- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">OBJECTS,
    FUNCTIONS, AND TYPES</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">对象、函数和类型</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'In this chapter, you’ll learn about objects, functions, and types. We’ll examine
    how to declare variables (objects with named identifiers) and functions, take
    the addresses of objects, and dereference those object pointers. Each object or
    function instance has a type. You’ve already seen some types that are available
    to C programmers. The first thing you’ll learn in this chapter is one of the last
    things that I learned: every type in C is either an object type or a function
    type.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习对象、函数和类型。我们将探讨如何声明变量（具有命名标识符的对象）和函数，获取对象的地址，并解引用这些对象指针。每个对象或函数实例都有一个类型。你已经看到了一些C程序员可以使用的类型。本章中你将学到的第一件事，恰恰是我最后学到的：C中的每个类型都是对象类型或函数类型。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Entities</samp>
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">实体</samp>
- en: An *object* is storage in which you can represent values. To be precise, an
    object is defined by the C standard (ISO/IEC 9899:2024) as a “region of data storage
    in the execution environment, the contents of which can represent values,” with
    the added note, “when referenced, an object can be interpreted as having a particular
    type.” A variable is an example of an object.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象*是用于表示值的存储空间。准确来说，C标准（ISO/IEC 9899:2024）将对象定义为“执行环境中的一个数据存储区域，其内容可以表示值”，并补充说明，“当引用时，对象可以被解释为具有特定类型。”变量就是一个对象的例子。'
- en: '*Variables* have a declared *type* that tells you the kind of object its value
    represents. For example, an object with type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    contains an integer value. Type is important because the collection of bits that
    represent one type of object can have a different value if interpreted as a different
    type of object. For example, the number 1 is represented in the IEEE Standard
    for Floating-Point Arithmetic by the bit pattern <samp class="SANS_TheSansMonoCd_W5Regular_11">0x3f800000</samp>
    (IEEE 754-2019). But if you were to interpret this same bit pattern as an integer,
    you’d get the value 1,065,353,216 instead of 1.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量*有一个声明的*类型*，它告诉你变量值所代表的对象类型。例如，类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>的对象包含一个整数值。类型很重要，因为代表某种类型对象的比特集合，如果被解释为另一种类型的对象，可能会得到不同的值。例如，数字1在IEEE浮点运算标准中由比特模式<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x3f800000</samp>表示（IEEE 754-2019）。但如果你将这个比特模式解释为一个整数，你会得到值1,065,353,216，而不是1。'
- en: '*Functions* are not objects but do have types. A function type is characterized
    by both its return type and the number and types of its parameters.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*不是对象，但它们有类型。函数类型由其返回类型以及参数的数量和类型来描述。'
- en: The C language also has *pointers*, which can be thought of as an *address*—a
    location in memory where an object or function is stored.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: C语言中也有*指针*，它可以被看作是一个*地址*——内存中存储对象或函数的位置。
- en: Just like objects and functions, object pointers and function pointers are different
    things and must not be interchanged. In the following section, you’ll write a
    simple program that attempts to swap the values of two variables to help you better
    understand objects, functions, pointers, and types.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对象和函数一样，对象指针和函数指针是不同的东西，不能互换。在接下来的部分中，你将编写一个简单的程序，尝试交换两个变量的值，帮助你更好地理解对象、函数、指针和类型。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Declaring Variables</samp>
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">声明变量</samp>
- en: When you declare a variable, you assign it a type and provide it a name, or
    *identifier*, by which the variable is referenced. Optionally, you can also *initialize*
    the variable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明一个变量时，你为它分配一个类型，并提供一个名称或*标识符*，通过该标识符引用该变量。你也可以选择性地*初始化*该变量。
- en: '[Listing 2-1](chapter2.xhtml#Lis2-1) declares two integer objects with initial
    values. This simple program also declares, but doesn’t define, a <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function to swap those values.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-1](chapter2.xhtml#Lis2-1)声明了两个具有初始值的整数对象。这个简单的程序还声明了一个`swap`函数来交换这些值，但没有定义它。'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-1: A program meant
    to swap two integers</samp>'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 2-1：一个用于交换两个整数的程序</samp>
- en: This example program shows a <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function with a single *compound statement* that includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    characters and all the statements between them (also referred to as a *block*).
    We define two variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, within the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function. We declare the variables as having the type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and initialize them to <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>, respectively. Each
    variable must have a declaration. The <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function then calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function ❷ to try to swap the values of the two integers. The <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function is declared in this program ❶ but not defined. We’ll look at some possible
    implementations of this function later in this section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例程序展示了一个包含单个*复合语句*的 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    函数，该复合语句包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp> 字符以及其中的所有语句（也称为*块*）。我们在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 函数内定义了两个变量，<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>。我们将这两个变量声明为类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，并分别初始化为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>。每个变量必须有一个声明。然后，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 函数调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    函数 ❷ 尝试交换这两个整数的值。<samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> 函数在本程序中声明了
    ❶，但没有定义。我们将在本节后面探讨该函数的一些可能实现。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Swapping Values,
    First Attempt</samp>
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">交换值，第一次尝试</samp>
- en: Each object has a storage duration that determines its *lifetime*, which is
    the time during program execution for which the object exists, has storage, has
    a constant address, and retains its last-stored value. Objects must not be referenced
    outside their lifetime.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都有一个存储持续时间，决定了它的*生命周期*，即在程序执行过程中，对象存在、占用存储、拥有固定地址并保持最后存储的值的时间。对象不得在其生命周期外被引用。
- en: Local variables such as <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> from [Listing 2-1](chapter2.xhtml#Lis2-1)
    have *automatic storage duration*, meaning that they exist until execution leaves
    the block in which they’re declared. We’re going to try to swap the values stored
    in these two variables. [Listing 2-2](chapter2.xhtml#Lis2-2) shows our first attempt
    to implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本地变量，如来自 [列表 2-1](chapter2.xhtml#Lis2-1) 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>，具有*自动存储持续时间*，意味着它们存在直到程序执行离开声明它们的块为止。我们将尝试交换这两个变量中存储的值。[列表
    2-2](chapter2.xhtml#Lis2-2) 展示了我们第一次尝试实现 <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    函数的代码。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-2: A first attempt
    at implementing the</samp> <samp class="I">swap</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 2-2：第一次尝试实现</samp> <samp
    class="I">swap</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function is declared
    with two parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, that we use to pass arguments
    to this function. C distinguishes between *parameters*, which are objects declared
    as part of the function declaration that acquire a value on entry to the function,
    and *arguments*, which are comma-separated expressions we include in the function
    call expression. We also declare a temporary variable <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function and initialize it
    to the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>. This variable
    is used to temporarily save the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    so that it’s not lost during the swap.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> 函数声明了两个参数，<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>，我们用它们来向这个函数传递参数。C 区分
    *参数* 和 *实参*，其中参数是作为函数声明的一部分声明的对象，在进入函数时会获取一个值，而实参是我们在函数调用表达式中传入的以逗号分隔的表达式。我们还在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> 函数中声明了一个临时变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>，其类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，并将其初始化为 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    的值。此变量用于临时保存 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 中存储的值，以免在交换过程中丢失。
- en: 'We can now run the generated executable to test the program:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行生成的可执行文件来测试程序：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This result may be surprising. The variables <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> were initialized to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>,
    respectively. The first call to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    within the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function
    shows that these two values were swapped, but the second call to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> shows the original
    values unchanged. Let’s examine what happened.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果可能让人感到惊讶。变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 分别被初始化为 <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>。第一次在 <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    函数中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> 调用显示这两个值已被交换，但在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 中的第二次 <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    调用则显示原始值未变。让我们看看发生了什么。
- en: C is a *call-by-value* (also called a *pass-by-value*) language, which means
    that when you provide an argument to a function, the value of that argument is
    copied into a distinct variable for use within the function. The <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function assigns the values of the objects you pass as arguments to their respective
    parameters. When the parameter values in the function are changed, the argument
    values in the caller are unaffected because they are distinct objects. Consequently,
    the variables <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> retain their original values
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> during the second
    call to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>. The goal
    of the program was to swap the values of these two objects. By testing the program,
    we’ve discovered it has a bug, or defect.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: C 是一种 *按值传递*（也称为 *传值*）语言，这意味着当你向函数提供一个实参时，该实参的值会被复制到一个独立的变量中供函数使用。<samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    函数将你作为实参传递的对象的值赋给它们各自的参数。当函数中的参数值发生变化时，调用者中的实参值不会受到影响，因为它们是独立的对象。因此，在第二次调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> 时，变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 保持其在 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    中的原始值。程序的目标是交换这两个对象的值。通过测试程序，我们发现它存在一个 bug 或缺陷。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Swapping Values,
    Second Attempt</samp>
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">交换值，第二次尝试</samp>
- en: To repair this bug, we can use pointers to rewrite the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function. We use the indirection (<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>)
    operator to both declare pointers and dereference them, as shown in [Listing 2-3](chapter2.xhtml#Lis2-3).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个 bug，我们可以使用指针重写 <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    函数。我们使用间接操作符 (<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>) 来声明指针并对其解引用，如
    [Listing 2-3](chapter2.xhtml#Lis2-3) 所示。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-3: The revised</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">swap</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    using pointers</samp>'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-3: 修改后的</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">swap</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数使用指针</samp>'
- en: When used in a function declaration or definition, <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    acts as part of a pointer declarator indicating that the parameter is a pointer
    to an object or function of a specific type. In the rewritten <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function, we declare two parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp>, both having the type
    pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当在函数声明或定义中使用时，<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> 作为指针声明符的一部分，表示该参数是指向某种类型的对象或函数的指针。在重写的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> 函数中，我们声明了两个参数，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pa</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp>，它们的类型都是指向
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 的指针。
- en: 'The unary <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator denotes
    indirection. If its operand has type pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>,
    the result of the operation has type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>.
    For example, consider the following assignment:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一元操作符 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> 表示间接引用。如果其操作数是指向
    <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> 的指针类型，则操作结果的类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>。例如，考虑以下赋值：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This replaces the value of the pointer <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp>
    with the value of the pointer <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp>.
    Now consider the assignment in the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指针 <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp> 的值替换为指针 <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp>
    的值。现在考虑 <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> 函数中的赋值操作：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">*pb</samp> operation reads
    the value referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp>,
    while the <samp class="SANS_TheSansMonoCd_W5Regular_11">*pa</samp> operation reads
    the location referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp>.
    The value referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp>
    is then written to the location referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp>.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">*pb</samp> 操作读取 <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp>
    引用的值，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">*pa</samp> 操作读取 <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp>
    引用的位置。然后将 <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp> 引用的值写入 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">pa</samp> 引用的位置。
- en: 'When you call the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, you must
    also place an ampersand (<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>)
    character before each variable name:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 中调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    函数时，你还必须在每个变量名前加上一个 &（<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>）字符：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The unary <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> (*address-of*)
    operator generates a pointer to its operand. This change is necessary because
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function now accepts
    arguments of type pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    instead of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一元操作符 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>（*取地址*）操作符生成其操作数的指针。这个变化是必要的，因为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> 函数现在接受指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    类型的指针作为参数，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型。
- en: '[Listing 2-4](chapter2.xhtml#Lis2-4) shows the entire <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    program with comments describing the objects created during execution of this
    code and their values.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-4](chapter2.xhtml#Lis2-4) 显示了整个 <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    程序，注释描述了在执行此代码期间创建的对象及其值。'
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-4: A simulated call
    by reference</samp>'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 2-4：模拟的引用调用</samp>
- en: Upon entering the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function block, the variables <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> are initialized to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>,
    respectively. The code then takes the addresses of these objects and passes them
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function as arguments.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 函数块后，变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 分别被初始化为 <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">17</samp>。然后，代码获取这些对象的地址，并将它们作为参数传递给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> 函数。
- en: Within the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> function,
    the parameters <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">pb</samp> are now both declared as type
    pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and contain
    copies of the arguments passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    from the calling function (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>).
    These address copies still refer to the exact same objects, so when the values
    of their referenced objects are swapped in the <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp>
    function, the contents of the original objects declared in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    are also swapped. This approach simulates *call by* reference (also known as *pass
    by* reference) by generating object addresses, passing those by value, and then
    dereferencing the copied addresses to access the original objects.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> 函数内，参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">pa</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">pb</samp> 现在都声明为指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    类型的指针，并包含传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> 的调用函数（在本例中为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>）的参数副本。这些地址副本仍然指向完全相同的对象，因此当它们所引用对象的值在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">swap</samp> 函数中交换时，<samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    中声明的原始对象的内容也会被交换。这种方法通过生成对象地址、按值传递这些地址，然后解引用复制的地址来访问原始对象，从而模拟了 *按引用调用*（也称为 *按引用传递*）。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Object Types</samp>
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">对象类型</samp>
- en: This section introduces object types in C. Specifically, we’ll cover the Boolean
    type, character types, and arithmetic types (including both integer and floating
    types).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 C 中的对象类型。具体来说，我们将涵盖布尔类型、字符类型和算术类型（包括整数类型和浮点类型）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Boolean</samp>
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">布尔</samp>
- en: A Boolean data type has one of two possible values (<samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>) that represent
    the two truth values of logic and Boolean algebra. Objects declared as <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    can store only the values <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔数据类型有两个可能的值（<samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">false</samp>），表示逻辑和布尔代数中的两个真值。声明为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> 的对象只能存储 <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> 这两个值。
- en: 'The following example declares a function called <samp class="SANS_TheSansMonoCd_W5Regular_11">arm_detonator</samp>
    that takes a single <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> argument
    and returns a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例声明了一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">arm_detonator</samp>
    的函数，该函数接受一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型的参数，并返回一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> 类型的值：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">arm_missile</samp> function
    calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">arm_detonator</samp> function
    and assigns the return value to the Boolean variable <samp class="SANS_TheSansMonoCd_W5Regular_11">armed</samp>.
    This value can then be tested to determine whether the missile is armed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">arm_missile</samp> 函数调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">arm_detonator</samp> 函数，并将返回值赋给布尔变量 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">armed</samp>。然后，可以测试该值以确定导弹是否已准备就绪。
- en: Historically, Boolean values were represented by integers and still behave as
    integers. They can be stored in integer variables and used anywhere integers would
    be valid, including in indexing, arithmetic, parsing, and formatting. C guarantees
    that any two true values will compare equally (which was impossible to achieve
    before the introduction of the <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    type). You should use the <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    type to represent Boolean values.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，布尔值是通过整数表示的，并且仍然表现得像整数一样。它们可以存储在整数变量中，并可以在任何整数有效的地方使用，包括索引、算术运算、解析和格式化。C
    语言保证任何两个 `true` 值会相等比较（这是在引入 <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    类型之前无法实现的）。你应该使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> 类型来表示布尔值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Character</samp>
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">字符</samp>
- en: 'The C language defines the following character types: <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>. Each compiler implementation defines <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    to have the same alignment, size, range, representation, and behavior as either
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>. Regardless of the choice made, <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    is a separate type from the other two and is incompatible with both.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言定义了以下字符类型：<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>。每个编译器实现都将 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    定义为与 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> 具有相同的对齐方式、大小、范围、表示和行为。无论选择哪一种，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 都是一个独立的类型，与其他两个类型不兼容。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> type is commonly
    used to represent character data in C language programs. Objects of type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp> can represent the *basic execution
    character set*—the minimum set of characters required in the execution environment—including
    upper- and lowercase letters, the 10 decimal digits, the space character, punctuation,
    and control characters. The <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    type is inappropriate for integer data; use <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> to represent small, signed integer values, and use <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> to represent small, unsigned integer values.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 类型通常用于表示 C 语言程序中的字符数据。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 类型的对象可以表示 *基本执行字符集* —— 执行环境中所需的最小字符集，包括大小写字母、10
    个十进制数字、空格字符、标点符号和控制字符。<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    类型不适用于整数数据；使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>
    来表示小的有符号整数值，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>
    来表示小的无符号整数值。
- en: The size of objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    is always 1 byte, and its width is <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp>
    bits. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp> macro
    from <samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp> defines the
    number of bits in a byte. The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp>
    macro cannot be less than 8, and on most modern platforms, it is 8.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 类型的对象大小始终为 1 字节，宽度为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp> 位。<samp class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp>
    宏来自 <samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp>，用于定义一个字节中的位数。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CHAR_BIT</samp> 宏的值不能小于 8，并且在大多数现代平台上，其值为
    8。
- en: The basic execution character set suits the needs of many conventional data
    processing applications, but its lack of non-English letters is an obstacle to
    acceptance by international users. To address this need, the C standards committee
    specified a new wide type to allow large character sets. You can represent the
    characters of a large character set as *wide characters* by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    type, which generally takes more space than a basic character. Typically, implementations
    choose 16 or 32 bits to represent a wide character. The C standard library provides
    functions that support both narrow and wide character types. The <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    type was not designed to support Unicode and has consequently fallen out of favor
    for most implementations with the notable exception of Microsoft Visual Studio.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的执行字符集适用于许多常规数据处理应用，但其缺乏非英语字母是国际用户接受的障碍。为了解决这一需求，C 标准委员会规定了一种新的宽字符类型，以允许更大的字符集。你可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> 类型将大字符集的字符表示为 *宽字符*，它通常占用比基本字符更多的空间。通常，实施会选择
    16 位或 32 位来表示一个宽字符。C 标准库提供了支持窄字符和宽字符类型的函数。<samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    类型并未设计用来支持 Unicode，因此在大多数实现中已逐渐被弃用，微软 Visual Studio 是一个显著的例外。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Arithmetic</samp>
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">算术</samp>
- en: C provides several *arithmetic types* that can be used to represent integers,
    enumerators, and floating-point values. [Chapter 3](chapter3.xhtml) covers some
    of these in more detail, but here’s a brief introduction.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: C 提供了几种 *算术类型*，可用于表示整数、枚举值和浮点值。[第3章](chapter3.xhtml)详细介绍了其中的一些，但这里简要介绍一下。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Integer</samp>'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">整数</samp>'
- en: '*Signed integer types* can be used to represent negative numbers, positive
    numbers, and zero. The standard signed integer types include <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">short int</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp>.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*带符号整数类型* 可以用于表示负数、正数和零。标准的带符号整数类型包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">short int</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp>。'
- en: 'For each signed integer type, there is a corresponding *unsigned integer type*
    that uses the same amount of storage: <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned short int</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long int</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long
    long int</samp>. The unsigned types can represent positive numbers and zero. These
    unsigned integer types along with type <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    make up the standard unsigned integer types.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种带符号整数类型，都有一个相应的 *无符号整数类型*，它使用相同的存储空间：<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned short int</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long int</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long
    long int</samp>。无符号类型可以表示正数和零。这些无符号整数类型以及类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    组成了标准的无符号整数类型。
- en: Except for <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> itself,
    the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> may be omitted
    in the declarations for these types, so you might, for example, declare a type
    by using <samp class="SANS_TheSansMonoCd_W5Regular_11">long long</samp> instead
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp>.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 本身外，关键字 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    在这些类型的声明中可以省略，因此你可以通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">long long</samp>
    来声明类型，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp>。
- en: The signed and unsigned integer types are used to represent integers of various
    widths. Each platform determines the width for each of these types, given some
    constraints. Each type has a minimum representable range. The types are ordered
    by width, guaranteeing that wider types are at least as large as narrower types.
    This means that an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    long int</samp> can represent all values that an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp> can represent, an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp> can represent all values that can be represented by an object of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, and so forth. The implementation-defined
    minimum and maximum representable values for integer types are specified in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp> header file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有符号和无符号整数类型用于表示各种宽度的整数。每个平台确定每种类型的宽度，给定一些约束。每种类型都有一个最小可表示范围。这些类型按宽度排序，确保更宽的类型至少与更窄的类型一样大。这意味着<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp>类型的对象可以表示<samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp>类型的对象可以表示的所有值，<samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp>类型的对象可以表示的所有值都可以由<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>类型的对象表示，依此类推。整数类型的实现定义的最小和最大可表示值在<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp>头文件中指定。
- en: '*Extended integer types* may be provided in addition to the standard integer
    types. They are implementation defined, meaning that their width, precision, and
    behavior are up to the compiler. Extended integer types are typically larger than
    the standard integer types (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">__int128</samp>).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*扩展整数类型*可能会在标准整数类型之外提供。它们是实现定义的，这意味着它们的宽度、精度和行为取决于编译器。扩展整数类型通常比标准整数类型大（例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">__int128</samp>）。'
- en: In addition to the standard and extended integer types, C23 adds *bit-precise
    integer types*. These types accept an operand specifying the width of the integer,
    so a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(32)</samp> is a signed
    32-bit integer, and an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    _BitInt(32)</samp> is an unsigned 32-bit integer. Bit-precise integer types do
    not require their width to be a power of two; the maximum width supported is specified
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">BITINT_MAXWIDTH</samp> (which
    must be at least the same as the width of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long long</samp>).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准和扩展整数类型外，C23还增加了*比特精确整数类型*。这些类型接受一个操作数来指定整数的宽度，因此<samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(32)</samp>是一个带符号的32位整数，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned _BitInt(32)</samp>则是一个无符号的32位整数。比特精确整数类型不要求它们的宽度是2的幂；支持的最大宽度由<samp
    class="SANS_TheSansMonoCd_W5Regular_11">BITINT_MAXWIDTH</samp>指定（其宽度至少与<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long long</samp>的宽度相同）。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type is typically
    assigned the natural width suggested by the architecture of the execution environment
    (for example, 16 bits on a 16-bit architecture and 32 bits on a 32-bit or 64-bit
    architecture). You can specify actual-width integers by using type definitions
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdint.h></samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><inttypes.h></samp> header, like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">uint32_t</samp>. These headers also provide
    type definitions for the greatest-width integer types: <samp class="SANS_TheSansMonoCd_W5Regular_11">uintmax_t</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">intmax_t</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">intmax_t</samp>
    type, for example, can represent any value of any signed integer type with the
    possible exceptions of signed bit-precise integer types and of signed extended
    integer types.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>类型通常根据执行环境的架构被赋予自然的宽度（例如，在16位架构上是16位，在32位或64位架构上是32位）。您可以通过使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><stdint.h></samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11"><inttypes.h></samp>头文件中的类型定义（如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">uint32_t</samp>）来指定实际宽度整数。这些头文件还为最大宽度整数类型提供类型定义：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">uintmax_t</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">intmax_t</samp>。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">intmax_t</samp>类型可以表示任何带符号整数类型的值，可能例外的是带符号比特精确整数类型和带符号扩展整数类型。
- en: '[Chapter 3](chapter3.xhtml) covers integer types in excruciating detail.  ####
    <samp class="SANS_Futura_Std_Bold_Condensed_B_11">enum</samp>'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](chapter3.xhtml)详细讲解了整数类型。  #### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">enum</samp>'
- en: 'An *enumeration*, or <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>,
    allows you to define a type that assigns names (*enumerators*) to integer values
    in cases with an enumerable set of constant values. The following are examples
    of enumerations:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*枚举*，或称<samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>，允许你定义一个类型，在有枚举常量集合的情况下为整数值指定名称（*枚举量*）。以下是枚举的示例：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you don’t specify a value to the first enumerator with the <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    operator, the value of its enumeration constant is 0, and each subsequent enumerator
    without an <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> adds 1 to the
    value of the previous enumeration constant. Consequently, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">sun</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">day</samp> enumeration is
    0, <samp class="SANS_TheSansMonoCd_W5Regular_11">mon</samp> is 1, and so forth.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: "如果你没有使用<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">=</samp>操作符为第一个枚举量指定值，则其枚举常量的值为0，之后每个没有<samp\
    \ class=\"SANS_TheSansMonoCd_W5Regular_11\">=</samp>的枚举量将基于前一个枚举常量的值加1。因此，<samp\
    \ class=\"SANS_TheSansMonoCd_W5Regular_11\">sun</samp>在<\tsamp class=\"SANS_TheSansMonoCd_W5Regular_11\"\
    >day</samp>枚举中的值为0，<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">mon</samp>的值为1，以此类推。"
- en: You can also assign specific values to each enumerator, as shown by the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cardinal_points</samp> enumeration. Using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> with enumerators may produce
    enumeration constants with duplicate values, which can be a problem if you incorrectly
    assume that all the values are unique. The <samp class="SANS_TheSansMonoCd_W5Regular_11">months</samp>
    enumeration sets the first enumerator at 1, and each subsequent enumerator that
    isn’t specifically assigned a value will be incremented by 1.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为每个枚举量指定特定的值，如<samp class="SANS_TheSansMonoCd_W5Regular_11">cardinal_points</samp>枚举所示。使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp>与枚举量可能会导致枚举常量具有重复的值，如果你错误地假设所有值都是唯一的，这可能会成为问题。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">months</samp>枚举将第一个枚举量的值设为1，之后每个未特定赋值的枚举量将递增1。
- en: 'Starting with C23, you can specify the underlying type of the enumeration.
    For portability and other reasons (Meneide and Pygott 2022), it is always better
    to specify the enumeration type. In the following example, the enumeration constant
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a0</samp> can be assigned the value
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFFFFFFFFFFFFFFFFULL</samp> because
    the type is specified as <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long long</samp>:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从C23开始，你可以指定枚举的底层类型。为了移植性和其他原因（Meneide和Pygott 2022），最好始终指定枚举类型。在以下示例中，枚举常量<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a0</samp>可以被赋值为<samp class="SANS_TheSansMonoCd_W5Regular_11">0xFFFFFFFFFFFFFFFFULL</samp>，因为类型被指定为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned long long</samp>：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An omitted type is implementation defined. Visual C++ uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp> for the type, and GCC uses an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略类型，则由实现定义。Visual C++使用<samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>作为类型，而GCC则使用<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Floating</samp>
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Floating</samp>
- en: Floating-point arithmetic is similar to, and often used as a model for, the
    arithmetic of real numbers. The C language supports a variety of floating-point
    representations including, on most systems, representations in the IEEE Standard
    for Floating-Point Arithmetic (IEEE 754-2019). ISO/IEC 60559:2011 has content
    identical to IEEE 754-2019 but is referenced by the C standard because it is published
    by the same standards organization. The choice of floating-point representation
    is implementation defined. [Chapter 3](chapter3.xhtml) covers floating types in
    detail.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点运算与实数运算相似，并且常常作为实数运算的模型。C语言支持多种浮点表示，包括大多数系统上采用的IEEE浮点运算标准（IEEE 754-2019）。ISO/IEC
    60559:2011与IEEE 754-2019内容相同，但由于它是由同一标准组织发布的，因此C标准引用了它。浮点表示的选择由实现决定。[第3章](chapter3.xhtml)详细讲解了浮点类型。
- en: 'The C language supports three standard floating types: <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp>. The set of values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    is a subset of the set of values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>;
    the set of values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    is a subset of the set of values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp>.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: C语言支持三种标准浮动类型：<samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp>。类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> 的值集是类型
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 的值集的子集；类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    的值集是类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp> 的值集的子集。
- en: C23 adds three *decimal floating types* (ISO/IEC TS 18661-2:2015), designated
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal32</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal64</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal128</samp>. Respectively,
    these have the decimal32, decimal64, and decimal128 IEC 60559 formats.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: C23 添加了三种*十进制浮动类型*（ISO/IEC TS 18661-2:2015），分别为 <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal32</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">_Decimal64</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal128</samp>。这些类型分别对应于十进制32、十进制64和十进制128
    IEC 60559 格式。
- en: The standard floating types and the decimal floating types are collectively
    called the *real floating types*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 标准浮动类型和十进制浮动类型统称为*实数浮动类型*。
- en: There are also three *complex types*, designated as <samp class="SANS_TheSansMonoCd_W5Regular_11">float
    complex</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">double complex</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">long double complex</samp>.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 还有三种*复杂类型*，分别为 <samp class="SANS_TheSansMonoCd_W5Regular_11">float complex</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double complex</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double complex</samp>。
- en: The real floating and complex types are collectively called the *floating types*.
    [Figure 2-1](chapter2.xhtml#fig2-1) shows the hierarchy of floating types.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 实数浮动类型和复杂类型统称为*浮动类型*。[图 2-1](chapter2.xhtml#fig2-1)展示了浮动类型的层次结构。
- en: '![](../images/f02001.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/f02001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: The hierarchy of
    floating types</samp>'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-1：浮动类型的层次结构</samp>
- en: Complex types and decimal floating types are not covered in detail in this book.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本书没有详细介绍复杂类型和十进制浮动类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">void</samp>
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">void</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type is a rather
    strange type. The keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    (by itself) means “cannot hold any value.” For example, you can use it to indicate
    that a function doesn’t return a value or as the sole parameter of a function
    to indicate that the function takes no arguments. On the other hand, the *derived
    type* <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> means that the
    pointer can reference *any* object.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 类型是一个相当特殊的类型。关键字 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>（单独使用时）表示“不能持有任何值”。例如，你可以使用它来表示一个函数不返回任何值，或者作为函数的唯一参数，表示该函数不接受任何参数。另一方面，*派生类型*
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> 表示该指针可以引用*任何*对象。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Derived Types</samp>
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">派生类型</samp>
- en: '*Derived types* are constructed from other types. These include function types,
    pointer types, array types, type definitions, structure types, and union types—all
    of which are covered here.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*派生类型*是由其他类型构造而来的。它们包括函数类型、指针类型、数组类型、类型定义、结构类型和联合类型——所有这些都会在此涵盖。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Function</samp>
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">函数</samp>
- en: A *function type* is derived from the return type and the number and types of
    its parameters. A function can return any complete object type except for an array
    type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数类型*由返回类型和参数的数量及类型派生而来。一个函数可以返回任何完整的对象类型，但不能返回数组类型。'
- en: When you declare a function, you use the *function declarator* to specify the
    name of the function and the return type. If the declarator includes a parameter
    type list and a definition, the declaration of each parameter must include an
    identifier, except parameter lists with only a single parameter of type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, which needs no identifier.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明一个函数时，使用 *函数声明符* 来指定函数的名称和返回类型。如果声明符包括参数类型列表和定义，则每个参数的声明必须包含一个标识符，除非参数列表只有一个类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 的参数，这种情况不需要标识符。
- en: 'Here are a few function type declarations:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些函数类型声明：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, we declare two functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">fprime</samp>, with no parameter
    that returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. Next,
    we declare a function <samp class="SANS_TheSansMonoCd_W5Regular_11">fip</samp>
    with no parameters that return a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Finally, we declare two functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>, each returning <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp> and taking two parameters
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明两个函数，<samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">fprime</samp>，它们没有参数，返回一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。接下来，我们声明一个函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">fip</samp>，没有参数，返回一个指向
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 的指针。最后，我们声明两个函数，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">g</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>，每个函数都返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 并接受两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    类型的参数。
- en: Specifying parameters with identifiers (as done here with <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>)
    can be problematic if an identifier is a macro. However, providing parameter names
    is good practice for self-documenting code, so omitting the identifiers (as done
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>) is not typically
    recommended.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 指定带有标识符的参数（如这里的 <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>）可能会有问题，尤其是当标识符是宏时。然而，为参数提供名称是自文档化代码的好习惯，因此通常不建议省略标识符（就像在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp> 中所做的那样）。
- en: In a function declaration, specifying parameters is optional. However, failing
    to do so can be problematic. Prior to C23, <samp class="SANS_TheSansMonoCd_W5Regular_11">fip</samp>
    declares a function accepting any number of arguments of any type and returning
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. The same function
    declaration for <samp class="SANS_TheSansMonoCd_W5Regular_11">fip</samp> in C++
    declares a function accepting no arguments and returning an <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp>. Starting with C23, a function declarator with an empty parameter list
    declares a prototype for a function that takes no arguments (like it does in C++).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数声明中，指定参数是可选的。然而，如果不指定，可能会引发问题。在 C23 之前，<samp class="SANS_TheSansMonoCd_W5Regular_11">fip</samp>
    声明了一个接受任意数量的任意类型参数并返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>
    的函数。相同的 <samp class="SANS_TheSansMonoCd_W5Regular_11">fip</samp> 函数声明在 C++ 中声明了一个接受无参数并返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp> 的函数。从 C23 开始，具有空参数列表的函数声明符声明了一个不接受任何参数的函数原型（就像在
    C++ 中一样）。
- en: A function type is also known as a *function prototype*. A function prototype
    informs the compiler about the number and types of parameters a function accepts.
    Compilers use this information to verify that the correct number and type of parameters
    are used in the function definition and any calls to the function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 函数类型也被称为 *函数原型*。函数原型向编译器告知函数接受的参数数量和类型。编译器使用这些信息来验证函数定义和任何对函数的调用中使用了正确数量和类型的参数。
- en: 'The *function definition* provides the actual implementation of the function.
    Consider the following function definition:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数定义* 提供了函数的实际实现。考虑以下函数定义：'
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The return type specifier is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>;
    the function declarator is <samp class="SANS_TheSansMonoCd_W5Regular_11">max(int
    a, int b)</samp>; and the function body is <samp class="SANS_TheSansMonoCd_W5Regular_11">{return
    a > b ? a : b;}</samp>. The specification of a function type must not include
    any type qualifiers (see “Type Qualifiers” on [page 31](#pg_31)). The function
    body itself uses the conditional operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">?
    :</samp>), which is explained in [Chapter 4](chapter4.xhtml). This expression
    states that if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is greater
    than <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, return <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>;
    otherwise, return <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '返回类型说明符是 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>；函数声明是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">max(int a, int b)</samp>；函数体是 <samp class="SANS_TheSansMonoCd_W5Regular_11">{return
    a > b ? a : b;}</samp>。函数类型的规范不应包含任何类型限定符（见“类型限定符”部分，参见 [第31页](#pg_31)）。函数体本身使用了条件运算符（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">? :</samp>），这一运算符在 [第4章](chapter4.xhtml)
    中有解释。该表达式表示，如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 大于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>，则返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>；否则，返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pointer</samp>
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">指针</samp>
- en: A *pointer type* is derived from a function or object type called the *referenced
    type*. A pointer type derived from the referenced type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    is called a *pointer to* <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>.
    A pointer provides a reference to an entity of the referenced type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*指针类型* 是由称为 *引用类型* 的函数或对象类型派生而来。由引用类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    派生的指针类型称为指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> 的指针。指针提供对引用类型实体的引用。'
- en: 'The following three declarations declare a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, and a
    pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三条声明声明了指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>、指向 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 和指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    的指针：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Each pointer is initialized to a null pointer constant. A null pointer constant
    can be specified as an integer constant expression with the value 0, <samp class="SANS_TheSansMonoCd_W5Regular_11">(void
    *)0</samp>, or the predefined constant <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> macro is defined
    in <samp class="SANS_TheSansMonoCd_W5Regular_11"><stddef.h></samp>. If a null
    pointer constant is converted to a pointer type, the resulting null pointer is
    guaranteed to compare unequally to a pointer to any object or function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每个指针都初始化为一个空指针常量。空指针常量可以指定为值为 0 的整数常量表达式、<samp class="SANS_TheSansMonoCd_W5Regular_11">(void
    *)0</samp>，或者预定义常量 <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> 宏在 <samp class="SANS_TheSansMonoCd_W5Regular_11"><stddef.h></samp>
    中定义。如果空指针常量被转换为指针类型，则生成的空指针保证与指向任何对象或函数的指针进行比较时不相等。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp> constant was
    introduced in C23 and has advantages to using <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>
    (Gustedt 2022). [Table 2-1](chapter2.xhtml#tab2-1) shows common values for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> and their associated types.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp> 常量是在 C23 中引入的，相较于使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>，它具有优势（Gustedt 2022）。[表
    2-1](chapter2.xhtml#tab2-1) 显示了 <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>
    的常见值及其关联类型。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 2-1:</samp> <samp class="SANS_Futura_Std_Book_11">Common
    Values for</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> <samp
    class="SANS_Futura_Std_Book_11">and Their Associated Types</samp>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 2-1：</samp> <samp class="SANS_Futura_Std_Book_11">NULL
    的常见值及其关联类型</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Value</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Type</samp>
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">值</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">类型</samp>
    |'
- en: '| --- | --- |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0L</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0L</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">(void *)0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">(void *)0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> |'
- en: 'These different types can have surprising results when invoking a type-generic
    macro with a <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> argument.
    The conditional expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(true
    ? 0 : NULL)</samp> is always defined, regardless of the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>.
    However, the conditional expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(true
    ? 1 : NULL)</samp> is a constraint violation if <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>
    has type <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '这些不同类型在调用具有<samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>参数的类型通用宏时可能会产生意想不到的结果。条件表达式<samp
    class="SANS_TheSansMonoCd_W5Regular_11">(true ? 0 : NULL)</samp>始终是定义的，无论<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>的类型是什么。然而，如果<samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>的类型是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>，则条件表达式<samp class="SANS_TheSansMonoCd_W5Regular_11">(true
    ? 1 : NULL)</samp>将违反约束。'
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> argument passed
    as a sentinel value to a variadic function, such as the Portable Operating System
    Interface (POSIX) <samp class="SANS_TheSansMonoCd_W5Regular_11">execl</samp> function,
    which expects a pointer, can have unexpected results. On most modern architectures,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> types have different sizes. If <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>
    is defined as 0 on such an architecture, an incorrectly sized argument is passed
    to the variadic function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将<samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>参数作为哨兵值传递给可变参数函数（例如便携式操作系统接口（POSIX）<samp
    class="SANS_TheSansMonoCd_W5Regular_11">execl</samp>函数，它期望一个指针）可能会产生意外的结果。在大多数现代架构上，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp>类型的大小是不同的。如果在这样的架构上将<samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>定义为0，那么会将大小不正确的参数传递给可变参数函数。
- en: 'Earlier in the chapter, I introduced the address-of (<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>)
    and indirection (<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>) operators.
    You use the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operator to
    take the address of an object or function. For example, taking the address of
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> object results in
    an address with the type pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我介绍了取地址运算符（<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>）和间接寻址运算符（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">*</samp>）。你使用<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>运算符来获取对象或函数的地址。例如，获取一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>对象的地址会得到一个指向<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>的指针地址：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The second declaration declares the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">ip</samp>
    as a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and initializes
    it to the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>. You
    can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operator
    on the result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个声明声明了变量<samp class="SANS_TheSansMonoCd_W5Regular_11">ip</samp>为指向<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>的指针，并将其初始化为<i>i</i>的地址。你还可以对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">*</samp>运算符的结果使用<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>运算符：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Dereferencing <samp class="SANS_TheSansMonoCd_W5Regular_11">ip</samp> using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator resolves to
    the actual object <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>. Taking
    the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">*ip</samp> using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> operator retrieves
    the pointer, so these two operations cancel each other out.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>运算符解引用<samp class="SANS_TheSansMonoCd_W5Regular_11">ip</samp>将解析为实际对象<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i</samp>。使用<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>运算符取<samp
    class="SANS_TheSansMonoCd_W5Regular_11">*ip</samp>的地址将检索到指针，因此这两个操作相互抵消。
- en: The unary <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> operator converts
    a pointer to a type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> into
    a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>. It denotes
    *indirection* and operates only on pointers. If the operand points to a function,
    the result of using the <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    operator is the function designator, and if it points to an object, the result
    is a value of the designated object. For example, if the operand is a pointer
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, the result of the
    indirection operator has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    If the pointer is not pointing to a valid object or function, the behavior is
    undefined.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一元 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> 运算符将指针类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    转换为类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> 的值。它表示 *间接寻址*，并且仅适用于指针。如果操作数指向一个函数，使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> 运算符的结果是函数指示符；如果操作数指向一个对象，结果是该对象的值。例如，如果操作数是指向
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型的指针，则间接寻址运算符的结果是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型。如果指针未指向有效的对象或函数，则行为是未定义的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array</samp>
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">数组</samp>
- en: 'An *array* is a contiguously allocated sequence of objects that all have the
    same element type. Array types are characterized by their element types and the
    number of elements in the array. Here we declare an array of 11 elements of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> identified by <samp class="SANS_TheSansMonoCd_W5Regular_11">ia</samp>
    and an array of 17 elements of type <samp class="SANS_TheSansMonoCd_W5Regular_11">pointer</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> identified by <samp
    class="SANS_TheSansMonoCd_W5Regular_11">afp</samp>:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组* 是一系列按顺序分配的对象，这些对象都具有相同的元素类型。数组类型的特征由其元素类型和数组中元素的数量决定。这里我们声明了一个包含 11 个元素的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型数组，标识为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ia</samp>，以及一个包含
    17 个元素的指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> 的指针类型数组，标识为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">afp</samp>：'
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can use square brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>)
    to identify an element of an array. For example, the following contrived code
    snippet creates the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"0123456789"</samp>
    to demonstrate how to assign values to the elements of an array:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用方括号（<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>）来标识数组的一个元素。例如，下面的示例代码演示了如何给数组的元素赋值，以创建字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"0123456789"</samp>：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first line declares an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    with a bound of 11\. This allocates sufficient storage to create a string with
    10 characters plus a null character. The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop iterates 10 times, with the values of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    ranging from 0 to 9\. Each iteration assigns the result of the expression <samp
    class="SANS_TheSansMonoCd_W5Regular_11">'0'</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp>.
    Following the end of the loop, the null character is copied to the final element
    of the array <samp class="SANS_TheSansMonoCd_W5Regular_11">str[10]</samp>, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> now contains the string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"0123456789"</samp>.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行声明了一个大小为 11 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 数组。这为创建一个包含
    10 个字符加一个空字符的字符串分配了足够的存储空间。<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环迭代 10 次，<samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 的值从 0 到 9。每次迭代将表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'0'</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 的结果赋值给 <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp>。循环结束后，空字符被复制到数组的最后一个元素
    <samp class="SANS_TheSansMonoCd_W5Regular_11">str[10]</samp>，此时 <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>
    包含字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">"0123456789"</samp>。
- en: In the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> is automatically converted
    to a pointer to the first member of the array (pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>),
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> has an unsigned integer
    type. The subscript (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>)
    and addition (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>) operators
    are defined so that <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp>
    is identical to <samp class="SANS_TheSansMonoCd_W5Regular_11">*(str</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i)</samp>.
    When <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> is an array object
    (as it is here), the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp>
    designates the <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>th element
    of the array (counting from 0). Because arrays are indexed starting at 0, the
    array <samp class="SANS_TheSansMonoCd_W5Regular_11">char str[11]</samp> is indexed
    from 0 to 10, with 10 being the last element, as referenced on the last line of
    this example.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp> 中，<samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>
    会自动转换为指向数组第一个成员的指针（指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    的指针），而 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 则是无符号整数类型。下标（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>）和加法（<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>）运算符被定义为使得
    <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp> 与 <samp class="SANS_TheSansMonoCd_W5Regular_11">*(str</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i)</samp>
    等价。当 <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> 是一个数组对象（如本例所示）时，表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">str[i]</samp> 表示数组的第 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    个元素（从 0 开始计数）。因为数组的下标是从 0 开始的，所以数组 <samp class="SANS_TheSansMonoCd_W5Regular_11">char
    str[11]</samp> 的下标范围是从 0 到 10，其中 10 为最后一个元素，如本例最后一行所示。
- en: 'If the operand of the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator is the result of a <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>
    operator, the result is as if the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator were removed and the <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>
    operator were changed to a <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    operator. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">&str[10]</samp>
    is the same as <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一元运算符 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> 的操作数是 <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>
    运算符的结果，那么结果就好像是移除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> 运算符并将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp> 运算符换成了 <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    运算符。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">&str[10]</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    是等效的：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can also declare multidimensional arrays. [Listing 2-5](chapter2.xhtml#Lis2-5)
    declares <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> in the function
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> as a two-dimensional
    3×5 array of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, also
    referred to as a *matrix*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以声明多维数组。[列表 2-5](chapter2.xhtml#Lis2-5) 在函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    中声明了一个二维 3×5 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> 数组，类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，也叫做 *矩阵*。
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-5: Matrix operations</samp>'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 2-5：矩阵运算</samp>
- en: 'More precisely, <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> is
    an array of three elements, each of which is an array of five elements of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. When you use the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i]</samp> ❶ (which is equivalent
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">*(arr+i)</samp>), the following
    occurs:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确地说，<samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> 是一个包含三个元素的数组，每个元素又是一个包含五个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型元素的数组。当你使用表达式 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">arr[i]</samp> ❶（等同于 <samp class="SANS_TheSansMonoCd_W5Regular_11">*(arr+i)</samp>）时，发生的情况如下：
- en: 1.  <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> is converted to
    a pointer to the initial array of five elements of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i]</samp>.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> 被转换为指向包含五个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型元素的初始数组的指针，从 <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i]</samp>
    开始。
- en: 2.  <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is scaled to the
    type of <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> by multiplying
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> by the size of one array
    of five <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> objects.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 通过将 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    乘以一个包含五个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 元素的数组的大小，将其缩放到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp> 的类型。
- en: 3.  The results from steps 1 and 2 are added.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  步骤 1 和步骤 2 的结果被相加。
- en: 4.  Indirection is applied to the sum to produce an array of five elements of
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  间接访问应用于总和，生成一个包含五个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    类型元素的数组。
- en: When used in the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i][j]</samp>
    ❷, that array is converted to a pointer to the first element of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    so <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i][j]</samp> produces an
    object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当在表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i][j]</samp> ❷ 中使用时，该数组会被转换为指向第一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型元素的指针，因此 <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[i][j]</samp>
    会生成一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型的对象。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Structure</samp>
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">结构体</samp>
- en: A *structure type* (also known as a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>)
    contains sequentially allocated members. Each member has its own name and may
    have a distinct type—unlike array elements, which must all be of the same type.
    Structures are like record types found in other programming languages.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*结构类型*（也称为 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>）包含按顺序分配的成员。每个成员都有自己的名称，并且可以有不同的类型——与数组元素不同，数组元素必须都是相同类型。结构体类似于其他编程语言中的记录类型。'
- en: Structures are useful for declaring collections of related objects and may be
    used to represent things such as a date, customer, or personnel record. They are
    especially useful for grouping objects that are frequently passed together as
    arguments to a function, so you don’t need to repeatedly pass individual objects
    separately.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体用于声明一组相关对象的集合，可以用来表示日期、客户或人员记录等。它们尤其在将经常一起作为参数传递给函数的对象进行分组时非常有用，这样你就不需要重复传递单独的对象。
- en: '[Listing 2-6](chapter2.xhtml#Lis2-6) declares a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    named <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp> with type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct sigrecord</samp> and a pointer
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">struct sigrecord</samp> named
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline_p</samp>.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-6](chapter2.xhtml#Lis2-6) 声明了一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp>
    的 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>，其类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    sigrecord</samp>，并且有一个指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    sigrecord</samp> 的指针，名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline_p</samp>。'
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-6: A</samp> <samp
    class="I">struct sigrecord</samp>'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 2-6: A</samp> <samp class="I">struct
    sigrecord</samp>'
- en: 'The structure has three member objects: <samp class="SANS_TheSansMonoCd_W5Regular_11">signum</samp>
    is an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signame</samp> is an array of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> consisting of 20 elements,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">sigdesc</samp> is an array of
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> consisting of 100
    elements.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构体有三个成员对象：<samp class="SANS_TheSansMonoCd_W5Regular_11">signum</samp> 是一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型的对象，<samp class="SANS_TheSansMonoCd_W5Regular_11">signame</samp>
    是一个包含 20 个元素的 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 类型数组，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sigdesc</samp> 是一个包含 100 个元素的 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    类型数组。
- en: Once you have defined a structure, you’ll likely want to reference its members.
    You reference members of an object of the structure type by using the structure
    member (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>) operator. If you
    have a pointer to a structure, you can reference its members with the structure
    pointer (<samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>) operator. [Listing
    2-7](chapter2.xhtml#Lis2-7) demonstrates the use of each operator.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了一个结构体，你可能会想要引用其成员。你可以使用结构体成员（<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>）运算符来引用结构体类型对象的成员。如果你有一个结构体的指针，可以使用结构体指针（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-></samp>）运算符来引用其成员。[列表 2-7](chapter2.xhtml#Lis2-7)
    展示了这两个运算符的使用。
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-7: Referencing structure
    members</samp>'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 2-7：引用结构体成员</samp>
- en: The first three lines of [Listing 2-7](chapter2.xhtml#Lis2-7) directly access
    members of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp> object
    by using the dot (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>) operator.
    We assign the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp>
    object to the <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline_p</samp> pointer
    ❶. In the final three lines of the program, we indirectly access the members of
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp> object by using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operator through the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline_p</samp> pointer.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-7](chapter2.xhtml#Lis2-7) 的前三行通过使用点号（<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>）运算符直接访问
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp> 对象的成员。我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp>
    对象的地址赋值给 <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline_p</samp> 指针 ❶。在程序的最后三行，我们通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline_p</samp> 指针使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp>
    运算符间接访问 <samp class="SANS_TheSansMonoCd_W5Regular_11">sigline</samp> 对象的成员。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Union</samp>
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">联合体</samp>
- en: '*Union types* are like structures, except that the memory used by the member
    objects overlaps. Unions provide multiple different ways to look at the same memory.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*联合类型*类似于结构体，不同之处在于成员对象使用的内存是重叠的。联合体提供了多种不同的方式来查看相同的内存。'
- en: '[Listing 2-8](chapter2.xhtml#Lis2-8) shows a union that contains a single member
    <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> of type <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> that contains
    three bitfields of type <samp class="SANS_TheSansMonoCd_W5Regular_11">uint32_t</samp>:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">significand</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">exponent</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">sign</samp>.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-8](chapter2.xhtml#Lis2-8) 显示了一个联合体，其中包含一个类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    的单一成员 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>，以及一个包含三个类型为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">uint32_t</samp> 的位域的 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">significand</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">exponent</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">sign</samp>。'
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-8: Decomposing a</samp>
    <samp class="I">float</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">using
    a</samp> <samp class="I">union</samp>'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 2-8：使用</samp> <samp class="I">union</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">分解一个</samp> <samp class="I">float</samp>
- en: This allows a (low-level) C programmer to use the entire floating-point value
    and examine (and possibly modify) its constituent parts. This union is not portable
    because implementations may use a different floating-point representation or endianness.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> tests to
    ensure this union matches the implementation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得（低级）C 程序员可以使用整个浮点值并检查（以及可能修改）其组成部分。这个联合体不可移植，因为不同的实现可能使用不同的浮点表示方式或字节序。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> 用于测试以确保该联合体与实现匹配。
- en: '[Listing 2-9](chapter2.xhtml#Lis2-9) shows a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    n</samp> that contains a member <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    and a union <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> that itself
    contains four members: <samp class="SANS_TheSansMonoCd_W5Regular_11">inode</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fnode</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">dnode</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ldnode</samp>.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-9](chapter2.xhtml#Lis2-9) 显示了一个包含成员 <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    和联合体 <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    n</samp>，其中联合体包含四个成员：<samp class="SANS_TheSansMonoCd_W5Regular_11">inode</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fnode</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">dnode</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">ldnode</samp>。'
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-9: Saving memory
    with a union</samp>'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 2-9：通过联合体节省内存</samp>
- en: This structure might be used in a tree, a graph, or some other data structure
    that contains differently typed nodes. The <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    member might contain a value between 0 and 3, which indicates the type of the
    value stored in the structure. It is declared directly in the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    n</samp> because it is common to all nodes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构体可能用于树、图或其他包含不同类型节点的数据结构。<samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    成员可能包含一个介于 0 到 3 之间的值，表示存储在结构体中的值的类型。由于它对所有节点都是通用的，它直接在 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    n</samp> 中声明。
- en: As with structures, you can access union members via the <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>
    operator. Using a pointer to a union, you can reference its members with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-></samp> operator. In [Listing 2-9](chapter2.xhtml#Lis2-9),
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">dnode</samp> member is referenced
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.dnode</samp>. Code that uses
    this union will typically check the type of the node by examining the value stored
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">n.type</samp> and then accessing
    the value using <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.inode</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.fnode</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.dnode</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.ldnode</samp>, depending
    on the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">n.type</samp>.
    Without the union, each node would contain separate storage for all four data
    types. The use of a union allows the same storage to be used for all union members.
    On the x86-64 GCC version 13.2 compiler, using a union saved 16 bytes per node.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与结构体一样，你可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> 运算符访问联合体成员。使用指向联合体的指针时，你可以通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-></samp> 运算符访问其成员。在 [示例 2-9](chapter2.xhtml#Lis2-9)
    中，<samp class="SANS_TheSansMonoCd_W5Regular_11">dnode</samp> 成员被引用为 <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.dnode</samp>。使用该联合体的代码通常会通过检查
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n.type</samp> 中存储的值来判断节点的类型，然后根据
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n.type</samp> 中存储的值访问 <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.inode</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">n.u.fnode</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.dnode</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">n.u.ldnode</samp>。如果没有联合体，每个节点将为所有四种数据类型分别分配存储空间。使用联合体可以让所有联合体成员共享同一存储空间。在
    x86-64 GCC 版本 13.2 编译器上，使用联合体每个节点节省了 16 字节。
- en: Unions are commonly used to describe network or device protocols in cases where
    you do not know in advance which protocol will be used.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 联合体通常用于描述网络或设备协议，特别是在你事先不知道将使用哪个协议的情况下。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Tags</samp>
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">标签</samp>
- en: '*Tags* are a special naming mechanism for structures, unions, and enumerations.
    For example, the identifier <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    in the following structure is a tag:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*标签* 是一种特殊的命名机制，用于结构体、联合体和枚举体。例如，以下结构体中的标识符 <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    就是一个标签：'
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'By itself, a tag is not a type name and cannot be used to declare a variable
    (Saks 2002). Instead, you must declare variables of this type as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用时，标签不是类型名称，不能用来声明变量（Saks 2002）。相反，你必须像以下示例一样声明该类型的变量：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The names of unions and enumerations are also tags and not types, meaning that
    they cannot be used alone to declare a variable. For example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 联合体和枚举体的名称也是标签，而不是类型，这意味着它们不能单独用于声明变量。例如：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The tags of structures, unions, and enumerations are defined in a separate
    *namespace* from ordinary identifiers. This allows a C program to have both a
    tag and another identifier with the same spelling in the same scope:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体、联合体和枚举的标签在一个与普通标识符分开的*命名空间*中定义。这使得C程序可以在同一个作用域内同时拥有标签和其他拼写相同的标识符：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can even declare an object <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以声明一个类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>的对象<samp
    class="SANS_TheSansMonoCd_W5Regular_11">s</samp>：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This may not be good practice, but it is valid C. You can think of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    tags as type names and define an alias for the tag by using a <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>.
    Here’s an example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是一个好的实践，但它是有效的C语言。你可以将<samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>标签看作类型名称，并通过使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>为标签定义一个别名。以下是一个示例：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This now allows you to declare variables of type <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>. The
    tag name in <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">union</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    is optional, so you can just dispense with it entirely:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在允许你声明类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>的变量，而不是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct s</samp>。<samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">union</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>中的标签名称是可选的，因此你可以完全不使用它：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This works fine except in the case of self-referential structures that contain
    pointers to themselves:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在包含指向自身的指针的自引用结构体中不起作用：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: C requires the use of tag types (<samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>)
    to include the tag name. The compiler will emit a diagnostic if you do not use
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct tnode</samp> in the declaration
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp>
    pointers. Consequently, you must declare a tag for the structure.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: C语言要求使用标签类型（<samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">union</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>）来包含标签名称。如果你在声明<samp
    class="SANS_TheSansMonoCd_W5Regular_11">left</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp>指针时没有使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct tnode</samp>，编译器会发出诊断信息。因此，你必须为结构体声明一个标签。
- en: 'You can create an alias for the structure using a <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>为结构体创建一个别名：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The declaration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> pointers must still
    use the tag name because the <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>
    name is not introduced until after the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    declaration is complete. You can use the same name for the tag and the <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>,
    but a common idiom is to name the tag something ugly such as <samp class="SANS_TheSansMonoCd_W5Regular_11">tnode_</samp>
    to encourage programmers to use the type name:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp>指针的声明仍然必须使用标签名，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>名称直到<samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>声明完成后才会引入。你可以为标签和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>使用相同的名称，但常见的惯用法是将标签命名为一些丑陋的名字，如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tnode_</samp>，以鼓励程序员使用类型名称：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can also define this type before the structure so that you can use it to
    declare the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">right</samp> members that refer to other
    objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">tnode</samp>:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在结构体之前定义此类型，以便使用它声明指向其他类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">tnode</samp>对象的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">left</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp>成员：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Type definitions can improve code readability beyond their use with structures.
    For example, given the following type definition
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 类型定义不仅能改善结构体的可读性，还能在代码中其它地方提高可读性。例如，给定以下类型定义：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'these declarations of the <samp class="SANS_TheSansMonoCd_W5Regular_11">signal</samp>
    function all specify the same type:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对 <samp class="SANS_TheSansMonoCd_W5Regular_11">signal</samp> 函数的声明都指定了相同的类型：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The last two declarations are clearly easier to read.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两种声明显然更容易阅读。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Type Qualifiers</samp>
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">类型限定符</samp>
- en: 'All the types examined so far have been unqualified types. You can qualify
    types by using one or more of the following qualifiers: <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>.
    Each of these qualifiers changes behaviors when accessing objects of the qualified
    type.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，所有检查过的类型都是未限定类型。你可以通过使用以下一个或多个限定符来限定类型：<samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>。每个限定符在访问限定类型的对象时会改变行为。
- en: The qualified and unqualified versions of types can be used interchangeably
    as arguments to functions, return values from functions, and structure and union
    members.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 类型的限定版本和未限定版本可以互换使用，作为函数的参数、函数的返回值以及结构体和联合体的成员。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*The* <samp class="SANS_TheSansMonoCd_W5Regular_11">_Atomic</samp> *type qualifier,
    available since C11, supports concurrent programs.*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*<samp class="SANS_TheSansMonoCd_W5Regular_11">_Atomic</samp> 类型限定符，自 C11 起可用，支持并发程序。*'
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">const</samp>'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">const</samp>'
- en: 'Objects declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    qualifier (<samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    types) are not assignable but can have constant initializers. This means the compiler
    can place objects with <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    types in read-only memory, and any attempt to write to them will result in a runtime
    error:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> 限定符声明的对象（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">const</samp> 限定类型）不可赋值，但可以具有常量初始化值。这意味着编译器可以将具有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> 限定类型的对象放入只读内存中，任何尝试写入它们的操作都会导致运行时错误：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It’s possible to accidentally convince your compiler to change a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    object for you. In the following example, we take the address of a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    object <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> and tell the compiler
    that it’s actually a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会不小心让编译器改变一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> 限定对象。在下面的例子中，我们获取了一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> 限定对象 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    的地址，并告诉编译器它实际上是一个指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 的指针：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: C does not allow you to cast away the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    if the original was declared as a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    object. This code might appear to work, but it’s defective and may fail later.
    For example, the compiler might place the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    object in read-only memory, causing a memory fault when trying to store a value
    in the object at runtime.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: C语言不允许你强制转换掉原本声明为 <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    的对象。如果代码看起来能正常工作，它可能是有缺陷的，并且可能在后续运行时失败。例如，编译器可能会将 <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    限定的对象放入只读内存中，在运行时尝试向该对象存储值时会导致内存错误。
- en: 'C allows you to modify an object that is referenced by a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    pointer by casting the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    away, provided that the original object was not declared <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: C语言允许你通过强制转换去除 <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> 限定符，来修改一个通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> 限定指针引用的对象，只要原始对象未声明为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Be careful not to pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    pointer to a function that modifies the object.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 小心不要将一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> 限定的指针传递给会修改该对象的函数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">volatile</samp>
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">volatile</samp>
- en: Objects are given a <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified
    type to allow for processes that are *extrinsic* to the compiler. The values stored
    in these objects may change without the knowledge of the compiler, or a write
    may synchronize externally. For example, every time the value from a real-time
    clock is read, it may change, even if the value has not been written to by the
    C program. Using a <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified
    type lets the compiler know that the value may change without its knowledge and
    ensures that every access to the real-time clock occurs. Otherwise, an access
    to the real-time clock may be optimized away or replaced by a previously read
    and cached value.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对象被赋予 `<samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>` 修饰符类型，以允许编译器外部的*外在*进程操作。这些对象中存储的值可能会在编译器不知道的情况下发生变化，或者写操作可能会进行外部同步。例如，每次读取实时钟表的值时，它可能会发生变化，即使该值没有被
    C 程序写入。使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>` 修饰符类型让编译器知道该值可能在不知情的情况下发生变化，并确保每次访问实时钟表时都会发生。否则，对实时钟表的访问可能会被优化掉，或者被之前读取并缓存的值替代。
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified type
    can be used to access memory-mapped registers, which are accessed through an address
    just like any other memory. Input/output (I/O) devices often have memory-mapped
    registers, where you can write to, or read from, a specific address to set or
    retrieve information or data. Each read and write operation must occur, even if
    the compiler can see no reason for it. Declaring an object as <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>
    ensures that each read or write of that object at runtime occurs the same number
    of times and in the same order as indicated by the source code. For example, if
    <samp class="SANS_TheSansMonoCd_W5Regular_11">port</samp> is defined as a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    the compiler must generate instructions to read the value from <samp class="SANS_TheSansMonoCd_W5Regular_11">port</samp>
    and then write this value back to <samp class="SANS_TheSansMonoCd_W5Regular_11">port</samp>
    in the assignment:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>` 修饰符类型可用于访问内存映射寄存器，这些寄存器通过地址像其他内存一样被访问。输入/输出
    (I/O) 设备通常有内存映射寄存器，你可以通过特定地址进行读写以设置或获取信息或数据。每次读写操作必须发生，即使编译器认为没有必要。将对象声明为 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>` 可确保该对象在运行时的每次读写操作发生次数与源代码中所指示的次数相同，并且顺序一致。例如，如果
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">port</samp>` 被定义为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>`
    修饰的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>`，编译器必须生成指令从 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">port</samp>` 读取值，并将该值写回到 `<samp class="SANS_TheSansMonoCd_W5Regular_11">port</samp>`：'
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Without the <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp> qualification,
    the compiler would see this as a no-op (a programming statement that does nothing)
    and might eliminate both the read and the write. Reads and writes of volatile
    memory are touched exactly once. A volatile operation cannot be eliminated or
    fused with a subsequent one, even if the compiler believes it’s useless. A volatile
    operation cannot be speculated, even if the compiler can undo or otherwise make
    that speculation benign.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 `<samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>` 修饰符，编译器会将此视为无操作（一个什么也不做的编程语句），并可能会删除读取和写入操作。对
    volatile 内存的读写操作会恰好执行一次。volatile 操作不能被消除或与后续操作合并，即使编译器认为它是无用的。volatile 操作不能被猜测，即使编译器能够撤销或以其他方式使该猜测无害。
- en: Objects with <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified
    types are used when a compiler is not aware of external interactions. For example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified types
    can be used for memory shared with untrusted code to avoid time-of-check to time-of-use
    (ToCToU) vulnerabilities. Such types are used to access objects from a signal
    handler and with <samp class="SANS_TheSansMonoCd_W5Regular_11">setjmp</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">longjmp</samp> (refer to the C standard
    for information on signal handlers and <samp class="SANS_TheSansMonoCd_W5Regular_11">setjmp</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">longjmp</samp>). Unlike Java and other
    programming languages, <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp>-qualified
    types should not be used in C for synchronization between threads.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp> 限定符的对象用于编译器无法感知外部交互的情况。例如，带有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp> 限定符的类型可用于与不受信任代码共享的内存，以避免时检查与时使用（ToCToU）漏洞。这些类型用于从信号处理程序访问对象，并与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">setjmp</samp>/<samp class="SANS_TheSansMonoCd_W5Regular_11">longjmp</samp>
    一起使用（有关信号处理程序和 <samp class="SANS_TheSansMonoCd_W5Regular_11">setjmp</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">longjmp</samp> 的信息，请参阅 C 标准）。与 Java 和其他编程语言不同，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">volatile</samp> 限定符的类型不应在 C 中用于线程之间的同步。
- en: Memory-mapped I/O ports are modeled by a <samp class="SANS_TheSansMonoCd_W5Regular_11">static
    volatile</samp>–qualified objects model. Memory-mapped input ports such as a real-time
    clock are modeled by <samp class="SANS_TheSansMonoCd_W5Regular_11">static const
    volatile</samp>–qualified objects. A <samp class="SANS_TheSansMonoCd_W5Regular_11">const
    volatile</samp>–qualified object models a variable that can be altered by a separate
    thread. The meaning of the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    storage-class specifier is explained later in this chapter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射 I/O 端口通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">static volatile</samp>
    限定符的对象模型表示。内存映射输入端口，如实时钟，通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">static
    const volatile</samp> 限定符的对象表示。一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">const
    volatile</samp> 限定符的对象表示一个可能会被单独线程修改的变量。<samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    存储类说明符的含义将在本章后面解释。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">restrict</samp>
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">restrict</samp>
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>-qualified pointer
    is used to promote optimization. Objects indirectly accessed through a pointer
    frequently cannot be fully optimized because of potential aliasing, which occurs
    when more than one pointer refers to the same object. Aliasing can inhibit optimizations
    because the compiler can’t tell whether an object can change values when another
    apparently unrelated object is modified, for example.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带有 <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp> 限定符的指针用于促进优化。通过指针间接访问的对象通常无法完全优化，因为可能会出现别名问题，当多个指针指向同一对象时，就会发生别名问题。例如，当另一个看似无关的对象被修改时，编译器无法确定对象是否会更改值，这种情况会抑制优化。
- en: 'The following function copies <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    bytes from the storage referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>
    to the storage referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>.
    The function parameters <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> are both <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>-qualified
    pointers:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数将从由 <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> 引用的存储区复制 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">n</samp> 字节到由 <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    引用的存储区。函数参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>
    都是 <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp> 限定符的指针：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Because both <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">q</samp> are <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>-qualified
    pointers, the compiler can assume that an object accessed through one of the pointer
    parameters is not also accessed through the other. The compiler can make this
    assessment based solely on the parameter declarations without analyzing the function
    body.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>
    都是 <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp> 限定符的指针，编译器可以假设通过其中一个指针参数访问的对象不会通过另一个指针参数访问。编译器可以仅通过参数声明来做出这个假设，而无需分析函数体。
- en: Although using <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp>-qualified
    pointers can result in more efficient code, you must ensure that the pointers
    do not refer to overlapping memory to prevent undefined behavior.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">restrict</samp> 限定指针可以提高代码的效率，但你必须确保指针不引用重叠的内存，以避免未定义的行为。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Scope</samp>
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">作用域</samp>
- en: 'Objects, functions, macros, and other C language identifiers have *scope* that
    delimits the contiguous region where they can be accessed. C has four types of
    scope: file, block, function prototype, and function.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对象、函数、宏以及其他 C 语言标识符具有 *作用域*，作用域限定了它们可以访问的连续区域。C 语言有四种作用域：文件作用域、块作用域、函数原型作用域和函数作用域。
- en: The scope of an object or function identifier is determined by where it is declared.
    If the declaration is outside any block or parameter list, the identifier has
    *file scope*, meaning its scope is the entire text file in which it appears as
    well as any included files.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对象或函数标识符的作用域由其声明位置决定。如果声明位于任何块或参数列表之外，则该标识符具有 *文件作用域*，意味着它的作用域是它所在的整个文本文件以及任何包含的文件。
- en: If the declaration appears inside a block or within the list of parameters,
    it has *block scope*, meaning that the identifier is accessible only from within
    the block. The identifiers for <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> from [Listing 2-4](chapter2.xhtml#Lis2-4)
    have block scope and can be referenced only from within the code block in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function in which they’re
    defined.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果声明出现在块内部或参数列表内，则该标识符具有 *块作用域*，意味着该标识符仅能在块内部访问。来自 [清单 2-4](chapter2.xhtml#Lis2-4)
    中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    的标识符具有块作用域，并且只能在它们定义所在的 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    函数中的代码块内引用。
- en: If the declaration appears within the list of parameter declarations in a function
    prototype (not part of a function definition), the identifier has *function prototype
    scope*, which terminates at the end of the function declarator. *Function scope*
    is the area between the opening <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>of
    a function definition and its closing}. A label name is the only kind of identifier
    that has function scope. *Labels* are identifiers followed by a colon, and they
    identify a statement in the same function to which control may be transferred.
    ([Chapter 5](chapter5.xhtml) covers labels and control transfer.)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果声明出现在函数原型的参数声明列表中（而不是函数定义的一部分），则该标识符具有 *函数原型作用域*，作用域在函数声明符的末尾结束。*函数作用域* 是函数定义的起始
    <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp> 和结束处之间的区域。标签名是唯一具有函数作用域的标识符。*标签*
    是后跟冒号的标识符，用于标识同一函数中的一个语句，控制可以转移到该语句。（[第 5 章](chapter5.xhtml) 讲解了标签和控制转移。）
- en: Scopes also can be *nested*, with *inner* and *outer* scopes. For example, you
    can define a block scope inside another block scope, and every block scope is
    defined within a file scope. The inner scope has access to the outer scope, but
    not vice versa. As the name implies, any inner scope must be completely contained
    within any outer scope that encompasses it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域也可以是 *嵌套* 的，具有 *内层* 和 *外层* 作用域。例如，你可以在一个块作用域内部定义另一个块作用域，每个块作用域都定义在文件作用域内。内层作用域可以访问外层作用域，但反之则不行。顾名思义，任何内层作用域必须完全包含在它所包含的外层作用域内。
- en: If you declare the same identifier in both an inner scope and an outer scope,
    the identifier declared in the outer scope is *hidden* (also known as *shadowed*)
    by the identifier declared in the inner scope. Referencing the identifier from
    the inner scope will refer to the object in the inner scope; the object in the
    outer scope is hidden and cannot be referenced by its name. The easiest way to
    prevent this from becoming a problem is to use different names. [Listing 2-10](chapter2.xhtml#Lis2-10)
    demonstrates different scopes and how identifiers declared in inner scopes can
    hide identifiers declared in outer scopes.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在内层作用域和外层作用域中声明了相同的标识符，则外层作用域中声明的标识符会被内层作用域中声明的标识符 *隐藏*（也叫 *遮蔽*）。从内层作用域引用该标识符将引用内层作用域中的对象；外层作用域中的对象被隐藏，无法通过其名称引用。防止这个问题的最简单方法是使用不同的名称。[清单
    2-10](chapter2.xhtml#Lis2-10) 演示了不同的作用域以及内层作用域中声明的标识符如何隐藏外层作用域中声明的标识符。
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-10: Identifiers declared
    in inner scopes hiding identifiers declared in outer scopes</samp>'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 2-10：在内层作用域中声明的标识符隐藏外层作用域中声明的标识符</samp>
- en: There is nothing wrong with this code, provided the comments accurately describe
    your intent. However, it’s better to use different names for different identifiers
    to avoid confusion, which leads to bugs. Using short names such as <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> is fine for identifiers
    with small scopes. Identifiers in large scopes should have longer, descriptive
    names that are unlikely to be hidden in nested scopes. Some compilers will warn
    about hidden identifiers.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 只要注释准确描述了你的意图，这段代码并没有问题。然而，最好为不同的标识符使用不同的名称，以避免混淆，进而导致bug。像<samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">j</samp>这样简短的名称适用于小范围作用域的标识符。而大范围作用域的标识符应该具有较长的、描述性的名称，这样就不太可能在嵌套作用域中被隐藏。有些编译器会警告标识符被隐藏。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Storage Duration</samp>
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">存储持续时间</samp>
- en: 'Objects have a storage duration that determines their lifetime. Four storage
    durations are available: automatic, static, thread, and allocated. You’ve already
    seen that objects declared within a block or as a function parameter have automatic
    storage duration. The lifetime of these objects starts when the block in which
    they’re declared begins execution and ends when execution of this block completes.
    If the block is entered recursively, a new object is created each time the block
    is entered, and each object has its own storage.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对象具有一个存储持续时间，它决定了对象的生命周期。存储持续时间有四种类型：自动、静态、线程和动态分配。你已经看到，声明在块内或作为函数参数的对象具有自动存储持续时间。这些对象的生命周期从它们所在块的执行开始，到块的执行完成时结束。如果块是递归进入的，那么每次进入时都会创建一个新的对象，每个对象都有自己的存储空间。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Scope and lifetime are entirely different concepts. Scope applies to identifiers,
    whereas lifetime applies to objects. The scope of an identifier is the code region
    where the object denoted by the identifier can be accessed by its name. The lifetime
    of an object is the period for which the object exists.*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*作用域和生命周期是完全不同的概念。作用域适用于标识符，而生命周期适用于对象。标识符的作用域是指可以通过标识符名称访问该对象的代码区域。对象的生命周期是指该对象存在的时间段。*'
- en: Objects declared in file scope have *static* storage duration. The lifetime
    of those objects is the entire execution of the program, and their stored value
    is initialized prior to program startup.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件作用域内声明的对象具有*静态*存储持续时间。这些对象的生命周期是程序执行的整个过程，它们的存储值在程序启动之前就已经初始化。
- en: '*Thread* storage duration is used in concurrent programming and is not covered
    in this book. *Allocated* storage duration involves dynamically allocated memory
    and is discussed in [Chapter 6](chapter6.xhtml). Finally, as described in the
    next section, a storage-class specifier can determine or influence storage duration.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*线程*存储持续时间用于并发编程，本书不涉及这一内容。*动态分配*存储持续时间涉及动态分配的内存，相关内容将在[第六章](chapter6.xhtml)中讨论。最后，如下节所述，存储类别说明符可以确定或影响存储持续时间。'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Storage Class</samp>
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">存储类别</samp>
- en: You can specify the storage class of an object or functions using storage-class
    specifiers. For C23, these include <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">thread_local</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> storage-class
    specifier is new in C23, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    storage-class specifier is significantly changed.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用存储类说明符来指定对象或函数的存储类。对于 C23，存储类说明符包括 `<samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>`，`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>`，`<samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>`，`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">register</samp>`，`<samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>`，`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">thread_local</samp>` 和 `<samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>`。`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>` 存储类说明符是 C23 中的新特性，而
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>` 存储类说明符发生了显著变化。
- en: 'Storage-class specifiers specify various properties of identifiers and declared
    features:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 存储类说明符指定标识符和声明特性的各种属性：
- en: 'Storage duration: <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    in block scope, <samp class="SANS_TheSansMonoCd_W5Regular_11">thread_local</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp>'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储持续时间：块作用域中的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>`，`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">thread_local</samp>`，`<samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>`
    和 `<samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp>`
- en: 'Linkage: <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">static</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>
    in file scope, and <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接属性：文件作用域中的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>`，`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">static</samp>` 和 `<samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>`，以及
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>`
- en: 'Value: <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值：`<samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>`
- en: 'Type: <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型：`<samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>`
- en: With a few exceptions, only one storage-class specifier is allowed for each
    declaration. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    may appear with all the others except <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 除少数例外情况外，每个声明只能使用一个存储类说明符。例如，`<samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>`
    可以与其他所有说明符一起使用，除了 `<samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>`。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">static</samp>
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">static</samp>`'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> storage-class
    specifier is used to specify both storage duration and linkage.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>` 存储类说明符用于指定存储持续时间和链接属性。'
- en: File scope identifiers specified as <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>, or functions
    specified as static, have <samp class="SANS_TheSansMonoCd_W5Regular_11">internal</samp>
    linkage.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>` 或 `<samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>`
    指定的文件作用域标识符，或指定为静态的函数，具有 `<samp class="SANS_TheSansMonoCd_W5Regular_11">internal</samp>`
    链接属性。
- en: You can also declare a variable with block scope to have static storage duration
    by using the storage-class specifier <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>,
    as shown in the counting example in [Listing 2-11](chapter2.xhtml#Lis2-11). These
    objects persist after the function has exited.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用存储类说明符 `<samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>` 来声明具有块作用域的变量，从而使其具有静态存储持续时间，正如在
    [Listing 2-11](chapter2.xhtml#Lis2-11) 中的计数示例所示。这些对象在函数退出后仍然存在。
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-11: A counting example</samp>'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-11: 计数示例</samp>`'
- en: This program outputs <samp class="SANS_TheSansMonoCd_W5Regular_11">1 2 3 4 5</samp>.
    The static variable <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp>
    is initialized to 0 once at program startup and incremented each time the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">increment</samp> function is called. The
    lifetime of <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp> is the
    entire execution of the program, and it will retain its last-stored value throughout
    its lifetime. You could achieve the same behavior by declaring <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp>
    with file scope. However, it’s good software engineering practice to limit the
    scope of an object whenever possible.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序输出 <samp class="SANS_TheSansMonoCd_W5Regular_11">1 2 3 4 5</samp>。静态变量 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">counter</samp> 在程序启动时初始化为 0，并且每次调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">increment</samp> 函数时递增。<samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp>
    的生命周期为程序的整个执行过程，它会在生命周期内保持其最后存储的值。通过使用文件作用域声明 <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp>
    也可以实现相同的行为。但是，作为好的软件工程实践，尽可能限制对象的作用域是有益的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">extern</samp>
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">extern</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> specifier specifies
    static storage duration and external linkage. It can be used with function and
    object declarations in both file and block scope (but not function parameter lists).
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> is specified for
    the redeclaration of an identifier that has already been declared with internal
    linkage, the linkage remains internal. Otherwise (if the prior declaration was
    external, has no linkage, or is not in scope), the linkage is external.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> 说明符指定静态存储持续时间和外部链接。它可以与文件范围和块范围内的函数和对象声明一起使用（但不能用于函数参数列表）。如果
    <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> 被用于重新声明已经用内部链接声明的标识符，则链接仍为内部链接。否则（如果先前的声明是外部声明、没有链接，或不在作用域内），链接为外部链接。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">thread_local</samp>
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">thread_local</samp>
- en: An object whose identifier is declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">thread_local</samp>
    storage-class specifier has *thread storage duration*. Its initializer is evaluated
    prior to program execution, its lifetime is the entire execution of the thread
    for which it is created, and its stored value is initialized with the previously
    determined value when the thread is started. There is a distinct object per thread,
    and use of the declared name in an expression refers to the object associated
    with the thread evaluating the expression. (The topic of threading is beyond the
    scope of this book.)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">thread_local</samp> 存储类说明符声明的对象具有
    *线程存储持续时间*。它的初始化器在程序执行之前进行评估，其生命周期为创建该线程的整个执行过程，并且当线程启动时，它的存储值会用先前确定的值进行初始化。每个线程都有一个独立的对象，并且在表达式中使用声明的名称会引用与评估该表达式的线程关联的对象。（线程的相关内容超出了本书的范围。）
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">constexpr</samp>
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">constexpr</samp>
- en: A scalar object declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>
    storage-class specifier is a constant and has its value permanently fixed at translation
    time. The <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> storage-class
    specifier may appear with <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>.
    If not already present, a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    qualification is implicitly added to the object’s type. The resulting object cannot
    be modified at runtime in any way. The compiler can then use this value in any
    other constant expression.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> 存储类说明符声明的标量对象是一个常量，其值在翻译时固定。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> 存储类说明符可以与 <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">register</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    一起使用。如果原本没有，<samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> 限定符会隐式地添加到对象的类型中。结果对象在运行时无法以任何方式修改。编译器可以在其他常量表达式中使用该值。
- en: 'Additionally, the constant expression used for the initializer of such a constant
    is checked at compile time. Before the introduction of <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>
    in C23, a very large object constant might be declared as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，用于常量初始化器的常量表达式将在编译时进行检查。在 C23 引入 <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>
    之前，可能会像下面这样声明一个非常大的对象常量：
- en: '[PRE44]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The initializer may or may not fit into <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>;
    a diagnostic is not required. In C23, this same object can be declared using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器可能适合也可能不适合 <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>；不需要诊断。在
    C23 中，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> 可以像下面这样声明相同的对象：
- en: '[PRE45]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, a diagnostic is required on implementations where <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>
    has a width of 32 or less.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于 <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> 宽度为 32 或更小的实现，要求进行诊断。
- en: 'Static objects must be initialized with a constant value and not a variable:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 静态对象必须使用常量值进行初始化，而不是变量：
- en: '[PRE46]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Arithmetic constant expressions are allowed in initializers. Constant values
    are literal constants (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp>),
    <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> members, a scalar object
    declared with the <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>
    storage-class specifier, and the result of operators such as <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> (provided the operand
    does not have a variable-length array type). Unfortunately, <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>-qualified
    objects are not constant values. Starting with C23, an implementation may accept
    other forms of constant expressions; it is implementation defined whether they
    are integer constant expressions.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 算术常量表达式可以用于初始化器。常量值包括字面常量（例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">'a'</samp>，或 <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp>）、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> 成员、使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>
    存储类说明符声明的标量对象，以及操作符（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>）的结果（前提是操作数没有变长数组类型）。不幸的是，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">const</samp> 限定的对象不是常量值。从 C23 开始，实现可能会接受其他形式的常量表达式；是否是整数常量表达式由实现定义。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">register</samp>
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">register</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp> storage-class
    specifier suggests that access to an object be as fast as possible. The extent
    to which such suggestions are effective is implementation defined. Frequently,
    compilers can make better decisions about register allocation and ignore these
    programmer suggestions. The <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp>
    storage class can be used only for an object that never has its address taken.
    A compiler can treat any register declaration simply as an <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    declaration. However, whether addressable storage is used, the address of any
    part of an object declared with a storage-class specifier register cannot be computed,
    either explicitly by use of the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator or implicitly by converting an array name to a pointer.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp> 存储类说明符建议尽可能快速地访问对象。此类建议的有效性取决于实现。通常，编译器可以做出更好的寄存器分配决策，并忽略这些程序员的建议。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">register</samp> 存储类只能用于从未被取地址的对象。编译器可以将任何寄存器声明简单地视为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> 声明。然而，无论是否使用可寻址存储，使用存储类说明符
    <samp class="SANS_TheSansMonoCd_W5Regular_11">register</samp> 声明的对象的任何部分的地址都不能被计算出来，无论是通过使用单目运算符
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> 显式计算，还是通过将数组名称转换为指针隐式计算。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">typedef</samp>
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">typedef</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> storage-class
    specifier defines an identifier to be a <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>
    name that denotes the type specified for the identifier. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>
    storage-class specifier was discussed earlier in the “Type Definitions” box.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> 存储类说明符定义了一个标识符作为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> 名称，用来表示为标识符指定的类型。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> 存储类说明符在“类型定义”框中已有讨论。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">auto</samp>
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">auto</samp>
- en: Prior to C23, the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    specifier was allowed only for objects declared at block scope (except function
    parameter lists). It indicates automatic storage duration and no linkage, which
    are the defaults for these kinds of declarations.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C23 之前，<samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> 说明符仅允许用于在块作用域内声明的对象（函数参数列表除外）。它表示自动存储持续时间和无链接性，这些是此类声明的默认设置。
- en: C23 introduced type inference into the C language by expanding the definition
    of the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> storage-class
    specifier. Prior to C23, declaring a variable in C requires the user to name a
    type. However, when the declaration includes an initializer, the type can be derived
    directly from the type of the expression used to initialize the variable. This
    has been a C++ feature since 2011.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: C23 通过扩展现有的 <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> 存储类说明符的定义，将类型推断引入了
    C 语言。在 C23 之前，声明一个变量时需要指定类型。然而，当声明中包含初始化器时，类型可以直接从用于初始化变量的表达式类型中推导出来。自 2011 年以来，这一特性已经是
    C++ 的一部分。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> storage duration
    class specifier has similar behavior to C++ in that it allows the type to be inferred
    from the type of the assignment value. Take the following file scope definitions,
    for example:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> 存储持续时间类说明符的行为类似于 C++，它允许从赋值的类型推断出类型。以下是文件作用域定义的示例：
- en: '[PRE47]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Because the integer literal <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    has an implicit type of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    these declarations are interpreted as if they had been written as:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 由于整数常量 <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> 隐式类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，因此这些声明的解释方式就像它们被写成如下所示：
- en: '[PRE48]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Effectively, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    is an <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. Type inference
    is extremely useful when implementing or invoking type-generic macros, as we’ll
    see in [Chapter 9](chapter9.xhtml).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    类型，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> 是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    *</samp> 类型。在实现或调用类型通用宏时，类型推断非常有用，正如我们将在[第9章](chapter9.xhtml)中看到的那样。
- en: <samp class="SANS_Futura_Std_Bold_B_11">typeof Operators</samp>
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">typeof 运算符</samp>
- en: C23 introduced the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operators <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operators can operate on an expression or a type name and yield the type of their
    operand. If the type of the operand is a variably modified type, the operand is
    evaluated; otherwise, the operand is not evaluated.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: C23 引入了 <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> 运算符 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> 运算符可以作用于表达式或类型名称，并返回其操作数的类型。如果操作数的类型是一个可变修改的类型，则会评估操作数；否则，操作数不会被评估。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operators and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> storage duration
    class specifier both perform automatic type inference. They can both be used to
    determine the type of expression.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> 运算符和 <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    存储持续时间类说明符都执行自动类型推断。它们都可以用来确定表达式的类型。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> storage duration
    class specifier is commonly used to declare initialized variables where the type
    can be inferred from the initial value. However, to form a derived type, you must
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>` 存储持续时间类说明符常用于声明初始化变量，在这种情况下，类型可以从初始值推断出来。然而，要形成衍生类型，你必须使用
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>` 操作符：'
- en: '[PRE49]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> storage duration
    class specifier cannot be used with <samp class="SANS_TheSansMonoCd_W5Regular_11">_Generic</samp>
    (described in [Chapter 9](chapter9.xhtml)) and <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>
    (described later in this chapter).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>` 存储持续时间类说明符不能与 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">_Generic</samp>`（在[第9章](chapter9.xhtml)中描述）和
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>`（本章稍后描述）一起使用。'
- en: The result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>
    operator is the nonatomic, unqualified version of the type that would result from
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator preserves
    all qualifiers.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>` 操作符的结果是类型的非原子、未限定版本，该类型是通过
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>` 操作符得到的。`<samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>`
    操作符保留所有限定符。'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator is
    like the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator,
    which executes the expression in an unevaluated context to understand the final
    type. You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operator anywhere you can use a type name. The following example illustrates the
    use of both <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operators:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>` 操作符类似于 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>` 操作符，它在未求值的上下文中执行表达式，以了解最终的类型。你可以在任何可以使用类型名称的地方使用
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>` 操作符。以下示例演示了两个 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>` 操作符的使用：'
- en: '[PRE50]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: At the first use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>
    operator ❶, the operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp>,
    which has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">const int</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp> operator
    strips the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> qualifier,
    resulting in just plain <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    This use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>
    operator is illustrative and not meant for production code. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>
    operator is used again on operand <samp class="SANS_TheSansMonoCd_W5Regular_11">asi</samp>
    ❷, which has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">const _Atomic
    int</samp>. All qualifiers are once again stripped, resulting in a plain <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. The operand to the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    specifier at ❸ includes another <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    specifier. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operand is itself a <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    specifier, the operand is evaluated before evaluating the current <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operator. This evaluation happens recursively until a <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    specifier is no longer the operand. In this case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    specifier at ❸ does nothing and can be omitted. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operator at ❹ is evaluated before the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operator at ❸ and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">const
    int</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator
    at ❸ is now evaluated and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">const
    _Atomic int</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operator at ❺ returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    array of four <samp class="SANS_TheSansMonoCd_W5Regular_11">const char</samp>
    pointers. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>
    operator at ❻ strips the qualifier and returns an array of four <samp class="SANS_TheSansMonoCd_W5Regular_11">const
    char</samp> pointers. The qualifiers, in this case, are stripped only from the
    array and not the element types the array contains.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp> 操作符
    ❶ 时，操作数是 <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp>，其类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">const
    int</samp>。<samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>
    操作符会去掉 <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> 限定符，结果仅为普通的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。这种使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>
    操作符的方式是示范性的，并不适用于生产代码。<samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp>
    操作符再次作用于操作数 <samp class="SANS_TheSansMonoCd_W5Regular_11">asi</samp> ❷，其类型是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">const _Atomic int</samp>。所有限定符再次被去除，结果是普通的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。在 ❸ 处，<samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    说明符的操作数包含另一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> 说明符。如果
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> 操作数本身就是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    说明符，则会先评估该操作数，再评估当前的 <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    操作符。这种评估是递归进行的，直到操作数不再是 <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    说明符为止。在这种情况下，❸ 处的 <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    说明符不做任何操作，可以省略。❹ 处的 <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    操作符会在 ❸ 处的 <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> 操作符之前评估，返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">const int</samp>。然后，❸ 处的 <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    操作符被评估，返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">const _Atomic int</samp>。❺
    处的 <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> 操作符返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    数组，包含四个 <samp class="SANS_TheSansMonoCd_W5Regular_11">const char</samp> 指针。❻ 处的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp> 操作符去掉限定符，返回一个包含四个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">const char</samp> 指针的数组。在这种情况下，限定符仅从数组本身去除，而不去除数组元素类型中的限定符。
- en: 'The following <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function
    is equivalent but doesn’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operators:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 函数是等效的，但没有使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> 操作符：
- en: '[PRE51]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    operator to refer to a macro parameter to construct objects with the required
    types without specifying the type names explicitly as macro arguments.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> 操作符引用宏参数，以在不显式指定类型名称作为宏参数的情况下构造具有所需类型的对象。
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">Alignment</samp>'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '## <samp class="SANS_Futura_Std_Bold_B_11">对齐</samp>'
- en: Object types have alignment requirements that place restrictions on the addresses
    at which objects of that type may be allocated. An *alignment* represents the
    number of bytes between successive addresses at which a given object can be allocated.
    Central processing units (CPUs) may have different behavior when accessing aligned
    data (for example, where the data address is a multiple of the data size) versus
    unaligned data.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对象类型有对齐要求，这些要求限制了该类型对象可以分配的地址。*对齐* 表示在连续地址之间分配给定对象的字节数。中央处理单元（CPU）在访问对齐数据（例如，当数据地址是数据大小的倍数时）与未对齐数据时，可能会有不同的行为。
- en: Some machine instructions can perform multibyte accesses on nonword boundaries,
    but with a performance penalty. A *word* is a natural, fixed-sized unit of data
    handled by the instruction set or the hardware of the processor. Some platforms
    cannot access unaligned memory. Alignment requirements may depend on the CPU word
    size (typically, 16, 32, or 64 bits).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一些机器指令可以在非字边界上执行多字节访问，但会带来性能惩罚。*字* 是指令集或处理器硬件处理的自然、固定大小的数据单位。一些平台无法访问未对齐的内存。对齐要求可能取决于
    CPU 的字大小（通常为 16、32 或 64 位）。
- en: Generally, C programmers need not concern themselves with alignment requirements,
    because the compiler chooses suitable alignments for its various types. However,
    on rare occasions, you might need to override the compiler’s default choices—for
    example, to align data on the boundaries of the memory cache lines that must start
    at power-of-two address boundaries or to meet other system-specific requirements.
    Traditionally, these requirements were met by linker commands or similar operations
    involving other nonstandard facilities.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，C 程序员无需担心对齐要求，因为编译器会为各种类型选择合适的对齐方式。然而，在少数情况下，你可能需要覆盖编译器的默认选择——例如，为了将数据对齐到必须以二的幂地址边界开始的内存缓存行边界，或者满足其他系统特定的要求。传统上，这些要求通过链接器命令或类似的操作来满足，这些操作涉及其他非标准设施。
- en: 'C11 introduced a simple, forward-compatible mechanism for specifying alignments.
    Alignments are represented as values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>.
    Every valid alignment value is a nonnegative integral power of two. An object
    type imposes a default alignment requirement on every object of that type: a stricter
    alignment (a larger power of two) can be requested using the alignment specifier
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">alignas</samp>). You can include
    an alignment specifier in a declaration. [Listing 2-12](chapter2.xhtml#Lis2-12)
    uses the alignment specifier to ensure that <samp class="SANS_TheSansMonoCd_W5Regular_11">good_buff</samp>
    is properly aligned (<samp class="SANS_TheSansMonoCd_W5Regular_11">bad_buff</samp>
    may have incorrect alignment for member-access expressions).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: C11 引入了一种简单且向前兼容的机制，用于指定对齐方式。对齐方式表示为类型<samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>的值。每个有效的对齐值都是非负整数的二的幂。一个对象类型对该类型的每个对象施加默认的对齐要求：可以使用对齐说明符（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">alignas</samp>）请求更严格的对齐（更大的二的幂）。你可以在声明中包含对齐说明符。[列表
    2-12](chapter2.xhtml#Lis2-12) 使用对齐说明符以确保 <samp class="SANS_TheSansMonoCd_W5Regular_11">good_buff</samp>
    被正确对齐（<samp class="SANS_TheSansMonoCd_W5Regular_11">bad_buff</samp> 可能由于成员访问表达式导致对齐不正确）。
- en: '[PRE52]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-12: Use of the</samp>
    <samp class="I">alignas</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">keyword</samp>'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 2-12：使用</samp> <samp class="I">alignas</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">关键字</samp>
- en: Although <samp class="SANS_TheSansMonoCd_W5Regular_11">good_buff</samp> has
    proper alignment to be accessed through an lvalue of type <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    S</samp>, this program still has undefined behavior. This undefined behavior stems
    from the underlying object <samp class="SANS_TheSansMonoCd_W5Regular_11">good_buff</samp>
    being declared as an array of objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> and being accessed through an lvalue of a different type. The cast
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">(struct S *)</samp>, like any
    pointer cast, doesn’t change the effective type of the storage allocated to each
    array. Because it is an established practice to use areas of character type for
    low-level storage management, I co-authored a paper to make such code conforming
    in a future revision of the C standard (Seacord et al. 2024).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管<samp class="SANS_TheSansMonoCd_W5Regular_11">good_buff</samp>具有适当的对齐方式，可以通过类型为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct S</samp>的左值访问，但该程序仍然存在未定义行为。这种未定义行为源于底层对象<samp
    class="SANS_TheSansMonoCd_W5Regular_11">good_buff</samp>被声明为<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>类型的对象数组，并通过不同类型的左值进行访问。像任何指针类型转换一样，转换为<samp class="SANS_TheSansMonoCd_W5Regular_11">(struct
    S *)</samp>并不会改变分配给每个数组的存储的有效类型。由于使用字符类型区域进行低级存储管理是一个既定的做法，我与他人合著了一篇论文，旨在使这样的代码在未来版本的C标准中符合规范（Seacord等，2024年）。
- en: Alignments are ordered from weaker to stronger (also called *stricter*) alignments.
    Stricter alignments have larger alignment values. An address that satisfies an
    alignment requirement also satisfies any valid, weaker alignment requirement.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐方式从较弱到较强（也称为*严格*对齐）排列。严格对齐的对齐值更大。满足对齐要求的地址也会满足任何有效的、更弱的对齐要求。
- en: Alignment of dynamically allocated memory is covered in [Chapter 6](chapter6.xhtml).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分配内存的对齐方式在[第6章](chapter6.xhtml)中进行了详细讨论。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Variably Modified Types</samp>
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">可变修改类型</samp>
- en: Variably modified types (VMTs) define a base type and an extent (number of elements),
    which is determined at runtime. VMTs are a mandatory feature of C23.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 可变修改类型（VMT）定义了一个基本类型和一个由运行时决定的范围（元素数量）。VMT是C23的强制性特性。
- en: 'VMTs can be used as function parameters. Remember from earlier in this chapter
    that, when used in an expression, an array is converted to a pointer to the first
    element of the array. This means that we must add an explicit parameter to specify
    the size of the array—for example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    parameter in the signature for <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: VMT可以作为函数参数使用。记住，在本章前面提到的，当在表达式中使用时，数组会被转换为指向数组第一个元素的指针。这意味着我们必须添加一个显式参数来指定数组的大小——例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>签名中的<samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>参数：
- en: '[PRE53]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When you call such a function, <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    should accurately represent the size of the array referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>.
    Undefined behavior results if this size is larger than the array.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用这样的函数时，<samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>应该准确地表示由<samp
    class="SANS_TheSansMonoCd_W5Regular_11">s</samp>引用的数组的大小。如果这个大小超过数组的实际大小，将会导致未定义行为。
- en: 'When declaring a function to take an array as an argument that specifies a
    size, we must declare the size of the array before referencing the size in the
    array declaration. We could, for example, modify the signature for the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>
    function as follows to take the number of elements <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    and an array of at least <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    elements:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当声明一个函数以接受一个指定大小的数组作为参数时，我们必须在引用数组大小之前先声明数组的大小。例如，我们可以修改<samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>函数的签名，使其接受元素数量<samp
    class="SANS_TheSansMonoCd_W5Regular_11">n</samp>和一个至少包含<samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>个元素的数组：
- en: '[PRE54]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: For arrays of character type, the number of elements is equal to the size. In
    this function signature, <samp class="SANS_TheSansMonoCd_W5Regular_11">s[n]</samp>
    is a variably modified type because <samp class="SANS_TheSansMonoCd_W5Regular_11">s[n]</samp>
    depends on the runtime value of <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符类型的数组，元素的数量等于大小。在这个函数签名中，<samp class="SANS_TheSansMonoCd_W5Regular_11">s[n]</samp>是一个可变修改类型，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">s[n]</samp>依赖于<samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>的运行时值。
- en: We’ve changed the order of the parameters so that the size parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    is declared before we use it in the array declaration. The array argument <samp
    class="SANS_TheSansMonoCd_W5Regular_11">s</samp> is still adjusted to a pointer,
    and no storage is allocated because of this declaration (except for the pointer
    itself). When calling this function, you must declare the actual storage for the
    array referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> and
    ensure that <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> is a valid
    size for it. Just like a non-VMT parameter, the actual array storage may be a
    fixed-size array, variable-length array (covered in [Chapter 6](chapter6.xhtml)),
    or dynamically allocated storage.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经改变了参数的顺序，使得在数组声明之前声明了大小参数<samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>。数组参数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">s</samp>仍然会调整为指针，并且由于这个声明（除了指针本身）不会分配存储。当调用这个函数时，你必须为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">s</samp>所引用的数组声明实际的存储，并确保<samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>是一个有效的大小。就像非VMT参数一样，实际的数组存储可能是一个固定大小的数组、可变长度的数组（在[第6章](chapter6.xhtml)中讨论）或动态分配的存储。
- en: 'VMTs can generalize your functions, making them more useful. For example, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">matrix_sum</samp> function sums
    all the values in a two-dimensional array. The following version of this function
    accepts a matrix with a fixed column size:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: VMT可以使你的函数更加通用，提高它们的实用性。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">matrix_sum</samp>函数对二维数组中的所有值进行求和。以下版本的这个函数接受一个具有固定列数的矩阵：
- en: '[PRE55]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: When passing a multidimensional array to a function, the number of elements
    in the initial dimension of the array (the rows) is lost and needs to be passed
    in as an argument. The <samp class="SANS_TheSansMonoCd_W5Regular_11">rows</samp>
    parameter provides this information in this example. You can call this function
    to sum the values of any matrix with exactly four columns, as shown in [Listing
    2-13](chapter2.xhtml#Lis2-13).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当将一个多维数组传递给函数时，数组的初始维度（行数）的元素个数会丢失，必须作为参数传递。在这个例子中，<samp class="SANS_TheSansMonoCd_W5Regular_11">rows</samp>参数提供了这一信息。你可以调用这个函数来求和任何列数恰好为四的矩阵，如[示例
    2-13](chapter2.xhtml#Lis2-13)所示。
- en: '[PRE56]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-13: Summing matrices
    with four columns</samp>'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 2-13: 对具有四列的矩阵求和</samp>'
- en: 'This is fine until you need to sum the values of a matrix that does not have
    four columns. For example, changing <samp class="SANS_TheSansMonoCd_W5Regular_11">m3</samp>
    to have five columns would result in a warning such as this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这在你需要对一个列数不是四的矩阵求和时就会出问题。例如，如果将<samp class="SANS_TheSansMonoCd_W5Regular_11">m3</samp>改为具有五列，可能会出现如下警告：
- en: '[PRE57]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: To accept this argument, you would have to write a new function with a signature
    that matches the new dimensions of the multidimensional array. The problem with
    this approach, then, is that it fails to generalize sufficiently.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要接受这个参数，你必须编写一个新的函数，其签名必须与多维数组的新维度相匹配。这个方法的问题在于，它无法做到足够的通用化。
- en: Instead of doing that, we can rewrite the <samp class="SANS_TheSansMonoCd_W5Regular_11">matrix_sum</samp>
    function to use a VMT, as shown in [Listing 2-14](chapter2.xhtml#Lis2-14). This
    change allows us to call <samp class="SANS_TheSansMonoCd_W5Regular_11">matrix_sum</samp>
    with matrices of any dimension.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将<samp class="SANS_TheSansMonoCd_W5Regular_11">matrix_sum</samp>函数重写为使用VMT，如[示例
    2-14](chapter2.xhtml#Lis2-14)所示。这个修改使我们能够使用任何维度的矩阵来调用<samp class="SANS_TheSansMonoCd_W5Regular_11">matrix_sum</samp>函数。
- en: '[PRE58]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-14: Using a VMT as
    a function parameter</samp>'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 2-14: 使用VMT作为函数参数</samp>'
- en: The compiler performs the matrix indexing ❶. Without VMTs, this would require
    either manual indexing or double indirection, which are both error prone.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器执行矩阵索引操作❶。如果没有VMT，这将需要手动索引或双重间接引用，而这两者都容易出错。
- en: Again, no storage is allocated by either the function declaration or the function
    definition. As with a non-VMT parameter, you need to allocate the storage for
    the matrix separately, and its dimensions must match those passed to the function
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">rows</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">cols</samp>
    arguments. Failing to do so can result in undefined behavior.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，函数声明和函数定义都不会分配存储空间。与非VMT参数类似，你需要单独为矩阵分配存储空间，并且其维度必须与传递给函数的<samp class="SANS_TheSansMonoCd_W5Regular_11">rows</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">cols</samp>参数相匹配。如果不这样做，可能会导致未定义的行为。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Attributes</samp>
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">属性</samp>
- en: Starting with C23, you can use *attributes* to associate additional information
    with a declaration, statement, or type. This information can be used by the implementation
    to improve diagnostics, improve performance, or modify the behavior of the program
    in other ways. A comma-delimited list of zero or more attributes is specified
    within a pair of double square brackets, for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">[[foo]]</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">[[foo, bar]]</samp>.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 从C23开始，你可以使用*属性*将附加信息与声明、语句或类型关联。这些信息可以被实现用来改善诊断、提升性能或以其他方式修改程序行为。属性的逗号分隔列表可以在一对双重方括号内指定，例如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">[[foo]]</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">[[foo,
    bar]]</samp>。
- en: 'Declarations attributes are specified in two ways. If the attribute specifier
    is at the start of a declaration, the attributes are applied to all declarations
    in the declaration group. Otherwise, the attributes are applied to the declaration
    to the immediate left of the attribute specifier. For example, in the following
    declaration group, the <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    attribute is applied to <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 声明属性有两种指定方式。如果属性说明符位于声明的开头，则该属性将应用于声明组中的所有声明。否则，属性将应用于紧接着属性说明符左侧的声明。例如，在以下声明组中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>属性应用于<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>：
- en: '[PRE59]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'While in the second declaration group, the <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp> attributes are applied
    only to <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个声明组中，<samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>属性仅应用于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>：
- en: '[PRE60]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: C23 defines several attributes that apply to declarations, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">nodiscard</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">deprecated</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">nodiscard</samp> attribute is used with
    function declarations to denote that the value returned by the function is expected
    to be used within an expression or initializer. The <samp class="SANS_TheSansMonoCd_W5Regular_11">deprecated</samp>
    attribute is used with the declaration of a function or a type to denote that
    use of the function or type should be diagnosed as discouraged.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: C23定义了多个适用于声明的属性，例如<samp class="SANS_TheSansMonoCd_W5Regular_11">nodiscard</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">deprecated</samp>。<samp class="SANS_TheSansMonoCd_W5Regular_11">nodiscard</samp>属性与函数声明一起使用，表示函数返回的值预期将在表达式或初始化器中使用。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">deprecated</samp>属性用于声明函数或类型，表示该函数或类型的使用应被诊断为不推荐使用。
- en: In addition to standard attributes, the implementation may provide nonportable
    attributes. Such attributes are also specified within double square brackets,
    but they include a vendor prefix to distinguish between attributes from different
    vendors. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">[[clang::overloadable]]</samp>
    attribute is used on a function declaration to specify that it can use C++-style
    function overloading in C, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">[[gnu::packed]]</samp>
    attribute is used on a structure declaration to specify that the member declarations
    of the structure should avoid using padding between member declarations whenever
    possible for a more space-efficient layout. Vendors typically use their own prefixes,
    and they may use whatever prefixes they choose. For example, Clang implements
    many attributes with the <samp class="SANS_TheSansMonoCd_W5Regular_11">gnu</samp>
    prefix for improved compatibility with GCC. Your compiler should ignore unknown
    attributes, although they may still be diagnosed so you know that the attribute
    has no effect. Refer to your compiler’s documentation for the full list of supported
    attributes.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准属性外，编译器实现可能提供非可移植的属性。这些属性也在双重方括号内指定，但它们包括供应商前缀，用于区分不同供应商的属性。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">[[clang::overloadable]]</samp>
    属性用于函数声明，表示它可以在 C 语言中使用 C++ 风格的函数重载，<samp class="SANS_TheSansMonoCd_W5Regular_11">[[gnu::packed]]</samp>
    属性用于结构声明，表示结构成员声明应该尽量避免成员之间使用填充，以便获得更高效的空间布局。供应商通常使用自己的前缀，并且可以使用他们选择的任何前缀。例如，Clang
    实现了许多带有 <samp class="SANS_TheSansMonoCd_W5Regular_11">gnu</samp> 前缀的属性，以提高与 GCC
    的兼容性。你的编译器应该忽略未知的属性，尽管它们仍然可能被诊断出来，帮助你了解该属性没有效果。有关支持的属性的完整列表，请参考你的编译器文档。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter, you learned about objects and functions and how they differ.
    You learned how to declare objects and functions, take the addresses of objects,
    and dereference those object pointers. You also learned about most of the object
    types available to C programmers as well as derived types.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了对象和函数，以及它们的区别。你学会了如何声明对象和函数，获取对象的地址，并解引用这些对象指针。你还了解了 C 程序员可用的大多数对象类型以及派生类型。
- en: 'We’ll return to these types in later chapters to further explore how they can
    be best used to implement your designs. In the next chapter, I provide detailed
    information about the two kinds of arithmetic types: integers and floating-point.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中返回这些类型，进一步探索如何最好地使用它们来实现你的设计。在下一章中，我将提供关于两种算术类型的详细信息：整数和浮点数。
