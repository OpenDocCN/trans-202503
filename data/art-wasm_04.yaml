- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Low-Level Bit Manipulation
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 低级位操作
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: This chapter discusses some bit manipulation techniques for WebAssembly applications,
    which we’ll apply to projects in later chapters to improve application performance.
    This topic can be challenging for readers not familiar with low-level programming,
    so if working with binary data isn’t in your interest, you can continue on to
    the next chapter and simply refer back to this one as needed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了一些用于 WebAssembly 应用的位操作技巧，我们将在后续章节的项目中应用这些技巧，以提高应用的性能。对于不熟悉低级编程的读者来说，这个话题可能会有一定挑战，因此如果你对处理二进制数据不感兴趣，可以继续阅读下一章，并根据需要随时参考本章内容。
- en: Before exploring bit manipulation techniques, we’ll go over a few essential
    topics, which include the three different numeric bases—decimal, hexadecimal,
    and binary; the details of integer and floating-point arithmetic; and 2s complement
    as well as big-endian and little-endian byte order. Additionally, we’ll examine
    high-order and low-order bits, bit masking, bit shifting, and bit rotation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索位操作技巧之前，我们将先介绍一些基本概念，包括三种不同的数字进制——十进制、十六进制和二进制；整数和浮点数运算的细节；以及二的补码、大小端字节序。此外，我们还将研究高位和低位、位掩码、位移和位旋转等内容。
- en: WebAssembly allows you to get as close to the metal as possible from within
    a web browser. If you want to write WebAssembly that executes at lightning speed,
    understanding how to manipulate your data at the level of bits is very useful.
    Bit manipulation is also essential to comprehend the data types WebAssembly works
    with, how they perform, and their limitations. WAT can manipulate data at the
    level of bits in a way that’s similar to assembly languages. Low-level coding
    is a tricky subject, and if you’re not already familiar with some of the concepts
    in this chapter, you might not grasp them all immediately. The good news is you
    don’t need to know all of these low-level concepts to work with WebAssembly, but
    understanding low-level WebAssembly can help you write fast, high-performance
    code for the web. Many times, code a compiler optimizes will generate code that
    performs bit manipulation, so knowledge of how these bit manipulation operations
    work is also important when you’re disassembling a WebAssembly binary to WAT code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 使你能够在 Web 浏览器中尽可能接近硬件层面。如果你希望编写执行速度极快的 WebAssembly，理解如何在比特级别操作数据非常有用。位操作对于理解
    WebAssembly 处理的数据类型、它们的表现以及限制也至关重要。WAT 可以以类似汇编语言的方式在比特级别操作数据。低级编程是一个复杂的主题，如果你之前没有接触过本章中的一些概念，可能无法立即掌握它们。好消息是，你并不需要了解所有这些低级概念才能使用
    WebAssembly，但理解低级 WebAssembly 有助于你为 Web 编写快速、高性能的代码。很多时候，编译器优化的代码会生成执行位操作的代码，因此了解这些位操作如何工作，对于将
    WebAssembly 二进制代码反汇编为 WAT 代码时也非常重要。
- en: Binary, Decimal, and Hexadecimal
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二进制、十进制和十六进制
- en: The *hexadecimal system* is a common numbering system in computer programming
    that uses base-16 instead of the base-10 decimal numbering system you’ve been
    using since you were two years old. Computer programmers work with hexadecimal
    (hex) because computers natively use binary, and hex more cleanly translates into
    binary than decimal. You won’t learn how to convert from decimal to hex manually,
    because I’ll assume you’re either familiar with how to do it or have access to
    a calculator; most calculator apps offer a programmer mode that will do this conversion
    for you, like the one shown in [Figure 4-1](#figure4-1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*十六进制系统*是计算机编程中常用的数字系统，它使用基数 16，而不是你从两岁开始就使用的十进制数字系统。计算机程序员使用十六进制（hex），因为计算机本地使用二进制，十六进制比十进制更简洁地转换为二进制。你不会学到如何手动将十进制转换为十六进制，因为我假设你要么已经知道如何做，要么有一个计算器可以做到这一点；大多数计算器应用程序都提供程序员模式，可以为你完成这个转换，正如[图
    4-1](#figure4-1)中所示。'
- en: '![f04001](Images/f04001.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![f04001](Images/f04001.png)'
- en: 'Figure 4-1: Microsoft Windows Calculator app in Programmer mode'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-1：Microsoft Windows 计算器应用的程序员模式
- en: I also provide a simple decimal to hex conversion tool at [https://wasmbook.com/hex](https://wasmbook.com/hex),
    as well as an online calculator written in WAT at [https://wasmbook.com/calculator.html](https://wasmbook.com/calculator.html).
    Keep in mind that if you want to embed numeric data into a string in WAT, you
    need to use two-digit hex numbers, not decimals.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我还提供了一个简单的十进制到十六进制的转换工具，[https://wasmbook.com/hex](https://wasmbook.com/hex)，以及一个用
    WAT 编写的在线计算器，[https://wasmbook.com/calculator.html](https://wasmbook.com/calculator.html)。请记住，如果你想将数字数据嵌入到
    WAT 字符串中，需要使用两位数的十六进制数字，而不是十进制数字。
- en: Integers and Floating-Point Arithmetic
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数与浮点运算
- en: Before discussing how we can use bit manipulation on types, we need to discuss
    the details of the types that WebAssembly supports. The two primary data types
    in WebAssembly are integers and floating-point numbers. These types are assigned
    to all local and global variables when they’re declared, and you should use them
    for all parameters in function declarations. Integers represent whole numbers
    and can represent negative as well as positive numbers. However, using negative
    integer numbers requires a little more effort than negative floating-point numbers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论如何对类型进行位操作之前，我们需要先讨论 WebAssembly 支持的类型的细节。WebAssembly 的两种主要数据类型是整数和浮点数。这些类型在声明时会分配给所有的局部和全局变量，并且在函数声明中应使用这些类型作为参数。整数表示整数，并且可以表示负数和正数。然而，使用负整数比使用负浮点数稍微复杂一些。
- en: You can store integers and floating-point numbers in variables and in linear
    memory. If you’re familiar with JavaScript, linear memory is like a typed, unsigned-integer
    array. We’ll discuss linear memory more in Chapter 6.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将整数和浮点数存储在变量中，也可以存储在线性内存中。如果你熟悉 JavaScript，线性内存就像一个类型化的无符号整数数组。我们将在第六章中进一步讨论线性内存。
- en: In this section, we’ll look at how integer and floating-point variables work,
    the different types of floating-point and integer variables, and how to do some
    basic binary manipulation on them. Let’s first briefly discuss the four primary
    data types that WebAssembly supports. There are two integer data types (`i32`
    and `i64`) as well as two floating-point data types (`f32` and `f64`).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将探讨整数和浮点变量是如何工作的，不同类型的浮点和整数变量，以及如何对它们进行一些基本的二进制操作。首先，我们简要讨论一下 WebAssembly
    支持的四种主要数据类型。有两种整数数据类型（`i32` 和 `i64`）以及两种浮点数据类型（`f32` 和 `f64`）。
- en: Integers
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数
- en: Integer arithmetic is usually faster than floating-point arithmetic for most
    math operations. WebAssembly currently supports 32-bit and 64-bit integers but,
    unfortunately, cannot share 64-bit integers with JavaScript as easily as the other
    data types.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数数学运算，整数运算通常比浮点运算更快。WebAssembly 当前支持 32 位和 64 位整数，但不幸的是，不能像其他数据类型一样轻松地与
    JavaScript 共享 64 位整数。
- en: i32 (32-Bit Integers)
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: i32（32 位整数）
- en: The `i32` data type is fast, small, and easily moved between WebAssembly and
    JavaScript. It can represent between 0 and 4,294,967,295 as unsigned data and
    between –2,147,483,648 to 2,147,483,647 for signed integers. If you’re dealing
    with numbers that you know will be less than a billion in value and you don’t
    need fractional numbers, using `i32` is a great choice. Working with signed or
    unsigned values has more to do with the functions you perform on the data rather
    than the data in the variable. The `i32` data type represents negative numbers
    using 2s complement.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`i32` 数据类型速度快，占用空间小，并且可以在 WebAssembly 和 JavaScript 之间轻松传递。它可以表示无符号数据范围为 0 到
    4,294,967,295，表示有符号整数的范围为 -2,147,483,648 到 2,147,483,647。如果你处理的数字值不会超过十亿，并且不需要小数，使用
    `i32` 是一个不错的选择。处理有符号或无符号值更多的是与对数据进行的操作有关，而不是变量中的数据本身。`i32` 数据类型使用 2 补码表示负数。'
- en: 2s Complement
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2 补码
- en: The 2s complement is a widely used technique for representing negative numbers
    in a binary format. Computers only work in binary so only have memory with 1s
    and 0s. Binary can be translated into decimal fairly easily, but it’s less obvious
    how to represent a negative number with only 1s and 0s. It’s important to note
    that floating-point numbers have a dedicated sign bit and therefore don’t use
    2s complement.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 2 补码是一种广泛使用的技术，用于以二进制格式表示负数。计算机只以二进制工作，因此内存中只有 1 和 0。二进制可以相对容易地转换为十进制，但如何仅用
    1 和 0 表示负数却不太显而易见。需要注意的是，浮点数有专门的符号位，因此不使用 2 补码。
- en: To understand how 2s complement works, let’s digress into a metaphorical comparison.
    Imagine you have a push button tally counter and each time you press a button,
    it advances a little number dial by one ([Figure 4-2](#figure4-2)). This particular
    counter only has a single decimal digit display, so it starts at 0 and counts
    to 9, but when you click it a tenth time, it rolls back to 0\. From your counter’s
    perspective, adding 10 is the equivalent of adding 0, because your counter ends
    up in the same location as it started. Apropos of that, pressing the button 9
    times is functionally the same as subtracting 1 for all numbers except 0.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 2 的补码如何工作，让我们借用一个比喻来说明。假设你有一个按键计数器，每次按下一个按钮时，它都会将一个数字刻度拨动一位 ([图 4-2](#figure4-2))。这个计数器只有一个十进制数字显示，因此它从
    0 开始，计数到 9，但当你按下第十次时，它会回到 0。从计数器的角度来看，增加 10 等同于增加 0，因为你的计数器最终回到与起始位置相同的位置。顺便说一下，按下按钮
    9 次在功能上等同于减去 1，除了 0 之外的所有数字都是如此。
- en: '![f04002](Images/f04002.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![f04002](Images/f04002.png)'
- en: 'Figure 4-2: Nine rolls over to 0 when 1 is added.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-2：当加 1 时，9 会回到 0。
- en: Using the high-value numbers as negatives is only useful if you know that your
    numbers will be in a range that doesn’t include the chosen negative numbers. If
    you declare that 9 is equivalent to –1, but you need to count up to 9 with your
    counter, this number system won’t work. The rolling-over system is the reason
    that a signed 8-bit integer supports numbers from –128 to 127\. The unsigned 8-bit
    encoding of the number 255 (eight 1s) is the same as the signed 8-bit representation
    of –1 because adding 255 to any number causes the bits to roll over like an odometer
    and subtract one. The largest numbers become negative because they result in the
    bits rolling over. The code that performs a 2s complement conversion on binary
    digits uses a binary XOR to flip all of the bits and then adds the number 1 to
    the result, which results in the negative of the number. You’ll see the code to
    this function when we look at XOR and bit flipping later in this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将高位数作为负数使用仅在你知道你的数字范围不包括所选择的负数时才有用。如果你声明 9 等于 –1，但你需要用计数器数到 9，那么这个数字系统就无法工作。溢出系统是有符号
    8 位整数支持从 –128 到 127 的数字的原因。数字 255（八个 1）的无符号 8 位编码与 –1 的有符号 8 位表示相同，因为将 255 加到任何数字上会导致比特像里程表一样滚动并减去
    1。最大的数字变成负数是因为它们会导致比特溢出。执行 2 的补码转换的代码使用二进制异或（XOR）操作翻转所有位，然后将数字 1 加到结果上，从而得到该数字的负数。你将在本章稍后看到执行
    XOR 和位翻转的代码。
- en: i64 (64-Bit Integers)
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: i64（64 位整数）
- en: 'The `i64` data type can represent positive integer numbers between 0 and 18,446,744,073,709,551,615
    for unsigned integers and between –9,223,372,036,854,775,808 and 9,223,372,036,854,775,807
    for signed integers. The `i64` data type in WAT doesn’t specify whether it’s signed
    or unsigned when the variable is declared. Instead, WAT has to choose operations
    to perform on that data based on whether the user wants to treat the number as
    signed or unsigned. Not all operations require you to make that choice: for example,
    `i64.add`, `i64.sub`, and `i64.mul` all work the same whether the integers are
    signed or not. In contrast are the division functions, such as `i64.div_s` and
    `i64.div_u`. The division operation must treat the numbers differently if they’re
    signed or unsigned and so must have the `_s` and `_u` suffix appended to the different
    versions of the operation.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`i64` 数据类型可以表示无符号整数在 0 和 18,446,744,073,709,551,615 之间的正整数，以及有符号整数在 –9,223,372,036,854,775,808
    和 9,223,372,036,854,775,807 之间的整数。WAT 中的 `i64` 数据类型在声明变量时没有指定它是有符号还是无符号的。相反，WAT
    必须根据用户是否希望将数字视为有符号或无符号来选择执行的操作。并非所有操作都需要你做出这个选择：例如，`i64.add`、`i64.sub` 和 `i64.mul`
    无论整数是否有符号，都可以正常工作。与之对比的是除法函数，如 `i64.div_s` 和 `i64.div_u`。除法操作必须区分数字是有符号还是无符号，因此必须在不同版本的操作符后附加
    `_s` 和 `_u` 后缀。'
- en: As mentioned earlier, one problem with `i64` data types is that you cannot directly
    move 64-bit integers back and forth between WebAssembly and JavaScript. JavaScript
    only uses 64-bit floating-point numbers, but 64-bit floats can accommodate 32-bit
    integers and 32-bit floating-point numbers. The bottom line is that transferring
    64-bit integers to the JavaScript portion of your app can be a pain.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`i64` 数据类型的一个问题是你无法直接在 WebAssembly 和 JavaScript 之间来回传递 64 位整数。JavaScript
    只使用 64 位浮点数，但 64 位浮点数可以容纳 32 位整数和 32 位浮点数。最关键的问题是，将 64 位整数传递到 JavaScript 部分的应用中可能会很麻烦。
- en: Floating-Point Numbers
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点数
- en: 'A floating-point number contains three parts in binary: a sign bit, followed
    by a series of bits to represent the exponent, and then the bits that represent
    the significant digits (sometimes called the *mantissa* or *significand*). Remember,
    there is no decimal point in binary; computer scientists had to invent a system
    for representing decimal points inside a binary number. The sign bit indicates
    whether the number is positive or negative. The exponent signifies how many positions
    to move a decimal point (left or right), and the significant digits are simply
    the numbers for your floating-point number. Let’s look at how you could create
    floating-point numbers using base 10 by first using the exponent to raise a number:
    if you take a number like 345, and multiply it by 10 raised to a power of 2, it
    appends two zeros to the end of your number, as shown in [Figure 4-3](#figure4-3).
    This is effectively moving the decimal place two positions to the right.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数在二进制中包含三部分：符号位，后跟表示指数的一系列位，然后是表示有效数字的位（有时称为*尾数*或*有效数字*）。请记住，二进制中没有小数点；计算机科学家必须发明一种系统来表示二进制数中的小数点。符号位表示数字是正数还是负数。指数表示小数点需要移动多少位（左移或右移），有效数字则是浮点数的数字部分。让我们看看如何通过使用指数来构造十进制浮点数：如果你拿一个像345的数字，并将它乘以10的2次方，它会在数字的末尾添加两个零，如[图4-3](#figure4-3)所示。这实际上是将小数点向右移动了两位。
- en: '![f04003](Images/f04003.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![f04003](Images/f04003.png)'
- en: 'Figure 4-3: Shift the decimal point right with a positive exponent.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-3：使用正指数将小数点向右移动。
- en: Using only base 10 numbers, you would say that you have an exponent of 2 followed
    by 3 decimal digits, so 2345 would be the number 34,500, or 345 × 10² depicted
    in [Figure 4-4](#figure4-4).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用十进制数字，你会说指数是2，后跟3个小数位，因此2345就是数字34,500，或345 × 10²，如[图4-4](#figure4-4)所示。
- en: '![f04004](Images/f04004.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![f04004](Images/f04004.png)'
- en: 'Figure 4-4: Using a decimal exponent'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-4：使用十进制指数
- en: 'To get a fractional value, we need an exponent that is negative rather than
    positive, as shown in [Figure 4-5](#figure4-5): a negative exponent moves the
    decimal point to the left.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到分数值，我们需要一个负的指数而不是正的指数，如[图4-5](#figure4-5)所示：负指数将小数点向左移动。
- en: '![f04005](Images/f04005.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![f04005](Images/f04005.png)'
- en: 'Figure 4-5: Shift the decimal point left with a negative exponent.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-5：使用负指数将小数点向左移动。
- en: 'An exponent of negative 2 turns 345 into 3.45, resulting in a fractional value.
    Notice the problem with this system: so far we have no method for representing
    the negative nature of the first exponent bit. We said we could use 2345 to represent
    345 × 10², but we didn’t represent the minus sign. We can choose from one of two
    approaches: 2s complement and biased exponent. First, we could use a method like
    2s complement and assign the higher digit values negative numbers, so 8345 could
    represent 345 × 10^(–2) because 10 – 2 = 8\. But this isn’t the method the designers
    of floating-point numbers chose. Instead, they use a *biased exponent* where they
    simply subtract a particular chosen value from the exponent to give us the negative
    exponent. For example, if we decide to always subtract 5 from our exponent digit,
    3345 would represent 345 × 10^(–2) because 3 – 5 = –2.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 指数为负2时，345变成了3.45，结果是一个分数值。请注意，这种系统的问题：到目前为止，我们还没有方法来表示第一个指数位的负号。我们说过可以用2345来表示345
    × 10²，但我们没有表示负号。我们可以选择两种方法中的一种：2的补码和偏置指数。首先，我们可以使用像2的补码这样的方式，并将较高的数字值赋予负数，因此8345可以表示345
    × 10^(–2)，因为10 – 2 = 8。但这不是浮点数设计者选择的方法。相反，他们使用*偏置指数*，通过简单地从指数中减去一个特定的选定值来给出负指数。例如，如果我们决定总是从指数数字中减去5，那么3345就可以表示345
    × 10^(–2)，因为3 – 5 = –2。
- en: Real floating-point numbers are binary, not decimal, but the basic principles
    are the same. In binary floating-point numbers, the most significant bit is a
    sign bit, which is 0 if the number is positive and 1 if it’s negative. The eight
    bits that follow the sign bit represent the exponent. The mantissa represents
    a fractional number value between one and two. The leftmost bit represents a value
    of 0.5, followed by 0.25, 0.125, 0.0625, and so on, halving each time. Because
    the minimum value of the mantissa is 1, the actual value of the mantissa is always
    one greater than the sum of all these fraction bits. The layout of these bits
    is shown in [Figure 4-6](#figure4-6).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实数浮动点数是二进制的，而非十进制，但基本原理是相同的。在二进制浮动点数中，最高有效位是符号位，如果数值为正则为0，若为负则为1。符号位之后的八位表示指数。尾数表示一个介于一和二之间的分数值。最左侧的位表示0.5，接着是0.25、0.125、0.0625，依此类推，每次减半。因为尾数的最小值为1，所以尾数的实际值总是比所有这些分数字节的和大1。位的布局如[图4-6](#figure4-6)所示。
- en: '![f04006](Images/f04006.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![f04006](Images/f04006.png)'
- en: 'Figure 4-6: 32-bit floating-point bits'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-6：32位浮动点数位
- en: The fact that the mantissa has a minimum value of 1 creates a problem for the
    number 0\. Raising a non-zero value to any power can never result in a value of
    0\. To compensate for this, the exponent has two special values that allow for
    the representation of 0 and infinite values in the floating-point number. If all
    the bits in the exponent and mantissa are 0, then the number represented is 0,
    even though 0⁰ is 1\. Interestingly, floating-point numbers can represent 0 and
    –0 depending on the value in the sign bit. Infinity and –Infinity are values that
    have all of the exponent bits set to 1 and all of the mantissa bits set to 0\.
    If the mantissa bits aren’t 0, the floating-point is a NaN (not a number).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尾数的最小值为1的问题引出了数字0的处理。将一个非零值提升到任何幂次时永远不会得到0的值。为了弥补这一点，指数有两个特殊值，用于表示浮动点数中的0和无限大。如果指数和尾数的所有位都为0，则表示的数值为0，尽管0⁰为1。值得注意的是，浮动点数可以根据符号位的值表示0和-0。无限大和-无限大是指数位全为1，尾数位全为0的数值。如果尾数位不是0，则浮动点数表示为NaN（不是数字）。
- en: Subnormal Numbers
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 次正常数
- en: '*Subnormal numbers* (sometimes called *denormalized numbers*) are another floating-point
    edge case in the IEEE-754 specification for floating-point numbers. Subnormal
    numbers are an edge case where the exponent bits are all 0\. In the situation
    in which all the exponent bits are 0, the mantissa value no longer adds 1 to the
    value represented. This allows for even smaller decimal point values. We won’t
    use subnormal numbers in this book, but you should at least be aware of their
    existence.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*次正常数*（有时称为*非规范化数*）是IEEE-754浮动点数规范中的另一种浮动点数边界情况。次正常数是一种边界情况，其中指数位全为0。在所有指数位均为0的情况下，尾数值不再增加1到所表示的值。这使得可以表示更小的十进制数值。虽然本书中不使用次正常数，但你至少应该知道它们的存在。'
- en: f64/number
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: f64/number
- en: The `f64` data type is a double-precision 64-bit floating-point number. An `f64`
    has 52 bits that represent the significant digits, an 11-bit exponent, and a sign
    bit. This data type allows for high precision but on most hardware executes more
    slowly than integers or smaller floating-point numbers. One of its benefits is
    that it’s the same data type JavaScript uses for all of its numbers, making it
    a convenient data type for numbers that must be moved back and forth between JavaScript
    and WebAssembly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`f64`数据类型是双精度64位浮动点数。`f64`有52位表示有效数字，11位表示指数，1位表示符号位。该数据类型允许高精度，但在大多数硬件上，其执行速度比整数或较小的浮动点数要慢。它的一个优点是它是JavaScript用于所有数字的数据类型，使得它在JavaScript与WebAssembly之间转换数据时非常方便。'
- en: f32
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: f32
- en: The `f32` data type is smaller and faster than `f64` but has far less precision,
    giving you fewer significant digits to work with. The `f64` data type has roughly
    16 decimal significant digits for you to play with where an `f32` has only about
    seven. Because binary digits represent the significand, it doesn’t line up perfectly
    with decimal digits. The number of significant decimal digits is only an approximation,
    but it does give you a sense of each type’s limitations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`f32`数据类型比`f64`更小且更快，但精度要低得多，这意味着它能够使用的有效数字较少。`f64`数据类型大约有16位十进制有效数字，而`f32`只有大约七位。由于二进制数字表示有效数字，它与十进制数字并不完全对齐。有效十进制数字的数量只是一个近似值，但它能帮助你了解每种类型的限制。'
- en: High- and Low-Order Bits
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高位和低位
- en: In this section, we’ll look at bit significance. The low-order bit is the least
    significant bit of a binary number; significance simply means *representing the
    largest value*. In [Figure 4-7](#figure4-7), in the number 128, the digit 1 is
    the most significant digit and 8 is the least significant.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本节我们将讨论位的有效性。低位是二进制数的最低有效位；有效性意味着 *表示最大值*。[图 4-7](#figure4-7) 中，数字 128 中的 1
    是最高有效位，而 8 是最低有效位。
- en: '![f04007](Images/f04007.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![f04007](Images/f04007.png)'
- en: 'Figure 4-7: Most significant and least significant digits'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-7：最高有效位和最低有效位
- en: The digit representing the largest numeric value is the most significant. Here,
    1 is the most significant digit because it’s in the 100th place, and there are
    no digits representing numbers in a higher position. The sad little 8 in the illustration
    is the least significant digit because it represents the 1s place.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 代表最大数值的数字是最高有效位。在这里，1 是最高有效位，因为它处于 100 位，而没有更高位的数字。插图中的那个可怜的小 8 是最低有效位，因为它表示的是个位数。
- en: Binary numbers also have higher-order digits. On a computer, one byte is always
    eight binary digits; even if the number is 00000001, the left seven binary digits
    are still in the byte. For example, the number 37 is 100101 in binary, but in
    computer memory, the value in the byte is 00100101\. The most significant bit
    (high-order bit) in this byte is the leftmost 0, as shown in [Figure 4-8](#figure4-8).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数也有高位。在计算机中，一个字节总是由八个二进制位组成；即使数字是 00000001，左边的七个二进制位仍然存在于字节中。例如，数字 37 的二进制表示是
    100101，但在计算机内存中，字节中的值是 00100101。该字节中的最高有效位（高位）是最左边的 0，如[图 4-8](#figure4-8)所示。
- en: '![f04008](Images/f04008.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![f04008](Images/f04008.png)'
- en: 'Figure 4-8: High-order and low-order bit'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-8：高位和低位
- en: The low-order bit in this byte is the 1 on the far right, and the high-order
    bit is the 0 on the far left.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该字节中的低位是最右侧的 1，高位是最左侧的 0。
- en: Looking at just the high-order and low-order bits of a variable can reveal some
    information about a byte. The low-order bit in an integer indicates whether that
    integer has an even (0) or odd (1) value. The high-order bit of a signed integer
    determines whether that number is positive (0) or negative (1).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅查看变量的高位和低位可以揭示一些字节的信息。整数中的低位表示该整数是偶数（0）还是奇数（1）。带符号整数的高位决定了该数字是正数（0）还是负数（1）。
- en: Bit Operations
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位操作
- en: WebAssembly offers data manipulation at a low level of abstraction. If you’re
    willing to put in the work, you can frequently provide better code performance
    by manipulating data at the level of bits. Understanding how these operations
    work can also be useful when you’re trying to improve your code’s performance,
    even in high-level languages. We’ll use many of the operations in this chapter
    in applications we write later in the book, so refer back to this chapter as needed.
    These operations are very general purpose, so it’s difficult to give an example
    of when we would use them. However, as situations arise, it will be obvious which
    operation is suitable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 提供了低级别的数据操作抽象。如果你愿意付出努力，通过在位级别进行数据操作，你可以经常提供更好的代码性能。了解这些操作如何工作也可以在你尝试提高代码性能时发挥作用，即使是在高级语言中。我们将在本书后面写的应用中使用本章中的许多操作，因此根据需要回顾这一章。这些操作非常通用，因此很难给出具体的应用实例。然而，当实际情况出现时，哪个操作适用会显而易见。
- en: Shifting and Rotating Bits
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移位和旋转位
- en: In this section, we’ll cover shifting and rotating bits. These are fundamental
    bit manipulation operations that we’ll use from time to time in this book. A single
    byte of data is made up of eight bits and can hold a number from 0 to 255 in decimal,
    which is the same as 0 to FF in hexadecimal. Did you know that four bits are called
    a *nibble*? Single hexadecimal digits are made up of a single nibble (half a byte)
    and can be a value from 0 to 15 in decimal and 0 to F in hexadecimal.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍位的移位和旋转操作。这些是基本的位操作，我们在本书中会时常使用。一个字节的数据由八个位组成，可以存储从 0 到 255 的十进制数值，等同于从
    0 到 FF 的十六进制值。你知道四个位称为 *半字节*（nibble）吗？单个十六进制数字由一个半字节（半个字节）组成，十进制值为 0 到 15，十六进制值为
    0 到 F。
- en: The fact that four bits can store a single hexadecimal digit makes it relatively
    easy to work with hexadecimal numbers in WAT, especially when it comes to *shifting*.
    Shifting is a generic operation that’s a building block for the optimizations
    we’ll discuss in later chapters. Shifting is somewhat like pushing bits off a
    cliff and replacing them with 0s (or 1s for some signed right shifts). You can
    shift by any number of bits and in either the left or right direction. For example,
    the binary 1110 1001 is E9 in hexadecimal (and 233 in decimal). If we shift that
    number 4 bits to the right using the `(i32.shr_u``)` expression, it returns the
    binary 0000 1110 or 0E in hexadecimal. [Figure 4-9](#figure4-9) shows a dramatization
    of a four-bit shift of E9.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 四个位可以存储一个十六进制数字，这使得在WAT中处理十六进制数字相对容易，尤其是在进行*移位*时。移位是一种通用操作，是我们在后续章节中讨论的优化的基础。移位有点像将位从悬崖上推下来，并用0（或者对于某些带符号的右移，用1）替换它们。你可以按任意数量的位进行移位，且可以向左或向右移位。例如，二进制1110
    1001在十六进制中是E9（在十进制中是233）。如果我们使用`(i32.shr_u)`表达式将该数字右移4位，它将返回二进制0000 1110，或在十六进制中是0E。[图4-9](#figure4-9)展示了E9四位右移的戏剧化效果。
- en: '![f04009](Images/f04009.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![f04009](Images/f04009.png)'
- en: 'Figure 4-9: Shifting hexadecimal E9 four bits to the right results in 0E.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-9：将十六进制E9右移四位得到0E。
- en: Shifting data to the right can be a useful trick. Every bit you shift to the
    right is the functional equivalent of dividing by 2\. Similarly, every bit you
    shift to the left is the functional equivalent of multiplying by 2\. You can use
    shifting in combination with masking to isolate sections of binary data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据向右移位可以是一种有用的技巧。每向右移一位，相当于除以2。同样，每向左移一位，相当于乘以2。你可以将移位与位屏蔽结合使用，以隔离二进制数据的某些部分。
- en: Left-shifting in WebAssembly is sign-independent, but to right-shift we use
    a signed or an unsigned shift operation. When you right-shift or left-shift a
    binary number, the bits shifted off are usually replaced on the opposite side
    of the integer with 0s. However, with a negative number, if you sign-shift to
    the right, 1s will be sign-shifted in from the left side to preserve the integer’s
    sign. Sign-shifting a 2s complement representation preserves the sign (negativeness).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebAssembly中，左移是不依赖符号的，但右移时我们使用带符号或无符号的移位操作。当你进行二进制数的右移或左移时，被移出的位通常会被用0替换到整数的另一侧。然而，对于负数，如果进行带符号的右移，1会从左侧移入，以保持整数的符号。对二进制补码进行符号移位，可以保持符号（即负号）。
- en: '*Bit rotation*, unlike a shift, flips bits back around to the other side of
    the variable. If you rotate a bit to the right, the least significant bit is transferred
    to the front and ends up as the most significant bit, and all the other bits shift
    to the right. WAT does bit rotation with the `rotl` (rotate left) or `rotr` (rotate
    right) commands, depicted in [Figure 4-10](#figure4-10).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*位旋转*与移位不同，它将位反转并移到变量的另一侧。如果你将位向右旋转，最不重要的位将转移到最前面，成为最重要的位，其他所有位都将向右移位。WAT使用`rotl`（向左旋转）或`rotr`（向右旋转）命令进行位旋转，如[图4-10](#figure4-10)所示。'
- en: '![f04010](Images/f04010.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![f04010](Images/f04010.png)'
- en: 'Figure 4-10: Rotating a bit to the right'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-10：将位向右旋转
- en: Masking Bits with AND and OR
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用AND和OR进行位屏蔽
- en: '*Bit masking*is a method used to set some specified bits in an integer to 1
    or 0, depending on the kind of mask we use, to isolate or override them. This
    can be very helpful when writing high-performance applications. Also, it’s important
    to know that WebAssembly doesn’t have the concept of boolean values. Comparisons
    in WebAssembly usually return a value of 1 for true and 0 for false. You must
    use the `i32.and` and `i32.or` when, in many languages, you would use boolean
    logic. In this section, we’ll use the `i32.and` and `i32.or` to isolate or override
    bit values with bit masking.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*位屏蔽*是一种方法，用于根据我们使用的掩码类型，将整数中的某些指定位设置为1或0，从而隔离或覆盖它们。在编写高性能应用程序时，这非常有用。此外，需要知道WebAssembly没有布尔值的概念。在WebAssembly中，比较通常返回1表示真，0表示假。当你在许多编程语言中使用布尔逻辑时，必须使用`i32.and`和`i32.or`。在本节中，我们将使用`i32.and`和`i32.or`进行位屏蔽，隔离或覆盖位值。'
- en: When you mask with a bitwise AND, the 0 bits in your integer win the battle
    of the bits. The 0 bits in the mask act like masking tape that covers up any other
    bit in the integer, replacing them with 0s. The 1 bits in the mask allow the original
    value to show through. [Figure 4-11](#figure4-11) shows what it looks like to
    mask binary 1011 1110 (190) with 0000 0111 (7).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用按位 AND 进行掩码时，整数中的 0 位在比特位的竞争中获胜。掩码中的 0 位就像胶带一样，覆盖了整数中的任何其他位，并将它们替换为 0。掩码中的
    1 位则允许原始值透过掩码显示。[图 4-11](#figure4-11)展示了将二进制 1011 1110（190）与 0000 0111（7）进行 AND
    掩码的效果。
- en: As you can see in [Figure 4-11](#figure4-11), all of the bits of our original
    value are covered by the 0s in the AND mask. When a bitwise AND operation is performed
    on two different integers, the 0 bit wins ([Figure 4-12](#figure4-12)).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[图 4-11](#figure4-11)中看到的，原始值的所有位都被 AND 掩码中的 0 覆盖。当对两个不同的整数执行按位 AND 操作时，0
    位胜出（参见[图 4-12](#figure4-12)）。
- en: '![f04011](Images/f04011.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![f04011](Images/f04011.png)'
- en: 'Figure 4-11: Masking bits with bitwise AND'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-11：使用按位 AND 进行掩码
- en: '![f04012](Images/f04012.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![f04012](Images/f04012.png)'
- en: 'Figure 4-12: Bitwise AND 0 wins the battle of the bits.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-12：按位 AND 操作，0 位胜出
- en: 'When you mask with OR, using an `i32/i64.or`, the results would be the exact
    opposite: 1 bits cover up any bits with 1s. You cannot use the OR mask to isolate
    bits as with an AND. Instead, you use it to set specific bits to 1\. [Figure 4-13](#figure4-13)
    shows masking with OR.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 OR 掩码时，使用 `i32/i64.or` 操作，结果恰好相反：1 位会覆盖任何包含 1 的位。你不能像使用 AND 掩码那样隔离位。相反，你使用它将特定位设置为
    1。[图 4-13](#figure4-13)展示了使用 OR 进行掩码的效果。
- en: '![f04013](Images/f04013.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![f04013](Images/f04013.png)'
- en: 'Figure 4-13: Masking with a bitwise OR'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-13：使用按位 OR 进行掩码
- en: As you can see in [Figure 4-13](#figure4-13), when you use a bitwise OR, the
    1 bits in your mask cover any bits in your initial integer value. So in a bitwise
    OR situation, the 1 bit wins over the 0 bit ([Figure 4-14](#figure4-14)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[图 4-13](#figure4-13)中看到的，使用按位 OR 操作时，掩码中的 1 位覆盖了初始整数值中的任何位。因此，在按位 OR 操作中，1
    位会覆盖 0 位（参见[图 4-14](#figure4-14)）。
- en: '![f04014](Images/f04014.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![f04014](Images/f04014.png)'
- en: 'Figure 4-14: In a bitwise OR, the 1 bit always wins.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-14：在按位 OR 中，1 位总是胜出。
- en: XOR Bit Flip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XOR 位翻转
- en: The last binary operation we’ll cover is XOR. With AND and OR, the results of
    a mask are clear. The XOR `i32/i64.xor` operation is a little different. If a
    0 masks a 0, a 1 masks a 0, or a 0 masks a 1, the XOR operates just like a typical
    `i32/i64.or`. The weirdness occurs when you have two 1s, which results in the
    XOR setting the resulting bit to 0\. This feature is handy for *bit flipping*,
    where you invert each bit to its opposite. Certain operations require you to change
    every 1 bit in an integer to a 0 and every 0 bit to a 1\. [Figure 4-15](#figure4-15)
    shows how to flip every bit in a nibble with an XOR.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讲解的最后一个二进制操作是 XOR。与 AND 和 OR 不同，掩码的结果是明确的。XOR `i32/i64.xor` 操作稍有不同。如果 0
    遮掩了 0，1 遮掩了 0，或 0 遮掩了 1，XOR 操作就像典型的 `i32/i64.or` 操作一样。奇怪的地方出现在两个 1 的情况下，这会导致 XOR
    操作将结果位设置为 0。这个特性对于 *位翻转* 很有用，它能将每个位翻转为其相反值。有些操作要求你将整数中的每个 1 位改为 0，将每个 0 位改为 1。[图
    4-15](#figure4-15)展示了如何使用 XOR 翻转一个字节中的每一位。
- en: '![f04015](Images/f04015.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![f04015](Images/f04015.png)'
- en: 'Figure 4-15: XOR bit flip'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-15：XOR 位翻转
- en: In our 2s complement discussion earlier, we noted that if you want to find the
    negative of any number, you can do so by flipping every bit and adding the number
    1\. You can flip all the bits using an `XOR` against an integer that has every
    bit set to 1\. Let’s write a short app that converts an integer value to its negative
    using 2s complement and bit flipping. Create a file named *twos_complement.wat*
    and add the code in [Listing 4-1](#listing4-1).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前讨论的 2 补码中，我们提到，如果你想找到任何数的负数，你可以通过翻转每个位并加上 1 来实现。你可以通过对一个所有位都设置为 1 的整数进行
    `XOR` 操作来翻转所有位。让我们编写一个小应用程序，使用 2 补码和位翻转将一个整数值转换为其负数。创建一个名为 *twos_complement.wat*
    的文件，并将[列表 4-1](#listing4-1)中的代码添加进去。
- en: '**twos_complement.wat**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**twos_complement.wat**'
- en: '[PRE0]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 4-1: 2s complement function'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-1：2 补码函数
- en: This is a very simple module that takes an `i32` parameter called `$number`.
    We push the `i32` onto the stack, followed by a 32-bit number where all the bits
    are 1 1. When we call `i32.xor` 2, all of the bits from the original number are
    flipped. Every 1 is turned into a 0 and every 0 into a 1\. We then call `i32.add`
    3 to add a value of 1 to this number to get 2s complement, resulting in the negative
    number. This code works well as a demonstration of how 2s complement works; however,
    it would perform better if we just subtracted `$number` from `0` to negate it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的模块，接受一个名为`$number`的`i32`参数。我们将`i32`推送到栈上，接着是一个所有位都是1的32位数字。当我们调用`i32.xor`
    2时，原始数字的所有位都会被翻转。每个1变为0，每个0变为1。然后我们调用`i32.add` 3，将该数字加上1，得到2的补码，从而得到负数。这个代码作为2的补码工作原理的演示非常有效；然而，如果我们只是从`0`中减去`$number`来取反，它会表现得更好。
- en: Big-Endian vs. Little-Endian
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大端与小端
- en: All numbers you’re familiar with are arranged in a *big-endian*format, meaning
    the highest-order digits are on the left side and the lowest-order digits are
    on the right side. Most computer hardware uses *little-endian*, where the lowest-order
    digit is on the left and the high-order digit is on the right, so one hundred
    twenty-eight would be written as 821 instead. Keep in mind that endianness is
    about byte order, not digit order, so my little-endian decimal 821 example is
    an oversimplification that can’t be directly translated to binary. Little-endian
    hardware orders the bytes in reverse of what is typical. The number 168,496,141
    written in big-endian hex is 0A0B0C0D. The high-order byte is 0A, and the low-order
    byte is 0D because each hex digit is represented by a nibble or half a byte. If
    we order the bytes in little-endian order, they’re arranged as 0D0C0B0A, as illustrated
    in [Figure 4-16](#figure4-16).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你熟悉的所有数字都采用*大端*格式排列，这意味着最高位的数字在左侧，最低位的数字在右侧。大多数计算机硬件使用*小端*格式，其中最低位的数字在左侧，最高位的数字在右侧，因此128会写成821。请记住，字节序指的是字节顺序，而不是数字顺序，所以我使用的小端十进制821示例是一个过于简化的例子，不能直接转化为二进制。小端硬件将字节按照与典型顺序相反的方式排序。数字168,496,141用大端十六进制表示为0A0B0C0D。高位字节是0A，低位字节是0D，因为每个十六进制数字由一个半字节（nibble）表示。如果我们按照小端字节序排序字节，它们将按0D0C0B0A排列，如[图4-16](#figure4-16)所示。
- en: '![f04016](Images/f04016.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![f04016](Images/f04016.png)'
- en: 'Figure 4-16: Big-endian versus little-endian byte order'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-16：大端与小端字节序
- en: Most hardware today arranges bytes in little-endian order for performance reasons.
    WebAssembly uses little-endian byte order regardless of the hardware. When you’re
    initializing data using the `(data``)` statement in WebAssembly, it’s important
    to keep the byte order in mind.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 目前大多数硬件出于性能原因使用小端字节序。WebAssembly 无论硬件如何，都会使用小端字节序。当你在 WebAssembly 中使用`(data)`语句初始化数据时，保持字节顺序非常重要。
- en: Summary
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered a lot of low-level programming concepts. We looked at the
    different numeric bases (decimal, hexadecimal, and binary) used in low-level programming.
    We examined the details of integer and floating-point arithmetic, and touched
    on 2s complement as well as big-endian and little-endian byte order. We talked
    about bit manipulation, including discussions of high-order and low-order bits,
    bit masking, bit shifting, and bit rotation. These low-level options will become
    useful for applications in later chapters that enhance performance by manipulating
    bits.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了许多低级编程概念。我们查看了低级编程中使用的不同数字进制（十进制、十六进制和二进制）。我们研究了整数和浮点算术的细节，并涉及了2的补码以及大端和小端字节序。我们讨论了位操作，包括高位和低位、位掩码、位移和位旋转。这些低级选项将在后续章节的应用中变得有用，通过操作位来提高性能。
- en: In the next chapter, you’ll learn several methods for managing strings as data
    structures, including null-terminated strings and length-prefixed strings. We’ll
    also explore copying strings and converting numeric data into strings in decimal,
    hexadecimal, and binary formats.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将学习几种管理字符串作为数据结构的方法，包括空字符终止字符串和长度前缀字符串。我们还将探索复制字符串以及将数字数据转换为十进制、十六进制和二进制格式的过程。
