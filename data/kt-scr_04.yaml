- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 3 VISUALIZING WITH JAVAFX
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3 使用 JavaFX 进行可视化
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/icon.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/icon.jpg)'
- en: Data visualization is the art of presenting complex data in a visually accessible
    format, allowing for quick and effective understanding. Through charts, graphs,
    maps, and other graphical representations, data visualization not only simplifies
    data interpretation but also uncovers patterns, trends, and insights that might
    otherwise be overlooked.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可视化是一种将复杂数据以视觉可访问的格式呈现的艺术，使得理解更加快速和有效。通过图表、图形、地图以及其他图形化表示，数据可视化不仅简化了数据的解读，还揭示了那些可能被忽视的模式、趋势和洞察。
- en: By transforming raw data into meaningful and actionable knowledge, visualization
    plays a pivotal role in decision-making across various domains, such as business
    analytics and scientific research. Another facet of data visualization involves
    the creation and presentation of intricate objects and patterns on a screen, often
    incorporating dynamic or moving elements within simulations or optimization processes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将原始数据转化为有意义和可操作的知识，可视化在各个领域的决策过程中起着至关重要的作用，例如商业分析和科学研究。数据可视化的另一个方面是创建和展示复杂的物体和图案，通常在仿真或优化过程中结合动态或移动元素。
- en: In this chapter, we’ll explore creating data visualization and other output
    with Kotlin code. We’ll focus on the JavaFX library, allowing us to build standard
    charts, free-form drawings, and even animations. The programming patterns we cover
    in this chapter will pay dividends in later chapters when we work on projects
    with more elaborate visual components.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索使用 Kotlin 代码创建数据可视化和其他输出内容。我们将重点介绍 JavaFX 库，它使我们能够构建标准图表、自由形式的图形甚至动画。本章中涵盖的编程模式将在后续章节中起到重要作用，特别是在我们处理更复杂的可视化组件项目时。
- en: Data Visualization Tools for Kotlin
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kotlin 的数据可视化工具
- en: 'Several data visualization tools, both commercial and free, are available to
    run with Kotlin on the JVM. These tools make it possible to create interactive
    plots and charts and, in some cases, free-form drawings and fully featured user
    interfaces (UIs). They offer a variety of features and customization options to
    suit your needs. Here’s an overview of some of the visualization tools available:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多数据可视化工具（包括商业和免费的）可在 Kotlin 上的 JVM 上运行。这些工具使得创建交互式图表和图形成为可能，在某些情况下，还可以进行自由形式的绘图和创建功能齐全的用户界面（UI）。它们提供了多种功能和定制选项，以满足你的需求。以下是一些可用的可视化工具概述：
- en: '**Lets-Plot**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lets-Plot**'
- en: A multiplatform plotting library for Kotlin that can be used to create interactive
    plots and charts. It’s primarily used to access graphics features within a Jupyter
    Notebook, a web application that facilitates the creation and sharing of documents
    containing live code, narrative text, and visualizations. You can access Lets-Plot’s
    graphics library through application programming interface (API) calls with predefined
    syntax. Lets-Plot doesn’t have a free-form drawing or sketching tool comparable
    to Tkinter in Python or the Canvas class in JavaFX.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个多平台的 Kotlin 绘图库，可用于创建交互式图表和图形。它主要用于在 Jupyter Notebook 中访问图形功能，这是一种支持创建和共享包含实时代码、叙述文本和可视化内容的文档的
    Web 应用程序。你可以通过预定义语法的应用程序编程接口（API）调用来访问 Lets-Plot 的图形库。Lets-Plot 没有类似 Python 中
    Tkinter 或 JavaFX 中 Canvas 类的自由绘图工具。
- en: '**Plotly**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**Plotly**'
- en: Another tool for creating interactive plots and charts for Kotlin applications.
    Plotly works on various platforms, including the JVM, JavaScript, and Python.
    Plotly is user friendly, has a simple API, and offers many customization options.
    Like Lets-Plot, it lacks a free-form drawing tool.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于为 Kotlin 应用程序创建交互式图表和图形的工具。Plotly 可以在多种平台上运行，包括 JVM、JavaScript 和 Python。Plotly
    用户友好，提供简单的 API，并且具有许多自定义选项。与 Lets-Plot 相似，它缺少自由绘图工具。
- en: '**Jetpack Compose**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jetpack Compose**'
- en: A modern UI toolkit for building native Android, desktop, and web applications
    using a single codebase. While Jetpack Compose doesn’t have built-in support for
    charting, third-party libraries are available for creating interactive plots and
    charts. Jetpack Compose provides a canvas API that can be used to draw custom
    graphics and shapes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个现代的 UI 工具包，用于构建本地 Android、桌面和 Web 应用程序，使用单一代码库。尽管 Jetpack Compose 不支持内置图表功能，但可以通过第三方库来创建交互式图表和图形。Jetpack
    Compose 提供了一个画布 API，可用于绘制自定义图形和形状。
- en: '**JavaFX**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaFX**'
- en: An open source framework that lets you use Java to create applications for desktop,
    mobile, and embedded systems. It results from a collaborative effort by many individuals
    and companies that aim to provide a modern, efficient, and fully featured toolkit
    for developing rich client applications. You can use JavaFX to create user interfaces
    and interactive visualizations, as well as various charts such as line charts,
    bar charts, pie charts, and scatterplots. JavaFX works well with Kotlin because
    of its compatibility with Java.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个开源框架，允许你使用 Java 创建桌面、移动和嵌入式系统的应用程序。它是许多个人和公司共同努力的结果，旨在提供一个现代化、高效且功能齐全的工具包，用于开发丰富的客户端应用程序。你可以使用
    JavaFX 创建用户界面和互动可视化，以及各种图表，如折线图、柱状图、饼图和散点图。由于与 Java 的兼容性，JavaFX 也能与 Kotlin 很好地配合使用。
- en: In this book, we’ll use JavaFX as the graphics library of choice. This is because
    it’s a mature and feature-rich library that’s well documented and can seamlessly
    integrate with both Java and Kotlin applications. Most important, it has built-in
    features for charting and free-form drawing, including pixel-level manipulation
    of the display screen. These features will be useful in some projects we’ll work
    on later in the book.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用 JavaFX 作为图形库。之所以选择它，是因为它是一个成熟且功能丰富的库，文档完善，并且能够与 Java 和 Kotlin 应用程序无缝集成。最重要的是，它内置了图表和自由绘图的功能，包括对显示屏的像素级操作。这些功能将在本书后面我们将要进行的一些项目中派上用场。
- en: An Overview of JavaFX
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaFX 概述
- en: JavaFX was first introduced by Sun Microsystems in 2007 as a modern replacement
    for the aging Java Swing framework. It marked a significant step forward in Java’s
    capabilities for creating GUIs and multimedia-rich applications. Initially, JavaFX
    was shipped as part of the Java Development Kit (JDK). However, Oracle, the company
    that acquired JavaFX from Sun Microsystems, announced in 2018 that JavaFX would
    be open sourced and moved to the OpenFX project. The same year, JavaFX 11 was
    released as a stand-alone framework, decoupled from the JDK.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 首次由 Sun Microsystems 于 2007 年推出，作为老旧的 Java Swing 框架的现代替代品。它标志着 Java 在创建图形用户界面和多媒体丰富应用程序方面的重要进步。最初，JavaFX
    作为 Java 开发工具包（JDK）的一部分发布。然而，收购了 JavaFX 的公司 Oracle 在 2018 年宣布，JavaFX 将开源并移至 OpenFX
    项目。同年，JavaFX 11 作为独立框架发布，脱离了 JDK。
- en: JavaFX has evolved over the years, thanks to numerous updates and improvements
    from its developers. It continues to thrive as an open source project under the
    stewardship of the OpenJFX community and is included as a standard library in
    many Java distributions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 多年来不断发展，得益于开发者的众多更新和改进。它作为一个开源项目在 OpenJFX 社区的支持下蓬勃发展，并作为标准库包含在许多 Java
    发行版中。
- en: Key Functionalities
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关键功能
- en: 'JavaFX is a comprehensive toolkit for building cross-platform applications.
    While this chapter focuses on its charting and drawing features, JavaFX offers
    many other features that you can use in your projects. Here’s a quick overview
    of its key functionalities:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 是一个综合性的工具包，用于构建跨平台应用程序。虽然本章重点介绍其图表和绘图功能，JavaFX 还提供许多其他功能，你可以在项目中使用。以下是其关键功能的快速概览：
- en: '**UI development**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户界面开发**'
- en: JavaFX enables the developer to simplify and enhance the development of visually
    rich and interactive user interfaces for desktop, web, and mobile applications.
    It provides a wide variety of UI controls, layouts, and styles, allowing the creation
    of visually appealing and highly customizable interfaces.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 使开发者能够简化并增强桌面、网页和移动应用程序中视觉丰富且互动性强的用户界面的开发。它提供了各种 UI 控件、布局和样式，使得创建视觉吸引且高度可定制的界面成为可能。
- en: '**Cross-platform compatibility**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨平台兼容性**'
- en: JavaFX is designed to create applications that can run on various platforms,
    including Windows, macOS, Linux, and mobile devices, without major modifications.
    This cross-platform compatibility reduces development effort and allows for broader
    application distribution.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 旨在创建能够在多个平台上运行的应用程序，包括 Windows、macOS、Linux 和移动设备，而无需做重大修改。这种跨平台的兼容性减少了开发工作量，并允许更广泛的应用分发。
- en: '**Charts and data visualization**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**图表与数据可视化**'
- en: JavaFX includes built-in support for creating various charts and graphs, making
    it a preferred choice for data visualization applications.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 内置支持创建各种图表和图形，使其成为数据可视化应用程序的首选。
- en: '**3D graphics**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**3D 图形**'
- en: JavaFX provides versatile 3D graphics capabilities for developing mathematical
    and scientific applications that require 3D visualizations.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 提供了多功能的 3D 图形能力，适用于开发需要 3D 可视化的数学和科学应用程序。
- en: '**Rich media support**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**丰富的媒体支持**'
- en: JavaFX is known for its robust multimedia support, making it suitable for applications
    that require video, audio, animations, and 2D or 3D graphics.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 以其强大的多媒体支持而闻名，使其适用于需要视频、音频、动画以及 2D 或 3D 图形的应用程序。
- en: '**High performance**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**高性能**'
- en: JavaFX provides hardware acceleration and optimizations for improved rendering
    performance, making it suitable for applications demanding smooth animations and
    responsive interfaces.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 提供了硬件加速和优化，提升了渲染性能，适用于对流畅动画和响应式界面有较高需求的应用程序。
- en: '**Integration with Java and Kotlin**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**与 Java 和 Kotlin 的集成**'
- en: JavaFX seamlessly integrates with the Java programming language, leveraging
    the robustness, security, and ecosystem of Java. Since Kotlin is fully interoperable
    with Java, JavaFX is a natural choice for developing desktop and web-based applications
    in Kotlin.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 与 Java 编程语言无缝集成，利用了 Java 的稳健性、安全性和生态系统。由于 Kotlin 与 Java 完全互操作，JavaFX
    成为开发 Kotlin 桌面和基于 Web 的应用程序的自然选择。
- en: For more information about JavaFX features, see the project website at [https://openjfx.io](https://openjfx.io).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 JavaFX 特性的更多信息，请参见项目网站 [https://openjfx.io](https://openjfx.io)。
- en: Setup
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置
- en: If you’ve followed the steps for installing IntelliJ IDEA and the Azul Zulu
    JDK as described in the appendix, you’re all set to start using JavaFX with Kotlin.
    You can access JavaFX features just as you’ve been accessing Kotlin features from
    the IDE. While the support for Kotlin is integrated within the IDE itself, the
    access to JavaFX is gained through the installed JDK.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照附录中描述的步骤安装了 IntelliJ IDEA 和 Azul Zulu JDK，那么你已经可以开始使用 JavaFX 和 Kotlin 了。你可以像在
    IDE 中访问 Kotlin 特性一样访问 JavaFX 特性。尽管 Kotlin 的支持已集成在 IDE 本身中，但访问 JavaFX 是通过已安装的 JDK
    实现的。
- en: If you haven’t followed the instructions in the appendix, I recommend using
    a JDK with JavaFX prepackaged so you can avoid the extra steps needed to link
    the library to your code. For example, Azul JDK FX and Liberica Full JDK are well-known
    distributions with integrated JavaFX support. Alternatively, you can download
    and install JavaFX separately from the OpenJFX website. There you’ll find detailed
    instructions on how to set up JavaFX for various operating systems, such as Windows,
    macOS, and Linux, including how to access JavaFX from your IDE.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有按照附录中的说明操作，我建议使用预装 JavaFX 的 JDK，这样你就可以避免需要将库链接到代码中的额外步骤。例如，Azul JDK FX
    和 Liberica Full JDK 是集成了 JavaFX 支持的知名发行版。或者，你可以从 OpenJFX 网站单独下载并安装 JavaFX。网站上提供了如何为各种操作系统（如
    Windows、macOS 和 Linux）设置 JavaFX 的详细说明，包括如何在 IDE 中访问 JavaFX。
- en: Once both Kotlin and JavaFX are accessible from the IDE, you can focus on creating
    new JavaFX applications in Kotlin. The process is similar to creating regular
    Kotlin programs, except that you need to add some boilerplate JavaFX code, which
    I’ll explain in detail next.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Kotlin 和 JavaFX 都可以从 IDE 访问，你就可以专注于在 Kotlin 中创建新的 JavaFX 应用程序。这个过程与创建常规 Kotlin
    程序类似，不同之处在于你需要添加一些模板化的 JavaFX 代码，我将在接下来的部分详细解释。
- en: 'Project 3: Build “Hello, World!” in JavaFX'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 3：在 JavaFX 中构建“Hello, World！”
- en: 'In this project, I’ll walk you through the process of building a simple “Hello,
    world!” application using JavaFX and Kotlin. This will serve as the foundation
    for constructing other applications that leverage JavaFX’s charting and visualization
    features. First, follow these steps to create a new JavaFX-enabled application
    from scratch:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，我将引导你通过使用 JavaFX 和 Kotlin 构建一个简单的“Hello, world!”应用程序的过程。这将作为构建其他利用 JavaFX
    图表和可视化功能的应用程序的基础。首先，按照以下步骤从头开始创建一个启用 JavaFX 的新应用程序：
- en: 1.  Open IntelliJ IDEA and create a new Kotlin project by navigating to **File****New****Project**.
    You’ll be taken to the project setup window shown in [Figure 3-1](chapter3.xhtml#fig3-1).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 打开 IntelliJ IDEA，创建一个新的 Kotlin 项目，路径为**文件****新建****项目**。你将进入项目设置窗口，如[图
    3-1](chapter3.xhtml#fig3-1)所示。
- en: '![](../images/Figure3-1.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-1.jpg)'
- en: 'Figure 3-1: Configuration options for JavaFX-based Kotlin projects'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1：基于 JavaFX 的 Kotlin 项目的配置选项
- en: 2.  Name the project HelloWorld and note its location. Then select **Kotlin**
    as the language and **Maven** as the build system and choose a JDK that includes
    integrated support for JavaFX. (If you’ve followed the instructions in the appendix,
    that’ll be the latest long-term support version of Azul Zulu JDK FX.) For all
    JavaFX-based projects covered in this book, we’ll use these same settings (apart
    from the project name), as they eliminate the need for additional steps, such
    as manually linking a separate JavaFX library to the project.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将项目命名为 HelloWorld，并注意其存放位置。然后选择 **Kotlin** 作为语言，选择 **Maven** 作为构建系统，并选择包含 JavaFX
    集成支持的 JDK。（如果您按照附录中的说明操作，那么应该选择最新的长期支持版本的 Azul Zulu JDK FX。）对于本书中所有基于 JavaFX 的项目，我们将使用这些相同的设置（除了项目名称），因为这些设置省去了额外步骤，比如手动将独立的
    JavaFX 库链接到项目中。
- en: NOTE
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*You may notice that the left-hand panel of IntelliJ IDEA has an option to
    autogenerate a new JavaFX project, complete with a default “Hello!” window. This
    preconfigured setup comes with objects and files that may not be necessary for
    each project, so I recommend creating a project from scratch and including only
    the required code and objects, as outlined here.*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*您可能会注意到，IntelliJ IDEA 的左侧面板有一个选项，可以自动生成一个新的 JavaFX 项目，并带有一个默认的“Hello!”窗口。这个预配置的设置包含了一些对于每个项目可能并不必要的对象和文件，因此我建议从头创建一个项目，并仅包含所需的代码和对象，正如这里所述。*'
- en: 3.  Click **Create** to create a new project with the correct configuration.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **Create** 创建具有正确配置的新项目。
- en: 4.  In the project panel on the left side of the IDE, expand the project tree
    by navigating to **HelloWorld****src****main****kotlin**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDE 左侧的项目面板中，通过依次展开项目树中的**HelloWorld****src****main****kotlin**来查看项目。
- en: 5.  Right-click the kotlin folder and choose **New****Kotlin Class/File**.
    Then choose **File** and enter **HelloWorld** as the name of the Kotlin file.
    (For other projects, you can choose any other meaningful name.) Note that including
    the file extension, .kt, is optional. At this stage, the project screen should
    look like [Figure 3-2](chapter3.xhtml#fig3-2).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击 kotlin 文件夹，选择 **New****Kotlin Class/File**。然后选择 **File** 并输入 **HelloWorld**
    作为 Kotlin 文件的名称。（对于其他项目，您可以选择任何有意义的名称。）请注意，是否包括文件扩展名 .kt 是可选的。在这个阶段，项目屏幕应该像 [图
    3-2](chapter3.xhtml#fig3-2) 一样。
- en: '![](../images/Figure3-2.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-2.jpg)'
- en: 'Figure 3-2: Creating the Kotlin file for a JavaFX application'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-2：为 JavaFX 应用程序创建 Kotlin 文件
- en: 6.  Once you’ve typed in the Kotlin filename, press ENTER to create the file,
    which also takes you to the code editor window.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦输入了 Kotlin 文件名，按下 ENTER 键以创建文件，同时这也会带您进入代码编辑窗口。
- en: With that, we’re ready to start coding our basic JavaFX application. For more
    complex projects, you may have to create additional classes or files. You can
    do so by using the same method outlined here.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里，我们已经准备好开始编写基本的 JavaFX 应用程序了。对于更复杂的项目，您可能需要创建额外的类或文件。您可以使用这里介绍的相同方法进行操作。
- en: The Code
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: The center of any JavaFX project is the Application class, an abstract class
    built into JavaFX that provides a framework for managing a graphical application.
    It features an abstract start() method that serves as the application’s entry
    point, much like the main() function is the point of entry for a console-based
    program. The project must feature a new class—what we’ll call HelloWorld, in this
    case—that extends the Application class and overrides the start() method. In the
    overridden method, you write the code for setting up and configuring the graphics
    window for data visualization and other aspects of your application. The project
    still needs a separate main() function as well, but the sole purpose of that function
    is to call the built-in launch() method of the Application class, which in turn
    launches the JavaFX application and calls the start() method.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 JavaFX 项目的核心是 Application 类，这是 JavaFX 内置的一个抽象类，它提供了管理图形应用程序的框架。它包含一个抽象的 start()
    方法，作为应用程序的入口点，就像 console 程序的 main() 函数是入口点一样。该项目必须包含一个新的类——在本例中我们称之为 HelloWorld——它继承自
    Application 类并重写 start() 方法。在重写的方法中，您将编写设置和配置图形窗口以进行数据可视化以及应用程序其他方面的代码。项目还需要一个单独的
    main() 函数，但该函数的唯一目的是调用 Application 类内置的 launch() 方法，该方法启动 JavaFX 应用程序并调用 start()
    方法。
- en: 'With that in mind, here’s the code to create a simple graphical application
    that displays a “Hello, world!” message to the user:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点后，下面是用于创建一个简单图形应用程序的代码，该程序会向用户显示“Hello, world!”信息：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We first import several JavaFX classes, including Application, Pos, Stage, Scene,
    VBox, Font, and Text. These are required to create and manage the graphical elements
    for the “Hello, world!” application. Any JavaFX application will begin with a
    long import block like this, though the specifics will vary depending on the application’s
    functionality.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入了几个JavaFX类，包括Application、Pos、Stage、Scene、VBox、Font和Text。这些是创建和管理“Hello,
    world！”应用程序的图形元素所必需的。任何JavaFX应用程序都会以这样的长导入块开始，尽管具体内容会根据应用程序的功能有所不同。
- en: 'Next, we declare the HelloWorld class to inherit from the Application class,
    which, as mentioned, is standard practice in JavaFX applications. Inside the class,
    we override the start() method ❶ to define the entry point for the application
    that will be executed when the program is launched. The start() method takes an
    argument called primaryStage, an object of the JavaFX Stage class, representing
    the application’s primary viewing window. Within the method, we do the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明HelloWorld类继承自Application类，正如前面提到的，这是JavaFX应用程序中的标准做法。在类内部，我们重写了start()方法
    ❶，以定义程序启动时执行的应用程序入口点。start()方法接受一个名为primaryStage的参数，它是JavaFX Stage类的一个对象，代表应用程序的主要视图窗口。在该方法内，我们执行以下操作：
- en: Use primaryStage.title to set the title of the application window to "Primary
    Stage".
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用primaryStage.title将应用程序窗口的标题设置为“Primary Stage”。
- en: Create a Text object named text containing the message "Hello, world!" with
    a custom font of Verdana size 20.0.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为text的Text对象，包含消息“Hello, world！”，并使用Verdana字体，大小为20.0。
- en: Create a VBox object named vbx and add the text object to it. In JavaFX, a VBox
    is a layout container that arranges its contents (in this case, text) in a vertical
    column. We set its alignment property to Pos.CENTER to ensure the text will be
    centered within the window.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为vbx的VBox对象，并将text对象添加到其中。在JavaFX中，VBox是一个布局容器，将其内容（在此案例中为文本）垂直排列。我们将其对齐属性设置为Pos.CENTER，以确保文本将在窗口中居中显示。
- en: Create a Scene object named scene with the vbx attached to it and a size of
    300.0×300.0 pixels. (The dimensions have to be given in the floating-point format
    as they’re of type Double.)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为scene的Scene对象，并将vbx附加到其上，大小为300.0×300.0像素。（由于它们是Double类型，因此必须以浮动点格式给出尺寸。）
- en: Assign the Scene object to the primaryStage parameter’s scene property, which
    adds the scene to the viewing window.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Scene对象分配给primaryStage参数的scene属性，从而将场景添加到视图窗口中。
- en: Call the show() method of the primaryStage object to display the JavaFX application
    window.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用primaryStage对象的show()方法来显示JavaFX应用程序窗口。
- en: We’ll discuss the significance of these JavaFX constructs in more detail shortly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将稍后更详细地讨论这些JavaFX构件的重要性。
- en: The final segment of the program is the main() function, which consists of just
    a single line of code ❷. As mentioned earlier, its sole purpose is to call the
    launch() method of the Application class, which activates the start() method of
    the HelloWorld application. The parameter inside the launch() method, HelloWorld::class.java,
    specifies the Java class corresponding to the HelloWorld Kotlin class that serves
    as the entry point for the JavaFX application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后一部分是main()函数，它只有一行代码 ❷。如前所述，它的唯一目的是调用Application类的launch()方法，该方法激活HelloWorld应用程序的start()方法。launch()方法中的参数HelloWorld::class.java指定了对应于HelloWorld
    Kotlin类的Java类，作为JavaFX应用程序的入口点。
- en: '#### The Result'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 结果'
- en: Try running the application in IntelliJ IDEA. The output window shown in [Figure
    3-3](chapter3.xhtml#fig3-3) should pop up.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在IntelliJ IDEA中运行该应用程序。输出窗口如图[图3-3](chapter3.xhtml#fig3-3)所示，应弹出。
- en: '![](../images/Figure3-3.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-3.jpg)'
- en: 'Figure 3-3: The minimal “Hello, world!” application in Kotlin and JavaFX'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-3：Kotlin和JavaFX中的最小“Hello, world！”应用程序
- en: Let’s highlight a few details in this output. First, the window has a title,
    “Primary Stage,” which is what the title property of primaryStage was set to.
    Second, the text “Hello, world!” is neatly centered inside the window. This was
    achieved by setting the alignment property of vbx to Pos.CENTER so that its contents
    would be aligned centrally within its boundaries. Third, the initial size of the
    window was set by specifying the width and height of the scene. However, you can
    change the window size by dragging any of its boundaries. Finally, the application
    continues to run in the background as long as the display window is open. Once
    you close the window, the application terminates normally.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来重点关注一下这个输出中的几个细节。首先，窗口有一个标题“Primary Stage”，这是 primaryStage 的标题属性所设置的内容。其次，文本“Hello,
    world!”整齐地居中显示在窗口内。这是通过设置 vbx 的对齐属性为 Pos.CENTER 来实现的，这样它的内容就会在其边界内居中对齐。第三，窗口的初始大小是通过指定场景的宽度和高度来设置的。然而，你可以通过拖动任何边界来改变窗口的大小。最后，只要显示窗口打开，应用程序就会在后台继续运行。一旦你关闭窗口，应用程序会正常终止。
- en: 'This code will be the foundational template for all our JavaFX-based applications,
    requiring only minor modifications. For example, you’ll be replacing the Text
    object with a LineChart or a Canvas object to adapt the code for creating a graph
    or a free-form drawing, respectively. JavaFX is a feature-rich framework, and
    I highly recommend exploring the resources listed at the end of this chapter to
    gain a thorough understanding of its core components and their relationships.
    For now, I’ll provide a brief overview of key features that we’ll be using in
    our upcoming JavaFX-based projects.  ### The JavaFX Object Hierarchy'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '这段代码将成为我们所有基于 JavaFX 的应用程序的基础模板，只需做少量修改。例如，你将用 LineChart 或 Canvas 对象替换 Text
    对象，以分别适应创建图表或自由形式绘图的代码。JavaFX 是一个功能丰富的框架，我强烈建议你查看本章末尾列出的资源，全面了解其核心组件及其关系。目前，我将简要概述我们即将在即将到来的
    JavaFX 项目中使用的关键特性。 ### JavaFX 对象层次结构'
- en: JavaFX uses a hierarchy of objects to represent the structure of a GUI and the
    elements that make up a visual display. At the top of this hierarchy is the Stage,
    which serves as the primary window for an application. The Stage is a container
    for one or more Scene objects, and each Scene is a container for various graphical
    elements, including other layout containers, controls, and shapes. All these components
    are considered *nodes* in the JavaFX object hierarchy.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 使用对象层次结构来表示 GUI 的结构以及构成视觉显示的元素。在这个层次结构的最上层是 Stage，它作为应用程序的主要窗口。Stage
    是一个包含一个或多个 Scene 对象的容器，每个 Scene 是包含各种图形元素的容器，包括其他布局容器、控件和形状。所有这些组件都被视为 JavaFX
    对象层次结构中的*节点*。
- en: We’ve already worked with several of these objects in our “Hello, world!” application.
    Let’s now take a closer look at what they are and how they relate to each other.
    Understanding and manipulating JavaFX’s object hierarchy is fundamental to creating
    visually appealing and interactive applications.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在“Hello, world!”应用程序中使用了这些对象中的几个。现在，让我们更仔细地看看它们是什么以及它们如何相互关联。理解和操作 JavaFX
    的对象层次结构对于创建视觉吸引力强且互动性强的应用程序至关重要。
- en: The Stage
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Stage
- en: 'The Stage is the top-level container in a JavaFX application. It represents
    the application window, complete with its title bar, borders, and any native OS-level
    components. The Stage serves as the primary object for creating a graphical window.
    You create a Stage and set its properties, such as the window title and dimensions:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Stage 是 JavaFX 应用程序中的顶级容器。它代表应用程序窗口，包含标题栏、边框以及任何本地操作系统级别的组件。Stage 作为创建图形窗口的主要对象。你可以创建一个
    Stage，并设置其属性，例如窗口标题和尺寸：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In JavaFX applications, at least one Stage object is essential. This primary
    Stage is created when you override the start() method. However, in this example,
    we’re explicitly creating an additional Stage object, which will appear as a second
    graphical window within our application. We achieve this by invoking the Stage()
    constructor and assigning it to a new class member, myStage.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaFX 应用程序中，至少需要一个 Stage 对象。这个主要的 Stage 在你重写 start() 方法时创建。然而，在这个例子中，我们显式地创建了一个额外的
    Stage 对象，它将在我们的应用程序中作为第二个图形窗口出现。我们通过调用 Stage() 构造函数并将其分配给一个新的类成员 myStage 来实现这一点。
- en: Scenes
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 场景
- en: 'A Scene represents a single, self-contained GUI component within the Stage.
    It acts as a container for all the visible elements in a specific part of an application,
    such as the main menu, a settings screen, or a game level. Typically, the root
    node of a Scene is set to a *layout container*, such as a Group, Pane, VBox, or
    HBox object, which in turn contains other nodes, such as buttons, labels, or shapes.
    Here’s an example of creating a Scene and setting its root node at the same time:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Scene表示Stage中一个单独的、独立的GUI组件。它充当特定部分应用程序中所有可见元素的容器，例如主菜单、设置界面或游戏关卡。通常，Scene的根节点设置为*布局容器*，如Group、Pane、VBox或HBox对象，这些布局容器又包含其他节点，如按钮、标签或形状。下面是一个创建Scene并同时设置其根节点的示例：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We pass root as the first arguments to the Scene constructor. This mirrors how
    we assigned a VBox as the root node of our “Hello, world!” application’s Scene
    object.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将root作为第一个参数传递给Scene构造函数。这与我们在“Hello, world!”应用程序的Scene对象中将VBox作为根节点的做法相对应。
- en: Layout Containers
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 布局容器
- en: Layout containers like Group and VBox often serve as the root or parent node
    for a Scene. They’re used to position and size other *child nodes* displayed in
    the application window. In this way, layout containers are essential for designing
    the structure and layout of a user interface in JavaFX. In upcoming projects,
    we’ll use a few of these containers, so it’s worth taking a closer look at their
    properties to see which is most appropriate for different applications. Sometimes
    more than one type can be equally suitable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 布局容器如Group和VBox通常作为Scene的根节点或父节点。它们用于定位和调整应用程序窗口中显示的其他*子节点*的大小。通过这种方式，布局容器对JavaFX用户界面的结构和布局设计至关重要。在接下来的项目中，我们将使用这些容器中的一些，因此值得仔细了解它们的属性，看看哪种最适合不同的应用程序。有时多种类型都可以同样适用。
- en: Group
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Group
- en: A Group is a container that groups other nodes together without providing any
    layout capabilities. This can be useful when you want to apply a transformation
    or effect to a set of shapes collectively. For example, you can group multiple
    shapes together and apply a rotation or scaling effect to the entire group.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Group是一种将其他节点组合在一起的容器，但不提供任何布局功能。当你希望对一组形状应用变换或效果时，这非常有用。例如，你可以将多个形状组合在一起并对整个组应用旋转或缩放效果。
- en: Pane
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Pane
- en: 'A Pane is a layout container that serves as a building block for organizing
    and positioning nodes in a user interface. It’s not specialized for a particular
    layout, which makes it a versatile choice for various UI design scenarios. JavaFX
    provides several subclasses of Pane that you can choose from based on the requirements
    of your application. These subclasses include:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Pane是一种布局容器，作为组织和定位用户界面节点的构建模块。它并不专门用于某种特定布局，这使得它成为多种UI设计场景的通用选择。JavaFX提供了多个Pane的子类，你可以根据应用程序的需求选择使用。以下是一些子类：
- en: FlowPane A container for arranging nodes in a fluid manner, automatically wrapping
    when the container’s boundaries are reached. By default, a FlowPane is horizontal,
    meaning it lays out nodes in rows, starting from the left boundary. When the right
    boundary is reached, nodes wrap (move) to the next row.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: FlowPane 一种以流动方式排列节点的容器，当容器的边界达到时会自动换行。默认情况下，FlowPane是水平的，这意味着它按行排列节点，从左边界开始。当右边界到达时，节点会换行（移动到）下一行。
- en: StackPane A container for stacking nodes on top of one another, such that one
    node blocks another. This enables creative layering of elements. All child nodes
    are automatically centered both horizontally and vertically within the available
    space.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: StackPane 一种将节点堆叠在彼此之上的容器，导致一个节点覆盖另一个节点。这使得元素可以进行创造性的层叠。所有子节点会在可用空间内自动居中显示，既水平居中也垂直居中。
- en: BorderPane A container for positioning nodes in a structured manner in the top,
    bottom, left, right, and center positions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: BorderPane 一种用于以结构化方式定位节点的容器，分为顶部、底部、左侧、右侧和中央位置。
- en: AnchorPane Similar to BorderPane, except it allows nodes to attach to the top,
    bottom, left, and right edges of the pane.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: AnchorPane 类似于BorderPane，但它允许节点附加到面板的顶部、底部、左侧和右侧边缘。
- en: GridPane A container for arranging nodes in a grid of rows and columns.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: GridPane 一种用于将节点排列成行和列网格的容器。
- en: Panes are essential components of JavaFX applications, as they provide the layout
    and structure for the user interface. By using panes, you can create flexible
    and responsive UIs that can adapt to different screen sizes and resolutions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 面板是JavaFX应用程序中的核心组件，因为它们为用户界面提供布局和结构。通过使用面板，你可以创建灵活且响应式的UI，能够适应不同的屏幕尺寸和分辨率。
- en: '##### VBox and HBox'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '##### VBox和HBox'
- en: VBox and HBox are layout containers designed to organize their child nodes neatly.
    VBox arranges its children in a vertical column, while HBox places them in a horizontal
    line.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: VBox和HBox是用于整理其子节点的布局容器。VBox将其子节点按垂直列排列，而HBox将其子节点水平排列成一行。
- en: Child Nodes
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 子节点
- en: Child nodes are the fundamental building blocks of a JavaFX application. They
    represent specific visual elements, including shapes (for example, rectangles
    or circles), images, text, and interactive controls like buttons or text fields.
    The different types of chart objects that we’ll soon create are also considered
    nodes in JavaFX. By adding, removing, and modifying nodes within the application’s
    hierarchy of objects, you can design intuitive and engaging user interfaces.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 子节点是JavaFX应用程序的基本构建块。它们代表特定的视觉元素，包括形状（例如矩形或圆形）、图像、文本以及交互控件，如按钮或文本框。我们接下来将创建的各种图表对象也被视为JavaFX中的节点。通过在应用程序的对象层次结构中添加、删除和修改节点，你可以设计出直观且富有吸引力的用户界面。
- en: 'You can add child nodes to parent nodes such as a Group, Pane, VBox, or HBox
    to create complex hierarchies of UI components. Here’s an example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将子节点添加到父节点，如Group、Pane、VBox或HBox，以创建复杂的UI组件层次结构。以下是一个示例：
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We create a blue Rectangle object that’s 100×100 pixels. We then assign the
    rectangle as a child node of a Group object called root. In this case, we assign
    the child node by passing it as an argument to the parent node’s constructor,
    but children don’t always have to be assigned immediately upon the creation of
    the parent. You can also assign a child node to a parent later by using the children.add()
    method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个大小为100×100像素的蓝色矩形对象。然后我们将该矩形作为一个名为root的Group对象的子节点。在这种情况下，我们通过将矩形作为参数传递给父节点的构造函数来分配子节点，但子节点不一定要在父节点创建时立即分配。你也可以稍后使用children.add()方法将子节点添加到父节点：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we create a Button object (button) and a Pane object (pane).
    Then we add the button as a child node of the pane by using the children.add()
    method. This method takes a single node as an argument and appends it to the list
    of children of the pane. We could also add or pass multiple children to the pane
    by using the children.addAll() method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个Button对象（button）和一个Pane对象（pane）。然后我们使用children.add()方法将按钮作为pane的子节点添加。这个方法接受一个单一的节点作为参数，并将其附加到pane的子节点列表中。我们也可以使用children.addAll()方法将多个子节点添加或传递给pane。
- en: Creating JavaFX Charts
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建JavaFX图表
- en: 'JavaFX provides a set of built-in features for creating visually appealing
    charts. You can feed a dataset into a chart for visualization and customize the
    result by changing the colors, fonts, and other properties. Here are the basic
    steps for creating a chart with JavaFX and Kotlin:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX提供了一组内置功能，用于创建视觉效果吸引人的图表。你可以将数据集输入图表进行可视化，并通过更改颜色、字体和其他属性来自定义结果。以下是使用JavaFX和Kotlin创建图表的基本步骤：
- en: '1.  Create objects to represent the x-axis and y-axis of the chart. These can
    be of two types: NumberAxis and CategoryAxis. Use the former for visualizing numerical
    data and the latter for string-type data.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 创建表示图表x轴和y轴的对象。这些对象可以是两种类型：NumberAxis和CategoryAxis。前者用于可视化数值数据，后者用于字符串类型的数据。
- en: 2.  Create an instance of a class representing the type of chart you want to
    design, such as LineChart, BarChart, ScatterChart, PieChart, or BubbleChart. You
    pass the objects created in step 1 as arguments to the chart’s constructor.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 创建一个表示你想要设计的图表类型的类的实例，例如LineChart、BarChart、ScatterChart、PieChart或BubbleChart。将步骤1中创建的对象作为参数传递给图表的构造函数。
- en: 3.  Create one or more Series objects to represent the data series you want
    to display in the chart.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 创建一个或多个Series对象来表示你想在图表中显示的数据系列。
- en: 4.  Add data points to each series by using the data.add() method for a single
    data point or the data.addAll() method for several data points at once.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 使用data.add()方法为每个数据系列添加数据点，添加单个数据点，或者使用data.addAll()方法一次性添加多个数据点。
- en: 5.  Add each series to the chart also by using the data.add() method.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 使用data.add()方法将每个数据系列添加到图表中。
- en: 6.  Create a new Scene object and add the chart to it. Although you can directly
    assign a chart object as the root of a scene, you may want to first assign the
    chart as a child of a layout container and make that container the root of the
    scene. This way, you can have better control over the result.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 创建一个新的 Scene 对象并将图表添加到其中。虽然你可以直接将图表对象作为场景的根节点，但你可能希望先将图表作为布局容器的子元素，然后将该容器设置为场景的根节点。这样，你可以更好地控制结果。
- en: 7.  Assign the Scene to the Stage object where the chart should be displayed.
    Don’t forget to display the Stage by using its show() method!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 7. 将 Scene 分配给应该显示图表的 Stage 对象。别忘了使用 show() 方法来显示 Stage！
- en: 'These steps are generic and can be used to create any of the chart types available
    in JavaFX. We’ll now look at two representative examples of creating different
    chart objects that use actual data: a bar chart and a line chart.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤是通用的，可以用来创建 JavaFX 中任何类型的图表。接下来，我们将查看两个代表性的示例，展示如何使用实际数据创建不同类型的图表对象：一个柱状图和一个折线图。
- en: 'Project 4: Visualize Data as a Bar Chart'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 4：将数据可视化为柱状图
- en: In this project, we’ll generate a bar chart to visualize the monthly sales data
    for a fictitious company named ABC & Co. over the first quarter of a year. The
    chart will feature the months of January through March along the x-axis, with
    vertical bars illustrating the sales total for each month along the y-axis. The
    code will follow the same general outline we used for the simple “Hello, world!”
    application, with modifications to implement the charting steps we discussed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将生成一个柱状图，以可视化一个名为 ABC & Co. 的虚构公司的第一季度每月销售数据。图表将在 x 轴上显示 1 月到 3 月的月份，y
    轴上则以垂直条形图表示每个月的销售总额。代码将遵循我们为简单的“Hello, world!”应用程序所使用的相同大纲，并进行修改以实现我们讨论过的绘图步骤。
- en: The Code
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: 'Here’s the code for creating a bar chart:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建柱状图的代码：
- en: '[PRE5]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We begin by importing the necessary JavaFX classes. In addition to the general
    Application, Scene, and Stage classes common to any JavaFX application, we import
    some classes specific to charting, such as Side, CategoryAxis, BarChart, NumberAxis,
    and XYChart. After the import block, we declare the BarChartExample class, which
    once again extends JavaFX’s abstract Application class. Much like the “Hello,
    world!” application, we override the start() method with a custom definition.
    This time we use the method to create a bar chart.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入必要的 JavaFX 类。除了任何 JavaFX 应用程序中常见的通用 Application、Scene 和 Stage 类外，我们还导入了一些特定于图表的类，例如
    Side、CategoryAxis、BarChart、NumberAxis 和 XYChart。在导入代码块后，我们声明了 BarChartExample
    类，它再次继承了 JavaFX 的抽象 Application 类。与“Hello, world!”应用程序类似，我们用自定义定义重写了 start() 方法。这次我们使用该方法来创建一个柱状图。
- en: The start() method is organized into several blocks. In the first block, we
    set the title of primaryStage (the Stage object passed into the start() method)
    to "Bar Chart Example" ❶. In the second block ❷, we create two objects representing
    the chart’s x- and y-axes. We use the CategoryAxis class for the x-axis, where
    the data points will be months of the year (strings), and the NumberAxis class
    for the y-axis, where the data points will be numeric sales totals. We also use
    the label property of each axis object to give the axis a descriptive label. In
    the third block ❸, we create the BarChart object, passing the xAxis and yAxis
    objects as arguments. We also assign the chart a title and position its legend
    at the top of the chart. The legend explains the significance of the colors or
    patterns used to visualize the data.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: start() 方法分为几个模块。第一模块中，我们将 primaryStage（传递给 start() 方法的 Stage 对象）的标题设置为“Bar
    Chart Example”❶。在第二模块❷中，我们创建了两个对象，分别表示图表的 x 轴和 y 轴。我们使用 CategoryAxis 类表示 x 轴，其中的数据点是年份的月份（字符串），而使用
    NumberAxis 类表示 y 轴，其中的数据点是销售总额（数字）。我们还使用每个轴对象的 label 属性为轴添加描述标签。在第三模块❸中，我们创建了
    BarChart 对象，并将 xAxis 和 yAxis 对象作为参数传递给它。我们还为图表指定了标题，并将其图例位置设置在图表的顶部。图例解释了用于可视化数据的颜色或图案的意义。
- en: 'In the fourth code block ❹, we create a series called dataSeries of type XYChart.Series.
    Each data point of this series will have a pair of elements of type <String, Number>,
    representing a month and its corresponding sales total in thousands of dollars.
    We set the name for the series; this name will appear in the chart’s legend. Then,
    to keep the start() method itself concise, we call a custom getData() function
    ❺ to add data points to the series before adding the series to the BarChart object
    to plot the data on the chart. Here’s a look at the getData() function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四个代码块 ❹ 中，我们创建了一个名为 dataSeries 的 XYChart.Series 类型的系列。该系列的每个数据点将由一对 <String,
    Number> 类型的元素组成，表示月份和对应的销售总额（单位为千美元）。我们为该系列设置名称；此名称将在图表的图例中显示。然后，为了使 start() 方法本身更加简洁，我们调用了一个自定义的
    getData() 函数 ❺，该函数将数据点添加到系列中，之后再将系列添加到 BarChart 对象中，以便在图表上绘制数据。以下是 getData() 函数的代码：
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function’s sole job is to add the data points to the dataSeries object
    in bulk by using the data.addAll() method. Each data point is an instance of the
    XYChart.Data class, which encapsulates the x- and y-axis values of a data point
    together in one container. In particular, each data point has a string month abbreviation
    for the x-value and an integer sales total for the y-value. We could also provide
    the sales totals as floating-point values; JavaFX recognizes both forms as numbers.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的唯一任务是通过使用 data.addAll() 方法将数据点批量添加到 dataSeries 对象中。每个数据点都是 XYChart.Data
    类的一个实例，该类将数据点的 x 轴和 y 轴值一起封装在一个容器中。特别地，每个数据点的 x 值是月份的简写，y 值是销售总额的整数。我们还可以将销售总额提供为浮动小数值；JavaFX
    会将这两种形式都识别为数字。
- en: The remaining part of the application class is standard JavaFX template code,
    virtually identical to that of our “Hello, world!” application. We construct a
    Scene object, assigning barChart as its root node. Then we assign the Scene object
    to primaryStage and call the latter’s show() method, which displays the bar chart
    we’ve created on the screen.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序类的其余部分是标准的 JavaFX 模板代码，几乎与我们“Hello, world!”应用程序的代码完全相同。我们构建了一个 Scene 对象，并将
    barChart 作为其根节点。然后，我们将 Scene 对象分配给 primaryStage，并调用后者的 show() 方法，这样就能在屏幕上显示我们创建的条形图。
- en: The Result
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: If you run this code, the resulting bar chart should look like [Figure 3-4](chapter3.xhtml#fig3-4).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，生成的条形图应该类似于[图 3-4](chapter3.xhtml#fig3-4)。
- en: '![](../images/Figure3-4.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-4.jpg)'
- en: 'Figure 3-4: A bar chart drawn using JavaFX'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-4：使用 JavaFX 绘制的条形图
- en: Notice how JavaFX has automatically generated a bar with the correct height
    for each data point, with the months spaced evenly along the x-axis and ticks
    labeled in increments of 25 along the y-axis, stopping just past the maximum value
    displayed in the chart. You can also verify that the chart correctly displays
    the properties we set explicitly, such as the title (“Monthly Sales”), the x-
    and y-axes labels (“Months” and “Sales in thousands of dollars”), and the legend
    (“Q1 Data for ABC & Co.”), which is positioned correctly at the top.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，JavaFX 如何自动为每个数据点生成具有正确高度的条形图，月份沿 x 轴均匀分布，y 轴按每 25 为单位标记刻度，直到超出图表中显示的最大值。你还可以验证图表是否正确显示了我们显式设置的属性，例如标题（“每月销售”）、x
    轴和 y 轴的标签（“月份”和“销售额（千美元）”）以及图例（“ABC & Co. 的 Q1 数据”），并且图例位置正确，位于顶部。
- en: 'Project 5: Create a Multiseries Line Chart'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 5：创建多系列折线图
- en: 'In this next project, we’ll create a line chart in JavaFX that displays the
    average heights of males and females at different ages. In a line chart, both
    axes are numeric, and their properties can be adjusted—for example, by setting
    the tick intervals and bounds. We’ll visualize age on the x-axis and height (in
    inches) on the y-axis. A key feature of the chart is that it will have two datasets,
    one for males and one for females, each in its own Series object. JavaFX will
    automatically plot the datasets separately, giving each a different colored line.  ####
    The Code'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '在下一个项目中，我们将使用 JavaFX 创建一个折线图，显示不同年龄段男性和女性的平均身高。在折线图中，两个轴都是数值型的，并且它们的属性可以调整——例如，可以设置刻度间隔和范围。我们将在
    x 轴上可视化年龄，在 y 轴上可视化身高（单位为英寸）。图表的一个关键特性是它将有两个数据集，一个用于男性，一个用于女性，每个数据集都有自己的 Series
    对象。JavaFX 会自动分开绘制这两个数据集，并为每个数据集分配不同的颜色线条。 #### 代码'
- en: 'Our code will follow the same structure as the code for the bar chart, with
    modifications to instead make a line chart with two series. The program can be
    easily extended to chart three or more series. Here’s the code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码将遵循与条形图相同的结构，只是修改成用两个数据系列来绘制折线图。该程序可以轻松扩展为绘制三个或更多数据系列。以下是代码：
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We begin with a typical JavaFX import block, this time importing the LineChart
    class instead of BarChart. Then we declare an application class called LineChartExample
    and override its start() method as usual. Inside the method, we first set the
    primaryStage title to "Average Heights at Different Ages", create the x- and y-axes,
    and set their labels. We use the NumberAxis class for both axes, since ages and
    heights are both numerical data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个典型的 JavaFX 导入块开始，这次导入 LineChart 类而不是 BarChart。然后，我们声明一个名为 LineChartExample
    的应用类，并像往常一样重写其 start() 方法。在该方法中，我们首先将 primaryStage 的标题设置为 "不同年龄段的平均身高"，创建 x 和
    y 坐标轴，并设置它们的标签。我们使用 NumberAxis 类为两个坐标轴提供支持，因为年龄和身高都是数值数据。
- en: 'In the next code block ❶, we further customize the axes. For both axes, we
    turn off the autoranging capability by setting the isAutoRanging property to false
    (this is necessary for the subsequent changes to take effect). Then we set the
    lower and upper bounds for the axes: ages 0.0 to 35.0 on the x-axis and heights
    20.0 to 75.0 on the y-axis. We also set a tick interval of 5.0 on the x-axis.
    We let JavaFX work out all these settings automatically for the bar chart, but
    here we exert more control to remove the unnecessary autogenerated space and better
    position the two series in the chart window. In particular, JavaFX defaults to
    a lower bound of 0.0 for any numeric axis (when x- and y-values are positive),
    which in this case would create a lot of extra space near the bottom of the chart
    since the lowest height in the dataset is 36.0.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码块❶中，我们进一步自定义坐标轴。对于两个坐标轴，我们通过将 isAutoRanging 属性设置为 false 来关闭自动范围功能（这对于后续更改生效是必要的）。然后，我们设置坐标轴的上下限：x
    轴的年龄范围为 0.0 到 35.0，y 轴的身高范围为 20.0 到 75.0。我们还在 x 轴上设置了一个 5.0 的刻度间隔。我们让 JavaFX 自动处理所有这些设置以适应柱状图，但在这里我们进行更多的控制，以去除不必要的自动生成的空间，并更好地定位两个系列在图表窗口中的位置。特别是，JavaFX
    默认对于任何数字轴（当 x 和 y 值为正数时）的下限是 0.0，这在本例中会在图表底部产生大量额外的空间，因为数据集中的最低身高是 36.0。
- en: 'The next few blocks are very similar to the bar chart example. We create a
    LineChart object ❷, set its title, and set the position of the legend. Then we
    create two XYChart.Series objects, maleData and femaleData, and call two helper
    functions, getMaleData() ❸ and getFemaleData() ❹, to populate the series with
    data. Here are the definitions of those functions:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个代码块与柱状图示例非常相似。我们创建一个 LineChart 对象❷，设置其标题，并设置图例的位置。然后我们创建两个 XYChart.Series
    对象，maleData 和 femaleData，并调用两个辅助函数，getMaleData()❸ 和 getFemaleData()❹，以便将数据填充到系列中。以下是这些函数的定义：
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Much like the bar chart project, we use the data.addAll() method to add all
    the data points to each series in one go. As before, the x- and y-values for each
    data point are packaged into an XYChart.Data object.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 和柱状图项目类似，我们使用 data.addAll() 方法一次性将所有数据点添加到每个系列中。像之前一样，每个数据点的 x 和 y 值被打包成一个 XYChart.Data
    对象。
- en: Returning to the main code, once both series (maleData and femaleData) are populated,
    we add them to the lineChart object by using the data.addAll() method ❺. Finally,
    we assign lineChart to scene and scene to primaryStage, and call the primaryStage
    object’s show() method to display the line chart, following our normal pattern
    of displaying a JavaFX visualization.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 返回主代码部分，一旦两个系列（maleData 和 femaleData）都填充完毕，我们通过使用 data.addAll() 方法❺将它们添加到 lineChart
    对象中。最后，我们将 lineChart 分配给场景，并将场景分配给 primaryStage，调用 primaryStage 对象的 show() 方法来显示折线图，按照我们常规的
    JavaFX 可视化显示模式。
- en: The Result
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: '[Figure 3-5](chapter3.xhtml#fig3-5) shows the line chart that results from
    running the code.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-5](chapter3.xhtml#fig3-5) 显示了运行代码后生成的折线图。'
- en: '![](../images/Figure3-5.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-5.jpg)'
- en: 'Figure 3-5: A multiseries line chart drawn using JavaFX'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-5：使用 JavaFX 绘制的多系列折线图
- en: The line chart displays the average heights for males and females of different
    age groups as a set of two series plotted on the same x- and y-axes. JavaFX uses
    the chart’s legend to distinguish one plot from the other. You can verify that
    the chart has been configured based on the properties we’ve set manually; for
    example, the y-axis has a lower bound of 20, and the x-axis ticks are labeled
    in increments of 5.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 折线图展示了不同年龄组男性和女性的平均身高，作为在相同的 x 和 y 轴上绘制的两个系列。JavaFX 使用图表的图例来区分两条曲线。您可以验证图表已根据我们手动设置的属性进行配置；例如，y
    轴的下限为 20，x 轴的刻度标签按 5 的增量标注。
- en: You can do a lot more customization beyond the basic settings we’ve adjusted
    in this project. I’ll leave it to you to explore other options based on your additional
    reading and experimentation with JavaFX.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在本项目中调整的基本设置外，你还可以进行更多自定义。我将把探索其他选项的任务留给你，基于你额外的阅读和对JavaFX的实验。
- en: '### Drawing with the Canvas'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用Canvas绘图'
- en: In JavaFX, a *canvas* is a region that provides a drawing surface for rendering
    custom 2D graphics. Whereas JavaFX’s charting features handle much of the drawing
    automatically, a canvas allows you to write low-level code for drawing individual
    lines, shapes, text fields, and more. You create a canvas by instantiating the
    Canvas class. Then you draw to the canvas object by accessing its *graphics context*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaFX中，*canvas*是一个区域，提供一个绘图表面，用于渲染自定义的2D图形。虽然JavaFX的图表功能自动处理了大部分绘图工作，但canvas允许你编写低级代码来绘制单独的线条、形状、文本框等。你通过实例化Canvas类来创建一个canvas。然后，通过访问其*图形上下文*，将内容绘制到canvas上。
- en: In this section, we’ll look at a simple first example of working with a JavaFX
    canvas and explore some commonly used drawing methods. Then we’ll get better acquainted
    with the canvas through a more elaborate drawing project.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一个简单的第一个JavaFX canvas使用示例，并探索一些常用的绘图方法。然后，我们将通过一个更复杂的绘图项目，更好地了解canvas。
- en: A Simple Shape
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个简单的形状
- en: 'Let’s get started with the JavaFX Canvas class by using it to draw a simple
    shape. Here’s the code for an application that draws a rectangle to the canvas:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用JavaFX Canvas类绘制一个简单的形状开始。以下是一个绘制矩形到canvas的应用程序代码：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Inside the application class’s start() method, we create an instance of the
    Canvas class with a size of 400×200 pixels and call it canvas ❶. Then we call
    the canvas object’s getGraphicsContext2D() method. It returns a reference to the
    canvas’s GraphicsContext object, which we store in the gc variable ❷. This object
    provides the interface for drawing to the canvas. We then follow the usual steps
    of assigning the canvas to a layout container (a Pane object), the container to
    a scene, and the scene to the primary stage, which we display with the show()
    method. We need the Pane since Canvas isn’t a parent-type node and thus can’t
    be passed directly to a scene. Also, by making the Canvas object a child node
    to a container such as a Pane or VBox, we can further customize its placement
    and size if needed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序类的start()方法中，我们创建了一个Canvas类的实例，大小为400×200像素，并命名为canvas ❶。接着，我们调用canvas对象的getGraphicsContext2D()方法，它返回一个指向canvas的GraphicsContext对象的引用，我们将其存储在gc变量中
    ❷。这个对象提供了在canvas上绘图的接口。然后，我们按照常规步骤，将canvas分配给布局容器（一个Pane对象），再将容器分配给场景，最后将场景分配给主舞台，并通过show()方法显示它。我们需要Pane，因为Canvas不是父类型节点，因此不能直接传递给场景。另外，通过将Canvas对象作为Pane或VBox等容器的子节点，我们可以在需要时进一步自定义其位置和大小。
- en: To draw the rectangle, we call a custom drawRectangle() method ❸ that takes
    one argument, the graphics context. In the method’s definition, we use Kotlin’s
    with scope function to group the actions requiring access to the graphics content,
    gc ❹. This saves us from adding gc. to the start of each line of code, which is
    a big help in longer drawing methods. We set the stroke color of the graphics
    context to red (in computer graphics, a *stroke* is the outline of a geometric
    shape), then call JavaFX’s strokeRect() method to draw a rectangle. The first
    two arguments (100.0 and 50.0) set the x- and y-coordinates of the rectangle’s
    top-left corner, and the remaining arguments (200.0 and 100.0) define its width
    and height (in pixels). By default, the origin of the coordinate system (0.0,
    0.0) is positioned at the top-left corner of the canvas.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绘制矩形，我们调用一个自定义的drawRectangle()方法 ❸，该方法接受一个参数，即图形上下文。在方法的定义中，我们使用Kotlin的with作用域函数来组合需要访问图形内容的操作，gc
    ❹。这避免了在每行代码前加上gc.，在较长的绘图方法中，这非常有帮助。我们将图形上下文的描边颜色设置为红色（在计算机图形学中，*描边*是几何形状的轮廓），然后调用JavaFX的strokeRect()方法绘制一个矩形。前两个参数（100.0和50.0）设置矩形左上角的x和y坐标，剩余的参数（200.0和100.0）定义其宽度和高度（单位为像素）。默认情况下，坐标系统的原点（0.0，0.0）位于canvas的左上角。
- en: '[Figure 3-6](chapter3.xhtml#fig3-6) shows the result of running this simple
    canvas application.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-6](chapter3.xhtml#fig3-6)展示了运行此简单canvas应用程序的结果。'
- en: '![](../images/Figure3-6.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-6.jpg)'
- en: 'Figure 3-6: A red-outlined rectangle (shown here in gray) on a canvas'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-6：canvas上的红色轮廓矩形（此处显示为灰色）
- en: In this example, we’ve defined the drawRectangle() method within the CanvasExample_1
    class. Alternatively, we could have created it as an independent function, similar
    to the getData() functions in the bar chart and line chart examples. Both approaches
    are valid. When a function is generic and could be reused by other classes or
    modules, consider making it a stand-alone function. Otherwise, creating it as
    an internal method of a class enhances data encapsulation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在 CanvasExample_1 类中定义了 drawRectangle() 方法。或者，我们也可以将它作为独立的函数创建，类似于条形图和折线图示例中的
    getData() 函数。两种方法都是有效的。当一个函数是通用的，并且可以被其他类或模块复用时，考虑将其作为独立函数。否则，将其作为类的内部方法有助于数据封装。
- en: Common Graphics Context Methods
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 常用图形上下文方法
- en: The graphics context is an essential tool associated with any canvas that enables
    you to design 2D graphics in JavaFX. Before moving on to more advanced projects
    involving the canvas, let’s consider some of the key features and capabilities
    of the GraphicsContext class and how to apply them in Kotlin. The most commonly
    used features are listed in [Table 3-1](chapter3.xhtml#tab3-1) for ease of reference.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图形上下文是与任何画布相关联的一个重要工具，它使你能够在 JavaFX 中设计 2D 图形。在开始更高级的涉及画布的项目之前，让我们先考虑一下 GraphicsContext
    类的一些关键功能和能力，以及如何在 Kotlin 中应用它们。为了方便参考，最常用的功能列在 [表 3-1](chapter3.xhtml#tab3-1)
    中。
- en: 'Table 3-1: Commonly Used Graphics Context Methods'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1：常用图形上下文方法
- en: '| Feature | Description | Usage in Kotlin |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | 描述 | Kotlin 中的用法 |'
- en: '| --- | --- | --- |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Drawing shapes | Draw various 2D shapes, such as lines, rectangles, circles,
    and polygons. | gc.strokeRect(x, y, width, height) gc.fillOval(x, y, radiusX,
    radiusY) gc.fillPolygon(x-array, y-array, n) |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 绘制图形 | 绘制各种 2D 图形，如线条、矩形、圆形和多边形。 | gc.strokeRect(x, y, width, height) gc.fillOval(x,
    y, radiusX, radiusY) gc.fillPolygon(x-array, y-array, n) |'
- en: '| Setting colors | Set stroke (outline) and fill colors for shapes. | gc.stroke
    = Color.RED gc.fill = Color.BLUE |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 设置颜色 | 设置形状的描边（轮廓）和填充颜色。 | gc.stroke = Color.RED gc.fill = Color.BLUE |'
- en: '| Line width | Set line width and line style. | gc.lineWidth = 2.0 gc.setLineDashes(dash,
    gap) |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 线条宽度 | 设置线条宽度和线条样式。 | gc.lineWidth = 2.0 gc.setLineDashes(dash, gap) |'
- en: '| Text rendering | Draw text on the canvas with specified fonts and sizes.
    | gc.font = Font("Arial", 14.0) gc.fillText("Hello, world!", x, y) |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 文本渲染 | 用指定的字体和大小在画布上绘制文本。 | gc.font = Font("Arial", 14.0) gc.fillText("Hello,
    world!", x, y) |'
- en: '| Image rendering | Draw images on the canvas. | val image = Image("image.png")
    gc.drawImage(image, x, y) |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 图像渲染 | 在画布上绘制图像。 | val image = Image("image.png") gc.drawImage(image, x,
    y) |'
- en: '| Transformations | Translate (move the origin of the coordinate system by
    the specified x- and y-values) and rotate (rotate the subsequent drawings by a
    specified angle). | gc.translate(x, y) gc.rotate(angle) |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 变换 | 平移（通过指定的 x 和 y 值移动坐标系统的原点）和旋转（通过指定角度旋转后续的绘图）。 | gc.translate(x, y) gc.rotate(angle)
    |'
- en: '| Clearing canvas | Clear the entire canvas or a specific region. | gc.clearRect(0.0,
    0.0, canvas.width, canvas.height) gc.clearRect(x, y, width, height) |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 清空画布 | 清空整个画布或特定区域。 | gc.clearRect(0.0, 0.0, canvas.width, canvas.height)
    gc.clearRect(x, y, width, height) |'
- en: '[Table 3-1](chapter3.xhtml#tab3-1) shows the rich set of capabilities that
    the graphics context provides. For example, we can draw and fill geometric shapes
    such as rectangles and ovals with different colors. We can also adjust the width
    and style of a line. We have many options for rendering text as well. Besides
    shapes, we can use images of various formats (for example, JPG, PNG, or GIF) and
    creatively place them on the canvas. Moreover, we can move the origin of the coordinate
    system and rotate objects drawn on the canvas, altering their orientation relative
    to the current coordinate system. And finally, we can wipe the entire canvas clean,
    providing a fresh starting point for dynamic simulations.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-1](chapter3.xhtml#tab3-1) 显示了图形上下文提供的丰富功能。例如，我们可以用不同的颜色绘制和填充几何图形，如矩形和椭圆。我们还可以调整线条的宽度和样式。对于文本的渲染，我们也有许多选择。除了图形，我们还可以使用各种格式的图像（例如
    JPG、PNG 或 GIF），并将它们创意性地放置在画布上。此外，我们可以移动坐标系统的原点，并旋转画布上的对象，改变它们相对于当前坐标系统的方向。最后，我们可以清空整个画布，为动态仿真提供一个全新的起点。'
- en: In the projects to follow in this chapter and elsewhere in the book, we’ll use
    many of these features and see how they work in more detail.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章接下来的项目以及本书的其他地方，我们将使用这些功能，并更详细地了解它们是如何工作的。
- en: 'Project 6: Draw a Spiral Seashell'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 6：绘制螺旋贝壳
- en: In this project, we’ll dive deeper into the drawing capabilities of the JavaFX
    canvas and its 2D graphics context. We’ll create a complex figure with many circles
    of increasing sizes, arranged in a spiral around the center of the canvas. By
    changing the key parameters, we can produce various visual effects. Here we’ll
    use the parameters to make a figure that resembles a seashell with a spiral growth
    pattern.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将深入探讨 JavaFX 画布的绘图功能及其 2D 图形上下文。我们将创建一个复杂的图形，包含多个逐渐增大的圆圈，围绕画布中心按螺旋形排列。通过改变关键参数，我们可以产生不同的视觉效果。在这里，我们将利用这些参数绘制一个类似海螺的图形，其具有螺旋生长的模式。
- en: The Strategy
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 策略
- en: 'Before diving into the code, let’s strategize the approach required to generate
    a spiral pattern. A spiral resembles a circle, with one important difference:
    its leading edge never returns to the origin point. Instead, it continuously moves
    farther away from the center while encircling the initial starting point. To achieve
    this mathematically, we’ll employ a method involving a sequence of lines, as illustrated
    in [Figure 3-7](chapter3.xhtml#fig3-7).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解代码之前，我们先来规划生成螺旋图案的策略。螺旋看起来像一个圆，但有一个重要区别：它的前端永远不会返回到原点。相反，它会不断远离中心，同时围绕初始起点旋转。为了在数学上实现这一点，我们将采用一个由一系列直线构成的方法，如[图
    3-7](chapter3.xhtml#fig3-7)所示。
- en: '![](../images/Figure3-7.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-7.jpg)'
- en: 'Figure 3-7: The strategy for making a spiral pattern'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-7：制作螺旋图案的策略
- en: 'Each line has one end anchored at a specific point F, which we’ll set to the
    center of the canvas. The position of the other end of the line, C, is determined
    by two key factors: the length *r* of the line and an angle of rotation *θ* relative
    to the positive x-axis (or another fixed reference). Given the values of *r* and
    *θ*, we can use some basic trigonometry to calculate the coordinates of point
    C. By gradually increasing both the angle of rotation and the length of the line
    by preset amounts, the successive values of C will form a spiral as the points
    simultaneously circle around the fixed point F and grow more distant from it.
    We’ll repeat this until the spiral has achieved the desired number of turns (one
    turn equals 360 degrees).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 每条线的一端固定在一个特定点 F，我们将其设置为画布的中心。另一端的位置 C 由两个关键因素决定：线段的长度 *r* 和相对于正 x 轴的旋转角度 *θ*（或其他固定参考）。给定
    *r* 和 *θ* 的值后，我们可以利用基础的三角学来计算点 C 的坐标。通过逐渐增加旋转角度和线段长度，C 的连续值将形成一个螺旋图案，同时这些点既围绕着固定点
    F 转动，又越来越远离它。我们将重复这一过程，直到螺旋完成所需的圈数（一圈等于 360 度）。
- en: To create the spiral pattern, we’ll treat each point C as the center of a circle
    with a radius of length *r*. These circles will grow larger and move farther away
    from the starting point as we repeat the process.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建螺旋图案，我们将每个点 C 视为一个半径为 *r* 的圆的圆心。这些圆会逐渐变大，并随着我们不断重复过程，离起始点越来越远。
- en: The Code
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: 'Here’s the general structure of the code that will be used to draw the seashell
    spiral:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是用于绘制海螺螺旋的代码的一般结构：
- en: '[PRE10]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We begin by importing the required graphics-related classes, as well as the
    cos() and sin() trigonometric functions from Kotlin’s math library. Then we declare
    the MultiTurnSpiral application class. Much like the rectangle example, we first
    create and set the graphics elements, then call a custom method, in this case
    drawMultiTurnSpiral(), to coordinate the actual drawing. This approach keeps the
    overridden start() method concise. Notice that we’ve condensed the creation of
    the necessary JavaFX nodes by setting the scene property of the primaryStage object
    to Scene(Pane(canvas)) ❶. Nested assignments like this can help eliminate a few
    lines of code when the intermediate objects aren’t needed for other purposes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入所需的图形相关类，以及 Kotlin 数学库中的 cos() 和 sin() 三角函数。然后，我们声明 MultiTurnSpiral 应用类。与矩形示例类似，我们首先创建并设置图形元素，然后调用一个自定义方法——在这里是
    drawMultiTurnSpiral()——来协调实际的绘制过程。这种方式使得重写的 start() 方法更加简洁。注意，我们通过将 primaryStage
    对象的 scene 属性设置为 Scene(Pane(canvas)) ❶ 来简化 JavaFX 节点的创建。像这样的嵌套赋值可以帮助我们减少几行代码，特别是在中间对象不需要用于其他目的时。
- en: Beyond the start() method, the application class contains three methods that
    collectively define and render the spiral pattern. Among them, drawMultiTurnSpiral()
    is the primary method, while the other two, printParams() and drawCircle(), are
    helpers. We’ll look at each of these methods in detail, starting with drawMultiTurnSpiral().
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 除了start()方法，应用程序类还包含三个方法，这些方法共同定义并渲染螺旋图案。它们中，drawMultiTurnSpiral()是主要方法，而其他两个方法printParams()和drawCircle()是辅助方法。我们将详细查看这些方法，首先从drawMultiTurnSpiral()开始。
- en: '[PRE11]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The drawMultiTurnSpiral() method takes three parameters: gc, width, and height,
    which are the graphics context and the width and height of the canvas, respectively.
    We first set some key parameters for the spiral ❶. The numCircles variable sets
    the number of circles we’ll draw and turns dictates the number of rotations we’ll
    make around the center of the spiral. Multiplying turns by 360 gives us the maximum
    angle of rotation we’ll achieve, and dividing that value by numCircles gives us
    rotationStep, the amount we’ll rotate between drawing each circle. Similarly,
    we set maxRadius, the radius of the largest circle, to one-tenth the width or
    height of the canvas (whichever is lower), then divide this by numCircles and
    multiply the result by spacingFactor to get radiusStep, the amount by which the
    radius will grow from one circle to the next. Dividing the minimum of the width
    and height by 10 gives us some space to play with, and varying the spacingFactor
    allows us to better utilize that space by adjusting the distance between the circles.
    I’ve used a spacingFactor of 2 to create a visually pleasing pattern, but feel
    free to experiment with the values to understand how they affect the final figure.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: drawMultiTurnSpiral()方法接受三个参数：gc、width和height，分别表示图形上下文以及画布的宽度和高度。我们首先设置一些螺旋的关键参数❶。numCircles变量设置了我们将绘制的圆圈数，而turns决定了我们围绕螺旋中心旋转的圈数。将turns乘以360得出我们将达到的最大旋转角度，再将该值除以numCircles得出rotationStep，即每绘制一个圆圈时的旋转量。类似地，我们将maxRadius（最大圆圈的半径）设置为画布宽度或高度的十分之一（取较小者），然后将其除以numCircles，再将结果乘以spacingFactor得到radiusStep，即每个圆圈半径之间的增长量。将宽度和高度的较小值除以10可以为我们提供一些空间，调整spacingFactor可以通过调整圆圈之间的距离来更好地利用这些空间。我使用了spacingFactor为2来创建一个视觉上令人愉悦的图案，但你可以自由尝试不同的值，了解它们如何影响最终的图形。
- en: With these parameters set, we call the printParams() method ❷, which prints
    some key parameter values to the canvas. (We’ll look at this method shortly.)
    Then we use a for loop ❸ to iterate over the desired number of circles and draw
    them on the canvas. For each circle, we multiply looping variable i by rotationStep
    to calculate the current angle of rotation relative to the positive x-direction,
    and we multiply i by radiusStep to get the circle’s radius. We then calculate
    the coordinates of the circle’s center (x, y) by using trigonometric functions,
    taking the center of the canvas as the fixed point at the center of the spiral.
    (See [Figure 3-7](chapter3.xhtml#fig3-7) for how these calculations are derived.)
    Note that the cos() and sin() functions expect angles measured in radians rather
    than degrees, so we call toRadians() on the angle. Finally, we pass along the
    circle’s parameters to the custom drawCircle() method to actually draw the circle,
    including its center ❹.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好这些参数后，我们调用printParams()方法❷，它将一些关键的参数值打印到画布上。（稍后我们将详细介绍这个方法。）接着，我们使用for循环❸遍历所需的圆圈数量，并将它们绘制到画布上。对于每个圆圈，我们将循环变量i乘以rotationStep来计算相对于正x轴的当前旋转角度，再将i乘以radiusStep来获取圆圈的半径。然后，我们使用三角函数计算圆心的坐标（x，y），将画布中心作为螺旋中心的固定点。（有关这些计算的推导，请参见[图
    3-7](chapter3.xhtml#fig3-7)。）注意，cos()和sin()函数期望的是弧度而非角度，因此我们在角度上调用toRadians()。最后，我们将圆圈的参数传递给自定义的drawCircle()方法以实际绘制圆圈，包括其圆心❹。
- en: 'Now let’s look at the definitions of the two helper methods, printParams()
    and drawCircle():'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下两个辅助方法的定义，printParams()和drawCircle()：
- en: '[PRE12]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The printParams() method takes in the graphics context and two key parameters
    of the spiral: the radius step and the number of circles. We create two string
    templates by using these parameters in the msg1 and msg2 variables. In msg1, we
    format radiusStep, a floating-point number, to four decimal places. In msg2, the
    number of circles, numCircles, is an integer, so no formatting is needed. We then
    pass the messages along to the gc.fillText() method, which displays the text at
    a specified location on the canvas (we’re using coordinates near the bottom-left
    corner). This method offers a valuable alternative to using the println() function,
    which is limited to displaying text in the console. With fillText(), we have the
    capability to print text directly on the canvas, enhancing the visual representation
    of the program’s output.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: printParams()方法接受图形上下文和螺旋的两个关键参数：半径步长和圆圈的数量。我们使用这些参数在msg1和msg2变量中创建两个字符串模板。在msg1中，我们将半径步长radiusStep（一个浮动的小数）格式化为四位小数。在msg2中，圆圈的数量numCircles是整数，因此不需要格式化。然后，我们将消息传递给gc.fillText()方法，该方法会在画布的指定位置显示文本（我们使用的是接近左下角的坐标）。这个方法为println()函数提供了一个有价值的替代方案，因为println()只能在控制台显示文本。通过fillText()，我们可以直接在画布上打印文本，增强程序输出的视觉表现。
- en: 'The drawCircle() method draws an individual circle in the spiral in two ways:
    as a light blue outline of the full circle and as a smaller red dot to mark the
    center of the circle. The method takes in the graphics context, the x- and y-coordinates
    of the circle’s center, and the circle’s radius. There’s a catch, however: the
    canvas’s methods for drawing a circle, fillOval() and strokeOval(), position the
    circle not from its center but from the top-left corner of a rectangle that surrounds
    the circle. We therefore subtract the radius from x and y to get the coordinates
    for the top-left corner ❶. We also set pointSize, which defines the diameter of
    the small, filled circle marking the circle’s center.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: drawCircle()方法以两种方式绘制螺旋中的单个圆：作为一个浅蓝色的圆轮廓和作为一个较小的红点来标记圆心。该方法接受图形上下文、圆心的x和y坐标以及圆的半径。然而，有一个问题：画布的圆形绘制方法fillOval()和strokeOval()并不是从圆心开始定位圆，而是从包围圆的矩形的左上角开始。因此，我们从x和y中减去半径来得到左上角的坐标
    ❶。我们还设置了pointSize，它定义了标记圆心的小填充圆的直径。
- en: For the rest of the method, we use the scoping function with to access the properties
    and methods of the graphics context more easily. We set the line width and stroke
    color for the outlined circle and the fill color for the central circle. Then
    we draw the small central circle by using fillOval() ❷ and the larger outlined
    circle by using strokeOval() ❸. The first two arguments are the coordinates of
    the bounding rectangle’s top-left corner, and the remaining two are the desired
    width and height (which for a circle are both twice the radius).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法的其余部分，我们使用作用域函数以更方便地访问图形上下文的属性和方法。我们为轮廓圆设置线条宽度和描边颜色，并为中央圆设置填充颜色。然后，我们使用fillOval()
    ❷绘制小的中央圆，使用strokeOval() ❸绘制较大的轮廓圆。前两个参数是包围矩形左上角的坐标，后两个参数是期望的宽度和高度（对于圆形来说，宽度和高度都是半径的两倍）。
- en: '#### The Result'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 结果'
- en: We’re now ready to run the code. It should produce the output shown in [Figure
    3-8](chapter3.xhtml#fig3-8).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行代码了。它应该会生成如[图 3-8](chapter3.xhtml#fig3-8)所示的输出。
- en: '![](../images/Figure3-8.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-8.jpg)'
- en: 'Figure 3-8: A two-turn spiral created with circles of increasing radii'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-8：通过不断增大的圆半径绘制的两圈螺旋
- en: 'Take a few moments to appreciate the spiral’s visual intricacy. By plotting
    the centers of the circles with a contrasting color, we can clearly see how the
    successive circles get bigger and farther away from the center of the canvas (recall
    that the radius was a linear function of radiusStep). Ignoring the trajectory
    of the central dots for a moment, the circles create a visual illusion of a spiral
    seashell. This is no coincidence: some real-life seashells grow in spirals based
    on precise mathematical rules.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间欣赏螺旋的视觉复杂性。通过用对比色绘制圆心，我们可以清楚地看到后续的圆圈是如何变大并远离画布中心的（回想一下，半径是半径步长的线性函数）。暂时忽略中央点的轨迹，圆圈形成了一个螺旋海贝的视觉错觉。这并非巧合：一些现实中的海贝也会根据精确的数学规则以螺旋形生长。
- en: Animation in JavaFX
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaFX中的动画
- en: 'Animation is a powerful tool for creating engaging and interactive applications.
    JavaFX offers various animation options, from simple transitions to complex sequences.
    You can animate onscreen objects in JavaFX in two main ways: by using the TranslateTransition
    class or by using the Timeline and KeyFrame classes. In the following projects,
    we’ll explore both of these methods through hands-on examples.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 动画是创建引人入胜和互动应用程序的强大工具。JavaFX提供了多种动画选项，从简单的过渡到复杂的序列。在JavaFX中，您可以通过两种主要方式对屏幕上的物体进行动画处理：使用TranslateTransition类或使用Timeline和KeyFrame类。在接下来的项目中，我们将通过实际示例探索这两种方法。
- en: 'Project 7: Animate a Square'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 项目7：动画化正方形
- en: Transition-based animation treats animation as a gradual shift from one state
    to another. You define the start and end states of a visual object, and JavaFX
    works out a way to smoothly transition between the two. With transitions, you
    can make objects move, rotate, scale, fade, and so on, creating simple effects
    such as sliding, bouncing, flipping, and fading in or out. Transitions are easy
    to use and require minimal coding, but they’re more limited than the timeline
    and keyframe approach we’ll consider in the next project.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 基于过渡的动画将动画视为从一个状态到另一个状态的渐变。您定义一个视觉对象的起始状态和结束状态，然后JavaFX会计算出平滑过渡的方式。通过过渡，您可以让物体移动、旋转、缩放、淡入淡出等，创建简单的效果，如滑动、弹跳、翻转和淡入或淡出。过渡效果易于使用且需要的代码量较少，但它们比我们将在下一个项目中考虑的时间轴和关键帧方法更有限。
- en: To use a transition, you need to create an instance of a transition class, such
    as TranslateTransition to move an object or RotateTransition to make it spin.
    You pass the node you want to animate as an argument to the transition’s constructor.
    Then you set transition properties such as the duration, cycle count, and autoreverse.
    Finally, you call the transition object’s play() method to start the animation.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用过渡效果，您需要创建一个过渡类的实例，例如TranslateTransition（移动物体）或RotateTransition（让物体旋转）。您将要动画化的节点作为参数传递给过渡的构造函数。然后，您设置过渡的属性，如持续时间、循环次数和自动反转。最后，您调用过渡对象的play()方法来启动动画。
- en: The Code
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: 'Here’s a simple example that uses transitions to move a square back and forth
    from one side of the screen to the other:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例，使用过渡效果将正方形从屏幕的一侧移动到另一侧：
- en: '[PRE13]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We begin with the import block, which is now organized into imports related
    to graphics and imports related to animation. The application class, TransitionExample,
    has the same familiar structure we’ve seen throughout the chapter. I’ll highlight
    only the problem-specific parts.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从导入块开始，现在它已经按与图形相关的导入和与动画相关的导入进行组织。应用程序类TransitionExample具有我们在本章中看到的相同结构。我只会强调与问题相关的部分。
- en: To animate a square, we first create one by using the Rectangle class ❶. We
    set the side lengths of the square to 50 pixels and its color to red. By default,
    the square would be positioned at the top-left corner of the window, but we update
    the square’s y property to put it 100 pixels lower. We create a Pane layout, place
    the square inside it, and set it as the root node for a 300×300-pixel scene ❷.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了动画化一个正方形，我们首先通过使用Rectangle类创建一个正方形❶。我们将正方形的边长设置为50像素，并将颜色设置为红色。默认情况下，正方形会位于窗口的左上角，但我们更新正方形的y属性，将其向下移动100像素。我们创建一个Pane布局，将正方形放置其中，并将其设置为一个300×300像素场景的根节点❷。
- en: To set the transitions, we create an instance of the TranslateTransition class
    named transition ❸. In the constructor, we set the duration of the animation to
    two seconds and assign the square object as the node to be animated. We then use
    with (transition) to set the properties controlling the movements of the square.
    We specify the starting x-position for animation by using the fromX property (we’ll
    move the square only from side to side) and the end position by using the toX
    property. For the latter, we use pane .width - square.width to ensure the square
    won’t move outside the scene’s boundaries. The transition will interpolate the
    value of the x-position of the square from the fromX value to the toX value over
    the duration of the animation. Since we set cycleCount to Transition.INDEFINITE
    and isAutoReverse to true, the transition will reverse direction when it ends
    and start interpolating back to the fromX value—it will continue repeating as
    long as the window remains open. Finally, we set the transition in motion by using
    its play() method ❹.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置过渡，我们创建了一个名为 transition ❸ 的 TranslateTransition 类的实例。在构造函数中，我们将动画的持续时间设置为两秒，并将方块对象指定为要动画化的节点。然后我们使用
    with (transition) 来设置控制方块移动的属性。通过使用 fromX 属性来指定动画的起始 x 位置（我们只会让方块在水平方向上移动），并通过使用
    toX 属性来指定结束位置。对于后者，我们使用 pane.width - square.width 来确保方块不会移出场景的边界。该过渡将在动画的持续时间内将方块的
    x 位置从 fromX 值插值到 toX 值。由于我们将 cycleCount 设置为 Transition.INDEFINITE，并将 isAutoReverse
    设置为 true，过渡将在结束时反转方向，并开始插值回 fromX 值—只要窗口保持打开，动画就会继续重复。最后，我们通过使用它的 play() 方法 ❹
    启动过渡动画。
- en: The Result
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: When you run this code, you should see a red square initially positioned next
    to the left boundary of the scene. It should start moving toward the right boundary,
    then reverse its course once it hits the right boundary. This back-and-forth movement
    should continue until you close the window to terminate the program.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你应该会看到一个红色的方块，最初位置在场景的左边界旁边。它应该开始向右边界移动，然后在撞到右边界后反转方向。这个来回运动会一直持续，直到你关闭窗口终止程序。
- en: 'Project 8: Animate a Bouncing Ball'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 8：动画弹跳球
- en: The timeline and keyframe approach to animation offers exceptional versatility
    and is ideal for creating complex and precisely controlled animations. Each KeyFrame
    object defines a specific point in time where you set the values of certain properties,
    while the Timeline class manages the progression between keyframes. In JavaFX,
    you can find two approaches to this animation method. One is to define the properties
    of each KeyFrame object explicitly. The other is to set the properties of each
    KeyFrame programmatically by using an *action event handler*, a block of code
    similar to a lambda expression. This block of code is called periodically and
    contains rules for updating the scene. In this project, we’ll look at examples
    of both methods.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 时间线和关键帧的动画方法提供了极高的灵活性，特别适合创建复杂且精确控制的动画。每个 KeyFrame 对象定义了一个特定的时间点，在该时间点你设置某些属性的值，而
    Timeline 类则管理关键帧之间的进展。在 JavaFX 中，你可以使用两种方法来实现此动画。其一是明确地定义每个 KeyFrame 对象的属性，另一种是通过使用
    *事件处理器* 编程地设置每个 KeyFrame 的属性，事件处理器类似于 lambda 表达式的代码块。这个代码块会周期性地调用，并包含更新场景的规则。在本项目中，我们将查看这两种方法的示例。
- en: Setting Keyframes Explicitly
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显式设置关键帧
- en: 'In the first example, we’ll create an animated circle that grows and shrinks
    continuously. We’ll explicitly define the starting and ending KeyFrame objects,
    representing the circle at its smallest and largest sizes. Then we’ll use the
    Timeline class to interpolate back and forth between the keyframes. Here’s the
    code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们将创建一个动画圆圈，它会持续不断地增长和缩小。我们将明确地定义起始和结束的 KeyFrame 对象，表示圆圈在最小和最大尺寸时的状态。然后，我们将使用
    Timeline 类在关键帧之间来回插值。以下是代码：
- en: '[PRE14]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We create a blue Circle object with an initial radius of 50.0 pixels ❶ and
    attach it to a StackPane ❷, which automatically centers the node it contains.
    We manage the animation through a Timeline and two KeyFrame objects: startFrame
    and endFrame. For startFrame, we set the initial state of the circle’s radius
    property to 50.0 pixels at the start time of the animation (0 seconds). Notice
    how we set the radius through an instance of the KeyValue class, which we pass
    to the KeyFrame constructor. Any property of an object that should be animated
    between keyframes must be defined through a separate KeyValue object. The second
    keyframe, endFrame, sets the circle’s radius property to 250.0 pixels at the end
    time (five seconds) of the animation. We use the keyFrames.addAll() method to
    attach the two keyframes to the Timeline object ❸.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个初始半径为50.0像素的蓝色Circle对象❶，并将其附加到一个StackPane❷上，StackPane会自动将其中包含的节点居中。我们通过一个Timeline和两个KeyFrame对象来管理动画：startFrame和endFrame。在startFrame中，我们将圆形的半径属性的初始状态设置为50.0像素，动画的开始时间为0秒。注意我们如何通过KeyValue类的实例来设置半径，并将其传递给KeyFrame构造函数。任何需要在关键帧之间进行动画的对象属性必须通过单独的KeyValue对象定义。第二个关键帧endFrame将在动画结束时间（5秒）时将圆形的半径属性设置为250.0像素。我们通过keyFrames.addAll()方法将这两个关键帧附加到Timeline对象❸。
- en: In the final code block, inside the with scoping function, we configure the
    animation to keep repeating by setting the Timeline object’s cycleCount property
    to Timeline.INDEFINITE, and we turn on autoreversing so that the circle will start
    shrinking once it’s grown to its maximum size. Then we initiate the animation
    by invoking the play() method ❹.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的代码块中，在with作用域函数内，我们通过将Timeline对象的cycleCount属性设置为Timeline.INDEFINITE，配置动画保持重复播放，并开启自动反向功能，使得圆形在达到最大尺寸后会开始缩小。然后，我们通过调用play()方法❹来启动动画。
- en: If you run this code, an application window should open up where you’ll see
    a blue circle repeatedly grow and shrink, with each cycle lasting five seconds.
    The animation should continue indefinitely until you close the application window.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，应该会弹出一个应用窗口，在那里你会看到一个蓝色圆形反复地变大和变小，每个循环持续五秒钟。动画将继续无限循环，直到你关闭应用窗口。
- en: Using an Action Event Listener
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用动作事件监听器
- en: We’ll now explore a second example of creating animations with a timeline and
    keyframes. Unlike the previous example, where we specified distinct starting and
    ending keyframes for each animation cycle, we’ll rely on an action event listener
    block to execute the animation code. Specifically, we’ll create a red ball that
    continually traverses the scene, bouncing off the window boundaries. We’ll use
    the action event listener to set general rules for how the ball should move and
    when it should bounce. We’ll also encapsulate all the animation-related code within
    a dedicated method instead of putting it all in start(). This is a more structured
    and efficient coding method, which is particularly useful if we want to animate
    multiple balls by using the same method.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探索第二个使用时间线和关键帧创建动画的示例。与之前的例子不同，在那个例子中我们为每个动画周期指定了不同的起始和结束关键帧，而在这个示例中，我们将依靠一个动作事件监听器块来执行动画代码。具体来说，我们将创建一个红色的小球，它不断地穿越场景并碰撞到窗口的边界。我们将使用动作事件监听器来设置球的移动规则以及何时反弹。我们还会将所有与动画相关的代码封装在一个专用方法中，而不是将它们全部放在start()方法中。这是一种更加结构化和高效的编码方式，尤其当我们希望使用相同的方法为多个小球制作动画时，这种方式特别有用。
- en: 'Here’s the code for animating a bouncing red ball:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是用于动画跳动红球的代码：
- en: '[PRE15]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Inside the start() method of the BouncingBall application class, we first instantiate
    a red ball (redBall) with a radius of 30 pixels, positioning it at coordinates
    (250, 200) relative to the top-left corner (0, 0) of the scene ❶. To prevent the
    ball from constantly occupying the center of the scene, we assign it to a Pane
    instead of a StackPane. The rest of the code up to calling the show() method of
    primaryStage is practically the same as in the previous example.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在BouncingBall应用类的start()方法中，我们首先实例化一个半径为30像素的红色小球（redBall），并将其定位在相对于场景左上角(0,
    0)的坐标(250, 200)处❶。为了防止小球一直占据场景的中心，我们将它分配给一个Pane，而不是StackPane。接下来，直到调用primaryStage的show()方法，代码几乎与前面的示例相同。
- en: Once we’re done with setting the graphics part of the application, we call the
    custom bouncyBall() method, passing redBall and scene as its arguments ❷. This
    method encapsulates the process of setting up the Timeline and KeyFrame objects
    and maneuvering the ball inside the scene. Inside the method, we first define
    two displacement parameters, dx and dy, which set the horizontal and vertical
    distance (in pixels) that the red ball should travel in each animation frame.
    We initialize these values to 2, but if you modify them, the speed of the ball
    will change. For example, using 4 would double the ball’s speed, but this adjustment
    might introduce a perceptible jitter in the ball’s motion.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了应用程序图形部分的设置，我们调用自定义的bouncyBall()方法，将redBall和scene作为参数传递❷。这个方法封装了设置Timeline和KeyFrame对象并在场景中操控球的过程。在方法内部，我们首先定义了两个位移参数dx和dy，它们设置了红色球在每一帧动画中应该移动的水平和垂直距离（以像素为单位）。我们将这些值初始化为2，但如果你修改它们，球的速度会发生变化。例如，使用4会使球的速度加倍，但这种调整可能会导致球的运动出现明显的抖动。
- en: Next, we create tl, an instance of the Timeline class ❸, and define a single
    KeyFrame object named moveBall ❹. We set the duration of the KeyFrame to 0.015
    seconds (you can play with this value to get a sense of what happens when the
    duration is increased or decreased). The rest of the code block, surrounded by
    braces, is the action event handler block. This block, which we pass as the second
    argument to the KeyFrame constructor, is executed each time the KeyFrame is visited
    along the timeline.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建tl，一个Timeline类的实例❸，并定义一个名为moveBall的KeyFrame对象❹。我们将KeyFrame的持续时间设置为0.015秒（你可以调整这个值，看看当持续时间增大或减小时会发生什么）。代码块的其余部分被大括号包围，是动作事件处理块。我们将这个块作为第二个参数传递给KeyFrame构造函数，每次KeyFrame沿时间线被访问时，这个块都会被执行。
- en: The first few lines inside the action event handler block get the ball’s minimum
    and maximum coordinates in the x- and y-directions based on its current position.
    This is done by checking the corresponding coordinates of the parent container
    (a square, in this case) that holds the child (the circular ball). We then use
    these values to check if the ball has crossed the boundary of the scene during
    the last update of its position. For example, if xMin < 0 is true, the leftmost
    edge of the ball will be outside the left boundary of the scene. Similarly, if
    xMax > scene.width is true, the rightmost edge of the ball will be beyond the
    right boundary of the scene. For any such situations, we reverse the ball’s direction
    of movement along the appropriate axis by negating the corresponding displacement
    parameter (dx or dy), which creates a bouncing effect. The last step inside the
    action event block is to update the ball’s position by adding the displacement
    parameters to the coordinates of the ball, which are accessed by using the redBall
    object’s translateX and translateY properties.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 动作事件处理块中的前几行根据球的当前位置，获取球在x轴和y轴方向上的最小和最大坐标。通过检查父容器（在本例中是一个正方形）的相应坐标（该容器包含子对象——圆形的球）来实现这一点。然后，我们使用这些值来检查球在上次位置更新时是否越过了场景的边界。例如，如果xMin
    < 0为真，球的最左边将超出场景的左边界。类似地，如果xMax > scene.width为真，球的最右边将超出场景的右边界。对于任何这种情况，我们通过取反相应的位移参数（dx或dy）来反转球沿适当轴的运动方向，从而创建一个反弹效果。动作事件块中的最后一步是通过将位移参数添加到球的坐标来更新球的位置，这些坐标可以通过使用redBall对象的translateX和translateY属性来访问。
- en: We conclude the bouncyBall() method by using the with scoping function to assign
    the moveBall keyframe to the timeline ❺, set the timeline to cycle indefinitely,
    and call the play() method ❻ to start moving the ball on its bouncy path. Although
    we can’t show the dynamic motion of the ball on the static page of a book, [Figure
    3-9](chapter3.xhtml#fig3-9) gives you a sense of what to expect when you run this
    code.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用with作用域函数来结束bouncyBall()方法，给时间线分配moveBall关键帧❺，将时间线设置为无限循环，并调用play()方法❻，开始让球沿着它的反弹路径移动。尽管我们无法在静态的书页上展示球的动态运动，[图3-9](chapter3.xhtml#fig3-9)能让你对运行这段代码时的效果有所预期。
- en: '![](../images/Figure3-9.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-9.jpg)'
- en: 'Figure 3-9: Animating a bouncing red ball (shown here in gray)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-9：动画效果——一个反弹的红色球（此处显示为灰色）
- en: 'If you run this code several times and carefully observe the motion of the
    ball, you’ll notice that it actually follows the exact same path every time. In
    other words, its path is predetermined. Can you explain why that’s the case? What
    could we do to make its path less predictable?  ### Summary'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你多次运行此代码并仔细观察球的运动，你会注意到它每次实际上都遵循完全相同的路径。换句话说，它的路径是预定的。你能解释为什么会这样吗？我们能做些什么使其路径更难预测呢？
    ### 总结'
- en: In this chapter, we explored how to integrate JavaFX with Kotlin to create data
    visualizations. We covered fundamental JavaFX components such as Stage, Scene,
    and various layout containers and nodes. We also discussed using the Canvas class
    and its graphics context to create free-form drawings, and how to implement animations
    by using transitions or the Timeline and KeyFrame classes. We practiced these
    concepts through projects drawing various charts, generating a seashell-like spiral
    pattern, and even animating a bouncing ball. Throughout the book, we’ll continue
    to draw on the basic JavaFX tools covered here to add visual components to our
    various projects.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何将 JavaFX 与 Kotlin 集成以创建数据可视化。我们介绍了基本的 JavaFX 组件，如 Stage、Scene 以及各种布局容器和节点。我们还讨论了如何使用
    Canvas 类及其图形上下文来创建自由形式的图形，并介绍了如何通过使用过渡或 Timeline 和 KeyFrame 类来实现动画。我们通过绘制各种图表、生成海螺状的螺旋图案，甚至为弹跳球制作动画来实践这些概念。在本书的后续内容中，我们将继续利用这里介绍的基本
    JavaFX 工具，向我们的各种项目中添加视觉组件。
- en: Resources
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源
- en: 'Balasubramanian, Anirudh. “Crash Course into JavaFX: The Best Way to Make GUI
    Apps.” (Free tutorial.) Accessed June 15, 2024\. *[https://<wbr>www<wbr>.udemy<wbr>.com](https://www.udemy.com)*.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Balasubramanian, Anirudh. “JavaFX 快速入门：制作 GUI 应用的最佳方式。”（免费教程。）访问日期：2024年6月15日。*
    [https://<wbr>www<wbr>.udemy<wbr>.com](https://www.udemy.com) *。
- en: 'Dea, Carl, Gerrit Grunwald, José Pereda, Sean Phillips, and Mark Heckler. *JavaFX
    9 by Example*. 3rd ed. New York: Apress, 2017.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'Dea, Carl, Gerrit Grunwald, José Pereda, Sean Phillips, 和 Mark Heckler. *JavaFX
    9 示例指南*. 第3版. 纽约: Apress, 2017.'
- en: JavaFX. The Official Website for the Open JavaFX Project. Accessed June 15,
    2024\. *[https://openjfx.io](https://openjfx.io)*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX. Open JavaFX 项目的官方网站。访问日期：2024年6月15日。* [https://openjfx.io](https://openjfx.io)
    *。
- en: 'Lowe, Doug. *JavaFX for Dummies*. Hoboken, NJ: John Wiley & Sons, 2015.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Lowe, Doug. *JavaFX 傻瓜书*. 霍博肯，新泽西州：John Wiley & Sons, 2015.
