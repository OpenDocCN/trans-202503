- en: '16'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '16'
- en: MECHANICS IN THREE DIMENSIONS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 三维力学
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common.jpg)'
- en: To predict the motion of a projectile, a satellite, or any object that can move
    unconstrained through three-dimensional space, we need to use three-dimensional
    vectors to describe velocity, acceleration, and force. In this chapter, we’ll
    merge the three-dimensional vectors we described in [Chapter 10](ch10.xhtml) with
    the state-based solution techniques of [Chapter 15](ch15.xhtml).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预测一个抛射体、卫星或任何可以在三维空间中自由运动的物体的运动，我们需要使用三维向量来描述速度、加速度和力。在本章中，我们将把在[第10章](ch10.xhtml)中描述的三维向量与在[第15章](ch15.xhtml)中基于状态的求解技术结合起来。
- en: Describing the state of an object or particle remains central to our task of
    predicting its future motion. We’ll develop an appropriate set of state variables
    for a particle in three dimensions and define a new type called `ParticleState`
    to hold them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 描述物体或粒子的状态仍然是我们预测其未来运动的核心任务。我们将为三维空间中的粒子开发一组适当的状态变量，并定义一个名为`ParticleState`的新类型来保存它们。
- en: Acknowledging the dependence that forces have on state variables, we assign
    the name *one-body force* to a function that returns a force vector when presented
    with a particle state. We give multiple examples of one-body forces, such as Earth’s
    surface gravity and air resistance.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在承认力与状态变量之间的依赖关系时，我们将*一体力*命名为一个函数，该函数在给定粒子状态时返回一个力矢量。我们给出多个一体力的例子，例如地球表面重力和空气阻力。
- en: Solving a mechanics problem is a process of transforming information through
    a sequence of representations, beginning with a list of one-body forces, then
    a differential equation, then a state-update function, and finally a list of states.
    Newton’s second law appears as the transformation from forces to differential
    equation. A numerical method transforms a differential equation into a state-update
    function. Iteration of the state-update function from an initial state produces
    a list of states.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 求解力学问题是一个通过一系列表示转换信息的过程，开始时是一个一体力列表，然后是一个微分方程，再是一个状态更新函数，最后是一个状态列表。牛顿第二定律表现为从力到微分方程的转换。数值方法将微分方程转化为状态更新函数。从初始状态开始反复执行状态更新函数，最终产生一个状态列表。
- en: This chapter explores the foundational ideas and code that allow us to predict
    motion by transforming information through a sequence of representations. Let’s
    start with some introductory code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了允许我们通过一系列表示转换信息来预测运动的基础思想和代码。让我们从一些引导代码开始。
- en: Introductory Code
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引导代码
- en: 'In this chapter and the next two, we’ll create a module that contains ideas
    for setting up and solving Newton’s second law in three dimensions. Before we
    start adding type signatures and function definitions, there’s some code we need
    to have at the top of our source code file. This introductory code consists of
    four parts: a request for warnings, a request to use a language option, a name
    for the module, and a collection of types and functions we wish to import from
    other modules.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章以及接下来的两章中，我们将创建一个模块，该模块包含用于设置和求解三维中的牛顿第二定律的思想。在我们开始添加类型签名和函数定义之前，有一些代码需要放在源代码文件的顶部。这段引导代码由四个部分组成：请求警告、请求使用语言选项、模块名称以及我们希望从其他模块导入的类型和函数集合。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As usual, we begin by turning on warnings. We then turn on the language option
    that allows multi-parameter type classes, just as we did in the last chapter.
    We give this module the name `Mechanics3D`, which is how we will refer to it when
    we use any of the types or functions we define in this module in stand-alone programs
    or in other modules we write in later chapters. The remainder of the code consists
    of import statements, indicating that we wish to use types, type classes, and
    functions defined in modules that other people have written, or those defined
    in modules that we wrote in previous chapters.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，我们首先开启警告。然后，我们启用允许多参数类型类的语言选项，就像我们在上一章中做的那样。我们将这个模块命名为`Mechanics3D`，这将是我们在使用本模块中定义的任何类型或函数时的名称，无论是在独立程序中，还是在后续章节中我们编写的其他模块中。其余的代码是导入语句，表示我们希望使用其他人编写的模块中定义的类型、类型类和函数，或者我们在之前章节中编写的模块中定义的类型和函数。
- en: In particular, we import vector operations from the `SimpleVec` module we wrote
    in [Chapter 10](ch10.xhtml) and some differential equation solving types, type
    classes, and functions from the `Mechanics1D` module we wrote in [Chapter 15](ch15.xhtml).
    We’ve listed the name of each piece we’re importing from the `SimpleVec` and `Mechanics1D`
    modules, as opposed to simply importing the module as a whole. This is my preferred
    style because it shows where each of the names we use in the module comes from.
    If you want to import all of the names, you can write a one-line import statement
    composed of the keyword `import` followed by the module name, as we did in [Chapter
    15](ch15.xhtml). If you import all of the names from many different modules, one
    of the names that you use may be defined in multiple modules, causing the compiler
    to complain. You will then need to clarify which module you want the name imported
    from.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们从[第10章](ch10.xhtml)编写的`SimpleVec`模块中导入了向量运算，另外还从[第15章](ch15.xhtml)编写的`Mechanics1D`模块中导入了一些微分方程求解类型、类型类和函数。我们列出了从`SimpleVec`和`Mechanics1D`模块中导入的每一项名称，而不是直接导入整个模块。这是我偏好的风格，因为它可以显示出我们在模块中使用的每个名称的来源。如果你想导入所有的名称，可以写一行导入语句，使用关键字`import`后跟模块名称，就像我们在[第15章](ch15.xhtml)中做的那样。如果你从多个不同模块导入所有的名称，可能会有一个名称在多个模块中定义，导致编译器报错。这时你需要明确指定希望从哪个模块导入该名称。
- en: The parenthetical with two dots, `(..)`, after a data type like `Attribute`
    means we want to import the data type and all of its constructors. If we omit
    the two dots, we will only import the name of the data type. Two dots after a
    type class, such as `RealVectorSpace`, mean we want to import the functions owned
    by the type class in addition to the name of the type class itself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据类型如`Attribute`后面的括号中加上两个点`(..)`表示我们想要导入该数据类型及其所有构造函数。如果省略两个点，则只会导入数据类型的名称。类型类后面的两个点，比如`RealVectorSpace`，表示我们希望除了导入类型类的名称外，还导入该类型类所拥有的函数。
- en: Lastly, we have the qualified import of the `Graphics.Gloss` and `Vis` modules.
    The first qualified import statement assigns the short name `G` to the `Graphics.Gloss`
    module, allowing us to access any type or function provided by `Graphics.Gloss`
    as long as it’s prefixed by the short name `G` and a dot. The `Picture` type from
    the `Graphics.Gloss` module, for example, must be referred to as `G.Picture`.
    One reason I chose the qualified import method for the `Graphics.Gloss` and `Vis`
    modules is that they define several identical names, such as `simulate`. I want
    to use both definitions of `simulate` in the code I write, and I need a way of
    telling the compiler which definition I mean in each use.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有对`Graphics.Gloss`和`Vis`模块的限定导入。第一个限定导入语句将`Graphics.Gloss`模块的简称`G`分配给该模块，这样我们就可以通过短名称`G`加点来访问`Graphics.Gloss`提供的任何类型或函数。例如，`Graphics.Gloss`模块中的`Picture`类型必须以`G.Picture`来引用。我选择这种限定导入方式的一个原因是，`Graphics.Gloss`和`Vis`模块都定义了几个相同的名称，比如`simulate`。我希望在我编写的代码中使用这两个`simulate`定义，因此需要一种方式来告诉编译器每次使用时应该选择哪个定义。
- en: Having completed our introductory code, let’s look at Newton’s second law in
    three dimensions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了我们的入门代码后，让我们来看看三维中的牛顿第二定律。
- en: Newton’s Second Law in Three Dimensions
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三维中的牛顿第二定律
- en: 'Equation 14.1 gave Newton’s second law in one dimension. In three dimensions,
    position, velocity, acceleration, and force are described by vectors rather than
    numbers. In three dimensions, the net force on an object is the vector sum of
    the forces acting on that object:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 方程14.1给出了牛顿的第二定律在一维中的表达式。在三维中，位置、速度、加速度和力是通过向量来表示，而不是通过数字。在三维中，物体上的合力是作用在物体上的各个力的向量和：
- en: '![Image](Images/281equ01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/281equ01.jpg)'
- en: 'Here is Newton’s second law in three dimensions as a differential equation:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是牛顿第二定律在三维中的微分方程形式：
- en: '![Image](Images/281equ02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/281equ02.jpg)'
- en: '[Figure 16-1](ch16.xhtml#ch16fig1) shows a schematic diagram for Newton’s second
    law in three dimensions. Since acceleration, velocity, and position are being
    treated as vectors now, two of the integrators have vector inputs, vector outputs,
    and vector state.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16-1](ch16.xhtml#ch16fig1)展示了牛顿第二定律在三维中的示意图。由于加速度、速度和位置现在都作为向量处理，因此有两个积分器具有向量输入、向量输出和向量状态。'
- en: '![Image](Images/282fig01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/282fig01.jpg)'
- en: '*Figure 16-1: Schematic representation of Newton’s second law*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-1：牛顿第二定律的示意图*'
- en: Here the forces depend on time, position, and velocity. Acceleration depends
    on net force. Velocity is the integration of acceleration, and position is the
    integration of velocity. The type below each integrator indicates the type of
    quantity that the integrator holds as state. The integrator that outputs time
    holds a real number as state. The integrator that outputs position holds a vector
    as state. The integrator that outputs velocity also holds a vector as state.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，力依赖于时间、位置和速度。加速度依赖于净力。速度是加速度的积分，位置是速度的积分。每个积分器下方的类型表示该积分器作为状态所持有的量的类型。输出时间的积分器持有一个实数作为状态，输出位置的积分器持有一个向量作为状态，输出速度的积分器也持有一个向量作为状态。
- en: 'The two integrators in loops in the diagram hold velocity and position as state,
    so at a minimum, we need velocity and position to be state variables. We included
    time as a state variable for convenience in [Chapters 14](ch14.xhtml) and [15](ch15.xhtml),
    and we will continue to do so here. Writing Newton’s second law as a set of coupled
    first-order differential equations gives the following equations:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图示中的两个积分器分别保持速度和位置作为状态，因此至少我们需要将速度和位置作为状态变量。我们在[第 14 章](ch14.xhtml)和[第 15 章](ch15.xhtml)中为了方便而包含了时间作为状态变量，我们将在这里继续这么做。将牛顿第二定律写成一组耦合的一阶微分方程，得到以下方程：
- en: '![Image](Images/282equ01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/282equ01.jpg)'
- en: Equations 16.3, 16.4, and 16.5 contain information equivalent to the diagram
    in [Figure 16-1](ch16.xhtml#ch16fig1).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 方程 16.3、16.4 和 16.5 包含的信息等同于[图 16-1](ch16.xhtml#ch16fig1)中的图示。
- en: Having introduced Newton’s second law in three dimensions, let’s now turn to
    the question of how we will describe the state of a particle in three dimensions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了三维的牛顿第二定律之后，现在让我们转向如何在三维空间中描述粒子的状态的问题。
- en: The State of One Particle
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个粒子的状态
- en: The state of a particle plays five roles. First, the state specifies the information
    necessary for prediction; it’s the current information about the system that allows
    future prediction without historical information about the system (information
    from the past). Second, the state gives a template for the first-order differential
    Equations 16.3, 16.4, and 16.5 that form the starting point for our numerical
    approximation methods; each first-order differential equation expresses the time
    rate of change of one of the state variables in terms of the state variables themselves.
    Third, the state describes the information that needs to be updated by a state-update
    function. Fourth, the state encompasses the information that the forces depend
    on. Finally, knowing the state at all times counts as a solution to a Newton’s
    second law problem because anything we want to know about a particle is some function
    of its state.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子的状态发挥着五个作用。首先，状态指定了预测所需的信息；它是关于系统的当前信息，可以在没有历史信息的情况下进行未来预测（即过去的信息）。第二，状态为一阶微分方程
    16.3、16.4 和 16.5 提供了模板，这些方程构成了我们数值逼近方法的起点；每个一阶微分方程表示状态变量之一的时间变化率，表达式中仅涉及状态变量。第三，状态描述了需要通过状态更新函数来更新的信息。第四，状态包含了力所依赖的信息。最后，随时了解状态就是解决牛顿第二定律问题，因为我们想知道关于粒子的任何信息，都是其状态的某个函数。
- en: Since the forces that act on a particle can depend on the particle’s mass (such
    as the force of gravity) or charge (such as the Lorentz force law, which we’ll
    discuss later in the chapter), it’s convenient to include mass and charge in the
    state. However, its certainly not necessary; mass and charge remain constant throughout
    most physical situations, so we could treat them as global values independent
    of state. But including mass and charge as state variables will simplify some
    of our code and allow some forces to be expressed as functions of state only instead
    of as functions of state and one or more parameters.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于作用在粒子上的力可能依赖于粒子的质量（如引力）或电荷（如洛伦兹力定律，我们将在本章稍后讨论），因此将质量和电荷包含在状态中是方便的。然而，这并不是必需的；质量和电荷在大多数物理情境下保持恒定，因此我们可以将它们视为与状态无关的全局值。但是，将质量和电荷作为状态变量将简化我们的一些代码，并允许某些力仅作为状态的函数，而不是作为状态和一个或多个参数的函数来表达。
- en: The definition of the `ParticleState` data type we’ll use for the state of one
    particle includes mass, charge, time, position, and velocity as state variables.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用于描述单个粒子状态的`ParticleState`数据类型定义包括质量、电荷、时间、位置和速度作为状态变量。
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We use record syntax to give each field of the new data type its own extraction
    function (`mass`, `charge`, and so on). An extraction function is also called
    an eliminator or selector. We decided to make a new data type (using the `data`
    keyword) rather than a type synonym so that this type has no chance of being confused
    with any other type. We want to be able to display values of this data type, so
    we want `ParticleState` to be an instance of type class `Show`. By including `deriving
    Show`, we ask that the compiler automatically figure out how to make a `Show`
    instance.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用记录语法为新数据类型的每个字段提供自己的提取函数（`mass`、`charge`等）。提取函数也称为消除器或选择器。我们决定创建一个新的数据类型（使用`data`关键字），而不是类型同义词，以确保该类型不会与任何其他类型混淆。我们希望能够显示该数据类型的值，因此我们希望`ParticleState`是类型类`Show`的一个实例。通过包含`deriving
    Show`，我们要求编译器自动计算出如何创建一个`Show`实例。
- en: For convenience, let’s define a default `ParticleState`, which can be used to
    make new particle states.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们定义了一个默认的`ParticleState`，可以用来创建新的粒子状态。
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `defaultParticleState` allows us to define a particle state without needing
    to explicitly provide all five pieces of information. For example, to specify
    the state of a 2-kg rock with no net charge, at the origin, moving with velocity
    ![Image](Images/e0284-01.jpg) m/s, we can write the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultParticleState`允许我们定义一个粒子状态，而无需显式提供所有五个信息。例如，要指定一个2千克的石头状态，电荷为零，位于原点，速度为![Image](Images/e0284-01.jpg)米/秒，我们可以写出以下代码：'
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because we have the default state, we don’t need to explicitly give state variables
    that are the same as those of the default, such as charge, time, and position.
    Recall that the operator `*^` is used to scale a vector on the right by a number
    on the left.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们有默认状态，所以不需要显式地提供与默认值相同的状态变量，如电荷、时间和位置。回想一下，操作符`*^`用于通过左侧的数字缩放右侧的向量。
- en: Newton’s second law is a recipe for constructing a differential equation from
    a list of force functions. Throughout [Chapters 14](ch14.xhtml) and [15](ch15.xhtml),
    we saw the usefulness of force functions in which the force depends on the state
    of the particle. We’ll define a *one-body force* to be a force that depends on
    the current particle state as expressed by `ParticleState`; in other words, a
    force that could depend on time or the particle’s position, velocity, mass, or
    charge.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿第二定律是根据力函数列表构造微分方程的一个公式。在[第14章](ch14.xhtml)和[第15章](ch15.xhtml)中，我们看到了力函数的实用性，其中力依赖于粒子状态。我们将定义*一体力*为依赖于当前粒子状态的力，这个状态由`ParticleState`表示；换句话说，力可能依赖于时间或粒子的位置、速度、质量或电荷。
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We’ll see in the following section that many common forces in mechanics are
    naturally expressed as one-body forces.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到许多常见的力在力学中自然地表现为一体力。
- en: 'The code we write below for Newton’s second law will produce a differential
    equation. In other words, it will produce a function that gives the time derivatives
    of state variables when presented with the state variables themselves. How should
    we return these time derivatives of state variables? Since the state variables
    are bundled together into an object with type `ParticleState`, we will similarly
    bundle together the time derivatives into an object with type `DParticleState`.
    Here is our definition of the new data type `DParticleState`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下面写的代码用于牛顿第二定律将产生一个微分方程。换句话说，它将产生一个函数，当给定状态变量本身时，返回状态变量的时间导数。我们应该如何返回这些状态变量的时间导数呢？由于状态变量被捆绑在一个类型为`ParticleState`的对象中，我们将类似地将时间导数捆绑在一个类型为`DParticleState`的对象中。以下是我们定义的新数据类型`DParticleState`：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As there are five quantities contained in the particle state, so there are five
    quantities in the state derivative. The real number whose extraction function
    is `dmdt` (named after the derivative *dm*/*dt*) holds the rate at which mass
    changes. Mass will not change in any of our examples, so this rate will be zero,
    but the ability to have mass change is useful in some situations, such as rocket
    motion (in which a rocket expends fuel). Each of the other extraction functions
    has a name designed to indicate that the quantity represents the rate of change
    of a state variable. The names `dqdt` and `dtdt` label the real numbers for the
    rates at which charge and time change with time, respectively. The rate at which
    time changes with time is 1, so it’s a little silly to keep track of this rate.
    An alternative is to write a data type that omits this quantity; I have chosen
    a data type whose structure parallels that of the state, even if some slots hold
    information that seems obvious. The names `drdt` and `dvdt` label the rates at
    which position and velocity change. These quantities are vectors, as the data
    type definition shows.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于粒子状态中包含五个量，因此状态导数中也包含五个量。其提取函数为`dmdt`（得名于导数*dm*/*dt*）的实数表示质量变化率。质量在我们的示例中不会发生变化，因此该变化率为零，但在某些情况下，质量变化的能力是有用的，例如火箭运动（火箭消耗燃料）。其他每个提取函数的命名旨在表示该量表示状态变量变化率。`dqdt`和`dtdt`表示电荷和时间变化率的实数。时间对时间的变化率为1，所以追踪这个变化率有点多余。另一种做法是编写一个省略该量的数据类型；我选择了一个与状态结构相平行的数据类型，即使有些槽位存储的内容看起来显而易见。`drdt`和`dvdt`表示位置和速度变化率。这些量是向量，正如数据类型定义所示。
- en: The function `newtonSecondPS` below is the Haskell representation of Newton’s
    second law, which is equivalent to differential Equations 16.3, 16.4, and 16.5.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下述函数`newtonSecondPS`是牛顿第二定律的Haskell表示形式，相当于微分方程16.3、16.4和16.5。
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The function `newtonSecondPS` is a recipe for converting a list of one-body
    forces into a differential equation. The PS in the name indicates that the function
    works with the `ParticleState` data type. The differential equation produced by
    `newtonSecondPS` expresses the time rate of change of each of the state variables
    in terms of the state variables themselves. Given values for each of the five
    state variables, the function `newtonSecondPS` returns values for the time rate
    of change of each of these five.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`newtonSecondPS`是将一组单体力转换为微分方程的公式。名称中的PS表示该函数与`ParticleState`数据类型一起工作。由`newtonSecondPS`生成的微分方程表示每个状态变量的时间变化率，用状态变量本身表示。给定五个状态变量的值，函数`newtonSecondPS`将返回这五个状态变量的时间变化率的值。
- en: The function `newtonSecondPS` consists of a `let` expression, in which we first
    find the `Vec` representing the net force on the particle in the current state,
    name it `fNet`, then name the mass and velocity of the particle `m` and `v`, respectively,
    and finally compute the acceleration of the particle by dividing the net force
    by the mass. The body of the `let` expression returns a state derivative with
    type `DParticleState`. The derivatives of mass and charge with respect to time
    are 0 because mass and charge do not change. The derivative of time with respect
    to time is 1\. Finally, the derivative of position is the velocity in the current
    state, and the derivative of velocity is the acceleration calculated in the `let`
    expression.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`newtonSecondPS`包含一个`let`表达式，在该表达式中，我们首先找到表示粒子当前状态下合力的`Vec`，将其命名为`fNet`，然后分别将粒子的质量和速度命名为`m`和`v`，最后通过将合力除以质量来计算粒子的加速度。`let`表达式的主体返回一个类型为`DParticleState`的状态导数。质量和电荷对时间的导数为0，因为质量和电荷不变化。时间对时间的导数为1。最后，位置的导数是当前状态下的速度，而速度的导数是`let`表达式中计算出的加速度。
- en: We regard the function `newtonSecondPS fs`, where `fs` is the list of one-body
    forces that describes the physical situation, as the Haskell version of the differential
    equation that expresses Newton’s second law. The schematic diagram in [Figure
    16-1](ch16.xhtml#ch16fig1), the differential Equations 16.3, 16.4, and 16.5, and
    the Haskell function `newtonSecondPS` are different ways of expressing Newton’s
    second law for a single object in three dimensions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将函数`newtonSecondPS fs`视为牛顿第二定律的哈斯克尔版本，其中`fs`是描述物理情况的一体力列表。图[16-1](ch16.xhtml#ch16fig1)中的示意图、微分方程16.3、16.4和16.5，以及哈斯克尔函数`newtonSecondPS`是表达牛顿第二定律的不同方式，适用于三维空间中的单一物体。
- en: Solving Newton’s Second Law
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决牛顿第二定律
- en: 'Our strategy for constructing and solving Newton’s second law for one particle
    consists of transforming information about the physical situation through a sequence
    of four different forms:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建并求解牛顿第二定律的策略是通过四种不同形式的信息转换来处理物理情况：
- en: One-body forces
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一体力
- en: Differential equation
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微分方程
- en: State-update function
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态更新函数
- en: List of states
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态列表
- en: '[Figure 16-2](ch16.xhtml#ch16fig2) shows a functional diagram of the data representations,
    shown as vertical arrows, and the functions that transform the data from one representation
    to another, shown as boxes.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图[16-2](ch16.xhtml#ch16fig2)展示了数据表示的功能图，垂直箭头表示数据表示，方框表示将数据从一种表示转换为另一种表示的函数。
- en: '![Image](Images/286fig01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/286fig01.jpg)'
- en: '*Figure 16-2: Data flow for solving a one-particle mechanics problem*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-2：解决单粒子力学问题的数据流*'
- en: A list of one-body forces is the first in a sequence of four information representations
    we use to describe a physical situation, each getting closer to a solution. The
    list of one-body forces characterizes the physical setting or situation in which
    a particle finds itself, serving as an algebraic analogue to the visual and geometric
    free-body diagrams that introductory physics classes use to show all of the forces
    acting on an object.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一体力列表是我们用来描述物理情况的四种信息表示方式中的第一种，每种方式都越来越接近解决方案。这个一体力列表描述了粒子所处的物理环境或情况，作为代数类比，它类似于初学物理时所用的自由体图，用于展示作用于物体上的所有力。
- en: Newton’s second law provides the means to transform the one-body forces into
    a differential equation, our second information representation. The function `newtonSecondPS`
    expresses Newton’s second law as it applies to the `ParticleState` data type.
    The Haskell representation of a differential equation is a function `ParticleState
    -> DParticleState` that gives the time rates of change of the state variables
    in terms of the state variables themselves.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿第二定律提供了将一体力转化为微分方程的方法，这是我们的第二种信息表示。函数`newtonSecondPS`将牛顿第二定律应用于`ParticleState`数据类型。微分方程的哈斯克尔表示是函数`ParticleState
    -> DParticleState`，它给出了状态变量随时间变化的速率，并以状态变量本身为表达式。
- en: A state-update function is our third information representation; it describes
    how to take a small step forward in time, producing a new state from an old state.
    The two-and three-dimensional animation tools we use take a state-update function
    as input; inasmuch as an animated visualization of a particle’s motion counts
    as a solution to a mechanics problem, the state-update function at the heart of
    that animation can also be regarded as a solution. To obtain a state-update function
    from a differential equation, we need a numerical method. By using a numerical
    method, we admit that we’re looking only for an approximate solution to our mechanics
    problem rather than an exact solution as can sometimes be found by working with
    a differential equation analytically. We have a choice of numerical methods; `euler
    0.01`, `eulerCromerPS 0.1`, and `rungeKutta4 0.1` will be examples of numerical
    methods that can be used to produce a state-update function. We’ll write the function
    `eulerCromerPS` later in this chapter, and we’ll also show how to make use of
    the general-purpose functions `euler` and `rungeKutta4` that we wrote in the last
    chapter. Having chosen a numerical method, we apply it to the differential equation
    to obtain a state-update function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 状态更新函数是我们第三种信息表示方式；它描述了如何在时间上向前迈出小步，从一个旧状态产生一个新状态。我们使用的二维和三维动画工具以状态更新函数作为输入；因为粒子运动的动画可视化算作一个力学问题的解，所以该动画中的状态更新函数也可以看作是一个解。为了从微分方程中得到状态更新函数，我们需要数值方法。通过使用数值方法，我们承认我们仅仅是在寻找力学问题的近似解，而不是通过解析方法解决微分方程时能找到的精确解。我们可以选择不同的数值方法；`euler
    0.01`、`eulerCromerPS 0.1` 和 `rungeKutta4 0.1` 都是可以用来生成状态更新函数的数值方法示例。我们将在本章后面写出`eulerCromerPS`函数，也会展示如何使用在上一章中编写的通用函数`euler`和`rungeKutta4`。选择了数值方法后，我们将其应用到微分方程上，从而得到一个状态更新函数。
- en: The fourth information representation we use is a list of states. The list gives
    the state of the particle at each time calculated by the numerical method; in
    other words, each list element is the state at a particular time that is one time
    step advanced from that of the previous list element. This is pretty much all
    the information we could hope to know about the particle. From it, we can graph
    any state variable as a function of time or some other state variable.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的第四种信息表示方式是一个状态列表。该列表给出了通过数值方法计算的粒子在每个时间点的状态；换句话说，每个列表元素是特定时刻的状态，它比前一个列表元素的时间步长要长。这几乎是我们能知道的关于粒子的信息了。通过这些信息，我们可以将任何状态变量绘制为时间或其他状态变量的函数。
- en: Other quantities we might care about, but that are not contained in the state,
    such as energy or momentum, are functions of the state variables. If we wish,
    we can write a higher-order function that produces a position function or a velocity
    function for the particle from the information contained in the list of states.
    To obtain the list of states from the state-update function, we simply iterate
    the state-update function using the Prelude function `iterate`, which applies
    the state-update function to a given initial state and then to the updated state
    over and over again to make a list.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能关心的其他量，如能量或动量，虽然不包含在状态中，但却是状态变量的函数。如果我们愿意，我们可以写一个更高阶的函数，从状态列表中提取出粒子的位置函数或速度函数。要从状态更新函数得到状态列表，我们只需使用Prelude中的`iterate`函数迭代状态更新函数，这个函数将状态更新函数应用到给定的初始状态，然后不断应用到更新后的状态，直到生成一个列表。
- en: '[Figure 16-2](ch16.xhtml#ch16fig2) should be regarded as an overview of the
    process of solving a one-particle mechanics problem in three dimensions. The figure
    is similar to [Figure 15-2](ch15.xhtml#ch15fig2); the two main differences are
    (1) we’re using the new `ParticleState` data type, which contains mass, and (2)
    the new figure allows a choice of numerical method where the previous figure insisted
    on the Euler method.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16-2](ch16.xhtml#ch16fig2)应当被视为在三维空间中解决单粒子力学问题的过程概述。该图与[图15-2](ch15.xhtml#ch15fig2)相似，主要有两个区别：(1)
    我们使用了新的`ParticleState`数据类型，它包含质量；(2) 新的图允许选择数值方法，而上一图则坚持使用欧拉方法。'
- en: In summary, the broad outline of our process is to translate our problem (given
    by one-body forces) into something mathematical (a differential equation), solve
    the mathematics problem (by using a numerical method to produce a state-update
    function and iterating to produce a list of states), and then return to physics
    to interpret the results.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们的过程大致是将我们的物理问题（由一体力给出）转化为数学问题（一个微分方程），解决数学问题（通过数值方法生成状态更新函数，并进行迭代产生一系列状态），然后回到物理学解释结果。
- en: Having given an overview of the process we’ll employ to solve Newton’s second
    law, which begins with a list of one-body forces, let’s take a look at some examples
    of one-body forces.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在概述了我们将用于解决牛顿第二定律的过程后，接下来让我们看看一些一体力的例子。
- en: One-Body Forces
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一体力
- en: We introduced the definition of a one-body force earlier in this chapter, but
    we did not give any examples. Many of the common forces that we may want to include
    in Newton’s second law are naturally expressed as one-body forces.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章之前介绍了一体力的定义，但并未给出任何例子。许多我们希望纳入牛顿第二定律的常见力本质上都可以表示为一体力。
- en: Earth Surface Gravity
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 地球表面重力
- en: An object near Earth’s surface feels a gravitational force from the earth. (This
    is theory 2 from the list of gravity theories on [page 148](ch10.xhtml#ch10lev19).)
    If **g** is the acceleration of gravity that points toward the center of the earth,
    the gravitational force exerted by Earth on a particle or object with mass *m*
    that is near Earth’s surface is
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个靠近地球表面的物体会感受到来自地球的引力。（这是引力理论列表中[第148页](ch10.xhtml#ch10lev19)的理论2。）如果**g**是指向地球中心的重力加速度，那么地球对靠近地球表面质量为*m*的粒子或物体施加的引力为：
- en: '**F**[*g*] = *m***g**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**F**[*g*] = *m***g**'
- en: 'If we agree to let the z-direction of our coordinate system point away from
    Earth’s center, and to use SI units, then a one-body force for Earth surface gravity
    can be written as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们同意让坐标系的z轴指向远离地球中心的方向，并且使用国际单位制，那么地球表面重力的一体力可以写作如下：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Recall that a one-body force is a function from particle state to force vector.
    The local variable `st` holds the particle state, and `mass st` extracts the mass
    from the particle state using the extraction function `mass` that is automatically
    generated because we used record syntax when we defined `ParticleState`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，一体力是从粒子状态到力向量的函数。局部变量`st`保存粒子状态，`mass st`通过提取函数`mass`从粒子状态中提取质量，该提取函数是因为我们在定义`ParticleState`时使用了记录语法而自动生成的。
- en: If Earth’s surface gravity is a force that acts on our particle, all we need
    to do is include `earthSurfaceGravity` in the list of one-body forces that forms
    the input to `newtonSecondPS`. The appropriate mass will be taken from the state,
    and the force of gravity will be included in Newton’s second law.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果地球表面重力是作用于我们粒子的力，那么我们需要做的就是将`earthSurfaceGravity`包含在构成`newtonSecondPS`输入的一体力列表中。适当的质量将从状态中提取，引力将被包含在牛顿第二定律中。
- en: Gravity Produced by the Sun
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 太阳产生的引力
- en: Any object with mass exerts a gravitational force on any other object with mass.
    (This is theory 3 from the list of gravity theories on [page 148](ch10.xhtml#ch10lev19).)
    If the objects are spherical in shape, the force exerted by one object on another
    is directly proportional to the mass of each object and inversely proportional
    to the square of the distance between their centers. This is the content of Newton’s
    law of universal gravity, which we will discuss in more detail in [Chapter 19](ch19.xhtml).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有质量的物体都会对任何其他具有质量的物体施加引力。（这是引力理论列表中[第148页](ch10.xhtml#ch10lev19)的理论3。）如果物体是球形的，一个物体对另一个物体施加的引力与每个物体的质量成正比，与它们中心之间距离的平方成反比。这就是牛顿万有引力定律的内容，我们将在[第19章](ch19.xhtml)中详细讨论。
- en: 'In our solar system, there are many examples of pairs of objects with one much
    more massive than the other, such as sun/Earth, Earth/moon, and Earth/telecommunications
    satellite. If we want to understand Earth’s motion as it moves through the solar
    system, it is a good approximation to suppose two things: one, that the gravitational
    attraction of other planets such as Mars, Venus, and Jupiter have a very small
    effect on Earth, and can therefore be ignored; and two, that the sun is so massive
    compared to Earth that its position can be taken to be fixed. Under these approximations,
    the universal gravity produced by the sun can be regarded as a one-body force
    acting on Earth (or on Mars, Venus, Halley’s comet, and so on).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的太阳系中，有许多对象对，其中一个对象比另一个对象重得多，例如太阳/地球、地球/月球和地球/通信卫星。如果我们想要理解地球在太阳系中移动的运动，可以很好地假设两件事：一是其他行星（如火星、金星和木星）的引力吸引对地球的影响非常小，因此可以忽略不计；二是太阳与地球相比如此之大，其位置可以视为固定。在这些近似情况下，太阳产生的普遍重力可以视为作用于地球（或火星、金星、哈雷彗星等）的一体力。
- en: The gravitational force exerted by the sun on an object or particle with mass
    *m* is
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 太阳对具有质量*m*的物体或粒子施加的引力是
- en: '![Image](Images/289equ01.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/289equ01.jpg)'
- en: where *G* is Newton’s gravitational constant (in SI units, *G* = 6.67408 × 10–^(11)
    N m²/kg²), *M[s]* is the mass of the sun (*M[s]* = 1.98848 × 10^(30) kg), *r*
    is the distance between the center of the sun and the center of the object, and
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*G*是牛顿引力常数（在国际单位制中，*G* = 6.67408 × 10^(-11) N m²/kg²），*M[s]*是太阳的质量（*M[s]*
    = 1.98848 × 10^(30) kg），*r*是太阳中心与物体中心之间的距离，以及
- en: '![Image](Images/289equ02.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/289equ02.jpg)'
- en: 'is a unit vector pointing from the sun toward the object. The minus sign implies
    that the force on the object is toward the sun. A one-body force for sun gravity
    can be written as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个单位矢量，指向太阳朝向物体。负号意味着物体上的力指向太阳。可以写出太阳引力的一体力如下：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we use pattern matching on the input to extract the state variables instead
    of the extraction function we used for the previous one-body force of Earth surface
    gravity. Instead of naming the particle state with a local variable like `st`,
    we match the pattern of a particle state using the `ParticleState` constructor.
    We assign the five local variables that follow the constructor the values mass,
    charge, time, position, and velocity, respectively. We don’t need charge, time,
    or velocity to compute the gravitational force that the sun exerts, so they are
    preceded by underscores. (We could have used *only* the underscore for any or
    all of the unused variables, but providing a name after the underscore reminds
    us of exactly what is being ignored.) The choice of whether to use extraction
    functions or pattern matching to get the state variables out of the state is a
    matter of style, and you can use whatever you like best.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用输入模式匹配来提取状态变量，而不是我们用于地球表面重力的前一个一体力的提取函数。我们使用`ParticleState`构造函数匹配粒子状态的模式。我们分配跟随构造函数的五个局部变量的值为质量、电荷、时间、位置和速度。我们不需要电荷、时间或速度来计算太阳施加的引力，因此它们前面有下划线。
    （我们可以仅对任何或所有未使用的变量使用下划线，但在下划线后提供名称提醒我们忽略的内容。）选择是使用提取函数还是模式匹配来从状态中获取状态变量是一种风格问题，您可以使用您最喜欢的任何一种。
- en: If we are interested in the motion of the moon around the earth, we can express
    Earth’s universal gravity as a one-body force that acts on the moon. Exercise
    16.4 asks you to write a one-body force for the universal gravity produced by
    Earth. If, on the other hand, we are interested in the motion of the moon through
    the solar system, then gravity from both the sun and Earth is important, and it’s
    better to use the techniques of [Chapter 19](ch19.xhtml).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对月球绕地球运动感兴趣，我们可以将地球的普遍重力表达为作用于月球的一体力。练习16.4要求您为地球产生的普遍重力编写一个一体力。另一方面，如果我们对月球在太阳系中的运动感兴趣，那么太阳和地球的引力都很重要，最好使用[第19章](ch19.xhtml)的技术。
- en: Air Resistance
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 空气阻力
- en: Air resistance is a one-body force that depends on the velocity of the object
    moving through the air. We assume that the air is still with respect to our coordinate
    system. In [Chapter 14](ch14.xhtml), we developed an expression for air resistance
    that we applied in one-dimensional situations. In three-dimensional situations,
    velocity is a vector, and the force of air resistance appears as
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 空气阻力是一种一体力，依赖于物体在空气中移动的速度。我们假设空气在我们的坐标系中是静止的。在[第14章](ch14.xhtml)中，我们推导出了适用于一维情况的空气阻力表达式。在三维情况下，速度是一个向量，空气阻力的力表现为
- en: '![Image](Images/290equ01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/290equ01.jpg)'
- en: with the parameters *C*, *ρ*, and *A* still representing the drag coefficient,
    the density of the air, and the cross-sectional area of the object, respectively.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 参数*C*、*ρ* 和 *A* 仍然分别表示拖曳系数、空气密度和物体的横截面积。
- en: 'Here is the Haskell code for the one-body force that corresponds to Equation
    16.6:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对应于方程16.6的一体力的Haskell代码：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We are using pattern matching on the input when we name the incoming particle
    state `ParticleState _m _q _t _r v`. The force depends only on the velocity, so
    the velocity is the only state variable that needs to be named.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在命名传入粒子状态`ParticleState _m _q _t _r v`时，使用了模式匹配。力仅依赖于速度，因此速度是唯一需要命名的状态变量。
- en: For any situation in which we want to include air resistance, we need to estimate
    a drag coefficient, determine the cross-sectional area of our object, and determine
    an appropriate value for the density of air. At a reasonable temperature and pressure
    near Earth’s surface, the density of air is about 1.225 kg/m³. If, for example,
    0.8 was our drag coefficient and 0.003 m² was the cross-sectional area of our
    object, then including
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何需要考虑空气阻力的情况，我们需要估算一个拖曳系数，确定物体的横截面积，并确定一个适当的空气密度值。在地球表面附近的合理温度和压力下，空气的密度约为1.225
    kg/m³。例如，如果我们的拖曳系数是0.8，物体的横截面积是0.003 m²，那么
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: in the list of one-body forces for `newtonSecondPS` would include the force
    of air resistance in Newton’s second law.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`newtonSecondPS`的一体力列表中将包括空气阻力力，这出现在牛顿第二定律中。
- en: If we were going to do a lot of air resistance problems, we might put the cross-sectional
    area of the object into the state since it’s clearly a property of the object.
    We might even consider putting the drag coefficient into the state, if that can
    be regarded as a property of the object rather than a property of the interaction
    between the object and the air. We won’t make these modifications to our state
    data type; instead, we’ll stick with our `ParticleState`, and when forces depend
    on parameters that are not included in the state, we’ll just handle it on a case-by-case
    basis, as we did here.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要做大量的空气阻力问题，可能会将物体的横截面积纳入状态，因为它显然是物体的一个属性。如果我们认为拖曳系数是物体的属性，而不是物体与空气之间相互作用的属性，我们甚至可以考虑将拖曳系数纳入状态。我们不会对状态数据类型进行这些修改；相反，我们将坚持使用`ParticleState`，当力依赖于不包含在状态中的参数时，我们将根据具体情况逐一处理，就像我们在这里做的那样。
- en: Wind Force
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 风力
- en: 'The one-body force of air resistance just considered assumes that the air is
    motionless with respect to our coordinate system. The one-body wind force we consider
    in this section is a generalization of air resistance in that the air moves at
    some constant velocity with respect to our coordinate system. We can use our air
    resistance formula to find the wind force, but the appropriate velocity to use
    is the *relative velocity* between the object and the wind. If **v** is the velocity
    of the object with respect to our coordinate system, and **v**[wind] is the velocity
    of the air with respect to our coordinate system, then **v** – **v**[wind] is
    the velocity of the object with respect to the air. The wind force can be expressed
    as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚考虑的空气阻力一体力假设空气在我们的坐标系中是静止的。本节中考虑的风力是一种空气阻力的推广，即空气相对于我们的坐标系以某个恒定速度运动。我们可以使用空气阻力公式来计算风力，但适用的速度是物体与风之间的*相对速度*。如果**v**是物体相对于我们坐标系的速度，**v**[wind]是空气相对于我们坐标系的速度，那么**v**
    – **v**[wind]就是物体相对于空气的速度。风力可以表达为：
- en: '![Image](Images/291equ01.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/291equ01.jpg)'
- en: 'Here is the corresponding Haskell code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对应的Haskell代码：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code for wind force is similar to the code for air resistance. Exercise
    17.5 gives an opportunity to try out this force. Notice that if the wind velocity
    is chosen to be 0, the wind force becomes the force of air resistance we treated
    in the previous section. Air resistance is the force that stationary air exerts
    on an object, while wind force is the force that moving air exerts on an object.
    If the force of air is important in a situation, you’ll want air resistance or
    the wind force, but not both.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 风力的代码与空气阻力的代码类似。练习17.5提供了尝试这一力的机会。请注意，如果选择风速为0，那么风力就变成了我们在上一节中讨论的空气阻力。空气阻力是静止的空气对物体施加的力，而风力是流动的空气对物体施加的力。如果空气的力在某种情况下很重要，你需要使用空气阻力或风力，而不是两者兼用。
- en: Force from Uniform Electric and Magnetic Fields
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 来自均匀电场和磁场的力
- en: We haven’t talked about electric or magnetic fields yet, but we will in [Part
    III](part03.xhtml) of the book. For now, the important things to know are that
    these fields are produced by electric charge and that a particle experiences a
    force in the presence of electric and/or magnetic fields. When these fields are
    *uniform*, meaning the same at different places in space, a single vector describes
    the electric field and a single vector describes the magnetic field.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论电场或磁场，但我们将在本书的[第三部分](part03.xhtml)中讨论。现在，重要的是要知道，这些场是由电荷产生的，粒子在电场和/或磁场中会经历一个力。当这些场是*均匀*时，意味着它们在空间中的不同位置是相同的，那么一个向量可以描述电场，另一个向量可以描述磁场。
- en: Suppose that **E** is a uniform electric field vector and **B** is a uniform
    magnetic field vector. These fields exert a force on a charged particle traveling
    through them, given by
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 假设**E**是一个均匀电场向量，**B**是一个均匀磁场向量。这些场对穿越它们的带电粒子施加力，如下所示：
- en: '![Image](Images/e0292-01.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/e0292-01.jpg)'
- en: 'where *q* is the electric charge of the particle and **v**(*t*) is the velocity
    of the particle. This equation is called the *Lorentz force law*, and we will
    study it in more detail when we turn to electromagnetic theory, including the
    more general situation in which the fields need not be uniform. Here is the corresponding
    Haskell code for the one-body force:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*q*是粒子的电荷，**v**(*t*)是粒子的速度。这个方程被称为*洛伦兹力定律*，我们将在电磁学理论部分详细研究它，包括场不一定均匀时的更一般情况。以下是对应的Haskell代码，表示单粒子的力：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The function `uniformLorentzForce` has type `Vec -> Vec -> OneBodyForce`, which
    is the same as `Vec -> Vec -> ParticleState -> Vec`. Given a vector `vE :: Vec`
    for the electric field, a vector `vB :: Vec` for the magnetic field, and a particle
    state `ParticleState _m q _t _r v :: ParticleState` using pattern matching on
    the input, the function returns a force vector by applying the Lorentz force law
    (Equation 16.8). The charge and velocity of the particle are the state variables
    needed to compute this electromagnetic force.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '函数`uniformLorentzForce`的类型是`Vec -> Vec -> OneBodyForce`，这与`Vec -> Vec -> ParticleState
    -> Vec`相同。给定一个电场向量`vE :: Vec`、一个磁场向量`vB :: Vec`和一个粒子状态`ParticleState _m q _t _r
    v :: ParticleState`，通过模式匹配输入，该函数通过应用洛伦兹力定律（方程16.8）返回一个力向量。粒子的电荷和速度是计算这一电磁力所需的状态变量。'
- en: Having seen several examples of one-body forces, let’s continue along [Figure
    16-2](ch16.xhtml#ch16fig2) and explore the state-update process.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到多个单粒子力的例子后，我们继续沿着[图16-2](ch16.xhtml#ch16fig2)探讨状态更新过程。
- en: State Update for One Particle
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单粒子状态更新
- en: 'A numerical method transforms a differential equation into a state-update function.
    The Euler-Cromer method is a numerical method, and because it’s not a general-purpose
    numerical method, we need to write a new function for it for each state data type
    we want to use. Here is the Euler-Cromer function for the `ParticleState` data
    type:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 数值方法将微分方程转化为状态更新函数。欧拉-克罗默方法就是一种数值方法，由于它不是一种通用数值方法，因此我们需要为每种状态数据类型编写一个新的函数。以下是`ParticleState`数据类型的欧拉-克罗默函数：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we saw with the Euler-Cromer method in the last chapter, the key difference
    compared with the Euler method is that it uses an updated velocity to update position.
    The update equations in `eulerCromerPS` are almost identical to those in `eulerCromer1D`
    of the previous chapter, with the one difference being that we are now working
    with vectors.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中使用欧拉-克罗默方法所看到的，与欧拉方法相比，关键的区别在于它使用更新后的速度来更新位置。`eulerCromerPS`中的更新方程几乎与上一章的`eulerCromer1D`中的方程相同，唯一的区别是我们现在使用的是向量。
- en: The Euler and fourth-order Runge-Kutta methods are general-purpose methods for
    solving any differential equation. In [Chapter 15](ch15.xhtml), we wrote the `euler`
    and `rungeKutta4` functions, which can work with any differential equation and
    any state type. To use them with the `ParticleState` data type, we must write
    a `RealVectorSpace` instance for `DParticleState` and a `Diff` instance relating
    the `ParticleState` and `DParticleState` types.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉法和四阶龙格-库塔法是用于解决任何微分方程的通用方法。在[第15章](ch15.xhtml)中，我们编写了`euler`和`rungeKutta4`函数，这些函数可以处理任何微分方程和任何状态类型。为了将它们与`ParticleState`数据类型一起使用，我们必须为`DParticleState`编写一个`RealVectorSpace`实例，并为`ParticleState`和`DParticleState`类型编写一个`Diff`实例。
- en: 'Here is the `RealVectorSpace` instance:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`RealVectorSpace`实例：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this instance declaration, we define addition to be item-wise addition for
    each item, and we define scalar multiplication to be item-wise scaling for each
    item.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实例声明中，我们定义加法为每个项的逐项加法，定义标量乘法为每个项的逐项缩放。
- en: 'Here is the `Diff` instance:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Diff`实例：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Each item in the state is shifted by the product of its derivative with the
    time step.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 状态中的每个项都通过其导数与时间步长的乘积进行平移。
- en: Having made these instance declarations, we now have access to the functions
    `euler` and `rungeKutta4` we wrote in the previous chapter. We can use any of
    the three numerical methods, Euler, Euler-Cromer, or fourth-order Runge-Kutta,
    to produce a state-update function from a differential equation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出这些实例声明后，我们现在可以访问在上一章中编写的`euler`和`rungeKutta4`函数。我们可以使用三种数值方法中的任何一种，欧拉法、欧拉-克罗默法或四阶龙格-库塔法，从微分方程中生成状态更新函数。
- en: '[Figure 16-2](ch16.xhtml#ch16fig2) showed the four data representations we
    use to solve a mechanics problem and three functions that transform from one data
    representation to another. Compositions of these three functions are important
    enough to name and are shown as arrows on the sides of [Figure 16-3](ch16.xhtml#ch16fig3).
    We wrote `solver` in the last chapter and will write `updatePS` and `statesPS`
    shortly.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16-2](ch16.xhtml#ch16fig2)展示了我们用来解决力学问题的四种数据表示方式和三种从一种数据表示转换到另一种数据表示的函数。这三种函数的组合非常重要，以至于需要命名，并在[图16-3](ch16.xhtml#ch16fig3)的两侧以箭头形式显示。我们在上一章中编写了`solver`，并将在接下来的章节中编写`updatePS`和`statesPS`。'
- en: '![Image](Images/294fig01.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/294fig01.jpg)'
- en: '*Figure 16-3: Data representations and functions that transform among them*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-3：数据表示与它们之间转换的函数*'
- en: '[Figure 16-3](ch16.xhtml#ch16fig3) again shows the four data representations,
    with one small change. Where [Figure 16-2](ch16.xhtml#ch16fig2) has a list of
    states as the final representation, [Figure 16-3](ch16.xhtml#ch16fig3) has a function
    from initial state to list of states, which we call an *evolver*. The reason for
    this change is that we want to view each representation in [Figure 16-3](ch16.xhtml#ch16fig3)
    as the result of applying a single function to the single input consisting of
    the previous representation. In other words, where the initial state appears as
    an input in [Figure 16-2](ch16.xhtml#ch16fig2), it is part of the type of the
    evolver in [Figure 16-3](ch16.xhtml#ch16fig3). To transform between adjacent representations
    in [Figure 16-3](ch16.xhtml#ch16fig3), we apply Newton’s second law, then a numerical
    method, and then iteration.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16-3](ch16.xhtml#ch16fig3)再次展示了四种数据表示方式，并进行了一个小的更改。与[图16-2](ch16.xhtml#ch16fig2)中的最终表示为状态列表不同，[图16-3](ch16.xhtml#ch16fig3)展示了从初始状态到状态列表的一个函数，我们称之为*进化器*。之所以做出这个改变，是因为我们希望将[图16-3](ch16.xhtml#ch16fig3)中的每个表示视为将单个函数应用于由前一个表示构成的单一输入的结果。换句话说，在[图16-2](ch16.xhtml#ch16fig2)中，初始状态作为输入出现，而在[图16-3](ch16.xhtml#ch16fig3)中，它是进化器类型的一部分。为了在[图16-3](ch16.xhtml#ch16fig3)中进行相邻表示之间的转换，我们应用了牛顿第二定律、数值方法，然后进行迭代。'
- en: Let’s write a function `statesPS` that produces all three transformations of
    [Figure 16-3](ch16.xhtml#ch16fig3) by producing the differential equation from
    the forces, using a numerical method to turn the differential equation into a
    state-update function, and iterating the state-update function to produce an evolver.
    The inputs to this function will be a numerical method and a list of one-body
    forces. The output will be an evolver that can act on an initial state to produce
    an infinite list of states. We call this function `statesPS` because it produces
    a list of states when supplied with an initial state and is for the `ParticleState`
    data type.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个函数`statesPS`，它通过从力中产生微分方程，使用数值方法将微分方程转化为状态更新函数，并迭代状态更新函数来生成一个进化器，从而生成[图16-3](ch16.xhtml#ch16fig3)中的所有三种转换。这个函数的输入将是一个数值方法和一组单体力。输出将是一个可以作用于初始状态并生成无限状态列表的进化器。我们称这个函数为`statesPS`，因为它在提供初始状态时生成状态列表，且适用于`ParticleState`数据类型。
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The local variable `method` stands for the numerical method we provide when
    we use `statesPS`. We see from the definition that this function is a composition
    of three functions, as suggested by [Figure 16-3](ch16.xhtml#ch16fig3). Recall
    that numerical methods are things like `euler 0.01`, `eulerCromerPS 0.1`, and
    `rungeKutta4` `0.1`. Notice that the function `newtonSecondPS`, which transforms
    forces into a differential equation, can be used with any numerical method.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量`method`代表我们在使用`statesPS`时提供的数值方法。从定义中可以看出，这个函数是三个函数的复合，如[图16-3](ch16.xhtml#ch16fig3)所示。回想一下，数值方法包括`euler
    0.01`、`eulerCromerPS 0.1`和`rungeKutta4 0.1`等。请注意，`newtonSecondPS`函数将力转换为微分方程，它可以与任何数值方法一起使用。
- en: It is similarly useful, especially for animation, to name the function that
    transforms from a list of forces to a state-update function. We’ll call this function
    `updatePS`, and we see from its definition that it is simply the composition of
    Newton’s second law with a numerical method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，将力列表转换为状态更新函数的函数名称也非常有用，尤其是对于动画。我们将这个函数称为`updatePS`，从它的定义可以看出，它只是牛顿第二定律与数值方法的复合。
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Figure 16-3](ch16.xhtml#ch16fig3) demonstrates how this function fits into
    the sequence of data representations.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16-3](ch16.xhtml#ch16fig3)演示了这个函数如何适配到数据表示的序列中。'
- en: The final composition of transformations we might want to make is expressed
    by the function `solver` we wrote in the previous chapter. Unlike `statesPS` and
    `updatePS`, which require the `ParticleState` data type, the function `solver`
    works with any data type (any state space). If you look back on its definition,
    you will see that it is just the composition of a numerical method with iteration.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望进行的最终转换组合由我们在上一章中编写的`solver`函数表示。与`statesPS`和`updatePS`需要`ParticleState`数据类型不同，`solver`函数适用于任何数据类型（任何状态空间）。如果回顾它的定义，你会发现它只是一个数值方法与迭代的复合。
- en: 'We are now in a wonderful position. All we need to do to solve any one-body
    problem in mechanics is give the computer:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在处于一个极好的位置。要解决任何一个体力学问题，我们只需向计算机提供：
- en: A numerical method
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数值方法
- en: A list of one-body forces
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组单体力
- en: The body’s initial state
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物体的初始状态
- en: The computer will then calculate a list of states, which we can use to find
    quantities like position and velocity at arbitrary times.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，计算机会计算出一个状态列表，我们可以用它来在任意时刻找出诸如位置和速度等量。
- en: Putting everything together, we can write a function `positionPS`, similar to
    `positionFtxv` and others we have written before, that takes the three pieces
    of information listed above and produces a function that gives the position of
    the object at any time.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容结合起来，我们可以编写一个函数`positionPS`，类似于我们之前编写的`positionFtxv`和其他函数，它接受上述三个信息，并生成一个可以给出物体在任何时刻位置的函数。
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The function begins by naming the incoming numerical method `method`, the list
    of one-body forces `fs`, the initial particle state `st`, and the time `t`. The
    first line in the `let` clause uses `statesPS` to create an infinite list of particle
    states based on the numerical method, forces, and initial particle state given.
    The second line calculates the time step by subtracting the times of the first
    and second states in the list. The third line finds the number of time steps necessary
    to get as close as possible to the desired time `t`. The fourth line picks out
    the state that is closest to the desired time, and the body of the `let` construction,
    after the `in` keyword, uses the extraction function `posVec` to pick out the
    position from the state.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先定义传入的数值方法`method`、单体力的列表`fs`、初始粒子状态`st`和时间`t`。`let`子句中的第一行使用`statesPS`基于给定的数值方法、力和初始粒子状态创建一个无限的粒子状态列表。第二行通过减去列表中第一个和第二个状态的时间来计算时间步长。第三行找出为尽可能接近目标时间`t`所需的时间步数。第四行选出最接近目标时间的状态，而`let`构造体中的主体部分，在`in`关键字之后，使用提取函数`posVec`从状态中提取位置。
- en: Having written functions that allow us to solve any one-body mechanics problem
    using the numerical method of our choice, let’s turn our attention to some last
    details about animation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写了允许我们使用任意数值方法解决单体力学问题的函数之后，我们将注意力转向动画的一些最后细节。
- en: Preparing for Animation
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备动画
- en: In [Chapter 13](ch13.xhtml), we discussed how to make 2D and 3D animations with
    the `Graphics.Gloss` and `Vis` modules. Remember that each module has a `simulate`
    function, but the two functions are not parallel in terms of the inputs they require.
    In this section, we’ll ease future strain on our brains by creating two new functions,
    `simulateGloss` and `simulateVis`, that take very similar inputs to each other,
    so we can switch from 2D animation to 3D and back without having to remember all
    of the details about how the `gloss` `simulate` function differs from the `not-gloss`
    `simulate` function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](ch13.xhtml)中，我们讨论了如何使用`Graphics.Gloss`和`Vis`模块制作二维和三维动画。记住，每个模块都有一个`simulate`函数，但这两个函数在它们所要求的输入上并不相同。在本节中，我们通过创建两个新函数`simulateGloss`和`simulateVis`，使它们接受非常相似的输入，从而减少大脑的未来负担，这样我们就可以在二维动画和三维动画之间切换，而无需记住`gloss`的`simulate`函数与`非gloss`的`simulate`函数之间的所有细节。
- en: Two Helpful Animation Functions
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 两个有用的动画函数
- en: Each of the functions `simulateGloss` and `simulateVis` calls its own version
    of `simulate` to do the actual work. The intention is that we use these new functions
    instead of either version of `simulate`. We’ll briefly explain how `simulate`
    `Gloss` and `simulateVis` work; however, unlike many of the Haskell functions
    in this book, the point of writing these functions is not to illustrate important
    or beautiful ideas about physics or programming. Instead, the point is to make
    animation easier. We are willing to pay the cost of writing these functions once
    because we’ll then enjoy the benefit of being able to use them again and again
    to make animations in a more convenient way.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数`simulateGloss`和`simulateVis`都调用自己版本的`simulate`来完成实际的工作。我们的目的是使用这些新函数，而不是使用任何版本的`simulate`。我们将简要解释`simulate`、`Gloss`和`simulateVis`是如何工作的；然而，与本书中许多Haskell函数不同，编写这些函数的目的是为了让动画变得更简单，而不是为了展示关于物理或编程的重要或美丽的思想。我们愿意为编写这些函数付出一次性代价，因为这样我们就可以反复使用它们，更方便地制作动画。
- en: It’s more important to understand how to use these functions than it is to understand
    how they work. If you want to skip the definitions and the explanation of how
    the functions work, it will not cause you trouble later. However, do pay attention
    to the types of these two new functions and the inputs that must be provided for
    them to do their job.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用这些函数比理解它们是如何工作的更为重要。如果你想跳过函数的定义和它们的工作原理的解释，这对你后续不会造成困扰。然而，确实需要关注这两个新函数的类型，以及必须提供的输入，以使它们能够完成任务。
- en: 'Here are the type signatures and function definitions for `simulateGloss` and
    `simulateVis`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`simulateGloss`和`simulateVis`的类型签名和函数定义：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `simulateGloss` function makes a 2D animation, while `simulateVis` makes
    a 3D animation. Each function takes five inputs. The meaning and order of the
    inputs are the same in both functions, even though one of the five inputs has
    a different type in `simulateGloss` than it has in `simulateVis`. Let’s discuss
    the meaning and purpose of each of the five inputs.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`simulateGloss`函数生成2D动画，而`simulateVis`生成3D动画。每个函数都接受五个输入参数。虽然其中一个输入在`simulateGloss`中与`simulateVis`中有所不同，但这五个输入的含义和顺序是相同的。我们来讨论每个输入的含义和用途。'
- en: Time-Scale Factor
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 时间比例因子
- en: The first input to `simulateGloss` and `simulateVis`, `tsFactor`, says how fast
    we want the animation to run compared with physical evolution. There will be times
    when we want the animation to run faster or slower than the corresponding physical
    situation evolves. For example, it takes the moon about a month to orbit Earth,
    but we might want an animation in which the moon makes a full cycle in six seconds.
    We’re almost always going to want an animation that happens in seconds or minutes.
    Smaller than that and it’s too rapid to see; larger than that and we lose patience.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`simulateGloss`和`simulateVis`的第一个输入参数`tsFactor`表示我们希望动画相对于物理演化的运行速度。有时我们希望动画比对应的物理情况发展得更快或更慢。例如，月球绕地球一圈大约需要一个月，但我们可能希望动画中月球在六秒钟内完成一个完整的周期。我们几乎总是希望动画发生在秒或分钟级别。如果更短时间，变化太快看不清；如果更长时间，就会失去耐心。'
- en: We can distinguish between two forms of time. *Physical time* is the time for
    some process to occur in the physical world. The physical time for one period
    of the moon orbiting Earth is one month. *Animation time* is the time for some
    process to occur in a computer animation. The animation time for one period of
    the moon orbiting Earth is six seconds in our example.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分两种时间形式。*物理时间*是某个过程在物理世界中发生的时间。月球绕地球一圈的物理时间是一个月。*动画时间*是某个过程在计算机动画中发生的时间。在我们的示例中，月球绕地球一圈的动画时间是六秒。
- en: To allow a difference between physical time and animation time, our `simulateGloss`
    and `simulateVis` functions take a *time-scale factor* as their first input, hence
    the name `tsFactor`. The time-scale factor is the ratio of physical time to animation
    time. For the moon orbit example, where the physical time is much larger than
    the animation time, the time-scale factor is a number (much) bigger than 1\. A
    time-scale factor smaller than 1 should be used for a process that occurs very
    quickly in the physical world that we want to view in “slow motion” so we see
    interesting changes as they occur. By specifying a time-scale factor as the first
    input to `simulateGloss` or `simulateVis`, we are declaring how fast we want the
    animation to run compared with physical evolution.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分物理时间和动画时间，我们的`simulateGloss`和`simulateVis`函数将*时间比例因子*作为第一个输入参数，因此命名为`tsFactor`。时间比例因子是物理时间与动画时间的比率。在月球轨道示例中，物理时间远大于动画时间，因此时间比例因子是一个大于1的数字。对于在物理世界中发生得非常快、我们希望以“慢动作”方式查看的过程，应使用小于1的时间比例因子，以便在发生变化时看到有趣的变化。通过将时间比例因子作为第一个输入传递给`simulateGloss`或`simulateVis`，我们声明了希望动画与物理演化相比的运行速度。
- en: Animation Rate
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 动画速率
- en: The *animation rate*, called `rate` in the code shown earlier, is the number
    of picture frames displayed per second of animation time, and it’s the second
    input to `simulateGloss` and `simulateVis`. Because a new picture frame is generated
    every time the state-update function is called to produce a new state, the animation
    rate is also the number of state updates per second of animation time.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*动画速率*，在之前展示的代码中称为`rate`，是每秒钟显示的画面帧数，这是`simulateGloss`和`simulateVis`的第二个输入参数。由于每次调用状态更新函数以生成新的状态时，都会生成一个新的画面帧，因此动画速率也是每秒钟的状态更新次数。'
- en: There is a relationship between the time-scale factor, the animation rate, and
    the time step. If we let *α* denote the time-scale factor, *r* the animation rate,
    and Δ*t[p]* the time step (which is a physical time, hence subscript p), the relationship
    is
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 时间比例因子、动画速率和时间步长之间存在关系。如果我们让*α*表示时间比例因子，*r*表示动画速率，Δ*t[p]*表示时间步长（这是物理时间，因此下标为p），那么它们之间的关系为：
- en: '![Image](Images/298fig01.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/298fig01.jpg)'
- en: Only two of these can be chosen independently. Since the time step is a physical
    time, and since we are likely to be interested in situations with physical time
    scales ranging from nanoseconds to years, it’s convenient to tell `simulateGloss`
    or `simulateVis` the time-scale factor and the animation rate and let them calculate
    the time step to be used for state update. This way, if we choose a sensible time-scale
    factor, we can pick something like 20 frames/second for the animation rate and
    we’ll have a decent chance of using a reasonable time step. If we find we need
    a smaller time step, we can increase the animation rate (as we do in the next
    chapter for Halley’s comet).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些输入中只有两个可以独立选择。由于时间步长是物理时间，并且我们可能会关注从纳秒到年份的各种物理时间尺度，因此将时间尺度因子和动画速率告诉`simulateGloss`或`simulateVis`，并让它们计算用于状态更新的时间步长是很方便的。这样，如果我们选择了合适的时间尺度因子，我们可以选择每秒20帧的动画速率，并且有很大的机会使用合理的时间步长。如果我们发现需要更小的时间步长，我们可以提高动画速率（正如我们在下一章中对哈雷彗星的处理方式一样）。
- en: Initial State
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 初始状态
- en: The third input is the initial state of the particle or system we wish to animate,
    `initialState`. In this chapter, the state of a particle has the type `ParticleState`.
    In the previous chapter, the state of a particle in one dimension had type `State1D`.
    In [Chapter 19](ch19.xhtml), the state of a system of particles will have type
    `MultiParticleState`. Our two animation functions can work with any of these,
    as indicated by the type variable `s` used for the initial state.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个输入是我们希望动画化的粒子或系统的初始状态，`initialState`。在本章中，粒子的状态类型是`ParticleState`。在上一章中，单维粒子的状态类型是`State1D`。在[第19章](ch19.xhtml)中，粒子系统的状态类型将是`MultiParticleState`。我们的两个动画函数可以与这些类型中的任何一个配合使用，如初始状态中使用的类型变量`s`所示。
- en: Display Function
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 显示函数
- en: The fourth input, `picFunc`, is a display function that must explain what 2D
    or 3D picture to make for a given state. Since `gloss` uses the `Picture` type
    for a picture and `not-gloss` uses the `VisObject R` type, this fourth input has
    a different type in `simulateGloss` than in `simulateVis`. When we want to produce
    an animation for a specific physical situation, we’ll need to write a display
    function for that situation. The `not-gloss` package has its own type for three-dimensional
    vectors, which differs from the `Vec` type we have been using. Since there is
    a three-dimensional translation function called `Trans` that takes a `not-gloss`
    vector as input, it will be useful to have a conversion function around when we
    write the display function for a 3D animation. The function `v3FromVec` produces
    a `not-gloss` vector from a `Vec`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个输入，`picFunc`，是一个显示函数，它必须解释在给定状态下应该生成什么样的2D或3D图片。由于`gloss`使用`Picture`类型来表示图片，而`not-gloss`使用`VisObject
    R`类型，因此这个第四个输入在`simulateGloss`和`simulateVis`中的类型是不同的。当我们想为特定物理情况生成动画时，需要为该情况编写一个显示函数。`not-gloss`包有自己的三维向量类型，它与我们一直使用的`Vec`类型不同。由于有一个名为`Trans`的三维平移函数，它接受`not-gloss`向量作为输入，因此在为3D动画编写显示函数时，拥有一个转换函数是非常有用的。函数`v3FromVec`可以将一个`Vec`类型的向量转换为`not-gloss`向量。
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We’ll use this function in the 3D animations of projectile motion and of a proton
    in a magnetic field in the next chapter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章的3D动画中使用这个函数，包括抛体运动和质子在磁场中的运动。
- en: State-Update Function
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 状态更新函数
- en: The fifth and final input is a state-update function, `updateFunc`. State-update
    functions have been central to our method for solving Newton’s second law, even
    in the absence of animation. Notice that the type of the state-update function
    is `TimeStep -> s -> s`. This function must explain how to create a new state
    from an old state when given a time step. We are not choosing the time step here.
    Instead, we are specifying a function that takes a time step as input, along with
    an old state, and returns a new state. To obtain a state-update function, we can
    either apply a numerical method to a differential equation that comes from Newton’s
    second law or use the `updatePS` function we defined earlier with a numerical
    method and a list of one-body forces.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第五个也是最后一个输入是状态更新函数，`updateFunc`。状态更新函数是我们解牛顿第二定律方法的核心，即使在没有动画的情况下也是如此。请注意，状态更新函数的类型是`TimeStep
    -> s -> s`。这个函数必须解释如何通过给定时间步长从旧状态创建新状态。我们在这里并没有选择时间步长，而是指定了一个接受时间步长和旧状态作为输入并返回新状态的函数。为了得到状态更新函数，我们可以应用一个数值方法来求解来自牛顿第二定律的微分方程，或者使用我们之前定义的`updatePS`函数，该函数结合了数值方法和单体力的列表。
- en: The five inputs just discussed—the time-scale factor, animation rate, initial
    state, display function, and state-update function—contain everything about the
    physical situation we’re modeling as well as all the information about how to
    produce a picture as a function of time.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才讨论的五个输入——时间尺度因子、动画速率、初始状态、显示函数和状态更新函数——包含了我们所建模的物理情况的所有信息，并且也包含了关于如何生成随时间变化的画面的所有信息。
- en: Having discussed the inputs to the functions `simulateGloss` and `simulateVis`
    to make 2D and 3D animations, let’s look at how the functions work.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了`simulateGloss`和`simulateVis`函数的输入参数后，我们来看看这些函数是如何工作的，以生成二维和三维动画。
- en: How the Functions Work
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数的工作原理
- en: It is easier to understand how the `simulateGloss` function works, so we’ll
    start with that one. The `simulateGloss` function names the five inputs, `tsFactor`
    for the time-scale factor, and so on. It calls `gloss`’s `simulate` function to
    do the actual work, passing six arguments to that function. The first argument
    to `simulate` specifies an empty window name, a window size in pixels, and a window
    location. Since these parameters are not so interesting, and since we are unlikely
    to want to change these values from animation to animation, we have picked some
    values that we hope will work once and for all. The second argument to `simulate`
    is a background color, which we choose to be black. The third, fourth, and fifth
    inputs are the animation rate, initial state, and display function. These are
    all inputs to `simulateGloss`, so they can simply be passed along to `gloss`’s
    `simulate`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更容易理解`simulateGloss`函数的工作原理，因此我们从这个函数开始。`simulateGloss`函数命名了五个输入参数：`tsFactor`表示时间尺度因子，等等。它调用`gloss`的`simulate`函数来执行实际工作，并向该函数传递六个参数。传递给`simulate`的第一个参数指定了一个空的窗口名称、窗口大小（以像素为单位）和窗口位置。由于这些参数并不那么重要，而且我们不太可能希望在每个动画之间更改这些值，因此我们选择了一些希望能够一次性使用的值。传递给`simulate`的第二个参数是背景颜色，我们选择为黑色。第三、第四和第五个输入分别是动画速率、初始状态和显示函数。这些都是`simulateGloss`的输入，因此可以直接传递给`gloss`的`simulate`函数。
- en: The final input required by `gloss`’s `simulate` is an update function, but
    it differs from the state-update function we have been working with in three ways.
    First, `gloss`’s `simulate` expects an update function whose first argument is
    a `ViewPort`, which we do not intend to use. To give a place for the viewport,
    we write an anonymous function that throws away its first argument. Second, `gloss`’s
    `simulate` expects an update function that works with animation time rather than
    physical time. Since our update functions work with physical time, we need to
    do a conversion here using the time-scale factor. Third, we need to convert `R`
    to `Float` using `realToFrac`. In summary, our `simulateGloss` function works
    by providing inputs to `gloss`’s `simulate` function from the inputs given to
    `simulateGloss`. Two of the inputs to `gloss`’s `simulate` are simply specified,
    three are passed unchanged from inputs to `simulateGloss`, and one is a modification
    of a `simulateGloss` input.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`gloss`的`simulate`函数所需的最终输入是一个更新函数，但它与我们之前使用的状态更新函数在三个方面有所不同。首先，`gloss`的`simulate`期望一个更新函数，其第一个参数是`ViewPort`，而我们并不打算使用它。为了提供一个视口的位置，我们编写了一个匿名函数，它丢弃了第一个参数。第二，`gloss`的`simulate`期望一个基于动画时间而非物理时间的更新函数。由于我们的更新函数是基于物理时间的，因此我们需要使用时间尺度因子进行转换。第三，我们需要使用`realToFrac`将`R`转换为`Float`。总之，我们的`simulateGloss`函数通过将输入传递给`gloss`的`simulate`函数来工作，其中两个输入是直接指定的，三个输入从`simulateGloss`传递过去没有变化，最后一个是对`simulateGloss`输入的修改。'
- en: The `simulateVis` function gives the same names to its five inputs that `simulateGloss`
    uses because the inputs have the same meanings. It calls `not` `-gloss`’s `simulate`
    function to do the actual work, passing five arguments to that function. The first
    argument to `simulate` specifies some options, which we set, once and for all,
    to the default options. The second argument to `simulate` is the number of seconds
    per frame at which the animation should run. Since this is just the inverse of
    the animation rate, we can invert the `rate` after suitably changing its type
    from an integer to a real number. The third input is the initial state, which
    we pass along unchanged.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`simulateVis`函数为其五个输入参数赋予与`simulateGloss`相同的名称，因为这些输入参数具有相同的含义。它调用`not` `-gloss`的`simulate`函数来执行实际的工作，并将五个参数传递给该函数。传递给`simulate`的第一个参数指定了一些选项，我们将这些选项一劳永逸地设置为默认选项。传递给`simulate`的第二个参数是每帧动画运行的秒数。由于这只是动画速率的倒数，我们可以在适当将其类型从整数转换为实数后反转`rate`。第三个输入是初始状态，我们传递给它，保持不变。'
- en: The fourth input is the display function, which we could pass along unchanged,
    but we don’t because I want to take this opportunity to use the `orient` function,
    originally written in [Chapter 13](ch13.xhtml) and repeated below, to rotate the
    axes so that the y-axis points to the right, the z-axis points up the screen,
    and the x-axis points to the left and appears to extend out of the screen. In
    other words, I’m using `orient` so our animations will automatically use my favorite
    coordinate system.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个输入是显示函数，虽然我们本可以将其原样传递，但我们并没有这样做，因为我想借此机会使用`orient`函数，该函数最初写于[第13章](ch13.xhtml)，并在下面重复，用于旋转坐标轴，使得y轴指向右侧，z轴指向屏幕上方，x轴指向左侧并看起来延伸出屏幕。换句话说，我使用`orient`来使我们的动画自动使用我最喜欢的坐标系。
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The fifth and final input required by `not-gloss`’s `simulate` is an update
    function; however, it differs substantially from the state-update function `updateFunc`
    that we have to work with. Because the difference is so substantial, we use a
    `let` construction to define a local function `visUpdateFunc` that we will pass
    as the final input to `not-gloss`’s `simulate` function. We name the first `visUpdateFunc`
    input `ta` as a reminder that it represents animation time. We name the second
    `visUpdateFunc` input `st` for state. Our strategy is to use the `updateFunc`
    passed to `simulateVis` to calculate the value of `visUpdateFunc ta st`, which
    has type `s`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`not-gloss`的`simulate`所需的第五个也是最后一个输入是更新函数；然而，它与我们需要处理的状态更新函数`updateFunc`有着实质性的不同。由于这种差异非常大，我们使用`let`构造来定义一个局部函数`visUpdateFunc`，并将其作为最终输入传递给`not-gloss`的`simulate`函数。我们将第一个`visUpdateFunc`的输入命名为`ta`，以提醒它表示动画时间。我们将第二个`visUpdateFunc`的输入命名为`st`，表示状态。我们的策略是使用传递给`simulateVis`的`updateFunc`来计算`visUpdateFunc
    ta st`的值，该值的类型为`s`。'
- en: 'The difference between `visUpdateFunc` and `updateFunc` is all in how they
    interpret their first argument. The first input to `visUpdateFunc`, named `ta`,
    is the animation time elapsed since the beginning of the animation. In contrast,
    the first input to `updateFunc` is the physical time *step* since the previous
    state was calculated. Inside the local definition of `visUpdateFunc`, we have
    access to the animation time `ta` that we must use to calculate the physical time
    step `dtp` we will send to `updateFunc`. This conversion is more complicated than
    for `gloss` because we are really doing two conversions: one from animation time
    to physical time and one from physical time since the animation’s start to the
    physical time step. We use a nested `let` construction to define the local variable
    `dtp`, the physical time step we will send to `updateFunc` to produce the new
    state `visUpdateFunc ta st`. We calculate `dtp`, a real number with type `R`,
    by first converting the type of `ta` from `Float` to `R`, scaling this animation
    time by the time-scale factor to produce the physical time since the simulation
    began, and then subtracting the (physical) time of the old state. The physical
    time associated with state `st` is `timeOf st`. I explain how that works next.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`visUpdateFunc`和`updateFunc`的区别完全在于它们如何解释第一个参数。`visUpdateFunc`的第一个输入，名为`ta`，是从动画开始以来已经经过的动画时间。相比之下，`updateFunc`的第一个输入是从上一个状态计算后到当前状态的物理时间*步长*。在`visUpdateFunc`的局部定义中，我们可以访问动画时间`ta`，并利用它来计算我们将传递给`updateFunc`的物理时间步长`dtp`。这个转换比`gloss`的更为复杂，因为我们实际上进行的是两个转换：一个是从动画时间到物理时间，另一个是从动画开始的物理时间到物理时间步长。我们使用嵌套的`let`结构来定义局部变量`dtp`，即我们将传递给`updateFunc`以产生新状态`visUpdateFunc
    ta st`的物理时间步长。我们通过首先将`ta`的类型从`Float`转换为`R`，然后按时间尺度因子缩放该动画时间，得到自仿真开始以来的物理时间，最后减去旧状态的（物理）时间来计算`dtp`，一个类型为`R`的实数。与状态`st`相关的物理时间是`timeOf
    st`。接下来，我会解释这一如何运作。'
- en: 'We need to know the time (which is one of the state variables in `Particle`
    `State`) of a state. This would be no problem if `simulateVis` was intended to
    work only with the `ParticleState` data type. But we want `simulateVis` to be
    able to work with any state space `s`, or at least any state space `s` that contains
    time as a state variable. To solve this problem, it seems we must invent a new
    type class, called `HasTime`, for types that represent states from which a particular
    value of time can be extracted. The type class owns just one function, `timeOf`,
    which pulls the time out of the state. Here is the definition of the type class
    `HasTime`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要知道一个状态的时间（这是`Particle` `State`中的一个状态变量）。如果`simulateVis`只针对`ParticleState`数据类型工作，这不会成为问题。但我们希望`simulateVis`能够处理任何状态空间`s`，或者至少能够处理包含时间作为状态变量的状态空间`s`。为了解决这个问题，我们似乎必须发明一个新的类型类，叫做`HasTime`，用于表示能够提取特定时间值的状态类型。这个类型类只拥有一个函数`timeOf`，用于从状态中提取时间。以下是类型类`HasTime`的定义：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Each type that aspires to be an instance of `HasTime` must express how to implement
    `timeOf` through an instance declaration. Here is the instance declaration for
    `ParticleState`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型，若想成为`HasTime`的实例，必须通过实例声明表达如何实现`timeOf`。以下是`ParticleState`的实例声明：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In summary, our `simulateVis` function works by providing inputs to `not` `-gloss`’s
    `simulate` function from the inputs given to `simulateVis`. One of the inputs
    to `not-gloss`’s `simulate` is simply specified, two are passed unchanged from
    inputs to `simulateVis`, and two are modifications of `simulateVis` inputs.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们的`simulateVis`函数通过将输入传递给`not` `-gloss`的`simulate`函数来工作。`not-gloss`的`simulate`函数的输入之一是简单指定的，另外两个输入是从`simulateVis`的输入中直接传递过来的，最后两个输入是`simulateVis`输入的修改版本。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter applies Newtonian mechanics to a single object moving in three
    dimensions. Solving a mechanics problem is a process of transforming information
    through a sequence of four representations, starting with one-body forces, then
    a differential equation, then a state-update function, and finally a list of states.
    Newton’s second law appears in this process as the means to transform a list of
    forces acting on an object into a differential equation. A numerical method transforms
    a differential equation into a state-update function. We used the Euler-Cromer
    method and fourth-order Runge-Kutta method with appropriately chosen time steps
    as numerical methods in this chapter. A state-update function is an essential
    ingredient in an animation of motion.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将牛顿力学应用于三维空间中单个物体的运动。解决力学问题的过程是通过一系列四个表示来转换信息，首先是单体力，然后是一个微分方程，再是一个状态更新函数，最后是一个状态列表。在这个过程中，牛顿第二定律作为一种手段，将作用在物体上的力的列表转化为微分方程。数值方法将微分方程转化为状态更新函数。我们在本章中使用了欧拉-克罗梅方法和四阶龙格-库塔方法，并选择了合适的时间步长作为数值方法。状态更新函数是运动动画中的一个基本要素。
- en: The state-based paradigm remained central in this chapter, where we defined
    a new data type to hold the state of a particle. This new data type includes the
    particle’s mass and charge, as well as its position and velocity and the time.
    We introduced the notion of a one-body force, which became the main way we talked
    about forces in this chapter. In the next chapter, we apply these ideas to specific
    examples and animate many of our results.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本章仍然围绕基于状态的范式展开，在这一章中，我们定义了一种新的数据类型，用于存储粒子的状态。这个新数据类型包含粒子的质量、电荷、位置、速度以及时间。我们引入了单体力的概念，这也成为了我们在这一章讨论力的主要方式。在下一章中，我们将这些概念应用于具体的例子，并对许多结果进行动画演示。
- en: Exercises
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 习题
- en: '**Exercise 16.1.** Apply the function `newtonSecondPS` to a very simple list
    of forces, say the list of just a constant force, and a very simple state, say
    the `defaultParticleState`, and find the type of the resulting expression.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 16.1.** 将函数`newtonSecondPS`应用于一个非常简单的力列表，比如仅包含恒定力的列表，以及一个非常简单的状态，比如`defaultParticleState`，并找到结果表达式的类型。'
- en: '**Exercise 16.2.** Write a function'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 16.2.** 编写一个函数'
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: that takes a force vector as input and returns a `OneBodyForce` that will return
    the given constant force regardless of what state it is provided with. For example,
    if we use `constantForce` to make a one-body force that always produces 10![Image](Images/icap.jpg)
    N,
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个力向量作为输入，返回一个`OneBodyForce`，该力无论给定什么状态，都会返回相同的恒定力。例如，如果我们使用`constantForce`来创建一个始终产生10![Image](Images/icap.jpg)N的单体力，
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: then `tenNewtoniHatForce defaultParticleState` should produce `vec 10.0 0.0
    0.0`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`tenNewtoniHatForce defaultParticleState`应该产生`vec 10.0 0.0 0.0`。
- en: '**Exercise 16.3.** Write a function'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 16.3.** 编写一个函数'
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: that returns the gravitational force exerted by Earth’s moon on an object near
    the moon’s surface.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 返回地球月球对月球表面附近物体施加的引力。
- en: '**Exercise 16.4.** Write a one-body force for the universal gravity produced
    by Earth.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 16.4.** 编写一个表示地球产生的普遍引力的单体力。'
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Exercise 16.5.** Use the function `uniformLorentzForce` to find the direction
    of the force on a proton moving in the positive x-direction in a uniform magnetic
    field in the positive z-direction. There is no electric field. You can choose
    the speed of the proton and the magnitude of the magnetic field to be whatever
    you like. Given the direction of the force, what do you expect the subsequent
    motion of the proton to be?'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 16.5.** 使用函数`uniformLorentzForce`来找出在正z方向的均匀磁场中，沿正x方向运动的质子的力的方向。没有电场。你可以选择质子的速度和磁场的大小。根据力的方向，你预期质子接下来的运动是什么样的？'
- en: '**Exercise 16.6.** The tools we’ve developed in this chapter solve a mechanics
    problem by producing an infinite list of particle states. To make sense of that
    solution, we often want to extract some of the data and graph it. Suppose we wanted
    to plot the y-component of velocity as a function of time. We would want a list
    of pairs of (*t*, *v[y]*) values. Write a function'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 16.6.** 我们在本章中开发的工具通过生成粒子状态的无限列表来解决力学问题。为了理解这个解，我们通常希望提取一些数据并将其绘制成图。如果我们想绘制y分量速度随时间的变化曲线，我们需要一组(*t*,
    *v[y]*)值的对。编写一个函数'
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: that produces the desired pair of numbers from the state of one particle. Then
    write a function
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 生成所需的数字对，来自于一个粒子的状态。然后编写一个函数
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: that produces a list of numerical pairs from a list of states of one particle.
    You can use your `tvyPair` function in the body of this second function.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 它根据一个粒子的状态列表生成一对数值列表。你可以在第二个函数的主体中使用你的`tvyPair`函数。
- en: '**Exercise 16.7.** Write a predicate'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 16.7.** 编写一个谓词'
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: that returns `True` if the time contained in the state (assumed to be a number
    of seconds) is less than or equal to one year and returns `False` otherwise. This
    predicate could be used with `takeWhile` to transform an infinite list of states
    into a finite list in preparation for making a graph.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回`True`，如果状态中的时间（假设是秒数）小于或等于一年，否则返回`False`。这个谓词可以与`takeWhile`一起使用，将无限状态列表转换为有限列表，以便绘制图形。
- en: '**Exercise 16.8.** Write a function'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 16.8.** 编写一个函数'
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: that produces a function from time to particle state when given a list of states.
    Assume that the times between adjacent states are all the same.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 它根据给定的状态列表生成一个从时间到粒子状态的函数。假设相邻状态之间的时间间隔相同。
- en: '**Exercise 16.9.** In all of our work with air resistance so far, we have assumed
    the density of air to be a constant. However, the density of air near Earth’s
    surface actually decreases with altitude. A useful approximation for how air density
    changes with altitude is given by'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 16.9.** 在我们迄今为止的所有空气阻力的研究中，我们假设空气的密度是常数。然而，靠近地球表面的空气密度实际上随着高度的增加而减少。一个有用的近似公式来表示空气密度随高度的变化是'
- en: '*ρ* = *ρ*0*e*^(–*h*/*h*[0])'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*ρ* = *ρ*0*e*^(–*h*/*h*[0])'
- en: where *ρ*[0] is the air density at sea level, *h* is the distance above sea
    level, *ρ* is the air density at height *h* above sea level, and *h*[0] is a constant.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*ρ*[0]是海平面上的空气密度，*h*是海平面以上的高度，*ρ*是海拔高度*h*处的空气密度，*h*[0]是一个常数。
- en: Taking *h*[0] = 8,500 meters and using the z-component of position for height
    above sea level, write a one-body force
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 取*h*[0] = 8,500米，并使用位置的z分量表示海拔高度，编写一个单体力学模型
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'that can be used instead of `airResistance` for situations in which an object
    finds itself at high altitude. To test this new function, the following function
    compares the range of a lead ball fired from sea level with some initial velocity
    at some angle under three different conditions: (a) no air resistance, (b) uniform
    air resistance, and (c) air resistance that varies with altitude. The diameter
    of the lead ball is 10 cm. Supply the initial state and the final line of code
    (the two places marked `undefined`), and then use the code to see the ranges for
    a ball fired at 45^∘. Try initial speeds of 10 m/s, 100 m/s, and 300 m/s.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以代替`airResistance`在物体处于高海拔时使用。为了测试这个新函数，以下函数比较了从海平面发射的铅球在三种不同条件下的射程：（a）无空气阻力，（b）均匀空气阻力，以及（c）随着高度变化的空气阻力。铅球的直径是10厘米。提供初始状态和代码中的最后一行（标记为`undefined`的两处），然后使用代码查看45^∘角度发射的铅球射程。尝试初始速度为10
    m/s、100 m/s和300 m/s的情况。
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Exercise 16.10.** Consider dropping a ball from a height of 10 meters near
    Earth’s surface. Use the functions we defined in this chapter to write a function
    that produces a list of particle states for this motion. Extra credit if you can
    use the `takeWhile` function to extract the particle states with *z* ≥ 0 (those
    in which the ball is still at or above Earth’s surface) from the infinite list.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 16.10.** 考虑从10米高处自由落体的铅球，靠近地球表面。使用我们在本章定义的函数编写一个函数，生成此运动的粒子状态列表。如果你能使用`takeWhile`函数提取*z*
    ≥ 0的粒子状态（即球体仍然处于地球表面或以上的状态），则可以获得额外的学分。'
