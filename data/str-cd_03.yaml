- en: '2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '2'
- en: THE ESSENTIALS OF PROGRAMMING LANGUAGES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言的基本概念
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common01.jpg)'
- en: Attempting to compress the essentials of programming languages into a single
    chapter is an impossible task, but I’ll do my best to convey what is essential
    about programming languages as background for the rest of the book. In reality
    though, this chapter should be either a book or a semester-long undergraduate
    course.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 试图将编程语言的基本概念压缩到一个章节中是一项不可能完成的任务，但我会尽力传达编程语言的核心要素，为本书的其余部分提供背景。不过，实际上，这一章应该是一本书或一个学期的本科课程。
- en: The vignettes of [Chapter 1](ch01.xhtml#ch01) were meant to give you an introduction
    to a few programming language concepts, but they left some big questions unanswered.
    For example, what exactly *is* a programming language? How are programming languages
    structured and implemented? What are programming paradigms? And so on. Potential
    questions abound. In this chapter, I’ll provide sufficient answers to these questions,
    and others, to give us what we need to work through the languages we’ll encounter
    and implement later in the book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](ch01.xhtml#ch01)中的小插曲旨在向你介绍一些编程语言的概念，但它们留下了一些重要的问题没有解答。例如，什么才是真正的*编程语言*？编程语言是如何结构化和实现的？编程范式是什么？等等，潜在的问题有很多。在这一章中，我将为这些问题提供足够的答案，以及其他问题，为我们后续处理本书中将遇到的编程语言和实现打下基础。'
- en: We’ll begin this chapter with a working definition of *programming language*.
    Then we’ll cover syntax and semantics—how to speak in a programming language and
    what the speech means. After that, we’ll briefly review the ways programming languages
    are implemented, or made real. We’ll implement several esolangs in this book,
    so basic knowledge in this area will be useful.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将以对*编程语言*的工作定义开始。接着我们将讨论语法和语义——如何在编程语言中表达以及这些表达的意义。之后，我们将简要回顾编程语言是如何实现的，或者说是如何被“具象化”的。在本书中，我们将实现几种极简语言，因此在这方面的基本知识将会非常有用。
- en: We’ll then explore data types and data structures, what sort of data the language
    works with, and how it organizes that data. We’ll also explore variables and *scope*,
    which is the part of the language telling us what information can be seen and
    in what context.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将探讨数据类型和数据结构，编程语言所操作的数据类型是什么，以及它是如何组织这些数据的。我们还将探讨变量和*作用域*，即语言中告知我们哪些信息可以被访问以及在哪些上下文中可见的部分。
- en: All programming languages implement some form of *flow control*, that is, some
    way to do more than execute instruction after instruction in a linear fashion.
    We’ll explore that before ending the chapter with a discussion of *programming
    language paradigms*, or the different ways programming languages approach coding.
    We encountered several different programming paradigms in [Chapter 1](ch01.xhtml#ch01).
    Here, we’ll put names to the paradigms and discuss their characteristics. The
    paradigm, or paradigms, a language supports directly influence how we think in
    that language.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所有编程语言都实现某种形式的*流程控制*，也就是以某种方式执行指令，而不仅仅是按顺序一条一条地执行。我们将在本章结束时探讨这一点，并讨论*编程语言范式*，即编程语言对编程的不同处理方式。在[第1章](ch01.xhtml#ch01)中，我们已经遇到了一些不同的编程范式。在这里，我们将给这些范式命名，并讨论它们的特点。编程语言所支持的范式直接影响我们如何在该语言中进行思考。
- en: '**Defining Programming Language**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**定义编程语言**'
- en: A book about programming languages should include a definition of its subject.
    Therefore, let’s be explicit about what we mean when we write the words *programming
    language*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一本关于编程语言的书应当包括对其主题的定义。因此，让我们明确一下，当我们说*编程语言*时，我们指的是什么。
- en: 'A programming language is a vehicle that expresses thought and actualizes it
    as an algorithm to control a computer. A programming language consists of two
    things: *a set of instructions* and *rules for organizing those instructions*.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言是一种表达思想并将其转化为控制计算机的算法的工具。编程语言由两部分组成：*一组指令*和*组织这些指令的规则*。
- en: 'All of the languages in [Chapter 1](ch01.xhtml#ch01) meet our definition. Clearly,
    Short Code and everything created after it does: there are instructions and rules
    for organizing those instructions. Zuse’s Plankalkül and even Ada’s “diagram of
    development” meet this definition. Ada’s diagram encodes an algorithm in a manner
    useful for the Analytical Engine. Some might quibble that the Analytical Engine
    would not have been able to use the diagram directly, but a modern computer can’t
    use C, ALGOL, or Prolog source code directly, either. A programming language is
    abstract; it needs an interface between itself and the machine it seeks to control.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](ch01.xhtml#ch01)中的所有语言都符合我们的定义。显然，Short Code及其之后创建的所有内容都符合这一点：它们有指令和组织这些指令的规则。Zuse的Plankalkül，甚至Ada的“开发图”也符合这一定义。Ada的图以一种对分析引擎有用的方式编码了一个算法。有人可能会争辩，分析引擎不可能直接使用这个图，但现代计算机也无法直接使用C、ALGOL或Prolog源代码。编程语言是抽象的；它需要与其所控制的机器之间的接口。'
- en: '**Syntax and Semantics**'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**语法与语义**'
- en: '*Syntax* refers to how language elements can be combined to form valid statements
    in the grammar of a language. This is true for both human languages and programming
    languages. Most programming languages intended for real-world use have a formal
    grammar, that is, a specification of what is and isn’t allowed as a statement
    in the language. These grammars guide the development of interpreters and compilers
    for the language.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*语法*指的是语言元素如何结合在一起形成语法上有效的语句。这对于人类语言和编程语言都是适用的。大多数为实际应用设计的编程语言都有一个正式的语法，也就是规定语言中允许和不允许作为语句的内容。这些语法指导着该语言的解释器和编译器的开发。'
- en: The word *semantics* refers to the meaning of a syntactically correct statement.
    Syntax is concrete; a statement either is or isn’t valid for the language. Semantics,
    on the other hand, is harder to pin down; it depends on what the programmer (speaker)
    intends, which may differ from the effective meaning. In a human language context,
    this is a misunderstanding; in a programming language context, this is often a
    bug.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*语义*一词指的是语法上正确的语句的含义。语法是具体的；一个语句要么是有效的，要么不是有效的。另一方面，语义更难确定；它取决于程序员（说话者）的意图，这可能与实际含义不同。在人类语言的上下文中，这通常是误解；在编程语言的上下文中，这通常是一个bug。'
- en: 'To help understand the difference between syntax and semantics, let’s consider
    a `while` statement in Pascal:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助理解语法和语义之间的区别，假设我们看一个Pascal中的`while`语句：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is an expression of the `while` statement’s syntax. Pascal’s formal grammar
    must define <boolean-expression> and <statements>. A <boolean-expression> is an
    expression that returns a value that is true or false and <statements> is a single
    statement or a sequence of statements with `begin` and `end` around them (a block
    statement).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`while`语句语法的一个表达。Pascal的正式语法必须定义<boolean-expression>和<statements>。<boolean-expression>是一个返回真或假的值的表达式，而<statements>是一个单一的语句或一系列语句，且这些语句被`begin`和`end`括起来（即块语句）。
- en: 'Therefore, syntactically, this is a correct Pascal statement:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从语法上讲，这是一个正确的Pascal语句：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, semantically, this statement is unlikely to be correct. Its meaning
    is likely not what the programmer intended. If `i` is greater than or equal to
    10, the `while` loop never executes because the condition is false. If `i` is
    less than 10, the `while` loop does execute, but would never end because `i` is
    less than 10 and is only getting smaller. In practice, the `while` loop will eventually
    end when `i` wraps around from the largest negative to the largest positive supported
    by the integer data type. In Pascal, the largest negative integer is *–*32,768
    and the largest positive is 32,767\. In Pascal, an integer is signed and 16 bits
    wide. This statement is, at best, a highly inefficient way to do `i := 32767`,
    and is likely not at all what the programmer intended.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从语义上讲，这个语句可能并不正确。它的含义可能并不是程序员所期望的。如果`i`大于或等于10，`while`循环永远不会执行，因为条件为假。如果`i`小于10，`while`循环会执行，但永远不会结束，因为`i`小于10并且只会越来越小。实际上，当`i`从整数数据类型支持的最大负数绕回到最大正数时，`while`循环最终会结束。在Pascal中，最大负整数是*–*32,768，最大正整数是32,767。在Pascal中，整数是有符号的，并且是16位宽的。这个语句，充其量，只是一个非常低效的方式来执行`i
    := 32767`，并且很可能根本不是程序员的意图。
- en: 'Remember: syntax refers to grammatically correct statements and semantics refers
    to the meaning of a statement.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：语法指的是语法上正确的语句，而语义指的是语句的含义。
- en: '**Implementing Programming Languages**'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实现编程语言**'
- en: Konrad Zuse’s Plankalkül was a programming language, but he didn’t implement
    it. Zuse expressed thought through it, but he couldn’t actualize the thought encoded
    because there was no interface, that is, no implementation of the language for
    a physical machine. Programming languages can exist without a computer to run
    them, but to control a machine, there must be an implementation. In this section,
    we’ll discuss the ways programming languages are implemented.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 康拉德·祖泽的Plankalkül是一种编程语言，但他并没有实现它。祖泽通过它表达思想，但他无法将编码的思想转化为实际操作，因为没有接口，也就是没有为物理机器实现该语言。编程语言可以在没有计算机执行的情况下存在，但要控制机器，必须有一个实现。在这一部分，我们将讨论编程语言是如何实现的。
- en: There are two main methods for implementing a programming language. An *interpreter*
    takes the program text, breaks it up into pieces called statements—that is, sets
    of instructions with meaning—and performs the actions implied by the instructions.
    On the other hand, a *compiler* takes the program text, breaks it up into pieces
    with meaning, and translates those pieces into another language, often the computer’s
    machine language.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实现编程语言有两种主要方法。*解释器*将程序文本分解为称为语句的部分——即具有含义的指令集——并执行指令所暗示的操作。另一方面，*编译器*将程序文本分解为具有含义的部分，并将这些部分翻译成另一种语言，通常是计算机的机器语言。
- en: The output of a compiler is a set of machine instructions that the computer
    can execute directly. Compilers are programs that translate one programming language
    into another. Interpreters are programs that implement the meaning of the instructions
    implied by the program text.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器的输出是一组计算机可以直接执行的机器指令。编译器是将一种编程语言翻译成另一种编程语言的程序。解释器是实现程序文本所隐含指令意义的程序。
- en: Interpreters are like work crews. They get the work order and make it happen.
    Compilers are like translators. They map meaning from one programming language
    to another. Interpreters run programs; compilers produce programs to run later.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器就像工作队伍。它们接到工作指令并付诸实施。编译器则像翻译员，它们将一种编程语言的含义映射到另一种编程语言上。解释器运行程序；编译器生成程序，以便稍后运行。
- en: 'There is a clear conceptual break between what an interpreter does and what
    a compiler does. Unfortunately, in practice, this line isn’t as distinct as we
    might hope. For example, many new languages are both interpreted and compiled
    at the same time. This includes Python and Java, among others. There is a good
    reason for this: namely, portability between different hardware platforms. Languages
    that do this make use of *bytecode compilers*, which are compilers that translate
    from the high-level source language (like Python) to a low-level target language
    that can be interpreted very quickly. The compiler portion does the hard work
    of extracting the meaning of the program text while the interpreter concentrates
    on performance. The net result is a language implementation that is portable—just
    rewrite the interpreter part for a new target machine—and much faster than an
    old-style interpreter that mindlessly re-derived the meaning of the code, over
    and over, as it was executed.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器和编译器之间有一个清晰的概念性区别。不幸的是，在实践中，这条界线并不像我们希望的那样明确。例如，许多新语言同时既被解释又被编译。这包括Python和Java等语言。这背后有一个很好的理由：即不同硬件平台之间的可移植性。实现这一点的语言使用*字节码编译器*，这是一种将高级源语言（如Python）翻译成低级目标语言的编译器，该目标语言可以非常快速地被解释。编译器部分完成了提取程序文本含义的繁重工作，而解释器则专注于性能。最终的结果是，一个既可移植又比传统解释器快得多的语言实现——只需要为新的目标机器重写解释器部分，而不必像旧式解释器那样一次又一次地无意义地重新推导代码的含义。
- en: '***Tokens, Lexers, and Parsers***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***词法分析器、词法单元和解析器***'
- en: Neither interpreters nor compilers work with source code text as typed. The
    text is first processed by a *lexer* to split the text into *tokens*, which are
    strings representing the elements of the programming language. The lexer often
    attaches extra information to the tokens, such as whether the token is a number
    or a keyword of the language.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是解释器还是编译器，都不会直接处理键入的源代码文本。文本首先通过*词法分析器*进行处理，将文本分割成*词法单元*，这些词法单元是代表编程语言元素的字符串。词法分析器通常会为词法单元附加额外的信息，例如该词法单元是否是数字或语言的关键字。
- en: The output of the lexer is usually passed to a *parser*, which groups the tokens
    into meaningful language statements, often in the form of a tree. The interpreter
    or compiler then uses that tree to evaluate the statement (interpreter) or transform
    the statement into the target language (compiler).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 词法分析器的输出通常会传递给*语法分析器*，语法分析器将标记（tokens）分组为有意义的语言语句，通常以树的形式表示。然后，解释器或编译器使用这棵树来评估语句（解释器）或将语句转换成目标语言（编译器）。
- en: 'For example, consider this Pascal statement:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下Pascal语句：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The lexer splits the statement into tokens and then adds the associated information.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 词法分析器将语句分解成标记（tokens），然后添加相关的信息。
- en: '| **Token** | **Associated information** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **标记** | **相关信息** |'
- en: '| --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `y` | Variable, type real |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `y` | 变量，实数类型 |'
- en: '| `:=` | Assignment |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `:=` | 赋值 |'
- en: '| m | Variable, type real |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| m | 变量，实数类型 |'
- en: '| `*` | Multiplication |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 乘法 |'
- en: '| × | Variable, type real |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| × | 变量，实数类型 |'
- en: '| `+` | Addition |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 加法 |'
- en: '| b | Variable, type real |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| b | 变量，实数类型 |'
- en: '| `;` | End of statement |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `;` | 语句结束 |'
- en: The parser uses this to construct an *abstract syntax tree* (see [Figure 2-1](ch02.xhtml#ch02fig1)).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器使用这个符号来构造一个*抽象语法树*（见[图2-1](ch02.xhtml#ch02fig1)）。
- en: '![Image](Images/02fig01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/02fig01.jpg)'
- en: '*Figure 2-1: An abstract syntax tree for y := m*x + b*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-1：y := m*x + b的抽象语法树*'
- en: The tree is a representation of the statement in a form the interpreter or compiler
    can process. An interpreter would evaluate the right side of the tree using the
    current value of the variables `m`, `x`, and `b` to assign a new value to the
    variable `y`. A compiler would use the tree to generate a series of assembly language
    or machine code instructions that, when executed, implement the assignment.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 树是以解释器或编译器可以处理的形式表示语句。解释器会使用当前的`m`、`x`和`b`变量的值来评估树的右侧，从而为变量`y`赋予一个新值。编译器则使用树来生成一系列汇编语言或机器代码指令，执行这些指令时会实现赋值操作。
- en: Lexers and parsers for real programming languages can be quite complex. Most
    people use parser generators like flex/bison or ANTLR to automatically generate
    code from the language specifications. Fortunately for us, the esolangs we’ll
    explore are often so simple that lexing is removing whitespace and comments and
    parsing is examining the next character in the string output by the lexer. For
    example, this is precisely how the ABC language of [Chapter 7](ch07.xhtml#ch07)
    is processed by its interpreter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于真实的编程语言，词法分析器和语法分析器可能相当复杂。大多数人使用像flex/bison或ANTLR这样的语法分析器生成器，自动从语言规范生成代码。幸运的是，我们将探索的内存语言通常非常简单，词法分析仅仅是去除空白符和注释，语法分析则是检查词法分析器输出字符串中的下一个字符。例如，这正是[第7章](ch07.xhtml#ch07)中ABC语言的解释器处理方式。
- en: '***Interpreters***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***解释器***'
- en: Interpreters are usually easier to write than compilers. Computer scientists
    spent decades learning how to write optimizing compilers that produce highly efficient
    and fast code. The downside of an interpreter is that it’s often slow compared
    to the machine code generated by a compiler. All of the esolangs we’ll work with
    in this book are interpreted, though compilers do exist for some of them (for
    example Brainfuck; see *[https://github.com/Wilfred/bfc/](https://github.com/Wilfred/bfc/)*).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器通常比编译器更容易编写。计算机科学家花费了几十年时间学习如何编写优化编译器，以生成高效且快速的代码。解释器的缺点是，它通常比编译器生成的机器代码要慢。尽管如此，本书中我们将使用的所有内存语言都是解释型的，尽管有些语言（例如Brainfuck）也有编译器（见*[https://github.com/Wilfred/bfc/](https://github.com/Wilfred/bfc/)*）。
- en: Later in the book, we’ll write interpreters in Python for simple esolangs like
    ABC, FRACTRAN, Filska, and Firefly. By design, their syntax is simple enough that
    complex lexing and parsing are not necessary.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面，我们将用Python编写解释器，用于处理简单的内存语言（esolang），例如ABC、FRACTRAN、Filska和Firefly。这些语言的设计使得它们的语法足够简单，不需要复杂的词法分析和语法分析。
- en: A complete example of an interpreter, with a specified language grammar and
    a complete lexer and parser, is beyond what we can present here. However, I do
    recommend attempting to do that yourself at some point. If you do, think clearly
    and be prepared for some level of frustration before you succeed. For now, let’s
    look at what an old BASIC interpreter does to parse a simple program.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的解释器示例，包括指定的语言语法、完整的词法分析器和语法分析器，超出了我们在这里所能展示的内容。不过，我确实建议你在某个时候尝试自己动手做。如果你这么做了，请清晰地思考，并做好在成功之前遇到一些挫折的准备。目前，让我们来看一下一个旧的BASIC解释器是如何解析一个简单程序的。
- en: The Apple II computer came with BASIC in ROM. BASIC was both the command line
    and the programming language of the machine. Users entered a line of the program,
    which BASIC immediately parsed and stored in memory. Programs were stored in memory
    as a linked list, which is why every line needed a line number. It was so BASIC
    knew where to insert the line in the list.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Apple II计算机配备了ROM中的BASIC。BASIC既是机器的命令行，也是编程语言。用户输入一行程序，BASIC立即解析并存储在内存中。程序以链表的形式存储在内存中，这就是为什么每一行都需要一个行号的原因。这样BASIC才能知道将该行插入链表中的位置。
- en: 'Consider this simple program entered line by line at the prompt (`]`):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个简单的程序，它是通过提示符（`]`）逐行输入的：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If this program is `RUN`, it produces a table of squares.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个程序是`RUN`，它将生成一个平方数表。
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The tokenized representation of this program occupies 30 bytes of the Apple
    II’s memory ([Listing 2-1](ch02.xhtml#ch02list1)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的标记化表示占用Apple II内存中的30个字节（[清单 2-1](ch02.xhtml#ch02list1)）。
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 2-1: A tokenized Applesoft BASIC program*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-1：一个标记化的Applesoft BASIC程序*'
- en: 'The program begins at memory location 0x0801, with the link to the next line
    beginning at 0x080D. The line number is stored as a 16-bit unsigned integer, with
    the low-order byte first: `0A 00` = 0 × 256 + 10 = 10\. The parsed line of code
    comes next, where known BASIC commands like `FOR` have been replaced by a single-byte
    token (0x81). Interestingly, the numbers, like 1 and 10 for the `FOR` loop limits,
    are not stored as numbers but rather as ASCII characters. The `PRINT` statement
    is also stored as ASCII characters, including the name of the variable, `X`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 程序从内存位置0x0801开始，下一行的链接从0x080D开始。行号以16位无符号整数存储，低字节在前：`0A 00` = 0 × 256 + 10 =
    10。接下来是解析后的代码行，其中已知的BASIC命令如`FOR`被替换为单字节的标记（0x81）。有趣的是，像1和10这样的数字（用于`FOR`循环的限制）并不是以数字形式存储的，而是作为ASCII字符存储的。`PRINT`语句也以ASCII字符存储，包括变量名`X`。
- en: BASIC must do a significant amount of work to interpret a line, and do so repeatedly
    in this case because a loop is involved. Because of this, BASIC was notoriously
    slow. However, to be fair, the Apple II’s BASIC interpreter was written in assembly
    language for a simple 8-bit microprocessor to run on a machine with as little
    as 16KB of RAM. We’ll use Python to implement our languages, so our task will
    be significantly easier and proportionately less impressive.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: BASIC必须进行大量工作来解释每一行，且在此过程中需要重复执行，因为涉及了循环。因此，BASIC的执行速度较慢。不过，公平地说，Apple II的BASIC解释器是为一个简单的8位微处理器用汇编语言编写的，这台机器的RAM最低只有16KB。我们将使用Python来实现我们的语言，因此我们的任务将会轻松得多，相应地也不会那么令人印象深刻。
- en: '***Compilers***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编译器***'
- en: 'One of the best books about compilers is the classic “Dragon Book” by Aho,
    Lam, Sethi, and Ullman: *Compilers: Principles, Techniques, and Tools*, 2nd edition
    (Addison Wesley, 2006). It’s called the Dragon Book because of the cover illustration.
    If you are at all curious about compiler design, I recommend this book.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '关于编译器的最佳书籍之一是Aho、Lam、Sethi和Ullman的经典之作《龙书》：*Compilers: Principles, Techniques,
    and Tools*（第二版，Addison Wesley，2006）。之所以称为“龙书”，是因为封面插图的缘故。如果你对编译器设计有任何好奇，我推荐这本书。'
- en: 'Section 1.2 of the Dragon Book enumerates the phases of a compiler:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 《龙书》第1.2节列出了编译器的各个阶段：
- en: Lexical analyzer
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 词法分析器
- en: Syntax analyzer
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语法分析器
- en: Semantic analyzer
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语义分析器
- en: Intermediate code generator
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中间代码生成器
- en: Code optimizer
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码优化器
- en: Code generator
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码生成器
- en: Interpreters perform at least phases 1 through 3, and possibly some form of
    phase 4, and then execute the program. Compilers perform all or most of the phases
    to produce machine code output.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器至少执行第1到第3阶段，可能还会执行某种形式的第4阶段，然后执行程序。编译器则执行所有或大部分阶段，以生成机器代码输出。
- en: Let’s look at the code produced by a simple compiler called `pic0`. It compiles
    a simple stack-based language to assembly code for Microchip 10F2xx series microcontrollers.
    The 10F2xx series are perhaps the cheapest microcontrollers on the market. As
    of this writing, a single 10F200 can be yours for a mere 0.66 USD.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看由一个简单的编译器`pic0`生成的代码。它将一个简单的基于栈的语言编译成Microchip 10F2xx系列微控制器的汇编代码。10F2xx系列可能是市场上最便宜的微控制器。截至本文写作时，一颗10F200仅售0.66美元。
- en: The compiler is in the file *pic0.py*, and implements phases 1 through 5 above.
    Phase 6, final code generation, uses the `gpasm` assembler (see *[https://gputils.sourceforge.io/](https://gputils.sourceforge.io/)*).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器位于文件*pic0.py*中，执行上述第1到第5阶段。第6阶段，最终的代码生成，使用`gpasm`汇编器（请参见* [https://gputils.sourceforge.io/](https://gputils.sourceforge.io/)
    *）。
- en: The file *timer.pic0* ([Listing 2-2](ch02.xhtml#ch02list2)) contains a PIC0
    program to toggle an LED attached to the microcontroller.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 *timer.pic0* ([清单 2-2](ch02.xhtml#ch02list2)) 包含一个 PIC0 程序，用于切换附加到微控制器上的
    LED。
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 2-2: A PIC0 program to toggle an LED*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-2：一个切换 LED 的 PIC0 程序*'
- en: 'The compiler takes this file as input producing *timer.asm* as output ([Listing
    2-3](ch02.xhtml#ch02list3)). For the final compilation phase, `gpasm` takes *timer.asm*
    as input to produce several output files: *timer.cod*, *timer.lst*, and *timer.hex*.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将此文件作为输入，输出 *timer.asm*（[清单 2-3](ch02.xhtml#ch02list3)）。在最终的编译阶段，`gpasm`
    以 *timer.asm* 为输入，生成多个输出文件：*timer.cod*、*timer.lst* 和 *timer.hex*。
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 2-3: PIC0 compiler output*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-3：PIC0 编译器输出*'
- en: The file *timer.hex* contains code actually loaded onto the microcontroller.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 *timer.hex* 包含实际加载到微控制器上的代码。
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Listing 2-2](ch02.xhtml#ch02list2) may seem somewhat cryptic, but it’s likely
    more readable than [Listing 2-3](ch02.xhtml#ch02list3) even though both programs
    achieve the same goal. To learn more about PIC0, see *PIC0_Manual.pdf* in the
    same directory as *timer.pic0*.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-2](ch02.xhtml#ch02list2) 可能看起来有些晦涩，但它可能比 [清单 2-3](ch02.xhtml#ch02list3)
    更易读，尽管两个程序实现了相同的目标。要了解更多关于 PIC0 的信息，请参阅与 *timer.pic0* 位于同一目录下的 *PIC0_Manual.pdf*。'
- en: '***Bytecode Compilers***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字节码编译器***'
- en: 'Modern interpreters blur the line between interpreter and compiler by compiling
    the high-level language to a low-level language that can be interpreted quickly.
    In essence, these languages produce code for a machine that doesn’t exist: a machine
    simulated via an interpreter. To muddy the waters still further, some bytecode
    compilers perform *just-in-time compilation* (JIT) to produce actual machine code
    instead of interpreting the bytecode itself. Do we still call those languages
    interpreted?'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现代解释器模糊了解释器和编译器之间的界限，通过将高级语言编译为可以快速解释的低级语言。从本质上讲，这些语言为一个不存在的机器生成代码：一个通过解释器模拟的机器。为了进一步混淆，有些字节码编译器执行
    *即时编译*（JIT），生成实际的机器代码，而不是直接解释字节码。我们还会称这些语言为解释型语言吗？
- en: Bytecode compilers are not new, though they may not have been called that at
    first. For example, the UCSD Pascal system used in the late 1970s produced *p-code*,
    a bytecode that was then interpreted by programs written for a specific system.
    This made the output portable as only the interpreter needed to be rewritten for
    a new system. The Pascal system, including the compiler, was written in Pascal
    and already compiled to p-code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码编译器并不新鲜，尽管最初它们可能并不被称为字节码编译器。例如，1970年代末期使用的 UCSD Pascal 系统生成了 *p-code*，一种字节码，之后通过为特定系统编写的程序进行解释。这使得输出变得可移植，因为只有解释器需要为新系统重写。Pascal
    系统，包括编译器，都是用 Pascal 编写的，并且已经编译成了 p-code。
- en: 'As mentioned above, Python is also bytecode compiled. Python supplies a module,
    `dis`, showing us the bytecode for any function. For example, this function generates
    factorials recursively:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，Python 也是字节码编译的。Python 提供了一个模块 `dis`，可以显示任何函数的字节码。例如，这个函数递归地生成阶乘：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To see the bytecode Python actually runs, we can add
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Python 实际运行的字节码，我们可以添加
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This produces
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Again, even without studying the meaning of each part of the disassembly, we
    can follow the flow of the function by examining the tokens on the far right and
    the names of the instructions in the middle. For example, `POP_JUMP_IF_FALSE`
    must examine the result of applying `==`, and if not true, jumps to 12, which
    clearly implements the `else` portion of the function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不研究拆解中每一部分的含义，我们也可以通过检查最右边的标记和中间的指令名称来跟随函数的流程。例如，`POP_JUMP_IF_FALSE` 必须检查应用
    `==` 的结果，如果结果为假，则跳转到12，这清楚地实现了函数的 `else` 部分。
- en: Notice the final two lines of the disassembly? They return `None`, which is
    the default value Python returns from a function. To us, it is obvious that the
    function never ends by exiting the `if`, as both branches use `return`, but the
    Python compiler must not detect this, so it adds code to handle leaving the function
    without executing `return`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意拆解的最后两行吗？它们返回 `None`，这是 Python 从函数返回的默认值。对我们来说，很明显函数在退出 `if` 时并没有结束，因为两个分支都使用了
    `return`，但 Python 编译器可能无法检测到这一点，因此它添加了代码来处理在没有执行 `return` 时离开函数的情况。
- en: Programming languages, both compiled and interpreted, must operate on data.
    Let’s now explore how languages manipulate and store data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言，无论是编译型还是解释型，都必须处理数据。接下来我们将探讨语言如何操作和存储数据。
- en: '**Data Types**'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: The phrase *data type* refers to the organization of data in a programming language.
    Is the data element a number? A character? A structure made up of other data pooled
    together? How data is processed and stored depends on the data type.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据类型*这一术语指的是编程语言中数据的组织方式。数据元素是一个数字吗？是一个字符吗？是由其他数据汇聚成的结构吗？数据的处理和存储方式取决于数据类型。'
- en: Programming languages fall into different categories based on how they deal
    with data types. A language may be strongly typed or weakly typed. Similarly,
    a language might be statically typed or dynamically typed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言根据它们如何处理数据类型而分为不同类别。一种语言可能是强类型或弱类型。同样，一种语言也可能是静态类型或动态类型的。
- en: In a *strongly typed language*, the type of a variable will not, at a minimum,
    be automatically changed behind the scenes for a particular use of the variable.
    Python is a strongly typed language, as is Java. For example, in Python, adding
    an integer and string will result in a runtime error, even if the string is actually
    a number. You can see this by running `1 + '2'`, which should generate a `TypeError`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在*强类型语言*中，变量的类型至少不会在后台自动改变以适应某个特定用途。Python 是强类型语言，Java 也是如此。例如，在 Python 中，将整数和字符串相加会导致运行时错误，即使字符串实际上是一个数字。你可以通过运行
    `1 + '2'` 来看到这一点，它应该会产生一个 `TypeError`。
- en: A *weakly typed language* will change data types implicitly in different situations.
    In [Chapter 5](ch05.xhtml#ch05), we’ll explore SNOBOL. In SNOBOL, for some string
    operations, a numeric value is implicitly converted into a string. Similarly,
    a string that represents a number will be implicitly converted into a number if
    the expression expects a number. In SNOBOL, the expression `1 + '2'` isn’t an
    error. It correctly evaluates to `3` by quietly converting `'2'` into a number
    behind the scenes. Therefore, SNOBOL is a weakly typed language.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*弱类型语言*会在不同情况下隐式地改变数据类型。在[第 5 章](ch05.xhtml#ch05)中，我们将探讨 SNOBOL。在 SNOBOL 中，对于某些字符串操作，数字值会被隐式转换为字符串。同样，如果表达式期望的是一个数字，代表数字的字符串会被隐式转换为数字。在
    SNOBOL 中，表达式 `1 + ''2''` 并不是一个错误。它会正确地评估为 `3`，并且会在后台默默地将 `''2''` 转换为数字。因此，SNOBOL
    是一种弱类型语言。'
- en: A *dynamically typed language* does not require the programmer to declare the
    type of data a variable holds before using it. Python is a dynamically typed language.
    If the variable contains a number, it can be assigned a string at any time, for
    example. Therefore, Python is both strongly and dynamically typed. Smalltalk variables
    are not given a type before use, so Smalltalk is also a dynamically typed language.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态类型语言*不要求程序员在使用变量之前声明其数据类型。Python 是一种动态类型语言。例如，如果一个变量包含一个数字，它随时可以被赋值为一个字符串。因此，Python
    既是强类型又是动态类型的语言。Smalltalk 变量在使用之前不指定类型，因此 Smalltalk 也是一种动态类型语言。'
- en: A *statically typed language* forces the programmer to declare what kind of
    data a variable will hold. C, C++, Java, Pascal, ALGOL, and FORTRAN are all statically
    typed languages. FORTRAN still supports implicit variable typing, which superficially
    looks like dynamic typing, but it isn’t. Unless otherwise instructed via `implicit
    none`, FORTRAN automatically treats variables beginning with the letters *I* through
    *N* as integers and all other variables as reals (floating-point). The type is
    still specified indirectly. Therefore, FORTRAN is statically typed as well.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态类型语言*要求程序员声明变量将持有的数据类型。C、C++、Java、Pascal、ALGOL 和 FORTRAN 都是静态类型语言。FORTRAN
    仍然支持隐式变量类型，这表面上看起来像动态类型，但并非如此。除非通过 `implicit none` 明确指示，否则 FORTRAN 会自动将以字母 *I*
    到 *N* 开头的变量视为整数，将所有其他变量视为实数（浮点数）。类型仍然是间接指定的。因此，FORTRAN 也是静态类型语言。'
- en: As with many things in programming languages, absolute statements are fraught
    with peril. Nonetheless, for pedagogical purposes only, let’s categorize languages
    by whether they are dynamic or static and strongly or weakly typed. The result
    is [Table 2-1](ch02.xhtml#ch02tab1).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如许多编程语言中的事物一样，绝对的说法充满了危险。然而，仅为教学目的，我们还是将语言按是否动态或静态以及是否强类型或弱类型来分类。结果见[表 2-1](ch02.xhtml#ch02tab1)。
- en: '**Table 2-1:** Languages by Strong/Weak and Dynamic/Static Typing'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-1:** 按强/弱类型和动态/静态类型分类的语言'
- en: '|  | **Dynamic** | **Static** |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|  | **动态** | **静态** |'
- en: '| --- | --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Weak** | JavaScript, Perl, SNOBOL | C, C++, Pascal |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **弱类型** | JavaScript, Perl, SNOBOL | C, C++, Pascal |'
- en: '| **Strong** | Python, Ruby, Smalltalk, APL | Scala, Java, Ada, ALGOL, FORTRAN,
    COBOL, Simula |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **强类型** | Python, Ruby, Smalltalk, APL | Scala, Java, Ada, ALGOL, FORTRAN,
    COBOL, Simula |'
- en: Some languages don’t have a place in [Table 2-1](ch02.xhtml#ch02tab1). For example,
    in [Chapter 4](ch04.xhtml#ch04) we’ll explore Forth, which is a stack-based language.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有些语言没有在 [表 2-1](ch02.xhtml#ch02tab1) 中出现。例如，在 [第 4 章](ch04.xhtml#ch04)中，我们将探讨
    Forth，这是一种基于栈的语言。
- en: Forth has no concept of data type beyond the number of bits used by the values
    on its stack; however, some Forth systems have a separate floating-point data
    stack. The stack value might be a number, or it might be the address of a structure,
    which in Forth is only an agreed upon partitioning of some amount of memory. Forth
    is an *untyped* language and enforces nothing related to types.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 没有超出栈上值所用位数的概念数据类型；然而，一些 Forth 系统有一个单独的浮点数据栈。栈中的值可能是一个数字，也可能是一个结构体的地址，在
    Forth 中，结构体仅仅是对一部分内存的约定划分。Forth 是一种 *无类型* 的语言，不强制任何与类型相关的规则。
- en: Data types and their study are an important part of theoretical computer science.
    Please see the reference material at the back of the book for information on where
    you can go to dive as deeply into the world of data types as you wish. Here, we’ll
    only concern ourselves with primitive data types and *records*, which are user-defined
    collections of other data types.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型及其研究是理论计算机科学的重要组成部分。请参见书籍后面的参考资料，了解你可以深入研究数据类型世界的更多资源。在这里，我们只关心原始数据类型和 *记录*，即用户定义的其他数据类型的集合。
- en: '***Primitive Data Types***'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原始数据类型***'
- en: '*Primitive data types* are the atoms of a programming language. They are what
    you expect languages to work with: numbers, both integers and floating-point values,
    along with characters (C) and strings (Python). C doesn’t have strings as a primitive
    data type. Instead, it uses arrays of characters to represent strings. In Python,
    strings are primitive, along with Booleans (True or False). Additionally, Python
    supports complex numbers, which are usually represented internally as pairs of
    floating-point values, one for the real part and another for the imaginary part.
    Some languages, like Scheme, support fractions as a primitive data type. We’ll
    use this to good effect in [Chapter 8](ch08.xhtml#ch08) when we implement FRACTRAN
    in Scheme.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*原始数据类型* 是编程语言的基本单元。它们是你期望语言操作的内容：数字，包括整数和浮点值，以及字符（C 语言）和字符串（Python）。C 语言没有字符串作为原始数据类型。相反，它使用字符数组来表示字符串。在
    Python 中，字符串是原始数据类型之一，布尔值（True 或 False）也属于这一类。此外，Python 支持复数，通常以一对浮点数表示，一个用于实部，另一个用于虚部。一些语言，如
    Scheme，支持分数作为原始数据类型。在 [第 8 章](ch08.xhtml#ch08) 中，我们将使用 Scheme 实现 FRACTRAN 时，充分利用这一点。'
- en: Computers use multiple methods for representing numbers in memory. Depending
    on the language, a programmer might need to know explicit details of how a number
    is stored. This is often true for C when used in an embedded setting, such as
    on a microcontroller or single-board computer. In [Listing 2-1](ch02.xhtml#ch02list1),
    we saw how the Apple II stored the 16-bit integer used to represent the line number
    with its lowest-order byte first followed by the higher-order byte.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机使用多种方法在内存中表示数字。根据语言的不同，程序员可能需要了解数字存储的具体细节。这在 C 语言中尤其常见，特别是在嵌入式环境中使用时，比如在微控制器或单板计算机上。在
    [清单 2-1](ch02.xhtml#ch02list1) 中，我们看到 Apple II 如何存储表示行号的 16 位整数，其中最低有效字节在前，紧跟着是高位字节。
- en: '**NOTE**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**注释**'
- en: '*Storing integers with the lowest-order byte first is known as little-endian.
    As you might guess, the reverse is known as big-endian (or sometimes network order).
    For a detailed presentation of how computers store and operate on numbers, please
    see my book* Numbers and Computers *(Springer, 2017). To understand the origin
    of “little-endian” and “big-endian,” read* Gulliver’s Travels *by Jonathan Swift.*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*将整数按最低有效字节先存储被称为小端（little-endian）。如你所猜测，反过来就是大端（big-endian）（有时也称为网络字节序）。要详细了解计算机如何存储和操作数字，请参见我的书《数字与计算机》（Springer，2017）。若想理解“little-endian”和“big-endian”的来源，请阅读
    Jonathan Swift 的《格列佛游记》。*'
- en: '***Records***'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***记录***'
- en: If you use a programming language for any length of time, you’ll eventually
    want to group different data types into a meaningful unit. A *record*, also known
    as a *structure*, is just that. Languages supporting records include the ALGOL
    family, both the Pascal and C branches ([Figure 1-3](ch01.xhtml#ch01fig3)), along
    with many others, like SML. Exactly how a language supports this concept varies,
    and in some cases, the words *record* and *structure* are not synonymous. This
    is the case with C#, where a record is immutable but a structure is not. Let’s
    look at how Pascal and C implement records.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你长时间使用某种编程语言，你最终会希望将不同的数据类型组合成一个有意义的单元。*记录*（record），也称为*结构*（structure），正是这样的单元。支持记录的语言包括ALGOL家族、Pascal和C分支（[图1-3](ch01.xhtml#ch01fig3)），以及许多其他语言，如SML。每种语言如何支持这一概念有所不同，在某些情况下，*record*和*structure*并非同义词。例如在C#中，record是不可变的，而structure则不是。我们来看一下Pascal和C是如何实现记录的。
- en: '**Pascal Records**'
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Pascal记录**'
- en: 'A program to store information on people for later reference would benefit
    from a record grouping a person’s name, birthday, address, and phone number into
    a single unit. We might then define an array of these records to hold the same
    set of information for many different people. In Pascal, such declarations might
    look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个存储人名、生日、地址和电话号码等信息以供后续参考的程序将受益于一个记录，它将这些信息组合成一个单元。我们可能会定义一个包含这些记录的数组，用来保存许多不同人的相同信息。在Pascal中，这样的声明可能如下所示：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The type `PersonType` combines several strings along with instances of `PhoneNumberType`
    and `BirthdayType`. A variable of type `PersonType` is a single variable with
    multiple fields.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`PersonType`类型将多个字符串与`PhoneNumberType`和`BirthdayType`的实例组合在一起。`PersonType`类型的变量是一个具有多个字段的单一变量。'
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Fields are accessed by name using dot notation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过名称使用点符号访问字段。
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The nested `BirthdayType` is referenced first by accessing `bday`, and then
    by field of `bday`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的`BirthdayType`首先通过访问`bday`来引用，然后通过`bday`的字段来引用。
- en: A simple example using `PersonType` is in the file *lbb.pas*. To compile it,
    use the Free Pascal compiler (*[https://www.freepascal.org/](https://www.freepascal.org/)*),
    which is easy to install on Ubuntu.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`PersonType`的一个简单示例见文件*lbb.pas*。要编译它，请使用Free Pascal编译器（*[https://www.freepascal.org/](https://www.freepascal.org/)*），它在Ubuntu上很容易安装。
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: See the website for macOS and Windows versions. Once installed, compile *lbb.pas*
    with `fpc lbb.pas`. The program generates a random database of 100 different people.
    We’ll skip listing *lbb.pas* to save space, but do read through the file to understand
    what is going on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅网站以获取macOS和Windows版本的信息。安装完成后，使用`fpc lbb.pas`编译*lbb.pas*。该程序生成一个包含100个不同人的随机数据库。为了节省空间，我们不列出*lbb.pas*的内容，但请阅读该文件以理解发生了什么。
- en: '**C Structures**'
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**C结构体**'
- en: 'C structures are similar to Pascal records. The person structures look like:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: C结构体与Pascal记录类似。人的结构体如下所示：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As C has no primitive string type, we first define one using a fixed array of
    32 characters called `string`. The declarations use `typedef` to create a named
    type for each structure (`struct`). The names follow the C convention of using
    underscores and `_t` at the end to denote a type.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C语言没有原生字符串类型，我们首先使用一个包含32个字符的固定数组来定义一个`string`。声明使用`typedef`为每个结构体（`struct`）创建一个命名类型。命名规则遵循C语言的惯例，使用下划线并在类型名末尾加上`_t`。
- en: Some languages allow a structure to use the same region of memory to represent
    multiple fields with different types. I suspect the original motivation for this
    was to save memory for cases where fields were mutually exclusive. A C `union`
    works this way. For example, the following code defines a union where the same
    memory location is sometimes interpreted as a 32-bit float or a 32-bit unsigned
    integer.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言允许结构体使用相同的内存区域来表示多个不同类型的字段。我猜测最初这样做的动机是为了节省内存，尤其是在字段是互斥的情况下。C语言中的`union`就是这种方式。例如，下面的代码定义了一个联合体，其中相同的内存位置有时被解释为32位浮点数，有时被解释为32位无符号整数。
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Which interpretation is used depends on which field is accessed, `f` or `d`.
    The code below declares a variable `fp` to be of type `fp_t`, and then assigns
    the floating-point field the value of *π* before referencing the same memory as
    an unsigned 32-bit integer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哪种解释方式取决于访问的是哪个字段，`f`还是`d`。下面的代码声明了一个类型为`fp_t`的变量`fp`，然后将浮点字段的值设为*π*，随后将同一块内存引用为一个无符号32位整数。
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Data Structures**'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据结构**'
- en: A *data structure* is a way to organize data in memory. A record is a data structure,
    but the term is usually used to describe more complex ways of managing data. Data
    structures are necessary but somewhat masked by modern programming languages,
    as their intrinsic data structures, like Python’s lists and dictionaries, are
    so powerful that more elaborate data structures are not necessary as often as
    they used to be. Still, for C and C++ programmers, understanding data structures
    is critical. Data structures are a book in their own right, like many topics in
    this chapter. Sadly, we must give data structures short shrift by providing only
    quick summaries.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据结构* 是一种在内存中组织数据的方法。记录是一种数据结构，但这个术语通常用于描述更复杂的数据管理方式。数据结构是必要的，但在现代编程语言中，它们的本质数据结构（如Python的列表和字典）非常强大，因此不像过去那样经常需要更复杂的数据结构。但是，对于C和C++程序员来说，理解数据结构至关重要。数据结构是本章中许多主题中的一本书。遗憾的是，我们只能提供快速摘要来介绍数据结构。'
- en: '***Arrays***'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数组***'
- en: At its simplest, an *array* is nothing more than a block of contiguous memory
    partitioned into chunks of equal size. An array of 100 32-bit integers occupies
    a block of 100 × 4 = 400 bytes because each integer is 4 bytes long. For example,
    in C, `int A[100]` declares `A` to be such an array. The C `sizeof` operator reports
    that `A` uses 400 bytes of memory, as expected.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式下，*数组* 只不过是一个连续内存块，被分成大小相等的块。一个包含100个32位整数的数组占据了400字节的内存块，因为每个整数长度为4字节。例如，在C语言中，`int
    A[100]` 声明了`A` 是这样一个数组。C语言中的`sizeof`运算符报告`A` 使用了400字节的内存，正如预期的那样。
- en: The variable `A` refers to the first 4-byte block of memory allocated for the
    array. As C knows the size of each element of the array, finding the address of
    any index of the array is as simple as multiplying the index by four and adding
    that number to the base address of the array. This is why many programming languages
    index arrays from 0\. That way the offset to the first array element is 0 bytes
    from the base address.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`A` 指的是为数组分配的第一个4字节内存块。由于C知道数组每个元素的大小，因此找到数组任何索引的地址就像将索引乘以四然后加上数组的基地址一样简单。这就是为什么许多编程语言从0开始索引数组的原因。这样，从基地址到第一个数组元素的偏移量就是0字节。
- en: 'Multidimensional arrays are still stored as a single block of memory. For example,
    Pascal defines a 2D array like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组仍然存储为单个内存块。例如，Pascal定义一个2D数组如下：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The array `A` is an 8×8 array, or matrix, of integers (think of a chessboard).
    In memory, it’s still a contiguous block of memory, this time using 8 × 8 × 2
    = 128 bytes. To index the array, we use two indices, `A[i,j]`, and calculate the
    address of the desired element as `8 * i + j` added to the base memory address.
    The eight is the number of elements in one row of the array, that is, the number
    of columns. Indexing basic arrays, even multidimensional arrays, is trivial and
    fast as long as the array is stored as a contiguous block of memory.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 数组`A` 是一个8×8的整数数组（想象成棋盘）。在内存中，它仍然是一个连续的内存块，这次使用了8 × 8 × 2 = 128字节。为了索引数组，我们使用两个索引，`A[i,j]`，并计算所需元素的地址为基础内存地址加上`8
    * i + j`。八是数组一行中的元素数，即列数。索引基本数组，甚至是多维数组，只要数组存储为连续的内存块，就是简单且快速的。
- en: '***Linked Lists***'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***链表***'
- en: '*Linked lists* are the next simplest data structure. They are a collection
    of nodes, usually allocated on the heap, holding the data of interest along with
    a pointer to the following link in the chain. A *doubly linked* list also keeps
    a pointer to the previous node.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*链表* 是下一个最简单的数据结构。它们是一组节点，通常分配在堆上，保存了感兴趣的数据以及指向链中下一个链接的指针。*双向链表* 还保留了指向前一个节点的指针。'
- en: Inserting and removing elements of a linked list is easy once the proper node
    has been located. Locating a node in the first place is relatively slow by comparison
    because, in the simplest version of a linked list, the list must be traversed
    node by node from the beginning to find the target. Because of their conceptual
    simplicity, linked lists are a favorite homework assignment for introductory programming
    courses.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定位到适当的节点，插入和删除链表中的元素就很容易。与此相比，首先定位节点相对较慢，因为在最简单的链表版本中，必须从开头逐个节点地遍历列表以找到目标。由于它们的概念简单性，链表是入门编程课程中喜爱的作业任务。
- en: It might be tempting to wonder if Python lists are sophisticated instances of
    a linked list. However, this is not the case. Python lists are dynamic arrays
    of pointers to the objects they contain. Python lists can deliver good performance
    when indexing by cleverly managing how the arrays grow when new elements are added.
    They use the simple equations above to locate elements, bypassing the slow, node-by-node
    traversal of a linked list. That said, dynamic arrays of object pointers are still
    too slow for many scientific applications, which was the motivation behind powerful
    array-processing libraries for Python, like NumPy.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，Python 列表是不是一个复杂的链表实例。然而，事实并非如此。Python 列表是指向它们包含对象的动态数组。Python 列表通过巧妙地管理数组在添加新元素时的增长方式，可以在索引时提供良好的性能。它们使用上述简单的公式来定位元素，从而绕过了链表中逐节点遍历的缓慢过程。尽管如此，面向对象指针的动态数组对于许多科学应用仍然太慢，这也是
    Python 强大的数组处理库（如 NumPy）出现的动因。
- en: '***Trees***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***树***'
- en: '*Trees* are elaborate hierarchical data structures, usually built dynamically
    in heap memory. There are many different kinds of trees, and they offer excellent
    performance in terms of inserting or removing information and locating information
    quickly. We saw an example of a tree earlier in the chapter in [Figure 2-1](ch02.xhtml#ch02fig1),
    where the parser for a programming language builds trees representing the structure
    of program statements.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*树*是复杂的层次化数据结构，通常在堆内存中动态构建。有许多不同种类的树，它们在插入或删除信息以及快速查找信息方面表现出色。我们在本章早些时候看到过一个树的例子，在[图
    2-1](ch02.xhtml#ch02fig1)中，编程语言的解析器构建了表示程序语句结构的树。'
- en: Recursive algorithms exist for quickly traversing trees. Trees are ubiquitous
    in computer science, but again, they are now less often used in day-to-day scenarios
    because modern languages support robust data structures implicitly or via libraries.
    Thus, programmers are freed from implementing their own trees except in the most
    demanding of cases.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 递归算法存在于快速遍历树的过程中。树在计算机科学中无处不在，但现在它们在日常场景中的使用较少，因为现代语言通过隐式支持或库提供了强大的数据结构。因此，程序员除了在最苛刻的情况下，通常不需要自己实现树。
- en: '***Hash Tables***'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***哈希表***'
- en: In a *hash table*, a *hash*, the output of a *hash function*, is used to map
    a block of data to a single value. The idea behind a hash function is to map the
    data to a unique value, an integer in a specified range. For example, under the
    hood, Python dictionaries are hash tables. The key is given to the hash function
    to calculate a unique integer representing the key. Then, the table is indexed
    by the hash value to return the data associated with the key.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在*哈希表*中，*哈希*（即*哈希函数*的输出）用于将一块数据映射到一个单一值。哈希函数的思想是将数据映射到一个唯一值，即指定范围内的整数。例如，Python
    字典在底层就是哈希表。键会被传给哈希函数，计算出一个表示该键的唯一整数。然后，哈希值作为索引来查询与该键相关联的数据。
- en: If two different keys generate the same hash value, a *collision* has occurred.
    There are different options for handling collisions. Python dictionaries randomly
    probe the table to locate an open position for the key in case of a collision.
    A good hash function, plus a thorough knowledge of the probabilities behind hash
    collisions for a specified table size, lets Python manage hashes efficiently to
    minimize collisions while not wasting memory.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个不同的键生成相同的哈希值，则发生了*碰撞*。处理碰撞有不同的选项。Python 字典在发生碰撞时，会随机探查表格以寻找一个空位来存储键。一个好的哈希函数，再加上对指定表大小下哈希碰撞概率的深入了解，能让
    Python 高效管理哈希，减少碰撞并避免浪费内存。
- en: Of course, there are many more types of data structures. The references at the
    end of the book will point you toward resources where you can explore data structures
    in more depth. For now, let’s learn about how programming languages decide which
    variable to access when referenced in a program.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有许多其他类型的数据结构。本书末尾的参考资料会指引你找到可以深入学习数据结构的资源。现在，让我们来学习编程语言如何决定在程序中引用变量时访问哪个变量。
- en: '**Variables and Scope**'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**变量和作用域**'
- en: 'Variables exist in some context, in a relationship to other variables and regions
    of the code. The region of code where a variable is visible is known as the variable’s
    *scope*. Programming languages fall into two main camps when it comes to scope:
    lexical scoping and dynamic scoping. The majority of programming languages use
    lexical scoping. A smaller subset uses dynamic scoping, and a few, like Perl,
    use both. Each language has its own, sometimes rather complex, scoping rules.
    In this section, we’ll restrict ourselves to the difference between lexical and
    dynamic scoping and leave the minutiae of a particular language’s scoping rules
    out of the discussion.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 变量存在于某种上下文中，与其他变量和代码区域之间有关系。变量可见的代码区域称为变量的*作用域*。在作用域方面，编程语言分为两大类：词法作用域和动态作用域。大多数编程语言使用词法作用域。较少的一部分使用动态作用域，还有少数语言像
    Perl，使用了词法作用域和动态作用域的结合。每种语言都有自己独特的，往往较为复杂的作用域规则。在本节中，我们将限制讨论词法作用域和动态作用域之间的区别，并不深入讨论某个特定语言的作用域规则细节。
- en: '***Lexical Scope***'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***词法作用域***'
- en: In *lexical scoping* (also called *static scoping*), a variable reference is
    tied back to a declaration or assignment based on the structure of the program
    when the program was written, that is, the structure seen by a compiler. In this
    case, the relationships between variable references and which variable is used
    are static and fixed by the source code’s structure.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在*词法作用域*（也叫*静态作用域*）中，变量引用是根据程序编写时的结构，也就是编译器所看到的结构，回溯到声明或赋值的地方。在这种情况下，变量引用与哪个变量被使用之间的关系是静态的，并且由源代码的结构所固定。
- en: 'For lexical scoping, the variable corresponding to a reference follows a simple
    resolution algorithm: local block or function, next outer block or function, next
    outer, and so forth to the global level. Python is statically scoped. Consider
    the following example.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于词法作用域，引用所对应的变量遵循一个简单的解析算法：局部块或函数，接着是外层的块或函数，再往外，直到全局作用域。Python 是静态作用域的。考虑以下示例。
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output of this program is
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出是
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Python allows nested function declarations, so the function `a` contains `b`,
    which contains `c`, which in turn contains `d`. The outermost level, global scope,
    defines `x=10`, as the first `print` informs us. We then call `a`, which sets
    `x=15` locally, as `a`’s `print` tells us. Then we call `b`, which does not define
    `x` locally. Therefore, to understand the reference to `x` ➌, Python must search
    for `x` in an enclosing scope. Python finds `x` in `a`, so `b` uses `a`’s value,
    15\. When `c` is called by `b`, `c` must search for an `x` as well ➋. Python doesn’t
    find `x` in `b`, so it searches the next higher enclosing scope, that of `a`,
    where it does find `x=15`. Lastly, `c` calls `d` which defines `x=20` locally,
    as `d` reports ➊.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许嵌套函数声明，因此函数`a`包含`b`，`b`又包含`c`，而`c`又包含`d`。最外层的全局作用域定义了`x=10`，正如第一个`print`告诉我们的那样。然后我们调用`a`，它局部设置了`x=15`，正如`a`的`print`所示。接着我们调用`b`，它没有在局部定义`x`。因此，为了理解对`x`
    ➌的引用，Python必须在一个封闭作用域中搜索`x`。Python 在`a`中找到了`x`，因此`b`使用了`a`的值，即15。当`b`调用`c`时，`c`也必须搜索一个`x`
    ➋。Python 在`b`中没有找到`x`，因此它继续在下一个封闭作用域中搜索，也就是`a`，并在其中找到了`x=15`。最后，`c`调用`d`，`d`在局部定义了`x=20`，正如`d`的输出所示
    ➊。
- en: Lexical scoping makes sense without excessive tracing of the program to understand
    which value is used for which reference. That’s why most languages, especially
    newer or more widely used commercial languages, use it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 词法作用域使得理解程序中哪个值与哪个引用相关联变得更加直观，而无需过度追踪程序的执行。这就是为什么大多数语言，尤其是更新的或更广泛使用的商业语言，都采用它的原因。
- en: '***Dynamic Scope***'
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***动态作用域***'
- en: '*Dynamic scoping* uses the current state of the program to decide which value
    goes with which reference. This means it isn’t always easy to see which value
    of a variable will be used by a function, as it depends on the context in which
    the function is used.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态作用域*使用程序的当前状态来决定哪个值与哪个引用相关联。这意味着，很难直接看出函数会使用变量的哪个值，因为它依赖于函数所处的上下文。'
- en: 'Let’s do a little experiment. We’ll write what is, more or less, the same program
    in four different languages: lexically scoped Python and C, dynamically scoped
    SNOBOL, and Perl, which, as we’ll see, is both lexically and dynamically scoped.
    We’ll then see if we can explain the output in each case. The presentation below
    lists the source code on the left and the program’s output on the right.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个小实验。我们将分别用四种不同的语言写出基本相同的程序：词法作用域的 Python 和 C，动态作用域的 SNOBOL，以及 Perl，正如我们将看到的，它既有词法作用域也有动态作用域。然后我们将看看能否解释每种情况下的输出。以下展示了源代码在左侧，程序输出在右侧。
- en: '***Python***'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Python***'
- en: We know that Python is lexically scoped, as we demonstrated it above. Therefore,
    let’s use Python as our base case, the one that shouldn’t surprise us in any way.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道Python是按词法作用域的，正如我们之前展示的。因此，让我们使用Python作为基本情况，它是不会让我们感到惊讶的。
- en: '| **Code** | **Output** |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| **代码** | **输出** |'
- en: '| --- | --- |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| x = 10 def f():'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '| x = 10 def f():'
- en: return x
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: return x
- en: 'def g():'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 'def g():'
- en: x = 20
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: x = 20
- en: return f()
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: return f()
- en: print(g()) | 10 |
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: print(g()) | 10 |
- en: The code first defines `x` globally, then `f`, which does nothing more than
    return `x`. Next, the code defines the function `g`, which defines `x=20` locally,
    within the scope of `g`, and then returns whatever `f` returns. The main part
    of the code prints whatever `g` returns.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先在全局定义`x`，然后定义`f`，它仅仅返回`x`。接下来，代码定义了函数`g`，它在`g`的作用域内局部定义了`x=20`，然后返回`f`返回的值。代码的主部分打印了`g`返回的值。
- en: Look at the definition of `g`. There is a local `x` defined before the call
    to `f`. So why wasn’t the output 20? After all, that’s what `x` is set to immediately
    before the call to `f`. The output isn’t 20 because when `f` is defined (compiled),
    `x` exists globally as 10\. Therefore, that’s the value used for `f`, regardless
    of any local `x` defined by `g`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`g`的定义。它在调用`f`之前定义了一个局部的`x`。那么为什么输出不是20呢？毕竟，`x`在调用`f`之前被设置为20。输出不是20是因为当`f`被定义（编译）时，`x`在全局作用域中已经是10。因此，不管`g`是否定义了局部的`x`，`f`使用的始终是全局的10。
- en: Review this example, if necessary, to make sure you follow it. When you are
    ready, read on.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如有必要，复习这个例子，确保你理解了。如果准备好，继续阅读。
- en: '***C***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***C***'
- en: C, like Python, is also lexically scoped. Therefore, this example should be
    much like the example above. Let’s take a look.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: C语言与Python一样，也是按词法作用域的。因此，这个例子应该与上面的例子非常相似。让我们看一下。
- en: '| **Code** | **Output** |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| **代码** | **输出** |'
- en: '| --- | --- |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| int x = 10; int f() {  return x;  }'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '| int x = 10; int f() {  return x; }'
- en: int g() {
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: int g() {
- en: x = 20;
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: x = 20;
- en: return f();
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: return f();
- en: '}'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: int h() {
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: int h() {
- en: int x = 15;
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: int x = 15;
- en: return f();
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: return f();
- en: '}'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void main() {
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: void main() {
- en: printf("h() = %d\n", h());
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: printf("h() = %d\n", h());
- en: printf("g() = %d\n", g());
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: printf("g() = %d\n", g());
- en: '} | h() = 10 g() = 20 |'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '} | h() = 10 g() = 20 |'
- en: 'For this example, begin at the bottom, with the function `main`. In C, `main`
    must exist and is the entry point for all programs. The function `main` prints
    two values: whatever `h` returns followed by whatever `g` returns.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，从底部的`main`函数开始。在C语言中，`main`必须存在，并且是所有程序的入口点。`main`函数打印两个值：`h`返回的值和`g`返回的值。
- en: The function `h` defines a local `x=15` and then calls `f` to return whatever
    `f` returns. The function `f` can only see the global `x=10`, so that’s what it
    returns. The first output line makes sense.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`h`定义了一个局部的`x=15`，然后调用`f`返回`f`返回的值。函数`f`只能看到全局的`x=10`，所以它返回的是这个值。第一行输出是合理的。
- en: 'What about the output of `g`? Does that make sense? The function `g` is much
    like `h`, but the assignment to `x=20` doesn’t have an `int` type in front of
    it. When compiling this function, C realizes there is no locally defined `x` in
    `g`, so it goes up one level in scope to find `x` (in this case at global scope)
    and updates that `x`. So `g` has a side effect: it alters the value of `x` globally.
    This is why `f` now returns 20 instead of 10.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`g`的输出是什么？这有道理吗？函数`g`与`h`非常相似，但赋值`x=20`前没有加`int`类型。在编译这个函数时，C语言会意识到在`g`中没有局部定义`x`，所以它会向上查找作用域，在全局作用域中找到`x`并更新它。因此，`g`有一个副作用：它全局地改变了`x`的值。这就是为什么`f`现在返回的是20，而不是10。'
- en: '***SNOBOL***'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SNOBOL***'
- en: 'SNOBOL, the subject of [Chapter 5](ch05.xhtml#ch05), is a text-processing language
    from the 1970s. SNOBOL is dynamically scoped. Its syntax is strange, which is
    fitting for such a quirky language. For now, we need know only a few things about
    SNOBOL:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL，见[第5章](ch05.xhtml#ch05)，是一种1970年代的文本处理语言。SNOBOL是动态作用域的。它的语法很奇特，这也正符合这种语言的古怪特性。现在，我们只需要知道关于SNOBOL的几个要点：
- en: Functions are declared with `define` and return whatever value is assigned to
    their name.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数通过`define`声明，并返回分配给其名称的值。
- en: Variables are declared as local to a function by adding them after the name
    and arguments in the `define` statement.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量通过在`define`语句中添加到函数名和参数后面来声明为局部变量。
- en: Printing in SNOBOL is assigning to `output`.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在SNOBOL中，打印是通过赋值给`output`来实现的。
- en: The code we’ll consider is
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑的代码是
- en: '| **Code** | **Output** |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| **代码** | **输出** |'
- en: '| --- | --- |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|       x = 10       define(''f()'')     :(ef)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '|       x = 10       define(''f()'')     :(ef)'
- en: f     f = x             :(return)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: f     f = x             :(return)
- en: ef
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ef
- en: define('g()x')    :(eg)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: define('g()x')    :(eg)
- en: g     x = 20
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: g     x = 20
- en: g = f()           :(return)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: g = f()           :(return)
- en: eg
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: eg
- en: output = 'global x = ' f()
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: output = '全局 x = ' f()
- en: output = 'local  x = ' g()
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: output = '局部  x = ' g()
- en: output = 'global x = ' x
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: output = '全局 x = ' x
- en: end | global x = 10 local  x = 20
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 结束 | 全局 x = 10 局部  x = 20
- en: global x = 10 |
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 全局 x = 10 |
- en: 'This program defines two functions: `f` and `g`. The first returns whatever
    `x` is, and the second, which defines `x` as local to `g`, returns `f`’s return
    value. The main program begins with `x = 10`.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序定义了两个函数：`f` 和 `g`。第一个函数返回 `x` 的值，第二个函数将 `x` 定义为 `g` 的局部变量，并返回 `f` 的返回值。主程序开始时
    `x = 10`。
- en: 'The first line of the output is much like we saw earlier: `x` is global and
    `f` returns its value. The second line isn’t what we saw earlier. Instead of `f`
    using the value of `x` that existed when `f` was defined, it uses the value of
    `x` set by `g`, even though `g`’s `x` is local to `g`. The function `f` uses the
    context in which it is called, at runtime, to locate the value corresponding to
    `x`. This is dynamic scoping.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行与我们之前看到的类似：`x` 是全局的，`f` 返回它的值。第二行与我们之前看到的不同。`f` 并没有使用定义时存在的 `x` 的值，而是使用了
    `g` 设置的 `x` 值，即便 `g` 中的 `x` 是局部的。`f` 使用调用时的上下文，在运行时来查找与 `x` 对应的值。这就是动态作用域。
- en: The final line is there to show that `x` has not been updated by `g`, so this
    isn’t the situation we encountered with C where, in that case, `g` did update
    the global value of `x`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行是为了表明 `x` 并没有被 `g` 更新，因此这与我们在 C 中遇到的情况不同，因为在 C 中，`g` 确实更新了全局的 `x`。
- en: '***Perl***'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Perl***'
- en: Our final scoping example uses Perl. Perl is known for flexibility, so Perl
    supports both static and dynamic scoping, whichever suits the programmer’s fancy.
    Let’s see how.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个作用域示例使用的是 Perl。Perl 以灵活性著称，因此它支持静态和动态作用域，具体使用哪种取决于程序员的喜好。让我们看看是如何做到的。
- en: '| **Code** | **Output** |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| **代码** | **输出** |'
- en: '| --- | --- |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| $x = 10; sub f { return $x; }'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '| $x = 10; sub f { return $x; }'
- en: sub g {
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: sub g {
- en: local $x = 20;
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: local $x = 20;
- en: return f()
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: return f()
- en: '}'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: sub h {
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: sub h {
- en: my $x = 15;
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: my $x = 15;
- en: return f()
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: return f()
- en: '}'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: print g()."\n";
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: print g()."\n";
- en: print h()."\n"; |  20  10 |
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: print h()."\n"; |  20  10 |
- en: The form of this program is familiar. We see `f`, `g`, and `h`, just like the
    C example above. The program prints the output of `g` followed by `h`’s output.
    The only difference between `g` and `h`, besides the value assigned to `x`, is
    that `g` uses `local` and `h` uses `my`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的形式很熟悉。我们看到了 `f`、`g` 和 `h`，就像上面的 C 语言示例一样。程序先打印 `g` 的输出，再打印 `h` 的输出。除了赋值给
    `x` 的值外，`g` 和 `h` 之间的唯一区别是：`g` 使用 `local`，而 `h` 使用 `my`。
- en: 'Both `local` and `my` define a variable local to a function. The difference
    lies in which type of scoping is applied to the variable. When `my` is used, scoping
    is static, so `h` returns what `f` sees via static scoping, namely, `x=10`. However,
    for `g`, Perl has been told, via `local`, to use dynamic scoping with `x`, so
    the call to `f` from `g` uses `g`’s context to figure out which `x` to use, that
    is, the `x` local to `g`, thereby returning `x=20`. The lesson is clear: read
    Perl source code carefully.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`local` 和 `my` 都定义了一个函数局部变量。它们的区别在于应用于变量的作用域类型。当使用 `my` 时，作用域是静态的，因此 `h` 返回的是通过静态作用域，`f`
    所看到的内容，即 `x=10`。然而，对于 `g`，Perl 被告知通过 `local` 使用动态作用域与 `x`，因此 `g` 中调用 `f` 时，会根据
    `g` 的上下文来确定使用哪个 `x`，也就是 `g` 中局部的 `x`，因此返回 `x=20`。教训很明确：要仔细阅读 Perl 源代码。'
- en: Variable scoping is intimately linked with program flow. Investigating how programming
    languages implement and manipulate program flow is next on our list.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 变量作用域与程序流程紧密相连。接下来我们将探讨编程语言如何实现并操作程序流程。
- en: '**Controlling Program Flow**'
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**控制程序流程**'
- en: 'All programming languages implement some form of *flow control*, which is some
    means for modifying the sequence of instructions executed in response to different
    conditions. The discussion in this section focuses on *control structures* commonly
    encountered in programming languages. We’ll divide languages into two main groups:
    unstructured and structured. Let’s learn something about the characteristics of
    each.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 所有编程语言都实现了某种形式的 *流程控制*，即通过某种方式在不同条件下修改执行指令的顺序。本节讨论的重点是编程语言中常见的 *控制结构*。我们将语言分为两大类：无结构语言和结构化语言。让我们了解一下每种语言的特点。
- en: '***Unstructured Languages***'
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***无结构语言***'
- en: '*Unstructured languages* use goto, in some form, as the only way to modify
    program flow. Along with goto, these languages have some mechanism for testing
    different conditions. The combination of goto and conditional testing is sufficient
    to implement any algorithm, but that doesn’t mean doing so will be clear or easy
    to debug or verify.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*非结构化语言*使用goto，以某种形式作为修改程序流程的唯一方式。与goto一起，这些语言还有一些机制来测试不同的条件。goto和条件测试的组合足以实现任何算法，但这并不意味着这样做会清晰或容易调试或验证。'
- en: Old-style BASIC, like the example in [Listing 1-3](ch01.xhtml#ch01list3), is
    unstructured. There are `if` statements and a `goto` statement (of potentially
    different kinds). Likewise, assembly language is unstructured. Review [Listing
    2-3](ch02.xhtml#ch02list3), which includes instructions to test different conditions
    (`btfss`) and gotos.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版BASIC，如[示例1-3](ch01.xhtml#ch01list3)中的例子，是非结构化的。它有`if`语句和`goto`语句（可能是不同类型的）。同样，汇编语言也是非结构化的。查看[示例2-3](ch02.xhtml#ch02list3)，其中包含测试不同条件的指令（`btfss`）和goto。
- en: SNOBOL is also unstructured. Every line in SNOBOL either succeeds or fails,
    and a label can be given to instruct SNOBOL where to go in either case. SNOBOL
    does not have a structured `if` statement, but instead has predicates that either
    succeed or fail, allowing a goto to handle either case.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL也是非结构化的。SNOBOL中的每一行要么成功，要么失败，并且可以给标签来指示SNOBOL在任一情况下应该跳转到哪里。SNOBOL没有结构化的`if`语句，而是有谓词，它们要么成功，要么失败，从而允许goto来处理任一情况。
- en: Most of the esolangs we’ll explore in later chapters are unstructured languages.
    Most use simple tests and branching or goto, like machine code. Some, like the
    Firefly language we’ll develop in [Chapter 15](ch15.xhtml#ch15), or [Chapter 8](ch08.xhtml#ch08)’s
    FRACTRAN, lack any form of goto beyond restarting the program from the beginning.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中探讨的大多数esolangs都是非结构化语言。大多数使用简单的测试和分支或goto，像机器代码一样。像我们将在[第15章](ch15.xhtml#ch15)中开发的Firefly语言，或者[第8章](ch08.xhtml#ch08)中的FRACTRAN，都没有任何形式的goto，除了从头开始重新启动程序。
- en: '***Structured Languages***'
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结构化语言***'
- en: Edsger Dijkstra’s famous 1968 letter “Go To Statement Considered Harmful” sounded
    the alarm on how goto as a flow control option is generally a bad idea. In the
    decades since, unstructured languages have faded and have largely been replaced
    by languages that implement *structured programming*, meaning languages that use
    the now-familiar control structures and eschew goto and the like.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 埃兹杰·戴克斯特拉（Edsger Dijkstra）在1968年的著名信件《Go To语句有害》（“Go To Statement Considered
    Harmful”）中敲响了警钟，指出goto作为流程控制选项通常是一个糟糕的主意。自那时以来，非结构化语言逐渐消退，并大多被实现*结构化编程*的语言所取代，意味着使用现在熟悉的控制结构并避免使用goto等。
- en: '**Selection**'
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**选择**'
- en: '*Selection* refers to using the result of a Boolean expression, or the equivalent,
    to alter program flow. The most common selection structure is the `if-then-else`
    construct. For example, in Pascal, and most modern languages, the syntax is virtually
    the same.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*选择*是指使用布尔表达式的结果或等效的东西来改变程序的流程。最常见的选择结构是`if-then-else`结构。例如，在Pascal和大多数现代语言中，语法几乎是一样的。'
- en: '[PRE22]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, `<condition>` returns a Boolean value. If `<condition>` is true, `<statements1>`
    are executed; otherwise, `<statements2>`, if present, are executed. Variations
    on `if` statements exist, like `elif` in Python to combine a nested `if`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`<condition>`返回一个布尔值。如果`<condition>`为真，则执行`<statements1>`；否则，执行`<statements2>`（如果存在）。`if`语句有多种变体，例如Python中的`elif`，用于结合嵌套的`if`：
- en: '[PRE23]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Many languages support `case` or `switch` statements. Pascal uses `case` and
    C uses `switch`. For example, in C, a `switch` statement to check on the value
    of an integer, `x`, might look like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言支持`case`或`switch`语句。Pascal使用`case`，而C使用`switch`。例如，在C中，一个`switch`语句用于检查整数`x`的值，可能如下所示：
- en: '[PRE24]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `break` is necessary, as execution falls through to the next `case` if
    not present. The same construct in Pascal might look like the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`是必要的，因为如果没有它，执行会继续流向下一个`case`。在Pascal中，同样的结构可能如下所示：'
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Scheme uses a `cond` statement in much the same way.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme使用`cond`语句，方式与此相似。
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, each sublist of `cond` is `(<condition> <statements>)` and the statements
    are executed if the condition is true. The `cond` statement tests each condition
    in order until one of them is true.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`cond`的每个子列表都是`(<condition> <statements>)`，如果条件为真，则执行语句。`cond`语句按顺序测试每个条件，直到其中一个为真。
- en: '**Repetition**'
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**重复**'
- en: 'By *repetition*, I mean any form of looping structure. Specifically, we’ll
    discuss four kinds of loops: top-tested, bottom-tested, counted, and infinite.
    We’ll use Modula-2 for [Listing 2-4](ch02.xhtml#ch02list4), as it supports all
    four kinds. Modula-2 is a successor of Pascal.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的*重复*是指任何形式的循环结构。具体来说，我们将讨论四种循环：顶部测试循环、底部测试循环、计数循环和无限循环。我们将使用Modula-2来展示[列表
    2-4](ch02.xhtml#ch02list4)，因为它支持这四种循环。Modula-2是Pascal的继任者。
- en: '[PRE27]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 2-4: Loops in Modula-2*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-4：Modula-2中的循环*'
- en: '[Listing 2-4](ch02.xhtml#ch02list4) presents all four kinds of structured programming
    loops. The preamble loads required functions from the standard library. A single
    variable, `i`, is all we need ➊. Modula-2 distinguishes between integers and cardinals,
    which are positive integers.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-4](ch02.xhtml#ch02list4)展示了所有四种结构化编程循环。前言部分加载了标准库中所需的函数。我们只需要一个变量，`i`
    ➊。'
- en: The first loop is a *top-tested* `WHILE` loop ➋. The loop executes while the
    condition is true. Because the test on the condition is at the top of the loop,
    there is the possibility that the loop will never execute.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个循环是*顶部测试*的`WHILE`循环 ➋。当条件为真时，循环执行。由于条件测试位于循环顶部，因此有可能循环永远不会执行。
- en: The second loop ➌ is a *bottom-tested* loop. The test on whether to continue
    the loop happens after the body of the loop; therefore, this loop executes the
    body at least once, regardless of `i`’s initial value. Modula-2 uses `UNTIL` for
    the bottom test, meaning the loop body repeats until the condition is true. Some
    languages, like C, use a `while` for the bottom test, so the loop executes while
    the condition is true.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个循环 ➌ 是*底部测试*循环。判断是否继续循环的测试在循环体之后进行；因此，这个循环至少执行一次循环体，无论`i`的初始值如何。Modula-2使用`UNTIL`进行底部测试，意味着循环体会重复执行直到条件为真。有些语言，如C语言，使用`while`进行底部测试，因此循环在条件为真时执行。
- en: Modula-2 is one of the few high-level languages with an explicit *infinite*
    loop structure ➍. A `LOOP` executes the body forever, or until `EXIT` is executed.
    A `while` loop that is always true has the same effect.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Modula-2是少数几种具有显式*无限*循环结构的高级语言之一 ➍。`LOOP`会无限执行循环体，直到执行`EXIT`。一个始终为真的`while`循环具有相同的效果。
- en: The last example is a `FOR` loop ➎. Modula-2’s `FOR` is virtually identical
    to that of many other languages. The loop index has an initial value and continues
    incrementing until it reaches its ending value. There are many variants of this
    kind of loop, called the *counted loop*. In this category, I’m including loops
    like Python’s `for` that iterate over any object supporting iteration.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例是`FOR`循环 ➎。Modula-2的`FOR`几乎与许多其他语言的`FOR`相同。循环索引有一个初始值，并继续递增，直到达到结束值。这种类型的循环有很多变种，称为*计数循环*。在这个类别中，我包括了像Python的`for`那样对支持迭代的任何对象进行迭代的循环。
- en: Program flow is influenced by the way the programming language is structured
    and its approach to coding. Let’s conclude the chapter with a review of important
    coding paradigms used by programming languages.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 程序流受编程语言结构和编码方式的影响。让我们通过回顾编程语言中使用的重要编码范式来结束本章内容。
- en: '**Programming Paradigms**'
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程范式**'
- en: A *programming paradigm* is the way a language approaches the act of coding.
    The most important paradigms are imperative, object-oriented, and declarative,
    to which we’ll add my personal favorite, array processing. Let’s discuss the high-level
    characteristics of a few paradigms and give some examples of languages supporting
    each paradigm. Many practical languages support more than one paradigm.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*编程范式*是指一种语言如何处理编码的方式。最重要的范式有命令式、面向对象和声明式，除此之外，我个人最喜欢的还有数组处理范式。让我们讨论一下几种范式的高级特性，并举例说明支持每种范式的语言。许多实用的语言支持多种范式。'
- en: '***Imperative***'
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***命令式***'
- en: '*Imperative* programming languages instruct the computer step by step. Almost
    all languages, especially those you’ll encounter as a professional developer,
    use this paradigm, or at least support it somewhat. And that makes sense: this
    is the most natural way to think about coding. To achieve a goal, certain things
    must happen in a specific order. That’s imperative programming: the programmer
    issues commands to the computer via the programming language.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*命令式*编程语言按步骤指示计算机操作。几乎所有语言，尤其是你作为专业开发人员会遇到的语言，都使用这种范式，或者至少在某种程度上支持它。这是有道理的：这种方式是最自然的编码思维方式。为了实现目标，某些操作必须按特定顺序发生。这就是命令式编程：程序员通过编程语言向计算机发出命令。'
- en: 'Think of a popular programming language. It’s almost undoubtedly imperative:
    Java, Python, C/C++, C#, JavaScript, and so on. All of the languages we encountered
    in [Chapter 1](ch01.xhtml#ch01), except for Prolog and SML, are imperative languages.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个流行的编程语言。几乎可以肯定它是命令式的：Java、Python、C/C++、C#、JavaScript等等。我们在[第1章](ch01.xhtml#ch01)中遇到的所有语言，除了Prolog和SML，都是命令式语言。
- en: Imperative languages are often further subdivided into structured and unstructured.
    A structured imperative language uses structured programming, which we just discussed
    in the previous section. Therefore, Pascal, C, Modula-2, and so on, are all structured
    imperative programming languages. An unstructured imperative language does not
    use structured programming. This includes assembly, but also higher-level languages
    like SNOBOL.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式语言通常进一步分为结构化和非结构化。结构化命令式语言使用结构化编程，我们在前一节中讨论过。因此，Pascal、C、Modula-2等都是结构化命令式编程语言。非结构化命令式语言不使用结构化编程。这包括汇编语言，但也包括像SNOBOL这样的高级语言。
- en: All the esolangs we’ll encounter and develop are imperative languages. It’s
    the most obvious way to do things.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遇到和开发的所有怪异语言都是命令式语言。这是做事情的最明显方式。
- en: '***Object-Oriented***'
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***面向对象***'
- en: '*Object-oriented* languages employ encapsulation, polymorphism, and inheritance.
    In a sense, object-oriented languages are imperative languages plus a higher level
    of organization. The leap from imperative programming to object-oriented is relatively
    straightforward.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*面向对象*语言采用封装、多态和继承。从某种意义上说，面向对象语言是命令式语言加上更高级别的组织。从命令式编程到面向对象编程的过渡相对比较直接。'
- en: '*Encapsulation* means that objects are both data and methods—they have their
    own data, separate from other objects, and their own methods for operating on
    that data. This hides information from outside of the object. This separation
    between objects adds security and reliability to programs. It is less likely that
    changes in one part of the program will adversely and subtly affect another part
    of the program in an object-oriented language.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*封装*意味着对象既包含数据又包含方法——它们拥有自己的数据，与其他对象分离，并且拥有操作该数据的方法。这将信息隐藏在对象外部。对象之间的这种分离增加了程序的安全性和可靠性。在面向对象的语言中，一个程序部分的变化不太可能会对另一个程序部分造成不利且微妙的影响。'
- en: '*Polymorphism* is perhaps best understood by example. Imagine a class called
    `Shape` that has a method called `draw`. Now imagine subclasses of `Shape`, such
    as `Rectangle`, `Square`, and `Circle`. Each of these subclasses supplies a `draw`
    method appropriate for its particular shape. This creates an object hierarchy
    (see [Figure 2-2](ch02.xhtml#ch02fig2)).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*多态*最好通过示例理解。想象一个名为`Shape`的类，它有一个名为`draw`的方法。现在想象`Shape`的子类，如`Rectangle`、`Square`和`Circle`。每个子类提供适合其特定形状的`draw`方法。这创建了一个对象层次结构（参见[图2-2](ch02.xhtml#ch02fig2)）。'
- en: '![Image](Images/02fig02.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/02fig02.jpg)'
- en: '*Figure 2-2: Hierarchy of objects in an object-oriented language*'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-2：面向对象语言中对象的层次结构*'
- en: In this diagram, `Rectangle`, `Square`, and `Circle` are all children (subclasses)
    of `Shape`. If we now make a function accepting a `Shape` argument, and call the
    `draw` method of that `Shape`, we can pass any subclass of `Shape` to the function
    and the proper `draw` method will be called. This is polymorphism.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，`Rectangle`、`Square`和`Circle`都是`Shape`的子类。如果我们现在编写一个接受`Shape`参数的函数，并调用该`Shape`的`draw`方法，我们可以向函数传递任何`Shape`的子类，将调用适当的`draw`方法。这就是多态。
- en: '**FUNCTION OVERLOADING**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数重载**'
- en: 'Polymorphism also happens during *function overloading*, a situation where
    multiple functions using the same name are defined, but each accepts a different
    type of argument. For example, consider this C++ code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 多态还发生在*函数重载*期间，即多个使用相同名称但接受不同类型参数的函数被定义的情况。例如，考虑这段C++代码：
- en: '[PRE28]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The function `CtoF` is defined twice. The first definition accepts an integer
    and returns a double. The second definition accepts a double (64-bit float) and
    returns a double. The `main` function then calls `CtoF`, first with an integer
    argument, and then again with a floating-point argument. The C++ compiler uses
    the argument type to match which function is called.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`CtoF`被定义两次。第一个定义接受一个整数并返回一个双精度浮点数。第二个定义接受一个双精度（64位浮点数）并返回一个双精度浮点数。然后，`main`函数调用`CtoF`，首先使用整数参数，然后再次使用浮点参数。C++编译器使用参数类型来匹配调用哪个函数。
- en: The program outputs
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 程序输出
- en: '[PRE29]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first line is from the integer version of `CtoF` and the second is from
    the double version. Note that in C++, if the only `CtoF` available to the compiler
    is the double version, both calls will return 98.6, as the compiler is smart enough
    to know it can automatically change the integer to a double to make the call succeed.
    This is not the case in general and is an example of weak typing in C++. Function
    overloading is an example of *compile-time polymorphism* because the compiler
    selects which function is evaluated while building the output executable.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行来自`CtoF`的整数版本，第二行来自双精度版本。请注意，在C++中，如果编译器只有双精度版本的`CtoF`，两次调用将返回98.6，因为编译器足够智能，可以自动将整数转换为双精度以使调用成功。这在一般情况下并非如此，并且是C++中弱类型的一个例子。函数重载是*编译时多态*的一个例子，因为编译器在构建输出可执行文件时选择要评估的函数。
- en: The final hallmark of an object-oriented language is *inheritance*. This means
    a class can inherit, or acquire, the methods of another class. We saw this above
    with `Shape` and `Circle`, which is a subclass of `Shape`. The class `Circle`
    will inherit any methods `Shape` shares, gaining that functionality for free.
    We also saw inheritance at work in the Simula example of [Chapter 1](ch01.xhtml#ch01),
    where the class `Pal` inherited the member variables of its parent class, `Person`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象语言的最后一个标志是*继承*。这意味着一个类可以继承或获取另一个类的方法。我们在上面的`Shape`和`Circle`中看到了这一点，`Circle`是`Shape`的子类。类`Circle`将继承`Shape`共享的任何方法，从而免费获得该功能。我们还在[第1章](ch01.xhtml#ch01)的Simula示例中看到了继承的工作，其中类`Pal`继承了其父类`Person`的成员变量。
- en: '***Declarative***'
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***声明式***'
- en: '*Declarative* programming, in which the programmer states *what* instead of
    explicitly *how*, comes in several flavors. We already explored one flavor in
    [Chapter 1](ch01.xhtml#ch01)—logic programming—when we discussed Prolog. In Prolog,
    the goal is presented as what needs to happen without explicit step-by-step instructions
    as to how to make it happen.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*声明式*编程，其中程序员陈述*什么*而不是明确*如何*，有几种形式。我们在[第1章](ch01.xhtml#ch01)中已经探讨了一种形式——逻辑编程——当我们讨论Prolog时。在Prolog中，目标被表述为需要发生的事情，而没有明确的逐步指导如何实现它的说明。'
- en: Functional programming languages, like SML, also from [Chapter 1](ch01.xhtml#ch01),
    fall under the declarative category as well. SML is a good example of how difficult
    it can be to assign a language to just one paradigm. Functional languages use
    functions and recursion to express the what of a program rather than imperative
    control structures like `while` loops. However, SML supports `while` loops, a
    concession to imperative programming. Other languages that are often called “functional”
    include Lisp and Scheme, and, sometimes, even Python. However, it seems better
    to say Python includes functional programming elements but isn’t a functional
    language.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程语言，如SML，同样也属于声明式范畴，我们在[第1章](ch01.xhtml#ch01)中也看到了这一点。SML很好地展示了将语言归类为一个范式是多么困难的一个例子。函数式语言使用函数和递归来表达程序的*什么*，而不是像`while`循环这样的命令控制结构。然而，SML支持`while`循环，这是对命令式编程的让步。其他经常被称为“函数式”的语言包括Lisp和Scheme，有时甚至包括Python。然而，更好地说法似乎是Python包含了函数式编程元素，但并不是一个函数式语言。
- en: Hallmarks of functional programming include treating functions as *first-class
    objects*, meaning they can be assigned to variables, and *higher-order functions*,
    functions that accept functions as arguments or return functions. Let’s review
    two examples with Python.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的特点包括将函数视为*一等公民*，这意味着它们可以被赋值给变量，并且*高阶函数*，即接受函数作为参数或返回函数的函数。让我们通过Python来回顾两个例子。
- en: In [Chapter 1](ch01.xhtml#ch01), we saw an example of currying in SML. Now,
    let’s see how currying works in Python.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml#ch01)中，我们看到了SML中柯里化的一个例子。现在，让我们看看柯里化在Python中是如何工作的。
- en: '[PRE30]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: First, we define a function called `factory`, which takes an argument and returns
    a function. Look carefully at `factory`. The function, `mult`, is defined within
    `factory` and accepts one argument, `y`. However, the body of `mult` returns `x*y`,
    with `x` being the argument to `factory`. The value of `x` used by `mult` is the
    value of `x` passed to `factory` when `factory` is called.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个名为`factory`的函数，它接受一个参数并返回一个函数。仔细看看`factory`。函数`mult`是在`factory`内部定义的，接受一个参数`y`。然而，`mult`的函数体返回`x*y`，其中`x`是调用`factory`时传递给它的参数。`mult`使用的`x`的值是在调用`factory`时传递给它的`x`的值。
- en: 'Now look at the return value of `factory` ➊: it is the function, `mult`. Moreover,
    it is `mult` in the environment of `factory`, which means `mult` is using the
    value for `x` passed to `factory`. Now we see why I chose the name: `factory`
    is a generator of functions where one argument, `x`, is fixed. Returning a nested
    function creates a *closure*, a function with a specific environment bound to
    it—namely, the value of `x`.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看 `factory` ➊ 的返回值：它是函数 `mult`。而且，它是在 `factory` 环境中的 `mult`，这意味着 `mult` 正在使用传递给
    `factory` 的 `x` 值。现在我们明白为什么我选择了这个名字：`factory` 是一个生成函数的工厂，其中一个参数 `x` 是固定的。返回一个嵌套函数创建了一个
    *闭包*，即一个绑定到特定环境中的函数——也就是 `x` 的值。
- en: The variable `mult2` is assigned whatever `factory(2)` returns ➋. However, `factory(2)`
    returns a function, `mult`, with `x=2`. The variable `mult2` holds a function
    that multiplies its argument by 2\. Likewise, `mult11` holds a function multiplying
    its argument by 11\. Therefore, the code prints `8` and `33` as output.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `mult2` 被赋值为 `factory(2)` 返回的值 ➋。然而，`factory(2)` 返回一个函数 `mult`，其中 `x=2`。变量
    `mult2` 保存了一个将其参数乘以 2 的函数。同样，`mult11` 保存了一个将其参数乘以 11 的函数。因此，代码输出 `8` 和 `33`。
- en: Our second functional example involves decorators, Python syntactic sugar for
    a higher-order function that wraps another function.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个功能示例涉及装饰器，Python 的语法糖，用于将一个函数包装成高阶函数。
- en: '[PRE31]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This example defines four functions: `mydecorator`, `afunc`, `bfunc`, and `dfunc`.
    The first function ➊ accepts a function, `f`, and returns a new function, `decorate`,
    that wraps the result of `f`. Much like how the `factory` example above created
    a closure binding the value of `x`, `decorate` binds `f` to the function passed
    to `mydecorator`. Using `*args` and `**kwargs` is Python-speak for an arbitrary
    collection of positional and keyword arguments. Therefore, `mydecorator` is a
    higher-order function because it accepts a function as an argument and returns
    a function (a closure).'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例定义了四个函数：`mydecorator`、`afunc`、`bfunc` 和 `dfunc`。第一个函数 ➊ 接受一个函数 `f`，并返回一个新的函数
    `decorate`，该函数包装了 `f` 的结果。就像上面的 `factory` 示例创建了一个闭包，将 `x` 的值绑定到函数一样，`decorate`
    将 `f` 绑定到传递给 `mydecorator` 的函数。使用 `*args` 和 `**kwargs` 是 Python 的方式，表示任意数量的位置参数和关键字参数。因此，`mydecorator`
    是一个高阶函数，因为它接受一个函数作为参数并返回一个函数（闭包）。
- en: The definition of `afunc` ➋ is preceded by `@mydecorator`. This is the syntactic
    sugar part, a readable way to use `mydecorator` with `afunc`. To show this is
    so, ➌ defines `bfunc` identical to `afunc` and then assigns the output of `mydecorator`
    `(bfunc)` to `dfunc`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`afunc` ➋ 的定义前面加上了 `@mydecorator`。这是语法糖部分，是一种可读的方式来将 `mydecorator` 应用于 `afunc`。为了证明这一点，➌
    定义了与 `afunc` 相同的 `bfunc`，然后将 `mydecorator` 的输出 `(bfunc)` 赋值给 `dfunc`。'
- en: Now, consider how `afunc` and `dfunc` work, assuming the code to be in the file
    *decorator.py*.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑 `afunc` 和 `dfunc` 如何工作，假设代码位于文件 *decorator.py* 中。
- en: '[PRE32]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Both calls return the expected value wrapped by the string `'Per your` `request...'`,
    demonstrating that the decorator `@` syntax is, in reality, a function application.
    Decorators enable adding new functionality to a function without altering the
    original function or altering source code that uses the function. Any code depending
    on `afunc` would still work as expected, assuming the decorator did something
    more valuable than intercepting the return value and printing.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 两个调用都返回了预期的值，且被字符串 `'Per your` `request...'` 包装，展示了装饰器 `@` 语法实际上是一个函数应用。装饰器使得我们能够在不改变原始函数或使用该函数的源代码的情况下，向函数添加新功能。任何依赖
    `afunc` 的代码仍然会按预期工作，假设装饰器做的事情不止是拦截返回值并打印。
- en: Many modern languages have adopted elements of functional programming. Pure
    functional languages—those that are only function calls without side effects like
    updating variable values directly—have yet to make much of a dent outside of academic
    circles. Computer scientists like pure functional languages because they are friendly
    to proving a program to be correct. In contrast, software engineers like some
    aspects of functional languages but still need the ability to easily and more
    directly implement in code thinking that conforms to how we operate—executing
    an algorithm, step by step, to reach a desired outcome.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代编程语言已经采纳了函数式编程的元素。纯函数式语言——即那些没有副作用（如直接更新变量值）的纯函数调用——在学术圈之外的影响力尚未显著。计算机科学家喜欢纯函数式语言，因为它们有助于证明程序的正确性。相反，软件工程师喜欢函数式语言的一些方面，但仍然需要能够更直接地在代码中实现符合我们操作方式的思维——一步步执行算法，以达到期望的结果。
- en: '***Array Processing***'
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数组处理***'
- en: Scientific programming makes frequent use of numerical data, which is often
    most easily organized as some form of array, be it a vector, matrix, or higher-order
    tensor. For example, image processing and deep learning with convolutional neural
    networks use 2D, 3D, and even 4D data.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 科学编程经常使用数值数据，这些数据通常最容易以某种数组形式组织，无论是向量、矩阵还是更高阶的张量。例如，图像处理和使用卷积神经网络的深度学习就涉及到二维、三维甚至四维数据。
- en: Given this, it would make sense for programming languages to process entire
    arrays en masse without explicit loops. Such languages are known as *array-processing*
    languages. In [Chapter 1](ch01.xhtml#ch01), we briefly explored the first one,
    APL. Since APL, many array-processing languages have been developed.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于此，编程语言处理整个数组时无需显式循环显得是合乎逻辑的。这样的语言被称为*数组处理*语言。在[第1章](ch01.xhtml#ch01)中，我们简要地探讨了第一个数组处理语言APL。自APL以来，许多数组处理语言已经得到了发展。
- en: Suppose I’m a deep learning researcher with a dataset of images I need to work
    with. If the images are each 512 rows by 512 columns, I can store the images in
    an array. If the image is grayscale, meaning each pixel is represented by a single
    integer, often in the byte range of [0,255], then I can use a 2D array. If I have
    a stack of images, all the same size, I can store them one on top of the other
    in a 3D array. If the images are color, I need an extra dimension for the channels,
    implying a 4D array.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我是一个深度学习研究员，手头有一组需要处理的图像数据集。如果每张图像是512行×512列，我可以将这些图像存储在一个数组中。如果图像是灰度图，意味着每个像素由一个整数表示，通常在[0,255]的字节范围内，那么我可以使用二维数组。如果我有一堆大小相同的图像，我可以将它们一个接一个地存储在一个三维数组中。如果图像是彩色的，我还需要额外的一个维度来表示颜色通道，这就意味着需要一个四维数组。
- en: A common operation with deep neural networks is scaling the input so it lies
    in the range [0,1]. If I have 100 images, each 512 rows by 512 columns, I can
    store the stack in an array that is 100 by 512 by 512\. In that case, the scaling
    operation in a language like Pascal becomes
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 深度神经网络中的常见操作是对输入进行缩放，使其位于[0,1]范围内。如果我有100张图像，每张图像是512行×512列，我可以将这些图像堆叠在一个100×512×512的数组中。在这种情况下，在像Pascal这样的语言中，缩放操作将变成：
- en: '[PRE33]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In order to access every element of the array, we need a triple loop over the
    indices of the array. It would be nice to write `A := A / 255.0;` and have the
    language just “know” that `A` is an array and automatically apply the scaling
    operation to every element of it. This is precisely what an array-processing language
    provides.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问数组的每一个元素，我们需要对数组的索引进行三重循环。理想情况下，我们希望能写出 `A := A / 255.0;`，并且让语言“知道”`A`是一个数组，自动将缩放操作应用于数组中的每一个元素。这正是数组处理语言所提供的功能。
- en: Most deep learning researchers use Python with the NumPy library. NumPy adds
    high-speed array processing to Python. Native array-processing languages are in
    widespread use as well. For example, IDL and Matlab, or their respective open
    source counterparts, GDL and Octave, were built from the ground up for array processing.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数深度学习研究人员使用Python和NumPy库。NumPy为Python添加了高速数组处理功能。原生的数组处理语言也得到了广泛应用。例如，IDL和Matlab，或其各自的开源对应物GDL和Octave，都是从一开始就为数组处理而构建的。
- en: 'Let’s use GDL to see array processing in action. On Ubuntu, install GDL with
    the following command:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GDL来展示数组处理的实际操作。在Ubuntu上，使用以下命令安装GDL：
- en: '[PRE34]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If using macOS or Windows, see the Github page for installation instructions
    at *[https://github.com/gnudatalanguage/gdl/](https://github.com/gnudatalanguage/gdl/)*.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用macOS或Windows，请参阅Github页面上的安装说明，网址为 *[https://github.com/gnudatalanguage/gdl/](https://github.com/gnudatalanguage/gdl/)*。
- en: '[Listing 2-5](ch02.xhtml#ch02list5) contains GDL code to manipulate a small
    collection of public domain test images.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-5](ch02.xhtml#ch02list5)包含了GDL代码，用于处理一小部分公共领域的测试图像。'
- en: '[PRE35]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 2-5: Image processing in GDL*'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-5：GDL中的图像处理*'
- en: The code above is in *arraydemo.pro*. To run it, enter
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码位于*arraydemo.pro*文件中。要运行它，输入
- en: '[PRE36]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `-quiet` command line argument suppresses GDL’s startup message. Use CTRL-D
    to exit GDL.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`-quiet`命令行参数可以抑制GDL的启动信息。使用CTRL-D退出GDL。'
- en: '[Listing 2-5](ch02.xhtml#ch02list5) shows two procedures, `display` and `arraydemo`.
    The procedure `display` ➊ uses GDL commands to show two images, `a` and `b`, side
    by side before writing them to disk as one image. The `tvscl` command displays
    an image with scaling to [0, 255]. The `tvrd` function returns the image in the
    current window.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-5](ch02.xhtml#ch02list5)展示了两个过程，`display`和`arraydemo`。过程`display` ➊ 使用GDL命令展示两张图像，`a`和`b`，并将它们并排显示，然后将它们作为一张图像写入磁盘。`tvscl`命令将图像显示并进行缩放到[0,
    255]范围内。`tvrd`函数返回当前窗口中的图像。'
- en: All the action is in `arraydemo`. First, we read the test images into 512×512
    pixel arrays ➋. We then take the cameraman image and invert it by subtracting
    it from 255, the largest value in a byte image ➌. The expression `255-i2` returns
    a new 512×512 array in which each element is the difference between 255 and the
    corresponding element of `i2`. The entire image has been processed with no explicit
    loops.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 所有操作都在`arraydemo`中进行。首先，我们将测试图像读入512×512像素的数组➋。然后，我们将“摄像头”图像进行反转，方法是将其从255（字节图像中的最大值）中减去➌。表达式`255-i2`返回一个新的512×512数组，其中每个元素是255与`i2`对应元素的差值。整个图像已完成处理，而无需显式的循环。
- en: Next, we alpha-blend the test images ➍. Alpha-blending is a technique that merges
    two images into one, like the image on the right in [Figure 2-3](ch02.xhtml#ch02fig3).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们对测试图像进行alpha混合处理➍。Alpha混合是一种将两张图像合并为一张图像的技术，就像[图2-3](ch02.xhtml#ch02fig3)中右侧的图像。
- en: '![Image](Images/02fig03.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/02fig03.jpg)'
- en: '*Figure 2-3: The test images (left) and a sample alpha-blend (right)*'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-3：测试图像（左）和一个示例alpha混合（右）*'
- en: The variable `m03` holds the merged *barbara.png* and *zelda.png* images. Note
    that GDL respects data types, so we first multiply one of the images by the floating-point
    value 1.0 to convert the entire expression to floating-point, thereby avoiding
    the overflow that would happen if we left everything in the byte range. The `bytscl`
    function maps its input to [0,255] to make the result fit as a grayscale image.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`m03`保存了合并后的*barbara.png*和*zelda.png*图像。请注意，GDL会遵循数据类型规则，因此我们首先将其中一张图像乘以浮点值1.0，以将整个表达式转换为浮点数，从而避免了如果我们将所有内容保留在字节范围内可能发生的溢出。`bytscl`函数将其输入映射到[0,255]，以使结果适合灰度图像。
- en: The next bit of code merges the cameraman and boat images. Unlike the previous
    blend, the images are given unequal weighting, making the cameraman image twice
    as intense as the boat image. Do review the output images created by `arraydemo`
    to see the full effect.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 下一段代码将“摄像头”图像和“船”图像合并。与之前的混合不同，这些图像赋予了不等的权重，使得“摄像头”图像的强度是“船”图像的两倍。请查看`arraydemo`创建的输出图像，以查看完整效果。
- en: For ➎, we apply a mathematical expression to the *zelda.png* image. The image
    is first scaled to [0, 1], and then each output pixel is assigned via ![Image](Images/f0075.jpg)
    for all array elements (*i*, *j* = 0, 1, *…*511). The indices are not needed because
    GDL knows to apply the same operation to every array element. In a non-array processing
    language, the expression would be a double loop over *i* and *j*.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 对于➎，我们对*zelda.png*图像应用数学表达式。首先，将图像缩放到[0, 1]，然后通过![Image](Images/f0075.jpg)为所有数组元素（*i*,
    *j* = 0, 1, *…*511）分配输出像素。由于GDL知道对每个数组元素应用相同的操作，因此不需要使用索引。在非数组处理语言中，这个表达式将会是对*i*和*j*的双重循环。
- en: A standard image processing technique involves convolving a kernel over an image.
    Convolution means sliding a smaller array (the kernel) over the larger array (the
    image), where for each position of the kernel, the output value is the sum of
    the product of the kernel with the currently overlapped image region for all elements
    in the kernel. Convolution produces an output image showing how the image responds
    to the kernel. In ➏, we apply three kernels. The first detects edges, the second
    sharpens the image, and the last is randomly generated, so each run of *arraydemo.pro*
    produces a different output. The actual convolution uses GDL’s `convol` library
    routine. The random kernel comes from `randomu`, which returns a random array
    in [0,1).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一种标准的图像处理技术涉及将内核卷积应用于图像。卷积意味着将一个较小的数组（内核）滑动到较大的数组（图像）上，对于内核的每个位置，输出值是内核与当前重叠图像区域中所有元素的乘积之和。卷积产生的输出图像显示了图像如何响应内核。在➏中，我们应用了三个内核。第一个用于检测边缘，第二个用于锐化图像，最后一个是随机生成的，因此每次运行*arraydemo.pro*都会生成不同的输出。实际的卷积使用了GDL的`convol`库函数。随机内核来自`randomu`，它返回一个在[0,1)区间内的随机数组。
- en: Array processing is a powerful paradigm, especially for scientific applications.
    Without array processing, writing code, especially research code not meant for
    long-term use, would be exceedingly tedious and error prone.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 数组处理是一种强大的范式，特别适用于科学应用。如果没有数组处理，编写代码，尤其是那些不用于长期使用的研究代码，将会异常繁琐且容易出错。
- en: '**Summary**'
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this whirlwind chapter, we presented cherry-picked essentials related to
    programming languages meant as background for the remainder of the book. We discussed
    syntax and semantics and how programming languages are implemented, both interpreters
    and compilers. We then explored data types, including primitive types and records/structures,
    after which we followed a summary of more complex data structures like lists,
    trees, and hash tables. Next, we covered variable scope and learned the difference
    between lexical and dynamic scope. We then reviewed control structures, which
    are ways of controlling and modifying program flow. The chapter then reviewed
    several important programming paradigms, including imperative, object-oriented,
    declarative, and array processing.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章节中，我们呈现了精心挑选的与编程语言相关的基本内容，为本书其余部分提供背景知识。我们讨论了语法和语义，以及编程语言的实现方式，包括解释器和编译器。接着，我们探讨了数据类型，包括原始数据类型和记录/结构，然后总结了更复杂的数据结构，如列表、树和哈希表。接下来，我们介绍了变量作用域，并学习了词法作用域和动态作用域之间的区别。随后，我们回顾了控制结构，这是控制和修改程序流程的方式。最后，本章节回顾了几种重要的编程范式，包括命令式、面向对象、声明式和数组处理。
- en: Next, let’s move on and explore a bit of computer science theory related to
    what “computability” means.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续前进，探讨一些与“可计算性”相关的计算机科学理论。
