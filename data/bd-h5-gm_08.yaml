- en: Chapter 6. Rendering Canvas Sprites
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章 渲染 Canvas 精灵
- en: Up until now, we’ve built *Bubble Shooter* with a DOM-based approach by using
    HTML elements for game objects that are styled and positioned by CSS and manipulated
    by JavaScript. In this chapter, we’ll rework *Bubble Shooter* so most of the game
    area is rendered to a canvas instead of using the DOM. Our game’s dialogs will
    remain in HTML and CSS.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，我们一直使用基于 DOM 的方法构建 *Bubble Shooter*，通过使用 HTML 元素作为游戏对象，这些对象通过 CSS 进行样式化和定位，并由
    JavaScript 进行操作。在这一章中，我们将重新构建 *Bubble Shooter*，使大部分游戏区域渲染到 Canvas 上，而不是使用 DOM。我们的游戏对话框将继续使用
    HTML 和 CSS。
- en: Canvas rendering allows us to achieve graphical effects that are often impossible
    with DOM-based development, and it can often provide a faster rendering speed.
    To use canvas rendering for *Bubble Shooter*, we need to learn how to render entire
    scenes to the canvas, maintain state, and perform frame-by-frame animations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas 渲染允许我们实现一些通常在基于 DOM 的开发中无法实现的图形效果，而且它通常能提供更快的渲染速度。为了在 *Bubble Shooter*
    中使用 Canvas 渲染，我们需要学习如何将整个场景渲染到 Canvas 上，保持状态，并执行逐帧动画。
- en: We’ll keep the existing DOM-rendering code in place for devices where the `canvas`
    element isn’t supported and provide progressive enhancement to the canvas for
    more modern browsers. We’ll do this to demonstrate the principle involved in coding
    for both canvas- and DOM-based animation and to highlight the differences between
    the two approaches.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不支持 `canvas` 元素的设备，我们将保留现有的 DOM 渲染代码，并为更现代的浏览器提供 Canvas 渲染的渐进增强。我们这么做是为了演示如何为
    Canvas 和基于 DOM 的动画编码的原则，并突出这两种方法的区别。
- en: Detecting Canvas Support
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测 Canvas 支持
- en: 'Modernizr can help us detect canvas features so we don’t have to remember multiple
    cross-browser cases. We’ll load in only a couple of extra JavaScript files for
    the canvas version and won’t delete any files. To detect the canvas and load in
    the right files, we need an extra node in `Modernizr.load` in *index.html*, which
    will check for canvas support, and if present, load JavaScript files from an array.
    Add the following before *game.js* is loaded:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Modernizr 可以帮助我们检测 Canvas 特性，这样我们就不必记住多个跨浏览器的情况。我们只需要为 Canvas 版本加载几个额外的 JavaScript
    文件，并且不会删除任何文件。为了检测 Canvas 并加载正确的文件，我们需要在 *index.html* 中的 `Modernizr.load` 里增加一个额外的节点，这将检查
    Canvas 支持情况，如果支持，将从数组中加载 JavaScript 文件。在加载 *game.js* 之前，添加以下内容：
- en: '*index.html*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*index.html*'
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The value of `Modernizr.canvas`, the parameter that `test` looks for, will be
    either `true` or `false`. If it’s `true`, the two files listed in `yep` are loaded;
    if it’s `false`, nothing new happens.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`Modernizr.canvas` 的值，即 `test` 查找的参数，将是 `true` 或 `false`。如果为 `true`，则加载 `yep`
    中列出的两个文件；如果为 `false`，则不会发生任何新的操作。'
- en: Create empty files for *renderer.js* and *sprite.js* in the *_js* folder. The
    `Renderer` object will draw the game state at each frame, and the `Sprite` class
    will perform many of the operations that we’ve been using jQuery for to date.
    We want `Renderer` to be responsible for drawing pixels onto the canvas and not
    mix up game logic with it; likewise, we’ll try to keep state information inside
    the relevant objects. This approach makes it much easier to switch between rendering
    using the canvas or the DOM, depending on what we think is best for the game.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *_js* 文件夹中为 *renderer.js* 和 *sprite.js* 创建空文件。`Renderer` 对象将在每一帧绘制游戏状态，而 `Sprite`
    类将执行我们迄今为止使用 jQuery 完成的许多操作。我们希望 `Renderer` 负责将像素绘制到 Canvas 上，而不是将游戏逻辑与其混合；同样，我们将尽量将状态信息保留在相关的对象内。这样的方法让我们可以更轻松地在
    Canvas 和 DOM 渲染之间切换，具体取决于我们认为最适合游戏的方式。
- en: Drawing to the Canvas
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制到 Canvas
- en: With HTML5’s canvas feature, you can build games at a level of sophistication
    similar to that of Flash games or even native applications. You place `canvas`
    elements into documents in the same way as other elements, such as `<div>` or
    `<img>`, but it’s the way you work with the element that makes it different. Inside
    the canvas, you have pixel-level control, and you can draw to individual pixels,
    read their values, and manipulate them. You can write JavaScript code to generate
    arcade shooters or even 3D games that are difficult to reproduce with a DOM-based
    approach.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HTML5 的 Canvas 特性，你可以构建类似 Flash 游戏甚至本地应用程序级别的游戏。你将 `canvas` 元素放入文档中的方式与其他元素（如
    `<div>` 或 `<img>`）相同，但与该元素的交互方式使其与众不同。在 Canvas 内部，你可以精确控制像素，并且可以绘制到单个像素，读取其值并对其进行操作。你可以编写
    JavaScript 代码来生成街机射击游戏，甚至是 3D 游戏，而这些是基于 DOM 的方法难以复制的。
- en: The DOM vs. The Canvas
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 与 Canvas
- en: HTML is primarily an information format; CSS was introduced as a way to format
    that information. Creating games using both technologies is really a misappropriation,
    and games like *Bubble Shooter* are feasible largely because browser vendors have
    made an effort to increase performance. Many of the processes that are invaluable
    in laying out documents, such as ensuring that text areas don’t overlap or that
    text wraps around images, are practices that we don’t need for laying out games.
    As game developers, we take on responsibility for ensuring the screen is laid
    out well, but, unfortunately for us, the browser still runs through all of these
    checks in the background.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 主要是一种信息格式；CSS 则作为一种格式化信息的方式引入。使用这两种技术创建游戏实际上是一种误用，像 *泡泡射手* 这样的游戏之所以可行，很大程度上是因为浏览器厂商致力于提高性能。许多在排版文档时非常有用的过程，例如确保文本区域不重叠或文本绕过图像，都是我们在排版游戏时不需要的。作为游戏开发者，我们要负责确保屏幕布局良好，但不幸的是，浏览器仍然会在后台执行所有这些检查。
- en: 'For example, adding or removing elements in the DOM can be a relatively expensive
    operation in terms of processing power. The reason is that if we add or remove
    something, the browser needs to inspect it to ensure that the change doesn’t have
    a domino effect on the rest of the document flow. If we were working with, say,
    an expanding menu on a website, we might want the browser to push a navigation
    area down if we add more elements to it. However, in a game it’s more likely that
    we will be using `position: absolute`, and we definitely don’t want the addition
    or removal of a new element to force everything surrounding it to be repositioned.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，在 DOM 中添加或删除元素可能是一项相对昂贵的操作，涉及到处理性能的问题。原因在于，如果我们添加或删除某些内容，浏览器需要检查这些更改，以确保它们不会对文档的其他部分产生连锁反应。如果我们在网站上工作，比如一个扩展菜单，我们可能希望浏览器在我们添加更多元素时将导航区域推下去。然而，在游戏中，我们更可能使用
    `position: absolute`，而我们肯定不希望新增或删除元素时，周围的所有内容都被重新定位。'
- en: By contrast, when the browser sees a `canvas` element, it sees just an image.
    If we change the contents of the canvas, only the contents change. The browser
    doesn’t need to consider whether this change will have a knock-on effect on the
    rest of the document.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当浏览器看到 `canvas` 元素时，它只看到了一个图像。如果我们更改 canvas 的内容，只有内容会发生变化。浏览器不需要考虑这一变化是否会对文档的其他部分产生连锁效应。
- en: 'Unlike CSS and HTML, the canvas doesn’t let you rely on the browser to keep
    track of the positions of objects on the screen. Nothing automatically deals with
    layering or rendering backgrounds when a sprite moves over them because the canvas
    outputs a flat image for the browser to display. If sprite animation and movement
    with CSS is like moving papers around on a notice wall, canvas animation is more
    like working with a whiteboard: if you want to change something or move it, you’ll
    have to erase an area and redraw it.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与 CSS 和 HTML 不同，canvas 让你无法依赖浏览器跟踪屏幕上物体的位置。没有任何自动处理图层或背景渲染的机制，因为 canvas 输出的是一个平面图像供浏览器显示。如果使用
    CSS 进行精灵动画和移动像是在布告墙上移动纸张，那么 canvas 动画就更像是使用白板：如果你想改变或移动某个东西，你必须擦除一个区域然后重新绘制它。
- en: Canvas rendering also differs from CSS layout in that positioning of elements
    can’t be offloaded to the browser. For example, with our existing DOM-based system,
    we can use a CSS transition to move the bubble visually from its firing position
    to wherever we want it to end up in the board layout. To do this takes only a
    couple of lines of code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas 渲染与 CSS 布局的另一个不同之处在于，元素的定位不能由浏览器处理。例如，在现有的基于 DOM 的系统中，我们可以使用 CSS 过渡来将气泡从它的发射位置平滑地移动到我们希望它出现在板面布局的任何位置。做到这一点只需要几行代码。
- en: Canvas rendering, on the other hand, requires us to animate frame by frame in
    a way similar to the internal workings of jQuery. We must calculate how far a
    bubble is along its path and draw it at that position each time a frame update
    occurs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Canvas 渲染要求我们逐帧动画，方式类似于 jQuery 的内部工作原理。我们必须计算气泡在路径上的位置，并在每次帧更新时在该位置绘制它。
- en: On its own, animating on the canvas using JavaScript would be no more arduous
    than JavaScript animation using the DOM without jQuery or CSS transitions to fall
    back on, but the process is made more complex by the fact that if we want to change
    the contents of the canvas, we need to delete pixels and redraw them. Ways to
    optimize the redrawing process are available, but a basic approach is to draw
    the entire canvas afresh for each animation frame. This means that, if we want
    to move an object across the canvas, we have to render not just the object that
    we want to move but possibly every object in the scene.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来说，使用 JavaScript 在画布上进行动画制作不会比在没有 jQuery 或 CSS 过渡的情况下使用 DOM 进行 JavaScript
    动画更为困难，但这个过程变得更加复杂，因为如果我们想要更改画布的内容，我们需要删除像素并重新绘制它们。虽然有一些优化重绘过程的方法，但基本的方法是为每个动画帧重新绘制整个画布。这意味着，如果我们想要在画布上移动一个物体，我们不仅要渲染我们想要移动的物体，还可能需要渲染场景中的每个物体。
- en: We’ll draw the game board and the current bubble using the canvas, but some
    components, such as dialogs, are better left as DOM elements. User interface components
    are generally easier to update as DOM elements, and the browser usually renders
    text more precisely with HTML than it would render text within a `canvas` element.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用画布绘制游戏板和当前的气泡，但某些组件，如对话框，作为 DOM 元素会更好。用户界面组件通常作为 DOM 元素更新更为方便，而且浏览器通常使用
    HTML 渲染文本时比在 `canvas` 元素中渲染文本更为精确。
- en: Now that we’ve decided to render the game with a canvas system, let’s look at
    what that will involve. The key tasks are rendering the images and maintaining
    states for each bubble so that we know which bubbles are stationary, which are
    moving, and which are in the various stages of being popped.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们决定使用画布系统来渲染游戏，接下来让我们看看这将涉及哪些内容。关键任务是渲染图像并维护每个气泡的状态，以便我们知道哪些气泡是静止的，哪些在移动，哪些处于爆破的不同阶段。
- en: Image Rendering
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像渲染
- en: 'Any image you want to draw to the canvas must be preloaded so it’s available
    to be drawn; otherwise, nothing appears. To do this, we’ll create an in-memory
    `Image` object in JavaScript, set the image source to the sprite sheet, and attach
    an `onload` event handler to it so we know when it’s finished loading. Currently,
    the game is playable once the `init` function in *game.js* has run and the New
    Game button has the `startGame` function attached to its `click` event:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 任何你想绘制到画布上的图像都必须预加载，这样它才能在绘制时可用；否则，什么也不会显示。为此，我们将在 JavaScript 中创建一个内存中的 `Image`
    对象，设置图像源为精灵图，并附加一个 `onload` 事件处理程序，以便在图像加载完成时知道。目前，只要在 *game.js* 中运行 `init` 函数，并且点击“新游戏”按钮时触发
    `startGame` 函数，游戏就可以进行：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We still want this to happen, but we don’t want it to happen until after the
    sprite sheet image has loaded. This will be the first task we’ll tackle.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然希望这样做，但我们不希望在精灵图像加载完成之前发生。这将是我们要处理的第一个任务。
- en: canvas Elements
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: canvas 元素
- en: 'Next, we need to know how to draw images onto the canvas. A `canvas` element
    is an HTML element just like any other: it can be inserted into the DOM, can have
    CSS styling applied, and behaves in much the same way as an image. For example,
    to create a `canvas` element, we add the following to *index.html*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要了解如何将图像绘制到画布上。`canvas` 元素是一个 HTML 元素，就像其他任何元素一样：它可以插入到 DOM 中，可以应用 CSS
    样式，行为也与图像类似。例如，要创建一个 `canvas` 元素，我们需要在 *index.html* 中添加以下内容：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This creates a `canvas` element with the dimensions of 1000 pixels wide by
    620 pixels high. These dimensions are important because they establish the number
    of pixels that make up the canvas. However, we should also set these dimensions
    in CSS to establish the size of the canvas as it will appear on the page:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个 `canvas` 元素，宽度为 1000 像素，高度为 620 像素。这些尺寸很重要，因为它们确定了构成画布的像素数量。然而，我们还应该在
    CSS 中设置这些尺寸，以确定画布在页面上显示的大小：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the same way that an image can be rendered at scale, the `canvas` element
    can also be scaled. By setting the CSS dimensions to the same values as the HTML
    attributes, we ensure that we’re drawing the canvas at a scale of 1:1\. If we
    omitted the CSS, the canvas would be rendered at the width and height specified
    in the attributes, but it’s good practice to specify layout dimensions within
    the style sheet. Not only does it help with code readability, but it also ensures
    that if the internal dimensions of the canvas are changed, the page layout won’t
    break.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 就像图像可以按比例渲染一样，`canvas`元素也可以缩放。通过将CSS尺寸设置为与HTML属性相同的值，我们确保画布以1:1的比例绘制。如果我们省略了CSS，画布将按照属性中指定的宽度和高度渲染，但最好在样式表中指定布局尺寸。这样不仅有助于代码的可读性，还能确保如果画布的内部尺寸发生变化，页面布局不会被打破。
- en: 'To draw an image onto the canvas using JavaScript, we first need to get a *context*,
    the object that you use to manipulate canvas contents, using the method `getContext`.
    A context tells the browser whether we’re working in two dimensions or three.
    You would write something like this to indicate you want to work in two-dimensional
    space rather than three-dimensional space:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用JavaScript将图像绘制到画布上，首先需要获取一个*上下文*，这是你用来操作画布内容的对象，通过`getContext`方法获得。上下文告诉浏览器我们是在处理二维空间还是三维空间。你可以写类似下面的代码来指示你要在二维空间中工作，而不是三维空间：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or to write this using jQuery:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用jQuery来编写如下：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that the context is a property of the DOM node, not the jQuery object,
    because we’re retrieving the first object in jQuery’s set with the `get(0)` call.
    We need the DOM node because the basic jQuery library doesn’t contain any special
    functions for working with `canvas` elements.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上下文是DOM节点的属性，而不是jQuery对象的属性，因为我们通过`get(0)`调用从jQuery集合中获取第一个对象。我们需要DOM节点，因为基本的jQuery库不包含任何处理`canvas`元素的特殊函数。
- en: 'Now, to draw the image onto the canvas, we use the `drawImage` method of the
    context object:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了将图像绘制到画布上，我们使用上下文对象的`drawImage`方法：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Or again, to write this using jQuery:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 或者再使用jQuery来编写如下：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The parameters passed into `drawImage` are the `Image` object and then *x*-
    and *y*-coordinates at which to draw the image. These are pixels relative to the
    canvas context origin. By default, (0,0) is the top-left corner of the canvas.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`drawImage`的参数是`Image`对象，然后是绘制图像的*x*和*y*坐标。这些是相对于画布上下文原点的像素。默认情况下，(0,0)是画布的左上角。
- en: 'We can also clear pixels from the canvas with the `clearRect` method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`clearRect`方法清除画布上的像素：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `clearRect` command removes all canvas pixels from the top-left corner (first
    two parameters) down to the bottom-right corner (last two parameters). Although
    you can just clear the canvas rectangle that you want to change, it’s usually
    easier to clear the entire canvas and redraw it each frame. Again, the coordinates
    are relative to the context origin.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`clearRect`命令会清除从左上角（前两个参数）到右下角（后两个参数）的所有画布像素。虽然你可以只清除你想改变的画布区域，但通常更容易清空整个画布并在每一帧重新绘制它。再次强调，坐标是相对于上下文原点的。'
- en: 'The context maintains a number of state properties about the canvas, such as
    the current line thickness, line colors, and font properties. Most important for
    drawing sprites, it also maintains the coordinates of the context origin and a
    rotation angle. In fact, you can draw an image at a set position on the canvas
    in two ways:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文维护了有关画布的多个状态属性，例如当前的线条粗细、线条颜色和字体属性。对于绘制精灵来说最重要的是，它还维护着上下文原点的坐标和旋转角度。事实上，你可以通过两种方式在画布的固定位置绘制图像：
- en: Pass *x*- and *y*-coordinates into the `drawImage` function.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将*x*和*y*坐标传入`drawImage`函数。
- en: Move the context origin and draw the image at the origin.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动上下文原点并在原点处绘制图像。
- en: In practice, you’ll see the same results with either method, but there is a
    reason it’s often best to move—or *translate*—the context origin. If you want
    to draw an image onto the canvas at an angle, it’s not the image that’s rotated
    but the canvas context that’s rotated prior to drawing the image.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，使用任何一种方法都会得到相同的结果，但通常最好将上下文的原点**移动**或*平移*。如果你想以角度将图像绘制到画布上，并不是图像本身旋转，而是画布上下文在绘制图像之前先旋转。
- en: Rotating the Canvas
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旋转画布
- en: The canvas is always rotated around its origin. If you want to rotate an image
    around its own center, first translate the canvas origin to a new origin at the
    center of the image. Then rotate the canvas by the angle at which you want to
    rotate the image *but in the opposite direction to the rotation you wanted to
    apply to the object*. Then draw the image as usual, rotate the canvas back to
    zero degrees around its new origin, and finally translate the canvas back to its
    initial origin. [Figure 6-1](ch06.html#drawing_a_rotated_image_onto_the_canvas
    "Figure 6-1. Drawing a rotated image onto the canvas") shows how this works.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 画布始终围绕其原点旋转。如果你想围绕图像的中心旋转图像，首先将画布原点平移到图像中心的新原点。然后按你希望旋转图像的角度旋转画布*但方向与你想应用于对象的旋转相反*。接着像往常一样绘制图像，旋转画布回到新原点的零度角度，最后将画布平移回初始原点。[图6-1](ch06.html#drawing_a_rotated_image_onto_the_canvas
    "图6-1. 将旋转后的图像绘制到画布上")展示了这一过程是如何工作的。
- en: 'For example, to draw an image that’s 100 pixels across at coordinates (100,100)
    and rotate it by 30 degrees around its center, you could write the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要绘制一个宽度为100像素的图像，位于坐标（100,100），并围绕其中心旋转30度，你可以写出以下代码：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Drawing a rotated image onto the canvas](httpatomoreillycomsourcenostarchimages2184531.png.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![将旋转后的图像绘制到画布上](httpatomoreillycomsourcenostarchimages2184531.png.jpg)'
- en: Figure 6-1. Drawing a rotated image onto the canvas
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1. 将旋转后的图像绘制到画布上
- en: This code retrieves the canvas ➊ and the context ➋ and then clears the canvas
    so it’s ready for drawing ➌. We next translate the origin to the coordinates at
    which we want to draw the image ➍, but we also need to add half the image’s width
    and half of its height to the translation values, because we’ll be drawing the
    center of the image at the new origin.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码获取画布➊和上下文➋，然后清空画布，准备绘制➌。接下来，我们将原点平移到我们想要绘制图像的坐标位置➍，但我们还需要将图像的宽度和高度的一半添加到平移值中，因为我们将把图像的中心绘制到新的原点。
- en: The next step is to add rotation ➎, but remember that we rotate the *context*,
    not the image. Angles are also specified in radians rather than degrees. The image
    is drawn at (-50,-50) ➏, which means that the center of the image is drawn at
    the context origin and then the context is rotated back ➐ and then translated
    back ➑. The last two steps are important because the context maintains state,
    so the next operation that’s performed on the canvas would be on the rotated coordinates.
    By reversing the rotation and the translation, we have left the canvas in the
    same state in which we found it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加旋转➎，但请记住我们旋转的是*上下文*，而不是图像。角度是以弧度而不是度数来指定的。图像被绘制在（-50,-50）➏，这意味着图像的中心绘制在上下文原点，然后上下文被旋转回去➐，再进行平移➑。最后两步很重要，因为上下文会保持状态，因此接下来的任何操作都将基于旋转后的坐标进行。通过反转旋转和平移，我们让画布保持在与最初相同的状态。
- en: 'If you don’t want to have to remember to rotate and translate the canvas back
    to its origin, you can simplify the whole process by storing the context before
    changing your image and resetting the context afterward:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想记得旋转和翻译画布回到其原点，可以通过在改变图像之前保存上下文并在之后重置上下文来简化整个过程：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The call to `context.save` ➊ saves the current state of the context, although,
    importantly, it doesn’t save the pixel data inside the canvas. Then `context.restore`
    ➋ sets it back to this saved state.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`context.save`➊保存当前的上下文状态，但需要注意，它并不会保存画布内的像素数据。然后`context.restore`➋会将上下文状态恢复为之前保存的状态。
- en: These principles are all we need to draw whole images onto the canvas and to
    remove them again, but to draw bubbles, we’ll need to draw only a small section
    of the sprite sheet at a time.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则是我们绘制完整图像到画布上并再将其移除所需的全部内容，但如果要绘制气泡，我们每次只需要绘制精灵图中的一小部分。
- en: Canvas Width and Height
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 画布的宽度和高度
- en: The canvas has its own settings for width and height, and it’s important to
    specify these when you create a `canvas` element. You could use CSS to determine
    the dimensions of the canvas as displayed on the screen, but they may not match
    the number of pixels that the canvas internally is set to render. In our case,
    we’ll make both the same, so drawing one pixel to the canvas will result in one
    pixel being displayed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 画布有自己的宽度和高度设置，在创建`canvas`元素时指定这些设置非常重要。你可以使用CSS来决定画布在屏幕上显示的尺寸，但它们可能与画布内部实际渲染的像素数不匹配。在我们的例子中，我们会将这两个设置保持一致，这样在画布上绘制一个像素就会显示一个像素。
- en: 'If we were to set the width and height of the `canvas` element to double what
    they are now, the DOM element would still take up the same amount of space on
    the page because of our CSS definition. The canvas interacts with CSS in the same
    way images do: the width and height are specified in the style sheet, but the
    canvas (or image) may be larger or smaller. The result is that the image we draw
    occupies only the top quarter of the canvas and appears to be a quarter of its
    original size. This happens because canvas pixels are scaled to screen pixels
    at render time. Try changing the `canvas` definition in *index.html* to the following
    and see what happens:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `canvas` 元素的宽度和高度设置为当前的两倍，DOM 元素仍然会占用页面上的相同空间，因为我们的 CSS 定义如此。画布与 CSS 的交互方式与图像相同：宽度和高度在样式表中指定，但画布（或图像）可能更大或更小。结果是，我们绘制的图像仅占画布的四分之一，并且看起来是原始大小的四分之一。这是因为画布像素在渲染时被缩放到屏幕像素。尝试将
    *index.html* 中的 `canvas` 定义更改为以下内容，看看会发生什么：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `canvas` element won’t appear any bigger on the screen because of the CSS
    rules. Instead, every pixel defined by CSS will be represented by 4 pixels on
    the canvas. In most desktop browsers, 1 CSS pixel is identical to 1 screen pixel,
    so there’s little benefit to setting the canvas dimensions to values larger than
    those in the CSS. However, modern devices, especially mobile ones, have become
    sophisticated in their rendering and have what is called a higher pixel density.
    This allows the device to render much-higher-resolution images. You can read more
    about pixel density at *[http://www.html5rocks.com/en/tutorials/canvas/hidpi/](http://www.html5rocks.com/en/tutorials/canvas/hidpi/)*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`canvas` 元素不会因为 CSS 规则而在屏幕上显得更大。相反，CSS 定义的每个像素将在画布上表示为 4 个像素。在大多数桌面浏览器中，1 个
    CSS 像素与 1 个屏幕像素是相同的，所以将画布尺寸设置为比 CSS 中定义的更大的值没有太大意义。然而，现代设备，特别是移动设备，已经在渲染方面变得非常精密，具备了所谓的更高像素密度。这使得设备能够渲染更高分辨率的图像。你可以在
    *[http://www.html5rocks.com/en/tutorials/canvas/hidpi/](http://www.html5rocks.com/en/tutorials/canvas/hidpi/)*
    阅读更多关于像素密度的内容。'
- en: 'When you’re working with the canvas and CSS together, you need to remember
    which scale you’re working at. If you’re working within the canvas, it’s the dimensions
    of the canvas, as specified by its HTML attributes, that are important. When working
    with CSS elements around—or possibly even on top of—the canvas, you’ll be using
    CSS pixel dimensions. For example, to draw an image at the bottom-right of a canvas
    that is 2000 pixels wide and 1240 pixels high, you would use something like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在使用画布和 CSS 一起工作时，你需要记住你正在使用的缩放比例。如果你在画布内工作，那么重要的是画布的尺寸，正如其 HTML 属性所指定的那样。当你在画布周围（或可能甚至在画布上方）使用
    CSS 元素时，你将使用 CSS 像素尺寸。例如，要在宽度为 2000 像素、高度为 1240 像素的画布右下角绘制图像，你可以使用类似这样的代码：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But to place a DOM element at the bottom-right corner, you would use the coordinates
    (1000,620), such as in the following CSS:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，要将 DOM 元素放置在右下角，你将使用坐标 (1000, 620)，如下所示的 CSS：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If possible, it’s generally easiest to keep your screen display canvas size
    (set in the CSS) and the width and height definitions for the canvas the same
    so the canvas renderer doesn’t have to try to scale pixels. But if you’re targeting
    devices with high pixel densities (such as Apple Retina displays), you can improve
    the quality of your graphics by experimenting with increasing the number of pixels
    in the canvas.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，通常最好保持屏幕显示画布的大小（在 CSS 中设置）与画布的宽度和高度定义相同，这样画布渲染器就不需要尝试缩放像素。但是，如果你目标设备的像素密度较高（例如苹果的
    Retina 显示器），你可以通过尝试增加画布中像素的数量来提高图形的质量。
- en: Sprite Rendering
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精灵渲染
- en: We can’t use background images and position offsets to render bubble sprites,
    as we did with our DOM-based system. Instead, we need to draw the bubble sprites
    as images onto the canvas. Remember that the sprite image file contains all four
    bubble colors in both resting and popping states. For example, in the sprite image
    shown in [Figure 6-2](ch06.html#clip_boundary_required_to_draw_a_blue_bu "Figure 6-2. Clip
    boundary required to draw a blue bubble onto the board"), if we want to draw a
    blue bubble onto the board, we are interested in only the section of the image
    surrounded by the dotted line. To select only this part of the image, we’ll use
    the clip parameters that can be passed into the `drawImage` method of a canvas
    context.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能像在基于 DOM 的系统中那样使用背景图片和位置偏移来渲染气泡精灵。相反，我们需要将气泡精灵作为图片绘制到画布上。记住，精灵图像文件包含了四种气泡颜色，在静止和弹出的状态下都有。例如，在[图
    6-2](ch06.html#clip_boundary_required_to_draw_a_blue_bu "图 6-2. 绘制蓝色气泡到画布上所需的剪裁边界")中显示的精灵图像中，如果我们想将一个蓝色气泡绘制到画布上，我们只关心图像中被虚线框住的部分。为了只选择这部分图像，我们将使用可以传递给画布上下文的
    `drawImage` 方法的剪裁参数。
- en: '![Clip boundary required to draw a blue bubble onto the board](httpatomoreillycomsourcenostarchimages2184533.png.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![绘制蓝色气泡到画布上所需的剪裁边界](httpatomoreillycomsourcenostarchimages2184533.png.jpg)'
- en: Figure 6-2. Clip boundary required to draw a blue bubble onto the board
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-2. 绘制蓝色气泡到画布上所需的剪裁边界
- en: If we want to draw the bubble in the first stage of being popped, we would move
    the clip area to the right. This is similar to the way we display bubbles in the
    DOM version except that, rather than letting the boundaries of a `div` element
    define the clip boundaries, we’ll specify them in JavaScript.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想绘制气泡在被弹出的第一阶段，我们将把剪裁区域向右移动。这与我们在 DOM 版本中显示气泡的方式类似，不同之处在于，我们不会让 `div` 元素的边界定义剪裁边界，而是直接在
    JavaScript 中指定这些边界。
- en: 'To draw a clipped image to the canvas, add a couple more parameters to the
    `drawImage` method. Previously, we used `drawImage` with only three parameters
    (the `Image` object and *x*- and *y*-coordinates), but we can pass it a few more
    to clip the image. The full set of parameters that `drawImage` accepts are these:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要将剪裁后的图像绘制到画布上，只需向 `drawImage` 方法添加几个参数。之前，我们只用三个参数（`Image` 对象和 *x*、*y* 坐标）调用
    `drawImage`，但现在可以传递更多参数来剪裁图像。`drawImage` 接受的完整参数集如下：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The parameters are as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '****`img`****. The `Image` object.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`img`****。`Image` 对象。'
- en: '****`sx` and `sy`****. The *x*- and *y*-coordinates at which to clip the image
    relative to the image’s origin. For a blue bubble in its nonpopping state, these
    values would be 0 and 50, respectively.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`sx` 和 `sy`****。剪裁图像相对于图像原点的 *x* 和 *y* 坐标。对于静止状态下的蓝色气泡，这些值分别为 0 和 50。'
- en: '****`swidth` and `sheight`****. The width and height of the clip area. For
    our bubble sprite sheet, these values will both be 50.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`swidth` 和 `sheight`****。剪裁区域的宽度和高度。对于我们的气泡精灵图，两个值都将为 50。'
- en: '****`x` and `y`****. The coordinates to draw the image on the canvas relative
    to the canvas context origin.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`x` 和 `y`****。绘制图像在画布上的坐标，相对于画布上下文原点。'
- en: '****`width` and `height`****. The width and height of the image to draw. We
    can use these parameters to scale an image, or we can omit them if we want the
    image to be drawn at 1:1.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`width` 和 `height`****。要绘制的图像的宽度和高度。我们可以使用这些参数来缩放图像，或者如果希望图像按 1:1 的比例绘制，则可以省略它们。'
- en: 'For example, to draw the blue bubble highlighted in [Figure 6-2](ch06.html#clip_boundary_required_to_draw_a_blue_bu
    "Figure 6-2. Clip boundary required to draw a blue bubble onto the board") at
    the coordinates (200,150) on the canvas, we would use the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在画布的坐标 (200,150) 上绘制图 6-2 中突出显示的蓝色气泡，我们将使用以下代码：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This line of code assumes the sprite `Image` object is named `spriteSheet` and
    the sprite is 50 pixels wide and 50 pixels high.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码假设精灵 `Image` 对象命名为 `spriteSheet`，且精灵的宽度和高度均为 50 像素。
- en: Defining and Maintaining States
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和维护状态
- en: In the DOM-based version of the game code, we don’t have to think about bubble
    state; we just queue up events with timeouts and animate/callback chains. Once
    a bubble is drawn to the screen at a fixed position, we leave it as is unless
    we need to change it. The bubble will be drawn in the same spot until we tell
    the browser to do something else with it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 DOM 的游戏代码版本中，我们不需要考虑气泡的状态；我们只需使用超时队列事件和动画/回调链。一旦气泡被绘制到屏幕上的固定位置，我们就保持它的状态，除非需要进行修改。气泡会一直在同一位置绘制，直到我们告诉浏览器做其他事情。
- en: But when we switch to canvas rendering, we need to render each bubble, with
    the correct sprite, on each frame redraw. Our code must track the state of all
    bubbles on the screen, whether they’re moving, popping, falling, or just stationary.
    Each `bubble` object will track its current state and how long it’s been in that
    state. We need that duration for when we draw the frames of the popping animation.
    The `Board` object currently keeps track of bubbles in the main layout, and we
    need to add to it so we can also keep track of those bubbles that are popping,
    falling, or firing.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当我们切换到画布渲染时，我们需要在每一帧重绘时为每个气泡渲染正确的精灵。我们的代码必须追踪屏幕上所有气泡的状态，无论它们是移动、爆炸、下落还是静止。每个
    `bubble` 对象将追踪其当前状态以及在该状态中停留的时间。我们需要这个持续时间来绘制爆炸动画的帧。`Board` 对象目前跟踪主要布局中的气泡，我们需要对其进行扩展，以便也能追踪那些正在爆炸、下落或发射的气泡。
- en: Preparing the State Machine
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备状态机
- en: 'To maintain bubble state, we’ll first create a set of constants that refer
    to a bubble’s state. This is referred to as using a *state machine*, which you’re
    likely to find increasingly useful as the complexity of your games increases.
    The basic principles of using a state machine, as related to this game, are as
    follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持气泡的状态，我们首先会创建一组常量，用来表示气泡的状态。这就叫做使用 *状态机*，随着游戏复杂度的增加，你可能会发现它越来越有用。使用状态机的基本原则，在本游戏中的应用如下：
- en: A bubble can exist in a number of states, such as moving, popping, or falling.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个气泡可以处于多种状态，例如移动、爆炸或下落。
- en: The way a bubble reacts in the game will depend on the state it’s in. For example,
    we don’t want the bubble being fired to collide with a bubble being popped.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 气泡在游戏中的反应将取决于它所处的状态。例如，我们不希望发射的气泡与正在爆炸的气泡发生碰撞。
- en: The way a bubble is displayed may depend on its state, particularly if it’s
    being popped.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 气泡的显示方式可能取决于其状态，特别是在它正在爆炸时。
- en: A bubble can be in only one state at a time; it can’t be popped and popping
    at the same time, or popping and falling simultaneously.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个气泡一次只能处于一种状态；它不能同时处于爆炸状态和被爆炸状态，或者同时处于爆炸状态和下落状态。
- en: Once we have the state machine set up, we’ll know what we need to do to a bubble
    in any given situation. Some changes of state occur as a result of a user’s actions,
    such as when they fire the bubble, but we’ll also store the timestamp when a bubble
    enters a state. As a result, we can determine when the bubble should be moved
    from one state to another automatically, such as when we’re in the process of
    popping it after a collision.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好状态机，我们就能知道在任何给定情况下该如何处理气泡。一些状态的变化是由用户操作引起的，例如当他们发射气泡时，但我们也会记录气泡进入某个状态时的时间戳。因此，我们可以自动判断气泡何时应该从一个状态转移到另一个状态，例如在碰撞后，我们正处于爆炸过程中。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In general, even if you think your game will be relatively simple, it’s worth
    using a state machine as a way to manage complexity that you may not have thought
    of yet.*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*一般来说，即使你认为你的游戏相对简单，使用状态机来管理你可能还没想到的复杂性是值得的。*'
- en: 'Add the following to *bubble.js*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到 *bubble.js*：
- en: '*bubble.js*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*bubble.js*'
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These additions allow us to store and retrieve the bubble’s current state ➋,
    which will be one of the eight states at the top of the class ➊. Whenever we change
    a bubble’s state ➌, we also record the timestamp when it entered that state ➍.
    Once we determine how long the bubble has been in its current state ➎, we can
    work out what to draw. For example, the amount of time a bubble has spent in the
    `POPPING` state determines which frame of the popping sequence to display.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新增内容使我们能够存储和检索气泡的当前状态 ➋，该状态将是类顶部的八个状态之一 ➊。每当我们更改气泡的状态 ➌时，我们还会记录它进入该状态时的时间戳
    ➍。一旦我们确定气泡在当前状态中停留的时间 ➎，我们就可以确定需要绘制的内容。例如，气泡在 `爆炸` 状态中停留的时间决定了显示哪个爆炸序列的帧。
- en: Implementing States
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现状态
- en: 'Each bubble can have one of the following states, which we’ll need to implement:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个气泡可以有以下状态之一，我们需要实现这些状态：
- en: '| **`CURRENT`** | Waiting to be fired. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **`CURRENT`** | 等待发射。 |'
- en: '| **`ON_BOARD`** | Already part of the board display. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **`ON_BOARD`** | 已经是棋盘显示的一部分。 |'
- en: '| **`FIRING`** | Moving toward the board or off the screen. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **`FIRING`** | 向棋盘或屏幕外移动。 |'
- en: '| **`POPPING`** | Being popped. This will display one of the popping animation
    frames. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **`POPPING`** | 正在爆裂。这将显示爆裂动画的一个帧。 |'
- en: '| **`FALLING`** | An orphaned bubble that’s falling from the screen. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **`FALLING`** | 一个孤立的气泡正在从屏幕上掉落。 |'
- en: '| **`POPPED`** | Done `POPPING`. A popped bubble doesn’t need to be rendered.
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **`POPPED`** | 完成`POPPING`。被爆裂的气泡不需要渲染。 |'
- en: '| **`FIRED`** | Missed the board display after `FIRING`. A fired bubble doesn’t
    need to be rendered. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **`FIRED`** | 在`FIRING`后错过了棋盘显示。一个发射的气泡不需要被渲染。 |'
- en: '| **`FALLEN`** | Done `FALLING` off the screen. A fallen bubble doesn’t need
    to be rendered. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **`FALLEN`** | 完成`FALLING`并掉出屏幕。一个掉落的气泡不需要渲染。 |'
- en: The bubbles displayed in the board at the beginning of a level start out in
    the `ON_BOARD` state, but all other bubbles will start in the `CURRENT` state
    and move into one of the other states, as shown in [Figure 6-3](ch06.html#flowchart_showing_bubble_states
    "Figure 6-3. Flowchart showing bubble states").
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开始时棋盘上显示的气泡最初处于`ON_BOARD`状态，但所有其他气泡将从`CURRENT`状态开始，并转移到其他状态，如[图6-3](ch06.html#flowchart_showing_bubble_states
    "图6-3. 显示气泡状态的流程图")所示。
- en: 'We’ll add a couple of arrays to `Game` to keep track of those. At the top of
    the class, add:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`Game`中添加几个数组来跟踪这些状态。在类的顶部，添加：
- en: '*game.js*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This new array ➊ will contain all of the bubbles in the game, both on and off
    the board layout. Initially, every bubble is part of the board, so the board contents
    can be used to populate the array ➋. Each time we call `getNextBubble`, the bubble
    that’s ready to fire needs to be added ➌ and have its state set to `CURRENT` ➍.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新数组 ➊ 将包含游戏中所有的气泡，包括在棋盘上的和不在棋盘上的。最初，每个气泡都是棋盘的一部分，因此可以使用棋盘内容来填充数组 ➋。每次调用`getNextBubble`时，准备发射的气泡需要被添加
    ➌，并将其状态设置为`CURRENT` ➍。
- en: '![Flowchart showing bubble states](httpatomoreillycomsourcenostarchimages2184535.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![显示气泡状态的流程图](httpatomoreillycomsourcenostarchimages2184535.png)'
- en: Figure 6-3. Flowchart showing bubble states
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-3. 显示气泡状态的流程图
- en: '`board.getBubbles` is a new method that will return all of the bubbles in the
    rows and columns of the board as a single flat array, so add it to *board.js*:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`board.getBubbles`是一个新方法，它将返回棋盘上所有行和列中的气泡，作为一个单一的平面数组，因此请将其添加到*board.js*中：'
- en: '*board.js*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*board.js*'
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We also need to set the state of bubbles that are on the board to `ON_BOARD`,
    so make this change to the `createLayout` function in the same file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将棋盘上气泡的状态设置为`ON_BOARD`，因此请在同一文件中的`createLayout`函数中进行此更改：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`bubble.setState` handles the setup, which contains the states of `CURRENT`
    and `ON_BOARD`, but we also need to be able to change the state of a bubble.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`bubble.setState`处理设置，其中包括`CURRENT`和`ON_BOARD`的状态，但我们还需要能够改变气泡的状态。'
- en: 'The two states of `FIRING` and `FIRED` will be set inside `fireBubble` in *ui.js*.
    Amend the function as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`FIRING`和`FIRED`这两个状态将在*ui.js*中的`fireBubble`内设置。请按如下方式修改该函数：'
- en: '*ui.js*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*ui.js*'
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When the bubble is initially fired, we set the state to `FIRING` ➊. If the bubble
    reaches the board, we set it to `ON_BOARD` ➋, but if it hasn’t settled into a
    row and column, that means it missed the board, in which case it becomes `FIRED`
    ➌.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当气泡最初被发射时，我们将其状态设置为`FIRING` ➊。如果气泡到达棋盘，我们将其状态设置为`ON_BOARD` ➋，但如果它还没有稳定在某一行和列上，那么它就错过了棋盘，此时它的状态变为`FIRED`
    ➌。
- en: 'The other states will be set in *game.js*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 其他状态将在*game.js*中设置：
- en: '*game.js*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In `popBubbles`, we set every bubble to `POPPING` ➊, and then after 200 milliseconds,
    when the popping animation has finished, we set them to `POPPED` ➋. In `dropBubbles`,
    we set them to `FALLING` ➌, and then when they’ve finished falling at the end
    of the `kaboom` process, they become `FALLEN` ➍.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`popBubbles`中，我们将每个气泡的状态设置为`POPPING` ➊，然后在200毫秒后，当爆裂动画完成时，我们将其状态设置为`POPPED`
    ➋。在`dropBubbles`中，我们将其状态设置为`FALLING` ➌，然后在`kaboom`过程结束时，当它们完成下落后，它们变为`FALLEN`
    ➍。
- en: Now that bubbles know which state they’re in at any point in the game, we can
    start to render them onto a canvas.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，气泡知道它们在游戏中的任何时刻处于哪种状态，我们可以开始将它们渲染到画布上。
- en: Sprite Sheets and the Canvas
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精灵图和画布
- en: We can use the existing sprite sheet PNG (*bubble_sprite_sheet.png*) from the
    CSS version of the game when we draw to the canvas, although we need to work with
    it in a different way. Rather than shifting the sprite sheet around like a background
    image, we’ll draw part of the image that shows the correct bubble in the correct
    animation state. Our loading sequence will also change because we need to make
    sure that the sprite image is loaded before starting the game.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用游戏的CSS版本中现有的精灵图PNG (*bubble_sprite_sheet.png*) 来绘制canvas，尽管我们需要以不同的方式处理它。我们不会像处理背景图像那样移动精灵图，而是绘制图像的一部分，显示正确的气泡及其正确的动画状态。我们的加载顺序也会改变，因为我们需要确保精灵图在游戏开始前已被加载。
- en: We’ll make a new object called `Renderer` to handle drawing to the canvas, and
    we’ll give it its own `init` method, which will preload the sprite sheet, and
    call that method within `game.init`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的对象`Renderer`来处理渲染到canvas的操作，并为它定义一个`init`方法，该方法将预加载精灵图，并在`game.init`中调用该方法。
- en: 'Change the `init` method in *game.js* to the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将*game.js*中的`init`方法更改为如下内容：
- en: '*game.js*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, we check if `BubbleShoot.Renderer` exists ➊. If the `Modernizr.canvas`
    test passes when we load in scripts, the object will exist; if canvas isn’t supported,
    the object won’t exist.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查`BubbleShoot.Renderer`是否存在 ➊。 如果加载脚本时`Modernizr.canvas`测试通过，那么该对象将存在；如果不支持canvas，该对象则不存在。
- en: Then we call a `Renderer.init` method and pass it a function as its only parameter
    ➋. This is the function that attaches `startGame` to the New Game button ➌.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`Renderer.init`方法，并将一个函数作为唯一参数传入 ➋。这个函数将`startGame`附加到“新游戏”按钮 ➌。
- en: 'Now we need to write the `Renderer` object. In the blank *renderer.js* file,
    add the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要编写`Renderer`对象。在空白的*renderer.js*文件中，添加以下代码：
- en: '*renderer.js*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*renderer.js*'
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We first create variables to hold the canvas that we’ll use to render the game
    area ➊ and a reference to its rendering context, so we don’t have to call `canvas.getContext("2d")`
    constantly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建变量来保存用于渲染游戏区域的canvas ➊，以及它的渲染上下文引用，这样我们就不需要不断调用`canvas.getContext("2d")`。
- en: In the `init` method, we accept the callback function as a parameter ➋, create
    the `canvas` DOM element ➌, and then prepend it in the game `div` ➍. We also explicitly
    set the width and height attributes of the `canvas` ➎. Remember that these attributes
    define the number of pixels and the boundaries of the canvas internally, so for
    simplicity, we set them to the same dimensions as those rendered to the screen.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init`方法中，我们将回调函数作为参数 ➋，创建`canvas` DOM元素 ➌，然后将其添加到游戏的`div`中 ➍。我们还显式地设置`canvas`的宽度和高度属性
    ➎。请记住，这些属性定义了canvas内部的像素数量和边界，因此为了简化起见，我们将它们设置为与渲染到屏幕上的尺寸相同。
- en: 'That will create the `canvas` element for us and prime a context ready to be
    drawn into. We need to set the width and height of `game_canvas`, so add the following
    into *main.css*:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们创建`canvas`元素，并准备好一个可以绘制的上下文。我们需要设置`game_canvas`的宽度和高度，因此请将以下内容添加到*main.css*中：
- en: '*main.css*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*main.css*'
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The DOM-rendered version uses jQuery to move objects around the screen, but
    we won’t have DOM elements to manipulate inside a canvas, so there’s nothing for
    jQuery to work with. Hence, we’ll have to keep track of the position of every
    bubble on the screen with new code. Much of this will happen inside the new *sprite.js*
    file we’ve created.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: DOM渲染版本使用jQuery来在屏幕上移动对象，但在canvas内我们没有DOM元素可以操作，因此没有任何内容可以供jQuery处理。因此，我们必须通过新的代码来跟踪每个气泡在屏幕上的位置。大部分工作将在我们创建的新*sprite.js*文件中完成。
- en: 'Multiple Rendering Methods: Two Approaches'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 多种渲染方法：两种方案
- en: If you need to support different rendering methods, as we are here, you can
    take two approaches. First, you can create a class for each rendering method and
    provide identical sets of methods and properties so they can be used interchangeably.
    This is what we’re doing with *Bubble Shooter*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要支持不同的渲染方法，就像我们这里所做的，你可以采用两种方案。首先，你可以为每种渲染方法创建一个类，并提供相同的方法和属性集，以便它们可以互换使用。这正是我们在*Bubble
    Shooter*中所做的。
- en: 'Second, you can create a single class for both rendering methods and then have
    code inside that branches depending on which rendering method is supported. The
    new class may act as just a wrapper for a different class for each method. For
    example, for *Bubble Shooter*, we could create something like the following pseudocode:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，你可以为两种渲染方法创建一个类，然后在该类内部根据支持的渲染方法编写分支代码。这个新类可能只是为每种方法包装不同的类。例如，对于*Bubble Shooter*，我们可以创建如下的伪代码：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we would pass in some kind of identifier to an object constructor ➊ and
    then branch the code depending on how we’ll render the game ➋. We would need new
    functions to return either a `Sprite` ➌ or a `jQuery` ➍ object, which would be
    stored inside the class in `wrappedObject`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们会将某种标识符传递给对象构造函数 ➊，然后根据我们将如何渲染游戏来分支代码 ➋。我们将需要新的函数来返回一个 `Sprite` ➌ 或一个
    `jQuery` ➍ 对象，这些对象将存储在类中的 `wrappedObject` 内。
- en: From then on, if we wanted to find the position of the object, we would call
    the `position` method ➎ and know we would get correct data whether the object
    was being rendered in the DOM or on the canvas.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，如果我们想要查找对象的位置，我们会调用 `position` 方法 ➎，并且可以知道无论对象是在 DOM 中还是在画布上渲染，都会得到正确的数据。
- en: The main reason we’re not taking this approach with *Bubble Shooter* is that
    we have only one type of sprite—the bubbles on the screen. These are represented
    well enough by the `Bubble` class, which acts as a wrapper anyway. However, if
    we were dealing with many different kinds of sprites, we might want to split the
    structure more explicitly.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不采用这种方法的主要原因是，*Bubble Shooter* 中只有一种类型的精灵——屏幕上的气泡。这些精灵由 `Bubble` 类很好地表示，它本身就充当了一个包装器。然而，如果我们处理的是多种不同类型的精灵，我们可能会希望更明确地拆分结构。
- en: We’ll write *sprite.js* so that canvas sprites can be called with the same methods
    that we’re using on jQuery sprites. The main methods we’ve been calling are `position`,
    `width`, `height`, and `css`, and if we create implementations of these in *sprite.js*,
    the `Sprite` class will look like a jQuery object as far as the rest of our code
    is concerned.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写 *sprite.js*，使得画布精灵可以使用与 jQuery 精灵相同的方法进行调用。我们一直在调用的主要方法有 `position`、`width`、`height`
    和 `css`，如果我们在 *sprite.js* 中创建这些方法的实现，`Sprite` 类看起来就像一个 jQuery 对象，对我们其余代码的影响是一样的。
- en: 'Add the following to *sprite.js*:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到 *sprite.js* 中：
- en: '*sprite.js*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*sprite.js*'
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we’ve created an object that implements many of the methods that we access
    for jQuery objects. We have left and top coordinates ➊ and a `position` method
    ➋ that returns those coordinates in the same way that a call to jQuery’s `position`
    method would. The `setPosition` method can set the top and left coordinates ➌
    or do nothing if other values are passed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个对象，实现了我们访问 jQuery 对象时使用的许多方法。我们有左坐标和上坐标 ➊ 以及一个返回这些坐标的 `position`
    方法 ➋，这个方法的返回方式与调用 jQuery 的 `position` 方法相同。`setPosition` 方法可以设置上坐标和左坐标 ➌，如果传入其他值则不做任何操作。
- en: In our DOM-based version of the game, we call the `css` method to set the screen
    coordinates of an object. `setPosition` has been constructed to accept the same
    arguments as the `css` method, and to spare us from having to rewrite code anywhere
    that the `css` method is called and using `setPosition` for the canvas version,
    we can create a `css` method of Sprite and alias it to `setPosition` ➍.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们基于 DOM 的游戏版本中，我们调用 `css` 方法来设置对象的屏幕坐标。`setPosition` 已经构建成接受与 `css` 方法相同的参数，为了避免在调用
    `css` 方法的地方重写代码，并且在画布版本中使用 `setPosition`，我们可以为 Sprite 创建一个 `css` 方法并将其别名为 `setPosition`
    ➍。
- en: The `width` ➎ and `height` ➏ methods return the values defined for a bubble’s
    dimensions in *ui.js*. Finally, we define empty methods for `removeClass`, `addClass`,
    and `remove`, which maintain compatibility with a lot of our existing code ➐.
    Anywhere these last methods are called will not affect the display but will also
    not throw an error.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`width` ➎ 和 `height` ➏ 方法返回在 *ui.js* 中为气泡的尺寸定义的值。最后，我们为 `removeClass`、`addClass`
    和 `remove` 定义了空方法，这些方法与我们现有的很多代码保持兼容性 ➐。调用这些方法的地方不会影响显示，但也不会抛出错误。'
- en: 'When a bubble is created, we need to decide whether to create a jQuery object
    or an instance of `Sprite`, depending on whether we’re rendering using the DOM
    or canvas. We’ll do this inside the bubble creation process in *bubble.js*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个气泡被创建时，我们需要决定是创建一个 jQuery 对象还是一个 `Sprite` 实例，这取决于我们是使用 DOM 还是画布进行渲染。我们将在
    *bubble.js* 中的气泡创建过程中执行此操作：
- en: '*bubble.js*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*bubble.js*'
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code checks again that the `Renderer` object is loaded ➊ (which happens
    if canvas is enabled) and, if not, continues the DOM-based path. Otherwise, we
    make a new `Sprite` object ➋. With this in place, a call to `curBubble.getSprite`
    will return a valid object no matter whether we’re using jQuery with CSS or a
    pure canvas route.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码再次检查 `Renderer` 对象是否已加载 ➊（如果启用了画布的话会发生这种情况），如果没有，它将继续执行基于 DOM 的路径。否则，我们会创建一个新的
    `Sprite` 对象 ➋。有了这个，调用 `curBubble.getSprite` 时，无论我们是使用 jQuery 和 CSS 还是纯画布方式，都能返回一个有效的对象。
- en: 'The last part of initializing the `Sprite` objects is to make sure they have
    the correct onscreen coordinates. In the DOM version of the game, we set these
    in the CSS, but with the canvas, we have to set them in JavaScript code. These
    will be set in the `createLayout` function in *board.js*:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化`Sprite`对象的最后一步是确保它们具有正确的屏幕坐标。在游戏的DOM版本中，我们通过CSS设置这些坐标，但在画布中，我们必须通过JavaScript代码来设置这些坐标。这些坐标将会在*board.js*中的`createLayout`函数中设置：
- en: '*board.js*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*board.js*'
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If the renderer exists ➊, we calculate the left and top coordinates of where
    the bubble should be displayed ➋ and then set the sprite’s properties to those
    values ➌.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果渲染器存在 ➊，我们计算气泡应显示的左上角坐标 ➋，然后将精灵的属性设置为这些值 ➌。
- en: 'The current bubble also needs its position set, so this will happen inside
    `getNextBubble` in *game.js*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当前气泡也需要设置其位置，因此这将在*game.js*中的`getNextBubble`函数内进行：
- en: '*game.js*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We now have all bubble positions tracked and know their state at all times.
    We can also manipulate a sprite representation, but nothing will appear on the
    screen just yet. In the next section, we’ll render our sprites to the canvas.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经追踪了所有气泡的位置，并且随时了解它们的状态。我们还可以操作精灵表示，但目前屏幕上什么都不会出现。在下一部分，我们将把精灵渲染到画布上。
- en: The Canvas Renderer
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 画布渲染器
- en: To animate anything on the canvas, we need to clear pixels before each redraw.
    To render the game, we’ll use `setTimeout` with a timer to redraw the position
    and state of every bubble on a frame-by-frame basis. This process will be the
    same for just about any game you build and, certainly, for anything where the
    display is constantly being updated. In theory, we only need to redraw the canvas
    when information on the screen has changed; in practice, working out when there’s
    new information to show can be difficult. Fortunately, canvas rendering is so
    fast that there’s generally no reason not to just update the display as often
    as possible.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要在画布上动画化任何东西，我们需要在每次重新绘制之前清除像素。为了渲染游戏，我们将使用`setTimeout`和计时器，以逐帧的方式重新绘制每个气泡的位置和状态。这个过程几乎适用于任何你构建的游戏，尤其是那些需要不断更新显示的游戏。从理论上讲，我们只需在屏幕上的信息发生变化时重新绘制画布；但实际上，弄清楚何时有新信息需要显示可能会很困难。幸运的是，画布渲染速度非常快，所以通常没有理由不尽可能频繁地更新显示。
- en: 'We’ll store the value of the timeout ID returned by `setTimeout` so we know
    whether or not the frame counter is running. This will happen at the top of *game.js*
    in a new variable called `requestAnimationID`, where we’ll also store a timestamp
    for when the last animation occurred:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将存储`setTimeout`返回的超时ID值，这样就能知道帧计数器是否正在运行。这将在*game.js*的顶部通过一个名为`requestAnimationID`的新变量进行存储，同时我们还会存储上次动画发生的时间戳：
- en: '*game.js*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We add the two variables ➊, and if the `Renderer` object exists ➋, we start
    the timeout running to draw the first animation frame ➌.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个变量 ➊，如果`Renderer`对象存在 ➋，我们开始启动超时计时器，绘制第一个动画帧 ➌。
- en: We haven’t written `renderFrame` yet, but before we do, we’ll write a method
    in *renderer.js* to draw all of the bubbles. The method will accept an array of
    `bubble` objects as an input.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有编写`renderFrame`，但在此之前，我们将在*renderer.js*中编写一个方法来绘制所有气泡。这个方法将接受一个`bubble`对象的数组作为输入。
- en: 'First we need to load the bubble images into *renderer.js*:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将气泡图像加载到*renderer.js*中：
- en: '*renderer.js*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*renderer.js*'
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We create a variable to hold the image data ➊ and define another variable for
    the width and height of each bubble image ➋. The dimensions will tell us where
    to crop each image within the sprite sheet. We then load in the image file ➌,
    and the callback function that’s passed into `init` is triggered after the image
    has loaded ➍.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个变量来存储图像数据 ➊，并定义另一个变量来表示每个气泡图像的宽度和高度 ➋。这些尺寸将告诉我们如何在精灵图集中裁剪每张图像。然后我们加载图像文件
    ➌，在图像加载完成后传入`init`的回调函数会被触发 ➍。
- en: Next we’ll create the function to draw the sprites onto the canvas.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个函数，将精灵绘制到画布上。
- en: '*renderer.js*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*renderer.js*'
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: First, we create a render method that accepts an array of `Bubble` objects ➊.
    We then clear the canvas and offset the context by 120 pixels so the board display
    is drawn in the center of the screen. The code then loops over each bubble in
    the array ➋ and defines an (*x*,*y*) coordinate from which to extract the bubble’s
    sprite from the image ➌. The *x*-coordinate always starts at zero until we add
    frames for the popping animation, and the *y*-coordinate is the bubble type (0
    to 3) multiplied by the height of a bubble image (50 pixels). We pass this information
    along with the bubble’s `Sprite` object to another new method called `drawSprite`
    ➍ before resetting the context position.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个渲染方法，它接受一个 `Bubble` 对象的数组 ➊。然后，我们清除画布并将上下文偏移 120 像素，以便棋盘显示在屏幕的中央。接着，代码会循环遍历数组中的每个气泡
    ➋，并定义一个 (*x*,*y*) 坐标，从中提取气泡的精灵图像 ➌。*x* 坐标始终从零开始，直到我们为弹出动画添加帧，而 *y* 坐标则是气泡类型（0
    到 3）乘以气泡图像的高度（50 像素）。我们将这些信息以及气泡的 `Sprite` 对象传递给另一个新方法 `drawSprite` ➍，然后重置上下文位置。
- en: Inside `drawSprite`, we translate the context ➎ by the coordinates of the sprite,
    remembering to offset the (top,left) coordinates by half of (width,height) to
    get the center of the image, and then draw the image ➏. In general, it’s best
    to translate the canvas context so its origin is at the center of any image being
    drawn, because the `rotate` method of the context performs rotations around the
    context origin. This means that if we want to rotate an image around its center,
    we already have the context set up correctly to do so.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `drawSprite` 中，我们通过精灵的坐标 ➎ 来平移上下文，并记得将（top,left）坐标偏移图像的一半（width,height），以便将图像的中心放在原点上，然后绘制图像
    ➏。一般来说，最好将画布上下文平移，使其原点位于任何绘制图像的中心，因为上下文的 `rotate` 方法是围绕上下文的原点进行旋转的。这意味着，如果我们想围绕图像的中心旋转图像，那么上下文已经设置好了，能够正确地执行旋转。
- en: 'Finally, after calling `drawImage`, we translate the context back to the origin
    ➐. To see the board being rendered to the canvas, we just need to put `renderFrame`
    into *game.js*:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在调用 `drawImage` 后，我们将上下文平移回原点 ➐。为了看到棋盘被渲染到画布上，我们只需要在 *game.js* 中加入 `renderFrame`：
- en: '*game.js*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Reload the page in your browser to start the game again. After clicking New
    Game, you should see the board render in its initial state. However, firing a
    bubble produces no animation, and neither does popping, falling, or anything else.
    In the next section, we’ll get bubble firing working again and also animate the
    bubble popping. If you open the game in a browser that doesn’t support canvas,
    then the game will still work as before because we have left the DOM version intact.
    Next, we’ll add animation to the canvas version.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中重新加载页面以重新开始游戏。点击“新游戏”后，你应该会看到棋盘在初始状态下渲染出来。然而，发射气泡时没有动画效果，弹出、下落或其他任何动作也都没有动画效果。在下一部分，我们将重新实现气泡发射的动画，并且为气泡弹出的动画添加动画效果。如果你在不支持画布的浏览器中打开游戏，游戏仍然会像以前一样运行，因为我们保留了
    DOM 版本。接下来，我们将为画布版本添加动画效果。
- en: Moving Sprites on the Canvas
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在画布上移动精灵
- en: With the CSS version of the game, we used jQuery to move objects around on the
    screen with one call to the `animate` method. For canvas animation, we need to
    calculate and update movements manually.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏的 CSS 版本中，我们使用 jQuery 通过调用 `animate` 方法来移动屏幕上的物体。对于画布动画，我们需要手动计算并更新物体的移动。
- en: 'The process of animating on the canvas is the same as jQuery’s internal processes,
    and we’ll give `Sprite` an `animate` method so we can continue to use our existing
    code. The `animate` method will do the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布上动画的过程与 jQuery 内部的过程相同，我们将给 `Sprite` 添加一个 `animate` 方法，以便继续使用现有的代码。`animate`
    方法将执行以下操作：
- en: Accept destination coordinates for a bubble and the duration of the movement.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受气泡的目标坐标和移动的持续时间。
- en: Move the object a small distance toward those coordinates by a value proportional
    to the time elapsed since the last frame.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据自上次帧以来经过的时间按比例将物体移动到目标坐标的一个小距离。
- en: Repeat step 2 until the bubble reaches its destination.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤 2，直到气泡到达目标位置。
- en: This process is identical to the one that happens when we use jQuery’s `animate`
    method and is one you’ll use just about any time you want to move an object around
    the screen.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程与我们使用 jQuery 的 `animate` 方法时的过程完全相同，并且是你每次想要移动屏幕上的物体时都会使用的方法。
- en: 'The `renderFrame` method, which is already called during each frame, will run
    the entire animation process. After the bubble sprites calculate their own coordinates,
    `renderFrame` will trigger the drawing process. We’ll add an `animate` method
    to the `Sprite` object so our existing game logic will work without us having
    to rewrite our code. Remember that when we call `animate` in *ui.js*, we pass
    in two parameters:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderFrame` 方法已经在每一帧时被调用，它将运行整个动画过程。气泡精灵计算出自己的坐标后，`renderFrame` 将触发绘制过程。我们会在
    `Sprite` 对象中添加一个 `animate` 方法，这样我们现有的游戏逻辑就可以正常工作，而无需重写代码。记住，当我们在 *ui.js* 中调用 `animate`
    时，我们传入了两个参数：'
- en: An object specifying `left` and `top` position coordinates
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指定 `left` 和 `top` 位置坐标的对象
- en: An object specifying `duration`, `callback` function, and `easing`
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指定 `duration`、`callback` 函数和 `easing` 的对象
- en: 'By constructing the `animate` method of `Sprite` to take the same parameters,
    we can avoid making any changes to the call in *ui.js*. Add the following to *sprite.js*:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建 `Sprite` 的 `animate` 方法以接收相同的参数，我们可以避免对 *ui.js* 中的调用做出任何更改。将以下内容添加到 *sprite.js*：
- en: '*sprite.js*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*sprite.js*'
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `destination` parameter passed into `animate` ➊ represents the sprite’s
    destination coordinates, which are contained in an object that looks like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `animate` 的 `destination` 参数 ➊ 代表精灵的目标坐标，这些坐标包含在一个看起来像这样的对象中：
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We also pass a configuration object, which will have a `duration` property ➋,
    plus an optional post-animation callback function to run when the animation is
    over.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还传递一个配置对象，该对象将具有 `duration` 属性 ➋，并且可以有一个可选的后动画回调函数，当动画结束时运行。
- en: Next, we set a start time for the animation ➌ and store the starting position
    ➍. These will both be used to calculate a bubble’s position at any time.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为动画设置一个开始时间 ➌，并存储起始位置 ➍。这两个值将用于随时计算气泡的位置。
- en: 'We dynamically add the `updateFrame` method onto the `Sprite` object ➎ so we
    can call it each frame to recalculate a bubble’s position. Inside `updateFrame`,
    we calculate how much of the animation is completed. In case the last timeout
    is called after the animation has completed, we ensure that the proportion is
    never greater than 1 so that a bubble never moves past its target destination.
    The new coordinates are calculated ➏ with the following equations:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们动态地将 `updateFrame` 方法添加到 `Sprite` 对象上 ➎，这样我们就可以在每一帧调用它重新计算气泡的位置。在 `updateFrame`
    内部，我们计算动画的完成度。如果最后一个超时调用发生在动画完成之后，我们确保比例永远不会大于 1，从而避免气泡越过目标位置。新坐标的计算 ➏ 使用以下公式：
- en: current *x* = start *x* + (final *x* – start *x*) × proportion elapsed
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前 *x* = 起始 *x* + (最终 *x* – 起始 *x*) × 经过的比例
- en: current *y* = start *y* + (final *y* – start *y*) × proportion elapsed
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前的 *y* = 起始 *y* + (最终 *y* – 起始 *y*) × 经过的比例
- en: Once we have the new top and left coordinates, the position of the sprite is
    updated with a call to its `css` method ➐. We don’t need `updateFrame` to run
    when the object has finished moving, so a timeout call is set ➑ to remove the
    method after `duration` ➒ passes, which is when the animation will be complete.
    This also calls any post-animation function that was passed in as the `callback`
    property of the `config` variable ➓.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到了新的顶部和左侧坐标，精灵的位置会通过调用它的 `css` 方法 ➐ 来更新。我们不需要在对象移动完成后继续运行 `updateFrame`，因此设置了一个超时调用
    ➑ 来在 `duration` ➒ 过去时移除该方法，此时动画将完成。这也会调用任何作为 `config` 变量的 `callback` 属性传入的后动画函数
    ➓。
- en: 'Now that we can calculate a bubble’s new coordinates, add a call to `updateFrame`
    in *game.js*:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以计算气泡的新坐标，接下来在 *game.js* 中添加一个对`updateFrame`的调用：
- en: '*game.js*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Each time `renderFrame` is called on a bubble ➊, if the method `updateFrame`
    is defined ➋, we call that method ➌.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 每次在气泡上调用 `renderFrame` ➊ 时，如果定义了 `updateFrame` 方法 ➋，我们就调用该方法 ➌。
- en: We also need to call `animate` in `fireBubble` in *ui.js* by checking for the
    existence of `BubbleShoot.Renderer` again. We know that `BubbleShoot.Renderer`
    will exist only if canvas is supported, and we want to use the canvas for rendering
    if that is the case. The outcome is that CSS transitions will animate the bubbles
    only if CSS transitions are supported *and* canvas rendering isn’t supported.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在 `fireBubble` 中调用 `animate`，在 *ui.js* 里再次检查 `BubbleShoot.Renderer` 是否存在。我们知道只有在支持
    canvas 的情况下，`BubbleShoot.Renderer` 才会存在，我们希望在这种情况下使用 canvas 渲染。最终的结果是，只有在支持 CSS
    过渡动画并且不支持 canvas 渲染时，CSS 过渡动画才会对气泡进行动画处理。
- en: '*ui.js*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*ui.js*'
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Reload the game and fire away! You should now have a working game again, but
    this time all the images are rendered onto the canvas. But now there’s no popping
    animation because we’re not handling changes in bubble state in the display. The
    game state is internally correct, but the screen isn’t entirely in sync because
    we never see a bubble popping. Rendering the bubbles in their correct state is
    the focus of the next section.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载游戏并开始射击！现在你应该能再次玩游戏了，但这次所有图像都会被渲染到画布上。不过现在没有爆炸动画，因为我们没有在显示中处理气泡状态的变化。游戏状态在内部是正确的，但屏幕显示不完全同步，因为我们从未看到气泡爆炸。将气泡渲染为正确的状态是下一节的重点。
- en: Animating Canvas Sprite Frames
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画画布精灵帧
- en: Currently, every bubble is rendered in the same visual state regardless of whether
    it’s sitting in the board, popping, newly fired, and so on. Bubbles remain on
    the screen after they’ve been popped, and we’re missing out on the popping animation!
    This happens because bubbles are never deleted from the `bubbles` array in `Game`,
    so they’re rendered even after they’ve been deleted from the `Board` object.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，所有气泡都渲染为相同的视觉状态，无论它们是处于棋盘上、爆炸中、刚被发射，等等。气泡在爆炸后仍会留在屏幕上，而且我们错过了爆炸动画！这是因为气泡从未从`Game`中的`bubbles`数组中删除，因此即使它们已经从`Board`对象中删除，仍然会被渲染。
- en: We already know which state a bubble is in, and we have the sprite sheet image
    loaded into memory to access all of the animation states. Drawing the correct
    state involves making sure that the `drawSprite` method of `Renderer` is either
    called with the correct state for a visible bubble or skipped entirely for any
    bubbles that have been popped or dropped off the screen. The changes in a bubble’s
    appearance that we need to implement are listed by state in [Table 6-1](ch06.html#visual_changes_based_on_bubble_state
    "Table 6-1. Visual Changes Based on Bubble State").
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道气泡处于哪个状态，并且已经将精灵图加载到内存中，以便访问所有动画状态。绘制正确的状态需要确保`Renderer`的`drawSprite`方法要么以正确的状态调用以显示气泡，要么完全跳过任何已经爆炸或从屏幕上消失的气泡。我们需要实现的气泡外观变化按状态列出在[表6-1](ch06.html#visual_changes_based_on_bubble_state
    "表6-1. 基于气泡状态的视觉变化")中。
- en: Table 6-1. Visual Changes Based on Bubble State
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-1. 基于气泡状态的视觉变化
- en: '| Bubble’s state in code | Visual displayed to the player |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 代码中的气泡状态 | 显示给玩家的视觉效果 |'
- en: '| --- | --- |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CURRENT_BUBBLE` | No change |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `CURRENT_BUBBLE` | 无变化 |'
- en: '| `ON_BOARD` | No change |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `ON_BOARD` | 无变化 |'
- en: '| `FIRING` | No change |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `FIRING` | 无变化 |'
- en: '| `POPPING` | Render one of four bubble frames, depending on how long the bubble
    has been `POPPING` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `POPPING` | 根据气泡已经处于`POPPING`状态的时间渲染四个气泡帧中的一个 |'
- en: '| `FALLING` | No change |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `FALLING` | 无变化 |'
- en: '| `POPPED` | Skip rendering |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `POPPED` | 跳过渲染 |'
- en: '| `FALLEN` | Skip rendering |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `FALLEN` | 跳过渲染 |'
- en: '| `FIRED` | Skip rendering |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `FIRED` | 跳过渲染 |'
- en: 'Those changes will happen inside `Renderer.render`. We’ll loop over the entire
    bubble array and either skip the rendering stage or adjust the coordinates to
    clip the sprite sheet for the correct stage in the popping animation. Make the
    following change to *renderer.js*:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改将在`Renderer.render`内部进行。我们将遍历整个气泡数组，并根据情况跳过渲染阶段或调整坐标，以便为正确的爆炸动画阶段裁剪精灵图。请对*renderer.js*进行以下更改：
- en: '*renderer.js*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*renderer.js*'
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: First, we want to see which state the bubble is in ➊. To do this, we’ll use
    a `switch` statement. State machines are often written using `switch`/`case` statements
    rather than multiple `if`/`else` statements. Using this structure not only makes
    it easier to add any future states but also provides a clue to others reading
    the code in the future that they’re looking at a state machine.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要查看气泡处于哪种状态➊。为此，我们将使用`switch`语句。状态机通常使用`switch`/`case`语句编写，而不是多个`if`/`else`语句。使用这种结构不仅使得将来添加任何新状态变得更加容易，而且还为将来阅读代码的其他人提供了一个线索，告诉他们正在查看的是一个状态机。
- en: If the bubble is popping, we want to know how long it’s been in that state ➋.
    That time determines which animation frame to fetch. We use the unpopped state
    for the first 80 milliseconds ➌, the first frame for the next 60 milliseconds
    ➍, and the final popping frame from that point until the `POPPING` state is cleared
    ➎.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果气泡正在爆炸，我们需要知道它已经处于该状态多长时间➋。这个时间决定了我们要获取哪个动画帧。前80毫秒使用未爆炸状态➌，接下来的60毫秒使用第一帧➍，从那时起直到`POPPING`状态被清除之前使用最后的爆炸帧➎。
- en: If the bubble is in the `POPPED` ➏, `FIRED` ➐, or `FALLEN` ➑ states, we return
    and skip rendering altogether. Otherwise, we call `drawSprite` as before ➒.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果气泡处于`POPPED` ➏、`FIRED` ➐ 或 `FALLEN` ➑ 状态，我们会返回并跳过渲染。否则，我们像以前一样调用 `drawSprite`
    ➒。
- en: 'Now if you reload the game, it should completely work again. Without making
    drastic changes, we’ve refactored our entire game area to use either canvas- or
    DOM-based rendering, depending on browser compatibility. The browser you use to
    load the game and the features that browser supports will determine how *Bubble
    Shooter* is presented to you:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你重新加载游戏，它应该会完全正常工作。我们没有做剧烈的修改，只是重构了整个游戏区域，根据浏览器的兼容性使用 canvas 或 DOM 渲染。你用来加载游戏的浏览器以及该浏览器支持的功能将决定*Bubble
    Shooter*如何呈现给你：
- en: If your browser supports the `canvas` element, you’ll see that version.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的浏览器支持`canvas`元素，你将看到该版本。
- en: If your browser supports CSS transitions but *not* the `canvas` element, you’ll
    see the CSS transition version.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的浏览器支持 CSS 过渡效果，但*不*支持`canvas`元素，你将看到 CSS 过渡效果版本。
- en: If neither of the above is supported, you’ll see the DOM version animated with
    jQuery.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果上述两者都不支持，你将看到使用 jQuery 动画的 DOM 版本。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: That covers most of the core of drawing the graphics elements of an HTML5 game,
    whether you’re using HTML and CSS or an entirely canvas-based approach. But that
    doesn’t mean we’ve finished the game! We have no sound, only one level of play
    exists, and a scoring system would be nice. In the next chapter, we’ll implement
    these elements and explore a few more features of HTML5, including local storage
    for saving game state, `requestAnimationFrame` for smoother animations, and how
    to make sound work reliably.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了绘制 HTML5 游戏图形元素的大部分核心内容，无论你是使用 HTML 和 CSS，还是完全基于 canvas 的方法。但这并不意味着我们的游戏完成了！我们没有声音，只有一个关卡，另外一个得分系统会更好。接下来的章节中，我们将实现这些元素，并探索更多
    HTML5 的功能，包括用于保存游戏状态的本地存储，`requestAnimationFrame` 以实现更流畅的动画，以及如何让声音可靠地工作。
- en: Further Practice
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步练习
- en: When bubbles pop, the animation plays identically for every bubble. Experiment
    with changing the timing so that some bubbles play the animation faster and some
    slower. Also, try adding some rotation to the bubbles as they’re drawn onto the
    canvas. This should give the popping animation a much richer feel for very little
    effort.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当气泡爆炸时，每个气泡的动画播放是相同的。试着改变时间，使一些气泡播放动画更快，另一些更慢。同时，尝试为气泡添加一些旋转效果，当它们被绘制到 canvas
    上时。这应该会让爆炸动画看起来更丰富，而且几乎不需要太多努力。
- en: When orphaned bubbles fall, they remain as the default sprite. Change *renderer.js*
    so that bubbles pop as they’re falling.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当孤立的气泡下降时，它们仍然保持为默认的精灵。修改*renderer.js*，使得气泡在下落时会爆炸。
