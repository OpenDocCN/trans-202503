- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: UART, JTAG, and SWD Exploitation
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: UART、JTAG 和 SWD 利用
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: If you understand the protocols that interact directly with a system’s electronic
    components, you can target IoT devices at the physical level. The *Universal Asynchronous
    Receiver-Transmitter (UART)* is one of the simplest serial protocols, and its
    exploitation provides one of the easiest ways to gain access to IoT devices. Vendors
    typically use it for debugging, which means that you can often obtain root access
    through it. To accomplish this, you’ll need some specialized hardware tools; for
    instance, it’s common for attackers to identify the UART pins on a device’s printed
    circuit board (PCB) using a multimeter or logic analyzer. They then connect a
    USB-to-serial adapter to these pins and open a serial debug console from the attacking
    workstation. Most of the time, if you do this, you’ll be dropped to a root shell.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解与系统电子组件直接交互的协议，你就可以在物理层面攻击 IoT 设备。*通用异步接收传输器（UART）* 是最简单的串行协议之一，其利用提供了获取
    IoT 设备访问权限的最简单途径之一。供应商通常用它进行调试，这意味着你通常可以通过它获得 root 权限。为此，你需要一些专用的硬件工具；例如，攻击者通常通过使用万用表或逻辑分析仪来识别设备印刷电路板（PCB）上的
    UART 引脚。然后，他们将 USB 转串口适配器连接到这些引脚，并从攻击工作站打开串行调试控制台。大多数情况下，如果你这样做，你将被直接进入 root shell。
- en: The *Joint Test Action Group (JTAG)* is an industry standard (defined in IEEE
    1491.1) for debugging and testing increasingly complex PCBs. JTAG interfaces on
    embedded devices allow us to read and write memory contents, including dumping
    the entire firmware, which means it serves as a way to gain complete control of
    a target device. *Serial Wire Debug* (*SWD*) is a very similar, even simpler electrical
    interface than JTAG that we’ll examine here as well.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*联合测试行动小组（JTAG）* 是一种工业标准（在 IEEE 1491.1 中定义），用于调试和测试日益复杂的 PCB。嵌入式设备上的 JTAG 接口允许我们读取和写入内存内容，包括转储整个固件，这意味着它是获得完全控制目标设备的一种方式。*串行线调试*（*SWD*）是一种非常相似、甚至比
    JTAG 更简单的电气接口，我们也将在这里进行探讨。'
- en: We spend most of this chapter walking through a lengthy practical exercise;
    you’ll program, debug, and exploit a microcontroller to bypass its authentication
    process using UART and SWD. But first we explain the inner workings of these protocols
    and show you how to identify UART and JTAG pinouts on a PCB using hardware and
    software tools.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容将通过一个较长的实践演练进行讲解；你将编程、调试并利用微控制器，通过 UART 和 SWD 绕过其认证过程。但首先，我们将解释这些协议的内部工作原理，并展示如何使用硬件和软件工具识别
    PCB 上的 UART 和 JTAG 引脚。
- en: UART
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UART
- en: UART is a *serial* protocol, which means it transfers data between components
    one bit at a time. In contrast, *parallel communication* protocols transmit data
    simultaneously through multiple channels. Common serial protocols include RS-232,
    I²C, SPI, CAN, Ethernet, HDMI, PCI Express, and USB.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: UART 是一种*串行*协议，这意味着它一次传输一个比特的数据。相比之下，*并行通信*协议通过多个通道同时传输数据。常见的串行协议包括 RS-232、I²C、SPI、CAN、以太网、HDMI、PCI
    Express 和 USB。
- en: UART is simpler than many of the protocols you’ve likely encountered. To synchronize
    communications, the UART transmitter and receiver must agree on a specific baud
    rate (the rate of bits transmitted per second). [Figure 7-1](#figure7-1) shows
    the UART packet format.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: UART 比你可能遇到的许多协议更简单。为了同步通信，UART 的发送器和接收器必须就一个特定的波特率（每秒传输的比特数）达成一致。[图 7-1](#figure7-1)
    显示了 UART 数据包的格式。
- en: '![f07001](Images/f07001.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![f07001](Images/f07001.png)'
- en: 'Figure 7-1: UART packet format'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1：UART 数据包格式
- en: Generally, the line is held high (at a logical 1 value) while UART is in the
    *idle* state. Then, to signal the start of a data transfer, the transmitter sends
    a *start bit* to the receiver, during which the signal is held low (at a logical
    0 value). Next, the transmitter sends five to eight *data bits* containing the
    actual message, followed by an optional parity bit and one or two stop bits (with
    a logical 1 value), depending on the configuration. The *parity bit*, used for
    error checking, is rarely seen in practice. The *stop bit* (or bits) signify the
    end of transmission.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在 UART 处于*空闲*状态时，线路保持高电平（逻辑 1）。然后，为了表示数据传输的开始，发送器向接收器发送一个*起始位*，此时信号保持低电平（逻辑
    0）。接着，发送器发送五到八个*数据位*，包含实际的消息，之后是一个可选的奇偶校验位和一个或两个停止位（逻辑 1），具体取决于配置。用于错误检查的*奇偶校验位*在实际应用中很少见。*停止位*（或多个停止位）表示传输结束。
- en: 'We call the most common configuration *8N1*: eight data bits, no parity, and
    one stop bit. For example, if we wanted to send the character C, or 0x43 in ASCII,
    in an 8N1 UART configuration, we would send the following bits: `0` (the start
    bit); `0`, `1`, `0`, `0`, `0`, `0`, `1`, `1` (the value of 0x43 in binary), and
    `0` (the stop bit).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称最常见的配置为*8N1*：8个数据位、无奇偶校验位和一个停止位。例如，如果我们想在8N1 UART配置中发送字符C，或ASCII码0x43，我们将发送以下位：`0`（起始位）；`0`、`1`、`0`、`0`、`0`、`0`、`1`、`1`（0x43的二进制值）；以及`0`（停止位）。
- en: Hardware Tools for Communicating with UART
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与UART通信的硬件工具
- en: You can use a variety of hardware tools to communicate with UART. One easy option
    is a USB-to-serial adapter, like the one we use in “Hacking a Device Through UART
    and SWD” on page 168\. Other options include adapters with the CP2102 or PL2303
    chips. If you are new to hardware hacking, we recommend getting a multipurpose
    tool that supports protocols other than just UART, such as the Bus Pirate, the
    Adafruit FT232H, the Shikra, or the Attify Badge.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用各种硬件工具与UART进行通信。一种简单的选择是USB到串口适配器，如我们在“通过UART和SWD黑客攻击设备”一节中使用的那种。其他选项包括配备CP2102或PL2303芯片的适配器。如果你是硬件黑客新手，我们建议你获取一款支持除UART以外的其他协议的多功能工具，例如Bus
    Pirate、Adafruit FT232H、Shikra或Attify Badge。
- en: You can also find a list of tools and their descriptions, as well as links to
    buy them, in “Tools for IoT Hacking” at the end of this book.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在本书末尾的“物联网黑客工具”中找到工具列表及其描述，并附有购买链接。
- en: Identifying UART Ports
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定UART端口
- en: 'To exploit a device through UART, you first need to locate its four UART ports,
    or connectors, which typically come in the form of pins or *pads* (plated holes).
    The term *pinout* refers to the diagram of all the ports. We’ll use these terms
    interchangeably throughout this book. A UART pinout has four ports: *TX (Transmit)*,
    *RX (Receive)*, *Vcc (Voltage)*, and *GND (Ground)*. Start by opening the device’s
    external case and removing the PCB. Be warned that this might void your warranty.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过UART攻击设备，首先需要定位其四个UART端口或连接器，通常以引脚或*焊盘*（镀层孔）的形式出现。术语*引脚图*指的是所有端口的图示。我们将在本书中交替使用这些术语。UART引脚图包含四个端口：*TX（发送）*、*RX（接收）*、*Vcc（电压）*和*GND（地）*。首先打开设备的外壳并拆下PCB。请注意，这可能会使你的保修失效。
- en: These four ports often appear next to each other on the board. If you’re lucky,
    you might even find markings that indicate the TX and RX ports, as shown in [Figure
    7-2](#figure7-2). In that case, you can be fairly certain that the set of four
    pins are the UART pins.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个端口通常会彼此靠近。如果你运气好，甚至可能找到标明TX和RX端口的标记，如[图7-2](#figure7-2)所示。在这种情况下，你可以相当确定这四个引脚就是UART引脚。
- en: '![f07002](Images/f07002.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![f07002](Images/f07002.png)'
- en: 'Figure 7-2: UART pins clearly marked as DBG_TXD and DBG_RXD on the PCB in a
    St. Jude/Abbott Medical Merlin@home Transmitter'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2：在圣裘德/雅培医疗Merlin@home发射器的PCB板上，UART引脚清晰标记为DBG_TXD和DBG_RXD。
- en: In other cases, you might see four through-hole pads next to each other, like
    those in the TP-Link router in [Figure 7-3](#figure7-3). This might occur because
    vendors have removed the UART header pins from the PCB, which means that you might
    have to either perform some soldering to reach them or use test probes. (*Test
    probes* are physical devices that connect electronic test equipment to a device.
    They include a probe, cable, and terminating connector. We show a few examples
    of test probes in Chapter 8.)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，你可能会看到四个互相并排的通孔焊盘，如[图7-3](#figure7-3)中TP-Link路由器的那样。这可能是因为厂商将UART头针从PCB上移除，这意味着你可能需要进行一些焊接操作来接触到它们，或者使用测试探针。（*测试探针*是连接电子测试设备和设备的物理设备，包括探针、电缆和终端连接器。我们将在第8章中展示一些测试探针的示例。）
- en: '![f07003](Images/f07003.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![f07003](Images/f07003.png)'
- en: 'Figure 7-3: A PCB in a TP-Link TL WR840N router. On the bottom left, you can
    see a zoomed-in part of the PCB with the UART pads.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-3：TP-Link TL WR840N路由器中的PCB。在左下角，你可以看到放大的PCB部分，标有UART焊盘。
- en: Also, keep in mind that some devices emulate UART ports by programming the General-Purpose
    Input/Output (GPIO) pins if there isn’t enough space on the board for dedicated
    hardware UART pins.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，某些设备通过编程通用输入输出（GPIO）引脚来模拟UART端口，如果板上没有足够的空间放置专用的硬件UART引脚。
- en: 'When UART pins aren’t marked as clearly as those shown here, you can typically
    identify them on a device in two ways: by using a multimeter or by using a logic
    analyzer. A *multimeter* measures voltage, current, and resistance. Having a multimeter
    in your arsenal when doing hardware hacking is highly important, because it can
    serve a variety of purposes. For example, we commonly use it to test for *continuity*.
    A continuity test sounds a buzzer when a circuit’s resistance is low enough (less
    than a few ohms), indicating that there’s a continuous path between the two points
    probed by the multimeter’s leads.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当 UART 引脚没有像这里所示那样清晰标记时，通常可以通过两种方式在设备上识别它们：使用万用表或使用逻辑分析仪。*万用表*可用于测量电压、电流和电阻。进行硬件黑客操作时，拥有万用表非常重要，因为它可以用于多种用途。例如，我们通常用它来测试*通断性*。通断性测试在电路电阻足够低（低于几欧姆）时会发出蜂鸣声，表示万用表探头所接触的两个点之间存在连续路径。
- en: Although a cheap multimeter will do the job, we recommend that you invest in
    a robust and precise multimeter, if you plan to delve deeper into hardware hacking.
    True RMS multimeters are more accurate for measuring AC currents. [Figure 7-4](#figure7-4)
    shows a typical multimeter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然便宜的万用表可以完成工作，但如果您计划深入研究硬件黑客操作，我们建议您投资一款坚固且精确的万用表。真正的 RMS 万用表在测量交流电流时更加精确。[图
    7-4](#figure7-4)展示了一款典型的万用表。
- en: '![f07004](Images/f07004.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![f07004](Images/f07004.png)'
- en: 'Figure 7-4: Common multimeter. Highlighted is the Continuity Test mode, which
    typically has an icon that looks like a sound wave (because of the buzzer that
    sounds when detecting continuity).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-4：常见万用表。突出显示的是通断性测试模式，通常该模式有一个类似声波的图标（因为在检测到通断性时会发出蜂鸣声）。
- en: To identify UART pinouts using a multimeter, start by making sure the device
    is powered off. By convention, you should connect a black test lead to the multimeter’s
    COM jack. Insert a red lead in the VΩ jack.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用万用表识别 UART 引脚，首先确保设备已关闭电源。按照惯例，您应将黑色测试线连接到万用表的 COM 插孔。将红色测试线插入 VΩ 插孔。
- en: Begin by identifying the UART GND. Turn the multimeter dial to the Continuity
    Test mode, which typically has an icon that looks like a sound wave. It might
    share a spot on the dial with one or more functions, usually resistance. Place
    the other end of the black lead on any grounded metallic surface (an area that
    has a direct conductive path to earth), be it a part of the tested PCB or not.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先识别 UART GND 引脚。将万用表旋钮转到通断性测试模式，通常该模式有一个类似声波的图标。它可能与一个或多个功能共享一个位置，通常是电阻。将黑色测试线的另一端放在任何接地的金属表面上（无论是测试的
    PCB 一部分还是其他地方），该表面应有直接的导电路径连接到地面。
- en: Then place the red probe on each of the ports you suspect might be part of the
    UART pinout. When you hear a beeping sound from the multimeter, you’ve found a
    GND pin. Keep in mind that the device might have more than one GND pin and you
    might have found one that isn’t necessarily part of the UART pinout.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将红色探头放在您怀疑可能是 UART 引脚的每个端口上。当您听到万用表发出蜂鸣声时，说明您找到了 GND 引脚。请记住，设备可能有多个 GND 引脚，您可能找到的并不一定是
    UART 引脚的一部分。
- en: Continue by identifying the Vcc port. Turn the multimeter dial to the DC voltage
    mode in and set it up to 20 V of voltage. Keep the multimeter’s black probe on
    a grounded surface. Place the red probe in a suspected pad and turn on the device.
    If the multimeter measures a constant voltage of either 3.3 V or 5 V, you’ve found
    the Vcc pin. If you get other voltages, place the red probe on another port, reboot
    the device, and measure the voltage again. Do the same for every port until you
    identify Vcc.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来识别 Vcc 引脚。将万用表旋钮转到直流电压模式，并设置为 20 V 电压。将万用表的黑色探头保持在接地表面上。将红色探头放在一个怀疑是 Vcc
    引脚的焊盘上，然后打开设备。如果万用表测得恒定电压为 3.3 V 或 5 V，则说明您找到了 Vcc 引脚。如果得到其他电压，请将红色探头放到另一个端口，重新启动设备并再次测量电压。对每个端口都做同样的操作，直到找到
    Vcc 引脚。
- en: Next, identify the TX port. Keep the multimeter mode at a DC voltage of 20 V
    or less, and leave the black probe in a grounded surface. Move the red probe to
    the suspected pad and power cycle the device. If the voltage fluctuates for a
    few seconds and then stabilizes at the Vcc value (either 3.3 or 5), you’ve most
    likely found the TX port. This behavior happens because, during bootup, the device
    sends serial data through that TX port for debugging purposes. Once it finishes
    booting, the UART line goes idle. Recall from [Figure 7-1](#figure7-1) that an
    idle UART line remains at a logical high, which means that it has the Vcc value.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，识别TX端口。将万用表模式设置为直流电压20V或以下，并将黑色探头保持在接地面上。将红色探头移至怀疑的焊盘，并对设备进行断电重启。如果电压在几秒钟内波动，随后稳定在Vcc值（无论是3.3V还是5V），则很可能找到了TX端口。这种现象发生在设备启动时，设备会通过该TX端口发送串行数据用于调试。启动完成后，UART线变为空闲状态。回顾[图7-1](#figure7-1)，我们知道空闲的UART线保持逻辑高电平，这意味着它具有Vcc值。
- en: If you’ve already identified the rest of the UART ports, the nearby fourth pin
    is most likely the RX port. Otherwise, you can identify it because it has the
    lowest voltage fluctuation and lowest overall value of all the UART pins.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经识别了其他UART端口，那么附近的第四个引脚很可能就是RX端口。否则，你可以通过它的电压波动最小且所有UART引脚中电压值最低来识别它。
- en: To identify the UART pins more accurately, use a *logic analyzer*, a device
    that captures and displays signals from a digital system. Many kinds of logic
    analyzers are available. They range from cheaper ones, such as the HiLetgo or
    the Open Workbench Logic Sniffer, to the more professional Saleae family ([Figure
    7-5](#figure7-5)), which support higher sampler rates and are more robust.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要更准确地识别UART引脚，可以使用*逻辑分析仪*，这是一种捕获和显示数字系统信号的设备。市面上有许多类型的逻辑分析仪，从较便宜的HiLetgo或Open
    Workbench Logic Sniffer，到更专业的Saleae系列（[图7-5](#figure7-5)），后者支持更高的采样率并且更为稳健。
- en: We’ll walk through the process of using a logic analyzer against a target device
    in “Using a Logic Analyzer to Identify the UART Pins” on page 176.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第176页的《使用逻辑分析仪识别UART引脚》一节中，详细介绍如何使用逻辑分析仪对目标设备进行测试。
- en: Identifying the UART Baud Rate
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别UART波特率
- en: Next, you have to identify the baud rate the UART ports use. Otherwise, you
    can’t communicate with the device. Given the absence of a synchronizing clock,
    the baud rate is the only way for the transmitter and receiver to exchange data
    in sync.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要识别UART端口使用的波特率。否则，无法与设备进行通信。由于缺乏同步时钟，波特率是发射器和接收器同步交换数据的唯一方式。
- en: '![f07005](Images/f07005.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![f07005](Images/f07005.png)'
- en: 'Figure 7-5: Saleae is a family of professional logic analyzers.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-5：Saleae是一系列专业的逻辑分析仪。
- en: The easiest way to identify the correct baud rate is to look at the TX pin’s
    output and try to read the data. If the data you receive isn’t readable, switch
    to the next possible baud rate until the data becomes readable. You can use a
    USB-to-serial adapter or a multipurpose device like Bus Pirate to do this, paired
    with a helper script, such as *baudrate.py* ([https://github.com/devttys0/baudrate/](https://github.com/devttys0/baudrate/))
    by Craig Heffner, to help automate this process. The most common baud rates are
    9600, 38400, 19200, 57600, and 115200, all of which Heffner’s Python script tests
    by default.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 识别正确波特率的最简单方法是观察TX引脚的输出，并尝试读取数据。如果接收到的数据不可读，切换到下一个可能的波特率，直到数据变得可读。你可以使用USB转串口适配器或像Bus
    Pirate这样的多功能设备，配合一个辅助脚本，例如Craig Heffner的*baudrate.py*（[https://github.com/devttys0/baudrate/](https://github.com/devttys0/baudrate/)），来帮助自动化这个过程。最常见的波特率有9600、38400、19200、57600和115200，Heffner的Python脚本默认会测试这些波特率。
- en: JTAG and SWD
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JTAG和SWD
- en: Like UART, the JTAG and SWD interfaces on IoT embedded devices can serve as
    a way to gain control of a device. In this section, we’ll cover the basics of
    these interfaces and how you can communicate with them. In “Hacking a Device Through
    UART and SWD” on page 168, we’ll walk through a detailed example of interacting
    with SWD.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与UART类似，IoT嵌入式设备上的JTAG和SWD接口也可以作为获取设备控制权限的一种方式。在本节中，我们将介绍这些接口的基本概念，以及如何与它们进行通信。在第168页的《通过UART和SWD破解设备》一节中，我们将通过一个详细示例演示如何与SWD交互。
- en: JTAG
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JTAG
- en: As manufacturers started producing smaller, denser components, testing them
    efficiently became harder. Engineers used to test hardware for defects using a
    *bed of nails* process, in which they placed the board on a number of fixtures
    arranged to mate with various parts of the board. When manufacturers began using
    multilayer boards and ball grid array packages, the fixtures could no longer access
    all nodes on the board.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 随着制造商开始生产更小、更密集的组件，高效地测试它们变得更加困难。工程师过去使用*针床*过程来测试硬件缺陷，在这种过程中，他们将电路板放置在一些固定装置上，这些装置与电路板的不同部分连接。当制造商开始使用多层电路板和球栅阵列封装时，这些固定装置无法再访问电路板上的所有节点。
- en: '*JTAG* solved this problem by introducing a more effective alternative to the
    bed of nails test: the boundary scan. The *boundary scan* analyzes certain circuitry,
    including embedded boundary-scan cells and registers for each pin. By leveraging
    these boundary scan cells, engineers can test that a certain point on the circuit
    board correctly connects to another point more easily than they could before.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*JTAG*通过引入一种更有效的替代方式——边界扫描，解决了这个问题：边界扫描分析了某些电路，包括每个引脚的嵌入式边界扫描单元和寄存器。通过利用这些边界扫描单元，工程师可以比以前更容易地测试电路板上某个点是否正确连接到另一个点。'
- en: Boundary Scan Commands
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 边界扫描命令
- en: 'The JTAG standard defines specific commands for conducting boundary scans,
    including the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JTAG标准定义了用于进行边界扫描的特定命令，包括以下内容：
- en: '*BYPASS* allows you to test a specific chip without the overhead of passing
    through other chips.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*旁路*（BYPASS）允许你在不经过其他芯片的情况下测试特定的芯片。'
- en: '*SAMPLE/PRELOAD* takes a sample of the data entering and leaving the device
    when it’s in its normal functioning mode.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*采样/预加载*（SAMPLE/PRELOAD）在设备处于正常工作模式时，采集进出设备的数据。'
- en: '*EXTEST* sets and reads pin states.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*外部测试*（EXTEST）设置并读取引脚状态。'
- en: The device must support these commands to be considered JTAG compliant. Devices
    might also support optional commands, like *IDCODE* (for identifying a device)and
    *INTEST* (for the internal testing of the device), among others. You might come
    across these instructions when you use a tool like the JTAGulator (described later
    in "Identifying JTAG pins" on page 166) for identifying JTAG pins.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 设备必须支持这些命令才能被认为符合JTAG标准。设备也可能支持一些可选命令，如*IDCODE*（用于识别设备）和*INTEST*（用于设备的内部测试）等。在使用像JTAGulator这样的工具（稍后在“识别JTAG引脚”第166页中描述）来识别JTAG引脚时，你可能会遇到这些指令。
- en: The Test Access Port
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试访问端口
- en: Boundary scans include tests of the four-wire *Test Access Port (TAP)*, a general-purpose
    port that provides access to the JTAG test support functions built into a component.
    It uses a 16-stage finite state machine that moves from state to state. Note that
    JTAG doesn’t define any protocol for the data coming in or out of the chip.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 边界扫描包括对四线*测试访问端口（TAP）*的测试，这是一种通用端口，用于访问内置于组件中的JTAG测试支持功能。它使用一个16级有限状态机，在各个状态之间移动。请注意，JTAG并未定义任何关于芯片输入或输出数据的协议。
- en: 'TAP uses the following five signals:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: TAP使用以下五个信号：
- en: '**Test clock input (TCK)** The TCK is the clock that defines how often the
    TAP controller will take a single action (in other words, jump to the next state
    in the state machine). The clock’s speed isn’t specified by the JTAG standard.
    The device performing the JTAG test can determine it.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试时钟输入（TCK）** TCK是定义TAP控制器每次执行一个操作（换句话说，即跳转到状态机中的下一个状态）频率的时钟。JTAG标准并未规定时钟的速度，执行JTAG测试的设备可以自行确定。'
- en: '**Test mode select (TMS) input** TMS controls the finite state machine. On
    each beat of the clock, the device’s JTAG TAP controller checks the voltage on
    the TMS pin. If the voltage is below a certain threshold, the signal is considered
    low and interpreted as 0, whereas if the voltage is above a certain threshold,
    the signal is considered high and interpreted as 1.'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试模式选择（TMS）输入** TMS控制有限状态机。在每个时钟脉冲上，设备的JTAG TAP控制器检查TMS引脚上的电压。如果电压低于某个阈值，则信号被认为是低电平并解释为0；如果电压高于某个阈值，则信号被认为是高电平并解释为1。'
- en: '**Test data input (TDI)** TDI is the pin that sends data into the chip through
    the scan cells. Each vendor is responsible for defining the communication protocol
    over this pin, because JTAG doesn’t define this. The signal presented at TDI is
    sampled on the rising edge of TCK.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试数据输入（TDI）** TDI是将数据通过扫描单元发送到芯片的引脚。每个供应商负责定义该引脚的通信协议，因为JTAG并未定义这一点。在TDI上呈现的信号会在TCK的上升沿进行采样。'
- en: '**Test data output (TDO)** TDO is the pin that sends data out of the chip.
    According to the standard, changes in the state of the signal driven through TDO
    should occur only on the falling edge of TCK.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试数据输出（TDO）** TDO是将数据从芯片输出的引脚。根据标准，TDO信号的状态变化应该仅在TCK的下降沿发生。'
- en: '**Test reset (TRST) input** The optional TRST resets the finite state machine
    to a known good state. It’s active on low (0). Alternatively, if the TMS is held
    at 1 for five consecutive clock cycles, it invokes a reset, the same way the TRST
    pin would, which is why TRST is optional.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试复位（TRST）输入** 可选的TRST用于将有限状态机重置为已知的良好状态。当信号为低电平（0）时，TRST有效。或者，如果TMS保持为1五个连续的时钟周期，也会触发复位，方式与TRST引脚相同，这就是为什么TRST是可选的原因。'
- en: How SWD Works
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SWD的工作原理
- en: SWD is a two-pin electrical interface that works very similarly to JTAG. Whereas
    JTAG was made primarily for chip and board testing, SWD is an ARM-specific protocol
    designed for debugging. Given the large prevalence of ARM processors in the IoT
    world, SWD has become increasingly important. If you find an SWD interface, you
    can almost always gain complete control of the device.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: SWD是一个两引脚电气接口，工作方式与JTAG非常相似。JTAG主要用于芯片和板卡测试，而SWD是为调试设计的ARM专用协议。由于ARM处理器在物联网世界中的广泛应用，SWD变得越来越重要。如果你找到一个SWD接口，几乎总是可以完全控制该设备。
- en: 'The SWD interface requires two pins: a bidirectional *SWDIO* signal, which
    is the equivalent of JTAG’s TDI and TDO pins and a clock, and *SWCLK*, which is
    the equivalent of TCK in JTAG. Many devices support the *Serial Wire or JTAG Debug
    Port (SWJ-DP)*, a combined JTAG and SWD interface that enables you to connect
    either a SWD or JTAG probe to the target.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: SWD接口需要两个引脚：一个双向的*SWDIO*信号，相当于JTAG的TDI和TDO引脚，以及一个时钟*SWCLK*，它相当于JTAG中的TCK。许多设备支持*串行线或JTAG调试端口（SWJ-DP）*，这是一个结合了JTAG和SWD接口的接口，允许你将SWD或JTAG探头连接到目标设备。
- en: Hardware Tools for Communicating with JTAG and SWD
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与JTAG和SWD通信的硬件工具
- en: A variety of tools allow us to communicate with JTAG and SWD. Popular tools
    include the Bus Blaster FT2232H chip, as well as any tool with the FT232H chip,
    such as the Adafruit FT232H breakout board, the Shikra, or the Attify Badge. The
    Bus Pirate can also support JTAG if you load it with special firmware, but we
    don’t recommend using that functionality because it can be unstable. The Black
    Magic Probe, a specialized tool for JTAG and SWD hacking, has built-in GNU Debugger
    (GDB) support, which is useful because you won’t need intermediary programs like
    the *Open On-Chip Debugger (OpenOCD)* (discussed in “Installing OpenOCD” on page
    171). A professional debugging tool, the *Segger J-Link Debug Probe* supports
    JTAG, SWD, and even SPI, and it comes with proprietary software. If you want to
    communicate with SWD only, you can use a tool like the *ST-Link* programmer, which
    we’ll use later in this chapter in “Hacking a Device Through UART and SWD” on
    page 168\.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 多种工具使我们能够与JTAG和SWD进行通信。流行的工具包括Bus Blaster FT2232H芯片，以及任何带有FT232H芯片的工具，如Adafruit
    FT232H扩展板、Shikra或Attify Badge。如果你给Bus Pirate加载特殊固件，它也可以支持JTAG，但我们不推荐使用这个功能，因为它可能不稳定。Black
    Magic Probe是一个专门用于JTAG和SWD破解的工具，内置GNU调试器（GDB）支持，这一点很有用，因为你不需要像*Open On-Chip Debugger
    (OpenOCD)*这样的中介程序（在第171页的“安装OpenOCD”中有讨论）。作为一个专业的调试工具，*Segger J-Link Debug Probe*支持JTAG、SWD，甚至SPI，并且附带专有软件。如果你只想与SWD通信，可以使用像*ST-Link*编程器这样的工具，我们将在本章后面的“通过UART和SWD破解设备”中使用它，详见第168页。
- en: You can find additional tools, their descriptions, and links in “Tools for IoT
    Hacking.”
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在“物联网破解工具”中找到更多工具、它们的描述以及链接。
- en: Identifying JTAG Pins
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定JTAG引脚
- en: Sometimes a PCB has markings indicating the location of a JTAG header ([Figure
    7-6](#figure7-6)). But most times you’ll have to manually identify the header,
    as well as which pins correspond to the four signals (TDI, TDO, TCK, and TMS).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有时PCB上会有标记指示JTAG接口的位置（见[图7-6](#figure7-6)）。但大多数时候你需要手动确定接口位置，以及哪些引脚对应四个信号（TDI、TDO、TCK和TMS）。
- en: '![f07006](Images/f07006.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![f07006](Images/f07006.png)'
- en: 'Figure 7-6: Sometimes the JTAG header is clearly marked on the PCB, as in this
    mobile Point of Sale (POS) device, where even the individual JTAG pins are labeled
    (TMS, TDO, TDI, TCK).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-6：有时JTAG接口会在PCB上明显标出，如在这个移动销售点（POS）设备中，甚至每个JTAG引脚（TMS、TDO、TDI、TCK）都有标签。
- en: You can take several approaches to identify JTAG pins on a target device. The
    fastest but most expensive way to detect JTAG ports is by using the *JTAGulator*,
    a device created specifically for this purpose (although it can also detect UART
    pinouts). The tool, shown in [Figure 7-7](#figure7-7), has 24 channels that you
    can connect to a board’s pins. It performs a brute force of these pins by issuing
    the IDCODE and BYPASS boundary scan commands to every permutation of pins and
    waits for a response. If it receives a response, it displays the channel corresponding
    to each JTAG signal, allowing you to identify the JTAG pinout.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以采取多种方法来识别目标设备上的 JTAG 引脚。最快但最昂贵的检测 JTAG 端口的方法是使用 *JTAGulator*，这是一种专门为此目的创建的设备（尽管它也可以检测
    UART 引脚）。如[图 7-7](#figure7-7)所示，这个工具有 24 个通道，你可以将其连接到板子的引脚。它通过对这些引脚执行 IDCODE 和
    BYPASS 边界扫描命令来进行暴力枚举，尝试每一种引脚的排列，并等待响应。如果收到响应，它会显示每个 JTAG 信号对应的通道，从而帮助你识别 JTAG
    引脚。
- en: '![f07007](Images/f07007.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![f07007](Images/f07007.png)'
- en: 'Figure 7-7: The JTAGulator ([http://www.grandideastudio.com/jtagulator/](http://www.grandideastudio.com/jtagulator/))
    can help you identify JTAG pins on a target device.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-7：JTAGulator（[http://www.grandideastudio.com/jtagulator/](http://www.grandideastudio.com/jtagulator/)）可以帮助你识别目标设备上的
    JTAG 引脚。
- en: To use the JTAGulator, connect it to your computer with a USB cable and then
    communicate with it over serial (for example, using the `screen` utility on Linux).
    You’ll see an example of interfacing over serial later in this chapter in “Connecting
    the USB to a Serial Adapter” on page 178\. You can watch a demonstration of the
    JTAGulator by its creator, Joe Grand, at [https://www.youtube.com/watch?v=uVIsbXzQOIU/](https://www.youtube.com/watch?v=uVIsbXzQOIU/).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 JTAGulator，将其通过 USB 电缆连接到计算机，然后通过串口与其通信（例如，使用 Linux 上的 `screen` 工具）。你将在本章后面的“连接
    USB 到串口适配器”一节中看到如何通过串口进行接口操作，详见第178页。你可以在 [https://www.youtube.com/watch?v=uVIsbXzQOIU/](https://www.youtube.com/watch?v=uVIsbXzQOIU/)
    上观看 JTAGulator 的创作者 Joe Grand 的演示。
- en: 'A cheaper but much slower way of identifying JTAG pinouts is by using the *JTAGenum*
    utility ([https://github.com/cyphunk/JTAGenum/](https://github.com/cyphunk/JTAGenum/))
    loaded on an Arduino-compatible microcontroller, like the STM32F103 blue and black
    pill devices we’ll attack later in this chapter in “Hacking a Device Through UART
    and SWD” on page 168\. Using JTAGenum, you’d first define the pins of the probing
    device that you’ll use for the enumeration. For example, for the STM32 blue pill,
    we’ve selected the following pins (but you can change them):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更便宜但速度较慢的识别 JTAG 引脚的方法是使用 *JTAGenum* 工具（[https://github.com/cyphunk/JTAGenum/](https://github.com/cyphunk/JTAGenum/)），该工具加载在一个兼容
    Arduino 的微控制器上，比如 STM32F103 蓝黑色药丸设备，这些设备我们将在本章的“通过 UART 和 SWD 破解设备”一节（第168页）中进行攻击。使用
    JTAGenum，你首先需要定义你用于枚举的探测设备的引脚。例如，对于 STM32 蓝药丸，我们选择了以下引脚（但你可以更改它们）：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You’d have to reference the device’s pinout diagram, and then connect these
    pins with the test points on your target device. Then you’ll have to flash the
    JTAGenum Arduino code ([https://github.com/cyphunk/JTAGenum/blob/master/JTAGenum.ino/](https://github.com/cyphunk/JTAGenum/blob/master/JTAGenum.ino/))
    on the device and communicate with it over serial (the `s` command will scan for
    JTAG combinations).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要参考设备的引脚图，然后将这些引脚与目标设备上的测试点连接。接着，你需要将 JTAGenum Arduino 代码（[https://github.com/cyphunk/JTAGenum/blob/master/JTAGenum.ino/](https://github.com/cyphunk/JTAGenum/blob/master/JTAGenum.ino/)）刷入设备，并通过串口与设备通信（`s`命令将扫描
    JTAG 组合）。
- en: A third way to identify JTAG pins is by inspecting the PCB for one of the pinouts
    shown in [Figure 7-8](#figure7-8). In some cases, PCBs might conveniently provide
    the *Tag-Connect interface*, which is a clear indication that the board has a
    JTAG connector, too. You can see what that interface looks like at [https://www.tag-connect.com/info/](https://www.tag-connect.com/info/).
    Additionally, inspecting the datasheets of the chipsets on the PCB might reveal
    pinout diagrams that point to JTAG interfaces.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 识别 JTAG 引脚的第三种方法是通过检查 PCB 上的引脚图（如[图 7-8](#figure7-8)所示）。在某些情况下，PCB 上可能会方便地提供
    *Tag-Connect 接口*，这清楚地表明该板上也有 JTAG 连接器。你可以在 [https://www.tag-connect.com/info/](https://www.tag-connect.com/info/)
    查看该接口的样子。此外，检查 PCB 上芯片的数据手册可能会揭示出指向 JTAG 接口的引脚图。
- en: '![f07008](Images/f07008.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![f07008](Images/f07008.png)'
- en: 'Figure 7-8: Finding any of these pin interfaces in the PCB, depending on the
    manufacturer (ARM, STMicroelectronics, or Infineon for OCDS), would be a good
    indication that you’re dealing with a JTAG connector.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-8：根据制造商（ARM、STMicroelectronics 或 Infineon 的 OCDS），在 PCB 上找到任何这些引脚接口都可以作为你正在处理
    JTAG 连接器的良好指示。
- en: Hacking a Device Through UART and SWD
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 UART 和 SWD 破解设备
- en: 'In this section, we’ll exploit a microcontroller’s UART and SWD ports to retrieve
    the device memory and bypass the flashed program’s authentication routine. To
    attack the device, we’ll use two tools: a mini ST-Link programmer and a USB-to-serial
    adapter.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将利用微控制器的 UART 和 SWD 接口来获取设备内存并绕过已闪存程序的认证例程。为了攻击设备，我们将使用两种工具：迷你 ST-Link
    编程器和 USB 到串行适配器。
- en: The *mini ST-Link programmer* ([Figure 7-9](#figure7-9)) lets us interact with
    our target device through SWD.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*迷你 ST-Link 编程器*（[图 7-9](#figure7-9)）让我们通过 SWD 与目标设备进行交互。'
- en: '![f07009](Images/f07009.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![f07009](Images/f07009.png)'
- en: 'Figure 7-9: The mini ST-Link V2 programmer lets us interact with STM32 cores
    through SWD.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-9：迷你 ST-Link V2 编程器让我们通过 SWD 与 STM32 核心进行交互。
- en: The *USB-to-serial adapter* ([Figure 7-10](#figure7-10)) lets us communicate
    with the device’s UART pins through our computer’s USB port. This adapter is a
    *transistor-transistor logic (TTL)* device, which means it uses currents of 0
    and 5 volts to represent the values 0 and 1, respectively. Many adapters use the
    FT232R chip, and you can easily find one if you search for USB-to-serial adapters
    online.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*USB 到串行适配器*（[图 7-10](#figure7-10)）让我们通过计算机的 USB 端口与设备的 UART 引脚进行通信。该适配器是一个
    *晶体管-晶体管逻辑（TTL）* 设备，意味着它使用 0 和 5 伏的电流分别表示 0 和 1。许多适配器使用 FT232R 芯片，你可以通过在线搜索 USB
    到串行适配器轻松找到一个。'
- en: '![f07010](Images/f07010.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![f07010](Images/f07010.png)'
- en: 'Figure 7-10: A USB-to-serial (TTL) adapter. This one can also switch between
    5 V and 3.3 V.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-10：USB 到串行（TTL）适配器。此适配器还可以在 5V 和 3.3V 之间切换。
- en: You’ll need a minimum of ten *jumper wires* to connect the devices by their
    pins. We also recommend getting a *breadboard*, which is a construction base that
    you can use to hold the black pill steady. You should be able to purchase these
    hardware components online. We specifically selected the components used here
    because they’re easy to find and inexpensive. But if you wanted an alternative
    to the ST-Link programmer, you could use the Bus Blaster, and as an alternative
    to the USB-to-serial adapter, you could use the Bus Pirate.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要至少十根 *跳线* 来通过引脚连接设备。我们还建议你购买一个 *面包板*，它是一个构建基座，可以用来稳固地固定黑色小药丸。你应该能在网上购买到这些硬件组件。我们特别选择这里使用的组件，因为它们易于找到且价格便宜。但如果你想要替代
    ST-Link 编程器，可以使用 Bus Blaster，替代 USB 到串行适配器，可以使用 Bus Pirate。
- en: As for the software, we’ll use Arduino to code the authentication program we’ll
    attack; we’ll use OpenOCD with GDB for debugging. The following sections show
    you how to set up this testing and debugging environment.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于软件，我们将使用 Arduino 编写我们要攻击的认证程序；我们将使用 OpenOCD 和 GDB 进行调试。以下章节将向你展示如何设置这个测试和调试环境。
- en: The STM32F103C8T6 (Black Pill) Target Device
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: STM32F103C8T6（黑色小药丸）目标设备
- en: The STM32F103xx is a very popular, inexpensive microcontroller family used in
    a large variety of applications in the industrial, medical, and consumer markets.
    It has an ARM Cortex-M3 32-bit RISC core operating at 72 MHz frequency, a flash
    memory of up to 1MB, static random-access memory (SRAM) of up to 96KB, and an
    extensive range of I/Os and peripherals.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: STM32F103xx 是一个非常受欢迎且廉价的微控制器系列，广泛应用于工业、医疗和消费市场。它拥有一个 72 MHz 频率的 ARM Cortex-M3
    32 位 RISC 核心，最多 1MB 的闪存，最多 96KB 的静态随机存取存储器（SRAM），以及丰富的 I/O 和外设接口。
- en: The two versions of this device are known as the blue pill and the black pill
    (based on the board’s color). We’ll use the black pill (STM32F103C8T6) as our
    target device. The main difference between the two versions is that the black
    pill consumes less energy and is sturdier than the blue pill. You can easily order
    it online. We recommend getting a board that has presoldered headers and the Arduino
    bootloader flashed. That way, you won’t have to solder the headers and you’ll
    be able to use the device directly through USB. But in this exercise, we’ll show
    you how to load a program to the black pill without the Arduino bootloader.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该设备有两个版本，分别称为蓝色药丸和黑色药丸（根据板子的颜色）。我们将使用黑色药丸（STM32F103C8T6）作为目标设备。两个版本的主要区别在于，黑色药丸比蓝色药丸消耗更少的能量且更坚固。你可以轻松在线购买它。我们建议购买已经预焊接引脚头并且已经烧录了
    Arduino 启动加载程序的板子。这样，你就不需要焊接引脚头，并且可以直接通过 USB 使用该设备。但在本次练习中，我们将向你展示如何在没有 Arduino
    启动加载程序的情况下，将程序加载到黑色药丸上。
- en: '[Figure 7-11](#figure7-11) shows the device’s pinout diagram. Notice that although
    some pins are 5 V-resistant, others aren’t; so we’ll have to send them no more
    than 3.3 V. If you’re interested in learning more about the internals of the STM32
    microcontroller in general, you can find a very good reference at [https://legacy.cs.indiana.edu/~geobrown/book.pdf](https://legacy.cs.indiana.edu/~geobrown/book.pdf).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-11](#figure7-11)显示了设备的引脚图。请注意，尽管一些引脚支持 5V 电压，其他的则不支持；因此，我们只能向这些引脚提供最多
    3.3V 的电压。如果你有兴趣进一步了解 STM32 微控制器的内部结构，可以参考 [https://legacy.cs.indiana.edu/~geobrown/book.pdf](https://legacy.cs.indiana.edu/~geobrown/book.pdf)
    上的优秀资料。'
- en: Make sure you don’t connect any 5 V output to any of the black pill’s 3.3 V
    pins, or you’ll most likely burn them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 确保不要将任何 5V 输出连接到黑色药丸板的 3.3V 引脚，否则你很可能会烧毁它们。
- en: '![f07011](Images/f07011.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![f07011](Images/f07011.png)'
- en: 'Figure 7-11: STM32F103C8T6 (black pill) pinout diagram'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-11：STM32F103C8T6（黑色药丸）引脚图
- en: Setting Up the Debugging Environment
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置调试环境
- en: We’ll start by programming our target device using the *Arduino Integrated Development
    Environment (IDE)*. The Arduino is an inexpensive, easy-to-use, open source electronics
    platform that lets you program microcontrollers using its Arduino programming
    language. Its IDE contains a text editor for writing code; a board and library
    manager; built-in functionality for verifying, compiling, and uploading the code
    to an Arduino board; and a serial monitor to display output from the hardware.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用 *Arduino 集成开发环境（IDE）* 对目标设备进行编程。Arduino 是一个廉价、易于使用的开源电子平台，让你能够使用 Arduino
    编程语言编程微控制器。其 IDE 包含一个代码编辑器用于编写代码；一个板子和库管理器；内建的功能来验证、编译和上传代码到 Arduino 板；以及一个串口监视器，用于显示硬件的输出。
- en: Installing the Arduino Environment
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装 Arduino 环境
- en: 'You can get the latest version of the Arduino IDE at [https://www.arduino.cc/en/Main/Software/](https://www.arduino.cc/en/Main/Software/).
    For this demonstration, we’ll use version 1.8.9 on Ubuntu 18.04.3 LTS, but the
    operating system you use won’t matter. On Linux, download the package manually
    and follow the instructions at [https://www.arduino.cc/en/guide/linux/](https://www.arduino.cc/en/guide/linux/).
    Alternatively, if you’re using a Debian-based distribution, such as Kali or Ubuntu,
    you can enter the following command in a terminal to install everything you’ll
    need:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://www.arduino.cc/en/Main/Software/](https://www.arduino.cc/en/Main/Software/)
    获取 Arduino IDE 的最新版本。对于本演示，我们将使用 Ubuntu 18.04.3 LTS 上的 1.8.9 版本，但你使用的操作系统不会影响安装。在
    Linux 上，你可以手动下载包并按照 [https://www.arduino.cc/en/guide/linux/](https://www.arduino.cc/en/guide/linux/)
    上的说明操作。或者，如果你使用的是基于 Debian 的发行版，如 Kali 或 Ubuntu，你可以在终端输入以下命令来安装所有所需的工具：
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After installing the IDE, download the latest Arduino STM32 core files from
    GitHub, install them in the *hardware* folder in the Arduino sketches directory,
    and run the *udev rules* installation script.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 IDE 后，从 GitHub 下载最新的 Arduino STM32 核心文件，将其安装到 Arduino 草图目录中的*hardware*文件夹，并运行
    *udev rules* 安装脚本。
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Make sure you replace the username after */home/* with your own username.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将 */home/* 后的用户名替换为你自己的用户名。
- en: If the *hardware* folder doesn’t exist, create it. To discover where the Arduino
    sketches are saved, run the Arduino IDE by entering `arduino` in a terminal or
    clicking the Arduino icon on your Desktop. Then click **File**▶**Preferences**
    and note the **Sketchbook location** file path. In this example, it’s */home/<ithilgore>/Arduino*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*hardware*文件夹不存在，创建它。要查找Arduino草图保存的位置，运行Arduino IDE，方法是终端输入`arduino`或点击桌面上的Arduino图标。然后点击**文件**▶**首选项**，并记下**草图位置**的文件路径。在这个示例中，路径是*/home/<ithilgore>/Arduino*。
- en: 'You’ll also need to install the 32-bit version of `libusb-1.0` as follows because
    the `st-link` utility that comes bundled with the Arduino STM32 relies on it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要安装32位版本的`libusb-1.0`，如下所示，因为Arduino STM32捆绑的`st-link`工具依赖于它：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In addition, install the Arduino SAM boards (Cortex-M3). These are the cores
    for the Cortex-M3 microcontroller. *Cores* are low-level APIs that make specific
    microcontrollers compatible with your Arduino IDE. You can install these inside
    the Arduino IDE by clicking **Tools**▶**Board**▶**Boards Manager**. Then search
    for **SAM Boards**. Click **Install** on the **Arduino SAM Boards (32-bits ARM
    Cortex-M3)** option that should appear. We used version 1.6.12\.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，安装Arduino SAM板（Cortex-M3）。这些是Cortex-M3微控制器的核心。*核心*是低级API，使特定的微控制器与Arduino
    IDE兼容。你可以通过在Arduino IDE中点击**工具**▶**开发板**▶**开发板管理器**来安装它们。然后搜索**SAM板**。点击**安装**，选择应该出现的**Arduino
    SAM Boards (32-bit ARM Cortex-M3)**选项。我们使用的是版本1.6.12\。
- en: You can also find the latest installation instructions for Arduino STM32 at
    [https://github.com/rogerclarkmelbourne/Arduino_STM32/wiki/Installation/](https://github.com/rogerclarkmelbourne/Arduino_STM32/wiki/Installation/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在[https://github.com/rogerclarkmelbourne/Arduino_STM32/wiki/Installation/](https://github.com/rogerclarkmelbourne/Arduino_STM32/wiki/Installation/)找到最新的Arduino
    STM32安装说明。
- en: Installing OpenOCD
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装OpenOCD
- en: '*OpenOCD* is a free and open source testing tool that provides JTAG and SWD
    access through GDB to ARM, MIPS, and RISC-V systems. We’ll use it to debug the
    black pill. To install it in your Linux system, enter the following commands:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*OpenOCD*是一个免费的开源测试工具，通过GDB提供对ARM、MIPS和RISC-V系统的JTAG和SWD访问。我们将使用它来调试黑色药丸。在Linux系统中安装它，可以输入以下命令：'
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that you also install `libusb-1.0`, which you’ll need to enable support
    for Future Technology Devices International (FTDI) devices. Then compile OpenOCD
    from the source. This allows us to enable support for FTDI devices and the Bus
    Pirate tool.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你还需要安装`libusb-1.0`，它是启用对Future Technology Devices International (FTDI)设备支持的必要工具。然后从源代码编译OpenOCD。这使我们能够启用对FTDI设备和Bus
    Pirate工具的支持。
- en: To learn more about OpenOCD, consult its extensive user guide at [http://openocd.org/doc/html/index.html](http://openocd.org/doc/html/index.html).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于OpenOCD的信息，请查阅它的详细用户手册，网址是[http://openocd.org/doc/html/index.html](http://openocd.org/doc/html/index.html)。
- en: Installing the GNU Debugger
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装GNU调试器
- en: '*GDB* is a portable debugger that runs on Unix-like systems. It supports many
    target processors and programming languages. We’ll use GDB to remotely trace and
    alter the target program’s execution.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*GDB*是一个便携式调试器，运行在类Unix系统上。它支持许多目标处理器和编程语言。我们将使用GDB远程跟踪和修改目标程序的执行。'
- en: 'On Ubuntu, you’ll have to install the original `gdb` and `gdb-multiarch`, which
    extends GDB support for multiple target architectures, including ARM (the black
    pill’s architecture). You can do so by entering the following in a terminal:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu上，你需要安装原版的`gdb`和`gdb-multiarch`，后者扩展了GDB对多种目标架构的支持，包括ARM（黑色药丸的架构）。你可以通过在终端中输入以下命令来安装：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Coding a Target Program in Arduino
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Arduino中编写目标程序
- en: Now we’ll write a program in Arduino that we’ll load onto the black pill and
    target for exploitation. In an actual test, you might not have access to the device’s
    source code, but we’re showing it to you for two reasons. First, you’ll learn
    how Arduino code gets translated to a binary that you can upload onto the device.
    Second, when we perform debugging with OpenOCD and GDB, you’ll get to see how
    the assembly code corresponds to the original source code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一个程序，在Arduino中将其加载到黑色药丸（black pill）并以此作为攻击目标。在实际测试中，你可能无法访问设备的源代码，但我们展示这个代码有两个目的。首先，你将了解Arduino代码是如何转换为二进制文件并上传到设备上的。其次，当我们使用OpenOCD和GDB进行调试时，你将看到汇编代码与原始源代码之间的对应关系。
- en: The program ([Listing 7-1](#listing7-1)) uses the serial interface to send and
    receive data. It emulates an authentication process by checking for a password.
    If it receives the right password from the user, it prints `ACCESS GRANTED`. Otherwise,
    it keeps prompting the user to log in.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序（[列表 7-1](#listing7-1)）使用串行接口发送和接收数据。它通过检查密码来模拟身份验证过程。如果它收到正确的密码，它将打印 `ACCESS
    GRANTED`。否则，它会继续提示用户登录。
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 7-1: A serial communication program in Arduino for the STM32F103 chip'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-1：用于 STM32F103 芯片的串行通信程序
- en: We begin by defining four global variables 1. The `bufsiz` variable holds the
    number of bytes for the character array `buf`,``which stores the bytes coming
    through the serial port from the user or device interacting with the port. The
    `new_data` variable is a boolean that becomes `true` every time the main program
    loop receives a new line of serial data. The boolean variable `start` is `true`
    only upon the first iteration of the main loop, so it prints the first “Login”
    prompt.``
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了四个全局变量。1. `bufsiz` 变量保存字符数组 `buf` 的字节数，`buf` 存储通过串口从用户或与该端口交互的设备传输的字节。`new_data`
    变量是一个布尔值，每当主程序循环接收到一行新的串行数据时，它变为 `true`。布尔变量 `start` 只有在主循环的第一次迭代时才为 `true`，因此它会打印第一次的“登录”提示。
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
