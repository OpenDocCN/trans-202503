- en: '11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '11'
- en: IMPLEMENTING AND ATTACKING CRYPTOGRAPHY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 实现与攻击加密技术
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common.jpg)'
- en: A conversation about security isn’t complete without exploring *cryptography*.
    When organizations use cryptographic practices, they can help conserve the integrity,
    confidentiality, and authenticity of their information and systems alike. As a
    tool developer, you’d likely need to implement cryptographic features, perhaps
    for SSL/TLS communications, mutual authentication, symmetric-key cryptography,
    or password hashing. But developers often implement cryptographic functions insecurely,
    which means the offensive-minded can exploit these weaknesses to compromise sensitive,
    valuable data, such as social security or credit card numbers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论安全性时，如果不涉及*加密学*，那就不完整。当组织使用加密实践时，它们可以帮助保持信息和系统的完整性、机密性和真实性。作为工具开发者，你可能需要实现加密功能，或许是为了
    SSL/TLS 通信、互相认证、对称密钥加密或密码哈希。然而，开发者经常以不安全的方式实现加密功能，这意味着攻击者可以利用这些弱点来破坏敏感的、具有价值的数据，如社会保障号码或信用卡号码。
- en: This chapter demonstrates various implementations of cryptography in Go and
    discusses common weaknesses you can exploit. Although we provide introductory
    information for the different cryptographic functions and code blocks, we’re not
    attempting to explore the nuances of cryptographic algorithms or their mathematical
    foundations. That, frankly, is far beyond our interest in (or knowledge of) cryptography.
    As we’ve stated before, don’t attempt anything in this chapter against resources
    or assets without explicit permission from the owner. We’re including these discussions
    for learning purposes, not to assist in illegal activities.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了在 Go 语言中实现加密技术的各种方式，并讨论了你可以利用的常见弱点。尽管我们提供了不同加密函数和代码块的介绍信息，但我们并不打算深入探讨加密算法的细节或其数学基础。坦率地说，这远远超出了我们对加密学的兴趣（或知识）。正如我们之前所说，未经所有者明确许可，请勿在任何资源或资产上尝试本章中的内容。我们提供这些讨论是为了学习目的，而不是为了协助非法活动。
- en: Reviewing Basic Cryptography Concepts
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回顾基本的加密学概念
- en: Before we explore crypto in Go, let’s discuss a few basic cryptography concepts.
    We’ll make this short to keep you from falling into a deep sleep.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索 Go 中的加密技术之前，先来讨论一些基本的加密学概念。我们会简要介绍，避免让你陷入深度睡眠。
- en: First, encryption (for the purposes of maintaining confidentiality) is just
    one of the tasks of cryptography. *Encryption*, generally speaking, is a two-way
    function with which you can scramble data and subsequently unscramble it to retrieve
    the initial input. The process of encrypting data renders it meaningless until
    it’s been decrypted.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，加密（为了保持机密性）只是加密学的一项任务。*加密*，一般来说，是一个双向功能，你可以将数据加密并随后解密以恢复原始输入。加密数据的过程会使数据变得无意义，直到它被解密为止。
- en: Both encryption and decryption involve passing the data and an accompanying
    key into a cryptographic function. The function outputs either the encrypted data
    (called *ciphertext*) or the original, readable data (called *cleartext)*. Various
    algorithms exist to do this. *Symmetric* algorithms use the same key during the
    encryption and decryption processes, whereas *asymmetric* algorithms use different
    keys for encryption and decryption. You might use encryption to protect data in
    transit or to store sensitive information, such as credit card numbers, to decrypt
    later, perhaps for convenience during a future purchase or for fraud monitoring.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 加密和解密都涉及将数据和一个附带的密钥传入加密函数。该函数输出加密数据（称为*密文*）或原始的、可读的数据（称为*明文*）。有多种算法可以实现这一过程。*对称*算法在加密和解密过程中使用相同的密钥，而*非对称*算法在加密和解密过程中使用不同的密钥。你可能会使用加密来保护传输中的数据，或者存储敏感信息，例如信用卡号码，以便稍后解密，可能是为了将来购物时的便利，或进行欺诈监控。
- en: On the other hand, *hashing* is a one-way process for mathematically scrambling
    data. You can pass sensitive information into a hashing function to produce a
    fixed-length output. When you’re working with strong algorithms, such as those
    in the SHA-2 family, the probability that different inputs produce the same output
    is extremely low. That is, there is a low likelihood of a *collision*. Because
    they’re nonreversible, hashes are commonly used as an alternative to storing cleartext
    passwords in a database or to perform integrity checking to determine whether
    data has been changed. If you need to obscure or randomize the outputs for two
    identical inputs, you use a *salt*, which is a random value used to differentiate
    two identical inputs during the hashing process. Salts are common for password
    storage because they allow multiple users who coincidentally use identical passwords
    to still have different hash values.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，*哈希*是一种单向过程，用于在数学上对数据进行混淆。你可以将敏感信息传入哈希函数，以产生固定长度的输出。当你使用强大的算法时，例如SHA-2系列算法，不同输入产生相同输出的概率极低。也就是说，发生*碰撞*的可能性很小。由于哈希是不可逆的，它们通常被用作替代方案，用于在数据库中存储明文密码，或者进行完整性检查，以确定数据是否已被更改。如果你需要模糊或随机化两个相同输入的输出，可以使用*盐*，它是一个随机值，用来在哈希过程中区分两个相同的输入。盐通常用于密码存储，因为它们允许多个恰好使用相同密码的用户仍然具有不同的哈希值。
- en: Cryptography also provides a means for authenticating messages. A *message authentication
    code (MAC)* is the output produced from a special one-way cryptographic function.
    This function consumes the data itself, a secret key, and an initialization vector,
    and produces an output unlikely to have a collision. The sender of a message performs
    the function to generate a MAC and then includes the MAC as part of the message.
    The receiver locally calculates the MAC and compares it to the MAC they received.
    A match indicates that the sender has the correct secret key (that is, that the
    sender is authentic) and that the message was not changed (the integrity has been
    maintained).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 加密学还提供了一种认证消息的手段。*消息认证码（MAC）*是从一个特殊的单向加密函数产生的输出。该函数会使用数据本身、一个秘密密钥和一个初始化向量，并产生一个输出，这个输出不太可能发生碰撞。消息的发送者执行该函数以生成MAC，并将MAC作为消息的一部分发送出去。接收方在本地计算MAC并与接收到的MAC进行比较。如果匹配，则表示发送者拥有正确的秘密密钥（即发送者是可信的），并且消息没有被更改（即完整性得到了保持）。
- en: There! Now you should know enough about cryptography to understand the contents
    of this chapter. Where necessary, we’ll discuss more specifics relevant to the
    given topic. Let’s start by looking at Go’s standard crypto library.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！现在你应该对加密学有足够的了解，能够理解本章的内容。必要时，我们会讨论与特定主题相关的更多细节。让我们先来看一下Go的标准加密库。
- en: Understanding the Standard Crypto Library
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解标准加密库
- en: The beautiful thing about implementing crypto in Go is that the majority of
    cryptographic features you’ll likely use are part of the standard library. Whereas
    other languages commonly rely on OpenSSL or other third-party libraries, Go’s
    crypto features are part of the official repositories. This makes implementing
    crypto relatively straightforward, as you won’t have to install clumsy dependencies
    that’ll pollute your development environment. There are two separate repositories.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中实现加密的美妙之处在于，你很可能会使用的大多数加密功能都是标准库的一部分。而其他语言通常依赖于OpenSSL或其他第三方库，Go的加密功能则是官方库的一部分。这使得实现加密相对简单，因为你不需要安装繁琐的依赖项，从而避免污染开发环境。这里有两个独立的库。
- en: The self-contained `crypto` package contains a variety of subpackages used for
    the most common cryptographic tasks and algorithms. For example, you could use
    the `aes`, `des`, and `rc4` subpackages for implementing symmetric-key algorithms;
    the `dsa` and `rsa` subpackages for asymmetric encryption; and the `md5`, `sha1`,
    `sha256`, and `sha512` subpackages for hashing. This is not an exhaustive list;
    additional subpackages exist for other crypto functions, as well.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 自包含的`crypto`包包含用于最常见的加密任务和算法的多种子包。例如，你可以使用`aes`、`des`和`rc4`子包来实现对称密钥算法；使用`dsa`和`rsa`子包来进行非对称加密；使用`md5`、`sha1`、`sha256`和`sha512`子包进行哈希。这不是一个详尽无遗的列表，还有其他子包可用于其他加密功能。
- en: 'In addition to the standard `crypto` package, Go has an official, extended
    package that contains a variety of supplementary crypto functionality: `golang``.org/x/crypto`.
    The functionality within includes additional hashing algorithms, encryption ciphers,
    and utilities. For example, the package contains a `bcrypt` subpackage for *bcrypt
    hashing* (a better, more secure alternative for hashing passwords and sensitive
    data), `acme/autocert` for generating legitimate certificates, and SSH subpackages
    to facilitate communications over the SSH protocol.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准的 `crypto` 包，Go 还提供了一个官方的扩展包，其中包含了多种附加的加密功能：`golang.org/x/crypto`。该包中的功能包括额外的哈希算法、加密算法和工具。例如，该包包含了一个用于
    *bcrypt 哈希* 的子包（这是一个更好的、更安全的哈希密码和敏感数据的替代方法），`acme/autocert` 用于生成合法的证书，还有用于 SSH
    协议通信的 SSH 子包。
- en: 'The only real difference between the built-in `crypto` and supplementary `golang.org/x/crypto`
    packages is that the `crypto` package adheres to more stringent compatibility
    requirements. Also, if you wish to use any of the `golang``.org/x/crypto` subpackages,
    you’ll first need to install the package by entering the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `crypto` 包和附加的 `golang.org/x/crypto` 包之间唯一的真正区别是，`crypto` 包遵循更严格的兼容性要求。此外，如果你希望使用任何
    `golang.org/x/crypto` 子包，你需要先通过以下命令安装该包：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For a complete listing of all the functionality and subpackages within the official
    Go crypto packages, check out the official documentation at [*https://golang.org/pkg/crypto/*](https://golang.org/pkg/crypto/)
    and [*https://godoc.org/golang.org/x/crypto/*](https://godoc.org/golang.org/x/crypto/).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看官方 Go 加密包中所有功能和子包的完整列表，请查阅官方文档：[*https://golang.org/pkg/crypto/*](https://golang.org/pkg/crypto/)
    和 [*https://godoc.org/golang.org/x/crypto/*](https://godoc.org/golang.org/x/crypto/)。
- en: The next sections delve into various crypto implementations. You’ll see how
    to use Go’s crypto functionality to do some nefarious things, such as crack password
    hashes, decrypt sensitive data by using a static key, and brute-force weak encryption
    ciphers. You’ll also use the functionality to create tools that use TLS to protect
    your in-transit communications, check the integrity and authenticity of data,
    and perform mutual authentication.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将深入探讨各种加密实现。你将看到如何使用 Go 的加密功能做一些恶意操作，例如破解密码哈希、使用静态密钥解密敏感数据，以及暴力破解弱加密算法。你还将使用这些功能来创建使用
    TLS 保护传输中的通信、检查数据的完整性和真实性，并执行互相认证的工具。
- en: Exploring Hashing
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索哈希
- en: Hashing, as we mentioned previously, is a one-way function used to produce a
    fixed-length, probabilistically unique output based on a variable-length input.
    You can’t reverse this hash value to retrieve the original input source. Hashes
    are often used to store information whose original, cleartext source won’t be
    needed for future processing or to track the integrity of data. For example, it’s
    bad practice and generally unnecessary to store the cleartext version of the password;
    instead, you’d store the hash (salted, ideally, to ensure randomness between duplicate
    values).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希，如前所述，是一种单向函数，用于根据可变长度的输入生成固定长度的、概率上唯一的输出。你无法通过反向操作哈希值来找回原始输入数据。哈希常用于存储那些不需要原始明文数据进行后续处理或用于跟踪数据完整性的信息。例如，存储明文密码是一个不好的做法，通常也是不必要的；你应当存储哈希值（理想情况下加盐，以确保不同值之间的随机性）。
- en: To demonstrate hashing in Go, we’ll look at two examples. The first attempts
    to crack a given MD5 or SHA-512 hash by using an offline dictionary attack. The
    second example demonstrates an implementation of bcrypt. As mentioned previously,
    bcrypt is a more secure algorithm for hashing sensitive data such as passwords.
    The algorithm also contains a feature that reduces its speed, making it harder
    to crack passwords.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 Go 中的哈希操作，我们来看两个例子。第一个例子试图通过离线字典攻击来破解给定的 MD5 或 SHA-512 哈希值。第二个例子展示了 bcrypt
    的实现。如前所述，bcrypt 是一种用于哈希敏感数据（如密码）的更安全的算法。该算法还包含一个降低速度的特性，使得破解密码变得更加困难。
- en: Cracking an MD5 or SHA-256 Hash
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 破解 MD5 或 SHA-256 哈希
- en: '[Listing 11-1](ch11.xhtml#ch11list1) shows the hash-cracking code. (All the
    code listings at the root location of / exist under the provided github repo *[https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)*.)
    Since hashes aren’t directly reversible, the code instead tries to guess the cleartext
    value of the hash by generating its own hashes of common words, taken from a word
    list, and then comparing the resulting hash value with the hash you have in hand.
    If the two hashes match, you’ve likely guessed the cleartext value.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-1](ch11.xhtml#ch11list1) 展示了哈希破解的代码。（所有位于根目录 `/` 的代码列表都存在于提供的 GitHub
    仓库 *[https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)*
    下。）由于哈希值不可直接反转，代码会通过生成常见词汇的哈希（这些词汇来自于一个单词列表），然后将生成的哈希值与手头的哈希值进行比较，从而尝试猜测哈希的明文值。如果两个哈希值匹配，你可能已经猜到了明文值。'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 11-1: Cracking MD5 and SHA-256 hashes (*[/ch-11/hashes/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-11/hashes/main.go)*)*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-1：破解 MD5 和 SHA-256 哈希值 (*[/ch-11/hashes/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-11/hashes/main.go)*)*'
- en: You start by defining two variables ❶ that hold the target hash values. One
    is an MD5 hash, and the other is a SHA-256\. Imagine that you acquired these two
    hashes as part of post-exploitation and you’re trying to determine the inputs
    (the cleartext passwords) that produced them after being run through the hashing
    algorithm. You can often determine the algorithm by inspecting the length of the
    hash itself. When you find a hash that matches the target, you’ll know you have
    the correct input.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你从定义两个变量 ❶ 开始，它们分别保存目标哈希值。一个是 MD5 哈希，另一个是 SHA-256 哈希。假设你在后渗透过程中获得了这两个哈希值，你正试图确定哪些输入（明文密码）经过哈希算法处理后生成了它们。你通常可以通过检查哈希值的长度来确定使用的算法。当你找到一个与目标哈希匹配的哈希时，就可以确认你找到了正确的输入。
- en: The list of inputs you’ll try exists in a dictionary file you’ll have created
    earlier. Alternatively, a Google search can help you find dictionary files for
    commonly used passwords. To check the MD5 hash, you open the dictionary file ❷
    and read it, line by line, by creating a `bufio.Scanner` on the file descriptor
    ❸. Each line consists of a single password value that you wish to check. You pass
    the current password value into a function named `md5.Sum(input` `[]byte``)` ❹.
    This function produces the MD5 hash value as raw bytes, so you use the `fmt.Sprintf()`
    function with the format string `%x` to convert it to a hexadecimal string. After
    all, your `md5hash` variable consists of a hexadecimal string representation of
    the target hash. Converting your value ensures that you can then compare the target
    and calculated hash values ❺. If these hashes match, the program displays a success
    message to stdout.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你将尝试的输入列表存在一个字典文件中，该文件是在之前创建的。或者，Google 搜索可以帮助你找到用于常用密码的字典文件。要检查 MD5 哈希值，你需要打开字典文件
    ❷，并通过在文件描述符 ❸ 上创建一个 `bufio.Scanner` 来逐行读取它。每一行包含一个你想要检查的密码值。你将当前密码值传入一个名为 `md5.Sum(input
    []byte)` 的函数 ❹。该函数生成 MD5 哈希值作为原始字节，因此你使用 `fmt.Sprintf()` 函数并结合格式化字符串 `%x` 将其转换为十六进制字符串。毕竟，你的
    `md5hash` 变量是目标哈希的十六进制字符串表示。转换后的值使你能够比较目标哈希和计算出的哈希值 ❺。如果这两个哈希匹配，程序将在标准输出显示成功消息。
- en: You perform a similar process to calculate and compare SHA-256 hashes. The implementation
    is fairly similar to the MD5 code. The only real difference is that the `sha256`
    package contains additional functions to calculate various SHA hash lengths. Rather
    than calling `sha256.Sum()` (a function that doesn’t exist), you instead call
    `sha256.Sum256(input []byte)` ❻ to force the hash to be calculated using the SHA-256
    algorithm. Much as you did in the MD5 example, you convert your raw bytes to a
    hex string and compare the SHA-256 hashes to see whether you have a match ❼.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你执行类似的过程来计算并比较 SHA-256 哈希值。实现方式与 MD5 代码非常相似。唯一的实际差异是 `sha256` 包包含额外的函数，用于计算各种
    SHA 哈希长度。你不是调用 `sha256.Sum()`（一个不存在的函数），而是调用 `sha256.Sum256(input []byte)` ❻ 强制使用
    SHA-256 算法计算哈希。就像在 MD5 示例中一样，你将原始字节转换为十六进制字符串，并比较 SHA-256 哈希值，以查看是否匹配 ❼。
- en: Implementing bcrypt
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现 bcrypt
- en: The next example shows how to use bcrypt to encrypt and authenticate passwords.
    Unlike SHA and MD5, bcrypt was designed for password hashing, making it a better
    option for application designers than the SHA or MD5 families. It includes a salt
    by default, as well as a cost factor that makes running the algorithm more resource-intensive.
    This cost factor controls the number of iterations of the internal crypto functions,
    increasing the time and effort needed to crack a password hash. Although the password
    can still be cracked using a dictionary or brute-force attack, the cost (in time)
    increases significantly, discouraging cracking activities during time-sensitive
    post-exploitation. It’s also possible to increase the cost over time to counter
    the advancement of computing power. This makes it adaptive to future cracking
    attacks.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了如何使用 bcrypt 来加密和验证密码。与 SHA 和 MD5 不同，bcrypt 是专为密码哈希设计的，比 SHA 或 MD5 更适合应用程序设计人员使用。它默认包括盐值，并且有一个成本因子，使得算法执行更加资源密集。这个成本因子控制内部加密函数的迭代次数，从而增加了破解密码哈希所需的时间和努力。虽然密码仍然可以通过字典攻击或暴力破解攻击被破解，但成本（时间）显著增加，这使得在时间敏感的后期利用中，破解活动变得不划算。随着计算能力的提升，也可以逐步增加成本，以应对未来的破解攻击。这使得
    bcrypt 对未来的破解攻击具有适应性。
- en: '[Listing 11-2](ch11.xhtml#ch11list2) creates a bcrypt hash and then validates
    whether a cleartext password matches a given bcrypt hash.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-2](ch11.xhtml#ch11list2) 创建一个 bcrypt 哈希，并验证一个明文密码是否与给定的 bcrypt 哈希匹配。'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 11-2: Comparing bcrypt hashes (*[/ch-11/bcrypt/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-11/bcrypt/main.go)*)*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-2：比较 bcrypt 哈希（*[/ch-11/bcrypt/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-11/bcrypt/main.go)*)*'
- en: For most of the code samples in this book, we’ve omitted the package imports.
    We’ve included them in this example to explicitly show that you’re using the supplemental
    Go package, `golang.org/x/crypto/bcrypt` ❶, because Go’s built-in `crypto` package
    doesn’t contain the bcrypt functionality. You then initialize a variable, `storedHash`
    ❷, that holds a precomputed, encoded bcrypt hash. This is a contrived example;
    rather than wiring our sample code up to a database to get a value, we’ve opted
    to hardcode a value for demonstrative purposes. The variable could represent a
    value that you’ve found in a database row that stores user authentication information
    for a frontend web application, for instance.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中的大多数代码示例，我们省略了包的导入。在这个示例中，我们显式地包含了它们，以展示你正在使用辅助的 Go 包 `golang.org/x/crypto/bcrypt`
    ❶，因为 Go 内置的 `crypto` 包并不包含 bcrypt 功能。接下来，你会初始化一个变量 `storedHash` ❷，该变量保存一个预计算的、编码后的
    bcrypt 哈希值。这是一个虚构的示例；我们没有将示例代码与数据库连接以获取值，而是为了演示目的选择了硬编码一个值。这个变量可以代表你在数据库行中找到的一个值，那个行存储了前端
    Web 应用程序的用户身份验证信息。
- en: 'Next, you’ll produce a bcrypt-encoded hash from a cleartext password value.
    The main function reads a password value as a command line argument and proceeds
    to call two separate bcrypt functions. The first function, `bcrypt.GenerateFromPassword()`
    ❸, accepts two parameters: a byte slice representing the cleartext password and
    a cost value. In this example, you’ll pass the constant variable `bcrypt.DefaultCost`
    to use the package’s default cost, which is 10 at the time of this writing. The
    function returns the encoded hash value and any errors produced.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将从明文密码值生成一个 bcrypt 编码的哈希值。主函数将密码值作为命令行参数读取，并调用两个不同的 bcrypt 函数。第一个函数 `bcrypt.GenerateFromPassword()`
    ❸ 接受两个参数：一个字节切片，表示明文密码和一个成本值。在这个示例中，你将传递常量变量 `bcrypt.DefaultCost` 来使用该包的默认成本，该成本在撰写时为
    10。该函数返回编码后的哈希值和可能产生的错误。
- en: The second bcrypt function you call is `bcrypt.CompareHashAndPassword()` ❹,
    which does the hash comparison for you behind the scenes. It accepts a bcrypt-encoded
    hash and a cleartext password as byte slices. The function parses the encoded
    hash to determine the cost and salt. It then uses these values with the cleartext
    password value to generate a bcrypt hash. If this resulting hash matches the hash
    extracted from the encoded `storedHash` value, you know the provided password
    matches what was used to create the `storedHash`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你调用的第二个 bcrypt 函数是 `bcrypt.CompareHashAndPassword()` ❹，它在后台为你进行哈希比较。它接受一个经过
    bcrypt 编码的哈希值和一个明文密码，作为字节切片传入。该函数解析编码的哈希值，以确定成本和盐值。然后，它使用这些值和明文密码值生成一个 bcrypt
    哈希。如果生成的哈希值与从编码的 `storedHash` 值中提取出的哈希值匹配，那么你就知道提供的密码与创建 `storedHash` 时使用的密码一致。
- en: This is the same method you used to perform your password cracking against SHA
    and MD5—run a given password through the hashing function and compare the result
    with the stored hash. Here, rather than explicitly comparing the resulting hashes
    as you did for SHA and MD5, you check whether `bcrypt.CompareHashAndPassword()`
    returns an error. If you see an error, you know the computed hashes, and therefore
    the passwords used to compute them, do not match.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这与您使用的破解SHA和MD5密码的方法相同——将给定的密码通过哈希函数并将结果与存储的哈希值进行比较。在这里，您不是像破解SHA和MD5那样显式比较结果哈希，而是检查`bcrypt.CompareHashAndPassword()`是否返回错误。如果你看到错误，那就说明计算出的哈希值，进而计算这些哈希值的密码，不匹配。
- en: 'The following are two sample program runs. The first shows the output for an
    incorrect password:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是两个示例程序的运行情况，第一个展示了错误密码的输出：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The second shows the output for the correct password:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例展示了正确密码的输出：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Those of you with a keen eye for detail may notice that the hash value displayed
    for your successful authentication does not match the value you hardcoded for
    your `storedHash` variable. Recall, if you will, that your code is calling two
    separate functions. The `GenerateFromPassword()` function produces the encoded
    hash by using a random salt value. Given different salts, the same password will
    produce different resulting hashes. Hence the difference. The `CompareHashAndPassword()`
    function performs the hashing algorithm by using the same salt and cost as the
    stored hash, so the resulting hash is identical to the one in the `storedHash`
    variable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你细心观察，可能会注意到，在你成功认证时显示的哈希值与`storedHash`变量中你硬编码的值并不匹配。回想一下，你的代码调用了两个不同的函数。`GenerateFromPassword()`函数通过使用一个随机的盐值来生成编码后的哈希。由于盐值不同，即使是相同的密码也会生成不同的哈希值，这就是差异的原因。而`CompareHashAndPassword()`函数则使用与存储哈希相同的盐值和成本来执行哈希算法，因此生成的哈希值与`storedHash`变量中的值完全相同。
- en: Authenticating Messages
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息认证
- en: Let’s now turn our focus to message authentication. When exchanging messages,
    you need to validate both the integrity of data and the authenticity of the remote
    service to make sure that the data is authentic and hasn’t been tampered with.
    Was the message altered during transmission by an unauthorized source? Was the
    message sent by an authorized sender or was it forged by another entity?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将焦点转向消息认证。在交换消息时，你需要验证数据的完整性以及远程服务的真实性，以确保数据是合法的且没有被篡改。消息在传输过程中是否被未经授权的源篡改过？这条消息是由授权的发送者发送的吗，还是被其他实体伪造的？
- en: You can address these questions by using Go’s `crypto/hmac` package, which implements
    the *Keyed-Hash Message Authentication Code* (HMAC) standard. HMAC is a cryptographic
    algorithm that allows us to check for message tampering and verify the identity
    of the source. It uses a hashing function and consumes a shared secret key, which
    only the parties authorized to produce valid messages or data should possess.
    An attacker who does not possess this shared secret cannot reasonably forge a
    valid HMAC value.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用Go的`crypto/hmac`包来解决这些问题，它实现了*密钥哈希消息认证码*（HMAC）标准。HMAC是一种加密算法，允许我们检查消息是否被篡改，并验证来源的身份。它使用哈希函数并消耗一个共享的秘密密钥，只有被授权生成有效消息或数据的双方才应该拥有这个密钥。如果攻击者没有这个共享的秘密密钥，就无法合理地伪造有效的HMAC值。
- en: Implementing HMAC in some programming languages can be a little tricky. For
    example, some languages force you to manually compare the received and calculated
    hash values byte by byte. Developers may inadvertently introduce timing discrepancies
    in this process if their byte-by-byte comparison is aborted prematurely; an attacker
    can deduce the expected HMAC by measuring message-processing times. Additionally,
    developers will occasionally think HMACs (which consume a message and key) are
    the same as a hash of a secret key prepended to a message. However, the internal
    functionality of HMACs differs from that of a pure hashing function. By not explicitly
    using an HMAC, the developer is exposing the application to length-extension attacks,
    in which an attacker forges a message and valid MAC.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些编程语言中实现HMAC可能有点棘手。例如，某些语言要求你手动逐字节地比较接收到的哈希值与计算出来的哈希值。如果开发人员在这个逐字节比较的过程中中途终止，可能会不小心引入时间差异；攻击者可以通过测量消息处理时间来推测预期的HMAC值。此外，开发人员有时会误以为HMAC（它同时使用消息和密钥）与将秘密密钥附加到消息前的哈希是一样的。然而，HMAC的内部功能与纯粹的哈希函数是不同的。如果没有显式使用HMAC，开发人员就会暴露应用程序于长度扩展攻击，其中攻击者伪造消息并生成有效的MAC。
- en: Luckily for us Gophers, the `crypto/hmac` package makes it fairly easy to implement
    HMAC functionality in a secure fashion. Let’s look at an implementation. Note
    that the following program is much simpler than a typical use case, which would
    likely involve some type of network communications and messaging. In most cases,
    you’d calculate the HMAC on HTTP request parameters or some other message transmitted
    over a network. In the example shown in [Listing 11-3](ch11.xhtml#ch11list3),
    we’re omitting the client-server communications and focusing solely on the HMAC
    functionality.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于我们这些Go程序员来说，`crypto/hmac`包使得以安全的方式实现HMAC功能变得相对容易。让我们来看一个实现例子。请注意，以下程序比典型的使用案例要简单得多，典型的使用场景可能涉及某种网络通信和消息传递。在大多数情况下，你会计算HTTP请求参数上的HMAC，或者一些其他通过网络传输的消息。在[示例
    11-3](ch11.xhtml#ch11list3)中，我们省略了客户端和服务器之间的通信，专注于HMAC功能本身。
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 11-3: Using HMAC for message authentication (*[/ch-11/hmac/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-11/hmac/main.go)*)*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11-3：使用HMAC进行消息认证 (*[/ch-11/hmac/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-11/hmac/main.go)*)*'
- en: The program begins by defining the key you’ll use for your HMAC cryptographic
    function ❶. You’re hardcoding the value here, but in a real implementation, this
    key would be adequately protected and random. It would also be shared between
    the endpoints, meaning both the message sender and receiver are using this same
    key value. Since you aren’t implementing full client-server functionality here,
    you’ll use this variable as if it were adequately shared.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 程序首先定义了你将用于HMAC加密功能的密钥 ❶。你在这里硬编码了这个值，但在实际的实现中，这个密钥应该得到适当的保护并且是随机的。它还应在端点之间共享，也就是说，消息发送方和接收方都在使用相同的密钥值。由于你在这里并没有实现完整的客户端-服务器功能，因此你可以假设该变量已经得到了适当的共享。
- en: Next, you define a function, `checkMAC()` ❷, that accepts a message and the
    received HMAC as parameters. The message receiver would call this function to
    check whether the MAC value they received matches the value they calculated locally.
    First, you call `hmac.New()` ❸, passing to it `sha256.New`, which is a function
    that returns a `hash.Hash` instance, and the shared secret key. In this case,
    the `hmac.New()` function initializes your HMAC by using the SHA-256 algorithm
    and your secret key, and assigns the result to a variable named `mac`. You then
    use this variable to calculate the HMAC hash value, as you did in the earlier
    hashing examples. Here, you call `mac.Write(message)` and `mac.Sum(nil)`, respectively.
    The result is your locally calculated HMAC, stored in a variable named `calcMAC`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你定义了一个函数，`checkMAC()` ❷，该函数接受一个消息和接收到的HMAC作为参数。消息接收方会调用此函数检查他们收到的MAC值是否与他们本地计算的值匹配。首先，你调用`hmac.New()`
    ❸，并传入`sha256.New`，这是一个返回`hash.Hash`实例的函数，以及共享的密钥。在这种情况下，`hmac.New()`函数通过使用SHA-256算法和你的密钥来初始化HMAC，并将结果赋值给名为`mac`的变量。然后，你使用这个变量像之前的哈希示例一样计算HMAC哈希值。这里，你依次调用`mac.Write(message)`和`mac.Sum(nil)`。结果是你本地计算的HMAC，存储在名为`calcMAC`的变量中。
- en: The next step is to evaluate whether your locally calculated HMAC value is equal
    to the HMAC value you received. To do this in a secure manner, you call `hmac.Equal(calcMAC,
    recvMAC)` ❹. A lot of developers would be inclined to compare the byte slices
    by calling `bytes.Compare(calcMAC,` `recvMAC``)`. The problem is, `bytes.Compare()`
    performs a lexicographical comparison, walking and comparing each element of the
    given slices until it finds a difference or reaches the end of a slice. The time
    it takes to complete this comparison will vary based on whether `bytes.Compare()`
    encounters a difference on the first element, the last, or somewhere in between.
    An attacker could measure this variation in time to determine the expected HMAC
    value and forge a request that’s processed legitimately. The `hmac.Equal()` function
    solves this problem by comparing the slices in a way that produces nearly constant
    measurable times. It doesn’t matter where the function finds a difference, because
    the processing times will vary insignificantly, producing no obvious or perceptible
    pattern.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是评估你本地计算出的HMAC值是否与接收到的HMAC值相等。为了安全地做到这一点，你调用`hmac.Equal(calcMAC, recvMAC)`❹。许多开发人员可能倾向于通过调用`bytes.Compare(calcMAC,
    recvMAC)`来比较字节切片。问题是，`bytes.Compare()`执行的是字典顺序比较，它会遍历并比较给定切片的每个元素，直到找到差异或到达切片的末尾。完成这个比较所需的时间会因`bytes.Compare()`在第一个元素、最后一个元素或中间某个地方遇到差异而有所不同。攻击者可以通过测量这一时间变化来确定预期的HMAC值，并伪造一个被合法处理的请求。`hmac.Equal()`函数通过以几乎恒定的可测时间比较切片来解决这个问题。无论函数在哪个位置发现差异，处理时间变化都非常微小，不会产生明显或可感知的模式。
- en: The `main()` function simulates the process of receiving a message from a client.
    If you were really receiving a message, you’d have to read and parse the HMAC
    and message values from the transmission. Since this is just a simulation, you
    instead hardcode the received message ❺ and the received HMAC ❻, decoding the
    HMAC hex string so it’s represented as a `[]byte`. You use an `if` statement to
    call your `checkMAC()` function ❼, passing it your received message and HMAC.
    As detailed previously, your `checkMAC()` function computes an HMAC by using the
    received message and the shared secret key and returns a `bool` value for whether
    the received HMAC and calculated HMAC match.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数模拟接收来自客户端的消息过程。如果你真正在接收消息，你需要从传输中读取并解析HMAC和消息值。由于这只是一个模拟，你将接收到的消息❺和接收到的HMAC❻硬编码进来，并解码HMAC十六进制字符串，使其表示为`[]byte`。你使用`if`语句调用你的`checkMAC()`函数❼，并将接收到的消息和HMAC传递给它。正如前面所详细描述的，你的`checkMAC()`函数通过使用接收到的消息和共享的密钥计算HMAC，并返回一个`bool`值，表示接收到的HMAC和计算出来的HMAC是否匹配。'
- en: Although the HMAC does provide both authenticity and integrity assurance, it
    doesn’t ensure confidentiality. You can’t know for sure that the message itself
    wasn’t seen by unauthorized resources. The next section addresses this concern
    by exploring and implementing various types of encryption.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然HMAC提供了真实性和完整性保证，但它并不能确保保密性。你无法完全确认消息本身是否被未经授权的资源看到。下一部分将通过探索和实现各种加密类型来解决这个问题。
- en: Encrypting Data
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加密数据
- en: Encryption is likely the most well-known cryptographic concept. After all, privacy
    and data protection have garnered significant news coverage due to high-profile
    data breaches, often resulting from organizations storing user passwords and other
    sensitive data in unencrypted formats. Even without the media attention, encryption
    should spark the interest of black hats and developers alike. After all, understanding
    the basic process and implementation can be the difference between a lucrative
    data breach and a frustrating disruption to an attack kill chain. The following
    section presents the varying forms of encryption, including useful applications
    and use cases for each.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 加密可能是最为人知的加密概念。毕竟，隐私和数据保护因高调的数据泄露事件而受到广泛关注，这些事件通常是因为组织将用户密码和其他敏感数据以未加密的格式存储所导致的。即使没有媒体的关注，加密也应该引起黑客和开发人员的兴趣。毕竟，理解基本的过程和实现可能是决定数据泄露和攻击杀链中断之间的关键。以下部分介绍了不同形式的加密，包括每种形式的有用应用和使用案例。
- en: Symmetric-Key Encryption
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对称密钥加密
- en: Your journey into encryption will start with what is arguably its most straightforward
    form—*symmetric-key encryption*. In this form, both the encryption and decryption
    functions use the same secret key. Go makes symmetric cryptography pretty straightforward,
    because it supports most common algorithms in its default or extended packages.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你进入加密的旅程将从其最简单的形式——*对称密钥加密*开始。在这种形式中，加密和解密功能使用相同的密钥。Go 使对称加密变得相当简单，因为它在默认或扩展包中支持大多数常见的算法。
- en: For the sake of brevity, we’ll limit our discussion of symmetric-key encryption
    to a single, practical example. Let’s imagine you’ve breached an organization.
    You’ve performed the necessary privilege escalation, lateral movement, and network
    recon to gain access to an e-commerce web server and the backend database. The
    database contains financial transactions; however, the credit card number used
    in those transactions is obviously encrypted. You inspect the application source
    code on the web server and determine that the organization is using the Advanced
    Encryption Standard (AES) encryption algorithm. AES supports multiple operating
    modes, each with slightly different considerations and implementation details.
    The modes are not interchangeable; the mode used for decryption must be identical
    to that used for encryption.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们将对对称密钥加密的讨论限制为一个实际的例子。假设你已经突破了一个组织的防线，进行了必要的权限提升、横向移动和网络侦察，成功访问了一个电子商务
    Web 服务器和后台数据库。数据库中包含财务交易数据；然而，这些交易中使用的信用卡号显然是加密过的。你检查了 Web 服务器上的应用程序源代码，并确定该组织正在使用高级加密标准（AES）算法。AES
    支持多种操作模式，每种模式都有稍微不同的考虑和实现细节。这些模式不可互换；解密时使用的模式必须与加密时使用的模式完全相同。
- en: In this scenario, let’s say you’ve determined that the application is using
    AES in Cipher Block Chaining (CBC) mode. So, let’s write a function that decrypts
    these credit cards ([Listing 11-4](ch11.xhtml#ch11list4)). Assume that the symmetric
    key was hardcoded in the application or set statically in a configuration file.
    As you go through this example, keep in mind that you’ll need to tweak this implementation
    for other algorithms or ciphers, but it’s a good starting place.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，假设你已经确定应用程序正在使用 AES 的密码块链接（CBC）模式。那么，接下来我们来编写一个函数，解密这些信用卡信息（[示例 11-4](ch11.xhtml#ch11list4)）。假设对称密钥已在应用程序中硬编码或在配置文件中静态设置。在处理这个示例时，请记住，你可能需要为其他算法或密码稍作调整，但这是一个很好的起点。
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 11-4: AES padding and decryption (*[/ch-11/aes/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-11/aes/main.go)*)*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11-4：AES 填充和解密 (*[/ch-11/aes/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-11/aes/main.go)*)*'
- en: 'The code defines two functions: `unpad()` and `decrypt()`. The `unpad()` function
    ❶ is a utility function scraped together to handle the removal of padding data
    after decryption. This is a necessary step, but beyond the scope of this discussion.
    Do some research on Public Key Cryptography Standards (PKCS) #7 padding for more
    information. It’s a relevant topic for AES, as it’s used to ensure that our data
    has proper block alignment. For this example, just know that you’ll need the function
    later to clean up your data. The function itself assumes some facts that you’d
    want to explicitly validate in a real-world scenario. Specifically, you’d want
    to confirm that the value of the padding bytes is valid, that the slice offsets
    are valid, and that the result is of appropriate length.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码定义了两个函数：`unpad()` 和 `decrypt()`。`unpad()` 函数 ❶ 是一个实用函数，用来处理解密后移除填充数据的工作。这是一个必要的步骤，但超出了本讨论的范围。你可以研究一下公共密钥加密标准（PKCS）#7
    填充，以获取更多信息。这是与 AES 相关的主题，因为它用于确保我们的数据具有正确的块对齐。对于这个示例，你只需要知道稍后你会用到这个函数来清理数据。该函数本身假设了一些事实，实际上你应该在真实场景中显式验证这些假设。具体来说，你应该确认填充字节的值是有效的，切片偏移量是有效的，以及结果的长度是合适的。
- en: 'The most interesting logic exists within the `decrypt()` function ❷, which
    takes two byte slices: the ciphertext you need to decrypt and the symmetric key
    you’ll use to do it. The function performs some validation to confirm that the
    ciphertext is at least as long as your block size ❸. This is a necessary step,
    because CBC mode encryption uses an initialization vector (IV) for randomness.
    This IV, like a salt value for password hashing, doesn’t need to remain secret.
    The IV, which is the same length as a single AES block, is prepended onto your
    ciphertext during encryption. If the ciphertext length is less than the expected
    block size, you know that you either have an issue with the cipher text or are
    missing the IV. You also check whether the ciphertext length is a multiple of
    the AES block size ❹. If it’s not, decryption will fail spectacularly, because
    CBC mode expects the ciphertext length to be a multiple of the block size.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的逻辑存在于`decrypt()`函数❷中，该函数接受两个字节切片：需要解密的密文和你将用来解密的对称密钥。该函数执行一些验证，确认密文至少与块大小相同❸。这是必要的步骤，因为CBC模式加密使用初始化向量（IV）来增加随机性。这个IV，像密码哈希中的盐值一样，并不需要保持机密。IV的长度与单个AES块相同，在加密时它会被加到密文前面。如果密文的长度小于预期的块大小，你就知道要么密文存在问题，要么IV丢失。你还会检查密文长度是否是AES块大小的倍数❹。如果不是，解密将会失败，因为CBC模式期望密文长度是块大小的倍数。
- en: Once you’ve completed your validation checks, you can proceed to decrypt the
    ciphertext. As mentioned previously, the IV is prepended to the ciphertext, so
    the first thing you do is extract the IV from the ciphertext ❺. You use the `aes.BlockSize`
    constant to retrieve the IV and then redefine your `ciphertext` variable to the
    remainder of your ciphertext via `ciphertext` `= [aes.BlockSize:]`. You now have
    your encrypted data separate from your IV.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成了验证检查，你就可以继续解密密文。正如之前提到的，IV是加到密文前面的，因此你做的第一件事是从密文中提取IV❺。你使用`aes.BlockSize`常量来获取IV，然后通过`ciphertext
    = [aes.BlockSize:]`重新定义`ciphertext`变量，得到密文的剩余部分。现在你已将加密数据与IV分离开来。
- en: 'Next, you call `aes.NewCipher()`, passing it your symmetric-key value ❻. This
    initializes your AES block mode cipher, assigning it to a variable named `block`.
    You then instruct your AES cipher to operate in CBC mode by calling `cipher.NewCBCDecryptor(block,
    iv)` ❼. You assign the result to a variable named `mode`. (The `crypto/cipher`
    package contains additional initialization functions for other AES modes, but
    you’re using only CBC decryption here.) You then issue a call to `mode.CryptBlocks(plaintext,
    ciphertext)` to decrypt the contents of `ciphertext` ❽ and store the result in
    the `plaintext` byte slice. Lastly, you ❾ remove your PKCS #7 padding by calling
    your `unpad()` utility function. You return the result. If all went well, this
    should be the plaintext value of the credit card number.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，你调用`aes.NewCipher()`，并传入对称密钥值❻。这会初始化AES块模式加密器，并将其赋值给名为`block`的变量。然后，你通过调用`cipher.NewCBCDecryptor(block,
    iv)`❼来指示你的AES加密器以CBC模式工作。你将结果赋值给名为`mode`的变量。（`crypto/cipher`包包含了其他AES模式的初始化函数，但这里你只使用CBC解密。）接着，你调用`mode.CryptBlocks(plaintext,
    ciphertext)`来解密`ciphertext`❽的内容，并将结果存储在`plaintext`字节切片中。最后，你❾通过调用`unpad()`工具函数来移除PKCS
    #7填充。你返回结果。如果一切顺利，这应该是信用卡号的明文值。'
- en: 'A sample run of the program produces the expected result:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的示例运行会产生预期的结果：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that you didn’t define a `main()` function in this sample code. Why not?
    Well, decrypting data in unfamiliar environments has a variety of potential nuances
    and variations. Are the ciphertext and key values encoded or raw binary? If they’re
    encoded, are they a hex string or Base64? Is the data locally accessible, or do
    you need to extract it from a data source or interact with a hardware security
    module, for example? The point is, decryption is rarely a copy-and-paste endeavor
    and often requires some level of understanding of algorithms, modes, database
    interaction, and data encoding. For this reason, we’ve chosen to lead you to the
    answer with the expectation that you’ll inevitably have to figure it out when
    the time is right.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这段示例代码中，你并没有定义`main()`函数。为什么呢？因为在不熟悉的环境中解密数据存在许多潜在的细微差别和变数。密文和密钥值是编码过的还是原始二进制？如果它们是编码的，它们是十六进制字符串还是Base64？数据是本地可访问的，还是需要从数据源中提取，或与硬件安全模块进行交互？重点是，解密通常不是一个简单的复制粘贴的过程，往往需要一定的算法、模式、数据库交互和数据编码的理解。因此，我们选择引导你找到答案，预期你最终会在合适的时候自己解决问题。
- en: Knowing just a little bit about symmetric-key encryption can make your penetrations
    tests much more successful. For example, in our experience pilfering client source-code
    repositories, we’ve found that people often use the AES encryption algorithm,
    either in CBC or Electronic Codebook (ECB) mode. ECB mode has some inherent weaknesses
    and CBC isn’t any better, if implemented incorrectly. Crypto can be hard to understand,
    so often developers assume that all crypto ciphers and modes are equally effective
    and are ignorant of their subtleties. Although we don’t consider ourselves cryptographers,
    we know just enough to implement crypto securely in Go—and to exploit other people’s
    deficient implementations.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 了解一些对称密钥加密的基本知识可以让你的渗透测试更加成功。例如，根据我们的经验，在盗取客户源代码仓库时，我们发现人们经常使用AES加密算法，无论是CBC模式还是电子密码本（ECB）模式。ECB模式存在一些固有的弱点，而如果实现不当，CBC模式也不会更好。加密技术可能难以理解，因此开发人员常常假设所有的加密算法和模式都是同样有效的，忽视了它们的细微差别。尽管我们不认为自己是加密专家，但我们知道足够的知识，可以在Go语言中安全地实现加密，并利用他人不完善的实现。
- en: Although symmetric-key encryption is faster than asymmetric cryptography, it
    suffers from inherent key-management challenges. After all, to use it, you must
    distribute the same key to any and all systems or applications that perform the
    encryption or decryption functions on the data. You must distribute the key securely,
    often following strict processes and auditing requirements. Also, relying solely
    on symmetric-key cryptography prevents arbitrary clients from, for example, establishing
    encrypted communications with other nodes. There isn’t a good way to negotiate
    the secret key, nor are there authentication or integrity assurances for many
    common algorithms and modes.[¹](footnote.xhtml#ch11fn1) That means anyone, whether
    authorized or malicious, who obtains the secret key can proceed to use it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对称密钥加密比非对称加密更快，但它存在固有的密钥管理挑战。毕竟，要使用它，你必须将相同的密钥分发给任何执行加密或解密操作的系统或应用程序。你必须安全地分发密钥，通常需要遵循严格的流程和审计要求。而且，单纯依赖对称密钥加密会阻止任意客户端，例如，建立与其他节点的加密通信。没有好的方法来协商秘密密钥，也没有很多常见算法和模式的身份验证或完整性保证。[¹](footnote.xhtml#ch11fn1)
    这意味着，任何人，无论是授权者还是恶意者，只要获得了秘密密钥，就可以使用它。
- en: This is where asymmetric cryptography can be of use.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是非对称加密可能派上用场的地方。
- en: Asymmetric Cryptography
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 非对称加密
- en: Many of the problems associated with symmetric-key encryption are solved by
    *asymmetric* (or *public-key*) *cryptography*, which uses two separate but mathematically
    related keys. One is available to the public and the other is kept private. Data
    encrypted by the private key can be decrypted only by the public key, and data
    encrypted by the public key can be decrypted only by the private key. If the private
    key is protected properly and kept, well, private, then data encrypted with the
    public key remains confidential, since you need the closely guarded private key
    to decrypt it. Not only that, but you could use the private key to authenticate
    a user. The user could use the private key to sign messages, for example, which
    the public could decrypt using the public key.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与对称密钥加密相关的许多问题都可以通过*非对称*（或*公钥*）*密码学*来解决，它使用两个独立但数学相关的密钥。一个是公开的，另一个是私密的。用私钥加密的数据只能用公钥解密，用公钥加密的数据只能用私钥解密。如果私钥得到了适当保护并保持私密，那么用公钥加密的数据依然是保密的，因为你需要严格保护的私钥才能解密它。不仅如此，你还可以用私钥来验证用户身份。比如，用户可以用私钥来签名消息，公众则可以使用公钥来解密这些消息。
- en: 'So, you might be asking, “What’s the catch? If public-key cryptography provides
    all these assurances, why do we even have symmetric-key cryptography?” Good question,
    you! The problem with public-key encryption is its speed; it’s a lot slower than
    its symmetric counterpart. To get the best of both worlds (and avoid the worst),
    you’ll often find organizations using a hybrid approach: they’ll use asymmetric
    crypto for the initial communications negotiation, establishing an encrypted channel
    through which they create and exchange a symmetric key (often called a *session
    key*). Because the session key is fairly small, using public-key crypto for this
    process requires little overhead. Both the client and server then have a copy
    of the session key, which they use to make future communications faster.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你可能会问：“有什么问题？如果公钥密码学提供了所有这些保证，为什么我们还需要对称密钥密码学？”好问题！公钥加密的问题在于它的速度；它比对称加密慢得多。为了兼顾两者的优点（并避免最坏的情况），你会发现很多组织采用混合方法：他们会使用非对称加密进行初始的通信协商，建立一个加密通道，通过这个通道他们创建并交换一个对称密钥（通常称为*会话密钥*）。由于会话密钥相对较小，使用公钥加密这一过程所需的开销很小。客户端和服务器随后都拥有会话密钥的副本，用它们来加快后续的通信。
- en: Let’s look at a couple of common use cases for public-key crypto. Specifically,
    we’ll look at encryption, signature validation, and mutual authentication.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看几个公钥加密的常见使用案例。具体来说，我们将讨论加密、签名验证和相互认证。
- en: Encryption and Signature Validation
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 加密和签名验证
- en: For this first example, you’ll use public-key crypto to encrypt and decrypt
    a message. You’ll also create the logic to sign a message and validate that signature.
    For simplicity, you’ll include all of this logic in a single `main()` function.
    This is meant to show you the core functionality and logic so that you can implement
    it. In a real-world scenario, the process is a little more complex, since you’re
    likely to have two remote nodes communicating with each other. These nodes would
    have to exchange public keys. Fortunately, this exchange process doesn’t require
    the same security assurances as exchanging symmetric keys. Recall that any data
    encrypted with the public key can be decrypted only by the related private key.
    So, even if you perform a man-in-the-middle attack to intercept the public-key
    exchange and future communications, you won’t be able to decrypt any of the data
    encrypted by the same public key. Only the private key can decrypt it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个示例中，你将使用公钥加密来加密和解密一条消息。你还将创建逻辑来签名消息并验证该签名。为了简化，你将把所有这些逻辑包含在一个单一的`main()`函数中。这样做是为了向你展示核心功能和逻辑，以便你能够实现它。在实际场景中，这个过程会稍微复杂一些，因为你可能需要有两个远程节点互相通信。这些节点必须交换公钥。幸运的是，这个交换过程不需要和交换对称密钥一样的安全保证。回想一下，任何用公钥加密的数据只能通过相关的私钥解密。所以，即使你执行中间人攻击来拦截公钥交换和未来的通信，你也无法解密任何用相同公钥加密的数据。只有私钥才能解密它。
- en: Let’s take a look at the implementation shown in [Listing 11-5](ch11.xhtml#ch11list5).
    We’ll elaborate on the logic and cryptographic functionality as we review the
    example.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下在[清单11-5](ch11.xhtml#ch11list5)中展示的实现。我们将在回顾示例时详细阐述逻辑和加密功能。
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 11-5: Asymmetric, or public-key, encryption (*[/ch-11/public-key/main.go/](https://github.com/blackhat-go/bhg/blob/master/ch-11/public-key/main.go)*)*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单11-5：非对称加密或公钥加密 (*[/ch-11/public-key/main.go/](https://github.com/blackhat-go/bhg/blob/master/ch-11/public-key/main.go)*)*'
- en: 'The program demonstrates two separate but related public-key crypto functions:
    encryption/decryption and message signing. You first generate a public/private
    key pair by calling the `rsa.GenerateKey()` function ❶. You supply a random reader
    and a key length as input parameters to the function. Assuming the random reader
    and key lengths are adequate to generate a key, the result is an `*rsa.PrivateKey`
    instance that contains a field whose value is the public key. You now have a working
    key pair. You assign the public key to its own variable for the sake of convenience
    ❷.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序演示了两个独立但相关的公钥加密功能：加密/解密和消息签名。你首先通过调用`rsa.GenerateKey()`函数 ❶生成公私钥对。你为该函数提供一个随机读取器和一个密钥长度作为输入参数。假设随机读取器和密钥长度足以生成密钥，结果将是一个`*rsa.PrivateKey`实例，该实例包含一个字段，其值为公钥。现在你有了一个有效的密钥对。为了方便起见，你将公钥分配给自己的变量
    ❷。
- en: This program generates this key pair every time it’s run. In most circumstances,
    such as SSH communications, you’ll generate the key pair a single time, and then
    save and store the keys to disk. The private key will be kept secure, and the
    public key will be distributed to endpoints. We’re skipping key distribution,
    protection, and management here, and focusing only on the cryptographic functions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序每次运行时都会生成这个密钥对。在大多数情况下，比如SSH通信，你只需生成一次密钥对，然后将密钥保存到磁盘上。私钥将被保密存储，而公钥将分发到各个端点。我们在这里跳过了密钥分发、保护和管理，专注于加密功能。
- en: Now that you’ve created the keys, you can start using them for encryption. You
    do so by calling the function `rsa.EncryptOAEP()` ❸, which accepts a hashing function,
    a reader to use for padding and randomness, your public key, the message you wish
    to encrypt, and an optional label. This function returns an error (if the inputs
    cause the algorithm to fail) and our ciphertext. You can then pass the same hashing
    function, a reader, your private key, your ciphertext, and a label into the function
    `rsa.DecryptOAEP()` ❹. The function decrypts the ciphertext by using your private
    key and returns the cleartext result.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了密钥，可以开始使用它们进行加密。你通过调用`rsa.EncryptOAEP()` ❸来实现加密，该函数接受一个哈希函数、用于填充和随机化的读取器、公钥、你希望加密的消息以及一个可选的标签。该函数返回一个错误（如果输入导致算法失败）和加密后的密文。然后，你可以将相同的哈希函数、读取器、私钥、密文和标签传递给`rsa.DecryptOAEP()`
    ❹函数。该函数使用你的私钥解密密文，并返回明文结果。
- en: Notice that you’re encrypting the message with the public key. This ensures
    that only the holder of the private key will have the ability to decrypt the data.
    Next you create a digital signature by calling `rsa.SignPSS()` ❺. You pass to
    it, again, a random reader, your private key, the hashing function you’re using,
    the hash value of the message, and a `nil` value representing additional options.
    The function returns any errors and the resulting signature value. Much like human
    DNA or fingerprints, this signature uniquely identifies the identity of the signer
    (that is, the private key). Anybody holding the public key can validate the signature
    to not only determine the authenticity of the signature but also validate the
    integrity of the message. To validate the signature, you pass the public key,
    hash function, hash value, signature, and additional options to `rsa.VerifyPSS()`
    ❻. Notice that in this case you’re passing the public key, not the private key,
    into this function. Endpoints wishing to validate the signature won’t have access
    to the private key, nor will validation succeed if you input the wrong key value.
    The `rsa.VerifyPSS()` function returns `nil` when the signature is valid and an
    error when it’s invalid.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你正在使用公钥加密消息。这确保了只有持有私钥的人才能解密数据。接下来，你通过调用`rsa.SignPSS()` ❺来创建数字签名。你再次传递一个随机读取器、私钥、你使用的哈希函数、消息的哈希值，以及一个表示附加选项的`nil`值。该函数返回任何错误以及生成的签名值。就像人类的DNA或指纹一样，这个签名唯一地标识了签名者的身份（即私钥）。任何持有公钥的人都可以验证签名，不仅可以确定签名的真实性，还可以验证消息的完整性。要验证签名，你将公钥、哈希函数、哈希值、签名和附加选项传递给`rsa.VerifyPSS()`
    ❻。请注意，在这种情况下，你传递的是公钥，而不是私钥。希望验证签名的端点无法访问私钥，如果输入错误的密钥值，验证也将失败。`rsa.VerifyPSS()`函数在签名有效时返回`nil`，在签名无效时返回错误。
- en: 'Here is a sample run of the program. It behaves as expected, encrypting the
    message by using a public key, decrypting it by using a private key, and validating
    the signature:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是程序的一个示例运行。它按预期行为操作，使用公钥加密消息，使用私钥解密，并验证签名：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next up, let’s look at another application of public-key cryptography: mutual
    authentication.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看公钥加密的另一种应用：互相认证。
- en: Mutual Authentication
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 互相认证
- en: '*Mutual authentication* is the process by which a client and server authenticate
    each other. They do this with public-key cryptography; both the client and server
    generate public/private key pairs, exchange public keys, and use the public keys
    to validate the authenticity and identity of the other endpoint. To accomplish
    this feat, both the client and server must do some legwork to set up the authorization,
    explicitly defining the public key value with which they intend to validate the
    other. The downside to this process is the administrative overhead of having to
    create unique key pairs for every single node and ensuring that the server and
    the client nodes have the appropriate data to proceed properly.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*互相认证*是客户端和服务器互相认证的过程。它们使用公钥加密技术；客户端和服务器都生成公/私钥对，交换公钥，并使用公钥来验证对方的真实性和身份。为了实现这一过程，客户端和服务器都必须做一些准备工作，设置授权，并明确指定用于验证对方的公钥值。这个过程的缺点是需要为每个节点创建唯一的密钥对，并确保服务器和客户端节点拥有正确的数据，才能顺利进行。'
- en: 'To begin, you’ll knock out the administrative tasks of creating key pairs.
    You’ll store the public keys as self-signed, PEM-encoded certificates. Let’s use
    the `openssl` utility to create these files. On your server, you’ll create the
    server’s private key and certificate by entering the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将处理创建密钥对的管理任务。您将以自签名的 PEM 编码证书形式存储公钥。我们使用 `openssl` 工具来创建这些文件。在您的服务器上，您将通过输入以下命令来创建服务器的私钥和证书：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `openssl` command will prompt you for various inputs, to which you can
    supply arbitrary values for this example. The command creates two files: *serverKey.pem*
    and *serverCrt.pem*. The file *serverKey.pem* contains your private key, and you
    should protect it. The *serverCrt.pem* file contains the server’s public key,
    which you’ll distribute to each of your connecting clients.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`openssl` 命令将提示您输入各种信息，您可以为本示例提供任意值。该命令会创建两个文件：*serverKey.pem* 和 *serverCrt.pem*。文件
    *serverKey.pem* 包含您的私钥，您应当保护它。*serverCrt.pem* 文件包含服务器的公钥，您将把它分发给每个连接的客户端。'
- en: 'For every connecting client, you’ll run a command similar to the preceding
    one:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个连接的客户端，您将运行类似于前面命令的操作：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This command also generates two files: *clientKey.pem* and *clientCrt.pem*.
    Much as with the server output, you should protect the client’s private key. The
    *clientCrt.pem* certificate file will be transferred to your server and loaded
    by your program. This will allow you to configure and identify the client as an
    authorized endpoint. You’ll have to create, transfer, and configure a certificate
    for each additional client so that the server can identify and explicitly authorize
    them.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令还会生成两个文件：*clientKey.pem* 和 *clientCrt.pem*。与服务器输出类似，您应当保护客户端的私钥。*clientCrt.pem*
    证书文件将被传输到您的服务器，并由您的程序加载。这将允许您配置并将客户端标识为授权的端点。对于每个额外的客户端，您必须创建、传输并配置证书，以便服务器能够识别并明确授权它们。
- en: In [Listing 11-6](ch11.xhtml#ch11list6), you set up an HTTPS server that requires
    a client to provide a legitimate, authorized certificate.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 11-6](ch11.xhtml#ch11list6) 中，您设置了一个 HTTPS 服务器，要求客户端提供合法的授权证书。
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 11-6: Setting up a mutual authentication server (*[/ch-11/mutual-auth/cmd/server/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-11/mutual-auth/cmd/server/main.go)*)*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11-6：设置互相认证服务器 (*[/ch-11/mutual-auth/cmd/server/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-11/mutual-auth/cmd/server/main.go)*)*'
- en: Outside the `main()` function, the program defines a `helloHandler()` function
    ❶. As we discussed way back in [Chapters 3](ch03.xhtml#ch3) and [4](ch04.xhtml#ch4),
    the handler function accepts an `http.ResponseWriter` instance and the `http.Request`
    itself. This handler is pretty boring. It logs the common name of the client certificate
    received ❷. The common name is accessed by inspecting the `http.Request`’s `TLS`
    field and drilling down into the certificate `PeerCertificates` data. The handler
    function also sends the client a message indicating that authentication was successful.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数外，程序定义了一个`helloHandler()`函数❶。正如我们在[第3章](ch03.xhtml#ch3)和[第4章](ch04.xhtml#ch4)中讨论过的那样，处理程序函数接受一个`http.ResponseWriter`实例和`http.Request`本身。这个处理程序相当简单，它记录了接收到的客户端证书的常用名称❷。常用名称是通过检查`http.Request`的`TLS`字段，并深入到证书的`PeerCertificates`数据中来获取的。该处理程序还会向客户端发送一条消息，指示身份验证已成功。
- en: But how do you define which clients are authorized, and how do you authenticate
    them? The process is fairly painless. You first read the client’s certificate
    from the PEM file the client created previously ❸. Because it’s possible to have
    more than one authorized client certificate, you create a certificate pool and
    call `pool.AppendCertsFromPEM(clientCert)` to add the client certificate to your
    pool ❹. You perform this step for each additional client you wish to authenticate.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你如何定义哪些客户端是授权的，如何对它们进行身份验证呢？这个过程相当简单。你首先从客户端之前创建的PEM文件中读取客户端证书❸。因为可能有多个授权的客户端证书，所以你需要创建一个证书池，并调用`pool.AppendCertsFromPEM(clientCert)`将客户端证书添加到你的池中❹。你需要对每个额外的客户端执行此步骤，以便对它们进行身份验证。
- en: Next, you create your TLS configuration. You explicitly set the `ClientCAs`
    field to your `pool` and configure `ClientAuth` to `tls.RequireAndVerifyClientCert`
    ❺. This configuration defines your pool of authorized clients and requires clients
    to properly identify themselves before they’ll be allowed to proceed. You issue
    a call to `tlsConf.BuildNameToCertificate()` so that the client’s common and subject
    alternate names—the domain names for which the certificate was generated—will
    properly map to their given certificate ❻. You define your HTTP server, explicitly
    setting your custom configuration ❼, and start the server by calling `server.ListenAndServeTLS()`,
    passing to it the server certificate and private-key files you created previously
    ❽. Note that you don’t use the client’s private-key file anywhere in the server
    code. As we’ve said before, the private key remains private; your server will
    be able to identify and authorize clients by using only the client’s public key.
    This is the brilliance of public-key crypto.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要创建你的TLS配置。你显式地将`ClientCAs`字段设置为你的`pool`，并将`ClientAuth`配置为`tls.RequireAndVerifyClientCert`❺。这个配置定义了你授权客户端的池，并要求客户端在允许继续之前正确地进行身份验证。你调用`tlsConf.BuildNameToCertificate()`，确保客户端的常用名称和主题备用名称——证书生成的域名——能够正确映射到它们指定的证书❻。你定义了你的HTTP服务器，显式地设置了自定义配置❼，并通过调用`server.ListenAndServeTLS()`启动服务器，传入你之前创建的服务器证书和私钥文件❽。请注意，你在服务器代码中不会使用客户端的私钥文件。正如我们之前所说，私钥保持私密；你的服务器只会使用客户端的公钥来识别和授权客户端。这就是公钥加密的精妙之处。
- en: 'You can validate your server by using `curl`. If you generate and supply a
    bogus, unauthorized client certificate and key, you’ll be greeted with a verbose
    message telling you so:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`curl`验证你的服务器。如果你生成并提供一个虚假的、未经授权的客户端证书和密钥，你会收到一条详细的消息，告诉你这一点：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You’ll also get a more verbose message on the server, something like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会在服务器上收到一条更为详细的消息，内容可能如下：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On the flip side, if you supply the valid certificate and the key that matches
    the certificate configured in the server pool, you’ll enjoy a small moment of
    glory as it successfully authenticates:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，如果你提供了有效的证书和与服务器池中配置的证书匹配的密钥，你将享受成功身份验证时那短暂的荣耀时刻：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This message tells you the server works as expected.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息告诉你服务器工作正常。
- en: Now, let’s have a look at a client ([Listing 11-7](ch11.xhtml#ch11list7)). You
    can run the client on either the same system as the server or a different one.
    If it’s on a different system, you’ll need to transfer *clientCrt.pem* to the
    server and *serverCrt.pem* to the client.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下一个客户端（[示例 11-7](ch11.xhtml#ch11list7)）。你可以在与服务器相同的系统上运行客户端，也可以在不同的系统上运行。如果是在不同的系统上，你需要将*clientCrt.pem*传输到服务器，并将*serverCrt.pem*传输到客户端。
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 11-7: The mutual authentication client (*[/ch-11/mutual-auth/cmd/client/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-11/mutual-auth/cmd/client/main.go)*)*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-7：相互认证客户端（*[/ch-11/mutual-auth/cmd/client/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-11/mutual-auth/cmd/client/main.go)）*'
- en: 'A lot of the certificate preparation and configuration will look similar to
    what you did in the server code: creating a pool of certificates and preparing
    subject and common names. Since you won’t be using the client certificate and
    key as a server, you instead call `tls.``LoadX509KeyPair("clientCrt.pem",` `"clientKey.pem")`
    to load them for use later ❶. You also read the server certificate, adding it
    to the pool of certificates you wish to allow ❷. You then use the pool and client
    certificates ❸ to build your TLS configuration ❹, and call `tlsConf.BuildNameToCertificate()`
    to bind domain names to their respective certificates ❺.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 证书的准备和配置与你在服务器代码中所做的类似：创建证书池并准备主题和通用名称。由于你不会将客户端证书和密钥用作服务器，因此你需要调用 `tls.``LoadX509KeyPair("clientCrt.pem",`
    `"clientKey.pem")` 来加载它们，以供后续使用 ❶。你还需要读取服务器证书，并将其添加到你希望允许的证书池中 ❷。然后，你使用该证书池和客户端证书
    ❸ 来构建 TLS 配置 ❹，并调用 `tlsConf.BuildNameToCertificate()` 来将域名与其各自的证书绑定 ❺。
- en: Since you’re creating an HTTP client, you have to define a transport ❻, correlating
    it with your TLS configuration. You can then use the transport instance to create
    an `http.Client` struct ❼. As we discussed in [Chapters 3](ch03.xhtml#ch3) and
    [4](ch04.xhtml#ch4), you can use this client to issue an HTTP GET request via
    `client.Get("https://server.blackhat-go.local:9443/hello")` ❽.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你正在创建一个 HTTP 客户端，你必须定义一个传输层 ❻，并将其与 TLS 配置关联。然后，你可以使用该传输实例来创建一个 `http.Client`
    结构体 ❼。正如我们在[第 3 章](ch03.xhtml#ch3)和[第 4 章](ch04.xhtml#ch4)中讨论的那样，你可以使用这个客户端通过
    `client.Get("https://server.blackhat-go.local:9443/hello")` ❽ 发起一个 HTTP GET 请求。
- en: 'All the magic happens behind the scenes at this point. Mutual authentication
    is performed—the client and the server mutually authenticate each other. If authentication
    fails, the program returns an error and exits. Otherwise, you read the HTTP response
    body and display it to stdout ❾. Running your client code produces the expected
    result, specifically, that there were no errors thrown and that authentication
    succeeds:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点时，所有的“魔法”都发生在幕后。进行的是相互认证——客户端和服务器相互认证。如果认证失败，程序将返回一个错误并退出。否则，你将读取 HTTP 响应体并将其显示到标准输出
    ❾。运行你的客户端代码会产生预期的结果，具体来说，就是没有抛出错误且认证成功：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Your server output is shown next. Recall that you configured the server to
    log a hello message to standard output. This message contains the common name
    of the connecting client, extracted from the certificate:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是你的服务器输出。请记住，你已经配置服务器将问候消息记录到标准输出中。该消息包含连接客户端的通用名称，从证书中提取：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You now have a functional sample of mutual authentication. To further enhance
    your understanding, we encourage you to tweak the previous examples so they work
    over TCP sockets.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经有了一个功能齐全的相互认证示例。为了进一步增强你的理解，我们鼓励你调整之前的示例，使其可以在 TCP 套接字上运行。
- en: 'In the next section, you’ll dedicate your efforts to a more devious purpose:
    brute-forcing RC2 encryption cipher symmetric keys.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将把精力集中在一个更阴险的目的上：暴力破解 RC2 加密算法的对称密钥。
- en: Brute-Forcing RC2
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 暴力破解 RC2
- en: '*RC2* is a symmetric-key block cipher created by Ron Rivest in 1987\. Prompted
    by recommendations from the government, the designers used a 40-bit encryption
    key, which made the cipher weak enough that the US government could brute-force
    the key and decrypt communications. It provided ample confidentiality for most
    communications but allowed the government to peep into chatter with foreign entities,
    for example. Of course, back in the 1980s, brute-forcing the key required significant
    computing power, and only well-funded nation states or specialty organizations
    had the means to decrypt it in a reasonable amount of time. Fast-forward 30 years;
    today, the common home computer can brute-force a 40-bit key in a few days or
    weeks.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*RC2* 是由 Ron Rivest 在 1987 年创建的对称密钥分组密码。受到政府推荐的启发，设计者使用了 40 位加密密钥，这使得该密码足够弱，以至于美国政府可以暴力破解密钥并解密通信。它为大多数通信提供了足够的保密性，但也让政府能够窥探与外国实体的谈话。例如，在
    1980 年代，暴力破解密钥需要大量计算能力，只有资金雄厚的国家或专业机构才能在合理的时间内解密。然而，时至今日，普通家用电脑可以在几天或几周内暴力破解 40
    位密钥。'
- en: So, what the heck, let’s brute force a 40-bit key.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，怎么说呢，咱们来暴力破解一个 40 位密钥吧。
- en: Getting Started
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 开始使用
- en: Before we dive into the code, let’s set the stage. First of all, neither the
    standard nor extended Go crypto libraries have an RC2 package intended for public
    consumption. However, there’s an internal Go package for it. You can’t import
    internal packages directly in external programs, so you’ll have to find another
    way to use it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，先设定一下背景。首先，标准的和扩展的Go加密库都没有供公众使用的RC2包。然而，它有一个内部的Go包。你不能直接在外部程序中导入内部包，因此你必须找到另一种方法来使用它。
- en: 'Second, to keep things simple, you’ll make some assumptions about the data
    that you normally wouldn’t want to make. Specifically, you’ll assume that the
    length of your cleartext data is a multiple of the RC2 block size (8 bytes) to
    avoid clouding your logic with administrative tasks like handling PKCS #5 padding.
    Handling the padding is similar to what you did with AES previously in this chapter
    (see [Listing 11-4](ch11.xhtml#ch11list4)), but you’d need to be more diligent
    in validating the contents to maintain the integrity of the data you’ll be working
    with. You’ll also assume that your ciphertext is an encrypted credit card number.
    You’ll check the potential keys by validating the resulting plaintext data. In
    this case, validating the data involves making sure the text is numeric and then
    subjecting it to a *Luhn check*, which is a method of validating credit card numbers
    and other sensitive data.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '其次，为了简化操作，你将做一些通常不愿意做的假设。具体来说，你将假设明文数据的长度是RC2块大小（8字节）的倍数，以避免用像处理PKCS #5填充这样的管理任务来干扰你的逻辑。处理填充的方式类似于你在本章之前使用AES时做的（见[列表11-4](ch11.xhtml#ch11list4)），但你需要更加小心地验证内容，以确保你将要处理的数据的完整性。你还将假设你的密文是一个加密的信用卡号码。你将通过验证得到的明文数据来检查潜在的密钥。在这种情况下，验证数据包括确保文本是数字，然后进行*Luhn校验*，这是一种验证信用卡号码和其他敏感数据的方法。'
- en: Next, you’ll assume you were able to determine—perhaps from pilfering filesystem
    data or source code—that the data is encrypted using a 40-bit key in ECB mode
    with no initialization vector. RC2 supports variable-length keys and, since it’s
    a block cipher, can operate in different modes. In ECB mode, which is the simplest
    mode, blocks of data are encrypted independently of other blocks. This will make
    your logic a little more straightforward. Lastly, although you can crack the key
    in a nonconcurrent implementation, if you so choose, a concurrent implementation
    will be far better performing. Rather than building this thing iteratively, showing
    first a nonconcurrent version followed by a concurrent one, we’ll go straight
    for the concurrent build.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将假设你能够通过窃取文件系统数据或源代码来确定——数据使用40位密钥在ECB模式下加密，并且没有初始化向量。RC2支持可变长度的密钥，并且作为一个分组密码，它可以在不同模式下工作。在ECB模式下，这是最简单的模式，数据块独立于其他数据块进行加密。这将使你的逻辑变得更加直观。最后，虽然你可以在非并发实现中破解密钥，但如果你选择并发实现，它将具有更好的性能。与其逐步构建，先展示一个非并发版本再展示一个并发版本，我们直接从并发构建开始。
- en: Now you’ll install a couple of prerequisites. First, retrieve the official RC2
    Go implementation from [*https://github.com/golang/crypto/blob/master/pkcs12/internal/rc2/rc2.go*](https://github.com/golang/crypto/blob/master/pkcs12/internal/rc2/rc2.go).
    You’ll need to install this in your local workspace so that you can import it
    into your brute-forcer. As we mentioned earlier, the package is an internal package,
    meaning that, by default, outside packages can’t import and use it. This is a
    little hacky, but it’ll prevent you from having to use a third-party implementation
    or—shudder—writing your own RC2 cipher code. If you copy it into your workspace,
    the non-exported functions and types become part of your development package,
    which makes them accessible.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将安装几个先决条件。首先，从[*https://github.com/golang/crypto/blob/master/pkcs12/internal/rc2/rc2.go*](https://github.com/golang/crypto/blob/master/pkcs12/internal/rc2/rc2.go)获取官方的RC2
    Go实现。你需要将其安装到本地工作空间中，以便你可以将其导入到你的暴力破解器中。如前所述，该包是一个内部包，意味着默认情况下，外部包无法导入和使用它。这有点黑客手段，但它可以防止你使用第三方实现，或者——哆嗦——自己编写RC2密码代码。如果你将其复制到工作空间中，未导出的函数和类型将成为你开发包的一部分，从而使它们可以访问。
- en: 'Let’s also install a package that you’ll use to perform the Luhn check:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还安装一个你将用来执行Luhn校验的包：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A Luhn check calculates checksums on credit card numbers or other identification
    data to determine whether they’re valid. You’ll use the existing package for this.
    It’s well-documented and it’ll save you from re-creating the wheel.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Luhn 检查计算信用卡号码或其他身份识别数据的校验和，以确定它们是否有效。你将使用现有的包来完成这一操作。它有着完善的文档，并且可以避免你重新发明轮子。
- en: Now you can write your code. You’ll need to iterate through every combination
    of the entire key space (40-bits), decrypting your ciphertext with each key, and
    then validating your result by making sure it both consists of only numeric characters
    and passes a Luhn check. You’ll use a producer/consumer model to manage the work—the
    producer will push a key to a channel and the consumers will read the key from
    the channel and execute accordingly. The work itself will be a single key value.
    When you find a key that produces properly validated plaintext (indicating you
    found a credit card number), you’ll signal each of the goroutines to stop their
    work.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以编写代码了。你需要遍历整个密钥空间的每一种组合（40 位），用每个密钥解密密文，然后通过确保解密结果仅包含数字字符并通过 Luhn 检查来验证结果。你将使用生产者/消费者模型来管理工作——生产者将密钥推送到一个通道，消费者从通道读取密钥并相应执行。工作本身将是一个单一的密钥值。当你找到一个能够生成经过验证的明文的密钥（表明你找到了一个信用卡号码）时，你将通知所有
    goroutine 停止工作。
- en: One of the interesting challenges of this problem is how to iterate the key
    space. In our solution, you iterate it using a `for` loop, traversing the key
    space represented as `uint64` values. The challenge, as you’ll see, is that `uint64`
    occupies 64 bits of space in memory. So, converting from a `uint64` to a 40-bit
    (5-byte) `[]byte` RC2 key requires that you crop off 24 bits (3 bytes) of unnecessary
    data. Hopefully, this process becomes clear once you’ve looked at the code. We’ll
    take it slow, breaking down sections of the program and working through them one
    by one. [Listing 11-8](ch11.xhtml#ch11list8) begins the program.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的一个有趣挑战是如何遍历密钥空间。在我们的解决方案中，你通过一个 `for` 循环来遍历表示为 `uint64` 值的密钥空间。挑战在于，正如你所看到的，`uint64`
    在内存中占用 64 位空间。因此，将一个 `uint64` 转换为一个 40 位（5 字节）`[]byte` 的 RC2 密钥时，必须剪切掉 24 位（3
    字节）的无用数据。希望在你看过代码后，这个过程会变得更加清晰。我们会慢慢来，逐步解析程序的各个部分，逐一进行分析。[Listing 11-8](ch11.xhtml#ch11list8)
    开始了这段程序。
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 11-8: Importing the RC2 brute-force type (*[/ch-11/rc2-brute/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-11/rc2-brute/main.go)*)*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-8: 导入 RC2 暴力破解类型 (*[/ch-11/rc2-brute/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-11/rc2-brute/main.go)*)*'
- en: We’ve included the `import` statements here to draw attention to the inclusion
    of the third-party `go-luhn` package ❶, as well as the inclusion of the `rc2`
    package ❷ you cloned from the internal Go repository. You also compile a regular
    expression ❸ that you’ll use to check whether the resulting plaintext block is
    8 bytes of numeric data.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里包含了 `import` 语句，以引起注意第三方 `go-luhn` 包 ❶ 的引入，以及你从内部 Go 仓库克隆的 `rc2` 包 ❷ 的引入。你还编译了一个正则表达式
    ❸，用来检查结果明文块是否为 8 字节的数字数据。
- en: Note that you’re checking 8 bytes of data and not 16 bytes, which is the length
    of your credit card number. You’re checking 8 bytes because that’s the length
    of an RC2 block. You’ll be decrypting your ciphertext block by block, so you can
    check the first block you decrypt to see whether it’s numeric. If the 8 bytes
    of the block aren’t all numeric, you can confidently assume that you aren’t dealing
    with a credit card number and can skip the decryption of the second block of ciphertext
    altogether. This minor performance improvement will significantly reduce the time
    it takes to execute millions of times over.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你检查的是 8 字节的数据，而不是 16 字节——后者是信用卡号码的长度。你检查 8 字节是因为它是 RC2 块的长度。你将逐块解密密文，因此可以先检查你解密的第一个块，看看它是否是数字。如果这个
    8 字节的块不是全数字，你可以自信地认为它不是信用卡号码，并跳过对第二块密文的解密。这个小小的性能改进将显著减少执行数百万次所需的时间。
- en: Lastly, you define a type named `CryptoData` ❹ that you’ll use to store your
    key and a `cipher.Block`. You’ll use this `struct` to define units of work, which
    producers will create and consumers will act upon.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你定义了一个名为 `CryptoData` ❹ 的类型，用来存储你的密钥和一个 `cipher.Block`。你将使用这个 `struct` 来定义工作单元，生产者会创建它，消费者会对其执行操作。
- en: Producing Work
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成工作
- en: Let’s look at the producer function ([Listing 11-9](ch11.xhtml#ch11list9)).
    You place this function after your type definitions in the previous code listing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一下生产者函数（[Listing 11-9](ch11.xhtml#ch11list9)）。你将此函数放在前面代码列表中的类型定义后面。
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 11-9: The RC2 producer function (*[/ch-11/rc2-brute/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-11/rc2-brute/main.go)*)*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-9: RC2 生产者函数 (*[/ch-11/rc2-brute/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-11/rc2-brute/main.go)*)*'
- en: Your producer function is named `generate()` ❶. It accepts two `uint64` variables
    used to define a segment of the key space on which the producer will create work
    (basically, the range over which they’ll produce keys). This allows you to break
    up the key space, distributing portions of it to each producer.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你的生产者函数命名为 `generate()` ❶。它接受两个 `uint64` 变量，用于定义生产者将创建工作的密钥空间段（基本上是它们将生成密钥的范围）。这允许你将密钥空间拆分，将其部分分配给每个生产者。
- en: 'The function also accepts two channels: a `*CryptData` write-only channel used
    for pushing work to consumers and a generic `struct` channel that’ll be used for
    receiving signals from consumers. This second channel is necessary so that, for
    example, a consumer that identifies the correct key can explicitly signal the
    producer to stop producing. No sense creating more work if you’ve already solved
    the problem. Lastly, your function accepts a `WaitGroup` to be used for tracking
    and synchronizing producer execution. For each concurrent producer that runs,
    you execute `wg.Add(1)` ❷ to tell the `WaitGroup` that you started a new producer.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数还接受两个通道：一个用于推送工作给消费者的 `*CryptData` 写通道和一个通用的 `struct` 通道，用于接收来自消费者的信号。这个第二个通道是必要的，例如，消费者识别出正确的密钥时，可以显式地通知生产者停止生产。如果问题已经解决，就没有必要再创造更多的工作了。最后，你的函数接受一个
    `WaitGroup`，用于跟踪和同步生产者的执行。对于每个并发运行的生产者，你执行 `wg.Add(1)` ❷ 来告诉 `WaitGroup` 你已经启动了一个新的生产者。
- en: You populate your work channel within a goroutine ❸, including a call to `defer
    wg.Done()` ❹ to notify your `WaitGroup` when the goroutine exits. This will prevent
    deadlocks later as you try to continue execution from your `main()` function.
    You use your `start()` and `stop()` values to iterate a subsection of the key
    space by using a `for` loop ❺. Every iteration of the loop increments the `i`
    variable until you’ve reached your ending offset.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你在一个 goroutine ❸ 中填充你的工作通道，包括调用 `defer wg.Done()` ❹ 来通知你的 `WaitGroup` 当 goroutine
    退出时。这将防止后续在尝试从 `main()` 函数继续执行时发生死锁。你使用 `start()` 和 `stop()` 值，通过 `for` 循环 ❺ 遍历密钥空间的一个子集。循环的每次迭代都会递增
    `i` 变量，直到你到达结束偏移量。
- en: As we mentioned previously, your key space is 40 bits, but `i` is 64 bits. This
    size difference is crucial to understand. You don’t have a native Go type that
    is 40 bits. You have only 32- or 64-bit types. Since 32 bits is too small to hold
    a 40-bit value, you need to use your 64-bit type instead, and account for the
    extra 24 bits later. Perhaps you could avoid this whole challenge if you could
    iterate the entire key space by using a `[]byte` instead of a `uint64`. But doing
    so would likely require some funky bitwise operations that may overcomplicate
    the example. So, you’ll deal with the length nuance instead.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，你的密钥空间是 40 位，但 `i` 是 64 位。这个大小差异非常重要。你没有一个原生的 Go 类型是 40 位的。你只有 32
    位或 64 位类型。由于 32 位太小，无法容纳 40 位的值，因此你需要使用 64 位类型，并且稍后处理额外的 24 位。也许你可以通过使用 `[]byte`
    而不是 `uint64` 来迭代整个密钥空间，从而避免整个挑战。但这样做可能需要一些奇怪的位运算，可能会让例子变得过于复杂。所以，你将处理长度上的细微差别。
- en: Within your loop, you include a `select` statement ❻ that may look silly at
    first, because it’s operating on channel data and doesn’t fit the typical syntax.
    You use it to check whether your `done` channel has been closed via `case <- done`
    ❼. If the channel is closed, you issue a `return` statement to break out of your
    goroutine. When the `done` channel isn’t closed, you use the `default` case ❽
    to create the crypto instances necessary to define work. Specifically, you call
    `binary.BigEndian.PutUint64(key, i)` ❾ to write your `uint64` value (the current
    key) to a `[]byte` named `key`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的循环中，你包含了一个 `select` 语句 ❻，乍一看可能显得有些愚蠢，因为它是在通道数据上操作，且不符合典型的语法。你使用它来检查 `done`
    通道是否已通过 `case <- done` ❼ 关闭。如果通道已关闭，你发出 `return` 语句以跳出你的 goroutine。当 `done` 通道未关闭时，你使用
    `default` 情况 ❽ 来创建定义工作的加密实例。具体而言，你调用 `binary.BigEndian.PutUint64(key, i)` ❾ 将你的
    `uint64` 值（当前密钥）写入名为 `key` 的 `[]byte` 中。
- en: 'Although we didn’t explicitly call it out earlier, you initialized `key` as
    an 8-byte slice. So why are you defining the slice as 8 bytes when you’re dealing
    with only a 5-byte key? Well, since `binary.BigEndian.PutUint64` takes a `uint64`
    value, it requires a destination slice of 8 bytes in length or else it throws
    an index-out-of-range error. It can’t fit an 8-byte value into a 5-byte slice.
    So, you give it an 8-byte slice. Notice throughout the remainder of the code,
    you use only the last 5 bytes of the `key` slice; even though the first 3 bytes
    will be zero, they will still corrupt the austerity of our crypto functions if
    included. This is why you call `rc2.New(key[3:], 40)` to create your cipher initially;
    doing so drops the 3 irrelevant bytes and also passes in the length, in bits,
    of your key: 40\. You use the resulting `cipher.Block` instance and the relevant
    key bytes to create a `CryptoData` object, and you write it to the `out` worker
    channel ❿.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们之前没有明确指出，但你将`key`初始化为一个8字节的切片。那么，为什么你要将切片定义为8字节，而实际上只处理5字节的密钥呢？嗯，因为`binary.BigEndian.PutUint64`接受的是一个`uint64`值，因此它需要一个8字节长度的目标切片，否则会抛出超出索引范围的错误。它无法将8字节的值存入5字节的切片。所以，你给它传递了一个8字节的切片。请注意，在其余的代码中，你只使用`key`切片的最后5个字节；即使前3个字节会是零，它们如果被包含进来，也会破坏我们加密函数的严格性。因此，你通过调用`rc2.New(key[3:],
    40)`来初始化你的加密器；这样做丢弃了前3个不相关的字节，并且传递了密钥的长度（单位为比特）：40。你使用生成的`cipher.Block`实例和相关的密钥字节来创建一个`CryptoData`对象，并将其写入`out`工作通道
    ❿。
- en: That’s it for the producer code. Notice that in this section you’re only bootstrapping
    the relevant key data needed. Nowhere in the function are you actually attempting
    to decrypt the ciphertext. You’ll perform this work in your consumer function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是生产者代码的全部内容。注意，在这一部分，你仅仅是在初始化所需的相关关键信息。函数中并没有实际尝试解密密文。你将在消费者函数中执行这项工作。
- en: Performing Work and Decrypting Data
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 执行工作和解密数据
- en: Let’s review the consumer function now ([Listing 11-10](ch11.xhtml#ch11list10)).
    Again, you’ll add this function to the same file as your previous code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回顾一下消费者函数（[示例11-10](ch11.xhtml#ch11list10)）。同样，你将把这个函数添加到与之前的代码相同的文件中。
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 11-10: The RC2 consumer function (*[/ch-11/rc2-brute/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-11/rc2-brute/main.go)*)*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例11-10：RC2消费者函数（*[/ch-11/rc2-brute/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-11/rc2-brute/main.go)*)*'
- en: 'Your consumer function, named `decrypt()` ❶, accepts several parameters. It
    receives the ciphertext you wish to decrypt. It also accepts two separate channels:
    a read-only `*CryptoData` channel named `in` that you’ll use as a work queue and
    a channel named `done` that you’ll use for sending and receiving explicit cancellation
    signals. Lastly, it also accepts a `*sync.WaitGroup` named `wg` that you’ll use
    for managing your consumer workers, much like your producer implementation. You
    tell your `WaitGroup` that you’re starting a worker by calling `wg.Add(1)` ❷.
    This way, you’ll be able to track and manage all the consumers that are running.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你的消费者函数名为`decrypt()` ❶，接受多个参数。它接收你想要解密的密文。同时，它还接受两个不同的通道：一个只读的`*CryptoData`通道，名为`in`，你将用它作为工作队列；另一个是名为`done`的通道，用于发送和接收显式的取消信号。最后，它还接受一个`*sync.WaitGroup`，名为`wg`，你将用它来管理消费者工作线程，和你的生产者实现方式类似。你通过调用`wg.Add(1)`
    ❷来告诉`WaitGroup`你正在启动一个工作线程。这样，你就能够跟踪并管理所有正在运行的消费者。
- en: Next, inside your goroutine, you call `defer wg.Done()` ❸ so that when the goroutine
    function ends, you’ll update the `WaitGroup` state, reducing the number of running
    workers by one. This `WaitGroup` business is necessary for you to synchronize
    the execution of your program across an arbitrary number of workers. You’ll use
    the `WaitGroup` in your `main()` function later to wait for your `goroutines`
    to complete.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在你的goroutine中，你调用`defer wg.Done()` ❸，这样当goroutine函数结束时，你将更新`WaitGroup`的状态，将正在运行的工作线程数减一。这个`WaitGroup`机制对于在任意数量的工作线程之间同步程序执行是必要的。稍后，你将在`main()`函数中使用`WaitGroup`来等待所有`goroutines`完成。
- en: The consumer uses a `for` loop ❹ to repeatedly read `CryptoData` work structs
    from the `in` channel. The loop stops when the channel is closed. Recall that
    the producer populates this channel. As you’ll see shortly, this channel closes
    after the producers have iterated their entire key space subsections and pushed
    the relative crypto data onto the work channel. Therefore, your consumer loops
    until the producers are done producing.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者使用`for`循环❹从`in`通道反复读取`CryptoData`工作结构体。循环在通道关闭时停止。回想一下，生产者会填充这个通道。正如你很快会看到的那样，这个通道会在生产者迭代完它们的整个密钥空间子集并将相关的加密数据推送到工作通道后关闭。因此，消费者循环直到生产者完成生产。
- en: As you did in the producer code, you use a `select` statement within the `for`
    loop to check whether the `done` channel has been closed ❺, and if it has, you
    explicitly signal the consumer to stop additional work efforts. A worker will
    close the channel when a valid credit card number has been identified, as we’ll
    discuss in a moment. Your `default` case ❻ performs the crypto heavy lifting.
    First, it decrypts the first block (8 bytes) of ciphertext ❼, checking whether
    the resulting plaintext is an 8-byte, numeric value ❽. If it is, you have a potential
    card number and proceed to decrypt the second block of ciphertext ❾. You call
    these decryption functions by accessing the `cipher.Block` field within your `CryptoData`
    work object that you read in from the channel. Recall that the producer instantiated
    the struct by using a unique key value taken from the key space.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 和生产者代码一样，你在`for`循环中使用`select`语句来检查`done`通道是否已关闭❺，如果已关闭，你显式地通知消费者停止额外的工作。当一个有效的信用卡号码被识别时，工作者将关闭通道，正如我们稍后会讨论的那样。你的`default`分支❻执行加密相关的重任务。首先，它解密第一个密文块（8字节）❼，检查结果明文是否是一个8字节的数字值❽。如果是，那么你就有了一个潜在的卡号，并继续解密第二个密文块❾。你通过访问从通道读取的`CryptoData`工作对象中的`cipher.Block`字段来调用这些解密函数。回想一下，生产者使用密钥空间中的唯一密钥值实例化了该结构。
- en: Lastly, you validate the entirety of the plaintext against the Luhn algorithm
    and validate that the second block of plaintext is an 8-byte, numeric value ❿.
    If these checks succeed, you can be reasonably sure that you found a valid credit
    card number. You display the card number and the key to `stdout` and call `close(done)`
    to signal the other goroutines that you’ve found what you’re after.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你使用Luhn算法验证整个明文，并验证第二个明文块是否是一个8字节的数字值❿。如果这些检查通过，你可以合理地确定你找到了一个有效的信用卡号码。你将卡号和密钥显示到`stdout`，并调用`close(done)`来通知其他goroutine你已经找到了目标。
- en: Writing the Main Function
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写主函数
- en: By this point, you have your producer and consumer functions, both equipped
    to execute with concurrency. Now, let’s tie it all together in your `main()` function
    ([Listing 11-11](ch11.xhtml#ch11list11)), which will appear in the same source
    file as the previous listings.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到这时，你已经有了生产者和消费者函数，两个函数都已准备好并具备并发执行的能力。现在，让我们在你的`main()`函数中将它们整合起来（[Listing
    11-11](ch11.xhtml#ch11list11)），它将出现在与之前的代码示例相同的源文件中。
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 11-11: The RC2* main() *function (*[/ch-11/rc2-brute/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-11/rc2-brute/main.go)*)*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-11: The RC2* main() *function (*[/ch-11/rc2-brute/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-11/rc2-brute/main.go)*)*'
- en: Your `main()` function decodes your ciphertext, represented as a hexadecimal
    string ❶. Next, you create several variables ❷. First you create `WaitGroup` variables
    used for tracking both producer and consumer goroutines. You also define several
    `uint64` values for tracking the minimum value in a 40-bit key space (0x0000000000),
    the maximum value in the key space (0xffffffffff), and the number of producers
    you intend to start, in this case `75`. You use these values to calculate a step
    or range, which represents the number of keys each producer will iterate, since
    your intent is to distribute these efforts uniformly across all your producers.
    You also create a `*CryptoData` work channel and a `done` signaling channel. You’ll
    pass these around to your producer and consumer functions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`main()`函数解码你的密文，密文以十六进制字符串表示❶。接下来，你创建几个变量❷。首先，你创建`WaitGroup`变量，用于跟踪生产者和消费者的goroutine。你还定义了几个`uint64`类型的值，用于跟踪40位密钥空间中的最小值（0x0000000000）、密钥空间中的最大值（0xffffffffff），以及你打算启动的生产者数量，这里是`75`。你使用这些值来计算步长或范围，表示每个生产者将迭代的密钥数量，因为你的目标是将这些工作均匀地分配给所有生产者。你还创建了一个`*CryptoData`工作通道和一个`done`信号通道。你将这些传递给你的生产者和消费者函数。
- en: Since you’re doing basic integer math to calculate your step value for the producers,
    there’s a chance that you’ll lose some data if the key space size isn’t a multiple
    of the number of producers you’ll spin up. To account for this—and to avoid losing
    precision while converting to a floating-point number for use in a call to `math.Ceil()`—you
    check whether the maximum key (`step * prods`) is less than your maximum value
    for the entire key space (0xffffffffff) ❸. If it is, a handful of values in the
    key space won’t be accounted for. You simply increase your `step` value to account
    for this shortage. You initialize two variables, `start` and `end`, to maintain
    the beginning and ending offsets you can use to break apart the key space.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你正在进行基本的整数运算来计算生产者的步长值，因此如果密钥空间的大小不是你将启动的生产者数量的倍数，就有可能丢失一些数据。为了解决这个问题——并避免在转换为浮点数时丧失精度，以便调用`math.Ceil()`——你会检查最大密钥值（`step
    * prods`）是否小于整个密钥空间的最大值（0xffffffffff）❸。如果是这样，密钥空间中就会有一些值没有被考虑到。你只需增加`step`值来弥补这一缺口。你初始化了两个变量，`start`和`end`，用于维护你可以用来划分密钥空间的起始和结束偏移量。
- en: The math to arrive at your offsets and step size isn’t precise by any means,
    and it could cause your code to search beyond the end of the maximum allowable
    key space. However, you fix that within a `for` loop ❹ used to start each of the
    producers. In the loop, you adjust your ending step value, `end`, should that
    value fall beyond the maximum allowed key space value. Each iteration of the loop
    calls `generate()` ❺, your producer function, and passes to it the start (`start`)
    and end (`end`) key space offsets for which the producer will iterate. You also
    pass it your `work` and `done` channels, as well as your producer `WaitGroup`.
    After calling the function, you shift your `start` and `end` variables to account
    for the next range of key space that will be passed to a new producer. This is
    how you break up your key space into smaller, more digestible portions that the
    program can process concurrently, without overlapping efforts between goroutines.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 计算偏移量和步长的数学方法并不精确，这可能导致你的代码在搜索时越过最大允许的密钥空间。然而，你在`for`循环❹中修正了这一点，这个循环用于启动每个生产者。在循环中，你调整结束步长值`end`，以防该值超出最大允许的密钥空间值。每次迭代都会调用`generate()`❺，这是你的生产者函数，并将开始（`start`）和结束（`end`）的密钥空间偏移量传递给它，生产者将根据这些偏移量进行迭代。你还将`work`和`done`通道以及生产者的`WaitGroup`传递给它。调用函数后，你会调整`start`和`end`变量，以便处理下一个密钥空间范围，这个范围将传递给新的生产者。这就是如何将密钥空间分成更小、更易处理的部分，程序可以并行处理，而不会在goroutines之间产生重叠的工作。
- en: After your producers are spun up, you use a `for` loop to create your workers
    ❻. In this case, you’re creating 30 of them. For each iteration, you call your
    `decrypt()` function ❼, passing to it the ciphertext, the work channel, the done
    channel, and the consumer `WaitGroup`. This spins up your concurrent consumers,
    which begin to pull and process work as the producers create it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产者启动之后，你使用`for`循环来创建你的工作线程❻。在这个例子中，你将创建30个工作线程。对于每次迭代，你调用`decrypt()`函数❼，并将密文、工作通道、完成通道以及消费者`WaitGroup`作为参数传递给它。这会启动你的并发消费者，它们开始在生产者生成工作时拉取并处理工作。
- en: Iterating through the entire key space takes time. If you don’t handle things
    correctly, the `main()` function will assuredly exit before you discover a key
    or exhaust key space. So, you need to make sure the producers and consumers have
    adequate time to either iterate the entire key space or discover the correct key.
    This is where your `WaitGroups` come in. You call `prodWg.Wait()` ❽ to block `main()`
    until the producers have completed their tasks. Recall that the producers have
    completed their tasks if they either exhaust the key space or explicitly cancel
    the process via the `done` channel. After this completes, you explicitly close
    the `work` channel so the consumers won’t deadlock continually while trying to
    read from it. Finally, you block `main()` again by calling `consWg.Wait()` ❾ to
    give adequate time for the consumers in your `WaitGroup` to complete any remaining
    `work` in the work channel.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历整个密钥空间需要时间。如果你不正确处理，`main()`函数肯定会在你发现密钥或者耗尽密钥空间之前退出。因此，你需要确保生产者和消费者有足够的时间来遍历整个密钥空间或找到正确的密钥。这时你的`WaitGroups`就派上用场了。你调用`prodWg.Wait()`❽来阻塞`main()`，直到生产者完成它们的任务。回想一下，生产者完成任务的条件是它们要么耗尽了密钥空间，要么通过`done`通道显式取消了任务。任务完成后，你显式关闭`work`通道，以避免消费者在尝试从中读取时发生死锁。最后，你再次阻塞`main()`，调用`consWg.Wait()`❾，为`WaitGroup`中的消费者提供足够的时间来完成`work`通道中的任何剩余工作。
- en: Running the Program
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行程序
- en: 'You’ve completed your program! If you run it, you should see the following
    output:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了程序！如果你运行它，应该会看到以下输出：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The program starts the producers and consumers and then waits for them to execute.
    When a card is found, the program displays the cleartext card and the key used
    to decrypt that card. Since we assume this key is the magical key for all cards,
    we interrupt execution prematurely and celebrate our success by painting a self-portrait
    (not shown).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 程序启动生产者和消费者，然后等待它们执行。当找到一张卡片时，程序会显示明文卡片和用来解密该卡片的密钥。由于我们假设这个密钥是所有卡片的魔法密钥，所以我们提前中断了执行，并通过画一幅自画像（未展示）来庆祝我们的成功。
- en: Of course, depending on the key value, brute-forcing on a home computer can
    take a significant amount of time—think days or even weeks. For the preceding
    sample run, we narrowed the key space to find the key more quickly. However, completely
    exhausting the key space on a 2016 MacBook Pro takes approximately seven days.
    Not too bad for a quick-and-dirty solution running on a laptop.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，根据密钥的不同，暴力破解在家庭电脑上可能需要相当长的时间——可能是几天甚至几周。对于前面的样本运行，我们通过缩小密钥空间来更快地找到密钥。然而，在2016款MacBook
    Pro上完全耗尽密钥空间大约需要七天时间。对于在笔记本电脑上运行的一个快速粗糙的解决方案来说，这还算不错。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概要
- en: Crypto is an important topic for security practitioners, even though the learning
    curve can be steep. This chapter covered symmetric and asymmetric crypto, hashing,
    password handling with bcrypt, message authentication, mutual authentication,
    and brute-forcing RC2\. In the next chapter, we’ll get into the nitty-gritty of
    attacking Microsoft Windows.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 加密是安全从业人员的重要话题，尽管学习曲线可能比较陡峭。本章讲解了对称和非对称加密、哈希、使用bcrypt处理密码、消息认证、互认证以及暴力破解RC2。接下来的章节，我们将深入探讨攻击Microsoft
    Windows的细节。
