- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">VALUE
    TYPES AND POLYMORPHISM</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">值类型与多态性</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: As an object-oriented programming (OOP) language, C# has good support for features
    that allow us to capture complex ideas and express them intuitively, such as classes,
    virtual methods, and inheritance. However, the language support for inheritance
    doesn’t extend to value types. Structs and record structs implicitly derive from
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> class, which
    is derived directly from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>,
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种面向对象编程（OOP）语言，C# 对一些能够捕捉复杂思想并直观表达的特性提供了很好的支持，如类、虚方法和继承。然而，语言对继承的支持并未扩展到值类型。结构体和记录结构体隐式地继承自<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>类，而该类又直接继承自<samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>。
- en: but they can’t inherit any other type and can’t themselves be inherited; that
    is, structs and record structs are implicitly sealed. Inheritance is a central
    feature of OOP that enables us to treat a reference to a derived class as though
    it refers to the base class, overriding the base class’s properties and methods
    to have new behavior as needed. These features don’t apply to value types, but
    that doesn’t mean value types are inferior.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但它们不能继承任何其他类型，也不能被继承；也就是说，结构体和记录结构体隐式地是封闭的。继承是面向对象编程的核心特性之一，它使我们能够将对派生类的引用当作对基类的引用来使用，必要时通过覆盖基类的属性和方法来获得新的行为。这些特性不适用于值类型，但这并不意味着值类型就逊色。
- en: Using the term *polymorphism* interchangeably with *inheritance* is common,
    but polymorphism is a more general concept; it relates to writing code that works
    uniformly for a variety of types to reduce duplication. As this chapter discusses,
    inheritance is just one kind of polymorphism, and while there are sound technical
    and semantic reasons for why value types can’t employ inheritance relationships,
    they can take advantage of other kinds of polymorphism.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 常常将*多态性*与*继承*交替使用，但多态性是一个更为广泛的概念；它涉及编写适用于多种类型的统一代码，以减少重复。正如本章所讨论的，继承只是多态性的一种形式，尽管有技术性和语义上的充分理由表明值类型不能使用继承关系，但它们可以利用其他类型的多态性。
- en: 'We’ll explore the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索以下内容：
- en: Why value types are sealed and why value-like types in general shouldn’t use
    inheritance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么值类型是封闭的，以及为什么一般来说类似值的类型不应使用继承
- en: How subtyping differs from subclassing and why it matters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类型化与子类化的区别及其重要性
- en: What *type substitutability* means and how it relates to inheritance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类型可替代性*是什么意思，它与继承有何关系'
- en: Where to use other kinds of polymorphism, rather than inheritance, to model
    relationships between objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模型化对象之间的关系时，何时使用其他类型的多态性，而非继承
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why Value Types Are Sealed</samp>
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">为何值类型是封闭的</samp>
- en: 'The principal technical reason for prohibiting inheritance for structs, and
    by extension record structs, is that they have different lifetime and storage
    characteristics than reference types. The restriction is more than an arbitrary
    rule: it results directly from how value type variables behave in memory, and
    how that behavior differs from reference types.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 禁止结构体及扩展到记录结构体使用继承的主要技术原因是，它们的生命周期和存储特性与引用类型不同。这一限制并非随意规定，而是直接源于值类型变量在内存中的表现，以及与引用类型的区别。
- en: Inheritance between classes allows us to use a reference to a base class type
    to refer to an instance of a derived class, so the static, compile-time type of
    a reference variable isn’t necessarily the same as the dynamic, run-time instance
    type. This characteristic permits *virtual dispatch* for method calls—the mechanism
    whereby the appropriate method implementation will be called based on the actual
    type of the object at run time—and relies on the extra level of indirection afforded
    by references; therefore, inheritance is appropriate only for reference types.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 类之间的继承允许我们使用对基类类型的引用来引用派生类的实例，因此，引用变量的静态编译时类型不一定与动态运行时实例的类型相同。这一特性使得*虚拟调度*成为可能——即根据对象在运行时的实际类型调用适当的方法实现——并依赖于引用提供的额外间接层级；因此，继承仅适用于引用类型。
- en: Value type variables directly contain their data, so we can’t declare a variable
    as one type to represent an instance of a different type, other than via boxing.
    Inheriting from a struct thus makes no sense, and the compiler forbids it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型变量直接包含它们的数据，因此我们不能声明一个变量为某种类型来表示另一个类型的实例，除了通过装箱（boxing）方式。继承自结构体因此没有意义，编译器会禁止这种做法。
- en: Remember, though, that we can use classes to model value-like behavior. As you
    saw in [Chapter 6](chapter6.xhtml), <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    behaves like a value but is implemented as a reference type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    type uses a value-based (rather than identity-based) equality comparison, is immutable,
    and has various other characteristics that identify it as a value. Being a class,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> could support virtual
    method dispatch, but we can’t derive from the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    class because it’s explicitly sealed. This means we can’t create our own augmented
    subclass of <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> any more
    than we could inherit from <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp>, or any other value
    type.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，我们可以使用类来模拟值类型行为。正如你在[第 6 章](chapter6.xhtml)中看到的，<samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    行为像值类型，但它是作为引用类型实现的。<samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    类型使用基于值的（而非基于标识的）相等性比较，是不可变的，并具有其他一些标识其为值类型的特征。作为一个类，<samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    可以支持虚方法调度，但我们不能从 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> 类派生，因为它被显式标记为密封类。这意味着我们不能像继承
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp>
    或任何其他值类型一样，创建我们自己的增强版 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    子类。
- en: Like the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> class,
    records are reference types but have value-like equality behavior. Records can
    derive from other records and can also have virtual methods, so they seemingly
    unify the ideas of values and inheritance. However, using records is not that
    straightforward. We need to note the subtleties and avoid the pitfalls when using
    any inheritance, whether between classes or records.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 像 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> 类一样，记录是引用类型，但具有类似值类型的相等性行为。记录可以从其他记录派生，并且可以拥有虚方法，因此它们似乎将值类型和继承的概念统一了。然而，使用记录并不是那么简单。我们需要注意细节，避免在使用任何继承时（无论是在类之间还是记录之间）掉进陷阱。
- en: When we allow our types to participate in inheritance relationships, we need
    to be mindful of what deriving from those types might entail. There’s a difference
    between *implementation* and *interface* inheritance. Inheriting an implementation
    presents some of the same difficulties as deriving from a value type. To explore
    why doing so is ill-advised, let’s look at a class with value-like characteristics
    and use implementation inheritance to demonstrate some of the problems that can
    result.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们允许我们的类型参与继承关系时，我们需要注意从这些类型派生可能带来的后果。*实现*继承和*接口*继承是有所区别的。继承实现会带来一些与继承值类型相似的困难。为了探讨为什么这样做不明智，我们来看一个具有值类型特征的类，并使用实现继承来展示可能导致的一些问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementation Inheritance</samp>
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">实现继承</samp>
- en: 'Anytime we inherit from a concrete class—that is, one that’s not fully abstract—we
    are, by definition, inheriting its implementation. [Listing 7-1](#list7-1) shows
    a simple inheritance relationship: a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    class derives from a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    base class and adds a new feature of its own.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们从一个具体类继承——即一个不是完全抽象的类——我们本质上是在继承它的实现。[列表 7-1](#list7-1) 展示了一个简单的继承关系：一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 类从 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 基类继承，并添加了自己的新特性。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-1: Creating a derived
    class, TranslucentColor, that inherits the implementation of Color</samp>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 7-1：创建一个派生类 TranslucentColor，它继承了
    Color 的实现</samp>
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> class
    subclasses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> class
    and inherits all of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s
    structural representation, along with its methods and properties. Both classes
    have automatic properties, which are each given a backing field of the same type
    as the property—<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in this
    example—and every field of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    is inherited by <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>类是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>类的子类，并继承了<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>的所有结构表示，以及它的方法和属性。两个类都有自动属性，每个属性都有一个与属性类型相同类型的后台字段—在这个例子中是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>—并且<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>的每个字段都被<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>继承。
- en: Even if we’d used private fields in <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    and returned their values via the properties, those fields would be inherited
    by the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> class,
    although they’d still be accessible only via the inherited *public* properties.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>中使用了私有字段，并通过属性返回它们的值，这些字段仍然会被<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>类继承，尽管它们仍然只能通过继承的*public*属性访问。
- en: 'The implementation inherited by <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> depends on those
    private fields. An instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    requires its own copies of all the fields declared by its base class so that the
    properties inherited from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    work correctly. We can use <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s
    properties via a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    variable as if they were declared as members of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>,
    as shown here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>继承的实现依赖于那些私有字段。<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>的实例需要拥有其基类声明的所有字段的副本，以确保从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>继承的属性能够正确工作。我们可以通过<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>变量像访问<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>的成员一样，使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>的属性，如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this simple test, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>
    property of a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    variable, which inherited that property from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
    We can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>
    property, which was declared as a member of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的测试中，我们使用一个<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>变量的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>属性，这个属性是从<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>继承而来的。我们还可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>属性，它是作为<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>的成员声明的。
- en: Using inheritance like this—to reuse the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>—is attractive,
    because it means that the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    type definition doesn’t duplicate <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s
    properties. By deriving from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> class
    gets those properties for free.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过继承这种方式—在<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>中重用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>的实现—非常有吸引力，因为这意味着<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>类型定义不会重复<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>的属性。通过从<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>派生，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>类可以免费获得这些属性。
- en: Both <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    look like good candidates to be value types because an equality comparison should
    compare each instance’s state. However, making value-based equality behave correctly
    in an inheritance hierarchy hides complexity that can easily result in undesirable
    behavior. To demonstrate that, let’s give <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> value
    semantics by following the recommendations from [Chapter 5](chapter5.xhtml) to
    override <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and its companions
    for both classes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    看起来是很好的值类型候选，因为相等比较应当比较每个实例的状态。然而，在继承层次结构中实现基于值的相等比较会隐藏一些复杂性，这可能会导致不希望出现的行为。为了证明这一点，让我们按照[第5章](chapter5.xhtml)的建议，为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    提供值语义，重写这两个类的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法及其相关方法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Value-Based Equality
    for Classes</samp>
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">基于值的类相等性</samp>
- en: We begin with the base class, <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
    With the implementation in [Listing 7-2](#list7-2), we can compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances to see whether their properties are equal.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从基类 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 开始。在[清单7-2](#list7-2)中的实现下，我们可以比较两个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 实例，查看它们的属性是否相等。
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: Defining value
    equality in the base class, Color</samp>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单7-2：在基类Color中定义值相等性</samp>
- en: This implementation of equality follows common practice for implementing value-based
    equality for classes, including the guidelines given in the Microsoft documentation.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> class implements
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< Color></samp> interface,
    which requires an overload of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method specifically for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
    We use this overload to provide the full implementation, which we can call from
    any other method, including the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method overridden from the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    base class. Since we’ve overridden <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>,
    we also override <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    to ensure that two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    produce the same hash code if they compare equal. Finally, we provide implementations
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> equality operators.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种相等性实现遵循了类的值类型相等性实现的常见做法，包括微软文档中的相关指南。<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    类实现了 <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< Color></samp> 接口，这要求为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 专门重载 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法。我们使用这个重载提供完整的实现，可以从任何其他方法中调用，包括从 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    基类重写的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法。由于我们已经重写了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>，我们还重写了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>，以确保两个相等的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    实例生成相同的哈希值。最后，我们为 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">!=</samp> 相等操作符提供了实现。
- en: Let’s examine each step in detail.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细检查每个步骤。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Canonical Form of Equals</samp>
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Equals的规范形式</samp>
- en: First we have to override the virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method inherited from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>,
    as shown in [Listing 7-3](#list7-3). Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    is a class, by default <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    compares object identities, so we need to override that behavior to give <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> a value-based implementation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须重写从 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 继承的虚方法
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>，如 [Listing 7-3](#list7-3)
    中所示。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 是一个类，默认情况下 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 比较的是对象的身份，因此我们需要重写该行为，以便为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 提供基于值的实现。
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-3: Overriding Equals</samp>'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-3: 重写 Equals</samp>'
- en: The override of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    must match the base-class signature. In this example, we declare the types within
    a nullable context, so we use <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp>
    as the parameter type for <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    indicating that we know the parameter could be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    and can handle that circumstance safely. Here we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp>
    operator to cast <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> in order to call the type-safe
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method. If <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>
    isn’t a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> or is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, the argument passed will
    be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, which is explicitly
    handled by the type-safe overload in [Listing 7-4](#list7-4).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 的重写必须与基类的签名匹配。在这个例子中，我们在一个可空的上下文中声明类型，因此我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> 作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    的参数类型，表示我们知道参数可能是 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，并且能够安全地处理这种情况。这里我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp> 操作符将 <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>
    强制转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>，以便调用类型安全的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>
    不是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 或者是 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，传入的参数将是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，这将通过类型安全的重载在 [Listing
    7-4](#list7-4) 中显式处理。
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-4: Implementing IEquatable</samp><
    Color>'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-4: 实现 IEquatable</samp><
    Color>'
- en: The type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> implementation
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< Color></samp>
    interface takes a nullable <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    parameter. This overload will always be preferred over the method taking an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> parameter when we’re comparing
    two variables whose static type is <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>,
    including when we call it from the <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> methods.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 类型安全的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 实现是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< Color></samp> 接口的一部分，接受一个可空的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 参数。当我们比较两个静态类型为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 的变量时，包含从 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>
    方法调用的情况，这个重载方法将优先于接受 <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp>
    参数的方法。
- en: One implication of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    being a reference type is that it’s possible for the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp>
    parameter to refer to the same instance as <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>.
    To handle this scenario, [Listing 7-4](#list7-4) casts both <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    to make it clear that we intend a reference comparison. While the cast we used
    in [Listing 7-3](#list7-3) from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    to a more derived type is a relatively costly run-time conversion, the conversion
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> to its <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    base class is very efficient and allows the comparison to be made with the intrinsic
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction introduced
    in [Chapter 5](chapter5.xhtml). One alternative would be to use <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals(this,
    other)</samp> here, making the reference-based comparison explicit.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 作为引用类型的一个含义是，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">other</samp> 参数可能引用与 <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    相同的实例。为了处理这种情况，[清单 7-4](#list7-4) 将 <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> 都强制转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>，以明确表示我们打算进行引用比较。尽管在
    [清单 7-3](#list7-3) 中使用的从 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    到更派生类型的强制转换是一个相对昂贵的运行时转换，但从 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    到其 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 基类的转换非常高效，并且使得比较能够使用
    [第 5 章](chapter5.xhtml) 中引入的原生 <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>
    指令进行。一种替代方法是这里使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals(this,
    other)</samp>，使引用比较更加显式。
- en: Comparing the two variables to see whether they reference the same object is
    a simple but not mandatory optimization. The logical <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    operator short-circuits if its left-hand expression is true, so the rest of the
    comparisons are attempted only if <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> are references
    to different instances. Note that the order of comparisons in this code relies
    on operator precedence; the logical <samp class="SANS_TheSansMonoCd_W5Regular_11">AND</samp>
    operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>) has a higher
    precedence than logical <samp class="SANS_TheSansMonoCd_W5Regular_11">OR</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>), so the comparisons
    on the right side of <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> all
    bind together as if they were explicitly grouped within a pair of parentheses.
    Although redundant, the extra parentheses don’t affect the behavior in any way,
    and some programmers prefer to add them to avoid having to remember the operator
    precedence rules.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 比较这两个变量是否引用同一个对象是一个简单但非强制性的优化。如果其左侧表达式为真，逻辑 <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    运算符会短路，因此只有当 <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">other</samp> 引用不同的实例时，才会尝试其余的比较。请注意，代码中比较的顺序依赖于运算符优先级；逻辑
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AND</samp> 运算符 (<samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>)
    的优先级高于逻辑 <samp class="SANS_TheSansMonoCd_W5Regular_11">OR</samp> 运算符 (<samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>)，因此
    <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> 右侧的比较会像被显式括在一对圆括号中一样一起绑定。虽然是冗余的，但额外的圆括号不会影响行为，某些程序员更喜欢添加这些括号，以避免记住运算符优先级规则。
- en: Because <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is a reference
    type, the argument passed could be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    so we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">is not</samp> constant
    pattern to compare <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> and avoid the common
    trap of calling our own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method recursively.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 是引用类型，传递的参数可能是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，因此我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">is
    not</samp> 常量模式来将 <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> 与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> 进行比较，从而避免常见的陷阱——递归调用我们自己的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> class is intentionally
    not sealed, so we also check that the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp>
    value is exactly the same type as <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp> method,
    defined on the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> base
    class. This method returns the run-time type of an instance, and the types won’t
    match if <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> is a reference
    to a more derived type such as <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
    Objects of different types don’t normally compare equal, even if their types are
    related by inheritance.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>类故意没有封闭，因此我们还检查<samp
    class="SANS_TheSansMonoCd_W5Regular_11">other</samp>值是否与<samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>的类型完全相同，方法是使用定义在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp>基类中的<samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp>方法。此方法返回实例的运行时类型，如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">other</samp>是指向更派生类型（如<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>）的引用，则类型不匹配。不同类型的对象通常不会比较相等，即使它们的类型通过继承相关联。
- en: Finally, if the types match, we compare each property’s value in turn. If they
    all match, our <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>. We use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    here because all the properties of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    are simple <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> values. Built-in
    values such as these can be compared intrinsically, and much more compactly than
    calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    for each of them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果类型匹配，我们依次比较每个属性的值。如果它们都匹配，我们的<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">true</samp>。我们在这里使用<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>而不是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>，因为<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>的所有属性都是简单的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>值。像这样的内置值可以本质上进行比较，比对每个属性调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法更加紧凑。
- en: 'To make comparing <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances natural, we also implement <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp>, which both defer to the type-safe
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使比较<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>实例变得自然，我们还实现了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>，它们都委托给类型安全的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法，像这样：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> operator will return
    the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> if the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> parameter is not <samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>; otherwise, it returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">true</samp> if both the parameters are
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> operator returns the opposite
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> by inverting the comparisons.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果<samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp>参数不是<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，则<samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp>运算符将返回<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>的结果；否则，如果两个参数都为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，则返回<samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>运算符通过反转比较结果返回与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp>相反的结果。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Contract for Equality</samp>
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">平等契约</samp>
- en: 'Implementing equality in a way that is self-consistent is critical. It would
    be a strange state of affairs if we had two references to the same instance of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> that did *not* compare
    equal, and stranger still if <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    could return <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> when comparing
    a value with itself. Equality has a contract similar to the one you saw for less-than
    comparisons in [Chapter 6](chapter6.xhtml). Namely, equality has the following
    characteristics:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以自洽的方式实现相等性非常关键。如果我们有两个引用指向同一实例的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>，但它们*不*相等，那将是非常奇怪的，更奇怪的是，如果在比较一个值与它自身时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>。相等性有一个类似于你在[第6章](chapter6.xhtml)中看到的“小于比较”约定的契约。即，相等性具有以下特征：
- en: '**Reflexive**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**自反性**'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is always <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 总是 <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>。
- en: '**Symmetric**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**对称性**'
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>，则 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>。
- en: '**Transitive**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**传递性**'
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> *and* <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>,
    then it follows that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> *并且* <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>，那么可以推断出
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>。
- en: '**Safe**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全性**'
- en: Non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> values are never
    equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 非<sup class="SANS_TheSansMonoCd_W5Regular_11">null</sup>值永远不等于 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>。
- en: '**Stable**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**稳定性**'
- en: The result of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> doesn’t change as long
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    don’t change.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 只要 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    不变，<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 的结果不会改变。
- en: In [Listing 7-5](#list7-5), we write some tests to prove that we’ve met the
    requirements of the equality contract.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 7-5](#list7-5)中，我们编写了一些测试来证明我们已满足相等性契约的要求。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*These tests are presented this way for emphasis, not to demonstrate a good
    style of assertion writing.*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*这些测试是为了强调这一点，而不是为了展示一种好的断言写作风格。*'
- en: The first test also ensures that we’re comparing the variables by value, not
    merely comparing references.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试还确保我们是通过值来比较变量，而不仅仅是比较引用。
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-5: Testing the contract
    for equality for Color</samp>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 7-5：测试 Color 的相等性契约</samp>
- en: 'Writing a test for comparison stability is more difficult, so in [Listing 7-6](#list7-6)
    we test the opposite: that if one of the values changes, the instances are no
    longer equal.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试以验证比较的稳定性更为复杂，因此在[示例 7-6](#list7-6)中，我们测试的是相反的情况：即如果某个值发生变化，实例就不再相等。
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-6: Testing that equality
    is stable</samp>'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-6：测试相等性是否稳定</samp>
- en: Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s properties
    are immutable, we can change the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp>
    only by assigning it to a new instance. However, the effect is the same as if
    we had mutated one or more of the properties, because we have arranged for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances to be compared
    by value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>的属性是不可变的，我们只能通过将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp>赋值为一个新实例来改变它的值。然而，效果和我们修改一个或多个属性是一样的，因为我们已经安排了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>实例按值进行比较。
- en: 'We have one other requirement for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method and its operator counterparts: they must never throw an exception. Our
    implementation has no danger of that, since we have already tested that it is
    safe with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法及其操作符对的另一项要求是：它们绝不应抛出异常。我们的实现没有这种风险，因为我们已经测试过它在处理<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>时是安全的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Equality Behavior
    in Derived Classes</samp>
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">派生类中的相等行为</samp>
- en: The next step is to implement equality for the derived <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    class, which, as we know, inherits all the methods and properties from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
    Since <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> is
    a value-like type, it should implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface for itself, substituting the <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>. As
    [Listing 7-7](#list7-7) shows, implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    TranslucentColor></samp> is a little simpler than the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    base class, which already does most of the work.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为派生类<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>实现相等性，正如我们所知，它继承了所有来自<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>的函数和属性。由于<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>是一个类值类型，它应该为自己实现<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp>接口，将<samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>替换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>。正如[清单 7-7](#list7-7)所示，实现<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< TranslucentColor></samp>比<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>基类要简单一些，因为基类已经完成了大部分工作。
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-7: Behavior inheritance
    in the derived class, TranslucentColor</samp>'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-7：派生类 TranslucentColor
    中的行为继承</samp>
- en: As with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> implementation,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> overrides
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp> method,
    converting the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> parameter
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> in order
    to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(TranslucentColor?)</samp>
    method ❶. That method also checks whether we’re comparing two references to a
    single instance and ensures that the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp>
    parameter isn’t <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 和<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>的实现一样，<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>重写了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>方法，将<samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>参数转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>，以调用<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(TranslucentColor?)</samp>方法❶。该方法还检查我们是否正在比较对单个实例的两个引用，并确保<samp
    class="SANS_TheSansMonoCd_W5Regular_11">other</samp>参数不是<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>。
- en: Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> already performs
    the check for identical references, the comparison with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    and the type check, as well as comparing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>
    properties, we don’t need to duplicate those comparisons and can simply invoke
    the base class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    before finally comparing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>
    properties that are specific to <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
    Passing <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">base.Equals</samp>
    is fine because a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    reference will convert implicitly to its <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    base class type.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>已经执行了对相同引用的检查、与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>的比较、类型检查，以及对<samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>属性的比较，因此我们不需要重复这些比较，只需调用基类的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法，然后最终比较特定于<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>属性。将<samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp>传递给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">base.Equals</samp>是可以的，因为<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>引用会隐式转换为其<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>基类类型。
- en: We also give <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    its own implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp>, and they, too, follow the same
    pattern as in <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, except
    that they take two <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    parameters ❷.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>提供了它自己的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>实现，它们也遵循与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>相同的模式，唯一不同的是它们接受两个<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>参数❷。
- en: The contract for equality applies not only to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    but also to <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
    We can use a test similar to the one from [Listing 7-5](#list7-5) to ensure that
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> meets the
    contract’s requirements. [Listing 7-8](#list7-8) shows a variation on [Listing
    7-6](#list7-6)’s stability check for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    as we test that differences in the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> property value
    will cause instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    to compare unequal.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 相等契约不仅适用于<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>，还适用于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>。我们可以使用类似于[清单 7-5](#list7-5)的测试来确保<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>符合契约的要求。[清单 7-8](#list7-8)展示了对[清单
    7-6](#list7-6)中<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>稳定性检查的变体，测试了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>类的<samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>属性值的差异会导致<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>实例比较为不相等。
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-8: Testing the equality
    contract for TranslucentColor</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-8：测试 TranslucentColor 的相等契约</samp>
- en: In this example, the two <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instances differ only in their <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>
    property and correctly compare *not* equal. We might conclude, then, that all
    is right with the world—but we’d be wrong.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，两个<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>实例仅在其<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>属性上有所不同，并且正确地比较为*不相等*。那么我们可能会得出结论，一切都没有问题——但我们会错的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Equality Comparisons
    and Type Substitution</samp>
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">相等比较与类型替代</samp>
- en: We’ve used a suite of tests to reassure us that the equality contract is intact
    for both <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> when we’re using
    variables whose dynamic (run-time) instance type is the same as their static (compile-time)
    variable type. However, the types might not always match. The compiler allows
    us to pass a reference to a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    anywhere a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> reference
    is required because <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    is a direct base class of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
    In other words, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type can be *substituted* by a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
    At run time, any <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> reference
    may, in fact, refer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instance.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一套测试来确保当我们使用动态（运行时）实例类型与静态（编译时）变量类型相同的变量时，`Color` 和 `TranslucentColor`
    的相等性契约是完好的。然而，类型可能并不总是匹配。编译器允许我们将一个 `TranslucentColor` 的引用传递到任何需要 `Color` 引用的地方，因为
    `Color` 是 `TranslucentColor` 的直接基类。换句话说，`Color` 类型可以被*替代*为 `TranslucentColor`。在运行时，任何
    `Color` 引用实际上可能指向一个 `TranslucentColor` 实例。
- en: To illustrate the effect on equality of using a base class reference to a derived
    class instance, [Listing 7-9](#list7-9) explicitly uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    base class reference to declare two <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    values that aren’t equal because their <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>
    properties differ.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明使用基类引用到派生类实例对相等性的影响，[列表 7-9](#list7-9)明确使用 `Color` 基类引用来声明两个 `TranslucentColor`
    值，它们不相等，因为它们的 `Alpha` 属性不同。
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-9: Testing equality
    from the base class</samp>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 7-9：从基类测试相等性</samp>
- en: 'This test fails: the <samp class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">crayon</samp> variables compare
    equal even though the instances have different values. It makes no difference
    whether we compare the variables with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    or call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method;
    the outcome is the same.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试失败了：`pencil` 和 `crayon` 变量在比较时是相等的，即使它们的实例值不同。无论我们使用 `==` 比较这些变量，还是调用 `Equals`
    方法，结果都是一样的。
- en: The static types being compared are <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    variables, so what’s invoked here is the base class implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>,
    which in turn calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> knows nothing about
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> property of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>, so <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    determines equality by using only the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>
    properties. Those properties are all identical, so according to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color.Equals</samp>,
    the two objects are equal.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正在比较的静态类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 变量，因此这里调用的是基类实现的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>，它又调用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法。<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法并不了解 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> 属性，因此 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    仅通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp> 属性来判断相等性。这些属性完全相同，因此根据
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color.Equals</samp>，这两个对象是相等的。
- en: Those are the mechanics that explain why our <samp class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">crayon</samp> variables incorrectly
    compare equal, but type substitution isn’t always so easy to spot, and its consequences
    are far-reaching.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些机制解释了为什么我们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp> 和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">crayon</samp> 变量错误地被认为相等，但类型替换并不总是那么容易被发现，它的后果深远。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Effects of Type Substitution</samp>
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">类型替换的影响</samp>
- en: We would rarely explicitly use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    reference for a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    object, but we can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    reference as an argument to a method with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    parameter. We can substitute a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    when a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is expected.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很少会显式地使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 引用来表示
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 对象，但我们可以将一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 引用作为参数传递给一个接受
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 参数的方法。当期望传递 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    时，我们可以用 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    进行替代。
- en: '[Listing 7-10](#list7-10) shows that if we pass two references to <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    objects that differ only in their <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>
    values to a method with <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    parameters, those parameter variables compare equal within the method. If we pass
    the same two references to a method that takes <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    parameters, the values won’t compare equal even though they haven’t changed.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-10](#list7-10) 显示了如果我们将两个仅在其 <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>
    值不同的 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 对象作为引用传递给一个具有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 参数的方法，那么这些参数变量在方法内会被认为相等。如果我们将相同的两个引用传递给一个接受
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 参数的方法，即使它们没有发生变化，值也不会被认为相等。'
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-10: Testing the stability
    promise</samp>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 7-10：测试稳定性承诺</samp>
- en: In the first assertion, the <samp class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">crayon</samp> references are
    automatically converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    references when we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaBase</samp>
    method because a reference to a derived class is implicitly convertible to a reference
    to any of its base classes. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    within <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaBase</samp> invokes
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s implementation, which
    incorrectly determines the parameter variables to be equal. The <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaDerived</samp>
    method calls <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor.Equals</samp>
    directly, which correctly reports that the parameter variables are not equal.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次断言中，当我们调用<samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaBase</samp>方法时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">crayon</samp>引用会被自动转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>引用，因为对派生类的引用可以隐式地转换为对其任何基类的引用。在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EqualViaBase</samp>中的<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>调用会调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>的实现，而该实现错误地认为参数变量是相等的。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EqualViaDerived</samp>方法直接调用<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor.Equals</samp>，它正确地报告参数变量不相等。
- en: 'The equality implementation for <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    isn’t stable: it can produce a different result for the same two instances depending
    on the static type of the variable used to refer to those instances, even when
    their underlying state remains unchanged.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>的相等实现并不稳定：它可能会根据用于引用这两个实例的变量的静态类型，产生不同的结果，即使它们的基础状态保持不变。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Breach of Contract</samp>
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">违反契约</samp>
- en: The behavior of the tests in [Listing 7-10](#list7-10) demonstrates that <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> breaks the promise
    of stability established by the contract for equality— namely, that the result
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> doesn’t change
    if the values being compared don’t change. When we compare two variables that
    have different values, they should compare not equal, and as long as no changes
    are made to either variable’s state, the result of the comparison shouldn’t change.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-10](#list7-10)中的测试行为表明，<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>违反了相等契约所规定的稳定性承诺——即，如果被比较的值没有变化，则<
    s>Equals</s>的结果不应发生变化。当我们比较两个具有不同值的变量时，它们应该被比较为不相等，并且只要这两个变量的状态没有变化，比较结果就不应改变。'
- en: One problem with our <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    implementation is that the type-specific overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> class isn’t
    virtual, and therefore it can’t be overridden in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
    The virtual version of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    which takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> parameter,
    isn’t considered in overload resolution because the overload with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    parameter is a much better match, even when the run-time type is derived from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>实现的一个问题是，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>类中的类型特定重载<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>并不是虚拟的，因此不能在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>中重写。虚拟版本的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>（接受<samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>参数）在重载解析中并未被考虑，因为带有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>参数的重载更为匹配，即使运行时类型是从<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>派生出来的。
- en: To get the test in [Listing 7-9](#list7-9) to pass, we could make the type-specific
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method virtual in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and add an override
    for it in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
    Another possibility would be to remove the implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    so that the only <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    would be virtual. We’d lose the facility for type-specific comparisons, with a
    small performance cost, but this option would address the problem of stability.
    However, either approach would be solving the wrong problem.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要使[Listing 7-9](#list7-9)中的测试通过，我们可以使类型特定的<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>中变为虚方法，并在<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>中为其添加重写方法。另一种可能是移除<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>中<samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp>接口的实现，使得唯一的<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法成为虚方法。我们将失去类型特定比较的功能，虽然会有一些小的性能开销，但这个选项可以解决稳定性问题。然而，任何一种方法都解决了错误的问题。
- en: The real underlying problem is that we’ve used inheritance inappropriately,
    not that our implementation of equality is incorrect. To fully appreciate why,
    we need to be clear on the difference between subclasses and subtypes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上的根本问题是我们不恰当地使用了继承，而不是我们实现的相等性存在问题。要充分理解这一点，我们需要明确区分子类和子类型的不同。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Inclusion Polymorphism and Subtyping</samp>
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">包含多态性与子类型化</samp>
- en: We think of the classes, structs, records, and record structs we write as being
    user-defined types. By extension, then, it’s natural to think that the definition
    of a class is its type. That perception is partially true, but a more formal distinction
    between *type* and *class* exists.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为我们编写的类、结构、记录和记录结构是用户定义的类型。因此，按扩展来说，认为类的定义就是它的类型是很自然的。这个看法部分正确，但*类型*和*类*之间存在着更为正式的区别。
- en: The polymorphism afforded by using inheritance is known as *inclusion* polymorphism.
    If we were to group all the objects in a system by type, each group of any specific
    type would *include* all the types that inherit from it, known as *subtypes*.
    In our example, the group for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type includes both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> types.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承所提供的多态性被称为*包含*多态性。如果我们根据类型将系统中的所有对象进行分组，那么任何特定类型的每一组将*包括*所有继承自它的类型，这些类型被称为*子类型*。在我们的例子中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>类型的组包括了<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>类型。
- en: An object’s type is a contract for its interface and describes the allowable
    operations on the object. The operations defined by a type are, therefore, valid
    for any subtypes in its group. Practically speaking, if we derive from a given
    type, all the operations that are valid for an object of the base type must be
    valid—and behave correctly—for an object of the derived type.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的类型是其接口的契约，描述了对该对象可执行的操作。因此，类型定义的操作对其组中的任何子类型都是有效的。从实际角度来看，如果我们从某个给定类型派生，那么所有对基础类型对象有效的操作必须对派生类型的对象也有效，并且行为正确。
- en: In our example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    object is an instance of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type as well as being a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
    This relationship means we can invoke any <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    operation on a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>,
    which in turn means we can pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instance to a method taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    parameter. As far as the compiler is concerned, a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    must be able to support all the operations of its base type, so it allows the
    substitution.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，一个<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>对象既是一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>类型的实例，也同时是一个<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>。这种关系意味着我们可以对一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>调用任何<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>操作，这也意味着我们可以将一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>实例传递给一个接受<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>参数的方法。就编译器而言，<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>必须能够支持其基类类型的所有操作，因此它允许这种替换。
- en: The type of an object establishes which operations a subtype must support, but
    it doesn’t specify any structural details or specific implementation. We’re free
    to implement the same interface in different ways, using various classes. However,
    while the contract for a type doesn’t mandate a specific implementation, it does
    define the expected behavior of any of its operations. When we inherit from a
    concrete class, we inherit its implementation, and this sets an expectation for
    that behavior. When implementing a type as a class or record, we must be mindful
    of the distinction between subtyping and subclassing, since we can inherit from
    reference types unless they’re explicitly sealed. For value types in C#, this
    isn’t an issue, because they’re implicitly sealed and so can’t have derived types.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的类型决定了子类型必须支持哪些操作，但它并未指定任何结构细节或具体实现。我们可以使用不同的类以不同的方式实现相同的接口。然而，虽然类型的契约并不要求具体的实现，它确实定义了任何操作的预期行为。当我们从一个具体类继承时，我们继承了它的实现，这就设定了对该行为的期望。当将类型实现为类或记录时，我们必须注意子类型化和子类化之间的区别，因为我们可以从引用类型继承，除非它们被显式封闭。对于C#中的值类型，这不是问题，因为它们是隐式封闭的，因此不能有派生类型。
- en: As noted earlier in this chapter, implementation and interface inheritance differ.
    In other words, simply inheriting from a class isn’t the same as actually respecting
    its behavioral characteristics. Code written in terms of the more general *type*,
    which defines the interface, may well depend on the specific characteristics of
    the *class*, which represents a particular implementation. If the derived class
    doesn’t respect the behavioral aspect of the type’s contract, when we use an instance
    of the derived class in code written for the base type, that code will very likely
    have unexpected behavior.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，实现和接口继承是不同的。换句话说，简单地继承一个类并不等同于真正遵守它的行为特性。用更一般的*类型*编写的代码，定义了接口，可能会依赖于*类*的特定特性，而类代表了特定的实现。如果派生类没有遵守类型契约的行为方面，那么当我们在为基类类型编写的代码中使用派生类的实例时，该代码很可能会出现意外的行为。
- en: When we inherit from a class, we inherit its behavior, characteristics, and
    expectations. A class that inherits from another concrete class is, then, a subclass,
    and only a true subtype if code using the base class *type* can use the derived
    class transparently with no change in observable behavior. When we inherit only
    the type, we have no implementation behavior to consider.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从一个类继承时，我们继承了它的行为、特性和预期。一个从另一个具体类继承的类就是子类，只有当使用基类*类型*的代码能够透明地使用派生类且观察不到任何行为变化时，它才是真正的子类型。当我们只继承类型时，就没有实现行为需要考虑。
- en: Mechanically speaking, we can substitute a reference to a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    where a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is required
    because we can use a reference to the derived type as an argument to a method
    expecting the base type. However, as you’ve seen with the behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instances interchangeably is not really possible.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从机械角度讲，我们可以在需要<code>Color</code>的地方替换为对<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>的引用，因为我们可以将派生类型的引用作为参数传递给期望基类型的方法。然而，正如你在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法的行为中所见，交替使用<code>Color</code>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>实例并不是完全可行的。
- en: The lack of substitutability between <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> arises
    because <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    is a *subclass* but not a true *subtype* of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>之间缺乏可替代性，是因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>是一个*子类*，但不是<code>Color</code>的真正*子类型*。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Working with Input
    and Output Types of Virtual Methods</samp>
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">处理虚方法的输入输出类型</samp>
- en: The difference between a subtype and a subclass has implications that go beyond
    how an inherited <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    is implemented. We can override any virtual method with an implementation that
    is appropriate for the derived class. If the observable effects, including any
    side effects, of calling the more derived method are identical to the effects
    of the base class, then the derived type is a good substitute for its base type—that
    is, the derived type is a proper subtype. Side effects might include writing to
    a file or to the screen, or perhaps updating the value of a variable visible outside
    the method. If a derived class does any of these things when its base class doesn’t,
    it’s not a true subtype.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 子类型与子类之间的差异有着超出如何实现继承的<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法的影响。我们可以用适合派生类的实现来重写任何虚拟方法。如果调用更派生的方法所产生的可观察效果，包括任何副作用，与基类的效果完全相同，那么派生类型就是其基类型的良好替代—that，即派生类型是一个真正的子类型。副作用可能包括写入文件或屏幕，或更新一个方法外部可见的变量的值。如果派生类在其基类没有的情况下做了这些事情，它就不是一个真正的子类型。
- en: A method’s behavior includes what the method considers to be valid inputs and
    outputs—that is, what parameters a method accepts and what it may return—each
    of which directly affects the method caller. To illustrate, suppose we add a virtual
    method to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> class
    like the one in [Listing 7-11](#list7-11) to subtract one <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    value from another.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的行为包括方法认为有效的输入和输出——即，方法接受哪些参数以及它可能返回什么——这些都会直接影响方法的调用者。举个例子，假设我们像[示例 7-11](#list7-11)中一样，向<code>Color</code>类添加一个虚拟方法，用来从另一个<code>Color</code>值中减去一个<code>Color</code>值。
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-11: Adding a virtual
    Subtract method to Color</samp>'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 7-11: 为 Color 添加虚拟的 Subtract
    方法</samp>'
- en: Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp> method
    is virtual, we can specialize its implementation in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    to handle subtraction appropriately for <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instances. Regardless of the actual algorithm used to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp>,
    its return value is the observable behavior of the method, as long as it has no
    side effects.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于<code>Subtract</code>方法是虚拟的，我们可以在<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>中专门化其实现，以适当处理<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>实例的减法操作。不管实现<code>Subtract</code>的实际算法是什么，只要没有副作用，它的返回值就是该方法的可观察行为。
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp> implementation
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> never returns a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference but the overridden
    version in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    might, then the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    method has a weaker behavioral contract than the base class method. Allowing the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> implementation
    to return a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> value requires
    extra checking in the calling code to avoid <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>-reference
    exceptions. The calling code, knowing only about the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type, might reasonably expect only non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    values. The weaker requirements on the return type mean that <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    isn’t substitutable for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果<samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp>在<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>中的实现从不返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>引用，但在<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>中被重写的版本可能会返回，那么<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>方法的行为契约就比基类方法更弱。允许<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>实现返回<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>值需要在调用代码中额外检查，以避免<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>引用异常。调用代码仅知道<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>类型，合理地会期望只返回非<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>值。对返回类型的更弱要求意味着<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>不能替代<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>。
- en: A corresponding situation arises when we *strengthen* requirements on the parameters
    in an overridden method. If we insist on non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    values in the derived type but the base class accepts <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    references, we break the contract established by the base class method. Once again,
    code written in terms of the base class has no notion of those requirements in
    derived classes and can easily violate them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在重写的方法中*加强*对参数的要求时，也会出现类似情况。如果我们在派生类型中坚持使用非<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>值，但基类接受<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>引用，就打破了基类方法所建立的契约。同样，以基类编写的代码对派生类中的这些要求没有概念，并且很容易违反这些要求。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp> method shown
    in [Listing 7-11](#list7-11) mitigates both of these potential problems by using
    the nullable reference type feature available since C# v8.0\. The return type
    of the base <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp> method
    is non-nullable, and the compiler will warn us if we override it with a method
    having a nullable reference type or if that method attempts to return a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference. Similarly, the
    parameter to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color.Subtract</samp>
    method is a nullable reference, indicating that <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    is an acceptable argument. If we override the method with a non-nullable reference
    type, the compiler will warn us that the method signature doesn’t match the base
    declaration.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-11](#list7-11)中显示的<samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp>方法通过使用自C#
    v8.0以来提供的可空引用类型特性，缓解了这两个潜在问题。基类<samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp>方法的返回类型是不可空的，如果我们重写它并使用可空引用类型或者该方法尝试返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>引用，编译器会警告我们。同样，<samp class="SANS_TheSansMonoCd_W5Regular_11">Color.Subtract</samp>方法的参数是一个可空引用，表示<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>是可以接受的参数。如果我们使用不可空引用类型重写该方法，编译器会警告我们方法签名与基类声明不匹配。'
- en: Note that if the base method returns a nullable reference and we override it
    to return a non-nullable reference, the compiler won’t give a warning. That is
    because in this case we’re strengthening the behavioral contract in the derived
    method, and it’s entirely reasonable for the more derived method to prohibit <samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, even if the base method allows
    it. The requirements on any code calling the method from a base type reference
    aren’t affected.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果基类方法返回一个可空引用，而我们重写它以返回一个不可空引用，编译器也不会给出警告。这是因为在这种情况下，我们在派生方法中加强了行为契约，而对于更派生的方法来说，禁止
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> 是完全合理的，即使基类方法允许它。通过基类类型引用调用方法的代码的要求并不受到影响。
- en: Likewise, the compiler is silent if the base method has a non-nullable parameter
    and we override it to allow a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference to be passed to the derived method, because weakening the parameter’s
    contract in the more derived type is safe and reasonable. The change is visible
    only to code using the more derived type *directly* rather than via a base type
    reference.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果基类方法有一个不可空的参数，而我们重写该方法以允许传递一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    引用给派生方法，编译器将保持沉默，因为在更派生的类型中削弱参数的契约是安全且合理的。这个变化只对直接使用更派生类型的代码可见，而不是通过基类类型引用来使用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Upholding a Type’s
    Contract</samp>
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">遵守类型的契约</samp>
- en: Our test for equality using base class references in [Listing 7-9](#list7-9)
    fails because the contract for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color.Equals</samp>
    isn’t properly fulfilled by the derived class. The expectations set out by <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> aren’t met by <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>,
    which imposes a new requirement on <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    because equality between <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instances must also compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>
    property. Our test fails as a direct result of our using implementation inheritance
    and expecting type substitutability, when in fact <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    isn’t substitutable for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
    The implications of implementation inheritance apply to all inheritance relationships,
    not just when we’re modeling value semantics.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[清单 7-9](#list7-9)中使用基类引用进行的相等性测试失败了，因为派生类没有正确履行 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color.Equals</samp>
    的契约。<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 所设定的期望并未被 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 满足，后者对 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    增加了新的要求，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    实例之间的相等性还必须比较 <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> 属性。我们的测试失败直接源于我们使用实现继承并期望类型可替代性，而实际上
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 并不能替代 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>。实现继承的影响适用于所有继承关系，而不仅仅是在建模值语义时。
- en: Upholding a type’s contract matters in practical ways. The behavior of an inherited
    method is part of that contract, and failing to uphold it can result in extremely
    hard-to-diagnose errors. If we fail to meet the *interface* contract of a base
    class—for instance, by using a different signature in an overridden method—the
    compiler will inform us with an error. However, the compiler can’t check that
    we’ve also kept the behavioral promises of a base class. Here we must use our
    own judgment, and that’s not necessarily as straightforward as it might seem.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循类型的契约在实际中非常重要。继承方法的行为是该契约的一部分，未能遵守它可能会导致极难诊断的错误。如果我们未能遵守基类的*接口*契约——例如，通过在重写方法中使用不同的签名——编译器会提示我们错误。然而，编译器无法检查我们是否遵守了基类的行为承诺。在这种情况下，我们必须依赖自己的判断，而这不一定像看起来那样简单。
- en: One rule of thumb is to avoid implementation inheritance whenever we use inheritance.
    The simplest way to be certain of that is to never derive from a class that has
    any concrete behavior—including abstract classes with any nonabstract methods.
    Types defined with the <samp class="SANS_TheSansMonoCd_W5Regular_11">interface</samp>
    keyword can’t have any implementation, and any class implementing an interface
    is a true subtype.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经验法则是，每当我们使用继承时，应该避免实现继承。确保这一点的最简单方法是，永远不要从具有任何具体行为的类派生——包括具有任何非抽象方法的抽象类。使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">interface</samp>关键字定义的类型不能有任何实现，任何实现接口的类都是一个真正的子类型。
- en: 'Another rule is that value types implemented as classes shouldn’t inherit from
    anything and should be sealed. In fact, this second rule arises as a result of
    the first: it makes little sense for a value type to be fully abstract, since
    a defining feature of value and value-like types is that we compare them according
    to the value they represent. It follows, then, that value types are concrete types.
    The built-in value-like class <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    leads the way with this advice, which is why <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    is intentionally a sealed class.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个规则是，作为类实现的值类型不应该继承任何东西，并且应该是密封的。实际上，第二条规则是由第一条规则引发的：对于值类型来说，完全抽象几乎没有意义，因为值类型和类似值类型的一个定义特征就是根据它们所代表的值进行比较。因此，值类型是具体类型。内置的类似值类<samp
    class="SANS_TheSansMonoCd_W5Regular_11">string</samp>以此为指导，这也是<samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>故意被设计为密封类的原因。
- en: Similar to strings, records are reference types that have value semantics for
    the purpose of comparisons with <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    Unlike strings, records can inherit from other records, but just as when we derive
    from a concrete class, a derived record inherits all the base record’s behavior.
    Therefore, we must still take care to uphold the base record’s promises in a derived
    record; however, as with classes, doing so isn’t always as simple as it might
    seem. Even though records permit inheritance, they’re specifically intended to
    model value types, so the advice to seal value types applies equally to them.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串类似，记录是引用类型，具有用于与<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>比较的值语义。与字符串不同，记录可以继承自其他记录，但就像从具体类派生时一样，派生的记录会继承所有基类记录的行为。因此，我们仍然需要小心，在派生的记录中遵守基类记录的承诺；然而，与类一样，做到这一点并不像看起来那么简单。尽管记录允许继承，但它们特别旨在建模值类型，因此对值类型应用密封的建议同样适用于记录。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Inheriting Record
    Types</samp>
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">继承记录类型</samp>
- en: When compiled, a record type is a class with some compiler-generated methods,
    including everything required for value-based equality. Moreover, records defined
    using the positional syntax are immutable by default. Using records instead of
    classes for creating value-like types, then, saves us from having to write a lot
    of boilerplate code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，记录类型是一个类，具有一些编译器生成的方法，包括所有与基于值的相等性相关的内容。此外，使用位置语法定义的记录默认是不可变的。因此，使用记录而不是类来创建类似值的类型，可以避免编写大量样板代码。
- en: Records, unlike structs, can inherit from other records, although they can’t
    be part of an inheritance relationship with a class. We might therefore recast
    our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    types as records, as in [Listing 7-12](#list7-12).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与结构体不同，记录可以继承自其他记录，尽管它们不能与类形成继承关系。因此，我们可能会将<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>类型重构为记录类型，如[示例
    7-12](#list7-12)所示。
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-12: Inheriting record
    types</samp>'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 7-12：继承记录类型</samp>
- en: Here we define <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> as positional
    records with positional parameters that represent read-only properties with those
    names, and a constructor taking parameters of the same type. The inheritance syntax
    for records differs slightly from that for classes because we need to initialize
    the positional parameters in the base record. The <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    record derives from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    and passes its <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>
    parameter values to the respective positional parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将<sup class="SANS_TheSansMonoCd_W5Regular_11">Color</sup>和<sup class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</sup>定义为带有位置参数的记录，这些位置参数表示具有这些名称的只读属性，并且构造函数接受相同类型的参数。记录的继承语法与类的继承语法略有不同，因为我们需要在基类记录中初始化位置参数。<sup
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</sup>记录从<sup class="SANS_TheSansMonoCd_W5Regular_11">Color</sup>派生，并将其<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Red</sup>、<sup class="SANS_TheSansMonoCd_W5Regular_11">Green</sup>和<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Blue</sup>参数值传递给<sup class="SANS_TheSansMonoCd_W5Regular_11">Color</sup>的相应位置参数。
- en: As we explored in [Chapter 5](chapter5.xhtml), the compiler generates the implementations
    of the constructor and properties for us, along with implementations for various
    overrides of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and a
    few methods, including a value-based implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>, and others. Equality
    comparisons between record variables compare the value of each property, so two
    record variables are equal if all their properties are equal.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第5章](chapter5.xhtml)中探讨的，编译器为我们生成了构造函数和属性的实现，以及<sup class="SANS_TheSansMonoCd_W5Regular_11">Equals</sup>的各种重写实现和一些方法的实现，包括基于值的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</sup>、<sup class="SANS_TheSansMonoCd_W5Regular_11">ToString</sup>等方法。记录变量之间的平等比较会比较每个属性的值，因此，如果两个记录变量的所有属性都相等，它们就相等。
- en: We can write our own implementation of the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method created by the compiler if we wish. However, the implementation of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> provided by the compiler
    is specially crafted to take inheritance into account.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，可以编写自己实现类型安全的<sup class="SANS_TheSansMonoCd_W5Regular_11">Equals</sup>方法，这是由编译器创建的。然而，编译器提供的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</sup>实现特别考虑了继承的情况。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Records and the Equality Contract</samp>
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <sup class="SANS_Futura_Std_Bold_Condensed_B_11">记录与平等合同</sup>
- en: The contract for equality applies to records just as for any other type, and
    the code provided by the compiler ensures that every aspect of the contract is
    respected, including the stability of comparisons via base class references. The
    test in [Listing 7-13](#list7-13) differs from the test in [Listing 7-10](#list7-10)
    in that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> types are records
    rather than classes. Here we compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    record values with different <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>
    properties and assert that they compare unequal whether we compare them directly
    using their concrete type or indirectly via a base class reference.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 平等合同适用于记录类型，就像适用于任何其他类型一样，编译器提供的代码确保合同的各个方面都得到遵守，包括通过基类引用进行比较时的稳定性。[列表 7-13](#list7-13)中的测试与[列表
    7-10](#list7-10)中的测试不同，因为<sup class="SANS_TheSansMonoCd_W5Regular_11">Color</sup>和<sup
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</sup>类型是记录类型，而不是类类型。在这里，我们比较了两个具有不同<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Alpha</sup>属性的<sup class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</sup>记录值，并断言它们在直接使用具体类型进行比较或通过基类引用间接比较时都不相等。
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-13: Equality between
    record types</samp>'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <sup class="SANS_Futura_Std_Book_Oblique_I_11">列表 7-13：记录类型之间的平等</sup>
- en: This test passes, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">crayon</samp> variables compare
    not equal whichever method we call, <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaDerived</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaBase</samp>.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 该测试通过，无论我们调用<samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaDerived</samp>还是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EqualViaBase</samp>方法，<samp class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">crayon</samp>变量比较结果始终为不相等。
- en: Because the compiler-generated implementation of equality pays particular attention
    to the equality contract, the variables compare not equal whether we use a base
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record reference or
    the derived <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    reference. In particular, the type-safe implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color.Equals(Color)</samp>
    is virtual in a record implementation and is overridden in the derived <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    record. As mentioned, doing this for our class implementations would make the
    test behave correctly. With records, the compiler injects those implementations
    for us.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译器生成的平等实现特别关注平等契约，因此无论我们使用基类的<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>记录引用还是派生类的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>引用，变量都会被认为不相等。特别地，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color.Equals(Color)</samp>的类型安全实现是虚拟的，并且在派生的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>记录中被重写。如前所述，若我们对类实现这样做，测试将正确执行。对于记录类型，编译器会为我们注入这些实现。
- en: We can override the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    methods ourselves, in which case the compiler won’t synthesize methods whose signature
    matches our own custom implementations. However, if we do so, we must pay the
    same attention to the equality contract as the compiler would in its generated
    version.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以自行重写<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法，在这种情况下，编译器不会生成与我们自定义实现签名匹配的方法。然而，如果我们这么做，我们必须像编译器生成版本那样，特别注意平等契约。
- en: In nonsealed records, the compiler creates a virtual property named <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>,
    which uses <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> to report
    the static (compile-time) type of its containing record. The implementation of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    record shown in [Listing 7-14](#list7-14) is equivalent to the one generated by
    the compiler, although, as you saw in [Chapter 5](chapter5.xhtml), some implementation
    details differ.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在非密封记录中，编译器创建了一个虚拟属性，命名为<samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>，它使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>报告其包含记录的静态（编译时）类型。如在[清单 7-14](#list7-14)中展示的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>记录的<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>实现与编译器生成的实现相同，尽管正如你在[第5章](chapter5.xhtml)中看到的，某些实现细节有所不同。
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-14: Using the equality
    contract in a nonsealed record</samp>'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-14：在非密封记录中使用平等契约</samp>
- en: When one record derives from another, as <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    does from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, the compiler
    adds an override of <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>
    in the derived record to report its static type. The compiler-generated implementation
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> in the base class
    checks that the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>
    properties match for both objects. If they don’t, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个记录继承自另一个记录时，正如<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>继承一样，编译器会在派生记录中添加一个重写的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>，以报告其静态类型。基类中编译器生成的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>实现会检查两个对象的<samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>属性是否匹配。如果不匹配，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>将返回<samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>。
- en: Notwithstanding the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>
    property, the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    follows the canonical form shown in [Listing 7-4](#list7-4). Since <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    derives from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">other</samp> parameter could refer to
    an instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
    If we attempt to compare a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    record with a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp> properties
    won’t match, and the objects will (correctly) compare not equal. Checking the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp> property
    is analogous to our original <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    class in [Listing 7-4](#list7-4) checking that <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp>
    returned the same type for both objects. Using the static type as <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>
    does has a slight benefit over <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp>
    because <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> is evaluated
    at compile time, whereas <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp>
    is evaluated at run time.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有<samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>属性，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>的实现仍遵循[清单7-4](#list7-4)中展示的规范形式。由于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>继承自<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">other</samp>参数可能引用<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>的实例。如果我们尝试将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>记录与<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>进行比较，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>属性将不匹配，两个对象将（正确地）被判定为不相等。检查<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>属性类似于我们在[清单7-4](#list7-4)中检查原始<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>类时检查<samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp>是否返回相同类型的对象。将静态类型用作<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>相比于<samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp>有一个轻微的优势，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>在编译时进行评估，而<samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp>是在运行时评估的。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp> property
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">protected</samp> so that it can
    be overridden by the derived type, but it can’t be called publicly. As [Listing
    7-15](#list7-15) shows, the virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>
    property is overridden in the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    record to return the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>属性是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">protected</samp>，以便由派生类型重写，但不能公开调用。如[清单7-15](#list7-15)所示，虚拟的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>属性在<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>记录中被重写，返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>的类型。
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-15: Overriding the
    equality contract in the TranslucentColor record</samp>'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单7-15：在TranslucentColor记录中重写相等契约</samp>
- en: The implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> calls
    the base class implementation before comparing the local properties of each object,
    ensuring that the contract properties are always compared. Crucially, the virtual
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Color?)</samp> method is
    overridden in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    and casts its argument to a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
    If that cast fails, the argument passed will be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    When we compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instances using <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> reference
    variables, as when we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaBase</samp>
    method in [Listing 7-13](#list7-13), it’s this override of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    that’s executed via virtual dispatch.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 中的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 实现会在比较每个对象的本地属性之前调用基类的实现，以确保始终比较契约属性。关键是，虚拟的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Color?)</samp> 方法在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 中被重写，并将其参数强制转换为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>。如果转换失败，传入的参数将是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>。当我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    引用变量比较两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    实例时，就像在 [示例 7-13](#list7-13) 中调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaBase</samp>
    方法一样，是通过虚拟分发执行的重写版本的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法。
- en: If we write our own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, it must also compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>
    properties because it rarely makes sense for instances of different types to compare
    equal.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编写自己的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法，它也必须比较
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp> 属性，因为不同类型的实例比较相等通常没有意义。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp> property
    alone doesn’t solve the problem of comparing two <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instances using <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> references.
    Our test in [Listing 7-13](#list7-13) passes because the compiler generates a
    virtual type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and overrides
    it in the derived record. When we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    on a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> variable, if the
    run-time instance is a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>,
    we call the more derived implementation. Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(TranslucentColor?)</samp>
    method is also virtual, because <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    can itself be inherited. A record deriving from <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    will have compiler-generated overrides of both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(TranslucentColor?)</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Color?)</samp> alongside
    its own type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅有 <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp> 属性并不能解决使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 引用比较两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    实例的问题。我们在 [示例 7-13](#list7-13) 中的测试通过了，因为编译器为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    生成了一个虚拟的类型安全的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法，并在派生记录中重写了它。当我们在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 变量上调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    时，如果运行时实例是 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>，我们就会调用更派生的实现。请注意，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals(TranslucentColor?)</samp> 方法也是虚拟的，因为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 本身可以被继承。从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 派生的记录将会生成编译器的重写版本，分别是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(TranslucentColor?)</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Color?)</samp>，并且还会有它自己的类型安全的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法。
- en: However, equality isn’t the only implementation we can inherit from a class
    or a record. We can define our own virtual and nonvirtual methods for a record
    exactly as we do for a class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，平等性并不是我们可以从类或记录中继承的唯一实现。我们可以像为类定义虚拟和非虚拟方法一样，为记录定义我们自己的虚拟和非虚拟方法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Contracts Other Than Equality</samp>
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">除平等性之外的契约</samp>
- en: The behavioral contract established by a base class or record applies to all
    its methods, not just <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    The compiler generates the right implementations to compare two record instances
    for equality, but we have to supply any other implementations for ourselves. One
    common interface implemented by value types is <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    T ></samp>, which, as you saw in [Chapter 6](chapter6.xhtml), allows us to sort
    collections of value types. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp> records in [Listing
    7-16](#list7-16) are related by inheritance, and each implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    T ></samp> interface by defining a <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 基类或记录所建立的行为契约适用于其所有方法，而不仅仅是<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>。编译器会生成比较两个记录实例是否相等的正确实现，但我们必须为其他任何实现提供自己的代码。值类型实现的一个常见接口是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IComparable< T ></samp>，正如你在[第6章](chapter6.xhtml)中看到的，它允许我们对值类型的集合进行排序。[Listing
    7-16](#list7-16)中的<samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>记录通过继承相关联，并且每个都通过定义<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>方法来实现<samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    T ></samp>接口。
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-16: Sorting Area
    and Volume records with IComparable</samp>< T >'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-16: 使用IComparable排序Area和Volume记录</samp><
    T >'
- en: The compiler will generate the code to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> for both <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>, although we should
    keep in mind that <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    is comparing <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values
    in each case, leading to possible problems, as we discovered in [Chapter 5](chapter5.xhtml).
    However, the compiler doesn’t provide the implementation for <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    T ></samp>, so we must write our own. Here, we define the ordering for <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp>
    so that one object is less than another if its total area is smaller. Similarly,
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>, one is less than
    another if its total volume is smaller. We also add <samp class="SANS_TheSansMonoCd_W5Regular_11">operator<</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator></samp> for both <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Area</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>,
    implemented in terms of the <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    method.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会为<samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>生成实现<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp>的代码，尽管我们应该记住，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>在每种情况下比较的是<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>值，这可能会导致问题，正如我们在[第5章](chapter5.xhtml)中发现的那样。然而，编译器并没有提供<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IComparable< T ></samp>的实现，因此我们必须自己编写。在这里，我们为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Area</samp>定义了排序规则，当一个对象的总面积较小时，它小于另一个对象。类似地，对于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>，当一个对象的总体积较小时，它小于另一个对象。我们还为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Area</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>添加了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator<</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">operator></samp>，这些运算符是通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>方法实现的。
- en: As we explored in [Chapter 6](chapter6.xhtml), ordering comparisons have their
    own contract, and the implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    T ></samp> in [Listing 7-16](#list7-16) effectively suffer the same problems as
    our original implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> classes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第6章](chapter6.xhtml)中探讨的那样，排序比较有其自身的契约，而在[示例 7-16](#list7-16)中的`IComparable<T>`实现，实际上遭遇了与我们原始实现的`IEquatable<T>`接口在`Color`和`TranslucentColor`类中的相同问题。
- en: Although we’re using <samp class="SANS_TheSansMonoCd_W5Regular_11">record</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp> in the declarations,
    we’re still employing implementation inheritance. Subclassing is as much an issue
    for records as it is for classes. We can demonstrate this with a new test in the
    same vein as checking whether two <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instances compare not equal when their <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>
    properties differ. In [Listing 7-17](#list7-17), two <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>
    instances differ only in their <samp class="SANS_TheSansMonoCd_W5Regular_11">Depth</samp>
    property, but we compare them with <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
    by using references to the base record type.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在声明中我们使用了`record`而不是`class`，但我们仍然在使用实现继承。子类化对于记录类型的问题与类类型一样。我们可以通过一个新的测试来演示这一点，就像检查两个`TranslucentColor`实例在它们的`Alpha`属性不同的情况下是否不相等一样。在[示例
    7-17](#list7-17)中，两个`Volume`实例仅在它们的`Depth`属性上有所不同，但我们通过使用基记录类型的引用，使用`<`进行比较。
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-17: Testing the contract
    for CompareTo in two Volume instances</samp>'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 7-17：测试两个Volume实例中CompareTo契约</samp>
- en: This test *fails* because the static, compile-time types of the <samp class="SANS_TheSansMonoCd_W5Regular_11">door</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">window</samp> variables differ
    from their dynamic, run-time types. When we compare them using the base class
    static type, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Depth</samp> property
    of the derived record is ignored, giving an incorrect result.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试*失败*了，因为`door`和`window`变量的静态编译时类型与它们的动态运行时类型不同。当我们使用基类的静态类型进行比较时，派生记录的`Depth`属性被忽略，导致了错误的结果。
- en: As with the compiler implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp>, we could make the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    virtual in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp> record
    and override it in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>
    type. While doing so would address the immediate problem of this failing test,
    it wouldn’t solve every problem with our implementation. For example, when we
    compare an <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp> with a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>, what should <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    return? An equality comparison between instances that aren’t the same type simply
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>, but it’s not
    so straightforward for <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>.
    We might choose to compare any <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp>
    as less than any <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>,
    but that too may lead to confusion.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如编译器实现的<samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp>一样，我们可以将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>的实现定义为虚拟方法，放在<samp class="SANS_TheSansMonoCd_W5Regular_11">面积</samp>记录中，并在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">体积</samp>类型中重写它。尽管这样做可以解决当前测试失败的问题，但它并不能解决我们实现中的所有问题。例如，当我们比较一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">面积</samp>和一个<samp class="SANS_TheSansMonoCd_W5Regular_11">体积</samp>时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>应该返回什么？不同类型实例之间的相等比较会简单地返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">false</samp>，但对<samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>来说就不那么简单了。我们可能会选择将任何<samp
    class="SANS_TheSansMonoCd_W5Regular_11">面积</samp>视为小于任何<samp class="SANS_TheSansMonoCd_W5Regular_11">体积</samp>，但这也可能导致混淆。
- en: The question of whether an <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp>
    is less than a <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp> is
    not a meaningful one, but disallowing ordering comparisons for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp> types individually
    would be extremely prohibitive; it makes perfect sense to see if one <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp>
    is less than another, and likewise for <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>.
    We can arrange for <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    to throw an exception if the objects being compared have different run-time types,
    but this will add complexity to the calling code and may surprise some users.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">面积</samp>是否小于<samp class="SANS_TheSansMonoCd_W5Regular_11">体积</samp>的问题并没有实际意义，但禁止对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">面积</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">体积</samp>类型分别进行排序比较将极为繁琐；比较两个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">面积</samp>是否大小关系，或比较两个<samp class="SANS_TheSansMonoCd_W5Regular_11">体积</samp>也是非常合理的。我们可以让<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>在比较的对象类型不同时抛出异常，但这会增加调用代码的复杂性，可能会让某些用户感到困惑。
- en: This demonstrates first that records are not a “silver bullet,” and second—and
    more importantly—that we might still be trying to solve the wrong problem.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这首先证明了记录并不是“灵丹妙药”，更重要的是，它表明我们可能仍在试图解决错误的问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Avoiding Implementation
    Inheritance</samp>
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">避免实现继承</samp>
- en: Our problems with inheriting <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> demonstrate
    why value types don’t make good base types, regardless of whether we use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">class</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">record</samp>
    to define them.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继承<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>时遇到的问题表明，值类型并不适合作为基类型，无论我们是使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">class</samp>还是<samp class="SANS_TheSansMonoCd_W5Regular_11">record</samp>来定义它们。
- en: More generally, inheriting any implemented behavior makes it challenging to
    ensure that code written for the base type will work correctly if we substitute
    an inherited type. Even if we don’t override the base type’s methods, we can’t
    easily guarantee that those methods will work correctly for any derived type.
    While inheritance is a popular mechanism for reusing a base type’s implementation,
    fulfilling the base type behavioral contract in a derived type is often much more
    difficult than it appears.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地说，继承任何已实现的行为使得确保为基类型编写的代码在替换继承类型时能正确运行变得具有挑战性。即使我们没有重写基类型的方法，我们也无法轻易保证这些方法对于任何派生类型都能正确工作。虽然继承是重用基类型实现的常见机制，但在派生类型中履行基类型行为合同通常比看起来要困难得多。
- en: One way to ensure that one type can be substituted for another is to avoid implementation
    inheritance entirely. Remember, when we implement an interface, the implementing
    class is truly a subtype of the interface type; there’s no behavioral contract
    to consider because interfaces have no implementation. An interface type defines
    what an implementing type must be able to do but doesn’t prescribe any specific
    implementation. An interface, in effect, defines *only* a type, not a class.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 确保一种类型可以替代另一种类型的一种方法是完全避免实现继承。记住，当我们实现一个接口时，实现类实际上是接口类型的子类型；因为接口没有实现，所以没有行为合同需要考虑。接口类型定义了实现类型必须能够做的事情，但并不规定任何具体的实现。接口实际上仅仅定义了*一个*类型，而不是一个类。
- en: An interface type can be substituted by any implementing type, so we can use
    different implementations under different circumstances. Code that depends only
    on an interface type—whether as a parameter in a method or a field in a type—is
    completely decoupled from the way that interface is implemented. This means that
    interfaces are *seams*—customization points in our code where we can swap one
    implementation for another.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接口类型可以被任何实现类型替代，因此我们可以在不同的情况下使用不同的实现。仅依赖于接口类型的代码——无论是在方法中的参数，还是在类型中的字段——都完全与接口的实现方式解耦。这意味着接口是*接口*——我们代码中的定制点，允许我们在不同实现之间进行切换。
- en: Code that’s written in terms of interface types rather than concrete implementations
    is more flexible because it doesn’t depend on a particular implementation. It’s
    also easier to test because we can switch out concrete implementations of an interface
    with our own *test double*, sometimes known as a *stub*, *fake*, or *mock object*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 用接口类型而非具体实现编写的代码更具灵活性，因为它不依赖于特定的实现。它也更容易测试，因为我们可以用自己的*测试替身*（有时称为*存根*、*假对象*或*模拟对象*）来替换接口的具体实现。
- en: It’s common to see interface types represent the controllers and services described
    in [Chapter 6](chapter6.xhtml), sometimes with several implementations. A specific
    concrete implementation may be selected at run time, perhaps according to configuration
    parameters or the run-time environment. However, code *using* the controller or
    service—frequently in the entity types—doesn’t need to change because its behavior
    depends only on the interface, not the specific concrete type. The controllers
    and services are also where we’re most likely to want a fake implementation during
    testing so that the testing doesn’t need access to an external or expensive resource,
    such as a real database.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们会看到接口类型代表[第六章](chapter6.xhtml)中描述的控制器和服务，有时会有多种实现。特定的具体实现可能会在运行时根据配置参数或运行环境选择。然而，*使用*控制器或服务的代码——通常是在实体类型中——不需要修改，因为它的行为仅依赖于接口，而不是具体的实现类型。控制器和服务通常是我们在测试中最希望使用假的实现的地方，这样测试就不需要访问外部或昂贵的资源，比如真实的数据库。
- en: When value types implement one or more interfaces, it’s to define specific protocols,
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable< T ></samp>, rather
    than to allow client code to use different implementations. Value types, no matter
    the mechanism we use to implement them, should stand alone and be largely, if
    not wholly, independent of other types in an application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当值类型实现一个或多个接口时，它是为了定义特定的协议，例如<samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable< T ></samp>，而不是为了允许客户端代码使用不同的实现。值类型，无论我们使用什么机制来实现它们，都应该独立存在，并且在应用程序中应该大多数、如果不是完全独立于其他类型。
- en: The advice to avoid implementation inheritance leads to the recommendation that
    records should *always* be sealed, because they’re specifically designed for modeling
    value types. Classes should also be sealed by default, whether or not we’re using
    them to model values, and inheritance enabled only when we have a specific design
    rationale for it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 避免实现继承的建议导致了“记录应该*始终*是密封的”这一推荐，因为它们专门用于建模值类型。类也应该默认是密封的，无论我们是否使用它们来建模值，只有在我们有特定设计理由时才启用继承。
- en: Although this advice might seem to limit the flexibility of our designs, we
    can use other ways to define relationships in our code without deriving new types
    from existing ones. Inheritance isn’t the only option for reusing the implementation
    of an existing type to extend its capabilities.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个建议可能看起来限制了我们设计的灵活性，但我们可以通过其他方式在代码中定义关系，而无需从现有类型派生新类型。继承并不是唯一可以复用现有类型实现并扩展其功能的选项。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Containing Instead
    of Inheriting Types</samp>
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">包含类型而非继承类型</samp>
- en: One way we can use the behavior of one concrete type to implement another is
    to simply *contain* (or *compose*) an instance of the type as a field or property.
    This is especially true when we need a value type, like <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>,
    that’s easily implemented in terms of a simpler type, like <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>,
    but without implying any type substitutability between them. While value types
    should generally be stand-alone, containing another value as a field is one exception
    that’s frequently beneficial.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将一个具体类型的实例作为字段或属性来简单地*包含*（或*组合*）另一个类型的行为，从而实现对另一个类型的实现。这在我们需要值类型时尤其适用，比如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>，它可以通过更简单的类型
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 来实现，但并不意味着它们之间有任何类型替代关系。虽然值类型通常应该是独立的，但作为字段包含另一个值类型是一个经常带来好处的例外。
- en: We implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> as
    a class and then as a record so we could take advantage of inheritance. Modeling
    values with a <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp> is not
    unreasonable—and, as we know, records are specifically provided for that purpose.
    But if we contain a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> instead
    of deriving from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> to implement both
    types is much simpler. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">record
    struct</samp> is even simpler still, as we do in [Listing 7-18](#list7-18), where
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> contains
    an instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 实现为类，再实现为记录，以便利用继承。用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp> 来建模值并不是不合理的——而且，正如我们所知，记录专门用于此目的。但如果我们在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 中*包含*一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 实例，而不是从 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    派生，那么使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> 来实现这两种类型会更简单。使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">record struct</samp> 甚至更简单，就像我们在[清单
    7-18](#list7-18)中所做的那样，其中 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    包含一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 实例。
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-18: Containing Color
    rather than inheriting from it</samp>'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-18：包含颜色而非继承颜色</samp>
- en: 'Here, the compiler provides the implementation for <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> for each type, leaving us to define just the properties and behavior
    for them. The <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    type contains a read-only <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instance, and we add a new constructor as a convenience for our users, who can
    either create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    value to pass to <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>’s
    generated constructor or call our new constructor with each component part separately.
    We also mirror <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s properties
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> and forward
    them to the contained <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    value. We don’t get those properties for free, but they afford users of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> a much more natural
    interface, like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，编译器为每种类型提供了 <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T
    ></samp> 的实现，我们只需要定义这些类型的属性和行为。<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    类型包含一个只读的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 实例，并且我们增加了一个新的构造函数，方便我们的用户创建新的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 值并传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    生成的构造函数，或者通过分别传递每个组件调用我们的新构造函数。我们还在 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    中镜像了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 的属性，并将它们转发到包含的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 值。我们没有免费获得这些属性，但它们为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 的用户提供了一个更自然的接口，像这样：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The alternative would force users to explicitly obtain the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    property in order to access its properties, like so:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择将强迫用户显式获取 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 属性，以便访问其属性，像这样：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Whether we use structs or define our value types with sealed records or classes,
    or record structs, testing our new types is much simpler to reason about now,
    as we don’t need to consider cases where <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instances are referred to by <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    references. That in itself is a large consideration because those tests will be
    not only easier to write but also easier to read by the next programmers who visit
    the code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是使用结构体，还是通过封闭记录或类，或记录结构体来定义值类型，测试我们新的类型现在变得更容易理解，因为我们不需要考虑 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    实例是否通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 引用进行引用。这本身是一个重要的考虑，因为这些测试不仅更容易编写，而且下一个访问代码的程序员也能更容易阅读。
- en: Composing types isn’t a perfect match for the version that employed inheritance,
    because we can’t use a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instance as an argument to a method expecting a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
    As you’ve seen, sometimes that substitutability isn’t appropriate.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 类型组合与采用继承的版本并不完全匹配，因为我们不能将 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    实例作为方法参数传递给期望接收 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 的方法。正如你所见，有时这种替代性并不合适。
- en: Inheritance isn’t the only form of polymorphism nor the only mechanism that
    exhibits type substitutability, but other approaches allow the compiler to inform
    us when we incorrectly substitute one type for another. Let’s take a look at some
    of them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 继承并不是唯一的多态形式，也不是唯一展示类型替代性的机制，但其他方法允许编译器在我们错误地替代某个类型时通知我们。让我们来看看其中的一些。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Parametric Polymorphism with Generics</samp>
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用泛型的参数多态性</samp>
- en: C# generics offer *parametric polymorphism*, a form of polymorphism that allows
    us to write code once that works for multiple types by using generic type parameters
    instead of actual types. This approach provides a common form and purpose for
    all the types that can be substituted for those parameters.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: C# 泛型提供了*参数多态性*，这是一种多态性形式，通过使用泛型类型参数而非实际类型，可以编写一次代码以适应多种类型。这种方法为所有能够替代这些参数的类型提供了一个共同的形式和目的。
- en: This is most clearly demonstrated by the generic collection classes in the Standard
    Library, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">List< T ></samp>,
    where <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is a generic parameter
    type that can be substituted by *any* run-time type, including any types we define
    ourselves. For example, in [Listing 7-19](#list7-19) we declare two <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    T ></samp> variables parameterized with different, unrelated types.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点在标准库中的泛型集合类中得到了最清晰的展示，比如 <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    T ></samp>，其中 <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> 是一个泛型参数类型，可以由
    *任何* 运行时类型替代，包括我们自己定义的类型。例如，在 [清单 7-19](#list7-19) 中，我们声明了两个泛型类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    T ></samp> 的变量，分别使用不同且不相关的类型。
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-19: Using a generic
    type</samp>'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-19: 使用泛型类型</samp>'
- en: Although the <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp> implementation’s
    behavior doesn’t change, a <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    Color></samp> is a distinct type from <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    string></samp>, and there’s no relationship between the two types. The generic
    <samp class="SANS_TheSansMonoCd_W5Regular_11">List< T ></samp> code is written
    in terms of the <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> generic
    parameter, and since <samp class="SANS_TheSansMonoCd_W5Regular_11">List< T ></samp>
    doesn’t need to know anything about the structural or behavioral characteristics
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, it can be used with
    any type.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp> 实现的行为没有改变，但 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">List< Color></samp> 是与 <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    string></samp> 完全不同的类型，这两个类型之间没有任何关系。泛型 <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    T ></samp> 代码是根据 <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> 泛型参数编写的，而由于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">List< T ></samp> 不需要了解 <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    的结构或行为特征，因此它可以与任何类型一起使用。
- en: To put that another way, in the context of <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    T ></samp>, any type can be substituted for the <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    parameter without implying any subtype relationship. We have no behavioral contract
    to take into account, because <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    T ></samp> makes no assumptions about <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">List< T ></samp> 的上下文中，任何类型都可以替代
    <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> 参数，而不意味着任何子类型关系。我们不需要考虑行为契约，因为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">List< T ></samp> 对 <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    没有任何假设。
- en: If we need to be more selective about the types that are suitable for a generic
    parameter type in our own generic code, or if we require the generic code to use
    methods and properties beyond those provided by <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>,
    we can constrain the parameter to allow only types having specific behavior.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要对适用于泛型参数类型的类型进行更精确的选择，或者如果我们要求泛型代码使用比 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    提供的更多方法和属性，我们可以对参数进行约束，只允许具有特定行为的类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generic Constraints
    and Protocol Interfaces</samp>
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">泛型约束与协议接口</samp>
- en: Since <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> is the base
    class of every type, generics can use its methods via a variable of type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, but to access anything else,
    the compiler needs more information on what <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    can be. We provide that information through generic type constraints. One example
    is an interface constraint, which restricts <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    to a type that implements the specified interface, ensuring that all interface
    operations are legal for a variable of that generic type. Consider, for instance,
    the interface shown in [Listing 7-20](#list7-20).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 是所有类型的基类，所以泛型可以通过类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> 的变量使用其方法，但要访问其他内容时，编译器需要更多关于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> 可以是什么的信息。我们通过泛型类型约束提供这些信息。一个例子是接口约束，它将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> 限制为实现指定接口的类型，确保该泛型类型的变量对所有接口操作都是合法的。例如，考虑
    [清单 7-20](#list7-20) 中展示的接口。
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-20: A contract interface</samp>'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 7-20：一个契约接口</samp>
- en: The generic <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp>
    interface defines a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp>
    method for turning a string value into an object instance of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> parameter in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp> is unconstrained,
    so this interface can be implemented by any type. In [Listing 7-21](#list7-21),
    we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp> interface
    to constrain the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    parameter of the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    generic class.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型接口 `<samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp>` 定义了一个将字符串值转换为
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>` 类型对象实例的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp>`
    方法。`<samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp>` 中的 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">T</samp>` 参数没有约束，因此此接口可以被任何类型实现。在 [列表
    7-21](#list7-21) 中，我们使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    T ></samp>` 接口来限制 `<samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>`
    泛型类的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>` 参数。
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-21: Constraining
    a type for its API</samp>'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 7-21：为其 API 限制一个类型</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> class has
    two generic parameters. The <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    parameter is constrained to the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    T ></samp> interface in the <samp class="SANS_TheSansMonoCd_W5Regular_11">where</samp>
    clause following the type definition. <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    is constrained using the second generic parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>,
    which also corresponds to the return type from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>
    method, meaning that <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    can be substituted by an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    TResult ></samp>. The constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> parameter,
    so the argument passed must be an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    T ></samp>, with the <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> substituted
    by the same type as the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>
    parameter for <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>` 类有两个泛型参数。`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>` 参数在类型定义后的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">where</samp>`
    子句中被限制为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp>` 接口。`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>` 通过第二个泛型参数 `<samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>`
    进行约束，`<samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>` 也对应于 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>` 方法的返回类型，这意味着 `<samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>`
    可以由 `<samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< TResult ></samp>`
    的实现来替代。`<samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>` 的构造函数接受一个
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>` 参数，因此传递的参数必须是 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp>` 的实现，且 `<samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>`
    必须与 `<samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>` 的 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>` 参数的类型一致。'
- en: For simplicity, the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    constructor takes a sequence of string values to represent the input values, but
    in a real application, <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    might be obtaining its data from a database or more elaborate source.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为简化起见，`<samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>` 的构造函数接受一系列字符串值作为输入值，但在实际应用中，`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>` 可能是从数据库或更复杂的数据源获取数据。
- en: The interface type constraint on the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    generic type parameter enables us to call <samp class="SANS_TheSansMonoCd_W5Regular_11">parser.Parse</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> method, which
    returns a sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>
    elements. Without the <samp class="SANS_TheSansMonoCd_W5Regular_11">where</samp>
    constraint for <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> method would fail to
    compile because <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> has
    no <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> method.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对 <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> 泛型类型参数的接口类型约束使得我们可以在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> 方法中调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">parser.Parse</samp>，该方法返回一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> 元素的序列。如果没有 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">where</samp> 约束来限制 <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>，则
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> 方法将无法编译，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    类型没有 <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> 方法。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp> interface
    in [Listing 7-20](#list7-20) isn’t intended to be used as the type of a variable;
    rather, it’s a contract interface whose purpose is to describe the *protocol*
    for parsing a string into an object. We even use <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    as the type of a field in the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    class rather than declaring the field as <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    T ></samp>.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7-20](#list7-20) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    T ></samp> 接口并非用于作为变量类型；相反，它是一个契约接口，其目的是描述解析字符串为对象的*协议*。我们甚至在 <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    类中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> 作为字段类型，而不是声明字段为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp>。'
- en: The presence of the constraint on the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    generic parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    means that we can create a <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    only by providing an implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    T ></samp> protocol. The constraint guarantees that whatever type is substituted
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> at run time will
    have a <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> method whose
    signature matches the operation defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    T ></samp> interface.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对 <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> 泛型参数的约束存在于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> 中，意味着我们只能通过提供 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp> 协议的实现来创建一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>。该约束保证了在运行时为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> 替代的任何类型都会有一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> 方法，其签名与 <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    T ></samp> 接口中定义的操作相匹配。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing the IParser<T>
    Protocol</samp>
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">实现 IParser<T> 协议</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp> interface
    is itself generic, allowing an implementing type to specify the return type from
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> method. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> class in [Listing 7-22](#list7-22)
    implements <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< Color></samp>
    to convert a string to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    object. In this example, the input string represents each color component as a
    two-digit hexadecimal value, so the entire value is in the format <samp class="SANS_TheSansMonoCd_W5Regular_11">"RRGGBB"</samp>.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp> 接口本身是泛型的，允许实现的类型指定
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> 方法的返回类型。[示例 7-22](#list7-22)
    中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> 类实现了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IParser< Color></samp> 接口，将一个字符串转换为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 对象。在此示例中，输入字符串表示每个颜色组件的两位十六进制值，因此整个值的格式为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"RRGGBB"</samp>。
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-22: Implementing
    a contract interface</samp>'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 7-22：实现一个契约接口</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> method of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> class uses the
    range operator syntax, introduced in C# v8.0, on the <samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp>
    parameter to split the string into three parts of two characters each. A range
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">[begin..end]</samp>, also called
    a *slice*, specifies a substring from the <samp class="SANS_TheSansMonoCd_W5Regular_11">begin</samp>
    index up to but not including the <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp>
    index. Ranges can also be used with arrays to specify a subrange of the array.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> 类的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp>
    方法使用了 C# v8.0 中引入的范围操作符语法，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp>
    参数上将字符串拆分为三个部分，每部分两个字符。像 <samp class="SANS_TheSansMonoCd_W5Regular_11">[begin..end]</samp>
    这样的范围，也叫做 *切片*，表示从 <samp class="SANS_TheSansMonoCd_W5Regular_11">begin</samp>
    索引开始，到但不包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp> 索引。范围还可以与数组一起使用，指定数组的子范围。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*A* range *is a half-open interval of indices and would more properly be written
    [begin..end), but C# syntax doesn’t allow nonmatching brackets or parentheses.
    Be careful not to confuse this syntax with the Enumerable.Range method, which
    takes the starting index and a count of items to include as its parameters.*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个* 范围 *是一个半开区间，应该更准确地写为 [begin..end)，但 C# 语法不允许不匹配的括号或圆括号。请小心不要将此语法与 Enumerable.Range
    方法混淆，该方法接受起始索引和要包括的项数作为参数。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Parameterizing the DataAdapter
    Class</samp>
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">为 DataAdapter 类参数化</samp>
- en: Since <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> implements
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp> interface,
    we can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> class,
    as shown in [Listing 7-23](#list7-23).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> 实现了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp> 接口，我们可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp>
    与 <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> 类一起使用，如 [列表
    7-23](#list7-23) 所示。
- en: '[PRE26]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-23: Using the generic
    type</samp>'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 7-23：使用泛型类型</samp>
- en: While the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> class
    itself is written in a polymorphic way (inasmuch as it works on any type implementing
    the required <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp>
    protocol), using it requires us to explicitly indicate the concrete type we’re
    substituting for both the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    parameter and the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>
    parameter type to be returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>
    method.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> 类本身是以多态的方式编写的（因为它可以处理任何实现了所需的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp> 协议的类型），但使用它时我们需要显式指定我们为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> 参数和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>
    方法返回的 <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> 参数类型所替代的具体类型。
- en: 'This prevents us from accidentally using <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> parameter
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> along with
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> class like
    this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以防止我们不小心将 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    用作 <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>
    参数，并与 <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> 类一起使用，像这样：
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> class
    is specific to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> types
    because it implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    Color></samp> interface. The compiler will catch such transgressions and report
    an error:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> 类是专门针对 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 类型的，因为它实现了 <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    Color></samp> 接口。编译器会捕捉到这种违规行为并报告错误：
- en: '[PRE28]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> generic
    parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    is already implied by the concrete type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    T ></samp> implementation we provide, as it must be the same type that’s returned
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">.Parse</samp>. The type constraint we
    used for the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> generic
    parameter for <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    in [Listing 7-21](#list7-21) makes this relationship explicit:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，<samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> 的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> 泛型参数已经由我们提供的具体 <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    T ></samp> 实现的类型隐式地指定，因为它必须与 <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    T</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.Parse</samp>
    返回的类型相同。我们在 [Listing 7-21](#list7-21) 中为 <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    的 <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> 泛型参数使用的类型约束使这种关系变得明确：
- en: '[PRE29]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since we’ve gone to the trouble of ensuring that the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    class can work with any <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    T ></samp> implementation, having to specify which implementation we mean seems
    superfluous. Instead, we can have the compiler deduce the correct type for the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> parameter based on
    the actual type we use.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经费尽心思确保 <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    类可以与任何 <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp> 实现一起工作，因此指定我们指的哪种实现似乎是多余的。相反，我们可以让编译器根据实际使用的类型推导出
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> 参数的正确类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generic Method Parameters
    and Type Deduction</samp>
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">泛型方法参数和类型推导</samp>
- en: Although the compiler doesn’t infer the actual type for any parameters of a
    generic class, it may do so for a generic method if a generic parameter type is
    used in the method’s formal parameters. Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    type parameter is used only by the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter.Read</samp>
    method, we can move it from the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    class and add it instead to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>
    method, making <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> a generic
    method, as shown in [Listing 7-24](#list7-24).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编译器不会为任何泛型类的参数推导实际类型，但如果泛型参数类型在方法的形式参数中使用，它可以为泛型方法推导类型。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    类型参数仅被 <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter.Read</samp> 方法使用，我们可以将其从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> 类中移除，并将其添加到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> 方法中，使 <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>
    成为一个泛型方法，如 [Listing 7-24](#list7-24) 所示。
- en: '[PRE30]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-24: Defining DataAdapter.Read
    as a generic method</samp>'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-24: 将 DataAdapter.Read
    定义为泛型方法</samp>'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> no longer
    needs a field to store a <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    object since it’s passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>
    method. The generic method still requires the interface constraint so that we
    can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> method
    via the <samp class="SANS_TheSansMonoCd_W5Regular_11">parser</samp> variable,
    but we don’t need to specify the type of the parser argument when passing it;
    the compiler infers the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    based on the argument we pass to <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>,
    as shown in [Listing 7-25](#list7-25).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> 不再需要一个字段来存储
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> 对象，因为它已经被传递到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> 方法中。泛型方法仍然要求接口约束，以便我们能够通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">parser</samp> 变量调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp>
    方法，但在传递时我们不需要指定解析器参数的类型；编译器根据传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>
    的参数推断 <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> 的类型，如 [Listing
    7-25](#list7-25) 所示。
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-25: Parameter type
    inference</samp>'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: <sup class="SANS_Futura_Std_Book_Oblique_I_11">列表 7-25：参数类型推断</sup>
- en: We mention the <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp>
    type just once, when we create an instance of it to pass to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>
    method. Compare this with [Listing 7-23](#list7-23), where we not only required
    an instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp>
    but also needed to specify its type for the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>.
    By taking advantage of the type inference afforded by a generic method, we avoid
    the redundant code.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅在创建<sup class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</sup>实例并将其传递给<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Read</sup>方法时提到过<sup class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</sup>类型。将此与[列表
    7-23](#list7-23)进行对比，在那里我们不仅需要<sup class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</sup>的实例，还需要为<sup
    class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</sup>的<sup class="SANS_TheSansMonoCd_W5Regular_11">TParser</sup>参数指定其类型。通过利用泛型方法提供的类型推断功能，我们避免了冗余代码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parameterized Types</samp>
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <sup class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">参数化类型</sup>
- en: We still need to specify <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> parameter
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> in [Listing
    7-25](#list7-25), even though <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>
    is used only by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>
    method. The compiler can only infer the real type of a generic parameter from
    the arguments we pass to a method, and <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>
    isn’t used as the type for any parameter in <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>.
    If a method has generic parameters, they must all be either explicitly specified
    or deduced from the arguments; the compiler won’t partially deduce the types just
    from available arguments.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要为[列表 7-25](#list7-25)中的<sup class="SANS_TheSansMonoCd_W5Regular_11">TResult</sup>参数指定<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Color</sup>，即使<sup class="SANS_TheSansMonoCd_W5Regular_11">TResult</sup>仅由<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Read</sup>方法使用。编译器只能根据我们传递给方法的参数推断泛型参数的实际类型，而<sup
    class="SANS_TheSansMonoCd_W5Regular_11">TResult</sup>在<sup class="SANS_TheSansMonoCd_W5Regular_11">Read</sup>方法中并未作为任何参数的类型使用。如果一个方法有泛型参数，它们必须全部明确指定或从传递的参数中推断；编译器不会仅根据可用的参数部分推断类型。
- en: However, this is a benefit of the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    class, because it ensures that the <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp>
    matches the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> parameter
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>. If we want
    a different type to stand in for <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>,
    we need a different parser implementation. In [Listing 7-26](#list7-26), we implement
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp> interface
    in a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> type
    and create a <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    for the new type.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是<sup class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</sup>类的一个好处，因为它确保了<IParser<
    T >`的<sup class="SANS_TheSansMonoCd_W5Regular_11">T</sup>参数与<sup class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</sup>的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">TResult</sup>参数匹配。如果我们想用不同的类型替代<sup class="SANS_TheSansMonoCd_W5Regular_11">TResult</sup>，我们需要一个不同的解析器实现。在[列表
    7-26](#list7-26)中，我们在一个<sup class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</sup>类型中实现了<sup
    class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></sup>接口，并为新的类型创建了一个<sup class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</sup>。
- en: '[PRE32]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-26: Parameterizing
    DataAdapter with a different type</samp>'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: <sup class="SANS_Futura_Std_Book_Oblique_I_11">列表 7-26：使用不同类型参数化DataAdapter</sup>
- en: We specify <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> to implement
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp> in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColorParser</samp> class, and
    we specify <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    as the type for the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>
    parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColorParser</samp>
    implementation uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp>
    object to parse the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    portion of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    as a convenience, but otherwise it’s an entirely new type. Similarly, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter< TranslucentColor></samp>
    type is unrelated to <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter<
    Color></samp>.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColorParser</samp>
    类中实现 <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp> 时，指定了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>，并且我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 作为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>
    参数的类型。<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColorParser</samp>
    的实现使用了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> 对象来解析
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 部分，作为一种便利，但除此之外，它是一个完全新的类型。类似地，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter< TranslucentColor></samp>
    类型与 <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter< Color></samp> 无关。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> class is
    polymorphic according to the type we provide as an argument for its <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>
    parameter because that type affects what the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>
    method returns. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>
    method is itself polymorphic, as it has its own generic parameter. We need to
    write the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> method only
    once, and it works for any type that implements <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    T ></samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> matches
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> type of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> 类是多态的，具体取决于我们作为参数传递给其
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> 参数的类型，因为该类型影响 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> 方法的返回值。<samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>
    方法本身也是多态的，因为它有自己的泛型参数。我们只需要编写一次 <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>
    方法，它适用于任何实现了 <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp>
    的类型，其中 <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> 与 <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    的 <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> 类型匹配。
- en: We can think of a generic method as representing multiple method overloads,
    each with different parameter types but all having an identical implementation.
    Even without generics, overloaded methods represent their own kind of polymorphism,
    known as *ad hoc polymorphism*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将泛型方法看作是表示多个方法重载，每个重载具有不同的参数类型，但都具有相同的实现。即使没有泛型，重载方法也代表了一种特殊的多态性，称为*临时多态性*。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Ad Hoc Polymorphism with Overloading</samp>
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">临时多态性与方法重载</samp>
- en: Ad hoc polymorphism, or *method overloading*, is how we define a family of operations
    that have the same name but differ in the type or number of their parameters.
    The compiler selects the correct method overload based on the method name and
    the arguments we use to call it. Each method can have a different implementation,
    so the method *name* is polymorphic with respect to its parameters.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 临时多态性，或称为*方法重载*，是我们定义一组具有相同名称但在参数的类型或数量上有所不同的操作的方式。编译器根据方法名称和我们调用方法时使用的参数来选择正确的方法重载。每个方法可以有不同的实现，因此方法的*名称*在参数上是多态的。
- en: You’ve seen a few examples of overloading instance methods in this and other
    chapters, where we’ve overridden the virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method and then overloaded it with a type-safe implementation. The compiler will
    select the type-safe overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    if the static type of the argument matches the implementing type rather than being
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> or another type.
    In a record struct, the compiler provides implementations for both methods, although
    we can provide our own type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    if we wish. [Listing 7-27](#list7-27) shows how using different arguments changes
    which method is called when the variables being compared are value types.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章及其他章节中，你已经看过了一些重载实例方法的例子，我们重写了虚拟的<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法，然后用类型安全的实现重载了它。如果参数的静态类型与实现类型匹配，而不是一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp>或其他类型，编译器将选择类型安全的<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>重载。在记录结构体中，编译器为这两个方法提供了实现，尽管如果需要，我们可以提供自己的类型安全的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法。[清单 7-27](#list7-27)展示了使用不同参数如何改变在比较变量是值类型时调用的方法。
- en: '[PRE33]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-27: Selecting method
    overloads</samp>'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-27：选择方法重载</samp>
- en: The first assertion, which compares the <samp class="SANS_TheSansMonoCd_W5Regular_11">plum</samp>
    variable with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, will
    call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method override
    with an <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> parameter
    because <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> is a reference
    type, and <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> will automatically
    convert to a reference parameter. In the second assertion, the method taking a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> as its parameter is
    a better match for the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp>
    argument because the types match exactly, so the type-specific overload is called.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> were a record instead
    of a record struct, both assertions would directly invoke the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Color)</samp>
    overload, since in that case <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    would be a reference type but a more specific one than <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>,
    making it a better conversion target for overload resolution when the argument
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个断言比较<samp class="SANS_TheSansMonoCd_W5Regular_11">plum</samp>变量与<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，将调用带有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">object?</samp>参数的<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法重载，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp>是引用类型，且<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>会自动转换为引用参数。在第二个断言中，接受<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>作为参数的方法更适合另一个参数，因为类型完全匹配，因此调用了特定类型的重载。如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>是记录而不是记录结构体，那么这两个断言将直接调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals(Color)</samp>重载，因为在这种情况下<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>将是引用类型，但比<samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp>更为具体，使其成为重载解析时更好的转换目标，尤其当参数为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>时。
- en: When we call an overloaded instance method, the compiler identifies the candidate
    methods by using the static type of the variable used to invoke the method. The
    candidate methods may include extension methods with the same name if they’re
    in scope where the method is called. It’s always the invoking variable that determines
    how the list of possible overloads is selected, and the arguments passed determine
    the specific overload from that candidate list. In [Listing 7-28](#list7-28),
    we change the static type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">plum</samp>
    variable to be <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> instead
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> before calling its
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用一个重载的实例方法时，编译器通过使用调用方法的变量的静态类型来识别候选方法。如果在方法调用的作用域内存在同名的扩展方法，候选方法中也可能包括这些扩展方法。始终是调用变量决定了如何选择可能的重载方法列表，而传递的参数则决定了从候选列表中选择哪个具体的重载方法。在[列表
    7-28](#list7-28)中，我们在调用<sup class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法之前，将<sup
    class="SANS_TheSansMonoCd_W5Regular_11">plum</samp>变量的静态类型从<sup class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>改为<sup
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp>。
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-28: Argument type
    versus invoking type</samp>'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 7-28：参数类型与调用类型</samp>
- en: 'The candidates for <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    are selected from the methods defined on <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    because that’s the compile-time type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">plum</samp>
    variable. We have only one such method, which takes a parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp>,
    so that’s automatically a match, even though the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp>
    argument is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">plum</samp> is still a reference
    to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> that has an overloaded
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method taking a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> parameter. The same would
    be true if <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> were a reference
    type: the type-specific overload isn’t even considered during overload resolution
    because it’s not a member of the type of the variable used to call the method.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法的候选方法是从<sup class="SANS_TheSansMonoCd_W5Regular_11">object</samp>上定义的方法中选择的，因为那是<sup
    class="SANS_TheSansMonoCd_W5Regular_11">plum</samp>变量的编译时类型。我们只有一个这样的重载方法，它接受一个<sup
    class="SANS_TheSansMonoCd_W5Regular_11">object?</samp>类型的参数，因此这自动成为匹配项，即使<sup
    class="SANS_TheSansMonoCd_W5Regular_11">其他</sup>参数是<sup class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>类型，并且<sup
    class="SANS_TheSansMonoCd_W5Regular_11">plum</samp>仍然是一个指向<sup class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>的引用，该类型有一个重载的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法，接受<sup class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>参数。如果<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>是引用类型，情况也相同：类型特定的重载在重载解析过程中不会被考虑，因为它不是用于调用该方法的变量类型的成员。
- en: Static methods can be overloaded too, although the candidate overloads are identified
    from the type name used by the caller. In either case, from this list of candidates,
    called a *method group*, the compiler chooses the best match according to the
    arguments being passed.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法也可以重载，尽管候选重载方法是通过调用者使用的类型名称来识别的。在这两种情况下，从这些候选方法中，称为*方法组*，编译器根据传递的参数选择最佳匹配项。
- en: If no match is found—that is, the arguments aren’t implicitly convertible to
    any of the parameter types—or there are multiple equally good candidates with
    no single best match, our program fails to compile.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到匹配项——也就是说，参数不能隐式转换为任何参数类型，或者有多个同样好的候选方法但没有明确的最佳匹配——我们的程序将无法编译。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Symbolic Polymorphism
    with Overloaded Operators</samp>
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用重载运算符的符号多态性</samp>
- en: Overloading can be especially powerful in conjunction with custom operators.
    It’s common for value types to overload <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    to correspond with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method. Not only is this more compact, but it also looks more natural to compare
    values with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> than to compare
    them by calling a method.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 重载在结合自定义运算符时尤其强大。值类型通常会重载 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>，以与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法对应。这样不仅更加简洁，而且用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> 比较值比通过调用方法来比较它们看起来更自然。
- en: 'We have to write our own operator implementations for structs, but the compiler
    provides <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> for records and record structs,
    making it convenient to compare two variables of the same type like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为结构体编写自己的运算符实现，但编译器为记录和记录结构体提供了 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp>，这使得比较同一类型的两个变量变得非常方便，如下所示：
- en: '[PRE35]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We’re not permitted to alter the implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> synthesized by the compiler for
    records and record structs, but we can add overloads of them to accept different
    types, just as we can with other methods. For instance, in [Listing 7-29](#list7-29),
    we overload <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> to permit comparisons
    between a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能修改编译器为记录（record）和记录结构体（record structs）合成的 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> 的实现，但我们可以为它们添加重载，以接受不同的类型，就像我们可以为其他方法添加重载一样。例如，在
    [Listing 7-29](#list7-29) 中，我们为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    重载了 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>，以便允许在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    之间进行比较。
- en: '[PRE36]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-29: Overloading operators</samp>'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-29: 重载运算符</samp>'
- en: 'We need to add a corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    for each overload (not shown here). These overloads are a convenience for users,
    who don’t need to explicitly construct <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances in order to compare them with their raw <samp class="SANS_TheSansMonoCd_W5Regular_11">RGB</samp>
    value and who can compare values like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为每个重载添加一个相应的 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>（此处未显示）。这些重载为用户提供了便利，用户无需显式地构造
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 实例即可将其与原始的 <samp class="SANS_TheSansMonoCd_W5Regular_11">RGB</samp>
    值进行比较，并且可以像这样进行比较：
- en: '[PRE37]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Overloading operators isn’t essentially different from overloading other methods,
    but rather than using named methods, we’re overloading *symbols* to behave in
    a polymorphic way with our types. A good example of symbolic polymorphism is embodied
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> class, which
    defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> symbol to mean
    concatenation rather than addition. This is a widely accepted convention familiar
    to most programmers.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 重载运算符本质上与重载其他方法没有太大区别，区别在于我们不是使用命名的方法，而是重载*符号*，使得这些符号能够以多态的方式与我们的类型一起工作。符号多态的一个好例子体现在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> 类中，它将 <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    符号定义为连接符而非加法符号。这是一个被大多数程序员广泛接受的约定。
- en: We should be cautious of introducing our own operations that don’t follow the
    usual rules. Overloading methods, and especially operators, requires careful thought
    and a hefty dose of what we might call “good taste.” Families of methods overloaded
    for different types give the impression of type substitutability by giving one
    common name to an operation that may be implemented differently for each type.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应谨慎引入那些不遵循常规规则的操作。方法重载，特别是运算符重载，需要仔细思考，并且需要一些我们可能称之为“良好品味”的东西。为不同类型重载的函数族，通过给操作一个通用名称，使得该操作对于每个类型可能有不同的实现，给人一种类型可替代性的印象。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> class doesn’t,
    for example, allow us to add a number with a string, for the simple reason that
    the type of the result may be misinterpreted: should <samp class="SANS_TheSansMonoCd_W5Regular_11">"5"</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp>
    be the same as <samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">"5"</samp>?
    The designers of the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    class decided to disallow either use to avoid any potential confusion.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>类不允许我们将数字与字符串相加，原因很简单，因为结果的类型可能会被误解：应该认为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">"5"</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">"5"</samp>是相同的吗？<samp
    class="SANS_TheSansMonoCd_W5Regular_11">string</samp>类的设计者决定不允许这两种用法，以避免任何潜在的混淆。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generic Delegates
    for Polymorphism</samp>
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">多态的泛型委托</samp>
- en: A *delegate* is a type that represents a method with a specific signature—the
    type and number of parameters—and a delegate object can be constructed from different
    methods as long as the signature matches the delegate type. Delegates are a central
    feature of the LINQ libraries; for example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    method takes a delegate parameter to represent the method for transforming one
    element of a sequence into a different type. We most commonly see lambdas being
    used as the arguments for methods with delegate type parameters, as shown in [Listing
    7-30](#list7-30).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*委托*是一种表示具有特定签名（即参数类型和数量）的方法的类型，并且只要签名与委托类型匹配，委托对象就可以从不同的方法构造。委托是LINQ库的核心特性；例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>方法接受一个委托参数，表示将序列中的一个元素转换为不同类型的方法。我们最常见的是看到lambda作为带有委托类型参数的方法的参数，如[清单7-30](#list7-30)所示。'
- en: '[PRE38]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-30: Passing a lambda
    for a delegate parameter</samp>'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单7-30：为委托参数传递lambda</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp> is an extension
    method for <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable< T ></samp>,
    and here we call it via the <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp>
    variable, passing a lambda to represent a method taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    parameter, since that’s the element type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp>
    sequence. The lambda is invoked for each element in the sequence and returns a
    hexadecimal representation of the value as a string formatted to <samp class="SANS_TheSansMonoCd_W5Regular_11">"RRGGBB"</samp>—the
    reverse operation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp>
    method defined in [Listing 7-22](#list7-22).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>是一个用于<IEnumerable<
    T >>的扩展方法，在这里我们通过< s   amp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp>变量调用它，并传递一个lambda表示一个接受<Color>参数的方法，因为<Color>是<
    s   amp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp>序列的元素类型。该lambda会为序列中的每个元素调用，并返回该值的十六进制表示，作为一个格式化为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">"RRGGBB"</samp>的字符串——这是[清单7-22](#list7-22)中定义的<
    samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp>方法的反向操作。
- en: Inline lambdas like the one in [Listing 7-30](#list7-30) are convenient but
    generally lack the flexibility offered by method overloads. For example, if we
    change the element type of <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp>
    to be <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> instead
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, our code still
    compiles, and the lambda implementation will continue to work with the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    type defined in [Listing 7-18](#list7-18), but the result won’t have the extra
    2 bytes for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> property.
    We have to write a new lambda for <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>,
    and if we need to support both <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> elements,
    we have to handle them separately.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 像[列表 7-30](#list7-30)中那样的内联lambda表达式很方便，但通常缺乏方法重载所提供的灵活性。例如，如果我们将<samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp>的元素类型从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>更改为<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>，我们的代码仍然能够编译，并且lambda实现将继续与[列表
    7-18](#list7-18)中定义的<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>类型一起工作，但结果不会为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>属性额外占用2个字节。我们必须为<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>编写一个新的lambda表达式，如果我们需要同时支持<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>元素，我们就必须分别处理它们。
- en: Overloaded methods are a perfect way to capture the common purpose we need while
    simultaneously enabling us to encapsulate the different implementations required.
    Consider the two static methods in [Listing 7-31](#list7-31).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 重载方法是捕获我们需要的共同目的的完美方式，同时使我们能够封装所需的不同实现。请参考[列表 7-31](#list7-31)中的两个静态方法。
- en: '[PRE39]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-31: Overloaded methods
    for different types</samp>'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 7-31：用于不同类型的重载方法</samp>
- en: Notice that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format(TranslucentColor)</samp>
    method’s implementation calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format(Color)</samp>
    overload—something we couldn’t do with separate anonymous lambda expressions.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，<samp class="SANS_TheSansMonoCd_W5Regular_11">Format(TranslucentColor)</samp>方法的实现调用了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Format(Color)</samp>重载——这是我们无法通过单独的匿名lambda表达式来做到的。
- en: Rather than passing a lambda as the argument for <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>,
    we can pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format</samp> method
    group, as shown in [Listing 7-32](#list7-32).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将<sup><samp class="SANS_TheSansMonoCd_W5Regular_11">Format</samp>方法组作为参数传递给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>，而不是传递一个lambda表达式，如[列表 7-32](#list7-32)所示。
- en: '[PRE40]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-32: A method group
    as an argument</samp>'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 7-32：作为参数的方法组</samp>
- en: Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">Formatter.Format</samp>
    is the common name for two method overloads and represents a method group. The
    compiler selects the correct overload in the group based on the element type of
    the sequence used to call <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>.
    The delegate parameter for <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    is a generic delegate—that is, one that has its own generic type parameters. Like
    generic methods, the compiler will infer the actual types based on the arguments
    passed to the delegate.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，<samp class="SANS_TheSansMonoCd_W5Regular_11">Formatter.Format</samp>是两个方法重载的通用名称，代表一个方法组。编译器根据用于调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>的序列元素类型，选择方法组中的正确重载。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>的委托参数是一个泛型委托，也就是说，它有自己的泛型类型参数。像泛型方法一样，编译器会根据传递给委托的参数推断出实际的类型。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Formatter.Format</samp> method
    group is polymorphic according to the arguments that are passed by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    method internally. Here, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format(TranslucentColor)</samp>
    method from [Listing 7-31](#list7-31) is called because the element type of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp> sequence is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>. If we changed
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp> variable to be
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">List< Color></samp> instead, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp> method would call
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Format(Color)</samp>, but without
    us needing to change the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    expression in any way.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Formatter.Format</samp> 方法组根据传递给内部
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp> 方法的参数具有多态性。在这里，由于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp> 序列的元素类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>，所以调用了
    [清单 7-31](#list7-31) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Format(TranslucentColor)</samp>
    方法。如果我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp> 变量改为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">List< Color></samp>，则 <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    方法将调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Format(Color)</samp>，但我们无需以任何方式更改
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp> 表达式。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Coercion Polymorphism Using Conversions</samp>
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用转换的强制多态性</samp>
- en: As you’ve seen, inheritance allows us to use a reference to an instance of one
    type when a different type is expected, as long as the first type inherits from
    the second type. A derived class is syntactically substitutable for its base class
    because there’s a natural implicit conversion from a specific type to any of its
    parent types.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，继承允许我们在需要不同类型时，使用某种类型的实例作为引用，只要第一个类型继承自第二个类型。派生类在语法上可以替代其基类，因为从特定类型到任何父类类型都有一个自然的隐式转换。
- en: We can implement our own type conversions to mimic substitutability between
    two otherwise unrelated types. Casting—or *coercing*—a variable to a different
    type can be convenient, whether via implicit or explicit conversions, but doing
    so may mask problems beneath the surface. However, applied carefully, conversions
    between unrelated types can be an effective and concise way to express a design.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现自己的类型转换，以模拟两个本无关类型之间的可替换性。将变量转换（或 *强制*）为不同的类型是方便的，无论是通过隐式转换还是显式转换，但这样做可能会掩盖表面下的问题。然而，谨慎应用时，不相关类型之间的转换可以成为表达设计的一种有效且简洁的方式。
- en: To demonstrate some of the problems with implicit conversions that we haven’t
    yet explored, [Listing 7-33](#list7-33) implements an implicit conversion operator
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> to convert
    an instance to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示一些我们尚未探索的隐式转换问题，[清单 7-33](#list7-33) 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    中实现了一个隐式转换运算符，将实例转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    类型。
- en: '[PRE41]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-33: Implicit conversion
    operator</samp>'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-33：隐式转换运算符</samp>
- en: 'The conversion operator in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    is an *outward* conversion: we’re converting from an instance of the implementing
    type to something else. It will allow us to call a method expecting a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    value when we have a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    at hand, as we do when we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaColor</samp>
    method in [Listing 7-34](#list7-34).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 中的转换运算符是一个
    *外向* 转换：我们将一个实现类型的实例转换为其他类型。这将允许我们在拥有一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    实例时，调用一个期望 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 类型值的方法，就像我们在调用
    [清单 7-34](#list7-34) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaColor</samp>
    方法时一样。
- en: '[PRE42]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-34: Implicit conversions
    in action</samp>'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-34：隐式转换的实际应用</samp>
- en: Owing to the implicit conversion operator, the <samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">blue</samp> variables are converted
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances when we
    pass them as arguments to the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaColor</samp>
    method. The conversion happens invisibly because the conversion operator is defined
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">implicit</samp>.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 由于隐式转换运算符，当我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">blue</samp> 变量作为参数传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaColor</samp>
    方法时，它们会被转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 实例。转换是隐式发生的，因为转换运算符被定义为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">implicit</samp>。
- en: We could achieve the same effect by defining an inward conversion operator on
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type taking a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> parameter. The
    difference is merely about where we choose to define the operator. Since <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> already depends
    on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> otherwise has no knowledge
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>, the
    outward conversion defined in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    makes better sense here.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 类型上定义一个内部转换运算符，接收一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 参数，从而实现相同的效果。不同之处仅在于我们选择在哪里定义运算符。由于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 已经依赖于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 类型，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    对 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 没有任何了解，因此在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 中定义的外部转换更为合理。
- en: However, we must be careful with all conversions, especially implicit ones.
    As you saw in [Chapter 1](chapter1.xhtml), implicit conversions may hide complexity
    and can even lead to undesired behavior. A user-defined coercion is not quite
    the same as the implicit reference conversion from a derived type to its base
    type.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们必须小心所有的转换，特别是隐式转换。正如你在 [第 1 章](chapter1.xhtml) 中看到的，隐式转换可能会隐藏复杂性，甚至导致不希望发生的行为。用户定义的强制转换与从派生类型到基类型的隐式引用转换并不完全相同。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Widening vs. Narrowing
    Conversions</samp>
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">扩展转换与缩小转换</samp>
- en: When <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> inherited
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, we could pass
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> reference
    to a method expecting a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>,
    but it was still a reference to the same instance of a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>,
    and only a copy of the reference would be made. In [Listing 7-33](#list7-33),
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> are record structs and therefore
    value types. When we invoke the conversion operator of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>,
    we’re simply creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instance, so the copy has lost some of the information specific to <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>—namely,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> property.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 继承自
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 时，我们可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    引用传递给一个期望 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 的方法，但它仍然是对同一
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 实例的引用，只会复制引用。在
    [列表 7-33](#list7-33) 中，<samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 是记录结构体，因此是值类型。当我们调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 的转换运算符时，我们只是创建了一个新的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 实例，因此复制操作丢失了某些特定于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 的信息——特别是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> 属性。
- en: 'A conversion from a derived class reference to a base class reference is a
    *widening* conversion. We can refer to a specific instance by using a more general
    (base) type, but no loss of information occurs. We’re still able to explicitly
    cast the base class reference back to the original derived instance, although
    that’s a relatively expensive run-time operation. Our implicit conversion from
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> struct
    to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> via our own operator
    method is *narrowing*: neither type is really more specific or general than the
    other, and they’re independent values, but the act of conversion loses information.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 从派生类引用到基类引用的转换是 *拓宽* 转换。我们可以使用更通用的（基类）类型引用特定的实例，但不会丢失信息。我们仍然可以显式地将基类引用转换回原始的派生实例，尽管这是一个相对昂贵的运行时操作。从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 结构体到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 的隐式转换通过我们自己的运算符方法是 *缩窄* 转换：两者类型并没有真正的上下级关系，它们是独立的值，但转换的过程会丢失信息。
- en: While we’ve replicated the behavior of converting from a derived class to a
    base class, it doesn’t give us the same flexibility. The converted value really
    *is* just a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, and we
    need other means of capturing the extra properties of a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    if we need to reinstate them.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已复制了从派生类到基类的转换行为，但这并没有给我们带来相同的灵活性。转换后的值确实 *就是* 一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>，如果需要恢复其额外的属性，我们需要其他方式来捕获
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 的额外属性。
- en: Conversions aren’t appropriate for trying to replicate the characteristics of
    inheritance, but they can be useful for other scenarios.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 转换不适合用来复制继承的特性，但它们在其他场景下可能是有用的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">For Representation</samp>
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">用于表示</samp>
- en: Conversions between unrelated types make more sense when the types have a common
    meaning with different representation. For instance, we might need to use an external
    API that uses the common <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    representation of the hexadecimal RGB value of colors. Changing a value’s representation
    is usually better implemented as an explicit rather than implicit conversion,
    as shown in [Listing 7-35](#list7-35). However, any conversions—whether explicit
    or implicit—require careful consideration of alternate approaches.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型具有相同的含义但不同的表示形式时，进行无关类型之间的转换更有意义。例如，我们可能需要使用一个外部 API，该 API 使用常见的 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    表示颜色的十六进制 RGB 值。改变值的表示通常更适合通过显式转换而非隐式转换来实现，如 [Listing 7-35](#list7-35) 所示。然而，任何转换——无论是显式的还是隐式的——都需要仔细考虑其他的替代方法。
- en: '[PRE43]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-35: Converting to
    a different type representation</samp>'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-35: 转换为不同的类型表示</samp>'
- en: In [Listing 7-36](#list7-36), we test the explicit conversion operator’s implementation
    by casting the <samp class="SANS_TheSansMonoCd_W5Regular_11">plum</samp> value
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in order to pass it
    as an argument for a method taking an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    parameter.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Listing 7-36](#list7-36) 中，我们通过将 <samp class="SANS_TheSansMonoCd_W5Regular_11">plum</samp>
    值转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，来测试显式转换运算符的实现，以便将其作为参数传递给一个接受
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型参数的方法。
- en: '[PRE44]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-36: Testing an explicit
    conversion</samp>'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-36: 测试显式转换</samp>'
- en: 'This local <samp class="SANS_TheSansMonoCd_W5Regular_11">Converted</samp> function
    takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> parameter and,
    for the purposes of the test, simply returns its parameter value. Since the conversion
    operator is explicit, we must cast the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    value when we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Converted</samp>
    method; the compiler will complain if we try to use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    value directly as an argument for <samp class="SANS_TheSansMonoCd_W5Regular_11">Converted</samp>.
    The compiler will also catch any unintentionally inappropriate expressions like
    this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个本地的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Converted</samp> 函数接收一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 参数，并且为了测试的目的，它仅仅返回这个参数的值。由于转换运算符是显式的，我们在调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Converted</samp> 方法时必须强制转换 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 值；如果我们尝试直接将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    值作为参数传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">Converted</samp>，编译器会报错。编译器还会捕捉到任何这种无意中的不合适表达：
- en: '[PRE45]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If we had made the conversion operator implicit in <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>,
    this code would compile but would compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    values, probably with unexpected results.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 中的转换运算符改为隐式，这段代码会编译通过，但会比较两个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 值，结果可能会是意外的。
- en: The cast to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in [Listing
    7-36](#list7-36), while explicit and obvious in the code, doesn’t say much about
    the intention behind the conversion, which is implied to some extent by the use.
    We might consider replacing an explicit outward conversion like this with a method
    or property that more definitively describes the intent of the conversion, perhaps
    by calling it <samp class="SANS_TheSansMonoCd_W5Regular_11">ToWebColor</samp>.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 7-36](#list7-36) 中对 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    的强制转换，虽然在代码中是显式且明显的，但并没有表达出转换背后的意图，这一点在某种程度上通过使用的方式得到了暗示。我们或许可以考虑用一个方法或属性来替代这种显式的外部转换，更加明确地描述转换的意图，可能将其命名为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ToWebColor</samp>。
- en: Naming the conversion allows us to better express what we mean and why, making
    the code more self-documenting without being overly intrusive or syntax-heavy
    compared to an explicit cast. One frequently overlooked consequence of using a
    named property instead of a cast is that the property name is easier to search
    for, should we need to find everywhere it’s used.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 命名转换使我们能够更好地表达我们想要的含义和原因，从而使代码更加自我文档化，同时又不会像显式强制转换那样过于侵入或冗长。使用命名属性而不是强制转换经常被忽视的一个后果是，属性名称更容易被搜索到，这样我们就可以方便地找到它在何处被使用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">For Purpose</samp>
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">用途</samp>
- en: Conversion operators, even implicit conversions, aren’t exclusively a bad choice.
    Conversions are commonly used to allow a value to be represented by unrelated
    types that support different operations, although the value itself has a common
    representation. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    is an immutable value type, but we might want to build up its value incrementally.
    A <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> has multiple properties,
    and sometimes setting them individually might be more convenient than setting
    them all at once in a constructor.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 转换运算符，即使是隐式转换，也并不一定是一个坏选择。转换通常用于允许一个值由支持不同操作的无关类型表示，尽管这个值本身有一个共同的表示形式。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 是一个不可变的值类型，但我们可能希望逐步构建它的值。一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 有多个属性，有时候单独设置它们比在构造函数中一次性设置所有属性更为方便。
- en: Rather than compromising the immutable nature of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    by adding <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessors for
    its properties, we introduce a new companion type that looks very much like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, except that it allows its
    properties to be changed. When the values are in their final state, we can then
    materialize an instance of the mutable type into an immutable <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
    Key to this is that we can easily convert from the companion type to the target
    value type. [Listing 7-37](#list7-37) shows such a *mutable companion* type for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> that allows an implicit
    conversion to the immutable target value.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不通过为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 的属性添加 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">set</samp> 访问器而破坏其不可变性，我们引入了一种新的伴随类型，它与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 非常相似，唯一不同的是它允许更改其属性。当值处于最终状态时，我们可以将可变类型的实例转化为不可变的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>。关键在于我们可以轻松地从伴随类型转换到目标值类型。[列表
    7-37](#list7-37) 展示了这种*可变伴随对象*类型，它允许隐式转换到不可变的目标值。
- en: '[PRE46]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-37: A mutable companion
    for Color</samp>'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 7-37：Color 的可变伴随对象</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp> type isn’t
    itself a value type; its sole purpose is to provide a kind of factory for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp> 类型本身不是一个值类型；它唯一的目的是为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 值提供一种工厂机制。
- en: Applications of the *Mutable Companion* pattern are fairly common, and we see
    it in the Standard Library with <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">StringBuilder</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">string</samp> type is immutable, and when
    we need to build up a <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    variable from several parts, using its mutable companion, <samp class="SANS_TheSansMonoCd_W5Regular_11">StringBuilder</samp>,
    is efficient. When we’ve finished “building” the string, we turn it into its *immutable*
    state.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '*可变伴随对象* 模式的应用相当常见，我们在标准库中看到过 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">StringBuilder</samp>。<samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    类型是不可变的，当我们需要从多个部分构建一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    变量时，使用其可变伴随对象 <samp class="SANS_TheSansMonoCd_W5Regular_11">StringBuilder</samp>
    是高效的。当我们“构建”完字符串后，将其转化为*不可变*状态。'
- en: Unlike with <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp>,
    we must call the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>
    method of <samp class="SANS_TheSansMonoCd_W5Regular_11">StringBuilder</samp> to
    turn it into a string, but an implicit conversion can be used to good effect here.
    Since <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp> is implicitly
    convertible to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, we
    can call a method taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    parameter with a <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp>
    value, as we see in [Listing 7-38](#list7-38), where we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">RelativeLuminance</samp>
    method with both a <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 与 <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp> 不同，我们必须调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">StringBuilder</samp> 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>
    方法将其转换为字符串，但这里可以很好地使用隐式转换。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp>
    可以隐式转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>，我们可以用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp> 的值调用一个接收 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    参数的方法，如 [列表 7-38](#list7-38) 所示，我们用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 值都调用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">RelativeLuminance</samp>
    方法。
- en: '[PRE47]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-38: Converting a
    companion type</samp>'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 7-38：转换伴随类型</samp>
- en: The implicit conversion operator we defined for <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp>
    in [Listing 7-37](#list7-37) permits us to pass the mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">builder</samp>
    variable as an argument to any method that expects a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
    Any code written for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances won’t be expecting to be able to use the mutating properties of the
    companion class, so the conversion is safe and convenient.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[清单 7-37](#list7-37)中为<samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp>定义的隐式转换操作符允许我们将可变的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">builder</samp>变量作为参数传递给任何期望接受<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>的函数。任何为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>实例编写的代码都不会期望使用伴生类的可变属性，因此这种转换是安全且方便的。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp> can be
    substituted for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> courtesy
    of the implicit conversion. No information is lost because the two types share
    a common representation; however, a narrowing of the interface occurs, because
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> target type has
    no <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessors for its
    properties.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp>可以通过隐式转换替代为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>。由于这两种类型共享相同的表示方式，因此没有信息丢失；然而，接口发生了缩小，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>目标类型没有属性的<samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>访问器。
- en: Conversions represent a form of polymorphism, as we explicitly allow a variable
    of one type to be coerced to a variable of a different but unrelated type. Like
    parametric polymorphism using generics, and ad hoc polymorphism with overloading,
    coercion polymorphism is a compile-time activity, in contrast to the dynamic,
    run-time characteristic of inclusion polymorphism using inheritance. Inclusion
    polymorphism is a powerful tool, but because the type relationships are resolved
    at run time, the compiler can’t identify many of the errors that may occur. When
    we improperly use generics, overloading, or coercions, we can rely on the compiler
    to tell us about most errors in our code.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 转换代表了一种多态性，因为我们显式地允许一个类型的变量被强制转换为另一种不相关类型的变量。像使用泛型的参数化多态性和通过重载实现的特定多态性一样，强制转换多态性是一种编译时活动，区别于通过继承实现的包含多态性，它是在运行时动态决定的。包含多态性是一个强大的工具，但由于类型关系是在运行时解决的，编译器无法识别可能发生的许多错误。当我们不正确地使用泛型、重载或强制转换时，可以依赖编译器来告诉我们代码中的大部分错误。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: '*Trying to outsmart a compiler defeats much of the purpose of using one.*'
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*试图聪明地对付编译器会削弱使用编译器的主要目的。*'
- en: ''
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Brian Kernighan and P.J. Plauger, *The Elements of Programming Style*
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —布赖恩·柯宁汉和P.J. 普劳杰，*《编程风格的元素》*
- en: 'Asking how to make value types behave correctly when used polymorphically is
    the wrong question: polymorphism itself takes many forms! Combining value types
    and inheritance can cause hard-to-diagnose errors, but inheritance is only one
    kind of polymorphism. The dynamic nature of inclusion polymorphism with virtual
    dispatch brings an expectation of type substitutability and doesn’t sit well with
    value-based equality.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 问如何使值类型在多态使用时表现正确是错误的问题：多态本身有许多形式！将值类型与继承结合使用可能会导致难以诊断的错误，但继承只是多态性的一种形式。通过虚拟调度实现的包含多态性的动态特性带来了类型替代的期望，而这种特性与基于值的相等性不兼容。
- en: Inheriting one type from another imposes a responsibility on the derived type
    to respect the contract established by the base class. Failing to uphold that
    contract can lead to undesirable behavior. One type is genuinely substitutable
    for another only if they share the same behavioral contract, which is something
    the compiler can’t enforce. It’s up to us, the programmers, to judge whether inheritance
    is appropriate. In the case of structs, it’s not even permitted, freeing us from
    that particular responsibility.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 从一种类型继承另一种类型会对派生类型施加责任，要求其遵守基类建立的契约。如果未能遵守该契约，可能会导致不良行为。只有当两种类型共享相同的行为契约时，一种类型才真正可以替代另一种类型，而这正是编译器无法强制执行的。是否使用继承是由我们程序员来判断的。对于结构体，甚至不允许继承，解放了我们对这种责任的承担。
- en: With records, we need to pay just as much attention to the base class contract
    as we do with classes. Although the compiler carefully crafts its implementation
    of equality to ensure that <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    behaves correctly for records, it doesn’t do the same for any of our own virtual
    and overridden methods in those types.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 对于记录类型，我们需要像对待类一样，关注基类的契约。尽管编译器精心设计了相等性的实现，确保<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>在记录类型中正确运行，但对于我们自己在这些类型中虚拟和重写的方法，它并没有做同样的处理。
- en: Records aren’t necessarily appropriate for everything, and as noted earlier,
    making <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> “just work”
    for values using inheritance is an incomplete solution to the wrong problem. In
    particular, records are reference types and thus subject to garbage collection.
    The implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    are all virtual, as is the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>
    property, and they all carry an associated cost. Records are a very compact way
    of declaring immutable value-like types, but programming is more than the amount
    of typing required of us.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类型并不一定适用于所有情况，正如前面提到的，使用继承让<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>对值类型“自动工作”是一个不完整的解决方案，解决了错误的问题。特别是，记录类型是引用类型，因此会受到垃圾回收的影响。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>的实现都是虚拟的，<samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>属性也是虚拟的，它们都带有相关的开销。记录类型是一种非常简洁的声明不可变值类型的方式，但编程不仅仅是我们输入的字符数量。
- en: 'Value types do combine much better with the other ways of representing polymorphic
    behavior: coercion, overloading, and generic. These three forms of polymorphism
    are static in nature; that is, they are resolved by the compiler. Although type
    parameters in generic classes and methods are resolved at run time, we must still
    provide compile-time guarantees about which operations those parameters support.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型与其他多态行为表示方式结合得更好：类型转换、重载和泛型。这三种多态形式是静态的；也就是说，它们由编译器解决。虽然泛型类和方法中的类型参数是在运行时解析的，但我们仍然必须提供关于这些参数支持哪些操作的编译时保证。
- en: It can be tempting to use inheritance in order to reuse code from a base class.
    This is a bad idea because inheriting a class implies that the base class can
    be substituted by the inheriting class, but it can be difficult to ensure that
    the base class’s behavioral characteristics are properly met. We can still reuse
    another type’s implementation by containing an instance of the type and using
    the contained instance privately to implement our new type.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承来重用基类的代码可能很有诱惑力。但这是一个坏主意，因为继承一个类意味着基类可以被继承类替代，但很难确保基类的行为特征得到正确满足。我们仍然可以通过包含一个类型的实例并私下使用这个实例来实现我们的新类型，从而重用另一个类型的实现。
- en: Inheriting from concrete types—that is, nonabstract classes—in general presents
    us with the challenges of respecting the contracts established by those base classes.
    When we override an abstract method or implement an interface, we don’t suffer
    from those issues because there is no base class implementation to respect. In
    those cases, we’re inheriting only the interface contract, which is much easier
    to uphold.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 从具体类型——即非抽象类——继承通常会给我们带来遵循基类契约的挑战。当我们重写一个抽象方法或实现一个接口时，我们不会遇到这些问题，因为没有基类实现需要遵守。在这些情况下，我们仅继承接口契约，这要更容易遵守。
- en: The moral of the story is that if we always implement true interfaces or inherit
    from fully abstract classes, the problems we’ve encountered in this chapter will
    never cause us difficulties. Correspondingly, we should seal any class or record
    that models a value type and ensure that it has no user-defined base types. We
    can still write code that behaves polymorphically with the value types we use
    and create, but we should express it differently by employing generics, overloading
    methods, and permitting type conversions.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事的道理是，如果我们总是实现真正的接口或继承完全抽象的类，那么本章中遇到的问题就永远不会给我们带来困难。相应地，我们应该封闭任何表示值类型的类或记录，确保它没有用户定义的基类型。我们仍然可以编写与我们使用和创建的值类型多态的代码，但应该通过使用泛型、重载方法和允许类型转换来以不同的方式表达。
