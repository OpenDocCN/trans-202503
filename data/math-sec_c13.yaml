- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Delivering Python Applications
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 交付Python应用程序
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Once you feel you’ve met the requirements for a minimum viable product, it’s
    time to focus on the delivery pipeline. A *delivery pipeline* defines how your
    users will get your application and any future updates. Truthfully, I tend to
    start my projects by defining these attributes, as they can make some development
    choices more or less advantageous. For example, if you decide to deploy your application
    to the cloud, saving the data as local files doesn’t make as much sense as it
    would if you plan to deliver your code as a local package. In this chapter, we’ll
    take a high-level look at four potential delivery pipelines. Each method has a
    deep pool of resource material to help you deliver your project, so I’ll focus
    on the important considerations, strengths, and weaknesses of each method.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你觉得自己已经达到了最小可行产品的要求，就该开始关注交付管道了。*交付管道*定义了用户如何获得你的应用程序及其未来的更新。说实话，我通常在项目开始时就定义这些属性，因为它们能让某些开发决策变得更有利或更不利。例如，如果你决定将应用程序部署到云端，将数据保存为本地文件就不像计划将代码作为本地包交付时那么有意义。在本章中，我们将高层次地了解四种潜在的交付管道。每种方法都有丰富的资源材料帮助你交付项目，因此我将重点介绍每种方法的重要考虑因素、优点和缺点。
- en: In addition to discussing the delivery aspects of each method, I’ll talk about
    the removal process. One part of an MVP that people often neglect is the uninstall
    capability. Having a good, clean uninstall function for your application is, in
    my opinion, one of the keys to being a good software vendor. The objective for
    your uninstaller should be to leave nothing behind for the user to clean up. As
    you’ll see, some methods make this easier than others.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除了讨论每种方法的交付方面，我还会谈论卸载过程。MVP（最小可行产品）中人们常常忽视的一个部分是卸载功能。我认为，拥有一个良好、干净的卸载功能是成为优秀软件供应商的关键之一。你的卸载程序的目标应该是让用户不需要做任何清理工作。如你所见，有些方法比其他方法更容易实现这一点。
- en: One major influence on which delivery method to choose is whether or not you
    plan to monetize access to the application, and how. For example, if you want
    to charge users a subscription fee, you probably want to skip to the sections
    “[Distributing with Cloud Microservices](#h1-502567c13-0003)” or “[Licensing with
    PyArmor](#h1-502567c13-0004),” both options that would allow you to define who
    has access to your application. The downside is that neither option is free, so
    if you don’t plan to charge for access to your application, it may be more cost-effective
    to distribute the application via GitHub using the setup script or prepackage
    the application with all the files needed to run the application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 选择交付方法的一个主要影响因素是你是否计划通过应用程序获利，以及如何获利。例如，如果你想向用户收取订阅费，你可能希望跳到“[通过云微服务分发](#h1-502567c13-0003)”或“[使用PyArmor授权](#h1-502567c13-0004)”这两个章节，它们都能让你定义谁可以访问你的应用程序。缺点是这两种选择都不是免费的，因此，如果你不打算对应用程序的访问收取费用，使用GitHub通过设置脚本分发应用程序，或预打包应用程序及其所需的所有文件可能会更具成本效益。
- en: Using Setup Scripts
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用设置脚本
- en: The simplest choice for distributing a Python application is to use a special
    configuration script named *setup.py*, which configures the underlying system
    with the libraries and supporting files necessary to run the code. You’ve probably
    run into this method if you’ve installed a Python module after manually downloading
    a GitHub repository. More generally speaking, installing code packaged using this
    method requires your users to install a library called setuptools, which handles
    the installation based on the structure you define in the setup script. You can
    learn more about the structure and options for the setup scripts by reading the
    PyPi documentation ([https://pythonhosted.org/an_example_pypi_project/setuptools.html](https://pythonhosted.org/an_example_pypi_project/setuptools.html)).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 分发Python应用程序最简单的选择是使用一个名为*setup.py*的特殊配置脚本，它为底层系统配置了运行代码所需的库和支持文件。如果你曾在手动下载GitHub仓库后安装过Python模块，那么你可能遇到过这种方法。更一般而言，使用这种方法打包的代码要求用户安装一个名为setuptools的库，它根据你在设置脚本中定义的结构来处理安装。你可以通过阅读PyPi文档了解有关设置脚本的结构和选项（[https://pythonhosted.org/an_example_pypi_project/setuptools.html](https://pythonhosted.org/an_example_pypi_project/setuptools.html)）。
- en: The major benefit to using this method is that you can get your project hosted
    on PyPi, which will then allow your users to install it simply using the pip tool.
    When you install a project from PyPi, the pip tool pulls the appropriate version
    of your project from a storage location you define (most often, a public GitHub
    repository, although there are other options as well). Your users won’t need to
    manually download repositories or run setup scripts, all of which is handled in
    the background.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法的主要好处是你可以将项目托管到PyPi，这样用户就可以通过pip工具轻松安装它。当你从PyPi安装一个项目时，pip工具会从你定义的存储位置拉取适当版本的项目（通常是一个公开的GitHub仓库，虽然也有其他选择）。用户无需手动下载代码库或运行设置脚本，这些都在后台处理。
- en: However, there are some definite drawbacks to this method. First, it’s very
    difficult to monetize the code. There are no controls to stop a user from copying
    the source code to another machine. There’s also no native way to remove the code
    once it’s installed, which means even if you found a way to monetize access, you’d
    be limited to charging a one-time fee for lifetime access. There would be no way
    to enforce something like a subscription plan. Second, the setup script relies
    on your users installing the application from the command line. This is fine if
    you expect your users to be familiar with that process, but this isn’t the best
    choice for delivering applications to the general population. Finally, installing
    an application this way makes changes to the user’s underlying system. It installs
    the packages and configures them. While this works most of the time, making any
    changes to a system runs the risk of corrupting something, colliding with existing
    files, and so on. If the user doesn’t install your application in an isolated
    virtual environment, there’s the very real risk of running into incompatible library
    versions with some other application the user installed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法也有一些明显的缺点。首先，利用这种方式很难对代码进行货币化。没有控制机制来阻止用户将源代码复制到其他机器上。也没有原生的方式来卸载已安装的代码，这意味着即使你找到了货币化的方式，也只能收取一次性费用，无法实施类似订阅计划的收费模式。其次，设置脚本依赖用户从命令行安装应用程序。如果你预期用户熟悉这个过程，这没问题，但对于普通用户来说，这并不是交付应用程序的最佳选择。最后，这种安装方式会对用户的底层系统进行更改，安装并配置软件包。虽然这种方式大多数情况下可以正常工作，但对系统进行任何更改都有可能导致损坏某些内容、与现有文件发生冲突等。如果用户没有在隔离的虚拟环境中安装应用程序，就会有很大的风险与用户安装的其他应用程序发生不兼容的库版本冲突。
- en: Removing applications installed with this method poses its own problems and
    usually requires the user to remove the requirements and other resources from
    their system. If you opt to go this route, I recommend pushing your users to use
    separate virtual environments. If the user hasn’t set up the application in an
    isolated virtual environment, trying to helpfully uninstall a dependency may break
    other applications on their system. On the other hand, if your users do install
    everything in its own virtual environment, uninstalling is as easy as deleting
    the environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法安装的应用程序在卸载时会遇到一些问题，通常需要用户从系统中移除相关依赖和其他资源。如果你选择这种方式，我建议让用户使用独立的虚拟环境。如果用户没有在隔离的虚拟环境中安装应用程序，试图帮助卸载依赖可能会破坏系统上其他应用程序的正常运行。另一方面，如果用户确实将所有内容都安装在自己的虚拟环境中，卸载就像删除环境一样简单。
- en: I recommend using the setup script method for open source applications and smaller
    projects that aren’t backed by the resources for a more complex delivery pipeline.
    You can deploy a module and setup script to PyPi in a matter of minutes once you
    have an account. Setup scripts are also a good entry point for understanding more
    complex deployments, like cloud services, because at some level, all these methods
    need a way to understand what dependencies must be present for the code to function.
    Overall, this is a solid delivery method every Python developer should be familiar
    with.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议对于开源应用程序和那些没有足够资源支持复杂交付管道的小型项目使用设置脚本方法。一旦你有了账户，你可以在几分钟内将模块和设置脚本部署到PyPi。设置脚本也是理解更复杂部署（如云服务）的一个良好入口点，因为在某种程度上，所有这些方法都需要了解代码运行所需的依赖关系。总体来说，这是每个Python开发者都应该熟悉的可靠交付方式。
- en: Packaging with Python Interpreters
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Python解释器进行打包
- en: The next option aims to address some of the shortcomings of the setup script
    method by taking some work off the user. The idea is to package the code, support
    files, and the Python interpreter to run it into a single archive that can be
    delivered to the user. The user then simply needs to extract the archive to a
    directory on their system and they’re ready to run the application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个选项旨在通过减少用户的工作量，解决设置脚本方法的一些缺点。其理念是将代码、支持文件和 Python 解释器打包到一个单独的档案中，并交付给用户。用户只需要将档案解压到他们系统中的一个目录，就可以准备好运行应用程序。
- en: This allows for better monetization than the setup script. By hosting the packaged
    application download behind a website, you can charge users for each new version
    or you can charge a monthly subscription fee to the site that includes access
    to the latest versions for download. There’s still nothing to stop a user from
    paying once and keeping that version forever, but they also have incentive to
    maintain their account for access to the latest features.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与设置脚本相比，这种方法能够带来更好的变现方式。通过将打包后的应用程序下载托管在网站后面，您可以向用户收取每个新版本的费用，或者您可以向该网站收取月度订阅费，其中包括对最新版本的下载访问权限。尽管没有任何东西可以阻止用户支付一次费用并永久保留该版本，但他们也有动机维持他们的账户，以便访问最新功能。
- en: To handle the packaging, I use PyInstaller, a free application to help collect
    the necessary files to make your program stand-alone, meaning able to run without
    configuring the underlying system. Packaging with this method is often called
    *freezing* an application because it collects a copy of the current version of
    all dependencies and the Python interpreter installed on the system, and then
    it packages them such that the included interpreter will use only those packaged
    libraries to operate. The advantage here is that you don’t need to worry about
    what version of a package is installed or whether it will conflict with other
    applications on the user’s machine. The disadvantage is that if you need to update
    one of the underlying libraries after freezing the application—for instance, to
    mitigate a security risk in one of the dependencies—it requires releasing a patch
    or a new build of the application for distribution. If a user doesn’t apply the
    patch or download the latest version (all too common), their system is left at
    risk.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理打包，我使用了 PyInstaller，这是一款免费的应用程序，帮助收集必要的文件，使您的程序独立运行，即无需配置底层系统即可运行。使用这种方法进行打包通常被称为*冻结*应用程序，因为它收集了系统中当前版本的所有依赖项和已安装的
    Python 解释器的副本，然后将它们打包，使得包含的解释器只会使用那些打包的库来运行。这里的优点是，您不需要担心安装了哪个版本的包，或者它是否会与用户机器上的其他应用程序发生冲突。缺点是，如果在冻结应用程序后需要更新其中一个底层库——例如，为了减少某个依赖项中的安全风险——就需要发布补丁或新的应用程序版本进行分发。如果用户没有应用补丁或下载最新版本（这种情况非常普遍），他们的系统就会面临风险。
- en: The other drawback is the size of most frozen applications. To make sure the
    internal code functions properly, the entire standard library is usually frozen
    along with the other dependencies. The large code base and the Python interpreter
    mean that even simple applications may end up being multiple megabytes. PyInstaller
    does what it can to minimize the bloat, and you can configure it to reduce the
    weight even further, but ultimately there will always be additional bloat with
    this method.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是大多数冻结应用程序的体积。为了确保内部代码正常运行，通常会将整个标准库与其他依赖项一起冻结。庞大的代码库和 Python 解释器意味着即使是简单的应用程序也可能最终达到几个兆字节。PyInstaller
    尽其所能来最小化冗余，并且您可以配置它以进一步减轻体积，但最终，使用这种方法时总会有额外的冗余。
- en: Like energy, complexity doesn’t just disappear. Taking the complexity off the
    user means putting it onto yourself. For the frozen delivery method to work, you’ll
    need to create a different package for each type of system you want to support.
    For example, you may end up with one package named *agp_linux64_amd.tar.gz* intended
    for users on a 64-bit Linux system that has an AMD, one named *agp_win64_intel.zip*
    intended for users who have 64-bit Windows running on an Intel platform, and so
    on. To package each of these, you need access to a copy of the underlying OS that
    can be used to package the system files. To run the application during development,
    I use VirtualBox with a copy of each OS as a virtual machine preconfigured with
    the proper dependencies and version of Python. I like this method because it allows
    me to automate the build process for several platforms at once using the VirtualBox-manager
    application and some custom scripting ([https://www.virtualbox.org/wiki/Documentation](https://www.virtualbox.org/wiki/Documentation)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 就像能量一样，复杂性并不会消失。将复杂性从用户身上转移到自己身上。为了使冻结交付方法有效，你需要为每种你想要支持的系统类型创建不同的包。例如，你可能最终会有一个名为*agp_linux64_amd.tar.gz*的包，适用于拥有
    AMD 处理器的 64 位 Linux 系统用户，另一个名为*agp_win64_intel.zip*的包，适用于在 Intel 平台上运行的 64 位 Windows
    用户，依此类推。为了打包每一个包，你需要访问一个操作系统副本，用于打包系统文件。在开发过程中，我使用 VirtualBox 配合每个操作系统的副本作为虚拟机，并预配置好合适的依赖项和
    Python 版本。我喜欢这种方法，因为它允许我通过 VirtualBox-manager 应用程序和一些自定义脚本来自动化多个平台的构建过程（[https://www.virtualbox.org/wiki/Documentation](https://www.virtualbox.org/wiki/Documentation)）。
- en: 'For Windows, you face a unique circumstance. At the time of writing, some of
    the necessary drivers are protected by Microsoft licenses. Redistributing these
    libraries within your application without paying a licensing fee could be a breach
    of the Microsoft terms of service, and may even result in you being held liable
    for any perceived loss of revenue. The caveat is that if the end user already
    has a copy of the libraries (as is usually the case), then sending them the application
    wouldn’t violate the Microsoft agreement. Suffice to say: when and how you can
    deliver a prepackaged Python application for Windows is a bit of a gray area.
    Don’t interpret this as legal advice; I am not a lawyer. I insist you consult
    with an attorney in your area who specializes in intellectual property disputes
    around technology licenses. They’ll be able to help you steer clear of any legal
    risks.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows，你面临一个独特的情况。在撰写本文时，一些必要的驱动程序受到微软许可证的保护。未经授权分发这些库到你的应用程序中，可能会违反微软的服务条款，甚至可能导致你因被认为造成收入损失而承担责任。需要注意的是，如果最终用户已经拥有这些库的副本（通常情况下是这样），那么将应用程序发送给他们就不会违反微软协议。可以说：何时以及如何为
    Windows 提供预打包的 Python 应用程序是一个灰色地带。不要将此解释为法律建议；我不是律师。我建议你咨询你所在地区专门从事技术许可证知识产权争议的律师，他们能够帮助你避免任何法律风险。
- en: Freezing your application might be a good choice if you want to deliver a stand-alone
    version of it for users. The benefit of a stand-alone project is that it’s easy
    to set up and remove from a machine—uninstalling can be as simple as deleting
    a folder. In a lot of cases, frozen applications can even be run from a USB storage
    device, meaning you can carry it with you anywhere, and you won’t need to install
    the code on a system to use it!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为用户提供独立版本的应用程序，冻结你的应用可能是一个不错的选择。独立项目的好处在于它易于设置和从机器上删除——卸载操作可以像删除一个文件夹一样简单。在很多情况下，冻结的应用程序甚至可以从
    USB 存储设备运行，这意味着你可以随身携带它，并且不需要在系统上安装代码就能使用！
- en: Distributing with Cloud Microservices
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用云微服务进行分发
- en: Deploying to the cloud means different things for different people. You could
    argue that hosting the packages from the previous messages using some data storage
    service (like Amazon’s S3 or Google’s Cloud Storage) and hosting the website in
    a virtual machine served by the same vendor constitutes a cloud deployment. It’s
    true that the delivery pipeline is a cloud service at that point, but the application
    itself would still be downloaded and run locally by the user, so I don’t consider
    it a true cloud service.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 部署到云端对不同的人来说意义不同。你可以认为使用某些数据存储服务（例如亚马逊的 S3 或谷歌的云存储）托管前面消息中的包，并在同一供应商提供的虚拟机中托管网站，构成了一种云部署。的确，在那个时候，交付管道是云服务，但应用程序本身仍然会被用户下载并在本地运行，所以我不认为这是一种真正的云服务。
- en: To me, a cloud deployment runs the majority of its functional code from infrastructure
    hosted by a service provider (like Google or Amazon), meaning your application
    is served to users in a functional state, rather than sending them source code
    to run. For the rest of the chapter, I’ll refrain from speaking about any one
    service provider. The two major global cloud providers, Google Cloud Platform
    (GCP) and Amazon Web Services (AWS), maintain approximately equivalent features,
    so I think it’s more beneficial to discuss the concepts generally. You can take
    these concepts and learn how to apply them using your particular provider.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，云部署的大多数功能代码都运行在由服务提供商（如谷歌或亚马逊）托管的基础设施上，这意味着你的应用程序是以功能状态提供给用户，而不是将源代码发送给他们运行。在本章的其余部分，我将避免提到任何特定的服务提供商。全球两大云提供商——谷歌云平台（GCP）和亚马逊网络服务（AWS）——大致提供相同的功能，因此我认为讨论这些概念更有益。你可以根据这些概念，学习如何在你选择的特定服务提供商上应用它们。
- en: Rather than hosting code to download, the user will generally be given access
    to your software via a website of some sort. It’s possible to have a user-side
    application that acts as the interface to the cloud structure, but this is less
    common because it adds complexity to an already complex process. The code is broken
    up into small chunks called *microservices*, each of which handles one small part
    of the application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通常会通过某种网站访问你的软件，而不是下载代码进行托管。虽然也可以拥有一个用户端应用程序作为与云结构交互的界面，但这种做法不太常见，因为它会增加已然复杂的过程的复杂度。代码被拆分成称为*微服务*的小块，每个微服务处理应用程序的一小部分。
- en: '[Figure 13-1](#figure13-1) shows a simplified microservice architecture for
    the AGP project.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-1](#figure13-1)展示了AGP项目的简化微服务架构。'
- en: '![](image_fi/502567c13/f13001.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c13/f13001.png)'
- en: 'Figure 13-1: Microservice architecture diagram'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-1：微服务架构图
- en: Each oval represents a small part of the application run inside a virtual machine
    with just enough resources to execute the function and then disappear once it’s
    no longer needed. The key to a good microservice deployment lies in cleanly separating
    the functions into services and efficiently managing the communication between
    the services (the black arrows in the figure).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每个椭圆代表应用程序的一个小部分，它在虚拟机中运行，虚拟机仅具备足够的资源来执行该功能，然后在不再需要时消失。一个好的微服务部署的关键在于将功能清晰地分离到不同的服务中，并高效地管理服务之间的通信（图中的黑色箭头）。
- en: In [Figure 13-1](#figure13-1), I’ve divided the project into four services.
    The user interface is moved into a website that most likely uses HTML5 for the
    interactive drawing and JavaScript for communicating with the rest of the services.
    JSON is a good choice for the communication protocol since the communication between
    services is mostly handled using HTTP requests, and both languages involved (Python
    and JavaScript) handle the format easily. The Data Manager service holds the functions
    for saving and loading project data for users.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图13-1](#figure13-1)中，我将项目分为四个服务。用户界面被移到一个网站中，该网站可能使用HTML5进行交互式绘图，并使用JavaScript与其余的服务进行通信。JSON是一个很好的通信协议选择，因为服务之间的通信大多是通过HTTP请求处理的，并且两种使用的语言（Python和JavaScript）都能轻松处理这种格式。数据管理服务包含保存和加载用户项目数据的功能。
- en: One limitation of a lot of microservice designs is that they lack a permanent
    filesystem to serve files from. You can overcome this by creating a persistent
    storage location, or you could make the storage location a persistent database
    instance. In fact, with a bit of ingenuity, you can make any network-accessible
    storage location work for this purpose. In any case, placing the Data Manager
    service between the other services and the storage container means the Data Manager
    is the only service that needs to know how to read and write from the Cloud Storage
    container. If you decide to migrate to a different method of storage later, you’ll
    only need to update one service.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 许多微服务设计的一个限制是它们缺乏一个永久性的文件系统来提供文件。你可以通过创建一个持久存储位置来克服这一点，或者将存储位置设置为持久的数据库实例。事实上，凭借一些创造力，你可以使任何网络可访问的存储位置都适用于这个目的。无论如何，将数据管理服务置于其他服务和存储容器之间，意味着数据管理服务是唯一需要知道如何从云存储容器中读取和写入的服务。如果你决定以后迁移到不同的存储方式，你只需要更新一个服务。
- en: The Graph builder service contains all of the functions for the application
    to manage the graph representation of a gallery. It communicates with both the
    User Web Interface (to take in the JSON data representing the graph) and the Data
    Manager (to save the information once completed). The Triangle Solver service
    contains the functions for managing the polygon representation of a gallery, including
    the code to ultimately solve each floor using the Triangle library. It also talks
    with the User Web Interface service and the Data Manager service to handle the
    input and output for the code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图形构建服务包含了应用程序管理画廊图形表示的所有功能。它与用户网页界面（接收表示图形的 JSON 数据）和数据管理器（在完成后保存信息）进行通信。三角形求解服务包含了管理画廊多边形表示的功能，包括最终使用三角形库求解每个楼层的代码。它还与用户网页界面服务和数据管理器服务进行通信，处理代码的输入和输出。
- en: Docker is great for microservices because it allows you to configure each virtual
    machine to contain only the pieces necessary to run the service’s code, making
    them faster to create and more secure to operate. You can use Docker containers
    to define these tiny machines on most cloud providers ([https://docs.docker.com](https://docs.docker.com)).
    Furthermore, you can use a container orchestration platform like Kubernetes to
    automatically manage the creation and deletion of each service container as needed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 非常适合微服务，因为它允许你配置每个虚拟机，仅包含运行服务代码所需的部分，这使得虚拟机创建速度更快，运行更安全。你可以使用 Docker
    容器在大多数云服务提供商上定义这些微小的机器（[https://docs.docker.com](https://docs.docker.com)）。此外，你还可以使用像
    Kubernetes 这样的容器编排平台，根据需要自动管理每个服务容器的创建和删除。
- en: 'Automatically creating more instances of your application to serve to users
    is called *horizontal scaling*. Taking advantage of the horizontal scaling capabilities
    of your platform will allow your application to seamlessly adapt to changes in
    processing needs. You can define rules for each service individually, meaning
    you’ll scale only the parts of the application that need to and leave the rest
    alone. For example, suppose your application has 20 users who simultaneously request
    the solution for different floor plans. With a traditional architecture, the Triangle
    service would have to handle all 20 requests, so the last user in the queue will
    have a longer wait than the first. With horizontal scaling, the orchestration
    engine will see the increase in demand and add 19 more copies of the Triangle
    Solver service. The additional copies all run in parallel, so all the requests
    can be handled simultaneously. On the other hand, 20 users on a web server is
    usually fine, so you wouldn’t want the orchestration platform to add more copies
    of the User Interface Service. By configuring automated horizontal scaling rules
    for each service individually, you can save yourself hours of maintenance down
    the road. This is the third form of parallelism you can take advantage of: *hardware
    parallelism.* It’s similar to process parallelism, discussed in [Chapter 12](c12.xhtml),
    but the work is spread across different machines instead of different cores on
    the same machine.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 自动创建更多应用程序实例以提供给用户的过程叫做*横向扩展*。利用平台的横向扩展功能将使你的应用程序能够无缝适应处理需求的变化。你可以为每个服务单独定义规则，这意味着你只会扩展那些需要扩展的应用程序部分，其他部分则保持不变。例如，假设你的应用程序有
    20 个用户同时请求不同楼层平面图的解决方案。在传统架构下，三角形服务必须处理所有 20 个请求，因此队列中的最后一个用户的等待时间会比第一个长。而使用横向扩展时，编排引擎会看到需求增加，并添加
    19 个三角形求解服务的副本。这些副本会并行运行，因此所有请求都可以同时处理。另一方面，20 个用户使用一个网页服务器通常没有问题，所以你不会希望编排平台添加更多的用户界面服务副本。通过为每个服务单独配置自动横向扩展规则，你可以节省未来维护的时间。这是你可以利用的第三种并行形式：*硬件并行性*。它类似于第
    [12 章](c12.xhtml) 中讨论的进程并行性，只不过工作是分布在不同的机器上，而不是同一机器的不同核心上。
- en: The cloud microservices method is probably the most complex to achieve initially,
    but the benefits are also numerous. We’ve already seen how its flexibility can
    allow for quick iterations and reduce maintenance time. Another benefit is that
    you can easily monetize the application with much greater control. Since the source
    code is never sent to the end user, they must maintain their account to continue
    accessing the service. There’s usually little to nothing for the user to uninstall
    if they choose to stop using the service as well. All a user needs to do is terminate
    their account and the service is gone, making it the cleanest exit method from
    this perspective.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 云微服务方法可能是最初实现起来最复杂的，但其带来的好处也很多。我们已经看到，它的灵活性可以允许快速迭代并减少维护时间。另一个好处是，你可以更轻松地实现应用程序的货币化，且掌控度更大。由于源代码从未发送给终端用户，他们必须保持账户才能继续访问服务。如果他们决定停止使用该服务，通常也没有什么需要卸载的东西。用户所需要做的就是终止账户，服务即告消失，从这个角度来看，这是最干净的退出方式。
- en: You can run multiple versions of the application to serve users at your discretion.
    Most cloud service providers offer application layer traffic routing, which allows
    you to intelligently direct traffic to different copies of your application based
    on some rules you define. Kubernetes also has some traffic routing capabilities
    that can be used to achieve the same effect. You can use the traffic routing ability
    to selectively beta-test changes before distributing them to all users or to define
    separate testing and production versions (called *A/B* or *blue/green testing*).^([1](b01.xhtml#c13-endnote-001))
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要运行多个版本的应用程序以服务用户。大多数云服务提供商提供应用层流量路由功能，使你能够根据定义的规则智能地将流量引导到应用程序的不同副本。Kubernetes也有一些流量路由功能，可以用来实现相同的效果。你可以使用流量路由功能，在将更改分发给所有用户之前，有选择地进行Beta测试，或者定义单独的测试版和生产版（称为*A/B*或*蓝绿测试*）。^([1](b01.xhtml#c13-endnote-001))
- en: 'Finally, updates are entirely under your control. Users automatically have
    access to the newest production version as soon as you update it. Typically, microservices
    are built in several stages. The stages can vary from project to project but roughly
    follow these phases: code push, continuous integration testing, Docker container
    build, and finally, service deployment. The code push is probably already familiar
    to you. It occurs when you push some changes to the code repositories (for example,
    with the command `git push`). Pushing the code triggers the continuous integration
    tests. These tests are designed to ensure that you don’t introduce any common
    bugs with your changes ([https://circleci.com/blog/proactive-integration-testing](https://circleci.com/blog/proactive-integration-testing)).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新完全由你掌控。用户在你更新后会自动访问到最新的生产版本。通常，微服务是分阶段构建的。每个项目的阶段可能有所不同，但大致上遵循以下几个阶段：代码推送、持续集成测试、Docker容器构建，最后是服务部署。代码推送你可能已经非常熟悉了。它是在你将一些更改推送到代码仓库时发生的（例如，使用命令`git
    push`）。推送代码会触发持续集成测试。这些测试旨在确保你的更改不会引入常见的bug（[https://circleci.com/blog/proactive-integration-testing](https://circleci.com/blog/proactive-integration-testing)）。
- en: The major drawback is the monetary and time costs associated with building and
    maintaining the network of services required to make the application behave seamlessly
    for users. Each cloud provider comes with its own unique way of implementing the
    pieces, and the pieces themselves require you to understand auxiliary applications
    like Docker and Kubernetes to work. If you decide to deploy your application in
    the cloud, you’ll need to spend some time learning the idiosyncrasies of the platform
    you choose. It also doesn’t hurt to have a development team to support your cloud
    deployment efforts.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的缺点是与构建和维护确保应用程序无缝运行所需的服务网络相关的金钱和时间成本。每个云服务提供商都有自己独特的实现方式，而且这些组件本身要求你了解像Docker和Kubernetes这样的辅助应用程序。如果你决定将应用程序部署到云端，你将需要花些时间学习你所选择平台的独特性。拥有一支开发团队来支持你的云部署工作也是有益的。
- en: 'You can’t expect to become an expert in all the different components necessary
    for a solid cloud deployment pipeline. I’ve been lucky through my career to have
    the pleasure of working with some of the best cloud engineers in the field, and
    what I learned was the value of a strong team made up of different specialists.
    Having someone who can focus on the architecture while another person focuses
    on the user interface while a third writes the main service code means the work
    can get done much quicker; this is parallel development. Having a team also allows
    each person to maintain focus on the areas where they are most knowledgeable,
    and your project to benefit from the added expertise. Of course, running a development
    team brings its own host of problems: conflicting personalities, failures on delivery
    dates, and so on. Deciding to use a development team means you also need someone
    who will be responsible for communication and coordination among the team members^([2](b01.xhtml#c13-endnote-002))
    (called the *project manager*). Cloud deployments are at the heart of all modern
    software-as-a-service (SaaS) companies because the long-term benefits far outweigh
    the initial development cost. Of course, cloud deployments may not be the best
    choice for a small project with only a few planned users.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能指望在构建一个稳固的云部署管道时，成为所有不同组件的专家。在我的职业生涯中，我很幸运与一些领域内最优秀的云工程师共事，我学到的就是强大团队的价值，团队由不同的专家组成。拥有一个专注于架构的人员、另一个专注于用户界面的人员，以及第三个编写主要服务代码的人员，意味着工作可以更快完成；这就是并行开发。拥有团队还使每个人能够专注于他们最擅长的领域，并使你的项目受益于更多的专业知识。当然，管理一个开发团队也带来了许多问题：个性冲突、交付日期延误等等。决定使用开发团队意味着你还需要一个人来负责团队成员之间的沟通和协调（称为*项目经理*）。云部署是所有现代软件即服务（SaaS）公司的核心，因为其长期的收益远远超过了最初的开发成本。当然，云部署可能不是仅有少数计划用户的小项目的最佳选择。
- en: Licensing with PyArmor
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 PyArmor 的许可
- en: The next method is a bit of an oddball. PyArmor is a command line tool for obfuscating
    Python source code. It’s conceptually similar to the stand-alone application in
    the sense that you still deliver an executable to your users, but PyArmor tries
    to ensure that your Python applications are saved and run only from approved machines
    in an attempt to protect your intellectual property and help monetize executables
    you deliver to your users. *Obfuscation* is the process of hiding the structure
    and operation of the code to render the application inoperable without the proper
    de-obfuscation technique. An example of obfuscation might be changing the string
    `"Hello from PyArmor"` to something like `"H7ejl8l3ocb1fRr4osm9blPjy9Afr4mvo0rp"`.
    The application obfuscates constants and literal strings as well as the runtime
    code of each function. If someone attempts to read your source code, either at
    rest or in memory, they’ll be met by a wall of gibberish.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法有点特别。PyArmor 是一个命令行工具，用于混淆 Python 源代码。它在概念上类似于独立应用程序，因为你仍然会向用户交付一个可执行文件，但
    PyArmor 尝试确保你的 Python 应用程序只在经过批准的机器上保存和运行，旨在保护你的知识产权，并帮助你将交付给用户的可执行文件进行货币化。*混淆*是隐藏代码的结构和操作的过程，从而使得应用程序在没有适当的去混淆技术时无法运行。混淆的一个例子可能是将字符串
    `"Hello from PyArmor"` 改为类似于 `"H7ejl8l3ocb1fRr4osm9blPjy9Afr4mvo0rp"` 的内容。该应用程序会混淆常量和字面字符串以及每个函数的运行时代码。如果有人试图读取你的源代码，无论是在静态文件中还是在内存中，他们将遇到一堵乱码的墙。
- en: Obfuscating your application’s source code also enables you to bind your application
    to a single machine and expire the application remotely. Your code is hidden behind
    a startup application that contains the proper de-obfuscation technique. PyArmor
    startup scripts check for a license file that was created when the user installed
    your application. The license file uses some unique machine attributes to ensure
    it’s run on the same machine at each start.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆应用程序的源代码还使你能够将应用程序绑定到单一的机器上，并且能够远程使应用程序过期。你的代码被隐藏在一个启动应用程序后面，该应用程序包含适当的去混淆技术。PyArmor
    启动脚本检查用户安装应用程序时创建的许可文件。该许可文件使用一些唯一的机器属性，确保每次启动时都在同一台机器上运行。
- en: You can also define a license server that manages the validity of each license.
    On each start, your application calls out to the license server with its license
    identifier. Your server can then respond with an authenticated message saying
    whether or not the application should allow itself to execute. Of course, this
    relies on your user having network access every time they want to run your software,
    which may or may not make sense for your project.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以定义一个许可证服务器，管理每个许可证的有效性。在每次启动时，你的应用程序会调用许可证服务器并传递它的许可证标识符。然后，服务器可以返回一个经过身份验证的消息，告知应用程序是否应该允许自己执行。当然，这依赖于用户每次运行软件时都能访问网络，这可能适用于你的项目，也可能不适用。
- en: 'Obfuscation shouldn’t be confused with encryption, and it certainly doesn’t
    offer the security of a strong encryption scheme. With encryption, you have some
    mathematical proof of security using some form of secret information. The bigger
    and harder to guess that secret is, the more secure the application. Obfuscation,
    on the other hand, is more like camouflage: it’s meant to hide the code from casual
    attempts at reverse engineering or bypassing the license restrictions. But once
    someone understands how the code has been obfuscated, they can always reverse
    the process. Going back to my previous example, if you examined the second string
    more closely, you may have realized that all I did was insert random characters
    between the letters of the phrase. Next, I replaced the spaces with a constant
    character, `b`. By reversing this process, replacing the even-numbered `b` characters
    with spaces and stripping every other character out, you can convert the jumbled
    string back to the original phrase. As if that weren’t bad enough, the part of
    the startup script that handles the de-obfuscation can’t be obfuscated itself,
    meaning the technique used is available to anyone who wishes to look for it. (If
    it could be obfuscated, you’d create a feedback loop as you’d need a de-obfuscator
    for the de-obfuscator.) To borrow a phrase used in the lock-picking world: “It’s
    good enough to keep honest people honest.” Depending on the level of obfuscation,
    this may only hinder a talented reverse engineer by a couple hours.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆不应与加密混淆，它显然不能提供强加密方案的安全性。使用加密时，你可以通过某种形式的秘密信息来提供数学上的安全证明。这个秘密越大，越难以猜测，应用程序就越安全。另一方面，混淆更像是伪装：它旨在防止通过逆向工程或绕过许可限制的简单尝试。然而，一旦有人理解了代码是如何被混淆的，他们总能逆转这个过程。回到我之前的例子，如果你更仔细地检查第二个字符串，你可能会意识到我所做的只是将随机字符插入到短语的字母之间。接下来，我将空格替换为常量字符`b`。通过逆转这个过程，将偶数位置的`b`字符替换为空格，并去掉每隔一个字符，你就能把混乱的字符串恢复成原始短语。更糟糕的是，处理去混淆的启动脚本本身无法被混淆，这意味着所使用的技术对任何希望查看的人都是公开的。（如果它能被混淆，你将会创造一个反馈循环，因为你需要一个去混淆器来去混淆去混淆器。）借用锁匠世界中的一句话：“足以让诚实的人保持诚实。”
    根据混淆的级别，这可能只能让一位优秀的逆向工程师浪费几个小时。
- en: Although there are some obvious limitations, I wouldn’t completely dismiss PyArmor
    either. PyArmor may make a good addition if you plan to monetize the stand-alone
    package delivery method because it does add some control and monitoring to the
    process. You can’t guarantee your controls won’t be bypassed, but it certainly
    makes it less likely than a stand-alone application without obfuscation and licensing
    applied. Another potential use for PyArmor’s licensing is tracking the number
    of active users. Even if you don’t plan to monetize your project, having a license
    in place allows you to approximate the number of users by looking at which licenses
    have checked in (meaning the application was started). As your project gains popularity,
    you can use these estimates to gain investor interest or potentially sell your
    project to a larger SaaS provider.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有一些明显的限制，我并不会完全否定PyArmor。如果你计划通过独立包交付方式来实现盈利，PyArmor可能是一个不错的补充，因为它确实为这个过程增加了一些控制和监控。你不能保证你的控制不会被绕过，但它肯定比没有应用混淆和许可的独立应用程序更不容易被绕过。PyArmor的另一个潜在用途是跟踪活跃用户的数量。即使你不打算从你的项目中盈利，拥有许可证也能通过查看哪些许可证已经签到（意味着应用程序已经启动）来估算用户数量。随着你的项目受欢迎程度的提升，你可以利用这些估算来吸引投资者的兴趣，或者有可能将项目出售给更大的SaaS提供商。
- en: Open Source Delivery
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开源交付
- en: There’s no better place to finish than with the option of open source delivery.
    By far the easiest method to deliver your project and to give back to the community
    is to openly license the source code for your project to everyone. By design,
    open source software licenses promote collaboration and sharing as they permit
    other people to make modifications to source code and incorporate those changes
    into their own projects. By hosting your code base on a public GitHub repository
    (or similar), you get the benefits of crowd-sourcing development, getting feedback
    from potential users, reducing hosting costs, and more. Open source projects promote
    collaboration from diverse perspectives. Different people from around the globe
    can come together and contribute. People have different and unique ways of solving
    problems, so including contributions from people with diverse backgrounds can
    push your project to a level of functionality you never would have achieved on
    your own, even with a traditional development team.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比开源交付选项更合适的结尾了。迄今为止，交付你的项目并回馈社区的最简单方法就是公开授权你的项目源代码，让每个人都能使用。开源软件许可证本身就促进了协作和共享，因为它们允许其他人对源代码进行修改，并将这些修改纳入自己的项目中。通过将你的代码库托管在公共
    GitHub 仓库（或类似平台）上，你可以享受众包开发的好处，获得潜在用户的反馈，减少托管成本，等等。开源项目促进了多元化视角的协作。来自全球不同地区的人们可以汇聚一堂并做出贡献。人们解决问题的方式各异，因此，来自不同背景的人们的贡献可以将你的项目推向一个你自己，即使是有传统开发团队的情况下，也无法达到的功能水平。
- en: One common misconception is that “open source” automatically means you can’t
    monetize your application. This isn’t true at all! While it’s true that most open
    source projects aren’t started for money, maintaining a large open source project—Kubernetes,
    for instance—is a lot of work! It takes several full-time developers who probably
    want to get paid for their time, so open source projects will often spawn successful
    companies. Projects are often open-sourced in conjunction with a cloud delivery
    option to provide both a free and paid version. Companies will pay for these cloud-hosted
    versions to reduce the number of systems they have to maintain internally. Red
    Hat, the maintainer of one of the most popular Linux distributions for enterprise
    use, is one example of a large open source company that follows this model. While
    Red Hat continues to offer the open source version of many of its applications,
    it also offers paid customizations and remote support to maintain the business.
    In short, choosing to open-source your code often will reduce your stress and
    encourage a better result for your project, but you don’t have to sacrifice monetization.
    I highly recommend you research the open source route when considering delivery
    methods for your application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的误解是，“开源”就意味着你无法从应用程序中获利。这完全不正确！虽然大多数开源项目的起点并非为了盈利，但维护一个大型开源项目——比如 Kubernetes——确实是一项巨大的工作！它需要几个全职开发人员，而这些开发人员大概率希望能从他们的工作中获得报酬，因此开源项目往往会衍生出成功的公司。项目通常会与云交付选项结合开源，以提供免费版本和付费版本。公司会支付这些云托管版本的费用，从而减少需要在内部维护的系统数量。Red
    Hat——一个维护最受欢迎的企业级 Linux 发行版的公司——就是遵循这一模式的大型开源公司之一。虽然 Red Hat 继续提供许多应用程序的开源版本，但它也提供付费定制和远程支持来维持业务。简而言之，选择开源代码通常能减少你的压力，并推动项目取得更好的成果，但你并不需要牺牲盈利能力。在考虑应用程序交付方法时，我强烈推荐你研究开源路线。
- en: Summary
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Deploying your application for general use can seem like a whole project in
    itself. As you’ve seen, there are several factors that should influence your choice
    of method. These include the number of users you plan to serve and whether you
    want to charge for access. As I said at the start of the chapter, you should start
    with the basic concept of the delivery platform in place when you begin your project.
    Once you’ve decided how to deliver your application, you can let the choice inform
    the rest of your development decisions, such as what storage options are available
    to your code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的应用程序部署供一般用户使用，可能看起来像是一个独立的项目。正如你所看到的，有几个因素应当影响你选择的方法。这些因素包括你计划服务的用户数量，以及你是否打算收费。正如我在章节开始时所说，你应该在开始项目时就确定交付平台的基本概念。一旦你决定了如何交付应用程序，你可以根据这个选择来影响你其他的开发决策，比如可供你的代码使用的存储选项。
- en: At this point, you should have an idea of the available options and the positives
    and negatives of each. You can take these basics and learn more about the process
    that suits your needs best. Whatever method you choose, it’s important to remember
    to think from a user’s perspective as well as from a developer’s. Be kind to users
    and give them intuitive ways to install, manage, and remove your application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到此时，你应该已经对可用的选项以及每个选项的优缺点有了一个大致的了解。你可以从这些基础出发，深入了解最适合你需求的过程。不管你选择哪种方法，记得从用户的角度以及开发者的角度思考。对用户要友好，提供直观的方式来安装、管理和删除你的应用。
- en: The internet is filled with resources for learning about software deployment
    plans, ranging from the very simple to the exceedingly complex. There are also
    excellent books covering various deployment technologies like Docker and Kubernetes
    ([https://bookauthority.org/books/new-continuous-delivery-books](https://bookauthority.org/books/new-continuous-delivery-books)).
    I recommend starting small and working your way up. If you’ve never used Git,
    jumping into a cloud deployment right away is going to lead to frustration. Start
    with something like PyPi, which will allow you to hone your repository management
    skills. Once you’re comfortable with each of the underlying pieces, you’ll be
    better equipped to tackle the large cloud deployment process.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上充满了学习软件部署计划的资源，从非常简单到极其复杂的都有。也有一些非常棒的书籍涉及各种部署技术，如 Docker 和 Kubernetes（[https://bookauthority.org/books/new-continuous-delivery-books](https://bookauthority.org/books/new-continuous-delivery-books)）。我建议从小规模开始，逐步提高。如果你从未使用过
    Git，直接跳入云部署将会让你感到沮丧。可以从像 PyPi 这样的工具入手，它将帮助你磨练你的仓库管理技能。一旦你对每个基本组件都感到熟悉，你将更有准备来应对大型云部署过程。
- en: And with that, we’ve come to the end of the book! If you’ve tackled all the
    concepts and projects, I congratulate you! I hope you feel that you understand
    the role that applied mathematics can play in your security tools. If you take
    anything away from this book, I hope it’s the idea that you can tackle seemingly
    complex research topics with only a basic knowledge of math and an understanding
    of programming. Topics such as facial recognition, privacy monitoring, and social
    network analysis may be getting all the headlines at the moment, but the number
    of open research problems in the broader security field is huge, and they would
    all benefit from a talented and dedicated researcher like you. If there’s a particular
    field that interests you, I encourage you to take the concepts you’ve learned
    and apply them to that field as well. The fields covered in the book all lend
    themselves incredibly well to multiple areas of interest, and when you mix and
    match them, you can achieve some very powerful analysis tools.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里，我们已经完成了本书的内容！如果你已经掌握了所有的概念和项目，我向你表示祝贺！希望你能感受到应用数学在安全工具中可以发挥的作用。如果你从本书中获得任何收获，我希望那就是：你可以仅凭基本的数学知识和编程理解来应对看似复杂的研究课题。像人脸识别、隐私监控和社交网络分析等话题现在可能占据了所有的头条，但在更广泛的安全领域中，仍有大量未解的研究问题，而这些问题都可以从像你这样的才华横溢且专注的研究人员中受益。如果有某个特定的领域引起了你的兴趣，我鼓励你将学到的概念应用到那个领域中。本书所涵盖的领域都能极好地适应多种兴趣方向，当你将它们结合在一起时，可以实现非常强大的分析工具。
- en: 'The scariest part of applying security to the real world, where a mistake could
    cost lives, is the need to make decisions in the face of uncertainty. Analysis
    tools like the ones presented in the previous chapters allow us to examine the
    world in different ways and to make the most informed decisions possible. You
    may not be able to remove uncertainty completely, but you can minimize its impact
    on yourself and those around you. Remember: security isn’t just a job or career
    path, but a way of understanding the world. The future of security applications
    lies in the accurate collection, interpretation, and response to data collected
    from our physical and digital environments to aid us in that understanding.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在将安全应用到现实世界中时，最可怕的部分就是在不确定性面前做出决策，毕竟一个错误可能会付出生命的代价。像前几章所展示的分析工具，能够让我们从不同的角度审视世界，并做出最有依据的决策。你可能无法完全消除不确定性，但你可以将其对自己和周围人的影响降到最低。记住：安全不仅仅是一份工作或职业道路，它更是一种理解世界的方式。未来的安全应用将依赖于准确地收集、解读和回应来自我们物理和数字环境的数据，以帮助我们更好地理解世界。
