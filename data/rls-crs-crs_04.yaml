- en: Chapter 3. Models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 模型
- en: In Rails, models represent the data in your application and the rules to manipulate
    that data. Models manage interactions between your application and a corresponding
    database table. The bulk of your application’s business logic should also be in
    the models.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rails中，模型表示应用程序中的数据以及操作这些数据的规则。模型管理应用程序与相应数据库表之间的交互。应用程序的大部分业务逻辑也应该放在模型中。
- en: This chapter covers Active Record, the Rails component that provides model persistence
    (that is, storing data in the database), as well as data validations, database
    migrations, and model associations. *Validations* are rules to ensure that only
    valid data is stored in the database. You create database *migrations* to change
    the schema of the database, and *associations* are relationships between multiple
    models in your application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了活跃记录，这是Rails组件之一，提供模型持久化（即，将数据存储在数据库中），以及数据验证、数据库迁移和模型关联。*验证*是确保仅有效数据存储在数据库中的规则。你创建数据库*迁移*来更改数据库的架构，*关联*是你应用程序中多个模型之间的关系。
- en: The Post Model
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 帖子模型
- en: In the previous chapter, we used the Rails scaffold generator to build a simple
    blog with models, views, and controllers for blog posts. Look at the post model
    created by the scaffold generator by opening the file *app/models/post.rb* in
    your favorite text editor.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用Rails脚手架生成器构建了一个简单的博客，包含用于博客帖子的模型、视图和控制器。通过在你喜欢的文本编辑器中打开文件*app/models/post.rb*，查看脚手架生成器创建的帖子模型。
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There’s not much to see here. Right now, the file just tells us that the class
    `Post` inherits from `ActiveRecord::Base`. Before I talk about what you can actually
    do with `Post`, let’s begin our discussion with Active Record.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多内容。目前，这个文件仅告诉我们`Post`类继承自`ActiveRecord::Base`。在我讲解你可以实际做什么之前，让我们从活跃记录开始讨论。
- en: Active Record
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活跃记录
- en: '*Active Record* is an implementation of the object-relational mapping (ORM)
    pattern described, using the same name, by Martin Fowler in *Patterns of Enterprise
    Application Architecture* (Addison-Wesley Professional, 2002). It’s an automated
    mapping between classes and tables as well as attributes and columns.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*活跃记录*是对象关系映射（ORM）模式的一种实现，Martin Fowler在其《企业应用架构模式》（Addison-Wesley Professional,
    2002）中使用相同的名称描述了这一模式。它是类与表之间、属性与列之间的自动映射。'
- en: Each table in your database is represented by a class in your application. Each
    row of that table is represented by an instance (or object) of the associated
    class, and each column of that row is represented by an attribute of that object.
    The example in [Table 3-1](ch03.html#posts_table "Table 3-1. The Posts Table")
    demonstrates this structure. If you could look inside your database, this is what
    you would see.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中的每个表都由应用程序中的一个类表示。该表的每一行由关联类的实例（或对象）表示，行中的每一列由该对象的一个属性表示。[表 3-1](ch03.html#posts_table
    "表 3-1. 帖子表")中的示例演示了这种结构。如果你能查看你的数据库，看到的就是这样的内容。
- en: Table 3-1. The Posts Table
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1. 帖子表
- en: '| id | title | body | created_at | updated_at |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| id | 标题 | 内容 | 创建时间 | 更新时间 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1 | Hello, World | Welcome to my blog... | ... | ... |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 你好，世界 | 欢迎来到我的博客... | ... | ... |'
- en: '| 2 | My Cat | The cutest kitty in the... | ... | ... |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 我的猫 | 最可爱的猫咪... | ... | ... |'
- en: '| 3 | Too Busy | Sorry I haven’t posted... | ... | ... |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 太忙了 | 抱歉，我没有更新... | ... | ... |'
- en: '[Table 3-1](ch03.html#posts_table "Table 3-1. The Posts Table") holds three
    example blog posts. This table is represented by the `Post` class. The post with
    an `id` of 1 can be represented by a `Post` object. Let’s call our object `post`.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-1](ch03.html#posts_table "表 3-1. 帖子表")包含了三个示例博客帖子。这个表由`Post`类表示。`id`为1的帖子可以由一个`Post`对象表示。我们把这个对象叫做`post`。'
- en: You can access the data associated with a single column by calling an attribute
    method on the object. For example, to see the post’s title, call `post.title`.
    The ability to access and change database values by calling attribute methods
    on an object is known as *direct manipulation*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用对象的属性方法来访问与单个列相关的数据。例如，要查看帖子的标题，调用`post.title`。通过在对象上调用属性方法访问和更改数据库值的能力被称为*直接操作*。
- en: Create, Read, Update, and Delete
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建、读取、更新和删除
- en: Let’s explore Active Record further by entering a few commands in the Rails
    console. The Rails console is the IRB that you used in [Chapter 1](ch01.html "Chapter 1. Ruby
    Fundamentals") with your Rails application’s environment preloaded.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在Rails控制台中输入一些命令进一步探索Active Record。Rails控制台就是你在[第1章](ch01.html "第1章 Ruby基础")中使用的IRB，只不过加载了Rails应用程序的环境。
- en: To start the Rails console, go to your *blog* directory and enter **`bin/rails
    console`**. You might notice that the console takes a little longer to start than
    the IRB. During that slight pause, your application’s environment is being loaded.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动Rails控制台，进入你的*blog*目录并输入**`bin/rails console`**。你可能会注意到控制台启动时比IRB稍微慢一些。在这短暂的暂停期间，应用程序的环境正在加载。
- en: As with the IRB, you can enter `exit` to quit the console when you’re done.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与IRB一样，当你完成操作时，你可以输入`exit`退出控制台。
- en: The four major functions of database applications are *create*, *read*, *update*,
    and *delete*, usually abbreviated as *CRUD*. Once you know how to perform these
    four actions, you can build any type of application you need.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库应用程序的四个主要功能是*创建*、*读取*、*更新*和*删除*，通常缩写为*CRUD*。一旦你掌握了这四个操作，你就能构建任何类型的应用程序。
- en: Rails makes these actions easy for you. In most cases, you can accomplish each
    with a single line of code. Let’s use them now to work with posts on our blog.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Rails使这些操作变得非常简单。在大多数情况下，你可以通过一行代码完成每个操作。现在让我们使用它们来处理我们博客上的帖子。
- en: Create
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建
- en: We’ll start by adding a few records to the database. Enter these commands in
    the Rails console as you work through this section. The remaining examples in
    this chapter use these records.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从向数据库中添加一些记录开始。在完成本节内容时，请在Rails控制台中输入这些命令。本章接下来的示例将使用这些记录。
- en: 'The easiest way to create a record in Rails is with the appropriately named
    `create` method, as shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rails中创建记录最简单的方法是使用命名恰当的`create`方法，如下所示：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Rails console displays the SQL being sent to the database as commands are
    run ➊. In the interest of brevity, I’m going to omit these SQL statements in the
    rest of the samples.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Rails控制台会在执行命令时显示发送到数据库的SQL语句 ➊。为了简洁起见，接下来的示例中我将省略这些SQL语句。
- en: The `create` method accepts a hash of attribute-value pairs and inserts a record
    into the database with the appropriate values. In this case, it’s setting the
    `title` attribute to the value `"First Post"`. When you run this example, the
    values for `id`, `created_at`, and `updated_at` are set for you automatically.
    The `id` column is an auto-incrementing value in the database, whereas `created_at`
    and `updated_at` are timestamps set for you by Rails. The `body` column is set
    to NULL since no value was passed for it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`create`方法接受一组属性-值对，并将记录插入到数据库中，使用适当的值。在这种情况下，它将`title`属性设置为`"First Post"`的值。当你运行这个示例时，`id`、`created_at`和`updated_at`的值会自动为你设置。`id`列是数据库中的自增值，而`created_at`和`updated_at`是Rails为你设置的时间戳。由于没有为`body`列传入值，因此它被设置为NULL。'
- en: 'The `create` method is a shortcut for instantiating a new `Post` object, assigning
    values, and saving it to the database. If you don’t want to take the shortcut,
    you could also write a separate line of code for each action:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`create`方法是一个快捷方式，用于实例化一个新的`Post`对象、分配值并将其保存到数据库。如果你不想使用快捷方式，你也可以为每个操作写单独的代码行：'
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We had to use multiple commands this time, but just like before, we’ve created
    a brand new `Post` object. Two posts are now stored in the database. In both examples,
    we only assigned values to the post’s `title` attribute, but you would assign
    values to the post `body` in exactly the same way. Rails assigns values to `id`,
    `created_at`, and `updated_at` automatically. You shouldn’t change these.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们使用了多个命令，但就像之前一样，我们创建了一个全新的`Post`对象。现在数据库中存储了两个帖子。在这两个示例中，我们仅为帖子的`title`属性分配了值，但你可以通过相同的方式为帖子的`body`属性分配值。Rails会自动为你分配`id`、`created_at`和`updated_at`的值。你不应该修改这些值。
- en: Read
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读
- en: 'Once you have a few posts in your database, you’ll probably want to read them
    back out for display. First, let’s look at all of the posts in the database with
    the `all` method:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的数据库中有了一些帖子，你可能会希望将它们读出并显示。首先，让我们使用`all`方法查看数据库中的所有帖子：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This returns an Active Record *relation*, which contains an array of all posts
    in your database, and stores it in `posts`. You can chain additional methods onto
    this relation, and Active Record combines them into a single query.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这会返回一个Active Record *关系*，它包含一个数据库中所有帖子的数组，并将其存储在`posts`中。你可以将其他方法链式调用到这个关系上，Active
    Record会将它们合并成一个查询。
- en: 'Active Record also implements the `first` and `last` methods, which return
    the first and last entries in an array. The Active Record version of these methods
    returns only the first or last record in the database table. This is much more
    efficient than fetching all of the records in the table and then calling `first`
    or `last` on the array. Let’s try fetching a couple of posts from our database:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Active Record 还实现了 `first` 和 `last` 方法，它们返回数组中的第一个和最后一个条目。Active Record 版本的这些方法只会返回数据库表中的第一个或最后一个记录。这比先获取表中所有记录，再在数组上调用
    `first` 或 `last` 要高效得多。让我们试着从数据库中获取几篇帖子：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example returns the first and last posts, as ordered by `id`. You’ll learn
    how to order records by a different field in the next section. Sometimes, however,
    you’ll know exactly which record you want, and it might not be the first or last
    one. In that case, you can use the `find` method to retrieve a record by `id`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子返回的是按照 `id` 排序的第一篇和最后一篇帖子。你将在下一个章节学习如何按其他字段对记录进行排序。然而，有时你可能确切知道想要哪个记录，而它可能不是第一个或最后一个。在这种情况下，你可以使用
    `find` 方法通过 `id` 获取记录。
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Just don’t ask `find` to fetch a record that doesn’t exist. If a record with
    the specified `id` isn’t in your database, Active Record will raise an `ActiveRecord::RecordNotFound`
    exception. When you know a specific record exists but you don’t know its `id`,
    you can use the `where` method to specify an attribute that you do know:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 只是不要请求 `find` 去获取一个不存在的记录。如果数据库中没有指定 `id` 的记录，Active Record 将抛出 `ActiveRecord::RecordNotFound`
    异常。当你知道某个特定记录存在但不知道它的 `id` 时，可以使用 `where` 方法指定你已知的某个属性：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `where` method also returns a relation. If more than one record matches,
    you can chain the `all` method after `where` and tell Rails to retrieve all matching
    records on demand when they are needed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`where` 方法也返回一个关系。如果有多个记录匹配，你可以在 `where` 后链式调用 `all` 方法，告诉 Rails 按需获取所有匹配的记录。'
- en: 'If you know the database has only one matching record, you can chain the `first`
    method after `where` to retrieve that specific record as in the previous example.
    This pattern is so common that Active Record also provides the `find_by` method
    as a shortcut:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道数据库中只有一个匹配的记录，你可以在 `where` 后链式调用 `first` 方法来获取这个特定记录，就像在之前的例子中一样。这个模式非常常见，因此
    Active Record 还提供了 `find_by` 方法作为快捷方式：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This method takes a hash of attribute-value pairs and returns the first matching
    record.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接受一个属性-值对的哈希，并返回第一个匹配的记录。
- en: Update
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新
- en: 'Updating a record is as easy as reading it into a variable, changing values
    via direct manipulation, and then saving it back to the database:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 更新记录就像读取它到一个变量、通过直接操作改变值，然后将其保存回数据库一样简单：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Rails also provides the `update` method, which takes a hash of attribute-value
    pairs, updates the record, and saves to the database all on one line:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Rails 还提供了 `update` 方法，它接受一个属性-值对的哈希，更新记录，并在一行中保存到数据库：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `update` method, like the `save` method, returns `true` when successful
    or `false` if it has a problem saving the record.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`update` 方法与 `save` 方法类似，成功时返回 `true`，如果保存记录时出现问题，则返回 `false`。'
- en: Delete
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除
- en: Once you have read a record from the database, you can delete it with the `destroy`
    method. But this time don’t type in these commands. You don’t want to delete the
    posts you created earlier!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你从数据库中读取了一个记录，你可以通过 `destroy` 方法将其删除。但这次不要输入这些命令，你可不想删除你之前创建的帖子！
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `destroy` method can also be called on the class to delete a record by
    `id`, which has the same effect as reading the record into a variable first:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`destroy` 方法也可以在类上调用，通过 `id` 删除记录，这与先将记录读取到变量中的效果相同：'
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can also delete records based on a relation:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以根据关系删除记录：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This example deletes all records with a title of `"First Post"`. Be careful
    with the `destroy_all` method, however. If you call it without a `where` clause,
    you’ll delete all records of the specified class!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子删除了所有标题为 `"First Post"` 的记录。然而，使用 `destroy_all` 方法时要小心。如果在没有 `where` 条件的情况下调用它，你会删除指定类的所有记录！
- en: More Active Record Methods
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多 Active Record 方法
- en: If you’re familiar with SQL or other methods of accessing records in a database,
    you know there’s much more to working with a database than simple CRUD. Active
    Record provides methods for more database operations, such as ordering, limiting,
    counting, and other calculations.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 SQL 或其他访问数据库记录的方法，你会知道操作数据库不仅仅是简单的 CRUD。Active Record 提供了更多数据库操作的方法，如排序、限制、计数和其他计算。
- en: Query Conditions
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询条件
- en: In addition to the simple `where` conditions you’ve seen so far, Active Record
    also has several methods to help refine your queries. The `order` method specifies
    the order of returned records; `limit` specifies how many records to return; and
    `offset` specifies the first record to return from a list.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你到目前为止看到的简单 `where` 条件，Active Record 还提供了几个方法来帮助你优化查询。`order` 方法指定返回记录的顺序；`limit`
    指定返回多少条记录；`offset` 指定从列表中返回的第一条记录。
- en: 'The `limit` and `offset` methods are often used together for pagination. For
    example, if you want to show 10 blog posts per page, you can read the posts for
    the first page like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`limit` 和 `offset` 方法通常一起用于分页。例如，如果你想每页显示10篇博客文章，你可以这样读取第一页的文章：'
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To read the posts for the second page of your site, you’ll need to skip the
    first 10 posts:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取网站第二页的文章，你需要跳过前10篇文章：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Entering this returns an empty set since we only have two posts in our database.
    When you combine `offset` with `limit` in this way, you can pass `offset` multiples
    of what you passed `limit` to view different pages of your blog.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 输入这个会返回一个空集，因为我们的数据库中只有两篇文章。当你以这种方式将 `offset` 和 `limit` 结合使用时，你可以将 `offset`
    设置为 `limit` 的倍数，查看博客的不同页面。
- en: 'You can also change how the entries in a relation are ordered. When using `limit`,
    the order of records returned is undefined, so you need to specify an order. With
    the `order` method, you can specify a different order for the set of records returned:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以更改关联中条目的排序方式。使用 `limit` 时，返回的记录顺序是未定义的，所以你需要指定排序方式。使用 `order` 方法，你可以为返回的记录集指定不同的排序方式：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using `DESC` tells `order` to return the posts from newest to oldest. You could
    also use `ASC` to order them the opposite way. If you would rather see posts alphabetized
    by title, try replacing `"created_at DESC"` with `"title ASC"`. The `order` method
    defaults to ascending order if you don’t specify `ASC` or `DESC`, but I always
    give an order so my intention is clear.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `DESC` 告诉 `order` 返回从最新到最旧的文章。你也可以使用 `ASC` 按相反的顺序排列。如果你更愿意按标题的字母顺序查看文章，可以将
    `"created_at DESC"` 替换为 `"title ASC"`。如果不指定 `ASC` 或 `DESC`，`order` 方法默认按升序排列，但我总是指定一个排序，以便明确我的意图。
- en: Calculations
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算
- en: Databases also provide methods for performing calculations on records. We could
    read the records and perform these operations in Ruby, but the methods built in
    to the database are usually optimized to be faster and use less memory.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库还提供了对记录执行计算的方法。我们可以在 Ruby 中读取记录并执行这些操作，但内置的数据库方法通常已优化为更快并且使用更少的内存。
- en: 'The `count` method returns the number of records matching a given condition:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`count` 方法返回匹配给定条件的记录数：'
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you don’t specify a condition, `count` counts all records by default, as
    in this example.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有指定条件，`count` 默认会计算所有记录，如此示例所示。
- en: 'The `sum`, `average`, `minimum`, and `maximum` methods perform the requested
    function on a field. For example, this line of code finds and returns the date
    on the newest blog post:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum`、`average`、`minimum` 和 `maximum` 方法在某个字段上执行请求的功能。例如，这行代码会查找并返回最新博客文章的日期：'
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The maximum `created_at` date you see should match the date for your newest
    blog post, not necessarily the date you see in the example.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的最大 `created_at` 日期应该与最新博客文章的日期匹配，而不一定是示例中显示的日期。
- en: Migrations
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移
- en: '*Database migrations* are used any time you need to change your database’s
    structure. When we used the scaffold generator to create blog posts, it generated
    a migration for us, but you can also create migrations yourself. As you build
    your application, your database migrations contain a complete record of the changes
    made to your database.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据库迁移* 用于每次需要更改数据库结构时。当我们使用脚手架生成器创建博客文章时，它为我们生成了迁移文件，但你也可以自己创建迁移文件。随着你构建应用程序，数据库迁移将包含对数据库所做更改的完整记录。'
- en: 'Migration files are stored in the *db/migrate* directory and start with a timestamp
    that indicates when they were created. For example, you can see the migration
    created by the scaffold generator by editing the file *db/migrate/*_create_posts.rb*.
    (Because the timestamps on your files will surely be different from mine, I’ll
    use an asterisk from now on to refer to the date part of the filename.) Let’s
    look at that file now:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移文件存储在 *db/migrate* 目录中，并以时间戳开头，表示它们的创建时间。例如，你可以通过编辑文件 *db/migrate/*_create_posts.rb*
    来查看脚手架生成器创建的迁移文件。（由于你文件上的时间戳肯定与我的不同，从现在开始我将使用星号来表示文件名中的日期部分。）现在我们来看看这个文件：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Database migrations are actually Ruby classes. The `change` method is called
    ➊ when the migration is run. In this case, the method creates a table named `posts`
    with fields for `title`, `body`, and `timestamps`. The `timestamps` field refers
    to both the `created_at` and `updated_at` fields. Rails also automatically adds
    the `id` column.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库迁移实际上是Ruby类。当迁移运行时，调用`change`方法 ➊。在这个例子中，该方法创建一个名为`posts`的表，并包含`title`、`body`和`timestamps`字段。`timestamps`字段指的是`created_at`和`updated_at`字段。Rails
    还会自动添加`id`列。
- en: You can run migrations as tasks with the `rake` command. For example, you enter
    `bin/rake db:migrate` to run all pending migrations and bring your database up-to-date.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`rake`命令将迁移作为任务运行。例如，输入`bin/rake db:migrate`来运行所有待处理的迁移，并使你的数据库保持最新。
- en: Rails keeps track of which migrations have been run by storing the timestamps
    in a database table called `schema_migrations`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Rails 通过在名为`schema_migrations`的数据库表中存储时间戳，跟踪哪些迁移已经运行。
- en: If you make a mistake in a database migration, use the `db:rollback` task to
    undo it. After you correct the migration, use `db:migrate` to run it again.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在数据库迁移中犯了错误，可以使用`db:rollback`任务来撤销它。纠正迁移后，使用`db:migrate`重新运行它。
- en: The Schema
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式
- en: 'In addition to the individual migration files, Rails also stores your database’s
    current state. You can see this by opening the file *db/schema.rb*. Ignoring the
    comment block at the top of the file, it should look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单独的迁移文件外，Rails 还存储了你数据库的当前状态。你可以通过打开文件*db/schema.rb*来查看。忽略文件顶部的注释块，应该像这样：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This file is updated whenever you run a database migration. You should not
    edit it manually. If you are moving your application to a new computer and would
    like to create a new, empty database all at once instead of by running the individual
    migrations, you can do that with the `db:schema:load rake` task:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行数据库迁移时，此文件都会更新。你不应手动编辑它。如果你将应用程序迁移到新电脑，并且想要一次性创建一个新的空数据库，而不是通过运行单独的迁移，你可以使用`db:schema:load
    rake`任务来实现：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Running this command resets the database structure and removes all of your data
    in the process.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令会重置数据库结构，并在此过程中移除所有数据。
- en: Adding a Column
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加列
- en: 'Now that you know more about migrations, let’s create one and run it. When
    we created our blog post model, we forgot that posts need authors. Add a string
    column to the posts table by generating a new migration:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对迁移有了更多了解，接下来让我们创建一个并运行它。当我们创建博客文章模型时，忘记了文章需要作者。通过生成一个新的迁移，向文章表添加一个字符串列：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The Rails generator (`g` is short for `generate`) looks at the name of your
    migration, in this case, `add_author_to_posts`, and tries to figure out what you
    want to do. This is another example of convention over configuration: name your
    migration in the format `add_`*`ColumnName`*`_to_`*`TableName`*, and Rails will
    parse that to add what you need. Based on the name, we clearly want to add a column
    named `author` to the posts table. We also specified that `author` is a string,
    so Rails has all the information it needs to create the migration.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Rails生成器（`g`是`generate`的缩写）查看迁移的名称，在这个例子中是`add_author_to_posts`，并尝试推断你想做什么。这是约定优于配置的另一个例子：按照`add_`*`ColumnName`*`_to_`*`TableName`*的格式命名迁移，Rails会解析这些信息并自动添加所需内容。根据名称，我们显然想要将名为`author`的列添加到文章表中。我们还指定了`author`是一个字符串，因此Rails拥有创建迁移所需的所有信息。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*You can name a migration anything you want, but you should follow the convention
    so you don’t have to edit the migration manually.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以为迁移命名任何你想要的名称，但你应该遵循约定，这样就不需要手动编辑迁移文件。*'
- en: Enter **`bin/rake db:migrate`** to run the migration and add the `author` column
    to your database. If you still have a Rails console open, you’ll need to **`exit`**
    and restart with **`bin/rails console`** for your changes to take effect. You
    can also look at the *db/schema.rb* file to see the new column in the posts table.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 输入**`bin/rake db:migrate`**来运行迁移并向数据库中添加`author`列。如果你仍然打开了Rails控制台，你需要**`exit`**并重新启动，使用**`bin/rails
    console`**才能使更改生效。你也可以查看*db/schema.rb*文件，以查看文章表中新添加的列。
- en: Inside the Author Migration
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在作者迁移中
- en: The code you just generated for adding a column is simple. Edit the file *db/migrate/*_add_author_to_posts.rb*
    to see how it works.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚生成的添加列的代码很简单。编辑文件*db/migrate/*_add_author_to_posts.rb*来查看它是如何工作的。
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Like **_create_posts.rb*, this migration is a class containing a `change` method.
    The `add_column` method is called with the table name, column name, and column
    type. If you want to add multiple columns, you could create separate migrations
    for each, or you could call this method multiple times.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 像 **_create_posts.rb**，这个迁移是一个包含 `change` 方法的类。调用 `add_column` 方法并传入表名、列名和列类型。如果你想添加多个列，你可以为每个列创建单独的迁移，或者可以多次调用这个方法。
- en: Active Record migrations also provide the `rename_column` method for changing
    a column’s name, the `remove_column` method for removing a column from a table,
    and the `change_column` method for changing a column’s type or other options,
    such as default value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Active Record 迁移还提供了 `rename_column` 方法用于更改列名，`remove_column` 方法用于从表中删除列，以及
    `change_column` 方法用于更改列的类型或其他选项，如默认值。
- en: Validations
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: Remember that models have rules for manipulating application data. Active Record
    *validations* are sets of rules created to protect your data. Add validation rules
    to ensure that only good data makes it into your database.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，模型有用于操作应用数据的规则。Active Record *验证* 是一组规则，旨在保护你的数据。添加验证规则以确保只有有效数据被写入你的数据库。
- en: Adding a Validation
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加验证
- en: Let’s look at an example. Because we’re making a blog, we should ensure that
    all posts have a title so readers don’t get confused, and we can do that with
    a validation rule.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。因为我们在做一个博客，所以我们应该确保所有帖子都有标题，以免读者感到困惑，我们可以通过验证规则来做到这一点。
- en: 'Validations are implemented as class methods in Rails. Open the post model
    (*app/models/post.rb*) in your editor and add this line:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 验证在 Rails 中作为类方法实现。打开你的帖子模型（*app/models/post.rb*）并添加这一行：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This validates the presence of text in the `title` field. Attempting to create
    a blog post with a blank title should now result in an error.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这会验证 `title` 字段中是否有文本。如果尝试创建没有标题的博客文章，现在应该会出现错误。
- en: Other Common Validations
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常见验证
- en: Rails provides a variety of other validations in addition to the `:presence`
    validation. For example, you can use the `:uniqueness` validation to ensure that
    no two posts have the same title.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `:presence` 验证，Rails 还提供了各种其他验证。例如，你可以使用 `:uniqueness` 验证，确保没有两篇帖子有相同的标题。
- en: 'The `:length` validation accepts a hash of options to confirm that the value
    is the correct length. Adding this line to your post model confirms that all titles
    are at least five characters:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`:length` 验证接受一个选项哈希，以确认值的长度是否正确。将这一行添加到你的帖子模型中，可以确保所有标题至少有五个字符：'
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can also specify a `:maximum` value instead of a `:minimum`, or you can
    use `:is` to set an exact value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以指定 `:maximum` 值来代替 `:minimum`，或者使用 `:is` 设置一个精确值。
- en: 'The `:exclusion` validation ensures the value does not belong to a given set
    of values. For example, adding this validation prohibits blog posts with the title
    *Title*:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`:exclusion` 验证确保值不属于给定的值集合。例如，添加此验证会禁止标题为 *Title* 的博客帖子：'
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can think of `:exclusion` as a blacklist for values you don’t want to allow.
    Rails also provides an `:inclusion` validation for specifying a whitelist of accepted
    values.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `:exclusion` 看作是不允许的值的黑名单。Rails 还提供了 `:inclusion` 验证，用于指定一个接受的值的白名单。
- en: Testing Data
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试数据
- en: 'Validations are automatically run before data is saved to the database. Attempt
    to store invalid data, and `save` returns `false`. You can also test a model manually
    with the `valid?` method:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 验证会在数据保存到数据库之前自动运行。如果尝试保存无效数据，`save` 会返回 `false`。你也可以手动测试模型，使用 `valid?` 方法：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, the `valid?` method should return `false` because you didn’t
    set a value for the title. Failing validations add messages to an array called
    `errors`, and calling `full_messages` on the `errors` array should return a list
    of error messages generated by Active Record based on your validations.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`valid?` 方法应该返回 `false`，因为你没有为标题设置值。验证失败会将消息添加到一个名为 `errors` 的数组中，调用
    `errors` 数组上的 `full_messages` 方法应该返回一个由 Active Record 根据你的验证生成的错误消息列表。
- en: Use validations freely to keep bad data out of your database, but also consider
    your users when you create those validations. Make it clear which values are valid,
    and display error messages if invalid data is given so the user can correct the
    mistake.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 自由使用验证规则以防止无效数据进入你的数据库，但在创建这些验证时，也要考虑到用户。清楚地指出哪些值是有效的，并在提供无效数据时显示错误消息，方便用户纠正错误。
- en: Associations
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联
- en: Only the simplest of applications contain a single model. As your application
    grows, you’ll need additional models, and as you add more, you’ll need to describe
    the relationships between them. Active Record *associations* describe the relationships
    between models. For example, let’s add comments to our blog posts.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 只有最简单的应用程序才包含一个单一模型。随着你的应用程序的增长，你会需要更多的模型，随着你添加更多模型，你需要描述它们之间的关系。Active Record
    *关联*描述了模型之间的关系。例如，让我们为博客帖子添加评论。
- en: Posts and comments are associated. Each post *has many* comments, and each comment
    *belongs to* a post. This *one-to-many* relationship is one of the most commonly
    used associations, and we’ll explore it here.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 帖子和评论是相关联的。每个帖子*有许多*评论，每个评论*属于*一个帖子。这种*一对多*关系是最常用的关联之一，我们将在这里探讨它。
- en: Generating the Model
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成模型
- en: 'A blog comment should have an author, a body, and a reference to a post. You
    can easily generate a model using that information:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个博客评论应该有一个作者、一个内容和一个指向帖子的引用。你可以轻松地使用这些信息生成一个模型：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Remember to run database migrations after generating this new model!*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*记得在生成新模型后运行数据库迁移！*'
- en: The `post:references` option tells the Rails generator to add a foreign key
    to the comments database table. In this case, the foreign key is named `post_id`
    because it refers to a post. The `post_id` field contains the `id` of this comment’s
    post. The migration created the column we need in the database, so now we need
    to edit our models to finish setting up the association.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`post:references` 选项告诉 Rails 生成器在评论数据库表中添加一个外键。在这种情况下，外键名为 `post_id`，因为它指向一个帖子。`post_id`
    字段包含该评论对应帖子的 `id`。迁移创建了我们在数据库中需要的列，现在我们需要编辑模型来完成关联设置。'
- en: Adding Associations
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加关联
- en: 'First, open *app/model/post.rb* again to add the comments association. Earlier
    I said that each post has many comments, and that’s the association we need here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，再次打开 *app/model/post.rb* 来添加评论关联。之前我提到过每个帖子有许多评论，这正是我们在这里需要的关联：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Rails uses a class method called `has_many` to create this association in a
    readable way. Now, edit *app/model/comment.rb*, and you’ll see that the Rails
    generator already added the matching `belongs_to` statement for you automatically:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Rails 使用一个叫做 `has_many` 的类方法以可读的方式创建这个关联。现在，编辑 *app/model/comment.rb*，你会看到 Rails
    生成器已经自动为你添加了匹配的 `belongs_to` 语句：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The post to comments association should now work as intended. If your Rails
    console was still running while you made these changes, you’ll need to restart
    it to see the effects.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，帖子到评论的关联应该能按预期工作。如果你的 Rails 控制台在你做这些更改时仍在运行，你需要重启它才能看到效果。
- en: Using Associations
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用关联
- en: When you create an association in a model, Rails automatically defines several
    methods for that model. Use these methods, and you won’t have to worry about keeping
    the `post_id` updated. They maintain this relationship for you automatically.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在模型中创建一个关联时，Rails 会自动为该模型定义几个方法。使用这些方法，你就不需要担心保持 `post_id` 更新了。它们会自动维护这个关系。
- en: The has_many Methods
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: has_many 方法
- en: 'The `has_many :comments` statement you saw inside `Post` defines several methods:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 `Post` 中看到的 `has_many :comments` 语句定义了几个方法：
- en: '****`comments`****. Returns an Active Record relation representing the array
    of comments for this post'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`comments`****。返回一个 Active Record 关系，表示该帖子的评论数组。'
- en: '****`comments<`****. Adds an existing comment to this post'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`comments<`****。将现有的评论添加到该帖子中。'
- en: '****`comments=`****. Replaces the existing array of comments for this post
    with a given array'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`comments=`****。用给定的评论数组替换该帖子的现有评论数组。'
- en: '****`comment_ids`****. Returns an array of the comment ids associated with
    this post'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`comment_ids`****。返回与该帖子相关联的评论 ID 数组。'
- en: '****`comment_ids=`****. Replaces the existing array of comments for this post
    with the comments corresponding to the given array of ids'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`comment_ids=`****。用给定的 ID 数组中的评论替换该帖子的现有评论数组。'
- en: 'Because the `comments` method returns a relation, it is commonly used with
    other methods. For example, you can create new comments associated with a post
    with `post.comments.build`, which builds a new comment belonging to this post,
    or `post.comments.create`, which creates a new comment belonging to this post
    and saves it to the database. Each of these methods automatically assigns the
    `post_id` of the newly created comment. This example creates a new comment associated
    with your first post. You should see the new comment in the output from `post.comments`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `comments` 方法返回的是一个关系，它通常与其他方法一起使用。例如，你可以使用 `post.comments.build` 创建与某个帖子相关的新评论，它会为该帖子构建一个新评论，或者使用
    `post.comments.create` 创建并保存一个新评论到数据库中。每个方法都会自动为新创建的评论分配 `post_id`。此示例为你的第一个帖子创建了一个新评论。你应该能在
    `post.comments` 的输出中看到新评论：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you want to check if any comments are associated with a post, use `comments.empty?`,
    which returns `true` if there are none. You might also find it helpful to know
    how many comments are associated with a particular post; in that case, you use
    `comments.size`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想检查是否有评论与某个帖子相关联，可以使用 `comments.empty?`，如果没有评论，则返回 `true`。你也许还会发现，知道某个帖子有多少个评论是很有用的；在这种情况下，你可以使用
    `comments.size`：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When you know a post has comments associated with it, you can look for a particular
    comment by passing `post.comments.find` a comment id. This method raises an `ActiveRecord::RecordNotFound`
    exception if a matching comment cannot be found belonging to this post. Use `post.comments.where`
    instead if you would rather not raise an exception. This method just returns an
    empty relation if a matching comment is not found.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道某个帖子有评论与之相关时，你可以通过传递评论 ID 给 `post.comments.find` 来查找特定评论。如果找不到与该帖子关联的匹配评论，该方法将抛出
    `ActiveRecord::RecordNotFound` 异常。如果你不想抛出异常，可以使用 `post.comments.where`，如果没有找到匹配的评论，该方法会返回一个空的关系。
- en: The belongs_to Methods
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属于 `belongs_to` 方法
- en: 'The `belongs_to :post` statement inside the `Comment` model defines five methods.
    Because `belongs_to` is a singular association (a comment can only belong to one
    post), all of these methods have singular names:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comment` 模型中的 `belongs_to :post` 语句定义了五个方法。由于 `belongs_to` 是单一关联（一个评论只能属于一个帖子），因此所有这些方法的名称都是单数形式：'
- en: '****`post`****. Returns an instance of the post that this comment belongs to'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`post`****。返回此评论所属帖子的实例'
- en: '****`post=`****. Assigns this comment to a different post'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`post=`****。将此评论分配给另一个帖子'
- en: '****`build_post`****. Builds a new post for this comment'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`build_post`****。为此评论构建一个新帖子'
- en: '****`create_post`****. Creates a new post for this comment and saves it to
    the database'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`create_post`****。为此评论创建一个新帖子并保存到数据库'
- en: '****`create_post!`**** Creates a new post for this comment but raises `ActiveRecord::RecordInvalid`
    if the post is not valid'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`create_post!`**** 为此评论创建一个新帖子，但如果帖子无效，则会抛出 `ActiveRecord::RecordInvalid`
    异常'
- en: 'These methods are the inverse of the methods defined in the `Post` model. Use
    them when you have a comment and you would like to manipulate its post. For example,
    let’s fetch the post associated with our first comment:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法是 `Post` 模型中定义的方法的逆操作。当你有一个评论并希望操作其关联的帖子时，可以使用它们。例如，下面我们来获取与我们第一个评论相关的帖子：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Calling `post` on the first comment, which is also our only comment so far,
    should return our first post. This confirms the association works both ways. Assuming
    you still have more than one post in your database, you can also assign this comment
    to a different post:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个评论上调用 `post`，它也是我们目前唯一的评论，应该会返回我们的第一个帖子。这证明了关联是双向有效的。如果你数据库中仍然有多个帖子，你也可以将此评论分配给另一个帖子：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Assigning a comment to another post updates the comment’s `post_id`, but does
    not write that to the database. Don’t forget to call `save` after updating the
    `post_id`! If you make this common mistake, the comment’s `post_id` won’t actually
    change.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将评论分配给另一个帖子会更新评论的 `post_id`，但不会写入数据库。更新 `post_id` 后别忘了调用 `save`！如果你犯了这个常见错误，评论的
    `post_id` 实际上是不会改变的。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has been a whirlwind tour of Active Record, so play around in the
    console until you’re comfortable with these ideas. Add more posts, update the
    existing posts with body text, and create comments associated with these posts.
    Focus on the CRUD operations and association methods in particular. These methods
    are commonly used in all Rails applications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本章对 Active Record 进行了快速概览，因此在控制台中练习，直到你对这些概念感到熟悉为止。增加更多的帖子，更新现有帖子的正文，并为这些帖子创建评论。特别关注
    CRUD 操作和关联方法。这些方法在所有 Rails 应用程序中都很常用。
- en: The next chapter covers Rails controllers. There, you’ll see all of these methods
    in use as you work your way through the various controller actions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍 Rails 控制器。在那里，你将看到所有这些方法在实际操作中是如何使用的，随着你一步步完成各种控制器动作。
- en: Exercises
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '| Q: | 1\. It might be nice to contact the people leaving comments on our blog.
    Generate a new migration to add a string column to the comments table to store
    an email address. Run this migration, and use the Rails console to verify that
    you can add an email address to comments now. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 问题： | 1\. 或许我们想联系一下那些在我们博客上留言的人。生成一个新的迁移，为评论表添加一个字符串列，用来存储电子邮件地址。运行这个迁移，并使用
    Rails 控制台验证你现在是否可以为评论添加电子邮件地址。 |'
- en: '| Q: | 2\. We need to ensure that users actually enter some text when they
    create a comment. Add validations to the comments model for the `author` and `body`
    fields. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 问题： | 2\. 我们需要确保用户在创建评论时实际上输入了一些文字。为评论模型中的`author`和`body`字段添加验证。 |'
- en: '| Q: | 3\. Write a query to determine the number of comments belonging to each
    post. You can’t do this with a single query, but you should be able to find the
    answer by iterating over a collection of posts as if it were an array. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 问题： | 3\. 写一个查询来确定每个帖子拥有的评论数量。你不能通过一个查询来完成，但你应该能够通过遍历帖子集合（就像它是一个数组一样）来找到答案。
    |'
