- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">BOOLEAN
    ALGEBRA AND THE LOOK-UP TABLE</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">布尔代数与查找表</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: Boolean algebra is a field of mathematics and logic essential to understanding
    how to work with devices like FPGAs. In Boolean algebra, the input and output
    values are all true or false, which we can equate with 1s and 0s, or high and
    low voltages. Instead of operations like multiplication and division, Boolean
    algebra has operations such as AND, OR, and NOT. Each of these operations takes
    in some number of 0s and 1s as input, evaluates them, and produces a 0 or 1 as
    an output. Algebra class would have been much simpler if it had been about Boolean
    algebra!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔代数是数学和逻辑领域的重要分支，理解它对于操作 FPGA 等设备至关重要。在布尔代数中，输入和输出的值只有真假两种，通常用 1 和 0，或者高低电压表示。与乘法和除法等运算不同，布尔代数包括与（AND）、或（OR）和非（NOT）等运算。每个运算接收一些
    0 和 1 作为输入，评估它们并输出 0 或 1。如果代数课讲的是布尔代数，它肯定会简单很多！
- en: 'You may have encountered Boolean operations in other programming languages,
    such as C or Python. For example, you might want your program to write to a file
    only if the user chooses to do so *and* the filename is valid. Similarly, inside
    an FPGA, you’ll often want to check multiple inputs to determine the state of
    an output. Let’s say you want to turn on an LED when either of two switches is
    pressed. An FPGA can make this happen using an OR operation: if either one switch
    *or* the other (or both) provides a 1 as an input, the FPGA provides a 1 as an
    output to the LED, and the LED lights up.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在其他编程语言中遇到过布尔运算，比如 C 或 Python。例如，你可能希望程序只有在用户选择后，并且文件名有效的情况下，才会写入文件。类似地，在
    FPGA 中，你经常需要检查多个输入，以确定输出的状态。假设你想在按下两个开关中的任意一个时点亮 LED。一个 FPGA 可以通过 OR 运算来实现这一点：如果任意一个开关*或*另一个（或者两个开关同时）提供
    1 作为输入，FPGA 就会输出 1 给 LED，LED 就会亮起。
- en: Boolean algebra makes tasks like this possible. But more importantly, Boolean
    algebra describes *all* the underlying operations on data in your FPGA. String
    together enough Boolean operations and you can do math, store data, and more.
    You can do a surprising amount by manipulating 1s and 0s.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔代数使得像这样的任务成为可能。但更重要的是，布尔代数描述了 FPGA 中所有底层的数据运算。将足够多的布尔运算串联在一起，你就能进行数学运算、存储数据，甚至更多。通过操作
    1 和 0，你可以做出令人惊讶的事情。
- en: In this chapter, we’ll explore how to represent simple Boolean operations with
    logic gates, and we’ll see how these gates can be combined into more complicated
    Boolean equations. Then we’ll explore how FPGAs actually perform logic operations
    by combining the functionality of different logic gates into a single device called
    a look-up table. As you’ll see, look-up tables are one of the most important components
    in an FPGA.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何用逻辑门表示简单的布尔运算，并了解这些逻辑门如何组合成更复杂的布尔方程。然后，我们将研究 FPGA 如何通过将不同逻辑门的功能结合到一个叫做查找表的单一设备中来执行逻辑运算。如你所见，查找表是
    FPGA 中最重要的组成部分之一。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Logic Gates and Their Truth Tables</samp>
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">逻辑门及其真值表</samp>
- en: When designing FPGAs, we represent simple Boolean operations with *logic gates*,
    devices that take in electrical signals as inputs, perform a Boolean operation
    on them, and produce the appropriate electrical signal as an output. There are
    different logic gates corresponding to all the different Boolean operations, such
    as AND, OR, NOT, XOR, and NAND. Each of these logic gates can be described with
    a *truth table*, a table that lists all the possible input combinations for a
    Boolean algebra equation and shows the corresponding outputs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计 FPGA 时，我们用*逻辑门*表示简单的布尔运算，逻辑门是一种接收电信号作为输入，对其进行布尔运算，并输出相应电信号的设备。针对各种布尔运算，如与（AND）、或（OR）、非（NOT）、异或（XOR）和与非（NAND），都有不同的逻辑门。每种逻辑门都可以通过*真值表*来描述，真值表列出了布尔代数方程的所有可能输入组合，并展示了相应的输出。
- en: 'We’ll discuss some common logic gates and examine their truth tables next.
    But first, it’s important to understand what the 1s and 0s in the truth tables
    we’ll be looking at actually mean. Inside an FPGA, digital data is represented
    by voltages: 0 volts for a 0, and some higher-than-zero voltage, called the *core
    voltage*, for a 1\. The core voltage depends on the specific FPGA, but often is
    around 0.8 to 1.2 volts. When we talk about a signal being *high*, we mean that
    the signal is at the core voltage and represents a data value of 1\. Likewise,
    a *low* signal is at 0 volts and represents a data value of 0\. With this in mind,
    let’s look at some logic gates.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来将讨论一些常见的逻辑门，并检查它们的真值表。但首先，重要的是要理解我们接下来要查看的真值表中的1和0究竟意味着什么。在 FPGA 内部，数字数据通过电压表示：0伏特表示0，某个高于0的电压，称为*核心电压*，表示1。核心电压依赖于具体的
    FPGA，但通常在0.8伏特到1.2伏特之间。当我们说一个信号是*高*时，我们指的是该信号处于核心电压状态，并表示数据值为1。类似地，*低*信号为0伏特，表示数据值为0。考虑到这一点，让我们来看一些逻辑门。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AND Gates</samp>
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">与门（AND Gates）</samp>
- en: An *AND gate* is a logic gate whose output is high when all its inputs are high.
    We’ll use the example of a two-input AND gate, but AND gates can have any number
    of inputs. For a two-input AND gate, the output is high when input A *and* input
    B are both high, hence the name AND gate. [Table 3-1](#tab3-1) shows the truth
    table for this AND gate. Notice that the output is a 1 only when both inputs are
    a 1.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*与门*是一种逻辑门，当所有输入都为高电平时，其输出为高电平。我们将以一个两输入与门为例，但与门可以有任意数量的输入。对于一个两输入与门，当输入 A
    *和* 输入 B 都为高电平时，输出才为高电平，这也是“与门”这个名称的由来。[表3-1](#tab3-1)显示了该与门的真值表。请注意，只有当两个输入都为1时，输出才为1。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-1:</samp> <samp class="SANS_Futura_Std_Book_11">Truth
    Table for a Two-Input AND Gate</samp>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表3-1：</samp> <samp class="SANS_Futura_Std_Book_11">两输入与门的真值表</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Input
    B</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Output Q</samp> |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">输入 A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输入
    B</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出 Q</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: In a truth table, the rows are usually arranged in increasing decimal order,
    based on the inputs. In the case of the AND truth table, the first row shows when
    input A = 0 and input B = 0, which is represented as <samp class="SANS_TheSansMonoCd_W5Regular_11">b00</samp>,
    which means <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> in binary,
    or 0 in decimal. Next comes <samp class="SANS_TheSansMonoCd_W5Regular_11">b01</samp>
    (decimal 1), then <samp class="SANS_TheSansMonoCd_W5Regular_11">b10</samp> (decimal
    2), then <samp class="SANS_TheSansMonoCd_W5Regular_11">b11</samp> (decimal 3).
    If the AND gate had additional inputs, then there would be more rows in our truth
    table that we would have to fill out. In the case of a three-input AND gate, for
    example, there would be eight rows, going from <samp class="SANS_TheSansMonoCd_W5Regular_11">b000</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">b111</samp>, or 0 to 7 in decimal.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在真值表中，行通常按输入的十进制顺序排列。在与门的真值表中，第一行表示输入 A = 0 和输入 B = 0，对应的表示为 <samp class="SANS_TheSansMonoCd_W5Regular_11">b00</samp>，即二进制的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>，或十进制的 0。接下来是 <samp class="SANS_TheSansMonoCd_W5Regular_11">b01</samp>（十进制
    1），然后是 <samp class="SANS_TheSansMonoCd_W5Regular_11">b10</samp>（十进制 2），接着是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b11</samp>（十进制 3）。如果与门有额外的输入，那么我们的真值表中将有更多的行需要填写。例如，对于一个三输入的与门，真值表会有八行，从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b000</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">b111</samp>，即从十进制的
    0 到 7。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*The output of a logic gate is denoted with a Q. This convention comes from
    the English mathematician Alan Turing, who used the letter Q to denote states
    in his famous Turing machines. The Q stood for* quanta*, which is a discrete state
    (such as 0 or 1), rather than something that can have a continuous range of values.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*逻辑门的输出用 Q 表示。这个约定源于英国数学家艾伦·图灵，他在著名的图灵机中使用字母 Q 来表示状态。Q 代表*量子*，这是一个离散状态（例如 0
    或 1），而不是一个可以具有连续值范围的状态。*'
- en: Each logic gate has a distinctive symbol for use in schematics. A two-input
    AND gate is drawn as shown in [Figure 3-1](#fig3-1). The symbol depicts the inputs
    A and B going into the gate on the left, and the output Q emerging on the right.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个逻辑门都有一个独特的符号，用于电路图中。两个输入的与门符号如[图 3-1](#fig3-1)所示。该符号表示输入 A 和 B 从左侧进入门，而输出
    Q 从右侧出来。
- en: '![](../images/Figure3-1.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: The AND gate symbol</samp>'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-1：与门符号</samp>
- en: As we continue our exploration of logic gates, most of the gates we’ll look
    at will have two inputs and one output. As with AND gates, it’s possible that
    these other types of gates could have additional inputs, but for simplicity we’ll
    stick to the two-input versions. (The exception is the NOT gate, which can only
    have one input and one output.) For brevity, I’ll omit the words *two-input* from
    this point forward when referring to a given logic gate.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们对逻辑门的进一步探索，大多数我们要研究的门都有两个输入和一个输出。和与门一样，这些其他类型的门也可能有额外的输入，但为了简化起见，我们将仅讨论两个输入的版本。（例外是非门，它只有一个输入和一个输出。）为了简便，从现在起提到某个逻辑门时，我将省略*两个输入*这一描述。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">OR Gates</samp>
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">或门</samp>
- en: An *OR gate* ([Figure 3-2](#fig3-2)) is a logic gate whose output is high when
    either of the inputs is high; that is, when either input A *or* input B is high.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*或门*（[图 3-2](#fig3-2)）是一种逻辑门，当任一输入为高电平时，输出为高电平；即当输入 A *或* 输入 B 为高电平时，输出为高电平。'
- en: '![](../images/Figure3-2.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: The OR gate symbol</samp>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-2：或门符号</samp>
- en: '[Table 3-2](#tab3-2) shows the truth table for an OR gate.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-2](#tab3-2) 显示了或门的真值表。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-2:</samp> <samp class="SANS_Futura_Std_Book_11">Truth
    Table for an OR Gate</samp>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-2：</samp> <samp class="SANS_Futura_Std_Book_11">或门的真值表</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Input
    B</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Output Q</samp> |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">输入 A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输入
    B</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出 Q</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: Notice that when both inputs are high, the OR gate’s output is high as well.
    All that matters to an OR gate is that at least one of the inputs is high, which
    is also the case when both inputs are high.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当两个输入都是高电平时，OR门的输出也是高电平。对于OR门，唯一重要的是至少有一个输入是高电平，这在两个输入都是高电平时也成立。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NOT Gates</samp>
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NOT门</samp>
- en: A *NOT gate* ([Figure 3-3](#fig3-3)) has a single input and a single output.
    This kind of gate simply inverts the input (the output is *not* the input), so
    it’s also known as an inverter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*NOT门*（[图3-3](#fig3-3)）有一个输入和一个输出。这种门简单地将输入反转（输出不是输入），因此也称为反转器。
- en: '![](../images/Figure3-3.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: The NOT gate symbol</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图3-3：NOT门符号</samp>
- en: Notice the bubble at the tip of the triangle in the NOT gate symbol, which indicates
    inversion. It also appears in the NAND gate, which we’ll look at later, and can
    even appear on some inputs. The truth table for a NOT gate is shown in [Table
    3-3](#tab3-3).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意NOT门符号三角形尖端的气泡，它表示反转。它也出现在NAND门中，我们稍后会讨论，还可能出现在某些输入上。NOT门的真值表见于[表3-3](#tab3-3)。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-3:</samp> <samp class="SANS_Futura_Std_Book_11">Truth
    Table for a NOT Gate</samp>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表3-3：</samp> <samp class="SANS_Futura_Std_Book_11">NOT门的真值表</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Output
    Q</samp> |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">输入A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出Q</samp>
    |'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    |'
- en: As the truth table indicates, whatever the input value to the gate is, the output
    is the opposite.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如真值表所示，无论门的输入值是什么，输出都是相反的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">XOR Gates</samp>
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">XOR门</samp>
- en: The output of an *XOR gate* (pronounced “ex-or,” short for *exclusive or*) is
    high when either of the inputs is high, but not both. In other words, the gate
    checks for exclusively one or the other input being high. The symbol for an XOR
    gate is shown in [Figure 3-4](#fig3-4).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*XOR门*（发音为“ex-or”，即*异或*）的输出当且仅当其中一个输入为高电平时为高电平，而当两个输入都为高电平时输出为低电平。换句话说，门检测是否仅有一个输入为高电平。XOR门的符号见于[图3-4](#fig3-4)。'
- en: '![](../images/Figure3-4.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-4: The XOR gate symbol</samp>'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图3-4：XOR门符号</samp>
- en: The symbol looks like that of an OR gate, but the extra line on the left side
    of the gate sets it apart. [Table 3-4](#tab3-4) shows the XOR gate’s truth table.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 该符号看起来像OR门的符号，但左侧的额外线条将其区分开来。[表3-4](#tab3-4)展示了XOR门的真值表。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-4:</samp> <samp class="SANS_Futura_Std_Book_11">Truth
    Table for an XOR Gate</samp>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表3-4：</samp> <samp class="SANS_Futura_Std_Book_11">XOR门的真值表</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Input
    B</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Output Q</samp> |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">输入A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输入B</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">输出Q</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: Though this type of gate might not seem particularly useful at first blush,
    it comes up more often than you might expect. For example, XOR gates are used
    for generating a *cyclic redundancy check (CRC)*, a way to validate data to verify
    the integrity of transmitted information.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种类型的门乍一看似乎并不特别有用，但它的应用比你想象的要频繁。例如，XOR 门用于生成 *循环冗余校验（CRC）*，一种验证数据完整性的方法，用于确保传输信息的正确性。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NAND Gates</samp>
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NAND 门</samp>
- en: 'A *NAND gate* (short for *not and*) has the opposite output of an AND gate.
    You can infer this from the NAND gate’s schematic symbol, shown in [Figure 3-5](#fig3-5):
    it looks exactly like an AND gate, except with a bubble on the output to indicate
    an inversion.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*NAND 门*（即 *非与门*）的输出与 AND 门相反。你可以从 NAND 门的电路符号中推断这一点，参见 [图 3-5](#fig3-5)：它看起来与
    AND 门完全相同，只是输出端多了一个圆圈表示取反。'
- en: '![](../images/Figure3-5.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-5: The NAND gate symbol</samp>'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-5：NAND 门符号</samp>
- en: The output of the NAND gate is thus the same as an AND gate, but inverted. If
    both input A and input B are high, output Q will be low. In all other cases, output
    Q will be high. This is shown in the truth table in [Table 3-5](#tab3-5).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，NAND 门的输出与 AND 门相同，但取反。如果输入 A 和输入 B 都为高电平，输出 Q 将为低电平。在其他所有情况下，输出 Q 将为高电平。这个逻辑在
    [表 3-5](#tab3-5) 的真值表中有所展示。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-5:</samp> <samp class="SANS_Futura_Std_Book_11">Truth
    Table for a NAND Gate</samp>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-5：</samp> <samp class="SANS_Futura_Std_Book_11">NAND
    门的真值表</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Input
    B</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Output Q</samp> |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">输入 A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输入
    B</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出 Q</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: NAND gates are commonly used in USB flash drives, solid state drives (SSDs),
    and other types of data storage devices. They also inspired the name of my website,
    [*https://<wbr>nandland<wbr>.com*](https://nandland.com).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: NAND 门广泛应用于 USB 闪存、固态硬盘（SSD）和其他类型的数据存储设备。它们也启发了我的网站名称，[*https://<wbr>nandland<wbr>.com*](https://nandland.com)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Other Gates</samp>
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">其他门</samp>
- en: We’ve explored the most common types of logic gates here to give you an idea
    of how they work, but this isn’t an exhaustive list. There are other types as
    well, such as NOR (short for *not or*) and XNOR (*exclusive not or*) gates. Additionally,
    as mentioned previously, though we focused on the two-input versions here, all
    of these gates (with the exception of NOT) can have more than two inputs. This
    section was just intended to get you comfortable with the standard logic operations
    from Boolean algebra. Next, we’ll explore how these operations can be combined
    to make more complicated expressions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里探讨了最常见的几种逻辑门，以帮助你理解它们是如何工作的，但这并不是一个详尽无遗的列表。还有其他类型的逻辑门，例如 NOR（即*非或*）和 XNOR（*异或非*）门。此外，正如前面所提到的，虽然我们在这里集中讲解了两输入版本，但所有这些门（除了NOT）都可以有多个输入。本节旨在帮助你熟悉布尔代数中的标准逻辑运算。接下来，我们将探讨如何将这些运算组合起来，构建更复杂的表达式。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Combining Gates with Boolean Algebra</samp>
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">将门与布尔代数结合</samp>
- en: You’ve seen how individual logic gates work. However, often you’ll want to write
    code that’s more complex than just a single logic operation. The good news is
    that you can chain together multiple logic gates to represent more elaborate Boolean
    equations, and use Boolean algebra to determine the outcome.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了单个逻辑门的工作原理。然而，通常你可能需要编写比单一逻辑运算更复杂的代码。好消息是，你可以将多个逻辑门链接起来，表示更复杂的布尔方程，并使用布尔代数来确定结果。
- en: In Boolean algebra, each logic operation has its own symbol. One common set
    of symbols is shown in [Table 3-6](#tab3-6). For example, * represents an AND
    operation, and + represents an OR operation. These symbols make it easier to write
    more elaborate Boolean algebraic equations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在布尔代数中，每个逻辑运算都有其独特的符号。一组常见的符号在[表 3-6](#tab3-6)中展示。例如，*表示与运算，而+表示或运算。这些符号使得编写更复杂的布尔代数方程变得更加简便。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-6:</samp> <samp class="SANS_Futura_Std_Book_11">Boolean
    Algebra Symbols</samp>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-6：</samp> <samp class="SANS_Futura_Std_Book_11">布尔代数符号</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Symbol</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Meaning</samp>
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">符号</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">含义</samp>
    |'
- en: '| --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">AND</samp>
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">与</samp>
    |'
- en: '| + | <samp class="SANS_Futura_Std_Book_11">OR</samp> |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| + | <samp class="SANS_Futura_Std_Book_11">或</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">′</samp> | <samp class="SANS_Futura_Std_Book_11">NOT</samp>
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">′</samp> | <samp class="SANS_Futura_Std_Book_11">非</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">^</samp> | <samp class="SANS_Futura_Std_Book_11">XOR</samp>
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">^</samp> | <samp class="SANS_Futura_Std_Book_11">异或</samp>
    |'
- en: Boolean algebra also has its own *order of operations*. To solve a Boolean equation,
    first you evaluate NOTs, then ANDs, and finally ORs. As in conventional algebra,
    you can use parentheses to bypass the order of operations; anything in parentheses
    will be evaluated first.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔代数还有自己的*运算顺序*。要解决一个布尔方程，首先要计算非（NOT），然后是与（AND），最后是或（OR）。与常规代数一样，你可以使用括号来绕过运算顺序；括号中的内容将首先计算。
- en: You now know everything you need to write and evaluate Boolean equations with
    more than one logic operation, such as Q = A * B + A<samp class="SANS_Futura_Std_Book_11">′</samp>.
    In plain language, you’d read this as “The output Q equals A *and* B *or not*
    A.” [Table 3-7](#tab3-7) shows the truth table for this equation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经知道如何编写和评估包含多个逻辑运算的布尔方程，比如Q = A * B + A<samp class="SANS_Futura_Std_Book_11">′</samp>。用简单的语言来讲，你可以把它读作：“输出Q等于A
    *与* B *或非* A。”[表 3-7](#tab3-7)展示了这个方程的真值表。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-7:</samp> <samp class="SANS_Futura_Std_Book_11">Truth
    Table for A * B</samp> + <samp class="SANS_Futura_Std_Book_11">A′</samp>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-7：</samp> <samp class="SANS_Futura_Std_Book_11">A
    * B</samp> + <samp class="SANS_Futura_Std_Book_11">A′</samp> 的真值表
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Input
    B</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Output Q</samp> |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">输入 A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输入
    B</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出 Q</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '[Figure 3-6](#fig3-6) shows the circuit equivalent of this equation, created
    by combining logic gates.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-6](#fig3-6)显示了这个方程的电路等效图，它是通过组合逻辑门构建的。'
- en: '![](../images/Figure3-6.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-6: The circuit diagram
    for A * B</samp> + <samp class="SANS_Futura_Std_Book_Oblique_I_11">A</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">′</samp>'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-6：A * B</samp> + <samp class="SANS_Futura_Std_Book_Oblique_I_11">A</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">′</samp> 的电路图
- en: As you can see, we still have only two inputs, but because those inputs go through
    three different logic operations, the possible outputs of our truth table are
    more interesting than they were for individual logic gates. Let’s consider what
    happens with this equation when both inputs are 0, the first row of our truth
    table. The equation has no parentheses, so first we look at NOT A, which evaluates
    to 1\. Then we perform the AND operation of A and B, which evaluates to 0\. Finally,
    we OR the results of both of those expressions, giving us an output of 1\. Considering
    the other possible inputs, you should see that any time A is 0, or any time A
    and B are both 1, the output Q will be 1\. Otherwise, the output will be 0.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，尽管我们依然只有两个输入，但由于这些输入经过三种不同的逻辑运算，我们的真值表的可能输出比单独的逻辑门更有趣。让我们考虑当两个输入都为 0 时（真值表中的第一行）这个方程的情况。方程中没有括号，所以我们首先看
    NOT A，结果为 1。然后我们进行 A 和 B 的“与”操作，结果为 0。最后，我们对这两种表达式的结果进行“或”操作，得到输出 1。考虑到其他可能的输入，你应该会看到，每当
    A 为 0，或者 A 和 B 都为 1 时，输出 Q 都为 1。否则，输出为 0。
- en: 'While this example featured two inputs, it’s possible to have Boolean equations
    with any number of inputs. Each input increases the number of rows in the truth
    table by a factor of 2: for one input there are two truth table rows, for two
    inputs there are four rows, for three inputs there are eight rows, and so on.
    In mathematical terms, for *n* inputs, there are 2*^n* truth table rows.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子只有两个输入，但布尔方程可以有任意数量的输入。每增加一个输入，真值表中的行数就会增加一倍：一个输入时有两行，两个输入时有四行，三个输入时有八行，以此类推。用数学术语表示，对于
    *n* 个输入，真值表有 2*^n* 行。
- en: 'To demonstrate, let’s consider an example equation with three inputs: Q = A
    + (C * B′). Note that the parentheses indicate that the operation C AND NOT B
    occurs prior to the OR operation. In fact, that follows the regular Boolean algebra
    order of operations, but the parentheses make the equation a little easier to
    read. The truth table with three inputs is shown in [Table 3-8](#tab3-8).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，让我们考虑一个有三个输入的示例方程：Q = A + (C * B′)。注意，括号表示在执行“或”操作之前，先进行“与非”操作。这实际上遵循了常规的布尔代数操作顺序，但括号使得方程更易读。包含三个输入的真值表见[表
    3-8](#tab3-8)。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-8:</samp> <samp class="SANS_Futura_Std_Book_11">Truth
    Table for A</samp> + <samp class="SANS_Futura_Std_Book_11">(C * B′)</samp>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-8：</samp> <samp class="SANS_Futura_Std_Book_11">A</samp>
    + <samp class="SANS_Futura_Std_Book_11">(C * B′)</samp> 的真值表
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Input
    B</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Input C</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Output
    Q</samp> |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">输入 A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输入
    B</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输入 C</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出
    Q</samp> |'
- en: '| --- | --- | --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
- en: The corresponding circuit is shown in [Figure 3-7](#fig3-7).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的电路如[图 3-7](#fig3-7)所示。
- en: '![](../images/Figure3-7.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-7: The circuit diagram
    for A</samp> + <samp class="SANS_Futura_Std_Book_Oblique_I_11">(C * B</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">′</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">)</samp>'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-7：A 的电路图</samp> + <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">(C * B</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">′</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">)</samp>
- en: To generate this truth table, first we should perform the operation inside the
    parentheses. This is C AND NOT B. Within the parentheses, the highest precedence
    is the inversion applied to B, which is then ANDed with C. In all, the part of
    the equation in parentheses evaluates to high when C is high and B is low, and
    since the remainder of the equation is an OR operation, we also know that the
    overall output will be high when C is high and B is low. This case occurs on the
    second line of the truth table. It also occurs on the fifth line of the truth
    table, so we can fill those in with a 1\. Finally, consider the A on the other
    side of the OR operation. When it’s high, as in the last four lines of the truth
    table, the output will be high. We can fill in the remaining lines with a 0 to
    complete the truth table.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成这个真值表，首先我们应该执行括号内的操作。这是 C AND NOT B。在括号内，最高优先级是对 B 应用的取反运算，之后与 C 进行与（AND）运算。总的来说，当
    C 为高电平且 B 为低电平时，括号内的部分会得到高电平。由于方程的其余部分是或（OR）运算，我们也可以知道当 C 为高电平且 B 为低电平时，整体输出为高电平。这个情况出现在真值表的第二行，也出现在第五行，所以我们可以将这两行填上
    1。最后，考虑 OR 运算符另一边的 A。当 A 为高电平时，如真值表中的最后四行，输出将为高电平。我们可以将剩余的行填上 0 来完成真值表。
- en: Combining logic operations to perform more complicated functionality is common
    throughout programming. In FPGAs, this same capability is possible by chaining
    together simple logic gate functions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，将逻辑运算组合起来以执行更复杂的功能是很常见的。在 FPGA 中，通过将简单的逻辑门功能连接在一起，也可以实现相同的功能。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Look-Up Table</samp>
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">查找表</samp>
- en: 'So far we’ve been learning about individual logic gates, but it might surprise
    you to find out that these logic gates don’t physically exist inside an FPGA.
    There isn’t a bank of AND gates and OR gates that you can just pull from and wire
    together to create your Boolean algebra logic. Instead, there’s something much
    better: *look-up tables (LUTs)*. These are devices that can be programmed to perform
    any Boolean algebra equation you can think of, regardless of the specific logic
    gate(s) involved. If you need an AND gate, a LUT can do it. If you need an XOR
    gate, a LUT can do that too. A single LUT can also evaluate an equation involving
    multiple logic gates, like the ones we considered in the previous section. Any
    truth table you can think of, a LUT can produce. This is the power of the look-up
    table.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在学习个别的逻辑门，但你可能会惊讶地发现，这些逻辑门在 FPGA 中并不真正存在。没有一个与门和或门的阵列，供你随意取用并连接起来创建布尔代数逻辑。相反，存在着更好的东西：*查找表（LUTs）*。这些设备可以被编程为执行你能想到的任何布尔代数方程，无论涉及到哪些特定的逻辑门。如果你需要一个与门，一个查找表就可以完成。如果你需要一个异或门，查找表也能做到。一个查找表也可以评估一个包含多个逻辑门的方程，就像我们在前一节中考虑的那样。任何你能想到的真值表，查找表都能生成。这就是查找表的强大之处。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Early programmable logic devices like Programmable Array Logic (PAL) did actually
    have banks of AND and OR gates. With FPGAs, these have been superseded by the
    more capable LUTs.*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*早期的可编程逻辑设备，如可编程阵列逻辑（PAL），确实有与门和或门阵列。而在 FPGA 中，这些已被更强大的查找表（LUTs）所取代。*'
- en: LUTs are classified by the number of inputs they can accept. For example, there
    are two-, three-, four-, five-, and even six-input LUTs on the newest FPGAs. Most
    LUTs produce a single output. [Figure 3-8](#fig3-8) shows what a three-input LUT
    (often referred to as LUT-3) looks like.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 查找表（LUT）按它们能接受的输入数量分类。例如，最新的 FPGA 上有二输入、三输入、四输入、五输入，甚至六输入的查找表。大多数查找表产生单一的输出。[图
    3-8](#fig3-8)展示了一个三输入查找表（通常称为 LUT-3）的样子。
- en: '![](../images/Figure3-8.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-8.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-8: A three-input LUT</samp>'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-8：一个三输入查找表（LUT）</samp>
- en: This LUT is a blank slate that can be programmed to perform any Boolean algebra
    operation with three inputs and one output. For example, look back at the circuit
    drawn in [Figure 3-7](#fig3-7) to represent the Boolean equation Q = A + (C *
    B′). Drawing the circuit for that equation required three logic gates—a NOT gate,
    an AND gate, and an OR gate—but we can replace those three gates with our single
    three-input LUT. The same LUT could also be programmed to represent the equation
    Q = (A + B + C)′, or Q = (A + B)′ * C.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查找表是一个空白的基板，可以编程执行任何具有三输入和一个输出的布尔代数操作。例如，回顾一下[图 3-7](#fig3-7)中的电路，该电路表示布尔方程
    Q = A + (C * B′)。绘制该方程的电路需要三个逻辑门——一个非门、一个与门和一个或门——但我们可以用一个三输入查找表来替代这三个逻辑门。这个查找表也可以被编程为表示方程
    Q = (A + B + C)′，或者 Q = (A + B)′ * C。
- en: 'What happens if we have a Boolean algebra equation with more than three inputs?
    That’s just fine, as LUTs can be chained together to perform very long sequences
    of logic. In fact, the typical FPGA contains hundreds or even thousands of LUTs,
    all ready to be programmed to carry out whatever logic operations you need. This
    is why look-up tables are one of the two most important components to understand
    inside of an FPGA: they perform the logical operations of your code. The other
    key component is the flip-flop, which we’ll talk about in the next chapter.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个包含超过三个输入的布尔代数方程，会发生什么呢？这没问题，因为可以将查找表串联在一起执行非常长的逻辑序列。实际上，典型的 FPGA 包含数百甚至数千个查找表，随时可以编程以执行你需要的任何逻辑操作。这就是为什么查找表是
    FPGA 中两个最重要的组件之一：它们执行你代码中的逻辑操作。另一个关键组件是触发器，我们将在下一章讨论。
- en: 'Although we’ve been drawing truth tables and logic gate diagrams here, in the
    real world you’ll rarely define FPGA operations this way. Instead, you’ll write
    code. Often, the code you write is at a higher level than individual logic gates:
    you might write code to compare two numbers, or increment a counter, or check
    if a condition is true, and the synthesis tools then break down that code into
    the necessary Boolean logic operations and assign those operations to LUTs. However,
    the purpose of this book is to teach you how FPGAs work so you understand them,
    and at a fundamental level, FPGAs work by performing Boolean algebra. Once you
    know how FPGAs work, you’ll be able to use Verilog or VHDL with a deeper understanding
    of what you’re creating with your code. This will help you create efficient and
    reliable FPGA designs.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在这里绘制了真值表和逻辑门图，但在实际应用中，你很少会用这种方式定义 FPGA 操作。相反，你会编写代码。通常，你写的代码会比单独的逻辑门更高层次：你可能会编写代码来比较两个数字、增加计数器或检查条件是否为真，然后综合工具会将代码拆解成必要的布尔逻辑操作，并将这些操作分配给查找表（LUT）。然而，本书的目的是教你理解
    FPGA 的工作原理，从根本上说，FPGA 通过执行布尔代数来工作。一旦你了解了 FPGA 的工作原理，你将能够更深入地理解你用代码创建的内容，并能更好地使用
    Verilog 或 VHDL。这将帮助你创建高效且可靠的 FPGA 设计。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #2: Lighting an LED with Logic
    Gates</samp>'
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #2：用逻辑门点亮 LED</samp>'
- en: You’re now ready to combine everything you’ve learned about Boolean logic and
    look-up tables in a real-world example on your FPGA development board. This project
    should illuminate an LED, but only when two switches are pushed at the same time.
    In other words, you’re using your first LUT by implementing an AND gate. [Figure
    3-9](#fig3-9) shows the block diagram for this project.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好将你学到的布尔逻辑和查找表知识应用到 FPGA 开发板上的实际例子中了。这个项目应该会点亮一个 LED，但只有当两个开关同时被按下时才会点亮。换句话说，你通过实现与门（AND
    gate）来使用你的第一个 LUT。[图 3-9](#fig3-9) 显示了这个项目的框图。
- en: '![](../images/Figure3-9.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-9.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-9: The Project #2
    block diagram</samp>'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-9：项目 #2 的框图</samp>'
- en: This project turns the entire FPGA into one single AND gate. This might be overkill
    for a very capable FPGA, but it’s an excellent way to visualize how a LUT works
    in the real world. [Table 3-9](#tab3-9) shows the truth table corresponding to
    the project.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目将整个 FPGA 转变为一个单一的与门。对于一个非常强大的 FPGA 来说，这可能有些过头，但它是一个很好的方法来直观展示 LUT 在实际中的工作原理。[表
    3-9](#tab3-9) 显示了与这个项目相对应的真值表。
- en: '<samp class="SANS_Futura_Std_Heavy_B_11">Table 3-9:</samp> <samp class="SANS_Futura_Std_Book_11">Truth
    Table for Project #2</samp>'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_11">表 3-9：</samp> <samp class="SANS_Futura_Std_Book_11">项目
    #2 的真值表</samp>'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">SW1</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">SW2</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">D1</samp> |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">SW1</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">SW2</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">D1</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: This truth table looks exactly like the one we created for the AND gate, but
    the column labels have been replaced to represent two switches and an LED on your
    development board. As expected, the output D1 is only high when inputs SW1 and
    SW2 are both high.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个真值表看起来和我们为与门（AND gate）创建的真值表完全一样，不过列标签已经被替换为表示开发板上的两个开关和一个 LED。正如预期的那样，只有当输入
    SW1 和 SW2 都为高电平时，输出 D1 才会为高电平。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Code</samp>
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">编写代码</samp>
- en: 'Implementing an AND gate uses very few resources: three connections (two input
    and one output) and a single LUT. Let’s look at the Verilog and VHDL to get that
    LED to light up:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个与门（AND gate）使用的资源非常少：三个连接（两个输入和一个输出）以及一个LUT。让我们看看如何通过Verilog和VHDL使LED亮起：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE0]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE1]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We begin by defining our inputs as <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_2</samp>, and our output
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>. Then we continuously
    assign the output with the AND of the two inputs ❶. In Verilog the symbol for
    an AND operation is <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>, whereas
    in VHDL <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp> is a reserved
    keyword.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将输入定义为 <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp> 和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_2</samp>，输出定义为 <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>。然后，我们持续将输出与两个输入的与运算进行赋值❶。在Verilog中，与运算的符号是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>，而在VHDL中，<samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>
    是一个保留关键字。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building and Programming
    the FPGA</samp>
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">构建和编程FPGA</samp>
- en: 'You’re now ready to run your Verilog or VHDL through the build process discussed
    in [Chapter 2](chapter2.xhtml). The synthesis tool will generate a report outlining
    the resource utilization on your FPGA. Here’s the most interesting part of the
    report:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好将你的Verilog或VHDL代码通过[第2章](chapter2.xhtml)中讨论的构建过程运行。综合工具将生成一份报告，概述FPGA上的资源利用情况。以下是报告中最有趣的部分：
- en: '[PRE2]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This report tells us that three I/O ports (input/output ports, or pins, meaning
    connections to the outside world) on the FPGA have been used to implement our
    circuit design ❶ and, most importantly, that we’ve used a single LUT ❷. That <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(0%)</samp> on the last line is indicating
    the resource utilization on the FPGA. On this particular FPGA there are over 1,000
    LUTs available for usage, and we’re only making use of 1 of them. Since the synthesis
    report is showing one LUT with 0 percent resource utilization, the tool must be
    doing some rounding down here (1 / 1,000 = 0.1).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本报告告诉我们，FPGA上的三个I/O端口（输入/输出端口，或称引脚，意味着与外部世界的连接）已被用于实现我们的电路设计❶，最重要的是，我们使用了一个LUT❷。最后一行中的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0%)</samp> 表示FPGA上的资源利用率。在这个特定的FPGA上，有超过1000个LUT可供使用，而我们只使用了其中的1个。由于综合报告显示一个LUT的资源利用率为0%，工具可能在此处进行了四舍五入（1
    / 1,000 = 0.1）。
- en: Go ahead and program your development board, and notice that the LED only illuminates
    when the two switches are held down together. The LUT is working!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请继续编程你的开发板，注意到只有在两个开关同时按下时，LED才会亮起。LUT在正常工作！
- en: Feel free to change the code around to implement a different Boolean operation
    than AND. For example, you could create an OR gate or an XOR gate using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">|</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>
    symbols in Verilog, or the <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp> keywords in VHDL.
    You could also try stringing together several operations to make the LED light
    up based on whatever crazy Boolean algebra equation you can think of, or try adding
    in more switch inputs or more LED outputs to implement more complicated truth
    tables. You can check that the synthesis tools are really generating the correct
    LUTs based on your code by writing out your own truth table using the switches
    as inputs and the LED as the output, then testing all possible switch combinations
    to see if they work as expected.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随意修改代码，使用与（AND）以外的其他布尔运算。例如，你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp> 符号在Verilog中创建一个或门（OR
    gate）或异或门（XOR gate），或者使用VHDL中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp> 关键字。你还可以尝试将多个运算结合起来，使LED根据你想到的任何复杂布尔代数方程亮起，或者尝试增加更多的开关输入或LED输出来实现更复杂的真值表。你可以通过编写你自己的真值表，使用开关作为输入，LED作为输出，然后测试所有可能的开关组合，查看它们是否按预期工作，来检查综合工具是否真的根据你的代码生成了正确的LUT。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: 'In this chapter you’ve learned about one of the two most important components
    of an FPGA: the look-up table. You’ve seen how a LUT can implement any Boolean
    algebra equation with a given number of inputs, from simple logic gates like AND,
    OR, NOT, XOR, and NAND to more complex equations that combine these gates. In
    the next chapter, we’ll focus on the other crucial FPGA component: the flip-flop.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了 FPGA 两个最重要组成部分之一：查找表（LUT）。你已经看到，LUT 可以通过给定数量的输入实现任何布尔代数方程，从简单的逻辑门（如与门（AND）、或门（OR）、非门（NOT）、异或门（XOR）和与非门（NAND））到将这些门组合起来的更复杂的方程式。在下一章中，我们将重点介绍另一个关键的
    FPGA 组件：触发器（flip-flop）。
