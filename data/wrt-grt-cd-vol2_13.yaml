- en: '**13**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**13**'
- en: '**CONTROL STRUCTURES AND PROGRAMMATIC DECISIONS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制结构和程序决策**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: 'Control structures are the bread and butter of high-level language (HLL) programming.
    The ability to make decisions based on the evaluation of stated conditions is
    fundamental to practically every kind of automation that computers provide. The
    translation of HLL control structures into machine code has, perhaps, the largest
    impact on program performance and size. As you’ll see in this chapter, knowing
    which control structures to use in a given situation is the key to writing great
    code. In particular, this chapter describes the machine implementation of control
    structures related to decision making and unconditional flow, including:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 控制结构是高级语言（HLL）编程的核心。根据给定条件的评估做出决策的能力，对于计算机提供的几乎所有自动化任务都是基础。高级语言控制结构转化为机器码的过程，可能对程序的性能和大小产生最大的影响。正如你将在本章中看到的，知道在特定情况下使用哪种控制结构是编写出色代码的关键。特别是，本章描述了与决策和无条件流相关的控制结构的机器实现，包括：
- en: '`if` statements'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` 语句'
- en: '`switch` or `case` statements'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch` 或 `case` 语句'
- en: '`goto` and related statements'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`goto` 及相关语句'
- en: The following two chapters will expand this discussion to loop control structures
    and procedure/function calls and returns.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两章将扩展讨论循环控制结构及过程/函数调用与返回。
- en: '**13.1 How Control Structures Affect a Program’s Efficiency**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**13.1 控制结构如何影响程序效率**'
- en: A fair percentage of the machine instructions in a program control the execution
    path through that program. Because control transfer instructions often flush the
    instruction pipeline (see *WGC1*), they tend to be slower than instructions that
    perform simple calculations. To produce efficient programs, you should reduce
    the number of control transfer instructions or, if that’s not possible, choose
    the fastest ones.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中相当一部分机器指令控制着程序的执行路径。由于控制转移指令通常会清空指令流水线（参见 *WGC1*），它们往往比执行简单计算的指令要慢。为了生成高效的程序，你应该减少控制转移指令的数量，或者如果无法避免，选择最快的指令。
- en: The exact set of instructions that CPUs use to control program flow varies across
    processors. Nevertheless, many CPUs (including the five families covered in this
    book) control program flow using the “compare-and-jump” paradigm. That is, after
    a compare or another instruction that modifies the CPU flags, a conditional jump
    instruction transfers control to another location based on the CPU flag settings.
    Some CPUs can do all this with a single instruction, while others require two,
    three, or more. Some CPUs allow you to compare two values for a large range of
    different conditions, whereas others allow only a few tests. Regardless of the
    mechanism, HLL statements that map to a given sequence on one CPU will map to
    a comparable sequence on a second CPU. Therefore, if you understand the basic
    conversion for one CPU, you’ll have a good idea how the compiler works across
    all CPUs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: CPUs 用于控制程序流的指令集在不同处理器之间有所不同。然而，许多 CPU（包括本书所涵盖的五个家族）使用“比较与跳转”范式来控制程序流。也就是说，在进行比较或其他修改
    CPU 标志的指令后，条件跳转指令会根据 CPU 标志设置将控制权转移到另一个位置。有些 CPU 可以用单条指令完成所有这些操作，而其他 CPU 可能需要两条、三条或更多指令。有些
    CPU 允许你对两个值进行广泛的不同条件比较，而其他 CPU 仅允许进行少数几种测试。不论使用何种机制，映射到某一 CPU 上给定指令序列的高级语言（HLL）语句，在第二个
    CPU 上也会映射到一个相似的序列。因此，如果你理解了某个 CPU 上的基本转换方式，就能较好地理解编译器如何在所有 CPU 上工作。
- en: '**13.2 Introduction to Low-Level Control Structures**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**13.2 低级控制结构简介**'
- en: Most CPUs use a two-step process to make a programmatic decision. First, the
    program compares two values and saves the result of the comparison in a machine
    register or flag. Then the program tests that result and, based on what it learns,
    transfers control to one of two locations. With little more than this *compare
    and conditional branch* sequence, it is possible to synthesize most of the major
    HLL control structures.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 CPU 使用两步过程来做程序决策。首先，程序比较两个值，并将比较结果保存在机器寄存器或标志中。然后，程序测试该结果，并根据结果将控制权转移到两个位置之一。通过这种*比较与条件分支*序列，几乎可以合成大多数主要的高级语言控制结构。
- en: Even within the compare and conditional branch paradigm, CPUs commonly implement
    conditional code sequences using two different approaches. One technique, especially
    common on stack-based architectures (such as the UCSD p-machine, Java Virtual
    Machine, and Microsoft CLR), is to have different forms of the compare instruction
    that test for specific conditions. For example, you might have *compare if equal*,
    *compare if not equal*, *compare if less than*, *compare if greater than*, and
    so on. The result of each is a Boolean value. Then a pair of conditional branch
    instructions, *branch if true* and *branch if false*, can test the result of the
    comparison and transfer control to the appropriate location. Some of these VMs
    might actually merge the compare and branch instructions into “compare and branch”
    instructions (one for each condition to test). Despite using fewer instructions,
    the end result is exactly the same.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在比较和条件分支范式中，CPU 通常也使用两种不同的方法来实现条件代码序列。一个技术，尤其在基于堆栈的架构（如 UCSD p-machine、Java
    虚拟机和 Microsoft CLR）中常见，是使用不同形式的比较指令来测试特定条件。例如，你可能会有 *相等比较*、*不相等比较*、*小于比较*、*大于比较*
    等等。每个比较的结果是一个布尔值。然后，一对条件分支指令，*条件成立时分支* 和 *条件不成立时分支*，可以测试比较的结果，并将控制转移到适当的位置。这些虚拟机可能实际上将比较和分支指令合并为“比较和分支”指令（每个条件一个）。尽管使用了更少的指令，但最终结果完全相同。
- en: The second, and historically more popular, approach is for the CPU’s instruction
    set to contain a single comparison instruction that sets (or clears) several bits
    in the CPU’s *program status* or *flags* register. Then the program uses one of
    several more specific conditional branch instructions to transfer control to some
    other location. These conditional branch instructions might have names such as
    *jump if equal*, *jump if not equal*, *jump if less than*, or *jump if greater
    than*. Because this “compare and jump” technique is the one the 80x86, ARM, and
    PowerPC use, that’s also the approach this chapter’s examples use; however, it’s
    easy to convert them to the multiple comparisons/jump true/jump false paradigm.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种，也是历史上更为流行的方法，是让 CPU 的指令集包含一个单一的比较指令，该指令设置（或清除）CPU 的 *程序状态* 或 *标志* 寄存器中的多个位。然后，程序使用几种更具体的条件分支指令之一，将控制转移到其他位置。这些条件分支指令可能有如
    *相等跳转*、*不相等跳转*、*小于跳转* 或 *大于跳转* 等名称。由于这种“比较和跳转”技术是 80x86、ARM 和 PowerPC 所使用的，因此本章的示例也采用了这种方法；然而，将其转换为多重比较/跳转真/跳转假范式是很容易的。
- en: 'The 32-bit variants of the ARM processor introduce a third technique: conditional
    execution. Most instructions (not just the branches) on the 32-bit ARM provide
    this option. For example, the `addeq` instruction adds two values if and only
    if the result of the previous comparison (or other operation) has set the zero
    flag. See “Conditional Suffixes for Instructions” in Appendix C online for more
    details.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 处理器的 32 位变体引入了第三种技术：条件执行。大多数指令（不仅仅是分支指令）在 32 位 ARM 上都提供了这个选项。例如，`addeq`
    指令仅在先前的比较（或其他操作）结果设置了零标志时，才会执行两个值的加法。更多详细信息，请参见附录 C 中的《指令的条件后缀》。
- en: 'Conditional branches are typically two-way branches. That is, they transfer
    control to one location in the program if the condition they’re testing is `true`
    and to a different location if the condition is `false`. To reduce the size of
    the instruction, the conditional branches on most CPUs encode the address of only
    one of the two possible branch locations, and they use an implied address for
    the opposite condition. Specifically, most conditional branches transfer control
    to some target location if the condition is `true` and fall through to the next
    instruction if the condition is `false`. For example, consider the following 80x86
    `je` (jump if equal) instruction sequence:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 条件分支通常是双向分支。也就是说，如果它们测试的条件为 `true`，则将控制转移到程序中的一个位置；如果条件为 `false`，则转移到另一个位置。为了减少指令的大小，大多数
    CPU 上的条件分支仅编码两个可能分支位置中的一个地址，并且对于相反条件使用隐式地址。具体来说，大多数条件分支如果条件为 `true`，则将控制转移到目标位置，如果条件为
    `false`，则跳过到下一条指令。例如，考虑以下 80x86 的 `je`（相等跳转）指令序列：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This instruction sequence begins by comparing the value in the EAX register
    against the value in EBX (the `cmp` instruction); this sets the *condition-code
    bits* in the 80x86 EFLAGS register. In particular, this instruction sets the 80x86
    zero flag to `1` if the value in EAX is equal to the value in EBX. The `je` instruction
    tests the zero flag to see if it is set, and if so, transfers control to the machine
    instruction immediately following the `EAXequalsEBX` label. If the value in EAX
    is not equal to EBX, then the `cmp` instruction clears the zero flag and the `je`
    instruction falls through to the `mov` instruction rather than transferring control
    to the destination label.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令序列首先通过比较EAX寄存器中的值与EBX寄存器中的值（`cmp`指令）；这会设置80x86 EFLAGS寄存器中的*条件码位*。特别地，如果EAX中的值等于EBX中的值，则该指令将80x86零标志设置为`1`。`je`指令测试零标志是否被设置，如果是，它将控制转移到紧随`EAXequalsEBX`标签之后的机器指令。如果EAX中的值不等于EBX，则`cmp`指令会清除零标志，`je`指令会直接跳过到`mov`指令，而不会转移控制到目标标签。
- en: Certain machine instructions that access data can be smaller (and faster) if
    the memory location the machine instruction accesses is near the base address
    of the activation record containing that variable. This rule also applies to conditional
    jump instructions. The 80x86 provides two forms of the conditional jump instructions.
    One form is only 2 bytes long (1 byte for an opcode and 1 byte for a signed displacement
    in the range –128 through +127). The other form is 6 bytes long (2 bytes for the
    opcode and 4 bytes for a signed displacement in the range –2 billion through +2
    billion). The displacement value specifies how far (in bytes) the program must
    jump to reach the target location. To transfer control to a nearby location, the
    program can use the short form of the branch. Because 80x86 instructions are between
    1 and 15 bytes long (typically around 3 or 4 bytes long), the short forms of the
    conditional jump instructions can usually skip over about 32 to 40 machine instructions.
    Once the target location is out of the ±127-byte range, the 6-byte version of
    these conditional jump instructions extends the range to ±2 billion bytes around
    the current instruction. If you’re interested in writing the most efficient code,
    then, you’ll want to use the 2-byte form as often as possible.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 某些访问数据的机器指令，如果所访问的内存位置靠近包含该变量的激活记录的基址，则可能会更小（且更快）。此规则同样适用于条件跳转指令。80x86提供了两种形式的条件跳转指令。一种形式仅为2字节长（1字节用于操作码，1字节用于范围从-128到+127的有符号位移）。另一种形式为6字节长（2字节用于操作码，4字节用于范围从-20亿到+20亿的有符号位移）。位移值指定程序需要跳转多少字节才能到达目标位置。为了将控制转移到附近的位置，程序可以使用短形式的跳转。由于80x86指令的长度在1到15字节之间（通常约为3或4字节），条件跳转指令的短形式通常可以跳过大约32到40条机器指令。一旦目标位置超出了±127字节的范围，这些条件跳转指令的6字节版本将扩展跳转范围到当前指令的±20亿字节。如果你有兴趣编写最有效的代码，那么你会尽量多使用2字节形式。
- en: Branching is an expensive operation in a modern (pipelined) CPU because a branch
    may require the CPU to flush the pipeline and reload it (see *WGC1* for more details).
    Conditional branches incur this cost only if the branch is taken; if the conditional
    branch instruction falls through to the next instruction, the CPU will continue
    to use the instructions found in the pipeline without flushing them. Therefore,
    on many systems the *branch that falls through to the next instruction is faster
    than the branch that is taken*. Note, however, that some CPUs (like the 80x86,
    PowerPC, and ARM) support a *branch prediction* feature that tells the CPU to
    begin fetching instructions for the pipeline from the branch’s target location
    rather than from the instructions that immediately follow the conditional jump.
    Unfortunately, branch prediction algorithms vary from processor to processor (even
    within the 80x86 CPU family), so it’s difficult to predict, in general, how branch
    prediction will affect your HLL code. It’s probably safest to assume, unless you’re
    writing code for a specific processor, that falling through to the next instruction
    is more efficient than taking the jump.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 分支在现代（流水线）CPU中是一个昂贵的操作，因为分支可能要求CPU刷新流水线并重新加载（更多细节见*WGC1*）。条件分支只有在分支被执行时才会产生这种成本；如果条件分支指令跳过到下一条指令，CPU将继续使用流水线中找到的指令，而不会刷新它们。因此，在许多系统中，*跳过到下一条指令的分支比执行跳转的分支更快*。然而，请注意，一些CPU（如80x86、PowerPC和ARM）支持*分支预测*功能，这可以告诉CPU从分支目标位置开始获取指令进入流水线，而不是从紧随其后的条件跳转指令后获取。不幸的是，分支预测算法因处理器而异（甚至在80x86系列CPU中也有所不同），因此通常难以预测分支预测会如何影响你的高级语言代码。除非你正在为特定的处理器编写代码，否则最安全的假设是，跳过到下一条指令比执行跳转更有效。
- en: 'Although the compare and conditional branch paradigm is the most common control
    structure found in machine code programs, there are other ways to transfer control
    to another location in memory based on some computed result. Without question,
    the indirect jump (especially via a table of addresses) is the most common alternative
    form. Consider the following 32-bit 80x86 `jmp` instruction:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然比较和条件分支范式是机器代码程序中最常见的控制结构，但也有其他方法可以基于某些计算结果将控制权转移到内存中的另一个位置。毫无疑问，间接跳转（尤其是通过地址表）是最常见的替代形式。考虑以下32位80x86的`jmp`指令：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This `jmp` instruction fetches the double-word value at the index specified
    by the value in EBX in the `jmpTable` array. That is, the instruction transfers
    control to one of four different locations based upon the value (`0..3`) in EBX.
    For example, if EBX contains `0`, then the `jmp` instruction fetches the double
    word at index `0` in `jmpTable` (the address of the instruction prefixed by `label1`).
    Likewise, if EBX contains `2`, then this `jmp` instruction fetches the third double
    word from this table (the address of `label3` in the program). This is roughly
    equivalent to, but usually shorter than, the following sequence of instructions:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`jmp`指令从`jmpTable`数组中，由EBX中的值指定的索引处获取双字值。也就是说，该指令根据EBX中的值（`0..3`）将控制权转移到四个不同的位置。例如，如果EBX的值为`0`，那么`jmp`指令将从`jmpTable`的索引`0`处获取双字（即由`label1`前缀的指令的地址）。同样地，如果EBX的值为`2`，那么该`jmp`指令将从该表中获取第三个双字（即程序中`label3`的地址）。这大致等同于，但通常比以下指令序列更简短：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A few other conditional control transfer mechanisms are available on various
    CPUs, but these two mechanisms (compare and conditional branch and indirect jump)
    are the ones most HLL compilers use to implement standard control structures in
    the HLL.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他的条件控制转移机制在不同的CPU上也可以使用，但这两种机制（比较和条件分支以及间接跳转）是大多数高级语言编译器用来实现标准控制结构的方式。
- en: '**13.3 The goto Statement**'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**13.3 goto语句**'
- en: The `goto` statement is, perhaps, the most fundamental low-level control structure.
    Since the wave of “structured programming” in the late 1960s and 1970s, its use
    in HLL code has diminished. Indeed, some modern high-level programming languages
    (for example, Java and Swift) don’t even provide an unstructured `goto` statement.
    Even in those languages where one is available, programming style guidelines usually
    restrict its use to special circumstances. Combined with the fact that student
    programmers have been religiously taught to avoid them in their programs since
    the mid 1970s, it’s now rare to find many `goto` statements in a modern program.
    From a readability point of view, this is a good thing (check out some 1960sera
    FORTRAN programs to get an idea of how hard to read code can be when it’s peppered
    with `goto` statements). Nevertheless, some programmers believe that they can
    achieve higher efficiency by using `goto` statements in their code. While this
    is sometimes true, the gains are rarely worth the loss of readability that ultimately
    occurs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto`语句也许是最基本的低级控制结构。自从1960年代末和1970年代“结构化编程”浪潮以来，它在高级语言代码中的使用逐渐减少。事实上，一些现代高级编程语言（例如Java和Swift）甚至不提供非结构化的`goto`语句。即使在提供`goto`语句的语言中，编程风格指南通常也会限制其仅在特殊情况下使用。再加上自1970年代中期以来，学生程序员被严格教导在程序中避免使用`goto`，因此在现代程序中很少能找到`goto`语句。从可读性的角度来看，这是件好事（可以查看一些1960年代的FORTRAN程序，了解当代码中充斥着`goto`语句时，代码有多难以阅读）。尽管如此，仍有一些程序员认为，通过在代码中使用`goto`语句，他们可以实现更高的效率。虽然有时这种说法是对的，但效率的提升往往不值得牺牲可读性。'
- en: 'One of the big efficiency arguments for `goto` is that it helps avoid duplicate
    code. Consider the following simple C/C++ example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto`的一个重要效率论点是它有助于避免重复代码。考虑以下简单的C/C++示例：'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Programmers looking for ways to make their programs more efficient will immediately
    notice all the duplicated code and might be tempted to rewrite the example as
    follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找提高程序效率方法的程序员会立即注意到所有重复的代码，并可能会被诱使将示例重写如下：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are, of course, several software engineering problems with this code,
    including the fact that it is a bit harder to read, modify, and maintain than
    the original example. (You *could* argue that it’s actually a little easier to
    maintain, because you no longer have duplicated code and you only have to fix
    defects in the common code at one spot.) However, there’s no denying that there’s
    less code in this example. Or is there?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这段代码存在一些软件工程问题，包括它比原始示例稍难阅读、修改和维护。（你*可以*辩称它实际上更容易维护，因为你不再有重复的代码，只需要在一个地方修复公共代码中的缺陷。）然而，不能否认的是，这个示例中的代码量确实较少。或者说，真的少吗？
- en: The optimizers in many modern compilers actually look for code sequences like
    the first example and generate code that’s identical to what you’d expect for
    the second example. Therefore, a *good* compiler avoids generating duplicate machine
    code even when the source file contains duplication, as in the first example.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代编译器中的优化器实际上会寻找像第一个示例中的代码序列，并生成与第二个示例预期完全相同的代码。因此，一个*优秀*的编译器即使源文件中存在重复，也会避免生成重复的机器代码，正如第一个示例中的情况。
- en: 'Consider the following C/C++ example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下C/C++示例：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here’s the compilation of the `if` sequence to PowerPC code by GCC:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是GCC将`if`语句序列编译成PowerPC代码的过程：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Of course, not every compiler has an optimizer that will recognize the duplicated
    code. So, if you want to write a program that compiles to efficient machine code
    regardless of the compiler, you might be tempted to use the version of the code
    that employs the `goto` statement. Indeed, you could make a strong software engineering
    argument that having duplicate code in a source file makes the program harder
    to read and harder to maintain. (If you fix a defect in one copy of the code,
    chances are that you’ll forget to correct the defect in the other copies of the
    code.) While this is definitely true, if you make changes to the code at the target
    label, it’s not immediately obvious that the change is appropriate for each and
    every section of code that jumps to the target label. And it’s not immediately
    obvious how many different `goto` statements transfer control to the same target
    label when you’re reading through the source code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非每个编译器都有优化器能够识别重复代码。因此，如果你想编写一个无论编译器如何都能编译成高效机器代码的程序，你可能会倾向于使用带有`goto`语句的代码版本。实际上，你可以提出一个强有力的软件工程论点，即源代码中的重复代码使得程序更难以阅读和维护。（如果你在某个代码副本中修复了一个缺陷，可能会忘记在其他副本中修复相同的缺陷。）虽然这确实是事实，但如果你在目标标签处对代码进行修改，那么是否每个跳转到该目标标签的代码段都适合这种更改并不立刻显现。而且，在阅读源代码时，也不容易立刻看出有多少个`goto`语句将控制转移到同一个目标标签。
- en: The traditional software engineering approach is to put the common code into
    a procedure or function and simply call that function. However, the overhead of
    a function call and return can be rather large (especially if there isn’t much
    duplicated code), so from a performance point of view, that approach may not be
    satisfactory. For short sequences of common code, creating a macro or an inline
    function is probably the best solution. To complicate the issue, you might need
    a change that affects only one instance of the duplicated code (that is, it would
    no longer be a duplicate). The bottom line is that using a `goto` statement to
    gain efficiency in this manner should be your last resort.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的软件工程方法是将公共代码放入一个过程或函数中，然后简单地调用该函数。然而，函数调用和返回的开销可能相当大（尤其是在没有太多重复代码的情况下），因此从性能角度来看，这种方法可能不尽如人意。对于短小的公共代码序列，创建宏或内联函数可能是最佳解决方案。更复杂的是，你可能需要对仅影响一个实例的重复代码进行更改（也就是说，它不再是重复的）。总的来说，以这种方式使用`goto`语句来提高效率应当是你的最后手段。
- en: Another common use for `goto` statements is for exceptional conditions. When
    you find yourself nested deeply in several statements and you encounter a situation
    where you need to exit all those statements, the common consensus is that a `goto`
    is acceptable if restructuring the code wouldn’t make it more readable. However,
    jumps out of nested blocks may thwart the optimizer’s ability to generate decent
    code for the entire procedure or function. The use of the `goto` statement may
    save a few bytes or processor cycles in the code it immediately affects, but it
    could have detrimental effects on the rest of the function, resulting in less
    efficient code overall. So, take care when inserting `goto` statements into your
    code—they can make your source code harder to read, and might wind up making it
    less efficient as well.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的`goto`语句用法是处理异常情况。当你发现自己深深地嵌套在多个语句中，并且遇到一种需要退出所有这些语句的情况时，普遍共识是，如果重构代码不会使其更加可读，那么使用`goto`是可以接受的。然而，从嵌套块跳出可能会妨碍优化器为整个过程或函数生成良好代码的能力。`goto`语句的使用可能会在它直接影响的代码中节省一些字节或处理器周期，但它也可能对函数的其余部分产生不利影响，导致整体代码效率降低。因此，在代码中插入`goto`语句时要小心——它们可能会使源代码更难以阅读，并且可能最终使其效率降低。
- en: 'For what it’s worth, there’s a programming trick you can use to solve the original
    problem. Consider the following modification to the code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得有用，下面是一个可以用来解决原始问题的编程技巧。考虑对代码进行如下修改：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Of course, this is tricky code, and tricky code isn’t usually great code. However,
    it does have the benefit of avoiding duplication of source code in your program.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这段代码比较棘手，而棘手的代码通常不是优秀的代码。然而，它确实有一个好处，就是避免了程序中源代码的重复。
- en: '**13.3.1 Restricted Forms of the goto Statement**'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**13.3.1 限制形式的goto语句**'
- en: In an effort to support structured `goto`-less programming, many programming
    languages have added restricted forms of the `goto` statement that allow a programmer
    to immediately exit a control structure such as a loop or a procedure/function.
    Typical statements include `break` and `exit`, which jump out of an enclosing
    loop; `continue`, `cycle`, and `next`, which restart an enclosing loop; and `return`
    and `exit`, which immediately return from an enclosing procedure or function.
    These statements are more structured than a standard `goto` because the programmer
    doesn’t choose the destination; instead, control transfers to a fixed location
    based upon whatever control statement (or function or procedure) encloses the
    statement.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持结构化的“无 goto”编程，许多编程语言添加了受限形式的 `goto` 语句，允许程序员立即退出控制结构，如循环或过程/函数。典型的语句包括
    `break` 和 `exit`，它们会跳出包围的循环；`continue`、`cycle` 和 `next`，它们会重新启动包围的循环；以及 `return`
    和 `exit`，它们会立即从包围的过程或函数中返回。这些语句比标准的 `goto` 更具结构性，因为程序员并不选择跳转目标；相反，控制会转移到一个固定的位置，这个位置取决于包含该语句的控制语句（或函数或过程）。
- en: Almost every one of these statements compiles into a single `jmp` instruction.
    Those that jump out of a loop (such as `break`) compile into a single `jmp` instruction
    that transfers control to the first statement beyond the bottom of the loop. Those
    that restart a loop (for example, `continue`, `next`, or `cycle`) compile into
    a single `jmp` instruction that transfers control to the loop termination test
    (in the case of while or `repeat..until`/`do..while`) or to the top of the loop
    (in the case of most other loops).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有这些语句都会编译为单个 `jmp` 指令。那些跳出循环的语句（如 `break`）会编译为一个 `jmp` 指令，将控制权转移到循环底部之后的第一个语句。那些重新启动循环的语句（例如，`continue`、`next`
    或 `cycle`）会编译为一个 `jmp` 指令，将控制权转移到循环终止测试（对于 `while` 或 `repeat..until`/`do..while`）或循环顶部（对于其他大多数循环）。
- en: However, just because these statements typically compile to a single `jmp` instruction
    doesn’t mean they’re efficient to use. Even ignoring the fact that a `jmp` can
    be somewhat expensive (because it forces the CPU to flush the instruction pipeline),
    statements that branch out of a loop can have a serious impact on the compiler’s
    optimizer, dramatically reducing the opportunity to generate high-quality code.
    Therefore, you should attempt to use these statements as sparingly as possible.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅因为这些语句通常会编译为单个 `jmp` 指令，并不意味着它们使用起来高效。即使忽略了 `jmp` 可能比较昂贵的事实（因为它会迫使 CPU
    清空指令流水线），从循环中分支出来的语句可能会对编译器的优化器产生严重影响，显著降低生成高质量代码的机会。因此，您应该尽可能节省使用这些语句。
- en: '**13.4 The if Statement**'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**13.4 if 语句**'
- en: Perhaps the most basic high-level control structure is the `if` statement. Indeed,
    with nothing more than an `if` and a `goto` statement, you can (semantically)
    implement all other control structures.^([1](footnotes.xhtml#ch13fn1)) We’ll revisit
    this point when discussing other control structures, but for now we’ll look at
    how a typical compiler converts an `if` statement into machine code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最基本的高级控制结构就是 `if` 语句。事实上，仅凭 `if` 和 `goto` 语句，您就可以（语义上）实现所有其他控制结构。^([1](footnotes.xhtml#ch13fn1))
    我们将在讨论其他控制结构时再次提到这一点，但现在我们先来看一下典型编译器是如何将 `if` 语句转换为机器代码的。
- en: 'To implement a simple `if` statement that compares two values and executes
    the body if the condition is `true`, you can use a single compare and conditional
    branch instruction. Consider the following Pascal `if` statement:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现一个简单的 `if` 语句，它比较两个值并在条件为 `true` 时执行主体，您可以使用单个比较和条件跳转指令。考虑下面的 Pascal `if`
    语句：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here’s the conversion to 80x86/HLA code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是转换为 80x86/HLA 代码的示例：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the Pascal source code, the body of the `if` statement executes if the value
    of EAX is equal to EBX. In the resulting assembly code, the program compares EAX
    with EBX and then, if EAX does not equal EBX, branches over the statements that
    correspond to the `if` statement’s body. This is the “boilerplate” conversion
    of an HLL `if` statement into machine code: test some condition and, if it’s `false`,
    branch over the `if` statement’s body.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pascal 源代码中，`if` 语句的主体会在 EAX 的值等于 EBX 时执行。在生成的汇编代码中，程序会比较 EAX 和 EBX，然后，如果
    EAX 不等于 EBX，跳过对应于 `if` 语句主体的语句。这是将高层语言 `if` 语句转换为机器代码的“模板”：测试某个条件，如果条件为 `false`，则跳过
    `if` 语句的主体。
- en: 'The implementation of an `if..then..else` statement is only slightly more complicated
    than the basic `if` statement. An `if..then..else` statement typically employs
    syntax and semantics such as the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`if..then..else` 语句的实现比基本的 `if` 语句稍微复杂一些。`if..then..else` 语句通常采用如下的语法和语义：'
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Implementing this code sequence in machine code requires only a single machine
    instruction beyond what a simple `if` statement requires. Consider this example
    C/C++ code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器代码中实现这一代码序列，只需比简单的 `if` 语句多一个机器指令。考虑以下 C/C++ 示例代码：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is the conversion to 80x86 assembly language code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是转换成 80x86 汇编语言代码：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There are two things to note about this code. First, if the condition evaluates
    to `false`, the code transfers to the first statement of the `else` block rather
    than the first statement following the (entire) `if` statement. The second thing
    to note is the `jmp` instruction at the end of the `true` clause skips the `else`
    block.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有两点需要注意。首先，如果条件计算结果为 `false`，代码将跳转到 `else` 块的第一条语句，而不是跳转到（整个）`if` 语句后的第一条语句。第二点需要注意的是，在
    `true` 条件语句末尾的 `jmp` 指令跳过了 `else` 块。
- en: 'Some languages, including HLA, support an `elseif` clause in their `if` statement
    to evaluate a second condition if the first one fails. This is a straightforward
    extension of the code generation of the `if` statement I’ve shown. Consider the
    following HLA `if..elseif..else..endif` statements:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言，包括 HLA，支持 `if` 语句中的 `elseif` 子句，当第一个条件失败时，它会评估第二个条件。这是对我所展示的 `if` 语句代码生成的一个直接扩展。考虑以下
    HLA `if..elseif..else..endif` 语句：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And here’s the conversion to pure 80x86/HLA assembly language code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是转换成纯 80x86/HLA 汇编语言代码：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The translation of the `elseif` clause is very straightforward; the machine
    code for it is identical to an `if` statement. What’s noteworthy here is how the
    compiler emits a `jmp` instruction at the end of the `if..then` clause to skip
    around the Boolean test emitted for the `elseif` clause.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`elseif` 子句的翻译非常直接；它的机器码与 `if` 语句是相同的。这里值得注意的是，编译器如何在 `if..then` 子句末尾发出 `jmp`
    指令，以跳过为 `elseif` 子句发出的布尔测试。'
- en: '**13.4.1 Improving the Efficiency of Certain if/else Statements**'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**13.4.1 提高某些 if/else 语句的效率**'
- en: 'From an efficiency point of view, it’s important to note that there’s no path
    through the `if..else` statement that doesn’t involve a transfer of control (unlike
    the simple `if` statement, which simply falls through if the conditional expression
    is `true`). As this chapter has pointed out, branches are bad because they often
    flush the CPU’s instruction pipeline, which takes several CPU cycles to refill.
    If both outcomes of the Boolean expression (`true` and `false`) are equally likely,
    there’s little you can do to improve the code’s performance by rearranging the
    `if..else` statement. For most `if` statements, however, one outcome is often
    more likely—perhaps much more likely—than the other. Assembly coders who understand
    the likelihood of one comparison over another will often encode their `if..else`
    statements as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从效率角度来看，需要注意的是，`if..else` 语句中没有路径是不会涉及控制转移的（与简单的 `if` 语句不同，如果条件表达式为 `true`，它会直接跳过）。正如本章所指出的，分支是有问题的，因为它们通常会刷新
    CPU 的指令流水线，重新填充需要几个 CPU 周期。如果布尔表达式的两个结果（`true` 和 `false`）的可能性相等，那么通过重新安排 `if..else`
    语句来提高代码的性能几乎没有什么可做的。然而，对于大多数 `if` 语句来说，一个结果往往比另一个更可能——甚至可能大大更可能——出现。理解一种比较比另一种比较更可能的汇编程序员通常会按如下方式编码他们的
    `if..else` 语句：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note that in the most common case (where the expression evaluates to `true`),
    the code falls through to the `then` section, which then falls straight through
    to the code that follows the entire `if` statement. Therefore, if the Boolean
    expression (`eax == ebx`) is `true` most of the time, this code executes straight
    through without any branches. In the rare case, when EAX does not equal EBX, the
    program actually has to execute two branches: one to transfer control to the section
    of code that handles the `else` clause, and one to return control to the first
    statement following the `if`. As long as this occurs less than half of the time,
    the software sees an overall performance boost. You can achieve this same result
    in an HLL such as C using `goto` statements. For example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在最常见的情况下（即表达式求值为`true`时），代码会直接跳转到`then`部分，然后继续执行`if`语句后面的代码。因此，如果布尔表达式（`eax
    == ebx`）大部分时间为`true`，这段代码会毫不分支地直接执行。在极少数情况下，当EAX不等于EBX时，程序实际上需要执行两次分支：一次转移控制到处理`else`子句的代码段，另一次将控制权返回到`if`后面的第一条语句。只要这种情况发生的频率不到一半，软件的整体性能就会得到提升。你可以在像C这样的高级语言中通过`goto`语句实现相同的结果。例如：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Of course, the drawback to this scheme is that it produces *spaghetti code*
    that becomes unreadable once you add more than a few of these kludges. Assembly
    language programmers get away with this because most assembly language code is,
    by definition, spaghetti code.^([2](footnotes.xhtml#ch13fn2)) For HLL code, however,
    this programming style is generally unacceptable, and you should use it only when
    necessary. (See “The `goto` Statement” on [page 455](ch13.xhtml#page_455).)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种方案的缺点是它产生了*意大利面条代码*，一旦你加入多个这种权宜之计，它就变得难以阅读。汇编语言程序员可以使用这种方式，因为大多数汇编语言代码本质上就是意大利面条代码。^([2](footnotes.xhtml#ch13fn2))
    然而，对于高级语言（HLL）代码而言，这种编程风格通常是不可接受的，只有在必要时才应使用它。（请参见“`goto`语句”在[第455页](ch13.xhtml#page_455)的内容。）
- en: 'The following generic `if` statement is common in programs written in HLLs
    such as C:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个在高级语言（如C）中常见的通用`if`语句：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here’s the conversion of this C code into 80x86/HLA assembly code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将此C代码转换为80x86/HLA汇编代码的形式：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you’ve seen in previous examples, the `if..then..else` statement conversion
    to assembly language requires two control transfer instructions:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的示例中看到的，`if..then..else`语句的汇编语言转换需要两条控制转移指令：
- en: The `jne` instruction that tests the comparison between EAX and EBX
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试EAX和EBX之间比较的`jne`指令
- en: The unconditional `jmp` instruction that skips over the `else` section of the
    `if` statement
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无条件的`jmp`指令跳过`if`语句中的`else`部分
- en: 'Regardless of which path the program takes (through the `then` or the `else`
    section), the CPU executes a slow branch instruction that winds up flushing the
    instruction pipeline. Consider the following code, which does not have this problem:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 无论程序采取哪条路径（通过`then`部分还是`else`部分），CPU都会执行一个慢速的分支指令，最终导致指令流水线被刷新。考虑以下代码，它没有这个问题：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is its conversion to pure 80x86/HLA assembly code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它转换为纯80x86/HLA汇编代码的形式：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, if the expression evaluates to `true`, the CPU executes no control
    transfer statements at all. Yes, the CPU executes an extra `mov` instruction whose
    result is immediately overwritten (so the execution of the first `mov` instruction
    is wasted); however, the execution of this extra `mov` instruction happens much
    more rapidly than the execution of the `jmp` instruction. This trick is a prime
    example of why it’s a good idea to know some assembly language code (and know
    how compilers generate machine code from high-level code). It’s not at all obvious
    that the second sequence is better than the first. Beginning programmers, in fact,
    would probably believe it to be inferior because the program “wastes” an assignment
    to `i` when the expression evaluates to `true` (and no such assignment is made
    in the first version). This is one reason why this chapter exists—to make sure
    you understand the costs associated with using high-level control structures.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，如果表达式求值为`true`，CPU根本不会执行任何控制转移指令。是的，CPU执行了一条额外的`mov`指令，其结果会立即被覆盖（因此第一次`mov`指令的执行是浪费的）；然而，这条额外的`mov`指令的执行速度远快于`jmp`指令的执行。这个技巧是一个典型例子，说明了为什么了解一些汇编语言代码（以及了解编译器如何从高级语言代码生成机器代码）是一个好主意。第二个序列比第一个更优这一点并不明显。事实上，初学者可能会认为它更差，因为当表达式求值为`true`时，程序“浪费”了对`i`的赋值（而第一个版本没有进行这样的赋值）。这也是本章存在的原因之一——确保你理解使用高级控制结构所涉及的成本。
- en: '**13.4.2 Forcing Complete Boolean Evaluation in an if Statement**'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**13.4.2 强制在 if 语句中进行完全布尔求值**'
- en: Because complete Boolean evaluation and short-circuit Boolean evaluation can
    produce different results (see “Short-Circuit Evaluation” on [page 441](ch12.xhtml#page_441)),
    there are times when you’ll need to force your code to use one form or the other
    when computing the result of a Boolean expression.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因为完全布尔求值和短路布尔求值可能会产生不同的结果（参见 [第 441 页](ch12.xhtml#page_441)的“短路求值”），因此在计算布尔表达式的结果时，有时需要强制代码使用其中一种形式。
- en: 'The general way to force complete Boolean evaluation is to evaluate each subcomponent
    of the expression and store the subresult into temporary variables. Then you can
    combine the temporary results after their computation to produce the complete
    result. For example, consider the following Pascal code fragment:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 强制完全布尔求值的一般方法是评估表达式的每个子组件，并将子结果存储到临时变量中。然后，你可以在计算完这些临时结果后，将它们组合成完整的结果。例如，考虑以下
    Pascal 代码片段：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Because Pascal doesn’t guarantee complete Boolean evaluation, function `f()`
    might not be called in this expression—if `i` is less than `g(y)`—and thus any
    side effects produced by the call to `f()` might not occur. (See “Side Effects
    in Arithmetic Expressions” on [page 430](ch12.xhtml#page_430).) If the logic of
    the application depends on any side effects produced by the calls to `f()` and
    `g()`, then you must ensure that the application calls both functions. Note that
    simply swapping the two subexpressions around the AND operator is insufficient
    to solve this problem; with that change, the application might not call `g()`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Pascal 不保证完全布尔求值，函数 `f()` 可能不会在此表达式中被调用——如果 `i` 小于 `g(y)`——因此，调用 `f()` 可能产生的副作用可能不会发生。（参见
    [第 430 页](ch12.xhtml#page_430)的“算术表达式中的副作用”）。如果应用程序的逻辑依赖于 `f()` 和 `g()` 的调用产生的副作用，则必须确保应用程序调用这两个函数。请注意，简单地交换
    AND 运算符两边的子表达式不足以解决这个问题；通过这种修改，应用程序可能不会调用 `g()`。
- en: 'One way to solve this problem is to compute the Boolean results of the two
    subexpressions using separate assignment statements and then compute the logical
    AND of the two results within the `if` expression:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是使用单独的赋值语句计算两个子表达式的布尔结果，然后在 `if` 表达式中计算这两个结果的逻辑与：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Don’t be too concerned about the efficiency loss that could result from using
    these temporary variables. Any compiler that provides optimization facilities
    will put these values into registers and not bother using actual memory locations.
    Consider the following variant of the previous Pascal program written in C and
    compiled with the Visual C++ compiler:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 不必过于担心使用这些临时变量可能导致的效率损失。任何提供优化功能的编译器都会将这些值放入寄存器，而不会使用实际的内存位置。考虑以下用 C 语言编写并通过
    Visual C++ 编译器编译的 Pascal 程序变体：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here’s the conversion to 32-bit MASM code by the Visual C++ compiler (a few
    instructions have been rearranged to make their intent clearer):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Visual C++ 编译器转换为 32 位 MASM 代码的结果（为了更清楚地表达意图，几条指令已经重新排列）：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you scan the assembly code, you’ll see that this code fragment always executes
    the calls to both `f()` and `g()`. Contrast this with the following C code and
    assembly output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看汇编代码，你会发现这段代码片段始终执行对 `f()` 和 `g()` 的调用。与以下 C 代码和汇编输出对比：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here’s the MASM assembly output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 MASM 汇编输出：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In C, you can use another trick to force complete Boolean evaluation in any
    Boolean expression. The C bitwise operators do not support short-circuit Boolean
    evaluation. If your subexpressions in a Boolean expression always produce `0`
    or `1`, the bitwise Boolean conjunction and disjunction operators (that is, `&`
    and `|`) produce identical results to the logical Boolean operators (`&&` and
    `||`). Consider the following C code and the MASM code that the Visual C++ compiler
    produces:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中，你可以使用另一种技巧来强制在任何布尔表达式中进行完全的布尔求值。C 语言的位运算符不支持短路布尔求值。如果你的布尔表达式中的子表达式始终产生
    `0` 或 `1`，那么位运算布尔与（`&`）和布尔或（`|`）运算符的结果与逻辑布尔运算符（`&&` 和 `||`）产生的结果是相同的。考虑以下 C 代码和
    Visual C++ 编译器生成的 MASM 代码：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here’s the MASM code emitted by Visual C++:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Visual C++ 生成的 MASM 代码：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note how the use of the bitwise operators produces comparable code to the earlier
    sequence that used temporary variables. This creates less clutter in your original
    C source file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意位运算符的使用如何生成与早期使用临时变量的代码段相似的代码。这会减少原始 C 源文件中的杂乱。
- en: 'Do keep in mind, however, that C’s bitwise operators produce the same results
    as the logical operators *only* if the operands are `0` and `1`. Fortunately,
    you can use a little C trick here: just write `!!(expr`), and if the expression’s
    value is zero or nonzero, C will convert the result to `0` or `1`. To see this
    in action, consider the following C/C++ code fragment:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得记住的是，C的按位运算符只有在操作数为`0`和`1`时，才会产生与逻辑运算符相同的结果。幸运的是，你可以在这里使用一个小技巧：只需写`!!(expr)`，如果表达式的值是零或非零，C将把结果转换为`0`或`1`。为了演示这一点，考虑以下C/C++代码片段：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here’s the 80x86 assembly code that Microsoft’s Visual C++ compiler produces
    for this short program:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是微软Visual C++编译器为此短程序生成的80x86汇编代码：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see in the 80x86 assembly output, only three machine instructions
    (involving no expensive branches) are needed to convert zero/nonzero to `0`/`1`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在80x86汇编输出中所看到的，只需要三条机器指令（不涉及昂贵的分支操作）就能将零/非零转换为`0`/`1`。
- en: '**13.4.3 Forcing Short-Circuit Evaluation in an if Statement**'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**13.4.3 在if语句中强制短路求值**'
- en: 'Although it’s useful to be able to force complete Boolean evaluation on occasion,
    needing to force short-circuit evaluation is probably more common. Consider the
    following Pascal statement:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然偶尔强制完全布尔求值是有用的，但强制短路求值的需求可能更为常见。考虑以下Pascal语句：
- en: '[PRE31]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The Pascal language definition leaves it up to the compiler writer to decide
    whether to use complete Boolean evaluation or short-circuit evaluation. In fact,
    the writer is free to use both schemes as desired. Thus, it’s quite possible that
    the same compiler could use complete Boolean evaluation for the previous statement
    in one section of the code and short-circuit evaluation in another.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal语言的定义将是否使用完全的布尔求值还是短路求值留给编译器编写者决定。实际上，编写者可以根据需要自由选择两种方案。因此，完全有可能同一个编译器在代码的一个部分使用完全布尔求值，而在另一个部分使用短路求值。
- en: You can see that this Boolean expression will fail if `ptrVar` contains the
    NIL pointer value and if the compiler uses complete Boolean evaluation. The only
    way to get this statement to work properly is by using short-circuit Boolean evaluation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，如果`ptrVar`包含NIL指针值，并且编译器使用完全布尔求值，这个布尔表达式将失败。要使此语句正确工作，唯一的方法就是使用短路布尔求值。
- en: 'Simulating short-circuit Boolean evaluation with the AND operator is actually
    quite simple. All you have to do is create a pair of nested `if` statements and
    place each subexpression in each one. For example, you could guarantee short-circuit
    Boolean evaluation in the current Pascal example by rewriting it as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AND运算符模拟短路布尔求值实际上非常简单。你所需要做的就是创建一对嵌套的`if`语句，并将每个子表达式分别放入其中。例如，你可以通过以下方式在当前Pascal示例中保证短路布尔求值：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This statement is semantically identical to the previous one. It should be clear
    that the second subexpression will not execute if the first expression evaluates
    to `false`. Even though this approach clutters up the source file a bit, it does
    guarantee short-circuit evaluation regardless of whether the compiler supports
    that scheme.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这条语句在语义上与前一个相同。应该很清楚，如果第一个表达式求值为`false`，第二个子表达式将不会执行。尽管这种方法会让源文件稍显冗杂，但它确实能保证无论编译器是否支持该方案，都会进行短路求值。
- en: 'Handling the logical-OR operation is a little more difficult. Guaranteeing
    that the right operand of a logical-OR does not execute if the left operand evaluates
    to `true` requires an extra test. Consider the following C code (remember that
    C supports short-circuit evaluation by default):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 处理逻辑“或”操作要稍微复杂一些。如果左操作数求值为`true`，则需要额外的测试来保证右操作数不执行。考虑以下C代码（记住，C默认支持短路求值）：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here’s the machine code that the Microsoft Visual C++ compiler produces:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是微软Visual C++编译器生成的机器代码：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here’s a version of the C program that implements short-circuit evaluation
    without relying on the C compiler to do so (not that this is necessary for C,
    as its language definition guarantees short-circuit evaluation, but you could
    use this approach in any language):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个C程序版本，它实现了短路求值，而不依赖C编译器的实现（值得注意的是，C的语言定义保证了短路求值，但你可以在任何语言中使用这种方法）：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here’s the corresponding MASM code emitted by the Microsoft Visual C++ compiler:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是微软Visual C++编译器为此短程序生成的相应MASM代码：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, the code the compiler emits for the second version of the routine,
    which manually forces short-circuit evaluation, isn’t quite as good as that emitted
    by the C compiler for the first example. However, if you need the semantics for
    short-circuit evaluation so the program will execute correctly, you’ll have to
    live with possibly less efficient code than you’d get if the compiler supported
    this scheme directly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，编译器为第二版例程（手动强制短路求值）生成的代码不如C编译器为第一个示例生成的代码那样好。然而，如果你需要短路求值的语义以确保程序正确执行，那么你只能接受比编译器直接支持这种方案时生成的代码效率低的情况。
- en: 'If speed, minimal size, and short-circuit evaluation are all necessary, and
    you’re willing to sacrifice a little readability and maintainability in your code
    to achieve them, then you can destructure the code and create something comparable
    to what the C compiler produces using short-circuit evaluation. Consider the following
    C code and the resulting output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果速度、最小化大小和短路求值都是必要的，并且你愿意牺牲代码的可读性和可维护性来实现这些目标，那么你可以解构代码，生成类似于C编译器通过短路求值生成的代码。请看以下C代码及其生成的输出：
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here’s the MASM output from Visual C++:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Visual C++的MASM输出：
- en: '[PRE38]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you compare this code to the MASM output for the original C example (which
    relies on short-circuit evaluation), you’ll see that this code is just as efficient.
    This is a classic example of why there was considerable resistance to structured
    programming in the 1970s among some programmers—sometimes it leads to less efficient
    code. Of course, readability and maintainability are usually more important than
    a few bytes or machine cycles. But never forget that if performance is paramount
    for a small section of code, destructuring that code can improve efficiency in
    some special cases.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将这段代码与原始C示例的MASM输出进行比较（原始C示例依赖于短路求值），你会发现这段代码同样高效。这是为什么在1970年代，一些程序员对结构化编程存在相当大抵制的经典例子——有时候它会导致不那么高效的代码。当然，代码的可读性和可维护性通常比几个字节或机器周期更重要。但永远不要忘记，如果性能对某段小代码至关重要，解构这段代码在某些特殊情况下可以提高效率。
- en: '**13.5 The switch/case Statement**'
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**13.5 `switch`/`case`语句**'
- en: 'The `switch` (or `case`) high-level control statement is another conditional
    statement found in HLLs. As you’ve seen, an `if` statement tests a Boolean expression
    and executes one of two different paths in the code based on the result of the
    expression. A `switch/case` statement, on the other hand, can branch to one of
    several different points in the code based on the result of an ordinal (integer)
    expression. The following examples demonstrate the `switch` and `case` statements
    in C/C++, Pascal, and HLA. First, the C/C++ `switch` statement:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`（或`case`）高阶控制语句是HLL（高级语言）中另一种条件语句。如你所见，`if`语句测试布尔表达式，并根据表达式的结果执行代码中的两条不同路径。另一方面，`switch/case`语句可以根据序数（整数）表达式的结果跳转到代码中的多个不同位置。以下示例展示了C/C++、Pascal和HLA中的`switch`和`case`语句。首先是C/C++中的`switch`语句：'
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Java and Swift provide a similar syntax to C/C++ for the `switch` statement,
    although Swift’s version has many additional features. We’ll explore some of those
    additional features in the section “The Swift `switch` Statement” on [page 500](ch13.xhtml#page_500).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Java和Swift为`switch`语句提供了类似C/C++的语法，尽管Swift的版本有许多附加特性。我们将在“Swift `switch`语句”章节中探讨一些附加特性，具体见[第500页](ch13.xhtml#page_500)。
- en: 'Here’s an example of a Pascal `case` statement:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Pascal `case`语句的示例：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And finally, here’s the HLA `switch` statement:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是HLA中的`switch`语句：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can tell by these examples, these statements all share a similar syntax.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些例子中你可以看出，这些语句的语法都非常相似。
- en: '**13.5.1 Semantics of a switch/case Statement**'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**13.5.1 `switch`/`case`语句的语义**'
- en: 'Most beginning programming classes and textbooks teach the semantics of the
    `switch`/`case` statement by comparing it with a chain of `if..else..if` statements;
    this introduces the `switch`/`case` statement using a concept the student already
    understands. Unfortunately, this approach can be misleading. To see why, consider
    the following code, which an introductory Pascal programming book might claim
    is equivalent to our Pascal `case` statement:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数初学编程的课程和教材通过将`switch`/`case`语句与一系列`if..else..if`语句进行比较，来讲解`switch`/`case`语句的语义；这种方式用学生已经理解的概念介绍`switch`/`case`语句。不幸的是，这种方法可能具有误导性。为了解释原因，请看以下代码，一本入门级Pascal编程书籍可能会声称它等同于我们的Pascal
    `case`语句：
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Although this particular sequence will achieve the same result as the `case`
    statement, there are several fundamental differences between the `if..then..elseif`
    sequence and the Pascal `case` implementation. First, the case labels in a `case`
    statement must all be constants, but in an `if..then..elseif` chain you can actually
    compare variables and other nonconstant values against the control variable. Another
    limitation of the `switch`/`case` statement is that you can compare only the value
    of a single expression against a set of constants; you cannot compare one expression
    against a constant for one case and a separate expression against a second constant,
    as you can with an `if..then..elseif` chain. The reason for these limitations
    will become clear in a moment, but the takeaway here is that an `if..then..elseif`
    chain is semantically different from—and more powerful than—a `switch`/`case`
    statement.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个特定的序列会与 `case` 语句达到相同的效果，但 `if..then..elseif` 序列和 Pascal `case` 实现之间有几个根本性的区别。首先，`case`
    语句中的 `case` 标签必须都是常量，但在 `if..then..elseif` 链中，你实际上可以将变量和其他非常量值与控制变量进行比较。`switch`/`case`
    语句的另一个限制是，你只能将单一表达式的值与常量集合进行比较；而在 `if..then..elseif` 链中，你可以将一个表达式与一个常量进行比较，并将另一个表达式与第二个常量进行比较。稍后会解释这些限制的原因，但这里要记住的是，`if..then..elseif`
    链在语义上与 `switch`/`case` 语句不同——并且比其功能更强大。
- en: '**13.5.2 Jump Tables vs. Chained Comparisons**'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**13.5.2 跳转表与链式比较**'
- en: 'Although it is arguably more readable and convenient than an `if..then..elseif`
    chain, the `switch`/`case` statement was originally added to HLLs for efficiency,
    not readability or convenience. Consider an `if..then..elseif` chain with 10 separate
    expressions to test. If all the cases are mutually exclusive and equally likely,
    then on average the program will execute five comparisons before encountering
    an expression that evaluates to `true`. In assembly language, it’s possible to
    transfer control to one of several different locations in a fixed amount of time,
    independent of the number of cases, by using a table lookup and an indirect jump.
    Effectively, such code uses the value of the `switch`/`case` expression as an
    index into a table of addresses and then jumps (indirectly) to the statement specified
    by the table entry. When you have more than three or four cases, this scheme is
    typically faster and consumes less memory than the corresponding `if..then..elseif`
    chain. Consider the following simple implementation of a `switch`/`case` statement
    in assembly language:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `switch`/`case` 语句在可读性和便利性上可能比 `if..then..elseif` 链更好，但它最初添加到高级语言中是为了效率，而非可读性或便利性。考虑一个包含
    10 个独立表达式的 `if..then..elseif` 链。如果所有的 `case` 是互斥的并且同样可能，那么程序平均需要执行五次比较，才能遇到一个计算结果为
    `true` 的表达式。在汇编语言中，使用表查找和间接跳转，可以在固定时间内将控制转移到多个不同的目标地址，而不受 `case` 数量的影响。实际上，这段代码利用
    `switch`/`case` 表达式的值作为索引，查找地址表中的一个地址，然后（间接地）跳转到表项指定的语句。当 `case` 数量超过三四个时，这种方案通常比相应的
    `if..then..elseif` 链更快，且占用更少的内存。考虑以下汇编语言中 `switch`/`case` 语句的简单实现：
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: To see how this code operates, we’ll step through it one instruction at a time.
    The `jmpTable` declaration defines an array of four double-word pointers, one
    pointer for each case in our `switch` statement emulation. Entry 0 in the array
    holds the address of the statement to jump to when the `switch` expression evaluates
    to `0`, entry 1 contains the address of the statement to execute when the `switch`
    expression evaluates to `1`, and so on. Note that the array must have one element
    whose index matches each of the possible cases in the `switch` statement (`0`
    through `3` in this particular example).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看这段代码如何运作，我们将逐条指令进行分析。`jmpTable` 声明定义了一个包含四个双字指针的数组，每个指针对应 `switch` 语句模拟中的一个
    `case`。数组中的第 0 项保存了 `switch` 表达式计算结果为 `0` 时需要跳转到的语句地址，第 1 项保存了 `switch` 表达式计算结果为
    `1` 时需要执行的语句地址，依此类推。请注意，数组必须包含一个元素，其索引与 `switch` 语句中每个可能的 `case` 匹配（在此例中为 `0`
    至 `3`）。
- en: 'The first machine instruction in this example loads the value of the `switch`
    expression (variable `i`’s value) into the EAX register. Because this code uses
    the `switch` expression’s value as an index into the `jmpTable` array, this value
    must be an ordinal (integer) value in an 80x86 32-bit register. The next instruction
    (`jmp`) does the real work of the `switch` statement emulation: it jumps to the
    address specified by the entry in the `jmpTable` array, indexed by EAX. If EAX
    contains `0` upon execution of this `jmp` statement, the program fetches the double
    word from `jmpTable[0]` and transfers control to that address; this is the address
    of the first instruction following the `label0` label in the program code. If
    EAX contains `1`, then the `jmp` instruction fetches the double word at address
    `jmpTable + 4` in memory (note that the `*4` scaled-index addressing mode is used
    in this code; see “Indexed Addressing Mode” on [page 34](ch03.xhtml#page_34) for
    more details). Likewise, if EAX contains `2` or `3`, then the `jmp` instruction
    transfers control to the double-word address held at `jmpTable + 8` or `jmpTable
    + 12` (respectively). Because the `jmpTable` array is initialized with the addresses
    of `label0`, `label1`, `label2`, and `label3`, at respective offsets 0, 4, 8,
    and 12, this particular indirect `jmp` instruction will transfer control to the
    statement at the label corresponding to `i`’s value (`label0`, `label1`, `label2`,
    or `label3`, respectively).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的第一条机器指令将`switch`表达式的值（变量`i`的值）加载到EAX寄存器中。因为这段代码使用`switch`表达式的值作为索引来访问`jmpTable`数组，所以这个值必须是一个整数（整型）值，存储在80x86的32位寄存器中。接下来的指令（`jmp`）执行了`switch`语句仿真的实际工作：它跳转到由`jmpTable`数组中由EAX索引的条目所指定的地址。如果EAX在执行这条`jmp`指令时的值为`0`，程序将从`jmpTable[0]`获取双字，并将控制转移到该地址；这是程序代码中`label0`标签后面的第一条指令的地址。如果EAX的值为`1`，则`jmp`指令从内存地址`jmpTable
    + 4`获取双字（注意，这段代码使用了`*4`的缩放索引寻址模式；有关更多详细信息，请参阅[第34页](ch03.xhtml#page_34)）。同样，如果EAX的值为`2`或`3`，则`jmp`指令将控制转移到存储在`jmpTable
    + 8`或`jmpTable + 12`（分别）的双字地址。因为`jmpTable`数组已经初始化了`label0`、`label1`、`label2`和`label3`的地址，分别位于偏移量0、4、8和12，因此这个特定的间接`jmp`指令将把控制转移到与`i`的值相对应的标签语句（`label0`、`label1`、`label2`或`label3`）。
- en: The first point of interest about this `switch` statement emulation is that
    it requires only two machine instructions (and a jump table) to transfer control
    to any of the four possible cases. Contrast this with an `if..then..elseif` implementation,
    which requires at least two machine instructions for each case. Indeed, as you
    add more cases to the `if..then..elseif` implementation, the number of compare
    and conditional branch instructions increases, yet the number of machine instructions
    for the jump table implementation remains fixed at two (even though the size of
    the jump table increases by one entry for each case). Accordingly, the `if..then..elseif`
    implementation gets progressively slower as you add more cases, while the jump
    table implementation takes a constant amount of time to execute (regardless of
    the number of cases). Assuming your HLL compiler uses a jump table implementation
    for `switch` statements, a `switch` statement will typically be much faster than
    an `if..then..elseif` sequence if there are a large number of cases.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`switch`语句仿真最有趣的第一点是，它只需要两条机器指令（和一个跳转表）就能将控制转移到四个可能的案例中的任何一个。与此相比，`if..then..elseif`的实现，每个案例至少需要两条机器指令。实际上，随着你向`if..then..elseif`实现中添加更多的案例，比较和条件分支指令的数量会增加，而跳转表实现的机器指令数始终固定为两条（尽管跳转表的大小会因每个案例增加一个条目而增大）。因此，随着案例的增加，`if..then..elseif`实现会逐渐变慢，而跳转表实现则保持恒定的执行时间（无论案例的数量如何）。假设你的HLL编译器为`switch`语句使用了跳转表实现，那么如果有大量案例，`switch`语句通常会比`if..then..elseif`序列更快。
- en: The jump table implementation of `switch` statements does have a couple of drawbacks,
    though. First, because the jump table is an array in memory, and accessing (noncached)
    memory can be slow, accessing the jump table array could possibly impair system
    performance.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`switch`语句的跳转表实现也有几个缺点。首先，由于跳转表是内存中的一个数组，而访问（非缓存的）内存可能较慢，因此访问跳转表数组可能会影响系统性能。
- en: 'Another downside is that you must have one entry in the table for every possible
    case between the largest and the smallest case values, including those values
    for which you haven’t actually supplied an explicit case. In the example up to
    this point, this hasn’t been an issue because the case values started with `0`
    and were contiguous through `3`. However, consider the following Pascal `case`
    statement:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是，你必须在表格中为每一个可能的情况（从最大值到最小值之间的所有情况）创建一个条目，包括那些你并未明确提供的情况。在目前为止的示例中，这并不是一个问题，因为情况值从`0`开始，并且是连续的，直到`3`。然而，考虑以下的Pascal
    `case`语句：
- en: '[PRE44]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We can’t implement this `case` statement with a jump table containing four entries.
    If the value of `i` were `0` or `1`, then it would fetch the correct address.
    However, for case 5, the index into the jump table would be `20` (5 × 4), not
    the third (2 x 4 = 8) entry in the jump table. If the jump table contained only
    four entries (16 bytes), indexing into the jump table using the value `20` would
    grab an address beyond the end of the table and likely crash the application.
    This is exactly why in the original definition of Pascal, the results were undefined
    if the program supplied a case value that wasn’t present in the set of labels
    for a particular `case` statement.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法通过一个包含四个条目的跳转表来实现这个`case`语句。如果`i`的值是`0`或`1`，则会获取正确的地址。然而，对于情况5，跳转表的索引将是`20`（5
    × 4），而不是跳转表中的第三个（2 × 4 = 8）条目。如果跳转表只包含四个条目（16字节），那么使用值`20`进行索引将会获取到表格末尾之后的地址，并可能导致应用崩溃。这正是为什么在Pascal的原始定义中，如果程序提供了一个在特定`case`语句的标签集合中不存在的情况值，结果将是未定义的原因。
- en: 'To solve this problem in assembly language, you must make sure there are entries
    for each of the possible case labels as well as all values in between them. In
    the current example, the jump table would need nine entries to handle all the
    possible case values, `0` through `8`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决汇编语言中的这个问题，你必须确保每一个可能的情况标签都有相应的条目，并且所有这些标签之间的值也要包含在内。在当前示例中，跳转表需要九个条目来处理所有可能的情况值，从`0`到`8`：
- en: '[PRE45]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Notice that if `i` is equal to `2`, `3`, `4`, `6`, or `7`, then this code transfers
    control to the first statement beyond the `switch` statement (the standard semantics
    for C’s `switch` statement and the `case` statement in most modern variants of
    Pascal). Of course, C will also transfer control to this point in the code if
    the `switch`/`case` expression value is greater than the largest case value. Most
    compilers implement this feature with a comparison and conditional branch immediately
    before the indirect jump. For example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果`i`的值为`2`、`3`、`4`、`6`或`7`，那么这段代码会将控制转移到`switch`语句之后的第一个语句（这是C语言的`switch`语句和大多数现代Pascal变种中的`case`语句的标准语义）。当然，如果`switch`/`case`表达式的值大于最大情况值，C语言也会将控制转移到这段代码中的这一点。大多数编译器通过在间接跳转之前立即进行比较和条件分支来实现此功能。例如：
- en: '[PRE46]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You may have noticed another assumption that this code is making—that the case
    values start at `0`. Modifying the code to handle an arbitrary range of case values
    is simple. Consider the following example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到这段代码做出了另一个假设——即情况值从`0`开始。修改代码以处理任意范围的情况值是很简单的。考虑以下示例：
- en: '[PRE47]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: There are two differences between this example and the previous one. First,
    this example compares the value in EAX against the range `10..16` and, if the
    value falls outside this range, branches to the `switchDone` label (in other words,
    there is no case label for the value in EAX). Second, the `jmpTable` index has
    been modified to be `[eax*4 – 10*4]`. Arrays at the machine level always begin
    at index `0`; the “`- 10*4`” component of this expression adjusts for the fact
    that EAX actually contains a value starting at `10` rather than `0`. Effectively,
    this expression makes `jmpTable` start 40 bytes earlier in memory than its declaration
    states. Because EAX is always 10 or greater (40 bytes or greater because of the
    `eax*4` component), this code begins accessing the table at its declared beginning
    location. Note that HLA subtracts this offset from the address of `jmpTable`;
    the CPU doesn’t actually perform this subtraction at runtime. Hence, there is
    no additional efficiency loss to create this zero-based index.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子和之前的例子有两个区别。首先，这个例子将EAX中的值与范围`10..16`进行比较，如果值超出此范围，则跳转到`switchDone`标签（换句话说，EAX中的值没有对应的case标签）。其次，`jmpTable`的索引被修改为`[eax*4
    - 10*4]`。在机器级别，数组总是从索引`0`开始；该表达式中的“`- 10*4`”部分调整了EAX实际上包含的是从`10`开始的值，而不是从`0`开始。实际上，这个表达式使得`jmpTable`在内存中的起始位置比声明中所示提前了40个字节。因为EAX的值总是大于等于10（由于`eax*4`的作用，实际上是40字节或更大），所以这段代码从`jmpTable`声明的起始位置开始访问该表。需要注意的是，HLA从`jmpTable`的地址中减去这个偏移量；CPU在运行时并不会实际执行这次减法操作。因此，创建这个基于零的索引不会导致额外的效率损失。
- en: 'Notice that a fully generalized `switch`/`case` statement actually requires
    six instructions to implement: the original two instructions plus four instructions
    to test the range.^([3](footnotes.xhtml#ch13fn3)) This, plus the fact that an
    indirect jump is slightly more expensive to execute than a conditional branch,
    is why the break-even point for a `switch`/`case` statement (versus an `if..then..elseif`
    chain) is around three to four cases.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，完全通用的`switch`/`case`语句实际上需要六条指令来实现：原始的两条指令加上四条用于测试范围的指令。^([3](footnotes.xhtml#ch13fn3))
    这一点，再加上间接跳转的执行成本略高于条件分支的事实，解释了为什么`switch`/`case`语句（相对于`if..then..elseif`链）的盈亏平衡点大约在三到四个分支之间。
- en: 'As mentioned earlier, one serious drawback to the jump table implementation
    of the `switch`/`case` statement is the fact that you must have one table entry
    for every possible value between the smallest case and the largest case. Consider
    the following C/C++ `switch` statement:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`switch`/`case`语句的跳转表实现有一个严重的缺点，即你必须为从最小case到最大case之间的每一个可能的值准备一个表项。考虑以下C/C++
    `switch`语句：
- en: '[PRE48]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If the C/C++ compiler implements this `switch` statement using a jump table,
    that table will require 10,001 entries (that is, 40,004 bytes of memory on a 32-bit
    processor). That’s quite a chunk of memory for such a simple statement! Although
    the wide separation of the cases has a major effect on memory usage, it has only
    a minor effect on the execution speed of the `switch` statement. The program executes
    the same four instructions it would execute if the values were all contiguous
    (only four instructions are necessary because the case values start at `0`, so
    there’s no need to check the `switch` expression against a lower bound). Indeed,
    the only reason there’s a performance difference at all is because of the effects
    of the table size on the cache (it’s less likely you will find a particular table
    entry in the cache when the table is large). Speed issues aside, the memory usage
    by the jump table is difficult to justify for most applications. Therefore, if
    your particular compiler emits a jump table for all `switch`/`case` statements
    (which you can determine by looking at the code it produces), you should be careful
    about creating `switch`/`case` statements whose cases are widely separated.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果C/C++编译器使用跳转表来实现这个`switch`语句，那么该表将需要10,001个条目（也就是说，在32位处理器上需要40,004字节的内存）。对于这样一个简单的语句来说，这可是相当大的一块内存！虽然各个case之间的宽大间隔对内存使用有很大的影响，但它对`switch`语句的执行速度影响却微乎其微。程序执行的仍然是与值是连续的情况相同的四条指令（只需要四条指令，因为case值从`0`开始，所以无需检查`switch`表达式是否符合下界）。实际上，唯一导致性能差异的原因是表的大小对缓存的影响（当表非常大时，查找某个特定的表项时，缓存命中率较低）。抛开速度问题不谈，跳转表的内存使用对于大多数应用来说是难以证明其合理性的。因此，如果你的编译器为所有`switch`/`case`语句生成了跳转表（你可以通过查看它生成的代码来确定），那么你应该小心创建那些case分布较远的`switch`/`case`语句。
- en: '**13.5.3 Other Implementations of switch/case**'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**13.5.3 switch/case的其他实现**'
- en: 'Because of the issue with jump table sizes, some HLL compilers do not implement
    `switch`/`case` statements using jump tables. Some compilers will simply convert
    a `switch`/`case` statement into the corresponding `if..then..elseif` chain (Swift
    falls into this category). Obviously, such compilers tend to produce low-quality
    code (from a speed point of view) whenever a jump table would be appropriate.
    Many modern compilers are relatively smart about their code generation. They’ll
    determine the number of cases in a `switch`/`case` statement as well as the spread
    of the case values. Then the compiler will choose a jump table or `if..then..elseif`
    implementation based on some threshold criteria (code size versus speed). Some
    compilers might even use a combination of the techniques. For example, consider
    the following Pascal `case` statement:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于跳转表大小的问题，一些高级语言编译器并未使用跳转表实现`switch`/`case`语句。有些编译器会将`switch`/`case`语句简单地转换为相应的`if..then..elseif`链（Swift就是这种情况）。显然，这种编译器在跳转表合适的情况下会生成低质量的代码（从速度角度来看）。许多现代编译器在代码生成方面相对智能。它们会根据`switch`/`case`语句中的案例数量以及案例值的分布来选择使用跳转表还是`if..then..elseif`实现，这取决于一些阈值标准（代码大小与速度的平衡）。有些编译器甚至可能使用这些技术的组合。例如，考虑以下Pascal的`case`语句：
- en: '[PRE49]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'A good compiler will recognize that the majority of the cases work well in
    a jump table, with the exception of only one (or a few) cases. It will translate
    this code to a sequence of instructions that combine the `if..then` and jump table
    implementation. For example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的编译器会识别出大多数案例适合使用跳转表，只有少数（一个或几个）案例不适合。它会将代码转换为一系列结合了`if..then`和跳转表实现的指令。例如：
- en: '[PRE50]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Although the `switch`/`case` statement was originally created to allow the
    use of an efficient jump table transfer mechanism in an HLL, there are few language
    definitions that require a specific implementation for a control structure. Therefore,
    unless you stick with a specific compiler and you know how that compiler generates
    code under all circumstances, there’s absolutely no guarantee that your `switch`/`case`
    statements will compile to a jump table, an `if..then..elseif` chain, some combination
    of the two, or something else entirely. For example, consider the following short
    C program and the resulting assembly output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`switch`/`case`语句最初是为了在高级语言中使用高效的跳转表传输机制而创建的，但很少有语言定义要求特定的控制结构实现。因此，除非你坚持使用某个特定的编译器，并且知道该编译器在所有情况下如何生成代码，否则完全无法保证你的`switch`/`case`语句会编译成跳转表、`if..then..elseif`链、两者的组合，或者完全不同的东西。例如，考虑以下简短的C程序及其生成的汇编输出：
- en: '[PRE51]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here’s the 80x86 output from the (older) Borland C++ v5.0 compiler:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是（较旧版本的）Borland C++ v5.0编译器的80x86输出：
- en: '[PRE52]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you can see at the beginning of the main program, this code compares the
    value in `argc` against the four values (`1`, `2`, `10`, and `11`) sequentially.
    For a `switch` statement as small as this one, this isn’t a bad implementation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在主程序开始部分，代码将`argc`中的值依次与四个值（`1`、`2`、`10`和`11`）进行比较。对于这样一个小的`switch`语句，这并不是一个糟糕的实现。
- en: 'When there are a fair number of cases and a jump table would be too large,
    many modern optimizing compilers generate a binary search tree to test the cases.
    For example, consider the following C program and the corresponding output:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当有相当多的案例且跳转表会太大时，许多现代优化编译器会生成二叉搜索树来测试各个案例。例如，考虑以下C程序及其相应的输出：
- en: '[PRE53]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here’s the 64-bit MASM output from the Visual C++ compiler. Note how Microsoft’s
    compiler generates a partial binary search through each of the 10 cases:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自Visual C++编译器的64位MASM输出。注意，微软的编译器如何通过对每个10个案例进行部分二叉搜索：
- en: '[PRE54]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Interestingly enough, when compiling to 32-bit code, Visual C++ produces a
    true binary search. Here’s the MASM32 output from the 32-bit version of Visual
    C++:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在编译成32位代码时，Visual C++会生成真正的二叉搜索。以下是Visual C++ 32位版本的MASM32输出：
- en: '[PRE55]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Some compilers, especially those for some microcontroller devices, generate
    a table of *2-tuples* (paired records/structures), with one element of the tuple
    being the value of the case and the second element being the address to jump to
    if the value matches. Then the compiler emits a loop that scans through this little
    table searching for the current `switch`/`case` expression value. If this is a
    linear search, this implementation is even slower than the `if..then..elseif`
    chain. If the compiler emits a binary search, the code may be faster than an `if..then.elseif`
    chain but probably not as fast as a jump table implementation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编译器，特别是某些微控制器设备的编译器，会生成一个 *2 元组* 表（成对的记录/结构），元组的一个元素是 case 值，第二个元素是如果值匹配时跳转到的地址。然后编译器会生成一个循环，扫描这个小表，寻找当前
    `switch`/`case` 表达式的值。如果这是线性搜索，这种实现比 `if..then..elseif` 链还慢。如果编译器生成的是二分查找，代码可能会比
    `if..then..elseif` 链更快，但可能不如跳转表实现快。
- en: 'Here’s a Java example of a `switch` statement, along with the Java bytecode
    the compiler produces:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Java `switch` 语句的例子，以及编译器生成的 Java 字节码：
- en: '[PRE56]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `lookupswitch` bytecode instruction contains a table of 2-tuples. As described
    earlier, the first value of the tuple is the case value, and the second is the
    target address where the code transfers on a match. Presumably, the bytecode interpreter
    does a binary search on these values rather than a linear search (one would hope!).
    Notice that the Java compiler generates a separate call to method `f()` for each
    of the cases; it doesn’t optimize them to a single call as GCC and Visual C++
    do.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookupswitch` 字节码指令包含一个由 2 元组组成的表。如前所述，元组的第一个值是 case 值，第二个值是匹配时代码跳转的目标地址。可以推测，字节码解释器对这些值执行二分查找，而不是线性查找（希望是这样！）。注意，Java
    编译器为每个 case 生成了单独的 `f()` 方法调用；它并没有像 GCC 和 Visual C++ 那样将它们优化为单个调用。'
- en: '**NOTE**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Java also has a tableswitch VM instruction that executes a table-driven switch
    operation. The Java compiler chooses between the tableswitch and lookupswitch
    instructions based on the density of the case values.*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*Java 还具有一个 tableswitch 虚拟机指令，用于执行基于表驱动的 switch 操作。Java 编译器会根据 case 值的密度选择使用
    tableswitch 还是 lookupswitch 指令。*'
- en: 'Sometimes, compilers resort to some code tricks to generate marginally better
    code under certain circumstances. Consider again the short `switch` statement
    that led the Borland compiler to produce a linear search:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，编译器会采用一些代码技巧，在特定情况下生成略微更好的代码。再看看导致 Borland 编译器生成线性查找的简短 `switch` 语句：
- en: '[PRE57]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here’s the code that the Microsoft Visual C++ 32-bit compiler generates for
    this `switch` statement:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是微软 Visual C++ 32 位编译器为这个 `switch` 语句生成的代码：
- en: '[PRE58]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The trick in this 80x86 code is that Visual C++ first does a table lookup to
    make an `argc` value in the range `1..11` to a value in the range `0..3` (which
    corresponds to the three different code bodies appearing in the cases, plus a
    default case). This code is shorter than a jump table, with the corresponding
    double-word entries mapping to the default case, although it’s a little slower
    than a jump table because it needs to access two different tables in memory. (As
    for how the speed of this code compares with a binary search or linear search,
    that research is left to you; the answer will probably vary by processor.) Note,
    however, that when producing 64-bit code, Visual C++ reverts to the linear search:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 80x86 代码的技巧在于，Visual C++ 首先通过表查找将 `argc` 值范围 `1..11` 映射到值范围 `0..3`（对应于出现的三个不同的代码体，以及一个默认
    case）。这段代码比跳转表要短，双字条目对应于默认 case，尽管它比跳转表稍慢，因为它需要访问内存中的两个不同表。（至于这段代码的速度与二分查找或线性查找相比如何，这个研究留给你自己；答案可能因处理器而异。）然而需要注意的是，当生成
    64 位代码时，Visual C++ 会回退到线性查找：
- en: '[PRE59]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Few compilers give you the option of explicitly specifying how the compiler
    will translate a specific `switch`/`case` statement. For example, if you really
    want the `switch` statement with cases 0, 1, 10, 100, 1,000, and 10,000 given
    earlier to generate a jump table, you’ll have to write the code in assembly language
    or use a specific compiler whose code generation traits you understand. Any HLL
    code you’ve written that depends on the compiler generating a jump table won’t
    be portable to other compilers, however, because few languages specify the actual
    machine code implementation of high-level control structures.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有编译器允许你显式指定编译器如何转换特定的`switch`/`case`语句。例如，如果你真的希望之前提到的包含0、1、10、100、1000和10000这几个case的`switch`语句生成跳转表，你必须使用汇编语言编写代码，或者使用你理解其代码生成特性的特定编译器。然而，任何依赖于编译器生成跳转表的HLL代码都无法在其他编译器中移植，因为很少有语言指定高级控制结构的实际机器代码实现。
- en: 'Of course, you don’t have to totally rely on the compiler to generate decent
    code for a `switch`/`case` statement. Assuming your compiler uses the jump table
    implementation for all `switch`/`case` statements, you can help it produce better
    code when modifications to your HLL source code would generate a huge jump table.
    For example, consider the `switch` statement given earlier with the cases 0, 1,
    2, 3, 4, and 1,000\. If your compiler generates a jump table with 1,001 entries
    (consuming a little more than 4KB of memory), you can improve its output by writing
    the following Pascal code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不必完全依赖编译器为`switch`/`case`语句生成高效的代码。假设你的编译器对所有`switch`/`case`语句使用跳转表实现，当对你的HLL源代码做出修改时，可能会生成一个巨大的跳转表，你可以帮助编译器生成更好的代码。例如，考虑之前给出的`switch`语句，包含0、1、2、3、4和1000这几个case。如果你的编译器生成一个包含1001个条目的跳转表（占用超过4KB的内存），你可以通过编写以下Pascal代码来改善编译器的输出：
- en: '[PRE60]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: By handling case value `1000` outside the `switch` statement, the compiler can
    produce a short jump table for the main cases, which are contiguous.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将case值`1000`放在`switch`语句之外，编译器可以为主要的、连续的case生成一个简短的跳转表。
- en: 'Another possibility (which is arguably easier to read) is the following C/C++
    code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能性（可以说更容易阅读）是以下C/C++代码：
- en: '[PRE61]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: What makes this example slightly easier to read is that the code for the case
    when `i` is equal to `1000` has been moved into the `switch` statement (thanks
    to the default clause), so it doesn’t appear to be separate from all the tests
    taking place in the `switch`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个例子稍微容易阅读的原因是，当`i`等于`1000`时的代码已经被移入了`switch`语句中（得益于默认子句），因此它看起来不会与`switch`中进行的所有测试分开。
- en: Some compilers simply won’t generate a jump table for a `switch`/`case` statement.
    If you’re using such a compiler and you want to generate a jump table, there’s
    little you can do—short of dropping into assembly language or using nonstandard
    C extensions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编译器根本不会为`switch`/`case`语句生成跳转表。如果你使用的是这样的编译器，并且希望生成跳转表，那么除了使用汇编语言或非标准的C扩展之外，你几乎无能为力。
- en: 'Although jump table implementations of `switch`/`case` statements are generally
    efficient when you have a fair number of cases and they’re all equally likely,
    remember that an `if..then..elseif` chain can be faster if one or two cases are
    far more likely than the others. For example, if a variable has the value `15`
    more than half the time, the value `20` about a quarter of the time, and one of
    several different values the remaining 25 percent of the time, it’s probably more
    efficient to implement the multiway test using an `if..then..elseif` chain (or
    a combination of `if..then..elseif` and a `switch`/`case` statement). By testing
    the most common case(s) first, you can often reduce the average time the multiway
    statement needs to execute. For example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`switch`/`case`语句的跳转表实现通常在有大量case且它们的可能性相等时效率较高，但请记住，如果其中一两个case的可能性远高于其他case，使用`if..then..elseif`链可能更高效。例如，如果一个变量的值为`15`的时间超过一半，`20`的时间大约四分之一，而其余25%的时间则是其他几种不同的值，那么使用`if..then..elseif`链（或`if..then..elseif`和`switch`/`case`语句的组合）来实现多路选择可能更为高效。通过先测试最常见的case，你通常可以减少多路选择语句执行所需的平均时间。例如：
- en: '[PRE62]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If `i` is equal to `15` more often than not, then most of the time this code
    sequence will execute the body of the first `if` statement after executing only
    two instructions. Even in the best `switch` statement implementation, you’re going
    to need more instructions than this.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `i` 的值为 `15` 的情况出现得更多，那么大多数时候这段代码会在执行仅两条指令后，执行第一个 `if` 语句的主体。即使是在最好的 `switch`
    语句实现中，你仍然需要比这更多的指令。
- en: '**13.5.4 The Swift switch Statement**'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**13.5.4 Swift `switch` 语句**'
- en: 'Swift’s `switch` statement is semantically different from most other languages.
    There are four major differences between Swift’s `switch` and the typical C/C++
    `switch` or Pascal `case` statement:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 的 `switch` 语句在语义上与大多数其他语言不同。Swift 的 `switch` 和典型的 C/C++ `switch` 或 Pascal
    `case` 语句之间有四个主要区别：
- en: Swift’s `switch` provides a special `where` clause that lets you apply a conditional
    to a `switch`.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 的 `switch` 提供了一个特殊的 `where` 子句，允许你对 `switch` 应用条件。
- en: Swift’s `switch` allows you to use the same value in more than one `case` statement
    (differentiated by the `where` clause).
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 的 `switch` 允许你在多个 `case` 语句中使用相同的值（通过 `where` 子句区分）。
- en: Swift’s `switch` allows the use of nonintegral/ordinal data types, such as tuples,
    strings, and sets, as the selection value (with appropriately typed case values).
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 的 `switch` 允许使用非整数/序数数据类型，如元组、字符串和集合，作为选择值（并配有适当类型的 case 值）。
- en: Swift’s `switch` statement supports pattern matching for case values.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 的 `switch` 语句支持对 case 值进行模式匹配。
- en: Check out the Swift language reference manual for more details. The purpose
    of this section is not to provide the syntax and semantics of the Swift `switch`,
    but rather to discuss how Swift’s design affects its implementation.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请查阅 Swift 语言参考手册以获取更多细节。本节的目的是讨论 Swift 设计如何影响其实现，而不是提供 Swift `switch` 的语法和语义。
- en: Because it allows arbitrary types as the `switch` selector value, there’s no
    way that Swift could use a jump table to implement the `switch` statement. A jump
    table implementation requires an ordinal value (something you can represent as
    an integer) that the compiler can use as an index into the jump table. A string
    selector, for example, couldn’t be used as an index into an array. Furthermore,
    Swift allows you to specify the same case value twice,^([4](footnotes.xhtml#ch13fn4))
    creating a consistency problem with the same jump table entry mapping to two separate
    sections of code (which is impossible for a jump table).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它允许任意类型作为 `switch` 选择值，因此 Swift 无法使用跳转表来实现 `switch` 语句。跳转表实现需要一个序数值（可以表示为整数），编译器可以将其用作跳转表的索引。例如，字符串选择值不能用作数组的索引。此外，Swift
    允许你指定相同的 case 值两次^([4](footnotes.xhtml#ch13fn4))，这就导致了一个一致性问题，因为同一个跳转表条目会映射到代码的两个不同部分（这对于跳转表来说是不可能的）。
- en: Given the design of the Swift `switch` statement, then, the only solution is
    a linear search (effectively, the `switch` statement is equivalent to a chain
    of `if..else if..else if..etc`. statements). The bottom line is that there is
    no performance benefit to using the `switch` statement over a set of `if` statements.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于 Swift `switch` 语句的设计，唯一的解决方案是线性搜索（实际上，`switch` 语句等同于一系列 `if..else if..else
    if..etc` 语句）。最重要的是，使用 `switch` 语句并不会比使用一组 `if` 语句带来性能上的好处。
- en: '**13.5.5 Compiler Output for switch Statements**'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**13.5.5 `switch` 语句的编译器输出**'
- en: Before you run off to help your compiler produce better code for `switch` statements,
    you might want to examine the actual code it produces. This chapter has described
    several of the techniques that various compilers use for implementing `switch`/`case`
    statements at the machine code level, but there are several additional implementations
    that this book could not cover. Although you can’t assume that a compiler will
    always generate the same code for a `switch`/`case` statement, observing its output
    can help you see the different implementations that compiler authors use.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在你去帮助你的编译器生成更好的 `switch` 语句代码之前，你可能想检查一下它实际生成的代码。本章已经描述了各种编译器在机器码层面实现 `switch`/`case`
    语句时使用的几种技术，但还有一些额外的实现本书未能覆盖。尽管你不能假设编译器总是为 `switch`/`case` 语句生成相同的代码，观察它的输出有助于你了解编译器作者使用的不同实现方式。
- en: '**13.6 For More Information**'
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**13.6 更多信息**'
- en: 'Aho, Alfred V., Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman. *Compilers:
    Principles, Techniques, and Tools*. 2nd ed. Essex, UK: Pearson Education Limited,
    1986.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Aho, Alfred V., Monica S. Lam, Ravi Sethi 和 Jeffrey D. Ullman. *编译器：原理、技术与工具*（第2版）。英国埃塞克斯：皮尔逊教育有限公司，1986年。
- en: 'Barrett, William, and John Couch. *Compiler Construction: Theory and Practice*.
    Chicago: SRA, 1986.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Barrett, William, 和 John Couch. *编译器构造：理论与实践*. 芝加哥：SRA, 1986.
- en: 'Dershem, Herbert, and Michael Jipping. *Programming Languages, Structures and
    Models*. Belmont, CA: Wadsworth, 1990.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Dershem, Herbert, 和 Michael Jipping. *编程语言、结构与模型*. 贝尔蒙特，加利福尼亚州：Wadsworth, 1990.
- en: 'Duntemann, Jeff. *Assembly Language Step-by-Step*. 3rd ed. Indianapolis: Wiley,
    2009.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Duntemann, Jeff. *汇编语言一步步学*. 第3版. 印第安纳波利斯：Wiley, 2009.
- en: 'Fraser, Christopher, and David Hansen. *A Retargetable C Compiler: Design and
    Implementation*. Boston: Addison-Wesley Professional, 1995.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Fraser, Christopher, 和 David Hansen. *可重定向的 C 编译器：设计与实现*. 波士顿：Addison-Wesley
    Professional, 1995.
- en: 'Ghezzi, Carlo, and Jehdi Jazayeri. *Programming Language Concepts*. 3rd ed.
    New York: Wiley, 2008.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Ghezzi, Carlo, 和 Jehdi Jazayeri. *编程语言概念*. 第3版. 纽约：Wiley, 2008.
- en: 'Hoxey, Steve, Faraydon Karim, Bill Hay, and Hank Warren, eds. *The PowerPC
    Compiler Writer’s Guide*. Palo Alto, CA: Warthman Associates for IBM, 1996.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Hoxey, Steve, Faraydon Karim, Bill Hay, 和 Hank Warren, 编辑. *PowerPC 编译器编写者指南*.
    帕洛阿尔托，加利福尼亚州：Warthman Associates 为 IBM 出版, 1996.
- en: 'Hyde, Randall. *The Art of Assembly Language*. 2nd ed. San Francisco: No Starch
    Press, 2010.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Hyde, Randall. *汇编语言艺术*. 第2版. 旧金山：No Starch Press, 2010.
- en: Intel. “Intel 64 and IA-32 Architectures Software Developer Manuals.” Updated
    November 11, 2019\. *[https://software.intel.com/en-us/articles/intel-sdm](https://software.intel.com/en-us/articles/intel-sdm)*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Intel. “Intel 64 和 IA-32 架构软件开发者手册。”更新于2019年11月11日。*[https://software.intel.com/en-us/articles/intel-sdm](https://software.intel.com/en-us/articles/intel-sdm)*.
- en: 'Ledgard, Henry, and Michael Marcotty. *The Programming Language Landscape*.
    Chicago: SRA, 1986.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Ledgard, Henry, 和 Michael Marcotty. *编程语言的全景图*. 芝加哥：SRA, 1986.
- en: 'Louden, Kenneth C. *Compiler Construction: Principles and Practice*. Boston:
    Cengage, 1997.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Louden, Kenneth C. *编译器构造：原理与实践*. 波士顿：Cengage, 1997.
- en: 'Louden, Kenneth C., and Kenneth A. Lambert. *Programming Languages: Principles
    and Practice*. 3rd ed. Boston: Course Technology, 2012.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Louden, Kenneth C., 和 Kenneth A. Lambert. *编程语言：原理与实践*. 第3版. 波士顿：Course Technology,
    2012.
- en: 'Parsons, Thomas W. *Introduction to Compiler Construction*. New York: W. H.
    Freeman, 1992.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Parsons, Thomas W. *编译器构造导论*. 纽约：W. H. Freeman, 1992.
- en: 'Pratt, Terrence W., and Marvin V. Zelkowitz. *Programming Languages, Design
    and Implementation*. 4th ed. Upper Saddle River, NJ: Prentice Hall, 2001.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Pratt, Terrence W., 和 Marvin V. Zelkowitz. *编程语言：设计与实现*. 第4版. 上萨德尔河，新泽西州：Prentice
    Hall, 2001.
- en: 'Sebesta, Robert. *Concepts of Programming Languages*. 11th ed. Boston: Pearson,
    2016.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Sebesta, Robert. *编程语言概念*. 第11版. 波士顿：Pearson, 2016.
