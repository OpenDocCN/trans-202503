- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">INTERACTIVE
    AUTHENTICATION</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">交互式认证</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: When you authenticate to your Windows system, you’ll usually access a login
    interface, enter your credentials, and be greeted with the desktop. But quite
    a lot happens behind the scenes to make this authentication process work. *Interactive
    authentication* is the mechanism that converts a set of credentials into a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object that you can use to
    interact with authorization systems, such as access checks.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当你登录到 Windows 系统时，通常会看到一个登录界面，输入凭据后，你会进入桌面。但在幕后有许多操作确保这个认证过程正常工作。*交互式认证*是将一组凭据转换为一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> 对象的机制，你可以使用这个对象与授权系统交互，如访问检查。
- en: Windows uses many types of interactive authentication for a variety of purposes.
    For example, it uses one type when a user creates an interactive desktop and another
    when the user has provided credentials to a network-facing service. We’ll begin
    this chapter by exploring how Windows creates your interactive desktop when you
    authenticate to a Windows system. We’ll then cover how this interactive authentication
    is implemented through the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API. Finally, we’ll look at the various types of interactive authentication, the
    differences between them, and when they might be used.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 为了不同的用途使用了多种类型的交互式认证。例如，当用户创建交互式桌面时使用一种类型的认证，而当用户为网络服务提供凭据时则使用另一种类型。本章将首先探讨
    Windows 如何在你登录 Windows 系统时创建交互式桌面。接着，我们将介绍通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API 实现的交互式认证。最后，我们将讨论各种交互式认证的类型、它们之间的区别以及何时使用它们。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating a User’s Desktop</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">创建用户桌面</samp>
- en: The most common way of interacting with a Windows system is via the user interface
    on a desktop. [Figure 12-1](chapter12.xhtml#fig12-1) summarizes the process of
    creating a user’s desktop.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Windows 系统交互最常见的方式是通过桌面上的用户界面。[图 12-1](chapter12.xhtml#fig12-1) 总结了创建用户桌面的过程。
- en: '![](../images/Figure12-1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: An overview of
    interactive desktop creation</samp>'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-1：交互式桌面创建概述</samp>
- en: When the Windows system starts, the session manager creates a console session,
    as described in [Chapter 3](chapter3.xhtml). In this console session it starts
    an instance of the Winlogon process, which gathers credentials and starts the
    new user’s processes once they’re authenticated. The Winlogon process then creates
    the LogonUI process to display a UI. The LogonUI process reads the credentials
    from the user and passes them back to Winlogon ❶.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Windows 系统启动时，会话管理器会创建一个控制台会话，如[第 3 章](chapter3.xhtml)所述。在此控制台会话中，它会启动 Winlogon
    进程实例，该进程收集凭据并在凭据验证后启动新用户的进程。然后，Winlogon 进程创建 LogonUI 进程以显示用户界面。LogonUI 进程从用户处读取凭据并将其传回
    Winlogon ❶。
- en: Next, the Winlogon process sends the credentials to the LSA’s <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API to verify that they’re correct ❷. If the user has successfully authenticated,
    a token representing the user’s identity is returned to Winlogon ❸. The console
    session can then be reconfigured for the user, a process that includes creating
    a window station and desktop and spawning the user initialization process using
    the user’s token ❹.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Winlogon 进程将凭据发送到 LSA 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API，以验证凭据是否正确 ❷。如果用户成功认证，一个表示用户身份的令牌将返回给 Winlogon ❸。然后，控制台会话可以重新配置用户，这个过程包括创建窗口站和桌面，并使用用户的令牌启动用户初始化进程
    ❹。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API directly
    supports the most common type of credential, a username and password pair. However,
    Windows allows many other local authentication factors as well, such as biometric
    data (for example, a scanning of the user’s face) or a simple PIN. To handle these,
    Winlogon loads a credential provider when needed. Each provider is responsible
    for mapping its credential type to one that <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    supports to get the token.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API 直接支持最常见的凭证类型，即用户名和密码对。然而，Windows
    也允许许多其他本地身份验证因素，例如生物特征数据（例如扫描用户面部）或简单的 PIN 码。为了处理这些，Winlogon 在需要时加载凭证提供程序。每个提供程序负责将其凭证类型映射到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> 支持的凭证类型，从而获取令牌。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The LsaLogonUser API</samp>
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">LsaLogonUser API</samp>
- en: 'We know the basics of how to create a desktop on Windows. Now let’s dig into
    how the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API
    implements the interactive authentication service for Winlogon and other applications
    on the local system. This API might seem quite complex, but it really requires
    only three pieces of information from an application to authenticate a user:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何在 Windows 上创建桌面的基本知识。现在，让我们深入探讨 <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API 如何实现 Winlogon 和其他应用程序在本地系统上的交互式身份验证服务。这个 API 可能看起来很复杂，但实际上它只需要应用程序提供三项信息即可验证用户：
- en: The logon type requested
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求的登录类型
- en: The security package identifier
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全包标识符
- en: The user’s credentials
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的凭证
- en: The API uses the *logon type* to accommodate different authentication scenarios.
    [Table 12-1](chapter12.xhtml#tab12-1) lists the logon types most commonly used
    by applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该 API 使用 *登录类型* 来适应不同的身份验证场景。[表 12-1](chapter12.xhtml#tab12-1) 列出了应用程序最常使用的登录类型。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-1:</samp> <samp class="SANS_Futura_Std_Book_11">Common
    Logon Types</samp>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 12-1：</samp> <samp class="SANS_Futura_Std_Book_11">常见的登录类型</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Logon type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">登录类型</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp>
    |'
- en: '| --- | --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp> | <samp
    class="SANS_Futura_Std_Book_11">Interact with a local desktop.</samp> |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">交互式</samp> | <samp class="SANS_Futura_Std_Book_11">通过本地桌面与系统进行交互。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Batch</samp> | <samp class="SANS_Futura_Std_Book_11">Run
    as a background process, even if no desktop is available.</samp> |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">批处理</samp> | <samp class="SANS_Futura_Std_Book_11">作为后台进程运行，即使没有桌面可用。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp> | <samp class="SANS_Futura_Std_Book_11">Run
    as a system service.</samp> |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">服务</samp> | <samp class="SANS_Futura_Std_Book_11">作为系统服务运行。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp> | <samp class="SANS_Futura_Std_Book_11">Interact
    with the system from a network client.</samp> |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">网络</samp> | <samp class="SANS_Futura_Std_Book_11">通过网络客户端与系统进行交互。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NetworkCleartext</samp> | <samp
    class="SANS_Futura_Std_Book_11">Perform network authentication, but store the
    user’s credentials for later use.</samp> |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NetworkCleartext</samp> | <samp
    class="SANS_Futura_Std_Book_11">执行网络身份验证，但将用户的凭证存储以备后用。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp> | <samp
    class="SANS_Futura_Std_Book_11">Clone the caller’s token and change network user
    credentials.</samp> |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp> | <samp
    class="SANS_Futura_Std_Book_11">克隆调用者的令牌并更改网络用户凭证。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp> |
    <samp class="SANS_Futura_Std_Book_11">Interact with a desktop via the Remote Desktop
    Protocol.</samp> |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp> |
    <samp class="SANS_Futura_Std_Book_11">通过远程桌面协议与桌面进行交互。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unlock</samp> | <samp class="SANS_Futura_Std_Book_11">Verify
    the user’s credentials for unlocking the desktop.</samp> |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">解锁</samp> | <samp class="SANS_Futura_Std_Book_11">验证用户凭证以解锁桌面。</samp>
    |'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Unlock</samp> is a special type
    that Winlogon uses to verify a user’s credentials on the lock screen, and it isn’t
    typically used by applications directly. We’ll come back to some of the other
    logon types later in the chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">解锁</samp> 是 Winlogon 用于在锁屏界面上验证用户凭据的特殊类型，通常不会被应用程序直接使用。我们将在本章稍后回到其他几种登录类型。
- en: Windows abstracts the details of authentication to a *security package*, which
    provides a standardized interface to an authentication protocol. The authentication
    protocol is a formal process that takes a set of credentials and verifies that
    they’re valid. It also provides a mechanism to return information about the verified
    user, such as their group memberships. We also sometimes refer to a security package
    as a *security support provider (SSP).*
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 将身份验证的细节抽象为一个*安全包*，该包提供了一个标准化的接口来实现身份验证协议。身份验证协议是一个正式的过程，它接受一组凭据并验证其有效性。它还提供了一种机制，用于返回关于经过验证的用户的信息，如其组成员身份。有时我们也将安全包称为*安全支持提供者（SSP）*。
- en: We can enumerate the available security packages using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaPackage</samp>
    PowerShell command, as shown in [Listing 12-1](chapter12.xhtml#Lis12-1).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaPackage</samp> PowerShell
    命令列举可用的安全包，如 [清单 12-1](chapter12.xhtml#Lis12-1) 所示。
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 12-1: Enumerating the supported security packages'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-1：列举支持的安全包
- en: Applications typically access a security package via a more generic API that
    is agnostic to the authentication protocol used. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    works across multiple different packages by accepting a unique identifier for
    the package to use. A security package can also implement a network authentication
    protocol, which we’ll cover in more depth in the following chapters.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常通过一个更通用的 API 访问安全包，该 API 与所使用的身份验证协议无关。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    通过接受一个用于指定包的唯一标识符，跨多个不同的包工作。安全包还可以实现网络身份验证协议，我们将在后续章节中详细介绍。
- en: The most widely used security packages for local authentication are *Negotiate*
    ❶ and *NT LAN Manager (NTLM)* ❷. The NTLM authentication protocol was introduced
    in Windows NT 3.1, and it’s also sometimes referred to as the *Microsoft Authentication
    Package V1.0* in documentation. The Negotiate package can automatically select
    between different authentication protocols, depending on the circumstances. For
    example, it might select NTLM if authenticating locally to the SAM database or
    Kerberos when authenticating to a domain.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的本地身份验证安全包是*Negotiate* ❶ 和 *NT LAN Manager (NTLM)* ❷。NTLM 身份验证协议在 Windows
    NT 3.1 中首次引入，在文档中有时也被称为*Microsoft 身份验证包 V1.0*。Negotiate 包可以根据具体情况自动选择不同的身份验证协议。例如，它可能会在本地对
    SAM 数据库进行身份验证时选择 NTLM，或者在对域进行身份验证时选择 Kerberos。
- en: The supported credential types depend on the security package being used for
    the authentication. For example, NTLM supports only username and password credentials,
    whereas Kerberos supports X.509 certificates and smart card authentication in
    addition to a username and password.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的凭据类型取决于用于身份验证的安全包。例如，NTLM 只支持用户名和密码凭据，而 Kerberos 除了支持用户名和密码外，还支持 X.509 证书和智能卡身份验证。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Local Authentication</samp>
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">本地身份验证</samp>
- en: Let’s explore how the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API authenticates a user in more detail. [Figure 12-2](chapter12.xhtml#fig12-2)
    gives an overview of this process for a user in the local SAM database.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨 <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API 如何进行用户身份验证。[图 12-2](chapter12.xhtml#fig12-2) 给出了本地 SAM 数据库中用户身份验证过程的概述。
- en: '![](../images/Figure12-2.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-2: The local authentication
    process using LsaLogonUser</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-2：使用 LsaLogonUser 进行本地身份验证的过程</samp>
- en: Due to the complexities of the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API, it’s more common for an application to use a simpler API provided by the
    system. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonUser</samp>
    API accepts a username, a domain name, a password, and the logon type and formats
    the parameters appropriately for the underlying security package.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于<samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API的复杂性，应用程序通常会使用系统提供的更简单的API。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LogonUser</samp> API接受用户名、域名、密码和登录类型，并为底层安全包适当地格式化参数。
- en: It then forwards these parameters, including the user’s credentials, to the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API in the LSA
    process ❶. The API in turn forwards the authentication request to the chosen security
    package, which in this case is the NTLM package implemented in the *MSV1_0.DLL*
    library.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将这些参数，包括用户的凭证，转发给LSA进程中的<samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API ❶。该API又将身份验证请求转发给所选的安全包，在这种情况下是实现于*MSV1_0.DLL*库中的NTLM包。
- en: The security package checks whether the user exists in the local SAM database.
    If it does, the user’s password is converted to an NT hash (discussed in [Chapter
    10](chapter10.xhtml)), and then it is compared against the value stored in the
    database ❷. If the hashes match and the user account is enabled, the authentication
    proceeds and the user’s details, such as group membership, are read from the SAM
    database for the authentication process to use.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 安全包检查用户是否存在于本地SAM数据库中。如果存在，用户的密码将被转换为NT哈希（在[第10章](chapter10.xhtml)中讨论），然后与数据库中存储的值进行比较
    ❷。如果哈希值匹配且用户帐户已启用，则身份验证继续进行，用户的详细信息，例如组成员身份，将从SAM数据库中读取，用于身份验证过程。
- en: Now that the security package knows the user’s group membership and account
    details, it can check whether the local security policy allows the user to authenticate
    ❸. The main policy checks whether the logon type requested is granted an account
    right. [Table 12-2](chapter12.xhtml#tab12-2) lists the logon types and the account
    rights the user must be granted in order to authenticate. Note that the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp> logon type doesn’t
    need a specific account right; we’ll cover why in the “Network Credentials” box
    on page 407.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在安全包已经知道了用户的组成员身份和帐户详细信息，它可以检查本地安全策略是否允许该用户进行身份验证 ❸。主要的策略检查请求的登录类型是否被授予帐户权限。[表
    12-2](chapter12.xhtml#tab12-2)列出了登录类型以及用户必须被授予的帐户权限，才能进行身份验证。请注意，<samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp>
    登录类型不需要特定的帐户权限；我们将在407页的“网络凭据”框中解释原因。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-2:</samp> <samp class="SANS_Futura_Std_Book_11">Logon
    Types and Associated Allow and Deny Account Rights</samp>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 12-2：</samp> <samp class="SANS_Futura_Std_Book_11">登录类型及相关的允许与拒绝帐户权限</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Logon type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Allow
    account right</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Deny account right</samp>
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">登录类型</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">允许帐户权限</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">拒绝帐户权限</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeDenyInteractiveLogonRight</samp> |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">交互式</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyInteractiveLogonRight</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Batch</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBatchLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyBatchLogonRight</samp> |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">批处理</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBatchLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyBatchLogonRight</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeServiceLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyServiceLogonRight</samp>
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">服务</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeServiceLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyServiceLogonRight</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeNetworkLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyNetworkLogonRight</samp>
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeNetworkLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyNetworkLogonRight</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NetworkCleartext</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeNetworkLogonRight</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyNetworkLogonRight</samp>
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NetworkCleartext</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeNetworkLogonRight</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyNetworkLogonRight</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp> | <samp
    class="SANS_Futura_Std_Book_11">N/A</samp> | <samp class="SANS_Futura_Std_Book_11">N/A</samp>
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp> | <samp
    class="SANS_Futura_Std_Book_11">N/A</samp> | <samp class="SANS_Futura_Std_Book_11">N/A</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRemoteInteractiveLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyRemoteInteractiveLogonRight</samp>
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRemoteInteractiveLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyRemoteInteractiveLogonRight</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unlock</samp> | <samp class="SANS_Futura_Std_Book_11">The
    same as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp>
    <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp>
    | <samp class="SANS_Futura_Std_Book_11">The same as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp>
    <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp>
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unlock</samp> | <samp class="SANS_Futura_Std_Book_11">与</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp> <samp class="SANS_Futura_Std_Book_11">或</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp> <samp class="SANS_Futura_Std_Book_11">相同</samp>
    | <samp class="SANS_Futura_Std_Book_11">与</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp>
    <samp class="SANS_Futura_Std_Book_11">或</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp>
    <samp class="SANS_Futura_Std_Book_11">相同</samp> |'
- en: If the user doesn’t have the necessary account right granted or is explicitly
    denied the right, the authentication will fail. There can be other limitations
    on authentication, as well; for example, you could configure a user so that they’re
    allowed to authenticate only between certain times, or even only on certain days
    of the week. If the user doesn’t meet one of the policy requirements, the security
    package will reject the authentication.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户没有被授予必要的账户权限或明确被拒绝该权限，身份验证将失败。身份验证还可能受到其他限制；例如，您可以配置用户使其仅在特定时间段或甚至仅在特定的星期几进行身份验证。如果用户未满足某个策略要求，安全包将拒绝该身份验证。
- en: If the user’s credentials are valid and the policy permits them to authenticate,
    the LSA can create a token using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp>
    system call based on the information about the user and their privileges extracted
    from the SAM and LSA policy databases ❹. The application receives a handle to
    a token, which the user can subsequently use for impersonation or to create a
    new process within the limits of the assignment, as described in [Chapter 4](chapter4.xhtml).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户的凭证有效且策略允许其进行身份验证，LSA 可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp>
    系统调用，根据从 SAM 和 LSA 策略数据库中提取的有关用户及其权限的信息创建一个令牌 ❹。应用程序接收一个令牌句柄，用户随后可以使用该令牌进行模拟，或在分配的限制范围内创建新进程，具体说明见
    [第 4 章](chapter4.xhtml)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Domain Authentication</samp>
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">域身份验证</samp>
- en: Authenticating a user to a domain controller is not significantly different
    from local authentication, but it’s still worth highlighting the small distinctions.
    [Figure 12-3](chapter12.xhtml#fig12-3) shows the domain authentication process.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对用户进行域控制器身份验证与本地身份验证没有显著差异，但值得强调的是其中的一些小区别。 [图 12-3](chapter12.xhtml#fig12-3)
    展示了域身份验证过程。
- en: '![](../images/Figure12-3.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-3: The domain authentication
    process using LsaLogonUser</samp>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-3：使用 LsaLogonUser 的域身份验证过程</samp>
- en: The domain authentication process starts in the same manner as local authentication.
    The application provides the credentials and other parameters to the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API running in the LSA process ❶. At this point, it’s likely that API will use
    the Negotiate security package to select the most appropriate security package
    to authenticate with.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 域认证过程的开始方式与本地认证相同。应用程序将凭据和其他参数提供给运行在 LSA 进程中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API ❶。此时，API 很可能会使用 Negotiate 安全包来选择最合适的安全包进行认证。
- en: In this example, it once again uses the NTLM security package, which is easy
    to understand. However, in a modern Windows network, you’re more likely to find
    Kerberos used. Interactive authentication with Kerberos is much more complex,
    so I’ll wait until [Chapter 14](chapter14.xhtml) to provide details about it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，它再次使用 NTLM 安全包，这个包容易理解。然而，在现代的 Windows 网络中，更常见的是使用 Kerberos。Kerberos
    的交互式认证要复杂得多，所以我将在[第 14 章](chapter14.xhtml)中详细讲解它。
- en: Windows also supports online authentication protocols, such as those for Microsoft
    and Azure Active Directory accounts. Authentication for these accounts uses the
    *CloudAP* security package, which Negotiate will select automatically if it’s
    the best security package to use. Details of this selection process are beyond
    the scope of this book, although we’ll cover some aspects of Negotiate in [Chapter
    15](chapter15.xhtml).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 还支持在线认证协议，如用于 Microsoft 和 Azure Active Directory 账户的协议。这些账户的认证使用 *CloudAP*
    安全包，若这是最佳的安全包，Negotiate 将自动选择它。尽管我们会在[第 15 章](chapter15.xhtml)中涉及 Negotiate 的一些方面，但这个选择过程的细节超出了本书的范围。
- en: The NTLM security package once again generates the NT hash, but instead of consulting
    the local SAM database, it determines the domain controller for the user’s domain.
    It then forwards the authentication request containing the user’s name and NT
    hash to the domain controller’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NetrLogonSamLogon</samp>
    API using the *Netlogon* network protocol.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: NTLM 安全包再次生成 NT 哈希，但它不再查询本地 SAM 数据库，而是确定用户域的域控制器。然后，它通过 *Netlogon* 网络协议将包含用户名称和
    NT 哈希的认证请求转发到域控制器的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NetrLogonSamLogon</samp>
    API。
- en: While Windows has deprecated the Netlogon protocol for primary domain authentication,
    it has not removed the protocol in the latest versions. Not removing legacy features
    can result in important security issues as technology becomes obsolete and security
    expectations change. For example, CVE-2020-1472, dubbed *Zerologon*, was a serious
    vulnerability in the Netlogon protocol that allowed unauthenticated users to compromise
    the entire domain network due to a flaw in the weak cryptography used by the protocol.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Windows 已经弃用了 Netlogon 协议用于主域认证，但在最新版本中该协议并未被移除。不删除旧有功能可能会导致重要的安全问题，因为随着技术过时和安全需求的变化，原有的安全措施可能变得不再适用。例如，CVE-2020-1472，俗称
    *Zerologon*，是 Netlogon 协议中的一个严重漏洞，允许未经认证的用户利用该协议中弱加密的缺陷来攻破整个域网络。
- en: The domain controller verifies the user’s credentials in the domain’s user database
    ❷. For modern versions of Windows, this is Active Directory, not a SAM database.
    The user must also be enabled for the authentication to succeed. If the hashes
    match, the user’s information is extracted from Active Directory and returned
    to the client system.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 域控制器在域的用户数据库中验证用户的凭据 ❷。对于现代版本的 Windows，这是 Active Directory，而不是 SAM 数据库。用户也必须启用才能使认证成功。如果哈希匹配，用户的信息将从
    Active Directory 提取并返回到客户端系统。
- en: Once the user’s credentials have been validated, the client system can verify
    its local policy ❸ to determine whether the user is permitted to authenticate
    based on the logon type and other restrictions, such as time limits. If every
    check succeeds, the LSA generates the token and returns it to the application
    ❹.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户的凭据被验证，客户端系统可以验证其本地策略 ❸，以确定用户是否被允许基于登录类型和其他限制（如时间限制）进行认证。如果每项检查都通过，LSA 将生成令牌并返回给应用程序
    ❹。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Logon and Console
    Sessions</samp>
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">登录和控制台会话</samp>
- en: Once the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API
    has verified the user’s credentials, it can create an initial token for the user.
    Before it can make a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp>,
    however, the LSA must set up an associated logon session. We discussed the logon
    session in [Chapter 4](chapter4.xhtml), in the context of the token’s authentication
    ID, but it’s worth going into more depth about what it contains.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦<samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API验证了用户的凭据，它就可以为用户创建初始令牌。然而，在调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp>之前，LSA必须设置一个关联的登录会话。我们在[第4章](chapter4.xhtml)中讨论了登录会话，特别是在令牌的身份验证ID上下文中，但值得更深入地了解它所包含的内容。
- en: Let’s begin by querying the LSA for all current logon sessions using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-NtLogonSession</samp> PowerShell command,
    as shown in [Listing 12-2](chapter12.xhtml#Lis12-2). You should run this command
    as an administrator to display all the logon sessions on the system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtLogonSession</samp>
    PowerShell命令查询LSA以获取所有当前的登录会话，如[清单12-2](chapter12.xhtml#Lis12-2)所示。你应该以管理员身份运行此命令，以显示系统上的所有登录会话。
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 12-2: Displaying all current logon sessions'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-2：显示所有当前的登录会话
- en: We can see that the first two sessions are for service accounts ❶, as indicated
    by the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonType</samp> value. Oddly,
    the third session is also a service account, for the *SYSTEM* user, but notice
    that the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonType</samp> is undefined
    ❷. This is because the kernel creates the *SYSTEM* logon session before the LSA
    process is started, which means no authentication has taken place.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，前两个会话是服务帐户❶，这是由<samp class="SANS_TheSansMonoCd_W5Regular_11">LogonType</samp>值指示的。奇怪的是，第三个会话也是服务帐户，属于*SYSTEM*用户，但请注意，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LogonType</samp>是未定义的❷。这是因为内核在LSA进程启动之前就创建了*SYSTEM*登录会话，这意味着没有进行身份验证。
- en: The rest of the logon sessions are for interactive accounts, as indicated by
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp> logon type
    ❸. Only one user is authenticated ❹; the other accounts belong to system processes
    such as the user-mode font driver (UMFD) and the desktop window manager (DWM).
    We won’t cover these system processes in any detail. Observe that the current
    user has two logon sessions. This is because of UAC, introduced in [Chapter 4](chapter4.xhtml);
    we’ll come back to why UAC generates two sessions in “Token Creation” on page
    407.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的登录会话是互动帐户，如<samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp>登录类型❸所示。只有一个用户被验证❹；其他帐户属于系统进程，如用户模式字体驱动程序（UMFD）和桌面窗口管理器（DWM）。我们不会详细讨论这些系统进程。请注意，当前用户有两个登录会话。这是由于UAC（在[第4章](chapter4.xhtml)中介绍）；我们将在“令牌创建”部分（第407页）回到为什么UAC会生成两个会话。
- en: Notice also that a <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionId</samp>
    is shown for each logon session, in addition to the authentication identifier
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">LogonId</samp>) that identifies
    the account. This is the console session ID. It’s important not to confuse the
    logon session and console session types. As this output shows, it’s possible for
    a single console session to host multiple separate logon sessions, and for a single
    logon session to be used across multiple console sessions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，每个登录会话都会显示一个<samp class="SANS_TheSansMonoCd_W5Regular_11">SessionId</samp>，除了用于标识帐户的身份验证标识符（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LogonId</samp>）。这是控制台会话ID。不要将登录会话和控制台会话类型混淆非常重要。正如这个输出所示，一个控制台会话可以托管多个独立的登录会话，而一个登录会话也可以跨多个控制台会话使用。
- en: The LSA stores the console session ID originally associated with the logon session
    when it was created. In [Listing 12-3](chapter12.xhtml#Lis12-3), we query the
    LSA for all current console sessions with <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtConsoleSession</samp>.
    This behavior allows multiple users to share the same console and desktop.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: LSA存储与登录会话关联的原始控制台会话ID，当它被创建时。在[清单12-3](chapter12.xhtml#Lis12-3)中，我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-NtConsoleSession</samp>查询LSA获取所有当前的控制台会话。这种行为允许多个用户共享同一个控制台和桌面。
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 12-3: Displaying all current console sessions'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-3：显示所有当前的控制台会话
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionName</samp> column
    indicates where the console session is connected. Session 0 is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Services</samp>
    console, meaning it’s used only for system services. The <samp class="SANS_TheSansMonoCd_W5Regular_11">State</samp>
    column indicates the state of the UI. For session 0 this is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Disconnected</samp>,
    as there is no UI displayed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionName</samp> 列表示控制台会话连接的位置。会话
    0 是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Services</samp> 控制台，意味着它仅用于系统服务。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">State</samp> 列表示 UI 的状态。对于会话 0，它被设置为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Disconnected</samp>，因为没有显示 UI。
- en: Session 1 is created on demand when the user successfully completes the interactive
    authentication process. The <samp class="SANS_TheSansMonoCd_W5Regular_11">UserName</samp>
    column identifies the authenticated user. The session state is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Active</samp>,
    as this is the console session in which I ran the PowerShell command. The session
    name is a unique value indicating that this is a remote desktop connection.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 会话 1 在用户成功完成交互式身份验证过程后按需创建。<samp class="SANS_TheSansMonoCd_W5Regular_11">UserName</samp>
    列标识经过身份验证的用户。会话状态被设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Active</samp>，因为这是我运行
    PowerShell 命令的控制台会话。会话名称是一个唯一值，表明这是一个远程桌面连接。
- en: Finally, session 2 lives on the physical console. It shows a state of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Connected</samp>, as it currently hosts
    a LogonUI in case a user tries to physically log in to the machine. However, at
    this point there’s no authenticated user in session 2, as you can see by the absence
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">UserName</samp> in the listing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，会话 2 位于物理控制台上。它显示为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Connected</samp>
    状态，因为它当前承载 LogonUI，以防用户尝试通过物理方式登录到计算机。然而，此时会话 2 中没有经过身份验证的用户，如列表中没有 <samp class="SANS_TheSansMonoCd_W5Regular_11">UserName</samp>
    所示。
- en: '[Figure 12-4](chapter12.xhtml#fig12-4) summarizes the relationships between
    logon sessions and console sessions in this example. The console sessions are
    the gray boxes in the background, and the logon sessions are the white boxes in
    the foreground.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-4](chapter12.xhtml#fig12-4) 总结了本示例中登录会话和控制台会话之间的关系。控制台会话是背景中的灰色框，而登录会话是前景中的白色框。'
- en: '![](../images/Figure12-4.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-4: The console and
    logon sessions</samp>'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-4：控制台和登录会话</samp>
- en: 'Notice that console session 0 contains the service logon sessions, such as
    those for the local system, the network service, and the local service. The local
    system logon session is also used for the LogonUI process running in console session
    2\. At the bottom right is console session 1, which contains two user logon sessions:
    one for the UAC administrator and one for the filtered non-administrator.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，控制台会话 0 包含服务登录会话，例如本地系统、网络服务和本地服务的会话。本地系统登录会话还用于控制台会话 2 中运行的 LogonUI 进程。右下角是控制台会话
    1，其中包含两个用户登录会话：一个是 UAC 管理员会话，另一个是过滤后的非管理员会话。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Token Creation</samp>
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">令牌创建</samp>
- en: With a new logon session, the LSA can create the final <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object for the user. To do this, it must gather information about the token’s
    various security properties, including the user’s groups, privileges, and logon
    session ID, then pass these to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp>.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的登录会话中，LSA 可以为用户创建最终的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    对象。为此，它必须收集有关令牌的各种安全属性的信息，包括用户的组、特权和登录会话 ID，然后将这些信息传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp>。
- en: You might be wondering where the user’s groups come from. As domain authentication
    is the most complex case, let’s consider the groups assigned to a domain user
    token when Winlogon authenticates the user. (The group assignment will look similar
    in the local authentication process, except that the LSA will consider only local
    groups.) [Table 12-3](chapter12.xhtml#tab12-3) shows the group assignments for
    the *alice* user.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，用户的组是从哪里来的。由于域身份验证是最复杂的情况，让我们考虑一下 Winlogon 在对用户进行身份验证时，分配给域用户令牌的组。（在本地身份验证过程中，组分配会相似，唯一的不同是
    LSA 只会考虑本地组。）[表 12-3](chapter12.xhtml#tab12-3) 显示了 *alice* 用户的组分配。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-3:</samp> <samp class="SANS_Futura_Std_Book_11">Groups
    Added to an Interactive Token on a Domain-Joined System</samp>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 12-3：</samp> <samp class="SANS_Futura_Std_Book_11">在域加入系统的交互令牌中添加的组</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Group name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Group
    source</samp> |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">组名</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">组来源</samp>
    |'
- en: '| --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">MINERAL\alice</samp> | <samp
    class="SANS_Futura_Std_Book_11">Domain user account</samp> |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">MINERAL\alice</samp> | <samp
    class="SANS_Futura_Std_Book_11">域用户帐户</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">MINERAL\Domain Users</samp>
    | <samp class="SANS_Futura_Std_Book_11">Domain group membership</samp> |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">MINERAL\Domain Users</samp>
    | <samp class="SANS_Futura_Std_Book_11">域组成员</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">Authentication authority
    asserted identity</samp> |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">身份验证机构声明的身份</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\Claims Valid</samp>
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\Claims Valid</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">MINERAL\Local Resource</samp>
    | <samp class="SANS_Futura_Std_Book_11">Domain-local resource group membership</samp>
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">MINERAL\Local Resource</samp>
    | <samp class="SANS_Futura_Std_Book_11">域本地资源组成员</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">BUILTIN\Administrators</samp>
    | <samp class="SANS_Futura_Std_Book_11">Local group membership</samp> |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">BUILTIN\Administrators</samp>
    | <samp class="SANS_Futura_Std_Book_11">本地组成员</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">BUILTIN\Users</samp> |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">BUILTIN\Users</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\INTERACTIVE</samp>
    | <samp class="SANS_Futura_Std_Book_11">Automatic LSA groups</samp> |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\INTERACTIVE</samp>
    | <samp class="SANS_Futura_Std_Book_11">自动 LSA 组</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\Authenticated
    Users</samp> |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\Authenticated
    Users</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">Everyone</samp> |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">Everyone</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">Mandatory Label\High Mandatory
    Level</samp> |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">Mandatory Label\High Mandatory
    Level</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\LogonSessionId_0_6077548</samp>
    | <samp class="SANS_Futura_Std_Book_11">Winlogon groups</samp> |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\LogonSessionId_0_6077548</samp>
    | <samp class="SANS_Futura_Std_Book_11">Winlogon 组</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">LOCAL</samp> |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">LOCAL</samp> |'
- en: As you can see, the groups added to the token come from six sources. The first
    entry comes from the domain user account. (In a local authentication scenario,
    the group would come from the local user account instead.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，添加到令牌中的组来自六个来源。第一个条目来自域用户帐户。（在本地身份验证场景中，组将来自本地用户帐户。）
- en: Next are the domain group memberships. These come from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Universal</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp> group scopes,
    discussed in the previous chapter. The *alice* user is a member of the first group,
    *Domain Users*. The other two groups are generated automatically when the user
    authenticates. The *Authentication authority asserted identity* group relates
    to a feature called *Service for User (S4U)*, which we’ll explore when we talk
    about Kerberos authentication in [Chapter 14](chapter14.xhtml).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是域组成员身份。这些成员来自前一章讨论的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Universal</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp> 组范围。*alice* 用户是第一个组
    *Domain Users* 的成员。其他两个组是在用户认证时自动生成的。*Authentication authority asserted identity*
    组与名为 *Service for User (S4U)* 的功能相关，我们将在讨论 Kerberos 身份验证时详细介绍该功能，详见[第14章](chapter14.xhtml)。
- en: The following source includes the groups with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DomainLocal</samp>
    scope. These domain-local groups are marked in the token with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Resource</samp>
    group attribute, although the attribute doesn’t affect their use in an access
    check. The list of domain-local resource groups a user belongs to is returned
    in the response from the <samp class="SANS_TheSansMonoCd_W5Regular_11">NetrLogonSamLogon</samp>
    API, known as a *privilege attribute certificate (PAC)*. We’ll also come back
    to the PAC in [Chapter 14](chapter14.xhtml).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下源包括具有 <samp class="SANS_TheSansMonoCd_W5Regular_11">DomainLocal</samp> 范围的组。这些域本地组在令牌中以
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Resource</samp> 组属性标记，尽管该属性不会影响其在访问检查中的使用。用户所属的域本地资源组列表会在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NetrLogonSamLogon</samp> API 的响应中返回，该列表称为
    *特权属性证书 (PAC)*。我们将在[第14章](chapter14.xhtml)中进一步讨论 PAC。
- en: Next, any local groups the user is a member of are added to the token. These
    local groups can be selected based on the domain SIDs provided during the authentication
    process.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，任何用户所在的本地组将被添加到令牌中。这些本地组可以根据认证过程中提供的域 SID 进行选择。
- en: These are followed by the automatic LSA groups. Membership in the *Everyone*
    and *Authenticated Users* groups is granted to all authenticated tokens automatically.
    *INTERACTIVE* group membership is granted when a user is authenticated using the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp> logon type. [Table
    12-4](chapter12.xhtml#tab12-4) provides a list of the SIDs added for different
    logon types. The LSA adds the *Mandatory Label\High Mandatory Level* SID automatically
    if the user is considered an administrator (for example, if they’re in the *Administrators*
    group or have certain high-level privileges). This sets the integrity level of
    the token to <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp>. Normal
    users get the *Medium Mandatory Level* SID, while system service users (such as
    *SYSTEM*) get the *System Mandatory Level* SID.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是自动添加的 LSA 组。*Everyone* 和 *Authenticated Users* 组的成员身份会自动赋予所有已认证的令牌。*INTERACTIVE*
    组的成员身份会在使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp> 登录类型进行身份验证时授予。
    [表 12-4](chapter12.xhtml#tab12-4) 提供了为不同登录类型添加的 SID 列表。如果用户被认为是管理员（例如，如果他们属于 *Administrators*
    组或拥有某些高级权限），LSA 会自动添加 *Mandatory Label\High Mandatory Level* SID。这会将令牌的完整性级别设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp>。普通用户会获得 *Medium Mandatory
    Level* SID，而系统服务用户（如 *SYSTEM*）则会获得 *System Mandatory Level* SID。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-4:</samp> <samp class="SANS_Futura_Std_Book_11">The
    SIDs Added to the Token for Each Logon Type</samp>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 12-4：</samp> <samp class="SANS_Futura_Std_Book_11">每种登录类型为令牌添加的
    SID</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Logon type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Name</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">SID</samp> |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">登录类型</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">名称</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">SID</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp> | <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\INTERACTIVE</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-4</samp> |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">交互式</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\INTERACTIVE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-4</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Batch</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\BATCH</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-3</samp>
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">批处理</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\BATCH</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-3</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\SERVICE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-6</samp>
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">服务</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\SERVICE</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-6</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\NETWORK</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-2</samp>
    |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">网络</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\NETWORK</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-2</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NetworkCleartext</samp> | <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\NETWORK</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-2</samp> |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">网络明文</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\NETWORK</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-2</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp> | <samp
    class="SANS_Futura_Std_Book_11">The same as that of the original token</samp>
    | <samp class="SANS_Futura_Std_Book_11">N/A</samp> |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">新凭证</samp> | <samp class="SANS_Futura_Std_Book_11">与原始令牌相同</samp>
    | <samp class="SANS_Futura_Std_Book_11">不适用</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp> |
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\INTERACTIVE</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\REMOTE INTERACTIVE LOGON</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-4</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-14</samp>
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">远程交互</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\INTERACTIVE</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\REMOTE INTERACTIVE LOGON</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-4</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-14</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unlock</samp> | <samp class="SANS_Futura_Std_Book_11">The
    same as the logon session that is being unlocked</samp> | <samp class="SANS_Futura_Std_Book_11">N/A</samp>
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">解锁</samp> | <samp class="SANS_Futura_Std_Book_11">与正在解锁的登录会话相同</samp>
    | <samp class="SANS_Futura_Std_Book_11">不适用</samp> |'
- en: Providing a unique SID for each logon type allows a security descriptor to secure
    resources depending on the type of logon. For example, a security descriptor could
    explicitly deny access to the *NT AUTHORITY\NETWORK* SID, meaning a user authenticated
    from the network would be denied access to the resource, while other authenticated
    users would be granted access.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为每种登录类型提供唯一的 SID 允许安全描述符根据登录类型保护资源。例如，安全描述符可以明确拒绝对 *NT AUTHORITY\NETWORK* SID
    的访问，这意味着从网络认证的用户将被拒绝访问该资源，而其他认证用户将被允许访问。
- en: The sixth set of SIDs added to the token are for the groups added by Winlogon
    when it calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API. The API allows a caller with <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    enabled to add arbitrary group SIDs to the created token, so Winlogon adds a logon
    session and a *LOCAL* SID. This logon session SID’s two RID values are the two
    32-bit integers from a LUID generated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateLocallyUniqueId</samp>
    system call. You might assume that the LUID would match the one used for the logon
    session. However, as the SID is created before the call to the LSA that creates
    the logon session, this isn’t possible. This SID is used to secure ephemeral resources
    such as the user’s *BaseNamedObjects* directory.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到令牌中的第六组 SID 是 Winlogon 在调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API 时为添加的组。该 API 允许启用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    的调用者将任意组 SID 添加到创建的令牌中，因此 Winlogon 添加了一个登录会话和一个 *本地* SID。该登录会话 SID 的两个 RID 值是由
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateLocallyUniqueId</samp>
    系统调用生成的 LUID 中的两个 32 位整数。你可能认为 LUID 会与用于登录会话的 LUID 匹配。然而，由于该 SID 在调用创建登录会话的 LSA
    之前创建，因此这是不可能的。这个 SID 用于保护短暂的资源，例如用户的 *BaseNamedObjects* 目录。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you don’t specify a logon session SID when creating the token, the LSA
    will add its own for you. However, it will follow the same pattern of using a
    different LUID from that of the token’s logon session.*'
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果在创建令牌时未指定登录会话 SID，LSA 会为你添加一个。但它会遵循相同的模式，使用与令牌登录会话不同的 LUID。*'
- en: As discussed in [Chapter 10](chapter10.xhtml), the token’s privileges are based
    on the account rights stored in the local LSA policy database. This is true even
    in domain authentication; however, the account rights can be modified using a
    domain group policy deployed to computers in the domain.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第10章](chapter10.xhtml)所讨论，令牌的权限基于存储在本地 LSA 策略数据库中的账户权限。这在域认证中也适用；然而，账户权限可以通过部署到域内计算机的域组策略进行修改。
- en: If the user is considered an administrator, UAC is enabled, and the user is
    authenticating with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp> logon
    type, the LSA will first build the full token and create a new logon session,
    then create a second copy of the full token with a new logon session but call
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp> to remove administrator
    privileges (see [Chapter 4](chapter4.xhtml) for a more in-depth description of
    this). The LSA will then link the two tokens together and return the filtered
    token back to the caller. This behavior is why we observed two logon sessions
    for the same user in [Listing 12-2](chapter12.xhtml#Lis12-2).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户被认为是管理员，UAC 启用，并且用户使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp> 登录类型进行身份验证，LSA
    将首先构建完整的令牌并创建一个新的登录会话，然后创建一个包含新登录会话的完整令牌副本，但会调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>
    来移除管理员权限（有关更详细的描述，请参见[第4章](chapter4.xhtml)）。然后，LSA 将把这两个令牌链接在一起，并将过滤后的令牌返回给调用者。这种行为就是为什么我们在[清单
    12-2](chapter12.xhtml#Lis12-2)中观察到同一个用户有两个登录会话的原因。
- en: 'You can disable the token-splitting behavior by adjusting the system’s UAC
    settings. It’s also disabled by default for the *Administrator* user, which is
    always created when Windows is installed but only enabled by default on Windows
    Server systems. The LSA checks the last RID of the user’s SID: if it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">500</samp>,
    which matches the *Administrator* user, the token won’t be split.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调整系统的 UAC 设置来禁用令牌拆分行为。对于*管理员*用户，默认情况下它是禁用的，该用户在安装 Windows 时总会创建，但仅在 Windows
    Server 系统上默认启用。LSA 会检查用户 SID 的最后 RID：如果是 <samp class="SANS_TheSansMonoCd_W5Regular_11">500</samp>，与*管理员*用户匹配，则令牌不会被拆分。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Using the LsaLogonUser API from PowerShell</samp>
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">从 PowerShell 使用 LsaLogonUser API</samp>
- en: Now that you know how the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API works, let’s see how to access the API from the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp>
    PowerShell module. Unless you run PowerShell with <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>,
    some features of the API will be blocked, such as adding new group SIDs to the
    token, but you’ll be able to create a new token if you have the user’s username
    and password.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API
    的工作原理，我们来看看如何通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtObjectManager</samp>
    PowerShell 模块访问该 API。除非你以 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    运行 PowerShell，否则 API 的某些功能将被阻止，例如向令牌添加新的组 SID，但如果你有用户的用户名和密码，你仍然可以创建一个新的令牌。
- en: We access the API via the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    command and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Logon</samp> parameter.
    [Listing 12-4](chapter12.xhtml#Lis12-4) shows how to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    to authenticate a new user.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> 命令和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Logon</samp> 参数访问该 API。[清单 12-4](chapter12.xhtml#Lis12-4)
    展示了如何使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> 来验证新用户。
- en: '[PRE3]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 12-4: Authenticating a user'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-4：验证用户身份
- en: It’s best not to enter passwords on the command line. Instead, we use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Read-Host</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">AsSecureString</samp>
    property to read the password as a secure string.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最好不要在命令行中输入密码。相反，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Read-Host</samp>
    配合 <samp class="SANS_TheSansMonoCd_W5Regular_11">AsSecureString</samp> 属性将密码作为安全字符串读取。
- en: We can then call <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>,
    specifying the username, the domain, and the password. (Replace the username in
    this example, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">user</samp>,
    with that of a valid local user.) We set the domain to the name of the local computer,
    indicating that we want to authenticate using a local account. You can set any
    logon type, but in this case we specify <samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp>,
    which works for all users. Whether the LSA will allow other logon types depends
    on the assigned account rights.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>，并指定用户名、域名和密码。（将此示例中的用户名
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">user</samp> 替换为有效的本地用户。）我们将域名设置为本地计算机的名称，表示我们希望使用本地账户进行身份验证。你可以设置任何登录类型，但在此例中我们指定
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp>，它适用于所有用户。LSA 是否允许其他登录类型取决于分配的账户权限。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*By default, the LsaLogonUser API won’t authenticate a user with an empty password
    outside of the physical console. If you try running the command with a user account
    that has an empty password, the call will fail.*'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*默认情况下，LsaLogonUser API 在物理控制台之外不会验证具有空密码的用户。如果你尝试使用一个空密码的用户帐户运行该命令，调用将失败。*'
- en: The logon type also determines what type of token <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    will return based on the created token’s likely purpose, such as creating a new
    process or impersonation. [Table 12-5](chapter12.xhtml#tab12-5) shows the mappings
    of logon type to token type. (We can freely convert between primary and impersonation
    tokens through duplication, so the tokens don’t have to be used in the expected
    way.)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 登录类型还决定了 <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> 根据所创建令牌的预期用途（如创建新进程或模拟）返回何种类型的令牌。[表
    12-5](chapter12.xhtml#tab12-5) 显示了登录类型与令牌类型的映射。（我们可以通过复制自由地在主令牌和模拟令牌之间转换，因此这些令牌不必按预期的方式使用。）
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-5:</samp> <samp class="SANS_Futura_Std_Book_11">Logon
    Types Mapped to Token Types</samp>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 12-5：</samp> <samp class="SANS_Futura_Std_Book_11">登录类型与令牌类型的映射</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Logon type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Token
    type</samp> |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">登录类型</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">令牌类型</samp>
    |'
- en: '| --- | --- |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp> | <samp
    class="SANS_Futura_Std_Book_11">Primary</samp> |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">交互式</samp> | <samp class="SANS_Futura_Std_Book_11">主账户</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Batch</samp> | <samp class="SANS_Futura_Std_Book_11">Primary</samp>
    |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">批处理</samp> | <samp class="SANS_Futura_Std_Book_11">主账户</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp> | <samp class="SANS_Futura_Std_Book_11">Primary</samp>
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">服务</samp> | <samp class="SANS_Futura_Std_Book_11">主账户</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp> | <samp class="SANS_Futura_Std_Book_11">Impersonation</samp>
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">网络</samp> | <samp class="SANS_Futura_Std_Book_11">模拟</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NetworkCleartext</samp> | <samp
    class="SANS_Futura_Std_Book_11">Impersonation</samp> |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">网络明文</samp> | <samp class="SANS_Futura_Std_Book_11">模拟</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp> | <samp
    class="SANS_Futura_Std_Book_11">Primary</samp> |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">新凭据</samp> | <samp class="SANS_Futura_Std_Book_11">主账户</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoteInteractive</samp> |
    <samp class="SANS_Futura_Std_Book_11">Primary</samp> |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">远程交互式</samp> | <samp class="SANS_Futura_Std_Book_11">主账户</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unlock</samp> | <samp class="SANS_Futura_Std_Book_11">Primary</samp>
    |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">解锁</samp> | <samp class="SANS_Futura_Std_Book_11">主账户</samp>
    |'
- en: 'In [Listing 12-4](chapter12.xhtml#Lis12-4), the command returned an impersonation
    token. You might be wondering: Are we allowed to impersonate the token without
    having <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>
    enabled, especially if the token belongs to a different user? The LSA sets the
    new token’s origin ID to the caller’s authentication ID, so based on the rules
    for impersonation covered in [Chapter 4](chapter4.xhtml), we can, even if the
    token belongs to a different user.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Listing 12-4](chapter12.xhtml#Lis12-4)中，命令返回了一个模拟令牌。你可能会问：我们是否允许在没有启用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>的情况下模拟令牌，特别是当令牌属于其他用户时？LSA会将新令牌的源
    ID 设置为调用者的身份验证 ID，因此根据[第4章](chapter4.xhtml)中讨论的模拟规则，即使令牌属于不同的用户，我们也可以进行模拟。
- en: This isn’t considered a security issue, because if you know the user’s password,
    you can already fully authenticate as that user. In [Listing 12-5](chapter12.xhtml#Lis12-5),
    we check whether the origin and authentication IDs match using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenId</samp>
    command.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这不被认为是安全问题，因为如果你知道用户的密码，你已经能够完全以该用户身份进行身份验证。在[Listing 12-5](chapter12.xhtml#Lis12-5)中，我们检查使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenId</samp>命令时，源 ID 和身份验证 ID
    是否匹配。
- en: '[PRE4]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 12-5: Comparing the authentication ID and origin ID'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 12-5：比较身份验证 ID 和源 ID
- en: We query the primary token for its authentication ID, then query the new token
    for its origin ID. The output shows that the IDs are equal.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查询主令牌的身份验证 ID，然后查询新令牌的源 ID。输出显示这两个 ID 是相同的。
- en: However, there is one restriction on impersonating the token. If the user being
    authenticated is an administrator, and the authentication process uses a logon
    type other than <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp>,
    the command won’t return a filtered token. Instead, it will return an administrator
    with a <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp> integrity level.
    This integrity level prevents the token from being impersonated from a <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>-level
    process. But because the returned token handle has write access, we can reduce
    the integrity level to <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>
    before impersonating it. We do this in [Listing 12-6](chapter12.xhtml#Lis12-6).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，模拟令牌时存在一个限制。如果被身份验证的用户是管理员，并且身份验证过程使用的是非<samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp>的登录类型，则命令不会返回过滤后的令牌。相反，它将返回一个具有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">High</samp>完整性级别的管理员。这个完整性级别会阻止从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>级别进程模拟该令牌。但由于返回的令牌句柄具有写访问权限，我们可以在模拟之前将其完整性级别降低为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>。我们在[Listing 12-6](chapter12.xhtml#Lis12-6)中执行了这一操作。
- en: '[PRE5]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 12-6: Testing the ability to impersonate the returned token'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 12-6：测试是否能够模拟返回的令牌
- en: In this case, the token we’ve authenticated is a member of the *Administrators*
    group and so has a <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp> integrity
    level. We try to impersonate it, and as you can see, the command returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. We then set the token’s
    integrity level to <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>
    and test impersonation again. The operation now returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们验证的令牌是*管理员*组的成员，因此具有<samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp>完整性级别。我们尝试模拟它，正如你所看到的，命令返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。然后，我们将令牌的完整性级别设置为<samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>并再次测试模拟。此时操作返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating a New Process with a Token</samp>
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用令牌创建新进程</samp>
- en: If you use a logon type that returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">Primary</samp>
    token, you might assume that the token will enable you to create a new process.
    To test this, run [Listing 12-7](chapter12.xhtml#Lis12-7) as a non-administrator
    user, making sure to change the username to that of a valid account.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用返回<samp class="SANS_TheSansMonoCd_W5Regular_11">Primary</samp>令牌的登录类型，你可能会认为该令牌可以让你创建新进程。为了测试这一点，作为非管理员用户运行[Listing
    12-7](chapter12.xhtml#Lis12-7)，并确保将用户名更改为有效账户的用户名。
- en: '[PRE6]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 12-7: Creating a new process with an authenticated token'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 12-7：使用身份验证令牌创建新进程
- en: You’ll find that creating the new process fails. This is because the new token
    doesn’t meet the requirements for primary token assignment described in [Chapter
    4](chapter4.xhtml). The process creation would work if the calling process had
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>,
    which Winlogon would have; however, a normal user process doesn’t have this privilege.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现创建新进程失败。这是因为新令牌未满足 [第4章](chapter4.xhtml) 中描述的主令牌分配要求。如果调用进程具有 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>，进程创建将成功，Winlogon
    会具备该权限；然而，普通用户进程没有这个权限。
- en: If you rerun the command as an administrator, though, it should succeed, even
    though administrators are not granted the privilege by default. Let’s explore
    why this works. The <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    command first tries to create the process using the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessAsUser</samp>
    API, which runs in-process. As the calling process doesn’t have <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>,
    this operation fails.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你以管理员身份重新运行该命令，它应该会成功，即使管理员默认并未被授予该权限。让我们来探讨一下为什么它能够成功。<samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    命令首先尝试使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessAsUser</samp>
    API 创建进程，该 API 在进程内运行。由于调用进程没有 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>，因此该操作失败。
- en: Upon this failure, the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    API will fall back to calling an alternative API, <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithToken</samp>.
    This API isn’t implemented in-process; instead, it’s implemented in a system service,
    the secondary logon service, which does have <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>.
    In this case, the service will check whether the caller has <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>
    before creating the new process.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在此失败情况下，<samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    API 将回退到调用另一个替代 API，<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithToken</samp>。该
    API 并未在进程内实现；相反，它是在一个系统服务中实现的，即辅助登录服务，该服务具有 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>。在这种情况下，服务将在创建新进程之前检查调用者是否具有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>。
- en: The command therefore works for administrators who are granted <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>.
    Even so, administrators shouldn’t rely on <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithToken</samp>
    exclusively, because the API doesn’t support many features of <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessAsUser</samp>,
    such as inheriting arbitrary handles to the new process.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该命令适用于被授予 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>
    的管理员。即便如此，管理员不应完全依赖 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithToken</samp>，因为该
    API 不支持 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessAsUser</samp>
    的许多功能，例如继承任意句柄到新进程。
- en: There is also a way for a non-administrator user to create a process as a different
    user. The secondary logon service exposes a second API, <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithLogon</samp>,
    that accepts the username, domain, and password for the user to create instead
    of a token handle. The service authenticates the user using <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>,
    then uses the authenticated token with <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessAsUser</samp>.
    As the service has <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>,
    the process creation will succeed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 非管理员用户也可以以其他用户身份创建进程。辅助登录服务公开了第二个 API，<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithLogon</samp>，它接受用户名、域名和密码来创建用户，而不是令牌句柄。服务使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> 进行用户身份验证，然后使用经过身份验证的令牌与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessAsUser</samp>。由于服务具有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>，因此进程创建将成功。
- en: You can specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Credential</samp>
    parameter when calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    command to use <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithLogon</samp>,
    as shown in [Listing 12-8](chapter12.xhtml#Lis12-8).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp> 命令时，可以指定
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Credential</samp> 参数来使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithLogon</samp>，如
    [Listing 12-8](chapter12.xhtml#Lis12-8) 所示。
- en: '[PRE7]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 12-8: Calling CreateProcessWithLogon using New-Win32Process'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 12-8: 使用 New-Win32Process 调用 CreateProcessWithLogon'
- en: Here we read the credentials for the *alice* user and create the new process
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>, specifying
    the credentials with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Credential</samp>
    parameter. This will call the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithLogon</samp>
    API.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们读取 *alice* 用户的凭证，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    创建新进程，通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">Credential</samp> 参数指定凭证。这将调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithLogon</samp> API。
- en: The API will return a process and thread handle to use. For example, we can
    query for the process user, which shows it was created with a token for the authenticated
    *alice* user.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 该 API 将返回一个进程和线程句柄供使用。例如，我们可以查询进程的用户，显示它是通过认证的 *alice* 用户的令牌创建的。
- en: The API doesn’t allow you to specify the logon type of the user (it defaults
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp>), but you
    can specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">NetCredentialsOnly</samp>
    flag to the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonFlags</samp> parameter
    to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp>
    logon type instead.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 该 API 不允许你指定用户的登录类型（默认值是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp>），但你可以向
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonFlags</samp> 参数指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">NetCredentialsOnly</samp>
    标志，以改为使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp> 登录类型。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Service Logon Type</samp>
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">服务登录类型</samp>
- en: Let’s wrap up this chapter by talking a little more about the <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp>
    logon type. The service control manager uses this logon type to create tokens
    for system service processes. It will allow any user account that has been granted
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeServiceLogonRight</samp> account
    right to authenticate.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过再谈一下 <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp> 登录类型来总结这一章。服务控制管理器使用此登录类型为系统服务进程创建令牌。它将允许任何已被授予
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeServiceLogonRight</samp> 账户权限的用户进行身份验证。
- en: However, the LSA also supports four well-known local service accounts that are
    not stored in the SAM database. We can create them using <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    by specifying the domain name as <samp class="SANS_TheSansMonoCd_W5Regular_11">NT
    AUTHORITY</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp>
    logon type and one of the usernames in [Table 12-6](chapter12.xhtml#tab12-6),
    which also shows the user SIDs.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，LSA 还支持四个著名的本地服务帐户，这些帐户并未存储在 SAM 数据库中。我们可以通过指定域名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">NT
    AUTHORITY</samp> 和服务登录类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp>，以及
    [表 12-6](chapter12.xhtml#tab12-6) 中的用户名之一，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    创建它们，该表也显示了用户 SID。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-6:</samp> <samp class="SANS_Futura_Std_Book_11">Usernames
    and SIDs for the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp>
    <samp class="SANS_Futura_Std_Book_11">Logon Type</samp>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 12-6：</samp> <samp class="SANS_Futura_Std_Book_11">服务登录类型的用户名和
    SID</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Username</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">User
    SID</samp> |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">用户名</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">用户
    SID</samp> |'
- en: '| --- | --- |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">IUSR</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-17</samp>
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">IUSR</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-17</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SYSTEM</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-18</samp>
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">SYSTEM</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-18</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">LOCAL SERVICE</samp> <samp
    class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">LocalService</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-19</samp> |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">本地服务</samp> <samp class="SANS_Futura_Std_Book_11">或</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">LocalService</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-19</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">NETWORK SERVICE</samp> <samp
    class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">NetworkService</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-20</samp> |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">网络服务</samp> <samp class="SANS_Futura_Std_Book_11">或</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">NetworkService</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-20</samp> |'
- en: The *SYSTEM* user is the only administrator of the four users; the other three
    are not members of the *Administrators* group, but they do have high-level privileges
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>,
    which makes them effectively equivalent to an administrator.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*SYSTEM* 用户是四个用户中唯一的管理员；其他三个用户不是 *Administrators* 组的成员，但它们确实拥有高权限，例如 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>，这使得它们实际上等同于管理员。'
- en: The *IUSR* account represents the anonymous internet user. It’s available to
    reduce the privileges for the Internet Information Services (IIS) web server when
    it’s configured for anonymous authentication. When a request is made to the IIS
    web server with no user credentials, it will impersonate an *IUSR* account token
    before opening any resources, such as files. This prevents inadvertently exposing
    resources remotely as a privileged user.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*IUSR* 帐户代表匿名互联网用户。它可用于减少配置为匿名身份验证的 Internet 信息服务（IIS）Web 服务器的权限。当没有用户凭据的请求发送到
    IIS Web 服务器时，它将在打开任何资源（如文件）之前模拟 *IUSR* 帐户令牌。这可以防止意外地以特权用户身份远程暴露资源。'
- en: For these built-in service accounts, you don’t need to specify a password, but
    you do need to call <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp> enabled,
    which prevents it from being used outside of a system service. [Listing 12-9](chapter12.xhtml#Lis12-9)
    shows how to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    to create a *SYSTEM* user token. Run these commands as an administrator.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些内置服务帐户，你无需指定密码，但需要调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    并启用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp> 权限，这样可以防止它在系统服务之外被使用。[列表
    12-9](chapter12.xhtml#Lis12-9) 演示了如何使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    来创建 *SYSTEM* 用户令牌。以管理员身份运行这些命令。
- en: '[PRE8]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 12-9: Getting the <samp class="SANS_Futura_Std_Book_11">SYSTEM</samp>
    user token'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-9：获取 <samp class="SANS_Futura_Std_Book_11">SYSTEM</samp> 用户令牌
- en: Even as an administrator you don’t receive <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    by default, so the command supports a <samp class="SANS_TheSansMonoCd_W5Regular_11">WithTcb</samp>
    parameter, which automatically impersonates a token with the privilege enabled.
    You can also simplify the creation of a service account by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp>
    parameter and specifying the name of the service user to create.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是管理员，默认情况下也不会获得 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    权限，因此该命令支持一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">WithTcb</samp> 参数，该参数会自动模拟一个启用了该权限的令牌。你还可以通过使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp> 参数并指定要创建的服务用户名称，来简化服务帐户的创建。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp>
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">示例</samp>
- en: Let’s walk through some examples that demonstrate how to use the various commands
    introduced in this chapter in security research or systems analysis.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些示例来演示如何在安全研究或系统分析中使用本章介绍的各种命令。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing Privileges
    and Logon Account Rights</samp>
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">测试权限和登录帐户权限</samp>
- en: I mentioned in [Chapter 10](chapter10.xhtml) that you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtAccountRight</samp>
    command to add a SID to the list of account rights. Now that we know how to authenticate
    a user, let’s use this command to explore these account rights. In [Listing 12-10](chapter12.xhtml#Lis12-10),
    we assign privileges and logon account rights to a new user. Run these commands
    as an administrator.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第10章](chapter10.xhtml)中提到过，你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtAccountRight</samp>
    命令将 SID 添加到账户权限列表中。现在我们已经知道如何认证用户，接下来让我们使用这个命令来探索这些账户权限。在[清单 12-10](chapter12.xhtml#Lis12-10)中，我们为一个新用户分配了特权和登录账户权限。请以管理员身份运行这些命令。
- en: '[PRE9]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 12-10: Assigning account rights to a new user'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-10：为新用户分配账户权限
- en: We start by creating a new user ❶ and testing that we can authenticate interactively
    ❷. We can do so because the user is automatically part of the *BUILTIN\Users*
    group, which has <samp class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp>
    by default. We also check that the token hasn’t been filtered for UAC by looking
    at the <samp class="SANS_TheSansMonoCd_W5Regular_11">ElevationType</samp> parameter,
    which shows up as <samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp>,
    indicating that no filtering took place.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新用户 ❶ 并测试是否可以进行交互式身份验证 ❷。我们之所以能够这么做，是因为该用户自动属于 *BUILTIN\Users* 组，该组默认具有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp> 权限。我们还检查了令牌是否没有被
    UAC 过滤，通过查看 <samp class="SANS_TheSansMonoCd_W5Regular_11">ElevationType</samp>
    参数，该参数显示为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp>，表明没有发生过滤。
- en: 'Next, we assign the user the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp>
    privilege ❸. This is a high-level privilege, so we should expect the LSA to perform
    UAC filtering. We find this to be the case when we authenticate the user: we can’t
    enable <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp>,
    since it’s been filtered ❹, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ElevationType</samp>
    is now set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Limited</samp>.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为用户分配了 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp>
    权限 ❸。这是一个高级权限，因此我们应该预期 LSA 会执行 UAC 过滤。当我们认证用户时，我们发现确实如此：我们无法启用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp>，因为它已经被过滤
    ❹，并且 <samp class="SANS_TheSansMonoCd_W5Regular_11">ElevationType</samp> 已设置为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Limited</samp>。
- en: However, we can instead use network authentication ❺, which isn’t subject to
    the default UAC filtering rules. We can now enable <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp>
    ❻, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ElevationType</samp>
    becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp> once again,
    indicating that no filtering took place.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以改用网络身份验证 ❺，它不受默认 UAC 过滤规则的限制。我们现在可以启用 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp>
    ❻，并且 <samp class="SANS_TheSansMonoCd_W5Regular_11">ElevationType</samp> 再次变为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Default</samp>，表明没有发生过滤。
- en: We then test the logon account rights. Remember that the user is granted <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp> because
    they are a member of the *BUILTIN\Users* group. We can’t remove that logon right
    without also removing them from that group, so instead we explicitly deny it to
    the specific user by adding their SID to the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyInteractiveLogonRight</samp>
    ❼. Then we verify the intended behavior by trying to log on interactively ❽, which
    now returns an error.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们测试登录账户权限。记住，用户被授予了 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp>
    权限，因为他们是 *BUILTIN\Users* 组的成员。我们不能在不将他们从该组中移除的情况下删除该登录权限，因此我们通过将他们的 SID 显式添加到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyInteractiveLogonRight</samp>
    ❼ 来拒绝该权限。然后我们通过尝试交互式登录 ❽ 来验证预期的行为，此时会返回一个错误。
- en: We also added the user’s SID to the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBatchLogonRight</samp>,
    which allows them to authenticate as a batch logon session. Normally, only members
    of the *Administrators* group receive this access right. We verify we’ve authenticated
    as a batch logon session by checking for the *NT AUTHORITY\BATCH* group that the
    LSA assigns ❾.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将用户的 SID 添加到了 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBatchLogonRight</samp>
    中，这允许他们作为批处理登录会话进行身份验证。通常，只有 *Administrators* 组的成员才会获得此访问权限。我们通过检查 LSA 分配的 *NT
    AUTHORITY\BATCH* 组 ❾ 来验证我们已作为批处理登录会话进行了身份验证。
- en: Finally, we clean up the account right assignments using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtAccountRight</samp>
    command ❿. This isn’t strictly necessary, as the LSA will clean up the assignments
    when the local user is removed, but I’ve included the operations here to demonstrate
    the use of the command.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`<samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtAccountRight</samp>`命令❿清理账户权限分配。这不是严格必要的，因为当本地用户被删除时，LSA会自动清理这些分配，但我在这里包含了这些操作以演示该命令的使用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a Process
    in a Different Console Session</samp>
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">在不同控制台会话中创建进程</samp>
- en: In certain scenarios, you might want to start a process inside a different console
    session. For example, if you’re running code in a system service using session
    0, you might want to show a message on the currently authenticated user’s desktop.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能希望在不同的控制台会话中启动进程。例如，如果你在使用会话 0 运行系统服务中的代码，你可能希望在当前认证的用户桌面上显示一条消息。
- en: To successfully create a process on another desktop, you need <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    to change a token’s session ID and <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>
    to create the process. By default, an administrator user has neither of these
    privileges, so to test the example code provided here you’ll need to run PowerShell
    as the *SYSTEM* user.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要在另一个桌面上成功创建进程，你需要`<samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>`来更改令牌的会话
    ID，并且需要`<samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>`来创建进程。默认情况下，管理员用户没有这两个权限，因此要测试这里提供的示例代码，你需要以*SYSTEM*用户身份运行PowerShell。
- en: 'First run the following command as an administrator to create a shell process
    on your desktop with the required privileges:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，以管理员身份运行以下命令，在桌面上创建一个具有所需权限的 shell 进程：
- en: '[PRE10]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, make sure that you have two users authenticated at the same time on different
    desktops on the same machine. If you use Fast User Switching, you’ll be able to
    easily confirm that a process was created on each desktop.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，确保在同一台机器上有两个用户同时在不同的桌面上进行身份验证。如果你使用快速用户切换功能，你将能够轻松确认在每个桌面上都创建了进程。
- en: '[Listing 12-11](chapter12.xhtml#Lis12-11) starts by finding the console session
    for the new process. Run these commands as the *SYSTEM* user.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-11](chapter12.xhtml#Lis12-11)开始时通过查找新进程的控制台会话。以*SYSTEM*用户身份运行这些命令。'
- en: '[PRE11]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 12-11: Creating a new process in a different console session'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-11：在不同控制台会话中创建新进程
- en: We start by selecting the console session belonging to a user named *GRAPHITE\user*
    ❶. We then create a duplicate of our current token (which belongs to the *SYSTEM*
    user), enable <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>,
    and assign the console session ID to the token ❷.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先选择属于名为*GRAPHITE\user*的用户的控制台会话❶。然后我们创建一个当前令牌的副本（该令牌属于*SYSTEM*用户），启用`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>`，并将控制台会话 ID 分配给该令牌❷。
- en: With this new token, we can create a new process using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    command, specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    parameter ❸. In this case we’re creating a copy of Notepad, but you can change
    this process to any application you’d like by altering the command. Also note
    that we set the name of the window station and desktop, separated by a backslash,
    for the new process. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">WinSta0</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp>, respectively,
    ensures that we create the application on the default desktop; otherwise, the
    user interface would be hidden.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新令牌，我们可以通过`<samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>`命令创建一个新进程，并指定`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>`参数❸。在这种情况下，我们正在创建一个记事本的副本，但你可以通过修改命令将此进程更改为任何你想要的应用程序。还需要注意的是，我们为新进程设置了窗口站和桌面的名称，并用反斜杠分隔。分别使用`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WinSta0</samp>`和`<samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp>`，确保我们在默认桌面上创建应用程序；否则，用户界面将会被隐藏。
- en: We can verify that we’ve created the process in the target session by comparing
    the expected session ID with the actual session ID assigned to the process ❹.
    In this case, the comparison returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    which indicates success. If you now switch back to the other user, you should
    find a copy of Notepad running as the *SYSTEM* user on the desktop.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将预期的会话 ID 与分配给该进程的实际会话 ID 进行比较，来验证我们是否已经在目标会话中创建了进程 ❹。在这种情况下，比较返回 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，表示成功。如果此时你切换回另一个用户，你应该会在桌面上看到以
    *SYSTEM* 用户身份运行的记事本副本。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authenticating Virtual
    Accounts</samp>
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">认证虚拟账户</samp>
- en: In [Chapter 10](chapter10.xhtml), I mentioned that you can create your own SID-to-name
    mappings in the LSA using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSidName</samp>
    command. Once you’ve set up a mapping, you can also create a new token for that
    SID through <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>.
    [Listing 12-12](chapter12.xhtml#Lis12-12) demonstrates; run these commands as
    an administrator.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第10章](chapter10.xhtml) 中，我提到过可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSidName</samp>
    命令在 LSA 中创建自己的 SID 到名称的映射。一旦设置了映射，你还可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    为该 SID 创建新的令牌。[清单 12-12](chapter12.xhtml#Lis12-12) 演示了这一过程；请以管理员身份运行这些命令。
- en: '[PRE12]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 12-12: Creating a virtual account token'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-12：创建虚拟账户令牌
- en: 'We start by setting up some parameters to use in later commands ❶. We create
    three SIDs: the domain, a group, and a user. These values don’t need to reflect
    real SIDs or names. We then need to add the SIDs and create a token, all of which
    requires <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>,
    so we impersonate a *SYSTEM* token ❷.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置一些参数，以便在后续命令中使用 ❶。我们创建了三个 SID：域、组和用户。这些值不需要反映实际的 SID 或名称。接下来我们需要添加这些 SID
    并创建令牌，这一过程都需要 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>，所以我们模拟了一个
    *SYSTEM* 令牌 ❷。
- en: We register the three SIDs using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSidName</samp>
    command ❸. Note that you must specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Register</samp>
    parameter; otherwise, you’ll merely add the SID to the PowerShell module’s name
    cache and won’t register it with LSASS. Once we’ve added the SIDs, we need to
    grant the user <samp class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp>
    so that we can authenticate them and receive a token ❹. You could choose a different
    logon right, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SeServiceLogonRight</samp>,
    if you wanted.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSidName</samp> 命令注册这三个
    SID ❸。请注意，必须指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">Register</samp> 参数；否则，你将仅仅把
    SID 添加到 PowerShell 模块的名称缓存中，而不会在 LSASS 中注册它。一旦我们添加了 SID，就需要授予用户 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp>，这样我们就可以认证用户并接收令牌
    ❹。如果需要，也可以选择其他的登录权限，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeServiceLogonRight</samp>。
- en: We can now authenticate the user via <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    by using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> ❺. Make
    sure to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Virtual</samp>
    logon provider and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp>
    logon type. You don’t need to specify a password, but you can’t perform the operation
    without <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> 使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> ❺ 进行用户认证。确保指定
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Virtual</samp> 登录提供程序和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Interactive</samp>
    登录类型。你不需要指定密码，但在没有 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    的情况下，无法执行该操作。
- en: Before we finish impersonating, we remove the logon right and then delete the
    domain SID ❻. Deleting the domain SID will also delete the group and user SIDs
    automatically.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成模拟之前，我们移除了登录权限，然后删除了域 SID ❻。删除域 SID 会自动删除组和用户的 SID。
- en: Finally, we format the token. Now we can see that the user SID is the virtual
    SID we created ❼, and that the token is automatically granted the group SID as
    well ❽. Note that if we hadn’t added the SID-to-name mapping for the group SID,
    we’d still be granted it, but the SID would not be resolvable to a name. We can
    now impersonate the token or use it to create a new process running under that
    user identity.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们对令牌进行了格式化。现在我们可以看到用户 SID 是我们创建的虚拟 SID ❼，并且令牌也自动被授予了组 SID ❽。请注意，如果我们没有为组
    SID 添加 SID 到名称的映射，我们仍然会获得该 SID，但该 SID 无法解析为名称。现在我们可以模拟该令牌，或者使用它创建一个以该用户身份运行的新进程。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: As you’ve seen, interactive authentication, the process used to access the Windows
    desktop, is an extremely complicated topic. The authentication process requires
    a combination of a user interface, which collects the credentials, and the Winlogon
    process, which calls the LSA’s <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API. Once the API has validated the user’s credentials, it creates a new logon
    session, along with a token that Winlogon can use to create the user’s initial
    processes. The logon session can also cache the credentials so the user won’t
    need to re-enter them to access network services.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，交互式认证，即用于访问 Windows 桌面的过程，是一个极其复杂的话题。认证过程需要结合用户界面来收集凭证，并通过 Winlogon 进程调用
    LSA 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API。API
    验证用户凭证后，会创建一个新的登录会话，并生成一个令牌，Winlogon 可以使用该令牌来创建用户的初始进程。登录会话还可以缓存凭证，这样用户就不需要重新输入凭证来访问网络服务。
- en: Next, we defined the differences between local authentication and domain authentication.
    We only touched on how authentication works with Netlogon here, but we’ll cover
    the more common Kerberos in [Chapter 14](chapter14.xhtml). With an understanding
    of the basic authentication mechanisms in hand, we discussed how the LSA uses
    the user information to build a token, including how it assigns groups and privileges
    and how UAC results in token filtering for administrators.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了本地认证和域认证之间的区别。在这里我们只简要介绍了认证如何通过 Netlogon 工作，但我们将在[第14章](chapter14.xhtml)中详细讲解更常见的
    Kerberos。掌握了基本的认证机制后，我们讨论了 LSA 如何使用用户信息构建令牌，包括如何分配组和权限，以及 UAC 如何导致管理员令牌过滤。
- en: We then discussed how to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>
    API using the PowerShell module’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    command. We saw that we can use the token returned from the API to impersonate
    a user, because the LSA sets the token’s origin ID to the caller’s authentication
    ID. We also saw how to create a new process as a different user via the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithLogon</samp> API, exposed
    through the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    command.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们讨论了如何使用 PowerShell 模块的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    命令调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API。我们看到，借助从
    API 返回的令牌，我们可以模拟一个用户，因为 LSA 会将令牌的来源 ID 设置为调用者的认证 ID。我们还看到如何通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    命令调用的 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithLogon</samp>
    API 创建一个以不同用户身份运行的新进程。
- en: Finally, we looked briefly at the <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp>
    logon type and the four accounts that the LSA predefines. The service control
    manager uses these for its system service processes. In the next chapter, we’ll
    begin exploring how network authentication allows a user to authenticate to another
    Windows system. This will also allow us to understand the protocols used by domain
    authentication.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要了解了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Service</samp> 登陆类型和
    LSA 预定义的四个账户。服务控制管理器使用这些账户来管理其系统服务进程。在下一章，我们将开始探索网络认证如何使用户能够对另一个 Windows 系统进行身份验证。这也将帮助我们理解域认证使用的协议。
