- en: '## **13'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **13'
- en: MODERN COMPUTING**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: This chapter provides an overview of a few select areas of modern computing.
    Given the diversity and breadth in computing, I had a wide range of topics to
    choose from. The areas I chose are by no means an exhaustive list of the interesting
    things happening in computing today. Instead, they represent a handful of topics
    that I believe are worth your consideration. In this chapter we cover apps, virtualization,
    cloud computing, Bitcoin, and more. We wrap up with a final project that brings
    together many of the topics covered in this book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了现代计算中的几个选定领域。考虑到计算的多样性和广度，我有许多主题可以选择。我选择的这些领域绝不是当前计算中所有有趣事物的详尽列表。相反，它们代表了我认为值得你关注的一些话题。在本章中，我们将讨论应用程序、虚拟化、云计算、比特币等内容。最后，我们通过一个最终项目，将本书中涉及的多个主题汇集在一起。
- en: '**Apps**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**应用程序**'
- en: Since the early days of computing, people have referred to software programs
    that are used directly by users as *applications*. This term was shortened to
    *app* as a convenience, and in the past, the two terms were interchangeable. However,
    since Apple opened the iPhone *App Store* in 2008, the word *app* has taken on
    a distinct meaning. Although there is no standard technical definition for what
    makes a software program an app, apps tend to share a number of common characteristics.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 自计算机早期以来，人们一直将直接供用户使用的软件程序称为*应用程序*。这个术语被缩写为*app*，以前这两个术语可以互换使用。然而，自从 Apple 在
    2008 年推出 iPhone *App Store* 以来，*app* 一词便赋予了新的含义。尽管没有标准的技术定义来区分什么软件程序算作一个 app，但应用程序通常具有一些共同特征。
- en: Apps are designed for end users. Apps often target a mobile device, such as
    a smartphone or tablet. Apps are typically distributed through an internet-based
    digital storefront (an *app store*), such as Apple’s App Store, the Google Play
    Store, or the Microsoft Store. Apps have limited access to the system on which
    they run, and often must declare what specific capabilities they require to operate.
    Apps tend to use touchscreens as their primary means of user input. The term *app*,
    when used alone, usually implies software installed on a device that makes direct
    use of the operating system’s API. In other words, the term *app* usually means
    a *native app*, an app built for a particular operating system. In contrast, *web
    apps* are apps designed with web technology (HTML, CSS, and JavaScript), and are
    not tied to a particular OS. [Figure 13-1](ch13.xhtml#ch13fig1) provides a high-level
    look at native apps and web apps.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序是为最终用户设计的。应用程序通常面向移动设备，如智能手机或平板电脑。应用程序通常通过基于互联网的数字商店（即*应用商店*）分发，如 Apple
    的 App Store、Google Play Store 或 Microsoft Store。应用程序对其运行的系统的访问权限有限，通常必须声明它们运行所需的具体功能。应用程序通常使用触摸屏作为主要的用户输入方式。单独使用时，*app*
    一词通常指安装在设备上的软件，并直接利用操作系统的 API。换句话说，*app* 一词通常指的是*原生应用程序*，即为特定操作系统构建的应用程序。相对而言，*Web
    应用程序*是使用 Web 技术（HTML、CSS 和 JavaScript）设计的应用程序，并且不依赖于特定的操作系统。[图 13-1](ch13.xhtml#ch13fig1)
    提供了原生应用程序和 Web 应用程序的概述。
- en: '![image](../images/fig13-1.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig13-1.jpg)'
- en: '*Figure 13-1: Native apps are built for a particular OS. Web apps are built
    using web technology.*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：原生应用程序是为特定操作系统构建的。Web 应用程序则是使用 Web 技术构建的。*'
- en: As shown in [Figure 13-1](ch13.xhtml#ch13fig1), native apps are typically installed
    from an app store and are designed to utilize the capabilities of a specific operating
    system. Web apps typically run from a website and are designed to use web technologies.
    Web apps run in a browser or another process that renders web content. Let’s now
    look at both native apps and web apps in more detail.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 13-1](ch13.xhtml#ch13fig1)所示，原生应用程序通常是通过应用商店安装的，旨在利用特定操作系统的功能。Web 应用程序通常通过网站运行，旨在使用
    Web 技术。Web 应用程序在浏览器或其他呈现 Web 内容的进程中运行。接下来，我们将更详细地了解原生应用程序和 Web 应用程序。
- en: '***Native Apps***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原生应用程序***'
- en: 'As mentioned earlier, native apps are built for a particular operating system.
    Apple’s App Store and the similar app stores that followed it ushered in a new
    era of native software development, giving developers new platforms to target,
    new methods of distributing their software, and new ways to make money with software.
    The current state of native app development is largely focused on two platforms:
    iOS and Android. Software is certainly still developed for other operating systems,
    but often that software doesn’t have the typical characteristics of an app (mobile-friendly,
    touch-input based, distributed via an app store, and so forth).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，原生应用是为特定操作系统构建的。苹果的App Store和随之而来的类似应用商店开启了原生软件开发的新纪元，为开发者提供了新的平台、新的软件分发方式，以及通过软件赚钱的新方式。目前，原生应用开发的现状主要集中在两个平台：iOS和Android。虽然软件仍然会为其他操作系统开发，但这些软件通常没有应用程序的典型特征（如移动友好、触摸输入、通过应用商店分发等）。
- en: Android and iOS differ in their programming languages, APIs, and more. Therefore,
    writing an app that runs on both iOS and Android requires either maintaining separate
    codebases or the use of a *cross-platform framework* like Xamarin, React Native,
    Flutter, or Unity. These cross-platform solutions abstract the underlying details
    of each operating system API, making it possible for developers to write code
    that can be built to run on multiple platforms. Many native apps also rely on
    web services, meaning that app developers must not only write and maintain code
    for iOS and Android, but they must also build or integrate with web services.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Android和iOS在编程语言、API等方面有所不同。因此，要编写一个同时适用于iOS和Android的应用程序，需要么维护独立的代码库，要么使用像Xamarin、React
    Native、Flutter或Unity这样的*跨平台框架*。这些跨平台解决方案抽象了每个操作系统API的底层细节，使开发者能够编写能够在多个平台上运行的代码。许多原生应用也依赖于网络服务，这意味着应用开发者不仅需要为iOS和Android编写和维护代码，还必须构建或与网络服务集成。
- en: Developing a cross-platform, web-connected app requires a good deal of work
    and expertise! In the past, developers would often focus on just one platform,
    such as Windows PCs or Macs. Things are certainly more complicated today for the
    developer targeting multiple platforms and the web. Platform competition is generally
    a good thing for users, but it does mean more work for developers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个跨平台的、与网络连接的应用程序需要大量的工作和专业知识！过去，开发者通常只专注于一个平台，例如Windows PC或Mac。今天，对于目标多个平台和网络的开发者来说，事情肯定更复杂了。平台竞争通常对用户是好事，但这也意味着开发者需要付出更多的工作。
- en: 'Interestingly, the current state of app development could have turned out quite
    differently. When the iPhone was announced in January 2007, Steve Jobs (Apple’s
    CEO at the time) had this to say about third-party app development on the iPhone:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，当前的应用开发状态本可以完全不同。当iPhone在2007年1月发布时，时任Apple CEO的Steve Jobs曾就iPhone上的第三方应用开发发表过以下言论：
- en: The full Safari engine is inside of iPhone. And so, you can write amazing Web
    2.0 and Ajax apps that look exactly and behave exactly like apps on the iPhone.
    And these apps can integrate perfectly with iPhone services. They can make a call,
    they can send an email, they can look up a location on Google Maps. And guess
    what? There’s no SDK that you need!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 整个Safari引擎都在iPhone内。因此，你可以编写令人惊叹的Web 2.0和Ajax应用，这些应用看起来和行为完全像iPhone上的应用。这些应用可以与iPhone服务完美集成。它们可以打电话，发送电子邮件，查找Google地图上的位置。猜猜看？你不需要任何SDK！
- en: '**NOTE**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*An* SDK (software development kit) *is a collection of software used by developers
    to build applications for a particular platform*.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个*SDK（软件开发工具包）*是开发者用于为特定平台构建应用程序的软件集合*。'
- en: Based on this quote, Apple’s original plan for third-party app development was
    to simply let developers build app-like websites that could make use of the iPhone’s
    capabilities. Native app development would be limited to the apps that Apple developed
    and included with the iPhone, such as the Camera, Mail, and Calendar apps.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这段话，苹果最初的第三方应用开发计划是让开发者只需构建类似应用的网站，这些网站可以利用iPhone的功能。原生应用开发将仅限于苹果开发并随iPhone一起提供的应用程序，如相机、邮件和日历应用。
- en: At the time, using the web as a platform for application development wasn’t
    common. Apple’s position was forward-looking. Unfortunately, the underlying technologies
    of the web in 2007 were arguably not mature enough to position the web as a true
    app platform. By October 2007, Apple changed its message, announcing that Apple
    would allow developers to build native apps for the iPhone. Apple opened the App
    Store in 2008 as the only supported mechanism for distributing native iPhone apps
    to users.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当时，使用网络作为应用开发平台并不常见。苹果的立场具有前瞻性。不幸的是，2007年时，网络的基础技术可以说还不够成熟，无法将网络定位为真正的应用平台。到2007年10月，苹果改变了其立场，宣布允许开发者为iPhone开发本地应用。苹果在2008年推出了App
    Store，这是唯一支持将本地iPhone应用分发给用户的机制。
- en: Apple’s policy reversal benefited the company, as the App Store became a source
    of revenue for Apple. There is a fee to register as an App Store developer, plus
    Apple takes a percentage of every sale. The App Store and native iPhone development
    also opened the door for exclusive content, apps that only worked on Apple devices.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果的政策逆转使公司受益，因为App Store成为苹果的一项收入来源。注册成为App Store开发者需要支付费用，而且苹果会从每笔销售中抽取一定比例。App
    Store和本地iPhone开发还为独占内容打开了大门，推出了仅能在苹果设备上运行的应用。
- en: The App Store also presents benefits to end users. A curated list of apps with
    ratings is helpful, and the store provides a measure of consumer trust. Apps that
    make it into the App Store must meet certain quality guidelines. A centralized
    payment service means users don’t have to give their payment information to multiple
    companies. Apps are automatically updated, an advantage over traditional PC software,
    although not an advantage over the web, since web apps are also updated without
    user involvement.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: App Store也为最终用户带来了好处。带有评分的精选应用列表很有帮助，且商店提供了一定程度的消费者信任。进入App Store的应用必须符合某些质量标准。集中化的支付服务意味着用户无需将支付信息提供给多个公司。应用会自动更新，这相较于传统的PC软件是一大优势，尽管相较于网络应用，这并不算优势，因为网络应用也会在没有用户干预的情况下进行更新。
- en: 'With the success of Apple’s App Store, other companies created similar digital
    storefronts for distributing software. The Google Play Store, Microsoft Store,
    and Amazon Appstore all operate on a similar model to Apple’s store and provide
    similar benefits. Although this system has generally worked well for these companies
    and for end users, it has also created a complex environment for developers: multiple
    stores, multiple platforms, and varying technologies. Each digital marketplace
    has its own requirements that app developers must meet, and each store takes a
    percentage of sales revenue.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 随着苹果App Store的成功，其他公司也创建了类似的数字商店来分发软件。Google Play商店、Microsoft Store和Amazon Appstore都采用了与苹果商店相似的模式，并提供类似的好处。尽管这一系统通常对这些公司和最终用户来说运作良好，但它也为开发者创造了一个复杂的环境：多个商店、多个平台和不同的技术。每个数字市场都有自己的要求，应用开发者必须满足这些要求，而且每个商店都会从销售收入中抽取一定的比例。
- en: '***Web Apps***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***网页应用***'
- en: Alongside the rise of native apps, the web matured into a platform that’s quite
    capable of running apps. A mature version of HTML known as HTML5 was introduced,
    and web browsers became more capable and consistent in their handling of content.
    Browser developers made their implementations of JavaScript compliant with the
    ECMAScript 5 standard, providing a better foundation for JavaScript code. Outside
    of browser updates, the web developer community embraced (and continues to embrace)
    a concept known as *responsive web design*, an approach that ensures web content
    renders well no matter the size of screen on which it’s displayed. Using responsive
    design techniques, web developers can maintain a single website that works well
    across diverse devices, rather than creating separate websites that target different
    devices. Also, multiple *web development frameworks*, such as Angular and React,
    have been released in recent years. These frameworks make it easier for developers
    to write and maintain *web apps*—websites that behave like apps.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本地应用的兴起，网络逐渐发展成为一个非常适合运行应用的平台。HTML5作为HTML的成熟版本被引入，网页浏览器在处理内容方面变得更加高效和一致。浏览器开发者使得他们的JavaScript实现符合ECMAScript
    5标准，为JavaScript代码提供了更好的基础。除了浏览器更新外，网页开发者社区接受并继续采用一种叫做*响应式网页设计*的概念，这种方法确保无论显示内容的屏幕大小如何，网页内容都能良好呈现。通过使用响应式设计技术，网页开发者可以维护一个适用于各种设备的单一网站，而不是为不同设备创建多个网站。此外，近年来发布了多个*网页开发框架*，如Angular和React。这些框架使得开发者更容易编写和维护*网页应用*——表现得像应用程序的网页。
- en: Developers have realized that modern web technology can be used to build experiences
    that closely resemble native apps, and many developers build websites that function
    as apps. Some developers have chosen to forgo native apps altogether and only
    build web apps. The advantages of this approach are that a web app will run on
    any device with a modern web browser, and the code only has to be written once.
    However, web apps also have some disadvantages. Web apps don’t have access to
    the full range of device capabilities, tend to be slower than native apps, require
    the user to be online, and generally aren’t listed in app stores.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者已经意识到，现代网页技术可以用来构建与本地应用程序非常相似的体验，许多开发者构建了像应用程序一样运行的网站。有些开发者选择完全放弃本地应用程序，只构建网页应用程序。这个方法的优点是，网页应用程序可以在任何具有现代网页浏览器的设备上运行，且代码只需要编写一次。然而，网页应用程序也有一些缺点。网页应用程序无法访问设备的全部功能，通常比本地应用程序慢，要求用户保持在线，并且通常不会列在应用商店中。
- en: To address some of the disadvantages of web apps, *Progressive Web Apps (PWAs)*
    offer a set of technologies and guidelines that help bridge the gap between native
    apps and web apps. A PWA is just a website with a few extra features that help
    it be more app-like. A Progressive Web App must be served over HTTPS, render appropriately
    on mobile devices, be able to load while offline once downloaded, provide a manifest
    to the browser that describes the app, and transition quickly between pages. To
    the end user, running a PWA should feel as responsive and natural as running a
    native app. If a website meets the criteria for a PWA, modern web browsers give
    users the option of adding an icon for the PWA to their home screen or desktop.
    Doing so means that users can launch the web app just like they would launch a
    native app. The app opens in its own window, rather than in a browser window,
    and generally behaves like a native app.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了弥补网页应用程序的一些缺点，*渐进式网页应用程序（PWAs）* 提供了一套技术和指南，帮助缩小本地应用程序和网页应用程序之间的差距。PWA 仅仅是一个具有一些额外功能的网站，这些功能使其更像一个应用程序。一个渐进式网页应用程序必须通过
    HTTPS 提供服务，能够在移动设备上适当地渲染，下载后能够离线加载，提供一个描述该应用程序的清单文件给浏览器，并且在页面之间快速过渡。对最终用户来说，运行一个
    PWA 应该和运行一个本地应用程序一样响应迅速且自然。如果一个网站符合 PWA 的标准，现代的网页浏览器会给用户提供将 PWA 图标添加到主屏幕或桌面的选项。这样做意味着用户可以像启动本地应用程序一样启动网页应用程序。该应用程序将在自己的窗口中打开，而不是浏览器窗口中，并且通常表现得像一个本地应用程序。
- en: PWAs can potentially offer great benefits to developers who wish to use web
    technologies for their apps but don’t want to build multiple apps for different
    platforms. However, there are still some drawbacks to PWAs. A significant one
    is that PWAs don’t appear in app stores. Mobile operating systems have been training
    users for years that apps should be obtained through app stores. Users aren’t
    accustomed to browsing to a web page to get an app. At the time of this writing,
    only the Microsoft Store allows PWAs to be published directly to the store. Other
    platforms expect PWAs to be installed from the browser or repackaged as a native
    app that renders the web content. This repackaged app can then be submitted to
    the store. Another potential drawback is that PWAs may not look like native apps;
    they will usually look essentially the same on all platforms, although some might
    consider this a good thing. PWAs still don’t have the performance of a native
    app or access to all the capabilities of the underlying platform, but depending
    on the needs of the app, this isn’t necessarily an issue.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 渐进式网页应用程序可能为那些希望使用网页技术构建应用程序但又不想为不同平台构建多个应用程序的开发者提供巨大好处。然而，PWA 仍然存在一些缺点。一个显著的缺点是，PWA
    不会出现在应用商店中。移动操作系统多年来一直在训练用户，应用程序应该通过应用商店获取。用户不习惯通过浏览网页来获得应用程序。在撰写本文时，只有 Microsoft
    Store 允许将 PWA 直接发布到商店。其他平台则要求 PWA 从浏览器安装或重新打包为本地应用程序来渲染网页内容。这个重新打包的应用程序可以提交到商店。另一个潜在的缺点是，PWA
    可能看起来不像本地应用程序；它们通常在所有平台上看起来基本相同，尽管有些人可能认为这是好事。PWA 仍然无法达到本地应用程序的性能，也无法访问底层平台的所有功能，但根据应用程序的需求，这不一定是一个问题。
- en: '**Virtualization and Emulation**'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**虚拟化与仿真**'
- en: When is a computer not a physical device? When it’s a virtual computer, of course!
    *Virtualization* is the process of using software to create a virtual representation
    of a computer. A related technology, *emulation*, allows applications designed
    for a certain type of device to run on a totally different type of device. In
    this section we explore both virtualization and emulation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机何时不是一个物理设备？当然是当它是一个虚拟计算机时！*虚拟化*是利用软件创建计算机虚拟表示的过程。另一种相关技术，*仿真*，允许为某种类型的设备设计的应用程序在完全不同类型的设备上运行。本节我们将探讨虚拟化和仿真两者。
- en: '***Virtualization***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***虚拟化***'
- en: A virtual computer, known as a *virtual machine (VM)*, runs an operating system
    just like a physical computer. In turn, applications run on that operating system.
    From the perspective of the application, the virtualized hardware acts like a
    physical computer. Virtualization enables several useful scenarios. A computer
    running one operating system can run another operating system in a virtual machine.
    For example, a computer running Windows can run an instance of Linux in a virtual
    machine. Virtual machines also allow datacenters to host multiple virtual servers
    on a single physical server. This provides a way for internet hosting companies
    to easily and quickly provide dedicated servers to their customers, as long as
    the customer is fine with a virtual server. VMs can be easily backed up, restored,
    and deployed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟计算机，称为*虚拟机（VM）*，运行操作系统，就像物理计算机一样。接着，应用程序在该操作系统上运行。从应用程序的角度来看，虚拟化的硬件就像物理计算机一样。虚拟化使得几种有用的场景成为可能。运行一个操作系统的计算机可以在虚拟机中运行另一个操作系统。例如，运行Windows的计算机可以在虚拟机中运行Linux的实例。虚拟机还允许数据中心在单一物理服务器上托管多个虚拟服务器。这为互联网托管公司提供了一种简单快捷的方式来为客户提供专用服务器，只要客户可以接受虚拟服务器。虚拟机可以轻松备份、恢复和部署。
- en: A *hypervisor* is a software platform that runs virtual machines. There are
    two types of hypervisors, as illustrated in [Figure 13-2](ch13.xhtml#ch13fig2).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟机监控器（Hypervisor）*是运行虚拟机的软件平台。如[图13-2](ch13.xhtml#ch13fig2)所示，虚拟机监控器有两种类型。'
- en: '![image](../images/fig13-2.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig13-2.jpg)'
- en: '*Figure 13-2: Type 1 and type 2 hypervisors*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-2：类型1和类型2虚拟机监控器*'
- en: As shown on the left side of [Figure 13-2](ch13.xhtml#ch13fig2), a hypervisor
    can interact directly with underlying hardware, actually placing the hypervisor
    below the kernel in the technology stack. The hypervisor talks to the physical
    hardware and presents virtualized hardware to the OS kernel. This is known as
    a *type 1 hypervisor*. In contrast, *type 2 hypervisors*, shown on the right in
    [Figure 13-2](ch13.xhtml#ch13fig2), run as an application on an operating system.
    Microsoft’s Hyper-V and VMware ESX are type 1 hypervisors, whereas VMware Player
    and VirtualBox are examples of type 2 hypervisors.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图13-2](ch13.xhtml#ch13fig2)左侧所示，虚拟机监控器可以直接与底层硬件交互，实际上将虚拟机监控器放置在技术栈中的内核下方。虚拟机监控器与物理硬件通信，并将虚拟化硬件呈现给操作系统内核。这被称为*类型1虚拟机监控器*。相比之下，*类型2虚拟机监控器*，如[图13-2](ch13.xhtml#ch13fig2)右侧所示，作为操作系统上的应用程序运行。微软的Hyper-V和VMware
    ESX是类型1虚拟机监控器，而VMware Player和VirtualBox是类型2虚拟机监控器的例子。
- en: Another popular approach for virtualization is the use of containers. A *container*
    provides an isolated user mode environment in which to run applications. Unlike
    a virtual machine, a container shares a kernel with the host OS and with other
    containers running on the same computer. A process running in a container can
    only see a subset of the resources available on the physical machine. For example,
    every container can be granted its own isolated filesystem. Containers provide
    the isolation of a VM without the overhead of running a separate kernel for each
    VM. In general, containers are limited to running the same operating system as
    the host since the kernel is shared. Some container technologies, like OpenVZ,
    are used to virtualize the entire user mode portion of operating systems, whereas
    others, like Docker, are used to run individual applications in isolated containers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种流行的虚拟化方法是使用容器。*容器*提供了一个隔离的用户模式环境，在其中运行应用程序。与虚拟机不同，容器与主机操作系统共享内核，并与同一计算机上运行的其他容器共享内核。运行在容器中的进程只能看到物理机上可用资源的一个子集。例如，每个容器可以被授予自己的隔离文件系统。容器提供了虚拟机的隔离功能，但没有为每个虚拟机运行独立内核的开销。一般来说，容器限于运行与主机相同的操作系统，因为内核是共享的。一些容器技术，如OpenVZ，用于虚拟化操作系统的整个用户模式部分，而其他容器技术，如Docker，用于在隔离容器中运行单独的应用程序。
- en: '**NOTE**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You may recall that an operating system process was also described as a “container”
    in [Chapter 10](ch10.xhtml)—this isn’t the same thing as a virtualization container*.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能还记得，在[第10章](ch10.xhtml)中，操作系统进程被描述为一个“容器”——这与虚拟化容器是不同的*。'
- en: '***Emulation***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***仿真***'
- en: Emulation is the use of software to make one type of device behave like another
    type of device. Emulation and virtualization are similar in that they both provide
    a virtual environment for running software, but whereas virtualization offers
    up a slice of the underlying hardware, emulation presents virtual hardware that’s
    *unlike* the physical hardware in use. For example, a virtual machine or container
    running on an x86 processor runs software compiled for x86, directly making use
    of the physical CPU. In contrast, an *emulator* (a program that performs emulation)
    running on x86 hardware can run software compiled for a completely different processor.
    Emulators often also provide other virtual hardware besides the processor.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 仿真是使用软件使一种设备表现得像另一种设备。仿真和虚拟化的相似之处在于，它们都提供一个虚拟环境来运行软件，但虚拟化提供的是底层硬件的一部分，而仿真则呈现出与正在使用的物理硬件*不同*的虚拟硬件。例如，运行在x86处理器上的虚拟机或容器运行为x86编译的软件，直接利用物理CPU。相比之下，运行在x86硬件上的*仿真器*（执行仿真的程序）可以运行为完全不同处理器编译的软件。仿真器通常还会提供除处理器之外的其他虚拟硬件。
- en: For example, a complete emulator for the Sega Genesis (a video game system from
    the 1990s) will emulate a Motorola 68000 processor, a Yamaha YM2612 sound chip,
    input controllers, and every other piece of hardware found in a Sega Genesis.
    At runtime, such an emulator translates CPU instructions originally designed to
    run on a Sega Genesis to capabilities implemented in x86 code. This introduces
    significant overhead, since each CPU instruction must be translated, but a sufficiently
    fast modern computer can still emulate the much slower Sega Genesis at full speed.
    The result is the ability to run software intended for one platform on a completely
    different platform, as shown in [Figure 13-3](ch13.xhtml#ch13fig3).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，完整的Sega Genesis（1990年代的视频游戏系统）仿真器将模拟摩托罗拉68000处理器、雅马哈YM2612音频芯片、输入控制器和Sega
    Genesis中所有其他硬件。在运行时，这样的仿真器将原本设计用于Sega Genesis的CPU指令转换为在x86代码中实现的功能。这引入了显著的开销，因为每条CPU指令都必须进行转换，但足够快速的现代计算机仍然可以以全速仿真远比Sega
    Genesis慢得多的硬件。结果是可以在完全不同的平台上运行为某个平台设计的软件，如[图13-3](ch13.xhtml#ch13fig3)所示。
- en: '![image](../images/fig13-3.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig13-3.jpg)'
- en: '*Figure 13-3: Code compiled for System A can run on an emulator for System
    A*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-3：为系统A编译的代码可以在系统A的仿真器上运行*'
- en: Emulation plays an important role in preserving software designed for obsolete
    platforms. As computing platforms age, it becomes increasingly difficult to find
    working hardware. Emulation is commonly used by software developers who want to
    bring old software to a modern platform. The original source code may be lost,
    or the task of modernizing it may be burdensome. In such cases, investing in an
    emulator allows the original compiled code to run on a new platform without modification.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 仿真在保护为过时平台设计的软件方面起着重要作用。随着计算平台的老化，找到可以正常工作的硬件变得越来越困难。软件开发人员常常使用仿真技术来将旧软件移植到现代平台上。原始的源代码可能已经丢失，或者更新它的任务可能会非常繁重。在这种情况下，投资仿真器可以让原始的已编译代码在不修改的情况下在新平台上运行。
- en: '**PROCESS VIRTUAL MACHINES**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程虚拟机**'
- en: There’s another type of virtual machine that shares some traits with emulators.
    A *process virtual machine* runs an application within an execution environment
    that abstracts the details of the underlying operating system. It’s similar to
    an emulator in that it provides a platform for execution that’s decoupled from
    the hardware and OS on which it runs. However, unlike an emulator, a process VM
    isn’t trying to simulate real hardware. Rather, it provides an environment designed
    for running platform-independent software. As we discussed in [Chapter 9](ch09.xhtml),
    Java and .NET make use of process virtual machines that run bytecode.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种与仿真器有些相似的虚拟机类型。*进程虚拟机*在一个执行环境中运行应用程序，该环境抽象了底层操作系统的细节。它类似于仿真器，因为它提供了一个与运行它的硬件和操作系统解耦的平台执行环境。然而，不同于仿真器，进程虚拟机并不试图模拟真实的硬件。相反，它提供了一个为运行平台无关的软件而设计的环境。正如我们在[第9章](ch09.xhtml)中讨论的，Java和.NET利用了运行字节码的进程虚拟机。
- en: '**Cloud Computing**'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**云计算**'
- en: '*Cloud computing* is the delivery of computing services over the internet.
    In this section, we’ll look at various types of cloud computing, but first let’s
    quickly review the history of remote computing.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*云计算*是通过互联网提供计算服务。在本节中，我们将探讨各种类型的云计算，但首先让我们快速回顾一下远程计算的历史。'
- en: '***The History of Remote Computing***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***远程计算的历史***'
- en: Since the beginning of computing, we can observe a pendulum swing from remote,
    centralized computing (servers accessed from terminals), to local computing (desktop
    computers), and now back to remote computing (the web) accessed from smart, local
    devices (such as smartphones). Many applications today rely on a combination of
    remote computing and local computing. In the case of the web, some code runs in
    a browser and some code runs on a web server. The devices we carry in our pockets
    today are significantly more powerful than the room-sized computers from the early
    days of computing, yet much of what we want to do on those devices involves communicating
    with other computers, so it makes sense that the responsibility of processing
    should be shared between local devices and remote servers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 自计算机诞生以来，我们可以观察到从远程集中式计算（通过终端访问服务器）到本地计算（桌面计算机），再到现在的远程计算（通过智能本地设备如智能手机访问网络）的摆动。今天，许多应用程序依赖于远程计算和本地计算的结合。在网络的情况下，部分代码运行在浏览器中，部分代码运行在网络服务器上。我们今天口袋里携带的设备，比起计算机诞生初期的占地一间房大小的机器，要强大得多，但我们希望在这些设备上做的许多事情，仍然涉及与其他计算机的通信，因此将处理任务分担给本地设备和远程服务器是合情合理的。
- en: With this reemergence of remote computing came a need for organizations to maintain
    servers. In the past, this meant purchasing a physical server, configuring it
    as needed, connecting it to the network, and letting it run in a closet somewhere.
    The organization had physical access to the machine and complete control over
    its configuration. However, maintaining a server (or a fleet of servers) can be
    a complex and costly endeavor. This includes the costs of purchasing and maintaining
    hardware, keeping up with software updates, dealing with security concerns and
    capacity planning concerns, managing the networking configuration, and so forth.
    Often the skillset and expertise required for this work doesn’t align well with
    the purpose of an organization. Even a technology-focused company doesn’t necessarily
    want to be in the business of maintaining servers. This is where cloud computing
    comes in.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 随着远程计算的重新兴起，组织开始需要维护服务器。过去，这意味着购买一台物理服务器，根据需要进行配置，将其连接到网络，并让它在某个储物间中运行。组织可以直接访问机器，并完全控制其配置。然而，维护服务器（或一组服务器）可能是一项复杂且昂贵的工作。这包括购买和维护硬件、跟进软件更新、处理安全问题和容量规划问题、管理网络配置等等。通常，这项工作所需的技能和专业知识与组织的主要业务并不匹配。即使是一个技术驱动的公司，也不一定希望从事维护服务器的工作。这就是云计算的出现背景。
- en: '*Cloud computing* delivers remote computing capabilities over the internet
    (the *cloud*). Underlying hardware is maintained by a cloud services company (the
    *cloud provider*), freeing the organization or user in need of such capabilities
    (the *cloud consumer*) from maintaining servers. Cloud computing allows for the
    purchase of computing services on demand, as needed. For the cloud consumer, this
    means releasing control of certain things and trusting a third party to deliver
    reliable service. Cloud computing takes many forms; let’s look at some of those
    forms here.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*云计算*通过互联网（即*云*）提供远程计算能力。底层硬件由云服务公司（即*云提供商*）维护，解放了需要这些计算能力的组织或用户（即*云消费者*）免于维护服务器。云计算允许按需购买计算服务，随需随取。对于云消费者来说，这意味着放弃对某些事务的控制，信任第三方提供可靠的服务。云计算有多种形式；我们将在这里了解其中的一些形式。'
- en: '***The Categories of Cloud Computing***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***云计算的类别***'
- en: The various categories of cloud computing are typically defined by the line
    that divides the responsibility between the cloud provider and the cloud consumer.
    [Figure 13-4](ch13.xhtml#ch13fig4) provides an overview of four categories of
    cloud computing (IaaS, PaaS, FaaS, and SaaS) and their respective divisions of
    responsibility. We’ll look at each of these categories momentarily.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算的不同类别通常由划分云提供商和云消费者责任的界限定义。[图13-4](ch13.xhtml#ch13fig4)提供了四种云计算类别（IaaS、PaaS、FaaS
    和 SaaS）及其各自责任划分的概述。我们接下来将逐一介绍这些类别。
- en: '![image](../images/fig13-4.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig13-4.jpg)'
- en: '*Figure 13-4: Distribution of responsibility in various types of cloud offerings*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-4：不同类型云服务中的责任分配*'
- en: The vertical stacks in [Figure 13-4](ch13.xhtml#ch13fig4) represent the components
    needed to run an application. No matter which category of cloud computing is used,
    all the components need to be present—the difference across categories lies in
    whether the cloud provider or the cloud consumer is responsible for managing each
    component. The various components in each stack should look familiar, since we’ve
    covered these topics already. However, *runtime* requires an explanation. A *runtime
    environment* is the environment in which an application executes, including any
    needed libraries, interpreters, process virtual machines, and so forth. Let’s
    now cover the four categories of cloud computing shown in [Figure 13-4](ch13.xhtml#ch13fig4),
    progressing from left to right.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-4](ch13.xhtml#ch13fig4)中的垂直堆栈表示运行应用程序所需的组件。无论使用哪种类型的云计算，所有组件都必须存在——各类别之间的区别在于云服务提供商或云消费者是否负责管理每个组件。每个堆栈中的不同组件应该是熟悉的，因为我们已经覆盖了这些主题。然而，*运行时*
    需要解释。*运行时环境* 是应用程序执行的环境，包括所需的库、解释器、进程虚拟机等。接下来，让我们从左到右依次介绍[图13-4](ch13.xhtml#ch13fig4)中展示的四种云计算类别。'
- en: '*Infrastructure as a Service (IaaS)* is a cloud computing scenario in which
    a cloud provider manages hardware and virtualization only, allowing the consumer
    to manage the operating system, runtime environment, application code, and data.
    A consumer of IaaS typically gets an internet-connected, virtual computer to use
    as they see fit, typically as a server of some sort. This virtual computer is
    usually implemented as a hypervisor-based virtual machine or a container of the
    user mode portion of a Linux distribution. The consumer of an IaaS virtual server
    has access to the virtual computer’s operating system and is able to configure
    it however they wish. This gives the consumer maximum flexibility, but it also
    means that the responsibility of maintaining the system’s software (including
    the operating system, third-party software, and so forth) sits squarely on the
    shoulders of the consumer. IaaS provides a virtual computer, and the consumer
    is responsible for everything that runs on that computer. Here are some examples
    of IaaS: Amazon Elastic Compute Cloud (EC2), Microsoft Azure Virtual Machines,
    and Google Compute Engine.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*基础设施即服务（IaaS）* 是一种云计算场景，其中云服务提供商仅管理硬件和虚拟化，允许消费者管理操作系统、运行时环境、应用代码和数据。IaaS的消费者通常会获得一台连接互联网的虚拟计算机，按照自己的需求使用，通常作为某种类型的服务器。这台虚拟计算机通常实现为基于虚拟机监控程序的虚拟机或用户模式部分的
    Linux 发行版容器。IaaS虚拟服务器的消费者可以访问虚拟计算机的操作系统，并可以根据需要配置它。这为消费者提供了最大灵活性，但也意味着维护系统软件（包括操作系统、第三方软件等）的责任完全落在消费者肩上。IaaS提供了一台虚拟计算机，消费者负责运行在该计算机上的所有内容。以下是一些IaaS的例子：亚马逊弹性计算云（EC2）、微软Azure虚拟机和谷歌计算引擎。'
- en: '*Platform as a Service (PaaS)* gives the cloud provider more responsibility.
    In a PaaS scenario, the cloud provider manages not only hardware and virtualization,
    but also the operating system and runtime environment that the consumer wishes
    to use. A PaaS consumer develops an application that’s targeted to run on their
    chosen cloud platform, taking advantage of the various capabilities that are unique
    to that platform. Cloud consumers of PaaS offerings don’t need to concern themselves
    with maintaining the underlying OS or runtime environment. The cloud consumer
    can just focus on their application code. Although the provider does abstract
    away the details of the underlying system, the consumer still needs to manage
    what resources are provisioned by the provider to handle their application. This
    includes the amount of storage required and the type of allocated virtual machines.
    PaaS provides a managed platform for running code, and the consumer is responsible
    for the application that runs on that platform. Here are some examples of PaaS:
    Amazon Web Services Elastic Beanstalk, Microsoft Azure App Service, and Google
    App Engine.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*平台即服务（PaaS）*赋予云服务提供商更多的责任。在PaaS场景中，云服务提供商不仅管理硬件和虚拟化，还管理消费者希望使用的操作系统和运行时环境。PaaS消费者开发的应用程序是为了在他们选择的云平台上运行，并利用该平台独特的各种功能。PaaS产品的云消费者无需担心维护底层操作系统或运行时环境。云消费者可以只专注于他们的应用程序代码。尽管提供商抽象化了底层系统的细节，消费者仍然需要管理由提供商配置的用于处理其应用程序的资源。这包括所需的存储量和分配的虚拟机类型。PaaS提供了一个托管平台来运行代码，消费者负责运行在该平台上的应用程序。以下是一些PaaS的例子：Amazon
    Web Services Elastic Beanstalk、Microsoft Azure App Service和Google App Engine。'
- en: '*Function as a Service (FaaS)* takes the PaaS model one step further. It does
    not require the consumer to deploy a full application or to provision platform
    instances ahead of time. Instead, a consumer only needs to deploy their code (a
    function) that runs in response to certain events. For example, a developer could
    write a function that returns the distance to the nearest grocery store. This
    function could run in response to a web browser sending its current GPS coordinates
    to a URL. This event-driven model means that the cloud provider is responsible
    for an on-demand invocation of the consumer’s code. The consumer no longer needs
    to have application code running all the time, waiting for requests. This can
    simplify things for the consumer and reduce costs, although it can mean a slower
    response time when a request comes in if the function code isn’t already running.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数即服务（FaaS）*将PaaS模型进一步发展。它不要求消费者部署完整的应用程序或提前配置平台实例。相反，消费者只需要部署他们的代码（一个函数），该函数在响应特定事件时运行。例如，开发者可以编写一个函数，返回距离最近超市的距离。该函数可以在浏览器向URL发送当前GPS坐标时运行。这个事件驱动的模型意味着云服务提供商负责按需调用消费者的代码。消费者不再需要让应用程序代码始终运行，等待请求的到来。这可以简化消费者的操作并降低成本，尽管如果函数代码尚未运行，处理请求时可能会有较慢的响应时间。'
- en: FaaS is a type of *serverless computing*, a cloud computing model where consumers
    do not have to deal with managing servers or virtual machines. Of course, the
    term is a misnomer; servers are actually required to run the code, it’s just that
    the consumer doesn’t have to think about them! FaaS provides an event-driven platform
    for running code, and the consumer is responsible for the code that runs in response
    to events. Some examples of FaaS include Amazon Web Services Lambda, Microsoft
    Azure Functions, and Google Cloud Functions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: FaaS是一种*无服务器计算*，一种云计算模型，在这种模型中，消费者不需要处理服务器或虚拟机的管理。当然，这个术语并不完全准确；实际上运行代码是需要服务器的，只不过消费者不需要考虑它们！FaaS提供了一个事件驱动的平台来运行代码，消费者负责响应事件时运行的代码。一些FaaS的例子包括Amazon
    Web Services Lambda、Microsoft Azure Functions和Google Cloud Functions。
- en: '*Software as a Service (SaaS)* is a fundamentally different type of cloud service.
    SaaS delivers an application to the consumer that’s fully managed in the cloud.
    Whereas IaaS, PaaS, and FaaS are for software engineering teams who want to run
    their own code in the cloud, SaaS delivers a complete cloud application to end
    users or organizations, already written. So much software runs in the cloud today
    that this may seem unremarkable, but it stands in contrast to a user or organization
    installing and maintaining software on their local devices and network. SaaS provides
    a complete application managed in the cloud, and the consumer is only responsible
    for the data they store in that application. Even management of data is partially
    handled by the provider, including the details of how the data is stored, backed
    up, and so forth. Some examples of SaaS include Microsoft 365, Google G Suite,
    and Dropbox.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*软件即服务 (SaaS)* 是一种本质上与其他云服务不同的服务类型。SaaS 为消费者提供的应用程序完全托管在云端。而IaaS、PaaS和FaaS是面向希望在云中运行自己代码的软件工程团队，SaaS则向最终用户或组织提供一个已经编写好的完整云应用程序。如今，许多软件都在云端运行，因此这看起来似乎没有什么特别的，但它与用户或组织在本地设备和网络上安装和维护软件形成鲜明对比。SaaS
    提供一个完全在云中管理的应用程序，消费者只需负责存储在该应用程序中的数据。甚至数据的管理也部分由提供商负责，包括数据存储、备份等细节。SaaS的一些例子包括
    Microsoft 365、Google G Suite 和 Dropbox。'
- en: Some of the major players in the cloud provider space are Amazon Web Services,
    Microsoft Azure, Google Cloud Platform, IBM Cloud, Oracle Cloud, and Alibaba Cloud.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务提供商领域的一些主要参与者包括亚马逊 Web 服务、微软 Azure、谷歌云平台、IBM 云、甲骨文云和阿里巴巴云。
- en: '**The Deep Web and Dark Web**'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**深网与暗网**'
- en: 'You have probably read news about nefarious happenings on the dark web or the
    deep web. Unfortunately, the two terms are often confused, but they have distinct
    meanings. The web can be divided into three broad segments: the surface web, the
    deep web, and the dark web, as illustrated in [Figure 13-5](ch13.xhtml#ch13fig5).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经读过有关暗网或深网的恶性事件的新闻。不幸的是，这两个术语经常被混淆，但它们有着不同的含义。网络可以分为三个大致的部分：表层网络、深网和暗网，如[图13-5](ch13.xhtml#ch13fig5)所示。
- en: '![image](../images/fig13-5.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig13-5.jpg)'
- en: '*Figure 13-5: The surface web, deep web, and dark web*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-5：表层网络、深网和暗网*'
- en: Content that’s freely available for anyone to access is part of the *surface
    web*. Public blogs, news sites, and public Twitter posts are all examples of surface
    web content. The surface web is indexed by search engines, and sometimes the surface
    web is defined as content that can be found with a search engine.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人都可以自由访问的内容属于*表层网络*。公共博客、新闻网站和公共推特帖子都是表层网络内容的例子。表层网络是被搜索引擎索引的，有时，表层网络被定义为可以通过搜索引擎找到的内容。
- en: The *deep web* is web content that cannot be accessed without logging in to
    a website or web service. Most internet users access deep web content on a regular
    basis. Checking your bank balance, reading your email through a website like Gmail,
    logging in to Facebook, looking at your personal shopping history on Amazon—these
    are all examples of deep web activities. The deep web is simply content that’s
    not publicly available and generally requires a password of some sort to access.
    Most users don’t want their email or bank balances to be publicly available, so
    there’s a good reason why this type of content isn’t public and cannot be indexed
    by search engines.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*深网* 是指需要登录网站或网络服务才能访问的网络内容。大多数互联网用户都定期访问深网内容。查看银行余额、通过像Gmail这样的网页读取电子邮件、登录Facebook、查看自己在亚马逊上的个人购物历史——这些都是深网活动的例子。深网仅仅是指那些不可公开访问的内容，通常需要某种密码才能访问。大多数用户不希望他们的电子邮件或银行余额公开，因此这些内容不会公开，并且无法被搜索引擎索引。'
- en: The *dark web* is web content that requires specialized software to access.
    You cannot access the dark web using only a standard web browser. The most prevalent
    dark web technology is *Tor (the onion router)*. Through a system of encryption
    and relays, Tor allows for anonymous access to the web, preventing a user’s ISP
    from monitoring which sites are accessed, and preventing sites from knowing their
    visitor’s IP address. Additionally, Tor allows users to access websites known
    as *onion services* that cannot be accessed at all without Tor—these sites are
    part of the dark web. Tor hides the IP addresses of onion services, making them
    anonymous as well. As you might expect, the anonymity of the dark web is sometimes
    exploited for criminal purposes. However, there are legitimate uses for the privacy
    afforded by the dark web, such as whistleblowing and political discussion. I recommend
    caution when accessing content on the dark web.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*暗网*是需要专门软件才能访问的网络内容。你不能仅通过标准网页浏览器访问暗网。最常见的暗网技术是*Tor（洋葱路由器）*。通过加密和中继系统，Tor使得用户能够匿名访问网络，防止用户的ISP监控访问的站点，也防止网站知道访客的IP地址。此外，Tor还允许用户访问一些称为*洋葱服务*的网站，这些网站如果没有Tor无法访问——这些网站属于暗网的一部分。Tor还隐藏洋葱服务的IP地址，使其匿名。如你所料，暗网的匿名性有时被犯罪分子利用。然而，暗网所提供的隐私也有合法用途，比如举报和政治讨论。在访问暗网内容时，我建议谨慎。'
- en: '**Bitcoin**'
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**比特币**'
- en: A *cryptocurrency* is a digital asset intended to be used for financial transactions,
    as a substitute for a traditional currency like the US dollar. Users of cryptocurrencies
    maintain a balance of that currency, much like at a traditional bank, and can
    spend their currency on goods and services. Some users treat cryptocurrencies
    primarily as an investment rather than a means of commerce, making it more akin
    to something like gold for those users. Unlike traditional currencies, cryptocurrencies
    are typically decentralized, with no single organization controlling their use.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*加密货币*是一种数字资产，旨在用于金融交易，作为传统货币（如美元）的替代品。加密货币的用户维持该货币的余额，类似于传统银行账户，并可以用其购买商品和服务。有些用户将加密货币主要作为投资，而非交易手段，这使得它对于这些用户来说更像是黄金。与传统货币不同，加密货币通常是去中心化的，没有任何单一组织控制其使用。'
- en: '***Bitcoin Basics***'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***比特币基础***'
- en: Introduced in 2009, *Bitcoin* was the first decentralized cryptocurrency, and
    it’s the most well-known today. Since then, a large number of alternate cryptocurrencies
    (known as *altcoins*) have sprung up, but none have challenged the dominance of
    Bitcoin. Bitcoin’s main unit of currency is also simply called *bitcoin*, abbreviated
    *BTC*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*比特币*于2009年推出，是第一种去中心化的加密货币，今天也是最为人知的。自那时以来，大量的替代加密货币（被称为*山寨币*）相继出现，但没有一种能够挑战比特币的主导地位。比特币的主要货币单位也叫做*比特币*，缩写为*BTC*。'
- en: Bitcoin and similar cryptocurrencies are based on *blockchain* technology. In
    a blockchain, information is grouped into data structures called *blocks*, and
    blocks are linked together chronologically. That is, when a new block is created,
    it’s added to the end of a blockchain. In the case of Bitcoin, blocks hold transaction
    records, tracking the movement of bitcoins. [Figure 13-6](ch13.xhtml#ch13fig6)
    illustrates the Bitcoin blockchain.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币和类似的加密货币基于*区块链*技术。在区块链中，信息被分组到叫做*区块*的数据结构中，区块按时间顺序连接在一起。也就是说，当新块创建时，它会被添加到区块链的末端。以比特币为例，区块中保存着交易记录，跟踪比特币的流动。[图13-6](ch13.xhtml#ch13fig6)展示了比特币区块链的情况。
- en: '![image](../images/fig13-6.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig13-6.jpg)'
- en: '*Figure 13-6: Bitcoin’s blockchain links chronological blocks of transaction
    records.*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-6：比特币的区块链将按时间顺序链接交易记录块。*'
- en: Blockchains operate over a network such as the internet, with multiple computers
    working together to process transactions and update the blockchain. The computers
    that work together to process Bitcoin transactions are known as the *Bitcoin network*.
    A computer that connects to the Bitcoin network is called a *node*, and certain
    nodes hold a copy of the blockchain; there is no single master copy. Encryption
    and decryption are employed to ensure the integrity of transactions and prevent
    tampering with the data in the blockchain. Once written, blockchain data is immutable—it
    can’t be changed. Bitcoin’s blockchain is a public, decentralized, immutable ledger
    of transactions. This ledger is used to record all events that occur on the Bitcoin
    network, such as the transfer of bitcoins.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链通过像互联网这样的网络运行，多个计算机共同处理交易并更新区块链。一起处理比特币交易的计算机被称为*比特币网络*。连接到比特币网络的计算机称为*节点*，某些节点保存区块链的副本；没有单一的主副本。加密和解密被用来确保交易的完整性，并防止篡改区块链中的数据。一旦写入，区块链数据是不可更改的——它不能被修改。比特币的区块链是一个公共的、去中心化的、不可变的交易账本。这个账本用来记录所有在比特币网络上发生的事件，比如比特币的转账。
- en: '***Bitcoin Wallets***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***比特币钱包***'
- en: An end user’s bitcoins are stored in a *Bitcoin wallet*. However, more accurately,
    a Bitcoin wallet holds a collection of cryptographic key pairs, as illustrated
    in [Figure 13-7](ch13.xhtml#ch13fig7).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最终用户的比特币存储在*比特币钱包*中。然而，更准确地说，比特币钱包持有一组加密密钥对，如[图 13-7](ch13.xhtml#ch13fig7)所示。
- en: '![image](../images/fig13-7.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig13-7.jpg)'
- en: '*Figure 13-7: A Bitcoin wallet contains key pairs. A Bitcoin address is derived
    from a public key.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-7：一个比特币钱包包含密钥对。比特币地址是由公钥派生出来的。*'
- en: 'As shown in [Figure 13-7](ch13.xhtml#ch13fig7), each key pair in a wallet consists
    of two numbers—a private key and a public key. The *private key* is a randomly
    generated 256-bit number. This number must be kept secret; anyone who knows the
    private key can spend the bitcoins associated with the key pair. The *public key*,
    which is used to receive bitcoins, is derived from the private key. When receiving
    bitcoins, the public key is represented as a *Bitcoin address*, a text string
    generated from the public key. Here’s an example Bitcoin address: `13pB1brJqea4DYXkUKv5n44HCgBkJHa2v1`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 13-7](ch13.xhtml#ch13fig7)所示，钱包中的每个密钥对由两个数字组成——一个私钥和一个公钥。*私钥*是一个随机生成的256位数字。这个数字必须保密；任何知道私钥的人都可以花费与该密钥对相关联的比特币。*公钥*用于接收比特币，是从私钥派生出来的。在接收比特币时，公钥以*比特币地址*的形式表示，这是从公钥生成的文本字符串。这里是一个比特币地址的例子：`13pB1brJqea4DYXkUKv5n44HCgBkJHa2v1`。
- en: Let’s say I have one bitcoin that I want to send you. This bitcoin is associated
    with an address that I control. That is, I have the private key for this address.
    If you give me the text string representation of a Bitcoin address that you control,
    I can send my bitcoin to your address. You don’t need to (and shouldn’t) send
    me your private key. I’m able to send my bitcoin to you because I have the private
    key for my address, which allows me to spend my bitcoin. Conversely, I can’t transfer
    any bitcoins out of your address because I don’t have your private key.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有一个比特币想要发送给你。这个比特币与我控制的地址相关联。也就是说，我拥有这个地址的私钥。如果你给我你控制的比特币地址的文本字符串表示，我可以将我的比特币发送到你的地址。你不需要（也不应该）将私钥发给我。我之所以能将比特币发送给你，是因为我拥有我地址的私钥，这使我能够花费我的比特币。反之，我无法将任何比特币转出你的地址，因为我没有你的私钥。
- en: '***Bitcoin Transactions***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***比特币交易***'
- en: Let’s take a closer look at how this works. A transfer of bitcoins is known
    as a *transaction*. To send bitcoins, wallet software constructs a transaction
    specifying the details of the transfer, digitally signs it with a private key,
    and broadcasts the transaction to the Bitcoin network. The computers in the Bitcoin
    network verify the transaction and add it to a new block on the blockchain. [Figure
    13-8](ch13.xhtml#ch13fig8) illustrates a Bitcoin transaction.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看它是如何工作的。比特币的转账被称为*交易*。要发送比特币，钱包软件构建一个指定转账细节的交易，用私钥对其进行数字签名，然后将交易广播到比特币网络中。比特币网络中的计算机验证交易，并将其添加到区块链中的新区块。
    [图 13-8](ch13.xhtml#ch13fig8) 说明了一个比特币交易。
- en: '![image](../images/fig13-8.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig13-8.jpg)'
- en: '*Figure 13-8: A Bitcoin transaction moves 0.5 bitcoin to address B (ignoring
    any transaction fee).*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-8：一个比特币交易将0.5比特币转移到地址B（忽略任何交易费用）。*'
- en: As shown in [Figure 13-8](ch13.xhtml#ch13fig8), a transaction contains inputs
    and outputs, representing where the bitcoin is coming from and going to. On the
    left of this figure we have a previous transaction, where only the output is shown;
    the input of the previous transaction isn’t relevant to our discussion. In the
    previous transaction, 0.5 BTC was sent to address A.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 13-8](ch13.xhtml#ch13fig8)所示，交易包含输入和输出，分别表示比特币的来源和去向。在该图的左侧，我们可以看到一个先前的交易，只有输出被显示；先前交易的输入与我们的讨论无关。在先前的交易中，0.5
    BTC被发送到地址A。
- en: On the right side of [Figure 13-8](ch13.xhtml#ch13fig8) we have a new transaction,
    which moves 0.5 BTC from address A to address B. For simplicity, this transaction
    has only a single input and single output. The input represents the source of
    the bitcoin to be transferred. You might expect this to be a Bitcoin address,
    but it isn’t. Instead, the input is the previous transaction’s output. Let’s say
    that address A is my address, and I want to send 0.5 bitcoin to your address,
    address B. Now, I know that previously 0.5 BTC was sent to my address, so I can
    use that previous transaction’s output as an input to a new transaction, allowing
    me to send that 0.5 bitcoin to you. The output portion of a transaction contains
    the address where the bitcoin is sent.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 13-8](ch13.xhtml#ch13fig8)的右侧，我们可以看到一个新交易，它将0.5 BTC从地址A转移到地址B。为了简便起见，这笔交易只有一个输入和一个输出。输入表示要转移的比特币的来源。你可能会认为这应该是一个比特币地址，但事实并非如此。相反，输入是先前交易的输出。假设地址A是我的地址，而我想将0.5比特币发送到你的地址B。那么，我知道之前0.5
    BTC已被发送到我的地址，因此我可以将先前交易的输出作为新交易的输入，从而将那0.5比特币发送给你。交易的输出部分包含比特币被发送到的地址。
- en: Although you can think of an address as having a balance of bitcoin, the amount
    of bitcoin associated with an address isn’t stored in a Bitcoin wallet, nor is
    the balance directly stored in the blockchain. Instead, the history of transactions
    association with that address is stored in the blockchain, and from that history
    the balance for a certain address may be calculated. As a reminder, Bitcoin wallets
    simply contain the keys that enable Bitcoin transactions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以认为一个地址有比特币余额，但与地址相关的比特币数量并不是存储在比特币钱包中的，也不是直接存储在区块链中的。相反，关联到该地址的交易历史存储在区块链中，从这些历史记录中可以计算出某个地址的余额。提醒一下，比特币钱包只是包含了用于执行比特币交易的密钥。
- en: '***Bitcoin Mining***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***比特币挖矿***'
- en: The process of maintaining the Bitcoin blockchain is known as *Bitcoin mining*.
    Computers from around the globe add blocks of transactions to the blockchain—these
    computers are called *miners*. [Figure 13-9](ch13.xhtml#ch13fig9) illustrates
    the process of mining bitcoins.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 维护比特币区块链的过程被称为*比特币挖矿*。全球的计算机将交易区块添加到区块链中——这些计算机被称为*矿工*。[图 13-9](ch13.xhtml#ch13fig9)展示了比特币挖矿的过程。
- en: '![image](../images/fig13-9.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig13-9.jpg)'
- en: '*Figure 13-9: Bitcoin mining*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-9：比特币挖矿*'
- en: In order to add a block of transactions to the blockchain, a miner must verify
    the transactions included in the block (ensuring that each transaction is syntactically
    correct, that the input coins haven’t already been spent, and so forth), and it
    must also complete a computationally difficult problem. Requiring miners to solve
    such a problem prevents tampering with the blockchain, since altering a block
    would require solving the problem for the altered block and for every block that
    comes after it in the blockchain. This system of solving a difficult problem as
    a means of deterring unwanted behavior is known as *proof of work*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将一个交易区块添加到区块链中，矿工必须验证区块中包含的交易（确保每个交易在语法上正确，输入的比特币尚未被花费等等），并且还必须完成一个计算上困难的问题。要求矿工解决这样的问题可以防止篡改区块链，因为修改一个区块需要重新解决该区块及其后续所有区块的问题。这种通过解决困难问题来防止不当行为的系统被称为*工作量证明*。
- en: Arriving at a solution to the computational problem involves a significant number
    of trial-and-error calculations. The solution is hard to produce but easy to verify.
    The first miner to complete the problem is awarded a sum of bitcoins. This is
    how new bitcoins are generated and introduced into the system. In this way, Bitcoin
    mining is similar to traditional mining—miners perform work and may “strike gold”
    under the right circumstances. In addition to being awarded newly minted bitcoins,
    the miner is also able to claim a *fee* for each transaction included in the block,
    which is deducted from the total amount of bitcoins sent in the transaction. Bitcoin
    is designed to only allow for 21 million coins to be mined in total. Once this
    number is reached, Bitcoin miners will no longer be awarded bitcoins, and will
    instead rely on transaction fees to fund their operations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到达计算问题的解决方案需要大量的试验和错误计算。解决方案难以产生，但容易验证。第一个完成问题的矿工将获得一笔比特币奖励。这就是新比特币生成并被引入系统的方式。这样，比特币挖矿类似于传统矿业——矿工进行工作，在合适的情况下可能会“淘金”。除了获得新铸造的比特币外，矿工还可以为每个包含在区块中的交易收取*手续费*，该费用从交易中发送的比特币总额中扣除。比特币的设计只允许总共挖掘2100万个币。一旦这个数字达到，比特币矿工将不再获得比特币奖励，而是依靠交易费用来资助他们的运营。
- en: '**BITCOIN BEGINNINGS**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**比特币的起源**'
- en: The Bitcoin blockchain began when the first block, known as the *genesis block*,
    was mined in 2009\. This block was mined by Satoshi Nakamoto, who is credited
    with inventing Bitcoin. “Satoshi Nakamoto” is presumed to be a pseudonym; this
    person’s identity is disputed at the time of this writing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币区块链的开始可以追溯到2009年，当时第一个区块，也就是*创世区块*，被挖掘出来。这个区块是由中本聪挖掘的，中本聪被认为是比特币的发明者。“中本聪”被认为是一个化名；至本文写作时，这个人的身份仍然存在争议。
- en: For Bitcoin mining to be profitable, the costs of operating mining hardware
    must not exceed the value of bitcoins awarded. Bitcoin mining hardware tends to
    be power-hungry, and so the electricity bill for people mining Bitcoin can be
    high. Bitcoin was originally mined on regular computers, but today specialized,
    costly hardware is used to mine as quickly as possible (remember, the award goes
    to the first computer to solve the problem). These costs, plus the highly volatile
    price of bitcoins, mean that Bitcoin mining is not a guaranteed path to profit!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要使比特币挖矿有利可图，操作挖矿硬件的成本不能超过获得的比特币的价值。比特币挖矿硬件通常非常耗电，因此挖矿者的电费可能很高。比特币最初是在普通计算机上挖掘的，但如今使用专用的、高成本的硬件来尽可能快地挖矿（记住，奖励会给予第一个解决问题的计算机）。这些成本，加上比特币价格的高度波动，意味着比特币挖矿并不是一条保证盈利的路！
- en: The Bitcoin blockchain is public—all transactions can be viewed by anyone. However,
    the blockchain contains no records of the personal identity of the people transferring
    bitcoins. So while an address’s balance and transaction history are public, there’s
    no easy way to tie that address to a human. For that reason, Bitcoin is attractive
    to those who wish to remain anonymous, such as those who run commerce sites on
    the dark web.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币区块链是公开的——所有交易都可以被任何人查看。然而，区块链中没有记录转账比特币的人的个人身份。因此，尽管一个地址的余额和交易历史是公开的，但没有简单的方法将该地址与某个人挂钩。因此，比特币对那些希望保持匿名的人具有吸引力，比如那些在暗网运营商业网站的人。
- en: Blockchain technology is closely associated with cryptocurrencies, where it’s
    used as a financial ledger, but blockchains can be used for other purposes as
    well. Any system that needs a tamper-resistant history of records could make use
    of a blockchain. Time will tell if Bitcoin or other cryptocurrencies are successful
    in the long run, but regardless, we may see blockchain technology leveraged in
    other novel ways.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链技术与加密货币密切相关，在加密货币中作为财务账本使用，但区块链也可以用于其他目的。任何需要防篡改记录历史的系统都可以利用区块链。时间将证明比特币或其他加密货币是否能够在长期内成功，但无论如何，我们可能会看到区块链技术在其他新颖的方式中得到应用。
- en: '**Virtual Reality and Augmented Reality**'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**虚拟现实与增强现实**'
- en: Two technologies that have the potential to fundamentally change how we interact
    with computers are virtual reality (VR) and augmented reality (AR). *Virtual reality*
    is a form of computing that immerses a user in a three-dimensional virtual space,
    typically displayed by a headset. VR allows the user to interface with virtual
    objects via a variety of input methods, including the user’s gaze, voice commands,
    and specialized handheld controllers. In contrast, *augmented reality* overlays
    virtual elements onto the real world, either through a headset or by the user
    looking “through” a handheld portable device, like a smartphone or tablet. VR
    immerses the user in another world; AR alters the real world.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 两项有可能从根本上改变我们与计算机互动方式的技术是虚拟现实（VR）和增强现实（AR）。*虚拟现实*是一种将用户沉浸在三维虚拟空间中的计算形式，通常通过头显显示。虚拟现实允许用户通过多种输入方式与虚拟物体交互，包括用户的目光、语音命令以及专用的手持控制器。与此相反，*增强现实*通过头显或用户通过手持便携设备（如智能手机或平板）“透视”来将虚拟元素叠加到现实世界中。虚拟现实将用户沉浸在另一个世界中；增强现实则改变了现实世界。
- en: Although various attempts at VR have been made for several decades, it wasn’t
    until the 2010s that VR became more mainstream. Google helped popularize VR in
    2014 with *Google Cardboard*, named for the idea that a VR headset can be constructed
    from cardboard, lenses, and a smartphone. Specially-designed Cardboard apps present
    VR content to the user by rendering content for the left eye on half of the smartphone
    screen and content for the right eye on the other half of the screen, shown in
    [Figure 13-10](ch13.xhtml#ch13fig10).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管几十年来已经有各种虚拟现实尝试，但直到2010年代，虚拟现实才开始进入主流。2014年，Google通过*Google Cardboard*帮助普及了虚拟现实，Cardboard这个名字源于这样一个想法：虚拟现实头显可以由纸板、镜头和智能手机构成。专为Cardboard设计的应用通过在智能手机屏幕的左半部分渲染左眼内容、右半部分渲染右眼内容，向用户呈现虚拟现实内容，正如[图13-10](ch13.xhtml#ch13fig10)所示。
- en: '![image](../images/fig13-10.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig13-10.jpg)'
- en: '*Figure 13-10: An app designed for Google Cardboard presenting in VR mode*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-10：为Google Cardboard设计的应用以虚拟现实模式呈现*'
- en: Apps designed for Cardboard rely on the smartphone’s ability to detect gyroscopic
    movement, allowing the display to update as the user moves their head. Such a
    headset is said to have *3 degrees of freedom (3DoF)*; the headset can track limited
    head movement, but it cannot otherwise track movement in space. This allows a
    user to *look* around, but not *move* around using the headset. Cardboard also
    supports a basic one-button input. Cardboard is simple, but effective. It introduced
    VR to many users who probably wouldn’t have tried it otherwise.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为Cardboard设计的应用依赖于智能手机的陀螺仪检测能力，使得显示屏可以随着用户头部的移动而更新。这样的头显被称为具有*3自由度（3DoF）*；头显能够追踪有限的头部运动，但无法追踪其他空间中的运动。这使得用户可以*环顾四周*，但不能使用头显*移动*。Cardboard还支持基本的单按钮输入。Cardboard简单但有效，它让许多可能不会尝试虚拟现实的用户第一次体验到了虚拟现实。
- en: A more immersive experience requires *6 degrees of freedom (6DoF)*; where the
    user can move around in VR by physically moving their body in real space. Some
    VR headsets support 6DoF, and VR controllers can have either 3DoF or 6DoF. A 6DoF
    controller, held in the user’s hand, can track the position of the controller
    in VR space, allowing for more natural interactions with the VR environment.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 更具沉浸感的体验需要*6自由度（6DoF）*；用户可以通过在现实空间中身体的物理移动来在虚拟现实中自由移动。一些虚拟现实头显支持6DoF，而虚拟现实控制器则可能是3DoF或6DoF。6DoF控制器由用户手持，可以追踪控制器在虚拟现实空间中的位置，从而实现与虚拟环境的更自然互动。
- en: The consumer market has seen a number of VR solutions released since Google
    Cardboard. Some rely on smartphones (Samsung Gear VR, Google Daydream). Others
    use a personal computer for processing, with a connected VR headset and controllers
    (Oculus Rift, HTC Vive, Windows Mixed Reality). Still others are standalone devices,
    not requiring a smartphone or PC (Oculus Go, Oculus Quest, Lenovo Mirage Solo).
    In general, the PC-connected solutions provide the highest graphical fidelity,
    and are also the most expensive, particularly when considering the cost of the
    required computer.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 自Google Cardboard发布以来，消费市场出现了多种虚拟现实解决方案。一些依赖于智能手机（如Samsung Gear VR、Google Daydream）。另一些则使用个人计算机进行处理，通过连接的虚拟现实头显和控制器（如Oculus
    Rift、HTC Vive、Windows Mixed Reality）。还有一些是独立设备，无需智能手机或个人计算机（如Oculus Go、Oculus
    Quest、Lenovo Mirage Solo）。通常，连接PC的解决方案提供最高的图形保真度，同时也是最昂贵的，特别是在考虑到所需计算机的成本时。
- en: As mentioned earlier, augmented reality, or AR, is a similar but distinct technology.
    While VR attempts to completely immerse the user in a virtual world, AR overlays
    virtual elements onto the real world. This can be accomplished using a mobile
    device, where a rear-facing camera is used to observe the real world while simulated
    elements are overlaid on what is seen by the camera. Advanced AR techniques allow
    software to understand the physical elements in a room so that overlaid virtual
    elements can interact seamlessly with the environment. AR is implemented in basic
    form in mobile apps, but it’s more fully realized in dedicated devices such as
    Google Glass, Magic Leap’s headset, and Microsoft HoloLens. Such AR devices are
    worn on the head and superimpose computer generated graphics on a user’s field
    of view. Users are able to interact with virtual elements using various methods,
    such as voice commands or hand tracking.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，增强现实（AR）是一种类似但不同的技术。虚拟现实试图让用户完全沉浸在虚拟世界中，而增强现实则是在现实世界上叠加虚拟元素。这可以通过移动设备实现，移动设备的后置摄像头用于观察现实世界，同时将虚拟元素叠加在摄像头所看到的画面上。先进的AR技术可以使软件理解房间中的物理元素，从而使叠加的虚拟元素能够与环境无缝互动。增强现实以基本形式在移动应用中实现，但在像Google
    Glass、Magic Leap头戴设备和微软HoloLens这样的专用设备中得到了更充分的应用。这些AR设备佩戴在头部，将计算机生成的图形叠加在用户的视野中。用户可以通过语音命令或手部追踪等多种方式与虚拟元素进行互动。
- en: The various VR and AR technologies (referred to together as *XR*) present multiple
    platforms for software developers to target. Many VR developers rely on existing
    game engines that are typically used for building 3D games, such as the Unity
    game engine or the Unreal game engine. These engines are familiar to game developers
    already, and they make it relatively easy for the developers to build their software
    for multiple VR platforms. Web developers can develop VR and AR content using
    JavaScript APIs known as *WebVR* and *WebXR*. Of the two, WebVR came first and
    was focused on VR specifically. WebXR followed, with support for both AR and VR.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 各种虚拟现实（VR）和增强现实（AR）技术（统称为*XR*）为软件开发人员提供了多个目标平台。许多VR开发者依赖于现有的游戏引擎，这些引擎通常用于构建3D游戏，比如Unity游戏引擎或Unreal游戏引擎。这些引擎对游戏开发者来说已经很熟悉，并且使得开发者能够相对轻松地为多个VR平台构建他们的软件。Web开发者可以使用被称为*WebVR*和*WebXR*的JavaScript
    API来开发VR和AR内容。二者中，WebVR首先出现，并专注于VR；而WebXR则紧随其后，支持AR和VR。
- en: '**The Internet of Things**'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**物联网**'
- en: Traditionally we think of servers as providing services on the internet, and
    users interacting with those servers via internet-connected personal computing
    devices, such as PCs, laptops, and smartphones. In recent years we’ve seen the
    growth of new types of devices connecting to the internet—speakers, televisions,
    thermostats, doorbells, cars, lightbulbs, you name it! This concept of connecting
    all kinds of devices to the internet is known as the *Internet of Things (IoT)*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，我们认为服务器提供互联网上的服务，用户通过互联网连接的个人计算设备，如PC、笔记本电脑和智能手机，与这些服务器进行交互。近年来，我们看到了更多新型设备连接到互联网——扬声器、电视、恒温器、门铃、汽车、灯泡，等等！这种将各种设备连接到互联网的概念被称为*物联网（IoT）*。
- en: Costs and physical size of electronic components are decreasing, Wi-Fi and cellular
    internet access are widespread, and consumers expect their devices to be “smarter.”
    All of this has contributed to the trend of connecting everything to the internet.
    IoT devices typically don’t operate without some kind of web service supporting
    them, so the rise of cloud computing has also furthered the spread of the Internet
    of Things. For consumers, IoT devices are prominent in the “smart home,” where
    all types of home appliances can be monitored and controlled. In business, IoT
    devices can be found in manufacturing, healthcare, transportation, and more.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 电子元件的成本和物理尺寸在减少，Wi-Fi和蜂窝网络的互联网接入也已普及，消费者期待他们的设备“更智能”。所有这些因素共同推动了将一切连接到互联网的趋势。物联网设备通常离不开某种支持它们的网络服务，因此，云计算的兴起也促进了物联网的传播。对于消费者来说，物联网设备在“智能家居”中尤为突出，其中各种家电可以被监控和控制。在商业领域，物联网设备可以在制造、医疗保健、交通等多个领域找到。
- en: Although these types of connected devices bring clear benefits, these devices
    also introduce risks. Security of such devices is a particular area of concern.
    Not every IoT device is well secured against attacks from malicious parties. Even
    if the data on the device isn’t of interest to an attacker, the device can act
    as a foothold in an otherwise well-defended network, or it can be used as a launch
    point for a remote attack against a different target. Particularly for consumers,
    an IoT device seems innocuous enough, and security concerns often aren’t top of
    mind when connecting such a device to a home network.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些类型的联网设备带来了明显的好处，但它们也引入了风险。此类设备的安全性是一个特别需要关注的问题。并不是每个物联网设备都能很好地防御恶意攻击。即使设备上的数据对攻击者没有兴趣，设备也可能成为进入本来防守严密的网络的突破口，或者被用作对其他目标进行远程攻击的发起点。尤其是对于消费者来说，物联网设备看起来足够无害，在将其连接到家庭网络时，安全问题往往不会成为优先考虑的事项。
- en: Privacy is another risk presented by IoT devices. Many of these devices, by
    their nature, collect data. That data is often sent to a cloud service for processing.
    How much should end users trust the organizations that operate these services
    with their personal data? Even a well-intentioned organization can be a victim
    of a data breach, and user data may be exposed in unexpected ways. Devices like
    smart speakers must be listening all the time, waiting for verbal commands. This
    presents a risk of accidental recording of private conversations. Modern day readers
    of George Orwell’s novel *1984* may find a certain irony in seeing consumers of
    today willingly trading privacy for convenience.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 隐私是物联网设备带来的另一个风险。许多这类设备由于其性质，会收集数据。这些数据通常会被发送到云服务进行处理。最终用户应该如何信任这些运营服务的组织处理他们的个人数据呢？即使是一个有良好意图的组织，也可能成为数据泄露的受害者，用户数据可能以意想不到的方式暴露。像智能音响这样的设备必须随时监听，等待语音命令。这带来了意外录音私密对话的风险。现代读者阅读乔治·奥威尔的小说*1984*时，可能会发现，当今的消费者自愿为了便利而交换隐私，具有一定的讽刺意味。
- en: Another risk with IoT devices is that their full functionality often depends
    on a cloud service. If a device’s internet connection goes down, that device may
    temporarily become less useful. A greater concern is that a device’s manufacturer
    will likely someday permanently turn off the service that supports the device.
    At that point, the smart device will revert to a dumb device!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网设备的另一个风险是，它们的完整功能通常依赖于云服务。如果设备的互联网连接中断，该设备可能会暂时变得不那么有用。更大的担忧是，设备的制造商可能在某一天永久关闭支持该设备的服务。到那时，智能设备将变回“傻”设备！
- en: '**NOTE**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #41](ch13.xhtml#proj41) on [page 311](ch13.xhtml#page_311),
    where you can use what you’ve learned about hardware, software, and the web to
    build a network-connected “vending machine” IoT device*.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参考[项目 #41](ch13.xhtml#proj41)在[第311页](ch13.xhtml#page_311)，在这里你可以运用你学到的硬件、软件和网络知识，构建一个联网的“自动售货机”物联网设备*。'
- en: '**Summary**'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter we covered a variety of topics related to modern computing.
    You learned about apps, both native and web-based. You explored how virtualization
    and emulation allow computers to run software on virtualized hardware. You saw
    how cloud computing provides new platforms for running software. You learned how
    the surface web, deep web, and dark web differ, and how cryptocurrencies like
    Bitcoin enable decentralized payment systems. We touched on virtual reality and
    augmented reality and how they enable unique user interfaces for computing. You
    learned about IoT, and had an opportunity to build an internet-connected “vending
    machine.”
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了与现代计算相关的各种话题。你了解了应用程序，包括本地应用和基于网络的应用。你探索了虚拟化和仿真如何使计算机能够在虚拟化硬件上运行软件。你看到了云计算如何为软件运行提供新的平台。你了解了表面网络、深网和暗网的区别，以及像比特币这样的加密货币如何实现去中心化支付系统。我们简要介绍了虚拟现实和增强现实，以及它们如何为计算提供独特的用户界面。你学习了物联网，并有机会构建一个联网的“自动售货机”。
- en: 'As we near the end of this book, let’s review some major computing concepts
    and see how they fit together. Computers are binary digital devices, where everything
    is represented as a 0 or 1, on or off. Binary logic, also known as Boolean logic,
    provides the foundation for computing operations. Computers are implemented using
    digital electrical circuits where voltage levels represent binary states—a low
    voltage is 0, and a high voltage is 1\. Digital logic gates are transistor-based
    circuits that enable Boolean operations such as AND and OR. Such logic gates can
    be arranged to create more complex circuits, such as counters, memory devices,
    and addition circuits. These types of circuits provide a conceptual foundation
    for computer hardware: a central processing unit (CPU) that executes instructions,
    random access memory (RAM) that stores instructions and data while powered, and
    input/output (I/O) devices that interact with the outside world.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们接近本书的结尾时，让我们回顾一些主要的计算机概念，并看看它们是如何相互关联的。计算机是二进制数字设备，所有事物都以0或1、开或关的形式表示。二进制逻辑，也称为布尔逻辑，为计算操作提供了基础。计算机通过使用数字电路来实现，其中电压水平代表二进制状态——低电压表示0，高电压表示1。数字逻辑门是基于晶体管的电路，能够执行布尔操作，如AND和OR。这样的逻辑门可以排列组合，创建更复杂的电路，如计数器、存储设备和加法电路。这些类型的电路为计算机硬件提供了概念基础：执行指令的中央处理单元（CPU）、在电源开启时存储指令和数据的随机存取内存（RAM）以及与外界交互的输入/输出（I/O）设备。
- en: Computers are programmable; they can perform new tasks without changing their
    hardware. Instructions that tell a computer what to do are known as software or
    code. CPUs execute machine code, whereas software developers typically write source
    code in a higher-level programming language. Computer programs typically run on
    an operating system—software that communicates with computer hardware and provides
    an environment for the execution of programs. Computers communicate using the
    internet, a globally connected set of computer networks that all use the TCP/IP
    protocol suite. A popular use of the internet is the World Wide Web, a set of
    distributed, addressable, linked resources, delivered by HTTP over the internet.
    All of these technologies provide an environment where modern computing innovations
    can flourish.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机是可编程的；它们可以在不更改硬件的情况下执行新的任务。指示计算机该做什么的指令被称为软件或代码。CPU执行机器码，而软件开发人员通常使用高级编程语言编写源代码。计算机程序通常运行在操作系统上——操作系统是与计算机硬件通信并为程序执行提供环境的软件。计算机通过互联网进行通信，互联网是一个全球互联的计算机网络集合，所有这些网络都使用TCP/IP协议套件。互联网的一个流行应用是万维网，它是一组分布式、可寻址、互联的资源，通过HTTP协议在互联网上传输。所有这些技术为现代计算创新提供了一个蓬勃发展的环境。
- en: I hope this book has given you a fuller understanding of how computers work.
    We covered a great deal of ground, and yet we only scratched the surface of most
    topics. If some particular area grabbed your attention, I’d encourage you to continue
    learning about that subject—read about it online, take a class, watch videos,
    or buy another book! There’s a wealth of knowledge about computing to be discovered.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望本书已经让你对计算机的工作原理有了更全面的了解。我们覆盖了大量内容，但大多数主题我们只是触及了皮毛。如果某个特定领域引起了你的兴趣，我鼓励你继续深入学习这个主题——在网上阅读相关资料，参加课程，观看视频，或购买另一本书！关于计算的知识有很多可以探索的地方。
- en: '**PROJECT #41: USE PYTHON TO CONTROL A VENDING MACHINE CIRCUIT**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #41：使用Python控制自动售货机电路**'
- en: 'Prerequisites: [Project #7](ch06.xhtml#proj7) (on [page 105](ch06.xhtml#page_105))
    and #8 (on [page 107](ch06.xhtml#page_107)) where you built a vending machine
    circuit. A Raspberry Pi, running Raspberry Pi OS. I recommend that you flip to
    [Appendix B](appb.xhtml) and read the entire “Raspberry Pi” section on [page 341](appb.xhtml#page_341)
    if you haven’t already.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '先决条件：[项目 #7](ch06.xhtml#proj7)（见[第105页](ch06.xhtml#page_105)）和#8（见[第107页](ch06.xhtml#page_107)），在这些项目中，你构建了一个自动售货机电路。你需要一台运行Raspberry
    Pi OS的树莓派。如果你还没有这样做，我建议你翻到[附录B](appb.xhtml)，阅读[第341页](appb.xhtml#page_341)上的“树莓派”部分。'
- en: In this project, you’ll use what you’ve learned about hardware, software, and
    the web to build a network-connected “vending machine” IoT device. Back in [Chapter
    6](ch06.xhtml) you built a vending machine circuit using push buttons, an LED,
    and digital logic gates. For this project, you’ll update that device. You’ll keep
    the buttons and LED, but you’ll replace the logic gates with Python code running
    on a Raspberry Pi. This will allow you to add capabilities in software easily,
    such as the ability to connect to the device over the network.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将利用你所学到的硬件、软件和网络知识，构建一个网络连接的“自动售货机”物联网设备。在[第6章](ch06.xhtml)中，你使用按键、LED和数字逻辑门搭建了一个自动售货机电路。对于这个项目，你将更新该设备。你将保留按钮和LED，但用运行在Raspberry
    Pi上的Python代码替换逻辑门。这将使你能够轻松地通过软件添加功能，例如能够通过网络连接到设备。
- en: 'For this project, you’ll need the following components:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你将需要以下组件：
- en: Breadboard
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板
- en: LED
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED
- en: Current-limiting resistor to use with your LED; approximately 220Ω
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于LED的限流电阻；大约220Ω
- en: Two switches or pushbuttons that fit a breadboard
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个适合面包板的开关或按钮
- en: Jumper wires, including 4 male-to-female wires
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线，包括4根公对母跳线
- en: Raspberry Pi
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi
- en: '***GPIO***'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '***GPIO***'
- en: Besides its tiny size and low cost, the Raspberry Pi has another feature that
    sets it apart from a typical computer—its GPIO pins. Each *general-purpose input/output
    (GPIO)* pin can be designated as an electrical input or output. When a pin acts
    as an input, code running on the Raspberry Pi can read the pin as high at 3.3V,
    or as low at 0V. The Raspberry Pi even has internal pull-up and pull-down resistors,
    enabled through software, so you no longer have to add such resistors to your
    input buttons. When a pin acts as an output, it can be set to high (3.3V) or low
    (0V), all controlled through software. Some pins are always set to ground, 5V,
    or 3.3V. The pins are referenced in software by number. [Figure 13-11](ch13.xhtml#ch13fig11)
    shows the GPIO pin designations.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其小巧的尺寸和低廉的成本，Raspberry Pi还有一个特点，使其与普通计算机区别开来——那就是它的GPIO引脚。每个*通用输入/输出（GPIO）*引脚可以指定为电气输入或输出。当引脚作为输入时，运行在Raspberry
    Pi上的代码可以将其读取为高电平3.3V或低电平0V。Raspberry Pi甚至内置了上拉和下拉电阻，通过软件启用，因此你不再需要为输入按钮额外添加这些电阻。当引脚作为输出时，它可以设置为高电平（3.3V）或低电平（0V），这一切都可以通过软件控制。某些引脚始终设置为接地、5V或3.3V。这些引脚在软件中通过编号引用。[图13-11](ch13.xhtml#ch13fig11)显示了GPIO引脚的指定。
- en: As you can see in [Figure 13-11](ch13.xhtml#ch13fig11), the GPIO numbers don’t
    correspond to the pin numbers. The pins, shown in the gray box, are simply numbered
    1 through 40, starting in the upper left and ending in the lower right. For example,
    the second pin down on the left side is GPIO 2 and pin number 3\. When you reference
    these GPIO pins in code, you need to use the GPIO number rather than the pin number.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在[图13-11](ch13.xhtml#ch13fig11)中，GPIO编号与引脚编号并不对应。引脚，如灰色框中的显示，从1到40按顺序编号，从左上角开始，右下角结束。例如，左侧第二个引脚是GPIO
    2，而引脚编号是3。在代码中引用这些GPIO引脚时，你需要使用GPIO编号，而不是引脚编号。
- en: '![image](../images/fig13-11.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig13-11.jpg)'
- en: '*Figure 13-11: Raspberry Pi GPIO pins*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-11：Raspberry Pi GPIO引脚*'
- en: '***BUILD THE CIRCUIT***'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '***搭建电路***'
- en: Before writing any code, connect your circuit components to a breadboard and
    to the Raspberry Pi GPIO pins as shown in [Figure 13-12](ch13.xhtml#ch13fig12).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何代码之前，请按照[图13-12](ch13.xhtml#ch13fig12)所示，将电路组件连接到面包板和Raspberry Pi的GPIO引脚。
- en: '![image](../images/fig13-12.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig13-12.jpg)'
- en: '*Figure 13-12: Raspberry Pi vending machine circuit diagram*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-12：Raspberry Pi自动售货机电路图*'
- en: I’d recommend powering off your Raspberry Pi before connecting anything to the
    GPIO pins. For the connections between the GPIO pins and the breadboard, use a
    male-to-female jumper wire. You can connect the female end of the wire to the
    GPIO pin, and the male end of the wire to the breadboard.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在连接任何东西到GPIO引脚之前，先关闭你的Raspberry Pi。对于GPIO引脚和面包板之间的连接，使用公对母跳线。你可以将跳线的母头连接到GPIO引脚，公头连接到面包板。
- en: If you use the pin numbers shown in [Figure 13-12](ch13.xhtml#ch13fig12), the
    VEND LED, VEND button, and COIN button are connected to three consecutive GPIO
    pins on the Raspberry Pi. You also need to connect one of the GND pins (I’d recommend
    pin 9) to the breadboard’s negative power column, so you can easily connect the
    buttons and LED to ground.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用[图13-12](ch13.xhtml#ch13fig12)中显示的引脚编号，VEND LED、VEND按钮和COIN按钮会连接到Raspberry
    Pi上连续的三个GPIO引脚。你还需要将其中一个GND引脚（我建议使用引脚9）连接到面包板的负电源列，这样你就可以轻松将按钮和LED连接到地。
- en: 'You may have noticed that this circuit’s input switches are wired differently
    from the switches you used in [Project #7](ch06.xhtml#proj7) (on [page 105](ch06.xhtml#page_105))
    and #8 (on [page 107](ch06.xhtml#page_107)). In those projects, you connected
    a switch to 5V on one side and to a pull-down resistor/input pin on the other
    side. The circuit was designed so that an open switch was expected to be a low
    voltage, whereas a closed switch was expected to be a high voltage. Here, things
    are just the opposite—a closed switch is low, and an open switch is high. Internally,
    the Raspberry Pi pulls the GPIO pin high when the switch is open (or nothing is
    connected).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这个电路的输入开关与[第7项目](ch06.xhtml#proj7)（[第105页](ch06.xhtml#page_105)）和第8项目（[第107页](ch06.xhtml#page_107)）中使用的开关接线方式不同。在这些项目中，你将开关的一侧连接到5V，另一侧连接到下拉电阻/输入引脚。电路的设计是预期开关打开时为低电压，而关闭时为高电压。而在这里，情况正好相反——开关关闭时为低电压，打开时为高电压。从内部来看，当开关打开（或没有连接任何东西）时，树莓派将GPIO引脚拉高。
- en: '[Figure 13-13](ch13.xhtml#ch13fig13) shows this circuit built on a breadboard.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-13](ch13.xhtml#ch13fig13)展示了在面包板上搭建的这个电路。'
- en: '![image](../images/fig13-13.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig13-13.jpg)'
- en: '*Figure 13-13: Raspberry Pi vending machine circuit on a breadboard*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-13：在面包板上搭建的树莓派自动售货机电路*'
- en: Once your circuit is connected and you have verified your connections, power
    on your Raspberry Pi. You may see the LED turn on, and that’s fine, since you
    haven’t run any code yet to set the LED to a particular state.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的电路连接好并且你验证了连接，开启树莓派的电源。你可能会看到LED亮起，这没关系，因为你还没有运行任何代码来设置LED的状态。
- en: '***TEST YOUR CIRCUIT***'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '***测试你的电路***'
- en: Before entering the vending machine code, let’s write a simple program to test
    that the circuit is properly connected and to give you a feel for working with
    GPIO in Python. For interacting with the GPIO pins, we’re going to use *GPIO Zero*,
    a Python library that makes it easy to work with physical devices such as buttons
    and LEDs. Use the text editor of your choice to create a new file named *gpiotest.py*
    in the root of your home folder. Enter the following Python code into your text
    editor. Indentation matters in Python, so make sure you indent appropriately.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入自动售货机代码之前，我们先写一个简单的程序来测试电路是否正确连接，并让你熟悉在Python中使用GPIO的操作。为了与GPIO引脚进行交互，我们将使用*GPIO
    Zero*，这是一个Python库，可以轻松与按钮、LED等物理设备进行交互。使用你喜欢的文本编辑器，在主目录下创建一个名为*gpiotest.py*的新文件。在文本编辑器中输入以下Python代码。Python中缩进非常重要，请确保正确缩进。
- en: '[PRE0]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This simple program imports the `sleep` function ❶ and the `LED` and `Button`
    classes from the GPIO Zero library ❷. It then creates a variable named `button`
    that represents the physical button on GPIO 3 ❸. Similarly, an `led` variable
    is created to represent the LED connected to GPIO 2 ❹. The program then enters
    an infinite loop ❺ that turns the LED off, waits for the button to be pressed,
    and then turns the LED on for one second before going through the loop again.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的程序导入了`sleep`函数❶和来自GPIO Zero库的`LED`和`Button`类❷。然后，它创建一个名为`button`的变量，代表GPIO
    3上的物理按钮❸。类似地，创建了一个`led`变量，代表连接到GPIO 2的LED❹。程序随后进入一个无限循环❺，在该循环中，LED先熄灭，等待按钮被按下，然后亮起一秒钟后再次进入循环。
- en: 'Once the file is saved, you can run it using the Python interpreter like so:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件保存，你可以通过Python解释器运行它，如下所示：
- en: '[PRE1]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you start the program, nothing should happen at first, except perhaps the
    LED may turn off if it was previously on. If you press the button connected to
    GPIO 3, the LED should turn on for one second, and then turn off. You can repeat
    this as long as the program is running.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动程序时，最初应该不会发生任何事情，除了如果LED之前是亮的，可能会熄灭。如果你按下连接到GPIO 3的按钮，LED应该会亮起一秒钟，然后熄灭。只要程序在运行，你可以重复这个操作。
- en: Our simple program didn’t include any graceful way to exit, so to end the program,
    press CTRL-C on the keyboard. When you exit the program in this way, the Python
    interpreter shows you a “Traceback” of the recent function calls—this is normal.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的简单程序没有包含任何优雅的退出方式，因此要结束程序，请按下键盘上的CTRL-C。当你以这种方式退出程序时，Python解释器会显示“追溯”（Traceback）最近的函数调用——这是正常现象。
- en: If the program doesn’t work as expected, double-check the code you entered and
    review “[Troubleshooting Circuits](appb.xhtml#lev1_105)” on [page 340](appb.xhtml#page_340).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序没有按预期工作，请仔细检查你输入的代码，并查看[《电路故障排除》](appb.xhtml#lev1_105)在[第340页](appb.xhtml#page_340)的内容。
- en: '***A VENDING MACHINE PROGRAM***'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '***一个自动售货机程序***'
- en: 'In [Project #7](ch06.xhtml#proj7) (on [page 105](ch06.xhtml#page_105)) and
    #8 (on [page 107](ch06.xhtml#page_107)), the vending machine’s logic was controlled
    by an SR latch, an AND gate, and a capacitor. You can now replace all of that
    with a program on the Raspberry Pi. This new design also gets rid of the COIN
    LED. Previously, the COIN LED turned on if a coin had been inserted. With this
    new design, the program instead prints the count of coin credits. Each time a
    coin is inserted, the credit count should go up one, and each time a vend operation
    occurs the credit count should go down by one.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '在 [项目 #7](ch06.xhtml#proj7)（见 [第 105 页](ch06.xhtml#page_105)）和 #8（见 [第 107
    页](ch06.xhtml#page_107)）中，自动售货机的逻辑由 SR 锁存器、与门和电容器控制。现在，你可以用 Raspberry Pi 上的程序来替代这一切。这种新设计还去除了
    COIN LED。之前，如果投入了硬币，COIN LED 会亮起。在新的设计中，程序会打印硬币积分数。每次投入硬币时，积分数应该增加 1，每次发生售货操作时，积分数应该减少
    1。'
- en: 'The requirements for this device are the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 该设备的要求如下：
- en: Pressing the COIN button increases the credit count by one.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下 COIN 按钮会使积分数增加 1。
- en: Pressing the VEND button simulates vending an item. If the credit count is greater
    than 0, the VEND LED briefly turns on and the credit count decreases by one. If
    the credit count is 0, nothing happens when the VEND button is pressed.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下 VEND 按钮模拟售货操作。如果积分数大于 0，VEND LED 会短暂亮起，积分数减少 1。如果积分数为 0，按下 VEND 按钮时不会发生任何事情。
- en: Every actionable button press, whether COIN or VEND, causes the program to print
    the current number of credits.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次按下可操作的按钮，无论是 COIN 还是 VEND，都会导致程序打印当前的积分数。
- en: 'Use the text editor of your choice to create a new file named *vending.py*
    in the root of your home folder. Enter the following Python code into your text
    editor:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你选择的文本编辑器，在你的主文件夹根目录下创建一个名为 *vending.py* 的新文件。将以下 Python 代码输入到文本编辑器中：
- en: '[PRE2]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, the code imports the `sleep` function, `LED` class, and `Button` class
    ❶, all of which are used later in the program. Next, three variables are declared
    that represent the physical components attached to GPIO pins—`vend_led` on GPIO
    2, `vend_button` on GPIO 3, and `coin_button` on GPIO 4 ❷. The variable `coin_count`
    is declared to track the number of times the COIN button has been pressed, and
    the variable `vend_count` tracks the number of times that a vending operation
    has occurred ❸. These two variables are used to calculate the number of credits.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码导入了 `sleep` 函数、`LED` 类和 `Button` 类 ❶，这些将在程序中后续使用。接下来，声明了三个变量，代表连接到 GPIO
    引脚的物理组件——`vend_led` 连接到 GPIO 2，`vend_button` 连接到 GPIO 3，`coin_button` 连接到 GPIO
    4 ❷。声明了变量 `coin_count` 用于跟踪按下 COIN 按钮的次数，变量 `vend_count` 用于跟踪发生了多少次自动售货操作 ❸。这两个变量用于计算积分数。
- en: The `print_credits` function ❹ prints the number of available credits, which
    is simply the difference between `coin_count` and `vend_count`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_credits` 函数 ❹ 打印可用积分数，计算方法是 `coin_count` 和 `vend_count` 之间的差值。'
- en: The `coin_button_pressed` function ❺ is the code that runs when the COIN button
    is pressed. It increments `coin_count` and prints the number of credits. The `global
    coin_count` statement allows the global variable `coin_count` to be modified within
    the `coin_button_pressed` function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`coin_button_pressed` 函数 ❺ 是当按下 COIN 按钮时运行的代码。它增加 `coin_count` 并打印当前的积分数。`global
    coin_count` 语句允许在 `coin_button_pressed` 函数中修改全局变量 `coin_count`。'
- en: The `vend_button_pressed` function ❻ is the code that runs when the VEND button
    is pressed. If there are credits remaining (`coin_count > vend_count`), then the
    function increments `vend_count`, prints the number of credits, and turns the
    LED on for 0.3 seconds.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`vend_button_pressed` 函数 ❻ 是当按下 VEND 按钮时运行的代码。如果还有积分剩余（`coin_count > vend_count`），则该函数增加
    `vend_count`，打印当前的积分数，并让 LED 灯亮起 0.3 秒。'
- en: Setting `coin_button.when_pressed = coin_button_pressed` ❼ associates the `coin_button_pressed`
    function with `coin_button` on GPIO 4 so that the function runs when the button
    is pressed. Similarly, `vend_button_pressed` is associated with `vend_button`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `coin_button.when_pressed = coin_button_pressed` ❼ 将 `coin_button_pressed`
    函数与 GPIO 4 上的 `coin_button` 关联，以便在按下按钮时运行该函数。类似地，`vend_button_pressed` 与 `vend_button`
    关联。
- en: Finally, we call the `input` function ❽. This function prints a message to the
    screen and waits for the user to press the ENTER key. This is a simple way to
    the keep the program running. Without this line of code, the program would reach
    its end and stop running before the user had a chance to interact with the buttons.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`input`函数❽。这个函数会在屏幕上打印一条消息，并等待用户按下ENTER键。这是一种保持程序运行的简单方法。如果没有这一行代码，程序会在用户有机会与按钮交互之前就结束并停止运行。
- en: 'Once the file is saved, you can run it using the Python interpreter like so:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 文件保存后，你可以像这样使用Python解释器运行它：
- en: '[PRE3]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When you start the program, you should immediately see `Press Enter to exit
    the program` displayed to the terminal window. At this point try pressing the
    COIN button, which is connected to GPIO 4\. You should see the program print `Credits:
    1`. Next try pressing the VEND button. The LED should briefly light up, and the
    program should print `Credits: 0`. Try pressing the VEND button again—nothing
    should happen. Try pressing COIN and VEND multiple times and make sure the program
    works as expected. When you’re finished testing the program, press ENTER to end
    the program.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '当你启动程序时，你应该立即看到`Press Enter to exit the program`显示在终端窗口上。这时尝试按下连接到GPIO 4的COIN按钮。你应该看到程序打印出`Credits:
    1`。接下来，尝试按下VEND按钮。LED应该会短暂点亮，程序应打印出`Credits: 0`。再按一次VEND按钮——应该什么也不会发生。多次按下COIN和VEND按钮，确保程序按预期工作。当你完成测试时，按下ENTER键结束程序。'
- en: As you can see, a Raspberry Pi, or similar device, can replicate in software
    the same logic that we previously implemented in hardware. However, a software-based
    solution is much easier to modify. New features can be added by changing a few
    lines of code rather than adding new chips and wiring. A Raspberry Pi is actually
    overkill for what we wanted to do here; the same thing could be accomplished with
    a less capable computing device at even lower cost, but the principle is the same.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一台树莓派或类似的设备，可以在软件中复制我们之前在硬件中实现的相同逻辑。然而，基于软件的解决方案更容易修改。可以通过改变几行代码来添加新功能，而不是添加新的芯片和布线。对于我们在这里想要做的事情来说，树莓派实际上有点“杀鸡用牛刀”；同样的事情可以通过一个更不强大的计算设备以更低的成本完成，但原理是一样的。
- en: '***AN IOT VENDING MACHINE***'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '***一个物联网自动售货机***'
- en: Let’s say that the operator of the vending machine wants to be able to check
    the machine’s status remotely, over the internet. Since you’re using a Raspberry
    Pi for your vending machine’s logic, you can take things a step further and make
    this an IoT vending machine! You can add a simple web server to the program, allowing
    someone to connect to the device’s IP address from a web browser and see how many
    times a coin has been inserted and how many times a vending operation occurred.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 假设自动售货机的操作员希望能够通过互联网远程检查机器的状态。由于你使用的是树莓派来处理自动售货机的逻辑，你可以更进一步，让它成为一台物联网自动售货机！你可以在程序中添加一个简单的Web服务器，使得有人可以通过Web浏览器连接到设备的IP地址，并查看已插入硬币的次数以及发生了多少次售货操作。
- en: Python makes this relatively easy, because it includes a simple web server library,
    `http.server`. You just need to construct some HTML that includes the data you
    want to send and write a handler for incoming `GET` requests. You also need to
    start the web server when the program begins.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Python使这变得相对简单，因为它包含了一个简单的Web服务器库`http.server`。你只需要构建一些包含你要发送的数据的HTML，并为传入的`GET`请求编写一个处理程序。你还需要在程序启动时启动Web服务器。
- en: 'Use the text editor of your choice to edit your existing *vending.py* file
    in the root of your home folder. Start by inserting the following import statement
    as the first line of the file (leaving all the existing code intact, just shifted
    down a line):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你选择的文本编辑器编辑你家目录根目录下现有的*vending.py*文件。首先在文件的第一行插入以下导入语句（保持现有代码不变，只是向下移一行）：
- en: '[PRE4]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, remove the entire `input` line at the bottom of the file and add this
    code to the end of the file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，删除文件底部的整个`input`行，并将以下代码添加到文件末尾：
- en: '[PRE5]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`HTML_CONTENT` is a multiline string that defines the HTML code that the program
    sends over the network. This block of HTML code represents a simple web page with
    a `<title>`, a `<h1>` heading, and two `<p>` paragraphs that describe the state
    of the vending machine. Specific values in these paragraphs are represented as
    placeholders `{0}` and `{1}`. These values are filled in by the program when it
    runs. Since this is HTML, the spacing and line breaks within this string don’t
    matter.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTML_CONTENT` 是一个多行字符串，定义了程序通过网络发送的HTML代码。该HTML代码块表示一个简单的网页，包含一个 `<title>`、一个
    `<h1>` 标题和两个描述自动售货机状态的 `<p>` 段落。这些段落中的具体值由占位符 `{0}` 和 `{1}` 表示。这些值将在程序运行时由程序填充。由于这是HTML，字符串中的空格和换行不重要。'
- en: 'The `WebHandler` class ❶ describes how the web server handles incoming HTTP
    requests. It inherits from the `BaseHTTPRequestHandler` class, meaning that it
    has the same methods and fields as `BaseHTTPRequestHandler`. However, this just
    gives you a generic HTTP request handler; you still need to specify how your program
    will respond to specific HTTP requests. In this case, the program only needs to
    respond to HTTP `GET` requests, so the code defines the `do_GET` method ❷. This
    method is invoked when a `GET` request comes to the server, and it replies with
    the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebHandler` 类 ❶ 描述了网页服务器如何处理传入的HTTP请求。它继承自 `BaseHTTPRequestHandler` 类，这意味着它拥有与
    `BaseHTTPRequestHandler` 相同的方法和字段。然而，这仅提供了一个通用的HTTP请求处理器；你仍然需要指定程序如何响应特定的HTTP请求。在这种情况下，程序只需要响应HTTP
    `GET` 请求，因此代码定义了 `do_GET` 方法 ❷。当收到一个 `GET` 请求时，会调用该方法，并以以下内容进行回复：'
- en: A `200` status code indicating success ❸
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200` 状态码，表示成功 ❸'
- en: 'A `Content-type: text/html` header that tells the browser to expect the response
    to be HTML ❹'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-type: text/html` 头部，告诉浏览器期望响应为HTML ❹'
- en: The HTML string that was defined earlier, but with the two placeholders replaced
    by the values of `coin_count` and `vend_count` ❺
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先前定义的HTML字符串，但两个占位符已被 `coin_count` 和 `vend_count` 的值替换 ❺
- en: A web server instance is created using the `HTTPServer` class ❻. Here you specify
    that the server name can be anything and that the HTTP server listens on port
    8080 `('', 8080)`. This is also where you specify to use the `WebHandler` class
    for inbound HTTP requests.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `HTTPServer` 类 ❻ 创建一个网页服务器实例。在这里，你指定服务器名称可以是任何内容，并且HTTP服务器监听8080端口 `('',
    8080)`。在此处，你还指定了使用 `WebHandler` 类来处理传入的HTTP请求。
- en: The web server starts with `server.serve_forever()` ❽. This is placed in a `try/except/finally`
    block ❼ so that the server continues running until a `KeyboardInterrupt` exception
    occurs (generated by CTRL-C). When this happens, `server.server_close()` is called
    to clean up, and the program ends ❾.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 网页服务器通过 `server.serve_forever()` 启动 ❽。这被放置在一个 `try/except/finally` 块 ❼ 中，以便服务器可以持续运行直到发生
    `KeyboardInterrupt` 异常（由CTRL-C触发）。发生这种情况时，调用 `server.server_close()` 进行清理，然后程序结束
    ❾。
- en: 'Once the file is saved, you can run the file using the Python interpreter like
    so:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件保存完毕，你可以像这样使用Python解释器运行该文件：
- en: '[PRE6]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The program should behave as it did before when you press the COIN or VEND buttons.
    However, now you can also connect to the device from a web browser and see data
    about the vending machine. To do this, you need a device on the same local network
    as the Raspberry Pi, unless your Pi is directly connected to the internet with
    a public IP address, in which case any device on the internet should be able to
    connect to it. If you don’t have another device, you can launch a web browser
    on the Raspberry Pi itself and let the Raspberry Pi act as both the client and
    server.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在按下COIN或VEND按钮时应与之前的行为相同。然而，现在你还可以通过网页浏览器连接到设备，并查看有关自动售货机的数据。为此，你需要确保设备与树莓派在同一局域网内，除非你的树莓派直接连接到互联网并具有公共IP地址，在这种情况下，任何互联网设备都应能连接到它。如果没有其他设备，你可以在树莓派本身上启动网页浏览器，让树莓派同时充当客户端和服务器。
- en: 'You need to find the IP address of your Raspberry Pi. We did this in [Project
    #30](ch11.xhtml#proj30) on [page 255](ch11.xhtml#page_255) if you want to review
    the details, but this is the command you want to use:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要找到树莓派的IP地址。如果你想查看详细信息，我们在[项目#30](ch11.xhtml#proj30)中已经讲解过，位于[第255页](ch11.xhtml#page_255)，但你需要使用的命令是：
- en: '[PRE7]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once you have the IP address of your Raspberry Pi, open a web browser on the
    device you want to use as your client. In the address bar, enter the following:
    `http://IP:8080`, replacing `IP` with your Raspberry Pi’s IP address. The end
    result should look something like this: `http://192.168.1.41:8080`. Once you’ve
    entered this into the browser’s address bar, you should see the web page load
    with the count of coins and vending operations. Each time you request this page,
    you should see the Python program print information about the request to the terminal.
    Once the web page is loaded, it won’t automatically reload, so if you press the
    COIN or VEND buttons additional times and want to see the latest values, you need
    to refresh your browser’s view of the page. To stop this program, use CTRL-C on
    the keyboard.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道了树莓派的IP地址，在你想用作客户端的设备上打开一个网页浏览器。在地址栏中输入以下内容：`http://IP:8080`，将`IP`替换为树莓派的IP地址。最终结果应类似于：`http://192.168.1.41:8080`。当你将这个地址输入到浏览器的地址栏后，你应该看到网页加载，显示硬币数量和售货操作。每次你请求此页面时，应该能在终端看到Python程序打印有关请求的信息。一旦网页加载完成，它不会自动重新加载，因此如果你多次按下COIN或VEND按钮并希望查看最新的数值，你需要刷新浏览器中的页面视图。要停止此程序，可以使用键盘上的CTRL-C。
- en: Recall from [Chapter 12](ch12.xhtml) that websites are either static or dynamic.
    The site you ran in the [Chapter 12](ch12.xhtml) projects was static—it served
    content that was built ahead of time. In contrast, the vending machine site in
    this chapter is dynamic. It generates an HTML response when a request comes in.
    Specifically, it updates the coin and vending values in the HTML content before
    responding.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第12章](ch12.xhtml)，网站可以是静态的或动态的。你在[第12章](ch12.xhtml)项目中运行的网站是静态的——它提供了预先构建好的内容。与此不同，本章中的售货机网站是动态的。它在收到请求时生成HTML响应。具体来说，它会在响应之前更新HTML内容中的硬币和售货机数值。
- en: As a bonus challenge, try modifying the program to also display the “credits”
    value on the web page. This value should match the last credits value that was
    printed to the terminal.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个额外的挑战，尝试修改程序，使其也在网页上显示“积分”值。这个值应该与上次打印到终端的积分值相匹配。
