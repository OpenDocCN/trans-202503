- en: '8'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: AUTOMATING CUCKOO SANDBOX
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化 Cuckoo Sandbox
- en: '![](images/00010.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00010.jpg)'
- en: Cuckoo Sandbox is an open source project that allows you to run malware samples
    within the safety of virtual machines, and then analyze and report on how the
    malware behaved in a virtual sandbox without the threat of the malware infecting
    your real machine. Written in Python, Cuckoo Sandbox also offers a REST API that
    allows a programmer using any language to fully automate many of Cuckoo’s features,
    such as spinning up sandboxes, running malware, and grabbing reports. In this
    chapter, we’ll do all of this with easy-to-use C# libraries and classes. However,
    there is a lot of work to do, like setting up the virtual environment for Cuckoo
    to use, before we can begin testing and running malware samples with C#. You can
    find more information about and download Cuckoo Sandbox at [https://www.cuckoosandbox.org/](https://www.cuckoosandbox.org/).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Cuckoo Sandbox 是一个开源项目，允许你在虚拟机的安全环境中运行恶意软件样本，然后分析并报告恶意软件在虚拟沙箱中的行为，而不必担心恶意软件会感染你的真实机器。Cuckoo
    Sandbox 是用 Python 编写的，它还提供了一个 REST API，允许程序员使用任何语言来自动化许多 Cuckoo 的功能，例如启动沙箱、运行恶意软件和获取报告。在本章中，我们将使用易于使用的
    C# 库和类来完成这一切。但是，在我们开始使用 C# 测试和运行恶意软件样本之前，还需要完成许多工作，比如设置 Cuckoo 使用的虚拟环境。你可以在 [https://www.cuckoosandbox.org/](https://www.cuckoosandbox.org/)
    找到更多关于 Cuckoo Sandbox 的信息并进行下载。
- en: Setting Up Cuckoo Sandbox
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Cuckoo Sandbox
- en: We won’t cover setting up Cuckoo Sandbox in this chapter because the instructions
    can vary greatly between different operating systems—and even based on which version
    of Windows you use as the virtual machine sandbox. This chapter will assume that
    you correctly set up Cuckoo Sandbox with a Windows guest and that Cuckoo is completely
    functional. Be sure to follow the directions on the main Cuckoo Sandbox website
    ([http://docs.cuckoosandbox.org/en/latest/installation/](http://docs.cuckoosandbox.org/en/latest/installation/)),
    which provides up-to-date and thorough documentation on setting up and configuring
    the software.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不会介绍如何设置 Cuckoo Sandbox，因为不同操作系统之间的安装步骤差异较大，甚至在使用哪个版本的 Windows 作为虚拟机沙箱时也会有所不同。本章假设你已经正确设置了带有
    Windows 客户机的 Cuckoo Sandbox，并且 Cuckoo 已完全功能正常。请确保遵循 Cuckoo Sandbox 官方网站上的说明（[http://docs.cuckoosandbox.org/en/latest/installation/](http://docs.cuckoosandbox.org/en/latest/installation/)），该网站提供了关于软件安装和配置的最新且详细的文档。
- en: In the conf/cuckoo.conf file that ships with Cuckoo Sandbox, I recommend making
    an adjustment to the default timeout configuration so that it is shorter (I set
    mine to 15 seconds) before you begin working with the API. This will make things
    easier and faster during testing. In your cuckoo.conf file, you will see a section
    toward the bottom that looks like [Listing 8-1](#filepos557059).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cuckoo Sandbox 附带的 conf/cuckoo.conf 文件中，我建议你在开始使用 API 之前，调整默认的超时配置，使其更短（我将它设置为
    15 秒）。这将使测试过程更加简单和快速。在你的 cuckoo.conf 文件中，你会看到底部有一个类似于 [Listing 8-1](#filepos557059)
    的部分。
- en: '[timeouts]'
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[timeouts]'
- en: Set the default analysis timeout expressed in seconds. This value will be
  id: totrans-8
  prefs:
  - PREF_BQ
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置默认的分析超时时间，单位为秒。这个值将会是
- en: used to define after how many seconds the analysis will terminate unless
  id: totrans-9
  prefs:
  - PREF_BQ
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用来定义分析将在多少秒后终止，除非
- en: otherwise specified at submission.
  id: totrans-10
  prefs:
  - PREF_BQ
  - PREF_H1
  type: TYPE_NORMAL
  zh: 除非在提交时另有说明。
- en: default = ➊120
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认 = ➊120
- en: 'Listing 8-1: The default timeout configuration section in cuckoo.conf'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-1: cuckoo.conf 文件中的默认超时配置部分'
- en: The default timeout for Cuckoo testing is set to 120 seconds ➊. A long timeout
    can make you quite impatient to see if you fixed a problem during debugging, since
    you must wait for the timeout to be reached before a report is ready, but setting
    this value between 15 and 30 seconds should be good for our purposes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Cuckoo 测试的默认超时设置为 120 秒 ➊。较长的超时可能会让你在调试时变得有些焦急，因为你必须等到超时达到之后才能看到报告，但是将该值设置在
    15 到 30 秒之间应该对我们的目的来说足够了。
- en: Manually Running the Cuckoo Sandbox API
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 手动运行 Cuckoo Sandbox API
- en: Like Nessus, the Cuckoo Sandbox follows a REST pattern (see the description
    of REST in [Chapter 5](index_split_010.html#filepos420379) if you need a refresher).
    However, the Cuckoo Sandbox API is far simpler than the Nessus API, since we only
    need to communicate with a couple of API endpoints. To do this, we’ll continue
    to use the session/manager pattern and implement the CuckooSession class first,
    which encompasses how we will communicate with the Cuckoo Sandbox API. Let’s check
    whether you set up Cuckoo Sandbox correctly, though, before we get started writing
    code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 Nessus，Cuckoo Sandbox 遵循 REST 模式（如果你需要复习 REST，请参见 [第 5 章](index_split_010.html#filepos420379)
    的描述）。然而，Cuckoo Sandbox 的 API 比 Nessus API 简单得多，因为我们只需要与几个 API 端点进行通信。为此，我们将继续使用
    session/manager 模式，首先实现 CuckooSession 类，涵盖我们将如何与 Cuckoo Sandbox API 进行通信。在开始编写代码之前，让我们检查一下你是否正确设置了
    Cuckoo Sandbox。
- en: Starting the API
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 API
- en: With Cuckoo Sandbox successfully installed, you should be able to start it locally
    with the command ./cuckoo.py, as in [Listing 8-2](#filepos559846). If you receive
    an error, ensure the VM you’re using for testing is running.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 成功安装 Cuckoo Sandbox 后，你应该能够通过命令 ./cuckoo.py 在本地启动它，如 [清单 8-2](#filepos559846)
    所示。如果收到错误信息，请确保你用于测试的虚拟机正在运行。
- en: $ ./cuckoo.py
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ ./cuckoo.py
- en: ''
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: eeee e e eeee e e eeeee eeeee
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: eeee e e eeee e e eeeee eeeee
- en: 8 8 8 8 8 8 8 8 8 88 8 88
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8 8 8 8 8 8 8 8 8 88 8 88
- en: 8e 8e 8 8e 8eee8e 8 8 8 8
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8e 8e 8 8e 8eee8e 8 8 8 8
- en: 88 88 8 88 88 8 8 8 8 8
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 88 88 8 88 88 8 8 8 8 8
- en: 88e8 88ee8 88e8 88 8 8eee8 8eee8
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 88e8 88ee8 88e8 88 8 8eee8 8eee8
- en: ''
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Cuckoo Sandbox 2.0-rc2
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Cuckoo Sandbox 2.0-rc2
- en: www.cuckoosandbox.org
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: www.cuckoosandbox.org
- en: Copyright (c) 2010-2015
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 版权所有 (c) 2010-2015
- en: ''
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Checking for updates...
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查更新中...
- en: Good! You have the latest version available.
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 好的！你已经拥有最新版本。
- en: ''
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '2016-05-19 16:17:06,146 [lib.cuckoo.core.scheduler] INFO: Using "virtualbox"
    as machine manager'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2016-05-19 16:17:06,146 [lib.cuckoo.core.scheduler] 信息：使用 "virtualbox" 作为机器管理器
- en: '2016-05-19 16:17:07,484 [lib.cuckoo.core.scheduler] INFO: Loaded 1 machine/s'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2016-05-19 16:17:07,484 [lib.cuckoo.core.scheduler] 信息：已加载 1 台机器
- en: '2016-05-19 16:17:07,495 [lib.cuckoo.core.scheduler] INFO: Waiting for analysis
    tasks...'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2016-05-19 16:17:07,495 [lib.cuckoo.core.scheduler] 信息：等待分析任务...
- en: 'Listing 8-2: Starting the Cuckoo Sandbox manager'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-2：启动 Cuckoo Sandbox 管理器
- en: Starting Cuckoo successfully should yield a fun ASCII art banner, followed by
    quick informational lines about how many VMs have been loaded. After starting
    the main Cuckoo script, you need to start the API that we’ll communicate with.
    Both of these Python scripts must be running at the same time! The cuckoo.py Python
    script is the engine behind Cuckoo Sandbox. If we start the api.py script without
    starting the cuckoo.py script, as in [Listing 8-3](#filepos561051), then our API
    requests won’t do anything. For us to use the Cuckoo Sandbox from the API, both
    cuckoo.py and api.py must be running. By default, the Cuckoo Sandbox API listens
    on port 8090, as [Listing 8-3](#filepos561051) shows.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 成功启动 Cuckoo 后，应该会显示一个有趣的 ASCII 艺术横幅，随后是一些快速信息，显示已加载了多少虚拟机。启动主 Cuckoo 脚本后，你需要启动我们将要进行通信的
    API。这两个 Python 脚本必须同时运行！cuckoo.py Python 脚本是 Cuckoo Sandbox 的引擎。如果我们在没有启动 cuckoo.py
    脚本的情况下启动 api.py 脚本，如 [清单 8-3](#filepos561051) 所示，那么我们的 API 请求将不会执行任何操作。为了通过 API
    使用 Cuckoo Sandbox，cuckoo.py 和 api.py 必须同时运行。默认情况下，Cuckoo Sandbox API 监听 8090 端口，如
    [清单 8-3](#filepos561051) 所示。
- en: $ utils/api.py ➊-H 0.0.0.0
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ utils/api.py ➊-H 0.0.0.0
- en: '* Running on ➋http://0.0.0.0:8090/ (Press CTRL+C to quit)'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '* 正在运行在 ➋http://0.0.0.0:8090/（按 CTRL+C 退出）'
- en: 'Listing 8-3: Running the HTTP API for Cuckoo Sandbox'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-3：运行 Cuckoo Sandbox 的 HTTP API
- en: To specify an IP address to listen on (the default is localhost), you can pass
    the utils/api.py script the -H argument ➊, which tells the API which IP address
    to use when listening for API requests. In this case, we have set 0.0.0.0 as the
    IP address to listen on, which means all network interfaces (both internal and
    external IP addresses for the system) will have port 8090 available for communication
    since we are using the default port. The URL that the Cuckoo API is listening
    on is also printed to the screen ➋ after starting. This URL is how we’ll communicate
    with the API to drive Cuckoo Sandbox in the rest of the chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定监听的 IP 地址（默认是 localhost），你可以通过 utils/api.py 脚本传递 -H 参数 ➊，该参数告诉 API 在监听 API
    请求时使用哪个 IP 地址。在此案例中，我们将 0.0.0.0 设置为监听的 IP 地址，这意味着所有网络接口（包括系统的内部和外部 IP 地址）都将有 8090
    端口可用进行通信，因为我们使用的是默认端口。Cuckoo API 监听的 URL 在启动后也会打印到屏幕上 ➋。这个 URL 是我们与 API 通信，驱动
    Cuckoo Sandbox 进行后续操作的方式。
- en: Checking Cuckoo’s Status
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 Cuckoo 的状态
- en: We can test the API to ensure it has been set up correctly using the curl command
    line tool, as we have in previous chapters for other APIs. Later in the chapter,
    we make similar API requests to create a task, watch the task until completed,
    and report on the file to see how it behaved when it ran. But to get started,
    [Listing 8-4](#filepos564120) shows how to use curl to retrieve the Cuckoo Sandbox
    status information in JSON format with the HTTP API.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用curl命令行工具测试API是否正确设置，就像我们在前几章中为其他API做的一样。在本章后面，我们会发出类似的API请求来创建任务，观察任务直到完成，并报告文件以查看它在运行时的行为。但在开始时，[列表
    8-4](#filepos564120)展示了如何使用curl通过HTTP API以JSON格式获取Cuckoo Sandbox状态信息。
- en: $ curl http://127.0.0.1:8090/cuckoo/status
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ curl http://127.0.0.1:8090/cuckoo/status
- en: '{'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: '"cpuload": ['
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"cpuload": ['
- en: 0.0,
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 0.0,
- en: 0.02,
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 0.02,
- en: '0.05'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '0.05'
- en: '],'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '],'
- en: '"diskspace": {'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"diskspace": {'
- en: '"analyses": {'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"analyses": {'
- en: '"free": 342228357120,'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"free": 342228357120,'
- en: '"total": 486836101120,'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"total": 486836101120,'
- en: '"used": 144607744000'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"used": 144607744000'
- en: '},'
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '},'
- en: '"binaries": {'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"binaries": {'
- en: '"free": 342228357120,'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"free": 342228357120,'
- en: '"total": 486836101120,'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"total": 486836101120,'
- en: '"used": 144607744000'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"used": 144607744000'
- en: '}'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '},'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '},'
- en: '"hostname": "fdsa-E7450",'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"hostname": "fdsa-E7450",'
- en: '➊"machines": {'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '➊"machines": {'
- en: '"available": 1,'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"available": 1,'
- en: '"total": 1'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"total": 1'
- en: '},'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '},'
- en: '"memory": 82.06295645686164,'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"memory": 82.06295645686164,'
- en: '➋"tasks": {'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '➋"tasks": {'
- en: '"completed": 0,'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"completed": 0,'
- en: '"pending": 0,'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"pending": 0,'
- en: '"reported": 3,'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"reported": 3,'
- en: '"running": 0,'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"running": 0,'
- en: '"total": 13'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"total": 13'
- en: '},'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '},'
- en: '➌"version": "2.0-rc2"'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '➌"version": "2.0-rc2"'
- en: '}'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 8-4: Using curl to retrieve the Cuckoo Sandbox status via the HTTP
    API'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-4：使用curl通过HTTP API获取Cuckoo Sandbox状态
- en: The status information is quite useful, detailing many aspects of the Cuckoo
    Sandbox system. Of note is the aggregate task information ➋, with the number of
    tasks that have been run or are running by Cuckoo, listed by status. A task could
    be analyzing a file that is running or opening a web page with a URL, though we’ll
    only cover submitting a file for analysis in this chapter. You can also see the
    number of VMs you have available for analysis ➊ and the current version of Cuckoo
    ➌.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 状态信息非常有用，详细描述了Cuckoo Sandbox系统的多个方面。值得注意的是汇总任务信息➋，其中列出了Cuckoo已运行或正在运行的任务数量，按状态分类。任务可能是分析正在运行的文件，或者是打开带有URL的网页，尽管本章只会介绍提交文件进行分析。你还可以看到用于分析的虚拟机数量➊和当前Cuckoo的版本➌。
- en: Great, the API is up and running! We’ll use this same status API endpoint later
    to test our code as we write it and to discuss the JSON it returns more thoroughly.
    At the moment, we only need to confirm the API is up and running.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒，API已启动并运行！我们稍后会使用相同的状态API端点来测试我们编写的代码，并更详细地讨论它返回的JSON数据。目前，我们只需要确认API已经启动并运行。
- en: Creating the CuckooSession Class
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建CuckooSession类
- en: Now that we know the API works and we can make HTTP requests and get the JSON
    responses, we can start writing our code to drive Cuckoo Sandbox programmatically.
    Once we have the base classes built, we can submit a file that will be analyzed
    as it runs and then report on the results. We’ll start with the CuckooSession
    class, which begins in [Listing 8-5](#filepos566180).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道API工作正常，可以发送HTTP请求并获取JSON响应，接下来我们可以开始编写代码来以编程方式驱动Cuckoo Sandbox。一旦构建了基础类，我们就可以提交一个文件进行分析，分析文件运行时的行为并报告结果。我们从CuckooSession类开始，代码见[列表
    8-5](#filepos566180)。
- en: public class ➊CuckooSession
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class ➊CuckooSession
- en: '{'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public CuckooSession➋(string host, int port)
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public CuckooSession➋(string host, int port)
- en: '{'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Host = host;
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Host = host;
- en: this.Port = port;
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Port = port;
- en: '}'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string ➌Host { get; set; }
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string ➌Host { get; set; }
- en: public int ➍Port { get; set; }
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int ➍Port { get; set; }
- en: 'Listing 8-5: Starting the  CuckooSession  class'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-5：启动CuckooSession类
- en: Keeping things simple to start with, we create the CuckooSession class ➊ as
    well as the CuckooSession constructor. The constructor takes two arguments ➋.
    The first is the host to connect to, and the second is the port on the host on
    which the API will be listening. In the constructor, the two values passed as
    arguments are assigned to their respective properties, Host ➌ and Port ➍, which
    are defined below the constructor. Next, we need to implement the methods available
    for the CuckooSession class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们首先创建CuckooSession类➊以及CuckooSession构造函数。构造函数接受两个参数➋，第一个是要连接的主机，第二个是主机上API监听的端口。在构造函数中，传入的两个参数值被分配给相应的属性Host
    ➌和Port ➍，这些属性在构造函数下方定义。接下来，我们需要实现CuckooSession类中的可用方法。
- en: Writing the ExecuteCommand() Methods to Handle HTTP Requests
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 编写ExecuteCommand()方法以处理HTTP请求
- en: 'Cuckoo expects two kinds of HTTP requests when API requests are made: a traditional
    HTTP request and a more complex HTTP multipart form request used for sending files
    to Cuckoo for analysis. We’ll implement two ExecuteCommand() methods to cover
    these types of requests: first, we’ll use a simpler ExecuteCommand() method that
    accepts two arguments for the traditional request, and then we’ll overload it
    with an ExecuteCommand() method that takes three arguments for the multipart request.
    Creating two methods with the same name but with different arguments, or method
    overloading, is allowed in C#. This is a good example of when you would use method
    overloading instead of a single method that accepts optional arguments because
    the methods for each request are relatively different, despite sharing the same
    name. [Listing 8-6](#filepos569112) details the simpler ExecuteCommand() method.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Cuckoo 期望在 API 请求时收到两种 HTTP 请求：一种是传统的 HTTP 请求，另一种是用于将文件发送到 Cuckoo 进行分析的更复杂的
    HTTP 多部分表单请求。我们将实现两个 ExecuteCommand() 方法来涵盖这些请求类型：首先，我们将使用一个简单的 ExecuteCommand()
    方法，接受两个参数用于传统请求，然后我们将通过重载它，创建一个接受三个参数用于多部分请求的 ExecuteCommand() 方法。在 C# 中，允许创建具有相同名称但不同参数的方法，也就是方法重载。这是一个典型的例子，展示了在方法重载时的应用场景，而不是使用一个接受可选参数的单一方法，因为尽管方法名相同，但每种请求的方法相对不同。更简单的
    ExecuteCommand() 方法在 [Listing 8-6](#filepos569112) 中有详细说明。
- en: public JObject ➊ExecuteCommand(string uri, string method)
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public JObject ➊ExecuteCommand(string uri, string method)
- en: '{'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: HttpWebRequest req = (HttpWebRequest)WebRequest
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: HttpWebRequest req = (HttpWebRequest)WebRequest
- en: .➋Create("http://" + this.Host + ":" + this.Port + uri);
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: .➋Create("http://" + this.Host + ":" + this.Port + uri);
- en: req.➌Method = method;
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: req.➌Method = method;
- en: ''
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string resp = string.Empty;
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string resp = string.Empty;
- en: using (Stream str = req.GetResponse().GetResponseStream())
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (Stream str = req.GetResponse().GetResponseStream())
- en: using (StreamReader rdr = new StreamReader(str))
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (StreamReader rdr = new StreamReader(str))
- en: resp = rdr.➍ReadToEnd();
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: resp = rdr.➍ReadToEnd();
- en: ''
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JObject obj = JObject.➎Parse(resp);
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JObject obj = JObject.➎Parse(resp);
- en: return obj;
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return obj;
- en: '}'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 8-6: The simpler  ExecuteCommand()  method that accepts just a URI
    and the HTTP method as arguments'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-6: 更简单的 ExecuteCommand() 方法，它仅接受 URI 和 HTTP 方法作为参数'
- en: 'The first ExecuteCommand() method ➊ takes two arguments: the URI to request
    and the HTTP method to use (GET, POST, PUT, and so on). After using Create() ➋
    to build a new HTTP request and setting the Method property ➌ of the request,
    we make the HTTP request and read ➍ the response into a string. Finally, we parse
    ➎ the returned string as JSON and return the new JSON object.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 ExecuteCommand() 方法 ➊ 接受两个参数：请求的 URI 和要使用的 HTTP 方法（如 GET、POST、PUT 等）。在使用
    Create() ➋ 构建新的 HTTP 请求并设置请求的 Method 属性 ➌ 后，我们发出 HTTP 请求并读取 ➍ 响应到一个字符串中。最后，我们将返回的字符串解析
    ➎ 为 JSON，并返回新的 JSON 对象。
- en: 'The overloaded ExecuteCommand() method takes three arguments: the URI to request,
    the HTTP method, and a dictionary of parameters that will be sent in an HTTP multipart
    request. Multipart requests allow you to send more complex data such as binary
    files along with other HTTP parameters to a web server, which is exactly how we’ll
    use it. A full multipart request is shown later in [Listing 8-9](#filepos580411).
    How to send this type of request is detailed in [Listing 8-7](#filepos571955).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 重载的 ExecuteCommand() 方法接受三个参数：请求的 URI、HTTP 方法和一个字典，字典包含将通过 HTTP 多部分请求发送的参数。多部分请求允许你发送更复杂的数据，如二进制文件以及其他
    HTTP 参数到 Web 服务器，这正是我们将要使用的方式。一个完整的多部分请求将在 [Listing 8-9](#filepos580411) 中展示。如何发送这种类型的请求将在
    [Listing 8-7](#filepos571955) 中详细说明。
- en: public JObject ➊ExecuteCommand(string uri, string method, IDictionary<string,
    object> parms)
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public JObject ➊ExecuteCommand(string uri, string method, IDictionary<string,
    object> parms)
- en: '{'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: HttpWebRequest req = (HttpWebRequest)WebRequest
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: HttpWebRequest req = (HttpWebRequest)WebRequest
- en: .➋Create("http://" + this.Host + ":" + this.Port + uri);
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: .➋Create("http://" + this.Host + ":" + this.Port + uri);
- en: req.➌Method = method;
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: req.➌Method = method;
- en: string boundary = ➍String.Format("----------{0:N}", Guid.NewGuid());
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string boundary = ➍String.Format("----------{0:N}", Guid.NewGuid());
- en: byte[] data = ➎GetMultipartFormData(parms, boundary);
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] data = ➎GetMultipartFormData(parms, boundary);
- en: ''
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: req.ContentLength = data.Length;
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: req.ContentLength = data.Length;
- en: req.ContentType = ➏"multipart/form-data; boundary=" + boundary;
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: req.ContentType = ➏"multipart/form-data; boundary=" + boundary;
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (Stream parmStream = req.GetRequestStream())
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (Stream parmStream = req.GetRequestStream())
- en: parmStream.➐Write(data, 0, data.Length);
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: parmStream.➐Write(data, 0, data.Length);
- en: ''
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string resp = string.Empty;
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string resp = string.Empty;
- en: using (Stream str = req.GetResponse().GetResponseStream())
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (Stream str = req.GetResponse().GetResponseStream())
- en: using (StreamReader rdr = new StreamReader(str))
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (StreamReader rdr = new StreamReader(str))
- en: resp = rdr.➑ReadToEnd();
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: resp = rdr.➑ReadToEnd();
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JObject obj = JObject.➒Parse(resp);
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JObject obj = JObject.➒Parse(resp);
- en: return obj;
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return obj;
- en: '}'
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 8-7: The overloaded  ExecuteCommand()  method, which makes a multipart/form-data
    HTTP request'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-7：重载的 `ExecuteCommand()` 方法，它发起一个 multipart/form-data HTTP 请求
- en: The second, more complex ExecuteCommand() method ➊ takes three arguments, as
    outlined earlier. After instantiating a new request ➋ and setting the HTTP method
    ➌, we create a boundary that will be used to separate the HTTP parameters in the
    multipart form request using String.Format() ➍. Once the boundary is created,
    we call GetMultipartFormData() ➎ (which we will implement shortly) to convert
    the dictionary of parameters passed as the third argument into a multipart HTTP
    form with the new boundary.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个，更复杂的 `ExecuteCommand()` 方法 ➊ 接受三个参数，如前所述。实例化一个新的请求 ➋ 并设置 HTTP 方法 ➌ 后，我们创建一个边界，边界将用于在多部分表单请求中分隔
    HTTP 参数，使用 `String.Format()`  ➍。一旦边界创建完成，我们调用 `GetMultipartFormData()` ➎（我们稍后将实现）来将作为第三个参数传递的参数字典转换为一个带有新边界的多部分
    HTTP 表单。
- en: After building the multipart HTTP data, we need to set up the HTTP request by
    setting the ContentLength and ContentType request properties based on the multipart
    HTTP data. For the ContentType property, we also append the boundary that will
    be used to separate the HTTP parameters ➏. Finally, we can write ➐ the multipart
    form data to the HTTP request stream and read ➑ the response from the server.
    With the final response from the server, we parse ➒ the response as JSON and then
    return the JSON object.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建完多部分 HTTP 数据后，我们需要通过设置基于多部分 HTTP 数据的 `ContentLength` 和 `ContentType` 请求属性来设置
    HTTP 请求。对于 `ContentType` 属性，我们还需要附加用于分隔 HTTP 参数的边界 ➏。最后，我们可以将 ➐ 多部分表单数据写入 HTTP
    请求流并读取 ➑ 来自服务器的响应。通过从服务器获取最终响应后，我们将响应解析 ➒ 为 JSON，然后返回 JSON 对象。
- en: Both of these ExecuteCommand() methods will be used to execute API calls against
    the Cuckoo Sandbox API. But before we can start calling the API endpoints, we
    need to write a bit more code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 `ExecuteCommand()` 方法将用于执行针对 Cuckoo Sandbox API 的 API 调用。但在我们开始调用 API 端点之前，我们需要再写一些代码。
- en: Creating Multipart HTTP Data with the GetMultipartFormData() Method
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `GetMultipartFormData()` 方法创建多部分 HTTP 数据
- en: Although the GetMultipartFormData() method is core to communicating with Cuckoo
    Sandbox, I’m not going to go over it line by line. This method is actually a good
    example of a small weakness in the core libraries for C# because it shouldn’t
    be this complicated to make a multipart HTTP request. Unfortunately, there is
    no easy-to-use class available that allows us to do this, so we need to create
    this method to build the HTTP multipart request from scratch. The raw technical
    details of building multipart HTTP requests are a bit out of scope for what we
    are looking to accomplish, so I’ll only gloss over the general flow of this method.
    The method in full (shown in [Listing 8-8](#filepos577748), minus in-line comments)
    was written by Brian Grinstead,^([1](index_split_025.html#filepos1129476)) whose
    work was then incorporated into the RestSharp client ([http://restsharp.org/](http://restsharp.org/)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `GetMultipartFormData()` 方法是与 Cuckoo Sandbox 通信的核心，但我不会逐行讲解它。这个方法实际上是 C#
    核心库中一个小缺陷的好例子，因为制作一个多部分 HTTP 请求不应该这么复杂。不幸的是，目前没有一个易于使用的类可以帮助我们完成这个操作，所以我们需要创建这个方法，从头开始构建
    HTTP 多部分请求。构建多部分 HTTP 请求的技术细节有些超出了我们要实现的目标，所以我只会简单概述这个方法的基本流程。完整的方法（见[示例 8-8](#filepos577748)，去除了内联注释）是由
    Brian Grinstead 编写的^([1](index_split_025.html#filepos1129476))，他的工作后来被纳入了 RestSharp
    客户端 ([http://restsharp.org/](http://restsharp.org/))。
- en: private byte[] ➊GetMultipartFormData(IDictionary<string, object> postParameters,
    string boundary)
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private byte[] ➊GetMultipartFormData(IDictionary<string, object> postParameters,
    string boundary)
- en: '{'
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: System.Text.Encoding encoding = System.Text.Encoding.ASCII;
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: System.Text.Encoding encoding = System.Text.Encoding.ASCII;
- en: Stream formDataStream = new System.IO.MemoryStream();
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Stream formDataStream = new System.IO.MemoryStream();
- en: bool needsCLRF = false;
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bool needsCLRF = false;
- en: ''
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (var param in postParameters)
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (var param in postParameters)
- en: '{'
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (needsCLRF)
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (needsCLRF)
- en: formDataStream.Write(encoding.GetBytes("\r\n"), 0, encoding.GetByteCount("\r\n"));
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: formDataStream.Write(encoding.GetBytes("\r\n"), 0, encoding.GetByteCount("\r\n"));
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: needsCLRF = true;
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: needsCLRF = true;
- en: if (param.Value is FileParameter)
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (param.Value is FileParameter)
- en: '{'
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ''
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: FileParameter fileToUpload = (FileParameter)param.Value;
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: FileParameter fileToUpload = (FileParameter)param.Value;
- en: 'string header = string.Format("--{0}\r\nContent-Disposition: form-data; name=\"{1}\";"
    +'
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'string header = string.Format("--{0}\r\nContent-Disposition: form-data; name=\"{1}\";"
    +'
- en: '"filename=\"{2}\";\r\nContent-Type: {3}\r\n\r\n",'
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"filename=\"{2}\";\r\nContent-Type: {3}\r\n\r\n",'
- en: boundary,
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: boundary,
- en: param.Key,
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: param.Key,
- en: fileToUpload.FileName ?? param.Key,
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: fileToUpload.FileName ?? param.Key,
- en: fileToUpload.ContentType ?? "application/octet-stream");
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: fileToUpload.ContentType ?? "application/octet-stream");
- en: formDataStream.Write(encoding.GetBytes(header), 0, encoding.GetByteCount(header));
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: formDataStream.Write(encoding.GetBytes(header), 0, encoding.GetByteCount(header));
- en: formDataStream.Write(fileToUpload.File, 0, fileToUpload.File.Length);
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: formDataStream.Write(fileToUpload.File, 0, fileToUpload.File.Length);
- en: '}'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else
- en: '{'
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: 'string postData = string.Format("--{0}\r\nContent-Disposition: form-data;"
    +'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'string postData = string.Format("--{0}\r\nContent-Disposition: form-data;"
    +'
- en: '"name=\"{1}\"\r\n\r\n{2}",'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"name=\"{1}\"\r\n\r\n{2}",'
- en: boundary,
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: boundary,
- en: param.Key,
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: param.Key,
- en: param.Value);
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: param.Value);
- en: formDataStream.Write(encoding.GetBytes(postData), 0, encoding.GetByteCount(postData));
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: formDataStream.Write(encoding.GetBytes(postData), 0, encoding.GetByteCount(postData));
- en: '}'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string footer = "\r\n--" + boundary + "--\r\n";
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string footer = "\r\n--" + boundary + "--\r\n";
- en: formDataStream.Write(encoding.GetBytes(footer), 0, encoding.GetByteCount(footer));
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: formDataStream.Write(encoding.GetBytes(footer), 0, encoding.GetByteCount(footer));
- en: ''
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: formDataStream.Position = 0;
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: formDataStream.Position = 0;
- en: byte[] formData = new byte[formDataStream.Length];
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] formData = new byte[formDataStream.Length];
- en: formDataStream.Read(formData, 0, formData.Length);
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: formDataStream.Read(formData, 0, formData.Length);
- en: formDataStream.Close();
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: formDataStream.Close();
- en: return formData;
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return formData;
- en: '}'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 8-8: The  GetMultipartFormData()  method'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-8: The  GetMultipartFormData()  method'
- en: 'In the GetMultipartFormData() method ➊, we start by accepting two arguments:
    the first is the dictionary of parameters and their respective values that we’ll
    turn into a multipart form, and the second is the string that we’ll use to separate
    the file parameters in the request so they can be parsed out. This second argument
    is called boundary, and we use it to tell the API to split the HTTP request body
    using this boundary, and then use each section as a separate parameter and value
    in the request. This can be hard to visualize, so [Listing 8-9](#filepos580411)
    details a sample HTTP multipart form request.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetMultipartFormData()`方法➊中，我们首先接受两个参数：第一个是参数及其各自值的字典，我们将把这些转换为一个multipart表单；第二个是用于分隔请求中文件参数的字符串，以便它们可以被解析。这个第二个参数叫做`boundary`，我们用它告诉API使用这个边界分隔HTTP请求体，然后将每个部分作为请求中的独立参数和值。这个过程可能难以想象，所以[示例
    8-9](#filepos580411)详细介绍了一个示例HTTP多部分表单请求。
- en: POST / HTTP/1.1
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: POST / HTTP/1.1
- en: 'Host: localhost:8000'
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Host: localhost:8000'
- en: 'User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:29.0) Gecko/20100101 Firefox/29.0'
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:29.0) Gecko/20100101 Firefox/29.0'
- en: 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
- en: 'Accept-Language: en-US,en;q=0.5'
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Accept-Language: en-US,en;q=0.5'
- en: 'Accept-Encoding: gzip, deflate'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Accept-Encoding: gzip, deflate'
- en: 'Connection: keep-alive'
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Connection: keep-alive'
- en: 'Content-Type: ➊multipart/form-data;'
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Content-Type: ➊multipart/form-data;'
- en: boundary➋=------------------------9051914041544843365972754266
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: boundary➋=------------------------9051914041544843365972754266
- en: 'Content-Length: 554'
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Content-Length: 554'
- en: ''
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '--------------------------9051914041544843365972754266➌'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '--------------------------9051914041544843365972754266➌'
- en: 'Content-Disposition: form-data; ➍name="text"'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Content-Disposition: form-data; ➍name="text"'
- en: ''
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: text default➎
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: text default➎
- en: '--------------------------9051914041544843365972754266➏'
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '--------------------------9051914041544843365972754266➏'
- en: 'Content-Disposition: form-data; name="file1"; filename="a.txt"'
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Content-Disposition: form-data; name="file1"; filename="a.txt"'
- en: 'Content-Type: text/plain'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Content-Type: text/plain'
- en: Content of a.txt.
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Content of a.txt.
- en: ''
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '--------------------------9051914041544843365972754266➐'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '--------------------------9051914041544843365972754266➐'
- en: 'Content-Disposition: form-data; name="file2"; filename="a.html"'
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Content-Disposition: form-data; name="file2"; filename="a.html"'
- en: 'Content-Type: text/html'
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Content-Type: text/html'
- en: ''
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <!DOCTYPE html><title>Content of a.html.</title>
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <!DOCTYPE html><title>Content of a.html.</title>
- en: ''
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '--------------------------9051914041544843365972754266--➑'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '--------------------------9051914041544843365972754266--➑'
- en: 'Listing 8-9: A sample HTTP multipart form request'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-9: A sample HTTP multipart form request'
- en: This HTTP request looks a lot like what we are trying to build, so let’s point
    out the important parts that were mentioned in GetMultipartFormData(). First,
    note the Content-Type header is multipart/form-data ➊ with a boundary ➋, just
    like the one we set in [Listing 8-7](#filepos571955). This boundary is used throughout
    the HTTP request (➌, ➏, ➐, ➑) to separate each HTTP parameter. Each parameter
    also has a parameter name ➍ and value ➎. The GetMultipartFormData() method takes
    the parameter names and values we pass in the Dictionary argument and the boundary
    and then turns them into a similar HTTP request using the given boundary to separate
    each parameter.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 HTTP 请求看起来与我们正在尝试构建的请求非常相似，因此让我们指出在 GetMultipartFormData() 中提到的重要部分。首先，注意
    Content-Type 头部是 multipart/form-data ➊，并且有一个边界 ➋，就像我们在[示例 8-7](#filepos571955)中设置的那样。这个边界将在整个
    HTTP 请求中使用（➌、➏、➐、➑）来分隔每个 HTTP 参数。每个参数也都有一个参数名 ➍ 和一个参数值 ➎。GetMultipartFormData()
    方法接受我们在字典参数中传递的参数名和值，以及边界，然后使用给定的边界将它们转换为类似的 HTTP 请求，以分隔每个参数。
- en: Processing File Data with the FileParameter Class
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 FileParameter 类处理文件数据
- en: In order to send Cuckoo the file or malware we want to analyze, we need to create
    a class we can use to store the data for the file, such as the file type, filename,
    and actual content of the file. The simple FileParameter class wraps a bit of
    the information we need for the GetMultipartFormData() method. It’s shown in [Listing
    8-10](#filepos582712).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们想要分析的文件或恶意软件发送给 Cuckoo，我们需要创建一个类来存储文件的数据，例如文件类型、文件名和文件的实际内容。简单的 FileParameter
    类封装了我们需要为 GetMultipartFormData() 方法提供的信息的一部分。它在[示例 8-10](#filepos582712)中展示。
- en: public class ➊FileParameter
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class ➊FileParameter
- en: '{'
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public byte[] File { get; set; }
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public byte[] File { get; set; }
- en: public string FileName { get; set; }
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string FileName { get; set; }
- en: public string ContentType { get; set; }
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string ContentType { get; set; }
- en: ''
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public ➋FileParameter(byte[] file, string filename, string contenttype)
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public ➋FileParameter(byte[] file, string filename, string contenttype)
- en: '{'
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ➌File = file;
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➌File = file;
- en: ➍FileName = filename;
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➍FileName = filename;
- en: ➎ContentType = contenttype;
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➎ContentType = contenttype;
- en: '}'
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 8-10: The  FileParameter  class'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 8-10: FileParameter 类'
- en: 'The FileParameter class ➊ represents the data we need to build an HTTP parameter
    that will contain the file to be analyzed. The constructor ➋ for the class accepts
    three arguments: the byte array containing the file contents, the name of the
    file, and the content type. Each argument is then assigned to the respective class
    property (➌, ➍, ➎).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: FileParameter 类 ➊ 表示我们需要构建一个 HTTP 参数，该参数将包含要分析的文件。该类的构造函数 ➋ 接受三个参数：包含文件内容的字节数组、文件名和内容类型。每个参数随后会被分配给相应的类属性（➌、➍、➎）。
- en: Testing the CuckooSession and Supporting Classes
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 CuckooSession 和支持类
- en: We can test what we have written so far with a short and simple Main() method
    that requests the status of Cuckoo Sandbox using the API. We did this manually
    in “[Checking Cuckoo’s Status](#filepos561892)” on [page 149](#filepos554179).
    [Listing 8-11](#filepos584418) shows how we can do this using the new CuckooSession
    class.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个简短且简单的 Main() 方法来测试到目前为止所写的内容，该方法通过 API 请求 Cuckoo Sandbox 的状态。我们之前在
    “[检查 Cuckoo 状态](#filepos561892)”（[第 149 页](#filepos554179)）中手动做过这件事。[示例 8-11](#filepos584418)
    展示了我们如何使用新的 CuckooSession 类来做到这一点。
- en: public static void ➊Main(string[] args)
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void ➊Main(string[] args)
- en: '{'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: CuckooSession session = new ➋CuckooSession("127.0.0.1", 8090);
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CuckooSession session = new ➋CuckooSession("127.0.0.1", 8090);
- en: JObject response = session.➌ExecuteCommand("/cuckoo/status", "GET");
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JObject response = session.➌ExecuteCommand("/cuckoo/status", "GET");
- en: Console.➍WriteLine(response.ToString());
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.➍WriteLine(response.ToString());
- en: '}'
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 8-11:  Main()  method for retrieving the Cuckoo Sandbox status'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 8-11: 用于检索 Cuckoo Sandbox 状态的 Main() 方法'
- en: With a new Main() method ➊, we first create a CuckooSession object ➋ by passing
    the IP address and the port that Cuckoo Sandbox is running on. If the API is running
    on your local machine, then 127.0.0.1 for the IP should be fine. The IP and port
    (8090 by default) should have been set up when we started the API in [Listing
    8-3](#filepos561051). Using the new session, we call the ExecuteCommand() method
    ➌, passing the URI /cuckoo/status as the first argument and the HTTP method GET
    as the second method. The response is then printed to the screen using WriteLine()
    ➍.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的 Main() 方法 ➊，我们首先通过传递 Cuckoo Sandbox 运行的 IP 地址和端口来创建一个 CuckooSession 对象
    ➋。如果 API 运行在本地机器上，IP 地址应该可以使用 127.0.0.1。IP 地址和端口（默认端口为 8090）应该在我们启动 API 时在[示例
    8-3](#filepos561051)中已经设置过了。使用新的会话，我们调用 ExecuteCommand() 方法 ➌，传入 URI /cuckoo/status
    作为第一个参数，HTTP 方法 GET 作为第二个参数。然后，响应通过 WriteLine() ➍ 打印到屏幕上。
- en: Running the Main() method should print a JSON dictionary to the screen with
    status information about Cuckoo, as detailed in [Listing 8-12](#filepos587213).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '运行 Main() 方法应该会在屏幕上打印一个 JSON 字典，包含 Cuckoo 的状态信息，具体细节见 [Listing 8-12](#filepos587213)。  '
- en: $ ./ch8_automating_cuckoo.exe
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '$ ./ch8_automating_cuckoo.exe  '
- en: '{'
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{  '
- en: '"cpuload": ['
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"cpuload": [  '
- en: 0.0,
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '0.0,  '
- en: 0.03,
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '0.03,  '
- en: '0.05'
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '0.05  '
- en: '],'
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '],  '
- en: '"diskspace": {'
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"diskspace": {  '
- en: '"analyses": {'
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"analyses": {  '
- en: '"free": 342524416000,'
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"free": 342524416000,  '
- en: '"total": 486836101120,'
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"total": 486836101120,  '
- en: '"used": 144311685120'
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"used": 144311685120  '
- en: '},'
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '},  '
- en: '"binaries": {'
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"binaries": {  '
- en: '"free": 342524416000,'
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"free": 342524416000,  '
- en: '"total": 486836101120,'
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"total": 486836101120,  '
- en: '"used": 144311685120'
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"used": 144311685120  '
- en: '}'
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}  '
- en: '},'
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '},  '
- en: '"hostname": "fdsa-E7450",'
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"hostname": "fdsa-E7450",  '
- en: '"machines": {'
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"machines": {  '
- en: '"available": 1,'
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"available": 1,  '
- en: '"total": 1'
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"total": 1  '
- en: '},'
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '},  '
- en: '"memory": 85.542549616647932,'
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"memory": 85.542549616647932,  '
- en: '"tasks": {'
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"tasks": {  '
- en: '"completed": 0,'
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"completed": 0,  '
- en: '"pending": 0,'
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"pending": 0,  '
- en: '"reported": 2,'
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"reported": 2,  '
- en: '"running": 0,'
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"running": 0,  '
- en: '"total": 12'
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"total": 12  '
- en: '},'
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '},  '
- en: '"version": "2.0-rc2"'
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"version": "2.0-rc2"  '
- en: '}'
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}  '
- en: 'Listing 8-12: Testing the  CuckooSession  class to print the current status
    information for the Cuckoo Sandbox'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-12: 测试 CuckooSession 类以打印 Cuckoo Sandbox 的当前状态信息  '
- en: You can see that the JSON information printed here is the same as when we ran
    the API command manually earlier to check Cuckoo’s status.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以看到，这里打印的 JSON 信息与我们之前手动运行 API 命令检查 Cuckoo 状态时得到的相同。  '
- en: writing the CuckooManager Class
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '编写 CuckooManager 类  '
- en: With the CuckooSession class and other supporting classes implemented, we can
    move on to the CuckooManager class, which will wrap a few easy API calls. To start
    off the CuckooManager class, we need the constructor shown in [Listing 8-13](#filepos588590).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '在实现了 CuckooSession 类和其他支持类之后，我们可以继续编写 CuckooManager 类，它将封装一些简单的 API 调用。要开始
    CuckooManager 类，我们需要构造函数，如 [Listing 8-13](#filepos588590) 所示。  '
- en: 'public class ➊CuckooManager : ➋IDisposable'
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'public class ➊CuckooManager : ➋IDisposable  '
- en: '{'
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{  '
- en: CuckooSession ➌_session = null;
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'CuckooSession ➌_session = null;  '
- en: public ➍CuckooManager(CuckooSession session)
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'public ➍CuckooManager(CuckooSession session)  '
- en: '{'
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{  '
- en: ➎_session = session;
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '➎_session = session;  '
- en: '}'
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}  '
- en: 'Listing 8-13: Starting the  CuckooManager  class'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-13: 启动 CuckooManager 类  '
- en: 'The CuckooManager class ➊ starts by implementing the IDisposable interface
    ➋, which we’ll use to dispose of our private _session variable ➌ when we are finished
    with the CuckooManager class. The class constructor ➍ takes only a single argument:
    the session to use when communicating with the Cuckoo Sandbox instance. The private
    _session variable is assigned with the argument passed to the constructor ➎ so
    that the methods we will write shortly can use the session to make their specific
    API calls.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 'CuckooManager 类 ➊ 首先实现 IDisposable 接口 ➋，我们将利用该接口来处理私有的 _session 变量 ➌，当我们完成
    CuckooManager 类的使用时。类的构造函数 ➍ 仅接受一个参数：与 Cuckoo Sandbox 实例进行通信时使用的会话。私有的 _session
    变量会赋值为传递给构造函数的参数 ➎，这样我们接下来编写的方法就可以使用该会话来进行特定的 API 调用。  '
- en: Writing the CreateTask() Method
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '编写 CreateTask() 方法  '
- en: The first method in the CuckooManager class is CreateTask(), the most complicated
    manager method we’ll write. The CreateTask() method implements the HTTP call that
    will create a new task by determining the type of task we are creating and then
    making the correct HTTP call, as shown in [Listing 8-14](#filepos592106).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 'CuckooManager 类中的第一个方法是 CreateTask()，它是我们编写的最复杂的管理方法。CreateTask() 方法实现了 HTTP
    调用，该调用会根据我们要创建的任务类型，确定并执行正确的 HTTP 调用，具体见 [Listing 8-14](#filepos592106)。  '
- en: public int ➊CreateTask(Task task)
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'public int ➊CreateTask(Task task)  '
- en: '{'
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{  '
- en: string param = null, uri = "/tasks/create/";
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'string param = null, uri = "/tasks/create/";  '
- en: object val = null;
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'object val = null;  '
- en: if ➋(task is FileTask)
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if ➋(task is FileTask)  '
- en: '{'
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{  '
- en: byte[] data;
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'byte[] 数据;  '
- en: using (FileStream str = new ➌FileStream((task as FileTask).Filepath,
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'using (FileStream str = new ➌FileStream((task as FileTask).Filepath,  '
- en: FileMode.Open,
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'FileMode.Open,  '
- en: FileAccess.Read))
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'FileAccess.Read))  '
- en: '{'
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{  '
- en: data = new byte[str.Length];
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'data = new byte[str.Length];  '
- en: str.➍Read(data, 0, data.Length);
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'str.➍Read(data, 0, data.Length);  '
- en: '}'
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}  '
- en: ''
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: param = "file";
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'param = "file";  '
- en: uri += param;
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'uri += param;  '
- en: val = new ➎FileParameter(data, (task as FileTask).Filepath,
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'val = new ➎FileParameter(data, (task as FileTask).Filepath,  '
- en: '"application/binary");'
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"application/binary");'
- en: '}'
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}  '
- en: ''
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: IDictionary<string, object> ➏parms = new Dictionary<string, object>();
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'IDictionary<string, object> ➏parms = new Dictionary<string, object>();  '
- en: parms.Add(param, val);
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'parms.Add(param, val);  '
- en: parms.Add("package", task.Package);
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'parms.Add("package", task.Package);  '
- en: parms.Add("timeout", task.Timeout.ToString());
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'parms.Add("timeout", task.Timeout.ToString());  '
- en: parms.Add("options", task.Options);
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'parms.Add("options", task.Options);  '
- en: parms.Add("machine", ➐task.Machine);
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'parms.Add("machine", ➐task.Machine);  '
- en: parms.Add("platform", task.Platform);
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'parms.Add("platform", task.Platform);  '
- en: parms.Add("custom", task.Custom);
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'parms.Add("custom", task.Custom);  '
- en: parms.Add("memory", task.EnableMemoryDump.ToString());
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'parms.Add("memory", task.EnableMemoryDump.ToString());  '
- en: parms.Add("enforce_timeout", task.EnableEnforceTimeout.ToString());
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: parms.Add("enforce_timeout", task.EnableEnforceTimeout.ToString());
- en: ''
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JObject resp = _session.➑ExecuteCommand(uri, "POST", parms);
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JObject resp = _session.➑ExecuteCommand(uri, "POST", parms);
- en: ''
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return ➒(int)resp["task_id"];
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return ➒(int)resp["task_id"];
- en: '}'
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 8-14: The  CreateTask()  method'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-14：CreateTask() 方法
- en: The CreateTask() method ➊ starts by first checking whether the task passed in
    is a FileTask class ➋ (the class for describing a file or malware to be analyzed).
    Because Cuckoo Sandbox supports more than just analyzing files (such as URLs),
    the CreateTask() method can easily be extended to create different types of tasks
    this way. If the task is a FileTask, we open the file to send to Cuckoo Sandbox
    with a new FileStream() ➌ and then read the file into a byte array. Once the file
    has been read ➍, we create a new FileParameter class ➎ with the filename, the
    file bytes, and the content type application/binary.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: CreateTask() 方法 ➊ 首先检查传入的任务是否为 FileTask 类 ➋（用于描述要分析的文件或恶意软件的类）。由于 Cuckoo Sandbox
    不仅支持分析文件（例如 URL），因此 CreateTask() 方法可以很容易地扩展为创建不同类型的任务。如果任务是 FileTask，我们会用新的 FileStream()
    ➌ 打开要发送到 Cuckoo Sandbox 的文件，并将文件读取到字节数组中。文件读取完成后 ➍，我们使用新的 FileParameter 类 ➎ 来创建文件名、文件字节和内容类型为
    application/binary 的参数。
- en: Then we set up the HTTP parameters we’ll be sending to Cuckoo Sandbox in a new
    Dictionary ➏. The HTTP parameters are specified in the Cuckoo Sandbox API documentation
    and should contain the information required to create a task. These parameters
    allow us to change default configuration items such as which VM to use ➐. Finally,
    we create the new task by calling ExecuteCommand() ➑ with the parameters in the
    dictionary and then return ➒ the new task ID.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在新的 Dictionary ➏ 中设置将发送到 Cuckoo Sandbox 的 HTTP 参数。这些 HTTP 参数在 Cuckoo Sandbox
    API 文档中有说明，并应包含创建任务所需的信息。这些参数允许我们更改默认配置项，例如选择使用哪个虚拟机 ➐。最后，我们通过调用 ExecuteCommand()
    ➑ 并使用字典中的参数来创建新任务，然后返回 ➒ 新的任务 ID。
- en: The Task Details and Reporting Methods
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 任务详情和报告方法
- en: A few more API calls need to be supported in order for us to submit our file
    to be analyzed and reported on, but they are much simpler than CreateTask(), as
    [Listing 8-15](#filepos595416) details. We just create a method to show the task
    details, two methods to report on our tasks, and a method to clean up our sessions.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够提交我们的文件进行分析和报告，还需要支持更多的 API 调用，但它们比 CreateTask() 要简单得多，如[列表 8-15](#filepos595416)所述。我们只需要创建一个方法来显示任务详情，两个方法来报告我们的任务，还有一个方法来清理我们的会话。
- en: public Task ➊GetTaskDetails(int id)
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public Task ➊GetTaskDetails(int id)
- en: '{'
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string uri = ➋"/tasks/view/" + id;
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string uri = ➋"/tasks/view/" + id;
- en: JObject resp = _session.➌ExecuteCommand(uri, "GET");
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JObject resp = _session.➌ExecuteCommand(uri, "GET");
- en: ➍return TaskFactory.CreateTask(resp["task"]);
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➍return TaskFactory.CreateTask(resp["task"]);
- en: '}'
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public JObject ➎GetTaskReport(int id)
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public JObject ➎GetTaskReport(int id)
- en: '{'
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: return GetTaskReport(id, ➏"json");
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return GetTaskReport(id, ➏"json");
- en: '}'
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public JObject ➐GetTaskReport(int id, string type)
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public JObject ➐GetTaskReport(int id, string type)
- en: '{'
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string uri = ➑"/tasks/report/" + id + "/" + type;
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string uri = ➑"/tasks/report/" + id + "/" + type;
- en: return _session.➒ExecuteCommand(uri, "GET");
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return _session.➒ExecuteCommand(uri, "GET");
- en: '}'
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public void ➓Dispose()
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public void ➓Dispose()
- en: '{'
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: _session = null;
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _session = null;
- en: '}'
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 8-15: Supporting methods for retrieving task information and reports'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-15：用于检索任务信息和报告的辅助方法
- en: The first method we implement is the GetTaskDetails() method ➊, which takes
    a task ID for the variable id as its only argument. We first create the URI we’ll
    make the HTTP request to by appending the ID argument to /tasks/view ➋, and then
    we call ExecuteCommand() ➌ with the new URI. This endpoint returns some information
    about the task, such as the name of the VM running the task and the task’s current
    status, which we can use to watch the task until it is finished. Finally, we use
    the TaskFactory.CreateTask() method ➍ to turn the JSON task returned by the API
    into a C# Task class, which we’ll create in the next section.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的第一个方法是 GetTaskDetails() 方法 ➊，它以任务 ID 作为唯一参数传入变量 id。我们首先通过将 ID 参数附加到 /tasks/view
    ➋ 来创建将进行 HTTP 请求的 URI，然后使用新的 URI 调用 ExecuteCommand() ➌。此端点返回有关任务的一些信息，例如运行任务的虚拟机名称和任务的当前状态，我们可以用这些信息来监控任务直到它完成。最后，我们使用
    TaskFactory.CreateTask() 方法 ➍ 将 API 返回的 JSON 任务转换为 C# 的 Task 类，我们将在下一节中创建该类。
- en: The second method is a simple convenience method ➎. Because Cuckoo Sandbox supports
    multiple types of reports (JSON, XML, and so on), there are two GetTaskReport()
    methods, and the first is used only for JSON reports. It just accepts the ID of
    the task you want a report for as an argument and calls its overloaded sister
    method with the same ID passed, but with a second argument specifying that a JSON
    ➏ report should be returned. In the second GetTaskReport() method ➐, the task
    ID and report type are passed as arguments and then used to build the URI ➑ that
    will be requested in the API call. The new URI is passed to the ExecuteCommand()
    method ➒, and the report from Cuckoo Sandbox is returned.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法是一个简单的便利方法 ➎。由于 Cuckoo Sandbox 支持多种报告类型（JSON、XML 等），因此有两个 GetTaskReport()
    方法，第一个只用于 JSON 报告。它只接受要获取报告的任务 ID 作为参数，并调用其重载方法，传入相同的 ID，并指定第二个参数表明应该返回 JSON ➏
    报告。在第二个 GetTaskReport() 方法 ➐ 中，任务 ID 和报告类型作为参数传递，然后用于构建将在 API 调用中请求的 URI ➑。新的
    URI 被传递给 ExecuteCommand() 方法 ➒，并返回来自 Cuckoo Sandbox 的报告。
- en: Finally, the Dispose() method ➓, which completes the IDisposable interface,
    is implemented. This method cleans up the session that we used to communicate
    with the API, assigning null to the private _session variable.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，实现了 Dispose() 方法 ➓，它完成了 IDisposable 接口。该方法清理了我们与 API 通信时使用的会话，并将私有的 _session
    变量赋值为 null。
- en: Creating the Task Abstract Class
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 创建任务抽象类
- en: Supporting the CuckooSession and CuckooManager classes is the Task class, an
    abstract class that stores most of the relevant information for a given task so
    that the information can easily be accessed as properties. [Listing 8-16](#filepos601085)
    details the abstract Task class.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 CuckooSession 和 CuckooManager 类的是 Task 类，它是一个抽象类，存储了给定任务的大部分相关信息，以便可以作为属性轻松访问。[清单
    8-16](#filepos601085) 详细介绍了抽象的 Task 类。
- en: public abstract class ➊Task
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public abstract class ➊Task
- en: '{'
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: protected ➋Task(JToken token)
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: protected ➋Task(JToken token)
- en: '{'
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (token != null)
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (token != null)
- en: '{'
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.AddedOn = ➌DateTime.Parse((string)token["added_on"]);
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.AddedOn = ➌DateTime.Parse((string)token["added_on"]);
- en: ''
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (token["completed_on"].Type != JTokenType.Null)
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (token["completed_on"].Type != JTokenType.Null)
- en: this.CompletedOn = ➍DateTime.Parse(token["completed_on"].ToObject<string>());
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.CompletedOn = ➍DateTime.Parse(token["completed_on"].ToObject<string>());
- en: ''
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Machine = (string)token["machine"];
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Machine = (string)token["machine"];
- en: this.Errors = token["errors"].ToObject<ArrayList>();
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Errors = token["errors"].ToObject<ArrayList>();
- en: this.Custom = (string)token["custom"];
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Custom = (string)token["custom"];
- en: this.EnableEnforceTimeout = (bool)token["enforce_timeout"];
  id: totrans-380
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.EnableEnforceTimeout = (bool)token["enforce_timeout"];
- en: this.EnableMemoryDump = (bool)token["memory"];
  id: totrans-381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.EnableMemoryDump = (bool)token["memory"];
- en: this.Guest = token["guest"];
  id: totrans-382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Guest = token["guest"];
- en: this.ID = (int)token["id"];
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.ID = (int)token["id"];
- en: this.Options = token["options"].ToString();
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Options = token["options"].ToString();
- en: this.Package = (string)token["package"];
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Package = (string)token["package"];
- en: this.Platform = (string)token["platform"];
  id: totrans-386
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Platform = (string)token["platform"];
- en: this.Priority = (int)token["priority"];
  id: totrans-387
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Priority = (int)token["priority"];
- en: this.SampleID = (int)token["sample_id"];
  id: totrans-388
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.SampleID = (int)token["sample_id"];
- en: this.Status = (string)token["status"];
  id: totrans-389
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Status = (string)token["status"];
- en: this.Target = (string)token["target"];
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Target = (string)token["target"];
- en: this.Timeout = (int)token["timeout"];
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Timeout = (int)token["timeout"];
- en: '}'
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Package { get; set; }
  id: totrans-395
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Package { get; set; }
- en: public int Timeout { get; set; }
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int Timeout { get; set; }
- en: public string Options { get; set; }
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Options { get; set; }
- en: public string Machine { get; set; }
  id: totrans-398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Machine { get; set; }
- en: public string Platform { get; set; }
  id: totrans-399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Platform { get; set; }
- en: public string Custom { get; set; }
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Custom { get; set; }
- en: public bool EnableMemoryDump { get; set; }
  id: totrans-401
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public bool EnableMemoryDump { get; set; }
- en: public bool EnableEnforceTimeout { get; set; }
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public bool EnableEnforceTimeout { get; set; }
- en: public ArrayList Errors { get; set; }
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public ArrayList Errors { get; set; }
- en: public string Target { get; set; }
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Target { get; set; }
- en: public int SampleID { get; set; }
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int SampleID { get; set; }
- en: public JToken Guest { get; set; }
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public JToken Guest { get; set; }
- en: public int Priority { get; set; }
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int Priority { get; set; }
- en: public string Status { get; set;}
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Status { get; set;}
- en: public int ID { get; set; }
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int ID { get; set; }
- en: public DateTime AddedOn { get; set; }
  id: totrans-410
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public DateTime AddedOn { get; set; }
- en: public DateTime CompletedOn { get; set; }
  id: totrans-411
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public DateTime CompletedOn { get; set; }
- en: '}'
  id: totrans-412
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 8-16: The abstract  Task  class'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-16：抽象的 Task 类
- en: Although the abstract Task class ➊ looks complex at first, all the class has
    is a constructor and a dozen or so properties. The constructor ➋ accepts a JToken
    as an argument, which is a special JSON class like JObject. The JToken is used
    to assign all the task details from the JSON to C# properties in the class. The
    first property we assign with a value in the constructor is the AddedOn property.
    Using DateTime.Parse() ➌, the timestamp for when the task was created is parsed
    from a string to a DateTime class, which is assigned to AddedOn. The same is done
    for the CompletedOn property, also using DateTime.Parse() ➍, if the task has been
    completed. The rest of the properties are assigned directly using values from
    the JSON that was passed as the argument to the constructor.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管抽象的Task类 ➊ 起初看起来很复杂，但该类实际上只有一个构造函数和十几个属性。构造函数 ➋ 接受一个JToken作为参数，这是一个特殊的JSON类，如JObject。JToken用于将来自JSON的所有任务细节分配给类中的C#属性。在构造函数中，第一个赋值的属性是AddedOn属性。使用DateTime.Parse()
    ➌，任务创建时的时间戳将从字符串解析为DateTime类，并分配给AddedOn属性。如果任务已完成，CompletedOn属性也会使用DateTime.Parse()
    ➍进行同样的操作。其余的属性则直接使用传递给构造函数的JSON中的值进行赋值。
- en: Sorting and Creating Different Class Types
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 排序和创建不同的类类型
- en: Cuckoo Sandbox supports more than one type of task, even though we are only
    implementing one (the file analysis task). The FileTask class will inherit from
    the abstract Task class, but it adds a new property that stores the path of the
    file we want to send to Cuckoo to analyze. The other type of task supported by
    Cuckoo is a URL task that opens a given URL in a web browser and analyzes what
    happens (in case there is a drive-by exploit or other malware on the site).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: Cuckoo Sandbox支持多种类型的任务，尽管我们只实现了其中一种（文件分析任务）。FileTask类将从抽象的Task类继承，但它添加了一个新属性，用于存储我们希望发送给Cuckoo分析的文件路径。Cuckoo支持的另一种任务是URL任务，它会在web浏览器中打开给定的URL并分析发生了什么（以防该网站存在drive-by攻击或其他恶意软件）。
- en: Creating the FileTask Class to Make File Analysis Tasks
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 创建FileTask类以执行文件分析任务
- en: The FileTask class will be used to store the information we need to kick off
    an analysis of a file. It’s short and sweet, as [Listing 8-17](#filepos603915)
    shows, since it inherits most of its properties from the Task class we just implemented.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: FileTask类将用于存储启动文件分析所需的信息。如[Listing 8-17](#filepos603915)所示，它简洁明了，因为它继承了我们刚刚实现的Task类的大部分属性。
- en: 'public class ➊FileTask : Task'
  id: totrans-419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'public class ➊FileTask : Task'
- en: '{'
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: 'public ➋FileTask() : base(null) { }'
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'public ➋FileTask() : base(null) { }'
- en: 'public ➌FileTask(JToken dict) : base(dict) { }'
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'public ➌FileTask(JToken dict) : base(dict) { }'
- en: public ➍string Filepath { get; set; }
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public ➍string Filepath { get; set; }
- en: '}'
  id: totrans-424
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 8-17: The  FileTask  class that inherits from  Task'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-17：继承自Task的FileTask类
- en: The simple FileTask class ➊, which inherits from the previous Task class, uses
    some advanced inheritance techniques available in C#. The class implements two
    different constructors, both of which pass their arguments to the base Task constructor
    as well. For instance, the first constructor ➋ accepts no arguments and passes
    a null value to the base class constructor. This allows us to keep a default constructor
    for the class that doesn’t require any arguments. The second constructor ➌, which
    accepts a single JToken class as its only argument, passes the JSON argument straight
    to the base constructor, which will populate the properties the FileTask class
    inherits from Task. This makes it easy to set up a FileTask using the JSON returned
    from the Cuckoo API. The only thing we have in the FileTask class that we don’t
    have in the generic Task class is the Filepath property ➍, which is only useful
    for submitting file analysis tasks.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的FileTask类 ➊，继承自之前的Task类，使用了C#中一些高级的继承技巧。该类实现了两个不同的构造函数，两个构造函数都会将参数传递给基类Task的构造函数。例如，第一个构造函数
    ➋ 不接受任何参数，并将null值传递给基类的构造函数。这使得我们可以为类保留一个不需要任何参数的默认构造函数。第二个构造函数 ➌ 接受一个JToken类作为唯一参数，并将JSON参数直接传递给基类构造函数，后者将填充FileTask类从Task继承的属性。这使得使用来自Cuckoo
    API的JSON轻松设置FileTask。FileTask类中唯一的属性是Filepath ➍，这是提交文件分析任务时才有用的属性，在通用Task类中没有这个属性。
- en: Using the TaskFactory Class to Determine the Task Type to Create
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TaskFactory类来确定要创建的任务类型
- en: Java developers or others familiar with object-oriented programming may already
    know about the factory pattern used in object-oriented development. It is a flexible
    way to have a single class manage the creation of many similar but ultimately
    different types of classes (usually all inheriting from the same base class, but
    they could also all be implementing the same interface). The TaskFactory class
    (shown in [Listing 8-18](#filepos607196)) is used to turn a JSON task returned
    by Cuckoo Sandbox in an API response into our C# Task class, be it a FileTask
    or otherwise—that is, if you choose to go the extra step and implement the URL
    task we described for homework!
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: Java 开发者或其他熟悉面向对象编程的人可能已经知道，工厂模式是面向对象开发中常用的设计模式。这是一种灵活的方式，通过一个类来管理许多相似但最终不同类型的类的创建（通常这些类都继承自同一个基类，但它们也可以实现相同的接口）。TaskFactory
    类（见[清单 8-18](#filepos607196)）用于将 Cuckoo Sandbox 返回的 JSON 任务转化为我们的 C# Task 类，无论是
    FileTask 还是其他类型——也就是说，如果你选择进一步实现我们为作业描述的 URL 任务！
- en: public static class ➊TaskFactory
  id: totrans-429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static class ➊TaskFactory
- en: '{'
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public static Task ➋CreateTask(JToken dict)
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static Task ➋CreateTask(JToken dict)
- en: '{'
  id: totrans-432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Task task = null;
  id: totrans-433
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Task task = null;
- en: ➌switch((string)dict["category"])
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➌switch((string)dict["category"])
- en: '{'
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: 'case ➍"file":'
  id: totrans-436
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'case ➍"file":'
- en: task = new ➎FileTask(dict);
  id: totrans-437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: task = new ➎FileTask(dict);
- en: break;
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: break;
- en: 'default:'
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'default:'
- en: 'throw new Exception("Don''t know category: " + dict["category"]);'
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'throw new Exception("未知类别: " + dict["category"]);'
- en: '}'
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return ➏task;
  id: totrans-443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return ➏task;
- en: '}'
  id: totrans-444
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 8-18: The  TaskFactory  static class, which implements a very simple
    factory pattern commonly used in object-oriented programming'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-18：TaskFactory 静态类，它实现了一个常见的简单工厂模式，通常用于面向对象编程
- en: The final class for us to implement is the TaskFactory static class ➊. This
    class is the glue that lets us turn JSON tasks from Cuckoo Sandbox into C# FileTask
    objects—and, if you choose to implement other task types in the future, you can
    also use TaskFactory to handle the creation of those tasks. The TaskFactory class
    has only a single static method called CreateTask() ➋, which accepts a JToken
    as its only argument. In the CreateTask() method, we use a switch statement ➌
    to test the value of the task category. If the category is a file task ➍, we pass
    the JToken task to the FileTask constructor ➎ and then return the new C# task
    ➏. Although we won’t use other file types in this book, you can use this switch
    statement to create a different type of Task, such as a url task based on the
    category, and then return the result.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要实现的最终类是 TaskFactory 静态类 ➊。这个类是将 Cuckoo Sandbox 中的 JSON 任务转换为 C# 的 FileTask
    对象的关键——如果你将来选择实现其他任务类型，也可以使用 TaskFactory 来处理这些任务的创建。TaskFactory 类只有一个静态方法 CreateTask()
    ➋，它接受一个 JToken 作为唯一参数。在 CreateTask() 方法中，我们使用 switch 语句 ➌ 来测试任务类别的值。如果类别是文件任务
    ➍，我们将 JToken 任务传递给 FileTask 构造函数 ➎，然后返回新的 C# 任务 ➏。尽管本书中我们不会使用其他文件类型，但你可以使用这个 switch
    语句根据任务类别创建不同类型的任务，例如基于类别的 URL 任务，然后返回结果。
- en: Putting It Together
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 整合起来
- en: Finally, we have the scaffolding in place to start automating some malware analysis.
    [Listing 8-19](#filepos611008) demonstrates using the CuckooSession and CuckooManager
    classes to create a file analysis task, watch the task until completion, and print
    the task’s JSON report to the console.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经搭建好了框架，开始自动化一些恶意软件分析。[清单 8-19](#filepos611008) 演示了如何使用 CuckooSession
    和 CuckooManager 类来创建一个文件分析任务，监视任务直到完成，并将任务的 JSON 报告打印到控制台。
- en: public static void ➊Main(string[] args)
  id: totrans-450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void ➊Main(string[] args)
- en: '{'
  id: totrans-451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: CuckooSession session = new ➋CuckooSession("127.0.0.1", 8090);
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CuckooSession session = new ➋CuckooSession("127.0.0.1", 8090);
- en: using (CuckooManager manager = new ➌CuckooManager(session))
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (CuckooManager manager = new ➌CuckooManager(session))
- en: '{'
  id: totrans-454
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: FileTask task = new ➍FileTask();
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: FileTask task = new ➍FileTask();
- en: task.➎Filepath = "/var/www/payload.exe";
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: task.➎Filepath = "/var/www/payload.exe";
- en: ''
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: int taskID = manager.➏CreateTask(task);
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: int taskID = manager.➏CreateTask(task);
- en: 'Console.WriteLine("Created task: " + taskID);'
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Console.WriteLine("创建任务: " + taskID);'
- en: ''
  id: totrans-460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: task = (FileTask)manager.➐GetTaskDetails(taskID);
  id: totrans-461
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: task = (FileTask)manager.➐GetTaskDetails(taskID);
- en: while(task.Status == "pending" || task.Status == "running")
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: while(task.Status == "pending" || task.Status == "running")
- en: '{'
  id: totrans-463
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine("Waiting 30 seconds..."+task.Status);
  id: totrans-464
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("等待 30 秒..." + task.Status);
- en: System.Threading.Thread.Sleep(30000);
  id: totrans-465
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: System.Threading.Thread.Sleep(30000);
- en: task = (FileTask)manager.GetTaskDetails(taskID);
  id: totrans-466
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: task = (FileTask)manager.GetTaskDetails(taskID);
- en: '}'
  id: totrans-467
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (task.➑Status == "failure")
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (task.➑Status == "failure")
- en: '{'
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Console.Error.WriteLine("There was an error:");
  id: totrans-471
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.Error.WriteLine("发生错误：");
- en: foreach (var error in task.Errors)
  id: totrans-472
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (var error in task.Errors)
- en: Console.Error.WriteLine(error);
  id: totrans-473
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.Error.WriteLine(error);
- en: ''
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return;
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return;
- en: '}'
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-477
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string report = manager.➒GetTaskReport(taskID).ToString();
  id: totrans-478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string report = manager.➒GetTaskReport(taskID).ToString();
- en: Console.➓WriteLine(report);
  id: totrans-479
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.➓WriteLine(report);
- en: '}'
  id: totrans-480
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-481
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 8-19: The  Main()  method bringing the  CuckooSession  and  CuckooManager  classes
    together'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 8-19: Main() 方法将 CuckooSession 和 CuckooManager 类结合起来'
- en: In the Main() method ➊, we first create a new CuckooSession instance ➋, passing
    the IP address and the port to connect to when making API requests. With the new
    session created, in the context of a using statement, we create a new CuckooManager
    object ➌ and a new FileTask object ➍ as well. We also set the Filepath property
    ➎ on the task to a path on the filesystem with an executable we want to analyze.
    For testing purposes, you can generate payloads with Metasploit’s msfvenom (as
    we did in [Chapter 4](index_split_009.html#filepos344540)) or use some of the
    payloads we wrote in [Chapter 4](index_split_009.html#filepos344540). With the
    FileTask set up with the file to scan, we pass the task to the manager’s CreateTask()
    method ➏ and store the ID returned for later use.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Main() 方法 ➊ 中，我们首先创建一个新的 CuckooSession 实例 ➋，传入用于 API 请求的 IP 地址和端口。创建新的会话后，在
    using 语句的上下文中，我们还创建一个新的 CuckooManager 对象 ➌ 和一个新的 FileTask 对象 ➍。我们还将任务的 Filepath
    属性 ➎ 设置为文件系统上包含我们要分析的可执行文件的路径。为了测试，你可以使用 Metasploit 的 msfvenom 生成有效载荷（如我们在[第 4
    章](index_split_009.html#filepos344540)中所做的那样），或者使用我们在[第 4 章](index_split_009.html#filepos344540)中编写的一些有效载荷。将
    FileTask 设置为扫描的文件后，我们将任务传递给管理器的 CreateTask() 方法 ➏，并存储返回的 ID 以供后续使用。
- en: 'Once the task has been created, we call GetTaskDetails() ➐ and pass the task
    ID returned by CreateTask(). When we call GetTaskDetails(), a status is returned
    by the method. In this case, we are interested only in two statuses: pending and
    failure. As long as GetTaskDetails() returns a pending status, we print a friendly
    message to the user that the task is not done yet and have the application sleep
    for 30 seconds before calling GetTaskDetails() for the task status again. Once
    the status is no longer pending, we check whether the status is failure ➑ in case
    something went wrong during analysis. If the status of the task is failure, we
    print the error message returned by Cuckoo Sandbox.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦任务创建完成，我们调用 GetTaskDetails() ➐ 并传入由 CreateTask() 返回的任务 ID。当我们调用 GetTaskDetails()
    时，该方法会返回一个状态。在这种情况下，我们只对两种状态感兴趣：待处理和失败。只要 GetTaskDetails() 返回待处理状态，我们就会向用户打印一个友好的消息，告知任务尚未完成，并让应用程序休眠
    30 秒后再调用 GetTaskDetails() 获取任务状态。一旦状态不再是待处理状态，我们会检查状态是否为失败 ➑，以防在分析过程中出现问题。如果任务的状态是失败，我们会打印
    Cuckoo Sandbox 返回的错误信息。
- en: However, if the status is not failure, we can assume the task successfully completed
    analysis, and we can create a new report from Cuckoo Sandbox with the findings.
    We call the GetTaskReport() method ➒, passing the task ID as the only argument,
    and then print the report to the console screen with WriteLine() ➓.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果状态不是失败，我们可以假设任务已成功完成分析，并且可以从 Cuckoo Sandbox 创建一个新报告，包含分析结果。我们调用 GetTaskReport()
    方法 ➒，传入任务 ID 作为唯一参数，然后使用 WriteLine() ➓ 将报告打印到控制台屏幕上。
- en: Testing the Application
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应用程序
- en: With the automation out of the way, we can finally drive our Cuckoo Sandbox
    instance to run and analyze a potentially nefarious Windows executable and then
    retrieve a report of the task that was run, as shown in [Listing 8-20](#filepos617041).
    Remember to run the instance as an administrator.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 通过自动化操作，我们终于可以驱动 Cuckoo Sandbox 实例运行并分析一个可能恶意的 Windows 可执行文件，然后检索运行任务的报告，如[列表
    8-20](#filepos617041)所示。记得以管理员身份运行实例。
- en: $ ./ch8_automating_cuckoo.exe
  id: totrans-488
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ ./ch8_automating_cuckoo.exe
- en: Waiting 30 seconds...pending
  id: totrans-489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 等待 30 秒...待处理
- en: '{'
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: '"info": {'
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"info": {'
- en: '"category": "file",'
  id: totrans-492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"category": "file",'
- en: '"score": 0.0,'
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"score": 0.0,'
- en: '"package": "",'
  id: totrans-494
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"package": "",'
- en: '"started": "2016-05-19 15:56:44",'
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"started": "2016-05-19 15:56:44",'
- en: '"route": "none",'
  id: totrans-496
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"route": "none",'
- en: '"custom": "",'
  id: totrans-497
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"custom": "",'
- en: '"machine": {'
  id: totrans-498
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"machine": {'
- en: '"status": "stopped",'
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"status": "stopped",'
- en: '"name": "➊cuckoo1",'
  id: totrans-500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"name": "➊cuckoo1",'
- en: '"label": "cuckoo1",'
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"label": "cuckoo1",'
- en: '"manager": "VirtualBox",'
  id: totrans-502
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"manager": "VirtualBox",'
- en: '"started_on": "2016-05-19 15:56:44",'
  id: totrans-503
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"started_on": "2016-05-19 15:56:44",'
- en: '"shutdown_on": "2016-05-19 15:57:09"'
  id: totrans-504
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"shutdown_on": "2016-05-19 15:57:09"'
- en: '},'
  id: totrans-505
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '},'
- en: '"ended": "2016-05-19 15:57:09",'
  id: totrans-506
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"ended": "2016-05-19 15:57:09",'
- en: '"version": "2.0-rc2",'
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"version": "2.0-rc2",'
- en: '"platform": "",'
  id: totrans-508
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"platform": "",'
- en: '"owner": "",'
  id: totrans-509
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"owner": "",'
- en: '"options": "",'
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"options": "",'
- en: '"id": 13,'
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"id": 13,'
- en: '"duration": 25'
  id: totrans-512
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"duration": 25'
- en: '},'
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '},'
- en: '"signatures": [],'
  id: totrans-514
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"signatures": [],'
- en: '"target": {'
  id: totrans-515
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"target": {'
- en: '"category": "file",'
  id: totrans-516
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"category": "file",'
- en: '"file": {'
  id: totrans-517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"file": {'
- en: '"yara": [],'
  id: totrans-518
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"yara": [],'
- en: '"sha1": "f145181e095285feeb6897c9a6bd2e5f6585f294",'
  id: totrans-519
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"sha1": "f145181e095285feeb6897c9a6bd2e5f6585f294",'
- en: '"name": "bypassuac-x64.exe",'
  id: totrans-520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"name": "bypassuac-x64.exe",'
- en: '"type": "PE32+ executable (console) x86-64, for MS Windows",'
  id: totrans-521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"type": "PE32+ 可执行文件（控制台） x86-64，适用于 MS Windows",'
- en: '"sha256": "➋2a694038d64bc9cfcd8caf6af35b6bfb29d2cb0c95baaeffb2a11cd6e60a73d1",'
  id: totrans-522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"sha256": "➋2a694038d64bc9cfcd8caf6af35b6bfb29d2cb0c95baaeffb2a11cd6e60a73d1",'
- en: '"urls": [],'
  id: totrans-523
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"urls": [],'
- en: '"crc32": "26FB5E54",'
  id: totrans-524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"crc32": "26FB5E54",'
- en: '"path": "/home/bperry/tmp/cuckoo/storage/binaries/2a694038d2cb0c95baaeffb2a11cd6e60a73d1",'
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"path": "/home/bperry/tmp/cuckoo/storage/binaries/2a694038d2cb0c95baaeffb2a11cd6e60a73d1",'
- en: '"ssdeep": null,'
  id: totrans-526
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"ssdeep": null,'
- en: '"size": 501248,'
  id: totrans-527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"size": 501248,'
- en: '"sha512":'
  id: totrans-528
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"sha512":'
- en: '"4b09f243a8fcd71ec5bf146002519304fdbaf99f1276da25d8eb637ecbc9cebbc49b580c51e36c96c8548a41c38cc76'
  id: totrans-529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"4b09f243a8fcd71ec5bf146002519304fdbaf99f1276da25d8eb637ecbc9cebbc49b580c51e36c96c8548a41c38cc76'
- en: 595ad1776eb9bd0b96cac17ca109d4d88",
  id: totrans-530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 595ad1776eb9bd0b96cac17ca109d4d88",
- en: '"md5": "46a695c9a3b93390c11c1c072cf9ef7d"'
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"md5": "46a695c9a3b93390c11c1c072cf9ef7d"'
- en: '}'
  id: totrans-532
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '},'
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '},'
- en: --snip--
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: --snip--
- en: 'Listing 8-20: The Cuckoo Sandbox analysis JSON report'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-20：Cuckoo Sandbox 分析 JSON 报告
- en: The analysis report from Cuckoo Sandbox is huge. It contains highly detailed
    information about what happened on the Windows system while your executable was
    running. The listing shows the basic metadata about the analysis, such as what
    machine ran the analysis ➊ and common hashes of the executable ➋. Once this report
    is dumped, we can begin to see what the malware did on an infected system and
    put together a plan for remediation and cleanup.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: Cuckoo Sandbox 的分析报告非常庞大。它包含了关于在 Windows 系统上运行你的可执行文件时发生的非常详细的信息。该列表展示了有关分析的基本元数据，如执行分析的机器
    ➊ 和可执行文件的常见哈希值 ➋。一旦报告输出完成，我们就可以开始了解恶意软件在被感染系统上所做的事情，并制定修复和清理计划。
- en: 'Note that only part of the report is included here. What is not shown is the
    immense number of Windows API and system calls that were made, the files on the
    filesystem that were touched, and other incredibly detailed system information
    that allows you to more quickly determine what a malware sample may have done
    on a client’s machine. More information can be found on what exactly is reported
    and how to use it on the official Cuckoo Sandbox documentation site: [http://docs.cuckoosandbox.org/en/latest/usage/results/](http://docs.cuckoosandbox.org/en/latest/usage/results/).'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里仅包含报告的部分内容。未显示的部分包括所做的巨大数量的 Windows API 和系统调用，操作过的文件以及其他极为详细的系统信息，这些信息可以帮助你更快地确定恶意软件样本在客户端机器上可能执行了什么。更多信息可以在
    Cuckoo Sandbox 官方文档网站找到，了解具体报告内容以及如何使用：[http://docs.cuckoosandbox.org/en/latest/usage/results/](http://docs.cuckoosandbox.org/en/latest/usage/results/).
- en: As an exercise, you can save the full report to a file instead of printing to
    the console screen, since an output file might be more desirable for future malware
    analysis!
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种练习，你可以将完整的报告保存到文件中，而不是打印到控制台屏幕上，因为输出文件可能更适合未来的恶意软件分析！
- en: Conclusion
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 结论
- en: The Cuckoo Sandbox is a powerful framework for malware analysis, and with the
    API feature, it can be easily integrated into work processes, infrastructures
    such as email servers, or even incident response playbooks. With the ability to
    run both files and arbitrary websites within a sandboxed and contained environment,
    security professionals can easily and quickly determine whether an attacker may
    have breached the network with a payload or drive-by exploit.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: Cuckoo Sandbox 是一个强大的恶意软件分析框架，借助 API 功能，它可以轻松集成到工作流程、电子邮件服务器等基础设施中，甚至是事件响应操作手册中。通过在沙箱环境中运行文件和任意网站，安全专业人员可以轻松快速地确定攻击者是否通过有效载荷或驱动器攻击渗透了网络。
- en: In this chapter, we were able to drive this functionality of Cuckoo Sandbox
    programmatically using core C# classes and libraries. We created a handful of
    classes to communicate with the API and then created tasks and reported on them
    when they were finished. However, we only implemented support for doing file-based
    malware analysis. The classes we built, though, are meant to be extensible so
    that new types of tasks can be added and supported, such as a task that submits
    a URL to be opened in the web browser.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们能够通过核心 C# 类和库编程驱动 Cuckoo Sandbox 的这一功能。我们创建了一些类与 API 进行通信，然后创建了任务，并在任务完成时报告它们。然而，我们只实现了对基于文件的恶意软件分析的支持。我们构建的类是可扩展的，因此可以添加和支持新类型的任务，例如提交一个
    URL 以在 Web 浏览器中打开的任务。
- en: With such a high-quality and useful framework available freely for all to use,
    anyone could add this functionality to their organization’s security-critical
    infrastructure and thus easily cut down the time it takes to discover and remediate
    potential breaches on home or enterprise networks.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这样一个高质量且实用的框架，所有人都可以免费使用，任何人都可以将此功能添加到其组织的安全关键基础设施中，从而轻松减少发现和修复家庭或企业网络潜在安全漏洞所需的时间。
