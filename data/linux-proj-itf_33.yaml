- en: 'Chapter 33. Threads: Further Details'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第33章：线程：更多细节
- en: This chapter provides further details on various aspects of POSIX threads. We
    discuss the interaction of threads with aspects of the traditional UNIX API—in
    particular, signals and the process control primitives (*fork()*, *exec()*, and
    *_exit()*). We also provide an overview of the two POSIX threads implementations
    available on Linux—LinuxThreads and NPTL—and note where each of these implementations
    deviates from the SUSv3 specification of Pthreads.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了关于 POSIX 线程的各个方面的更多细节。我们讨论了线程与传统 UNIX API 的交互，特别是信号和进程控制原语（*fork()*, *exec()*,
    和 *_exit()*）。我们还概述了 Linux 上可用的两种 POSIX 线程实现——LinuxThreads 和 NPTL，并指出这些实现在哪些方面偏离了
    SUSv3 规范中的 Pthreads。
- en: Thread Stacks
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程栈
- en: Each thread has its own stack whose size is fixed when the thread is created.
    On Linux/x86-32, for all threads other than the main thread, the default size
    of the per-thread stack is 2 MB. (On some 64-bit architectures, the default size
    is higher; for example, it is 32 MB on IA-64.) The main thread has a much larger
    space for stack growth (refer to [Figure 29-1](ch29.html#four_threads_executing_in_a_process_open
    "Figure 29-1. Four threads executing in a process (Linux/x86-32)"), in [Background
    Details of the Pthreads API](ch29.html#background_details_of_the_pthreads_api
    "Background Details of the Pthreads API")).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都有自己的栈，其大小在创建线程时就已固定。在 Linux/x86-32 上，除主线程外，所有线程的默认栈大小为 2 MB。（在一些 64 位架构上，默认大小较大；例如，在
    IA-64 上为 32 MB。）主线程有一个更大的栈空间用于栈增长（参考 [图29-1](ch29.html#four_threads_executing_in_a_process_open
    "图29-1：四个线程在进程中执行（Linux/x86-32）")，以及 [Pthreads API 背景细节](ch29.html#background_details_of_the_pthreads_api
    "Pthreads API 背景细节")）。
- en: Occasionally, it is useful to change the size of a thread’s stack. The *pthread_attr_setstacksize()*
    function sets a thread attribute ([Thread Attributes](ch29.html#thread_attributes
    "Thread Attributes")) that determines the size of the stack in threads created
    using the thread attributes object. The related *pthread_attr_setstack()* function
    can be used to control both the size and the location of the stack, but setting
    the location of a stack can decrease application portability. The manual pages
    provide details of these functions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，改变线程栈的大小是有用的。*pthread_attr_setstacksize()* 函数设置一个线程属性（[线程属性](ch29.html#thread_attributes
    "线程属性")），它决定了使用线程属性对象创建的线程的栈大小。相关的 *pthread_attr_setstack()* 函数可用于控制栈的大小和位置，但设置栈的位置可能会降低应用程序的可移植性。手册页提供了这些函数的详细信息。
- en: One reason to change the size of per-thread stacks is to allow for larger stacks
    for threads that allocate large automatic variables or make nested function calls
    of great depth (perhaps because of recursion). Alternatively, an application may
    want to reduce the size of per-thread stacks to allow for a greater number of
    threads within a process. For example, on x86-32, where the user-accessible virtual
    address space is 3 GB, the default stack size of 2 MB means that we can create
    a maximum of around 1500 threads. (The precise maximum depends on how much virtual
    memory is consumed by the text and data segments, shared libraries, and so on.)
    The minimum stack that can be employed on a particular architecture can be determined
    by calling *sysconf(_SC_THREAD_STACK_MIN)*. For the NPTL implementation on Linux/x86-32,
    this call returns the value 16,384.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 改变每个线程栈大小的一个原因是为分配大规模自动变量或进行深度嵌套函数调用（可能是由于递归）的线程提供更大的栈空间。或者，应用程序可能希望减少每个线程栈的大小，以便在一个进程内创建更多的线程。例如，在
    x86-32 上，用户可访问的虚拟地址空间为 3 GB，默认的栈大小为 2 MB，这意味着我们最多可以创建大约 1500 个线程。（精确的最大值取决于文本段、数据段、共享库等占用的虚拟内存量。）可以通过调用
    *sysconf(_SC_THREAD_STACK_MIN)* 来确定某个架构上可使用的最小栈大小。对于 Linux/x86-32 上的 NPTL 实现，该调用返回值为
    16,384。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Under the NPTL threading implementation, if the stack size resource limit (`RLIMIT_STACK`)
    is set to anything other than *unlimited*, then it is used as the default stack
    size when creating new threads. This limit must be set *before* the program is
    executed, typically by using the *ulimit -s* shell built-in command (*limit stacksize*
    in the C shell) before executing the program. It is not sufficient to use *setrlimit()*
    within the main program to set the limit, because NPTL makes its determination
    of the default stack size during the run-time initialization that occurs before
    *main()* is invoked.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NPTL 线程实现下，如果堆栈大小资源限制（`RLIMIT_STACK`）设置为非 *无限*，则在创建新线程时会使用该值作为默认堆栈大小。此限制必须在程序执行之前设置，通常通过在执行程序之前使用
    *ulimit -s* shell 内置命令（在 C shell 中为 *limit stacksize*）来设置。仅在主程序中使用 *setrlimit()*
    设置限制是不足够的，因为 NPTL 在运行时初始化时会在调用 *main()* 之前确定默认堆栈大小。
- en: Threads and Signals
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程与信号
- en: The UNIX signal model was designed with the UNIX process model in mind, and
    predated the arrival of Pthreads by a couple of decades. As a result, there are
    some significant conflicts between the signal and thread models. These conflicts
    arose primarily from the need to maintain the traditional signal semantics for
    single-threaded processes (i.e., the signal semantics of traditional programs
    should not be changed by Pthreads), while at the same time developing a signal
    model that would be usable within a multithreaded process.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX 信号模型是在 UNIX 进程模型的基础上设计的，并且比 Pthreads 的出现早了几十年。因此，信号模型与线程模型之间存在一些显著的冲突。这些冲突主要源于需要保持传统单线程进程的信号语义（即，传统程序的信号语义不应因
    Pthreads 的引入而改变），同时开发一个可以在多线程进程中使用的信号模型。
- en: The differences between the signal and thread models mean that combining signals
    and threads is complex, and should be avoided whenever possible. Nevertheless,
    sometimes we must deal with signals in a threaded program. In this section, we
    discuss the interactions between threads and signals, and describe various functions
    that are useful in threaded programs that deal with signals.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 信号模型与线程模型之间的差异意味着将信号与线程结合起来是复杂的，并且应尽可能避免。然而，有时我们不得不在多线程程序中处理信号。在本节中，我们讨论线程与信号之间的交互，并描述在处理信号的多线程程序中有用的各种函数。
- en: How the UNIX Signal Model Maps to Threads
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UNIX 信号模型如何映射到线程
- en: 'To understand how UNIX signals map to the Pthreads model, we need to know which
    aspects of the signal model are process-wide (i.e., are shared by all of the threads
    in the process) as opposed to those aspects that are specific to individual threads
    within the process. The following list summarizes the key points:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 UNIX 信号如何映射到 Pthreads 模型，我们需要知道哪些信号模型的方面是进程范围的（即进程中的所有线程共享的），哪些方面是特定于进程中单个线程的。以下列表总结了关键点：
- en: Signal actions are process-wide. If any unhandled signal whose default action
    is *stop* or *terminate* is delivered to any thread in a process, then all of
    the threads in the process are stopped or terminated.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号动作是进程范围的。如果任何未处理的信号，其默认动作是 *停止* 或 *终止*，并被发送到进程中的任何线程，那么该进程中的所有线程都将被停止或终止。
- en: Signal dispositions are process-wide; all threads in a process share the same
    disposition for each signal. If one thread uses *sigaction()* to establish a handler
    for, say, `SIGINT`, then that handler may be invoked from any thread to which
    the `SIGINT` is delivered. Similarly, if one thread sets the disposition of a
    signal to *ignore*, then that signal is ignored by all threads.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号的处理方式是进程范围的；进程中的所有线程共享每个信号的相同处理方式。如果某个线程使用 *sigaction()* 设置了一个处理程序，例如 `SIGINT`，那么该处理程序可能会从任何接收到
    `SIGINT` 信号的线程中调用。同样，如果某个线程将信号的处理方式设置为 *忽略*，那么所有线程都会忽略该信号。
- en: 'A signal may be directed to either the process as a whole or to a specific
    thread. A signal is thread-directed if:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号可以被发送到整个进程或特定的线程。如果信号是线程特定的，则其生成方式如下：
- en: 'it is generated as the direct result of the execution of a specific hardware
    instruction within the context of the thread (i.e., the hardware exceptions described
    in [Hardware-Generated Signals](ch22.html#hardware-generated_signals "Hardware-Generated
    Signals"): `SIGBUS`, `SIGFPE`, `SIGILL`, and `SIGSEGV`);'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是由特定硬件指令在该线程上下文中执行的直接结果生成的（即，[硬件生成的信号](ch22.html#hardware-generated_signals
    "硬件生成的信号")中描述的硬件异常：`SIGBUS`、`SIGFPE`、`SIGILL` 和 `SIGSEGV`）；
- en: it is a `SIGPIPE` signal generated when the thread tried to write to a broken
    pipe; or
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个 `SIGPIPE` 信号，当线程尝试写入一个破损的管道时生成；或者
- en: it is sent using *pthread_kill()* or *pthread_sigqueue()*, which are functions
    (described in [Sending a Signal to a Thread](ch33.html#sending_a_signal_to_a_thread
    "Sending a Signal to a Thread")) that allow one thread to send a signal to another
    thread within the same process.
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是通过 *pthread_kill()* 或 *pthread_sigqueue()* 发送的，这些是允许一个线程向同一进程内的另一个线程发送信号的函数（描述请见
    [向线程发送信号](ch33.html#sending_a_signal_to_a_thread "Sending a Signal to a Thread")）。
- en: All signals generated by other mechanisms are process-directed. Examples are
    signals sent from another process using *kill()* or *sigqueue()*; signals such
    as `SIGINT` and `SIGTSTP`, generated when the user types one of the terminal special
    characters that generate a signal; and signals generated for software events such
    as the resizing of a terminal window (`SIGWINCH`) or the expiration of a timer
    (e.g., `SIGALRM`).
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有由其他机制生成的信号都是进程级信号。例如，通过 *kill()* 或 *sigqueue()* 从另一个进程发送的信号；用户输入生成信号的终端特殊字符时产生的
    `SIGINT` 和 `SIGTSTP` 信号；以及为软件事件生成的信号，如终端窗口调整大小时的 `SIGWINCH` 或定时器到期时的信号（例如 `SIGALRM`）。
- en: When a signal is delivered to a multithreaded process that has established a
    signal handler, the kernel arbitrarily selects one thread in the process to which
    to deliver the signal and invokes the handler in that thread. This behavior is
    consistent with maintaining the traditional signal semantics. It would not make
    sense for a process to perform the signal handling actions multiple times in response
    to a single signal.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当信号传递到一个已经建立了信号处理程序的多线程进程时，内核会任意选择该进程中的一个线程来传递信号，并在该线程中调用处理程序。这种行为与维持传统信号语义是一致的。对于一个进程来说，响应单一信号多次执行信号处理操作是没有意义的。
- en: The signal mask is per-thread. (There is no notion of a process-wide signal
    mask that governs all threads in a multithreaded process.) Threads can independently
    block or unblock different signals using *pthread_sigmask()*, a new function defined
    by the Pthreads API. By manipulating the per-thread signal masks, an application
    can control which thread(s) may handle a signal that is directed to the whole
    process.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号屏蔽是按线程进行的。（不存在一个针对多线程进程中所有线程的进程级信号屏蔽。）线程可以通过 *pthread_sigmask()*（Pthreads
    API 中定义的一个新函数）独立地屏蔽或解除屏蔽不同的信号。通过操作每个线程的信号屏蔽，应用程序可以控制哪个线程（或哪些线程）可以处理针对整个进程的信号。
- en: The kernel maintains a record of the signals that are pending for the process
    as a whole, as well as a record of the signals that are pending for each thread.
    A call to *sigpending()* returns the union of the set of signals that are pending
    for the process and those that are pending for the calling thread. In a newly
    created thread, the per-thread set of pending signals is initially empty. A thread-directed
    signal can be delivered only to the target thread. If the thread is blocking the
    signal, it will remain pending until the thread unblocks the signal (or terminates).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核维护着针对整个进程和每个线程的待处理信号记录。调用 *sigpending()* 返回待处理的进程信号和调用线程的待处理信号的并集。在新创建的线程中，每个线程的待处理信号集合最初是空的。线程级信号只能传递给目标线程。如果该线程屏蔽了信号，则信号将保持待处理状态，直到线程解除屏蔽该信号（或终止）。
- en: If a signal handler interrupts a call to *pthread_mutex_lock()*, then the call
    is always automatically restarted. If a signal handler interrupts a call to *pthread_cond_wait()*,
    then the call either is restarted automatically (this is what Linux does) or returns
    0, indicating a spurious wake-up (in which case a well-designed application will
    recheck the corresponding predicate and restart the call, as described in [Testing
    a Condition Variable’s Predicate](ch30.html#testing_a_condition_variable_number_symb
    "Testing a Condition Variable’s Predicate")). SUSv3 requires these two functions
    to behave as described here.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果信号处理程序中断了对 *pthread_mutex_lock()* 的调用，那么该调用将始终自动重新启动。如果信号处理程序中断了对 *pthread_cond_wait()*
    的调用，那么该调用要么自动重新启动（这就是 Linux 的行为），要么返回 0，表示发生了虚假唤醒（在这种情况下，设计良好的应用程序会重新检查相应的谓词并重新启动调用，详情请见
    [测试条件变量的谓词](ch30.html#testing_a_condition_variable_number_symb "Testing a Condition
    Variable’s Predicate")）。SUSv3 要求这两个函数按这里描述的方式行为。
- en: 'The alternate signal stack is per-thread (refer to the description of *sigaltstack()*
    in [Handling a Signal on an Alternate Stack: *sigaltstack()*](ch21.html#handling_a_signal_on_an_alternate_stack
    "Handling a Signal on an Alternate Stack: sigaltstack()")). A newly created thread
    doesn’t inherit the alternate signal stack from its creator.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替代信号堆栈是每个线程独立的（参考[sigaltstack()的描述](ch21.html#handling_a_signal_on_an_alternate_stack
    "处理替代堆栈上的信号：sigaltstack()")）。新创建的线程不会继承其创建者的替代信号堆栈。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More precisely, SUSv3 specifies that there is a separate alternate signal stack
    for each kernel scheduling entity (KSE). On a system with a 1:1 threading implementation,
    as on Linux, there is one KSE per thread (see [Thread Implementation Models](ch33.html#thread_implementation_models
    "Thread Implementation Models")).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说，SUSv3指定每个内核调度实体（KSE）都有一个单独的替代信号堆栈。在具有1:1线程实现的系统中（如Linux），每个线程都有一个KSE（参见[线程实现模型](ch33.html#thread_implementation_models
    "线程实现模型")）。
- en: Manipulating the Thread Signal Mask
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作线程信号屏蔽字
- en: When a new thread is created, it inherits a copy of the signal mask of the thread
    that created it. A thread can use *pthread_sigmask()* to change its signal mask,
    to retrieve the existing mask, or both.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新线程时，它会继承创建它的线程的信号屏蔽字的副本。线程可以使用*pthread_sigmask()*来更改其信号屏蔽字，检索现有的屏蔽字，或同时执行这两者。
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or a positive error number on error
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回正数错误码
- en: Other than the fact that it operates on the thread signal mask, the use of *pthread_sigmask()*
    is the same as the use of *sigprocmask()* ([The Signal Mask (Blocking Signal Delivery)](ch20.html#the_signal_mask_open_parenthesis_blockin
    "The Signal Mask (Blocking Signal Delivery)")).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了它操作线程信号屏蔽字这一事实，*pthread_sigmask()*的使用与*sigprocmask()*的使用相同（[信号屏蔽字（阻塞信号传递）](ch20.html#the_signal_mask_open_parenthesis_blockin
    "信号屏蔽字（阻塞信号传递）")）。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 notes that the use of *sigprocmask()* within a multithreaded program is
    unspecified. We can’t portably employ *sigprocmask()* in a multithreaded program.
    In practice, *sigprocmask()* and *pthread_sigmask()* are identical on many implementations,
    including Linux.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3指出，在多线程程序中使用*sigprocmask()*是未指定的。我们不能在多线程程序中便捷地使用*sigprocmask()*。在实践中，*sigprocmask()*和*pthread_sigmask()*在许多实现中是相同的，包括Linux。
- en: Sending a Signal to a Thread
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向线程发送信号
- en: The *pthread_kill()* function sends the signal *sig* to another thread in the
    same process. The target thread is identified by the argument *thread*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_kill()*函数将信号*sig*发送到同一进程中的另一个线程。目标线程由*thread*参数标识。'
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or a positive error number on error
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回正数错误码
- en: Because a thread ID is guaranteed to be unique only within a process (see [Thread
    IDs](ch29.html#thread_ids "Thread IDs")), we can’t use *pthread_kill()* to send
    a signal to a thread in another process.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因为线程ID仅在进程内保证唯一（见[线程ID](ch29.html#thread_ids "线程ID")），所以我们不能使用*pthread_kill()*向另一个进程中的线程发送信号。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *pthread_kill()* function is implemented using the Linux-specific *tgkill(tgid,
    tid, sig)* system call, which sends the signal *sig* to the thread identified
    by *tid* (a kernel thread ID of the type returned by *gettid()*) within the thread
    group identified by *tgid*. See the *tgkill(2)* manual page for further details.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_kill()*函数通过Linux特有的*tgkill(tgid, tid, sig)*系统调用实现，该调用将信号*sig*发送到由*tid*标识的线程（由*gettid()*返回的内核线程ID）在由*tgid*标识的线程组内。有关详细信息，请参见*tgkill(2)*手册页。'
- en: 'The Linux-specific *pthread_sigqueue()* function combines the functionality
    of *pthread_kill()* and *sigqueue()* ([Limits on the number of queued realtime
    signals](ch22.html#limits_on_the_number_of_queued_real-id1 "Limits on the number
    of queued realtime signals")): it sends a signal with accompanying data to another
    thread in the same process.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Linux特有的*pthread_sigqueue()*函数结合了*pthread_kill()*和*sigqueue()*的功能（[队列中实时信号的数量限制](ch22.html#limits_on_the_number_of_queued_real-id1
    "队列中实时信号的数量限制")）：它向同一进程中的另一个线程发送带有附加数据的信号。
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or a positive error number on error
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回正数错误码
- en: As with *pthread_kill()*, *sig* specifies the signal to be sent, and *thread*
    identifies the target thread. The *value* argument specifies the data to accompany
    the signal, and is used in the same way as the equivalent argument of *sigqueue()*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与*pthread_kill()*类似，*sig*指定要发送的信号，*thread*标识目标线程。*value*参数指定信号的附加数据，并以与*sigqueue()*的等效参数相同的方式使用。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *pthread_sigqueue()* function was added to *glibc* in version 2.11 and requires
    support from the kernel. This support is provided by the *rt_tgsigqueueinfo()*
    system call, which was added in Linux 2.6.31.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_sigqueue()* 函数在 *glibc* 2.11 版本中添加，并需要内核的支持。这个支持由 *rt_tgsigqueueinfo()*
    系统调用提供，该调用在 Linux 2.6.31 中引入。'
- en: Dealing with Asynchronous Signals Sanely
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理智地处理异步信号
- en: 'In [Chapter 20](ch20.html "Chapter 20. Signals: Fundamental Concepts") to [Chapter 22](ch22.html
    "Chapter 22. Signals: Advanced Features"), we discussed various factors—such as
    reentrancy issues, the need to restart interrupted system calls, and avoiding
    race conditions—that can make it complex to deal with asynchronously generated
    signals via signal handlers. Furthermore, none of the functions in the Pthreads
    API is among the set of async-signal-safe functions that we can safely call from
    within a signal handler ([Reentrant and Async-Signal-Safe Functions](ch21.html#reentrant_and_async-signal-safe_function
    "Reentrant and Async-Signal-Safe Functions")). For these reasons, multithreaded
    programs that must deal with asynchronously generated signals generally should
    not use a signal handler as the mechanism to receive notification of signal delivery.
    Instead, the preferred approach is the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第20章](ch20.html "第20章. 信号：基础概念") 到 [第22章](ch22.html "第22章. 信号：高级特性") 中，我们讨论了各种因素——如可重入问题、需要重新启动中断的系统调用以及避免竞争条件——这些问题使得通过信号处理程序处理异步生成的信号变得复杂。此外，Pthreads
    API 中的函数都不属于我们可以安全地从信号处理程序中调用的异步信号安全函数集合（[可重入和异步信号安全函数](ch21.html#reentrant_and_async-signal-safe_function
    "可重入和异步信号安全函数")）。因此，必须处理异步生成信号的多线程程序通常不应使用信号处理程序作为接收信号传递通知的机制。相反，推荐的方法是：
- en: All threads block all of the asynchronous signals that the process might receive.
    The simplest way to do this is to block the signals in the main thread before
    any other threads are created. Each subsequently created thread will inherit a
    copy of the main thread’s signal mask.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有线程会阻塞进程可能接收到的所有异步信号。实现这一点最简单的方法是在创建任何其他线程之前，在主线程中阻塞这些信号。之后创建的每个线程将继承主线程的信号掩码副本。
- en: Create a single dedicated thread that accepts incoming signals using *sigwaitinfo()*,
    *sigtimedwait()*, or *sigwait()*. We described *sigwaitinfo()* and *sigtimedwait()*
    in [Synchronously Waiting for a Signal](ch22.html#synchronously_waiting_for_a_signal
    "Synchronously Waiting for a Signal"). We describe *sigwait()* below.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个专用线程，使用 *sigwaitinfo()*、*sigtimedwait()* 或 *sigwait()* 接受传入的信号。我们在 [同步等待信号](ch22.html#synchronously_waiting_for_a_signal
    "同步等待信号") 中描述了 *sigwaitinfo()* 和 *sigtimedwait()*。下面我们将描述 *sigwait()*。
- en: The advantage of this approach is that asynchronously generated signals are
    received synchronously. As it accepts incoming signals, the dedicated thread can
    safely modify shared variables (under mutex control) and call non-async-signal-safe
    functions. It can also signal condition variables, and employ other thread and
    process communication and synchronization mechanisms.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是异步生成的信号以同步方式接收。当它接受到传入的信号时，专用线程可以安全地修改共享变量（在互斥锁控制下）并调用非异步信号安全函数。它还可以信号条件变量，并使用其他线程和进程通信与同步机制。
- en: The *sigwait()* function waits for the delivery of one of the signals in the
    signal set pointed to by *set*, accepts that signal, and returns it in *sig*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*sigwait()* 函数等待传递到 *set* 指向的信号集中的一个信号，接受该信号，并将其返回到 *sig* 中。'
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or a positive error number on error
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回一个正的错误号码
- en: 'The operation of *sigwait()* is the same as *sigwaitinfo()*, except that:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*sigwait()* 的操作与 *sigwaitinfo()* 相同，不同之处在于：'
- en: instead of returning a *siginfo_t* structure describing the signal, *sigwait()*
    returns just the signal number; and
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*sigwait()* 不会返回描述信号的 *siginfo_t* 结构，而仅返回信号号码；并且'
- en: the return value is consistent with other thread-related functions (rather than
    the 0 or -1 returned by traditional UNIX system calls).
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值与其他线程相关的函数一致（而不是传统 UNIX 系统调用返回的 0 或 -1）。
- en: If multiple threads are waiting for the same signal with *sigwait()*, only one
    of the threads will actually accept the signal when it arrives. Which of the threads
    this will be is indeterminate.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个线程正在等待同一个信号并使用 *sigwait()*，当信号到达时，只有一个线程会实际接受到信号。哪个线程会接受信号是不确定的。
- en: Threads and Process Control
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程与进程控制
- en: Like the signals mechanism, *exec()*, *fork()*, and *exit()* predate the Pthreads
    API. In the following paragraphs, we note some details concerning the use of these
    system calls in threaded programs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 和信号机制一样，*exec()*, *fork()*, 和 *exit()* 在 Pthreads API 之前就已存在。在接下来的段落中，我们将提到一些关于在多线程程序中使用这些系统调用的细节。
- en: Threads and *exec()*
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 线程与 *exec()*
- en: When any thread calls one of the *exec()* functions, the calling program is
    completely replaced. All threads, except the one that called *exec()*, vanish
    immediately. None of the threads executes destructors for thread-specific data
    or calls cleanup handlers. All of the (process-private) mutexes and condition
    variables belonging to the process also disappear. After an *exec()*, the thread
    ID of the remaining thread is unspecified.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何线程调用 *exec()* 函数时，调用的程序会被完全替换。除调用 *exec()* 的线程外，所有线程都会立即消失。没有线程会执行线程特定数据的析构函数或调用清理处理程序。进程中所有的（进程私有）互斥锁和条件变量也会消失。在
    *exec()* 之后，剩余线程的线程 ID 未指定。
- en: Threads and *fork()*
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 线程与 *fork()*
- en: 'When a multithreaded process calls *fork()*, only the calling thread is replicated
    in the child process. (The ID of the thread in the child is the same as the ID
    of the thread that called *fork()* in the parent.) All of the other threads vanish
    in the child; no thread-specific data destructors or cleanup handlers are executed
    for those threads. This can lead to various problems:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个多线程进程调用 *fork()* 时，只有调用线程会在子进程中被复制。（子进程中的线程 ID 与调用 *fork()* 的父进程中的线程 ID 相同。）子进程中所有其他线程都会消失；对于这些线程，不会执行线程特定数据的析构函数或清理处理程序。这可能会导致各种问题：
- en: Although only the calling thread is replicated in the child, the states of global
    variables, as well as all Pthreads objects such as mutexes and condition variables,
    are preserved in the child. (This is so because these Pthreads objects are allocated
    within the parent’s memory, and the child gets a duplicate of that memory.) This
    can lead to tricky scenarios. For example, suppose that another thread had locked
    a mutex at the time of the *fork()* and is part-way through updating a global
    data structure. In this case, the thread in the child would not be able to unlock
    the mutex (since it is not the mutex owner) and would block if it tried to acquire
    the mutex. Furthermore, the child’s copy of the global data structure is probably
    in an inconsistent state, because the thread that was updating it vanished part-way
    through the update.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管只有调用线程会在子进程中被复制，但全局变量的状态以及所有 Pthreads 对象（如互斥锁和条件变量）都会在子进程中得到保留。（这是因为这些 Pthreads
    对象分配在父进程的内存中，子进程会获得该内存的副本。）这可能会导致一些棘手的情况。例如，假设在执行 *fork()* 时，另一个线程已经锁定了一个互斥锁，并且正在部分更新一个全局数据结构。在这种情况下，子进程中的线程将无法解锁该互斥锁（因为它不是互斥锁的所有者），如果尝试获取互斥锁，则会阻塞。此外，子进程中全局数据结构的副本可能处于不一致的状态，因为正在更新它的线程在更新过程中消失了。
- en: Since destructors for thread-specific data and cleanup handlers are not called,
    a *fork()* in a multithreaded program can cause memory leaks in the child. Furthermore,
    the thread-specific data items created by other threads are likely to be inaccessible
    to the thread in the new child, since it doesn’t have pointers referring to these
    items.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于线程特定数据的析构函数和清理处理程序不会被调用，在多线程程序中执行 *fork()* 可能会导致子进程出现内存泄漏。此外，由其他线程创建的线程特定数据项可能无法在新子进程中的线程中访问，因为它没有指向这些数据项的指针。
- en: Because of these problems, the usual recommendation is that the only use of
    *fork()* in a multithreaded process should be one that is followed by an immediate
    *exec()*. The *exec()* causes all of the Pthreads objects in the child process
    to disappear as the new program overwrites the memory of the process.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些问题，通常的建议是在多线程进程中，*fork()* 之后应立即执行 *exec()*。*exec()* 会导致子进程中的所有 Pthreads
    对象消失，因为新程序会覆盖进程的内存。
- en: 'For programs that must use a *fork()* that is not followed by an *exec()*,
    the Pthreads API provides a mechanism for defining *fork handlers*. Fork handlers
    are established using a *pthread_atfork()* call of the following form:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于必须使用 *fork()* 但不跟随 *exec()* 的程序，Pthreads API 提供了一种机制来定义 *fork handlers*。可以通过以下形式的
    *pthread_atfork()* 调用来设置 fork 处理程序：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each *pthread_atfork()* call adds *prepare_func* to a list of functions that
    will be automatically executed (in reverse order of registration) before the new
    child process is created when *fork()* is called. Similarly, *parent_func* and
    *child_func* are added to a list functions that will be called automatically (in
    order of registration), in, respectively, the parent and child process, just before
    *fork()* returns.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 *pthread_atfork()* 都会将 *prepare_func* 添加到一个函数列表中，这些函数将在调用 *fork()* 时，在创建新的子进程之前自动执行（按照注册顺序的逆序执行）。类似地，*parent_func*
    和 *child_func* 会被添加到一个函数列表中，这些函数会在 *fork()* 返回之前，分别在父进程和子进程中自动调用（按照注册顺序执行）。
- en: Fork handlers are sometimes useful for library code that makes use of threads.
    In the absence of fork handlers, there would be no way for the library to deal
    with applications that naively make use of the library and call *fork()*, unaware
    that the library has created some threads.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Fork 处理程序有时对于使用线程的库代码很有用。如果没有 fork 处理程序，库就无法处理那些天真地使用该库并调用 *fork()* 的应用程序，因它们没有意识到该库已经创建了一些线程。
- en: The child produced by *fork()* inherits fork handlers from the thread that called
    *fork()*. During an *exec()*, fork handlers are not preserved (they can’t be,
    since the code of the handlers is overwritten during the *exec()*).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由 *fork()* 创建的子进程会继承调用 *fork()* 的线程的 fork 处理程序。在 *exec()* 过程中，fork 处理程序不会被保留（它们不能被保留，因为处理程序的代码在
    *exec()* 过程中会被覆盖）。
- en: Further details on fork handlers, and examples of their use, can be found in
    [Butenhof, 1996].
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 fork 处理程序的更多细节，以及它们使用的示例，可以参考 [Butenhof, 1996]。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux, fork handlers are not called if a program using the NPTL threading
    library calls *vfork()*. However, in a program using LinuxThreads, fork handlers
    are called in this case.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，如果一个使用 NPTL 线程库的程序调用了 *vfork()*，则不会调用 fork 处理程序。然而，在使用 LinuxThreads
    的程序中，在这种情况下会调用 fork 处理程序。
- en: Threads and *exit()*
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 线程与 *exit()*
- en: If any thread calls *exit()* or, equivalently, the main thread does a `return`,
    all threads immediately vanish; no thread-specific data destructors or cleanup
    handlers are executed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何线程调用 *exit()* 或者主线程执行 `return`，所有线程会立即消失；不会执行任何线程特定的数据析构函数或清理处理程序。
- en: Thread Implementation Models
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程实现模型
- en: In this section, we go into some theory, briefly considering three different
    models for implementing a threading API. This provides useful background for [Linux
    Implementations of POSIX Threads](ch33.html#linux_implementations_of_posix_threads
    "Linux Implementations of POSIX Threads"), where we consider the Linux threading
    implementations. The differences between these implementation models hinge on
    how threads are mapped onto *kernel scheduling entities* (KSEs), which are the
    units to which the kernel allocates the CPU and other system resources. (In traditional
    UNIX implementations that predate threads, the term *kernel scheduling entity*
    is synonymous with the term *process*.)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们简要地讨论了三种不同的线程 API 实现模型。这为 [Linux 实现 POSIX 线程](ch33.html#linux_implementations_of_posix_threads
    "Linux 实现 POSIX 线程") 提供了有用的背景，后者我们将考虑 Linux 的线程实现。这些实现模型之间的区别在于线程如何映射到 *内核调度实体*（KSEs），这些实体是内核为其分配
    CPU 和其他系统资源的单位。（在传统的 UNIX 实现中，线程出现之前，*内核调度实体* 这一术语与 *进程* 一词是同义的。）
- en: Many-to-one (M:1) implementations (user-level threads)
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多对一（M:1）实现（用户级线程）
- en: In M:1 threading implementations, all of the details of thread creation, scheduling,
    and synchronization (mutex locking, waiting on condition variables, and so on)
    are handled entirely within the process by a user-space threading library. The
    kernel knows nothing about the existence of multiple threads within the process.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 M:1 线程实现中，所有线程的创建、调度和同步（互斥锁、等待条件变量等）细节完全由用户空间的线程库处理。内核对于进程中多个线程的存在一无所知。
- en: M:1 implementations have a few advantages. The greatest advantage is that many
    threading operations—for example, creating and terminating a thread, context switching
    between threads, and mutex and condition variable operations—are fast, since a
    switch to kernel mode is not required. Furthermore, since kernel support for the
    threading library is not required, an M:1 implementation can be relatively easily
    ported from one system to another.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: M:1 实现有一些优点。最大的优点是许多线程操作——例如，创建和终止线程、线程之间的上下文切换，以及互斥锁和条件变量操作——都很快速，因为不需要切换到内核模式。此外，由于不需要内核对线程库的支持，M:1
    实现可以相对容易地从一个系统移植到另一个系统。
- en: 'However, M:1 implementations suffer from some serious disadvantages:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，M:1实现存在一些严重的缺点：
- en: When a thread makes a system call such as *read()*, control passes from the
    user-space threading library to the kernel. This means that if the *read()* call
    blocks, then all threads in the process are blocked.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个线程执行像*read()*这样的系统调用时，控制权从用户空间线程库转交给内核。这意味着，如果*read()*调用阻塞，进程中的所有线程都会被阻塞。
- en: The kernel can’t schedule the threads of a process. Since the kernel is unaware
    of the existence of multiple threads within the process, it can’t schedule the
    separate threads to different processors on multiprocessor hardware. Nor is it
    possible to meaningfully assign a thread in one process a higher priority than
    a thread in another process, since the scheduling of the threads is handled entirely
    within the process.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核无法调度进程的线程。由于内核无法感知进程中多个线程的存在，它无法将不同的线程调度到多处理器硬件上的不同处理器上。也无法在不同进程之间有意义地为某个线程分配比其他进程中的线程更高的优先级，因为线程的调度完全由进程内处理。
- en: One-to-one (1:1) implementations (kernel-level threads)
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一对一（1:1）实现（内核级线程）
- en: In a 1:1 threading implementation, each thread maps onto a separate KSE. The
    kernel handles each thread’s scheduling separately. Thread synchronization operations
    are implemented using system calls into the kernel.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在1:1线程实现中，每个线程映射到一个独立的KSE。内核单独处理每个线程的调度。线程同步操作通过系统调用实现。
- en: 1:1 implementations eliminate the disadvantages suffered by M:1 implementations.
    A blocking system call does not cause all of the threads in a process to block,
    and the kernel can schedule the threads of a process onto different CPUs on multiprocessor
    hardware.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 1:1实现消除了M:1实现所面临的缺点。一个阻塞的系统调用不会导致进程中的所有线程都被阻塞，内核可以将进程的线程调度到多处理器硬件上的不同CPU。
- en: However, operations such as thread creation, context switching, and synchronization
    are slower on a 1:1 implementations, since a switch into kernel mode is required.
    Furthermore, the overhead required to maintain a separate KSE for each of the
    threads in an application that contains a large number of threads may place a
    significant load on the kernel scheduler, degrading overall system performance.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，1:1实现中的线程创建、上下文切换和同步等操作较慢，因为需要切换到内核模式。此外，对于包含大量线程的应用程序来说，维护每个线程的独立KSE所需的开销可能会对内核调度程序造成较大负担，进而降低整体系统性能。
- en: Despite these disadvantages, a 1:1 implementation is usually preferred over
    an M:1 implementation. Both of the Linux threading implementations—LinuxThreads
    and NPTL—employ the 1:1 model.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些缺点，1:1实现通常比M:1实现更受青睐。Linux的两种线程实现——LinuxThreads和NPTL——都采用了1:1模型。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: During the development of NPTL, significant effort went into rewriting the kernel
    scheduler and devising a threading implementation that would allow the efficient
    execution of multithreaded processes containing many thousands of threads. Subsequent
    testing showed that this goal was achieved.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在NPTL的开发过程中，进行了大量的工作来重写内核调度程序，并设计一种线程实现，能够高效地执行包含成千上万线程的多线程进程。随后的测试表明，这一目标已成功实现。
- en: Many-to-many (M:N) implementations (two-level model)
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多对多（M:N）实现（两级模型）
- en: M:N implementations aim to combine the advantages of the 1:1 and M:1 models,
    while eliminating their disadvantages.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: M:N实现旨在结合1:1和M:1模型的优点，同时消除它们的缺点。
- en: In the M:N model, each process can have multiple associated KSEs, and several
    threads may map to each KSE. This design permits the kernel to distribute the
    threads of an application across multiple CPUs, while eliminating the possible
    scaling problems associated with applications that employ large numbers of threads.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在M:N模型中，每个进程可以拥有多个关联的KSE（内核线程实体），且每个KSE可以映射多个线程。这种设计使得内核可以将应用程序的线程分配到多个CPU上，同时避免了大量线程的应用程序可能面临的扩展问题。
- en: The most significant disadvantage of the M:N model is complexity. The task of
    thread scheduling is shared between the kernel and the user-space threading library,
    which must cooperate and communicate information with one another. Managing signals
    according to the requirements of SUSv3 is also complex under an M:N implementation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: M:N模型的最大缺点是复杂性。线程调度的任务在内核和用户空间线程库之间共享，这两者必须合作并相互传递信息。在M:N实现中，根据SUSv3的要求管理信号也非常复杂。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An M:N implementation was initially considered for the NPTL threading implementation,
    but rejected as requiring changes to the kernel that were too wide ranging and
    perhaps unnecessary, given the ability of the Linux scheduler to scale well, even
    when dealing with large numbers of KSEs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最初考虑过为 NPTL 线程实现采用 M:N 方案，但由于这种实现需要对内核进行广泛的修改，而这种修改可能并不必要，尤其是在 Linux 调度程序即使在处理大量
    KSE 时也能很好地扩展的情况下，因此被 rejected。
- en: Linux Implementations of POSIX Threads
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux 的 POSIX 线程实现
- en: 'Linux has two main implementations of the Pthreads API:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 有两个主要的 Pthreads API 实现：
- en: '*LinuxThreads*: This is the original Linux threading implementation, developed
    by Xavier Leroy.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*LinuxThreads*：这是最初的 Linux 线程实现，由 Xavier Leroy 开发。'
- en: '*NPTL (Native POSIX Threads Library)*: This is the modern Linux threading implementation,
    developed by Ulrich Drepper and Ingo Molnar as a successor to LinuxThreads. NPTL
    provides performance that is superior to LinuxThreads, and it adheres more closely
    to the SUSv3 specification for Pthreads. Support for NPTL required changes to
    the kernel, and these changes appeared in Linux 2.6.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NPTL（原生 POSIX 线程库）*：这是现代的 Linux 线程实现，由 Ulrich Drepper 和 Ingo Molnar 开发，作为
    LinuxThreads 的继任者。NPTL 提供的性能优于 LinuxThreads，并且更严格遵循 SUSv3 对 Pthreads 的规范。NPTL
    的支持需要对内核进行更改，这些更改出现在 Linux 2.6 中。'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a while, it appeared that the successor to LinuxThreads would be another
    implementation, called Next Generation POSIX Threads (NGPT), a threading implementation
    developed at IBM. NGPT employed an M:N design and performed significantly better
    than LinuxThreads. However, the NPTL developers decided to pursue a new implementation.
    This approach was justified—the 1:1-design NPTL was shown to perform better than
    NGPT. Following the release of NPTL, development of NGPT was discontinued.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经一度，LinuxThreads 的继任者被认为是另一种实现，名为下一代 POSIX 线程（NGPT），这是一种在 IBM 开发的线程实现。NGPT
    使用 M:N 设计，性能明显优于 LinuxThreads。然而，NPTL 开发者决定追求新的实现。这种方法是有充分理由的——1:1 设计的 NPTL 被证明比
    NGPT 性能更好。NPTL 发布后，NGPT 的开发被终止。
- en: In the following sections, we consider further details of these two implementations,
    and note the points where they deviate from the SUSv3 requirements for Pthreads.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将进一步讨论这两种实现的详细信息，并指出它们偏离 SUSv3 对 Pthreads 的要求的地方。
- en: At this point, it is worth emphasizing that the LinuxThreads implementation
    is now obsolete; it is not supported in *glibc* 2.4 and later. All new thread
    library development occurs only in NPTL.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，值得强调的是，LinuxThreads 实现现在已经过时；在 *glibc* 2.4 及更高版本中不再支持。所有新的线程库开发仅在 NPTL 中进行。
- en: LinuxThreads
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LinuxThreads
- en: 'For many years, LinuxThreads was the main threading implementation on Linux,
    and it was sufficient for implementing a variety of threaded applications. The
    essentials of the LinuxThreads implementation are as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，LinuxThreads 是 Linux 上主要的线程实现，它足以实现各种线程应用程序。LinuxThreads 实现的核心内容如下：
- en: 'Threads are created using a *clone()* call that specifies the following flags:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程通过 *clone()* 调用创建，并指定以下标志：
- en: '[PRE5]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This means that LinuxThreads threads share virtual memory, file descriptors,
    file system-related information (umask, root directory, and current working directory),
    and signal dispositions. However, threads don’t share process IDs and parent process
    IDs.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着 LinuxThreads 线程共享虚拟内存、文件描述符、与文件系统相关的信息（如 umask、根目录和当前工作目录）以及信号处理。然而，线程之间不会共享进程
    ID 和父进程 ID。
- en: In addition to the threads created by the application, LinuxThreads creates
    an additional “manager” thread that handles thread creation and termination.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了应用程序创建的线程外，LinuxThreads 还会创建一个额外的“管理”线程，负责处理线程的创建和终止。
- en: The implementation uses signals for its internal operation. With kernels that
    support realtime signals (Linux 2.2 and later), the first three realtime signals
    are used. With older kernels, `SIGUSR1` and `SIGUSR2` are used. Applications can’t
    use these signals. (The use of signals results in high latency for various thread
    synchronization operations.)
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该实现使用信号进行内部操作。对于支持实时信号的内核（Linux 2.2 及更高版本），使用前三个实时信号。对于旧版本的内核，则使用 `SIGUSR1`
    和 `SIGUSR2`。应用程序不能使用这些信号。（使用信号会导致各种线程同步操作的高延迟。）
- en: LinuxThreads deviations from specified behavior
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: LinuxThreads 偏离指定行为
- en: 'LinuxThreads doesn’t conform to the SUSv3 specification for Pthreads on a number
    of points. (The LinuxThreads implementation was constrained by the kernel features
    available at the time that it was developed; it was as conformant as practicable
    within those constraints.) The following list summarizes the nonconformances:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: LinuxThreads在若干方面不符合SUSv3关于Pthreads的规范。（LinuxThreads的实现受到当时内核特性限制，在这些限制下，它是尽可能符合规范的。）以下列表总结了不符合的地方：
- en: Calls to *getpid()* return a different value in each of the threads of a process.
    Calls to *getppid()* reflect the fact that every thread other than the main thread
    is created by the process’s manager thread (i.e., *getppid()* returns the process
    ID of the manager thread). Calls to *getppid()* in the other threads should return
    the same value as a call to *getppid()* in the main thread.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用*getpid()*会返回进程中每个线程的不同值。调用*getppid()*则反映了除主线程外的每个线程都是由进程的管理线程创建的（即，*getppid()*返回管理线程的进程ID）。其他线程中的*getppid()*调用应该返回与主线程中的*getppid()*调用相同的值。
- en: If one thread creates a child using *fork()*, then any other thread should be
    able to obtain the termination status of that child using *wait()* (or similar).
    However, this is not so; only the thread that created the child process can *wait()*
    for it.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个线程使用*fork()*创建了一个子进程，那么其他任何线程都应该能够使用*wait()*（或类似方法）获取该子进程的终止状态。然而，事实并非如此；只有创建子进程的线程才能*wait()*它。
- en: If a thread calls *exec()*, then, as required by SUSv3, all other threads are
    terminated. However, if the *exec()* is done from any thread other than the main
    thread, then the resulting process will have the same process ID as the calling
    thread—that is, a process ID that is different from the main thread’s process
    ID. According to SUSv3, the process ID should be the same as that of the main
    thread.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个线程调用*exec()*，根据SUSv3的要求，所有其他线程都会被终止。然而，如果*exec()*是从主线程之外的任何线程调用的，那么结果进程将与调用线程具有相同的进程ID——即，与主线程的进程ID不同。根据SUSv3，进程ID应该与主线程的进程ID相同。
- en: Threads don’t share credentials (user and group IDs). When a multithreaded process
    is executing a set-user-ID program, this can lead to scenarios in which one thread
    can’t send a signal to another thread using *pthread_kill()*, because the credentials
    of the two threads have been changed in such a way that the sending thread no
    longer has permission to signal the target thread (refer to [Figure 20-2](ch20.html#permissions_required_for_an_unprivileged
    "Figure 20-2. Permissions required for an unprivileged process to send a signal"),
    in [Checking for the Existence of a Process](ch20.html#checking_for_the_existence_of_a_process
    "Checking for the Existence of a Process")). Furthermore, since the LinuxThreads
    implementation uses signals internally, various Pthreads operations can fail or
    hang if a thread changes its credentials.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程不共享凭据（用户和组ID）。当一个多线程进程执行设置用户ID的程序时，这可能导致某些线程无法使用*pthread_kill()*向另一个线程发送信号，因为两个线程的凭据已发生变化，以至于发送线程不再有权限向目标线程发送信号（请参见[图20-2](ch20.html#permissions_required_for_an_unprivileged
    "图20-2. 非特权进程发送信号所需的权限")，在[检查进程是否存在](ch20.html#checking_for_the_existence_of_a_process
    "检查进程是否存在")中）。此外，由于LinuxThreads实现内部使用信号，若线程更改其凭据，可能会导致各种Pthreads操作失败或挂起。
- en: 'Various aspects of the SUSv3 specification for the interaction between threads
    and signals are not honored:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SUSv3规范中关于线程与信号交互的各个方面并未得到遵守：
- en: A signal that is sent to a process using *kill()* or *sigqueue()* should be
    delivered to, and handled by, an arbitrary thread in the target process that is
    not blocking the signal. However, since LinuxThreads threads have different process
    IDs, a signal can be targeted only at a specific thread. If that thread is blocking
    the signal, it remains pending, even if there are other threads that are not blocking
    the signal.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*kill()*或*sigqueue()*发送到进程的信号应当被目标进程中的某个不阻塞该信号的线程接收并处理。然而，由于LinuxThreads线程具有不同的进程ID，信号只能针对特定的线程。如果该线程正在阻塞信号，即便有其他线程未阻塞信号，该信号仍然会保持待处理状态。
- en: LinuxThreads doesn’t support the notion of signals that are pending for a process
    as whole; only per-thread pending signals are supported.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: LinuxThreads不支持针对整个进程的待处理信号的概念；仅支持每线程的待处理信号。
- en: If a signal is directed at a process group that contains a multithreaded application,
    then the signal will be handled by all threads in the application (i.e., all threads
    that have established a signal handler), rather than by a single (arbitrary) thread.
    Such a signal may, for example, be generated by typing one of the terminal characters
    that generates a job-control signal for the foreground process group.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果信号被定向到包含多线程应用程序的进程组，那么该信号将由应用程序中的所有线程（即所有已建立信号处理程序的线程）处理，而不是由单个（任意）线程处理。例如，输入终端字符生成前台进程组的作业控制信号时，可能会生成这样的信号。
- en: The alternate signal stack settings (established by *sigaltstack()*) are per-thread.
    However, because a new thread wrongly inherits its alternate signal stack settings
    from the caller of *pthread_create()*, the two threads share an alternate signal
    stack. SUSv3 requires that a new thread should start with no alternate signal
    stack defined. The consequence of this LinuxThreads nonconformance is that if
    two threads happen to simultaneously handle different signals on their shared
    alternate signal stacks at the same time, chaos is likely to result (e.g., a program
    crash). This problem may be very hard to reproduce and debug, since its occurrence
    depends on the probably rare event that the two signals are handled at the same
    time.
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备用信号栈设置（由 *sigaltstack()* 建立）是每个线程独立的。然而，由于新线程错误地从 *pthread_create()* 的调用者继承了备用信号栈设置，导致两个线程共享一个备用信号栈。SUSv3
    规定，新线程应从没有定义备用信号栈开始。LinuxThreads 不符合此规范的后果是，如果两个线程恰好在相同时间处理不同信号，并且使用的是共享的备用信号栈，可能会导致混乱（例如，程序崩溃）。这个问题可能很难重现和调试，因为其发生依赖于两个信号同时处理的概率，这个事件可能较为罕见。
- en: Note
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In a program using LinuxThreads, a new thread could make a call to *sigaltstack()*
    to ensure that it uses a different alternate signal stack from the thread that
    created it (or no stack at all). However, portable programs (and library functions
    that create threads) won’t know to do this, since it is not a requirement on other
    implementations. Furthermore, even if we employ this technique, there is still
    a possible race condition: the new thread could receive and handle a signal on
    the alternate stack before it has a chance to call *sigaltstack()*.'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在使用 LinuxThreads 的程序中，新线程可以调用 *sigaltstack()* 来确保它使用与创建它的线程不同的备用信号栈（或根本不使用栈）。然而，便携式程序（以及创建线程的库函数）不会知道这样做，因为在其他实现中这并不是一个要求。此外，即使采用此技术，仍然可能会出现竞争条件：新线程可能会在有机会调用
    *sigaltstack()* 之前，在备用栈上接收并处理信号。
- en: Threads don’t share a common session ID and process group ID. The *setsid()*
    and *setpgid()* system calls can’t be used to change the session or process group
    membership of a multithreaded process.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程之间不共享会话 ID 和进程组 ID。*setsid()* 和 *setpgid()* 系统调用不能用于改变多线程进程的会话或进程组成员身份。
- en: Record locks established using *fcntl()* are not shared. Overlapping lock requests
    of the same type are not merged.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *fcntl()* 建立的记录锁不共享。同一类型的重叠锁请求不会合并。
- en: Threads don’t share resource limits. SUSv3 specifies that resource limits are
    process-wide attributes.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程不共享资源限制。SUSv3 指定资源限制是进程级别的属性。
- en: The CPU time returned by *times()* and the resource usage information returned
    by *getrusage()* are per-thread. These system calls should return process-wide
    totals.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*times()* 返回的 CPU 时间和 *getrusage()* 返回的资源使用信息是每个线程独立的。这些系统调用应返回进程级别的总和。'
- en: Some versions of *ps(1)* show all of the threads in a process (including the
    manager thread) as separate items with distinct process IDs.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些版本的 *ps(1)* 会将进程中的所有线程（包括管理线程）显示为具有不同进程 ID 的独立项。
- en: Threads don’t share nice value set by *setpriority()*.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程不共享由 *setpriority()* 设置的 nice 值。
- en: Interval timers created using *setitimer()* are not shared between the threads.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *setitimer()* 创建的间隔定时器在线程之间不共享。
- en: Threads don’t share System V semaphore undo (*semadj*) values.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程不共享 System V 信号量撤销（*semadj*）值。
- en: Other problems with LinuxThreads
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: LinuxThreads 的其他问题
- en: 'In addition to the above deviations from SUSv3, the LinuxThreads implementation
    has the following problems:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述偏离 SUSv3 的情况，LinuxThreads 实现还有以下问题：
- en: If the manager thread is killed, then the remaining threads must be manually
    cleaned up.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果管理线程被杀死，那么剩余的线程必须手动清理。
- en: A core dump of a multithreaded program may not include all of the threads of
    the process (or even the one that triggered the core dump).
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程程序的核心转储可能不会包含进程的所有线程（甚至可能不包括触发核心转储的线程）。
- en: The nonstandard *ioctl()* `TIOCNOTTY` operation can remove the process’s association
    with a controlling terminal only when called from the main thread.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非标准的 *ioctl()* `TIOCNOTTY` 操作只有在主线程调用时，才能移除进程与控制终端的关联。
- en: NPTL
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NPTL
- en: 'NPTL was designed to address most of the shortcomings of LinuxThreads. In particular:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: NPTL 旨在解决 LinuxThreads 的大多数不足之处，特别是：
- en: NPTL provides much closer conformance to the SUSv3 specification for Pthreads.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPTL 更加符合 SUSv3 对 Pthreads 的规范。
- en: Applications that employ large numbers of threads scale much better under NPTL
    than under LinuxThreads.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用大量线程的应用程序在 NPTL 下的扩展性比在 LinuxThreads 下要好得多。
- en: Note
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: NPTL allows an application to create large numbers of threads. The NPTL implementers
    were able to run test programs that created 100,000 threads. With LinuxThreads,
    the practical limit on the number of threads is a few thousand. (Admittedly, very
    few applications need such large numbers of threads.)
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: NPTL 允许应用程序创建大量线程。NPTL 的实现者能够运行创建 100,000 个线程的测试程序。而在 LinuxThreads 中，线程数量的实际限制为几千个。（诚然，极少数应用程序需要如此大量的线程。）
- en: 'Work on implementing NPTL began in 2002 and progressed over the next year or
    so. In parallel, various changes were made within the Linux kernel to accommodate
    the requirements of NPTL. The changes that appeared in the Linux 2.6 kernel to
    support NPTL included the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: NPTL 的实现工作始于 2002 年，并在接下来的一年左右取得了进展。同时，Linux 内核也进行了各种修改，以适应 NPTL 的需求。Linux 2.6
    内核中为支持 NPTL 所做的修改包括：
- en: refinements to the implementation of thread groups ([Example program](ch28.html#example_program-id39
    "Example program"));
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对线程组实现的改进（[示例程序](ch28.html#example_program-id39 "Example program")）；
- en: the addition of futexes as a synchronization mechanism (futexes are a generic
    mechanism that was designed not just for NPTL);
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了 futexes 作为一种同步机制（futexes 是一种通用机制，不仅仅为 NPTL 设计）；
- en: the addition of new system calls (*get_thread_area()* and *set_thread_area()*)
    to support thread-local storage;
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新增系统调用 (*get_thread_area()* 和 *set_thread_area()*) 以支持线程局部存储；
- en: support for threaded core dumps and debugging of multithreaded processes;
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持线程化核心转储和多线程进程的调试；
- en: modifications to support management of signals in a manner consistent with the
    Pthreads model;
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为支持与 Pthreads 模型一致的信号管理，进行了修改；
- en: the addition of a new *exit_group()* system call to terminate all of the threads
    in a process (starting with *glibc* 2.3, *_exit()*—and thus also the *exit()*
    library function—is aliased as a wrapper that invokes *exit_group()*, while a
    call to *pthread_exit()* invokes the true *_exit()* system call in the kernel,
    which terminates just the calling thread);
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新增 *exit_group()* 系统调用，用于终止进程中的所有线程（从 *glibc* 2.3 开始，*_exit()* —— 也就是 *exit()*
    库函数 —— 被重定向为调用 *exit_group()* 的包装函数，而调用 *pthread_exit()* 则会调用内核中的真正 *_exit()*
    系统调用，只终止调用线程）；
- en: a rewrite of the kernel scheduler to allow efficient scheduling of very large
    numbers (i.e., thousands) of KSEs;
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核调度器的重写，允许高效地调度大量（即数千个）KSE。
- en: improved performance for the kernel’s process termination code; and
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进了内核的进程终止代码的性能；
- en: extensions to the *clone()* system call ([The *clone()* System Call](ch28.html#the_clone_open_parenthesis_close_parenth
    "The clone() System Call")).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 *clone()* 系统调用的扩展（[The *clone()* System Call](ch28.html#the_clone_open_parenthesis_close_parenth
    "The clone() System Call")）。
- en: 'The essentials of the NPTL implementation are as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: NPTL 实现的要点如下：
- en: 'Threads are created using a *clone()* call that specifies the following flags:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程是通过 *clone()* 调用创建的，并指定以下标志：
- en: '[PRE6]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: NPTL threads share all of the information that LinuxThreads threads share, and
    more. The `CLONE_THREAD` flag means that a thread is placed in the same thread
    group as its creator and shares the same process ID and parent process ID. The
    `CLONE_SYSVSEM` flag means that a thread shares System V semaphore undo values
    with its creator.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: NPTL 线程共享 LinuxThreads 线程共享的所有信息，甚至更多。`CLONE_THREAD` 标志表示线程被放入与其创建者相同的线程组，并共享相同的进程
    ID 和父进程 ID。`CLONE_SYSVSEM` 标志表示线程与其创建者共享 System V 信号量撤销值。
- en: Note
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we use *ps(1)* to list a multithreaded process running under NPTL, we see
    just a single line of output. To see information about the threads within a process,
    we can use the *ps -L* option.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们使用 *ps(1)* 列出一个在 NPTL 下运行的多线程进程时，我们只看到一行输出。要查看进程内线程的信息，我们可以使用 *ps -L* 选项。
- en: The implementation makes internal use of the first two realtime signals. Applications
    can’t use these signals.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该实现内部使用前两个实时信号。应用程序无法使用这些信号。
- en: Note
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One of these signals is used to implement thread cancellation. The other signal
    is used as part of a technique that ensures that all of the threads in a process
    have the same user and group IDs. This technique is required because, at the kernel
    level, threads have distinct user and group credentials. Therefore, the NPTL implementation
    does some work in the wrapper function for each system call that changes user
    and group IDs (*setuid()*, *setresuid()*, and so on, and their group analogs)
    that causes the IDs to be changed in all of the threads of the process.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中一个信号用于实现线程取消。另一个信号则作为确保进程中所有线程具有相同用户和组 ID 的技术的一部分。此技术是必需的，因为在内核层面，线程具有不同的用户和组凭证。因此，NPTL
    实现会在每个系统调用的包装函数中执行一些工作，这些系统调用会更改用户和组 ID（如*setuid()*、*setresuid()* 等及其组相关调用），并导致进程中所有线程的
    ID 都发生变化。
- en: Unlike LinuxThreads, NPTL doesn’t use manager threads.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 LinuxThreads 不同，NPTL 不使用管理线程。
- en: NPTL standards conformance
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: NPTL 标准兼容性
- en: 'These changes mean that NPTL achieves much closer SUSv3 conformance than LinuxThreads.
    At the time of writing, the following nonconformance remains:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化意味着 NPTL 实现比 LinuxThreads 更加符合 SUSv3 标准。目前为止，以下不兼容问题仍然存在：
- en: Threads don’t share a nice value.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程之间不会共享 nice 值。
- en: 'There are some additional NPTL nonconformances in earlier 2.6.*x* kernels:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的 2.6.*x* 内核中，存在一些额外的 NPTL 不兼容问题：
- en: In kernels before 2.6.16, the alternate signal stack was per-thread, but a new
    thread wrongly inherited alternate signal stack settings (established by *sigaltstack()*)
    from the caller of *pthread_create()*, with the consequence that the two threads
    shared an alternate signal stack.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 2.6.16 之前的内核中，备用信号栈是按线程分配的，但新线程错误地继承了调用*pthread_create()*的线程设置的备用信号栈（通过*sigaltstack()*建立），因此两个线程共享了备用信号栈。
- en: In kernels before 2.6.16, only a thread group leader (i.e., the main thread)
    could start a new session by calling *setsid()*.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 2.6.16 之前的内核中，只有线程组的领导者（即主线程）才能通过调用*setsid()*来启动一个新的会话。
- en: In kernels before 2.6.16, only a thread group leader could use *setpgid()* to
    make the host process a process group leader.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 2.6.16 之前的内核中，只有线程组的领导者才能使用*setpgid()*将宿主进程设置为进程组的领导者。
- en: In kernels prior to 2.6.12, interval timers created using *setitimer()* were
    not shared between the threads of a process.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 2.6.12 之前的内核中，使用*setitimer()*创建的间隔定时器不会在进程的线程之间共享。
- en: In kernels prior to 2.6.10, resource limit settings were not shared between
    the threads of a process.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 2.6.10 之前的内核中，资源限制设置不会在进程的线程之间共享。
- en: In kernels prior to 2.6.9, the CPU time returned by *times()* and the resource
    usage information returned by *getrusage()* were per-thread.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 2.6.9 之前的内核中，*times()* 返回的 CPU 时间和 *getrusage()* 返回的资源使用信息是按线程计算的。
- en: NPTL was designed to be ABI-compatible with LinuxThreads. This means that programs
    that were linked against a GNU C library providing LinuxThreads don’t need to
    be relinked in order to use NPTL. However, some behaviors may change when the
    program is run with NPTL, primarily because NPTL adheres more closely to the SUSv3
    specification for Pthreads.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: NPTL 旨在与 LinuxThreads 兼容 ABI。这意味着，针对提供 LinuxThreads 的 GNU C 库编译的程序无需重新链接即可使用
    NPTL。然而，当程序在 NPTL 上运行时，某些行为可能会发生变化，主要是因为 NPTL 更加遵循 SUSv3 对 Pthreads 的规范。
- en: Which Threading Implementation?
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择哪种线程实现？
- en: 'Some Linux distributions ship with a GNU C library that provides both LinuxThreads
    and NPTL, with the default being determined by the dynamic linker according to
    the underlying kernel on which the system is running. (These distributions are
    by now historical because, since version 2.4, *glibc* no longer provides LinuxThreads.)
    Therefore, we may sometimes need to answer the following questions:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Linux 发行版自带一个 GNU C 库，提供 LinuxThreads 和 NPTL，两者的默认选择由动态链接器根据系统运行的底层内核来决定。（这些发行版现在已经成为历史，因为从
    2.4 版本开始，*glibc* 不再提供 LinuxThreads。）因此，我们有时需要回答以下问题：
- en: Which threading implementation is available in a particular Linux distribution?
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定的 Linux 发行版中，哪种线程实现是可用的？
- en: On a Linux distribution that provides both LinuxThreads and NPTL, which implementation
    is used by default, and how can we explicitly select the implementation that is
    used by a program?
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在提供 LinuxThreads 和 NPTL 的 Linux 发行版中，默认使用哪种实现，如何明确选择程序使用的实现？
- en: Discovering the threading implementation
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 发现线程实现方式
- en: We can use a few techniques to discover the threading implementation that is
    available on a particular system, or to discover the default implementation that
    will be employed when a program is run on a system that provides both threading
    implementations.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一些技术来发现特定系统上可用的线程实现，或者在提供两种线程实现的系统上，发现默认使用的实现。
- en: 'On a system providing *glibc* version 2.3.2 or later, we can use the following
    command to discover which threading implementation the system provides, or, if
    it provides both implementation, then which one is used by default:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供 *glibc* 版本 2.3.2 或更高版本的系统上，我们可以使用以下命令来发现系统提供的线程实现，或者如果系统提供两种实现，则发现默认使用的实现：
- en: '[PRE7]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On a system where NPTL is the only or the default implementation, this will
    display a string such as the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NPTL 是唯一或默认实现的系统上，这将显示类似以下的字符串：
- en: '[PRE8]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since *glibc* 2.3.2, a program can obtain similar information by using *confstr(3)*
    to retrieve the value of the *glibc*-specific `_CS_GNU_LIBPTHREAD_VERSION` configuration
    variable.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *glibc* 2.3.2 版本开始，程序可以通过使用 *confstr(3)* 获取 *glibc* 特定的 `_CS_GNU_LIBPTHREAD_VERSION`
    配置变量的值，从而获得类似的信息。
- en: 'On systems with older GNU C libraries, we must do a little more work. First,
    the following command can be used to show the pathname of the GNU C library that
    is used when we run a program (here, we use the example of the standard *ls* program,
    which resides at `/bin/ls`):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用较旧的 GNU C 库的系统中，我们必须做更多的工作。首先，可以使用以下命令来显示运行程序时使用的 GNU C 库的路径名（这里我们以标准的 *ls*
    程序为例，该程序位于 `/bin/ls`）：
- en: '[PRE9]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We say a little more about the *ldd* (list dynamic dependencies) program in
    Section 41.5.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 41.5 节中稍微介绍一下 *ldd*（列出动态依赖）程序。
- en: 'The pathname of the GNU C library is shown after the `=>`. If we execute this
    pathname as a command, then *glibc* displays a range of information about itself.
    We can *grep* though this information to select the line that displays the threading
    implementation:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: GNU C 库的路径名会显示在 `=>` 后面。如果我们执行这个路径名作为命令，那么 *glibc* 会显示一系列关于它的信息。我们可以通过 *grep*
    来筛选这些信息，以选择显示线程实现的那一行：
- en: '[PRE10]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We include *nptl* in the *egrep* regular expression because some *glibc* releases
    containing NPTL instead display a string like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *egrep* 正则表达式中包括 *nptl*，因为某些包含 NPTL 的 *glibc* 版本会显示如下字符串：
- en: '[PRE11]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since the *glibc* pathname may vary from one Linux distribution to another,
    we can employ shell command substitution to produce a command line that will display
    the threading implementation in use on any Linux system, as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 *glibc* 的路径名可能因 Linux 发行版而异，我们可以使用 shell 命令替换，生成一个命令行来显示任何 Linux 系统上正在使用的线程实现，方法如下：
- en: '[PRE12]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Selecting the threading implementation used by a program
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择程序使用的线程实现方式
- en: On a Linux system that provides both NPTL and LinuxThreads, it is sometimes
    useful to be able to explicitly control which threading implementation is used.
    The most common example of this requirement is when we have an older program that
    depends on some (probably nonstandard) behavior of LinuxThreads, so that we want
    to force the program to run with that threading implementation, instead of the
    default NPTL.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供 NPTL 和 LinuxThreads 的 Linux 系统中，有时需要显式地控制使用哪种线程实现。这个需求最常见的例子是，当我们有一个依赖于
    LinuxThreads（可能是非标准行为）的旧程序时，我们希望强制程序使用该线程实现，而不是默认的 NPTL。
- en: 'For this purpose, we can employ a special environment variable understood by
    the dynamic linker: `LD_ASSUME_KERNEL`. As its name suggests, this environment
    variable tells the dynamic linker to operate as though it is running on top of
    a particular Linux kernel version. By specifying a kernel version that doesn’t
    provide support for NPTL (e.g., `2.2.5`), we can ensure that LinuxThreads is used.
    Thus, we could run a multithreaded program with LinuxThreads using the following
    command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们可以使用一个动态链接器理解的特殊环境变量：`LD_ASSUME_KERNEL`。顾名思义，这个环境变量告诉动态链接器按某个特定的 Linux
    内核版本运行。通过指定一个不支持 NPTL 的内核版本（例如，`2.2.5`），我们可以确保使用 LinuxThreads。因此，我们可以使用以下命令运行一个多线程程序并使用
    LinuxThreads：
- en: '[PRE13]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When we combine this environment variable setting with the command that we
    described earlier to show the threading implementation that is used, we see something
    like the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将这个环境变量设置与前面描述的命令结合使用时，用来显示所使用的线程实现时，我们会看到类似以下内容：
- en: '[PRE14]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The range of kernel version numbers that can be specified in `LD_ASSUME_KERNEL`
    is subject to some limits. In several common distributions that supply both NPTL
    and LinuxThreads, specifying the version number as 2.2.5 is sufficient to ensure
    the use of LinuxThreads. For a fuller description of the use of this environment
    variable, see [http://people.redhat.com/drepper/assumekernel.html](http://people.redhat.com/drepper/assumekernel.html).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`LD_ASSUME_KERNEL`中可以指定的内核版本号范围有限。在多个同时提供NPTL和LinuxThreads的常见发行版中，指定版本号为2.2.5足以确保使用LinuxThreads。有关此环境变量使用的更完整描述，请参见[http://people.redhat.com/drepper/assumekernel.html](http://people.redhat.com/drepper/assumekernel.html)。'
- en: Advanced Features of the Pthreads API
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pthreads API的高级特性
- en: 'Some advanced features of the Pthreads API include the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Pthreads API的一些高级功能包括以下内容：
- en: '*Realtime scheduling*: We can set realtime scheduling policies and priorities
    for threads. This is similar to the process realtime scheduling system calls described
    in Section 35.3.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实时调度*：我们可以为线程设置实时调度策略和优先级。这类似于第35.3节中描述的进程实时调度系统调用。'
- en: '*Process shared mutexes and condition variables*: SUSv3 specifies an option
    to allow mutexes and condition variables to be shared between processes (rather
    than just among the threads of a single process). In this case, the condition
    variable or mutex must be located in a region of memory shared between the processes.
    NPTL supports this feature.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*进程间共享互斥量和条件变量*：SUSv3规定了一个选项，允许互斥量和条件变量在进程之间共享（而不仅仅是单一进程的线程之间共享）。在这种情况下，条件变量或互斥量必须位于进程之间共享的内存区域中。NPTL支持此功能。'
- en: '*Advanced thread-synchronization primitives*: These facilities include barriers,
    read-write locks, and spin locks.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高级线程同步原语*：这些设施包括屏障、读写锁和自旋锁。'
- en: Further details on all of these features can be found in [Butenhof, 1996].
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些功能的进一步细节可以在[Butenhof, 1996]中找到。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Threads don’t mix well with signals; multithreaded application designs should
    avoid the use of signals whenever possible. If a multithreaded application must
    deal with asynchronous signals, usually the cleanest way to do so is to block
    signals in all threads, and have a single dedicated thread that accepts incoming
    signals using *sigwait()* (or similar). This thread can then safely perform tasks
    such as modifying shared variables (under mutex control) and calling non-async-signal-safe
    functions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 线程与信号配合不好；多线程应用程序设计应尽量避免使用信号。如果多线程应用程序必须处理异步信号，通常最干净的方式是阻塞所有线程中的信号，并让一个专门的线程使用*sigwait()*（或类似方法）接收传入的信号。然后，该线程可以安全地执行任务，如修改共享变量（在互斥量控制下）和调用非异步信号安全的函数。
- en: 'Two threading implementations are commonly available on Linux: LinuxThreads
    and NPTL. LinuxThreads has been available on Linux for many years, but there are
    a number of points where it doesn’t conform to the requirements of SUSv3 and it
    is now obsolete. The more recent NPTL implementation provides closer SUSv3 conformance
    and superior performance, and is the implementation provided in modern Linux distributions.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Linux上通常有两种线程实现：LinuxThreads和NPTL。LinuxThreads在Linux上已有多年历史，但它在多个方面不符合SUSv3的要求，现在已经过时。更新的NPTL实现提供了更接近SUSv3的符合性和更优的性能，并且是现代Linux发行版中提供的实现。
- en: Further information
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步的信息
- en: Refer to the sources of further information listed in [Summary](ch29.html#summary-id28
    "Summary").
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[Summary](ch29.html#summary-id28 "Summary")中列出的更多信息来源。
- en: The author of LinuxThreads documented the implementation in a web page that
    can be found at [http://pauillac.inria.fr/~xleroy/linuxthreads/](http://pauillac.inria.fr/~xleroy/linuxthreads/).
    The NPTL implementation is described by its implementers in a (now somewhat out-of-date)
    paper that is available online at [http://people.redhat.com/drepper/nptl-design.pdf](http://people.redhat.com/drepper/nptl-design.pdf).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: LinuxThreads的作者在一个网页上记录了该实现，网址为[http://pauillac.inria.fr/~xleroy/linuxthreads/](http://pauillac.inria.fr/~xleroy/linuxthreads/)。NPTL的实现由其开发者在一篇（现在有些过时的）论文中描述，该论文可以在线访问，地址为[http://people.redhat.com/drepper/nptl-design.pdf](http://people.redhat.com/drepper/nptl-design.pdf)。
- en: Exercises
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Write a program to demonstrate that different threads in the same process can
    have different sets of pending signals, as returned by *sigpending()*. You can
    do this by using *pthread_kill()* to send different signals to two different threads
    that have blocked these signals, and then have each of the threads call *sigpending()*
    and display information about pending signals. (You may find the functions in
    [Example 20-4](ch20.html#functions_for_displaying_signal_sets "Example 20-4. Functions
    for displaying signal sets") useful.)
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序来演示同一进程中的不同线程可以拥有不同的待处理信号集，如通过*sigpending()*返回的那样。你可以通过使用*pthread_kill()*向两个不同的线程发送不同的信号来实现这些信号的阻塞，然后让每个线程调用*sigpending()*并显示关于待处理信号的信息。（你可能会发现[示例
    20-4](ch20.html#functions_for_displaying_signal_sets "示例 20-4. 显示信号集的函数")中的函数很有用。）
- en: Suppose that a thread creates a child using *fork()*. When the child terminates,
    is it guaranteed that the resulting `SIGCHLD` signal will be delivered to the
    thread that called *fork()* (as opposed to some other thread in the process)?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设一个线程使用*fork()*创建了一个子进程。当子进程终止时，是否保证结果`SIGCHLD`信号会传递给调用*fork()*的线程（而不是进程中的其他线程）？
