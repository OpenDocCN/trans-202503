- en: '**15'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**15'
- en: MAKING YOUR SYSTEM USEFUL**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**使你的系统更有用**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: A basic FreeBSD install includes *exactly* enough to make the system run, plus
    a few extra bits that Unix systems traditionally include. You can decide whether
    to install additional programs or source code. While FreeBSD has grown over the
    years, a complete base install fills about a gigabyte—much less disk space than
    either a Windows or a commercial Linux install.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的FreeBSD安装包括*正好*足以让系统运行的内容，再加上一些Unix系统传统上包含的额外组件。你可以决定是否安装额外的程序或源代码。尽管FreeBSD随着时间的推移不断发展，但一个完整的基本安装大约占用1GB的空间——比Windows或商业Linux安装所需的磁盘空间要少得多。
- en: The advantage to this sparseness is that it includes only necessary system components.
    Debugging becomes much simpler when you know that no shared library you’ve never
    even heard of, and would never use, can be responsible for your problems. The
    downside is that you must decide what functions you do need and select software
    to provide those functions. FreeBSD simplifies add-on software installation through
    ports and packages.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简洁性的优点在于它仅包含必要的系统组件。当你知道没有任何你从未听说过、且永远不会使用的共享库能够导致你的问题时，调试变得简单得多。缺点是你必须决定需要哪些功能，并选择提供这些功能的软件。FreeBSD通过端口和包简化了附加软件的安装。
- en: '**Ports and Packages**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**端口和软件包**'
- en: FreeBSD supports two different ways to install add-on software. Everything starts
    with the Ports Collection, but most users will prefer preconfigured packages.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD支持两种安装附加软件的方式。一切都从端口集合开始，但大多数用户会更喜欢预配置的软件包。
- en: FreeBSD has a system for building add-on software called the *Ports Collection*,
    or just *ports*. Ports let you start with raw source code from the program vendor
    and build the software in exactly the way you need, enabling and disabling features
    as you need. Ports are fast and easy for the experienced user but require a certain
    amount of Unix expertise and can intimidate the new user.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD有一个构建附加软件的系统，叫做*端口集合*，或简称*端口*。端口让你从程序供应商提供的原始源代码开始，并按照你需要的方式构建软件，按需启用或禁用功能。对于经验丰富的用户来说，端口既快速又简单，但需要一定的Unix专业知识，对于新用户来说可能会感到有些吓人。
- en: '*Packages* are the result of building ports, using the options the port maintainer
    thinks will be most useful to the widest variety of people, and bundling them
    up in a lump to make them easily installable. The FreeBSD Project has a whole
    farm of systems that do nothing but build all the ports, bundle them up, and make
    them available for users to download and install. Packages let you quickly install,
    uninstall, and upgrade add-on software.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*软件包*是通过构建端口而生成的，使用端口维护者认为对最广泛的用户群体最有用的选项，并将它们打包成一个整体，方便安装。FreeBSD项目有一整套系统，仅用于构建所有端口，打包并供用户下载和安装。软件包让你能够快速安装、卸载和升级附加软件。'
- en: '**INTERNET ADVICE STICKS AROUND FOREVER**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**互联网建议永远不会消失**'
- en: Forums and mailing list archives contain many recommendations to skip packages
    and proceed directly to ports. This is no longer true; packages are preferable
    for both technical reasons and your own peace of mind. The older package system,
    pkg_tools, had serious limitations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 论坛和邮件列表存档中有许多建议跳过软件包，直接使用端口。这已经不再正确；从技术角度和个人心态上看，软件包更为优选。旧的软件包系统pkg_tools有严重的限制。
- en: Ignore any recommendations that mention tools like pkg_add(8), pkg_delete(8),
    pkg_create(8), and so on. It’s extremely obsolete.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略任何提到像pkg_add(8)、pkg_delete(8)、pkg_create(8)等工具的推荐意见。它们已经过时了。
- en: FreeBSD’s highly flexible packaging system is called *package*, pkg(8), or just
    plain pkg. Package information gets stored in SQLite databases, which lets you
    perform arbitrary queries on package data. During development, pkg was called
    *pkgNG*. That name’s been gone for years now but lingers on in some old docs and
    third-party software. Don’t let the name confuse you.^([1](footnote.xhtml#ch15fn1))
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD高度灵活的软件包系统叫做*package*，pkg(8)，或简单称为pkg。软件包信息存储在SQLite数据库中，这使得你可以对软件包数据执行任意查询。在开发过程中，pkg曾被称为*pkgNG*。这个名称已经消失多年，但仍然出现在一些旧文档和第三方软件中。不要让这个名字混淆你。^([1](footnote.xhtml#ch15fn1))
- en: We’ll start by discussing managing systems with pkg(8) and then proceed to customizing
    software with ports.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论如何使用pkg(8)管理系统，然后继续讨论如何通过端口定制软件。
- en: '**Packages**'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**软件包**'
- en: Packages are precompiled software from the Ports Collection, bundled up for
    a particular version of FreeBSD. The FreeBSD Project offers several sets of packages
    in a public repository, updated every few days. Packages are the simplest way
    to install add-on software. Any software without legal restrictions on its distribution
    is probably available as a package.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包是来自Ports Collection的预编译软件，针对特定版本的FreeBSD进行打包。FreeBSD项目提供了多个软件包集，并在公共仓库中发布，每几天更新一次。软件包是安装附加软件的最简单方式。任何没有法律分发限制的软件可能都可以作为软件包提供。
- en: Legal restrictions? Software can have any license terms, including some really
    odd ones. The license of some software prohibits distribution in any form other
    than source code. FreeBSD can’t legally package that. Other software can legally
    be distributed only in precompiled form. FreeBSD usually packages such software,
    distributing it as the precompiled binary plus FreeBSD-specific packaging information.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 法律限制？软件可能具有任何许可证条款，包括一些非常奇怪的条款。有些软件的许可证禁止以任何非源代码形式进行分发。FreeBSD在法律上无法将其打包。其他软件则只能以预编译形式合法分发。FreeBSD通常会打包这类软件，将其作为预编译的二进制文件和FreeBSD特定的打包信息一起分发。
- en: Packages are built on the oldest supported release of each major FreeBSD version.
    Packages for all versions of FreeBSD 12 are built on the oldest supported release
    of FreeBSD 12, FreeBSD 13 packages are built on the oldest supported version of
    FreeBSD 13, and so on. This helps reduce, identify, and contain ABI incompatibilities.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包是基于每个主要FreeBSD版本的最旧支持版本构建的。所有FreeBSD 12版本的软件包都是基于FreeBSD 12的最旧支持版本构建的，FreeBSD
    13的软件包是基于FreeBSD 13的最旧支持版本构建的，依此类推。这有助于减少、识别和解决ABI不兼容问题。
- en: If you need to build your own package repository, investigate the Ports Collection
    (see [Chapter 16](ch16.xhtml#ch16)) and the add-on package *poudriere*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要建立自己的软件包仓库，查阅 Ports Collection（参见[第16章](ch16.xhtml#ch16)）以及附加软件包*poudriere*。
- en: '***Package Files***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***软件包文件***'
- en: Ultimately, packages contain files. Those files might be binary programs, documentation,
    configuration files, or anything else the software might need. These files are
    considered part of the operating system. Don’t edit them manually.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，软件包包含文件。这些文件可能是二进制程序、文档、配置文件或软件可能需要的任何其他内容。这些文件被视为操作系统的一部分。不要手动编辑它们。
- en: The one odd case is when a package contains a sample configuration file. If
    a program needs a configuration file, the package should include a sample. You’ll
    need to edit the configuration to fit your needs—that’s what configuration files
    are *for*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特殊的情况是，当软件包包含一个示例配置文件时。如果程序需要配置文件，软件包应该包括一个示例。你需要编辑该配置文件以适应你的需求——这就是配置文件的*用途*。
- en: FreeBSD reconciles this by installing the package’s configuration files with
    the suffix *.sample*. Our web server configuration file appears as something like
    *httpd.conf.sample*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD通过安装带有后缀*.sample*的配置文件来解决这个问题。我们的Web服务器配置文件通常会以*httpd.conf.sample*的形式出现。
- en: If there’s no production configuration file, the package installation also copies
    the sample file into place. That file is yours to edit.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有生产配置文件，软件包安装时也会将示例文件复制到适当位置。这个文件可以由你来编辑。
- en: If you upgrade a package, pkg(8) compares the current production file to the
    old sample file. If the sample is identical to the production version, the upgrade
    replaces the production file. If the files differ in any way, pkg updates only
    the sample file. It’s your job to merge any desirable changes into your production
    configuration. Note that the package upgrade always replaces the sample configuration,
    so if an old sample is important, you need to make a point to hang on to it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你升级了一个软件包，pkg(8)会将当前的生产文件与旧的示例文件进行比较。如果示例文件与生产版本相同，升级会替换生产文件。如果文件有任何差异，pkg只会更新示例文件。合并任何需要的更改到生产配置是你的工作。请注意，软件包升级总是会替换示例配置文件，因此如果旧的示例文件很重要，你需要特别保存它。
- en: '***Introducing pkg(8)***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***介绍pkg(8)***'
- en: 'Unlike the older packaging system, pkg(8) is a single program with a whole
    flock of subcommands. You’ll use the same program to install, uninstall, and investigate
    packages. All changes to installed packages must be run as root. Here’s how you’d
    install a vital program desired by all right-thinking sysadmins:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与旧的打包系统不同，pkg(8)是一个单一程序，带有一大堆子命令。你将使用相同的程序来安装、卸载和调查软件包。所有对已安装软件包的更改必须以root身份运行。以下是如何安装所有有远见的系统管理员都需要的一个重要程序：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Those of you clinging to irrational biases against superior text processors
    probably want to remove it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 那些对更优文本处理器抱有不合理偏见的人，可能想要将其删除。
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All package operations use the pkg(8) command.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有包操作都使用 pkg(8) 命令。
- en: While the pkg(8) man page documents the base pkg functions, each subcommand
    has its own man page, named *pkg-* and the subcommand. Examples include pkg-install(8)
    and pkg-delete(8). You can also use the `pkg help` command and the name of the
    subcommand to get assistance—for example, `pkg help install`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 pkg(8) 手册页记录了基本的 pkg 功能，但每个子命令都有自己的手册页，命名格式为 *pkg-* 加上子命令名。示例包括 pkg-install(8)
    和 pkg-delete(8)。你也可以使用 `pkg help` 命令和子命令的名称获取帮助，例如，`pkg help install`。
- en: FreeBSD doesn’t ship with pkg(8) installed. You need to install it . . . as
    a package. No, wait, don’t scream—it’s *much* better than it sounds.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 并没有预装 pkg(8)。你需要安装它……作为一个包。等等，别尖叫——它比听起来要*好得多*。
- en: '***Installing pkg(8)***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安装 pkg(8)***'
- en: FreeBSD ships with a very simple package manager in */usr/sbin/pkg*, pkg(7).
    It has barely enough brains to find FreeBSD’s current package manager. It installs
    that new package manager and surrenders all responsibility for package management
    to it. This gives FreeBSD the flexibility to update the package manager with the
    packages.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 随附了一个非常简单的包管理器 */usr/sbin/pkg*，即 pkg(7)。它几乎没有足够的智能来找到 FreeBSD 当前的包管理器。它安装那个新的包管理器，并将所有包管理责任交给它。这使得
    FreeBSD 在更新包管理器时具有灵活性。
- en: The first time you try to install a package, pkg(8) prompts you to install the
    package manager. I found I needed the dmidecode package on a new server, so I
    can get an RMA on a bad power supply from the manufacturer. (Don’t worry about
    how I *found* the dmidecode package—just go with me for the moment.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次尝试安装一个包时，pkg(8) 会提示你安装包管理器。我发现在新服务器上需要安装 dmidecode 包，这样我才能从厂家获得坏电源的 RMA。（不用担心我如何*找到*
    dmidecode 包——暂时跟着我走就好。）
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: FreeBSD runs pkg(8) and finds that no package management is installed yet.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 运行 pkg(8) 并发现尚未安装包管理。
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The default answer appears in capital letters. If I hit `n` and ENTER, pkg terminates.
    If I hit `y` and ENTER, FreeBSD bootstraps the system.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的答案以大写字母显示。如果我按 `n` 和回车，pkg 会终止。如果我按 `y` 和回车，FreeBSD 将启动系统。
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The installation starts by downloading the current pkg tools from a FreeBSD
    mirror ➊. It then checks the digital signature on the downloaded file ➋. The tools
    are extracted and installed ➌. Pkg then downloads and installs the catalog of
    available packages ➍.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 安装开始时会从 FreeBSD 镜像站点下载当前的 pkg 工具 ➊。然后它会检查下载文件的数字签名 ➋。工具被解压并安装 ➌。然后 pkg 下载并安装可用包的目录
    ➍。
- en: The packaging system is now installed. To smooth things out, the stub pkg(8)
    that ships with FreeBSD tells the newly installed packaging system to install
    the program you really wanted. In this case, our new pkg(8) installs dmidecode
    for you.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理系统现在已安装。为了顺利运行，FreeBSD 随附的简单 pkg(8) 告诉新安装的包管理系统去安装你真正想要的程序。在这种情况下，我们的新 pkg(8)
    为你安装了 dmidecode。
- en: You can install the packaging system on its own, without adding other packages,
    by running pkg bootstrap—but seriously, nobody does that at the command line.
    Running pkg bootstrap does nothing when the packaging system is already installed,
    so it’s useful for setup scripts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以单独安装包管理系统，而不添加其他包，通过运行 pkg bootstrap ——但说实话，没人会在命令行中这么做。当包管理系统已经安装时，运行 pkg
    bootstrap 不会做任何事情，因此它主要用于安装脚本中。
- en: '***Common pkg Options***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***常见的 pkg 选项***'
- en: While each pkg subcommand has unique features, a few command options work across
    almost all of them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每个 pkg 子命令都有独特的功能，但有一些命令选项在几乎所有子命令中都能通用。
- en: In its default configuration, pkg prompts you for confirmation before doing
    anything. Tell pkg to take action without prompting you with the `-y` flag.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认配置下，pkg 在执行任何操作之前都会提示你确认。你可以通过 `-y` 标志告诉 pkg 执行操作而不提示你。
- en: On the other hand, maybe you want pkg to show you what it would do if you ran
    a command, but not actually do anything. Perform a dry run by using the `-n` flag.
    For example, a package install using `-n` would show the names of every package
    to be installed, including dependencies. There’s no risk that the system would
    install the packages, however. Dry runs can help you prepare for changes during
    a maintenance window.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，也许你希望 pkg 显示如果你运行命令会做什么，但不实际执行任何操作。可以使用 `-n` 标志执行演练。例如，使用 `-n` 安装包时，会显示每个将要安装的包的名称，包括依赖包。然而，系统不会安装任何包，演练可以帮助你在维护窗口期间准备好变更。
- en: Many pkg operations produce a bunch of output. Reduce the amount of output with
    `-q`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 pkg 操作会生成大量输出。使用 `-q` 可以减少输出量。
- en: The `-a` flag usually applies a command to all installed packages.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`-a` 标志通常将命令应用于所有已安装的软件包。'
- en: Finally, pkg usually refuses to do pointless things or things that damage the
    system. The `-f` flag forces pkg to do what you said. Forcing package activities
    is usually, but not always, a bad idea. For example, you might need `-f` to forcibly
    reinstall a damaged package.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，pkg 通常拒绝做无意义的事情或破坏系统的操作。`-f` 标志强制 pkg 执行你所说的操作。强制执行软件包活动通常是个坏主意，尽管不是总是如此。例如，你可能需要
    `-f` 来强制重新安装损坏的软件包。
- en: '***Configuring pkg(8)***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置 pkg(8)***'
- en: The pkg(8) program is designed to be highly flexible. While each subcommand
    has a whole bunch of options, you can establish customized but consistent behavior
    for most programs with the configuration file, */usr/local/etc/pkg.conf*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: pkg(8) 程序设计得非常灵活。虽然每个子命令有很多选项，但你可以通过配置文件 */usr/local/etc/pkg.conf* 为大多数程序建立定制但一致的行为。
- en: The *pkg.conf* file contains commented-out defaults for pkg(8). It’s a great
    place to look to see how the system behaves when you haven’t mucked with it at
    all. The configuration is written in UCL (see [Chapter 2](ch02.xhtml#ch02)). Variables
    can be set to an integer; a string, such as a file path; or a Boolean value, like
    `YES` or `NO`. `YES`, `ON`, and `TRUE` are synonyms, as are `NO`, `OFF`, and `FALSE`.
    All are case-insensitive.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*pkg.conf* 文件包含了为 pkg(8) 注释掉的默认值。它是一个很好的地方，可以查看系统在你完全没有修改它的情况下是如何运行的。配置采用 UCL
    编写（见 [第 2 章](ch02.xhtml#ch02)）。变量可以设置为整数、字符串（如文件路径）或布尔值，像 `YES` 或 `NO`。`YES`、`ON`
    和 `TRUE` 是同义词，`NO`、`OFF` 和 `FALSE` 也是同义词。所有这些都不区分大小写。'
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: FreeBSD runs perfectly well with an empty *pkg.conf*. The default configuration
    contains a whole bunch of commented-out entries and quite a few aliases. You might
    consider these example settings as you proceed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 在 *pkg.conf* 为空的情况下也能正常运行。默认配置包含许多被注释掉的条目和相当多的别名。你可以考虑在继续时参考这些示例设置。
- en: Most pkg operations offer a yes/no dialog, showing the default as a capital
    letter. Being conservative, pkg normally defaults to `NO`. Change that default
    to `YES` with the `DEFAULT_ALWAYS_YES` option.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 pkg 操作提供一个是/否对话框，默认值显示为大写字母。为了保持保守，pkg 通常默认设置为 `NO`。可以通过 `DEFAULT_ALWAYS_YES`
    选项将默认值更改为 `YES`。
- en: You can make a pkg command assume you’ll answer yes to everything by adding
    the `-y` flag. If you get tired of typing `-y`, make pkg assume you always answer
    yes by setting the `ASSUME_ALWAYS_YES` flag to `YES`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加 `-y` 标志使 pkg 命令假设你会对所有问题回答“是”。如果你不想每次都输入 `-y`，可以通过将 `ASSUME_ALWAYS_YES`
    标志设置为 `YES`，让 pkg 始终假设你会回答“是”。
- en: 'As I’m lazy but not reckless, I prefer these *pkg.conf* settings:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我懒但不鲁莽，所以我更喜欢这些 *pkg.conf* 设置：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If installing a package runs amok, you might want debugging output. Setting
    `DEBUG_LEVEL` turns on debugging output. This variable accepts an integer from
    0 (no debugging) to 4 (complete debugging).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装软件包时出现问题，可能需要调试输出。设置 `DEBUG_LEVEL` 可以开启调试输出。此变量接受从 0（不调试）到 4（完全调试）的整数值。
- en: Many packages include scripts as part of their installation procedure. Turn
    on debugging for each script by setting `DEBUG_SCRIPTS` to `YES`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件包在安装过程中包含脚本。通过将 `DEBUG_SCRIPTS` 设置为 `YES`，可以为每个脚本启用调试。
- en: 'Any *pkg.conf* settings are also usable as environment variables. Environment
    variables override anything in the configuration file. You could install a package
    with debugging like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 *pkg.conf* 设置也可以用作环境变量。环境变量会覆盖配置文件中的任何设置。你可以像这样安装带有调试的包：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All of the options are documented in pkg.conf(5). Not all of the options have
    a commented-out entry, though. If a sample of an option doesn’t exist but you
    want it, add it. We’ll examine many of them in the following sections.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所有选项都可以在 pkg.conf(5) 中找到文档。并不是所有的选项都有注释掉的条目。如果某个选项的示例不存在但你需要它，可以自行添加。我们将在接下来的章节中详细研究其中的许多选项。
- en: '***Finding Packages***'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查找软件包***'
- en: Now that you have a package manager installed, you can install packages. Sysadmins
    familiar with a variety of Unix-like operating systems know that different operating
    systems assign different names to packaged versions of the same software. A package
    for the Apache web server on FreeBSD will have a completely different name than
    the packaged Apache on illumos or even different Linux distributions. Before you
    can install anything, you’ll need to figure out what it’s called.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了包管理器，可以安装软件包。熟悉各种类 Unix 操作系统的系统管理员知道，不同的操作系统会为同一软件的打包版本赋予不同的名称。在 FreeBSD
    上，Apache Web 服务器的软件包名称与 illumos 或其他 Linux 发行版上的 Apache 软件包名称完全不同。在你安装任何东西之前，你需要弄清楚它的名称。
- en: Suppose the client wants to run WordPress on Apache. Your job isn’t to question
    the client’s choice in web servers; your job is to build and support the web server.
    First, find Apache with the pkg search command. You’ll need to provide a text
    string for pkg to perform a case-insensitive search.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设客户想在 Apache 上运行 WordPress。你的工作不是质疑客户选择的 Web 服务器；你的工作是构建和支持 Web 服务器。首先，使用 `pkg
    search` 命令查找 Apache。你需要提供一个文本字符串，供 pkg 执行不区分大小写的搜索。
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I deliberately picked an annoying example; FreeBSD has 50-odd packages related
    to the Apache web server. Fortunately, each search result lists a one-line package
    description. It’s pretty easy to flip through the results until you find the actual
    web servers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意选了一个麻烦的例子；FreeBSD 有大约 50 个与 Apache Web 服务器相关的软件包。幸运的是，每个搜索结果都会列出一行包描述。翻阅这些结果直到找到实际的
    Web 服务器是非常简单的。
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Six different versions of Apache. First, look at the package names. When a piece
    of software comes in multiple versions, the major version number gets integrated
    into the package name. Apache 2.2 is a very different beast than Apache 2.4, so
    the packages are named *apache22* and *apache24*. The actual version number follows.
    Our first Apache 2.2 package is actually for Apache 2.2.31\. The trailing `_1`
    is the package version number, which means that this an updated package. The included
    software hasn’t changed, but the package has been altered somehow. Package version
    numbers get bumped for two reasons. When the source port changes in a way that
    has a material impact on the package, the version number is increased. When an
    ABI change in a required shared library demands recompiling the package, that
    also merits a version bump.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 六个不同版本的 Apache。首先，看一下软件包名称。当一款软件有多个版本时，主要版本号会被集成到软件包名称中。Apache 2.2 与 Apache
    2.4 有很大不同，因此这些软件包被命名为 *apache22* 和 *apache24*。实际的版本号紧随其后。我们第一个 Apache 2.2 软件包实际上是
    Apache 2.2.31。后缀 `_1` 是软件包的版本号，这意味着这是一个更新版的软件包。包含的软件没有变化，但软件包本身有所修改。软件包版本号的提升有两个原因。当源代码端口发生变化，且对软件包有实际影响时，版本号会增加。当所需的共享库发生
    ABI 更改，需要重新编译软件包时，也会提升版本号。
- en: Apache 2.2 comes in five different packages. People familiar with Apache probably
    remember that this version of Apache could use different Multi-Processing Modules
    (MPMs), but the MPM had to be selected at compile time. I have blissfully forgotten
    everything I ever knew about MPMs, so rather than fuss with them, I’ll choose
    to install the Apache 2.4 package, apache24.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Apache 2.2 有五个不同的软件包。熟悉 Apache 的人可能记得，Apache 的这个版本可以使用不同的多处理模块（MPM），但必须在编译时选择
    MPM。我已经完全忘记了关于 MPM 的所有知识，因此我选择安装 Apache 2.4 包，`apache24`。
- en: '**Package Searching Options**'
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**软件包搜索选项**'
- en: Some searches can generate hundreds of results. Try searching for Perl, and
    you’ll get about 150 packages. Perl modules all begin with the string `p5-`; FreeBSD
    has packages for over 5,200 Perl modules! Use command line options to trim or
    adjust the search results. While pkg-search(8) lists many options, here are some
    of the most common.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有些搜索会生成数百个结果。试着搜索 Perl，你会得到大约 150 个软件包。Perl 模块的名称都以字符串 `p5-` 开头；FreeBSD 拥有超过
    5200 个 Perl 模块的软件包！可以使用命令行选项来修剪或调整搜索结果。虽然 `pkg-search(8)` 列出了许多选项，这里是一些最常用的。
- en: Make a search case-sensitive with `-C`.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `-C` 使搜索区分大小写。
- en: If you know exactly which package you want, and you only want to see whether
    it’s available for your system, use the `-e` flag to search for an exact match.
    Your search term must include the package version number, though.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你确切知道自己需要哪个软件包，并且只想查看它是否适用于你的系统，可以使用 `-e` 标志来搜索精确匹配。你的搜索词必须包含软件包版本号。
- en: If you need to highly customize your searches and your search results, investigate
    the `-L`, `-S`, and `-Q` flags in pkg-search(8).
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要高度自定义你的搜索和搜索结果，请查看 `-L`、`-S` 和 `-Q` 标志，参见 pkg-search(8)。
- en: '**Examining Found Packages**'
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**检查已安装的包**'
- en: Perhaps you’re not sure whether a package is what you really want. You might
    look up details on the package from a third-party site, like FreshPorts (*[https://www.freshports.org/](https://www.freshports.org/)*),
    but that would require leaving your terminal, and I can’t countenance that. Use
    the `-R` flag to examine the repository catalog’s metadata for the package. This
    metadata is a subset of the full *package manifest* built into each package.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 或许你不确定某个包是否是你真正想要的。你可能会去第三方网站查找该包的详细信息，比如 FreshPorts (*[https://www.freshports.org/](https://www.freshports.org/)*)，但这需要离开你的终端，而我不建议这么做。使用
    `-R` 标志来查看包的仓库目录的元数据。这些元数据是每个包中内置的 *包清单* 的一个子集。
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The package manifest includes fields for the package name, the port the package
    is built from, the software version, the package repository, dependencies, and
    more. It’s rarely enough used and subject to change, so we won’t discuss it in
    detail, but scrolling through this information provides more details about the
    software inside the package.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 包清单包括包名、构建包的端口、软件版本、包仓库、依赖关系等字段。它很少被使用并且可能会发生变化，所以我们不会详细讨论，但浏览这些信息能提供关于包内软件的更多细节。
- en: One important detail here is the *www* field, which gives the website the original
    software comes from. This is the Apache web server, not a fork or some other project
    using that name.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个重要的细节是 *www* 字段，它给出了原始软件来自的网站。这是 Apache Web 服务器，而不是某个使用该名称的分支或其他项目。
- en: The default format for this raw manifest is YAML, or “YAML Ain’t Markup Language.”
    It’s yet another syntax for formatting configuration files, but it’s fairly human-readable.
    Use the `--raw-format` flag to choose an alternate format. Other supported formats
    include json and json-compact.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原始清单的默认格式是 YAML，即 “YAML Ain’t Markup Language”。它是另一种格式化配置文件的语法，但相当易于人类阅读。使用
    `--raw-format` 标志选择备用格式。其他支持的格式包括 json 和 json-compact。
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you want to automatically parse package information, this is how you grab
    the raw data.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想自动解析包信息，这就是获取原始数据的方式。
- en: '***Installing Software***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安装软件***'
- en: Use pkg’s `install` subcommand and the name of a package to install a package.
    You don’t need to give the complete package name.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pkg 的 `install` 子命令和包名来安装一个包。你不需要给出完整的包名。
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first thing that happens is that pkg checks to see whether its local copy
    of the package database is the same as that on the package server. You’ll either
    get a message like “Updating FreeBSD repository catalogue” or be told that the
    “FreeBSD repository is up to date.”
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是 pkg 检查它本地的包数据库是否与包服务器上的数据库一致。你将看到类似“正在更新 FreeBSD 仓库目录”或“FreeBSD 仓库是最新的”这样的消息。
- en: The system then checks for any packages that your chosen package requires. Read
    the dependency list. Is there anything here you don’t want installed on this host?
    Does the list give you a reason *not* to install the package?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会检查你选择的包所需的任何其他包。阅读依赖列表。列表中有你不希望安装的内容吗？这个列表是否给出了 *不* 安装该包的理由？
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As a final warning, pkg tells you how much disk space and bandwidth the installation
    requires. You then get prompted to change your mind.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的警告是，pkg 会告诉你安装所需的磁盘空间和带宽。然后你会被提示改变主意。
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Enter y, and pkg fetches the package from the repository and installs it to
    your system.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 y，pkg 会从仓库中获取该包并将其安装到你的系统上。
- en: The `install` subcommand assumes that you’re either giving the complete name
    of a package or the name of a package without the package version number. You
    can request the apache24 package and pkg will figure out that the current package
    is apache24-2.4.25_1\. You can also use the name of the port the package was built
    from, as in `pkg install` `www/apache24`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`install` 子命令假定你要么给出包的完整名称，要么给出没有版本号的包名。你可以请求 apache24 包，pkg 会自动识别当前包为 apache24-2.4.25_1。你也可以使用构建该包的端口名称，例如
    `pkg install` `www/apache24`。'
- en: In the last section, our package search turned up five different Apache 2.2
    packages, each a slightly different variant. If you ask `pkg install` to grab
    the apache22 package, it installs the version named apache22 plus a package version
    number. If you want a variant, such as apache22-event-mpm, specify the full package
    name in the `install` command.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们的软件包搜索显示了五个不同的Apache 2.2软件包，每个软件包是稍微不同的变体。如果你要求`pkg install`安装apache22软件包，它会安装名为apache22的软件包以及一个版本号。如果你想要某个变体，比如apache22-event-mpm，可以在`install`命令中指定完整的软件包名称。
- en: Some packages include installation messages. These messages might be helpful
    instructions, warnings, caveats, or anything else relevant. If the package creator
    felt a chunk of information sufficiently important enough to spend her precious
    time composing a message about it, then the least you can do is read it. You might
    use script(1) to record this information or run `pkg info --pkg-message` and the
    package name to show it again.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一些软件包包含安装消息。这些消息可能是有用的说明、警告、注意事项或其他相关内容。如果软件包创建者认为某条信息足够重要，值得花费宝贵的时间编写说明，那你至少应该阅读它。你可以使用script(1)记录这些信息，或者运行`pkg
    info --pkg-message`并指定软件包名称再次查看这些信息。
- en: '**Fetching Packages**'
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**获取软件包**'
- en: FreeBSD installs packages by downloading them over the internet. You might want
    to download packages in one location to install them elsewhere or at another time.
    Use the pkg fetch command to download but not install packages. Fetching packages
    makes the most sense when combined with `-d`, which makes `pkg fetch` grab all
    the dependencies as well as the named package.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD通过从互联网上下载软件包进行安装。你可能想在一个位置下载软件包，然后在其他地方或以后安装它们。使用pkg fetch命令可以下载但不安装软件包。结合`-d`选项使用`pkg
    fetch`命令最为合适，这样它会抓取所有依赖包以及指定的软件包。
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You’ll see the normal repository update messages, followed by a notice of what
    pkg will download.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到正常的仓库更新信息，之后会有pkg将要下载的内容通知。
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Verify that what pkg plans to download matches what you expect, and then hit
    y to proceed. The packages are downloaded to the package file cache.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 验证pkg计划下载的内容是否与预期一致，然后按y继续。软件包会下载到软件包文件缓存中。
- en: To install a downloaded package, run pkg install normally. The installation
    process uses the cached files rather than the downloaded ones.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装已下载的软件包，正常运行pkg install。安装过程会使用缓存的文件，而不是已下载的文件。
- en: Those of you who read man pages might notice the `-a` flag, which downloads
    the entire package repository. Don’t use that. The `-a` option is intended for
    public repository mirrors. Average sysadmins who mirror the entire repository
    waste bandwidth and slow down the system for everyone. Generous people donate
    FreeBSD’s package server bandwidth. Don’t waste it. You might need a whole bunch
    of packages. With dependencies, you might need hundreds or even thousands of packages.
    You don’t need tens of thousands of packages. Download only what you need.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读man页面的用户可能会注意到`-a`标志，它会下载整个软件包仓库。不要使用这个选项。`-a`选项是为公共仓库镜像设计的。普通的系统管理员镜像整个仓库会浪费带宽，且会减慢系统速度。慷慨的人捐赠了FreeBSD的软件包服务器带宽，千万不要浪费它。你可能需要下载一大堆软件包，带有依赖关系时，可能需要数百个甚至数千个软件包，但你不需要下载成千上万的软件包。只下载你需要的内容。
- en: '**Download Timing**'
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**下载时机**'
- en: Any tool that accesses the internet needs to set a maximum length of time to
    try to download files. You can customize pkg’s download behavior with two *pkg.conf*
    settings.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 任何访问互联网的工具都需要设置最大下载时间。你可以通过两个*pkg.conf*设置来定制pkg的下载行为。
- en: If a download fails, pkg tries again. The `FETCH_RETRY` option controls how
    many times pkg retries a download. The default is three, which means that it tries
    to download one time and retries up to three more times.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果下载失败，pkg会重试。`FETCH_RETRY`选项控制pkg重试下载的次数。默认情况下是三次，这意味着它会尝试下载一次，并最多重试三次。
- en: Downloads happen fairly quickly on most modern internet connections. If your
    uplink isn’t quite so modern, you might need to increase the amount of time pkg
    will spend on a single download attempt. The `FETCH_TIMEOUT` setting controls
    how long pkg waits for any one file to download. The default, 30, limits downloads
    to 30 seconds. If you’re downloading LibreOffice over a 33.6 modem, you’ll want
    to increase this setting and consider having files shipped to you on a removable
    drive via the Pony Express.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数现代互联网连接下，下载过程相当迅速。如果你的上行带宽不是那么现代，你可能需要增加pkg在单次下载尝试中花费的时间。`FETCH_TIMEOUT`设置控制pkg等待某个文件下载的时间。默认值为30，限制下载时间为30秒。如果你正在通过33.6的调制解调器下载LibreOffice，你可能需要增加这个设置，并考虑通过“马车快递”将文件送到可移动驱动器上。
- en: '***The Package Cache***'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***包缓存***'
- en: The ability to download packages and install them later implies that pkg(8)
    sticks those packages somewhere on the disk for later consumption. The package
    cache, */var/cache/pkg*, contains the original package files downloaded from the
    internet. While you can administer FreeBSD hosts for years without futzing with
    the cache, here are a few things you should know.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下载包并稍后安装的功能意味着pkg(8)会将这些包存储在磁盘上的某个地方以供以后使用。包缓存目录*/var/cache/pkg*包含从互联网下载的原始包文件。尽管你可以多年管理FreeBSD主机而无需处理缓存，但这里有一些你需要知道的事情。
- en: '**Cleaning the Cache**'
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**清理缓存**'
- en: What with upgrades, new packages, removed packages, and the gleeful randomness
    of system administration, the cache directory can fill up. My web server has only
    a few packages but somehow has accumulated 1.7GB of old package files. The `pkg
    clean` command removes any cached packages that have been replaced by newer versions,
    as well as any package files that are no longer in the repository. You’ll get
    a list of all the files that will get removed, plus a chance to proceed or quit.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于升级、新包、删除的包以及系统管理的随机性，缓存目录可能会填满。我的Web服务器只有几个包，但不知怎的已经积累了1.7GB的旧包文件。`pkg clean`命令会删除任何已被新版本替换的缓存包，以及任何不再在仓库中的包文件。你将看到所有将被删除的文件列表，并有机会继续或退出。
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you’ve never cleaned the package cache on a long-running system, the list
    will be pretty long. At the prompt, hit y to proceed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未清理过长期运行系统上的包缓存，列表可能会非常长。在提示符下，按y继续。
- en: If you want to remove all cached packages, use the `-a` flag.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想删除所有缓存的包，可以使用`-a`标志。
- en: Remember that `pkg clean` removes package files that are no longer available
    in the package repository. If you depend on a package that’s been removed from
    the repository, back up that file outside the cache before a thoughtless cleaning
    removes it forever. You could also try pkg-create(8) to rebuild a package from
    its installed components.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`pkg clean`会删除那些不再在包仓库中的包文件。如果你依赖于某个已从仓库中删除的包，在清理之前请将该文件备份到缓存之外，否则它会被无意删除。你也可以尝试pkg-create(8)来从已安装的组件重新构建一个包。
- en: If you want to clean the package cache automatically after each package install
    or upgrade, set the *pkg.conf* option `AUTOCLEAN` to true. I find autocleaning
    too aggressive, as sometimes the new bugs in an upgraded package compel me to
    revert to the older version. We cover upgrading packages at the end of this chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在每次安装或升级包后自动清理包缓存，请将*pkg.conf*中的选项`AUTOCLEAN`设置为true。我觉得自动清理过于激进，因为有时升级后的新包中的错误迫使我恢复到旧版本。我们将在本章末尾讨论包的升级问题。
- en: '**Moving the Cache**'
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**移动缓存**'
- en: You might want the package cache located elsewhere on the filesystem. Use the
    *pkg.conf* option `PKG_CACHEDIR` to set a new package cache directory.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望将包缓存放在文件系统的其他位置。使用*pkg.conf*中的选项`PKG_CACHEDIR`来设置一个新的包缓存目录。
- en: Why move the cache directory? Many server farms share a package cache across
    multiple machines. You can safely share a package cache between hosts running
    the same FreeBSD major release and hardware architecture. Verify that your NFS
    configuration uses locking, and set the *pkg.conf* option `NFS_WITH_PROPER_LOCKING`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要移动缓存目录？许多服务器集群会在多台机器之间共享一个包缓存。你可以安全地在运行相同FreeBSD主版本和硬件架构的主机之间共享包缓存。确保你的NFS配置使用了锁定，并设置*pkg.conf*中的选项`NFS_WITH_PROPER_LOCKING`。
- en: '***Package Information and Automatic Installs***'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***包信息与自动安装***'
- en: After a while, you’ll forget which packages you’ve installed on a system. Get
    the complete list of installed software with `pkg info`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间后，你会忘记你在系统上安装了哪些包。使用`pkg info`获取已安装软件的完整列表。
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you want more information about an installed package, use `pkg info` and
    the package name. This shows the package manifest and installation details in
    a human-friendly report.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于已安装包的信息，使用`pkg info`和包名。这样会显示一个易于理解的报告，列出包清单和安装细节。
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When was the package installed? Was the package installed on this machine built
    from the Ports Tree with certain options enabled? What’s the license? What shared
    libraries does every program in the package require? Answer all these and more
    with `pkg info` and the package name.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包是什么时候安装的？这个包是在这台机器上从Ports Tree构建并启用了某些选项吗？它的许可证是什么？该包中的每个程序需要哪些共享库？使用`pkg
    info`和包名，你可以回答这些问题以及更多问题。
- en: The `pkg info` subcommand has many other features. We’ll see some of them, such
    as locking status, later this chapter. The pkg-info(8) man page has the complete
    details.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg info`子命令有许多其他功能。我们将在本章稍后看到其中的一些，例如锁定状态。pkg-info(8)手册页有完整的细节。'
- en: '**Automatic Packages**'
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**自动安装包**'
- en: Look back at the sample `pkg info` output. I deliberately installed a few different
    programs on this system, but I’m pretty sure I never knowingly installed anything
    about GNU info pages or gettext.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下示例的`pkg info`输出。我故意在这个系统上安装了几个不同的程序，但我可以肯定我从未故意安装任何关于GNU信息页面或gettext的内容。
- en: I did install those programs. I merely didn’t pay much attention to what they
    were because I was more concerned about installing the package that required them.
    They’re dependencies.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实安装了那些程序。我只是没有太关注它们是什么，因为我更关心的是安装那个需要它们的包。它们是依赖项。
- en: FreeBSD records whether you requested a package be installed or it was brought
    along as a dependency. Packages installed as dependencies are called *automatic*
    packages. Packages you requested are just packages, although they’re sometimes
    called *nonautomatic* packages.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD会记录你是请求安装了某个包，还是它作为依赖项被带入。作为依赖项安装的包被称为*自动*包。你请求的包只是包，尽管有时也称它们为*非自动*包。
- en: You might want to know which packages you requested to be installed and which
    were dragged along as dependencies. That’s when things get tricky.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道哪些包是你要求安装的，哪些是作为依赖项被拖入的。到这时，事情就变得复杂了。
- en: '**Querying the Package Database**'
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**查询包数据库**'
- en: The pkg tools can’t cover every possible contingency a sysadmin might face.
    The simplest way to get some information is to interrogate the installed package
    database. While you could use raw SQLite, that would mean you’d need to become
    intimate with the database’s innards. Most sysadmins don’t have that kind of time,
    especially when that database might change any time. FreeBSD insulates from that
    with the `pkg query` subcommand. A complete survey of package queries would fill
    a chapter, but here’s a quick overview.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: pkg工具无法覆盖系统管理员可能遇到的所有情况。获取一些信息的最简单方法是查询已安装的包数据库。虽然你可以使用原始的SQLite，但那意味着你需要深入了解数据库的内部结构。大多数系统管理员没有那么多时间，特别是当数据库可能随时发生变化时。FreeBSD通过`pkg
    query`子命令隔离了这一点。完整的包查询概述会占据一章的篇幅，但这里提供一个快速的概览。
- en: '**REMOTE QUERIES**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**远程查询**'
- en: Use pkg-query(8) to search the database of installed packages. If your database
    of packages available in the repository is up to date, though, you can search
    it using pkg-rquery(8). The database of available packages doesn’t contain all
    the metadata of an installed package, however, so not all patterns are available.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pkg-query(8)来搜索已安装包的数据库。不过，如果你仓库中可用的包数据库是最新的，你也可以使用pkg-rquery(8)进行搜索。然而，可用包的数据库并不包含已安装包的所有元数据，因此并非所有模式都可以使用。
- en: Anything you might want to get out of the package database has a convenient
    representation in `pkg query`. The catch is, everything than anyone might possibly
    want to extract from the package database is in `pkg query`, as a quick perusal
    of pkg-query(8) shows. The query and command structure is deliberately designed
    for use in scripts, but we’ll use it interactively now and then.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 任何你可能想从包数据库中提取的信息，都可以通过`pkg query`轻松表示。关键是，任何人可能想从包数据库中提取的所有信息，都在`pkg query`中，正如快速浏览pkg-query(8)所展示的那样。查询和命令结构是专门为脚本使用设计的，但我们有时会互动式使用它。
- en: Run queries by using *patterns*. A pattern is a variable that has an assigned
    meaning, represented by a percent sign and a letter. For example, `%n` contains
    the package name, `%o` contains the port the package was built from, and `%t`
    contains the timestamp indicating when the package was installed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 *模式* 来运行查询。模式是一个有指定含义的变量，用百分号和字母表示。例如，`%n` 包含包名，`%o` 包含构建该包的端口，`%t` 包含表示包安装时间戳的时间戳。
- en: 'Running `pkg query` and giving a pattern produces that value for every installed
    package. As `%n` represents the package name, here’s how you’d get a list of everything
    on the system:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `pkg query` 并给定一个模式，会为每个安装的包输出该值。由于 `%n` 代表包名，以下是你如何获取系统上所有内容的列表：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We don’t get the extra information `pkg info` shows—but maybe that’s what you
    want.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有得到 `pkg info` 显示的额外信息——但也许这正是你想要的。
- en: You can request multiple items in a single query. The `%v` pattern represents
    the package version, while `%c` represents the comment. Here, I separate the package
    name and version with a dash but put a tab between the version and the comment.
    Using the shell tab character `\t` means I must quote the `pkg query` argument.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一个查询中请求多个项。`%v` 模式代表包的版本，而 `%c` 代表评论。在这里，我用破折号分隔包名和版本，但在版本和评论之间放置一个制表符。使用
    shell 制表符字符 `\t` 意味着我必须为 `pkg query` 参数加上引号。
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You know, this looks an awful lot like the output of `pkg info`. When a pkg
    command queries or manipulates the package database, it uses these exact same
    patterns. You have the same visibility into the packaging system that the rest
    of the tools do.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，这看起来非常像 `pkg info` 的输出。当 pkg 命令查询或操作包数据库时，它使用的是这些完全相同的模式。你对包装系统的可视化程度与其他工具相同。
- en: 'If you want to get a pattern for a specific package, give the package name
    as a final argument. Here, I get the port the apache24 package came from:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获取特定包的模式，将包名作为最后一个参数。在这里，我获取 apache24 包来源的端口：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We do have a middle ground between asking all the packages and specific packages,
    however.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们在查询所有包和查询特定包之间有一个中间选择。
- en: '**Evaluations in Queries**'
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**查询中的评估**'
- en: Here’s one last nifty package querying feature. Many—not all, but many—patterns
    are available as variables. A command can evaluate those variables and take action
    based on the results. Use the `-e` command line option to evaluate a variable
    with using a logical operator. A complete list of logical operators appears in
    pkg-query(8).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个最后的巧妙包查询功能。许多——但不是所有的——模式都可以作为变量使用。一个命令可以评估这些变量，并根据结果采取行动。使用 `-e` 命令行选项可以评估变量，并使用逻辑运算符。逻辑运算符的完整列表可以在
    pkg-query(8) 中找到。
- en: 'Evaluation breaks down into “if this is true, do that.” The test goes inside
    quotes. Here’s an example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 评估可以分解成“如果这个为真，就做那个”。测试放在引号内。这里有一个例子：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This query goes down the whole list of installed packages. The `-e` shows we’re
    evaluating a variable for each package. The statement inside the quotes, `%a =
    0`, means we’re testing the value of `%a` in that package. If `%a` equals 0, the
    query evaluates to true and `pkg query` prints out the contents of `%n`. If `%a`
    equals anything except 0, the statement is false and `pkg query` proceeds to the
    next package without doing anything.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询遍历了所有安装的包。`-e` 表示我们正在评估每个包的一个变量。引号内的语句 `%a = 0` 意味着我们在测试该包的 `%a` 值。如果 `%a`
    等于 0，查询就会为真，`pkg query` 会打印出 `%n` 的内容。如果 `%a` 等于 0 以外的任何值，语句为假，`pkg query` 会跳过该包并继续处理下一个包。
- en: 'We already know that `%n` contains the package name. The variable `%a` contains
    pkg’s record of whether or not the package was automatically installed. If you
    requested this particular package, it’s set to 0\. If a package was originally
    installed as a dependency, it’s set to 1\. So: if a package is not a dependency,
    print the name. This query prints nonautomatic packages.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道 `%n` 包含包名。变量 `%a` 包含 pkg 记录的包是否是自动安装的。如果你请求了这个特定的包，它被设置为 0。如果一个包最初是作为依赖安装的，它被设置为
    1。所以：如果一个包不是依赖包，就打印出包名。这个查询打印的是非自动安装的包。
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A couple things stand out here. First, I didn’t deliberately ask pkg to install
    pkg(8). I requested dmidecode, and pkg bootstrapped itself. The pkg suite itself
    is always considered a nonautomatic package, though.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几点需要注意。首先，我并没有故意请求 pkg 安装 pkg(8)。我请求了 dmidecode，而 pkg 自我引导安装了。pkg 套件本身始终被视为非自动安装的包。
- en: 'Second: who installed youtube_dl on this box?'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个：谁在这个机器上安装了 youtube_dl？
- en: To find out which packages were installed as dependencies, evaluate whether
    `%a` is set to 1.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出哪些软件包是作为依赖安装的，请检查`%a`是否设置为1。
- en: '**= OR ==?**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**= 或 ==?**'
- en: You’ll see the examples using double equal signs, as if `pkg query` were a programming
    language. My examples use a single equal sign. Surely there’s some subtle difference
    between the two and special conditions under which you should use each?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到使用双等号的示例，就像`pkg query`是编程语言一样。我的示例使用单等号。两者之间肯定有一些细微的差别，以及在特殊条件下应该使用每个符号的情况？
- en: Nope!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 不！
- en: You can use either single or double equal signs, as your muscle memory prefers.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据自己的肌肉记忆偏好使用单等号或双等号。
- en: Realistically, though, I’m not going to bother remembering how to run this query
    on all my hosts. I need a simple way to make pkg(8) remember it for me.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，我不会费心记住如何在所有主机上运行这个查询。我需要一种简单的方式让pkg(8)为我记住它。
- en: '**Pkg Command Aliases**'
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Pkg命令别名**'
- en: You can define aliases for pkg subcommands in *pkg.conf*. This lets you, say,
    create aliases to show automatic and nonautomatic commands. I could do something
    similar in my shell, but it wouldn’t show up as pkg(8) subcommands and I’m easily
    confused.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在*pkg.conf*中定义pkg子命令的别名。这允许您创建别名来显示自动和非自动命令。尽管我也可以在我的shell中做类似的事情，但它不会显示为pkg(8)子命令，而且我很容易困惑。
- en: At the bottom of *pkg.conf*, you’ll find a section labeled `ALIAS`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在*pkg.conf*的底部，您会找到一个名为`ALIAS`的部分。
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: An alias is a single word for the alias name, either a colon or an equal sign,
    and then the pkg command to run. If you run `pkg all-depends`, pkg(8) looks in
    *pkg.conf* and runs `pkg query %dn-%dv`. Every alias ends in a colon to indicate
    that the aliases list continues on the next line.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 别名是别名名称的单个单词，后跟冒号或等号，然后是要运行的pkg命令。如果您运行`pkg all-depends`，pkg(8)会在*pkg.conf*中查找并运行`pkg
    query %dn-%dv`。每个别名以冒号结尾，表示别名列表将在下一行继续。
- en: 'Many of the aliases in the default configuration represent hangovers from the
    pkg_add aeon, created for us old timers. The existing aliases are a great place
    to find sample queries and searches, though. And searching through the aliases
    turns up this fine entry:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 默认配置中的许多别名代表了从pkg_add aeon遗留下来的东西，这是为我们这些老家伙创建的。尽管如此，现有的别名是查找示例查询和搜索的好地方。而且，通过别名搜索，您会找到以下这个很好的条目：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This alias, *noauto*, runs a `pkg query` command to evaluate `%a` and print
    the package’s name and version number if it’s 0\. It prints packages that weren’t
    automatically installed. I added a very similar alias to print automatic packages.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个别名，*noauto*，运行一个`pkg query`命令来评估`%a`，并在其值为0时打印软件包的名称和版本号。它会打印那些未自动安装的软件包。我添加了一个非常相似的别名，用于打印自动安装的软件包。
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When you find yourself repeatedly running complex commands, add aliases.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当您发现自己反复运行复杂命令时，可以添加别名。
- en: '***Uninstalling Packages***'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***卸载软件包***'
- en: We’ve all installed software only to rip it out in disgust. The only difference
    is what, exactly, disgusted us. Uninstall packages with the `pkg delete` subcommand.
    It’s also available as `pkg remove`. That extraneous youtube_dl package? Let’s
    remove it from the system.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都曾安装软件，最后却因厌恶而将其卸载。唯一的区别是，究竟是什么让我们感到厌恶。使用`pkg delete`子命令卸载软件包。它也可以通过`pkg remove`来实现。那个多余的youtube_dl软件包？让我们把它从系统中移除。
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The removal process makes sure that nothing terrible has happened to the package,
    that nobody else needs it, and that its removal won’t do terrible things that
    the package system can predict.^([2](footnote.xhtml#ch15fn2))
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 删除过程会确保软件包没有出现严重问题，没有其他软件包需要它，并且它的删除不会导致软件包系统无法预测的严重问题。^([2](footnote.xhtml#ch15fn2))
- en: You’ll then get a list of packages to be removed and how much space they’ll
    free up. At the end is a final chance to say no.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将看到要删除的软件包列表以及它们释放的空间量。最后会有一个最终的机会让您选择“不”。
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The package is deleted from your system.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 该软件包已从您的系统中删除。
- en: '**Removing Dependencies**'
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**移除依赖**'
- en: If you remove a package that other packages depend on, pkg removes the depending
    packages as well.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您删除一个其他软件包依赖的包，pkg也会删除依赖的软件包。
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The gnutls package needs trousers, and emacs-nox11 needs gnutls. Removing trousers
    breaks both of them, so pkg figures you clearly don’t want them on your system
    either.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: gnutls软件包需要trousers，而emacs-nox11需要gnutls。删除trousers会破坏它们两个，因此pkg认为您显然也不想在系统中保留它们。
- en: If you really want to delete a package that other packages depend on, add the
    `-f` flag.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的想删除一个其他软件包依赖的包，请添加`-f`标志。
- en: Read the warnings from `pkg delete` *very* carefully!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请*非常*小心地阅读`pkg delete`的警告信息！
- en: '**Autoremoval**'
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**自动移除**'
- en: Leaving unnecessary software installed on a host increases the security risks
    and sysadmin workload. On a long-running system, you don’t always know which software
    to remove. Removing software you chose to install is easy, but that software might
    have brought along dependencies that you never really paid attention to. Or maybe
    a new version of a package has fewer or different dependencies than the previous
    version.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机上保留不必要的软件会增加安全风险并增加系统管理员的工作量。在长期运行的系统上，你并不总是知道该删除哪些软件。删除你选择安装的软件很容易，但这些软件可能带来了你从未关注过的依赖项。或者，某个软件包的新版本可能比旧版本具有更少或不同的依赖项。
- en: I removed the youtube_dl package from my test system. That leaves me with other
    packages I deliberately installed and their dependencies. It also leaves the packages
    youtube_dl depended on but that nothing else needs. The `pkg autoremove` subcommand
    identifies packages that were installed as dependencies but are no longer required
    by any other package. It offers to remove these no longer needed. I strongly recommend
    performing a dry run before removing unneeded dependencies, simply to give your
    feeble human brain a chance to look at the list twice.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我从我的测试系统中删除了youtube_dl软件包。这样就只剩下我故意安装的其他软件包及其依赖项。它也保留了youtube_dl依赖的但没有其他软件包需要的那些软件包。`pkg
    autoremove`子命令识别出作为依赖项安装但不再被其他任何软件包需要的软件包，并提供删除这些不再需要的软件包。我强烈建议在删除不需要的依赖项之前执行一次模拟运行，给你脆弱的人类大脑一次检查列表的机会。
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Pkg runs a database query to identify unneeded dependencies and proposes them
    for removal.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Pkg运行数据库查询以识别不需要的依赖项，并提议删除它们。
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Study this list carefully. It’s not uncommon for a piece of nonpackaged software
    to need a package that was brought in elsewhere. You probably don’t need the video
    processing tools rtmpdump and librtmp without youtube_dl, but an awful lot of
    software needs a Python interpreter. Do you *really* want to blow that away?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细研究这个列表。非软件包软件需要通过其他途径引入的软件包并不罕见。你可能不需要没有youtube_dl的rtmpdump和librtmp视频处理工具，但很多软件都需要Python解释器。你*真的*想删除它吗？
- en: If you really can remove all these packages, answer `y` and proceed. If one
    of those dependencies has become critical, though, change your database to tell
    it so.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的可以删除这些软件包，回答`y`并继续。如果其中某个依赖项变得至关重要，那么改变你的数据库来告诉它。
- en: '***Changing the Package Database***'
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***更改软件包数据库***'
- en: Thinking of changing the package database outside of pkg(8)? Don’t. You will
    only cause yourself pain, and your pleas for assistance will be met either with
    derisive laughter or suggestions to blow away all your packages and start over.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 想要在pkg(8)之外更改软件包数据库吗？不要。你只会给自己带来麻烦，寻求帮助时要么会遭遇嘲笑，要么会被建议删除所有软件包并重新开始。
- en: There are a couple circumstances where pkg(8) supports altering the package
    database, though. That’s when you can use `pkg set`. The pkg-set(8) subcommand
    lets you correctly adjust a few sensible values within the database without corrupting
    the data. The most common is when you want to make an automatic package no longer
    automatic.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个情况pkg(8)支持更改软件包数据库。那时你可以使用`pkg set`。pkg-set(8)子命令允许你在不破坏数据的情况下正确调整数据库中的一些合理值。最常见的情况是当你想让一个自动软件包不再是自动的。
- en: The `-A` flag to `pkg set` lets you change a package’s automatic setting. Setting
    this flag to 1 means that the package was installed automatically, as a dependency,
    while a 0 means that the package was specifically requested by the user.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg set`的`-A`标志允许你更改软件包的自动设置。将此标志设置为1表示该软件包是自动安装的，作为依赖项，而设置为0则表示该软件包是用户专门请求的。'
- en: In the previous section, the list of four packages to be deleted by `pkg autoremove`
    included Python. I want to keep Python—not just this time, but any time I perform
    autoremovery in the future. The simple way to do that is to change Python from
    automatic to nonautomatic.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，`pkg autoremove`要删除的四个软件包中包括了Python。我想保留Python——不仅是这次，而且是今后每次执行autoremove时。我保持Python的方法很简单，就是把它从自动软件包改为非自动软件包。
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Python is now a nonautomatic package. The results of pkg autoremove now look
    different.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Python是一个非自动软件包。`pkg autoremove`的结果现在看起来不同了。
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Only two packages instead of four? Apparently Python needs readline. I’m glad
    that pkg figured that out for me because I can’t be bothered to remember it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只剩两个软件包，而不是四个？显然Python需要readline。我很高兴pkg帮我找出了这一点，因为我实在不想记住这些。
- en: We’ll cover `pkg set` more as needed.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会根据需要进一步讲解`pkg set`。
- en: '***Locking Packages***'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***锁定软件包***'
- en: Some software is like a subway’s electrified rail. Touching it causes suffering
    or death.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有些软件就像地铁的电气化轨道。触摸它会导致痛苦或死亡。
- en: My favorite example is the remote file synchronization program rsync(8). Rsync
    has been around for decades, and its internal protocol has changed over time.
    Many embedded and legacy systems use rsync, but it’s never been upgraded. I’ve
    spent many painful hours debugging why a current rsync can’t communicate with
    that on a 20th-century embedded phone switch controller. It turned out that an
    rsync point release dropped support for the very old protocol supported by the
    phone switch. Upgrading the phone switch wasn’t possible, so I needed the rsync
    package on my host to never upgrade. *Never*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的例子是远程文件同步程序rsync(8)。rsync已经存在几十年了，其内部协议随着时间的推移发生了变化。许多嵌入式和遗留系统使用rsync，但它从未被升级。我曾花费许多痛苦的小时调试为什么当前的rsync无法与20世纪的嵌入式电话交换机控制器进行通信。结果发现，某个rsync版本的发布去掉了对电话交换机支持的非常旧协议的支持。由于无法升级电话交换机，因此我需要确保主机上的rsync软件包永远不会升级。*永远*。
- en: That’s where locking packages comes in.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是锁定软件包的作用。
- en: When you lock a package, pkg won’t upgrade, downgrade, uninstall, or reinstall
    it. It applies the same rules to the package’s dependencies and the programs it
    depends on. The host responsible for fetching the phone switch files needed to
    have its rsync package locked. Use `pkg lock` to lock a package.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当你锁定一个软件包时，pkg将不会对其进行升级、降级、卸载或重新安装。它将对软件包的依赖项和它所依赖的程序应用相同的规则。负责获取电话交换机文件的主机需要锁定其rsync软件包。使用`pkg
    lock`来锁定软件包。
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This package is now nailed in place.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个软件包现在已经固定在原位。
- en: To show all the locked packages on the system, use the `-l` flag. This shows
    only the packages you’ve deliberately locked, not the dependents or dependencies.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示系统上所有被锁定的软件包，请使用`-l`标志。这只会显示你有意锁定的软件包，而不会显示依赖项或依赖关系。
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Use the `pkg unlock` command to remove the lock.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pkg unlock`命令来移除锁定。
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To lock or unlock all packages on the system, use the `-a` flag. You’ll get
    a confirmation prompt for every package, so if you really want to affect all the
    packages, add the `-y` flag.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要锁定或解锁系统上的所有软件包，请使用`-a`标志。每个软件包都会弹出确认提示，因此，如果你真的想影响所有软件包，请添加`-y`标志。
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Package locking doesn’t prevent someone with root access from mucking with the
    files contained in a package.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包锁定并不能阻止具有root权限的人修改软件包中包含的文件。
- en: On a related note, [Chapter 22](ch22.xhtml#ch22) covers using jails to contain
    really old software.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的内容，[第22章](ch22.xhtml#ch22)讲解了如何使用监狱来限制非常旧的软件。
- en: '***Package Files***'
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***软件包文件***'
- en: Files installed by a package are considered system files, and you shouldn’t
    manually edit them. Before you *can* edit those files, you must know what files
    came with the package. Use `pkg info -l` and the package name to see the complete
    list. (It’s also available as `pkg list`, thanks to a *pkg.conf* alias.)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由软件包安装的文件被视为系统文件，你不应该手动编辑它们。在你*可以*编辑这些文件之前，必须知道哪些文件是由软件包带来的。使用`pkg info -l`和软件包名称查看完整的文件列表。（通过*pkg.conf*别名，这个信息也可以通过`pkg
    list`获得。）
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Another possibility is that you want to know which package a file came from.
    Use the `pkg which` command. I normally use this when I’ve found a weird library
    and want to know where it came from.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是你想知道某个文件来自哪个软件包。使用`pkg which`命令。当我发现一个奇怪的库时，我通常会用这个命令来看看它是从哪里来的。
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: My question is now, “What is p11-kit?” But that’s progress.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我的疑问现在是：“什么是p11-kit？”但这算是进步。
- en: '***Package Integrity***'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***软件包完整性***'
- en: While you shouldn’t alter package files, eventually, someone does. You can use
    pkg to discover those alterations and undo the damage.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你不应该修改软件包文件，但最终，还是会有人这么做。你可以使用pkg来发现这些更改并撤销损害。
- en: The pkg-check(8) tool includes features for identifying damage to packages and
    package dependencies. Developers can also use pkg-check(8) to check the bundled
    packages built from ports and distributed to end users, but that’s a whole separate
    problem.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: pkg-check(8)工具包括用于识别软件包和软件包依赖关系损坏的功能。开发者也可以使用pkg-check(8)检查从端口构建并分发给最终用户的捆绑软件包，但那是一个完全不同的问题。
- en: '**File Corruption**'
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**文件损坏**'
- en: Verify that a package’s files are unaltered with `pkg check -s` and the package
    name. When my locked rsync package stops synchronizing files from the finicky
    remote server, one thing I verify is the package integrity.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pkg check -s`和软件包名称来验证软件包文件是否未被修改。当我锁定的rsync软件包停止从挑剔的远程服务器同步文件时，我会验证其中一个事项就是软件包完整性。
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Either the disk is failing or someone has mucked with my rsync(1) binary. As
    this system uses self-healing ZFS, there’s gonna be a paddling.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要么是磁盘出现故障，要么是有人动过我的rsync(1)二进制文件。由于这个系统使用自修复的ZFS，所以会有一番“修补”。
- en: You could uninstall and reinstall the package, but that might trigger changes
    depending on which packages require the package you’re updating. Also, as discussed
    earlier, this particular package is special. I don’t want pkg to upgrade the package
    to the newest version. Instead, I want to force pkg to reinstall the current package
    from the package cache. Use the `-f` flag to `pkg install`. While it updates the
    repository database, it reinstalls the cached package. If the package is locked,
    you must unlock it first.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以卸载并重新安装这个包，但这可能会触发其他依赖该包的包发生变化。另外，正如前面讨论的，这个特定的包很特殊。我不想让pkg将这个包升级到最新版本，而是希望强制pkg从包缓存中重新安装当前版本。使用`-f`标志执行`pkg
    install`。虽然它会更新仓库数据库，但会重新安装缓存中的包。如果该包被锁定，你必须先解锁它。
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: My precious rsync is restored.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我珍贵的rsync已经恢复了。
- en: Check the integrity of all your packages by running `pkg check -saq`. It produces
    no output unless something has changed, so you could schedule it via cron (see
    [Chapter 20](ch20.xhtml#ch20)).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`pkg check -saq`检查所有包的完整性。除非有变动，否则不会产生任何输出，因此你可以通过cron定时运行它（见[第20章](ch20.xhtml#ch20)）。
- en: '**Dependency Problems**'
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**依赖性问题**'
- en: If someone really tries, they can delete packages that other packages depend
    on. Use the `-d` flag of `pkg check` to identify and fix missing dependencies.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人真的想尝试，他们可以删除其他包依赖的包。使用`pkg check`的`-d`标志来识别并修复缺失的依赖。
- en: '[PRE43]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The first thing to note is that when `pkg check` identifies a missing dependency,
    it tries to correct it. Answer y at the prompt to reinstall the dependency.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，当`pkg check`识别到缺失的依赖时，它会尝试修复它。对提示回答y以重新安装该依赖。
- en: Note that this `pkg check` run shows us a missing library, libgnutls.so.30 ➊.
    The dependency check doesn’t actually search for all the files in all of the packages.
    It knows that this library is missing only because the package that includes it
    is gone. If you manually remove the library, the dependency check won’t find it.
    You need to check package file integrity, as earlier.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个`pkg check`运行显示我们缺少一个库，libgnutls.so.30 ➊。依赖性检查实际上并不会搜索所有包中的所有文件。它之所以知道这个库缺失，是因为包含它的包已经不存在了。如果你手动删除了这个库，依赖性检查是无法找到它的。你需要像之前一样检查包文件的完整性。
- en: If you want to check all package dependencies with `pkg check -d`, don’t give
    it a package name. You could add `-a` to explicitly check all packages, but that’s
    not necessary. If you add the `-q` flag, this command produces output only when
    it finds a problem. Adding `-q` also tells `pkg check` to attempt to resolve any
    dependency problems it finds, without user intervention.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想用`pkg check -d`检查所有包的依赖关系，不要提供包名。你可以添加`-a`来显式检查所有包，但这并不是必需的。如果你添加`-q`标志，这个命令只有在发现问题时才会输出结果。添加`-q`还告诉`pkg
    check`尝试自动解决它发现的任何依赖性问题，而无需用户干预。
- en: The combination means that while I can run this check as a scheduled job, I’m
    less comfortable with my host reinstalling a missing dependency. Think about your
    system installing packages without your attention before automating dependency
    corrections.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组合意味着，虽然我可以将这个检查作为定期任务运行，但我对于我的主机重新安装缺失的依赖并不太放心。在自动修复依赖问题之前，考虑一下系统在没有你关注的情况下安装包的情况。
- en: The `pkg check` subcommand includes several other useful options, such as `-B`
    to rebuild shared library dependencies and `-r` to manually recompute the checksum
    of an installed package. Read pkg-check(8) for details.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg check`子命令包括一些其他有用的选项，例如`-B`用于重建共享库依赖，`-r`用于手动重新计算已安装包的校验和。详情请参阅pkg-check(8)。'
- en: '***Package Maintenance***'
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***包维护***'
- en: The package system includes several maintenance scripts intended to be run from
    periodic(8). Enable these in */etc/periodic.conf*, as discussed in [Chapter 20](ch20.xhtml#ch20).
    Each adds to the daily, weekly, or security status emails.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理系统包括一些维护脚本，旨在通过periodic(8)运行。从*/etc/periodic.conf*启用这些脚本，如[第20章](ch20.xhtml#ch20)所讨论的那样。每个脚本都会添加到每日、每周或安全状态的电子邮件中。
- en: To have the daily maintenance check package checksums and replace damaged packages,
    as with `pkg check -saq`, set `daily_status_security_pkg_checksum_enable` to YES.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行每日维护检查包的校验和并替换损坏的包，像`pkg check -saq`一样，将`daily_status_security_pkg_checksum_enable`设置为YES。
- en: To determine whether installed packages have security vulnerabilities published
    in the FreeBSD package security system, as discussed in [Chapter 19](ch19.xhtml#ch19),
    set `daily_status_security_pkgaudit_enable` to YES.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测已安装的软件包是否存在 FreeBSD 软件包安全系统中发布的安全漏洞，如 [第 19 章](ch19.xhtml#ch19)所讨论的，可以将
    `daily_status_security_pkgaudit_enable` 设置为 YES。
- en: If you want FreeBSD to back up the installed packages and the package database
    every day, set `daily_backup_pkg_enable` to YES.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望 FreeBSD 每天备份已安装的软件包和软件包数据库，请将 `daily_backup_pkg_enable` 设置为 YES。
- en: To be notified of changes in the installed packages, set `daily_status_pkg_changes_enable`
    to YES.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接收已安装软件包的变更通知，将 `daily_status_pkg_changes_enable` 设置为 YES。
- en: Finally, you can check for obsolete packages each week by setting `weekly_status_pkg_enable`
    to YES.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以通过将 `weekly_status_pkg_enable` 设置为 YES，每周检查过时的软件包。
- en: '***Package Networking and Environment***'
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***软件包网络配置和环境***'
- en: FreeBSD’s package system is designed to work for a normal network attached to
    the internet. That’s something of a cruel joke because no network is normal. You
    can adjust pkg’s behavior to fit your network.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 的软件包系统是为了适应普通的互联网连接网络而设计的。这有点像一个残酷的笑话，因为没有网络是“正常”的。你可以调整 pkg 的行为以适应你的网络。
- en: 'The most common change is the need for a proxy server. Pkg uses fetch(3) to
    download package files, which takes any special networking configuration through
    environment variables. Set environment variables in the `PKG_ENV` section of *pkg.conf*.
    Each variable needs the variable name, a colon, and the value. Here, I set the
    `HTTP_PROXY` environment variable to my network proxy:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的变更是需要使用代理服务器。Pkg 使用 fetch(3) 下载软件包文件，任何特殊的网络配置都可以通过环境变量进行设置。在 *pkg.conf*
    文件的 `PKG_ENV` 部分设置环境变量。每个变量需要包括变量名、冒号和对应的值。在这里，我将 `HTTP_PROXY` 环境变量设置为我的网络代理：
- en: '[PRE44]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: See fetch(3) for the complete list of proxy environment settings.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 fetch(3) 以获取完整的代理环境设置列表。
- en: Some networks have separate bandwidth for different network stacks. I’ve been
    on more than one network that has better IPv6 connectivity than IPv4, or the other
    way. Direct pkg to use one network protocol or the other with the `IP_VERSION`
    setting in *pkg.conf*. You can set this to 4, 6, or let the host autoselect with
    the default of 0.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 有些网络为不同的网络协议栈分配了独立的带宽。我曾经使用过多个网络，其中某些网络在 IPv6 上的连接速度比 IPv4 更好，或者反之。你可以通过在 *pkg.conf*
    文件中设置 `IP_VERSION` 来让 pkg 使用某个特定的网络协议。你可以将此设置为 4、6，或者让主机默认自动选择（默认为 0）。
- en: Finally, the *pkg.conf* `NAMESERVER` setting lets you override the nameservers
    given in */etc/resolv.conf*. Put an IPv4 or IPv6 address here. You can use a hostname
    here, but pkg will look up that hostname using the default system nameservers.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*pkg.conf* 文件中的 `NAMESERVER` 设置允许你覆盖 */etc/resolv.conf* 中的 DNS 服务器。在此处可以输入
    IPv4 或 IPv6 地址。你也可以使用主机名，pkg 会通过系统默认的 DNS 服务器来查找该主机名。
- en: '**Package Repositories**'
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**软件包仓库**'
- en: You might want to use packages other than those provided by the FreeBSD Project.
    Maybe you build your own packages, as discussed in [Chapter 16](ch16.xhtml#ch16).
    Perhaps you have access to an experimental package repository. Or maybe you want
    to switch which set of official packages you’re using.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望使用 FreeBSD 项目提供的以外的软件包。也许你自己构建了软件包，正如 [第 16 章](ch16.xhtml#ch16) 所讨论的那样。或者你可能有权访问一个实验性的软件包仓库。又或者你想要切换使用的官方软件包集合。
- en: Pkg supports package *repositories*, or *repos*, which are named collections
    of packages. You can add, remove, enable, and disable repositories.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Pkg 支持软件包 *仓库*，或 *repo*，它们是命名的软件包集合。你可以添加、删除、启用和禁用这些仓库。
- en: Normal repositories are very simple, but in rare cases, they can get quite complicated.
    We won’t go into the edge cases of configuring your own repositories, but the
    basics will take you quite far.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的仓库配置非常简单，但在少数情况下，它们可能会变得相当复杂。我们不会深入讨论配置自定义仓库的极端情况，但基础知识会让你走得很远。
- en: '***Repository Configuration***'
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***仓库配置***'
- en: Configure each repository in its own file. Official FreeBSD repositories belong
    in */etc/pkg*. Configure repositories in UCL format (see [Chapter 2](ch02.xhtml#ch02)).
    FreeBSD ships with the repo FreeBSD enabled. You’ll find the configuration file
    in */etc/pkg/FreeBSD.conf*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在各自的文件中配置每个仓库。官方的 FreeBSD 仓库应放置在 */etc/pkg* 目录下。仓库配置使用 UCL 格式（参见 [第 2 章](ch02.xhtml#ch02)）。FreeBSD
    默认启用了 FreeBSD 仓库。你可以在 */etc/pkg/FreeBSD.conf* 文件中找到该配置文件。
- en: '[PRE45]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This repository, named *FreeBSD*, supports the FreeBSD repo. When you decide
    to set up your own repository, give it a meaningful name.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名为 *FreeBSD* 的仓库支持 FreeBSD 的软件包仓库。当你决定设置自己的仓库时，给它起个有意义的名字。
- en: The `mirror_type` entry ➋ tells pkg whether this repository is hosted on a normal
    website. Setting `mirror_type` to `NONE` tells pkg to use fetch to get packages
    using the standard network methods, like HTTP, FTP, or even a file path.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`mirror_type` 条目 ➋ 告诉 pkg 该仓库是否托管在一个普通的网站上。将 `mirror_type` 设置为 `NONE` 会告诉 pkg
    使用 fetch 通过标准网络方法（如 HTTP、FTP，甚至是文件路径）来获取软件包。'
- en: Millions of machines run FreeBSD and need access to the package repository.
    A single web server can’t keep up. By setting `mirror_type` to `srv`, you tell
    pkg to check DNS for an SRV record. SRV records are used to direct high-availability
    services, like VoIP and Active Directory.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 数百万台机器运行 FreeBSD 并需要访问软件包仓库。单个 web 服务器无法满足需求。通过将 `mirror_type` 设置为 `srv`，你告诉
    pkg 检查 DNS 是否有 SRV 记录。SRV 记录用于引导高可用性服务，如 VoIP 和 Active Directory。
- en: The `url` entry ➊ shows the internet site where this repository can be found.
    I’m sure you’ve seen http URLs before, but what about this pkg+http thing? It
    ties the request to the SRV record used to direct pkg requests, as set by `mirror_type`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`url` 条目 ➊ 显示了该仓库所在的互联网网站。我相信你之前见过 http URLs，那这个 pkg+http 是怎么回事呢？它将请求与用于引导
    pkg 请求的 SRV 记录绑定在一起，正如 `mirror_type` 所设置的那样。'
- en: The package system can verify downloaded packages with public keys or cryptographic
    hash fingerprints ➌. You’ll need to tell pkg where to find the keys or hashes,
    though ➍.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理系统可以通过公钥或加密哈希指纹 ➌ 来验证下载的软件包。但你需要告诉 pkg 在哪里找到这些密钥或哈希 ➍。
- en: Finally, you must explicitly enable or disable ➎ each repository.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你必须显式地启用或禁用 ➎ 每个仓库。
- en: '***Repository Customization***'
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***仓库定制***'
- en: You can add and remove repositories as needed. As */etc/pkg* is reserved for
    official FreeBSD repositories, you’ll need another directory. The traditional
    location is */usr/local/etc/pkg/repos*. If you want to use a different directory,
    you’ll need to set a location in *pkg.conf* with the `REPO_DIRS` option. You’ll
    see commented-out examples for the defaults.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要添加和移除仓库。由于 */etc/pkg* 保留用于官方 FreeBSD 仓库，你需要另一个目录。传统的位置是 */usr/local/etc/pkg/repos*。如果你想使用不同的目录，你需要在
    *pkg.conf* 中通过 `REPO_DIRS` 选项设置一个位置。你将看到注释掉的默认示例。
- en: '[PRE46]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The local repository directory doesn’t exist by default, so you’ll need to create
    it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 本地仓库目录默认不存在，因此你需要创建它。
- en: '[PRE47]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Put your own repository configurations in that directory.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 将你自己的仓库配置放在那个目录里。
- en: FreeBSD searches for packages in directory order, checking directories in the
    order given in `REPOS_DIR`. The obvious implication is that the default FreeBSD
    repo can’t be disabled or overridden. That’s not quite true, but the reason is
    a little tricky.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 按照目录顺序搜索软件包，检查 `REPOS_DIR` 中给定顺序的目录。显而易见的含义是，默认的 FreeBSD 仓库不能被禁用或覆盖。虽然这不完全正确，但原因有些复杂。
- en: '***Repository Inheritance***'
  id: totrans-279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***仓库继承***'
- en: You can split a repository’s configuration between multiple files. Entries in
    later files overwrite the entries in earlier files.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将一个仓库的配置分割到多个文件中。后续文件中的条目会覆盖前面文件中的条目。
- en: To see how this works, consider the default repository, called *FreeBSD*. If
    you have all of your custom repositories configured in */usr/local/etc/pkg/repos*,
    pkg finds the FreeBSD repo first.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这如何工作，可以考虑默认的仓库，名为 *FreeBSD*。如果你在 */usr/local/etc/pkg/repos* 中配置了所有自定义仓库，pkg
    会首先找到 FreeBSD 仓库。
- en: But now create a */usr/local/etc/pkg/repos/FreeBSD.conf* file. Define the FreeBSD
    repo in there, but include only a single configuration statement.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在创建一个 */usr/local/etc/pkg/repos/FreeBSD.conf* 文件。在里面定义 FreeBSD 仓库，但只包括一个配置声明。
- en: '[PRE48]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Pkg finds the repo named FreeBSD first in */etc/pkg/FreeBSD.conf*. This configuration
    defines the defaults for this repo. It finds the second configuration later. The
    second configuration overrides only one option, but that option turns off the
    repository.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Pkg 在 */etc/pkg/FreeBSD.conf* 中首先找到名为 FreeBSD 的仓库。此配置定义了该仓库的默认设置。它稍后会找到第二个配置。第二个配置只覆盖一个选项，但该选项会禁用仓库。
- en: While disabling the FreeBSD repository is an extreme case for folks who don’t
    run their own repository, there’s good reason to make minor changes to the repo,
    as we’ll see next.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然禁用 FreeBSD 仓库是一个极端的例子，适用于那些不运行自己仓库的人，但对仓库进行小幅修改是有充分理由的，正如我们接下来将看到的。
- en: '**Package Branches**'
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**软件包分支**'
- en: FreeBSD’s packages are built from the Ports Collection (see [Chapter 16](ch16.xhtml#ch16)).
    The Ports Collection attempts to bring tens of thousands of different software
    suites to FreeBSD. These different programs all have their own release schedules,
    and the Ports Collection evolves continuously in an effort to keep up with them.
    As you can imagine, the Ports Collection has a whole bunch of churn. Most of us
    who run servers want stability. When most sysadmins consider “stability,” the
    word *churn* isn’t what comes to mind.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 的软件包是从 Ports 集合中构建的（参见[第16章](ch16.xhtml#ch16)）。Ports 集合试图将成千上万种不同的软件套件带到
    FreeBSD 上。这些不同的程序都有自己的发布计划，而 Ports 集合也在不断演进，努力跟上它们的步伐。正如你能想象的那样，Ports 集合充满了变化。我们大多数运行服务器的人都更看重稳定性。当大多数系统管理员谈到“稳定性”时，*变化*这个词并不是他们脑海中的第一印象。
- en: Most of us don’t need the very latest software on our servers. Most of the time,
    I’m fine if my database server is a minor point release or two behind; I care
    only that it keeps working. I’m certainly not going to upgrade my servers just
    because MySQL or nginx or PHP has a new software version. That way lies the madness
    of constant upgrades.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数人并不需要在服务器上安装最新的软件。大多数时候，如果我的数据库服务器只是稍微落后一个或两个小版本，我是没问题的；我只关心它是否能继续正常工作。我当然不会因为
    MySQL、nginx 或 PHP 发布了新版本就升级我的服务器。那样做会陷入不断升级的疯狂之中。
- en: I do want security and stability updates, however. The database server being
    a little older doesn’t bother me. The database server occasionally losing its
    brain and sending all my data to the bit bucket, or offering everything to a Detroit
    hacking crew, bothers me a whole bunch.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实希望获得安全性和稳定性的更新。然而，数据库服务器稍微老旧一点我并不在乎。数据库服务器偶尔失去“理智”并将我的所有数据发送到垃圾桶，或者把所有数据提供给底特律的黑客团队，这让我非常不安。
- en: The FreeBSD package system’s *quarterly branches* try to strike a middle ground
    between the world’s constant churning software and a sysadmin’s peace of mind.
    Every January, April, July, and October, the Ports crew forks the Ports Collection
    into a quarterly branch. The quarterly branch receives only security and stability
    updates, while the main Ports Collection charges merrily ahead.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 的软件包系统的*季度分支*试图在世界上不断变化的软件和系统管理员的心理平衡之间找到一个中间点。每年的一月、四月、七月和十月，Ports
    团队会将 Ports 集合分叉成一个季度分支。季度分支只会接收安全性和稳定性更新，而主 Ports 集合则继续快速发展。
- en: The FreeBSD Project builds two sets of packages for each release. The *quarterly*
    packages are built from the quarterly Ports Collection. The *latest* packages
    are built from the bleeding-edge packages.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 项目为每个版本构建了两套软件包。*季度*软件包是从季度 Ports 集合中构建的。*最新*软件包则是从前沿的软件包中构建的。
- en: Some of you prefer the most current packages, despite the churn. That’s okay.
    Switching is simple. You need override only one entry in the FreeBSD repository.
    Create a new repository file, */usr/local/etc/pkg/repos/FreeBSD.conf*, just as
    in the last section. Rather than disabling the default repository, though, we’re
    going to override the package source. Change the “quarterly” and the end of the
    URL to “latest.”
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你们中的一些人虽然不喜欢软件包频繁更新，但还是偏爱使用最新的软件包。没关系，切换很简单。你只需要覆盖 FreeBSD 仓库中的一个条目。像上一节那样创建一个新的仓库文件，*/usr/local/etc/pkg/repos/FreeBSD.conf*。不过，这次我们不会禁用默认仓库，而是要覆盖软件包来源。将
    URL 末尾的“quarterly”改为“latest”。
- en: '[PRE49]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Welcome to the churn!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到频繁变动的世界！
- en: It’s strongly recommended to run `pkg update -f` after changing repositories
    in order to force pkg to download the latest repository catalogs.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议在更改仓库后运行`pkg update -f`，以强制 pkg 下载最新的仓库目录。
- en: Switching package collections doesn’t necessarily mean you need to reinstall
    everything. If your old packages work, use them. If weird problems appear, though,
    reinstall all of your packages with a command like `pkg upgrade -fa`. Even packages
    that have the same version as those in the other package collection might be subtly
    different.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 切换软件包集合并不意味着你需要重新安装所有内容。如果你旧的软件包能正常工作，就继续使用它们。不过，如果出现奇怪的问题，可以使用类似 `pkg upgrade
    -fa` 的命令重新安装所有软件包。即使是版本相同的其他软件包，它们可能也会有所不同。
- en: '**Upgrading Packages**'
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**升级软件包**'
- en: As much as we might wish it were otherwise, you can’t set up a new system and
    ignore it. Either stability bugs appear or some clever jerk figures out a security
    exploit. ([Chapter 19](ch19.xhtml#ch19) discusses auditing package security.)
    Sometimes you must upgrade your third-party software. With FreeBSD’s original
    packaging system, pkg_add, package upgrades risked a certain degree of heartache.
    With pkg(8), you still risk heartache—but it’s from the newer versions of the
    software, not the packaging system itself.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可能希望它是另一种情况，但你不能忽视一个新系统的建立。要么会出现稳定性错误，要么某个聪明的家伙发现了一个安全漏洞。([第19章](ch19.xhtml#ch19)讨论了包安全的审计。)
    有时你必须升级第三方软件。在FreeBSD的原始包管理系统pkg_add中，包升级存在一定程度的麻烦风险。而使用pkg(8)时，你仍然会遇到麻烦——但这来自于软件的新版本，而不是包管理系统本身。
- en: Before upgrading packages, back up your system. Then, use the `upgrade` subcommand
    to have pkg(8) upgrade all your packages. I recommend running a dry run first,
    with `-n`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在升级包之前，先备份系统。然后，使用`upgrade`子命令让pkg(8)升级所有包。我建议首先运行干运行，使用`-n`选项。
- en: '[PRE50]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Carefully look at the list of packages to be upgraded. Are there any large jumps?
    Do you need to look at any release notes? How intrusive is this likely to be?
    Does the upgrade remove any packages that you want, like *X.org* or your text
    editor? Should you wait until Sunday at 3 AM and have your flunky do it?^([3](footnote.xhtml#ch15fn3))
    Studying the upgrade and considering the risks of each package upgrade might not
    reduce the amount of work you need to do, but it will reduce the amount of downtime
    and the amount of time people yell at you.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看待升级的包列表。是否有大的跳跃？是否需要查看任何发行说明？这次升级可能会造成多大影响？升级是否会移除你需要的某些包，比如*X.org*或你的文本编辑器？你是否应该等到周日凌晨3点，再让你的下属来处理？^([3](footnote.xhtml#ch15fn3))
    研究升级内容并考虑每个包升级的风险，可能不会减少你需要做的工作量，但它会减少停机时间和被人责骂的时间。
- en: Once you’re comfortable with what will change, run the upgrade.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对将要发生的变化感到满意，就可以运行升级了。
- en: '[PRE51]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You’ll see very similar messages about the packages to be upgraded and then
    notifications of the download and install process. Finally, pkg displays the installation
    message for every upgraded package.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到关于待升级包的非常相似的信息，然后是下载和安装过程的通知。最后，pkg会显示每个升级包的安装信息。
- en: Even the world’s most flexible packaging system won’t always meet your needs.
    FreeBSD makes customizing add-on software very easy through the Ports Collection,
    where we’ll go next.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是世界上最灵活的包管理系统也并不总能满足你的需求。FreeBSD通过Ports Collection使得定制附加软件变得非常容易，我们将进入下一个部分。
