- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8'
- en: LOGIC PROGRAMMING
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑编程
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common01.jpg)'
- en: '*Logic programming* derives its roots from the discipline of formal logic.
    It’s a declarative programming style that focuses on *what* needs to be done,
    rather than *how* it is to be done. The most well-known programming language in
    this arena is Prolog (see [**5**]). The great strength of Prolog, and logic programming,
    in general is that it provides a platform to express and solve certain types of
    problems (typically involving some type of search) in a natural and fluid way.
    The disadvantage is that for other types of problems, logic programming can be
    very inefficient.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*逻辑编程* 起源于形式逻辑学科。它是一种声明式编程风格，专注于 *需要做什么*，而不是 *如何做*。这一领域中最著名的编程语言是 Prolog（参见
    [**5**]）。Prolog 和逻辑编程的一个巨大优势是，它提供了一个平台，可以自然流畅地表达和解决某些类型的问题（通常涉及某种搜索）。缺点是，对于其他类型的问题，逻辑编程可能非常低效。'
- en: The good news is that Racket allows you to have the best of both worlds. Racket
    provides a Prolog-style logic programming library called *Racklog*. Racklog closely
    mirrors Prolog semantics, but as an embedded extension of the Racket syntax. The
    Racklog library can be accessed via the `(require racklog)` form.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，Racket 允许你同时享受两全其美的方案。Racket 提供了一个类似 Prolog 风格的逻辑编程库，名为 *Racklog*。Racklog
    在语义上与 Prolog 非常相似，但它是 Racket 语法的嵌入式扩展。Racklog 库可以通过 `(require racklog)` 形式访问。
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍
- en: 'Logic programming is all about facts and the relationships between facts. In
    normal Racket, to define what we consider a coffee drink, we might do it this
    way:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑编程完全围绕事实及事实之间的关系展开。在普通的 Racket 中，如果我们想定义什么是咖啡饮品，可能会这样写：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We could then ask whether something is a coffee drink by using the member function.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以通过使用成员函数来询问某个东西是否是咖啡饮品。
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Racklog way of defining our coffee facts is the following. Note that all
    built-in Racklog object names are prefixed with a percent sign (`%`) to avoid
    conflicts with the standard Racket names. Usernames aren’t required to use this
    convention.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Racklog 定义我们咖啡事实的方式如下。请注意，所有内建的 Racklog 对象名称都以百分号 (`%`) 开头，以避免与标准 Racket 名称冲突。用户名不必遵循这一惯例。
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Such a collection of facts is often referred to as a *database* in Prolog. We
    can *query* our coffee facts (technically *clauses*) via the `%which` form (asking
    *which* facts are true). Note that the purpose of the empty parentheses in the
    `%rel` and `%which` forms will become clear a bit later.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的事实集合在 Prolog 中通常被称为 *数据库*。我们可以通过 `%which` 形式（查询 *哪些* 事实为真）来 *查询* 我们的咖啡事实（技术上是
    *子句*）。请注意，稍后会解释 `%rel` 和 `%which` 形式中的空括号的目的。
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since ’`milk` is not in our `%coffee` facts, the query `(%which () (%coffee`
    ’`milk))` returned false as expected. The expression `(%coffee` ’`milk)` in the
    `%which` clause is called the *goal*. Used in this way, `%coffee` is said to be
    a *predicate*. In essence we’re asking, *Is milk a coffee?* In this case, the
    goal is said to have *failed*. When we asked about ’`latte`, our query returned
    the empty list ’`()`. A returned list of any type (even an empty one) is Racklog’s
    way of indicting success. It’s possible to query Racklog with explicit goals that
    always succeed or always fail as follows.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `milk` 不在我们的 `%coffee` 事实中，查询 `(%which () (%coffee 'milk))` 如预期返回了 false。表达式
    `(%coffee 'milk)` 在 `%which` 子句中被称为 *目标*。以这种方式使用时，`%coffee` 被称为 *谓词*。本质上，我们在问，*牛奶是咖啡吗？*
    在这个例子中，目标被认为是*失败*的。当我们询问 `latte` 时，查询返回了空列表 `()`。任何类型的返回列表（即使是空的）都是 Racklog 表示成功的方式。你也可以用明确的目标查询
    Racklog，且这些目标总是成功或总是失败，如下所示。
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Suppose we wanted to know which things are considered a coffee drink. We can
    ask this way.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想知道哪些东西被认为是咖啡饮品。我们可以这样提问。
- en: '[PRE5]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When `%which` finds a match, it returns a list of pairs. The `c` identifier
    is a local logic variable that’s used by the `%which` form to indicate which item
    was matched (that is *bound* or *instantiated*) to the identifier. Note that binding
    a logic variable is a somewhat different process than binding a Racket identifier.
    In this case, the identifier `c` isn’t assigned a value, but is rather used as
    a mechanism to associate the logic variable with a value retrieved from the database.
    While the term *bind* can be used in both senses, we’ll usually use the term *instantiate*
    to distinguish binding a logic variable from binding a Racket identifier. The
    second subform of `%which` (that is, `(c)`) can be a list of such local logic
    variables. This list is simply used as a way to declare to Racklog the logic variables
    that are being used in the remainder of the expression.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `%which` 找到匹配项时，它会返回一对对的列表。`c` 标识符是一个本地逻辑变量，`%which` 形式使用它来指示哪个项被匹配（即 *绑定*
    或 *实例化*）到该标识符。请注意，绑定逻辑变量与绑定 Racket 标识符是不同的过程。在这种情况下，标识符 `c` 并没有被赋值，而是作为一种机制，将逻辑变量与从数据库中检索到的值关联起来。虽然“绑定”这个术语可以在两种情况下使用，但我们通常会使用“实例化”这个术语来区分绑定逻辑变量和绑定
    Racket 标识符。`%which` 的第二个子形式（即 `(c)`）可以是一个这样的本地逻辑变量列表。这个列表仅仅是用来向 Racklog 声明在接下来的表达式中使用了哪些逻辑变量。
- en: What’s going on here is a process called *unification*. There are two important
    factors at work. The first is pattern matching. The second is the aforementioned
    instantiation. If there are no logic variables in a query, the structure of the
    query expression must exactly match a corresponding value in the database to succeed.
    We saw this process fail with the query attempt `(%which () (%coffee` ’`milk))`,
    since there was no exact match in the database. If logic variables are part of
    the query expression, they’re allowed to match with corresponding elements in
    the database. So far, we’ve only seen a simple example involving a query expression
    that just consists of a single logic variable where we’re querying a database
    that just contains some atomic values. We’ll soon encounter more interesting examples.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里正在发生的过程叫做 *统一*。有两个重要的因素在起作用。第一个是模式匹配。第二个是前面提到的实例化。如果查询中没有逻辑变量，那么查询表达式的结构必须与数据库中的对应值完全匹配才能成功。我们在查询尝试
    `(%which () (%coffee 'milk))` 时看到了这个过程失败，因为数据库中没有完全匹配的项。如果查询表达式中有逻辑变量，它们可以与数据库中的相应元素匹配。到目前为止，我们只看到过一个简单的例子，查询表达式只包含一个逻辑变量，而数据库只包含一些原子值。我们很快会遇到更有趣的例子。
- en: We can query our coffee database for more coffee drinks using `(%more)`. Each
    time `%more` is invoked, additional matches are generated.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `(%more)` 查询我们的咖啡数据库，以获取更多的咖啡饮品。每次调用 `%more` 时，都会生成更多的匹配项。
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that when we run out of coffee facts, `(%more)` fails (returns `#f`).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们用完咖啡事实时，`(%more)` 会失败（返回 `#f`）。
- en: 'If we just needed to know whether there’s any coffee, we could ask this way,
    where the expression `(_)` designates an anonymous variable that will match to
    anything:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只需要知道是否有咖啡，我们可以这样提问，其中表达式 `(_)` 表示一个匿名变量，它可以匹配任何内容：
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Basics
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础知识
- en: What I’ve shown you so far just looks like a more verbose way to do the same
    thing Racket already does, but Racklog is built for much more. We’ll see that
    more-complex relationships can be defined, such as parent–child. This type of
    relationship can be naturally extended to grandparent–child, and so on. Given
    that these relationships are defined in our database, we can ask questions such
    as *Who are the parents of Tom?* or *Who are Dick’s grandchildren?*
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我所展示的看起来只是在做 Racket 已经能够完成的同样事情，但 Racklog 是为更复杂的事情而设计的。我们将看到可以定义更复杂的关系，比如父子关系。这种关系可以自然地扩展到祖父母–子女关系，依此类推。由于这些关系已在我们的数据库中定义，我们可以提出这样的问题，例如
    *Tom 的父母是谁？* 或 *Dick 的孙子是谁？*
- en: '***Knowing Your Relatives***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***了解你的亲戚***'
- en: Knowing about coffee drinks probably won’t keep you awake at night, but knowing
    who your relatives are just might. That not withstanding, we’re going to create
    a little parent–child database to further expand our knowledge of Racklog.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 了解咖啡饮品可能不会让你彻夜未眠，但知道你的亲戚是谁可能会。尽管如此，我们将创建一个简单的父子数据库，进一步扩展我们对 Racklog 的了解。
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first item of each relation is the parent, and the second is the child (in
    reality you can decide which is which; it’s just a convention). Suppose that after
    `%parent` was defined, it was discovered that ’`Lisa` and ’`Maggie` needed to
    be added as children of ’`Homer`. This can be remedied by use of one of two `%assert!`
    forms.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个关系的第一个项是父母，第二个是孩子（实际上，你可以决定哪个是哪个；这只是一种约定）。假设在定义了`%parent`后，发现`Lisa`和`Maggie`需要作为`Homer`的孩子被添加进来。这可以通过使用两种`%assert!`形式之一来解决。
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first expression adds ’`Homer` as a parent of ’`Lisa` after all the other
    clauses. But be aware that `%assert-after!` adds a clause *before* all the other
    clauses (don’t ask us). To demonstrate this, let’s find all the children of ’`Homer`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个表达式将`Homer`作为`Lisa`的父母添加到所有其他子句之后。但是要注意，`%assert-after!`会在所有其他子句*之前*添加子句（不要问我们为什么）。为了演示这一点，让我们找出`Homer`的所有孩子。
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It isn’t necessary to pre-populate a relation with values. We can create an
    empty relation and add items to it as shown here.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要预先填充关系的值。我们可以创建一个空关系，并像这样向其中添加条目。
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We don’t need to constrain ourselves to a single generation. We can also ask
    about grandparents. A grandparent is someone whose child is a parent of someone
    else. We can define such a relationship in this way:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必局限于单一的世代。我们也可以询问祖父母。祖父母是指那些子女是他人父母的人。我们可以这样定义这种关系：
- en: '[PRE12]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this case, the second subform ➊ is a list of symbols `(g p c)` (representing
    grandparent, parent, and child respectively). As mentioned with `%which`, this
    list is simply a way to declare to Racklog the local logic variables that will
    be used in the rest of the expression. Unlike other relations where each clause
    only contained a single expression, in this case the clause has three expressions.
    If you’re familiar with Prolog (don’t worry if you’re not), this would be expressed
    as something like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，第二个子形式➊是一个符号列表`(g p c)`（分别表示祖父母、父母和孩子）。如同`%which`所提到的，这个列表只是向Racklog声明将在其余表达式中使用的局部逻辑变量。与其他关系不同，每个子句只包含单个表达式，而在这个例子中，子句包含了三个表达式。如果你熟悉Prolog（如果你不熟悉也没关系），这可以表示为如下形式：
- en: '[PRE13]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: An expression of this type is known as a *rule*. In the Racklog version, we
    have the expression being matched against ➋. In Prolog terminology, this is known
    as the *head* of the rule (the Racket code `(g c)` would be equivalent to `grand(G,C)`
    in the Prolog version). Following this, we have two subgoals (known as the rule
    *body*) that must also be matched ➌. In plain English this is interpreted to mean
    `g` is the grandparent of `c` if `g` is the parent of `p` and `p` is the parent
    of `c`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的表达式被称为*规则*。在Racklog版本中，我们将该表达式与➋进行匹配。在Prolog术语中，这被称为规则的*头部*（Racket代码`(g
    c)`在Prolog版本中相当于`grand(G,C)`）。接下来，我们有两个子目标（称为规则的*主体*），也必须与➌匹配。用通俗的话来说，这意味着如果`g`是`p`的父母，并且`p`是`c`的父母，那么`g`就是`c`的祖父母。
- en: Let’s take a look at what happens with the query `(%which (k) (%grand` ’`Tom
    k))`, which is asking which person (`k`) is a grandchild of ’`Tom`. With this
    query, the local variable `g` ➌ of our `%grand` definition is instantiated to
    the value ’`Tom`. The variables `k` and `c` are tied together (even though neither,
    as yet, has a concrete value); as mentioned above, the process of associating
    these variables is called *unification*. Racklog then scans through its parent
    database (assuming our original set of parents) until it finds an entry where
    ’`Tom` is a parent. In this case, there’s a record indicating that ’`Tom` is the
    parent of ’`Dick`. So the first subgoal succeeds with the result being that `p`
    is instantiated to ’`Dick`. Now the second subgoal is tested (`(%parent p c)`,
    which through unification becomes `(%parent` ’`Dick c)`). Racklog scans its parent
    database and finds that ’`Dick` is the parent of ’`Harry`, at which point the
    variable `c` (and by unification `k`) is instantiated to the value ’`Harry`. Executing
    the query in DrRacket, we indeed arrive at the expected results.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看查询`(%which (k) (%grand` ’`Tom k))`的执行过程，这个查询是在问谁是`Tom`的孙子（`k`）。通过这个查询，我们的`%grand`定义中的局部变量`g`
    ➌ 被实例化为`Tom`。变量`k`和`c`被关联在一起（尽管它们目前还没有具体的值）；如上所述，关联这些变量的过程称为*统一*。Racklog随后扫描其父数据库（假设我们有原始的父母数据集），直到找到一条记录，其中`Tom`是父母之一。在这种情况下，有一条记录显示`Tom`是`Dick`的父亲。因此，第一个子目标成功，结果是`p`被实例化为`Dick`。现在，第二个子目标被测试（`(%parent
    p c)`，通过统一变成了`(%parent` ’`Dick c)`）。Racklog扫描其父数据库，发现`Dick`是`Harry`的父亲，此时变量`c`（通过统一也就是`k`）被实例化为`Harry`。在DrRacket中执行该查询时，我们确实得到了预期的结果。
- en: '[PRE14]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we want to see if ’`Tom` has any other grandchildren, we can use `(%more)`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想看看`Tom`是否有其他孙子，可以使用`(%more)`。
- en: '[PRE15]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: At the point that the original match was made for ’`Harry`, parent (`p`) was
    instantiated to ’`Dick`. What’s happening behind the scenes with `(%more)` is
    that it’s actually triggering a failure of the rule. Racklog then *backtracks*
    over the goal `(%parent p c)` and uninstantiates the variable `c` (it does not
    uninstantiate `p`, since this was instantiated in the previous goal). It then
    looks through the database for another match for a parent of ’`Dick` and finds
    a second record with ’`Harriet` as his child (hence, a grandchild to ’`Tom`).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初匹配`Harry`时，父母（`p`）被实例化为`Dick`。在`(%more)`背后发生的事情是，它实际上触发了规则的失败。Racklog随后*回溯*到目标`(%parent
    p c)`，并且将变量`c`进行反实例化（它不会反实例化`p`，因为`p`是在之前的目标中实例化的）。然后它在数据库中查找`Dick`的另一个父母匹配，找到了第二条记录，显示`Harriet`是`Dick`的孩子（因此是`Tom`的孙子）。
- en: 'One nice feature of logic programming is that the same relation allows questions
    to be asked in different ways. We’ve asked who is ’`Tom`’s grandchild, but we
    could also ask who has grandchildren by framing our query this way:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑编程的一个优点是同一关系可以以不同的方式提问。我们问了谁是`Tom`的孙子，但我们也可以通过以下方式来问谁有孙子：
- en: '[PRE16]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Or we could ask whether ’`Homer` is a grandparent.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以问`Homer`是否是祖父。
- en: '[PRE17]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is one way in which Racklog extends the capability of Racket. We’ll see
    more of this type of flexibility in the next section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Racklog扩展Racket功能的一种方式。我们将在下一节中看到更多这种灵活性的例子。
- en: 'If we simply wanted to list the parents, we could use the goal `(%parent p
    (_))`, followed by entering some number of `(%more)` commands. It can be a bit
    cumbersome to have to keep entering `(%more)` to see if a goal can be re-satisfied.
    One way around this is to use `%bag-of`. The `%bag-of` predicate takes three arguments:
    a Racket expression we want to return (in this case, just the value of the logic
    variable `p`), the goal to test (in this case `(%parent p (_))`), and a variable
    to instantiate the computed list of results to (also `p`). Here’s an example.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是想列出父母，可以使用目标`(%parent p (_))`，然后输入一些`(%more)`命令。每次都输入`(%more)`以查看目标是否能够重新满足，确实有些繁琐。解决这个问题的一种方法是使用`%bag-of`。`%bag-of`谓词接受三个参数：我们想要返回的Racket表达式（在这种情况下，就是逻辑变量`p`的值），要测试的目标（在此为`(%parent
    p (_))`），以及用来实例化计算出的结果列表的变量（也就是`p`）。这里有一个例子。
- en: '[PRE18]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, we just used `p` as the computed value, but we could dress up
    the output a bit by forming a query this way (from this we see that the value
    of logic variable `p` is `cons`’d with the literal ’`parent` to produce the final
    result).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只是使用了`p`作为计算结果，但我们可以通过这种方式构造查询来稍微美化一下输出（从中可以看出，逻辑变量`p`的值与字面量`parent`一起使用，生成最终结果）。
- en: '[PRE19]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here’s a simpler way to get a similar output.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一种更简单的方式来获得类似的输出。
- en: '[PRE20]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using `%bag-of` and `%find-all` will list values in the same order that would
    result from using `(%more)`. Because of this, some entries may be repeated (such
    as ’`Dick` in this example). To only get unique values, we can use `%set-of` instead.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`%bag-of`和`%find-all`将按与使用`(%more)`相同的顺序列出值。因此，一些条目可能会重复（例如本例中的`Dick`）。为了只获得唯一值，我们可以改用`%set-of`。
- en: '[PRE21]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this section, we’ve covered some of the basic ideas behind logic programming.
    For a more detailed description of backtracking, unification, and such, refer
    to the classic (and very approachable) work on the subject in *Programming in
    Prolog* by Clocksin and Mellish [**5**].
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了一些逻辑编程的基本思想。如需更详细地了解回溯、统一等内容，请参阅Clocksin和Mellish所著的经典且易于理解的作品《*Prolog编程*》[**5**]。
- en: '***Racklog Predicates***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Racklog谓词***'
- en: So far we’ve explored some of the fundamental capabilities that Racklog offers.
    Logic programming is a unique paradigm that dictates the need for some specialized
    tools to make it fully useful. In this section, we’ll take a look at a few of
    those tools.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探索了Racklog提供的一些基本功能。逻辑编程是一种独特的范式，要求使用一些专门的工具才能充分发挥其作用。在本节中，我们将介绍其中的一些工具。
- en: '**Equality**'
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**等式**'
- en: We’ve seen that unification plays a key role in the semantics of logic programming.
    Racklog provides the equality predicate `%=`, which uses unification in a direct
    way to test structural equality and implement the instantiation process. The following
    examples should provide some insight into various ways in which this predicate
    can be applied.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，统一在逻辑编程的语义中起着关键作用。Racklog提供了等式谓词`%=`, 它直接使用统一来测试结构相等性并实现实例化过程。以下示例应能为这个谓词的应用提供一些见解。
- en: '[PRE22]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: What’s happening in the first example is subtle. Note that `(1 potato sack)`
    is in fact equivalent to `(1 . (potato sack))` and `(cons a b)` is equivalent
    to `(a . b)`. This means that via unification, `a` gets instantiated to 1 and
    `b` gets instantiated to `(potato sack)`. The result is ’`((a . 1) (b potato sack))`.
    An instantiation is always shown as a pair, but we see the first element, `(a`
    `. 1)`, displayed as a pair and the second element, `(b potato sack)`, shown as
    a list. Recall that a list *is* in fact a pair, just displayed a bit differently.
    In the case of `(b potato sack)`, `b` is the `car` of the pair and `(potato sack)`
    is the `cdr` of the pair.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子中发生的情况比较微妙。请注意，`(1 potato sack)`实际上等同于`(1 . (potato sack))`，而`(cons a b)`等同于`(a
    . b)`。这意味着通过统一，`a`被实例化为1，`b`被实例化为`(potato sack)`。结果是`((a . 1) (b potato sack))`。实例化总是以对的形式显示，但我们看到第一个元素`(a
    . 1)`显示为一对，第二个元素`(b potato sack)`显示为列表。回想一下，列表*实际上*就是一对，只是显示方式略有不同。在`(b potato
    sack)`的例子中，`b`是这一对的`car`，`(potato sack)`是这一对的`cdr`。
- en: 'The opposite of `%=` is `%/=`, which means not unifiable. Recall that unification
    is essentially a matching process. Leveraging the last example, observe the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`%=`的相反是`%/=`，表示无法统一。回想一下，统一本质上是一个匹配过程。利用上一个例子，观察以下内容：'
- en: '[PRE23]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: While in the first example it was possible to instantiate the logic variable
    `a` to 5, the attempt to match the 4 in the first list to the 5 in the second
    list caused the unification to fail. In the second example, the unification still
    failed, but since we used the not-equal predicate, a list was returned with the
    logic variable `a` unbound.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，虽然可以将逻辑变量`a`实例化为5，但尝试将第一个列表中的4与第二个列表中的5匹配导致了统一失败。在第二个例子中，统一仍然失败，但由于我们使用了不相等谓词，因此返回了一个列表，逻辑变量`a`保持未绑定状态。
- en: Similar to the equality predicate is the *identical* predicate `%==`. Unlike
    `%=`, `%==` does not do any instantiation. It checks to see whether two expressions
    are *exactly* the same.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于等式谓词的是`*identical*`谓词`%==`。与`%=`不同，`%==`不进行任何实例化。它检查两个表达式是否*完全*相同。
- en: '[PRE24]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The opposite of `%==` is `%/==`, which means not identical.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`%==`的相反是`%/==`，表示不相等。'
- en: '**Let**'
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Let**'
- en: It’s sometimes desirable to use local variables in a query to produce an intermediate
    result and not have those variables shown in the output. The `%let` predicate
    provides a way to establish these hidden variables.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望在查询中使用局部变量来生成中间结果，而不希望这些变量出现在输出中。`%let`谓词提供了一种建立这些隐藏变量的方式。
- en: '[PRE25]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, the `%bag-of` predicate creates a cons pair from the result
    of `friends` and instantiates it to `pals`. Here `a` and `b` are lexically local
    to the `%let`, so only the unified results are passed out of the expression to
    `pals`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`%bag-of` 谓词从 `friends` 的结果创建了一个 cons 对，并将其实例化为 `pals`。这里 `a` 和 `b` 是
    `%let` 的词法局部变量，因此只有统一的结果被传递到 `pals`。
- en: '**Is**'
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**是**'
- en: 'The `%is`predicate acts a bit differently than the other Racklog predicates.
    It takes two arguments: the first expression is frequently (but not always) an
    identifier and the second a normal Racket expression. The `%is` expression instantiates
    the result of evaluating the second expression to the first. Normally, all identifiers
    in the second expression will need to be instantiated before the `%is` expression
    is evaluated. The `%is` expression can be used to assign a value to the first
    argument or to test equality.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`%is` 谓词的作用与其他 Racklog 谓词略有不同。它有两个参数：第一个表达式通常（但不总是）是标识符，第二个是普通的 Racket 表达式。`%is`
    表达式将第二个表达式求值的结果实例化为第一个表达式。通常，第二个表达式中的所有标识符需要在求值 `%is` 表达式之前先实例化。`%is` 表达式可以用来给第一个参数赋值或测试相等性。'
- en: '[PRE26]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: One difference between `%is` and `%=` is that for `%is`, any logic variables
    in its second argument generally need to be instantiated, as seen in these examples.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`%is` 和 `%=` 之间的一个区别是，对于 `%is`，它的第二个参数中的任何逻辑变量通常需要先实例化，正如这些例子所示。'
- en: '[PRE27]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There are, however, situations where `%is` may be advantageous. See the Racket
    manual for details.^([1](footnote.xhtml#ch08foot_1))
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，`%is` 可能更有优势。详细信息请参见 Racket 手册^([1](footnote.xhtml#ch08foot_1))。
- en: '**Arithmetic Comparisons**'
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**算术比较**'
- en: Racklog uses `%=:=` to test for numeric equality and `%=/=` to test for numeric
    inequality, but the other predicates are what you’d normally expect.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Racklog 使用 `%=:=` 来测试数值相等，使用 `%=/=` 来测试数值不等，但其他谓词则是你通常期望的。
- en: '[PRE28]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that these comparisons only perform tests without instantiating logic variables,
    so an expression like `(%which (a) (%=:= a 2))` will fail.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些比较只执行测试，而不会实例化逻辑变量，因此像 `(%which (a) (%=:= a 2))` 这样的表达式会失败。
- en: '**Logical Operators**'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**逻辑运算符**'
- en: Racklog supports the expected logical predicates `%not`, `%and`, and `%or`,
    as shown below. The built-in `%fail` goal always fails, and the `%true` goal always
    succeeds.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Racklog 支持常见的逻辑谓词 `%not`、`%and` 和 `%or`，如下所示。内置的 `%fail` 目标总是失败，而 `%true` 目标总是成功。
- en: '[PRE29]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There’s also an `%if-then-else` predicate: when given three goals, if the first
    goal succeeds, it evaluates the second goal; otherwise, it evaluates the third
    goal. Here’s a little test framework.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 `%if-then-else` 谓词：当给定三个目标时，如果第一个目标成功，它会求值第二个目标；否则，它会求值第三个目标。这里有一个小的测试框架。
- en: '[PRE30]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The following exchange illustrates `%if-then-else` in action.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下交换示例展示了`%if-then-else`的实际应用。
- en: '[PRE31]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Because ’`broccoli` isn’t in the `%spud` database, the last goal is evaluated
    and ’`unknown` is instantiated to `taste` (via `t`).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因为’`broccoli` 不在 `%spud` 数据库中，最后的目标被求值，’`unknown` 被实例化为 `taste`（通过 `t`）。
- en: '**Append**'
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**附加**'
- en: We’ve already seen the standard Racket version of `append`, which is a function
    that (typically) takes two lists and returns a list that consists of the two lists
    concatenated together, as shown below.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到过标准的 Racket 版本的 `append`，它是一个函数，通常接受两个列表并返回一个由这两个列表连接而成的新列表，如下所示。
- en: '[PRE32]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is a one-way street. We only get to ask one question: if I have two lists,
    what does the resulting list look like if I join the lists together? With the
    Racklog version we are about to explore, we can also ask these questions:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一条单行街道。我们只能问一个问题：如果我有两个列表，将这两个列表合并后的结果列表是什么样的？在我们即将探索的 Racklog 版本中，我们还可以问这些问题：
- en: If I have a result list, what other lists can I combine to get this list?
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我有一个结果列表，还有哪些其他列表可以组合成这个列表？
- en: If I have a starting list and a resulting list, what list can I join to the
    starting list to get the resulting list?
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我有一个起始列表和一个结果列表，哪个列表可以加入到起始列表中以得到结果列表？
- en: If I have an ending list and a result list, what list can I join to the start
    of the ending list to get the result list?
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我有一个结束列表和一个结果列表，什么列表可以加入到结束列表的开头来得到结果列表？
- en: If I have three lists, is the third list the result of appending the first two?
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我有三个列表，第三个列表是将前两个列表拼接的结果吗？
- en: Before we explain how Racklog’s `%append` works, let’s take a look at a few
    examples. This first query answers the original question (the result of concatenating
    two lists).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解释 Racklog 的 `%append` 是如何工作的之前，让我们先看看几个例子。第一个查询回答了原始问题（两个列表连接的结果）。
- en: '[PRE33]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This query answers question two.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询回答了第二个问题。
- en: '[PRE34]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This query answers question three.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询回答了第三个问题。
- en: '[PRE35]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: And this query answers question one.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 而这个查询回答了第一个问题。
- en: '[PRE36]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Generating all possibilities that satisfy certain conditions is one of the strengths
    of logic programming.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 生成满足特定条件的所有可能性是逻辑编程的强项之一。
- en: 'If `%append` weren’t already defined in Racklog, it would be easy enough to
    create it from scratch (adapted from [**5**]):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `%append` 在 Racklog 中还没有定义，我们可以很容易地从头开始创建它（改编自 [**5**]）：
- en: '[PRE37]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'So what’s going on with our predicate `%append`? It consists of two clauses.
    The first ➊ simply says that if the first list is empty, the result of concatenating
    that list to any list `l` is just `l`. The second clause ➋ is more complicated:
    `((cons h l1) l2 (cons h l3))` is the head of a rule. The head of this rule expects
    three arguments, each of which is either a list or an uninstantiated variable:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们的谓词 `%append` 到底是怎么回事呢？它由两个子句组成。第一个 ➊ 简单地表示，如果第一个列表为空，则将该列表与任何列表 `l` 连接的结果就是
    `l`。第二个子句 ➋ 比较复杂：`((cons h l1) l2 (cons h l3))` 是规则的头部。该规则的头部需要三个参数，每个参数要么是一个列表，要么是一个未实例化的变量：
- en: The first element of this argument (if a list) is instantiated to `h`, and the
    rest of the list is instantiated to `l1`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果该参数是一个列表，则其第一个元素会被实例化为 `h`，其余的部分会实例化为 `l1`。
- en: The second argument is instantiated to `l2`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个参数被实例化为 `l2`。
- en: If the third argument is a logic variable, `(cons h l3)` is used to construct
    the return value from the `h` provided in the first argument and `l3` produced
    in the recursive call to `%append` ➌. If this argument is a list, its head must
    match the `h` in the first argument, and the rest of the list is matched to `l3`
    in the last line ➌.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果第三个参数是逻辑变量，则使用 `(cons h l3)` 从第一个参数中提供的 `h` 和在递归调用 `%append` ➌ 时生成的 `l3` 来构建返回值。如果该参数是一个列表，则它的头部必须与第一个参数中的
    `h` 匹配，剩余的列表部分将与最后一行中的 `l3` 匹配 ➌。
- en: As we’ve seen, any one or two of the arguments to `%append` may simply be an
    uninstantiated variable. Racklog uses its unification process to link concrete
    values to the appropriate values and uses placeholders to temporarily allocate
    space for the other variables until a proper instantiation can be made. We consider
    the case where the first and second arguments are instantiated to explicit lists.
    Once the unification process is complete ➋, the variables `l1` (instantiated to
    the tail of the first supplied list) and `l2` (instantiated to the second list)
    are used to make a recursive call to `%append` ➌ with the expectation that `l3`
    will be populated by the recursive call with the result of concatenating the now
    shorter list `l1` with `l2`. Since `(cons h l3)` is used to form the final value,
    the end result is that both the original supplied lists are concatenated together.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`%append` 的任何一个或两个参数可能只是一个未实例化的变量。Racklog 使用它的统一过程将具体值与适当的值关联，并使用占位符临时分配空间，以便在适当的实例化后为其他变量分配空间。我们考虑一下第一和第二个参数被实例化为显式列表的情况。一旦统一过程完成
    ➋，变量 `l1`（实例化为第一个提供的列表的尾部）和 `l2`（实例化为第二个列表）将用于递归调用 `%append` ➌，期望通过递归调用将现在更短的列表
    `l1` 与 `l2` 连接，最终填充 `l3`。由于 `(cons h l3)` 被用来构造最终值，最终结果就是将两个原始提供的列表连接在一起。
- en: 'Here’s a walk-through where we append ’`(1)` and ’`(2 3)` (for the sake of
    brevity, we’ll use the equal sign (=) to indicated logic variable bindings):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个演示过程，我们将 ’`(1)` 和 ’`(2 3)` 连接起来（为了简洁起见，我们将使用等号（=）来表示逻辑变量绑定）：
- en: The first step is to call `(%which (a) (%append` ’`(1)` ’`(2 3) a))`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是调用 `(%which (a) (%append` ’`(1)` ’`(2 3) a))`。
- en: Then comes our first port of call ➊. Since ’`(1)` doesn’t match ’`()`, we fall
    through to the next case.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们来到了第一个判断点 ➊。由于 ’`(1)` 不匹配 ’`()`, 我们继续执行下一个情况。
- en: At this point in the code we have `h=1`, `l1=`’`()` and `l2=`’`(2 3)` ➋ (we’ll
    get to `l3` later; it’s used to construct the returned value).
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时在代码中我们有 `h=1`，`l1=`’`()` 和 `l2=`’`(2 3)` ➋（稍后我们会看到 `l3`，它用于构造返回值）。
- en: Next is the recursive call ➌. With the instantiated values, this resolves to
    `(%which (l3) (%append` ’`()` ’`(2 3) l3))`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是递归调用 ➌。通过实例化的值，结果为 `(%which (l3) (%append` ’`()` ’`(2 3) l3))`。
- en: We’re at our first port of call again ➊, but now the empty lists do match. With
    `l=`’`(2 3)` instanciated with `l3`, we return `l3=`’`(2 3)`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次来到第一个判断点 ➊，但现在空列表确实匹配。通过将 `l=`’`(2 3)` 与 `l3` 实例化，我们返回 `l3=`’`(2 3)`。
- en: Since we’ve returned from the recursive call, the logic variable will be back
    to the values given in step 3; of particular interest is `h=1`. But now we also
    have the value returned from the recursive call of `l3=`’`(2 3)`. Our code ➋ says
    that our return value (`a`) from this stage is constructed from `(cons h l3)`.
    That’s ’`(1 2 3)`, the desired end result.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经从递归调用中返回，逻辑变量将恢复到第3步中给出的值；特别感兴趣的是`h=1`。但是现在我们也得到了从`l3=’(2 3)`的递归调用中返回的值。我们的代码
    ➋ 表示从这一阶段返回的值（`a`）是由`(cons h l3)`构造的。那就是`(1 2 3)`，即所需的最终结果。
- en: Other instantiation scenarios can be analyzed in a similar fashion.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 其他实例化场景可以以类似的方式进行分析。
- en: '**Member**'
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**成员**'
- en: 'Another Racket function that has a Racklog equivalent is `%member`. If we needed
    to create this function ourselves, one way to do it would be the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有Racklog等价物的Racket函数是`%member`。如果我们需要自己创建这个函数，一种实现方式如下：
- en: '[PRE38]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Is should be clear that this first checks to see if `x` is at the start of the
    list (that is, `(cons x (~_))` assigns `x` the value at the head of the list,
    so it must match the value being searched for); if not, it checks to see if it
    occurs somewhere in the rest of the list.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 应该很明显，首先检查`x`是否位于列表的开头（也就是说，`(cons x (~_))`将`x`赋值为列表头部的值，因此它必须匹配正在查找的值）；如果不是，它会检查它是否出现在列表的其余部分。
- en: 'Examples:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE39]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***Racklog Utilities***'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Racklog 工具***'
- en: In this section, we’ll look at implementing a few additional predicates in Racklog.
    These are all common list operations whose implementations show off the capabilities
    of logic programming and Racklog. We’ll only make use of the `%permutation` predicate
    later (which we’ll explain in detail). You can take the remainder as black boxes,
    meaning that we illustrate what they do and how to use them via provided examples,
    without providing detailed explanations of the code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究在Racklog中实现一些额外的谓词。这些都是常见的列表操作，其实现展示了逻辑编程和Racklog的能力。稍后我们将使用`%permutation`谓词（我们会详细解释）。其余的可以视为黑盒，即我们通过提供的示例来展示它们的功能和用法，而不对代码进行详细解释。
- en: '**Select**'
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**选择**'
- en: Depending on how `select` is used, it can either pick single items from a list,
    return a list with an item removed, or return a list with an item inserted. Here’s
    the definition.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`select`的使用方式，它可以从列表中选择单个项、返回一个删除项的列表，或返回一个插入项的列表。以下是其定义。
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: And here are some examples.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些示例。
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Subtract**'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**减法**'
- en: The `%subtract` predicate is designed to remove one set of elements in a list
    from the set of elements in another list. It leverages the functionality of the
    `%select` predicate to achieve its result. The implementation is straightforward
    and should be easy to understand.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`%subtract`谓词旨在从一个列表中的元素集合中删除另一个列表中的元素集合。它利用`%select`谓词的功能来实现其结果。实现非常直接，应该容易理解。'
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first parameter of the predicate is the source list of items, the second
    parameter is the list of items to be removed, and the last parameter is the list
    to be returned.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词的第一个参数是源列表，第二个参数是需要删除的项的列表，最后一个参数是返回的列表。
- en: Here are a few examples illustrating the use of `%subtract`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些说明`%subtract`用法的示例。
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Permutation**'
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**排列**'
- en: It can sometimes be useful to obtain all the permutations of a given list. To
    provide a bit of background on how the following predicate works, it’s helpful
    to imagine a simple way of generating all the permutations of a given list. Suppose
    we have a list of the digits from 1 to 4\. It’s clear that each digit must, at
    some point, appear as the first digit in the list. So one approach is to start
    with four lists, each of these consisting of a single digit from 1 to 4\. For
    each of these lists, we create a corresponding list that contains all the remaining
    digits as shown below.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有时获得给定列表的所有排列是有用的。为了提供以下谓词的工作原理的一些背景，想象一种生成给定列表所有排列的简单方法是很有帮助的。假设我们有一个从1到4的数字列表。显然，每个数字必须在某一时刻作为列表中的第一个数字出现。因此，一种方法是从四个列表开始，每个列表由1到4中的一个数字组成。对于这些列表中的每一个，我们创建一个对应的列表，包含所有剩余的数字，如下所示。
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We’ve now made our problem a bit smaller. Instead of having to generate all
    the permutations of a list of four digits, we now only need a way to generate
    the permutations of a list of three digits. Of course we’re smart enough to know
    that we can recursively continue this process to work on smaller and smaller lists.
    All that remains is to just join the parts back together. This is essentially
    what the `%permutation` predicate does.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在把问题缩小了一些。我们不再需要生成四个数字列表的所有排列，而只需要生成一个三位数字列表的排列。当然，我们足够聪明，知道可以递归地继续这个过程，处理更小的列表。剩下的就是将各部分重新组合起来。这实际上就是
    `%permutation` 谓词所做的事情。
- en: Before diving into the code, it’s helpful to recall that `%append` can be used
    not just to append two lists together, but to find all the ways a list can be
    split into two parts. For example, if we call `%which (l1 l2)` ’`(1 2 3 4)`, one
    of the possible outputs is ’`((l1) (l2 1 2 3 4))` (the value of `l1` is the empty
    list). With that bit of background under our belt, here’s the predicate (the code
    is adapted from [5]).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，回顾一下 `%append` 的作用是很有帮助的，它不仅可以将两个列表连接在一起，还可以找到列表分割成两部分的所有方式。例如，如果我们调用
    `%which (l1 l2)` `'`(1 2 3 4)`，其中一个可能的输出是 `'`((l1) (l2 1 2 3 4))`（`l1` 的值是空列表）。有了这些背景知识之后，这里是谓词（代码来源于
    [5]）。
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This predicate takes two arguments: a list to permutate and an identifier to
    instantiate the returned list of permutations to. Let’s see what happens when
    we call `(%which (a) (%permutation` ’`(1 2 3 4) a))`. Because the list isn’t empty,
    we blow by the first match attempt ➊. Next, we have `l=`’`(1 2 3 4)` ➋. The rest
    of the code at this point is used to construct the return value, so we’ll come
    back to that a bit later. The next line is where things get a bit interesting
    ➌. As mentioned above, the first call to `%append` with a list as its third argument
    will yield an empty list and the list ’`(1 2 3 4)`. With this result, we have
    `v =` ’`()`, `h=1`, and `u=`’`(2 3 4)`. Moving to the next line, we see that `v=`’`()`
    and `u=`’`(2 3 4)` are instantiated but `w` is not, so `(%append v u w)` just
    binds `w` to ’`(2 3 4)` ➍. Finally, we generate the permutations of ’`(2 3 4)`
    and instantiate the result to `t` ➎. We’re now in a position to construct the
    return value(s) ➋. This will generate all the permutations that start with 1.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谓词接受两个参数：一个要排列的列表和一个标识符，用于实例化返回的排列列表。让我们看看当我们调用 `(%which (a) (%permutation`
    `'`(1 2 3 4) a))` 时会发生什么。因为列表不为空，我们跳过了第一次匹配尝试 ➊。接下来，我们有 `l=`'`(1 2 3 4)` ➋。此时其余的代码用于构造返回值，我们稍后再回到这一部分。下一行开始有些有趣的变化
    ➌。正如前面提到的，第一次调用 `%append` 时，第三个参数是一个列表，它会生成一个空列表和列表 `'`(1 2 3 4)`。通过这个结果，我们有 `v
    =` `'()`，`h=1`，`u=`'`(2 3 4)`。接着看下一行，`v=`'`()` 和 `u=`'`(2 3 4)` 被实例化了，但 `w` 并没有，所以
    `(%append v u w)` 只是将 `w` 绑定到 `'`(2 3 4)` ➍。最后，我们生成 `'`(2 3 4)` 的排列，并将结果实例化为 `t`
    ➎。现在我们处于构造返回值的阶段 ➋。这将生成所有以 1 开头的排列。
- en: So what about the remaining permutations? Once we’ve exhausted all the permutations
    starting with 1, via backtracking ➌, we eventually have `%append` yielding the
    lists ’`(1)` and ’`(2 3 4)`. At this point we have `v=`’`(1)`, `h=2`, and `u=`’`(3
    4)`, so now we have `w=`’`(1 3 4)` ➍. The process continues as before, now constructing
    the permutations of lists starting with 2.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 那剩下的排列呢？一旦我们通过回溯 ➌ 耗尽了以 1 开头的所有排列，我们最终得到 `%append` 生成的列表 `'(1)` 和 `'(2 3 4)`。此时我们有
    `v=`'`(1)`，`h=2`，`u=`'`(3 4)`，所以现在我们有 `w=`'`(1 3 4)` ➍。过程继续进行，就像之前一样，现在开始构建以 2
    开头的列表的排列。
- en: Let’s look at the different ways we can arrange the four card suits.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何安排四种扑克牌的花色。
- en: '[PRE46]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'By making a small adjustment, we can create a version of `%permutation` that
    generates all permutations of a certain length by taking an additional parameter,
    the desired length:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过做一个小调整，我们可以创建一个版本的 `%permutation`，它通过额外的参数——所需的长度——来生成某一长度的所有排列：
- en: '[PRE47]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The exclamation point (`!`) on the third line is called a *cut*. The cut is
    a goal that always succeeds, but is used to prevent backtracking across the cut.
    What this means is that if the goal immediately following the cut fails (via backtracking
    or any other reason), the cut prevents backtracking to any previous goals. In
    this case, once we reach a count of zero, there’s no need to look for additional,
    longer permutations. This will make the process a bit more efficient (that is,
    the predicate will still work properly without it, but without testing additional
    permutations that are not needed).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行中的感叹号（`!`）称为 *cut*。cut 是一个总是成功的目标，但它用于防止在 cut 之前回溯。这意味着，如果紧跟在 cut 后面的目标失败（无论是通过回溯还是其他原因），cut
    会阻止回溯到任何之前的目标。在这个例子中，一旦我们达到了零的计数，就不需要再寻找额外的、更长的排列。这将使过程更加高效（也就是说，谓词在没有它的情况下仍然能正常工作，但不会测试那些不必要的额外排列）。
- en: 'Due to the pattern matching done by Racklog, there’s no need to have two separate
    predicates. We can combine these into a single predicate as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Racklog 的模式匹配功能，我们不需要使用两个独立的谓词。我们可以将它们合并为一个谓词，具体如下：
- en: '[PRE48]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here are a couple of examples:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个例子：
- en: '[PRE49]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now that we’ve laid the groundwork, let’s look at a few applications.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经打下了基础，让我们来看几个应用实例。
- en: Applications
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用实例
- en: So far, we’ve introduced the basic mechanics of logic programming. As interesting
    as these topics are, we’ll now take a look at solving some real world (but recreational)
    problems. Here we’ll see how logic programming provides a framework to solve problems
    using a declarative style that more directly mirrors the problem constraints.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了逻辑编程的基本机制。尽管这些话题很有趣，但接下来我们将看看如何解决一些现实世界中的（但属于娱乐性质的）问题。在这里，我们将看到逻辑编程如何提供一个框架，通过声明式的方式来解决问题，更直接地映射问题的约束条件。
- en: '***SEND + MORE = MONEY***'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SEND + MORE = MONEY***'
- en: The following famous recreational math problem was published in the July 1924
    issue of *The Strand Magazine* by Henry Dudeney.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下面这个著名的娱乐数学问题由 Henry Dudeney 在 1924 年 7 月的《The Strand Magazine》上发表。
- en: '![Image](../images/p0245-01.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0245-01.jpg)'
- en: 'Each letter represents a different digit in the solution. Problems of this
    type are variously known as alphametics, cryptarithmetic, cryptarithm, or word
    addition. While this problem can be solved with just a pencil and paper, we’re
    going to leverage Racket (via Racklog) to solve it instead. We’re going to use
    an approach that’s generally frowned on: brute force. This means we’re going to
    generate (almost) all the possible ways we can assign numbers to the letters (it’s
    obvious that M is 1, so we won’t bother looking for that value).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字母代表解答中的一个不同数字。这类问题通常被称为字母算式、加密算术、加密算式或文字加法。尽管这个问题可以通过纸和笔来解决，我们将利用 Racket（通过
    Racklog）来解决它。我们将使用一种通常不被推荐的方法：穷举法。这意味着我们将生成（几乎）所有可能的方式，将数字分配给字母（显然 M 是 1，所以我们不会再去寻找那个值）。
- en: In the following code, we use the `%permute-n` predicate defined in the previous
    section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们使用了上一节定义的 `%permute-n` 谓词。
- en: '[PRE50]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The predicate to solve the puzzle is `%solve` ➍. First, it assigns 1 to M as
    previously discussed. The unique letters (aside from M) used in this puzzle are
    S, E, N, D, O, R, and Y. The next step is to generate all the possible permutations
    of ’`(0, 2, 3, 4, 5, 6, 7, 8, 9)` ➎ (taken 7 numbers at a time). A call to the
    predicate `%check` is used to test whether the particular permutation will result
    in a solution to the puzzle (more on `%check` in a bit). If the current permutation
    generates a solution, the resulting assignments are returned ➏. Note that if `%check`
    fails, we backtrack ➎ to generate another permutation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 解这个谜题的谓词是 `%solve` ➍。首先，它将 1 分配给 M，如前所述。这个谜题中使用的唯一字母（除了 M）是 S、E、N、D、O、R 和 Y。下一步是生成所有可能的排列
    `'(0, 2, 3, 4, 5, 6, 7, 8, 9)` ➎（每次取 7 个数字）。调用 `%check` 谓词来测试特定排列是否能解出这个谜题（稍后会介绍
    `%check`）。如果当前排列生成了一个解，结果的赋值将被返回 ➏。请注意，如果 `%check` 失败，我们将回溯 ➎ 以生成另一个排列。
- en: The code for `%check` is also fairly simple. At the first `%is` statement ➋,
    we just form the arithmetic sum for the current permutation of `s1` = SEND + MORE
    (remember M is implicitly 1—here expanded to 1000). At the second `%is` statement
    ➌, we form the sum `s2` = MONEY. Finally we test whether `s1` = `s2`. Due to the
    fairly lengthy arithmetic expressions ➋ ➌, we’re taking advantage of the *infix*
    library so that the computation is clear.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`%check`的代码也相当简单。在第一个`%is`语句 ➋ 中，我们只需为当前排列计算算术和 `s1` = SEND + MORE（记住M隐含为1——这里扩展为1000）。在第二个`%is`语句
    ➌ 中，我们计算和 `s2` = MONEY。最后，我们测试 `s1` 是否等于 `s2`。由于算术表达式 ➋ ➌ 相当冗长，我们利用了 *infix* 库，使得计算过程更为清晰。'
- en: We generate the solution as follows.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如下生成了解决方案。
- en: '[PRE51]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Even though we’re using a highly inefficient brute-force approach, on a fairly
    healthy computer, the solution should appear in under a minute.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们使用的是一种效率非常低的暴力破解方法，在一台相对健康的计算机上，解答应该在一分钟之内出现。
- en: '***Fox, Goose, Beans***'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***狐狸、鹅和豆子***'
- en: 'The fox, goose, and a bag of beans puzzle is an example of a class of puzzles
    called river crossing puzzles. It’s quite old and dates back to at least the 9th
    century. These types of puzzles are a natural fit for logic programming systems.
    The narrative of the puzzle goes something like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 狐狸、鹅和豆子谜题是河流过河类谜题的一个例子。这种谜题相当古老，至少可以追溯到9世纪。这类谜题非常适合逻辑编程系统。谜题的叙述大致是这样的：
- en: Once upon a time, a farmer went to the market and purchased a fox, a goose,
    and a bag of beans. On his way home, the farmer comes to the bank of the river
    where he left his boat. But his boat is rather small, and the farmer can carry
    only himself and a single one of his purchases—the fox, the goose, or the bag
    of the beans. If left alone, the fox would eat the goose, and the goose would
    eat the beans.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 从前，一位农民去市场买了狐狸、一只鹅和一袋豆子。回家的路上，农民来到河边，他把船停在了那里。但他的船很小，农民只能带着自己和他购买的其中一个物品——狐狸、鹅或豆子。如果留下狐狸，它会吃掉鹅；如果留下鹅，它会吃掉豆子。
- en: The farmer’s task is to get himself and his purchases (still intact) to the
    far bank of the river. How does he do it?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 农民的任务是将自己和他的购买物品（保持完好）带到河的另一岸。他是如何做到的呢？
- en: While this puzzle is not difficult to solve by hand, it affords us an opportunity
    to exercise the inherent ability of Racklog to perform a *depth-first search (DFS)*.
    To get some idea of how this type of search works, imagine you’re on a small island
    and need to get to the lighthouse, but you don’t know how to get there and you
    don’t have a map. One way to get to your destination is just to begin driving
    and every time you get to a fork in the road, carefully record which path you
    take. You keep going until you either arrive at your destination or you get to
    a dead end or a place you already visited. If you get to a dead end or a place
    you already visited, you *backtrack* to the previous fork and take a path you
    haven’t taken before. If you’ve already tried all the paths at a particular fork,
    you backtrack to the fork before that. Eventually, if you keep working in this
    fashion, you’ll have tried all the possible paths and arrived at your destination
    or you’ll discover that you’re actually on the wrong island (oops).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个谜题手动解答并不困难，但它为我们提供了一个机会，展示Racklog执行 *深度优先搜索（DFS）* 的固有能力。为了帮助你理解这种搜索是如何工作的，可以想象你在一个小岛上，需要到达灯塔，但你不知道该怎么走，也没有地图。到达目的地的一个方法是开始行驶，每次遇到分岔路口时，仔细记录下你走的路。你继续前进，直到到达目的地，或者走到死胡同或已经走过的地方。如果你到达死胡同或已经走过的地方，你需要
    *回溯* 到上一个分岔口，选择一条没走过的路。如果你已经尝试过所有分岔口的路径，你会回到更早的分岔口。最终，如果你按照这种方式继续工作，你将尝试所有可能的路径，最终到达目的地，或者你会发现自己其实在错误的岛屿上（哎呀）。
- en: 'Assume the farmer travels east and west across the river. Using the DFS strategy,
    we keep track of which items we’ve had on each bank as the search progresses.
    We begin then with a record of all items on the east bank. At any point, we may
    elect to travel back to the opposite bank without an item, or we may select a
    single item to carry back to the opposite bank (as long as these movements do
    not violate the constraints of the puzzle). We must also ensure that the resulting
    movement does not create an arrangement of items that previously existed. For
    example, suppose we begin by carrying the goose across the river. We now have
    two stored states: one with all the items (including the farmer) on the east bank,
    and one with the fox and beans on the east bank with the farmer and goose on the
    west bank. At this point the farmer may elect to travel alone back to the east
    bank, since this generates a new state, but if the farmer (stupidly) carries the
    goose back to the east bank, this results in a state already seen (the start state)
    and should not be considered. Play continues in this fashion until the solution
    is found.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 假设农夫在河流两岸之间往返。使用深度优先搜索（DFS）策略，我们在搜索过程中跟踪每一岸上放置了哪些物品。然后我们从所有物品都在东岸的记录开始。任何时候，我们可以选择不带物品返回对岸，或者选择携带一件物品回到对岸（前提是这些动作不违反谜题的约束）。我们还必须确保，所做的移动不会造成之前已经存在的物品排列。例如，假设我们首先将鹅带过河。现在我们有两个已存状态：一个是所有物品（包括农夫）都在东岸，另一个是狐狸和豆子在东岸，农夫和鹅在西岸。此时，农夫可以选择独自返回东岸，因为这会生成一个新的状态，但如果农夫（愚蠢地）将鹅带回东岸，这将导致已经出现过的状态（起始状态），因此不应考虑。游戏以这种方式继续进行，直到找到解决方案。
- en: The west bank is designated by the number 0, and the east bank designated by
    the number 1\. A four-element vector is used to keep track of the program state.
    Each element of the vector will indicate the location (that is, bank) of each
    character, as indicated in [Table 8-1](ch08.xhtml#ch8tab1).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 西岸用数字0表示，东岸用数字1表示。使用一个四元素向量来跟踪程序状态。向量的每个元素将表示每个角色的位置（即岸），如[表8-1](ch08.xhtml#ch8tab1)所示。
- en: '**Table 8-1**: Fox, Goose, Beans State Vector'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-1**：狐狸、鹅、豆子状态向量'
- en: '| **Index** | **Character** |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| **索引** | **角色** |'
- en: '| --- | --- |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | Farmer |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 农夫 |'
- en: '| 1 | Fox |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 狐狸 |'
- en: '| 2 | Goose |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 鹅 |'
- en: '| 3 | Beans |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 豆子 |'
- en: We begin by defining which states aren’t permissible in a predicate called `%rejects`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义哪些状态在谓词`%rejects`中是不允许的。
- en: '[PRE52]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The first rejected state indicates that if the farmer is on bank 0, it’s not
    permissible to have the fox, goose, and beans on bank 1\. The remaining states
    can be analyzed in a similar fashion. Observing the pattern of the numbers, `%rejects`
    can be written a bit more succinctly:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个被拒绝的状态表明，如果农夫在0号岸，则不允许狐狸、鹅和豆子都在1号岸。其余状态可以类似地进行分析。通过观察数字模式，`%rejects`可以更简洁地编写：
- en: '[PRE53]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If the farmer moves an item from one bank to the other, it’s necessary to toggle
    both the farmer’s bank and the item’s bank. This is handled by the `toggle-item`
    function, which takes a state vector and an element index and returns a new state
    vector. Notice that’s a normal Racket function and not a Racklog predicate. How
    this fits in will be shown next.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果农夫将物品从一岸移到另一岸，就必须切换农夫的岸和物品的岸。这是由`toggle-item`函数处理的，该函数接受一个状态向量和一个元素索引，并返回一个新的状态向量。请注意，这是一个普通的Racket函数，而不是Racklog谓词。接下来将展示这一点如何适应。
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The code `(zero? i)` tests for the farmer’s index (0), and `(= i a)` checks
    for the item’s index ➊. Recall that `for/vector` forms a new vector from the results
    of each item computed in the `let` body.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 代码`(zero? i)`测试农夫的索引（0），而`(= i a)`检查物品的索引 ➊。回忆一下，`for/vector`根据`let`体中计算的每个项的结果形成一个新的向量。
- en: 'The `%gen-move` predicate below generates moves consisting of each of the four
    possible types of boat passengers (represented by the numbers 0 through 3 respectively):
    the farmer alone, or the farmer with a fox, goose, or bag of beans.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的`%gen-move`谓词生成的移动包括四种可能的船上乘客类型（分别用数字0到3表示）：农夫单独，或农夫带狐狸、鹅或一袋豆子。
- en: '[PRE55]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The predicate is initially called with the list ’`(0 1 2 3)` (representing
    all the items that can be moved) and the current state. It returns a pair with
    the `car` indicating the item being moved and the `cdr` giving the resulting state.
    We have the situation where there are no items left to move ➊, so the next line
    simply toggles the state of the farmer. Notice the cut (!): there’s no need to
    generate additional moves, since there’s nothing left to move. Next, we have a
    non-empty list, so we take the head of the list and toggle the state of that item
    ➋. Finally, we tackle the rest of the list with a recursive call to `%gen-move`
    ➌.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词最初使用列表’`(0 1 2 3)`（表示所有可以移动的项目）和当前状态进行调用。它返回一个对，其中`car`表示正在移动的项目，`cdr`给出结果状态。我们遇到了没有剩余项目可以移动的情况
    ➊，因此下一行仅切换农民的状态。注意切割（!）：不需要生成额外的移动，因为没有剩余的项目可以移动。接下来，我们有一个非空列表，因此我们取列表的头部并切换该项目的状态
    ➋。最后，我们使用递归调用`%gen-move`处理其余的列表 ➌。
- en: As the search progresses, it’ll be necessary to ensure that the program doesn’t
    get into an infinite loop by rechecking states that have already been tested.
    To facilitate this, we maintain a list that contains the states that have already
    been visited, and pass this list and a state to check to a `%check-history` predicate.
    If the state is in the history list, the check will fail.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 随着搜索的推进，需要确保程序不会通过重新检查已经测试过的状态进入无限循环。为此，我们维护一个包含已访问状态的列表，并将此列表和待检查的状态传递给`%check-history`谓词。如果该状态在历史列表中，检查将失败。
- en: '[PRE56]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, we’ve encountered a previous state, so we fail without backtracking by
    following the cut with `%fail` ➊.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遇到了一个先前的状态，因此通过紧随其后的`%fail` ➊失败而不回溯。
- en: Next up is the `%gen-valid-move` predicate. This predicate is passed the current
    state and move history. It first generates a potential move and checks whether
    the items left on the bank after the move form a legitimate combination (that
    is, the state isn’t in the reject list). If so, it then checks whether the current
    state has been seen before. If not, it returns the move as a valid move.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`%gen-valid-move`谓词。该谓词接收当前状态和移动历史。它首先生成一个潜在的移动，并检查移动后银行上剩余的项目是否形成一个合法的组合（即状态不在拒绝列表中）。如果是，它接着检查当前状态是否曾经出现过。如果没有，它将返回这个移动作为有效的移动。
- en: '[PRE57]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'With the previous appetizers under our belt, we now move on to the main course:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的开胃菜，我们现在进入正餐：
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The overall strategy is quite simple: generate a valid move and check for the
    solved state. If we reach a dead-end, Racklog’s automatic backtrack mechanism
    will back up and try another move that doesn’t lead to a previous state. The `%solve`
    predicate is called with the initial state, an empty list (representing the state
    history), and a list with the moves generated so far (also empty). The final parameter
    is an identifier to be instantiated to the list of moves solving the puzzle. First
    we check to see whether the puzzle is in the solved state ➊; if so, we return
    the move list. If this isn’t the case, we get the next move candidate and resulting
    state ➋ (these are assigned to `move` ➌), which is used to recursively call `%solve`
    ➍. If a failure is generated by the `%solve` predicate ➍, backtracking occurs.
    Since `%is` cannot be re-satisfied, backtracking continues back ➋ where another
    possible solution is generated. The `%solve` predicate returns a pair: the first
    element is an indicator of the passengers in the boat (see discussion of `%gen-move`
    for meaning of numbers), and the second is the state of the east bank after the
    move.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 整体策略非常简单：生成一个有效的移动并检查是否到达解决状态。如果我们遇到死胡同，Racklog的自动回溯机制将回退并尝试另一个不会导致重复状态的移动。`%solve`谓词以初始状态、一个空列表（表示状态历史）和一个包含至今生成的移动的列表（也是空的）进行调用。最后一个参数是一个标识符，将被实例化为解决难题的移动列表。首先，我们检查谜题是否处于解决状态
    ➊；如果是，我们返回移动列表。如果不是，我们获取下一个移动候选和结果状态 ➋（这些被赋值给`move` ➌），然后递归调用`%solve` ➍。如果`%solve`谓词
    ➍ 生成了失败，回溯发生。由于`%is`不能重新满足，回溯会继续回到 ➋ 处，生成另一个可能的解决方案。`%solve`谓词返回一个对：第一个元素是船上的乘客指示器（有关数字的含义，请参见`%gen-move`的讨论），第二个元素是移动后的东岸状态。
- en: 'To actually solve the puzzle, we call `%solve` as shown here:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正解决这个难题，我们像这样调用`%solve`：
- en: '[PRE59]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In addition to being in reverse order, the output listing leaves a bit to be
    desired in terms of readability. To get a more intuitive output, we define a couple
    of new helper procedures. First, we create a Racklog predicate version of the
    Racket `printf` form that we call `%print`. It takes a format string as its first
    argument and a value to print as its second. Making this work requires a bit of
    a trick. The `printf` function can’t be called as a Racklog goal since it isn’t
    a predicate. It doesn’t return a value, so normal instantiation won’t work. The
    trick is to enclose the `printf` form in a `begin` form (which evaluates expressions
    in order and returns the value of the last one), where we return `#t` as its final
    expression. We can then use `%is` to instantiate this with the constant `#t` to
    create a predicate that always succeeds.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 除了顺序被反转外，输出列表在可读性上还有些欠缺。为了获得更直观的输出，我们定义了几个新的辅助过程。首先，我们创建了Racklog谓词版的Racket `printf`形式，称为`%print`。它的第一个参数是格式化字符串，第二个参数是要打印的值。让它工作需要一些技巧。由于`printf`函数不是谓词，所以不能作为Racklog目标调用，也不会返回值，因此正常的实例化方法无法工作。技巧在于将`printf`形式封装在`begin`形式中（该形式按顺序求值表达式，并返回最后一个表达式的值），我们将`#t`作为最终表达式返回。然后，我们可以使用`%is`实例化它，得到一个始终成功的谓词。
- en: '[PRE60]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The second helper procedure is a regular Racket function that takes a state
    vector and a bank number. It returns a list indicating which items are currently
    on the bank.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个辅助过程是一个常规的Racket函数，它接受一个状态向量和一个银行编号。它返回一个列表，指示当前银行上有哪些物品。
- en: '[PRE61]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Given a list of solution moves, `%print-moves` (see below) will provide two
    lines of output for each move: the first line will indicate the direction of movement
    and the passenger(s) of the boat; the second line of output will consist of a
    list where the first item is the occupants of bank 0 and the second item is the
    occupants of bank 1\. We leave it as a little exercise for the reader to figure
    out how it works.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一系列解法步骤，`%print-moves`（见下文）将为每个步骤提供两行输出：第一行将表示移动方向和船上的乘客；第二行输出将是一个列表，其中第一个项目是银行0的占用者，第二个项目是银行1的占用者。我们将此作为一个小练习留给读者去理解其工作原理。
- en: '[PRE62]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, we have this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到了这个：
- en: '[PRE63]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The procedure `%print-solution` doesn’t take any arguments, but it generates
    the solution of the puzzle, reverses the list of moves, and calls `%print-moves`
    to print out the solution. Here’s the much more readable end result:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 过程`%print-solution`不接受任何参数，但它会生成谜题的解法，反转动作列表，并调用`%print-moves`打印出解法。这里是一个更易读的最终结果：
- en: '[PRE64]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Recall that the final empty list is Racklog’s way of indicating success.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，最终的空列表是Racklog表示成功的方式。
- en: '***How Many Donuts?***'
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***多少块甜甜圈？***'
- en: 'The following problem appeared in the October 27, 2007, “AskMarilyn” column
    of *Parade* magazine:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题出现在2007年10月27日的*Parade*杂志“AskMarilyn”专栏中：
- en: Jack, Janet, and Chrissy meet at their corner coffeehouse and buy half a dozen
    donuts. Each friend always tells the truth or always lies. Jack says that he got
    one donut, but Janet says that Jack got two, and Chrissy says that Jack got more
    than three. On the other hand, all three friends agree that Janet got two. Assuming
    that each friend got at least one and that no donut was cut and divided, how many
    donuts did each friend get?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Jack、Janet和Chrissy在他们常去的咖啡馆碰面并买了六个甜甜圈。每个朋友要么总是说真话，要么总是撒谎。Jack说他拿了一块甜甜圈，但Janet说Jack拿了两块，Chrissy则说Jack拿了三块以上。另一方面，三个人都一致认为Janet拿了两块。假设每个人至少拿了一块，而且没有甜甜圈被切分，问每个人拿了多少块甜甜圈？
- en: Logic programming systems eat this type of problem for breakfast (donuts, breakfast—funny,
    eh?), and Racklog is no exception. What’s nice about this problem is that its
    solution in Racklog is mainly just a declarative statement of the facts (embellished
    with a few helper items).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑编程系统对于这种类型的问题简直是轻松应对（甜甜圈，早餐——有趣吧？），而Racklog也不例外。这个问题的特别之处在于，在Racklog中的解决方案主要只是对事实的声明（并附带了一些辅助项）。
- en: Here are a few basic definitions; the comments should be sufficient to explain
    their function.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些基本定义；注释应该足以解释它们的功能。
- en: '[PRE65]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The intent here is to determine how many donuts an individual can have, if we
    say they can’t have a certain number (provided as the second argument). Since
    `%can-have` gives all the donuts a person can have, the statement `(%=/= n d)])`
    will give all the donuts they can have, excluding the number they can’t have.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目的是确定一个人可以拥有多少个甜甜圈，前提是我们说他们不能拥有某个数量（作为第二个参数提供）。由于`%can-have`给出了一个人可以拥有的所有甜甜圈，语句`(%=/=
    n d)])`将给出他们可以拥有的所有甜甜圈，排除他们不能拥有的数量。
- en: Now we list each person’s statement in two versions (one in case they’re telling
    the truth, and the other in case they’re lying). Here we are abbreviating “Chrissy”
    to “Chris.”
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们以两种版本列出每个人的陈述（一种是他们说真话的情况，另一种是他们撒谎的情况）。这里我们将“Chrissy”缩写为“Chris”。
- en: '[PRE66]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Our solver just needs to check each person’s statements and see if the total
    donuts add up to six.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的求解器只需要检查每个人的陈述，并查看总甜甜圈是否加起来为六个。
- en: '[PRE67]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'And voilà:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后就像魔法一样：
- en: '[PRE68]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '***Boles and Creots***'
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Boles 和 Creots***'
- en: Boles and Creots is an old pencil and paper code-breaking game. It’s also known
    as Bulls and Cows, or Pigs and Bulls. A commercial variation, called *Mastermind*,
    involves codes consisting of colored pegs. Gameplay progresses by one player selecting
    a secret code (typically a sequence of four or five unique digits or letters).
    The other player then proposes a guess, to which they’re provided a hint consisting
    of the number of boles (correct digits in the correct position) and the number
    of creots (correct digits in the wrong position). The players continue exchanging
    guesses and hints until the guessing player gets all digits in the proper order.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Boles 和 Creots 是一种传统的纸笔破译游戏，也叫做 Bulls 和 Cows，或 Pigs 和 Bulls。一种商业变体叫做 *Mastermind*，使用的是由彩色小圆钉组成的代码。游戏玩法是由一个玩家选择一个秘密代码（通常是四个或五个独特的数字或字母组成的序列）。另一个玩家然后提出一个猜测，系统提供提示，告诉他们有多少个
    boles（正确的数字在正确的位置）和多少个 creots（正确的数字在错误的位置）。玩家继续交换猜测和提示，直到猜测玩家将所有数字按正确顺序猜中。
- en: Here we have the computer attempt to guess a number provided by a human player.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们让计算机尝试猜测一个由人类玩家提供的数字。
- en: 'The strategy is fairly simple: the guessing player (in this case the Racklog
    program) keeps a record of each guess and the corresponding number of boles and
    creots. Candidate guesses are generated (by a brute-force generation of all possible
    permutations of the digits 0 through 9) where each candidate is tested against
    previous guesses to see if they yield a consistent number of boles and creots.
    If a candidate guess isn’t found to be inconsistent with previous guesses, it
    becomes the next guess presented to the user. To see what we mean, suppose play
    has progressed as shown in [Table 8-2](ch08.xhtml#ch8tab2) below.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 策略相当简单：猜测玩家（在此案例中是 Racklog 程序）记录每次猜测和相应的 boles 和 creots 数量。候选猜测由所有可能的数字 0 到
    9 的排列组合的暴力生成生成，每个候选猜测都与之前的猜测进行比对，看看是否能得出一致的 boles 和 creots 数量。如果一个候选猜测与之前的猜测没有不一致的地方，它就会成为下一个展示给用户的猜测。为了说明我们的意思，假设游戏已经按下面的[表
    8-2](ch08.xhtml#ch8tab2)进行。
- en: '**Table 8-2**: Boles and Creots in Progress'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-2**：Boles 和 Creots 进展情况'
- en: '| **Guess** | **Boles** | **Creots** |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| **猜测** | **Boles** | **Creots** |'
- en: '| --- | --- | --- |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 2359 | 0 | 2 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 2359 | 0 | 2 |'
- en: '| 1297 | 2 | 1 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 1297 | 2 | 1 |'
- en: For the next turn, the first candidate guess is 1973\. This guess, compared
    to the first guess in the table, has two correct digits (but in the wrong position),
    which gives 0 boles and 2 creots. So far, so good; but when compared with the
    second guess, we have 1 bole and 2 creots, so it’s rejected. Suppose our next
    candidate guess is 9247\. This gives 0 boles and 2 creots when compared to the
    first guess, and 2 boles and 1 creot when compared to the second guess, so it’s
    a good candidate guess. The program guesses 9247, gets a hint from the user, and
    updates the table with the guess, boles, and creots. The process repeats until
    someone wins.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一轮中，第一个候选猜测是 1973。与表中的第一个猜测相比，这个猜测有两个正确的数字（但位置错误），因此得到了 0 个 boles 和 2 个 creots。到此为止一切正常；但与第二个猜测相比，得到了
    1 个 bole 和 2 个 creots，因此被拒绝。假设下一个候选猜测是 9247。与第一个猜测相比，得到了 0 个 boles 和 2 个 creots；与第二个猜测相比，得到了
    2 个 boles 和 1 个 creot，因此它是一个不错的候选猜测。程序猜测 9247，得到用户的提示，并更新表格，记录猜测、boles 和 creots。这个过程会重复，直到有人获胜。
- en: To simulate a game between a guessing computer and hinting human, our Racklog
    program uses a read-evaluate-print loop (REPL) that prints a guess, waits for
    input (a hint) from the user, reads that input, and evaluates it to form its next
    guess.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟一个猜测计算机与提示人类之间的游戏，我们的Racklog程序使用一个读-评估-打印循环（REPL），该循环打印出一个猜测，等待用户输入（提示），读取输入，并评估该输入以形成下一个猜测。
- en: Let’s take a look at a sample session before we begin digging into the code.
    I’ve decided the number to be guessed is 12345\. My response to each guess is
    a two-digit number representing the number of boles and creots respectively.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始深入代码之前，先来看看一个示例会话。我已经决定了要猜的数字是12345。对于每次猜测，我的回应是一个两位数，分别表示boles和creots的数量。
- en: '[PRE69]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The code for the overall process is given below. It relies on a number of supporting
    processes that are explained in more detail later.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程的代码如下所示。它依赖于一些支持过程，稍后将更详细地解释。
- en: '[PRE70]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The constant `DIGITS` specifies the number of digits to be used for a guess.
    The `%repl` predicate implements the read-evaluate-print loop. The `%repl` code
    generates a randomized list of digits to be used to generate the guesses ➊, and
    the `history` list is cleared ➋. The actual loop starts ➌ where the permutations
    are generated. Each permutation is tested ➍, and backtracking occurs until an
    acceptable candidate guess is generated. Once that happens, the user is presented
    the guess ➎. The user is then prompted to provide the number of boles and creots,
    with the resulting input parsed ➏. The history list is then updated ➐. Finally,
    the input is tested on to see if all the digits are correct ➑, in which case a
    cut (`!`) is used to terminate the process. Otherwise a failure is generated,
    which triggers backtracking and additional guesses.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 常量`DIGITS`指定用于猜测的数字个数。`%repl`谓词实现了读-评估-打印循环。`%repl`代码生成一个随机化的数字列表，用于生成猜测➊，同时清空`history`列表➋。实际的循环从➌开始，此时生成排列。每个排列都会进行测试➍，直到生成一个可接受的候选猜测为止，回溯过程会继续进行。生成候选猜测后，用户将看到该猜测➎。接着，系统提示用户提供boles和creots的数量，结果输入将被解析➏。然后，`history`列表会被更新➐。最后，输入将被测试，看是否所有数字都正确➑，如果是，使用一个切割符号（`!`）来终止过程。否则，生成失败，触发回溯并进行额外的猜测。
- en: 'To keep track of prior guesses, a `history` list is defined. Each element of
    the list is a three-element list consisting of the following: a guess, the number
    of boles, and the number of creots. The history list is populated by the `%update-history`
    predicate.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪之前的猜测，定义了一个`history`列表。列表的每个元素是一个包含以下三个元素的三元组：猜测、boles的数量和creots的数量。`history`列表由`%update-history`谓词填充。
- en: '[PRE71]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: As seen above, a guess is represented by a list of digits. We define a `score`
    function that, given two lists of digits, compares them and returns the corresponding
    number of boles and creots in a pair.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，一个猜测由一组数字表示。我们定义了一个`score`函数，给定两个数字列表，比较它们并返回对应的boles和creots的数量。
- en: '[PRE72]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To prevent the program from always starting with the same initial guess, we
    define a number generator function to create a jumbled set of digits to choose
    from:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止程序每次都从相同的初始猜测开始，我们定义了一个数字生成器函数，用于创建一个混乱的数字集合以供选择：
- en: '[PRE73]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: To create guess candidates, we need to generate lists of permutations of our
    randomized digits. For this purpose, we reuse the `%permute-n` predicate we introduced
    in an earlier section.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建猜测候选项，我们需要生成随机数字的排列列表。为此，我们重用了在早期章节中介绍的`%permute-n`谓词。
- en: '[PRE74]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: A predicate called `%consistent?` takes a guess and tests whether it’s consistent
    (as defined above) with the elements of `history`. It’s called with a candidate
    guess.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为`%consistent?`的谓词接受一个猜测并测试它是否与`history`中的元素一致（如上所定义）。它通过候选猜测调用。
- en: '[PRE75]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Controlling input and output is the job of `get-input` and `%print`, as given
    below.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 控制输入和输出的工作由`get-input`和`%print`负责，具体如下所示。
- en: '[PRE76]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In the opening sections of this chapter, we introduced the logic programming
    paradigm and various tools and utilities that expand its capabilities. In this
    section, we looked at a number of puzzles and problems in recreational mathematics
    that can be solved via logic programming in a natural and declarative way. These
    problems illustrate the powerful search mechanism that’s an inherent feature of
    logic programming.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头部分，我们介绍了逻辑编程范式以及扩展其能力的各种工具和实用程序。在本节中，我们讨论了一些可以通过逻辑编程以自然和声明的方式解决的数学谜题和问题。这些问题展示了逻辑编程内在的强大搜索机制。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we’ve given an overview of the logic programming paradigm and
    looked at a number of interesting applications. We’ve seen that in addition to
    Racket’s functional and imperative programming capabilities, it’s also quite adept
    at logic programming given its Racklog library. Logic programming (specifically
    Prolog) is known to be Turing complete. What this means, in simple terms, is that
    anything that can be computed with a typical imperative programming language can
    be computed with a logic program. Technically it means that it can be used to
    simulate a Turing machine (more on this in a bit). That being said, there are
    problem domains where logic programming isn’t going to be optimal. Cases involving
    extensive numerical calculations or where a well-known imperative algorithm is
    already available speak against using logic programming. Logic programming particularly
    shines in search problems such as we saw in the application section and at symbolic
    calculations such as those involved in theorem proving. The good news with Racket
    is that you can choose whichever approach best suits the problem at hand.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，我们概述了逻辑编程范式，并考察了一些有趣的应用。我们已经看到，除了 Racket 的函数式和命令式编程能力之外，它在逻辑编程方面也相当擅长，得益于其
    Racklog 库。逻辑编程（特别是 Prolog）被认为是图灵完备的。简单来说，这意味着任何可以用典型的命令式编程语言计算的内容，也可以用逻辑程序计算。技术上来说，它可以用来模拟图灵机（稍后会详细讲解）。话虽如此，逻辑编程在某些问题领域并不总是最优的。例如，涉及大量数值计算的案例，或者已经有了公认的命令式算法的情况，都不适合使用逻辑编程。逻辑编程尤其在搜索问题上表现出色，就像我们在应用部分看到的那样，以及在定理证明等符号计算中。好消息是，使用
    Racket 时，你可以选择最适合当前问题的编程方法。
- en: In the next chapter, we’ll take a look at a number of abstract computing machines,
    such as the aforementioned Turing machine.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨一些抽象的计算机模型，例如前文提到的图灵机。
