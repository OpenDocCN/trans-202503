- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Injection
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 注入
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: This chapter guides you through the detection and exploitation of several prominent
    injection vulnerabilities. API requests that are vulnerable to injection allow
    you to send input that is then directly executed by the API’s supporting technologies
    (such as the web application, database, or operating system running on the server),
    bypassing input validation measures.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将引导你检测和利用几种常见的注入漏洞。易受注入攻击的 API 请求允许你发送输入，这些输入会被 API 支持的技术（例如运行在服务器上的 Web 应用、数据库或操作系统）直接执行，从而绕过输入验证措施。
- en: You’ll typically find injection attacks named after the technology they are
    targeting. Database injection techniques such as SQL injection take advantage
    of SQL databases, whereas NoSQL injection takes advantage of NoSQL databases.
    Cross-site scripting (XSS) attacks insert scripts into web pages that run on a
    user’s browser. Cross-API scripting (XAS) is similar to XSS but leverages third-party
    applications ingested by the API you’re attacking. Command injection is an attack
    against the web server operating system that allows you to send it operating system
    commands.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会发现按其目标技术命名的注入攻击。例如，SQL 注入利用 SQL 数据库，而 NoSQL 注入则利用 NoSQL 数据库。跨站脚本攻击（XSS）会将脚本插入到在用户浏览器上运行的网页中。跨
    API 脚本攻击（XAS）类似于 XSS，但它利用的是第三方应用程序，这些应用程序被你攻击的 API 吸收。命令注入是针对 Web 服务器操作系统的攻击，允许你向其发送操作系统命令。
- en: The techniques demonstrated throughout this chapter can be applied to other
    injection attacks as well. As one of the most severe findings you might come across,
    API injection can lead to a total compromise of a target’s most sensitive data
    or even grant you access to the supporting infrastructure.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中演示的技术也可以应用于其他注入攻击。作为你可能遇到的最严重的漏洞之一，API 注入可能导致目标最敏感数据的完全泄露，甚至可能让你获得对支持基础设施的访问权限。
- en: Discovering Injection Vulnerabilities
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现注入漏洞
- en: 'Before you can inject a payload using an API, you must discover places where
    the API accepts user input. One way to discover these injection points is by fuzzing
    and then analyzing the responses you receive. You should attempt injection attacks
    against all potential inputs and especially within the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 API 注入有效载荷之前，你必须先发现 API 接受用户输入的地方。发现这些注入点的一种方法是通过模糊测试，然后分析你收到的响应。你应该尝试对所有潜在的输入进行注入攻击，特别是在以下几种情况下：
- en: API keys
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 密钥
- en: Tokens
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令牌
- en: Headers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头信息
- en: Query strings in the URL
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL 中的查询字符串
- en: Parameters in POST/PUT requests
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POST/PUT 请求中的参数
- en: Your approach to fuzzing will depend on how much information you know about
    your target. If you’re not worried about making noise, you could send a variety
    of fuzzing inputs likely to cause an issue in many possible supporting technologies.
    Yet the more you know about the API, the better your attacks will be. If you know
    what database the application uses, what operating system is running on the web
    server, or the programming language in which the app was written, you’ll be able
    to submit targeted payloads aimed at detecting vulnerabilities in those particular
    technologies.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你进行模糊测试的方法将取决于你对目标了解多少。如果你不担心制造噪音，你可以发送各种可能会在许多支持技术中引发问题的模糊测试输入。但你对 API 了解得越多，你的攻击就会越有效。如果你知道应用程序使用的数据库是什么，Web
    服务器上运行的操作系统是什么，或者应用程序是用什么编程语言编写的，你就能提交有针对性的有效载荷，旨在检测这些特定技术中的漏洞。
- en: After sending your fuzzing requests, hunt for responses that contain a verbose
    error message or some other failure to properly handle the request. In particular,
    look for any indication that your payload bypassed security controls and was interpreted
    as a command, either at the operating system, programming, or database level.
    This response could be as obvious as a message such as “SQL Syntax Error” or something
    as subtle as taking a little more time to process a request. You could even get
    lucky and receive an entire verbose error dump that can provide you with plenty
    of details about the host.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 发送模糊测试请求后，寻找包含详细错误信息或其他未能正确处理请求的响应。特别是，注意任何表明你的有效载荷绕过了安全控制并被解释为命令的迹象，无论是在操作系统、编程语言还是数据库层面。这种响应可能是像“SQL语法错误”这样的明显信息，也可能是处理请求时稍微多花了一点时间。你甚至可能运气好，收到一整个详细的错误转储，其中可能包含有关主机的大量细节。
- en: When you do come across a vulnerability, make sure to test every similar endpoint
    for that vulnerability. Chances are, if you find a weakness in the */file/upload*
    endpoint, all endpoints with an upload feature, such as */image/upload* and */account/upload*,
    have the same problem.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你遇到漏洞时，一定要测试每个类似的端点，看看是否也有相同的漏洞。如果你在*/file/upload*端点发现了一个漏洞，那些具有上传功能的端点，例如*/image/upload*和*/account/upload*，很可能也有同样的问题。
- en: Lastly, it is important to note that several of these injection attacks have
    been around for decades. The only thing unique about API injection is that the
    API provides a newer delivery method for the attack. Since injection vulnerabilities
    are well known and often have a detrimental impact on application security, they
    are often well-protected against.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得注意的是，这些注入攻击中的许多已经存在了几十年。API注入的独特之处在于，它为这种攻击提供了一种更新的传播方式。由于注入漏洞是众所周知的，且通常会对应用安全产生不利影响，因此它们通常会得到良好的防护。
- en: Cross-Site Scripting (XSS)
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨站脚本（XSS）
- en: XSS is a classic web application vulnerability that has been around for decades.
    If you’re already familiar with the attack, you might be wondering, is XSS a relevant
    threat to API security? Of course it is, especially if the data submitted over
    the API interacts with the web application in the browser.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: XSS是一种经典的Web应用漏洞，已经存在了几十年。如果你已经熟悉这种攻击，你可能会想，XSS是否对API安全构成威胁？当然是，特别是当通过API提交的数据与浏览器中的Web应用交互时。
- en: In an XSS attack, the attacker inserts a malicious script into a website by
    submitting user input that gets interpreted as JavaScript or HTML by a user’s
    browser. Often, XSS attacks inject a pop-up message into a web page that instructs
    a user to click a link that redirects them to the attacker’s malicious content.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在XSS攻击中，攻击者通过提交用户输入，将恶意脚本插入网站，这些输入被用户浏览器解释为JavaScript或HTML。通常，XSS攻击会在网页中注入一个弹出消息，指示用户点击一个链接，该链接会将他们重定向到攻击者的恶意内容。
- en: In a web application, executing an XSS attack normally consists of injecting
    XSS payloads into different input fields on the site. When it comes to testing
    APIs for XSS, your goal is to find an endpoint that allows you to submit requests
    that interact with the frontend web application. If the application doesn’t sanitize
    the request’s input, the XSS payload might execute the next time a user visits
    the application’s page.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用中，执行XSS攻击通常包括将XSS负载注入到网站上的不同输入字段中。在测试API的XSS时，你的目标是找到一个允许你提交与前端Web应用交互的请求的端点。如果应用程序没有清理请求的输入，XSS负载可能会在下次用户访问应用页面时执行。
- en: That said, for this attack to succeed, the stars have to align. Because XSS
    has been around for quite some time, API defenders are quick to eliminate opportunities
    to easily take advantage of this weakness. In addition, XSS takes advantage of
    web browsers loading client-side scripts, so if an API does not interact with
    a web browser, the chances of exploiting this vulnerability are slim to none.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，为了让这次攻击成功，必须具备一些条件。由于XSS已经存在了相当长的时间，API防御者会迅速消除轻易利用这一弱点的机会。此外，XSS利用了Web浏览器加载客户端脚本的特性，所以如果API不与Web浏览器交互，利用此漏洞的可能性几乎为零。
- en: 'Here are a few examples of XSS payloads:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个XSS负载的示例：
- en: '`<script>alert("xss")</script>`'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<script>alert("xss")</script>`'
- en: '`<script>alert(1);</script>`'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<script>alert(1);</script>`'
- en: '`<%00script>alert(1)</%00script>`'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<%00script>alert(1)</%00script>`'
- en: '`SCRIPT>alert("XSS");///SCRIPT>`'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SCRIPT>alert("XSS");///SCRIPT>`'
- en: Each of these scripts attempts to launch an alert in a browser. The variations
    between the payloads are attempts to bypass user input validation. Typically,
    a web application will try to prevent XSS attacks by filtering out different characters
    or preventing characters from being sent in the first place. Sometimes, doing
    something simple such as adding a null byte (`%00`) or capitalizing different
    letters will bypass web app protections. We will go into more depth about evading
    security controls in Chapter 13.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些脚本中的每一个都试图在浏览器中发出警报。负载之间的变体尝试绕过用户输入验证。通常，Web应用会尝试通过过滤掉不同的字符或防止字符一开始就被发送来防止XSS攻击。有时，做一些简单的事情，比如添加一个空字节（`%00`）或将不同的字母大写，就能绕过Web应用的保护。在第13章中，我们会更深入地讨论如何绕过安全控制。
- en: 'For API-specific XSS payloads, I highly recommend the following resources:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定于API的XSS负载，我强烈推荐以下资源：
- en: '**Payload Box XSS payload list** This list contains over 2,700 XSS scripts
    that could trigger a successful XSS attack ([https://github.com/payloadbox/xss-payload-list](https://github.com/payloadbox/xss-payload-list)).'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Payload Box XSS 载荷列表** 该列表包含超过 2,700 个 XSS 脚本，可能触发成功的 XSS 攻击（[https://github.com/payloadbox/xss-payload-list](https://github.com/payloadbox/xss-payload-list)）。'
- en: '**Wfuzz wordlist** A shorter wordlist included with one of our primary tools.
    Useful for a quick check for XSS ([https://github.com/xmendez/wfuzz/tree/master/wordlist](https://github.com/xmendez/wfuzz/tree/master/wordlist)).'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Wfuzz 词典** 随我们的主要工具之一附带的较短词典。适用于快速检查 XSS（[https://github.com/xmendez/wfuzz/tree/master/wordlist](https://github.com/xmendez/wfuzz/tree/master/wordlist)）。'
- en: '**NetSec.expert XSS payloads** Contains explanations of different XSS payloads
    and their use cases. Useful to better understand each payload and conduct more
    precise attacks ([https://netsec.expert/posts/xss-in-2020](https://netsec.expert/posts/xss-in-2020)).'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**NetSec.expert XSS 载荷** 包含不同 XSS 载荷及其使用案例的解释。对于更好地理解每个载荷并进行更精确的攻击非常有用（[https://netsec.expert/posts/xss-in-2020](https://netsec.expert/posts/xss-in-2020)）。'
- en: If the API implements some form of security, many of your XSS attempts should
    produce similar results, like 405 Bad Input or 400 Bad Request. However, watch
    closely for the outliers. If you find requests that result in some form of successful
    response, try refreshing the relevant web page in your browser to see whether
    the XSS attempt affected it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 API 实施了某种形式的安全措施，那么您的大部分 XSS 尝试应该会产生类似的结果，例如 405 错误输入或 400 错误请求。然而，请密切关注异常情况。如果您发现某些请求返回了某种形式的成功响应，请尝试刷新相关的网页，看看
    XSS 尝试是否对其产生了影响。
- en: 'When reviewing the web apps for potential API XSS injection points, look for
    requests that include client input and are used to display information within
    the web app. A request used for any of the following is a prime candidate:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看 Web 应用程序是否存在潜在的 API XSS 注入点时，请寻找包含客户端输入并用于在 Web 应用中显示信息的请求。用于以下任何操作的请求都是潜在的目标：
- en: Updating user profile information
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新用户个人资料信息
- en: Updating social media “like” information
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新社交媒体“点赞”信息
- en: Updating ecommerce store products
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新电子商务商店产品
- en: Posting to forums or comment sections
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布到论坛或评论区
- en: Search the web application for requests and then fuzz them with an XSS payload.
    Review the results for anomalous or successful status codes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 应用程序中搜索请求，然后使用 XSS 载荷进行模糊测试。查看结果中是否有异常或成功的状态代码。
- en: Cross-API Scripting (XAS)
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨 API 脚本（XAS）
- en: XAS is cross-site scripting performed across APIs. For example, imagine that
    the hAPI Hacking blog has a sidebar powered by a LinkedIn newsfeed. The blog has
    an API connection to LinkedIn such that when a new post is added to the LinkedIn
    newsfeed, it appears in the blog sidebar as well. If the data received from LinkedIn
    isn’t sanitized, there is a chance that an XAS payload added to a LinkedIn newsfeed
    could be injected into the blog. To test this, you could post a LinkedIn newsfeed
    update containing an XAS script and check whether it successfully executes on
    the blog.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: XAS 是通过 API 执行的跨站脚本攻击。例如，假设 hAPI Hacking 博客有一个由 LinkedIn 新闻源提供支持的侧边栏。该博客与 LinkedIn
    之间有 API 连接，当 LinkedIn 新闻源添加新帖子时，新的内容也会显示在博客的侧边栏中。如果从 LinkedIn 接收到的数据没有经过清理，那么有可能将添加到
    LinkedIn 新闻源中的 XAS 载荷注入到博客中。要进行测试，您可以发布一个包含 XAS 脚本的 LinkedIn 新闻源更新，并检查它是否成功在博客中执行。
- en: XAS does have more complexities than XSS, because the web application must meet
    certain conditions in order for XAS to succeed. The web app must poorly sanitize
    the data submitted through its own API or a third-party one. The API input must
    also be injected into the web application in a way that would launch the script.
    Moreover, if you’re attempting to attack your target through a third-party API,
    you may be limited in the number of requests you can make through its platform.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: XAS 确实比 XSS 更复杂，因为 Web 应用必须满足某些条件才能使 XAS 成功。Web 应用必须未能正确清理通过其自身 API 或第三方 API
    提交的数据。API 输入还必须以某种方式注入到 Web 应用中，才能启动脚本。此外，如果您通过第三方 API 尝试攻击目标，可能会限制您可以通过该平台发出的请求数量。
- en: 'Besides these general challenges, you’ll encounter the same challenge inherent
    to XSS attacks: input validation. The API provider might attempt to prevent certain
    characters from being submitted through the API. Since XAS is just another form
    of XSS, you can borrow from the XSS payloads described in the preceding section.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些常见的挑战，您还会遇到 XSS 攻击固有的相同挑战：输入验证。API 提供者可能会尝试阻止某些字符通过 API 提交。由于 XAS 只是 XSS
    的另一种形式，您可以借用前面部分描述的 XSS 载荷。
- en: 'In addition to testing third-party APIs for XAS, you might look for the vulnerability
    in cases when a provider’s API adds content or makes changes to its web application.
    For example, let’s say the hAPI Hacking blog allows users to update their user
    profiles through either a browser or a POST request to the API endpoint */api/profile/update*.
    The hAPI Hacking blog security team may have spent all their time protecting the
    blog from input provided using the web application, completely overlooking the
    API as a threat vector. In this situation, you might try sending a typical profile
    update request containing your payload in one field of POST request:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对第三方 API 进行 XAS 测试外，您可能还需要在提供商的 API 添加内容或对其 web 应用程序进行更改时，查找该漏洞。例如，假设 hAPI
    Hacking 博客允许用户通过浏览器或向 API 端点 */api/profile/update* 发送 POST 请求来更新其用户资料。hAPI Hacking
    博客的安全团队可能将所有精力都集中在保护博客免受 web 应用程序提供的输入攻击，完全忽略了 API 作为攻击渠道的可能性。在这种情况下，您可能会尝试发送一个典型的用户资料更新请求，其中包含您在
    POST 请求中的有效负载：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If the request succeeds, load the web page in a browser to see whether the script
    executes. If the API implements input validation, the server might issue an HTTP
    400 Bad Request response, preventing you from sending scripts as payloads. In
    that case, try using Burp Suite or Wfuzz to send a large list of XAS/XSS scripts
    in an attempt to locate some that don’t result in a 400 response.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求成功，尝试在浏览器中加载网页，看脚本是否执行。如果 API 实施了输入验证，服务器可能会发出 HTTP 400 错误请求响应，阻止您发送脚本作为有效负载。在这种情况下，您可以尝试使用
    Burp Suite 或 Wfuzz 发送一大批 XAS/XSS 脚本，尝试找到不会导致 400 响应的脚本。
- en: 'Another useful XAS tip is to try altering the `Content-Type` header to induce
    the API into accepting an HTML payload to spawn the script:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的 XAS 提示是尝试更改 `Content-Type` 头部，诱使 API 接受 HTML 有效负载来启动脚本：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: XAS requires a specific situation to be in place in order to be exploitable.
    That said, API defenders often do a better job at preventing attacks that have
    been around for over two decades, such as XSS and SQL injection, than newer and
    more complex attacks like XAS.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: XAS 需要特定的条件才能被利用。也就是说，API 防御者往往在防止已有二十多年历史的攻击（如 XSS 和 SQL 注入）方面做得比防止像 XAS 这样的新型复杂攻击更好。
- en: SQL Injection
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 注入
- en: One of the most well-known web application vulnerabilities, SQL injection, allows
    a remote attacker to interact with the application’s backend SQL database. With
    this access, an attacker could obtain or delete sensitive data such as credit
    card numbers, usernames, passwords, and other gems. In addition, an attacker could
    leverage SQL database functionality to bypass authentication and even gain system
    access.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 注入是最著名的 web 应用漏洞之一，它允许远程攻击者与应用程序的后端 SQL 数据库进行交互。通过这种访问，攻击者可能会获取或删除敏感数据，如信用卡号、用户名、密码以及其他重要信息。此外，攻击者还可以利用
    SQL 数据库功能绕过身份验证，甚至获得系统访问权限。
- en: This vulnerability has been around for decades, and it seemed to be diminishing
    before APIs presented a new way to perform injection attacks. Still, API defenders
    have been keen to detect and prevent SQL injections over APIs. Therefore, these
    attacks are not likely to succeed. In fact, sending requests that include SQL
    payloads could arouse the attention of your target’s security team or cause your
    authorization token to be banned.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞已经存在了几十年，并且在 APIs 出现之前似乎有所减少，因为 APIs 提供了一种新的注入攻击方式。然而，API 防御者一直非常关注检测和防止通过
    API 进行的 SQL 注入攻击。因此，这些攻击不太可能成功。事实上，发送包含 SQL 有效负载的请求可能会引起目标安全团队的注意，甚至导致您的授权令牌被禁用。
- en: Luckily, you can often detect the presence of a SQL database in less obvious
    ways. When sending a request, try requesting the unexpected. For example, take
    a look at the Swagger documentation shown in [Figure 12-1](#figure12-1) for a
    Pixi endpoint.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，您通常可以通过一些不太显眼的方式检测 SQL 数据库的存在。在发送请求时，尝试请求一些意想不到的内容。例如，查看[图 12-1](#figure12-1)中展示的
    Pixi 端点的 Swagger 文档。
- en: '![screenshot of swagger documentation that contains the following values in
    the body: id, user, pass, name, is_admin , and account_balance](image_fi/502444c12/F12001.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![包含以下值的 Swagger 文档截图：id、user、pass、name、is_admin 和 account_balance](image_fi/502444c12/F12001.png)'
- en: 'Figure 12-1: Pixi API Swagger documentation'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-1：Pixi API Swagger 文档
- en: As you can see, Pixi is expecting the consumer to provide certain values in
    the body of a request. The `"id"` value should be a number, `"name"` expects a
    string, and `"is_admin"` expects a Boolean value such as true or false. Try providing
    a string where a number is expected, a number where a string is expected, and
    a number or string where a Boolean value is expected. If an API is expecting a
    small number, send a large number, and if it expects a small string, send a large
    one. By requesting the unexpected, you’re likely to discover a situation the developers
    didn’t predict, and the database might return an error in the response. These
    errors are often verbose, revealing sensitive information about the database.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，Pixi 期望消费者在请求的主体中提供某些值。`"id"` 值应该是一个数字，`"name"` 期望一个字符串，`"is_admin"` 期望一个布尔值，比如
    true 或 false。尝试在预期数字的地方提供字符串，在预期字符串的地方提供数字，并在预期布尔值的地方提供数字或字符串。如果 API 预期一个小数字，请发送一个大数字，如果它预期一个小字符串，请发送一个大字符串。通过请求意外情况，你很可能会发现开发人员没有预测到的情况，数据库可能会在响应中返回错误。这些错误通常是冗长的，会泄露有关数据库的敏感信息。
- en: When looking for requests to target for database injections, seek out those
    that allow client input and can be expected to interact with a database. In [Figure
    12-1](#figure12-1), there is a good chance that the collected user information
    will be stored in a database and that the PUT request allows us to update it.
    Since there is a probable database interaction, the request is a good candidate
    to target in a database injection attack. In addition to making obvious requests
    like this, you should fuzz everything, everywhere, because you might find indications
    of a database injection weakness in less obvious requests.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找用于数据库注入的目标请求时，要寻找那些允许客户端输入并且预计会与数据库交互的请求。在 [图 12-1](#figure12-1) 中，收集的用户信息很可能会存储在数据库中，并且
    PUT 请求允许我们对其进行更新。由于可能存在数据库交互，因此该请求是目标进行数据库注入攻击的一个很好的候选项。除了进行明显的请求外，还应该对所有地方进行模糊测试，因为你可能会在不太明显的请求中找到数据库注入弱点的迹象。
- en: 'This section will cover two easy ways to test whether an application is vulnerable
    to SQL injection: manually submitting metacharacters as input to the API and using
    an automated solution called SQLmap.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍两种简单的方法来测试应用程序是否容易受到 SQL 注入攻击：手动将元字符提交为 API 的输入，以及使用一个名为 SQLmap 的自动化解决方案。
- en: Manually Submitting Metacharacters
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动提交元字符
- en: '*Metacharacters* are characters that SQL treats as functions rather than as
    data. For example, `--` is a metacharacter that tells the SQL interpreter to ignore
    the following input because it is a comment. If an API endpoint does not filter
    SQL syntax from API requests, any SQL queries passed to the database from the
    API will execute.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*元字符* 是 SQL 中被视为函数而不是数据的字符。例如，`--` 是一个元字符，告诉 SQL 解释器忽略接下来的输入，因为它是一个注释。如果 API
    端点没有过滤 API 请求中的 SQL 语法，那么通过 API 传递到数据库的任何 SQL 查询都将被执行。'
- en: 'Here are some SQL metacharacters that can cause some issues:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可以引起问题的 SQL 元字符：
- en: '`''`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`''`'
- en: '`''''`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`''''`'
- en: '`;%00`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`;%00`'
- en: '`--`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`--`'
- en: '`-- -`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`-- -`'
- en: '`""`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`""`'
- en: '`;`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`;`'
- en: '`'' OR ''1`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`'' OR ''1`'
- en: '`'' OR 1 -- -`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`'' OR 1 -- -`'
- en: '`" OR "" = "`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`" OR "" = "`'
- en: '`" OR 1 = 1 -- -`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`" OR 1 = 1 -- -`'
- en: '`'' OR '''' = ''`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`'' OR '''' = ''`'
- en: '`OR 1=1`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`OR 1=1`'
- en: 'All of these symbols and queries are meant to cause problems for SQL queries.
    A null byte like `;%00` could cause a verbose SQL-related error to be sent as
    a response. The `OR 1=1` is a conditional statement that literally means “or the
    following statement is true,” and it results in a true condition for the given
    SQL query. Single and double quotes are used in SQL to indicate the beginning
    and ending of a string, so quotes could cause an error or a unique state. Imagine
    that the backend is programmed to handle the API authentication process with a
    SQL query like the following, which is a SQL authentication query that checks
    for username and password:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些符号和查询都旨在引起 SQL 查询的问题。像 `;%00` 这样的空字节可能会导致一个冗长的与 SQL 相关的错误作为响应发送。`OR 1=1`
    是一个条件语句，字面上意味着“或者以下语句为真”，这将导致给定 SQL 查询的条件为真。单引号和双引号在 SQL 中用于指示字符串的开始和结束，因此引号可能会导致错误或独特的状态。想象一下，后端程序编程时，处理
    API 身份验证过程的 SQL 查询可能会像下面这样，这是一个检查用户名和密码的 SQL 身份验证查询：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The query retrieves the values `hAPI_hacker` and `Password1!` from the user
    input. If, instead of a password, we supplied the API with the value `'' OR 1=1--
    -`, the SQL query might instead look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 查询从用户输入中检索值 `hAPI_hacker` 和 `Password1!`。如果我们向 API 提供的不是密码，而是值 `' OR 1=1-- -`，那么
    SQL 查询可能会变成这样：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This would be interpreted as selecting the user with a true statement and skipping
    the password requirement, as it has been commented out. The query no longer checks
    for a password at all, and the user is granted access. The attack can be performed
    to both the username and password fields. In a SQL query, the dashes (`--`) represent
    the beginning of a single-line comment. This turns everything within the following
    query line into a comment that will not be processed. Single and double quotes
    can be used to escape the current query to cause an error or to append your own
    SQL query.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被解释为选择一个为真语句的用户，并跳过密码要求，因为密码部分已被注释掉。查询不再检查密码，用户被授予访问权限。该攻击可以对用户名和密码字段同时执行。在
    SQL 查询中，破折号（`--`）代表单行注释的开始。这将使后续查询行中的所有内容变成注释，不会被处理。单引号和双引号可以用来逃避当前查询，导致错误，或追加你自己的
    SQL 查询。
- en: The preceding list has been around in many forms for years, and the API defenders
    are also aware of its existence. Therefore, make sure you attempt various forms
    of requesting the unexpected.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表已经以多种形式存在多年，API 防御者也意识到它的存在。因此，确保你尝试各种方式请求意外的结果。
- en: SQLmap
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLmap
- en: One of my favorite ways to automatically test an API for SQL injection is to
    save a potentially vulnerable request in Burp Suite and then use SQLmap against
    it. You can discover potential SQL weaknesses by fuzzing all potential inputs
    in a request and then reviewing the responses for anomalies. In the case of a
    SQL vulnerability, this anomaly is normally a verbose SQL response like “The SQL
    database is unable to handle your request . . .”
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的一种自动测试 API 是否存在 SQL 注入的方法是，将一个可能存在漏洞的请求保存在 Burp Suite 中，然后使用 SQLmap 对其进行攻击。你可以通过对请求中的所有潜在输入进行模糊测试，然后检查响应中的异常来发现潜在的
    SQL 弱点。在 SQL 漏洞的情况下，这种异常通常是类似于“SQL 数据库无法处理你的请求……”的详细 SQL 响应。
- en: 'Once you’ve saved the request, launch SQLmap, one of the standard Kali packages
    that can be run over the command line. Your SQLmap command might look like the
    following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 保存请求后，启动 SQLmap，这是 Kali 的标准包之一，可以通过命令行运行。你的 SQLmap 命令可能如下所示：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `-r` option lets you specify the path to the saved request. The `-p` option
    lets you specify the exact parameters you’d like to test for SQL injection. If
    you do not specify a parameter to attack, SQLmap will attack every parameter,
    one after another. This is great for performing a thorough attack of a simple
    request, but a request with many parameters can be fairly time-consuming. SQLmap
    tests one parameter at a time and tells you when a parameter is unlikely to be
    vulnerable. To skip a parameter, use the ctrl-C keyboard shortcut to pull up SQLmap’s
    scan options and use the `n` command to move to the next parameter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`-r` 选项让你指定已保存请求的路径。`-p` 选项让你指定希望测试 SQL 注入的具体参数。如果没有指定要攻击的参数，SQLmap 会依次攻击每一个参数。这对于对一个简单请求进行彻底攻击非常有效，但对于一个包含多个参数的请求，可能会相当耗时。SQLmap
    会一次测试一个参数，并告诉你哪个参数不太可能存在漏洞。要跳过某个参数，可以使用 ctrl-C 键组合打开 SQLmap 的扫描选项，并使用 `n` 命令跳到下一个参数。'
- en: 'When SQLmap indicates that a certain parameter may be injectable, attempt to
    exploit it. There are two major next steps, and you can choose which to pursue
    first: dumping every database entry or attempting to gain access to the system.
    To dump all database entries, use the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当 SQLmap 表明某个参数可能存在注入漏洞时，尝试利用它。有两个主要的后续步骤，你可以选择先进行哪一个：导出所有数据库条目或尝试获取系统访问权限。要导出所有数据库条目，可以使用以下命令：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you’re not interested in dumping the entire database, you could use the
    `--dump` command to specify the exact table and columns you would like:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想导出整个数据库，你可以使用 `--dump` 命令来指定你希望获取的具体表格和列：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This example attempts to dump the `password` column of the `users` table within
    the `helpdesk` database. When this command executes successfully, SQLmap will
    display database information on the command line and export the information to
    a CSV file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例尝试从 `helpdesk` 数据库中的 `users` 表导出 `password` 列。当命令成功执行时，SQLmap 会在命令行上显示数据库信息，并将信息导出到
    CSV 文件。
- en: 'Sometimes SQL injection vulnerabilities will allow you to upload a web shell
    to the server that can then be executed to obtain system access. You could use
    one of SQLmap’s commands to automatically attempt to upload a web shell and execute
    the shell to grant you with system access:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有时 SQL 注入漏洞会允许你向服务器上传一个 Web Shell，然后执行该 Shell 以获取系统访问权限。你可以使用 SQLmap 的命令之一来自动尝试上传
    Web Shell 并执行它，从而为你提供系统访问权限：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This command will attempt to leverage the SQL command access within the vulnerable
    parameter to upload and launch a shell. If successful, this will give you access
    to an interactive shell with the operating system.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将尝试利用漏洞参数中的SQL命令访问，上传并启动一个shell。如果成功，这将使你能够访问操作系统的交互式shell。
- en: 'Alternatively, you could use the `os-pwn` option to attempt to gain a shell
    using Meterpreter or VNC:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用`os-pwn`选项尝试通过Meterpreter或VNC获得shell：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Successful API SQL injections may be few and far between, but if you do find
    a weakness, the impact can lead to a severe compromise of the database and affected
    servers. For additional information on SQLmap, check out its documentation at
    [https://github.com/sqlmapproject/sqlmap#readme](https://github.com/sqlmapproject/sqlmap#readme).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的API SQL注入可能少之又少，但如果你确实找到漏洞，影响可能会导致数据库和受影响服务器的严重泄露。关于SQLmap的更多信息，请查看其文档：[https://github.com/sqlmapproject/sqlmap#readme](https://github.com/sqlmapproject/sqlmap#readme)。
- en: NoSQL Injection
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NoSQL注入
- en: APIs commonly use NoSQL databases due to how well they scale with the architecture
    designs common among APIs, as discussed in Chapter 1. It may even be more common
    for you to discover NoSQL databases than SQL databases. Also, NoSQL injection
    techniques aren’t as well known as their structured counterparts. Due to this
    one small fact, you might be more likely to find NoSQL injections.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: API常常使用NoSQL数据库，因为它们与API中常见的架构设计兼容，如第一章所述。你可能会发现NoSQL数据库比SQL数据库更为普遍。而且，NoSQL注入技术不像结构化的SQL注入那样广为人知。正因为这一小点，你更可能发现NoSQL注入。
- en: As you hunt, remember that NoSQL databases do not share as many commonalities
    as the different SQL databases do. *NoSQL* is an umbrella term that means the
    database does not use SQL. Therefore, these databases have unique structures,
    modes of querying, vulnerabilities, and exploits. Practically speaking, you’ll
    conduct many similar attacks and target similar requests, but your actual payloads
    will vary.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在你进行渗透测试时，请记住，NoSQL数据库不像不同的SQL数据库那样具有许多共同点。*NoSQL*是一个总括性术语，意味着数据库不使用SQL。因此，这些数据库具有独特的结构、查询模式、漏洞和利用方式。实际上，你会进行许多类似的攻击并针对相似的请求，但实际的有效负载会有所不同。
- en: 'The following are common NoSQL metacharacters you could send in an API call
    to manipulate the database:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你可以在API调用中发送的常见NoSQL元字符，用于操作数据库：
- en: '`$gt`'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$gt`'
- en: '`{"$gt":""}`'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{"$gt":""}`'
- en: '`{"$gt":-1}`'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{"$gt":-1}`'
- en: '`$ne`'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$ne`'
- en: '`{"$ne":""}`'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{"$ne":""}`'
- en: '`{"$ne":-1}`'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{"$ne":-1}`'
- en: '`$nin`'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$nin`'
- en: '`{"$nin":1}`'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{"$nin":1}`'
- en: '`{"$nin":[1]}`'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{"$nin":[1]}`'
- en: '`|| ''1''==''1`'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`|| ''1''==''1`'
- en: '`//`'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`//`'
- en: '`||''a''\\''a`'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`||''a''\\''a`'
- en: '`''||''1''==''1'';//`'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''||''1''==''1'';//`'
- en: '`''/{}:`'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''/{}:`'
- en: '`''"\;{}`'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''"\;{}`'
- en: '`''"\/$[].>`'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''"\/$[].>`'
- en: '`{"$where": "sleep(1000)"}`'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{"$where": "sleep(1000)"}`'
- en: 'A note on a few of these NoSQL metacharacters: as we touched on in Chapter
    1, `$gt` is a MongoDB NoSQL query operator that selects documents that are greater
    than the provided value. The `$ne` query operator selects documents where the
    value is not equal to the provided value. The `$nin` operator is the “not in”
    operator, used to select documents where the field value is not within the specified
    array. Many of the others in the list contain symbols that are meant to cause
    verbose errors or other interesting behavior, such as bypassing authentication
    or waiting 10 seconds.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些NoSQL元字符的说明：正如我们在第一章中提到的，`$gt`是MongoDB NoSQL查询操作符，用于选择大于给定值的文档。`$ne`查询操作符选择值不等于给定值的文档。`$nin`操作符是“not
    in”操作符，用于选择字段值不在指定数组中的文档。列表中的许多其他符号旨在导致详细的错误信息或其他有趣的行为，比如绕过认证或等待10秒。
- en: 'Anything out of the ordinary should encourage you to thoroughly test the database.
    When you send an API authentication request, one possible response for an incorrect
    password is something like the following, which comes from the Pixi API collection:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 任何异常的情况都应该促使你彻底测试数据库。当你发送API身份验证请求时，错误密码的一个可能响应如下所示，来自Pixi API集合：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that a failed response includes a status code of 202 Accepted and includes
    a failed login message. Fuzzing the */api/login* endpoint with certain symbols
    results in verbose error messaging. For example, the payload `'"\;{}` sent as
    the password parameter might cause the following 400 Bad Request message.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，失败的响应包括状态码202 Accepted，并带有失败的登录信息。使用特定符号模糊测试*/api/login*端点会导致详细的错误消息。例如，将有效负载`'"\;{}`作为密码参数发送，可能会导致以下400
    Bad Request消息。
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Unfortunately, the error messaging does not indicate anything about the database
    in use. However, this unique response does indicate that this request has an issue
    with handling certain types of user input, which could be an indication that it
    is potentially vulnerable to an injection attack. This is exactly the sort of
    response that should incite you to focus your testing. Since we have our list
    of NoSQL payloads, we can set the attack position to the password with our NoSQL
    strings:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，错误信息并未指示所使用的数据库类型。然而，这个独特的响应确实表明，该请求在处理某些类型的用户输入时存在问题，这可能表明它可能容易受到注入攻击。这正是应该引起你注意并集中测试的响应。既然我们已经有了
    NoSQL 负载列表，我们可以将攻击位置设置为密码，并使用我们的 NoSQL 字符串：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since we already have this request saved in our Pixi collection, let’s attempt
    our injection attack with Postman. Sending various requests with the NoSQL fuzzing
    payloads results in 202 Accepted responses, as seen with other bad password attempts
    in [Figure 12-2](#figure12-2).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在 Pixi 集合中保存了这个请求，让我们尝试使用 Postman 进行注入攻击。发送带有 NoSQL 模糊负载的各种请求会得到 202 Accepted
    响应，正如在[图 12-2](#figure12-2)中看到的其他错误密码尝试。
- en: As you can see, the payloads with nested NoSQL commands `{"$gt":""}` and `{"$ne":""}`
    result in successful injection and authentication bypass.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，嵌套的 NoSQL 命令负载 `{"$gt":""}` 和 `{"$ne":""}` 导致了成功的注入和认证绕过。
- en: '![screenshot of postman that shows successful attempts when using nested nosql
    commands](image_fi/502444c12/F12002.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 截图，显示使用嵌套 NoSQL 命令时成功的尝试](image_fi/502444c12/F12002.png)'
- en: 'Figure 12-2: Successful NoSQL injection attack using Postman'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-2：使用 Postman 成功进行 NoSQL 注入攻击
- en: Operating System Command Injection
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统命令注入
- en: Operating system command injection is similar to the other injection attacks
    we’ve covered in this chapter, but instead of, say, database queries, you’ll inject
    a command separator and operating system commands. When you’re performing operating
    system injection, it helps a great deal to know which operating system is running
    on the target server. Make sure you get the most out of your Nmap scans during
    reconnaissance in an attempt to glean this information.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统命令注入类似于本章中我们讨论的其他注入攻击，但不同之处在于，你注入的不是数据库查询，而是命令分隔符和操作系统命令。在进行操作系统注入时，了解目标服务器上运行的操作系统非常有帮助。确保在侦察期间充分利用你的
    Nmap 扫描，以尝试获取这些信息。
- en: As with all other injection attacks, you’ll begin by finding a potential injection
    point. Operating system command injection typically requires being able to leverage
    system commands that the application has access to or escaping the application
    altogether. Some key places to target include URL query strings, request parameters,
    and headers, as well as any request that has thrown unique or verbose errors (especially
    those containing any operating system information) during fuzzing attempts.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他注入攻击一样，你的第一步是找到潜在的注入点。操作系统命令注入通常需要能够利用应用程序访问的系统命令，或完全逃逸出应用程序。一些关键的攻击目标包括
    URL 查询字符串、请求参数和头部，以及在模糊测试中抛出过独特或冗长错误（特别是那些包含操作系统信息的错误）的请求。
- en: 'Characters such as the following all act as *command separators*, which enable
    a program to pair multiple commands together on a single line. If a web application
    is vulnerable, it would allow an attacker to add command separators to an existing
    command and then follow it with additional operating system commands:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下字符都充当 *命令分隔符*，它们允许程序在一行中将多个命令配对。如果 Web 应用程序存在漏洞，它将允许攻击者将命令分隔符添加到现有命令中，并在其后跟随其他操作系统命令：
- en: '`|`'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`|`'
- en: '`||`'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`||`'
- en: '`&`'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`&`'
- en: '`&&`'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`&&`'
- en: '`''`'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''`'
- en: '`"`'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`"`'
- en: '`;`'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`;`'
- en: '`''"`'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''"`'
- en: 'If you don’t know a target’s underlying operating system, put your API fuzzing
    skills to work by using two payload positions: one for the command separator followed
    by a second for the operating system command. [Table 12-1](#table12-1) is a small
    list of potential operating system commands to use.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道目标的底层操作系统，可以通过使用两个负载位置来发挥你的 API 模糊技能：一个用于命令分隔符，另一个用于操作系统命令。[表 12-1](#table12-1)是一些潜在的操作系统命令。
- en: 'Table 12-1: Common Operating System Commands to Use in Injection Attacks'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-1：注入攻击中常用的操作系统命令
- en: '| **Operating system** | **Command** | **Description** |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| **操作系统** | **命令** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Windows | `ipconfig` | Shows the network configuration |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| Windows | `ipconfig` | 显示网络配置 |'
- en: '|  | `dir` | Prints the contents of a directory |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|  | `dir` | 打印目录内容 |'
- en: '|  | `ver` | Prints the operating system and version |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|  | `ver` | 打印操作系统和版本 |'
- en: '|  | `echo``%CD%` | Prints the current working directory |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|  | `echo``%CD%` | 打印当前工作目录 |'
- en: '|  | `whoami` | Prints the current user |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|  | `whoami` | 打印当前用户 |'
- en: '| *nix (Linux and Unix) | `ifconfig` | Shows the network configuration |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| *nix（Linux和Unix）| `ifconfig` | 显示网络配置 |'
- en: '|  | `ls` | Prints the contents of a directory |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  | `ls` | 打印目录的内容 |'
- en: '|  | `uname``-a` | Prints the operating system and version |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|  | `uname``-a` | 打印操作系统和版本 |'
- en: '|  | `pwd` | Prints the current working directory |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|  | `pwd` | 打印当前工作目录 |'
- en: '|  | `whoami` | Prints the current user |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|  | `whoami` | 打印当前用户 |'
- en: 'To perform this attack with Wfuzz, you can either manually provide a list of
    commands or supply them as a wordlist. In the following example, I have saved
    all my command separators in the file *commandsep.txt* and operating system commands
    as *os-cmds.txt*:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Wfuzz执行此攻击，你可以手动提供命令列表，或将其作为字典文件提供。在下面的示例中，我将所有的命令分隔符保存在文件*commandsep.txt*中，操作系统命令保存在*os-cmds.txt*中：
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To perform this same attack in Burp Suite, you could leverage an Intruder cluster
    bomb attack.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Burp Suite中执行同样的攻击，你可以利用Intruder集群炸弹攻击。
- en: We set the request to be a login POST request and target the `user` parameter.
    Two payload positions have been set to each of our files. Review the results for
    anomalies, such as responses in the 200s and response lengths that stick out.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将请求设置为登录的POST请求，并针对`user`参数。已为每个文件设置了两个有效载荷位置。查看结果，检查异常情况，比如返回200系列响应和突出显示的响应长度。
- en: 'What you decide to do with your operating system command injection is up to
    you. You could retrieve SSH keys, the */etc/shadow* password file on Linux, and
    so on. Alternatively, you could escalate or command-inject to a full-blown remote
    shell. Either way, that is where your API hacking transitions into regular old
    hacking, and there are plenty of other books on that topic. For additional information,
    check out the following resources:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你决定如何使用操作系统命令注入完全取决于你。你可以获取SSH密钥、Linux上的*/etc/shadow*密码文件等等。或者，你也可以进行权限提升或命令注入，获得一个完整的远程Shell。无论如何，这就是你的API黑客技巧转变为普通黑客技巧的时刻，而且这个话题还有很多其他书籍可以参考。欲了解更多信息，请查看以下资源：
- en: '*RTFM:* *Red Team Field Manual* (2013) by Ben Clark'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*阅读手册：* *红队作战手册*（2013）作者：本·克拉克'
- en: '*Penetration Testing: A Hands-On Introduction to Hacking* (No Starch Press,
    2014) by Georgia Weidman'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*渗透测试：黑客实战入门*（No Starch Press，2014）作者：乔治亚·威德曼'
- en: '*Ethical Hacking: A Hands-On Introduction to Breaking In* (No Starch Press,
    2021) by Daniel Graham'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*伦理黑客：实战入门*（No Starch Press，2021）作者：丹尼尔·格雷厄姆'
- en: '*Advanced Penetration Testing: Hacking the World’s Most Secure Networks* (Wiley,
    2017) by Wil Allsop'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高级渗透测试：破解世界上最安全的网络*（Wiley，2017）作者：威尔·奥尔索普'
- en: '*Hands-On Hacking* (Wiley, 2020) by Jennifer Arcuri and Matthew Hickey'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动手黑客*（Wiley，2020）作者：詹妮弗·阿库里和马修·希基'
- en: '*The Hacker Playbook 3: Practical Guide to Penetration Testing* (Secure Planet,
    2018) by Peter Kim'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*黑客剧本3：渗透测试实用指南*（Secure Planet，2018）作者：彼得·金'
- en: '*The Shellcoder’s Handbook: Discovering and Exploiting Security Holes* (Wiley,
    2007) by Chris Anley, Felix Lindner, John Heasman, and Gerardo Richarte'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Shellcoder手册：发现和利用安全漏洞*（Wiley，2007）作者：克里斯·安利、费利克斯·林德纳、约翰·赫斯曼和赫拉尔多·里查特'
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we used fuzzing to detect several types of API injection vulnerabilities.
    Then we reviewed the myriad ways these vulnerabilities can be exploited. In the
    next chapter, you’ll learn how to evade common API security controls.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用模糊测试来检测几种类型的API注入漏洞。然后，我们回顾了这些漏洞可能被利用的各种方式。在下一章，你将学习如何规避常见的API安全控制。
- en: 'Lab #9: Faking Coupons Using NoSQL Injection'
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验#9：使用NoSQL注入伪造优惠券
- en: It’s time to approach the crAPI with our new injection powers. But where to
    start? Well, one feature we haven’t tested yet that accepts client input is the
    coupon code feature. Now don’t roll your eyes—coupon scamming can be lucrative!
    Search for Robin Ramirez, Amiko Fountain, and Marilyn Johnson and you’ll learn
    how they made $25 million. The crAPI might just be the next victim of a massive
    coupon heist.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候利用我们的新注入技巧来攻击crAPI了。但从哪里开始呢？好吧，我们还没有测试的一个功能是接受客户端输入的优惠券代码功能。别翻白眼——优惠券欺诈可是赚钱的！搜索Robin
    Ramirez、Amiko Fountain和Marilyn Johnson，你就能知道他们是如何赚到2500万美元的。crAPI可能正是下一个遭遇大规模优惠券诈骗的受害者。
- en: Using the web application as an authenticated user, let’s use the **Add Coupon**
    button found within the Shop tab. Enter some test data in the coupon code field
    and then intercept the corresponding request with Burp Suite (see [Figure 12-3](#figure12-3)).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用经过身份验证的用户访问 Web 应用程序，我们可以在“商店”标签页中使用**添加优惠券**按钮。请输入一些测试数据到优惠券代码字段中，然后用 Burp
    Suite 拦截相应的请求（见[图 12-3](#figure12-3)）。
- en: '![screenshot of crapi’s enter coupon code pop-up window, in which “test!” has
    been typed into the coupon code box and has given the error message “invalid coupon
    code”](image_fi/502444c12/F12003.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![crapi 输入优惠券代码弹窗截图，其中输入了“test!”并显示错误信息“无效的优惠券代码”](image_fi/502444c12/F12003.png)'
- en: 'Figure 12-3: The crAPI coupon code validation feature'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-3：crAPI 优惠券代码验证功能
- en: 'In the web application, using this coupon code validation feature with an incorrect
    coupon code results in an “invalid coupon code” response. The intercepted request
    should look like the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 应用程序中，使用错误的优惠券代码进行优惠券代码验证会返回“无效的优惠券代码”响应。被拦截的请求应如下所示：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice the `"coupon_code"` value in the POST request body. This seems like a
    good field to test if we’re hoping to forge coupons. Let’s send the request over
    to Intruder and add our payload positions around `TEST!` so we can fuzz this coupon
    value. Once we’ve set our payload positions, we can add our injection fuzzing
    payloads. Try including all the SQL and NoSQL payloads covered in this chapter.
    Next, begin the Intruder fuzzing attack.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 POST 请求体中的 `"coupon_code"` 值。若我们希望伪造优惠券，这似乎是一个很好的测试字段。让我们将请求发送到 Intruder，并在
    `TEST!` 周围添加负载位置，以便对该优惠券值进行模糊测试。一旦设置了负载位置，我们就可以添加我们的注入模糊负载。尝试包括本章中涵盖的所有 SQL 和
    NoSQL 负载。接下来，开始 Intruder 模糊测试攻击。
- en: The results of this initial scan all show the same status code (500) and response
    length (385), as you can see in [Figure 12-4](#figure12-4).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这次初步扫描的结果都显示相同的状态码（500）和响应长度（385），如[图 12-4](#figure12-4)所示。
- en: '![fuzzing results show various requests, all with a length of 385 and a status
    code of 500](image_fi/502444c12/F12004.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![模糊测试结果显示各种请求，长度均为 385，状态码为 500](image_fi/502444c12/F12004.png)'
- en: 'Figure 12-4: Intruder fuzzing results'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-4：Intruder 模糊测试结果
- en: Nothing appears anomalous here. Still, we should investigate what the requests
    and responses look like. See Listings 12-1 and 12-2.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里看起来没有异常。不过，我们应该调查请求和响应的具体情况。请参见列表 12-1 和 12-2。
- en: '[PRE14]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 12-1: The coupon validation request'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-1：优惠券验证请求
- en: '[PRE15]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 12-2: The coupon validation response'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-2：优惠券验证响应
- en: While reviewing the results, you may notice something interesting. Select one
    of the results and look at the Request tab. Notice that the payload we sent has
    been encoded. This could be interfering with our injection attack because the
    encoded data might not be interpreted correctly by the application. In other situations,
    the payload might need to be encoded to help bypass security controls, but for
    now, let’s find the source of this problem. At the bottom of the Burp Suite Intruder
    Payloads tab is an option to URL-encode certain characters. Uncheck this box,
    as shown in [Figure 12-5](#figure12-5), so that the characters will be sent, and
    then send another attack.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看结果时，您可能会注意到一些有趣的情况。选择其中一个结果并查看请求选项卡。请注意，我们发送的负载已被编码。这可能会干扰我们的注入攻击，因为编码后的数据可能无法被应用程序正确解释。在其他情况下，负载可能需要被编码，以帮助绕过安全控制，但现在我们需要找出这个问题的源头。在
    Burp Suite Intruder 负载选项卡的底部，有一个选项可以 URL 编码某些字符。请取消选中该框，如[图 12-5](#figure12-5)所示，以便发送原始字符，然后重新发送一次攻击。
- en: '![screenshot of burp suite’s intruder payloads tab that shows the “url-encode
    these characters” option as unchecked](image_fi/502444c12/F12005.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite 的 Intruder 负载选项卡截图，显示“url-encode 这些字符”选项未勾选](image_fi/502444c12/F12005.png)'
- en: 'Figure 12-5: Burp Suite Intruder’s payload-encoding options'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-5：Burp Suite Intruder 的负载编码选项
- en: 'The request should now look like [Listing 12-3](#listing12-3), and the response
    should now look like [Listing 12-4](#listing12-4):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请求应像[列表 12-3](#listing12-3)中所示，响应应像[列表 12-4](#listing12-4)中所示：
- en: '[PRE16]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 12-3: The request with URL encoding disabled'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-3：禁用 URL 编码的请求
- en: '[PRE17]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 12-4: The corresponding response'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-4：相应的响应
- en: This round of attacks did result in some slightly more interesting responses.
    Notice the 422 Unprocessable Entity status code, along with the verbose error
    message. This status code normally means that there is an issue in the syntax
    of the request.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这一轮攻击确实产生了一些稍微更有趣的响应。请注意 422 Unprocessable Entity 状态码，以及详细的错误信息。这个状态码通常意味着请求的语法存在问题。
- en: 'Taking a closer look at our request, you might notice a possible issue: we
    placed our payload position within the original key/value quotes generated in
    the web application’s request. We should experiment with the payload position
    to include the quotes so as to not interfere with nested object injection attempts.
    Now the Intruder payload positions should look like the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看我们的请求，你可能会注意到一个潜在问题：我们将载荷位置放置在了 Web 应用程序请求中生成的原始键/值引号内。我们应该尝试调整载荷位置，包含引号，以避免干扰嵌套对象的注入尝试。现在，Intruder
    的载荷位置应如下所示：
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once again, initiate the updated Intruder attack. This time, we receive even
    more interesting results, including two 200 status codes (see [Figure 12-6](#figure12-6)).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 再次发起更新后的 Intruder 攻击。这次我们收到了更有趣的结果，包括两个 200 状态码（见[图 12-6](#figure12-6)）。
- en: '![screenshot of burp suite’s intruder results that shows various requests of
    varying lengths; all but two requests are of status code 422, and the two are
    of status code 200.](image_fi/502444c12/F12006.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite 的 Intruder 结果截图，显示不同长度的请求；除了两个请求外，其他请求的状态码都是 422，两个请求的状态码是 200。](image_fi/502444c12/F12006.png)'
- en: 'Figure 12-6: Burp Suite Intruder results'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-6：Burp Suite Intruder 结果
- en: As you can see, two injection payloads, `{"$gt":""}` and `{"$nin":[1]}`, resulted
    in successful responses. By investigating the response to the `$nin` (not in)
    NoSQL operator, we see that the API request has returned a valid coupon code.
    Congratulations on performing a successful API NoSQL injection attack!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，两个注入载荷 `{"$gt":""}` 和 `{"$nin":[1]}` 导致了成功的响应。通过调查响应中的 `$nin`（不在）NoSQL
    操作符，我们看到 API 请求返回了有效的优惠券代码。恭喜你成功执行了 API NoSQL 注入攻击！
- en: Sometimes the injection vulnerability is present, but you need to troubleshoot
    your attack attempts to find the injection point. Therefore, make sure you analyze
    your requests and responses and follow the clues left within verbose error messages.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有时注入漏洞是存在的，但你需要排查攻击尝试，以找到注入点。因此，确保分析你的请求和响应，并遵循详细错误信息中留下的线索。
