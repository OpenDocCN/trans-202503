- en: Chapter 17. A Stack-Based Buffer Overflow in Windows
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第17章. Windows中的基于栈的缓冲区溢出
- en: In this chapter, we will look at exploiting a stack-based buffer overflow in
    an older version of a Windows-based FTP server. As we did in [Chapter 16](ch16.xhtml
    "Chapter 16. A Stack-Based Buffer Overflow in Linux"), we will attempt to overwrite
    the return pointer saved onto the stack when a function is called, as shown earlier
    in [Figure 16-3](ch16.xhtml#stack_after_call_to_function1 "Figure 16-3. Stack
    after call to function1"). When the function `main` calls `function1`, the next
    instruction to be executed is saved on the stack, and a stack frame for `function1`
    is added to the stack.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究如何利用Windows平台FTP服务器的一个旧版本中的基于栈的缓冲区溢出问题。正如我们在[第16章](ch16.xhtml "第16章.
    Linux中的基于栈的缓冲区溢出")中所做的那样，我们将尝试覆盖在调用函数时保存在栈上的返回指针，如[图16-3](ch16.xhtml#stack_after_call_to_function1
    "图16-3. 调用function1后的栈")中所示。当`main`函数调用`function1`时，下一条要执行的指令会被保存在栈上，并且会在栈中为`function1`添加栈帧。
- en: The size of `function1`’s local variables is determined when the application
    is compiled and fixed. The amount of space “reserved” on the stack for these local
    variables is fixed, too. This reservation is called a *stack buffer*. If we put
    more data in the stack buffer than it can hold, we will cause the buffer to overflow.
    Then we may be able to overwrite the saved return address, which is placed after
    the stack buffer, and take control of program execution. (For a more detailed
    review of this process, see [Chapter 16](ch16.xhtml "Chapter 16. A Stack-Based
    Buffer Overflow in Linux").)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`function1`的局部变量大小是在应用程序编译时确定并固定的。为这些局部变量“预留”的栈空间大小也是固定的。这种预留被称为*栈缓冲区*。如果我们在栈缓冲区中放入超过其容量的数据，就会导致缓冲区溢出。然后，我们可能会覆盖保存的返回地址，该地址位于栈缓冲区之后，并接管程序的执行控制。（有关此过程的详细回顾，请参见[第16章](ch16.xhtml
    "第16章. Linux中的基于栈的缓冲区溢出")。）'
- en: In [Chapter 1](ch01.xhtml "Chapter 1. Setting Up Your Virtual Lab"), we installed
    War-FTP version 1.65 on the Windows XP target, but we didn’t start it. We have
    exploited the FileZilla FTP server in previous chapters, and if you’ve been following
    along, that FTP server is still running. Before we can use War-FTP, we need to
    stop the FileZilla FTP server using the XAMPP control panel. This will open TCP
    port 21 for War-FTP. Open War-FTP on the Windows XP desktop by double clicking
    its icon (see [Figure 17-1](ch17.xhtml#war-ftp_icon "Figure 17-1. War-FTP icon")),
    and click the lightning bolt in the top-left corner of the War-FTP window to put
    it online (see [Figure 17-2](ch17.xhtml#war-ftp_1dot65_gui "Figure 17-2. War-FTP
    1.65 GUI")).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml "第1章. 设置你的虚拟实验室")中，我们在Windows XP目标机器上安装了War-FTP版本1.65，但我们没有启动它。在之前的章节中，我们已经利用了FileZilla
    FTP服务器，如果你一直跟着教程走，那么这个FTP服务器仍然在运行。在我们使用War-FTP之前，需要通过XAMPP控制面板停止FileZilla FTP服务器。这将为War-FTP打开TCP端口21。在Windows
    XP桌面上双击其图标打开War-FTP（见[图17-1](ch17.xhtml#war-ftp_icon "图17-1. War-FTP图标")），然后点击War-FTP窗口左上角的闪电图标使其上线（见[图17-2](ch17.xhtml#war-ftp_1dot65_gui
    "图17-2. War-FTP 1.65 GUI")）。
- en: '![War-FTP icon](httpatomoreillycomsourcenostarchimages2030510.png.jpg)Figure 17-1. War-FTP
    icon'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '![War-FTP图标](httpatomoreillycomsourcenostarchimages2030510.png.jpg)图17-1. War-FTP图标'
- en: Searching for a Known Vulnerability in War-FTP
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索War-FTP的已知漏洞
- en: 'A search on Google for known vulnerabilities in War-FTP 1.65 finds the following
    information on *SecurityFocus.com*:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Google上搜索War-FTP 1.65的已知漏洞时，找到了以下关于*SecurityFocus.com*上的信息：
- en: War-FTP Username Stack-Based Buffer-Overflow Vulnerability
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: War-FTP用户名基于栈的缓冲区溢出漏洞
- en: ''
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: War-FTP is prone to a stack-based buffer-overflow vulnerability because it fails
    to properly check boundaries on user-supplied data before copying it to an insufficiently
    sized buffer.
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: War-FTP容易受到基于栈的缓冲区溢出漏洞的影响，因为它在将用户提供的数据复制到大小不足的缓冲区时没有正确检查数据边界。
- en: ''
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exploiting this issue could lead to denial-of-service conditions and to the
    execution of arbitrary machine code in the context of the application.
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 利用此问题可能导致拒绝服务条件，并在应用程序上下文中执行任意机器代码。
- en: In [Chapter 16](ch16.xhtml "Chapter 16. A Stack-Based Buffer Overflow in Linux"),
    we overflowed a function’s local variable on the stack with supplied input and
    redirected execution to a memory location of our choosing. Based on this information
    from *SecurityFocus.com*, it looks like we can do something similar with War-FTP
    1.65\. In this chapter, we will manually exploit War-FTP 1.65’s stack-based buffer
    overflow vulnerability in the Username field of the FTP login. Now that we are
    using a real program rather than demo code, we will learn more about writing real
    exploits. For example, this time we won’t be able to simply redirect execution
    to another function; we will instead need to introduce instructions to be executed
    as part of our attack string.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第16章](ch16.xhtml "第16章. Linux中的基于堆栈的缓冲区溢出")中，我们通过提供的输入溢出了一个函数的局部变量，并将执行重定向到我们选择的内存位置。根据*SecurityFocus.com*提供的信息，看起来我们可以对War-FTP
    1.65做类似的操作。在本章中，我们将手动利用War-FTP 1.65的基于堆栈的缓冲区溢出漏洞，该漏洞出现在FTP登录的用户名字段中。现在我们使用的是一个实际的程序，而不是示例代码，我们将学习更多关于编写实际漏洞利用的知识。例如，这一次我们不能简单地将执行重定向到另一个函数；相反，我们需要在攻击字符串中引入要执行的指令。
- en: To get started, make sure War-FTP 1.65 is open and running on your Win-dows
    XP virtual machine. (The lightning bolt icon in the top-left corner of the GUI
    shown in [Figure 17-2](ch17.xhtml#war-ftp_1dot65_gui "Figure 17-2. War-FTP 1.65
    GUI") tells the server to listen for incoming connections.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，确保War-FTP 1.65已经在你的Windows XP虚拟机上打开并运行。（如[图17-2](ch17.xhtml#war-ftp_1dot65_gui
    "图17-2. War-FTP 1.65 GUI")所示，GUI左上角的闪电图标表示服务器正在监听传入的连接。）
- en: The issue we are going to exploit is particularly dangerous because an attacker
    does not need to log in to the FTP server before launching an attack. Thus, we
    do not need to add any legitimate users to the FTP server for this attack to work.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要利用的问题特别危险，因为攻击者无需登录FTP服务器即可发起攻击。因此，我们无需向FTP服务器添加任何合法用户，攻击就能生效。
- en: Before we dive in and start trying to exploit War-FTP, let’s hook it up to a
    debugger. Immunity Debugger should be on the desktop of your Windows XP target
    because we installed it in [Chapter 1](ch01.xhtml "Chapter 1. Setting Up Your
    Virtual Lab"). If it is not, follow the instructions in [Chapter 1](ch01.xhtml
    "Chapter 1. Setting Up Your Virtual Lab") for setting up Immunity Debugger and
    the Mona plugin. Like GDB, Immunity Debugger will allow us to see the internals
    of memory as we attempt to exploit War-FTP. Unfortunately, we don’t have source
    code to guide us toward a successful exploit, but by watching our program in memory
    as we send it attack strings, we should still be able to develop a working exploit.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入并开始尝试利用War-FTP之前，让我们将它连接到调试器。Immunity Debugger应该已经安装在你的Windows XP目标机器的桌面上，因为我们在[第1章](ch01.xhtml
    "第1章. 设置你的虚拟实验室")中安装过它。如果没有，请按照[第1章](ch01.xhtml "第1章. 设置你的虚拟实验室")中的说明来设置Immunity
    Debugger和Mona插件。像GDB一样，Immunity Debugger将允许我们在尝试利用War-FTP时查看内存的内部结构。不幸的是，我们没有源代码来帮助我们成功利用漏洞，但通过在内存中观察程序并发送攻击字符串，我们仍然能够开发出一个有效的漏洞利用。
- en: '![War-FTP 1.65 GUI](httpatomoreillycomsourcenostarchimages2030512.png.jpg)Figure 17-2. War-FTP
    1.65 GUI'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![War-FTP 1.65 GUI](httpatomoreillycomsourcenostarchimages2030512.png.jpg)图17-2.
    War-FTP 1.65 GUI'
- en: Start Immunity Debugger, open the **File** menu, and select **Attach**. We want
    to attach Immunity Debugger to the running War-FTP process, which we see in the
    process list in [Figure 17-3](ch17.xhtml#process_list_in_the_immunity_debugger_in
    "Figure 17-3. Process list in the Immunity Debugger interface"). Highlight War-FTP
    1.65, and click **Attach**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Immunity Debugger，打开**文件**菜单，选择**附加**。我们想要将Immunity Debugger附加到正在运行的War-FTP进程，进程列表中显示了它，见[图17-3](ch17.xhtml#process_list_in_the_immunity_debugger_in
    "图17-3. Immunity Debugger中的进程列表")。高亮选择War-FTP 1.65，然后点击**附加**。
- en: '![Process list in the Immunity Debugger interface](httpatomoreillycomsourcenostarchimages2030514.png.jpg)Figure 17-3. Process
    list in the Immunity Debugger interface'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![Immunity Debugger界面中的进程列表](httpatomoreillycomsourcenostarchimages2030514.png.jpg)图17-3.
    Immunity Debugger界面中的进程列表'
- en: When Immunity Debugger first attaches to a process, it pauses the process’s
    execution. If at any point your exploit just randomly stops working, check to
    make sure the process is running. A paused process isn’t listening for incoming
    connections, and, as you can see in the lower-right corner of the Immunity Debugger
    window in [Figure 17-4](ch17.xhtml#war-ftp_pauses_in_immunity_debuggerdot "Figure 17-4. War-FTP
    pauses in Immunity Debugger."), the process is paused. Click the **Play** button
    at the top-left corner of the screen to tell the process to continue running.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Immunity Debugger 首次附加到一个进程时，它会暂停该进程的执行。如果在任何时候你的利用代码突然停止工作，请检查确保进程仍在运行。暂停的进程无法接收传入连接，正如你在
    Immunity Debugger 窗口的右下角看到的 [图17-4](ch17.xhtml#war-ftp_pauses_in_immunity_debuggerdot
    "Figure 17-4. War-FTP pauses in Immunity Debugger.") 中所示，进程处于暂停状态。点击屏幕左上角的**播放**按钮，让进程继续运行。
- en: '![War-FTP pauses in Immunity Debugger.](httpatomoreillycomsourcenostarchimages2030516.png.jpg)Figure 17-4. War-FTP
    pauses in Immunity Debugger.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![War-FTP 在 Immunity Debugger 中暂停。](httpatomoreillycomsourcenostarchimages2030516.png.jpg)图17-4.
    War-FTP 在 Immunity Debugger 中暂停。'
- en: With War-FTP running in Immunity Debugger, we can figure out how to exploit
    its buffer overflow vulnerability.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Immunity Debugger 中运行 War-FTP 时，我们可以找出如何利用其缓冲区溢出漏洞。
- en: Causing a Crash
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导致崩溃
- en: In [Chapter 19](ch19.xhtml "Chapter 19. Fuzzing, Porting Exploits, and Metasploit
    Modules"), we will use a technique called *fuzzing* to look for potential vulnerabilities
    in programs, but for now, follow my lead on which attack strings to use to crash
    the program. In the Username field of the FTP login, let’s send a string of 1,100
    *A*s instead of a username. Rather than attacking our program locally, as we did
    in the previous example, this time we will create our exploit in Kali Linux and
    set up the exploit to talk to the FTP server over the network. [Example 17-1](ch17.xhtml#python_exploit_to_crash_war-ftp
    "Example 17-1. Python exploit to crash War-FTP") shows a starter exploit that
    will cause the War-FTP program to crash.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第19章](ch19.xhtml "Chapter 19. Fuzzing, Porting Exploits, and Metasploit Modules")
    中，我们将使用一种叫做 *模糊测试* 的技术来寻找程序中的潜在漏洞，但现在，按照我的指导，使用特定的攻击字符串来让程序崩溃。在 FTP 登录的用户名字段中，我们将发送一个包含
    1,100 个 *A* 的字符串，而不是一个用户名。与我们在前一个示例中本地攻击程序不同，这次我们将在 Kali Linux 中创建我们的利用代码，并将其设置为通过网络与
    FTP 服务器进行通信。[示例17-1](ch17.xhtml#python_exploit_to_crash_war-ftp "Example 17-1.
    Python exploit to crash War-FTP") 展示了一个初步的利用代码，能够导致 War-FTP 程序崩溃。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Our exploit examples are written in Python, but they can easily be ported into
    another language if you’d prefer to use a different one.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的利用示例是用 Python 编写的，但如果你更愿意使用其他语言，它们很容易移植到其他语言中。
- en: Example 17-1. Python exploit to crash War-FTP
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 示例17-1. Python 利用代码导致 War-FTP 崩溃
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the exploit shown in [Example 17-1](ch17.xhtml#python_exploit_to_crash_war-ftp
    "Example 17-1. Python exploit to crash War-FTP"), we first import the socket Python
    library. Next, we create a string called *buffer*, which contains 1,100 *A*s,
    and set up a socket at ❶ to connect to our Windows XP machine on port 21, where
    the War-FTP server is listening. Next, we accept and print out the FTP server’s
    banner to the screen at ❷. Our exploit then sends over the `USER` command with
    1,100 *A*s ❸ for the username in hopes of causing the FTP server to crash.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例17-1](ch17.xhtml#python_exploit_to_crash_war-ftp "Example 17-1. Python
    exploit to crash War-FTP")中，我们首先导入了 socket Python 库。接下来，我们创建一个名为*buffer*的字符串，其中包含
    1,100 个*A*，并在 ❶ 设置一个 socket 来连接到我们运行 War-FTP 服务器的 Windows XP 机器的 21 端口。然后，在 ❷
    处，我们接收并打印出 FTP 服务器的横幅信息。我们的利用代码接着发送 `USER` 命令，并用 1,100 个 *A* 作为用户名 ❸，希望导致 FTP
    服务器崩溃。
- en: If the server responds and asks for our password, the exploit is ready to finish
    the connection with the password, *PASSWORD*. However, if our exploit succeeds,
    it won’t matter if our credentials are valid, because the program will crash before
    it finishes the login process. Finally, we close our socket, and the exploit finishes.
    Make sure the Python script is executable with `chmod +x`, and run the exploit
    as shown here.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器响应并请求我们的密码，利用代码准备好使用密码 *PASSWORD* 完成连接。然而，如果我们的利用成功了，即使我们的凭据有效也无关紧要，因为程序会在完成登录过程之前崩溃。最后，我们关闭我们的
    socket，利用代码结束。确保 Python 脚本是可执行的，可以使用 `chmod +x` 命令，并按照下面的示例运行利用代码。
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As with the previous example, we hope to overwrite the saved return address
    with a string of *A*s and cause the program to crash. The War-FTP server sends
    over its welcome banner, prompts us for our username, and then asks for a password.
    Take a look at War-FTP in Immunity Debugger, as shown in [Figure 17-5](ch17.xhtml#war-ftp_crashes_due_to_a_buffer_overflow
    "Figure 17-5. War-FTP crashes due to a buffer overflow."), to see if our exploit
    managed to cause a crash.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如同之前的示例一样，我们希望通过一串 *A* 字符来覆盖保存的返回地址并导致程序崩溃。War-FTP 服务器发送欢迎横幅，提示我们输入用户名，然后询问密码。查看
    Immunity Debugger 中的 War-FTP，如[图 17-5](ch17.xhtml#war-ftp_crashes_due_to_a_buffer_overflow
    "图 17-5. 由于缓冲区溢出，War-FTP 崩溃。")所示，看看我们的利用是否成功导致崩溃。
- en: '![War-FTP crashes due to a buffer overflow.](httpatomoreillycomsourcenostarchimages2030518.png.jpg)Figure 17-5. War-FTP
    crashes due to a buffer overflow.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![由于缓冲区溢出，War-FTP 崩溃。](httpatomoreillycomsourcenostarchimages2030518.png.jpg)图
    17-5. 由于缓冲区溢出，War-FTP 崩溃。'
- en: After we run our exploit, we see that War-FTP is paused due to an access violation
    when attempting to execute an instruction at `41414141`. Based on what we learned
    in the Linux buffer overflow example in [Chapter 16](ch16.xhtml "Chapter 16. A
    Stack-Based Buffer Overflow in Linux"), this result should seem familiar. A return
    address was overwritten by our long string of *A*s, so when the function returned,
    `41414141` was loaded into the EIP register. The program attempted to execute
    the instructions at that memory location, which was out of bounds and caused a
    crash.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行利用代码后，我们看到 War-FTP 因访问违规而暂停，并尝试在 `41414141` 处执行指令。根据我们在[第 16 章](ch16.xhtml
    "第 16 章. Linux 中的基于栈的缓冲区溢出")的 Linux 缓冲区溢出示例中学到的知识，这个结果应该是熟悉的。一个返回地址被我们的长 *A* 字符串覆盖，因此当函数返回时，`41414141`
    被加载到 EIP 寄存器中。程序试图在该内存位置执行指令，而该位置超出边界并导致崩溃。
- en: Locating EIP
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位 EIP
- en: As with the previous example, we need to know which four *A*s in our string
    are overwriting the return address. Unfortunately, 1,100 *A*s is a bit more than
    the 30 we used in the previous chapter, so just counting in memory is more difficult
    in this case. Also, we can’t be sure if the first *A*s we’re seeing on the stack
    are the first *A*s sent as part of the exploit.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如同之前的示例，我们需要知道我们字符串中的哪四个 *A* 字符正在覆盖返回地址。不幸的是，1,100 个 *A* 字符比我们在前一章使用的 30 个要多，所以在内存中逐个计数变得更加困难。此外，我们无法确定我们在堆栈上看到的第一个
    *A* 字符是否是作为利用的一部分发送的第一个 *A* 字符。
- en: Traditionally, the next step would be to crash the program again with 550 *A*s
    followed by 550 *B*s. If the program crashed with `41414141` in EIP, then the
    return address overwrite occurred in the first 550 bytes; if it crashed with `42424242`
    in EIP, the overwrite was in the second half. From there, the half of the string
    in question would be split into 275 *A*s followed by 275 *B*s. Slowly but surely,
    this method would narrow down the exact location.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，下一步是再次通过输入 550 个 *A* 字符后接 550 个 *B* 字符来使程序崩溃。如果程序在 EIP 中出现 `41414141`，则表示返回地址在前
    550 字节处发生了覆盖；如果程序在 EIP 中出现 `42424242`，则说明覆盖发生在后半部分。接下来，将问题字符串的那一半分为 275 个 *A*
    字符后接 275 个 *B* 字符。通过这种缓慢但可靠的方法，可以逐步缩小确切位置。
- en: Generating a Cyclical Pattern to Determine Offset
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成循环模式以确定偏移量
- en: Luckily, we can use Mona to generate a unique cyclic pattern to find the right
    four bytes for the return address overwrite in only one iteration. To use Mona
    for this task, enter **`!mona pattern_create`** with length **1100** as an argument
    at the bottom of the Immunity Debugger window, as shown in [Figure 17-6](ch17.xhtml#using_patternunderscorecreate_in_mona
    "Figure 17-6. Using pattern_create in Mona").
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以使用 Mona 生成一个独特的循环模式，在仅一次迭代中找到返回地址覆盖的正确四个字节。要使用 Mona 完成此任务，请在 Immunity
    Debugger 窗口的底部输入 **`!mona pattern_create`**，并将长度设置为 **1100**，如[图 17-6](ch17.xhtml#using_patternunderscorecreate_in_mona
    "图 17-6. 在 Mona 中使用 pattern_create")所示。
- en: '![Using pattern_create in Mona](httpatomoreillycomsourcenostarchimages2030520.png.jpg)Figure 17-6. Using
    `pattern_create` in Mona'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![在 Mona 中使用 pattern_create](httpatomoreillycomsourcenostarchimages2030520.png.jpg)图
    17-6. 在 Mona 中使用 `pattern_create`'
- en: The 1,100-character cyclic pattern is written to the file *C:\logs\war-ftpd\pattern.txt*,
    as shown in [Example 17-2](ch17.xhtml#output_of_the_patternunderscorecreate_co
    "Example 17-2. Output of the pattern_create command").
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 1,100 字符的循环模式被写入文件 *C:\logs\war-ftpd\pattern.txt*，如[示例 17-2](ch17.xhtml#output_of_the_patternunderscorecreate_co
    "示例 17-2. `pattern_create` 命令的输出")所示。
- en: Example 17-2. Output of the `pattern_create` command
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 17-2. `pattern_create` 命令的输出
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are going to replace the long string of *A*s with the unique pattern shown
    in [Example 17-2](ch17.xhtml#output_of_the_patternunderscorecreate_co "Example 17-2. Output
    of the pattern_create command"). But before running the exploit again, we need
    to restart War-FTP from the previous crash. In Immunity Debugger, go to **Debug**
    ▸ **Restart**, and then press the **Play** button and click the lightning bolt
    icon to tell War-FTP to listen on the network. (Follow these steps each time you
    need to restart War-FTP after a crash.) Alternatively, you can close Immunity
    Debugger, restart War-FTP manually, and attach to the new process in the debugger.
    Replace the value of the buffer in the exploit with the pattern from [Example 17-2](ch17.xhtml#output_of_the_patternunderscorecreate_co
    "Example 17-2. Output of the pattern_create command"), surrounded by quotation
    marks to make it a string in Python, as shown in [Example 17-3](ch17.xhtml#exploit_with_cyclic_pattern
    "Example 17-3. Exploit with cyclic pattern").
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用在[示例17-2](ch17.xhtml#output_of_the_patternunderscorecreate_co "示例17-2. pattern_create命令输出")中显示的唯一模式替换掉这一长串的*
    A *。但在再次运行漏洞利用之前，我们需要从上次崩溃中重新启动War-FTP。在Immunity调试器中，点击**调试** ▸ **重新启动**，然后按下**播放**按钮并点击闪电图标，指示War-FTP开始监听网络。（每次War-FTP崩溃后需要重新启动时，都需要按照这些步骤进行。）或者，您可以关闭Immunity调试器，手动重新启动War-FTP，然后将新进程附加到调试器中。将漏洞利用中的缓冲区值替换为[示例17-2](ch17.xhtml#output_of_the_patternunderscorecreate_co
    "示例17-2. pattern_create命令输出")中的模式，并用引号将其括起来，使其成为Python中的字符串，如[示例17-3](ch17.xhtml#exploit_with_cyclic_pattern
    "示例17-3. 带有循环模式的漏洞利用")所示。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If War-FTP refuses to restart with the error *Unknown format for user database*,
    find and delete the files *FtpDaemon.dat* and/or *FtpDaemon.ini* that were created
    on the desktop by War-FTP. This should fix the problem and War-FTP should start
    normally.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果War-FTP因*未知的用户数据库格式*错误而拒绝重新启动，找到并删除War-FTP在桌面上创建的*FtpDaemon.dat*和/或*FtpDaemon.ini*文件。这应该能解决问题，War-FTP应该能正常启动。
- en: Example 17-3. Exploit with cyclic pattern
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 示例17-3. 带有循环模式的漏洞利用
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now run the exploit again with the generated pattern starting at ❶, replacing
    the 1,100 *A*s.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新运行漏洞利用，使用从❶开始的生成模式，替换掉1,100个* A *。
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Having run our exploit with Metasploit’s pattern, look back at Immunity Debugger,
    as shown in [Figure 17-7](ch17.xhtml#finding_the_return_address_overwrite "Figure 17-7. Finding
    the return address overwrite"), to see what value is contained in EIP and to find
    out where in our attack string we overwrite the return address.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Metasploit的模式运行漏洞利用后，回到Immunity调试器，如图[17-7](ch17.xhtml#finding_the_return_address_overwrite
    "图17-7. 查找返回地址覆盖")所示，查看EIP中包含的值，并找出我们在攻击字符串中覆盖返回地址的位置。
- en: '![Finding the return address overwrite](httpatomoreillycomsourcenostarchimages2030522.png.jpg)Figure 17-7. Finding
    the return address overwrite'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![查找返回地址覆盖](httpatomoreillycomsourcenostarchimages2030522.png.jpg)图17-7. 查找返回地址覆盖'
- en: 'War-FTP has crashed again, but this time EIP contains four bytes of our generated
    pattern: `32714131`. We can use Mona to determine where exactly in the 1,100-character
    cyclic pattern the ASCII equivalent of `32714131` is. Enter **`!mona pattern_offset
    32714131`** to get just the offset, or enter **`!mona findmsp`** at the Immunity
    Debugger prompt, as shown in [Figure 17-8](ch17.xhtml#finding_the_pattern_offsets_in_mona
    "Figure 17-8. Finding the pattern offsets in Mona"), to have Mona perform additional
    analysis on all registers and on instances of the pattern in memory.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: War-FTP再次崩溃，但这次EIP包含了我们生成的四个字节模式：`32714131`。我们可以使用Mona来确定`32714131`的ASCII等效值在1,100字符的循环模式中的准确位置。输入**`!mona
    pattern_offset 32714131`**可以仅获取偏移量，或者在Immunity调试器提示符下输入**`!mona findmsp`**，如图[17-8](ch17.xhtml#finding_the_pattern_offsets_in_mona
    "图17-8. 查找Mona中的模式偏移")所示，让Mona对所有寄存器和内存中的模式实例执行额外分析。
- en: '![Finding the pattern offsets in Mona](httpatomoreillycomsourcenostarchimages2030524.png.jpg)Figure 17-8. Finding
    the pattern offsets in Mona'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![查找Mona中的模式偏移](httpatomoreillycomsourcenostarchimages2030524.png.jpg)图17-8.
    查找Mona中的模式偏移'
- en: Mona finds instances of the cyclic pattern in memory. The output of the command
    is written to *C:\logs\war-ftpd\findmsp.txt*. Part of the output is shown here.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Mona在内存中找到了循环模式的实例。命令的输出被写入到*C:\logs\war-ftpd\findmsp.txt*中。部分输出如下所示。
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Verifying Offsets
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证偏移量
- en: According to Mona, our return address overwrite is 485 bytes into the attack
    string. We can verify this, as shown in [Example 17-4](ch17.xhtml#verifying_the_eip_offset
    "Example 17-4. Verifying the EIP offset").
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Mona的分析，我们的返回地址覆盖发生在攻击字符串的485字节位置。我们可以通过[示例17-4](ch17.xhtml#verifying_the_eip_offset
    "示例17-4. 验证EIP偏移")来验证这一点。
- en: Example 17-4. Verifying the EIP offset
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 示例17-4. 验证EIP偏移
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we’ll create an attack string that contains 485 *A*s, 4 *B*s, and 611 *C*s
    as shown at ❶ in [Example 17-4](ch17.xhtml#verifying_the_eip_offset "Example 17-4. Verifying
    the EIP offset"). With our new string in place, if EIP contains `42424242` when
    the program crashes, we’ll know we have found the correct four bytes for the return
    address. (Remember to restart War-FTP in Immunity Debugger before running the
    exploit again.) Now, check EIP, as shown in [Figure 17-9](ch17.xhtml#war-ftp_crashes_with_eip_filled_with_bs
    "Figure 17-9. War-FTP crashes with EIP filled with Bs").
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个攻击字符串，包含485个*A*、4个*B*和611个*C*，如[示例17-4](ch17.xhtml#verifying_the_eip_offset
    "示例17-4. 验证EIP偏移")中的❶所示。将新的字符串放入后，如果程序崩溃时EIP包含`42424242`，我们就知道找到了正确的返回地址四个字节。（记得在重新运行攻击前先在Immunity
    Debugger中重启War-FTP。）现在，检查EIP，如[图17-9](ch17.xhtml#war-ftp_crashes_with_eip_filled_with_bs
    "图17-9. War-FTP崩溃，EIP填充了B")所示。
- en: As expected, War-FTP has crashed again, this time with `42424242` in EIP. This
    result confirms that we have found the location of the return address in our attack
    string. Next we need to find someplace to redirect execution and exploit this
    buffer overflow vulnerability.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，War-FTP再次崩溃，这次EIP中是`42424242`。这个结果确认了我们找到了攻击字符串中返回地址的位置。接下来，我们需要找到一个位置来重定向执行并利用这个缓冲区溢出漏洞。
- en: '![War-FTP crashes with EIP filled with Bs](httpatomoreillycomsourcenostarchimages2030526.png.jpg)Figure 17-9. War-FTP
    crashes with EIP filled with Bs'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![War-FTP崩溃，EIP填充了B](httpatomoreillycomsourcenostarchimages2030526.png.jpg)
    图17-9. War-FTP崩溃，EIP填充了B'
- en: Hijacking Execution
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 劫持执行
- en: In the exploit example discussed in [Chapter 16](ch16.xhtml "Chapter 16. A Stack-Based
    Buffer Overflow in Linux"), we sent execution to another function. Unfortunately,
    because we don’t have the source code of War-FTP to review for potentially interesting
    code, we’ll use a more typical technique for exploit development this time. Instead
    of redirecting execution to somewhere else in the program, we will introduce our
    own instructions and redirect execution to part of our attack string.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第16章](ch16.xhtml "第16章. Linux中的基于栈的缓冲区溢出")中讨论的利用示例中，我们将执行重定向到另一个函数。不幸的是，由于我们没有War-FTP的源代码来查看潜在有趣的代码，这次我们将采用一种更典型的利用开发技术。我们将不再将执行重定向到程序的其他部分，而是引入我们自己的指令，并将执行重定向到攻击字符串的一部分。
- en: First, we need to find out if part of our attack string is easily accessible
    at the time of the crash. Look back at the output of the `!mona findmsp` command
    in *C:\logs\warftp-d\findmsp.txt*, as shown here.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出在崩溃时是否可以轻松访问攻击字符串的一部分。请回顾一下`!mona findmsp`命令在*C:\logs\warftp-d\findmsp.txt*中的输出，如下所示。
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In addition to taking control of EIP, the registers ESP, EDI, and EBP also point
    to part of the attack string. In other words, our attack string decides the contents
    of these registers, and there’s nothing to stop us from replacing the part of
    the attack string (the *C*s in our current crash) with useful instructions for
    the CPU to execute.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了控制EIP外，寄存器ESP、EDI和EBP也指向攻击字符串的一部分。换句话说，我们的攻击字符串决定了这些寄存器的内容，没有任何东西能阻止我们将攻击字符串的一部分（当前崩溃中的*C*）替换为CPU可以执行的有用指令。
- en: We can see that ESP is at memory address `00AFFD48`, while EBP is slightly higher
    in memory at address `00AFFDA0`. EDI is at `00AFFE48`. We could redirect execution
    to any of these locations, but with the lower address farther up the stack, we
    have a little more space for our instructions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，ESP的内存地址是`00AFFD48`，而EBP的内存地址稍微高一些，是`00AFFDA0`。EDI的地址是`00AFFE48`。我们可以将执行重定向到这些位置中的任何一个，但是由于较低的地址更靠近栈的顶部，我们可以为指令提供更多空间。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Also, note that ESP does not point directly to the beginning of our Cs. Our
    saved return pointer overwrite is at byte 485 in the pattern, but ESP is at 493,
    eight bytes away (four bytes for the return address and four bytes of Cs).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，ESP并未直接指向我们*C*的开始位置。我们保存的返回指针覆盖位于模式中的第485个字节，但ESP在493位置，距离有8个字节（4个字节用于返回地址和4个字节用于*C*）。
- en: Right-click **ESP** in the top right of the Immunity Debugger window, and select
    **Follow in Stack**. The stack is shown in the bottom right of the Immunity Debugger
    window. Scroll up a few lines, as shown in [Figure 17-10](ch17.xhtml#esp_controlled_by_the_attack_string
    "Figure 17-10. ESP controlled by the attack string").
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击Immunity Debugger窗口右上方的**ESP**，选择**Follow in Stack**。栈会显示在Immunity Debugger窗口的右下角。向上滚动几行，如[图17-10](ch17.xhtml#esp_controlled_by_the_attack_string
    "图17-10. ESP由攻击字符串控制")所示。
- en: Notice that the line above ESP also contains four *C*s, and above that are four
    *B*s for the return address. This tells us that we need to start our malicious
    instructions for the CPU to execute four bytes into our *C*s in the attack string
    (because ESP is four bytes into the *C*s); otherwise, the first four bytes of
    our shellcode will be missed. (This sort of scenario will come up frequently because
    these four *C*s are caused by a calling convention and indicate that the function
    has cleaned-up arguments.)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，ESP上方的那一行也包含了四个*C*，而在其上方则有四个*B*，表示返回地址。这告诉我们我们需要在攻击字符串中的*C*处开始我们的恶意指令（因为ESP指向的是*C*的四个字节），否则我们的shellcode的前四个字节将会被跳过。（这种情况会经常出现，因为这四个*C*是由调用约定造成的，表示该函数已经清理了参数。）
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Calling conventions are a set of rules implemented in a compiler, describing
    how a child function will receive arguments from its caller function. Some conventions
    will cause the caller function to remove the arguments from the stack, while others
    state that the child function must remove the arguments. The latter will cause
    one or more dwords (depending on the number of arguments) to be skipped on the
    stack automatically, as shown in [Figure 17-10](ch17.xhtml#esp_controlled_by_the_attack_string
    "Figure 17-10. ESP controlled by the attack string"), as soon as the child function
    ends.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 调用约定是编译器中实现的一组规则，描述了子函数如何从其调用函数接收参数。一些约定会导致调用函数从栈中移除参数，而另一些约定则规定子函数必须移除参数。后一种约定将导致一个或多个双字（根据参数的数量）在栈上自动跳过，如[图
    17-10](ch17.xhtml#esp_controlled_by_the_attack_string "图 17-10. ESP 被攻击字符串控制")所示，一旦子函数结束。
- en: '![ESP controlled by the attack string](httpatomoreillycomsourcenostarchimages2030528.png.jpg)Figure 17-10. ESP
    controlled by the attack string'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![ESP 被攻击字符串控制](httpatomoreillycomsourcenostarchimages2030528.png.jpg)图 17-10.
    ESP 被攻击字符串控制'
- en: Now we can just put `00AFFD48` into the return address, replace our *C*s with
    shellcode, and we will have a complete exploit, right? Close, but not quite. Unfortunately,
    if we just hardcode the address `00AFFD48` into our return address, the exploit
    may work just fine for us but not in other cases—and we want it to work as universally
    as possible. As we saw in [Chapter 16](ch16.xhtml "Chapter 16. A Stack-Based Buffer
    Overflow in Linux"), the locations of registers like ESP can change based on program
    factors such as the length of provided arguments or because the stack is tied
    to a thread, which means the stack address can differ the next time you attack
    the application. Lucky for us, jumping to a CPU register to execute its contents
    is denoted by the assembly language instruction `JMP ESP` (or another register
    name, as needed). In pre-ASLR operating systems, such as our Windows XP SP3 target,
    Windows DLLs were loaded into the same place in memory every time. That means
    if we find a `JMP ESP` inside an executable module on our Windows XP target, it
    should be in the same place on every Windows XP SP3 English-language machine.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将`00AFFD48`直接放入返回地址，替换我们的*C*为shellcode，这样我们就有了一个完整的漏洞利用，对吗？差不多，但还不完全正确。不幸的是，如果我们将地址`00AFFD48`硬编码到返回地址中，漏洞利用可能在我们这里能够正常工作，但在其他情况下却可能无法使用——而我们希望它尽可能普遍地工作。正如我们在[第
    16 章](ch16.xhtml "第 16 章. Linux 中的基于栈的缓冲区溢出")中看到的，像ESP这样的寄存器的位置可能会根据程序因素（如提供的参数的长度）发生变化，或者因为栈与线程相关联，这意味着下一次攻击时栈地址可能会不同。幸运的是，跳转到CPU寄存器以执行其内容的汇编语言指令是`JMP
    ESP`（或者根据需要使用其他寄存器名称）。在未启用ASLR的操作系统中，例如我们的Windows XP SP3目标，Windows DLLs每次都会加载到相同的内存位置。这意味着如果我们在Windows
    XP目标的可执行模块中找到`JMP ESP`，它应该在每台Windows XP SP3英文版机器上都在相同的位置。
- en: For that matter, `JMP ESP` is not our only option. As long as we end up with
    execution pointed to ESP, we can use an equivalent instruction to `JMP ESP` or
    even a series of instructions. For example, `CALL ESP` will work, or `PUSH ESP`
    followed by `RET`, which sends execution to the memory address in ESP.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`JMP ESP`并不是我们唯一的选择。只要我们最终能够将执行指向ESP，我们就可以使用与`JMP ESP`等价的指令，甚至可以使用一系列指令。例如，`CALL
    ESP`也可以工作，或者`PUSH ESP`后跟`RET`，这样就可以将执行转到ESP中的内存地址。
- en: We can find all the occurrences of `JMP ESP` and the logical equivalents in
    the executable modules for War-FTP with the command `!mona jmp -r esp`, as shown
    in [Figure 17-11](ch17.xhtml#searching_for_jmp_esp_with_mona "Figure 17-11. Searching
    for JMP ESP with Mona").
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过命令`!mona jmp -r esp`在War-FTP的可执行模块中找到所有`JMP ESP`及其逻辑等价物，如[图 17-11](ch17.xhtml#searching_for_jmp_esp_with_mona
    "图 17-11. 使用 Mona 查找 JMP ESP")所示。
- en: '![Searching for JMP ESP with Mona](httpatomoreillycomsourcenostarchimages2030530.png.jpg)Figure 17-11. Searching
    for `JMP ESP` with Mona'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用Mona查找JMP ESP](httpsatomoreillycomsourcenostarchimages2030530.png.jpg)图17-11.
    使用Mona查找`JMP ESP`'
- en: The results are written to *C:\logs\war-ftpd\jmp.txt*. We are presented with
    84 possible `JMP ESP` (or equivalent) instructions. Some may contain bad characters
    (as we’ll discuss later in the chapter)—which instructions should we choose? As
    a rule of thumb, go for modules that belong to the application itself and not
    to the operating system. If that is not possible, try relatively stable modules
    such *MSVCRT.dll* because very few changes have been made to this module in Windows
    patches compared with other Windows modules (although changes are still possible
    based on the language of the operating system). The `JMP ESP` instructions Mona
    found in *MSVCRT.dll* are shown next.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 结果写入到*C:\logs\war-ftpd\jmp.txt*。我们得到了84个可能的`JMP ESP`（或等效）指令。有些可能包含不良字符（如本章后面讨论的那样）——我们应该选择哪些指令呢？根据经验，优先选择属于应用程序本身的模块，而不是操作系统。如果这不可能，尝试选择相对稳定的模块，如*MSVCRT.dll*，因为与其他Windows模块相比，Windows补丁对该模块的更改非常少（尽管仍有可能根据操作系统的语言进行更改）。Mona在*MSVCRT.dll*中找到的`JMP
    ESP`指令如下所示。
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s use the first one: the `PUSH ESP` followed by a `RET` at `0x77C35459`.
    As in [Chapter 16](ch16.xhtml "Chapter 16. A Stack-Based Buffer Overflow in Linux"),
    we can set a breakpoint to pause execution when we reach our instructions to redirect
    execution to ESP and make sure everything is working correctly before we replace
    our *C*s with instructions to be executed. Set a breakpoint at the memory address
    `0x77C35459` with the command **`bp`** **`0x77C35459`** in Immunity Debugger,
    as shown in [Figure 17-12](ch17.xhtml#breakpoints_in_immunity_debugger "Figure 17-12. Breakpoints
    in Immunity Debugger"). (To view all currently set breakpoints, go to **View**
    ▸ **Breakpoints** in Immunity Debugger.)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用第一个：`PUSH ESP`，然后在`0x77C35459`处出现`RET`。如[第16章](ch16.xhtml "第16章. Linux中的基于栈的缓冲区溢出")所示，我们可以设置断点，在我们到达重定向执行到ESP的指令时暂停执行，并在替换*C*为待执行指令之前确保一切正常。使用命令**`bp`**
    **`0x77C35459`** 在免疫调试器中设置一个断点，如[图17-12](ch17.xhtml#breakpoints_in_immunity_debugger
    "图17-12. 免疫调试器中的断点")所示。（要查看所有当前设置的断点，请在免疫调试器中转到**视图** ▸ **断点**。）
- en: '![Breakpoints in Immunity Debugger](httpatomoreillycomsourcenostarchimages2030532.png.jpg)Figure 17-12. Breakpoints
    in Immunity Debugger'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![免疫调试器中的断点](httpsatomoreillycomsourcenostarchimages2030532.png.jpg)图17-12.
    免疫调试器中的断点'
- en: Now replace the four *B*s in your exploit string with the location of the redirection
    to ESP, as shown in [Example 17-5](ch17.xhtml#using_a_return_address_from_an_executabl
    "Example 17-5. Using a return address from an executable module").
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将攻击字符串中的四个*B*替换为指向ESP重定向位置的地址，如[示例17-5](ch17.xhtml#using_a_return_address_from_an_executabl
    "示例17-5. 使用来自可执行模块的返回地址")所示。
- en: Example 17-5. Using a return address from an executable module
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 示例17-5. 使用来自可执行模块的返回地址
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With a breakpoint prepared, let’s place our new return address at the right
    location in our attack string at ❶ and change the 611 *C*s to four *C*s followed
    by 607 *D*s to account for the four bytes of the attack string before ESP. Once
    the attack string is in place, run the exploit against War-FTP, and see if it
    reaches our breakpoint in Immunity Debugger, as shown in [Figure 17-13](ch17.xhtml#we_reached_our_breakpointdot
    "Figure 17-13. We reached our breakpoint.").
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好断点后，我们将新的返回地址放在攻击字符串的正确位置，位于❶处，并将611个*C*替换为四个*C*，然后是607个*D*，以补偿ESP前的攻击字符串的四个字节。将攻击字符串放置好后，针对War-FTP运行漏洞，看看是否能够在免疫调试器中达到我们的断点，如[图17-13](ch17.xhtml#we_reached_our_breakpointdot
    "图17-13. 我们达到了断点。")所示。
- en: '![We reached our breakpoint.](httpatomoreillycomsourcenostarchimages2030534.png.jpg)Figure 17-13. We
    reached our breakpoint.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![我们达到了断点。](httpsatomoreillycomsourcenostarchimages2030534.png.jpg)图17-13.
    我们达到了断点。'
- en: Perfect—notice in the bottom of the Immunity Debugger window that we hit our
    breakpoint.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 完美——注意到在免疫调试器窗口底部，我们击中了断点。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you forget to take endianness into account, you might not reach your breakpoint;
    instead, the program will crash with an access violation at `5954C377`. Be sure
    to flip the bytes around to little-endian format.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记考虑字节序，可能无法达到断点；相反，程序会在`5954C377`处因访问冲突而崩溃。确保将字节转换为小端格式。
- en: The next command to be executed is shown in the top left of the Immunity Debugger
    window in the CPU pane. Use F7 to execute one command at a time rather than have
    the program continue running normally. We press **F7** twice to execute the `PUSH
    ESP` and `RET` instructions, and, as expected, execution is redirected to the
    beginning of our *D*s (44 in hex), as shown in [Figure 17-14](ch17.xhtml#redirecting_execution_to_our_attack_stri
    "Figure 17-14. Redirecting execution to our attack string").
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的命令将在 Immunity Debugger 窗口的 CPU 面板左上方显示。使用 F7 一次执行一个命令，而不是让程序继续正常运行。我们按 **F7**
    两次来执行 `PUSH ESP` 和 `RET` 指令，并且如预期的那样，执行被重定向到我们的 *D*s（十六进制的 44），如[图 17-14](ch17.xhtml#redirecting_execution_to_our_attack_stri
    "图 17-14. 将执行重定向到我们的攻击字符串")所示。
- en: '![Redirecting execution to our attack string](httpatomoreillycomsourcenostarchimages2030536.png.jpg)Figure 17-14. Redirecting
    execution to our attack string'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![将执行重定向到我们的攻击字符串](httpatomoreillycomsourcenostarchimages2030536.png.jpg)图
    17-14. 将执行重定向到我们的攻击字符串'
- en: Getting a Shell
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取一个 Shell
- en: Now we just need to put something useful in place of the *D*s from the previous
    section for the CPU to execute on our behalf. In [Chapter 4](ch04.xhtml "Chapter 4. Using
    the Metasploit Framework"), we used the Metasploit tool Msfvenom to generate malicious
    executables. We can also use it to create raw shellcode to put in our handwritten
    exploits. For instance, we can tell our hijacked CPU to open a bind shell on TCP
    port 4444 (or any other port) by using Msfvenom to generate the shellcode for
    a Metasploit payload.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需将前一节中的 *D*s 替换成一些有用的内容，以便 CPU 代表我们执行。在[第4章](ch04.xhtml "第4章. 使用 Metasploit
    框架")中，我们使用 Metasploit 工具 Msfvenom 生成了恶意可执行文件。我们也可以使用它生成原始的 shellcode，放入我们手写的利用程序中。例如，我们可以告诉被劫持的
    CPU 在 TCP 端口 4444（或任何其他端口）上打开一个绑定 Shell，通过使用 Msfvenom 生成 Metasploit 负载的 shellcode。
- en: We need to tell Msfvenom the payload to use—in this case *windows/shell_bind_tcp*,
    the inline Windows command shell. We also need to provide it with the maximum
    size we can have for our shellcode.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要告诉 Msfvenom 使用哪种负载——在这个例子中是 *windows/shell_bind_tcp*，即内联 Windows 命令 Shell。我们还需要提供它能用于我们
    shellcode 的最大大小。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As you experiment with crashing War-FTP, you will notice that you can actually
    make the attack string slightly bigger, but things start to act strangely around
    1,150 characters. (We will see what this is all about in [Chapter 18](ch18.xhtml
    "Chapter 18. Structured Exception Handler Overwrites").) At 1,100 characters we
    are safe, and our exploit will work as expected each time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在你尝试崩溃 War-FTP 时，你会注意到实际上可以将攻击字符串稍微增大，但在大约 1,150 个字符时，事情开始变得异常。（我们将在[第18章](ch18.xhtml
    "第18章. 结构化异常处理程序覆盖")中看到这一点。）在 1,100 个字符时我们是安全的，并且我们的利用将按预期每次都能正常工作。
- en: Our current exploit string has 607 *D*s, so we have 607 bytes for our shellcode.
    Finally, we need to tell Msfvenom which special characters to avoid when creating
    the payload. In this case, we need to avoid the null byte (\x00), carriage return
    (\x0d), line feed (\x0a), and @ (\x40).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的利用字符串包含 607 个 *D*s，因此我们有 607 字节的空间用于我们的 shellcode。最后，我们需要告诉 Msfvenom 在创建负载时应避免哪些特殊字符。在这种情况下，我们需要避免空字节（\x00）、回车符（\x0d）、换行符（\x0a）和
    @（\x40）。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Finding bad characters is an advanced topic beyond the scope of this book,
    so just trust me that these are the right ones for this exploit. These bad characters
    make sense: The null byte terminates a string, carriage return and line feed denote
    a new line, and *@* will break the *user@server* syntax for an FTP login. For
    more information on this topic, check out my blog post “Finding Bad Characters
    with Immunity Debugger and Mona.py” (*[http://www.bulbsecurity.com/finding-bad-characters-with-immunity-debugger-and-mona-py/](http://www.bulbsecurity.com/finding-bad-characters-with-immunity-debugger-and-mona-py/)*).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 查找坏字符是一个高级主题，超出了本书的范围，所以请相信我，这些是适用于此利用的正确字符。这些坏字符是有原因的：空字节（null byte）终止字符串，回车符（carriage
    return）和换行符（line feed）表示新的一行，*＠* 将破坏 *user@server* 的 FTP 登录语法。欲了解更多信息，请查看我的博客文章“使用
    Immunity Debugger 和 Mona.py 查找坏字符”（*[http://www.bulbsecurity.com/finding-bad-characters-with-immunity-debugger-and-mona-py/](http://www.bulbsecurity.com/finding-bad-characters-with-immunity-debugger-and-mona-py/)*）。
- en: Feed this information into Msfvenom, as shown in [Example 17-6](ch17.xhtml#generating_shellcode_with_msfvenom
    "Example 17-6. Generating shellcode with Msfvenom").
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些信息输入到 Msfvenom 中，如[示例 17-6](ch17.xhtml#generating_shellcode_with_msfvenom
    "示例 17-6. 使用 Msfvenom 生成 shellcode")所示。
- en: Example 17-6. Generating shellcode with Msfvenom
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 17-6. 使用 Msfvenom 生成 shellcode
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Msfvenom generated our shellcode in 368 bytes, leaving us plenty of room to
    spare. Replace the *D*s in the exploit with the generated shellcode, as shown
    in [Example 17-7](ch17.xhtml#our_finished_exploit "Example 17-7. Our finished
    exploit").
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Msfvenom生成的shellcode大小为368字节，给我们留出了足够的空间。将漏洞利用中的*D*替换为生成的shellcode，如[示例17-7](ch17.xhtml#our_finished_exploit
    "示例17-7. 我们完成的漏洞利用")所示。
- en: Example 17-7. Our finished exploit
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 示例17-7. 我们完成的漏洞利用
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When you try running the exploit, something unexpected happens. Though we are
    still able to hit our breakpoint and redirect execution to our shellcode, War-FTP
    crashes before we receive our bind shell on port 4444\. Something in the shellcode
    is causing a crash, as shown in [Figure 17-15](ch17.xhtml#war-ftp_crashes "Figure 17-15. War-FTP
    crashes").
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试运行漏洞利用时，出现了意外的情况。虽然我们仍然能够命中断点并将执行重定向到我们的shellcode，但War-FTP在我们收到绑定到端口4444的shell之前崩溃了。shellcode中的某些部分导致了崩溃，详情见[图17-15](ch17.xhtml#war-ftp_crashes
    "图17-15. War-FTP崩溃")。
- en: '![War-FTP crashes](httpatomoreillycomsourcenostarchimages2030538.png.jpg)Figure 17-15. War-FTP
    crashes'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![War-FTP崩溃](httpatomoreillycomsourcenostarchimages2030538.png.jpg)图17-15.
    War-FTP崩溃'
- en: Msfvenom’s encoded shellcode needs to first decode itself before executing,
    and as part of the decoding process, it needs to find its location in memory using
    a routine called getPC. A common technique for finding the current location in
    memory includes using an instruction called `FSTENV`, which writes a structure
    onto the stack, overwriting what’s there—in our case part of the shellcode. All
    we need to do to fix this is move ESP away from the shellcode, so getPC has room
    to work without corrupting our shellcode. (The problem in general is that if the
    values in EIP and ESP are too close together, shellcode tends to corrupt itself,
    either during decoding or during execution.) This is what caused our crash in
    the previous run.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Msfvenom生成的编码shellcode在执行之前需要先解码，在解码过程中，它需要使用一个名为getPC的例程来找到自己在内存中的位置。查找当前内存位置的常用技术包括使用`FSTENV`指令，它将一个结构写入栈中，覆盖栈中的内容——在我们的情况下，部分shellcode就被覆盖了。我们需要做的就是将ESP从shellcode中移开，以便getPC有足够的空间执行，而不会破坏我们的shellcode。（一般来说，问题是如果EIP和ESP的值太接近，shellcode往往会自我破坏，无论是在解码过程中还是执行过程中。）这就是我们在上一次运行中崩溃的原因。
- en: We can use the Metasm utility to turn a simple assembly instruction into shellcode
    that we can drop into our exploit. We need to move ESP away from our shellcode
    in memory. We can do this using the assembly `ADD` instruction. The syntax is
    `ADD` *`destination, amount`*. Because our stack consumes lower memory addresses,
    let’s subtract 1,500 bytes from ESP. The number of bytes should be large enough
    to avoid corruption; 1,500 bytes is usually a safe choice.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Metasm工具将简单的汇编指令转换为可以插入漏洞利用中的shellcode。我们需要将ESP从内存中的shellcode位置移开。我们可以使用汇编指令`ADD`来完成此操作。其语法为`ADD`
    *`destination, amount`*。由于我们的栈使用较低的内存地址，因此我们从ESP中减去1,500字节。这个字节数应该足够大，以避免破坏；1,500字节通常是一个安全的选择。
- en: Change directories to */usr/share/metasploit-framework/tools* and start *metasm_shell.rb*,
    as shown in [Example 17-8](ch17.xhtml#generating_shellcode_with_metasm "Example 17-8. Generating
    shellcode with Metasm").
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 更改目录到*/usr/share/metasploit-framework/tools*并启动*metasm_shell.rb*，如[示例17-8](ch17.xhtml#generating_shellcode_with_metasm
    "示例17-8. 使用Metasm生成shellcode")所示。
- en: Example 17-8. Generating shellcode with Metasm
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 示例17-8. 使用Metasm生成shellcode
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we try **`sub esp, 1500`** ❶, the resulting shellcode includes null bytes,
    and, as discussed earlier, a null byte is a bad character that needs to be avoided
    due to the FTP specification. Instead, enter **`add esp, -1500`** ❷ (a logical
    equivalent) into the `metasm` prompt.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试**`sub esp, 1500`** ❶，生成的shellcode会包含null字节，正如之前讨论的，null字节是需要避免的坏字符，因为FTP规范要求避免使用它。相反，在`metasm`提示符中输入**`add
    esp, -1500`** ❷（一个逻辑等价操作）。
- en: Now add the resulting shellcode to the exploit right before the *windows/shell_bind_tcp*
    shellcode, as shown in [Example 17-9](ch17.xhtml#exploit_with_esp_moved_out_of_the_way
    "Example 17-9. Exploit with ESP moved out of the way").
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将生成的shellcode添加到漏洞利用中，放置在*windows/shell_bind_tcp* shellcode之前，如[示例17-9](ch17.xhtml#exploit_with_esp_moved_out_of_the_way
    "示例17-9. 将ESP移开后的漏洞利用")所示。
- en: Example 17-9. Exploit with ESP moved out of the way
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 示例17-9. 将ESP移开后的漏洞利用
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With ESP out of the way, and knowing that our shellcode won’t be corrupted in
    the process of being decoded or executed, run the exploit again and use Netcat
    on Kali Linux to connect to TCP port 4444 on the Windows target, as shown here.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将ESP移开后，并且确保我们的shellcode在解码或执行过程中不会被破坏，再次运行漏洞利用，并使用Kali Linux上的Netcat连接到Windows目标的TCP端口4444，如下所示。
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Sure enough, we now have a shell on the Windows target, as shown by the Windows
    command prompt above.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，我们现在在 Windows 目标上拥有了一个 shell，如上面所示的 Windows 命令提示符所示。
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter we used our knowledge from [Chapter 16](ch16.xhtml "Chapter 16. A
    Stack-Based Buffer Overflow in Linux") to exploit a real-world vulnerable program:
    the War-FTP program with a buffer overflow issue in the Username field. We crashed
    the program and located the return address, and then, instead of hardcoding a
    memory address for the overwritten return address, we found a `JMP ESP` instruction
    in a loaded DLL. We then filled the attacker-controlled ESP register with shellcode
    generated by Msfvenom. Now we’ve managed to hijack control of a real program.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们运用了来自[第16章](ch16.xhtml "第16章：Linux中的基于栈的缓冲区溢出")的知识，利用一个真实世界中的易受攻击程序：War-FTP
    程序，该程序在用户名字段存在缓冲区溢出问题。我们使程序崩溃并定位了返回地址，然后，我们并没有为被覆盖的返回地址硬编码一个内存地址，而是找到了一个在加载的 DLL
    中的`JMP ESP`指令。接着，我们用 Msfvenom 生成的 shellcode 填充了攻击者控制的 ESP 寄存器。现在，我们已经成功劫持了一个真实程序的控制。
- en: In the next chapter, we will look at another Windows exploitation technique,
    structured exception handler overwrites.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究另一种 Windows 利用技术——结构化异常处理程序覆盖。
