- en: '15'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '15'
- en: USING FIREFLY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 FIREFLY
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common01.jpg)'
- en: '[Chapter 14](ch14.xhtml#ch14) introduced us to Firefly. Now let’s see what
    we can make it do. First, we’ll walk through the environment for building and
    testing Firefly programs. Then, we’ll look at five examples that put Firefly to
    the test. For the first test, we’ll make the firefly count (“Fly Time”). After
    that, we’ll simulate a 1960s sci-fi computer display (“Space Trek”). Then, we’ll
    go high-brow and play some classical music (“Beethoven in Lights”). We’ll even
    experiment with animation effects (“Dance Dance”) and end with something useful,
    a tea timer (“Tea Time”). We’ll conclude the chapter with a discussion of Firefly
    as a programming language.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 14 章](ch14.xhtml#ch14)向我们介绍了 Firefly。现在让我们看看它能做什么。首先，我们将介绍构建和测试 Firefly
    程序的环境。然后，我们将看五个例子来测试 Firefly。第一个测试是让萤火虫计数（“飞行时间”）。接着，我们将模拟 1960 年代的科幻计算机显示（“太空漫游”）。然后，我们将更高雅一些，播放一些经典音乐（“灯光中的贝多芬”）。我们甚至会尝试动画效果（“舞蹈舞蹈”），最后做一些有用的事，设置一个茶水计时器（“茶时光”）。本章将以讨论
    Firefly 作为编程语言结束。'
- en: '**The Process**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**流程**'
- en: 'There are two versions of the Firefly interpreter: one for the console and
    one for the micro:bit. [Chapter 14](ch14.xhtml#ch14) presented the micro:bit version.
    In this section, we’ll walk through developing Firefly programs, testing with
    the console interpreter, debugging via execution tracing, and deploying code on
    the micro:bit. The last step is optional for all the examples in the chapter,
    should you not have a micro:bit handy. However, you won’t hear the firefly sing.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Firefly 解释器有两个版本：一个是控制台版，一个是 micro:bit 版。[第 14 章](ch14.xhtml#ch14)介绍了 micro:bit
    版本。在本节中，我们将演示开发 Firefly 程序、使用控制台解释器进行测试、通过执行追踪调试，并将代码部署到 micro:bit 上。最后一步对于本章的所有示例都是可选的，如果你没有
    micro:bit 也可以跳过。不过，这样你就听不到萤火虫的歌声了。
- en: The process involves the sequence of steps listed next. Steps 4, 5, and 6 are
    specific to the micro:bit, so console-only users should stop after Step 3.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程包括以下列出的步骤。步骤 4、5 和 6 是特定于 micro:bit 的，因此仅使用控制台的用户应在步骤 3 后停止。
- en: Write Firefly code, including comments and whitespace, in a text editor.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中编写 Firefly 代码，包括注释和空白。
- en: Run the code with the console interpreter, *firefly.py*.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用控制台解释器 *firefly.py* 运行代码。
- en: Optionally debug the code with execution tracing.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，通过执行追踪调试代码。
- en: Package the debugged program using *fly_dump.py*.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *fly_dump.py* 打包调试过的程序。
- en: Build a micro:bit runtime to bundle the compacted Firefly code with the micro:bit
    interpreter, *firefly_micro.py*.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个 micro:bit 运行时，将压缩的 Firefly 代码与 micro:bit 解释器 *firefly_micro.py* 打包在一起。
- en: Transfer the bundled runtime to the micro:bit using the *[microbit.org](http://microbit.org)*
    Python editor, [https://python.microbit.org/v/2/](https://python.microbit.org/v/2/).
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *[microbit.org](http://microbit.org)* Python 编辑器将打包的运行时传输到 micro:bit，[https://python.microbit.org/v/2/](https://python.microbit.org/v/2/)。
- en: If you plan on using a micro:bit, we’ll be using the online Python editor at
    *[https://python.microbit.org/v/2](https://python.microbit.org/v/2)*. It works
    best with Windows. I used the Microsoft Edge browser and had no trouble at all.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划使用 micro:bit，我们将使用在线 Python 编辑器 *[https://python.microbit.org/v/2](https://python.microbit.org/v/2)*。它在
    Windows 上表现最佳。我使用了 Microsoft Edge 浏览器，并且没有遇到任何问题。
- en: To work with the micro:bit on Linux, I had some success with the Mu editor when
    using a version 1 micro:bit and the 1.0.2 version of Mu. With later versions of
    the editor and a version 2 micro:bit, I was only able to get stable functionality
    from Ubuntu 18.04 when running the editor directly from the GitHub repo at *[https://github.com/mu-editor/mu/](https://github.com/mu-editor/mu/)*.
    Your mileage may vary.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上使用 micro:bit 时，我在使用版本 1 的 micro:bit 和 Mu 编辑器 1.0.2 版本时取得了一些成功。在编辑器的后续版本和版本
    2 的 micro:bit 上，只有在直接从 GitHub 仓库运行编辑器（[https://github.com/mu-editor/mu/](https://github.com/mu-editor/mu/)）时，才能在
    Ubuntu 18.04 上获得稳定的功能。你的情况可能有所不同。
- en: '[Figure 15-1](ch15.xhtml#ch015fig1) shows the Python editor running on Windows
    in the Microsoft Edge browser.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-1](ch15.xhtml#ch015fig1) 显示了在 Microsoft Edge 浏览器中运行的 Windows 上的 Python
    编辑器。'
- en: '![Image](Images/15fig01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/15fig01.jpg)'
- en: '*Figure 15-1: The Python editor for micro:bit*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-1：micro:bit 的 Python 编辑器*'
- en: Note that the book’s GitHub site contains short videos showing the code running
    on a micro:bit. Please take a look, especially if you do not intend to use the
    micro:bit yourself.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本书的 GitHub 网站包含了展示代码在 micro:bit 上运行的短视频。请查看，特别是如果你不打算亲自使用 micro:bit 的话。
- en: '***Writing Firefly Code***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写 Firefly 代码***'
- en: Our first example is the Firefly equivalent of “Hello, world!” The program draws
    the letters `HI` on the screen. The source code is in *hi.fly* in the *firefly/
    console/examples* directory (see [Listing 15-1](ch15.xhtml#ch015list1)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个示例是萤火虫版的 “Hello, world!” 程序，它在屏幕上绘制字母 `HI`。源代码位于 *hi.fly* 文件中，路径是 *firefly/console/examples*
    目录（见 [Listing 15-1](ch15.xhtml#ch015list1)）。
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 15-1: “Hello, world!” in Firefly*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 15-1: Firefly 中的 “Hello, world!”*'
- en: The first line of *hi.fly* ensures move mode (no trail) and moves the firefly
    from its initial (2,2) position to the upper-left corner, (0,0). The mode is then
    set to intensity 5.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*hi.fly* 的第一行确保了移动模式（无轨迹），并将萤火虫从初始位置 (2,2) 移动到左上角 (0,0)。然后，模式设置为强度 5。'
- en: The next line moves south three spaces to draw the left side of the H. At this
    point, the firefly is at position (3,0), so switching to move mode and going north
    twice puts the firefly at (1,0). Setting the mode to 5 and moving east three times
    draws the crossbar of the H. The next two lines finish the H and `MEEN` moves
    to (2,4). From (2,4), setting the mode to 5 and moving north three times draws
    the I, ending with the firefly at position (4,4). The `L` instruction loops forever
    to preserve the “HI” display on the micro:bit.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行将萤火虫向南移动三个位置，绘制字母 H 的左侧。此时，萤火虫位于 (3,0) 位置，因此切换到移动模式并向北移动两次，将萤火虫移至 (1,0) 位置。将模式设置为
    5，并向东移动三次绘制字母 H 的横杆。接下来的两行完成了字母 H 的绘制，`MEEN` 将移动到 (2,4)。从 (2,4) 开始，设置模式为 5 并向北移动三次，绘制字母
    I，最终萤火虫位于 (4,4) 位置。`L` 指令会永远循环，以保持 “HI” 显示在 micro:bit 上。
- en: '***Using the Console Interpreter***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用控制台解释器***'
- en: To execute [Listing 15-1](ch15.xhtml#ch015list1), we need the console interpreter.
    Run the code with
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行 [Listing 15-1](ch15.xhtml#ch015list1)，我们需要控制台解释器。运行以下代码：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: to produce
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以生成
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The 5×5 display is indented four spaces and one space is printed between each
    digit. By default, *firefly.py* shows 0 intensity as a space. Adding the `-z`
    command line option shows 0 intensity as 0s
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 5×5 显示框缩进了四个空格，每个数字之间有一个空格。默认情况下，*firefly.py* 将 0 强度显示为空格。添加 `-z` 命令行选项后，0 强度将显示为
    0。
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: where we now see the full 5×5 grid.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到完整的 5×5 网格。
- en: 'Next, step through *hi.fly* by adding the `-t` (trace) command line option:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过添加 `-t`（跟踪）命令行选项，逐步执行 *hi.fly*：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In trace mode, an instruction is executed and the display is updated; then,
    before execution of the next instruction, the interpreter shows a status line
    and waits for the user to press ENTER or Q to quit the program. For example, running
    *hi.fly* in trace mode presents us with
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在跟踪模式下，一条指令被执行并且显示更新；然后，在执行下一条指令之前，解释器会显示状态行，并等待用户按下 ENTER 键或 Q 键退出程序。例如，在跟踪模式下运行*hi.fly*，我们会看到
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'which tells us that the last instruction executed was `M` (set move mode).
    This is the `INST` part of the status line. The rest of the status line is described
    as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉我们，最后执行的指令是 `M`（设置移动模式）。这是状态行中的 `INST` 部分。状态行的其余部分如下所述：
- en: '| **Instruction** | **Explanation** |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **解释** |'
- en: '| --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `I=(2,2)(12)` | The firefly is at (2,2) (index 12) |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `I=(2,2)(12)` | 萤火虫位于 (2,2) 位置（索引 12） |'
- en: '| `SHOW=A` | Grid A is currently visible |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `SHOW=A` | 当前显示的是网格 A |'
- en: '| `DRAW=A` | Grid A is currently drawn to |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `DRAW=A` | 当前绘制的是网格 A |'
- en: '| `M=M` | Move mode is “M” |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `M=M` | 移动模式是 “M” |'
- en: The index is into the `bytearray` of the currently active memory grid.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 索引指向当前活动内存网格的 `bytearray`。
- en: Pressing ENTER moves us to
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 ENTER 键将我们带到
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: which informs us that the firefly is now at position (1, 2) (index 7) because
    a “move north” instruction was executed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉我们，萤火虫当前位于 (1, 2) 位置（索引 7），因为执行了一个 “向北移动” 指令。
- en: Continuing to press ENTER traces through the entire program.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 持续按下 ENTER 键会跟踪整个程序的执行过程。
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We continue to the `L` instruction, which throws us into an infinite loop. Use
    CTRL-C to exit the loop.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续到 `L` 指令，它将我们带入一个无限循环。使用 CTRL-C 来退出循环。
- en: We have a working program. Let’s now bundle it to run on the micro:bit.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了一个可以运行的程序。现在让我们将它打包以便在 micro:bit 上运行。
- en: '***Packing a Bundle***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***打包程序包***'
- en: We can’t use *hi.fly* as-is with the micro:bit version of Firefly because we
    first need to strip the comments and whitespace. We could do this manually, but
    why bother when we already have a utility to do it for us? In the same `console`
    directory as *firefly.py* is *fly_dump.py*. Let’s run it to get a single-string
    version of *hi.fly*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能直接使用 *hi.fly* 文件与 micro:bit 版本的 Firefly，因为我们需要首先去除注释和空白。我们可以手动去除这些内容，但为什么要麻烦自己呢？我们已经有了一个工具来帮助我们。与
    *firefly.py* 位于同一 `console` 目录下的是 *fly_dump.py*。让我们运行它，以获取 *hi.fly* 的单行版本。
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first argument is the console version of the code with comments and whitespace.
    The second is the output, which in this case is sent to the *examples* directory
    of the micro:bit version in *micro*. The output generated is
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是带有注释和空格的代码的控制台版本。第二个是输出，在这种情况下，输出被发送到*micro*中 micro:bit 版本的*examples*目录。生成的输出为
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This version of the code still runs in the console interpreter. Give it a try
    and see for yourself.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的代码仍然在控制台解释器中运行。试试看，亲自体验一下。
- en: 'To make the micro:bit bundle, we’ll need to complete the following steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作 micro:bit 捆绑包，我们需要完成以下步骤：
- en: Copy *firefly_micro.py* to *hi.py*.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*firefly_micro.py*复制到*hi.py*。
- en: Edit *hi.py* and update *PRG* to be the text in *micro/examples/hi.fly*.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑*hi.py*并将*PRG*更新为*micro/examples/hi.fly*中的文本。
- en: Run the Python editor and load *hi.py*.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Python 编辑器并加载*hi.py*。
- en: Attach the micro:bit via USB.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 USB 连接 micro:bit。
- en: Program the micro:bit from the online Python editor.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从在线 Python 编辑器对 micro:bit 进行编程。
- en: Steps 1 and 2 mean that bundles are copies of the micro:bit version of the interpreter
    edited to contain the compacted Firefly code. The default *firefly_micro.py* file
    begins with
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 1 和步骤 2 表示这些捆绑包是编辑过的 micro:bit 版本的解释器副本，包含了压缩后的 Firefly 代码。默认的*firefly_micro.py*
    文件开始于
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: which becomes
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 它变成了
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This embeds the code in *hi.py*. The remainder of *hi.py* is the same as the
    interpreter code of [Chapter 15](ch15.xhtml#ch15).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将代码嵌入到*hi.py*中。*hi.py* 的其余部分与[第 15 章](ch15.xhtml#ch15)的解释器代码相同。
- en: To program the micro:bit, first run the editor in Microsoft Edge by opening
    *[https://python.microbit.org/v/2/](https://python.microbit.org/v/2/)*. Then,
    connect the micro:bit’s Micro-USB port to the computer’s USB port. The micro:bit
    will likely automount. If so, just close any Explorer window that opens.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要编程 micro:bit，首先在 Microsoft Edge 中运行编辑器，打开 *[https://python.microbit.org/v/2/](https://python.microbit.org/v/2/)*。然后，将
    micro:bit 的 Micro-USB 端口连接到计算机的 USB 端口。micro:bit 可能会自动挂载。如果是这样，只需关闭任何打开的资源管理器窗口。
- en: Next, connect to the micro:bit by clicking **Connect** and selecting the micro:bit
    from the resulting dialog. The micro:bit is present and working if you see a string
    similar to “‘BBC micro:bit CMSIS-DAP’ – Paired.” Select the micro:bit and click
    **Connect**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过点击**连接**并从弹出的对话框中选择 micro:bit 来连接到 micro:bit。如果看到类似于 “‘BBC micro:bit CMSIS-DAP’
    – 已配对” 的字符串，说明 micro:bit 已连接并正常工作。选择 micro:bit 并点击**连接**。
- en: Next, open *hi.py* by clicking **Load/Save** followed by **Download** to program
    the micro:bit. Programming takes a few seconds. When complete, the program starts
    immediately producing [Figure 15-2](ch15.xhtml#ch015fig2).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过点击**加载/保存**然后点击**下载**来打开*hi.py*，以便对 micro:bit 进行编程。编程只需几秒钟。当完成时，程序会立即开始运行，并生成[图
    15-2](ch15.xhtml#ch015fig2)。
- en: '![Image](Images/15fig02.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/15fig02.jpg)'
- en: '*Figure 15-2: “Hello, world!” micro:bit style*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-2：“你好，世界！” micro:bit 风格*'
- en: Did you notice something when the program ran? Rerun it by pressing the reset
    button beneath the micro:bit.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，你注意到什么了吗？按下 micro:bit 下方的重置按钮重新运行它。
- en: If you are using a version 1 micro:bit, you’ll see the message draw on the screen
    from left to right. The *hi.fly* program moves the firefly on grid A while showing
    grid A, so we see each instruction’s effect. Later in the chapter, we’ll adjust
    *hi.fly* to use double buffering (see “Space Trek” below).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是版本 1 的 micro:bit，你会看到消息从左到右在屏幕上绘制。*hi.fly* 程序在网格 A 上移动萤火虫并显示网格 A，因此我们可以看到每个指令的效果。在本章后面，我们将调整*hi.fly*，使用双缓冲（请参见下面的“太空旅行”）。
- en: 'The remainder of this chapter walks through each example’s code, running it
    on the console when applicable and then running the code on the micro:bit. In
    each case, program the micro:bit as we did here: use *fly_dump.py* to strip comments
    and whitespace, paste the compacted Firefly program text into a suitably renamed
    copy of *firefly_micro.py*, and load the copy onto the micro:bit via the Python
    editor. Don’t forget to take a look at the micro:bit videos on the book’s GitHub
    site as well.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 本章其余部分介绍了每个示例的代码，并在适用时在控制台上运行，然后在 micro:bit 上运行该代码。在每种情况下，我们都按照这里的方式对 micro:bit
    进行编程：使用*fly_dump.py* 去掉注释和空格，将压缩后的 Firefly 程序文本粘贴到适当重命名的*firefly_micro.py*副本中，并通过
    Python 编辑器将副本加载到 micro:bit 上。别忘了查看本书 GitHub 网站上的 micro:bit 视频。
- en: Let’s put our firefly to work.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让我们的萤火虫开始工作。
- en: '**Fly Time**'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**飞行时间**'
- en: The `P` instruction pauses the program for 0.1 seconds. Therefore, `PPPPPPPPPP`
    pauses the program for one second. Let’s use this as the basis for a counter/
    timer. Our goal is a Firefly program that counts seconds, up to 1,000, before
    rolling over and starting again. Firefly lacks any looping mechanism other than
    starting a program from the beginning after it ends; therefore, we need to design
    our program so that looping from the beginning starts the counter again from 0.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`P` 指令使程序暂停 0.1 秒。因此，`PPPPPPPPPP` 会让程序暂停一秒。我们以此为基础，设计一个计数器/计时器。我们的目标是编写一个 Firefly
    程序，该程序能计数秒数，最多达到 1,000 秒，然后重新开始计数。Firefly 除了在程序结束后从头开始运行外，并没有其他的循环机制；因此，我们需要设计程序，使得每次从头开始时，计数器能重新从
    0 开始。'
- en: If 10 `P` instructions give a one-second pause, then `PPPPPPPPPPT` pauses for
    one second before “moving” the firefly by remaining in place. If the mode is `I`
    (increment), the net effect is a one-second pause before incrementing the current
    firefly position. Repeat the one-second pause 10 times with `T` after each pause,
    and we have a 10-second timer.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 10 个 `P` 指令可以暂停一秒，那么 `PPPPPPPPPPT` 会先暂停一秒，然后通过保持当前位置“移动” Firefly。如果模式是 `I`（增量），则其效果是暂停一秒后递增当前
    Firefly 位置。重复这种一秒暂停 10 次，每次暂停后执行 `T`，就得到了一个 10 秒的计时器。
- en: To count, we increment the ones digit until it rolls over back to 0 and then
    increment the tens digit by 1\. We can use this approach with the one-second timer
    to build a two-digit timer by moving from the current firefly position, the ones
    position, over to the left and incrementing, and then moving back and repeating
    for another 10 seconds.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计数，我们增加个位数字，直到其回绕到 0，然后将十位数字加 1。我们可以使用这种方法，通过一秒的计时器，构建一个两位数的计时器，方法是从当前的 Firefly
    位置——个位数位置——向左移动并递增，然后再返回并重复此过程，持续 10 秒。
- en: This thought suggests a set of repeated instructions. The program begins with
    the firefly at position (2,2). Let’s use position (0,4) for the ones and position
    (0,3) for the tens. Consider the sequence of instructions shown in [Listing 15-2](ch15.xhtml#ch015list2).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个思路提示了一组重复的指令。程序从 Firefly 位置 (2,2) 开始。我们将位置 (0,4) 用作个位数位置，将位置 (0,3) 用作十位数位置。请参考
    [Listing 15-2](ch15.xhtml#ch015list2) 中显示的指令序列。
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 15-2: A 10-second timer*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 15-2: 一个 10 秒计时器*'
- en: The first line moves the firefly from (2,2) to (0,4), which is the ones position.
    The second line sets the mode to increment. Next comes a one-second delay followed
    by a “tick” to increment the ones position. Nine more one-second delays finish
    the 10-second delay, and the ones position has moved from 0 up through 9 and back
    to 0.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将 Firefly 从 (2,2) 移动到 (0,4)，即个位数位置。第二行设置增量模式。接下来是一个一秒的延迟，然后是一次“滴答”递增个位数位置。再接着是九次一秒的延迟，完成了
    10 秒的延迟，个位数位置从 0 数到 9 然后回到 0。
- en: 'The line `MWIT` moves one position to the left, to (0,3), and increments the
    tens position by 1\. Let’s break the steps down: `M` sets move mode (no trail),
    `W` moves left one position, `I` sets increment mode, and `T` increments position
    (0,3). The block of steps ends with `MEI` to move back to (0,4), the ones position,
    which is currently 0 because it rolled over, followed by `I` to reassert increment
    mode.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`MWIT` 这一行将位置从 (0,4) 向左移动一格，至 (0,3)，并将十位数位置增加 1。我们来分解一下这些步骤：`M` 设置为移动模式（没有尾迹），`W`
    向左移动一格，`I` 设置为增量模式，`T` 使位置 (0,3) 递增。该步骤块以 `MEI` 结束，将 Firefly 移回到个位数位置 (0,4)，该位置当前为
    0，因为它已经回绕过，接着通过 `I` 重新设置增量模式。'
- en: '[Listing 15-2](ch15.xhtml#ch015list2) counts for 10 seconds. If [Listing 15-2](ch15.xhtml#ch015list2)
    is repeated nine more times, except for the top two lines, `NNEE` and `I`, which
    set up the initial firefly position and mode, we’ll have a 100-second timer.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 15-2](ch15.xhtml#ch015list2) 用于计时 10 秒。如果将 [Listing 15-2](ch15.xhtml#ch015list2)
    重复九次，除了前两行 `NNEE` 和 `I`（用于设置初始 Firefly 位置和模式），我们就得到了一个 100 秒的计时器。'
- en: The file *fly_time.fly* in *console/examples* contains the code we need. Most
    of the code is repeated blocks like [Listing 15-2](ch15.xhtml#ch015list2). However,
    the 10th block ends with [Listing 15-3](ch15.xhtml#ch015list3).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 *fly_time.fly* 位于 *console/examples* 中，包含我们需要的代码。大部分代码是像 [Listing 15-2](ch15.xhtml#ch015list2)
    中那样的重复块。然而，第 10 个块以 [Listing 15-3](ch15.xhtml#ch015list3) 结束。
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 15-3: End of the 10th timer block*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 15-3: 第 10 个计时块结束*'
- en: The last one-second pause and an increment happens, followed by `MWIT` to move
    from (0,4) to (0,3) and increment the tens value. As this is the 10th block, the
    tens value has rolled over from 9 back to 0\. So a second `MWIT` moves from (0,3)
    to (0,2), the hundreds position, and increments it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后进行一秒的暂停和递增，然后通过`MWIT`指令将位置从（0,4）移动到（0,3），并递增十位数值。由于这是第10个块，十位数值已经从9回滚到0。因此，第二个`MWIT`将位置从（0,3）移动到（0,2），百位，并递增该位置。
- en: This last step completes a counter from 0 to 100\. If the firefly moves back
    to (0,4) and the program loops by starting over, the display will still read `1
    0 0`. The final line is `MEEI` to move back to (0,4) and set increment mode. As
    there is no `H` or `L` instruction, the program begins again.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一步完成了从0到100的计数。如果萤火虫移动回（0,4）并且程序通过重新开始来循环，显示仍然会是`1 0 0`。最后一行是`MEEI`，将位置移回（0,4）并设置增量模式。由于没有`H`或`L`指令，程序重新开始。
- en: Note that when the program loops, the display memory is preserved, but the firefly
    is warped back to its initial position of (2,2). However, this is what we want.
    The first instructions in *fly_time.fly* tell the firefly to move to (0,4), which
    is just where we need it to be to count another 100 seconds.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当程序循环时，显示内存被保留，但萤火虫会被扭曲回其初始位置（2,2）。然而，这正是我们希望的效果。*fly_time.fly*中的第一条指令告诉萤火虫移动到（0,4），这是我们需要它的位置，以便再计时100秒。
- en: The hundreds position, (0,2), is incremented again after another 100 seconds,
    leaving the display at `2 0 0`. Another 100 seconds later, the display is `3 0
    0`. This continues to 1,000 seconds, after which the display rolls over to all
    0s. We don’t increment the thousands position, but the program continues to loop
    until we hit CTRL-C, so the 1,000-second counter begins again, over and over.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 百位位置（0,2）在经过另一个100秒后再次递增，显示为`2 0 0`。再过100秒，显示为`3 0 0`。这种方式持续到1000秒，之后显示会回滚为全0。我们不会递增千位位置，但程序会继续循环，直到按下CTRL-C，因此1000秒的计数器将重新开始，不断循环。
- en: Run *fly_time.fly* with the console interpreter using `-z` to show 0 memory
    as 0s.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用控制台解释器运行*fly_time.fly*并使用`-z`选项，将0内存显示为0。
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The program counts until you hit CTRL-C. By starting the program at the beginning
    of an interval, and using CTRL-C to stop the program at the end of an interval,
    we have a primitive stopwatch—geeky to be sure, but functional.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会一直计数，直到你按下CTRL-C。通过在一个区间的开始启动程序，并在区间结束时使用CTRL-C停止程序，我们就得到了一个原始的秒表——虽然很极客，但功能完备。
- en: 'This example makes use of the only looping available to Firefly: restarting
    the program. It is naturally designed for the console so we can read the time
    directly as a number, but nothing stops you from running this code on the micro:bit.
    If you do, you’ll see sequences of increasingly bright LEDs. If you are like me,
    you’ll see the LEDs change and understand that the program is counting up, but
    not be able to reliably tell the difference between an LED that is at, say, brightness
    3 versus one at brightness 4.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子利用了Firefly唯一的循环方式：重启程序。它自然是为控制台设计的，因此我们可以直接读取时间作为数字，但没有什么能阻止你将此代码运行在micro:bit上。如果你这么做，你会看到LED逐渐变亮的序列。如果你像我一样，你会看到LED变化并理解程序在递增，但却无法可靠地区分亮度为3的LED和亮度为4的LED之间的差异。
- en: Of course, *fly_time.fly* is counting in base-10; however, there is no reason
    why other bases couldn’t be used. If we used binary, then the micro:bit would
    work nicely. Or perhaps we could use base-3, with LED intensities of 0, 5, and
    9 to make the distinction between digits clear. Changing the base changes the
    repeated code block used, but the general idea remains the same. Instead of ones
    (10⁰), tens (10¹), and hundreds positions (10²), we would use ones (3⁰), threes
    (3¹), nines (3²), and possibly twenty-sevens positions (3³).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，*fly_time.fly*是以十进制计数的；然而，没有理由不能使用其他进制。如果我们使用二进制，那么micro:bit会很好地工作。或者，我们也可以使用三进制，用0、5和9的LED强度来区分不同的数字。更改进制会改变所使用的重复代码块，但总体思路保持不变。我们将不再使用十位（10⁰）、十位（10¹）和百位（10²），而是使用个位（3⁰）、三位（3¹）、九位（3²）以及可能的二十七位（3³）。
- en: We’ll implement a different sort of timer later in the chapter, but for now,
    let’s learn how to use Firefly’s double buffering for animations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面实现另一种类型的计时器，但现在，让我们学习如何使用Firefly的双重缓冲进行动画。
- en: '**Space Trek**'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**太空旅行**'
- en: We’ve mentioned Firefly’s double buffering several times now. Let’s see it in
    action. The examples in this section work best on the micro:bit. Depending on
    your machine’s speed, you might see some effect when using the console interpreter;
    however, it’s most noticeable on the micro:bit.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次提到萤火虫的双重缓冲了。现在让我们看看它的实际效果。本节中的示例在 micro:bit 上效果最好。根据机器的速度，使用控制台解释器时你可能会看到一些效果；然而，在
    micro:bit 上它最为明显。
- en: Earlier in the chapter, we played around with *hi.fly* and commented that since
    we are showing grid A while drawing on grid A, we see the letters as they’re drawn.
    A simple modification uses double buffering to present the letters to us only
    after being drawn. The code we need is in *hi2.fly* under *console/examples*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早些时候，我们玩了 *hi.fly* 并评论过，因为我们在绘制 A 网格时展示了 A 网格，所以我们可以看到字母在绘制时的样子。一个简单的修改使用双重缓冲，在字母被绘制完毕后才将其展示给我们。我们需要的代码在
    *hi2.fly* 文件中，位于 *console/examples* 目录下。
- en: '[Listing 15-4](ch15.xhtml#ch015list4) presents the updated code. The only difference
    between [Listing 15-4](ch15.xhtml#ch015list4) and [Listing 15-1](ch15.xhtml#ch015list1)
    is the first line, `Y`, and the second-to-last line, `X`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 15-4](ch15.xhtml#ch015list4) 展示了更新后的代码。 [列表 15-4](ch15.xhtml#ch015list4)
    和 [列表 15-1](ch15.xhtml#ch015list1) 之间唯一的区别是第一行的 `Y` 和倒数第二行的 `X`。'
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 15-4: “HI” with double buffering*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-4：“HI”与双重缓冲*'
- en: We show grid A and draw to it. Executing `Y` shows grid B, which is empty, while
    still drawing to grid A. The letters are drawn as before, but the user does not
    see it because grid B is shown. When the letters are finished, `X` shows grid
    A again, and `L` enters the loop to preserve the micro:bit display.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示 A 网格并对其进行绘制。执行 `Y` 显示 B 网格，B 网格是空的，同时继续绘制 A 网格。字母像以前一样被绘制，但用户看不见它，因为显示的是
    B 网格。当字母绘制完成后，`X` 再次显示 A 网格，`L` 进入循环以保持 micro:bit 显示的内容。
- en: Bundle *hi2.fly* and load it on the micro:bit. When it runs, instead of watching
    the letters draw, you’ll see nothing until the complete word `HI` suddenly appears.
    If you run *hi2.fly* in the console using the `-t` option, you’ll notice `HI`
    suddenly appear as well.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *hi2.fly* 打包并加载到 micro:bit 上。当它运行时，你将不会看到字母被逐个绘制，直到完整的单词 `HI` 突然出现。如果你在控制台中使用
    `-t` 选项运行 *hi2.fly*，你也会注意到 `HI` 会突然出现。
- en: '[Listing 15-4](ch15.xhtml#ch015list4) is a bare-minimum example of double buffering.
    The core concept of double buffering is to show grid B while updating grid A and
    then switch and show grid A while updating grid B. We repeat this as necessary
    so that the user never views a grid as it is being drawn.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 15-4](ch15.xhtml#ch015list4) 是一个双重缓冲的最小示例。双重缓冲的核心概念是：在更新 A 网格时展示 B 网格，然后切换并展示
    A 网格，在更新 B 网格时如此反复。我们根据需要重复此过程，以确保用户在网格绘制时永远看不到它。'
- en: Let’s see a slightly more interesting example where we simulate the random “computer”
    displays often seen in the background of 1960s sci-fi shows. First, we’ll generate
    the display live, without double buffering. Then we’ll change the code to use
    double buffering. The difference between the two is visibly clear; however, to
    be honest, both approaches are pretty cool to watch.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个稍微有趣一点的示例，在这里我们模拟了1960年代科幻剧集中常见的随机“计算机”显示。首先，我们将生成没有双重缓冲的实时显示。然后，我们会修改代码，使用双重缓冲。这两者之间的差异显而易见；不过，老实说，两种方法看起来都很酷。
- en: '[Listing 15-5](ch15.xhtml#ch015list5) generates random displays without double
    buffering.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 15-5](ch15.xhtml#ch015list5) 生成没有双重缓冲的随机显示。'
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 15-5: Random computer lights*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-5：随机计算机灯光*'
- en: The first line moves to (0,0), the upper-left corner of the display. Recall
    that not only does the firefly start at position (2,2), it also starts in “move”
    mode (`M`) so there is no trail. The second line sets the mode to “random” (`R`).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行移动到 (0,0)，即显示的左上角。回想一下，不仅萤火虫从 (2,2) 位置开始，它还以“移动”模式（`M`）开始，所以没有拖影。第二行将模式设置为“随机”（`R`）。
- en: The third line moves east from (0,0) four times. Each move sets the previous
    position to a random intensity. After the last move east, the firefly is at position
    (0,4), so a move south sets position (0,4) to a random intensity and puts the
    firefly at position (1,4).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行从 (0,0) 向东移动四次。每次移动都将前一个位置设置为随机强度。最后一次向东移动后，萤火虫位于 (0,4) 位置，因此向南移动将 (0,4)
    位置设置为随机强度，并将萤火虫放置到 (1,4) 位置。
- en: To fill in the second row of the display, we’ll need four moves to the west
    followed by a move south to end up at the beginning of the third row. This zig-zag
    continues through the remaining rows until the final `S` moves the firefly to
    (0,4). A final move then sets the last LED at (4,4).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充显示的第二行，我们需要四次向西移动，然后向南移动一次，最终到达第三行的起点。这种之字形移动会继续，直到最后的`S`将萤火虫移到(0,4)。最后一次移动将最后一个LED设置为(4,4)。
- en: There is no halt instruction, so the program loops after filling the display.
    The firefly is reset to (2,2), immediately moved to (0,0), and the grid is drawn
    again from top to bottom. Therefore, the display is overwritten continuously,
    row by row, with the previous set of random intensities still present.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有暂停指令，因此程序在填充显示后会继续循环。萤火虫被重置到(2,2)，然后立即移动到(0,0)，并且从上到下重新绘制网格。因此，显示会一行一行地被覆盖，之前的一组随机强度仍然存在。
- en: The console interpreter is too fast to see the overwriting effect, but running
    *random.fly* on the micro:bit makes it visible, though just barely. Even on the
    micro:bit, the code is almost too fast. The effect is mesmerizing. Unfortunately,
    there is no way to capture the effect in a still image in a book. To see the effect,
    do view the videos on the GitHub site.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台解释器运行得太快，无法看到覆盖效果，但在micro:bit上运行*random.fly*时，效果可以看得见，虽然只是勉强可见。即使在micro:bit上，代码也几乎太快了。这个效果令人着迷。不幸的是，无法在书中的静态图像中捕捉到这个效果。要查看效果，请访问GitHub网站上的视频。
- en: Instead of overwriting the display one row at a time, we can introduce double
    buffering and display a full grid of random intensities while generating the next
    grid, then flip and display that grid, and so on.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以引入双缓冲，而不是一次覆盖一行显示，这样可以在生成下一个网格时，显示一个完整的随机强度网格，然后切换并显示那个网格，依此类推。
- en: '[Listing 15-6](ch15.xhtml#ch015list6) shows us *random2.fly*.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表15-6](ch15.xhtml#ch015list6)展示了我们*random2.fly*。'
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 15-6: Random computer lights with double buffering*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表15-6：带双缓冲的随机计算机灯光*'
- en: The code is in two distinct blocks. The first block is nearly identical to [Listing
    15-5](ch15.xhtml#ch015list5) except for the addition of a leading `B` instruction
    to tell the firefly to make trails on grid B even though grid A is being shown.
    At the bottom of the first block, after the entirety of grid B is updated, come
    `M` and `NNNN` to set move mode and then move back to (0,0).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分为两个不同的块。第一个块几乎与[列表15-5](ch15.xhtml#ch015list5)相同，唯一的区别是增加了一个`B`指令，告诉萤火虫在显示网格A时，也在网格B上留下轨迹。在第一个块的底部，在更新完网格B的所有内容后，接下来是`M`和`NNNN`来设置移动模式，然后返回到(0,0)。
- en: The second block of code now takes over. First, `YA` shows grid B, the grid
    the first block of code just filled with random intensities, and switches to drawing
    trails on grid A. The next six lines fill grid A and the final instruction is
    `X` to show grid A.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第二块代码现在接管。首先，`YA`显示网格B，即第一个代码块刚刚用随机强度填充的网格，并切换到在网格A上绘制轨迹。接下来的六行填充网格A，最后的指令是`X`，以显示网格A。
- en: 'At this point, the program loops and begins again, filling grid B. The final
    `X` has us looking at grid A, just as we do when a Firefly program begins, so
    the sequence repeats: show A, draw on B, show B, draw on A, and repeat forever.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点，程序进入循环并重新开始，填充网格B。最终的`X`使我们再次查看网格A，就像当一个Firefly程序开始时一样，因此序列会重复：显示A，绘制B，显示B，绘制A，然后永远循环。
- en: Unlike [Listing 15-5](ch15.xhtml#ch015list5), which constantly overwrites the
    one grid shown, [Listing 15-6](ch15.xhtml#ch015list6) ping-pongs between the two
    grids, so the user only sees the grid that was most recently filled and never
    the grid actively being drawn to. The effect is perhaps even more like the old
    sci-fi movies. There is no flow from top to bottom and the intensities change
    seemingly at once.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与[列表15-5](ch15.xhtml#ch015list5)不同，它不断覆盖显示的唯一网格，[列表15-6](ch15.xhtml#ch015list6)则在两个网格之间来回切换，因此用户只会看到最近填充的网格，而看不到正在绘制的网格。这个效果甚至可能更像旧时的科幻电影。没有从上到下的流动，强度似乎是同时改变的。
- en: '**Beethoven in Lights**'
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**贝多芬之光**'
- en: I claimed in [Chapter 14](ch14.xhtml#ch14) that our firefly knows how to sing.
    Let’s prove it now by writing some music in Firefly. Of course, without an actual
    micro:bit, console-only runs of the examples in this section will be disappointing.
    Have no fear! You can always listen to the song via the videos included on the
    book’s GitHub site.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第14章](ch14.xhtml#ch14)中曾声称我们的萤火虫知道如何唱歌。现在，让我们通过编写一些Firefly音乐来证明这一点。当然，如果没有实际的micro:bit，单纯在控制台上运行本节中的示例会令人失望。别担心！你总是可以通过书籍GitHub网站上的视频来聆听这首歌。
- en: Firefly supports playing notes in the key of C. Middle C (the default) is octave
    4, and middle C itself is note 1\. Therefore, the simplest way to play a note
    in Firefly is to execute `1TF`, which sets the intensity to 1, “ticks” to update
    the default firefly position of (2,2), and plays with the default duration of
    a quarter note. The code loops, of course, and after a brief pause for reset,
    the note plays again. The result is a dim LED in the middle of the grid followed
    by buzzing at the pitch of middle C, over and over and over until you cut the
    power. Still, it’s impressive to get sound from a three-character program.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Firefly支持在C调中演奏音符。中央C（默认）是第4八度，而中央C本身是第1音符。因此，演奏Firefly中一个音符的最简单方法是执行`1TF`，该指令将强度设置为1，“滴答”更新默认的萤火虫位置（2,2），并以四分音符的默认时值进行演奏。当然，代码会循环，并在短暂的重置暂停后，音符再次演奏。结果是一个在网格中央的暗LED，随后发出中央C音高的嗡嗡声，反复进行，直到你切断电源。不过，从一个三字符的程序中发出声音，还是相当令人印象深刻的。
- en: 'A slightly longer program does sound fun and a bit outer space-ish: `1TJRTF`.
    First, it sets the note duration to 1, which is one-quarter of a quarter note
    (a sixteenth note). Then it sets the note itself to a random note and plays it.
    Visually, the higher the pitch, the brighter the LED. The `R` instruction sets
    positions to a random value in the range [1,9]. However, you’ll notice pauses
    while the random melody plays. If the random value is 8, it acts as note 0, which
    is a rest. For fun, experiment with two slightly different versions: `RTJRTF`
    and `0TJRTF`. The first makes the note duration random as well, and the second
    sets the duration to 0, causing a staccato effect.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微长一点的程序听起来很有趣，有点像外太空的感觉：`1TJRTF`。首先，它将音符时值设置为1，即四分之一音符的四分之一（十六分音符）。然后它将音符本身设置为随机音符并演奏。视觉上，音高越高，LED越亮。`R`指令将位置设置为[1,9]范围内的随机值。然而，你会注意到在随机旋律播放时会有停顿。如果随机值是8，它就作为音符0，即休止符。为了好玩，可以尝试两个略有不同的版本：`RTJRTF`和`0TJRTF`。第一个使音符时值也变为随机，第二个将时值设置为0，产生切分音效果。
- en: We’ll get to Beethoven in time, but before we do, [Listing 15-7](ch15.xhtml#ch015list7)
    shows us how to play an actual scale.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会在适当的时候提到贝多芬，但在此之前，[清单 15-7](ch15.xhtml#ch015list7)展示了如何演奏一个实际的音阶。
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 15-7: A simple C-major scale*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-7：一个简单的C大调音阶*'
- en: The first line sets the duration to 1, as we did with the random melody. Next,
    we set the note to 0 and the mode to increment. Then, `TF` increments to 1 and
    plays the note (middle C). The next `TF` increments to 2 and plays D. This repeats
    for notes E through B.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将时值设置为1，就像我们在随机旋律中做的那样。接下来，我们将音符设置为0，模式设置为增量。然后，`TF`增量到1并演奏音符（中央C）。接下来的`TF`增量到2并演奏D。这个过程对E到B音符重复进行。
- en: To play the C one octave above middle C, we need to update the octave with `5TG`,
    remembering that middle C is octave 4\. Lastly, `8TG` sets the duration to a half
    note (8) and plays the first note of octave 5 before halting.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要演奏高于中央C一个八度的C音，我们需要使用`5TG`更新八度，并记住中央C是第4八度。最后，`8TG`将时值设置为半音符（8），并在停止前演奏第5八度的第一个音符。
- en: The scale plays quickly, but there is a distinct pause before the final note
    plays. In this case, it adds a bit of dramatic effect, but in reality, the pause
    is an artifact of how slowly the micro:bit interprets Firefly instructions. There
    are eight instructions between playing the second-to-last note, B, and the last
    note, C. Interpreting these eight instructions causes the pause you hear.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 音阶演奏得很快，但在最后一个音符演奏之前会有一个明显的停顿。在这种情况下，这个停顿增添了一点戏剧效果，但实际上，停顿是因为micro:bit解释Firefly指令的速度较慢。演奏倒数第二个音符B和最后一个音符C之间有八个指令。解释这八个指令会导致你听到的停顿。
- en: Let’s get classical. We want code to make the firefly “sing” Beethoven’s *Ode
    to Joy* (see [Figure 15-3](ch15.xhtml#ch015fig3)).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来点经典的。我们想让代码让萤火虫“唱”贝多芬的*欢乐颂*（见[图 15-3](ch15.xhtml#ch015fig3)）。
- en: '![Image](Images/15fig03.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/15fig03.jpg)'
- en: '*Figure 15-3: Beethoven’s* Ode to Joy'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-3：贝多芬的* 欢乐颂'
- en: Instead of simply playing the notes in one place, wouldn’t it be nice if the
    firefly displayed the notes as it played them? S- along with singing, we want
    the firefly to show us the notes in lights on the display.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不仅仅是在一个地方演奏音符，而是萤火虫在演奏音符时同时显示它们，那不是更好吗？除了唱歌，我们还希望萤火虫通过显示器上的灯光向我们展示音符。
- en: There are 30 notes in [Figure 15-3](ch15.xhtml#ch015fig3), split into two musical
    phrases of 15 notes each. There are five LEDs per row on the micro:bit display.
    How convenient for us. We’ll show the notes, one per position, using the first
    three rows of LEDs to cover a 15-note phrase. Then, we’ll clear the screen and
    repeat the process for the remaining 15 notes. The code we need is in *ode.fly*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-3](ch15.xhtml#ch15fig3) 中有 30 个音符，分成两个包含 15 个音符的音乐段落。micro:bit 显示器每行有五个
    LED。对我们来说太方便了。我们将逐个位置显示音符，使用前 3 行 LED 来覆盖 15 个音符的段落。然后，我们清除屏幕，重复这个过程显示剩下的 15 个音符。我们需要的代码在
    *ode.fly* 中。'
- en: Let’s walk through the code by musical phrase. The first phrase is in [Listing
    15-8](ch15.xhtml#ch015list8).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照音乐段落逐步解析代码。第一段旋律在[清单 15-8](ch15.xhtml#ch015list8)中。
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 15-8: Ode to Joy, first phrase*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-8：欢乐颂，第一段旋律*'
- en: By default, the octave is that of middle C, and the duration matches a quarter
    note, so we need not change the duration or octave. We want the notes displayed
    as they play, row by row, so we first move the firefly to position (0,0). The
    next line sets up a pattern we’ll repeat for each note. For example, `3TFE` sets
    the current position to 3 (`3T`) and plays the note (`F`) before moving one position
    to the east (`E`). This pattern of instructions is used for every note of the
    piece.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，八度是中音C，时值匹配四分音符，因此我们无需更改时值或八度。我们希望音符在播放时逐行显示，因此我们首先将萤火虫移动到位置 (0,0)。接下来的代码设置了一个我们将在每个音符上重复的模式。例如，`3TFE`
    将当前位置设置为 3（`3T`），播放音符（`F`），然后将位置向东移动一个格子（`E`）。这个指令模式在整个乐曲的每个音符上都会使用。
- en: The next four notes, E-F-G-G, finish the first row and leave the firefly back
    at position (0,0). To get to the next row, we use `MS` to move south to (1,0)
    without changing the current value of (0,0). The notes of the second row play
    next, F-E-D-C-C, before moving to the third row.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四个音符 E-F-G-G 完成了第一行，并将萤火虫返回到位置 (0,0)。为了进入下一行，我们使用 `MS` 指令将萤火虫向南移动到 (1,0)，而不改变当前的
    (0,0) 位置。接下来播放第二行的音符 F-E-D-C-C，然后进入第三行。
- en: 'The first four notes of row 3 play: D-E-E-D. Then, we change the duration from
    quarter notes to half notes. If we make the change directly, we’ll upset the display,
    as we need to set a position to 8 for the `J` instruction. So we tell the firefly
    to draw on grid B, which is not displayed, and set the duration that way before
    switching back to drawing on grid A and playing the note: `A2TF`. The first phrase
    is now complete.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行的前四个音符依次为：D-E-E-D。然后，我们将时值从四分音符改为二分音符。如果我们直接进行更改，显示会出错，因为我们需要将位置设置为 8 以执行
    `J` 指令。所以我们让萤火虫在未显示的 B 网格上绘制，并设置时值，然后再切换回 A 网格绘制并播放音符：`A2TF`。第一段旋律现在已经完成。
- en: '[Listing 15-9](ch15.xhtml#ch015list9) plays the second phrase.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 15-9](ch15.xhtml#ch015list9) 播放第二段旋律。'
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 15-9: Ode to Joy, second phrase*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-9：欢乐颂，第二段旋律*'
- en: '[Listing 15-9](ch15.xhtml#ch015list9) is much the same as [Listing 15-8](ch15.xhtml#ch015list8)
    except for the first line. That line clears the display, grid A, switches to grid
    B to reset the duration to 4, and then goes back to drawing on grid A. The next
    line moves the firefly to (0,0), and the second phrase plays just as the first
    did. After the final note, the program executes `H` to end.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 15-9](ch15.xhtml#ch015list9) 与 [清单 15-8](ch15.xhtml#ch015list8) 基本相同，唯一的区别是第一行。该行清除显示器
    A 网格，切换到网格 B 重置时值为 4，然后再切换回网格 A 继续绘制。接下来的一行将萤火虫移动到 (0,0)，第二段旋律像第一段一样播放。最后一个音符后，程序执行
    `H` 以结束。'
- en: Naturally, we must run this program on the micro:bit, but you can play the associated
    video to see how it goes if you don’t have one. It would be straightforward to
    copy this technique to play other melodies, though we were fortunate that *Ode
    to Joy* consists of two distinct musical phrases of exactly 15 notes and thus
    fits perfectly on the 5×5 display.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，我们必须在 micro:bit 上运行这个程序，但如果你没有 micro:bit，可以播放相关视频来看演示。将这种技术应用于其他旋律是很简单的，尽管我们很幸运，《欢乐颂》由两段完全相同的
    15 个音符组成，正好适合 5×5 的显示器。
- en: If you watch the melody play, you’ll see how the LED intensity is related to
    the pitch of the note; higher notes are brighter, at least within the same octave.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你观看旋律播放，你会看到 LED 的亮度与音符的音高相关；较高的音符较亮，至少在同一个八度内是这样。
- en: '**Dance Dance**'
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**舞动舞动**'
- en: Now let’s use Firefly’s double-buffering abilities to do a bit of animation
    with music. We’ll begin with the animation and add the music later.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们利用 Firefly 的双缓冲能力做一些带有音乐的动画。我们将从动画开始，稍后再添加音乐。
- en: Our goal is to make a simple figure “dance.” With a 5×5 display, the emphasis
    is definitely on the word *simple*. Each stance of the figure is a display. To
    make the animation, we’ll use double buffering and a collection of independent
    stances. We’ll proceed by defining the stances in code, putting them together
    in an animation, and adding the dance music. Our firefly will be quite the busy
    flier for this example.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是让一个简单的图形“跳舞”。在一个 5×5 的显示屏上，重点肯定是“简单”这个词。图形的每个姿势都是一个显示内容。为了制作动画，我们将使用双缓冲和一组独立的姿势。我们将通过在代码中定义这些姿势，将它们组合成动画，并加入舞蹈音乐。我们的萤火虫在这个例子中将会非常忙碌。
- en: '***The Stances***'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***姿势***'
- en: We’ll make the firefly trace the figure for each stance beginning and ending
    at position (2,2). This allows us to string the stances together in any order
    that we wish and be in the proper position when the program loops and begins again.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让萤火虫在每个姿势的开始和结束位置 (2,2) 处跟踪图形。这使得我们可以随意将这些姿势串联在一起，并确保在程序循环并重新开始时处于正确的位置。
- en: We will begin with Stance 1\. As the figure dances, each move returns to Stance
    1 before moving on to the next. [Listing 15-10](ch15.xhtml#ch015list10) shows
    the code for Stance 1 along with the stance itself.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从姿势 1 开始。随着图形的跳舞，每个动作都会回到姿势 1，然后再移动到下一个姿势。[清单 15-10](ch15.xhtml#ch015list10)展示了姿势
    1 的代码和该姿势本身。
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 15-10: Stance 1*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-10：姿势 1*'
- en: With a bit of imagination, you’ll see a figure with outstretched arms. To make
    the figure dance, we’ll move the arms and legs in sequence. We can move both arms
    up or down, or move one up and the other down. Similarly, we can move the right
    leg out or the left leg out for a total of six possible stances. [Table 15-1](ch15.xhtml#ch015tab1)
    gives us the code and the appearance of each stance.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一点想象，你会看到一个张开双臂的图形。为了让图形跳舞，我们会按顺序移动手臂和腿。我们可以同时将两只手臂抬起或放下，或者将一只抬起另一只放下。同样，我们可以将右腿或左腿伸出，总共可以形成六种不同的姿势。[表
    15-1](ch15.xhtml#ch015tab1)提供了每种姿势的代码和外观。
- en: '**Table 15-1:** The Remaining Stances'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 15-1：剩余姿势**'
- en: '![Image](Images/f0406-01.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0406-01.jpg)'
- en: While developing this example, it was extremely helpful to use the console interpreter
    in trace mode. I first generated the code for each stance independently of the
    others. We’ll see below how this helps create the desired animation sequence by
    literally copying and pasting code in the right place.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发这个例子时，使用控制台解释器的追踪模式非常有帮助。我首先独立生成了每个姿势的代码。下面我们将看到，这种做法如何通过直接复制和粘贴代码到正确的位置，帮助创建所需的动画序列。
- en: '***The Dance***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***舞蹈***'
- en: To animate the figure, we start with Stance 1, and after each move go back to
    Stance 1\. The sequence is
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让图形动起来，我们从姿势 1 开始，每次移动后都回到姿势 1。这个序列是
- en: 1 → 2 → 1 → 3 → 1 → 4 → 1 → 5 → 1 → 6 → 1 → 7
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 1 → 2 → 1 → 3 → 1 → 4 → 1 → 5 → 1 → 6 → 1 → 7
- en: where we end with Stance 7 and allow the program to loop to begin again with
    Stance 1.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最终我们以姿势 7 结束，并允许程序循环重新开始，回到姿势 1。
- en: Look carefully at the sequence of stances and think of Firefly’s double buffers.
    When the program starts, we’re looking at grid A and the firefly is drawing to
    grid A. We’ll draw Stance 1 in grid A, but doing that will let the user see the
    firefly draw, so we’ll show grid B while drawing Stance 1\. Likewise, when the
    firefly has drawn Stance 1 in grid A, we’ll show grid A and tell the firefly to
    draw in grid B. Then, we’ll render Stance 2 in grid B.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察姿势的顺序，并思考萤火虫的双缓冲技术。当程序启动时，我们查看网格 A，萤火虫正在向网格 A 绘制。我们会在网格 A 中绘制姿势 1，但这样做会让用户看到萤火虫绘制的过程，因此在绘制姿势
    1 时，我们会显示网格 B。同样，当萤火虫在网格 A 中绘制完姿势 1 后，我们会显示网格 A，并告诉萤火虫在网格 B 中绘制。然后，我们将在网格 B 中渲染姿势
    2。
- en: At this point, we might be tempted to draw Stance 1 in grid A; however, Stance
    1 is already in grid A, so we don’t need to draw it again. This is why the figure
    always returns to Stance 1 before moving to another stance—we can leave Stance
    1 in grid A and only draw it once. When we need to draw a new stance, we’ll do
    it in grid B while showing Stance 1 in grid A.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可能会想在网格 A 中绘制姿势 1；然而，姿势 1 已经在网格 A 中，所以我们不需要再绘制一次。这就是为什么图形总是回到姿势 1 再移动到另一个姿势——我们可以将姿势
    1 留在网格 A 中，只绘制一次。当我们需要绘制新姿势时，我们会在网格 B 中进行绘制，同时显示网格 A 中的姿势 1。
- en: 'Therefore, to animate, we need the following sequence, formatted as (*shown*,
    *drawn*):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要实现动画，我们需要以下的序列，格式为 (*显示的*, *绘制的*)：
- en: (*B*, *A*) → (*A*, *B*) → (*B*, ∗) → (*A*, *B*) → (*B*, ∗) → (*A*, *B*) →
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: (*B*, *A*) → (*A*, *B*) → (*B*, ∗) → (*A*, *B*) → (*B*, ∗) → (*A*, *B*) →
- en: (*B*, ∗) → (*A*, *B*) → (*B*, ∗) → (*A*, *B*) → (*B*, ∗) → (*A*, *B*)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: (*B*, ∗) → (*A*, *B*) → (*B*, ∗) → (*A*, *B*) → (*B*, ∗) → (*A*, *B*)
- en: Here, ∗ means we don’t change the grid drawn to as we’re showing Stance 1, which
    never needs to be redrawn. At each step in the sequence, save the first, the grid
    shown reveals the most recently drawn stance (or Stance 1).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，∗意味着我们不改变所绘制的网格，因为我们展示的是Stance 1，它永远不需要重新绘制。在序列中的每一步，除了第一步，显示的网格将揭示最近绘制的姿势（或Stance
    1）。
- en: '[Listing 15-11](ch15.xhtml#ch015list11) presents the animation code in skeleton
    form to show the sequence of stances drawn and how the different grids are displayed
    and drawn to. To generate the actual code, replace instances of “draw Stance 1”
    and so on with the proper code block from [Table 15-1](ch15.xhtml#ch015tab1) or
    [Listing 15-10](ch15.xhtml#ch015list10).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 15-11](ch15.xhtml#ch015list11)展示了动画代码的框架，显示了绘制的姿势序列以及不同网格的显示和绘制方式。要生成实际的代码，将“绘制Stance
    1”等实例替换为[表 15-1](ch15.xhtml#ch015tab1)或[列表 15-10](ch15.xhtml#ch015list10)中的正确代码块。'
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 15-11: Animation sequence code skeleton*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-11：动画序列代码框架*'
- en: The `PPPPP` blocks delay for 0.5 seconds to control the speed of the animation.
    These are also the locations where we’ll later add music. To watch the animation
    without music, execute *dance.fly*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`PPPPP`块延迟0.5秒以控制动画的速度。这些也是我们稍后添加音乐的位置。要观看没有音乐的动画，可以执行*dance.fly*。'
- en: '***The Music***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***音乐***'
- en: Let’s add some music. The melody we’ll use was kindly written for us by film
    and television composer Paul Kneusel (see [Figure 15-4](ch15.xhtml#ch015fig4)).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加入一些音乐。我们将使用的旋律是由电影和电视作曲家Paul Kneusel为我们特别创作的（见[图 15-4](ch15.xhtml#ch15fig4)）。
- en: '![Image](Images/15fig04.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/15fig04.jpg)'
- en: '*Figure 15-4: “Dance dance” by Paul Kneusel (*[https://www.paulkneusel.com/](https://www.paulkneusel.com/)*)*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-4：“舞蹈舞蹈”由Paul Kneusel创作 (*[https://www.paulkneusel.com/](https://www.paulkneusel.com/)*
    )*'
- en: Translating the score into Firefly code leads to [Listing 15-12](ch15.xhtml#ch015list12).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将乐谱转换成Firefly代码会得到[列表 15-12](ch15.xhtml#ch015list12)。
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 15-12: “Dance dance” in Firefly*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-12：“舞蹈舞蹈”在Firefly中的实现*'
- en: You can hear the melody by loading *dance_loop.fly* onto the micro:bit or by
    watching the video on the GitHub site. The music plays in place, so the center
    LED on the micro:bit fluctuates in brightness as the melody plays.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将*dance_loop.fly*加载到micro:bit上，或者通过观看GitHub网站上的视频来听到旋律。音乐在原地播放，因此micro:bit上的中央LED会随着旋律的播放而亮度波动。
- en: To complete this section, we’ll merge the melody with the animation code. [Listing
    15-11](ch15.xhtml#ch015list11) has pauses between screens, `PPPPP`. For the musical
    version, we’ll replace the pauses with successive measures from the melody, so
    the first instance of `PPPPP` in [Listing 15-11](ch15.xhtml#ch015list11) is replaced
    by the first measure of [Listing 15-12](ch15.xhtml#ch015list12) and so on. The
    result is *dance_music.fly*. We won’t show the code here, but do read through
    it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这一部分，我们将旋律与动画代码结合起来。[列表 15-11](ch15.xhtml#ch015list11)中屏幕之间有暂停，`PPPPP`。对于音乐版本，我们将用旋律中的连续小节替换暂停，因此[列表
    15-11](ch15.xhtml#ch015list11)中第一个`PPPPP`会被[列表 15-12](ch15.xhtml#ch015list12)中的第一个小节替换，依此类推。最终的结果是*舞曲_music.fly*。我们不会在这里展示代码，但请务必阅读一遍。
- en: If you run *dance_music.fly*, you’ll hear the first measure as a sort of intro
    before the animation. There are noticeable pauses while successive screens are
    rendered in the buffer not shown, but the tune and animation still work.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行*dance_music.fly*，你会听到第一小节作为动画前的引子。在连续屏幕渲染时，缓冲区中会有明显的暂停，虽然没显示出来，但旋律和动画仍然有效。
- en: '**Tea Time**'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**茶点时间**'
- en: There is no general agreement as to how long one should steep a cup of tea,
    but a rule of thumb I often use is about three and a half minutes for a cup of
    black tea. In this section, we’ll use Firefly to write a tea timer that runs for
    about three and a half minutes. Once you see the pattern, you’ll be able to adjust
    the delay to suit your tastes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 关于泡茶的时间并没有统一的标准，但我常用的经验法则是：一杯红茶大约泡三分半钟。在这一部分中，我们将使用Firefly编写一个茶叶计时器，运行大约三分半钟。一旦你掌握了模式，你就可以根据自己的口味调整延迟时间。
- en: The timer counts down a display of LEDs. When the countdown is complete, the
    program animates the display while playing an alarm sound to let us know our tea
    is ready. This example is practical enough to make it worth dedicating an entire
    micro:bit to the task. Just put your teabag in the hot water, start the micro:bit,
    and wait for the visual and audio alarm to sound—your tea is now ready.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 倒计时器通过LED显示屏倒计时。当倒计时完成时，程序会显示动画并播放警报声音，提醒我们茶已经准备好了。这个例子足够实用，值得将整个micro:bit专门用来完成这个任务。只需将茶包放入热水中，启动micro:bit，等待视觉和音频警报响起——你的茶就做好了。
- en: The source code is in *tea_timer.fly*. The program fills the first four rows
    of the display with maximum intensity. Then, starting with position (0,0), the
    program dims the LEDs by 1 after a one-second delay. When the LED at the current
    position is 0, the program moves to the next position and repeats. LED after LED
    is dimmed to 0 this way until all four rows are 0\. After the display is completely
    0, a brief animation of star patterns plays along with a rapid scale as the audio
    alarm.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码在 *tea_timer.fly* 中。程序首先将显示器的前四行填充为最大强度。然后，从位置 (0,0) 开始，程序在每秒延迟后将 LED 的亮度减少
    1。当当前亮度为 0 时，程序将移动到下一个位置并重复。LED 会依次变暗，直到所有四行的 LED 都变为 0。显示器完全变为 0 后，会播放一个简短的星形图案动画，并伴随着音频警报。
- en: Filling four rows of the display means we have 20 LEDs to dim. Each LED takes
    10 seconds to go from maximum intensity to 0; therefore, dimming the display takes
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 填充显示器的四行意味着我们有 20 个 LED 需要调暗。每个 LED 从最大强度到 0 需要 10 秒钟；因此，调暗显示器需要
- en: '![Image](Images/f0409-01.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0409-01.jpg)'
- en: The animation and alarm add a few more seconds to give us an approximate three-and-a-half
    minute timer.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 动画和警报增加了几秒钟，给我们一个大约三分半钟的定时器。
- en: The timer starts by filling the first four rows of grid A with 9s (see [Listing
    15-13](ch15.xhtml#ch015list13)).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器通过将网格 A 的前四行填充为 9（参见 [清单 15-13](ch15.xhtml#ch015list13)）开始。
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 15-13: Filling the display*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-13：填充显示器*'
- en: To avoid watching the display draw, grid B is shown until the first four rows
    of grid A are full, and then grid A is shown again after moving the firefly to
    position (0,0).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免观看显示器的绘制过程，网格 B 会在网格 A 的前四行填满之前显示，之后在将萤火虫移动到位置 (0,0) 后再显示网格 A。
- en: The countdown now begins. Here’s where the simplicity of Firefly pains us a
    bit. The pattern we need to implement is
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 倒计时现在开始。这里就是 Firefly 简单性让我们稍微感到痛苦的地方。我们需要实现的模式是
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, `M` is the micro:bit display, grid A. It would be nice to have some sort
    of looping construct, but Firefly is too primitive to support looping, so we need
    to unroll the loops and manually decrement each position to 0 before moving to
    the next position and then repeat, row by row.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`M` 是 micro:bit 显示器的网格 A。虽然有一些循环结构会更好，但 Firefly 过于简陋，无法支持循环，因此我们需要展开循环，并在移动到下一个位置之前手动将每个位置递减到
    0，然后按行重复。
- en: Fortunately, once we have a pattern in place for the current position, we have
    what we need for virtually all the positions in a row. Once we have all we need
    for a row, we have what we need for all four rows. So unrolling the loops isn’t
    too bad and is relatively straightforward with the help of some copy-and-paste
    magic.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，一旦我们为当前的位置设置了模式，我们就可以在行内的几乎所有位置中重复使用它。一旦我们为一行设置好了所有内容，就能为所有四行设置好。因此，展开循环并不难，通过一些复制粘贴的技巧，操作相对简单。
- en: For example, to process the first column of the first row, meaning position
    (0,0), we need
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要处理第一行的第一列，也就是位置 (0,0)，我们需要
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first line pauses for one second, then uses `T` to decrement the current
    position without moving. This changes intensity 9 to intensity 8\. Repeating this
    process eight more times results in intensity 0 at (0,0). We need to wait one
    more second for the 0 intensity before moving to the next column with `MED`. We
    are now at position (0,1) and ready to repeat this code block. We do the same
    for positions (0,2), (0,3), and (0,4).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行暂停一秒钟，然后使用 `T` 来递减当前的位置而不移动。这将强度从 9 降到 8。重复这个过程 8 次后，(0,0) 的强度变为 0。在移动到下一列之前，我们需要再等一秒钟，直到强度为
    0，然后使用 `MED` 移动到下一个位置。此时我们已到达位置 (0,1)，并准备重复这段代码块。我们对位置 (0,2)、(0,3) 和 (0,4) 也做同样的操作。
- en: At the end of position (0,4), we need to move to the next row. So instead of
    executing `MED`, we execute `MESD` to arrive at (1,0). The entire process repeats
    for row 1, row 2, and row 3\. However, at the end of row 3, the timer portion
    is complete and all of grid A is empty. We conclude by moving to (2,2) via `MWWN`
    so we are in position to begin the animation and alarm.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在位置 (0,4) 结束时，我们需要移动到下一行。所以，我们不执行 `MED`，而是执行 `MESD`，到达 (1,0)。整个过程会在第 1 行、第 2
    行和第 3 行重复。然而，在第 3 行结束时，定时器部分已完成，网格 A 已完全为空。我们通过 `MWWN` 移动到 (2,2)，这样我们就准备开始动画和警报。
- en: 'The animation is straightforward: two star patterns, with one stored on each
    grid. We’ll toggle between them while playing the alarm. [Listing 15-14](ch15.xhtml#ch015list14)
    shows the code.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 动画非常简单：两个星形图案，每个图案存储在一个网格中。我们将在它们之间切换，同时播放警报。[清单 15-14](ch15.xhtml#ch015list14)
    显示了代码。
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 15-14: Animation and alarm code*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-14：动画和警报代码*'
- en: There are three code blocks. The first generates an X shape on grid A and the
    second displays a + shape on grid B. The last block toggles between grids A and
    B while playing a scale over and over. Note that the firefly is at position (2,2),
    so the center pixel on both grids changes as the animation happens. When complete,
    the program exits, and our tea is ready.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三个代码块。第一个在A网格上生成一个X形状，第二个在B网格上显示一个+形状。最后一个块在A网格和B网格之间切换，同时反复播放音阶。请注意，萤火虫位于位置(2,2)，所以在动画进行时，两个网格的中心像素都会发生变化。当程序完成时，它会退出，茶也泡好了。
- en: The tea timer concludes our Firefly examples. There is one more, using genetic
    programming to evolve Firefly programs, but its complexity requires moving it
    to Appendix 16\. Do take a look. The examples of this chapter are fun and whimsical.
    The example in Appendix 16 demonstrates a more sophisticated way to use even the
    tiniest of esolangs.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 泡茶计时器结束了我们对Firefly的示例。在附录16中，我们还有一个例子，使用遗传编程来演化Firefly程序，但由于其复杂性，我们将其移到了附录16中。请一定查看。
    本章中的示例既有趣又充满奇思妙想。附录16中的示例展示了如何使用即使是最小的esolangs来实现更复杂的功能。
- en: '**Discussion**'
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Firefly is most definitely *not* Turing complete. We learned in [Chapter 3](ch03.xhtml#ch03)
    that a Turing complete imperative programming language requires some form of conditional
    branching and arbitrary memory. Firefly has no branching, conditional or otherwise,
    and minimal memory; therefore, Firefly is not Turing complete and not able to
    implement, even in theory, arbitrary algorithms.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Firefly绝对*不是*图灵完备的。我们在[第3章](ch03.xhtml#ch03)中了解到，图灵完备的命令式编程语言需要某种形式的条件分支和任意内存。Firefly没有分支，无论是条件分支还是其他类型的分支，而且内存非常有限；因此，Firefly不是图灵完备的，甚至在理论上也无法实现任意算法。
- en: 'However, as the examples of this chapter demonstrate, Firefly does support
    useful programs. We created a counter suitable for timing things in the real world.
    We also created a timer for steeping tea and programs to play music. Even the
    random sci-fi backgrounds are useful, if desired: imagine a wall of micro:bits
    each running *random.fly* or *random2.fly* and built into a prop.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如本章的示例所示，Firefly确实支持一些有用的程序。我们创建了一个适合计时的计数器。我们还创建了一个泡茶计时器和一些播放音乐的程序。即便是随机科幻背景，也能派上用场：想象一下，一排micro:bit每个都运行*random.fly*或*random2.fly*，并且它们被嵌入道具中。
- en: Is Firefly all it could be? Definitely not. The micro:bit has two pushbuttons
    for user input, but Firefly ignores them. And this says nothing about all the
    many other advanced features the micro:bit supports. One reason for making Firefly
    primitive was the limited memory of the version 1 micro:bit. Another was the need
    for simplicity in the presentation via a physical book. Firefly is screaming for
    enhancement. I genuinely hope a reader or two accepts the challenge and enhances
    the language. If you do, please share it with us. Part of the fun of esoteric
    programming languages is how they build upon each other—just witness the many
    variants of BF. One language’s ideas prompt new thoughts about languages and lead
    to “what if” ideas, which lead to new esolangs.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Firefly是否达到了它的全部潜力？绝对没有。micro:bit有两个用于用户输入的按钮，但Firefly忽略了它们。这还只是冰山一角，micro:bit支持许多其他先进功能。制作Firefly简化版的一个原因是第一版micro:bit的内存有限。另一个原因是在通过纸质书籍展示时需要简化。Firefly迫切需要改进。我真心希望有一位或两位读者能接受挑战，改进这个语言。如果你做到了，请与我们分享。晦涩的编程语言的乐趣之一就在于它们如何相互发展——看看BF的众多变种就知道了。一个语言的创意会激发出对其他语言的新思考，并引发“如果...会怎样”的想法，这又会催生出新的esolangs。
- en: '**Summary**'
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we presented many examples of Firefly programs. Some were trivial,
    like *hi.fly*, and others were visually appealing, like *random.fly*, or musical,
    like *ode.fly*. Some were cute, like *dance.fly*, and some were perhaps even a
    bit useful, like *fly_time.fly* and *tea_timer.fly*. Regardless, all were (hopefully)
    fun. Many more fun Firefly programs doubtless exist, waiting to be extracted from
    the ether and written down. For example, its display and its compact size makes
    the thought of embedding the micro:bit in a craft or holiday decoration something
    to consider.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了许多Firefly程序的例子。有些程序很简单，比如*hi.fly*，有些则具有视觉吸引力，比如*random.fly*，或者具有音乐性，比如*ode.fly*。有些很可爱，比如*dance.fly*，有些可能甚至有点实用，比如*fly_time.fly*和*tea_timer.fly*。不管怎样，所有这些（希望）都很有趣。毫无疑问，还有更多有趣的Firefly程序等待被从虚空中提取并记录下来。例如，Firefly的显示效果和其紧凑的体积使得将micro:bit嵌入手工艺品或节日装饰品中成为值得考虑的选项。
- en: 'Firefly also concludes our exploration of esolangs and programming languages
    in general. Only one chapter remains: where to go from here.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Firefly 也总结了我们对电子语言和编程语言的一般探索。只剩下最后一章：接下来该怎么走。
