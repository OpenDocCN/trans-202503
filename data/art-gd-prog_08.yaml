- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Advanced Graphics and Animation
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 高级图形与动画
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: 'Sketch 61: Layering'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图61：图层叠加
- en: 'One of the key features of modern graphics programs like Photoshop is the idea
    of layers. That’s the creation of a set of graphical objects (images) that are
    placed on top of each other to achieve a complex effect. Transparency makes it
    possible to see objects on lower layers. This sketch uses three layers: an image
    of the moon, a circle around a crater, and a targeting display (reticle). Using
    the keyboard, the user can reposition the moon image. The goal of the interface
    is to allow the user to align the reticle with the target circle.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现代图形程序（如Photoshop）的一个关键特性是图层的概念。这是创建一组图形对象（图像），将它们叠加以实现复杂效果。透明度使得可以看到下层的物体。这个草图使用了三层：月亮的图像、环绕陨石坑的圆圈和一个目标显示（准星）。通过键盘，用户可以重新定位月亮图像。界面的目标是让用户将准星与目标圆圈对齐。
- en: Drawing inside the sketch window involves using a graphics object class called
    `PGraphics`. The `background()`, `line()`, and `ellipse()` functions, and many
    others, are part of the `PGraphics` class, though we can use them without a `PGraphics`
    object. Alternatively, our drawing can take place in one of these objects and
    then be displayed on the screen later by calling `image()`. This sketch will draw
    the moon image with an ellipse highlighting a crater inside of a `PGraphics` instance,
    and we’ll then display it in the sketch window.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在草图窗口中绘制涉及使用一种名为`PGraphics`的图形对象类。`background()`、`line()`和`ellipse()`等函数，许多其他函数，都是`PGraphics`类的一部分，尽管我们可以在没有`PGraphics`对象的情况下使用它们。或者，我们的绘图可以发生在这些对象之一中，然后通过调用`image()`将其显示在屏幕上。这个草图将在`PGraphics`实例中绘制月亮图像，并用椭圆突出显示陨石坑，然后我们会在草图窗口中显示它。
- en: 'The variable used for the `PGraphics` object is named `pg`, and the function
    that creates one is called (reasonably enough) `createGraphics()` 1:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 用于`PGraphics`对象的变量名为`pg`，创建该对象的函数被称为（合乎情理地）`createGraphics()` 1：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `moon` is the `PImage` variable that holds the background image of the
    moon.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`moon`是`PImage`变量，保存了月亮的背景图像。
- en: 'To draw in a `PGraphics` object, we use the graphics functions that we have
    used before, but specify the `pg` variable as the target 2:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`PGraphics`对象中绘制，我们使用之前使用过的图形函数，但指定`pg`变量作为目标 2：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Drawing is preceded by a call to `beginDraw()`, a function that is similar to
    a bracket; the corresponding end bracket is a call to `endDraw()`. If you don’t
    use these calls, Processing doesn’t initialize the object, and drawing will not
    work (even though Processing may not generate an error). The preceding code draws
    the moon image in the `PGraphics` objects and draws a circle around a target.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制之前会调用`beginDraw()`，这是一个类似于括号的函数；对应的结束括号是调用`endDraw()`。如果不使用这些调用，Processing将无法初始化对象，绘制将无法进行（尽管Processing可能不会生成错误）。前面的代码在`PGraphics`对象中绘制月亮图像，并在目标周围绘制一个圆圈。
- en: The `draw()` function displays the `PGraphics` object using the call `image(pg,
    xoff, yoff)`, where `xoff` and `yoff` are positional offsets that are controlled
    using key presses of W, A, S, and D in the traditional way 3. (A `PGraphics` object
    has many of the properties of a `PImage`, since `image()` can display both.) The
    values of `xoff` and `yoff` are generally negative so that the underlying graphic
    gets shifted left and up under the window, which remains stable, from its starting
    point in the upper-left corner. The `draw()` function also draws the reticle as
    a small set of lines that point to the center of the window 4.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw()`函数通过调用`image(pg, xoff, yoff)`来显示`PGraphics`对象，其中`xoff`和`yoff`是位置偏移量，使用传统的W、A、S和D键来控制
    3。（`PGraphics`对象具有`PImage`的许多属性，因为`image()`可以显示两者。）`xoff`和`yoff`的值通常为负数，以便将底层图形向左和向上移动，保持窗口稳定，从其在左上角的起始点开始。`draw()`函数还绘制了一个准星，作为指向窗口中心的小线条集
    4。'
- en: 'Sketch 62: Seeing the World Through a Window'
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图62：通过窗口看世界
- en: Many games, animations, and simulations (driving or space travel, for example)
    use a view through a window as a part of the interface. This sketch implements
    a window that looks out on a 3D scene and allows the user to move about that scene
    while looking through the window.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏、动画和仿真（例如驾驶或太空旅行）将通过窗口的视图作为界面的一部分。这个草图实现了一个可以看到3D场景的窗口，并允许用户在场景中移动，同时透过窗口查看。
- en: This is a more advanced application of `PGraphics`. We’ll render a simple 3D
    scene to a `PGraphics` instance named `pg`, read a 2D image with transparent sections
    (the window) into a `PGraphics` instance named `g2`, and draw the two graphics
    objects to the screen using calls to `image()`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更高级的`PGraphics`应用。我们将渲染一个简单的 3D 场景到一个名为 `pg` 的 `PGraphics` 实例中，将一个具有透明部分的
    2D 图像（窗户）读取到一个名为 `g2` 的 `PGraphics` 实例中，并通过调用 `image()` 将两个图形对象绘制到屏幕上。
- en: 'The 3D primitives we’ll use to draw the 3D scene are all part of `PGraphics`.
    We’ll enable the 3D rendering engine with a parameter to `createGraphics()` 1,
    instead of to `size()` as in Sketch 51, and then we’ll set up the 3D parameters
    with calls to `camera()` 2 and `ambientLight()`. The basic call to `size()` sets
    up the graphics window; each `PGraphics` instance is like having a distinct window
    to draw in, and all of the usual graphics methods can be used via the dot notation:
    `pg.line()`, `pg.ellipse()`, and so on. No `PGraphics` object is visible until
    drawn in the graphics window. Thus we can create a simulated 3D space inside the
    `pg` object, drawing four cubes there that provide targets to be viewed through
    the window.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用于绘制 3D 场景的 3D 基本图形原语都属于 `PGraphics`。我们将通过 `createGraphics()` 的参数启用 3D 渲染引擎，1
    而不是像草图 51 中那样通过 `size()` 来启用，然后通过调用 `camera()` 2 和 `ambientLight()` 来设置 3D 参数。基本的
    `size()` 调用设置图形窗口；每个 `PGraphics` 实例就像是一个单独的绘图窗口，可以通过点符号来使用所有常见的图形方法：`pg.line()`、`pg.ellipse()`
    等等。直到被绘制在图形窗口中，`PGraphics` 对象才会显示。因此，我们可以在 `pg` 对象内部创建一个模拟的 3D 空间，在那里绘制四个立方体，作为通过窗户查看的目标。
- en: The 2D portion involves displaying a 2D image (a `PImage` variable named `back`)
    that represents the window ([Figure 62-1](#figure62-1)). The GIF image has transparent
    sections, created by defining a color (in this case green) as transparent using
    an image editor like Photoshop. We call this kind of image a stencil.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 2D 部分涉及显示一个 2D 图像（一个名为 `back` 的 `PImage` 变量），它表示窗户（[图 62-1](#figure62-1)）。该
    GIF 图像具有透明部分，通过使用图像编辑器（如 Photoshop）将某个颜色（在这种情况下是绿色）定义为透明来创建。我们称这种类型的图像为模板。
- en: '![f062001](Images/f062001.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![f062001](Images/f062001.png)'
- en: 'Figure 62-1: The stencil for the window'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 62-1：窗户的模板
- en: The sketch draws the two images on the window, `pg` first (the 3D rendering)
    3 followed by `g2` (the stencil) 4. The transparent parts of `g2` allow the 3D
    scene to be seen through the window portions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 草图首先绘制 `pg`（3D 渲染）3，再绘制 `g2`（模板）4。`g2` 的透明部分允许通过窗户部分看到 3D 场景。
- en: The user can control the viewpoint for the 3D scene using the keyboard in the
    usual way 5. The 3D scene changes as a consequence of the change in the viewpoint,
    but the 2D scene does not. The result is that the window stays in the same place
    but the view seen through it (the transparent portions) changes as a function
    of that viewpoint, as if the user were inside a moving vehicle looking at a scene
    outside.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用键盘按常规方式控制 3D 场景的视角。5 3D 场景会根据视角变化而变化，但 2D 场景则不会。结果是窗户保持在原地，但透过窗户看到的画面（透明部分）会随着视角的变化而变化，就像用户在移动的车辆内看到外面场景一样。
- en: 'Sketch 63: The PShape Object—A Rotating Planet'
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 63：PShape 对象——一个旋转的行星
- en: This sketch will display a rotating planet (a sphere) and allow the user to
    move around it in 3D. The new part in this sketch is texture-mapping the planet’s
    surface onto the sphere, which is really a collection of polygons. One way to
    do this would be to build a model of a sphere out of polygons and do the texture-mapping
    within a `beginShape()` and `endShape()` block. An easier way is to use a `PShape`
    object, which is a data type for storing arbitrary shapes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图将展示一个旋转的行星（一个球体），并允许用户在 3D 空间中环绕它移动。这个草图中新加入的部分是将行星表面纹理映射到球体上，而球体本质上是由多边形组成的。实现这种效果的一种方法是用多边形构建一个球体模型，并在
    `beginShape()` 和 `endShape()` 块内进行纹理映射。更简单的方法是使用 `PShape` 对象，它是一种用于存储任意形状的数据类型。
- en: 'To implement the rotating planet, we’ll create a `PShape` object through a
    call to `createShape()`, which allows us to build arbitrarily complex shapes using
    the large set of drawing operations provided by the `PShape` class. It is possible
    to create almost anything using a `PShape`, and the documentation available online
    is necessary for complex creations. Our case is simple, because a sphere is one
    of the shapes provided. This is the call that makes the planet, where `globe`
    is a `PShape` object 1:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现旋转的行星，我们将通过调用`createShape()`来创建一个`PShape`对象，这使我们能够利用`PShape`类提供的大量绘图操作构建任意复杂的形状。使用`PShape`几乎可以创建任何东西，而在线文档对于复杂的创作是必不可少的。我们的例子很简单，因为球体是已提供的形状之一。这是创建行星的调用，其中`globe`是一个`PShape`对象
    1：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The texture, a map of Mars as a `PImage` variable named `timg`, is applied using
    `globe.setTexture(timg)` 2.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理，作为一个名为`timg`的`PImage`变量，应用于`globe`对象，使用`globe.setTexture(timg)` 2。
- en: 'Then we display the planet in `draw()` using a call to the `shape()` function
    3:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在`draw()`函数中通过调用`shape()`函数 3来显示行星。
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code positions the sphere in the center of the field of view and rotates
    it about its own axis before displaying it. The usual keys allow the user to change
    the viewing position.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将球体放置在视野中心，并绕其自身轴旋转，随后进行显示。常用的按键允许用户改变视角。
- en: 'Sketch 64: Splines—Drawing Curves'
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图64：样条—绘制曲线
- en: So far, we’ve rendered simple geometric objects like lines, ellipses, rectangles,
    and spheres using predefined Processing functions. But many real-world objects
    are not linear or elliptical; they have complex shapes. Examples are legion, including
    cars, fan blades, jewelry, clothing, and living things—even graphs of data. In
    Processing, complex shapes are rendered using curves. To demonstrate, this sketch
    allows the user to draw curves using a series of mouse clicks and to see how the
    selected “control points” affect the curves.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用预定义的Processing函数渲染了简单的几何物体，如线条、椭圆、矩形和球体。但许多现实世界中的物体并非线性或椭圆形的；它们有复杂的形状。比如汽车、风扇叶片、珠宝、衣物以及生物体，甚至数据图表等，都是复杂形状的例子。在Processing中，复杂形状通过曲线来渲染。为了演示，这个草图允许用户通过一系列鼠标点击来绘制曲线，并观察所选的“控制点”如何影响曲线。
- en: Processing uses *splines* to render curves. In the earlier days of drafting,
    when people used pencils and T-squares, people used something called a spline
    to draw smooth, oddly shaped curves. It was a long, flexible metal strip that
    could hold a shape, align with points on paper, and allow the drafter to connect
    them using a pencil. Mathematically, a spline is a polynomial function that approximates
    a curve by using a set of points. The details can be complex, but the idea is
    to use many polynomials connected end to end to build the curve. Processing hides
    the complexity.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Processing使用*splines*来渲染曲线。在早期的绘图时代，当人们使用铅笔和T型直尺时，曾使用一种叫做样条的工具来绘制平滑的、不规则的曲线。它是一条长而灵活的金属条，可以保持形状，和纸上的点对齐，并允许绘图人员用铅笔将这些点连接起来。从数学上讲，样条是一种多项式函数，通过使用一组点来逼近曲线。具体细节可能很复杂，但基本思想是使用许多连接在一起的多项式来构建曲线。Processing隐藏了这些复杂性。
- en: Processing provides a function named `curve()` that implements a type of polynomial
    named the Catmull-Rom spline. This function uses four points to define each section
    of the curve. The first two define the direction the curve will have at the beginning,
    and the second two define the direction it will have at the end. The curve itself
    consists of a set of points (pixels) between the middle two points. As seen in
    [Figure 64-1](#figure64-1), the angle defined by the first two points establishes
    the direction of the curve at point P[1], which defines the shape of the polygon
    between P[1] and P[2]; we establish the direction of the curve at P[2] by the
    direction between P[2] and P[3]. In the figure, the points P[1] and P[2] in the
    two examples are the same, but the curves have a different shape due to the different
    positions of P[0] and P[3].
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Processing提供了一个名为`curve()`的函数，来实现一种叫做Catmull-Rom样条的多项式类型。该函数使用四个点来定义曲线的每一部分。前两个点定义曲线开始时的方向，后两个点定义曲线结束时的方向。曲线本身由中间两个点之间的一组点（像素）组成。如[图64-1](#figure64-1)所示，前两个点定义的角度确定了曲线在P[1]点的方向，从而定义了P[1]和P[2]之间多边形的形状；通过P[2]和P[3]之间的方向来确定曲线在P[2]的方向。在图中，两个示例中的P[1]和P[2]是相同的，但由于P[0]和P[3]的位置不同，曲线的形状也有所不同。
- en: '![f064001](Images/f064001.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![f064001](Images/f064001.png)'
- en: 'Figure 64-1: Control points of a spline curve'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图64-1：样条曲线的控制点
- en: 'This is the function call used in Processing to draw a curve section between
    P[1]=(x1,y1) and P[2]=(x2,y2):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Processing中用来绘制P[1]=(x1,y1)和P[2]=(x2,y2)之间曲线段的函数调用：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The start and end points, (`x0`, `y0`) and (`x3`, `y3`), control the shape 1.
    To draw a longer curve, we need multiple calls to `curve()`, with the endpoints
    of one being the beginning of the next.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 起始点和结束点（`x0`，`y0`）和（`x3`，`y3`）控制曲线的形状1。为了绘制更长的曲线，我们需要多次调用`curve()`，每次的结束点是下一个曲线的起始点。
- en: This sketch allows the user to select points, drawn as small red circles using
    mouse clicks 2, and to observe the shape change caused by the position of the
    next point as the mouse moves. Four points define a curve, so when the user selects
    the fourth point, a red curve is drawn using the points specified, and then a
    blue curve that changes as the mouse moves is drawn from the final point to the
    mouse position, (`mouseX`, `mouseY`). Clicking again will add a new point to the
    curve, extending the red portion to include the new point and showing a new blue
    section. Pressing the BACKSPACE key deletes the last point in the curve 3, and
    the spacebar turns the drawing of the final (blue) section on and off 4.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图允许用户选择点，这些点通过鼠标点击绘制为小红圈2，并观察随着鼠标移动，下一个点的位置如何影响曲线形状。四个点定义了一条曲线，因此当用户选择第四个点时，将使用指定的点绘制一条红色曲线，然后从最后一个点到鼠标位置（`mouseX`，`mouseY`）绘制一条蓝色曲线，随着鼠标移动而变化。再次点击将向曲线添加一个新点，将红色部分扩展以包含新点，并显示一个新的蓝色部分。按下BACKSPACE键将删除曲线中的最后一个点3，按下空格键将打开或关闭最后一段（蓝色）曲线的绘制4。
- en: This sketch keeps the point coordinates in arrays `x` and `y` and passes successive
    groups of four coordinates to `curve()`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图将点坐标保存在数组`x`和`y`中，并将连续的四个坐标组传递给`curve()`函数。
- en: 'Sketch 65: A Driving Simulation with Waypoints'
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图65：带有路标的驾驶模拟
- en: Sketch 60 allowed a user to drive around a track in 3D, and Sketch 64 illustrated
    how to create curves, like a track that a simulated car could drive on. Computer
    driving games often have automated vehicles that compete with the player, giving
    the impression of being a real opponent. This sketch will implement a system for
    computer-controlled cars that is similar to the methods used in those computer
    games.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 草图60允许用户在3D赛道上驾驶，草图64展示了如何创建曲线，比如模拟汽车可以驾驶的赛道。计算机驾驶游戏通常有自动化的车辆与玩家竞争，给人一种真实对手的印象。这个草图将实现一个类似于那些计算机游戏中使用的方法的计算机控制汽车系统。
- en: It’s important to realize that games and simulations do not necessarily do things
    the way people do. A human driver would orient the car based on the next turn
    they could see and would steer continually to remain on the track. We could build
    a computer program to do this too, but it would be pretty complicated. Another
    option is to use predetermined knowledge about the track to steer the vehicle.
    In this case, the programmer has to provide more information to the program at
    the outset, but the resulting simplicity in the code is worth the effort.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，游戏和模拟不一定像人类一样做事情。人类驾驶员会根据他们看到的下一个转弯来调整汽车的方向，并不断地转动方向盘以保持在车道上。我们也可以编写一个计算机程序来实现这一点，但这会相当复杂。另一种选择是使用关于赛道的预设知识来控制车辆。在这种情况下，程序员必须在一开始就为程序提供更多信息，但代码的简洁性弥补了这一努力。
- en: To be specific, the programmer breaks up the track into linear pieces. The linear
    pieces should be as long as possible and join to each other at vertices called
    waypoints, places where the direction of the line, and hence the car, changes.
    (We can dissect any curve this way.) Each waypoint has a number or a label assigned
    by the programmer. When the car is at waypoint 1, the program will change its
    direction of motion to move toward waypoint 2\. When it arrives at waypoint 2,
    it will steer to waypoint 3\. Because the segments are lines, we don’t need to
    steer between waypoints.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，程序员将赛道分解成线性段。线性段应该尽可能长，并在称为路标的顶点处连接，路标是线的方向发生变化的地方，也是汽车改变方向的地方。（我们可以以这种方式分解任何曲线。）每个路标都有一个编号或标签，由程序员分配。当汽车到达路标1时，程序将改变其运动方向，朝向路标2移动。当它到达路标2时，它将转向路标3。由于这些段是直线的，因此我们不需要在路标之间转向。
- en: 'This sketch implements waypoints as a collection of arrays, each array containing
    one dimension of the waypoints. The location of waypoint `i` is in the array locations
    `wpx[i]` and `wpy[i]` 1. In a more accurate simulation, a waypoint would have
    much more information associated with it: changes in speed and acceleration, rate
    of change of the turn, and perhaps graphical information like brake lights turning
    on. In the current sketch, the only other thing needed is the angle between the
    current and the next waypoint so that we can rotate the car to face the new direction.
    We could calculate this, but it would take more code, and the positions of the
    waypoints and the angles between them can be determined in advance. We declare
    arrays `wpx`, `wpy`, and `wpa` 2 and initialize them with the position and angle
    data, which implicitly defines the size of the arrays. (It is not possible to
    both specify the size of an array using a number and initialize it using data.)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本草图将路径点实现为一个数组集合，每个数组包含路径点的一个维度。路径点 `i` 的位置存储在数组 `wpx[i]` 和 `wpy[i]` 中。在更精确的模拟中，路径点会关联更多信息：速度和加速度的变化、转弯的变化率，甚至可能包括一些图形信息，比如刹车灯的亮起。在当前草图中，唯一需要的其他信息是当前路径点和下一个路径点之间的角度，这样我们就能旋转车辆，使其朝向新的方向。我们本可以计算这个角度，但这会需要更多的代码，而路径点的位置和它们之间的角度可以预先确定。我们声明了数组
    `wpx`、`wpy` 和 `wpa`，并用位置和角度数据初始化它们，这也隐含地定义了数组的大小。（不能同时使用数字指定数组大小并通过数据初始化它。）
- en: 'Using the vehicle’s assigned `speed` (changed using W and S), we compute its
    position change during each frame as `dx = speed * ( wpx(i+1) - wpx(i) )/d(i,i+1)`where
    `d(i,i+1)` is the distance between waypoints `i` and `i+1` 4. We say that the
    vehicle has arrived at waypoint `i` when it is within `speed` pixels of it, at
    which point it changes direction and aims for the next waypoint, `i+1` 3. The
    `wayPoint` variable indicates the last waypoint encountered, meaning that the
    vehicle is aiming for `wayPoint+1`. The waypoint count wraps around at the end,
    so we increment modulo-*N* where *N* is the number of waypoints: the waypoint
    following *N* is 0.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用车辆的指定 `speed`（通过 W 和 S 键更改），我们计算其每帧的位移变化为 `dx = speed * ( wpx(i+1) - wpx(i)
    )/d(i,i+1)`，其中 `d(i,i+1)` 是路径点 `i` 和 `i+1` 之间的距离。我们说车辆到达路径点 `i` 时，它距离该点的像素数在 `speed`
    范围内，此时它会改变方向，瞄准下一个路径点 `i+1`。`wayPoint` 变量表示最后到达的路径点，意味着车辆正在瞄准 `wayPoint+1`。路径点计数会在末尾环绕，因此我们按模
    *N* 递增，其中 *N* 是路径点的数量：路径点 *N* 之后的路径点是 0。
- en: Pressing the spacebar allows the user to see where the waypoints and paths are.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 按下空格键可以让用户查看路径点和路径的位置。
- en: 'Sketch 66: Many Small Objects—A Snowstorm'
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 66：许多小物体——一场雪暴
- en: A Processing program redraws the screen many times each second. Visible objects
    must be redrawn in each frame, and to do so the program must save the graphical
    parameters (size, location, shape, and color) of all of them. Drawing each object
    takes time, so if there are many, is it still possible to redraw them all quickly
    enough? In many cases it is, if the objects themselves are not complex. This sketch
    will draw snow falling, with each snowflake being an object that moves realistically
    between frames.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Processing 程序每秒钟会重绘多次屏幕。每一帧中，屏幕上的可见物体都需要被重新绘制，为了做到这一点，程序必须保存所有物体的图形参数（大小、位置、形状和颜色）。绘制每个物体需要时间，那么如果物体很多，是否仍然能够足够快地重绘它们？在许多情况下，如果物体本身不复杂，是完全可能的。本草图将绘制雪花飘落，每一片雪花都是一个物体，它在每一帧之间会真实地移动。
- en: Snowflakes are, in fact, very complex shapes, but from a distance they are just
    white blobs. We’ll draw them as small rectangles whose width and height vary by
    a small random value each frame to simulate the effect of the snowflake fluttering
    as it falls 1. We set the dimensions with the formula `width = size + random(3)-1.5`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 雪花实际上是非常复杂的形状，但从远处看，它们只是白色的斑块。我们将它们绘制为小矩形，每一帧的宽度和高度都会略微随机变化，以模拟雪花在下落过程中轻微飘动的效果。我们通过公式
    `width = size + random(3)-1.5` 来设置尺寸。
- en: '`size` is a constant set to `3`, and the value of `random(3)` is a number between
    0 and 3, so `random(3)-1.5` will have a value between −1.5 and +1.5, creating
    a change in the size between 1.5 and 4.5\. Each snowflake also has a slightly
    different falling speed 5. This gives the illusion of depth because flakes that
    fall faster appear nearer to the viewer than ones that fall slower. The speed
    is selected at random, but it yields the desired effect.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`size` 是一个常量，设置为 `3`，而 `random(3)` 的值是介于 0 和 3 之间的一个数字，因此 `random(3)-1.5` 的值将介于
    −1.5 和 +1.5 之间，从而导致大小在 1.5 和 4.5 之间变化。每个雪花的下落速度也略有不同。这种差异造成了深度的假象，因为下落更快的雪花看起来离观察者更近，而下落较慢的雪花则更远。速度是随机选择的，但它达到了预期的效果。'
- en: 'The program creates snowflakes at the top of the screen and gives them a downward
    (+y) speed, which will make them appear to fall. To track the position, size,
    and speed in both the x- and y-directions, we use arrays: for example, the array
    `x` stores the x position, and `x[i]` is the x location of the `i`^(th) snowflake.
    The array size, given by the constant `SIZE`, is the maximum number of snowflakes.
    (The value here is 5,000, found by trial and error based on the observed number
    needed given the background and the maximum rate of snowfall.)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会在屏幕顶部生成雪花，并给它们设置一个向下（+y）速度，这样它们看起来就会下落。为了追踪每片雪花的位置信息、大小和速度（在 x 和 y 方向上），我们使用数组：例如，数组
    `x` 存储 x 位置，`x[i]` 是第 `i` 个雪花的 x 位置。数组大小由常量 `SIZE` 给出，表示最大雪花数量。（这个值是 5,000，是通过试验和误差，根据观察到的背景和最大降雪速率确定的。）
- en: Snow does not normally fall straight down; we observe it drifting and floating
    with air currents. The speed at which the snowflakes fall remains constant, but
    the x position of each flake changes a bit at random as it falls to try to give
    the illusion of real snow 2. If we set `dx` to a nonzero value, it simulates a
    wind, and snow will blow in the specified direction.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 雪花通常不会垂直下落；我们看到它们随着气流飘动和漂浮。雪花下落的速度保持不变，但每片雪花的 x 位置会在下落过程中随机变化一些，以模拟真实的雪花效果。如果我们将
    `dx` 设置为非零值，它就模拟了风的作用，雪花将会在指定的方向上吹动。
- en: 'Each frame, we generate up to 30 new snowflakes with random horizontal positions
    and y-coordinates of 0 4 (at the top of the window, to maintain the illusion).
    The number of snowflakes created during each frame is random but is a function
    of the y position of the mouse 3. The nearer the mouse is to the top of the screen,
    the less snow will appear to fall. This is the number of flakes created:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每一帧，我们生成最多 30 片新的雪花，随机设置它们的横向位置和 y 坐标为 0 4（位于窗口顶部，以保持假象）。每帧生成的雪花数量是随机的，但它与鼠标的
    y 位置有关。鼠标越接近屏幕顶部，看到的雪花就越少。以下是生成的雪花数量：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This means that almost no flakes will fall for small values of `mouseY`, while
    the maximum of up to 30 new snowflakes during each frame occurs when `mouseY/height`
    is at its maximum of 1.0.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，对于小的 `mouseY` 值，几乎没有雪花会落下，而当 `mouseY/height` 达到最大值 1.0 时，每帧会最多生成 30 片新的雪花。
- en: The global variable `SIZE` has a value of 5,000, which is the number of snowflakes
    that can be on the screen at any time. Initially there are only a few, but the
    array will fill up quickly. When all 5,000 array elements are occupied, we start
    over again at 0, assuming that the snowflakes at the beginning of the array have
    fallen past the bottom of the screen and are not visible. This technique is referred
    to as a circular array.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量 `SIZE` 的值为 5,000，这是屏幕上可以同时显示的最大雪花数量。最初只有几个雪花，但数组会迅速填满。当所有 5,000 个数组元素被占用时，我们会从
    0 开始重新计数，假设数组开始位置的雪花已经掉过屏幕底部并且不可见。这个技术被称为循环数组。
- en: 'Sketch 67: Particle Graphics—Smoke'
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 67：粒子图形—烟雾
- en: 'Some things are difficult to model using polygons: soft and amorphous shapes
    like water, fire, clouds, and smoke, for example. Such things can move in unpredictable
    ways and expand to fill arbitrary shapes. This sketch will draw smoke emitting
    from a smokestack and illustrate a key method in modern computer graphics: a particle
    system.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有些东西用多边形建模很困难，例如水、火、云和烟雾等柔软且无定形的物体。这些物体的运动方式不可预测，并且可以扩展以填充任意形状。这个草图将绘制从烟囱中冒出的烟雾，并展示现代计算机图形学中的一个关键方法：粒子系统。
- en: 'A particle system combines a large number of small objects to form a complex
    shape. The objects are usually simple, like spheres or circles, and have a set
    of parameters that control their display. The basic parameters of a circle are
    position, velocity, color, and size. Initial parameters usually have a random
    element: speed plus or minus a random number, for example. An emitter is the location
    where the system creates new particles (circles), usually with a small, random
    displacement, so the particles aren’t exactly at the emitter.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统将大量小物体组合起来，形成复杂的形状。这些物体通常很简单，比如球体或圆形，并具有一组控制其显示的参数。圆形的基本参数包括位置、速度、颜色和大小。初始参数通常包含随机元素，例如速度加上或减去一个随机数。发射器是系统创建新粒子（圆形）的地方，通常带有一个小的随机位移，这样粒子就不会完全位于发射器位置。
- en: The particle system in this sketch produces a large number of overlapping circles,
    possibly somewhat transparent, moving with slightly different speeds (not unlike
    the previous sketch except for density). The previous sketch drew a large number
    of small objects that could still be seen as individual snowflakes. In this sketch,
    if enough of these particles exist, we can’t distinguish them individually, and
    they form an object in combination. As the number increases and the objects overlap,
    the result looks like fog or smoke.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图中的粒子系统生成了大量重叠的圆形，这些圆形可能是半透明的，以略微不同的速度移动（与之前的草图相比，唯一不同的是密度）。之前的草图绘制了大量小物体，仍然可以看作是单独的雪花。而在这个草图中，如果粒子的数量足够多，我们就无法区分它们的个体，它们会组合成一个物体。随着数量的增加和物体的重叠，结果看起来像雾气或烟雾。
- en: 'The sketch defines a large number of circles to be created (`SIZE`) and declares
    arrays to hold the position, speed, and size of each one: the value of `x[121]`
    is the x position of the 121st circle, for example. Initially there are none,
    and the variable `last` holds the index of the last one defined. We increment
    `last` each frame as we create new circles, and we reset it to zero when the number
    exceeds `SIZE`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该草图定义了要创建的大量圆形（`SIZE`），并声明了数组来保存每个圆形的位置、速度和大小。例如，`x[121]`的值表示第121个圆形的x位置。初始时没有圆形，变量`last`保存最后一个定义的圆形的索引。每一帧我们创建新的圆形时都会增加`last`的值，当圆形的数量超过`SIZE`时，我们会将其重置为零。
- en: The `draw()` function first runs through the arrays and draws each circle that
    exists (meaning `x[i] > 0`) 1. It changes the circle’s position by a small random
    amount, may change the size slightly, and gives it a color that varies around
    RGB = (205, 205, 150). It then creates a random number of new circles, giving
    them positions near the emitter, a vertical speed, and a small size 2.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw()`函数首先遍历数组，绘制每一个存在的圆形（意味着`x[i] > 0`）1。它会将圆形的位置稍微改变，可能会略微改变大小，并赋予它一个围绕RGB
    = (205, 205, 150)变化的颜色。然后，它会创建一个随机数量的新圆形，赋予它们靠近发射器的位置、垂直的速度和一个较小的大小2。'
- en: The effect is striking. With up to 800 circles, the system yields a remarkably
    good impression of smoke moving upward. The sketch reads and displays a background
    image of a smokestack for a better visual effect.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 效果非常引人注目。通过多达800个圆形，系统能极好地模拟烟雾向上升腾的效果。该草图展示并呈现了一个烟囱的背景图，以增强视觉效果。
- en: The outline around the circles has been turned off with `noStroke()`, but it
    is educational to delete that statement and run the program so that the particles
    can be seen. The way the particles move and overlap is clearer, as in [Figure
    67-1](#figure67-1).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形的轮廓已经通过`noStroke()`关闭，但将该语句删除并运行程序，可以看到粒子的形态。这样，粒子的移动和重叠变得更加清晰，如[图67-1](#figure67-1)所示。
- en: '![f067001](Images/f067001.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![f067001](Images/f067001.png)'
- en: 'Figure 67-1: Particles showing the outline of the circles'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图67-1：粒子显示圆形的轮廓
- en: 'Sketch 68: Saving a State—A Spinning Propeller'
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 68：保存状态——旋转螺旋桨
- en: This sketch will draw a spinning propeller. We can code this in many ways, some
    of them simpler than the method in this sketch, but the purpose here is to use
    a simple example to explain how and why to save (and restore) the geometric state
    of a sketch.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图将绘制一个旋转的螺旋桨。我们可以用多种方式编写代码，有些方式比这个草图中的方法更简单，但这里的目的是通过一个简单的例子来解释如何以及为什么要保存（和恢复）草图的几何状态。
- en: The geometric state is the resultant combination of all the translation, rotation,
    and scaling that accumulate during the display of an object up to a specific point
    in the drawing process. Rotating an object about its center means first translating
    the origin to the center of the object, doing the rotation, and then translating
    the origin back to the original location. If the state is not restored by undoing
    the translation, then all objects drawn from that time on will translate to the
    location of the object.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 几何状态是所有平移、旋转和缩放的结果组合，这些操作在绘制过程中的某一特定时刻累积。围绕物体的中心旋转意味着首先将原点平移到物体的中心，进行旋转，然后再将原点平移回原位置。如果不通过撤销平移来恢复状态，那么从此时起绘制的所有物体都会平移到该物体的位置。
- en: 'The current state, whatever it is, including all rotation, translation, and
    scaling, is saved using a call to the function `pushMatrix()` and is restored
    by a call to `popMatrix()`. These calls must always occur in pairs, like brackets;
    a call to `pushMatrix()` always has a corresponding call to `popMatrix()`. For
    example, you could save and restore state while rotating a triangle about its
    center at (100, 100), shown in [Figure 68-1](#figure68-1), as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当前状态，无论是什么，包括所有的旋转、平移和缩放，都是通过调用函数`pushMatrix()`来保存的，并通过调用`popMatrix()`来恢复。这些调用必须始终成对出现，就像括号一样；调用`pushMatrix()`总是有一个对应的`popMatrix()`调用。例如，您可以在围绕(100,
    100)的中心旋转一个三角形时，保存并恢复状态，如[图68-1](#figure68-1)所示，代码如下：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At this point, the origin and rotation angle are back to their original values,
    and the next object can be drawn from a clean state.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，原点和旋转角度已恢复到原始值，接下来可以从一个干净的状态绘制下一个物体。
- en: 'This sketch draws a propeller with four sections, each being one blade, which
    is an image. We draw this blade four times: once in the original orientation,
    and then three times each rotated about the propeller center point by 90 degrees
    1. Each section drawn uses a save and restore:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图绘制了一个四部分的螺旋桨，每个部分是一片刀片，即一张图片。我们绘制这片刀片四次：一次是原始方向，然后是围绕螺旋桨中心点每次旋转90度，共三次。每个部分的绘制都使用了保存和恢复状态：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The four-section propeller is drawn inside a `drawProp(x,y)` function that saves
    the state on entering the function, then translates to (`x`, `y`), scales the
    image, rotates it, updates the angle so the next call to `drawProp()` draws the
    propeller at a different angle 2, and draws the four sections. We use multiple
    calls to the `drawProp()` function to draw a rotating propeller at multiple locations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个四部分的螺旋桨绘制在一个`drawProp(x, y)`函数中，该函数在进入时保存状态，然后平移到(`x`, `y`)，缩放图像，旋转图像，更新角度，以便下次调用`drawProp()`时绘制出不同角度的螺旋桨，并绘制四个部分。我们通过多次调用`drawProp()`函数，在多个位置绘制旋转中的螺旋桨。
- en: '![f068001](Images/f068001.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![f068001](Images/f068001.png)'
- en: 'Figure 68-1: The transformations needed to rotate an object about its center'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图68-1：围绕物体中心旋转所需的变换
- en: 'Sketch 69: L-Systems—Drawing Plants'
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图69：L系统——绘制植物
- en: Drawing realistic-looking plants is difficult. Living things do not usually
    contain straight lines, which is what computers draw best. In addition, there
    is a random nature to life forms that humans recognize, so we are critical of
    renderings. In 1968 a botanist named Aristid Lindenmayer developed a scheme for
    describing the growth of fungi and algae, and then later expanded it to deal with
    more advanced plant life. This was in turn adapted by computer graphics practitioners
    into a scheme for drawing plants. We call this scheme an L-system.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制逼真的植物是困难的。生物体通常没有直线，而直线是计算机最擅长绘制的形状。此外，生命形式有一种人类能够识别的随机性，因此我们对渲染的结果会产生批判。1968年，一位名叫阿里斯蒂德·林登梅耶的植物学家开发了一种描述真菌和藻类生长的方案，后来将其扩展到处理更高级的植物生命。此方案随后被计算机图形学从业者改编成一种绘制植物的方案。我们称这种方案为L系统。
- en: 'An L-system is technically a grammar, which is a set of rules for making strings.
    If a grammar has two rules, X -> Xf and X -> z, then it is showing how to take
    a symbol, X, and transform it into a sequence of characters. For each X, we choose
    which replacement rule to follow, and we continue replacing capital Xs (referred
    to as non-terminal symbols) until there are no more left to replace. Here’s an
    example expansion for this grammar: X -> Xf -> Xff -> Xfff -> zfff.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: L系统在技术上是一种语法，是一组用于生成字符串的规则。如果语法有两条规则，X -> Xf 和 X -> z，那么它就展示了如何将一个符号X转换成一个字符序列。对于每个X，我们选择遵循哪个替换规则，并继续替换大写X（称为非终结符号），直到没有更多可以替换的X。以下是该语法的一个扩展示例：X
    -> Xf -> Xff -> Xfff -> zfff。
- en: 'In an L-system, a grammar that can define a plant, the final string represents
    a recipe for drawing something. It uses the following symbols:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在L系统中，一种可以定义植物的文法，最终的字符串代表着绘制某物的配方。它使用以下符号：
- en: f Draw a straight line segment.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: f 绘制一条直线段。
- en: '[ Save the current state (`pushMatrix()`).'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[ 保存当前状态（`pushMatrix()`）。'
- en: '] Go back to the previous state (`popMatrix()`).'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '] 返回到先前的状态（`popMatrix()`）。'
- en: + Rotate by a fixed positive angle.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: + 按固定的正角度旋转。
- en: '- Rotate by a fixed negative angle.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '- 按固定的负角度旋转。'
- en: 'The grammar uses two rules to produce a string of these symbols:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该文法使用两个规则来生成这些符号的字符串：
- en: X -> ff
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: X -> ff
- en: X -> f–[[X]+X]+f[+fX]–X
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: X -> f–[[X]+X]+f[+fX]–X
- en: Unless the plant consists of only two straight lines (ff), the first step would
    be X –> f–[[X]+X]+f[+fX]–X. Then each X would be replaced by the right side of
    a production, so the second step might be f–[[X]+X]+f[+fX]–X –> f–[[ f–[[X]+X]+f[+fX]–X]+ff]+f[+ff]–ff,
    followed perhaps by f–[[ f–[[ff]+ff]+f[+fff]–ff]+ff]+f[+ff]–ff, which can now
    be drawn.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除非植物只包含两条直线（ff），否则第一步将是 X –> f–[[X]+X]+f[+fX]–X。然后，每个X将被替换为产生式的右侧，因此第二步可能是 f–[[X]+X]+f[+fX]–X
    –> f–[[ f–[[X]+X]+f[+fX]–X]+ff]+f[+ff]–ff，接下来可能是 f–[[ f–[[ff]+ff]+f[+fff]–ff]+ff]+f[+ff]–ff，现在可以绘制了。
- en: The `makeString()` function 1 calls itself to expand the non-terminal X symbols
    into strings and append these to the string being constructed. It will only call
    itself to a depth specified by the first parameter, `levels`, and will then return,
    thus guaranteeing that the program will eventually end. The string generated by
    the grammar is passed to the `drawPlant()` function 2, which executes each character
    as a graphical operation, thus drawing the plant. In the function `void` `drawPlant(float
    length, float angle, String s, int drawLevel)`, the first parameter, `length`,
    is the length of the line to draw (for the symbol f); the `angle` is the rotation
    angle for the + and - characters; `s` is the string generated by `makeString()`;
    and `drawLevel` indicates a depth level for drawing lines. Essentially, `makeString()`
    creates a string that is a program for how to draw the plant, and `drawPlant()`
    executes that program.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeString()`函数1会调用自身，将非终结符号X展开为字符串，并将这些字符串附加到正在构建的字符串上。它只会根据第一个参数`levels`指定的深度调用自身，然后返回，从而保证程序最终会结束。文法生成的字符串传递给`drawPlant()`函数2，后者将每个字符作为图形操作执行，从而绘制植物。在`void
    drawPlant(float length, float angle, String s, int drawLevel)`函数中，第一个参数`length`是绘制直线段的长度（对于符号f）；`angle`是+和-字符的旋转角度；`s`是由`makeString()`生成的字符串；`drawLevel`表示绘制线条的深度级别。本质上，`makeString()`创建了一个绘制植物的程序字符串，而`drawPlant()`执行这个程序。'
- en: 'Sketch 70: Warping an Image'
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例图70：图像的变形
- en: In 1991 the general public saw morphing for the first time, an effect that uses
    a computer to smoothly convert one image into another. The computer produces a
    small sequence of images so that, when played back as a video sequence, an object
    appears to continuously change shape to become the other. The film *Terminator
    2* used it and, probably most strikingly, the Michael Jackson music video for
    the song “Black or White” used it in a sequence where faces morphed into one another.
    This sketch performs a warp or bending of an image, but does not do a complete
    morph.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 1991年，公众首次见到了形态变换效果，这是一种利用计算机平滑地将一幅图像转换成另一幅图像的效果。计算机生成一小段图像序列，当这些图像以视频序列回放时，一个物体似乎会不断地改变形状，直到变成另一个物体。电影《终结者2》使用了这一效果，最具代表性的是迈克尔·杰克逊的《黑白》音乐视频，其中人物的面孔相互变形。这段示意图执行的是图像的弯曲或变形，但并没有进行完全的形态变换。
- en: The principle underlying the morphing method is something called a polynomial
    warp. Imagine we place an image over a regular grid and then bend the grid using
    a mathematical function and take the image with it. The result is an image that
    changes in a particular way—a warp. Morphing between two images requires that
    we establish a correspondence between the image, usually by a human. A function
    bends (maps) one image into another (a warp) while the pixel color values change
    systematically from the source to the destination values.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 形态变换方法的原理是所谓的多项式变形。假设我们将图像放置在一个常规网格上，然后使用数学函数弯曲网格并将图像一同弯曲。结果是图像以特定的方式发生变化——变形。两个图像之间的形态变换要求我们建立图像之间的对应关系，通常由人工完成。一个函数将（映射）一幅图像变形为另一幅图像（变形），而像素的颜色值会系统性地从源值变到目标值。
- en: If the image is a face and the warp is based on a sine curve, we get an effect
    that looks like a funhouse mirror, as shown in [Figure 70-1](#figure70-1). The
    geometry of the original face bends (maps) into that of the new one according
    to the function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图像是一张人脸，并且扭曲基于正弦曲线，那么我们会得到一种像是镜厅效果的视觉效果，如[图 70-1](#figure70-1)所示。原始人脸的几何形状会根据函数变形（映射）到新的人脸几何形状。
- en: '![f070001](Images/f070001.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![f070001](Images/f070001.png)'
- en: 'Figure 70-1: Warping a face'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 70-1：扭曲人脸
- en: 'This sketch implements an image warp. We read an image and display the pixels
    according to a sine function transformation of coordinates. The original image
    is `source`, and this is the mapping between original and new pixel coordinates:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图实现了图像的扭曲。我们读取一张图像，并根据正弦函数变换坐标来显示像素。原始图像是`source`，这是原始和新像素坐标之间的映射：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This mapping is arbitrary, chosen for an amusing effect. The loop that does
    the mapping 2 has to map pixel values from the destination back to the source,
    not the other way around. Each pixel in the source does correspond to a pixel
    in the destination, but there may be unmapped pixels in the result if we do the
    mapping the other way. So for each pixel `(x,y)` in the destination image, we
    transform it to `(newX, newY)` values using the desired function and then find
    the corresponding pixel in the source image. We then set the destination `(x,y)`
    to the source `(newX, newY)`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个映射是任意选择的，目的是为了创造有趣的效果。执行映射的循环2必须将目标像素值映射回源像素，而不是反过来。如果我们反向映射，源图像中的每个像素确实对应目标图像中的一个像素，但结果中可能会出现未映射的像素。因此，对于目标图像中的每个像素`(x,y)`，我们使用所需的函数将其转换为`(newX,
    newY)`值，然后找到源图像中对应的像素。接着，我们将目标图像中的`(x,y)`像素设置为源图像中的`(newX, newY)`。
- en: In the sketch, the values of `ds` and `size` are parameters to the transformation
    function, and they change slightly each frame 1, creating a cyclical change in
    the image that a person will perceive as an animation of the bending or warping
    motion.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个草图中，`ds`和`size`的值是变换函数的参数，它们每一帧都会略微变化1，从而在图像中创造出一个周期性的变化，这种变化会被人眼感知为弯曲或扭曲的动画效果。
