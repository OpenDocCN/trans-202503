- en: Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 常量、变量和数据类型
- en: '![CONSTANTS, VARIABLES, AND DATA TYPES](tagoreillycom20100401nostarchimages577853.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![常量、变量和数据类型](tagoreillycom20100401nostarchimages577853.png.jpg)'
- en: '[Chapter 2](ch02.html "Chapter 2. DATA REPRESENTATION") discussed the basic
    format for data in memory. [Chapter 3](ch03.html "Chapter 3. MEMORY ACCESS AND
    ORGANIZATION") covered how a computer system physically organizes that data in
    memory. This chapter finishes the discussion by connecting the concept of *data
    representation* to its actual physical representation. As the title implies, this
    chapter concerns itself with three main topics: constants, variables, and data
    structures. This chapter does not assume that you''ve had a formal course in data
    structures, though such experience would be useful.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章 数据表示")讨论了内存中数据的基本格式。[第3章](ch03.html "第3章 内存访问与组织")介绍了计算机系统如何在物理上组织这些数据。本章通过将
    *数据表示* 与其实际物理表示连接起来，完成了讨论。正如标题所示，本章主要涉及三个主题：常量、变量和数据结构。本章并不假设你已经接受过正式的数据结构课程，尽管这样的经验会有所帮助。'
- en: This chapter discusses how to declare and use constants, scalar variables, integers,
    data types, pointers, arrays, records/structures, unions, and namespaces. You
    must master these subjects before going on to the next chapter. Declaring and
    accessing arrays, in particular, seems to present a multitude of problems to beginning
    assembly language programmers. However, the rest of this text depends on your
    understanding of these data structures and their memory representation. Do not
    try to skim over this material with the expectation that you will pick it up as
    you need it later. You will need it right away, and trying to learn this material
    along with later material will only confuse you more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论如何声明和使用常量、标量变量、整数、数据类型、指针、数组、记录/结构体、联合体和命名空间。在进入下一章之前，必须掌握这些内容。特别是声明和访问数组似乎给初学汇编语言的程序员带来了很多问题。然而，本文的其余部分依赖于你对这些数据结构及其内存表示的理解。不要抱有以后慢慢学到这些内容的期望，试图跳过这些材料会让你感到困惑。你马上就会用到这些内容，试图与后续的内容一起学习只会增加困惑。
- en: '4.1 Some Additional Instructions: intmul, bound, into'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1 一些额外的指令：intmul、bound、into
- en: This chapter introduces arrays and other concepts that will require the expansion
    of your 80x86 instruction set knowledge. In particular, you will need to learn
    how to multiply two values; hence the first instruction we will look at is the
    `intmul` (integer multiply) instruction. Another common task when accessing arrays
    is to check to see if an array index is within bounds. The 80x86 `bound` instruction
    provides a convenient way to check a register's value to see if it is within some
    range. Finally, the `into` (interrupt on overflow) instruction provides a quick
    check for signed arithmetic overflow. Although `into` isn't really necessary for
    array (or other data type) access, its function is very similar to `bound`; hence
    the presentation of it at this point.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了数组和其他需要扩展你对 80x86 指令集知识的概念。特别是，你需要学习如何将两个值相乘；因此我们首先要介绍的是 `intmul`（整数乘法）指令。另一个在访问数组时常见的任务是检查数组索引是否在范围内。80x86
    的 `bound` 指令提供了一种方便的方式，检查寄存器的值是否在某个范围内。最后，`into`（溢出时中断）指令提供了一种快速检查有符号算术溢出的方法。虽然在数组（或其他数据类型）访问中并不一定需要
    `into`，但它的功能与 `bound` 非常相似，因此在这一点上介绍它。
- en: 'The `intmul` instruction takes one of the following forms:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`intmul` 指令有以下几种形式：'
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the syntax of the `intmul` instruction is different from that of the
    `add` and `sub` instructions. In particular, the destination operand must be a
    register (`add` and `sub` both allow a memory operand as a destination). Also
    note that `intmul` allows three operands when the first operand is a constant.
    Another important difference is that the `intmul` instruction allows only 16-bit
    and 32-bit operands; it does not multiply 8-bit operands.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`intmul` 指令的语法与 `add` 和 `sub` 指令不同。特别是，目标操作数必须是寄存器（`add` 和 `sub` 都允许内存操作数作为目标）。还要注意，当第一个操作数是常量时，`intmul`
    允许三个操作数。另一个重要的区别是，`intmul` 指令仅允许 16 位和 32 位操作数；它不支持 8 位操作数的乘法。
- en: intmul computes the product of its specified operands and stores the result
    into the destination register. If an overflow occurs (which is always a signed
    overflow, because `intmul` multiplies only signed integer values), then this instruction
    sets both the carry and overflow flags. `intmul` leaves the other condition code
    flags undefined (so, for example, you cannot meaningfully check the sign flag
    or the zero flag after executing `intmul`).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`intmul` 计算指定操作数的乘积并将结果存储到目标寄存器中。如果发生溢出（这总是一个有符号溢出，因为 `intmul` 仅乘以有符号整数值），那么此指令会设置进位标志和溢出标志。`intmul`
    会使其他条件码标志未定义（例如，执行 `intmul` 后你不能有意义地检查符号标志或零标志）。'
- en: 'The `bound` instruction checks a 16-bit or 32-bit register to see if it is
    between two values. If the value is outside this range, the program raises an
    exception and aborts. This instruction is particularly useful for checking to
    see if an array index is within a given range. The `bound` instruction takes one
    of the following forms:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`bound` 指令检查 16 位或 32 位寄存器，查看它是否在两个值之间。如果该值超出此范围，程序会引发异常并中止。此指令特别适用于检查数组索引是否在给定范围内。`bound`
    指令有以下几种形式：'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `bound` instruction compares its register operand against an unsigned lower
    bound value and an unsigned upper bound value to ensure that the register is in
    the range:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`bound` 指令将其寄存器操作数与无符号下界值和无符号上界值进行比较，以确保寄存器的值在范围内：'
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The form of the `bound` instruction with three operands compares the register
    against the second and third parameters (the lower bound and upper bound, respectively).^([[47](#ftn.CHP-4-FN-1)])
    The `bound` instruction with two operands checks the register against one of the
    following ranges:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 带有三个操作数的 `bound` 指令将寄存器与第二和第三个参数（分别是下界和上界）进行比较。^([[47](#ftn.CHP-4-FN-1)]) 带有两个操作数的
    `bound` 指令将寄存器与以下一个范围进行比较：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the specified register is not within the given range, then the 80x86 raises
    an exception. You can trap this exception using the HLA `try..endtry` exception-handling
    statement. The *excepts.hhf* header file defines an exception, `ex.BoundInstr`,
    specifically for this purpose. The program in [Example 4-1](ch04.html#demonstration_of_the_bound_instruction
    "Example 4-1. Demonstration of the bound instruction") demonstrates how to use
    the `bound` instruction to check some user input.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定的寄存器不在给定范围内，则 80x86 会引发异常。你可以使用 HLA 的 `try..endtry` 异常处理语句捕获此异常。*excepts.hhf*
    头文件为此目的定义了一个异常 `ex.BoundInstr`。[示例 4-1](ch04.html#demonstration_of_the_bound_instruction
    "示例 4-1. `bound` 指令的演示") 程序展示了如何使用 `bound` 指令检查某些用户输入。
- en: Example 4-1. Demonstration of the `bound` instruction
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-1. `bound` 指令的演示
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `into` instruction, like `bound`, also generates an exception under certain
    conditions. Specifically, `into` generates an exception if the overflow flag is
    set. Normally, you would use `into` immediately after a signed arithmetic operation
    (e.g., `intmul`) to see if an overflow occurs. If the overflow flag is not set,
    the system ignores `into`; however, if the overflow flag is set, then the `into`
    instruction raises the `ex.IntoInstr` exception. The program in [Example 4-2](ch04.html#demonstration_of_the_into_instruction
    "Example 4-2. Demonstration of the into instruction") demonstrates the use of
    the `into` instruction.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`into` 指令与 `bound` 指令类似，也会在某些条件下生成异常。具体而言，`into` 会在溢出标志被设置时生成异常。通常，你会在有符号算术操作（例如
    `intmul`）之后立即使用 `into` 来检查是否发生溢出。如果溢出标志未设置，系统会忽略 `into`；但是，如果溢出标志被设置，则 `into`
    指令会引发 `ex.IntoInstr` 异常。[示例 4-2](ch04.html#demonstration_of_the_into_instruction
    "示例 4-2. `into` 指令的演示") 程序演示了如何使用 `into` 指令。'
- en: Example 4-2. Demonstration of the `into` instruction
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-2. `into` 指令的演示
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '* * *'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[47](#CHP-4-FN-1)]) This form isn't a true 80x86 instruction. HLA converts
    this form of the bound instruction to the two-operand form by creating two `readonly`
    memory variables initialized with the specified constants.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[47](#CHP-4-FN-1)]) 这种形式并不是一个真正的 80x86 指令。HLA 会通过创建两个初始化为指定常量的 `readonly`
    内存变量，将这种形式的 `bound` 指令转换为双操作数形式。
- en: 4.2 HLA Constant and Value Declarations
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2 HLA 常量和数值声明
- en: HLA's `const` and `val` sections let you declare symbolic constants. The `const`
    section lets you declare identifiers whose value is constant throughout compilation
    and runtime; the `val` section lets you declare symbolic constants whose values
    can change at compile time but whose values are constant at runtime (that is,
    the same name can have a different value at several points in the source code,
    but the value of a `val` symbol at a given point in the program cannot change
    while the program is running).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 的 `const` 和 `val` 部分允许你声明符号常量。`const` 部分允许你声明在编译和运行时其值都恒定不变的标识符；`val` 部分允许你声明在编译时值可以变化，但在运行时值不变的符号常量（也就是说，相同的名称可以在源代码的不同地方有不同的值，但在程序运行时，`val`
    符号的值在特定的程序点不能改变）。
- en: 'The `const` section appears in the same area of your program as the `static`,
    `readonly`, `storage`, and `var` sections. It begins with the `const` reserved
    word and has a syntax that is nearly identical to the `readonly` section; that
    is, the `const` section contains a list of identifiers followed by a type and
    a constant expression. The following example will give you an idea of what the
    `const` section looks like:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` 部分出现在程序中的位置与 `static`、`readonly`、`storage` 和 `var` 部分相同。它以 `const`
    保留字开始，语法几乎与 `readonly` 部分相同；也就是说，`const` 部分包含一个标识符列表，后跟类型和常量表达式。以下示例将给你一个关于 `const`
    部分的基本概念：'
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once you declare these constants in this manner, you may use the symbolic identifiers
    anywhere the corresponding literal constant is legal. These constants are known
    as manifest constants. A *manifest constant* is a symbolic representation of a
    constant that allows you to substitute the literal value for the symbol anywhere
    in the program. Contrast this with `readonly` variables; a `readonly` variable
    is certainly a constant value because you cannot change such values at runtime.
    However, there is a memory location associated with `readonly` variables, and
    the operating system, not the HLA compiler, enforces the read-only attribute.
    Although it will certainly crash your program when it runs, it is perfectly legal
    to write an instruction like `mov( eax, ReadOnlyVar );`. On the other hand, it
    is no more legal to write `mov( eax, MaxIndex );` (using the declaration above)
    than it is to write `mov( eax, 15 );`. In fact, both of these statements are equivalent
    because the compiler substitutes `15` for `MaxIndex` whenever it encounters this
    manifest constant.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦以这种方式声明了这些常量，你可以在任何符号常量合法的地方使用这些符号标识符。这些常量被称为显式常量。*显式常量*是常量的符号表示，允许你在程序中的任何地方将字面值替换为符号。与
    `readonly` 变量进行对比；`readonly` 变量当然是常量值，因为在运行时你不能改变这些值。然而，`readonly` 变量有一个内存位置，操作系统，而不是
    HLA 编译器，强制执行只读属性。尽管在程序运行时，它肯定会导致程序崩溃，但写出像 `mov( eax, ReadOnlyVar );` 这样的指令是完全合法的。另一方面，写
    `mov( eax, MaxIndex );`（使用上面的声明）和写 `mov( eax, 15 );` 是一样不合法的。实际上，这两个语句是等效的，因为编译器在遇到这个显式常量时，会用
    `15` 替换 `MaxIndex`。
- en: 'If there is absolutely no ambiguity about a constant''s type, then you may
    declare a constant by specifying only the name and the constant''s value, omitting
    the type specification. In the example earlier, the `pi`, `Delimiter`, `MaxIndex`,
    and `DebugActive` constants could use the following declarations:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果常量的类型完全没有歧义，那么你可以仅指定名称和常量值来声明常量，省略类型说明。在之前的示例中，`pi`、`Delimiter`、`MaxIndex`
    和 `DebugActive` 常量可以使用以下声明：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Symbol constants that have an integer literal constant are always given the
    smallest possible unsigned type if the constant is zero or positive, or the smallest
    possible integer type (`int8`, `int16`, and so on) if the value is negative.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 具有整数字面常量的符号常量，如果常量为零或正数，则始终使用最小的无符号类型；如果值为负数，则使用最小的整数类型（`int8`、`int16` 等）。
- en: Constant declarations are great for defining "magic" numbers that might possibly
    change during program modification. The program in [Example 4-3](ch04s02.html#data_alignment_program_rewritten_using_c
    "Example 4-3. Data alignment program rewritten using const definitions") provides
    an example of using constants to parameterize "magic" values in the program. In
    this particular case, the program defines manifest constants for the amount of
    memory to allocate for the test, the (mis)alignment, and the number of loop and
    data repetitions. This program demonstrates the performance reduction that occurs
    on misaligned data accesses. Adjust the `MainRepetitions` constant if the program
    is too fast or too slow.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 常量声明非常适合定义可能在程序修改过程中发生变化的“魔法”数字。[示例 4-3](ch04s02.html#data_alignment_program_rewritten_using_c
    "示例 4-3. 使用 const 定义重写的数据对齐程序")中的程序展示了如何使用常量来参数化程序中的“魔法”值。在这个具体案例中，程序定义了清单常量来指定为测试分配的内存量、（错误的）对齐方式，以及循环和数据重复的次数。该程序展示了在数据访问未对齐时性能的下降。如果程序运行太快或太慢，可以调整
    `MainRepetitions` 常量。
- en: Example 4-3. Data alignment program rewritten using `const` definitions
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-3. 使用 `const` 定义重写的数据对齐程序
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 4.2.1 Constant Types
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.1 常量类型
- en: Manifest constants can be any of the HLA primitive types plus a few of the composite
    types this chapter discusses. [Chapter 1](ch01.html "Chapter 1. HELLO, WORLD OF
    ASSEMBLY LANGUAGE"), [Chapter 2](ch02.html "Chapter 2. DATA REPRESENTATION"),
    and [Chapter 3](ch03.html "Chapter 3. MEMORY ACCESS AND ORGANIZATION") discussed
    most of the primitive types; the primitive types include the following:^([[48](#ftn.CHP-4-FN-2)])
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 清单常量可以是任何 HLA 基本类型，以及本章讨论的一些复合类型。[第 1 章](ch01.html "第 1 章. 汇编语言的世界"), [第 2 章](ch02.html
    "第 2 章. 数据表示"), 和 [第 3 章](ch03.html "第 3 章. 内存访问与组织") 讨论了大多数基本类型；基本类型包括以下几种：^([[48](#ftn.CHP-4-FN-2)])
- en: '`boolean` constants (true or false)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean` 常量（true 或 false）'
- en: '`uns8` constants (0..255)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uns8` 常量（0..255）'
- en: '`uns16` constants (0..65,535)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uns16` 常量（0..65,535）'
- en: '`uns32` constants (0..4,294,967,295)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uns32` 常量（0..4,294,967,295）'
- en: '`int8` constants (−128..+127)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int8` 常量（−128..+127）'
- en: '`int16` constants (−32,768..+32,767)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int16` 常量（−32,768..+32,767）'
- en: '`int32` constants (−2,147,483,648..+2,147,483,647)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int32` 常量（−2,147,483,648..+2,147,483,647）'
- en: '`char` constants (any ASCII character with a character code in the range 0..255)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char` 常量（任何 ASCII 字符，字符代码范围为 0..255）'
- en: '`byte` constants (any 8-bit value including integers, booleans, and characters)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte` 常量（任何 8 位值，包括整数、布尔值和字符）'
- en: '`word` constants (any 16-bit value)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`word` 常量（任何 16 位值）'
- en: '`dword` constants (any 32-bit value)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dword` 常量（任何 32 位值）'
- en: '`real32` constants (floating-point values)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`real32` 常量（浮点值）'
- en: '`real64` constants (floating-point values)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`real64` 常量（浮点值）'
- en: '`real80` constants (floating-point values)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`real80` 常量（浮点值）'
- en: 'In addition to the constant types appearing above, the `const` section supports
    six additional constant types:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上面出现的常量类型外，`const` 部分还支持六种额外的常量类型：
- en: '`string` constants'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string` 常量'
- en: '`text` constants'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text` 常量'
- en: Enumerated constant values
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举常量值
- en: Array constants
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组常量
- en: Record/Union constants
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录/联合常量
- en: Character set constants
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符集常量
- en: These data types are the subject of this chapter, and the discussion of most
    of them appears a little later. However, the string and text constants are sufficiently
    important to warrant an early discussion of these constant types.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据类型是本章的主题，关于它们的大部分讨论稍后会出现。然而，字符串和文本常量足够重要，值得早期讨论这些常量类型。
- en: 4.2.2 String and Character Literal Constants
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.2 字符串和字符字面常量
- en: HLA, like most programming languages, draws a distinction between a sequence
    of characters, a *string*, and a single character. This distinction is present
    both in the type declarations and in the syntax for literal character and string
    constants. Until now, this text has not drawn a fine distinction between character
    and string literal constants; now is the time to do so.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 和大多数编程语言一样，区分字符序列（*字符串*）和单个字符。这一区别在类型声明和字面字符与字符串常量的语法中都存在。到目前为止，本书尚未对字符和字符串字面常量做出精细区分；现在是时候进行区分了。
- en: 'String literal constants consist of a sequence of zero or more characters surrounded
    by ASCII quote characters. The following are examples of legal literal string
    constants:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面常量由零个或多个字符组成，这些字符被 ASCII 引号字符包围。以下是合法的字面字符串常量的示例：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A string of length 1 is not the same thing as a character constant. HLA uses
    two completely different internal representations for character and string values.
    Hence, `"a"` is not a character; it is a string that just happens to contain a
    single character.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 长度为 1 的字符串与字符常量并不相同。HLA 对字符和字符串值使用了两种完全不同的内部表示方式。因此，`"a"` 不是一个字符；它是一个字符串，只不过恰好包含一个字符。
- en: 'Character literal constants take a couple forms, but the most common form consists
    of a single character surrounded by ASCII apostrophe characters:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 字符字面量常量有几种形式，但最常见的形式是由一个字符包围在 ASCII 撇号字符中：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As this section notes earlier, `"a"` and `'a'` are not equivalent.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节前面所述，`"a"` 和 `'a'` 并不等价。
- en: Those who are familiar with C, C++, or Java probably recognize these literal
    constant forms, because they are similar to the character and string constants
    in C/C++/Java. In fact, this text has made a tacit assumption to this point that
    you are somewhat familiar with C/C++ insofar as examples appearing up to this
    point use character and string constants without an explicit definition of them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 那些熟悉 C、C++ 或 Java 的人可能会认出这些字面常量形式，因为它们与 C/C++/Java 中的字符和字符串常量相似。事实上，到目前为止，本文已经默认假设你对
    C/C++ 有一定的了解，因为到目前为止的示例中使用了字符和字符串常量，而没有明确地对它们进行定义。
- en: Another similarity between C/C++ strings and HLA's is the automatic concatenation
    of adjacent literal string constants within your program. For example, HLA concatenates
    the two string constants
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 字符串和 HLA 字符串之间的另一个相似之处是自动连接程序中的相邻字面量字符串常量。例如，HLA 会将两个字符串常量连接起来
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: to form the single-string constant
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 形成一个单一的字符串常量
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Beyond these few similarities, however, HLA strings and C/C++ strings differ.
    For example, C/C++ strings let you specify special character values using the
    escape character sequence consisting of a backslash character followed by one
    or more special characters; HLA does not use this escape character mechanism.
    HLA does provide, however, several other ways to insert special characters into
    a string or character constant.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了这些相似之处，HLA 字符串和 C/C++ 字符串还是有所不同。例如，C/C++ 字符串允许你使用转义字符序列来指定特殊字符值，该序列由反斜杠字符后跟一个或多个特殊字符组成；而
    HLA 不使用这种转义字符机制。然而，HLA 提供了其他几种方法将特殊字符插入字符串或字符常量中。
- en: 'Because HLA does not allow escape character sequences in literal string and
    character constants, the first question you might ask is, "How does one embed
    quote characters in string constants and apostrophe characters in character constants?"
    To solve this problem, HLA uses the same technique as Pascal and many other languages:
    You insert two quotes in a string constant to represent a single quote, or you
    place two apostrophes in a character constant to represent a single apostrophe
    character. For example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 HLA 不允许在字面量字符串和字符常量中使用转义字符序列，你可能首先会问：“如何在字符串常量中嵌入引号字符，在字符常量中嵌入撇号字符？”为了解决这个问题，HLA
    使用与 Pascal 和许多其他语言相同的技术：在字符串常量中插入两个引号以表示单个引号，或者在字符常量中插入两个撇号以表示单个撇号字符。例如：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The above is equivalent to:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容等价于：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As [Chapter 1](ch01.html "Chapter 1. HELLO, WORLD OF ASSEMBLY LANGUAGE") pointed
    out, to create a single apostrophe character constant, you place two adjacent
    apostrophes within a pair of apostrophes:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第1章](ch01.html "第1章。汇编语言的世界")所指出的，要创建一个单一的撇号字符常量，你需要在一对撇号中放入两个相邻的撇号：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'HLA provides a couple of other features that eliminate the need for escape
    characters. In addition to concatenating two adjacent string constants to form
    a longer string constant, HLA will also concatenate any combination of adjacent
    character and string constants to form a single string constant:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 提供了其他一些功能，消除了对转义字符的需求。除了将两个相邻的字符串常量连接成一个更长的字符串常量外，HLA 还可以将任何相邻的字符常量和字符串常量的组合连接成一个单一的字符串常量：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that the two *He wrote* strings in the previous examples are identical
    in HLA.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面示例中的两个*He wrote*字符串在 HLA 中是完全相同的。
- en: 'HLA provides a second way to specify character constants that handles all the
    other C/C++ escape character sequences: the ASCII code literal character constant.
    This literal character constant form uses the syntax:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 提供了第二种指定字符常量的方法，可以处理所有其他 C/C++ 转义字符序列：ASCII 码字面量字符常量。这个字面量字符常量的形式使用以下语法：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This form creates a character constant whose value is the ASCII code specified
    by `integer_constant`. The numeric constant can be a decimal, hexadecimal, or
    binary value. For example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该形式创建一个字符常量，其值为由`integer_constant`指定的ASCII码。数字常量可以是十进制、十六进制或二进制值。例如：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Because you may concatenate character literals with strings, and the `#constant`
    form is a character literal, the following are all legal strings:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你可以将字符字面量与字符串连接，而`#constant`形式是一个字符字面量，所以下列字符串都是合法的：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Because $22 is the ASCII code for the quote character, this last example is
    yet a third form of the *He wrote* string literal.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因为$22是引号字符的ASCII码，所以这个最后的示例是*He wrote*字符串字面量的第三种形式。
- en: 4.2.3 String and Text Constants in the const Section
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.3 `const`部分中的字符串和文本常量
- en: 'String and text constants in the `const` section use the following declaration
    syntax:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`部分中的字符串和文本常量使用以下声明语法：'
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Other than the data type of these two constants, their declarations are identical.
    However, their behavior in an HLA program is quite different.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两个常量的数据类型外，它们的声明是相同的。然而，它们在HLA程序中的行为却完全不同。
- en: Whenever HLA encounters a symbolic string constant within your program, it substitutes
    the string literal constant in place of the string name. So a statement like `stdout.put(
    AStringConst );` prints the string `123` to the display. No real surprise here.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每当HLA在程序中遇到符号字符串常量时，它会用字符串字面量常量替换字符串名称。所以像`stdout.put( AStringConst );`这样的语句会将字符串`123`打印到显示屏上。这里没有什么意外。
- en: 'Whenever HLA encounters a symbolic text constant within your program, it substitutes
    the text of that string (rather than the string literal constant) for the identifier.
    That is, HLA substitutes the characters between the delimiting quotes in place
    of the symbolic text constant. Therefore, the following statement is perfectly
    legal given the declarations above:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每当HLA在程序中遇到符号文本常量时，它会用该字符串的文本内容（而不是字符串字面量常量）替换标识符。也就是说，HLA会将定界引号之间的字符替换为符号文本常量。因此，考虑以下语句，根据上述声明，它是完全合法的：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that substituting `AStringConst` for `ATextConst` in this example is illegal:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个示例中，将`AStringConst`替换为`ATextConst`是非法的：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This latter example is illegal because you cannot move a string literal constant
    into the AL register.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个后续示例是非法的，因为你不能将字符串字面量常量移入AL寄存器。
- en: 'Whenever HLA encounters a symbolic text constant in your program, it immediately
    substitutes the value of the text constant''s string for that text constant and
    continues the compilation as though you had written the text constant''s value
    rather than the symbolic identifier in your program. This can save some typing
    and help make your programs a little more readable if you often enter some sequence
    of text in your program. For example, consider the `nl` (newline) text constant
    declaration found in the HLA *stdio.hhf* library header file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每当HLA在你的程序中遇到符号文本常量时，它会立即将文本常量的字符串值替换为该文本常量，并继续编译，就像你在程序中写入的是文本常量的值而不是符号标识符一样。如果你经常在程序中输入某些文本序列，这可以节省一些输入工作，并使你的程序更具可读性。例如，考虑在HLA
    *stdio.hhf*库头文件中找到的`nl`（换行）文本常量声明：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Whenever HLA encounters the symbol `nl`, it immediately substitutes the value
    of the string "`#$d #$a`" for the `nl` identifier. When HLA sees the `#$d` (carriage
    return) character constant followed by the `#$a` (line feed) character constants,
    it concatenates the two to form the string containing the Windows newline sequence
    (a carriage return followed by a line feed). Consider the following two statements:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '每当HLA遇到符号`nl`时，它会立即将字符串"`#$d #$a`"的值替换为`nl`标识符。当HLA看到`#$d`（回车）字符常量后跟`#$a`（换行）字符常量时，它会将这两个字符连接成一个字符串，形成Windows换行序列（回车后跟换行）。考虑以下两个语句：'
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '(Notice that the second statement above does not separate the string literal
    and the `nl` symbol with a comma.) In the first example, HLA emits code that prints
    the string `Hello World` and then emits some additional code that prints a newline
    sequence. In the second example, HLA expands the `nl` symbol as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，上述第二个语句没有用逗号分隔字符串字面量和`nl`符号。）在第一个示例中，HLA生成代码打印字符串`Hello World`，然后生成一些额外的代码打印换行符序列。在第二个示例中，HLA将`nl`符号扩展如下：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now HLA sees a string literal constant (`Hello World`) followed by two character
    constants. It concatenates the three of them together to form a single string
    and then prints this string with a single call. Therefore, leaving off the comma
    between the string literal and the `nl` symbol produces slightly more efficient
    code. Keep in mind that this works only with string literal constants. You cannot
    concatenate string variables, or a string variable with a string literal, by using
    this technique.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 HLA 看到一个字符串字面常量（`Hello World`），后面跟着两个字符常量。它将这三者连接起来，形成一个单一的字符串，并通过一个调用来打印这个字符串。因此，省略字符串字面常量和
    `nl` 符号之间的逗号可以生成略微更高效的代码。请记住，这仅适用于字符串字面常量。你不能通过这种技巧连接字符串变量，或将字符串变量与字符串字面常量连接起来。
- en: Linux, FreeBSD, and Mac OS X users should note that the Unix end-of-line sequence
    is just a single line-feed character. Therefore, the declaration for `nl` is slightly
    different in those operating systems (to always guarantee that `nl` expands to
    a string constant rather than a character constant).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Linux、FreeBSD 和 Mac OS X 用户应注意，Unix 的行尾序列仅是一个单一的换行符。因此，在这些操作系统中，`nl` 的声明略有不同（以确保
    `nl` 始终展开为字符串常量，而不是字符常量）。
- en: In the constant section, if you specify only a constant identifier and a string
    constant (that is, you do not supply a type), HLA defaults to type `string`. If
    you want to declare a `text` constant, you must explicitly supply the type.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在常量部分，如果只指定常量标识符和字符串常量（即未提供类型），HLA 默认类型为 `string`。如果你想声明一个 `text` 常量，必须显式地提供类型。
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 4.2.4 Constant Expressions
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.4 常量表达式
- en: 'Thus far, this chapter has given the impression that a symbolic constant definition
    consists of an identifier, an optional type, and a literal constant. Actually,
    HLA constant declarations can be a lot more sophisticated than this because HLA
    allows the assignment of a constant expression, not just a literal constant, to
    a symbolic constant. The generic constant declaration takes one of the following
    two forms:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章给人的印象是符号常量定义由标识符、可选类型和字面常量组成。实际上，HLA 常量声明可以比这复杂得多，因为 HLA 允许将常量表达式（而不仅仅是字面常量）赋值给符号常量。通用常量声明有以下两种形式：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Constant expressions take the familiar form you're used to in high-level languages
    like C/C++ and Pascal. They may contain literal constant values, previously declared
    symbolic constants, and various arithmetic operators. [Table 4-1](ch04s02.html#operations_allowed_in_constant_expressio
    "Table 4-1. Operations Allowed in Constant Expressions") lists some of the operations
    possible in a constant expression.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 常量表达式采用你在 C/C++ 和 Pascal 等高级语言中常见的形式。它们可以包含字面常量值、先前声明的符号常量和各种算术运算符。[表 4-1](ch04s02.html#operations_allowed_in_constant_expressio
    "表 4-1. 常量表达式中允许的运算") 列出了常量表达式中可能的一些运算。
- en: The constant expression operators follow standard precedence rules; you may
    use the parentheses to override the precedence if necessary. See the HLA reference
    at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) or [http://artofasm.com/](http://artofasm.com/)
    for the exact precedence relationships. In general, if the precedence isn't obvious,
    use parentheses to exactly state the order of evaluation. HLA actually provides
    a few more operators than these, though the ones above are the ones you will most
    commonly use; the HLA documentation provides a complete list of constant expression
    operators.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 常量表达式运算符遵循标准的优先级规则；如果需要，你可以使用括号来覆盖优先级。有关确切的优先级关系，请参见 HLA 参考手册 [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    或 [http://artofasm.com/](http://artofasm.com/)。一般来说，如果优先级不明显，可以使用括号明确指出计算顺序。虽然
    HLA 提供了比这些更多的运算符，但上述运算符是你最常用的；HLA 文档提供了常量表达式运算符的完整列表。
- en: Table 4-1. Operations Allowed in Constant Expressions
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1. 常量表达式中允许的运算
- en: '| Arithmetic Operators |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 算术运算符 |'
- en: '| --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| `−` (unary negation) | Negates the expression immediately following `"-"`.
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `−`（一元取反） | 对紧随其后的表达式执行取反操作。 |'
- en: '| `*` | Multiplies the integer or real values around the asterisk. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 乘法运算，作用于星号两边的整数或实数值。 |'
- en: '| `div` | Divides the left integer operand by the right integer operand, producing
    an integer (truncated) result. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `div` | 将左侧整数操作数除以右侧整数操作数，产生一个整数（截断）结果。 |'
- en: '| `mod` | Divides the left integer operand by the right integer operand, producing
    an integer remainder. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `mod` | 用于将左侧整数操作数除以右侧整数操作数，产生一个整数余数。 |'
- en: '| `/` | Divides the left numeric operand by the second numeric operand, producing
    a floating point result. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 将左侧数字操作数除以第二个数字操作数，返回浮点结果。 |'
- en: '| `+` | Adds the left and right numeric operands. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 将左右两个数字操作数相加。 |'
- en: '| `−` | Subtracts the right numeric operand from the left numeric operand.
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `−` | 从左操作数中减去右操作数。 |'
- en: '| Comparison Operators |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 比较运算符 |'
- en: '| --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| `=`, `==` | Compares left operand with right operand. Returns true if equal.
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `=`, `==` | 比较左操作数和右操作数。如果相等，返回真。 |'
- en: '| `<>`, `!=` | Compares left operand with right operand. Returns true if not
    equal. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `<>`, `!=` | 比较左操作数和右操作数。如果不相等，返回真。 |'
- en: '| `<` | Returns true if left operand is less than right operand. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 如果左操作数小于右操作数，则返回真。 |'
- en: '| `<=` | Returns true if left operand is <= right operand. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 如果左操作数小于或等于右操作数，则返回真。 |'
- en: '| `>` | Returns true if left operand is greater than right operand. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 如果左操作数大于右操作数，则返回真。 |'
- en: '| `>=` | Returns true if left operand is >= right operand. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 如果左操作数大于或等于右操作数，则返回真。 |'
- en: '| Logical Operators^([[a](#ftn.CHP-4-TFN-1)]) |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑运算符^([[a](#ftn.CHP-4-TFN-1)]) |'
- en: '| --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| `&` | For boolean operands, returns the logical `and` of the two operands.
    |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 对于布尔操作数，返回两个操作数的逻辑`与`。 |'
- en: '| `&#124;` | For boolean operands, returns the logical `or` of the two operands.
    |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 对于布尔操作数，返回两个操作数的逻辑`或`。 |'
- en: '| `^` | For boolean operands, returns the logical exclusive-or. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 对于布尔操作数，返回逻辑异或。 |'
- en: '| `!` | Returns the logical not of the single operand following `"!"`. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 返回紧随 `"!"` 后的单一操作数的逻辑`非`。 |'
- en: '|'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '^([[a](#CHP-4-TFN-1)]) Note to C/C++ and Java users: HLA''s constant expressions
    use complete boolean evaluation rather than short-circuit boolean evaluation.
    Hence, HLA constant expressions do not behave identically to C/C++/Java expressions.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[a](#CHP-4-TFN-1)]) 提示给C/C++和Java用户：HLA的常量表达式使用完整的布尔求值，而不是短路布尔求值。因此，HLA的常量表达式与C/C++/Java表达式的行为不同。
- en: '|'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Bitwise Logical Operators |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 按位逻辑运算符 |'
- en: '| --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| `&` | For integer numeric operands, returns bitwise `and` of the operands.
    |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 对于整数数字操作数，返回操作数的按位`与`。 |'
- en: '| `&#124;` | For integer numeric operands, returns bitwise `or` of the operands.
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 对于整数数字操作数，返回操作数的按位`或`。 |'
- en: '| `^` | For integer numeric operands, returns bitwise `xor` of the operands.
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 对于整数数字操作数，返回操作数的按位`异或`。 |'
- en: '| `!` | For an integer numeric operand, returns bitwise `not` of the operand.
    |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 对于整数数字操作数，返回该操作数的按位`取反`。 |'
- en: '| String Operators |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 字符串运算符 |'
- en: '| --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| `''+''` | Returns the concatenation of the left and right string operands.
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `''+''` | 返回左侧和右侧字符串操作数的连接结果。 |'
- en: 'If an identifier appears in a constant expression, that identifier must be
    a constant identifier that you have previously defined in your program in a const
    or `val` section. You may not use variable identifiers in a constant expression;
    their values are not defined at compile time when HLA evaluates the constant expression.
    Also, don''t confuse compile-time and runtime operations:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果常量表达式中出现标识符，则该标识符必须是你在程序中的`const`或`val`部分之前定义的常量标识符。你不能在常量表达式中使用变量标识符，因为在HLA求值常量表达式时，变量的值在编译时并未定义。另外，请不要混淆编译时操作和运行时操作：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: HLA directly interprets the value of a constant expression during compilation.
    It does not emit any machine instructions to compute `x + y` in the constant expression
    above. Instead, it directly computes the sum of these two constant values. From
    that point forward in the program, HLA associates the value 11 with the constant
    `Sum` just as if the program had contained the statement `Sum := 11;` rather than
    `Sum := x + y;`. On the other hand, HLA does not precompute the value 11 in AL
    for the `mov` and `add` instructions above; it faithfully emits the object code
    for these two instructions and the 80x86 computes their sum when the program is
    run (sometime after the compilation is complete).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: HLA在编译期间直接解释常量表达式的值。它不会发出任何机器指令来计算上面常量表达式中的`x + y`。相反，它会直接计算这两个常量值的和。从那时起，HLA将常量`Sum`与值11关联，就像程序中包含了语句`Sum
    := 11;`而不是`Sum := x + y;`一样。另一方面，HLA不会在AL中预计算指令`mov`和`add`的值；它忠实地发出这两个指令的目标代码，80x86将在程序运行时（编译完成后某个时刻）计算它们的和。
- en: 'In general, constant expressions don''t get very sophisticated in assembly
    language programs. Usually, you''re adding, subtracting, or multiplying two integer
    values. For example, the following `const` section defines a set of constants
    that have consecutive values:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，常量表达式在汇编语言程序中不会非常复杂。通常，你只是对两个整数值进行加法、减法或乘法。例如，以下 `const` 区段定义了一组具有连续值的常量：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The constants above have the following values: `TapeDAT=0`, `Tape8mm=1`, `TapeQIC80=2`,
    `TapeTravan=3`, and `TapeDLT=4`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上述常量具有以下值：`TapeDAT=0`、`Tape8mm=1`、`TapeQIC80=2`、`TapeTravan=3` 和 `TapeDLT=4`。
- en: 4.2.5 Multiple const Sections and Their Order in an HLA Program
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.5 HLA 程序中的多个 `const` 区段及其顺序
- en: Although `const` sections must appear in the declaration section of an HLA program
    (for example, between the program *`pgmname`*`;` header and the corresponding
    `begin` *`pgmname`*`;` statement), they do not have to appear before or after
    any other items in the declaration section. In fact, like the variable declaration
    sections, you can place multiple `const` sections in a declaration section. The
    only restriction on HLA constant declarations is that you must declare any constant
    symbol before you use it in your program.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `const` 区段必须出现在 HLA 程序的声明区段中（例如，在程序 *`pgmname`*`;` 头部和相应的 `begin` *`pgmname`*`;`
    语句之间），但它不必出现在声明区段中的其他任何位置之前或之后。事实上，和变量声明区段一样，你可以在声明区段中放置多个 `const` 区段。HLA 常量声明的唯一限制是，必须在程序中使用任何常量符号之前先声明该符号。
- en: 'Some C/C++ programmers, for example, are more comfortable writing their constant
    declarations as follows (because this is closer to C/C++''s syntax for declaring
    constants):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 C/C++ 程序员，例如，更习惯于按如下方式编写常量声明（因为这更接近 C/C++ 声明常量的语法）：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The placement of the `const` section in a program seems to be a personal issue
    among programmers. Other than the requirement of defining all constants before
    you use them, you may feel free to insert the `const` declaration section anywhere
    in the declaration section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，`const` 区段的位置似乎是程序员个人的问题。除了要求在使用常量之前定义所有常量外，你可以随意将 `const` 声明区段插入到声明区段的任何位置。
- en: 4.2.6 The HLA val Section
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.6 HLA `val` 区段
- en: You cannot change the value of a constant you define in the `const` section.
    While this seems perfectly reasonable (constants after all, are supposed to be,
    well, constant), there are different ways we can define the term *constant*, and
    `const` objects follow the rules of only one specific definition. HLA's `val`
    section lets you define constant objects that follow slightly different rules.
    This section discusses the `val` section and the difference between `val` constants
    and `const` constants.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能更改在 `const` 区段中定义的常量的值。虽然这似乎是完全合理的（毕竟常量应该是常量），但我们可以通过不同的方式来定义 "*常量*" 这个术语，而
    `const` 对象遵循的是一个特定定义的规则。HLA 的 `val` 区段允许你定义遵循略有不同规则的常量对象。本节讨论了 `val` 区段及 `val`
    常量与 `const` 常量之间的区别。
- en: 'The concept of "`const`-ness" can exist at two different times: while HLA is
    compiling your program and later when your program executes (and HLA is no longer
    running). All reasonable definitions of a constant require that a value not change
    while the program is running. Whether or not the value of a "constant" can change
    during compilation is a separate issue. The difference between HLA `const` objects
    and HLA `val` objects is whether the value can change during compilation.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '"`const` 属性" 可以在两个不同的时刻存在：当 HLA 正在编译程序时，以及程序执行时（此时 HLA 不再运行）。所有合理的常量定义都要求常量的值在程序运行时保持不变。至于常量的值是否可以在编译时发生变化，这是一个单独的问题。HLA
    `const` 对象和 HLA `val` 对象的区别在于，常量的值是否可以在编译时发生变化。'
- en: Once you define a constant in the `const` section, the value of that constant
    is immutable from that point forward *both at runtime and while HLA is compiling
    your program*. Therefore, an instruction like `mov( SymbolicCONST, eax );` always
    moves the same value into EAX, regardless of where this instruction appears in
    the HLA main program. Once you define the symbol `SymbolicCONST` in the `const`
    section, this symbol has the same value from that point forward.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在 `const` 区段中定义了常量，该常量的值从此以后将不可更改，*无论是在运行时还是在 HLA 编译程序时*。因此，像 `mov( SymbolicCONST,
    eax );` 这样的指令始终将相同的值移动到 EAX 寄存器中，无论该指令在 HLA 主程序中出现的位置如何。一旦你在 `const` 区段中定义了符号
    `SymbolicCONST`，从那时起该符号的值就始终不变。
- en: 'The HLA `val` section lets you declare symbolic constants, just like the `const`
    section. However, HLA `val` constants can change their value throughout the source
    code in your program. The following HLA declarations are perfectly legal:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: HLA的`val`部分允许你声明符号常量，就像`const`部分一样。然而，HLA的`val`常量可以在程序的整个源代码中更改其值。以下HLA声明是完全合法的：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: All of the symbols appearing in the `const` sections use the symbolic value
    `InitialValue` as part of the definition. Note, however, that `InitialValue` has
    different values at various points in this code sequence; at the beginning of
    the code sequence `InitialValue` has the value 0, while later it has the value
    100.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所有出现在`const`部分的符号都使用符号值`InitialValue`作为定义的一部分。然而，请注意，`InitialValue`在这段代码序列中的不同位置有不同的值；在代码序列的开始，`InitialValue`的值为0，而在后面它的值为100。
- en: Remember, at runtime a `val` object is not a variable; it is still a manifest
    constant and HLA will substitute the current value of a `val` identifier for that
    identifier.^([[49](#ftn.CHP-4-FN-3)]) Statements like `mov( 25, InitialValue );`
    are no more legal than `mov( 25, 0 );` or `mov( 25, 100 );`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在运行时，`val`对象不是变量；它仍然是一个常量，HLA会用`val`标识符当前的值替代该标识符。^([[49](#ftn.CHP-4-FN-3)])
    像`mov( 25, InitialValue );`这样的语句和`mov( 25, 0 );`或`mov( 25, 100 );`一样不合法。
- en: 4.2.7 Modifying val Objects at Arbitrary Points in Your Programs
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.7 在程序中的任意位置修改`val`对象
- en: If you declare all your `val` objects in the declaration section, it would seem
    that you would not be able to change the value of a `val` object between the `begin`
    and `end` statements of your program. After all, the `val` section must appear
    in the declaration section of the program, and the declaration section ends before
    the `begin` statement. In [Chapter 9](ch09.html "Chapter 9. MACROS AND THE HLA
    COMPILE-TIME LANGUAGE"), you will learn that most `val` object modifications occur
    between the `begin` and `end` statements; hence, HLA must provide some way to
    change the value of a `val` object outside the declaration section. The mechanism
    to do this is the `?` operator. Not only does HLA allow you to change the value
    of a `val` object outside the declaration section, but it also allows you to change
    the value of a `val` object almost *anywhere* in the program. Anywhere a space
    is allowed inside an HLA program, you can insert a statement of the form
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在声明部分声明了所有的`val`对象，看起来你就无法在程序的`begin`和`end`语句之间更改`val`对象的值。毕竟，`val`部分必须出现在程序的声明部分，而声明部分在`begin`语句之前就结束了。在[第9章](ch09.html
    "第9章. 宏和HLA编译时语言")中，你将学到，大多数`val`对象的修改发生在`begin`和`end`语句之间；因此，HLA必须提供某种方式来在声明部分之外更改`val`对象的值。实现这一点的机制是`?`操作符。HLA不仅允许你在声明部分之外更改`val`对象的值，而且还允许你几乎在程序的*任何地方*更改`val`对象的值。在HLA程序中，凡是允许空格的位置，你都可以插入如下形式的语句
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This means that you could write a short program like the one appearing in [Example 4-4](ch04s02.html#demonstration_of_val_redefinition_using
    "Example 4-4. Demonstration of val redefinition using the ? operator").
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以编写一个像[示例4-4](ch04s02.html#demonstration_of_val_redefinition_using "示例4-4.
    使用?操作符演示val重新定义")中出现的简短程序。
- en: Example 4-4. Demonstration of `val` redefinition using the `?` operator
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4-4：使用`?`操作符演示`val`重新定义
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '* * *'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[48](#CHP-4-FN-2)]) This is not a complete list. HLA also supports 64-bit
    and 128-bit data types. We'll discuss those in [Chapter 8](ch08.html "Chapter 8. ADVANCED
    ARITHMETIC").
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[48](#CHP-4-FN-2)]) 这不是一个完整的列表，HLA还支持64位和128位数据类型。我们将在[第8章](ch08.html "第8章.
    高级算术")中讨论这些类型。
- en: ^([[49](#CHP-4-FN-3)]) In this context, *current* means the value last assigned
    to a `val` object looking backward in the source code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[49](#CHP-4-FN-3)]) 在此上下文中，*当前*指的是回顾源代码时最后一次赋值给`val`对象的值。
- en: 4.3 The HLA Type Section
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.3 HLA类型部分
- en: 'Let''s say that you simply do not like the names that HLA uses for declaring
    `byte`, `word`, `dword`, `real`, and other variables. Let''s say that you prefer
    Pascal''s naming convention or perhaps C''s naming convention. You want to use
    terms like `integer`, `float`, `double`, or whatever. If HLA were Pascal, you
    could redefine the names in the `type` section of the program. With C you could
    use a `#define` or a `typedef` statement to accomplish the task. Well, HLA, like
    Pascal, has its own `type` statement that also lets you create aliases of these
    names. The following example demonstrates how to set up some C/C++/Pascal-compatible
    names in your HLA programs:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你就是不喜欢HLA用来声明`byte`、`word`、`dword`、`real`和其他变量的名称。假设你更喜欢Pascal的命名约定，或者可能是C的命名约定。你希望使用诸如`integer`、`float`、`double`等术语。如果HLA像Pascal一样，你可以在程序的`type`部分重新定义这些名称。如果是C，你可以使用`#define`或`typedef`语句来完成这项任务。好吧，HLA和Pascal一样，也有自己的`type`语句，它也允许你创建这些名称的别名。以下示例演示了如何在HLA程序中设置一些与C/C++/Pascal兼容的名称：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now you can declare your variables with more meaningful statements like these:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以用更有意义的语句声明你的变量，例如：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you program in Ada, C/C++, or FORTRAN (or any other language, for that matter),
    you can pick type names you''re more comfortable with. Of course, this doesn''t
    change how the 80x86 or HLA reacts to these variables one iota, but it does let
    you create programs that are easier to read and understand because the type names
    are more indicative of the actual underlying types. One warning for C/C++ programmers:
    don''t get too excited and go off and define an `int` data type. Unfortunately,
    `int` is an 80x86 machine instruction (interrupt), and therefore this is a reserved
    word in HLA.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Ada、C/C++或FORTRAN（或其他任何语言），你可以选择你更习惯的类型名称。当然，这并不会改变80x86或HLA对这些变量的反应，但它确实让你创建的程序更易于阅读和理解，因为类型名称更能反映实际的底层类型。给C/C++程序员的一个警告：不要太兴奋，去定义一个`int`数据类型。不幸的是，`int`是80x86的机器指令（中断），因此它在HLA中是一个保留字。
- en: The `type` section is useful for much more than creating type isomorphism (that
    is, giving a new name to an existing type). The following sections demonstrate
    many of the possible things you can do in the `type` section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`部分不仅仅用于创建类型同构（即，为现有类型指定新名称）。以下部分演示了你可以在`type`部分执行的许多操作。'
- en: 4.4 enum and HLA Enumerated Data Types
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.4 `enum`与HLA枚举数据类型
- en: 'In a previous section discussing constants and constant expressions, you saw
    the following example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前讨论常量和常量表达式的部分，你看到了以下示例：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This example demonstrates how to use constant expressions to develop a set of
    constants that contain unique, consecutive values. There are, however, a couple
    of problems with this approach. First, it involves a lot of typing (and extra
    reading when reviewing this program). Second, it's very easy to make a mistake
    when creating long lists of unique constants and reuse or skip some values. The
    HLA `enum` type provides a better way to create a list of constants with unique
    values.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例演示了如何使用常量表达式来开发一组包含独特、连续值的常量。然而，这种方法存在一些问题。首先，它涉及大量的输入（以及在复查该程序时额外的阅读工作）。其次，在创建长列表的独特常量时，很容易犯错，可能会重复使用或跳过某些值。HLA的`enum`类型提供了一种更好的方法来创建具有独特值的常量列表。
- en: '`enum` is an HLA type declaration that lets you associate a list of names with
    a new type. HLA associates a unique value with each name (that is, it *enumerates*
    the list). The `enum` keyword typically appears in the `type` section, and you
    use it as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`是HLA的一种类型声明，它允许你将一系列名称与新类型关联。HLA会将一个独特的值与每个名称关联（即，它对列表进行*枚举*）。`enum`关键字通常出现在`type`部分，你可以按照以下方式使用它：'
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The symbol *`enumTypeID`* becomes a new type whose values are specified by
    a list of names. As a concrete example, consider the data type `TapeDrives` and
    a corresponding variable declaration of type `TapeDrives`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 符号*`enumTypeID`*成为一个新类型，其值由名称列表指定。作为一个具体的例子，考虑数据类型`TapeDrives`及其对应的变量声明类型`TapeDrives`：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: By default, HLA reserves 1 byte of storage for enumerated data types. So the
    `BackupUnit` variable will consume 1 byte of memory, and you would typically use
    an 8-bit register to access it.^([[50](#ftn.CHP-4-FN-4)]) As for the constants,
    HLA associates consecutive `uns8` constant values starting at 0 with each of the
    enumerated identifiers. In the `TapeDrives` example, the tape drive identifiers
    would have the values `TapeDAT=0`, `Tape8mm=1`, `TapeQIC80=2`, `TapeTravan=3`,
    and `TapeDLT=4`. You may use these constants exactly as though you had defined
    them with these values in a `const` section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，HLA 为枚举数据类型保留 1 字节的存储空间。因此，`BackupUnit` 变量将消耗 1 字节的内存，你通常会使用一个 8 位寄存器来访问它。^([[50](#ftn.CHP-4-FN-4)])
    至于常量，HLA 将从 0 开始依次为每个枚举标识符分配 `uns8` 常量值。在 `TapeDrives` 示例中，磁带驱动器标识符的值为 `TapeDAT=0`、`Tape8mm=1`、`TapeQIC80=2`、`TapeTravan=3`
    和 `TapeDLT=4`。你可以像在 `const` 部分定义这些常量并赋值一样，直接使用这些常量。
- en: '* * *'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[50](#CHP-4-FN-4)]) HLA provides a mechanism by which you can specify that
    enumerated data types consume 2 or 4 bytes of memory. See the HLA documentation
    for more details.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[50](#CHP-4-FN-4)]) HLA 提供了一种机制，你可以通过它指定枚举数据类型消耗 2 或 4 字节的内存。有关更多细节，请参见 HLA
    文档。
- en: 4.5 Pointer Data Types
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.5 指针数据类型
- en: You've probably experienced pointers firsthand in the Pascal, C, or Ada programming
    languages, and you're probably getting worried right now. Almost everyone has
    a bad experience when they first encounter pointers in a high-level language.
    Well, fear not! Pointers are actually *easier* to deal with in assembly language
    than in high-level languages. Besides, most of the problems you had with pointers
    probably had nothing to do with pointers but rather with the linked list and tree
    data structures you were trying to implement with them. Pointers, on the other
    hand, have many uses in assembly language that have nothing to do with linked
    lists, trees, and other scary data structures. Indeed, simple data structures
    like arrays and records often involve the use of pointers. So if you have some
    deep-rooted fear about pointers, forget everything you know about them. You're
    going to learn how *great* pointers really are.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在 Pascal、C 或 Ada 等编程语言中亲身体验过指针，而且现在可能有些担心。几乎每个人第一次接触指针时都会有糟糕的体验。别怕！指针在汇编语言中的处理实际上比在高级语言中要*简单*。此外，你在使用指针时遇到的许多问题，可能与指针本身无关，而是你尝试用它们实现的链表和树形数据结构的问题。另一方面，指针在汇编语言中的用途非常广泛，且与链表、树和其他复杂的数据结构无关。实际上，像数组和记录这样简单的数据结构也常常涉及使用指针。所以，如果你对指针有根深蒂固的恐惧，忘掉你对它们的所有认知吧。你将会发现，指针其实是*很棒*的。
- en: Probably the best place to start is with the definition of a pointer. Just exactly
    what is a pointer, anyway? Unfortunately, high-level languages like Pascal tend
    to hide the simplicity of pointers behind a wall of abstraction. This added complexity
    (which exists for good reason, by the way) tends to frighten programmers because
    *they don't understand what's going on*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最好的入门方式是从指针的定义开始。指针究竟是什么呢？不幸的是，高级语言像 Pascal 常常将指针的简单性隐藏在抽象的墙后。这种额外的复杂性（顺便说一下，这是有充分理由的）往往会让程序员感到害怕，因为*他们不理解发生了什么*。
- en: 'If you''re afraid of pointers, let''s just ignore them for the time being and
    work with an array. Consider the following array declaration in Pascal:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你害怕指针，那就暂时忽略它们，先使用数组。考虑下面这个 Pascal 数组声明：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Even if you don't know Pascal, the concept here is pretty easy to understand.
    `M` is an array with 1,024 integers in it, indexed from `M[0]` to `M[1023]`. Each
    one of these array elements can hold an integer value that is independent of all
    the others. In other words, this array gives you 1,024 different integer variables,
    each of which you refer to by number (the array index) rather than by name.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不知道 Pascal，理解这个概念也非常简单。`M` 是一个包含 1,024 个整数的数组，索引从 `M[0]` 到 `M[1023]`。这些数组元素中的每一个都可以保存一个整数值，并且每个值都与其他元素的值无关。换句话说，这个数组为你提供了
    1,024 个不同的整数变量，每个变量都通过数字（数组索引）而非名称来访问。
- en: 'If you encounter a program that has the statement `M[0]:=100;`, you probably
    won''t have to think at all about what is happening with this statement. It is
    storing the value 100 into the first element of the array `M`. Now consider the
    following two statements:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到一个程序，其中有语句 `M[0]:=100;`，你大概不需要多想就知道这条语句在做什么。它正在把值 100 存储到数组 `M` 的第一个元素中。现在考虑以下两条语句：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You should agree, without too much hesitation, that these two statements perform
    the same operation as `M[0]:=100`;. Indeed, you''re probably willing to agree
    that you can use any integer expression in the range 0..1,023 as an index into
    this array. The following statements still perform the same operation as our single
    assignment to index 0:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该不太犹豫就同意，这两条语句执行的操作和`M[0]:=100`;是一样的。实际上，你可能会同意，你可以使用任何范围在0到1,023之间的整数表达式作为这个数组的索引。以下语句依然执行与我们对索引0的单一赋值相同的操作：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '"Okay, so what''s the point?" you''re probably thinking. "Anything that produces
    an integer in the range 0..1,023 is legal. So what?" Okay, how about the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: “好了，那么重点是什么？”你可能在想。“任何生成0到1,023范围内整数的东西都是合法的，那又怎么样？”好吧，那以下的情况怎么样：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Whoa! Now that takes a few moments to digest. However, if you take it slowly,
    it makes sense and you'll discover that these two instructions perform the exact
    same operation you've been doing all along. The first statement stores 0 into
    array element `M[1]`. The second statement fetches the value of `M[1]`, which
    is an integer so you can use it as an array index into `M`, and uses that value
    (0) to control where it stores the value 100.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这一点可能需要一点时间消化。不过，如果你慢慢来，它是有道理的，你会发现这两条指令实际上执行的是你一直在做的相同操作。第一条语句将0存储到数组元素`M[1]`中。第二条语句取出`M[1]`的值，这是一个整数，因此你可以将其用作数组`M`的索引，并使用该值（0）来控制它存储100的地方。
- en: If you're willing to accept the above as reasonable, perhaps bizarre, but usable
    nonetheless, then you'll have no problems with pointers. *Because* *`M[1]`* *is
    a pointer!* Well, not really, but if you were to change `M` to "memory" and treat
    this array as all of memory, this is the exact definition of a pointer. A pointer
    is simply a memory location whose value is the address (or index, if you prefer)
    of some other memory location. Pointers are very easy to declare and use in an
    assembly language program. You don't even have to worry about array indices or
    anything like that.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意接受上述内容作为合理的，或许有些奇怪，但依然可用的情况，那么你就不会对指针有任何问题了。*因为* *`M[1]`* *就是一个指针！* 其实不完全是，但如果你将`M`看作“内存”，并将这个数组视为整个内存，那么这就是指针的确切定义。指针仅仅是一个内存位置，其值是某个其他内存位置的地址（或者说索引，如果你喜欢这样称呼的话）。在汇编语言程序中，指针的声明和使用非常简单，你甚至不必担心数组索引之类的问题。
- en: 4.5.1 Using Pointers in Assembly Language
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5.1 在汇编语言中使用指针
- en: 'An HLA pointer is a 32-bit value that may contain the address of some other
    variable. If you have a `dword` variable `p` that contains $1000_0000, then `p`
    "points" at memory location $1000_0000\. To access the `dword` that `p` points
    at, you could use code like the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: HLA指针是一个32位的值，可能包含某个其他变量的地址。如果你有一个`dword`类型的变量`p`，它的值是$1000_0000，那么`p`“指向”内存位置$1000_0000。要访问`p`所指向的`dword`，你可以使用类似以下的代码：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: By loading the value of `p` into EBX, this code loads the value $1000_0000 into
    EBX (assuming `p` contains $1000_0000 and, therefore, points at memory location
    $1000_0000). The second instruction above loads the EAX register with the `dword`
    starting at the location whose offset appears in EBX. Because EBX now contains
    $1000_0000, this will load EAX from locations $1000_0000 through $1000_0003.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`p`的值加载到EBX中，这段代码将$1000_0000的值加载到EBX中（假设`p`包含$1000_0000，因此指向内存位置$1000_0000）。上面第二条指令将EAX寄存器加载为从EBX中偏移量所指向的位置开始的`dword`。因为EBX现在包含$1000_0000，所以这将从$1000_0000到$1000_0003的位置加载EAX。
- en: 'Why not just load EAX directly from location $1000_0000 using an instruction
    like `mov( mem, eax )`; (assuming `mem` is at address $1000_0000)? Well, there
    are a lot of reasons. But the primary reason is that this `mov` instruction always
    loads EAX from location `mem`. You cannot change the address from where it loads
    EAX. The former instructions, however, always load EAX from the location where
    `p` is pointing. This is very easy to change under program control. In fact, the
    simple instruction `mov( &mem2, p );` will cause those same two instructions above
    to load EAX from `mem2` the next time they execute. Consider the following instruction
    sequence:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接使用像`mov( mem, eax )`这样的指令从位置$1000_0000加载EAX？（假设`mem`位于地址$1000_0000）其实有很多原因。不过最主要的原因是，这条`mov`指令总是从位置`mem`加载EAX。你无法更改它加载EAX的地址。然而，前面的指令总是从`p`所指向的位置加载EAX。这在程序控制下非常容易改变。实际上，简单的指令`mov(
    &mem2, p );`会使得上面那两条指令在下次执行时，从`mem2`加载EAX。考虑以下指令序列：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This short example demonstrates two execution paths through the program. The
    first path loads the variable `p` with the address of the variable `i`. The second
    path through the code loads `p` with the address of the variable `j`. Both execution
    paths converge on the last two `mov` instructions that load EAX with `i` or `j`
    depending upon which execution path was taken. In many respects, this is like
    a *parameter* to a procedure in a high-level language like Pascal. Executing the
    same instructions accesses different variables depending on whose address (`i`
    or `j`) winds up in `p`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单示例演示了程序的两条执行路径。第一条路径将变量 `p` 加载为变量 `i` 的地址。第二条路径通过代码将 `p` 加载为变量 `j` 的地址。这两条执行路径在最后两条
    `mov` 指令处汇合，根据执行路径的不同，将 `i` 或 `j` 加载到 EAX 寄存器中。在许多方面，这就像在高级语言（如 Pascal）中的*参数*。执行相同的指令时，取决于哪个地址（`i`
    或 `j`）最终存储在 `p` 中，程序访问不同的变量。
- en: 4.5.2 Declaring Pointers in HLA
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5.2 在 HLA 中声明指针
- en: 'Because pointers are 32-bits long, you could simply use the `dword` type to
    allocate storage for your pointers. However, there is a much better way to do
    this: HLA provides the `pointer to` phrase specifically for declaring pointer
    variables. Consider the following example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于指针是 32 位长，您可以简单地使用 `dword` 类型为指针分配存储空间。但是，有一种更好的方法：HLA 提供了 `pointer to` 短语专门用于声明指针变量。考虑以下示例：
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This example demonstrates that it is possible to initialize as well as declare
    pointer variables in HLA. Note that you may only take addresses of static variables
    (`static`, `readonly`, and `storage` objects) with the address-of operator, so
    you can only initialize pointer variables with the addresses of static objects.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例演示了在 HLA 中初始化和声明指针变量是可能的。请注意，您只能使用取地址符号（address-of operator）获取静态变量（`static`、`readonly`
    和 `storage` 对象）的地址，因此只能使用静态对象的地址来初始化指针变量。
- en: You can also define your own pointer types in the `type` section of an HLA program.
    For example, if you often use pointers to characters, you'll probably want to
    use a `type` declaration like the one in the following example.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在 HLA 程序的 `type` 部分定义自己的指针类型。例如，如果您经常使用指向字符的指针，您可能希望使用如下所示的 `type` 声明。
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 4.5.3 Pointer Constants and Pointer Constant Expressions
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5.3 指针常量与指针常量表达式
- en: 'HLA allows two literal pointer constant forms: the address-of operator followed
    by the name of a static variable or the constant `NULL`. In addition to these
    two literal pointer constants, HLA also supports simple pointer constant expressions.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 允许两种字面指针常量形式：取地址符号后跟静态变量的名称，或者常量 `NULL`。除了这两种字面指针常量外，HLA 还支持简单的指针常量表达式。
- en: The `NULL` pointer is the constant 0\. Zero is an illegal address that will
    raise an exception if you try to access it under modern operating systems. Programs
    typically initialize pointers with `NULL` to indicate that a pointer has explicitly
    *not* been initialized with a valid address.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`NULL` 指针是常量 0。零是一个非法地址，如果您在现代操作系统下尝试访问它，会引发异常。程序通常用 `NULL` 初始化指针，以表示指针显式地*未*初始化为有效地址。'
- en: 'In addition to simple address literals and the value 0, HLA allows very simple
    constant expressions wherever a pointer constant is legal. Pointer constant expressions
    take one of the three following forms:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的地址字面量和值 0 之外，HLA 还允许在任何指针常量合法的地方使用非常简单的常量表达式。指针常量表达式有以下三种形式之一：
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The *`PureConstantExpression`* term is a numeric constant expression that does
    not involve any pointer constants. This type of expression produces a memory address
    that is the specified number of bytes before or after (`−` or `+`, respectively)
    the *`StaticVarName`* variable in memory. Note that the first two forms above
    are semantically equivalent; they both return a pointer constant whose address
    is the sum of the static variable and the constant expression.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*`PureConstantExpression`* 术语指的是不涉及任何指针常量的数字常量表达式。这种类型的表达式生成一个内存地址，该地址是 *`StaticVarName`*
    变量在内存中指定字节数之前或之后（分别为 `−` 或 `+`）。请注意，上面两种形式在语义上是等效的；它们都返回一个指针常量，其地址是静态变量和常量表达式的总和。'
- en: Because you can create pointer constant expressions, it should come as no surprise
    to discover that HLA lets you define manifest pointer constants in the `const`
    section. The program in [Example 4-5](ch04s05.html#pointer_constant_expressions_in_an_hla_p
    "Example 4-5. Pointer constant expressions in an HLA program") demonstrates how
    you can do this.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可以创建指针常量表达式，发现HLA允许你在`const`部分定义指针常量并不令人惊讶。程序在[示例 4-5](ch04s05.html#pointer_constant_expressions_in_an_hla_p
    "示例 4-5. HLA程序中的指针常量表达式")中演示了如何实现这一点。
- en: Example 4-5. Pointer constant expressions in an HLA program
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-5. HLA程序中的指针常量表达式
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Upon execution, this program prints the value of the byte just beyond `b` in
    memory (which contains the value $01).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，该程序打印出位于内存中`b`之后的字节的值（该字节的值为$01）。
- en: 4.5.4 Pointer Variables and Dynamic Memory Allocation
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5.4 指针变量与动态内存分配
- en: 'Pointer variables are the perfect place to store the return result from the
    HLA Standard Library `mem.alloc` function. The `mem.alloc` function returns the
    address of the storage it allocates in the EAX register; therefore, you can store
    the address directly into a pointer variable with a single `mov` instruction immediately
    after a call to `mem.alloc`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 指针变量是存储HLA标准库`mem.alloc`函数返回结果的理想地方。`mem.alloc`函数返回分配的存储空间的地址，存储在EAX寄存器中；因此，你可以在调用`mem.alloc`后，立即使用单条`mov`指令将地址直接存储到指针变量中：
- en: '[PRE49]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 4.5.5 Common Pointer Problems
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5.5 常见指针问题
- en: 'Programmers encounter five common problems when using pointers. Some of these
    errors will cause your programs to immediately stop with a diagnostic message;
    other problems are more subtle, yielding incorrect results without otherwise reporting
    an error or simply affecting the performance of your program without displaying
    an error. These five problems are:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员在使用指针时常常会遇到五个常见的问题。这些错误中的一些会导致程序立即停止，并显示诊断信息；其他问题则更加隐蔽，可能导致程序结果不正确，但不会报告错误，或者仅影响程序的性能，而不显示错误。以下是这五个问题：
- en: Using an uninitialized pointer
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用未初始化的指针
- en: Using a pointer that contains an illegal value (e.g., `NULL`)
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包含非法值（例如，`NULL`）的指针
- en: Continuing to use `mem.alloc`'d storage after that storage has been freed
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在该存储空间被释放后，继续使用通过`mem.alloc`分配的存储空间
- en: Failing to `mem.free` storage once the program is finished using it
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在程序使用完存储空间后未调用`mem.free`释放该存储空间
- en: Accessing indirect data using the wrong data type
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用错误的数据类型访问间接数据
- en: The first problem above is using a pointer variable before you have assigned
    a valid memory address to the pointer. Beginning programmers often don't realize
    that declaring a pointer variable reserves storage only for the pointer itself;
    it does not reserve storage for the data that the pointer references. The short
    program in [Example 4-6](ch04s05.html#uninitialized_pointer_demonstration "Example 4-6. Uninitialized
    pointer demonstration") demonstrates this problem.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 上述第一个问题是使用指针变量时，尚未为指针分配有效的内存地址。初学者通常没有意识到，声明一个指针变量只是为指针本身保留存储空间；它并不为指针引用的数据保留存储空间。[示例
    4-6](ch04s05.html#uninitialized_pointer_demonstration "示例 4-6. 未初始化指针演示")中的简短程序演示了这个问题。
- en: Example 4-6. Uninitialized pointer demonstration
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-6. 未初始化指针演示
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Although variables you declare in the `static` section are, technically, initialized,
    static initialization still doesn't initialize the pointer in this program with
    a valid address (it initializes them with `0`, which is `NULL`).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你在`static`部分声明的变量在技术上是初始化的，但静态初始化仍然未能为该程序中的指针赋予有效地址（它们被初始化为`0`，即`NULL`）。
- en: Of course, there is no such thing as a truly uninitialized variable on the 80x86\.
    What you really have are variables that you've explicitly given an initial value
    and variables that just happen to inherit whatever bit pattern was in memory when
    storage for the variable was allocated. Much of the time, these garbage bit patterns
    lying around in memory don't correspond to a valid memory address. Attempting
    to *dereference* such a pointer (that is, access the data in memory at which it
    points) typically raises a *Memory Access Violation* exception.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在80x86中并没有真正的未初始化变量。你真正拥有的是已经显式赋予初始值的变量，以及那些恰好继承了在分配变量存储空间时内存中所存储的位模式的变量。大多数情况下，这些在内存中残留的垃圾位模式并不对应有效的内存地址。试图*解引用*这样的指针（即访问它所指向的内存中的数据）通常会引发*内存访问违规*异常。
- en: Sometimes, however, those random bits in memory just happen to correspond to
    a valid memory location you can access. In this situation, the CPU will access
    the specified memory location without aborting the program. Although to a naive
    programmer this situation may seem preferable to stopping the program, in reality
    this is far worse because your defective program continues to run without alerting
    you to the problem. If you store data through an uninitialized pointer, you may
    very well overwrite the values of other important variables in memory. This defect
    can produce some very difficult-to-locate problems in your program.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时候，内存中的随机位恰好可能对应一个有效的内存位置，你可以访问。在这种情况下，CPU会访问指定的内存位置，而不会终止程序。虽然对于一个天真的程序员来说，这种情况似乎比停止程序要好，但实际上这是更糟糕的，因为你的缺陷程序会继续运行，而不会提醒你发生了问题。如果你通过一个未初始化的指针存储数据，你很可能会覆盖内存中其他重要变量的值。这个缺陷可能会在你的程序中产生一些非常难以定位的问题。
- en: The second problem programmers have with pointers is storing invalid address
    values into a pointer. The first problem above is actually a special case of this
    second problem (with garbage bits in memory supplying the invalid address rather
    than you producing it via a miscalculation). The effects are the same; if you
    attempt to dereference a pointer containing an invalid address, either you will
    get a Memory Access Violation exception or you will access an unexpected memory
    location.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员在使用指针时的第二个问题是将无效的地址值存储到指针中。上述第一个问题实际上是第二个问题的一个特例（内存中的垃圾位提供了无效地址，而不是由于计算错误由你自己产生的）。其影响是相同的；如果你尝试解引用一个包含无效地址的指针，要么会触发内存访问违规（Memory
    Access Violation）异常，要么会访问到一个意外的内存位置。
- en: 'The third problem listed above is also known as the dangling pointer problem.
    To understand this problem, consider the following code fragment:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列出的第三个问题也被称为悬空指针问题。要理解这个问题，请考虑以下代码片段：
- en: '[PRE51]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this example you will note that the program allocates 256 bytes of storage
    and saves the address of that storage in the `ptr` variable. Then the code uses
    this block of 256 bytes for a while and frees the storage, returning it to the
    system for other uses. Note that calling `mem.free` does not change the value
    of `ptr` in any way; `ptr` still points at the block of memory allocated by `mem.alloc`
    earlier. Indeed, `mem.free` does not change any data in this block, so upon return
    from `mem.free`, `ptr` still points at the data stored into the block by this
    code. However, note that the call to `mem.free` tells the system that the program
    no longer needs this 256-byte block of memory and the system can use this region
    of memory for other purposes. The `mem.free` function cannot enforce the fact
    that you will never access this data again; you are simply promising that you
    won't. Of course, the code fragment above breaks this promise; as you can see
    in the last two instructions above, the program fetches the value in `ptr` and
    accesses the data it points at in memory.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你会注意到程序分配了256字节的存储空间，并将该存储空间的地址保存在`ptr`变量中。然后代码使用这一块256字节的内存一段时间，释放了存储空间，将其交还给系统以供其他用途。请注意，调用`mem.free`并不会以任何方式改变`ptr`的值；`ptr`仍然指向之前通过`mem.alloc`分配的内存块。实际上，`mem.free`并不会改变这块内存中的任何数据，因此在从`mem.free`返回后，`ptr`仍然指向代码存入该内存块的数据。然而，需要注意的是，调用`mem.free`是告诉系统程序不再需要这块256字节的内存，系统可以将这块内存用于其他用途。`mem.free`函数并不能强制保证你将永远不会再访问这些数据；你只是承诺不会这么做。当然，上述代码片段违反了这个承诺；正如你在上面的最后两条指令中看到的，程序获取了`ptr`中的值并访问了它所指向的内存数据。
- en: 'The biggest problem with dangling pointers is that you can get away with using
    them a good part of the time. As long as the system doesn''t reuse the storage
    you''ve freed, using a dangling pointer produces no ill effects in your program.
    However, with each new call to `mem.alloc`, the system may decide to reuse the
    memory released by that previous call to `mem.free`. When this happens, any attempt
    to dereference the dangling pointer may produce some unintended consequences.
    The problems range from reading data that has been overwritten (by the new, legal
    use of the data storage), to overwriting the new data, to (the worst case) overwriting
    system heap management pointers (doing so will probably cause your program to
    crash). The solution is clear: *Never use a pointer value once you free the storage
    associated with that pointer*.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 悬挂指针的最大问题是，您可以在很大一部分时间里不出问题地使用它们。只要系统没有重用您已释放的存储，使用悬挂指针对程序没有不良影响。然而，每次调用 `mem.alloc`
    时，系统可能决定重用先前通过 `mem.free` 释放的内存。当发生这种情况时，任何试图解引用悬挂指针的操作可能会导致一些意外后果。问题的范围从读取已被覆盖的数据（由数据存储的合法新用途覆盖），到覆盖新数据，再到（最糟糕的情况）覆盖系统堆管理指针（这样做可能会导致程序崩溃）。解决方案很明确：*一旦释放与指针相关联的存储，就永远不要再使用该指针值*。
- en: 'Of all the problems, the fourth (failing to free allocated storage) will probably
    have the least impact on the proper operation of your program. The following code
    fragment demonstrates this problem:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 所有问题中，第四个问题（未释放分配的存储）对程序正常运行的影响可能最小。以下代码片段演示了这个问题：
- en: '[PRE52]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this example the program allocates 256 bytes of storage and references this
    storage using the `ptr` variable. At some later time the program allocates another
    block of bytes and overwrites the value in `ptr` with the address of this new
    block. Note that the former value in `ptr` is lost. Because the program no longer
    has this address value, there is no way to call `mem.free` to return the storage
    for later use. As a result, this memory is no longer available to your program.
    While making 256 bytes of memory inaccessible to your program may not seem like
    a big deal, imagine that this code is in a loop that repeats over and over again.
    With each execution of the loop the program loses another 256 bytes of memory.
    After a sufficient number of loop iterations, the program will exhaust the memory
    available on the heap. This problem is often called a *memory leak* because the
    effect is the same as though the memory bits were leaking out of your computer
    (yielding less and less available storage) during program execution.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，程序分配了 256 字节的存储，并通过 `ptr` 变量引用该存储。稍后，程序又分配了另一个内存块，并将 `ptr` 中的值覆盖为这个新内存块的地址。请注意，`ptr`
    中的原始值丢失了。由于程序不再拥有这个地址值，因此无法调用 `mem.free` 来释放存储以供后续使用。结果，这块内存不再对程序可用。虽然使 256 字节的内存对程序不可访问看起来不算大问题，但请想象这段代码在一个不断重复的循环中。每次执行循环时，程序都会丢失另外
    256 字节的内存。在足够多次的循环迭代后，程序将耗尽堆上可用的内存。这个问题通常被称为 *内存泄漏*，因为其效果就像是内存数据在程序执行过程中从计算机中“泄漏”出去（导致可用存储空间越来越少）。
- en: 'Memory leaks are far less damaging than dangling pointers. Indeed, there are
    only two problems with memory leaks: the danger of running out of heap space (which,
    ultimately, may cause the program to abort, though this is rare) and performance
    problems due to virtual memory page swapping. Nevertheless, you should get in
    the habit of always freeing all storage once you have finished using it. When
    your program quits, the operating system reclaims all storage, including the data
    lost via memory leaks. Therefore, memory lost via a leak is lost only to your
    program, not the whole system.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏的危害远小于悬挂指针。实际上，内存泄漏只有两个问题：一是堆空间耗尽的危险（最终可能导致程序中止，尽管这种情况很少发生），二是由于虚拟内存页面交换导致的性能问题。尽管如此，您应该养成在使用完所有存储后立即释放它们的习惯。当您的程序退出时，操作系统会回收所有存储，包括因内存泄漏而丢失的数据。因此，通过泄漏丢失的内存仅对您的程序丢失，而非整个系统。
- en: The last problem with pointers is the lack of type-safe access. This can occur
    because HLA cannot and does not enforce pointer type checking. For example, consider
    the program in [Example 4-7](ch04s05.html#type-unsafe_pointer_access_example "Example 4-7. Type-unsafe
    pointer access example").
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 指针的最后一个问题是缺乏类型安全的访问。这可能是因为 HLA 无法且不强制执行指针类型检查。例如，考虑 [示例 4-7](ch04s05.html#type-unsafe_pointer_access_example
    "示例 4-7. 类型不安全的指针访问示例") 中的程序。
- en: Example 4-7. Type-unsafe pointer access example
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-7. 类型不安全的指针访问示例
- en: '[PRE53]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This program reads in data from the user as character values and then displays
    the data as double-word hexadecimal values. While a powerful feature of assembly
    language is that it lets you ignore data types at will and automatically coerce
    the data without any effort, this power is a two-edged sword. If you make a mistake
    and access indirect data using the wrong data type, HLA and the 80x86 may not
    catch the mistake and your program may produce inaccurate results. Therefore,
    you need to take care when using pointers and indirection in your programs that
    you use the data consistently with respect to data type.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序从用户输入数据作为字符值，然后将数据显示为双字节的十六进制值。虽然汇编语言的一个强大特性是它允许你随意忽略数据类型，并且自动将数据强制转换而无需任何努力，但这种强大也是一把双刃剑。如果你犯了错误，使用错误的数据类型访问间接数据，HLA
    和 80x86 可能无法捕捉到这个错误，你的程序可能会产生不准确的结果。因此，在你的程序中使用指针和间接寻址时，必须小心，确保数据类型的一致性。
- en: 4.6 Composite Data Types
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.6 复合数据类型
- en: Composite data types, also known as *aggregate* data types, are those that are
    built up from other (generally scalar) data types. This chapter covers several
    of the more important composite data types—character strings, character sets,
    arrays, records, and unions. A string is a good example of a composite data type;
    it is a data structure built up from a sequence of individual characters and some
    other data.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 复合数据类型，也叫做*聚合*数据类型，是由其他（通常是标量）数据类型构建而成的。本章将介绍几个重要的复合数据类型——字符字符串、字符集、数组、记录和联合体。字符串就是一个很好的复合数据类型的例子；它是由一系列单独的字符和一些其他数据构成的数据结构。
- en: 4.7 Character Strings
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.7 字符字符串
- en: After integer values, character strings are probably the most common data type
    that modern programs use. The 80x86 does support a handful of string instructions,
    but these instructions are really intended for block memory operations, not a
    specific implementation of a character string. Therefore, this section will concentrate
    mainly on the HLA definition of character strings and will also discuss the string-handling
    routines available in the HLA Standard Library.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在整数值之后，字符字符串可能是现代程序中使用的最常见的数据类型。80x86 确实支持一些字符串指令，但这些指令实际上是为了块内存操作而设计的，而不是针对字符字符串的特定实现。因此，本节将主要集中在
    HLA 字符字符串的定义，并讨论 HLA 标准库中提供的字符串处理例程。
- en: 'In general, a character string is a sequence of ASCII characters that possesses
    two main attributes: a *length* and some *character data*. Different languages
    use different data structures to represent strings. To better understand the reasoning
    behind the design of HLA strings, it is probably instructive to look at two different
    string representations popularized by various high-level languages.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，字符字符串是一系列 ASCII 字符，具有两个主要属性：*长度*和一些*字符数据*。不同的语言使用不同的数据结构来表示字符串。为了更好地理解
    HLA 字符串设计背后的思路，看看两种由不同高级语言推广的字符串表示方法可能是很有帮助的。
- en: 'Without question, *zero-terminated strings* are probably the most common string
    representation in use today because this is the native string format for C, C++,
    C#, Java, and other languages. A zero-terminated string consists of a sequence
    of zero or more ASCII characters ending with a 0 byte. For example, in C/C++,
    the string `"abc"` requires 4 bytes: the three characters `''a''`, `''b''`, and
    `''c''` followed by a 0\. As you''ll soon see, HLA character strings are upward
    compatible with zero-terminated strings, but in the meantime you should note that
    it is very easy to create zero-terminated strings in HLA. The easiest place to
    do this is in the `static` section using code like the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，*零终止字符串*可能是目前使用最广泛的字符串表示形式，因为这是 C、C++、C#、Java 以及其他语言的本地字符串格式。零终止字符串由一系列零个或多个
    ASCII 字符组成，并以一个 0 字节结尾。例如，在 C/C++ 中，字符串 `"abc"` 需要 4 个字节：三个字符 `'a'`、`'b'` 和 `'c'`，后跟一个
    0 字节。如你将很快看到的，HLA 字符串与零终止字符串向上兼容，但在此之前，你应该注意，在 HLA 中创建零终止字符串非常简单。最简单的方法是在 `static`
    区段中使用如下代码：
- en: '[PRE54]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Remember, when using the `@nostorage` option, HLA doesn't reserve any space
    for the variable, so the `zeroTerminatedString` variable's address in memory corresponds
    to the first character in the following `byte` directive. Whenever a character
    string appears in the `byte` directive as it does here, HLA emits each character
    in the string to successive memory locations. The 0 value at the end of the string
    terminates this string.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当使用 `@nostorage` 选项时，HLA 不为变量保留任何空间，因此 `zeroTerminatedString` 变量在内存中的地址对应于以下
    `byte` 指令中的第一个字符。每当字符字符串出现在 `byte` 指令中时，如同这里所示，HLA 会将字符串中的每个字符依次输出到连续的内存位置。字符串末尾的
    0 值终止了这个字符串。
- en: 'HLA supports a `zstring` data type. However, those objects are double word
    pointers that contain the address of a `zstring`, not the zero-terminated string
    itself. Here is an example of a `zstring` declaration (and static initialization):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 支持 `zstring` 数据类型。然而，这些对象是双字指针，包含一个指向 `zstring` 的地址，而不是零终止字符串本身。以下是 `zstring`
    声明（和静态初始化）的示例：
- en: '[PRE55]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Zero-terminated strings have two principal attributes: They are very simple
    to implement, and the strings can be any length. On the other hand, zero-terminated
    strings have a few drawbacks. First, though not usually important, zero-terminated
    strings cannot contain the NUL character (whose ASCII code is 0). Generally, this
    isn''t a problem, but it does create havoc once in a while. The second problem
    with zero-terminated strings is that many operations on them are somewhat inefficient.
    For example, to compute the length of a zero-terminated string, you must scan
    the entire string looking for that 0 byte (counting characters up to the 0). The
    following program fragment demonstrates how to compute the length of the string
    above:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 零终止字符串有两个主要特点：它们非常容易实现，并且字符串长度没有限制。另一方面，零终止字符串也有一些缺点。首先，虽然通常不重要，零终止字符串不能包含 NUL
    字符（其 ASCII 码为 0）。通常这不是问题，但偶尔会带来麻烦。零终止字符串的第二个问题是，许多操作相对低效。例如，为了计算零终止字符串的长度，你必须扫描整个字符串，寻找那个
    0 字节（即计算字符直到遇到 0）。下面的程序片段演示了如何计算上述字符串的长度：
- en: '[PRE56]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see from this code, the time it takes to compute the length of the
    string is proportional to the length of the string; as the string gets longer,
    it takes longer to compute its length.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从这段代码中看到的，计算字符串长度所需的时间与字符串的长度成正比；随着字符串变长，计算其长度所需的时间也会增加。
- en: 'A second string format, *length-prefixed strings*, overcomes some of the problems
    with zero-terminated strings. Length-prefixed strings are common in languages
    like Pascal; they generally consist of a length byte followed by zero or more
    character values. The first byte specifies the string length, and the following
    bytes (up to the specified length) are the character data. In a length-prefixed
    scheme, the string `abc` would consist of the 4 bytes `$03` (the string length)
    followed by `a`, `b`, and `c`. You can create length-prefixed strings in HLA using
    code like the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种字符串格式，*长度前缀字符串*，克服了零终止字符串的一些问题。长度前缀字符串在像 Pascal 这样的语言中很常见；它们通常由一个长度字节和零个或多个字符值组成。第一个字节指定字符串的长度，接下来的字节（直到指定的长度）是字符数据。在长度前缀方案中，字符串`abc`将由4个字节组成，分别是
    `$03`（字符串长度）后跟 `a`、`b` 和 `c`。你可以在 HLA 中使用如下代码创建长度前缀字符串：
- en: '[PRE57]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Counting the characters ahead of time and inserting them into the byte statement,
    as was done here, may seem like a major pain. Fortunately, there are ways to have
    HLA automatically compute the string length for you.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 提前计算字符数并将其插入到字节声明中，如同这里所做的那样，可能看起来是一项麻烦的工作。幸运的是，有一些方法可以让 HLA 自动计算字符串的长度。
- en: Length-prefixed strings solve the two major problems associated with zero-terminated
    strings. It is possible to include the NUL character in length-prefixed strings,
    and those operations on zero-terminated strings that are relatively inefficient
    (e.g., string length) are more efficient when using length-prefixed strings. However,
    length-prefixed strings have their own drawbacks. The principal drawback is that
    they are limited to a maximum of 255 characters in length (assuming a 1-byte length
    prefix).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 长度前缀字符串解决了与零终止字符串相关的两个主要问题。可以在长度前缀字符串中包含 NUL 字符，并且那些在零终止字符串上相对低效的操作（例如，计算字符串长度）在使用长度前缀字符串时更高效。然而，长度前缀字符串也有它们自己的缺点。主要的缺点是它们的长度最大限制为
    255 个字符（假设使用 1 字节长度前缀）。
- en: HLA uses an expanded scheme for strings that is upward compatible with both
    zero-terminated and length-prefixed strings. HLA strings enjoy the advantages
    of both zero-terminated and length-prefixed strings without the disadvantages.
    In fact, the only drawback to HLA strings over these other formats is that HLA
    strings consume a few additional bytes (the overhead for an HLA string is 9 to
    12 bytes compared to 1 byte for zero-terminated or length-prefixed strings, the
    overhead being the number of bytes needed above and beyond the actual characters
    in the string).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 使用一种扩展的字符串方案，该方案与零终止字符串和长度前缀字符串向上兼容。HLA 字符串享有零终止字符串和长度前缀字符串的优点，而没有它们的缺点。事实上，HLA
    字符串相对于这些其他格式的唯一缺点是，它比零终止或长度前缀字符串消耗了几个额外的字节（HLA 字符串的开销为 9 到 12 字节，而零终止或长度前缀字符串的开销为
    1 字节，开销是指实际字符之外所需的字节数）。
- en: An HLA string value consists of four components. The first element is a double-word
    value that specifies the maximum number of characters that the string can hold.
    The second element is a double-word value specifying the current length of the
    string. The third component is the sequence of characters in the string. The final
    component is a zero-terminating byte. You could create an HLA-compatible string
    in the `static` section using code like the following:^([[51](#ftn.CHP-4-FN-5)])
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 字符串值由四个组件组成。第一个元素是一个双字值，指定字符串可以容纳的最大字符数。第二个元素是一个双字值，指定字符串的当前长度。第三个组件是字符串中的字符序列。最后一个组件是一个零终止字节。你可以使用以下代码在
    `static` 区段创建一个兼容 HLA 的字符串：^([[51](#ftn.CHP-4-FN-5)])
- en: '[PRE58]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that the address associated with the HLA string is the address of the first
    character, not the maximum or current length values.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，HLA 字符串关联的地址是第一个字符的地址，而不是最大值或当前长度值。
- en: '"So what is the difference between the current and maximum string lengths?"
    you''re probably wondering. In a literal string they are usually the same. However,
    when you allocate storage for a string variable at runtime, you will normally
    specify the maximum number of characters that can go into the string. When you
    store actual string data into the string, the number of characters you store must
    be less than or equal to this maximum value. The HLA Standard Library string routines
    will raise an exception if you attempt to exceed this maximum length (something
    the C/C++ and Pascal formats can''t do).'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: “那么当前字符串长度和最大字符串长度有什么区别呢？”你可能会想。在一个字面量字符串中，它们通常是相同的。然而，当你在运行时为字符串变量分配存储时，通常会指定字符串可以容纳的最大字符数。当你将实际的字符串数据存储到字符串中时，存储的字符数必须小于或等于这个最大值。如果你尝试超过这个最大长度，HLA
    标准库的字符串例程将抛出异常（这是 C/C++ 和 Pascal 格式无法做到的）。
- en: The terminating 0 byte at the end of the HLA string lets you treat an HLA string
    as a zero-terminated string if it is more efficient or more convenient to do so.
    For example, most calls to Windows, Mac OS X, FreeBSD, and Linux require zero-terminated
    strings for their string parameters. Placing a 0 at the end of an HLA string ensures
    compatibility with the operating system and other library modules that use zero-terminated
    strings.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 字符串末尾的终止 0 字节使得你可以将 HLA 字符串视为一个零终止字符串，如果这样做更高效或更方便。例如，大多数对 Windows、Mac OS
    X、FreeBSD 和 Linux 的调用都需要零终止字符串作为它们的字符串参数。在 HLA 字符串末尾放置一个 0 确保与操作系统以及使用零终止字符串的其他库模块的兼容性。
- en: '* * *'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[51](#CHP-4-FN-5)]) Actually, there are some restrictions on the placement
    of HLA strings in memory. This text will not cover those issues. See the HLA documentation
    for more details.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[51](#CHP-4-FN-5)]) 事实上，HLA 字符串在内存中的存放位置有一些限制。本文不涉及这些问题。有关更多详细信息，请参见 HLA
    文档。
- en: 4.8 HLA Strings
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.8 HLA 字符串
- en: 'As the previous section notes, HLA strings consist of four components: a maximum
    length, a current string length, character data, and a zero-terminating byte.
    However, HLA never requires you to create string data by manually emitting these
    components yourself. HLA is smart enough to automatically construct this data
    for you whenever it sees a string literal constant. So if you use a string constant
    like the following, understand that somewhere HLA is creating the four-component
    string in memory for you:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，HLA 字符串由四个组件组成：最大长度、当前字符串长度、字符数据和零终止字节。然而，HLA 从不要求你手动创建字符串数据来发出这些组件。HLA
    足够智能，当它看到字符串常量时，会自动为你构建这些数据。因此，如果你使用以下字符串常量，请理解在某个地方 HLA 会在内存中为你创建这个四组件字符串：
- en: '[PRE59]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'HLA doesn''t actually work directly with the string data described in the previous
    section. Instead, when HLA sees a string object, it always works with a *pointer*
    to that object rather than working directly with the object. Without question,
    this is the most important fact to know about HLA strings and is the biggest source
    of problems beginning HLA programmers have with strings in HLA: *Strings are pointers!*
    A string variable consumes exactly 4 bytes, the same as a pointer (because it
    is a pointer!). Having said all that, let''s look at a simple string variable
    declaration in HLA:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 实际上并不直接处理前一部分描述的字符串数据。相反，当 HLA 看到一个字符串对象时，它总是处理指向该对象的*指针*，而不是直接处理对象。毫无疑问，这是关于
    HLA 字符串最重要的事实，也是初学者在处理 HLA 字符串时遇到问题的最大源头：*字符串是指针！* 一个字符串变量占用的空间正好是 4 个字节，与指针相同（因为它就是一个指针！）。说完这些，我们来看一下
    HLA 中一个简单的字符串变量声明：
- en: '[PRE60]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Because a string variable is a pointer, you must initialize it before you can
    use it. There are three general ways you may initialize a string variable with
    a legal string address: using static initializers, using the `str.alloc` routine,
    or calling some other HLA Standard Library function that initializes a string
    or returns a pointer to a string.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 因为字符串变量是指针，所以你必须在使用它之前初始化它。你可以通过三种常见方式来初始化一个合法字符串地址的字符串变量：使用静态初始化器，使用 `str.alloc`
    例程，或者调用其他初始化字符串或返回字符串指针的 HLA 标准库函数。
- en: 'In one of the static declaration sections that allow initialized variables
    (`static` and `readonly`) you can initialize a string variable using the standard
    initialization syntax. For example:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个允许初始化变量（`static` 和 `readonly`）的静态声明部分，你可以使用标准初始化语法来初始化一个字符串变量。例如：
- en: '[PRE61]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note that this does not initialize the string variable with the string data.
    Instead, HLA creates the string data structure (see [4.7 Character Strings](ch04s07.html
    "4.7 Character Strings")) in a special, hidden, memory segment and initializes
    the `InitializedString` variable with the address of the first character in this
    string (the `T` in `This`). *Remember, strings are pointers!* The HLA compiler
    places the actual string data in a read-only memory segment. Therefore, you cannot
    modify the characters of this string literal at runtime. However, because the
    string variable (a pointer, remember) is in the `static` section, you can change
    the string variable so that it points at different string data.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这并不会用字符串数据初始化字符串变量。相反，HLA 会在一个特殊的、隐藏的内存段中创建字符串数据结构（参见[4.7 字符串](ch04s07.html
    "4.7 字符串")），并将 `InitializedString` 变量初始化为该字符串第一个字符的地址（`This` 中的 `T`）。*记住，字符串是指针！*
    HLA 编译器将实际的字符串数据放置在只读内存段中。因此，您无法在运行时修改此字符串字面量的字符。然而，由于字符串变量（记住，它是一个指针）位于 `static`
    部分，因此你可以更改字符串变量，使其指向不同的字符串数据。
- en: Because string variables are pointers, you can load the value of a string variable
    into a 32-bit register. The pointer itself points at the first character position
    of the string. You can find the current string length in the double-word 4 bytes
    prior to this address, and you can find the maximum string length in the double-word
    8 bytes prior to this address. The program in [Example 4-8](ch04s08.html#accessing_the_length_and_maximum_length
    "Example 4-8. Accessing the length and maximum length fields of a string") demonstrates
    one way to access this data.^([[52](#ftn.CHP-4-FN-6)])
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 因为字符串变量是指针，你可以将字符串变量的值加载到一个 32 位寄存器中。指针本身指向字符串的第一个字符位置。你可以在这个地址前的双字 4 个字节中找到当前字符串的长度，并且可以在这个地址前的双字
    8 个字节中找到字符串的最大长度。[示例 4-8](ch04s08.html#accessing_the_length_and_maximum_length
    "示例 4-8：访问字符串的长度和最大长度字段") 中的程序演示了一种访问这些数据的方法。^([[52](#ftn.CHP-4-FN-6)])
- en: Example 4-8. Accessing the length and maximum length fields of a string
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-8：访问字符串的长度和最大长度字段
- en: '[PRE62]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: When accessing the various fields of a string variable, it is not wise to access
    them using fixed numeric offsets as done in [Example 4-8](ch04s08.html#accessing_the_length_and_maximum_length
    "Example 4-8. Accessing the length and maximum length fields of a string"). In
    the future, the definition of an HLA string may change slightly. In particular,
    the offsets to the maximum length and length fields are subject to change. A safer
    way to access string data is to coerce your string pointer using the `str.strRec`
    data type. The `str.strRec` data type is a `record` data type (see [4.25 Records](ch04s25.html
    "4.25 Records")) that defines symbolic names for the offsets of the length and
    maximum length fields in the `string` data type. If the offsets to the length
    and maximum length fields were to change in a future version of HLA, then the
    definitions in `str.strRec` would also change. So if you use `str.strRec`, then
    recompiling your program would automatically make any necessary changes to your
    program.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问字符串变量的各个字段时，像[Example 4-8](ch04s08.html#accessing_the_length_and_maximum_length
    "Example 4-8. Accessing the length and maximum length fields of a string")中那样使用固定的数字偏移量是不明智的。未来，HLA字符串的定义可能会稍作更改，特别是最大长度和长度字段的偏移量可能会发生变化。访问字符串数据的更安全方法是通过使用`str.strRec`数据类型来强制转换你的字符串指针。`str.strRec`数据类型是一个`record`数据类型（参见[4.25
    Records](ch04s25.html "4.25 Records")），它为`string`数据类型中长度和最大长度字段的偏移量定义了符号名称。如果将来HLA版本中长度和最大长度字段的偏移量发生变化，那么`str.strRec`中的定义也会随之变化。因此，如果使用`str.strRec`，那么重新编译程序会自动对程序进行必要的更改。
- en: To use the `str.strRec` data type properly, you must first load the string pointer
    into a 32-bit register; for example, `mov( SomeString, ebx );`. Once the pointer
    to the string data is in a register, you can coerce that register to the `str.strRec`
    data type using the HLA construct `(type str.strRec [ebx])`. Finally, to access
    the length or maximum length fields, you would use either `(type str.strRec [ebx]).length`
    or `(type str.strRec [ebx]).maxlen` (respectively). Although there is a little
    more typing involved (versus using simple offsets like −4 or −8), these forms
    are far more descriptive and much safer than straight numeric offsets. The program
    in [Example 4-9](ch04s08.html#correct_way_to_access_the_length_and_max "Example 4-9. Correct
    way to access the length and maxlen fields of a string") corrects the example
    in [Example 4-8](ch04s08.html#accessing_the_length_and_maximum_length "Example 4-8. Accessing
    the length and maximum length fields of a string") by using the `str.strRec` data
    type.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确使用`str.strRec`数据类型，首先必须将字符串指针加载到一个32位寄存器中；例如，`mov( SomeString, ebx );`。一旦字符串数据的指针被加载到寄存器中，就可以使用HLA构造
    `(type str.strRec [ebx])` 将该寄存器强制转换为`str.strRec`数据类型。最后，要访问长度或最大长度字段，可以分别使用`(type
    str.strRec [ebx]).length` 或`(type str.strRec [ebx]).maxlen`。虽然这涉及更多的输入（相比于使用简单的偏移量，如−4或−8），但这些形式比直接使用数字偏移量更加描述性且更安全。示例程序[Example
    4-9](ch04s08.html#correct_way_to_access_the_length_and_max "Example 4-9. Correct
    way to access the length and maxlen fields of a string")通过使用`str.strRec`数据类型，修正了[Example
    4-8](ch04s08.html#accessing_the_length_and_maximum_length "Example 4-8. Accessing
    the length and maximum length fields of a string")中的例子。
- en: Example 4-9. Correct way to access the `length` and `maxlen` fields of a string
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4-9。正确访问字符串的`length`和`maxlen`字段
- en: '[PRE63]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'A second way to manipulate strings in HLA is to allocate storage on the heap
    to hold string data. Because strings can''t directly use pointers returned by
    `mem.alloc` (string operations access the 8 bytes prior to the address), you shouldn''t
    use `mem.alloc` to allocate storage for string data. Fortunately, the HLA Standard
    Library memory module provides a memory allocation routine specifically designed
    to allocate storage for strings: `str.alloc`. Like `mem.alloc`, `str.alloc` expects
    a single double-word parameter. This value specifies the maximum number of characters
    allowed in the string. The `str.alloc` routine will allocate the specified number
    of bytes of memory, plus between 9 and 13 additional bytes to hold the extra string
    information.^([[53](#ftn.CHP-4-FN-7)])'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在HLA中操作字符串的第二种方法是分配堆内存来存储字符串数据。由于字符串不能直接使用`mem.alloc`返回的指针（字符串操作访问的是地址前8个字节），因此不应使用`mem.alloc`为字符串数据分配内存。幸运的是，HLA标准库的内存模块提供了一个专门为字符串数据分配存储的内存分配例程：`str.alloc`。与`mem.alloc`类似，`str.alloc`也期望一个双字参数。这个值指定字符串中允许的最大字符数。`str.alloc`例程将分配指定数量的字节内存，再加上9到13个额外字节来存储额外的字符串信息。^([[53](#ftn.CHP-4-FN-7)])
- en: The `str.alloc` routine will allocate storage for a string, initialize the maximum
    length to the value passed as the `str.alloc` parameter, initialize the current
    length to 0, and store a zero-terminating byte in the first character position
    of the string. After this, `str.alloc` returns the address of the zero-terminating
    byte (that is, the address of the first character element) in the EAX register.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.alloc`例程将为字符串分配存储空间，将最大长度初始化为作为`str.alloc`参数传入的值，将当前长度初始化为0，并在字符串的第一个字符位置存储一个零终止字节。之后，`str.alloc`会将零终止字节的地址（即第一个字符元素的地址）返回到EAX寄存器中。'
- en: Once you've allocated storage for a string, you can call various string-manipulation
    routines in the HLA Standard Library to manipulate the string. The next section
    discusses a few of the HLA string routines in detail; this section introduces
    a couple of string-related routines for the sake of example. The first such routine
    is the `stdin.gets(` *`strvar`* `);`. This routine reads a string from the user
    and stores the string data into the string storage pointed at by the string parameter
    (*`strvar`* in this case). If the user attempts to enter more characters than
    the maximum the string allows, then `stdin.gets` raises the `ex.StringOverflow`
    exception. The program in [Example 4-10](ch04s08.html#reading_a_string_from_the_user
    "Example 4-10. Reading a string from the user") demonstrates the use of `str.alloc`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为字符串分配了存储空间，你可以调用HLA标准库中的各种字符串处理例程来操作该字符串。下一部分将详细讨论一些HLA字符串例程；本节为了举例，介绍了几个与字符串相关的例程。第一个例程是`stdin.gets(`
    *`strvar`* `);`。这个例程从用户处读取一个字符串，并将字符串数据存储到由字符串参数（此例中为*`strvar`*）指向的字符串存储区。如果用户试图输入超过字符串最大允许长度的字符，`stdin.gets`会引发`ex.StringOverflow`异常。[示例
    4-10](ch04s08.html#reading_a_string_from_the_user "示例 4-10。读取用户输入的字符串")中的程序演示了如何使用`str.alloc`。
- en: Example 4-10. Reading a string from the user
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-10。读取用户输入的字符串
- en: '[PRE64]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If you look closely, you'll see a slight defect in the program above. It allocates
    storage for the string by calling `str.alloc`, but it never frees the storage
    allocated. Even though the program immediately exits after the last use of the
    string variable, and the operating system will deallocate the storage, it's always
    a good idea to explicitly free up any storage you allocate. Doing so keeps you
    in the habit of freeing allocated storage (so you don't forget to do it when it's
    important); also, programs have a way of growing such that an innocent defect
    that doesn't affect anything in today's program becomes a show-stopping defect
    in tomorrow's version.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会发现上面程序有一个小缺陷。它通过调用`str.alloc`为字符串分配存储空间，但它从未释放所分配的存储空间。即使程序在最后一次使用字符串变量后立即退出，操作系统会回收该存储空间，但显式地释放你分配的存储空间始终是个好习惯。这样做可以帮助你养成释放已分配存储的习惯（避免在重要时刻忘记释放）；此外，程序总是有增长的可能，一个在当前版本中看似无害的小缺陷，可能会在明天的版本中变成致命的缺陷。
- en: To free storage you allocate via `str.alloc`, you must call the `str.free` routine,
    passing the string pointer as the single parameter. The program in [Example 4-11](ch04s08.html#corrected_program_that_reads_a_string_fr
    "Example 4-11. Corrected program that reads a string from the user") is a correction
    of the program [Example 4-10](ch04s08.html#reading_a_string_from_the_user "Example 4-10. Reading
    a string from the user") with this defect corrected.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要释放通过`str.alloc`分配的存储空间，必须调用`str.free`例程，并将字符串指针作为唯一参数传入。[示例 4-11](ch04s08.html#corrected_program_that_reads_a_string_fr
    "示例 4-11。修正后的程序，从用户读取字符串")中的程序是[示例 4-10](ch04s08.html#reading_a_string_from_the_user
    "示例 4-10。读取用户输入的字符串")的修正版本，修正了这个缺陷。
- en: Example 4-11. Corrected program that reads a string from the user
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-11。修正后的程序，从用户读取字符串
- en: '[PRE65]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: When looking at this corrected program, please take note that the `stdin.gets`
    routine expects you to pass it a string parameter that points at an allocated
    string object. Without question, one of the most common mistakes beginning HLA
    programmers make is to call `stdin.gets` and pass it a string variable that they
    have not initialized. This may be getting old now, but keep in mind that *strings
    are pointers!* Like pointers, if you do not initialize a string with a valid address,
    your program will probably crash when you attempt to manipulate that string object.
    The call to `str.alloc` and the following `mov` instruction is how the programs
    above initialize the string pointer. If you are going to use string variables
    in your programs, you must ensure that you allocate storage for the string data
    prior to writing data to the string object.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看这个修正后的程序时，请注意，`stdin.gets`例程期望你传递一个指向已分配字符串对象的字符串参数。无疑，初学HLA的程序员常犯的一个错误就是调用`stdin.gets`并传递一个未初始化的字符串变量。虽然这可能已经听得很烦了，但请记住，*字符串是指针！*
    就像指针一样，如果你没有用有效的地址初始化字符串，那么当你尝试操作这个字符串对象时，程序很可能会崩溃。上面的程序通过调用`str.alloc`和随后的`mov`指令来初始化字符串指针。如果你在程序中使用字符串变量，你必须确保在向字符串对象写入数据之前为字符串数据分配存储空间。
- en: Allocating storage for a string is such a common operation that many HLA Standard
    Library routines will automatically allocate the storage for you. Generally, such
    routines have an `a_` prefix as part of their name. For example, the `stdin.a_gets`
    combines a call to `str.alloc` and `stdin.gets` into the same routine. This routine,
    which doesn't have any parameters, reads a line of text from the user, allocates
    a string object to hold the input data, and then returns a pointer to the string
    in the EAX register. [Example 4-12](ch04s08.html#reading_a_string_from_the_user_with_stdi
    "Example 4-12. Reading a string from the user with stdin.a_gets") presents an
    adaptation of the two programs in [Example 4-10](ch04s08.html#reading_a_string_from_the_user
    "Example 4-10. Reading a string from the user") and [Example 4-11](ch04s08.html#corrected_program_that_reads_a_string_fr
    "Example 4-11. Corrected program that reads a string from the user") that uses
    `stdin.a_gets`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为字符串分配存储空间是一个非常常见的操作，因此许多HLA标准库例程会自动为你分配存储空间。通常，这些例程的名称中会带有`a_`前缀。例如，`stdin.a_gets`将调用`str.alloc`和`stdin.gets`合并成同一个例程。这个例程没有任何参数，它会从用户处读取一行文本，分配一个字符串对象来保存输入数据，然后将指向字符串的指针返回到EAX寄存器中。[示例
    4-12](ch04s08.html#reading_a_string_from_the_user_with_stdi "示例 4-12. 使用stdin.a_gets从用户读取字符串")展示了一个改编版，它结合了[示例
    4-10](ch04s08.html#reading_a_string_from_the_user "示例 4-10. 从用户读取字符串")和[示例 4-11](ch04s08.html#corrected_program_that_reads_a_string_fr
    "示例 4-11. 修正后的程序，用于从用户读取字符串")，并使用了`stdin.a_gets`。
- en: Example 4-12. Reading a string from the user with `stdin.a_gets`
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-12. 使用`stdin.a_gets`从用户读取字符串
- en: '[PRE66]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Note that, as before, you must still free up the storage `stdin.a_gets` allocates
    by calling the `str.free` routine. One big difference between this routine and
    the previous two is the fact that HLA will automatically allocate exactly enough
    space for the string read from the user. In the previous programs, the call to
    `str.alloc` allocates only 16 bytes. If the user types more than 16 characters,
    then the program raises an exception and quits. If the user types fewer than 16
    characters, then some space at the end of the string is wasted. The `stdin.a_gets`
    routine, on the other hand, always allocates the minimum necessary space for the
    string read from the user. Because it allocates the storage, there is little chance
    of overflow.^([[54](#ftn.CHP-4-FN-8)])
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与之前一样，你仍然需要通过调用`str.free`例程来释放`stdin.a_gets`分配的存储空间。这个例程与之前的两个例程的一个重要区别是，HLA会自动为从用户读取的字符串分配刚好足够的空间。在之前的程序中，调用`str.alloc`仅分配16字节的空间。如果用户输入超过16个字符，程序会抛出异常并退出。如果用户输入少于16个字符，则字符串末尾的空间会被浪费。而`stdin.a_gets`例程则始终为从用户读取的字符串分配最小所需的空间。由于它会分配存储空间，因此溢出的可能性很小。^([[54](#ftn.CHP-4-FN-8)])
- en: '* * *'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[52](#CHP-4-FN-6)]) Note that this scheme is not recommended. If you need
    to extract the length information from a string, use the routines provided in
    the HLA string library for this purpose.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[52](#CHP-4-FN-6)]) 请注意，这种方案不推荐使用。如果你需要从字符串中提取长度信息，请使用HLA字符串库提供的例程来实现。
- en: ^([[53](#CHP-4-FN-7)]) `str.alloc` may allocate more than 9 bytes for the overhead
    data because the memory allocated to an HLA string must always be double-word
    aligned, and the total length of the data structure must be a multiple of 4.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[53](#CHP-4-FN-7)]) `str.alloc`可能会为开销数据分配超过9字节的内存，因为分配给HLA字符串的内存必须始终是双字对齐的，并且数据结构的总长度必须是4的倍数。
- en: ^([[54](#CHP-4-FN-8)]) Actually, there are limits on the maximum number of characters
    that `stdin.a_gets` will allocate. This is typically between 1,024 bytes and 4,096
    bytes. See the HLA Standard Library source listings and your operating system
    documentation for the exact value.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[54](#CHP-4-FN-8)]) 事实上，`stdin.a_gets`分配的最大字符数是有限制的。通常这个范围在1,024字节到4,096字节之间。具体值请参考HLA标准库源代码和操作系统文档。
- en: 4.9 Accessing the Characters Within a String
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.9 访问字符串中的字符
- en: Extracting individual characters from a string is a very common task. It is
    so easy that HLA doesn't provide any specific procedure or language syntax to
    accomplish this—you simply use machine instructions to accomplish this. Once you
    have a pointer to the string data, a simple indexed addressing mode will do the
    rest of the work for you.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 从字符串中提取单个字符是一个非常常见的任务。它非常简单，以至于HLA没有提供任何特定的过程或语言语法来实现这一点——你只需使用机器指令即可完成。只要你有一个指向字符串数据的指针，简单的索引寻址模式就可以完成其余的工作。
- en: Of course, the most important thing to keep in mind is that *strings are pointers*.
    Therefore, you cannot apply an indexed addressing mode directly to a string variable
    and expect to extract characters from the string. That is, if `s` is a string
    variable, then `mov( s[ebx], al )`; does not fetch the character at position EBX
    in string `s` and place it in the AL register. Remember, `s` is just a pointer
    variable; an addressing mode like `s[ebx]` will simply fetch the byte at offset
    EBX in memory starting at the address of `s` (see [Figure 4-1](ch04s09.html#incorrectly_indexing_off_a_string_variab
    "Figure 4-1. Incorrectly indexing off a string variable")).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最重要的是要记住，*字符串是指针*。因此，你不能直接对字符串变量应用索引寻址模式来提取字符串中的字符。也就是说，如果`s`是一个字符串变量，那么`mov(
    s[ebx], al )`；并不会获取字符串`s`中EBX位置的字符并将其放入AL寄存器中。记住，`s`只是一个指针变量；像`s[ebx]`这样的寻址模式只是会从`s`的地址开始，按偏移量EBX获取内存中的字节（见[图4-1](ch04s09.html#incorrectly_indexing_off_a_string_variab
    "图4-1. 错误地从字符串变量进行索引")）。
- en: '![Incorrectly indexing off a string variable](tagoreillycom20100401nostarchimages577979.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![错误地从字符串变量进行索引](tagoreillycom20100401nostarchimages577979.png)'
- en: Figure 4-1. Incorrectly indexing off a string variable
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-1. 错误地从字符串变量进行索引
- en: In [Figure 4-1](ch04s09.html#incorrectly_indexing_off_a_string_variab "Figure 4-1. Incorrectly
    indexing off a string variable"), assuming EBX contains 3, `s[ebx]` does not access
    the fourth character in the string `s`; instead it fetches the fourth byte of
    the pointer to the string data. It is very unlikely that this is what you would
    want. [Figure 4-2](ch04s09.html#correctly_indexing_off_the_value_of_a_st "Figure 4-2. Correctly
    indexing off the value of a string variable") shows the operation that is necessary
    to fetch a character from the string, assuming EBX contains the value of `s`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图4-1](ch04s09.html#incorrectly_indexing_off_a_string_variab "图4-1. 错误地从字符串变量进行索引")中，假设EBX的值为3，`s[ebx]`并不会访问字符串`s`中的第四个字符；相反，它会获取指向字符串数据的指针的第四个字节。这很可能不是你想要的。[图4-2](ch04s09.html#correctly_indexing_off_the_value_of_a_st
    "图4-2. 正确地从字符串变量的值中进行索引")展示了在假设EBX包含`s`的值时，如何从字符串中提取字符的必要操作。
- en: '![Correctly indexing off the value of a string variable](tagoreillycom20100401nostarchimages577981.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![正确地从字符串变量进行索引](tagoreillycom20100401nostarchimages577981.png)'
- en: Figure 4-2. Correctly indexing off the value of a string variable
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-2. 正确地从字符串变量的值中进行索引
- en: 'In [Figure 4-2](ch04s09.html#correctly_indexing_off_the_value_of_a_st "Figure 4-2. Correctly
    indexing off the value of a string variable") EBX contains the value of string
    `s`. The value of `s` is a pointer to the actual string data in memory. Therefore,
    EBX will point at the first character of the string when you load the value of
    `s` into EBX. The following code demonstrates how to access the fourth character
    of string `s` in this fashion:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图4-2](ch04s09.html#correctly_indexing_off_the_value_of_a_st "图4-2. 正确地从字符串变量的值中进行索引")中，EBX包含字符串`s`的值。`s`的值是指向内存中实际字符串数据的指针。因此，当你将`s`的值加载到EBX中时，EBX将指向字符串的第一个字符。以下代码演示了如何以这种方式访问字符串`s`的第四个字符：
- en: '[PRE67]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If you want to load the character at a variable, rather than fixed, offset
    into the string, then you can use one of the 80x86''s scaled indexed addressing
    modes to fetch the character. For example, if an `uns32` variable `index` contains
    the desired offset into the string, you could use the following code to access
    the character at `s[index]`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想加载字符串中位于变量而非固定偏移量处的字符，可以使用80x86的缩放索引寻址模式来获取该字符。例如，如果一个`uns32`变量`index`包含了字符串中的目标偏移量，你可以使用以下代码访问`s[index]`处的字符：
- en: '[PRE68]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'There is only one problem with the code above—it does not check to ensure that
    the character at offset `index` actually exists. If `index` is greater than the
    current length of the string, then this code will fetch a garbage byte from memory.
    Unless you can a priori determine that `index` is always less than the length
    of the string, code like this is dangerous to use. A better solution is to check
    the index against the string''s current length before attempting to access the
    character. The following code provides one way to do this:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码只有一个问题——它没有检查偏移量`index`处的字符是否真实存在。如果`index`大于字符串当前的长度，那么这段代码将从内存中获取一个垃圾字节。除非你能事先确定`index`总是小于字符串的长度，否则像这样的代码是很危险的。一个更好的解决方案是在尝试访问字符之前，先检查索引是否在字符串当前的长度范围内。以下代码提供了实现此操作的一种方法：
- en: '[PRE69]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In the `else` portion of this `if` statement you could take corrective action,
    print an error message, or raise an exception. If you want to explicitly raise
    an exception, you can use the HLA `raise` statement to accomplish this. The syntax
    for the `raise` statement is
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在此`if`语句的`else`部分，你可以采取纠正措施，打印错误信息，或者引发异常。如果你想明确引发异常，可以使用HLA的`raise`语句来实现。`raise`语句的语法是
- en: '[PRE70]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The value of the *`integer_constant`* or 32-bit register must be an exception
    number. Usually, this is one of the predefined constants in the *excepts.hhf*
    header file. An appropriate exception to raise when a string index is greater
    than the length of the string is `ex.StringIndexError`. The following code demonstrates
    raising this exception if the string index is out of bounds:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '*`integer_constant`*或32位寄存器的值必须是一个异常编号。通常，这是*excepts.hhf*头文件中的一个预定义常量。当字符串索引大于字符串长度时，应该引发的适当异常是`ex.StringIndexError`。以下代码演示了如果字符串索引越界时引发此异常：'
- en: '[PRE71]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 4.10 The HLA String Module and Other String-Related Routines
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.10 HLA字符串模块与其他字符串相关例程
- en: Although HLA provides a powerful definition for string data, the real power
    behind HLA's string capabilities lies in the HLA Standard Library, not in the
    definition of HLA string data. HLA provides hundreds of string-manipulation routines
    that far exceed the capabilities found in standard high-level languages like C/C++,
    Java, or Pascal; indeed, HLA's string-handling capabilities rival those in string-processing
    languages like Icon or SNOBOL4\. This chapter discusses several of the string
    functions that the HLA Standard Library provides.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管HLA为字符串数据提供了强大的定义，但HLA字符串功能背后的真正强大之处在于HLA标准库，而不是HLA字符串数据的定义。HLA提供了数百个字符串处理例程，远超标准高级语言（如C/C++、Java或Pascal）中的功能；事实上，HLA的字符串处理能力堪比字符串处理语言（如Icon或SNOBOL4）。本章讨论了HLA标准库提供的几种字符串函数。
- en: 'Perhaps the most basic string operation you will need is to assign one string
    to another. There are three different ways to assign strings in HLA: by reference,
    by copying a string, and by duplicating a string. Of these, assignment by reference
    is the fastest and easiest. If you have two strings and you wish to assign one
    string to the other, a simple and fast way to do this is to copy the string pointer.
    The following code fragment demonstrates this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要的最基本字符串操作就是将一个字符串赋值给另一个字符串。HLA中有三种不同的方法来赋值字符串：通过引用赋值、通过复制字符串赋值和通过重复字符串赋值。在这三种方法中，通过引用赋值是最快且最简单的。如果你有两个字符串，并希望将一个字符串赋给另一个字符串，一种简单且快速的方法是复制字符串指针。以下代码片段演示了这一点：
- en: '[PRE72]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: String assignment by reference is very efficient because it involves only two
    simple `mov` instructions regardless of the string length. Assignment by reference
    works great if you never modify the string data after the assignment operation.
    Do keep in mind, though, that both string variables (`string1` and `string2` in
    the example above) *wind up pointing at the same data*. So if you make a change
    to the data pointed at by one string variable, you will change the string data
    pointed at by the second string object because both objects point at the same
    data. [Example 4-13](ch04s10.html#problem_with_string_assignment_by_copyin "Example 4-13. Problem
    with string assignment by copying pointers") provides a program that demonstrates
    this problem.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用进行字符串赋值非常高效，因为无论字符串长度如何，它只涉及执行两条简单的`mov`指令。如果在赋值操作之后你不再修改字符串数据，引用赋值效果很好。不过，请记住，两个字符串变量（在上述例子中为`string1`和`string2`）*最终指向相同的数据*。因此，如果你修改了一个字符串变量指向的数据，你也会修改第二个字符串对象所指向的数据，因为这两个对象指向的是相同的数据。[示例
    4-13](ch04s10.html#problem_with_string_assignment_by_copyin "示例 4-13. 通过复制指针进行字符串赋值的问题")提供了一个演示该问题的程序。
- en: Example 4-13. Problem with string assignment by copying pointers
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-13. 通过复制指针进行字符串赋值的问题
- en: '[PRE73]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Because both `string1` and `string2` point at the same string data in this example,
    any change you make to one string is reflected in the other. While this is sometimes
    acceptable, most programmers expect assignment to produce a different copy of
    a string; that is, they expect the semantics of string assignment to produce two
    unique copies of the string data.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在这个例子中`string1`和`string2`都指向相同的字符串数据，所以对一个字符串所做的任何修改都会反映到另一个字符串上。虽然这种情况有时是可以接受的，但大多数程序员期望赋值操作会生成字符串的不同副本；也就是说，他们期望字符串赋值的语义能够生成两个独立的字符串数据副本。
- en: An important point to remember when using *copy by reference* (this term means
    copying a pointer) is that you have created an alias of the string data. The term
    *alias* means that you have two names for the same object in memory (for example,
    in the program above, `string1` and `string2` are two different names for the
    same string data). When you read a program, it is reasonable to expect that different
    variables refer to different memory objects. Aliases violate this rule, thus making
    your program harder to read and understand because you have to remember that aliases
    do not refer to different objects in memory. Failing to keep this in mind can
    lead to subtle bugs in your program. For instance, in the example above you have
    to remember that `string1` and `string2` are aliases so as not to free both objects
    at the end of the program. Worse still, you have to remember that `string1` and
    `string2` are aliases so that you don't continue to use `string2` after freeing
    `string1` because `string2` would be a dangling reference at that point.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*引用复制*（这个术语意味着复制一个指针）时，必须记住一个重要的点，那就是你创建了字符串数据的别名。术语*别名*意味着你有两个不同的名称指向内存中的同一个对象（例如，在上述程序中，`string1`和`string2`是指向同一字符串数据的两个不同名称）。当你阅读一个程序时，合理的期望是不同的变量指向不同的内存对象。别名违反了这一规则，从而使得程序更难阅读和理解，因为你必须记住别名并不指向内存中不同的对象。如果不记住这一点，可能会导致程序中的微妙错误。例如，在上述例子中，你必须记住`string1`和`string2`是别名，以避免在程序结束时释放这两个对象。更糟糕的是，你必须记住`string1`和`string2`是别名，这样你就不会在释放`string1`后继续使用`string2`，因为此时`string2`将成为一个悬空引用。
- en: 'Because using copy by reference makes your programs harder to read and increases
    the possibility that you might introduce subtle defects into your programs, you
    might wonder why someone would use copy by reference at all. There are two reasons
    for this: First, copy by reference is very efficient; it involves only the execution
    of two `mov` instructions. Second, some algorithms actually depend on copy-by-reference
    semantics. Nevertheless, before using this technique you should carefully consider
    whether copying string pointers is the appropriate way to do a string assignment
    in your program.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 因为通过引用复制会使你的程序更难以阅读，并增加可能引入微妙缺陷的风险，你可能会想知道为什么有人会使用引用复制。原因有两个：首先，引用复制非常高效；它只涉及执行两条`mov`指令。其次，一些算法实际上依赖于引用复制的语义。然而，在使用这种技术之前，你应该仔细考虑复制字符串指针是否是你程序中字符串赋值的合适方式。
- en: The second way to assign one string to another is to copy the string data. The
    HLA Standard Library `str.cpy` routine provides this capability. A call to the
    `str.cpy` procedure uses the following call syntax:^([[55](#ftn.CHP-4-FN-9)])
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个字符串赋值给另一个字符串的第二种方式是复制字符串数据。HLA 标准库的 `str.cpy` 例程提供了这个功能。调用 `str.cpy` 过程时使用以下调用语法：^([[55](#ftn.CHP-4-FN-9)])
- en: '[PRE74]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The source and destination strings must be string variables (pointers) or 32-bit
    registers containing the addresses of the string data in memory.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 源字符串和目标字符串必须是字符串变量（指针）或包含字符串数据在内存中地址的 32 位寄存器。
- en: The `str.cpy` routine first checks the maximum length field of the destination
    string to ensure that it is at least as big as the source string's current length.
    If it is not, then `str.cpy` raises the `ex.StringOverflow` exception. If the
    destination string's maximum length is large enough, then `str.cpy` copies the
    string length, the characters, and the zero-terminating byte from the source string
    to the destination string. When this process is complete, the two strings point
    at identical data, but they do not point at the same data in memory.^([[56](#ftn.CHP-4-FN-10)])
    The program in [Example 4-14](ch04s10.html#copying_strings_using_str.cpy "Example 4-14. Copying
    strings using str.cpy") is a rework of the example in [Example 4-13](ch04s10.html#problem_with_string_assignment_by_copyin
    "Example 4-13. Problem with string assignment by copying pointers") using `str.cpy`
    rather than copy by reference.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.cpy` 例程首先检查目标字符串的最大长度字段，确保它至少与源字符串当前的长度一样大。如果不是，`str.cpy` 将引发 `ex.StringOverflow`
    异常。如果目标字符串的最大长度足够大，`str.cpy` 就会将源字符串的字符串长度、字符和零终止字节从源字符串复制到目标字符串。当这个过程完成时，两个字符串指向相同的数据，但它们在内存中并不指向相同的数据^([[56](#ftn.CHP-4-FN-10)])。[示例
    4-14](ch04s10.html#copying_strings_using_str.cpy "示例 4-14. 使用 str.cpy 复制字符串")
    中的程序是使用 `str.cpy` 而不是通过引用复制的方式，对 [示例 4-13](ch04s10.html#problem_with_string_assignment_by_copyin
    "示例 4-13. 通过复制指针字符串赋值的问题") 中示例的重做。'
- en: Example 4-14. Copying strings using `str.cpy`
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-14. 使用 `str.cpy` 复制字符串
- en: '[PRE75]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: There are two important things to note about the program in [Example 4-14](ch04s10.html#copying_strings_using_str.cpy
    "Example 4-14. Copying strings using str.cpy"). First, note that this program
    begins by allocating storage for `string2`. Remember, the `str.cpy` routine does
    not allocate storage for the destination string; it assumes that the destination
    string already has storage allocated. Keep in mind that `str.cpy` does not initialize
    `string2`; it only copies data to the location where `string2` is pointing. It
    is the program's responsibility to initialize the string by allocating sufficient
    memory before calling `str.cpy`. The second thing to notice here is that the program
    calls `str.free` to free up the storage for both `string1` and `string2` before
    the program quits.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 有两件重要的事情需要注意，关于 [示例 4-14](ch04s10.html#copying_strings_using_str.cpy "示例 4-14.
    使用 str.cpy 复制字符串") 中的程序。首先，注意这个程序开始时会为 `string2` 分配存储空间。请记住，`str.cpy` 例程不会为目标字符串分配存储空间；它假定目标字符串已经分配了存储空间。请注意，`str.cpy`
    不会初始化 `string2`；它只会将数据复制到 `string2` 当前指向的位置。程序有责任在调用 `str.cpy` 之前分配足够的内存来初始化该字符串。第二件需要注意的事情是，程序在退出之前调用
    `str.free` 来释放 `string1` 和 `string2` 的存储空间。
- en: 'Allocating storage for a string variable prior to calling `str.cpy` is so common
    that the HLA Standard Library provides a routine that allocates and copies the
    string: `str.a_cpy`. This routine uses the following call syntax:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `str.cpy` 之前为字符串变量分配存储空间是非常常见的，以至于 HLA 标准库提供了一个分配并复制字符串的例程：`str.a_cpy`。这个例程使用以下调用语法：
- en: '[PRE76]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note that there is no destination string. This routine looks at the length of
    the source string, allocates sufficient storage, makes a copy of the string, and
    then returns a pointer to the new string in the EAX register. The program in [Example 4-15](ch04s10.html#copying_strings_using_str.a_underscore_c
    "Example 4-15. Copying strings using str.a_cpy") demonstrates how to do the same
    thing as the program in [Example 4-14](ch04s10.html#copying_strings_using_str.cpy
    "Example 4-14. Copying strings using str.cpy") using the `str.a_cpy` procedure.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`str.cpy` 没有目标字符串。该例程查看源字符串的长度，分配足够的存储空间，复制字符串，然后返回一个指向新字符串的指针，存储在 EAX 寄存器中。[示例
    4-15](ch04s10.html#copying_strings_using_str.a_underscore_c "示例 4-15. 使用 str.a_cpy
    复制字符串") 中的程序演示了如何使用 `str.a_cpy` 过程完成与 [示例 4-14](ch04s10.html#copying_strings_using_str.cpy
    "示例 4-14. 使用 str.cpy 复制字符串") 中相同的操作。
- en: Example 4-15. Copying strings using `str.a_cpy`
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-15. 使用 `str.a_cpy` 复制字符串
- en: '[PRE77]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Warning
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Whenever you use copy by reference or `str.a_cpy` to assign a string, don't
    forget to free the storage associated with the string when you have (completely)
    finished with that string's data. Failure to do so may produce a memory leak if
    you do not have another pointer to the previous string data lying around.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用引用传递或 `str.a_cpy` 来分配字符串时，别忘了在完全处理完字符串数据后释放与该字符串相关的存储。如果你没有其他指向先前字符串数据的指针，未能这样做可能会导致内存泄漏。
- en: 'Obtaining the length of a character string is so common that the HLA Standard
    Library provides a `str.length` routine specifically for this purpose. Of course,
    you can fetch the length by using the `str.strRec` data type to access the length
    field directly, but constant use of this mechanism can be tiring because it involves
    a lot of typing. The `str.length` routine provides a more compact and convenient
    way to fetch the length information. You call `str.length` using one of the following
    two formats:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 获取字符字符串的长度非常常见，以至于 HLA 标准库提供了一个专门用于此目的的 `str.length` 例程。当然，你也可以通过使用 `str.strRec`
    数据类型直接访问长度字段来获取长度，但由于这种机制需要输入大量的代码，频繁使用会比较繁琐。`str.length` 例程提供了一种更紧凑、更方便的方式来获取长度信息。你可以使用以下两种格式之一调用
    `str.length`：
- en: '[PRE78]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This routine returns the current string length in the EAX register.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例程将当前字符串的长度返回在 EAX 寄存器中。
- en: 'Another pair of useful string routines is the `str.cat` and `str.a_cat` procedures.
    They use the following syntax:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的字符串例程对是 `str.cat` 和 `str.a_cat` 过程。它们使用以下语法：
- en: '[PRE79]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: These two routines concatenate two strings (that is, they create a new string
    by joining the two strings together). The `str.cat` procedure concatenates the
    source string to the end of the destination string. Before the concatenation actually
    takes place, `str.cat` checks to make sure that the destination string is large
    enough to hold the concatenated result, and it raises the `ex.StringOverflow`
    exception if the destination string's maximum length is too small.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例程将两个字符串连接在一起（即通过将两个字符串连接创建一个新字符串）。`str.cat` 过程将源字符串连接到目标字符串的末尾。在实际进行连接之前，`str.cat`
    会检查目标字符串是否足够大，能够容纳连接结果，如果目标字符串的最大长度太小，它会抛出 `ex.StringOverflow` 异常。
- en: The `str.a_cat` routine, as its name suggests, allocates storage for the resulting
    string before doing the concatenation. This routine will allocate sufficient storage
    to hold the concatenated result, then it will copy the `srcLStr` to the allocated
    storage, next it will append the string data pointed at by `srcRStr` to the end
    of this new string, and then it will return a pointer to the new string in the
    EAX register.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.a_cat` 例程顾名思义，在进行连接操作之前，会为结果字符串分配存储空间。这个例程将为连接结果分配足够的存储空间，然后将 `srcLStr`
    复制到分配的存储空间中，接着将 `srcRStr` 指向的字符串数据附加到这个新字符串的末尾，最后它会在 EAX 寄存器中返回指向新字符串的指针。'
- en: Warning
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Note a potential source of confusion. The `str.cat` procedure concatenates its
    first operand to the end of the second operand. Therefore, `str.cat` follows the
    standard `(src, dest)` operand format present in many HLA statements. The `str.a_cat`
    routine, on the other hand, has two source operands rather than a source operand
    and a destination operand. The `str.a_cat` routine concatenates its two operands
    in an intuitive left-to-right fashion. This is the opposite of `str.cat`. Keep
    this in mind when using these two routines.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一个潜在的混淆来源。`str.cat` 过程将其第一个操作数连接到第二个操作数的末尾。因此，`str.cat` 遵循许多 HLA 语句中常见的标准
    `(src, dest)` 操作数格式。而 `str.a_cat` 例程则有两个源操作数，而不是一个源操作数和一个目标操作数。`str.a_cat` 例程以直观的从左到右的方式连接这两个操作数，这与
    `str.cat` 正好相反。使用这两个例程时，请记住这一点。
- en: '[Example 4-16](ch04s10.html#demonstration_of_str.cat_and_str.a_under "Example 4-16. Demonstration
    of str.cat and str.a_cat routines") demonstrates the use of the `str.cat` and
    `str.a_cat` routines.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-16](ch04s10.html#demonstration_of_str.cat_and_str.a_under "示例 4-16. 演示
    str.cat 和 str.a_cat 例程") 演示了如何使用 `str.cat` 和 `str.a_cat` 例程。'
- en: Example 4-16. Demonstration of `str.cat` and `str.a_cat` routines
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-16. 演示 `str.cat` 和 `str.a_cat` 例程
- en: '[PRE80]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `str.insert` and `str.a_insert` routines are similar to the string-concatenation
    procedures. However, the `str.insert` and `str.a_insert` routines let you insert
    one string anywhere into another string, not just at the end of the string. The
    calling sequences for these two routines are:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.insert` 和 `str.a_insert` 例程与字符串连接过程类似。然而，`str.insert` 和 `str.a_insert`
    例程允许你将一个字符串插入到另一个字符串的任何位置，而不仅仅是字符串的末尾。这两个例程的调用顺序如下：'
- en: '[PRE81]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: These two routines insert the source string (*`src`*) into the destination string
    (*`dest`*) starting at character position *`index`*. The `str.insert` routine
    inserts the source string directly into the destination string; if the destination
    string is not large enough to hold both strings, `str.insert` raises an `ex.StringOverflow`
    exception. The `str.a_insert` routine first allocates storage for a new string
    on the heap, copies the destination string (*`src`*) to the new string, and then
    inserts the source string (*`dest`*) into this new string at the specified offset;
    `str.a_insert` returns a pointer to the new string in the EAX register.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数将源字符串（*`src`*）插入到目标字符串（*`dest`*）的指定字符位置*`index`*处。`str.insert`函数将源字符串直接插入目标字符串；如果目标字符串的长度不足以容纳两个字符串，`str.insert`会引发`ex.StringOverflow`异常。`str.a_insert`函数首先为新字符串分配内存，将目标字符串（*`src`*）复制到新字符串中，然后在指定的偏移位置插入源字符串（*`dest`*）；`str.a_insert`返回新字符串的指针，并存储在EAX寄存器中。
- en: Indexes into a string are zero based. This means that if you supply the value
    0 as the index in `str.insert` or `str.a_insert`, then these routines will insert
    the source string before the first character of the destination string. Likewise,
    if the *`index`* is equal to the length of the string, then these routines will
    simply concatenate the source string to the end of the destination string.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的索引是从零开始的。这意味着，如果你在`str.insert`或`str.a_insert`中提供值0作为索引，那么这些函数会在目标字符串的第一个字符之前插入源字符串。同样地，如果*`index`*等于字符串的长度，那么这些函数会直接将源字符串连接到目标字符串的末尾。
- en: Warning
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: If the `index` is greater than the length of the string, the `str.insert` and
    `str.a_insert` procedures will not raise an exception; instead, they will simply
    append the source string to the end of the destination string.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`index`大于字符串的长度，`str.insert`和`str.a_insert`过程不会引发异常；相反，它们会简单地将源字符串附加到目标字符串的末尾。
- en: 'The `str.delete` and `str.a_delete` routines let you remove characters from
    a string. They use the following calling sequence:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.delete`和`str.a_delete`函数允许你从字符串中删除字符。它们使用以下调用方式：'
- en: '[PRE82]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Both routines delete *`Length`* characters starting at character position *`StartIndex`*
    in string *`strng`*. The difference between the two is that `str.delete` deletes
    the characters directly from *`strng`*, whereas `str.a_delete` first allocates
    storage and copies *`strng`* and then deletes the characters from the new string
    (leaving *`strng`* untouched). The `str.a_delete` routine returns a pointer to
    the new string in the EAX register.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 两个函数都会从字符串*`strng`*的字符位置*`StartIndex`*开始删除*`Length`*个字符。两者的区别在于，`str.delete`直接从*`strng`*中删除字符，而`str.a_delete`首先分配内存并复制*`strng`*，然后从新字符串中删除字符（不改变*`strng`*）。`str.a_delete`函数会将新字符串的指针返回在EAX寄存器中。
- en: The `str.delete` and `str.a_delete` routines are very forgiving with respect
    to the values you pass in *`StartIndex`* and *`Length`*. If *`StartIndex`* is
    greater than the current length of the string, these routines do not delete any
    characters from the string. If *`StartIndex`* is less than the current length
    of the string, but *`StartIndex`*+*`Length`* is greater than the length of the
    string, then these routines will delete all characters from *`StartIndex`* to
    the end of the string.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.delete`和`str.a_delete`函数对你传入的*`StartIndex`*和*`Length`*的值非常宽容。如果*`StartIndex`*大于字符串的当前长度，这两个函数不会从字符串中删除任何字符。如果*`StartIndex`*小于字符串的当前长度，但*`StartIndex`*+*`Length`*大于字符串的长度，那么这两个函数会删除从*`StartIndex`*到字符串末尾的所有字符。'
- en: 'Another very common string operation is the need to copy a portion of a string
    to another string without otherwise affecting the source string. The `str.substr`
    and `str.a_substr` routines provide this capability. These routines use the following
    syntax:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常常见的字符串操作是需要将字符串的一部分复制到另一个字符串，而不影响源字符串。`str.substr`和`str.a_substr`函数提供了这个功能。这些函数使用以下语法：
- en: '[PRE83]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `str.substr` routine copies *`Length`* characters, starting at position
    *`StartIndex`*, from the *`src`* string to the *`dest`* string. The dest string
    must have sufficient storage to hold the new string or `str.substr` will raise
    an `ex.StringOverflow` exception. If the *`StartIndex`* value is greater than
    the length of the string, then `str.substr` will raise an `ex.StringIndexError`
    exception. If *`StartIndex`*+*`Length`* is greater than the length of the source
    string, but *`StartIndex`* is less than the length of the string, then `str.substr`
    will extract only those characters from *`StartIndex`* to the end of the string.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.substr`例程将从*`src`*字符串的*`StartIndex`*位置开始，复制*`Length`*个字符到*`dest`*字符串中。目标字符串必须有足够的存储空间来容纳新字符串，否则`str.substr`将抛出`ex.StringOverflow`异常。如果*`StartIndex`*的值大于字符串的长度，则`str.substr`将抛出`ex.StringIndexError`异常。如果*`StartIndex`*+*`Length`*大于源字符串的长度，但*`StartIndex`*小于字符串的长度，那么`str.substr`将仅提取从*`StartIndex`*到字符串末尾的字符。'
- en: The `str.a_substr` procedure behaves in a fashion nearly identical to `str.substr`,
    except it allocates storage on the heap for the destination string. `str.a_substr`
    handles exceptions identically to `str.substr`, except it never raises a string
    overflow exception because this will never occur.^([[57](#ftn.CHP-4-FN-11)]) As
    you can probably guess by now, `str.a_substr` returns a pointer to the newly allocated
    string in the EAX register.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.a_substr`过程的行为几乎与`str.substr`完全相同，唯一不同的是它会在堆上分配存储空间用于目标字符串。`str.a_substr`处理异常的方式与`str.substr`相同，唯一不同的是它永远不会抛出字符串溢出异常，因为这种情况永远不会发生。^([[57](#ftn.CHP-4-FN-11)])
    你现在可能已经猜到了，`str.a_substr`会返回一个指向新分配字符串的指针，该指针存储在EAX寄存器中。'
- en: 'After you have been working with string data for a little while, the need will
    invariably arise to compare two strings. A first attempt at string comparison,
    using the standard HLA relational operators, will compile but not necessarily
    produce the desired result:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始处理字符串数据一段时间后，比较两个字符串的需求通常会不可避免地出现。第一次尝试使用标准HLA关系运算符进行字符串比较时，虽然会编译通过，但不一定会产生预期的结果：
- en: '[PRE84]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Remember, *strings are pointers*. This code compares the two pointers to see
    if they are equal. If they are equal, clearly the two strings are equal (because
    both `s1` and `s2` point at the exact same string data). However, the fact that
    the two pointers are different doesn''t necessarily mean that the strings are
    not equivalent. Both `s1` and `s2` could contain different values (that is, they
    point at different addresses in memory), yet the string data at those two addresses
    could be identical. Most programmers expect a string comparison for equality to
    be true if the data for the two strings is the same. Clearly a pointer comparison
    does not provide this type of comparison. To overcome this problem, the HLA Standard
    Library provides a set of string-comparison routines that will compare the string
    data, not just their pointers. These routines use the following calling sequences:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，*字符串是指针*。这段代码比较两个指针，看看它们是否相等。如果它们相等，显然这两个字符串是相等的（因为`s1`和`s2`指向的是完全相同的字符串数据）。然而，两个指针不同并不一定意味着这两个字符串不相等。`s1`和`s2`可能包含不同的值（即它们指向内存中的不同地址），但这两个地址上的字符串数据可能是相同的。大多数程序员期望当两个字符串的数据相同时，字符串比较为true。显然，指针比较并不能提供这种类型的比较。为了解决这个问题，HLA标准库提供了一组字符串比较例程，这些例程会比较字符串数据，而不仅仅是它们的指针。使用这些例程时，调用方式如下：
- en: '[PRE85]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Each of these routines compares the *`src1`* string to the *`src2`* string
    and returns true (1) or false (0) in the EAX register depending on the comparison.
    For example, `str.eq( s1, s2);` returns true in EAX if `s1` is equal to `s2`.
    HLA provides a small extension that allows you to use the string-comparison routines
    within an `if` statement.^([[58](#ftn.CHP-4-FN-12)]) The following code demonstrates
    the use of some of these comparison routines within an `if` statement:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例程将*`src1`*字符串与*`src2`*字符串进行比较，并根据比较结果在EAX寄存器中返回true（1）或false（0）。例如，`str.eq(
    s1, s2);` 如果`s1`等于`s2`，则会在EAX中返回true。HLA提供了一个小扩展，允许你在`if`语句中使用字符串比较例程。^([[58](#ftn.CHP-4-FN-12)])
    以下代码演示了如何在`if`语句中使用一些比较例程：
- en: '[PRE86]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Note that the string the user enters in this example must exactly match `Hello`,
    including the use of an uppercase *H* at the beginning of the string. When processing
    user input, it is best to ignore alphabetic case in string comparisons because
    different users have different ideas about when they should be pressing the SHIFT
    key on the keyboard. An easy solution is to use the HLA case-insensitive string-comparison
    functions. These routines compare two strings, ignoring any differences in alphabetic
    case. These routines use the following calling sequences:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，用户在此示例中输入的字符串必须完全匹配 `Hello`，包括字符串开头的大写字母 *H*。在处理用户输入时，最好在字符串比较时忽略字母的大小写，因为不同的用户对于何时按下键盘上的
    SHIFT 键有不同的理解。一种简单的解决方案是使用 HLA 的不区分大小写的字符串比较函数。这些例程比较两个字符串，忽略字母的大小写差异。这些例程使用以下调用顺序：
- en: '[PRE87]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Other than they treat uppercase characters the same as their lowercase equivalents,
    these routines behave exactly like the former routines, returning true or false
    in EAX depending on the result of the comparison.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将大写字符与其小写等效字符视为相同外，这些例程的行为与前述例程完全相同，根据比较结果在 EAX 中返回 true 或 false。
- en: Like most high-level languages, HLA compares strings using *lexicographical
    ordering*. This means that two strings are equal if and only if their lengths
    are the same and the corresponding characters in the two strings are exactly the
    same. For less-than or greater-than comparisons, lexicographical ordering corresponds
    to the way words appear in a dictionary. That is, `a` is less than `b` is less
    than `c`, and so on. Actually, HLA compares the strings using the ASCII numeric
    codes for the characters, so if you are unsure whether `a` is less than a period,
    simply consult the ASCII character chart (incidentally, `a` is greater than a
    period in the ASCII character set, just in case you were wondering).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数高级语言一样，HLA 使用*字典顺序*来比较字符串。这意味着两个字符串只有在它们的长度相同且两个字符串中对应的字符完全相同的情况下才相等。在小于或大于的比较中，字典顺序对应于单词在字典中的排列方式。也就是说，`a`
    小于 `b` 小于 `c`，以此类推。实际上，HLA 使用字符的 ASCII 数字代码来比较字符串，因此如果你不确定 `a` 是否小于句点，可以查阅 ASCII
    字符表（顺便提一下，在 ASCII 字符集里，`a` 大于句点，以防你有这个疑问）。
- en: If two strings have different lengths, lexicographical ordering worries about
    the length only if the two strings exactly match through the length of the shorter
    string. If this is the case, then the longer string is greater than the shorter
    string (and, conversely, the shorter string is less than the longer string). Note,
    however, that if the characters in the two strings do not match at all, then HLA's
    string-comparison routines ignore the length of the string; for example, `z` is
    always greater than `aaaaa`, even though it is shorter.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个字符串长度不同，字典顺序只有在两个字符串完全匹配到较短字符串的长度时才考虑长度。如果是这种情况，那么较长的字符串大于较短的字符串（反之亦然，较短的字符串小于较长的字符串）。然而，请注意，如果两个字符串中的字符完全不匹配，那么
    HLA 的字符串比较例程会忽略字符串的长度；例如，`z` 总是大于 `aaaaa`，即使它较短。
- en: 'The `str.eq` routine checks to see if two strings are equal. Sometimes, however,
    you might want to know whether one string *contains* another string. For example,
    you may want to know if some string contains the substring `north` or `south`
    to determine some action to take in a game. The HLA `str.index` routine lets you
    check to see if one string is contained as a substring of another. The `str.index`
    routine uses the following calling sequence:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.eq` 例程检查两个字符串是否相等。然而，有时你可能想知道一个字符串是否*包含*另一个字符串。例如，你可能想知道某个字符串是否包含子字符串
    `north` 或 `south`，以决定在游戏中采取某个行动。HLA 的 `str.index` 例程允许你检查一个字符串是否作为子字符串包含在另一个字符串中。`str.index`
    例程使用以下调用顺序：'
- en: '[PRE88]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This function returns, in EAX, the offset into *`StrToSearch`* where *`SubstrToSearchFor`*
    appears. This routine returns −1 in EAX if *`SubstrToSearchFor`* is not present
    in *`StrToSearch`*. Note that `str.index` will do a case-sensitive search. Therefore,
    the strings must exactly match. There is no case-insensitive variant of `str.index`
    you can use.^([[59](#ftn.CHP-4-FN-13)])
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数在 EAX 中返回 *`StrToSearch`* 中 *`SubstrToSearchFor`* 出现的位置偏移量。如果 *`SubstrToSearchFor`*
    不存在于 *`StrToSearch`* 中，则该例程在 EAX 中返回 −1。请注意，`str.index` 会进行区分大小写的搜索。因此，字符串必须完全匹配。没有可以使用的不区分大小写的
    `str.index` 变体。^([[59](#ftn.CHP-4-FN-13)])
- en: The HLA `strings` module contains hundreds of routines besides those appearing
    in this section. Space limitations and prerequisite knowledge prevent the presentation
    of all those functions here; however, this does not mean that the remaining string
    functions are unimportant. You should definitely take a look at the HLA Standard
    Library documentation to learn everything you can about the powerful HLA string
    library routines.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: HLA `strings` 模块除了本节中列出的那些例程外，还包含数百个例程。由于空间限制和前提知识的要求，这里无法展示所有这些函数；然而，这并不意味着剩余的字符串函数不重要。你应该一定要查看
    HLA 标准库文档，了解更多关于强大的 HLA 字符串库例程的知识。
- en: '* * *'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[55](#CHP-4-FN-9)]) Warning to C/C++ users: note that the order of the operands
    is opposite that of the C Standard Library `strcpy` function.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[55](#CHP-4-FN-9)]) 警告 C/C++ 用户：请注意，操作数的顺序与 C 标准库的 `strcpy` 函数相反。
- en: ^([[56](#CHP-4-FN-10)]) Unless, of course, both string pointers contained the
    same address to begin with, in which case `str.cpy` copies the string data over
    itself.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[56](#CHP-4-FN-10)]) 当然，除非两个字符串指针最初包含相同的地址，在这种情况下 `str.cpy` 会将字符串数据复制到自身。
- en: ^([[57](#CHP-4-FN-11)]) Technically, `str.a_substr`, like all routines that
    call `mem.alloc` to allocate storage, can raise an `ex.MemoryAllocationFailure`
    exception, but this is very unlikely to occur.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[57](#CHP-4-FN-11)]) 从技术上讲，`str.a_substr` 就像所有调用 `mem.alloc` 来分配存储空间的例程一样，可能会抛出
    `ex.MemoryAllocationFailure` 异常，但这种情况发生的可能性非常小。
- en: ^([[58](#CHP-4-FN-12)]) This extension is actually a little more general than
    this section describes. [Chapter 7](ch07.html "Chapter 7. LOW-LEVEL CONTROL STRUCTURES")
    explains it fully.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[58](#CHP-4-FN-12)]) 这个扩展实际上比本节描述的要更通用。[第7章](ch07.html "第7章。低级控制结构") 完整地解释了它。
- en: ^([[59](#CHP-4-FN-13)]) However, HLA does provide routines that will convert
    all the characters in a string to one case or another. So you can make copies
    of the strings, convert all the characters in both copies to lowercase, and then
    search using these converted strings. This will achieve the same result.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[59](#CHP-4-FN-13)]) 然而，HLA确实提供了一些例程，可以将字符串中的所有字符转换为某种大小写。因此，你可以复制字符串，将两个副本中的所有字符都转换为小写，然后使用这些转换后的字符串进行搜索。这将达到相同的效果。
- en: 4.11 In-Memory Conversions
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.11 内存中的转换
- en: 'The HLA Standard Library''s `string` module contains dozens of routines for
    converting between strings and other data formats. Although it''s a little premature
    in this text to present a complete description of those functions, it would be
    rather criminal not to discuss at least one of the available functions: the `str.put`
    routine. This routine encapsulates the capabilities of many of the other string-conversion
    functions, so if you learn how to use this one, you''ll have most of the capabilities
    of those other routines at your disposal.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: HLA标准库的 `string` 模块包含数十个用于在字符串和其他数据格式之间转换的例程。尽管在本节中介绍这些函数还为时过早，但如果不至少讨论其中一个可用的函数——`str.put`
    例程，那将有些不妥。这个例程封装了许多其他字符串转换函数的功能，因此如果你学会了如何使用这个，你将能够使用大部分其他例程的功能。
- en: 'You use the `str.put` routine in a manner very similar to the `stdout.put`
    routine. The only difference is that the `str.put` routine "writes" its data to
    a string instead of the standard output device. A call to `str.put` has the following
    syntax:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 你以类似于 `stdout.put` 例程的方式使用 `str.put`。唯一的区别是，`str.put` 例程将数据“写入”一个字符串，而不是标准输出设备。调用
    `str.put` 的语法如下：
- en: '[PRE89]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Here''s an example of a call to `str.put`:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这是调用 `str.put` 的一个示例：
- en: '[PRE90]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Warning
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Generally, you would not put a newline character sequence at the end of the
    string as you would if you were printing the string to the standard output device.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不会像打印字符串到标准输出设备时那样在字符串末尾加上换行符序列。
- en: The *`destString`* parameter at the beginning of the `str.put` parameter list
    must be a string variable, and it must already have storage associated with it.
    If `str.put` attempts to store more characters than allowed into the *`destString`*
    parameter, then this function raises the `ex.StringOverflow` exception.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '*`destString`* 参数在 `str.put` 参数列表的开头必须是一个字符串变量，并且它必须已经分配了存储空间。如果 `str.put`
    尝试将超过允许字符数的内容存储到 *`destString`* 参数中，那么此函数将抛出 `ex.StringOverflow` 异常。'
- en: Most of the time you won't know the length of the string that `str.put` will
    produce. In those instances, you should allocate storage for a very large string,
    one that is much larger than you expect, and use this string object as the first
    parameter of the `str.put` call. This will prevent an exception from crashing
    your program. Generally, if you expect to produce about one screen line of text,
    then you should probably allocate at least 256 characters for the destination
    string. If you're creating longer strings, you should probably use a default of
    1,024 characters (or more, if you're going to produce *really* large strings).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你不知道 `str.put` 会生成的字符串长度。在这种情况下，你应该为一个非常大的字符串分配存储空间，远大于你预期的大小，并将这个字符串对象作为
    `str.put` 调用的第一个参数。这将防止异常导致程序崩溃。通常，如果你预期生成大约一行屏幕文字，那么应该为目标字符串分配至少 256 个字符。如果你要生成更长的字符串，应该为字符串分配至少
    1,024 个字符（如果你要生成*非常*大的字符串，可以分配更多）。
- en: 'Here''s an example:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE91]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: You can use the `str.put` routine to convert any data to a string that you can
    print using `stdout.put`. You will probably find this routine invaluable for common
    value-to-string conversions.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `str.put` 例程将任何数据转换为字符串，然后使用 `stdout.put` 打印出来。你会发现这个例程对于常见的值到字符串的转换非常有用。
- en: 4.12 Character Sets
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.12 字符集
- en: Character sets are another composite data type, like strings, built upon the
    character data type. A character set is a mathematical set of characters with
    the most important attribute being membership. That is, a character is either
    a member of a set or it is not a member of a set. The concept of sequence (for
    example, whether one character comes before another, as in a string) doesn't apply
    to character sets. Also, membership is a binary relation; a character is either
    in the set or it is not in the set; you cannot have multiple copies of the same
    character in a character set. Various operations are possible on character sets,
    including the mathematical set operations of union, intersection, difference,
    and membership test.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 字符集是另一种复合数据类型，类似于字符串，是基于字符数据类型构建的。字符集是一个数学集合，最重要的属性是成员资格。也就是说，字符要么是集合的成员，要么不是集合的成员。序列的概念（例如，字符是否排在另一个字符之前，如同在字符串中）不适用于字符集。此外，成员资格是一种二元关系；字符要么在集合中，要么不在集合中；你不能在字符集中有多个相同字符。对字符集可以进行各种操作，包括数学集合运算，如并集、交集、差集和成员测试。
- en: HLA implements a restricted form of character sets that allows set members to
    be any of the 128 standard ASCII characters (that is, HLA's character set facilities
    do not support extended character codes in the range 128..255). Despite this restriction,
    HLA's character set facilities are very powerful and are handy when writing programs
    that work with string data. The following sections describe the implementation
    and use of HLA's character set facilities so you may take advantage of character
    sets in your own programs.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 实现了一种受限形式的字符集，允许字符集成员是任何 128 个标准 ASCII 字符（即 HLA 的字符集功能不支持扩展字符编码范围 128..255）。尽管有此限制，HLA
    的字符集功能仍然非常强大，并且在编写处理字符串数据的程序时非常方便。以下部分将描述 HLA 字符集功能的实现和使用，以便你可以在自己的程序中利用字符集。
- en: 4.13 Character Set Implementation in HLA
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.13 HLA 中的字符集实现
- en: There are many different ways to represent character sets in an assembly language
    program. HLA implements character sets using an array of 128 boolean values. Each
    boolean value determines whether the corresponding character is a member of the
    character set; that is, a true boolean value indicates that the corresponding
    character is a member of the set, whereas a false value indicates that the character
    is not a member of the set. To conserve memory, HLA allocates only a single bit
    for each character in the set; therefore, HLA character sets consume 16 bytes
    of memory because there are 128 bits in 16 bytes. This array of 128 bits is organized
    in memory as shown in [Figure 4-3](ch04s13.html#bit_layout_of_a_character_set_object
    "Figure 4-3. Bit layout of a character set object").
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言程序中表示字符集有多种方式。HLA 使用一个包含 128 个布尔值的数组来实现字符集。每个布尔值决定相应字符是否是字符集的成员；也就是说，布尔值为真表示相应字符是字符集的成员，而布尔值为假表示该字符不是字符集的成员。为了节省内存，HLA
    为字符集中的每个字符分配一个位，因此 HLA 字符集只消耗 16 字节的内存，因为 16 字节包含 128 位。这个包含 128 位的数组在内存中的组织方式如
    [图 4-3](ch04s13.html#bit_layout_of_a_character_set_object "图 4-3. 字符集对象的位布局")
    所示。
- en: '![Bit layout of a character set object](tagoreillycom20100401nostarchimages577983.png.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![字符集对象的位布局](tagoreillycom20100401nostarchimages577983.png.jpg)'
- en: Figure 4-3. Bit layout of a character set object
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-3. 字符集对象的位布局
- en: Bit 0 of byte 0 corresponds to ASCII code 0 (the NUL character). If this bit
    is 1, then the character set contains the NUL character; if this bit contains
    false, then the character set does not contain the NUL character. Likewise, bit
    0 of byte 1 (the ninth bit in the 128-bit array) corresponds to the backspace
    character (ASCII code is 8). Bit 1 of byte 8 corresponds to ASCII code 65, an
    uppercase `A`. Bit 65 will contain a 1 if `A` is a current member of the character
    set; it will contain 0 if `A` is not a member of the set.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 字节 0 的位 0 对应于 ASCII 代码 0（NUL 字符）。如果该位为 1，则字符集包含 NUL 字符；如果该位为假，则字符集不包含 NUL 字符。同样，字节
    1 的位 0（128 位数组中的第九位）对应退格字符（ASCII 代码为 8）。字节 8 的位 1 对应 ASCII 代码 65，大写字母 `A`。如果 `A`
    是字符集的当前成员，则位 65 将为 1；如果 `A` 不是字符集的成员，则该位为 0。
- en: While there are other possible ways to implement character sets, with this bit-vector
    implementation it is very easy to implement set operations such as union, intersection,
    difference comparison, and membership tests.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在其他实现字符集的方法，但使用这种位向量实现可以非常容易地实现集合操作，如并集、交集、差集比较和成员测试。
- en: 'HLA supports character set variables using the `cset` data type. To declare
    a character set variable, you would use a declaration like the following:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 支持使用 `cset` 数据类型的字符集变量。要声明一个字符集变量，可以使用如下声明：
- en: '[PRE92]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This declaration will reserve 16 bytes of storage to hold the 128 bits needed
    to represent a set of ASCII characters.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 该声明将预留 16 字节的存储空间，用于保存表示 ASCII 字符集的 128 位。
- en: Although it is possible to manipulate the bits in a character set using instructions
    like `and`, `or`, `xor`, and so on, the 80x86 instruction set includes several
    bit test, set, reset, and complement instructions that are nearly perfect for
    manipulating character sets. The `bt` (bit test) instruction, for example, will
    copy a single bit in memory to the carry flag. The `bt` instruction allows the
    following syntactical forms.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用如 `and`、`or`、`xor` 等指令操作字符集中的位，80x86 指令集包括几条用于测试、设置、重置和补码的指令，非常适合操作字符集。例如，`bt`（位测试）指令会将内存中的一个位复制到进位标志中。`bt`
    指令支持以下语法形式。
- en: '[PRE93]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The first operand holds a bit number, and the second operand specifies a register
    or memory location whose bit should be copied into the carry flag. If the second
    operand is a register, the first operand must contain a value in the range 0..*n*−1,
    where *n* is the number of bits in the second operand. If the first operand is
    a constant and the second operand is a memory location, the constant must be in
    the range 0..255\. Here are some examples of these instructions:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个操作数包含一个位数，第二个操作数指定一个寄存器或内存位置，其位应该复制到进位标志中。如果第二个操作数是一个寄存器，则第一个操作数必须包含一个在 0..*n*−1
    范围内的值，其中 *n* 是第二个操作数的位数。如果第一个操作数是常量且第二个操作数是内存位置，则常量必须在 0..255 范围内。以下是这些指令的一些示例：
- en: '[PRE94]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `bt` instruction turns out to be quite useful for testing set membership.
    For example, to see if the character `A` is a member of a character set, you could
    use a code sequence like the following:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`bt` 指令对于测试集合成员资格非常有用。例如，要检查字符 `A` 是否是字符集的成员，可以使用如下代码序列：'
- en: '[PRE95]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The `bts` (bit test and set), `btr` (bit test and reset), and `btc` (bit test
    and complement) instructions are also useful for manipulating character set variables.
    Like the `bt` instruction, these instructions copy the specified bit into the
    carry flag; after copying the specified bit, these instructions will set (`bts`),
    reset/clear (`btr`), or complement/invert (`btc`) the specified bit. Therefore,
    you can use the `bts` instruction to add a character to a character set via set
    union (that is, it adds a character to the set if the character was not already
    a member of the set; otherwise the set is unaffected). You can use the `btr` instruction
    to remove a character from a character set via set intersection (that is, it removes
    a character from the set if and only if it was previously in the set; otherwise
    it has no effect on the set). The `btc` instruction lets you add a character to
    the set if it wasn't previously in the set; it removes the character from the
    set if it was previously a member (that is, it toggles the membership of that
    character in the set).
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`bts`（位测试并设置）、`btr`（位测试并重置）和`btc`（位测试并取反）指令在操作字符集变量时也非常有用。像`bt`指令一样，这些指令将指定的位复制到进位标志中；在复制指定的位后，这些指令将设置（`bts`）、重置/清除（`btr`）或取反/翻转（`btc`）该位。因此，你可以使用`bts`指令通过集合并集将字符添加到字符集中（也就是说，如果字符不在集合中，它将被添加到集合中；否则集合不受影响）。你可以使用`btr`指令通过集合交集将字符从字符集中移除（也就是说，它只有在字符原本在集合中时才会移除字符；否则对集合没有影响）。`btc`指令让你可以将字符添加到集合中，如果字符原本不在集合中；如果字符已经在集合中，它将从集合中移除（也就是说，它会切换字符在集合中的成员身份）。'
- en: 4.14 HLA Character Set Constants and Character Set Expressions
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.14 HLA字符集常量与字符集表达式
- en: 'HLA supports literal character set constants. These `cset` constants make it
    easy to initialize `cset` variables at compile time and allow you to easily pass
    character set constants as procedure parameters. An HLA character set constant
    takes the following form:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: HLA支持字面字符集常量。这些`cset`常量使得在编译时初始化`cset`变量变得更加容易，并且允许你将字符集常量轻松地作为过程参数传递。HLA字符集常量的形式如下：
- en: '[PRE96]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The following is an example of a simple character set holding the numeric digit
    characters:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的字符集示例，包含所有数字字符：
- en: '[PRE97]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'When specifying a character set literal that has several contiguous values,
    HLA lets you concisely specify the values using only the starting and ending values
    of the range thusly:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定具有多个连续值的字符集字面量时，HLA允许你简洁地仅使用范围的起始值和结束值来指定这些值，如下所示：
- en: '[PRE98]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'You may combine characters and various ranges within the same character set
    constant. For example, the following character set constant is all the alphanumeric
    characters:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在同一字符集常量中结合字符和各种范围。例如，以下字符集常量包含所有的字母数字字符：
- en: '[PRE99]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'You can use these `cset` literal constants as initializers in the `const` and
    `val` sections. The following example demonstrates how to create the symbolic
    constant `AlphaNumeric` using the character set above:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`const`和`val`部分使用这些`cset`字面常量作为初始化器。以下示例演示了如何使用上面的字符集创建符号常量`AlphaNumeric`：
- en: '[PRE100]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: After the above declaration, you can use the identifier `AlphaNumeric` anywhere
    the character set literal is legal.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述声明之后，你可以在任何合法的字符集字面量使用的地方使用标识符`AlphaNumeric`。
- en: 'You can also use character set literals (and, of course, character set symbolic
    constants) as the initializer field for a `static` or `readonly` variable. The
    following code fragment demonstrates this:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将字符集字面量（当然也包括字符集符号常量）用作`static`或`readonly`变量的初始化字段。以下代码片段演示了这一点：
- en: '[PRE101]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Anywhere you can use a character set literal constant, a character set constant
    expression is also legal. [Table 4-2](ch04s14.html#hla_character_set_operators
    "Table 4-2. HLA Character Set Operators") shows the operators that HLA supports
    in character set constant expressions.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可以使用字符集字面常量的地方，也可以使用字符集常量表达式。[表4-2](ch04s14.html#hla_character_set_operators
    "表4-2. HLA字符集操作符")展示了HLA在字符集常量表达式中支持的操作符。
- en: Table 4-2. HLA Character Set Operators
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-2. HLA字符集操作符
- en: '| Operator | Description |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CSetConst1 + CSetConst2` | Computes the union of the two sets. The set union
    is the set of all characters that are in either set. |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| `CSetConst1 + CSetConst2` | 计算两个集合的并集。集合并集是包含任一集合中所有字符的集合。 |'
- en: '| `CSetConst1 * CSetConst2` | Computes the intersection of the two sets. The
    set intersection is the set of all characters that appear in both operand sets.
    |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| `CSetConst1 * CSetConst2` | 计算两个集合的交集。交集是出现在两个操作数集合中的所有字符的集合。 |'
- en: '| `CSetConst1 - CSetConst2` | Computes the set difference of the two sets.
    The set difference is the set of characters that appear in the first set but do
    not appear in the second set. |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| `CSetConst1 - CSetConst2` | 计算两个集合的差集。差集是出现在第一个集合中但不出现在第二个集合中的字符集合。 |'
- en: '| `-CSetConst` | Computes the set complement. The set complement is the set
    of all characters not in the set. |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| `-CSetConst` | 计算集合的补集。补集是所有不在该集合中的字符的集合。 |'
- en: Note that these operators produce only compile-time results. That is, the expressions
    above are computed by the compiler during compilation; they do not emit any machine
    code. If you want to perform these operations on two different sets while your
    program is running, the HLA Standard Library provides routines you can call to
    achieve the results you desire. HLA also provides other compile-time character
    set operators.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些运算符仅生成编译时结果。也就是说，上面的表达式是由编译器在编译期间计算的；它们不会生成任何机器代码。如果你想在程序运行时对两个不同的字符集执行这些操作，HLA标准库提供了可以调用的例程来实现你想要的结果。HLA还提供了其他编译时字符集运算符。
- en: 4.15 Character Set Support in the HLA Standard Library
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.15 HLA标准库中的字符集支持
- en: 'The HLA Standard Library provides several character set routines you may find
    useful. The character set support routines fall into four categories: standard
    character set functions, character set tests, character set conversions, and character
    set I/O. This section describes these routines in the HLA Standard Library.'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: HLA标准库提供了几个你可能会觉得有用的字符集例程。字符集支持例程分为四类：标准字符集函数、字符集测试、字符集转换和字符集输入/输出。本节描述了这些HLA标准库中的例程。
- en: To begin with, let's consider the Standard Library routines that help you construct
    character sets. These routines include `cs.empty`, `cs.cpy`, `cs.charToCset`,
    `cs.unionChar`, `cs.removeChar`, `cs.rangeChar`, `cs.strToCset`, and `cs.unionStr`.
    These procedures let you build up character sets at runtime using character and
    string objects.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑一下帮助你构建字符集的标准库例程。这些例程包括`cs.empty`、`cs.cpy`、`cs.charToCset`、`cs.unionChar`、`cs.removeChar`、`cs.rangeChar`、`cs.strToCset`和`cs.unionStr`。这些过程允许你在运行时使用字符和字符串对象构建字符集。
- en: 'The `cs.empty` procedure initializes a character set variable with the empty
    set by setting all the bits in the character set to 0\. This procedure call uses
    the following syntax (*`CSvar`* is a character set variable):'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`cs.empty`过程通过将字符集中的所有位设置为0来初始化一个字符集变量为空集。该过程调用使用以下语法（*`CSvar`*是一个字符集变量）：'
- en: '[PRE102]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The `cs.cpy` procedure copies one character set to another, replacing any data
    previously held by the destination character set. The syntax for `cs.cpy` is:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '`cs.cpy`过程将一个字符集复制到另一个字符集，替换目标字符集之前的任何数据。`cs.cpy`的语法如下：'
- en: '[PRE103]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The `cs.cpy` source character set can be either a character set constant or
    a character set variable. The destination character set must be a character set
    variable.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`cs.cpy`源字符集可以是一个字符集常量或一个字符集变量。目标字符集必须是一个字符集变量。'
- en: 'The `cs.unionChar` procedure adds a character to a character set. It uses the
    following calling sequence:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`cs.unionChar`过程将一个字符添加到字符集中。它使用以下调用格式：'
- en: '[PRE104]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This call will add the first parameter, a character, to the set via set union.
    Note that you could use the `bts` instruction to achieve this same result; however,
    the `cs.unionChar` call is often more convenient. The character value must be
    in the range #0..#127.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用将第一个参数，一个字符，通过集合并运算添加到集合中。请注意，你可以使用`bts`指令来实现相同的结果；然而，`cs.unionChar`调用通常更方便。字符值必须在#0..#127的范围内。
- en: 'The `cs.charToCset` function creates a singleton set (a set containing a single
    character). The calling format for this function is:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '`cs.charToCset`函数创建一个单例集合（包含一个字符的集合）。该函数的调用格式为：'
- en: '[PRE105]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The first operand, the character value *`CharValue`*, can be an 8-bit register,
    a constant, or a character variable that holds a value in the range #0..#127\.
    The second operand (*`CSvar`*) must be a character set variable. This function
    clears the destination character set to all zeros and then unions the specified
    character into the character set.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个操作数，即字符值*`CharValue`*，可以是一个8位寄存器、一个常量，或一个存储在#0..#127范围内的字符变量。第二个操作数（*`CSvar`*）必须是一个字符集变量。该函数将目标字符集清零，然后将指定的字符并入字符集中。
- en: 'The `cs.removeChar` procedure lets you remove a single character from a character
    set without affecting the other characters in the set. This function uses the
    same syntax as `cs.charToCset`, and the parameters have the same attributes. The
    calling sequence is:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`cs.removeChar` 过程允许你从字符集中移除一个字符，而不影响集合中的其他字符。此函数的语法与 `cs.charToCset` 相同，参数也具有相同的属性。调用顺序如下：'
- en: '[PRE106]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Note that if the character was not in the *`CSVar`* set to begin with, `cs.removeChar`
    will not affect the set. This function roughly corresponds to the `btr` instruction.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果字符本来不在 *`CSVar`* 集合中，`cs.removeChar` 将不会影响集合。此函数大致对应 `btr` 指令。
- en: 'The `cs.rangeChar` constructs a character set containing all the characters
    between two characters you pass as parameters. This function sets all bits outside
    the range of these two characters to 0\. The calling sequence is:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '`cs.rangeChar` 构造一个字符集，包含你传递的两个字符之间的所有字符。此函数将这些两个字符范围之外的所有位设置为 0。调用顺序如下：'
- en: '[PRE107]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The *`LowerBoundChar`* and *`UpperBoundChar`* parameters can be constants,
    registers, or character variables. The values held in *`LowerBoundChar`* and *`UpperBoundChar`*
    must be in the range #0..#127\. `CSVar`, the destination character set, must be
    a `cset` variable.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '*`LowerBoundChar`* 和 *`UpperBoundChar`* 参数可以是常量、寄存器或字符变量。*`LowerBoundChar`*
    和 *`UpperBoundChar`* 中的值必须在 #0..#127 范围内。`CSVar`，目标字符集，必须是一个 `cset` 变量。'
- en: 'The `cs.strToCset` procedure creates a new character set containing the union
    of all the characters in a character string. This procedure begins by setting
    the destination character set to the empty set, and then it unions in the characters
    in the string one by one until it exhausts all characters in the string. The calling
    sequence is:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`cs.strToCset` 过程创建一个新的字符集，其中包含字符串中所有字符的并集。该过程首先将目标字符集设置为空集，然后依次将字符串中的字符并入集合，直到所有字符都被处理完。调用顺序如下：'
- en: '[PRE108]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Technically, the *`StringValue`* parameter can be a string constant as well
    as a string variable; however, it doesn't make any sense to call `cs.strToCset`
    this way because `cs.cpy` is a much more efficient way to initialize a character
    set with a constant set of characters. As usual, the destination character set
    must be a `cset` variable. Typically, you'd use this function to create a character
    set based on a string input by the user.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，*`StringValue`* 参数可以是一个字符串常量，也可以是一个字符串变量；然而，以这种方式调用 `cs.strToCset` 没有任何意义，因为
    `cs.cpy` 是一种更高效的方式，用常量字符集来初始化字符集。像往常一样，目标字符集必须是一个 `cset` 变量。通常，你会使用这个函数根据用户输入的字符串创建一个字符集。
- en: 'The `cs.unionStr` procedure will add the characters in a string to an existing
    character set. Like `cs.strToCset`, you''d normally use this function to union
    characters into a set based on a string input by the user. The calling sequence
    for this is:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '`cs.unionStr` 过程会将字符串中的字符添加到现有字符集中。像 `cs.strToCset` 一样，你通常会使用此函数根据用户输入的字符串将字符联合成一个集合。调用顺序如下：'
- en: '[PRE109]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Standard set operations include union, intersection, and set difference. The
    HLA Standard Library routines `cs.setunion`, `cs.intersection`, and `cs.difference`
    provide these operations, respectively.^([[60](#ftn.CHP-4-FN-14)]) These routines
    all use the same calling sequence:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 标准集合操作包括并集、交集和集合差集。HLA 标准库例程 `cs.setunion`、`cs.intersection` 和 `cs.difference`
    分别提供这些操作^([[60](#ftn.CHP-4-FN-14)])。这些例程都使用相同的调用顺序：
- en: '[PRE110]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The first parameter can be a character set constant or a character set variable.
    The second parameter must be a character set variable. These procedures compute
    *`destCset`* `:=` *`destCset op srcCset`* where *`op`* represents set union, intersection,
    or difference, depending on the function call.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数可以是字符集常量或字符集变量。第二个参数必须是字符集变量。这些过程计算 *`destCset`* `:=` *`destCset op srcCset`*，其中
    *`op`* 表示集合并集、交集或差集，具体取决于函数调用。
- en: The third category of character set routines test character sets in various
    ways. They typically return a boolean value indicating the result of the test.
    The HLA character set routines in this category include `cs.IsEmpty`, `cs.member`,
    `cs.subset`, `cs.psubset`, `cs.superset`, `cs.psuperset`, `cs.eq`, and `cs.ne`.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 第三类字符集例程以各种方式测试字符集。它们通常返回一个布尔值，表示测试结果。HLA 字符集例程中的此类包括 `cs.IsEmpty`、`cs.member`、`cs.subset`、`cs.psubset`、`cs.superset`、`cs.psuperset`、`cs.eq`
    和 `cs.ne`。
- en: 'The `cs.IsEmpty` function tests a character set to see if it is the empty set.
    The function returns true or false in the EAX register. This function uses the
    following calling sequence:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '`cs.IsEmpty`函数用于测试一个字符集是否为空集。该函数将在EAX寄存器中返回true或false。此函数使用的调用顺序如下：'
- en: '[PRE111]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The single parameter may be a constant or a character set variable, although
    it doesn't make much sense to pass a character set constant to this procedure
    (because you would know at compile time whether this set is empty).
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 单个参数可以是常量或字符集变量，尽管将字符集常量传递给此过程没有多大意义（因为你在编译时就知道该集合是否为空）。
- en: 'The `cs.member` function tests to see if a character value is a member of a
    set. This function returns true in the EAX register if the character is a member
    of the set. Note that you can use the `bt` instruction to test this same condition.
    However, the `cs.member` function is probably a little more convenient to use
    if the character argument is not a constant. The calling sequence for `cs.member`
    is:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '`cs.member`函数用于测试某个字符值是否是集合的成员。如果字符是集合的成员，该函数将在EAX寄存器中返回true。请注意，你可以使用`bt`指令来测试相同的条件。然而，如果字符参数不是常量，`cs.member`函数可能会更方便使用。`cs.member`的调用顺序如下：'
- en: '[PRE112]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The first parameter is an 8-bit register, character variable, or a constant.
    The second parameter is either a character set constant or a character set variable.
    It would be unusual for both parameters to be constants.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个8位寄存器、字符变量或常量。第二个参数可以是字符集常量或字符集变量。两个参数都是常量的情况不太常见。
- en: 'The `cs.subset`*,* `cs.psubset` (proper subset), `cs.superset`*,* and `cs.psuperset`
    (proper superset) functions let you check to see if one character set is a subset
    or superset of another. The calling sequence for these four routines is nearly
    identical; it is one of the following:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`cs.subset`、`cs.psubset`（真子集）、`cs.superset`、`cs.psuperset`（真超集）函数让你检查一个字符集是否是另一个字符集的子集或超集。这四个例程的调用顺序几乎相同；它们的调用顺序如下：'
- en: '[PRE113]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: These routines compare the first parameter against the second parameter and
    return true or false in the EAX register depending upon the result. One set is
    a subset of another if all the members of the first character set are present
    in the second character set. It is a proper subset if the second (right) character
    set also contains characters not found in the first (left) character set. Likewise,
    one character set is a superset of another if it contains all the characters in
    the second set (and possibly more). A proper superset contains additional characters
    beyond those found in the second set. The parameters can be either character set
    variables or character set constants; however, it would be unusual for both parameters
    to be character set constants (because you can determine this at compile time,
    there would be no need to call a runtime function to compute this).
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例程将第一个参数与第二个参数进行比较，并根据结果在EAX寄存器中返回true或false。如果第一个字符集的所有成员都包含在第二个字符集中，则一个集合是另一个集合的子集。如果第二个（右边）字符集还包含在第一个（左边）字符集中不存在的字符，则它是一个真子集。同样，如果一个字符集包含第二个字符集中的所有字符（并可能包含更多字符），则它是另一个字符集的超集。真超集包含第二个集合中没有的额外字符。参数可以是字符集变量或字符集常量；然而，如果两个参数都是字符集常量就不太常见了（因为你可以在编译时确定这一点，没必要在运行时调用函数来计算）。
- en: 'The `cs.eq` and `cs.ne` functions check to see if two sets are equal or not
    equal. These functions return true or false in EAX depending upon the set comparison.
    The calling sequence is identical to the sub/superset functions above:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '`cs.eq`和`cs.ne`函数用于检查两个集合是否相等或不相等。这些函数根据集合比较结果在EAX中返回true或false。调用顺序与上面的子集/超集函数相同：'
- en: '[PRE114]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Note that there are no functions that test for less than, less than or equal,
    greater than, or greater than or equal. The subset and proper subset functions
    are the equivalent of less than or equal and less than (respectively); likewise,
    the superset and proper superset functions are equivalent to greater than or equal
    and greater than (respectively).
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，没有测试小于、小于等于、大于或大于等于的函数。子集和真子集函数分别等同于小于等于和小于；同样，超集和真超集函数分别等同于大于等于和大于。
- en: 'The `cs.extract` routine removes an arbitrary character from a character set
    and returns that character in the EAX register.^([[61](#ftn.CHP-4-FN-15)]) The
    calling sequence is the following:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '`cs.extract`例程从字符集中移除一个任意字符，并将该字符返回到EAX寄存器中。^([[61](#ftn.CHP-4-FN-15)]) 调用顺序如下：'
- en: '[PRE115]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The single parameter must be a character set variable. Note that this function
    will modify the character set variable by removing some character from the character
    set. This function returns $FFFF_FFFF (−1) in EAX if the character set was empty
    prior to the call.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的参数必须是一个字符集变量。请注意，这个函数会通过从字符集中删除某些字符来修改字符集变量。如果在调用之前字符集为空，这个函数会在 EAX 中返回 $FFFF_FFFF（−1）。
- en: In addition to the routines found in the `cset.hhf` (character set) library
    module, the string and standard output modules also provide functions that allow
    or expect character set parameters. For example, if you supply a character set
    value as a parameter to `stdout.put`, the `stdout.put` routine will print the
    characters currently in the set. See the HLA Standard Library documentation for
    more details on character set-handling procedures.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 `cset.hhf`（字符集）库模块中找到的例程外，字符串和标准输出模块还提供了允许或需要字符集参数的函数。例如，如果你将一个字符集值作为参数传递给
    `stdout.put`，那么 `stdout.put` 例程将打印字符集中当前的字符。有关字符集处理过程的更多细节，请参阅 HLA 标准库文档。
- en: '* * *'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[60](#CHP-4-FN-14)]) `cs.setunion` was used rather than `cs.union` because
    *union* is an HLA reserved word.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[60](#CHP-4-FN-14)]) 使用了 `cs.setunion` 而不是 `cs.union`，因为 *union* 是 HLA 的保留字。
- en: ^([[61](#CHP-4-FN-15)]) This routine returns the character in AL and zeros out
    the H.O. 3 bytes of EAX.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[61](#CHP-4-FN-15)]) 这个例程返回 AL 中的字符，并将 EAX 的高 3 字节清零。
- en: 4.16 Using Character Sets in Your HLA Programs
  id: totrans-513
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.16 在你的 HLA 程序中使用字符集
- en: Character sets are valuable for many different purposes in your programs. For
    example, one common use of character sets is to validate user input. This section
    will also present a couple of other applications for character sets to help you
    start thinking about how you could use them in your program.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 字符集在你的程序中有很多不同的用途。例如，字符集的一个常见用途是验证用户输入。本节还将介绍字符集的其他几个应用，帮助你开始思考如何在程序中使用它们。
- en: 'Consider the following short code segment that gets a yes/no-type answer from
    the user:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下简短的代码段，它从用户那里获取一个是/否类型的回答：
- en: '[PRE116]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'A major problem with this code sequence is that it will stop only if the user
    types a lowercase *n* character. If the user types anything other than *n* (including
    uppercase *N*), the program will treat this as an affirmative answer and transfer
    back to the beginning of the `repeat..until` loop. A better solution would be
    to validate the user input before the `until` clause above to ensure that the
    user has only typed *n*, *N*, *y*, or *Y*. The following code sequence will accomplish
    this:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码序列的一个主要问题是，它只有在用户输入小写的 *n* 时才会停止。如果用户输入除了 *n* 以外的任何字符（包括大写的 *N*），程序会把它当作肯定的回答，并返回到
    `repeat..until` 循环的开头。更好的解决方案是在 `until` 子句之前验证用户输入，以确保用户仅输入了 *n*、*N*、*y* 或 *Y*。以下代码序列将实现这一点：
- en: '[PRE117]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 4.17 Arrays
  id: totrans-519
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.17 数组
- en: Along with strings, arrays are probably the most commonly used composite data.
    Yet most beginning programmers don't understand how arrays operate internally
    and their associated efficiency trade-offs. It's surprising how many novice (and
    even advanced!) programmers view arrays from a completely different perspective
    once they learn how to deal with arrays at the machine level.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串一起，数组可能是最常用的复合数据类型。然而，大多数初学者程序员并不理解数组的内部操作以及它们相关的效率权衡。令人惊讶的是，许多初学者（甚至是高级程序员！）在学习如何在机器层面处理数组后，才会从完全不同的角度看待数组。
- en: Abstractly, an array is an aggregate data type whose members (elements) are
    all the same type. Selection of a member from the array is by an integer index.^([[62](#ftn.CHP-4-FN-16)])
    Different indices select unique elements of the array. This text assumes that
    the integer indices are contiguous (though this is by no means required). That
    is, if the number *x* is a valid index into the array and *y* is also a valid
    index, with *x* < *y*, then all *i* such that *x* < *i* < *y* are valid indices.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象来说，数组是一种聚合数据类型，其成员（元素）都是相同的类型。从数组中选择一个成员是通过一个整数索引来完成的。^([[62](#ftn.CHP-4-FN-16)])
    不同的索引选择数组中的独特元素。本节假设整数索引是连续的（尽管这并非必须）。也就是说，如果数字 *x* 是数组的有效索引，而 *y* 也是有效索引，并且 *x*
    < *y*，那么所有满足 *x* < *i* < *y* 的 *i* 都是有效的索引。
- en: Whenever you apply the indexing operator to an array, the result is the specific
    array element chosen by that index. For example, *`A`*`[`*`i`*`]` chooses the
    *i*th element from array `A`. Note that there is no formal requirement that element
    *`i`* be anywhere near element *`i`*`+1` in memory. As long as *`A`*`[`*`i`*`]`
    always refers to the same memory location and *`A`*`[`*`i+1`*`]` always refers
    to its corresponding location (and the two are different), the definition of an
    array is satisfied.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你对数组应用索引操作符时，结果是该索引选择的具体数组元素。例如，*`A`*`[`*`i`*`]` 选择数组 `A` 中的第 *i* 个元素。请注意，没有正式要求元素
    *`i`* 在内存中必须靠近元素 *`i+1`*。只要 *`A`*`[`*`i`*`]` 总是指向相同的内存位置，并且 *`A`*`[`*`i+1`*`]`
    总是指向其对应的位置（且两者不同），那么数组的定义就满足要求。
- en: In this text, we assume that array elements occupy contiguous locations in memory.
    An array with five elements will appear in memory as [Figure 4-4](ch04s17.html#array_layout_in_memory
    "Figure 4-4. Array layout in memory") shows.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们假设数组元素在内存中占据连续的位置。一个包含五个元素的数组将在内存中呈现为 [图 4-4](ch04s17.html#array_layout_in_memory
    "图 4-4. 数组在内存中的布局") 所示。
- en: '![Array layout in memory](tagoreillycom20100401nostarchimages577985.png)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
  zh: '![数组在内存中的布局](tagoreillycom20100401nostarchimages577985.png)'
- en: Figure 4-4. Array layout in memory
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-4. 数组在内存中的布局
- en: The *base address* of an array is the address of the first element on the array
    and always appears in the lowest memory location. The second array element directly
    follows the first in memory, the third element follows the second, and so on.
    Note that there is no requirement that the indices start at 0\. They may start
    with any number as long as they are contiguous. However, for the purposes of discussion,
    this book will start all indexes at 0.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的 *基地址* 是数组中第一个元素的地址，并且始终位于内存的最低位置。第二个数组元素紧跟第一个元素之后存储在内存中，第三个元素跟在第二个元素后面，以此类推。请注意，索引不一定要求从
    0 开始。它们可以从任何数字开始，只要是连续的即可。然而，为了讨论的方便，本书将所有索引从 0 开始。
- en: 'To access an element of an array, you need a function that translates an array
    index to the address of the indexed element. For a single-dimensional array, this
    function is very simple. It is:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数组中的一个元素，你需要一个将数组索引转换为索引元素地址的函数。对于一维数组，这个函数非常简单。它是：
- en: '[PRE118]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: where *`Initial_Index`* is the value of the first index in the array (which
    you can ignore if 0) and the value *`Element_Size`* is the size, in bytes, of
    an individual array element.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *`Initial_Index`* 是数组中第一个索引的值（如果是 0 可以忽略），*`Element_Size`* 是数组元素的大小，以字节为单位。
- en: '* * *'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[62](#CHP-4-FN-16)]) Or it could be some value whose underlying representation
    is integer, such as character, enumerated, and boolean types.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[62](#CHP-4-FN-16)]) 或者它可能是某个底层表示为整数的值，例如字符、枚举类型和布尔类型。
- en: 4.18 Declaring Arrays in Your HLA Programs
  id: totrans-532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.18 在 HLA 程序中声明数组
- en: 'Before you can access elements of an array, you need to set aside storage for
    that array. Fortunately, array declarations build on the declarations you''ve
    already seen. To allocate `n` elements in an array, you would use a declaration
    like the following in one of the variable declaration sections:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以访问数组的元素之前，你需要为该数组分配存储空间。幸运的是，数组声明基于你已经看到的声明。要为数组分配 `n` 个元素，你可以在变量声明部分使用如下声明：
- en: '[PRE119]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '*`ArrayName`* is the name of the array variable and *`basetype`* is the type
    of an element of that array. This sets aside storage for the array. To obtain
    the base address of the array, just use *`ArrayName`*.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '*`ArrayName`* 是数组变量的名称，*`basetype`* 是该数组元素的类型。这个声明为数组分配了存储空间。要获取数组的基地址，只需使用
    *`ArrayName`*。'
- en: The `[n]` suffix tells HLA to duplicate the object `n` times. Now let's look
    at some specific examples.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`[n]` 后缀告诉 HLA 将对象复制 `n` 次。现在让我们看一些具体示例。'
- en: '[PRE120]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'These examples all allocate storage for uninitialized arrays. You may also
    specify that the elements of the arrays be initialized using declarations like
    the following in the `static` and `readonly` sections:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例都为未初始化的数组分配了存储空间。你也可以指定使用如下声明在 `static` 和 `readonly` 部分初始化数组元素：
- en: '[PRE121]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: These definitions both create arrays with eight elements. The first definition
    initializes each 4-byte real value to 1.0, the second declaration initializes
    each `int32` element to 1\. Note that the number of constants within the square
    brackets must exactly match the size of the array.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个定义都创建了包含八个元素的数组。第一个定义将每个 4 字节的实数值初始化为 1.0，第二个声明将每个 `int32` 元素初始化为 1。请注意，方括号内常量的数量必须与数组的大小完全匹配。
- en: 'This initialization mechanism is fine if you want each element of the array
    to have the same value. What if you want to initialize each element of the array
    with a (possibly) different value? No sweat, just specify a different set of values
    in the list surrounded by the square brackets in the example above:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望数组的每个元素都具有相同的值，那么这种初始化机制是可以的。如果你想要初始化每个元素为（可能是）不同的值呢？不用担心，只需在上面示例中的方括号内指定一组不同的值：
- en: '[PRE122]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 4.19 HLA Array Constants
  id: totrans-543
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.19 HLA数组常量
- en: 'The last few examples in the previous section demonstrate the use of HLA array
    constants. An HLA array constant is nothing more than a list of values surrounded
    by a pair of brackets. The following are all legal array constants:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节的最后几个例子展示了HLA数组常量的使用。HLA数组常量不过是由一对括号包围的一组值。以下都是合法的数组常量：
- en: '[PRE123]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: (Note that this last array constant contains four double-word pointers to the
    four HLA strings appearing elsewhere in memory.)
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: （注意，最后这个数组常量包含了四个双字指针，指向内存中其他地方出现的四个HLA字符串。）
- en: As you saw in the previous section, you can use array constants in the `static`
    and `readonly` sections to provide initial values for array variables. The number
    of comma-separated items in an array constant must exactly match the number of
    array elements in the variable declaration. Likewise, the type of each of the
    array constant's elements must match the array variable's declared base type.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 如同你在上一节中所看到的，你可以在`static`和`readonly`部分使用数组常量来为数组变量提供初始值。数组常量中的项数必须与变量声明中的数组元素数量完全匹配。同样，数组常量中每个元素的类型必须与数组变量声明的基础类型相匹配。
- en: 'Using array constants to initialize small arrays is very convenient. Of course,
    if your array has several thousand elements, entering them will be tedious. Most
    arrays initialized this way have no more than a couple hundred entries and generally
    far less than 100\. It is reasonable to use an array constant to initialize such
    variables. However, at some point initializing arrays in this manner will become
    far too tedious and error prone. You probably would not want to manually initialize
    an array with 1,000 different elements using an array constant. However, if you
    want to initialize all the elements of an array with the same value, HLA does
    provide a special array constant syntax for doing so. Consider the following declaration:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组常量初始化小型数组非常方便。当然，如果你的数组有几千个元素，输入这些值会很繁琐。大多数以这种方式初始化的数组不超过几百个元素，通常远少于100个元素。使用数组常量来初始化这种变量是合理的。然而，到了某个时候，使用这种方式初始化数组会变得太过繁琐且容易出错。你可能不想手动用数组常量初始化一个有1000个不同元素的数组。然而，如果你想用相同的值初始化数组的所有元素，HLA确实提供了一种特殊的数组常量语法来做到这一点。考虑以下声明：
- en: '[PRE124]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'This declaration creates a 1,000-element integer array initializing each element
    to one. The `1000 dup [ 1 ]` expression tells HLA to create an array constant
    by duplicating the single value `[ 1 ]` one thousand times. You can even use the
    `dup` operator to duplicate a series of values (rather than a single value), as
    the following example indicates:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明创建了一个包含1000个元素的整数数组，并将每个元素初始化为1。`1000 dup [ 1 ]`表达式告诉HLA通过重复单一值`[ 1 ]`一千次来创建一个数组常量。你甚至可以使用`dup`运算符来重复一系列值（而不是单一值），如下例所示：
- en: '[PRE125]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This example initializes `SixteenInts` with four copies of the sequence `1,2,3,4`,
    yielding a total of 16 different integers (i.e., 1, 2, 3, 4, 1, 2, 3, 4, 1, 2,
    3, 4, 1, 2, 3, 4).
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子通过四次复制序列`1,2,3,4`来初始化`SixteenInts`，从而得到总共16个不同的整数（即1, 2, 3, 4, 1, 2, 3,
    4, 1, 2, 3, 4, 1, 2, 3, 4）。
- en: You will see some more possibilities with the `dup` operator when looking at
    multidimensional arrays in [4.22 Multidimensional Arrays](ch04s22.html "4.22 Multidimensional
    Arrays").
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看[4.22 多维数组](ch04s22.html "4.22 Multidimensional Arrays")时，你将看到使用`dup`运算符的更多可能性。
- en: 4.20 Accessing Elements of a Single-Dimensional Array
  id: totrans-554
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.20 访问一维数组的元素
- en: To access an element of a zero-based array, you can use the simplified formula
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问一个基于零的数组元素，你可以使用简化公式
- en: '[PRE126]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'For the *`Base_Address`* entry you can use the name of the array (because HLA
    associates the address of the first element of an array with the name of that
    array). The *`Element_Size`* entry is the number of bytes for each array element.
    If the object is an array of bytes, the *`Element_Size`* field is 1 (resulting
    in a very simple computation). If each element of the array is a word (or other
    2-byte type), then *`Element_Size`* is 2, and so on. To access an element of the
    `SixteenInts` array in the previous section, you''d use the following formula
    (the size is 4 because each element is an *`int32`* object):'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *`Base_Address`* 项，你可以使用数组的名称（因为 HLA 将数组第一个元素的地址与该数组的名称关联）。*`Element_Size`*
    项是每个数组元素的字节数。如果该对象是字节数组，*`Element_Size`* 字段为 1（结果是一个非常简单的计算）。如果数组的每个元素是一个字（或其他
    2 字节类型），则 *`Element_Size`* 为 2，依此类推。要访问上一节中的 `SixteenInts` 数组的一个元素，你可以使用以下公式（大小为
    4，因为每个元素是一个 *`int32`* 对象）：
- en: '[PRE127]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The 80x86 code equivalent to the statement `eax :=` *`SixteenInts`*`[`*`index`*`]`
    is
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 代码中等价于语句 `eax :=` *`SixteenInts`*`[`*`index`*`]` 的代码是：
- en: '[PRE128]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: There are two important things to notice here. First of all, this code uses
    the `shl` instruction rather than the `intmul` instruction to compute `4*index`.
    The main reason for choosing `shl` is that it was more efficient. It turns out
    that `shl` is a *lot* faster than `intmul` on many processors.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两点需要注意。首先，这段代码使用了 `shl` 指令，而不是 `intmul` 指令来计算 `4*index`。选择 `shl` 的主要原因是它更高效。事实证明，`shl`
    在许多处理器上比 `intmul` 快得多。
- en: The second thing to note about this instruction sequence is that it does not
    explicitly compute the sum of the base address plus the index times 4\. Instead,
    it relies on the indexed addressing mode to implicitly compute this sum. The instruction
    `mov( SixteenInts[ ebx ], eax );` loads EAX from location `SixteenInts + ebx`,
    which is the base address plus `index*4` (because EBX contains `index*4`). Sure,
    you could have used
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这条指令序列需要注意的第二点是，它并没有显式地计算基地址加上索引乘以 4 的和。而是依赖于索引寻址模式隐式地计算这个和。指令 `mov( SixteenInts[
    ebx ], eax );` 从 `SixteenInts + ebx` 位置加载 EAX，也就是基地址加上 `index*4`（因为 EBX 中包含 `index*4`）。当然，你本可以使用
- en: '[PRE129]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: in place of the previous sequence, but why use five instructions where three
    will do the same job? This is a good example of why you should know your addressing
    modes inside and out. Choosing the proper addressing mode can reduce the size
    of your program, thereby speeding it up.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 代替之前的指令序列，为什么要使用五条指令，而三条指令就能完成相同的任务呢？这是一个很好的例子，说明为什么你需要深入了解你的寻址模式。选择正确的寻址模式可以减少程序的大小，从而加快程序的运行速度。
- en: 'Of course, as long as we''re discussing efficiency improvements, it''s worth
    pointing out that the 80x86 scaled indexed addressing modes let you automatically
    multiply an index by 1, 2, 4, or 8\. Because this current example multiplies the
    index by 4, we can simplify the code even more by using the scaled indexed addressing
    mode:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，既然我们在讨论效率提升，值得指出的是，80x86 的缩放索引寻址模式让你能够自动将索引乘以 1、2、4 或 8。因为当前的示例将索引乘以 4，所以我们可以通过使用缩放索引寻址模式进一步简化代码：
- en: '[PRE130]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Note, however, that if you need to multiply by some constant other than 1, 2,
    4 or 8, then you cannot use the scaled indexed addressing modes. Similarly, if
    you need to multiply by some element size that is not a power of 2, you will not
    be able to use the `shl` instruction to multiply the index by the element size;
    instead, you will have to use `intmul` or some other instruction sequence to do
    the multiplication.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 但需要注意的是，如果你需要将索引乘以其他常数，而不是 1、2、4 或 8，那么你不能使用缩放索引寻址模式。同样，如果你需要将索引乘以某个不是 2 的幂的元素大小，你将不能使用
    `shl` 指令来将索引乘以元素大小；相反，你需要使用 `intmul` 或其他指令序列来完成乘法运算。
- en: The indexed addressing mode on the 80x86 is a natural for accessing elements
    of a single-dimensional array. Indeed, its syntax even suggests an array access.
    The important thing to keep in mind is that you must remember to multiply the
    index by the size of an element. Failure to do so will produce incorrect results.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 上的索引寻址模式非常适合访问一维数组的元素。事实上，它的语法甚至暗示着数组访问。需要记住的重要一点是，你必须记得将索引乘以元素的大小。如果忘记这样做，会导致不正确的结果。
- en: 4.21 Sorting an Array of Values
  id: totrans-569
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.21 排序一个值的数组
- en: Almost every textbook on this planet gives an example of a sort when introducing
    arrays. Because you've probably seen how to do a sort in high-level languages
    already, it's probably instructive to take a quick look at a sort in HLA. The
    example code in this section will use a variant of the bubble sort, which is great
    for short lists of data and lists that are nearly sorted but horrible for just
    about everything else.^([[63](#ftn.CHP-4-FN-17)])
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每本教科书在介绍数组时都会给出一个排序的例子。因为你可能已经在高级语言中看到过如何进行排序，所以看看在 HLA 中如何实现排序可能会更具启发性。本节中的示例代码将使用气泡排序的变种，这对于短列表数据和几乎已排序的列表非常有效，但对于其他情况几乎毫无用处。^([[63](#ftn.CHP-4-FN-17)])
- en: '[PRE131]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The bubble sort works by comparing adjacent elements in an array. The interesting
    thing to note in this code fragment is how it compares adjacent elements. You
    will note that the `if` statement compares EAX (which contains `DataToSort[ebx*4]`)
    against `DataToSort[ebx*4 + 4]`. Because each element of this array is 4 bytes
    (`uns32`), the index `[ebx*4 + 4]` references the next element beyond `[ebx*4]`.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 气泡排序通过比较数组中相邻的元素来工作。这个代码片段中有一个有趣的地方，那就是它如何比较相邻的元素。你会注意到，`if` 语句将 EAX（它包含 `DataToSort[ebx*4]`）与
    `DataToSort[ebx*4 + 4]`进行比较。因为该数组的每个元素是 4 字节（`uns32`），所以索引 `[ebx*4 + 4]` 引用的是
    `[ebx*4]` 之后的下一个元素。
- en: As is typical for a bubble sort, this algorithm terminates if the innermost
    loop completes without swapping any data. If the data is already presorted, then
    the bubble sort is very efficient, making only one pass over the data. Unfortunately,
    if the data is not sorted (worst case, if the data is sorted in reverse order),
    then this algorithm is extremely inefficient. Indeed, although it is possible
    to modify the code above so that, on the average, it runs about twice as fast,
    such optimizations are wasted on such a poor algorithm. However, the bubble sort
    is very easy to implement and understand (which is why introductory texts continue
    to use it in examples).
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 像气泡排序算法一样，如果最内层的循环在没有交换任何数据的情况下完成，则该算法终止。如果数据已经是预排序的，那么气泡排序非常高效，仅对数据进行一次遍历。不幸的是，如果数据没有排序（最坏的情况是数据按逆序排列），那么这个算法非常低效。实际上，虽然可以修改上面的代码，使其在平均情况下运行速度提高约两倍，但对于这么一个效率低下的算法，这些优化是徒劳的。然而，气泡排序非常容易实现和理解（这也是为什么入门教材仍然在示例中使用它）。
- en: '* * *'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[63](#CHP-4-FN-17)]) Fear not, you'll see some better sorting algorithms
    in [Chapter 5](ch05.html "Chapter 5. PROCEDURES AND UNITS").
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[63](#CHP-4-FN-17)]) 不要担心，您将在[第 5 章](ch05.html "第 5 章. 程序和单元")看到一些更好的排序算法。
- en: 4.22 Multidimensional Arrays
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.22 多维数组
- en: The 80x86 hardware can easily handle single-dimensional arrays. Unfortunately,
    there is no magic addressing mode that lets you easily access elements of multidimensional
    arrays. That's going to take some work and several instructions.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 硬件可以轻松处理一维数组。不幸的是，没有一种神奇的寻址模式可以让你轻松访问多维数组的元素。要做到这一点需要一些工作和多条指令。
- en: Before discussing how to declare or access multidimensional arrays, it would
    be a good idea to figure out how to implement them in memory. The first problem
    is to figure out how to store a multidimensional object into a one-dimensional
    memory space.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论如何声明或访问多维数组之前，最好先弄清楚如何在内存中实现它们。第一个问题是弄清楚如何将一个多维对象存储到一维内存空间中。
- en: Consider for a moment a Pascal array of the form `A:array[0..3,0..3] of char;`.
    This array contains 16 bytes organized as four rows of four characters. Somehow
    you've got to draw a correspondence with each of the 16 bytes in this array and
    16 contiguous bytes in main memory. [Figure 4-5](ch04s22.html#mapping_a_4x4_array_to_sequential_memory
    "Figure 4-5. Mapping a 4x4 array to sequential memory locations") shows one way
    to do this.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个 Pascal 数组，形式为 `A:array[0..3,0..3] of char;`。这个数组包含 16 个字节，组织为四行四列的字符。你需要将这个数组中的
    16 个字节与主内存中的 16 个连续字节对应起来。[图 4-5](ch04s22.html#mapping_a_4x4_array_to_sequential_memory
    "图 4-5. 将 4x4 数组映射到顺序内存位置") 展示了一种实现方式。
- en: '![Mapping a 4x4 array to sequential memory locations](tagoreillycom20100401nostarchimages577987.png)'
  id: totrans-580
  prefs: []
  type: TYPE_IMG
  zh: '![将 4x4 数组映射到顺序内存位置](tagoreillycom20100401nostarchimages577987.png)'
- en: Figure 4-5. Mapping a 4x4 array to sequential memory locations
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-5. 将 4x4 数组映射到顺序内存位置
- en: 'The actual mapping is not important as long as two things occur: (1) Each element
    maps to a unique memory location (that is, no two entries in the array occupy
    the same memory locations), and (2) the mapping is consistent. That is, a given
    element in the array always maps to the same memory location. So what you really
    need is a function with two input parameters (row and column) that produces an
    offset into a linear array of 16 memory locations.'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的映射并不重要，只要满足两个条件：(1) 每个元素都映射到唯一的内存位置（即，数组中的任何两个条目都不占用相同的内存位置），(2) 映射是一致的。也就是说，数组中的某个给定元素始终映射到相同的内存位置。因此，你真正需要的是一个带有两个输入参数（行和列）的函数，它可以产生一个指向
    16 个内存位置的线性数组的偏移量。
- en: 'Now any function that satisfies the above constraints will work fine. Indeed,
    you could randomly choose a mapping as long as it was consistent. However, what
    you really want is a mapping that is efficient to compute at runtime and works
    for any size array (not just 4x4 or even limited to two dimensions). While a large
    number of possible functions fit this bill, there are two functions in particular
    that most programmers and high-level languages use: *row-major ordering* and *column-major
    ordering*.'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何满足上述约束的函数都可以正常工作。事实上，只要映射一致，你甚至可以随意选择一个映射。然而，真正需要的是一个在运行时高效计算并且适用于任何大小数组（不仅仅是
    4x4 或二维数组）的映射。虽然有很多可能的函数符合这个要求，但有两个特别的函数是大多数程序员和高级语言使用的：*行主序排列* 和 *列主序排列*。
- en: 4.22.1 Row-Major Ordering
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.22.1 行主序排列
- en: Row-major ordering assigns successive elements, moving across the rows and then
    down the columns, to successive memory locations. This mapping is demonstrated
    in [Figure 4-6](ch04s22.html#row-major_array_element_ordering "Figure 4-6. Row-major
    array element ordering").
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 行主序排列将相邻的元素按行从左到右排列，再按列向下排列，并分配到连续的内存位置。这个映射在[图 4-6](ch04s22.html#row-major_array_element_ordering
    "图 4-6. 行主序数组元素排列")中得到了展示。
- en: '![Row-major array element ordering](tagoreillycom20100401nostarchimages577989.png)'
  id: totrans-586
  prefs: []
  type: TYPE_IMG
  zh: '![行主序数组元素排列](tagoreillycom20100401nostarchimages577989.png)'
- en: Figure 4-6. Row-major array element ordering
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-6. 行主序数组元素排列
- en: Row-major ordering is the method most high-level programming languages employ.
    It is very easy to implement and use in machine language. You start with the first
    row (row 0) and then concatenate the second row to its end. You then concatenate
    the third row to the end of the list, then the fourth row, and so on (see [Figure 4-7](ch04s22.html#another_view_of_row-major_ordering_for_a
    "Figure 4-7. Another view of row-major ordering for a 4×4 array")).
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 行主序排列是大多数高级编程语言采用的方法。这种方法在机器语言中非常容易实现和使用。你从第一行（行 0）开始，然后将第二行连接到其末尾。接着将第三行连接到列表的末尾，然后是第四行，依此类推（参见[图
    4-7](ch04s22.html#another_view_of_row-major_ordering_for_a "图 4-7. 4×4 数组的行主序排列的另一种视图")）。
- en: '![Another view of row-major ordering for a 4×4 array](tagoreillycom20100401nostarchimages577991.png.jpg)'
  id: totrans-589
  prefs: []
  type: TYPE_IMG
  zh: '![4×4 数组的行主序排列的另一种视图](tagoreillycom20100401nostarchimages577991.png.jpg)'
- en: Figure 4-7. Another view of row-major ordering for a 4×4 array
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-7. 4×4 数组的行主序排列的另一种视图
- en: 'The actual function that converts a list of index values into an offset is
    a slight modification of the formula for computing the address of an element of
    a single-dimensional array. The formula to compute the offset for a two-dimensional
    row-major ordered array is:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 将索引值列表转换为偏移量的实际函数是对计算一维数组元素地址公式的轻微修改。计算二维行主序排列数组偏移量的公式如下：
- en: '[PRE132]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'As usual, *`Base_Address`* is the address of the first element of the array
    (`A[0][0]` in this case), and *`Element_Size`* is the size of an individual element
    of the array, in bytes. *`colindex`* is the leftmost index, and *`rowindex`* is
    the rightmost index into the array. *`row_size`* is the number of elements in
    one row of the array (four, in this case, because each row has four elements).
    Assuming *`Element_Size`* is 1, this formula computes the following offsets from
    the base address:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，*`Base_Address`* 是数组第一个元素的地址（在本例中是`A[0][0]`），*`Element_Size`* 是数组单个元素的大小，以字节为单位。*`colindex`*
    是最左边的索引，*`rowindex`* 是数组中最右边的索引。*`row_size`* 是数组中一行的元素数量（在本例中为四，因为每行有四个元素）。假设*`Element_Size`*
    为 1，以下公式计算从基地址开始的偏移量：
- en: '[PRE133]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'For a three-dimensional array, the formula to compute the offset into memory
    is the following:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 对于三维数组，计算内存偏移量的公式如下：
- en: '[PRE134]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '*`col_size`* is the number of items in a column, and `row_size` is the number
    of items in a row. In C/C++, if you''ve declared the array as *`type`* `A[i] [j]
    [k];`, then *`row_size`* is equal to `k` and *`col_size`* is equal to `j`.'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '*`col_size`* 是列中的元素数，`row_size` 是行中的元素数。在 C/C++ 中，如果你声明数组为 *`type`* `A[i] [j]
    [k];`，那么 *`row_size`* 等于 `k`，*`col_size`* 等于 `j`。'
- en: 'For a four-dimensional array, declared in C/C++ as *`type`* `A[i] [j] [k] [m];`,
    the formula for computing the address of an array element is:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在 C/C++ 中声明的四维数组 *`type`* `A[i] [j] [k] [m];`，计算数组元素地址的公式是：
- en: '[PRE135]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '*`depth_size`* is equal to `j`, *`col_size`* is equal to `k`, and *`row_size`*
    is equal to `m`. *`LeftIndex`* represents the value of the leftmost index.'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '*`depth_size`* 等于 `j`，*`col_size`* 等于 `k`，*`row_size`* 等于 `m`。*`LeftIndex`*
    表示最左侧索引的值。'
- en: By now you're probably beginning to see a pattern. There is a generic formula
    that will compute the offset into memory for an array with *any* number of dimensions;
    however, you'll rarely use more than four.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经开始看到一种模式。确实存在一个通用公式，可以计算任何维度的数组在内存中的偏移量；然而，你很少会使用超过四个维度的数组。
- en: 'Another convenient way to think of row-major arrays is as arrays of arrays.
    Consider the following single-dimensional Pascal array definition:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方便的思考行主序数组的方法是将其视为数组的数组。考虑以下单维 Pascal 数组定义：
- en: '[PRE136]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Assume that *`sometype`* is the type *`sometype`* `= array [0..3] of char;`.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 *`sometype`* 是类型 *`sometype`* `= array [0..3] of char;`。
- en: '`A` is a single-dimensional array. Its individual elements happen to be arrays,
    but you can safely ignore that for the time being. The formula to compute the
    address of an element of a single-dimensional array is:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '`A` 是一个一维数组。它的单独元素恰好是数组，但暂时可以忽略这一点。计算一维数组元素地址的公式是：'
- en: '[PRE137]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: In this case *`Element_Size`* happens to be 4 because each element of *`A`*
    is an array of four characters. So what does this formula compute? It computes
    the base address of each row in this 4x4 array of characters (see [Figure 4-8](ch04s22.html#viewing_a_4x4_array_as_an_array_of_array
    "Figure 4-8. Viewing a 4x4 array as an array of arrays")).
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，*`Element_Size`* 恰好为 4，因为 *`A`* 的每个元素都是一个包含四个字符的数组。那么这个公式计算的是什么呢？它计算的是这个
    4x4 字符数组中每一行的基地址（参见 [图 4-8](ch04s22.html#viewing_a_4x4_array_as_an_array_of_array
    "图 4-8. 查看 4x4 数组作为数组的数组")）。
- en: '![Viewing a 4x4 array as an array of arrays](tagoreillycom20100401nostarchimages577993.png)'
  id: totrans-608
  prefs: []
  type: TYPE_IMG
  zh: '![查看 4x4 数组作为数组的数组](tagoreillycom20100401nostarchimages577993.png)'
- en: Figure 4-8. Viewing a 4x4 array as an array of arrays
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-8. 查看 4x4 数组作为数组的数组
- en: Of course, once you compute the base address of a row, you can reapply the single-dimensional
    formula to get the address of a particular element. While this doesn't affect
    the computation, it's probably a little easier to deal with several single-dimensional
    computations rather than a complex multidimensional array computation.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一旦计算出一行的基地址，你可以重新应用一维公式来获取特定元素的地址。虽然这不会影响计算，但处理几个一维计算可能比处理复杂的多维数组计算要容易一些。
- en: 'Consider a Pascal array defined as `A:array [0..3] [0..3] [0..3] [0..3] [0..3]
    of char;`. You can view this five-dimensional array as a single-dimensional array
    of arrays. The following HLA code provides such a definition:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个定义为 `A:array [0..3] [0..3] [0..3] [0..3] [0..3] of char;` 的 Pascal 数组。你可以将这个五维数组视为一个数组的数组。一段
    HLA 代码提供了这样的定义：
- en: '[PRE138]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The size of `OneD` is 4 bytes. Because `TwoD` contains four `OneD` arrays,
    its size is 16 bytes. Likewise, `ThreeD` is four `TwoD`s, so it is 64 bytes long.
    Finally, `FourD` is four `ThreeDs`, so it is 256 bytes long. To compute the address
    of `A [b, c, d, e, f]`, you could use the following steps:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '`OneD` 的大小是 4 字节。因为 `TwoD` 包含四个 `OneD` 数组，所以它的大小是 16 字节。同样，`ThreeD` 是四个 `TwoD`，因此它的大小是
    64 字节。最后，`FourD` 是四个 `ThreeD`，所以它的大小是 256 字节。为了计算 `A [b, c, d, e, f]` 的地址，你可以使用以下步骤：'
- en: Compute the address of `A [b]` as *`Base`* `+ b *` *`size`*. Here size is 256
    bytes. Use this result as the new base address in the next computation.
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过公式计算 `A [b]` 的地址，公式为 *`Base`* `+ b *` *`size`*。其中 size 为 256 字节。将此结果作为下一步计算中的新基地址。
- en: Compute the address of `A [b, c]` by the formula *`Base`* `+ c *` *`size`*,
    where *`Base`* is the value obtained in the previous step and *`size`* is 64\.
    Use the result as the new base in the next computation.
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过公式 *`Base`* `+ c *` *`size`* 计算 `A [b, c]` 的地址，其中 *`Base`* 是上一步得到的值，*`size`*
    为 64。将结果作为下一步计算中的新基地址。
- en: Compute the base address of `A [b, c, d]` by *`Base`* `+ d *` *`size`*, with
    *`Base`* coming from the previous computation and *`size`* is 16\. Use the result
    as the new base in the next computation.
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 *`Base`* `+ d *` *`size`* 计算 `A[b, c, d]` 的基地址，*`Base`* 来自前一步的计算，*`size`*
    为 16。将该结果作为下一个计算的基地址。
- en: Compute the address of `A [b, c, d, e]` with the formula *`Base`* `+ e *` *`size`*,
    with *`Base`* from the previous step with a size of 4\. Use this value as the
    base for the next computation.
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用公式 *`Base`* `+ e *` *`size`* 计算 `A[b, c, d, e]` 的地址，其中 *`Base`* 来自前一步的计算，*`size`*
    为 4。将此值作为下一步计算的基地址。
- en: Finally, compute the address of `A [b, c, d, e, f]` using the formula *`Base`*
    `+ f *` *`size`*, where *`Base`* comes from the previous computation and *`size`*
    is 1 (obviously you can simply ignore this final multiplication). The result you
    obtain at this point is the address of the desired element.
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用公式 *`Base`* `+ f *` *`size`* 计算 `A[b, c, d, e, f]` 的地址，其中 *`Base`* 来自之前的计算，*`size`*
    为 1（显然，你可以忽略这一最后的乘法）。此时你得到的结果就是所需元素的地址。
- en: One of the main reasons you won't find higher-dimensional arrays in assembly
    language is that assembly language emphasizes the inefficiencies associated with
    such access. It's easy to enter something like `A [b, c, d, e, f]` into a Pascal
    program, not realizing what the compiler is doing with the code. Assembly language
    programmers are not so cavalier—they see the mess you wind up with when you use
    higher-dimensional arrays. Indeed, good assembly language programmers try to avoid
    two-dimensional arrays and often resort to tricks in order to access data in such
    an array when its use becomes absolutely mandatory.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 你在汇编语言中不会找到高维数组的一个主要原因是，汇编语言强调与这种访问方式相关的低效性。像 `A[b, c, d, e, f]` 这样的内容很容易就会被输入到
    Pascal 程序中，而你可能没意识到编译器在处理这些代码时的方式。汇编语言程序员可不会这么轻率——他们清楚地知道，当你使用高维数组时，会遇到的一团糟。事实上，优秀的汇编语言程序员会尽量避免使用二维数组，并且在不得已使用二维数组时，往往会采取一些技巧来访问该数组中的数据。
- en: 4.22.2 Column-Major Ordering
  id: totrans-620
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.22.2 列主序排列
- en: Column-major ordering is the other function high-level languages frequently
    used to compute the address of an array element. FORTRAN and various dialects
    of BASIC (e.g., older versions of Microsoft BASIC) use this method.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 列主序排列是高阶语言中常用来计算数组元素地址的另一种方法。FORTRAN 和各种 BASIC 方言（例如，早期版本的 Microsoft BASIC）使用这种方法。
- en: In row-major ordering the rightmost index increases the fastest as you move
    through consecutive memory locations. In column-major ordering the leftmost index
    increases the fastest. Pictorially, a column-major ordered array is organized
    as shown in [Figure 4-9](ch04s22.html#column-major_array_element_ordering "Figure 4-9. Column-major
    array element ordering").
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 在行主序排列中，最右侧的索引随着你在连续的内存位置中移动而增长最快。在列主序排列中，最左侧的索引增长得最快。从图示上来看，列主序排列的数组结构如图 [Figure
    4-9](ch04s22.html#column-major_array_element_ordering "Figure 4-9. Column-major
    array element ordering") 所示。
- en: '![Column-major array element ordering](tagoreillycom20100401nostarchimages577995.png)'
  id: totrans-623
  prefs: []
  type: TYPE_IMG
  zh: '![列主序数组元素排列](tagoreillycom20100401nostarchimages577995.png)'
- en: Figure 4-9. Column-major array element ordering
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-9。列主序数组元素排列
- en: 'The formula for computing the address of an array element when using column-major
    ordering is very similar to that for row-major ordering. You simply reverse the
    indexes and sizes in the computation:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列主序排列时，计算数组元素地址的公式与行主序排列时非常相似。你只需要在计算中反转索引和尺寸：
- en: '[PRE139]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 4.23 Allocating Storage for Multidimensional Arrays
  id: totrans-627
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.23 为多维数组分配存储空间
- en: 'If you have an *`m`* x *`n`* array, it will have *`m`* * *`n`* elements and
    require *`m`* * *`n`* * *`Element_Size`* bytes of storage. To allocate storage
    for an array you must reserve this memory. As usual, there are several different
    ways of accomplishing this task. Fortunately, HLA''s array-declaration syntax
    is very similar to high-level language array-declaration syntax, so C/C++, Java,
    BASIC, and Pascal programmers will feel right at home. To declare a multidimensional
    array in HLA, you use a declaration like the following:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个 *`m`* x *`n`* 的数组，它将包含 *`m`* * *`n`* 个元素，并且需要 *`m`* * *`n`* * *`Element_Size`*
    字节的存储空间。为了为数组分配存储空间，你必须预留这块内存。像往常一样，有几种不同的方式来完成这个任务。幸运的是，HLA 的数组声明语法与高阶语言的数组声明语法非常相似，因此
    C/C++、Java、BASIC 和 Pascal 程序员都会觉得得心应手。要在 HLA 中声明一个多维数组，你可以使用类似以下的声明：
- en: '[PRE140]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'For example, here is a declaration for a 4x4 array of characters:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一个 4x4 字符数组的声明：
- en: '[PRE141]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Here is another example that shows how to declare a three-dimensional array
    of strings:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个示例，展示如何声明一个三维字符串数组：
- en: '[PRE142]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Remember, string objects are really pointers, so this array declaration reserves
    storage for 18 double-word pointers (2 * 3 * 3 = 18).
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，字符串对象实际上是指针，因此此数组声明为 18 个双字指针（2 * 3 * 3 = 18）保留了存储空间。
- en: 'As was the case with single-dimensional arrays, you may initialize every element
    of the array to a specific value by following the declaration with the assignment
    operator and an array constant. Array constants ignore dimension information;
    all that matters is that the number of elements in the array constant corresponds
    to the number of elements in the actual array. The following example shows the
    `GameGrid` declaration with an initializer:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 就像单维数组一样，你可以通过在声明后跟上赋值操作符和数组常量来初始化数组的每个元素。数组常量会忽略维度信息；唯一重要的是数组常量中的元素数量与实际数组中的元素数量相对应。以下示例显示了带有初始化器的
    `GameGrid` 声明：
- en: '[PRE143]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Note that HLA ignores the indentation and extra whitespace characters (e.g.,
    newlines) appearing in this declaration. It was laid out to enhance readability
    (which is always a good idea). HLA does not interpret the four separate lines
    as representing rows of data in the array. Humans do, which is why it's good to
    write the data in this manner. All that matters is that there are 16 (4 * 4) characters
    in the array constant. You'll probably agree that this is much easier to read
    than
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，HLA 会忽略此声明中出现的缩进和额外的空白字符（例如换行符）。此布局是为了增强可读性（这是一个始终不错的想法）。HLA 并不会将这四行视为数组中的数据行，而是人类这样做，这也是为什么以这种方式书写数据很好的原因。唯一重要的是数组常量中有
    16（4 * 4）个字符。你可能会同意，这比
- en: '[PRE144]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Of course, if you have a large array, an array with really large rows, or an
    array with many dimensions, there is little hope for winding up with something
    readable. That's when comments that carefully explain everything come in handy.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你有一个很大的数组，或者一个非常大的行数数组，或者一个多维数组，那么最终可能无法获得可读性高的代码。这时，精心编写的注释就派上用场了。
- en: 'As for single-dimensional arrays, you can use the `dup` operator to initialize
    each element of a large array with the same value. The following example initializes
    a 256x64 array of bytes so that each byte contains the value $FF:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 至于单维数组，你可以使用 `dup` 操作符来将大数组的每个元素初始化为相同的值。以下示例初始化了一个 256x64 的字节数组，使每个字节包含值 $FF：
- en: '[PRE145]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Note the use of a constant expression to compute the number of array elements
    rather than simply using the constant 16,384 (256 * 64). The use of the constant
    expression more clearly suggests that this code is initializing each element of
    a 256x64 element array than does the simple literal constant 16,384.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用常量表达式来计算数组元素的数量，而不是简单地使用常量 16,384（256 * 64）。使用常量表达式更加清晰地表明这段代码正在初始化一个 256x64
    元素的数组，而不是简单的文字常量 16,384。
- en: 'Another HLA trick you can use to improve the readability of your programs is
    to use *nested array constants*. The following is an example of an HLA nested
    array constant:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以用来提高程序可读性的 HLA 技巧是使用 *嵌套数组常量*。以下是一个 HLA 嵌套数组常量的示例：
- en: '[PRE146]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Whenever HLA encounters an array constant nested inside another array constant,
    it simply removes the brackets surrounding the nested array constant and treats
    the whole constant as a single-array constant. For example, HLA converts this
    nested array constant to the following:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 HLA 遇到嵌套在另一个数组常量中的数组常量时，它会简单地移除围绕嵌套数组常量的括号，并将整个常量视为单一数组常量。例如，HLA 会将这个嵌套数组常量转换为如下所示：
- en: '[PRE147]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'You can take advantage of this fact to help make your programs a little more
    readable. For multidimensional array constants you can enclose each row of the
    constant in square brackets to denote that the data in each row is grouped and
    separate from the other rows. Consider the following declaration for the `GameGrid`
    array that is identical (as far as HLA is concerned) to the earlier declaration
    for `GameGrid`:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用这一点来帮助使你的程序更具可读性。对于多维数组常量，你可以将每一行常量用方括号括起来，以表示每一行的数据是分组的，并与其他行分开。考虑下面的
    `GameGrid` 数组声明，它与之前的 `GameGrid` 声明在 HLA 眼中是相同的：
- en: '[PRE148]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: This declaration makes it clearer that the array constant is a 4x4 array rather
    than just a 16-element one-dimensional array whose elements wouldn't fit all on
    one line of source code. Little aesthetic improvements like this are what separate
    mediocre programmers from good programmers.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明更清楚地表明该数组常量是一个 4x4 的数组，而不仅仅是一个 16 元素的一维数组，因为它的元素无法都放在一行源代码中。像这样的细微美学改进正是将普通程序员与优秀程序员区分开的因素。
- en: 4.24 Accessing Multidimensional Array Elements in Assembly Language
  id: totrans-650
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.24 在汇编语言中访问多维数组元素
- en: Well, you've seen the formulas for computing the address of a multidimensional
    array element. Now it's time to see how to access elements of those arrays using
    assembly language.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你已经看过了计算多维数组元素地址的公式。现在是时候看看如何使用汇编语言访问这些数组的元素了。
- en: The `mov`, `shl`, and `intmul` instructions make short work of the various equations
    that compute offsets into multidimensional arrays. Let's consider a two-dimensional
    array first.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov`、`shl`和`intmul`指令能够快速处理计算多维数组偏移量的各种方程式。我们先来看一个二维数组的例子。'
- en: '[PRE149]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Note that this code does *not* require the use of a two-register addressing
    mode on the 80x86\. Although an addressing mode like `TwoD[ebx][esi]` looks like
    it should be a natural for accessing two-dimensional arrays, that isn't the purpose
    of this addressing mode.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这段代码*不*需要在80x86上使用双寄存器寻址模式。虽然像`TwoD[ebx][esi]`这样的寻址模式看起来应该是访问二维数组的自然方式，但这并不是该寻址模式的目的。
- en: 'Now consider a second example that uses a three-dimensional array:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑第二个示例，它使用了一个三维数组：
- en: '[PRE150]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Note that this code uses the `intmul` instruction to multiply the value in EBX
    by 5\. Remember, the `shl` instruction can only multiply a register by a power
    of 2\. While there are ways to multiply the value in a register by a constant
    other than a power of 2, the `intmul` instruction is more convenient.^([[64](#ftn.CHP-4-FN-18)])
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这段代码使用了`intmul`指令将EBX中的值乘以5。记住，`shl`指令只能将寄存器的值乘以2的幂。虽然也有方法将寄存器中的值乘以非2的幂常数，但`intmul`指令更加方便。^([[64](#ftn.CHP-4-FN-18)])
- en: '* * *'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[64](#CHP-4-FN-18)]) A full discussion of multiplication by constants other
    than a power of 2 appears in [Chapter 4](ch04.html "Chapter 4. CONSTANTS, VARIABLES,
    AND DATA TYPES").
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[64](#CHP-4-FN-18)]) 关于常数乘法的完整讨论（除了2的幂）出现在[第4章](ch04.html "第4章 常量、变量和数据类型")。
- en: 4.25 Records
  id: totrans-660
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.25 记录
- en: Another major composite data structure is the Pascal record or C/C++/C# structure.^([[65](#ftn.CHP-4-FN-19)])
    The Pascal terminology is probably better, because it tends to avoid confusion
    with the more general term *data structure*. Because HLA uses the term *record*,
    we'll adopt that term here.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个主要的复合数据结构是Pascal记录或C/C++/C#结构。^([[65](#ftn.CHP-4-FN-19)]) Pascal术语可能更好，因为它避免了与更通用的术语*数据结构*混淆。由于HLA使用术语*记录*，我们在这里也采用这个术语。
- en: Whereas an array is homogeneous, whose elements are all the same type, the elements
    in a record can have different types. Arrays let you select a particular element
    via an integer index. With records, you must select an element (known as a *field*)
    by name.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 而数组是同质的，其元素都是相同类型的，记录中的元素可以具有不同的类型。数组允许你通过整数索引选择特定元素。对于记录，你必须通过名称选择一个元素（称为*字段*）。
- en: 'The whole purpose of a record is to let you encapsulate different, though logically
    related, data into a single package. The Pascal record declaration for a student
    is a typical example:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的全部目的是让你将不同的、尽管在逻辑上相关的数据封装到一个单一的包中。Pascal记录的学生声明是一个典型示例：
- en: '[PRE151]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Most Pascal compilers allocate each field in a record to contiguous memory locations.
    This means that Pascal will reserve the first 65 bytes for the name,^([[66](#ftn.CHP-4-FN-20)])
    the next 2 bytes hold the major code, the next 12 bytes hold the Social Security
    number, and so on.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Pascal编译器将记录中的每个字段分配到连续的内存位置。这意味着Pascal将为名称保留前65个字节，^([[66](#ftn.CHP-4-FN-20)])接下来的2个字节保存主代码，接下来的12个字节保存社会安全号码，依此类推。
- en: 'In HLA, you can also create record types using the `record`/`endrecord` declaration.
    You would encode the above record in HLA as follows:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 在HLA中，你也可以使用`record`/`endrecord`声明创建记录类型。你可以通过以下方式在HLA中编码上述记录：
- en: '[PRE152]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: As you can see, the HLA declaration is very similar to the Pascal declaration.
    Note that, to be true to the Pascal declaration, this example uses character arrays
    rather than strings for the `Name` and `SSN` (US Social Security number) fields.
    In a real HLA record declaration you'd probably use a string type for at least
    the name (keeping in mind that a string variable is only a 4-byte pointer).
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，HLA声明与Pascal声明非常相似。请注意，为了忠实于Pascal声明，示例中使用了字符数组而不是字符串来表示`Name`和`SSN`（美国社会安全号码）字段。在实际的HLA记录声明中，你可能会为至少是名称字段使用字符串类型（记住，字符串变量实际上是一个4字节指针）。
- en: The field names within the record must be unique. That is, the same name may
    not appear two or more times in the same record. However, all field names are
    local to that record. Therefore, you may reuse those field names elsewhere in
    the program or in different records.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 记录中的字段名必须是唯一的。也就是说，同一个名字不能在同一个记录中出现两次或更多次。然而，所有字段名对于该记录是局部的。因此，你可以在程序的其他地方或不同的记录中重复使用这些字段名。
- en: 'The `record`/`endrecord` declaration may appear in a variable declaration section
    (e.g., `static` or `var`) or in a `type` declaration section. In the previous
    example the `Student` declaration appears in the `type` section, so this does
    not actually allocate any storage for a `Student` variable. Instead, you have
    to explicitly declare a variable of type `Student`. The following example demonstrates
    how to do this:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '`record`/`endrecord`声明可以出现在变量声明部分（例如`static`或`var`）或`type`声明部分。在之前的示例中，`Student`声明出现在`type`部分，因此这并没有为`Student`变量分配任何存储空间。相反，你需要显式声明一个`Student`类型的变量。以下示例演示了如何做到这一点：'
- en: '[PRE153]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: This allocates 81 bytes of storage laid out in memory as shown in [Figure 4-10](ch04s25.html#student_data_structure_storage_in_memory
    "Figure 4-10. Student data structure storage in memory").
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 这分配了81字节的存储，并在内存中按[图 4-10](ch04s25.html#student_data_structure_storage_in_memory
    "图 4-10. 学生数据结构在内存中的存储")所示的方式布局。
- en: '![Student data structure storage in memory](tagoreillycom20100401nostarchimages577997.png)'
  id: totrans-673
  prefs: []
  type: TYPE_IMG
  zh: '![学生数据结构在内存中的存储](tagoreillycom20100401nostarchimages577997.png)'
- en: Figure 4-10. Student data structure storage in memory
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-10. 学生数据结构在内存中的存储
- en: If the label `John` corresponds to the *base address* of this record, then the
    `Name` field is at offset `John+0`, the `Major` field is at offset `John+65`,
    the `SSN` field is at offset `John+67`, and so on.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标签`John`对应于该记录的*基地址*，那么`Name`字段的偏移量为`John+0`，`Major`字段的偏移量为`John+65`，`SSN`字段的偏移量为`John+67`，依此类推。
- en: To access an element of a structure, you need to know the offset from the beginning
    of the structure to the desired field. For example, the `Major` field in the variable
    `John` is at offset 65 from the base address of `John`. Therefore, you could store
    the value in AX into this field using the instruction
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问结构中的元素，你需要知道从结构的起始位置到目标字段的偏移量。例如，变量`John`中的`Major`字段相对于`John`的基地址的偏移量是65。因此，你可以使用以下指令将AX中的值存储到该字段中：
- en: '[PRE154]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Unfortunately, memorizing all the offsets to fields in a record defeats the
    whole purpose of using them in the first place. After all, if you have to deal
    with these numeric offsets, why not just use an array of bytes instead of a record?
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，记住记录中所有字段的偏移量违背了使用记录的初衷。毕竟，如果你必须处理这些数字偏移量，为什么不直接使用字节数组而不是记录呢？
- en: 'Fortunately, HLA lets you refer to field names in a record using the same mechanism
    C/C++/C# and Pascal use: the dot operator. To store AX into the `Major` field,
    you could use `mov( ax, John.Major );` instead of the previous instruction. This
    is much more readable and certainly easier to use.'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，HLA让你可以通过与C/C++/C#和Pascal相同的机制来引用记录中的字段名：点操作符。为了将AX存储到`Major`字段，你可以使用`mov(
    ax, John.Major );`，而不是之前的指令。这种方式更加易读，且使用起来显然更为简便。
- en: Note that the use of the dot operator does *not* introduce a new addressing
    mode. The instruction `mov( ax, John.Major );` still uses the displacement-only
    addressing mode. HLA simply adds the base address of `John` with the offset to
    the `Major` field (65) to get the actual displacement to encode into the instruction.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用点操作符*并不会*引入新的寻址模式。指令`mov( ax, John.Major );`依然使用的是仅位移寻址模式。HLA只是将`John`的基地址与`Major`字段的偏移量（65）相加，以得到实际的位移量，并将其编码到指令中。
- en: 'Like any type declaration, HLA requires all record type declarations to appear
    in the program before you use them. However, you don''t have to define all records
    in the `type` section to create record variables. You can use the `record`/`endrecord`
    declaration directly in a variable declaration section. This is convenient if
    you have only one instance of a given record object in your program. The following
    example demonstrates this:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何类型声明一样，HLA要求所有记录类型声明在你使用之前出现在程序中。然而，你不必在`type`部分定义所有记录来创建记录变量。你可以直接在变量声明部分使用`record`/`endrecord`声明。如果程序中只需要一个特定记录对象的实例，这种方式非常方便。以下示例演示了这一点：
- en: '[PRE155]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '* * *'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[65](#CHP-4-FN-19)]) It also goes by some other names in other languages,
    but most people recognize at least one of these names.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[65](#CHP-4-FN-19)]) 它在其他语言中也有一些不同的名称，但大多数人至少认识其中一个名称。
- en: ^([[66](#CHP-4-FN-20)]) Strings require an extra byte, in addition to all the
    characters in the string, to encode the length.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[66](#CHP-4-FN-20)]) 字符串需要额外的一个字节，除了字符串中的所有字符外，还用于编码长度。
- en: 4.26 Record Constants
  id: totrans-686
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.26 记录常量
- en: HLA lets you define record constants. In fact, HLA supports both manifest (symbolic)
    record constants and literal record constants. Record constants are useful as
    initializers for static record variables. They are also quite useful as compile-time
    data structures when using the HLA compile-time language (see the HLA reference
    manual for more details on the HLA compile-time language). This section discusses
    how to create record constants.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 让你定义记录常量。事实上，HLA 支持符号（显式）记录常量和字面值记录常量。记录常量作为静态记录变量的初始化器非常有用。当使用 HLA 编译时语言时，它们也作为编译时数据结构非常有用（有关
    HLA 编译时语言的更多细节，请参阅 HLA 参考手册）。本节将讨论如何创建记录常量。
- en: 'A literal record constant takes the following form:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 字面值记录常量的形式如下：
- en: '[PRE156]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The *`RecordTypeName`* is the name of a record data type you've defined in an
    HLA `type` section prior to using the constant.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '*`RecordTypeName`* 是你在 HLA `type` 部分定义的记录数据类型的名称，必须在使用常量之前定义。'
- en: 'The constant list appearing between the brackets is the data for each of the
    fields in the specified record. The first item in the list corresponds to the
    first field of the record, the second item in the list corresponds to the second
    field, and so on. The data types of each of the constants appearing in this list
    must match their respective field types. The following example demonstrates how
    to use a literal record constant to initialize a record variable:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 出现在括号中的常量列表是指定记录中每个字段的数据。列表中的第一个项对应记录的第一个字段，第二个项对应记录的第二个字段，以此类推。此列表中每个常量的数据类型必须与其各自字段的类型匹配。以下示例演示了如何使用字面值记录常量来初始化记录变量：
- en: '[PRE157]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: This declaration initializes `Vector.x` with 1, `Vector.y` with −2, and `Vector.z`
    with 3.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 该声明将 `Vector.x` 初始化为 1，`Vector.y` 初始化为 −2，`Vector.z` 初始化为 3。
- en: 'You can also create manifest record constants by declaring record objects in
    the `const` or `val` sections of your program. You access fields of these symbolic
    record constants just as you would access the field of a record variable, using
    the dot operator. Because the object is a constant, you can specify the field
    of a record constant anywhere a constant of that field''s type is legal. You can
    also employ symbolic record constants as variable initializers. The following
    example demonstrates this:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在程序的 `const` 或 `val` 部分声明记录对象来创建显式记录常量。你可以像访问记录变量的字段一样访问这些符号记录常量的字段，使用点操作符。由于该对象是常量，你可以在任何该字段类型合法的常量位置指定记录常量的字段。你还可以将符号记录常量作为变量初始化器。以下示例演示了这一点：
- en: '[PRE158]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 4.27 Arrays of Records
  id: totrans-696
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.27 记录的数组
- en: 'It is a perfectly reasonable operation to create an array of records. To do
    so, you simply create a record type and then use the standard array declaration
    syntax. The following example demonstrates how you could do this:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 创建记录数组是一个完全合理的操作。为此，你只需要创建一个记录类型，然后使用标准的数组声明语法。以下示例演示了如何做到这一点：
- en: '[PRE159]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'To access an element of this array you use the standard array indexing techniques.
    Because *`recArray`* is a single-dimensional array, you''d compute the address
    of an element of this array using the formula *`baseAddress`* `+` *`index`*`*@size(`
    *`recElement`* `)`. For example, to access an element of *`recArray`* you''d use
    code like the following:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问该数组的元素，你可以使用标准的数组索引技巧。由于 *`recArray`* 是一个一维数组，你需要使用公式 *`baseAddress`* `+`
    *`index`*`*@size(` *`recElement`* `)` 来计算该数组元素的地址。例如，要访问 *`recArray`* 的一个元素，你可以使用如下代码：
- en: '[PRE160]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Note that the index specification follows the entire variable name; remember,
    this is assembly, not a high-level language (in a high-level language you'd probably
    use *`recArray`*`[i].`*`someField`*).
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，索引规范紧随整个变量名之后；记住，这是汇编语言，而不是高级语言（在高级语言中，你可能会使用 *`recArray`*`[i].`*`someField`*）。
- en: Naturally, you can create multidimensional arrays of records as well. You would
    use the row-major or column-major order functions to compute the address of an
    element within such records. The only thing that really changes (from the discussion
    of arrays) is that the size of each element is the size of the record object.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，你也可以创建多维记录数组。你将使用行主序或列主序的函数来计算该记录中某个元素的地址。唯一真正变化的地方（与数组的讨论相比）是每个元素的大小是记录对象的大小。
- en: '[PRE161]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 4.28 Arrays/Records as Record Fields
  id: totrans-704
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.28 数组/记录作为记录字段
- en: 'Records may contain other records or arrays as fields. Consider the following
    definition:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 记录可以包含其他记录或数组作为字段。考虑以下定义：
- en: '[PRE162]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'The definition above defines a single point with a 32-bit color component.
    When initializing an object of type `Pixel`, the first initializer corresponds
    to the `Pt` field, *not the* *`x-coordinate`* *field*. The following definition
    is incorrect:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的定义定义了一个带有32位颜色组件的单一点。在初始化`Pixel`类型的对象时，第一个初始化器对应于`Pt`字段，*而不是* *`x坐标`* *字段*。以下定义是错误的：
- en: '[PRE163]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The value of the first field (5) is not an object of type `point`. Therefore,
    the assembler generates an error when encountering this statement. HLA will allow
    you to initialize the fields of `Pixel` using declarations like the following:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字段（5）的值不是`point`类型的对象。因此，汇编程序在遇到这条语句时会生成一个错误。HLA 允许你使用如下声明来初始化`Pixel`的字段：
- en: '[PRE164]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Accessing `Pixel` fields is very easy. As in a high-level language, you use
    a single period to reference the `Pt` field and a second period to access the
    `x`, `y`, and `z` fields of `point`:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`Pixel`字段非常简单。就像在高级语言中一样，你使用一个句点来引用`Pt`字段，再用一个句点访问`point`的`x`、`y`和`z`字段：
- en: '[PRE165]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'You can also declare arrays as record fields. The following record creates
    a data type capable of representing an object with eight points (for example,
    a cube):'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将数组声明为记录字段。以下记录创建了一个数据类型，能够表示一个有八个点的对象（例如，一个立方体）：
- en: '[PRE166]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'This record allocates storage for eight different points. Accessing an element
    of the `Pts` array requires that you know the size of an object of type `point`
    (remember, you must multiply the index into the array by the size of one element,
    12 in this particular case). Suppose, for example, that you have a variable `Cube`
    of type `Object8`. You could access elements of the `Pts` array as follows:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 这个记录为八个不同的点分配存储空间。访问`Pts`数组中的一个元素要求你知道`point`类型对象的大小（记住，你必须将数组索引乘以单个元素的大小，在这个特定的例子中是12）。假设，例如，你有一个类型为`Object8`的变量`Cube`。你可以如下访问`Pts`数组中的元素：
- en: '[PRE167]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'The one unfortunate aspect of all this is that you must know the size of each
    element of the `Pts` array. Fortunately, you can rewrite the code above using
    `@size` as follows:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切的一个不幸之处在于，你必须知道`Pts`数组中每个元素的大小。幸运的是，你可以使用`@size`重写上面的代码，如下所示：
- en: '[PRE168]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Note in this example that the index specification (`[ebx]`) follows the whole
    object name even though the array is `Pts`, not `x`. Remember, the `[ebx]` specification
    is an indexed addressing mode, not an array index. Indexes always follow the entire
    name, so you do not attach them to the array component as you would in a high-level
    language like C/C++ or Pascal. This produces the correct result because addition
    is commutative, and the dot operator (as well as the index operator) corresponds
    to addition. In particular, the expression `Cube.Pts.x[ebx]` tells HLA to compute
    the sum of `Cube` (the base address of the object) plus the offset to the `Pts`
    field, plus the offset to the `x` field, plus the value of EBX. Technically, we're
    really computing offset(`Cube`) + offset(`Pts`) + EBX + offset(`x`), but we can
    rearrange this because addition is commutative.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个示例中，索引规格（`[ebx]`）跟随整个对象名称，即使数组是`Pts`，而不是`x`。请记住，`[ebx]`规格是一个索引寻址模式，而不是数组索引。索引总是跟随整个名称，因此你不会像在
    C/C++ 或 Pascal 等高级语言中那样将它们附加到数组组件上。这会产生正确的结果，因为加法是可交换的，点运算符（以及索引运算符）对应加法。特别是，表达式`Cube.Pts.x[ebx]`告诉
    HLA 计算`Cube`（对象的基址）加上`Pts`字段的偏移，再加上`x`字段的偏移，再加上 EBX 的值。从技术上讲，我们实际上是在计算`offset(Cube)`
    + `offset(Pts)` + EBX + `offset(x)`，但我们可以重新排列这个顺序，因为加法是可交换的。
- en: 'You can also define two-dimensional arrays within a record. Accessing elements
    of such arrays is no different than accessing any other two-dimensional array
    other than the fact that you must specify the array''s field name as the base
    address for the array. For example:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在记录中定义二维数组。访问此类数组的元素与访问任何其他二维数组没有不同，唯一的区别是你必须将数组的字段名称指定为数组的基地址。例如：
- en: '[PRE169]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: The code above uses the standard row-major calculation to index into a 4x5 array
    of double words. The only difference between this example and a standalone array
    access is the fact that the base address is `recVar.aField`.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码使用标准的行优先计算法来索引一个4x5的双字数组。这个示例与独立数组访问的唯一区别是基址是`recVar.aField`。
- en: 'There are two common ways to nest record definitions. As this section notes,
    you can create a record type in a `type` section and then use that type name as
    the data type of some field within a record (e.g., the `Pt:point` field in the
    `Pixel` data type above). It is also possible to declare a record directly within
    another record without creating a separate data type for that record; the following
    example demonstrates this:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套记录定义有两种常见方式。正如本节所述，你可以在`type`部分创建一个记录类型，然后将该类型名称作为记录中某个字段的数据类型（例如，上面`Pixel`数据类型中的`Pt:point`字段）。也可以在另一个记录内直接声明一个记录，而不为该记录创建单独的数据类型；以下示例演示了这一点：
- en: '[PRE170]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Generally, it's a better idea to create a separate type rather than embed records
    directly in other records, but nesting them is perfectly legal.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，创建一个单独的类型比直接将记录嵌入到其他记录中更好，但嵌套记录是完全合法的。
- en: 'If you have an array of records and one of the fields of that record type is
    an array, you must compute the indexes into the arrays independently of one another
    and then use the sum of these indexes as the ultimate index. The following example
    demonstrates how to do this:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个记录数组，并且其中一个字段是数组类型，你必须独立地计算每个数组的索引，然后将这些索引的和作为最终的索引。以下示例演示了如何做到这一点：
- en: '[PRE171]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Note the use of the base plus scaled indexed addressing mode to simplify this
    operation.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用基址加缩放索引寻址模式来简化此操作。
- en: 4.29 Aligning Fields Within a Record
  id: totrans-729
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.29 在记录中对齐字段
- en: 'To achieve maximum performance in your programs, or to ensure that HLA''s records
    properly map to records or structures in some high-level language, you will often
    need to be able to control the alignment of fields within a record. For example,
    you might want to ensure that a double-word field''s offset is an even multiple
    of 4\. You use the `align` directive to do this. The following example shows how
    to align some fields on important boundaries:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在程序中获得最佳性能，或者确保HLA的记录正确映射到某些高级语言中的记录或结构，你通常需要能够控制记录中字段的对齐。例如，你可能希望确保一个双字节字段的偏移量是4的偶数倍。你可以使用`align`指令来实现这一点。以下示例展示了如何将某些字段对齐到重要的边界：
- en: '[PRE172]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Whenever HLA encounters the `align` directive within a record declaration,
    it automatically adjusts the following field''s offset so that it is an even multiple
    of the value the `align` directive specifies. It accomplishes this by increasing
    the offset of that field, if necessary. In the example above, the fields would
    have the following offsets: `c:0`, `d:4`, `b:8`, `w:10`. Note that HLA inserts
    3 bytes of padding between `c` and `d`, and it inserts 1 byte of padding between
    `b` and `w`. It goes without saying that you should never assume that this padding
    is present. If you want to use those extra bytes, then you must declare fields
    for them.'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 每当HLA在记录声明中遇到`align`指令时，它会自动调整后续字段的偏移量，以确保它是`align`指令指定值的偶数倍。如果需要，它会通过增加该字段的偏移量来实现这一点。在上面的示例中，字段的偏移量将如下：`c:0`、`d:4`、`b:8`、`w:10`。注意，HLA在`c`和`d`之间插入了3个字节的填充，在`b`和`w`之间插入了1个字节的填充。不用说，你永远不应假设这些填充字节存在。如果你想使用这些额外的字节，那么你必须为它们声明字段。
- en: 'Note that specifying alignment within a record declaration does not guarantee
    that the field will be aligned on that boundary in memory; it only ensures that
    the field''s offset is a multiple of the value you specify. If a variable of type
    `PaddedRecord` starts at an odd address in memory, then the `d` field will also
    start at an odd address (because any odd address plus 4 is an odd address). If
    you want to ensure that the fields are aligned on appropriate boundaries in memory,
    you must also use the `align` directive before variable declarations of that record
    type. For example:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在记录声明中指定对齐并不能保证字段在内存中会对齐到指定的边界；它只是确保字段的偏移量是你指定的值的倍数。如果一个`PaddedRecord`类型的变量在内存中从一个奇数地址开始，那么`d`字段也将从一个奇数地址开始（因为任何奇数地址加4仍然是奇数地址）。如果你想确保字段在内存中对齐到合适的边界，你还必须在该记录类型的变量声明之前使用`align`指令。例如：
- en: '[PRE173]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: The value of the `align` operand should be an even value that is divisible by
    the largest `align` expression within the record type (4 is the largest value
    in this case, and it's already divisible by 2).
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '`align`操作数的值应是一个偶数，并且可以被记录类型中最大的`align`表达式整除（在本例中，4是最大值，且已能被2整除）。'
- en: 'If you want to ensure that the record''s size is a multiple of some value,
    then simply stick an `align` directive as the last item in the record declaration.
    HLA will emit an appropriate number of bytes of padding at the end of the record
    to fill it in to the appropriate size. The following example demonstrates how
    to ensure that the record''s size is a multiple of 4 bytes:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想确保记录的大小是某个值的倍数，那么只需在记录声明的最后加上一个 `align` 指令。HLA 会在记录的末尾填充适当数量的字节，以使其大小符合要求。以下示例演示了如何确保记录的大小是
    4 字节的倍数：
- en: '[PRE174]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: HLA provides some additional alignment directives for records that let you easily
    control the alignment of all fields within a record and the starting offset of
    the fields in a record. If you're interested in more information, please consult
    the HLA reference manual.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 提供了一些额外的对齐指令，用于记录类型，让你可以轻松控制记录内所有字段的对齐方式以及字段在记录中的起始偏移量。如果你对更多信息感兴趣，请查阅 HLA
    参考手册。
- en: 4.30 Pointers to Records
  id: totrans-739
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.30 指向记录的指针
- en: 'During execution, your program may refer to record objects indirectly using
    a pointer. When you use a pointer to access fields of a structure, you must load
    one of the 80x86''s 32-bit registers with the address of the desired record. Suppose
    you have the following variable declarations (assuming the `Object8` structure
    from an earlier section):'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行过程中，你的程序可能会通过指针间接引用记录对象。当你使用指针访问结构体的字段时，你必须将 80x86 的一个 32 位寄存器加载为所需记录的地址。假设你有以下变量声明（假设是前面部分提到的
    `Object8` 结构）：
- en: '[PRE175]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '`CubePtr` contains the address of (that is, it is a pointer to) the `Cube`
    object. To access the `Color` field of the `Cube` object, you could use an instruction
    like `mov( Cube.Color, eax );`. When accessing a field via a pointer, you first
    need to load the address of the object into a 32-bit register such as EBX. The
    instruction `mov( CubePtr, ebx );` will do the trick. After doing so, you can
    access fields of the `Cube` object using the `[ebx+offset]` addressing mode. The
    only problem is, "How do you specify which field to access?" Consider briefly
    the following *incorrect* code:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '`CubePtr` 包含（即指向）`Cube` 对象的地址。要访问 `Cube` 对象的 `Color` 字段，你可以使用类似 `mov( Cube.Color,
    eax )` 的指令。通过指针访问字段时，你首先需要将对象的地址加载到如 EBX 这样的 32 位寄存器中。指令 `mov( CubePtr, ebx );`
    就能完成这一步。完成后，你可以使用 `[ebx+offset]` 寻址模式来访问 `Cube` 对象的字段。唯一的问题是，“如何指定要访问哪个字段？”请简要考虑以下
    *错误的* 代码：'
- en: '[PRE176]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: Because field names are local to a structure and it's possible to reuse a field
    name in two or more structures, how does HLA determine which offset `Color` represents?
    When accessing structure members directly (e.g., `mov( Cube.Color, eax )`;), there
    is no ambiguity because `Cube` has a specific type that the assembler can check.
    `[ebx]`, on the other hand, can point at *anything*. In particular, it can point
    at any structure that contains a `Color` field. So the assembler cannot, on its
    own, decide which offset to use for the `Color` symbol.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 因为字段名是结构体内部的局部名称，且可能在两个或多个结构体中重用同一个字段名，HLA 如何确定 `Color` 表示的偏移量呢？当直接访问结构体成员时（例如，`mov(
    Cube.Color, eax )`；），没有歧义，因为 `Cube` 有一个特定的类型，汇编器可以进行检查。另一方面，`[ebx]` 可以指向 *任何东西*。特别是，它可以指向任何包含
    `Color` 字段的结构体。因此，汇编器不能单独决定 `Color` 符号使用哪个偏移量。
- en: 'HLA resolves this ambiguity by requiring that you explicitly supply a type.
    To do this, you must coerce `[ebx]` to type `Cube`. Once you do this, you can
    use the normal dot operator notation to access the `Color` field:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 通过要求你显式地提供类型来解决这个模糊性问题。为此，你必须将 `[ebx]` 强制转换为 `Cube` 类型。一旦完成这一步，你就可以使用正常的点操作符符号来访问
    `Color` 字段：
- en: '[PRE177]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'If you have a pointer to a record and one of that record''s fields is an array,
    the easiest way to access elements of that field is by using the base-plus-indexed
    addressing mode. To do so, you just load the pointer''s value into one register
    and compute the index into the array in a second register. Then you combine these
    two registers in the address expression. In the example above, the `Pts` field
    is an array of eight `point` objects. To access field `x` of the `i`th element
    of the `Cube.Pts` field, you''d use code like the following:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有指向记录的指针，并且该记录的某个字段是数组，访问该字段元素最简单的方法是使用基址加索引的寻址模式。为此，你只需将指针的值加载到一个寄存器中，并在第二个寄存器中计算数组的索引。然后，你将这两个寄存器组合在地址表达式中。在上面的例子中，`Pts`
    字段是一个包含八个 `point` 对象的数组。要访问 `Cube.Pts` 字段的第 `i` 个元素的 `x` 字段，你可以使用如下代码：
- en: '[PRE178]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'If you use a pointer to a particular record type frequently in your program,
    typing a coercion operator like `(type Object8 [ebx])` can get old very quickly.
    One way to reduce the typing needed to coerce EBX is to use a `text` constant.
    Consider the following statement:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在程序中频繁使用指向特定记录类型的指针，像`(type Object8 [ebx])`这样的强制类型转换操作符很快就会变得很麻烦。减少强制转换EBX输入量的一种方法是使用`text`常量。考虑以下语句：
- en: '[PRE179]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'With this statement at the beginning of your program, you can use `O8ptr` in
    place of the type coercion operator, and HLA will automatically substitute the
    appropriate text. With a text constant like the above, the former example becomes
    a little more readable and writable:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序开始时使用此语句，你可以用`O8ptr`代替类型强制转换操作符，HLA会自动替换为适当的文本。使用像上面这样的文本常量，前面的例子变得更具可读性和可写性：
- en: '[PRE180]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 4.31 Unions
  id: totrans-753
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.31 联合体
- en: 'A record definition assigns different offsets to each field in the record according
    to the size of those fields. This behavior is quite similar to the allocation
    of memory offsets in a `var` or `static` section. HLA provides a second type of
    structure declaration, the `union`, that does not assign different addresses to
    each object; instead, each field in a `union` declaration has the same offset—0\.
    The following example demonstrates the syntax for a `union` declaration:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 记录定义根据字段的大小为记录中的每个字段分配不同的偏移量。这种行为与在`var`或`static`段中分配内存偏移量非常相似。HLA提供了第二种结构声明类型——`union`，它不会为每个对象分配不同的地址；相反，`union`声明中的每个字段具有相同的偏移量——0。以下示例演示了`union`声明的语法：
- en: '[PRE181]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'You access the fields of a `union` exactly the same way you access the fields
    of a record: using dot notation and field names. The following is a concrete example
    of a `union` type declaration and a variable of the `union` type:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 你访问`union`的字段的方式与访问记录的字段完全相同：使用点符号和字段名称。以下是一个`union`类型声明及其`union`类型变量的具体示例：
- en: '[PRE182]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'The important thing to note about `union` objects is that all the fields of
    a `union` have the same offset in the structure. In the example above, the `number.u`,
    `number.i`, and `number.r` fields all have the same offset: 0\. Therefore, the
    fields of a `union` overlap in memory; this is very similar to the way the 80x86
    8-, 16-, and 32-bit registers overlap one another. Usually, you may access only
    one field of a `union` at a time; that is, you do not manipulate separate fields
    of a particular `union` variable concurrently because writing to one field overwrites
    the other fields. In the example above, any modification of `number.u` would also
    change `number.i` and `number.r`.'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`union`对象需要注意的重要一点是，`union`的所有字段在结构中具有相同的偏移量。在上面的例子中，`number.u`、`number.i`和`number.r`字段的偏移量都是相同的：0。因此，`union`的字段在内存中是重叠的；这与80x86的8位、16位和32位寄存器之间的重叠方式非常相似。通常，你一次只能访问`union`的一个字段；也就是说，你不能同时操作一个特定`union`变量的多个字段，因为写入一个字段会覆盖其他字段。在上面的例子中，任何对`number.u`的修改都会改变`number.i`和`number.r`。
- en: 'Programmers typically use unions for two different reasons: to conserve memory
    or to create aliases. Memory conservation is the intended use of this data structure
    facility. To see how this works, let''s compare the `numeric union` above with
    a corresponding record type.'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员通常出于两种不同的原因使用联合体：节省内存或创建别名。节省内存是这种数据结构的主要用途。为了了解这如何运作，我们可以将上面的`numeric union`与相应的记录类型进行比较。
- en: '[PRE183]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: If you declare a variable, say `n`, of type `numericRec`, you access the fields
    as `n.i`, `n.u`, and `n.r` exactly as though you had declared the variable to
    be type `numeric`. The difference between the two is that `numericRec` variables
    allocate separate storage for each field of the record, whereas `numeric` (union)
    objects allocate the same storage for all fields. Therefore, `@size(numericRec)`
    is 16 because the record contains two double-word fields and a quad word (`real64`)
    field. `@size(numeric)`, however, is 8\. This is because all the fields of a `union`
    occupy the same memory locations, and the size of a `union` object is the size
    of the largest field of that object (see [Figure 4-11](ch04s31.html#layout_of_a_union_versus_a_record_variab
    "Figure 4-11. Layout of a union versus a record variable")).
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你声明一个类型为`numericRec`的变量，比如`n`，你可以像访问`numeric`类型的变量一样访问其字段，分别为`n.i`、`n.u`和`n.r`。两者的区别在于，`numericRec`变量为记录的每个字段分配了独立的存储空间，而`numeric`（联合体）对象则为所有字段分配了相同的存储空间。因此，`@size(numericRec)`的大小为16，因为记录包含了两个双字字段和一个四字字段（`real64`）。而`@size(numeric)`的大小为8，这是因为所有`union`的字段都占用了相同的内存位置，`union`对象的大小是该对象中最大字段的大小（参见[图4-11](ch04s31.html#layout_of_a_union_versus_a_record_variab
    "图4-11. 联合体与记录变量的布局")）。
- en: '![Layout of a union versus a record variable](tagoreillycom20100401nostarchimages577999.png)'
  id: totrans-762
  prefs: []
  type: TYPE_IMG
  zh: '![联合体与记录变量的布局](tagoreillycom20100401nostarchimages577999.png)'
- en: Figure 4-11. Layout of a `union` versus a `record` variable
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-11. `union`与`record`变量的布局
- en: 'In addition to conserving memory, programmers often use unions to create aliases
    in their code. As you may recall, an alias is a different name for the same memory
    object. Aliases are often a source of confusion in a program, so you should use
    them sparingly; sometimes, however, using an alias can be quite convenient. For
    example, in some section of your program you might need to constantly use type
    coercion to refer to an object using a different type. Although you can use an
    HLA `text` constant to simplify this process, another way to do this is to use
    a `union` variable with the fields representing the different types you want to
    use for the object. As an example, consider the following code:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 除了节省内存外，程序员通常使用联合体来创建代码中的别名。你可能还记得，别名是同一内存对象的不同名称。别名通常会导致程序中的混淆，因此你应该谨慎使用；然而，有时使用别名会非常方便。例如，在程序的某些部分，你可能需要不断使用类型转换来通过不同类型引用一个对象。虽然你可以使用HLA的`text`常量来简化这一过程，但另一种方法是使用一个`union`变量，其字段表示你希望用于该对象的不同类型。以下是一个示例代码：
- en: '[PRE184]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: With a declaration like the above, you can manipulate an `uns32` object by accessing
    `v.u`. If, at some point, you need to treat the L.O. byte of this `uns32` variable
    as a character, you can do so by simply accessing the `v.c` variable, for example,
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 通过如上声明，你可以通过访问`v.u`来操作一个`uns32`对象。如果某个时候，你需要将这个`uns32`变量的低字节当作字符来处理，你可以通过简单地访问`v.c`变量来实现，例如，
- en: '[PRE185]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: You can use unions exactly the same way you use records in an HLA program. In
    particular, `union` declarations may appear as fields in records, `record` declarations
    may appear as fields in unions, array declarations may appear within unions, you
    can create arrays of unions, and so on.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 在HLA程序中，你可以像使用记录一样使用联合体。特别是，`union`声明可以作为记录中的字段，`record`声明可以作为联合体中的字段，数组声明可以出现在联合体内部，你还可以创建联合体数组，等等。
- en: 4.32 Anonymous Unions
  id: totrans-769
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.32 匿名联合体
- en: 'Within a `record` declaration you can place a `union` declaration without specifying
    a fieldname for the `union` object. The following example demonstrates the syntax
    for this:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 在`record`声明中，你可以放置一个`union`声明，而无需为`union`对象指定字段名。以下示例演示了这种语法：
- en: '[PRE186]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Whenever an anonymous union appears within a `record` you can access the fields
    of the `union` as though they were direct fields of the `record`. In the example
    above, for example, you would access `v`''s `u` and `i` fields using the syntax
    `v.u` and `v.i`, respectively. The `u` and `i` fields have the same offset in
    the record (8, because they follow a `real64` object). The fields of `v` have
    the following offsets from `v`''s base address:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 每当匿名联合体出现在`record`中时，你可以像直接访问`record`字段一样访问`union`的字段。例如，在上面的例子中，你可以分别使用`v.u`和`v.i`的语法来访问`v`的`u`和`i`字段。`u`和`i`字段在记录中的偏移量相同（为8，因为它们位于一个`real64`对象之后）。`v`的字段相对于`v`的基地址具有以下偏移量：
- en: '[PRE187]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '`@size(v)` is 16 because the `u` and `i` fields consume only 4 bytes.'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '`@size(v)`的大小为16，因为`u`和`i`字段只占用4个字节。'
- en: HLA also allows anonymous records within unions. Please see the HLA documentation
    for more details, though the syntax and usage are identical to anonymous unions
    within records.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 还允许在联合体中使用匿名记录。有关更多详细信息，请参阅 HLA 文档，尽管语法和用法与记录中的匿名联合体相同。
- en: 4.33 Variant Types
  id: totrans-776
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.33 变体类型
- en: One big use of unions in programs is to create *variant* types. A variant variable
    can change its type dynamically while the program is running. A variant object
    can be an integer at one point in the program, switch to a string at a different
    part of the program, and then change to a real value at a later time. Many very-high-level
    language (VHLL) systems use a dynamic type system (that is, variant objects) to
    reduce the overall complexity of the program; indeed, proponents of many VHLLs
    insist that the use of a dynamic typing system is one of the reasons you can write
    complex programs with so few lines of code using those languages. Of course, if
    you can create variant objects in a VHLL, you can certainly do it in assembly
    language. In this section we'll look at how we can use the `union` structure to
    create variant types.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 联合体在程序中的一个重要用途是创建*变体*类型。一个变体变量可以在程序运行时动态改变其类型。一个变体对象可以在程序中的某一时刻是一个整数，之后在程序的另一个部分切换为字符串，稍后又变为实数值。许多高级语言（VHLL）系统使用动态类型系统（即变体对象）来减少程序的整体复杂性；实际上，许多
    VHLL 的支持者坚持认为，使用动态类型系统是你能用少量代码编写复杂程序的原因之一。当然，如果你能够在 VHLL 中创建变体对象，那么在汇编语言中当然也能做到。在本节中，我们将看看如何使用`union`结构来创建变体类型。
- en: 'At any one given instant during program execution, a variant object has a specific
    type, but under program control the variable can switch to a different type. Therefore,
    when the program processes a variant object, it must use an `if` statement or
    `switch` statement (or something similar) to execute different instructions based
    on the object''s current type. Very-high-level languages do this transparently.
    In assembly language you will have to provide the code to test the type yourself.
    To achieve this, the variant type needs some additional information beyond the
    object''s value. Specifically, the variant object needs a field that specifies
    the current type of the object. This field (often known as the `tag` field) is
    an enumerated type or integer that specifies the object''s type at any given instant.
    The following code demonstrates how to create a variant type:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序执行的任何时刻，变体对象都有一个特定的类型，但在程序控制下，变量可以切换到不同的类型。因此，当程序处理变体对象时，必须使用`if`语句或`switch`语句（或类似的语句）根据对象的当前类型执行不同的指令。高级语言会透明地做到这一点。在汇编语言中，你必须提供代码来测试类型。为了实现这一点，变体类型需要比对象的值更多的附加信息。具体而言，变体对象需要一个字段来指定对象的当前类型。这个字段（通常称为`tag`字段）是一个枚举类型或整数，用于指定对象在任何给定时刻的类型。以下代码演示了如何创建变体类型：
- en: '[PRE188]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: The program would test the `v.tag` field to determine the current type of the
    `v` object. Based on this test, the program would manipulate the `v.i`, `v.u`,
    or `v.r` field.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将测试`v.tag`字段以确定`v`对象的当前类型。根据此测试，程序将操作`v.i`、`v.u`或`v.r`字段。
- en: Of course, when operating on variant objects, the program's code must constantly
    be testing the `tag` field and executing a separate sequence of instructions for
    `uns32`, `int32`, or `real64` values. If you use the variant fields often, it
    makes a lot of sense to write procedures to handle these operations for you (e.g.,
    *`vadd`*, *`vsub`*, *`vmul`*, and *`vdiv`*).
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在操作变体对象时，程序的代码必须不断测试`tag`字段，并针对`uns32`、`int32`或`real64`值执行一系列独立的指令。如果你经常使用变体字段，那么编写程序来处理这些操作是非常有意义的（例如，*`vadd`*、*`vsub`*、*`vmul`*和*`vdiv`*）。
- en: 4.34 Namespaces
  id: totrans-782
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.34 命名空间
- en: One really nice feature of records and unions is that the field names are local
    to a given `record` or `union` declaration. That is, you can reuse field names
    in different records or unions. This is an important feature of HLA because it
    helps avoid *namespace pollution*. Namespace pollution occurs when you use up
    all the "good" names within your program and you have to start creating nondescriptive
    names for objects because you've already used the most appropriate name for something
    else. We use the term *namespace* to describe how HLA associates names with a
    particular object. The field names of a `record` have a namespace that is limited
    to objects of that record type. HLA provides a generalization of this namespace
    mechanism that lets you create arbitrary namespaces. These namespace objects let
    you shield the names of constants, types, variables, and other objects so their
    names do not interfere with other declarations in your program.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 记录（`record`）和联合体（`union`）的一个非常好的特点是，字段名是局部的，仅在给定的`record`或`union`声明中有效。也就是说，你可以在不同的记录或联合体中重复使用字段名。这是HLA的一个重要特点，因为它有助于避免*命名空间污染*。命名空间污染发生在你用尽程序中的所有“好”名字时，你不得不开始为对象创建不具描述性的名称，因为你已经把最合适的名称用在了其他东西上。我们使用*命名空间*一词来描述HLA如何将名称与特定对象关联。`record`的字段名有一个命名空间，该命名空间仅限于该记录类型的对象。HLA提供了这一命名空间机制的推广，允许你创建任意命名空间。这些命名空间对象可以让你保护常量、类型、变量和其他对象的名称，使它们的名称不会干扰程序中其他声明的命名。
- en: 'An HLA `namespace` section encapsulates a set of generic declarations in much
    the same way that a `record` encapsulates a set of variable declarations. A `namespace`
    declaration takes the following form:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 一个HLA的`namespace`部分封装了一组通用声明，方式与`record`封装一组变量声明类似。`namespace`声明的形式如下：
- en: '[PRE189]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: The *`name`* identifier provides the name for the `namespace`. The identifier
    after the `end` clause must exactly match the identifier after `namespace`. Note
    that a `namespace` declaration section is a section unto itself. It does not have
    to appear in a `type` or `var` section. A `namespace` may appear anywhere one
    of the HLA declaration sections is legal. A program may contain any number of
    `namespace` declarations; in fact, the namespace identifiers don't even have to
    be unique, as you will soon see.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '*`name`*标识符为`namespace`提供了名称。`end`语句后的标识符必须与`namespace`后的标识符完全匹配。请注意，`namespace`声明部分本身就是一个单独的部分。它不需要出现在`type`或`var`部分中。`namespace`可以出现在任何一个HLA声明部分合法的位置。一个程序可以包含任意数量的`namespace`声明；实际上，命名空间标识符甚至不需要唯一，正如你很快会看到的那样。'
- en: 'The declarations that appear between the `namespace` and `end` clauses are
    all the standard HLA declaration sections except that you cannot nest `namespace`
    declarations. You may, however, put `const`, `val`, `type`, `static`, `readonly`,
    and `storage` sections within a `namespace`.^([[67](#ftn.CHP-4-FN-21)]) The following
    code provides an example of a typical `namespace` declaration in an HLA program:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 在`namespace`和`end`语句之间出现的声明都是标准的HLA声明部分，除了你不能在`namespace`声明中嵌套其他`namespace`声明。不过，你可以在`namespace`内放置`const`、`val`、`type`、`static`、`readonly`和`storage`部分。^([[67](#ftn.CHP-4-FN-21)])
    以下代码提供了HLA程序中典型的`namespace`声明示例：
- en: '[PRE190]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'To access the fields of a namespace you use the same dot notation that records
    and unions use. For example, to access the fields of `myNames` outside of the
    namespace, you''d use the following identifiers:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问命名空间的字段，你使用与记录和联合体相同的点符号。例如，要在命名空间外访问`myNames`的字段，你可以使用以下标识符：
- en: '[PRE191]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'This example also demonstrates an important point about `namespace` declarations:
    Within a namespace you may reference other identifiers in that same `namespace`
    declaration without using the dot notation. For example, the `i` field above uses
    type `integer` from the `myNames` namespace without the `mynames`. prefix.'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例还展示了一个关于`namespace`声明的重要点：在一个命名空间内，你可以引用同一命名空间声明中的其他标识符，而无需使用点符号。例如，上面的`i`字段使用了来自`myNames`命名空间的`integer`类型，而不需要使用`mynames.`前缀。
- en: 'What is not obvious from the example above is that `namespace` declarations
    create a clean symbol table whenever you open up a namespace. The only external
    symbols that HLA recognizes in a `namespace` declaration are the predefined type
    identifiers (e.g., `int32`, `uns32`, and `char`). HLA does not recognize any symbols
    you''ve declared outside the namespace while it is processing your `namespace`
    declaration. This creates a problem if you want to use symbols from outside the
    namespace when declaring other symbols inside the namespace. For example, suppose
    the type `integer` had been defined outside `myNames` as follows:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的示例中看不出的一点是，`namespace`声明每次打开命名空间时都会创建一个干净的符号表。HLA在`namespace`声明中识别的唯一外部符号是预定义的类型标识符（例如，`int32`、`uns32`和`char`）。HLA在处理`namespace`声明时不会识别你在命名空间外部声明的任何符号。这会导致一个问题：如果你希望在声明命名空间内部的其他符号时使用命名空间外部的符号。例如，假设`integer`类型在`myNames`外部被定义如下：
- en: '[PRE192]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'If you were to attempt to compile this code, HLA would complain that the symbol
    `integer` is undefined. Clearly `integer` is defined in this program, but HLA
    hides all external symbols when creating a namespace so that you can reuse (and
    redefine) those symbols within the namespace. Of course, this doesn''t help much
    if you actually want to use a name that you''ve defined outside `myNames` within
    that namespace. HLA provides a solution to this problem: the `@global:` operator.
    If, within a `namespace` declaration section, you prefix a name with `@global:`,
    then HLA will use the global definition of that name rather than the local definition
    (if a local definition even exists). To correct the problem in the previous example,
    you''d use the following code:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试编译这段代码，HLA会抱怨符号`integer`未定义。显然`integer`在这个程序中已定义，但HLA在创建命名空间时会隐藏所有外部符号，这样你就可以在命名空间内重用（并重新定义）这些符号。当然，如果你真的想在那个命名空间内使用在`myNames`外部定义的名称，这并不会有什么帮助。HLA提供了一个解决这个问题的方案：`@global:`运算符。如果在`namespace`声明部分中，你用`@global:`前缀加上一个名称，那么HLA将使用该名称的全局定义，而不是局部定义（如果局部定义存在）。为了修复上面示例中的问题，你可以使用以下代码：
- en: '[PRE193]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: With the `@global:` prefix, the `i` variable will be type `int32` even if a
    different declaration of `integer` appears within the `myNames` namespace.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@global:`前缀时，即使在`myNames`命名空间中出现了不同的`integer`声明，`i`变量的类型仍将是`int32`。
- en: You cannot nest `namespace` declarations. Logically, there doesn't seem to be
    any need for this, hence its omission from the HLA language.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能嵌套`namespace`声明。从逻辑上看，这似乎没有必要，因此在HLA语言中省略了这一功能。
- en: 'You can have multiple `namespace` declarations in the same program that use
    the same namespace identifier. For example:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在同一个程序中有多个使用相同命名空间标识符的`namespace`声明。例如：
- en: '[PRE194]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: When HLA encounters a second `namespace` declaration for a given identifier,
    it simply appends the declarations in the second group to the end of the symbol
    list it created for the first group. Therefore, after processing the two `namespace`
    declarations, the `ns` namespace would contain the set of all symbols you've declared
    in both `namespace` blocks.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 当HLA遇到一个已定义标识符的第二个`namespace`声明时，它会将第二组声明附加到为第一组创建的符号列表的末尾。因此，处理完这两个`namespace`声明后，`ns`命名空间将包含你在两个`namespace`块中声明的所有符号。
- en: Perhaps the most common use of namespaces is in library modules. If you create
    a set of library routines to use in various projects or distribute to others,
    you have to be careful about the names you choose for your functions and other
    objects. If you use common names like `get` and `put`, the users of your module
    will complain when your names collide with theirs. An easy solution is to put
    all your code in a `namespace` block. Then the only name you have to worry about
    is the `namespace` identifier itself. This is the only name that will collide
    with other users' identifiers. This can happen, but it's much less likely to happen
    than if you don't use a namespace and your library module introduces dozens, if
    not hundreds, of new names into the global namespace.^([[68](#ftn.CHP-4-FN-22)])
    The HLA Standard Library provides many good examples of namespaces in use. The
    HLA Standard Library defines several namespaces like `stdout`, `stdin`, `str`,
    `cs`, and `chars`. You refer to functions in these namespaces using names like
    `stdout.put`, `stdin.get`, `cs.intersection`, `str.eq`, and `chars.toUpper`. The
    use of namespaces in the HLA Standard Library prevents conflicts with similar
    names in your own programs.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间最常见的用途可能是在库模块中。如果你创建一组库例程供多个项目使用或分发给他人，你需要小心选择函数和其他对象的名称。如果你使用像`get`和`put`这样的常见名称，当你的名称与用户的名称发生冲突时，他们会抱怨。一个简单的解决方案是将所有代码放在一个`namespace`块中。这样，你唯一需要担心的名称就是`namespace`标识符本身。这是唯一可能与其他用户的标识符发生冲突的名称。虽然这种情况有可能发生，但如果你不使用命名空间，并且你的库模块将数十个，甚至数百个新名称引入全局命名空间，冲突发生的概率会大大增加。^([[68](#ftn.CHP-4-FN-22)])
    HLA标准库提供了许多命名空间使用的好例子。HLA标准库定义了多个命名空间，如`stdout`、`stdin`、`str`、`cs`和`chars`。你可以通过类似`stdout.put`、`stdin.get`、`cs.intersection`、`str.eq`和`chars.toUpper`这样的名称来引用这些命名空间中的函数。HLA标准库中命名空间的使用防止了与你自己的程序中的类似名称发生冲突。
- en: '* * *'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[67](#CHP-4-FN-21)]) Procedure declarations, the subject of [Chapter 5](ch05.html
    "Chapter 5. PROCEDURES AND UNITS"), are also legal within a `namespace` declaration
    section.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[67](#CHP-4-FN-21)]) 过程声明，作为[第5章](ch05.html "第5章. 过程与单元")的主题，也是`namespace`声明部分中的合法内容。
- en: ^([[68](#CHP-4-FN-22)]) The global namespace is the global section of your program.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[68](#CHP-4-FN-22)]) 全局命名空间是你程序的全局部分。
- en: 4.35 Dynamic Arrays in Assembly Language
  id: totrans-805
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.35 汇编语言中的动态数组
- en: One problem with arrays as this chapter describes them is that their size is
    static. That is, the number of elements in all of the examples was chosen when
    writing the program; it was not selected while the program runs (that is, dynamically).
    Alas, sometimes you simply don't know how big an array needs to be when you're
    writing the program; you can only determine the size of the array while the program
    is running. This section describes how to allocate storage for arrays dynamically
    so you can set their size at runtime.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所描述的数组的一个问题是它们的大小是静态的。也就是说，所有示例中的元素数量是在编写程序时选择的；而不是在程序运行时（即动态地）选择的。遗憾的是，有时你在编写程序时根本不知道一个数组需要多大；只能在程序运行时确定数组的大小。本节描述了如何动态分配数组的存储空间，以便你可以在运行时设置数组的大小。
- en: Allocating storage for a single-dimensional array, and accessing elements of
    that array, is a nearly trivial task at runtime. All you need to do is call the
    HLA Standard Library `mem.alloc` routine, specifying the size of the array in
    bytes. `mem.alloc` will return a pointer to the base address of the new array
    in the EAX register. Typically, you would save this address in a pointer variable
    and use that value as the base address of the array in all future array accesses.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 为一维数组分配存储空间并访问该数组的元素，在运行时几乎是一个微不足道的任务。你所需要做的就是调用HLA标准库中的`mem.alloc`例程，并指定数组的大小（以字节为单位）。`mem.alloc`将返回一个指向新数组基地址的指针，该指针存储在EAX寄存器中。通常，你会将这个地址保存在一个指针变量中，并在所有后续的数组访问中使用这个地址作为数组的基地址。
- en: To access an element of a single-dimensional dynamic array, you would generally
    load the base address into a register and compute the index in a second register.
    Then you could use the base-indexed addressing mode to access elements of that
    array. This is not a whole lot more work than accessing elements of a statically
    allocated array. The following code fragment demonstrates how to allocate and
    access elements of a single-dimensional dynamic array.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问一维动态数组的元素，你通常需要将基地址加载到一个寄存器中，并在第二个寄存器中计算索引。然后，你可以使用基址索引寻址模式来访问该数组的元素。这与访问静态分配数组元素的工作量没有太大区别。以下代码片段演示了如何分配和访问一维动态数组的元素。
- en: '[PRE195]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Dynamically allocating storage for a multidimensional array is fairly straightforward.
    The number of elements in a multidimensional array is the product of all the dimension
    values; for example, a 4x5 array has 20 elements. So if you get the bounds for
    each dimension from the user, all you need to do is compute the product of all
    of these bound values and multiply the result by the size of a single element.
    This computes the total number of bytes in the array, the value that `mem.alloc`
    expects.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 为多维数组动态分配存储是相当直接的。多维数组中的元素数量是所有维度值的乘积；例如，一个4x5的数组有20个元素。所以如果你从用户那里获得每个维度的边界，你需要做的就是计算所有这些边界值的乘积，并将结果乘以单个元素的大小。这将计算出数组的总字节数，这是`mem.alloc`期望的值。
- en: Accessing elements of multidimensional arrays is a little more problematic.
    The problem is that you need to keep the dimension information (that is, the bounds
    on each dimension) around because these values are needed when computing the row-major
    (or column-major) index into the array.^([[69](#ftn.CHP-4-FN-23)]) The conventional
    solution is to store these bounds into a static array (generally you know the
    *arity*, or number of dimensions, at compile time, so it is possible to statically
    allocate storage for this array of dimension bounds). This array of dynamic array
    bounds is known as a *dope vector*. The following code fragment shows how to allocate
    storage for a two-dimensional dynamic array using a simple dope vector.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 访问多维数组的元素稍微有点复杂。问题在于你需要保留维度信息（即每个维度的边界），因为在计算行主序（或列主序）索引时，这些值是必需的。^([[69](#ftn.CHP-4-FN-23)])
    常见的解决方案是将这些边界存储在一个静态数组中（通常在编译时你就知道*维度数*，因此可以为这个维度边界的数组分配静态存储）。这个动态数组边界数组被称为*哑向量*。下面的代码片段展示了如何使用一个简单的哑向量来为一个二维动态数组分配存储。
- en: '[PRE196]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '* * *'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[69](#CHP-4-FN-23)]) Technically, you don't need the value of the leftmost
    dimension bound to compute an index into the array; however, if you want to check
    the index bounds using the `bound` instruction (or some other technique), you
    will need this value around at runtime as well.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[69](#CHP-4-FN-23)]) 从技术上讲，你不需要最左边维度边界的值来计算数组中的索引；然而，如果你想使用`bound`指令（或其他方法）检查索引边界，你需要在运行时保留这个值。
- en: 4.36 For More Information
  id: totrans-815
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.36 更多信息
- en: In the electronic edition of this book, which you'll find at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/), you will find additional
    information about data types. The HLA Standard Library documentation describes
    the HLA arrays package that provides support for dynamically allocated (and statically
    allocated) arrays, indexing into arrays, and many other array options. You should
    consult the HLA stdlib documentation for more details about this array package.
    For additional information about data structure representation in memory, you
    should consider reading my book *Write Great Code, Volume 1* (No Starch Press,
    2004). For an in-depth discussion of data types, you should consult a textbook
    on data structures and algorithms.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的电子版中，你可以在[http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)或[http://www.artofasm.com/](http://www.artofasm.com/)找到关于数据类型的额外信息。HLA标准库文档描述了HLA数组包，提供了对动态分配（以及静态分配）数组的支持，数组索引及许多其他数组选项。你应当参考HLA标准库文档以获取更多关于该数组包的详细信息。关于内存中数据结构表示的更多信息，你可以考虑阅读我的书《*写出伟大的代码，第1卷*》（No
    Starch Press，2004）。关于数据类型的深入讨论，你应当查阅有关数据结构与算法的教材。
