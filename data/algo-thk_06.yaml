- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '6'
- en: SHORTEST PATHS IN WEIGHTED GRAPHS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 加权图中的最短路径
- en: '![Image](../images/common1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common1.jpg)'
- en: This chapter generalizes what we learned in [Chapter 5](ch05.xhtml) about finding
    shortest paths. In [Chapter 5](ch05.xhtml), our focus was on finding the minimum
    number of moves needed to solve a problem. Now, what if we care not about the
    minimum number of moves but about the minimum amount of time or distance? Think
    about using a GPS app to get home. Maybe there’s a route to get home using only
    one street that takes 10 minutes. Maybe there’s another way that involves using
    three streets that takes only eight minutes in total. We might prefer using the
    three streets, since they save us time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章对我们在[第5章](ch05.xhtml)中学习的最短路径问题进行了推广。在[第5章](ch05.xhtml)中，我们的重点是找出解决问题所需的最小步数。现在，假设我们关心的不是最小步数，而是最短时间或距离？想象一下使用GPS应用程序回家。也许有一条只需要10分钟的单行道回家。也许有另一条路线，虽然需要经过三条街，但总共只需8分钟。我们可能会选择走这三条街，因为它们节省了时间。
- en: 'In this chapter, we’ll learn *Dijkstra’s algorithm* for finding shortest paths
    in weighted graphs. We’ll use it to determine the number of mice that can escape
    a maze within a time limit and the number of shortest paths between someone’s
    home and their grandma’s house. I chose that grandma example in particular to
    reprise a discovery we made in [Chapter 5](ch05.xhtml): that, suitably modified,
    algorithms such as BFS and Dijkstra’s can do much more than “find the shortest
    path.” We’re learning algorithms—deservedly famous ones—but also stocking up on
    flexible problem-solving tools. Let’s go!'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 *Dijkstra 算法*，用于在加权图中找到最短路径。我们将使用它来确定在时间限制内能够逃脱迷宫的实验鼠数量，以及从某人家到他们祖母家的最短路径数量。我特别选择了那个关于祖母的例子，来重温我们在[第5章](ch05.xhtml)中发现的一个结论：经过适当修改，像BFS和Dijkstra这样的算法能够做的不仅仅是“找到最短路径”。我们正在学习算法——这些算法理应广为人知——同时也在积累灵活的问题解决工具。让我们开始吧！
- en: 'Problem 1: Mice Maze'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题 1：实验鼠迷宫
- en: This is UVa problem `1112`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 UVa 问题 `1112`。
- en: '*The Problem*'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题*'
- en: 'A maze consists of cells and passages. Each passage leads from some cell *a*
    to some other cell *b*, and it takes *t* time units to walk the passage. For example,
    it may take 5 time units to walk from Cell 2 to Cell 4\. Now for the passage going
    the other way: it may take 70 time units to walk from Cell 4 to Cell 2, or there
    may be no passage at all from Cell 4 to Cell 2—the *a* *→* *b* and *b* *→* *a*
    passages are independent. One of the cells of the maze is designated as the exit
    cell.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个迷宫由单元格和通道组成。每条通道从某个单元格 *a* 到另一个单元格 *b*，并且行走这条通道需要 *t* 时间单位。例如，从单元格2到单元格4可能需要5时间单位。现在考虑反向通道：从单元格4到单元格2可能需要70时间单位，或者从单元格4到单元格2可能根本没有通道——*a*
    *→* *b* 和 *b* *→* *a* 通道是独立的。迷宫中的一个单元格被指定为出口单元格。
- en: There’s a lab mouse in each cell, including the exit cell. The mice have been
    trained to walk to the exit cell in as little time as possible. Our task is to
    determine the number of mice that can reach the exit cell within a specified time
    limit.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单元格中都有一只实验鼠，包括出口单元格。实验鼠已经被训练成尽可能快速地走到出口单元格。我们的任务是确定在规定时间内能够到达出口单元格的实验鼠数量。
- en: Input
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: 'The first line of input gives the number of test cases and is followed by a
    blank line. There’s also a blank line between each pair of test cases. Each test
    case consists of the following lines:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行输入给出测试用例的数量，后面跟着一个空行。每一对测试用例之间也有一个空行。每个测试用例包含以下几行：
- en: A line containing *n*, the number of cells in the maze. Cells are numbered 1
    to *n*; *n* is at most 100.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含 *n*，迷宫中的单元格数量。单元格编号从 1 到 *n*；*n* 至多为 100。
- en: A line containing *e*, the exit cell. *e* is between 1 and *n*.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含 *e*，出口单元格。*e* 介于 1 和 *n* 之间。
- en: A line containing *t*, the integer time limit for the mice to get to the exit
    cell. *t* is at least zero.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含 *t*，实验鼠到达出口单元格的整数时间限制。*t* 至少为零。
- en: A line containing *m*, the number of passages in the maze.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含 *m*，迷宫中通道的数量。
- en: '*m* lines, each describing a passage in the maze. Each such line contains three
    integers: the first cell *a* (between 1 and *n*), the second cell *b* (between
    1 and *n*), and the time (at least zero) it takes to walk from *a* to *b*.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*m* 行，每行描述迷宫中的一条通道。每行包含三个整数：第一个单元格 *a*（介于1和*n*之间），第二个单元格 *b*（介于1和*n*之间），以及从
    *a* 到 *b* 行走所需的时间（至少为零）。'
- en: Output
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: For each test case, output the number of mice that reach the exit cell *e* within
    the time limit *t*. The output for each test case is separated from the next by
    a blank line.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个测试用例，输出在时间限制*t*内到达出口单元格*e*的老鼠数量。每个测试用例的输出之间由一个空行分隔。
- en: The time limit for solving the test cases—for our code, not the mice—is three
    seconds.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试用例的时间限制——是针对我们的代码，而不是老鼠——是三秒钟。
- en: '*Moving On from BFS*'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*从BFS继续*'
- en: There are key similarities between the Mice Maze problem and the three problems
    in [Chapter 5](ch05.xhtml). We can model the Mice Maze as a graph, where the nodes
    are the maze cells and the edges are the passages. The graph is directed (as in
    the Rope Climb problem), because a passage from Cell *a* to Cell *b* tells us
    nothing about the possible passage from *b* to *a*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 老鼠迷宫问题与第[5章](ch05.xhtml)中的三个问题有一些关键的相似之处。我们可以将老鼠迷宫建模为一个图，其中节点是迷宫单元格，边是通道。这个图是有向的（就像绳索攀爬问题那样），因为从单元格*a*到单元格*b*的通道并不能告诉我们从*b*到*a*的通道是否存在。
- en: The workhorse for the three problems in [Chapter 5](ch05.xhtml) was breadth-first
    search. The killer feature of BFS is that it finds shortest paths. Not coincidentally,
    we want shortest paths for our Mice Maze, too. They’ll let us determine how long
    it takes each mouse to reach the exit cell.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](ch05.xhtml)中的三个问题的核心算法是广度优先搜索（BFS）。BFS的杀手特性是它能够找到最短路径。巧合的是，我们在老鼠迷宫中也需要最短路径。它们能帮助我们确定每只老鼠到达出口单元格所需的时间。'
- en: 'However, all this talk of similarities is obscuring a crucial difference: the
    Mice Maze graph is *weighted*: on each edge, we have an arbitrary integer giving
    the time required to traverse that edge. See [Figure 6-1](ch06.xhtml#ch06fig01)
    for an example.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有关于相似性的讨论掩盖了一个关键的区别：老鼠迷宫图是*加权的*：每条边上都有一个任意的整数，表示穿越该边所需的时间。具体例子请参见[图6-1](ch06.xhtml#ch06fig01)。
- en: '![Image](../images/ch06fig01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/ch06fig01.jpg)'
- en: '*Figure 6-1: The Mice Maze graph*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：老鼠迷宫图*'
- en: 'Let’s say that the exit cell is Cell 4\. What’s the minimum amount of time
    taken by the mouse in Cell 1 to get to Cell 4? There’s an edge directly from Cell
    1 to Cell 4, so if we were counting edges (as in BFS), then the answer would be
    `1`. However, we are not interested in the number of edges here: instead, we want
    the shortest path in terms of the sum of its edge weights. The weight of the 1
    *→* 4 edge is 45\. That is not the shortest path. The shortest path from Cell
    1 to Cell 4 is the three-edge path that goes from Cell 1 to Cell 3 (six units
    of time), then from Cell 3 to Cell 2 (two units of time), and finally from Cell
    2 to Cell 4 (nine units of time). That’s 6 + 2 + 9 = 17 in all. It is because
    of this focus on edge weights, not edge counts, that BFS is out of its element
    here and we’ll need a different algorithm.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 假设出口单元格是单元格4。单元格1到单元格4所需的最短时间是多少？单元格1到单元格4之间有一条直接的边，所以如果我们在计算边的数量（如BFS中那样），答案将是`1`。然而，我们这里不关心边的数量：我们更关心的是以边的权重总和来衡量的最短路径。1
    *→* 4边的权重是45，这不是最短路径。单元格1到单元格4的最短路径是这样的一条三边路径：从单元格1到单元格3（花费6个时间单位），再从单元格3到单元格2（花费2个时间单位），最后从单元格2到单元格4（花费9个时间单位）。这总共是6
    + 2 + 9 = 17个时间单位。正因为如此，BFS在这种情况下就不适用了，我们需要采用不同的算法。
- en: 'Hold on, though: there were some weighted graphs in [Chapter 5](ch05.xhtml),
    and we used BFS on those. What gives? Look back at [Figure 5-6](ch05.xhtml#ch05fig06),
    a Rope Climb graph where some of the edges had weight 1 and others had weight
    0\. We managed to use a variant of BFS there, but only because the edge weights
    were so constrained. Now look back at [Figure 5-7](ch05.xhtml#ch05fig07), a Book
    Translation graph. That’s a full-blown weighted graph with arbitrary edge weights.
    We managed to use BFS there, too, but that’s because the primary distance measure
    was the number of edges. Once a node’s edge distance was determined by BFS, only
    then did the edge weights come into play, helping us add the node as cheaply as
    possible.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但稍等：第[5章](ch05.xhtml)中也有一些加权图，我们在其中使用了BFS。怎么回事？回顾[图5-6](ch05.xhtml#ch05fig06)，这是一个绳索攀爬图，其中有些边的权重是1，有些边的权重是0。我们能够在这里使用BFS，原因仅仅是边的权重受到严格限制。现在回头看看[图5-7](ch05.xhtml#ch05fig07)，这是一个书籍翻译图。这是一个完全加权的图，边的权重是任意的。我们在这里也能使用BFS，但那是因为主要的距离度量是边的数量。一旦BFS确定了一个节点的边的距离，只有在此之后，边的权重才会发挥作用，帮助我们以尽可能低的成本添加节点。
- en: However, in no way does the Mice Maze have anything to do with the number of
    edges. A path from *a* to *b* might have 100 edges and a total time of 5 units.
    A different path from *a* to *b* might have only 1 edge with a time of 80 units.
    BFS would discover that second path, when what we want is the first.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，鼠标迷宫与边的数量毫无关系。从*a*到*b*的路径可能有100条边，总时间为5单位。另一条从*a*到*b*的路径可能只有1条边，时间为80单位。BFS会发现第二条路径，而我们想要的是第一条路径。
- en: '*Finding Shortest Paths in Weighted Graphs*'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*在加权图中寻找最短路径*'
- en: 'BFS operates by progressively identifying nodes that are further and further
    away, in terms of edge count, from the starting node. The algorithm that I’ll
    present in this section operates similarly: it identifies the shortest path for
    nodes further and further away, in terms of total edge weight, from the starting
    node.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: BFS通过逐步识别离起始节点越来越远的节点（按边数计算）来运作。我在这一节中展示的算法与此类似：它通过总边权来识别离起始节点越来越远的最短路径。
- en: BFS organizes its work in rounds, where the nodes discovered in the next round
    are one edge more distant than the nodes in the current round. We aren’t going
    to be able to use that rounds idea to find shortest paths in weighted graphs,
    because the shortest paths that we discover most recently are not necessarily
    those that will help us find the shortest path for a new node. We’ll have to work
    a little harder to find the next shortest path.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: BFS按照回合组织工作，每一回合中发现的节点比当前回合的节点距离起始节点多一条边。我们无法使用这种回合的思路来寻找加权图中的最短路径，因为我们最近发现的最短路径不一定有助于我们找到新节点的最短路径。我们必须稍微多做些工作，才能找到下一个最短路径。
- en: To demonstrate, let’s find the shortest paths from Node 1 to each node in the
    graph using [Figure 6-1](ch06.xhtml#ch06fig01). That will tell us how long it
    takes the mouse in cell 1 to get to the exit cell.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们来通过[图6-1](ch06.xhtml#ch06fig01)找到从节点1到图中每个节点的最短路径。这将告诉我们鼠标从单元格1到出口单元格需要多长时间。
- en: 'For each node, we’ll maintain two pieces of information:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个节点，我们将维护两条信息：
- en: '***done***   This is a true/false variable. If it’s false, it means that we
    haven’t found the shortest path for this node yet; if it’s true, then we have.
    Once a node’s *done* value is true, we’re done with it: its shortest path will
    never change again.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '***done*** 这是一个布尔变量。如果为false，意味着我们还没有找到该节点的最短路径；如果为true，表示我们已经找到了。只要一个节点的*done*值为true，我们就完成了该节点：它的最短路径永远不会再改变。'
- en: '***min_time***   This is the shortest path distance from the starting node
    to this node, in terms of total time, using a path whose other nodes are all done.
    As more and more nodes become done, *min_time* can decrease, because we have more
    options for paths to this node.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '***min_time*** 这是从起始节点到此节点的最短路径距离，按总时间计算，使用一条所有其他节点均已完成的路径。随着越来越多的节点完成，*min_time*可以减小，因为我们有更多通往该节点的路径选择。'
- en: 'The shortest path from Node 1 to Node 1 is 0: there’s nowhere to go and no
    edge to take. Let’s start there, with a *min_time* for Node 1 of 0 and no *min_time*
    information for the other nodes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从节点1到节点1的最短路径是0：没有地方可去，也没有边可走。我们从这里开始，节点1的*min_time*为0，其他节点没有*min_time*信息：
- en: '| ***node*** | ***done*** | ***min_time*** |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| ***node*** | ***done*** | ***min_time*** |'
- en: '| --- | --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | false | 0 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 1 | false | 0 |'
- en: '| 2 | false |  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 2 | false |  |'
- en: '| 3 | false |  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 3 | false |  |'
- en: '| 4 | false |  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 4 | false |  |'
- en: '| 5 | false |  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 5 | false |  |'
- en: 'We next set Node 1 to done, and then we set the *min_time* for each other node
    based on the edge weights from Node 1\. Here’s our next snapshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将节点1标记为已完成，然后根据从节点1到其他节点的边权设置各自的*min_time*。以下是我们接下来的快照：
- en: '| ***node*** | ***done*** | ***min_time*** |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| ***node*** | ***done*** | ***min_time*** |'
- en: '| --- | --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | true | 0 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 1 | true | 0 |'
- en: '| 2 | false | 12 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 2 | false | 12 |'
- en: '| 3 | false | 6 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 3 | false | 6 |'
- en: '| 4 | false | 45 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 4 | false | 45 |'
- en: '| 5 | false | 7 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 5 | false | 7 |'
- en: 'Now, here’s a claim that’s at the heart of what we’re doing here: the shortest
    path from Node 1 to Node 3 is 6, and there’s no way we can ever do better than
    6\. I chose Node 3 in my claim because it has the smallest *min_time* value of
    any node that is not done.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，下面这个陈述是我们所做工作的核心：从节点1到节点3的最短路径是6，并且我们永远无法做得比6更好。我选择节点3作为我的陈述对象，因为它是尚未完成节点中*min_time*值最小的节点。
- en: Claiming that the answer is 6 right now might seem brazen. What if there were
    some other path to Node 3 that was shorter, maybe another path that goes through
    some other nodes before eventually making its way to Node 3?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在声称答案是 6 似乎有些大胆。如果存在另一条更短的路径到达节点 3，或者是通过一些其他节点最终到达节点 3 的路径呢？
- en: 'Here’s why that can’t happen, and why our claim of 6 is safe. Imagine that
    there were some shorter path *p* from Node 1 to Node 3\. That path must start
    at Node 1 and leave Node 1 on some edge *e*. Then it must take zero or more other
    edges and arrive at Node 3\. Check it out: *e* already takes at least 6 time units,
    because 6 is the minimum time it takes to go from Node 1 to some other node. Any
    other edges that are on *p* only add to this, so there’s no way that *p* could
    have a total time of less than 6 units!'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么那种情况不可能发生，以及为什么我们可以确定 6 是正确答案的原因。假设从节点 1 到节点 3 存在一条更短的路径 *p*。这条路径必须从节点
    1 开始，并通过某个边 *e* 离开节点 1。然后它必须经过零个或多个其他边，并到达节点 3。仔细想想：*e* 已经至少需要 6 时间单位，因为 6 是从节点
    1 到其他节点所需的最短时间。路径 *p* 上的任何其他边只会增加这个时间，因此不可能存在总时间少于 6 单位的路径 *p*！
- en: 'So, Node 3 is done: we know its shortest path. Now we will have to use Node
    3 to check whether we can improve any of the shortest paths for nodes that are
    not yet done. Remember that the *min_time* values give the shortest path using
    done nodes. It takes 6 time units to get to Node 3, and there’s an edge from Node
    3 to Node 2 that takes 2 time units, so we now have a way to get from Node 1 to
    Node 2 in only 8 time units. We therefore update the *min_time* value for Node
    2 from 12 to 8\. Here’s where that leaves us:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，节点 3 已完成：我们知道它的最短路径。现在我们需要使用节点 3 来检查是否能够改善任何尚未完成的节点的最短路径。请记住，*最短时间* 值是通过已完成节点计算的最短路径。到达节点
    3 需要 6 时间单位，并且从节点 3 到节点 2 有一条边，花费 2 时间单位，因此我们现在有了一条从节点 1 到节点 2 仅需 8 时间单位的路径。因此，我们将节点
    2 的 *最短时间* 值从 12 更新为 8。以下是当前的状态：
- en: '| ***node*** | ***done*** | ***min_time*** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***已完成*** | ***最短时间*** |'
- en: '| --- | --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | true | 0 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 1 | true | 0 |'
- en: '| 2 | false | 8 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 2 | false | 8 |'
- en: '| 3 | true | 6 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 3 | true | 6 |'
- en: '| 4 | false | 45 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 4 | false | 45 |'
- en: '| 5 | false | 7 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 5 | false | 7 |'
- en: 'Nodes 2, 4, and 5 are not yet done. Which one can we doneify now? The answer
    is Node 5: it’s got the minimum *min_time*. Can we use Node 5 to update any of
    our other shortest paths? Node 5 does have an outgoing edge to Node 2, but getting
    from Node 1 to Node 5 (7 time units) and then taking the edge from Node 5 to Node
    2 (21 time units) takes more time (7 + 21 = 28) than our old path from Node 1
    to Node 2 (8 time units). So we leave Node 2’s *min_time* alone. The only change
    in the next snapshot, then, is to set Node 5 to done.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 节点 2、4 和 5 尚未完成。现在我们能将哪个节点标记为完成呢？答案是节点 5：它的 *最短时间* 最小。我们能否利用节点 5 更新其他最短路径？节点
    5 确实有一条指向节点 2 的边，但从节点 1 到节点 5 需要 7 时间单位，然后再从节点 5 到节点 2 需要 21 时间单位，总共需要的时间（7 +
    21 = 28）比我们原来的从节点 1 到节点 2 的路径（8 时间单位）要长。所以我们不会改变节点 2 的 *最短时间*。因此，下一次更新的唯一变化是将节点
    5 标记为完成。
- en: '| ***node*** | ***done*** | ***min_time*** |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***已完成*** | ***最短时间*** |'
- en: '| --- | --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | true | 0 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 1 | true | 0 |'
- en: '| 2 | false | 8 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 2 | false | 8 |'
- en: '| 3 | true | 6 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 3 | true | 6 |'
- en: '| 4 | false | 45 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 4 | false | 45 |'
- en: '| 5 | true | 7 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 5 | true | 7 |'
- en: 'There are two nodes to go. Node 2 has a *min_time* of 8, and Node 4 has a *min_time*
    of 45\. As always, we choose the smaller, finalizing the shortest path distance
    from Node 1 to Node 2 as 8\. Again, there can be no shorter path to Node 2 than
    8\. Any shorter path *p* from Node 1 to Node 2 must begin with some done nodes
    and will at some point cross for the first time on an edge from a done node to
    one that is not done. Call that edge *x* *→* *y*, where *x* is done and *y* is
    not. So that’s how *p* gets from Node 1 to Node *y*. It can then do whatever it
    wants to get from Node *y* to Node 2 . . . but it’s all frivolous. Getting from
    Node 1 to Node *y* already takes at least 8 time units: if it were less, then
    *y*’s *min_time* value would be less than 8 and we’d have chosen to set *y* to
    done rather than Node 2\. Whatever *p* does to get from Node *y* to Node 2 can
    only add even more time. So *p* can’t be shorter than 8.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个节点要处理。节点2的*min_time*为8，节点4的*min_time*为45。和往常一样，我们选择较小的值，最终确定从节点1到节点2的最短路径为8。再次强调，从节点1到节点2的最短路径无法小于8。任何从节点1到节点2的较短路径*p*，必须先经过一些已完成的节点，并且在某一时刻，会第一次穿越一条从已完成节点到未完成节点的边。我们称这条边为*x*
    *→* *y*，其中*x*是已完成的节点，而*y*是未完成的节点。这就是*p*从节点1到达节点*y*的方式。接下来，它可以随意从节点*y*到节点2……但这一切都是多余的。从节点1到节点*y*已经至少需要8个时间单位：如果少于8个单位，那*y*的*min_time*值就会小于8，而我们本应选择将*y*标记为已完成，而不是节点2。无论*p*如何从节点*y*到节点2，都会增加更多的时间。所以*p*不能比8更短。
- en: 'Adding Node 2 gives us two edges to check for shorter paths. There’s an edge
    from Node 2 to Node 1, but that won’t help us because Node 1 is already done.
    There’s an edge of 9 time units from Node 2 to Node 4\. That one does help us!
    Getting from Node 1 to Node 2 takes 8 time units, and then the 2 *→* 4 edge takes
    9 time units, for a total of 17 time units. That’s better than our old path from
    Node 1 to Node 4 that took 45 time units. Here’s the next snapshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 添加节点2后，我们有两条边可以检查是否存在更短的路径。从节点2到节点1有一条边，但这没有帮助，因为节点1已经完成。从节点2到节点4有一条9时间单位的边。这条边有帮助！从节点1到节点2需要8个时间单位，然后2
    *→* 4的边需要9个时间单位，总共是17个时间单位。这比我们之前从节点1到节点4需要的45个时间单位要好。下面是下一个快照：
- en: '| ***node*** | ***done*** | ***min_time*** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***已完成*** | ***最短时间*** |'
- en: '| --- | --- | --- |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | true | 0 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 1 | true | 0 |'
- en: '| 2 | true | 8 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 2 | true | 8 |'
- en: '| 3 | true | 6 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 3 | true | 6 |'
- en: '| 4 | false | 17 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 4 | false | 17 |'
- en: '| 5 | true | 7 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 5 | true | 7 |'
- en: 'There’s only one node, Node 4, that’s not done. As all other nodes are done,
    we’ve found all of their shortest paths. Node 4, therefore, can’t help us find
    any new, shorter paths. We can set Node 4 to done and conclude:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个节点，即节点4，尚未完成。由于其他所有节点都已完成，我们已经找出了它们的最短路径。因此，节点4不能帮助我们找到任何新的、更短的路径。我们可以将节点4标记为已完成，并得出结论：
- en: '| ***node*** | ***done*** | ***min_time*** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***已完成*** | ***最短时间*** |'
- en: '| --- | --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | true | 0 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 1 | true | 0 |'
- en: '| 2 | true | 8 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 2 | true | 8 |'
- en: '| 3 | true | 6 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 3 | true | 6 |'
- en: '| 4 | true | 17 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 4 | true | 17 |'
- en: '| 5 | true | 7 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 5 | true | 7 |'
- en: It takes 17 time units for the mouse in Cell 1 to get to the exit cell 4\. We
    could repeat the process for each other node to find out how long each other mouse
    takes to get to the exit cell, then count the mice that get there in time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1单元格的老鼠到达出口单元格4时，总共需要17个时间单位。我们可以对每个其他节点重复这个过程，找出每只老鼠到达出口单元格所需的时间，然后计算按时到达的老鼠数量。
- en: This algorithm is known as Dijkstra’s algorithm, after Edsger W. Dijkstra, a
    pioneering and influential computer scientist. Given a starting node *s* and a
    weighted graph, it calculates the shortest path from *s* to each node in the graph.
    It’s exactly what we need to solve the Mice Maze problem. Let’s read the input
    to build the graph and then see how Dijkstra’s algorithm can be implemented.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法被称为迪杰斯特拉算法（Dijkstra’s algorithm），以计算机科学的先驱和影响力人物埃德斯杰·W·迪杰斯特拉（Edsger W. Dijkstra）命名。给定一个起始节点*s*和一个加权图，它可以计算出从*s*到图中每个节点的最短路径。这正是我们解决老鼠迷宫问题所需要的。让我们读取输入来构建图形，然后看看如何实现迪杰斯特拉算法。
- en: '*Building the Graph*'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*构建图形*'
- en: With all of your experience building trees and graphs to this point, there won’t
    be many surprises here. We’ll build the graph like we built it for the Book Translation
    problem in the previous chapter (see “Building the Graph” on [page 189](ch05.xhtml#sec79)).
    The only difference is that the graphs there were undirected and our graphs here
    are directed. In more good news, we’re given the node numbers directly and don’t
    have to map between language names and integers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 基于你到目前为止构建树和图的经验，这里不会有太多惊讶。我们将像在上一章的书籍翻译问题中一样构建图（见[第189页](ch05.xhtml#sec79)中的“构建图”）。唯一的不同是，之前的图是无向图，而我们这里的图是有向图。好消息是，我们直接给出了节点编号，而不需要在语言名称和整数之间进行映射。
- en: 'Just so we have something on which to test, here’s an input corresponding to
    [Figure 6-1](ch06.xhtml#ch06fig01):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便测试，这里提供了一个输入，对应于[图 6-1](ch06.xhtml#ch06fig01)：
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That `12` ➊ gives the time limit for the mice to get to the exit. (You can verify
    that three mice can get to the exit within this time limit; those mice are the
    ones in Cells 2, 3, and 4.)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该`12` ➊ 给出了老鼠到达出口的时间限制。（你可以验证，三只老鼠可以在这个时间限制内到达出口；这三只老鼠分别位于单元2、3和4。）
- en: As in Book Translation, we’ll use an adjacency list representation of the graph.
    Each edge maintains the cell to which it points, the length of time required to
    walk the edge, and a next pointer.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 和书籍翻译问题一样，我们将使用图的邻接表表示法。每条边包含指向的单元、行走该边所需的时间以及下一个指针。
- en: 'Here’s the needed constant and `typedef`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所需的常量和`typedef`：
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The graphs are read by the `main` function in [Listing 6-1](ch06.xhtml#ch06ex01).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图表由`main`函数读取，见[列表 6-1](ch06.xhtml#ch06ex01)。
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 6-1: The* main *function for building the graph*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-1：用于构建图的* main *函数*'
- en: 'The input specification says that a blank line follows the number of test cases
    and that a blank line sits between each pair of test cases. However, using `scanf`,
    we don’t have to worry about that: when reading a number, `scanf` skips leading
    whitespace (including newlines) that it encounters.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 输入规范说在测试用例数量后会有一个空行，每对测试用例之间也有一个空行。然而，使用`scanf`时我们无需担心这一点：当读取数字时，`scanf`会跳过它遇到的所有前导空白（包括换行符）。
- en: 'The first thing we do for each test case is to clear the adjacency list by
    setting each cell’s edge list to `NULL` ➊. Not doing that results in a horrible
    bug where each test case includes edges from prior test cases. (I would know:
    I made that mistake, and three hours later it was three hours later.) It’s our
    responsibility to clear things for each test case!'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个测试用例做的第一件事是通过将每个单元的边表设置为`NULL` ➊来清空邻接表。如果不这么做，会导致一个可怕的bug，其中每个测试用例都会包含前一个测试用例的边。（我知道，因为我犯过这个错误，结果三小时后才发现。）我们有责任为每个测试用例清空数据！
- en: Upon initializing each edge, we add it to the linked list for `from_cell` ➋.
    We don’t add anything to the linked list for `to_cell`, because the graph is directed
    (not undirected).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化每个边时，我们将其添加到`from_cell`的链表中 ➋。我们不会向`to_cell`的链表添加任何内容，因为图是有向图（不是无向图）。
- en: The problem requires that we find the shortest path from each cell to the exit
    cell. For each cell, then, we call `find_time` ➌, a helper function that implements
    Dijkstra’s algorithm. We’ll write that function next. Given a starting cell `i`
    and target cell `exit_cell`, it returns `-1` if there’s no path at all or else
    returns the shortest path time. Each cell that takes `time_limit` units of time
    or less to get to the exit cell results in `total` being incremented by one ➍.
    Once each cell’s shortest path has been considered, `total` is output.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题要求我们找到每个单元到出口单元的最短路径。因此，对于每个单元，我们调用`find_time` ➌，它是一个实现了Dijkstra算法的辅助函数。我们接下来会编写这个函数。给定起始单元`i`和目标单元`exit_cell`，如果没有路径，它返回`-1`，否则返回最短路径时间。每个到达出口单元需要`time_limit`单位时间或更少的单元，都会使得`total`增加1
    ➍。一旦考虑完每个单元的最短路径，`total`就会被输出。
- en: '*Implementing Dijkstra’s Algorithm*'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*实现Dijkstra算法*'
- en: 'Now it’s time to implement Dijkstra’s algorithm, following the outline provided
    in “Finding Shortest Paths in Weighted Graphs” on [page 200](ch06.xhtml#sec84).
    Here’s the signature for the function that we’ll implement:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是实现Dijkstra算法的时候了，按照“加权图中寻找最短路径”部分提供的概要来实现，见[第200页](ch06.xhtml#sec84)。这是我们将要实现的函数签名：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The four parameters correspond to the adjacency list, number of cells, starting
    cell, and exit cell, respectively. Dijkstra’s algorithm will calculate the shortest
    path time from the starting cell to all other cells, including the exit cell.
    Once we’re done, we can return the shortest path time to the exit cell. That may
    seem extravagant, calculating the shortest path to all cells only to throw everything
    away except the shortest path to the exit cell. There are various optimizations
    that we can perform, and we’ll turn to those in the next subsection. For now,
    let’s settle in with a working, unadorned implementation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个参数分别对应邻接表、单元格数量、起始单元格和出口单元格。Dijkstra 算法将计算从起始单元格到所有其他单元格的最短路径时间，包括出口单元格。一旦计算完成，我们可以返回到出口单元格的最短路径时间。这个看起来可能有点奢侈，计算到所有单元格的最短路径后，只保留通往出口单元格的最短路径而抛弃其他路径。我们可以进行多种优化，接下来会讨论这些优化。现在，让我们先实现一个简单可用的版本。
- en: 'The body of Dijkstra’s algorithm is implemented by two nested `for` loops.
    The outer `for` loop runs once per cell; each iteration sets one cell to done
    and updates shortest paths using that new cell. The inner `for` loop is a minimum
    computation: it finds the cell whose `min_time` value, among all cells that are
    not done, is minimum. See [Listing 6-2](ch06.xhtml#ch06ex02) for the code.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra 算法的主体通过两个嵌套的 `for` 循环实现。外层 `for` 循环每个单元格运行一次；每次迭代将一个单元格标记为已完成，并使用该新单元格更新最短路径。内层
    `for` 循环进行最小值计算：它在所有未完成的单元格中找到 `min_time` 值最小的单元格。代码见 [Listing 6-2](ch06.xhtml#ch06ex02)。
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 6-2: The shortest path to the exit cell using Dijkstra’s algorithm*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-2: 使用 Dijkstra 算法找到通往出口单元格的最短路径*'
- en: 'The purpose of the `done` array is to indicate whether each cell is done: a
    `0` means “not done” and a `1` means “done.” The purpose of the `min_times` array
    is to store the shortest path distance from the starting cell to each cell.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`done` 数组的目的是指示每个单元格是否已完成：`0`表示“未完成”，`1`表示“已完成”。`min_times` 数组的目的是存储从起始单元格到每个单元格的最短路径距离。'
- en: 'We use a `for` loop ➊ to initialize these two arrays: it sets all `done` values
    to `0` (false) and `min_times` values to `-1` (not found). We then set `min_times`
    for `from_cell` to `0` ➋ to indicate that the shortest path distance from the
    starting cell to itself is zero.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `for` 循环 ➊ 来初始化这两个数组：它将所有 `done` 值设置为 `0`（假），将 `min_times` 值设置为 `-1`（未找到）。然后，我们将
    `from_cell` 的 `min_times` 设置为 `0` ➋，表示从起始单元格到它自身的最短路径距离为零。
- en: The `found` variable tracks whether a new cell can be discovered by Dijkstra’s
    algorithm. On each iteration of the outer `for` loop, it starts off as `0` (false)
    ➌ and gets set to `1` (true) if a cell can be found—but how could a cell not be
    found? For example, earlier in this chapter, we found all of the cells. However,
    there may be graphs where there is *no* path between a starting cell and some
    other cell. On those graphs, there will be cells that Dijkstra’s algorithm does
    not find; when no new cell can be found, it’s time to stop.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`found` 变量跟踪 Dijkstra 算法是否能发现新单元格。在每次外层 `for` 循环迭代时，它初始为 `0`（假），如果找到一个单元格，则设置为
    `1`（真）——但是，怎么可能找不到单元格呢？例如，在本章之前，我们已经找到了所有单元格。然而，可能存在这样的图形，其中起始单元格与某些其他单元格之间*没有*路径。在这些图形中，Dijkstra
    算法无法找到某些单元格；当无法找到新单元格时，就该停止了。'
- en: 'Now we arrive at the inner `for` loop ➍, whose task is to identify the cell
    whose shortest path will be found next. This loop will leave `min_time_index`
    with the index of the cell whose shortest path has been found and `min_time` with
    the shortest path time itself. The eligible cells are those that are both not
    done and have a `min_times` value that’s at least `0` (that is, not `-1`) ➎. We
    need the cell to be not done, because done cells already have their shortest paths
    finalized. We also need the `min_times` value to be at least `0`: if it’s `-1`,
    then the cell hasn’t been found yet, so we have no idea what its shortest path
    is. If we had no eligible cell yet or the current cell has a shorter path than
    our shortest thus far ➏, we update `min_time` and `min_time_index` and set `found`
    to `1` to flag that we successfully found a cell.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进入内层 `for` 循环 ➍，它的任务是识别下一个最短路径将被找到的单元格。这个循环将把 `min_time_index` 设置为最短路径已找到的单元格的索引，并将
    `min_time` 设置为最短路径的时间。符合条件的单元格是那些既未完成又有一个至少为 `0`（即非 `-1`）的 `min_times` 值的单元格 ➎。我们需要单元格未完成，因为已完成的单元格已经有了最终的最短路径。我们还需要
    `min_times` 值至少为 `0`：如果它是 `-1`，表示该单元格尚未找到，因此我们不知道它的最短路径是什么。如果还没有符合条件的单元格，或者当前单元格的路径比我们当前已知的最短路径更短
    ➏，我们就更新 `min_time` 和 `min_time_index`，并将 `found` 设置为 `1`，标志着我们成功找到了一个单元格。
- en: If no cell was found, then we stop ➐. Otherwise, we set the identified cell
    to done and loop through its outgoing edges to find shorter paths. For each edge
    `e`, we check whether the cell provides a shorter path to `e->to_cell` ➑. That
    possible shorter path is `min_time` (the time taken to get from `from_cell` to
    `min_time_index`) plus the time taken to walk edge `e` (from `min_time_index`
    to `e->to_cell`).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到单元格，那么我们就停止 ➐。否则，我们将识别出的单元格标记为完成，并循环遍历它的出边来寻找更短的路径。对于每一条边 `e`，我们检查该单元格是否提供到
    `e->to_cell` 的更短路径 ➑。那个可能的更短路径是 `min_time`（从 `from_cell` 到 `min_time_index` 的时间）加上走过边
    `e`（从 `min_time_index` 到 `e->to_cell` 的时间）。
- en: When looking at edge `e`, shouldn’t we first be verifying that `e->to_cell`
    is not done before checking whether we’ve found a shorter path ➑? Although we
    could add that check, it would have no effect. Done cells already have their finalized
    shortest paths; there’s no way that some shorter path can be found.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看边 `e` 时，难道我们不应该先验证 `e->to_cell` 是否已经完成，然后再检查我们是否找到了更短的路径 ➑ 吗？虽然我们可以添加那个检查，但它不会产生任何效果。已完成的单元格已经拥有最终确定的最短路径；不可能再找到更短的路径了。
- en: Having computed shortest paths to all cells, we’ve certainly computed the shortest
    path to the exit cell. The final thing to do is return that time ➒.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过计算到所有单元格的最短路径，我们肯定已经计算出了到出口单元格的最短路径。最后要做的就是返回那个时间 ➒。
- en: That’s a wrap! Go ahead and submit to the judge. The code should pass all of
    the test cases.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 结束了！继续提交给评测系统吧。代码应该能够通过所有的测试用例。
- en: '*Two Optimizations*'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*两个优化*'
- en: There are a few things that can be done to speed up Dijkstra’s algorithm. The
    most widely applicable and dramatic speedup is wrought by a data structure called
    a *heap*. In our current implementation, it’s very expensive to find the next
    node to set to done, as we need to scan through all nodes that are not done to
    find the one with the shortest path. A heap uses a tree to convert this slow,
    linear search into a fast search. As heaps are useful in many contexts beyond
    Dijkstra’s algorithm, I’ll discuss them later, in [Chapter 8](ch08.xhtml). Here,
    I’ll offer a couple of optimizations more specific to the Mice Maze problem.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些方法可以加速 Dijkstra 算法。最广泛适用且显著的加速是通过一种叫做 *堆* 的数据结构实现的。在我们当前的实现中，找到下一个要标记为完成的节点非常昂贵，因为我们需要扫描所有未完成的节点，找出具有最短路径的那个节点。堆使用树将这种慢速的线性搜索转换为快速搜索。由于堆在许多场景中都很有用，不仅限于
    Dijkstra 算法，我将在稍后的[第 8 章](ch08.xhtml)中讨论它们。在这里，我会提供几个更具体于老鼠迷宫问题的优化方法。
- en: Recall that as soon as a cell is done, we never change its shortest path again.
    As such, once we set the exit cell to done, we have its shortest path. After that,
    there’s no reason to find shortest paths for other cells. We may as well terminate
    Dijkstra’s algorithm early.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一旦一个单元格被标记为完成，我们就不再改变它的最短路径。因此，一旦我们将出口单元格标记为完成，我们就得到了它的最短路径。之后，就没有必要再为其他单元格找到最短路径了。我们可以提前终止
    Dijkstra 算法。
- en: We can still do better, though. For a maze of *n* cells, we invoke Dijkstra’s
    algorithm *n* times, once for each cell. For Cell 1, we compute all shortest paths—and
    then keep only the shortest path to the exit cell. We do the same for Cell 2,
    Cell 3, and so on, throwing out all of the shortest paths we found except for
    those that involve the exit cell.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还是可以做得更好。对于一个包含 *n* 个单元格的迷宫，我们可以执行 Dijkstra 算法 *n* 次，每次对一个单元格执行。对于单元格 1，我们计算所有的最短路径——然后只保留到出口单元格的最短路径。对于单元格
    2、单元格 3，依此类推，我们丢弃所有找到的最短路径，除了那些涉及出口单元格的路径。
- en: 'Instead, consider running Dijkstra’s algorithm just once, with the exit cell
    as the starting cell. Dijkstra’s algorithm would then find the shortest path from
    the exit cell to Cell 1, the exit cell to Cell 2, and so on. However, that’s not
    quite what we want, because the graph is directed: the shortest path from the
    exit cell to Cell 1 is *not* necessarily the shortest path from Cell 1 to the
    exit cell.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，可以考虑只运行一次 Dijkstra 算法，将出口单元格作为起始单元格。Dijkstra 算法会找到从出口单元格到单元格 1，从出口单元格到单元格
    2，依此类推的最短路径。然而，这并不是我们想要的，因为图是有向的：从出口单元格到单元格 1 的最短路径*不一定*是从单元格 1 到出口单元格的最短路径。
- en: 'Here again is [Figure 6-1](ch06.xhtml#ch06fig01):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里再次展示[图 6-1](ch06.xhtml#ch06fig01)：
- en: '![Image](../images/unch06fig01.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/unch06fig01.jpg)'
- en: As we discovered earlier, the shortest path from Cell 1 to Cell 4 is 17, but
    the shortest path from Cell 4 to Cell 1 is 36.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前发现的，从单元格 1 到单元格 4 的最短路径是 17，但从单元格 4 到单元格 1 的最短路径是 36。
- en: The shortest path from Cell 1 to Cell 4 uses the edges 1 *→* 3, 3 *→* 2, and
    2 *→* 4\. If we intend on starting Dijkstra’s algorithm from Cell 4, then we need
    it to find edges 4 *→* 2, 2 *→* 3, and 3 *→* 1\. Each of these edges is the *reverse*
    of an edge in the original graph. [Figure 6-2](ch06.xhtml#ch06fig02) shows the
    *reversed graph*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从Cell 1到Cell 4的最短路径使用了边1 *→* 3、3 *→* 2和2 *→* 4。如果我们打算从Cell 4开始运行Dijkstra算法，那么它需要找到边4
    *→* 2、2 *→* 3和3 *→* 1。每一条边都是原始图中边的*反向*。图[6-2](ch06.xhtml#ch06fig02)显示了*反向图*。
- en: '![Image](../images/ch06fig02.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch06fig02.jpg)'
- en: '*Figure 6-2: A reversed version of the graph in [Figure 6-1](ch06.xhtml#ch06fig01)*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：图[6-1](ch06.xhtml#ch06fig01)的反向版本*'
- en: Now we can run Dijkstra’s algorithm—just one invocation of it!—from Cell 4 to
    recover shortest paths to all nodes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行Dijkstra算法——只需调用一次！——从Cell 4开始，恢复到所有节点的最短路径。
- en: 'In terms of implementation, we would need to produce the reversed graph instead
    of the original graph. This can be done in the `main` function ([Listing 6-1](ch06.xhtml#ch06ex01)),
    when reading the graph. Instead of:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 就实现而言，我们需要生成反向图，而不是原始图。这可以在`main`函数中完成（见[Listing 6-1](ch06.xhtml#ch06ex01)），在读取图时进行处理。替代方法是：
- en: '[PRE5]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'we want this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是：
- en: '[PRE6]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That is, the edge now points to `from_cell`, and it gets added to the linked
    list for `to_cell`. If you make this change and adapt the code so that it invokes
    Dijkstra’s algorithm just once (from the exit cell), you’ll end up with a much
    faster program. Give it a try!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，边现在指向`from_cell`，并且它会被添加到`to_cell`的链表中。如果你进行这个修改并调整代码，使其只调用一次Dijkstra算法（从出口单元开始），你将得到一个更快的程序。试试看！
- en: Dijkstra’s Algorithm
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dijkstra算法
- en: Dijkstra’s algorithm takes over where BFS leaves off. BFS finds shortest paths
    in terms of numbers of edges in an unweighted graph; Dijkstra’s algorithm finds
    shortest paths in terms of edge weights in a weighted graph.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra算法接管了BFS的工作。BFS在无权图中根据边的数量找到最短路径；而Dijkstra算法在加权图中根据边的权重找到最短路径。
- en: Like BFS, Dijkstra’s algorithm takes a starting node, and it finds shortest
    paths from there to each node in the graph. Like BFS, it then solves the *single-source
    shortest-paths* problem, except on weighted graphs rather than unweighted graphs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与广度优先搜索（BFS）类似，Dijkstra算法从一个起始节点开始，并从那里找到到图中每个节点的最短路径。与BFS类似，它解决的是*单源最短路径*问题，不同的是，Dijkstra算法是在加权图上运行，而不是无权图。
- en: To be fair, Dijkstra’s algorithm *can* find shortest paths in unweighted graphs,
    too. Just take the unweighted graph and give each edge a weight of one. Now, when
    Dijkstra’s algorithm finds the shortest paths, it will have minimized the number
    of edges in the path, precisely what BFS does.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，Dijkstra算法*也*可以在无权图中找到最短路径。只需将无权图中的每条边赋予权重1。现在，当Dijkstra算法找到最短路径时，它实际上最小化了路径中的边数，这正是BFS所做的。
- en: 'Why not hammer every shortest-path problem, unweighted or weighted, with Dijkstra’s
    algorithm, then? Indeed, there are problems where it’s difficult to decide between
    BFS and Dijkstra’s algorithm. For example, I suspect that many people would have
    chosen Dijkstra’s algorithm over (modified) BFS to solve the Rope Climb problem
    in [Chapter 5](ch05.xhtml). When the task is clearly to minimize the number of
    moves, BFS should still get the call: it’s generally easier to implement than
    Dijkstra’s algorithm and runs a little faster, too. By no means, however, is Dijkstra’s
    algorithm slow.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 那为什么不使用Dijkstra算法来解决每个最短路径问题，无论是无权图还是加权图呢？实际上，确实存在一些问题，在这些问题中很难决定使用BFS还是Dijkstra算法。例如，我怀疑很多人会选择使用Dijkstra算法而不是（修改过的）BFS来解决[第5章](ch05.xhtml)中的绳子攀爬问题。当任务明确是最小化移动次数时，BFS应当是首选：它通常比Dijkstra算法更容易实现，而且运行得稍微快一点。但无论如何，Dijkstra算法并不慢。
- en: '*Runtime of Dijkstra’s Algorithm*'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*Dijkstra算法的运行时间*'
- en: Let’s characterize the runtime of Dijkstra’s algorithm as seen in [Listing 6-2](ch06.xhtml#ch06ex02).
    We’ll use *n* to refer to the number of nodes in the graph.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来描述一下Dijkstra算法的运行时间，如[Listing 6-2](ch06.xhtml#ch06ex02)所示。我们使用*n*来表示图中的节点数。
- en: The initialization loop ➊ iterates *n* times, doing a constant number of steps
    per iteration, so it does total work proportional to *n*. The next bit of initialization
    ➋ is a single step. Whether we say that the initialization takes *n* steps or
    *n* + 1 steps changes nothing, so we’ll ignore this 1 and say that it takes *n*
    steps.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化循环➊重复*n*次，每次迭代执行一个常数步骤，因此总工作量与*n*成正比。接下来的初始化步骤➋是一个单一步骤。无论我们说初始化需要*n*步还是*n*
    + 1步都没关系，因此我们忽略这个1，认为它需要*n*步。
- en: The real work done by Dijkstra’s algorithm starts now. Its outer `for` loop
    iterates up to *n* times. For each such iteration, the inner `for` loop does *n*
    iterations to find the next node. The inner `for` loop, then, iterates a total
    of *n*² times. Each such iteration does a constant amount of work, so the inner
    `for` loop does total work proportional to *n*².
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra算法的真正工作现在开始。它的外层 `for` 循环最多迭代 *n* 次。在每次迭代中，内层 `for` 循环会执行 *n* 次以找到下一个节点。因此，内层
    `for` 循环总共会迭代 *n*² 次。每次迭代执行固定量的工作，因此内层 `for` 循环的总工作量与 *n*² 成正比。
- en: The other work that Dijkstra’s algorithm does is to iterate through the edges
    of each node. There are a total of *n* nodes, so certainly each node has no more
    than *n* edges leaving it. We therefore take *n* steps to iterate through the
    edges of one node, and we have to do this for each of the *n* nodes. That’s another
    *n*² steps.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra算法的另一个工作是遍历每个节点的边。总共有 *n* 个节点，所以每个节点最多有 *n* 条离开的边。因此，我们需要进行 *n* 步来遍历一个节点的边，并且我们必须对每个节点做这件事。这又是
    *n*² 步。
- en: Summarizing, we’ve got *n* work in the initialization, *n*² work in the inner
    `for` loop, and *n*² work checking the edges. The biggest exponent there is 2,
    so this is an *O*(*n*²), or quadratic, algorithm.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们在初始化时有 *n* 工作，在内层 `for` 循环中有 *n*² 工作，在检查边时有 *n*² 工作。最大的指数是2，所以这是一个 *O*(*n*²)
    或二次时间复杂度的算法。
- en: In [Chapter 1](ch01.xhtml), we sneezed at a quadratic-time algorithm for Unique
    Snow-flakes, tossing it away in favor of a linear-time algorithm. In that sense,
    the implementation of Dijkstra’s algorithm that we have developed is not too impressive.
    In another sense, though, it is, because in *n*² time it’s solving not one but
    *n* problems, one for each shortest path from the starting node.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml)中，我们对一个二次时间复杂度的“独特雪花”算法嗤之以鼻，抛弃它，选择了一个线性时间的算法。从这个意义上说，我们开发的Dijkstra算法实现并不算太惊艳。然而，从另一个角度来看，它确实令人印象深刻，因为它在
    *n*² 时间内解决了 *n* 个问题，每个问题对应从起始节点出发的最短路径。
- en: I’ve chosen to present Dijkstra’s algorithm in this book, but there are many
    other shortest-paths algorithms. Some find the shortest path between all pairs
    of nodes in the graph in one fell swoop. Doing so solves the *all-pairs shortest-paths*
    problem. One such algorithm is called the *Floyd–Warshall algorithm*, and it runs
    in *O*(*n*³) time. Interestingly, we can find all-pairs shortest paths with Dijkstra’s
    algorithm, too, and just as quickly. We can run Dijkstra’s algorithm *n* times,
    once from each starting node. That’s *n* invocations of an *n*² algorithm, for
    a total of *O*(*n*³) work.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择在本书中介绍Dijkstra算法，但还有许多其他最短路径算法。有些算法能够一次性找到图中所有节点对之间的最短路径。这样就解决了 *所有节点对最短路径*
    问题。一个这样的算法叫做 *Floyd-Warshall 算法*，它的时间复杂度是 *O*(*n*³)。有趣的是，我们也可以用Dijkstra算法找到所有节点对的最短路径，而且速度一样快。我们可以运行Dijkstra算法
    *n* 次，每次从不同的起始节点开始。那就是 *n* 次调用 *n*² 算法，总共的工作量是 *O*(*n*³)。
- en: Weighted or unweighted, single-source or all-pairs, Dijkstra’s algorithm can
    do it. Is it simply unstoppable? Negative!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是加权还是无加权，单源还是所有节点对，Dijkstra算法都能处理。它真的无法阻挡吗？错！
- en: '*Negative-Weight Edges*'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*负权重边*'
- en: 'We’ve made an implicit assumption to this point in the chapter: edge weights
    are nonnegative. In the Mice Maze, for example, edge weights represent times to
    walk edges; walking an edge surely can’t cause time to go backward, so no edge
    weight was negative. Similarly, in many other graphs, edges with negative weights
    don’t arise simply because they don’t make sense. For example, consider a graph
    where the nodes are cities and edges are flight costs between cities. No airline
    is going to pay us for taking their flights, so each edge will be a nonnegative
    dollar cost.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在本章中做了一个隐含假设：边的权重是非负的。例如，在老鼠迷宫中，边的权重代表走过每条边所需的时间；走一条边肯定不会让时间倒退，因此没有边的权重是负的。同样，在许多其他图中，负权重的边不会出现，因为它们没有实际意义。例如，考虑一个图，其中节点是城市，边是城市间的航班费用。没有航空公司会为我们乘坐他们的航班付费，因此每条边的费用是非负的美元。
- en: Now consider a game in which some moves give us points, and other moves take
    points away. Those latter moves correspond to *negative-weight edges*. Thus negative-weight
    edges do appear from time to time. How does Dijkstra’s algorithm respond? Let’s
    find out using the sample graph in [Figure 6-3](ch06.xhtml#ch06fig03).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个游戏，其中一些操作给我们加分，而另一些操作则扣分。后者的操作对应于 *负权重边*。因此，负权重边偶尔会出现。那么Dijkstra算法如何应对呢？让我们用[图6-3](ch06.xhtml#ch06fig03)中的示例图来看看。
- en: '![Image](../images/ch06fig03.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch06fig03.jpg)'
- en: '*Figure 6-3: A graph with a negative-weight edge*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：带有负权边的图*'
- en: 'Let’s try to find shortest paths from Node A. As always, Dijkstra’s algorithm
    begins by assigning a shortest path of 0 to Node A and setting Node A to done.
    The distance to B from A is 3, the distance to C from A is 5, but the distance
    to D from A is not defined (and has been left blank):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试从节点 A 寻找最短路径。和往常一样，Dijkstra 算法首先将最短路径 0 指定给节点 A，并将 A 设置为已完成。从 A 到 B 的距离是
    3，从 A 到 C 的距离是 5，但从 A 到 D 的距离尚未定义（并且留空）：
- en: '| ***node*** | ***done*** | ***min_distance*** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***已完成*** | ***最短距离*** |'
- en: '| --- | --- | --- |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| A | true | 0 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| A | true | 0 |'
- en: '| B | false | 3 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| B | false | 3 |'
- en: '| C | false | 5 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| C | false | 5 |'
- en: '| D | false |  |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| D | false |  |'
- en: 'Dijkstra’s algorithm then decides to finalize the shortest path to Node B at
    3, and it sets B to done. It also updates the shortest path to D:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra 算法接着决定将到 B 的最短路径定为 3，并将 B 标记为已完成。它还更新了到 D 的最短路径：
- en: '| ***node*** | ***done*** | ***min_distance*** |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***已完成*** | ***最短距离*** |'
- en: '| --- | --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| A | true | 0 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| A | true | 0 |'
- en: '| B | true | 3 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| B | true | 3 |'
- en: '| C | false | 5 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| C | false | 5 |'
- en: '| D | false | 4 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| D | false | 4 |'
- en: 'By virtue of B being done, we’re claiming that 3 is the shortest path from
    A to B, but that spells trouble, because 3 is *not* the shortest path that we
    can find from A to B. The shortest path is *A* *→* *C* *→* *B*, with a total weight
    of –495\. For kicks, let’s continue under these fishy circumstances and see what
    Dijkstra’s algorithm would do anyway. The next node that’s done is D:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 B 已完成，我们声称从 A 到 B 的最短路径是 3，但这会出问题，因为 3 *不是*从 A 到 B 的最短路径。最短路径应该是 *A* *→*
    *C* *→* *B*，总权重为 -495。为了好玩，我们就继续在这些可疑的情况下进行，看看 Dijkstra 算法会怎么做。下一个完成的节点是 D：
- en: '| ***node*** | ***done*** | ***min_distance*** |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***已完成*** | ***最短距离*** |'
- en: '| --- | --- | --- |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| A | true | 0 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| A | true | 0 |'
- en: '| B | true | 3 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| B | true | 3 |'
- en: '| C | false | 5 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| C | false | 5 |'
- en: '| D | true | 4 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| D | true | 4 |'
- en: 'That shortest path to D is wrong, too! It should be –494\. As all nodes are
    done except for C, there’s nothing that C can do:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到 D 的最短路径也错了！它应该是 -494。因为除了 C 外所有节点都已完成，所以 C 无法再做任何事情：
- en: '| ***node*** | ***done*** | ***min_distance*** |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***已完成*** | ***最短距离*** |'
- en: '| --- | --- | --- |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| A | true | 0 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| A | true | 0 |'
- en: '| B | true | 3 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| B | true | 3 |'
- en: '| C | true | 5 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| C | true | 5 |'
- en: '| D | true | 4 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| D | true | 4 |'
- en: Even if we let Dijkstra’s algorithm change the shortest path to B here, from
    3 to –495, then the shortest path to D will still be wrong. We’d have to somehow
    process B again, even though B is done. We’d need some way of saying, “Hey, I
    know that I said B was done, but I’m changing my mind.” In any event, the classical
    Dijkstra’s algorithm as I’ve presented it gets this example wrong.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们让 Dijkstra 算法将最短路径更改为 B（从 3 改为 -495），到 D 的最短路径仍然是错误的。我们必须以某种方式再次处理 B，即使
    B 已完成。我们需要一种方法来表示：“嘿，我知道我说 B 已完成，但我改变主意了。”无论如何，我展示的经典 Dijkstra 算法在这个例子中是错误的。
- en: In general, Dijkstra’s algorithm does not work when graph edges can be negative.
    For that, you may wish to explore the *Bellman–Ford algorithm* or the aforementioned
    Floyd–Warshall algorithm.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当图的边有负权时，Dijkstra 算法是无法工作的。对此，你可以考虑探索 *Bellman-Ford 算法* 或前面提到的 Floyd-Warshall
    算法。
- en: Let’s proceed here with another problem where we don’t have to worry about negative-weight
    edges. We’ll use Dijkstra’s algorithm again, or, rather, we’ll adapt Dijkstra’s
    algorithm to solve a new kind of problem about shortest paths.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行另一个问题，这次我们不必担心负权边。我们将再次使用 Dijkstra 算法，或者更确切地说，我们将调整 Dijkstra 算法来解决关于最短路径的全新问题。
- en: 'Problem 2: Grandma Planner'
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题 2：奶奶规划师
- en: Sometimes, we’ll be asked for not only the shortest path distance but also further
    information about the shortest paths. This problem is just such an example.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们不仅会被要求给出最短路径的距离，还会要求进一步提供关于最短路径的信息。这个问题就是这样一个例子。
- en: This is DMOJ problem `saco08p3`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 `saco08p3`。
- en: '*The Problem*'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题*'
- en: Bruce is planning a trip to his grandma’s house. There are *n* towns, numbered
    1 to *n*. Bruce starts in Town 1, and his grandma lives in Town *n*. Between each
    pair of towns is a road, and we’re given the length (distance) of each road.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Bruce 正在计划去奶奶家旅行。那里有 *n* 个城镇，编号为 1 到 *n*。Bruce 从城镇 1 出发，他的奶奶住在城镇 *n*。每对城镇之间都有一条道路，并且我们给出了每条道路的长度（距离）。
- en: Bruce wishes to arrive at his grandma’s with a box of cookies, so he must buy
    it along the way. Some of the towns have cookie stores; Bruce is required to hit
    at least one of these cookie towns on his way to his grandma’s.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 布鲁斯希望带着一盒饼干到达奶奶家，因此他必须在途中购买饼干。一些镇有饼干店；布鲁斯必须至少经过一个饼干镇才能到达奶奶家。
- en: Our task is twofold. First, we must determine the minimum distance needed for
    Bruce to get from his starting point to his grandma’s house, picking up a box
    of cookies along the way. That minimum distance does not tell us how many options
    Bruce has for getting to his grandma’s. Maybe there’s only one way that he can
    do it, with all other routes requiring greater distance, or maybe there are several
    routes all with the same minimum distance. So, second, we’re asked to determine
    the number of these minimum-distance routes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务有两个方面。首先，我们必须确定布鲁斯从起点到奶奶家的最短距离，并且途中必须经过至少一个饼干店。这个最短距离并没有告诉我们布鲁斯有多少种路径可以到达奶奶家。也许只有一种方法可以做到，所有其他路径都需要更长的距离，或者可能有几条路径，它们的最短距离是相同的。因此，第二个任务是确定这些最短路径的数量。
- en: Input
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input contains one test case, consisting of the following lines:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含一个测试用例，由以下几行组成：
- en: A line containing *n*, the number of towns. Towns are numbered 1 to *n*. There
    are between 2 and 700 towns.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含 *n*，即镇的数量。镇的编号从 1 到 *n*。镇的数量介于 2 到 700 之间。
- en: '*n* lines, each containing *n* integers. The first of these lines gives the
    road distance from Town 1 to each town (Town 1, then Town 2, and so on); the second
    of these lines gives the road distance from Town 2 to each town; and so on. The
    distance from a town to itself is zero; each other distance is at least one. The
    distance from Town *a* to Town *b* is the same as the distance from Town *b* to
    Town *a*.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 行，每行包含 *n* 个整数。第一行给出了从镇 1 到每个镇的道路距离（先是镇 1，再是镇 2，依此类推）；第二行给出了从镇 2 到每个镇的道路距离；依此类推。从一个镇到其自身的距离为零；其他每个距离至少为
    1。从镇 *a* 到镇 *b* 的距离与从镇 *b* 到镇 *a* 的距离相同。'
- en: A line containing *m*, the number of towns that have a cookie store. *m* is
    at least one.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含 *m*，即有饼干店的镇的数量。*m* 至少为 1。
- en: A line containing *m* integers, each giving the number of a town with a cookie
    store.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含 *m* 个整数，每个整数表示一个有饼干店的镇的编号。
- en: Output
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: 'Output the following on a single line:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在一行中输出以下内容：
- en: The minimum distance to get from Town 1 to Town *n* (picking up a box of cookies
    along the way)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从镇 1 到镇 *n* 的最短距离（途中经过饼干店）
- en: A space
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空格
- en: The number of minimum-distance routes, mod 1,000,000
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最短距离路径的数量，模 1,000,000
- en: The time limit for solving the test case is one second.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此测试用例的时间限制为一秒。
- en: '*Adjacency Matrix*'
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*邻接矩阵*'
- en: 'The way that the graph is represented here differs from that of the Mice Maze
    and that of the Book Translation problem in [Chapter 5](ch05.xhtml). In those
    two problems, each edge was supplied as one node, the other node, and the edge
    weight. For example, consider the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的图表示方式与 [第五章](ch05.xhtml)中的《老鼠迷宫》和《书籍翻译问题》不同。在这两个问题中，每条边都以一个节点、另一个节点和边权的形式提供。例如，考虑以下情况：
- en: '[PRE7]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This means that there’s an edge from Node 1 to Node 2 with weight 12.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着从节点 1 到节点 2 有一条边，边权为 12。
- en: In the Grandma Planner problem, the graph is presented as an *adjacency matrix*,
    which is a two-dimensional array of numbers where a given row, column coordinate
    gives us the weight of the edge at that row and column.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在《奶奶规划师问题》中，图是以 *邻接矩阵* 的形式表示的，邻接矩阵是一个二维数字数组，其中给定的行列坐标表示该行和列的边的权重。
- en: 'Here’s a sample test case:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例测试用例：
- en: '[PRE8]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `4` at the top tells us that there are four towns. The next four lines
    are the adjacency matrix. Let’s focus on the first of those lines:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的 `4` 告诉我们有四个镇。接下来的四行是邻接矩阵。让我们关注其中的第一行：
- en: '[PRE9]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This single line gives all of the edges leaving Town 1\. There’s an edge from
    Town 1 to Town 1 of weight `0`, from Town 1 to Town 2 of weight `3`, from Town
    1 to Town 3 of weight `8`, and from Town 1 to Town 4 of weight `2`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行给出了离开镇 1 的所有边。镇 1 到镇 1 的边权为 `0`，镇 1 到镇 2 的边权为 `3`，镇 1 到镇 3 的边权为 `8`，镇 1 到镇
    4 的边权为 `2`。
- en: The next line,
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行，
- en: '[PRE10]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: does similarly for Town 2, and so on.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，这对镇 2 也适用，依此类推。
- en: Notice that there’s an edge between any pair of towns; that is, there are no
    missing edges. Such a graph is called a *complete graph*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，任意一对镇之间都有边连接；也就是说，图中没有缺失的边。这样的图称为 *完全图*。
- en: This adjacency matrix has some redundancy. For example, it says in row 1, column
    3 that there’s an edge from Town 1 to Town 3 of weight `8`. However, since the
    problem specifies that the road from Town *a* to Town *b* is the same distance
    as that of the road from Town *b* to Town *a*, we see this `8` again in row 3,
    column 1\. (We’re therefore dealing with undirected graphs.) We also have `0`’s
    along the diagonal, which explicitly state that the distance from some town to
    itself is zero. We’ll just ignore those.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个邻接矩阵有一些冗余。例如，在第 1 行第 3 列，它表示从城镇 1 到城镇 3 的边权重为`8`。然而，由于问题中规定从城镇 *a* 到城镇 *b*
    的路程与从城镇 *b* 到城镇 *a* 的路程相同，因此我们在第 3 行第 1 列再次看到这个`8`。 （因此我们处理的是无向图。）我们在对角线也有`0`，这明确表示从某个城镇到其自身的距离为零。我们将忽略这些。
- en: '*Building the Graph*'
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*构建图形*'
- en: This problem is ultimately going to demand our creativity not once, but twice.
    First, we’ll need to force our paths through a town with a cookie store. Among
    those paths, we want the shortest one. Second, we’ll need to keep track not only
    of the shortest path but also of the number of ways we can realize that shortest
    path. Double the fun, I say!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题最终将要求我们展现创意，不是一次，而是两次。首先，我们需要强制让路径经过一个有饼干店的城镇。在这些路径中，我们要找到最短的一条。其次，我们需要跟踪的不仅是最短路径，还要统计有多少种方式可以实现最短路径。双倍的乐趣，我说！
- en: Let’s begin by reading the test case from the input and building the graph.
    We’re well positioned to do that at this point. With our graph in hand, we’ll
    then be ready for what lies ahead.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从输入中读取测试用例并构建图形。此时，我们已经准备好进行下一步了。有了图形后，我们将准备好处理接下来的问题。
- en: The plan is to read the adjacency matrix, building our adjacency lists as we
    go. We’ll have to keep track of the town indices ourselves, since the adjacency
    matrix doesn’t explicitly provide them.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 计划是读取邻接矩阵，在此过程中构建我们的邻接列表。由于邻接矩阵没有明确提供城镇的索引，我们需要自己跟踪这些索引。
- en: It’s possible to read in and use the adjacency matrix directly, avoiding the
    adjacency list representation altogether. Each row *i* gives the distance to each
    town, so we could just loop through row *i* in Dijkstra’s algorithm instead of
    looping through *i*’s adjacency list. Since the graph is complete, we wouldn’t
    even have to waste time skipping over edges that don’t exist. We’ll use adjacency
    lists here, however, for continuity with what we’ve already done.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 可以直接读取并使用邻接矩阵，完全避免使用邻接列表表示法。每一行 *i* 给出到每个城镇的距离，因此我们可以在 Dijkstra 算法中直接循环遍历第 *i*
    行，而不是循环遍历 *i* 的邻接列表。由于图是完全图，我们甚至不需要浪费时间跳过不存在的边。然而，为了与我们已经做过的保持一致，我们这里还是使用邻接列表。
- en: 'Here’s a constant and `edge` struct that we’ll use:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常量和`edge`结构体，我们将使用它：
- en: '[PRE11]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code for reading the graph is given in [Listing 6-3](ch06.xhtml#ch06ex03).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 读取图形的代码见于[列表 6-3](ch06.xhtml#ch06ex03)。
- en: '[PRE12]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 6-3: The* main *function for building the graph*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-3：构建图形的* 主 *函数*'
- en: After reading the number of towns, we use a double `for` loop to read the adjacency
    matrix. Each iteration of the outer `for` loop ➊ is responsible for reading one
    row, specifically, the row for `from_town`. To read that row, we have an inner
    `for` loop, which reads one `length` value for each `to_town`. So now we know
    where the edge starts, where the edge ends, and the length of the edge. We then
    want to add the edge, but only if it’s not one of those 0-weight edges that go
    from a town back to itself. If the edge is between distinct towns ➋, then we add
    it to the adjacency list for `from_town`. Because the graph is undirected, we
    must also ensure that eventually this edge is added to the adjacency list for
    `to_town`. We had to do that explicitly in [Listing 5-16](ch05.xhtml#ch05ex016)
    when solving the Book Translation problem. We don’t have to do that here, though,
    because it’ll get added later without us doing anything special when we process
    the row for `to_town`. For example, if `from_town` is `1` and `to_town` is `2`,
    then the 1 *→* 2 edge will be added now. Later, when `from_town` is `2` and `to_town`
    is `1`, then the 2 *→* 1 edge will be added.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 读取城镇数量后，我们使用一个双重`for`循环来读取邻接矩阵。外层`for`循环的每次迭代➊负责读取一行，具体来说，就是读取`from_town`这一行。为了读取该行，我们有一个内层`for`循环，它会读取每个`to_town`的`length`值。现在我们知道了边的起始点、终点以及边的长度。接下来，我们想要添加这条边，但前提是它不是从某个城镇返回到自身的0权重边。如果这条边是连接两个不同城镇➋的，那么我们就将它添加到`from_town`的邻接表中。由于图是无向图，我们还必须确保这条边最终会被添加到`to_town`的邻接表中。在[Listing
    5-16](ch05.xhtml#ch05ex016)中解决“书籍翻译”问题时，我们必须显式地这么做。但在这里，我们不需要这么做，因为当我们处理`to_town`的这一行时，它会在后续自动被添加。举个例子，如果`from_town`是`1`且`to_town`是`2`，那么1
    *→* 2的边现在会被添加。稍后，当`from_town`是`2`且`to_town`是`1`时，2 *→* 1的边会被添加。
- en: All that’s left is to read the information about which towns have cookie stores,
    starting with the number of such towns ➌. To keep track of these towns, we use
    array `store`, where `store[i]` is `1` (true) if Town `i` has a cookie store and
    `0` (false) if it does not.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来只需要读取哪些城镇有饼干店的信息，从有饼干店的城镇数量➌开始。为了跟踪这些城镇，我们使用数组`store`，其中`store[i]`为`1`（真）表示城镇`i`有饼干店，为`0`（假）表示没有饼干店。
- en: '*Working Through a Weird Test Case*'
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*处理一个奇怪的测试案例*'
- en: Let’s get a feel for the problem by working through the test case from “Adjacency
    Matrix” on [page 214](ch06.xhtml#sec91). The corresponding graph is provided in
    [Figure 6-4](ch06.xhtml#ch06fig04), where **c** represents a cookie town.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过处理“邻接矩阵”中的测试案例来更好地理解这个问题，见[第214页](ch06.xhtml#sec91)。对应的图形在[图6-4](ch06.xhtml#ch06fig04)中给出，其中**c**代表饼干城镇。
- en: '![Image](../images/ch06fig04.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch06fig04.jpg)'
- en: '*Figure 6-4: The grandma graph*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：奶奶图*'
- en: Bruce starts in Town 1 and has to get to Town 4\. Town 2 is the only town with
    a cookie store. What’s the shortest-distance path? While it’s true that Bruce
    can zip from Town 1 directly to Town 4 along the edge of distance 2, that isn’t
    a feasible solution to the problem. Remember that we need to ensure that a town
    with a cookie store is included in any proposed shortest path. For this particular
    graph, this means that we must include Town 2\. (In other test cases, there could
    be multiple towns that have cookie stores; what we’d need to do is include one
    or more of them.)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Bruce从城镇1出发，必须到达城镇4。城镇2是唯一有饼干店的城镇。最短路径是多少？虽然Bruce可以直接从城镇1飞速到达城镇4，沿途经过距离为2的边，但这不是问题的可行解。记住，我们需要确保任何拟议的最短路径都必须包含一个有饼干店的城镇。对于这个特定的图形，这意味着我们必须包括城镇2。（在其他测试案例中，可能会有多个城镇有饼干店；我们需要做的是包括一个或多个这样的城镇。）
- en: 'Here’s a path from Town 1 to Town 4 that *is* feasible: 1 *→* 2 (distance 3)
    *→* 4 (distance 1). That’s a total distance of 4, and it is indeed a shortest
    path from Town 1 to Town 4 that passes through Town 2.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个从城镇1到城镇4的可行路径：1 *→* 2（距离3） *→* 4（距离1）。这条路径的总距离是4，确实是从城镇1到城镇4的最短路径，且经过了城镇2。
- en: 'That’s not the only optimal path, though. There’s one more, and here it is:
    1 *→* 4 (distance 2) *→* 2 (distance 1) *→* 4 (distance 1). What’s a little weird
    about this path is that we visit Town 4, grandma’s house, *twice*. We start by
    going from Town 1 to Town 4, but we cannot end the path there because we don’t
    have the box of cookies yet. Then we go from Town 4 to Town 2, where we pick up
    the box of cookies. Finally, we go from Town 2 to Town 4, which is our second
    visit to Town 4, but this time we arrive with the box of cookies, and so we have
    a feasible path.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这并不是唯一的最优路径。还有一条路径，正如下所示：1 *→* 4（距离2）*→* 2（距离1）*→* 4（距离1）。这个路径有点奇怪，因为我们访问了城镇4，也就是奶奶的家，*两次*。我们首先从城镇1到城镇4，但不能在这里结束路径，因为我们还没有拿到饼干盒。然后我们从城镇4到城镇2，拿到了饼干盒。最后我们从城镇2到城镇4，这是我们第二次访问城镇4，不过这次我们带着饼干盒，因此我们得到了一个可行的路径。
- en: 'It does seem that this path is cyclic, since we get to Town 4 once and then
    get to Town 4 again. Viewed in a different light, however, there is no cycle at
    all. When we visited Town 4 the first time, we had no box of cookies; when we
    visited Town 4 again, we had a box of cookies. These two visits are therefore
    not repeats: it’s true that Town 4 was visited twice, but it is also true that
    the state (not carrying a box of cookies versus carrying a box of cookies) differs
    each time.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来这条路径是有环的，因为我们先到达城镇4，然后又再次到达城镇4。然而，从另一个角度来看，这根本没有环。当我们第一次访问城镇4时，手里没有饼干盒；当我们第二次访问城镇4时，手里有了饼干盒。因此这两次访问并不是重复的：虽然城镇4被访问了两次，但每次的状态（是否携带饼干盒）是不同的。
- en: Now we see that the same town can’t possibly be visited more than twice. If
    a town is visited three times, for example, then two of those visits must be in
    the same state. Perhaps Visit 1 and Visit 2 were both in the “not carrying a box
    of cookies” state. Then that really is a cycle, and it costs us some distance
    to traverse the cycle, so removing it gives a shorter path.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到，同一个城镇最多只能访问两次。如果一个城镇被访问了三次，那么这三次访问中必须有两次发生在同一状态下。也许访问1和访问2都处于“没有拿饼干盒”状态。那就真的形成了一个环，而我们需要花费一定的距离来遍历这个环，所以去掉它会缩短路径。
- en: It’s not sufficient, then, to know which town we’re in. We also need to know
    whether or not a box of cookies has been picked up.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，知道我们在哪个城镇是不够的。我们还需要知道是否已经拿到饼干盒。
- en: We’ve wrestled with this kind of problem once before, when solving Rope Climb
    in [Chapter 5](ch05.xhtml). There, we discussed adding a second rope to produce
    a more suitable model of the problem. We’re going to reprise that idea here, by
    adding a state that tells us whether or not a box of cookies is being carried.
    In State 0, no box of cookies is being carried; in State 1, a box of cookies is
    being carried. A feasible path, then, is any path that arrives at grandma’s house
    in State 1\. Arriving at grandma’s house in State 0 cannot be the end of a feasible
    path.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前曾经遇到过类似的问题，解决过《第5章》的绳子攀爬问题。[在第5章](ch05.xhtml)中，我们讨论了增加第二根绳子来得到一个更合适的模型。我们将在这里重温这个想法，通过添加一个状态来告诉我们是否正在携带饼干盒。在状态0中，不携带饼干盒；在状态1中，携带饼干盒。一个可行的路径是指任何到达奶奶家时处于状态1的路径。到达奶奶家时如果处于状态0，那就不能算作可行路径的结束。
- en: Take a look at [Figure 6-5](ch06.xhtml#ch06fig05), which introduces a cookie
    state to [Figure 6-4](ch06.xhtml#ch06fig04). Again, **c** represents a cookie
    town. The edges with no arrows are undirected, but now we have some directed edges,
    too.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 看一看[图6-5](ch06.xhtml#ch06fig05)，它在[图6-4](ch06.xhtml#ch06fig04)的基础上引入了饼干状态。再次说明，**c**表示一个饼干城镇。没有箭头的边是无向的，但现在我们也有一些有向边。
- en: '![Image](../images/ch06fig05.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch06fig05.jpg)'
- en: '*Figure 6-5: A grandma graph with a cookie state*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：带有饼干状态的奶奶图*'
- en: 'Here’s what we do to create this graph:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们创建这个图的步骤：
- en: Add four new town nodes, one for each original town in the graph. The original
    nodes are in State 0; the new nodes are in Sate 1.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加四个新的城镇节点，每个原始城镇对应一个新节点。原始节点位于状态0；新节点位于状态1。
- en: Keep all of the original edges, except for those leaving Town 2 (the town with
    the cookie store). If we reach Town 2 in State 0, then we’ve transitioned to State
    1, so the only edge leaving (2,0) is the directed edge to (2,1). It’s a 0-weight
    edge, because changing state takes no time. While Dijkstra’s algorithm can’t be
    trusted on graphs with negative-weight edges (see “Negative-Weight Edges” on [page
    211](ch06.xhtml#sec89)), 0-weight edges are okay.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留所有原始边，除了那些离开小镇2（有饼干店的小镇）的边。如果我们在状态0下到达小镇2，那么我们已经过渡到状态1，因此离开（2,0）的唯一边是指向（2,1）的有向边。它是一个0权重的边，因为更改状态不需要时间。虽然Dijkstra算法不能在含有负权边的图上信赖（请参阅[第211页](ch06.xhtml#sec89)中的“负权边”），但0权重的边是可以的。
- en: Connect nodes in State 1 using exactly the same edges that originally connected
    nodes in State 0.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用与原先连接状态0节点相同的边，连接状态1的节点。
- en: When we’re in State 0 and reach a town with a cookie store, we buy a box of
    cookies and end up in State 1\. Once we’re in State 1, the graph gives us no way
    to return to State 0, because there’s no way to lose the box of cookies.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处于状态0并到达一个有饼干店的小镇时，我们购买一盒饼干并最终到达状态1。一旦我们进入状态1，图中就没有办法返回状态0，因为没有办法丢失饼干盒。
- en: We start in Town 1, State 0\. We must arrive in Town 4, State 1\. This requires
    that we eventually move from State 0 to State 1 and then go to Town 4 using the
    State-1 edges. When there are multiple towns with cookie stores, the problem becomes
    increasingly tricky, because then we have to choose exactly which cookie town
    takes us from State 0 to State 1\. Well, it might be tricky for us, but not for
    Dijkstra’s algorithm, because we’re just asking for a shortest path in a graph.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从小镇1的状态0开始。我们必须到达小镇4的状态1。这要求我们最终从状态0过渡到状态1，然后通过状态1的边到达小镇4。当有多个小镇有饼干店时，问题变得越来越棘手，因为我们必须选择哪个饼干小镇将我们从状态0带到状态1。嗯，这对我们来说可能很棘手，但对Dijkstra算法来说却不是，因为我们只是在图中寻找最短路径。
- en: '*Task 1: Shortest Paths*'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*任务1：最短路径*'
- en: 'So far, we’ve talked about how to model the problem as a graph and find the
    shortest path distance, but not how to find the *number* of shortest paths. I’ll
    take these two subtasks in turn. At the end of this subsection, we’ll have solved
    half of the problem, correctly printing the shortest path distance. We won’t be
    printing anything for the number of paths, though, so we’ll still fail all of
    the test cases. Don’t worry: in the next subsection, we’ll work out how to coax
    the number of paths out of our code, too. It’s Dijkstra time!'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了如何将问题建模为图并找到最短路径距离，但还没有讨论如何找到最短路径的*数量*。我将依次处理这两个子任务。在这一小节的结尾，我们将解决问题的一半，正确打印最短路径距离。但对于路径数量，我们暂时不会打印任何内容，所以我们仍然会失败所有测试用例。别担心：在下一小节中，我们将研究如何从代码中引出路径的数量。是时候使用Dijkstra算法了！
- en: With our new model (using the States 0 and 1), the graph that we read from the
    input no longer corresponds to the graph that we’ll explore with Dijkstra’s algorithm.
    One idea is to produce the adjacency list representation of the new graph from
    the adjacency list for the original graph. That is, start with an empty graph
    that has twice the number of nodes and add all of the required edges. That can
    be done, but I think it’s easier to leave the graph alone, logically adding the
    state to the code for Dijkstra’s algorithm. (When solving the Rope Climb problem
    in [Chapter 5](ch05.xhtml), we didn’t have much of a choice of what to do, because
    the input did not contain a graph.)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新模型中（使用状态0和状态1），我们从输入读取的图不再对应于我们用Dijkstra算法探索的图。一个思路是从原始图的邻接表表示中生成新图的邻接表表示。也就是说，从一个空图开始，图中有两倍的节点数，并添加所有必需的边。虽然这样做是可行的，但我认为更简单的方法是保持图的原样，在Dijkstra算法的代码中逻辑上添加状态。（在解决[第五章](ch05.xhtml)中的绳索攀爬问题时，我们没有太多选择，因为输入没有包含图。）
- en: 'We’ll write the function with the following signature:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个函数，签名如下：
- en: '[PRE13]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, `adj_list` is the adjacency list, `num_towns` is the number of towns (and
    the number of grandma’s town), and `store` tells us for any given `i` whether
    town `i` has a cookie store.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`adj_list`是邻接表，`num_towns`是小镇的数量（也是奶奶的小镇数量），`store`告诉我们给定的`i`小镇是否有饼干店。
- en: Now we’ll proceed just as we did with the Mice Maze ([Listing 6-2](ch06.xhtml#ch06ex02)).
    At each step, however, we ask what effect the state has on our code and we make
    appropriate modifications. Let’s walk through the code, which is given in [Listing
    6-4](ch06.xhtml#ch06ex04). Compare this code to [Listing 6-2](ch06.xhtml#ch06ex02)
    to highlight the similarities.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将按照与老鼠迷宫（[Listing 6-2](ch06.xhtml#ch06ex02)）相同的方式进行。不过，在每一步，我们都会问状态对代码的影响，并做出相应的修改。让我们通过[Listing
    6-4](ch06.xhtml#ch06ex04)中的代码来一步步走过。将此代码与[Listing 6-2](ch06.xhtml#ch06ex02)进行对比，突出其中的相似性。
- en: '[PRE14]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 6-4: The shortest path to grandma’s using Dijkstra’s algorithm*'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-4：使用Dijkstra算法到奶奶家的最短路径*'
- en: Right from the start, we see the influence of the state on our arrays, as `done`
    and `min_distances` are now two-dimensional arrays. The first dimension is indexed
    by the town number, and the second is indexed by the state. In our initialization
    ➊, we’re careful to initialize the elements of both states.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，我们就看到了状态对我们数组的影响，因为`done`和`min_distances`现在是二维数组。第一维是按城镇编号索引的，第二维是按状态索引的。在我们的初始化
    ➊中，我们小心地初始化了两个状态的元素。
- en: Our starting point is Town 1, State 0, so that’s the distance that we initialize
    to `0` ➋.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的起点是城镇1，状态0，因此这是我们初始化为`0`的距离 ➋。
- en: As always, we want to continue running Dijkstra’s algorithm until no new nodes
    can be found. We have `num_towns` towns, but each one exists in both State 0 and
    State 1, so we have a maximum of `num_towns * 2` nodes to find ➌.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们希望继续运行Dijkstra算法，直到找不到新的节点。我们有`num_towns`个城镇，但每个城镇在状态0和状态1中都有，所以我们最多需要找到`num_towns
    * 2`个节点 ➌。
- en: 'The nested `state` and `j` loops together find the next node. When these loops
    are done ➍, two important variables will be set: `min_town_index` gives the index
    of the town, and `min_state_index` gives the index of the state.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的`state`和`j`循环一起找到下一个节点。当这些循环完成 ➍时，两个重要的变量将被设置：`min_town_index`给出城镇的索引，`min_state_index`给出状态的索引。
- en: Our next step depends on which state we’re in and whether the town has a cookie
    store. If we’re in State 0 and at a town with a cookie store ➎, then we ignore
    `adj_list` and consider only the transition to State 1\. Remember that the transition
    from `[min_town_index][0]` to `[min_town_index][1]` has distance `0`, so our new
    path to `[min_town_index][1]` has the same distance as the shortest path to `[min_town_index][0]`.
    In typical Dijkstra fashion, we update the shortest path if our new path is shorter.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步取决于我们所在的状态以及城镇是否有饼干店。如果我们处于状态0且位于有饼干店的城镇 ➎，那么我们忽略`adj_list`，仅考虑转换到状态1。记住，从`[min_town_index][0]`到`[min_town_index][1]`的转换距离为`0`，因此我们到`[min_town_index][1]`的新路径与到`[min_town_index][0]`的最短路径具有相同的距离。按照典型的Dijkstra方式，如果我们新路径更短，就更新最短路径。
- en: Otherwise, we’re in State 0 but not at a town with a cookie store, or we’re
    in State 1\. The available edges here are exactly those in the input graph from
    the current town, so we examine all edges from `min_town_index` ➏. Now we’re in
    Mice Maze territory, looking for new shorter paths using edge `e`. Just be careful
    to use `min_state_index` everywhere, since none of these edges changes the state.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们处于状态0，但不在有饼干店的城镇，或者我们处于状态1。此时，当前城镇的所有可用边正是输入图中的边，所以我们检查所有来自`min_town_index`的边
    ➏。现在，我们进入老鼠迷宫的领域，使用边`e`寻找新的更短路径。只需注意，在所有地方都使用`min_state_index`，因为这些边都不会改变状态。
- en: The final thing to do is print the shortest path distance ➐. We use `num_towns`
    as the first index (that’s grandma’s town) and `1` as the second index (so that
    a box of cookies is being carried).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是打印最短路径距离 ➐。我们使用`num_towns`作为第一个索引（这是奶奶的城镇），并使用`1`作为第二个索引（表示一个饼干盒正在被携带）。
- en: If you run our program on the test case from “Adjacency Matrix” on [page 214](ch06.xhtml#sec91),
    you should get the correct output of `4`. Indeed, for any test case, we’ll output
    the shortest path. Now, let’s move on to the number of shortest paths.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在“邻接矩阵”一节的测试案例上运行我们的程序（见[第214页](ch06.xhtml#sec91)），你应该得到正确的输出`4`。实际上，对于任何测试案例，我们都会输出最短路径。接下来，让我们讨论最短路径的数量。
- en: '*Task 2: Number of Shortest Paths*'
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*任务2：最短路径的数量*'
- en: It takes just a few changes to beef up Dijkstra’s algorithm so that it finds
    not only the shortest path distance, but also the number of shortest paths. Those
    changes are subtle, so I’ll begin by working a few steps of an example to give
    you some intuition about why what we’re doing makes sense. I’ll then show the
    new code before giving a more detailed correctness argument.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 只需进行几处修改，就能增强 Dijkstra 算法，使其不仅找到最短路径的距离，还能找到最短路径的数量。这些修改很微妙，因此我将先通过几个步骤的例子，给你一些直觉，帮助你理解我们所做的修改为什么是合理的。然后，我会展示新的代码，并给出更详细的正确性证明。
- en: Working Through an Example
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 通过一个例子来讲解
- en: Let’s trace Dijkstra’s algorithm on [Figure 6-5](ch06.xhtml#ch06fig05) from
    node (1,0). In addition to tracking whether each node is done and the minimum
    distance to each node, we’ll also keep *num_paths*, giving the number of shortest
    paths of minimum distance to the node. We’ll see that those paths counted by *num_paths*
    get thrown away whenever a shorter path is found.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从节点 (1,0) 开始，追踪 [图 6-5](ch06.xhtml#ch06fig05) 上的 Dijkstra 算法。除了跟踪每个节点是否完成以及到每个节点的最短距离外，我们还会跟踪
    *num_paths*，即到该节点的最短路径数量。我们将看到，每当找到一条更短的路径时，由 *num_paths* 计算的路径会被丢弃。
- en: 'To begin, we initialize the state for the starting node (1, 0). We set its
    minimum distance to 0 and set it to be done. As there’s exactly one path of distance
    0 from the starting node to itself (the path of no edges), we set its number of
    paths to 1\. We use the edges from the starting node to initialize the other nodes,
    and we set each of them to have one path (the path from the starting node). This
    gives us our first snapshot:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们初始化起始节点 (1, 0) 的状态。我们将其最短距离设置为 0，并标记为已完成。由于从起始节点到自身有一条距离为 0 的路径（即没有边的路径），因此我们将其路径数量设置为
    1。然后，我们使用从起始节点出发的边来初始化其他节点，并将每个节点的路径数量设置为 1（即从起始节点出发的路径）。这就是我们的第一个快照：
- en: '| ***node*** | ***done*** | ***min_distance*** | ***num_paths*** |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| ***node*** | ***done*** | ***min_distance*** | ***num_paths*** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| (1,0) | true | 0 | 1 |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| (1,0) | true | 0 | 1 |'
- en: '| (2,0) | false | 3 | 1 |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| (2,0) | false | 3 | 1 |'
- en: '| (3,0) | false | 8 | 1 |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| (3,0) | false | 8 | 1 |'
- en: '| (4,0) | false | 2 | 1 |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| (4,0) | false | 2 | 1 |'
- en: '| (1,1) | false |  |  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| (1,1) | false |  |  |'
- en: '| (2,1) | false |  |  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| (2,1) | false |  |  |'
- en: '| (3,1) | false |  |  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| (3,1) | false |  |  |'
- en: '| (4,1) | false |  |  |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| (4,1) | false |  |  |'
- en: 'Now what? Well, as always with Dijkstra’s algorithm, we scan through the nodes
    that are not done and choose one with minimum *min_distance* value. We therefore
    choose node (4,0). Dijkstra’s algorithm guarantees that this node has its shortest
    path set, so we can set it to done. Then, we must check the edges leaving (4,0)
    to see whether we can find shorter paths to other nodes. We can indeed find a
    shorter path to (3,0): before it was 8, but now it’s 7, because we can get to
    (4,0) with distance 2, and then from (4,0) to (3,0) with distance 5\. What do
    we put for the number of shortest paths to (3,0)? Well, it used to be 1, so it’s
    tempting to make it 2\. However, 2 is wrong, because that would count the path
    of distance 8, and that’s no longer a shortest path. The answer is 1, because
    there’s only one path of distance 7.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来怎么办？如同 Dijkstra 算法的惯例，我们会扫描未完成的节点，并选择一个具有最小 *min_distance* 值的节点。因此，我们选择节点
    (4,0)。Dijkstra 算法保证该节点的最短路径已经确定，因此我们可以将其标记为已完成。然后，我们必须检查从 (4,0) 出发的边，看看是否能找到到其他节点的更短路径。我们确实找到了到
    (3,0) 的更短路径：之前是 8，但现在是 7，因为我们可以先到达 (4,0)（距离为 2），然后再从 (4,0) 到 (3,0)（距离为 5）。那么，(3,0)
    的最短路径数量应该是多少呢？它原来是 1，因此很容易想到把它设置为 2。然而，2 是错误的，因为这样会计算原来距离为 8 的路径，而那不再是最短路径。正确的答案是
    1，因为只有一条距离为 7 的路径。
- en: There’s an edge from (4,0) to (2,0) that we shouldn’t dismiss too quickly. The
    old shortest path to (2,0) was 3\. What does the edge from (4,0) to (2,0) do for
    us? Does it give us a shorter path? Well, the distance to (4,0) is 2, and the
    edge from (4,0) to (2,0) has distance 1, so we have a new way to get to (2,0)
    with distance 3\. That’s not a shorter path, but it is *another* shortest path!
    That is, getting to (4,0) and then using the edge to (2,0) gives us new ways to
    get to (2,0). The number of new ways is the number of shortest paths to (4,0),
    which is just one. That gives us 1 + 1 = 2 shortest paths to get to (2,0).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 从 (4,0) 到 (2,0) 有一条边，我们不应该太快忽略它。到 (2,0) 的旧最短路径是 3。那么，(4,0) 到 (2,0) 的边为我们带来了什么？它给我们提供了一条更短的路径吗？好吧，(4,0)
    的距离是 2，而从 (4,0) 到 (2,0) 的边的距离是 1，因此我们有了一种新的到达 (2,0) 的方法，距离是 3。这不是一条更短的路径，但它是 *另一条*
    最短路径！也就是说，先到达 (4,0)，然后通过边到 (2,0) 给我们提供了到达 (2,0) 的新方法。新的方法数量等于到 (4,0) 的最短路径数量，即只有一条。因此，得到
    (2,0) 的最短路径总数是 1 + 1 = 2 条。
- en: 'This is all summarized in the next snapshot:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切总结在下一个快照中：
- en: '| ***node*** | ***done*** | ***min_distance*** | ***num_paths*** |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***已完成*** | ***最小距离*** | ***路径数量*** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| (1,0) | true | 0 | 1 |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| (1,0) | true | 0 | 1 |'
- en: '| (2,0) | false | 3 | 2 |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| (2,0) | false | 3 | 2 |'
- en: '| (3,0) | false | 7 | 1 |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| (3,0) | false | 7 | 1 |'
- en: '| (4,0) | true | 2 | 1 |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| (4,0) | true | 2 | 1 |'
- en: '| (1,1) | false |  |  |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| (1,1) | false |  |  |'
- en: '| (2,1) | false |  |  |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| (2,1) | false |  |  |'
- en: '| (3,1) | false |  |  |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| (3,1) | false |  |  |'
- en: '| (4,1) | false |  |  |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| (4,1) | false |  |  |'
- en: 'The next node that’s done is (2,0). There’s an edge of weight 0 from (2,0)
    to (2,1), and it takes distance 3 to get to (2,0), so we have a shortest path
    of distance 3 to (2,1) as well. There are two ways to get to (2,0) with that minimum
    distance, so there are two ways to get to (2,1) as well. Here’s what we’ve got
    now:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步完成的节点是(2,0)。从(2,0)到(2,1)有一条权重为0的边，而且从(2,0)到达(2,1)的距离是3，因此我们也有一条到(2,1)的最短路径，距离为3。到(2,0)的最短路径有两种方式，所以到(2,1)也有两种方式。现在的情况如下：
- en: '| ***node*** | ***done*** | ***min_distance*** | ***num_paths*** |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***已完成*** | ***最小距离*** | ***路径数量*** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| (1,0) | true | 0 | 1 |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| (1,0) | true | 0 | 1 |'
- en: '| (2,0) | true | 3 | 2 |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| (2,0) | true | 3 | 2 |'
- en: '| (3,0) | false | 7 | 1 |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| (3,0) | false | 7 | 1 |'
- en: '| (4,0) | true | 2 | 1 |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| (4,0) | true | 2 | 1 |'
- en: '| (1,1) | false |  |  |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| (1,1) | false |  |  |'
- en: '| (2,1) | false | 3 | 2 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| (2,1) | false | 3 | 2 |'
- en: '| (3,1) | false |  |  |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| (3,1) | false |  |  |'
- en: '| (4,1) | false |  |  |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| (4,1) | false |  |  |'
- en: 'The next node that’s done is (2,1), and it is this node that finds the shortest
    path distance to our destination (4,1). There are two shortest paths to (2,1),
    so there are two shortest paths to (4,1) as well. Node (2,1) also finds new shortest
    paths to (1,1) and (3,1). Here’s what we’ve got now:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步完成的节点是(2,1)，正是这个节点找到了到目的地(4,1)的最短路径距离。从(2,1)到(2,1)有两条最短路径，所以到(4,1)也有两条最短路径。节点(2,1)还找到到(1,1)和(3,1)的新最短路径。现在的情况如下：
- en: '| ***node*** | ***done*** | ***min_distance*** | ***num_paths*** |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| ***节点*** | ***已完成*** | ***最小距离*** | ***路径数量*** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| (1,0) | true | 0 | 1 |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| (1,0) | true | 0 | 1 |'
- en: '| (2,0) | true | 3 | 2 |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| (2,0) | true | 3 | 2 |'
- en: '| (3,0) | false | 7 | 1 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| (3,0) | false | 7 | 1 |'
- en: '| (4,0) | true | 2 | 1 |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| (4,0) | true | 2 | 1 |'
- en: '| (1,1) | false | 6 | 2 |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| (1,1) | false | 6 | 2 |'
- en: '| (2,1) | true | 3 | 2 |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| (2,1) | true | 3 | 2 |'
- en: '| (3,1) | false | 5 | 2 |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| (3,1) | false | 5 | 2 |'
- en: '| (4,1) | false | 4 | 2 |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| (4,1) | false | 4 | 2 |'
- en: 'Node (4,1) is the next one out, so we have our answer: the shortest path is
    4 and the number of shortest paths is 2\. (In our code we won’t have a stopping
    criterion here at the destination, so Dijkstra’s algorithm would keep going, finding
    shortest paths and number of shortest paths for other nodes. I encourage you to
    persevere with this example until the end.)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 节点(4,1)是下一个出列的节点，因此我们得到了答案：最短路径是4，最短路径数量是2。（在我们的代码中，目的地处不会有停止条件，所以Dijkstra算法会继续执行，为其他节点找到最短路径和最短路径数量。我鼓励你坚持完成这个例子，直到最后。）
- en: 'That’s how the algorithm works. It can be summarized by two rules:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，算法的工作原理。可以通过两个规则总结如下：
- en: '**Rule 1**   Suppose that we use Node *u* to find a shorter path to Node *v*.
    Then the number of shortest paths to *v* is the number of shortest paths to *u*.
    (All of the old paths to *v* are invalidated and no longer count, because we now
    know that they are not shortest paths.)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 1** 假设我们使用节点*u*找到到节点*v*的更短路径。那么，到*v*的最短路径数量就是到*u*的最短路径数量。（所有以前到*v*的路径都无效，并且不再计算，因为我们现在知道它们不是最短路径。）'
- en: '**Rule 2**   Suppose that we use Node *u* to find a path to Node *v* that’s
    the same distance as the current shortest path to *v*. Then the number of paths
    to *v* is the number of shortest paths that we already had for *v*, plus the number
    of shortest paths to *u*. (All of the old paths to *v* still count.)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 2** 假设我们使用节点*u*找到到节点*v*的路径，并且该路径的距离与当前到*v*的最短路径相同。那么，到*v*的路径数量就是我们已经为*v*找到的最短路径数量，加上到*u*的最短路径数量。（所有以前到*v*的路径仍然有效。）'
- en: 'Suppose that we focus on some node *n* and watch what happens to its minimum
    distance and number of shortest paths as it runs. We don’t know what the shortest
    path to *n* will be: we might have its shortest path now, or Dijkstra’s algorithm
    might find a shorter one later. If we have its shortest path now, then we had
    better accumulate the number of shortest paths to *n*, since we may ultimately
    need that value to compute the number of shortest paths for other nodes. If we
    don’t have its shortest path now, then in retrospect we’ll have pointlessly accumulated
    its number of shortest paths. That’s okay, though, because we’ll just reset the
    number of shortest paths anyway when we find a shorter path.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们关注某个节点*n*，并观察在运行过程中它的最短距离和最短路径数量的变化。我们并不知道通往*n*的最短路径是什么：现在可能已经有了最短路径，也可能后来Dijkstra算法会找到一条更短的路径。如果我们现在已经有了最短路径，那么最好将通往*n*的最短路径数量累积起来，因为最终我们可能需要这个值来计算其他节点的最短路径数量。如果现在没有最短路径，那么回过头来看，我们可能会无意义地累积了最短路径数量。不过没关系，因为当我们找到更短的路径时，我们会重置最短路径数量。
- en: The Code
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码
- en: To solve this task, we can start with [Listing 6-4](ch06.xhtml#ch06ex04) and
    make the changes necessary to find the number of shortest paths. The updated code
    is given in [Listing 6-5](ch06.xhtml#ch06ex05).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个任务，我们可以从[清单6-4](ch06.xhtml#ch06ex04)开始，并进行必要的更改以找到最短路径的数量。更新后的代码可以在[清单6-5](ch06.xhtml#ch06ex05)中找到。
- en: '[PRE15]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 6-5: The shortest path and number of shortest paths to grandma’s*'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-5：到奶奶家的最短路径和最短路径数量*'
- en: I added a `num_paths` array that tracks the number of paths that we’ve found
    for each node ➊ and set all of its elements to `0` ➋. The only nonzero element
    in `num_paths` is for our starting node (1,0), which has one path of distance
    0 (the path that begins at the starting node and follows no edges) ➌.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了一个`num_paths`数组，用来跟踪我们为每个节点找到的路径数量 ➊，并将其所有元素初始化为`0` ➋。`num_paths`中唯一不为零的元素是我们的起始节点(1,0)，它的路径数量为1，距离为0（即从起始节点开始并没有经过任何边的路径）
    ➌。
- en: The remaining new work is to update `num_paths`. As we’ve discussed, there are
    two cases. If we find a shorter path, then the old number of paths no longer counts.
    If we find another way to reach a node using its current path distance, then we
    add to the old number of paths. It’s that second case that can trip us up if we’re
    not careful, because we need to include an equality check in addition to a greater-than
    check ➍. If we used exactly the code that we’ve used throughout the chapter,
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作是更新`num_paths`。如我们所讨论的，有两种情况。如果我们找到一条更短的路径，那么旧的路径数量就不再有效。如果我们找到另一条路径，它的当前路径距离相同，那么我们就将旧的路径数量加上。这第二种情况如果不小心就会出错，因为我们需要在检查“大于”的同时，还需要加入等于的检查
    ➍。如果我们一直使用本章中用到的代码，
- en: '[PRE16]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: then the number of paths to a node would only be updated when a shorter path
    was found; there would be no way to accumulate shortest paths from multiple sources.
    Instead, we use `>=` rather than `>`
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，只有在找到更短的路径时，路径数量才会更新；无法从多个源累积最短路径。相反，我们使用`>=`而不是`>`。
- en: '[PRE17]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: so that we can find more shortest paths, even if the shortest path itself does
    not change.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以找到更多的最短路径，即使最短路径本身没有变化。
- en: Now we can implement exactly the two cases that we’ve discussed for updating
    the number of paths. We have to do these cases twice, because there are two places
    in the code where Dijkstra’s algorithm can find shortest paths. The first addition
    ➎ is to the code that follows a 0-weight edge from State 0\. If the shortest path
    is the same as before, we add; if there’s now a new shorter path, we reset. The
    second addition of essentially the same code ➐ is added to the code for looping
    through the edges leaving the current node. In both cases, we use the mod operator
    ➏ ➑ to keep us under 1,000,000 shortest paths.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以准确地实现我们之前讨论的两种更新路径数量的情况。我们必须执行这两种情况两次，因为代码中有两个地方，Dijkstra算法可能会找到最短路径。第一个添加
    ➎ 是针对从状态0开始的0权重边的代码。如果最短路径与之前相同，我们就加上；如果现在有了新的更短路径，我们就重置。第二个相同的代码添加 ➐ 是针对循环遍历当前节点的出边的代码。在这两种情况下，我们都使用模运算符
    ➏ ➑ 来确保路径数不超过1,000,000。
- en: The final required change is to update the `printf` call at the end ➒, now also
    printing the number of shortest paths to grandma’s.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 最终需要做的更改是在最后更新`printf`调用 ➒，现在它也会打印到奶奶家的最短路径数量。
- en: You’re ready to submit to the judge. Let’s discuss a little bit about correctness
    before we wrap up for good.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好提交给评审了。在我们最终总结之前，先讨论一下正确性。
- en: Algorithm Correctness
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 算法正确性
- en: There are no negative-weight edges in our Grandma Planner graphs, so we know
    that Dijkstra’s algorithm will correctly find all shortest path distances. There
    are some 0-weight edges—one from each cookie town in State 0 to the corresponding
    town in State 1—but Dijkstra’s algorithm copes just fine with those when finding
    shortest paths.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Grandma Planner 图中没有负权边，所以我们知道 Dijkstra 算法会正确地找到所有最短路径距离。图中有一些 0 权重的边——每个饼干城镇从状态
    0 到对应的状态 1 的城镇之间都有这样的边——但是 Dijkstra 算法在找到最短路径时处理这些边没有问题。
- en: 'However, we must carefully think through the implications of 0-weight edges
    on finding the *number* of shortest paths. If we allow arbitrary 0-weight edges,
    then there may be an *infinite* number of shortest paths. Take a look at [Figure
    6-6](ch06.xhtml#ch06fig06), where we have 0-weight edges from A to B, B to C,
    and C to A. The shortest path from A to C, for example, is 0, and we have an infinite
    number of such paths: A *→* B *→* C, A *→* B *→* C *→* A *→* B *→* C, and so on.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们必须仔细思考 0 权重边对找到最短路径“数量”的影响。如果我们允许任意的 0 权重边，那么可能会有一个 *无限* 多的最短路径。看看 [图 6-6](ch06.xhtml#ch06fig06)，其中我们有从
    A 到 B、从 B 到 C 和从 C 到 A 的 0 权重边。例如，从 A 到 C 的最短路径是 0，我们有无限多这样的路径：A *→* B *→* C，A
    *→* B *→* C *→* A *→* B *→* C，依此类推。
- en: '![Image](../images/ch06fig06.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch06fig06.jpg)'
- en: '*Figure 6-6: A graph with an infinite number of shortest paths*'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：一个具有无限多最短路径的图*'
- en: Luckily, cycles of 0-weight edges cannot actually present themselves in Grandma
    Planner graphs. Remember that all road distances are at least one. Suppose that
    there were a 0-weight edge from Node *u* to Node *v*. This means that *u* is in
    State 0 and *v* is in State 1\. We can never get from *v* back to *u*, because
    our graphs provide no way to move from State 1 back to State 0.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，0 权重边的循环在 Grandma Planner 图中实际上不会出现。记住，所有的道路距离至少是 1。假设从节点 *u* 到节点 *v* 存在一条
    0 权重的边。这意味着 *u* 在状态 0，*v* 在状态 1。我们永远无法从 *v* 返回到 *u*，因为我们的图没有提供从状态 1 返回状态 0 的方法。
- en: 'I’ll end by arguing the following: once a node is set to done, we have found
    its total number of shortest paths. Consider a run of our algorithm where it gives
    the wrong number of shortest paths. Our algorithm hums along, finding shortest
    paths and the number of shortest paths . . . and then, boom, it makes a mistake
    for the first time. It sets some node *n* to done, but it’s missed finding some
    of its shortest paths. We need to argue that this mistake cannot arise.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我要提出以下观点：一旦节点被设置为完成，我们就已经找到了它的最短路径总数。考虑一个算法执行过程，其中它给出了错误的最短路径数。我们的算法正常运行，找到最短路径和最短路径数量……然后，突然，它第一次出错。它将某个节点
    *n* 设置为完成，但它错过了找出其中一些最短路径。我们需要证明这个错误是不会发生的。
- en: Suppose that some shortest paths to *n* end with some edge *m* *→* *n*. If *m*
    *→* *n* has a weight greater than 0, then the shortest path to *m* is shorter
    than the shortest path to *n*. (It’s the shortest path to *n* minus the weight
    of *m* *→* *n*.) Dijkstra’s algorithm works by finding nodes that are further
    and further from the starting node, so Node *m* must be done by this point. When
    Dijkstra’s algorithm set *m* to done, it would have gone through all edges from
    *m*, including *m* *→* *n*. Since *m*’s number of paths was set correctly (*m*
    is done, and Dijkstra’s algorithm hadn’t made its mistake yet), Dijkstra’s algorithm
    includes all of those paths in *n*’s path count.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 假设某些最短路径到 *n* 以某条边 *m* *→* *n* 结束。如果 *m* *→* *n* 的权重大于 0，那么到 *m* 的最短路径比到 *n*
    的最短路径要短。（这就是到 *n* 的最短路径减去 *m* *→* *n* 的权重。）Dijkstra 算法通过找到越来越远的节点来工作，因此节点 *m*
    必须在此时被标记为完成。当 Dijkstra 算法将 *m* 设置为完成时，它会遍历所有从 *m* 出发的边，包括 *m* *→* *n*。由于 *m* 的路径数量已经正确设置（*m*
    已完成，且 Dijkstra 算法尚未犯错），Dijkstra 算法会将这些路径全部计入 *n* 的路径数中。
- en: Now, what if *m* *→* *n* is a 0-weight edge? We need *m* to be done before *n*;
    otherwise, *m*’s number of paths cannot be trusted when exploring the edges that
    leave *m*. We know that 0-weight edges go from a node in State 0 to a node in
    State 1, so *m* must be in State 0 and *n* must be in State 1\. The shortest path
    to *m* must be the same as the shortest path to *n*, since the 0-weight edge adds
    nothing to *m*’s shortest path. At some point, then, at the time when *m* and
    *n* are not done, Dijkstra’s algorithm will have to choose which of the two to
    next set to done. It had better choose *m*; and it will, because, as I’ve written
    the code, when there is a tie it chooses a node from State 0 rather than State
    1.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果 *m* *→* *n* 是一条0权重的边呢？我们需要先完成 *m*，然后才能完成 *n*；否则，当探索离开 *m* 的边时，*m* 的路径数量将不可信。我们知道，0权重的边是从状态0中的一个节点到状态1中的一个节点，因此
    *m* 必须在状态0中，*n* 必须在状态1中。到 *m* 的最短路径必须与到 *n* 的最短路径相同，因为0权重边对 *m* 的最短路径没有影响。那么，在某个时刻，当
    *m* 和 *n* 都未完成时，Dijkstra 算法将不得不选择下一个完成的节点。它最好选择 *m*；而它会选择 *m*，因为根据我写的代码，在存在平局的情况下，它会选择状态0中的节点，而不是状态1中的节点。
- en: 'We need to tread lightly: we’re really getting away with something here. Here’s
    a test case that exemplifies why we have to process State-0 nodes before State-1
    nodes:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要小心谨慎：我们实际上是在侥幸取巧。以下是一个测试用例，说明为什么我们必须先处理状态0节点，再处理状态1节点：
- en: '[PRE18]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Trace our modified Dijkstra’s algorithm on this example. If you have a choice
    of which node to next set to done, choose one from State 0\. If you do that, you’ll
    get the correct answer: a shortest path distance of four and four shortest paths.
    Then, trace the algorithm again, only this time break ties by choosing a node
    from State 1\. You’ll still get the correct shortest path distance of four, because
    Dijkstra’s algorithm is not sensitive to how ties are broken. But our modified
    Dijkstra’s algorithm is, witnessed by the fact that you should get two shortest
    paths rather than four.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中跟踪我们修改后的 Dijkstra 算法。如果你有选择下一个完成的节点的机会，选择一个来自状态0的节点。如果你这样做，你将得到正确的答案：最短路径距离为四，最短路径数量为四条。然后，再次跟踪算法，这次通过选择来自状态1的节点来打破平局。你仍然会得到正确的最短路径距离四，因为
    Dijkstra 算法对平局如何打破并不敏感。但我们修改后的 Dijkstra 算法是敏感的，证明这一点的是，你应该得到两条最短路径，而不是四条。
- en: Summary
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Dijkstra’s algorithm is designed to find shortest paths in graphs. We’ve seen
    in this chapter how to model a problem instance as a suitable weighted graph and
    then use Dijkstra’s algorithm. Moreover, Dijkstra’s algorithm, like BFS in [Chapter
    5](ch05.xhtml), can serve as a guide for solving related but distinct problems.
    In the Grandma Planner problem, we found the number of shortest paths by a suitable
    modification to Dijkstra’s algorithm. We didn’t have to start from scratch. We’re
    not always literally going to be asked for the shortest path. If Dijkstra’s algorithm
    were resolute, finding shortest paths and nothing else, then it would offer no
    help when contexts shift. Indeed, we’d have learned a powerful algorithm, but
    one of an all-or-nothing flavor. Fortunately, Dijkstra’s algorithm applies more
    broadly. If you continue with graph algorithms beyond what I’ve included in this
    book, you’ll likely see ideas from Dijkstra’s algorithm appear again. While there
    may be millions of problems out there, there are far fewer algorithms. The best
    algorithms are often the ones that rest on ideas so flexible that they can ooze
    beyond their intended purpose.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra 算法旨在寻找图中的最短路径。在本章中，我们已经了解了如何将问题实例建模为合适的加权图，然后使用 Dijkstra 算法。此外，Dijkstra
    算法像 [第五章](ch05.xhtml)中的广度优先搜索（BFS）一样，可以作为解决相关但不同问题的指南。在“祖母计划者”问题中，我们通过对 Dijkstra
    算法进行适当修改，找到了最短路径的数量。我们不需要从头开始。我们并不总是被要求找到最短路径。如果 Dijkstra 算法只是一个坚定不移的算法，只为寻找最短路径而设计，那它在上下文发生变化时就没有任何帮助。事实上，我们会学到一个强大的算法，但它的性质是非黑即白的。幸运的是，Dijkstra
    算法的应用范围更广。如果你继续研究图算法，超出本书所包含的内容，你很可能会再次看到 Dijkstra 算法的思想。尽管可能存在数百万个问题，但算法远少于此。最好的算法通常是那些基于灵活的思想的算法，它们可以超越最初的目的。
- en: Notes
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: Mice Maze is originally from the 2001 Southwestern Europe Regional Contest.
    Grandma Planner is originally from the 2008 South African Programming Olympiad,
    Final Round.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 老鼠迷宫问题最初来源于2001年西南欧洲区域赛。祖母计划者问题最初来自2008年南非编程奥林匹克赛决赛。
- en: For more about graph search and its many applications to competitive programming
    problems, I recommend *Competitive Programming 4* by Steven Halim and Felix Halim
    (2020).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多图搜索及其在竞争性编程问题中的应用，我推荐 Steven Halim 和 Felix Halim（2020）的 *《Competitive Programming
    4》*。
