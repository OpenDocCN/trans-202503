- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Foundations
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基础
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: As you dive into the more advanced corners of Rust, it’s important that you
    ensure you have a solid understanding of the fundamentals. In Rust, as in any
    programming language, the precise meaning of various keywords and concepts becomes
    important as you begin to use the language in more sophisticated ways. In this
    chapter, we’ll walk through many of Rust’s primitives and try to define more clearly
    what they mean, how they work, and why they are exactly the way that they are.
    Specifically, we’ll look at how variables and values differ, how they are represented
    in memory, and the different memory regions a program has. We’ll then discuss
    some of the subtleties of ownership, borrowing, and lifetimes that you’ll need
    to have a handle on before you continue with the book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当你深入探索 Rust 的更高级内容时，确保你对基础知识有扎实的理解非常重要。像任何编程语言一样，在你开始以更复杂的方式使用 Rust 时，各种关键字和概念的精确定义变得至关重要。在本章中，我们将逐步讲解
    Rust 的许多基本概念，并尽可能清晰地定义它们的含义、工作原理以及为什么它们是以这种方式存在的。具体来说，我们将探讨变量和值的区别、它们在内存中的表示方式以及程序所拥有的不同内存区域。接着，我们将讨论一些所有权、借用和生命周期的细微之处，这些都是你在继续阅读本书之前需要掌握的内容。
- en: You can read this chapter from top to bottom if you wish, or you can use it
    as a reference to brush up on the concepts that you feel less sure about. I recommend
    that you move on only when you feel completely comfortable with the content of
    this chapter, as misconceptions about how these primitives work will quickly get
    in the way of understanding the more advanced topics, or lead to you using them
    incorrectly.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以从头到尾阅读本章，或者将其作为参考，回顾你不太确定的概念。我建议你在完全理解本章内容之前，不要急于继续，因为对这些基本概念的误解会迅速阻碍你理解更高级的主题，或者导致你错误地使用它们。
- en: Talking About Memory
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论内存
- en: Not all memory is created equal. In most programming environments, your programs
    have access to a stack, a heap, registers, text segments, memory-mapped registers,
    memory-mapped files, and perhaps nonvolatile RAM. Which one you choose to use
    in a particular situation has implications for what you can store there, how long
    it remains accessible, and what mechanisms you use to access it. The exact details
    of these memory regions vary between platforms and are beyond the scope of this
    book, but some are so important to how you reason about Rust code that they are
    worth covering here.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有内存都是相同的。在大多数编程环境中，你的程序可以访问栈、堆、寄存器、文本段、内存映射寄存器、内存映射文件，甚至可能是非易失性 RAM。你选择在特定情况下使用哪种内存区域，会影响你能在那里存储什么、它能保持可访问的时间以及你如何访问它。不同平台之间这些内存区域的具体细节有所不同，超出了本书的范围，但有些内存区域对于你理解
    Rust 代码的方式非常重要，值得在这里进行讨论。
- en: Memory Terminology
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存术语
- en: Before we dive into regions of memory, you first need to know about the difference
    between values, variables, and pointers. A *value* in Rust is the combination
    of a type and an element of that type’s domain of values. A value can be turned
    into a sequence of bytes using its type’s *representation*, but on its own you
    can think of a value more like what you, the programmer, meant. For example, the
    number `6` in the type `u8` is an instance of the mathematical integer 6, and
    its in-memory representation is the byte `0x06`. Similarly, the `str` `"Hello
    world"` is a value in the domain of all strings whose representation is its UTF-8
    encoding. A value’s meaning is independent of the location where those bytes are
    stored.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解内存区域之前，你需要先了解值、变量和指针之间的区别。Rust 中的一个*值*是类型和该类型值域中的元素的组合。一个值可以通过其类型的*表示*转换为字节序列，但单独来看，你可以把值理解为你作为程序员所表示的东西。例如，类型为
    `u8` 的数字 `6` 是数学整数 6 的一个实例，其在内存中的表示是字节 `0x06`。类似地，字符串 `str` `"Hello world"` 是所有字符串的一个值，其表示是其
    UTF-8 编码。一个值的含义与这些字节存储的位置无关。
- en: A value is stored in a *place*, which is the Rust terminology for “a location
    that can hold a value.” This place can be on the stack, on the heap, or in a number
    of other locations. The most common place to store a value is a *variable*, which
    is a named value slot on the stack.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值被存储在一个*位置*中，这个术语在 Rust 中指的是“可以存储值的位置”。这个位置可以位于栈上、堆上或其他多个地方。存储值最常见的位置是一个*变量*，它是栈上一个命名的值槽。
- en: A *pointer* is a value that holds the address of a region of memory, so the
    pointer points to a place. A pointer can be dereferenced to access the value stored
    in the memory location it points to. We can store the same pointer in more than
    one variable and therefore have multiple variables that indirectly refer to the
    same location in memory and thus the same underlying value.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*指针*是一个值，它保存内存区域的地址，因此指针指向一个位置。指针可以被解引用以访问它所指向的内存位置中存储的值。我们可以将相同的指针存储在多个变量中，从而让多个变量间接引用内存中的同一位置，因此引用相同的底层值。'
- en: Consider the code in [Listing 1-1](#listing1-1), which illustrates these three
    elements.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考[示例 1-1](#listing1-1)中的代码，它展示了这三个元素。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 1-1: Values, variables, and pointers'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-1：值、变量和指针
- en: 'Here, there are four distinct values: `42` (an `i32`), `43` (an `i32`), the
    address of `x` (a pointer), and the address of `y` (a pointer). There are also
    four variables: `x`, `y`, `var1`, and `var2`. The latter two variables both hold
    values of the pointer type, because references are pointers. While `var1` and
    `var2` store the same value initially, they store separate, independent copies
    of that value; when we change the value stored in `var2` 1, the value in `var1`
    does not change. In particular, the `=` operator stores the value of the right-hand
    side expression in the place named by the left-hand side.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，有四个不同的值：`42`（一个`i32`），`43`（一个`i32`），`x`的地址（一个指针），以及`y`的地址（一个指针）。也有四个变量：`x`、`y`、`var1`和`var2`。后两个变量都保存指针类型的值，因为引用是指针。虽然`var1`和`var2`最初存储相同的值，但它们存储的是该值的独立副本；当我们改变`var2`中存储的值时，`var1`中的值不会改变。特别地，`=`运算符将右侧表达式的值存储在左侧命名的地方。
- en: 'An interesting example of where the distinction between variables, values,
    and pointers becomes important is in a statement such as:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的例子，展示了变量、值和指针之间的区别何时变得重要，出现在如下语句中：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Even though we assign a string value to the variable `string`, the *actual*
    value of the variable is a pointer to the first character in the string value
    `"Hello world"`, and not the string value itself. At this point you might say,
    “But hang on, where is the string value stored, then? Where does the pointer point?”
    If so, you have a keen eye—we’ll get to that in a second.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们将一个字符串值赋给变量`string`，该变量的*实际*值是指向字符串值`"Hello world"`中第一个字符的指针，而不是字符串值本身。此时你可能会说，“等等，那字符串值到底存储在哪里？指针指向哪里？”如果是这样，你的眼光非常敏锐——我们马上就会讲到这个问题。
- en: Variables in Depth
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量深入解析
- en: 'The definition of a variable I gave earlier is broad and unlikely to be all
    that useful in and of itself. As you encounter more complex code, you’ll need
    a more accurate mental model to help you reason through what the programs are
    really doing. There are many such models that we can make use of. Describing them
    all in detail would take up several chapters and is beyond the scope of this book,
    but broadly speaking, they can be divided into two categories: high-level models
    and low-level models. High-level models are useful when thinking about code at
    the level of lifetimes and borrows, while low-level models are good for when you
    are reasoning about unsafe code and raw pointers. The models for variables described
    in the following two sections will suffice for most of the material in this book.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前给出的变量定义比较宽泛，单独来看可能并不太有用。随着你遇到更复杂的代码，你将需要一个更准确的思维模型，帮助你推理程序到底在做什么。我们可以利用许多这样的模型。详细描述它们会占用几章内容，超出了本书的范围，但广义上来说，它们可以分为两类：高级模型和低级模型。高级模型适用于从生命周期和借用的角度思考代码，而低级模型则适合在你推理不安全代码和原始指针时使用。以下两节中描述的变量模型足以涵盖本书中的大部分内容。
- en: High-Level Model
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 高级模型
- en: In the high-level model, we don’t think of variables as places that hold bytes.
    Instead, we think of them just as names given to values as they are instantiated,
    moved, and used throughout a program. When you assign a value to a variable, that
    value is from then on named by that variable. When a variable is later accessed,
    you can imagine drawing a line from the previous access of that variable to the
    new access, which establishes a dependency relationship between the two accesses.
    If the value in a variable is moved, no lines can be drawn from it anymore.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在高级模型中，我们不把变量看作存储字节的地方。相反，我们把它们看作是赋值时被赋予名称的值，这些值在程序中被实例化、移动并使用。当你将一个值赋给一个变量时，从此该变量就会“命名”这个值。当后续访问变量时，你可以想象从变量的前次访问到新的访问之间画一条线，这样就建立了两个访问之间的依赖关系。如果变量中的值被移动，则不再能够从其访问绘制任何线条。
- en: In this model, a variable exists only so long as it holds a legal value; you
    cannot draw lines from a variable whose value is uninitialized or has been moved,
    so effectively it isn’t there. Using this model, your entire program consists
    of many of these dependency lines, often called *flows*, each one tracing the
    lifetime of a particular instance of a value. Flows can fork and merge when there
    are branches, with each split tracing a distinct lifetime for that value. The
    compiler can check that at any given point in your program, all flows that can
    exist in parallel with each other are compatible. For example, there cannot be
    two parallel flows with mutable access to a value. Nor can there be a flow that
    borrows a value while there is no flow that owns the value. [Listing 1-2](#listing1-2)
    shows examples of both of these cases.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模型中，一个变量仅在它持有一个合法的值时存在；你不能从一个未初始化或已被移动的变量绘制线条，所以实际上它就不存在了。使用这个模型，你的整个程序由许多这样的依赖线条组成，这些线条通常被称为*流*，每一条都追踪一个特定值实例的生命周期。流可以在分支处分叉和合并，每个分支追踪该值的不同生命周期。编译器可以检查在程序的任何给定点，所有可能并行存在的流是否兼容。例如，不能有两个并行的流同时对一个值有可变访问；也不能有一个流借用一个值，而没有一个流拥有该值。[Listing
    1-2](#listing1-2) 显示了这两种情况的示例。
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 1-2: Illegal flows that the borrow checker will catch'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 1-2：借用检查器会捕获的非法流
- en: 'First, we cannot use `x` before it is initialized, because we have nowhere
    to draw the flow from. Only when we assign a value to `x` can we draw flows from
    it. This code has two flows: one exclusive (`&mut`) flow from 1 to 3, and one
    shared (`&`) flow from 1 through 2 to 4. The borrow checker inspects every vertex
    of every flow and checks that no other incompatible flows exist concurrently.
    In this case, when the borrow checker inspects the exclusive flow at 3, it sees
    the shared flow that terminates at 4. Since you cannot have an exclusive and a
    shared use of a value at the same time, the borrow checker (correctly) rejects
    the code. Notice that if 4 was not there, this code would compile fine! The shared
    flow would terminate at 2, and when the exclusive flow is checked at 3, no conflicting
    flows would exist.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们不能在`x`初始化之前使用它，因为我们无法从任何地方绘制流。只有在我们为`x`赋值时，才能从它绘制流。这个代码有两个流：一个独占（`&mut`）流从1到3，和一个共享（`&`）流从1经过2到4。借用检查器会检查每个流的每个节点，确保没有其他不兼容的流并行存在。在这种情况下，当借用检查器检查3处的独占流时，它看到终止于4的共享流。由于不能同时对一个值有独占和共享的使用，借用检查器（正确地）拒绝了这段代码。注意，如果4不在那里，这段代码会正常编译！共享流将在2处终止，而当独占流在3处被检查时，不会有冲突的流存在。
- en: If a new variable is declared with the same name as a previous one, they are
    still considered distinct variables. This is called *shadowing*—the later variable
    “shadows” the former by the same name. The two variables coexist, though subsequent
    code no longer has a way to name the earlier one. This model matches roughly how
    the compiler, and the borrow checker in particular, reasons about your program,
    and is actually used internally in the compiler to produce efficient code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果声明一个新变量，且该变量与先前的变量同名，它们仍然被视为不同的变量。这被称为*遮蔽*——后声明的变量“遮蔽”了前一个变量。两个变量共存，尽管后续代码不再有方法访问前一个变量。这一模型大致匹配编译器的工作方式，特别是借用检查器如何推理程序，并且实际上在编译器内部用于生成高效的代码。
- en: Low-Level Model
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 低级模型
- en: 'Variables name memory locations that may or may not hold legal values. You
    can think of a variable as a “value slot.” When you assign to it, the slot is
    filled, and its old value (if it had one) is dropped and replaced. When you access
    it, the compiler checks that the slot isn’t empty, as that would mean the variable
    is uninitialized or its value has been moved. A pointer to a variable refers to
    the variable’s backing memory and can be dereferenced to get at its value. For
    example, in the statement `let x: usize`, the variable `x` is a name for a region
    of memory on the stack that has room for a value the size of a `usize`, though
    it does not have a well-defined value (its slot is empty). If you assign a value
    to that variable, such as with `x = 6`, that region of memory will then hold the
    bits representing the value `6`. `&x` does not change when you assign to `x`.
    If you declare multiple variables with the same name, they still end up with different
    chunks of memory backing them. This model matches the memory model used by C and
    C++, and many other low-level languages, and is useful for when you need to reason
    explicitly about memory.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '变量命名内存位置，这些位置可能包含合法值，也可能不包含。你可以把变量看作是一个“值槽”。当你给它赋值时，这个槽就被填满，原来的值（如果有的话）会被丢弃并被新值替换。当你访问它时，编译器会检查这个槽是否为空，因为如果为空，意味着变量未初始化或者其值已经被移动。指向变量的指针指向该变量的后备内存，可以解引用来获取其值。例如，在语句`let
    x: usize`中，变量`x`是栈上一个内存区域的名字，该区域足够存储一个`usize`类型的值，但该值没有明确的定义（槽为空）。如果你给这个变量赋值，比如`x
    = 6`，那块内存区域就会存储表示值`6`的字节。`&x`在你给`x`赋值时不会改变。如果你声明多个同名变量，它们最终会有不同的内存块作为后备存储。这个模型与C和C++以及许多其他低级语言使用的内存模型相匹配，并且在需要明确推理内存时非常有用。'
- en: You may find that one of these matches your previous model better than the other,
    but I urge you to try to wrap your head around both of them. They are both equally
    valid, and both are simplifications, like any useful mental model has to be. If
    you are able to consider a piece of code from both of these perspectives, you
    will find it much easier to work through complicated code segments and understand
    why they do or do not compile and work as you expect.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现其中某个模型比另一个更符合你之前的理解，但我鼓励你尝试理解这两者。它们都是有效的简化模型，就像任何有用的思维模型必须具备的特点一样。如果你能够从这两种视角考虑一段代码，你会发现解决复杂的代码段变得更加容易，也能更好地理解为什么代码能够或不能按预期编译和运行。
- en: Memory Regions
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存区域
- en: Now that you have a grip on how we refer to memory, we need to talk about what
    memory actually is. There are many different regions of memory, and perhaps surprisingly,
    not all of them are stored in the DRAM of your computer. Which part of memory
    you use has a significant impact on how you write your code. The three most important
    regions for the purposes of writing Rust code are the stack, the heap, and static
    memory.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了我们如何引用内存的方式，接下来需要讨论内存到底是什么。内存有许多不同的区域，或许让你惊讶的是，并非所有的内存都存储在计算机的DRAM中。你使用的内存部分会对你编写代码的方式产生重大影响。在编写Rust代码时，三个最重要的内存区域是栈、堆和静态内存。
- en: The Stack
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 栈
- en: The *stack* is a segment of memory that your program uses as scratch space for
    function calls. Each time a function is called, a contiguous chunk of memory called
    a *frame* is allocated at the top of the stack. Near the bottom of the stack is
    the frame for the `main` function, and as functions call other functions, additional
    frames are pushed onto the stack. A function’s frame contains all the variables
    within that function, along with any arguments the function takes. When the function
    returns, its stack frame is reclaimed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*栈*是程序用于函数调用时的临时内存空间。每当调用一个函数时，栈顶会分配一个连续的内存块，称为*帧*。栈底靠近的地方是`main`函数的帧，而随着函数调用其他函数，更多的帧会被压入栈中。一个函数的帧包含该函数内所有变量以及该函数接收的任何参数。当函数返回时，它的栈帧会被回收。'
- en: The bytes that make up the values of the function’s local variables are not
    immediately wiped, but it’s not safe to access them as they may have been overwritten
    by a subsequent function call whose frame overlaps with the reclaimed one. And
    even if they haven’t been overwritten, they may contain values that are illegal
    to use, such as ones that were moved when the function returned.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 组成函数局部变量值的字节不会立即被清除，但访问它们并不安全，因为它们可能已被后续函数调用覆盖，这些函数的帧可能与被回收的帧重叠。即使它们没有被覆盖，它们也可能包含非法的值，例如在函数返回时被移动的值。
- en: Stack frames, and crucially the fact that they eventually disappear, are very
    closely tied to the notion of lifetimes in Rust. Any variable stored in a frame
    on the stack cannot be accessed after that frame goes away, so any reference to
    it must have a lifetime that is at most as long as the lifetime of the frame.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 栈帧，特别是它们最终消失这一事实，和 Rust 中的生命周期概念密切相关。存储在栈帧中的任何变量，在该栈帧消失后都不能再访问，因此任何对它的引用必须具有一个生命周期，这个生命周期最多和栈帧的生命周期一样长。
- en: The Heap
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 堆
- en: The *heap* is a pool of memory that isn’t tied to the current call stack of
    the program. Values in heap memory live until they are explicitly deallocated.
    This is useful when you want a value to live beyond the lifetime of the current
    function’s frame. If that value is the function’s return value, the calling function
    can leave some space on its stack for the called function to write that value
    into before it returns. But if you want to, say, send that value to a different
    thread with which the current thread may share no stack frames at all, you can
    store it on the heap.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*堆* 是一块内存池，它与程序当前的调用栈无关。堆内存中的值会一直存在，直到它们被显式地释放。当你希望一个值的生命周期超出当前函数的作用域时，堆内存就非常有用。如果这个值是函数的返回值，调用函数可以在其栈上留出一些空间，让被调用的函数在返回之前将这个值写入其中。但如果你希望将这个值发送到一个与当前线程可能没有任何栈帧共享的线程中，你可以将它存储在堆上。'
- en: The heap allows you to explicitly allocate contiguous segments of memory. When
    you do so, you get a pointer to the start of that segment of memory. That memory
    segment is reserved for you until you later deallocate it; this process is often
    referred to as *freeing*, after the name of the corresponding function in the
    C standard library. Since allocations from the heap do not go away when a function
    returns, you can allocate memory for a value in one place, pass the pointer to
    it to another thread, and have that thread safely continue to operate on that
    value. Or, phrased differently, when you heap-allocate memory, the resulting pointer
    has an unconstrained lifetime—its lifetime is however long your program keeps
    it alive.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 堆允许你显式地分配连续的内存段。当你这样做时，你会得到指向该内存段开始位置的指针。该内存段会被保留，直到你稍后显式释放它；这个过程通常被称为*释放*，这是
    C 标准库中相应函数的名称。由于堆内存的分配不会在函数返回时消失，你可以在一个地方分配内存，将指针传递给另一个线程，并让那个线程安全地继续操作该值。换句话说，当你在堆上分配内存时，得到的指针具有不受限制的生命周期——它的生命周期长到程序决定将它保持活跃为止。
- en: The primary mechanism for interacting with the heap in Rust is the `Box` type.
    When you write `Box::new(value)`, the value is placed on the heap, and what you
    are given back (the `Box<T>`) is a pointer to that value on the heap. When the
    `Box` is eventually dropped, that memory is freed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中与堆交互的主要机制是 `Box` 类型。当你写 `Box::new(value)` 时，值会被放置到堆上，而你得到的返回值（`Box<T>`）是指向该堆上值的指针。当
    `Box` 最终被丢弃时，这块内存会被释放。
- en: If you forget to deallocate heap memory, it will stick around forever, and your
    application will eventually eat up all the memory on your machine. This is called
    *leaking memory* and is usually something you want to avoid. However, there are
    some cases where you explicitly want to leak memory. For example, say you have
    a read-only configuration that the entire program should be able to access. You
    can allocate that on the heap and explicitly leak it with `Box::leak` to get a
    `'static` reference to it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记释放堆内存，它将永远存在，你的应用程序最终会占满机器上的所有内存。这被称为*内存泄漏*，通常是我们要避免的。然而，也有一些情况你可能故意想要发生内存泄漏。例如，假设你有一个只读的配置，程序中的每个部分都应该能够访问它。你可以将其分配到堆上，并通过
    `Box::leak` 显式地泄漏它，从而获得对其的 `'static` 引用。
- en: Static Memory
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 静态内存
- en: '*Static memory* is really a catch-all term for several closely related regions
    located in the file your program is compiled into. These regions are automatically
    loaded into your program’s memory when that program is executed. Values in static
    memory live for the entire execution of your program. Your program’s static memory
    contains the program’s binary code, which is usually mapped as read-only. As your
    program executes, it walks through the binary code in the text segment instruction
    by instruction and jumps around whenever a function is called. Static memory also
    holds the memory for variables you declare with the `static` keyword, as well
    as certain constant values in your code, like strings.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态内存* 实际上是一个统称，指的是位于你程序编译文件中的多个密切相关的区域。这些区域在程序执行时会自动加载到你的程序内存中。静态内存中的值会在程序执行期间一直存在。你的程序的静态内存包含了程序的二进制代码，这些代码通常映射为只读。当你的程序执行时，它会逐条指令地遍历二进制代码，并在每次调用函数时跳转。静态内存还保存你使用`static`关键字声明的变量的内存，以及你代码中的某些常量值，如字符串。'
- en: 'The special lifetime `''static`, which gets its name from the static memory
    region, marks a reference as being valid for “as long as static memory is around,”
    which is until the program shuts down. Since a static variable’s memory is allocated
    when the program starts, a reference to a variable in static memory is, by definition,
    `''static`, as it is not deallocated until the program shuts down. The inverse
    is not true—there can be `''static` references that do not point to static memory—but
    the name is still appropriate: once you create a reference with a static lifetime,
    whatever it points to might as well be in static memory as far as the rest of
    the program is concerned, as it can be used for however long your program wishes.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊生命周期`'static`，其名称来自静态内存区域，标记一个引用有效的时间为“只要静态内存存在”，即直到程序关闭。由于静态变量的内存在程序启动时分配，指向静态内存中变量的引用，按定义就是`'static`，因为它不会被释放直到程序关闭。反之则不然——可能会有指向非静态内存的`'static`引用——但这个名称仍然是合适的：一旦你创建了一个具有静态生命周期的引用，无论它指向什么，其他部分的程序都认为它好像指向了静态内存，因为它可以在程序需要的任何时长内使用。
- en: 'You will encounter the `''static` lifetime much more often than you will encounter
    truly static memory (through the `static` keyword, for example) when working with
    Rust. This is because `''static` often shows up in trait bounds on type parameters.
    A bound like `T: ''static` indicates that the type parameter `T` is able to live
    for however long we keep it around for, up to and including the remaining execution
    of the program. Essentially, this bound requires that `T` is owned and self-sufficient,
    either in that it does not borrow other (non-static) values or that anything it
    does borrow is also `''static` and thus will stick around until the end of the
    program. A good example of `''static` as a bound is the `std::thread::spawn` function
    that creates a new thread, which requires that the closure you pass it is `''static`.
    Since the new thread may outlive the current thread, the new thread cannot refer
    to anything stored on the old thread’s stack. The new thread can refer only to
    values that will live for its entire lifetime, which may be for the remaining
    duration of the program.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '当你在 Rust 中工作时，你会比遇到真正的静态内存（例如通过`static`关键字）更常遇到`''static`生命周期。这是因为`''static`通常出现在类型参数的
    trait 约束中。像`T: ''static`这样的约束表示类型参数`T`能够存在多长时间，我们保留它，直到程序执行结束。实质上，这个约束要求`T`是拥有者且自给自足的，要么它不借用其他（非静态）值，要么它借用的任何东西也是`''static`的，因此会一直存在直到程序结束。一个关于`''static`作为约束的好例子是`std::thread::spawn`函数，它用于创建一个新线程，这要求你传递的闭包是`''static`的。由于新线程可能会比当前线程存活得更久，它不能引用任何存储在旧线程栈上的东西。新线程只能引用那些会在其整个生命周期内存在的值，这些值可能会持续到程序结束。'
- en: Ownership
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所有权
- en: Rust’s memory model centers on the idea that all values have a single *owner*—that
    is, exactly one location (usually a scope) is responsible for ultimately deallocating
    each value. This is enforced through the borrow checker. If the value is moved,
    such as by assigning it to a new variable, pushing it to a vector, or placing
    it on the heap, the ownership of the value moves from the old location to the
    new one. At that point, you can no longer access the value through variables that
    flow from the original owner, even though the bits that make up the value are
    technically still there. Instead, you must access the moved value through variables
    that refer to its new location.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的内存模型以所有值都有一个单一的*所有者*为核心——即，恰好有一个位置（通常是作用域）负责最终释放每个值的内存。这通过借用检查器来强制执行。如果值被移动，比如通过将其赋值给一个新变量、将其推送到一个向量中或放到堆上，那么值的所有权从旧位置转移到新位置。此时，你不能再通过原始所有者流出的变量访问该值，即使构成该值的位在技术上仍然存在。相反，你必须通过引用其新位置的变量来访问已移动的值。
- en: Some types are rebels and do not follow this rule. If a value’s type implements
    the special `Copy` trait, the value is not considered to have moved even if it
    is reassigned to a new memory location. Instead, the value is *copied*, and both
    the old and new locations remain accessible. Essentially, another identical instance
    of that same value is constructed at the destination of the move. Most primitive
    types in Rust, such as the integer and floating-point types, are `Copy`. To be
    `Copy`, it must be possible to duplicate the type’s values simply by copying their
    bits. This eliminates all types that *contain* non-`Copy` types as well as any
    type that owns a resource it must deallocate when the value is dropped.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有些类型是叛逆者，不遵循这个规则。如果一个值的类型实现了特殊的`Copy`特征，那么即使它被重新分配到新的内存位置，也不会被视为已经移动。相反，值会被*复制*，旧的和新的位置都可以访问。本质上，另一个相同的值实例会在移动的目标位置被构造出来。Rust
    中的大多数原始类型，如整数和浮点类型，都是`Copy`类型。为了成为`Copy`，必须能够通过简单地复制它们的位来复制类型的值。这排除了所有*包含*非`Copy`类型的类型，以及任何拥有必须在值被丢弃时释放的资源的类型。
- en: To see why, consider what would happen if a type like `Box` were `Copy`. If
    we executed `box2 = box1`, then `box1` and `box2` would both believe that they
    owned the heap memory allocated for the box, and they would both attempt to free
    it when they went out of scope. Freeing the memory twice could have catastrophic
    consequences.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解原因，考虑一下如果像 `Box` 这样的类型是 `Copy` 会发生什么。如果我们执行 `box2 = box1`，那么 `box1` 和 `box2`
    都会认为它们拥有为 box 分配的堆内存，当它们超出作用域时，它们都会尝试释放这段内存。两次释放内存可能会导致灾难性的后果。
- en: When a value’s owner no longer has use for it, it is the owner’s responsibility
    to do any necessary cleanup for that value by *dropping* it. In Rust, dropping
    happens automatically when the variable that holds the value is no longer in scope.
    Types usually recursively drop values they contain, so dropping a variable of
    a complex type may result in many values being dropped. Because of Rust’s discrete
    ownership requirement, we cannot accidentally drop the same value multiple times.
    A variable that holds a reference to another value does not own that other value,
    so the value isn’t dropped when the variable drops.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个值的所有者不再需要它时，清理这个值的责任就落在所有者身上，*丢弃*它。在 Rust 中，当持有值的变量不再在作用域内时，丢弃会自动发生。类型通常会递归地丢弃它们包含的值，因此丢弃一个复杂类型的变量可能会导致多个值被丢弃。由于
    Rust 的显式所有权要求，我们不能意外地多次丢弃同一个值。一个持有对另一个值引用的变量并不拥有该值，因此当该变量被丢弃时，该值不会被丢弃。
- en: The code in [Listing 1-3](#listing1-3) gives a quick summary of the rules around
    ownership, move and copy semantics, and dropping.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 1-3](#listing1-3)中的代码简要总结了有关所有权、移动和复制语义以及丢弃的规则。'
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 1-3: Moving and copying semantics'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-3：移动和复制语义
- en: We start out with two values, the number `42` and a `Box` (a heap-allocated
    value) containing the number `84`. The former is `Copy`, whereas the latter is
    not. When we place `x1` and `y1` into the tuple `z` 1, `x1` is *copied* into `z`,
    whereas `y1` is *moved* into `z`. At this point, `x1` continues to be accessible
    and can be used again 3. On the other hand, `y1` is rendered inaccessible once
    its value has been moved 4, and any attempt to access it would incur a compiler
    error. When `z` goes out of scope 2, the tuple value it contains is dropped, and
    this in turn drops the value copied from `x1` and the one moved from `y1`. When
    the `Box` from `y1` is dropped, it also deallocates the heap memory used to store
    `y1`’s value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从两个值开始，一个是数字`42`，另一个是包含数字`84`的`Box`（堆分配的值）。前者是`Copy`类型，而后者不是。当我们将`x1`和`y1`放入元组`z`时，`x1`被*复制*到`z`中，而`y1`则被*移动*到`z`中。此时，`x1`仍然可访问并且可以再次使用3。另一方面，一旦`y1`的值被移动4，它就变得不可访问，任何尝试访问它的行为都会导致编译错误。当`z`超出作用域2时，它包含的元组值会被丢弃，这也会丢弃从`x1`复制的值和从`y1`移动的值。当`y1`的`Box`被丢弃时，它也会释放用于存储`y1`值的堆内存。
- en: Borrowing and Lifetimes
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 借用和生命周期
- en: Rust allows the owner of a value to lend out that value to others, without giving
    up ownership, through references. *References* are pointers that come with an
    additional contract for how they can be used, such as whether the reference provides
    exclusive access to the referenced value, or whether the referenced value may
    also have other references point to it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 允许值的所有者将该值通过引用借给其他人，而不放弃所有权。*引用*是指针，它附带了额外的约定，规定了如何使用这些引用，例如该引用是否提供对引用值的独占访问权限，或者该引用的值是否可能同时被其他引用指向。
- en: Shared References
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享引用
- en: A shared reference, `&T`, is, as the name implies, a pointer that may be shared.
    Any number of other references may exist to the same value, and each shared reference
    is `Copy`, so you can trivially make more of them. Values behind shared references
    are not mutable; you cannot modify or reassign the value a shared reference points
    to, nor can you cast a shared reference to a mutable one.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 共享引用`&T`，顾名思义，是可以共享的指针。可以存在任何数量的其他引用指向相同的值，并且每个共享引用都是`Copy`类型，因此你可以轻松地创建更多的共享引用。共享引用所指向的值不可变；你不能修改或重新赋值共享引用指向的值，也不能将共享引用转换为可变引用。
- en: The Rust compiler is allowed to assume that the value a shared reference points
    to *will not change* while that reference lives. For example, if the Rust compiler
    sees that the value behind a shared reference is read multiple times in a function,
    it is within its rights to read it only once and reuse that value. More concretely,
    the assertion in [Listing 1-4](#listing1-4) should never fail.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 编译器允许假设共享引用指向的值在引用存在期间*不会改变*。例如，如果 Rust 编译器发现共享引用指向的值在函数中被多次读取，它可以仅读取一次并重用该值。更具体地说，列表
    [1-4](#listing1-4) 中的断言永远不应该失败。
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 1-4: Rust assumes that shared references are immutable.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-4：Rust 假设共享引用是不可变的。
- en: Whether or not the compiler chooses to apply a given optimization is more or
    less irrelevant. The compiler heuristics change over time, so you generally want
    to code against what the compiler is allowed to do rather than what it actually
    does in a particular case at a particular moment in time.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器是否选择应用某种优化通常无关紧要。编译器的启发式规则会随着时间变化，因此你通常需要根据编译器允许的行为来编写代码，而不是依据它在某一特定时刻做出的实际行为。
- en: Mutable References
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变引用
- en: 'The alternative to a shared reference is a mutable reference: `&mut T`. With
    mutable references, the Rust compiler is again allowed to make full use of the
    contract that the reference comes with: the compiler assumes that there are no
    other threads accessing the target value, whether through a shared reference or
    a mutable one. In other words, it assumes that the mutable reference is *exclusive*.
    This enables some interesting optimizations that are not readily available in
    other languages. Take, for example, the code in [Listing 1-5](#listing1-5).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 共享引用的替代方案是可变引用：`&mut T`。对于可变引用，Rust 编译器同样可以完全利用引用所附带的约定：编译器假设没有其他线程通过共享引用或可变引用访问目标值。换句话说，它假设可变引用是*独占的*。这使得某些优化变得可能，而这些优化在其他语言中可能不容易实现。例如，参考[列表
    1-5](#listing1-5)中的代码。
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 1-5: Rust assumes that mutable references are exclusive.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-5：Rust 假设可变引用是独占的。
- en: In Rust, the compiler can assume that `input` and `output` do not point to the
    same memory. Therefore, the reassignment of `output` at 1 cannot affect the check
    at 2, and the entire function can be compiled as a single `if-else` block. If
    the compiler could not rely on the exclusive mutability contract, that optimization
    would be invalid, since an `input` of `1` could then result in an `output` of
    `3` in a case like `noalias(&x, &mut x)`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，编译器可以假设 `input` 和 `output` 不指向相同的内存。因此，在1处重新分配 `output` 不会影响2处的检查，整个函数可以作为一个单独的
    `if-else` 块编译。如果编译器不能依赖于独占的可变性契约，那么该优化将无效，因为 `input` 为 `1` 时可能导致 `output` 为 `3`，例如在
    `noalias(&x, &mut x)` 的情况下。
- en: A mutable reference lets you mutate only the memory location that the reference
    points to. Whether you can mutate values that lie beyond the immediate reference
    depends on the methods provided by the type that lies between. This may be easier
    to understand with an example, so consider [Listing 1-6](#listing1-6).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 可变引用让你只能修改引用所指向的内存位置。是否可以修改超出直接引用范围的值，取决于该类型之间提供的方法。这可以通过一个示例更容易理解，参考 [列表 1-6](#listing1-6)。
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 1-6: Mutability applies only to the immediately referenced memory.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-6：可变性仅适用于直接引用的内存。
- en: In this example, you are able to change the value of the pointer `y` to a different
    value (that is, a different pointer) by making it reference a different variable,
    but you cannot change the value that is pointed to (that is, the value of `x`).
    Similarly, you can change the pointer value of `y` through `z`, but you cannot
    change `z` itself to hold a different reference.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以通过让指针 `y` 引用另一个变量来改变指针的值（即改变指针本身），但你不能改变它所指向的值（即 `x` 的值）。同样，你可以通过
    `z` 来改变 `y` 的指针值，但不能改变 `z` 本身，使其持有不同的引用。
- en: 'The primary difference between owning a value and having a mutable reference
    to it is that the owner is responsible for dropping the value when it is no longer
    necessary. Apart from that, you can do anything through a mutable reference that
    you can if you own the value, with one caveat: if you move the value behind the
    mutable reference, then you must leave another value in its place. If you did
    not, the owner would still think it needed to drop the value, but there would
    be no value for it to drop!'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个值和拥有它的可变引用之间的主要区别在于，拥有者负责在不再需要该值时丢弃它。除此之外，你可以通过可变引用做任何你可以通过拥有该值做的事情，有一个例外：如果你将值从可变引用背后移走，那么你必须留下另一个值来替代它。如果你没有这样做，拥有者仍然认为它需要丢弃该值，但没有值可以丢弃！
- en: '[Listing 1-7](#listing1-7) gives an example of the ways in which you can move
    the value behind a mutable reference.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 1-7](#listing1-7) 给出了你如何移除可变引用背后值的示例。'
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 1-7: Access through a mutable reference must leave a value behind.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-7：通过可变引用的访问必须留下一个值。
- en: I’ve added commented-out lines that represent illegal operations. You cannot
    simply move the value out 1 since the caller would still think they owned that
    value and would free it again at 5, leading to a double free. If you just want
    to leave some valid value behind, `std::mem::take` 2 is a good candidate. It is
    equivalent to `std::mem::replace(&mut value, Default::default())`; it moves `value`
    out from behind the mutable reference but leaves a new, default value for the
    type in its place. The default is a separate, owned value, so it is safe for the
    caller to drop it when the scope ends at 5.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经添加了注释掉的行，表示非法操作。你不能简单地将值移出1，因为调用者仍然认为它拥有该值，并会在5处再次释放它，从而导致双重释放。如果你只是想留下一个有效的值，`std::mem::take`
    2 是一个很好的选择。它等价于 `std::mem::replace(&mut value, Default::default())`；它将 `value`
    从可变引用后面移出，但在其位置留下一个新的默认值。默认值是一个独立的、拥有的值，因此调用者可以在作用域结束时安全地丢弃它。
- en: Alternatively, if you don’t need the old value behind the reference, you can
    overwrite it with a value that you already own 3, leaving it to the caller to
    drop the value later. When you do this, the value that used to be behind the mutable
    reference is dropped immediately.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你不需要引用背后的旧值，你可以用一个你已经拥有的值3来覆盖它，将其留给调用者稍后丢弃该值。当你这么做时，原来在可变引用背后的值会立即被丢弃。
- en: Finally, if you have two mutable references, you can swap their values without
    owning either of them 4, since both references will end up with a legal owned
    value for their owners to eventually free.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你有两个可变引用，你可以交换它们的值而无需拥有它们4，因为两个引用最终都会得到一个合法的拥有值，供它们的拥有者最终释放。
- en: Interior Mutability
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内部可变性
- en: 'Some types provide *interior mutability*, meaning they allow you to mutate
    a value through a shared reference. These types usually rely on additional mechanisms
    (like atomic CPU instructions) or invariants to provide safe mutability without
    relying on the semantics of exclusive references. These normally fall into two
    categories: those that let you get a mutable reference through a shared reference,
    and those that let you replace a value given only a shared reference.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有些类型提供 *内部可变性*，意味着它们允许你通过共享引用来变更一个值。这些类型通常依赖于额外的机制（如原子 CPU 指令）或不变量来提供安全的可变性，而不依赖于独占引用的语义。这些类型通常分为两类：一类是让你通过共享引用获得可变引用，另一类是让你仅凭共享引用就能替换一个值。
- en: The first category consists of types like `Mutex` and `RefCell`, which contain
    safety mechanisms to ensure that, for any value they give a mutable reference
    to, only one mutable reference (and no shared references) can exist at a time.
    Under the hood, these types (and those like them) all rely on a type called `UnsafeCell`,
    whose name should immediately make you hesitate to use it. We will cover `UnsafeCell`
    in more detail in Chapter 9, but for now you should know that it is the *only*
    correct way to mutate through a shared reference.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第一类类型包括 `Mutex` 和 `RefCell`，它们包含安全机制，确保对于它们给出的可变引用的任何值，在同一时间内只能存在一个可变引用（且没有共享引用）。在底层，这些类型（以及类似的类型）都依赖于一个名为
    `UnsafeCell` 的类型，其名称应该让你在使用时有所犹豫。我们将在第 9 章详细讨论 `UnsafeCell`，但目前你需要知道，它是通过共享引用进行变更的*唯一*正确方式。
- en: Other categories of types that provide interior mutability are those that do
    not give out a mutable reference to the inner value but instead just give you
    methods for manipulating that value in place. The atomic integer types in `std::sync::atomic`
    and the `std::cell::Cell` type fall into this category. You cannot get a reference
    directly to the `usize` or `i32` behind such a type, but you can read and replace
    its value at a given point in time.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 提供内部可变性的其他类型是那些不直接给出对内部值的可变引用，而是提供一些方法来在原地操作该值的类型。`std::sync::atomic` 中的原子整数类型和
    `std::cell::Cell` 类型属于这一类。你不能直接获取到这些类型背后的 `usize` 或 `i32` 引用，但你可以在某个时刻读取并替换其值。
- en: Lifetimes
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生命周期
- en: If you’re reading this book, you’re probably already familiar with the concept
    of lifetimes, likely through repeated notices from the compiler about lifetime
    rules violations. That level of understanding will serve you well for the majority
    of Rust code you will write, but as we dive deeper into the more complex parts
    of Rust, you will need a more rigorous mental model to work with.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读本书，你可能已经对生命周期的概念有所了解，可能是通过编译器多次提醒生命周期规则的违规。这个层次的理解对于你编写的大部分 Rust 代码来说是足够的，但随着我们深入探索
    Rust 的更复杂部分，你将需要一个更严谨的思维模型来进行工作。
- en: 'Newer Rust developers are often taught to think of lifetimes as corresponding
    to scopes: a lifetime begins when you take a reference to some variable and ends
    when that variable is moved or goes out of scope. That’s often correct, and usually
    useful, but the reality is a little more complex. A *lifetime* is really a name
    for a region of code that some reference must be valid for. While a lifetime will
    frequently coincide with a scope, it does not have to, as we will see later in
    this section.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 Rust 开发者通常被教导将生命周期视为与作用域对应：生命周期在你获取某个变量的引用时开始，在该变量被移动或超出作用域时结束。这通常是正确的，而且通常很有用，但现实情况要复杂一些。*生命周期*实际上是指一些引用必须在其上有效的代码区域。虽然生命周期通常与作用域重合，但它不一定总是如此，正如我们稍后在本节中将看到的那样。
- en: Lifetimes and the Borrow Checker
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生命周期与借用检查器
- en: At the heart of Rust lifetimes is the *borrow checker*. Whenever a reference
    with some lifetime `'a` is used, the borrow checker checks that `'a` is still
    *alive*. It does this by tracing the path back to where `'a` starts—where the
    reference was taken—from the point of use and checking that there are no conflicting
    uses along that path. This ensures that the reference still points to a value
    that it is safe to access. This is similar to the high-level “data flow” mental
    model we discussed earlier in the chapter; the compiler checks that the flow of
    the reference we are accessing does not conflict with any other parallel flows.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Rust生命周期的核心是*借用检查器*。每当某个生命周期`'a`的引用被使用时，借用检查器检查`'a`是否仍然*有效*。它通过回溯路径到`'a`开始的地方——即引用被获取的地方——并检查沿路径是否没有冲突的使用。这确保了引用仍然指向一个安全访问的值。这类似于我们在本章前面讨论的高级“数据流”思维模型；编译器检查我们正在访问的引用的流动是否与其他平行的流动冲突。
- en: '[Listing 1-8](#listing1-8) shows a simple code example with lifetime annotations
    for the reference to `x`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 1-8](#listing1-8)展示了一个简单的代码示例，带有对`x`引用的生命周期注解。'
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 1-8: Lifetimes do not need to be contiguous.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-8：生命周期不需要是连续的。
- en: 'The lifetime starts at 1 when we take a reference to `x`. In the first branch
    2, we then immediately try to modify `x` by changing its value to `84`, which
    requires a `&mut x`. The borrow checker takes out a mutable reference to `x` and
    immediately checks its use. It finds no conflicting uses between when the reference
    was taken and when it was used, so it accepts the code. This may come as a surprise
    if you are used to thinking about lifetimes as scopes, since `r` is still in scope
    at 2 (it goes out of scope at 4). But the borrow checker is smart enough to realize
    that `r` is never used later if this branch is taken, and therefore it is fine
    for `x` to be mutably accessed here. Or, phrased differently, the lifetime created
    at 1 does not extend into this branch: there is no flow from `r` beyond 2, and
    therefore there are no conflicting flows. The borrow checker then finds the use
    of `r` in the print statement at 3. It walks the path back to 1 and finds no conflicting
    uses (2 is not on that path), so it accepts this use as well.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们获取对`x`的引用时，生命周期从1开始。在第一个分支2时，我们立即尝试通过将`x`的值更改为`84`来修改`x`，这需要一个`&mut x`。借用检查器获取对`x`的可变引用，并立即检查它的使用。它没有发现引用被获取时与使用时之间存在冲突的使用，因此它接受了这段代码。如果你习惯于将生命周期视为作用域，可能会感到惊讶，因为`r`仍然在2时有效（它在4时失效）。但是，借用检查器足够智能，能意识到如果选择了这个分支，`r`之后不会被使用，因此允许在此处可变地访问`x`。换句话说，从1开始的生命周期不会延伸到这个分支：在2之后没有来自`r`的流动，因此没有冲突的流动。借用检查器接着找到了在3时打印语句中使用`r`的地方。它回溯到1，并没有发现冲突的使用（2不在这个路径上），因此它也接受了这个使用。
- en: If we were to add another use of `r` at 4 in [Listing 1-8](#listing1-8), the
    code would no longer compile. The lifetime `'a` would then last from 1 all the
    way until 4 (the last use of `r`), and when the borrow checker checked our new
    use of `r`, it would discover a conflicting use at 2.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在[清单 1-8](#listing1-8)中添加一个在4时对`r`的使用，代码将不再编译。生命周期`'a`将从1持续到4（`r`的最后一次使用），当借用检查器检查我们对`r`的新使用时，它会在2时发现一个冲突的使用。
- en: Lifetimes can get quite convoluted. In [Listing 1-9](#listing1-9) you can see
    an example of a lifetime that has *holes*, where it’s intermittently invalid between
    where it starts and where it ultimately ends.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期可能变得相当复杂。在[清单 1-9](#listing1-9)中，你可以看到一个生命周期的例子，它有*空洞*，在它开始和最终结束之间存在间歇性无效的情况。
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 1-9: Lifetimes can have holes.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-9：生命周期可以有空洞。
- en: The lifetime starts at 1 when we take a reference to `x`. We then move out of
    `x` at 3, which ends the lifetime `'a` because it is no longer valid. The borrow
    checker accepts this move by considering `'a` ended at 2, which leaves no conflicting
    flows from `x` at 3. Then, we restart the lifetime by updating the reference in
    `z` 4. Regardless of whether the code now loops back around to 2 or continues
    to the final print statement, both of those uses now have a valid value to flow
    from, and there are no conflicting flows, so the borrow checker accepts the code!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们获取对`x`的引用时，生命周期从1开始。然后在3时我们离开了`x`，这结束了生命周期`'a`，因为它不再有效。借用检查器通过认为`'a`在2时结束，从而接受了这个移动，这样在3时`x`没有冲突的流动。接着，我们通过在`z`中更新引用在4时重新启动生命周期。不管代码现在是回到2还是继续到最终的打印语句，这两种使用方式都有有效的值流动，并且没有冲突的流动，所以借用检查器接受了这段代码！
- en: Again, this aligns perfectly with the data-flow model of memory we discussed
    earlier. When `x` is moved, `z` stops existing. When we reassign `z` later, we
    are creating an entirely new variable that exists only from that point forward.
    It just so happens that that new variable is also named `z`. With that model in
    mind, this example is not weird.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这与我们之前讨论的内存数据流模型完全一致。当`x`被移动时，`z`就停止存在了。当我们稍后重新赋值给`z`时，我们实际上是在创建一个从那时起才存在的新变量。恰好的是，这个新变量也被命名为`z`。考虑到这个模型，这个例子并不奇怪。
- en: Generic Lifetimes
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 泛型生命周期
- en: Occasionally you need to store references within your own types. Those references
    need to have a lifetime so that the borrow checker can check their validity when
    they are used in the various methods on that type. This is especially true if
    you want a method on your type to return a reference that outlives the reference
    to `self`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要在自己的类型中存储引用。这些引用需要有一个生命周期，以便借用检查器在它们在该类型的各种方法中使用时检查它们的有效性。如果你希望类型上的方法返回一个比对`self`的引用生命周期更长的引用，这一点尤其重要。
- en: Rust lets you make a type definition generic over one or more lifetimes, just
    as it allows you to make it generic over types. *The Rust Programming Language*
    by Steve Klabnik and Carol Nichols (No Starch Press, 2018) covers this topic in
    some detail, so I won’t reiterate the basics here. But as you write more complex
    types of this nature, there are two subtleties around the interaction between
    such types and lifetimes that you should be aware of.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Rust允许你在一个或多个生命周期上定义泛型类型，就像它允许你在类型上定义泛型一样。Steve Klabnik和Carol Nichols的《*Rust编程语言*》（No
    Starch Press，2018）对此主题进行了详细讲解，因此我在这里不会重复基础知识。但在你编写此类更复杂的类型时，有两个关于这些类型与生命周期交互的细微之处是你需要注意的。
- en: First, if your type also implements `Drop`, then dropping your type counts as
    a use of any lifetime or type your type is generic over. Essentially, when an
    instance of your type is dropped, the borrow checker will check that it’s still
    legal to use any of your type’s generic lifetimes before dropping it. This is
    necessary in case your drop code *does* use any of those references. If your type
    does not implement `Drop`, dropping the type does *not* count as a use, and users
    are free to ignore any references stored in your type as long as they do not use
    it anymore, like we saw in [Listing 1-7](#listing1-7). We’ll talk more about these
    rules around dropping in Chapter 9.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你的类型还实现了`Drop`，那么丢弃你的类型就算作使用了任何类型或生命周期。基本上，当你的类型的一个实例被丢弃时，借用检查器会检查在丢弃之前是否仍然合法使用你的类型的任何泛型生命周期。这是必要的，以防你的丢弃代码*确实*使用了这些引用。如果你的类型没有实现`Drop`，丢弃类型就*不*算作使用，用户可以忽略存储在类型中的任何引用，只要他们不再使用它，就像我们在[列表1-7](#listing1-7)中看到的那样。我们将在第9章中进一步讨论这些与丢弃相关的规则。
- en: Second, while a type can be generic over multiple lifetimes, making it so often
    only serves to unnecessarily complicate your type signature. Usually, a type being
    generic over a single lifetime is fine, and the compiler will use the shorter
    of the lifetimes for any references inserted into your type as that one lifetime.
    You should only really use multiple generic lifetime parameters if you have a
    type that contains multiple references, and its methods return references that
    should be tied to the lifetime of only *one* of those references.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，虽然一个类型可以在多个生命周期上进行泛型化，但这样做往往只会让类型签名变得不必要地复杂。通常，一个类型在单一生命周期上进行泛型化就足够了，编译器会使用插入到类型中的任何引用的较短生命周期作为那个生命周期。如果你有一个包含多个引用的类型，并且它的方法返回的引用应该与这些引用中的*一个*的生命周期绑定在一起时，你才真的需要使用多个泛型生命周期参数。
- en: Consider the type in [Listing 1-10](#listing1-10), which gives you an iterator
    over parts of a string separated by a particular other string.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[列表1-10](#listing1-10)中的类型，它提供了一个迭代器，用于遍历由特定字符串分隔的字符串部分。
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 1-10: A type that needs to be generic over multiple lifetimes'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1-10：需要在多个生命周期上进行泛型化的类型
- en: 'When you construct this type, you have to give the `delimiter` and `document`
    to search, both of which are references to string values. When you ask for the
    next string, you get a reference into the document. Consider what would happen
    if you used a single lifetime in this type. The values yielded by the iterator
    would be tied to the lifetime of the `document` *and* the `delimiter`. This would
    make `str_before` impossible to write: the return type would have a lifetime associated
    with a variable local to the function—the `String` produced by `to_string`—and
    the borrow checker would reject the code.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建这种类型时，你必须提供`delimiter`和`document`来进行搜索，它们都是字符串值的引用。当你请求下一个字符串时，你会获得一个指向文档的引用。想一想如果你在这个类型中使用单一生命周期会发生什么。迭代器产生的值将与`document`*和*`delimiter`的生命周期绑定在一起。这将使得`str_before`无法编写：返回类型会与一个局部变量的生命周期相关联——由`to_string`生成的`String`——借用检查器将拒绝这段代码。
- en: Lifetime Variance
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生命周期方差
- en: Variance is a concept that programmers are often exposed to but rarely know
    the name of because it’s mostly invisible. At a glance, variance describes what
    types are subtypes of other types and when a subtype can be used in place of a
    supertype (and vice versa). Broadly speaking, a type `A` is a subtype of another
    type `B` if `A` is at least as useful as `B`. Variance is the reason why, in Java,
    you can pass a `Turtle` to a function that accepts an `Animal` if `Turtle` is
    a subtype of `Animal`, or why, in Rust, you can pass a `&'static str` to a function
    that accepts a `&'a str`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 方差是一个程序员常常接触到的概念，但很少知道它的名字，因为它大多数时候是不可见的。方差从表面上看描述了哪些类型是其他类型的子类型，以及何时可以用子类型替代父类型（反之亦然）。广义来说，如果类型`A`至少和类型`B`一样有用，那么`A`是`B`的子类型。方差是为什么在
    Java 中，如果`Turtle`是`Animal`的子类型，你可以将一个`Turtle`传递给一个接受`Animal`的函数，或者在 Rust 中，你可以将`&'static
    str`传递给一个接受`&'a str`的函数。
- en: 'While variance usually hides out of sight, it comes up often enough that we
    need to have a working knowledge of it. `Turtle` is a subtype of `Animal` because
    a `Turtle` is more “useful” than some unspecified `Animal`—a `Turtle` can do anything
    an `Animal` can do, and likely more. Similarly, `''static` is a subtype of `''a`
    because a `''static` lives at least as long as any `''a` and so is more useful.
    Or, more generally, if `''b: ''a` (`''b` outlives `''a`), then `''b` is a subtype
    of `''a`. This is obviously not the formal definition, but it gets close enough
    to be of practical use.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然方差通常是隐藏的，但它足够常见，我们需要对它有一定的了解。`Turtle`是`Animal`的子类型，因为`Turtle`比某个不具体指定的`Animal`更“有用”——`Turtle`可以做任何`Animal`能做的事情，而且可能做得更多。同样，`''static`是`''a`的子类型，因为`''static`至少与任何`''a`一样长，因此更有用。或者更普遍地说，如果`''b:
    ''a`（即`''b`的生命周期比`''a`长），那么`''b`是`''a`的子类型。这显然不是正式的定义，但它已经足够接近实际使用了。'
- en: 'All types have a variance, which defines what other similar types can be used
    in that type’s place. There are three kinds of variance: covariant, invariant,
    and contravariant. A type is *covariant* if you can just use a subtype in place
    of the type. For example, if a variable is of type `&''a T`, you can provide a
    value of type `&''static T` to it, because `&''a T` is covariant in `''a`. `&''a
    T` is also covariant in `T`, so you can pass a `&Vec<&''static str>` to a function
    that takes `&Vec<&''a str>`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型都有一个方差，它定义了哪些其他相似的类型可以替代该类型。有三种方差：协变、不变和逆变。如果你可以直接用子类型替代该类型，则该类型是*协变的*。例如，如果一个变量的类型是`&'a
    T`，你可以向其提供一个类型为`&'static T`的值，因为`&'a T`在`'a`上是协变的。`&'a T`在`T`上也是协变的，因此你可以将一个`&Vec<&'static
    str>`传递给一个接受`&Vec<&'a str>`的函数。
- en: Some types are *invariant*, which means that you must provide exactly the given
    type. `&mut T` is an example of this—if a function takes a `&mut Vec<&'a str>`,
    you cannot pass it a `&mut Vec<&'static str>`. That is, `&mut T` is invariant
    in `T`. If you could, the function could put a short-lived string inside the `Vec`,
    which the caller would then continue using, thinking that it were a `Vec<&'static
    str>` and thus that the contained string were `'static`! Any type that provides
    mutability is generally invariant for the same reason—for example, `Cell<T>` is
    invariant in `T`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类型是*不变的*，这意味着你必须提供完全相同的类型。`&mut T`就是一个例子——如果一个函数接受`&mut Vec<&'a str>`，你不能传递给它一个`&mut
    Vec<&'static str>`。也就是说，`&mut T`在`T`中是不可变的。如果可以这样做，函数可能会在`Vec`中放入一个生命周期较短的字符串，调用者然后继续使用它，以为它是一个`Vec<&'static
    str>`，从而认为里面的字符串是`'static`！任何提供可变性的类型通常都是不可变的，原因是相同的——例如，`Cell<T>`在`T`中是不变的。
- en: 'The last category, *contravariance*, comes up for function arguments. Function
    types are more useful if they’re okay with their arguments being *less* useful.
    This is clearer if you contrast the variance of the argument types on their own
    with their variance when used as function arguments:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一类，*协变*，出现在函数参数中。如果函数类型允许其参数变得*不那么*有用，那么函数类型会更有用。如果将参数类型的方差与作为函数参数时的方差进行对比，这一点会更加清晰：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This flipped relationship indicates that `Fn(T)` is contravariant in `T`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种反转的关系表明，`Fn(T)`在`T`上是协变的。
- en: So why do you need to learn about variance when it comes to lifetimes? Variance
    becomes relevant when you consider how generic lifetime parameters interact with
    the borrow checker. Consider a type like the one shown in [Listing 1-11](#listing1-11),
    which uses multiple lifetimes in a single field.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么在处理生命周期时需要了解方差呢？方差变得重要是当你考虑泛型生命周期参数如何与借用检查器交互时。考虑像[示例 1-11](#listing1-11)中所示的类型，它在单个字段中使用了多个生命周期。
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 1-11: A type that needs to be generic over multiple lifetimes'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-11：一个需要多个生命周期的泛型类型
- en: At first glance, using two lifetimes here seems unnecessary—we have no methods
    that need to differentiate between a borrow of different parts of the structure,
    as we did with `StrSplit` in [Listing 1-10](#listing1-10). But if you replace
    the two lifetimes here with a single `'a`, the code no longer compiles! And it’s
    all because of variance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，在这里使用两个生命周期似乎是不必要的——我们没有需要区分结构体不同部分借用的方法，正如在[示例 1-10](#listing1-10)中我们对`StrSplit`所做的那样。但如果你将这里的两个生命周期替换为一个`'a`，代码将无法编译！这完全是因为方差的原因。
- en: At 1, the compiler must determine what lifetime the lifetime parameter(s) should
    be set to. If there are two lifetimes, `'a` is set to the to-be-determined lifetime
    of the borrow of `s`, and `'b` is set to `'static` since that’s the lifetime of
    the provided string `"hello"`. If there is just one lifetime `'a`, the compiler
    infers that that lifetime must be `'static`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在1处，编译器必须确定生命周期参数应该设置为什么生命周期。如果有两个生命周期，`'a`被设置为`s`借用的待定生命周期，而`'b`被设置为`'static`，因为这是提供的字符串`"hello"`的生命周期。如果只有一个生命周期`'a`，编译器推断该生命周期必须是`'static`。
- en: When we later attempt to access the string reference `s` through a shared reference
    to print it, the compiler tries to shorten the mutable borrow of `s` used by `MutStr`
    to allow the shared borrow of `s`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们稍后尝试通过共享引用来访问字符串引用`s`并打印时，编译器试图缩短`MutStr`所使用的`s`的可变借用，以允许`s`的共享借用。
- en: In the two-lifetime case, `'a` simply ends just before the `println`, and `'b`
    stays the same. In the single-lifetime case, on the other hand, we run into issues.
    The compiler wants to shorten the borrow of `s`, but to do so, it would also have
    to shorten the borrow of the `str`. While `&'static str` can in general be shortened
    to any `&'a str` (`&'a T` is covariant in `'a`), here it’s behind a `&mut T`,
    which is invariant in `T`. Invariance requires that the relevant type is never
    replaced with a sub- or supertype, so the compiler’s attempt to shorten the borrow
    fails, and it reports that `s` is still mutably borrowed. Ouch!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个生命周期的情况下，`'a`仅在`println`之前结束，而`'b`保持不变。另一方面，在单一生命周期的情况下，我们遇到了问题。编译器想要缩短`s`的借用，但为此，它还必须缩短`str`的借用。虽然`&'static
    str`通常可以缩短为任何`&'a str`（`&'a T`在`'a`上是协变的），但这里它处于`&mut T`背后，而`&mut T`在`T`上是不可变的。不变性要求相关类型永远不能被替换为子类型或父类型，因此编译器试图缩短借用失败，并报告`s`仍然被可变借用。哎呀！
- en: Because of the reduced flexibility imposed by invariance, you want to ensure
    that your types remain covariant (or contravariant where appropriate) over as
    many of their generic parameters as possible. If that requires introducing additional
    lifetime arguments, you need to carefully weigh the cognitive cost of adding another
    parameter against the ergonomic cost of invariance.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不变性带来的灵活性降低，你需要确保你的类型在尽可能多的泛型参数上保持协变（或在适当的地方保持逆变）。如果这要求引入额外的生命周期参数，你需要仔细权衡增加另一个参数的认知成本与不变性带来的人体工学成本。
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: The aim of this chapter has been to establish a solid, shared foundation that
    we can build on in the chapters to come. By now, I hope you feel that you have
    a firm grasp on Rust’s memory and ownership model, and that those errors you may
    have gotten from the borrow checker seem less mysterious. You might have known
    bits and pieces of what we covered here already, but hopefully the chapter has
    given you a more holistic image of how it all fits together. In the next chapter,
    we will do something similar for types. We’ll go over how types are represented
    in memory, see how generics and traits produce running code, and take a look at
    some of the special type and trait constructs Rust offers for more advanced use
    cases.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是建立一个坚实的、共同的基础，以便在接下来的章节中继续构建。到现在为止，我希望你已经牢牢掌握了 Rust 的内存和所有权模型，并且那些你可能从借用检查器那里收到的错误看起来不再那么神秘了。你可能已经了解了我们在这里讲解的一些知识点，但希望本章能给你提供一个更加全面的视角，帮助你理解它们是如何相互联系的。在下一章，我们将做类似的内容，探讨类型。我们将介绍类型如何在内存中表示，看看泛型和特性如何生成可运行的代码，并了解
    Rust 提供的一些特殊类型和特性构造，用于更高级的用例。
