- en: '14'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: READING OFFLINE REGISTRY HIVES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 离线读取注册表 Hive
- en: '![](images/00010.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00010.jpg)'
- en: The Windows NT registry is a gold mine of information for useful data such as
    patch levels and password hashes. And that information isn’t just useful for offensive
    pentesters looking to exploit a network; it’s also useful for anyone in the incident
    response or data forensics area of information security.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Windows NT 注册表是一个金矿，里面包含了很多有用的数据，比如补丁级别和密码哈希。而这些信息不仅对那些希望利用网络漏洞的渗透测试者有用，对任何从事信息安全事件响应或数据取证的人员也同样有价值。
- en: Say, for example, you’re handed the hard drive of a computer that has been breached
    and you need to find out what happened. What do you do? Being able to read key
    information from the hard drive regardless of whether Windows can run is imperative.
    The Windows registry is actually a collection of files on the disk, called registry
    hives, and learning your way around the registry hives will allow you to better
    use these hives that hold so much useful information. Registry hives are also
    a great introduction to parsing binary file formats, which are made to store data
    efficiently for computers but are not so great for human consumption.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你拿到了一台被入侵的计算机的硬盘，并且你需要找出发生了什么事情。你该怎么做？无论 Windows 是否能正常运行，从硬盘中读取关键信息都是至关重要的。Windows
    注册表实际上是磁盘上一组文件，称为注册表 Hive，学会如何浏览注册表 Hive 能让你更好地利用这些包含大量有用信息的 Hive。注册表 Hive 也是解析二进制文件格式的一个很好的入门，二进制文件格式是为了计算机高效存储数据而设计的，但对人类来说并不太友好。
- en: In this chapter, we discuss the Windows NT registry hive data structure, and
    we write a small library with a few classes to read offline hives from which we
    can extract useful information, such as the boot key. This is useful if you want
    to extract password hashes from the registry later.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 Windows NT 注册表 Hive 数据结构，并编写一个包含几个类的小型库来读取离线 Hive，从中提取有用信息，比如启动键。如果你以后想从注册表中提取密码哈希，这将非常有用。
- en: The Registry Hive Structure
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表 Hive 结构
- en: At a high level, the registry hive is a tree of nodes. Each node may have key/value
    pairs, and it may have child nodes. We’ll use the terms node key and value key
    to classify the two types of data in the registry hive and create classes for
    both key types. Node keys contain information about the structure of the tree
    and its subkeys, whereas value keys hold value information that applications access.
    Visually, the tree looks a bit like [Figure 14-1](#filepos897813).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 高级别来看，注册表 Hive 是一个节点树。每个节点可能有键/值对，并且可能有子节点。我们将使用节点键和值键这两个术语来分类注册表 Hive 中的两种数据类型，并为这两种键类型创建类。节点键包含有关树结构及其子键的信息，而值键保存应用程序访问的值信息。从视觉效果来看，树的形态有点像[图
    14-1](#filepos897813)。
- en: '![](images/00002.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00002.jpg)'
- en: 'Figure 14-1: A visual representation of a simple registry tree with nodes,
    keys, and values'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-1：一个简单的注册表树的可视化表示，展示了节点、键和值
- en: Every node key has some specific metadata stored alongside it, such as the last
    time its value keys were modified and other system-level information. All of this
    data is stored very efficiently for a computer to read—but not for a human. While
    we implement our library, we’ll skip over some of this metadata in order to make
    the end result simpler, but I will call these instances out as we go.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点键都有一些特定的元数据与之一起存储，例如最后一次修改其值键的时间和其他系统级信息。所有这些数据都为计算机读取进行了高效存储——但对人类来说并不友好。在实现我们的库时，我们会跳过一些元数据，以便使最终结果更简洁，但我会在过程中指出这些实例。
- en: As you can see in [Figure 14-1](#filepos897813), after the registry header,
    the node tree begins with the root node key. The root node key has two child nodes,
    which in this example we call Foo and Bar. The Foo node key contains two value
    keys, Baz and Bat, which have values of true and "AHA", respectively. Bar, on
    the other hand, only has child node BarBuzz, which has a single value key. This
    example of a registry hive tree is very contrived and simple. The registry hives
    on your machine are more complex and likely have millions of keys!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[图 14-1](#filepos897813)中看到的，注册表头之后，节点树以根节点键开始。根节点键有两个子节点，在这个示例中我们称它们为 Foo
    和 Bar。Foo 节点键包含两个值键，分别是 Baz 和 Bat，其值分别为 true 和 "AHA"。而 Bar 则只有子节点 BarBuzz，且只有一个值键。这个注册表
    Hive 树的示例非常简单且人为构造。你机器上的注册表 Hive 要复杂得多，可能包含数百万个键！
- en: Getting the Registry Hives
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 获取注册表 Hive
- en: During normal operation, Windows locks the registry hives to prevent tampering.
    Altering the Windows registry can have potentially devastating results, such as
    an unbootable computer, so it’s not something to take lightly. You can, however,
    use cmd.exe to export a given registry hive if you have Administrator access to
    the machine. Windows ships with reg.exe, which is a useful command line utility
    for reading and writing to the registry. We can use this tool to copy the hives
    that we’re interested in so that we can read them offline, as shown in [Listing
    14-1](#filepos900511). This will prevent any accidental catastrophes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常操作期间，Windows 会锁定注册表蜂巢以防止篡改。修改 Windows 注册表可能会带来灾难性后果，比如计算机无法启动，因此这并不是一项可以轻视的操作。然而，如果你具有管理员权限，可以使用
    cmd.exe 导出指定的注册表蜂巢。Windows 随附有 reg.exe，这是一个有用的命令行工具，用于读取和写入注册表。我们可以使用这个工具来复制我们感兴趣的注册表蜂巢，以便离线读取，如
    [Listing 14-1](#filepos900511) 所示。这将防止任何意外灾难的发生。
- en: Microsoft Windows [Version 6.1.7601]
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Microsoft Windows [版本 6.1.7601]
- en: Copyright (c) 2009 Microsoft Corporation. All rights reserved.
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 版权所有 (c) 2009 Microsoft Corporation。保留所有权利。
- en: C:\Windows\system32>reg ➊save HKLM\System C:\system.hive
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: C:\Windows\system32>reg ➊save HKLM\System C:\system.hive
- en: The operation completed successfully.
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 操作成功完成。
- en: 'Listing 14-1: Using  reg.exe  to copy a registry hive'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 14-1：使用 reg.exe 复制注册表蜂巢
- en: Using the save subcommand ➊, we specify the registry path we want to save as
    well as the file to save to. The first argument is the HKLM\System path, which
    is the root registry node for the system registry hive (where information such
    as the boot key resides). By choosing this registry path, we save a copy of the
    system’s registry hive off the machine for further analysis later. This same technique
    can be used for HKLM\Sam (where usernames and hashes are stored) and HKLM\Software
    (where patch levels and other software information are stored). But remember,
    saving these nodes requires administrator access!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用保存子命令 ➊，我们指定要保存的注册表路径以及保存到的文件。第一个参数是 HKLM\System 路径，它是系统注册表蜂巢的根节点（其中包含如启动密钥等信息）。通过选择这个注册表路径，我们可以将系统的注册表蜂巢保存到机器外部，以便以后进行进一步分析。同样的技术可以用于
    HKLM\Sam（存储用户名和哈希值）和 HKLM\Software（存储补丁级别和其他软件信息）。但请记住，保存这些节点需要管理员权限！
- en: There’s also another method for getting the registry hives if you have a hard
    drive you can mount on your machine. You can simply copy the registry hives from
    the System32 folder where the raw hives are stored by the operating system. If
    Windows isn’t running, the hives won’t be locked, and you should be able to copy
    them to another system. You can find the raw hives currently in use by the operating
    system in the directory C:\Windows\ System32\config (see [Listing 14-2](#filepos903808)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个可以挂载到机器上的硬盘，另一个获取注册表蜂巢的方法是直接从 System32 文件夹中复制注册表蜂巢，操作系统将原始蜂巢存储在该文件夹中。如果
    Windows 没有运行，注册表蜂巢不会被锁定，你应该能够将它们复制到其他系统中。你可以在目录 C:\Windows\System32\config 中找到操作系统当前使用的原始蜂巢（参见
    [Listing 14-2](#filepos903808)）。
- en: Microsoft Windows [Version 6.1.7601]
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Microsoft Windows [版本 6.1.7601]
- en: Copyright (c) 2009 Microsoft Corporation. All rights reserved.
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 版权所有 (c) 2009 Microsoft Corporation。保留所有权利。
- en: C:\Windows\system32>cd config
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: C:\Windows\system32>cd config
- en: C:\Windows\System32\config>dir
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: C:\Windows\System32\config>dir
- en: Volume in drive C is BOOTCAMP
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'C: 驱动器的卷标是 BOOTCAMP'
- en: Volume Serial Number is B299-CCD5
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 卷序列号为 B299-CCD5
- en: Directory of C:\Windows\System32\config
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: C:\Windows\System32\config 目录
- en: 01/24/2016 02:17 PM <DIR> .
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 01/24/2016 02:17 PM <DIR> .
- en: 01/24/2016 02:17 PM <DIR> ..
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 01/24/2016 02:17 PM <DIR> ..
- en: 05/23/2014 03:19 AM 28,672 BCD-Template
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 05/23/2014 03:19 AM 28,672 BCD-Template
- en: 01/24/2016 02:24 PM 60,555,264 COMPONENTS
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 01/24/2016 02:24 PM 60,555,264 COMPONENTS
- en: 01/24/2016 02:24 PM 4,456,448 DEFAULT
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 01/24/2016 02:24 PM 4,456,448 DEFAULT
- en: 07/13/2009 08:34 PM <DIR> Journal
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 07/13/2009 08:34 PM <DIR> Journal
- en: 09/21/2015 05:56 PM 42,909,696 prl_boot
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 09/21/2015 05:56 PM 42,909,696 prl_boot
- en: 01/19/2016 12:17 AM <DIR> RegBack
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 01/19/2016 12:17 AM <DIR> RegBack
- en: 01/24/2016 02:13 PM 262,144 SAM
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 01/24/2016 02:13 PM 262,144 SAM
- en: 01/24/2016 02:24 PM 262,144 SECURITY ➊
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 01/24/2016 02:24 PM 262,144 SECURITY ➊
- en: 01/24/2016 02:36 PM 115,867,648 SOFTWARE ➋
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 01/24/2016 02:36 PM 115,867,648 SOFTWARE ➋
- en: 01/24/2016 02:33 PM 15,728,640 SYSTEM ➌
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 01/24/2016 02:33 PM 15,728,640 SYSTEM ➌
- en: 06/22/2014 06:13 PM <DIR> systemprofile
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 06/22/2014 06:13 PM <DIR> systemprofile
- en: 05/24/2014 10:45 AM <DIR> TxR
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 05/24/2014 10:45 AM <DIR> TxR
- en: 8 File(s) 240,070,656 bytes
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8 个文件 240,070,656 字节
- en: 6 Dir(s) 332,737,015,808 bytes free
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6 个目录 332,737,015,808 字节可用
- en: C:\Windows\System32\config>
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: C:\Windows\System32\config>
- en: 'Listing 14-2: The contents of the C:\Windows\System32\config folder with registry
    hives'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 14-2：C:\Windows\System32\config 文件夹中的注册表蜂巢内容
- en: '[Listing 14-2](#filepos903808) shows the registry hives in the directory. The
    SECURITY ➊, SOFTWARE ➋, and SYSTEM ➌ hives are the ones with the most commonly
    sought information. Once hives are copied onto your system, you can easily verify
    that you have saved the registry hives you want to read with the file command
    if you are using Linux or OS X, as shown in [Listing 14-3](#filepos904821).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 14-2](#filepos903808) 显示了目录中的注册表蜂巢。SECURITY ➊、SOFTWARE ➋ 和 SYSTEM ➌ 是包含最常查找信息的蜂巢。一旦蜂巢文件复制到你的系统上，如果你使用的是
    Linux 或 OS X，你可以轻松验证你保存了想要读取的注册表蜂巢，方法是使用文件命令，正如 [列表 14-3](#filepos904821) 所示。'
- en: $ file system.hive
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ 文件系统.hive
- en: 'system.hive: MS Windows registry file, NT/2000 or above'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: system.hive：MS Windows 注册表文件，NT/2000 或更高版本
- en: $
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $
- en: 'Listing 14-3: Confirming which registry hive you saved in Linux or OS X'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-3：确认你在 Linux 或 OS X 中保存了哪个注册表蜂巢
- en: Now we’re ready to start digging into a hive.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备开始分析注册表文件了。
- en: Reading the Registry Hive
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 读取注册表蜂巢
- en: We’ll start by reading the registry hive header, a 4,096-byte chunk of data
    at the beginning of the registry hive. Don’t worry, only the first 20 bytes or
    so are actually useful for parsing, and we’ll only read the first four to verify
    the file is a registry hive. The remaining 4,000+ bytes are just buffer.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从读取注册表蜂巢头开始，它是位于注册表蜂巢开头的 4,096 字节数据块。别担心，实际上只有前 20 字节左右对于解析是有用的，我们将只读取前四个字节来验证文件是否为注册表蜂巢。剩余的
    4,000 多字节只是缓冲区。
- en: Creating a Class to Parse a Registry Hive File
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类来解析注册表蜂巢文件
- en: 'We’ll create a new class to begin parsing the file: the RegistryHive class.
    This is one of the simpler classes we’ll implement in order to read offline registry
    hives. It has only a constructor and a few properties, as shown in [Listing 14-4](#filepos907483).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的类来开始解析文件：RegistryHive 类。这是我们为读取离线注册表蜂巢实现的几个简单类之一。它只有一个构造函数和一些属性，如 [列表
    14-4](#filepos907483) 所示。
- en: public class RegistryHive
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class RegistryHive
- en: '{'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public ➊RegistryHive(string file)
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public ➊RegistryHive(string file)
- en: '{'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (!➋File.Exists(file))
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (!➋File.Exists(file))
- en: throw new FileNotFoundException();
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: throw new FileNotFoundException();
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Filepath = file;
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Filepath = file;
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (FileStream stream = ➌File.OpenRead(file))
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (FileStream stream = ➌File.OpenRead(file))
- en: '{'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (BinaryReader reader = new ➍BinaryReader(stream))
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (BinaryReader reader = new ➍BinaryReader(stream))
- en: '{'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: byte[] buf = reader.ReadBytes(4);
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] buf = reader.ReadBytes(4);
- en: ''
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if ➎(buf[0] != 'r' || buf[1] != 'e' || buf[2] != 'g' || buf[3] != 'f')
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if ➎(buf[0] != 'r' || buf[1] != 'e' || buf[2] != 'g' || buf[3] != 'f')
- en: throw new NotSupportedException("File not a registry hive.");
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: throw new NotSupportedException("文件不是注册表蜂巢。");
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: //fast-forward
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: //快进
- en: ➏reader.BaseStream.Position = 4096 + 32 + 4;
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➏reader.BaseStream.Position = 4096 + 32 + 4;
- en: ''
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.RootKey = new ➐NodeKey(reader);
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.RootKey = new ➐NodeKey(reader);
- en: '}'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: public string Filepath { get; set; }
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Filepath { get; set; }
- en: public NodeKey RootKey { get; set; }
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public NodeKey RootKey { get; set; }
- en: public bool WasExported { get; set; }
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public bool WasExported { get; set; }
- en: '}'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 14-4: The  RegistryHive  class'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-4：RegistryHive 类
- en: Let’s look at the constructor where the magic first happens. The constructor
    ➊ accepts a single argument, which is the file path to the offline registry hive
    on the filesystem. We check whether the path exists using File.Exists() ➋, and
    we throw an exception if it doesn’t.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看构造函数，魔术就在这里开始。构造函数 ➊ 接受一个参数，即文件系统中离线注册表蜂巢的文件路径。我们使用 File.Exists() ➋ 检查路径是否存在，如果不存在就抛出异常。
- en: 'Once we have determined the file exists, we need to make sure it is a registry
    file. But this is not hard. The first four magic bytes of any registry hive should
    be r, e, g, and f. To check whether our file matches, we open a stream to read
    the file using File.OpenRead() ➌. Then we create a new BinaryReader ➍ by passing
    the file stream to the BinaryReader constructor. We use this to read the first
    four bytes of the file and store them in a byte array. Then, we check whether
    they match ➎. If they don’t, we throw an exception: the hive is either too damaged
    to be read normally or is not a hive at all!'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定文件存在，我们需要确保它是一个注册表文件。但这并不难。任何注册表蜂巢的前四个魔术字节应该是 r、e、g 和 f。为了检查我们的文件是否匹配，我们使用
    File.OpenRead() ➌ 打开一个流来读取文件。然后，我们通过将文件流传递给 BinaryReader 构造函数 ➍ 来创建一个新的 BinaryReader。我们用它来读取文件的前四个字节，并将它们存储在一个字节数组中。然后，我们检查它们是否匹配
    ➎。如果不匹配，我们就抛出一个异常：蜂巢文件要么损坏得无法正常读取，要么根本就不是一个蜂巢文件！
- en: If the header checks out, though, we fast-forward ➏ to the end of the registry
    header block to the root node key (skipping some metadata we don’t need at the
    moment). In the next section, we create a NodeKey class to handle our node keys
    so we can read the key by passing the BinaryReader to a NodeKey constructor ➐,
    and we assign the new NodeKey to the RootKey property for later use.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果头部检查通过，那么我们快速前进到➏注册表头部块的末尾，找到根节点键（跳过我们此时不需要的一些元数据）。在下一节中，我们将创建一个NodeKey类来处理我们的节点键，这样我们就可以通过将BinaryReader传递给NodeKey构造函数➐来读取该键，并将新的NodeKey分配给RootKey属性以供以后使用。
- en: Creating a Class for Node Keys
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 创建NodeKey类
- en: The NodeKey class is the most complex class we need to implement to read the
    offline registry hive. There is a bit of metadata stored in the registry hive
    for node keys that we can skip, but there’s a lot that we can’t. However, the
    constructor for the NodeKey class is quite simple, though it has quite a few properties,
    as [Listing 14-5](#filepos911598) shows.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: NodeKey类是我们需要实现的最复杂的类，用于读取离线注册表hive。注册表hive中存储了一些节点键的元数据，我们可以跳过其中的一些，但有很多是我们无法跳过的。然而，NodeKey类的构造函数相当简单，尽管它有很多属性，如[Listing
    14-5](#filepos911598)所示。
- en: public class NodeKey
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class NodeKey
- en: '{'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public ➊NodeKey(BinaryReader hive)
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public ➊NodeKey(BinaryReader hive)
- en: '{'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ReadNodeStructure(hive);
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ReadNodeStructure(hive);
- en: ReadChildrenNodes(hive);
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ReadChildrenNodes(hive);
- en: ReadChildValues(hive);
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ReadChildValues(hive);
- en: '}'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public List<NodeKey> ➋ChildNodes { get; set; }
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public List<NodeKey> ➋ChildNodes { get; set; }
- en: public List<ValueKey> ➌ChildValues { get; set; }
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public List<ValueKey> ➌ChildValues { get; set; }
- en: public DateTime ➍Timestamp { get; set; }
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public DateTime ➍Timestamp { get; set; }
- en: public int ParentOffset { get; set; }
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int ParentOffset { get; set; }
- en: public int SubkeysCount { get; set; }
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int SubkeysCount { get; set; }
- en: public int LFRecordOffset { get; set; }
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int LFRecordOffset { get; set; }
- en: public int ClassnameOffset { get; set; }
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int ClassnameOffset { get; set; }
- en: public int SecurityKeyOffset { get; set; }
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int SecurityKeyOffset { get; set; }
- en: public int ValuesCount { get; set; }
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int ValuesCount { get; set; }
- en: public int ValueListOffset { get; set; }
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int ValueListOffset { get; set; }
- en: public short NameLength { get; set; }
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public short NameLength { get; set; }
- en: public bool IsRootKey { get; set; }
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public bool IsRootKey { get; set; }
- en: public short ClassnameLength { get; set; }
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public short ClassnameLength { get; set; }
- en: public string Name { get; set; }
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Name { get; set; }
- en: public byte[] ClassnameData { get; set; }
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public byte[] ClassnameData { get; set; }
- en: public NodeKey ParentNodeKey { get; set; }
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public NodeKey ParentNodeKey { get; set; }
- en: 'Listing 14-5: The  NodeKey  class constructor and properties'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 14-5: NodeKey类的构造函数和属性'
- en: 'The NodeKey class constructor ➊ takes a single argument, which is a BinaryReader
    for the registry hive. The constructor calls three methods that read and parse
    specific parts of the node, which we’ll implement next. After the constructor,
    we define several properties that will be used throughout the next three methods.
    The first three properties are particularly useful: ChildNodes ➋, ChildValues
    ➌, and Timestamp ➍.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: NodeKey类的构造函数➊接收一个参数，即注册表hive的BinaryReader。构造函数调用三个方法来读取和解析节点的特定部分，我们将在接下来的部分实现这些方法。在构造函数之后，我们定义了几个将在接下来的三个方法中使用的属性。前三个属性特别有用：ChildNodes
    ➋、ChildValues ➌和Timestamp ➍。
- en: The first method called in the NodeKey constructor is ReadNodeStructure(), which
    reads the node key data from the registry hive but not any of its child nodes
    or values. This is detailed in [Listing 14-6](#filepos914845).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: NodeKey构造函数中调用的第一个方法是ReadNodeStructure()，该方法从注册表hive读取节点键数据，但不包括其子节点或值。详细内容请参见[Listing
    14-6](#filepos914845)。
- en: private void ReadNodeStructure(BinaryReader hive)
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private void ReadNodeStructure(BinaryReader hive)
- en: '{'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: byte[] buf = hive.➊ReadBytes(4);
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] buf = hive.➊ReadBytes(4);
- en: if (buf[0] != 0x6e || buf[1] != 0x6b) //nk
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (buf[0] != 0x6e || buf[1] != 0x6b) //nk
- en: throw new NotSupportedException("Bad nk header");
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: throw new NotSupportedException("无效的nk头部");
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: long startingOffset = ➋hive.BaseStream.Position;
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: long startingOffset = ➋hive.BaseStream.Position;
- en: 'this.➌IsRootKey = (buf[2] == 0x2c) ? true : false;'
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'this.➌IsRootKey = (buf[2] == 0x2c) ? true : false;'
- en: this.➍Timestamp = DateTime.FromFileTime(hive.ReadInt64());
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.➍Timestamp = DateTime.FromFileTime(hive.ReadInt64());
- en: ''
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: hive.BaseStream.Position += ➎4; //skip metadata
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: hive.BaseStream.Position += ➎4; //跳过元数据
- en: ''
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.ParentOffset = hive.➏ReadInt32();
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.ParentOffset = hive.➏ReadInt32();
- en: this.SubkeysCount = hive.ReadInt32();
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.SubkeysCount = hive.ReadInt32();
- en: ''
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: hive.BaseStream.Position += 4; //skip metadata
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: hive.BaseStream.Position += 4; //跳过元数据
- en: ''
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.LFRecordOffset = hive.ReadInt32();
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.LFRecordOffset = hive.ReadInt32();
- en: ''
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: hive.BaseStream.Position += 4; //skip metadata
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: hive.BaseStream.Position += 4; //跳过元数据
- en: ''
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.ValuesCount = hive.ReadInt32();
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.ValuesCount = hive.ReadInt32();
- en: this.ValueListOffset = hive.ReadInt32();
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.ValueListOffset = hive.ReadInt32();
- en: this.SecurityKeyOffset = hive.ReadInt32();
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.SecurityKeyOffset = hive.ReadInt32();
- en: this.ClassnameOffset = hive.ReadInt32();
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.ClassnameOffset = hive.ReadInt32();
- en: ''
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: hive.BaseStream.Position = startingOffset + 68;
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: hive.BaseStream.Position = startingOffset + 68;
- en: ''
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.NameLength = hive.➐ReadInt16();
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.NameLength = hive.➐ReadInt16();
- en: this.ClassnameLength = hive.ReadInt16();
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.ClassnameLength = hive.ReadInt16();
- en: ''
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: buf = hive.➑ReadBytes(this.NameLength);
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: buf = hive.➑ReadBytes(this.NameLength);
- en: this.Name = System.Text.Encoding.UTF8.GetString(buf);
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Name = System.Text.Encoding.UTF8.GetString(buf);
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: hive.BaseStream.Position = this.ClassnameOffset + 4 + 4096;
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: hive.BaseStream.Position = this.ClassnameOffset + 4 + 4096;
- en: this.➒ClassnameData = hive.ReadBytes(this.ClassnameLength);
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.➒ClassnameData = hive.ReadBytes(this.ClassnameLength);
- en: '}'
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 14-6: The  ReadNodeStructure()  method of the  NodeKey  class'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-6：NodeKey 类的 ReadNodeStructure() 方法
- en: To begin the ReadNodeStructure() method, we read the next four bytes of the
    node key with ReadBytes() ➊ to check that we are at the beginning of a node key
    (note that the second two bytes are junk that we can ignore for our purposes;
    we only care about the first two bytes). We compare the first two of these bytes
    to 0x6e and 0x6b, respectively. We are looking for the two hexadecimal byte values
    that represent the ASCII characters n and k (for node key). Every node key in
    the registry hive starts with these two bytes, so we can always be sure that we
    are parsing what we expect. After determining we are reading a node key, we save
    our current position ➋ in the file stream so that we can easily return to it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始 ReadNodeStructure() 方法，我们使用 ReadBytes() ➊ 读取节点键的接下来的四个字节，以检查是否位于节点键的开始位置（请注意，第二个两个字节是我们可以忽略的垃圾数据；我们只关心前两个字节）。我们将这两个字节分别与
    0x6e 和 0x6b 进行比较。我们正在寻找代表 ASCII 字符 n 和 k（表示节点键）的两个十六进制字节值。注册表中的每个节点键都以这两个字节开始，因此我们可以始终确保正在解析我们预期的数据。在确定我们正在读取一个节点键后，我们保存当前的文件流位置
    ➋，以便稍后可以轻松返回到此位置。
- en: Next, we begin assigning values to some of the NodeKey properties, starting
    with the IsRootKey ➌ and Timestamp ➍ properties. Notice that every few lines,
    we skip ahead by four in the current stream position ➎ without reading anything.
    We’re skipping pieces of metadata that aren’t necessary for our purposes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始为一些 NodeKey 属性赋值，从 IsRootKey ➌ 和 Timestamp ➍ 属性开始。注意，每隔几行，我们会在当前流位置
    ➎ 跳过四个字节而不读取任何内容。我们跳过了一些对于我们目的不必要的元数据。
- en: Then, we use the ReadInt32() method ➏ to read four bytes and return an integer
    representing them that C# can read. This is what makes the BinaryReader class
    so useful. It has many convenient methods that will cast bytes for you. As you
    can see, most of the time, we will use the ReadInt32() method, but occasionally
    we will use ReadInt16() ➐ or other methods to read specific types of integers,
    such as unsigned and really long integers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 ReadInt32() 方法 ➏ 读取四个字节，并返回一个 C# 可以读取的整数。这正是 BinaryReader 类如此有用的原因。它有许多方便的方法，可以帮助你将字节转换。正如你所看到的，大多数时候我们会使用
    ReadInt32() 方法，但偶尔我们也会使用 ReadInt16() ➐ 或其他方法来读取特定类型的整数，例如无符号整数或非常长的整数。
- en: Finally, we read the name of the NodeKey ➑ and assign the string to the Name
    property. We also read the class name data ➒, which we will use later when dumping
    the boot key.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们读取 NodeKey 的名称 ➑ 并将该字符串赋给 Name 属性。我们还读取类名数据 ➒，稍后在转储引导键时将使用这些数据。
- en: Now we need to implement the ReadChildrenNodes() method. This method iterates
    over each child node and adds the node to the ChildNodes property so that we can
    analyze it later, as [Listing 14-7](#filepos919727) shows.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要实现 ReadChildrenNodes() 方法。该方法会遍历每个子节点，并将节点添加到 ChildNodes 属性中，以便稍后进行分析，正如
    [列表 14-7](#filepos919727) 所示。
- en: private void ReadChildrenNodes(➊BinaryReader hive)
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private void ReadChildrenNodes(➊BinaryReader hive)
- en: '{'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.ChildNodes = new ➋List<NodeKey>();
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.ChildNodes = new ➋List<NodeKey>();
- en: if (this.LFRecordOffset != -1)
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 (this.LFRecordOffset != -1)
- en: '{'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: hive.BaseStream.Position = 4096 + this.LFRecordOffset + 4;
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: hive.BaseStream.Position = 4096 + this.LFRecordOffset + 4;
- en: byte[] buf = hive.ReadBytes(2);
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] buf = hive.ReadBytes(2);
- en: ''
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: //ri
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: //ri
- en: if ➌(buf[0] == 0x72 && buf[1] == 0x69)
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 ➌(buf[0] == 0x72 && buf[1] == 0x69)
- en: '{'
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: int count = hive.ReadInt16();
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: int count = hive.ReadInt16();
- en: ➍for (int i = 0; i < count; i++)
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➍for (int i = 0; i < count; i++)
- en: '{'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: long pos = hive.BaseStream.Position;
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: long pos = hive.BaseStream.Position;
- en: int offset = hive.ReadInt32();
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: int offset = hive.ReadInt32();
- en: ''
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➎hive.BaseStream.Position = 4096 + offset + 4;
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➎hive.BaseStream.Position = 4096 + offset + 4;
- en: buf = hive.ReadBytes(2);
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: buf = hive.ReadBytes(2);
- en: ''
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (!(buf[0] == 0x6c && (buf[1] == 0x66 || buf[1] == 0x68)))
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 !(buf[0] == 0x6c && (buf[1] == 0x66 || buf[1] == 0x68))
- en: throw new Exception("Bad LF/LH record at:"
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: throw new Exception("在以下位置发现错误的 LF/LH 记录："
- en: + hive.BaseStream.Position);
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: + hive.BaseStream.Position);
- en: ''
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➏ParseChildNodes(hive);
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➏ParseChildNodes(hive);
- en: ''
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➐hive.BaseStream.Position = pos + 4; //go to next record list
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➐hive.BaseStream.Position = pos + 4; //跳转到下一个记录列表
- en: '}'
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: //lf or lh
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: //lf或lh
- en: else if ➑(buf[0] == 0x6c && (buf[1] == 0x66 || buf[1] == 0x68))
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else if ➑(buf[0] == 0x6c && (buf[1] == 0x66 || buf[1] == 0x68))
- en: ➒ParseChildNodes(hive);
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➒ParseChildNodes(hive);
- en: else
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else
- en: 'throw new Exception("Bad LF/LH/RI record at: "'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: throw new Exception("在以下位置发现无效的LF/LH/RI记录："
- en: + hive.BaseStream.Position);
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: + hive.BaseStream.Position);
- en: '}'
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 14-7: The  ReadChildrenNodes()  method of the  NodeKey  class'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 14-7: NodeKey类的ReadChildrenNodes()方法'
- en: Like most of the methods we will be implementing for the NodeKey class, the
    ReadChildrenNodes() method takes a single argument, which is the BinaryReader
    ➊ for the registry hive. We create an empty list ➋ of node keys for the ChildNodes
    property to read to. Then we must parse any child nodes in the current node key.
    This gets a bit tricky because there are three different ways to point to child
    node keys, and one type is read differently than the other two. The three types
    are the ri (for index root), lf (for fast leaf), and lh (for hash leaf) structures.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 像我们将要为NodeKey类实现的大多数方法一样，ReadChildrenNodes()方法接受一个参数，即注册表hive的BinaryReader ➊。我们创建一个空的节点键列表
    ➋，供ChildNodes属性读取。然后，我们必须解析当前节点键中的任何子节点。这有点棘手，因为有三种不同的方式指向子节点键，而且其中一种类型的读取方式与另外两种不同。这三种类型分别是ri（索引根）、lf（快速叶子）和lh（哈希叶子）结构。
- en: We check whether we are on an ri structure ➌ first. The ri structure is a container
    and is stored slightly differently. It is used for pointing to multiple lf or
    lh records and allows a node key to have more child nodes than a single lf or
    lh record can handle. As we loop over each set of child nodes in a for loop ➍,
    we jump to each child record ➎ and call ParseChildNodes() ➏, which we will implement
    next, by passing the BinaryReader for the hive as the only argument. After parsing
    the child nodes, we can see that our stream position has changed (we’ve moved
    around in the registry hive), so we set the stream position back to the ri list
    ➐, where we were before reading the children, in order to read the next record
    in the list.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查是否是ri结构 ➌。ri结构是一个容器，并且存储方式稍有不同。它用于指向多个lf或lh记录，并允许一个节点键拥有比单个lf或lh记录能够处理的更多子节点。在一个for循环
    ➍中遍历每一组子节点时，我们跳转到每个子记录 ➎，并通过将hive的BinaryReader作为唯一参数传递给ParseChildNodes() ➏来调用它，这是我们接下来会实现的。解析完子节点后，我们可以看到流的位置已经发生了变化（我们在注册表hive中移动了位置），因此我们将流的位置重置回ri列表
    ➐，也就是在读取子节点之前的位置，以便读取列表中的下一个记录。
- en: If we are dealing with an lf or lh record ➑, we just pass the BinaryReader to
    the ParseChildNodes() method ➒ and let it read the nodes directly.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在处理一个lf或lh记录 ➑，我们只需要将BinaryReader传递给ParseChildNodes()方法 ➒，并让它直接读取节点。
- en: Luckily, once the child nodes have been read, they can all be parsed in the
    same way, regardless of the structure used to point to them. The method to do
    all of the actual parsing is relatively easy, as shown in [Listing 14-8](#filepos923496).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，一旦子节点被读取，它们都可以以相同的方式进行解析，无论指向它们的结构是什么。执行所有实际解析的方法相对简单，如[示例 14-8](#filepos923496)所示。
- en: private void ParseChildNodes(➊BinaryReader hive)
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private void ParseChildNodes(➊BinaryReader hive)
- en: '{'
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: int count = hive.➋ReadInt16();
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: int count = hive.➋ReadInt16();
- en: long topOfList = hive.BaseStream.Position;
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: long topOfList = hive.BaseStream.Position;
- en: ''
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➌for (int i = 0; i < count; i++)
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➌for (int i = 0; i < count; i++)
- en: '{'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: hive.BaseStream.Position = topOfList + (i*8);
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: hive.BaseStream.Position = topOfList + (i*8);
- en: int newoffset = hive.ReadInt32();
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: int newoffset = hive.ReadInt32();
- en: hive.BaseStream.Position += 4; //skip over registry metadata
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: hive.BaseStream.Position += 4; //跳过注册表元数据
- en: hive.BaseStream.Position = 4096 + newoffset + 4;
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: hive.BaseStream.Position = 4096 + newoffset + 4;
- en: NodeKey nk = new ➍NodeKey(hive) { ParentNodeKey = this };
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: NodeKey nk = new ➍NodeKey(hive) { ParentNodeKey = this };
- en: this.ChildNodes.➎Add(nk);
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.ChildNodes.➎Add(nk);
- en: '}'
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: hive.BaseStream.Position = topOfList + (count * 8);
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: hive.BaseStream.Position = topOfList + (count * 8);
- en: '}'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 14-8: The  ParseChildNodes()  method for the  NodeKey  class'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 14-8: NodeKey类的ParseChildNodes()方法'
- en: ParseChildNodes() takes a single argument, the BinaryReader ➊ for the hive.
    The number of nodes we need to iterate over and parse is stored in a 16-bit integer,
    which we read from the hive ➋. After storing our position so we can return to
    it later, we begin iterating in a for loop ➌, jumping to each new node and passing
    the BinaryReader to the NodeKey class constructor ➍. Once the child NodeKey is
    created, we add ➎ the node to the ChildNodes list and begin the process again,
    until no more nodes are available to be read.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ParseChildNodes()方法接受一个参数，即hive的BinaryReader ➊。我们需要遍历并解析的节点数量存储在一个16位整数中，我们从hive中读取该值➋。在存储当前位置以便稍后返回后，我们开始在for循环中迭代➌，跳转到每个新节点并将BinaryReader传递给NodeKey类构造函数
    ➍。一旦子NodeKey创建完成，我们将➎该节点添加到ChildNodes列表中，然后重新开始这一过程，直到没有更多节点可读取。
- en: The last method, called in the NodeKey constructor, is the ReadChildValues()
    method. This method call, detailed in [Listing 14-9](#filepos925913), populates
    the ChildValues property list with all the key/value pairs we have found in the
    node key.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法是在NodeKey构造函数中调用的，即ReadChildValues()方法。这个方法调用，详见[列表14-9](#filepos925913)，将所有我们在节点键中找到的键/值对填充到ChildValues属性列表中。
- en: private void ReadChildValues(BinaryReader hive)
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private void ReadChildValues(BinaryReader hive)
- en: '{'
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.ChildValues = new ➊List<ValueKey>();
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.ChildValues = new ➊List<ValueKey>();
- en: if (this.ValueListOffset != ➋-1)
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (this.ValueListOffset != ➋-1)
- en: '{'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ➌hive.BaseStream.Position = 4096 + this.ValueListOffset + 4;
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➌hive.BaseStream.Position = 4096 + this.ValueListOffset + 4;
- en: for (int i = 0; i < this.ValuesCount; i++)
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: for (int i = 0; i < this.ValuesCount; i++)
- en: '{'
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: hive.BaseStream.Position = 4096 + this.ValueListOffset + 4 + (i*4);
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: hive.BaseStream.Position = 4096 + this.ValueListOffset + 4 + (i*4);
- en: int offset = hive.ReadInt32();
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: int offset = hive.ReadInt32();
- en: hive.BaseStream.Position = 4096 + offset + 4;
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: hive.BaseStream.Position = 4096 + offset + 4;
- en: this.ChildValues.➍Add(new ValueKey(hive));
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.ChildValues.➍Add(new ValueKey(hive));
- en: '}'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 14-9: The  ReadChildValues()  method for the  NodeKey  class'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-9：NodeKey类的ReadChildValues()方法
- en: Within the ReadChildValues() method, we first instantiate a new list ➊ to store
    the ValueKeys in and assign it to the ChildValues property. If the ValueListOffset
    doesn’t equal -1 ➋ (which is a magic value that means there are no child values),
    we jump to the ValueKey list ➌ and begin reading each value key in a for loop,
    adding ➍ each new key to the ChildValues property so we can access it later.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在ReadChildValues()方法中，我们首先实例化一个新的列表➊来存储ValueKeys，并将其分配给ChildValues属性。如果ValueListOffset不等于-1
    ➋（这是一个特殊值，表示没有子值），我们跳转到ValueKey列表➌并开始在for循环中读取每个值键，逐个将➍每个新键添加到ChildValues属性中，以便我们稍后访问。
- en: With this step, the NodeKey class is complete. The last class to implement is
    the ValueKey class.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一步，NodeKey类完成了。最后要实现的是ValueKey类。
- en: Making a Class to Store Value Keys
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类来存储值键
- en: The ValueKey class is much simpler and shorter than the NodeKey class. Most
    of the ValueKey class is just the constructor, as [Listing 14-10](#filepos929682)
    shows, though there are a handful of properties as well. This is all that is left
    to implement before we can start reading the offline registry hive.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ValueKey类比NodeKey类要简单得多，也更短。ValueKey类的大部分内容仅是构造函数，如[列表14-10](#filepos929682)所示，尽管还有一些属性。这就是在我们开始读取离线注册表hive之前，剩下要实现的全部内容。
- en: public class ValueKey
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class ValueKey
- en: '{'
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public ➊ValueKey(BinaryReader hive)
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public ➊ValueKey(BinaryReader hive)
- en: '{'
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: byte[] buf = hive.➋ReadBytes(2);
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] buf = hive.➋ReadBytes(2);
- en: ''
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (buf[0] != 0x76 || buf[1] != 0x6b) //vk
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (buf[0] != 0x76 || buf[1] != 0x6b) //vk
- en: throw new NotSupportedException("Bad vk header");
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: throw new NotSupportedException("坏的vk头");
- en: ''
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.NameLength = hive.➌ReadInt16();
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.NameLength = hive.➌ReadInt16();
- en: this.DataLength = hive.➍ReadInt32();
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.DataLength = hive.➍ReadInt32();
- en: ''
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: byte[] ➎databuf = hive.ReadBytes(4);
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] ➎databuf = hive.ReadBytes(4);
- en: ''
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.ValueType = hive.ReadInt32();
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.ValueType = hive.ReadInt32();
- en: hive.BaseStream.Position += 4; //skip metadata
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: hive.BaseStream.Position += 4; //跳过元数据
- en: ''
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: buf = hive.ReadBytes(this.NameLength);
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: buf = hive.ReadBytes(this.NameLength);
- en: 'this.Name = (this.NameLength == 0) ? "Default" :'
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'this.Name = (this.NameLength == 0) ? "Default" :'
- en: System.Text.Encoding.UTF8.GetString(buf);
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: System.Text.Encoding.UTF8.GetString(buf);
- en: ''
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (➏this.DataLength < 5)
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (➏this.DataLength < 5)
- en: ➐this.Data = databuf;
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➐this.Data = databuf;
- en: else
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else
- en: '{'
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: hive.BaseStream.Position = 4096 + BitConverter.➑ToInt32(databuf, 0) + 4;
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: hive.BaseStream.Position = 4096 + BitConverter.➑ToInt32(databuf, 0) + 4;
- en: this.Data = hive.ReadBytes(this.DataLength);
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Data = hive.ReadBytes(this.DataLength);
- en: '}'
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public short NameLength { get; set; }
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public short NameLength { get; set; }
- en: public int DataLength { get; set; }
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int DataLength { get; set; }
- en: public int DataOffset { get; set; }
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int DataOffset { get; set; }
- en: public int ValueType { get; set; }
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int ValueType { get; set; }
- en: public string Name { get; set; }
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Name { get; set; }
- en: public byte[] Data { get; set; }
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public byte[] Data { get; set; }
- en: public string String { get; set; }
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string String { get; set; }
- en: '}'
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 14-10: The  ValueKey  class'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 清单14-10：ValueKey类
- en: In the constructor ➊, we read ➋ the first two bytes and make sure that we are
    reading a value key by comparing the two bytes to 0x76 and 0x6b, as we did earlier.
    In this case, we are looking for vk in ASCII. We also read the lengths of the
    name ➌ and data ➍ and assign those values to their respective properties.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数➊中，我们读取了前两个字节，并通过将这两个字节与0x76和0x6b进行比较，确保我们读取的是值键，就像之前做的那样。在这种情况下，我们查找的是ASCII编码的vk。我们还读取了名称➌和数据➎的长度，并将这些值分配给它们各自的属性。
- en: Something to note is that the databuf variable ➎ can hold either a pointer to
    the value key data or the value key data itself. If the data length is five or
    more, the data is generally in a four-byte pointer. We use the DataLength property
    ➏ to check whether the ValueKey length is less than five. If so, we assign the
    data in the databuf variable directly to the Data property ➐ and finish up. Otherwise,
    we turn the databuf variable into a 32-bit integer ➑, which is an offset from
    the current position in the file stream to the actual data to read, and then jump
    to that position in the stream and read the data with ReadBytes(), assigning it
    to the Data property.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，databuf变量➎可以包含指向值键数据的指针，或者直接包含值键数据本身。如果数据长度为五个字节或更多，数据通常存储在一个四字节指针中。我们使用DataLength属性➏来检查ValueKey的长度是否小于五。如果是，我们将databuf变量中的数据直接分配给Data属性➐并结束。如果不是，我们将databuf变量转换为32位整数➑，这个整数表示文件流中当前位置到实际数据的偏移量，然后跳转到流中的那个位置并使用ReadBytes()方法读取数据，将其分配给Data属性。
- en: Testing the Library
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 测试库
- en: Once we’ve finished writing the classes, we can write a quick Main() method,
    shown in [Listing 14-11](#filepos931941), to test that we are successfully parsing
    the registry hive.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 完成编写类后，我们可以编写一个简短的Main()方法，如[清单14-11](#filepos931941)所示，来测试我们是否成功解析了注册表hive。
- en: public static void Main(string[] args)
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void Main(string[] args)
- en: '{'
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: RegistryHive hive = new ➊RegistryHive(args[0]);
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: RegistryHive hive = new ➊RegistryHive(args[0]);
- en: Console.WriteLine("The rootkey's name is " + hive.RootKey.Name);
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("根键的名称是 " + hive.RootKey.Name);
- en: '}'
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 14-11: The  Main()  method to print the root key name of a registry
    hive'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 清单14-11：打印注册表hive根键名称的Main()方法
- en: 'In the Main() method, we instantiate a new RegistryHive class ➊ by passing
    the first argument of the program as the file path to the offline registry hive
    on the filesystem. Then, we print the name of the registry hive root NodeKey,
    which is stored in the RegistryHive class RootKey property:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在Main()方法中，我们通过将程序的第一个参数作为离线注册表hive的文件路径来实例化一个新的RegistryHive类➊。然后，我们打印出存储在RegistryHive类RootKey属性中的注册表hive根节点名称：
- en: $ ./ch14_reading_offline_hives.exe /Users/bperry/system.hive
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ ./ch14_reading_offline_hives.exe /Users/bperry/system.hive
- en: The rootkey's name is CMI-CreateHive{2A7FB991-7BBE-4F9D-B91E-7CB51D4737F5}
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 根键的名称是CMI-CreateHive{2A7FB991-7BBE-4F9D-B91E-7CB51D4737F5}
- en: $
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $
- en: Once we have confirmed that we are successfully parsing the hive, we are ready
    to search the registry for the information we’re interested in.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确认成功解析了hive，就可以开始在注册表中搜索我们感兴趣的信息了。
- en: Dumping the Boot Key
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 转储启动密钥
- en: Usernames are nice, but password hashes are probably a lot more useful. Therefore,
    we’ll look at how to find these now. In order to access the password hashes in
    the registry, we must first retrieve the boot key from the SYSTEM hive. The password
    hashes in the Windows registry are encrypted with the boot key, which is unique
    to most Windows machines (unless they are images or virtual machine clones). Adding
    four more methods to the class with our Main() method will allow us to dump the
    boot key from a SYSTEM registry hive.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名很有用，但密码哈希值可能更有用。因此，我们现在来看看如何查找这些值。为了访问注册表中的密码哈希，我们必须首先从SYSTEM hive中检索启动密钥。Windows注册表中的密码哈希使用启动密钥进行加密，启动密钥对于大多数Windows机器来说是唯一的（除非它们是镜像或虚拟机克隆）。通过在类中添加四个方法，我们可以从SYSTEM注册表hive中转储启动密钥。
- en: The GetBootKey() Method
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: GetBootKey()方法
- en: The first method is the GetBootKey() method, which takes a registry hive and
    returns an array of bytes. The boot key is broken up across multiple node keys
    in the registry hive, which we must first read and then decode using a special
    algorithm that will give us the final boot key. The beginning of this method is
    shown in [Listing 14-12](#filepos935364).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法是 GetBootKey() 方法，它接收一个注册表蜂巢并返回一个字节数组。启动密钥分布在注册表蜂巢中的多个节点键上，我们必须先读取这些节点键，然后使用特殊的算法对它们进行解码，从而得到最终的启动密钥。该方法的开始部分展示在[列表14-12](#filepos935364)中。
- en: static byte[] GetBootKey(RegistryHive hive)
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: static byte[] GetBootKey(RegistryHive hive)
- en: '{'
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ValueKey controlSet = ➊GetValueKey(hive, "Select\\Default");
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ValueKey controlSet = ➊GetValueKey(hive, "Select\\Default");
- en: int cs = BitConverter.ToInt32(controlSet.Data, 0);
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: int cs = BitConverter.ToInt32(controlSet.Data, 0);
- en: ''
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: StringBuilder scrambledKey = new StringBuilder();
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: StringBuilder scrambledKey = new StringBuilder();
- en: foreach (string key in new string[] ➋{"JD", "Skew1", "GBG", "Data"})
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (string key in new string[] ➋{"JD", "Skew1", "GBG", "Data"})
- en: '{'
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: NodeKey nk = ➌GetNodeKey(hive, "ControlSet00" + cs +
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: NodeKey nk = ➌GetNodeKey(hive, "ControlSet00" + cs +
- en: '"\\Control\\Lsa\\" + key);'
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"\\Control\\Lsa\\" + key);'
- en: ''
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for (int i = 0; i < nk.ClassnameLength && i < 8; i++)
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: for (int i = 0; i < nk.ClassnameLength && i < 8; i++)
- en: scrambledKey.➍Append((char)nk.ClassnameData [i*2]);
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: scrambledKey.➍Append((char)nk.ClassnameData [i*2]);
- en: '}'
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 14-12: Beginning of the  GetBootKey()  method to read the scrambled
    boot key'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-12：开始实现 GetBootKey() 方法来读取加密的启动密钥
- en: The GetBootKey() method starts by grabbing the \Select\Default value key with
    the GetValueKey() method ➊ (which we’ll implement shortly). It holds the current
    control set being used by the registry. We need this so that we read the correct
    boot key registry values from the correct control set. Control sets are sets of
    operating system configurations kept in the registry. Copies are kept for backup
    purposes in case the registry is corrupted, so we want to pick the control set
    that is selected by default at boot, which is dictated by the \Select\Default
    registry value key.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: GetBootKey() 方法通过使用 GetValueKey() 方法 ➊ 获取 \Select\Default 值的键（我们稍后会实现该方法）。它持有当前由注册表使用的控制集。我们需要它，以便从正确的控制集中读取正确的启动密钥注册表值。控制集是在注册表中保存的操作系统配置集合。为了备份防止注册表损坏，会保留多个副本，因此我们要选择默认启动时选中的控制集，这是由
    \Select\Default 注册表值键决定的。
- en: Once we’ve found the correct default control set, we iterate over the four value
    keys—JD, Skew1, GBG, and Data—that contain the encoded boot key data ➋. As we
    iterate, we find each key with GetNodeKey() ➌ (which we’ll also implement shortly),
    iterate over the boot key data byte by byte, and append ➍ it to the total scrambled
    boot key.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了正确的默认控制集，我们就会遍历包含编码的启动密钥数据的四个值键——JD、Skew1、GBG 和 Data ➋。在遍历过程中，我们通过 GetNodeKey()
    ➌（我们也将很快实现该方法）找到每个键，逐字节遍历启动密钥数据，并将 ➍ 它追加到总的加密启动密钥中。
- en: Once we have the scrambled boot key, we need to descramble it, and we can use
    a straightforward algorithm. [Listing 14-13](#filepos937780) shows how we can
    turn our scrambled boot key into the key used to decrypt the password hashes.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到了加密的启动密钥，我们需要解密它，并且可以使用一个简单的算法。[列表14-13](#filepos937780)展示了我们如何将加密的启动密钥转换为用于解密密码哈希的密钥。
- en: byte[] skey = ➊StringToByteArray(scrambledKey.ToString());
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] skey = ➊StringToByteArray(scrambledKey.ToString());
- en: byte[] descramble = ➋new byte[] { 0x8, 0x5, 0x4, 0x2, 0xb, 0x9, 0xd, 0x3,
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] descramble = ➋new byte[] { 0x8, 0x5, 0x4, 0x2, 0xb, 0x9, 0xd, 0x3,
- en: 0x0, 0x6, 0x1, 0xc, 0xe, 0xa, 0xf, 0x7 };
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 0x0, 0x6, 0x1, 0xc, 0xe, 0xa, 0xf, 0x7 };
- en: ''
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: byte[] bootkey = new ➌byte[16];
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] bootkey = new ➌byte[16];
- en: ➍for (int i = 0; i < bootkey.Length; i++)
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➍for (int i = 0; i < bootkey.Length; i++)
- en: bootkey[i] = skey[➎descramble[i]];
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bootkey[i] = skey[➎descramble[i]];
- en: ''
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return ➏bootkey;
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return ➏bootkey;
- en: '}'
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 14-13: Finishing the  GetBootKey()  method to descramble the boot key'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-13：完成 GetBootKey() 方法来解密启动密钥
- en: After converting the scrambled key into a byte array for further processing
    with StringToByteArray() ➊, which we’ll implement soon, we create a new byte array
    ➋ to descramble our current value. We then create another new byte array ➌ to
    store the final product and begin iterating over the scrambled key in a for loop
    ➍, using the descramble byte array ➎ to find the correct values for the final
    bootkey byte array. The final key is then returned to the caller ➏.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在将加密密钥转换为字节数组以便进一步处理时，我们使用 StringToByteArray() ➊（我们稍后会实现此方法），然后创建一个新的字节数组 ➋
    来解密当前的值。接着，我们创建另一个新的字节数组 ➌ 来存储最终结果，并开始在一个 for 循环 ➍ 中遍历加密密钥，使用 descramble 字节数组
    ➎ 来为最终的 bootkey 字节数组找到正确的值。最后的密钥将返回给调用者 ➏。
- en: The GetValueKey() Method
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: GetValueKey() 方法
- en: The GetValueKey() method, shown in [Listing 14-14](#filepos939416), simply returns
    a value for a given path in the hive.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: GetValueKey() 方法，如 [Listing 14-14](#filepos939416) 所示，简单地返回注册表文件中给定路径的值。
- en: static ValueKey GetValueKey(➊RegistryHive hive, ➋string path)
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: static ValueKey GetValueKey(➊RegistryHive hive, ➋string path)
- en: '{'
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string keyname = path.➌Split('\\').➍Last();
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string keyname = path.➌Split('\\').➍Last();
- en: NodeKey node = ➎GetNodeKey(hive, path);
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: NodeKey node = ➎GetNodeKey(hive, path);
- en: return node.ChildValues.➏SingleOrDefault(v => v.Name == keyname);
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return node.ChildValues.➏SingleOrDefault(v => v.Name == keyname);
- en: '}'
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 14-14: The  GetValueKey()  method'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 14-14: GetValueKey() 方法'
- en: This simple method accepts a registry hive ➊ and the registry path ➋ to find
    in the hive. Using the backslash character to separate the nodes in the registry
    path, we split ➌ the path and take the last segment ➍ of the path as the value
    key to find. We then pass the registry hive and registry path to GetNodeKey()
    ➎ (implemented next), which will return the node that contains the key. Finally,
    we use the LINQ method SingleOrDefault() ➏ to return the value key from the node’s
    child values.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的方法接受一个注册表文件 ➊ 和注册表路径 ➋ 来查找该文件中的节点。我们使用反斜杠字符来分隔注册表路径中的节点，分割 ➌ 路径并将路径的最后一部分
    ➍ 作为要查找的值键。然后，我们将注册表文件和路径传递给 GetNodeKey() ➎（下文实现），该方法会返回包含该键的节点。最后，我们使用 LINQ 方法
    SingleOrDefault() ➏ 从节点的子值中返回值键。
- en: The GetNodeKey() Method
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: GetNodeKey() 方法
- en: The GetNodeKey() method is a bit more complicated than the GetValueKey() method.
    Shown in [Listing 14-15](#filepos941760), the GetNodeKey() method iterates through
    a hive until it finds a given node key path and returns the node key.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: GetNodeKey() 方法比 GetValueKey() 方法稍微复杂一些。如 [Listing 14-15](#filepos941760) 所示，GetNodeKey()
    方法会遍历一个注册表文件，直到找到给定的节点键路径并返回节点键。
- en: static NodeKey GetNodeKey(➊RegistryHive hive, ➋string path)
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: static NodeKey GetNodeKey(➊RegistryHive hive, ➋string path)
- en: '{'
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: NodeKey ➌node = null;
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: NodeKey ➌node = null;
- en: string[] paths = path.➍Split('\\');
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string[] paths = path.➍Split('\\');
- en: foreach (string ch in ➎paths)
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (string ch in ➎paths)
- en: '{'
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ''
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (node == null)
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (node == null)
- en: node = hive.RootKey;
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: node = hive.RootKey;
- en: ''
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➏foreach (NodeKey child in node.ChildNodes)
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➏foreach (NodeKey child in node.ChildNodes)
- en: '{'
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (child.Name == ch)
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (child.Name == ch)
- en: '{'
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: node = child;
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: node = child;
- en: break;
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: break;
- en: '}'
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'throw new Exception("No child found with name: " + ch);'
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: throw new Exception("未找到名称为 " + ch + " 的子项");
- en: '}'
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➐return node;
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➐return node;
- en: '}'
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 14-15: The  GetNodeKey()  method'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 14-15: GetNodeKey() 方法'
- en: The GetNodeKey() method accepts two arguments—the registry hive ➊ to search
    and the path of the node ➋ to return—separated by backslash characters. We start
    by declaring a null node ➌ for keeping track of our position while traversing
    the registry tree paths; then we split ➍ the path at each backslash character,
    returning an array of path segment strings. We then iterate over each path segment,
    traversing the registry tree until we find the node at the end of the path. We
    start traversing using a foreach loop that will progressively loop over each path
    segment in the paths array ➎. As we iterate over each segment, we use a foreach
    loop ➏ inside the for loop to find the next segment in the path until we have
    found the last node. Finally, we return ➐ the node we found.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: GetNodeKey() 方法接受两个参数——需要搜索的注册表文件 ➊ 和需要返回的节点路径 ➋，这些路径由反斜杠字符分隔。我们首先声明一个空的节点 ➌
    来跟踪我们遍历注册表树路径时的位置；然后，我们在每个反斜杠字符处分割 ➍ 路径，返回路径段字符串的数组。接下来，我们遍历每个路径段，逐步遍历注册表树，直到找到路径的最后节点。我们使用一个
    foreach 循环开始遍历，这个循环将会依次处理 paths 数组 ➎ 中的每个路径段。在遍历每个段时，我们会在 for 循环中使用另一个 foreach
    循环 ➏ 来查找路径中的下一个段，直到找到最后一个节点。最后，我们返回 ➐ 我们找到的节点。
- en: The StringToByteArray() Method
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: StringToByteArray() 方法
- en: Finally, we implement the StringToByteArray() method used in [Listing 14-13](#filepos937780).
    This very simple method is detailed in [Listing 14-16](#filepos943743).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了 StringToByteArray() 方法，它在 [Listing 14-13](#filepos937780) 中被使用。这个非常简单的方法在
    [Listing 14-16](#filepos943743) 中详细说明。
- en: static byte[] StringToByteArray(string s)
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: static byte[] StringToByteArray(string s)
- en: '{'
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: return ➊Enumerable.Range(0, s.Length)
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return ➊Enumerable.Range(0, s.Length)
- en: .➋Where(x => x % 2 == 0)
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: .➋Where(x => x % 2 == 0)
- en: .➌Select(x => Convert.ToByte(s.Substring(x, 2), 16))
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: .➌Select(x => Convert.ToByte(s.Substring(x, 2), 16))
- en: .ToArray();
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: .ToArray();
- en: '}'
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 14-16: The  StringToByteArray()  method used by  GetBootKey()'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 14-16: GetNodeKey() 方法使用的 StringToByteArray() 方法'
- en: The StringToByteArray() method uses LINQ to convert each two-character string
    into a single byte. For example, if the string "FAAF" were passed in, a byte array
    of { 0xFA, 0xAF } would be returned by the method. Using Enumerable.Range() ➊
    to iterate over each character in the string, we skip the odd-numbered characters
    with Where() ➋ and then use Select() ➌ to convert each pair of characters into
    the byte the pair represents.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: StringToByteArray() 方法使用 LINQ 将每两个字符的字符串转换为一个字节。例如，如果传入字符串 "FAAF"，该方法将返回字节数组
    { 0xFA, 0xAF }。使用 Enumerable.Range() ➊ 来遍历字符串中的每个字符，我们通过 Where() ➋ 跳过奇数位置的字符，然后使用
    Select() ➌ 将每对字符转换为它们所表示的字节。
- en: Getting the Boot Key
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 获取启动密钥
- en: We can finally try dumping the boot key from the system hive. By calling our
    new GetBootKey() method, we can rewrite the Main() method we used previously to
    print the root key name to print the boot key instead. [Listing 14-17](#filepos945565)
    shows this.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终可以尝试从系统蜂巢中转储启动密钥。通过调用我们新的 GetBootKey() 方法，我们可以重写之前用于打印根密钥名称的 Main() 方法，改为打印启动密钥。[清单
    14-17](#filepos945565) 展示了这一点。
- en: public static void Main(string[] args)
  id: totrans-381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void Main(string[] args)
- en: '{'
  id: totrans-382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: RegistryHive systemHive = new ➊RegistryHive(args[0]);
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: RegistryHive systemHive = new ➊RegistryHive(args[0]);
- en: byte[] bootKey = ➋GetBootKey(systemHive);
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] bootKey = ➋GetBootKey(systemHive);
- en: ''
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '➌Console.WriteLine("Boot key: " + BitConverter.ToString(bootKey));'
  id: totrans-386
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '➌Console.WriteLine("启动密钥: " + BitConverter.ToString(bootKey));'
- en: '}'
  id: totrans-387
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 14-17: The  Main()  method testing the  GetBootKey()  method'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 14-17：测试 GetBootKey() 方法的 Main() 方法
- en: This Main() method will open the registry hive ➊, which is passed as the only
    argument to the program. Then the new hive is passed to the GetBootKey() method
    ➋. With the new boot key saved, we print the boot key with Console.WriteLine()
    ➌.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Main() 方法将打开注册表蜂巢 ➊，它作为唯一的参数传递给程序。然后，将新的蜂巢传递给 GetBootKey() 方法 ➋。保存了新的启动密钥后，我们使用
    Console.WriteLine() 打印启动密钥 ➌。
- en: Then, we can run the test code to print the boot key, shown in [Listing 14-18](#filepos946699).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以运行测试代码来打印启动密钥，如[清单 14-18](#filepos946699)所示。
- en: $ ./ch14_reading_offline_hives.exe ~/system.hive
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ ./ch14_reading_offline_hives.exe ~/system.hive
- en: 'Boot key: F8-C7-0D-21-3E-9D-E8-98-01-45-63-01-E4-F1-B4-1E'
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 启动密钥：F8-C7-0D-21-3E-9D-E8-98-01-45-63-01-E4-F1-B4-1E
- en: $
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $
- en: 'Listing 14-18: Running the final  Main()  method'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 14-18：运行最终的 Main() 方法
- en: It worked! But how can we be sure this is the actual boot key?
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！但我们如何确认这就是实际的启动密钥呢？
- en: Verifying the Boot Key
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 验证启动密钥
- en: We can verify that our code is working correctly by comparing it to the result
    of bkhive, a popular tool used to dump the boot key of a system hive, just as
    we have done. Included in the repository of code for this book (linked from the
    book’s page at [https://www.nostarch.com/grayhatcsharp/](https://www.nostarch.com/grayhatcsharp/))
    is a copy of the source code for the bkhive tool. Compiling and running this tool
    on the same registry hive we have been testing on should verify our results, as
    [Listing 14-19](#filepos948543) shows.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将我们的代码与 bkhive 工具的结果进行比较，来验证代码是否正常工作，bkhive 是一个常用的工具，用于转储系统蜂巢的启动密钥，正如我们所做的那样。在本书的代码仓库中（可以从本书页面的[https://www.nostarch.com/grayhatcsharp/](https://www.nostarch.com/grayhatcsharp/)找到）包含了
    bkhive 工具的源代码。编译并运行该工具，使用我们一直在测试的同一个注册表蜂巢，应该能验证我们的结果，正如[清单 14-19](#filepos948543)所示。
- en: $ cd bkhive-1.1.1
  id: totrans-398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ cd bkhive-1.1.1
- en: $ make
  id: totrans-399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ make
- en: $ ./bkhive ~/system.hive /dev/null
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ ./bkhive ~/system.hive /dev/null
- en: bkhive 1.1.1 by Objectif Securite
  id: totrans-401
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bkhive 1.1.1 由 Objectif Securite 提供
- en: http://www.objectif-securite.ch
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: http://www.objectif-securite.ch
- en: 'original author: ncuomo@studenti.unina.it'
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原作者：ncuomo@studenti.unina.it
- en: ''
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Root Key : CMI-CreateHive{2A7FB991-7BBE-4F9D-B91E-7CB51D4737F5}'
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 根密钥：CMI-CreateHive{2A7FB991-7BBE-4F9D-B91E-7CB51D4737F5}
- en: 'Default ControlSet: 001'
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认 ControlSet：001
- en: 'Bootkey: ➊f8c70d213e9de89801456301e4f1b41e'
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 启动密钥：➊f8c70d213e9de89801456301e4f1b41e
- en: $
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $
- en: 'Listing 14-19: Verifying that the boot key returned by our code is what  bkhive  prints'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 14-19：验证我们的代码返回的启动密钥与 bkhive 打印的一致
- en: The bkhive tool verifies that our own boot key dumper works like a charm! Although
    bkhive prints the boot key ➊ in a slightly different form than we do (all lowercase
    with no hyphens), the data it prints is still the same (F8C70D21...) as ours.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: bkhive 工具验证了我们自己的启动密钥转储工具的完美运行！尽管 bkhive 打印的启动密钥 ➊ 格式略有不同（全部小写且没有连字符），但它打印的数据与我们的一致（F8C70D21...）。
- en: You might wonder why go through all the effort with the C# classes to dump the
    boot key when we could just use bkhive. The bkhive tool is highly specialized
    and will read a specific part of the registry hive, but the classes we implemented
    can be used to read any part of the registry hive, such as the password hashes
    (which are encrypted with the boot key!) and patch-level information. Our classes
    are much more flexible than the bkhive tool, and you’ll be able to use them as
    starting points if you want to expand your application.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会疑问，为什么要通过C#类来导出启动密钥，而不直接使用bkhive工具呢？bkhive工具是高度专用的，它只会读取注册表蜂巢的特定部分，但我们实现的类可以用来读取注册表蜂巢的任何部分，例如密码哈希值（这些哈希值是用启动密钥加密的！）和补丁级别信息。我们的类比bkhive工具更加灵活，如果你想扩展你的应用程序，它们还可以作为起点使用。
- en: Conclusion
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 结论
- en: The obvious next step for an offensive or incident response–focused registry
    library is to dump the actual usernames and password hashes. Getting the boot
    key is the most difficult part of this, but it’s also the only step that requires
    the SYSTEM registry hive. Dumping the usernames and password hashes requires the
    SAM registry hive instead.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 一个针对进攻或事件响应的注册表库的显而易见的下一步是导出实际的用户名和密码哈希值。获取启动密钥是这其中最困难的部分，但它也是唯一需要使用SYSTEM注册表蜂巢的步骤。导出用户名和密码哈希值则需要使用SAM注册表蜂巢。
- en: Reading registry hives (and other binary file formats in general) is an important
    C# skill to develop. Incident response and offensive security professionals often
    must be able to implement code that reads and parses binary data in a variety
    of formats, either over the wire or on disk. In this chapter, you first learned
    how to export the registry hives so that we could copy them to other machines
    and read them offline. We then implemented classes to read the registry hives
    using BinaryReader. With these classes built, we were able to read the offline
    hive and print the root key name. Then, we took it a step further and dumped the
    boot key, used to encrypt the password hashes stored in the Windows registry,
    from the system hive.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读注册表蜂巢（以及其他二进制文件格式）是一个重要的C#技能。事件响应和进攻安全专业人员通常必须能够实现读取和解析各种格式的二进制数据的代码，这些数据可能通过网络传输或存储在磁盘上。在本章中，你首先学习了如何导出注册表蜂巢，以便我们可以将它们复制到其他机器上并离线读取。然后，我们实现了使用BinaryReader读取注册表蜂巢的类。在这些类构建完成后，我们能够读取离线蜂巢并打印根密钥名称。接着，我们更进一步，导出了启动密钥，该密钥用于加密存储在Windows注册表中的密码哈希值，导出自系统蜂巢。
