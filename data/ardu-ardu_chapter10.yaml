- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">USING
    MULTIPLE I</samp><samp class="SANS_Dogma_OT_Bold_B-SUP_11">2</samp><samp class="SANS_Dogma_OT_Bold_B_11">C
    DEVICES WITH THE SAME ADDRESS</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">使用具有相同地址的多个
    I</samp><samp class="SANS_Dogma_OT_Bold_B-SUP_11">2</samp><samp class="SANS_Dogma_OT_Bold_B_11">C
    设备</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: In your Arduino journey, you’ve likely come across devices that interface via
    the I²C bus, a simple two-wire data bus for which the Arduino is considered the
    *primary* device, and each additional device or IC on the bus is a *secondary*
    device. Each secondary device has its own address that allows the Arduino to communicate
    with it. If two or more devices have the same bus address, however, you simply
    can’t use them together on the same bus.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 Arduino 旅程中，您可能遇到过通过 I²C 总线接口的设备，I²C 是一个简单的双线数据总线，在这个总线上 Arduino 被视为*主设备*，而总线上的每个附加设备或
    IC 则是*从设备*。每个从设备都有自己的地址，允许 Arduino 与其通信。然而，如果两个或更多设备具有相同的总线地址，您将无法将它们一起使用在同一总线上。
- en: 'This chapter shows you how to use two or more devices with the same bus address
    with the help of the TCA9548A I²C switch IC. You’ll learn to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示如何通过 TCA9548A I²C 开关 IC 使用两个或更多具有相同总线地址的设备。您将学习如何：
- en: Build an I²C address scanner to determine device bus addresses
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个 I²C 地址扫描仪，以确定设备的总线地址
- en: Use compact graphic organic light-emitting diode (OLED) displays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用紧凑型图形有机发光二极管（OLED）显示屏
- en: Use the BMP180 temperature and air pressure sensor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 BMP180 温度和气压传感器
- en: Combine the BMP180 and OLED devices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 BMP180 和 OLED 设备结合使用
- en: 'To prepare you to work with multiple I²C devices at once, I’ll first introduce
    a simple tool that reports the bus address of a device connected to the Arduino’s
    I²C bus: the I²C bus scanner.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您能同时使用多个 I²C 设备，我将首先介绍一个简单的工具，它可以报告连接到 Arduino I²C 总线的设备的总线地址：I²C 总线扫描仪。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*If you’re not familiar with the I* *²**C bus, you can review Chapter 19 of*
    Arduino Workshop*, 2nd edition.*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您不熟悉 I* *²**C 总线，可以查看* 《Arduino Workshop》第 19 章*，第二版。*'
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #30: Using an I²C Bus Scanner</samp>'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #30：使用 I²C 总线扫描仪</samp>'
- en: In this project, you’ll learn to use an I²C bus scanner. This tool helps you
    gather information on parts or devices whose documentation you can’t find, such
    as the part’s bus address. It’s also ideal for quick I²C bus testing once you’ve
    connected a device to the bus.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，您将学习如何使用 I²C 总线扫描仪。这个工具帮助您收集无法找到文档的零件或设备的信息，例如零件的总线地址。它对于在将设备连接到总线后进行快速的
    I²C 总线测试也非常理想。
- en: 'You’ll need the following parts:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要以下零件：
- en: An Arduino Uno or compatible board and USB cable
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块 Arduino Uno 或兼容板及 USB 数据线
- en: A solderless breadboard or mounting for the I²C device
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个无焊接面包板或 I²C 设备的安装架
- en: Various jumper wires
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种跳线
- en: The hardware connection will depend on the I²C device under test. As an example,
    I’ll use the BMP180 sensor for temperature, barometric pressure, and altitude,
    as shown in [Figure 10-1](chapter10.xhtml#fig10-1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件连接将取决于待测 I²C 设备。例如，我将使用 BMP180 传感器来测量温度、大气压力和海拔，如[图 10-1](chapter10.xhtml#fig10-1)所示。
- en: '![A BMP180 TEMPERATURE SENSOR CONNECTED TO AN ARDUINO UNO WITH WIRES AND A
    SOLDERLESS BREADBOARD](../images/fig10-1.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![一台 BMP180 温度传感器通过导线和无焊接面包板连接到 Arduino Uno](../images/fig10-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-1: The BMP180 sensor
    board</samp>'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-1：BMP180 传感器板</samp>
- en: You’ll also use the BMP180 later in the chapter and elsewhere in this book,
    but for this project, you can use any I²C device that’s 5 V tolerant. If your
    device isn’t a module, don’t forget to use pull-up resistors as you normally would.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将在本章及本书的其他部分使用 BMP180，但在本项目中，您可以使用任何兼容 5V 的 I²C 设备。如果您的设备不是模块，请不要忘记像平时一样使用上拉电阻。
- en: The sketch for this project is provided with the Arduino IDE. Open and upload
    the i2c_scanner sketch included with the Wire library examples, by selecting **File**
    ![](../images/arr.png) **Examples** ![](../images/arr.png) **Wire** ![](../images/arr.png)
    **i2c_scanner**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的草图已随 Arduino IDE 提供。通过选择 **文件** ![](../images/arr.png) **示例** ![](../images/arr.png)
    **Wire** ![](../images/arr.png) **i2c_scanner**，打开并上传随 Wire 库示例一起提供的 i2c_scanner
    草图。
- en: The sketch should interrogate the bus and report the address (or addresses)
    found in the Serial Monitor, as shown in [Figure 10-2](chapter10.xhtml#fig10-2).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 该示意图应该查询总线并在串口监视器中报告找到的地址（或地址），如[图 10-2](chapter10.xhtml#fig10-2)所示。
- en: '![A SCREEN CAPTURE OF THE I2C SCANNER SKETCH OUTPUT ON THE SERIAL MONITOR](../images/fig10-2.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![I2C 扫描器示意图在串口监视器上的输出截图](../images/fig10-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-2: The results of
    the I</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">C scanner sketch</samp>'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-2：I²C 扫描器示意图的结果</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">C
    扫描器示意图</samp>
- en: If you have two or more devices on the bus, the scanner will report both addresses,
    but you won’t know which device belongs to which address. For example, [Figure
    10-3](chapter10.xhtml#fig10-3) shows the bus addresses for the two devices connected
    to the bus. When you’re using two or more devices at once with the scanner, it’s
    okay to remove one or more devices even when the power is on, as the I²C bus is
    capable of “hot swapping.” That is, it’s designed to allow for devices to be connected
    or removed while operating.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果总线上有两个或更多设备，扫描器将报告两个地址，但你无法知道哪个设备属于哪个地址。例如，[图 10-3](chapter10.xhtml#fig10-3)显示了连接到总线的两个设备的总线地址。当你同时使用两个或更多设备时，即使电源开启，移除一个或多个设备也是可以的，因为
    I²C 总线支持“热插拔”。也就是说，它设计成允许设备在运行时连接或移除。
- en: '![A SCREEN CAPTURE OF THE I2C SCANNER SKETCH OUTPUT ON THE SERIAL MONITOR,
    SHOWING TWO DEVICES’ BUS ADDRESSES](../images/fig10-3.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![I2C 扫描器示意图在串口监视器上的输出截图，显示两个设备的总线地址](../images/fig10-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-3: The results of
    the I</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">C scanner sketch with two devices</samp>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-3：带有两个设备的 I²C 扫描器示意图的结果</samp>
- en: 'The sketch is quite simple. Let’s see how it works:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 该示意图非常简单。让我们来看它是如何工作的：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The sketch starts and finishes an I²C connection to every possible I²C address
    location (0 through 127) ❶. If a device exists on the address being tested, the
    sketch returns an error code of 0 ❷; if an error occurs, it returns a 4 ❸. If
    it doesn’t find any devices, it prints the message <samp class="SANS_TheSansMonoCd_W5Regular_11">No
    I2C devices found</samp> ❹.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 该示意图开始并完成对每个可能的 I²C 地址位置（0 到 127）进行 I²C 连接 ❶。如果在测试的地址上存在设备，示意图会返回错误代码 0 ❷；如果发生错误，它会返回
    4 ❸。如果没有找到任何设备，它会打印信息 <samp class="SANS_TheSansMonoCd_W5Regular_11">未找到 I2C 设备</samp>
    ❹。
- en: Now that you’ve seen how to connect an I²C device or two to the bus, let’s get
    started with the TCA9548A.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何将一个或多个 I²C 设备连接到总线，让我们开始使用 TCA9548A。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The TCA9548A Breakout Board</samp>
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">TCA9548A 扩展板</samp>
- en: The TCA9548A, shown on a breakout board in [Figure 10-4](chapter10.xhtml#fig10-4),
    allows you to connect the single I²C bus from your Arduino to one of eight separate
    buses that emanate from the TCA9548A, each of which operates in the same manner
    as the Arduino’s original I²C bus.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: TCA9548A，如[图 10-4](chapter10.xhtml#fig10-4)所示，允许你将 Arduino 的单个 I²C 总线连接到从 TCA9548A
    发出的八个独立总线中的任何一个，每个总线的工作方式与 Arduino 原始的 I²C 总线相同。
- en: '![A PHOTO OF A TCA9548A BREAKOUT BOARD](../images/fig10-4.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![TCA9548A 扩展板的照片](../images/fig10-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-4: The TCA9548A breakout
    board</samp>'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-4：TCA9548A 扩展板</samp>
- en: The TCA9548A also handles voltage translation, enabling you to use devices with
    the host Arduino that operate on different voltages—a convenient benefit, since
    an increasing number of devices operate only at 3.3 V or 1.8 V. Unfortunately,
    the TCA9548A is available in surface-mount format only, so it can’t be used with
    a solderless breadboard or prototyping board. Instead, you’ll need to use the
    module.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: TCA9548A 还负责电压转换，使你可以使用与主机 Arduino 工作在不同电压的设备——这是一个方便的优点，因为越来越多的设备只在 3.3 V 或
    1.8 V 下工作。不幸的是，TCA9548A 仅以表面贴装形式提供，因此无法与无焊接面包板或原型板一起使用。相反，你需要使用模块。
- en: The TCA9548A breakout board should include a pair of inline header pins that
    are not yet soldered to the board. Let’s solder them in now. To line up the pins
    properly, you can drop them into a solderless breadboard, as shown in [Figure
    10-5](chapter10.xhtml#fig10-5).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: TCA9548A 插件板应包括一对尚未焊接到板上的内联插针。现在我们来焊接它们。为了使插针正确对齐，你可以将它们插入无焊接面包板，如 [图 10-5](chapter10.xhtml#fig10-5)
    所示。
- en: '![A TCA9548A BREAKOUT BOARD WITH INLINE HEADER PINS IN A SOLDERLESS BREADBOARD](../images/fig10-5.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![带有内联插针并放置在无焊接面包板上的 TCA9548A 插件板](../images/fig10-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-5: The TCA9548A breakout
    board with inline header pins before soldering</samp>'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-5：未焊接内联插针的 TCA9548A 插件板</samp>
- en: After you solder in the pins, your board is ready for use in solderless breadboards
    and other hardware solutions, as shown in [Figure 10-6](chapter10.xhtml#fig10-6).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在你焊接好插针后，板子就可以在无焊接面包板和其他硬件解决方案中使用，如 [图 10-6](chapter10.xhtml#fig10-6) 所示。
- en: '![A TCA9548A BREAKOUT BOARD WITH INLINE HEADER PINS SOLDERED TO PCB PADS](../images/fig10-6.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![带有内联插针并已焊接到 PCB 焊盘的 TCA9548A 插件板](../images/fig10-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-6: The TCA9548A breakout
    board with inline header pins soldered to PCB pads</samp>'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-6：带有内联插针并已焊接到 PCB 焊盘的 TCA9548A
    插件板</samp>
- en: The pinouts on the board match the schematic diagram shown in [Figure 10-7](chapter10.xhtml#fig10-7),
    which also includes the connections you should make to your Arduino Uno or compatible
    board.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 板上的引脚排列与 [图 10-7](chapter10.xhtml#fig10-7) 中显示的原理图相匹配，原理图中还包括了你应该连接到 Arduino
    Uno 或兼容板的连接。
- en: '![THE TCA9548A BREAKOUT BOARD SCHEMATIC](../images/fig10-7.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![TCA9548A 插件板原理图](../images/fig10-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-7: The TCA9548A schematic</samp>'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-7：TCA9548A 原理图</samp>
- en: The TCA9548A requires pull-up resistors between the I²C bus and the positive
    power rail; these resistors are included on the breakout board.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: TCA9548A 需要在 I²C 总线与正电源之间连接上拉电阻；这些电阻已经包含在插件板上。
- en: The pins labeled A0 to A2 in the schematic are used to define the bus address
    for the TCA9548A. As you can see, the schematic sets them all to GND. If you run
    the port scanner, it will return an address of <samp class="SANS_TheSansMonoCd_W5Regular_11">0x70</samp>.
    If necessary, you can change the address by connecting the pins A0 to A2 to combinations
    of GND or 5V, as listed in [Table 10-1](chapter10.xhtml#tab10-1).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 原理图中标记为 A0 到 A2 的引脚用于定义 TCA9548A 的总线地址。正如你所看到的，原理图将它们都设置为 GND。如果你运行端口扫描器，它将返回地址
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x70</samp>。如果需要，你可以通过将 A0 到 A2
    引脚连接到 GND 或 5V 的组合，来更改地址，如 [表 10-1](chapter10.xhtml#tab10-1) 所列。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-1:</samp> <samp class="SANS_Futura_Std_Book_11">TCA9548A
    Address Configuration</samp>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 10-1：</samp> <samp class="SANS_Futura_Std_Book_11">TCA9548A
    地址配置</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">A0</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">A1</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">A2</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Address</samp>
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">A0</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">A1</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">A2</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">地址</samp>
    |'
- en: '| --- | --- | --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    | <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">0x70</samp>
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    | <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">0x70</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    | <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">0x71</samp>
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    | <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">0x71</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp>
    | <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">0x72</samp>
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp>
    | <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">0x72</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp>
    | <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">0x73</samp>
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp>
    | <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">0x73</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    | <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">0x74</samp>
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    | <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">0x74</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    | <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">0x75</samp>
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    | <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">0x75</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp>
    | <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">0x76</samp>
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp>
    | <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">0x76</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp>
    | <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">0x77</samp>
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp>
    | <samp class="SANS_Futura_Std_Book_11">5V</samp> | <samp class="SANS_Futura_Std_Book_11">0x77</samp>
    |'
- en: The eight I²C bus pairs in the schematic are labeled as SC0/SD0 through SC7/SD7
    (Clock and Data, respectively). The TCA9548A treats them each as a physically
    separate I²C bus.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 原理图中的八个 I²C 总线对标记为 SC0/SD0 到 SC7/SD7（分别是时钟和数据）。TCA9548A 将它们每个都视为物理上独立的 I²C 总线。
- en: 'Using the TCA9548A in your sketch requires just one additional step before
    using your I²C devices as normal: instructing the TCA9548A to use one of the eight
    buses it controls. To do this, you’ll send a byte of data to the TCA9548A’s I²C
    bus register, which will determine which of the eight buses you want to use. Each
    bit of the byte is used to turn the bus on or off, with the most significant bit
    (MSB) for bus 7, and the least significant bit (LSB) for bus 0\. For example,
    sending B00000001 (in binary) or 0 in decimal activates bus 0, while sending B00010000
    activates bus 5\. The TCA9548A then channels all data in and out of the bus to
    the Arduino on the selected bus; the TCA9548A itself is transparent to the Arduino.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的草图中使用 TCA9548A 只需要在正常使用 I²C 设备之前进行一个额外的步骤：指示 TCA9548A 使用它控制的八个总线之一。为此，您需要向
    TCA9548A 的 I²C 总线寄存器发送一个字节的数据，以确定您想使用的总线是哪一条。该字节的每一位用于打开或关闭总线，其中最高有效位（MSB）对应总线
    7，最低有效位（LSB）对应总线 0。例如，发送 B00000001（二进制）或 0（十进制）将激活总线 0，而发送 B00010000 将激活总线 5。然后，TCA9548A
    会将所有数据在所选总线上进出 Arduino；TCA9548A 对 Arduino 是透明的。
- en: 'Send the bus selection data only when you want to change buses. To simplify
    this process, you can use the following function to select the required bus:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在您想要更改总线时发送总线选择数据。为了简化此过程，您可以使用以下函数来选择所需的总线：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This function accepts a bus number and places a 1 in the TCA9548A’s bus register,
    matching our requirements. Insert this function right before you need to access
    a device on a particular I²C bus. For example, you’d use this function to access
    a device on bus 0:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个总线编号，并在 TCA9548A 的总线寄存器中放置一个 1，以匹配我们的需求。在需要访问特定 I²C 总线上的设备之前，插入此函数。例如，您可以使用此函数访问总线
    0 上的设备：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s the function to access a device on bus 7:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是访问总线 7 上设备的函数：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that you know how to select the required bus, I’ll introduce a neat display
    that you’ll use in your projects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何选择所需的总线，我将介绍一个有趣的显示器，您将在项目中使用它。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Graphic OLED Displays</samp>
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">图形 OLED 显示器</samp>
- en: You may be familiar with classic 16 × 2–character LCDs, as they’re quite popular
    and inexpensive. However, they are also somewhat bulky and old fashioned. The
    OLED display is a sleeker, more contemporary option that can display both text
    and graphics in various sizes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能熟悉经典的 16 × 2 字符 LCD 显示器，因为它们非常流行且价格便宜。然而，它们也有点笨重且过时。OLED 显示器是一种更时尚、更现代的选择，能够显示文本和图形，且尺寸可调。
- en: For the projects in this chapter, you’ll use a compact 128 × 32–pixel OLED display
    with a diagonal display size of 0.91 inches, such as PMD Way part 35998841A, shown
    in [Figure 10-8](chapter10.xhtml#fig10-8).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的项目将使用一款紧凑型 128 × 32 像素 OLED 显示器，显示尺寸对角线为 0.91 英寸，例如 PMD Way 的 35998841A，见
    [图 10-8](chapter10.xhtml#fig10-8)。
- en: '![A PHOTO OF A COMPACT OLED DISPLAY WITH INLINE HEADER PINS](../images/fig10-8.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![一张展示紧凑型 OLED 显示器与内联连接引脚的照片](../images/fig10-8.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-8: A compact OLED
    display with inline header pins</samp>'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-8：一款带内联连接引脚的紧凑型 OLED 显示器</samp>
- en: Inline headers for using with a solderless breadboard are included with the
    example board from PMD Way and are usually included with others, but check with
    the supplier. You can easily solder these to the breadboard by mounting the pins
    and the OLED in a breadboard, as shown in [Figure 10-9](chapter10.xhtml#fig10-9).
    Supporting the other end of the OLED with something to keep the display level,
    such as another group of inline header pins, as shown in [Figure 10-9](chapter10.xhtml#fig10-9),
    helps to ensure the pins are straight.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无焊面包板的内联连接头随 PMD Way 示例板一起提供，通常其他供应商的产品也包括这个，但请与供应商确认。你可以通过将引脚和 OLED 安装到面包板上，轻松地将它们焊接到面包板上，正如
    [图 10-9](chapter10.xhtml#fig10-9) 所示。用其他内联引脚支撑 OLED 的另一端，保持显示器水平，正如 [图 10-9](chapter10.xhtml#fig10-9)
    中所示，可以帮助确保引脚保持笔直。
- en: '![A PHOTO OF A COMPACT OLED DISPLAY SITTING IN INLINE HEADER PINS, READY FOR
    SOLDERING](../images/fig10-9.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![一张展示紧凑型 OLED 显示屏放置在内联连接引脚上的照片，准备焊接](../images/fig10-9.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-9: A compact OLED
    display sitting in inline header pins, ready for soldering</samp>'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-9：一款紧凑型 OLED 显示器放置在内联连接引脚上，准备焊接</samp>
- en: Once you’re ready to use the OLED, remove the plastic screen protector by pulling
    the blue tag, as shown in [Figure 10-10](chapter10.xhtml#fig10-10).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦准备好使用 OLED，按 [图 10-10](chapter10.xhtml#fig10-10) 所示，通过拉动蓝色标签移除塑料屏幕保护膜。
- en: '![AN IMAGE OF A COMPACT OLED DISPLAY WITH ITS INLINE HEADER PINS SOLDERED](../images/fig10-10.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![一张展示紧凑型 OLED 显示器与内联连接引脚已焊接的照片](../images/fig10-10.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-10: Ready-to-use
    OLED</samp>'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-10：即插即用 OLED</samp>
- en: To use the OLED, you’ll need to install an Arduino library. Search for **u8g2**
    in the Library Manager, and then click **Install** at the bottom of the library
    description.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 OLED，你需要安装 Arduino 库。在库管理器中搜索 **u8g2**，然后点击库描述底部的 **安装**。
- en: Once you’ve installed the library, test the OLED by running the I²C scanner
    sketch. It should return the address 0x3C, but if you get a different result,
    make a note of it for later. Next, connect the OLED to your Arduino Uno or compatible
    board using the connections listed in [Table 10-2](chapter10.xhtml#tab10-2).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 安装库之后，运行 I²C 扫描器草图来测试 OLED。它应该返回地址 0x3C，但如果你得到不同的结果，记下它以备后用。接下来，使用 [表 10-2](chapter10.xhtml#tab10-2)
    中列出的连接方式，将 OLED 连接到你的 Arduino Uno 或兼容板。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-2:</samp> <samp class="SANS_Futura_Std_Book_11">OLED
    to Arduino Connections</samp>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 10-2：</samp> <samp class="SANS_Futura_Std_Book_11">OLED
    与 Arduino 连接</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">OLED</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Arduino
    Uno</samp> |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">OLED</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Arduino
    Uno</samp> |'
- en: '| --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">SDA</samp> | <samp class="SANS_Futura_Std_Book_11">A4</samp>
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">SDA</samp> | <samp class="SANS_Futura_Std_Book_11">A4</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">SCL</samp> | <samp class="SANS_Futura_Std_Book_11">A5</samp>
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">SCL</samp> | <samp class="SANS_Futura_Std_Book_11">A5</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">VCC</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp>
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">VCC</samp> | <samp class="SANS_Futura_Std_Book_11">5V</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">GND</samp> | <samp class="SANS_Futura_Std_Book_11">GND</samp>
    |'
- en: Now enter and upload the [Listing 10-1](#LiT-10-1) sketch, which you can find
    in the downloadable code files on this book’s web page. After a few moments, the
    display should scroll between displaying “Count!” and an integer, as shown in
    [Figure 10-11](chapter10.xhtml#fig10-11). If your display had a different bus
    address to 0x3C, insert the new address into the “address” field in the line <samp
    class="SANS_TheSansMonoCd_W5Regular_11">u8g2_2.setI2CAddress(0x3D);</samp> in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, then uncomment
    the line and save and re-upload the sketch.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入并上传[清单 10-1](#LiT-10-1)的草图，你可以在本书网页上的可下载代码文件中找到它。片刻后，显示屏应当在显示“Count!”和一个整数之间滚动，如[图
    10-11](chapter10.xhtml#fig10-11)所示。如果你的显示屏的总线地址与 0x3C 不同，请将新地址插入到行 <samp class="SANS_TheSansMonoCd_W5Regular_11">u8g2_2.setI2CAddress(0x3D);</samp>
    的 “address” 字段中，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>
    中，然后取消注释此行，保存并重新上传草图。
- en: '![AN IMAGE OF OLED DISPLAYS, SHOWING TEXT (“COUNT!”)AND DIGITS (“30434”)](../images/fig10-11.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![OLED 显示屏的图片，显示文本（“COUNT!”）和数字（“30434”）](../images/fig10-11.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-11: Example displays
    from [Listing 10-1](#LiT-10-1)</samp>'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-11：来自 [清单 10-1](#LiT-10-1)
    的示例显示</samp>
- en: '[Listing 10-1](#LiT-10-1) shows how this works.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-1](#LiT-10-1) 展示了如何实现这一点。'
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-1: Using graphic
    OLED displays</samp>'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-1：使用图形 OLED 显示屏</samp>
- en: First, the sketch includes the u8g2 library and includes the OLED library ❶,
    after which it creates the instance of an OLED. The OLED’s specifications are
    defined in this file so the library knows which type of OLED you’re using.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，草图包含了 u8g2 库，并包含了 OLED 库 ❶，然后创建了 OLED 的实例。OLED 的规格在此文件中定义，以便库知道你正在使用哪种类型的
    OLED。
- en: The sketch then initializes the OLED ❷ and selects a font for the display ❸.
    The sketch uses a font that’s 32 pixels high, which works well for this OLED,
    but you can replace it with any of the fonts available at [*https://<wbr>github<wbr>.com<wbr>/olikraus<wbr>/u8g2<wbr>/wiki<wbr>/fntlistall*](https://github.com/olikraus/u8g2/wiki/fntlistall).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 草图首先初始化 OLED ❷ 并为显示屏选择字体 ❸。草图使用的字体为 32 像素高，这对于这个 OLED 显示屏效果很好，但你可以用[*https://<wbr>github<wbr>.com<wbr>/olikraus<wbr>/u8g2<wbr>/wiki<wbr>/fntlistall*](https://github.com/olikraus/u8g2/wiki/fntlistall)
    上提供的任何字体来替换它。
- en: The sketch controls the OLED by drawing up the intended display in its memory
    and then sending the contents of the memory to the display. After the OLED’s memory
    is cleared, the function ❹ accepts the lower x- and y-coordinates of the OLED
    display and then starts drawing the text itself. The sketch then prints the contents
    of the OLED memory to the display.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 草图通过在其内存中绘制预期的显示内容，然后将内存中的内容发送到显示屏，来控制 OLED。OLED 的内存清空后，函数 ❹ 接受 OLED 显示屏的较低
    x 和 y 坐标，然后开始绘制文本本身。草图随后将 OLED 内存中的内容打印到显示屏上。
- en: The sketch clears the memory again after a short delay and displays a number
    by first setting the cursor position and then printing the number to the memory,
    followed by another <samp class="SANS_TheSansMonoCd_W5Regular_11">sendBuffer()</samp>
    function to display the memory.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 草图在短暂的延迟后再次清空内存，并通过首先设置光标位置，再将数字打印到内存中，然后通过另一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">sendBuffer()</samp>
    函数来显示内存中的内容。
- en: Now that you’ve mastered the OLED display, I’ll introduce a sensor that you’ll
    use along with an OLED in your final project.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了 OLED 显示屏，我将介绍一个你将在最终项目中与 OLED 一起使用的传感器。
- en: <samp class="SANS_Futura_Std_Bold_B_11">BMP180 Sensors</samp>
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">BMP180 传感器</samp>
- en: 'The BMP180 sensor is an inexpensive, easy-to-use I²C device that measures ambient
    temperature and air pressure. This chapter’s final project uses a compact BMP180
    module with pull-up resistors like the one used in Project #30, such as PMD Way
    part 18000001, shown in [Figure 10-12](chapter10.xhtml#fig10-12).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: BMP180 传感器是一种廉价、易于使用的 I²C 设备，用于测量环境温度和气压。本章的最终项目使用了一个紧凑型的 BMP180 模块，带有上拉电阻，类似于第30个项目中使用的那种，例如
    PMD Way 部件 18000001，如[图 10-12](chapter10.xhtml#fig10-12)所示。
- en: '![A PHOTO OF THE BMP180 TEMPERATURE AND HUMIDITY SENSOR PLACED IN A SOLDERLESS
    BREADBOARD](../images/fig10-12.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![放置在无焊面包板上的 BMP180 温湿度传感器照片](../images/fig10-12.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-12: The BMP180 sensor
    module</samp>'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-12：BMP180 传感器模块</samp>
- en: As with the OLED display, begin by soldering the BMP180’s header pins to the
    board. Next, find the **Adafruit BMP180** library in the Arduino Library Manager
    and install it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与 OLED 显示屏一样，首先需要将 BMP180 的引脚焊接到电路板上。接着，在 Arduino 库管理器中找到**Adafruit BMP180**库并安装它。
- en: During the process of installing the BMP180 library, you may be asked to install
    some missing dependencies. Click **Install All** if prompted to do so.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 BMP180 库的过程中，可能会提示你安装一些缺失的依赖项。如果出现提示，请点击**安装全部**。
- en: Now enter and upload the [Listing 10-2](#LiT-10-2) sketch. Once the upload is
    complete, open the Serial Monitor in the IDE, where you’ll find the current temperature
    in degrees Celsius, along with the air pressure in hectopascals. In some regions,
    the unit of air pressure is the millibar. One hectopascal equals one millibar.
    [Figure 10-13](chapter10.xhtml#fig10-13) shows an example of this output.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入并上传[清单 10-2](#LiT-10-2)的草图。上传完成后，打开 IDE 中的串口监视器，你将看到当前的温度（单位为摄氏度）和气压（单位为百帕）。在一些地区，气压单位是毫巴。一百帕等于一毫巴。[图
    10-13](chapter10.xhtml#fig10-13)显示了这个输出的示例。
- en: '![A SCREENSHOT OF AN EXAMPLE TEMPERATURE AND PRESSURE READINGS OUTPUT IN SERIAL
    MONITOR](../images/fig10-13.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![串口监视器中温度和气压读取输出的屏幕截图](../images/fig10-13.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-13: Example output
    from [Listing 10-2](#LiT-10-2)</samp>'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-13：[清单 10-2](#LiT-10-2)
    的示例输出</samp>
- en: '[Listing 10-2](#LiT-10-2) shows how this works.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-2](#LiT-10-2)展示了这一过程是如何工作的。'
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-2: Using BMP180
    temperature and air pressure sensors</samp>'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-2：使用 BMP180 温度和气压传感器</samp>
- en: To set up the BMP180, the sketch first includes the requisite library and creates
    an instance of the sensor ❶. Two variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">temperature</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">pressure</samp>, store the sensor
    data. This is followed by initialization of the sensor ❷.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 BMP180，草图首先包含所需的库，并创建一个传感器实例 ❶。两个变量，<samp class="SANS_TheSansMonoCd_W5Regular_11">temperature</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">pressure</samp> 存储传感器数据。接下来是初始化传感器
    ❷。
- en: The sketch can then retrieve the data from the sensor using the <samp class="SANS_TheSansMonoCd_W5Regular_11">read
    Temperature()</samp> ❸ and <samp class="SANS_TheSansMonoCd_W5Regular_11">readPressure()</samp>
    ❹ functions. The temperature and air pressure readings (with the latter divided
    by 100 to convert it to hectopascals) are then sent to the Serial Monitor.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，草图可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">read Temperature()</samp>
    ❸和<samp class="SANS_TheSansMonoCd_W5Regular_11">readPressure()</samp> ❹函数从传感器获取数据。温度和气压读数（后者除以
    100 转换为百帕）将被发送到串口监视器。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #31: Creating a Temperature
    and Air Pressure Display</samp>'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #31：创建一个温度和气压显示</samp>'
- en: 'This project combines all the techniques you’ve learned in this chapter so
    far, using multiple I²C buses to display the BMP180’s temperature and air pressure
    readings with an OLED. You’ll need the following parts:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目结合了本章到目前为止学到的所有技巧，通过使用多个 I²C 总线将 BMP180 的温度和气压读数与 OLED 显示器进行显示。你将需要以下组件：
- en: An Arduino Uno or compatible board and USB cable
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块 Arduino Uno 或兼容板及 USB 电缆
- en: A 128 × 32–pixel, 0.91-inch OLED display
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 128 × 32 像素，0.91 英寸的 OLED 显示屏
- en: A BMP180 temperature and air pressure sensor board
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块 BMP180 温度和气压传感器板
- en: A TCA9548A breakout board
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 TCA9548A 扩展板
- en: A solderless breadboard
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块无焊面包板
- en: Various jumper wires
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种跳线
- en: Assemble the circuit as shown in [Figure 10-14](chapter10.xhtml#fig10-14).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图 10-14](chapter10.xhtml#fig10-14)所示组装电路。
- en: '![THE SCHEMATIC FOR PROJECT 31](../images/fig10-14.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![项目 31 的电路图](../images/fig10-14.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-14: The schematic
    for Project #31</samp>'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-14：项目 #31 的电路图</samp>'
- en: 'Next, enter and upload the Project #31 sketch. The temperature and air pressure
    should alternately display on the OLED, as shown in [Figure 10-15](chapter10.xhtml#fig10-15).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，输入并上传项目 #31 的草图。温度和气压应交替显示在 OLED 上，如[图 10-15](chapter10.xhtml#fig10-15)所示。'
- en: '![EXAMPLES OF THE OLED DISPLAYING TEMPERATURE (“25 C”) AND HUMIDITY (“999 H”)](../images/fig10-15.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![OLED 显示温度（“25°C”）和湿度（“999 H”）的示例](../images/fig10-15.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-15: Example output
    from Project #31</samp>'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-15：项目 #31 的示例输出</samp>'
- en: 'Let’s see how this works:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个是如何工作的：
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The sketch first includes the required libraries ❶ and configures the OLED type
    to use, temperature sensor, and required variables, as covered previously. It
    then defines a custom function to select the I²C bus from the TCA9548A ❷. It starts
    the I²C and OLED functions ❸, selects the OLED font ❹, and starts the temperature
    sensor ❺.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 程序首先引入所需的库 ❶，并配置要使用的 OLED 类型、温度传感器和所需的变量，正如之前所讲。然后它定义了一个自定义函数，用于从 TCA9548A 选择
    I²C 总线 ❷。接着，它启动 I²C 和 OLED 功能 ❸，选择 OLED 字体 ❹，并启动温度传感器 ❺。
- en: The sketch then switches the TCA9548A to the first of its I²C buses to retrieve
    data from the BMP180 ❻ and then to the second I²C bus ❼ so that the temperature
    and pressure data can be displayed on the OLED ❽ ❾.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 程序接着将 TCA9548A 切换到其第一个 I²C 总线，以获取来自 BMP180 的数据 ❻，然后切换到第二个 I²C 总线 ❼，以便将温度和压力数据显示在
    OLED 屏幕上 ❽ ❾。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">继续前进</samp>
- en: In this chapter, you learned to harness multiple devices on an I²C bus, alongside
    adding a new sensor and display to your tool kit. You might use these skills to
    make a large, multiple-time-zone clock with many OLEDs and a real-time clock IC,
    or you could use many temperature sensors in one area to determine the variations
    of temperature inside a refrigerator. No matter the project, you’re no longer
    limited by inexpensive devices with a single I²C bus address.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，你学会了如何在 I²C 总线上控制多个设备，同时将新的传感器和显示器加入你的工具包。你可以运用这些技能制作一个大型的多时区时钟，使用多个 OLED
    屏幕和实时时钟芯片，或者你也可以在一个区域使用多个温度传感器来检测冰箱内部温度的变化。无论是什么项目，你再也不受限于只有一个 I²C 总线地址的廉价设备。
- en: In the next chapter, you’ll use an Arduino Leonardo or compatible board to emulate
    a USB mouse and keyboard, which opens up many interesting and useful possibilities.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将使用 Arduino Leonardo 或兼容板来模拟 USB 鼠标和键盘，这为许多有趣且实用的应用打开了可能性。
