- en: Chapter 53. POSIX Semaphores
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第53章。POSIX 信号量
- en: This chapter describes POSIX semaphores, which allow processes and threads to
    synchronize access to shared resources. In [Chapter 47](ch47.html "Chapter 47. System
    V Semaphores"), we described System V semaphores, and we’ll assume that the reader
    is familiar with the general semaphore concepts and rationale for using semaphores
    that were presented at the start of that chapter. During the course of this chapter,
    we’ll make comparisons between POSIX semaphores and System V semaphores to clarify
    the ways in which these two semaphore APIs are the same and the ways in which
    they differ.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了 POSIX 信号量，它允许进程和线程同步访问共享资源。在[第47章](ch47.html "第47章。System V 信号量")中，我们描述了
    System V 信号量，并假设读者熟悉本章开始时所介绍的一般信号量概念和使用信号量的理由。在本章过程中，我们将比较 POSIX 信号量和 System V
    信号量，以澄清这两种信号量 API 在相同之处和不同之处。
- en: Overview
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: 'SUSv3 specifies two types of POSIX semaphores:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 指定了两种类型的 POSIX 信号量：
- en: '*Named semaphores*: This type of semaphore has a name. By calling *sem_open()*
    with the same name, unrelated processes can access the same semaphore.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*命名信号量*：这种信号量有一个名称。通过使用相同名称调用 *sem_open()*，不同的进程可以访问同一个信号量。'
- en: '*Unnamed semaphores*: This type of semaphore doesn’t have a name; instead,
    it resides at an agreed-upon location in memory. Unnamed semaphores can be shared
    between processes or between a group of threads. When shared between processes,
    the semaphore must reside in a region of (System V, POSIX, or *mmap()*) shared
    memory. When shared between threads, the semaphore may reside in an area of memory
    shared by the threads (e.g., on the heap or in a global variable).'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无名信号量*：这种信号量没有名称，而是位于内存中的一个约定位置。无名信号量可以在进程之间或线程组之间共享。当进程之间共享时，信号量必须位于（System
    V、POSIX 或 *mmap()*）共享内存区域。当线程之间共享时，信号量可以位于线程共享的内存区域（例如堆或全局变量中）。'
- en: POSIX semaphores operate in a manner similar to System V semaphores; that is,
    a POSIX semaphore is an integer whose value is not permitted to fall below 0\.
    If a process attempts to decrease the value of a semaphore below 0, then, depending
    on the function used, the call either blocks or fails with an error indicating
    that the operation was not currently possible.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 信号量的操作方式类似于 System V 信号量；也就是说，POSIX 信号量是一个整数，其值不能低于 0。如果进程尝试将信号量的值减少到
    0 以下，则根据使用的函数，调用要么阻塞，要么因操作当前无法完成而失败并返回错误。
- en: Some systems don’t provide a full implementation of POSIX semaphores. A typical
    restriction is that only unnamed thread-shared semaphores are supported. That
    was the situation on Linux 2.4; with Linux 2.6 and a *glibc* that provides NPTL,
    a full implementation of POSIX semaphores is available.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一些系统未提供完整的 POSIX 信号量实现。一个典型的限制是，只支持无名线程共享信号量。Linux 2.4 就是这种情况；而在 Linux 2.6 及提供
    NPTL 的 *glibc* 中，提供了完整的 POSIX 信号量实现。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux 2.6 with NPTL, semaphore operations (increment and decrement) are implemented
    using the *futex(2)* system call.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在带有 NPTL 的 Linux 2.6 上，信号量操作（增减）是通过 *futex(2)* 系统调用实现的。
- en: Named Semaphores
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名信号量
- en: 'To work with a named semaphore, we employ the following functions:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要与命名信号量一起使用，我们使用以下函数：
- en: The *sem_open()* function opens or creates a semaphore, initializes the semaphore
    if it is created by the call, and returns a handle for use in later calls.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*sem_open()* 函数打开或创建一个信号量，如果是通过该调用创建的信号量，则会初始化它，并返回一个句柄以供后续调用使用。'
- en: The *sem_post(sem)* and *sem_wait(sem)* functions respectively increment and
    decrement a semaphore’s value.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*sem_post(sem)* 和 *sem_wait(sem)* 函数分别增加和减少信号量的值。'
- en: The *sem_getvalue()* function retrieves a semaphore’s current value.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*sem_getvalue()* 函数检索信号量的当前值。'
- en: The *sem_close()* function removes the calling process’s association with a
    semaphore that it previously opened.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*sem_close()* 函数移除调用进程与先前打开的信号量的关联。'
- en: The *sem_unlink()* function removes a semaphore name and marks the semaphore
    for deletion when all processes have closed it.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*sem_unlink()* 函数移除信号量的名称，并在所有进程关闭该信号量后将其标记为删除。'
- en: 'SUSv3 doesn’t specify how named semaphores are to be implemented. Some UNIX
    implementations create them as files in a special location in the standard file
    system. On Linux, they are created as small POSIX shared memory objects with names
    of the form `sem.`*name*, in a dedicated *tmpfs* file system ([A Virtual Memory
    File System: *tmpfs*](ch14.html#a_virtual_memory_file_system_colon_tmpfs "A Virtual
    Memory File System: tmpfs")) mounted under the directory `/dev/shm`. This file
    system has kernel persistence--the semaphore objects that it contains will persist,
    even if no process currently has them open, but they will be lost if the system
    is shut down.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3并没有指定命名信号量的实现方式。某些UNIX实现将它们作为文件创建在标准文件系统的特定位置。在Linux中，它们作为小型POSIX共享内存对象创建，名称形式为`sem.`*name*，并存放在专用的*tmpfs*文件系统中（[虚拟内存文件系统：*tmpfs*](ch14.html#a_virtual_memory_file_system_colon_tmpfs
    "虚拟内存文件系统：tmpfs")），挂载在`/dev/shm`目录下。该文件系统具有内核持久性——其中包含的信号量对象会持续存在，即使没有任何进程打开它们，但如果系统关闭，这些对象会丢失。
- en: Named semaphores are supported on Linux since kernel 2.6.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 自Linux内核2.6起，支持命名信号量。
- en: Opening a Named Semaphore
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打开命名信号量
- en: The *sem_open()* function creates and opens a new named semaphore or opens an
    existing semaphore.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*sem_open()*函数用于创建并打开一个新的命名信号量，或者打开一个已有的信号量。'
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to semaphore on success, or `SEM_FAILED` on error
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回指向信号量的指针，出错时返回`SEM_FAILED`
- en: The *name* argument identifies the semaphore. It is specified according to the
    rules given in Section 51.1.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*name*参数标识信号量。它的指定规则见第51.1节。'
- en: The *oflag* argument is a bit mask that determines whether we are opening an
    existing semaphore or creating and opening a new semaphore. If *oflag* is 0, we
    are accessing an existing semaphore. If `O_CREAT` is specified in *oflag*, then
    a new semaphore is created if one with the given *name* doesn’t already exist.
    If *oflag* specifies both `O_CREAT` and `O_EXCL`, and a semaphore with the given
    *name* already exists, then *sem_open()* fails.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*oflag*参数是一个位掩码，用于确定我们是打开一个已有的信号量，还是创建并打开一个新的信号量。如果*oflag*为0，则我们正在访问一个已有的信号量。如果在*oflag*中指定了`O_CREAT`，则如果给定*name*的信号量不存在，就会创建一个新的信号量。如果*oflag*同时指定了`O_CREAT`和`O_EXCL`，且给定*name*的信号量已存在，则*sem_open()*会失败。'
- en: 'If *sem_open()* is being used to open an existing semaphore, the call requires
    only two arguments. However, if `O_CREAT` is specified in *flags*, then two further
    arguments are required: *mode* and *value*. (If the semaphore specified by *name*
    already exists, then these two arguments are ignored.) These arguments are as
    follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用*sem_open()*来打开一个已有的信号量，调用只需要两个参数。然而，如果*flags*中指定了`O_CREAT`，则需要两个额外的参数：*mode*和*value*。（如果由*name*指定的信号量已经存在，则这两个参数会被忽略。）这些参数如下：
- en: 'The *mode* argument is a bit mask that specifies the permissions to be placed
    on the new semaphore. The bit values are the same as for files ([Table 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits"), in [Permissions on Regular
    Files](ch15.html#permissions_on_regular_files "Permissions on Regular Files")),
    and, as with *open()*, the value in *mode* is masked against the process umask
    ([The Process File Mode Creation Mask: *umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "The Process File Mode Creation Mask: umask()")). SUSv3 doesn’t specify any access
    mode flags (`O_RDONLY`, `O_WRONLY`, and `O_RDWR`) for *oflag*. Many implementations,
    including Linux, assume an access mode of `O_RDWR` when opening a semaphore, since
    most applications using semaphores must employ both *sem_post()* and *sem_wait()*,
    which involve reading and modifying a semaphore’s value. This means that we should
    ensure that both read and write permissions are granted to each category of user—owner,
    group, and other—that needs to access the semaphore.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mode*参数是一个位掩码，用于指定新信号量的权限。位值与文件相同（[表15-4](ch15.html#constants_for_file_permission_bits
    "表15-4. 文件权限位常量")，[常规文件的权限](ch15.html#permissions_on_regular_files "常规文件的权限")），并且与*open()*一样，*mode*中的值会与进程的umask进行掩码处理（[进程文件模式创建掩码：*umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "进程文件模式创建掩码：umask()")）。SUSv3并未为*oflag*指定任何访问模式标志（`O_RDONLY`、`O_WRONLY`和`O_RDWR`）。许多实现，包括Linux，在打开信号量时默认使用`O_RDWR`访问模式，因为大多数使用信号量的应用程序必须同时使用*sem_post()*和*sem_wait()*，这涉及读取和修改信号量的值。这意味着我们应该确保每个需要访问信号量的用户类别——所有者、组和其他——都被授予读写权限。'
- en: The *value* argument is an unsigned integer that specifies the initial value
    to be assigned to the new semaphore. The creation and initialization of the semaphore
    are performed atomically. This avoids the complexities required for the initialization
    of System V semaphores ([Semaphore Initialization](ch47.html#semaphore_initialization
    "Semaphore Initialization")).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*value*参数是一个无符号整数，指定分配给新信号量的初始值。信号量的创建和初始化是原子的。这避免了初始化System V信号量时所需的复杂性（[信号量初始化](ch47.html#semaphore_initialization
    "信号量初始化")）。'
- en: Regardless of whether we are creating a new semaphore or opening an existing
    semaphore, *sem_open()* returns a pointer to a *sem_t* value, and we employ this
    pointer in subsequent calls to functions that operate on the semaphore. On error,
    *sem_open()* returns the value `SEM_FAILED`. (On most implementations, `SEM_FAILED`
    is defined as either *((sem_t *) 0)* or *((sem_t *) -1)*; Linux defines it as
    the former.)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是创建新信号量还是打开现有信号量，*sem_open()*都会返回指向*sem_t*值的指针，我们在后续对信号量的操作中使用此指针。如果出错，*sem_open()*返回`SEM_FAILED`值。（在大多数实现中，`SEM_FAILED`被定义为*((sem_t
    *) 0)*或*((sem_t *) -1)*；Linux定义为前者。）
- en: 'SUSv3 states that the results are undefined if we attempt to perform operations
    (*sem_post()*, *sem_wait()*, and so on) on a *copy* of the *sem_t* variable pointed
    to by the return value of *sem_open()*. In other words, the following use of *sem2*
    is not permissible:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3规定，如果我们尝试对由*sem_open()*返回值指向的*sem_t*变量的*副本*执行操作（*sem_post()*, *sem_wait()*等），结果是未定义的。换句话说，以下对*sem2*的使用是不允许的：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When a child is created via *fork()*, it inherits references to all of the named
    semaphores that are open in its parent. After the *fork()*, the parent and child
    can use these semaphores to synchronize their actions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过*fork()*创建子进程时，子进程会继承父进程中打开的所有命名信号量的引用。在*fork()*之后，父进程和子进程可以使用这些信号量来同步它们的操作。
- en: Example program
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: The program in [Example 53-1](ch53.html#using_sem_underscore_open_open_parenthes
    "Example 53-1. Using sem_open() to open or create a POSIX named semaphore") provides
    a simple command-line interface to the *sem_open()* function. The command format
    for this program is shown in the *usageError()* function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 53-1](ch53.html#using_sem_underscore_open_open_parenthes "示例 53-1. 使用 sem_open()
    打开或创建 POSIX 命名信号量")中的程序提供了一个简单的命令行界面来调用*sem_open()*函数。该程序的命令格式如*usageError()*函数中所示。'
- en: The following shell session log demonstrates the use of this program. We first
    use the *umask* command to deny all permissions to users in the class other. We
    then exclusively create a semaphore and examine the contents of the Linux-specific
    virtual directory that contains named semaphores.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例的Shell会话日志，演示了该程序的使用。我们首先使用*umask*命令拒绝其他用户类的所有权限。然后，我们独占创建一个信号量并检查包含命名信号量的Linux特定虚拟目录的内容。
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output of the *ls* command shows that the process umask overrode the specified
    permissions of read plus write for the user class other.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*ls*命令的输出显示，进程的umask覆盖了用户类“其他”的读取和写入权限。'
- en: If we try once more to exclusively create a semaphore with the same name, the
    operation fails, because the name already exists.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再试一次以相同的名称独占创建信号量，操作会失败，因为该名称已经存在。
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Example 53-1. Using *sem_open()* to open or create a POSIX named semaphore
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 53-1. 使用*sem_open()*打开或创建POSIX命名信号量
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Closing a Semaphore
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭信号量
- en: When a process opens a named semaphore, the system records the association between
    the process and the semaphore. The *sem_close()* function terminates this association
    (i.e., closes the semaphore), releases any resources that the system has associated
    with the semaphore for this process, and decreases the count of processes referencing
    the semaphore.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程打开一个命名信号量时，系统会记录进程与信号量之间的关联。*sem_close()*函数终止此关联（即关闭信号量），释放系统为该进程与信号量关联的任何资源，并减少引用该信号量的进程数量。
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，错误时返回-1
- en: Open named semaphores are also automatically closed on process termination or
    if the process performs an *exec()*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 打开的命名信号量在进程终止时或进程执行*exec()*时会自动关闭。
- en: Closing a semaphore does not delete it. For that purpose, we need to use *sem_unlink()*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭信号量并不会删除它。为此，我们需要使用*sem_unlink()*。
- en: Removing a Named Semaphore
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除命名信号量
- en: The *sem_unlink()* function removes the semaphore identified by *name* and marks
    the semaphore to be destroyed once all processes cease using it (this may mean
    immediately, if all processes that had the semaphore open have already closed
    it).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*sem_unlink()* 函数移除由 *name* 标识的信号量，并在所有进程停止使用它后标记该信号量为销毁状态（如果所有打开该信号量的进程已经关闭，它可能立即销毁）。'
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，错误时返回 -1
- en: '[Example 53-2](ch53.html#using_sem_underscore_unlink_open_parenth "Example 53-2. Using
    sem_unlink() to unlink a POSIX named semaphore") demonstrates the use of *sem_unlink()*.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 53-2](ch53.html#using_sem_underscore_unlink_open_parenth "示例 53-2. 使用 sem_unlink()
    来解除绑定 POSIX 命名信号量") 演示了如何使用 *sem_unlink()*。'
- en: Example 53-2. Using *sem_unlink()* to unlink a POSIX named semaphore
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 53-2. 使用 *sem_unlink()* 来解除绑定 POSIX 命名信号量
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Semaphore Operations
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号量操作
- en: 'As with a System V semaphore, a POSIX semaphore is an integer that the system
    never allows to go below 0\. However, POSIX semaphore operations differ from their
    System V counterparts in the following respects:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与 System V 信号量一样，POSIX 信号量是一个整数，系统永远不会允许它小于 0。然而，POSIX 信号量操作与 System V 信号量操作在以下方面有所不同：
- en: The functions for changing a semaphore’s value—*sem_post()* and *sem_wait()*—operate
    on just one semaphore at a time. By contrast, the System V *semop()* system call
    can operate on multiple semaphores in a set.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于改变信号量值的函数—*sem_post()* 和 *sem_wait()*—每次只操作一个信号量。相比之下，System V 的 *semop()*
    系统调用可以在一个信号量集合中操作多个信号量。
- en: The *sem_post()* and *sem_wait()* functions increment and decrement a semaphore’s
    value by exactly one. By contrast, *semop()* can add and subtract arbitrary values.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*sem_post()* 和 *sem_wait()* 函数将信号量的值分别增加和减少一个单位。相比之下，*semop()* 可以加减任意值。'
- en: There is no equivalent of the wait-for-zero operation provided by System V semaphores
    (a *semop()* call where the *sops.sem_op* field is specified as 0).
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有类似于 System V 信号量提供的等待零操作（*semop()* 调用中 *sops.sem_op* 字段指定为 0）的功能。
- en: From this list, it may seem that POSIX semaphores are less powerful than System
    V semaphores. However, this is not the case--anything that we can do with System
    V semaphores can also be done with POSIX semaphores. In a few cases, a bit more
    programming effort may be required, but, for typical scenarios, using POSIX semaphores
    actually requires less programming effort. (The System V semaphore API is rather
    more complicated than is required for most applications.)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个列表来看，可能会觉得 POSIX 信号量不如 System V 信号量强大。然而事实并非如此——我们用 System V 信号量可以做的任何事情，也能用
    POSIX 信号量实现。在某些情况下，可能需要多一些编程工作，但在典型的场景下，使用 POSIX 信号量实际上需要更少的编程工作。（System V 信号量
    API 比大多数应用需要的要复杂得多。）
- en: Waiting on a Semaphore
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 等待信号量
- en: The *sem_wait()* function decrements (decreases by 1) the value of the semaphore
    referred to by *sem*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*sem_wait()* 函数递减（减少 1）由 *sem* 引用的信号量的值。'
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，错误时返回 -1
- en: If the semaphore currently has a value greater than 0, *sem_wait()* returns
    immediately. If the value of the semaphore is currently 0, *sem_wait()* blocks
    until the semaphore value rises above 0; at that time, the semaphore is then decremented
    and *sem_wait()* returns.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果信号量当前的值大于 0，*sem_wait()* 会立即返回。如果信号量的值当前为 0，*sem_wait()* 会阻塞直到信号量值升高到 0 以上；此时，信号量值会被递减，*sem_wait()*
    返回。
- en: If a blocked *sem_wait()* call is interrupted by a signal handler, then it fails
    with the error `EINTR`, regardless of whether the `SA_RESTART` flag was used when
    establishing the signal handler with *sigaction()*. (On some other UNIX implementations,
    `SA_RESTART` does cause *sem_wait()* to automatically restart.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个被阻塞的 *sem_wait()* 调用被信号处理程序中断，那么它会以错误 `EINTR` 失败，无论在使用 *sigaction()* 设置信号处理程序时是否使用了
    `SA_RESTART` 标志。（在某些其他 UNIX 实现中，`SA_RESTART` 会导致 *sem_wait()* 自动重启。）
- en: The program in [Example 53-3](ch53.html#using_sem_underscore_wait_open_parenthes
    "Example 53-3. Using sem_wait() to decrement a POSIX semaphore") provides a command-line
    interface to the *sem_wait()* function. We demonstrate the use of this program
    shortly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 53-3](ch53.html#using_sem_underscore_wait_open_parenthes "示例 53-3. 使用 sem_wait()
    来递减一个 POSIX 信号量") 中的程序提供了一个命令行接口来使用 *sem_wait()* 函数。我们稍后会展示如何使用这个程序。'
- en: Example 53-3. Using *sem_wait()* to decrement a POSIX semaphore
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 53-3. 使用 *sem_wait()* 来递减一个 POSIX 信号量
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The *sem_trywait()* function is a nonblocking version of *sem_wait()*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*sem_trywait()* 函数是 *sem_wait()* 的非阻塞版本。'
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，错误时返回 -1
- en: If the decrement operation can’t be performed immediately, *sem_trywait()* fails
    with the error `EAGAIN`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果递减操作无法立即执行，*sem_trywait()* 将因错误 `EAGAIN` 而失败。
- en: The *sem_timedwait()* function is another variation on *sem_wait()*. It allows
    the caller to specify a limit on the time for which the call will block.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*sem_timedwait()* 函数是 *sem_wait()* 的另一种变体。它允许调用者指定调用阻塞的时间限制。'
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: If a *sem_timedwait()* call times out without being able to decrement the semaphore,
    then the call fails with the error `ETIMEDOUT`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *sem_timedwait()* 调用超时且无法递减信号量，则该调用将失败，并返回错误 `ETIMEDOUT`。
- en: 'The *abs_timeout* argument is a *timespec* structure ([High-Resolution Sleeping:
    *nanosleep()*](ch23.html#high-resolution_sleeping_colon_nanosleep "High-Resolution
    Sleeping: nanosleep()")) that specifies the timeout as an absolute value in seconds
    and nanoseconds since the Epoch. If we want to perform a relative timeout, then
    we must fetch the current value of the `CLOCK_REALTIME` clock using *clock_gettime()*
    and add the required amount to that value to produce a *timespec* structure suitable
    for use with *sem_timedwait()*.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*abs_timeout* 参数是一个 *timespec* 结构体（[高分辨率睡眠：*nanosleep()*](ch23.html#high-resolution_sleeping_colon_nanosleep
    "高分辨率睡眠：nanosleep()")），它指定自纪元以来的绝对超时时间，单位为秒和纳秒。如果我们想执行相对超时，则必须使用 *clock_gettime()*
    获取当前的 `CLOCK_REALTIME` 时钟值，并将所需的时间量加到该值上，生成一个适用于 *sem_timedwait()* 的 *timespec*
    结构体。'
- en: The *sem_timedwait()* function was originally specified in POSIX.1d (1999) and
    is not available on all UNIX implementations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*sem_timedwait()* 函数最初在 POSIX.1d（1999）中定义，并非所有 UNIX 实现都支持该函数。'
- en: Posting a Semaphore
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布信号量
- en: The *sem_post()* function increments (increases by 1) the value of the semaphore
    referred to by *sem*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*sem_post()* 函数将信号量 *sem* 的值递增（增加 1）。'
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: If the value of the semaphore was 0 before the *sem_post()* call, and some other
    process (or thread) is blocked waiting to decrement the semaphore, then that process
    is awoken, and its *sem_wait()* call proceeds to decrement the semaphore. If multiple
    processes (or threads) are blocked in *sem_wait()*, then, if the processes are
    being scheduled under the default round-robin time-sharing policy, it is indeterminate
    which one will be awoken and allowed to decrement the semaphore. (Like their System
    V counterparts, POSIX semaphores are only a synchronization mechanism, not a queuing
    mechanism.)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 *sem_post()* 调用之前信号量的值为 0，并且其他进程（或线程）被阻塞等待递减信号量，那么该进程将被唤醒，且其 *sem_wait()*
    调用将继续递减信号量。如果多个进程（或线程）在 *sem_wait()* 中被阻塞，则如果进程按照默认的轮询时间分配策略进行调度，则无法确定哪个进程将被唤醒并允许递减信号量。（像
    System V 信号量一样，POSIX 信号量仅仅是一个同步机制，而不是排队机制。）
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 specifies that if processes or threads are being executed under a realtime
    scheduling policy, then the process or thread that will be awoken is the one with
    the highest priority that has been waiting the longest.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 规定，如果进程或线程在实时调度策略下执行，则将唤醒等待时间最长且优先级最高的进程或线程。
- en: As with System V semaphores, incrementing a POSIX semaphore corresponds to releasing
    some shared resource for use by another process or thread.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与 System V 信号量一样，递增 POSIX 信号量意味着释放一些共享资源，以供其他进程或线程使用。
- en: The program in [Example 53-4](ch53.html#using_sem_underscore_post_open_parenthes
    "Example 53-4. Using sem_post() to increment a POSIX semaphore") provides a command-line
    interface to the *sem_post()* function. We demonstrate the use of this program
    shortly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 53-4](ch53.html#using_sem_underscore_post_open_parenthes "示例 53-4. 使用 sem_post()
    来递增 POSIX 信号量") 中的程序提供了一个命令行接口，用于调用 *sem_post()* 函数。我们稍后会演示如何使用这个程序。'
- en: Example 53-4. Using *sem_post()* to increment a POSIX semaphore
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 53-4. 使用 *sem_post()* 来递增 POSIX 信号量
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Retrieving the Current Value of a Semaphore
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取信号量的当前值
- en: The *sem_getvalue()* function returns the current value of the semaphore referred
    to by *sem* in the *int* pointed to by *sval*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*sem_getvalue()* 函数返回由 *sem* 引用的信号量的当前值，该值存储在 *sval* 所指向的 *int* 中。'
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: 'If one or more processes (or threads) are currently blocked waiting to decrement
    the semaphore’s value, then the value returned in *sval* depends on the implementation.
    SUSv3 permits two possibilities: 0 or a negative number whose absolute value is
    the number of waiters blocked in *sem_wait()*. Linux and several other implementations
    adopt the former behavior; a few other implementations adopt the latter behavior.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个或多个进程（或线程）当前被阻塞，等待递减信号量的值，那么返回的值在 *sval* 中取决于实现。SUSv3 允许两种可能性：0 或一个负数，其绝对值是被
    *sem_wait()* 阻塞的等待进程数。Linux 和其他一些实现采用前者；另外一些实现采用后者。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although returning a negative *sval* if there are blocked waiters can be useful,
    especially for debugging purposes, SUSv3 doesn’t require this behavior because
    the techniques that some systems use to efficiently implement POSIX semaphores
    don’t (in fact, can’t) record counts of blocked waiters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如果有阻塞的等待进程，返回负的 *sval* 很有用，特别是对于调试目的，但 SUSv3 并不要求这种行为，因为一些系统为了高效实现 POSIX 信号量所使用的技术并不（实际上无法）记录被阻塞的等待进程数量。
- en: Note that by the time *sem_getvalue()* returns, the value returned in *sval*
    may already be out of date. A program that depends on the information returned
    by *sem_getvalue()* being unchanged by the time of a subsequent operation will
    be subject to time-of-check, time-of-use race conditions ([Beware of Signals and
    Race Conditions](ch38.html#beware_of_signals_and_race_conditions "Beware of Signals
    and Race Conditions")).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 *sem_getvalue()* 返回时，*sval* 中返回的值可能已经过时。一个依赖于 *sem_getvalue()* 返回的信息在后续操作时不变的程序，将会面临检查时与使用时的竞争条件（[小心信号与竞争条件](ch38.html#beware_of_signals_and_race_conditions
    "Beware of Signals and Race Conditions")）。
- en: The program in [Example 53-5](ch53.html#using_sem_underscore_getvalue_open_paren
    "Example 53-5. Using sem_getvalue() to retrieve the value of a POSIX semaphore")
    uses *sem_getvalue()* to retrieve the value of the semaphore named in its command-line
    argument, and then displays that value on standard output.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 53-5](ch53.html#using_sem_underscore_getvalue_open_paren "Example 53-5.
    Using sem_getvalue() to retrieve the value of a POSIX semaphore") 中的程序使用 *sem_getvalue()*
    来检索命令行参数中指定的信号量的值，然后将该值显示在标准输出上。'
- en: Example 53-5. Using *sem_getvalue()* to retrieve the value of a POSIX semaphore
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 53-5. 使用 *sem_getvalue()* 检索 POSIX 信号量的值
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Example
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例
- en: 'The following shell session log demonstrates the use of the programs we have
    shown so far in this chapter. We begin by creating a semaphore whose initial value
    is zero, and then start a program in the background that attempts to decrement
    the semaphore:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 shell 会话日志演示了我们在本章中展示的程序的使用。我们首先创建一个初始值为零的信号量，然后启动一个后台程序，尝试递减该信号量：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The background command blocks, because the semaphore value is currently 0 and
    therefore can’t be decreased.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 后台命令被阻塞，因为信号量当前的值为 0，因此无法递减。
- en: 'We then retrieve the semaphore value:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检索信号量的值：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We see the value 0 above. On some other implementations, we might see the value
    -1, indicating that one process is waiting on the semaphore.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到上面的值为 0。在一些其他实现中，我们可能会看到值为 -1，表示有一个进程正在等待该信号量。
- en: 'We then execute a command that increments the semaphore. This causes the blocked
    *sem_wait()* in the background program to complete:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们执行一个命令来递增信号量。这将导致后台程序中的被阻塞的 *sem_wait()* 操作完成：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: (The last line of output above shows the shell prompt mixed with the output
    of the background job.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: （上面的最后一行输出显示了 shell 提示符与后台作业的输出混合在一起。）
- en: 'We press *Enter* to see the next shell prompt, which also causes the shell
    to report on the terminated background job, and then perform further operations
    on the semaphore:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按下 *Enter* 键以查看下一个 shell 提示符，这也会导致 shell 报告已终止的后台作业，并随后对信号量执行进一步的操作：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Unnamed Semaphores
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无名信号量
- en: Unnamed semaphores (also known as *memory-based semaphores*) are variables of
    type *sem_t* that are stored in memory allocated by the application. The semaphore
    is made available to the processes or threads that use it by placing it in an
    area of memory that they share.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 无名信号量（也叫做 *基于内存的信号量*）是类型为 *sem_t* 的变量，这些变量存储在应用程序分配的内存中。通过将信号量放置在它们共享的内存区域中，使进程或线程能够使用它。
- en: 'Operations on unnamed semaphores use the same functions (*sem_wait()*, *sem_post()*,
    *sem_getvalue()*, and so on) that are used to operate on named semaphores. In
    addition, two further functions are required:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对无名信号量的操作使用与操作命名信号量相同的函数（*sem_wait()*、*sem_post()*、*sem_getvalue()* 等）。此外，还需要两个额外的函数：
- en: The *sem_init()* function initializes a semaphore and informs the system of
    whether the semaphore will be shared between processes or between the threads
    of a single process.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*sem_init()* 函数初始化信号量，并告知系统该信号量是要在进程间共享还是在单个进程的线程间共享。'
- en: The *sem_destroy(sem)* function destroys a semaphore.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*sem_destroy(sem)* 函数用于销毁信号量。'
- en: These functions should not be used with named semaphores.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数不应与命名信号量一起使用。
- en: Unnamed versus named semaphores
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无名信号量与命名信号量
- en: 'Using an unnamed semaphore allows us to avoid the work of creating a name for
    a semaphore. This can be useful in the following cases:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无名信号量可以避免为信号量创建名称的工作。这在以下情况下特别有用：
- en: A semaphore that is shared between threads doesn’t need a name. Making an unnamed
    semaphore a shared (global or heap) variable automatically makes it accessible
    to all threads.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程间共享的信号量不需要名称。将无名信号量作为共享（全局或堆）变量会自动使其对所有线程可访问。
- en: A semaphore that is being shared between related processes doesn’t need a name.
    If a parent process allocates an unnamed semaphore in a region of shared memory
    (e.g., a shared anonymous mapping), then a child automatically inherits the mapping
    and thus the semaphore as part of the operation of *fork()*.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在相关进程间共享的信号量不需要名称。如果父进程在共享内存区域（例如共享匿名映射）中分配了无名信号量，则子进程会自动继承该映射，因此信号量也会作为 *fork()*
    操作的一部分被继承。
- en: If we are building a dynamic data structure (e.g., a binary tree), each of whose
    items requires an associated semaphore, then the simplest approach is to allocate
    an unnamed semaphore within each item. Opening a named semaphore for each item
    would require us to design a convention for generating a (unique) semaphore name
    for each item and to manage those names (e.g., unlinking them when they are no
    longer required).
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们正在构建一个动态数据结构（例如二叉树），每个元素都需要一个关联的信号量，那么最简单的方法是在每个元素内分配一个无名信号量。为每个元素打开一个命名信号量将需要我们设计一种约定，用于为每个元素生成（唯一的）信号量名称，并管理这些名称（例如，在不再需要时取消链接它们）。
- en: Initializing an Unnamed Semaphore
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化一个无名信号量
- en: The *sem_init()* function initializes the unnamed semaphore pointed to by *sem*
    to the value specified by *value*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*sem_init()* 函数将指向 *sem* 的无名信号量初始化为 *value* 指定的值。'
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，错误时返回 -1。
- en: The *pshared* argument indicates whether the semaphore is to be shared between
    threads or between processes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*pshared* 参数指示信号量是否在线程间或进程间共享。'
- en: If *pshared* is 0, then the semaphore is to be shared between the threads of
    the calling process. In this case, *sem* is typically specified as the address
    of either a global variable or a variable allocated on the heap. A thread-shared
    semaphore has process persistence; it is destroyed when the process terminates.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *pshared* 为 0，则信号量将在调用进程的线程间共享。在这种情况下，*sem* 通常指定为全局变量或在堆上分配的变量的地址。线程共享的信号量具有进程持久性；当进程终止时，它将被销毁。
- en: If *pshared* is nonzero, then the semaphore is to be shared between processes.
    In this case, *sem* must be the address of a location in a region of shared memory
    (a POSIX shared memory object, a shared mapping created using *mmap()*, or a System
    V shared memory segment). The semaphore persists as long as the shared memory
    in which it resides. (The shared memory regions created by most of these techniques
    have kernel persistence. The exception is shared anonymous mappings, which persist
    only as long as at least one process maintains the mapping.) Since a child produced
    via *fork()* inherits its parent’s memory mappings, process-shared semaphores
    are inherited by the child of a *fork()*, and the parent and child can use these
    semaphores to synchronize their actions.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *pshared* 非零，则信号量将在进程间共享。在这种情况下，*sem* 必须是指向共享内存区域（POSIX共享内存对象、通过 *mmap()*
    创建的共享映射或系统V共享内存段）中某个位置的地址。信号量的生命周期与其所在的共享内存的生命周期相同。（大多数这些技术创建的共享内存区域具有内核持久性，唯一的例外是共享匿名映射，它们只在至少有一个进程保持映射时才会持久存在。）由于通过
    *fork()* 创建的子进程会继承父进程的内存映射，因此进程共享信号量会被 *fork()* 的子进程继承，父子进程可以使用这些信号量来同步它们的操作。
- en: 'The *pshared* argument is necessary for the following reasons:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*pshared* 参数对于以下原因是必要的：'
- en: Some implementations don’t support process-shared semaphores. On these systems,
    specifying a nonzero value for *pshared* causes *sem_init()* to return an error.
    Linux did not support unnamed process-shared semaphores until kernel 2.6 and the
    advent of the NPTL threading implementation. (The older LinuxThreads implementation
    of *sem_init()* fails with the error `ENOSYS` if a nonzero value is specified
    for *pshared*.)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些实现不支持进程共享信号量。在这些系统中，为*pshared*指定非零值会导致*sem_init()*返回错误。直到内核2.6和NPTL线程实现的出现，Linux才开始支持无名进程共享信号量。（在较旧的LinuxThreads实现中，如果为*pshared*指定非零值，*sem_init()*会失败并返回`ENOSYS`错误。）
- en: On implementations that support both process-shared and thread-shared semaphores,
    specifying which kind of sharing is required may be necessary because the system
    must take special actions to support the requested sharing. Providing this information
    may also permit the system to perform optimizations depending on the type of sharing.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在支持进程共享和线程共享信号量的实现中，可能需要指定所需的共享类型，因为系统必须采取特殊措施来支持所请求的共享。提供这些信息还可能允许系统根据共享类型执行优化。
- en: The NPTL *sem_init()* implementation ignores *pshared*, since no special action
    is required for either type of sharing. Nevertheless, portable and future-proof
    applications should specify an appropriate value for *pshared*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: NPTL的*sem_init()*实现忽略*pshared*，因为对于任何类型的共享，都不需要特殊操作。然而，可移植且具有前瞻性的应用程序应为*pshared*指定一个适当的值。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The SUSv3 specification for *sem_init()* defines a failure return of -1, but
    makes no statement about the return value on success. Nevertheless, the manual
    pages on most modern UNIX implementations document a 0 return on success. (One
    notable exception is Solaris, where the description of the return value is similar
    to the SUSv3 specification. However, inspecting the OpenSolaris source code shows
    that, on that implementation, *sem_init()* does return 0 on success.) SUSv4 rectifies
    the situation, specifying that *sem_init()* shall return 0 on success.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3对*sem_init()*的规范定义了失败时返回-1，但没有说明成功时的返回值。然而，大多数现代UNIX实现的手册页上记录了成功时返回0。（一个显著的例外是Solaris，其中返回值的描述类似于SUSv3的规范。然而，通过检查OpenSolaris的源代码可以发现，在该实现中，*sem_init()*在成功时确实返回0。）SUSv4修正了这一情况，明确规定*sem_init()*在成功时应返回0。
- en: There are no permission settings associated with an unnamed semaphore (i.e.,
    *sem_init()* has no analog of the *mode* argument of *sem_open()*). Access to
    an unnamed semaphore is governed by the permissions that are granted to the process
    for the underlying shared memory region.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 无名信号量没有与之关联的权限设置（即，*sem_init()*没有类似*sem_open()*中*mode*参数的功能）。对无名信号量的访问受到底层共享内存区域赋予进程的权限控制。
- en: SUSv3 specifies that initializing an already initialized unnamed semaphore results
    in undefined behavior. In other words, we must design our applications so that
    just one process or thread calls *sem_init()* to initialize a semaphore.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3规定，如果初始化一个已经初始化过的无名信号量，将导致未定义的行为。换句话说，我们必须设计我们的应用程序，确保只有一个进程或线程调用*sem_init()*来初始化信号量。
- en: As with named semaphores, SUSv3 says that the results are undefined if we attempt
    to perform operations on a *copy* of the *sem_t* variable whose address is passed
    as the *sem* argument of *sem_init()*. Operations should always be performed only
    on the “original” semaphore.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与命名信号量一样，SUSv3规定，如果我们尝试对传递给*sem_init()*的*sem*参数所指向的*sem_t*变量的*副本*进行操作，结果是未定义的。操作应始终仅对“原始”信号量进行。
- en: Example program
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: In [Locking and Unlocking a Mutex](ch30.html#locking_and_unlocking_a_mutex "Locking
    and Unlocking a Mutex"), we presented a program ([Example 30-2](ch30.html#using_a_mutex_to_protect_access_to_a_glo
    "Example 30-2. Using a mutex to protect access to a global variable")) that used
    mutexes to protect a critical section in which two threads accessed the same global
    variable. The program in [Example 53-6](ch53.html#using_a_posix_unnamed_semaphore_to_prote
    "Example 53-6. Using a POSIX unnamed semaphore to protect access to a global variable")
    solves the same problem using an unnamed thread-shared semaphore.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在[锁定和解锁互斥量](ch30.html#locking_and_unlocking_a_mutex "锁定和解锁互斥量")中，我们展示了一个程序（[示例30-2](ch30.html#using_a_mutex_to_protect_access_to_a_glo
    "示例30-2. 使用互斥量保护对全局变量的访问")），该程序使用互斥量保护临界区，其中两个线程访问相同的全局变量。在[示例53-6](ch53.html#using_a_posix_unnamed_semaphore_to_prote
    "示例53-6. 使用POSIX无名信号量保护对全局变量的访问")中的程序，通过使用一个无名的线程共享信号量来解决同样的问题。
- en: Example 53-6. Using a POSIX unnamed semaphore to protect access to a global
    variable
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 53-6：使用 POSIX 无名信号量保护对全局变量的访问
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Destroying an Unnamed Semaphore
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 销毁无名信号量
- en: The *sem_destroy()* function destroys the semaphore *sem*, which must be an
    unnamed semaphore that was previously initialized using *sem_init()*. It is safe
    to destroy a semaphore only if no processes or threads are waiting on it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*sem_destroy()* 函数销毁信号量 *sem*，该信号量必须是之前使用 *sem_init()* 初始化的无名信号量。只有在没有进程或线程正在等待该信号量时，销毁信号量才是安全的。'
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: After an unnamed semaphore segment has been destroyed with *sem_destroy()*,
    it can be reinitialized with *sem_init()*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 *sem_destroy()* 销毁无名信号量段后，可以使用 *sem_init()* 重新初始化它。
- en: An unnamed semaphore should be destroyed before its underlying memory is deallocated.
    For example, if the semaphore is an automatically allocated variable, it should
    be destroyed before its host function returns. If the semaphore resides in a POSIX
    shared memory region, then it should be destroyed after all processes have ceased
    using the semaphore and before the shared memory object is unlinked with *shm_unlink()*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 无名信号量应在其底层内存被释放之前销毁。例如，如果信号量是自动分配的变量，它应在宿主函数返回之前销毁。如果信号量位于 POSIX 共享内存区域中，则应在所有进程停止使用信号量后，并在共享内存对象使用
    *shm_unlink()* 解除链接之前销毁它。
- en: On some implementations, omitting calls to *sem_destroy()* doesn’t cause problems.
    However, on other implementations, failing to call *sem_destroy()* can result
    in resource leaks. Portable applications should call *sem_destroy()* to avoid
    such problems.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些实现中，省略对 *sem_destroy()* 的调用不会导致问题。然而，在其他实现中，未调用 *sem_destroy()* 可能会导致资源泄漏。为了避免此类问题，便携式应用程序应该调用
    *sem_destroy()*。
- en: Comparisons with Other Synchronization Techniques
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与其他同步技术的比较
- en: 'In this section, we compare POSIX semaphores with two other synchronization
    techniques: System V semaphores and mutexes.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们将 POSIX 信号量与另外两种同步技术进行比较：System V 信号量和互斥量（mutex）。
- en: POSIX semaphores versus System V semaphores
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: POSIX 信号量与 System V 信号量
- en: 'POSIX semaphores and System V semaphores can both be used to synchronize the
    actions of processes. [Comparison of System V IPC and POSIX IPC](ch51.html#comparison_of_system_v_ipc_and_posix_ipc
    "Comparison of System V IPC and POSIX IPC") listed various advantages of POSIX
    IPC over System V IPC: the POSIX IPC interface is simpler and more consistent
    with the traditional UNIX file model, and POSIX IPC objects are reference counted,
    which simplifies the task of determining when to delete an IPC object. These general
    advantages also apply to the specific case of POSIX (named) semaphores versus
    System V semaphores.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 信号量和 System V 信号量都可以用来同步进程的操作。[System V IPC 与 POSIX IPC 的比较](ch51.html#comparison_of_system_v_ipc_and_posix_ipc
    "System V IPC 与 POSIX IPC 的比较")列出了 POSIX IPC 相对于 System V IPC 的各种优势：POSIX IPC
    接口更简单，并且与传统 UNIX 文件模型更一致，同时 POSIX IPC 对象是引用计数的，这简化了确定何时删除 IPC 对象的任务。这些一般优势同样适用于
    POSIX（命名）信号量与 System V 信号量的具体情况。
- en: 'POSIX semaphores have the following further advantages over System V semaphores:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 信号量相对于 System V 信号量有以下进一步优势：
- en: The POSIX semaphore interface is much simpler than the System V semaphore interface.
    This simplicity is achieved without loss of functional power.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX 信号量接口比 System V 信号量接口简单得多。这种简化是在不损失功能性的前提下实现的。
- en: POSIX named semaphores eliminate the initialization problem associated with
    System V semaphores ([Semaphore Initialization](ch47.html#semaphore_initialization
    "Semaphore Initialization")).
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX 命名信号量消除了与 System V 信号量相关的初始化问题（[信号量初始化](ch47.html#semaphore_initialization
    "信号量初始化")）。
- en: 'It is easier to associate a POSIX unnamed semaphore with a dynamically allocated
    memory object: the semaphore can simply be embedded inside the object.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 POSIX 无名信号量与动态分配的内存对象关联起来更为容易：信号量可以直接嵌入到对象内部。
- en: In scenarios where there is a high degree of contention for a semaphore (i.e.,
    operations on the semaphore are frequently blocked because another process has
    set the semaphore to a value that prevents the operation proceeding immediately),
    then the performance of POSIX semaphores and System V semaphores is similar. However,
    in cases where there is low contention for a semaphore (i.e., the semaphore’s
    value is such that operations can normally proceed without blocking), then POSIX
    semaphores perform considerably better than System V semaphores. (On the systems
    tested by the author, the difference in performance is more than an order of magnitude;
    see Exercise 53-4.) POSIX semaphores perform so much better in this case because
    the way in which they are implemented only requires a system call when contention
    occurs, whereas System V semaphore operations always require a system call, regardless
    of contention.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在信号量争用激烈的场景中（即由于另一个进程将信号量设置为阻止操作立即进行的值，导致对信号量的操作频繁被阻塞），POSIX 信号量和 System V 信号量的性能相似。然而，在信号量争用较低的情况下（即信号量的值使得操作通常可以顺利进行而不会被阻塞），POSIX
    信号量的性能明显优于 System V 信号量。（在作者测试的系统上，性能差异超过一个数量级；见练习 53-4。）POSIX 信号量在这种情况下表现更好的原因是它们的实现方式只有在发生争用时才需要系统调用，而
    System V 信号量操作则总是需要系统调用，不论是否发生争用。
- en: 'However, POSIX semaphores also have the following disadvantages compared to
    System V semaphores:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与 System V 信号量相比，POSIX 信号量也有以下缺点：
- en: POSIX semaphores are somewhat less portable. (On Linux, named semaphores have
    been supported only since kernel 2.6.)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX 信号量的可移植性稍差。（在 Linux 上，命名信号量从内核 2.6 开始才得到支持。）
- en: POSIX semaphores don’t provide an equivalent of the System V semaphore undo
    feature. (However, as we noted in [Semaphore Undo Values](ch47.html#semaphore_undo_values
    "Semaphore Undo Values"), this feature may not be useful in some circumstances.)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX 信号量没有提供类似于 System V 信号量的撤销特性。（然而，正如我们在[信号量撤销值](ch47.html#semaphore_undo_values
    "信号量撤销值")中提到的，这个特性在某些情况下可能并不有用。）
- en: POSIX semaphores versus Pthreads mutexes
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: POSIX 信号量与 Pthreads 互斥锁
- en: POSIX semaphores and Pthreads mutexes can both be used to synchronize the actions
    of threads within the same process, and their performance is similar. However,
    mutexes are usually preferable, because the ownership property of mutexes enforces
    good structuring of code (only the thread that locks a mutex can unlock it). By
    contrast, one thread can increment a semaphore that was decremented by another
    thread. This flexibility can lead to poorly structured synchronization designs.
    (For this reason, semaphores are sometimes referred to as the “gotos” of concurrent
    programming.)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 信号量和 Pthreads 互斥锁都可以用来同步同一进程内线程的操作，且它们的性能相似。然而，互斥锁通常更为优选，因为互斥锁的所有权特性有助于代码结构的规范化（只有锁定互斥锁的线程才能解锁它）。相比之下，一个线程可以递增另一个线程递减的信号量。这种灵活性可能导致不良的同步设计。（因此，信号量有时被称为并发编程中的“goto”。）
- en: There is one circumstance in which mutexes can’t be used in a multithreaded
    application and semaphores may therefore be preferable. Because it is async-signal-safe
    (see [Table 21-1](ch21.html#functions_required_to_be_async-signal-sa "Table 21-1. Functions
    required to be async-signal-safe by POSIX.1-1990, SUSv2, and SUSv3"), in [Standard
    async-signal-safe functions](ch21.html#standard_async-signal-safe_functions "Standard
    async-signal-safe functions")), the *sem_post()* function can be used from within
    a signal handler to synchronize with another thread. This is not possible with
    mutexes, because the Pthreads functions for operating on mutexes are not async-signal-safe.
    However, because it is usually preferable to deal with asynchronous signals by
    accepting them using *sigwaitinfo()* (or similar), rather than using signal handlers
    (see [Dealing with Asynchronous Signals Sanely](ch33.html#dealing_with_asynchronous_signals_sanely
    "Dealing with Asynchronous Signals Sanely")), this advantage of semaphores over
    mutexes is seldom required.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程应用程序中，有一种情况是无法使用互斥锁（mutexes）的，因此信号量可能更为可取。由于它是异步信号安全的（参见[表21-1](ch21.html#functions_required_to_be_async-signal-sa
    "表21-1. POSIX.1-1990、SUSv2 和 SUSv3 中要求异步信号安全的函数")，在[标准异步信号安全函数](ch21.html#standard_async-signal-safe_functions
    "标准异步信号安全函数")中），`*sem_post()*`函数可以在信号处理程序内使用，以便与另一个线程同步。这对于互斥锁来说是不可能的，因为操作互斥锁的
    Pthreads 函数不是异步信号安全的。然而，由于通常更推荐通过使用*sigwaitinfo()*（或类似函数）来处理异步信号，而不是使用信号处理程序（参见[理智地处理异步信号](ch33.html#dealing_with_asynchronous_signals_sanely
    "理智地处理异步信号")），因此信号量在这方面相较于互斥锁的优势通常不需要。
- en: Semaphore Limits
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号量限制
- en: 'SUSv3 defines two limits applying to semaphores:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 定义了两个适用于信号量的限制：
- en: '`SEM_NSEMS_MAX`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`SEM_NSEMS_MAX`'
- en: This is the maximum number of POSIX semaphores that a process may have. SUSv3
    requires that this limit be at least 256\. On Linux, the number of POSIX semaphores
    is effectively limited only by available memory.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个进程可以拥有的 POSIX 信号量的最大数量。SUSv3 要求此限制至少为 256。对于 Linux，POSIX 信号量的数量实际上仅受可用内存的限制。
- en: '`SEM_VALUE_MAX`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`SEM_VALUE_MAX`'
- en: This is the maximum value that a POSIX semaphore may reach. Semaphores may assume
    any value from 0 up to this limit. SUSv3 requires this limit to be at least 32,767;
    the Linux implementation allows values up to `INT_MAX` (2,147,483,647 on Linux/x86-32).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 POSIX 信号量可以达到的最大值。信号量可以取从 0 到此限制之间的任意值。SUSv3 要求此限制至少为 32,767；而 Linux 实现允许的最大值为
    `INT_MAX`（在 Linux/x86-32 上为 2,147,483,647）。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'POSIX semaphores allow processes or threads to synchronize their actions. POSIX
    semaphores come in two types: named and unnamed. A named semaphore is identified
    by a name, and can be shared by any processes that have permission to open the
    semaphore. An unnamed semaphore has no name, but processes or threads can share
    the same semaphore by placing it in a region of memory that they share (e.g.,
    in a POSIX shared memory object for process sharing, or in a global variable for
    thread sharing).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 信号量允许进程或线程同步其操作。POSIX 信号量有两种类型：命名信号量和未命名信号量。命名信号量通过名称进行标识，可以被任何具有打开信号量权限的进程共享。未命名信号量没有名称，但进程或线程可以通过将其放置在它们共享的内存区域中来共享该信号量（例如，在用于进程共享的
    POSIX 共享内存对象中，或在用于线程共享的全局变量中）。
- en: The POSIX semaphore interface is simpler than the System V semaphore interface.
    Semaphores are allocated and operated on individually, and the wait and post operations
    adjust a semaphore’s value by one.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 信号量接口比 System V 信号量接口更简单。信号量是单独分配和操作的，等待（wait）和发布（post）操作将信号量的值调整为 1。
- en: POSIX semaphores have a number of advantages over System V semaphores, but they
    are somewhat less portable. For synchronization within multithreaded applications,
    mutexes are generally preferred over semaphores.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 信号量相较于 System V 信号量具有一些优势，但它们的可移植性稍差。在多线程应用程序中的同步，通常更推荐使用互斥锁（mutexes）而非信号量。
- en: Further information
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步信息
- en: '[Stevens, 1999] provides an alternative presentation of POSIX semaphores and
    shows user-space implementations using various other IPC mechanisms (FIFOs, memory-mapped
    files, and System V semaphores). [Butenhof, 1996] describes the use of POSIX semaphores
    in multithreaded applications.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[Stevens, 1999] 提供了 POSIX 信号量的另一种呈现方式，并展示了使用其他 IPC 机制（如 FIFO、内存映射文件和 System
    V 信号量）的用户空间实现。[Butenhof, 1996] 描述了在多线程应用程序中使用 POSIX 信号量的方法。'
- en: Exercises
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Rewrite the programs in [Example 48-2](ch48.html#transfer_blocks_of_data_from_stdin_to_a
    "Example 48-2. Transfer blocks of data from stdin to a System V shared memory
    segment") and [Example 48-3](ch48.html#transfer_blocks_of_data_from_a_system_v
    "Example 48-3. Transfer blocks of data from a System V shared memory segment to
    stdout") ([Example: Transferring Data via Shared Memory](ch48.html#example_colon_transferring_data_via_shar
    "Example: Transferring Data via Shared Memory")) as a threaded application, with
    the two threads passing data to each other via a global buffer, and using POSIX
    semaphores for synchronization.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将[示例 48-2](ch48.html#transfer_blocks_of_data_from_stdin_to_a "示例 48-2. 从 stdin
    向 System V 共享内存段传输数据块")和[示例 48-3](ch48.html#transfer_blocks_of_data_from_a_system_v
    "示例 48-3. 从 System V 共享内存段向 stdout 传输数据块")([示例：通过共享内存传输数据](ch48.html#example_colon_transferring_data_via_shar
    "示例：通过共享内存传输数据"))中的程序重写为一个多线程应用程序，两个线程通过一个全局缓冲区相互传递数据，并使用POSIX信号量进行同步。
- en: Modify the program in [Example 53-3](ch53.html#using_sem_underscore_wait_open_parenthes
    "Example 53-3. Using sem_wait() to decrement a POSIX semaphore") (`psem_wait.c`)
    to use *sem_timedwait()* instead of *sem_wait()*. The program should take an additional
    command-line argument that specifies a (relative) number of seconds to be used
    as the timeout for the *sem_timedwait()* call.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[示例 53-3](ch53.html#using_sem_underscore_wait_open_parenthes "示例 53-3. 使用
    sem_wait() 来递减 POSIX 信号量")中的程序(`psem_wait.c`)，将*sem_wait()*替换为*sem_timedwait()*。程序应该接受一个额外的命令行参数，指定一个（相对的）秒数作为*sem_timedwait()*调用的超时。
- en: Devise an implementation of POSIX semaphores using System V semaphores.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计一种使用System V信号量实现POSIX信号量的方法。
- en: In [Comparisons with Other Synchronization Techniques](ch53.html#comparisons_with_other_synchronization_t
    "Comparisons with Other Synchronization Techniques"), we noted that POSIX semaphores
    perform much better than System V semaphores in the case where the semaphore is
    uncontended. Write two programs (one for each semaphore type) to verify this.
    Each program should simply increment and decrement a semaphore a specified number
    of times. Compare the times required for the two programs.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[与其他同步技术的比较](ch53.html#comparisons_with_other_synchronization_t "与其他同步技术的比较")中，我们指出在信号量未发生竞争的情况下，POSIX信号量比System
    V信号量表现得更好。编写两个程序（每种信号量类型一个）来验证这一点。每个程序应该简单地增加和减少一个信号量指定次数。比较这两个程序所需的时间。
