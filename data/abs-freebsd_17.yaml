- en: '**17'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**17'
- en: ADVANCED SOFTWARE MANAGEMENT**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 高级软件管理**
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: FreeBSD offers unique features that help system administrators better meet users’
    needs. Knowing how the system really works helps you make better decisions. For
    example, while multiple processors, multicore processors, and hardware threads
    can all increase system performance, they don’t always help as much as you might
    think. Knowing how different types of multiprocessing affect different types of
    workloads tells you where you can improve performance and where you can’t.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 提供了独特的功能，帮助系统管理员更好地满足用户需求。了解系统的真正工作原理有助于您做出更好的决策。例如，虽然多个处理器、多核处理器和硬件线程都能提高系统性能，但它们并不总是像您想象的那样有效。了解不同类型的多处理如何影响不同类型的工作负载，能告诉您在哪些地方可以提高性能，哪些地方不能。
- en: For your programs to start at boot and stop cleanly at shutdown, you must be
    able to create and edit proper startup and shutdown scripts. While some programs
    stop nicely when you just kill the operating system under them, others (for example,
    databases) demand a gentler shutdown. Starting and stopping system services cleanly
    is an excellent habit to develop, so we’ll learn more about the FreeBSD startup
    and shutdown scripts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您的程序在启动时自动启动，并在关机时干净地停止，您必须能够创建和编辑正确的启动和关机脚本。虽然有些程序在操作系统关闭时能够优雅地停止，但其他程序（例如数据库）则要求更温和的关机。干净地启动和停止系统服务是一个很好的习惯，所以我们将进一步了解
    FreeBSD 的启动和关机脚本。
- en: Under normal circumstances, you’ll never need to know how FreeBSD’s linking
    and shared library support works, but we’ll discuss them anyway. Why? Because
    normal circumstances are, oddly, quite rare in the computer business.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，您永远不需要知道 FreeBSD 的链接和共享库支持是如何工作的，但我们还是会讨论这些内容。为什么？因为正常情况在计算机行业中，奇怪地说，是相当罕见的。
- en: Finally, FreeBSD can run Linux software with the Linux compatibility layer,
    as well as software written for other hardware architectures.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，FreeBSD 可以通过 Linux 兼容层运行 Linux 软件，也可以运行为其他硬件架构编写的软件。
- en: '**Using Multiple Processors: SMP**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用多个处理器：SMP**'
- en: If you have a desktop or server built in the last 10 years, it almost certainly
    has multiple processors. Some of those processors are for dedicated purposes,
    such as the graphics processor in your video card. Modern operating systems use
    *symmetric multiprocessing (SMP)*, or multiple identical general-purpose processors.
    Modern hardware includes many different dedicated-purpose processors, such as
    the graphics card and server remote management and so on, but the hardware presented
    to the operating system has identical processors.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的桌面或服务器是在过去 10 年内构建的，它几乎可以肯定配备了多个处理器。其中一些处理器用于专用目的，例如您显卡中的图形处理器。现代操作系统使用
    *对称多处理（SMP）*，即多个相同的通用处理器。现代硬件包括许多不同的专用处理器，例如显卡和服务器远程管理等，但呈现给操作系统的硬件是相同的处理器。
- en: SMP systems have many advantages over single processors, and it’s not just the
    obvious “more power!” If you think about it at the microscopic level, in very
    small timeframes, a CPU can do only one thing at a time. Every process on the
    computer competes for processor time. If the CPU is performing a database query,
    it isn’t accepting the packet that the Ethernet card is trying to deliver. Every
    fraction of a second kernel directs the CPU to perform a *context switch* and
    work on another request. This happens so often and so quickly that the computer
    appears to be doing many things at once—much as a television picture appears to
    be moving when it’s really just showing individual pictures one after the other
    very quickly.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: SMP 系统相比单个处理器有许多优势，而且不仅仅是显而易见的“更多的力量！”如果从微观层面考虑，在非常短的时间内，CPU 一次只能做一件事。计算机上的每个进程都在争夺处理器时间。如果
    CPU 正在执行数据库查询，它就无法接受以太网卡试图传送的包。每一秒的一小部分时间，内核会指示 CPU 执行 *上下文切换*，并处理另一个请求。这种情况发生得如此频繁和快速，以至于计算机看起来像是在同时做很多事情——就像电视画面看起来在移动，其实它只是在以非常快的速度依次显示单个画面一样。
- en: My desktop has cwm providing window management, Firefox with eighty bajillion
    tabs, and LibreOffice accepting my typing. There’s a whole bunch of terminal windows
    attached to SSH sessions. Network interrupts are arriving; the screen is displaying
    text; the MP3 player is streaming Nurse With Wound to Stereohenge. The computer’s
    “seamless multitasking” only appears seamless to my feeble brain. In reality,
    the computer merely switches from one task to another very quickly. One millisecond,
    it’s sending another sliver of sound to my headphones, and the next, it’s updating
    text on the screen.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我的桌面上有 cwm 提供窗口管理，Firefox 打开了成千上万的标签页，LibreOffice 正在接受我的输入。还有一堆终端窗口连接着 SSH 会话。网络中断不断到达；屏幕上显示着文本；MP3
    播放器正在播放 Nurse With Wound 的 Stereohenge 专辑。计算机的“无缝多任务处理”看起来对我那脆弱的大脑而言确实很无缝。实际上，计算机只是非常快速地从一个任务切换到另一个任务。一个毫秒，它在将另一个声音片段传输到我的耳机，接下来的一个毫秒，它更新屏幕上的文本。
- en: With multiple processors, your computer really *can* perform multiple operations
    simultaneously. This is very useful—but system complexity skyrockets.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个处理器，你的计算机的确*可以*同时执行多个操作。这非常有用——但系统复杂性也急剧上升。
- en: '***Kernel Assumptions***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内核假设***'
- en: To understand SMP and the problems associated with it, we must delve into the
    kernel. All operating systems face the same challenges when supporting SMP, and
    the theory here is applicable across a wide variety of platforms. What follows
    is a gross simplification. Kernel design is a tricky subject, and it’s almost
    impossible for any description to do it justice. Nevertheless, here’s a rough
    stab at it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 SMP 以及它相关的问题，我们必须深入研究内核。所有操作系统在支持 SMP 时面临相同的挑战，这里的理论适用于各种平台。接下来是一个粗略的简化。内核设计是一个复杂的话题，几乎不可能有任何描述能够完全阐述它。然而，下面是一个大致的尝试。
- en: FreeBSD divides CPU utilization into time slices. A *time slice* is the length
    of time one CPU spends doing one task. One process can use the CPU either for
    a full-time slice or until there’s no more work for it to do, at which point the
    next task may run. The kernel uses a priority-based system to allocate time slices
    and to determine which programs may run in which time slices. If a process is
    running, but a higher-priority process presents itself, the kernel allows the
    first process to be interrupted, or *preempted*. This is commonly referred to
    as *preemptive multitasking*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 将 CPU 使用率划分为时间片。*时间片*是 CPU 执行一个任务的时间长度。一个进程可以使用 CPU，或者使用整个时间片，或者直到没有更多工作要做为止，此时下一个任务可能会运行。内核使用基于优先级的系统来分配时间片并决定哪些程序可以在哪些时间片中运行。如果一个进程正在运行，但一个更高优先级的进程出现，内核允许第一个进程被中断，或*抢占*。这通常被称为*抢占式多任务处理*。
- en: Although the kernel is running, it isn’t a process. Any process has certain
    data structures set up by the kernel, and the kernel manipulates those data structures
    as it sees fit. You can consider the kernel a special sort of process, one that
    behaves very differently from all other processes. It can’t be interrupted by
    other programs—you can’t type `pkill kernel` and reboot the system. Way back in
    the day, the kernel might have been called the *control process* or *monitor*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管内核正在运行，但它并不是一个进程。任何进程都有由内核设置的某些数据结构，内核根据需要操作这些数据结构。你可以把内核看作一种特殊类型的进程，它的行为与其他进程大不相同。它无法被其他程序中断——你不能输入
    `pkill kernel` 来重启系统。早在以前，内核可能被称为*控制进程*或*监控程序*。
- en: The kernel has special problems, not faced by other parts of the system. Imagine
    that you have a program sending data over the network. The kernel accepts data
    from the program and places it in a chunk of memory to be handed to the network
    card. If the computer can do only one thing at a time, nothing happens to that
    piece of memory or that network card until the kernel gets back to that task.
    If you have multiple processors, however, the computer can perform multiple tasks
    simultaneously. What if two different CPUs, both working on kernel tasks, direct
    your network card to perform different actions at the same time? The network card
    behaves much as you do when you have your boss screaming in one ear and your spouse
    in the other; nothing you do can satisfy either of them. What if one CPU allocates
    memory for a network task, while the other CPU allocates that same memory for
    a filesystem task? The kernel becomes confused, and the results will not please
    you.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 内核面临着系统其他部分没有的特殊问题。假设你有一个程序在通过网络发送数据。内核接受来自程序的数据并将其放入一块内存中，准备交给网络卡。如果计算机一次只能做一件事，那么在内核回到该任务之前，这块内存或网络卡不会发生任何变化。然而，如果你有多个处理器，计算机可以同时执行多个任务。那么，如果两个不同的CPU，都在处理内核任务，同时指示网络卡执行不同的操作，会发生什么呢？网络卡的表现就像你在一边听老板吼叫，另一边听配偶抱怨；你做的任何事都无法让他们满意。如果一个CPU为网络任务分配了内存，而另一个CPU为文件系统任务分配了相同的内存，会怎样呢？内核会变得混乱，结果不会让你满意。
- en: 'Unix-like kernels designed for a single processor declare that the kernel is
    nonpreemptive and can’t be interrupted. This simplifies kernel management because
    everything becomes completely deterministic: when a part of the kernel allocates
    memory, it can count on that memory being unchanged when it executes the next
    instruction. No other part of the kernel will alter that chunk of memory. When
    the computer could do only one thing at a time, this was a safe assumption. Start
    doing many things at once, however, and this assumption blows apart.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为单个处理器设计的类Unix内核声明内核是非抢占式的，不能被中断。这简化了内核管理，因为一切都变得完全可预测：当内核的一部分分配内存时，它可以指望在执行下一条指令时该内存不会改变。内核的其他部分不会改变那块内存。当计算机一次只能做一件事时，这是一种安全的假设。然而，一旦开始同时做多件事，这个假设就会崩溃。
- en: '***SMP: The First Try***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SMP：第一次尝试***'
- en: The first implementation of SMP support in FreeBSD was very simple minded. Processes
    were scattered between the CPUs, achieving a rough balance, and there was a lock
    on the kernel. Before a CPU would try to run the kernel, it would check to see
    whether the lock was available. If the lock was free, the CPU held the lock and
    ran the kernel. If the lock wasn’t free, the CPU knew that the kernel was being
    run elsewhere and went on to handle something else. This lock was called the *Big
    Giant Lock (BGL)*, or later just *Giant*. Under this system, the kernel could
    know that data wouldn’t change from under it. Essentially, Giant guaranteed that
    the kernel would run on only one CPU, just as it always had.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD中SMP支持的第一次实现非常简单。进程在CPU之间分散，达到粗略的负载平衡，并且内核上有一个锁。在一个CPU尝试运行内核之前，它会检查锁是否可用。如果锁是空闲的，CPU会获得锁并运行内核。如果锁不可用，CPU就知道内核正在其他地方运行，然后继续处理其他任务。这个锁被称为*大锁（BGL）*，或者后来简称为*Giant*。在这种系统下，内核可以确保数据不会被其下方的进程改变。本质上，Giant保证了内核只会在一个CPU上运行，就像它一直以来的工作方式一样。
- en: This strategy worked kind of adequately for two CPUs. You could run a medium-level
    database and a web server on a twin-CPU machine and feel confident that the CPU
    wouldn’t be your bottleneck. If one CPU was busy serving web pages, the other
    would be free to answer database queries. But if you had an eight-CPU machine,
    you were in trouble; the system would spend a lot of time just waiting for Giant
    to become available!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略对两个CPU的情况勉强有效。你可以在一台双CPU机器上运行一个中型数据库和一个Web服务器，并且有信心CPU不会成为瓶颈。如果一个CPU忙于提供网页服务，另一个CPU就可以空闲来处理数据库查询。但如果你有一台八CPU的机器，你就麻烦了；系统会花费大量时间等待Giant变得可用！
- en: This simplistic SMP technique is neither efficient nor scalable. The standard
    textbooks on SMP rarely mention this method because it’s so clunky. Some other
    SMP-handling methods are worse, however. For example, several early versions of
    Microsoft’s server OS dedicated one processor to the user interface and the other
    to everything else. This technique also rarely appears in the textbooks, although
    it does help your mouse appear more responsive.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简化的SMP技术既不高效也不可扩展。标准的SMP教科书很少提到这种方法，因为它非常笨重。然而，其他一些SMP处理方法更糟。例如，微软早期的几个服务器操作系统版本将一个处理器专用于用户界面，另一个处理器用于其他所有任务。这种技术也很少出现在教科书中，尽管它确实能使鼠标更加灵敏。
- en: '***Today’s SMP***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***今天的SMP***'
- en: Once you have a lock on the kernel, though, you can divvy up that lock. FreeBSD
    has fragmented Giant into many smaller locks, and now every part of the kernel
    uses the smallest possible lock to perform its tasks. Initially, the locks were
    implemented on core kernel infrastructure, such as the scheduler (the part of
    the kernel that says which tasks may have which time slices), the network stack,
    the disk I/O stack, and so on. This immediately improved performance because while
    one CPU was scheduling tasks, the other could be processing network traffic. Then,
    locks were pushed lower into the various kernel components. Each part of the network
    stack developed its own lock, then each part of the I/O subsystem, and so on—allowing
    the kernel to use multiple processors to do multiple things simultaneously. These
    separate kernel subprocesses are called *threads*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦你拥有了内核的锁，你就可以将这个锁分割开。FreeBSD已经将Giant锁分解成许多更小的锁，现在内核的每个部分都使用最小的锁来执行任务。最初，这些锁被实现于内核的核心基础设施中，如调度器（内核中负责分配任务时间片的部分）、网络栈、磁盘I/O栈等。这立即提高了性能，因为当一个CPU在调度任务时，另一个可以处理网络流量。随后，锁被推向了更低层次的各个内核组件。网络栈的每个部分开发了自己的锁，I/O子系统的每个部分也都如此——使得内核能够利用多个处理器同时执行多个任务。这些独立的内核子进程被称为*线程*。
- en: Each type of locking has its own requirements. You’ll see references to many
    different locks such as mutexes, sx locks, rw locks, spin mutexes, semaphores,
    read-mostly locks, and more. Each has its own benefits and drawbacks, and each
    must be carefully applied within the kernel.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的锁定都有其独特的要求。你将会看到许多不同的锁，例如互斥锁、sx锁、读写锁、自旋互斥锁、信号量、读多写少锁等等。每种锁都有其优缺点，且每种锁必须在内核中小心使用。
- en: Fine-grained locking is *a lot* harder than it sounds. Lock too finely, and
    the kernel spends more time processing locks than pushing data. Lock too coarsely,
    and the system wastes time waiting for locks to become available. Locking sufficient
    for a 2-processor system stalls and chokes a 32-processor system, and what works
    for the 32-core host is totally inadequate for the new 192-core systems. Lock
    adjustment and tuning has taken years, is still ongoing, and will continue forever.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 精细化锁定比听起来要*难得多*。锁得太细，内核花费更多时间处理锁，而不是推送数据；锁得太粗，系统浪费时间等待锁可用。适用于2处理器系统的锁定会使32处理器系统停滞不前，适用于32核心主机的锁定对新的192核心系统来说完全不够。锁定调整和调优已经花费了数年时间，仍在进行中，并将永远持续下去。
- en: While every part of the kernel uses the smallest lock currently possible, sometimes
    that lock is the Giant lock. Unplugging a USB device means grabbing Giant for
    a fraction of a second as the kernel says, “Hold everything! I’m reconfiguring
    the hardware!” A few device drivers still use Giant, as do certain tricky parts
    of the virtual memory stack, the sysctl handlers, and so on.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管内核的每个部分都使用当前可能的最小锁，但有时那个锁就是Giant锁。拔掉USB设备意味着在短暂的一瞬间抢占Giant锁，内核会说：“暂停一切！我正在重新配置硬件！”一些设备驱动程序仍然使用Giant锁，一些虚拟内存栈中的棘手部分、sysctl处理程序等也使用它。
- en: '**SMP Problems: Deadlocks and Lock Order Reversals**'
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**SMP问题：死锁和锁顺序反转**'
- en: All of these kernel locks have complicated rules for their use, and they interact
    with each other in myriad ways. The rules protect against unexpected lock interactions.
    Suppose that kernel thread A needs resources Y and Z, kernel thread B also needs
    Y and Z, but B needs Z before it needs Y. If A locks Y while B locks Z, then A
    winds up waiting for Z while B waits for Y. Neither thread can proceed until the
    missing resource is freed. This *deadlock* (also called a *deadly embrace*) will
    destabilize the system, probably bringing it down. Proper locking avoids this
    problem, among others.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些内核锁都有复杂的使用规则，它们之间以各种方式相互作用。这些规则是为了防止锁之间发生意外的相互作用。假设内核线程 A 需要资源 Y 和 Z，内核线程
    B 也需要 Y 和 Z，但 B 需要 Z 后才需要 Y。如果 A 锁定了 Y，而 B 锁定了 Z，那么 A 就会等待 Z，而 B 则会等待 Y。两个线程都无法继续，直到丢失的资源被释放。这种*死锁*（也叫*致命的拥抱*）会使系统不稳定，可能导致系统崩溃。正确的锁定方式可以避免这个问题，和其他一些问题。
- en: You might see a console message warning of a *lock order reversal*, meaning
    that locks have been applied out of order. While this kernel notice isn’t always
    an omen of impending doom, it’s important to pay attention.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会看到控制台上出现关于*锁定顺序反转*的警告，意味着锁定顺序错误地应用了。虽然这个内核通知并不总是预示着灾难的来临，但关注它仍然很重要。
- en: The `WITNESS` kernel option specifically watches for locking order and lock
    ordering violations. This option is enabled by default on FreeBSD-current (see
    [Chapter 18](ch18.xhtml#ch18)), and if you report a problem with your system,
    the development team might ask you to enable it. The `WITNESS` option makes the
    kernel inspect every action it takes for locking order violations, which reduces
    system performance. You can enable and disable `WITNESS` with the `debug.witness.watch`
    sysctl. Running `WITNESS`, reading the messages, and acting on them is an excellent
    way to help improve FreeBSD, however.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`WITNESS` 内核选项专门用于监控锁定顺序和锁定顺序违规情况。该选项在 FreeBSD-current 上默认启用（参见[第18章](ch18.xhtml#ch18)），如果您报告系统出现问题，开发团队可能会要求您启用它。`WITNESS`
    选项使内核检查每个操作是否存在锁定顺序违规，这会降低系统性能。不过，运行 `WITNESS`、查看消息并根据消息采取行动，是帮助改进 FreeBSD 的一个极好的方式。'
- en: '**Handling Lock Order Reversals**'
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**处理锁定顺序反转**'
- en: When you get one of these lock order reversal (LOR) messages, copy the LOR message
    in its entirety. In addition to appearing on the console, such messages are logged
    to */var/log/messages* for your convenience. Once you have the lock order message,
    search the FreeBSD-current mailing list for the first few lines of your LOR message
    to see whether someone has already filed it. If you find your LOR on the mailing
    lists, read the message and take the recommended action. There’s no need to post
    a “me too” message on the mailing list unless a developer recently and specifically
    requested notification of further LORs of that type.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当您收到一个锁定顺序反转（LOR）消息时，请完整复制该 LOR 消息。除了显示在控制台上外，这些消息还会记录到 */var/log/messages*
    中，方便您查看。一旦获得锁定顺序消息，请在 FreeBSD-current 邮件列表中搜索 LOR 消息的前几行，看看是否有人已经提交了该问题。如果在邮件列表中找到了您的
    LOR，请阅读消息并采取推荐的行动。如果开发者最近并特意要求通知进一步的此类 LOR，您才需要在邮件列表中发布“我也遇到这个问题”的消息。
- en: If you have a new LOR, congratulations! Discovering a new LOR isn’t as satisfying
    as discovering a new insect species—you don’t get to name your LOR, for one thing—but
    it does help the FreeBSD Project. Email your report to the FreeBSD-current mailing
    list. Provide full details on your system, especially the work being performed
    at the time the LOR appeared. You might be asked to file a bug report, as discussed
    in [Chapter 24](ch24.xhtml#ch24).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到一个新的锁定顺序反转（LOR），恭喜您！发现一个新的 LOR 并不像发现一个新的昆虫物种那样令人满足——首先，您不能给您的 LOR 命名——但它确实有助于
    FreeBSD 项目。请将您的报告发送至 FreeBSD-current 邮件列表。提供有关您的系统的详细信息，特别是在 LOR 出现时所执行的工作。您可能会被要求提交一个
    bug 报告，正如在[第24章](ch24.xhtml#ch24)中讨论的那样。
- en: '***Processors and SMP***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***处理器和 SMP***'
- en: 'You’ll see three different types of multiprocessor systems: multiple cores,
    multiple packages, and hardware threads. You need to understand the differences
    among them, as the different processor types have a direct impact on system and
    application behavior.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到三种不同类型的多处理器系统：多核、多包装和硬件线程。您需要理解它们之间的区别，因为不同的处理器类型会直接影响系统和应用程序的行为。
- en: The basic unit in processors is the *CPU core*. Each CPU core consists of a
    set of resources like execution units, registers, cache, and so on. Once upon
    a time, a core was the same thing as a processor.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器中的基本单位是*CPU核心*。每个CPU核心由一组资源组成，如执行单元、寄存器、缓存等。曾几何时，一个核心就等同于一个处理器。
- en: A CPU *package* is the chip socketed or soldered to your mainboard. It’s what
    many people think of as “a CPU” or “a processor.” That expensive part you can
    accidentally crush underfoot? That’s a package. Each package contains one or more
    cores. Prior to SMP, one package had only one core in it. These days, most packages
    have at least two cores, and the upper number keeps increasing. CPU cores within
    the same package can communicate with each other relatively quickly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: CPU *封装*是插入或焊接到主板上的芯片。它就是许多人所称的“CPU”或“处理器”。那个你可能不小心踩碎的昂贵部件？那就是封装。每个封装包含一个或多个核心。在对称多处理（SMP）之前，一个封装只有一个核心。如今，大多数封装至少包含两个核心，且核心数不断增加。同一封装中的CPU核心可以相互快速通信。
- en: Some hosts have more than one package. Multiple packages give you multiple groups
    of multiple cores, giving you the chance for even more parallelism. Communication
    between packages is slower than communication between cores on the same package.
    Also, each package usually has its own memory controller. CPU cores in one package
    will take longer to retrieve data in memory attached to a different package. Yes,
    this means a 16-core package will perform better than two 8-core packages. In
    reality, though, very little software is so heavily threaded that it can take
    advantage of the difference.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一些主机有多个封装。多个封装为你提供多个包含多个核心的组，从而提供更多的并行性。封装之间的通信比同一封装内核心之间的通信要慢。此外，每个封装通常都有自己的内存控制器。一个封装中的CPU核心从另一个封装获取内存数据会花费更长的时间。是的，这意味着一个16核封装比两个8核封装的性能更好。然而，实际上，很少有软件会被多线程到足以充分利用这种差异。
- en: Lastly some CPU cores can try to make more efficient use of their execution
    resources by being able to run more than one thread at a time. This is referred
    to as *hardware threading*, *Simultaneous Multi-Threading (SMT)* or (if you’re
    Intel) *HyperThreading*. The additional threads are sometimes called virtual processors
    or virtual cores. The virtual processor isn’t a full-fledged CPU, however; for
    example, it’s available only when the first CPU is waiting for something. FreeBSD’s
    default scheduler, sched_ule(4), is aware of which cores are real and which are
    virtual, and schedules work appropriately.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，某些CPU核心通过能够同时运行多个线程来更有效地利用其执行资源。这被称为*硬件线程*、*同时多线程（SMT）*，或（如果你是Intel的话）*超线程（HyperThreading）*。这些额外的线程有时被称为虚拟处理器或虚拟核心。然而，虚拟处理器并不是一个完整的CPU；例如，只有当第一个CPU在等待某些操作时，虚拟处理器才会被激活。FreeBSD的默认调度程序sched_ule(4)能够区分哪些核心是实际核心，哪些是虚拟核心，并适当地调度任务。
- en: Hardware threading presents a variety of potential security problems. A task
    running on one virtual processor can capture data such as cryptographic keys from
    a task running on another virtual processor using a variety of subtle timing attacks.
    It’s not a script-kiddie-friendly attack, but if you don’t trust your users, you
    can disable hardware threads by setting the boot-time tunable `machdep.hyperthreading_allowed`
    to `0`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件线程引发了多种潜在的安全问题。一个虚拟处理器上运行的任务可以通过各种微妙的时间攻击，从另一个虚拟处理器上运行的任务中捕获数据，例如加密密钥。这不是一个适合脚本小子攻击的手段，但如果你不信任用户，可以通过将启动时可调参数`machdep.hyperthreading_allowed`设置为`0`来禁用硬件线程。
- en: '**Using SMP**'
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用SMP**'
- en: Remember that multiple processors don’t necessarily make the system faster.
    One processor can handle a certain number of operations per second. A second processor
    just means that the computer can handle twice as many operations per second, but
    those operations aren’t necessarily any faster.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，多个处理器并不一定让系统更快。一个处理器每秒钟可以处理一定数量的操作。第二个处理器仅意味着计算机每秒钟可以处理两倍的操作量，但这些操作不一定更快。
- en: Think of the number of CPUs as the lanes on a road. If you have one lane, you
    can move one car at a time past any one spot. If you have four lanes, you can
    move four cars past that spot. Although the four-lane road won’t allow those cars
    to reach their destination more quickly, there’ll be a lot more of them arriving
    at any one time. If you think this doesn’t make a difference, contemplate what
    would happen if someone replaced your local freeway with a one-lane road. CPU
    bandwidth is important.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下 CPU 的数量就像道路上的车道。如果你有一条车道，你只能一次让一辆车经过某个地方。如果你有四条车道，你就可以同时让四辆车经过那个地方。虽然四车道的道路不会让这些车更快到达目的地，但它们会有更多的车同时到达。如果你认为这没有区别，可以想想如果有人把你本地的高速公路换成单车道会发生什么。CPU
    的带宽很重要。
- en: While one CPU can do only one thing at a time, one process can run on only one
    CPU at a time. Many programs can’t perform work on multiple processors simultaneously.
    Threaded programs are an exception, as we’ll see later in this chapter. Some programs
    work around this limitation by simultaneously running multiple processes and letting
    the operating system scatter them between processors as needed. The popular Apache
    web server has done this for many years. Threaded programs are specifically designed
    to work with multiple processors without spawning multiple processes. Many threaded
    programs simply create a whole bunch of threads to process data and scatter those
    threads across CPUs, which is a simple, if not always effective, way to handle
    parallelism. Other programs don’t handle multiple CPUs at all.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一个 CPU 一次只能做一件事，但一个进程一次只能在一个 CPU 上运行。许多程序无法在多个处理器上同时执行工作。线程程序是一个例外，正如我们在本章后面将看到的那样。一些程序通过同时运行多个进程，并让操作系统根据需要将它们分配到不同的处理器来绕过这个限制。流行的
    Apache Web 服务器已经这样做了很多年。线程程序是专门设计来与多个处理器一起工作的，而不需要生成多个进程。许多线程程序简单地创建大量线程来处理数据，并将这些线程分散到
    CPU 上，这是一种简单的（虽然并非总是有效的）并行处理方式。其他程序根本不处理多个 CPU。
- en: If you find that one of your CPUs is 100 percent busy while the others are mostly
    idle, you’re running a program that doesn’t handle multiple CPUs in any way. [Chapter
    21](ch21.xhtml#ch21) dives into performance issues, but not much can be done to
    help such a program.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现其中一个 CPU 100% 忙碌，而其他 CPU 大部分时间处于空闲状态，那说明你正在运行一个无法处理多个 CPU 的程序。[第 21 章](ch21.xhtml#ch21)
    将深入探讨性能问题，但对于这种程序，能做的帮助不多。
- en: '**SMP and make(1)**'
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**SMP 和 make(1)**'
- en: The make(1) program, which is used to build software, can start multiple processes.
    If your program is cleanly written, you can use multiple processes to build it.
    This doesn’t help for small programs, but when you’re building a large program,
    such as FreeBSD itself (see [Chapter 18](ch18.xhtml#ch18)) or LibreOffice, using
    multiple processors can really accelerate the work. Use make(1)’s `-j` flag to
    tell the system how many processes to start simultaneously. A good choice is the
    number of processors or cores in the system plus one. For example, on a dual-processor
    system with two cores on each processor, I would run five processes to build a
    program.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 用于构建软件的 make(1) 程序可以启动多个进程。如果你的程序写得很干净，你可以使用多个进程来构建它。这对小程序没有帮助，但当你构建一个大程序时，比如
    FreeBSD 本身（参见 [第 18 章](ch18.xhtml#ch18)）或 LibreOffice，使用多个处理器确实可以加速工作。使用 make(1)
    的 `-j` 标志告诉系统同时启动多少个进程。一个好的选择是系统中处理器或核心的数量加一。例如，在一台双处理器系统中，每个处理器有两个核心，我会运行五个进程来构建一个程序。
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Some programmers don’t design their *Makefiles* correctly, so their programs
    can’t handle being built with the `-j` flag. If a build gives you trouble, stop
    using `-j` and try again—or, better still, figure out the problem and file a bug
    report with the author.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员没有正确设计他们的*Makefile*，因此他们的程序无法处理 `-j` 标志。如果构建出现问题，停止使用 `-j` 再试一次——或者，更好的是，找出问题并向作者提交
    bug 报告。
- en: '**Threads, Threads, and More Threads**'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**线程、线程、还有更多线程**'
- en: One word you’ll hear in various contexts is *thread*. Some CPUs support HyperThreading.
    Some processes have threads. Some parts of the kernel run as threads. My pants
    have many many threads (although some have fewer than my wife thinks necessary
    for those pants to be worn in public). What are all these threads, and what do
    they mean?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在各种上下文中听到一个词——*线程*。一些 CPU 支持超线程（HyperThreading）。一些进程有线程。内核的某些部分作为线程运行。我的裤子上有很多很多的线（虽然有些比我妻子认为那些裤子应该在公共场合穿着所需的线少）。这些线程都是什么，它们意味着什么呢？
- en: In most contexts, a thread is a lightweight process. Remember, a *process* is
    a task on the system, a running program. Processes have their own process ID in
    the system and can be started, stopped, and generally managed by the user. Threads
    are pieces of a process, but they’re managed by the process and can’t be directly
    addressed by the user. A process can do only one thing at a time, but individual
    threads can act independently. If you have a multiprocessor system, one process
    can have threads running on multiple processors simultaneously.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，线程是一个轻量级进程。记住，*进程*是系统中的一个任务，一个正在运行的程序。进程有自己在系统中的进程 ID，并可以由用户启动、停止及管理。线程是进程的一部分，但它们由进程管理，不能直接由用户访问。一个进程一次只能做一件事，但个别线程可以独立执行。如果你有一个多处理器系统，一个进程可以在多个处理器上同时运行线程。
- en: Any threaded program needs to use a *threading library* that tells the application
    how to use threads on that operating system by interacting with the kernel. Threading
    libraries implement threading in different ways, so using particular libraries
    can impact application performance.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 任何多线程程序都需要使用一个 *线程库*，该库通过与内核交互，告诉应用程序如何在该操作系统上使用线程。线程库以不同的方式实现线程，因此使用特定的库可能会影响应用程序的性能。
- en: Similarly, a kernel thread is a subprocess within the kernel. FreeBSD has kernel
    threads that handle I/O, network, and so on. Each thread has its own functions,
    tasks, and locking. The threading within the kernel doesn’t use any userland libraries.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，内核线程是内核中的一个子进程。FreeBSD 有内核线程来处理 I/O、网络等操作。每个线程都有自己的功能、任务和锁定。内核中的线程不使用任何用户空间的库。
- en: 'Hardware threads are virtual CPU cores, as discussed in “["Using Multiple Processors:
    SMP"](ch17.xhtml#lev732) on [page 396](ch17.xhtml#page_396). While you need to
    understand what hardware is and how it impacts your system, hardware threads aren’t
    really part of threading.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件线程是虚拟的 CPU 核心，正如在“[使用多个处理器：SMP](ch17.xhtml#lev732)”的 [第396页](ch17.xhtml#page_396)中所讨论的那样。虽然你需要了解硬件是什么以及它如何影响你的系统，但硬件线程实际上并不属于线程的一部分。
- en: '**Startup and Shutdown Scripts**'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**启动和关闭脚本**'
- en: The service(8) command is a frontend to the system startup and shutdown scripts.
    These scripts are known as *rc scripts* after */etc/rc*, the script that manages
    the multiuser boot and shutdown process. While the main rc scripts are in */etc/rc.d*,
    scripts in other locations manage add-on software. Ports and packages install
    startup scripts, but if you install your own software, you’ll need to create your
    own rc script. If you’ve never used shell scripts before, read carefully. Shell
    scripting isn’t hard, and the best way to learn is by reading examples and making
    your own variations on those examples. Additionally, changing an existing package’s
    startup or shutdown process requires understanding how the startup scripts function.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: service(8) 命令是系统启动和关闭脚本的前端。这些脚本被称为 *rc 脚本*，源自 */etc/rc*，即管理多用户启动和关闭过程的脚本。虽然主要的
    rc 脚本位于 */etc/rc.d*，但其他位置的脚本用于管理附加软件。Ports 和 packages 安装启动脚本，但如果你安装了自己的软件，你需要创建自己的
    rc 脚本。如果你之前没有使用过 shell 脚本，请仔细阅读。Shell 脚本并不难，学习的最好方法是阅读示例并在这些示例的基础上进行变动。此外，修改现有软件包的启动或关闭过程需要理解启动脚本的功能。
- en: During boot and shutdown, FreeBSD checks */usr/local/etc/rc.d* for additional
    shell scripts to be integrated into the startup/shutdown process. (You can define
    additional directories with the `local_startup` *rc.conf* variable, but for now
    we’ll assume that you have only the default directory.) The startup process specifically
    looks for executable shell scripts and assumes that any script it finds is a startup
    script. It executes that script with an argument of `start`. During shutdown,
    FreeBSD runs those same commands with an argument of `stop`. The scripts are expected
    to read those arguments and take appropriate actions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动和关闭过程中，FreeBSD 会检查 */usr/local/etc/rc.d* 目录，寻找额外的 shell 脚本并将其集成到启动/关闭过程中。（你可以使用
    `local_startup` *rc.conf* 变量定义额外的目录，但目前我们假设你只有默认目录。）启动过程会特别查找可执行的 shell 脚本，并假定它找到的任何脚本都是启动脚本。它以
    `start` 参数执行该脚本。在关闭过程中，FreeBSD 以 `stop` 参数运行这些相同的命令。预期这些脚本会读取这些参数并采取适当的行动。
- en: '***rc Script Ordering***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***rc 脚本排序***'
- en: For decades, Unix-like operating system encoded service startup order in the
    startup scripts. That got really annoying, *really* quickly. Many, but not all,
    Unixes have moved on from this. Similarly, FreeBSD’s rc scripts arrange themselves
    in order. Each rc script identifies what resources it needs before it can start.
    The rc system uses that information to sort the scripts into order. This is performed
    by rcorder(8) at boot and at shutdown, but you can do this by hand at any time
    to see how it works. Just give rcorder(8) the paths to your startup scripts as
    arguments.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，类 Unix 操作系统在启动脚本中编码了服务启动顺序。这变得非常烦人，*非常*快。许多（但不是所有）Unix 系统已经摒弃了这种方式。类似地，FreeBSD
    的 rc 脚本按照顺序排列。每个 rc 脚本会标识出在启动之前需要哪些资源。rc 系统利用这些信息对脚本进行排序。这个过程在启动和关闭时由 rcorder(8)
    执行，但你随时可以手动进行，以查看它是如何工作的。只需将 rcorder(8) 路径传递给你的启动脚本作为参数。
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The rcorder(8) program sorts all the scripts in */etc/rc.d* and */usr/local/etc/rc.d*
    into the order used at system boot, using markers within the scripts themselves.
    If your rc scripts have any ordering errors, such as deadlocked scripts, those
    errors appear at the beginning of your rcorder(8) output.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: rcorder(8) 程序将 */etc/rc.d* 和 */usr/local/etc/rc.d* 目录中的所有脚本按系统启动时的顺序排序，使用脚本本身内的标记。如果你的
    rc 脚本有任何排序错误，例如死锁脚本，这些错误会出现在 rcorder(8) 输出的开头。
- en: '***A Typical rc Script***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个典型的 rc 脚本***'
- en: The rc script system is pretty simple—while scripts can get complicated, the
    complexity comes from the program the script runs, not the rc system. The script
    that starts the NFS server has a whole bunch of dependencies and requirements.
    The script for a simpler daemon, like timed(8), illuminates the rc system.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: rc 脚本系统非常简单——虽然脚本本身可以变得复杂，但复杂性来自于脚本所运行的程序，而不是 rc 系统。启动 NFS 服务器的脚本有一堆依赖关系和需求。而像
    timed(8) 这样的简单守护进程的脚本则体现了 rc 系统的简单性。
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `PROVIDE` label ➊ tells rcorder(8) the official name of this script. This
    script is called *timed*, after timed(8).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`PROVIDE` 标签 ➊ 告诉 rcorder(8) 这个脚本的官方名称。这个脚本叫做 *timed*，以 timed(8) 命名。'
- en: The `REQUIRE` label ➋ lists other scripts that must run before this script runs.
    Scripts that need timed to run before they can start list timed in `REQUIRE`.
    This script can run any time after the `DAEMON` script has been run.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`REQUIRE` 标签 ➋ 列出了在此脚本运行之前必须运行的其他脚本。需要在启动前运行 timed 的脚本会在 `REQUIRE` 中列出 timed。此脚本可以在
    `DAEMON` 脚本运行后任何时间运行。'
- en: The `BEFORE` label ➌ lets you specify scripts that should run after this one.
    This script should run before the `LOGIN` script. Both */etc/rc.d/LOGIN* and */etc/rc.d/timed*
    specify that they have to run after `DAEMON`, but the `BEFORE` label lets you
    set additional ordering requirements.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`BEFORE` 标签 ➌ 允许你指定该脚本后应运行的其他脚本。此脚本应在 `LOGIN` 脚本之前运行。*/etc/rc.d/LOGIN* 和 */etc/rc.d/timed*
    都指定它们必须在 `DAEMON` 之后运行，但 `BEFORE` 标签允许你设置额外的排序要求。'
- en: The `KEYWORD` command ➍ lets the startup system select only certain startup
    scripts. The timed(8) script includes `nojail` and `shutdown`. Jails don’t run
    this script, even if enabled. This script gets run at system shutdown.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`KEYWORD` 命令 ➍ 让启动系统只选择某些特定的启动脚本。timed(8) 脚本包括 `nojail` 和 `shutdown`。即使启用，监狱环境也不会运行这个脚本。此脚本在系统关闭时运行。'
- en: The */etc/rc.subr* file ➎ contains the rc script infrastructure. Every rc script
    must include it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/rc.subr* 文件 ➎ 包含了 rc 脚本基础结构。每个 rc 脚本都必须包含它。'
- en: While the script has a name, the program run by the script might have a separate
    name ➏. Most often, though, an rc script officially called *timed* will run the
    program *timed*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然脚本有一个名字，但脚本运行的程序可能有一个独立的名字 ➏。通常情况下，名为 *timed* 的 rc 脚本会运行名为 *timed* 的程序。
- en: The `description` field ➐ provides a brief description of the service the script
    provides, exactly as you’d expect.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`description` 字段 ➐ 提供了该脚本所提供服务的简要描述，正如你所预期的那样。'
- en: The `rcvar` statement ➑ lists the *rc.conf* variable that toggles this script.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`rcvar` 语句 ➑ 列出了切换此脚本的 *rc.conf* 变量。'
- en: The `command` ➒ identifies exactly which command this script should run—after
    all, you might have multiple commands of the same name on your system, just in
    different directories.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`command` ➒ 明确指定了该脚本应运行的命令——毕竟，系统中可能有多个相同名称的命令，只是位于不同的目录中。'
- en: The last two actions the script takes are to load ➓ the configuration for this
    service from */etc/rc.conf* and then actually run the command.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本执行的最后两个操作是从 */etc/rc.conf* 加载该服务的配置 ➓，然后实际运行命令。
- en: 'While this might look intimidating, it’s not really that hard in practice.
    Start your customized rc script by copying an existing one. Set the command name
    to that of your command and change the path appropriately. Decide what the script
    must have run before it: Do you need the network to be running? Do you need particular
    daemons to be started already, or do you need to run your program before certain
    daemons? If you really don’t know, have your script run at the very end by using
    a `REQUIRE` statement with the name of the last script run on your system. By
    looking through other rc scripts that provide similar functions, you’ll learn
    how to do almost anything in a startup script.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来可能有点让人畏惧，但实际上并没有那么难。开始编写你的自定义rc脚本时，可以先复制一个现有的脚本。将命令名称设置为你的命令，并适当地更改路径。确定在运行脚本之前必须完成哪些操作：你需要网络正常运行吗？你需要某些守护进程已经启动，还是需要在某些守护进程之前运行你的程序？如果你实在不确定，可以通过使用`REQUIRE`语句并指定系统上最后运行的脚本的名称，将脚本安排在最后运行。通过查看其他提供类似功能的rc脚本，你将学会如何在启动脚本中做几乎任何事。
- en: With this simple script, you can enable, disable, and configure your program
    by adding information to */etc/rc.conf*. For example, if your custom daemon is
    named `tracker`, the startup script will look for variables `tracker_enable` and
    `tracker_flags` in */etc/rc.conf* and use them each and every time you run the
    startup script.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个简单的脚本，你可以通过将信息添加到*/etc/rc.conf*来启用、禁用和配置你的程序。例如，如果你的自定义守护进程名为`tracker`，启动脚本会在*/etc/rc.conf*中查找变量`tracker_enable`和`tracker_flags`，并在每次运行启动脚本时使用它们。
- en: '***Special rc Script Providers***'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***特殊的rc脚本提供程序***'
- en: You might have noticed the services named *DAEMON* in our example and thought,
    “That’s odd. I don’t know of any system processes called *DAEMON*.” That’s because
    it’s not a process. The rc system has a few special providers that define major
    points in the boot process. Use these to make writing rc scripts easier.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到我们示例中有名为*DAEMON*的服务，并且可能会想：“这很奇怪，我不知道有什么叫*DAEMON*的系统进程。”其实那并不是一个进程。rc系统有一些特殊的提供程序，用于定义启动过程中的重要节点。使用这些提供程序可以简化编写rc脚本的过程。
- en: The FILESYSTEMS provider guarantees you that all local filesystems are mounted
    as defined in */etc/fstab*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: FILESYSTEMS提供程序确保所有本地文件系统都已按*/etc/fstab*中的定义挂载。
- en: The NETWORKING provider appears after all network functions are configured.
    This includes setting IP addresses on network interfaces, PF configuration, and
    so on.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 网络提供程序在所有网络功能配置完成后出现。这包括在网络接口上设置IP地址、PF配置等。
- en: The SERVERS provider means that the system has enough basic functionality to
    support basic servers, such as named(8) and the NFS support programs. Remote filesystems
    aren’t mounted yet.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: SERVERS提供程序表示系统已经具备了支持基本服务器所需的基本功能，如named(8)和NFS支持程序。但此时远程文件系统尚未挂载。
- en: The DAEMON provider ensures all local and remote filesystems are mounted, including
    NFS and CIFS, and that more advanced network functions, such as DNS, are operational.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程提供程序确保所有本地和远程文件系统都已挂载，包括NFS和CIFS，并确保更高级的网络功能，如DNS，已正常运行。
- en: At LOGIN, all network system services are running and FreeBSD is beginning to
    start up services to support logins via the console, FTP daemons, SSH, and so
    forth.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在登录时，所有网络系统服务已启动，FreeBSD开始启动支持通过控制台、FTP守护进程、SSH等进行登录的服务。
- en: By using one of these providers in a `REQUIRE` statement in your custom rc script,
    you can specify roughly when you want your custom program to run without going
    too far into nitty-gritty details.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在自定义rc脚本中的`REQUIRE`语句中使用这些提供程序，你可以大致指定何时希望你的自定义程序运行，而无需深入细节。
- en: '***Vendor Startup/Shutdown Scripts***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***供应商启动/关机脚本***'
- en: Perhaps you’re installing a complicated piece of software, and the vendor doesn’t
    support FreeBSD’s rc system. This isn’t a problem. Most vendor-supplied scripts
    expect to get a single argument, such as `start` or `stop`. Remember that at boot
    time, FreeBSD runs each rc script with an argument of `start`, and at system shutdown,
    it runs the scripts with an argument of `stop`. By adding `PROVIDE` and `REQUIRE`
    statements as comments to this vendor script and confirming that it accepts those
    arguments, you can make the script run at the proper time in the startup and shutdown
    process.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你正在安装一个复杂的软件包，而供应商并不支持FreeBSD的rc系统。这不是问题。大多数供应商提供的脚本预计会接收一个参数，如`start`或`stop`。记住，在启动时，FreeBSD会以`start`作为参数运行每个rc脚本，而在系统关机时，它会以`stop`作为参数运行脚本。通过将`PROVIDE`和`REQUIRE`语句作为注释添加到此供应商脚本中，并确认它接受这些参数，你可以确保脚本在启动和关机过程中在正确的时机运行。
- en: Use of the rc system features in management scripts isn’t mandatory. At the
    tail end of the boot process, FreeBSD runs */etc/rc.local*. Add your local commands
    there. You can’t use service(8) to manage anything in *rc.local*, however.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理脚本中使用 rc 系统功能不是强制性的。在启动过程的最后，FreeBSD 会运行 */etc/rc.local*。你可以在这里添加本地命令。然而，你不能使用
    service(8) 来管理 *rc.local* 中的任何内容。
- en: '***Debugging Custom rc Scripts***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***调试自定义 rc 脚本***'
- en: Local scripts, such as those installed by the Ports Collection, are run by */etc/rc.d/localpkg*.
    If your custom script is causing problems, you might try running the `localpkg`
    script with debugging to see how your script is interacting with the rc system.
    The best way to do this is to use debugging.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本地脚本，例如通过 Ports Collection 安装的脚本，是由 */etc/rc.d/localpkg* 运行的。如果你的自定义脚本引发了问题，你可以尝试通过调试运行
    `localpkg` 脚本，查看你的脚本如何与 rc 系统交互。最好的做法是使用调试功能。
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This attempts to start every local daemon on your server again, which might
    not be desirable on a production system. Try it on a test system first. Also,
    remember that the `-x` debugging flag isn’t passed on to the child scripts; you’re
    debugging the system startup script */etc/rc.d/localpkg* itself, not the local
    scripts. Run your script with the `-x` flag to debug it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这会尝试重新启动服务器上的每个本地守护进程，这在生产系统中可能并不合适。建议先在测试系统上尝试。另外，记住 `-x` 调试标志不会传递给子脚本；你正在调试的是系统启动脚本
    */etc/rc.d/localpkg* 本身，而不是本地脚本。运行脚本时请使用 `-x` 标志进行调试。
- en: '**Managing Shared Libraries**'
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**管理共享库**'
- en: A shared library is a chunk of compiled code that provides common functions
    to other compiled code. Shared libraries are designed to be reused by as many
    different programs as possible. For example, many programs must generate *hashes*,
    or cryptographic checksums, on pieces of data. If every program had to include
    its own hashing code, programs would be harder to write and more unpleasant to
    maintain. What’s more, programs would have interoperability problems if they implemented
    hashes slightly differently, and program authors would need to learn an awful
    lot about hashes to use them. By using a shared library (in this example, `libcrypt`),
    the program can access hash generation functions without any compatibility and
    maintenance problems. This reduces the average program size, both on disk and
    in memory, at a cost in complexity.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库是提供公共功能给其他已编译代码的已编译代码块。共享库的设计目的是尽可能被多个不同的程序重复使用。例如，许多程序必须为数据生成 *哈希* 或加密校验和。如果每个程序都需要包含自己的哈希代码，程序将更难编写，并且更不容易维护。而且，如果程序实现的哈希略有不同，它们之间将会出现互操作性问题，程序作者也需要学会大量关于哈希的知识才能使用它们。通过使用共享库（在这个例子中是
    `libcrypt`），程序可以访问哈希生成函数，而没有兼容性和维护问题。这减小了程序的平均大小，无论是在磁盘上还是在内存中，代价是复杂性增加。
- en: '***Shared Library Versions and Files***'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***共享库版本和文件***'
- en: Shared libraries have a human-friendly name, a version number, and an associated
    file. The human-friendly name is usually (but not always) similar to the associated
    file. For example, version 1 of the shared library called *libjail* is in the
    file */lib/libjail.so.1*. On the other hand, version 11 of the main Kerberos library
    is in the file */usr/lib/libkrb5.so.11*. Version numbering starts at 0.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库有一个人类友好的名称、一个版本号和一个相关联的文件。人类友好的名称通常（但不总是）与相关文件相似。例如，版本 1 的共享库 *libjail* 存放在文件
    */lib/libjail.so.1* 中。另一方面，主 Kerberos 库的版本 11 存放在文件 */usr/lib/libkrb5.so.11* 中。版本编号从
    0 开始。
- en: Historically, when changes to the library made it incompatible with earlier
    versions of the library, the version number was incremented. For example, libjail.so.0
    became libjail.so.1\. The FreeBSD team doesn’t bump these versions except at the
    beginning of a release cycle (see [Chapter 18](ch18.xhtml#ch18)). Each library
    also has a symlink for the library name without a version, pointing to the latest
    version of the library. For example, you’ll find that */usr/lib/libwres.so* is
    actually a symlink pointing to */usr/lib/libwres.so.10*. This makes compiling
    software much easier, as the software has to look only for the general library
    file rather than a specific version of that library.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，当库的更改使其与早期版本的库不兼容时，版本号会递增。例如，libjail.so.0 变成了 libjail.so.1。FreeBSD 团队只有在发布周期开始时才会增加这些版本号（参见
    [第 18 章](ch18.xhtml#ch18)）。每个库也有一个不带版本号的库名称的符号链接，指向该库的最新版本。例如，你会发现 */usr/lib/libwres.so*
    实际上是一个符号链接，指向 */usr/lib/libwres.so.10*。这使得编译软件变得更容易，因为软件只需要查找一般的库文件，而不是该库的特定版本。
- en: FreeBSD’s main libraries support *symbol versioning*, which lets shared libraries
    support multiple programming interfaces. With symbol versioning, a shared library
    provides every program with the version of the library the program requires. If
    you have a program that requires version 2 of a library, version 3 will support
    the functions just as well.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 的主要库支持 *符号版本控制*，这使得共享库可以支持多个编程接口。通过符号版本控制，共享库会为每个程序提供该程序所需的库版本。如果你有一个程序需要版本
    2 的库，版本 3 也能支持这些功能。
- en: Just because FreeBSD supports symbol versioning doesn’t mean that all the software
    in the Ports Collection supports it. You must be alert for library version problems.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为 FreeBSD 支持符号版本控制，并不意味着 Ports Collection 中的所有软件都支持它。你必须留意库版本问题。
- en: '***Attaching Shared Libraries to Programs***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将共享库附加到程序中***'
- en: So, how does a program get the shared libraries it needs? FreeBSD uses ldconfig(8)
    and rtld(1) to provide shared libraries as needed but also offers a few human-friendly
    tools for you to adjust and manage shared library handling.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，程序是如何获取所需的共享库的呢？FreeBSD 使用 ldconfig(8) 和 rtld(1) 根据需要提供共享库，但也提供了一些人性化的工具，供你调整和管理共享库的处理。
- en: The rtld(1) is perhaps the simplest program to understand, at least from a sysadmin’s
    perspective. Whenever a program starts, rtld(8) checks to see what shared libraries
    the program needs. The rtld(8) program searches the library directories to see
    whether those libraries are available and then links the libraries with the program
    so everything works. You can’t do very much at all with rtld(1) directly, but
    it provides the vital glue that holds shared libraries together.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: rtld(1) 也许是最容易理解的程序，至少从系统管理员的角度来看。每当程序启动时，rtld(8) 会检查程序需要哪些共享库。rtld(8) 程序会搜索库目录，查看这些库是否可用，然后将库与程序链接在一起，确保一切正常工作。你不能直接用
    rtld(1) 做太多事情，但它提供了将共享库连接在一起的关键“粘合剂”。
- en: '**The Library Directory List: ldconfig(8)**'
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**库目录列表：ldconfig(8)**'
- en: Instead of searching the entire hard drive for anything that looks like a shared
    library every time any dynamically linked program is run, the system maintains
    a list of shared library directories with ldconfig(8). (Older versions of FreeBSD
    built a cache of actual libraries on a system, but modern versions just keep a
    list of directories to check for shared libraries.) If a program can’t find shared
    libraries that you know are on your system, this means ldconfig(8) doesn’t know
    about the directory where those shared libraries live.^([1](footnote.xhtml#ch17fn1))
    To see the libraries currently found by ldconfig(8), run `ldconfig -r`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 系统不会在每次运行动态链接的程序时都在整个硬盘上搜索任何看起来像共享库的文件，而是通过 ldconfig(8) 维护一个共享库目录列表。(FreeBSD
    的旧版本会构建一个系统中实际库的缓存，但现代版本只保持一个检查共享库的目录列表。) 如果程序找不到你知道系统中有的共享库，这意味着 ldconfig(8)
    并不知道这些共享库所在的目录。^([1](footnote.xhtml#ch17fn1)) 若要查看当前 ldconfig(8) 能找到的库，可以运行 `ldconfig
    -r`。
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With the `-r` flag, ldconfig(8) lists every shared library in the shared library
    directories. We first see the list of directories searched and then the individual
    libraries in those directories. My main mail server has 170 shared libraries;
    my main web server, 244; my desktop, 531.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-r` 标志，ldconfig(8) 会列出所有共享库目录中的共享库。我们首先看到被搜索的目录列表，然后是这些目录中的各个库。我的主邮件服务器有
    170 个共享库；我的主网页服务器有 244 个；我的桌面有 531 个。
- en: If a program dies at startup with a complaint that it can’t find a shared library,
    that library won’t be on this list. Your problem then amounts to installing the
    desired library into a shared library directory or adding the library directory
    to the list of directories searched. You could just copy every shared library
    you need to */usr/lib*, but this makes system management very difficult—much like
    with a filing cabinet where everything is filed under *P* for *paper*. Adding
    directories to the shared library list is a better idea in the medium to long
    term.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序在启动时因找不到共享库而崩溃，那么该库就不会出现在这个列表中。你的问题就是需要将所需的库安装到共享库目录中，或者将库目录添加到被搜索的目录列表中。你可以将每个需要的共享库复制到
    */usr/lib* 中，但这会使得系统管理变得非常困难——就像是文件柜中所有东西都归到 *P* 类别下（即 *纸张*）。在中长期内，添加目录到共享库列表中会是更好的选择。
- en: '**Adding Library Directories to the Search List**'
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将库目录添加到搜索列表中**'
- en: 'If you’ve added a new directory of shared libraries, you must add it to the
    list ldconfig(8) searches. Check these ldconfig(8) entries in */etc/defaults/rc.conf*:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你添加了一个新的共享库目录，必须将它添加到ldconfig(8)搜索的列表中。检查*/etc/defaults/rc.conf*中的这些ldconfig(8)条目：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `ldconfig_paths` variable lists common locations for libraries. While out-of-the-box
    FreeBSD doesn’t have the directory */usr/local/lib*, most systems grow one shortly
    after install. Similarly, libraries for compatibility with older versions of FreeBSD
    go in */usr/lib/compat*. The location for storing old versions of libraries installed
    by packages is */usr/local/lib/compat/pkg*. The */lib* and */usr/lib* directories
    get searched by default, but the paths in this variable are common locations for
    shared libraries.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldconfig_paths`变量列出了常见的库位置。虽然开箱即用的FreeBSD没有*/usr/local/lib*目录，但大多数系统在安装后不久会创建一个类似目录。类似地，兼容旧版本FreeBSD的库会放入*/usr/lib/compat*。由软件包安装的旧版本库会存放在*/usr/local/lib/compat/pkg*目录。*/lib*和*/usr/lib*目录是默认被搜索的，但这个变量中的路径是共享库的常见位置。'
- en: Ports and packages use the `ldconfig_local_dirs` variable to get their shared
    libraries into the search list without just dumping everything into */usr/local/lib*.
    Packages can install a file in this directory. The file is named after the package
    and contains a list of directories with the libraries installed by the package.
    The ldconfig program checks these directories for files, reads the paths in the
    files, and treats those as additional library paths. For example, the Perl 5 package
    installs shared libraries in */usr/local/lib/perl5/5.24/mach/CORE*. The port also
    installs a file called */usr/local/libdata/ldconfig/perl5*, containing only a
    single line with this path in it. The ldconfig startup script adds the directories
    in these files to its list of places to check for shared libraries.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 端口和软件包使用`ldconfig_local_dirs`变量，将它们的共享库添加到搜索列表中，而不只是把所有东西都丢进*/usr/local/lib*。软件包可以在这个目录中安装一个文件。这个文件以软件包的名字命名，并包含一个列出软件包安装的库目录的列表。ldconfig程序会检查这些目录中的文件，读取文件中的路径，并将这些路径视为额外的库路径。例如，Perl
    5软件包将共享库安装在*/usr/local/lib/perl5/5.24/mach/CORE*中。这个端口还会安装一个名为*/usr/local/libdata/ldconfig/perl5*的文件，里面只有一行内容，列出了这个路径。ldconfig启动脚本会将这些文件中的目录添加到它检查共享库的目录列表中。
- en: '**/USR/LOCAL/LIB VS. PER-PORT LIBRARY DIRECTORIES**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**/USR/LOCAL/LIB与每个端口的库目录**'
- en: Isn’t */usr/local/lib* specifically for libraries installed by ports and packages?
    Why not just put all your shared libraries into that directory? Most ports do
    exactly that, but sometimes having a separate directory makes maintenance simpler.
    For example, I have Python 2.7 installed on my laptop, and */usr/local/lib/python27*
    includes 647 files! Dumping all those into */usr/local/lib* would overwhelm my
    non-Python libraries and make it harder for me to find the files installed by
    ports with only one or two shared libraries.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*/usr/local/lib*不是专门用于由端口和软件包安装的库吗？为什么不把所有共享库都放进那个目录呢？大多数端口正是这么做的，但有时使用单独的目录可以简化维护。例如，我在我的笔记本上安装了Python
    2.7，而*/usr/local/lib/python27*中包含了647个文件！如果把所有这些文件都放到*/usr/local/lib*中，就会压倒我非Python库的文件，并且让我更难找到由端口安装的只有一两个共享库的文件。'
- en: To get your directory of shared libraries into the search list, either add it
    to the ldconfig_paths in */etc/rc.conf* or create a file listing your directory
    in */usr/local/libdata/ldconfig*. Either works. Once you add the directory, the
    libraries in that directory are immediately available.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要将你的共享库目录添加到搜索列表中，可以将它添加到*/etc/rc.conf*中的ldconfig_paths，或者在*/usr/local/libdata/ldconfig*中创建一个列出该目录的文件。两种方法都可以。一旦添加了该目录，该目录中的库将立即可用。
- en: '**ldconfig(8) and Weird Libraries**'
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**ldconfig(8)与奇怪的库**'
- en: Shared libraries have a couple of edge cases that you should understand and
    many more that you really don’t have to worry about. These include libraries for
    different binary types and libraries for other architectures.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库有一些边缘情况你应该理解，还有许多你实际上不必担心的情况。这些情况包括针对不同二进制类型的库和针对其他架构的库。
- en: FreeBSD supports two different formats of binaries, a.out and ELF. System administrators
    don’t need to know the details of these binary types, but you should know that
    ELF binaries are the modern standard and became FreeBSD’s standard in version
    3.0, back in 1998\. Older versions of FreeBSD used a.out. Programs compiled as
    one type can’t use shared libraries of the other type. While a.out binaries have
    largely vanished, the cost of supporting them is so low that this support has
    never been removed. ldconfig(8) maintains separate directory lists for a.out and
    ELF binaries, as you can see from the output of */etc/rc.d/ldconfig*. You’ll find
    separate configuration options for ldconfig(8) with a.out libraries in *rc.conf*.
    It’s barely conceivable that you’ll need an a.out program.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 支持两种不同格式的二进制文件，a.out 和 ELF。系统管理员不需要了解这些二进制类型的详细信息，但你应该知道，ELF 二进制文件是现代标准，并且在
    1998 年的版本 3.0 中成为了 FreeBSD 的标准。早期版本的 FreeBSD 使用的是 a.out。以某种类型编译的程序无法使用另一种类型的共享库。虽然
    a.out 二进制文件已经基本消失，但由于支持它们的成本非常低，因此这个支持从未被移除。ldconfig(8) 为 a.out 和 ELF 二进制文件维护了独立的目录列表，正如你从
    */etc/rc.d/ldconfig* 的输出中所看到的那样。你会在 *rc.conf* 中找到单独配置 ldconfig(8) 使用 a.out 库的选项。几乎可以说，你不会需要使用
    a.out 程序。
- en: Another odd case is when you’re running 32-bit binaries on a 64-bit FreeBSD
    install. This is most common when you’re running the amd64 install and want to
    use a program from an older version of FreeBSD. 64-bit binaries cannot use 32-bit
    libraries, so ldconfig(8) keeps a separate directory list for them. You’ll find
    options to configure those directories in *rc.conf* as well. Don’t mix your 32-bit
    and 64-bit libraries!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个特殊情况是当你在 64 位 FreeBSD 安装上运行 32 位二进制文件时。最常见的情况是你在运行 amd64 安装并且希望使用来自旧版本 FreeBSD
    的程序时。64 位二进制文件无法使用 32 位库，因此 ldconfig(8) 为它们保持了一个单独的目录列表。你也可以在 *rc.conf* 中找到配置这些目录的选项。不要混合使用
    32 位和 64 位库！
- en: A few hardware platforms, such as ARM, have special versions of libraries for
    soft floating-point operations. You’ll find *rc.conf* options for those as well,
    pointing to a third set of directories.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一些硬件平台，如 ARM，拥有针对软浮点运算的特殊版本库。你也可以在 *rc.conf* 中找到这些选项，指向一组新的目录。
- en: In short, don’t mix unusual libraries with the standard libraries. The results
    will confuse FreeBSD, which will in turn upset you.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，不要将不常用的库与标准库混合使用。这样做会让 FreeBSD 混淆，从而让你感到困扰。
- en: '***LD_LIBRARY_PATH and LD_PRELOAD***'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***LD_LIBRARY_PATH 和 LD_PRELOAD***'
- en: While FreeBSD’s built-in shared library configuration system works well if you’re
    the sysadmin, it won’t work if you’re just a lowly user without root access.^([2](footnote.xhtml#ch17fn2))
    Also, if you have your own personal shared libraries, you probably don’t want
    them to be globally available. Sysadmins certainly won’t want to take the risk
    of production programs linking against random user-owned libraries! Here’s where
    `LD_LIBRARY_PATH` comes in.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 FreeBSD 内建的共享库配置系统在你是系统管理员时工作得很好，但如果你只是一个没有 root 权限的普通用户，它就无法工作了。^([2](footnote.xhtml#ch17fn2))
    此外，如果你有自己的个人共享库，你可能不希望它们被全局访问。系统管理员当然也不希望在生产程序中链接随机的用户拥有的库！这时 `LD_LIBRARY_PATH`
    就派上用场了。
- en: 'Every time rtld(1) runs, it checks the environment variable `LD_LIBRARY_PATH`.
    If this variable has directories in it, it checks these directories for shared
    libraries. Any libraries in these directories are included as options for the
    program. You can specify any number of directories in `LD_LIBRARY_PATH`. For example,
    if I want to do some testing and use libraries in */home/mwlucas/lib* and */tmp/testlibs*
    for my next run of a program, I’d just set the variable like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行 rtld(1) 时，它会检查环境变量 `LD_LIBRARY_PATH`。如果该变量包含目录，它会检查这些目录中的共享库。这些目录中的任何库都会作为程序的选项被包括进去。你可以在
    `LD_LIBRARY_PATH` 中指定任意数量的目录。例如，如果我想做一些测试并且在接下来的程序运行中使用 */home/mwlucas/lib* 和
    */tmp/testlibs* 里的库，我只需这样设置该变量：
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can set this automatically at login by entering the proper command in *.cshrc*
    or *.login*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 *.cshrc* 或 *.login* 中输入正确的命令，在登录时自动设置这个环境变量。
- en: Similarly, the `LD_PRELOAD` environment variable lets you load a particular
    library first. You have test your custom libc by giving the full path to it in
    `LD_PRELOAD`. When rtld(1) runs, it takes the library from `LD_PRELOAD` and ignores
    later libraries that offer the same symbols.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`LD_PRELOAD` 环境变量允许你先加载特定的库。你可以通过在 `LD_PRELOAD` 中指定完整路径来测试自定义的 libc。当 rtld(1)
    运行时，它会从 `LD_PRELOAD` 中获取库，并忽略后续提供相同符号的库。
- en: '**LD_ ENVIRONMENT VARIABLES AND SECURITY**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**LD_ 环境变量与安全性**'
- en: Using `LD_LIBRARY_PATH` or `LD_PRELOAD` is not secure. If you point this variable
    to an overly accessible directory, your program might link against whatever anyone
    put in there. The `LD_LIBRARY_PATH` variable overrides the shared library directory
    list, so if someone can put arbitrary files in your library directory, they can
    take over your program. For this reason, setuid and setgid programs ignore these
    variables.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `LD_LIBRARY_PATH` 或 `LD_PRELOAD` 并不安全。如果你将此变量指向一个过于开放的目录，你的程序可能会链接到任何人放入该目录的内容。`LD_LIBRARY_PATH`
    变量会覆盖共享库目录列表，因此，如果有人能够在你的库目录中放入任意文件，他们就能接管你的程序。出于这个原因，`setuid` 和 `setgid` 程序会忽略这些变量。
- en: '***What a Program Wants***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***程序需要什么***'
- en: 'Lastly, there’s the question of what libraries a program requires to run correctly.
    Get this information with ldd(1). For example, to discover what libraries Emacs
    needs, enter this command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于程序正确运行所需的库的问题。通过 `ldd(1)` 获取这些信息。例如，要了解 Emacs 需要哪些库，可以输入以下命令：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This output tells us the names of the shared libraries Emacs requires and the
    locations of the files that contain those libraries. If your program can’t find
    a necessary library, ldd(1) tells you so. The program itself announces the name
    of the first missing shared library when you try to run it, but ldd(1) gives you
    the complete list so that you can use a search engine to find all missing libraries.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出告诉我们 Emacs 所需的共享库的名称以及包含这些库的文件的位置。如果你的程序找不到所需的库，`ldd(1)` 会告诉你。程序本身在你尝试运行时会宣布第一个缺失的共享库的名称，但
    `ldd(1)` 会给你完整的列表，这样你可以使用搜索引擎查找所有缺失的库。
- en: Between ldconfig(8) and ldd(1), you should be fully prepared to manage shared
    libraries on your FreeBSD system.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ldconfig(8)` 和 `ldd(1)` 之间，你应该充分准备好在你的 FreeBSD 系统上管理共享库。
- en: '**Remapping Shared Libraries**'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**重新映射共享库**'
- en: Occasionally, you’ll find a piece of software that you want to run with particular
    shared libraries not used by the rest of the system. For example, FreeBSD’s standard
    C library is libc. You could have a second copy of libc with special functions
    provided just for a particular program, and you could make only that program use
    the special libc while using the standard libc for everything else. FreeBSD allows
    you to change any shared library any application gets. This sounds weird, but
    it’s terribly useful in all sorts of edge cases. Developers use this feature to
    test code on a small scale before pushing it out to their whole system. Use */etc/libmap.conf*
    and files in */usr/local/etc/libmap.d/* to tell rtld(1) to lie to client programs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，你会发现有一款软件需要使用特定的共享库，而这些库并不被系统的其他部分使用。例如，FreeBSD 的标准 C 库是 libc。你可以有一个带有特定功能的
    libc 副本，只为某个特定程序提供，然后你可以只让那个程序使用这个特殊的 libc，同时其他程序使用标准的 libc。FreeBSD 允许你更改任何应用程序使用的共享库。这听起来有些奇怪，但在各种边缘情况下非常有用。开发者使用这个功能在将代码推送到整个系统之前进行小规模的测试。使用
    */etc/libmap.conf* 和 */usr/local/etc/libmap.d/* 中的文件来告诉 `rtld(1)` 对客户端程序撒谎。
- en: 'While *libmap.conf* entries are useful for developing software, you can also
    use them to globally replace libraries. Some video card drivers installed via
    package require you use their driver rather than certain system libraries. A few
    Nvidia drivers want to provide libGL graphics functions. Don’t overwrite the libGL
    package that everything depends on: instead, remap that library. You can configure
    library substitution for the whole system, for individual program names, or for
    the program at a specific full path.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 *libmap.conf* 条目对于软件开发非常有用，但你也可以用它们来全局替换库。一些通过包安装的视频卡驱动程序需要你使用它们的驱动程序，而不是某些系统库。少数
    Nvidia 驱动程序希望提供 libGL 图形功能。不要覆盖所有程序依赖的 libGL 包：相反，重新映射这个库。你可以为整个系统、特定程序名称或特定完整路径下的程序配置库替换。
- en: 'A libmap file (either *libmap.conf* or a file in */usr/local/etc/libmap.d/*)
    has two columns. The first column is the name of the shared library a program
    requests; the second is the shared library to provide instead. All changes take
    place the next time the program is executed; no reboot or daemon restart is required.
    For example, here we tell the system, whenever any program requests libGL, to
    offer it the Nvidia version of the library instead. These global overrides must
    appear first in *libmap.conf* :'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 libmap 文件（可以是 *libmap.conf* 或 */usr/local/etc/libmap.d/* 中的文件）有两列。第一列是程序请求的共享库的名称；第二列是提供的共享库。所有更改将在下次执行程序时生效；不需要重新启动或重启守护进程。例如，在这里，我们告诉系统，每当任何程序请求
    libGL 时，应该提供 Nvidia 版本的库。这些全局覆盖必须首先出现在 *libmap.conf* 中：
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: “May I have libGL.so.1?”
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: “我可以获得 libGL.so.1 吗？”
- en: “Certainly, here’s libGL-NVIDIA.so.1.”
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: “当然，这是libGL-NVIDIA.so.1。”
- en: 'Globally remapping libraries is a rather bold step that might get you talked
    about by other sysadmins, but remapping libraries on a program-by-program basis
    is much less ambitious and more likely to solve more problems than it creates.
    Simply specify the desired program in square brackets before the remapping statements.
    If you specify the program by its full path, the remap will work only if you call
    the program by its full path. If you give only the name, the remap will work whenever
    you run any program of that name. For example, here we remap emacs(1) so that
    it uses Nvidia’s library instead of the system library when called by its full
    path:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 全局重新映射库是一个相当大胆的步骤，可能会引起其他系统管理员的讨论，但逐个程序地重新映射库则不那么雄心勃勃，更有可能解决更多问题，而不是制造问题。只需在重新映射语句之前指定所需的程序名并放入方括号。如果你通过完整路径指定程序，映射仅在通过完整路径调用程序时有效。如果你只提供名称，当你运行任何该名称的程序时，映射都会生效。例如，在这里我们重新映射emacs(1)，使其在通过完整路径调用时使用Nvidia的库，而不是系统库：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'How can you prove this worked? Well, check ldd(1):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如何证明这成功了呢？好吧，检查一下ldd(1)：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can see that when */usr/local/bin/emacs* requests libGL.so.1, rtld(1) attaches
    it to libGL-NVIDIA.so.1 instead. We specified the full path to the Emacs binary,
    however, so we need to call the program by its full path. Try to use ldd(1) on
    Emacs without calling it by its full path:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，当*/usr/local/bin/emacs*请求libGL.so.1时，rtld(1)会将其附加到libGL-NVIDIA.so.1上。我们指定了Emacs二进制文件的完整路径，因此我们需要通过完整路径调用该程序。尝试在没有完整路径调用的情况下对Emacs使用ldd(1)：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By going to */usr/local/bin* and running ldd(1) directly on Emacs without having
    to specify the full path, rtld doesn’t see the full path to the emacs(1) binary.
    */etc/libmap.conf* says to use Nvidia’s library only for the full path of */usr/local/bin/emacs*.
    When plain naked `emacs` requests libGL.so.1, it gets what it asked for.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进入*/usr/local/bin*并直接对Emacs运行ldd(1)，而无需指定完整路径，rtld无法看到emacs(1)二进制文件的完整路径。*/etc/libmap.conf*表示只在*/usr/local/bin/emacs*的完整路径下使用Nvidia的库。当裸露的`emacs`请求libGL.so.1时，它得到了它请求的内容。
- en: 'If you want to have a program use the alternate library no matter whether it’s
    called by full path or base name, just give the program name in square brackets
    rather than the full name:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望程序无论是通过完整路径还是基本名称调用，都使用替代库，只需在方括号中给出程序名称，而不是完整名称：
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Similarly, you can choose an alternate library for all of the programs in a
    directory by listing the directory name followed by a trailing slash. In this
    */usr/local/etc/libmap.d/oracle* file, we force all programs in a directory to
    use an alternate library:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你也可以通过列出目录名并在后面加上斜杠，选择一个替代库来应用于目录中的所有程序。在这个*/usr/local/etc/libmap.d/oracle*文件中，我们强制目录中的所有程序使用替代库：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using *libmap.conf* lets you arbitrarily remap shared libraries. Developers
    use this feature to test code. Ports use this to override libraries for certain
    programs. You’ll find a use for it too.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*libmap.conf*允许你任意重新映射共享库。开发人员使用此功能来测试代码。端口使用它来为某些程序覆盖库。你也会找到它的用处。
- en: '**Running Software from the Wrong OS**'
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在错误的操作系统上运行软件**'
- en: Traditional software is written for a particular OS and runs only on that OS.
    Many people built healthy businesses changing software so that it would run on
    another system, a process called *porting*. As an administrator, you have a few
    different ways to use software written for a platform other than FreeBSD. The
    most effective is to recompile the source code to run natively on FreeBSD. If
    this isn’t possible, you can run nonnative software under an emulator, such as
    Wine, or by reimplementing the application binary interface (ABI) of the software’s
    native platform.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的软件是为特定操作系统编写的，只能在该操作系统上运行。许多人通过改变软件使其能够在另一个系统上运行，从而建立了成功的商业，这一过程称为*移植*。作为管理员，你有几种不同的方式使用为其他平台（非FreeBSD）编写的软件。最有效的方法是重新编译源代码，使其能够在FreeBSD上本地运行。如果这不可行，你可以通过模拟器（如Wine）运行非本地软件，或者通过重新实现软件本地平台的应用程序二进制接口（ABI）来运行。
- en: '***Recompilation***'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重新编译***'
- en: Many FreeBSD packages are actually ports of software originally designed for
    other platforms. (That’s why it’s called the *Ports* Collection.) Software written
    for Linux, Solaris, or other Unix-like operating systems can frequently be recompiled
    from source code with little or no modification and run flawlessly on FreeBSD.
    By simply taking the source code and building it on a FreeBSD machine, you can
    run foreign software natively on FreeBSD.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 FreeBSD 包实际上是其他平台上原本设计的软件的移植版。（这就是为什么它被称为*Ports*集合的原因。）为 Linux、Solaris 或其他类
    Unix 操作系统编写的软件，通常可以通过少量或不做修改直接从源代码重新编译并在 FreeBSD 上无缝运行。只需将源代码取出并在 FreeBSD 机器上构建，就可以原生运行外部软件。
- en: Recompiling works best when the platforms are similar. Unix-like platforms should
    be fairly similar, no? FreeBSD and Linux, for example, provide many similar system
    functions; both are built on the standard C functions, both use similar tools,
    both use the GCC compiler, and so on. Over the years, though, the various Unix-like
    operating systems have diverged. Each version of Unix has implemented new features,
    new libraries, and new functions, and if a piece of software requires those functions,
    it won’t build on other platforms. The POSIX standard was introduced, in part,
    to alleviate this problem. POSIX defines the minimal acceptable Unix and Unix-like
    operating systems. Software written using only POSIX-compliant system calls and
    libraries should be immediately portable to any other POSIX-compliant operating
    system, and most Unix vendors comply with POSIX. The problem is ensuring that
    developers comply with POSIX. Many open source developers care only about having
    their software run on their preferred platform. Much Linux-specific software is
    not only not POSIX-compliant but also contains a bunch of unique functions commonly
    called *Linuxisms*. And POSIX-only code doesn’t take advantage of any special
    features offered by the operating system.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编译在平台相似时效果最佳。类 Unix 平台应该是相当相似的，不是吗？例如，FreeBSD 和 Linux 提供了许多相似的系统功能；它们都建立在标准
    C 函数之上，都使用类似的工具，都使用 GCC 编译器，等等。然而，多年来，各种类 Unix 操作系统已经发生了分歧。每个版本的 Unix 都实现了新特性、新库和新函数，如果某个软件依赖这些特性，它就无法在其他平台上构建。POSIX
    标准部分是为了解决这个问题而提出的。POSIX 定义了最基本的类 Unix 操作系统标准。仅使用符合 POSIX 的系统调用和库编写的软件，应该可以立即移植到任何其他符合
    POSIX 的操作系统上，而且大多数类 Unix 操作系统厂商都遵循 POSIX。问题在于如何确保开发者遵守 POSIX。许多开源开发者只关心他们的软件是否能在自己偏好的平台上运行。很多特定于
    Linux 的软件不仅不符合 POSIX 标准，还包含一堆独特的功能，通常被称为*Linuxisms*。而仅遵循 POSIX 的代码则无法利用操作系统提供的任何特殊功能。
- en: In all fairness, FreeBSD also has FreeBSDisms, such as the hyperefficient data-reading
    system call kqueue(2). Other Unix-like operating systems use select(2) and poll(2)
    instead or implement their own system calls. Application developers ask themselves
    whether they should use kqueue(2), which would make their software blindingly
    fast on FreeBSD but useless everywhere else, or they should use select(2) and
    poll(2) to allow their software to work everywhere, albeit more slowly. The developer
    can invest more time and support kqueue(2), select(2), poll(2), and any other
    OS-specific variant equally, but while this pleases users, it rather sucks from
    the developer’s perspective.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，FreeBSD 也有一些 FreeBSD 特有的特性，比如超高效的数据读取系统调用 kqueue(2)。其他类 Unix 操作系统则使用 select(2)
    和 poll(2)，或者实现自己的系统调用。应用程序开发者会问自己，是否应该使用 kqueue(2)，这样他们的软件在 FreeBSD 上会非常快速，但在其他地方则毫无用处；还是应该使用
    select(2) 和 poll(2)，让他们的软件能够在所有地方运行，尽管速度较慢。开发者可以投入更多时间，支持 kqueue(2)、select(2)、poll(2)
    和其他操作系统特定的变种，但尽管这样会让用户高兴，从开发者的角度来看却相当糟糕。
- en: FreeBSD takes a middle road. If a piece of software can be recompiled to run
    properly on FreeBSD, the ports team generally makes it happen. If the software
    needs minor patches, the ports team includes the patches with the port and sends
    them to the software developer as well. Most software developers gladly accept
    patches that would allow them to support another operating system. Even though
    they might not have that OS available to test, or they might not be familiar with
    the OS, a decent-looking patch from a reputable source is usually accepted.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 采取了一种折中的方式。如果某个软件可以重新编译以在 FreeBSD 上正常运行，端口团队通常会让它实现。如果该软件需要小的补丁，端口团队会将这些补丁与端口一起包含，并将它们发送给软件开发者。大多数软件开发者都会愉快地接受补丁，从而使他们的软件支持另一个操作系统。即使他们可能没有该操作系统可用于测试，或者他们可能对该操作系统不熟悉，只要补丁来自可靠的来源，并且看起来不错，通常都会被接受。
- en: '***Emulation***'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***仿真***'
- en: If software would require extensive redesign to work on FreeBSD, or if the source
    code is simply unavailable, we can try emulation. An *emulator* translates system
    and library calls for one operating system into the equivalent calls provided
    by the local operating system, so programs running under the emulator think they’re
    running on their native system. Translating all these calls creates additional
    system overhead, however, which impacts the program’s speed and performance.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果软件需要大量重新设计才能在 FreeBSD 上运行，或者如果源代码根本不可用，我们可以尝试仿真。一个 *仿真器* 会将一个操作系统的系统调用和库调用转换为本地操作系统提供的等效调用，从而使在仿真器下运行的程序认为它们正在本地系统上运行。然而，转换所有这些调用会增加额外的系统开销，影响程序的速度和性能。
- en: 'FreeBSD supports a wide variety of emulators, most of which are in the Ports
    Collection under */usr/ports/emulators*. In most cases, emulators are useful for
    education or entertainment. If you have an old Commodore 64 game that you’ve had
    an itch to play again, install */usr/ports/emulators/frodo*. (Be warned: Mounting
    that C64 floppy on a modern FreeBSD system will teach you more about disks than
    humanity was meant to know.) There’s a Nintendo GameCube emulator in */usr/ports/emulators/dolphin-emu*,
    a PDP-11 emulator in */usr/ports/emulators/simh*, and so on.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 支持多种仿真器，其中大多数在 Ports 集合中位于 */usr/ports/emulators* 下。在大多数情况下，仿真器用于教育或娱乐。如果你有一款老旧的
    Commodore 64 游戏，想再玩一次，可以安装 */usr/ports/emulators/frodo*。（警告：在现代 FreeBSD 系统上挂载
    C64 磁盘会让你比人类本应知道的更多了解磁盘。）在 */usr/ports/emulators/dolphin-emu* 下有一个 Nintendo GameCube
    仿真器，在 */usr/ports/emulators/simh* 下有一个 PDP-11 仿真器，等等。
- en: Emulators, though way cool, aren’t really useful for servers, so we won’t cover
    them in any depth.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然仿真器非常酷，但对于服务器来说并没有太大用处，因此我们不会深入讲解它们。
- en: '***ABI Reimplementation***'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***ABI 重新实现***'
- en: 'In addition to recompiling and emulating, the final option for running foreign
    programs is the one FreeBSD is best known for: *application binary interface (ABI)
    reimplementation*. The ABI is the part of the kernel that provides services to
    programs, including everything from managing sound cards to reading files to printing
    on the screen to starting other programs. As far as programs are concerned, the
    ABI is the operating system. By completely implementing the ABI of a different
    operating system on your native operating system and providing the userland libraries
    used by that operating system, you can run nonnative programs as if they were
    on the native platform.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 除了重新编译和仿真，运行外部程序的最后一种选择是 FreeBSD 最为人熟知的：*应用程序二进制接口（ABI）重新实现*。ABI 是内核提供给程序的服务部分，包括从管理声卡到读取文件、打印到屏幕、启动其他程序的所有操作。就程序而言，ABI
    就是操作系统。通过在本地操作系统上完全实现另一个操作系统的 ABI 并提供该操作系统所使用的用户空间库，你可以像在本地平台上一样运行非本地程序。
- en: While ABI reimplementation is frequently referred to as emulation, it isn’t.
    When implementing ABIs, FreeBSD isn’t emulating the system calls but rather providing
    native implementations for the application. No program runs to translate the system
    calls to their FreeBSD equivalents, and there’s no effort to translate userland
    libraries into FreeBSD ones. By the same token, it would be incorrect to say,
    “FreeBSD implements Linux.” When this technique was created, there was no one
    word to describe it, and even today there isn’t really a good description. You
    can say that FreeBSD implements the Linux system call interface and includes support
    for directing a binary to the appropriate system call interface, but that’s quite
    a mouthful. You’ll most often hear it referred to as a *mode*, as in “Linux mode.”
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 ABI 重新实现通常被称为仿真，但它并不是仿真。当实现 ABI 时，FreeBSD 并不是在仿真系统调用，而是为应用程序提供本地实现。没有程序会将系统调用转换为
    FreeBSD 等价的调用，也没有努力将用户空间库转换为 FreeBSD 库。同样，称“FreeBSD 实现了 Linux”也是不正确的。创建这个技术时，没有一个词可以完全描述它，直到今天也没有一个特别合适的描述方式。你可以说
    FreeBSD 实现了 Linux 系统调用接口，并且支持将二进制文件指向适当的系统调用接口，但这实在是有点冗长。你通常会听到它被称为 *模式*，比如说“Linux
    模式”。
- en: The problem with ABI reimplementation is overlap. Many operating systems include
    system calls with generic names, such as read, write, and so on. FreeBSD’s read(2)
    system call behaves very differently from Microsoft’s read() system call. When
    a program uses the read() call, how can FreeBSD know which version it wants? You
    can give your system calls different names, but then you’re violating POSIX and
    confusing the program. FreeBSD works around this by providing multiple ABIs and
    controlling which ABI a program uses through *branding*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ABI 重实现的问题是重叠。许多操作系统都包含具有通用名称的系统调用，例如 read、write 等。FreeBSD 的 read(2) 系统调用与 Microsoft
    的 read() 系统调用行为非常不同。当程序使用 read() 调用时，FreeBSD 如何知道它需要哪个版本呢？你可以给你的系统调用不同的名称，但那样会违反
    POSIX 并且混淆程序。FreeBSD 通过提供多个 ABI 并通过 *品牌化* 来控制程序使用哪个 ABI，从而解决了这个问题。
- en: '***Binary Branding***'
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***二进制品牌化***'
- en: Operating systems generally have a system function that executes programs. When
    the kernel sends a program to this execution engine, it runs the program.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统通常具有一个执行程序的系统功能。当内核将程序发送到这个执行引擎时，它会运行该程序。
- en: 'Decades ago, the BSD (Unix at the time) program execution system call was changed
    to include a special check for programs that began with `#!/bin/sh` and to run
    them with the system shell instead of the execution engine. BSD took this idea
    to its logical extreme: its execution engine includes a list of different binary
    types. Each program’s binary type directs it to the correct ABI. Thus, a FreeBSD
    system can implement multiple ABIs, keep them separate, and support programs from
    a variety of different operating systems.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年前，BSD（当时的 Unix）程序执行系统调用被更改为包括对以 `#!/bin/sh` 开头的程序进行特殊检查，并用系统 shell 运行它们，而不是执行引擎。BSD
    将这个想法推向了极限：其执行引擎包括一个不同二进制类型的列表。每个程序的二进制类型指向正确的 ABI。因此，FreeBSD 系统可以实现多个 ABI，保持它们的独立性，并支持来自不同操作系统的程序。
- en: The nifty thing about this system is that there’s minuscule overhead. As FreeBSD
    must decide how to run the program anyway, why not have it decide what ABI to
    use? After all, binaries for different operating systems all have slightly different
    characteristics, which FreeBSD can use to identify them. FreeBSD just makes this
    process transparent to the end user. A binary’s identification is called its *branding*.
    FreeBSD binaries are branded *FreeBSD*, while binaries from other operating systems
    are branded appropriately.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统的妙处在于它的开销极小。因为 FreeBSD 无论如何都必须决定如何运行程序，那为什么不让它决定使用哪个 ABI 呢？毕竟，不同操作系统的二进制文件都有略微不同的特征，FreeBSD
    可以利用这些特征来识别它们。FreeBSD 只是让这一过程对最终用户透明。二进制文件的识别称为 *品牌化*。FreeBSD 的二进制文件标记为 *FreeBSD*，而其他操作系统的二进制文件则适当品牌化。
- en: '***Supported ABIs***'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***支持的 ABI***'
- en: As a result of this ABI redirection, FreeBSD can run Linux binaries as if they
    were compiled natively. Older versions of FreeBSD could also run OSF/1, SCO, and
    SVR4 binaries, but the demand for these platforms has dramatically decreased.^([3](footnote.xhtml#ch17fn3))
    If you need one of these, you might try running an older version of FreeBSD on
    a virtual machine.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种 ABI 重定向，FreeBSD 可以像本地编译一样运行 Linux 二进制文件。旧版本的 FreeBSD 也可以运行 OSF/1、SCO 和
    SVR4 二进制文件，但这些平台的需求已经显著减少。^([3](footnote.xhtml#ch17fn3)) 如果你需要其中的某个，你可以尝试在虚拟机上运行旧版本的
    FreeBSD。
- en: Linux mode, also known as the *Linuxulator*, is quite thorough because Linux’s
    source code is available and its ABI is well documented. In fact, Linux mode works
    so well that many programs in the Ports Collection rely on it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 模式，也叫 *Linuxulator*，非常全面，因为 Linux 的源代码是开放的，且其 ABI 有良好的文档。事实上，Linux 模式工作得如此顺利，以至于
    Ports Collection 中的许多程序都依赖于它。
- en: '***Installing and Configuring the Linuxulator***'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安装和配置 Linuxulator***'
- en: While ABI reimplementation solves one major issue, programs require more than
    just the ABI. Without shared libraries, supporting programs, and the rest of the
    userland, most programs won’t run properly. No matter which ABI you use, you must
    have access to the userland for that platform.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 ABI 重实现解决了一个主要问题，但程序不仅仅需要 ABI。没有共享库、支持程序和其余的用户空间，大多数程序无法正常运行。无论你使用哪个 ABI，你必须能够访问该平台的用户空间。
- en: If you want to use a piece of Linux software available in the Ports Collection,
    install the port. That automatically installs any userland dependencies.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用 Ports Collection 中可用的 Linux 软件，安装该端口。这将自动安装任何用户空间的依赖项。
- en: If you’re looking to run an arbitrary piece of Linux software, you must install
    a Linux userland first. FreeBSD usually has a couple different Linux userlands
    available as packages. To see what’s available, search the package database for
    linux_base.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想运行某个任意的 Linux 软件，你必须先安装一个 Linux 用户空间。FreeBSD 通常会提供几种不同的 Linux 用户空间作为包。要查看有哪些可用的包，可以在包数据库中搜索
    linux_base。
- en: '[PRE14]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This version of FreeBSD has two Linux userlands: one based on CentOS 6.9 and
    one based on CentOS 7.3\. The Linux distribution might change in the future, depending
    on Linux’s direction.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的 FreeBSD 有两个 Linux 用户空间：一个基于 CentOS 6.9，另一个基于 CentOS 7.3。Linux 发行版可能会随着
    Linux 方向的变化而发生变化。
- en: Check to see what versions of Linux your software runs on. Install the most
    appropriate userland for your application. FreeBSD installs Linux userlands under
    */usr/compat/linux*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 检查你的软件运行在哪些版本的 Linux 上。为你的应用安装最合适的用户空间。FreeBSD 将 Linux 用户空间安装在 */usr/compat/linux*
    下。
- en: 'The port also loads the Linux mode kernel module. To load that module automatically
    at boot, use this *rc.conf* entry:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 该端口还会加载 Linux 模式内核模块。要在启动时自动加载该模块，可以使用以下 *rc.conf* 条目：
- en: '[PRE15]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That’s it! Linux mode isn’t a proper service, as you can’t restart it or get
    the status, so you can’t configure it with service(8). Run `/etc/rc.d/abi start`
    to activate Linux mode without rebooting.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！Linux 模式不是一个正式的服务，因为你无法重启它或获取状态，因此不能用 service(8) 来配置它。运行 `/etc/rc.d/abi
    start` 可以在不重启的情况下激活 Linux 模式。
- en: Before we dive into running a Linux program, let’s explore the userland a bit.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解如何运行 Linux 程序之前，先来探索一下用户空间。
- en: '**The Linuxulator Userland**'
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Linux 用户空间**'
- en: 'Just as the *linux.ko* kernel module provides the Linux ABI, the Linuxulator
    requires a very minimal Linux userland. Take a look under */usr/compat/linux*
    and you’ll see something much like the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 *linux.ko* 内核模块提供 Linux ABI 一样，Linuxulator 需要一个非常精简的 Linux 用户空间。看看 */usr/compat/linux*
    目录，你会看到类似下面的内容：
- en: '[PRE16]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Looks a lot like the contents of FreeBSD’s */* directory, doesn’t it? If you
    poke around a bit, you’ll find that, generally speaking, the contents of */usr/compat/linux*
    are comparable to your core FreeBSD installation. You’ll find many of the same
    programs in both.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很像 FreeBSD 的 */* 目录的内容，不是吗？如果你多探查一下，你会发现，通常情况下，*/usr/compat/linux* 中的内容与核心
    FreeBSD 安装中的内容相当。你会在两者中找到许多相同的程序。
- en: One thing Linux devotees immediately notice about any linux_base port is that
    its contents are minimal compared to a typical Linux install. That’s because each
    Linux-based package installs only what it requires to run. FreeBSD’s Linux packages
    impose the minimalist BSD philosophy on Linux software.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 爱好者立刻会注意到任何 linux_base 端口的一个特点，那就是它的内容比典型的 Linux 安装要精简。这是因为每个基于 Linux
    的包只安装它运行所需的内容。FreeBSD 的 Linux 包将极简的 BSD 哲学强加到 Linux 软件中。
- en: Whenever possible, programs in Linux mode try to stay under */usr/compat/linux*,
    which is somewhat like a weak jail (see [Chapter 22](ch22.xhtml#ch22)). When you
    execute a Linux binary that calls other programs, the Linux ABI first checks for
    the program under */usr/compat/linux*. If the program doesn’t exist there, Linux
    mode looks in the main system. For example, suppose you have a Linux binary that
    calls ping(8). The ABI first searches under */usr/compat/linux/* for a ping program;
    as of this writing, it’ll find none. The ABI then checks the main FreeBSD system,
    finds */sbin/ping*, and uses it. The Linuxulator makes heavy use of this fallback
    behavior to reduce the size of the Linux mode’s userland.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每当可能时，Linux 模式下的程序会尽量保持在 */usr/compat/linux* 目录下，这有点像一个弱监狱（参见 [第 22 章](ch22.xhtml#ch22)）。当你执行一个调用其他程序的
    Linux 二进制程序时，Linux ABI 会首先在 */usr/compat/linux* 下查找该程序。如果程序在那里不存在，Linux 模式会在主系统中查找。例如，假设你有一个调用
    ping(8) 的 Linux 二进制程序。ABI 首先会在 */usr/compat/linux/* 下查找 ping 程序；截至本文撰写时，它不会找到任何内容。然后，ABI
    会检查主 FreeBSD 系统，找到 */sbin/ping*，并使用它。Linuxulator 在很大程度上利用了这种回退机制来减少 Linux 模式用户空间的大小。
- en: Alternatively, suppose a Linux binary wants to call sh(1). The Linux ABI checks
    under */usr/compat/linux*, finds */usr/compat/linux/bin/sh*, and executes that
    program instead of the FreeBSD native */bin/sh*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，假设一个 Linux 二进制程序想调用 sh(1)。Linux ABI 会在 */usr/compat/linux* 下查找，找到 */usr/compat/linux/bin/sh*，并执行该程序，而不是
    FreeBSD 原生的 */bin/sh*。
- en: '**linprocfs and tmpfs**'
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**linprocfs 和 tmpfs**'
- en: Linux uses a process filesystem, or *procfs*. FreeBSD eliminated procfs as a
    default decades ago as a security risk, but some Linux programs will require it.
    Using Linux software that requires procfs means accepting the inherent risks.
    FreeBSD makes a Linux procfs available as linprocfs(5).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Linux使用一个进程文件系统，或*procfs*。FreeBSD几十年前就将procfs作为默认设置移除，因为它存在安全风险，但一些Linux程序仍然需要它。使用需要procfs的Linux软件意味着接受固有的风险。FreeBSD提供了一个作为linprocfs(5)的Linux
    procfs。
- en: 'To enable linprocfs(5), add the following to */etc/fstab* after installing
    the Linuxulator:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用linprocfs(5)，在安装Linuxulator后，将以下内容添加到*/etc/fstab*中：
- en: '[PRE17]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: FreeBSD loads filesystem kernel modules on demand, so enter `mount` `/compat``/li``nux/proc`
    to activate linprocfs(5) without rebooting.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD根据需要加载文件系统内核模块，因此请输入`mount` `/compat``/li``nux/proc`来激活linprocfs(5)而无需重启。
- en: Many Linux programs also expect */dev/shm* for shared memory. FreeBSD can emulate
    this with tmpfs(5).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Linux程序还期望*/dev/shm*用于共享内存。FreeBSD可以通过tmpfs(5)模拟这一点。
- en: '[PRE18]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Enter `mount /compat/linux/dev/shm`, and the shared memory device is ready.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`mount /compat/linux/dev/shm`，共享内存设备就绪。
- en: '**Testing Linux Mode**'
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**测试Linux模式**'
- en: 'Now that you have some idea what’s installed in Linux mode, testing Linux functionality
    is easy. Run the Linux shell and ask it what operating system it’s running on:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对Linux模式下安装的内容有了大致了解，测试Linux功能变得容易了。运行Linux shell并询问它正在运行哪个操作系统：
- en: '[PRE19]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When we ask what type of system this command prompt is running on, this shell
    responds that it’s a Linux system running on top of a Linux 2.6.32 kernel called
    *FreeBSD*. Pretty cool, eh?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们询问这个命令提示符运行的是什么类型的系统时，这个shell回答它是一个在Linux 2.6.32内核之上运行的Linux系统，叫做*FreeBSD*。很酷吧？
- en: Remember, however, that Linux mode isn’t a complete Linux userland. You can’t
    cross-compile software in the default Linuxulator install. You can perform only
    very basic tasks.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 但是请记住，Linux模式并不是一个完整的Linux用户空间。在默认的Linuxulator安装中，您无法交叉编译软件。您只能执行非常基础的任务。
- en: '**Identifying and Setting Brands**'
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**识别和设置品牌**'
- en: Branding software binaries is easier than branding cattle, but not nearly as
    adventurous. Most modern Unix-like binaries are in ELF format, which includes
    space for a comment. That’s where the brand lives. FreeBSD assigns each program
    an ABI by the brand on that binary. If a binary has no brand, it’s assumed to
    be a FreeBSD binary.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为软件二进制文件打上品牌要比给牲畜打上品牌容易，但没有那么冒险。大多数现代类Unix二进制文件都采用ELF格式，其中包括一个注释空间。品牌就存在于这里。FreeBSD通过该二进制文件上的品牌为每个程序分配一个ABI。如果二进制文件没有品牌，则假定它是FreeBSD二进制文件。
- en: 'View and change brands with brandelf(1):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用brandelf(1)查看和更改品牌：
- en: '[PRE20]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'No surprise there. This is a FreeBSD binary, so it’ll be executed under the
    FreeBSD ABI. Let’s try a Linux binary:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不令人惊讶。这是一个FreeBSD二进制文件，因此它将在FreeBSD ABI下执行。让我们尝试一个Linux二进制文件：
- en: '[PRE21]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: See the brands FreeBSD supports with the `-l` flag.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-l`标志查看FreeBSD支持的品牌。
- en: '[PRE22]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you have a foreign program that won’t run, check its branding. If it isn’t
    branded or is branded incorrectly, you’ve probably discovered your problem: FreeBSD
    is trying to run the program under the native FreeBSD ABI. Change this by setting
    the brand manually with `brandelf -t`. For example, to brand a program Linux,
    do this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个无法运行的外部程序，请检查其品牌。如果没有品牌或品牌错误，您可能已经发现了问题所在：FreeBSD试图在原生FreeBSD ABI下运行该程序。通过`brandelf
    -t`手动设置品牌来解决此问题。例如，要将程序标记为Linux，可以执行以下操作：
- en: '[PRE23]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The next time you try to run the program, FreeBSD will run it under the Linux
    ABI and the Linux userland, and the program should work as expected.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 下次尝试运行该程序时，FreeBSD将在Linux ABI和Linux用户空间下运行它，程序应该按预期工作。
- en: You can also use sysctls to set a *fallback brand*. All FreeBSD binaries get
    branded properly, but random programs you copy to your host might not be. Unbranded
    binaries get treated with the chosen fallback brand. The sysctl `kern.elf32.fallback_brand`
    gives a fallback brand for 32-bit hosts, while `kern.elf64.fallback_brand` sets
    the fallback brand for 64-bit hosts. This sysctl takes the brand’s numerical identifier,
    which for Linux is 3.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用sysctl设置*回退品牌*。所有FreeBSD二进制文件都会被正确地标记，但您复制到主机的随机程序可能不会。未标记品牌的二进制文件将被视为所选回退品牌。sysctl
    `kern.elf32.fallback_brand`为32位主机设置回退品牌，而`kern.elf64.fallback_brand`则为64位主机设置回退品牌。此sysctl采用品牌的数字标识符，对于Linux来说是3。
- en: '[PRE24]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You should now be able to run Linux programs without any further configuration.
    All that’s left are the minor annoyances and peccadilloes of Linux mode. Sadly,
    there’s a few of those, as we’ll illustrate next.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够运行Linux程序，而无需进一步配置。剩下的只是Linux模式中的一些小烦恼和瑕疵。可惜的是，正如我们接下来所示的那样，这些问题确实存在。
- en: '**Using Linux Mode**'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用Linux模式**'
- en: Many Linux programs are available only as ports. The Ports Collection is smart
    enough to realize that a piece of software needs Linux mode and chooses the appropriate
    pieces of Linux to install. One popular choice is Skype. Installing this port
    triggers installation of the proper Linux userland.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Linux 程序仅作为端口提供。Ports Collection 足够智能，可以识别出某个软件需要 Linux 模式，并选择合适的 Linux 组件进行安装。一个受欢迎的选择是
    Skype。安装这个端口时，会触发正确的 Linux 用户空间安装。
- en: The downside of having a minimal Linux userland is that any port will have a
    whole bunch of dependencies. Some of those will be FreeBSD binaries, others Linux.
    I recommend using the port’s `make missing` command to display missing dependencies,
    or even to auto-install dependencies from packages as discussed in [Chapter 16](ch16.xhtml#ch16).
    Once all the required packages are installed, once you have linprocfs and the
    Linux shared memory device installed, and once all the kernel modules are loaded,
    installing Skype is as easy as `make install clean`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个最小化的 Linux 用户空间的缺点是，任何端口都会有一堆依赖项。其中一些是 FreeBSD 二进制文件，其他是 Linux 文件。我建议使用端口的
    `make missing` 命令来显示缺少的依赖项，甚至像 [第 16 章](ch16.xhtml#ch16) 讨论的那样，自动从软件包中安装依赖项。一旦安装了所有所需的软件包，安装了
    linprocfs 和 Linux 共享内存设备，并加载了所有内核模块，安装 Skype 就像执行 `make install clean` 一样简单。
- en: '***Debugging Linux Mode***'
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***调试 Linux 模式***'
- en: Linux mode isn’t Linux, and nowhere is this clearer than when a program breaks.
    Many programs have cryptic error messages, and Linux mode can obscure them further.
    You need tools that can dig past the error messages and see what’s really going
    wrong.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 模式并不是 Linux，尤其在程序崩溃时，这一点尤为明显。许多程序都有晦涩的错误信息，而 Linux 模式可能会进一步掩盖这些信息。你需要一些工具，能够深入挖掘错误信息，看到真正的问题所在。
- en: '**Linux Mode and truss(1)**'
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Linux 模式与 truss(1)**'
- en: The best tool I’ve ever found for debugging Linux mode is truss(1), the FreeBSD
    system call tracer. Some people have told me that using truss(1) for this is like
    putting the 12-cylinder engine from a Mack truck into a Volkswagen Beetle, but
    after much thought and careful consideration, I’ve decided that I don’t care.
    It works. Once you learn about truss(1), you’ll wonder how you ever lived without
    it.^([4](footnote.xhtml#ch17fn4))
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现用于调试 Linux 模式的最佳工具是 truss(1)，即 FreeBSD 系统调用追踪器。有些人告诉我，用 truss(1) 来做这件事就像把一台
    Mack 卡车的 12 缸发动机装进一辆大众 Beetle 汽车里，但经过深思熟虑，我决定我不在乎。它有效。一旦你了解了 truss(1)，你会想知道你是怎么在没有它的情况下生活的。^([4](footnote.xhtml#ch17fn4))
- en: The truss(1) program identifies exactly which system calls a program makes and
    the results of each call. Remember, system calls are a program’s interface to
    the kernel. When a program tries to talk to the network, open a file, or even
    allocate memory, it makes a system call. This makes truss(1) an excellent way
    to see why a program is failing. Programs make a lot of system calls, which means
    that truss(1) generates a huge amount of data, making debugging with truss(1)
    a good candidate for script(1).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: truss(1) 程序可以准确识别程序进行的系统调用以及每个调用的结果。记住，系统调用是程序与内核的接口。当程序试图访问网络、打开文件，甚至分配内存时，它会发出系统调用。这使得
    truss(1) 成为查看程序为何失败的一个极好的工具。程序会发出大量的系统调用，这意味着 truss(1) 会生成大量数据，因此用 truss(1) 调试非常适合使用
    script(1) 来记录。
- en: So let’s run Skype.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们启动 Skype。
- en: '[PRE25]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here’s the good news: The program runs! The bad news is, it chokes on something.
    The most common errors I find are missing libraries, files, and directories, but
    which is it? The output of truss(1) can tell me. Start a script(1) session, run
    the program under truss(1), and end the script.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是：程序可以运行！坏消息是，它在某个地方卡住了。我最常遇到的错误是缺少库、文件和目录，但具体是哪一个呢？truss(1) 的输出可以告诉我。启动一个
    script(1) 会话，在 truss(1) 下运行程序，并结束 script。
- en: 'Your script file will be hundreds or thousands of lines long; how can you possibly
    find the problem? Search for a relevant part of your error message or for the
    string ERR. In this case, I searched for the string `directory` and found this
    near the end of the output:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你的脚本文件可能会有几百行或几千行；你怎么可能找到问题呢？搜索相关的错误信息或字符串 ERR。在这个例子中，我搜索了字符串 `directory`，并在输出的末尾找到了如下内容：
- en: '[PRE26]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Aha! Skype can’t find needed libraries. The package maintainer might have missed
    these, or perhaps I’ve screwed up somehow. Check to see whether the libraries
    exist on your host. If not, you’ll need to install them. Perhaps a port exists.
    Or I might need to install the Linux package.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！Skype 找不到所需的库。软件包维护者可能遗漏了这些库，或者可能是我某个地方搞错了。检查一下你的主机上是否有这些库。如果没有，你需要安装它们。也许有可用的端口，或者我可能需要安装
    Linux 软件包。
- en: '**Installing Linux Packages**'
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**安装 Linux 软件包**'
- en: 'If a port doesn’t exist for the Linux libraries or software you need, you have
    a couple choices. One is to create a port for that software. Ports are a great
    way to be involved with the FreeBSD community. If your goal is to get the software
    up and running so you can get on with your day, however, you’ll need to install
    the appropriate Linux software from the source RPM. Be warned, though: once you
    install something outside of the Ports Collection, you’ll need to maintain it
    by hand.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要的 Linux 库或软件没有端口，你有几种选择。一种是为该软件创建一个端口。端口是参与 FreeBSD 社区的好方法。然而，如果你的目标是让软件运行起来并继续完成你的工作，那么你需要从源
    RPM 安装适当的 Linux 软件。不过要注意，一旦你安装了 Ports 集合以外的软件，你就需要手动维护它。
- en: Find the RPM for the software you want. Be sure that the package version matches
    that installed in linux_base. It’s no good to find a CentOS 8 package for your
    missing libraries if your FreeBSD host uses CentOS 7.3.1611\. Download the RPM.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 查找你需要的软件的 RPM。确保包的版本与安装在 linux_base 中的版本匹配。如果你的 FreeBSD 主机使用的是 CentOS 7.3.1611，而你找到了适用于
    CentOS 8 的缺失库包，那就没用。下载 RPM 文件。
- en: '**COMMERCIAL LINUX SOFTWARE AND LINUX MODE**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**商业 Linux 软件和 Linux 模式**'
- en: Remember, commercial software vendors don’t support their Linux software in
    FreeBSD’s Linux mode. If you’re in an industrial environment with service-level
    agreements and run the risk of paying penalties, think very carefully before using
    Linux mode. The main benefit of commercial software is having someone to blame
    when it breaks, but FreeBSD’s Linux mode eliminates that benefit.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，商业软件供应商不会在 FreeBSD 的 Linux 模式下支持其 Linux 软件。如果你身处有服务级别协议的工业环境，并且存在可能需要支付罚款的风险，在使用
    Linux 模式之前请三思。商业软件的主要优势是当软件出现故障时，可以找人负责，但 FreeBSD 的 Linux 模式消除了这一优势。
- en: Suppose my life has taken a horrible turn^([5](footnote.xhtml#ch17fn5)) and
    I need to run Supermin in Linux mode. I find and download the package file, and
    then I install it with tar(1). FreeBSD’s libarchive-based tar can crack open RPM
    files as well as it does everything else.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我的生活发生了可怕的转折^([5](footnote.xhtml#ch17fn5))，我需要在 Linux 模式下运行 Supermin。我找到并下载了包文件，然后使用
    tar(1) 安装它。FreeBSD 基于 libarchive 的 tar 可以像处理其他任何文件一样打开 RPM 文件。
- en: '[PRE27]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now I get to find the next missing dependencies. Once I have the whole list
    of dependencies, I’ll write a port to save others this tedium.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我得去找下一个缺失的依赖项。一旦我拥有了完整的依赖项列表，我将写一个端口，以节省其他人这份繁琐的工作。
- en: '**Running Software from the Wrong Architecture or Release**'
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运行来自错误架构或版本的软件**'
- en: When you run FreeBSD’s amd64 platform, you’ll eventually find some piece of
    software that’s available only for i386 platforms. If your kernel has the `COMPAT_FREEBSD32`
    option (already in GENERIC), FreeBSD/amd64 can run all FreeBSD/i386 software.
    What you can’t do is use FreeBSD/amd64 shared libraries for FreeBSD/i386 software.
    If you want to run a complicated 32-bit program on a 64-bit computer, you must
    provide 32-bit versions of the necessary libraries. This is well supported; if
    you check *rc.conf*, you’ll find the ldconfig(8)’s options `ldconfig32_paths`
    and `ldconfig_local32_dirs`. These options are specifically for telling your amd64
    system where to find 32-bit libraries. FreeBSD includes 32-bit libraries on the
    installation media.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 FreeBSD 的 amd64 平台时，最终会遇到一些只提供给 i386 平台的软件。如果你的内核启用了 `COMPAT_FREEBSD32`
    选项（GENERIC 中已包含），FreeBSD/amd64 可以运行所有 FreeBSD/i386 软件。不过，你不能使用 FreeBSD/amd64 的共享库来运行
    FreeBSD/i386 软件。如果你想在 64 位计算机上运行一个复杂的 32 位程序，你必须提供必要库的 32 位版本。这是完全支持的；如果你查看 *rc.conf*，会看到
    ldconfig(8) 的选项 `ldconfig32_paths` 和 `ldconfig_local32_dirs`。这些选项专门用于告诉你的 amd64
    系统在哪里可以找到 32 位库。FreeBSD 在安装介质中包含了 32 位库。
- en: Additionally, FreeBSD can run software from older versions of FreeBSD. The GENERIC
    kernel includes all the system calls, but you’ll still need the base system libraries.
    These libraries are available as packages, one for each major FreeBSD release.
    Each package is named *compat*, followed by a version number, and ending in *x*.
    If you must run a FreeBSD 8 binary, install the compat8x package. The compat packages
    include 64-bit and 32-bit libraries.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，FreeBSD 可以运行来自旧版本 FreeBSD 的软件。GENERIC 内核包含所有的系统调用，但你仍然需要基础系统库。这些库以包的形式提供，每个主要的
    FreeBSD 版本都有一个相应的包。每个包的名称以*compat*开头，后跟版本号，并以*x*结尾。如果你必须运行 FreeBSD 8 的二进制文件，安装
    compat8x 包。compat 包包含 64 位和 32 位库。
- en: If you need to run binaries that aren’t i386 or amd64, you can even use binmiscctl(8)
    to automatically fire up the proper emulator whenever you run a non-x86 binary.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要运行非i386或amd64的二进制文件，你甚至可以使用binmiscctl(8)在每次运行非x86二进制文件时自动启动合适的模拟器。
- en: While there’s always more to learn about software management, you now know enough
    to scrape by. Let’s go on and learn about upgrading FreeBSD.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管关于软件管理的知识总是有更多可以学习的内容，但你现在已经足够掌握基本知识来应付了。接下来，让我们继续学习如何升级FreeBSD。
