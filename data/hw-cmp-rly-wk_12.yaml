- en: '## **12'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **12'
- en: THE WORLD WIDE WEB**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 万维网**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: The previous chapter described the internet, the globally connected set of computer
    networks that share a suite of protocols. The World Wide Web is a system built
    on top of the internet, one so popular that it is often confused with the internet
    itself. In this chapter, we dive into the details of the web. We first look at
    its key attributes and related programming languages, and then we look at web
    browsers and web servers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章描述了互联网，即一组全球连接的计算机网络，使用一套协议共享资源。万维网是建立在互联网之上的一个系统，由于其广泛的普及，常常与互联网本身混淆。在这一章中，我们深入探讨网络的细节。我们首先看看它的关键属性和相关的编程语言，然后我们再讨论web浏览器和web服务器。
- en: '**Overview of the World Wide Web**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**万维网概述**'
- en: The *World Wide Web*, often just called the *web*, is a set of resources, delivered
    using *HyperText Transfer Protocol (HTTP)* over the internet. A web *resource*
    is anything that can be accessed using the web, such as a document or an image.
    A computer or software program that hosts web resources is called a *web server*,
    and a *web browser* is a type of application commonly used to access content on
    the web. Browsers are used to view documents known as *web pages*, and a collection
    of related web pages is known as a *website*. The web is distributed, addressable,
    and linked. Let’s begin by examining each of those core attributes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*万维网*，通常简称为*网*，是一组通过*超文本传输协议（HTTP）*在互联网上提供的资源。一个网络*资源*是任何可以通过网络访问的内容，如文档或图片。托管网络资源的计算机或软件程序称为*web服务器*，而*web浏览器*是常用来访问网络内容的一种应用程序。浏览器用于查看称为*网页*的文档，一组相关的网页被称为*网站*。网络具有分布性、可寻址性和链接性。让我们从检查这些核心属性开始。'
- en: '***The Distributed Web***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分布式网络***'
- en: The World Wide Web is *distributed*. No centralized organization or system governs
    what content can be published to the web. Any computer connected to the internet
    can run a web server, and the owner of such a computer can make available any
    content they wish. That said, organizations or countries may choose to block users
    from accessing certain content on the web, and governments can shut down websites
    that host illegal content. Aside from those cases, the web is an open platform
    for publishing whatever people wish to publish, and no single organization controls
    what content is made available.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 万维网是*分布式*的。没有集中式的组织或系统来管理哪些内容可以发布到网络上。任何连接到互联网的计算机都可以运行web服务器，而该计算机的所有者可以公开任何他们希望发布的内容。尽管如此，组织或国家可能会选择阻止用户访问某些内容，而政府可以关闭托管非法内容的网站。除了这些情况，网络是一个开放的平台，允许人们发布任何他们愿意发布的内容，没有单一的组织控制可用内容。
- en: '***The Addressable Web***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***可寻址的网络***'
- en: The web uses *Uniform Resource Locators (URLs)* to give every resource on the
    web a unique address that includes both its location and how to access it. URLs
    are commonly referred to as *web addresses* or just *addresses*. To illustrate
    how these addresses are structured, let’s use a URL for a fictitious travel website,
    as shown in [Figure 12-1](ch12.xhtml#ch12fig1). This URL identifies a page with
    information about traveling to the Carolinas.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 网络使用*统一资源定位符（URL）*为网络上的每个资源提供一个唯一的地址，该地址包括其位置和如何访问它。URL通常被称为*网络地址*或简写为*地址*。为了说明这些地址的结构，让我们以一个虚构的旅游网站的URL为例，如[图12-1](ch12.xhtml#ch12fig1)所示。这个URL标识了一个关于前往卡罗莱纳的旅游信息页面。
- en: '![image](../images/fig12-1.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig12-1.jpg)'
- en: '*Figure 12-1: An example URL*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-1：一个示例URL*'
- en: A URL is composed of multiple parts. The URL *scheme* identifies the application
    layer protocol for accessing the resource. In this case, the protocol is HTTP,
    which we’ll cover in more detail later. The colon (:) character indicates the
    end of the scheme portion. Following two forward slashes (//) is the *authority*
    portion of the URL. In this example, the authority portion contains a DNS hostname
    of the server(s) where the resource resides, *travel.example.com*. An IP address
    can be used here as well. Other information besides the host can also go in this
    section, such as a username (preceding the host and followed by an @ sign) or
    port number (following the host and prefixed with a colon). The *path* portion
    of the URL is next; it specifies the location of a resource on the web server.
    A URL path is analogous to a filesystem path, organizing resources into a logical
    hierarchy. In our example, the path */destinations/carolinas* implies that the
    site has a collection of pages that describe travel destinations, and the particular
    page specified in the URL is a page about the Carolinas. We could reasonably assume
    that if the site had a page describing Florida as a destination, it would be found
    at */destinations/florida*. Finally, the *query* portion of the URL acts as a
    modifier to the resource returned to the client. In our example, the query indicates
    that the *carolinas* page should display locations at the beach. The format and
    meaning of the query portion of the URL varies from site to site.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个URL由多个部分组成。URL的*协议*标识了用于访问资源的应用层协议。在这种情况下，协议是HTTP，我们将在后续部分详细讨论。冒号（:）字符表示协议部分的结束。接着是两个斜杠（//），这是URL的*权限*部分。在这个示例中，权限部分包含了服务器的DNS主机名，即资源所在的服务器（*travel.example.com*）。这里也可以使用IP地址。除主机外，其他信息也可以出现在这一部分，例如用户名（位于主机之前并以@符号分隔）或端口号（位于主机之后，并以冒号前缀）。接下来是URL的*路径*部分，它指定了Web服务器上资源的位置。URL路径类似于文件系统路径，将资源组织成逻辑层级。在我们的示例中，路径*/destinations/carolinas*表示该网站有一个描述旅行目的地的页面集合，且URL指定的特定页面是关于卡罗莱纳州的页面。如果该网站有一个描述佛罗里达州作为目的地的页面，那么它可能位于*/destinations/florida*。最后，URL的*查询*部分作为修改返回给客户端的资源的修饰符。在我们的示例中，查询指示*carolinas*页面应显示海滩上的位置。URL查询部分的格式和含义因网站而异。
- en: A lot of information is packed into that URL, so let me restate how to read
    it in plain language. A website is running on a computer named *travel.example.com*.
    The site speaks HTTP, so use that protocol when connecting to the site. On that
    site there’s a page called *carolinas*, part of a collection of *destinations*.
    The query string directs the page to only show locations that are at the beach.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 该URL包含了大量信息，所以让我用简单的语言重新陈述如何读取它。一个网站运行在名为*travel.example.com*的计算机上。该网站使用HTTP协议，因此在连接到该网站时需要使用此协议。该网站上有一个名为*carolinas*的页面，它是*destinations*集合的一部分。查询字符串指示该页面仅显示位于海滩的地点。
- en: A URL does not have to include every element in the example in [Figure 12-1](ch12.xhtml#ch12fig1).
    It may also contain some elements not included in this example. A URL that includes
    only the scheme and the authority is perfectly valid, such as *[http://travel.example.com](http://travel.example.com)*.
    In that scenario, the website serves its default page, since no path is provided.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个URL不必包含[图12-1](ch12.xhtml#ch12fig1)中示例的每个元素。它也可以包含该示例中未包括的某些元素。只包含协议和权限的URL也是完全有效的，例如*[http://travel.example.com](http://travel.example.com)*。在这种情况下，网站会提供其默认页面，因为没有提供路径。
- en: '**EXERCISE 12-1: IDENTIFY THE PARTS OF A URL**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题12-1：识别URL的各个部分**'
- en: For the following URLs, identify the scheme, username, host, port, path, and
    query. Not all URLs include all these parts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下URL，识别其中的协议、用户名、主机、端口、路径和查询。并非所有URL都包含所有这些部分。
- en: '*[https://example.com/photos?subject=cat&color=black](https://example.com/photos?subject=cat&color=black)*'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*[https://example.com/photos?subject=cat&color=black](https://example.com/photos?subject=cat&color=black)*'
- en: '*[http://192.168.1.20:8080/docs/set5/two-trees.pdf](http://192.168.1.20:8080/docs/set5/two-trees.pdf)*'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*[http://192.168.1.20:8080/docs/set5/two-trees.pdf](http://192.168.1.20:8080/docs/set5/two-trees.pdf)*'
- en: '*[mailto:someone@example.com](mailto:someone@example.com)*'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*[mailto:someone@example.com](mailto:someone@example.com)*'
- en: You can check your answers in [Appendix A](appa.xhtml).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[附录A](appa.xhtml)中检查你的答案。
- en: A web browser typically displays the current URL in its address bar, as illustrated
    in [Figure 12-2](ch12.xhtml#ch12fig2).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器通常会在其地址栏中显示当前的URL，如[图12-2](ch12.xhtml#ch12fig2)所示。
- en: '![image](../images/fig12-2.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig12-2.jpg)'
- en: '*Figure 12-2: The address bar*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-2：地址栏*'
- en: Today, it’s common for browsers to exclude the scheme, colon, and forward slashes
    in the address bar representation of the URL. This doesn’t mean these elements
    of the URL are no longer used by the browser. The browser is just trying to simplify
    things for users. The specifics of how the URL is displayed continue to change
    over time, with various browsers behaving differently.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，浏览器通常会在地址栏中省略 URL 的方案、冒号和正斜杠。这并不意味着这些 URL 元素不再被浏览器使用。浏览器只是想简化用户体验。URL 的显示方式会随着时间的推移而不断变化，不同的浏览器表现也各不相同。
- en: '[Figure 12-3](ch12.xhtml#ch12fig3) shows examples of how Google Chrome (version
    77) displays URLs in its address bar.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-3](ch12.xhtml#ch12fig3) 显示了 Google Chrome（版本 77）如何在其地址栏中显示 URL 的示例。'
- en: '![image](../images/fig12-3.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig12-3.jpg)'
- en: '*Figure 12-3: Chrome’s address bar*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-3：Chrome 地址栏*'
- en: The top image in [Figure 12-3](ch12.xhtml#ch12fig3) shows the address bar when
    an HTTP site is loaded. Chrome doesn’t display the *http://* prefix in its address
    bar. Note the `Not secure` text. The lower image shows the address bar when an
    HTTPS site is loaded. HTTPS is the secure version of HTTP. Chrome omits the *https://*
    prefix but displays a padlock icon indicating this is an HTTPS site.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-3](ch12.xhtml#ch12fig3) 上方的图像显示了加载 HTTP 网站时的地址栏。Chrome 在其地址栏中不显示*http://*前缀。请注意`Not
    secure`文本。下方的图像显示了加载 HTTPS 网站时的地址栏。HTTPS 是 HTTP 的安全版本。Chrome 省略了*https://*前缀，但显示一个锁形图标，表示这是一个
    HTTPS 网站。'
- en: We’ve been discussing URLs in the context of web pages, but URLs extend to other
    resources on the web too. An image shown on a web page, for example, has its own
    URL, as does a script file or an XML data file. A web browser only shows the URL
    of the web page in its address bar, but a typical web page references various
    other resources by URL; the browser automatically loads those resources.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在讨论以网页为背景的 URL，但 URL 也扩展到 Web 上的其他资源。例如，网页上显示的图像有其自己的 URL，脚本文件或 XML 数据文件也是如此。网页浏览器只在地址栏显示网页的
    URL，但典型的网页通过 URL 引用各种其他资源；浏览器会自动加载这些资源。
- en: Sometimes it isn’t necessary to include the scheme, hostname, or even the full
    path in a URL. When a URL omits one or more of these elements, it’s known as a
    *relative URL*. A relative URL is interpreted as relative to the context in which
    it’s found. For example, if a URL like */images/cat.jpg* is used on a web page,
    the browser that loads the page assumes that the scheme and hostname of the cat
    photo match the scheme and hostname of the page itself.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在 URL 中不需要包含方案、主机名，甚至完整路径。当 URL 省略其中一个或多个元素时，这种 URL 被称为*相对 URL*。相对 URL 被解释为相对于其所在的上下文。例如，如果在网页中使用一个像*/images/cat.jpg*的
    URL，加载该页面的浏览器会假设猫照片的方案和主机名与该页面的方案和主机名相匹配。
- en: '***The Linked Web***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***链接的 Web***'
- en: The nature of URLs, where every resource on the web has a unique address, makes
    it easy for one web resource to reference another. A reference from one web document
    to another is known as a *hyperlink*, or just a *link*. Such links are one-way;
    any web page can link to another page without permission or a reciprocal link.
    This system of pages linking to one another is what puts the “web” in World Wide
    Web. Documents like web pages that can be connected with hyperlinks are known
    as *hypertext* documents.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: URL 的特点是 Web 上的每个资源都有一个唯一的地址，这使得一个 Web 资源可以轻松地引用另一个资源。从一个网页文档到另一个网页文档的引用被称为*超链接*，或者简称*链接*。这种链接是单向的；任何网页都可以链接到另一个页面，而无需许可或互链。网页相互链接的这种系统就是让“Web”成为万维网的原因。像网页这样的文档，如果可以通过超链接连接，就被称为*超文本*文档。
- en: '***The Protocols of the Web***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Web 协议***'
- en: The web is delivered using *HyperText Transfer Protocol (HTTP)*, and its secure
    variant, *HTTPS*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Web 使用*超文本传输协议（HTTP）*及其安全变种*HTTPS*进行传输。
- en: '**HTTP**'
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**HTTP**'
- en: Despite its name, HTTP isn’t just for transferring hypertext; it’s used for
    reading, creating, updating, and deleting all resources on the web. HTTP typically
    relies on TCP/IP. TCP ensures that data is reliably transferred, and IP handles
    host addressing. HTTP itself is based on a model of *request* and *response*.
    An HTTP request is sent to a web server, and the server replies with a response.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名称中有“超文本”，但 HTTP 不仅用于传输超文本；它还用于读取、创建、更新和删除 Web 上的所有资源。HTTP 通常依赖于 TCP/IP。TCP
    确保数据可靠传输，IP 负责主机寻址。HTTP 本身基于*请求*和*响应*的模型。HTTP 请求发送到 Web 服务器，服务器会回复一个响应。
- en: Each HTTP request includes an *HTTP method*, also informally called an *HTTP
    verb*, that describes what kind of action the client is requesting of the server.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 HTTP 请求都包括一个*HTTP 方法*，也非正式地称为*HTTP 动词*，它描述了客户端请求服务器执行的操作类型。
- en: 'Some commonly used HTTP methods:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常用的 HTTP 方法：
- en: GET   Retrieve a resource without modifying it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: GET   检索资源而不修改它。
- en: PUT   Create or modify a resource at a specific URL on the server.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: PUT   在服务器的特定 URL 上创建或修改资源。
- en: POST   Create a resource on the server, as a child of an existing URL.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: POST   在服务器上创建一个资源，作为现有 URL 的子资源。
- en: DELETE   Remove a resource from the server.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: DELETE   从服务器上删除资源。
- en: Any HTTP method can be attempted on any resource, but the server hosting a specific
    resource often won’t allow some methods on that resource. For example, most websites
    do not allow clients to delete resources. Those that do allow deletion almost
    always require the user to log on with an account that has permission to delete
    content.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 HTTP 方法都可以在任何资源上尝试，但托管特定资源的服务器通常不会允许某些方法在该资源上使用。例如，大多数网站不允许客户端删除资源。那些允许删除的站点几乎总是要求用户以拥有删除权限的帐户登录。
- en: The most commonly used method on a typical website is `GET`. When a web browser
    navigates to a website, the browser performs a `GET` on the requested page. That
    page may include references to scripts, images, and so forth, and the browser
    then also uses the `GET` method to obtain those resources before the page can
    be fully displayed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型网站上最常用的方法是 `GET`。当网页浏览器访问网站时，浏览器会对请求的页面执行 `GET` 请求。该页面可能包含对脚本、图片等的引用，浏览器随后也使用
    `GET` 方法获取这些资源，直到页面能够完全显示。
- en: Each HTTP response includes an *HTTP status code* that describes the server’s
    response. Each status code is a 3-digit number, where the most significant digit
    indicates the general class of response. Responses in the 100 range are informational.
    Responses in the 200 range indicate success. Responses in the 300 range indicate
    redirection. Responses in the 400s indicate an error on the client side—the request
    wasn’t properly formed by the client. A 500 range response means the server encountered
    an error.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 HTTP 响应都包括一个*HTTP 状态码*，它描述了服务器的响应。每个状态码是一个三位数，其中最显著的数字表示响应的总体类别。100 范围内的响应是信息性的，200
    范围的响应表示成功，300 范围的响应表示重定向，400 范围的响应表示客户端出现错误——请求未被客户端正确形成，500 范围的响应表示服务器发生了错误。
- en: 'Some commonly used HTTP status codes:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常用的 HTTP 状态码：
- en: '**200**   Success. The server was able to fulfill the request.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**200**   成功。服务器能够完成请求。'
- en: '**301**   Moved Permanently. The browser should redirect the request to a different
    URL, specified in the response.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**301**   永久移动。浏览器应将请求重定向到响应中指定的不同 URL。'
- en: '**401**   Unauthorized. Authentication is required.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**401**   未经授权。需要身份验证。'
- en: '**403**   Forbidden. The user doesn’t have access to the requested resource.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**403**   禁止访问。用户没有权限访问请求的资源。'
- en: '**404**   Not Found. The server didn’t find the requested resource.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**404**   未找到。服务器未能找到请求的资源。'
- en: '**500**   Internal Server Error. Something unexpected happened on the server.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**500**   服务器内部错误。服务器发生了意外错误。'
- en: 'HTTP is fairly easy to understand. It uses human-readable text to describe
    requests and responses. The first line of a request includes an HTTP method, the
    URL of the resource, and the requested version of HTTP. Here’s an example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 是相当容易理解的。它使用人类可读的文本来描述请求和响应。请求的第一行包括 HTTP 方法、资源的 URL 和请求的 HTTP 版本。以下是一个例子：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This simply means that the client is asking the server to send it the content
    of */documents/hello.txt* using HTTP version `1.1`. Following the request line,
    an HTTP request usually includes header fields that provide more information about
    the request and an optional message body.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着客户端请求服务器通过 HTTP 版本`1.1`发送 */documents/hello.txt* 的内容。在请求行之后，HTTP 请求通常包括一些头部字段，用以提供更多关于请求的信息，此外还可以有一个可选的消息体。
- en: 'Similarly, an HTTP response uses a simple text format. The first line includes
    a version of HTTP, a status code, and a response phrase. Here’s an example of
    the first line of an HTTP response:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，HTTP 响应也使用简单的文本格式。第一行包括 HTTP 版本、状态码和响应短语。以下是一个 HTTP 响应第一行的例子：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example response, the server is indicating a status code of `200` and
    a response phrase of `OK`. Just like HTTP requests, responses may also include
    header values and a message body. [Figure 12-4](ch12.xhtml#ch12fig4) provides
    a more detailed, but still simplified, example of an HTTP request and response.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个响应示例中，服务器返回了状态码 `200` 和响应短语 `OK`。就像 HTTP 请求一样，响应也可以包括头信息值和消息体。[图 12-4](ch12.xhtml#ch12fig4)
    提供了一个更详细，但仍然简化的 HTTP 请求和响应示例。
- en: '![image](../images/fig12-4.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig12-4.jpg)'
- en: '*Figure 12-4: A simplified HTTP request and response*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-4：简化的 HTTP 请求和响应*'
- en: '**NOTE**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #36](ch12.xhtml#proj36) on [page 283](ch12.xhtml#page_283),
    where you can look at HTTP network traffic*.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见 [项目 #36](ch12.xhtml#proj36) 在 [第 283 页](ch12.xhtml#page_283)，你可以查看 HTTP
    网络流量*。'
- en: '**HTTPS**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**HTTPS**'
- en: A secure variation of HTTP known as *HTTPS (HyperText Transfer Protocol Secure)*
    is commonly used on the web to encrypt data sent over the internet. *Encryption*
    is the process of encoding data into a format that’s unreadable. *Decryption*
    is the reversal of encryption, making encrypted data readable again. Cryptographic
    algorithms encrypt and decrypt data using a secret sequence of bytes known as
    a *cryptographic key*. Because keys can be kept secret, the algorithm itself can
    be well-known.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一种安全变体的 HTTP 称为*HTTPS（超文本传输协议安全）*，通常用于加密通过互联网发送的数据。*加密*是将数据编码成无法读取的格式的过程。*解密*是加密的反过程，使加密数据重新变得可读。加密算法使用称为*加密密钥*的秘密字节序列来加密和解密数据。由于密钥可以保持秘密，因此算法本身可以是公开的。
- en: 'HTTPS uses two kinds of encryption. *Symmetric encryption* uses a single *shared
    key* both for encrypting and decrypting a message. *Asymmetric encryption* uses
    two keys (a *key pair*): a *public key* is used to encrypt data, and a *private*
    *key* is used to decrypt data. Asymmetric encryption allows a public key to be
    shared freely so that anyone can encrypt and send data, whereas a private key
    is shared only with trusted parties who need to be able to receive and decrypt
    the data.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS 使用两种加密方式。*对称加密*使用一个*共享密钥*来加密和解密信息。*非对称加密*使用两把密钥（一个*密钥对*）：*公钥*用于加密数据，*私钥*用于解密数据。非对称加密允许公钥自由共享，以便任何人都可以加密和发送数据，而私钥则仅与需要接收和解密数据的信任方共享。
- en: Without HTTPS, web traffic is transmitted “in the clear,” meaning it is unencrypted
    and can be intercepted or modified in transit by malicious parties. HTTPS helps
    to reduce these risks. With HTTPS, the entire HTTP request is encrypted, including
    the URL, headers, and body. The same is true of an HTTPS response; it’s fully
    encrypted. HTTPS takes an HTTP request and encrypts it using a protocol called
    *Transport Layer Security (TLS)*. In the past, a similar protocol called *Secure
    Sockets Layer (SSL)* was used, but due to security issues, it has since been deprecated
    in favor of TLS. When we speak of HTTPS, what we mean is HTTP encrypted with TLS.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 HTTPS 时，网页流量以“明文”方式传输，这意味着它是未加密的，可能会在传输过程中被恶意方截获或修改。HTTPS 有助于减少这些风险。在 HTTPS
    中，整个 HTTP 请求都会被加密，包括 URL、头信息和主体。HTTPS 响应也是如此，它是完全加密的。HTTPS 将 HTTP 请求使用一种叫做*传输层安全协议（TLS）*的协议进行加密。过去，使用类似的协议叫做*安全套接字层（SSL）*，但由于安全问题，它已被弃用，取而代之的是
    TLS。当我们谈到 HTTPS 时，指的就是使用 TLS 加密的 HTTP。
- en: When an HTTPS session begins, the client connects to the server with a *client
    hello* message with details of how it wishes to securely communicate. The server
    responds with a *server hello* message that confirms how the communication will
    occur. The server also sends a set of bytes known as a *digital certificate*,
    which includes the server’s public cryptographic key, used for asymmetric encryption.
    The client then checks if the server’s certificate is valid. If so, the client
    encrypts a string of bytes using the server’s public key and then sends the encrypted
    message to the server. The server decrypts the bytes using its private key. The
    server and client both use the information previously exchanged to compute a shared
    secret key, used for symmetric encryption. Once both client and server have the
    shared key, that key is used to encrypt and decrypt all communication between
    the client and server for the duration of the session.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 HTTPS 会话开始时，客户端会通过一个包含安全通信方式的 *客户端 hello* 消息连接到服务器。服务器则以 *服务器 hello* 消息回应，确认通信的方式。服务器还会发送一组称为
    *数字证书* 的字节，其中包括服务器的公钥，用于非对称加密。然后，客户端检查服务器的证书是否有效。如果有效，客户端使用服务器的公钥加密一串字节，并将加密后的消息发送给服务器。服务器使用其私钥解密这些字节。客户端和服务器都利用先前交换的信息来计算一个共享的秘密密钥，用于对称加密。一旦客户端和服务器都拥有了共享密钥，所有在会话期间的通信都将使用该密钥进行加密和解密。
- en: HTTPS was previously only used in limited cases, for websites that dealt with
    particularly sensitive information. However, the web is moving to a state in which
    HTTPS is the norm rather than the exception. There is a growing belief that the
    security and privacy benefits of HTTPS make sense for most, if not all, traffic
    on the web. Google has encouraged this change, by marking HTTP sites as “Not secure”
    in Chrome and by using the presence of HTTPS as a positive signal to its search
    engine, helping to boost the Google search rank of HTTPS sites.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS 之前只在有限的情况下使用，通常用于处理特别敏感信息的网站。然而，网络正在向 HTTPS 成为常态而非例外的方向发展。越来越多的观点认为，HTTPS
    的安全性和隐私保护对大多数，甚至是所有网络流量都是有意义的。谷歌通过在 Chrome 浏览器中将 HTTP 网站标记为“不安全”并利用 HTTPS 作为正面信号来提升其搜索引擎排名，推动了这一变化。
- en: '**NOTE**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #37](ch12.xhtml#proj37) on [page 285](ch12.xhtml#page_285),
    where you can set up a simple web server on your local network.*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[项目 #37](ch12.xhtml#proj37)，它介绍了如何在本地网络上设置一个简单的 Web 服务器，详细内容见[第 285 页](ch12.xhtml#page_285)。*'
- en: '***The Searchable Web***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***可搜索的网络***'
- en: For many people, the typical entry point to the web is a search. Rather than
    navigate to a particular URL, a user types some search terms into their browser
    and sees what comes up. Browser design encourages this, since browsers commonly
    leverage the address bar as a search box too. Even when a user wants to visit
    a particular site, they often perform a search for that site, then click the resulting
    link, rather than entering the full URL in the address bar. This is a design that
    enhances usability of the browser, even as it blurs the distinction between URLs
    and search terms, browser and search engine.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多人来说，访问网络的典型入口是通过搜索。用户不需要直接访问特定的 URL，而是将一些搜索词输入到浏览器中，查看搜索结果。浏览器设计鼓励这种做法，因为浏览器通常会将地址栏也当作搜索框使用。即使用户想访问某个特定网站，他们通常会先搜索该网站，然后点击搜索结果中的链接，而不是在地址栏中输入完整的
    URL。这种设计增强了浏览器的可用性，即使它模糊了 URL 和搜索词、浏览器和搜索引擎之间的区别。
- en: Despite the prevalence and usefulness of searching the web, the capability of
    searching isn’t a native feature of the web. There isn’t a standard specification
    for how searching should work. This means that searching, one of the key features
    of the web, relies on nonstandard, proprietary search engines. At the time of
    this writing, Google dominates the web searching space, and although there are
    good alternative search engines, their worldwide usage is a fraction of Google’s.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管搜索网络的普遍性和实用性，搜索功能并不是网络的原生特性。没有标准的规范来定义搜索应该如何工作。这意味着，作为网络的关键特性之一，搜索依赖于非标准的、专有的搜索引擎。在本文写作时，谷歌主导着网络搜索领域，尽管也有一些不错的替代搜索引擎，但它们的全球使用量仅为谷歌的一小部分。
- en: '**The Languages of the Web**'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网络的语言**'
- en: Any content that can be saved as a file can be hosted on the web. For example,
    a web server can host a collection of Excel files, and they can be downloaded
    from the website and opened in Excel. However, a web browser is much more than
    just a tool for downloading files to be opened in other applications. A web browser
    not only downloads content, but also renders web pages. These pages can be simple
    documents, or interactive web applications. To make this possible, browsers understand
    three computer languages, which are used to construct websites.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可以保存为文件的内容都可以托管在网上。例如，Web 服务器可以托管一组 Excel 文件，这些文件可以从网站上下载并在 Excel 中打开。然而，网页浏览器不仅仅是一个下载文件并在其他应用程序中打开的工具。网页浏览器不仅下载内容，还会渲染网页。这些网页可以是简单的文档，也可以是互动的网页应用程序。为了实现这一点，浏览器理解三种计算机语言，这些语言用于构建网站。
- en: '**HyperText Markup Language (HTML)**   Defines the structure of a web page.
    In other words, it defines *what is on the page*. For example, HTML can specify
    that a button exists on a web page.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**超文本标记语言 (HTML)** 定义了网页的结构。换句话说，它定义了*页面上的内容*。例如，HTML 可以指定网页上存在一个按钮。'
- en: '**Cascading Style Sheets (CSS)**   Defines the appearance of a web page. In
    other words, it defines *how the page looks*. For example, CSS can specify that
    the aforementioned button is 30 pixels wide and blue.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**层叠样式表 (CSS)** 定义网页的外观。换句话说，它定义了*页面的外观*。例如，CSS 可以指定前述按钮的宽度为 30 像素，并且是蓝色的。'
- en: '**JavaScript**   Defines the behavior of a web page. In other words, it defines
    *how the page functions*. For example, JavaScript can be used to add two numbers
    together when a button is clicked.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript** 定义网页的行为。换句话说，它定义了*页面的功能*。例如，JavaScript 可以在点击按钮时将两个数字相加。'
- en: 'These three languages are used together to create the content of the web. It’s
    worth noting that web browsers are also capable of rendering some other data types
    too, notably certain image, video, and audio formats, but we won’t go into those
    in detail. Let’s now dive into each of the three foundational languages of the
    web: HTML, CSS, and JavaScript.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种语言一起用于创建网页内容。值得注意的是，网页浏览器也能够渲染其他数据类型，特别是某些图像、视频和音频格式，但我们不会详细讨论这些内容。现在，让我们深入了解构成网页的三种基础语言：HTML、CSS
    和 JavaScript。
- en: '***Structuring the Web with HTML***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 HTML 构建网页结构***'
- en: HTML is a markup language that describes the structure of a web page. Note that
    HTML isn’t a programming language. A programming language describes operations
    that a computer should perform, whereas a markup language describes the structure
    of data. In the case of HTML, the data in question represents a web page. A web
    page can contain various elements such as paragraphs, headings, and images. Here’s
    an example of a simple web page described in HTML.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 是一种标记语言，用于描述网页的结构。请注意，HTML 不是一种编程语言。编程语言描述的是计算机应该执行的操作，而标记语言描述的是数据的结构。就
    HTML 而言，这些数据代表的是网页。一个网页可以包含多种元素，如段落、标题和图片。以下是一个用 HTML 描述的简单网页示例。
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You see a number of items enclosed in less than (`<`) and greater than (`>`)
    signs. These are known as *HTML tags*, sets of text characters used to define
    the parts of an HTML document. As an example, the tag used to indicate the start
    of a paragraph is `<p>`. A corresponding tag is used to indicate the end of a
    paragraph, `</p>`. Note the slash in the end tag, differentiating it from the
    start tag. An *HTML element* is a portion of the page beginning with a start tag,
    ending with an end tag, and including the content between the tags. For example,
    this is an HTML element: `<p>This is a cat.</p>`. In truth, not all elements require
    an end tag. For example, the `img` element, used for representing an image, needs
    no end tag. You can see this in the previous HTML code example.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到许多内容被小于符号 (`<`) 和大于符号 (`>`) 包围。这些被称为 *HTML 标签*，是用于定义 HTML 文档部分的文本字符集。举个例子，表示段落开始的标签是
    `<p>`，用于表示段落结束的标签是 `</p>`。请注意结束标签中的斜杠，它与开始标签不同。*HTML 元素* 是指以开始标签开始，以结束标签结束，并包括标签之间的内容的网页部分。例如，这是一个
    HTML 元素：`<p>这是一个猫。</p>`。事实上，并不是所有元素都需要结束标签。例如，用于表示图像的 `img` 元素就不需要结束标签。你可以在前面的
    HTML 代码示例中看到这一点。
- en: '[Figure 12-5](ch12.xhtml#ch12fig5) shows how the example HTML might be rendered
    in a web browser.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-5](ch12.xhtml#ch12fig5) 显示了该 HTML 示例在网页浏览器中的渲染效果。'
- en: '![image](../images/fig12-5.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig12-5.jpg)'
- en: '*Figure 12-5: Our example web page rendered in a web browser*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-5：我们的示例网页在网页浏览器中的渲染效果*'
- en: The document intentionally included no information about how it should be presented,
    so a browser uses a default font and size for the heading and paragraph. In this
    example, the browser also defaulted to black text on a white background—again,
    that wasn’t specified in the document. Since this HTML example contains no style
    information, different browsers can choose to render this page slightly differently.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 该文档故意没有包含任何关于如何呈现的信息，因此浏览器会使用默认的字体和大小来显示标题和段落。在这个例子中，浏览器还默认使用黑色文字和白色背景——同样，这在文档中并没有指定。由于这个HTML示例没有包含样式信息，不同的浏览器可能会略微不同地呈现这个页面。
- en: 'Let’s examine the HTML code example more closely. The first line of an HTML
    document declares that the file is an HTML document, like so: `<!DOCTYPE html>`.
    After that, an HTML document is structured as a tree, with parent elements and
    child elements. The `<html>` tag is the top-level parent tag; everything is enclosed
    between `<html>` and `</html>`. You can interpret those two tags as “HTML starts
    here” and “HTML ends here.” This makes sense—everything in an HTML document should
    be HTML! The `<html>` tag also contains an attribute called `lang` that identifies
    the language of this document as `en`, the code for English.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看HTML代码示例。HTML文档的第一行声明该文件是一个HTML文档，如下所示：`<!DOCTYPE html>`。之后，HTML文档被结构化为一棵树，包含父元素和子元素。`<html>`标签是顶级父标签；所有内容都包含在`<html>`和`</html>`之间。你可以将这两个标签解释为“HTML从这里开始”和“HTML到此结束”。这很有道理——HTML文档中的一切都应该是HTML！`<html>`标签还包含一个名为`lang`的属性，它标识该文档的语言为`en`，即英语的代码。
- en: 'The `html` element has two child elements: `head` and `body`. Elements contained
    in the head (between `<head>` and `</head>`) describe the document, whereas elements
    in the body (between `<body>` and `</body>`) make up the contents of the document.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`html`元素有两个子元素：`head`和`body`。位于head中的元素（在`<head>`和`</head>`之间）描述文档，而位于body中的元素（在`<body>`和`</body>`之间）构成文档的内容。'
- en: 'In our example, the head contains two elements: a `meta` element describing
    the character set used to encode our document, and a `title`. Browsers typically
    show the title text on a page’s tab and use it as a default name when a user adds
    a bookmark or favorite. Search engines use the title text when showing results.
    For those reasons it’s important for web developers to give meaningful titles
    to their pages.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，head包含两个元素：一个`meta`元素，用于描述用于编码文档的字符集，还有一个`title`。浏览器通常会在页面的标签上显示标题文本，并在用户添加书签或收藏夹时将其作为默认名称。搜索引擎在显示结果时也会使用标题文本。因此，网页开发人员为页面提供有意义的标题非常重要。
- en: The body in our example includes an `<h1>` tag, which is used for a heading
    element. Heading tags of `<h1>` through `<h6>` are available, with `h1` intended
    to be used as the highest level of section headings, and `h6` as the lowest level.
    A paragraph follows the heading, indicated with a `<p>` tag, and after that an
    image is included using `<img>`. Note that the bytes of the image itself aren’t
    present in the HTML. Instead, the `<img>` tag simply references an image file
    by a relative URL (*cat.jpg*). To fully load this page, a browser needs to make
    a separate HTTP request to download the image. In this example, the image URL
    is simply a filename, meaning it’s hosted on the same server and in the same path
    as the document itself. If the image were hosted elsewhere, a URL with a path
    or a server name could be used. The `<img>` tag also has an `alt` attribute, which
    provides alternate text that describes the image. This is used in cases in which
    the image cannot be rendered, such as when a text-only browser or a screen reader
    that reads the contents of the page aloud is being used.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，body部分包含一个`<h1>`标签，用于表示标题元素。`<h1>`至`<h6>`有不同级别的标题标签，其中`h1`用于最高级别的章节标题，`h6`用于最低级别的标题。标题之后是一个段落，用`<p>`标签表示，接着是一个通过`<img>`标签包含的图像。请注意，图像本身的字节并没有出现在HTML中。相反，`<img>`标签仅通过相对URL（*cat.jpg*）引用图像文件。为了完全加载此页面，浏览器需要发送一个单独的HTTP请求来下载图像。在此示例中，图像的URL仅是文件名，意味着它托管在与文档相同的服务器和路径下。如果图像托管在其他地方，则可以使用带有路径或服务器名称的URL。`<img>`标签还有一个`alt`属性，它提供描述图像的替代文本。这在图像无法呈现时使用，例如当使用纯文本浏览器或朗读页面内容的屏幕阅读器时。
- en: You may have noticed that the earlier HTML code used indentation to show the
    nesting of various elements on the page. For example, the `<h1>` and `<p>` tags
    are indented to the same level, showing that they are child elements of the `<body>`
    tag. This is a common practice in web development to improve readability of HTML,
    but it’s not required. In fact, whitespace beyond a single space or tab doesn’t
    matter in an HTML document! We could remove all the extra spaces, tabs, and line
    breaks, leaving us with the HTML all on a single line, and the document would
    render the same way in a browser. Web browsers ignore extra whitespace, so spacing
    out elements on a page is only helpful to developers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，之前的HTML代码使用了缩进来显示页面上各种元素的嵌套关系。例如，`<h1>`和`<p>`标签被缩进到相同的级别，表明它们是`<body>`标签的子元素。这是网页开发中的一种常见做法，用于提高HTML的可读性，但并不是强制要求的。事实上，HTML文档中的空格除了单个空格或制表符之外都不重要！我们可以移除所有多余的空格、制表符和换行符，将HTML放在一行中，文档在浏览器中的呈现效果也不会改变。网页浏览器会忽略多余的空白，因此页面元素的排版对开发者有帮助，但对浏览器无影响。
- en: '**NOTE**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #38](ch12.xhtml#proj38) on [page 287](ch12.xhtml#page_287),
    where you can have your local website return a document structured with HTML rather
    than simple text*.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[项目#38](ch12.xhtml#proj38)，该项目在[第287页](ch12.xhtml#page_287)展示了如何使本地网站返回使用HTML结构的文档，而非简单文本*。'
- en: 'The HTML elements we’ve covered so far are only a small percentage of the total
    elements recognized by web browsers. We won’t exhaustively cover all of HTML here;
    it is well documented online. The specifications for HTML were previously maintained
    by two organizations: the World Wide Web Consortium (W3C) and the Web Hypertext
    Application Technology Working Group (WHATWG). The last major version of HTML
    to receive “Recommendation” status from the W3C was *HTML5*. In 2019, the two
    organizations agreed that ongoing development of the HTML standard will be handled
    principally by the WHATWG, in what is known as the *HTML Living Standard*, which
    is continually maintained.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前所讲解的HTML元素只是网页浏览器识别的所有元素的一小部分。我们在这里不会详尽地覆盖所有HTML内容；这些内容在网上有充分的文档资料。HTML的规范以前由两个组织维护：万维网联盟（W3C）和网页超文本应用技术工作组（WHATWG）。HTML的最后一个获得W3C“推荐”状态的主要版本是*HTML5*。2019年，这两个组织达成协议，HTML标准的持续开发将主要由WHATWG负责，这被称为*HTML生活标准*，并且会不断维护。
- en: Modern browsers attempt to support both current and older versions of HTML,
    since plenty of web content was authored with earlier HTML standards in mind.
    In the past, browsers introduced nonstandard HTML elements, some of which eventually
    became standardized, while others fell out of use and lost support. Web browser
    developers must balance innovation with adherence to standards, while still supporting
    less-than-perfect HTML that’s sometimes found on the web. Web browsers are ever
    evolving, and different browsers sometimes render the same content differently.
    This means that web developers regularly test their creations on multiple browsers
    to ensure consistent behavior.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器尝试支持当前版本和较早版本的HTML，因为许多网页内容是基于早期HTML标准编写的。过去，浏览器引入了非标准的HTML元素，其中一些最终成为标准化元素，而其他一些则不再使用并失去支持。网页浏览器开发者必须在创新与遵循标准之间找到平衡，同时仍然支持互联网上有时会遇到的不完美HTML。网页浏览器不断进化，不同的浏览器有时会以不同的方式呈现相同的内容。这意味着网页开发者通常需要在多个浏览器中测试他们的作品，以确保一致的行为。
- en: '***Styling the Web with CSS***'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***用CSS美化网页***'
- en: In our earlier example HTML, we used tags that described the structure of a
    document, but those tags did not convey any information about how the document
    should be presented. This was intentional; we want to keep structure and style
    separate. A division between the two allows for the same content to be rendered
    with different styles in different contexts. For example, most web content should
    be rendered differently on a large PC screen versus a small mobile screen.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的HTML示例中，我们使用了描述文档结构的标签，但这些标签并没有传达文档应该如何呈现的信息。这是有意为之；我们希望保持结构和样式的分离。结构与样式之间的分离使得相同的内容可以在不同的上下文中以不同的样式呈现。例如，大多数网页内容在大屏PC显示器上和小屏移动设备上应该有不同的呈现方式。
- en: '*Cascading Style Sheets (CSS)* is the language used to describe the style of
    a web page. A style sheet is a list of rules. Each rule describes a style that
    should be applied to a certain part of the page. Each rule includes a selector,
    which indicates what elements on the page should have the style applied. The *cascading*
    term refers to the ability for multiple rules to apply to the same element. Let’s
    look at a simple example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*层叠样式表（CSS）* 是用于描述网页样式的语言。样式表是一个规则列表。每个规则描述了应该应用于页面某个部分的样式。每条规则包括一个选择器，指示哪些页面元素应该应用该样式。*层叠*
    术语指的是多个规则可以应用于同一个元素的能力。让我们看一个简单的例子：'
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, style rules are defined for paragraph (`p`) elements and heading
    1 (`h1`) elements. When this CSS is applied to a page, all paragraphs on that
    page use the specified font, with a size of 11 point, a left margin of 10 pixels,
    and gray text. Similarly, h1 headings use the specified bolded font with a size
    of 18 point. Note that `font-family` is a list of fonts, not just a single font.
    This means that a web browser should try to find a matching font, starting with
    the leftmost font and proceeding to the right until a font match is found. Not
    every client device has the first choice of font installed; specifying multiple
    fonts increases the chance that a matching font will be available.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，为段落（`p`）元素和一级标题（`h1`）元素定义了样式规则。当此 CSS 应用到页面时，页面上的所有段落都使用指定的字体，字号为 11 磅，左边距为
    10 像素，文本为灰色。同样，h1 标题使用指定的加粗字体，字号为 18 磅。请注意，`font-family` 是一个字体列表，而不仅仅是单一字体。这意味着网页浏览器应该尝试找到匹配的字体，从最左边的字体开始，向右查找，直到找到匹配的字体为止。并非每个客户端设备都安装了首选字体；指定多个字体可以增加找到匹配字体的机会。
- en: 'You can apply a style sheet to a web page in a couple of ways. One option is
    to include the CSS rules within a `style` element on the page. For example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过几种方式将样式表应用于网页。一个选择是将 CSS 规则包含在页面上的 `style` 元素中。例如：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This isn’t ideal, because the style and structure are now closely related.
    A better option is to specify the CSS rules in a separate file, also hosted on
    the web. This approach keeps our HTML and CSS completely separate, and it allows
    multiple HTML files to use the same style sheet. This way we can change a CSS
    rule, and it will apply to multiple pages at once. A single element in the HTML’s
    head section can be used to apply the style sheet rules from a CSS file, like
    so (where `style.css` is the URL of the CSS file to apply):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做并不理想，因为样式和结构现在紧密相关。更好的做法是将 CSS 规则指定在一个单独的文件中，该文件也托管在网络上。这种方法使我们的 HTML 和 CSS
    完全分离，并允许多个 HTML 文件使用同一个样式表。这样我们可以修改一个 CSS 规则，并使其立即应用到多个页面。在 HTML 的头部部分，我们可以使用一个元素来应用来自
    CSS 文件的样式表规则，如下所示（其中 `style.css` 是要应用的 CSS 文件的 URL）：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we apply this style sheet to our example cat page, we see these changes to
    the heading and paragraph text, as shown in [Figure 12-6](ch12.xhtml#ch12fig6).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此样式表应用于我们的示例猫页面，则会看到标题和段落文本发生这些变化，如 [图 12-6](ch12.xhtml#ch12fig6) 所示。
- en: '![image](../images/fig12-6.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig12-6.jpg)'
- en: '*Figure 12-6: Our example web page with CSS applied*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-6：我们的示例网页，已应用 CSS 样式*'
- en: '**NOTE**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #39](ch12.xhtml#proj39) on [page 288](ch12.xhtml#page_288),
    where you can update your cat web page with some CSS*.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见 [项目 #39](ch12.xhtml#proj39) 第 [288 页](ch12.xhtml#page_288)，你可以通过一些 CSS
    更新你的猫网页*。'
- en: This CSS example is simple, but CSS allows for much more advanced styling as
    well. If you’re familiar with the amazing variety of visual styles to be found
    on the web, then you have already seen the power of CSS in action.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 CSS 示例很简单，但 CSS 也允许进行更为复杂的样式设置。如果你熟悉网页上各种令人惊叹的视觉样式，那么你已经看到了 CSS 强大功能的体现。
- en: '***Scripting the Web with JavaScript***'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 JavaScript 脚本编写网页***'
- en: The web was originally envisioned as a means of sharing information through
    hypertext documents. HTML gives us that capability, and CSS gives us a method
    of controlling the presentation of such documents. However, the web evolved into
    a platform for interactive content, and JavaScript became the standard means for
    enabling interactivity. *JavaScript* is a programming language that enables web
    pages to respond to users’ actions and programmatically perform various tasks.
    With JavaScript, a web browser becomes not just a document reader, but a full
    application development platform.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Web 最初是作为通过超文本文档共享信息的方式构想的。HTML 给我们提供了这个能力，CSS 则为我们提供了控制这些文档展示的方法。然而，Web 逐渐演变成了一个交互内容的平台，JavaScript
    成为了启用交互的标准方式。*JavaScript* 是一种编程语言，它使网页能够响应用户的操作，并以编程方式执行各种任务。使用 JavaScript，Web
    浏览器不仅仅是一个文档阅读器，而是一个完整的应用程序开发平台。
- en: JavaScript is an interpreted language; it isn’t compiled to machine code before
    it’s delivered to the browser. Web servers host JavaScript code in text format,
    and that code is downloaded by a browser and interpreted at runtime. That said,
    some browsers use a *just-in-time (JIT) compiler* that compiles JavaScript at
    runtime, leading to increased performance. Some developers *minify* their JavaScript
    before deploying it, removing whitespace, comments, and generally reducing the
    size of the script. Minifying JavaScript can improve the load time of a website.
    Minification isn’t the same as compilation; the minified file is still high-level
    code, not compiled machine code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种解释型语言；它在传递给浏览器之前并不会编译成机器代码。Web 服务器以文本格式托管 JavaScript 代码，浏览器会下载这些代码并在运行时进行解释。也就是说，一些浏览器使用*即时编译器
    (JIT)*，在运行时编译 JavaScript，从而提高性能。一些开发者会在部署之前对 JavaScript 进行*压缩*，去除空白符、注释，并通常会减小脚本的大小。压缩
    JavaScript 可以提高网站的加载速度。压缩并不等同于编译；压缩后的文件仍然是高级代码，而非编译后的机器代码。
- en: 'JavaScript has a syntax that’s similar to C and other languages that borrowed
    from C (such as C++, Java, and C#). However, the similarity is superficial, as
    JavaScript is quite different from those languages. Don’t let the name confuse
    you: JavaScript has little to do with Java. The language is object-oriented but
    fundamentally relies on *prototypes* rather than classes. That is, an existing
    object, rather than a class, acts a template for other objects.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的语法类似于 C 语言以及其他从 C 借用的语言（如 C++、Java 和 C#）。然而，这种相似性仅仅是表面的，因为 JavaScript
    与这些语言有很大的不同。不要让名字迷惑你：JavaScript 与 Java 几乎没有关系。该语言是面向对象的，但根本上依赖于*原型*而不是类。也就是说，现有的对象而非类，作为其他对象的模板。
- en: JavaScript interacts with an HTML page using a browser-supplied representation
    of the page called the *Document Object Model (DOM)*. The DOM is a hierarchical
    tree structure of page elements, and it can be programmatically modified. An update
    to an element in the DOM causes the browser to update the element on the displayed
    web page. JavaScript includes methods for working with the DOM, and by using these
    methods, JavaScript code can both respond to events that occur on the page (such
    as the click of a button) and change the contents of the rendered page.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 使用浏览器提供的页面表示与 HTML 页面进行交互，这种表示被称为*文档对象模型 (DOM)*。DOM 是一个页面元素的层级树结构，并且可以通过编程进行修改。对
    DOM 中元素的更新会导致浏览器在显示的网页上更新该元素。JavaScript 包含用于处理 DOM 的方法，利用这些方法，JavaScript 代码不仅可以响应页面上发生的事件（例如按钮的点击），还可以改变渲染页面的内容。
- en: Let’s look at part of a simple script that interacts with our example page.
    The script adds the text `Meow!` to our page’s paragraph every time the cat photo
    is clicked (or tapped on a touchscreen).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下与我们示例页面交互的简单脚本的一部分。每次点击猫咪照片（或在触摸屏上轻触）时，脚本都会将文本`Meow!`添加到页面的段落中。
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first line here adds an event handler that runs when the cat photo is clicked.
    The event handler code is defined on the next line, and it tells the browser to
    add the text `Meow!` to the paragraph. Since this is defined as an event handler,
    the code only runs when the image click event occurs. Note that the script references
    the photo and paragraph by IDs, `cat-photo` and `cat-para`, respectively. HTML
    elements can be given IDs; this allows us to easily reference them programmatically.
    Our script only works if we add these IDs to our HTML. Here is the updated HTML
    that references the script (named `cat.js`) and adds the needed IDs.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一行添加了一个事件处理器，当点击猫咪照片时会触发。事件处理器的代码在下一行定义，它告诉浏览器将文本`Meow!`添加到段落中。由于这是一个事件处理器，它只有在图片点击事件发生时才会运行。请注意，脚本通过
    ID 引用照片和段落，分别是`cat-photo`和`cat-para`。HTML 元素可以设置 ID；这使我们可以轻松地通过编程引用它们。我们的脚本只有在我们将这些
    ID 添加到 HTML 中时才有效。以下是更新后的 HTML，它引用了脚本（名为`cat.js`）并添加了所需的 ID。
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once the script code is saved as *cat.js*, and the HTML is updated as shown,
    then reloading the page and clicking the cat image appends `Meow!` to our paragraph.
    If we click the image multiple times, we end up with something like what is shown
    in [Figure 12-7](ch12.xhtml#ch12fig7).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本代码保存为*cat.js*，并且 HTML 按照所示方式更新后，重新加载页面并点击猫咪图片，就会将`Meow!`附加到段落中。如果我们多次点击该图片，我们最终会得到类似[图
    12-7](ch12.xhtml#ch12fig7)所示的效果。
- en: '![image](../images/fig12-7.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig12-7.jpg)'
- en: '*Figure 12-7: Our example web page after running JavaScript code to append
    text*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-7：运行 JavaScript 代码并附加文本后的示例网页*'
- en: '**NOTE**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #40](ch12.xhtml#proj40) on [page 289](ch12.xhtml#page_289),
    where you can update your web page with JavaScript*.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[项目 #40](ch12.xhtml#proj40)，在[第 289 页](ch12.xhtml#page_289)，你可以使用 JavaScript
    更新你的网页*。'
- en: JavaScript can be used to build full applications that run in a web browser.
    The previous example is a just a taste of what it can do. JavaScript is standardized
    in a specification known as *ECMAScript*. Various browsers implement script engines
    that attempt to comply with all or part of the ECMAScript standard, which is updated
    regularly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 可以用来构建在网页浏览器中运行的完整应用程序。前面的例子只是它能做的冰山一角。JavaScript 以 *ECMAScript*
    规范为标准化。各种浏览器实现了脚本引擎，力求遵守 ECMAScript 标准的全部或部分内容，该标准会定期更新。
- en: '***Structuring the Web’s Data with JSON and XML***'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 JSON 和 XML 构建网络数据结构***'
- en: Websites aren’t the only type of content available on the web. A *web service*
    provides data over HTTP and is intended to be interacted with programmatically.
    This is in contrast to a website that returns HTML (and related assets) and is
    intended for user consumption via a web browser. Most end users never directly
    interact with web services, although the websites and apps we use are often underpinned
    by web services.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 网站并不是网络上唯一的内容类型。*Web 服务*通过 HTTP 提供数据，旨在通过编程方式进行交互。这与返回 HTML（及相关资源）并旨在通过网页浏览器供用户消费的网站不同。大多数终端用户从不直接与
    Web 服务交互，尽管我们使用的网站和应用通常是由 Web 服务支撑的。
- en: Imagine that you run a website with information about local bands that perform
    in your city. The site contains a profile of each band, including band members,
    background, where the band will be playing, and so forth. An end user can visit
    your website and easily read up on their favorite musicians. Now, let’s say you’re
    approached by an app developer who wants to include the latest information from
    your website in their app. However, the app has its own presentation that’s totally
    different from your web pages—the developer doesn’t want to just display your
    web pages in the app. They need a way to get at the underlying data on your site.
    They could try to programmatically read your web pages and extract the relevant
    information, but this process is complicated and error-prone, particularly if
    your site’s layout changes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你经营着一个关于本地乐队信息的网站，网站包含每个乐队的资料，包括乐队成员、背景、演出地点等。终端用户可以访问你的网站，轻松阅读自己喜欢的音乐人的信息。现在，假设有一位应用开发者联系你，希望将你网站上的最新信息纳入他们的应用中。然而，该应用有自己完全不同的展示方式——开发者并不想仅仅在应用中展示你的网站页面。他们需要一种方式来获取你网站上底层的数据。他们可以尝试通过编程读取你的网站页面并提取相关信息，但这个过程复杂且容易出错，特别是如果你网站的布局发生变化时。
- en: You could make things much easier for this developer by providing a web service
    that presents the data from your site in a format other than HTML. Although HTML
    does provide a certain structure, it’s a structure that describes a document (headers,
    paragraphs, and so on) and provides little insight into the data types referenced
    in that document. HTML makes sense for a human reader, but it’s difficult for
    software to parse. So what format should your web service use to structure data
    about bands? The most common general-purpose data formats in use today by web
    services are XML and JSON.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供一个将网站数据以非 HTML 格式展示的 Web 服务，可以使得这个开发者的工作变得更加轻松。尽管 HTML 确实提供了一定的结构，但它描述的是一个文档的结构（如标题、段落等），并且对文档中引用的数据类型几乎没有提供任何见解。HTML
    对于人类读者是有意义的，但对软件来说解析起来困难。那么，你的 Web 服务应该使用什么格式来构建关于乐队的数据呢？当前 Web 服务中最常用的一般用途数据格式是
    XML 和 JSON。
- en: '*Extensible Markup Language (XML)* has been around since the 1990s and is a
    popular means of exchanging data over the web. Like HTML, it’s a text-based markup
    language, but rather than having a set of predefined tags, XML allows for custom
    tags that describe your data. In the case of our fictitious band information service,
    we might define a `<band>` tag and a `<concert>` tag. Let’s look at an imaginary
    band described using XML:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*可扩展标记语言 (XML)* 自 1990 年代以来就已出现，并且是一种流行的 Web 数据交换方式。像 HTML 一样，XML 是基于文本的标记语言，但与其预定义标签不同，XML
    允许使用自定义标签来描述数据。在我们虚构的乐队信息服务中，我们可能会定义一个 `<band>` 标签和一个 `<concert>` 标签。让我们看一下使用
    XML 描述的虚构乐队：'
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, the specific XML tags and their attributes are tailored to our
    needs, while the general structure of start tags, end tags, and tree hierarchy
    follows a pattern similar to HTML. The flexibility of XML, where tags can be arbitrarily
    defined, means that both the producer and the consumer of the XML need to agree
    on the expected tags and their meanings. This is true of HTML as well, but with
    HTML, all parties agree to a standard. In the case of XML, only the general format
    is standardized while the specific tags vary.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，具体的 XML 标签及其属性是根据我们的需求定制的，而开始标签、结束标签和树形结构的通用结构与 HTML 类似。XML 的灵活性使得标签可以被任意定义，这意味着
    XML 的生产者和消费者需要就预期的标签及其含义达成一致。HTML 也存在这个问题，但 HTML 中所有方参与方都同意一个标准。而在 XML 的情况下，只有通用格式是标准化的，具体标签则有所不同。
- en: XML is a popular method for sharing data over the web, with many web services
    using XML as their primary means of representing data. However, XML is verbose
    and parsing it properly can be tricky.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: XML 是一种流行的 Web 数据共享方法，许多 Web 服务将 XML 作为其主要的数据表示方式。然而，XML 的冗长性和正确解析它的难度是一个挑战。
- en: '*JavaScript Object Notation (JSON)*, like XML, is a method of describing data
    in a text format. JSON avoids using markup tags and instead embraces a style that’s
    similar to JavaScript’s syntax for describing objects, hence the name. In JSON,
    objects are wrapped in curly braces (`{` and `}`) and arrays (collections of objects)
    are enclosed in brackets (`[` and `]`). Its syntax is terser than XML, which is
    helpful in reducing the size of data transmitted over a network. The popularity
    of JSON rose in the 2010s, when it began to displace XML as the preferred data
    format for new web services. Here is the same imaginary band described in JSON:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScript 对象表示法 (JSON)*，和 XML 一样，是一种以文本格式描述数据的方法。JSON 避免使用标记标签，而是采用了一种类似于
    JavaScript 语法描述对象的风格，因此得名。在 JSON 中，对象用大括号（`{` 和 `}`）包裹，数组（对象的集合）用方括号（`[` 和 `]`）括起来。它的语法比
    XML 更简洁，这有助于减少通过网络传输的数据大小。JSON 的流行始于 2010 年代，当时它开始取代 XML 成为新 Web 服务首选的数据格式。以下是使用
    JSON 描述的相同虚构乐队：'
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Both XML and JSON ignore extra whitespace, so just like with HTML, we can remove
    all extra spaces, tabs, and line breaks without affecting how the data is interpreted.
    Doing so produces a fairly compact rendering of data, particularly in the case
    of JSON.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: XML 和 JSON 都会忽略多余的空白字符，因此，和 HTML 一样，我们可以去掉所有多余的空格、制表符和换行符，而不会影响数据的解释。这样做能生成相当紧凑的数据表示，尤其是在
    JSON 的情况下。
- en: XML and JSON are not formats meant for direct rendering in a web browser. Opening
    JSON or XML content in certain browsers may cause the browser to display something
    (perhaps a lightly formatted version of the data), but really JSON and XML aren’t
    intended to be directly consumed by web browsers. They are meant to be read by
    code that in turn does something useful with the data. Perhaps that code is a
    smartphone app that shows information about what bands are playing nearby, as
    in our example. Or maybe the code is client-side JavaScript that transforms JSON
    into HTML for a browser to display.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: XML 和 JSON 并不是为在网页浏览器中直接渲染而设计的格式。在某些浏览器中打开 JSON 或 XML 内容，可能会显示一些内容（也许是稍微格式化过的数据版本），但实际上，JSON
    和 XML 并不是为了被网页浏览器直接消费而设计的。它们是供代码读取，然后用数据做一些有用的事情。也许这些代码是一个智能手机应用，展示附近正在演出的乐队信息，就像我们示例中的情况。或者，也可能是客户端
    JavaScript 代码，将 JSON 转换为 HTML 供浏览器展示。
- en: '**Web Browsers**'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网页浏览器**'
- en: Now that we’ve covered the languages used to describe the web, let’s take a
    look at software on the client side of the web, the web browser. The first web
    browser was called *WorldWideWeb* (not to be confused with the subject of this
    chapter). It was developed by Tim Berners-Lee in 1990\. This first browser was
    the client for the first web server, *CERN httpd*. In a few years WorldWideWeb
    was supplanted by *Mosaic*, a browser that helped popularize the web. The next
    major browser release was *Netscape Navigator*, which also had a large following.
    In 1995, Microsoft released their first browser, *Internet Explorer*, as a direct
    competitor to Netscape Navigator, and Internet Explorer became the dominant browser
    of its time. Today, the browser landscape has shifted dramatically, and at the
    time of this writing, the dominant browsers are *Google Chrome*, *Apple Safari*,
    and *Mozilla Firefox*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讲解了用于描述网页的语言，让我们来看看网页客户端的软件 —— 网页浏览器。第一个网页浏览器叫做 *WorldWideWeb*（不要与本章讨论的主题混淆）。它是由蒂姆·伯纳斯-李（Tim
    Berners-Lee）于 1990 年开发的。这个第一个浏览器是第一个网页服务器 *CERN httpd* 的客户端。几年后，*WorldWideWeb*
    被 *Mosaic* 浏览器取代，后者帮助普及了互联网。接下来的主要浏览器发布是 *Netscape Navigator*，它也有大量的用户群体。1995
    年，微软发布了他们的第一个浏览器 *Internet Explorer*，作为 Netscape Navigator 的直接竞争对手，Internet Explorer
    成为了当时的主流浏览器。如今，浏览器市场发生了巨大变化，目前主流的浏览器是 *Google Chrome*、*Apple Safari* 和 *Mozilla
    Firefox*。
- en: '***Rendering a Page***'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***渲染页面***'
- en: Let’s now look at the process a web browser goes through to render a page. A
    typical visit to a website starts with a request of the default page of a site
    (such as *[http://www.example.com](http://www.example.com)/*) or a request of
    a specific page on the site (such as *[http://www.example.com/animals/cat.html](http://www.example.com/animals/cat.html)*).
    A user may enter this URL directly in the address bar, or the user could arrive
    at this URL by following a link. In either case, the browser requests the contents
    at the specified URL. Assuming the URL is valid and represents a web page, the
    server responds with HTML.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下网页浏览器渲染页面的过程。访问网站的典型流程从请求网站的默认页面（比如 *[http://www.example.com](http://www.example.com)/*）开始，或者请求网站上的特定页面（比如
    *[http://www.example.com/animals/cat.html](http://www.example.com/animals/cat.html)*）。用户可以直接在地址栏输入这个
    URL，或者通过点击链接来到这个 URL。无论哪种方式，浏览器都会请求指定 URL 的内容。如果 URL 是有效的并且代表一个网页，服务器就会返回 HTML
    内容。
- en: The web browser must then take the returned HTML and generate a DOM representation
    of the page. The HTML may contain references to other resources, like images,
    scripts, and style sheets. Each of these resources has its own URL, and the browser
    makes separate requests for each resource, as illustrated in [Figure 12-8](ch12.xhtml#ch12fig8).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，网页浏览器必须将返回的 HTML 解析并生成页面的 DOM 表示。HTML 可能包含对其他资源的引用，比如图片、脚本和样式表。每个资源都有自己的
    URL，浏览器会为每个资源单独发起请求，如[图 12-8](ch12.xhtml#ch12fig8)所示。
- en: '![image](../images/fig12-8.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig12-8.jpg)'
- en: '*Figure 12-8: A web browser requests a page and its referenced content*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-8：网页浏览器请求一个页面及其引用的内容*'
- en: Once the browser has retrieved the various resources of the page, it displays
    the HTML, using any specified CSS to determine the appropriate presentation. Any
    scripts are handed off to a JavaScript engine to run. JavaScript code may immediately
    make changes to the page, or it may register event handlers that run later when
    certain events occur. JavaScript code may also request data from a web service
    and use that data to update the page.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦浏览器检索到页面的各种资源，它会显示 HTML，并使用任何指定的 CSS 来确定适当的呈现方式。任何脚本都会交给 JavaScript 引擎运行。JavaScript
    代码可能立即对页面进行更改，或者它可能注册事件处理程序，在某些事件发生时再执行。JavaScript 代码也可以请求来自 Web 服务的数据，并使用这些数据来更新页面。
- en: 'Web browsers consist of a rendering engine (for HTML and CSS), a JavaScript
    engine, and a user interface that ties things together. Although the user interface
    provides the look and feel of the browser itself (such as the appearance of the
    back button and address bar), it’s the rendering engine and JavaScript engine
    that determine how websites are presented and behave (this includes things like
    how the page is laid out and how it responds to input). Since each rendering engine
    and JavaScript engine handle things slightly differently, a web page may look
    or act differently when viewed on different browsers. Ideally, all browsers would
    render content the same way, exactly as the site developer intended, but that’s
    not always the case. At the time of this writing, only three major rendering engines
    are in active development: WebKit, Blink, and Gecko.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Web 浏览器由一个渲染引擎（用于 HTML 和 CSS）、一个 JavaScript 引擎和一个将这些功能连接起来的用户界面组成。虽然用户界面提供了浏览器本身的外观和感觉（例如后退按钮和地址栏的外观），但正是渲染引擎和
    JavaScript 引擎决定了网站的呈现方式和行为（这包括页面如何布局以及如何响应输入等）。由于每个渲染引擎和 JavaScript 引擎的处理方式略有不同，网页在不同浏览器中的显示或行为可能会有所不同。理想情况下，所有浏览器应该以相同的方式渲染内容，完全按照网站开发者的意图，但现实情况并非总是如此。在撰写本文时，只有三个主要的渲染引擎正在积极开发：WebKit、Blink
    和 Gecko。
- en: '*WebKit* is the rendering engine and JavaScript engine for Apple’s Safari browser.
    It’s also used in applications found in the iOS App Store, since Apple requires
    all iOS apps that display web content to use this engine. *Blink*, which is a
    fork of WebKit, is the rendering engine for the *Chromium* open source project,
    which also includes the *V8* JavaScript engine. Chromium is the basis for Google
    Chrome and Opera. In December 2018, Microsoft announced that the *Microsoft Edge*
    browser would also be Chromium-based; Microsoft chose to halt development of its
    own rendering and JavaScript engines. That leaves only one major browser that
    doesn’t trace its roots to WebKit—Mozilla Firefox, which has its own *Gecko* rendering
    engine and *SpiderMonkey* JavaScript engine.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*WebKit* 是苹果 Safari 浏览器的渲染引擎和 JavaScript 引擎。它也被应用于 iOS 应用商店中的应用程序，因为苹果要求所有展示
    Web 内容的 iOS 应用都必须使用这个引擎。*Blink*，这是 WebKit 的一个分支，是 *Chromium* 开源项目的渲染引擎，该项目还包括
    *V8* JavaScript 引擎。Chromium 是 Google Chrome 和 Opera 的基础。在 2018 年 12 月，微软宣布其 *Microsoft
    Edge* 浏览器也将基于 Chromium；微软选择停止开发自己的渲染引擎和 JavaScript 引擎。现在只剩下一个主要的浏览器没有追溯到 WebKit——Mozilla
    Firefox，它拥有自己的 *Gecko* 渲染引擎和 *SpiderMonkey* JavaScript 引擎。'
- en: '**NOTE**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A software fork occurs when developers make a copy of a project’s source code
    and then make changes to that copy. This allows the original and forked projects
    to coexist as separate software*.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*软件分支（fork）发生在开发者复制一个项目的源代码并对其进行更改时。这使得原始项目和分支项目可以作为独立的软件共存*。'
- en: '***The User Agent String***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***用户代理字符串***'
- en: 'The formal, technical term for a web browser is a *user agent*. This term can
    be applied to other software as well (anything that acts on behalf of a user),
    but here we’re talking specifically about web browsers. This term pops up in technical
    documentation about the web, although it’s rarely used outside of formal communication.
    That said, one place where the term is used in practice is the *user agent string*.
    When a browser makes a request to a web server, it commonly includes a header
    value called `User-Agent` that describes the browser. As an example, here is the
    user agent string sent by Chrome (version 71) on Windows 10:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Web 浏览器的正式技术术语是*用户代理*。这个术语也可以应用于其他软件（任何代表用户执行操作的软件），但在这里我们特别讨论的是 Web 浏览器。这个术语出现在有关
    Web 的技术文档中，尽管在正式的交流之外很少使用。也就是说，术语实际使用的一个地方是*用户代理字符串*。当浏览器向 Web 服务器发出请求时，通常会包括一个名为`User-Agent`的头部值，用以描述浏览器。例如，下面是
    Windows 10 上 Chrome（版本 71）发送的用户代理字符串：
- en: '[PRE10]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This may seem contradictory. What does all this mean?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来似乎有些矛盾。这到底是什么意思呢？
- en: The first entry, `Mozilla/5.0`, is a holdover from the early days of the web.
    Mozilla was the user agent name for Netscape Navigator, and many sites specifically
    looked for “Mozilla” in the user agent string as an indicator to send the cutting-edge
    version of their website to the browser. At the time, other browsers wanted to
    get the best versions of websites too, so they identified themselves as Mozilla,
    even though they weren’t Mozilla at all. Fast forward to today, when essentially
    *every* browser identifies itself as Mozilla, and we find that portion of the
    user agent string fairly meaningless.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个条目 `Mozilla/5.0` 是网络早期的遗留物。Mozilla 曾是 Netscape Navigator 的用户代理名称，许多网站专门在用户代理字符串中寻找“Mozilla”以指示它们向浏览器发送网站的最新版本。那时，其他浏览器也希望获得网站的最佳版本，因此它们也自称是
    Mozilla，尽管根本不是 Mozilla。时至今日，几乎*每*个浏览器都自称是 Mozilla，我们发现这一部分的用户代理字符串其实没有多大意义。
- en: The next section in parentheses, `(Windows NT 10.0; Win64; x64)`, specifies
    the platform on which the browser is running.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 括号中的下一部分 `(Windows NT 10.0; Win64; x64)` 指定了浏览器运行的平台。
- en: Following that is the rendering engine, `AppleWebKit/537.36` in this case. As
    mentioned earlier, Chrome’s Blink engine is a fork of WebKit and still identifies
    itself as such. The following text, `(KHTML, like Gecko)`, is just a further elaboration
    on this; KHTML is a legacy engine that WebKit was based on.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着是渲染引擎，这里是 `AppleWebKit/537.36`。如前所述，Chrome 的 Blink 引擎是 WebKit 的一个分支，并且仍然自称如此。接下来的文本
    `(KHTML, like Gecko)` 进一步阐明了这一点；KHTML 是 WebKit 基于的一个遗留引擎。
- en: Now we get to the actual browser name and version, `Chrome/71.0.3578.98`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看实际的浏览器名称和版本，`Chrome/71.0.3578.98`。
- en: Finally, we have an awkward mention of Apple’s browser `Safari/537.36`, included
    for sites that give Safari special treatment. By including this text, Chrome attempts
    to ensure that those sites send it the same content that Safari would receive.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到一个尴尬的提及——苹果浏览器 `Safari/537.36`，它出现在某些网站需要对 Safari 特殊处理时。通过包括这段文本，Chrome
    尝试确保这些网站发送给它与 Safari 所接收的内容相同。
- en: That’s a rather complicated way to identify Chrome, but other browsers do the
    same kind of thing to ensure compatibility with all manner of websites. This complexity
    is an unfortunate side effect of historically fragmented capabilities in different
    browsers and websites that tried to send tailored versions of their content based
    on the particular browser. Browsers evolved so that today there is less variation
    in browser capabilities. However, many websites didn’t evolve and still send content
    tailored for specific browsers, forcing modern browsers to continue to trick old
    sites into believing they are communicating with a different browser.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当复杂的方式来标识 Chrome，但其他浏览器也做同样的事情，以确保与各种网站兼容。这种复杂性是不同浏览器和网站之间历史上功能碎片化的副作用，这些网站试图根据特定浏览器发送定制的内容。随着浏览器的发展，今天浏览器功能的差异性较小。然而，许多网站没有随之发展，仍然会为特定浏览器发送定制内容，迫使现代浏览器继续让旧网站相信它们正在与另一个浏览器通信。
- en: '**Web Servers**'
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网页服务器**'
- en: 'So far, we’ve focused primarily on the technologies used on the client side
    of the web. Web browsers speak a common trio of languages: HTML, CSS, and JavaScript.
    What about on the web’s server side? What languages and technologies are used
    to power web servers? In short, any programming language or technology can be
    used on a web server, as long as that technology can communicate over HTTP and
    return data in a format that the client understands.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要关注的是用于网页客户端的技术。网页浏览器使用三种常见的语言：HTML、CSS 和 JavaScript。那么，网页的服务器端呢？用于支持网页服务器的是什么语言和技术呢？简而言之，任何编程语言或技术都可以用于网页服务器，只要该技术能够通过
    HTTP 进行通信，并返回客户端能够理解的数据格式。
- en: Broadly speaking, websites are designed as either static or dynamic. A *static
    website* returns HTML, CSS, or JavaScript that was built ahead of time. Typically,
    the content of the site is stored in files on the server, and the server simply
    returns the contents of those files without modification. This means that any
    required runtime processing must be implemented in JavaScript that runs in the
    browser. On the other hand, a *dynamic website* performs processing on the server,
    generating HTML when a request comes in.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 广义上讲，网站可以分为静态和动态两种。*静态网站*返回的是提前构建好的 HTML、CSS 或 JavaScript。通常，网站内容存储在服务器上的文件中，服务器仅返回这些文件的内容而不做修改。这意味着任何需要的运行时处理必须通过浏览器中的
    JavaScript 来实现。另一方面，*动态网站*则在服务器上进行处理，当请求到来时生成 HTML。
- en: In the early days of the web, nearly everything was static. Pages were simple
    HTML, and there was little interactivity. As time went on, developers began adding
    code that ran on the web server, allowing the server to return dynamic content
    or accept a file upload or form submission from a user. This trend continued,
    and it became commonplace for requests to go through server-side processing before
    the server would respond.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的网络时代，几乎所有的内容都是静态的。页面是简单的HTML，几乎没有交互性。随着时间的推移，开发人员开始添加在Web服务器上运行的代码，使得服务器能够返回动态内容，或者接受用户上传的文件或表单提交。这一趋势持续发展，服务器端处理请求成为常见做法，直到服务器才响应。
- en: Let’s look at how server-side processing on a dynamic website typically works,
    as illustrated in [Figure 12-9](ch12.xhtml#ch12fig9). Assume that the dynamic
    website represented in [Figure 12-9](ch12.xhtml#ch12fig9) is a blog. A browser
    makes a request for a blog post. When the web server receives the request for
    the blog post, it reads the requested URL and determines that it needs to generate
    HTML. Code on the server then queries a database (which may be on the web server
    or on another server), retrieves the relevant blog text data, formats that text
    as HTML, and then responds to the client with that HTML. This approach is useful
    because it allows the content of a site to be managed separately from the website’s
    code, but dynamic sites also have some drawbacks. The increased complexity on
    the server means more work to set things up, a slower response at runtime, a potentially
    heavy load on the server, and an increased risk of security problems.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看动态网站的服务器端处理通常是如何工作的，如[图12-9](ch12.xhtml#ch12fig9)所示。假设[图12-9](ch12.xhtml#ch12fig9)中的动态网站是一个博客。浏览器请求一篇博客文章。当Web服务器收到请求时，它会读取请求的URL，并确定需要生成HTML。服务器上的代码然后查询数据库（可能是在Web服务器上，也可能在其他服务器上），获取相关的博客文本数据，将文本格式化为HTML，并将该HTML返回给客户端。这种方法很有用，因为它允许网站内容与网站代码分开管理，但动态网站也有一些缺点。服务器端的复杂性增加意味着设置工作更多，运行时响应更慢，服务器负载可能较重，而且安全问题的风险也增大。
- en: '![image](../images/fig12-9.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig12-9.jpg)'
- en: '*Figure 12-9: A typical dynamic website handles a request*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-9：典型的动态网站处理请求*'
- en: Recently, there has been a trend to move back to static sites where possible.
    The flow of a page request on a static site is shown in [Figure 12-10](ch12.xhtml#ch12fig10).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，出现了一种趋势，即尽可能回归静态网站。静态网站中页面请求的流动如[图12-10](ch12.xhtml#ch12fig10)所示。
- en: '![image](../images/fig12-10.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig12-10.jpg)'
- en: '*Figure 12-10: A static website handles a request*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-10：静态网站处理请求*'
- en: As shown in [Figure 12-10](ch12.xhtml#ch12fig10), the static website’s server-side
    processing is simplified, as compared to the dynamic site. The server-side processing
    on a static site is simply a matter of returning the static file that matches
    the requested URL. The content has already been built; the server does not need
    to retrieve raw data and format it. Reducing the complexity on the server side
    generally means simpler, faster, and more secure sites.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图12-10](ch12.xhtml#ch12fig10)所示，静态网站的服务器端处理相比于动态网站更为简化。静态网站的服务器端处理仅仅是返回与请求的URL匹配的静态文件。内容已经构建好，服务器无需再获取原始数据并格式化。减少服务器端的复杂性通常意味着网站更简单、更快速，并且更加安全。
- en: It is important to understand that in this context, the terms *static* and *dynamic*
    are from the server’s perspective, not the user’s. A static site’s content comes
    unchanged from files on the server, whereas a dynamic site’s content is generated
    on the server. The terms aren’t a description of how a user experiences the site,
    such as whether the site is interactive or if content is automatically updated.
    These experiences can be achieved using JavaScript in the browser, sometimes in
    conjunction with a separate web service, regardless of whether the website itself
    is static or dynamic.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的是，在这种语境下，*静态*和*动态*是从服务器的角度来看，而非用户的角度。静态网站的内容来自服务器上未更改的文件，而动态网站的内容则是由服务器生成的。这些术语并不描述用户体验网站的方式，例如网站是否具有交互性，或者内容是否会自动更新。这些体验可以通过浏览器中的JavaScript来实现，有时还会与独立的Web服务结合使用，无论网站本身是静态的还是动态的。
- en: 'If you’re hosting a static site, all you need is web server software that can
    respond to requests for your static files and serve the contents of those files.
    No custom code required. Many software packages and online services are available
    for hosting static sites. Typically, the software for serving a static site is
    configured to point to a directory of files on the server, and when a request
    comes in for a certain file, the server simply returns the contents of that file.
    For example, if the files for the website at *example.com* reside in a directory
    on the server called */websites/example*, then a request for *[http://example.com/images/cat.jpg](http://example.com/images/cat.jpg)*
    maps to */websites/example/images/cat.jpg*. The web server simply reads the matching
    file from its local directory and returns the bytes contained in that file to
    the client. The website developed in Projects #37 through #40 is an example of
    a static site.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你托管的是静态网站，你只需要一个能够响应静态文件请求并提供这些文件内容的网页服务器软件。无需编写自定义代码。许多软件包和在线服务都可以用于托管静态网站。通常，用于服务静态网站的软件会配置为指向服务器上的一个文件目录，当请求某个文件时，服务器只需返回该文件的内容。例如，如果位于*example.com*的网页文件存放在服务器上的目录*/websites/example*中，那么对*
    [http://example.com/images/cat.jpg](http://example.com/images/cat.jpg)*的请求将映射到*/websites/example/images/cat.jpg*。网页服务器只需从本地目录读取匹配的文件，并将该文件中包含的字节返回给客户端。在项目#37到#40中开发的网站就是一个静态网站的例子。
- en: If you’re building a dynamic website or web service, either you can use existing
    software that manages your content and serves up dynamic pages, or you can write
    your own custom code that generates web content. Assuming you’re writing custom
    code, you’ll find things are quite different on the server side as compared to
    the client side of web development. Any programming language, any operating system,
    any platform can be used for a web server. Anything goes, as long as the web server
    responds over HTTP and returns data in a format that the client understands! The
    client doesn’t care what technologies were used to generate HTML or JavaScript;
    it just needs a response in a format it can handle.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建一个动态网站或网络服务，你可以选择使用现有的软件来管理你的内容并提供动态页面，或者你可以编写自定义代码来生成网页内容。假设你在编写自定义代码，你会发现与客户端开发相比，服务器端的情况截然不同。任何编程语言、任何操作系统、任何平台都可以用作网页服务器。只要网页服务器通过HTTP响应并返回客户端可以理解的格式的数据，几乎什么技术都可以！客户端并不关心生成HTML或JavaScript时使用了什么技术，它只需要一个它能够处理的格式的响应。
- en: Since it doesn’t really matter to clients what technology is used on the web
    server side, many options are available to developers who wish to write code that
    runs on the server. Client-side web development is limited to the trio of HTML,
    CSS, and JavaScript, whereas server-side web development can take place in Python,
    C#, JavaScript, Java, Ruby, PHP, and more. Server-side web development often includes
    interfacing with a database of some kind. In the same way that any programming
    language can be used on the server, any kind of database can be used for server-side
    web development.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于客户端并不关心网页服务器端使用了什么技术，因此希望编写在服务器上运行代码的开发者有很多选择。客户端网页开发仅限于HTML、CSS和JavaScript三者，而服务器端网页开发可以使用Python、C#、JavaScript、Java、Ruby、PHP等多种语言。服务器端网页开发通常包括与某种数据库的交互。就像任何编程语言都可以用于服务器一样，任何类型的数据库也可以用于服务器端网页开发。
- en: '**Summary**'
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter we covered the web—a set of distributed, addressable, linked
    resources, delivered by HTTP over the internet. You learned how web pages are
    structured with HTML, styled with CSS, and scripted with JavaScript. We looked
    at web browsers, which are used to access content on the web, and we examined
    web servers—the software that hosts web resources. In the next chapter, we’ll
    look at some trends in modern computing, and you’ll have a chance to complete
    a final project that ties together various concepts found throughout this book.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们讨论了网页——一个分布式的、可寻址的、相互链接的资源集合，通过HTTP在互联网中传输。你学习了网页如何使用HTML进行结构化，使用CSS进行样式化，使用JavaScript进行脚本化。我们还探讨了网页浏览器，它们用于访问网页上的内容，并且我们检查了网页服务器——托管网页资源的软件。在下一章中，我们将探讨一些现代计算的趋势，并且你将有机会完成一个最终项目，将本书中各个概念结合起来。
- en: '**PROJECT #36: EXAMINE HTTP TRAFFIC**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #36：检查HTTP流量**'
- en: In this project, you’ll use Google Chrome or Chromium to examine HTTP traffic
    between a web browser and a web server. You can either use Chrome on a Windows
    PC or a Mac, or use the Chromium web browser on your Raspberry Pi. The following
    steps assume you’re using a Raspberry Pi, but the process is similar on a Windows
    PC or a Mac; just use Chrome instead of Chromium.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用Google Chrome或Chromium来检查web浏览器与web服务器之间的HTTP流量。你可以在Windows PC或Mac上使用Chrome，或者在Raspberry
    Pi上使用Chromium浏览器。以下步骤假设你在使用Raspberry Pi，但在Windows PC或Mac上的过程类似，只需使用Chrome代替Chromium。
- en: If you aren’t using the graphical desktop on your Raspberry Pi, switch to it
    now. Unlike previous projects, this project cannot be completed from a terminal
    window.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你没有使用Raspberry Pi的图形桌面界面，赶紧切换过去。与之前的项目不同，这个项目不能仅通过终端窗口完成。
- en: Click **Raspberry** (icon in the upper left corner)▶ **Internet**▶ **Chromium
    Web Browser**.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Raspberry**（左上角的图标）▶ **Internet**▶ **Chromium Web Browser**。
- en: Go to a website, such as *[http://www.example.com](http://www.example.com)*.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问一个网站，如*[http://www.example.com](http://www.example.com)*。
- en: Press the F12 key (or CTRL-SHIFT-I) to open the developer tools (DevTools),
    shown in [Figure 12-11](ch12.xhtml#ch12fig11).![image](../images/fig12-11.jpg)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下F12键（或CTRL-SHIFT-I）打开开发者工具（DevTools），如[图12-11](ch12.xhtml#ch12fig11)所示。![image](../images/fig12-11.jpg)
- en: '*Figure 12-11: Developer tools in Chromium*'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图12-11：Chromium中的开发者工具*'
- en: On the DevTools menu, choose the **Network** menu item.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在DevTools菜单中，选择**Network**菜单项。
- en: Press F5 (or hit the reload icon) to reload the page. You’ll see the HTTP requests
    that are made to load the page you’re currently visiting.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下F5键（或点击重载图标）重新加载页面。你将看到加载当前页面时发出的HTTP请求。
- en: If you actually use *www.example.com* you’ll likely see a fairly boring request.
    If you want to see something more interesting, visit a more complicated site and
    watch the network requests, as shown in [Figure 12-12](ch12.xhtml#ch12fig12).![image](../images/fig12-12.jpg)
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你实际使用*www.example.com*，你可能会看到一个相当简单的请求。如果你想看到更有趣的内容，可以访问一个更复杂的网站，并观察网络请求，如[图12-12](ch12.xhtml#ch12fig12)所示。![image](../images/fig12-12.jpg)
- en: '*Figure 12-12: Example of HTTP traffic for a website shown in Chromium’s DevTools*'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图12-12：Chromium开发者工具中显示的一个网站的HTTP流量示例*'
- en: Each line represents a request to the web server. You can see the resource name
    that was requested, the status of the request (`200` means success), and more.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每一行代表对web服务器的一个请求。你可以看到请求的资源名称、请求的状态（`200`表示成功）等信息。
- en: You can click each line and see the specifics of the request, such as the headers
    and the content returned.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以点击每一行，查看请求的具体内容，例如请求头和返回的内容。
- en: 'I recommend you try this on several websites to get a feel for the number of
    requests made for a site. You may be surprised at how much content is transferred!  **PROJECT
    #37: RUN YOUR OWN WEB SERVER**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你在多个网站上尝试一下，了解网站请求的数量。你可能会对传输的内容量感到惊讶！ **项目#37：运行你自己的Web服务器**
- en: In this project, you’ll set up a Raspberry Pi to act as a web server. You’ll
    use Python 3 to do this, so you can actually follow these steps on any device
    with Python 3 installed, although the steps here were written with the Raspberry
    Pi in mind. Our simple website will return the contents of a file when it receives
    a request.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将设置一个Raspberry Pi作为web服务器。你将使用Python 3来完成这一过程，因此你实际上可以在任何安装了Python 3的设备上跟随这些步骤，尽管这些步骤是针对Raspberry
    Pi编写的。我们简单的网站将在收到请求时返回一个文件的内容。
- en: Open a terminal window and create a directory that will hold the files your
    website will serve, and then set that new directory as your current directory.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，创建一个目录来存放你的网站文件，然后将该新目录设置为当前工作目录。
- en: '[PRE11]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When a request is made to the root of your website, the web server software
    looks for a file named *index.html* and returns the contents of that file to the
    client. Let’s create a very simple *index.html* file:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当向你网站的根目录发起请求时，web服务器软件会查找名为*index.html*的文件，并将该文件的内容返回给客户端。让我们创建一个非常简单的*index.html*文件：
- en: '[PRE12]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'That command creates a text file named *index.html* with the text `Hello, Web!`
    in the file. You can view the contents of the text file to ensure it was created
    successfully by opening the file in a text editor, or you can display the contents
    in the terminal like so:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令创建了一个名为*index.html*的文本文件，文件中包含`Hello, Web!`的文本。你可以通过文本编辑器打开文件来查看文件内容，或者像这样在终端中显示文件内容：
- en: '[PRE13]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once your file is in place, let’s use Python’s built-in web server to serve
    up your `Hello, Web!` message to anyone who connects.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件就绪，让我们使用 Python 内建的 web 服务器将 `Hello, Web!` 信息提供给任何连接的用户。
- en: '[PRE14]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This command tells Python to run an HTTP server on port `8888`. Let’s test
    this out to see if it’s working as expected. Open another terminal window on your
    Raspberry Pi. From this second terminal window, enter the following command to
    make a `GET` request to the root of your new website:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令告诉 Python 在端口`8888`上运行一个 HTTP 服务器。让我们测试一下，看看它是否按预期工作。打开树莓派上的另一个终端窗口。从这个第二个终端窗口，输入以下命令向你新网站的根目录发起一个
    `GET` 请求：
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `curl` utility can be used to make HTTP `GET` requests, and `localhost`
    is a hostname that refers to the computer you’re currently using. This command
    tells the `curl` utility to perform an HTTP `GET` to port `8888` on the local
    computer. You should see the text `Hello, Web!` returned. Also, back in the original
    terminal, you should see that a `GET` request came in.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl` 工具可以用来发起 HTTP `GET` 请求，而 `localhost` 是指当前正在使用的计算机的主机名。此命令告诉 `curl` 工具向本地计算机的端口
    `8888` 发起一个 HTTP `GET` 请求。你应该会看到返回的文本是 `Hello, Web!`。同时，在原始终端中，你应该看到一个 `GET` 请求已经到达。'
- en: Now, let’s try connecting to your website from a web browser. From the Raspberry
    Pi desktop, open the Chromium web browser. In the address bar, enter http://localhost:8888.
    You should see the text from your website appear in the browser, as shown in [Figure
    12-13](ch12.xhtml#ch12fig13).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试通过网页浏览器连接到你的网站。在树莓派桌面上，打开 Chromium 浏览器。在地址栏中输入 http://localhost:8888。你应该会看到网站中的文本出现在浏览器中，如[图
    12-13](ch12.xhtml#ch12fig13)所示。
- en: '![image](../images/fig12-13.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig12-13.jpg)'
- en: '*Figure 12-13: Connecting to a local web server using the Chromium browser*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-13：使用 Chromium 浏览器连接到本地 web 服务器*'
- en: 'Now try connecting to your website from another device. For this to work, the
    second device has to be on the same network as your Raspberry Pi. For example,
    they should both be on the same Wi-Fi network. Or, if your Raspberry Pi has a
    public IP address (see [Project #34](ch11.xhtml#proj34) on [page 259](ch11.xhtml#page_259)),
    then your website is available to any device on the internet! First, get your
    Raspberry Pi’s IP address by running the following command in the second terminal
    window:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '现在尝试从另一台设备连接到你的网站。为了使这项工作正常进行，第二台设备必须与树莓派在同一网络上。例如，它们应该都连接到同一个 Wi-Fi 网络。或者，如果你的树莓派有公共
    IP 地址（参见[项目 #34](ch11.xhtml#proj34)在[第 259 页](ch11.xhtml#page_259)），那么你的网站可以供互联网上的任何设备访问！首先，通过在第二个终端窗口中运行以下命令获取树莓派的
    IP 地址：'
- en: '[PRE16]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This likely returns several IP addresses. You can’t use `127.0.0.1` when connecting
    from a remote device, so choose another IP address assigned to your Raspberry
    Pi. Once you have the IP address, open a browser on another device. This can be
    a smartphone, laptop, or really any device on your network that has a web browser.
    In the browser window, enter the following in the address bar: *`http://w.x.y.z:8888`*
    (replacing *`w.x.y.z`* with the IP address of your device). Press ENTER or the
    appropriate button in the browser to navigate to that address. You should see
    `Hello, Web!` appear in the browser.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常会返回几个 IP 地址。从远程设备连接时，你不能使用 `127.0.0.1`，因此选择分配给你树莓派的另一个 IP 地址。拿到 IP 地址后，打开另一台设备上的浏览器。可以是智能手机、笔记本电脑，或者任何在你网络上的设备，只要它有网页浏览器。在浏览器窗口的地址栏中输入以下内容：*`http://w.x.y.z:8888`*（将
    *`w.x.y.z`* 替换为你设备的 IP 地址）。按下回车键或浏览器中的相应按钮以导航到该地址。你应该会在浏览器中看到 `Hello, Web!` 的字样。
- en: If this didn’t work for you, and your Raspberry Pi does not have a public IP
    address, make sure the two devices are on the same physical local network. Also,
    sometimes the Python web server becomes unresponsive to new requests. If the web
    server stops responding, you can restart it. To stop the web server, go to the
    terminal where the server command was executed, and press CTRL-C on the keyboard.
    Then restart the server by running the python3 -m http.server 8888 command again
    (press the keyboard up arrow to get the last command).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对你不起作用，且你的树莓派没有公共 IP 地址，请确保两台设备在同一物理局域网中。此外，有时 Python web 服务器会对新请求无响应。如果
    web 服务器停止响应，你可以重启它。要停止 web 服务器，请转到执行服务器命令的终端，按下 CTRL-C 键。然后通过再次运行 `python3 -m
    http.server 8888` 命令重新启动服务器（按键盘上的上箭头键可以获取上一个命令）。
- en: Once you have your site working, try editing the *index.html* file and change
    the message to say whatever you want. You can use the text editor of your choice
    to do this. Once your *index.html* file is updated, reload the web page in a web
    browser to see your changes!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的网站运行正常，尝试编辑*index.html*文件，并将信息更改为你想要的任何内容。你可以使用任何你喜欢的文本编辑器来完成此操作。更新完*index.html*文件后，重新加载网页以查看你的更改！
- en: 'If you don’t want other devices to be able to access your website, you can
    restrict things so that only requests from the Raspberry Pi itself get a response.
    Running the Python web server with the `--bind` option can accomplish this, like
    so:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不希望其他设备能够访问你的网站，你可以限制只允许来自树莓派本身的请求获得响应。通过使用`--bind`选项运行Python网页服务器可以实现这一点，方法如下：
- en: '[PRE17]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To run the web server with the `--bind` option, you first need to stop any running
    instance of the web server (press CTRL-C on the keyboard).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`--bind`选项运行网页服务器，首先需要停止任何正在运行的网页服务器实例（按键盘上的CTRL-C）。
- en: '**PROJECT #38: RETURN HTML FROM YOUR WEB SERVER**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #38：从网页服务器返回HTML**'
- en: 'Prerequisite: [Project #37](ch12.xhtml#proj37).'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '前提条件：[项目 #37](ch12.xhtml#proj37)。'
- en: 'In this project, you’ll update your local web server to return HTML instead
    of simple text. Use the text editor of your choice to open *index.html* (that
    was created in [Project #37](ch12.xhtml#proj37)) and replace all the text in the
    file with the following HTML. This is the same HTML code that was discussed in
    the chapter. You don’t need to worry about the indentation of each line, since
    extra whitespace in HTML doesn’t matter.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '在本项目中，你将更新本地网页服务器，使其返回HTML而不是简单的文本。使用你喜欢的文本编辑器打开*index.html*（在[项目 #37](ch12.xhtml#proj37)中创建的文件），并用以下HTML代码替换文件中的所有文本。这是本章中讨论的相同HTML代码。你无需担心每行的缩进，因为HTML中多余的空白字符是无关紧要的。'
- en: '[PRE18]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once your file has been updated, you’ll use Python’s built-in web server again.
    If it isn’t already running, start it with this command. Just be sure that your
    terminal window is currently in the *web* directory before running the command.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件更新完成，你将再次使用Python的内置网页服务器。如果它还未运行，使用此命令启动它。在运行命令之前，请确保你的终端窗口当前位于*web*目录中。
- en: '[PRE19]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, use a web browser to connect to your web server as you did in [Project
    #37](ch12.xhtml#proj37). You should see the page rendered, but without the cat
    photo. If you look at the terminal window where you ran the Python web server
    command, you should see an attempt to get the cat photo that failed, like so:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，使用网页浏览器像在[项目 #37](ch12.xhtml#proj37)中那样连接到你的网页服务器。你应该看到页面被渲染，但没有猫咪照片。如果你查看运行Python网页服务器命令的终端窗口，你应该看到一个尝试获取猫咪照片但失败的请求，如下所示：'
- en: '[PRE20]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `404` error code indicates that the resource can’t be found, which makes
    sense given that you don’t have a file named *cat.jpg* in this directory! Why
    did the web browser even ask for a cat photo? If you look back at the HTML for
    the page, you see an HTML `<img>` tag that directs the browser to render the `cat.jpg`
    image. The browser requests the image, but it fails to retrieve it since the file
    is missing.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`404`错误代码表示无法找到资源，这很合理，因为你在这个目录中没有名为*cat.jpg*的文件！为什么网页浏览器会请求一张猫咪照片呢？如果你回顾页面的HTML，会看到一个HTML
    `<img>`标签，它指示浏览器渲染`cat.jpg`图片。浏览器请求该图片，但由于文件缺失，无法成功获取。'
- en: Let’s fix the missing cat image issue. You need to download an image of a cat
    (or an image of anything really) in JPEG format and save it as *~/web/cat.jpg*.
    To make this easy, you can download the image used in the chapter with the following
    command. Be sure that your terminal window is currently in the *web* directory
    before running the command.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决丢失的猫咪图片问题。你需要下载一张猫的图片（或者任何东西的图片都可以），格式为JPEG，并将其保存为*~/web/cat.jpg*。为了简化，你可以使用以下命令下载本章中使用的图片。在运行命令之前，请确保你的终端窗口当前位于*web*目录中。
- en: '[PRE21]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should now have *cat.jpg* stored in your *web* directory. Reload the page
    in a web browser to see the cat image in the page. Reminder: if the web server
    seems stuck, restart it as described in [Project #37](ch12.xhtml#proj37).'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，你应该在*web*目录中存有*cat.jpg*文件。重新加载网页，查看页面中的猫咪图片。提醒：如果网页服务器似乎卡住了，按照[项目 #37](ch12.xhtml#proj37)中的描述重新启动它。'
- en: 'It’s worth noting that not only can you view the cat image in your page, but
    you can also request the image directly from the server, since it has its own
    URL. Try pointing your browser to the following URL (replacing *`SERVER`* with
    the hostname or IP address you’ve been using for your website): `http://*SERVER*:8888/cat.jpg`.
    You should see the cat image rendered in the browser, outside of the web page.
    Every resource referenced on a web page has its own URL and can be accessed directly!'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，你不仅可以在页面中查看猫的图片，还可以直接从服务器请求该图片，因为它有自己的URL。试着将浏览器指向以下URL（将*`SERVER`*替换为你为网站使用的主机名或IP地址）：`http://*SERVER*:8888/cat.jpg`。你应该能看到猫的图片在浏览器中显示出来，且不依赖于网页的内容。网页上引用的每个资源都有自己的URL，可以直接访问！
- en: '**PROJECT #39: ADD CSS TO YOUR WEBSITE**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #39：为你的网页添加CSS**'
- en: 'Prerequisite: [Project #38](ch12.xhtml#proj38).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '前提条件：[项目 #38](ch12.xhtml#proj38)。'
- en: 'In this project, you’ll use CSS to style your website. First, use the text
    editor of your choice to create a file named *style.css* in the *web* directory.
    This file will contain your CSS rules. Be sure the file is named *style.css* and
    is saved to the *web* directory alongside your *index.html* and *cat.jpg* files.
    The contents of *style.css* should be the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用CSS来设计你的网页。首先，使用你选择的文本编辑器，在*web*目录下创建一个名为*style.css*的文件。这个文件将包含你的CSS规则。确保文件名为*style.css*，并将其保存到*web*目录，与*index.html*和*cat.jpg*文件一起。*style.css*的内容应如下所示：
- en: '[PRE22]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once *style.css* has been created, open *index.html* for editing, as you did
    in the previous project. Leave the existing HTML in place. We just want to add
    a single line to the head section, as shown here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦*style.css*创建完成，就像在上一个项目中那样，打开*index.html*进行编辑。保留现有的HTML内容。我们只需要在头部区域添加一行，如下所示：
- en: '[PRE23]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once you’ve made this update ❶ to *index.html*, start your web server (if it
    isn’t already running), and reload the page in your web browser. You should see
    the style of the page update. Reminder: if the web server seems stuck, restart
    it as described in [Project #37](ch12.xhtml#proj37).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦你完成了对*index.html*的更新❶，启动你的web服务器（如果它还没有运行的话），并在浏览器中重新加载页面。你应该能看到页面样式的更新。提醒：如果web服务器似乎卡住了，按照[项目
    #37](ch12.xhtml#proj37)中描述的步骤重新启动它。'
- en: Feel free to edit *style.css* to try different styles. Maybe you want to make
    the paragraph font huge or a different color! Edit the style to your liking, save
    *style.css*, and reload the page in your browser.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 随意编辑*style.css*以尝试不同的样式。也许你想把段落字体设得非常大，或者换个颜色！根据自己的喜好编辑样式，保存*style.css*并在浏览器中重新加载页面。
- en: If you aren’t seeing your updates reflected in the browser, it may be because
    your web browser is loading a cached copy of your website rather than downloading
    the latest version. Try opening the page in a new tab or restarting the browser
    altogether. You can also tell your browser to bypass its local cache when reloading.
    To do this, navigate to the page, and then press CTRL-F5 to force the page to
    reload. This works on most browsers on Windows and Linux. On a Mac, you can force
    a refresh in Chrome and Firefox with CMD-SHIFT-R. Sometimes multiple refreshes
    are needed before the browser renders the latest content.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在浏览器中没有看到更新，可能是因为浏览器加载了你网站的缓存版本，而不是下载最新的版本。试着在新标签页中打开页面，或者完全重新启动浏览器。你还可以告诉浏览器在重新加载时跳过本地缓存。为此，请导航到页面，然后按CTRL-F5强制页面重新加载。大多数Windows和Linux浏览器都支持此操作。在Mac上，Chrome和Firefox可以通过CMD-SHIFT-R强制刷新。有时需要多次刷新才能让浏览器渲染最新的内容。
- en: '**PROJECT #40: ADD JAVASCRIPT TO YOUR WEBSITE**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #40：为你的网页添加JavaScript**'
- en: 'Prerequisite: [Project #39](ch12.xhtml#proj39).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '前提条件：[项目 #39](ch12.xhtml#proj39)。'
- en: 'In this project, you’ll use JavaScript to make your website interactive. First,
    use the text editor of your choice to create a file named *cat.js* in the *web*
    directory. This file will contain JavaScript code. Be sure the file is named *cat.js*
    and is saved to the *web* directory alongside your *index.html* and *cat.jpg*
    files. The contents of *cat.js* should be the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用JavaScript让你的网页具备交互性。首先，使用你选择的文本编辑器，在*web*目录下创建一个名为*cat.js*的文件。这个文件将包含JavaScript代码。确保文件名为*cat.js*，并将其保存到*web*目录，与*index.html*和*cat.jpg*文件一起。*cat.js*的内容应如下所示：
- en: '[PRE24]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once *cat.js* has been saved, open *index.html* for editing, as you did in
    the previous project. Leave the existing HTML in place and make the changes shown
    here:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦*cat.js*被保存，像在上一个项目中那样，打开*index.html*进行编辑。保留现有的HTML内容，并按照下面所示进行更改：
- en: '[PRE25]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: These changes reference the script ❶ and give IDs to the paragraph ❷ and image
    ❸.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改引用了脚本 ❶，并给段落 ❷ 和图片 ❸ 添加了 ID。
- en: 'Once you’ve made this update to *index.html*, start your web server (if it
    isn’t already running), and reload the page in a web browser. You should now be
    able to click (or touch) the cat photo and see the word `Meow!` appended to the
    paragraph. Reminder: if the web server seems stuck, restart it as described in
    [Project #37](ch12.xhtml#proj37).'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦你更新了*index.html*，启动你的 web 服务器（如果它尚未运行），并在浏览器中重新加载页面。现在你应该能够点击（或触摸）猫的照片，并看到单词`Meow!`被附加到段落中。提醒：如果
    web 服务器似乎卡住，按[项目 #37](ch12.xhtml#proj37)中的描述重启它。'
