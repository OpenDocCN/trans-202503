- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">EARLY
    LAUNCH ANTIMALWARE DRIVERS</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">早期启动反恶意软件驱动程序</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: In 2012, adversaries launched the Zacinlo adware campaign, whose rootkit, a
    member of the Detrahere family, includes a number of self-protection features.
    One of the most interesting is its persistence mechanism.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 2012年，攻击者发起了 Zacinlo 广告软件攻击活动，其根工具包是 Detrahere 家族的一员，包含了一些自我保护功能。最有趣的功能之一是其持久性机制。
- en: Similar to the callback routines discussed in [Chapters 3](chapter3.xhtml) through
    [5](chapter5.xhtml), drivers can register callback routines called *shutdown handlers*
    that let them perform some action when the system is shutting down. To ensure
    that their rootkit persisted on the system, the Zacinlo rootkit developers used
    a shutdown handler to rewrite the driver to disk under a new name and create new
    registry keys for a service that would relaunch the rootkit as a boot-start driver.
    If anyone made an attempt to clean the rootkit from the system, the driver would
    simply drop these files and keys, allowing it to persist much more effectively.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第3章](chapter3.xhtml)至[第5章](chapter5.xhtml)中讨论的回调例程类似，驱动程序可以注册称为*关机处理程序*的回调例程，在系统关闭时执行某些操作。为了确保其根工具包能在系统中持久存在，Zacinlo
    根工具包的开发者使用了一个关机处理程序，将驱动程序以新名称重写到磁盘上，并为一个服务创建新的注册表键，该服务将重新启动根工具包作为启动驱动程序。如果有人试图清除系统中的根工具包，驱动程序会简单地丢弃这些文件和键，从而使其更加有效地保持持久性。
- en: 'While this malware is no longer prevalent, it highlights a large gap in protection
    software: the ability to mitigate threats that operate early in the boot process.
    To address this weakness, Microsoft introduced a new antimalware feature in Windows
    8 that allows certain special drivers to load before all other boot-start drivers.
    Today, nearly all EDR vendors leverage this capability, called *Early Launch Antimalware
    (ELAM)*, in some way, as it offers the ability to affect the system extremely
    early in the boot process. It also provides access to specific types of system
    telemetry not available to other components.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种恶意软件现在已经不再流行，但它突显了保护软件中的一个巨大漏洞：无法缓解在启动过程早期运行的威胁。为了解决这个问题，微软在 Windows 8 中引入了一项新的反恶意软件功能，允许某些特殊驱动程序在所有其他启动驱动程序之前加载。如今，几乎所有的
    EDR 厂商都以某种方式利用这一功能，称为*早期启动反恶意软件（ELAM）*，因为它能够在系统启动过程的非常早期就对系统产生影响。它还提供了对某些类型的系统遥测数据的访问，这些数据对其他组件不可用。
- en: This chapter covers the development, deployment, and boot-start protection functionality
    of ELAM drivers, as well as strategies for evading these drivers. In [Chapter
    12](chapter12.xhtml), we’ll cover the telemetry sources and process protections
    available to vendors that deploy ELAM drivers to hosts.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 ELAM 驱动程序的开发、部署和启动保护功能，以及规避这些驱动程序的策略。在[第12章](chapter12.xhtml)中，我们将介绍为部署
    ELAM 驱动程序到主机的厂商提供的遥测源和进程保护。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How ELAM Drivers Protect the Boot Process</samp>
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">ELAM 驱动程序如何保护启动过程</samp>
- en: Microsoft lets third-party drivers load early in the boot process so that software
    vendors can initialize those that are critical to the system. However, this is
    a double-edged sword. While it provides a useful way to guarantee the loading
    of critical drivers, malware authors too can insert their rootkits into these
    early-load-order groups. If a malicious driver is able to load before antivirus
    or other security-related drivers, it could tamper with the system to keep those
    protection drivers from working as intended or prevent them from loading in the
    first place.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 微软允许第三方驱动程序在启动过程中早期加载，以便软件厂商可以初始化那些对系统至关重要的驱动程序。然而，这也是一把双刃剑。虽然它为确保加载关键驱动程序提供了一种有用的方式，但恶意软件作者也可以将其根工具包插入到这些早期加载顺序组中。如果恶意驱动程序能够在杀毒软件或其他安全相关驱动程序之前加载，它可能会篡改系统，阻止这些保护驱动程序按预期工作，甚至根本阻止它们加载。
- en: To avoid these attacks, Microsoft needed a way to load endpoint security drivers
    earlier in the boot process, before any malicious driver can load. The primary
    function of an ELAM driver is to receive notifications when another driver attempts
    to load during the boot process, then decide whether to allow it to load. This
    validation process is part of Trusted Boot, the Windows security feature responsible
    for validating the digital signature of the kernel and other components, like
    drivers, and only vetted antimalware vendors can participate in it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些攻击，微软需要一种方法，在启动过程的早期加载端点安全驱动程序，以便在任何恶意驱动程序加载之前进行加载。ELAM 驱动程序的主要功能是在启动过程中，当其他驱动程序尝试加载时接收通知，然后决定是否允许其加载。此验证过程是受信启动的一部分，受信启动是
    Windows 的一项安全功能，负责验证内核和其他组件（如驱动程序）的数字签名，只有经过验证的反恶意软件供应商才能参与。
- en: To publish an ELAM driver, developers must be part of the Microsoft Virus Initiative
    (MVI), a program open to antimalware companies that produce security software
    for the Windows operating system. As of this writing, in order to qualify to participate
    in this program, vendors must have a positive reputation (assessed by conference
    participation and industry-standard reports, among other factors), submit their
    applications to Microsoft for performance testing and feature review, and provide
    their solution for independent testing. Vendors must also sign a nondisclosure
    agreement, which is likely why those with knowledge of this program have been
    tight-lipped.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要发布 ELAM 驱动程序，开发者必须是微软病毒计划（MVI）的一部分，这是一个面向为 Windows 操作系统开发安全软件的反恶意软件公司的计划。截至本文写作时，为了有资格参与该计划，供应商必须具有良好的声誉（通过参加会议和行业标准报告等因素进行评估），向微软提交性能测试和功能审核的申请，并提供解决方案进行独立测试。供应商还必须签署保密协议，这可能是那些了解该计划的人保持沉默的原因。
- en: The Microsoft Virus Initiative and ELAM are closely tied. To create a *production
    driver* (one that can be deployed to systems not in test-signing mode), Microsoft
    must countersign the driver. This countersignature uses a special certificate,
    visible in the ELAM driver’s digital signature information under *Microsoft Windows
    Early Launch Anti-malware Publisher*, as shown in [Figure 11-1](#fig11-1). This
    countersignature is available to participants of the Microsoft Virus Initiative
    program only.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 微软病毒计划与 ELAM 密切相关。要创建*生产驱动程序*（即可以部署到非测试签名模式的系统中的驱动程序），微软必须对驱动程序进行反签名。此反签名使用一个特殊证书，在
    ELAM 驱动程序的数字签名信息中可以看到，显示为*Microsoft Windows Early Launch Anti-malware Publisher*，如[图
    11-1](#fig11-1)所示。只有微软病毒计划的参与者才能获得此反签名。
- en: '![](../images/Figure11-1.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-1: Microsoft’s countersignature
    on an ELAM driver</samp>'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-1：微软在 ELAM 驱动程序上的反签名</samp>
- en: Without this signature, the driver won’t be able to load as part of the *Early-Launch*
    service group discussed in “Loading an ELAM Driver” on [page 208](#sec6). For
    this reason, the examples in this chapter target a system with test-signing enabled,
    allowing us to ignore the countersigning requirement. The process and code described
    here are the same as for production ELAM drivers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有此签名，驱动程序将无法作为*早期启动*服务组的一部分加载，详细内容请参见[第 208 页](#sec6)中的“加载 ELAM 驱动程序”部分。因此，本章中的示例针对启用了测试签名的系统，这样我们就可以忽略反签名的要求。这里描述的过程和代码与生产环境中的
    ELAM 驱动程序相同。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Developing ELAM Drivers</samp>
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">开发 ELAM 驱动程序</samp>
- en: In many ways, ELAM drivers resemble the drivers covered in the previous chapters;
    they use callbacks to receive information about system events and make security
    decisions on the local host. ELAM drivers focus specifically on prevention rather
    than detection, however. When an ELAM driver is started early in the boot process,
    it evaluates every boot-start driver on the system and either approves or denies
    the load based on its own internal malware-signature data and logic, as well as
    a system policy that dictates the host’s risk tolerance. This section covers the
    process of developing an ELAM driver, including its internal workings and decision
    logic.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，ELAM 驱动程序类似于前面章节中介绍的驱动程序；它们使用回调函数接收关于系统事件的信息，并在本地主机上做出安全决策。然而，ELAM 驱动程序特别注重预防而非检测。当
    ELAM 驱动程序在启动过程中较早启动时，它会评估系统上每个启动驱动程序，并根据其内部的恶意软件签名数据和逻辑，以及系统策略（该策略决定主机的风险容忍度）来批准或拒绝加载。本节将介绍开发
    ELAM 驱动程序的过程，包括其内部工作原理和决策逻辑。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Registering Callback
    Routines</samp>
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">注册回调例程</samp>
- en: The first ELAM-specific action the driver takes is to register its callback
    routines. ELAM drivers commonly use both registry and boot-start callbacks. The
    registry callback functions, registered with <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!CmRegisterCallbackEx()</samp>,
    validate the configuration data of the drivers being loaded in the registry, and
    we covered them extensively in [Chapter 5](chapter5.xhtml), so we won’t revisit
    them here.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序采取的第一个 ELAM 特定的操作是注册其回调例程。ELAM 驱动程序通常同时使用注册表回调和启动回调。注册表回调函数通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!CmRegisterCallbackEx()</samp>
    注册，用于验证在注册表中加载的驱动程序的配置信息，关于这部分我们在 [第 5 章](chapter5.xhtml) 中进行了详细讲解，因此这里不再赘述。
- en: More interesting is the boot-start callback routine, registered with <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!IoRegisterBootDriverCallback()</samp>.
    This callback provides the ELAM driver with updates about the status of the boot
    process, as well as information about each boot-start driver being loaded. Boot-start
    callback functions are passed to the registration function as a <samp class="SANS_TheSansMonoCd_W5Regular_11">PBOOT_DRIVER_CALLBACK_FUNCTION</samp>
    and must have a signature matching the one shown in [Listing 11-1](#list11-1).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是启动回调例程，它通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!IoRegisterBootDriverCallback()</samp>
    注册。这个回调为 ELAM 驱动程序提供有关启动过程状态的更新，以及有关每个加载的启动驱动程序的信息。启动回调函数作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">PBOOT_DRIVER_CALLBACK_FUNCTION</samp>
    被传递给注册函数，并且必须具有与 [列表 11-1](#list11-1) 中所示的签名匹配的签名。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 11-1: An ELAM driver callback signature'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-1：ELAM 驱动程序回调签名
- en: During the boot process, this callback routine receives two different types
    of events, dictated by the value in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Classification</samp>
    input parameter. These are defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">BDCB_CALLBACK_TYPE</samp>
    enum shown in [Listing 11-2](#list11-2).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动过程中，此回调例程会接收到两种不同类型的事件，这取决于 <samp class="SANS_TheSansMonoCd_W5Regular_11">Classification</samp>
    输入参数中的值。这些事件在 [列表 11-2](#list11-2) 中显示的 <samp class="SANS_TheSansMonoCd_W5Regular_11">BDCB_CALLBACK_TYPE</samp>
    枚举中定义。
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 11-2: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">BDCB_CALLBACK_TYPE</samp>
    enumeration'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-2：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">BDCB_CALLBACK_TYPE</samp>
    枚举
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">BdCbStatusUpdate</samp> events
    tell the ELAM driver how far the system has gotten in the process of loading boot-start
    drivers so that the driver may act appropriately. It can report any of three states,
    shown in [Listing 11-3](#list11-3).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">BdCbStatusUpdate</samp> 事件告诉 ELAM
    驱动程序系统在加载启动驱动程序过程中已经执行到哪个阶段，以便驱动程序可以做出适当的响应。它可以报告以下三种状态之一，这些状态在 [列表 11-3](#list11-3)
    中显示。
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 11-3: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">BDCB_STATUS_UPDATE_TYPE</samp>
    values'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-3：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">BDCB_STATUS_UPDATE_TYPE</samp>
    值
- en: The first of these values indicates that the system is about to load driver
    dependencies. The second indicates that the system is about to load boot-start
    drivers. The last indicates that all boot-start drivers have been loaded, so the
    ELAM driver should prepare to be unloaded.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值中的第一个表示系统即将加载驱动程序依赖项。第二个表示系统即将加载启动驱动程序。最后一个表示所有启动驱动程序已加载，因此 ELAM 驱动程序应该准备卸载。
- en: During the first two states, the ELAM driver will receive another type of event
    that correlates to the loading of a boot-start driver’s image. This event, passed
    to the callback as a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">BDCB_IMAGE_INFORMATION</samp>
    structure, is defined in [Listing 11-4](#list11-4).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两种状态期间，ELAM 驱动程序将收到另一种与加载启动驱动程序映像相关的事件。此事件作为指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">BDCB_IMAGE_INFORMATION</samp>
    结构的指针传递给回调，该结构在 [列表 11-4](#list11-4) 中定义。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 11-4: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">BDCB_IMAGE_INFORMATION</samp>
    structure definition'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-4：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">BDCB_IMAGE_INFORMATION</samp>
    结构定义
- en: As you can see, this structure contains the bulk of the information used to
    decide whether some driver is a rootkit. Most of it relates to the image’s digital
    signature, and it notably omits a few fields you might expect to see, such as
    a pointer to the contents of the image on disk. This is due in part to the performance
    requirements imposed on ELAM drivers. Because they can affect system boot times
    (as they’re initialized every time Windows boots), Microsoft imposes a time limit
    of 0.5 ms for the evaluation of each boot-start driver and 50 ms for the evaluation
    of all boot-start drivers together, within a 128KB memory footprint. These performance
    requirements limit what an ELAM driver can do; for instance, it is too time-intensive
    to scan the contents of an image. Therefore, developers typically rely on static
    signatures to identify malicious drivers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个结构包含了用于判断某个驱动程序是否为 rootkit 的大部分信息。它的大部分内容与镜像的数字签名有关，并且特别地省略了一些你可能期望看到的字段，比如指向磁盘上镜像内容的指针。这部分是由于对
    ELAM 驱动程序的性能要求所导致的。由于它们会影响系统的启动时间（因为每次 Windows 启动时都会初始化），微软对每个启动驱动程序的评估时间限制为 0.5
    毫秒，对所有启动驱动程序的总评估时间限制为 50 毫秒，而且要求所有这些评估在 128KB 的内存占用下完成。这些性能要求限制了 ELAM 驱动程序的功能；例如，扫描镜像内容太耗时。因此，开发人员通常依赖静态签名来识别恶意驱动程序。
- en: During the boot process, the operating system loads the signatures in use by
    ELAM drivers into an early-launch drivers registry hive under *HKLM:\ELAM\*, followed
    by the vendor’s name (for example, *HKLM:\ELAM\Windows Defender* for Microsoft
    Defender, shown in [Figure 11-2](#fig11-2)). This hive is unloaded later in the
    boot process and is not present in the registry by the time users start their
    sessions. If the vendor wishes to update signatures in this hive, they may do
    so from user mode by mounting the hive containing the signatures from *%SystemRoot%\System32\config\ELAM*
    and modifying their key.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动过程中，操作系统将 ELAM 驱动程序使用的签名加载到一个早期启动驱动程序注册表数据项中，该数据项位于 *HKLM:\ELAM\*，后跟供应商的名称（例如，*HKLM:\ELAM\Windows
    Defender* 用于 Microsoft Defender，如[图 11-2](#fig11-2)所示）。此数据项将在启动过程的后期被卸载，并且在用户启动会话时，该项不会出现在注册表中。如果供应商希望更新此数据项中的签名，他们可以通过挂载包含签名的注册表数据项
    *%SystemRoot%\System32\config\ELAM* 并修改其密钥，来从用户模式进行更新。
- en: '![](../images/Figure11-2.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-2: Microsoft Defender
    in the ELAM registry hive</samp>'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-2：Microsoft Defender 在
    ELAM 注册表数据项中的位置</samp>
- en: 'Vendors can use three values of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_BINARY</samp>
    in this key: <samp class="SANS_TheSansMonoCd_W5Regular_11">Measured</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Policy</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Config</samp>.
    Microsoft hasn’t published formal public documentation about the purposes of these
    values or their differences. However, the company does state that the signature
    data blob must be signed and its integrity validated using *Cryptography API:
    Next Generation (CNG)* primitive cryptographic functions before the ELAM driver
    begins making decisions regarding the status of the boot-start driver.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 供应商可以在此键中使用三种类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">REG_BINARY</samp>
    的值：<samp class="SANS_TheSansMonoCd_W5Regular_11">Measured</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Policy</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Config</samp>。微软没有公开正式文档来说明这些值的目的或它们之间的区别。然而，微软确实声明，签名数据块必须经过签名，并且在
    ELAM 驱动程序开始做出关于启动驱动程序状态的决策之前，必须使用*加密 API：下一代 (CNG)* 原始加密函数验证其完整性。
- en: No standard exists for how the signature blobs must be structured or used once
    the ELAM driver has verified their integrity. In case you’re interested, however,
    in 2018 the German *Bundesamt für Sicherheit in der Informationstechnik* (BSI)
    published its Work Package 5, which includes an excellent walk-through of how
    Defender’s *wdboot.sys* performs its own integrity checks and parses its signature
    blocks.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 目前并没有标准规定在 ELAM 驱动程序验证签名块完整性后，这些签名块的结构或使用方式。然而，如果你感兴趣的话，2018 年德国的*联邦信息安全局*（BSI）发布了其工作包
    5，其中包括了如何 Defender 的*wdboot.sys*执行自身的完整性检查并解析签名块的优秀教程。
- en: If the cryptographic validation of the signature blob fails for any reason,
    the ELAM driver must return the <samp class="SANS_TheSansMonoCd_W5Regular_11">BdCbClassificationUnknownImage</samp>
    classification for all boot-start drivers using its callback, as the signature
    data isn’t considered reliable and shouldn’t affect *Measured Boot*, the Windows
    feature that measures each boot component from the firmware to the drivers and
    stores the results in the Trusted Platform Module (TPM), where it can be used
    to validate the integrity of the host.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于任何原因，签名数据的加密验证失败，ELAM 驱动程序必须为所有启动时加载的驱动程序使用其回调返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">BdCbClassificationUnknownImage</samp>
    分类，因为签名数据不被认为是可靠的，不应影响 *受度量启动*（Measured Boot），这是 Windows 的一项功能，它会测量从固件到驱动程序的每个启动组件，并将结果存储在受信平台模块（TPM）中，可以用来验证主机的完整性。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Applying Detection
    Logic</samp>
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">应用检测逻辑</samp>
- en: Once the ELAM driver has received the <samp class="SANS_TheSansMonoCd_W5Regular_11">BdCbStatusPrepareForDriverLoad</samp>
    status update and pointers to <samp class="SANS_TheSansMonoCd_W5Regular_11">BDCB_IMAGE_INFORMATION</samp>
    structures for each boot-load driver, it applies its detection logic using the
    information provided in the structure. Once it has made a determination, the driver
    updates the <samp class="SANS_TheSansMonoCd_W5Regular_11">Classification</samp>
    member of the current image-information structure (not to be confused with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Classification</samp> input parameter
    passed to the callback function) with a value from the <samp class="SANS_TheSansMonoCd_W5Regular_11">BDCB_CLASSIFICATION</samp>
    enumeration, defined in [Listing 11-5](#list11-5).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 ELAM 驱动程序收到 <samp class="SANS_TheSansMonoCd_W5Regular_11">BdCbStatusPrepareForDriverLoad</samp>
    状态更新，并获得指向每个启动加载驱动程序的 <samp class="SANS_TheSansMonoCd_W5Regular_11">BDCB_IMAGE_INFORMATION</samp>
    结构的指针，它会使用结构中提供的信息应用其检测逻辑。一旦作出判断，驱动程序会更新当前图像信息结构中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Classification</samp>
    成员（不要与传递给回调函数的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Classification</samp>
    输入参数混淆），并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">BDCB_CLASSIFICATION</samp>
    枚举中的值，该枚举在 [清单 11-5](#list11-5) 中定义。
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 11-5: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">The BDCB_CLASSIFICATION</samp>
    enumeration'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-5：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">BDC_CLASSIFICATION</samp>
    枚举
- en: 'Microsoft defines these values as follows, from top to bottom: the image hasn’t
    been analyzed, or a determination regarding its maliciousness can’t be made; the
    ELAM driver has found no malware; the ELAM driver detected malware; the boot-load
    driver is malware, but it is critical to the boot process; and the boot-load driver
    is reserved for system use. The ELAM driver sets one of these classifications
    for each boot-start driver until it receives the <samp class="SANS_TheSansMonoCd_W5Regular_11">BdCbStatusPrepareForUnload</samp>
    status update instructing it to clean up. The ELAM driver is then unloaded.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 微软按如下方式定义这些值，从上到下：图像尚未分析，或无法确定其恶意性；ELAM 驱动程序未发现恶意软件；ELAM 驱动程序检测到恶意软件；启动加载驱动程序是恶意软件，但对启动过程至关重要；启动加载驱动程序保留供系统使用。ELAM
    驱动程序为每个启动时加载的驱动程序设置其中一个分类，直到收到 <samp class="SANS_TheSansMonoCd_W5Regular_11">BdCbStatusPrepareForUnload</samp>
    状态更新，指示它进行清理。然后，ELAM 驱动程序被卸载。
- en: Next, the operating system evaluates the classifications returned by each ELAM
    driver and takes action if needed. To determine which action to take, Windows
    consults the registry key *HKLM:\System\CurrentControlSet\Control\EarlyLaunch\DriverLoadPolicy*,
    which defines the drivers allowed to run on the system. This value, read by <samp
    class="SANS_TheSansMonoCd_W5Regular_11">nt!IopInitializeBootDrivers()</samp>,
    can be any of the options included in [Table 11-1](#tab11-1).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，操作系统评估每个 ELAM 驱动程序返回的分类，并在需要时采取相应措施。为了决定采取何种措施，Windows 会查询注册表项 *HKLM:\System\CurrentControlSet\Control\EarlyLaunch\DriverLoadPolicy*，该项定义了允许在系统上运行的驱动程序。此值由
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!IopInitializeBootDrivers()</samp>
    读取，可以是 [表 11-1](#tab11-1) 中包含的任何选项。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 11-1:</samp> <samp class="SANS_Futura_Std_Book_11">Possible
    Driver Load-Policy Values</samp>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 11-1：</samp> <samp class="SANS_Futura_Std_Book_11">可能的驱动加载策略值</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Value</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">值</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp>
    |'
- en: '| --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">Good
    drivers only</samp> |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">仅良好驱动程序</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">Good
    and unknown drivers</samp> |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">良好和未知的驱动程序</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_Futura_Std_Book_11">Good,
    unknown, and bad but critical to the boot process (Default)</samp> |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_Futura_Std_Book_11">良好、未知和对启动过程至关重要的驱动程序（默认）</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">All
    drivers</samp> |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">所有驱动程序</samp>
    |'
- en: The kernel (specifically, the Plug and Play manager) uses the classification
    specified by the ELAM driver to prevent any banned drivers from loading. All other
    drivers are allowed to load, and system boot continues as normal.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 内核（特别是即插即用管理器）使用 ELAM 驱动程序指定的分类来防止任何被禁止的驱动程序加载。所有其他驱动程序都可以加载，系统启动照常继续。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*If the ELAM driver identifies a known malicious boot-start driver and is running
    on a system that leverages Measured Boot, developers must call <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tbs!Tbsi_Revoke_Attestation()</samp>.
    What this function does is a bit technical; essentially, it extends a platform
    configuration register bank in the TPM, specifically <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PCR[12]</samp>,
    by an unspecified value and then increments the TPM’s event counter, breaking
    trust in the security state of the system.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果 ELAM 驱动程序识别到已知的恶意启动驱动程序并且运行在利用测量启动（Measured Boot）的系统上，开发人员必须调用 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tbs!Tbsi_Revoke_Attestation()</samp>。这个函数的作用有点技术性；本质上，它通过未指定的值扩展
    TPM 中的一个平台配置寄存器组，特别是 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PCR[12]</samp>，然后递增
    TPM 的事件计数器，从而打破系统安全状态的信任。*'
- en: '<samp class="SANS_Futura_Std_Bold_B_11">An Example Driver: Preventing Mimidrv
    from Loading</samp>'
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">示例驱动程序：防止 Mimidrv 加载</samp>
- en: The debugger output in [Listing 11-6](#list11-6) shows debug messaging from
    an ELAM driver when it encounters a known malicious driver, Mimikatz’s Mimidrv,
    and prevents it from loading.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 11-6](#list11-6)中的调试器输出显示了当 ELAM 驱动程序遇到已知的恶意驱动程序 Mimikatz 的 Mimidrv 时，它会显示调试信息并防止其加载。
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 11-6: ELAM driver output showing the detection of Mimidrv'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-6：ELAM 驱动程序输出，显示检测到 Mimidrv
- en: 'In this example, you can see that the ELAM driver allows other boot-start drivers
    to load: the native Universal Naming Convention driver, *mup.sys*, and the Disk
    I/O Rate Filter driver, *iorate.sys*, both of which are signed by Microsoft. Between
    these two drivers, it detects Mimidrv using the file’s known cryptographic hash.
    Because it deems this driver to be malicious, it prevents Mimidrv from loading
    on the system before the operating system is fully initialized and without requiring
    any interaction from the user or other EDR components.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，你可以看到 ELAM 驱动程序允许其他启动驱动程序加载：本地的通用命名约定驱动程序 *mup.sys* 和磁盘 I/O 速率过滤驱动程序 *iorate.sys*，这两个驱动程序都由微软签名。在这两个驱动程序之间，它通过已知的文件加密哈希值检测
    Mimidrv。由于它将该驱动程序视为恶意驱动程序，它会在操作系统完全初始化之前阻止 Mimidrv 加载，而且无需用户或其他 EDR 组件的任何交互。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Loading an ELAM Driver</samp>
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">加载 ELAM 驱动程序</samp>
- en: 'Before you can load your ELAM driver, you must complete a few preparatory steps:
    signing the driver and assigning its load order.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载 ELAM 驱动程序之前，你必须完成几个准备步骤：签署驱动程序并分配其加载顺序。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Signing the Driver</samp>
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">签名驱动程序</samp>
- en: The most headache-inducing part of deploying an ELAM driver, especially during
    development and testing, is ensuring that its digital signature meets Microsoft’s
    requirements for loading on the system. Even when operating in test-signing mode,
    the driver must have specific certificate attributes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 部署 ELAM 驱动程序最让人头疼的部分，特别是在开发和测试过程中，是确保其数字签名符合微软对系统加载的要求。即使在测试签名模式下，驱动程序也必须具有特定的证书属性。
- en: 'Microsoft publishes limited information about the process of test-signing an
    ELAM driver. In its demo, Microsoft says the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 微软发布了关于测试签名 ELAM 驱动程序过程的有限信息。在其演示中，微软说了以下内容：
- en: Early Launch drivers are required to be signed with a code-signing certificate
    that also contains the Early Launch EKU “1.3.6.1.4.1.311.61.4.1” […] and the “1.3.6.1.5.5.7.3.3”
    Code Signing EKU. Once a certificate of this form has been created, signtool.exe
    can be used to sign [the ELAM driver].
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 早期启动驱动程序要求使用包含早期启动 EKU “1.3.6.1.4.1.311.61.4.1” […] 和 “1.3.6.1.5.5.7.3.3” 代码签名
    EKU 的代码签名证书进行签名。一旦创建了这种形式的证书，就可以使用 signtool.exe 对[ELAM 驱动程序]进行签名。
- en: In test-signing scenarios, you can create a certificate with these EKUs by running
    *makecert.exe*, a utility that ships with the Windows SDK, in an elevated command
    prompt. [Listing 11-7](#list11-7) demonstrates the syntax for doing this.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试签名场景中，你可以通过在提升权限的命令提示符中运行*makecert.exe*（Windows SDK 中附带的实用工具）来创建包含这些 EKU
    的证书。[列表 11-7](#list11-7)展示了执行此操作的语法。
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 11-7: Generating a self-signed certificate'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-7：生成自签名证书
- en: This tool supports a robust set of arguments, but only two are really relevant
    to ELAM. This first is the <samp class="SANS_TheSansMonoCd_W5Regular_11">-eku</samp>
    option, which adds the <samp class="SANS_TheSansMonoCd_W5Regular_11">Early Launch
    Antimalware Driver</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Code
    Signing</samp> object identifiers to the certificate. The second is the path to
    which the certificate should be written.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具支持一组强大的参数，但只有两个与 ELAM 特别相关。第一个是<samp class="SANS_TheSansMonoCd_W5Regular_11">-eku</samp>选项，它将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Early Launch Antimalware Driver</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Code Signing</samp>对象标识符添加到证书中。第二个是证书应写入的路径。
- en: When *makecert.exe* completes, you’ll find a new self-signed certificate written
    to the specified location. This certificate should have the necessary object identifiers,
    which you can validate by opening the certificate and viewing its details, as
    shown in [Figure 11-3](#fig11-3).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当*makecert.exe*完成时，你会在指定位置找到一个新的自签名证书。该证书应具有必要的对象标识符，你可以通过打开证书并查看其详细信息来验证这一点，如[图
    11-3](#fig11-3)所示。
- en: '![](../images/Figure11-3.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-3: ELAM EKUs included
    in the certificate</samp>'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-3：证书中包含的 ELAM EKU</samp>
- en: Next, you can use *signtool.exe*, another tool from the Windows SDK, to sign
    the compiled ELAM driver. [Listing 11-8](#list11-8) shows an example of doing
    this using the previously generated certificate.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以使用*signtool.exe*，这是 Windows SDK 中的另一个工具，来签名已编译的 ELAM 驱动程序。[列表 11-8](#list11-8)展示了使用之前生成的证书进行签名的示例。
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 11-8: Signing an ELAM driver with signtool.exe'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-8：使用 signtool.exe 签名 ELAM 驱动程序
- en: Like *makecert.exe*, this tool supports a large set of arguments, some of which
    aren’t particularly important to ELAM. First, the <samp class="SANS_TheSansMonoCd_W5Regular_11">/fd</samp>
    argument specifies the file-digest algorithm to use for signing the certificate
    (SHA256 in our case). The <samp class="SANS_TheSansMonoCd_W5Regular_11">/ph</samp>
    argument instructs *signtool.exe* to generate *page hashes* for executable files.
    Versions of Windows starting with Vista use these hashes to verify the signature
    of each page of the driver as it is loaded into memory. The <samp class="SANS_TheSansMonoCd_W5Regular_11">/tr</samp>
    argument accepts the URL of a timestamp server that allows the certificate to
    be appropriately timestamped (see RFC 3161 for details about the Time-Stamp Protocol).
    Developers can use a number of publicly available servers to complete this task.
    Lastly, the tool accepts the file to sign (in our case, the ELAM driver).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 像*makecert.exe*一样，这个工具支持一大堆参数，其中一些对 ELAM 并不特别重要。首先，<samp class="SANS_TheSansMonoCd_W5Regular_11">/fd</samp>参数指定用于签名证书的文件摘要算法（在我们的案例中是
    SHA256）。<samp class="SANS_TheSansMonoCd_W5Regular_11">/ph</samp>参数指示*signtool.exe*为可执行文件生成*页面哈希*。从
    Vista 开始的 Windows 版本使用这些哈希来验证驱动程序加载到内存时每个页面的签名。<samp class="SANS_TheSansMonoCd_W5Regular_11">/tr</samp>参数接受时间戳服务器的
    URL，使证书能够正确地打上时间戳（有关时间戳协议的详细信息，请参见 RFC 3161）。开发人员可以使用一些公开可用的服务器来完成此任务。最后，该工具接受要签名的文件（在我们的案例中是
    ELAM 驱动程序）。
- en: Now we can inspect the driver’s properties to check whether it is signed with
    the self-signed certificate and a countersignature from the timestamp server,
    as shown in [Figure 11-4](#fig11-4).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以检查驱动程序的属性，以查看它是否已使用自签名证书和时间戳服务器的反签名进行签名，如[图 11-4](#fig11-4)所示。
- en: '![](../images/Figure11-4.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure11-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-4: A signed driver
    with the timestamp included</samp>'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-4：包含时间戳的签名驱动程序</samp>
- en: If so, you may deploy the driver to the system. As for most drivers, the system
    uses a service to facilitate the driver’s loading at the desired time. To function
    properly, the ELAM driver must load very early in the boot process. This is where
    the concept of load-order grouping comes into play.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，你可以将驱动程序部署到系统中。与大多数驱动程序一样，系统使用服务来便于驱动程序在指定的时间加载。为了正常工作，ELAM 驱动程序必须在启动过程的非常早期加载。这就是加载顺序分组概念的应用场景。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting the Load
    Order</samp>
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">设置加载顺序</samp>
- en: When creating a boot-start service on Windows, the developer can specify when
    it should be loaded in the boot order. This is useful in cases when the driver
    depends on the availability of another service or otherwise needs to load at a
    specific time.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上创建启动时加载的服务时，开发者可以指定该服务应该在启动顺序中何时加载。这在驱动程序依赖于另一个服务的可用性或需要在特定时间加载时非常有用。
- en: The developer can’t specify any arbitrary string for the load-order group, however.
    Microsoft keeps a list containing most of the groups available in the registry
    at *HKLM:\SYSTEM\CurrentControlSet\Control\ServiceGroupOrder*, which you can retrieve
    easily, as shown in [Listing 11-9](#list11-9).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，开发者不能为加载顺序组指定任何任意字符串。微软维护着一个列表，其中包含注册表中大多数可用的组，位置为 *HKLM:\SYSTEM\CurrentControlSet\Control\ServiceGroupOrder*，你可以轻松地检索到这个列表，如
    [清单 11-9](#list11-9) 所示。
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 11-9: Retrieving service-load-order groups from the registry with PowerShell'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-9：使用 PowerShell 从注册表中检索服务加载顺序组
- en: This command parses the values of the registry key containing the load-order
    group names and returns them as a list. At the time of this writing, the registry
    key contains 70 groups.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令解析包含加载顺序组名称的注册表键的值，并将其作为列表返回。截至本文撰写时，注册表键中包含 70 个组。
- en: Microsoft instructs ELAM driver developers to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Early-Launch</samp>
    load-order group, which is notably missing from the *ServiceGroupOrder* key. No
    other special loading requirements exist, and you can do it simply by using *sc.exe*
    or the <samp class="SANS_TheSansMonoCd_W5Regular_11">advapi32!CreateService()</samp>
    Win32 API. For example, [Listing 11-10](#list11-10) loads *WdBoot*, an ELAM service
    that ships with Windows 10 and is used to load Defender’s boot-start driver of
    the same name.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 微软要求 ELAM 驱动程序开发者使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Early-Launch</samp>
    加载顺序组，这个组在 *ServiceGroupOrder* 键中是没有的。没有其他特殊的加载要求，你可以简单地通过使用 *sc.exe* 或者 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">advapi32!CreateService()</samp> Win32
    API 来完成。例如，[清单 11-10](#list11-10) 加载 *WdBoot*，这是一个与 Windows 10 一起发布的 ELAM 服务，用于加载名为相同的
    Defender 启动驱动程序。
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 11-10: Inspecting Defender’s WdBoot ELAM driver'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-10：检查 Defender 的 WdBoot ELAM 驱动程序
- en: This command collects the name of the service, its load-order group, and the
    path to the driver on the filesystem.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令收集服务的名称、其加载顺序组及驱动程序在文件系统中的路径。
- en: If you step inside the process of loading the ELAM drivers, you’ll find that
    it’s primarily the responsibility of the Windows bootloader, *winload.efi*. The
    bootloader, a complex piece of software in its own right, performs a few actions.
    First, it searches the registry for all boot-start drivers on the system in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Early-Launch</samp> group and adds
    them to a list. Next, it loads core drivers, such as the System Guard Runtime
    Monitor (*sgrmagent.sys*) and the Security Events Component Minifilter (*mssecflt.sys*).
    Finally, it goes over its list of ELAM drivers, performing some integrity checking
    and eventually loading the drivers. Once the <samp class="SANS_TheSansMonoCd_W5Regular_11">Early-Launch</samp>
    drivers are loaded, the boot process continues, and the ELAM vetting process described
    in “Developing ELAM Drivers” on [page 203](#sec2) is executed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你深入了解加载 ELAM 驱动程序的过程，你会发现这主要是 Windows 启动加载程序的责任，*winload.efi*。启动加载程序，作为一款复杂的软件，执行了几个操作。首先，它在注册表中搜索所有启动时加载的驱动程序，这些驱动程序位于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Early-Launch</samp> 组，并将它们添加到列表中。接着，它加载核心驱动程序，如系统防护运行时监控程序
    (*sgrmagent.sys*) 和安全事件组件迷你筛选器 (*mssecflt.sys*)。最后，它会检查 ELAM 驱动程序列表，进行完整性检查并最终加载驱动程序。一旦
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Early-Launch</samp> 驱动程序加载完成，启动过程继续，ELAM
    审核过程将在 [第 203 页](#sec2) 中描述。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*This is an oversimplified description of the process of loading ELAM drivers.
    If you’re interested in learning more about it, check out “Understanding WdBoot,”
    a blog post by @n4r1b detailing how Windows loads essential drivers.*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是对加载ELAM驱动程序过程的简化描述。如果你有兴趣了解更多，可以查看@n4r1b的博客文章《理解WdBoot》，该文详细讲解了Windows如何加载必要的驱动程序。*'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evading ELAM Drivers</samp>
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">规避ELAM驱动程序</samp>
- en: 'Because ELAM drivers mostly use static signatures and hashes to identify malicious
    boot-start drivers, you can evade them in the same way you’d evade user-mode file-based
    detections: by changing static indicators. Doing this for drivers is more difficult
    than doing it in user mode, however, because there are generally fewer viable
    drivers than user-mode executables to choose from. This is due in no small part
    to the Driver Signature Enforcement in modern versions of Windows.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ELAM驱动程序主要使用静态签名和哈希值来识别恶意的启动驱动程序，因此你可以像规避用户模式基于文件的检测那样规避它们：通过更改静态指示符。然而，在驱动程序中执行此操作比在用户模式中更困难，因为通常可供选择的驱动程序要比用户模式可执行文件少。这在很大程度上归因于现代版本Windows中的驱动程序签名强制。
- en: '*Driver Signature Enforcement* is a control implemented in Windows Vista and
    beyond that requires kernel-mode code (namely drivers) to be signed in order to
    load. Starting in build 1607, Windows 10 further requires that drivers be signed
    with an Extended Validation (EV) certificate and, optionally, a Windows Hardware
    Quality Labs (WHQL) signature if the developer would like the driver to load on
    Windows 10 S or have its updates distributed through Windows Update. Due to the
    complexity of these signing processes, attackers have a substantially harder time
    loading a rootkit on modern versions of Windows.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*驱动程序签名强制*是在Windows Vista及以后的版本中实施的一个控制措施，要求内核模式代码（即驱动程序）必须经过签名才能加载。从版本1607开始，Windows
    10进一步要求驱动程序必须使用扩展验证（EV）证书进行签名，并且如果开发者希望驱动程序能够在Windows 10 S上加载，或者希望其更新通过Windows
    Update分发，还需要可选的Windows硬件质量实验室（WHQL）签名。由于这些签名过程的复杂性，攻击者在现代版本的Windows上加载rootkit变得更加困难。'
- en: An attacker’s driver can serve a number of functions while operating under the
    requirements of Driver Signature Enforcement. For example, the NetFilter rootkit,
    signed by Microsoft, passed all Driver Signature Enforcement checks and can load
    on modern Windows versions. Getting a rootkit signed by Microsoft isn’t the easiest
    process, however, and it’s impractical for many offensive teams.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者的驱动程序可以在符合驱动程序签名强制要求的情况下执行多种功能。例如，微软签名的NetFilter rootkit通过了所有驱动程序签名强制检查，并且可以在现代Windows版本中加载。然而，获得微软签名的rootkit并不是一个简单的过程，对于许多进攻团队来说也不切实际。
- en: If the attacker takes the *Bring Your Own Vulnerable Driver (BYOVD)* approach,
    their options open up. These are vulnerable drivers that the attacker loads onto
    the system, and they’re usually signed by legitimate software vendors. As they
    don’t contain any overtly malicious code, they are difficult to detect and rarely
    have their certificate revoked after their vulnerability is discovered. If this
    BYOVD component is loaded during boot, a user-mode component running later in
    the boot process could exploit the driver to load the operator’s rootkit using
    any number of techniques, depending on the nature of the vulnerability.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者采用*自带易受攻击的驱动程序（BYOVD）*方法，他们的选择会变得更加广泛。这些是攻击者加载到系统上的易受攻击驱动程序，通常由合法的软件供应商签名。由于它们不包含明显的恶意代码，因此很难被检测到，而且在发现其漏洞后，证书很少会被吊销。如果这个BYOVD组件在启动时加载，稍后在启动过程中运行的用户模式组件可能会利用该驱动程序，通过多种技术手段加载操作员的rootkit，具体取决于漏洞的性质。
- en: Another approach involves the deployment of firmware rootkits or bootkits. While
    this technique is exceedingly rare, it can effectively evade ELAM’s boot-start
    protections. For example, the ESPecter bootkit patched the Boot Manager (*bootmgfw.efi*),
    disabled Driver Signature Enforcement, and dropped its driver, which was responsible
    for loading user-mode components and performing keylogging. ESPecter was initialized
    as soon as the system loaded UEFI modules, so early in the boot process that ELAM
    drivers had no ability to affect its presence.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是部署固件rootkit或bootkit。虽然这种技术极为罕见，但它可以有效地规避ELAM的启动保护。例如，ESptecter bootkit修补了启动管理器（*bootmgfw.efi*），禁用了驱动程序签名强制，并投放了其驱动程序，该驱动程序负责加载用户模式组件并执行键盘记录。ESpecter在系统加载UEFI模块时初始化，启动过程如此之早，以至于ELAM驱动程序无法影响其存在。
- en: 'While the specifics of implementing rootkits and bootkits are outside the scope
    of this book, they’re a fascinating topic for any of those interested in “apex”
    malware. *Rootkits and Bootkits: Reversing Modern Malware and Next Generation
    Threats* by Alex Matrosov, Eugene Rodionov, and Sergey Bratus is the most up-to-date
    resource on this topic at the time of this writing and is highly recommended as
    a complement to this section.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '尽管实现 rootkit 和 bootkit 的具体细节超出了本书的范围，但它们对于任何对“顶级”恶意软件感兴趣的人来说，都是一个迷人的话题。由 Alex
    Matrosov、Eugene Rodionov 和 Sergey Bratus 合著的 *Rootkits and Bootkits: Reversing
    Modern Malware and Next Generation Threats* 是截至本书撰写时最为更新的资源，并强烈推荐作为本节内容的补充。'
- en: Thankfully, Microsoft continues to invest heavily in protecting the part of
    the boot process that occurs before ELAM has a chance to act. These protections
    fall under the Measured Boot umbrella, which validates the integrity of the boot
    process from UEFI firmware through ELAM. During the boot process, Measured Boot
    produces cryptographic hashes, or *measurements*, of these boot components, along
    with other configuration data, such as the status of BitLocker and Test Signing,
    and stores them in the TPM.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，微软继续大量投资于保护启动过程中 ELAM 尚未发挥作用的部分。这些保护措施属于 Measured Boot 范畴，验证从 UEFI 固件到
    ELAM 的启动过程完整性。在启动过程中，Measured Boot 会生成这些启动组件的加密哈希值，或称为 *测量值*，以及其他配置数据，如 BitLocker
    和 Test Signing 的状态，并将其存储在 TPM 中。
- en: Once the system has completed booting, Windows uses the TPM to generate a cryptographically
    signed statement, or *quote*, used to confirm the validity of the system’s configuration.
    This quote is sent to an attestation authority, which authenticates the measurements,
    returns a determination of whether the system should be trusted, and optionally
    takes actions to remediate any issues. As Windows 11, which requires a TPM, becomes
    more widely adopted, this technology will become an important detective component
    for system integrity inside enterprises.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦系统完成启动，Windows 会使用 TPM 生成一个加密签名声明，或称为 *引用*，用于确认系统配置的有效性。该引用会发送到认证机构，认证机构对测量值进行认证，返回系统是否值得信任的判断，并可以选择采取措施修复任何问题。随着要求
    TPM 的 Windows 11 越来越广泛地被采用，这项技术将成为企业内部系统完整性检测的重要组成部分。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Unfortunate Reality</samp>
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">不幸的现实</samp>
- en: 'In the vast majority of situations, ELAM vendors don’t meet Microsoft’s recommendations.
    In 2021, Maxim Suhanov published a blog post, “Measured Boot and Malware Signatures:
    exploring two vulnerabilities found in the Windows loader,” wherein he compared
    26 vendors’ ELAM drivers. He noted that only 10 used signatures at all; of these,
    only two used them to affect Measured Boot in the way intended by Microsoft. Instead,
    these vendors use their ELAM drivers nearly exclusively to create protected processes
    and access the Microsoft-Windows-Threat-Intelligence ETW provider discussed in
    the next chapter.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在绝大多数情况下，ELAM 供应商未能符合微软的推荐标准。2021年，Maxim Suhanov 发布了一篇博客文章《Measured Boot 和恶意软件签名：探索
    Windows 加载程序中发现的两个漏洞》，在文章中他对比了26个供应商的 ELAM 驱动程序。他指出，只有 10 家供应商使用了签名；其中，只有两家供应商的签名在实现微软预期的
    Measured Boot 时发挥了作用。相反，这些供应商几乎完全利用他们的 ELAM 驱动程序来创建受保护的进程并访问下一章中讨论的 Microsoft-Windows-Threat-Intelligence
    ETW 提供程序。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">结论</samp>
- en: 'ELAM drivers give an EDR insight into portions of the boot process previously
    unable to be monitored. This allows an EDR to detect, or potentially even stop,
    an attacker that can execute their code before the primary EDR agent even starts.
    Despite this seemingly massive benefit, almost no vendors make use of this technology
    and instead use it only for its auxiliary function: gaining access to the Microsoft-Windows-Threat-Intelligence
    ETW provider.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ELAM 驱动程序为 EDR 提供了对启动过程中之前无法监控的部分的洞察。这使得 EDR 可以检测甚至可能阻止一个攻击者在主要 EDR 代理启动之前执行他们的代码。尽管这一看似巨大的好处，几乎没有供应商利用这项技术，而是仅将其用于辅助功能：访问
    Microsoft-Windows-Threat-Intelligence ETW 提供程序。
