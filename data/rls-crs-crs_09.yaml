- en: Chapter 7. Advanced Ruby
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章. 高级 Ruby
- en: You learned the fundamentals of Ruby back in [Chapter 1](ch01.html "Chapter 1. Ruby
    Fundamentals"). This chapter covers some of the language’s advanced features,
    including modules, the Ruby object model, introspection, and a bit of metaprogramming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第 1 章](ch01.html "第 1 章. Ruby 基础")学习了 Ruby 的基本概念。本章涵盖了一些语言的高级特性，包括模块、Ruby
    对象模型、反射以及一些元编程。
- en: Modules are used frequently in Rails applications to group similar functionality
    and share behavior between classes. The Ruby object model determines how methods
    are found and called in a hierarchy of inherited classes and shared code from
    modules. Introspection supports polymorphism by allowing you to look inside a
    class to see which methods it understands. Metaprogramming lets your classes respond
    to methods that don’t exist by defining methods at runtime.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 模块在 Rails 应用程序中经常用于将类似的功能分组，并在类之间共享行为。Ruby 对象模型决定了方法如何在继承类的层次结构中查找和调用，以及如何从模块共享的代码中查找方法。反射通过允许你查看类的内部结构，从而支持多态性，帮助你了解类能理解哪些方法。元编程允许你的类在运行时通过定义方法来响应那些不存在的方法。
- en: Open a terminal window and launch IRB to get started. Several of the examples
    in this chapter are longer than normal. You may find it easier to type the example
    into your editor, save it as a file with the extension *rb*, and then run the
    example in your terminal by entering `ruby` *`filename.rb`*. Or you can simply
    copy and paste the code from your editor into IRB.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端窗口并启动 IRB 开始实验。本章中的一些例子较长，输入时可能比平常更困难。你可以将代码输入到编辑器中，将其保存为扩展名为*rb*的文件，然后通过在终端输入`ruby`
    *`filename.rb`*来运行示例。或者，你也可以直接将代码从编辑器复制粘贴到 IRB 中。
- en: Modules
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: As you saw in [Chapter 1](ch01.html "Chapter 1. Ruby Fundamentals"), a module
    is a collection of methods and constants that cannot be instantiated. You define
    modules in basically the same way you define classes. Module definitions begin
    with the word `module`, followed by an uppercase name, and continue to the word
    `end`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第 1 章](ch01.html "第 1 章. Ruby 基础")中看到的，模块是一个方法和常量的集合，不能实例化。你定义模块的方式基本上和定义类相同。模块定义以`module`开头，后跟一个大写字母的名称，然后以`end`结束。
- en: 'To demonstrate using modules, we first need a class definition. Let’s define
    a simple `Person` class:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何使用模块，首先我们需要定义一个类。让我们定义一个简单的`Person`类：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This class uses `attr_accessor` ➊ to define getters and setters for the instance
    variable `@name`, and sets the value of `@name` when created ➋.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类使用`attr_accessor` ➊来定义实例变量`@name`的获取器和设置器，并在创建时设置`@name`的值 ➋。
- en: Class names are usually nouns because they represent objects. Module names are
    usually adjectives because they represent behavior. Many Ruby modules take this
    convention a step further and use adjective names ending with *able*, such as
    `Comparable` and `Forwardable`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 类名通常是名词，因为它们代表对象。模块名通常是形容词，因为它们代表行为。许多 Ruby 模块在此约定的基础上更进一步，使用以*able*结尾的形容词命名，例如`Comparable`和`Forwardable`。
- en: 'Here’s a silly example, just to show how it’s done:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子，展示如何使用模块：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Enter this module in IRB, include it in the `Person` class you created earlier
    in this chapter, and see if you can distract someone:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IRB 中输入这个模块，将其包含到你在本章早些时候创建的`Person`类中，看看你是否能分散某人的注意力：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In [Chapter 5](ch05.html "Chapter 5. Views"), you also defined a module method
    while working with Rails helpers. `ApplicationHelper` is a module that is automatically
    mixed into all controllers by Rails.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](ch05.html "第 5 章. 视图")中，你也在使用 Rails 辅助方法时定义了一个模块方法。`ApplicationHelper`是一个模块，Rails
    会自动将其混入所有控制器中。
- en: 'Modules serve two purposes in Ruby:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 模块在 Ruby 中有两个用途：
- en: Modules are used to group related methods and prevent name conflicts.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块用于将相关方法分组并防止名称冲突。
- en: Modules define methods that can be mixed in to classes to provide additional
    behavior.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块定义了可以混入类中的方法，以提供额外的行为。
- en: Organizing your code becomes more important as your application grows. By providing
    namespaces and making it easy to share code between classes, modules help you
    break your code into manageable pieces. Let’s look at both of these purposes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的成长，组织代码变得越来越重要。通过提供命名空间并使类之间的代码共享变得容易，模块帮助你将代码拆分成可管理的部分。让我们看看这两个用途。
- en: Modules as Namespaces
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块作为命名空间
- en: A Ruby module can be used as a *namespace,* a container for code such as constants
    or methods with related functionality.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 模块可以用作*命名空间*，即包含常量或相关功能方法的代码容器。
- en: 'The `Math` module is an example of a built-in Ruby module used as a namespace.
    It defines the constants `E` and `PI` as well as many common trigonometric and
    transcendental methods. The double-colon operator (`::`) is used to access constants
    in Ruby. The following example accesses the constant `PI` in the `Math` module:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math`模块是一个作为命名空间使用的内建Ruby模块。它定义了常量`E`和`PI`以及许多常见的三角函数和超越函数方法。双冒号运算符（`::`）用于访问Ruby中的常量。以下示例访问`Math`模块中的常量`PI`：'
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Methods defined in a module are accessed with a dot (`.`), just like methods
    in a class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块中定义的方法通过点（`.`）运算符访问，就像类中的方法一样：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Modules as Mixins
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块作为混入
- en: 'A Ruby module can also be used as a *mixin* to provide additional functionality
    to a class. Ruby only supports single inheritance; that is, a class can only inherit
    from a single parent class. Modules allow you to implement something similar to
    multiple inheritance: a class can include several modules, adding each module’s
    methods to its own.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby模块也可以作为*混入*，为类提供额外的功能。Ruby只支持单一继承，即一个类只能继承一个父类。模块使你能够实现类似于多重继承的功能：一个类可以包含多个模块，将每个模块的方法添加到自己的类中。
- en: You can add a module’s methods to a class in three ways, using `include`, `prepend`,
    or `extend`. I discuss the effect of each of these keywords next.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过三种方式将模块的方法添加到类中，使用`include`、`prepend`或`extend`。接下来，我将讨论这些关键字的效果。
- en: include
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: include
- en: The `include` statement adds the methods from a module to a class as instance
    methods and is the most common way of mixing a module into a class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`include`语句将模块的方法作为实例方法添加到类中，是将模块混入类中的最常见方式。'
- en: The `Comparable` module, included in Ruby, is commonly used as a mixin. It adds
    comparison operators and the `between?` method to classes when included. The class
    only needs to implement the `<=>` operator. This operator compares two objects
    and returns `–1`, `0`, or `1`, depending on whether the receiver is less than,
    equal to, or greater than the other object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comparable`模块是Ruby中常用的混入模块。它在包含时将比较运算符和`between?`方法添加到类中。类只需要实现`<=>`运算符。该运算符比较两个对象，并根据接收者是否小于、等于或大于另一个对象，返回`–1`、`0`或`1`。'
- en: 'To use this module as a mixin, add it `Person` class you created previously:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此模块作为混入模块使用，添加它到你之前创建的`Person`类中：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This class now includes the `Comparable` module ➊ and defines the `<=>` operator
    ➋ to compare the name of this object with the name of another object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 该类现在包含了`Comparable`模块➊，并定义了`<=>`运算符➋，用于将该对象的名称与另一个对象的名称进行比较。
- en: 'After entering this in IRB, create a few people and see if they can be compared:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在IRB中输入这个命令后，创建一些人物并检查它们是否能相互比较：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here `p1` is greater then `p2` because *T* is greater than *M* alphabetically.
    The `between?` method tells you whether an object falls between two others:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`p1`大于`p2`，因为*T*在字母顺序上大于*M*。`between?`方法告诉你一个对象是否位于另两个对象之间：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, `between?` returns `true` since *T* is between *M* and *W* alphabetically,
    which means it works as expected.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`between?`返回`true`，因为*T*在字母表顺序上位于*M*和*W*之间，这意味着它按预期工作。
- en: prepend
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: prepend
- en: The `prepend` statement also adds a module’s methods to a class, but `prepend`
    inserts the module’s methods *before* the class’s methods. This means if the module
    defines a method with the same name as the class, the module’s method will be
    executed instead of the class’s method. Using `prepend`, you can override a method
    in the class by writing a method in the module with the same name.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`prepend`语句也将模块的方法添加到类中，但`prepend`将模块的方法*插入到*类的方法之前。这意味着，如果模块定义了与类同名的方法，模块的方法将优先执行而不是类的方法。通过使用`prepend`，你可以通过在模块中编写同名方法来覆盖类中的方法。'
- en: One practical use for `prepend` is memoization. *Memoization* is an optimization
    technique in which a program stores the result of a calculation to avoid repeating
    the same calculation multiple times.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`prepend`的一个实际用法是记忆化。*记忆化*是一种优化技术，程序将计算结果存储起来，以避免多次重复相同的计算。'
- en: 'For example, imagine you wanted to implement the Fibonacci sequence in Ruby.
    The first two numbers in the Fibonacci sequence are zero and one. Each subsequent
    number is the sum of the previous two. Here is a method to calculate the *n*th
    value of the Fibonacci sequence in Ruby:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想在Ruby中实现斐波那契数列。斐波那契数列的前两个数字是零和一。每个后续数字是前两个数字的和。以下是在Ruby中计算斐波那契数列第*n*项的方法：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Notice that the `calc` method is recursive. Every call to `calc` with a value
    of `n` greater than 1 results in two more calls to itself ➊. Try creating an instance
    of this class and calculating some small values of `n`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `calc` 方法是递归的。每次用大于 1 的 `n` 值调用 `calc` 时，都将导致对自身的两次调用 ➊。试着创建这个类的实例并计算一些小的
    `n` 值：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you call the method with larger values of `n`, the method takes noticeably
    longer to run. For values of `n` around 40, the method takes several seconds to
    return an answer.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对更大的 `n` 值调用该方法时，方法执行的时间会显著增加。对于约 40 的 `n` 值，方法需要几秒钟才能返回一个答案。
- en: 'The Fibonacci `calc` method is slow because it repeats the same calculations
    many times. But if you define a module to implement memoization, the calculations
    should take significantly less time. Let’s do that now:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Fibonacci 的 `calc` 方法很慢，因为它重复进行相同的计算多次。但是，如果你定义一个模块来实现记忆化，计算应该会显著缩短时间。现在我们来做这个：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Memoize` module also defines a `calc` method. This method has a couple
    of interesting features. First, it initializes a class variable named `@@memo`
    ➊ with an empty hash if it is not already initialized. This hash stores the result
    of the `calc` method for each value of `n`. Next, it assigns the return value
    of `super` to `@@memo` at key `n` ➋ if that value is not already assigned. Because
    we are using `prepend` to add this module into `Fibonacci`, `super` calls the
    original `calc` method defined by the class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Memoize` 模块也定义了一个 `calc` 方法。这个方法有几个有趣的特点。首先，如果尚未初始化，它会初始化一个名为 `@@memo` ➊ 的类变量为空哈希表。这个哈希表存储每个
    `n` 值对应的 `calc` 方法的结果。接着，如果该值尚未分配，它会将 `super` 的返回值赋给 `@@memo` 中键为 `n` 的位置 ➋。因为我们使用
    `prepend` 将这个模块添加到 `Fibonacci` 中，`super` 会调用类定义的原始 `calc` 方法。'
- en: 'Each time the `calc` method is called, `@@memo` stores the Fibonacci number
    for the value `n`. For example, after calling `calc(3)`, the `@@memo` hash holds
    these keys and values:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `calc` 方法时，`@@memo` 会存储 `n` 值对应的 Fibonacci 数字。例如，在调用 `calc(3)` 后，`@@memo`
    哈希表会包含如下键值对：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On each line, the key (the first number) is the value of `n` and the value
    (the second number) is the corresponding Fibonacci number. The Fibonacci number
    for 0 is 0, 1 is 1, 2 is 1, and 3 is 2\. By storing these intermediate values,
    the `calc` method never needs to perform the same calculation more than once.
    Use `prepend Memoize` to add the `Memoize` module to the `Fibonacci` class and
    try it for yourself:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一行中，键（第一个数字）是 `n` 的值，值（第二个数字）是对应的 Fibonacci 数字。Fibonacci 数字对于 0 是 0，对于 1 是
    1，对于 2 是 1，对于 3 是 2。通过存储这些中间值，`calc` 方法就不需要重复计算相同的值。使用 `prepend Memoize` 将 `Memoize`
    模块添加到 `Fibonacci` 类中，并试试看：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that the values of `calc` are being memoized, you should be able to call
    `calc` for greater values of `n` and get an answer almost instantly. Try it with
    `n` = 100 or even `n` = 1000\. Note that you didn’t have to restart IRB or instantiate
    a new Fibonacci object. Method lookup in Ruby is dynamic.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `calc` 的值已经被记忆化，你应该能够对更大的 `n` 值调用 `calc` 并几乎立刻得到答案。试试 `n` = 100 或甚至 `n` =
    1000。注意，你不需要重启 IRB 或实例化一个新的 Fibonacci 对象。Ruby 中的方法查找是动态的。
- en: extend
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: extend
- en: When you use `include` or `prepend` to add a module to a class, the module’s
    methods are added to the class as instance methods. In [Chapter 1](ch01.html "Chapter 1. Ruby
    Fundamentals"), you learned that there are also class methods that are called
    on the class itself instead of on an instance of the class. The `extend` statement
    adds the methods from a module as class methods. Use `extend` to add behavior
    to the class itself instead of instances of the class.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `include` 或 `prepend` 将一个模块添加到类中时，模块的方法会作为实例方法被添加到类中。在[第 1 章](ch01.html
    "第 1 章. Ruby 基础知识")中，你学习了也有一些类方法，它们是直接在类上调用，而不是在类的实例上调用。`extend` 语句将模块的方法作为类方法添加到类中。使用
    `extend` 可以将行为添加到类本身，而不是类的实例。
- en: The Ruby standard library includes a module named `Forwardable`, which you can
    use to extend a class. The `Forwardable` module contains methods useful for delegation.
    *Delegation* means relying on another object to handle a set of method calls.
    Delegation is a way to reuse code by assigning the responsibility of certain method
    calls to another class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 标准库包含一个名为 `Forwardable` 的模块，你可以使用它来扩展一个类。`Forwardable` 模块包含了对委托很有用的方法。*委托*意味着依赖另一个对象来处理一组方法调用。委托是一种通过将某些方法调用的责任分配给另一个类来重用代码的方式。
- en: 'For example, imagine a class named `Library` that manages a collection of books.
    We store the books in an array named `@books`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设有一个名为 `Library` 的类，用来管理一本书的集合。我们将书籍存储在一个名为 `@books` 的数组中：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can store our books, but we can’t do anything with them yet. We could use
    `attr_accessor` to make the `@books` array available outside of the class, but
    that would make all of the array’s methods available to users of our class. A
    user could then call methods such as `clear` or `reject` to remove all of the
    books from our library.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以存储我们的书籍，但目前还无法对它们做任何操作。我们可以使用 `attr_accessor` 来使 `@books` 数组在类外部可用，但那样会让数组的所有方法对类的使用者开放。这样，用户就可以调用诸如
    `clear` 或 `reject` 等方法，将图书馆中的所有书籍移除。
- en: Instead, let’s delegate a few methods to the `@books` array to provide the functionality
    we need—a way to get the size of the library and add a book.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将一些方法委托给 `@books` 数组，以提供我们需要的功能——获取图书馆大小和添加书籍的方法。
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Forwardable` module is in the Ruby Standard Library, not the Ruby core,
    so we first need to `require` it ➊. Next, we use `extend` to add the `Forwardable`
    methods to our class as class methods ➋. Finally, we can call the `def_delegators`
    method ➌. The first argument to this method is a symbol representing the instance
    variable to which we’re delegating methods.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Forwardable` 模块在 Ruby 标准库中，而不是 Ruby 核心库中，因此我们首先需要 `require` 它 ➊。接着，我们使用 `extend`
    将 `Forwardable` 方法添加到我们的类中作为类方法 ➋。最后，我们可以调用 `def_delegators` 方法 ➌。这个方法的第一个参数是一个符号，表示我们要委托方法的实例变量。'
- en: In this case, the instance variable is `@books`. The rest of the arguments are
    symbols representing the methods we want to delegate. The `size` method returns
    the number of elements in the array. The `push` method appends a new element to
    the end of an array.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，实例变量是 `@books`。其余的参数是表示我们要委托的方法的符号。`size` 方法返回数组中元素的数量。`push` 方法将一个新元素追加到数组的末尾。
- en: In the following example, `lib.size` initially prints 2 because we have two
    books in our library. After adding a book, the size updates to 3.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，`lib.size` 初始值为 2，因为我们图书馆中有两本书。添加一本书后，大小更新为 3。
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Ruby Object Model
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby 对象模型
- en: The *Ruby object model* explains how Ruby locates a method when it is called.
    With inheritance and modules, you may find yourself wondering exactly where a
    particular method is defined or, in the case of multiple methods with the same
    name, which one is actually invoked by a particular call.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ruby 对象模型* 解释了 Ruby 在调用方法时如何查找该方法。在继承和模块的情况下，你可能会想知道某个方法到底是在哪里定义的，或者在有多个同名方法的情况下，哪一个方法是由特定调用实际调用的。'
- en: Ancestors
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 祖先
- en: 'Continuing with the simple `Person` class defined previously, we can find out
    a lot about this class in IRB. First, let’s see which classes and modules define
    methods for the `Person` class:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用之前定义的简单 `Person` 类，我们可以在 IRB 中了解关于这个类的许多信息。首先，让我们看看哪些类和模块定义了 `Person` 类的方法：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The class method `ancestors` returns a list of classes that `Person` inherits
    from and the modules it includes. In this example, `Person`, `Object`, and `BasicObject`
    are classes, whereas `Distractable`, `Comparable,` and `Kernel` are modules. You
    can find out which of these are classes and which are modules by calling the `class`
    method as explained in the *Class* section below.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法 `ancestors` 返回 `Person` 类继承的类和它包含的模块的列表。在这个例子中，`Person`、`Object` 和 `BasicObject`
    是类，而 `Distractable`、`Comparable` 和 `Kernel` 是模块。你可以通过调用 `class` 方法来找出这些是类还是模块，具体内容在下面的
    *Class* 部分会解释。
- en: '`Object` is the default root of all Ruby objects. Object inherits from BasicObject
    and mixes in the Kernel module. BasicObject is the parent class of all classes
    in Ruby. You can think of it as a blank class that all other classes build on.
    Kernel defines many of the Ruby methods that are called without a receiver, such
    as puts and exit. Every time you call puts, you’re actually calling the instance
    method puts in the Kernel module.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object` 是所有 Ruby 对象的默认根类。`Object` 继承自 `BasicObject` 并混入了 `Kernel` 模块。`BasicObject`
    是 Ruby 中所有类的父类。你可以把它看作是一个空白类，所有其他类都建立在这个类之上。`Kernel` 定义了许多 Ruby 方法，这些方法在没有接收者的情况下调用，比如
    `puts` 和 `exit`。每次你调用 `puts` 时，实际上是在调用 `Kernel` 模块中的实例方法 `puts`。'
- en: The order of this list indicates the order in which Ruby searches for a called
    method. Ruby first looks for a method definition in the class `Person` and then
    continues looking through the list until the method is found. If Ruby doesn’t
    find the method, it raises a `NoMethodError` exception.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表的顺序表示 Ruby 查找方法的顺序。Ruby 首先会在 `Person` 类中查找方法定义，然后继续在列表中查找，直到找到该方法。如果 Ruby
    没有找到该方法，它会抛出一个 `NoMethodError` 异常。
- en: Methods
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: 'You can see a list of the class methods and instance methods defined by a class
    by calling `methods` and `instance_methods`, respectively. These lists include
    methods defined by all parent classes by default. Pass the parameter `false` to
    leave out only these:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过分别调用`methods`和`instance_methods`来查看类定义的类方法和实例方法。这些列表默认包含所有父类定义的方法。传递参数`false`可以仅排除这些方法：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Person` class contains almost 100 different class methods from its ancestors,
    but it defines none of its own, so the call to `methods(false)` returns an empty
    array. The call to `instance_methods` returns the `name` and `name=` methods defined
    by `attr_accessor` and the `<=>` method that we defined in the body of the class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`类包含了几乎100个从其祖先类继承的类方法，但它自己并没有定义任何类方法，因此调用`methods(false)`会返回一个空数组。调用`instance_methods`会返回由`attr_accessor`定义的`name`和`name=`方法，以及我们在类体内定义的`<=>`方法。'
- en: Class
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: The last piece of the object model concerns the `Person` class itself. Everything
    in Ruby is an object, that is, an instance of a class. Therefore, the `Person`
    class must be an instance of some class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对象模型的最后一部分涉及到`Person`类本身。在Ruby中，一切都是对象，也就是说，它是某个类的实例。因此，`Person`类必须是某个类的实例。
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All Ruby classes are instances of the class `Class`. Defining a class, such
    as `Person`, creates an instance of the class `Class` and assigns it to a global
    constant, in this case `Person`. The most important method in `Class` is `new`,
    which is responsible for allocating memory for a new object and calling the `initialize`
    method.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Ruby类都是`Class`类的实例。定义一个类，例如`Person`，实际上是创建了`Class`类的一个实例，并将其赋值给一个全局常量，这里是`Person`。`Class`类中最重要的方法是`new`，它负责为新对象分配内存并调用`initialize`方法。
- en: '`Class` has its own set of ancestors:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Class`有自己的祖先列表：'
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Class inherits from the class `Module`, which inherits from `Object` as before.
    The `Module` class contains definitions of several of the methods used in this
    section such as `ancestors` and `instance_methods`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Class`继承自`Module`类，`Module`类继承自`Object`类。`Module`类包含了本节中使用的多个方法的定义，例如`ancestors`和`instance_methods`。'
- en: Introspection
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射
- en: '*Introspection*, also known as *reflection*, is the ability to examine an object’s
    type and other properties as a program is running. You’ve already seen how to
    determine an object’s type by calling `class` and how to get a list of methods
    defined by an object by calling `methods` and `instance_methods`, but Ruby’s `Object`
    class defines several more methods just for introspecting objects. For example,
    given an object, you may want to determine if it belongs to a particular class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*反射*，也叫做*自省*，是指程序运行时，能够检查对象的类型及其他属性。你已经看到过如何通过调用`class`来确定对象的类型，以及如何通过调用`methods`和`instance_methods`来获取对象定义的方法列表，但Ruby的`Object`类还定义了几个用于自省对象的方法。例如，给定一个对象，你可能想确定它是否属于某个特定的类：'
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `is_a?` method returns `true` if the given class is the class of the receiving
    object. In this case, it returns `true` because the object `p` is a `Person`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定的类是接收对象的类，`is_a?`方法会返回`true`。在这个例子中，它返回`true`，因为对象`p`是`Person`类的实例。
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It also returns `true` if the given class or module is an ancestor of the receiving
    object. In this case, `Object` is an ancestor of `Person`, so `is_a?` returns
    `true`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定的类或模块是接收对象的祖先类，`is_a?`方法也会返回`true`。在这个例子中，`Object`是`Person`的祖先，所以`is_a?`返回`true`。
- en: 'Use the `instance_of?` method if you need to determine exactly which class
    was used to create an object:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要准确判断创建一个对象时使用了哪个类，可以使用`instance_of?`方法：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `instance_of?` method returns `true` only if the receiving object is an
    instance of the given class. This method returns `false` for ancestors and classes
    inheriting from the given class. This type of introspection is helpful in some
    situations, but generally you don’t need to know the exact class used to create
    an object—just the object’s capabilities.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`instance_of?`方法只有在接收对象是给定类的实例时才返回`true`。对于祖先类和继承自给定类的类，这个方法返回`false`。这种自省方式在某些情况下很有用，但通常你不需要知道创建对象时使用的具体类——只需要知道对象的能力。'
- en: Duck Typing
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鸭子类型
- en: In *duck typing,* you only need to know whether an object accepts the methods
    you need to call. If the object responds to the needed methods, you don’t have
    to worry about class names or inheritance. The name duck typing comes from the
    phrase, “If it walks like a duck and quacks like a duck, call it a duck.”
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在*鸭子类型*中，你只需要知道一个对象是否接受你需要调用的方法。如果对象能响应所需的方法，你就不必关心类名或继承关系。鸭子类型的名字来源于那句话：“如果它走起来像鸭子，叫起来像鸭子，那就把它叫做鸭子。”
- en: In Ruby, you can use the `respond_to?` method to see if an object responds to
    a particular method. If `respond_to?` returns `false`, then calling the method
    raises a `NoMethodError` exception as explained earlier.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ruby中，你可以使用`respond_to?`方法查看一个对象是否响应某个特定的方法。如果`respond_to?`返回`false`，那么调用该方法会抛出`NoMethodError`异常，如前所述。
- en: 'For example, imagine a simple method to print some information to a file with
    a timestamp:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个简单的方法，用来将带有时间戳的信息打印到文件中：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can try this method in IRB.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在IRB中尝试这个方法。
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First, open a `File` named *temp.txt* in the current directory and store the
    `File` instance in the variable `f` ➊. Then pass `f` and the message `"Hello,
    World!"` to the `write_with_time` method ➋. Finally, close the `File` with `f.close`
    ➌.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开当前目录下名为*temp.txt*的`File`并将`File`实例存储在变量`f`中 ➊。然后，将`f`和消息`"Hello, World!"`传递给`write_with_time`方法
    ➋。最后，使用`f.close`关闭`File` ➌。
- en: 'The file *temp.txt* in the current directory now contains a single line similar
    to the one here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当前目录下的文件*temp.txt*现在包含类似于下面这一行的内容：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This method works great until someone accidentally passes a value to it that
    isn’t a file, such as `nil`. Here’s a possible fix for that bug:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法运行得很好，直到有人不小心传递了一个不是文件的值，比如`nil`。这是可能的修复方案：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This fix solves the problem by checking to see if `file` is an instance of the
    `File` class ➊, but it also limits the usefulness of this method. Now it *only*
    works with files. What if you want to write over the network using a `Socket`
    or write to the console using `STDOUT`?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修复通过检查`file`是否是`File`类的实例来解决问题 ➊，但它也限制了这个方法的适用性。现在它*仅仅*适用于文件。如果你想通过`Socket`写入网络，或者使用`STDOUT`写入控制台，怎么办呢？
- en: 'Instead of testing the *type* of `file`, let’s test its *capabilities*:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与其测试`file`的*类型*，不如测试它的*功能*：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You know that the `write_with_time` method calls the method `puts`, so check
    to see if `file` responds to the `puts` method ➊. Now, `write_with_time` works
    with any data type that responds to the `puts` method.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道`write_with_time`方法调用了`puts`方法，所以检查`file`是否响应`puts`方法 ➊。现在，`write_with_time`可以与任何响应`puts`方法的数据类型一起使用。
- en: Using duck typing leads to code that can be easily reused. Look for more opportunities
    to apply duck typing as you build applications.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用鸭子类型编程可以使代码更加易于复用。在构建应用程序时，寻找更多应用鸭子类型编程的机会。
- en: Metaprogramming
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元编程
- en: '*Metaprogramming* is the practice of writing code that works with code instead
    of data. With Ruby, you can write code that defines new behavior at runtime. The
    techniques in this section can save you time and remove duplication from your
    code by allowing Ruby to generate methods when your program is loaded or as it
    runs.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*元编程*是编写与代码而非数据打交道的代码的实践。在Ruby中，你可以编写代码，在运行时定义新的行为。本节中的技术可以节省时间并消除代码中的重复，允许Ruby在程序加载时或运行时生成方法。'
- en: 'This section covers two different ways of dynamically defining methods: `define_method`
    and `class_eval`. It also covers `method_missing`, so you can respond to methods
    that haven’t been defined.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了两种动态定义方法的不同方式：`define_method`和`class_eval`。它还涉及了`method_missing`，使你能够响应那些未定义的方法。
- en: define_method
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: define_method
- en: Let’s say we have an application with a list of features that can be enabled
    for users. The `User` class stores these features in a hash named `@features`.
    If a user has access to a feature, the corresponding hash value will be `true`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个应用程序，其中包含可以为用户启用的功能列表。`User`类将这些功能存储在名为`@features`的哈希表中。如果某个用户可以访问某个功能，那么对应的哈希值将为`true`。
- en: 'We want to add methods of the form `can_` *`feature`*`!` and `can_` *`feature`*`?`
    to enable a feature and check if a feature is enabled, respectively. Rather than
    write several mostly identical methods, we can iterate over the list of available
    features and use `define_method`, as shown here, to define the individual methods:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望添加形式为`can_` *`feature`*`!` 和 `can_` *`feature`*`?`的方法，分别用于启用某个功能和检查某个功能是否启用。与其编写多个大致相同的方法，不如迭代可用功能的列表，并使用`define_method`来定义这些方法，如下所示：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `User` class first creates a constant array ➊ of available features named
    `FEATURES`. It then iterates over `FEATURES` using `each` and calls `define_method`
    to create a method of the form `can_` *`feature`*`!` ➋ to allow a user access
    to a feature. Still inside the `each` block, the class also defines a method of
    the form `can_` *`feature`*`?` ➌ that determines whether a user has access to
    the feature. This method converts the value `@features[f]` to either `true` or
    `false` by using two NOT operators ➍.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`类首先创建了一个常量数组 ➊，命名为`FEATURES`，其中包含可用的功能。然后，它使用`each`遍历`FEATURES`，并调用`define_method`来创建形如`can_`*`feature`*`!`
    ➋的方法，允许用户访问某个功能。仍然在`each`块中，类还定义了形如`can_`*`feature`*`?` ➌的方法，用来判断用户是否具有访问该功能的权限。这个方法通过使用两个NOT运算符
    ➍将`@features[f]`的值转换为`true`或`false`。'
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Using two NOT operators isn’t strictly necessary because the `@features` hash
    returns `nil` for keys without values and Ruby treats `nil` as `false`, but this
    technique is commonly used.*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用两个NOT运算符并非绝对必要，因为`@features`哈希表对没有值的键返回`nil`，而Ruby将`nil`视为`false`，但这种技巧通常被使用。*'
- en: 'Now let’s create a new `User` and try the dynamically defined methods:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个新的`User`并尝试动态定义的方法：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you want more practice with `define_method`, see if you can add methods of
    the form `cannot_`*`feature`*`!`, which disables a feature for the user. More
    details are provided in Exercise 3 at the end of this chapter.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更多地练习`define_method`，看看你能否添加形如`cannot_`*`feature`*`!`的方法，用于禁用用户的某个功能。更多细节可以在本章末的练习3中找到。
- en: class_eval
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: class_eval
- en: The `class_eval` method evaluates a string of code as if it were typed directly
    into the class definition. Using `class_eval` is an easy way to add instance methods
    to a class at runtime.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`class_eval`方法将代码字符串作为类定义中的代码直接执行。使用`class_eval`是向类在运行时添加实例方法的一个简单方法。'
- en: When I discussed `attr_accessor` in [Chapter 1](ch01.html "Chapter 1. Ruby Fundamentals"),
    you learned that it defines getter and setter methods for instance variables in
    a class, but I didn’t discuss exactly how those methods were defined. The `attr_accessor`
    method is built in to Ruby. You don’t need to define it yourself, but you can
    learn about `class_eval` by implementing your own version of `attr_accessor`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在[第1章](ch01.html "第1章 Ruby基础")中讨论`attr_accessor`时，你了解到它为类中的实例变量定义了getter和setter方法，但我并没有详细讨论这些方法是如何定义的。`attr_accessor`方法是Ruby内置的，你不需要自己定义它，但你可以通过实现自己的`attr_accessor`版本来了解`class_eval`。
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, you define a class named `Accessor` ➊ with a single class method named
    `accessor` ➋. This method works like the built-in `attr_accessor`. It accepts
    a single parameter representing the attribute for which you’re creating getter
    and setter methods. Pass the string to `class_eval`, which uses string interpolation
    to insert the value of `attr` as needed to define two methods. The first method
    has the same name as the attribute and returns the value of the attribute ➌. The
    second method is the attribute name followed by an equal sign. It sets the attribute
    to a specified value `val` ➍.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你定义了一个名为`Accessor`的类 ➊，并且它有一个名为`accessor`的类方法 ➋。这个方法的工作方式类似于内建的`attr_accessor`。它接受一个参数，表示你正在为其创建
    getter 和 setter 方法的属性。将字符串传递给`class_eval`，它使用字符串插值将`attr`的值插入到需要的地方，从而定义两个方法。第一个方法的名称与属性相同，并返回属性的值
    ➌。第二个方法的名称是属性名后跟一个等号。它将属性设置为指定的值`val` ➍。
- en: 'For example, if `attr` is `:name`, then `accessor` defines the methods `name`
    and `name=` by replacing `attr` with *name* in the specified places. This is a
    little hard to follow without an example. The following code uses the `accessor`
    method in a class:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果`attr`是`:name`，那么`accessor`通过将`attr`替换为*name*来定义`name`和`name=`这两个方法。这在没有示例的情况下有些难以理解。以下代码在一个类中使用了`accessor`方法：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'First, you have the `Element` class inherit from the `Accessor` class ➊ so
    the `accessor` method is available. Then, you pass the name of the instance variable
    to `accessor` ➋. Here, you pass the symbol `:name`. When the program runs, the
    call to `class_eval` automatically generates this code inside the `Element` class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你让`Element`类继承自`Accessor`类 ➊，这样就可以使用`accessor`方法。然后，将实例变量的名称传递给`accessor`
    ➋。在这里，你传递了符号`:name`。当程序运行时，对`class_eval`的调用会自动在`Element`类中生成如下代码：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `name` method returns the current value of the instance variable `@name`
    ➊. The `name=` method accepts a value and assigns it to `@name` ➋. Test this by
    creating an instance of the `Element` class and trying to get and set the value
    of `name`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`name` 方法返回实例变量 `@name` 的当前值 ➊。`name=` 方法接受一个值并将其赋给 `@name` ➋。通过创建一个 `Element`
    类的实例并尝试获取和设置 `name` 的值来测试它：'
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, create a new `Element` and initialize its name with `"lead"` ➊. Next,
    use the `name=` method to assign the new name `"gold"` ➋. Finally, use the `name`
    method to display the value of `@name` ➌. There you have it. With a bit of metaprogramming
    magic, you turned lead into gold.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的 `Element` 并将其名称初始化为 `"lead"` ➊。接下来，使用 `name=` 方法将新名称 `"gold"` 赋给它
    ➋。最后，使用 `name` 方法显示 `@name` 的值 ➌。就这样，通过一点元编程的魔法，你将铅变成了金。
- en: method_missing
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: method_missing
- en: Whenever Ruby can’t find a method, it calls `method_missing` on the receiver.
    This method receives the original method name as a symbol, an array of arguments,
    and any block passed to the method call.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 Ruby 找不到一个方法时，它会在接收者上调用 `method_missing`。该方法会接收原始方法名（作为符号）、一个参数数组以及传递给方法调用的任何块。
- en: By default, `method_missing` calls `super`, which passes the method up the ancestor
    chain until it finds an ancestor class containing the method. If the method reaches
    the `BasicObject` class, it raises a `NoMethodError` exception. You can override
    `method_missing` by defining your own implementation in a class to intercept these
    method calls and add your own behavior.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`method_missing` 会调用 `super`，这会将方法向上传递到祖先链，直到找到包含该方法的祖先类。如果方法到达 `BasicObject`
    类，它会抛出一个 `NoMethodError` 异常。你可以通过在类中定义自己的实现来覆盖 `method_missing`，拦截这些方法调用并添加自己的行为。
- en: 'Let’s start with a simple example so you can see how it works. This class echoes
    any unknown method calls back to you three times:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始，这样你就能看到它是如何工作的。这个类会将任何未知的方法调用返回给你三次：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now that `method_missing` is overridden, if you try to call a nonexistent method
    on an instance of this class, you’ll just see that method’s “echo” in the terminal:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`method_missing` 被覆盖了，如果你尝试在该类的实例上调用一个不存在的方法，你会在终端中看到该方法的“回音”：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A real-world use for `method_missing` is the Rails dynamic finder. Using dynamic
    finders, you can write Active Record queries like `Post.find_by_title("First Post")`
    instead of `Post.where(title: "First Post").first`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`method_missing` 的一个现实应用是 Rails 的动态查找器。通过使用动态查找器，你可以写出像 `Post.find_by_title("First
    Post")` 这样的 Active Record 查询，而不是 `Post.where(title: "First Post").first`。'
- en: Dynamic finders can be implemented using `method_missing`. Let’s define our
    own version of dynamic finders. Instead of method names like `find_by_`*`attribute`*,
    we’ll use `query_by_`*`attribute`* so we can avoid conflicts with the built-in
    methods.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 动态查找器可以使用 `method_missing` 实现。让我们定义我们自己的动态查找器版本。我们将使用 `query_by_`*`attribute`*
    而不是像 `find_by_`*`attribute`* 这样的方式，这样可以避免与内置方法发生冲突。
- en: 'Open the `Post` model at *app/models/post.rb* in your blog directory to follow
    along with this example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你博客目录中的 `app/models/post.rb` 文件，按照这个例子继续操作：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: First, define the `method_missing` class method ➊ because our `query_by_`*`attribute`*
    method will be called on the `Post` class. Next, test the name against a regular
    expression ➋.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义 `method_missing` 类方法 ➊，因为我们的 `query_by_`*`attribute`* 方法将被调用到 `Post` 类上。接下来，测试名称是否符合正则表达式
    ➋。
- en: Finally, call the built-in `where` method ➌ using the string captured by the
    regular expression and the first argument passed to the method. Be sure to call
    `super` ➍ if the string doesn’t match; this ensures that unknown methods will
    be sent to the parent class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用正则表达式捕获的字符串和传递给方法的第一个参数来调用内置的 `where` 方法 ➌。如果字符串不匹配，一定要调用 `super` ➍；这确保了未知的方法会被发送到父类。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The regular expression `/\Aquery_by_(.+)\z/` matches strings that start with
    “query_by_” and then captures the rest of the string using parenthesis. A full
    discussion of regular expressions is beyond the scope of this book. The website*
    [http://rubular.com/](http://rubular.com/) *is a great way to edit and test regular
    expressions online.*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*正则表达式 `/\Aquery_by_(.+)\z/` 匹配以 “query_by_” 开头的字符串，并使用括号捕获字符串的其余部分。正则表达式的全面讨论超出了本书的范围。网站*
    [http://rubular.com/](http://rubular.com/) *是一个在线编辑和测试正则表达式的好方法。*'
- en: The real dynamic finders also check to make sure the captured string matches
    an attribute of the model. If you try to call our `query_by_`*`attribute`* method
    with nonexistent column, it raises a `SQLException`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的动态查找器还会检查捕获的字符串是否与模型的属性匹配。如果你尝试用不存在的列调用我们的 `query_by_`*`attribute`* 方法，它会抛出一个
    `SQLException`。
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Our implementation of `query_by_`*`attribute`* has one more problem:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的`query_by_`*`attribute`*还有一个问题：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Because we’re overriding `method_missing` to call this method, Ruby doesn’t
    know that the `Post` class can respond to it. To fix this, we need to also override
    the `respond_to_missing?` method in the `Post` model at *app/models/post.rb*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们重写了`method_missing`来调用这个方法，Ruby 不知道`Post`类能够响应它。为了解决这个问题，我们还需要在`Post`模型的*app/models/post.rb*中重写`respond_to_missing?`方法。
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Instead of the regular expression used in `method_missing`, we just check if
    the method name starts with `"query_by_"` ➊. If it does, this method returns `true`.
    Otherwise, `super` is called. Now restart the Rails console and try again:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再使用`method_missing`中的正则表达式，而是检查方法名是否以`"query_by_"`开头 ➊。如果是，这个方法会返回`true`。否则，调用`super`。现在重新启动
    Rails 控制台并再次尝试：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With this change in place, `respond_to?` returns `true` as expected. Remember
    to always override `respond_to_missing?` when using `method_missing`. Otherwise,
    users of your class have no way of knowing which methods it accepts, and the duck
    typing techniques covered earlier will fail.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出这个改变之后，`respond_to?`按预期返回`true`。记住，在使用`method_missing`时，始终要覆盖`respond_to_missing?`。否则，使用你类的用户就无法知道它接受哪些方法，之前提到的鸭子类型技巧也会失效。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: If you write enough Ruby, then you will eventually see all of the techniques
    covered in this chapter used in real-world programs. When that time comes, you
    can be confident that you’ll understand what the code does, instead of just assuming
    that metaprogramming is some kind of magic.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你写足够多的 Ruby 代码，你最终会在实际的程序中看到本章所介绍的所有技巧。到那时，你可以确信你能理解代码的作用，而不仅仅是认为元编程是一种神奇的东西。
- en: In the next chapter, you’ll start building a new Rails application from scratch.
    Along the way I’ll cover some advanced data-modeling techniques and you’ll learn
    even more about Active Record.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将从头开始构建一个新的 Rails 应用程序。在这个过程中，我将介绍一些高级数据建模技巧，你还将深入了解 Active Record。
- en: For now, try these exercises.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试这些练习吧。
- en: Exercises
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '| Q: | 1\. The Rails framework makes extensive use of modules both as namespaces
    and to add behavior to classes. Open a Rails console inside your *blog* directory
    and look at the ancestors of `Post`. How many ancestors does it have? Based on
    their names, can you tell what some of them do? |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 问题： | 1\. Rails 框架广泛使用模块作为命名空间，并向类添加行为。在你的*blog*目录中打开 Rails 控制台，并查看`Post`的祖先类。它有多少个祖先？根据它们的名称，你能猜出它们的作用吗？
    |'
- en: '| Q: | 2\. Update the `define_method` sample by adding a `cannot_` *`feature`*`!`
    method. This method should set the value corresponding to the correct key in the
    `@features` hash to `false`. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 问题： | 2\. 更新`define_method`示例，添加一个`cannot_` *`feature`*`!`方法。此方法应将`@features`哈希中对应正确键的值设置为`false`。
    |'
- en: '| Q: | 3\. Verify that `class_eval` created the instance methods you expected
    inside the `Element` class by calling `Element.instance_methods(false)`. Then
    reopen the `Element` class and call `accessor :symbol` to add two more methods
    for an instance variable named `@symbol`. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 问题： | 3\. 通过调用`Element.instance_methods(false)`验证`class_eval`是否创建了你预期的实例方法。然后重新打开`Element`类，并调用`accessor
    :symbol`，为名为`@symbol`的实例变量添加两个方法。 |'
