- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: 3D Graphics and Animation
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 图形与动画
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: 'Sketch 51: Basic 3D Objects'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 51号草图：基本的 3D 物体
- en: 'We have been drawing only two-dimensional (2D) objects so far: lines, circles,
    triangles, rectangles, and images. Processing can draw three-dimensional (3D)
    objects too, although all that we can represent on a computer screen is a view
    of these, a 2D projection onto a plane. This projection aspect is what makes 3D
    more difficult. The x dimension is horizontal, and the y is vertical, and displaying
    those coordinates on a 2D screen is obvious. The third dimension, called z, would
    be perpendicular to the screen’s surface. In order to visualize it, the three
    coordinates must be reduced to two, which is what the projection does.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在绘制二维（2D）物体：线条、圆形、三角形、矩形和图像。Processing 也可以绘制三维（3D）物体，尽管我们在计算机屏幕上能显示的只是它们的视图，即投影到平面上的二维图像。这种投影特性使得
    3D 更加复杂。x 维度是水平的，y 维度是垂直的，在二维屏幕上显示这些坐标是显而易见的。第三个维度，称为 z，应该垂直于屏幕表面。为了可视化它，必须将三个坐标压缩为两个坐标，这正是投影所做的。
- en: Processing provides a 3D box (cube) and a sphere. In this sketch, we’ll draw
    these standard objects to show how 3D works.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 提供了一个 3D 立方体和一个球体。在这个草图中，我们将绘制这些标准物体，以展示 3D 的效果。
- en: 'To render 3D objects, Processing needs to use software that performs 3D drawing
    operations, called a 3D renderer. The default renderer, called `P2D`, only handles
    two dimensions. To specify three dimensions, we provide the `P3D` renderer 1 as
    an argument to the `size` function within `setup`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染3D物体，Processing 需要使用执行 3D 绘图操作的软件，称为 3D 渲染器。默认的渲染器叫做 `P2D`，它只处理二维图形。要指定三维度，我们需要在
    `setup` 函数中的 `size` 函数里提供 `P3D` 渲染器作为参数：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now all 3D operations are available. Cubes and spheres are provided through
    functions, just as rectangles and ellipses are in 2D. The function `sphere(R)`
    3 draws a sphere having radius `R` at the origin.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的 3D 操作都可以使用了。立方体和球体通过函数提供，就像二维中的矩形和椭圆一样。`sphere(R)` 3 函数绘制一个半径为 `R` 的球体，位于原点处。
- en: A sphere is drawn as a collection of triangles that have x-, y-, and z-coordinates
    at each vertex, oriented along the surface of the sphere and connected edge to
    edge. Think of it as the 3D version of drawing a circle using many short straight
    lines; it’s not exactly smooth, but if the triangles are small enough, the illusion
    works. The triangles will be visible unless outlines are turned off with a call
    to `noStroke()`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 球体是通过一组三角形绘制的，每个顶点都有 x、y 和 z 坐标，这些三角形沿球体表面方向排列并连接边缘。可以将其视为使用许多短直线绘制圆形的 3D 版本；它并不完全平滑，但如果三角形足够小，视觉效果就能达到理想的效果。除非通过调用
    `noStroke()` 关闭轮廓显示，否则这些三角形将是可见的。
- en: 'The `box(s)` function draws a cube where each side is `s` pixels long 4. To
    specify the size in each direction, we can use the second form of `box`: `box(w,
    h, d)`.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`box(s)` 函数绘制一个立方体，其中每个边长为 `s` 像素 4。为了指定每个方向的大小，我们可以使用 `box` 的第二种形式：`box(w,
    h, d)`。'
- en: 'To draw either shape somewhere other than the origin, we must first call the
    `translate()` 2 function to move the origin to the location where the sphere is
    to be drawn. In 3D, coordinates have three values: x, y, and z, and `translate()`
    has three corresponding parameters.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要在原点以外的位置绘制任何形状，我们必须先调用 `translate()` 2 函数，将原点移动到要绘制球体的位置。在 3D 中，坐标有三个值：x、y
    和 z，`translate()` 函数有三个对应的参数。
- en: Finally, when drawing in three dimensions, we need illumination to create depth.
    To enable lighting, we call `lights()` in the `draw()` function. Without the call
    to `lights()`, the sphere on the left of the Example A output would just look
    like a circle.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在绘制三维图形时，我们需要照明来创建深度感。为了启用照明，我们在 `draw()` 函数中调用 `lights()`。如果没有调用 `lights()`，示例
    A 输出中的左侧球体将看起来只是一个圆形。
- en: Example A
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 A
- en: 'We draw two spheres: one with the triangles composing the sphere visible (right)
    and one with them hidden (using `noStroke()`, left). The spheres move away from
    the point of view and then back, showing the third dimension more clearly than
    if they were still.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绘制了两个球体：一个显示球体组成的三角形（右侧），另一个将它们隐藏起来（使用`noStroke()`，左侧）。球体从视角处移开然后再回来，比静止状态更清楚地展示了第三维度。
- en: Example B
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 B
- en: We draw two cubes, again with the right one showing the cube outlines and with
    the left one not. The cubes also move away from the camera and then back again
    (along the z-axis).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绘制了两个立方体，再次右侧显示立方体的轮廓，左侧则不显示。立方体也从相机处移开然后再回来（沿着 z 轴）。
- en: 'Sketch 52: 3D Geometry—Viewpoints, Projections'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 52号草图：3D几何—视点与投影
- en: 3D objects are really simulations in which the edges and faces have locations
    in a virtual space having three coordinates. Because computer screens are 2D,
    visualizing these objects means projecting them onto a plane so they can be drawn
    on a screen.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 3D物体实际上是在虚拟空间中具有三维坐标的边缘和面部的模拟。由于计算机屏幕是二维的，视觉化这些物体意味着将它们投影到一个平面上，以便它们能够在屏幕上绘制出来。
- en: This plane lies between the object and the location from which the object is
    being seen, or the viewpoint. The viewpoint is a location in 3D space, marked
    by an eye in [Figure 52-1](#figure52-1). (2D scenes don’t really have a viewpoint;
    the entire image is a plane in the first place.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个平面位于物体与观察物体的视点之间。视点是三维空间中的一个位置，由[图52-1](#figure52-1)中的眼睛标示。（二维场景实际上没有视点；整个图像本身就是一个平面。）
- en: '![f052001](Images/f052001.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![f052001](Images/f052001.png)'
- en: 'Figure 52-1: Viewing a 3D object'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图52-1：查看一个3D物体
- en: There is a second crucial point for defining how a 3D view appears, and that
    is the location where the viewer (camera) is *looking*. This is the center of
    the scene, denoted by `(cx, cy, cz)`. The plane on which the 3D scene is projected
    is perpendicular to the line between `(ex, ey, ez)` and `(cx, cy, cz)`, and precisely
    what can be seen depends on the field of view, or the angle of the visible field,
    which determines what can be seen without moving the camera.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 定义3D视图外观的第二个关键点是观察者（摄像机）*看向*的地方。这是场景的中心，用`(cx, cy, cz)`表示。3D场景投影的平面与`(ex, ey,
    ez)`和`(cx, cy, cz)`之间的连线垂直，能够看到的内容完全取决于视野，或者说是可见场域的角度，决定了在不移动摄像机的情况下能看到什么。
- en: 'In Processing, we use a call to `camera()` 1 to set up the basic 3D configuration:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Processing中，我们使用调用`camera()` 1来设置基本的3D配置：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first three parameters are the viewpoint, and the next three are the center
    of the scene. The last three represent a vector that defines the direction *up*
    so that the scene is oriented correctly. In this example, *up* is the positive
    y-direction. It is a choice made by the programmer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个参数是视点，接下来的三个是场景的中心。最后三个表示一个向量，用来定义方向*上*，以确保场景正确地定向。在这个示例中，*上*是正y方向。这是程序员做出的选择。
- en: 'This sketch uses the `camera()` function to change the view of a pair of 3D
    objects according to user key presses. We move the location of the viewpoint by
    incrementing or decrementing the values of `ex` and `ez` inside the `keyPressed()`
    function 2 when the proper keys are pressed: a decreases x (moves left), d increases
    x (moves right), w decreases z, and s increases z (the distance to the objects).
    This is the equivalent of moving the player in a video game. The sphere is drawn
    at `(cx, cy, cz)` so that it is guaranteed to be visible at the outset. To move
    the center of the scene away from the sphere, we can change the value of `cy`
    with the up and down arrow keys. You can see the effect of changing the viewpoint
    and the center of the scene by experimenting with them using the keyboard.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图使用`camera()`函数，根据用户的按键操作，改变一对3D物体的视角。我们通过在`keyPressed()`函数中增加或减少`ex`和`ez`的值来移动视点的位置，当按下相应的键时：a减小x（向左移动），d增加x（向右移动），w减小z，s增加z（物体的距离）。这等同于在视频游戏中移动玩家。球体绘制在`(cx,
    cy, cz)`位置，确保它一开始就可见。为了将场景的中心从球体移开，我们可以使用上下箭头键改变`cy`的值。你可以通过使用键盘来实验这些改变视点和场景中心的效果。
- en: 'Sketch 53: 3D Illumination'
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图53：3D照明
- en: Illumination can profoundly change the appearance of a scene. The location of
    lights will cause specific portions of objects or scenes to be visible while others
    are not. Colored lights can change the apparent color of objects. Directional
    lighting can illuminate some portions of an object and not others. Processing
    provides all of these options.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 照明可以深刻地改变场景的外观。光源的位置会使物体或场景的特定部分可见，而其他部分则不可见。彩色光源可以改变物体的外观颜色。定向光可以照亮物体的某些部分而不照亮其他部分。Processing提供了所有这些选项。
- en: 'In this sketch, we’ll draw a sphere and permit the user to select the type
    of lighting used by typing a number. The lighting may be ambient (1), directional
    (2), point (3), spot (4), or all three: directional, point, and spot (5). The
    default lighting is code 0\. When the user changes the kind of lighting, the color
    changes as well: ambient is cyan, directional is violet, point is yellow, and
    spot is green.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将绘制一个球体，并允许用户通过输入数字来选择所使用的光照类型。光照可以是环境光（1）、定向光（2）、点光源（3）、聚光灯（4）或三者的组合：定向光、点光源和聚光灯（5）。默认光照为代码0。当用户改变光照类型时，颜色也会随之改变：环境光是青色，定向光是紫色，点光源是黄色，聚光灯是绿色。
- en: The previous sketches have used a call to `lights()` to provide default illumination.
    Alternatively, we can use a call to the `ambientLight()` function 1 to specify
    a color and, optionally, a location for ambient lighting, which is illumination
    that permeates the scene.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例使用了对`lights()`的调用来提供默认的照明。或者，我们可以调用`ambientLight()`函数 1 来指定环境光的颜色，并且可以选择性地指定环境光的位置，环境光是照亮整个场景的光源。
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first three parameters specify the RGB values for the color of the light.
    The next three are optional, and specify a location in three dimensions. Light
    spreads in all directions from this point.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个参数指定光的RGB颜色值。接下来的三个是可选的，用来指定光源的三维位置。从该点发出的光在各个方向上扩散。
- en: The `directionalLight()` function 2 specifies light from a specific direction,
    so it appears brighter when striking a surface perpendicular to that direction
    and less bright as the angle changes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`directionalLight()`函数 2 指定来自特定方向的光线，因此当光线垂直照射到表面时会显得更亮，而角度改变时亮度会减小。'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Again, the first three parameters represent the color of the light. The next
    three specify the direction. So, for example, if `dy=1` while `dx=0` and `dz=0`,
    the object will be illuminated from above.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，前面的三个参数表示光的颜色。接下来的三个参数表示光的方向。例如，如果`dy=1`而`dx=0`和`dz=0`，则物体将从上方照射。
- en: 'The `pointLight()` function 3 creates a single location from which illumination
    comes, like a lamp. This call places a light with the specified RGB values at
    the given (`x`, `y`, `z`) location:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`pointLight()`函数 3 创建一个光源位置，类似于灯泡。此调用会在指定的（`x`，`y`，`z`）位置放置一个RGB值的光源：'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, a `spotlight()` 4 is a concentrated directional light, and it is the
    most complex of the lighting sources. This call specifies a light of color RGB
    at location (`x`, `y`, `z`) pointed in direction (`dx`, `dy`, `dz`):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`spotlight()` 4 是一种集中的定向光源，它是最复杂的光源之一。此调用指定一个在位置（`x`，`y`，`z`）上，朝着方向（`dx`，`dy`，`dz`）照射的RGB颜色光源：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The value of `angle` is the dispersion angle of the light; the smaller the angle,
    the smaller the circle of light. This angle is in radians. The `concentration`
    specifies how the light varies across a cross section, brighter in the center
    and less bright at the edges. Values can vary from 1 to 10,000.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`angle`的值是光的散射角度；角度越小，光圈越小。该角度以弧度为单位。`concentration`指定光在横截面上的变化，中心较亮，边缘较暗。值的范围从1到10,000不等。'
- en: 'Sketch 54: Bouncing a Ball in 3D'
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 54：3D弹球
- en: Sketch 28 was a simulation of a bouncing ball. A circle (ball) moved about a
    window, bouncing when it struck the boundary. An obvious extension of this into
    three dimensions has a sphere bouncing about the inside of a cube. When the sphere
    (ball) strikes one of the sides of the cube, it bounces. This is conceptually
    the same problem as in two dimensions, but it requires quite a bit more code because
    there are more conditions to check and more things to draw.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 28 是一个弹球的模拟。一个圆形（球体）在窗口中移动，当它碰到边界时会反弹。将其扩展到三维，球体在立方体内反弹。当球体（弹球）撞到立方体的某一面时，它会反弹。这个问题在概念上与二维情况相同，但需要更多的代码，因为需要检查更多的条件并绘制更多的内容。
- en: 'The scene consists of the cube and a sphere. The cube occupies most of the
    field of view, bounded by the coordinate axes. We’ll draw the coordinate axes
    in special colors to show the three primary directions: x will be green, y will
    be blue, and z will be red. Instead of calling `box()`, we’ll draw the cube as
    the 12 lines that compose the edges so that we can see the ball inside.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 场景由一个立方体和一个球体组成。立方体占据了大部分视野，由坐标轴界定。我们将用特定的颜色绘制坐标轴，以显示三种主要方向：x轴为绿色，y轴为蓝色，z轴为红色。我们将不调用`box()`，而是绘制组成边缘的12条线，以便我们可以看到里面的球体。
- en: We’ll start drawing the cube from the origin in the upper-left corner, followed
    by the remaining nine edges, using the `mycube()` function 1. To see if the ball
    has collided with a side, we’ll test the ball’s coordinates against the x, y,
    and z values of the bounding planes, which are aligned with the coordinate axes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从左上角的原点开始绘制立方体，接着绘制剩下的九条边，使用 `mycube()` 函数 1。为了判断球体是否与某个面发生碰撞，我们将测试球体的坐标与边界平面的
    x、y 和 z 值，这些平面与坐标轴对齐。
- en: 'We can still use the `sphere()` function to draw the bouncing ball at position
    (`x`, `y`, `z`) using a translation of the origin to that point before drawing.
    After each frame, we move the ball an amount (`dx`, `dy`, `dz`). If the ball coordinates
    are such that the ball extends past any of the cube faces, then the ball bounces—it
    reverses the direction of motion to move away from the face. This is implemented
    by the `moveSphere()` function. For example, in the x-direction, this is the specific
    test for a bounce 2:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以使用 `sphere()` 函数绘制在位置 (`x`, `y`, `z`) 处反弹的球体，通过将原点平移到该点再进行绘制。每绘制完一帧后，我们将球体移动一定的量
    (`dx`, `dy`, `dz`)。如果球体的坐标使得球体超出了任何一个立方体面的边界，则球体会发生反弹——它会反转运动方向，远离该面。这通过 `moveSphere()`
    函数实现。例如，在 x 方向上，这是特定的反弹测试 2：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This test is specific for a sphere size of 12, because it checks against the
    radius of 6 pixels. A sphere of radius *r* is in contact with the cube if its
    center is within *r* pixels of a face, and *r* is half of the specified sphere
    size. Because the cube starts at (0, 0, 0) and is 200 units in each direction,
    the ball collides around x-coordinates 6 and 194\.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试特定于半径为 12 的球体，因为它是与 6 像素的半径进行比较的。如果球体的半径 *r* 使得球体的中心距离某个面不超过 *r* 像素，则球体与立方体接触，而
    *r* 是指定球体大小的一半。由于立方体从 (0, 0, 0) 开始，且每个方向的尺寸为 200 单位，因此球体在 x 坐标为 6 和 194 附近发生碰撞\。
- en: The center of the cube is at (100, 100, 100) 3. This point is the center of
    the scene. We stare into the cube from the viewpoint at the (`x`, `y`) center,
    which is (100, 100), but along the z-axis 400 units.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体的中心位于 (100, 100, 100) 3。这个点是场景的中心。我们从视点的 (`x`, `y`) 中心（即 (100, 100)）凝视立方体，但沿
    z 轴偏移 400 个单位。
- en: 'Sketch 55: Constructing 3D Objects Using Planes'
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 55：使用平面构造 3D 对象
- en: Processing provides only spheres and boxes as basic 3D objects, but that does
    not mean that we can’t make more complex things. We can construct arbitrary objects
    from polygons. This means we need to design the objects first, either on paper
    or using a 3D modeling program like Blender or Maya. The design yields a set of
    coordinates of the vertices (corner points) of the polygons in three dimensions.
    Then we can use Processing to draw these polygons and thus display the object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 仅提供球体和立方体作为基本的 3D 对象，但这并不意味着我们不能做更复杂的物体。我们可以从多边形构造任意对象。这意味着我们需要先设计对象，无论是在纸上还是使用像
    Blender 或 Maya 这样的 3D 建模程序。设计过程会得到多边形顶点（角点）的三维坐标。然后我们可以使用 Processing 绘制这些多边形，从而显示该对象。
- en: Since prisms are the easiest objects to build, this sketch will draw a prism
    and color the various faces differently so we can tell which are which. The point
    of view will move in a pattern so that the 3D nature of the object is clear.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于棱柱是最容易构建的对象，这个草图将绘制一个棱柱，并用不同的颜色表示不同的面，这样我们就可以分辨各个面。视角将沿着一定的模式移动，从而使物体的 3D
    特性变得清晰。
- en: 'A rectangular prism consists of rectangles joined along their edges. A cube
    is a rectangular prism, for example. The first step is to determine the values
    of the coordinates for each of the corners of the rectangles that will compose
    the prism. A piece of graph paper is useful for this: sketch the prism and define
    the x, y, z coordinate system (x is horizontal). Then start with the origin, the
    (0, 0, 0) point, and place the coordinates on the drawing where they belong, as
    in [Figure 55-1](#figure55-1). Now you can simply read off the coordinates of
    each rectangle in any order you like. For example, the front face of the prism
    in the figure is defined by the following coordinates: (0, 0, 0), (sx, 0, 0),
    (sx, sy, 0), and (0, sy, 0).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 长方体由沿边缘连接的矩形组成。例如，立方体就是一种长方体。第一步是确定组成棱柱的每个矩形的角点坐标。画一些方格纸来帮助理解非常有用：在纸上画出棱柱，并定义
    x、y、z 坐标系（x 为水平轴）。然后，从原点 (0, 0, 0) 开始，将坐标按位置放置在图纸上，如 [图 55-1](#figure55-1) 所示。现在你可以随意读取每个矩形的坐标。例如，图中棱柱的前面是由以下坐标定义的：(0,
    0, 0)、(sx, 0, 0)、(sx, sy, 0)、和 (0, sy, 0)。
- en: '![f055001](Images/f055001.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![f055001](Images/f055001.png)'
- en: 'Figure 55-1: 3D coordinates of a prism'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 55-1：棱柱的 3D 坐标
- en: 'To draw polygons that are connected as an object, we bookend that drawing code
    between calls to the `beginShape()` and `endShape()` functions. In this case,
    because the polygons used are rectangles, `beginShape()` is passed the argument
    `QUAD` 1; another option would be `TRIANGLES`. This argument specifies to Processing
    the number of vertices needed for each polygon (in this case four). Between the
    begin and end calls, we place calls to a function named `vertex()` 2. Each such
    call specifies a point in 3D space that represents, in this instance, a corner
    of a rectangle. For example, the front face of the prism is defined by these calls:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制作为一个对象连接的多边形，我们将绘制代码包裹在对`beginShape()`和`endShape()`函数的调用之间。在这种情况下，由于使用的多边形是矩形，`beginShape()`传入参数`QUAD`
    1；另一种选择是`TRIANGLES`。这个参数告诉Processing每个多边形所需的顶点数量（在本例中为四个）。在开始和结束的调用之间，我们调用一个名为`vertex()`的函数
    2。每次调用都指定了3D空间中的一个点，在此实例中代表矩形的一个角。例如，棱镜的前面是通过这些调用来定义的：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The sketch draws four rectangles connected along vertical edges, creating a
    rectangular prism with no top or bottom. Each is filled with a different color
    merely by placing a call to `fill()` immediately before the four vertices for
    that rectangle are specified.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 草图绘制了四个连接在一起的矩形，沿垂直边缘形成一个没有顶部和底部的矩形棱镜。每个矩形通过在指定矩形的四个顶点之前立即调用`fill()`，并使用不同的颜色填充。
- en: The viewpoint changes by the amount `dz` during each frame between a minimum
    of z = −200 and a maximum of z = 300 4 so that various views of the prism are
    displayed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 视点在每一帧中根据`dz`的量发生变化，z的最小值为-200，最大值为300 4，从而展示棱镜的各种视图。
- en: 'Sketch 56: Texture Mapping'
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图56：纹理映射
- en: 'In Sketch 55 we gave each side of a prism a distinct color to make it easy
    to identify each face. This was done as an exercise, but in most real applications,
    a prism would either be a single color or would have a texture placed on it. A
    texture is a pattern, often simply an image, that we apply like a decal to a polygon.
    In this way, we can make a simple prism look like many things: a building, a book,
    a chair—nearly anything with corners. This sketch applies a texture (carpet) to
    a polygon (a rectangle) and moves the viewpoint so that the 3D effect can be seen.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在草图55中，我们给棱镜的每一面赋予了不同的颜色，以便轻松识别每一面。这样做是作为一个练习，但在大多数实际应用中，棱镜通常是单一颜色，或者会有纹理被应用到它上面。纹理是一种图案，通常只是一个图像，我们像贴花一样将其应用到多边形上。通过这种方式，我们可以使一个简单的棱镜看起来像许多东西：建筑物、书籍、椅子——几乎任何有角的物体。这个草图将纹理（地毯）应用于多边形（矩形），并移动视点，以便可以看到3D效果。
- en: 'Applying an image to a polygon as a texture is a process called texture mapping.
    The details of the algorithm are complex, but the idea is simple enough, and the
    way it is implemented in Processing fits nicely into the scheme already explained
    for drawing objects. In English, the process is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像应用于多边形作为纹理的过程叫做纹理映射。算法的细节很复杂，但这个概念足够简单，而且它在Processing中的实现很自然地融入了之前为绘制对象所解释的方案中。英文过程如下：
- en: Read in an image that will serve as the texture 1. This will be a `PImage`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取将作为纹理的图像 1。这将是一个`PImage`。
- en: Define the coordinates of a 3D polygon, possibly part of a bigger object.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个3D多边形的坐标，可能是更大对象的一部分。
- en: Map each of the four corners of the texture image to a vertex of the polygon;
    that is, if the polygon is a rectangle, decide which corners of the texture image
    will be placed over which corners of the rectangle.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将纹理图像的每个四个角映射到多边形的一个顶点；也就是说，如果多边形是矩形，决定纹理图像的哪些角将被覆盖在矩形的哪些角上。
- en: Convert the coordinate mapping into calls to the `vertex()` function 4.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将坐标映射转换为对`vertex()`函数的调用 4。
- en: Bracket the vertex calls between `beginShape()` 2 and `endShape()` 5.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`vertex()`的调用包裹在`beginShape()` 2和`endShape()` 5之间。
- en: Immediately after `beginShape()`, tell Processing which texture image to use
    by calling the built-in `texture()` function 3.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`beginShape()`之后，立即通过调用内置的`texture()`函数 3来告诉Processing使用哪个纹理图像。
- en: 'In this example, we use an image of carpet texture. As an orientation marker,
    a red rectangle is placed in the upper-left corner and a green one in the upper
    right. The texture image is 524 by 928 pixels. This is the coordinate mapping
    from texture to vertices, as shown in [Figure 56-1](#figure56-1):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用的是地毯纹理的图像。作为方位标记，一个红色矩形放置在左上角，一个绿色矩形放置在右上角。纹理图像的尺寸为524乘928像素。这是从纹理到顶点的坐标映射，如[图56-1](#figure56-1)所示：
- en: Texture (0, 0) maps to polygon (0, 0, 0).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理（0, 0）映射到多边形（0, 0, 0）。
- en: Texture (524, 0) maps to polygon (sx, 0, 0).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理（524, 0）映射到多边形（sx, 0, 0）。
- en: Texture (524, 928) maps to polygon (sx, sy, 0).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理(524, 928)映射到多边形(sx, sy, 0)。
- en: Texture (0, 928) maps to polygon (0, sy, 0).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理(0, 928)映射到多边形(0, sy, 0)。
- en: '![f056001](Images/f056001.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![f056001](Images/f056001.png)'
- en: 'Figure 56-1: Mapping texture coordinates to a polygon'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 56-1：将纹理坐标映射到多边形
- en: 'The `vertex()` function allows us to specify the mapping with two optional
    parameters for texture coordinates. This would be the mapping of the previous
    vertices:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`vertex()`函数允许我们使用两个可选参数来指定纹理坐标的映射。以下是之前顶点的映射：'
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because Processing knows the size of the texture image (`timage`), the numeric
    constant 524 in the preceding mappings can be replaced by `timage.width` 4. Similarly,
    we can use `timage.height` instead of 928.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Processing知道纹理图像（`timage`）的大小，前面映射中的数值常量524可以替换为`timage.width` 4。同样，我们可以用`timage.height`代替928。
- en: 'Sketch 57: Billboards—Simulating a Tree'
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 57：广告牌——模拟一棵树
- en: 'Let’s draw a tree in three dimensions. A prism is a simple thing, but a tree?
    Trees have many parts: leaves, branches, bark, and myriad details. Graphics specialists
    have devised very complex methods to create complex things like trees, mountains,
    and living things, but in most cases, it is not necessary to go to that trouble.
    For artwork, animations, and games, there are ways to simplify things (to “cheat”)
    so that they look pretty good while still being easy to implement. Building a
    tree as a billboard is one of those things.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在三维空间中画一棵树。棱柱是一个简单的物体，但树呢？树有很多部分：叶子、树枝、树皮以及各种细节。图形专家已经设计出了非常复杂的方法来创建像树、山脉和生物等复杂的东西，但在大多数情况下，我们不需要那么麻烦。对于艺术作品、动画和游戏，有一些方法可以简化事物（即“作弊”），使它们看起来相当不错，同时仍然容易实现。将树构建为广告牌就是其中之一。
- en: In its simplest form, a billboard is a rectangle with a texture drawn on it.
    It resembles the kind of billboard you can see while driving down tourist highways,
    and in computer graphics, it would normally occur only at a large distance from
    the viewer. To make a tree, we’ll use two billboards at right angles to each other,
    joined at the vertical center of each. Each one is a rectangle with a tree image
    textured onto it. The idea is that from any angle one sees the entire tree, and
    moving the viewpoint appears to change the view of the tree. From close up it
    is obvious what is happening, but when seen from a medium distance or while the
    viewer is moving, the illusion is a good one.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式下，广告牌是一个矩形，上面绘制有纹理。它类似于你在旅游公路上驾驶时看到的广告牌，而在计算机图形学中，广告牌通常只出现在距离观察者较远的位置。为了做一棵树，我们将使用两个垂直的广告牌，它们在各自的垂直中心连接。每个广告牌都是一个矩形，上面贴有树的纹理图像。这个想法是，从任何角度看都能看到完整的树，并且通过移动视角，似乎能够改变树的视图。近距离观察时，很容易看出其中的原理，但从中等距离或在观察者移动时，这种幻象效果非常逼真。
- en: '[Figure 57-1](#figure57-1) shows how we arrange the two perpendicular rectangles
    in three dimensions. The texture placed on them needs to have a transparent background,
    or the white rectangles will be visible. This means using either a GIF or PNG
    format image file, which are the ones that support transparency.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 57-1](#figure57-1)展示了我们如何在三维空间中排列两个垂直的矩形。放置在它们上的纹理需要具有透明背景，否则白色矩形将会显现出来。这意味着需要使用GIF或PNG格式的图像文件，因为它们支持透明度。'
- en: '![f057001](Images/f057001.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![f057001](Images/f057001.png)'
- en: 'Figure 57-1: Two perpendicular rectangles'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 57-1：两个垂直的矩形
- en: The sketch first reads in the tree image that we’ll use as a texture and opens
    the window, as usual. The `draw()` function sets up the camera 1 and draws two
    rectangles at the origin, both using the tree as a texture that we map onto the
    rectangles 2, similar to what was done in Sketch 56\. We rotate the second texture-mapped
    rectangle by 90 degrees 3 and translate it by 13 units in the x and z directions
    to align it with the center of the first rectangle. (The rectangle is 26 units
    wide, and 13 units is half of that.)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 草图首先读取我们将用作纹理的树的图像，并像往常一样打开窗口。`draw()`函数设置摄像机1，并在原点绘制两个矩形，都使用树作为纹理，并将纹理映射到矩形2上，这与草图56中所做的类似。我们将第二个纹理映射的矩形旋转90度3，并将其在x和z方向上平移13个单位，使其与第一个矩形的中心对齐。（矩形宽度为26单位，13单位是其中的一半。）
- en: We also change the viewpoint slightly in each frame so that the 3D effect is
    obvious when the sketch is executing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会在每一帧中稍微改变视角，以便在草图执行时，三维效果更为明显。
- en: 'Sketch 58: Moving the Viewpoint in 3D'
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 58：在三维中移动视角
- en: In a first-person computer game, the representation of the player in the game
    is an avatar, controlled by the player. Pressing w moves the avatar forward, s
    moves it backward, a moves it left, and d moves it right. This scheme is easy
    for a player to understand but harder to implement than the scheme we have been
    using.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一人称电脑游戏中，玩家在游戏中的表现是一个头像，由玩家控制。按w键让头像前进，按s键让它后退，按a键让它左移，按d键让它右移。这种方案对于玩家来说容易理解，但比我们一直使用的方案更难实现。
- en: In the sketches presented so far, the movement has been automatic or based on
    simplistic assumptions—a and d move along the x-axis and w and s move along the
    z-axis—but people don’t move in that way. The a and d keys should rotate the player
    about their own axis, and the w and s keys should move the player forward and
    backward along the direction defined by that angle. As a demonstration of avatar
    movement control, this sketch draws nine cubes and allows the user to move among
    them using this technique.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止展示的草图中，运动是自动的或基于简单的假设——a和d沿x轴移动，w和s沿z轴移动——但人类的运动并不是这样。a和d键应该使玩家围绕自己的轴旋转，w和s键应该让玩家沿着由角度定义的方向前进或后退。作为头像运动控制的演示，这个草图绘制了九个立方体，并允许用户通过这种技术在它们之间移动。
- en: 'The avatar has a direction in which it is facing, defined by the variable `angle`
    (in degrees). The a and d keys allow the user to change this angle by one degree
    per key press 3. Changing the angle will not modify the camera position, but it
    does modify the center of the scene by rotating it about the avatar. Because the
    vertical axis is y, we can calculate this in the x-z plane as a simple trigonometric
    relationship 4:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 头像有一个面向的方向，由变量`angle`（以度为单位）定义。按下a和d键可以让用户每按一次键改变一个角度。改变角度不会修改相机的位置，但会通过围绕头像旋转改变场景的中心。因为垂直轴是y轴，我们可以在x-z平面内通过简单的三角函数关系来计算这一点4：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The value 20,000 represents a large distance, effectively infinite, that provides
    a distant focus point.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 值20,000代表一个大距离，实际上是无限的，提供一个遥远的焦点。
- en: Pressing w moves the avatar one unit along the direction it is facing, which
    is the variable `angle`. Each unit moved changes the `x` position by `dx` and
    the `z` position by `dz`, as defined in [Figure 58-1](#figure58-1).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 按下w键让头像沿其面向的方向移动一个单位，这个方向由变量`angle`定义。每移动一个单位，`x`位置会改变`dx`，`z`位置会改变`dz`，如[图58-1](#figure58-1)所定义。
- en: '![f058001](Images/f058001.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![f058001](Images/f058001.png)'
- en: 'Figure 58-1: Converting (x, z) motion to (angle, distance)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图58-1：将（x，z）运动转换为（角度，距离）
- en: The position of the avatar is (`eyex`, `eyez`), and it is likely that for any
    given forward 1 or backward 2 movement, both of these values will change. One
    key press will move the avatar 5 units, or `dx*5`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 头像的位置是（`eyex`，`eyez`），并且对于任何给定的前进1或后退2动作，这两个值可能都会变化。按一次键将移动头像5个单位，或`dx*5`。
- en: 'Sketch 59: Spotlights'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图59：聚光灯
- en: If the ambient illumination is off and the background is dark, any objects drawn
    within the 3D space of the Processing graphics world will not be visible. This
    sketch simulates illumination in a new way—as a small spotlight source in a dark
    space. The spotlight shines on the center-of-scene coordinates, and the rest of
    the scene is unlit. The sketch places three cubes of different colors around the
    scene 2, and the user can explore the space by rotating and watching for the cubes
    to light up.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果环境光照关闭且背景较暗，任何绘制在Processing图形世界的3D空间中的物体都将不可见。这个草图以一种新的方式模拟了光照——作为一个在黑暗空间中的小聚光灯源。聚光灯照射在场景中心坐标上，其余的场景则没有光照。这个草图在场景中放置了三个不同颜色的立方体，用户可以通过旋转并观察立方体的亮起情况来探索这个空间。
- en: 'This sketch uses the same code for `keyPressed()` as does the previous sketch,
    so the avatar can rotate and move forward and backward 3. A Processing spotlight
    is placed at the camera coordinates 1:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图与之前的草图使用相同的`keyPressed()`代码，因此头像可以旋转并前后移动3。一个Processing聚光灯被放置在相机坐标1：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first three parameters (`255`, `255`, `20`) of the spotlight represent the
    RGB values for the color of the light, the next three (`eyex`, `eyey`, `eyez`)
    are the 3D coordinates of the light, and the next three (`cx`, `cy`, `cz`) are
    the coordinates toward which the light is pointed. This means that wherever the
    camera/avatar moves, a spotlight is shining on the center of the scene. The angle
    for the light, `PI/4` (45 degrees) is the 10th parameter, and we can increase
    or decrease it to see what happens to the scene. The value `300` indicates how
    strongly the light concentrates near the center of the spot, with larger numbers
    being more focused.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 聚光灯的前三个参数（`255`，`255`，`20`）代表光线的RGB值，接下来的三个参数（`eyex`，`eyey`，`eyez`）是光线的3D坐标，接下来的三个参数（`cx`，`cy`，`cz`）是光线指向的坐标。这意味着无论相机/化身如何移动，聚光灯始终照射到场景的中心。光线的角度，`PI/4`（45度），是第10个参数，我们可以增加或减少它，以查看场景发生的变化。数值`300`表示光线在聚光点中心附近的集中程度，较大的数值表示光线更为集中。
- en: 'We can define lights for other types of local illumination. Car headlights,
    for example, are simply two spotlights separated by a small distance. There is
    a commented-out statement that adds a second light to the one in the sketch:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为其他类型的局部照明定义光源。例如，汽车的车头灯实际上就是两个相隔较小距离的聚光灯。代码中有一个被注释掉的语句，用来为草图中的光源添加第二个光源：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Spotlights are only visible by their light reflected off of objects. They cannot
    be seen as glowing objects. The same is true of point lights and other sources.
    In that sense, lights are not objects. Surrounding a light with an object illuminates
    the objects around it but does not make the light source visible.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 聚光灯只能通过照射在物体上的光线反射来看见，不能作为发光物体被直接看到。点光源和其他光源也是如此。从这个意义上讲，光源并不是物体。围绕光源放置物体会照亮周围的物体，但不会使光源本身可见。
- en: We can make lights flash on and off or change color by alternately calling the
    `spotLight()` function or not, depending on a flag that is either true or false,
    here named `flash`. Simply change a counter after each frame, and change the flag
    after a fixed number of frames (20 here). The following code illuminates one of
    two spheres alternately with red or blue, like police car lights.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过交替调用`spotLight()`函数或不调用它，来使光源闪烁或改变颜色，取决于一个标志（`flash`），它的值为真或假。只需在每一帧后改变计数器，并在固定的帧数（此处为20帧）后改变标志。以下代码交替地用红色或蓝色照亮两个球体，就像警车的闪烁灯一样。
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Sketch 60: A Driving Simulation'
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图60：驾驶模拟
- en: Driving simulations and games have a specific, standard interface and visual
    presentation. Unlike previous sketches, where users can move about the space but
    are not themselves visible, driving simulations display the avatar as a car, and
    the camera (viewpoint) is usually behind and above the car so that the view of
    the car is always looking forward. Cars drive on roads, so a background is important;
    without one the user can’t tell when they are on a road or have any real idea
    of how fast they are moving. This sketch will allow a user to drive a vehicle
    (a rectangular prism, actually) around a track, using the same scheme to move
    the avatar as before.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 驾驶模拟和游戏具有特定的标准界面和视觉呈现。与之前的草图不同，在那些草图中用户可以在空间中移动但自己不可见，驾驶模拟显示的是化身为一辆车，摄像头（视角）通常位于车后方且偏上方，以便车的视角始终朝向前方。汽车行驶在道路上，因此背景非常重要；没有背景，用户就无法判断自己是否在道路上，也无法准确知道自己的行驶速度。这一草图将允许用户驾驶一辆车（实际上是一个长方体）沿着轨道行驶，使用与之前相同的方式来移动化身。
- en: The first thing to do is create a track. It will simply be an image, so we can
    use Paint or some other drawing program. It should be large enough so that it
    provides some entertainment value (variety) and does not distort too badly when
    displayed. The example shown in [Figure 60-1](#figure60-1) is 1,000×1,000 pixels.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要创建一个轨道。它将只是一个图像，因此我们可以使用画图工具或其他绘图程序。图像的大小应足够大，以提供一些娱乐性（多样性），并且在显示时不会严重失真。图中显示的示例（[图60-1](#figure60-1)）是1,000×1,000像素。
- en: '![f060001](Images/f060001.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![f060001](Images/f060001.png)'
- en: 'Figure 60-1: A simple track for driving on'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图60-1：简单的驾驶轨道
- en: 'The sketch reads this image and uses it as a texture for a 1,000×1,000 square
    drawn on the x-z plane 1:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 草图读取这张图像，并将其用作绘制在x-z平面上的1,000×1,000方形纹理：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The viewpoint needs to be above and behind the car. If the variables `dx` and
    `dz` represent the unit change in the x and z directions for the given `angle`
    (the current facing angle of the car), and `carX` and `carZ` are the horizontal
    and vertical positions of the car, then this should be the viewpoint 3:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 视角需要位于汽车的上方和后方。如果变量 `dx` 和 `dz` 代表给定 `angle`（汽车当前的朝向角度）下 x 和 z 方向的单位变化，而 `carX`
    和 `carZ` 是汽车的水平和垂直位置，那么视角应该是这样设置的 3：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: And it should have some fixed height `eyey=20`. The value `50` is a scale factor
    that depends on the image size.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该有一个固定的高度 `eyey=20`。值 `50` 是一个与图像大小相关的缩放因子。
- en: We draw the car at coordinates `(carX, 0, carZ)`. After each step, these coordinates
    change as a function of the car’s speed (variable `velocity`); the `velocity`
    value increases or decreases as the user presses the w and s keys 4 (as opposed
    to previous sketches in which we moved forward and backward using those keys).
    The w key is the accelerator pedal, and the s is the brake. The car maintains
    its speed once the user presses one of those keys, and the user can focus on steering
    using a and d.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在坐标 `(carX, 0, carZ)` 处绘制汽车。每次移动后，这些坐标会随着汽车速度（变量 `velocity`）的变化而变化；`velocity`
    的值会随着用户按下 w 和 s 键而增加或减少（与之前的草图不同，在之前的草图中我们使用这些键来向前和向后移动）。w 键是油门踏板，s 键是刹车。汽车在用户按下任意一个键后会保持当前速度，用户可以专注于通过
    a 和 d 键进行转向。
- en: 'We calculate the motion of the car as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以下方式计算汽车的运动：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Then we use the `translate()` function to make the car face the direction of
    motion 2. The car should always face away from the camera, so to make the car
    face in the correct direction, we rotate it by `–angle`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用 `translate()` 函数使汽车朝向运动方向 2。汽车应该始终背对相机，因此为了让汽车朝向正确的方向，我们将其旋转 `–angle`。
- en: The effect is that the car (a red prism) can speed up (w) and slow down (s)
    and turn left (a) or right (d) so as to stay on the grey circular path, and the
    camera follows the car at a discreet distance.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 效果是，汽车（一辆红色的棱柱体）可以加速（w）和减速（s），并可以向左转（a）或向右转（d），以保持在灰色的圆形路径上，同时相机保持在适当的距离跟随汽车。
