- en: '**10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10'
- en: DISKS, PARTITIONING, AND GEOM**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘、分区和几何**
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: A sysadmin can’t overemphasize the importance of managing disks and filesystems.
    (Go ahead, try to emphasize it too much. I’ll wait.) Your disks contain your data,
    making reliability and flexibility paramount to the operating system. FreeBSD
    supports a variety of filesystems and has many different ways to handle them.
    In this chapter, we’ll consider the most common disk tasks every sysadmin performs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员不能过分强调管理磁盘和文件系统的重要性。（去吧，试着过分强调。我会等着的。）你的磁盘存储着你的数据，这使得操作系统对其可靠性和灵活性要求极高。FreeBSD支持多种文件系统，并有许多不同的方法来处理它们。在本章中，我们将讨论每个系统管理员都会执行的最常见的磁盘任务。
- en: First, let’s discuss the most important thing to remember about storage devices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论存储设备最重要的一点。
- en: '**Disks Lie**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**磁盘会撒谎**'
- en: 'Once upon a time, a sysadmin could make decisions about a disk based on the
    information it provided. You could plug in a hard drive and query it for the number
    of platters, cylinders, sectors, and more. Those days are long, long past. Yes,
    you can perform the same query and get an answer, but those answers don’t reflect
    any reality. Today, a disk is a magic box that regurgitates data on request. Some
    of those magic boxes contain spinning platters. Others lack moving parts. The
    magic boxes provide numbered sectors for storing bits and bytes. The relationship
    between those numbers and the contents of the box? That’s magic: inscrutable and
    unknowable.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 曾几何时，系统管理员可以根据磁盘提供的信息做出决策。你可以插入硬盘，查询其盘片数、气缸数、扇区数等更多信息。那时候已经是很久很久以前的事了。是的，你现在可以执行相同的查询并得到答案，但这些答案并不反映任何现实。今天，磁盘就像是一个魔法盒子，根据需求吐出数据。这个魔法盒子有的包含旋转的盘片，另一些则没有活动部件。这个魔法盒子提供带编号的扇区来存储比特和字节。那些数字和盒子内容之间的关系？那就是魔法：不可理解且无法知晓。
- en: In previous books, including earlier editions of this one, I’ve discussed the
    importance of proper data placement on the disk, but all of that knowledge is
    completely obsolete. If you still retain any of that knowledge, discard it in
    favor of something more useful, like the complete biographies of all the actors
    who appeared in any role in classic *Doctor Who*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的书籍中，包括本书的早期版本，我讨论过数据在磁盘上正确放置的重要性，但这些知识如今已经完全过时。如果你仍然保留这些知识，请抛弃它，转而学习更有用的东西，比如所有出演经典*神秘博士*角色的演员的完整传记。
- en: As far as disk design goes, the only thing you need to know about is *logical
    block addressing (LBA)*. Each sector on a disk is assigned a number. Filesystems
    call disk sectors by number. That’s it. Anything beneath LBA is pure guesswork
    on your part.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 就磁盘设计而言，你需要知道的唯一事情就是*逻辑块寻址（LBA）*。磁盘上的每个扇区都会分配一个编号。文件系统通过编号来调用磁盘扇区。就是这样。LBA以下的任何内容，都只是你个人的猜测而已。
- en: 'Unfortunately, disks now have a new category of lies they tell: sector size.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，磁盘现在有了一类新的谎言：扇区大小。
- en: Up through the 1990s, disk sector sizes varied from 128 bytes to 2KB. Even the
    original IBM PC could understand different sector sizes on floppy disks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到了1990年代，磁盘扇区大小从128字节到2KB不等。即使是最早的IBM PC也能理解软盘上不同的扇区大小。
- en: In the early 2000s, though, manufacturers settled on 512-byte sectors. Today’s
    hard drives are much larger, and the files are similarly larger. In the last few
    years, the 512-byte sectors have mostly been replaced with 4,096-byte sectors,
    called *4K drives*. This sector size makes more sense for the type of data we
    store today.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在2000年代初期，制造商决定使用512字节的扇区。今天的硬盘容量大得多，文件也同样更大。在过去的几年里，512字节的扇区大多被4,096字节的扇区取代，这种硬盘被称为*4K硬盘*。这种扇区大小对于我们今天存储的数据类型来说更为合理。
- en: The problem is, operating systems like Windows XP know that a disk sector always
    has been, and always will be, 512 bytes. These operating systems won’t tolerate
    hard drives that reported having 4KB sectors because everybody knows there’s no
    such thing. If you manufacture 4K drives, what do you do?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，像Windows XP这样的操作系统知道磁盘扇区一直是，而且永远会是，512字节。这些操作系统无法容忍报告拥有4KB扇区的硬盘，因为大家都知道根本没有这种东西。如果你制造了4K硬盘，你该怎么办？
- en: The same thing you always do.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就是你一直在做的事。
- en: You teach the hard drive to lie.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你教硬盘撒谎。
- en: Best of all, different 4K drives lie in different ways. If the OS asks a drive
    its sector size, most drives state that they have 512-byte sectors. Drives that
    claim to have both 512-byte and 4KB sectors are probably 4K drives, struggling
    to tell the truth. Very few admit to having solely 4KB sectors. To complicate
    matters even more, some solid state drives have sectors as large as 8KB or 16KB,
    or they support multiple sector sizes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，不同的4K驱动方式不同。如果操作系统询问驱动其扇区大小，大多数驱动会声明它们有512字节的扇区。那些宣称有512字节和4KB扇区的驱动可能是4K驱动，正在努力说出真相。很少有驱动承认只使用4KB扇区。更复杂的是，一些固态硬盘的扇区甚至达到8KB或16KB，或者它们支持多种扇区大小。
- en: Both of FreeBSD’s main filesystems must know the sector size of the underlying
    disk and the logical block address of that sector. If you use the wrong sector
    size on your disk, performance suffers. I could go into long detailed discussions
    of how this happens, but to keep it simple, always align partitions on even megabyte
    boundaries. You might waste a few bytes here and there, but that’s trivial compared
    to the truly appalling performance you’ll get from having a filesystem misaligned
    with the disk.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD的两个主要文件系统都必须知道底层磁盘的扇区大小以及该扇区的逻辑块地址。如果在磁盘上使用了错误的扇区大小，性能会受到影响。我可以详细讨论这种情况发生的原因，但为了简化，始终将分区对齐到偶数MB边界。这可能会浪费一些字节，但与磁盘和文件系统不对齐所带来的严重性能问题相比，这点浪费是微不足道的。
- en: '**Device Nodes**'
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**设备节点**'
- en: We touched briefly on device nodes in [Chapter 4](ch04.xhtml#ch04), but let’s
    consider them in more detail here. Device nodes are special files that represent
    a hardware device or an operating system feature. They’re used as logical interfaces
    to provide features to user programs. By using a command on a device node, sending
    information to a device node, or reading data from a device node, you’re telling
    the kernel to perform an action. If the device node represents a physical device,
    you’re acting on that device. These actions can be very different for different
    devices—writing data to disk is very different than writing data to a sound card.
    While you can expose device nodes anywhere, the standard device nodes exist in
    */dev*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](ch04.xhtml#ch04)中简要讨论过设备节点，但在这里我们将更详细地探讨它们。设备节点是表示硬件设备或操作系统功能的特殊文件。它们作为逻辑接口提供功能给用户程序。通过对设备节点使用命令、发送信息或读取数据，你实际上是在告诉内核执行某个动作。如果设备节点代表物理设备，那你正在对该设备进行操作。这些操作在不同设备间可能大不相同——写数据到磁盘与写数据到声卡是完全不同的操作。虽然你可以在任何地方暴露设备节点，但标准的设备节点存在于*/dev*目录中。
- en: Before you can work with a disk or disk partition, you must know its device
    name. FreeBSD disk device nodes come from the names of the device driver for that
    type of hardware. Device driver names, in turn, often come from the type of device
    and not the device’s role or function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以使用磁盘或磁盘分区之前，你必须知道它的设备名称。FreeBSD的磁盘设备节点来自该类型硬件的设备驱动程序名称。设备驱动程序名称反过来通常来源于设备的类型，而不是设备的角色或功能。
- en: Table 10-1 shows the most common disk device nodes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 表10-1展示了最常见的磁盘设备节点。
- en: '**Table 10-1:** Storage Device Nodes and Types'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**表10-1：** 存储设备节点和类型'
- en: '| **Device node** | **Man page** | **Description** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **设备节点** | **手册页** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| */dev/ada** | ada(4) | ATA-style direct access disks (SATA, IDE, etc.) |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| */dev/ada** | ada(4) | ATA风格直接访问磁盘（SATA, IDE等） |'
- en: '| */dev/cd** | cd(4) | Optical media drives (CD, Blu-Ray, etc.) |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| */dev/cd** | cd(4) | 光学媒体驱动（CD，Blu-Ray等） |'
- en: '| */dev/da** | da(4) | SCSI-style direct access disks (USB storage, SAS, etc.)
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| */dev/da** | da(4) | SCSI风格直接访问磁盘（USB存储、SAS等） |'
- en: '| */dev/md** | md(4) | Memory disks |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| */dev/md** | md(4) | 内存磁盘 |'
- en: '| */dev/mmcsd** | mmcsd(4) | MMC and SD memory cards |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| */dev/mmcsd** | mmcsd(4) | MMC和SD存储卡 |'
- en: '| */dev/nvd** | nvd(4) | NVM express drives |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| */dev/nvd** | nvd(4) | NVM express驱动 |'
- en: '| */dev/vtbd** | virtio_blk(4) | Virtio-based virtual machine disk |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| */dev/vtbd** | virtio_blk(4) | 基于Virtio的虚拟机磁盘 |'
- en: '| */dev/xbd** | xen(4) | Xen virtual disks |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| */dev/xbd** | xen(4) | Xen虚拟磁盘 |'
- en: Many RAID controllers present their RAID containers as SCSI devices, so they
    show up as */dev/da* device nodes. Others present their disks as “SCSI plus special
    vendor topping,” so they get special device node names such as */dev/raid* (ATA
    RAID), */dev/mfid* (certain LSI MegaRAID cards), and so on. Check the man page
    for your RAID controller to see the device node it presents.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 RAID 控制器将它们的 RAID 容器呈现为 SCSI 设备，因此它们显示为 */dev/da* 设备节点。其他一些则将它们的磁盘呈现为“带有特殊厂商标识的
    SCSI”，因此它们会有特别的设备节点名称，如 */dev/raid*（ATA RAID）、*/dev/mfid*（某些 LSI MegaRAID 卡）等。查看你
    RAID 控制器的 man 页面，了解它所呈现的设备节点。
- en: '**The Common Access Method**'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通用访问方法**'
- en: The *Common Access Method (CAM)* is a standardized device driver architecture
    originally written to support the complex command set of 20th-century SCSI-2 disks.
    The idea was that standardizing based on this architecture would simplify writing
    device drivers. Only FreeBSD and DEC OSF/1 actually shipped with CAM, however,
    and each filled in the specification’s gaps differently.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*通用访问方法（CAM）* 是一种标准化的设备驱动架构，最初是为了支持 20 世纪的 SCSI-2 磁盘的复杂命令集而编写的。其理念是，基于这种架构的标准化将简化设备驱动程序的编写。然而，实际上只有
    FreeBSD 和 DEC OSF/1 配备了 CAM，并且每个操作系统都以不同的方式填补了规范中的空白。'
- en: FreeBSD 9 and later consolidates management of all physical disks that support
    CAM in the CAM interface. Use camcontrol(8) to gather information from disks and
    issue commands to them. The camcontrol(8) command has a variety of subcommands
    that let you issue instructions to hard drives.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 9 及之后的版本将支持 CAM 的所有物理磁盘的管理整合到了 CAM 接口中。使用 camcontrol(8) 从磁盘收集信息并向其发出命令。camcontrol(8)
    命令有多种子命令，可以向硬盘发出指令。
- en: '***What Disks Do You Have?***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***你有什么磁盘？***'
- en: 'To identify a host’s storage devices, you can trawl */var/run/dmesg.boot* looking
    for disk device nodes or see which filesystems are mounted and backtrack from
    there. But the easiest way to identify your storage is to have camcontrol(8) ask
    the CAM system what disks it sees. Let’s look at one of my test systems:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别主机的存储设备，你可以扫描 */var/run/dmesg.boot* 查找磁盘设备节点，或者查看挂载的文件系统并从中倒推。但识别存储设备的最简单方法是让
    camcontrol(8) 查询 CAM 系统，看看它识别出了哪些磁盘。让我们看一下我的一台测试系统：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This output is broken up into three fields. The first gives the name of the
    device, as reported by the device itself. This is usually a vendor and the vendor’s
    model number.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出分为三个字段。第一个字段给出了设备的名称，由设备本身报告。通常是厂商和厂商的型号。
- en: The second section gives SCSI connection information. These drives aren’t actually
    SCSI drives—they’re SATA connections managed via CAM. But you now know which disk
    devices are plugged into which port on the SATA controller.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分给出了 SCSI 连接信息。这些驱动器实际上并不是 SCSI 驱动器——它们是通过 CAM 管理的 SATA 连接。但现在你知道哪些磁盘设备插入了
    SATA 控制器的哪个端口。
- en: Finally, in parentheses, we have the SCSI device and what we probably want,
    the storage device node. This host has four disks, named da0, da1, da2, and da3.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在括号中，我们有 SCSI 设备和我们可能需要的存储设备节点。这个主机有四个磁盘，分别命名为 da0、da1、da2 和 da3。
- en: '***Non-CAM Devices***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***非 CAM 设备***'
- en: Generally speaking, everything except proprietary RAID controllers and virtual
    disks support CAM.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，除了专有的 RAID 控制器和虚拟磁盘外，其他都支持 CAM。
- en: RAID controllers have usually embraced and extended the CAM protocol, for what
    the manufacturer thought was a good reason at the time. A protocol written in
    the early 1990s wasn’t sufficient for a 2010 RAID controller. These controllers
    usually have their own control programs. The RAID containers show up in `devlist`
    and some other camcontrol(8) subcommands.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: RAID 控制器通常已经拥抱并扩展了 CAM 协议，出于制造商当时认为合理的原因。一个在 1990 年代初期编写的协议对于 2010 年的 RAID 控制器来说已经不够用了。这些控制器通常有自己的控制程序。RAID
    容器会出现在 `devlist` 和其他 camcontrol(8) 子命令中。
- en: Similarly, virtual disks don’t respond to CAM commands. There’s no disk to command
    there—you’re just writing blocks to a file. You can view the disk with `camcontrol
    devlist`, but that’s about it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，虚拟磁盘不会响应 CAM 命令。那里没有磁盘可供操作——你只是在文件中写入数据块。你可以通过 `camcontrol devlist` 查看磁盘，但就仅此而已。
- en: For most applications, I recommend using FreeBSD’s RAIDZ or GEOM RAID, rather
    than a hardware RAID controller.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数应用，我推荐使用 FreeBSD 的 RAIDZ 或 GEOM RAID，而不是硬件 RAID 控制器。
- en: '**The GEOM Storage Architecture**'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**GEOM 存储架构**'
- en: FreeBSD has an incredibly flexible storage infrastructure system called *GEOM*
    (short for “disk geometry”). GEOM lives between device driver nodes and the underlying
    hardware, handling data exchanged between them. From this position, GEOM can arbitrarily
    transform input/output requests.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 拥有一个极其灵活的存储基础设施系统，称为 *GEOM*（即“磁盘几何”）。GEOM 位于设备驱动程序节点与底层硬件之间，处理它们之间交换的数据。从这个位置，GEOM
    可以任意转换输入/输出请求。
- en: '**DEVICE CONTROL PROGRAMS**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备控制程序**'
- en: Some storage devices have special features that aren’t addressed in the generic
    CAM framework. RAID controllers often have vendor-specific features, and FreeBSD
    includes many small programs to individually manage these controllers. You’ll
    find programs like mfiutil(8) and mptutil(8) for older LSI controllers, mpsutil(8)
    for newer LSI controllers, and so on. If you have a nonvolatile memory express
    (NVMe) drive, check out nvmecontrol(8).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一些存储设备具有特殊功能，这些功能在通用 CAM 框架中并未涵盖。RAID 控制器通常具有厂商特定的功能，FreeBSD 包含许多小程序来单独管理这些控制器。你会发现像
    mfiutil(8) 和 mptutil(8) 用于较旧的 LSI 控制器，mpsutil(8) 用于较新的 LSI 控制器，等等。如果你有非易失性存储器高速缓存（NVMe）驱动器，可以查看
    nvmecontrol(8)。
- en: GEOM is built out of kernel modules, called *GEOM classes*, that let you perform
    specific types of transformation or management. Disks have a GEOM class that lets
    the kernel put data on the disk. But if you want to encrypt your disks, that’s
    a GEOM class. Software-based RAID? A GEOM class. FreeBSD implements all storage
    modifications as GEOM classes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: GEOM 是由内核模块构建的，称为 *GEOM 类*，它们让你执行特定类型的转换或管理。磁盘有一个 GEOM 类，允许内核将数据写入磁盘。但如果你想加密你的磁盘，那也是一个
    GEOM 类。基于软件的 RAID？一个 GEOM 类。FreeBSD 将所有存储修改实现为 GEOM 类。
- en: GEOM classes are *stackable*. They use the output of one class as the input
    for another. You want to encrypt your hard drive and then mirror it to another
    hard drive? Sure! Stack an encryption module on top of your hard drive and then
    stack the drive-mirroring module on top of that. You want to mirror that drive
    across the network? Add that GEOM class to the stack. This flexible modularity
    makes GEOM one of FreeBSD’s most powerful features.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: GEOM 类是 *可堆叠* 的。它们使用一个类的输出作为另一个类的输入。如果你想加密硬盘，然后将其镜像到另一个硬盘？当然可以！在硬盘上堆叠一个加密模块，然后再堆叠一个驱动器镜像模块。你想将那个驱动器跨网络镜像？把那个
    GEOM 类加到堆栈中。这种灵活的模块化使得 GEOM 成为 FreeBSD 最强大的特性之一。
- en: '***GEOM Autoconfiguration***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***GEOM 自动配置***'
- en: When FreeBSD finds a new storage device, either at boot or when you plug a new
    drive in, the GEOM subsystem checks the device for known formats, like a master
    boot record, a BSD disklabel, or other metadata. GEOM also checks for physical
    identifiers, such as the disk’s serial number. This is called *tasting*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当 FreeBSD 发现新存储设备时，无论是在启动时还是插入新硬盘时，GEOM 子系统会检查该设备是否包含已知的格式，比如主引导记录、BSD 磁盘标签或其他元数据。GEOM
    还会检查物理标识符，如磁盘的序列号。这被称为 *品尝*。
- en: When GEOM finds identifying information, it configures the device as that metadata
    dictates. If a disk’s metadata says, “I’m part of a mirror called *garbage*, along
    with two other disks,” GEOM looks for the other disks and assembles the mirror.
    If GEOM can identify a storage device by format, label, or other information,
    it starts the device, fires up an instance of the GEOM class, makes the appropriate
    device nodes, and performs any other configuration it understands.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当 GEOM 发现标识信息时，它会根据该元数据的指示配置设备。如果磁盘的元数据说，“我是名为 *garbage* 的镜像的一部分，和另外两块磁盘一起，”GEOM
    会寻找其他磁盘并组装镜像。如果 GEOM 能通过格式、标签或其他信息识别存储设备，它会启动该设备，启动一个 GEOM 类实例，创建适当的设备节点，并执行任何它理解的其他配置。
- en: If GEOM can’t identify any other metadata on the disk, such as on an unformatted
    and unpartitioned disk, GEOM creates the device node for the storage device and
    leaves it alone.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 GEOM 无法识别磁盘上的其他元数据，例如在未格式化且未分区的磁盘上，GEOM 会为该存储设备创建设备节点并保持原样。
- en: An instance of a GEOM class is called a *geom*. The gmirror(8) class makes disks
    mirror each other, but the specific pair of mirrored disks named *garbage* is
    a geom. Each disk in that mirror is also a geom.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: GEOM 类的实例称为 *geom*。gmirror(8) 类让磁盘彼此镜像，但名为 *garbage* 的特定镜像磁盘对就是一个 geom。该镜像中的每个磁盘也是一个
    geom。
- en: '***GEOM vs. Volume Managers***'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***GEOM 与卷管理器***'
- en: Traditional volume managers expect you to do things their way, whether that
    makes sense for your environment and hardware or not. If the volume manager says
    that you create an encrypted disk mirror by encrypting the individual drives and
    then mirroring on top of them, that’s what you do. It might make more sense in
    your environment to mirror the drives and then encrypt them, but if that’s not
    what the volume manager does, too bad. Worse, some volume managers make poor choices
    and then implement fixes sideways to minimize the consequences of those decisions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的卷管理器期望你按它们的方式做事，无论这对你的环境和硬件是否合理。如果卷管理器说你通过加密单个驱动器并在其上进行镜像来创建加密的磁盘镜像，那么你就必须这么做。或许在你的环境中，先镜像驱动器然后加密它们更合适，但如果这不是卷管理器的做法，那也没办法。更糟糕的是，一些卷管理器做出糟糕的选择，然后通过旁路方式修复这些选择，以最小化这些决策的后果。
- en: GEOM differs from volume managers in that it assumes you know what you’re doing.
    It gives you flexibility to arrange your storage in the manner that best fits
    your hardware and benefits your use case. GEOM classes let you easily insert new
    data transformations into your storage. You can’t, say, add an encryption layer
    into your commercial volume manager.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: GEOM 与卷管理器的不同之处在于，它假设你知道自己在做什么。它给你灵活性，让你以最适合硬件并能为你的用例带来好处的方式安排存储。GEOM 类让你可以轻松地将新的数据转换功能插入到存储中。而你不能在商业卷管理器中加入加密层之类的功能。
- en: Volume managers cover the most common cases for hardware that existed at the
    time they were conceived. As time passes, though, that most common case becomes
    increasingly uncommon. People continue to use volume managers long after the hardware
    they were designed for becomes obsolete. GEOM lets you evolve your designs with
    your hardware, environment, and application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 卷管理器涵盖了它们设计时硬件中最常见的情况。然而，随着时间的推移，这些常见的情况变得越来越不常见。人们继续使用卷管理器，即使它们最初为已经过时的硬件设计。GEOM
    让你随着硬件、环境和应用程序的变化，演化你的设计。
- en: 'FreeBSD includes two software suites that look much like volume managers: gvinum(8)
    and ZFS. Vinum was the FreeBSD volume manager in the 1990s, and while gvinum(8)
    reimplements it as a GEOM class, its use is strongly discouraged. ZFS is very
    powerful, as we saw in [Chapter 5](ch05.xhtml#ch05), but it does have the “do
    it our way” ethos of a volume manager.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 包含了两个看起来很像卷管理器的软件套件：gvinum(8) 和 ZFS。Vinum 是 1990 年代的 FreeBSD 卷管理器，尽管
    gvinum(8) 重新实现了它作为 GEOM 类，但强烈不建议使用它。ZFS 非常强大，正如我们在[第 5 章](ch05.xhtml#ch05)中看到的，但它确实有卷管理器的“按我们的方式做事”的理念。
- en: While you can theoretically stack GEOM modules forever, you must consider your
    hardware resources. Mirroring a busy disk across a network can require a dedicated
    network interface and an otherwise empty cross-connect cable. Encrypting and decrypting
    data eats processor time and memory. GEOM doesn’t prevent you from thrashing your
    disks; it merely gives you new and interesting opportunities for doing so.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然理论上你可以永远堆叠 GEOM 模块，但你必须考虑硬件资源。通过网络镜像一个繁忙的磁盘可能需要专用的网络接口和空闲的交叉连接电缆。加密和解密数据会消耗处理器时间和内存。GEOM
    不会阻止你对磁盘进行过度操作；它只是为你提供了进行这些操作的新机会和有趣的可能性。
- en: '***Providers, Consumers, and Slicers***'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***提供者、消费者和分割器***'
- en: Individual geoms are either consumers, providers, or both.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 各个 geom 要么是消费者，要么是提供者，或者两者兼具。
- en: A *provider* offers services to another geom. If you’re mirroring two hard drives,
    the geoms for the hard drive provide the disk to the mirror. A provider usually
    has a device node, such as */dev/ada1p1*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *提供者* 为另一个 geom 提供服务。如果你正在镜像两个硬盘，硬盘的 geom 提供磁盘给镜像使用。一个提供者通常具有一个设备节点，比如 */dev/ada1p1*。
- en: A *consumer* uses the provider’s services. A disk-mirror geom consumes the underlying
    disk drives. The consumer part of a geom doesn’t need a device node.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *消费者* 使用提供者的服务。磁盘镜像 geom 消耗底层磁盘驱动器。一个 geom 的消费者部分不需要设备节点。
- en: A geom can be both a provider and a consumer—indeed, every geom in the middle
    of a stack must be both. A disk-mirror geom consumes the underlying physical storage
    media, but it provides a mirrored disk for the filesystem to live on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 geom 可以既是提供者又是消费者——实际上，堆栈中间的每个 geom 必须既是提供者又是消费者。磁盘镜像 geom 消耗底层的物理存储介质，但它为文件系统提供了一个镜像磁盘。
- en: FreeBSD treats all providers and consumers identically. A physical hard drive
    is just another provider, exactly like a mirror or encryption layer or import
    from the network. This characteristic lets you arbitrarily stack GEOM classes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 对待所有提供者和消费者的方式是相同的。一个物理硬盘只是另一个提供者，就像镜像、加密层或网络导入一样。这一特点使得你可以任意堆叠 GEOM
    类。
- en: A GEOM class that subdivides a class is called a *slicer* and is usually responsible
    for managing partitions. The GEOM class that handles master boot record (MBR)
    partitions is a slicer, as is the GUID Partition Table (GPT) class. We discussed
    both of these partitioning methods in [Chapter 2](ch02.xhtml#ch02), and we’ll
    go deeper into both in this chapter. Slicers must make sure that disk partitions
    don’t overlap and that the partitions conform to the rules of the partitioning
    scheme.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个将一个类细分为多个子类的 GEOM 类称为 *切片器*，通常负责管理分区。处理主引导记录（MBR）分区的 GEOM 类是一个切片器，GUID 分区表（GPT）类也是如此。我们在[第
    2 章](ch02.xhtml#ch02)中讨论了这两种分区方法，在本章中我们将进一步探讨这两种方法。切片器必须确保磁盘分区不重叠，并且分区符合分区方案的规则。
- en: '***GEOM Control Programs***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***GEOM 控制程序***'
- en: Many GEOM classes have a control program that lets you administer the module
    or interrogate the device. Some widely used classes use geom(8), while other classes
    use programs like gmirror(8) or geli(8). The *disk* GEOM class talks to the physical
    storage media and provides consumers for upper layers. That’s a really commonly
    used class. Here, I interrogate a host to see what geoms of type *disk* it has
    and print out the information the disk offers the operating system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 GEOM 类都有一个控制程序，让你管理模块或查询设备。一些广泛使用的类使用 geom(8)，而其他类使用如 gmirror(8) 或 geli(8)
    之类的程序。*disk* GEOM 类与物理存储介质进行通信，并为上层提供消费者。这是一个非常常用的类。在这里，我查询主机以查看它具有的 *disk* 类型的
    geoms，并打印出磁盘提供给操作系统的信息。
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This hard drive provides a disk device called da0 ➊. The *mediasize* field gives
    its size in bytes and converts it to a more convenient 932GB ➋.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 该硬盘提供一个名为 da0 ➊ 的磁盘设备。*mediasize* 字段提供其大小（以字节为单位），并将其转换为更便捷的 932GB ➋。
- en: This disk claims to have a *sector size* of 512 bytes ➌. Many disks lie about
    their sector size. Check the drive manufacturer’s documentation to determine the
    actual sector size. Drives might offer a *Stripesize* value of 4,096 to indicate
    that they’re actually 4K drives.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 该磁盘声称其 *扇区大小* 为 512 字节 ➌。许多磁盘会虚报其扇区大小。请查看硬盘制造商的文档，以确定实际的扇区大小。驱动器可能会提供 *Stripesize*
    值 4,096，表示它们实际上是 4K 驱动器。
- en: A GEOM class’s *mode* looks an awful lot like file permissions ➍, but it’s really
    the number of GEOM classes reading from (r2) and writing to (w2) the device, plus
    the number of devices that have requested exclusive access to the device (e3).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 GEOM 类的 *mode* 看起来非常像文件权限 ➍，但它实际上是读取（r2）和写入（w2）设备的 GEOM 类的数量，以及请求独占访问设备的设备的数量（e3）。
- en: The *descr* field ➎ offers the drive’s model number.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*descr* 字段 ➎ 提供驱动器的型号。'
- en: The *lunname* field ➏ gives the model number plus the serial number. Yes, it’s
    a combination of the descr and ident fields. The hard drive really, really wants
    you to believe this is its name and identifier.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*lunname* 字段 ➏ 提供型号和序列号。是的，它是 *descr* 和 *ident* 字段的组合。硬盘确实很希望你相信这就是它的名称和标识符。'
- en: The *lunid* ➐ gives the logical-unit-number (LUN) identifier, which describes
    how this drive attaches to this host.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*lunid* ➐ 提供逻辑单元号（LUN）标识符，描述此驱动器如何连接到此主机。'
- en: The disk’s *ident* ➑ is the drive’s serial number.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘的 *ident* ➑ 是驱动器的序列号。
- en: The *rotationrate* ➒ tells us how fast this drive spins. It’s a 7,200 RPM disk.
    Nonspinning disks, like SSDs, have a rotationrate of 0.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*rotationrate* ➒ 告诉我们该驱动器的旋转速度。它是一个 7,200 RPM 磁盘。非旋转磁盘，如 SSD，其 rotationrate
    为 0。'
- en: The *fwsectors* and *fwheads* fields ➓ give us the drive geometry. These are
    examples of the lies mentioned in the beginning of this chapter. Even SSDs offer
    these values.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*fwsectors* 和 *fwheads* 字段 ➓ 提供磁盘几何信息。这些是本章开头提到的谎言的例子。即使是 SSD 也会提供这些值。'
- en: Some drives offer less information. Virtual disks offer almost no information,
    and anything they do say, you can’t trust. (While the VM system might say this
    disk offers 32,212,254,720 512-byte sectors, who knows what the actual disk beneath
    the virtual disk has?)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一些驱动器提供较少的信息。虚拟磁盘几乎不提供任何信息，而且它们提供的任何信息都不可信。（尽管虚拟机系统可能会说该磁盘提供 32,212,254,720
    个 512 字节扇区，但谁知道虚拟磁盘下方的实际磁盘是什么样子呢？）
- en: '***GEOM Device Nodes and Stacks***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***GEOM 设备节点和堆栈***'
- en: Many sysadmin tools expect to run on a disk or disk partition. Unix-like systems
    offer disks and partitions as device nodes. GEOM offers device nodes so that these
    tools remain compatible.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 许多系统管理员工具期望在磁盘或磁盘分区上运行。类Unix系统提供磁盘和分区作为设备节点。GEOM 提供设备节点，以确保这些工具保持兼容性。
- en: Most active GEOM modules have their own directory in */dev*. Device nodes within
    that directory represent the current providers of that module. The directory is
    often, but not always, named after the GEOM module using it. For example, the
    gmirror(8) class uses */dev/mirror*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数活跃的GEOM模块在*/dev/*下都有自己的目录。该目录中的设备节点表示该模块当前的提供者。该目录通常（但不总是）以使用该模块的GEOM模块命名。例如，gmirror(8)类使用*/dev/mirror*。
- en: The directory name might be changed to avoid ambiguity or overlaps. The *glabel
    (GEOM label)* class uses */dev/label*. The */dev/gpt* directory contains the labels
    stored on GPT partitions, where */dev/gptid* contains the numerical identifiers
    integral to GPT partitions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 目录名称可能会更改，以避免歧义或重叠。*glabel（GEOM标签）*类使用*/dev/label*。*/dev/gpt*目录包含存储在GPT分区上的标签，而*/dev/gptid*目录包含与GPT分区相关的数字标识符。
- en: Some classes don’t create a directory and instead piggyback on existing devices.
    The gnop(8) class creates a new node right next to the node it’s attached to but
    appends *.nop* to the end of the device name.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类不会创建目录，而是附加到现有设备上。gnop(8)类会在附加的节点旁边创建一个新的节点，但会在设备名称末尾附加*.nop*。
- en: '**Hard Disks, Partitions, and Schemes**'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**硬盘、分区和方案**'
- en: While we discussed partitioning in [Chapter 9](ch09.xhtml#ch09), consider partitions
    from a disk drive perspective. The first possible SATA disk on our first SATA
    controller is called */dev/ada0*. Subsequent disks are */dev/ada1*, */dev/ada2*,
    and so on. If you also have SAS disks, they’ll start their numbering over at 0.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在[第9章](ch09.xhtml#ch09)中讨论了分区，但请从磁盘驱动器的角度考虑分区。我们第一个SATA控制器上的第一个可能的SATA磁盘叫做*/dev/ada0*。后续的磁盘分别是*/dev/ada1*、*/dev/ada2*，依此类推。如果你还拥有SAS磁盘，它们的编号将从0开始。
- en: Disks get further divided into *partitions*. Even average consumer-grade systems
    running Microsoft operating systems ship with multiple partitions on the hard
    drive. Sysadmins chop huge disk arrays into smaller, more manageable units with
    dedicated purposes—or perhaps they go the other way and merge multiple disks into
    one monster partition.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘被进一步划分为*分区*。即使是运行Microsoft操作系统的普通消费级系统，其硬盘上也通常会有多个分区。系统管理员将巨大的磁盘阵列划分为更小、更易于管理的单元，具有特定用途——或者他们也可能采取相反的做法，将多个磁盘合并为一个庞大的分区。
- en: A *partitioning scheme* is the system for organizing partitions on a disk. The
    traditional master boot record (MBR) is one partitioning scheme. Old Apple and
    SPARC hardware have their own schemes. Today, the scheme used by most hardware
    and operating systems is *GUID Partition Tables (GPT)*. Each scheme has its own
    requirements for boot blocks, hardware architecture, and partitions. This book
    discusses the MBR and GPT schemes, but you should be aware that other schemes
    exist.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*分区方案*是用于组织磁盘分区的系统。传统的主引导记录（MBR）是一种分区方案。旧的苹果和SPARC硬件有它们自己的分区方案。今天，大多数硬件和操作系统使用的方案是*GUID分区表（GPT）*。每种方案都有其对引导块、硬件架构和分区的要求。本书讨论了MBR和GPT方案，但你应该意识到其他方案也存在。'
- en: 'Each disk partition gets its own device node, created by adding something to
    the end of the underlying device node name. Here, I look at the device node for
    a default FreeBSD install using UFS on a virtual disk:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每个磁盘分区都会获得自己的设备节点，这些设备节点是通过在底层设备节点名称末尾添加内容来创建的。在这里，我查看了一个默认的FreeBSD安装，使用UFS格式在虚拟磁盘上进行的设备节点：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have a device node for the disk itself and then three others ending in p1,
    p2, and p3\. What are those subdivisions? The *p* indicates that they’re GPT partitions.
    In a default install, p1 is the boot partition, p2 is the swap space, and p3 is
    the main filesystem.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个磁盘本身的设备节点，然后还有三个其他设备节点，分别以p1、p2和p3结尾。那些子分区是什么？*p*表示它们是GPT分区。在默认安装中，p1是引导分区，p2是交换空间，p3是主文件系统。
- en: Each partitioning scheme has its own device node extensions. We’ll read about
    those later this chapter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分区方案都有自己独特的设备节点扩展。我们将在本章后面阅读到这些内容。
- en: '**The Filesystem Table: /etc/fstab**'
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**文件系统表：/etc/fstab**'
- en: FreeBSD, like most Unix-like operating systems, uses the file system table */etc/fstab*
    to map on-disk partitions to filesystems and swap space. While ZFS doesn’t use
    */etc/fstab*, every other FreeBSD filesystem can appear therein. Each partition
    in use appears on a separate line, along with mounting and management instructions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD像大多数类Unix操作系统一样，使用文件系统表*/etc/fstab*将磁盘上的分区映射到文件系统和交换空间。虽然ZFS不使用*/etc/fstab*，但其他所有FreeBSD文件系统都可以出现在其中。每个使用中的分区都会出现在单独的一行上，并附有挂载和管理指令。
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The first field gives the GEOM provider name. This might be a physical disk
    partition such as */dev/ada0p1* or perhaps a partition of a GEOM device node.
    The first two lines here offer device nodes under */dev/gpt*. They’re GPT labels,
    which we’ll see later this chapter. Our third entry lists the word *proc* rather
    than a device node: it’s the procfs(5) virtual filesystem, which we’ll examine
    in [Chapter 13](ch13.xhtml#ch13).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字段给出了 GEOM 提供者的名称。这可能是一个物理磁盘分区，例如 */dev/ada0p1*，或者可能是一个 GEOM 设备节点的分区。这里的前两行提供了
    */dev/gpt* 下的设备节点。这是 GPT 标签，我们将在本章稍后看到。我们的第三项列出了 *proc*，而不是设备节点：它是 procfs(5) 虚拟文件系统，我们将在
    [第13章](ch13.xhtml#ch13) 中详细讨论。
- en: The second field gives the directory where the filesystem is available, called
    the *mount point*. Every partition you can read or write files on is attached
    to a mount point, such as */usr*, */var*, and so on. A few special partitions,
    such as swap space (line 2 here), have a mount point of none. You can’t read or
    write usable files to the swap space because they’re not attached to the directory
    tree and because the system would overwrite those files when it swapped.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个字段给出了文件系统可用的目录，称为 *挂载点*。每个可以读写文件的分区都会附加到一个挂载点，例如 */usr*、*/var* 等等。一些特殊的分区，例如
    swap 空间（这里是第二行），其挂载点为 none。因为它们没有连接到目录树，且系统在交换时会覆盖这些文件，所以你不能在 swap 空间上读写文件。
- en: Next, we have the filesystem type. The first line shows a type of *ufs*, or
    Unix File System. The second line is defined as *swap* space, while the third
    is type *procfs*. Other types include *cd9660* (CD disks or images), *nfs* (Network
    File System mounts), and *ext4fs* (Linux filesystems). The filesystem table tells
    FreeBSD how to mount this partition. [Chapter 13](ch13.xhtml#ch13) discusses alternate
    filesystems.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看文件系统类型。第一行显示的是 *ufs* 类型，或者说是 Unix 文件系统。第二行定义为 *swap* 空间，而第三行是 *procfs*
    类型。其他类型包括 *cd9660*（CD 光盘或映像）、*nfs*（网络文件系统挂载）和 *ext4fs*（Linux 文件系统）。文件系统表告诉 FreeBSD
    如何挂载这个分区。[第13章](ch13.xhtml#ch13)讨论了其他文件系统。
- en: 'The fourth field shows the mount(8) options used for this particular partition.
    Each filesystem has its own mount options, but here are a few that multiple filesystems
    use and that frequently appear in */etc/fstab*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个字段显示了用于此特定分区的 mount(8) 选项。每个文件系统都有其自己的挂载选项，但这里列出了一些多个文件系统都使用且经常出现在 */etc/fstab*
    中的选项：
- en: '**ro** The filesystem is mounted read-only. Not even root can write to it.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**ro** 文件系统以只读方式挂载。连 root 用户也不能对其进行写操作。'
- en: '**rw** The filesystem is mounted read-write.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**rw** 文件系统以读写方式挂载。'
- en: '**noauto** FreeBSD won’t automatically mount the filesystem, neither at boot
    nor when using `mount -a`. This option is useful for removable media drives that
    might not have media in them at boot.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**noauto** FreeBSD 不会自动挂载文件系统，无论是在启动时还是在使用 `mount -a` 时。这个选项对于可能在启动时没有介质的可移动媒体驱动器非常有用。'
- en: The fifth field is used to tell dump(8) what backup level is needed to back
    up this filesystem. Dump is largely obsolete these days; people perform file-level
    backup with tar(1) or use more advanced backup software, like Bacula (*[http://www.bacula.org/](http://www.bacula.org/)*)
    or Tarsnap (*[https://www.tarsnap.com/](https://www.tarsnap.com/)*).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第五个字段用于告诉 dump(8) 需要哪个备份级别来备份这个文件系统。现在，dump 已经基本过时；人们使用 tar(1) 进行文件级备份，或者使用更先进的备份软件，如
    Bacula (*[http://www.bacula.org/](http://www.bacula.org/)*) 或 Tarsnap (*[https://www.tarsnap.com/](https://www.tarsnap.com/)*）。
- en: The last field tells the FreeBSD boot process when to check filesystem integrity.
    All the partitions with the same number get checked in parallel with fsck(8).
    The root filesystem gets marked with a 1, meaning it’s checked first. Only the
    root filesystem should get a 1\. Any other partitions should get a 2 or higher,
    meaning they get checked later. Swap, read-only media, and logical filesystems
    don’t require integrity checking, so they get set to 0.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个字段告诉 FreeBSD 启动过程在何时检查文件系统的完整性。所有具有相同编号的分区会与 fsck(8) 一起并行检查。根文件系统标记为 1，意味着它是第一个被检查的。只有根文件系统应该标记为
    1，任何其他分区应该标记为 2 或更高，意味着它们稍后会被检查。交换分区、只读介质和逻辑文件系统不需要完整性检查，因此它们会设置为 0。
- en: FreeBSD configures all filesystems found in */etc/fstab* at boot. As the system
    runs, though, the sysadmin can mount other filesystems. And she can unmount ones
    listed there. That leads to our next question . . .
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 在启动时配置所有在 */etc/fstab* 中找到的文件系统。然而，随着系统运行，系统管理员可以挂载其他文件系统，并且她也可以卸载那些列在其中的文件系统。这就引出了我们的下一个问题……
- en: '**What’s Mounted Now?**'
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**现在挂载的是什么？**'
- en: If not all filesystems are mounted automatically at boot, and if the sysadmin
    can add and remove mounted filesystems, how can you determine what’s mounted right
    now? Use mount(8) without any options to see all mounted filesystems.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是所有的文件系统在启动时都被自动挂载，并且如果系统管理员可以添加和移除挂载的文件系统，如何确定当前已挂载的文件系统呢？使用mount(8)命令，不带任何选项，可以查看所有挂载的文件系统。
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a small UFS-based host. It has one disk partition and an instance of
    devfs(5) (see [Chapter 13](ch13.xhtml#ch13)). The word *local* means that the
    partition is on a hard drive attached to this machine. The journaled soft-updates
    option is a UFS feature we’ll discuss in [Chapter 11](ch11.xhtml#ch11). If you’re
    using NFS or SMB to mount partitions, they’ll appear here.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小型的基于UFS的主机。它只有一个磁盘分区和一个devfs(5)实例（参见[第13章](ch13.xhtml#ch13)）。*local*一词意味着该分区位于连接到此计算机的硬盘上。日志化软更新选项是UFS的一个特性，我们将在[第11章](ch11.xhtml#ch11)中讨论。如果你正在使用NFS或SMB来挂载分区，它们会出现在这里。
- en: 'More complicated hosts give larger results:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的主机会产生更大的结果：
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This host uses many ZFS datasets, each with its own mount point. The mount(8)
    output shows selected ZFS options, such as noatime and nfsv4acls.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 该主机使用多个ZFS数据集，每个数据集都有自己的挂载点。mount(8)命令的输出显示了选定的ZFS选项，例如noatime和nfsv4acls。
- en: At the end of this output, we have a procfs(5) entry and one for a devfs(5)
    mount. A working FreeBSD system needs devfs mounted at */dev* or it won’t work
    very well or for very long.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出的最后，我们有一个procfs(5)条目和一个devfs(5)挂载条目。一个正常工作的FreeBSD系统需要在*/dev*挂载devfs，否则它的运行将不太顺利，或者根本无法长时间工作。
- en: '**Disk Labeling**'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**磁盘标签**'
- en: At the lowest level, operating systems identify disks by their physical attachment
    to the system. Traditionally, the filesystem table says something like, “Use the
    disk attached at ATA port 3 as the */var/log* filesystem.” This worked fine with
    less flexible hardware, but as hardware technology improved, such connections
    became much more flexible. If you assign drive roles based on the physical attachment,
    sometimes that attachment changes. I’ve had more than one mainboard explode at
    an inconvenient hour, forcing a desperate emergency replacement. Tracking which
    cable goes to which connecter under such circumstances never goes well. In older
    versions of FreeBSD, you needed to “wire down” devices so that a specific disk
    always showed up as a specific device node. This is no longer needed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在最低层次上，操作系统通过硬件与系统的物理连接来识别磁盘。传统上，文件系统表可能会写道：“将连接在ATA端口3的磁盘用作*/var/log*文件系统。”在硬件灵活性较差时，这种方法工作得很好，但随着硬件技术的发展，这种连接变得更加灵活。如果你根据物理连接来分配磁盘角色，有时这种连接会发生变化。我曾经有过多次主板在不合时宜的时刻爆炸，迫使我进行紧急替换。在这种情况下，追踪哪个电缆连接到哪个接口通常都会失败。在旧版本的FreeBSD中，你需要“固定”设备，使得特定的磁盘总是作为特定的设备节点出现。现在不再需要这样做。
- en: Today, a sysadmin uses on-disk *labels* to refer to the disk by something other
    than the physical attachment. A label identifies an instance of a geom. Rather
    than telling FreeBSD that */var/www* is on the disk attached to SATA port 2, you
    declare that */var/www* is on the disk labeled *website*. While the former easily
    goes wrong, the latter is mostly immune to sleepy hardware techs. One disk can
    have several labels simultaneously, if they’re different types of label. FreeBSD
    automatically derives many labels from inherent disk characteristics; the sysadmin
    can define others.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，系统管理员使用磁盘上的*标签*来通过其他方式引用磁盘，而不是依赖于物理连接。标签标识了一个geom实例。与其告诉FreeBSD*/var/www*在连接到SATA端口2的磁盘上，不如声明*/var/www*在标签为*website*的磁盘上。前者容易出错，而后者则大多能避免因为硬件技术人员的疏忽。一个磁盘可以同时有多个标签，只要它们是不同类型的标签。FreeBSD会自动根据磁盘的固有特征推导出许多标签；系统管理员也可以定义其他标签。
- en: Most label types have a dedicated device node directory. Each GPT partition
    has a *globally unique identifier (GUID)*, and the autocreated labels for those
    partitions live in */dev/gptid*. Disks get unique disk IDs based on their serial
    number, which gets entries in */dev/diskid*. Manually created GPT labels appear
    in */dev/gpt*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数标签类型都有一个专门的设备节点目录。每个GPT分区都有一个*全局唯一标识符(GUID)*，这些分区的自动创建标签存储在*/dev/gptid*中。磁盘根据其序列号获得唯一的磁盘ID，这些ID会出现在*/dev/diskid*中。手动创建的GPT标签出现在*/dev/gpt*中。
- en: Use these labels as you would any other device name. If you label the disk ada5
    as *stuff1*, you can partition the disk stuff into *stuff1p1* and *stuff1p2*,
    use those partitions in configuration files, and more.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 像使用其他设备名称一样使用这些标签。如果你将磁盘ada5标记为*stuff1*，你可以将磁盘stuff分区为*stuff1p1*和*stuff1p2*，并在配置文件中使用这些分区，等等。
- en: Not all labels come from GEOM. ZFS uses its own internal labeling method for
    filesystems and pools. You can also add labels to UFS filesystems.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有标签都来自GEOM。ZFS使用自己内部的标签方法来标识文件系统和池。你还可以向UFS文件系统添加标签。
- en: Don’t let swapped SATA cables ruin your weekend. Label everything.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让交换的SATA电缆毁了你的周末。给所有东西加上标签。
- en: '***Viewing Labels***'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查看标签***'
- en: View labels with glabel(8), a shortcut for `geom label`. Here are parts of a
    label from a small virtual machine. The labels on real hardware can quickly become
    very complex.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用glabel(8)，即`geom label`的快捷方式来查看标签。以下是来自一个小型虚拟机的标签部分。实际硬件上的标签可能会变得非常复杂。
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This host has a single geom ➊ on the disk partition */dev/ada0p1*. It provides
    an appallingly long label based on the GPT partition ID ➋. We’ll see a bunch of
    information on the underlying disk, such as the number of sectors on the disk,
    the sector size, and other information you might see in `geom` `disk list` output.
    This information comes from the partition, however. The physical drive information
    is passed up from the underlying disk.^([1](footnote.xhtml#ch10fn1))
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主机在磁盘分区*/dev/ada0p1*上有一个单一的GEOM ➊。它提供了一个基于GPT分区ID ➋的非常长的标签。我们将在底层磁盘上看到一些信息，例如磁盘上的扇区数量、扇区大小以及你可能在`geom`
    `disk list`输出中看到的其他信息。然而，这些信息来自于分区。物理驱动器信息是从底层磁盘传递上来的。^([1](footnote.xhtml#ch10fn1))
- en: This drive has a single consumer ➌, the actual underlying partition. We’re at
    the very bottom of this simple GEOM stack, right up against the disk, so it’s
    consuming itself. If you add cryptographic layers or software RAID, you’ll see
    what other device this geom consumes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个驱动器有一个单一的消费者 ➌，即实际的底层分区。我们处于这个简单GEOM堆栈的最底层，紧贴磁盘，因此它正在自我消费。如果你添加了加密层或软件RAID，你将看到该GEOM消费的其他设备。
- en: '***Sample Labels***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***示例标签***'
- en: Here are some examples of the kinds of labels you’ll see on most FreeBSD systems.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你在大多数FreeBSD系统上看到的标签类型的示例。
- en: '**Disk ID Labels**'
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**磁盘ID标签**'
- en: A physical machine offers labels not available on virtual machines.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 物理机器提供虚拟机无法获得的标签。
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The drive ada3 provides a geom called *diskid/DISK-WD-WCAW36477141*. The *diskid*
    geom is named after the hard drive’s serial number, based on information provided
    by the drive. You can remove the disk from this machine and attach it to a completely
    different FreeBSD host, and that new host will generate the exact same disk ID
    label. Using the diskid label in your configurations guarantees that FreeBSD will
    use the exact disk you intend. Here’s how you might list partition 3 on this disk
    in */etc/fstab*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动器ada3提供了一个名为*diskid/DISK-WD-WCAW36477141*的GEOM。*diskid* GEOM以硬盘的序列号命名，基于硬盘提供的信息。你可以将磁盘从这台机器上取下，并将其连接到完全不同的FreeBSD主机上，新的主机将生成完全相同的磁盘ID标签。在配置中使用diskid标签可以确保FreeBSD使用你打算使用的确切磁盘。以下是在*/etc/fstab*中列出该磁盘分区3的方式：
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This disk could attach to the host as */dev/ada3* or */dev/ada300*, and FreeBSD
    would still mount this partition as */usr/local*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个磁盘可以作为*/dev/ada3*或*/dev/ada300*连接到主机，FreeBSD仍然会将该分区挂载为*/usr/local*。
- en: The problem with disk ID labels is that they’re painful to read and more painful
    to type. I’m describing them because they can appear by default, but I’d encourage
    you to choose a different label. Eliminate these labels from your host by setting
    the tunable `kern.geom.label.disk_ident.enable` to 0 in */boot/loader.conf*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘ID标签的问题在于它们难以阅读，也更难输入。我之所以提到它们，是因为它们可能是默认出现的，但我鼓励你选择其他标签。通过在*/boot/loader.conf*中将可调项`kern.geom.label.disk_ident.enable`设置为0，来从你的主机中移除这些标签。
- en: '**GPT GUID Labels**'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**GPT GUID 标签**'
- en: 'Every GPT partition includes a GUID. FreeBSD can treat the GUID as a label.
    Here, we see a GPT ID label for partition 1 on the disk attached as ada0:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每个GPT分区都包括一个GUID。FreeBSD可以将GUID视为标签。在这里，我们看到了附加为ada0的磁盘上分区1的GPT ID标签：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This disk partition is conveniently available as */dev/gptid/075e7b89-30ed-11e7-a386-002590dbd594*
    ➊. Much like disk serial numbers, GUIDs are integral to the partition. You can
    move the disk to another host and still get the same GPT ID. By using the GPT
    ID label in configurations like */etc/fstab*, you guarantee that FreeBSD uses
    this particular partition, rather than partition 1, on whatever device happens
    to get assigned ada0 at system boot.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个磁盘分区可以方便地表示为*/dev/gptid/075e7b89-30ed-11e7-a386-002590dbd594* ➊。类似于磁盘序列号，GUID是分区的一部分。你可以将磁盘移动到另一台主机，仍然能够获得相同的GPT
    ID。通过在像*/etc/fstab*这样的配置文件中使用GPT ID标签，可以确保FreeBSD在系统启动时使用这个特定的分区，而不是分区1，无论哪个设备被分配到ada0。
- en: Using a GPT ID label makes sense when you have many automatically configured
    disks, such as large storage arrays. On smaller systems, though, the 128-bit GUID
    is annoyingly long. If you decide not to use these labels, remove them from your
    system by setting the tunable `kern.geom.label.gptid.enable` to 0 in */boot/loader.conf*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GPT ID 标签在你有多个自动配置磁盘时很有意义，例如大型存储阵列。然而，在较小的系统中，128 位的 GUID 过长，令人烦恼。如果你决定不使用这些标签，可以通过将可调参数
    `kern.geom.label.gptid.enable` 设置为 0，在 */boot/loader.conf* 中将它们从系统中移除。
- en: For most hosts, I recommend assigning GPT labels.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数主机，我建议分配 GPT 标签。
- en: '**GPT Labels**'
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**GPT 标签**'
- en: 'GPT partitions let you manually assign a label name within the partition table.
    I highly recommend doing so whenever possible. Here’s a partition that I assigned
    a name:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: GPT 分区允许你在分区表内手动分配标签名称。我强烈建议在可能的情况下这么做。这里是我分配了名称的一个分区：
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'I’ve assigned the label *swap2* ➊ to partition 1 on disk ada2\. This label
    is physically stored on the disk partition. I can use this label in my configurations
    just like any other device name. Using manually assigned labels is much more manageable
    for small systems, as this */etc/fstab* shows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为磁盘 ada2 上的分区 1 分配了标签 *swap2* ➊。这个标签物理存储在磁盘分区上。我可以像使用其他设备名称一样在配置中使用这个标签。对于小型系统来说，使用手动分配的标签更加可管理，如这个
    */etc/fstab* 所示：
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: An assigned label is much more human-friendly than a long serial number or GUID.
    If you have the choice, I encourage you to label GPT partitions. We’ll assign
    labels when we partition disks.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个分配的标签比长串的序列号或 GUID 更加人性化。如果可以选择，我建议你为 GPT 分区分配标签。我们在分区时会分配标签。
- en: '**GEOM Labels**'
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**GEOM 标签**'
- en: 'In addition to spilling the standard labels on your system, the glabel(8) command
    lets you configure GEOM labels. A GEOM label is specific to FreeBSD’s GEOM infrastructure
    and appears in */dev/label*. Use GEOM labels with the `glabel label` command.
    Here, I apply the GEOM label *root* to the GPT partition da0p1:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在系统上显示标准标签外，glabel(8) 命令还允许你配置 GEOM 标签。GEOM 标签是特定于 FreeBSD GEOM 基础架构的，并出现在
    */dev/label* 中。使用 `glabel label` 命令来管理 GEOM 标签。这里，我将 GEOM 标签 *root* 应用到 GPT 分区
    da0p1 上：
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There’s also a `glabel create` command, but those labels disappear at system
    reboot.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 `glabel create` 命令，但这些标签在系统重启时会消失。
- en: '**GEOM Withering**'
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**GEOM 枯萎**'
- en: A provider can have multiple labels. One partition might have a label based
    on the disk ID of the underlying storage device (*/dev/diskid/somethinglong*),
    a GPT ID (*/dev/gptid/somethingevenlonger*), a manually assigned label (*/dev/gpt/swap0*),
    and a device node based on the underlying device’s attachment point (*/dev/ada0p1*).
    While any number of processes can look at a disk device simultaneously, many disk
    operations—such as mounting a partition—require exclusive, dedicated control of
    the device.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一个提供者可以有多个标签。一个分区可能有基于底层存储设备的磁盘 ID（*/dev/diskid/somethinglong*）、GPT ID（*/dev/gptid/somethingevenlonger*）、手动分配的标签（*/dev/gpt/swap0*）以及基于底层设备附件点的设备节点（*/dev/ada0p1*）。虽然多个进程可以同时查看磁盘设备，但许多磁盘操作——例如挂载分区——需要独占的设备控制。
- en: To prevent accessing geoms by multiple names, when you access a device by one
    label, the kernel removes the unused labels. This is called *withering*. If I,
    say, mount a swap partition using the GPT label */dev/gpt/swap0*, all the other
    labels for that partition disappear from */dev*. Anyone who tries to access the
    corresponding */dev/gptid* partition will find that the device node is missing.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止通过多个名称访问 geoms，当你通过一个标签访问设备时，内核会移除未使用的标签。这被称为 *枯萎*。例如，如果我通过 GPT 标签 */dev/gpt/swap0*
    挂载一个交换分区，那么该分区的所有其他标签都会从 */dev* 中消失。任何尝试访问相应 */dev/gptid* 分区的人会发现该设备节点丢失。
- en: Once all exclusive locks on a device are removed, the kernel de-withers the
    other device labels. If I deactivate that swap space, the GPT ID and raw device
    name reappear.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设备上的所有独占锁定被移除，内核会恢复其他设备标签的显示。如果我停用了交换空间，GPT ID 和原始设备名称会重新出现。
- en: '**The gpart(8) Command**'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**gpart(8) 命令**'
- en: Like many operating systems, FreeBSD once had specific partitioning tools for
    each partitioning scheme. Today, all disk partitioning functions, for MBR and
    GPT alike, are included in the gpart(8) program. Embedded devices with specialized
    storage might occasionally need older tools like fdisk(8) and bsdlabel(8), but
    gpart(8) works perfectly well for servers and desktops.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多操作系统一样，FreeBSD 曾经为每种分区方案提供专门的分区工具。今天，所有的磁盘分区功能，无论是 MBR 还是 GPT，都包括在 gpart(8)
    程序中。对于嵌入式设备，可能偶尔需要像 fdisk(8) 和 bsdlabel(8) 这样的旧工具，但 gpart(8) 对服务器和桌面系统完全适用。
- en: This common tool means you perform many functions the same way no matter which
    partitioning scheme you’re using. For example, no matter whether you’re working
    with the MBR or GPT scheme, you’ll need a way to indicate a particular partition.
    Both schemes let you indicate a partition with `-i` and the partition number.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个常用工具意味着无论你使用的是哪种分区方案，都能以相同的方式执行许多操作。例如，无论你使用 MBR 还是 GPT 方案，都需要一种方法来指示特定的分区。两种方案都允许你通过
    `-i` 和分区号来指示一个分区。
- en: Viewing and deleting partitions are great examples of common functions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 查看和删除分区是常见功能的很好示例。
- en: '***Viewing Partitions***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查看分区***'
- en: 'Use `gpart show` to see a brief summary of all GPT and MBR partitions on a
    geom. Give the name of a geom as an argument to see only the partitions on that
    geom. The output from `gpart show` doesn’t look that different from fdisk(8) and
    other more traditional disk management tools. Here, I look at a storage device
    by its traditional device node, but I could use diskid or gptid or any other label:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `gpart show` 可以查看 geom 上所有 GPT 和 MBR 分区的简要概览。通过提供 geom 的名称作为参数，可以仅查看该 geom
    上的分区。`gpart show` 的输出与 fdisk(8) 和其他传统磁盘管理工具的输出没有太大区别。在这里，我通过传统的设备节点查看存储设备，但我也可以使用
    diskid、gptid 或任何其他标签：
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The first column gives the first block in the partition; the second, the partition
    size in blocks. The third gives the partition number, while the fourth gives the
    partition type. (We’ll discuss partition types later this chapter: for the moment,
    just go with the flow.) At the end, we have the disk size.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列给出了分区的第一个块；第二列是分区的大小（以块为单位）。第三列是分区号，第四列是分区类型。（我们将在本章后面讨论分区类型：目前，先按流程进行。）最后，我们给出了磁盘大小。
- en: Our first partition begins on the disk’s sector number 40 and fills almost two
    billion sectors ➊. The third field shows that this isn’t a partition on the disk,
    but rather an entry for the entire disk. The fourth field gives the partitioning
    scheme used. This is a GPT disk. The entire disk is about 932GB.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个分区从磁盘的第 40 个扇区开始，填充了将近 20 亿个扇区 ➊。第三个字段显示这不是磁盘上的一个分区，而是整个磁盘的条目。第四个字段给出了使用的分区方案。这是一个
    GPT 磁盘。整个磁盘大约为 932GB。
- en: The second entry also starts on sector 40, and it fills 1,024 sectors ➋. This
    is partition 1, and it’s of type *freebsd-boot*. If we want to boot off this disk,
    we need a boot loader on this partition.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个条目也从第 40 扇区开始，填充了 1,024 个扇区 ➋。这是分区 1，类型是 *freebsd-boot*。如果我们想从这个磁盘启动，则需要在此分区上安装引导加载程序。
- en: The third entry begins on sector 1,064 and fills 984 sectors ➌. Why 1,064? The
    first partition started on sector 40 and filled 1,024 sectors, so the first (1,024
    + 40) 1,064 sectors are filled with other partitions. But this partition doesn’t
    have a partition number, and its type is `- free -`. This partition is aligned
    for disks with 4K sectors.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个条目从第 1,064 扇区开始，填充了 984 个扇区 ➌。为什么是 1,064？第一个分区从第 40 扇区开始，填充了 1,024 个扇区，因此前
    (1,024 + 40) 1,064 个扇区已被其他分区占用。但这个分区没有分区号，其类型是 `- free -`。这个分区为 4K 扇区的磁盘进行了对齐。
- en: The fourth entry is swap space, according to the partition type ➍. It begins
    on sector 2,048, is 4,194,304 sectors long, and is partition 2\. You’ll often
    see swap space near the beginning of a disk, a hangover from the days when partition
    placement on the disk impacted performance. If you’re using a virtual machine,
    however, putting the swap near the beginning of the disk leaves you room to expand
    a partition at the end of the disk.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个条目是交换空间，根据分区类型 ➍。它从第 2,048 扇区开始，长度为 4,194,304 个扇区，是分区 2。你通常会看到交换空间位于磁盘的前面，这是过去分区放置对性能有影响的遗留物。然而，如果你使用的是虚拟机，将交换空间放在磁盘的前面可以为你在磁盘末尾扩展分区留下空间。
- en: The fifth entry is a FreeBSD ZFS filesystem, starting in sector 4,196,352 and
    going on for about 1.9 billion sectors ➎. This freebsd-zfs partition has our data.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第五个条目是 FreeBSD ZFS 文件系统，从第 4,196,352 扇区开始，占用大约 19 亿个扇区 ➎。这个 freebsd-zfs 分区包含我们的数据。
- en: The very end of the disk has 1,416 free sectors ➏. There’s not quite enough
    space to add space to the partition while still aligning the partition to the
    1MB boundaries.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘的最后部分有 1,416 个空闲扇区 ➏。空间不足以在对齐到 1MB 边界的同时增加分区的空间。
- en: A MBR disk looks much like a GPT disk.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: MBR 磁盘看起来与 GPT 磁盘非常相似。
- en: '***Other Views***'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***其他视图***'
- en: Add command line flags to modify the output of `gpart show`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 添加命令行标志来修改 `gpart show` 的输出。
- en: You can assemble each partition’s device node from the underlying device name
    and the partition number. If you want to see the device node rather than the partition
    number, add the `-p` flag.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过底层设备名称和分区编号来组装每个分区的设备节点。如果你想看到设备节点而不是分区编号，可以添加`-p`标志。
- en: To replace the partition type with the partition label, use `-l`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要用分区标签替代分区类型，请使用`-l`。
- en: 'Here, I show both the device node and the labels on this disk:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我展示了这个磁盘的设备节点和标签：
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The partition number now contains complete device names, like *ada0p3*. Rather
    than the GPT partition type, you get the label applied to the GPT partition, such
    as *swap0* and *zfs0*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，分区编号包含完整的设备名称，比如*ada0p3*。你不再看到GPT分区类型，而是看到应用于GPT分区的标签，例如*swap0*和*zfs0*。
- en: To see the human-hostile GPT partition type rather than the name FreeBSD presents,
    use `-r`. I mostly use this when examining disks from other operating systems.
    It’s possible that FreeBSD will label multiple partition types as being type *ntfs*;
    while that’s good enough for most uses, if I’m doing digital forensics, the precise
    partitioning scheme might be extremely important.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看人类不友好的GPT分区类型，而不是FreeBSD显示的名称，请使用`-r`。我通常在检查其他操作系统的磁盘时使用它。FreeBSD可能会将多个分区类型标记为*ntfs*；虽然这对大多数用途来说足够，但如果我在做数字取证，精确的分区方案可能非常重要。
- en: To see a more detailed description of your GPT partitions, use `gpart list`.
    This creates output much like `glabel list` or other GEOM class commands.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看GPT分区的更详细描述，请使用`gpart list`。这会产生类似于`glabel list`或其他GEOM类命令的输出。
- en: '***Removing Partitions***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***删除分区***'
- en: Maybe you screw up when creating your partitions and need to remove one. No,
    you haven’t created partitions yet, in either MBR or GPT, but the process you
    follow is the same either way. Delete partitions by number.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你在创建分区时出错，需要删除其中一个。不是的，你还没有在MBR或GPT中创建分区，但你遵循的过程无论哪种方式都是一样的。通过编号删除分区。
- en: Take a look at the partition table in the previous section. We have partitions
    for boot, swap, and ZFS. Maybe you don’t want swap space on your boot drive. Remove
    that partition with the gpart delete command. Use the `-i` flag and the number
    of the partition you want to remove. The gpart show command said the swap space
    was partition 2\. Let’s remove it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 查看上一节中的分区表。我们有用于启动、交换和ZFS的分区。也许你不希望在启动磁盘上有交换空间。使用gpart delete命令删除该分区。使用`-i`标志和你想删除的分区编号。gpart
    show命令显示交换空间是分区2。让我们删除它。
- en: '[PRE15]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can now resize your ZFS partition to use that space. How you resize a partition
    varies with the partitioning scheme.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以调整ZFS分区的大小以使用这些空间。调整分区大小的方式取决于分区方案。
- en: '**Scheming Disks**'
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**设计磁盘**'
- en: No, not the sort of scheming where the disk deliberately lies to you. We’re
    talking about the disk’s partitioning scheme. Destruction is easier than creation,
    in both meatspace and with storage. Before you can partition a disk, you need
    to assign it a partitioning scheme.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这不是那种故意欺骗你的磁盘。我们谈论的是磁盘的分区方案。在现实世界和存储中，摧毁比创建更容易。在你能够分区磁盘之前，你需要为它分配一个分区方案。
- en: '***Removing the Disk Partitioning Scheme***'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***删除磁盘分区方案***'
- en: You could go through and painstakingly delete every partition on the disk and
    then obliterate the partitioning scheme. That’s a bunch of work, though. It’s
    much simpler to just trash the entire disk partition table.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以逐个删除磁盘上的每个分区，然后摧毁分区方案。然而，这样做工作量很大。更简单的方法是直接丢弃整个磁盘分区表。
- en: You can’t erase a disk with mounted partitions. Unmount those partitions first,
    and remove them from any ZFS pools. Once the disk is truly unused, erase any existing
    partitioning table with `gpart destroy`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能擦除带有已挂载分区的磁盘。首先卸载这些分区，并从任何ZFS池中删除它们。一旦磁盘真正未使用，使用`gpart destroy`擦除任何现有的分区表。
- en: '[PRE16]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the command returns immediately, the disk had no partitions. It might have
    had a partition scheme, but no partitions. If you get a “device busy” error, either
    the disk is still in use or the disk has partitions. You could methodically delete
    all existing partitions with `gpart delete` and then destroy the partitioning
    scheme, but it’s easier to burn the existing scheme to the ground by adding `-F`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令立即返回，说明磁盘没有分区。它可能有一个分区方案，但没有分区。如果你遇到“设备繁忙”错误，要么磁盘仍在使用中，要么磁盘有分区。你可以通过`gpart
    delete`逐个删除所有现有分区，然后销毁分区方案，但通过添加`-F`更容易彻底删除现有方案。
- en: '[PRE17]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This forcibly erases all partitions and the partitioning scheme. Running `gpart
    show da3` will show that there’s no partition table. You can now create new disk
    partitions.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这会强制擦除所有分区和分区方案。运行 `gpart show da3` 将显示没有分区表。现在可以创建新的磁盘分区。
- en: '***Assigning the Partitioning Scheme***'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分配分区方案***'
- en: 'Before you can create disk partitions, you need to mark the disk with the type
    of partitioning scheme you’ll be using. Use `gpart create` with the `-s` flag
    and the scheme, such as `gpt` or `mbr`. Here, I mark a disk as using the GPT scheme:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建磁盘分区之前，您需要标记磁盘所使用的分区方案类型。使用 `gpart create` 命令并加上 `-s` 标志和方案类型，如 `gpt` 或 `mbr`。在这里，我将磁盘标记为使用
    GPT 方案：
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Use `gpart show` to verify that the disk now has a GPT partition table. You
    can now add GPT partitions or recreate the partition table with MBR and add those
    partitions. But we’ll start by diving deep into GPT.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `gpart show` 验证磁盘现在是否有 GPT 分区表。现在可以添加 GPT 分区，或重新创建分区表并使用 MBR 添加这些分区。但我们将从深入了解
    GPT 开始。
- en: '**The GPT Partitioning Scheme**'
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**GPT 分区方案**'
- en: The GUID Partition Table, or GPT, is the modern standard for hard drive partitioning.
    This is the recommended standard for new installations. Always use the GPT partitioning
    scheme unless you have a deeply compelling reason not to, such as a lack of hardware
    support.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: GUID 分区表（GPT）是现代硬盘分区的标准。这是新安装的推荐标准。除非有非常强烈的理由不使用，比如硬件不支持，否则总是使用 GPT 分区方案。
- en: GPT supports disks up to 9.4ZB. One zettabyte is one billion terabytes. While
    our technology will eventually outgrow 9.4ZB, I expect GPT will last the rest
    of my career.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: GPT 支持最大 9.4ZB 的磁盘。1 ZB 等于 10 亿 TB。尽管我们的技术最终会超越 9.4ZB，但我预计 GPT 将持续到我职业生涯的最后。
- en: FreeBSD’s GPT implementation currently supports 128 partitions. Each partition
    gets assigned a GUID, which is a 128-bit number displayed as 32 hexadecimal characters.
    While GUIDs aren’t guaranteed to be truly unique across all of civilization, they’re
    certainly going to be unique within your organization.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 的 GPT 实现目前支持 128 个分区。每个分区都会分配一个 GUID，它是一个 128 位的数字，以 32 个十六进制字符显示。虽然
    GUID 并不保证在整个文明范围内真正唯一，但它们在你的组织内肯定是唯一的。
- en: Most modern operating systems support GPT and its predecessor, the master boot
    record (MBR). MBR-based systems put partition records in the first sector on the
    disk. If a host supports only MBR, but the first sector of a disk contains something
    that isn’t an MBR, the system gets confused and might refuse to boot. The GPT
    scheme puts a *protective master boot record (PMBR)* in the first sector of every
    disk. The PMBR indicates that the disk contains one MBR partition of type GPT.
    The second sector contains the actual GUID Partition Table. GPT also puts a backup
    copy of the partition table on the last sector of the disk so you can more easily
    recover from damage.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代操作系统支持 GPT 及其前身——主引导记录（MBR）。基于 MBR 的系统将分区记录存储在硬盘的第一个扇区。如果主机仅支持 MBR，但磁盘的第一个扇区包含不是
    MBR 的内容，系统会感到困惑，可能会拒绝启动。GPT 方案将 *保护性主引导记录（PMBR）* 放置在每个磁盘的第一个扇区。PMBR 表示磁盘包含一个类型为
    GPT 的 MBR 分区。第二个扇区包含实际的 GUID 分区表。GPT 还在磁盘的最后一个扇区放置了分区表的备份副本，以便更轻松地恢复损坏的数据。
- en: GPT requires allocating a partition for bootstrap code. The PMBR boot code searches
    the disk for a FreeBSD boot partition. This boot partition must be larger than
    the boot code, smaller than 545KB, and reserved for the FreeBSD boot loader. FreeBSD
    has two GPT boot loaders, gptboot(8) and gptzfsboot(8). You must install one of
    these on the boot partition.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: GPT 需要为引导代码分配一个分区。PMBR 启动代码会搜索磁盘上的 FreeBSD 启动分区。这个启动分区必须大于引导代码，小于 545KB，并且保留给
    FreeBSD 启动加载程序。FreeBSD 有两个 GPT 启动加载程序，gptboot(8) 和 gptzfsboot(8)。必须在启动分区上安装其中一个。
- en: Use gptboot(8) to start UFS-based systems. At system boot, gptboot searches
    for a FreeBSD partition marked with the *bootme* or *bootonce* attributes.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 gptboot(8) 启动基于 UFS 的系统。在系统启动时，gptboot 会搜索标记为 *bootme* 或 *bootonce* 属性的 FreeBSD
    分区。
- en: Use gptzfsboot(8) on systems running ZFS.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 ZFS 的系统上使用 gptzfsboot(8)。
- en: Use gpart(8) and its many subcommands to view, create, edit, and destroy GPT
    partitions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 gpart(8) 及其众多子命令来查看、创建、编辑和销毁 GPT 分区。
- en: '***GPT Device Nodes***'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***GPT 设备节点***'
- en: Each disk partition has a device node. GPT partition device nodes are an extension
    of the geom they’re built on, indicated by the letter *p* and the partition number.
    If you’ve created GPT partitions directly on the disk ada0, the first partition
    will be */dev/ada0p1*, the second */dev/ada0p2*, and so on.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每个磁盘分区都有一个设备节点。GPT 分区的设备节点是它们所在 geom 的扩展，由字母 *p* 和分区编号表示。如果你直接在磁盘 ada0 上创建 GPT
    分区，第一个分区将是 */dev/ada0p1*，第二个是 */dev/ada0p2*，依此类推。
- en: Many systems put their partitions on an upper-layer geom. One of my systems
    uses SATA RAID and offers the disk as */dev/raid/r0*. The partitions on this drive
    are */dev/raid/r0p1*, */dev/raid/r0p2*, and so on. You might also put partitions
    on a device by its GUID or disk ID, giving you partitions like */dev/diskid/DISK-WD-WCAW36477062p1*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 许多系统将它们的分区放在上层的 geom 上。我有一个系统使用 SATA RAID，并将磁盘呈现为 */dev/raid/r0*。这个磁盘上的分区分别是
    */dev/raid/r0p1*、*/dev/raid/r0p2* 等等。你也可能通过 GUID 或磁盘 ID 将分区放到一个设备上，从而获得像 */dev/diskid/DISK-WD-WCAW36477062p1*
    这样的分区。
- en: '***GPT Partition Types***'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***GPT 分区类型***'
- en: When you create a GPT partition, you must mark it with a *partition type*. The
    type indicates the partition’s intended use. FreeBSD makes decisions based on
    the partition types, so assign them correctly.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建 GPT 分区时，必须为其标记一个 *分区类型*。该类型表示分区的预定用途。FreeBSD 会根据分区类型做出决策，因此要正确分配它们。
- en: Strictly speaking, a partition type is another 128-bit GUID. FreeBSD marks GUIDs
    used as partition types with a leading exclamation point, such as `!516e7cb5-6ecf-11d6-8ff8-00022d09712b`.
    These partition types are common across all operating system, but most OSs provide
    human-friendly names for these human-hostile GUIDs. This book uses the human-friendly
    names; check gpart(8) for the human-hostile ones.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，分区类型是另一个 128 位的 GUID。FreeBSD 使用感叹号标记作为分区类型的 GUID，例如 `!516e7cb5-6ecf-11d6-8ff8-00022d09712b`。这些分区类型在所有操作系统中都很常见，但大多数操作系统会为这些不适合人类阅读的
    GUID 提供易于理解的名称。本书使用的是易于理解的名称；如需查看不适合人类的名称，请查阅 gpart(8)。
- en: 'The most common partition types you’ll see on a FreeBSD system include the
    following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 FreeBSD 系统中最常见的分区类型包括以下几种：
- en: '**freebsd-boot** FreeBSD boot loader'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**freebsd-boot** FreeBSD 引导加载程序'
- en: '**freebsd-ufs** FreeBSD UFS filesystem'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**freebsd-ufs** FreeBSD UFS 文件系统'
- en: '**freebsd-zfs** FreeBSD ZFS filesystem'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**freebsd-zfs** FreeBSD ZFS 文件系统'
- en: '**freebsd-swap** FreeBSD swap partition'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**freebsd-swap** FreeBSD 交换分区'
- en: '**efi** An EFI system partition, used to boot from EFI'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**efi** EFI 系统分区，用于从 EFI 启动'
- en: You might also see these GPT partition types. Don’t use them in modern FreeBSD,
    but know that their presence might help you identify just what that weird disk
    is and how to crack it open.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会看到这些 GPT 分区类型。在现代 FreeBSD 中不要使用它们，但知道它们的存在可能有助于你识别出这个奇怪的磁盘是什么，以及如何将其拆解。
- en: '**freebsd** A GPT partition that’s divided into bsdlabel(8) partitions'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**freebsd** 一个被分为 bsdlabel(8) 分区的 GPT 分区'
- en: '**freebsd-vinum** A partition controlled by gvinum(8)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**freebsd-vinum** 一个由 gvinum(8) 控制的分区'
- en: '**mbr** A partition subdivided into MBR partitions'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**mbr** 一个被细分为 MBR 分区的分区'
- en: '**ntfs** A partition containing a Microsoft NTFS filesystem'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**ntfs** 一个包含微软 NTFS 文件系统的分区'
- en: '**fat16, fat32** Partitions containing FAT'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**fat16, fat32** 包含 FAT 文件系统的分区'
- en: For a complete listing of recognized partition types, see gpart(8).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的已识别分区类型列表，请参见 gpart(8)。
- en: '***Creating GPT Partitions***'
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建 GPT 分区***'
- en: 'Partitioning disks is easy: figure out which partitions you want, create them,
    and go. The tricky part is living with your partitioning. Before creating partitions,
    decide what you’re going to do with this disk. How much space do you have? How
    do you want to divide it? Before you start creating partitions, write down exactly
    what you want to achieve.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 分区磁盘很简单：弄清楚你需要哪些分区，创建它们，然后就可以了。棘手的部分是如何使用你的分区。在创建分区之前，决定你将如何使用这个磁盘。你有多少空间？你希望如何划分？在开始创建分区之前，准确写下你想要实现的目标。
- en: 'Here, I’m manually partitioning a 1TB disk for a UFS FreeBSD install. It’ll
    need a 512KB boot partition (type *freebsd-boot*) and 8GB for swap (type *freebsd-swap*).
    The other partitions will be type *freebsd-ufs*: 5GB for root, 5GB for */tmp*,
    100GB for */var*, and the rest for */usr*. I’ll label each partition for its intended
    role.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我正在为 UFS FreeBSD 安装手动分区一个 1TB 的磁盘。它将需要一个 512KB 的引导分区（类型 *freebsd-boot*）和
    8GB 的交换分区（类型 *freebsd-swap*）。其他分区将是 *freebsd-ufs* 类型：5GB 用于根分区，5GB 用于 */tmp*，100GB
    用于 */var*，其余的用于 */usr*。我会为每个分区标明其预定的角色。
- en: Create partitions with gpart(8). Use the `-t` flag to specify the partition
    type, `-s` to give the size, and `-l` to assign a GPT label to the new partition.
    I’ll start with the boot partition.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用gpart(8)创建分区。使用`-t`标志指定分区类型，`-s`指定大小，`-l`为新分区分配GPT标签。我将从boot分区开始。
- en: '[PRE19]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Use `gpart show` to check your work. Add the `-l` flag to see the GPT label.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gpart show`检查您的工作。加上`-l`标志查看GPT标签。
- en: '[PRE20]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This disk has one partition, a 512K partition labeled *boot*. The command succeeded.
    Now add the swap space.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个磁盘有一个分区，大小为512K，标记为*boot*。命令执行成功。现在添加交换空间。
- en: '[PRE21]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This command is much like the one to add the boot partition: we give the partition
    type, size, and label.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令与添加boot分区的命令非常相似：我们指定分区类型、大小和标签。
- en: Hang on, though—what’s this `-a 1m` thing? The `-a` flag lets you set a partition
    alignment, enabling you to set where partitions can begin and end relative to
    the beginning of the disk. Remember back at the beginning of this chapter when
    I discussed that misaligning a filesystem with the physical sectors on a 4K disk
    could cause problems? The `-a 1m` tells gpart to create partition on an even multiple
    of 1MB from the beginning of the disk. You’ll have some empty space between partitions
    1 and 2, as we saw in “[Viewing Partitions](ch10.xhtml#lev343)” on [page 215](ch10.xhtml#page_215)
    in this chapter, but that’s okay. That gives you room to change that partition
    to support UEFI if necessary (see “[Unified Extensible Firmware Interface and
    GPT](ch10.xhtml#lev356)” on [page 222](ch10.xhtml#page_222) later this chapter).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下——这`-a 1m`是什么？`-a`标志允许您设置分区对齐方式，使您可以设置分区相对于磁盘起始位置的开始和结束位置。还记得在本章开始时我提到过，如果文件系统与4K磁盘的物理扇区不对齐可能会导致问题吗？`-a
    1m`告诉gpart从磁盘的开始位置按1MB的偶数倍创建分区。正如我们在本章的[第215页](ch10.xhtml#page_215)中“[查看分区](ch10.xhtml#lev343)”部分看到的那样，分区1和分区2之间会有一些空白空间，但这没问题。这给您留出了空间，必要时可以更改该分区以支持UEFI（请参阅本章后面部分的“[统一可扩展固件接口和GPT](ch10.xhtml#lev356)”）。
- en: Retain that 1MB alignment as you create the 5GB root and */tmp* partitions and
    the 100GB */var* partition.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建5GB的根分区、*/tmp*分区和100GB的*/var*分区时，保持1MB对齐。
- en: '[PRE22]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When you create the last partition, don’t give a size. This tells gpart to make
    the partition as large as possible.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 创建最后一个分区时，不要指定大小。这告诉gpart将该分区做得尽可能大。
- en: '[PRE23]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You have partitioned the disk, and it’s ready for your install.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您已分区，并且它已准备好进行安装。
- en: '***Resizing GPT Partitions***'
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***调整GPT分区大小***'
- en: On second thought, perhaps having a huge */usr* partition isn’t wise. A */usr*
    partition of 100GB or so would have all the room you might desire for operating
    system files, while leaving several hundred gigabytes for an isolated */home*
    partition. I trust most of my users, but a few^([2](footnote.xhtml#ch10fn2)) are
    just the sort to dump */dev/random* into a file until they absorb all available
    space. Here, I’ll resize */usr* to create space for */home*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 再想一想，也许创建一个巨大的*/usr*分区并不明智。一个大约100GB的*/usr*分区足以为操作系统文件提供足够的空间，同时为隔离的*/home*分区留出几百GB的空间。我信任大多数用户，但有些用户([2](footnote.xhtml#ch10fn2))可能会把*/dev/random*扔进文件，直到占满所有可用空间。在这里，我将调整*/usr*的大小，为*/home*创建空间。
- en: Use `gpart resize` to change the size of a partition. You must know the target
    partition’s partition number. Running `gpart show da3` tells us that */usr* is
    partition 6\. Use the `-i` flag and the partition number to resize a partition.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gpart resize`来更改分区的大小。您必须知道目标分区的分区编号。运行`gpart show da3`会告诉我们*/usr*是分区6。使用`-i`标志和分区编号来调整分区大小。
- en: '[PRE24]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Run `gpart show` to see the new disk size.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`gpart show`以查看新的磁盘大小。
- en: '[PRE25]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This disk has 714GB free at the end. We can now create a spacious */home* for
    all our troublesome users.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个磁盘在末尾有714GB的空闲空间。现在我们可以为所有麻烦的用户创建一个宽敞的*/home*分区。
- en: Each partition is assigned specific sectors on the disk. You can’t increase
    the size of a partition if there’s no free space on either side of the partition.
    While this sample disk has a bunch of free space after partition 6, you can’t
    use it to increase the size of partitions 1 through 5\. You must delete and recreate
    partitions.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分区都会分配特定的扇区。若分区两侧没有空闲空间，您无法增加分区的大小。尽管此示例磁盘在分区6之后有大量空闲空间，但您无法利用这些空间来增大分区1到分区5的大小。您必须删除并重新创建这些分区。
- en: Changing the size of a partition doesn’t change the size of the filesystem on
    that partition. Shrinking a partition with a filesystem will chop off part of
    the filesystem. Increasing the partition size won’t expand the filesystem. Both
    UFS and ZFS have tools to handle increased partition sizes, but you must handle
    that as a separate process.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 更改分区的大小不会更改该分区上文件系统的大小。缩小带有文件系统的分区会切断部分文件系统。增大分区大小不会扩展文件系统。UFS 和 ZFS 都有处理增大分区大小的工具，但你必须将此作为一个独立的过程来处理。
- en: '***Changing Labels and Types***'
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***更改标签和类型***'
- en: 'You can modify a GPT partition’s type or GPT label with the `gpart modify`
    command. Give the partition number with `-i`. Use `-l` to give the new label.
    Here, I change the GPT label on partition 2 of disk vtbd0:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `gpart modify` 命令修改 GPT 分区的类型或 GPT 标签。使用 `-i` 给出分区号，使用 `-l` 给出新的标签。在这里，我修改了磁盘
    vtbd0 的分区 2 的 GPT 标签：
- en: '[PRE26]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Similarly, change the type of partition with `-t`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，使用 `-t` 更改分区的类型：
- en: '[PRE27]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The disk’s GPT table now declares that partition 2 is labeled `rootfs` and is
    of type *freebsd-zfs*.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘的 GPT 表现在声明分区 2 的标签为 `rootfs`，并且类型为 *freebsd-zfs*。
- en: '***Booting on Legacy Hardware***'
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在传统硬件上启动***'
- en: Older hardware expects to see a master boot record at the start of the disk
    and won’t recognize a GPT partition table. FreeBSD uses a protective MBR (PMBR)
    to give legacy hardware a recognizable partition table and help that hardware
    boot a GPT-partitioned disk. A bootable disk formatted with GPT needs both a protective
    MBR and a GPT boot loader.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 较旧的硬件期望在磁盘的开始处看到一个主引导记录（MBR），并且不会识别 GPT 分区表。FreeBSD 使用保护性 MBR（PMBR）为传统硬件提供一个可识别的分区表，并帮助该硬件启动
    GPT 分区的磁盘。一个格式化为 GPT 的可启动磁盘需要同时拥有保护性 MBR 和 GPT 引导加载程序。
- en: Install a PMBR with the `gpart bootcode` command and the `-b` flag. FreeBSD
    provides a PMBR as */boot/pmbr*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `gpart bootcode` 命令和 `-b` 标志安装一个 PMBR。FreeBSD 提供了一个 PMBR，路径为 */boot/pmbr*。
- en: '[PRE28]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This disk will no longer confuse hosts that look for an MBR.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个磁盘将不再干扰那些寻找 MBR 的主机。
- en: You also need a boot loader. UFS hosts need the *gptboot* boot loader, while
    ZFS hosts need *gptzfsboot*. For convenience, FreeBSD provides a copy of each
    in the */boot* directory. These copies are not the on-disk boot loader, only the
    version of the bootloaders needed for that version of FreeBSD. Install the selected
    boot loader with the `-p` flag to `gpart bootcode`. Use the `-i` option to tell
    gpart(8) which partition to copy the boot loader to. The sample disk we used in
    the last section had partition 1 as type *freebsd-boot*, so we’ll use that.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一个引导加载程序。UFS 主机需要 *gptboot* 引导加载程序，而 ZFS 主机需要 *gptzfsboot*。为了方便，FreeBSD
    在 */boot* 目录中提供了每个引导加载程序的副本。这些副本不是磁盘上的引导加载程序，而是该版本 FreeBSD 所需的引导加载程序版本。使用 `-p`
    标志将选定的引导加载程序安装到 `gpart bootcode`。使用 `-i` 选项告诉 gpart(8) 要将引导加载程序复制到哪个分区。我们在上一节使用的示例磁盘中，分区
    1 的类型是 *freebsd-boot*，所以我们将使用该分区。
- en: '[PRE29]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can combine `-p` and `-b` into a single command.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `-p` 和 `-b` 合并为一个命令。
- en: '***Unified Extensible Firmware Interface and GPT***'
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***统一可扩展固件接口和 GPT***'
- en: The *Unified Extensible Firmware Interface (UEFI)* is a newer standard for booting
    amd64 hardware without using BIOS emulation. FreeBSD 10 and later have early support
    for UEFI booting to UFS, while FreeBSD 11 can boot ZFS off of UEFI.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*统一可扩展固件接口 (UEFI)* 是一种较新的标准，用于在不使用 BIOS 仿真的情况下启动 amd64 硬件。FreeBSD 10 及之后的版本支持早期的
    UEFI 启动到 UFS，而 FreeBSD 11 能够从 UEFI 启动 ZFS。'
- en: UEFI uses a partition of type *efi*, which must be 800KB or larger. Create an
    efi partition on a new disk with `gpart create`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI 使用类型为 *efi* 的分区，该分区必须为 800KB 或更大。使用 `gpart create` 在新磁盘上创建一个 efi 分区。
- en: '[PRE30]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: FreeBSD provides an efi partition as */boot/boot1.efifat*. Copy that to the
    new boot partition with dd(1).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 提供了一个 efi 分区，路径为 */boot/boot1.efifat*。使用 dd(1) 将其复制到新的引导分区。
- en: '[PRE31]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Partition the rest of the disk as you desire.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要分区剩余的磁盘空间。
- en: An efi partition is actually a FAT filesystem with a very specific directory
    hierarchy. Feel free to mount the file *boot1.efifat* and explore it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 efi 分区实际上是一个 FAT 文件系统，具有非常特定的目录层次结构。你可以挂载文件 *boot1.efifat* 并进行探索。
- en: '***Expanding GPT Disks***'
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***扩展 GPT 磁盘***'
- en: We’ve seen how to expand a partition, but what about a disk? Expanding disks
    often happens with virtual hosts. Expand a virtual disk, and gpart(8) will complain
    that the disk’s GPT is invalid. GPT and GEOM store information in the first and
    last sectors of the disk. Expanding a virtual disk means adding sectors. The new
    last sector will be empty. Create a new metadata block for the last sector with
    `gpart recover`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何扩展分区，但磁盘呢？扩展磁盘通常发生在虚拟主机上。扩展虚拟磁盘时，`gpart(8)`会抱怨磁盘的GPT无效。GPT和GEOM在磁盘的第一个和最后一个扇区存储信息。扩展虚拟磁盘意味着添加扇区。新的最后一个扇区将是空的。使用`gpart
    recover`为最后一个扇区创建新的元数据块。
- en: '[PRE32]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can now create or expand partitions on the expanded virtual disk.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以在扩展后的虚拟磁盘上创建或扩展分区。
- en: Now that you have a handle on GPT partitions, let’s look at MBR and see why
    GPT seemed like such an improvement.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经掌握了GPT分区，我们来看看MBR，看看为什么GPT似乎是一个如此重大的改进。
- en: '**The MBR Partitioning Scheme**'
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**MBR分区方案**'
- en: Old hardware, or new but small hardware, might need master boot record partitioning
    on its disks. Intel-style hardware has used MBR partitions for decades, and millions
    of devices running a plethora of operating systems use it. The MBR scheme works
    only on disks of 2TB or smaller. Larger disks must use GPT partitioning.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 旧硬件或新但小型的硬件可能需要在其磁盘上使用主引导记录分区。Intel风格的硬件已经使用MBR分区数十年，数百万个设备运行着各种操作系统都在使用它。MBR方案仅适用于2TB或更小的磁盘。更大的磁盘必须使用GPT分区。
- en: '***What Is the Master Boot Record?***'
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***什么是主引导记录（MBR）？***'
- en: The *master boot record (MBR)* is a file that takes up the first 512 bytes of
    a traditional disk, also known as *Sector 0*. The MBR contains partition information
    and a boot loader to allow the BIOS to find the operating system. The term *MBR*
    might refer to the actual first sector on the disk or the partition scheme used
    by that format.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*主引导记录（MBR）*是一个文件，占据传统磁盘的前512字节，也称为*扇区0*。MBR包含分区信息和一个引导加载程序，允许BIOS找到操作系统。术语*MBR*可能指代磁盘上的实际第一个扇区或该格式使用的分区方案。'
- en: A master boot record describes four *primary partitions*, called *slices* in
    the BSD community. Each slice description includes the disk sectors included in
    the partition and the type of filesystem expected on that slice. If a disk has
    only one slice on it, the MBR still lists four slices, but three of those slices
    have no sectors assigned to them. While the MBR format supports a linked list
    of up to 20 extended partitions, FreeBSD doesn’t need them thanks to BSD labels.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 主引导记录描述了四个*主分区*，在BSD社区中称为*切片*。每个切片描述包括该分区包含的磁盘扇区和预计在该切片上使用的文件系统类型。如果一个磁盘上只有一个切片，MBR仍然列出四个切片，但其中三个切片没有分配任何扇区。虽然MBR格式支持最多20个扩展分区的链表，但由于BSD标签的存在，FreeBSD不需要这些扩展分区。
- en: One of the four primary slices is considered active. When the system powers
    on, the bootstrap code looks for the active slice and tries to boot it.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 四个主切片中的一个被认为是活动的。当系统开机时，引导程序代码会查找活动切片并尝试引导它。
- en: The MBR sector also contains bootstrap code. You don’t need to allocate space
    specifically for a boot loader. In FreeBSD, the bootstrap code finds and executes
    the kernel. FreeBSD includes two different boot loaders, *mbr* and *boot0*. The
    mbr loader is for a host with a single operating system. If you have multiple
    operating systems installed on your hardware, use the boot0 loader—or, better
    still, dedicate your host to FreeBSD and virtualize the other operating systems.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: MBR扇区还包含引导程序代码。你不需要专门为引导加载程序分配空间。在FreeBSD中，引导程序代码会查找并执行内核。FreeBSD包括两个不同的引导加载程序，*mbr*和*boot0*。mbr加载程序用于单操作系统主机。如果你在硬件上安装了多个操作系统，使用boot0加载程序——或者，最好是将主机专用于FreeBSD，并将其他操作系统虚拟化。
- en: The main function of a slice is to contain a bsdlabel(8) partition.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 切片的主要功能是包含一个bsdlabel(8)分区。
- en: '***BSD Labels***'
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***BSD标签***'
- en: BSD existed before either the MBR or the IBM PC. BSD used its own disk partition
    format, called a *disklabel*. Now that labeling disks is much more common, disklabels
    are also called *BSD labels* or *bsdlabels*. (If you want to start a spirited
    discussion, ask a room of FreeBSD developers which is more correct.) BSD systems
    had several partitions including at least */* (root), */usr*, */var*, */tmp*,
    and swap space, plus separate partitions for whatever actual work the system did.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: BSD 出现的时间早于 MBR 或 IBM PC。BSD 使用自己独特的磁盘分区格式，称为 *disklabel*。现在磁盘标签变得更加常见，disklabel
    也被称为 *BSD labels* 或 *bsdlabels*。（如果你想激起一场激烈的讨论，可以问一群 FreeBSD 开发者，哪种叫法更正确。）BSD
    系统有多个分区，至少包括 */*（根目录），*/usr*，*/var*，*/tmp* 和交换空间，还有独立的分区用于系统执行的实际工作。
- en: When BSD was ported to the i386 platform, they could have switched disks to
    using MBR partitions. With extended MBR partitions, one disk could have had up
    to 24 partitions. Disklabel partitions were embedded throughout the kernel, however,
    often in icky places that nobody dared touch. The porting group decided to treat
    an MBR slice as a BSD disk and to partition each slice with a BSD disklabel. Sysadmins
    needed to create MBR partitions and then nest disklabel partitions inside those
    MBR partitions.^([3](footnote.xhtml#ch10fn3))
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当 BSD 移植到 i386 平台时，它们本可以将磁盘改为使用 MBR 分区。通过扩展 MBR 分区，一个磁盘最多可以拥有 24 个分区。然而，disklabel
    分区深嵌在内核中，通常位于没人敢碰的棘手地方。移植小组决定将 MBR 切片视为 BSD 磁盘，并使用 BSD disklabel 对每个切片进行分区。系统管理员需要创建
    MBR 分区，然后将 disklabel 分区嵌套在这些 MBR 分区内。^([3](footnote.xhtml#ch10fn3))
- en: This worked but also made the word *partition* ambiguous. Does *partition* mean
    an MBR partition or a disklabel partition? FreeBSD dusted off the word *slices*
    for MBR partitions. Each MBR slice will have its own disklabel, listing the BSD
    partitions contained within the slice. If you come from a Linux or Microsoft Windows
    background, the MBR partitions you’re familiar with are called *slices* over here.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式有效，但也使得 *partition* 这个词变得模糊。*partition* 是指 MBR 分区还是 disklabel 分区呢？FreeBSD
    重新使用了 *slices* 这个词来表示 MBR 分区。每个 MBR 切片都会有自己的 disklabel，列出包含在切片中的 BSD 分区。如果你来自
    Linux 或 Microsoft Windows 背景，你所熟悉的 MBR 分区在这里被称为 *slices*。
- en: You can’t label slices or disklabel partitions. These formats have no space
    for labels. Instead, label the ZFS or UFS filesystem on the partition.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能为切片或 disklabel 分区添加标签。这些格式没有空间容纳标签。相反，应为分区上的 ZFS 或 UFS 文件系统添加标签。
- en: It’s possible to skip slicing a disk, instead installing a disklabel directly
    on the hard drive. Some hardware refused to boot from such disks, so they’re called
    *dangerously dedicated*. With the advent of GPT, dangerously dedicated disks aren’t
    really used any more.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以跳过切片，直接在硬盘上安装 disklabel。有些硬件拒绝从这样的磁盘启动，因此它们被称为 *dangerously dedicated*（危险专用）。随着
    GPT 的出现，危险专用磁盘现在不再被广泛使用。
- en: '***MBR Device Nodes***'
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***MBR 设备节点***'
- en: 'Every disk, slice, and partition has a device node. The slice device node is
    an extension of the underlying disk, and the partition device node is an extension
    of the device’s node. Here are the device nodes on disk ada0 of an MBR-based system:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 每个磁盘、切片和分区都有一个设备节点。切片设备节点是基础磁盘的扩展，而分区设备节点是设备节点的扩展。以下是在基于 MBR 的系统中，磁盘 ada0 上的设备节点：
- en: '[PRE33]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first subdivision of the disk is the slice. Device nodes indicate a slice
    with the letter *s* and a number from 1 to 4\. The first slice is s1, the second
    is s2, and so on. Unused MBR partitions don’t get device nodes. Here, */dev/ada0s1*
    is slice 1 on the disk.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘的第一个细分是切片。设备节点使用字母 *s* 和 1 到 4 的数字表示切片。第一个切片是 s1，第二个是 s2，以此类推。未使用的 MBR 分区没有设备节点。在这里，*/dev/ada0s1*
    是磁盘上的第 1 个切片。
- en: The second layer of subdivision is the disklabel partition inside the slice.
    Each partition has a unique device node name created by adding a letter to the
    slice’s device node. Here, we have four disklabel partitions, */dev/ada0s1a* through
    */dev/ada0s1e*. Traditionally, the node ending in *a* (*/dev/ada0s1a*) is the
    root partition, while the node ending in *b* (*/dev/ada0s1b*) is swap space.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 第二层细分是切片内的 disklabel 分区。每个分区都有一个唯一的设备节点名称，通过在切片的设备节点后添加字母来创建。在这里，我们有四个 disklabel
    分区，从 */dev/ada0s1a* 到 */dev/ada0s1e*。传统上，结尾为 *a*（*/dev/ada0s1a*）的节点是根分区，而结尾为 *b*（*/dev/ada0s1b*）的节点是交换空间。
- en: Note that the list of device nodes doesn’t use the letter *c*. The c partition
    represents the entire slice. These days, you run disk partitioning tools on the
    slice entry rather than the disklabel for the slice.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，设备节点列表中没有使用字母 *c*。c 分区表示整个切片。如今，你在切片条目上运行磁盘分区工具，而不是在切片的 disklabel 上。
- en: Assign partitions d through h any way you like. A default disklabel can have
    up to seven usable partitions. With up to four slices on each drive, you can have
    up to 28 partitions on a drive. A disklabel can support up to 20 partitions, but
    you must indicate you want extra partitions when first creating the label.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随意分配d到h的分区。一个默认的磁盘标签最多可以有七个可用分区。每个磁盘最多可以有四个分区，因此你可以在一个磁盘上拥有最多28个分区。一个磁盘标签最多支持20个分区，但在第一次创建标签时，必须明确表示要使用额外的分区。
- en: '***MBR and Disklabel Alignment***'
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***MBR和磁盘标签对齐***'
- en: Slices have their own disk sector and filesystem block alignment issues. Traditionally,
    MBR partitions end on a cylinder boundary. Cylinder boundaries don’t mean anything
    on modern hardware, but even newer drives provide them as a comforting lie for
    older or less capable hardware. If you create MBR partitions that don’t end on
    a cylinder boundary, and you put that disk in a machine that requires respecting
    cylinder boundaries, the machine will have some sort of nervous breakdown. A disk
    you slice today could theoretically find its way into an older system. FreeBSD
    therefore arranges slices so that they end on cylinder boundaries. Cylinder boundaries
    not only can but probably do conflict with 4K disk sector sizes. If nothing else,
    the MBR itself takes up the first cylinder, or sixty-three 512-byte sectors!
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 分区有各自的磁盘扇区和文件系统块对齐问题。传统上，MBR分区会在磁道边界结束。虽然在现代硬件上，磁道边界并没有实际意义，但即使是较新的硬盘也会为旧的或能力较弱的硬件提供这样的“舒适的谎言”。如果你创建的MBR分区没有在磁道边界结束，并且将该磁盘放入需要遵守磁道边界的机器中，这台机器可能会发生某种“崩溃”。今天你所创建的分区，理论上可能会进入一台较老的系统中。因此，FreeBSD会安排分区，使它们结束在磁道边界上。磁道边界不仅可以，而且可能与4K磁盘扇区大小冲突。至少，MBR本身就占用了第一个磁道，或者63个512字节的扇区！
- en: Fortunately you rarely write to slice tables, and the performance of writing
    slice tables is rarely an issue. If you align your disklabel partitions within
    a slice to 1MB boundaries, you’ll lose a few sectors between the slice partition
    table and the disklabel partition, but you’ll have proper performance.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你很少需要写入分区表，并且写入分区表的性能问题也很少。只要你将磁盘标签分区对齐到1MB的边界，你会在分区表和磁盘标签分区之间丢失几个扇区，但性能将会是正常的。
- en: 'So: align disklabel partitions. Don’t align slices.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 所以：对齐磁盘标签分区。不要对齐分区。
- en: '***Creating Slices***'
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建分区***'
- en: Use gpart(8) to manage MBR slices. To create a slice, you need a partition type
    and a size. FreeBSD slices use type *freebsd*. If you don’t specify a size, gpart(8)
    uses all available space. On an empty disk, this dedicates the whole disk to a
    single slice.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用gpart(8)来管理MBR分区。要创建一个分区，你需要指定一个分区类型和大小。FreeBSD的分区使用类型*freebsd*。如果不指定大小，gpart(8)将使用所有可用空间。在一个空的磁盘上，这会将整个磁盘分配给一个单一的分区。
- en: 'Here, I erase the existing partitioning, tell the disk to use the MBR scheme,
    and create a single FreeBSD slice:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我删除现有的分区布局，告诉磁盘使用MBR方案，并创建一个单一的FreeBSD分区：
- en: '[PRE34]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Run `gpart show` and you’ll see that this disk now has a single slice. Add the
    `-p` flag to see the slice’s device node.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`gpart show`，你会看到该磁盘现在有一个单独的分区。添加`-p`标志以查看分区的设备节点。
- en: '[PRE35]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Our slice ada3s1 is now ready for disklabel partitions.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的分区ada3s1现在已经准备好用于磁盘标签分区。
- en: 'To create multiple slices, specify a size with `-s`. A common configuration
    for small embedded systems is to put three slices on a disk. Two smaller slices
    contain different versions of the operating system, while the third contains any
    data. Here, I divide this 1TB disk into two 150GB slices and give the rest to
    a third slice:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建多个分区，使用`-s`指定大小。小型嵌入式系统的常见配置是在一个磁盘上放置三个分区。两个较小的分区包含操作系统的不同版本，而第三个则包含任何数据。在这里，我将这个1TB的磁盘分为两个150GB的分区，并将其余的分配给第三个分区：
- en: '[PRE36]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***Removing Slices***'
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***删除分区***'
- en: 'Use `gpart delete` to remove unwanted slices. Give the slice number with `-i`.
    Here, I remove the third, larger slice from our multislice disk created in the
    last section:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gpart delete`来删除不需要的分区。通过`-i`指定分区编号。在这里，我删除了我们上一节中创建的多分区磁盘中的第三个较大分区：
- en: '[PRE37]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***Activating Slices***'
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***激活分区***'
- en: The active slice is the one that the BIOS tries to boot. Set the active slice
    with the `-a` active flag. Use `-i` to give the number of the active slice.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 激活的分区是BIOS尝试启动的分区。使用`-a`激活标志设置激活分区。使用`-i`指定激活分区的编号。
- en: '[PRE38]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Change which slice gets booted by setting a different active slice.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置不同的激活分区，改变启动的分区。
- en: The boot disk also needs a boot loader. While the MBR boot loader is different
    from the GPT or UEFI boot loaders, it uses the same gpart(8) `-b` flag. FreeBSD
    provides a copy of the MBR boot loader as */boot/mbr*.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 引导磁盘还需要一个引导加载程序。虽然MBR引导加载程序与GPT或UEFI引导加载程序不同，但它使用相同的gpart(8) `-b`标志。FreeBSD提供了一个MBR引导加载程序副本，位于*/boot/mbr*。
- en: '[PRE39]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Slice 1 on disk ada3 is now bootable. Now that you’ve sliced your disk, you
    can create BSD labels inside the slices.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘ada3上的切片1现在是可引导的。现在你已经对磁盘进行了分区，可以在这些切片内部创建BSD标签了。
- en: '**BSD Labels**'
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**BSD标签**'
- en: Creating BSD label (or disklabel) partitions inside a slice is much like creating
    slices or GPT partitions. You must tell the storage device the scheme to be used,
    create and remove partitions until you’re satisfied with them, and install a boot
    loader.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在切片内部创建BSD标签（或磁盘标签）分区，就像创建切片或GPT分区一样。你必须告诉存储设备使用的方案，创建并删除分区，直到你满意为止，然后安装引导加载程序。
- en: '***Creating a BSD Label***'
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建BSD标签***'
- en: Where GPT and MBR specifically provide space for partition tables, you must
    create a BSD label and write it to the beginning of the slice. As with any scheme,
    use `-s` and the name of the scheme. Install this scheme on the slice, not on
    the disk.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在GPT和MBR特定提供分区表空间的情况下，你必须创建一个BSD标签并将其写入切片的开头。和任何方案一样，使用`-s`和方案名称。将该方案安装在切片上，而不是磁盘上。
- en: Suppose you want to create a BSD label on the slice ada3s1\. Use the BSD scheme.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在切片ada3s1上创建一个BSD标签。使用BSD方案。
- en: '[PRE40]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is a default disklabel, with room for 8 disklabel partitions. You can increase
    the number of partitions, up to 20, by using the `-n` flag. Here, I create a whole
    bunch of partitions on ada3s3, the large partition.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个默认的磁盘标签，最多可以容纳8个磁盘标签分区。你可以通过使用`-n`标志增加分区数目，最多可达20个。在这里，我在ada3s3这个大分区上创建了一堆分区。
- en: '[PRE41]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There are no actual disklabel partitions on this slice; there’s merely a label
    that can contain disklabel partitions. Now that the label exists, you can create
    those partitions.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这个切片上没有实际的磁盘标签分区；只有一个可以包含磁盘标签分区的标签。标签一旦存在，你就可以创建这些分区了。
- en: '***Creating BSD Label Partitions***'
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建BSD标签分区***'
- en: Before blindly entering partitioning commands, plan how to partition the disk.
    Figuring things out on paper beforehand is much easier than figuring them out
    at the command line. I’m going to partition the first 150GB slice on this disk
    for UFS filesystems. This slice will get 5GB partitions for */* (root), swap,
    and */tmp*. The rest will go to */usr*. Why no */var*? I’ll dedicate the big slice,
    ada3s3, to */var*. I don’t need to add a boot partition because MBR disks don’t
    need one.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在盲目输入分区命令之前，先计划好如何对磁盘进行分区。提前在纸上搞清楚比在命令行上解决要容易得多。我打算将磁盘上第一个150GB的切片分配给UFS文件系统。这个切片将为*/*（根）、交换分区和*/tmp*分配5GB的分区。其余的空间将分配给*/usr*。为什么不为*/var*分区？我会把大的切片ada3s3分配给*/var*。我不需要添加引导分区，因为MBR磁盘不需要引导分区。
- en: To create a disklabel partition, you must specify the type with `-t` and the
    size with `-s`—exactly as you would for GPT partitions. FreeBSD UFS filesystems
    are of type *freebsd-ufs*. Let’s start with the root partition.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建磁盘标签分区，你必须使用`-t`指定类型，使用`-s`指定大小——就像你为GPT分区做的那样。FreeBSD UFS文件系统的类型是*freebsd-ufs*。我们从根分区开始。
- en: '[PRE42]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To view this partition, you must give `gpart show` the slice device, not the
    disk device. Using the disk device displays the slices.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这个分区，你必须给`gpart show`提供切片设备，而不是磁盘设备。使用磁盘设备会显示切片。
- en: '[PRE43]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The third line of output shows our 5GB partition.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第三行显示了我们的5GB分区。
- en: At the very beginning of this slice, we have 1,985 free blocks, or 993KB. I
    requested that the partition be aligned to 1MB boundaries, so gpart wasted a bit
    of space to meet that request. I’ll happily lose that 993KB, rather than halve
    the system’s performance.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个切片的最开始，我们有1985个空闲块，约993KB。我要求分区对齐到1MB边界，所以gpart浪费了一些空间来满足这个请求。我乐意失去这993KB，而不是降低系统的性能。
- en: Now create the swap partition of type *freebsd-swap*.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建类型为*freebsd-swap*的交换分区。
- en: '[PRE44]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The 5GB */tmp* comes next. Then, I dump the rest of the space into a partition
    for */usr* by omitting the size.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是5GB的*/tmp*。然后，我将剩余的空间分配给一个*/usr*分区，通过省略大小来完成。
- en: '[PRE45]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: A `gpart show` reveals our disklabel partitions have wasted 63 blocks, or 32KB,
    at the end of the disk. Watch me not care.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`gpart show`命令显示我们的磁盘标签分区在磁盘末尾浪费了63个块，约32KB。看我对此毫不在乎。
- en: These partitions are now ready to receive filesystems. We discuss UFS in [Chapter
    11](ch11.xhtml#ch11).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分区现在已经准备好接收文件系统了。我们在[第11章](ch11.xhtml#ch11)中讨论UFS。
- en: '***Assigning Specific Partition Letters***'
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分配特定的分区字母***'
- en: On a traditional BSD label, the *a* partition is for the root filesystem, while
    *b* is for swap. The *c* partition represents the entire slice. This isn’t mandatory,
    but I recommend not using any of these letters for any other purpose.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的BSD标签上，*a*分区用于根文件系统，而*b*用于交换。*c*分区表示整个切片。这不是强制性的，但我建议不要将这些字母用于任何其他用途。
- en: Why is this important? I once added a hard drive to a server so that we had
    more space for a database. We moved the database software to partition *a* and
    the actual data to partition *b*.^([4](footnote.xhtml#ch10fn4)) When I went on
    vacation a few months later, the system ran short on virtual memory. I got a call
    from a sysadmin who had found and activated the unconfigured swap space on the
    new drive—but now the database data was missing. Yes, the company lost several
    customers and many thousands of dollars of revenue, which is sad—but more importantly,
    it ruined one day of my vacation and cast a shadow over the rest. This was unacceptable.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这很重要？我曾经在一台服务器上添加了一个硬盘，以便为数据库提供更多空间。我们将数据库软件迁移到了分区*a*，而实际数据则迁移到了分区*b*。^([4](footnote.xhtml#ch10fn4))
    几个月后，当我去度假时，系统虚拟内存不足。我接到了系统管理员的电话，他找到了并激活了新硬盘上未配置的交换空间——但现在数据库数据丢失了。是的，公司失去了几位客户，并且损失了成千上万美元的收入，这很可悲——但更重要的是，这毁了一天的假期，并且对剩余的假期蒙上了阴影。这是不可接受的。
- en: Don’t bother fighting these traditions, especially on a decreasingly common
    disk format. Don’t use the letters *a*, *b*, or *c* for partitions other than
    those decreed by the Berkeley elders.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 不要试图反抗这些传统，尤其是在越来越不常见的磁盘格式上。除非是由伯克利的长老们规定，否则不要将字母*a*、*b*或*c*用于其他分区。
- en: The gpart program is designed to work with partition numbers, not letters. When
    you’re creating disklabels, however, `gpart add` maps index numbers onto letters.
    Partition 1 is *a*, partition 2 is *b*, and so on. By specifying a partition index
    when you create the partition, you assign the letter to the partition.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: gpart程序设计时是为了处理分区编号，而不是字母。然而，在创建磁盘标签时，`gpart add`会将索引号映射到字母上。分区1是*a*，分区2是*b*，依此类推。通过在创建分区时指定分区索引，你将字母分配给该分区。
- en: If you don’t specify a partition number, `gpart add` assigns partition letters
    starting with *a*. You might assign your first partition number 18, but if you
    don’t specify a number for the next partition, it’ll wind up getting partition
    *a*. To avoid using *a*, *b*, or *c*, use a number for every partition you create.
    You can use letters only up to the number of disklabel slots the partition has.
    A standard disklabel can use only letters *a* through *h*, while a 20-partition
    label can use *a* through *t*.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有指定分区号，`gpart add`会从分区字母*a*开始分配分区字母。你可能将第一个分区编号为18，但如果没有为下一个分区指定编号，它将默认使用分区*a*。为了避免使用*a*、*b*或*c*，为你创建的每个分区使用数字。你只能使用字母，直到分区有的磁盘标签槽位的数量。标准磁盘标签只能使用字母*a*到*h*，而一个支持20个分区的标签可以使用*a*到*t*。
- en: On my three-slice system, I want to put */var* on ada3s3\. I want to use a letter
    other than *a*, *b*, or *c*, so I randomly pick index 18\. It’s almost exactly
    the same as the partition for */usr*, but we’re adding it to a different slice.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的三分区系统中，我想将*/var*放在ada3s3上。我想使用一个不同于*a*、*b*或*c*的字母，所以我随机选择了索引18。它几乎与*/usr*的分区完全相同，只不过我们将它添加到了不同的切片上。
- en: '[PRE46]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: To see that disklabel partition, you’ll need to run `gpart show ada3s3`. Add
    `-p` to see the device name.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看该磁盘标签分区，你需要运行`gpart show ada3s3`。加上`-p`可以查看设备名称。
- en: '[PRE47]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: What do you know? The 18th letter of our alphabet is *R*.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗？我们字母表中的第18个字母是*R*。
- en: With partitions, we can start to look at filesystems.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 有了分区，我们可以开始查看文件系统了。
