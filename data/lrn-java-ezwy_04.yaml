- en: '**4**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4**'
- en: CREATING YOUR FIRST ANDROID APP
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建你的第一个 Android 应用
- en: '![Image](../images/circle.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/circle.jpg)'
- en: To build the mobile version of the Hi-Lo guessing game app, we’re going to use
    Android Studio. If you didn’t set this up in [Chapter 1](ch1.xhtml#ch1), go back
    to “[Installing Android Studio for Mobile App Development](ch1.xhtml#toc_lev13)”
    on [page 8](ch1.xhtml#page_8) and set it up. As with the GUI version of the game,
    we’re going to create a user interface for the app, as shown in [Figure 4-1](ch4.xhtml#ch4fig1).
    The apps you’ve created so far could only be run on your desktop computer, but
    Android apps can run on any Android device, including phones, tablets, watches,
    TVs, and so on. If you don’t own an Android device, don’t worry—you can still
    code for Android, as the Android emulator that comes with Android Studio lets
    you simulate running a device.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建 Hi-Lo 猜数字游戏的移动版本，我们将使用 Android Studio。如果你没有在[第 1 章](ch1.xhtml#ch1)中设置它，返回到
    “[为移动应用开发安装 Android Studio](ch1.xhtml#toc_lev13)”（第 8 页）并进行设置。与游戏的图形界面版本一样，我们将为应用创建一个用户界面，如[图
    4-1](ch4.xhtml#ch4fig1)所示。到目前为止，你创建的应用只能在桌面计算机上运行，但 Android 应用可以在任何 Android 设备上运行，包括手机、平板、手表、电视等。如果你没有
    Android 设备，不用担心——你仍然可以为 Android 编写代码，因为 Android Studio 附带的 Android 模拟器允许你模拟设备运行。
- en: '![Image](../images/f0076-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0076-01.jpg)'
- en: '*Figure 4-1: The guessing game will become a mobile app in this chapter. The
    app runs on a simulated Android phone (left) and on an actual Android tablet (right).*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：这个猜数字游戏将在本章变成一个移动应用。该应用在模拟的 Android 手机（左）和实际的 Android 平板（右）上运行。*'
- en: '[Figure 4-1](ch4.xhtml#ch4fig1) shows our app running on the Android emulator,
    simulating how the app looks on a Nexus 6P, and on an Android tablet. Both versions
    are running the same code—and, even more conveniently, we can reuse a lot of the
    Java code we built for the previous desktop versions because Android is built
    on Java!'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-1](ch4.xhtml#ch4fig1) 显示了我们的应用在 Android 模拟器上运行，模拟应用在 Nexus 6P 上的样子，以及在
    Android 平板上的样子。两个版本都在运行相同的代码——更方便的是，我们可以重用为前一个桌面版本编写的大量 Java 代码，因为 Android 是基于
    Java 构建的！'
- en: Notice that the emulator and the actual device look very similar, with some
    minor differences to account for the different screen sizes between the phone
    and the 7-inch tablet. In the same way that you can write a Java app for Windows
    and run it on macOS or Linux, you can write an Android mobile app in Java and
    run it on any of literally thousands of Android devices. Let’s get started building
    your first Android mobile app!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，模拟器和实际设备非常相似，只有一些细微的差异，以适应手机和 7 英寸平板之间的屏幕大小不同。就像你可以为 Windows 编写 Java 应用并在
    macOS 或 Linux 上运行一样，你也可以用 Java 编写 Android 移动应用，并在成千上万的 Android 设备上运行。让我们开始构建你的第一个
    Android 移动应用吧！
- en: Starting a New Android Studio App Project
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动一个新的 Android Studio 应用项目
- en: The first time you start Android Studio, it may take a few minutes to update
    and run. When it starts, you’ll see a screen like the one shown in [Figure 4-2](ch4.xhtml#ch4fig2).
    Select the option labeled **Start a new Android Studio project**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次启动 Android Studio 时，可能需要几分钟来更新和运行。当它启动时，你将看到如[图 4-2](ch4.xhtml#ch4fig2)所示的界面。选择标有**启动一个新的
    Android Studio 项目**的选项。
- en: Name your new project *GuessingGame*, with no space. If you have a website,
    you can enter it in the Company Domain field, as shown in [Figure 4-3](ch4.xhtml#ch4fig3).
    Otherwise, leave the default example domain. Next, choose a project location.
    I’ve set up a folder called *AndroidProjects* to keep things organized, and you
    should do the same.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的新项目命名为*GuessingGame*，不使用空格。如果你有网站，可以在公司域名字段中输入它，如[图 4-3](ch4.xhtml#ch4fig3)所示。否则，保持默认的示例域名。接下来，选择一个项目位置。我设置了一个名为*AndroidProjects*的文件夹来保持组织性，你也可以这么做。
- en: '![Image](../images/f0077-01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0077-01.jpg)'
- en: '*Figure 4-2: Once Android Studio finishes setting up, choose* ***Start a new
    Android Studio project***.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-2：一旦 Android Studio 完成设置，选择* ***启动一个新的 Android Studio 项目***。'
- en: '![Image](../images/f0077-02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0077-02.jpg)'
- en: '*Figure 4-3: Name your new Android Studio project* GuessingGame, *with no space.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-3：为你的新 Android Studio 项目命名为* GuessingGame，*不使用空格。*'
- en: Click **Next** after naming your project. Now you’ll have the opportunity to
    choose which Android version number your app should run on. The Android platform
    evolves rapidly as new devices and capabilities are developed, so we’ll need to
    pick a target. Fortunately, Android Studio is regularly updated with both the
    latest Android versions and information on how many devices still use the older
    versions. You’ll also need to select a *software development kit (SDK)* or *application
    program interface (API)* level when you choose which versions of Android to support.
    SDK and API levels include tools you’ll use to develop your app, but they’re tied
    to specific versions of Android. The Target Android Devices window, shown in [Figure
    4-4](ch4.xhtml#ch4fig4), allows you to choose a minimum SDK or API level for each
    app you develop.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 命名项目后点击**Next**。现在，你将有机会选择你的应用程序应该运行的Android版本号。随着新设备和功能的不断开发，Android平台快速发展，因此我们需要选择一个目标版本。幸运的是，Android
    Studio定期更新，提供最新的Android版本信息，以及仍在使用旧版本的设备数量。你还需要选择一个**软件开发工具包（SDK）**或**应用程序编程接口（API）**级别，选择支持的Android版本时。SDK和API级别包括你将用来开发应用的工具，但它们与特定的Android版本相关联。目标Android设备窗口，如[图4-4](ch4.xhtml#ch4fig4)所示，允许你为每个开发的应用选择最低SDK或API级别。
- en: '![Image](../images/f0078-01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0078-01.jpg)'
- en: '*Figure 4-4: Choose the Minimum SDK level for the Android devices you’re developing
    for.*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-4：选择你要开发的Android设备的最低SDK级别。*'
- en: Choose **API 16 (Android 4.1, Jelly Bean)** as the minimum SDK for the guessing
    game app. Android Studio will tell you that this runs on more than 99 percent
    of active Android devices. Click **Next**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**API 16 (Android 4.1, Jelly Bean)**作为猜谜游戏应用的最低SDK级别。Android Studio会告诉你，这个版本支持超过99%的活跃Android设备。点击**Next**。
- en: The New Project wizard will ask you what kind of *activity* you want to add
    to your app. An activity is just something the user can do. Each activity usually
    has its own screen layout with a user interface, like the ones shown in [Figure
    4-5](ch4.xhtml#ch4fig5).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 新项目向导将询问你想要在应用中添加哪种**活动**。活动就是用户可以执行的操作。每个活动通常都有自己的屏幕布局和用户界面，就像[图4-5](ch4.xhtml#ch4fig5)所示的那样。
- en: There are lots of choices for the main activity for an app, such as Google Maps,
    Login, Settings, Tabbed Activities, and more. The Basic Activity will give us
    a great foundation for the guessing game app, so choose that option and click
    **Next**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多选择可以作为应用的主要活动，比如Google Maps、登录、设置、标签页活动等。**Basic Activity**将为我们提供一个非常好的基础，用于猜谜游戏应用，因此选择该选项并点击**Next**。
- en: 'We’ll use the default names provided by Android Studio on the following screen
    (shown in [Figure 4-6](ch4.xhtml#ch4fig6)): *MainActivity* for the activity name
    and *activity_main* for the layout name. The activity file contains the Java source
    code that runs the app. The layout is a separate file that contains the app interface.
    Click **Finish** to complete your app project setup.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的界面上使用Android Studio提供的默认名称（如[图4-6](ch4.xhtml#ch4fig6)所示）：**MainActivity**作为活动名称，**activity_main**作为布局名称。活动文件包含运行应用程序的Java源代码，布局是一个独立的文件，包含应用界面。点击**Finish**完成应用项目的设置。
- en: '![Image](../images/f0079-01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0079-01.jpg)'
- en: '*Figure 4-5: Choose Basic Activity as the basis for your app.*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-5：选择Basic Activity作为你应用的基础。*'
- en: '![Image](../images/f0079-02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0079-02.jpg)'
- en: '*Figure 4-6: Leave the default values for activity name and layout name.*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-6：保留活动名称和布局名称的默认值。*'
- en: The project may take a few moments to build, as Android Studio creates the project
    files and sets up the *GuessingGame* app project. After it finishes loading, Android
    Studio will open the project to a default view that looks like [Figure 4-7](ch4.xhtml#ch4fig7).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 项目可能需要一些时间来构建，因为Android Studio正在创建项目文件并设置**GuessingGame**应用项目。加载完成后，Android
    Studio会以类似[图4-7](ch4.xhtml#ch4fig7)的默认视图打开该项目。
- en: '![Image](../images/f0080-01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0080-01.jpg)'
- en: '*Figure 4-7: The default project view in Android Studio, complete with a GUI
    mobile layout view*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-7：Android Studio中的默认项目视图，包含GUI移动布局视图*'
- en: If your project doesn’t open with this screen, click the Project tab in the
    upper left, expand the *app* folder in the Project Explorer, expand the *res*
    (short for *resources*) folder, expand *layout*, and then double-click the *content_main.xml*
    file to see a view similar to [Figure 4-7](ch4.xhtml#ch4fig7).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目没有以这个界面打开，请点击左上角的**Project**标签，展开**app**文件夹，展开**res**（即**resources**的缩写）文件夹，展开**layout**文件夹，然后双击**content_main.xml**文件，查看类似[图4-7](ch4.xhtml#ch4fig7)的视图。
- en: Building the GUI Layout in Design View
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在设计视图中构建GUI布局
- en: Android apps separate the layout from the app code (the activity), so this app
    will be a little different from the desktop app we wrote in [Chapter 3](ch3.xhtml#ch3).
    The layout isn’t described in Java but in *eXtensible Markup Language (XML)*.
    Fortunately, despite this difference, we can still use a drag-and-drop palette
    similar to Eclipse’s WindowBuilder Editor to design the GUI view. The main difference
    in Android Studio is that the components have been named with mobile apps in mind.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Android 应用将布局与应用代码（活动）分开，因此这个应用与我们在[第 3 章](ch3.xhtml#ch3)编写的桌面应用略有不同。布局不是用 Java
    描述的，而是用 *可扩展标记语言（XML）* 描述的。幸运的是，尽管存在这种差异，我们仍然可以使用类似于 Eclipse 的 WindowBuilder 编辑器的拖放调色板来设计
    GUI 界面。Android Studio 中的主要区别在于，组件的命名已经考虑到了移动应用的需求。
- en: Like the WindowBuilder Editor, Android Studio has two tabs, one for the design
    view and one for the source code. Click the Design tab in the lower-left corner
    of the main window containing the *content_main.xml* file. You’ll see the design
    view shown in [Figure 4-8](ch4.xhtml#ch4fig8).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 和 WindowBuilder 编辑器一样，Android Studio 也有两个标签页，一个用于设计视图，另一个用于源代码。点击主窗口左下角的设计标签，里面包含
    *content_main.xml* 文件。你将看到[图 4-8](ch4.xhtml#ch4fig8)中显示的设计视图。
- en: '![Image](../images/f0081-01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0081-01.jpg)'
- en: '*Figure 4-8: Android Studio has a design view similar to the WindowBuilder
    Editor in Eclipse.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-8：Android Studio 的设计视图类似于 Eclipse 中的 WindowBuilder 编辑器。*'
- en: '[Figure 4-8](ch4.xhtml#ch4fig8) shows the four areas of the design view that
    we’ll be using the most: the Project Explorer pane ➊, the Palette pane ➋, the
    Preview pane ➌, and the Properties pane ➍.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-8](ch4.xhtml#ch4fig8) 显示了我们最常使用的设计视图的四个区域：项目资源管理器窗格 ➊、调色板窗格 ➋、预览窗格 ➌ 和属性窗格
    ➍。'
- en: In the center of the Preview pane, you’ll see a label—known as a `TextView`
    in Android terminology—reading *Hello World!*. Click the label and press DELETE
    (or right-click and select **Delete** from the menu) to delete it from the Preview
    pane. Then, click the **Layouts** option in the Palette pane, select a **RelativeLayout**,
    and drag it either to the Preview pane or onto the ConstraintLayout (in [Figure
    4-8](ch4.xhtml#ch4fig8)) in the Component Tree listing just below the Palette
    pane. We’ll start with an empty RelativeLayout to build our guessing game GUI
    view.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在预览窗格的中心，你会看到一个标签——在 Android 术语中称为 `TextView`——显示 *Hello World!*。点击该标签并按 DELETE（或右键点击并从菜单中选择
    **删除**）将其从预览窗格中删除。然后，在调色板窗格中点击 **Layouts** 选项，选择 **RelativeLayout**，并将其拖动到预览窗格或拖动到位于调色板窗格下方的组件树列表中的
    ConstraintLayout（见[图 4-8](ch4.xhtml#ch4fig8)）。我们将从一个空的 RelativeLayout 开始，构建我们的猜数字游戏
    GUI 界面。
- en: In the Palette pane, under Widgets, select **TextView**. A `TextView` in Android
    is similar to a `JLabel` in the Swing toolkit, and *widgets* are what we call
    most of the GUI components in Android. We’ll drag and drop to place GUI components
    in the design preview.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在调色板窗格的 Widgets 下，选择 **TextView**。Android 中的 `TextView` 类似于 Swing 工具包中的 `JLabel`，而
    *widgets* 是我们在 Android 中称大多数 GUI 组件的术语。我们将使用拖放方式将 GUI 组件放置到设计预览中。
- en: Click the `TextView` widget and drag it over the white app background in the
    simulated Android phone, placing the widget near the top to serve as the title
    of your app.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 `TextView` 小部件，并将其拖动到模拟 Android 手机的白色应用背景上，放置该小部件靠近顶部，以作为你应用的标题。
- en: After placing the title `TextView`, you’ll see options appear in the Properties
    pane on the right. If the pane doesn’t appear, click Properties in the upper-right
    corner of the Design tab to expand the Properties pane. Find the `text` property
    of the `TextView` widget you’ve just added. Change the text to `"``Your Name``'s
    Guessing Game"` and change the `textAppearance` property to **Large**. Then, drag
    the `TextView` to center it at the top of the screen as shown in [Figure 4-9](ch4.xhtml#ch4fig9).
    The gray dashed guideline helps with placement.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 放置标题 `TextView` 后，你会看到右侧属性窗格中出现选项。如果属性窗格没有出现，请点击设计标签右上角的属性按钮以展开属性窗格。找到你刚刚添加的
    `TextView` 小部件的 `text` 属性。将文本更改为 `"``Your Name``'s Guessing Game"` 并将 `textAppearance`
    属性更改为 **Large**。然后，将 `TextView` 拖动到屏幕顶部的中心位置，如[图 4-9](ch4.xhtml#ch4fig9)所示。灰色虚线辅助线有助于定位。
- en: '![Image](../images/f0082-01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0082-01.jpg)'
- en: '*Figure 4-9: Placing GUI widgets/components in Android Studio is very similar
    to the process in Eclipse.*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-9：在 Android Studio 中放置 GUI 小部件/组件与在 Eclipse 中的过程非常相似。*'
- en: To add the label prompting the user to enter a number between 1 and 100, place
    another `TextView` widget onto the design preview just a small distance below
    the title. Change the `textAppearance` property to **Medium** in the Properties
    pane on the right. Then, type `Enter a number between 1 and 100:` in the `text`
    property for the `TextView`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加提示用户输入 1 到 100 之间数字的标签，将另一个 `TextView` 控件放置到设计预览中，稍微低于标题。然后，在右侧的属性面板中，将
    `textAppearance` 属性更改为 **Medium**。接着，在 `TextView` 的 `text` 属性中输入 `Enter a number
    between 1 and 100:`。
- en: Next, we’ll place the text field, also known as an `EditText` in Android, for
    the user’s guess. Text fields are listed just below Widgets in the Palette pane.
    There are many types of text fields in Android, and each behaves differently depending
    on the needs of your app. For example, Plain Text is a simple text field, Password
    hides characters as they’re typed, Phone shows the numeric keypad and formats
    the input as a phone number, and E-mail shows a modified keyboard with the @ symbol.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将放置用户输入猜测的文本字段，在 Android 中也称为 `EditText`。文本字段在 Palette 面板中的 Widget 下面列出。Android
    中有许多类型的文本字段，每种根据应用的需求行为不同。例如，Plain Text 是一个简单的文本字段，Password 在输入时隐藏字符，Phone 显示数字键盘并将输入格式化为电话号码，E-mail
    显示一个带有 @ 符号的修改过的键盘。
- en: Choose a **Number** text field so the user can enter their guess from a numeric
    keyboard on their screen. Place this field just a little below the previous label.
    Then, place a Button widget an equal distance below the text field and change
    its `text` property to `"Guess!"`. Finally, place another `TextView` widget below
    the button, giving it a `text` property of `"Enter a number, then click Guess!"`.
    If you have trouble placing the widget the same distance below the button because
    you’re too close to the vertical center of the screen, place it lower or higher
    in the Properties pane under Layout_Margin (you may need to click **View all properties**
    and then click the gray arrow next to Layout_Margin to expand the margin properties),
    find **layout_marginTop**, and change the value to **30dp**. The finished GUI
    layout should look similar to [Figure 4-10](ch4.xhtml#ch4fig10).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个**数字**文本字段，以便用户可以通过屏幕上的数字键盘输入他们的猜测。将这个字段放置在之前标签的下方一点。然后，将一个按钮控件放置在文本字段下方相等的距离，并将其`text`属性更改为
    `"Guess!"`。最后，将另一个 `TextView` 控件放在按钮下方，设置其 `text` 属性为 `"请输入一个数字，然后点击 Guess!"`。如果由于太接近屏幕的垂直中心而难以将控件放置在按钮下方相同的距离，可以在属性面板中的
    Layout_Margin 下将其向下或向上调整（你可能需要点击**查看所有属性**，然后点击 Layout_Margin 旁边的灰色箭头以展开边距属性），找到
    **layout_marginTop**，并将其值更改为 **30dp**。完成的 GUI 布局应该类似于[图 4-10](ch4.xhtml#ch4fig10)。
- en: '![Image](../images/f0083-01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0083-01.jpg)'
- en: '*Figure 4-10: The finished GUI layout for the Android guessing game app in
    design view*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-10：Android 猜数字游戏应用程序的完成 GUI 布局（设计视图）*'
- en: We’ll make one final change before naming the GUI components. Change the `width`
    property of the numeric text field, where the user enters their guess, to **75dp**;
    do so by clicking **View all properties** or the left-and-right arrow icon in
    the Properties pane. The original text field was too wide for a number-guessing
    game that uses only numbers between 1 and 100, so we’ve resized it to make it
    narrower.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名 GUI 组件之前，我们再做一个最终的修改。将用户输入猜测的数字文本字段的 `width` 属性更改为 **75dp**；可以通过点击属性面板中的**查看所有属性**或左右箭头图标来完成。原始的文本字段对于一个仅使用
    1 到 100 之间数字的猜数字游戏来说太宽了，所以我们将它调整得更窄一些。
- en: With that small change, it’s time to start naming our GUI components so we’ll
    be able to find them easily in the Java code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 做了这个小改动后，我们可以开始命名我们的 GUI 组件，这样我们就可以在 Java 代码中轻松找到它们了。
- en: Naming GUI Components in Android Studio
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Android Studio 中命名 GUI 组件
- en: Just as we named GUI components in Eclipse, we’ll need to name the GUI elements
    in Android Studio so that we can access them from the code. But in Android Studio,
    the names of the GUI elements themselves won’t appear in the Java source code
    by default. Instead, we’ll have to connect these XML GUI components to the Java
    code by hand before we can use them in the code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在 Eclipse 中命名 GUI 组件一样，我们也需要在 Android Studio 中命名 GUI 元素，以便能够在代码中访问它们。但在
    Android Studio 中，GUI 元素的名称默认不会出现在 Java 源代码中。相反，我们需要手动将这些 XML GUI 组件连接到 Java 代码中，才能在代码中使用它们。
- en: For now, though, we just need to change the `id` property of the number text
    field, the guess button, and the bottommost label to `txtGuess`, `btnGuess`, and
    `lblOutput`, respectively. If a pop-up message asks you to update usages, click
    **Yes**. We’ll use these names for consistency and convenience. [Figure 4-11](ch4.xhtml#ch4fig11)
    shows the renamed text field, button, and label.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只需要将数字文本框、猜测按钮和最底部标签的`id`属性分别更改为`txtGuess`、`btnGuess`和`lblOutput`。如果弹出消息提示你更新用法，点击**是**。我们将使用这些名称以保持一致性和便利性。[图
    4-11](ch4.xhtml#ch4fig11)展示了重命名后的文本框、按钮和标签。
- en: '![Image](../images/f0084-01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0084-01.jpg)'
- en: '*Figure 4-11: Rename the `EditText`, `Button`, and `TextView` components (circled)
    by changing their id properties to `txtGuess`, `btnGuess`, and `lblOutput`, respectively.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-11：通过更改 `EditText`、`Button` 和 `TextView` 组件（圈出的部分）的 id 属性，分别将其重命名为 `txtGuess`、`btnGuess`
    和 `lblOutput`。*'
- en: One last thing we should do before we start coding in Java is hide the small
    *floating action button (fab)* icon, shown in the bottom right of the design preview
    in [Figure 4-12](ch4.xhtml#ch4fig12). Your project may not show the fab icon,
    but if it does, double-click the *activity_main.xml* file in the Project Explorer
    pane ➊. Click the *activity_main.xml* tab above the design view ➋ and then click
    the fab icon ➌. Go to Properties and set the `visibility` property to **invisible**
    ➍.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写 Java 代码之前，我们需要做的一件事是隐藏小的*浮动操作按钮（fab）*图标，该图标显示在设计预览的右下角，[图 4-12](ch4.xhtml#ch4fig12)中。你的项目可能不会显示
    fab 图标，但如果显示了，双击项目资源管理器面板中的*activity_main.xml*文件 ➊。点击设计视图上方的*activity_main.xml*标签
    ➋，然后点击 fab 图标 ➌。进入属性设置，将`visibility`属性设置为**不可见** ➍。
- en: '![Image](../images/f0084-02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0084-02.jpg)'
- en: '*Figure 4-12: Hide the fab icon by going to the* activity_main.xml *file, clicking
    the small envelope icon, and setting the* `*visibility*` *property to invisible.*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-12：通过进入* activity_main.xml *文件，点击小的信封图标，并将* `*visibility*` *属性设置为不可见来隐藏
    fab 图标。*'
- en: I’ve chosen to set the fab icon to invisible rather than delete it entirely,
    because you might want to use the floating action button to add new features to
    your app later on. The floating action button can share info from the app to Facebook,
    post a tweet in Twitter about how much you like the app, send an email to a friend
    about the app, and more.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择将 fab 图标设置为不可见，而不是完全删除它，因为你可能希望以后使用浮动操作按钮为应用添加新功能。浮动操作按钮可以将应用中的信息分享到 Facebook，发布一条推文到
    Twitter，告诉朋友你有多喜欢这个应用，发送电子邮件告诉朋友关于这个应用的信息，等等。
- en: Next, we’ll wire up the GUI so that we can use it in Java to program the rest
    of the app.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将连接 GUI，以便我们可以在 Java 中使用它来编程应用的其余部分。
- en: Connecting the GUI to Java in Android Studio
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Android Studio 中将 GUI 连接到 Java
- en: It’s time to connect the GUI to Java so we can write the code for the guessing
    game app. First, let’s open the Java source code file by looking in the Project
    Explorer pane, under *app* ▸ *src* ▸ *main* ▸ *java* ▸ *com.example.guessinggame*
    (or your package name) ▸ *MainActivity*. Double-click *MainActivity* to open the
    *MainActivity.java* source code file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将 GUI 连接到 Java，以便我们可以编写猜谜游戏应用程序的代码了。首先，让我们通过在项目资源管理器面板中查找，打开 Java 源代码文件，路径为*app*
    ▸ *src* ▸ *main* ▸ *java* ▸ *com.example.guessinggame*（或你的包名） ▸ *MainActivity*。双击*MainActivity*以打开*MainActivity.java*源代码文件。
- en: You may have noticed the *java* folder in the Project Explorer has another package
    or two, possibly labeled the same, but with *(test)* or *(androidTest)* after
    the package name. These packages are used for testing in larger applications,
    where engineers evaluate app quality, security, and functionality for software
    quality assurance. We won’t tackle quality assurance, but it’s a great way to
    get into the software development industry.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，项目资源管理器中的*java*文件夹下有另一个或两个包，可能会有相同的名称，但包名后面带有*(test)*或*(androidTest)*。这些包用于更大型应用程序的测试，工程师通过测试评估应用程序的质量、安全性和功能性，以进行软件质量保证。我们不会涉及质量保证，但这是进入软件开发行业的一个很好的途径。
- en: The Java source code inside the *MainActivity.java* file will look something
    like [Figure 4-13](ch4.xhtml#ch4fig13).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*MainActivity.java*文件中的 Java 源代码大致如下所示：[图 4-13](ch4.xhtml#ch4fig13)。'
- en: '![Image](../images/f0085-01.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0085-01.jpg)'
- en: '*Figure 4-13: The Java source code for the app is called* MainActivity.java
    *by default.*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-13：应用的 Java 源代码默认命名为* MainActivity.java*。*'
- en: Notice that in Android Studio, a package declaration appears at the very top
    of the file by default. Packages help us organize all the files needed in a more
    complex program, such as a mobile app. In this case, the package name is the company
    domain name from the Create New Project screen back in [Figure 4-3](ch4.xhtml#ch4fig3)
    on [page 77](ch4.xhtml#page_77), but in reverse order—notice the *com* comes first.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在Android Studio中，包声明默认出现在文件的最顶部。包帮助我们组织在更复杂程序中所需的所有文件，比如移动应用。在这种情况下，包名是[图4-3](ch4.xhtml#ch4fig3)中创建新项目屏幕上使用的公司域名，但顺序相反——注意*com*在前。
- en: Several Android `import` statements follow the package declaration. These work
    just as they do for Java on the desktop, importing existing features and functionality
    into the code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 若干Android `import`语句紧跟在包声明后。这些语句的作用与桌面Java中的导入功能相同，将现有功能导入代码中。
- en: 'The following `public class MainActivity` code snippet may be slightly different
    for you depending on the minimum API level you chose for your app, but the overall
    code will be similar, and the app we’re writing will work across multiple API
    levels. First we’ll declare our variables to connect the GUI to the program. Click
    just inside the opening brace for the class, on the next line down, and add these
    lines to declare variables for the text field, button, and output label:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`public class MainActivity`代码片段可能会根据你为应用选择的最低API级别有所不同，但整体代码将相似，我们编写的应用将能够跨多个API级别运行。首先，我们将声明连接GUI和程序的变量。点击类的开括号内的下一行，并添加这些行以声明文本框、按钮和输出标签的变量：
- en: public class MainActivity extends AppCompatActivity {
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: public class MainActivity extends AppCompatActivity {
- en: private EditText txtGuess;
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: private EditText txtGuess;
- en: private Button btnGuess;
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: private Button btnGuess;
- en: private TextView lblOutput;
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: private TextView lblOutput;
- en: As you enter each new variable type, you may see a drop-down menu offering to
    import it (`android.widget.EditText`, for example). If you click the correct widget
    type to import, Android Studio will add the corresponding `import` statement for
    you. If you typed the three lines without clicking to accept the automatic imports,
    just click each widget type and then press ALT-ENTER (or OPTION-ENTER on macOS)
    to import any missing classes, as shown in [Figure 4-14](ch4.xhtml#ch4fig14).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入每种新的变量类型时，可能会看到一个下拉菜单，提供导入它（例如`android.widget.EditText`）。如果你点击正确的小部件类型进行导入，Android
    Studio会为你添加相应的`import`语句。如果你在没有点击接受自动导入的情况下输入了这三行代码，只需点击每个小部件类型，然后按ALT-ENTER（或在macOS上按OPTION-ENTER）来导入任何缺失的类，如[图4-14](ch4.xhtml#ch4fig14)所示。
- en: '![Image](../images/f0086-01.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0086-01.jpg)'
- en: '*Figure 4-14: Android Studio enables you to automatically import classes just
    as Eclipse did, either as you type or afterward with a simple key combination
    (**ALT**-**ENTER*, *or* *OPTION**-**ENTER* *on macOS).*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-14：Android Studio允许你像Eclipse一样自动导入类，无论是在输入时还是在之后通过简单的快捷键组合（**ALT**-**ENTER**，*或者*
    *macOS上的* *OPTION**-**ENTER*）。*'
- en: 'The following three `import` statements should now appear with the others near
    the top of your file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个`import`语句现在应与文件顶部其他语句一起出现：
- en: import android.widget.EditText;
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: import android.widget.EditText;
- en: import android.widget.Button;
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: import android.widget.Button;
- en: import android.widget.TextView;
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: import android.widget.TextView;
- en: After declaring the three variables for the GUI widgets, we need to connect
    those variables to the XML components for each one. We’ll do this in the `onCreate()`
    method, shown at the bottom of [Figure 4-14](ch4.xhtml#ch4fig14), which is the
    function that runs when the app is loaded. Android Studio has automatically generated
    the code to begin this method.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明了GUI小部件的三个变量后，我们需要将这些变量连接到每个小部件的XML组件。在`onCreate()`方法中完成这一操作，该方法在应用加载时运行，如[图4-14](ch4.xhtml#ch4fig14)底部所示。Android
    Studio已经自动生成了开始这个方法的代码。
- en: 'Look inside the top two or three lines of the `onCreate()` method, and find
    this line:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`onCreate()`方法的前两到三行，找到这一行：
- en: setContentView(R.layout.activity_main);
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: setContentView(R.layout.activity_main);
- en: 'Right after that line, press ENTER a couple of times and type the following
    partial line of code to begin connecting the variable `txtGuess` to the `EditText`
    widget in the XML layout file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在该行后，按几次ENTER键并输入以下部分代码，开始将变量`txtGuess`与XML布局文件中的`EditText`小部件连接：
- en: txtGuess = (EditText) findViewById(R.id.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: txtGuess = (EditText) findViewById(R.id.
- en: The `findViewById()` function is how we connect GUI widgets in the XML layout
    to the variables we’ll use to represent them in the source code. The `R` inside
    that function refers to a special file called *R.java* that Android Studio generates
    to make it possible to connect resources. The `R` is short for *resources*, usually
    stored in the *res* folder in the project. As you begin to type the preceding
    line, you’ll see a pop-up menu like the one shown in [Figure 4-15](ch4.xhtml#ch4fig15).
    Find and double-click `txtGuess` in the drop-down list of options. If you don’t
    see the `txtGuess` option, go back to the design view for *content _main.xml*
    and make sure you gave the text field the `id` property of `txtGuess`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`findViewById()` 函数是我们将 XML 布局中的 GUI 控件与我们在源代码中使用的变量连接起来的方式。该函数中的 `R` 指的是一个名为
    *R.java* 的特殊文件，它是 Android Studio 生成的，用于实现资源的连接。`R` 是 *resources*（资源）的缩写，通常存储在项目的
    *res* 文件夹中。当你开始输入前述代码行时，你会看到一个弹出菜单，如 [图 4-15](ch4.xhtml#ch4fig15) 所示。找到并双击下拉列表中的
    `txtGuess`。如果你没有看到 `txtGuess` 选项，请返回 *content_main.xml* 的设计视图，确保为文本字段指定了 `id`
    属性为 `txtGuess`。'
- en: 'Finish with the closing parenthesis followed by a semicolon, as shown in the
    following listing, and then set up the button and output label. The finished three
    lines of code inside your `onCreate()` method should look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码行末尾加上右括号和分号，如下所示，然后设置按钮和输出标签。你在 `onCreate()` 方法中的三行代码应该像这样：
- en: protected void onCreate(Bundle savedInstanceState) {
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: protected void onCreate(Bundle savedInstanceState) {
- en: super.onCreate(savedInstanceState);
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: super.onCreate(savedInstanceState);
- en: setContentView(R.layout.*activity_main*);
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: setContentView(R.layout.*activity_main*);
- en: txtGuess = (EditText) findViewById(R.id.*txtGuess*);
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: txtGuess = (EditText) findViewById(R.id.*txtGuess*);
- en: btnGuess = (Button) findViewById(R.id.*btnGuess*);
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: btnGuess = (Button) findViewById(R.id.*btnGuess*);
- en: lblOutput = (TextView) findViewById(R.id.*lblOutput*);
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: lblOutput = (TextView) findViewById(R.id.*lblOutput*);
- en: If everything has been named correctly in the layout, these lines of code should
    connect the variables `txtGuess`, `btnGuess`, and `lblOutput` to the `EditText`,
    `Button`, and `TextView` components in the GUI layout. This is a good time to
    stop and save your project to capture the progress you’ve made so far.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果布局中的所有元素都已经正确命名，那么这些代码行应该将变量`txtGuess`、`btnGuess`和`lblOutput`与GUI布局中的`EditText`、`Button`和`TextView`组件连接起来。此时是停下来并保存项目的好时机，以便捕捉到目前为止所取得的进展。
- en: '![Image](../images/f0088-01.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0088-01.jpg)'
- en: '*Figure 4-15: Android Studio helps us “wire up” the Java code to the GUI resources
    in the layout with helpful drop-down options.*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-15：Android Studio 帮助我们通过有用的下拉选项将 Java 代码与布局中的 GUI 资源“连接”起来。*'
- en: Adding Methods to Check the Guess and Begin a New Game
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加方法来检查猜测并开始新游戏
- en: Now, let’s work on writing the code for the `checkGuess()` function. We can
    begin writing the `checkGuess()` method just below the variable declarations for
    `txtGuess`, `btnGuess`, and `lblOutput` and just above the `onCreate()` method,
    as shown in [Figure 4-16](ch4.xhtml#ch4fig16).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始编写 `checkGuess()` 函数的代码。我们可以在 `txtGuess`、`btnGuess` 和 `lblOutput` 变量声明的下方，以及
    `onCreate()` 方法的上方开始编写 `checkGuess()` 方法，如 [图 4-16](ch4.xhtml#ch4fig16) 所示。
- en: 'First, we need to get the user’s guess from the GUI text field and store it
    in a `String` variable:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从 GUI 文本字段获取用户的猜测并将其存储在一个 `String` 变量中：
- en: public class MainActivity extends AppCompatActivity {
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: public class MainActivity extends AppCompatActivity {
- en: private EditText txtGuess;
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: private EditText txtGuess;
- en: private Button btnGuess;
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: private Button btnGuess;
- en: private TextView lblOutput;
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: private TextView lblOutput;
- en: public void checkGuess() {
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: public void checkGuess() {
- en: String guessText = txtGuess.getText().toString();
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: String guessText = txtGuess.getText().toString();
- en: The code to get the user’s guess from the text field looks almost the same as
    in the desktop version of the app, except for the additional`.toString()` method
    at the end. There is a separate `Text` class in Android and the text that is entered
    into a text field is a `Text` object, so we have to convert that object to a `String`
    object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 获取用户猜测的代码与桌面版应用程序中的几乎相同，唯一的不同是额外的 `.toString()` 方法。Android 中有一个独立的 `Text` 类，文本字段中输入的文本是一个
    `Text` 对象，因此我们需要将该对象转换为 `String` 对象。
- en: '![Image](../images/f0089-01.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0089-01.jpg)'
- en: '*Figure 4-16: Beginning to write the checkGuess() method in Java*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-16：开始编写 Java 中的 checkGuess() 方法*'
- en: 'Fortunately, the rest of the `checkGuess()` method can be copied and pasted
    directly from the Eclipse desktop GUI version of the app from [Chapter 3](ch3.xhtml#ch3),
    with no changes! The complete `checkGuess()` method should look like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`checkGuess()`方法的其余部分可以直接从Eclipse桌面GUI版本的应用程序中复制并粘贴过来，位于[第3章](ch3.xhtml#ch3)，无需任何更改！完整的`checkGuess()`方法应如下所示：
- en: public void checkGuess() {
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: public void checkGuess() {
- en: ➊ String guessText = txtGuess.getText().toString();
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ String guessText = txtGuess.getText().toString();
- en: String message = "";
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: String message = "";
- en: ➋ try {
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ try {
- en: ➌ int guess = Integer.*parseInt*(guessText);
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ int guess = Integer.*parseInt*(guessText);
- en: if (guess < theNumber)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: if (guess < theNumber)
- en: message = guess + " is too low. Try again.";
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: message = guess + " 太小了。再试一次。";
- en: else if (guess > theNumber)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: else if (guess > theNumber)
- en: message = guess + " is too high. Try again.";
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: message = guess + " 太大了。再试一次。";
- en: else {
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: else {
- en: message = guess +
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: message = guess +
- en: '" is correct. You win! Let''s play again!";'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '" 猜对了！你赢了！再玩一次！";'
- en: newGame();
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: newGame();
- en: '}'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ➍ } catch (Exception e) {
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ } catch (Exception e) {
- en: message = "Enter a whole number between 1 and 100.";
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: message = "请输入一个介于1和100之间的整数。";
- en: ➎ } finally {
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ } finally {
- en: lblOutput.setText(message);
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: lblOutput.setText(message);
- en: txtGuess.requestFocus();
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: txtGuess.requestFocus();
- en: txtGuess.selectAll();
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: txtGuess.selectAll();
- en: '}'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: One of the convenient features of Java is that we can reuse code across platforms.
    Just as we used code from the command line game to make the desktop game, we can
    use code from the desktop version in the Android version. Let’s review this code
    to understand how it will work in the Android app.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Java的一个便捷功能是我们可以在不同平台之间重用代码。就像我们将命令行游戏的代码用来制作桌面游戏一样，我们也可以在Android版本中使用桌面版本的代码。让我们回顾一下这些代码，了解它们如何在Android应用中工作。
- en: At ➊, we get the user’s guess from the text field and set up a string for the
    output message. At ➋, we begin a `try-catch-finally` statement to handle user
    input errors or exceptions. Inside the `try` block, at ➌, we parse the integer
    number of the user’s guess from the characters they enter. The rest of the `try`
    block contains the `if-else` statements that test whether the user guessed too
    high or too low, set the appropriate message, and start a new game. Next, the
    `catch` statement ➍ that tells the user to enter a whole number between 1 and
    100\. Then, the `finally` block ➎ sets the text on the `lblOutput` widget to the
    appropriate `message`, returns the cursor to the text field, and highlights the
    text to prepare for the user’s next guess.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们从文本框获取用户的猜测并设置一个字符串作为输出信息。在➋处，我们开始一个`try-catch-finally`语句来处理用户输入错误或异常。在`try`块内，➌处，我们从用户输入的字符中解析出整数作为猜测的数字。`try`块的其余部分包含了`if-else`语句，用来判断用户猜得是太大还是太小，设置相应的消息，并开始一局新游戏。接下来是`catch`语句➍，它会提示用户输入一个介于1和100之间的整数。然后，`finally`块➎会将`lblOutput`控件的文本设置为适当的`message`，并将光标返回到文本框，突出显示文本，为用户的下一次猜测做准备。
- en: 'You may have noticed that there are a couple of items underlined in red: `theNumber`
    and `newGame()`. This is because we haven’t defined them yet in this version of
    our app.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到有几个项目被红色下划线标记：`theNumber`和`newGame()`。这是因为我们在此版本的应用中还没有定义它们。
- en: 'At the top of the `MainActivity` class, below the three GUI widget declarations,
    add a declaration for the secret number, `theNumber`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`类的顶部，在三个GUI控件声明下方，添加一个声明用于存储秘密数字`theNumber`：
- en: public class MainActivity extends AppCompatActivity {
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: public class MainActivity extends AppCompatActivity {
- en: private EditText txtGuess;
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: private EditText txtGuess;
- en: private Button btnGuess;
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: private Button btnGuess;
- en: private TextView lblOutput;
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: private TextView lblOutput;
- en: private int theNumber;
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: private int theNumber;
- en: This is the same code we used in the desktop game, because the Java code to
    create an integer is the same across the command line, desktop, and Android mobile
    versions of the app.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在桌面游戏中使用的相同代码，因为创建整数的Java代码在命令行、桌面和Android移动版本的应用程序中是相同的。
- en: 'The code for the `newGame()` method is also the same as the desktop version.
    Add the `newGame()` method just before the `onCreate()` statement:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`newGame()`方法的代码也与桌面版本相同。在`onCreate()`语句之前添加`newGame()`方法：'
- en: public void newGame() {
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: public void newGame() {
- en: theNumber = (int)(Math.*random*() * 100 + 1);
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: theNumber = (int)(Math.*random*() * 100 + 1);
- en: '}'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@Override'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: protected void onCreate(Bundle savedInstanceState) {
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: protected void onCreate(Bundle savedInstanceState) {
- en: Creating a new game in the Android app is just like doing so in the desktop
    app. We just set `theNumber` to a random integer from 1 to 100, using the `Math.random()`
    function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android应用中创建新游戏和桌面应用一样。我们只需使用`Math.random()`函数将`theNumber`设置为1到100之间的随机整数。
- en: 'We can add a call to `newGame()` inside the `onCreate()` method after the code
    that connects the three GUI components:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在连接这三个GUI组件的代码后，在`onCreate()`方法内添加对`newGame()`的调用：
- en: protected void onCreate(Bundle savedInstanceState) {
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: protected void onCreate(Bundle savedInstanceState) {
- en: super.onCreate(savedInstanceState);
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: super.onCreate(savedInstanceState);
- en: setContentView(R.layout.*activity_main*);
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: setContentView(R.layout.*activity_main*);
- en: txtGuess = (EditText) findViewById(R.id.*txtGuess*);
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: txtGuess = (EditText) findViewById(R.id.*txtGuess*);
- en: btnGuess = (Button) findViewById(R.id.*btnGuess*);
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: btnGuess = (Button) findViewById(R.id.*btnGuess*);
- en: lblOutput = (TextView) findViewById(R.id.*lblOutput*);
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: lblOutput = (TextView) findViewById(R.id.*lblOutput*);
- en: newGame();
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: newGame();
- en: When the game starts up, the program will call the `newGame()` method and pick
    a random number for the user to guess. Now, we just need to handle the button
    click event and learn how to run the app on our own Android device or on the Android
    emulator.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏启动时，程序会调用`newGame()`方法并随机选择一个数字供用户猜测。现在，我们只需要处理按钮点击事件，并学习如何在自己的Android设备或Android模拟器上运行应用程序。
- en: Handling Events in Android
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Android中处理事件
- en: In Eclipse, we were able to add an event listener to the guess button just by
    double-clicking it in the design view. Unfortunately, it’s not that easy in Android
    Studio, because the GUI layout is separate from the source code. Fortunately,
    Android Studio helps us add event listeners by providing *code completion* options,
    similar to the content assist feature in Eclipse.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse中，我们只需在设计视图中双击猜测按钮就能添加事件监听器。不幸的是，在Android Studio中就没有那么简单了，因为GUI布局与源代码是分开的。幸运的是，Android
    Studio通过提供*代码自动完成*选项来帮助我们添加事件监听器，类似于Eclipse中的内容辅助功能。
- en: 'To add a listener for button clicks, begin typing the following partial line
    of code inside the `onCreate()` method on the next line after the call to `newGame()`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要为按钮点击添加监听器，可以在调用`newGame()`后的下一行代码中输入以下部分代码：
- en: txtGuess = (EditText) findViewById(R.id.txtGuess);
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: txtGuess = (EditText) findViewById(R.id.txtGuess);
- en: btnGuess = (Button) findViewById(R.id.*btnGuess*);
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: btnGuess = (Button) findViewById(R.id.*btnGuess*);
- en: lblOutput = (TextView) findViewById(R.id.*lblOutput*);
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: lblOutput = (TextView) findViewById(R.id.*lblOutput*);
- en: newGame();
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: newGame();
- en: btnGuess.setOn
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: btnGuess.setOn
- en: Android Studio’s code completion feature will pop up with a list of code recommendations,
    as shown in [Figure 4-17](ch4.xhtml#ch4fig17). Choose `setOnClickListener()` from
    the list of options and double-click to add it to your program.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio的代码自动完成功能会弹出一个代码推荐列表，如[图4-17](ch4.xhtml#ch4fig17)所示。从选项列表中选择`setOnClickListener()`并双击以将其添加到程序中。
- en: Inside the parentheses for `btnGuess.setOnClickListener()`, type `new` and start
    typing `OnClickListener`. Android Studio’s code completion feature will display
    a list of options, as shown in [Figure 4-18](ch4.xhtml#ch4fig18).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`btnGuess.setOnClickListener()`的括号内，输入`new`并开始输入`OnClickListener`。Android Studio的代码自动完成功能会显示一个选项列表，如[图4-18](ch4.xhtml#ch4fig18)所示。
- en: 'Choose `OnClickListener` from the list of options, and you’ll see Android Studio
    adds a few extra lines of code. Your event listener code for the `btnGuess` button
    should now look like the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从选项列表中选择`OnClickListener`，你会看到Android Studio会添加一些额外的代码行。此时，`btnGuess`按钮的事件监听器代码应如下所示：
- en: btnGuess.setOnClickListener(new View.OnClickListener() {
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: btnGuess.setOnClickListener(new View.OnClickListener() {
- en: '@Override'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public void onClick(View v) {
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: public void onClick(View v) {
- en: '}'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: Look familiar? This is another example of an anonymous inner class. The desktop
    version also had an anonymous inner class, but it was named slightly differently.
    The two will work virtually identically. You may have noticed that Android inserts
    `@Override` in several places. This is called a *compiler directive*, and it tells
    the compiler that you’re implementing your own version of a method in the parent
    class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很熟悉吗？这是另一个匿名内部类的示例。桌面版本也有一个匿名内部类，但它的命名稍有不同。两者的作用几乎完全相同。你可能已经注意到Android在多个地方插入了`@Override`。这叫做*编译器指令*，它告诉编译器你正在实现父类方法的自定义版本。
- en: '![Image](../images/f0092-01.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0092-01.jpg)'
- en: '*Figure 4-17: Android Studio’s code completion feature suggests code as we
    type, similar to Eclipse’s content assist feature.*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-17：Android Studio的代码自动完成功能在我们输入时提供代码建议，类似于Eclipse的内容辅助功能。*'
- en: '![Image](../images/f0092-02.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0092-02.jpg)'
- en: '*Figure 4-18: Use the code completion feature to create a new OnClickListener
    to add to the button btnGuess.*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-18：使用代码自动完成功能创建一个新的OnClickListener并将其添加到按钮btnGuess。*'
- en: When the user clicks the Guess! button, we need to check their guess against
    the secret number. Add `checkGuess();` inside the braces of the `onClick()` method.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击“Guess!”按钮时，我们需要检查他们的猜测是否与秘密数字匹配。在`onClick()`方法的花括号内添加`checkGuess();`。
- en: public void onClick(View v) {
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: public void onClick(View v) {
- en: checkGuess();
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: checkGuess();
- en: '}'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'The guessing game mobile app is now ready for its first run. The fully functional
    code for this first version of the guessing game is shown here. Your version may
    differ slightly, perhaps with a couple of extra methods for handling menu items,
    but because we’re not using the menu, these have been removed for space (see [Chapter
    5](ch5.xhtml#ch5) to learn how to create options menus and settings):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在猜数字游戏的移动应用程序已经准备好进行首次运行。这个版本的猜数字游戏的完整代码如下。你的版本可能略有不同，可能会有几个额外的方法用于处理菜单项，但由于我们没有使用菜单，这些方法已经被删除以节省空间（请参见[第5章](ch5.xhtml#ch5)，学习如何创建选项菜单和设置）：
- en: package com.brysonpayne.guessinggame;
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: package com.brysonpayne.guessinggame;
- en: import android.os.Bundle;
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: import android.os.Bundle;
- en: import android.support.design.widget.FloatingActionButton;
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: import android.support.design.widget.FloatingActionButton;
- en: import android.support.design.widget.Snackbar;
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: import android.support.design.widget.Snackbar;
- en: import android.support.v7.app.AppCompatActivity;
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: import android.support.v7.app.AppCompatActivity;
- en: import android.support.v7.widget.Toolbar;
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: import android.support.v7.widget.Toolbar;
- en: import android.view.View;
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: import android.view.View;
- en: import android.view.Menu;
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: import android.view.Menu;
- en: import android.view.MenuItem;
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: import android.view.MenuItem;
- en: import android.widget.EditText;
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: import android.widget.EditText;
- en: import android.widget.Button;
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: import android.widget.Button;
- en: import android.widget.TextView;
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: import android.widget.TextView;
- en: import org.w3c.dom.Text;
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: import org.w3c.dom.Text;
- en: public class MainActivity extends AppCompatActivity {
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: public class MainActivity extends AppCompatActivity {
- en: private EditText txtGuess;
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: private EditText txtGuess;
- en: private Button btnGuess;
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: private Button btnGuess;
- en: private TextView lblOutput;
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: private TextView lblOutput;
- en: private int theNumber;
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: private int theNumber;
- en: public void checkGuess() {
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: public void checkGuess() {
- en: String guessText = txtGuess.getText().toString();
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: String guessText = txtGuess.getText().toString();
- en: String message = "";
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: String message = "";
- en: try {
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: try {
- en: int guess = Integer.*parseInt*(guessText);
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: int guess = Integer.*parseInt*(guessText);
- en: if (guess < theNumber)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: if (guess < theNumber)
- en: message = guess + " is too low. Try again.";
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: message = guess + " 过低，请再试一次。";
- en: else if (guess > theNumber)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: else if (guess > theNumber)
- en: message = guess + " is too high. Try again.";
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: message = guess + " 过高，请再试一次。";
- en: else {
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: else {
- en: message = guess +
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: message = guess +
- en: '" is correct. You win! Let''s play again!";'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '" 是正确的，你赢了！再玩一次吧！";'
- en: newGame();
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: newGame();
- en: '}'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '} catch (Exception e) {'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (Exception e) {'
- en: message = "Enter a whole number between 1 and 100.";
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: message = "请输入一个1到100之间的整数。";
- en: '} finally {'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '} finally {'
- en: lblOutput.setText(message);
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: lblOutput.setText(message);
- en: txtGuess.requestFocus();
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: txtGuess.requestFocus();
- en: txtGuess.selectAll();
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: txtGuess.selectAll();
- en: '}'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void newGame() {
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: public void newGame() {
- en: theNumber = (int)(Math.*random*() * 100 + 1);
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: theNumber = (int)(Math.*random*() * 100 + 1);
- en: '}'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@Override'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: protected void onCreate(Bundle savedInstanceState) {
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: protected void onCreate(Bundle savedInstanceState) {
- en: super.onCreate(savedInstanceState);
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: super.onCreate(savedInstanceState);
- en: setContentView(R.layout.*activity_main*);
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: setContentView(R.layout.*activity_main*);
- en: txtGuess = (EditText) findViewById(R.id.*txtGuess*);
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: txtGuess = (EditText) findViewById(R.id.*txtGuess*);
- en: btnGuess = (Button) findViewById(R.id.*btnGuess*);
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: btnGuess = (Button) findViewById(R.id.*btnGuess*);
- en: lblOutput = (TextView) findViewById(R.id.*lblOutput*);
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: lblOutput = (TextView) findViewById(R.id.*lblOutput*);
- en: newGame();
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: newGame();
- en: btnGuess.setOnClickListener(new View.OnClickListener() {
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: btnGuess.setOnClickListener(new View.OnClickListener() {
- en: '@Override'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public void onClick(View v) {
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: public void onClick(View v) {
- en: checkGuess();
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: checkGuess();
- en: '}'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: Toolbar toolbar = (Toolbar) findViewById(R.id.*toolbar*);
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Toolbar toolbar = (Toolbar) findViewById(R.id.*toolbar*);
- en: setSupportActionBar(toolbar);
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: setSupportActionBar(toolbar);
- en: '}'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: In the next two sections, you’ll learn how to run the app on the Android emulator
    and on real Android devices.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两节中，你将学习如何在 Android 模拟器和真实的 Android 设备上运行应用程序。
- en: Running the App on the Android Emulator
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Android 模拟器上运行应用程序
- en: Now we have a working version of the Java code to run the app, but we still
    need to test it. Unlike the command line and desktop apps, the mobile app can’t
    run on a PC by itself, because PCs don’t have the Android operating system. To
    run your app for testing, you’ll need either an Android device or an emulator
    that will simulate an Android device on your PC. In this section, we’ll create
    an Android virtual device for testing your apps.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可以运行应用程序的 Java 代码版本，但我们仍然需要测试它。与命令行和桌面应用程序不同，移动应用程序不能单独在 PC 上运行，因为 PC
    没有 Android 操作系统。为了测试你的应用程序，你需要一个 Android 设备或一个可以在你的 PC 上模拟 Android 设备的模拟器。在这一节中，我们将创建一个
    Android 虚拟设备来测试你的应用。
- en: While viewing the *MainActivity.java* file, press the run button or select the
    menu item **Run** ▸ **Run ‘app’**. A pop-up window will ask you to select a *deployment
    target*, which is a device you want to run the app on, as shown in [Figure 4-19](ch4.xhtml#ch4fig19).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看*MainActivity.java*文件时，点击运行按钮或选择菜单项**运行** ▸ **运行‘app’**。弹出窗口会要求你选择一个*部署目标*，即你希望在其上运行应用程序的设备，如[图
    4-19](ch4.xhtml#ch4fig19)所示。
- en: '![Image](../images/f0095-01.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0095-01.jpg)'
- en: '*Figure 4-19: To run an Android app, you must choose a target device—either
    an emulator or an actual device.*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-19：要运行 Android 应用，你必须选择一个目标设备——可以是模拟器或实际设备。*'
- en: Click the **Create New Virtual Device** button to begin configuring a new *Android
    virtual device (AVD)*. Let’s begin by choosing the type of device, as shown in
    [Figure 4-20](ch4.xhtml#ch4fig20). Then click **Next**.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**创建新虚拟设备**按钮以开始配置一个新的*Android 虚拟设备 (AVD)*。首先选择设备类型，如[图 4-20](ch4.xhtml#ch4fig20)所示。然后点击**下一步**。
- en: '![Image](../images/f0095-02.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0095-02.jpg)'
- en: '*Figure 4-20: Choose a device to emulate.*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-20：选择一个设备进行模拟。*'
- en: We’ll select a Nexus 6P to start with, but feel free to test out other devices.
    If you decide to develop your own app for the Google Play Store, you’ll want to
    test it across a variety of screen sizes and device types, so you can try setting
    up several different emulators. But let’s start small for now with just one.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择 Nexus 6P 开始，但也可以自由尝试其他设备。如果你决定为 Google Play 商店开发自己的应用程序，你会希望在各种屏幕尺寸和设备类型上进行测试，因此你可以尝试设置多个不同的模拟器。但现在先从一个设备开始吧。
- en: Next, we need to select the system image, usually either x86 or ARM. We’ll be
    using an ARM image, so click the **Other Images** tab, as shown in [Figure 4-21](ch4.xhtml#ch4fig21).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要选择系统镜像，通常是 x86 或 ARM。我们将使用 ARM 镜像，因此点击**其他镜像**标签，如[图 4-21](ch4.xhtml#ch4fig21)所示。
- en: '![Image](../images/f0096-01.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0096-01.jpg)'
- en: '*Figure 4-21: You can choose either an x86 or ARM emulator; ARM is slower but
    tends to work more consistently on different types of processors.*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-21：你可以选择 x86 或 ARM 模拟器；ARM 较慢，但在不同类型的处理器上通常表现更稳定。*'
- en: If the Android version, API level, or emulator you want is displayed in a gray
    font, click the **Download** link for the version you want.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要的 Android 版本、API 级别或模拟器以灰色字体显示，请点击你想要的版本的**下载**链接。
- en: Click **Next** when you’ve chosen the Android emulator you want. For now, let’s
    use the Nougat API 24 ARM Android 7.0 version with Google APIs. You’ll see a final
    screen asking you to verify your configuration, including any advanced settings
    changes you want to make. Let’s change the name of the AVD, the device you’re
    emulating, to *My Nexus 6P*, as shown in [Figure 4-22](ch4.xhtml#ch4fig22).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**下一步**，当你选择了想要的 Android 模拟器后。现在，我们使用 Nougat API 24 ARM Android 7.0 版本与 Google
    API。你将看到一个最终的屏幕，要求你验证你的配置，包括你想要进行的任何高级设置更改。我们将把你正在模拟的设备的 AVD 名称更改为*我的 Nexus 6P*，如[图
    4-22](ch4.xhtml#ch4fig22)所示。
- en: If you have trouble getting your emulator to run on an older computer or on
    a computer with less than 8 GB of RAM, click **Show Advanced Settings**, scroll
    down to Memory and Storage, and change the RAM amount to **768 MB**.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在较旧的计算机或内存小于 8 GB 的计算机上运行模拟器遇到问题，请点击**显示高级设置**，向下滚动到内存和存储部分，将 RAM 数量更改为**768
    MB**。
- en: '![Image](../images/f0097-01.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0097-01.jpg)'
- en: '*Figure 4-22: Name your new AVD.*'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-22：为你的新 AVD 命名。*'
- en: Click **Finish**, and your new device will be created and saved to disk. Now
    it’s time to start the emulator and try out your device. You should see the Select
    Deployment Target window again, but this time, it shows *My Nexus 6P* as an available
    emulator. Now click **OK**, as shown in [Figure 4-23](ch4.xhtml#ch4fig23).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**完成**，你的新设备将被创建并保存到磁盘。现在是时候启动模拟器并尝试你的设备了。你应该会再次看到“选择部署目标”窗口，但这次它会显示*我的 Nexus
    6P*作为一个可用的模拟器。现在点击**确定**，如[图 4-23](ch4.xhtml#ch4fig23)所示。
- en: '![Image](../images/f0097-02.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0097-02.jpg)'
- en: '*Figure 4-23: Choose the emulator you just created as your deployment target.*'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-23：选择你刚刚创建的模拟器作为部署目标。*'
- en: After a few moments, you’ll see the message “Starting AVD,” followed by an emulator
    window that looks like an Android startup screen, as shown in [Figure 4-24](ch4.xhtml#ch4fig24).
    This could take *several* minutes the first time you run the emulator. When the
    emulator starts up, you might see a lock screen.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，你将看到“正在启动 AVD”的消息，随后是一个模拟器窗口，显示类似 Android 启动屏幕的界面，如[图 4-24](ch4.xhtml#ch4fig24)所示。第一次运行模拟器时，这可能需要*几分钟*。当模拟器启动时，你可能会看到锁屏界面。
- en: '![Image](../images/f0098-01.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0098-01.jpg)'
- en: '*Figure 4-24: The Android emulator booting up (left); the Android virtual device’s
    home screen (right)*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-24：Android 模拟器启动画面（左）；Android 虚拟设备的主屏幕（右）*'
- en: If your emulator shows a lock screen, click the lock at the bottom of the screen
    and drag it up to unlock the virtual device, similar to swiping the lock upward
    on an actual Android phone. You might see a welcome screen or two, but feel free
    to click out of those until you reach the home screen, which is shown in [Figure
    4-24](ch4.xhtml#ch4fig24).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的模拟器显示锁屏，点击屏幕底部的锁图标并向上拖动解锁虚拟设备，类似于在实际 Android 手机上向上滑动解锁。你可能会看到一个或两个欢迎界面，但可以随意点击跳过，直到你到达主屏幕，如[图
    4-24](ch4.xhtml#ch4fig24)所示。
- en: Now, go back to Android Studio and press the run button again. This time, you’ll
    see your AVD in the Select Deployment Target dialog (see [Figure 4-25](ch4.xhtml#ch4fig25)).
    Choose your device and click **OK**.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到 Android Studio，再次按下运行按钮。这次，你会在“选择部署目标”对话框中看到你的 AVD（请参见[图 4-25](ch4.xhtml#ch4fig25)）。选择你的设备并点击**确定**。
- en: '![Image](../images/f0098-02.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0098-02.jpg)'
- en: '*Figure 4-25: The emulator appears in the list of connected devices when running.*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-25：运行时，模拟器会出现在连接设备的列表中。*'
- en: The project will build one more time, and then it will transfer the executable
    version of the app to the emulator. (You may be asked to update your Android SDK
    Tools the first time you run the emulator.) After a few minutes, you’ll see your
    guessing game app running on the emulator!
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 项目会再构建一次，然后将应用的可执行版本传输到模拟器中。（第一次运行模拟器时，可能会提示你更新 Android SDK 工具。）几分钟后，你就会看到你的猜测游戏应用在模拟器上运行了！
- en: We’ve coded the full app, so you should be able to play the game right away
    on your emulator. Take a look at [Figure 4-26](ch4.xhtml#ch4fig26) to see what
    a round of the game might look like on the app.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了整个应用的编码，因此你应该能立刻在模拟器上玩这个游戏。看看[图 4-26](ch4.xhtml#ch4fig26)，看看游戏的一轮在应用中会是什么样子。
- en: '![Image](../images/f0099-01.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0099-01.jpg)'
- en: '*Figure 4-26: The guessing game app running on the emulator screen (left),
    after one guess (center), and after a winning guess (right).*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-26：猜测游戏应用在模拟器屏幕上运行（左），一次猜测后（中），以及猜对后的画面（右）。*'
- en: It works just like the desktop app, but on an Android emulator. Use your keyboard
    to type a guess and your mouse to click the Guess! button. There are a couple
    more things we’ll do to improve the user experience, just like we did with the
    GUI desktop app, but our Android mobile app is fully functional!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 它的运行方式与桌面应用相同，不过是在 Android 模拟器上。使用键盘输入猜测，使用鼠标点击“猜测！”按钮。接下来，我们还会做一些改进，提升用户体验，就像我们在
    GUI 桌面应用中做的那样，不过我们的 Android 移动应用已经完全功能齐全了！
- en: Before we improve the UX, we’ll cover how to run the app on a real Android device.
    For now, leave your Android emulator open. You can minimize it when you’re not
    using it, but leave it running in the background while programming to avoid the
    long startup time.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们改善用户体验之前，我们将介绍如何在真实的 Android 设备上运行应用程序。现在，保持 Android 模拟器开启。当你不使用时可以将其最小化，但在编程时请保持它在后台运行，以避免长时间的启动过程。
- en: '**NOTE**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you don’t have an Android device, you can skip to “[Improving the UX](ch3.xhtml#toc_lev55)”
    on [page 102](ch4.xhtml#page_102).*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你没有 Android 设备，可以跳到[第 102 页](ch4.xhtml#page_102)的“[改善用户体验](ch3.xhtml#toc_lev55)”部分。*'
- en: Running the App on a Real Android Device
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在真实的 Android 设备上运行应用程序
- en: Running the app on a real Android device can take some time and preparation,
    but if you have a USB cable to connect your device to your computer, you’ll be
    up and running quickly.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实的 Android 设备上运行应用程序可能需要一些时间和准备，但如果你有 USB 数据线将设备连接到电脑，你很快就能开始运行了。
- en: '*Preparing Your Device*'
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*准备你的设备*'
- en: Before you can deploy your own apps to your Android device, you have to enable
    Developer mode on the device. You’ll also need to change a couple of settings
    to allow you to develop and debug apps.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将自己的应用部署到 Android 设备之前，必须先启用设备的开发者模式。你还需要更改几个设置，以允许你开发和调试应用。
- en: On your Android device, tap **Settings** and then scroll to the bottom of the
    Settings menu to find the About tablet, About phone, or About device section.
    At the bottom of the About screen, you’ll find the Build number entry. Tap the
    build number at least seven times to enable the secret Developer mode. Developer
    mode allows you to test the apps you develop on your own device. [Figure 4-27](ch4.xhtml#ch4fig27)
    shows the Settings menu (left) and the About menu (center) with Developer mode
    unlocked.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 Android 设备上，点击**设置**，然后滚动到设置菜单的底部，找到“关于平板电脑”、“关于手机”或“关于设备”部分。在关于屏幕的底部，您会看到“版本号”条目。点击版本号至少七次以启用隐藏的开发者模式。开发者模式允许您在自己的设备上测试开发的应用程序。[图
    4-27](ch4.xhtml#ch4fig27)展示了设置菜单（左）和关于菜单（中），以及解锁后的开发者模式。
- en: After you’ve unlocked Developer mode, tap the back arrow in the upper-left corner
    of the About screen and open **Settings** ▸ **Developer options**. Make sure the
    Developer options are turned **On**, as shown in [Figure 4-27](ch4.xhtml#ch4fig27)
    (right). You should also turn on USB debugging.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 解锁开发者模式后，点击关于屏幕左上角的返回箭头，打开**设置** ▸ **开发者选项**。确保开发者选项已**开启**，如[图 4-27](ch4.xhtml#ch4fig27)（右）所示。您还需要开启
    USB 调试功能。
- en: '![Image](../images/f0100-01.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0100-01.jpg)'
- en: '*Figure 4-27: The Settings menu on an Android Nexus 7 tablet (left), the About
    menu (center), and the Developer options (right).*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-27：Android Nexus 7 平板电脑上的设置菜单（左）、关于菜单（中）和开发者选项（右）。*'
- en: Now you’re ready to connect an Android phone, tablet, or other device to your
    computer and run your app.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您准备好将 Android 手机、平板电脑或其他设备连接到计算机，并在其上运行您的应用程序。
- en: '*Connecting Your Device*'
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*连接您的设备*'
- en: To connect an Android device to your computer, you’ll need a USB cable, preferably
    the one that came with your phone or tablet. It should be a micro-USB cable, and
    it is often supplied as part of the charger for your device. Note that not all
    charger cables are fully functional USB cables—if your cable doesn’t work after
    you complete the following steps, try a different one.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Android 设备连接到计算机，您需要一根 USB 数据线，最好是随手机或平板电脑附带的那根。它应该是 micro-USB 数据线，通常与设备的充电器一起提供。请注意，并非所有充电器数据线都具备完整的
    USB 功能——如果按照以下步骤操作后您的数据线无法使用，请尝试换一根。
- en: Connect your device to your computer using the USB cable. After you plug in,
    the screen on your phone or tablet will show a window like the one in [Figure
    4-28](ch4.xhtml#ch4fig28) asking whether you want to allow USB debugging from
    the computer you just attached to. Tap **OK**. You can select the checkbox beside
    **Always allow from this computer** to prevent the pop-up next time you connect
    by USB to the same computer.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 USB 数据线将设备连接到计算机。插入后，您的手机或平板电脑屏幕上会显示一个类似于[图 4-28](ch4.xhtml#ch4fig28)的窗口，询问您是否允许来自刚连接的计算机的
    USB 调试。点击**确定**。您可以选择勾选**始终允许来自此计算机的连接**，这样下次连接同一台计算机时，就不会再弹出此窗口。
- en: '![Image](../images/f0101-01.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0101-01.jpg)'
- en: '*Figure 4-28: When you connect your Android device to your computer for the
    first time, it will ask whether you want to allow USB debugging.*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-28：第一次将 Android 设备连接到计算机时，系统会询问您是否允许 USB 调试。*'
- en: Allowing USB debugging enables a couple of things. First, we’ll be able to transfer
    the apps we program right to the Android device by transferring an *Android package
    file (APK)*. This is usually much faster than running apps on an emulator, and
    it’s a better way to test how the apps will behave on a real device. Also, we’ll
    be able to debug apps using the USB connection, meaning we’ll get information
    back from the Android device to help us debug. This information will include errors
    and other log entries that we’ll be able to read in a console-like application
    (called *logcat* in Android Studio). This is similar to the console output we
    used to find bugs in our command line and desktop GUI Java apps.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 允许 USB 调试会启用几个功能。首先，我们将能够通过传输*Android 包文件（APK）*，直接将我们编写的应用程序传输到 Android 设备。这通常比在模拟器上运行应用程序要快得多，而且是一种更好的方式来测试应用程序在真实设备上的表现。此外，我们还可以通过
    USB 连接调试应用程序，这意味着我们将从 Android 设备获得信息，以帮助我们进行调试。这些信息将包括错误和其他日志条目，我们可以在类似控制台的应用程序（在
    Android Studio 中称为*logcat*）中查看。这与我们以前在命令行和桌面 GUI Java 应用程序中查找错误时使用的控制台输出类似。
- en: Now that you’ve connected a real Android device to your computer, let’s see
    how to run the guessing game app on it!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已将真正的 Android 设备连接到计算机，让我们来看一下如何在其上运行猜数字游戏应用程序！
- en: '*Running the App on Your Device*'
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*在设备上运行应用程序*'
- en: 'Now we’re ready to try the app on the Android device. In Android Studio, press
    the run button or go to **Run** ▸ **Run ‘app’**. This time, the Select Deployment
    Target window will show *two* connected devices to choose from, as shown in [Figure
    4-29](ch4.xhtml#ch4fig29): your emulator (My Nexus 6P) and your real Android device.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备在 Android 设备上尝试该应用。在 Android Studio 中，按下运行按钮或转到**运行** ▸ **运行 ‘app’**。这时，选择部署目标窗口将显示
    *两个* 连接的设备供选择，如[图 4-29](ch4.xhtml#ch4fig29)所示：你的模拟器（My Nexus 6P）和你的真实 Android
    设备。
- en: '![Image](../images/f0102-01.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0102-01.jpg)'
- en: '*Figure 4-29: If you’ve unlocked Developer mode, enabled USB debugging, and
    connected your device successfully, you should be able to select your Android
    device to run your app.*'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-29：如果你已解锁开发者模式、启用 USB 调试并成功连接了设备，你应该能选择 Android 设备来运行应用。*'
- en: Choose your real Android device this time and click **OK**. Android Studio may
    take a moment to build the application, but once it transfers the APK file to
    your device, you’ll see the guessing game app open right up on your tablet or
    phone. Play a round or two to verify that it works just as it did on the emulator
    (maybe even better, or at least faster). Very cool!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这次选择你的真实 Android 设备并点击 **OK**。Android Studio 可能需要片刻来构建应用，但一旦将 APK 文件传输到设备，你将看到猜谜游戏应用在平板或手机上自动打开。玩几局以验证它的运行效果是否与模拟器上一样（甚至更好，或者至少更快）。真是太酷了！
- en: 'You may notice one important difference right away: the bottom part of the
    screen is covered by the numeric keypad, as shown in [Figure 4-30](ch4.xhtml#ch4fig30).'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能立刻注意到一个重要的区别：屏幕的底部被数字键盘遮挡，如[图 4-30](ch4.xhtml#ch4fig30)所示。
- en: When we placed the text field (`EditText`) for the user’s guess, we chose a
    Number text field for our input so the numeric keypad would show up. But since
    the emulator runs on a computer, which has its own keyboard, you probably didn’t
    see this when you ran your app earlier.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为用户的猜测放置文本框（`EditText`）时，选择了一个数字输入框，这样数字键盘就会显示出来。但由于模拟器运行在计算机上，而计算机有自己的键盘，因此你在之前运行应用时可能没有看到这一点。
- en: Now that we’re able to run Android apps on an Android phone, tablet, or other
    device, let’s make a few final improvements to the user experience for the guessing
    game app.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经能够在 Android 手机、平板或其他设备上运行 Android 应用了，让我们为猜谜游戏应用做一些最后的用户体验改进。
- en: '![Image](../images/f0102-02.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0102-02.jpg)'
- en: '*Figure 4-30: The app runs on your own Android device and shows the numeric
    keypad by default.*'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-30：应用在你的 Android 设备上运行，默认显示数字键盘。*'
- en: Improving the UX
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改善用户体验
- en: The guessing game app works beautifully on both the Android emulator and on
    real Android devices, but there are a few UX items we can improve upon. First,
    we’ll center the user’s guess in the Number text field. Second, we’ll learn how
    to treat the ENTER key just like the Guess! button to make the app more intuitive
    to the user.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 猜谜游戏应用在 Android 模拟器和真实 Android 设备上都运行得非常顺利，但我们可以改进一些用户体验方面的细节。首先，我们将在数字输入框中居中显示用户的猜测。其次，我们将学习如何像处理“猜测！”按钮一样处理
    ENTER 键，使应用对用户更加直观。
- en: '*Centering the User’s Guess in the Text Field*'
  id: totrans-307
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*在文本框中居中显示用户的猜测*'
- en: In Android Studio, open the *content_main.xml* layout file again. Select the
    text field, called `txtGuess`, by clicking it in the design preview. Under the
    Properties pane, find **textAlignment**. The `textAlignment` property in Android
    is similar to the `horizontalAlignment` property in the desktop GUI—it allows
    us to change the alignment of the text the user enters.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中，再次打开 *content_main.xml* 布局文件。通过在设计预览中点击选中名为 `txtGuess` 的文本框。在属性面板中找到
    **textAlignment**。Android 中的 `textAlignment` 属性类似于桌面 GUI 中的 `horizontalAlignment`
    属性——它允许我们改变用户输入文本的对齐方式。
- en: Click the center text alignment option, the icon that looks like centered text.
    If you want to test it in the design preview without running the app, scroll to
    find the `text` property and enter a value of `50`. The number should appear centered
    in the text field in the design preview pane. Be sure to delete the test value
    if you don’t want it to show up in the actual app.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 点击居中文本对齐选项，图标看起来像是居中的文本。如果你想在设计预览中测试它，而不运行应用，滚动查找 `text` 属性并输入值 `50`。数字应该在设计预览面板中的文本框里居中显示。如果你不希望它在实际应用中显示，记得删除测试值。
- en: '*Adding a Listener for the Enter Key*'
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*为 ENTER 键添加监听器*'
- en: Let’s set up an event listener to handle the ENTER key the same way we handled
    a click on the Guess! button, with a call to `checkGuess()`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个事件监听器，像处理“猜测！”按钮点击一样处理 ENTER 键，调用 `checkGuess()`。
- en: 'Go back to the *MainActivity.java* source code file, scroll down to the `onCreate()`
    method, and find where we added an `onClickListener` to the button `btnGuess`.
    (You may need to *expand* the event listener code by clicking the + in the left
    margin beside `btnGuess.setOnClickListener()` to make it look like the code shown
    here.) Right below that, we can add an event listener to the text field `txtGuess`
    to handle action events such as pressing the ENTER key. The following code adds
    a listener to `txtGuess`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 *MainActivity.java* 源代码文件，向下滚动到 `onCreate()` 方法，找到我们为按钮 `btnGuess` 添加的 `onClickListener`。
    （你可能需要通过点击 `btnGuess.setOnClickListener()` 左边边距处的 + 来 *展开* 事件监听器代码，使其显示出此处所示的代码。）在其下方，我们可以为文本字段
    `txtGuess` 添加一个事件监听器，以处理按下 ENTER 键等操作事件。以下代码为 `txtGuess` 添加了一个监听器：
- en: btnGuess.setOnClickListener(new View.OnClickListener() {
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: btnGuess.setOnClickListener(new View.OnClickListener() {
- en: public void onClick(View v) {
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: public void onClick(View v) {
- en: checkGuess();
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: checkGuess();
- en: '}'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: txtGuess.setOnEditorActionListener(new TextView.OnEditorActionListener() {
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: txtGuess.setOnEditorActionListener(new TextView.OnEditorActionListener() {
- en: '@Override'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
- en: checkGuess();
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: checkGuess();
- en: ➊ return true;
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ return true;
- en: '}'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: The *editor action* we’re listening for is when the user presses the ENTER key
    while typing in the text field. When that event happens, we want to check the
    guess the user entered.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在监听的 *编辑器动作* 是当用户在文本字段中输入时按下 ENTER 键。当该事件发生时，我们希望检查用户输入的猜测。
- en: We changed the `return` statement to return a value of `true` ➊ because we want
    to keep the keyboard on the screen so the user can enter their next guess. The
    `return` statement tells the text field whether the event handler code we’ve provided
    completed the event. By returning the value `true`, we’ve told Android that we’ve
    done everything that needs to be done to check the user’s guess. If we returned
    `false` here instead, Android would finish processing the ENTER key by removing
    the number keypad from the screen—as it does by default when you finish typing
    in a form on a web page. We don’t want the keypad to disappear after every guess,
    so we return `true`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `return` 语句更改为返回 `true` ➊，因为我们希望保持键盘在屏幕上，以便用户可以输入下一个猜测。`return` 语句告诉文本字段，我们提供的事件处理代码是否完成了事件的处理。通过返回
    `true`，我们告诉 Android，已经完成了检查用户猜测所需的所有工作。如果我们在这里返回 `false`，Android 会通过移除数字键盘来结束
    ENTER 键的处理——这就像你在网页表单输入完成后，默认的行为一样。我们不希望每次猜测后键盘消失，因此我们返回 `true`。
- en: '*Adding One More Finishing Touch*'
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*再添加一个细节*'
- en: Run the app a few times to test it, and you’ll see the ENTER key allows you
    to enter and check guesses quickly and efficiently. You’ll also see your guesses
    centered nicely in the text field. However, when you win, depending on the API
    version, screen size, or density of your device, you may see an alignment problem
    like the one shown in [Figure 4-31](ch4.xhtml#ch4fig31).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 多次运行应用程序进行测试，你会发现 ENTER 键可以快速高效地输入和检查猜测。你还会看到你的猜测在文本字段中居中显示。然而，当你获胜时，根据 API
    版本、屏幕大小或设备密度的不同，你可能会看到类似 [图4-31](ch4.xhtml#ch4fig31) 所示的对齐问题。
- en: The problem is that the `TextView` named `lblOutput` resizes to show the longer
    “You win! Let’s play again!” text, and some older APIs may not center this correctly.
    You can prevent this by expanding `lblOutput` to the full width of the screen
    in the design preview and by changing the `textAlignment` property to `center`.
    Now you have a complete guessing game app to play on your device and to share
    with friends! The final version 1.0 of the app is shown running on a Nexus 7,
    with Font settings at Large, in [Figure 4-32](ch4.xhtml#ch4fig32).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于名为 `lblOutput` 的 `TextView` 会根据较长的文本 “You win! Let’s play again!” 调整大小，一些较旧的
    API 可能无法正确居中显示。你可以通过在设计预览中将 `lblOutput` 扩展到屏幕的全宽，并将 `textAlignment` 属性改为 `center`
    来防止此问题。现在，你已经拥有了一个完整的猜数字游戏应用，可以在你的设备上玩，并与朋友分享！应用程序的最终版本 1.0 显示在 Nexus 7 上，字体设置为大号，见
    [图4-32](ch4.xhtml#ch4fig32)。
- en: '![Image](../images/f0104-01.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0104-01.jpg)'
- en: '*Figure 4-31: If you notice misaligned text, you may need to expand and center
    the TextView `lblOutput`.*'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-31：如果你发现文本对齐不正确，可能需要展开并居中 `lblOutput` 的 TextView。*'
- en: '![Image](../images/f0104-02.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0104-02.jpg)'
- en: '*Figure 4-32: Your finished version 1.0 of the mobile app, with all the user
    experience improvements in place*'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-32：你的移动应用程序版本 1.0，已完成所有用户体验改进*'
- en: Wow! You’ve gone from a simple, text-based, command line number-guessing program,
    to a sophisticated GUI desktop game, to a fully featured mobile app that runs
    on real Android devices. Are you starting to see the power and flexibility of
    Java? And in [Chapter 5](ch5.xhtml#ch5), we’ll make the app even more professional
    with a settings menu and the ability to store user preferences!
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！你已经从一个简单的基于文本的命令行数字猜谜程序，发展到了一个复杂的GUI桌面游戏，再到一个可以在真实Android设备上运行的功能齐全的移动应用程序。你是否开始看到Java的强大与灵活性了？在[第5章](ch5.xhtml#ch5)，我们将通过添加设置菜单和存储用户偏好的功能，使应用更加专业！
- en: What You Learned
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: 'You’ve seen that much of the Java code used in a text-based and GUI desktop
    program can build the foundation of a modern mobile app, thanks to Java’s reusability
    across multiple platforms. We have also picked up several new mobile-specific
    skills in this chapter:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，许多在文本和GUI桌面程序中使用的Java代码可以为现代移动应用打下基础，这得益于Java跨多个平台的可重用性。在本章中，我们还掌握了一些新的、特定于移动的技能：
- en: • Starting a new Android Studio app project
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: • 启动一个新的Android Studio应用项目
- en: • Building the GUI layout in design view in Android Studio, including changing
    the properties of various elements in the Properties pane
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: • 在Android Studio中使用设计视图构建GUI布局，包括更改属性面板中各种元素的属性
- en: • Naming GUI components in a layout for easy use in Java code
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: • 为方便在Java代码中使用，为GUI组件命名
- en: • Connecting the Android GUI layout elements to your Java code
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: • 将Android GUI布局元素连接到你的Java代码
- en: • Adding your own methods, such as `checkGuess()` and `newGame()`, to an Android
    app
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: • 向Android应用中添加你自己的方法，比如`checkGuess()`和`newGame()`方法
- en: • Reusing Java code in an Android app
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: • 在Android应用中重用Java代码
- en: • Handling events in Android, including button clicks and keyboard/editor actions
    such as pressing the ENTER key
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: • 在Android中处理事件，包括按钮点击和按键/编辑器操作，比如按下ENTER键
- en: • Testing apps by running them on an Android virtual device using the Android
    emulator
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: • 通过在Android模拟器上运行应用程序来测试它们
- en: • Running an app on an Android phone, tablet, or other device by enabling Developer
    mode and USB debugging
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: • 在Android手机、平板电脑或其他设备上运行应用，通过启用开发者模式和USB调试
- en: • Improving the user experience by changing widget properties and adding user-friendly
    finishing touches
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: • 通过更改小部件属性并添加用户友好的细节来改善用户体验
- en: Programming Challenges
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程挑战
- en: Try these programming challenge exercises to review and practice what you’ve
    learned and to expand your programming skills by trying something new. If you
    get stuck, visit *[https://www.nostarch.com/learnjava/](https://www.nostarch.com/learnjava/)*
    to download sample solutions.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些编程挑战练习，复习和实践你所学的内容，并通过尝试新事物来拓展你的编程技能。如果你卡住了，访问*[https://www.nostarch.com/learnjava/](https://www.nostarch.com/learnjava/)*下载示例解决方案。
- en: '*#1: “Toast”-ing to the Number of Tries*'
  id: totrans-349
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*#1: “吐司”——为尝试次数干杯*'
- en: In the programming challenges for
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程挑战中
- en: '[Chapter 3](ch3.xhtml#ch3), you changed the winning message to tell the user
    how many tries they took to win:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](ch3.xhtml#ch3)，你已经更改了获胜消息，告诉用户他们获胜时尝试了多少次：'
- en: 62 is correct! You win after 7 tries!
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 62是正确的！你在第7次尝试后获胜！
- en: Let’s do something similar for the Android version, with a twist—or, should
    I say, a *Toast*? A Toast is an Android widget for creating pop-up message windows.
    Toast pop-ups are a convenient way to show a quick notice, such as an error or
    a note telling the user they’ve won the game. See the Toast message near the bottom
    of the screen in [Figure 4-33](ch4.xhtml#ch4fig33).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为Android版本做一些类似的事情，不过这次加点“花样”——或者，我该说是一个*吐司*？吐司是一个Android小部件，用于创建弹出消息窗口。吐司弹出窗口是一种方便的方式，用来显示快速通知，比如错误提示或告知用户他们赢得了游戏。请参见[图
    4-33](ch4.xhtml#ch4fig33)中屏幕底部附近的吐司消息。
- en: '![Image](../images/f0106-01.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0106-01.jpg)'
- en: '*Figure 4-33: A Toast message pops up on the screen to alert the user to important
    information.*'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-33: 一个吐司消息会弹出在屏幕上，提醒用户重要信息。*'
- en: 'You can create a Toast message popup with the `Toast.makeText()` method. Here’s
    a sample to help you add a Toast pop-up to the `else` statement for winning the
    game:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`Toast.makeText()`方法创建一个吐司消息弹出窗口。这里有一个示例，帮助你将吐司弹出消息添加到`else`语句中，用于获胜提示：
- en: else {
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: else {
- en: message = guess +
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: message = guess +
- en: '" is correct. You win after " + numberOfTries + " tries!";'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '"是正确的。你在" + numberOfTries + "次尝试后获胜！";'
- en: Toast.*makeText*(MainActivity.this, message,
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: Toast.*makeText*(MainActivity.this, message,
- en: Toast.*LENGTH_LONG*).show();
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Toast.*LENGTH_LONG*).show();
- en: newGame();
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: newGame();
- en: '}'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The Toast message in this code will pop up over the `MainActivity` (our guessing
    game), displaying the `String` `message` for a few seconds thanks to `Toast.LENGTH_LONG`.
    There’s also a `Toast.LENGTH_SHORT`, but it pops up and disappears so quickly
    that it can be hard to read. The `.show()` method at the end does the important
    part, showing the Toast on the screen.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中的 Toast 消息将在`MainActivity`（我们的猜谜游戏）上方弹出，显示`String`类型的`message`，持续几秒钟，得益于`Toast.LENGTH_LONG`。还有一个`Toast.LENGTH_SHORT`，但是它出现和消失得非常快，可能难以阅读。结尾的`.show()`方法完成了关键的部分，显示了
    Toast 消息。
- en: As with the GUI desktop version, to accomplish this task, you’ll need to create
    a new variable at the top of your class (like `int numberOfTries = 0;`), add to
    the number of tries every time the `checkGuess()` method runs successfully, and
    change the output `message` to display the number of tries to the user when they
    win, both in a Toast pop-up and in the `lblOutput` field. After counting the number
    of tries, add the features you learned in [Chapter 3](ch3.xhtml#ch3) for running
    out of tries or losing. Give the user seven tries and tell them how many tries
    are left after each guess.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 与桌面版 GUI 相似，为了完成这个任务，你需要在类的顶部创建一个新的变量（例如`int numberOfTries = 0;`），每次`checkGuess()`方法成功运行时都增加尝试次数，并修改输出`message`，在用户获胜时通过
    Toast 弹窗和`lblOutput`字段显示尝试次数。在计算完尝试次数后，添加你在[第 3 章](ch3.xhtml#ch3)中学到的处理用尽尝试次数或失败的功能。给用户七次尝试，并在每次猜测后告诉他们剩余的次数。
- en: '*#2: Adding Visual Appeal*'
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*#2: 增加视觉吸引力*'
- en: Explore some of the more aesthetic properties of the GUI components in Android
    Studio, including background colors, foreground colors, fonts, `textSize`, and
    more. Move components in your guessing game app around to make the interface more
    visually appealing. For an example of one way you could customize your game, see
    [Figure 4-34](ch4.xhtml#ch4fig34).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 探索 Android Studio 中 GUI 组件的一些美学属性，包括背景颜色、前景颜色、字体、`textSize`等。将你的猜谜游戏应用中的组件移动，令界面更加美观。你可以参考[图
    4-34](ch4.xhtml#ch4fig34)来定制游戏。
- en: You can even add a custom background image (add an image file to the *app* ▸
    *res* ▸ *drawable* folder and then select it as the `background` property for
    your layout or for a button or other component). Play with various settings—you
    can always undo by pressing CTRL-Z!
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以添加自定义的背景图片（将图片文件添加到*app* ▸ *res* ▸ *drawable* 文件夹中，然后将其作为布局、按钮或其他组件的`background`属性）。尽情尝试各种设置——你可以随时按
    CTRL-Z 撤销！
- en: '![Image](../images/f0107-01.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0107-01.jpg)'
- en: '*Figure 4-34: Changing the colors, fonts, text size, and arrangement of the
    components in your app can make it stand out!*'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-34: 更改应用中组件的颜色、字体、文字大小和排列方式可以让它更加突出！*'
- en: '*#3: Creating a MadLibs Mobile App*'
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*#3: 创建一个 MadLibs 移动应用*'
- en: 'Look back at the *MadLibGUI.java* program you built in [Chapter 3](ch3.xhtml#ch3)
    (Programming Challenge #3 on [page 74](ch3.xhtml#page_74)). Now create a mobile
    version of your MadLibs app that prompts the user for several words in a GUI with
    labels and text fields, such as `txtBigAnimal`, `txtPastTenseVerb`, `txtSmallContainer`,
    and `txtFood`. Add a button that the user can press to generate their own MadLibs-style
    story. It may be a nice touch to include some default or initial text in each
    text field, just to give the user an idea of how the program works.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾你在[第 3 章](ch3.xhtml#ch3)（[第 74 页](ch3.xhtml#page_74)的编程挑战#3）中构建的*MadLibGUI.java*程序。现在创建一个移动版本的
    MadLibs 应用，提示用户输入多个单词，界面中包含标签和文本框，如`txtBigAnimal`、`txtPastTenseVerb`、`txtSmallContainer`和`txtFood`。添加一个按钮，用户可以按下它来生成自己的
    MadLibs 风格故事。可以在每个文本框中包含一些默认或初始文本，以便给用户展示程序如何工作。
- en: When the user clicks the button, the program should display the completed MadLibs
    story in a `TextView` or in an `EditText` widget—the `EditText` makes it possible
    to copy and paste the user’s funny story if they wish to share it. Play with the
    colors, fonts, and layout until you’re happy with the result and then share your
    creation with a friend!
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击按钮时，程序应在`TextView`或`EditText`小部件中显示完成的 MadLibs 故事——`EditText`使得用户可以复制并粘贴他们的搞笑故事，若他们想与他人分享。调整颜色、字体和布局，直到你对结果满意，然后与朋友分享你的创作！
- en: '**HINT**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '*To make a TextView or EditText show multiple lines, use the escape character
    sequence \n to insert a new line in the String message you display using the setText()
    method, like so: "Once upon a time... \n There was a buffalo princess \n who lived
    in a soup can." This quote will span three lines, separated by new lines wherever
    the \n escape sequence appears.*'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '*要使 TextView 或 EditText 显示多行，可以使用转义字符序列 \n 在通过 setText() 方法显示的 String 消息中插入新行，例如：“从前…
    \n 有一位水牛公主 \n 她住在一个汤罐里。” 这个引用将跨越三行，\n 转义序列出现的地方会插入换行符。*'
