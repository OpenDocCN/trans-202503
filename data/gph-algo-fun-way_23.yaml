- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">18</samp> <samp class="SANS_Dogma_OT_Bold_B_11">TOURS
    THROUGH GRAPHS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">18</samp> <samp class="SANS_Dogma_OT_Bold_B_11">图中的旅游路线</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'The problem of designing an optimal sightseeing tour lends itself perfectly
    to a graph formulation. Depending on our travel preferences, we might want to
    visit each of a set of major landmarks exactly once, minimize the total distance
    we travel, or visit every shop-lined street in our destination city. Each of these
    formulations corresponds to a classic graph problem: planning paths through a
    graph.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个最佳观光旅游的难题非常适合用图形来表示。根据我们的旅行偏好，我们可能希望精确地访问一组主要景点一次，最小化总行程，或者访问目的地城市中的每一条街道。每一种情况都对应着一个经典的图问题：规划图中的路径。
- en: In this chapter, we consider several variations of this core problem. *Hamiltonian
    paths* visit each node exactly once and can help us plan trips where we want to
    visit a discrete set of sites. Solving the *traveling salesperson problem* allows
    us to visit every site while minimizing the total distance we need to walk. Finally,
    *Eulerian paths* traverse each edge only once and can help us plan trips where
    we want to wander down each street without repetition.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将考虑这个核心问题的几种变体。*哈密尔顿路径*是指每个节点仅访问一次，可以帮助我们规划那些我们希望访问离散景点的旅行。解决*旅行商问题*则可以帮助我们访问每个景点，同时最小化总行程距离。最后，*欧拉路径*仅遍历每条边一次，可以帮助我们规划那些我们希望在不重复的情况下遍历每条街道的旅行。
- en: These types of path-planning problems have a host of real-world applications
    beyond vacation planning, such as solving logistical problems within the shipping
    industry. Unfortunately, many also come with significant computational challenges.
    While the problem of computing Eulerian paths has an efficient computational solution,
    both Hamiltonian paths and the traveling salesperson problem are NP-hard. We build
    upon the techniques from the previous chapters to create exhaustive algorithms
    for solving these problems.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路径规划问题不仅限于度假规划，它们在现实世界中有广泛的应用，如解决航运行业中的物流问题。不幸的是，许多问题也伴随着显著的计算挑战。虽然计算欧拉路径问题有高效的计算解法，但哈密尔顿路径和旅行商问题都是NP难题。我们将基于前几章的技术，创建穷举算法来解决这些问题。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Hamiltonian Paths and Cycles</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">哈密尔顿路径与循环</samp>
- en: A *Hamiltonian path*, named after the mathematician William Hamilton, is a path
    through a graph that visits each node exactly once. We can view the problem in
    terms of itinerary planning for a thorough yet easily bored tourist. The tourist
    balances two competing goals. First, they need to ensure they visit every attraction
    in the city. They do not want to miss a single one. Second, they want to avoid
    the annoyance of seeing the same spot twice. After all, if you’ve seen a giant
    clock tower once, do you really need to see it again?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*哈密尔顿路径*是以数学家威廉·哈密尔顿命名的，它是图中的一条路径，访问每个节点一次且仅一次。我们可以将这个问题看作是为一个既彻底又容易感到无聊的游客规划行程的问题。游客面临着两个相互竞争的目标。首先，他们需要确保访问城市中的每个景点，不希望错过任何一个。其次，他们希望避免看到同一个景点两次。毕竟，如果你已经看过了一个巨大的钟楼，你真的需要再看一遍吗？'
- en: '[Figure 18-1](#fig18-1) shows a Hamiltonian path [0, 1, 2, 5, 4, 3] on a graph
    with six nodes. The path starts at node 0, progresses through nodes 1, 2, 5, and
    4, and terminates at node 3\. Each node is visited only once.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-1](#fig18-1)展示了一个包含六个节点的图中的哈密尔顿路径[0, 1, 2, 5, 4, 3]。该路径从节点0开始，经过节点1、2、5和4，最后到达节点3。每个节点仅被访问一次。'
- en: '![A graph with six nodes. Arrows mark a path from node 0 through nodes 1, 2,
    5, 4, and 3\. The path ends at node 3.](../images/f18001.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含六个节点的图。箭头标记了从节点0到节点1、2、5、4、3的路径。该路径以节点3为终点。](../images/f18001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-1: A Hamiltonian
    path</samp>'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 18-1：哈密尔顿路径</samp>
- en: More useful for the tourist’s case is the *Hamiltonian cycle* (or circuit),
    which starts and ends at the same node while traveling to each node exactly once.
    While the tourist wants to avoid repeat destinations as much as possible, they
    want to both start and end the journey at their hotel—an acceptable trade-off
    for not having to carry their luggage through the city.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于游客而言，更有用的是*哈密尔顿循环*（或回路），它从同一个节点出发并回到该节点，同时访问每个节点一次且仅一次。虽然游客希望尽量避免重复的目的地，但他们希望能在酒店开始和结束旅行——这是一个可接受的折中，因为这样就不必在城市中搬运行李。
- en: While the tourist example uses a predefined node (the hotel) as the starting
    and ending location, Hamiltonian cycles can start or end at any node in the graph.
    The example Hamiltonian cycle in [Figure 18-2](#fig18-2) might start at node 0
    or any of the other five nodes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然旅游示例使用了预定义的节点（酒店）作为起点和终点，但哈密顿循环可以从图中的任何节点开始或结束。[图 18-2](#fig18-2)中的示例哈密顿循环可能从节点
    0 或其他任意五个节点开始。
- en: '![A graph with six nodes. Arrows mark a path from node 0 through nodes 1, 2,
    5, 4, and 3 to node 0.](../images/f18002.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含六个节点的图，箭头标记了一条从节点 0 通过节点 1、2、5、4 和 3 到节点 0 的路径。](../images/f18002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-2: A Hamiltonian
    cycle</samp>'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 18-2：哈密顿循环</samp>
- en: Because the path in [Figure 18-2](#fig18-2) forms a loop, all nodes along it
    must be reachable from themselves. As we will see, this same flexibility does
    not apply to Hamiltonian paths in general.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于[图 18-2](#fig18-2)中的路径形成了一个循环，路径上的所有节点必须能够从自身到达。如我们所见，这种灵活性并不适用于一般的哈密顿路径。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Validating Hamiltonian
    Paths</samp>
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">验证哈密顿路径</samp>
- en: 'Determining whether a path is Hamiltonian requires us to check that each node
    is visited once. We define a checker function <samp class="SANS_TheSansMonoCd_W5Regular_11">is_hamiltonian_path()</samp>
    that takes a path as a list of visited nodes:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 判断路径是否是哈密顿路径需要我们检查每个节点是否被访问一次。我们定义了一个检查函数<samp class="SANS_TheSansMonoCd_W5Regular_11">is_hamiltonian_path()</samp>，它接受一个由已访问节点组成的路径列表：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code starts by checking for potential validity by confirming the path length
    is equal to the number of nodes in the graph ❶. If there are fewer steps in the
    path, then not every node could have been visited. If there are more, then some
    node must have been visited more than once. This also handles the edge cases of
    an empty path and an empty graph.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先通过确认路径长度等于图中节点的数量 ❶ 来检查潜在的有效性。如果路径中的步骤较少，那么就无法访问所有节点。如果步骤过多，那么某个节点一定被访问了多次。这也处理了空路径和空图的边界情况。
- en: If the path is non-empty, the code sets up the data structures to use a Boolean
    array tracking whether each node has been visited (<samp class="SANS_TheSansMonoCd_W5Regular_11">visited</samp>)
    and the previous node seen along the path (<samp class="SANS_TheSansMonoCd_W5Regular_11">prev_node</samp>).
    The algorithm starts the check by setting <samp class="SANS_TheSansMonoCd_W5Regular_11">prev_node</samp>
    to the first node in the path and marking it visited ❷.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路径非空，代码会设置数据结构，使用布尔数组跟踪每个节点是否被访问过（<samp class="SANS_TheSansMonoCd_W5Regular_11">visited</samp>），以及沿路径看到的前一个节点（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">prev_node</samp>）。算法通过将<samp class="SANS_TheSansMonoCd_W5Regular_11">prev_node</samp>设置为路径中的第一个节点并将其标记为已访问
    ❷来开始检查。
- en: Most of the algorithm consists of a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop through the path. At each step, it checks for an edge between the previous
    node and current node ❸, then checks that the current node has not yet been visited
    ❹. If either check fails, the path is not a valid Hamiltonian path, and the code
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. If both checks
    succeed, the algorithm marks the current node as seen and sets <samp class="SANS_TheSansMonoCd_W5Regular_11">prev_node</samp>
    to the current node. If the code makes it through the entire path, it knows that
    it has visited the same number of nodes as in the graph and has not visited any
    twice. It returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> to
    indicate success.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的大部分内容是通过路径进行的<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环。在每一步，它检查前一个节点和当前节点之间是否存在边
    ❸，然后检查当前节点是否尚未被访问 ❹。如果任何一个检查失败，则路径不是有效的哈密顿路径，代码返回<samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。如果两个检查都成功，算法将当前节点标记为已访问，并将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">prev_node</samp>设置为当前节点。如果代码成功遍历整个路径，则表示它已经访问了图中的相同数量的节点，并且没有访问任何节点两次。它返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>表示成功。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Hamiltonian
    Paths with Depth-First Search</samp>
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用深度优先搜索寻找哈密顿路径</samp>
- en: While the problem of finding Hamiltonian paths is NP-hard, we can define an
    exhaustive search that, though costly, will find such paths. We use a variation
    of depth-first search that, instead of visiting each graph node once, explores
    all paths through a node.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然寻找哈密顿路径的问题是 NP 难题，但我们可以定义一个穷举搜索，尽管代价很高，它仍然能够找到这样的路径。我们使用深度优先搜索的变体，该变体不是每次只访问一个节点，而是探索通过一个节点的所有路径。
- en: Consider the graph in [Figure 18-3(a)](#fig18-3). This graph has the valid Hamiltonian
    path [0, 1, 3, 2, 4] shown in [Figure 18-3(b)](#fig18-3). However, the depth-first
    search from [Chapter 4](chapter4.xhtml) will not visit the nodes in this order
    but will explore node 2 before node 3.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 [图 18-3(a)](#fig18-3) 中的图。这个图有一个有效的哈密顿路径 [0, 1, 3, 2, 4]，如 [图 18-3(b)](#fig18-3)
    中所示。然而，[第 4 章](chapter4.xhtml) 中的深度优先搜索不会按此顺序访问节点，而是在节点 3 之前探索节点 2。
- en: '![(A) shows a graph with five nodes and directed edges (0, 1), (1, 0), (1,
    2), (1, 3), (2, 0), (2, 3), (2, 4), and (3, 2). (B) shows the same graph with
    the edges (0, 1), (1, 3), (3, 2), and (2, 4) bolded.](../images/f18003.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![(A) 显示了一个包含五个节点的图，带有有向边（0, 1）、（1, 0）、（1, 2）、（1, 3）、（2, 0）、（2, 3）、（2, 4）和（3,
    2）。(B) 显示了相同的图，边（0, 1）、（1, 3）、（3, 2）和（2, 4）被加粗。](../images/f18003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-3: A Hamiltonian
    path that does not match the visit order of the depth-first search</samp>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 18-3：一个哈密顿路径，它与深度优先搜索的访问顺序不匹配</samp>
- en: To find valid Hamiltonian paths, we must extend this depth-first search to backtrack
    and try different paths. The search must reset the nodes visited *after* the current
    node to unseen so that it can try different paths to get to those nodes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到有效的哈密顿路径，我们必须扩展这个深度优先搜索，使其能够回溯并尝试不同的路径。搜索必须在当前节点之后重置节点的访问状态为未访问，以便它可以尝试不同的路径到达这些节点。
- en: The code for Hamiltonian depth-first search in [Listing 18-1](#list18-1) uses
    the standard depth-first search with a few modifications.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 18-1](#list18-1) 中的哈密顿深度优先搜索代码使用了标准的深度优先搜索，并进行了少量修改。'
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-1: A recursive function
    for searching for Hamiltonian paths</samp>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 18-1：一个用于搜索哈密顿路径的递归函数</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">hamiltonian_dfs_rec()</samp>
    function takes the graph (<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>),
    the current node index (<samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp>),
    the path so far as a list of nodes (<samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp>),
    and the Boolean list of nodes visited (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>).
    It returns a list of nodes representing the path if one is found and <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    otherwise. We must import <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>
    from Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library
    to support the type hint of the return value.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">hamiltonian_dfs_rec()</samp> 函数接受图（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">g</samp>）、当前节点索引（<samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp>）、到目前为止的路径（作为节点列表，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">path</samp>），以及已经访问的节点的布尔列表（<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>）。如果找到了路径，它将返回代表路径的节点列表，否则返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>。我们必须从 Python 的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> 库中导入 <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>，以支持返回值的类型提示。
- en: The code starts by adding the current node to the path and marking it seen.
    It then checks whether it has visited <samp class="SANS_TheSansMonoCd_W5Regular_11">g.num_nodes</samp>
    unique nodes ❶. If so, <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp>
    is a valid Hamiltonian path, and the function returns it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先将当前节点添加到路径中，并将其标记为已访问。然后，它检查是否已访问 <samp class="SANS_TheSansMonoCd_W5Regular_11">g.num_nodes</samp>
    个独特的节点 ❶。如果是，<samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp> 就是一个有效的哈密顿路径，函数将返回它。
- en: The core search logic occurs when the path has yet to be completed. The code
    iterates over the outgoing edges with a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop and recursively tests unvisited neighbors ❷. If it finds a valid Hamiltonian
    path along any of these explorations (<samp class="SANS_TheSansMonoCd_W5Regular_11">result
    is not None</samp>), it returns the path immediately. In this case, the function
    exits without resetting either the nodes’ <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>
    value or the <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp> list because
    it will not continue testing alternate paths.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 核心搜索逻辑发生在路径尚未完成时。代码通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环迭代出边，并递归地测试未访问的邻居 ❷。如果在这些探索中找到有效的哈密顿路径（<samp class="SANS_TheSansMonoCd_W5Regular_11">result
    is not None</samp>），它会立即返回该路径。在这种情况下，函数退出时不会重置节点的 <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>
    值或 <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp> 列表，因为它将不再继续测试备用路径。
- en: If the code makes it through each outgoing edge without finding a valid path,
    it backtracks to the previous node. The code removes the current node from the
    path and marks it unseen ❸. This allows the search to visit the node via a different
    path. The code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    to indicate that it was unable to find a path along this branch.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码在通过每条出边时都没有找到有效路径，它会回溯到上一个节点。代码会从路径中移除当前节点并标记为未访问 ❸。这样，搜索就可以通过不同的路径访问该节点。代码返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>，表示无法在此分支上找到路径。
- en: 'We define a wrapper that initiates a search from each possible starting node:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个包装器，它从每个可能的起始节点启动搜索：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">hamiltonian_dfs()</samp> function
    initializes the <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> list
    to all <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> and uses a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to start a recursive search
    from each starting node. As soon as it finds a path (a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    result), it returns that path. If it cannot find a valid Hamiltonian path using
    any starting node, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">hamiltonian_dfs()</samp> 函数将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> 列表初始化为所有 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，并使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环从每个起始节点开始递归搜索。一旦找到路径（即非
    <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> 的结果），就返回该路径。如果无法使用任何起始节点找到有效的哈密顿路径，则返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>。
- en: '[Figure 18-4](#fig18-4) shows an example of this updated search. When visiting
    node 1 in [Figure 18-4(a)](#fig18-4), the search has two options of where to go
    next, nodes 2 or 3\. It starts by exploring node 2, as shown in [Figure 18-4(b)](#fig18-4),
    which leads to a dead end at node 3, which leaves node 4 unvisited. Unable to
    visit node 4, it has not found a valid Hamiltonian path. It must backtrack and
    try alternate paths.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-4](#fig18-4) 展示了这种更新后的搜索示例。在访问 [图 18-4(a)](#fig18-4) 中的节点 1 时，搜索有两个去向选择，节点
    2 或 3。它首先探索节点 2，如 [图 18-4(b)](#fig18-4) 所示，这导致在节点 3 处遇到死胡同，未能访问节点 4。由于无法访问节点 4，因此没有找到有效的哈密顿路径，必须回溯并尝试备用路径。'
- en: '![All four subfigures show the same directed graph with five nodes and directed
    edges (0, 1), (1, 0), (1, 2), (1, 3), (2, 0), (2, 3), (2, 4), and (3, 2). (A)
    shows edges (0, 1) bolded and nodes 0 and 1 shaded. (B) shows edges (0, 1), (1,
    2), and (2, 3) bolded and nodes 0, 1, 2, and 3 shaded. (C) shows edges (0, 1),
    (1, 2), and (2, 4) bolded and nodes 0, 1, 2, and 4 shaded. (D) shows edges (0,
    1), (1, 3), (3, 2), and (2, 4) bolded and nodes 0, 1, 2, 3, and 4 shaded.](../images/f18004.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![所有四个子图显示相同的有向图，包含五个节点和有向边 (0, 1)，(1, 0)，(1, 2)，(1, 3)，(2, 0)，(2, 3)，(2, 4)，(3,
    2)。(A) 显示边 (0, 1) 加粗，节点 0 和 1 被阴影标记。(B) 显示边 (0, 1)，(1, 2) 和 (2, 3) 加粗，节点 0、1、2
    和 3 被阴影标记。(C) 显示边 (0, 1)，(1, 2) 和 (2, 4) 加粗，节点 0、1、2 和 4 被阴影标记。(D) 显示边 (0, 1)，(1,
    3)，(3, 2) 和 (2, 4) 加粗，节点 0、1、2、3 和 4 被阴影标记。](../images/f18004.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-4: The steps along
    the depth-first-based Hamiltonian path search</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 18-4：基于深度优先的哈密顿路径搜索步骤</samp>
- en: The search backtracks to node 2\. It marks node 3 unvisited because it is no
    longer including that node in its current path. The search considers the other
    paths out of node 2\. It has already rejected the edge (2, 0) since it visited
    node 0 earlier. This leaves the edge (2, 4), as shown in [Figure 18-4(c)](#fig18-4).
    Unfortunately, taking this edge leads to a dead end, which does not visit node
    3\. It is blocked again.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索回溯到节点 2。它将节点 3 标记为未访问，因为它不再将该节点包含在当前路径中。搜索考虑从节点 2 出发的其他路径。它已经拒绝了边 (2, 0)，因为它之前已经访问过节点
    0。剩下的边是 (2, 4)，如 [图 18-4(c)](#fig18-4) 所示。不幸的是，走这条边会导致死胡同，无法访问节点 3，搜索再次被阻塞。
- en: The search must backtrack all the way to node 1 and try the path to node 3,
    as shown in [Figure 18-4(d)](#fig18-4). It resets both nodes 2 and 4 to unvisited
    and returns to the state shown in [Figure 18-4(a)](#fig18-4). This allows it to
    travel from node 3 to node 2 and on to node 4.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索必须回溯到节点 1，并尝试通往节点 3 的路径，如 [图 18-4(d)](#fig18-4) 所示。它将节点 2 和节点 4 都重置为未访问，并返回到
    [图 18-4(a)](#fig18-4) 中显示的状态。这样它就可以从节点 3 到达节点 2，并继续前往节点 4。
- en: Unfortunately, it may be insufficient to perform a single depth-first search.
    Unlike Hamiltonian cycles, the starting node of the search can affect whether
    the search finds a Hamiltonian path. [Figure 18-5](#fig18-5) shows a graph for
    which we can find Hamiltonian paths of [1, 0, 2] when starting from node 1 or
    [2, 0, 1] when starting from node 2, but no Hamiltonian path starting from node
    0.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，执行一次深度优先搜索可能不足以解决问题。与哈密顿回路不同，搜索的起始节点会影响是否能够找到哈密顿路径。 [图 18-5](#fig18-5)
    显示了一个图，其中从节点 1 开始可以找到哈密顿路径 [1, 0, 2]，从节点 2 开始可以找到哈密顿路径 [2, 0, 1]，但从节点 0 开始无法找到哈密顿路径。
- en: '![The figure shows a graph with three nodes and edges (1, 0) and (0, 2).](../images/f18005.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![该图显示了一个包含三个节点和边 (1, 0) 以及 (0, 2) 的图。](../images/f18005.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-5: A graph with no
    Hamiltonian path starting at node 0</samp>'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 18-5：从节点 0 开始没有哈密顿路径的图</samp>
- en: 'To combat this problem, we can run a separate depth-first search using each
    possible starting node. We keep searching until we have exhausted all the starting
    nodes or found a valid path.  ### <samp class="SANS_Futura_Std_Bold_B_11">The
    Traveling Salesperson Problem</samp>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '为了解决这个问题，我们可以使用每个可能的起始节点进行单独的深度优先搜索。我们会继续搜索，直到用尽所有起始节点或者找到一个有效的路径。  ### <samp
    class="SANS_Futura_Std_Bold_B_11">旅行商问题</samp>'
- en: The *traveling salesperson problem* is an extension to finding a Hamiltonian
    cycle that accounts for edge weights. Modeled after the problem of a traveling
    salesperson planning their itinerary through multiple cities, the goal of this
    problem is to find a path that (1) starts and ends at the same node, (2) travels
    to each node exactly once, and (3) minimizes the sum of the edge weights.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*旅行商问题* 是寻找哈密顿回路的扩展问题，它考虑了边的权重。这个问题的模型借鉴了旅行商规划多城市行程的问题，其目标是找到一条路径，满足以下条件：(1)
    从同一节点出发并返回；(2) 每个节点恰好访问一次；(3) 最小化边权重的总和。'
- en: '[Figure 18-6](#fig18-6) shows an example graph (a) and the lowest-cost traveling
    salesperson route through it (b). Spending a few minutes manually trying different
    paths quickly reveals the difficulty of the problem: the number of possible paths
    explodes even for simple graphs like this one.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-6](#fig18-6) 显示了一个示例图 (a) 和其最低成本的旅行商路线 (b)。通过手动尝试不同的路径，几分钟内就能快速发现问题的难度：即使是像这样的简单图，可能的路径数量也会急剧增加。'
- en: '![(A) shows a weighted graph with 6 nodes and 11 undirected edges with weights:
    (0, 1) = 5, (0, 2) = 6, (0, 3) = 2, (1, 2) = 3, (1, 3) = 1, (1, 4) = 1, (1, 5)
    = 2, (2, 5) = 6, (3, 4) = 7, (3, 5) = 5, and (4, 5) = 1\. (B) shows the same graph
    with the edges (0, 3), (3, 1), (1, 4), (4, 5), (5, 2), and (2, 0) bolded.](../images/f18006.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![(A) 显示了一个带有 6 个节点和 11 条带权无向边的加权图，边的权重分别为： (0, 1) = 5, (0, 2) = 6, (0, 3)
    = 2, (1, 2) = 3, (1, 3) = 1, (1, 4) = 1, (1, 5) = 2, (2, 5) = 6, (3, 4) = 7, (3,
    5) = 5 和 (4, 5) = 1。 (B) 显示了相同的图，其中边 (0, 3)、(3, 1)、(1, 4)、(4, 5)、(5, 2) 和 (2,
    0) 为粗体。](../images/f18006.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-6: An example graph
    with 6 nodes and 11 edges (a) and an optimal traveling salesperson path (b)</samp>'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 18-6：一个包含 6 个节点和 11 条边的示例图
    (a) 以及一个最优的旅行商路径 (b)</samp>
- en: The many concrete applications of this task to real-world routing problems make
    it critical in a range of domains such as shipping and logistics. Because of this
    importance, computer scientists and mathematicians have devoted significant time
    and effort to studying the traveling salesperson problem and have developed numerous
    approaches, including heuristic searches and approximation algorithms. In this
    section, we build off the approaches from previous sections and examine a single
    exhaustive approach based on depth-first search.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务在现实世界中的许多具体应用，如运输和物流，使其在多个领域至关重要。正因为如此，计算机科学家和数学家们投入了大量时间和精力研究旅行商问题，并开发了许多方法，包括启发式搜索和近似算法。在本节中，我们将基于前几节的方法，构建一个基于深度优先搜索的穷举法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Depth-First Search</samp>
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">深度优先搜索</samp>
- en: We can directly adapt the depth-first search algorithm from Hamiltonian paths
    to account for path cost. In doing so, we need to make three changes. First, since
    we are looking for cycles rather than paths, we update the algorithm to return
    to the starting node. Second, we no longer stop as soon as we have found the first
    valid result. Instead, we continue searching until we have evaluated all valid
    Hamiltonian cycles so that we can find the lowest-cost one. Third, we track the
    best path seen so far and its cost.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接调整哈密顿路径的深度优先搜索算法来考虑路径成本。在此过程中，我们需要做三项更改。首先，因为我们要寻找的是循环而不是路径，所以我们更新算法以返回起始节点。其次，我们不再在找到第一个有效结果时立即停止，而是继续搜索，直到评估所有有效的哈密顿循环，从而找到最低成本的循环。第三，我们跟踪迄今为止看到的最佳路径及其成本。
- en: We define the algorithm to perform a depth-first search over paths, resetting
    each node’s <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> label as
    the search backtracks from that node. As with the search for Hamiltonian paths,
    this allows us to try alternate paths out of each node. Each time we reach the
    end of the recursion by completing a Hamiltonian cycle, we return a copy of the
    path and its cost. The calling function compares the paths and costs from each
    of the recursive calls and returns the best one.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了该算法，在路径上执行深度优先搜索，每当从节点回溯时，重置每个节点的<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>标签。与哈密顿路径搜索类似，这允许我们尝试从每个节点出发的替代路径。每当我们通过完成哈密顿循环到达递归的终点时，我们会返回路径的副本及其成本。调用函数比较每次递归调用中的路径和成本，并返回最佳路径。
- en: Unlike the algorithm for Hamiltonian paths, we can begin this search from a
    single arbitrary node rather than from each starting node, since the result of
    the traveling salesperson problem is a cycle. The full cycle will have the same
    cost regardless of which node it uses as a starting and ending point.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与哈密顿路径算法不同，我们可以从任意一个节点开始此搜索，而不必从每个起始节点开始，因为旅行商问题的结果是一个循环。无论从哪个节点作为起始和结束点，整个循环的成本都是相同的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: We base the code for the traveling salesperson problem on the code for Hamiltonian
    path search in [Listing 18-1](#list18-1). Again, we start with the recursive function,
    as shown in [Listing 18-2](#list18-2).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基于[Listing 18-1](#list18-1)中哈密顿路径搜索的代码实现了旅行商问题的代码。再次，我们从递归函数开始，如[Listing 18-2](#list18-2)所示。
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-2: A recursive function
    for the traveling salesperson problem</samp>'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-2：用于旅行商问题的递归函数</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">tsp_dfs_rec()</samp> function
    takes the graph (<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>), the
    path so far (<samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp>), the Boolean
    list of nodes visited (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>),
    and the cost so far (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>).
    It extracts the index of the current node as the current final node in <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp>.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">tsp_dfs_rec()</samp>函数接受图（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">g</samp>）、到目前为止的路径（<samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp>）、访问过的节点的布尔列表（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>）和到目前为止的成本（<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>）。它提取当前节点的索引作为<code>path</code>中的当前终节点。
- en: The function starts by considering the base case for the recursion where all
    the nodes have been visited ❶. It checks whether the path can be made into a cycle
    by returning to the starting node (<samp class="SANS_TheSansMonoCd_W5Regular_11">path[0]</samp>).
    If so, the code returns a tuple with the cycle’s cost and a new copy of the full
    cycle (<samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">[path[0]]</samp>). If there is no
    edge back to the starting node, the code returns an infinite cost to indicate
    that it is not a valid cycle.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先考虑递归的基本情况，其中所有节点都已经被访问❶。它检查是否可以通过返回起始节点（<samp class="SANS_TheSansMonoCd_W5Regular_11">path[0]</samp>）将路径转换为一个循环。如果可以，代码返回一个包含循环成本和完整循环的新副本的元组（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">path</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">[path[0]]</samp>）。如果没有边返回到起始节点，代码返回无限大的成本，表示这不是一个有效的循环。
- en: If the algorithm has more nodes to explore, the code iterates over the current
    node’s outgoing edges with a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop and recursively tests unvisited neighbors ❸. Unlike in the code for Hamiltonian
    paths in [Listing 18-1](#list18-1), the code augments ❷ and resets ❹ both the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> list and <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp>
    in the calling function. This simplifies the earlier logic for the base case.
    After recursively exploring the neighbor, the code checks whether it has found
    a better result and, if so, saves it. It finishes by returning the best cost and
    cycle found through this branch.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果算法有更多节点需要探索，代码使用<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环遍历当前节点的出边，并递归地测试未访问的邻居❸。与[清单18-1](#list18-1)中用于哈密顿路径的代码不同，代码会增加❷并重置❹调用函数中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>列表和<samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp>列表。这简化了之前的基本情况逻辑。在递归探索邻居之后，代码检查是否找到了更好的结果，如果有，便保存它。最后，它返回通过该分支找到的最佳成本和循环。
- en: 'We define a wrapper that sets up the data structures and initiates the search:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个包装器，设置数据结构并启动搜索：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code starts by checking the edge case where the graph has a single node
    and returns the appropriate answer. It then sets up the initial <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp> lists for the search,
    starting the path at node 0 and marking it seen. Finally, it runs the search and
    returns the result.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先检查图中只有一个节点的边界情况，并返回相应的答案。接着，它为搜索设置初始的<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">path</samp>列表，从节点0开始路径并标记为已访问。最后，它运行搜索并返回结果。
- en: The recursive function shown in [Listing 18-2](#list18-2) is a basic implementation
    of the traveling salesperson algorithm. We could improve its efficiency with additional
    pruning. For example, we could prune the current path if its cost exceeds the
    best cost so far. Similarly, we could incorporate heuristics like exploring the
    neighbors in order of increasing edge weight to focus on potentially lower-cost
    paths. As noted earlier, the vast variety of optimizations and heuristics for
    the traveling salesperson problem far exceeds the scope of this chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单18-2](#list18-2)中显示的递归函数是旅行商问题算法的基本实现。我们可以通过额外的剪枝来提高它的效率。例如，如果当前路径的成本超过了迄今为止的最佳成本，我们可以剪枝该路径。类似地，我们可以结合启发式方法，例如按边权递增的顺序探索邻居，以专注于潜在的低成本路径。正如前面所提到的，旅行商问题的优化和启发式方法种类繁多，远超本章的讨论范围。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个例子</samp>
- en: '[Figure 18-7](#fig18-7) shows the results of running this search on the graph
    from [Figure 18-6(a)](#fig18-6). Each subfigure shows the base case where the
    algorithm has found a Hamiltonian cycle, with the path highlighted in bold and
    the cost listed below it.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[图18-7](#fig18-7)显示了在[图18-6(a)](#fig18-6)的图上运行此搜索的结果。每个子图展示了算法找到哈密顿循环的基本情况，路径以粗体突出显示，成本列在其下方。'
- en: '![Fourteen subfigures show paths through the graph along with their costs.
    The first subfigure has bolded edges (0, 1), (1, 2), (2, 5), (5, 4), (4, 3), and
    (3, 0) and a cost of 24.](../images/f18007.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![十四个子图展示了图中的路径及其成本。第一个子图中，边（0, 1）、（1, 2）、（2, 5）、（5, 4）、（4, 3）和（3, 0）是加粗的，成本为24。](../images/f18007.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-7: The 14 Hamiltonian
    cycles explored during the depth-first search</samp>'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图18-7：深度优先搜索中探索的14个哈密尔顿回路</samp>
- en: Each path appears in [Figure 18-7](#fig18-7) multiple times because the algorithm
    will find the cycle in both directions. For example, the first subfigure corresponds
    to the path [0, 1, 2, 5, 4, 3, 0], while the second to last corresponds to the
    path [0, 3, 4, 5, 2, 1, 0].
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每条路径在[图18-7](#fig18-7)中出现多次，因为算法会在两个方向上找到回路。例如，第一个子图对应路径[0, 1, 2, 5, 4, 3, 0]，而倒数第二个子图对应路径[0,
    3, 4, 5, 2, 1, 0]。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Eulerian Paths and Cycles</samp>
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">欧拉路径和回路</samp>
- en: An *Eulerian path*, which is named after the mathematician Leonhard Euler, is
    a path through a graph that traverses each edge exactly once. We can view the
    problem in terms of an efficient window-shopping tourist. Determined to survey
    all the stores in a city, our tourist searches for a path that will take them
    down every road exactly one time. They refuse to miss out on potential finds by
    skipping a road or to waste their time passing stores they have already seen.
    An *Eulerian cycle* is an Eulerian path that starts and ends at the same node,
    providing the ideal planning tool if the tourist wants to start and end at their
    hotel but is concerned about traveling each road exactly once.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*欧拉路径*以数学家莱昂哈德·欧拉命名，是一种通过图的路径，恰好经过每一条边一次。我们可以将问题看作是一个高效的橱窗购物游客。为了调查城市中的所有商店，游客会寻找一条路径，确保每条路只走一次。他们不愿意错过通过某条路时可能找到的潜在商店，也不愿浪费时间再走已经看过的街道。*欧拉回路*是一个从同一个节点出发并返回的欧拉路径，它提供了一个理想的规划工具，如果游客希望从酒店出发并返回，但又想确保每条路都走一次。'
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Remember that, as described in [Chapter 3](chapter3.xhtml), we are using the
    definition of path that is common in computer science texts and allows repeated
    nodes. This differs from the formal graph theory definition of a path, which does
    not allow for repeated nodes. In graph theory, this problem may be referred to
    as finding an* Eulerian trail.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*请记住，正如[第3章](chapter3.xhtml)中所述，我们使用的是计算机科学文本中常见的路径定义，这允许节点重复。这与图论中对路径的正式定义不同，后者不允许重复节点。在图论中，这个问题可能被称为寻找一个*欧拉轨迹*。'
- en: '[Figure 18-8](#fig18-8) shows an Eulerian cycle on a graph with six nodes.
    The path starts at node 0 and consists of [0, 1, 2, 5, 1, 3, 4, 5, 3, 0]. While
    it revisits nodes, it traverses each of the nine edges only once. The tourist
    may pass through the same intersection multiple times but will venture past each
    street’s shop windows only a single time.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[图18-8](#fig18-8)展示了一个包含六个节点的图上的欧拉回路。路径从节点0开始，包含[0, 1, 2, 5, 1, 3, 4, 5, 3,
    0]。尽管路径回访了节点，但它只经过了每条边一次。游客可能会多次通过相同的交叉口，但每条街道的店铺橱窗仅会经过一次。'
- en: '![A graph with six nodes. Arrows mark a path from node 0 through nodes 1, 2,
    5, 1, 3, 4, 5, 3, and 0.](../images/f18008.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![包含六个节点的图。箭头标记了从节点0到节点1、2、5、1、3、4、5、3、0的路径。](../images/f18008.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-8: An Eulerian cycle</samp>'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图18-8：欧拉回路</samp>
- en: Not all graphs contain Eulerian paths. [Figure 18-9](#fig18-9) shows an undirected
    graph where no Eulerian path is possible. After moving from node 1 to any other
    node, the search would need to use the same edge to return to node 1\. Since nodes
    0, 2, and 3 are connected only to node 1, any path through all edges would need
    to return to node 1.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的图都包含欧拉路径。[图18-9](#fig18-9)展示了一个无向图，其中不可能存在欧拉路径。从节点1移动到任何其他节点后，搜索需要使用相同的边返回到节点1。由于节点0、2和3只与节点1相连，因此任何经过所有边的路径都需要返回到节点1。
- en: '![A graph with four nodes and edges (0, 1), (1, 2), and (1, 3).](../images/f18009.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![包含四个节点和边（0, 1）、（1, 2）和（1, 3）的图](../images/f18009.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-9: A graph without
    an Eulerian path</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图18-9：没有欧拉路径的图</samp>
- en: 'Leonhard Euler devised a simple and effective way to test whether a connected,
    undirected graph has an Eulerian cycle:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 莱昂哈德·欧拉设计了一种简单而有效的方法来测试一个连通的无向图是否包含欧拉回路：
- en: A connected, undirected graph has an Eulerian cycle if and only if all nodes
    have an even degree.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一个连通的无向图当且仅当所有节点的度数都是偶数时，才包含欧拉回路。
- en: Using this test, we can define a helper function for testing if a graph both
    is fully connected and has an Eulerian cycle, as shown in [Listing 18-3](#list18-3).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个测试，我们可以定义一个辅助函数，用于测试图是否既完全连通又具有欧拉回路，如[示例 18-3](#list18-3)所示。
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-3: Checking if a
    graph is fully connected and has an Eulerian cycle</samp>'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 18-3：检查图是否完全连通并具有欧拉回路</samp>
- en: The code starts by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">dfs_connected_components()</samp>
    function from [Chapter 4](chapter4.xhtml) to label each node’s component ❶. It
    then uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to examine
    each node and check that it is part of the same component ❷ and has an even degree.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码首先使用来自[第4章](chapter4.xhtml)的 <samp class="SANS_TheSansMonoCd_W5Regular_11">dfs_connected_components()</samp>
    函数为每个节点标记其组件 ❶。然后，它使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环检查每个节点，确认它属于同一组件 ❷ 且具有偶数度数。
- en: For completeness, the degree computation in <samp class="SANS_TheSansMonoCd_W5Regular_11">has_eulerian_cycle()</samp>
    handles the case of undirected self-loops ❸. As noted in [Chapter 2](chapter2.xhtml),
    edges forming self-loops in undirected graphs are counted twice for the degree,
    since they contact the node on each end.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，<samp class="SANS_TheSansMonoCd_W5Regular_11">has_eulerian_cycle()</samp>
    中的度数计算处理了无向自环的情况 ❸。正如[第2章](chapter2.xhtml)中所述，形成自环的边在无向图中被计算两次度数，因为它们分别与每个端点的节点接触。
- en: If the code finds a disconnected component or a node with an odd degree, it
    immediately returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
    If it checks all nodes without a problem, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码发现一个不连通的组件或一个度数为奇数的节点，它将立即返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。如果它检查所有节点都没有问题，则返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Validating Eulerian
    Paths</samp>
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">验证欧拉路径</samp>
- en: 'To determine whether a path is a valid Eulerian cycle, we need to check that
    each edge is used a single time. We define a checker function that takes a path
    as a list of nodes:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定路径是否是有效的欧拉回路，我们需要检查每条边是否只被使用一次。我们定义一个检查函数，将路径作为节点列表传入：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">is_eulerian_cycle()</samp>
    code starts by checking the edge case of an empty path, which is assumed to be
    valid only if the graph has no nodes ❶. If the path does have edges, the code
    builds a dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp>
    that maps each edge in the graph to a Boolean indicating whether that edge has
    been visited ❷.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">is_eulerian_cycle()</samp> 代码首先检查空路径的边界情况，只有当图没有节点时，空路径才被认为是有效的
    ❶。如果路径确实有边，代码构建一个字典 <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp>，该字典将图中的每条边映射到一个布尔值，用于指示该边是否已被访问
    ❷。
- en: The main body of the code consists of a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop that walks the path, using a combination of the previous node (<samp class="SANS_TheSansMonoCd_W5Regular_11">prev_node</samp>)
    and the current node (<samp class="SANS_TheSansMonoCd_W5Regular_11">next_node</samp>)
    to identify the current edge. The function immediately returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    if the path uses an edge that does not exist ❸ or has already been traversed ❹.
    Otherwise, the code marks the edges as visited ❺, taking care to mark entries
    for both directions if the edges are undirected.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的主体部分是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环，它遍历路径，结合前一个节点
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">prev_node</samp>) 和当前节点 (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">next_node</samp>) 来识别当前的边。如果路径使用了不存在的边
    ❸ 或已被遍历的边 ❹，该函数将立即返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。否则，代码将标记这些边为已访问
    ❺，并确保在无向图的情况下，双向边都被标记。
- en: The code completes by checking that it has visited each of the edges and returning
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> if it finds an unvisited
    edge ❻. (Alternatively, we could structure the code to count the total number
    of edges and the number of edges seen, handling the undirected case correctly,
    and just compare the counts.) The function uses a final check that the start and
    end nodes are the same, meaning the path is a cycle ❼.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 代码完成后会检查是否访问了每条边，并在发现未访问的边时返回<samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    ❻。（或者，我们可以结构化代码来计算边的总数和已访问的边数，正确处理无向情况，并仅进行计数比较。）该函数使用最后检查确保起始节点和结束节点相同，意味着路径是一个回路
    ❼。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Eulerian
    Cycles with Hierholzer’s Algorithm</samp>
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用海尔霍尔策算法查找欧拉回路</samp>
- en: Unlike the previous two problems in this chapter, the problem of finding Eulerian
    cycles is not NP-hard, and there exists an efficient method for finding an Eulerian
    cycle in a graph. The mathematician Carl Hierholzer developed an algorithm for
    extracting the Eulerian cycle in graphs that have one. *Hierholzer’s algorithm*
    operates by repeatedly finding cycles over unused edges and removing those cycles
    from the graph. Since the algorithm requires that the graph does have an Eulerian
    cycle, we use the Euler’s degree-based test (and the code in [Listing 18-3](#list18-3))
    to precheck the graph.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章前两个问题不同，寻找欧拉回路的问题不是NP难题，并且存在一种高效的方法来在图中找到欧拉回路。数学家卡尔·海尔霍尔策（Carl Hierholzer）开发了一种用于提取具有欧拉回路的图中欧拉回路的算法。*海尔霍尔策算法*通过反复寻找未使用的边上的循环，并从图中移除这些循环来运行。由于该算法要求图中必须存在欧拉回路，因此我们使用欧拉度数测试（以及[清单18-3](#list18-3)中的代码）来对图进行预检查。
- en: The primary insight behind this approach is that if a graph has an Eulerian
    cycle, we can build this full cycle from a series of potentially smaller cycles.
    We call these smaller cycles *subloops* to distinguish them from the full Eulerian
    cycle. The algorithm starts by finding any cycle in the graph and removing its
    edges, which may leave some edges in the graph. Since the graph has a full Eulerian
    cycle that uses all the edges, the algorithm can insert these remaining edges
    into the full path by splicing in additional subloops that each start and end
    at the same node in the current path.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法背后的主要思路是，如果一个图具有欧拉回路，我们可以通过一系列潜在的较小循环构建这个完整的回路。我们将这些较小的循环称为*子循环*，以便与完整的欧拉回路区分开来。算法首先通过查找图中的任何一个循环并移除其边来开始，这可能会在图中留下部分边。由于该图具有一个使用所有边的完整欧拉回路，算法可以通过将这些剩余的边插入到完整路径中，插入额外的子循环，每个子循环都从当前路径中的相同节点开始和结束。
- en: '[Figure 18-10](#fig18-10) shows an example of this algorithm. In [Figure 18-10(b)](#fig18-10),
    the search finds an initial cycle [0, 1, 2, 5, 3, 0] that uses five edges and
    visits the five shaded nodes. It then removes these edges, as shown in [Figure
    18-10(c)](#fig18-10).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[图18-10](#fig18-10)展示了该算法的一个示例。在[图18-10(b)](#fig18-10)中，搜索找到一个初始循环[0, 1, 2,
    5, 3, 0]，该循环使用五条边并访问了五个阴影节点。然后它移除这些边，如[图18-10(c)](#fig18-10)所示。'
- en: '![Four subfigures show the steps of Hierholzer’s algorithm. In (a), an initial
    graph is shown with six nodes and nine undirected edges (0, 1), (0, 3), (1, 2),
    (1, 3), (1, 5), (2, 5), (3, 4), (3, 5), and (4, 5). (B) shows the cycle [0, 1,
    2, 5, 3, 0] with arrows indicating the traversed edges. (C) shows the graph with
    the traversed edges removed. (D) shows the graph with the cycle [1, 5, 4, 3, 1]
    highlighted.](../images/f18010.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![四个子图展示了Hierholzer算法的步骤。在(a)中，显示了一个包含六个节点和九条无向边的初始图，边为(0, 1)、(0, 3)、(1, 2)、(1,
    3)、(1, 5)、(2, 5)、(3, 4)、(3, 5)和(4, 5)。(B)显示了一个包含箭头的循环[0, 1, 2, 5, 3, 0]，箭头指示遍历过的边。(C)展示了去除遍历边后的图。(D)展示了突出显示的循环[1,
    5, 4, 3, 1]。](../images/f18010.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-10: The graph before
    (a), during the first step (b), after the first step (c), and during the second
    step (d) of Hierholzer’s algorithm</samp>'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图18-10：Hierholzer算法在步骤前（a）、第一步期间（b）、第一步后（c）和第二步期间（d）的图</samp>
- en: Next, the algorithm looks for a cycle that starts and ends at one of the previously
    visited nodes but travels unused edges. [Figure 18-10(d)](#fig18-10) shows the
    cycle [1, 5, 4, 3, 1]. We can splice this new loop into the full path by inserting
    it in place of the occurrence of node 1 for an overall path of [0, 1, 5, 4, 3,
    1, 2, 5, 3, 0].
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，算法寻找一个从之前访问过的节点出发并结束于该节点的循环，但该循环通过未使用的边缘。[图 18-10(d)](#fig18-10) 显示了循环 [1,
    5, 4, 3, 1]。我们可以通过将其插入到节点 1 的出现位置，将这个新环路拼接到完整路径中，最终路径为 [0, 1, 5, 4, 3, 1, 2, 5,
    3, 0]。
- en: 'Depending on how the algorithm selects which node to visit next, different
    implementations can ultimately explore different subloops and produce different
    Eulerian cycles for the same graph. For example, the code in this section will
    explore the nodes in [Figure 18-10(a)](#fig18-10) so as to produce the final Eulerian
    cycle from [Figure 18-8](#fig18-8): [0, 1, 2, 5, 1, 3, 4, 5, 3, 0].'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 根据算法如何选择下一个访问的节点，不同的实现最终可能会探索不同的子循环，并为相同的图生成不同的欧拉回路。例如，本节中的代码将按照[图 18-10(a)](#fig18-10)中的节点顺序进行探索，从而生成[图
    18-8](#fig18-8)中的最终欧拉回路：[0, 1, 2, 5, 1, 3, 4, 5, 3, 0]。
- en: 'To extract an Eulerian cycle from a graph, we must follow the subloops through
    the graph:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要从图中提取欧拉回路，我们必须通过图中的子循环进行遍历：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code starts by confirming the graph has an Eulerian cycle using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">has_eulerian_cycle()</samp> function from
    [Listing 18-3](#list18-3) ❶. If this check fails, the code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>
    to indicate the lack of an Eulerian cycle. The code relies on importing <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Union</samp> from the <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp>
    library to support the type hints for multiple return types. If the check passes,
    the code sets up the initial data structures, including a full copy of the graph
    that can be modified (<samp class="SANS_TheSansMonoCd_W5Regular_11">g_r</samp>),
    a set of seen nodes that it can use as starting points for subloops (<samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp>),
    and a list that tracks the Eulerian cycle constructed so far (<samp class="SANS_TheSansMonoCd_W5Regular_11">full_cycle</samp>).
    The code will iteratively build up <samp class="SANS_TheSansMonoCd_W5Regular_11">full_cycle</samp>
    by following subloops and inserting them into <samp class="SANS_TheSansMonoCd_W5Regular_11">full_cycle</samp>.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先通过使用 [Listing 18-3](#list18-3) ❶ 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">has_eulerian_cycle()</samp>
    函数来确认图是否存在欧拉回路。如果检查失败，代码将返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>，表示没有欧拉回路。代码依赖于从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> 库导入 <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>
    来支持多个返回类型的类型提示。如果检查通过，代码会设置初始数据结构，包括一个可以修改的图的完整副本（<samp class="SANS_TheSansMonoCd_W5Regular_11">g_r</samp>），一个已访问节点的集合，用于作为子循环的起始点（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">options</samp>），以及一个跟踪迄今为止构建的欧拉回路的列表（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">full_cycle</samp>）。代码将通过遍历子循环并将其插入到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">full_cycle</samp> 中，逐步构建 <samp class="SANS_TheSansMonoCd_W5Regular_11">full_cycle</samp>。
- en: The main body of the algorithm is a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop that continues finding new cycles while there exists a visited node with
    unused edges (<samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp> is
    not empty). The <samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp> set
    provides a list of nodes from which the code can start a new subloop. The code
    pops an arbitrary node from <samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp>
    ❷ and starts traversing a cycle.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的主体是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环，只要存在带有未使用边缘的已访问节点（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">options</samp> 不为空），它就会继续寻找新的循环。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">options</samp> 集合提供了一个节点列表，代码可以从这些节点开始一个新的子循环。代码从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp> ❷ 中弹出一个任意节点，并开始遍历一个循环。
- en: The code traverses the new cycle by using an inner <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop that explores until it has completed a circuit and returned to the cycle’s
    starting node ❸. The loop condition also tests that the new cycle has taken at
    least one step before terminating. If <samp class="SANS_TheSansMonoCd_W5Regular_11">len(subcycle)</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    the loop continues because the path hasn’t gone anywhere yet. During each step
    of the cycle traversal, the code selects the first key in the current node’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">edges</samp> dictionary as its next destination
    to visit (<samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp>) ❹. It
    adds <samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp> to the current
    loop being tracked and removes the edge from the copy of the graph.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过使用内部<samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环遍历新的循环，直到它完成一个回路并返回到循环的起始节点
    ❸。循环条件还会检查新的循环是否至少走了一步后才会终止。如果<samp class="SANS_TheSansMonoCd_W5Regular_11">len(subcycle)</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，循环会继续，因为路径还没有走到任何地方。在每一步的循环遍历过程中，代码选择当前节点<samp
    class="SANS_TheSansMonoCd_W5Regular_11">edges</samp>字典中的第一个键作为下一个要访问的目标（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp>） ❹。它将<samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp>添加到当前跟踪的循环中，并从图的副本中删除该边。
- en: The code updates <samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp>
    by considering the number of remaining edges from the current node ❺. If there
    is at least one remaining edge, it adds the node to <samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp>
    to indicate there are other paths to take. In contrast, if the code has just deleted
    the last edge adjacent to the current node, the code removes that node from the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp>. After the inner
    <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop completes, the
    code similarly discards the starting node if it has no remaining edges ❻.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过考虑当前节点剩余的边数来更新<samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp>
    ❺。如果至少还有一条剩余的边，它将该节点添加到<samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp>中，以表示还有其他路径可走。相比之下，如果代码刚刚删除了当前节点的最后一条相邻边，代码将该节点从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">options</samp>中移除。在内部<samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环完成后，代码同样会丢弃没有剩余边的起始节点
    ❻。
- en: After completing the inner loop, the code also inserts <samp class="SANS_TheSansMonoCd_W5Regular_11">subcycle</samp>
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">full_cycle</samp> ❼. For simplicity’s
    sake, we use a linear time find (<samp class="SANS_TheSansMonoCd_W5Regular_11">index()</samp>
    function) and build a new copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">full_cycle</samp>.
    With additional bookkeeping, we could use more efficient approaches to minimize
    the cost of this step.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成内部循环后，代码还将<samp class="SANS_TheSansMonoCd_W5Regular_11">subcycle</samp>插入到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">full_cycle</samp> ❼中。为了简化处理，我们使用线性时间查找（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">index()</samp>函数）并构建一个新的<samp class="SANS_TheSansMonoCd_W5Regular_11">full_cycle</samp>副本。如果进行额外的记录工作，我们可以使用更高效的方法来最小化这一步的成本。
- en: '[Figure 18-11](#fig18-11) shows the operation of Hierholzer’s algorithm on
    a graph with eight nodes. [Figure 18-11(a)](#fig18-11) shows the state of the
    graph, the <samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp> set, and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">full_cycle</samp> list before
    the start of the algorithm. The remaining subfigures show the state of the algorithm
    after each iteration of the outer <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop. Edges traversed and removed during that iteration are highlighted in bold.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[图18-11](#fig18-11)展示了Hierholzer算法在一个包含八个节点的图上的操作。[图18-11(a)](#fig18-11)展示了图的状态、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">options</samp>集合以及算法开始前的<samp class="SANS_TheSansMonoCd_W5Regular_11">full_cycle</samp>列表。其余的子图展示了每次外部<samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环迭代后的算法状态。在该迭代中遍历并移除的边以粗体显示。'
- en: We can visualize this algorithm in terms of an officer of a city’s tourism board
    planning a comprehensive tour. Their goal is to devise a path through the city
    that travels each street exactly once, giving visitors a full experience of the
    city without unnecessary repetition. They choose the city’s premier hotel as the
    starting location (node 0) and set out walking. Throughout their trip, they record
    each street they travel and visit intersections with untraveled roads.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将该算法可视化为一位城市旅游局官员规划综合旅游的过程来理解。其目标是设计一条遍历每条街道一次的路径，让游客全方位体验这座城市，而不产生不必要的重复。他们选择城市的豪华酒店作为起点（节点
    0），并开始出发。旅行过程中，他们记录下每条已走过的街道，并访问未走过的道路交叉口。
- en: '[Figure 18-11(b)](#fig18-11) illustrates the results of the tour planner’s
    first day. Taking untraveled roads, they complete a small cycle [0, 1, 2, 0] to
    arrive back at the hotel. At this point, they have no untraveled roads out of
    the current node. Undaunted by the number of streets left unexplored, they cross
    roads (0, 1), (1, 2), and (2, 0) off of their map. They also note that they could
    have taken different roads at intersections (that is, nodes) 1 and 2.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-11(b)](#fig18-11) 展示了旅游规划者第一天的结果。通过走未探索的道路，他们完成了一个小循环 [0, 1, 2, 0]，回到了酒店。此时，他们在当前节点没有未走过的道路。尽管还有许多街道没有被探索，他们仍然毫不气馁，标记了道路（0,
    1）、（1, 2）和（2, 0）为已走过。他们还注意到，在交叉口（即节点）1和2，他们本可以选择不同的道路。'
- en: '![Five subfigures show the state of Hierholzer’s algorithm at different points.
    In (A), the options set has element 0\. In (B), the edges (0, 1), (1, 2), and
    (2, 0) are bolded. The options set has elements 1 and 2.](../images/f18011.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![五个子图展示了 Hierholzer 算法在不同阶段的状态。在（A）中，选项集包含元素 0。在（B）中，边（0, 1）、（1, 2）和（2, 0）被加粗显示。选项集包含元素
    1 和 2。](../images/f18011.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-11: The steps of
    Hierholzer’s algorithm on an example graph</samp>'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 18-11：Hierholzer 算法在示例图上的步骤</samp>
- en: The next day, the planner ventures to one of the nodes with untraveled edges
    to explore from there. As shown in [Figure 18-11(c)](#fig18-11), they choose to
    start at node 1 because it was reachable on a previous cycle and had unexplored
    options. They complete another small cycle [1, 3, 4, 1] before returning to node
    1 and discovering they have traversed all the adjacent streets. They update their
    map to remove roads (1, 3), (3, 4), and (4, 1) and note that there are unexplored
    streets branching out from intersections 2, 3, and 4\. They splice today’s path
    into yesterday’s path at node 1, providing a combined path of [0, 1, 3, 4, 1,
    2, 0].
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第二天，规划者前往一个未走过边的节点，从那里继续探索。如[图 18-11(c)](#fig18-11)所示，他们选择从节点 1 出发，因为它在之前的循环中是可达的，并且有未探索的选项。他们完成了另一个小循环
    [1, 3, 4, 1]，然后返回到节点 1，发现他们已经遍历了所有相邻的街道。他们更新了地图，删除了道路（1, 3）、（3, 4）和（4, 1），并注意到有未探索的街道从节点
    2、3 和 4 的交叉口分叉出来。他们将今天的路径拼接到昨天的路径中，形成了合并路径 [0, 1, 3, 4, 1, 2, 0]。
- en: The third day is similar, with the planner starting from node 2, as shown in
    [Figure 18-11(d)](#fig18-11). They complete the cycle [2, 4, 7, 2], delete the
    traveled streets, and extend the combined path to [0, 1, 3, 4, 1, 2, 4, 7, 2,
    0]. As they follow that day’s tour, they notice that they have traveled all roads
    adjacent to nodes 2 and 4\. They remove both nodes from their starting options,
    leaving only node 3.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第三天的情况类似，规划者从节点 2 出发，如[图 18-11(d)](#fig18-11)所示。他们完成了循环 [2, 4, 7, 2]，删除了已走的街道，并将已合并的路径扩展为
    [0, 1, 3, 4, 1, 2, 4, 7, 2, 0]。在这一天的旅行过程中，他们注意到已经走过了所有与节点 2 和 4 相邻的道路。他们从起始选项中移除了这两个节点，只剩下节点
    3。
- en: The final day starts at node 3, as shown in Figure 18-12(e). The planner travels
    [3, 5, 6, 3] and splices it into the combined path for an Eulerian cycle of [0,
    1, 3, 5, 6, 3, 4, 1, 2, 4, 7, 2, 0].
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一天从节点 3 开始，如图 18-12(e) 所示。规划者走了 [3, 5, 6, 3] 并将其拼接到已合并路径中，形成欧拉回路 [0, 1, 3,
    5, 6, 3, 4, 1, 2, 4, 7, 2, 0]。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">为什么这很重要</samp>
- en: The three problems discussed in this chapter—finding Hamiltonian and Eulerian
    paths and solving the traveling salesperson problem—have clear applications to
    a variety of real-world planning and optimization use cases. Rather than searching
    for a path from a given origin to a given destination like the problems in the
    previous two chapters, the problems covered here aim to find paths that visit
    each node or edge in the graph.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的三个问题——寻找哈密顿路径和欧拉路径以及解决旅行推销员问题——在各种现实世界的规划和优化应用中具有明确的应用场景。与前两章中从给定起点到给定终点寻找路径的问题不同，本章所涉及的问题旨在寻找访问图中每个节点或边的路径。
- en: These problems provide a foundation on which to build more complex tasks. We
    could extend the Eulerian path problem by adding pairwise ordering constraints.
    For example, the tourist might need to visit the city’s welcome center and buy
    tickets before they can ride the gondolas. A company might partition their cities
    among five salespeople, requiring them to assign cities as well as paths to each
    employee. The three formulations from this chapter barely scratch the surface
    of the interesting and complex questions we can ask.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题为构建更复杂的任务提供了基础。我们可以通过添加成对排序约束来扩展欧拉路径问题。例如，游客可能需要先参观城市的欢迎中心并购买票据，然后才能乘坐缆车。一家公司可能会将其城市分配给五名销售人员，要求他们为每位员工分配城市和路径。本章中的这三个问题仅仅是我们可以提出的有趣且复杂问题的冰山一角。
- en: The problems in this chapter also demonstrate that the difficulty of solving
    seemingly similar problems can actually vary greatly. While the tasks of finding
    Eulerian and Hamiltonian paths have similar real-world analogies, their worst-case
    computational costs vary significantly. Recognizing and understanding these types
    of differences is important when considering which approaches to use when tackling
    a novel problem.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的问题还表明，解决看似相似的问题的难度实际上可能差异很大。尽管寻找欧拉路径和哈密顿路径的任务有类似的现实世界类比，但它们的最坏情况计算成本差异显著。在解决新问题时，认识到并理解这些差异非常重要，这有助于我们决定采用何种方法。
