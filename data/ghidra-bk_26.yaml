- en: '## **21'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **21**'
- en: OBFUSCATED CODE ANALYSIS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆代码分析**
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: Even under ideal circumstances, comprehending a disassembly listing is a difficult
    task. High-quality disassemblies are essential for anyone trying to understand
    the inner workings of a binary, which is precisely why we have spent the last
    20 chapters discussing Ghidra and its associated capabilities. It can be argued
    that Ghidra is so effective at what it does that it has lowered the barrier for
    entry into the binary analysis field. While certainly not attributable to Ghidra
    alone, recent advances in binary reverse engineering are not lost on anyone who
    does not want their software to be analyzed. Thus, over the last several years,
    an arms race of sorts has been taking place between programmers who wish to keep
    their code secret and reverse engineers
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在理想的情况下，理解反汇编列表也是一项困难的任务。高质量的反汇编对于任何试图理解二进制文件内部工作原理的人都是至关重要的，这也是我们在过去20章中讨论Ghidra及其相关功能的原因。可以说，Ghidra在它的工作中如此高效，以至于它降低了进入二进制分析领域的门槛。虽然这绝不是Ghidra独有的成就，但二进制逆向工程的近期进展并没有被那些不希望自己的软件被分析的人忽视。因此，在过去的几年里，程序员与逆向工程师之间为了保持代码的机密性，进行了一场某种意义上的技术竞赛。
- en: In this chapter, we examine Ghidra’s role in this arms race and discuss some
    of the measures that have been taken to protect code, along with approaches to
    defeating those measures. We wrap up the chapter by introducing Ghidra’s `Emulator`
    class and provide examples of how emulation scripts can give us an edge in this
    arms race.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨Ghidra在这场技术竞赛中的作用，并讨论一些已采取的保护代码的措施，以及应对这些措施的方法。最后，我们将介绍Ghidra的`Emulator`类，并举例说明仿真脚本如何帮助我们在这场技术竞赛中占得先机。
- en: '### **Anti–Reverse Engineering**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '### **反向工程防护**'
- en: '*Anti–reverse engineering* is an umbrella topic that covers all techniques
    that software developers might employ to make reverse engineering their products
    more challenging. Many tools and techniques exist to assist developers with this
    goal, with more appearing every day. The RE/anti-RE ecosystem is similar to the
    escalating dynamic that plays out between malware authors and antivirus vendors.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*反向工程防护*是一个涵盖所有软件开发人员可能采用的技术的总称，这些技术的目的是使得逆向工程他们的产品变得更加具有挑战性。许多工具和技术存在，旨在帮助开发者实现这一目标，而且每天都有新的技术出现。RE/反RE生态系统类似于恶意软件作者与杀毒软件供应商之间的日益升级的动态。'
- en: As a reverse engineer, you are likely to encounter techniques ranging from trivial
    to nearly impossible to defeat. The approaches that you will be required to use
    will also vary depending on the nature of the anti-reversing techniques you encounter,
    and may require some level of comfort with both static and dynamic analysis techniques.
    In the sections that follow, we discuss some of the more common anti-reversing
    techniques, why they are employed, and approaches for defeating them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名逆向工程师，你可能会遇到从简单到几乎无法攻克的各种技术。你需要使用的方法也会根据你遇到的反逆向技术的性质而有所不同，可能需要一定程度上熟悉静态和动态分析技术。在接下来的章节中，我们将讨论一些常见的反逆向技术、它们为何被采用以及如何克服这些技术的方法。
- en: '***Obfuscation***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***混淆***'
- en: Various dictionary definitions will inform you that *obfuscation* is the act
    of making something obscure, perplexing, confusing, or bewildering in order to
    prevent others from understanding the obfuscated item. In the context of this
    book and the use of Ghidra, the items being obfuscated are binary executable files
    (as opposed to source files or silicon chips, for example).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 各种词典定义表明，*混淆*是指将某物变得模糊、复杂、混乱或令人困惑，以防止他人理解该混淆的项目。在本书的背景下，以及在使用Ghidra时，被混淆的项目是二进制可执行文件（而不是源文件或硅片等）。
- en: Obfuscation, by itself, is too broad to be considered an anti–reverse engineering
    technique. It also fails to cover all known anti–reverse engineering techniques.
    Specific, individual techniques can often be described as obfuscating or non-obfuscating
    techniques and, where applicable, we point these out in the sections that follow.
    It is important to note that there is no one correct way to categorize techniques,
    as the general categories often overlap in their descriptions. In addition, new
    anti–reverse engineering techniques are under continuous development, and it is
    not possible to provide a single all-inclusive list.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆本身过于广泛，不能被视为一种反逆向工程技术。它也无法涵盖所有已知的反逆向工程技术。具体的、单独的技术通常可以描述为混淆或非混淆技术，适用时，我们将在以下部分指出这些技术。需要注意的是，没有单一正确的方式来分类这些技术，因为一般类别的描述常常是重叠的。此外，新的反逆向工程技术正在不断发展，因此无法提供一个包罗万象的列表。
- en: 'Because Ghidra is primarily a static analysis tool, we find it more useful
    to divide our discussion of techniques into two, broad categories: *anti–static
    analysis* and *anti–dynamic analysis*. Both categories may contain obfuscating
    techniques, but the former is more likely to confound static tools, while the
    latter generally targets debuggers and other runtime analysis tools.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Ghidra 主要是一个静态分析工具，我们发现将技术讨论分为两个大类更为有用：*反静态分析*和*反动态分析*。这两个类别都可能包含混淆技术，但前者更可能会困扰静态工具，而后者通常是针对调试器和其他运行时分析工具的。
- en: '***Anti–Static Analysis Techniques***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***反静态分析技术***'
- en: '*Anti–static analysis techniques* aim to prevent an analyst from understanding
    the nature of a program without actually running the program. These are precisely
    the types of techniques that target disassemblers such as Ghidra and are thus
    of greatest concern whenever you are using Ghidra to reverse engineer binaries.
    Several types of anti–static analysis techniques are discussed here.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*反静态分析技术*旨在防止分析人员在不实际运行程序的情况下理解程序的性质。这正是针对像 Ghidra 这样的反汇编工具的技术，因此在使用 Ghidra
    进行二进制逆向工程时，这类技术是最值得关注的。这里讨论了几种反静态分析技术。'
- en: '##### **Disassembly Desynchronization**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '##### **反汇编同步化**'
- en: One of the older techniques designed to frustrate the disassembly process involves
    the creative use of instructions and data to prevent the disassembler from finding
    the correct starting address for one or more instructions. Forcing the disassembler
    to lose track of itself usually results in a failed or, at a minimum, incorrect
    disassembly listing. [Listing 21-1](ch21.xhtml#exa21_1) shows Ghidra’s efforts
    to disassemble a portion of the Shiva anti–reverse engineering tool.^([1](footnotes.xhtml#ch21fn1))
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一种较旧的技术旨在通过创造性地使用指令和数据，防止反汇编工具找到一个或多个指令的正确起始地址。强制反汇编工具失去方向通常会导致反汇编失败，或者至少是错误的反汇编结果。[列表
    21-1](ch21.xhtml#exa21_1) 显示了 Ghidra 在反汇编 Shiva 反逆向工程工具部分代码时的努力。^([1](footnotes.xhtml#ch21fn1))
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 21-1: Sample of initial Shiva disassembly*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 21-1：初步 Shiva 反汇编示例*'
- en: This example executes a `CALL` ➊ that is immediately followed by a `POP` ➌.
    This sequence is not uncommon in self-modifying code and is used by the code to
    discover where it is running memory. The return address ➋ for the call instruction
    is `0a04b0d6` and sits on the top of the stack as execution arrives at the `POP`
    instruction. The `POP` instruction removes the return address from the stack and
    loads it into `EAX`, while the `LEA` that follows ➍ immediately adds `0xa` (10)
    to `EAX` so that `EAX` now holds `0a04b0e0` (keep this value handy, as we’ll use
    it in a few moments).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例执行了一个 `CALL` ➊，紧接着是一个 `POP` ➌。这个序列在自修改代码中并不罕见，代码通过它来发现自己在哪个内存位置运行。调用指令的返回地址
    ➋ 是 `0a04b0d6`，它位于栈顶，当执行到 `POP` 指令时。`POP` 指令从栈中移除返回地址并将其加载到 `EAX` 寄存器中，紧接着的 `LEA`
    立即将 `0xa`（即 10）加到 `EAX` 中，这样 `EAX` 现在存储的是 `0a04b0e0`（请记住这个值，我们稍后会用到）。
- en: The called function is unlikely to ever return to the original call point, as
    the original return address is no longer on top of the stack (it would need to
    be replaced in order to `RET` to the original return location), and Ghidra cannot
    form an instruction at the return address ➋ because `C7h` is not a valid start
    byte for an instruction.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用的函数不太可能返回到原始的调用点，因为原始返回地址已经不在栈顶（它需要被替换才能 `RET` 回原来的返回位置），而且 Ghidra 无法在返回地址
    ➋ 处形成指令，因为 `C7h` 不是有效的指令起始字节。
- en: 'So far, the code may be a little unusual or difficult to follow, but Ghidra
    is presenting a correct disassembly. This all changes when the `JMP` ➎ instruction
    is reached. This jump instruction is 2 bytes long, its address is `0a04b0db`,
    and the jump target is `LAB_0a04b0db+1`. The `+1` suffix in the label is new to
    us. The address component of the label is the same as the address of the jump
    itself. The `+1` is telling you that the jump target is 1 byte past `LAB_0a04b0db`.
    In other words, the jump lands right in the middle of the 2-byte jump instruction.
    While the processor doesn’t care about this unusual situation (it will happily
    fetch whatever the instruction pointer points to), Ghidra just can’t make it work.
    Ghidra has no means to concurrently display the byte at `0a04b0db` (`ff`) as both
    the second byte of the jump and the first byte of another instruction. As a result,
    Ghidra is suddenly unable to continue with the disassembly, as indicated by the
    undefined data value at `0a04b0dd` ➏. (This behavior is not restricted to Ghidra:
    virtually all disassemblers, whether they utilize a recursive descent algorithm
    or a linear sweep algorithm, fall victim to this technique.)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，代码可能有点不寻常或者难以理解，但 Ghidra 展示的是正确的反汇编。当达到 `JMP` ➎ 指令时，情况就发生了变化。这条跳转指令长 2
    个字节，地址是 `0a04b0db`，跳转目标是 `LAB_0a04b0db+1`。标签中的 `+1` 后缀对我们来说是新的。标签的地址部分与跳转本身的地址相同。`+1`
    告诉你，跳转目标在 `LAB_0a04b0db` 之后 1 个字节。换句话说，跳转指令正好跳到了 2 字节跳转指令的中间。虽然处理器不在乎这种不寻常的情况（它会很高兴地获取指令指针所指向的内容），但
    Ghidra 无法处理这个问题。Ghidra 没有办法同时显示 `0a04b0db` 处的字节（`ff`）既是跳转指令的第二个字节，又是另一条指令的第一个字节。因此，Ghidra
    无法继续进行反汇编，这在 `0a04b0dd` 处的未定义数据值 ➏ 中得到了体现。（这种行为不仅限于 Ghidra：几乎所有反汇编器，无论是使用递归下降算法还是线性扫描算法，都无法避免这种技术带来的问题。）
- en: Ghidra makes note of any problems it encounters during disassembly by creating
    *error bookmarks* in the disassembly. [Figure 21-1](ch21.xhtml#fig21_1) shows
    two such bookmarks (X icon to the left of the offending addresses) in the left
    margin of the Listing window. Hovering over an error bookmark displays an associated
    detail message. In addition, you can open a listing of all bookmarks in the current
    binary by using Window ▸ Bookmarks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 在反汇编过程中会通过创建*错误书签*来记录它遇到的任何问题。[图 21-1](ch21.xhtml#fig21_1)显示了两个这样的书签（位于有问题地址左侧的
    X 图标），它们出现在列表窗口的左侧边距中。将鼠标悬停在错误书签上会显示相关的详细信息。此外，你可以通过使用窗口 ▸ 书签来打开当前二进制文件中所有书签的列表。
- en: Ghidra’s message for the first error is “Unable to resolve constructor at 0a04b0d6
    (flow from 0a04b0d1),” which means roughly “I think an instruction is supposed
    to exist at 0a04b0d6, but I couldn’t create one.” Ghidra’s message for the second
    error is “Failed to disassemble at 0a04b0dc due to conflicting instruction at
    0a04b0db (flow from 0a04b0db),” which means roughly “I cannot disassemble an instruction
    within an existing instruction.”
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 对第一个错误的提示是“无法解析位于 0a04b0d6 的构造函数（来自 0a04b0d1 的流程）”，大致意思是“我认为 0a04b0d6
    处应该存在一条指令，但我没能创建它。”Ghidra 对第二个错误的提示是“由于 0a04b0db 处的指令冲突（来自 0a04b0db 的流程），无法在 0a04b0dc
    处进行反汇编”，大致意思是“我无法在现有指令中反汇编一条指令。”
- en: '![image](Images/fig21-1.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig21-1.jpg)'
- en: '*Figure 21-1: Ghidra error bookmarks*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 21-1：Ghidra 错误书签*'
- en: 'As a Ghidra user, you have no solution for the first error. A byte sequence
    is either a valid instruction or it isn’t. With a bit of effort on your part,
    you can deal with the second error. The proper way to deal with this situation
    is to undefine the instruction that contains the bytes that are the target of
    the call and then define an instruction at the call target address in an attempt
    to resynchronize the disassembly. You will lose the original instruction, but
    you can leave yourself a comment to remind you of what the original instruction
    was. The following portion of the previous listing contains the overlapping instruction
    error:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Ghidra 用户，对于第一个错误你没有解决方案。一个字节序列要么是有效的指令，要么不是。对于第二个错误，通过一些努力你可以处理。解决这种情况的正确方法是取消定义包含目标调用字节的指令，然后在调用目标地址处定义一条指令，尝试重新同步反汇编。你将失去原始的指令，但可以留一个注释来提醒你原始指令是什么。以下是前面列出的包含重叠指令错误的部分：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Right-clicking the `JMP` instruction ➊ and selecting Clear Code Bytes (hotkey
    C) from the context menu yields the following listing of undefined bytes:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击 `JMP` 指令 ➊ 并从上下文菜单中选择清除代码字节（快捷键 C）将显示以下未定义字节的列表：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The byte that is the target ➊ of the `JMP` is now accessible for reformatting.
    Raw bytes are changed to code by right-clicking the start byte of an instruction
    and selecting Disassemble (hotkey D). The listing is now updated to the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`JMP`指令目标➊的字节现在可以进行重新格式化。通过右键点击指令的起始字节并选择反汇编（快捷键D），原始字节将被更改为代码。此时，列表已更新为以下内容：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The target of the jump instruction turns out to be yet another jump instruction
    ➊. In this case, however, the jump is impossible for a disassembler (and potentially
    confusing to the human analyst) to follow, as the target of the jump is contained
    in a register (`EAX`) and computed at runtime. This is an example of another type
    of anti–static analysis technique, discussed in the following section, “Dynamically
    Computed Target Addresses.” We previously determined that `EAX` contains the value
    `0a04b0e0` by the time we reach this jump, and this is the address at which we
    must resume the disassembly process. Lather, rinse, repeat.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转指令的目标结果是另一个跳转指令➊。 然而，在这种情况下，跳转对于反汇编器来说是无法跟踪的（并且可能会让人工分析员感到困惑），因为跳转的目标存储在寄存器（`EAX`）中，并在运行时计算得出。这是另一种反静态分析技术的示例，接下来的“动态计算目标地址”部分将讨论这一点。我们之前已经确定，在到达此跳转时，`EAX`的值为`0a04b0e0`，而这是我们必须从此地址恢复反汇编过程的位置。洗头、冲水、重复。
- en: Referring back to [Listing 21-1](ch21.xhtml#exa21_1), as an alternative to manually
    moving to address `0a04b0e0` to resume the disassembly, you can set the value
    of `EAX` to the known value by right-clicking the address ➌ and selecting Set
    Register Values. Ghidra will then add a special markup called a *register transition*
    around the instruction to indicate the *assumed* value of the `JMP` target, `EAX`.
    Subsequent clearing (hotkey C) and disassembling (hotkey D) from this location
    will restart the recursive descent disassembly process from the `JMP` to the target,
    `0a04b0e0`, and beyond (including creating the XREFs between those code blocks).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[清单 21-1](ch21.xhtml#exa21_1)，作为手动跳转到`0a04b0e0`地址恢复反汇编的替代方法，您可以通过右键点击地址➌并选择设置寄存器值来将`EAX`的值设置为已知值。Ghidra将为该指令添加一个称为*寄存器过渡*的特殊标记，以指示`JMP`目标`EAX`的*假定*值。随后从此位置清除（快捷键C）并反汇编（快捷键D）将重新启动递归下降反汇编过程，从`JMP`到目标`0a04b0e0`，并继续（包括在这些代码块之间创建交叉引用）。
- en: 'An advantage of this approach is that the code is annotated to show the target
    of the `JMP`, allowing other analysts to easily follow the effective control flow
    through this section. (This is even clearer when combined with an override to
    the fallthrough for the `LEA` instruction at `0a04b0d8` in [Listing 21-1](ch21.xhtml#exa21_1)).
    This alternative approach results in the following listing:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个优点是代码被注释，以显示`JMP`指令的目标，从而使其他分析人员能够轻松跟踪此部分的有效控制流。（当与`0a04b0d8`处的`LEA`指令的后续覆盖结合使用时，这一点更加清晰，见[清单
    21-1](ch21.xhtml#exa21_1)）。这种替代方法会产生以下的列表：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Another example of desynchronization taken from a different binary demonstrates
    how processor flags may be utilized to turn conditional jumps into absolute jumps.
    The following disassembly demonstrates the use of the x86 `Z` flag for just such
    a purpose:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个来自不同二进制文件的去同步化示例展示了处理器标志如何被用来将条件跳转转变为绝对跳转。以下反汇编示例展示了x86 `Z`标志如何用于这种目的：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, the `XOR` instruction ➊ is used to zero the `EAX` register and set the
    x86 `Z` flag. The programmer, knowing that the `Z` flag is set, utilizes a jump-on-zero
    (`JZ`) instruction ➋, which will always be taken, to attain the effect of an unconditional
    jump. As a result, the instructions between the jump ➋ and the jump target ➌ will
    never be executed and serve only to confuse any analyst who fails to realize this
    fact. This example also obscures the actual jump target by jumping into the middle
    of the `CALL` instruction at `00401009` ➍. Properly disassembled, the code should
    read as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`XOR`指令➊用于清零`EAX`寄存器并设置x86的`Z`标志。程序员知道`Z`标志已被设置，因此利用跳转零（`JZ`）指令➋，该指令将始终被执行，从而实现无条件跳转的效果。因此，跳转指令➋与跳转目标➌之间的指令将永远不会被执行，仅用于迷惑任何没有意识到这一点的分析员。这个例子还通过跳转到`00401009`处的`CALL`指令的中间➍来模糊实际的跳转目标。正确反汇编后，代码应如下所示：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The actual target of the jump ➋ has been revealed, as has the extra byte ➊ that
    caused the desynchronization in the first place. It is certainly possible to use
    far more roundabout ways of setting and testing flags prior to executing a conditional
    jump. The level of difficulty for analyzing such code increases with the number
    of operations that may affect the processor flag bits prior to testing their value.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转的实际目标➋已经揭示，同时导致最初不同步的额外字节➊也被揭示。确实可能使用更加间接的方法来设置和测试标志位，在执行条件跳转之前。分析这种代码的难度随着在测试处理器标志位之前可能影响标志位的操作数量增加而增加。
- en: '**Dynamically Computed Target Addresses**'
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**动态计算的目标地址**'
- en: The phrase *dynamically computed* simply means that an address to which execution
    will flow is computed at runtime. In this section, we discuss several ways in
    which such an address can be derived. The intent of such techniques is to hide
    (obfuscate) the actual control flow path that a binary will follow from the prying
    eyes of the static analysis process.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态计算*这一术语简单地意味着执行流向的地址是在运行时计算的。在本节中，我们讨论了几种计算该地址的方式。这些技术的目的是隐藏（混淆）二进制文件将要遵循的实际控制流路径，以避免静态分析过程的窥探。'
- en: One example of this technique was shown in the preceding section. The example
    used a call instruction to place a return address on the stack. The return address
    was popped directly off the stack into a register, and a constant value was added
    to the register to derive the final target address, which was ultimately reached
    by performing a jump to the location specified by the register contents.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本节前面展示了这一技术的一个示例。该示例使用了调用指令将返回地址压入栈中。返回地址被直接从栈中弹出到寄存器，并将常量值加到寄存器中以推导最终的目标地址，最终通过执行跳转指令跳转到寄存器内容指定的位置。
- en: 'An infinite number of similar code sequences can be developed for deriving
    a target address and transferring control to that address. The following code,
    also used in Shiva, demonstrates an alternate method for dynamically computing
    target addresses:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 可以开发出无限多种类似的代码序列来推导目标地址并将控制权转移到该地址。以下代码也是在Shiva中使用的，展示了动态计算目标地址的另一种方法：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The comments to the right of the semicolons document the changes being made
    to various processor registers at each instruction. The process culminates in
    a derived value being moved into the top position of the stack (`TOS`) ➊, which
    causes the return instruction to transfer control to the computed location (`0A048068`
    in this case). An analyst must essentially run the code by hand to determine the
    actual control flow path taken in the program.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 分号右侧的注释记录了每条指令对各种处理器寄存器所做的更改。该过程最终将计算出的值移到栈的顶部位置（`TOS`）➊，这导致返回指令将控制权转移到计算得到的位置（此例为`0A048068`）。分析员本质上必须手动运行代码，以确定程序实际执行的控制流路径。
- en: '**Obfuscated Control Flow**'
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**混淆的控制流**'
- en: Much more complex methods to hide control flow have been developed and utilized
    in recent years. In the most complex cases, a program will use multiple threads
    or child processes to compute control flow information and receive that information
    via some form of interprocess communication (for child processes) or synchronization
    primitives (for multiple threads).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，已经开发和使用了更为复杂的控制流隐藏方法。在最复杂的情况下，一个程序会使用多个线程或子进程来计算控制流信息，并通过某种形式的进程间通信（对于子进程）或同步原语（对于多个线程）来接收这些信息。
- en: In such cases, static analysis can become extremely difficult, as it becomes
    necessary to understand not only the behavior of multiple executable entities
    but also the exact manner by which those entities exchange information. For example,
    one thread may wait on a shared semaphore object, while a second thread computes
    values or modifies code that the first thread will make use of after the second
    thread signals its completion via the semaphore.^([2](footnotes.xhtml#ch21fn2))
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，静态分析可能变得非常困难，因为不仅需要理解多个可执行实体的行为，还需要理解这些实体交换信息的具体方式。例如，一个线程可能会等待一个共享信号量对象，而第二个线程计算值或修改代码，第一线程将在第二个线程通过信号量发出完成信号后使用这些数据。^([2](footnotes.xhtml#ch21fn2))
- en: 'Another technique, frequently used within Windows malware, involves configuring
    an exception handler,^([3](footnotes.xhtml#ch21fn3)) intentionally triggering
    an exception, and then manipulating the state of the process’s registers while
    handling the exception. The following example is used by the tElock anti–reverse
    engineering tool to obscure the program’s actual control flow:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种技术，通常用于Windows恶意软件中，涉及配置一个异常处理程序，^([3](footnotes.xhtml#ch21fn3))故意触发一个异常，然后在处理异常时操控进程寄存器的状态。以下示例是tElock反逆向工程工具用于掩盖程序实际控制流的方式：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The sequence begins by using a `CALL` ➊ to the next instruction ➋; the `CALL`
    instruction pushes `0041d07f` onto the stack as a return address, which is promptly
    popped off the stack into the `EBP` register ➋. Next, the `EAX` register ➌ is
    set to the sum of `EBP` and `46h`, or `0041d0c5`, and this address is pushed onto
    the stack ➍ as the address of an exception handler function. The remainder of
    the exception handler setup takes place at ➎ and ➏, which complete the process
    of linking the new exception handler into the existing chain of exception handlers
    referenced by `FS:[0]`.^([4](footnotes.xhtml#ch21fn4))
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该序列首先通过`CALL` ➊调用下一个指令 ➋；`CALL`指令将`0041d07f`推入栈中作为返回地址，随后该地址被弹出并存入`EBP`寄存器 ➋。接下来，`EAX`寄存器
    ➌被设置为`EBP`和`46h`的和，即`0041d0c5`，该地址作为异常处理程序函数的地址被推入栈中 ➍。异常处理程序的其余设置发生在➎和➏处，这完成了将新的异常处理程序链接到由`FS:[0]`引用的现有异常处理程序链中的过程。^([4](footnotes.xhtml#ch21fn4))
- en: The next step is to intentionally generate an exception ➐, in this case an `INT
    3`, which is a software trap (interrupt) to the debugger. (In x86 programs, the
    `INT 3` instruction is used by debuggers to implement a software breakpoint.)
    Normally at this point, an attached debugger would gain control, as debuggers
    are given the first opportunity to handle the exception. In this case, the program
    fully expects to handle the exception, so any attached debugger must be instructed
    to pass the exception along to the program. Not allowing the program to handle
    the exception may cause the program to operate incorrectly or crash. Without understanding
    how the `INT 3` exception is handled, it is impossible to know what may happen
    next in this program. If we assume that execution simply resumes following the
    `INT 3`, then it appears that a divide-by-zero exception will eventually be triggered
    by instructions ➑ and ➒.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是故意生成一个异常➐，在本例中是一个`INT 3`，它是一个软件陷阱（中断），用于调试器。（在x86程序中，`INT 3`指令被调试器用来实现软件断点。）通常在此时，附加的调试器会获得控制权，因为调试器有机会首先处理该异常。在本例中，程序完全预期会处理该异常，因此任何附加的调试器必须被指示将异常传递给程序。不允许程序处理异常可能导致程序运行不正常或崩溃。如果没有理解如何处理`INT
    3`异常，就无法知道程序接下来会发生什么。如果我们假设执行在`INT 3`之后简单地恢复，那么看起来除法零异常将在指令➑和➒之后最终被触发。
- en: 'The decompiled version of the exception handler associated with the preceding
    code begins at address `0041d0c5`. The first portion of this function is shown
    here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的代码相关联的异常处理程序的反汇编版本从地址`0041d0c5`开始。该函数的第一部分如下所示：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The third argument to the exception handler function ➊ is a pointer to a Windows
    `CONTEXT` structure (defined in the Windows API header file *winnt.h*). The `CONTEXT`
    structure is initialized with the contents of all processor registers as they
    existed at the time of the exception. An exception handler has the opportunity
    to inspect and, if desired, modify the contents of the `CONTEXT` structure. If
    the exception handler feels that it has corrected the problem that led to the
    exception, it can notify the operating system that the offending thread should
    be allowed to continue. At this point, the operating system reloads the processor
    registers for the thread from the `CONTEXT` structure that was provided to the
    exception handler, and execution of the thread resumes as if nothing had ever
    happened.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理程序函数 ➊的第三个参数是一个指向Windows `CONTEXT`结构的指针（在Windows API头文件*winnt.h*中定义）。`CONTEXT`结构通过包含异常发生时所有处理器寄存器的内容来初始化。异常处理程序有机会检查并在需要时修改`CONTEXT`结构的内容。如果异常处理程序认为它已修复导致异常的问题，它可以通知操作系统允许出现问题的线程继续执行。此时，操作系统从提供给异常处理程序的`CONTEXT`结构中重新加载线程的处理器寄存器，然后线程的执行将恢复，就像什么都没有发生过一样。
- en: In the preceding example, the exception handler begins by accessing the thread’s
    `CONTEXT` in order to increment the instruction pointer ➋, to allow execution
    to resume at the instruction following the one that generated the exception. Next,
    the exception’s type code (a field within the provided `EXCEPTION_RECORD`) is
    retrieved ➌ in order to determine the nature of the exception. This portion of
    the exception handler handles the divide-by-zero error ➍, generated in the previous
    example, by zeroing ➎ all of the x86 hardware debugging registers and disabling
    hardware breakpoints.^([5](footnotes.xhtml#ch21fn5)) Without examining the remainder
    of the tElock code, it is not immediately apparent why the debug registers are
    being cleared. In this case, tElock is clearing values from a previous operation
    in which it used the debug registers to set four breakpoints in addition to the
    `INT 3` seen previously. In addition to obfuscating the true flow of the program,
    clearing or modifying the x86 debug registers can wreak havoc for software debuggers
    such as OllyDbg or GDB. Such anti-debugging techniques are discussed in “[Anti–Dynamic
    Analysis Techniques](ch21.xhtml#ch21lev394)” on [page 487](ch21.xhtml#page_487).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，异常处理程序首先访问线程的`CONTEXT`，以便递增指令指针 ➋，允许执行继续进行，跳过生成异常的那条指令。接下来，获取异常的类型代码（`EXCEPTION_RECORD`中的一个字段）
    ➌ ，以确定异常的性质。异常处理程序的这一部分处理了前面例子中产生的除以零错误 ➍，通过将所有x86硬件调试寄存器清零 ➎ 并禁用硬件断点。^([5](footnotes.xhtml#ch21fn5))
    在没有检查剩余的tElock代码之前，无法立即理解为什么要清空调试寄存器。在这种情况下，tElock清除了来自之前操作的值，其中它使用调试寄存器设置了四个断点，除了之前看到的`INT
    3`。除了混淆程序的真实执行流，清空或修改x86调试寄存器可能会对软件调试工具（如OllyDbg或GDB）造成严重干扰。此类反调试技术在[第487页](ch21.xhtml#page_487)的“[反动态分析技术](ch21.xhtml#ch21lev394)”中有讨论。
- en: '**Opcode Obfuscation**'
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**操作码混淆**'
- en: While the techniques described to this point may provide—in fact, are intended
    to provide—a hindrance to understanding a program’s control flow, none prevent
    you from observing the correct disassembled form of a program you are analyzing.
    Desynchronization had the greatest impact on the disassembly, but it was easily
    defeated by reformatting the disassembly to reflect the correct instruction flow.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然到目前为止所描述的技术确实为理解程序的控制流提供了——实际上，它们旨在提供——一定的障碍，但没有一种方法能够完全防止你观察正在分析的程序的正确反汇编形式。反同步化对反汇编影响最大，但通过重新格式化反汇编以反映正确的指令流，轻松战胜了这一技术。
- en: A more effective technique for preventing correct disassembly is to encode or
    encrypt the actual instructions when the executable file is being created. The
    obfuscated instructions must be deobfuscated back to their original form before
    they are fetched for execution by the processor. Therefore, at least some portion
    of the program must remain unencrypted in order to serve as the startup routine,
    which, in the case of an obfuscated program, is usually responsible for deobfuscating
    some or all of the remainder of the program. A very generic overview of the obfuscation
    process is shown in [Figure 21-2](ch21.xhtml#fig21_2).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 防止正确反汇编的一个更有效的技术是在可执行文件创建时对实际指令进行编码或加密。混淆的指令必须在被处理器取出执行之前恢复为原始形式。因此，程序的至少一部分必须保持未加密状态，以作为启动例程，在混淆程序的情况下，这通常负责将程序的其余部分部分或全部进行反混淆。[图
    21-2](ch21.xhtml#fig21_2)展示了混淆过程的一个非常通用的概览。
- en: '![image](Images/fig21-2.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig21-2.jpg)'
- en: '*Figure 21-2: Generic obfuscation process*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 21-2：通用混淆过程*'
- en: As shown, the input to the process is a program to be obfuscated. In many cases,
    the input program is written using standard programming languages and build tools
    (editors, compiler, and the like) with little thought required about the obfuscation
    to come. The resulting executable file is fed into an obfuscation utility that
    transforms the binary into a functionally equivalent, yet obfuscated, binary.
    As depicted, the obfuscation utility is responsible for obfuscating the original
    program’s code and data sections and adding additional code (a deobfuscation stub)
    that performs the task of deobfuscating the code and data before the original
    functionality can be accessed at runtime. The obfuscation utility also modifies
    the program headers to redirect the program entry point to the deobfuscation stub,
    ensuring that execution begins with the deobfuscation process. Following deobfuscation,
    execution typically transfers to the entry point of the original program, which
    begins execution as if it had never been obfuscated at all.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，输入到该过程的是一个需要混淆的程序。在许多情况下，输入程序使用标准编程语言和构建工具（如编辑器、编译器等）编写，对即将进行的混淆几乎没有考虑。生成的可执行文件被输入到一个混淆工具，该工具将二进制文件转换为一个功能上等效但被混淆的二进制文件。如图所示，混淆工具负责混淆原始程序的代码和数据部分，并添加额外的代码（去混淆存根），该存根在运行时能够执行去混淆操作，使得原始功能能够被访问。混淆工具还会修改程序头信息，将程序入口点重定向到去混淆存根，确保执行从去混淆过程开始。去混淆后，执行通常会转移到原始程序的入口点，程序开始执行，就好像它从未被混淆过一样。
- en: This oversimplified process varies widely based on the obfuscation utility that
    is used to create the obfuscated binary. An ever-increasing number of utilities
    are available to handle the obfuscation process. Such utilities offer features
    ranging from compression to anti-disassembly and anti-debugging techniques. Examples
    include programs such as UPX (compressor, also works with ELF; *[https://upx.github.io/](https://upx.github.io/)*),
    ASPack (compressor; *[http://www.aspack.com/](http://www.aspack.com/)*), ASProtect
    (anti–reverse engineering by the makers of ASPack), and tElock (compression and
    anti–reverse engineering; *[http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/Telock.shtml](http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/Telock.shtml)*.)
    for Windows PE files. The capabilities of obfuscation utilities have advanced
    to the point that some anti–reverse engineering tools such as VMProtect integrate
    with the entire build process, allowing programmers to integrate anti–reverse
    engineering features at every stage of development, from source code through post-processing
    the compiled binary file (*[https://vmpsoft.com/](https://vmpsoft.com/)*).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过于简化的过程根据所使用的混淆工具而有很大差异。现有越来越多的工具可用于处理混淆过程。这些工具提供了从压缩到反反汇编和反调试等技术的各种功能。例如，像UPX（压缩工具，也支持ELF；*
    [https://upx.github.io/](https://upx.github.io/)*）、ASPack（压缩工具；* [http://www.aspack.com/](http://www.aspack.com/)*）、ASProtect（反逆向工程，由ASPack开发者制作）、tElock（压缩和反逆向工程；*
    [http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/Telock.shtml](http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/Telock.shtml)*）等程序适用于Windows
    PE文件。混淆工具的功能已经发展到某些反逆向工程工具（如VMProtect）可以与整个构建过程集成，使得程序员能够在开发的每个阶段，从源代码到编译后的二进制文件后处理，集成反逆向工程功能（*
    [https://vmpsoft.com/](https://vmpsoft.com/)*）。
- en: '**SANDBOX ENVIRONMENTS**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**沙箱环境**'
- en: The purpose of a *sandbox environment* for reverse engineering is to allow you
    to execute programs in a manner that allows observation of the program’s behavior
    without allowing that behavior to adversely impact critical components of your
    reverse engineering platform or anything it is connected to. Sandbox environments
    are commonly constructed using platform virtualization software, but they may
    be constructed on dedicated systems that are capable of being restored to a known-good
    state following the execution of any malware.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 反向工程的*沙箱环境*的目的是让你以一种能够观察程序行为的方式执行程序，而不会让这种行为对反向工程平台的关键组件或其连接的任何内容产生不利影响。沙箱环境通常使用平台虚拟化软件构建，但也可以在能够在执行任何恶意软件后恢复到已知良好状态的专用系统上构建。
- en: Sandbox systems are typically heavily instrumented in order to observe and collect
    information on the behavior of programs run within the sandbox. Collected data
    may include information on the filesystem activity of a program, the registry
    activity of a (Windows) program, and information about any networking activity
    generated by the program. One example of a complete sandbox environment is Cuckoo
    (*[https://cuckoosandbox.org/](https://cuckoosandbox.org/)*), a popular open source
    sandbox specifically oriented toward malware analysis.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 沙箱系统通常会进行大量的监控，以便观察和收集运行在沙箱内的程序的行为信息。收集的数据可能包括程序的文件系统活动、（Windows）程序的注册表活动以及程序生成的任何网络活动信息。一个完整的沙箱环境的例子是Cuckoo
    (*[https://cuckoosandbox.org/](https://cuckoosandbox.org/)*)，它是一个专门用于恶意软件分析的流行开源沙箱。
- en: As with any offensive technology, defensive measures have been developed to
    counter many anti–reverse engineering tools. In most cases, the goal of such tools
    is to recover the original, unprotected executable file (or a reasonable facsimile),
    which can then be analyzed using more traditional tools such as disassemblers
    and debuggers.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 和任何进攻性技术一样，防御措施也已被开发出来，以应对许多反反向工程工具。在大多数情况下，这些工具的目标是恢复原始的、未保护的可执行文件（或一个合理的副本），然后可以使用更传统的工具，如反汇编器和调试器，进行分析。
- en: One such tool designed to deobfuscate Windows executables is called QuickUnpack
    (*[http://qunpack.ahteam.org/?p=458](http://qunpack.ahteam.org/?p=458)*; site
    is in Russian). QuickUnpack, like many other automated unpackers, operates by
    functioning as a debugger and allowing an obfuscated binary to execute through
    its deobfuscation phase and then capturing the process image from memory. Beware
    that this type of tool actually runs potentially malicious programs in the hope
    of intercepting the execution of those programs after they have unpacked or deobfuscated
    themselves but before they have a chance to do anything malicious. Thus, you should
    always execute such programs in a sandbox-type environment.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个旨在去混淆Windows可执行文件的工具叫做QuickUnpack (*[http://qunpack.ahteam.org/?p=458](http://qunpack.ahteam.org/?p=458)*；该网站为俄语)。QuickUnpack与许多其他自动解包器一样，通过充当调试器，允许一个混淆的二进制文件通过其去混淆阶段执行，然后捕获内存中的进程镜像。请注意，这种类型的工具实际上是运行潜在的恶意程序，目的是在这些程序解包或去混淆后但尚未做出恶意行为之前拦截它们的执行。因此，您应该始终在沙箱类型的环境中执行此类程序。
- en: 'Using a purely static analysis environment to analyze obfuscated code is a
    challenging task. Without being able to execute the deobfuscation stub, the obfuscated
    portions of the binary must be unpacked or decrypted before disassembly can begin.
    The Ghidra Address Type overview bar, at right in [Figure 21-3](ch21.xhtml#fig21_3),
    shows the layout of an executable that has been packed using the UPX packer. Ghidra
    color-codes content in the overview bar to give you an indication of the associated
    content in the binary. The general categories for the overview bar include the
    following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯静态分析环境来分析混淆代码是一项具有挑战性的任务。在无法执行去混淆存根的情况下，必须先解包或解密二进制文件中的混淆部分，然后才能开始反汇编。右侧的Ghidra地址类型概览栏（见[图21-3](ch21.xhtml#fig21_3)）显示了使用UPX打包器打包的可执行文件的布局。Ghidra在概览栏中对内容进行颜色编码，以便指示二进制文件中相关内容。概览栏的常见类别包括以下内容：
- en: Function
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能
- en: Uninitialized
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未初始化
- en: External Reference
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部引用
- en: Instruction
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令
- en: Data
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据
- en: Undefined
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义
- en: Focusing on the overview bar in the figure, we can see Ghidra’s preliminary
    assessment of various parts of the binary. Hovering over any of the sections in
    the overview bar will provide additional information about the corresponding region
    of the binary. The unusual appearance of this particular navigation bar is a tip-off
    that this binary has been obfuscated in some manner. Let’s take a closer look
    at some of the sections in the overview bar.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过图中的概览栏，我们可以看到Ghidra对二进制文件各个部分的初步评估。将鼠标悬停在概览栏的任何部分上，都会提供关于该二进制文件相应区域的附加信息。这个特别的导航栏的异常外观是一个提示，表明这个二进制文件以某种方式被混淆了。让我们更仔细地查看概览栏中的一些部分。
- en: 'Ghidra has identified a data section ➊ at the start of the file. Examining
    this content reveals the headers for the file along with informative content that
    is indicative of the type of obfuscation used on this file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra在文件开始处识别出了一个数据段➊。检查此内容后，可以看到文件的头信息以及一些指示文件使用的混淆类型的内容：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![image](Images/fig21-3.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig21-3.jpg)'
- en: '*Figure 21-3: Ghidra Listing window and Address Type overview bar for a binary
    packed using UPX*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 21-3：使用 UPX 压缩的二进制文件的 Ghidra Listing 窗口和地址类型概览栏*'
- en: 'This section is followed by a block of undefined content ➋ similar to the following,
    which appears in the Listing window:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本节后面是一个未定义内容块 ➋，类似于以下内容，它出现在 Listing 窗口中：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The largest section ➌ contains uninitialized data, which appears as follows
    in the Listing window:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的部分 ➌ 包含未初始化的数据，在 Listing 窗口中显示如下：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A little farther in the file, Ghidra has identified another block of undefined
    content ➍. At the end of this data is a region that Ghidra has identified as a
    function ➎. This function is easily recognizable as the UPX decompression stub,
    which Ghidra has identified as the entry point for the binary, as shown in the
    Listing window on the left in [Figure 21-3](ch21.xhtml#fig21_3). The undefined
    content segments we observed ➋➍ are the result of the UPX compression process.
    The job of the decompression stub is to unpack that data into the uninitialized
    region ➌ before finally transferring control to the unpacked code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件稍后的部分，Ghidra 识别出了另一个未定义的内容块 ➍。该数据的末尾是 Ghidra 识别为一个函数的区域 ➎。该函数很容易识别为 UPX 解压缩存根，Ghidra
    已将其标识为二进制文件的入口点，如 [图 21-3](ch21.xhtml#fig21_3) 左侧的 Listing 窗口所示。我们观察到的未定义内容块 ➋➍
    是 UPX 压缩过程的结果。解压存根的任务是将这些数据解包到未初始化区域 ➌ 中，最后将控制权转移到解压后的代码。
- en: The information presented by the Address Type overview bar can be correlated
    with the properties of each segment within the binary to determine whether the
    information presented in each display is consistent. The memory map for this binary
    is shown in [Figure 21-4](ch21.xhtml#fig21_4).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 地址类型概览栏提供的信息可以与二进制文件中每个段的属性相关联，以确定每个显示的信息是否一致。此二进制文件的内存映射如 [图 21-4](ch21.xhtml#fig21_4)
    所示。
- en: '![image](Images/fig21-4.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig21-4.jpg)'
- en: '*Figure 21-4: Memory map of a UPX packed binary*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 21-4：UPX 压缩二进制文件的内存映射*'
- en: In this particular binary, the entire range of addresses contained in segment
    `UPX0` ➊ and segment `UPX1` ➋ (`00401000`–`00408fff`) is marked as executable
    (the X flag is set). Given this fact, we should expect to see the entire Address
    Type overview bar colorized to represent functions. The fact that we do not, coupled
    with the fact that the entire range of `UPX0` is uninitialized and writable, should
    be considered highly suspicious and provides valuable clues about the binary and
    how we might proceed with analysis.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的二进制文件中，包含在 `UPX0` ➊ 和 `UPX1` ➋ 段中的整个地址范围（`00401000`–`00408fff`）被标记为可执行的（X
    标志已设置）。鉴于这一点，我们应该期望看到整个地址类型概览栏的颜色被标记为表示函数。然而，事实上我们没有看到这一点，并且 `UPX0` 段的整个范围未初始化且可写，这应被视为非常可疑，并为我们提供了关于该二进制文件的重要线索，帮助我们继续进行分析。
- en: Techniques for using Ghidra to perform the decompression operation in a static
    context (without actually executing the binary) on files such as this one are
    discussed in “[Static Deobfuscation of Binaries Using Ghidra](ch21.xhtml#ch21lev399)”
    on [page 491](ch21.xhtml#page_491).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ghidra 在静态环境中（不实际执行二进制文件）对此类文件进行解压操作的技术，讨论了“[使用 Ghidra 对二进制文件进行静态去混淆](ch21.xhtml#ch21lev399)”的内容，见
    [第 491 页](ch21.xhtml#page_491)。
- en: '***Imported Function Obfuscation***'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***导入函数混淆***'
- en: Anti–static analysis techniques may also hide which shared libraries and library
    functions a binary uses in order to avoid leaking information about potential
    actions that the binary may perform. In most cases, it is possible to render tools
    such as `dumpbin`, `ldd`, and `objdump` ineffective for the purposes of listing
    library dependencies.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 反静态分析技术也可能隐藏二进制文件使用的共享库和库函数，以避免泄露关于二进制文件可能执行的潜在操作的信息。在大多数情况下，可以使像 `dumpbin`、`ldd`
    和 `objdump` 这样的工具在列出库依赖项时失效。
- en: The effect of such obfuscations on Ghidra is most obvious in the Symbol Tree.
    The entire Symbol Tree for our earlier tElock example is shown in [Figure 21-5](ch21.xhtml#fig21_5).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种混淆对 Ghidra 的影响在符号树中最为明显。我们之前提到的 tElock 示例的完整符号树如 [图 21-5](ch21.xhtml#fig21_5)
    所示。
- en: '![image](Images/fig21-5.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig21-5.jpg)'
- en: '*Figure 21-5: Symbol Tree for obfuscated binary*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 21-5：混淆二进制文件的符号树*'
- en: 'Only two imported functions are referenced: `GetModulehandleA` (from *kernel32.dll*)
    and `MessageBoxA` (from *user32.dll*). Virtually nothing about the behavior of
    the program can be inferred from this short list. Here again the techniques are
    varied but essentially boil down to the fact that the program itself must load
    any additional libraries that it depends on, and once the libraries are loaded,
    the program must locate any required functions within those libraries. In most
    cases, these tasks are performed by the deobfuscation stub prior to transferring
    control to the deobfuscated program. The end goal is for the program’s import
    table to have been properly initialized, just as if the process had been performed
    by the operating system’s own loader.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 只有两个被引用的导入函数：`GetModulehandleA`（来自*kernel32.dll*）和`MessageBoxA`（来自*user32.dll*）。从这个简短的列表中几乎无法推测程序的行为。这里采用的技巧多种多样，但本质上归结为程序本身必须加载它所依赖的任何附加库，并且一旦这些库被加载，程序必须在这些库中找到所需的函数。在大多数情况下，这些任务由去混淆存根执行，在将控制权转交给去混淆后的程序之前。最终目标是使程序的导入表已正确初始化，就像操作系统自己的加载器执行的那样。
- en: For Windows binaries, a simple approach is to use the `LoadLibrary` function
    to load required libraries by name and then use the `GetProcAddress` function
    to perform function address lookups within each library. To use these functions,
    a program must either be explicitly linked to them or have an alternate means
    of looking them up. The Symbol Tree for the tElock example does not include either
    of these functions, while the Symbol Tree for the UPX example, shown in [Figure
    21-6](ch21.xhtml#fig21_6), includes both.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows二进制文件，一种简单的方法是使用`LoadLibrary`函数按名称加载所需的库，然后使用`GetProcAddress`函数在每个库中执行函数地址查找。要使用这些函数，程序必须显式链接到它们，或者有其他方式进行查找。tElock示例的符号树中不包含这两个函数，而UPX示例的符号树，如[图21-6](ch21.xhtml#fig21_6)所示，包含了这两个函数。
- en: '![image](Images/fig21-6.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig21-6.jpg)'
- en: '*Figure 21-6: Symbol Tree for UPX example*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图21-6：UPX示例的符号树*'
- en: The actual UPX code responsible for rebuilding the import table is shown in
    [Listing 21-2](ch21.xhtml#exa21_2).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 负责重建导入表的实际UPX代码见于[清单21-2](ch21.xhtml#exa21_2)。
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 21-2: Import table reconstruction in UPX*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单21-2：UPX中的导入表重建*'
- en: This example contains an outer loop responsible for calling `LoadLibrary` ➊
    and an inner loop responsible for calling `GetProcAddress` ➋. Following each successful
    call to `GetProcAddress`, the newly retrieved function address is stored into
    the reconstructed import table ➌.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例包含一个外部循环，负责调用`LoadLibrary` ➊，以及一个内部循环，负责调用`GetProcAddress` ➋。每次成功调用`GetProcAddress`后，新的函数地址会被存储到重建的导入表中
    ➌。
- en: These loops are executed as the last portion of the UPX deobfuscation stub,
    because each function takes string pointer parameters that point to either a library
    name or a function name, and the associated strings are held within the compressed
    data region to avoid detection by the `strings` utility. As a result, library
    loading in UPX cannot take place until the required strings have been decompressed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些循环是在UPX去混淆存根的最后部分执行的，因为每个函数都采用指向库名或函数名的字符串指针参数，而相关的字符串被保存在压缩数据区域中，以避免被`strings`工具检测到。因此，UPX中的库加载无法在所需的字符串被解压之前进行。
- en: Returning to the tElock example, a different problem presents itself. With only
    two imported functions, neither of which is `LoadLibrary` or `GetProcAddress`,
    how can the tElock utility perform the function-resolution tasks that were performed
    by UPX? All Windows processes depend on *kernel32.dll*, which means that it is
    present in memory for all processes. If a program can locate *kernel32.dll*, a
    relatively straightforward process may be followed to locate any function within
    the DLL, including `LoadLibrary` and `GetProcAddress`. As shown previously, with
    these two functions in hand, it is possible to load any additional libraries required
    by the process and locate all required functions within those libraries.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 回到tElock示例，出现了一个不同的问题。只有两个导入函数，而且都不是`LoadLibrary`或`GetProcAddress`，那么tElock工具如何执行UPX所执行的函数解析任务呢？所有Windows进程都依赖于*kernel32.dll*，这意味着它在所有进程的内存中都存在。如果一个程序能够定位到*kernel32.dll*，那么可以遵循一个相对简单的过程来定位该DLL中的任何函数，包括`LoadLibrary`和`GetProcAddress`。如前所示，拥有这两个函数后，就可以加载进程所需的任何附加库，并在这些库中找到所有必需的函数。
- en: 'In his paper “Understanding Windows Shellcode,” Skape discusses techniques
    for doing exactly this.^([6](footnotes.xhtml#ch21fn6)) While tElock does not use
    the exact techniques detailed by Skape, there are many parallels, and the net
    effect is to obscure the details of the loading and linking process. Without carefully
    tracing the program’s instructions, it is extremely easy to overlook the loading
    of a library or the lookup of a function address. The following small code fragment
    illustrates the manner in which tElock attempts to locate the address of `LoadLibrary`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的论文《理解 Windows Shellcode》中，Skape 讨论了执行此操作的技术。^([6](footnotes.xhtml#ch21fn6))
    虽然 tElock 并未使用 Skape 详细描述的具体技术，但两者之间有许多相似之处，最终的效果是掩盖加载和链接过程的细节。如果没有仔细追踪程序的指令，很容易忽略库的加载或函数地址的查找。以下小段代码展示了
    tElock 尝试定位 `LoadLibrary` 地址的方式：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is immediately obvious that several comparisons are taking place in rapid
    succession. What may not be immediately clear is the purpose of these comparisons.
    Reformatting the operands (right-click and then choose **Convert** ▸ **Char Sequence**)
    used in each comparison sheds a little light on the code, as seen in the following
    listing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，多个比较操作迅速接连进行。可能不太明显的是这些比较的目的。重新格式化每个比较中使用的操作数（右键点击，然后选择 **转换** ▸ **字符序列**）能稍微揭示一些代码的含义，如下所示的清单所示。
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Each hexadecimal constant is actually a sequence of four ASCII characters, which
    Ghidra is capable of displaying as quoted ASCII and, together, spell `LoadLibraryA`.^([7](footnotes.xhtml#ch21fn7))
    If the three comparisons succeed, tElock has located the export table entry for
    `LoadLibraryA` and in a few short operations will obtain the address of this function
    for loading additional libraries. tElock’s approach to function lookup is somewhat
    resistant to string analysis because the 4-byte constants embedded directly in
    the program’s instructions do not look like standard, null-terminated strings
    and thus do not get included in the list of strings generated by Ghidra unless
    you change the defaults (for example, unchecking the Require Null Termination
    option during your string search).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每个十六进制常量实际上是一组四个 ASCII 字符，Ghidra 能够将其显示为引用的 ASCII 字符，并一起拼写出 `LoadLibraryA`。^([7](footnotes.xhtml#ch21fn7))
    如果三个比较成功，tElock 就找到了 `LoadLibraryA` 的导出表项，并通过几次简单的操作获取该函数的地址，以加载更多的库。tElock 的函数查找方式在一定程度上抵抗字符串分析，因为嵌入程序指令中的
    4 字节常量不像标准的以 null 终止的字符串，因此除非你更改默认设置（例如，在字符串搜索时取消勾选“需要 null 终止”选项），否则这些常量不会被包含在
    Ghidra 生成的字符串列表中。
- en: Manually reconstructing a program’s import table through careful analysis of
    the program’s code is made easier in the case of UPX and tElock because, ultimately,
    both contain ASCII character data that you can use to determine exactly which
    libraries and which functions are being referenced. Skape’s paper details a function-resolution
    process in which no strings at all appear within the code. The basic idea discussed
    in the paper is to precompute a unique hash value for the name of each function
    that you need to resolve.^([8](footnotes.xhtml#ch21fn8)) To resolve each function,
    you can search through a library’s exported names table. Each name in the table
    is hashed, and you can compare the resulting hash against the precomputed hash
    value for the desired function. If the hashes match, you have located the desired
    function, and can easily locate its address in the library’s export address table.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仔细分析程序代码手动重建程序的导入表，在 UPX 和 tElock 的情况下会更加容易，因为最终，这两者都包含 ASCII 字符数据，你可以利用这些数据来准确确定所引用的库和函数。Skape
    的论文详细描述了一个函数解析过程，其中代码中根本没有出现任何字符串。论文中讨论的基本思路是为每个需要解析的函数名称预先计算一个唯一的哈希值。^([8](footnotes.xhtml#ch21fn8))
    要解析每个函数，你可以在一个库的导出名称表中进行查找。表中的每个名称都被哈希化，你可以将生成的哈希值与预先计算的哈希值进行比较。如果哈希值匹配，你就找到了所需的函数，并可以轻松地在库的导出地址表中定位其地址。
- en: 'To statically analyze binaries obfuscated in this manner, you need to understand
    the hashing algorithm used for each function name and apply that algorithm to
    all the names exported by the library the program is searching. With a complete
    table of hashes in hand, you can do a simple lookup of each hash you encounter
    in the program to determine which function the hash references. A portion of such
    a table, generated for *kernel32.dll*, might look like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要静态分析以这种方式混淆的二进制文件，你需要理解每个函数名使用的哈希算法，并将该算法应用于程序正在搜索的库所导出的所有名称。有了完整的哈希表，你可以简单地查找在程序中遇到的每个哈希，以确定该哈希所引用的函数。以下是为*kernel32.dll*生成的哈希表的一部分，可能像这样：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that the hash values are specific to the hash function being used within
    a particular binary and are likely to vary from one binary to another. Using this
    particular table, if the hash value `8A0FB5E2` ➊ were encountered within a program,
    you could quickly determine that the program was attempting to look up the address
    of the `GetProcAddress` function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，哈希值是特定于在特定二进制文件中使用的哈希函数的，且可能在不同的二进制文件之间有所不同。使用这个特定的表格，如果在程序中遇到哈希值`8A0FB5E2`
    ➊，你可以快速确定该程序试图查找`GetProcAddress`函数的地址。
- en: Skape’s use of hash values to resolve function names was originally developed
    and documented for use in exploit payloads for Windows vulnerabilities; however,
    they have been adopted for use in obfuscated programs as well.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Skape 使用哈希值来解析函数名最初是为 Windows 漏洞的利用负载开发和记录的；然而，它们也已被用于混淆程序中。
- en: '***Anti–Dynamic Analysis Techniques***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***反动态分析技术***'
- en: None of the anti–static analysis techniques covered in the past few sections
    have any effect whatsoever on whether a program will actually execute. In fact,
    while anti–static analysis techniques may make it difficult for you to comprehend
    the true behavior of a program using static analysis techniques alone, they can’t
    prevent the program from executing, or they would render a program useless from
    the start and therefore eliminate the need to analyze the program at all.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 过去几节中介绍的反静态分析技术对程序是否真正执行没有任何影响。实际上，虽然反静态分析技术可能使你仅使用静态分析技术难以理解程序的真实行为，但它们无法阻止程序执行，否则程序从一开始就会变得无法使用，从而根本不需要分析程序。
- en: Given that a program must run in order to do any useful work, dynamic analysis
    aims to observe the behavior of a program in motion (while it is running) rather
    than observe the program at rest (using static analysis while the program is not
    running). In this section, we briefly summarize some of the more common anti–dynamic
    analysis techniques. For the most part, these techniques have little effect on
    static analysis tools; however, where there is overlap, we point this out.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于程序必须运行才能执行任何有用的工作，动态分析旨在观察程序的运行行为（即在程序运行时），而不是观察程序静止时的状态（即在程序未运行时使用静态分析）。在本节中，我们简要总结了几种常见的反动态分析技术。在大多数情况下，这些技术对静态分析工具几乎没有影响；然而，当有重叠时，我们会指出这一点。
- en: '**Detecting Virtualization**'
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**检测虚拟化**'
- en: Sandbox environments commonly use virtualization software, such as VMware, to
    provide an execution environment for malicious software (or any other software
    of interest). The advantage of such environments is that they typically offer
    checkpoint and rollback capabilities that facilitate rapid restoration of the
    sandbox to a known-clean state. The primary disadvantage is that malware may be
    able to detect the sandbox. Under the assumption that virtualization equates to
    observation, many programs that want to remain undetected simply shut after once
    they determine that they are running within a virtual machine. Given the widespread
    use of virtualization for production purposes, this assumption is less valid today
    than it has been historically.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 沙箱环境通常使用虚拟化软件，如 VMware，为恶意软件（或任何其他感兴趣的软件）提供执行环境。这种环境的优势是它们通常提供检查点和回滚功能，有助于将沙箱迅速恢复到已知的干净状态。主要的缺点是恶意软件可能能够检测到沙箱。在假设虚拟化等同于观察的情况下，许多希望保持隐匿的程序一旦确定自己正在虚拟机中运行，就会直接关闭。鉴于虚拟化在生产中的广泛使用，这一假设今天已经不如历史上那么有效。
- en: 'The following list describes a few of the techniques that have been used by
    programs running in virtualized environments to determine that they are running
    within a virtual machine rather than on native hardware:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表描述了一些在虚拟化环境中运行的程序所使用的技术，这些技术用于判断它们是否在虚拟机中运行，而不是在本地硬件上运行：
- en: '**Detection of virtualization-specific software**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**检测虚拟化特定的软件**'
- en: Users often install helper applications within virtual machines to facilitate
    communications between a virtual machine and its host operating system or simply
    to improve performance within the virtual machine. The VMware Tools collection
    is one example of this kind of software. The presence of such software is easily
    detected by programs running within the virtual machine. For example, when VMware
    Tools is installed into a Microsoft Windows virtual machine, it creates Windows
    registry keys that can be read by any program. Malware detecting these keys may
    elect to shut down before exhibiting any noteworthy behaviors. On the other hand,
    virtualization is so widely used today that a VMware image found without VMware
    Tools installed might be considered equally suspicious in the eyes of a piece
    of malware.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通常会在虚拟机中安装辅助应用程序，以促进虚拟机与其主机操作系统之间的通信，或仅仅是为了提高虚拟机内的性能。VMware Tools 集合就是这类软件的一个例子。此类软件的存在很容易被虚拟机内运行的程序检测到。例如，当
    VMware Tools 被安装到 Microsoft Windows 虚拟机中时，它会创建 Windows 注册表键，这些键可以被任何程序读取。恶意软件检测到这些键时，可能会选择在展示任何显著行为之前关闭自己。另一方面，虚拟化如今已被广泛使用，因此在没有安装
    VMware Tools 的 VMware 镜像，可能在恶意软件看来同样令人怀疑。
- en: '**Detection of virtualization-specific hardware**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**检测虚拟化特定的硬件**'
- en: Virtual machines use virtual hardware abstraction layers to provide the interface
    between the virtual machine and the host computer’s native hardware. Characteristics
    of the virtual hardware are often easily detectable by software running within
    the virtual machine. For example, VMware has been assigned its own organizationally
    unique identifiers (OUIs) for its virtualized network adapters.^([9](footnotes.xhtml#ch21fn9))
    Observing a VMware-specific OUI is a good indication that a program is running
    within a virtual machine. Software that shuts down for this reason may be coaxed
    into executing by modifying the MAC address assigned to any virtual network adapters
    associated with the virtual machine.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机使用虚拟硬件抽象层提供虚拟机与主机计算机本地硬件之间的接口。虚拟硬件的特征通常很容易被运行在虚拟机内的软件检测到。例如，VMware 已为其虚拟化的网络适配器分配了独有的组织标识符（OUI）。^([9](footnotes.xhtml#ch21fn9))
    观察到 VMware 特定的 OUI 是程序正在虚拟机中运行的一个良好指示。因而，因这个原因而关闭的程序可能通过修改与虚拟机相关的虚拟网络适配器的 MAC
    地址来诱导其执行。
- en: '**Detection of processor-specific behavioral changes**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**检测处理器特定的行为变化**'
- en: Perfect virtualization is difficult to achieve. Ideally, a program should not
    be able to detect any difference between a virtualized environment and native
    hardware. However, this is seldom the case. Joanna Rutkowska developed her Red
    Pill VMware-detection technique after observing behavioral differences between
    the operation of the x86 `sidt` instruction on native hardware and the same instruction
    executed within a virtual machine environment.^([10](footnotes.xhtml#ch21fn10))
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 完美的虚拟化是难以实现的。理想情况下，一个程序不应该能察觉虚拟化环境与本地硬件之间的任何区别。然而，这种情况很少发生。Joanna Rutkowska
    在观察到本地硬件上 x86 `sidt` 指令与在虚拟机环境中执行相同指令之间的行为差异后，开发了她的 Red Pill VMware 检测技术。^([10](footnotes.xhtml#ch21fn10))
- en: '**Detecting Instrumentation**'
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**检测工具**'
- en: Following creation of your sandbox environment and prior to executing any program
    you want to observe, you need to ensure that instrumentation is in place to properly
    collect and record information about the behavior of the program you are analyzing.
    A wide variety of tools exist for performing such monitoring tasks. Two widely
    used examples are *Process Monitor* from the Sysinternals group at Microsoft and
    *Wireshark*.^([11](footnotes.xhtml#ch21fn11)) Process Monitor is a utility capable
    of monitoring certain activities associated with any running Windows process,
    including accesses to the Windows registry and filesystem activity. Wireshark
    is a network packet capture and analysis tool often used to analyze network traffic
    generated by malicious software.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建沙盒环境并执行任何程序之前，您需要确保已部署适当的工具来收集和记录有关您分析的程序行为的信息。有多种工具可用于执行此类监控任务。两个广泛使用的例子是来自微软
    Sysinternals 组的*进程监视器*和*Wireshark*。[11](footnotes.xhtml#ch21fn11) 进程监视器是一个实用工具，能够监控与任何正在运行的
    Windows 进程相关的某些活动，包括访问 Windows 注册表和文件系统活动。Wireshark 是一个网络数据包捕获和分析工具，通常用于分析恶意软件生成的网络流量。
- en: Malware authors with a sufficient level of paranoia may program their software
    to search for running instances of such monitoring programs. Techniques that have
    been employed range from scanning the active process list for process names associated
    with such monitoring software to scanning the title bar text for all active Windows
    applications to search for known strings. Deeper searches can be performed, with
    some software going so far as to search for specific characteristics associated
    with Windows GUI components used within certain instrumentation software.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有足够偏执的恶意软件作者可能会将其软件编程为搜索运行中的此类监控程序实例。已采用的技术包括扫描活动进程列表，查找与此类监控软件相关的进程名称，或扫描所有活动
    Windows 应用程序的标题栏文本，以搜索已知字符串。更深入的搜索可以执行，一些软件甚至会搜索与某些仪器化软件中使用的 Windows GUI 组件相关的特定特征。
- en: '**Detecting Debuggers**'
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**检测调试器**'
- en: Moving beyond simple observation of a program, a debugger allows an analyst
    to take complete control of the execution of a program that requires analysis.
    Debuggers are commonly used to run an obfuscated program just long enough to complete
    any decompression or decryption tasks, and then the debuggers’ memory-access features
    are used to extract the deobfuscated process image from memory. In most cases,
    standard static analysis tools and techniques can be used to complete the analysis
    of the extracted process image.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 超越简单的程序观察，调试器允许分析人员完全控制需要分析的程序的执行。调试器通常用于运行一个混淆程序，直到完成任何解压或解密任务，然后利用调试器的内存访问功能从内存中提取去混淆的进程映像。在大多数情况下，可以使用标准的静态分析工具和技术来完成对提取进程映像的分析。
- en: The authors of obfuscation utilities are well aware of such debugger-assisted
    deobfuscation techniques and so have developed measures to attempt to defeat the
    use of debuggers for execution of their obfuscated programs. Programs that detect
    the presence of a debugger often choose to terminate rather than proceed with
    any operations that might allow an analyst to determine the behavior of the program.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆工具的作者充分意识到这些调试器辅助的去混淆技术，因此他们已经采取措施，试图阻止使用调试器执行其混淆程序。检测到调试器存在的程序通常选择终止，而不是继续进行任何可能让分析人员确定程序行为的操作。
- en: Techniques for detecting the presence of debuggers range from simple queries
    to the operating system via well-known API functions such as the Windows `IsDebuggerPresent`
    function, to lower-level checks for memory or processor artifacts resulting from
    the use of a debugger. An example of the latter includes detecting that a processor’s
    trace (single step) flag is set.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 检测调试器的方法从通过知名 API 函数（如 Windows `IsDebuggerPresent` 函数）向操作系统发出简单查询，到检查由于使用调试器而产生的内存或处理器伪影。后者的一个例子包括检测处理器的跟踪（单步）标志是否已设置。
- en: As long as you know what to look for, there is nothing terribly tricky about
    trying to detect a debugger, and attempts to do so are easily observed during
    static analysis (unless anti–static analysis techniques are employed simultaneously).
    For more information on debugger detection, please consult the article “Anti Debugging
    Detection Techniques with Examples,” which provides a comprehensive overview of
    Windows anti-debugging techniques.^([12](footnotes.xhtml#ch21fn12))
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你知道应该查找什么，试图检测调试器其实并不复杂，而且在静态分析过程中，检测的尝试很容易被发现（除非同时使用反静态分析技术）。有关调试器检测的更多信息，请参阅文章《带有示例的反调试检测技术》，它提供了
    Windows 反调试技术的全面概述。^([12](footnotes.xhtml#ch21fn12))
- en: '**Preventing Debugging**'
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**防止调试**'
- en: Even an undetectable debugger can be thwarted using additional techniques that
    attempt to confound the debugger by introducing spurious breakpoints, clearing
    hardware breakpoints, hindering disassembly to make selection of appropriate breakpoint
    addresses difficult, or preventing the debugger from attaching to a process in
    the first place. Many of the techniques discussed in the previously referenced
    anti-debugging article are geared toward preventing debuggers from operating correctly.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 即便是无法检测到的调试器，也可以通过一些额外的技术来阻碍，尝试通过引入虚假的断点、清除硬件断点、妨碍反汇编使选择合适的断点地址变得困难，或者防止调试器附加到进程来进行干扰。之前提到的反调试文章中讨论的许多技术，都是为了防止调试器正确运行。
- en: Intentionally generating exceptions is one way a program may attempt to hinder
    debugging. In most cases, an attached debugger will catch the exception, and the
    user of the debugger must analyze why the exception occurred and whether to pass
    the exception along to the program being debugged. In the case of a software breakpoint
    such as the x86 `INT 3`, it may be difficult to distinguish a software interrupt
    generated by the underlying program from one that results from an actual debugger
    breakpoint. This confusion is exactly the effect that is desired by the creator
    of the obfuscated program. In such cases, it’s possible, though harder, to understand
    the true program flow by using careful analysis of the disassembly listing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 故意生成异常是程序可能尝试阻碍调试的一种方式。在大多数情况下，附加的调试器会捕获到异常，调试器的用户必须分析异常发生的原因，并决定是否将异常传递给正在调试的程序。在如
    x86 `INT 3` 这样的软件断点的情况下，很难区分是由底层程序生成的软中断，还是由实际的调试器断点引起的。正是这种混淆效果是混淆程序的创建者所希望达到的效果。在这种情况下，尽管更困难，但仍然可以通过仔细分析反汇编列表来理解真实的程序流程。
- en: Encoding portions of a program has the dual effect of hindering static analysis
    because disassembly is not possible and hindering debugging because placing breakpoints
    is difficult. Even if the start of each instruction is known, software breakpoints
    cannot be placed until the instructions have actually been decoded, as altering
    the instructions by inserting a software breakpoint is likely to result in a failed
    decryption of the obfuscated code and then a crash of the program when execution
    reaches the intended breakpoint.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对程序的编码部分具有双重效果：一方面会阻碍静态分析，因为无法进行反汇编；另一方面会妨碍调试，因为设置断点变得困难。即使已知每条指令的起始位置，也无法在指令实际解码之前设置软件断点，因为通过插入软件断点修改指令可能导致混淆代码解密失败，从而在执行到预定断点时导致程序崩溃。
- en: The Shiva ELF obfuscation tool for Linux uses a technique called *mutual ptrace*
    as a means of preventing the use of a debugger in analyzing Shiva’s behavior.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 用于 Linux 的 Shiva ELF 混淆工具采用一种叫做*互相 ptrace*的技术来防止使用调试器分析 Shiva 的行为。
- en: '**PROCESS TRACING**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程追踪**'
- en: The *ptrace*, or process tracing, API available on many Unix-like systems provides
    a mechanism for one process to monitor and control the execution of another process.
    The GNU debugger (`gdb`) is one of the more well-known applications that uses
    the ptrace API. Using the ptrace API, a ptrace parent process may attach to and
    control the execution of a ptrace child process. To begin controlling a process,
    a parent process must first *attach* to the child process that it seeks to control.
    Once the parent process is attached, the child process is stopped anytime it receives
    a signal, and the parent is notified of this fact via the POSIX `wait` function,
    at which point the parent may choose to alter or inspect the state of the child
    process before instructing the child process to continue execution. Once a parent
    process has attached to a child process, no other process may attach to the same
    child process until the tracing parent chooses to detach from the child process.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*ptrace*，或称进程跟踪（process tracing），是许多类Unix系统提供的API，它允许一个进程监视并控制另一个进程的执行。GNU
    调试器（`gdb`）是使用ptrace API的著名应用之一。通过ptrace API，一个ptrace父进程可以附加到并控制一个ptrace子进程的执行。为了开始控制一个进程，父进程必须首先*附加*到它想要控制的子进程。一旦父进程附加，子进程在接收到信号时会被停止，父进程通过POSIX的`wait`函数接收到这个通知，父进程可以选择在指示子进程继续执行之前，修改或检查子进程的状态。一旦父进程附加到子进程，其他进程就无法再附加到该子进程，直到跟踪父进程选择从子进程上分离。'
- en: Shiva takes advantage of the fact that only one other process may be attached
    to a process at any given time. Early in its execution, the Shiva process forks
    to create a copy of itself. The original Shiva process immediately performs a
    ptrace attach operation on the newly forked child. The newly forked child process,
    in turn, immediately attaches to its parent process. If either attach operation
    fails, Shiva terminates under the assumption that a debugger is being used to
    monitor the Shiva process. If both operations succeed, no other debugger can attach
    to the running Shiva pair, and Shiva can continue to run without fear of being
    observed. While operating in this manner, either Shiva process may alter the state
    of the other, making it difficult to determine, using static analysis techniques,
    what the exact control flow path is through the Shiva binary.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Shiva利用了每次只能有一个其他进程附加到一个进程的事实。在其执行的早期，Shiva进程会派生出一个自己的副本。原始的Shiva进程立即对新派生的子进程执行ptrace附加操作。新派生的子进程则立即附加到其父进程。如果任何一次附加操作失败，Shiva会终止，并假设有调试器正在监视Shiva进程。如果两次附加操作都成功，其他调试器无法附加到正在运行的Shiva对，这样Shiva就能继续运行，而不必担心被观察到。在这种方式下运行时，任一Shiva进程可以更改另一个进程的状态，这使得使用静态分析技术很难确定Shiva二进制文件的确切控制流路径。
- en: '**Static Deobfuscation of Binaries Using Ghidra**'
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用Ghidra进行二进制文件的静态去混淆**'
- en: At this point, you may be wondering how, given all of the anti–reverse engineering
    techniques available, it is possible to analyze software that a programmer is
    intent on keeping secret. Given that these techniques target both static analysis
    tools and dynamic analysis tools, what is the best approach to take in revealing
    a program’s hidden behavior? Unfortunately, no single solution fits all cases
    equally well.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 到这时，你可能会想，考虑到所有可用的反逆向工程技术，如何分析那些程序员有意隐瞒的软件呢？由于这些技术既针对静态分析工具，也针对动态分析工具，那么揭示程序隐藏行为的最佳方法是什么呢？不幸的是，没有一种解决方案能够适用于所有情况。
- en: In most cases, the solution depends on your skill set and the tools available
    to you. If your analysis tool of choice is a debugger, you will need to develop
    strategies for circumventing debugger detection and prevention protections. If
    your preferred analysis tool is a disassembler, you will need to develop strategies
    for obtaining an accurate disassembly and, in cases in which self-modifying code
    is encountered, for mimicking the behavior of that code in order to properly update
    your disassembly listings.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，解决方案取决于你的技能和可用的工具。如果你选择的分析工具是调试器，你需要开发绕过调试器检测和防护措施的策略。如果你偏好的分析工具是反汇编器，你需要开发获取准确反汇编结果的策略，并且在遇到自修改代码的情况下，需要模拟该代码的行为，以便正确更新反汇编列表。
- en: In this section, we discuss two techniques for dealing with self-modifying code
    in a static analysis environment (that is, without executing the code). Static
    analysis may be your only option when you are unwilling (because of hostile code)
    or unable (because of lack of hardware) to analyze a program while controlling
    it with a debugger. If these concepts make you feel like you are going down a
    rabbit hole, don’t be discouraged. Ghidra has secret (or not-so-secret) weapons
    that we can leverage in the static deobfuscation arms race.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们讨论了两种在静态分析环境中处理自修改代码的技术（即不执行代码的情况下）。静态分析可能是您的唯一选择，当您因敌意代码而不愿意（或因缺乏硬件而无法）在调试器控制下分析程序时。如果这些概念让您觉得自己正在陷入一个困境，不要气馁。Ghidra
    具有一些秘密（或者说不那么秘密的）武器，我们可以在静态解混淆的军备竞赛中加以利用。
- en: '***Script-Oriented Deobfuscation***'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***面向脚本的解混淆***'
- en: Because Ghidra can be used to disassemble binaries for an ever-increasing set
    of processors, it is not uncommon to analyze a binary developed for an entirely
    different platform than the one on which you are running Ghidra. For example,
    you may be asked to analyze a Linux x86 binary even though you happen to be running
    Ghidra on macOS, or you may be asked to analyze a MIPS or ARM binary even though
    you are running Ghidra on an x86 platform.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Ghidra 可以用于反汇编针对越来越多的处理器开发的二进制文件，因此分析为与您运行 Ghidra 的平台完全不同的另一个平台开发的二进制文件并不罕见。例如，您可能被要求分析一个
    Linux x86 二进制文件，即使您恰好在 macOS 上运行 Ghidra，或者您可能被要求分析一个 MIPS 或 ARM 二进制文件，即使您在 x86
    平台上运行 Ghidra。
- en: In such cases, you may not have access to appropriate tools, such as debuggers,
    for dynamically analyzing the binary. When such a binary has been obfuscated by
    encoding portions of the program, you may have no other option than to create
    a Ghidra script that will mimic the deobfuscating stage of the program in order
    to properly decode the program and disassemble the decoded instructions and data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可能无法访问合适的工具，例如调试器，用于动态分析二进制文件。当这样的二进制文件经过程序部分编码的混淆时，您可能别无选择，只能创建一个 Ghidra
    脚本，模拟程序的解混淆阶段，以正确解码程序并反汇编解码后的指令和数据。
- en: This may seem like a daunting task; however, in many cases, the decoding stages
    of an obfuscated program use only a small subset of a processor’s instruction
    set, so familiarizing yourself with the necessary operations may not require understanding
    the entire instruction set for the target processor.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能是一个令人生畏的任务；然而，在许多情况下，混淆程序的解码阶段只使用处理器指令集的一小部分，因此，熟悉必要的操作可能不需要理解目标处理器的整个指令集。
- en: '[Chapter 14](ch14.xhtml#ch14) presented an algorithm for developing scripts
    that emulate the behavior of portions of a program. In the following example,
    we will utilize those steps to develop a simple Ghidra script to decode a program
    that has been encrypted with the Burneye ELF encryption tool. In our sample program,
    execution begins with the instructions in [Listing 21-3](ch21.xhtml#exa21_3).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[第14章](ch14.xhtml#ch14)介绍了一种开发脚本以模拟程序部分行为的算法。在接下来的示例中，我们将利用这些步骤开发一个简单的 Ghidra
    脚本，以解码一个使用 Burneye ELF 加密工具加密的程序。在我们的示例程序中，执行从[第21-3节](ch21.xhtml#exa21_3)中的指令开始。'
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 21-3: Burneye startup sequence and obfuscated code*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*第21-3节：Burneye 启动序列和混淆代码*'
- en: 'The program begins by pushing the contents of memory location `05371008h` onto
    the stack ➊ before pushing the processor flags ➋ and all processor registers ➌.
    The purpose of these instructions is not immediately clear, so we simply file
    this information away for later. Next, the `ECX` register is loaded with the contents
    of memory location `05371000h` ➍. According to the algorithm presented in [Chapter
    14](ch14.xhtml#ch14), we need to declare a variable named `ECX` at this point
    and initialize it from memory by using Ghidra’s `getInt` function, as shown here:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 程序开始时将内存位置 `05371008h` 的内容压入栈中 ➊，然后压入处理器标志 ➋ 和所有处理器寄存器 ➌。这些指令的目的尚不清楚，因此我们将这些信息暂时记录下来以备后用。接下来，`ECX`
    寄存器被加载了内存位置 `05371000h` 的内容 ➍。根据[第14章](ch14.xhtml#ch14)中提出的算法，我们需要在这一点上声明一个名为
    `ECX` 的变量，并通过 Ghidra 的 `getInt` 函数从内存中初始化它，如下所示：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Following an absolute jump, the program calls function `FUN_05371048` ➎, which
    pushes address `05371087h` (the return address) onto the stack. The disassembled
    instructions that follow the `CALL` instruction begin to make less and less sense.
    The `OUT` instruction ➏ is not generally encountered in user-space code, and Ghidra
    is unable to disassemble an instruction at address `053710B5h` ➐. These are both
    indications that something is not quite right with this binary (that and the fact
    that the Symbol Tree lists only two functions: `entry` and `FUN_05371048`).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在绝对跳转后，程序调用函数`FUN_05371048` ➎，并将地址`05371087h`（返回地址）压入栈中。紧跟着`CALL`指令的反汇编指令开始变得越来越不合常理。`OUT`指令
    ➏通常不出现在用户空间代码中，而Ghidra无法反汇编位于地址`053710B5h`的指令 ➐。这些都表明该二进制文件可能存在问题（另外，符号树中只列出了两个函数：`entry`和`FUN_05371048`）。
- en: At this point, analysis needs to continue with the call to function `FUN_05371048`,
    which is shown in [Listing 21-4](ch21.xhtml#exa21_4).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，分析需要继续进行，接下来的函数调用是`FUN_05371048`，如[Listing 21-4](ch21.xhtml#exa21_4)所示。
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 21-4: Main Burneye decoding function*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 21-4: 主Burneye解码函数*'
- en: 'This is not a typical function: it begins by immediately popping the return
    address off the stack into the `ESI` register ➊. Recalling that the saved return
    address was `05371087h`, and taking into account the initialization of `EDI` ➋,
    `EBX` ➌, and `EDX` ➎, our script grows to the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个典型的函数：它开始时立即将返回地址从栈中弹出到`ESI`寄存器 ➊。回想一下，保存的返回地址是`05371087h`，并考虑到`EDI` ➋、`EBX`
    ➌和`EDX` ➎的初始化，我们的脚本扩展为如下：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Following these initializations, the function performs a test on the value contained
    in the `EBX` register ➍ before entering an outer loop ➏ and an inner loop ➐. The
    remaining logic of the function is captured in the following completed script.
    Within the script, comments are used to relate script actions to the corresponding
    actions in the preceding disassembly listing.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些初始化之后，函数会先对`EBX`寄存器中的值进行测试 ➍，然后进入外部循环 ➏和内部循环 ➐。函数的剩余逻辑在以下完成的脚本中得到了体现。脚本中使用注释将脚本操作与前述反汇编列表中的相应操作关联起来。
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Whenever you are trying to emulate an instruction, you should pay particular
    attention to data sizes and register aliasing. In this example, we need to select
    an appropriate data size and variable to properly implement the x86 `LODSB` (load
    string byte) and `STOSB` (store string byte) instructions. These instructions
    write to (`LODSB`) and read from (`STOSB`) the low-order 8 bits of the `EAX` register,^([13](footnotes.xhtml#ch21fn13))
    leaving the upper 24 bits unchanged. In Java, there is no way to partition a variable
    into bit-sized portions other than using various bitwise operations to mask off
    and recombine portions of the variable. Specifically, in the case of the `LODSB`
    instruction ➊, a more faithful emulation would read as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你尝试模拟一条指令时，应该特别注意数据大小和寄存器别名。在这个例子中，我们需要选择合适的数据大小和变量，以正确实现x86的`LODSB`（加载字符串字节）和`STOSB`（存储字符串字节）指令。这些指令分别对`EAX`寄存器的低8位进行写入（`LODSB`）和读取（`STOSB`），^([13](footnotes.xhtml#ch21fn13))而不改变上24位。在Java中，除了通过各种按位操作来掩码并重新组合变量的部分外，无法将变量分割为位大小的部分。具体来说，对于`LODSB`指令
    ➊，一个更忠实的模拟应如下所示：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This example first clears the low 8 bits of the `EAX` variable and then merges
    in the new value for the low 8 bits using an `OR` operation. In the Burneye decoding
    example, the entire `EAX` register is set to 8 at the beginning of each outer
    loop, which has the effect of zeroing the upper 24 bits of `EAX`. As a result,
    we have elected to simplify our implementation of `LODSB` ➊ by ignoring the effect
    of the assignment on the upper 24 bits of `EAX`. No thought need be given to our
    implementation of `STOSB` ➋, as the `setByte` function requires us to cast the
    second argument to a `byte`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子首先清除`EAX`变量的低8位，然后通过`OR`操作将新的低8位值合并到其中。在Burneye解码示例中，每次外部循环开始时，整个`EAX`寄存器被设置为8，这样就会将`EAX`的上24位置零。因此，我们决定简化`LODSB`
    ➊的实现，忽略赋值对`EAX`上24位的影响。对于`STOSB` ➋的实现无需过多思考，因为`setByte`函数要求我们将第二个参数转换为`byte`。
- en: Following execution of the Burneye decoding script, our disassembly would reflect
    all of the changes that would normally not be observable until the obfuscated
    program was executed on a Linux system. If the deobfuscation process was carried
    out properly, we are very likely to see many more legible strings within Ghidra’s
    Search ▸ “For Strings... option” . To observe this fact, you may need to select
    the Refresh icon in the String Search window.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 执行Burneye解码脚本后，我们的反汇编将反映所有那些通常在混淆程序在Linux系统上执行时才可观察到的变化。如果解混淆过程顺利进行，我们很可能会在Ghidra的“搜索
    ▸ 字符串...”选项中看到更多清晰的字符串。为了观察这一点，你可能需要在字符串搜索窗口中选择刷新图标。
- en: 'Remaining tasks include (1) determining where the decoding function will return
    to, given that it popped its return address in the very first instruction of the
    function, and (2) coaxing Ghidra to properly display the decoded byte values as
    instructions or data as appropriate. The Burneye decoding function ends with the
    following three instructions:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的任务包括：(1) 确定解码函数将返回到哪里，因为它在函数的第一条指令中弹出了返回地址，(2) 引导Ghidra正确地显示解码后的字节值，作为指令或数据，具体取决于情况。Burneye解码函数以以下三条指令结束：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Recall that the function began by popping its own return address, which means
    that the remaining stack values were set up by the caller. The `POPAD` and `POPFD`
    instructions used here are the counterparts to the `PUSHAD` and `PUSHFD` instructions
    used at the beginning of Burneye’s start routine, as shown here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，该函数从弹出自己的返回地址开始，这意味着剩余的栈值是由调用者设置的。这里使用的`POPAD`和`POPFD`指令是与Burneye启动例程开头使用的`PUSHAD`和`PUSHFD`指令相对的，正如这里所示：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The net result is that the only value that remains on the stack is the one that
    was pushed at the first line of `entry` ➊. It is to this location that the Burneye
    decoding routine returns, and it is at this location that further analysis of
    the Burneye protected binary would need to continue.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是，栈上唯一剩下的值是第一行`entry` ➊推送的那个值。Burneye解码例程会返回到这个位置，接下来对Burneye保护的二进制文件的进一步分析也必须从这个位置继续。
- en: The preceding example may make it seem like writing a script to decode or unpack
    an obfuscated binary is a relatively easy thing to do. This is true in the case
    of Burneye, which does not use a terribly sophisticated initial obfuscation algorithm.
    The deobfuscation stub of more sophisticated utilities such as ASPack and tElock
    would require somewhat more effort to implement using Ghidra.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例可能让人觉得编写一个脚本来解码或解开一个混淆的二进制文件是一件相对容易的事。对于Burneye来说，这是真的，因为它并没有使用非常复杂的初始混淆算法。像ASPack和tElock这类更复杂的工具的解混淆代码，使用Ghidra实现时需要更多的工作。
- en: Advantages to script-based deobfuscation include that the binary being analyzed
    need never be executed and that it is possible to create a functional script without
    ever developing a complete understanding of the exact algorithm used to deobfuscate
    the binary. This latter statement may seem counterintuitive, as it would seem
    that you would need to have a complete understanding of the deobfuscation before
    you could emulate the algorithm using a script. Using the development process
    described here and in [Chapter 14](ch14.xhtml#ch14), however, all you really need
    is a complete understanding of each processor instruction involved in the deobfuscation
    process. By faithfully implementing each processor action using Ghidra and properly
    sequencing each action according to the disassembly listing, you will have a script
    that mimics the program’s actions even if you do not fully comprehend the higher-level
    algorithm that those actions, as a whole, implement.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 基于脚本的解混淆的优点包括：被分析的二进制文件从不需要执行，而且有可能创建一个功能完整的脚本，而无需完全理解解混淆所使用的确切算法。这个后者的说法可能看起来违反直觉，因为似乎在你能够用脚本模拟该算法之前，你需要对解混淆算法有完整的理解。然而，按照这里描述的开发过程以及在[第14章](ch14.xhtml#ch14)中的说明，你真正需要的是对解混淆过程中涉及的每个处理器指令有完整的理解。通过忠实地使用Ghidra实现每个处理器动作，并根据反汇编列表正确地排列每个动作，你将获得一个脚本，能够模拟程序的行为，即使你不完全理解这些动作作为整体所实现的高级算法。
- en: Disadvantages of using a script-based approach include that the scripts are
    rather fragile. If a deobfuscation algorithm changes as a result of an upgrade
    to a deobfuscation tool or through the use of alternate command line settings
    supplied to the obfuscation tool, a script that had been effective against that
    tool will likely need to be modified accordingly. For example, it is possible
    to develop generic unpacking scripts for use with binaries packed using UPX, but
    such scripts require constant tuning as UPX evolves.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于脚本的方法的缺点之一是脚本相当脆弱。如果去混淆算法因为去混淆工具的升级或通过对混淆工具使用替代命令行设置而发生变化，那么以前对该工具有效的脚本可能需要进行相应修改。例如，虽然可以为使用UPX打包的二进制文件开发通用解包脚本，但随着UPX的演变，这些脚本需要不断调整。
- en: Finally, scripted deobfuscation suffers from the lack of a one-size-fits-all
    solution to deobfuscation. There is no mega-script capable of deobfuscating all
    binaries. In a sense, scripted deobfuscation suffers from many of the same shortcomings
    as signature-based intrusion detection and antivirus systems. A new script must
    be developed for each new type of packer, and subtle changes in existing packers
    are likely to break existing scripts. Let’s shift focus and look at a more generic
    approach to deobfuscation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，脚本化去混淆存在缺乏通用解决方案的问题。没有一种超级脚本可以去混淆所有的二进制文件。从某种意义上来说，脚本化去混淆存在与基于签名的入侵检测和杀毒系统相似的缺点。每种新的打包器类型都需要开发新的脚本，并且现有打包器的细微变化可能会导致现有脚本失效。让我们转移焦点，看看一种更通用的去混淆方法。
- en: '***Emulation-Oriented Deobfuscation***'
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***面向模拟的去混淆***'
- en: A recurring theme encountered when creating scripts to perform deobfuscation
    tasks is the need to emulate a processor’s instruction set in order to behave
    identically to the program being deobfuscated. Instruction emulators allow us
    to shift some or all of the work performed by these scripts over to the emulator
    and drastically reduce the amount of time required for Ghidra to deobfuscate.
    Emulators can fill the void between scripts and debuggers and can be more flexible
    than debuggers. An emulator can, for example, emulate a MIPS binary on an x86
    platform or emulate instructions from a Linux ELF binary on a Windows platform.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建用于执行去混淆任务的脚本时，常常遇到的一个主题是需要模拟处理器的指令集，以便与正在去混淆的程序行为一致。指令模拟器使我们能够将这些脚本执行的一部分或全部工作转交给模拟器，从而大幅减少Ghidra进行去混淆所需的时间。模拟器可以填补脚本与调试器之间的空白，并且比调试器更具灵活性。例如，模拟器可以在x86平台上模拟MIPS二进制文件，或者在Windows平台上模拟Linux
    ELF二进制文件的指令。
- en: Emulators vary in capabilities. At a minimum, an emulator requires a stream
    of instruction bytes and sufficient memory to dedicate to stack operations and
    processor registers. More sophisticated emulators may provide access to emulated
    hardware devices and operating system services.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器的功能各不相同。最低要求是模拟器需要处理指令字节流，并有足够的内存用于堆栈操作和处理器寄存器的分配。更为复杂的模拟器可能还会提供对模拟硬件设备和操作系统服务的访问。
- en: '##### **Ghidra’s Emulator Class**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '##### **Ghidra的模拟器类**'
- en: Fortunately, Ghidra provides a rich `Emulator` class as well as an `EmulatorHelper`,
    which provides a higher-level abstraction of common emulator functionality and
    facilitates the quick-and-easy creation of emulation scripts. In [Chapter 18](ch18.xhtml#ch18),
    we introduced p-code as an intermediate representation of the underlying assembly
    and described how this allows the decompiler to work against a variety of target
    architectures. Similarly, p-code supports emulator functionality as well, and
    Ghidra’s `ghidra.pcode.emulate.Emulate` class provides the ability to emulate
    a single p-code instruction.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Ghidra提供了丰富的`Emulator`类和`EmulatorHelper`，后者提供了常见模拟器功能的高级抽象，并便于快速轻松地创建模拟脚本。在[第18章](ch18.xhtml#ch18)中，我们介绍了p-code作为底层汇编的中间表示，并描述了它如何使反编译器能够针对多种目标架构进行工作。同样，p-code也支持模拟器功能，Ghidra的`ghidra.pcode.emulate.Emulate`类提供了模拟单个p-code指令的能力。
- en: We can use Ghidra’s emulator-related classes to build emulators that allow us
    to emulate a wide variety of processors. As with other Ghidra packages and classes,
    this functionality is documented in the Javadoc supplied with Ghidra and can be
    pulled up as a reference by clicking the red plus tool in the Script Manager window.
    If you are interested in writing emulators, we encourage you to check out the
    Javadoc associated with the emulator methods used in the following example.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Ghidra 的模拟器相关类来构建模拟器，允许我们模拟多种处理器类型。与 Ghidra 的其他包和类一样，这个功能在随 Ghidra 提供的
    Javadoc 文档中有详细说明，并且可以通过点击脚本管理器窗口中的红色加号工具调出作为参考。如果你有兴趣编写模拟器，建议你查看以下示例中使用的模拟器方法的
    Javadoc 文档。
- en: '**CRACKME, CRACK YOURSELF**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**破解我，自己破解**'
- en: A *crackme* is a puzzle built by reverse engineers, for reverse engineers. The
    name derives from cracking a piece of software to bypass copy or usage restrictions—one
    of the more nefarious uses of reverse engineering skills. Crackmes provide a legal
    means to practice these skills as well as provide both the author of the crackme
    and the person analyzing the crackme a chance to show off their talent.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*crackme* 是逆向工程师为逆向工程师构建的谜题。这个名字来源于破解一段软件以绕过复制或使用限制——这是逆向工程技能的一种恶意用途。破解题为练习这些技能提供了合法手段，也为破解题的作者和分析破解题的人提供了展示其才华的机会。'
- en: A common style of crackme receives a user input, transforms that input in some
    way, and then compares the result of the transformation to a precomputed output.
    When you attempt to solve a crackme, you are generally given only a compiled executable
    that contains both the code that performs the transformation and the final output
    for an unknown input. The crackme is solved when you derive the input that was
    used to generate the output contained in the binary, which typically requires
    understanding the transformation so well that you can derive the inverse transformation
    function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的破解题风格是接受用户输入，对输入进行某种转换，然后将转换后的结果与预计算的输出进行比较。当你尝试解决一个破解题时，通常只有一个包含执行转换的代码和一个用于未知输入的最终输出的已编译可执行文件。破解题的解决方法是推导出用于生成二进制文件中输出的输入，这通常需要理解转换过程到足以推导出逆转换函数。
- en: '**Example: SimpleEmulator**'
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例：SimpleEmulator**'
- en: 'Assume that we have a binary associated with the following crackme challenge,
    including some encoded content at the start of the file that eventually serves
    as the body of a function. In this example, we build an emulator script to automate
    the process of decoding the information needed to solve the crackme:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个与以下破解挑战相关的二进制文件，其中在文件开头有一些编码内容，这些内容最终作为函数体的一部分。在这个示例中，我们构建了一个模拟器脚本来自动化解码解决破解问题所需的信息的过程：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Even with the source code available, this crackme would require some effort
    to solve because of the encoded content ➊. Ghidra’s decompiler is frequently an
    awesome partner for solving crackme challenges, but this one has interesting characteristics
    that complicate the process. Ghidra sees only the encoded function body, but we
    need to know the function’s actual purpose before we can solve the challenge.
    At runtime, the `unpack` ➌ function call results in the decoding of the `check_access`
    ➋ function before `check_access` is called ➍. The answer to this crackme is obfuscated,
    and we can build an emulator script in Ghidra to help us attack this challenge.
    Unlike the previous example, this emulator will not just solve the problem for
    this specific case, but will be capable of emulating somewhat arbitrary code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 即使源代码可用，这个破解题仍然需要一些努力才能解决，因为它包含了编码内容 ➊。Ghidra 的反编译器常常是解决破解题的得力伙伴，但这个例子有一些有趣的特性使得过程变得复杂。Ghidra
    只能看到编码后的函数体，但在解决挑战之前，我们需要了解函数的实际功能。在运行时，`unpack` ➌ 函数调用会解码 `check_access` ➋ 函数，然后
    `check_access` 才会被调用 ➍。这个破解题的答案是混淆的，我们可以在 Ghidra 中构建一个模拟器脚本来帮助我们攻克这个挑战。与前一个示例不同，这个模拟器不仅仅能为这个特定案例解决问题，而是能够模拟一些任意的代码。
- en: '***Step 1: Define the Problem***'
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 1：定义问题***'
- en: Our task is to design and develop a simple emulator that will allow us to choose
    a region of a disassembly and will emulate the instructions in that region. The
    emulator needs to be added to Ghidra and be available as a script. For example,
    if we select the `unpack` function for the crackme challenge and run the script,
    our emulator should use the key to unpack the `check_access` array and let us
    know the solution to the crackme challenge. The script will write the unpacked
    code bytes into the program’s memory in Ghidra.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是设计和开发一个简单的模拟器，允许我们选择反汇编区域并模拟该区域的指令。该模拟器需要被添加到Ghidra中，并作为脚本可用。例如，如果我们为crackme挑战选择`unpack`函数并运行脚本，我们的模拟器应该使用密钥来解包`check_access`数组，并告诉我们crackme挑战的解决方案。该脚本将把解包后的代码字节写入Ghidra程序的内存中。
- en: '***Step 2: Create the Eclipse Script Project***'
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 2：创建Eclipse脚本项目***'
- en: 'We can create a project called *SimpleEmulator* using GhidraDev ▸ New ▸ Ghidra
    Script Project. This gives us a *SimpleEmulator* folder in Eclipse with a folder
    called *Home scripts* (refer to [Figure 15-16](ch15.xhtml#fig15_16) on [page 325](ch15.xhtml#page_325))
    waiting for our new script. We still need to create the actual script and enter
    the associated metadata to ensure that our script is documented and can be catalogued.
    The metadata collected in the script creation dialog is included in the file and,
    as [Figure 21-7](ch21.xhtml#fig21_7) shows, we have only one thing to do: `Add
    script code here`.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用GhidraDev ▸ New ▸ Ghidra脚本项目创建一个名为*SimpleEmulator*的项目。这样，我们将在Eclipse中创建一个*SimpleEmulator*文件夹，并在其中创建一个名为*Home
    scripts*的文件夹（参见[图 15-16](ch15.xhtml#fig15_16)，位于[第325页](ch15.xhtml#page_325)），等待我们的新脚本。我们仍然需要创建实际的脚本并输入相关的元数据，以确保我们的脚本有文档并可以被分类。脚本创建对话框中收集的元数据将包含在文件中，正如[图
    21-7](ch21.xhtml#fig21_7)所示，我们只需要做一件事：`在此处添加脚本代码`。
- en: '![image](Images/fig21-7.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig21-7.jpg)'
- en: '*Figure 21-7: Script template for* SimpleEmulator'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 21-7：SimpleEmulator的脚本模板*'
- en: '***Step 3: Build the Emulator***'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 3：构建模拟器***'
- en: 'We know that Eclipse will recommend imports if we need them as we develop our
    code, so we can jump right into the coding tasks we need to perform and add the
    recommended `import` statements when Eclipse detects that we need them. For functionality,
    we will rely on the following instance variable declarations throughout our `SimpleEmulator`
    class:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，Eclipse在我们开发代码时，如果需要导入内容，会自动推荐导入语句，因此我们可以直接开始编码任务，并在Eclipse检测到我们需要时添加推荐的`import`语句。在功能实现方面，我们将在整个`SimpleEmulator`类中依赖以下实例变量声明：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Comments associated with each declaration describe the purpose of each variable.
    The `executionAddress` will initially be set to the start of the selected range,
    but will also be used to advance through the selection.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个声明相关的注释描述了每个变量的目的。`executionAddress`最初将被设置为选定范围的起始地址，但也将用于在选择区域中推进。
- en: '**Step 3-1: Set Up the Emulator**'
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤 3-1：设置模拟器**'
- en: 'The first thing we will do in our script’s `run` method is instantiate our
    emulator helper object and activate the tracking of any memory written in the
    emulator so that we can write updated values back into the current program. The
    instantiation acts as a lock, similar to the lock that the CodeBrowser places
    on an open binary:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在脚本的`run`方法中做的第一件事是实例化我们的模拟器辅助对象，并激活对模拟器中任何内存写入操作的跟踪，以便我们可以将更新后的值写回当前程序。实例化操作充当了一个锁，类似于CodeBrowser在打开二进制文件时所施加的锁：
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Step 3-2: Select the Address Range to Be Emulated**'
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤 3-2：选择要模拟的地址范围**'
- en: Since we want the user to choose the section of code to be emulated, we need
    to ensure they have selected something in the Listing window. Otherwise, we will
    generate an error message.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们希望用户选择要模拟的代码段，所以我们需要确保他们在列表窗口中选择了某些内容。如果没有选择，我们将生成错误消息。
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Step 3-3: Get Ready to Emulate**'
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤 3-3：准备模拟**'
- en: 'Within the selection, we want to ensure we are looking at an instruction in
    order to establish the initial processor context, initialize the stack pointer,
    and set up a breakpoint at the end of the selected region. The `continuing` flag
    indicates whether we are just starting the emulation or continuing the emulation,
    and determines which version of `emuHelper.run` is called in step 3-4:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择的区域内，我们希望确保查看到的是一条指令，以便建立初始的处理器上下文，初始化堆栈指针，并在选定区域的末尾设置一个断点。`continuing`标志指示我们是刚开始模拟还是继续模拟，并决定在步骤3-4中调用`emuHelper.run`的哪个版本：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Step 3-4: Perform Emulation**'
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤 3-4：执行模拟**'
- en: 'In this section, you should recognize the use of some Ghidra API functions
    introduced in [Chapter 14](ch14.xhtml#ch14) (such as `monitor.isCancelled`). We
    need a loop to drive the emulation until a termination condition that we define
    is reached:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您应该能认识到一些 Ghidra API 函数的使用，这些函数在 [第 14 章](ch14.xhtml#ch14) 中有介绍（例如 `monitor.isCancelled`）。我们需要一个循环来驱动仿真，直到达到我们定义的终止条件：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For this example, emulation continues as long as the monitor hasn’t detected
    a user cancellation, we haven’t reached the end of the selected range of instructions,
    or an error condition hasn’t been triggered ➊. When the emulator stops, we need
    to update the current execution address ➋ and then handle the stop condition appropriately
    ➌. The final step is to call the `writeBackMemory()`method ➍.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，模拟将继续进行，直到监视器检测到用户取消操作、我们尚未到达所选指令范围的结束，或未触发错误条件 ➊。当模拟器停止时，我们需要更新当前执行地址
    ➋，然后适当处理停止条件 ➌。最后一步是调用 `writeBackMemory()` 方法 ➍。
- en: '**Step 3-5: Write Memory Back to the Program**'
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤 3-5：将内存写回程序**'
- en: The implementation of `writeBackMemory()` ➍ is shown here. This emulator is
    going to be tested on an unpack routine, which ultimately changes the bytes in
    memory. The memory changes that the emulator has made exist only in its working
    memory. The content needs to be written back to the binary in order to allow the
    listing and other user interfaces to accurately reflect the changes that result
    from executing the instructions in the unpack routine. Ghidra provides functionality
    within its `emulatorHelper` to facilitate this process.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeBackMemory()` ➍ 的实现如图所示。此模拟器将在一个解包例程中进行测试，该例程最终会更改内存中的字节。模拟器所做的内存更改仅存在于其工作内存中。内容需要写回到二进制文件，以便列出和其他用户界面能够准确反映通过执行解包例程中的指令所导致的更改。Ghidra
    在其 `emulatorHelper` 中提供了相关功能来简化此过程。'
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Step 3-6: Clean Up Resources**'
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤 3-6：清理资源**'
- en: 'In this step, we need to clean up resources and release the lock that we have
    on the current program. Both can be accomplished in one easy statement:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在此步骤中，我们需要清理资源并释放对当前程序的锁定。这两项操作可以通过一个简单的语句完成：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Since this emulator is only for demonstration purposes, we took some liberties
    in what was included in the script. To conserve space, we minimized the comments,
    functionality, error checking, and error handling that we would normally include
    in a production script. All that remains is to confirm that our emulator script
    is able to accomplish our goal.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此模拟器仅用于演示目的，我们在脚本中做了一些简化。为了节省空间，我们最小化了通常在生产脚本中包含的注释、功能、错误检查和错误处理。现在剩下的只是确认我们的模拟器脚本能够完成我们的目标。
- en: '***Step 4: Add the Script to Our Ghidra Installation***'
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 4：将脚本添加到我们的 Ghidra 安装中***'
- en: Adding a script to our Ghidra installation just requires dropping it somewhere
    that Ghidra will find it. If you set up the script project as a linked project,
    Ghidra knows where to find it already. If you did not link your script project
    (or if you created your emulator script in another editor), you need to save it
    in one of Ghidra’s script directories, as discussed in [Chapter 14](ch14.xhtml#ch14).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本添加到我们的 Ghidra 安装中只需要将其放置在 Ghidra 可以找到的地方。如果您将脚本项目设置为链接项目，Ghidra 已经知道在哪里找到它。如果您没有链接脚本项目（或如果您在另一个编辑器中创建了模拟器脚本），则需要将其保存在
    Ghidra 的某个脚本目录中，具体情况请参见 [第 14 章](ch14.xhtml#ch14)。
- en: '***Step 5: Test the Script Within Ghidra***'
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 5：在 Ghidra 中测试脚本***'
- en: 'To test the script, we will load the binary associated with the crackme challenge
    source code. When we load the binary and navigate to the `unpack` function, we
    note that it contains references to the `check_access` label:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试脚本，我们将加载与 crackme 挑战源代码相关的二进制文件。当我们加载二进制文件并导航到 `unpack` 函数时，注意到它包含对 `check_access`
    标签的引用：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The code in the Decompiler window contains the following, which does not get
    us any closer to solving our crackme:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Decompiler 窗口中的代码包含以下内容，这并没有让我们更接近解决 crackme：
- en: '[PRE34]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Double-clicking `check_access` within the Listing window leads us to address
    `00301010`, which does not look like instructions within a function.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Listing 窗口中双击 `check_access` 会将我们引导到地址 `00301010`，该地址看起来不像是函数内的指令。
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If we chose to disassemble this content, we would receive a bad data error in
    Ghidra. The Decompiler window also provides no help for this location. So let’s
    use our script to see if we can emulate the `unpack` function. We select the instructions
    that make up the `unpack` function and open the Script Manager and run our script.
    We see no observable change in the `unpack` function or in the Decompiler window.
    But if we navigate to `check_access` (`00301010`), the content has changed!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择反汇编这个内容，我们会在 Ghidra 中收到坏数据错误。反编译器窗口对此位置也没有任何帮助。所以让我们使用脚本看看能否仿真 `unpack`
    函数。我们选择构成 `unpack` 函数的指令，打开脚本管理器并运行我们的脚本。我们没有看到 `unpack` 函数或反编译器窗口中有任何可观察的变化。但是，如果我们导航到
    `check_access`（`00301010`），内容已经发生了变化！
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can clear these code bytes (hotkey C) and then disassemble (hotkey D) and
    obtain the following results:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清除这些代码字节（快捷键 C），然后反汇编（快捷键 D），并获得以下结果：
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here is the corresponding code in the Decompiler window:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是反编译器窗口中对应的代码：
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This was just a proof-of-concept script to demonstrate the use of emulators
    to aid in code deobfuscation, but it does show how a relatively general-purpose
    emulator can be built within Ghidra by using its emulator support classes. There
    are other situations where developing and using emulators are an appropriate course
    of action. An immediate advantage of emulation over debugging is that potentially
    malicious code is never actually executed by an emulator, whereas debugger-assisted
    deobfuscation must allow at least some portion of the malicious program to execute
    in order to obtain the deobfuscated version of the program.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个概念验证脚本，用于展示如何利用仿真器帮助代码去模糊化，但它确实展示了如何通过使用 Ghidra 的仿真器支持类在 Ghidra 中构建一个相对通用的仿真器。还有其他情况下，开发和使用仿真器是合适的做法。与调试相比，仿真有一个直接的优势，即潜在的恶意代码永远不会被仿真器实际执行，而调试器辅助的去模糊化必须至少允许恶意程序的某部分执行，以便获得去模糊化后的程序版本。
- en: '### **Summary**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '### **总结**'
- en: Obfuscated programs are the rule rather than the exception when it comes to
    malware these days. Any attempts to study the internal operations of a malware
    sample are almost certain to require some type of deobfuscation. Whether you take
    a debugger-assisted, dynamic approach to deobfuscation or you prefer not to run
    potentially malicious code and instead choose to use scripts or emulation to deobfuscate
    your binaries, the ultimate goal is to produce a deobfuscated binary that can
    be fully disassembled and properly analyzed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，模糊化程序在恶意软件中是常态，而非例外。任何尝试研究恶意软件样本内部操作的行为，几乎都需要某种形式的去模糊化。无论你是采用调试器辅助的动态去模糊化方法，还是更倾向于不运行潜在恶意代码而选择使用脚本或仿真来去模糊化二进制文件，最终的目标是生成一个可以完全反汇编并正确分析的去模糊化二进制文件。
- en: In most cases, this final analysis will be performed using a tool such as Ghidra.
    Given this ultimate goal (of using Ghidra for analysis), it makes sense to attempt
    to use Ghidra from start to finish. The techniques presented in this chapter are
    intended to demonstrate that Ghidra is capable of far more than simply generating
    disassembly listings, and we build on this in the next chapter as we look at how
    we can use Ghidra to patch our disassembly listings.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这一最终分析将使用像 Ghidra 这样的工具进行。考虑到最终目标（使用 Ghidra 进行分析），从头到尾使用 Ghidra 是合理的。本文中介绍的技术旨在展示
    Ghidra 能做的不仅仅是生成反汇编清单，接下来的章节将基于此，探讨我们如何使用 Ghidra 来修补我们的反汇编清单。
