- en: '**2**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2**'
- en: '**IMPROVING ON USER COMMANDS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**改进用户命令**'
- en: '![image](../images/common4.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common4.jpg)'
- en: A typical Unix or Linux system includes hundreds of commands by default, which,
    when you factor in flags and the possible ways to combine commands with pipes,
    produces millions of different ways to work on the command line.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的 Unix 或 Linux 系统默认包括数百个命令，当你考虑到标志和将命令与管道组合的不同方式时，就会产生数百万种不同的命令行工作方式。
- en: Before we go any further, [Listing 2-1](ch02.xhtml#ch2ex1) shows a bonus script
    that will tell you how many commands are in your `PATH`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入之前，[清单 2-1](ch02.xhtml#ch2ex1)展示了一个附加脚本，它会告诉你 `PATH` 中有多少个命令。
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 2-1: Counting the number of executables and nonexecutables in the
    current* `*PATH*`'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-1：计算当前`*PATH*`中可执行文件和非可执行文件的数量*'
- en: This script counts the number of executable files rather than just the number
    of files, and it can be used to reveal how many commands and nonexecutables are
    in the default `PATH` variables of many popular operating systems (see [Table
    2-1](ch02.xhtml#ch02table1)).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本计算的是可执行文件的数量，而不仅仅是文件的数量，它可以用来揭示许多流行操作系统默认 `PATH` 变量中有多少命令和非可执行文件（见[表 2-1](ch02.xhtml#ch02table1)）。
- en: '**Table 2-1:** Typical Command Count by OS'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-1：** 各操作系统的典型命令数量'
- en: '| **Operating system** | **Commands** | **Nonexecutables** |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| **操作系统** | **命令数** | **非可执行文件数** |'
- en: '| --- | --- | --- |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Ubuntu 15.04 (including all developer libraries) | 3,156 | 5 |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| Ubuntu 15.04（包括所有开发者库） | 3,156 | 5 |'
- en: '| OS X 10.11 (with developer options installed) | 1,663 | 11 |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| OS X 10.11（安装了开发者选项） | 1,663 | 11 |'
- en: '| FreeBSD 10.2 | 954 | 4 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| FreeBSD 10.2 | 954 | 4 |'
- en: '| Solaris 11.2 | 2,003 | 15 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| Solaris 11.2 | 2,003 | 15 |'
- en: 'Clearly, the different flavors of Linux and Unix offer a large number of commands
    and executable scripts. Why are there so many? The answer is based on the foundational
    Unix philosophy: commands should do one thing, and do it well. Word processors
    that have spellcheck, find file, and email capabilities might work well in the
    Windows and Mac world, but on the command line, each of these functions should
    be separate and discrete.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，不同版本的 Linux 和 Unix 提供了大量的命令和可执行脚本。为什么会有这么多？答案基于 Unix 的基本哲学：命令应该做一件事，并且做得好。具有拼写检查、文件查找和电子邮件功能的文字处理器在
    Windows 和 Mac 环境中可能运作良好，但在命令行中，每个功能都应该是独立且离散的。
- en: There are lots of advantages to this design philosophy, the most important being
    that each function can be modified and extended individually, giving all applications
    that utilize it access to these new capabilities. With any task you might want
    to perform on Unix, you can usually cobble together something that’ll do the trick
    easily, whether by downloading some nifty utility that adds capabilities to your
    system, creating some aliases, or dipping a toe into the shell-scripting pond.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计哲学有很多优点，最重要的一点是每个功能都可以单独修改和扩展，从而让所有使用它的应用程序都能获得这些新功能。无论你想在 Unix 上执行什么任务，通常都能轻松组合出一些能解决问题的东西，无论是通过下载添加新功能的实用工具、创建一些别名，还是稍微接触一下
    shell 脚本的世界。
- en: The scripts throughout the book not only are helpful but also are a logical
    extension of the Unix philosophy. After all, ’tis better to extend and expand
    than to build complex, incompatible versions of commands for your own installation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的脚本不仅有帮助，而且是 Unix 哲学的逻辑延伸。毕竟，比起为自己的安装构建复杂且不兼容的命令版本，扩展和扩展现有功能要好得多。
- en: The scripts explored in this chapter are all similar to the script in [Listing
    2-1](ch02.xhtml#ch2ex1) in that they add fun or useful features and capabilities
    without a high degree of complexity. Some of the scripts accept different command
    flags to allow even greater flexibility in their use, and some also demonstrate
    how a shell script can be used as a *wrapper*, a program that intercedes to allow
    users to specify commands or command flags in a common notation and then translates
    those flags into the proper format and syntax required by the actual Unix command.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨的脚本与[清单 2-1](ch02.xhtml#ch2ex1)中的脚本相似，它们添加了有趣或有用的功能和特性，同时保持较低的复杂度。一些脚本接受不同的命令标志，以提供更大的灵活性，而一些脚本还展示了如何将一个
    shell 脚本作为 *包装器*，一个插入程序，允许用户以一种通用的表示法指定命令或命令标志，然后将这些标志转换成实际 Unix 命令所需的正确格式和语法。
- en: '**#14 Formatting Long Lines**'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#14 格式化长行**'
- en: If you’re lucky, your Unix system already includes the `fmt` command, a program
    that’s remarkably useful if you work with text regularly. From reformatting emails
    to making lines use up all the available width in documents, `fmt` is a helpful
    utility to know.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果幸运的话，你的 Unix 系统已经包含了 `fmt` 命令，这对于经常处理文本的用户来说是一个非常有用的程序。从重新格式化电子邮件到使行文本充满文档中所有可用宽度，`fmt`
    是一个值得了解的实用工具。
- en: However, some Unix systems don’t include `fmt`. This is particularly true of
    legacy systems, which often have fairly minimalistic implementations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些 Unix 系统并不包含 `fmt`。这在老旧系统中尤其常见，这些系统通常有着相对简化的实现。
- en: As it turns out, the `nroff` command, which has been part of Unix since the
    very beginning and is a shell script wrapper in its own right, can be used in
    short shell scripts to wrap long lines and fill in short lines to even out line
    lengths, as shown in [Listing 2-2](ch02.xhtml#ch2ex2).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，`nroff` 命令自 Unix 初期便已存在，并且本身就是一个 shell 脚本封装器，可以在短小的 shell 脚本中使用，用于包装长行并填充短行以平衡行长，如在[列表
    2-2](ch02.xhtml#ch2ex2)中所示。
- en: '***The Code***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码部分***'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 2-2: The* `*fmt*` *shell script for formatting long texts nicely*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-2：用于良好格式化长文本的 `*fmt*` shell 脚本*'
- en: '***How It Works***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'This succinct script offers two different command flags: `-w X` to specify
    that lines should be wrapped when they exceed `X` characters (the default is 72)
    and `-h` to enable hyphenated word breaks across lines. Notice the check for flags
    at ➊. The `while` loop uses `getopts` to read each option passed to the script
    one at a time, and the inner `case` block decides what to do with them. Once the
    options are parsed, the script calls `shift` at ➋ to throw away all the option
    flags using `$OPTIND` (which holds the index of the next argument to be read by
    `getopts`) and leaves the remaining arguments to continue getting processed.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简洁的脚本提供了两个不同的命令标志：`-w X` 用于指定当行长度超过 `X` 字符时进行换行（默认值为 72），`-h` 用于启用跨行的连字符断词。请注意，在➊处检查标志。`while`
    循环使用 `getopts` 一次读取传递给脚本的每个选项，内层的 `case` 块决定如何处理这些选项。一旦选项被解析，脚本会在➋调用 `shift` 丢弃所有选项标志，使用
    `$OPTIND`（它保存着 `getopts` 要读取的下一个参数的索引），并将剩余的参数继续处理。
- en: 'This script also makes use of a *here document* (discussed in [Script #9](ch01.xhtml#ch01lev1sec10)
    on [page 34](ch01.xhtml#page_34)), which is a type of code block that can be used
    to feed multiple lines of input to a command. Using this notational convenience,
    the script at ➌ feeds `nroff` all the necessary commands to achieve the desired
    output. In this document, we use a bashism to replace a variable that isn’t defined
    ➍, in order to provide a sane default value if the user does not specify one as
    an argument. Finally, the script calls the `cat` command with the requested file
    names to process. To complete the task, the `cat` command’s output is also fed
    directly to `nroff` ➎. This is a technique that will appear frequently in the
    scripts presented in this book.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '这个脚本还使用了 *here document*（在[脚本 #9](ch01.xhtml#ch01lev1sec10)中有讨论，在[第 34 页](ch01.xhtml#page_34)），这是一种可以向命令提供多行输入的代码块类型。通过这种书写便捷方式，脚本在
    ➌ 处将所有必要的命令传递给 `nroff`，以实现预期输出。在本文档中，我们使用了一种 bash 语法替代了一个未定义的变量 ➍，以便为用户未指定参数时提供一个合理的默认值。最后，脚本调用了
    `cat` 命令，处理请求的文件名。为了完成任务，`cat` 命令的输出也会直接传递给 `nroff` ➎。这是一种在本书中会频繁出现的技巧。'
- en: '***Running the Script***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This script can be invoked directly from the command line, but it would more
    likely be part of an external pipe invoked from within an editor like `vi` or
    `vim` (for example, `!}fmt`) to format a paragraph of text.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以直接从命令行调用，但更可能作为外部管道的一部分，从 `vi` 或 `vim` 这样的编辑器内调用（例如，`!}fmt`）来格式化一段文本。
- en: '***The Results***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[Listing 2-3](ch02.xhtml#ch2ex3) enables hyphenation and specifies a maximum
    width of 50 characters.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-3](ch02.xhtml#ch2ex3) 启用了连字符处理，并指定了最大宽度为 50 字符。'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 2-3: Formatting text with the* `*fmt*` *script to hyphenate wrapped
    words at 50 characters*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-3：使用 `*fmt*` 脚本按 50 字符的宽度换行并进行连字符处理*'
- en: Compare [Listing 2-3](ch02.xhtml#ch2ex3) (note the newly hyphenated word `tinkling`,
    highlighted on lines 6 and 7) with the output in [Listing 2-4](ch02.xhtml#ch2ex4),
    generated using the default width and no hyphenation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将[列表 2-3](ch02.xhtml#ch2ex3)（注意第 6 行和第 7 行突出显示的已连字符化的单词 `tinkling`）与使用默认宽度且没有连字符处理的[列表
    2-4](ch02.xhtml#ch2ex4)的输出进行比较。
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 2-4: The default formatting of the* `*fmt*` *script with no hyphenation*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-4：没有连字符处理的 `*fmt*` 脚本的默认格式化*'
- en: '**#15 Backing Up Files as They’re Removed**'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#15 备份文件在删除时**'
- en: One of the most common problems that Unix users have is that there is no easy
    way to recover a file or folder that has been accidentally removed. There’s no
    user-friendly application like Undelete 360, WinUndelete, or an OS X utility that
    allows you to easily browse and restore deleted files at the touch of a button.
    Once you press ENTER after typing `rm *filename*`, the file is history.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Unix用户最常遇到的问题之一是，没有简单的办法恢复一个不小心删除的文件或文件夹。没有像Undelete 360、WinUndelete或OS X工具那样的用户友好应用，可以让你轻松浏览和恢复已删除的文件，只需按一个按钮。一旦你按下回车键，输入`rm
    *filename*`，文件就永远消失了。
- en: A solution to this problem is to secretly and automatically archive files and
    directories to a *.deleted-files* archive. With some fancy footwork in a script
    (as [Listing 2-5](ch02.xhtml#ch2ex5) shows), this process can be made almost completely
    invisible to users.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是将文件和目录秘密且自动地归档到一个*.deleted-files*归档中。通过脚本中的一些巧妙操作（如[清单 2-5](ch02.xhtml#ch2ex5)所示），这个过程几乎可以对用户完全隐形。
- en: '***The Code***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 2-5: The* `*newrm*` *shell script, which backs up files before they
    are deleted from the disk*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-5：* `*newrm*` *shell脚本，它在文件从磁盘中删除之前进行备份*'
- en: '***How It Works***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: There are a bunch of cool things to consider in this script, not the least of
    which is the significant effort it puts forth to ensure that users aren’t aware
    it exists. For example, this script doesn’t generate error messages in situations
    where it can’t work; it just lets `realrm` generate them by invoking (typically)
    */bin/rm* with possibly bad parameters. The calls to `realrm` are done with the
    `exec` command, which replaces the current process with the new process specified.
    As soon as `exec` invokes `realrm` ➍, it effectively exits this script, and the
    return code from the `realrm` process is given to the invoking shell.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本中有许多值得注意的地方，其中最显著的是它确保用户不会意识到它的存在。例如，当脚本无法工作时，它不会生成错误信息；它只是让`realrm`生成错误信息，通常是通过调用可能包含错误参数的*/bin/rm*。对`realrm`的调用是通过`exec`命令完成的，该命令用指定的新进程替换当前进程。一旦`exec`调用`realrm`
    ➍，它实际上就退出了这个脚本，并且`realrm`进程的返回码会传递给调用的shell。
- en: Because this script secretly creates a directory in the user’s home directory
    ➊, it needs to ensure that the files there aren’t suddenly readable by others
    simply because of a badly set `umask` value. (The `umask` value defines the default
    permissions for a newly created file or directory.) To avoid such oversharing,
    the script at ➋ uses `chmod` to ensure that the directory is set to read/write/execute
    for the user and is closed for everyone else.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个脚本会在用户的主目录中秘密创建一个目录 ➊，所以它需要确保该目录中的文件不会因为不正确设置的`umask`值而突然对其他人可读。（`umask`值定义了新创建的文件或目录的默认权限。）为了避免这种过度共享，脚本在
    ➋ 处使用`chmod`来确保该目录设置为对用户可读/写/执行，并且对其他人关闭权限。
- en: 'Finally at ➌, the script uses `basename` to strip out any directory information
    from the file’s path, and it adds a date- and timestamp to every deleted file
    in the form *second.minute.hour.day.month.filename*:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最终在 ➌ 处，脚本使用`basename`去除文件路径中的任何目录信息，并且为每个已删除的文件添加一个日期和时间戳，格式为*秒.分钟.小时.天.月.文件名*：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice the use of multiple `$( )` elements in the same substitution. Though
    perhaps a bit complicated, it’s nonetheless helpful. Remember, anything between
    `$(` and `)` is fed into a subshell, and the whole expression is then replaced
    by the result of that command.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在同一替换中使用多个`$( )`元素。虽然这可能有些复杂，但仍然很有帮助。记住，任何在`$(`和`)`之间的内容都会被送入子shell中执行，然后整个表达式会被该命令的结果替代。
- en: So why bother with a timestamp anyway? To support storing multiple deleted files
    with the same name. Once the files are archived, the script makes no distinction
    between */home/oops.txt* and */home/subdir/oops.txt*, other than by the times
    they were deleted. If multiple files with same name are deleted simultaneously
    (or within the same second), the files that were archived first will get overwritten.
    One solution to this problem would be to add the absolute paths of the original
    files to the archived filenames.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么还要使用时间戳呢？是为了支持存储多个具有相同名称的已删除文件。一旦文件被归档，脚本不再区分*/home/oops.txt*和*/home/subdir/oops.txt*，除了它们被删除的时间。如果多个同名文件同时被删除（或者在同一秒内删除），先被归档的文件将被覆盖。解决这个问题的一种方法是将原始文件的绝对路径添加到归档文件名中。
- en: '***Running the Script***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: 'To install this script, add an alias so that when you enter `rm`, you actually
    run this script, not the `/bin/rm` command. A bash or ksh alias would look like
    this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装这个脚本，可以添加一个别名，使得当你输入 `rm` 时，实际上运行的是这个脚本，而不是 `/bin/rm` 命令。一个 bash 或 ksh 的别名可能是这样的：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***The Results***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: The results of running this script are hidden by design (as [Listing 2-6](ch02.xhtml#ch2ex6)
    shows), so let’s keep an eye on the *.deleted-files* directory along the way.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个脚本的结果是故意隐藏的（正如[列表 2-6](ch02.xhtml#ch2ex6)所示），所以我们一路上要关注 *.deleted-files*
    目录。
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 2-6: Testing the* `*newrm*` *shell script*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-6：测试* `*newrm*` *shell 脚本*'
- en: Exactly right. While the file was deleted from the local directory, a copy of
    it was secretly squirreled away in the *.deleted-files* directory. The timestamp
    allows other deleted files with the same name to be stored in the same directory
    without overwriting each other.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 完全正确。虽然文件已从本地目录中删除，但它的副本被秘密地存放在 *.deleted-files* 目录中。时间戳允许其他同名的已删除文件存储在同一目录中，而不会互相覆盖。
- en: '***Hacking the Script***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: 'One useful tweak would be to change the timestamp so that it’s in reverse time
    order to produce file listings from `ls` in chronological order. Here’s the line
    to modify the script:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的改动是更改时间戳，使其按逆时间顺序排列，从而按照时间顺序显示 `ls` 的文件列表。下面是修改脚本的代码：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You could reverse the order of tokens in that formatted request so that the
    original filename is first and the date is second in the backed-up filename. However,
    since our time granularity is seconds, you might remove more than one version
    of an identically named file within the same second (for example, `rm test testdir/test`),
    resulting in two identically named files. Therefore, another useful modification
    would be to incorporate the location of the file into the archived copy. This
    would produce, for example, *timestamp.test* and *timestamp.testdir.test*, which
    are clearly two different files.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以反转该格式化请求中令牌的顺序，使得原始文件名排在前，日期排在备份文件名的后面。然而，由于我们的时间粒度是秒，你可能会在同一秒内删除多个版本的同名文件（例如，`rm
    test testdir/test`），这会导致两个同名文件。因此，另一个有用的修改是将文件的存储位置加入到归档副本中。例如，这会生成 *timestamp.test*
    和 *timestamp.testdir.test*，它们显然是两个不同的文件。
- en: '**#16 Working with the Removed File Archive**'
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#16 处理已删除文件归档**'
- en: Now that a directory of deleted files is hidden within the user’s home directory,
    a script to let the user choose between different versions of deleted files would
    be useful. However, it’s quite a task to address all the possible situations,
    ranging from not finding the specified file at all to finding multiple deleted
    files that match the given criteria. In the case of more than one match, for example,
    should the script automatically pick the newest file to undelete? Throw an error
    indicating how many matches there are? Or present the different versions and let
    the user pick? Let’s see what we can do with [Listing 2-7](ch02.xhtml#ch2ex7),
    which details the `unrm` shell script.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，已删除文件的目录隐藏在用户的主目录中，一个让用户在不同版本的已删除文件之间选择的脚本将非常有用。然而，要处理所有可能的情况是相当复杂的，从完全找不到指定文件，到找到多个匹配给定条件的已删除文件。例如，如果有多个匹配项，脚本应该自动选择最新的文件来恢复吗？抛出一个错误，指示有多少个匹配项？还是展示不同版本并让用户选择？让我们看看[列表
    2-7](ch02.xhtml#ch2ex7)，它详细介绍了 `unrm` 脚本。
- en: '***The Code***'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 2-7: The* `*unrm*` *shell script for restoring backed-up files*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-7：恢复备份文件的* `*unrm*` *shell 脚本*'
- en: '***How It Works***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原理***'
- en: 'The first chunk of code at ➊, the `if [$# -eq 0]` conditional block, executes
    if no arguments are specified, displaying the contents of the deleted files archive.
    However, there’s a catch: we don’t want to show the user the timestamp data we
    added to the filenames since that’s only for the script’s internal use. It would
    just clutter up the output. In order to display this data in a more attractive
    format, the `sed` statement at ➋ deletes the first five occurrences of *digit
    digit dot* in the `ls` output.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处的第一段代码，`if [$# -eq 0]` 条件块，会在没有指定参数时执行，显示已删除文件的归档内容。然而，这里有一个问题：我们不希望向用户展示我们添加到文件名中的时间戳数据，因为这些数据仅供脚本内部使用，展示出来会让输出显得杂乱。为了以更吸引人的格式显示这些数据，➋处的
    `sed` 语句会删除 `ls` 输出中前五个 *数字 数字 点* 的出现。
- en: The user can specify the name of the file or directory to recover as an argument.
    The next step at ➌ is to ascertain how many matches there are for the name provided.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过指定文件或目录的名称作为参数来恢复该文件或目录。接下来的步骤在➌处是确定所提供名称的匹配项数量。
- en: The unusual use of nested double quotes in this line (around `$1`) is to ensure
    `ls` matches filenames with embedded spaces, while the `*` wildcard expands the
    match to include any preceding timestamp. The `2> /dev/null` sequence is used
    to discard any error resulting from the command instead of showing it to the user.
    The errors being discarded will most likely be *No such file or directory*, when
    the specified filename isn’t found.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行中嵌套双引号的特殊用法（围绕`$1`）是为了确保`ls`匹配包含空格的文件名，同时`*`通配符将匹配扩展到包括任何前置的时间戳。`2> /dev/null`序列用于丢弃命令产生的任何错误，而不是将其显示给用户。被丢弃的错误很可能是*没有此文件或目录*，当指定的文件名未找到时会出现此错误。
- en: If there are multiple matches for the given file or directory name, then the
    most complex part of this script, the `if [ $matches -gt 1 ]` block at ➍, is executed
    and displays all the results. Using the `-t` flag for the `ls` command in the
    main `for` loop causes the archive files to be presented from newest to oldest,
    and at ➎, a succinct call to the `awk` command translates the timestamp portion
    of the filename into a deletion date and time in parentheses. In the size calculation
    at ➐, the inclusion of the `-k` flag to `ls` forces the file sizes to be represented
    in kilobytes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定的文件或目录名有多个匹配项，则脚本中最复杂的部分，即在➍处的`if [ $matches -gt 1 ]`块将被执行，并显示所有结果。主`for`循环中使用`ls`命令的`-t`标志，使得归档文件按从最新到最旧的顺序显示，而在➎处，通过简洁地调用`awk`命令，将文件名中的时间戳部分转换为括号中的删除日期和时间。在➐处的大小计算中，通过给`ls`命令添加`-k`标志，强制文件大小以千字节为单位表示。
- en: Rather than displaying the size of matching directory entries, the script displays
    the number of files within each matching directory, which is a more helpful statistic.
    The number of entries within a directory is easy to calculate. At ➏, we just count
    the number of lines given by `ls` and strip any spaces out of the `wc` output.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本并不显示匹配目录条目的大小，而是显示每个匹配目录中包含的文件数量，这是一个更有用的统计信息。计算目录中条目的数量很容易。在➏处，我们只需要计算`ls`给出的行数，并将`wc`的输出中的空格去掉。
- en: Once the user specifies one of the possible matching files or directories, the
    exact file is identified at ➑. This statement contains a slightly different use
    of `sed`. Specifying the `-n` flag with a line number (`${desired}`) followed
    by the `p` (print) command is a very fast way to extract only the specified line
    from the input stream. Want to see only line 37? The command `sed -n 37p` does
    just that.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户指定了一个可能的匹配文件或目录，具体的文件将在➑处被识别。这条语句使用了稍微不同的`sed`用法。指定`-n`标志并使用行号（`${desired}`）后跟`p`（打印）命令，是从输入流中快速提取指定行的方式。想只看第37行？命令`sed
    -n 37p`就是这么做的。
- en: Then there’s a test at ➒ to ensure that `unrm` isn’t going to step on an existing
    copy of the file, and the file or directory is restored with a call to `/bin/mv`.
    Once that’s finished, the user is given a chance to remove the additional (probably
    superfluous) copies of the file ➓, and the script is done.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在➒处进行测试，以确保`unrm`不会覆盖现有的文件副本，并通过调用`/bin/mv`来恢复文件或目录。完成后，用户将有机会删除额外的（可能是多余的）文件副本➓，脚本执行完毕。
- en: 'Note that using `ls` with `*"$1"` matches any filenames ending with the value
    in `$1`, so the list of multiple “matching files” may contain more than just the
    file the user wants to restore. For instance, if the deleted files directory contains
    the files *11.txt* and *111.txt*, running `unrm 11.txt` would signal that it found
    multiple matches and return listings for both *11.txt* and *111.txt*. While that
    might be okay, once the user chooses to restore the correct file (*11.txt*), accepting
    the prompt to delete additional copies of the file would also remove *111.txt*.
    Therefore, defaulting to delete under those circumstances might not be optimal.
    However, this could be easily overcome by using the `??.??.??.??.??."$1"` pattern
    instead, if you kept the same timestamp format for `newrm` as shown in [Script
    #15](ch02.xhtml#ch02lev1sec02) on [page 55](ch02.xhtml#page_55).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，使用 `ls` 配合 `*"$1"` 可以匹配任何以 `$1` 中的值结尾的文件名，因此多个“匹配文件”的列表可能包含不仅仅是用户想要恢复的文件。例如，如果删除的文件目录中包含文件
    *11.txt* 和 *111.txt*，运行 `unrm 11.txt` 将提示找到多个匹配项，并返回 *11.txt* 和 *111.txt* 的列表。虽然这可能没问题，但一旦用户选择恢复正确的文件（*11.txt*），接受提示删除其他副本时，也会删除
    *111.txt*。因此，在这种情况下默认删除可能并不是最优选择。然而，如果你像[脚本 #15](ch02.xhtml#ch02lev1sec02)中所示的那样保持相同的时间戳格式，改用
    `??.??.??.??.??."$1"` 模式就可以轻松解决这个问题，如[第55页](ch02.xhtml#page_55)所示。'
- en: '***Running the Script***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: There are two ways to run this script. Without any arguments, the script will
    show a listing of all files and directories in the user’s deleted files archive.
    When given a filename as its argument, the script will try to restore that file
    or directory (if there’s only one match), or it will show a list of candidates
    for restoration and allow the user to specify which version of the deleted file
    or directory to restore.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以运行这个脚本。没有任何参数时，脚本会显示用户删除的文件归档中所有文件和目录的列表。当提供一个文件名作为参数时，脚本会尝试恢复该文件或目录（如果只有一个匹配项），或者会显示候选恢复文件的列表，并允许用户指定要恢复的删除文件或目录的版本。
- en: '***The Results***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: Without any arguments specified, the script shows what’s in the deleted files
    archive as [Listing 2-8](ch02.xhtml#ch2ex8) shows.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有指定任何参数的情况下，脚本会显示删除文件归档中的内容，如[清单 2-8](ch02.xhtml#ch2ex8)所示。
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 2-8: Running the* `*unrm*` *shell script with no arguments lists the
    current files available to restore*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-8：运行没有参数的* `*unrm*` *shell 脚本列出当前可恢复的文件*'
- en: When a filename is specified, the script displays more information about the
    file if there are multiple files with that name, as shown in [Listing 2-9](ch02.xhtml#ch2ex9).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定了文件名时，如果有多个同名文件，脚本会显示更多关于该文件的信息，如[清单 2-9](ch02.xhtml#ch2ex9)所示。
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 2-9: Running the* `*unrm*` *shell script with a single argument attempts
    to restore the file*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-9：运行带有单个参数的* `*unrm*` *shell 脚本尝试恢复文件*'
- en: '***Hacking the Script***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: If you use this script, be aware that without any controls or limits, the files
    and directories in the deleted files archive will grow without bound. To avoid
    this, invoke `find` from within a `cron` job to prune the deleted files archive,
    using the `-mtime` flag to identify those files that have been sitting untouched
    for weeks. A 14-day archive is probably quite sufficient for most users and will
    keep the archival script from consuming too much disk space.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用这个脚本，请注意，由于没有任何控制或限制，删除文件归档中的文件和目录将无限增长。为了避免这种情况，可以在 `cron` 作业中调用 `find`
    来修剪删除文件归档，使用 `-mtime` 标志来识别那些几周没有被触碰的文件。对于大多数用户来说，14天的归档时间应该足够，并且可以防止归档脚本占用过多的磁盘空间。
- en: While we’re at it, there are some improvements that could make this script more
    user friendly. Think about adding starting flags like `-l` to `restore latest`
    and `-D` to `delete 00additional copies of the file`. Which flags would you add,
    and how would they streamline processing?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论这些时，实际上有一些改进可以使这个脚本更加用户友好。可以考虑添加像 `-l` 来恢复最新文件，或者 `-D` 来删除多余副本等启动标志。你会添加哪些标志？它们会如何简化处理流程？
- en: '**#17 Logging File Removals**'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#17 记录文件删除**'
- en: Instead of archiving deleted files, you may just want to keep track of what
    deletions are happening on your system. In [Listing 2-10](ch02.xhtml#ch2ex10),
    file deletions with the `rm` command will be logged in a separate file without
    notifying the user. This can be accomplished by using the script as a wrapper.
    The basic idea of wrappers is that they live between an actual Unix command and
    the user, offering the user useful functionality that’s not available with the
    original command alone.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想归档已删除的文件，你也许只想追踪系统上发生的删除事件。在 [Listing 2-10](ch02.xhtml#ch2ex10) 中，使用 `rm`
    命令删除的文件会被记录到一个单独的文件中，而不会通知用户。这可以通过使用脚本作为封装器来实现。封装器的基本理念是，它们位于实际的 Unix 命令和用户之间，提供原始命令无法单独提供的有用功能。
- en: '**NOTE**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Wrappers are such a powerful concept that you’ll see them show up time and
    again as you go through this book.*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*封装器是一个非常强大的概念，随着你深入本书，你会发现它们反复出现。*'
- en: '***The Code***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 2-10: The* `*logrm*` *shell script*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 2-10: *`*logrm*`* *shell 脚本*'
- en: '***How It Works***'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: The first section ➊ tests the user input, generating a simple file listing if
    no arguments are given. Then at ➋, the script tests whether argument `1` is `-s`;
    if so, it skips logging the removal request. Finally, the timestamp, user, and
    command are added to the *$removelog* file ➌, and the user command is silently
    passed over to the real */bin/rm* program ➍.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分 ➊ 测试用户输入，如果没有给定参数，则生成一个简单的文件列表。然后在 ➋，脚本测试参数 `1` 是否为 `-s`；如果是，它会跳过删除请求的日志记录。最后，时间戳、用户和命令会被添加到
    *$removelog* 文件中 ➌，并且用户的命令会被静默地传递给真正的 */bin/rm* 程序 ➍。
- en: '***Running the Script***'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: Rather than giving this script a name like `logrm`, a typical way to install
    a wrapper program is to rename the underlying command it’s intending to wrap and
    then install the wrapper using the original command’s old name. If you choose
    this route, however, make sure that the wrapper invokes the newly renamed program,
    not itself! For example, if you rename */bin/rm* to */bin/rm.old*, and name this
    script */bin/rm*, then the last few lines of the script will need to be changed
    so that it invokes */bin/rm.old* instead of itself.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与其给这个脚本命名为 `logrm`，一个典型的封装程序安装方式是重命名它所封装的底层命令，然后使用原始命令的旧名称来安装封装器。然而，如果你选择这种方式，请确保封装器调用的是新重命名的程序，而不是它自己！例如，如果你将
    */bin/rm* 重命名为 */bin/rm.old*，并将这个脚本命名为 */bin/rm*，那么脚本的最后几行需要进行更改，以便它调用的是 */bin/rm.old*
    而不是它自己。
- en: 'Alternatively, you can use an alias to replace standard `rm` calls with this
    command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以使用别名将标准的 `rm` 命令替换为这个命令：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In either case, you will need write and execute access to */var/log*, which
    might not be the default configuration on your particular system.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，你都需要对 */var/log* 目录具有写入和执行权限，这可能不是你系统上的默认配置。
- en: '***The Results***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: Let’s create a few files, delete them, and then examine the remove log, as shown
    in [Listing 2-11](ch02.xhtml#ch2ex11).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建几个文件，删除它们，然后查看删除日志，如 [Listing 2-11](ch02.xhtml#ch2ex11) 所示。
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 2-11: Testing the* `*logrm*` *shell script*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 2-11: 测试* `*logrm*` *shell 脚本*'
- en: Aha! Notice that on Thursday, user Susan deleted the file */tmp/central.log*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！注意到周四，用户 Susan 删除了文件 */tmp/central.log*。
- en: '***Hacking the Script***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: There’s a potential log file ownership permission problem here. Either the *remove.log*
    file is writable by all, in which case a user could clear its contents out with
    a command like `cat /dev/null > /var/log/remove.log`, or it isn’t writable by
    all, in which case the script can’t log the events. You could use a `setuid` permission—with
    the script running as root—so that the script runs with the same permissions as
    the log file. However, there are two problems with this approach. First, it’s
    a really bad idea! Never run shell scripts under `setuid`! By using `setuid` to
    run a command as a specific user, no matter who is executing the command, you
    are potentially introducing security weaknesses to your system. Second, you could
    get into a situation where the users have permission to delete their files but
    the script doesn’t, and because the effective uid set with `setuid` would be inherited
    by the `rm` command itself, things would break. Great confusion would ensue when
    users couldn’t even remove their own files!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能会遇到日志文件的所有权权限问题。要么 *remove.log* 文件对所有人可写，在这种情况下，用户可以使用类似 `cat /dev/null
    > /var/log/remove.log` 的命令清空其内容，要么该文件对所有人不可写，在这种情况下，脚本无法记录事件。你可以使用 `setuid` 权限——脚本以
    root 用户身份运行——这样脚本就会与日志文件具有相同的权限。然而，这种方法有两个问题。首先，这是一个非常糟糕的主意！绝对不要在 `setuid` 下运行
    shell 脚本！通过使用 `setuid` 以特定用户身份运行命令，无论是谁执行该命令，都可能会给系统带来安全隐患。其次，可能会出现用户可以删除自己的文件，但脚本却无法删除的情况，因为
    `setuid` 设置的有效用户 ID 会被 `rm` 命令继承，导致系统出错。当用户甚至无法删除自己的文件时，系统将陷入混乱！
- en: 'If you have an ext2, ext3, or ext4 filesystem (as is usually the case with
    Linux), a different solution is to use the `chattr` command to set a specific
    append-only file permission on the log file and then leave it writable to all
    without any danger. Yet another solution is to write the log messages to `syslog`,
    using the helpful `logger` command. Logging the `rm` commands with `logger` is
    straightforward, as shown here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 ext2、ext3 或 ext4 文件系统（通常是 Linux 系统），另一种解决方案是使用 `chattr` 命令在日志文件上设置一个特定的仅追加文件权限，然后让所有人都可以写入而不会有任何危险。另一种解决方案是将日志信息写入
    `syslog`，使用便捷的 `logger` 命令。使用 `logger` 记录 `rm` 命令是非常简单的，下面是示例：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This adds an entry to the `syslog` data stream, which is untouchable by regular
    users and is tagged with `logrm`, the username, and the command specified.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这会向 `syslog` 数据流中添加一个条目，普通用户无法触及，该条目标记为 `logrm`，包括用户名和指定的命令。
- en: '**NOTE**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you opt to use* `*logger*`*, you’ll want to check* `*syslogd(8)*` *to ensure
    that your configuration doesn’t discard* `*user.notice*` *priority log events.
    It’s almost always specified in the* /etc/syslogd.conf *file.*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你选择使用* `*logger*` *，你需要检查* `*syslogd(8)*` *以确保你的配置不会丢弃* `*user.notice*`
    *优先级的日志事件。它几乎总是会在* /etc/syslogd.conf *文件中指定。*'
- en: '**#18 Displaying the Contents of Directories**'
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#18 显示目录内容**'
- en: 'One aspect of the `ls` command has always seemed pointless: when a directory
    is listed, `ls` either lists the directory’s contents file by file or shows the
    number of 1,024-byte blocks required for the directory data. A typical entry in
    an `ls -l` output might be something like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls` 命令的一个方面一直让人觉得毫无意义：当列出一个目录时，`ls` 要么逐个列出目录中的文件，要么显示目录数据所需的 1,024 字节块数。`ls
    -l` 输出中的一个典型条目可能是这样的：'
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: But that’s not very useful! What we really want to know is how many files are
    in the directory. That’s what the script in [Listing 2-12](ch02.xhtml#ch2ex12)
    does. It generates a nice multicolumn listing of files and directories, showing
    files with their sizes and directories with the number of files they contain.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不太有用！我们真正想知道的是目录中有多少个文件。这就是 [Listing 2-12](ch02.xhtml#ch2ex12) 中脚本的作用。它生成了一个多列文件和目录的清单，显示文件的大小以及包含的文件数。
- en: '***The Code***'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 2-12: The* `*formatdir*` *shell script for more readable directory
    listings*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 2-12: 更具可读性的目录列出脚本* `*formatdir*`'
- en: '***How It Works***'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原理***'
- en: 'One of the most interesting parts of this script is the `readablesize` function
    ➊, which accepts numbers in kilobytes and outputs their value in either kilobytes,
    megabytes, or gigabytes, depending on which unit is most appropriate. Instead
    of having the size of a very large file shown as 2,083,364KB, for example, this
    function will instead show a size of 2.08GB. Note that `readablesize` is called
    with the `$( )` notation ➍:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本最有趣的部分之一是 `readablesize` 函数 ➊，它接受以千字节为单位的数字，并根据最合适的单位输出其值，可能是千字节、兆字节或吉字节。例如，代替将一个非常大的文件的大小显示为
    2,083,364KB，该函数会将其显示为 2.08GB。请注意，`readablesize` 是通过 `$( )` 语法 ➍ 调用的：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since subshells automatically inherit any functions defined in the running shell,
    the subshell created by the `$()` sequence has access to the `readablesize` function.
    Handy.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于子shell会自动继承运行中的shell中定义的所有函数，因此通过 `$()` 语法创建的子shell可以访问 `readablesize` 函数，非常方便。
- en: Near the top of the script at ➋, there is also a shortcut that allows users
    to specify a directory other than the current directory and then changes the current
    working directory of the running shell script to the desired location, simply
    by using `cd`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的顶部 ➋，还有一个快捷方式，允许用户指定一个不同于当前目录的目录，然后通过使用 `cd` 命令将运行中的shell脚本的当前工作目录更改为所需位置。
- en: The main logic of this script involves organizing its output into two neat,
    aligned columns. One issue to deal with is that you can’t simply replace spaces
    with line breaks in the output stream, because files and directories may have
    spaces within their names. To get around this problem, the script at ➎ first replaces
    each space with a sequence of three carets (`^^^`). Then it uses the `xargs` command
    to merge paired lines so that every group of two lines becomes one line separated
    by a real, expected space. Finally, at ➏ it uses the `awk` command to output columns
    in the proper alignment.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的主要逻辑是将输出组织成两列整齐对齐的形式。需要处理的一个问题是，不能简单地将空格替换为换行符，因为文件和目录的名称中可能包含空格。为了解决这个问题，脚本在
    ➎ 首先将每个空格替换为三个插入符号（`^^^`）的序列。然后，它使用 `xargs` 命令合并配对的行，使得每一对行变成一行，并通过一个真实的、预期的空格分隔。最后，在
    ➏ 它使用 `awk` 命令输出列并正确对齐。
- en: 'Notice how the number of (nonhidden) entries in a directory is easily calculated
    at ➌ with a quick call to `wc` and a `sed` invocation to clean up the output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过在 ➌ 使用 `wc` 快速调用并结合 `sed` 命令清理输出，可以轻松计算出目录中（非隐藏）条目的数量：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***Running the Script***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: For a listing of the current directory, invoke the command without arguments,
    as [Listing 2-13](ch02.xhtml#ch2ex13) shows. For information about the contents
    of a different directory, specify a directory name as the sole command line argument.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出当前目录，执行没有参数的命令，正如 [列表 2-13](ch02.xhtml#ch2ex13) 所示。若要查看其他目录的内容，只需指定目录名作为唯一的命令行参数。
- en: '***The Results***'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 2-13: Testing the* `*formatdir*` *shell script*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-13：测试* `*formatdir*` *shell 脚本*'
- en: '***Hacking the Script***'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: An issue worth considering is whether you happen to have a user who likes to
    use sequences of three carets in filenames. This naming convention is pretty unlikely—a
    116,696-file Linux install that we spot-tested didn’t have even a single caret
    within any of its filenames—but if it did occur, you’d get some confusing output.
    If you’re concerned, you could address this potential pitfall by translating spaces
    into another sequence of characters that’s even less likely to occur in user filenames.
    Four carets? Five?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得考虑的问题是，是否有用户喜欢在文件名中使用三个插入符号（^）。这种命名规范相当不太可能出现——我们在一次对 116,696 个文件的 Linux
    安装的测试中，发现它的文件名中甚至没有一个插入符号——但如果确实发生了，你将得到一些令人困惑的输出。如果你担心，可以通过将空格转化为另一种字符序列来解决这个潜在的问题，这样的字符序列在用户文件名中发生的可能性会更小。四个插入符号？五个？
- en: '**#19 Locating Files by Filename**'
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#19 通过文件名定位文件**'
- en: 'One command that’s quite useful on Linux systems, but isn’t always present
    on other Unix flavors, is `locate`, which searches a prebuilt database of filenames
    for a user-specified regular expression. Ever want to quickly find the location
    of the master *.cshrc* file? Here’s how that’s done with `locate`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 系统中有一个非常有用的命令，但并不是所有 Unix 系统都具备，它就是 `locate`，它可以在一个预构建的文件名数据库中搜索用户指定的正则表达式。曾经想快速找到主
    `*.cshrc*` 文件的位置吗？这就是使用 `locate` 来完成的方式：
- en: '![image](../images/f0068-01.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0068-01.jpg)'
- en: You can see that the master *.cshrc* file is in the */private/etc* directory
    on this OS X system. The version of `locate` we’re going to build sees every file
    on the disk when building its internal file index, whether the file is in the
    trash queue or on a separate volume or even if it’s a hidden dotfile. This is
    both an advantage and a disadvantage, as we will discuss shortly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，主*.cshrc*文件位于这台OS X系统的*/private/etc*目录中。我们将要构建的`locate`版本在构建内部文件索引时，能够看到磁盘上的每一个文件，无论该文件是否在回收站队列中，是否在单独的卷中，甚至是否是隐藏的点文件。这既是一个优势，也可能是一个劣势，我们将稍后讨论。
- en: '***The Code***'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: This method of finding files is simple to implement and comes in two scripts.
    The first (shown in [Listing 2-14](ch02.xhtml#ch2ex14)) builds a database of all
    filenames by invoking `find`, and the second (shown in [Listing 2-15](ch02.xhtml#ch2ex15))
    is a simple `grep` of the new database.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种查找文件的方法简单易行，分为两个脚本。第一个（见[列表 2-14](ch02.xhtml#ch2ex14)）通过调用`find`来构建所有文件名的数据库，第二个（见[列表
    2-15](ch02.xhtml#ch2ex15)）则是对新数据库进行简单的`grep`查找。
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 2-14: The* `*mklocatedb*` *shell script*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-14：`*mklocatedb*`* shell脚本*'
- en: The second script is even shorter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个脚本甚至更简短。
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 2-15: The* `*locate*` *shell script*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-15：`*locate*`* shell脚本*'
- en: '***How It Works***'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'The `mklocatedb` script must be run as the root user to ensure that it can
    see all the files in the entire system, so this is checked at ➊ with a call to
    `whoami`. Running any script as root, however, is a security problem because if
    a directory is closed to a specific user’s access, the `locate` database shouldn’t
    store any information about the directory or its contents. This issue will be
    addressed in [Chapter 5](ch05.xhtml#ch05) with a new, more secure `locate` script
    that takes privacy and security into account (see [Script #39](ch05.xhtml#ch05lev1sec05)
    on [page 127](ch05.xhtml#page_127)). For now, however, this script exactly emulates
    the behavior of the `locate` command in standard Linux, OS X, and other distributions.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '必须以root用户身份运行`mklocatedb`脚本，以确保它能够看到系统中的所有文件，因此在➊处通过调用`whoami`进行了检查。然而，以root身份运行任何脚本都是一个安全问题，因为如果某个目录对特定用户的访问被关闭，`locate`数据库就不应存储该目录及其内容的信息。这个问题将在[第5章](ch05.xhtml#ch05)中通过一个新的、更安全的`locate`脚本来解决，该脚本考虑到了隐私和安全问题（详见[脚本
    #39](ch05.xhtml#ch05lev1sec05)，位于[第127页](ch05.xhtml#page_127)）。不过，目前这个脚本完美模拟了标准Linux、OS
    X及其他发行版中`locate`命令的行为。'
- en: Don’t be surprised if `mklocatedb` takes a few minutes or longer to run; it’s
    traversing the entire filesystem, which can take a while on even a mediumsized
    system. The results can be quite large, too. On one OS X system we tested, the
    *locate.db* file had over 1.5 million entries and ate up 1874.5MB of disk space.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`mklocatedb`运行需要几分钟或更长时间，不必惊讶；它正在遍历整个文件系统，即使是中等大小的系统也可能需要一些时间。结果也可能非常庞大。在我们测试的一台OS
    X系统上，*locate.db*文件有超过150万个条目，占用了1874.5MB的磁盘空间。
- en: Once the database is built, the `locate` script itself is a breeze to write;
    it’s just a call to the `grep` command with whatever arguments are specified by
    the user.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据库构建完成，`locate`脚本本身就非常简单；它只是调用`grep`命令，带上用户指定的任何参数。
- en: '***Running the Script***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: To run the `locate` script, it’s first necessary to run `mklocatedb`. Once that’s
    done, `locate` invocations will almost instantly find all matching files on the
    system for any pattern specified.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行`locate`脚本，首先需要运行`mklocatedb`。完成之后，`locate`调用几乎可以瞬间找到系统中所有符合指定模式的文件。
- en: '***The Results***'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: The `mklocatedb` script has no arguments or output, as [Listing 2-16](ch02.xhtml#ch2ex16)
    shows.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`mklocatedb`脚本没有任何参数或输出，如[列表 2-16](ch02.xhtml#ch2ex16)所示。'
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 2-16: Running the* `*mklocatedb*` *shell script as root with the*
    `*sudo*` *command*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-16：以root身份运行`*mklocatedb*`* shell脚本，并使用`*sudo*`命令*'
- en: 'We can check the size of the database with a quick `ls`, as shown here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过快速的`ls`命令检查数据库的大小，如下所示：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we’re ready to start finding files on the system using `locate`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备开始使用`locate`查找系统中的文件：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This script also lets you ascertain other interesting statistics about your
    system, such as how many C source files you have, like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本还可以让你获得关于系统的其他有趣统计信息，比如你有多少个C源文件，像这样：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**NOTE**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Pay attention to the regular expression here. The* `*grep*` *command requires
    us to escape the dot (*`.`*) or it will match any single character. Also, the*
    `*$*` *denotes the end of the line or, in this case, the end of the filename.*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意这里的正则表达式。* `*grep*` *命令要求我们转义点号（*`.`*），否则它会匹配任何单一字符。另外，* `*$*` *表示行尾，或者在这个情况下，表示文件名的结束。*'
- en: With a bit more work, we could feed each one of these C source files to the
    `wc` command and ascertain the total number of lines of C code on the system,
    but, um, that would be kinda daft, wouldn’t it?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 再做一点小调整，我们可以将每个 C 源文件都传递给 `wc` 命令，从而计算系统中 C 代码的总行数，但，嗯，这样做是不是有点傻呢？
- en: '***Hacking the Script***'
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***修改脚本***'
- en: To keep the database reasonably up-to-date, it would be easy to schedule `mklocatedb`
    to run from `cron` in the wee hours of the night on a weekly basis— as most systems
    with built-in `locate` commands do—or even more frequently based on local usage
    patterns. As with any script executed by the root user, take care to ensure that
    the script itself isn’t editable by non-root users.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持数据库的合理更新，调度 `mklocatedb` 每周在深夜通过 `cron` 运行就非常简单——正如大多数内置 `locate` 命令的系统所做的那样——甚至可以根据本地的使用模式更频繁地运行。和任何由
    root 用户执行的脚本一样，要确保该脚本本身不能被非 root 用户修改。
- en: 'One potential improvement to this script would be to have `locate` check its
    invocation and fail with a meaningful error message if no pattern is specified
    or if the *locate.db* file doesn’t exist. As it’s written now, the script will
    spit out a standard `grep` error instead, which isn’t very useful. More importantly,
    as we discussed earlier, there’s a significant security issue with letting users
    have access to a listing of all filenames on the system, including those they
    wouldn’t ordinarily be able to see. A security improvement to this script is addressed
    in [Script #39](ch05.xhtml#ch05lev1sec05) on [page 127](ch05.xhtml#page_127).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '这个脚本的一个潜在改进是让 `locate` 检查其调用，如果没有指定模式或 *locate.db* 文件不存在，则失败并显示有意义的错误信息。现在按目前的写法，脚本只会输出一个标准的
    `grep` 错误，这并没有多大用处。更重要的是，正如我们之前讨论过的，允许用户访问系统中所有文件名的列表，包括那些他们通常无法看到的文件，是一个重大的安全问题。对这个脚本的安全性改进可以参见
    [脚本 #39](ch05.xhtml#ch05lev1sec05) 和 [第 127 页](ch05.xhtml#page_127)。'
- en: '**#20 Emulating Other Environments: MS-DOS**'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#20 模拟其他环境：MS-DOS**'
- en: 'Though it’s unlikely you’ll ever need them, it’s interesting and illustrative
    of some scripting concepts to create versions of classic MS-DOS commands, like
    `DIR`, as Unix-compatible shell scripts. Sure, we could just use a shell alias
    to map `DIR` to the Unix `ls` command, as in this example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能永远不需要它们，但创建像 `DIR` 这样的经典 MS-DOS 命令的版本作为 Unix 兼容的 shell 脚本，这既有趣又能说明一些脚本编程概念。确实，我们可以仅仅使用
    shell 别名将 `DIR` 映射到 Unix 的 `ls` 命令，像这个例子中那样：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: But this mapping doesn’t emulate the actual behavior of the command; it just
    helps forgetful people learn new command names. If you’re hip to the ancient ways
    of computing, you’ll remember that the `/W` option produces a wide listing format,
    for example. But if you specify `/W` to the `ls` command now, the program will
    just complain that the `/W` directory doesn’t exist. Instead, the following `DIR`
    script in [Listing 2-17](ch02.xhtml#ch2ex17) can be written so that it works with
    the forward-slash style of command flags.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种映射并不能模拟命令的实际行为；它仅仅帮助健忘的人记住新的命令名称。如果你熟悉古老的计算机方式，你会记得 `/W` 选项会产生宽格式的列出。例如，但如果你现在将
    `/W` 传递给 `ls` 命令，程序会抱怨说 `/W` 目录不存在。相反，以下在 [清单 2-17](ch02.xhtml#ch2ex17) 中的 `DIR`
    脚本可以写成使其适应斜杠风格的命令标志。
- en: '***The Code***'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 2-17: The* `*DIR*` *shell script for emulating the* `*DIR*` *DOS command
    on Unix*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-17：* `*DIR*` *Shell 脚本，用于在 Unix 上模拟* `*DIR*` *DOS 命令*'
- en: '***How It Works***'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原理说明***'
- en: This script highlights the fact that shell `case` statement conditional tests
    are actually regular expression tests. You can see at ➊ that the DOS flags `/N`,
    `/Q`, and `/W` all map to the same `-l Unix` flag in the final invocation of the
    `ls` command and that all this is done in a simple regular expression `/[NQW]`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本突出了 shell `case` 语句中的条件测试实际上是正则表达式测试这一事实。你可以看到在 ➊ 位置，DOS 标志 `/N`、`/Q` 和
    `/W` 都映射到最终调用 `ls` 命令时的同一个 `-l Unix` 标志，而所有这一切都通过一个简单的正则表达式 `/[NQW]` 实现。
- en: '***Running the Script***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: Name this script `DIR` (and consider creating a system-wide shell alias of `dir=DIR`
    since DOS was case insensitive but Unix is most assuredly case sensitive). This
    way, whenever users type `DIR` at the command line with typical MS-DOS `DIR` flags,
    they’ll get meaningful and useful output (shown in [Listing 2-18](ch02.xhtml#ch2ex18))
    rather than a `command not found` error message.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本命名为`DIR`（并考虑创建一个系统范围的 shell 别名`dir=DIR`，因为 DOS 不区分大小写，而 Unix 确实区分大小写）。这样，每当用户在命令行输入带有典型
    MS-DOS `DIR` 标志的 `DIR` 时，他们将得到有意义且有用的输出（如[清单 2-18](ch02.xhtml#ch2ex18)所示），而不是一个`command
    not found`的错误信息。
- en: '***The Results***'
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 2-18: Testing the* `*DIR*` *shell script to list files*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-18：测试`*DIR*` *shell 脚本列出文件*'
- en: This listing of the specified directory, sorted from oldest to newest, indicates
    file sizes (though directories always have a size of 0).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该指定目录的列出，按从最旧到最新的顺序排序，显示文件大小（尽管目录的大小始终为0）。
- en: '***Hacking the Script***'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***修改脚本***'
- en: At this point, it might be tough to find someone who remembers the MS-DOS command
    line, but the basic concept is powerful and worth knowing. One improvement you
    could make, for example, would be to have the Unix or Linux equivalent command
    be displayed before being executed and then, after a certain number of system
    invocations, have the script show the translation but not actually invoke the
    command. The user would be forced to learn the new commands just to accomplish
    anything!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个阶段，可能很难找到一个记得 MS-DOS 命令行的人，但基本概念是强大的，值得了解。例如，你可以做的一个改进是，先显示 Unix 或 Linux
    等效的命令，再执行，然后在经过一定次数的系统调用后，脚本显示翻译的命令，但实际上不执行命令。用户将被迫学习新命令，才能完成任何事情！
- en: '**#21 Displaying Time in Different Time Zones**'
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#21 显示不同时间区的时间**'
- en: The most fundamental requirement for a working `date` command is that it displays
    the date and time in your time zone. But what if you have users across multiple
    time zones? Or, more likely, what if you have friends and colleagues in different
    locations, and you’re always confused about what time it is in, say, Casablanca,
    Vatican City, or Sydney?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`date`命令的最基本要求是能够在你的时区内显示日期和时间。但如果你有跨多个时区的用户呢？或者，更可能的是，如果你有分布在不同地点的朋友和同事，而你总是弄不清楚比如卡萨布兰卡、梵蒂冈或悉尼的时间呢？'
- en: 'It turns out that the `date` command on most modern Unix flavors is built atop
    an amazing time zone database. Usually stored in the directory */usr/share/zoneinfo*,
    this database lists over 600 regions and details the appropriate time zone offset
    from UTC (Coordinated Universal Time, also often referred to as *GMT*, or *Greenwich
    Mean Time*) for each. The `date` command pays attention to the `TZ` time zone
    variable, which we can set to any region in the database, like so:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，大多数现代 Unix 系统上的`date`命令是建立在一个令人惊叹的时区数据库之上的。这个数据库通常存储在目录*/usr/share/zoneinfo*中，列出了超过600个地区，并为每个地区详细列出了与
    UTC（协调世界时，通常也称为*格林尼治标准时间*，或*GMT*）的时区偏移。`date`命令会关注`TZ`时区变量，我们可以将其设置为数据库中的任何地区，例如：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: However, most system users aren’t comfortable specifying temporary environment
    variable settings. Using a shell script, we can create a more user-friendly frontend
    to the time zone database.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数系统用户不习惯指定临时的环境变量设置。通过使用一个 shell 脚本，我们可以为时区数据库创建一个更加用户友好的前端。
- en: The bulk of the script in [Listing 2-19](ch02.xhtml#ch2ex19) involves digging
    around in the time zone database (which is typically stored across several files
    in the *zonedir* directory) and trying to find a file that matches a specified
    pattern. Once it finds a matching file, the script grabs the full time zone name
    (as with `TZ="Africa/Casablanca"` in this example) and invokes `date` with that
    as a subshell environment setting. The `date` command checks `TZ` to see what
    time zone it’s in and has no idea if it’s a one-off or the time zone you sit in
    most of the time.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-19](ch02.xhtml#ch2ex19)中的大部分脚本涉及在时区数据库中查找（该数据库通常分布在*zonedir*目录中的多个文件里），并尝试找到一个匹配指定模式的文件。一旦找到匹配的文件，脚本会抓取完整的时区名称（例如此例中的`TZ="Africa/Casablanca"`），并以此作为子shell环境设置调用`date`命令。`date`命令会检查`TZ`来查看当前的时区，并不知道它是一个一次性使用的时区还是你平时所处的时区。'
- en: '***The Code***'
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 2-19: The* `*timein*` *shell script for reporting the time in a certain
    time zone*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-19：`*timein*` *shell 脚本，用于报告特定时区的时间*'
- en: '***How It Works***'
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: This script exploits the ability of the `date` command to show the date and
    time for a specified time zone, regardless of your current environment settings.
    In fact, the entire script is all about identifying a valid time zone name so
    that the `date` command will work when invoked at the very end.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本利用了`date`命令的功能，能够显示指定时区的日期和时间，无论当前的环境设置如何。实际上，整个脚本的核心就是识别一个有效的时区名称，以便在最后调用时，`date`命令能够正常工作。
- en: Most of the complexity of this script comes from trying to anticipate names
    of world regions entered by users that do not match the names of regions in the
    time zone database. The time zone database is laid out with *timezonename* and
    *region/locationname* columns, and the script tries to display useful error messages
    for typical input problems, like a time zone that’s not found because the user
    is specifying a country like *Brazil*, which has more than one time zone.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的复杂性大部分来自于尝试预测用户输入的世界区域名称，这些名称与时区数据库中的区域名称不匹配。时区数据库是以*时区名称*和*区域/地点名称*列的形式排列的，脚本会尝试为典型的输入问题显示有用的错误消息，比如由于用户指定了像*巴西*这样的国家，而巴西有多个时区，导致找不到时区。
- en: For example, although `TZ="Casablanca" date` would fail to find a matching region
    and display the UTC/GMT time instead, the city Casablanca does exist in the time
    zone database. The issue is that you have to use its proper region name of *Africa/Casablanca*
    in order for it to work, as was shown in the introduction to this script.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，尽管`TZ="Casablanca" date`会因为找不到匹配的区域而显示UTC/GMT时间，卡萨布兰卡城市确实存在于时区数据库中。问题在于，你必须使用其正确的区域名称*Africa/Casablanca*，才能使其正常工作，正如本脚本介绍中所展示的那样。
- en: This script, on the other hand, can find Casablanca in the Africa directory
    on its own and identify the zone accurately. However, just specifying *Africa*
    wouldn’t be specific enough, as the script knows there are subregions within Africa,
    so it produces an error message indicating that the information is insufficient
    to uniquely identify a specific time zone ➋. You can also just use `list` to list
    all time zones ➊ or an actual time zone name ➌ (for example, UTC or WET), which
    can be used as an argument to this script.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这个脚本可以自行在非洲目录中找到卡萨布兰卡，并准确地识别该时区。然而，仅仅指定*非洲*是不够具体的，因为脚本知道非洲内有多个子区域，所以它会生成一条错误信息，表示信息不足以唯一地标识一个特定的时区➋。你还可以使用`list`列出所有时区➊，或者使用一个实际的时区名称➌（例如，UTC或WET），作为该脚本的参数。
- en: '**NOTE**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*An excellent reference to the time zone database can be found online at* [http://www.twinsun.com/tz/tz-link.htm](http://www.twinsun.com/tz/tz-link.htm).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*时区数据库的一个优秀参考可以在线查找，网址为* [http://www.twinsun.com/tz/tz-link.htm](http://www.twinsun.com/tz/tz-link.htm)。'
- en: '***Running the Script***'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: To check the time in a region or city, specify the region or city name as an
    argument to the `timein` command. If you know both the region and the city, you
    can also specify them as `*region*/*city*` (for example, `Pacific/Honolulu`).
    Without any arguments, `timein` shows UTC/GMT. [Listing 2-20](ch02.xhtml#ch2ex20)
    shows the `timein` script running with a variety of time zones.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看某个区域或城市的时间，可以将区域或城市名称作为参数传递给`timein`命令。如果你知道区域和城市的名称，也可以将它们指定为`*区域*/*城市*`（例如，`Pacific/Honolulu`）。如果没有任何参数，`timein`会显示UTC/GMT。[清单
    2-20](ch02.xhtml#ch2ex20)展示了`timein`脚本在多种时区下的运行情况。
- en: '***The Results***'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 2-20: Testing the* `*timein*` *shell script with various time zones*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-20：使用不同的时区测试* `*timein*` *脚本*'
- en: '***Hacking the Script***'
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: Knowing the time in a specific time zone across the world is a great ability,
    especially for a systems admin who manages global networks. But sometimes, you
    really just want to know the *difference* in time between two time zones quickly.
    The `timein` script could be hacked to provide just this functionality. By creating
    a new script, perhaps called `tzdiff`, based on the `timein` script, you could
    accept two arguments instead of one.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 知道全球特定时区的时间是一项非常有用的技能，尤其是对于管理全球网络的系统管理员来说。但有时，你其实只是想快速了解两个时区之间的*时间差*。`timein`脚本可以被修改来实现这个功能。通过基于`timein`脚本创建一个新的脚本，可能叫做`tzdiff`，你可以接受两个参数，而不是一个。
- en: Using both of the arguments, you could determine the current time in both time
    zones and then print the hour difference between the two. Keep in mind, though,
    that a two-hour difference between two time zones could be two hours *forward*
    or two hours *backward*, and this makes a big difference. Distinguishing between
    a two-hour difference going forward or backward is crucial in making this hack
    a useful script.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个参数，你可以确定两个时区的当前时间，然后打印出它们之间的小时差异。然而，请记住，两个时区之间的两小时差异可能是向*前*的两小时，或者是向*后*的两小时，这之间的差异非常重要。区分两小时差异是向前还是向后，对于让这个小技巧成为一个有用的脚本至关重要。
