- en: '**11**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11**'
- en: '**EVENT-DRIVEN PROGRAMMING**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件驱动编程**'
- en: '![image](graphics/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common01.jpg)'
- en: So far, the programs you’ve written have been mostly *sequential* because they
    have followed the lines of code in order, from top to bottom. Some statements
    might have made a comparison or called a subroutine to take a detour, but overall
    the order of statements has been mostly linear.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你写的程序大多是 *顺序执行* 的，因为它们是按照代码行的顺序，从上到下执行的。某些语句可能会进行比较或调用子程序以绕行，但总体来说，语句的顺序大多是线性的。
- en: 'In some ways, this is comparable to how you go about your daily routine: you
    wake up, make your bed, take a shower, eat your breakfast, watch TV, comb your
    hair, and so on. But what if the phone rings during your routine? If you’re expecting
    a call from a friend to confirm that night’s party, you’d better take it! Even
    though you’re doing something at that moment, you’re also listening for the phone.
    The minute you hear the ring (the event), you drop everything and take the call
    (let’s just hope it isn’t your aunt calling to see if you finished reading *Little
    House on the Freeway*).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，这类似于你日常的生活方式：你起床、整理床铺、洗澡、吃早餐、看电视、梳头发，依此类推。但如果在这个过程中电话响了呢？如果你在等朋友打电话确认今晚的聚会，你最好接一下！即使你此时正在做某件事，你也会注意听电话。一旦你听到铃声（事件），你会放下手头的一切去接电话（希望不是你阿姨打来问你是否已经读完《高速公路上的小屋》）。
- en: Similarly, many computer programs (especially games) use *event-driven programming*,
    which means they listen and respond to events raised by the operating system (see
    [Figure 11-1](ch11.html#ch11fig1)). Think of an *event* as a signal that’s raised
    in response to an action, like moving or clicking the mouse, clicking a button,
    typing on the keyboard, having a timer expire, and so on. Some objects in the
    Small Basic library can see these events and tell you when they happen. Programmers
    say that an object *raised* an event. You can write some exciting applications
    and games by handling these events (like a super fun explosion farming game).
    These games typically wait patiently for the player to move the mouse or press
    some keys, and then they take action.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，许多计算机程序（特别是游戏）使用 *事件驱动编程*，这意味着它们会监听并响应操作系统触发的事件（见[图 11-1](ch11.html#ch11fig1)）。可以把
    *事件* 看作是对某个动作做出反应的信号，例如移动或点击鼠标、点击按钮、敲击键盘、计时器到期等。Small Basic 库中的一些对象可以看到这些事件并告诉你它们何时发生。程序员称某个对象
    *触发* 了一个事件。你可以通过处理这些事件来编写一些有趣的应用程序和游戏（比如一个超级有趣的爆炸农场游戏）。这些游戏通常会耐心等待玩家移动鼠标或按下某些键，然后执行相应的动作。
- en: '![image](graphics/f11-01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f11-01.jpg)'
- en: '*Figure 11-1: The event-driven programming model*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-1：基于事件的编程模型*'
- en: In [Figure 11-1](ch11.html#ch11fig1), the events are at the top. When a user
    triggers an action (like pressing a key), the Small Basic library knows about
    it. If you want to know when an event happens, you can ask Small Basic to inform
    you when an event occurs so you can write programs that react to certain events.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 11-1](ch11.html#ch11fig1)中，事件位于顶部。当用户触发某个动作（如按键）时，Small Basic 库就会知道。如果你想知道某个事件发生的时刻，可以让
    Small Basic 在事件发生时通知你，这样你就可以编写响应某些事件的程序。
- en: 'The Small Basic library has three objects that handle events (see [Figure 11-2](ch11.html#ch11fig2)):
    `GraphicsWindow`, `Timer`, and `Controls`. You’ll study the events of `GraphicsWindow`
    and `Timer` objects in this chapter, and you’ll tackle the events of the `Controls`
    object in the next chapter.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Small Basic 库有三个处理事件的对象（见[图 11-2](ch11.html#ch11fig2)）：`GraphicsWindow`、`Timer`
    和 `Controls`。本章将研究 `GraphicsWindow` 和 `Timer` 对象的事件，而 `Controls` 对象的事件将在下一章讨论。
- en: '![image](graphics/f11-02.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f11-02.jpg)'
- en: '*Figure 11-2: The available events in Small Basic*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-2：Small Basic 中可用的事件*'
- en: '**GraphicsWindow Events**'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**GraphicsWindow 事件**'
- en: Let’s start by exploring the events in `GraphicsWindow`. When a user interacts
    with your application, `GraphicsWindow` knows when keys are pressed, which keys
    are pressed, and if the user clicks or moves the mouse. Although `GraphicsWindow`
    knows about these events, it doesn’t automatically do anything when the events
    happen. You need to instruct `GraphicsWindow` to tell you when these events happen
    so you can use them. Next, you’ll learn how to use the information Small Basic
    knows about the user to create interesting, interactive applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来探索`GraphicsWindow`中的事件。当用户与应用程序互动时，`GraphicsWindow`知道何时按下键、按下了哪些键，以及用户是否点击或移动鼠标。尽管`GraphicsWindow`知道这些事件的发生情况，但它并不会在事件发生时自动做任何事情。你需要指示`GraphicsWindow`在这些事件发生时通知你，这样你就可以使用它们。接下来，你将学习如何利用Small
    Basic关于用户的信息来创建有趣的互动应用。
- en: '***Create Patterns with the MouseDown Event***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过MouseDown事件创建图案***'
- en: Let’s make a simple application that draws a randomly colored circle every time
    the user clicks the graphics window. Enter the code in [Listing 11-1](ch11.html#ch11ex1).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们制作一个简单的应用程序，每次用户点击图形窗口时，都画一个随机颜色的圆。输入[清单11-1](ch11.html#ch11ex1)中的代码。
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 11-1: Drawing circles with a click of the mouse*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单11-1：点击鼠标画圆*'
- en: Run the program. A sample output is shown in [Figure 11-3](ch11.html#ch11fig3).
    When you click inside the graphics window, you draw a circle with a random color.
    Make a fun pattern, show it to someone else, and try to convince them that Pablo
    Picasso painted it!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序。一个示例输出显示在[图11-3](ch11.html#ch11fig3)中。当你点击图形窗口内时，会画出一个随机颜色的圆形。制作一个有趣的图案，展示给别人，并试图说服他们这幅画是巴勃罗·毕加索画的！
- en: '![image](graphics/f11-03.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/f11-03.jpg)'
- en: '*Figure 11-3: Sample output of* Circles.sb'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-3：Circles.sb的示例输出*'
- en: 'Let’s look at the code in [Listing 11-1](ch11.html#ch11ex1) to see how Small
    Basic handles event-driven programming. [Figure 11-4](ch11.html#ch11fig4) shows
    an important line in this program: line 2.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看[清单11-1](ch11.html#ch11ex1)中的代码，了解Small Basic是如何处理事件驱动编程的。[图11-4](ch11.html#ch11fig4)显示了该程序中的一行重要代码：第2行。
- en: '![image](graphics/f11-04.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/f11-04.jpg)'
- en: '*Figure 11-4: The event-handler registration statement*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-4：事件处理器注册语句*'
- en: The statement in line 2 tells the `GraphicsWindow` object that when the `MouseDown`
    event happens, it should run the `OnMouseDown()` subroutine. This subroutine is
    also known as an *event handler*, because its purpose is to handle, or process,
    an event. Although you can name this subroutine anything you want, it’s common
    to use the format `OnEventName`, which is why we named the handler `OnMouseDown`.
    The statement on line 2 is known as *registering* an event handler. In this example,
    Small Basic calls the `OnMouseDown()` subroutine every time the user clicks inside
    the graphics window.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第2行的语句告诉`GraphicsWindow`对象，当发生`MouseDown`事件时，应该运行`OnMouseDown()`子程序。这个子程序也被称为*事件处理器*，因为它的目的是处理或处理一个事件。虽然你可以为这个子程序命名任何你想要的名称，但通常使用`OnEventName`的格式，这就是我们将处理器命名为`OnMouseDown`的原因。第2行的语句被称为*注册*事件处理器。在这个例子中，每次用户点击图形窗口时，Small
    Basic都会调用`OnMouseDown()`子程序。
- en: When the user clicks inside the graphics window, the x and y mouse positions
    (relative to the window’s upper-left corner) are saved in the `MouseX` and `MouseY`
    properties of `GraphicsWindow`. Because the program draws a circle with a diameter
    of 20 centered around the mouse click, it subtracts 10 from `MouseX` and `MouseY`
    (to mark the circle’s upper-left position) and saves the result in the `X0` and
    `Y0` variables (lines 6–7). The subroutine then draws a circle with a diameter
    of 20 that’s centered at the mouse-click position (line 8).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击图形窗口时，鼠标的x和y位置（相对于窗口的左上角）会保存在`GraphicsWindow`的`MouseX`和`MouseY`属性中。由于程序画一个直径为20的圆，并以鼠标点击位置为圆心，它从`MouseX`和`MouseY`中减去10（以标记圆的左上角位置），然后将结果保存在`X0`和`Y0`变量中（第6–7行）。然后，子程序会画一个以鼠标点击位置为圆心、直径为20的圆（第8行）。
- en: '**TRY IT OUT 11-1**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**试试 11-1**'
- en: Change the code in [Listing 11-1](ch11.html#ch11ex1) to draw triangles and squares
    instead of a circle. If you need help, refer back to [Chapter 3](ch03.html#ch03)
    to review `GraphicsWindow`’s drawing methods.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 修改[清单11-1](ch11.html#ch11ex1)中的代码，改为画三角形和正方形，而不是圆形。如果你需要帮助，可以参考[第3章](ch03.html#ch03)回顾`GraphicsWindow`的绘图方法。
- en: '***Fire Missiles with the KeyDown Event***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过KeyDown事件发射导弹***'
- en: Many computer games are played using the keyboard. For example, the player might
    use the arrow keys to move the main character, the spacebar to shoot a missile,
    F1 to get help, P to pick the character’s nose, and ESC to exit the game. If you
    want to make a game that uses the keyboard for input, you need to add the `KeyDown`
    event to your program to let you know which key the user presses and when.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 许多电脑游戏使用键盘进行操作。例如，玩家可能使用方向键来移动主角，空格键来发射导弹，F1键来获取帮助，P键来捏角色的鼻子，以及ESC键来退出游戏。如果你想制作一个使用键盘输入的游戏，你需要在程序中添加`KeyDown`事件，这样你就可以知道用户按下了哪个键以及何时按下。
- en: To understand the `KeyDown` event, let’s write a simple application that displays
    the name of each key a user presses. Enter the program in [Listing 11-2](ch11.html#ch11ex2).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解`KeyDown`事件，让我们编写一个简单的应用程序，显示用户按下的每个键的名称。在[列表11-2](ch11.html#ch11ex2)中输入程序。
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 11-2: Displaying each key a user presses*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表11-2：显示用户按下的每个键*'
- en: A sample run, with some comments, is shown in [Figure 11-5](ch11.html#ch11fig5).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带有一些注释的示例运行结果见于[图11-5](ch11.html#ch11fig5)。
- en: '![image](graphics/f11-05.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f11-05.jpg)'
- en: '*Figure 11-5: A sample run of* KeyDown.sb'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-5：KeyDown.sb的示例运行结果*'
- en: The `yPos` variable sets the vertical position where you’ll display the name
    of the key the user presses. It starts at 10 and increases by 15 after it shows
    the name of the last pressed key (line 7).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`yPos`变量设置了显示用户按下的键名的垂直位置。它从10开始，在显示完上一个按下的键名后（第7行），会增加15。'
- en: You register the `KeyDown` event handler on line 3\. Whenever a user presses
    a key, the program runs the `OnKeyDown()` subroutine. The subroutine displays
    the name of the pressed key (line 6) and increases `yPos` by 15 (line 7) to get
    ready to display the name of the next key on the next line. The `GraphicsWindow.LastKey`
    property on line 6 provides the name of the pressed key (as a string). This read-only
    property tells you the last key a user pressed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第3行注册了`KeyDown`事件处理程序。每当用户按下一个键时，程序都会运行`OnKeyDown()`子程序。该子程序会显示按下的键的名称（第6行），并将`yPos`增加15（第7行），以准备在下一行显示下一个键的名称。第6行的`GraphicsWindow.LastKey`属性提供了按下键的名称（作为字符串）。这个只读属性告诉你用户最后按下的是哪个键。
- en: 'The importance of this example is that it shows you the names that Small Basic
    assigns to the different keyboard keys. If you want to create an application that
    responds to these keys, you need to know what Small Basic calls them. Here are
    some other details you should know:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的重要性在于，它展示了Small Basic为不同的键盘键分配的名称。如果你想创建一个响应这些键的应用程序，你需要知道Small Basic是如何命名它们的。以下是你应该了解的其他一些细节：
- en: The names of the letter keys (A–Z) are always uppercase. For example, if you
    type the letter `"a"`, `LastKey` will register it as an uppercase `"A"` regardless
    of whether caps lock is on or if you’re holding down the SHIFT key.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字母键（A–Z）的名称始终是大写的。例如，即使你输入字母`"a"`，`LastKey`也会将其注册为大写的`"A"`，无论是否打开大写锁定键或按下了SHIFT键。
- en: The name of a number key (0–9) uses the form `"Ddigit`". For example, the name
    of the 5 key is `"D5"`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数字键（0-9）的名称采用`"Ddigit"`的形式。例如，数字5键的名称是`"D5"`。
- en: The four arrow keys are named `"Up"`, `"Down"`, `"Right"`, and `"Left"`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 四个方向键分别命名为`"Up"`、`"Down"`、`"Right"`和`"Left"`。
- en: The ENTER (or RETURN) key is named `"Return"`, and the spacebar is named `"Space"`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回车（或返回）键的名称是`"Return"`，而空格键的名称是`"Space"`。
- en: The `KeyDown` event is raised continuously (about every 35 milliseconds) as
    long as a key is pressed. This is different from the `MouseDown` event, which
    is raised only once (when the left mouse button is clicked).
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只要按下一个键，`KeyDown`事件会不断触发（大约每35毫秒一次）。这与`MouseDown`事件不同，后者仅在点击左键时触发一次。
- en: Knowing the names of the keys is important if you want to test for certain keypresses
    in your programs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在程序中测试某些键的按下，了解键名是很重要的。
- en: '**TRY IT OUT 11-2**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试一下 11-2**'
- en: Enter and run the following code. Press some keys on the keyboard and watch
    for their names in the text window. Press and hold a key for a while to see what
    happens. (Make sure the graphics window is the active window when you type.)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输入并运行以下代码。按下键盘上的一些键，并观察它们在文本窗口中的名称。按住一个键一段时间，看看会发生什么。（确保在你输入时，图形窗口是活动窗口。）
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What did you notice when you tried this example?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试这个示例时，你注意到了什么？
- en: '***Make a Typewriter Using the TextInput Event***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用TextInput事件制作打字机***'
- en: The `TextInput` event is very similar to the `KeyDown` event, but it’s raised
    only when the user presses a text-related key on the keyboard. This includes letters
    (A–Z), digits (0–9), special characters (such as !@#$%^&), and other keys, like
    ENTER, the spacebar, TAB, and BACKSPACE. When the `TextInput` event is raised,
    the last character pressed on the keyboard is saved in the `GraphicsWindow.LastText`
    property.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextInput` 事件与 `KeyDown` 事件非常相似，但它仅在用户按下与文本相关的键时触发。这包括字母（A–Z）、数字（0–9）、特殊字符（如
    !@#$%^&）以及其他键，如 ENTER、空格键、TAB 和 BACKSPACE。当 `TextInput` 事件被触发时，键盘上最后按下的字符会保存在
    `GraphicsWindow.LastText` 属性中。'
- en: Let’s see how this event works. Enter the code in [Listing 11-3](ch11.html#ch11ex3)
    to simulate a typewriter. We know that typewriters are old school, but hey, it
    could be worse; we could be simulating an abacus!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个事件是如何工作的。输入代码 [Listing 11-3](ch11.html#ch11ex3) 来模拟打字机。我们知道打字机是旧式的，但嘿，情况还不算最糟；我们本可以在模拟算盘！
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 11-3: Making a typewriter sound with each keypress*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-3：每次按键时发出打字机声音*'
- en: Look at the sample output in [Figure 11-6](ch11.html#ch11fig6).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [Figure 11-6](ch11.html#ch11fig6) 中的示例输出。
- en: '![image](graphics/f11-06.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f11-06.jpg)'
- en: '*Figure 11-6: Sample output of* Typewriter.sb'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-6：打字机的示例输出*'
- en: Lines 2 and 3 set the cursor at the corner of the graphics window. Line 4 gives
    the window a title, line 5 sets the font style, and line 6 registers the event
    handler. Line 9 plays the click sound, and lines 10–12 advance the line if the
    user presses ENTER. Line 14 writes the character entered by the user, line 15
    moves the cursor to the next spot, and lines 16–18 move the cursor to the next
    line when the cursor gets to the right edge.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第 2 和第 3 行将光标设置在图形窗口的角落。第 4 行为窗口设置标题，第 5 行设置字体样式，第 6 行注册事件处理程序。第 9 行播放点击声音，第
    10 到第 12 行在用户按下 ENTER 时前进一行。第 14 行写入用户输入的字符，第 15 行将光标移动到下一个位置，第 16 到第 18 行当光标到达右边缘时，将光标移动到下一行。
- en: '**NOTE**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When you experiment with this application, you’ll notice that the* `TextInput`
    *event looks at the states of the different keyboard keys before setting the value
    of the* `LastText` *property. For example, if you press the A key while holding
    down* SHIFT, *the* `LastText` *property reports an uppercase* `"A"`*; if you don’t
    hold down* SHIFT, *it reports a lowercase* `"a"`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你在此应用程序中进行实验时，你会注意到 `TextInput` 事件会在设置 `LastText` 属性的值之前，检查不同键的状态。例如，如果你在按住
    SHIFT 键的同时按下 A 键，`LastText` 属性会报告大写字母 `"A"`；如果不按住 SHIFT 键，它则报告小写字母 `"a"`。*'
- en: '**TRY IT OUT 11-3**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**试一试 11-3**'
- en: Update [Listing 11-3](ch11.html#ch11ex3) to display each character in a random
    color. See [Listing 11-1](ch11.html#ch11ex1) for ideas on how to randomly change
    the color.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 [Listing 11-3](ch11.html#ch11ex3)，使每个字符显示为随机颜色。查看 [Listing 11-1](ch11.html#ch11ex1)，获取如何随机更改颜色的灵感。
- en: '***Draw Pictures with the MouseMove Event***'
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 MouseMove 事件绘制图片***'
- en: To understand how to use the `MouseMove` event, you’ll write an application
    that lets a user draw with the mouse. The user clicks the left mouse button in
    the graphics window and then drags the mouse to draw. The complete program is
    shown in [Listing 11-4](ch11.html#ch11ex4).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解如何使用 `MouseMove` 事件，你将编写一个应用程序，允许用户通过鼠标绘画。用户在图形窗口中点击左键，然后拖动鼠标进行绘画。完整程序见
    [Listing 11-4](ch11.html#ch11ex4)。
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 11-4: Drawing a line as the user moves the mouse*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-4：用户移动鼠标时绘制线条*'
- en: A sample output of *Scribble.sb* is in [Figure 11-7](ch11.html#ch11fig7).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*Scribble.sb 的示例输出见 [Figure 11-7](ch11.html#ch11fig7)。*'
- en: '![image](graphics/f11-07.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f11-07.jpg)'
- en: '*Figure 11-7: Sample output of* Scribble.sb'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-7：Scribble.sb 的示例输出*'
- en: The `OnMouseMove()` subroutine draws a line from the last mouse position, which
    you save in the variables `prevX` and `prevY` in lines 12 and 13, to the new mouse
    position, which you get from `GraphicsWindow`’s `MouseX` and `MouseY` properties.
    Because you want the user to draw only when the left mouse button is down, the
    `OnMouseMove()` subroutine checks the state of the left mouse button using the
    `Mouse.IsLeftButtonDown` property (line 8). This property indicates whether the
    left mouse button is being held down. If this value is true, the subroutine draws
    a line segment (line 9); if the value isn’t true, it doesn’t draw the line.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnMouseMove()`子程序绘制一条从上次鼠标位置（你在第12行和第13行的`prevX`和`prevY`变量中保存的位置）到当前鼠标位置（你通过`GraphicsWindow`的`MouseX`和`MouseY`属性获取的当前位置）的线段。因为你希望用户仅在按下左键时绘制，所以`OnMouseMove()`子程序通过`Mouse.IsLeftButtonDown`属性（第8行）检查左键的状态。这个属性表示左键是否被按下。如果该值为真，子程序会绘制一条线段（第9行）；如果值不为真，则不会绘制线条。'
- en: '**TRY IT OUT 11-4**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**试试看 11-4**'
- en: Change [Listing 11-4](ch11.html#ch11ex4) to use the `TextInput` event to set
    the pen’s color (R for red, G for green, B for black, and so on).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 更改[清单 11-4](ch11.html#ch11ex4)，使用`TextInput`事件来设置画笔的颜色（R代表红色，G代表绿色，B代表黑色，等等）。
- en: '**Useful Tips**'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实用提示**'
- en: 'Before moving on, we’ll give you some tips for dealing with events and event
    handlers. You can handle multiple events using the same subroutine. For example,
    look at these statements:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们将给你一些处理事件和事件处理程序的提示。你可以使用相同的子程序处理多个事件。例如，看看这些语句：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These statements cause the `MouseDown` and `MouseMove` events to call the `OnMouseEvent()`
    subroutine. This feature can come in handy for complex games that use many events,
    so keep this feature in mind.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语句使得`MouseDown`和`MouseMove`事件调用`OnMouseEvent()`子程序。这个功能对于使用许多事件的复杂游戏非常有用，所以请记住这一点。
- en: 'You can change the event-handler subroutine after you register it. For example,
    let’s say you registered the `OnMouseDown()` subroutine to handle the `MouseDown`
    event using this statement:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在注册事件处理程序子程序后修改它。例如，假设你使用以下语句注册了`OnMouseDown()`子程序来处理`MouseDown`事件：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you later decide to stop responding to the `MouseDown` event (for example,
    because the game is over), you can write this statement:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你后来决定停止响应`MouseDown`事件（例如，游戏结束时），你可以写出以下语句：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now `DoNothing` is the new handler for the `MouseDown` event. If you don’t write
    any statements in your `DoNothing()` subroutine, your programs won’t do anything
    in response to the `MouseDown` event.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`DoNothing`是新的`MouseDown`事件处理程序。如果你在`DoNothing()`子程序中不写任何语句，程序将不会对`MouseDown`事件做出任何响应。
- en: A `MouseDown` event is usually followed by a `MouseUp` event, but don’t always
    count on that `MouseUp` event happening. If you click the left mouse button in
    the graphics window and then move the cursor outside the graphics window before
    you release the button, your application receives only a `MouseDown` event notification.
    This is important to remember if you write an application that needs to pair the
    two events (such as if you click to grab a ball and release to throw it).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`MouseDown`事件通常会后跟一个`MouseUp`事件，但不要总是依赖`MouseUp`事件的发生。如果你在图形窗口内点击左键，然后在松开按钮之前将光标移到图形窗口外部，你的应用程序只会收到一个`MouseDown`事件通知。如果你编写的应用程序需要将这两个事件配对（例如，点击抓住一个球，松开来扔它），记住这一点非常重要。'
- en: In the next section, you’ll put into practice what you’ve learned so far by
    creating a complete game. You’ll also learn about the `Timer` object and its `Tick`
    event. Get ready for an exciting adventure in computer gaming!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，你将通过创建一个完整的游戏来实践到目前为止所学的内容。你还将了解`Timer`对象及其`Tick`事件。准备好迎接一场激动人心的计算机游戏冒险吧！
- en: '**Create a Gold Rush Game**'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建一个金币狂潮游戏**'
- en: Let’s create a simple game in which a player uses the arrow keys to move a turtle
    to collect as many bags of gold as possible (see [Figure 11-8](ch11.html#ch11fig8)).
    The bag of gold appears at random locations on the grid. If the player doesn’t
    grab the bag in 2 seconds, it moves elsewhere. Let’s see how fast you can get
    the turtle to move!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的游戏，玩家使用方向键控制乌龟移动，尽可能多地收集金币袋（见[图11-8](ch11.html#ch11fig8)）。金币袋会随机出现在网格上的某个位置。如果玩家在2秒内没有抓到金币袋，它会移动到其他地方。看看你能多快让乌龟移动吧！
- en: '![image](graphics/f11-08.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f11-08.jpg)'
- en: '*Figure 11-8: Help the turtle grab as many bags of gold as possible.*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-8：帮助乌龟抓取尽可能多的金币袋。*'
- en: '**NOTE**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The grid is part of the background image, but we added the x- and y-coordinates
    in [Figure 11-8](ch11.html#ch11fig8) to help you understand the numbers used in
    the code. Refer to this figure to picture how the turtle and the bag of gold move.*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*网格是背景图像的一部分，但我们在[图 11-8](ch11.html#ch11fig8)中添加了 x 和 y 坐标，帮助你理解代码中使用的数字。请参考此图，想象乌龟和金袋是如何移动的。*'
- en: '***Step 1: Open the Startup File***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 1：打开启动文件***'
- en: Open the file *GoldRush_Incomplete.sb* from this chapter’s folder. The folder
    also has the three images you’ll need for this game. Follow the next four steps
    to walk through the application’s code. The startup file contains the program’s
    main code, as shown in [Listing 11-5](ch11.html#ch11ex5). It prepares the game’s
    user interface, registers the event handlers, and initializes the game’s variables.
    The file also contains empty placeholders (not shown in [Listing 11-5](ch11.html#ch11ex5))
    for all the subroutines you’ll add.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 打开本章文件夹中的 *GoldRush_Incomplete.sb* 文件。该文件夹中还包含了你需要的三张图像。按照接下来的四个步骤逐步了解应用程序的代码。启动文件包含程序的主要代码，如[清单
    11-5](ch11.html#ch11ex5)所示。它准备了游戏的用户界面，注册了事件处理程序，并初始化了游戏的变量。该文件还包含了所有你将添加的子例程的空占位符（未在[清单
    11-5](ch11.html#ch11ex5)中显示）。
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 11-5: Setting up the Gold Rush game*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-5：设置 Gold Rush 游戏*'
- en: Lines 3–5 set the size of the graphics window to match the size of the background
    image (*grid.png*). Lines 8–10 use the `Shapes` object to load the three images
    (the background grid, the turtle, and the bag of gold) and save the returned identifiers.
    You’ll need the identifiers to move the turtle and the bag of gold later. Lines
    13–15 place the turtle near the middle of the grid. Note that each square on the
    grid is 60×60 pixels.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 到 5 行设置图形窗口的大小，以匹配背景图像的大小（*grid.png*）。第 8 到 10 行使用 `Shapes` 对象加载三张图像（背景网格、乌龟和金袋），并保存返回的标识符。你稍后需要这些标识符来移动乌龟和金袋。第
    13 到 15 行将乌龟放置在网格的中间附近。请注意，网格上的每个方格大小为 60×60 像素。
- en: 'Lines 18–22 create the text shape you’ll use to display the player’s score.
    The score is displayed in red on a black background in the upper-left corner of
    the screen (see [Figure 11-8](ch11.html#ch11fig8)). Lines 25–26 register two event
    handlers. The `OnKeyDown` handler checks the arrow keys and then moves the turtle
    as the player controls it. The `OnTick` handler handles the `Timer` object’s `Tick`
    event to limit the player’s time to reach each bag. Line 29 sets the timer interval
    to 2 seconds (2,000 milliseconds), telling the `Timer` object to raise a `Tick`
    event every 2 seconds. Then the code initializes the two variables `score` and
    `bagCount` to 0: `score` keeps track of the player’s score (line 30), and `bagCount`
    keeps track of how many bags have appeared so far (line 31).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第 18 到 22 行创建了你将用于显示玩家得分的文本形状。得分会以红色显示在屏幕左上角的黑色背景上（见[图 11-8](ch11.html#ch11fig8)）。第
    25 到 26 行注册了两个事件处理程序。`OnKeyDown` 处理程序检查箭头键，然后根据玩家的控制移动乌龟。`OnTick` 处理程序处理 `Timer`
    对象的 `Tick` 事件，限制玩家到达每个金袋的时间。第 29 行将计时器间隔设置为 2 秒（2,000 毫秒），告诉 `Timer` 对象每 2 秒触发一次
    `Tick` 事件。然后，代码将两个变量 `score` 和 `bagCount` 初始化为 0：`score` 跟踪玩家的得分（第 30 行），而 `bagCount`
    跟踪到目前为止出现了多少个金袋（第 31 行）。
- en: Run the code; you should see the turtle in the middle of the grid, the bag of
    gold in the upper-left square of the grid, and the score text showing 0.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码，你应该能看到乌龟位于网格的中间，金袋位于网格的左上角，得分文本显示为 0。
- en: '***Step 2: Move the Turtle***'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 2：移动乌龟***'
- en: To move the turtle when the player presses the arrow keys, add the code in [Listing
    11-6](ch11.html#ch11ex6) to the bottom of your file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让乌龟在玩家按下箭头键时移动，将[清单 11-6](ch11.html#ch11ex6)中的代码添加到文件的底部。
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 11-6: Moving the turtle as the player presses the arrow keys*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '***清单 11-6：随着玩家按下箭头键，移动乌龟***'
- en: The grid has eight horizontal and six vertical squares. Squares in the horizontal
    direction are numbered 0 to 7, and squares in the vertical direction are numbered
    0 to 5\. That means the `XP` variable (the player’s x position) takes any value
    between 0 and 7, and the `YP` variable (the player’s y position) takes any value
    between 0 and 5\. The `OnKeyDown()` subroutine uses an `If/ElseIf` ladder to check
    whether the pressed key is one of the four arrow keys. If one of the arrow keys
    is pressed while the turtle is in the graphics window, the subroutine adjusts
    `XP` or `YP` according to the pressed arrow key.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 网格有8个水平方格和6个垂直方格。水平方格编号为0到7，垂直方格编号为0到5。也就是说，`XP`变量（玩家的x坐标）可以取0到7之间的任何值，`YP`变量（玩家的y坐标）可以取0到5之间的任何值。`OnKeyDown()`子例程使用`If/ElseIf`结构检查按下的键是否是四个方向键之一。如果在图形窗口内按下方向键之一，子例程会根据按下的方向键调整`XP`或`YP`。
- en: For example, lines 3 and 4 check if the player pressed the up arrow, and if
    the turtle hasn’t reached the top edge yet, the turtle moves up one square. You
    can find the exact location on the grid (in pixels) by multiplying the square’s
    number by 60 (because each square is 60 pixels), which is what line 12 does. The
    code then calls the `CheckTouch()` subroutine to check if the player touched the
    bag of gold.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，第3行和第4行检查玩家是否按下了向上箭头，如果海龟还没有到达顶部边缘，海龟将上移一个方格。你可以通过将方格编号乘以60（因为每个方格是60像素）来找到网格上的确切位置（以像素为单位），第12行就是这么做的。然后，代码会调用`CheckTouch()`子例程来检查玩家是否碰到了金袋。
- en: Run the application again to check the code you just added. You should be able
    to move the turtle over the square grid using the arrow keys on the keyboard.
    It’s alive!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序，检查你刚刚添加的代码。你应该能够通过键盘上的方向键控制海龟在方格网格上移动。它活了！
- en: '***Step 3: Move the Bag of Gold***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 3：移动金袋***'
- en: Now you’ll add the `OnTick` handler to create a time limit and the code for
    moving the bag of gold to a new spot. Add the subroutine in [Listing 11-7](ch11.html#ch11ex7)
    to the bottom of your program.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将添加`OnTick`处理程序，以创建时间限制，并移动金袋到新位置的代码。将[列表 11-7](ch11.html#ch11ex7)中的子例程添加到程序的底部。
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 11-7: The* `OnTick()` *subroutine*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-7：`OnTick()`子例程*'
- en: As mentioned earlier, the bag of gold appears at a random location and gives
    the player 2 seconds to grab it. If the timer expires, the player loses because
    they didn’t grab the bag in time. In this case, the `OnTick` handler calls the
    `NewRound()` subroutine (line 2) to start another round of the game.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，金袋会出现在一个随机位置，并给玩家2秒钟的时间去抓取它。如果计时器到期，玩家就输了，因为他们没有及时抓住金袋。在这种情况下，`OnTick`处理程序会调用`NewRound()`子例程（第2行），以开始新一轮游戏。
- en: The `NewRound()` subroutine is shown in [Listing 11-8](ch11.html#ch11ex8). Add
    it to the bottom of your program.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewRound()`子例程在[列表 11-8](ch11.html#ch11ex8)中显示。将它添加到程序的底部。'
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 11-8: Starting a new round when the timer expires*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-8：当计时器到期时开始新一轮*'
- en: The `NewRound()` subroutine starts by increasing `bagCount` by 1 (line 2); `bagCount`
    just counts how many bags have appeared so far. The plan is to show a total of
    20 bags to the player. If 20 total bags have not been shown (line 3), the subroutine
    selects a random position for the bag (lines 4–5) and then moves the bag to that
    location in the graphics window (line 6). We use the variables `XG` and `YG` (for
    the x- and y-positions of the bag of gold) in the `CheckTouch()` subroutine. After
    moving the bag, the code calls `CheckTouch()` to see if the bag was placed right
    on top of the player (line 7)—how lucky!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewRound()`子例程首先将`bagCount`增加1（第2行）；`bagCount`仅用于统计目前已出现的金袋数量。计划是向玩家展示总共20个金袋。如果还没有展示20个金袋（第3行），子例程会为金袋选择一个随机位置（第4–5行），然后将金袋移动到图形窗口中的该位置（第6行）。我们在`CheckTouch()`子例程中使用变量`XG`和`YG`（分别代表金袋的x和y坐标）。移动金袋后，代码会调用`CheckTouch()`来检查金袋是否正好放置在玩家上方（第7行）——真幸运！'
- en: If `bagCount` is more than 20 (line 8), we delete the gold bag shape (line 9)
    and register the `OnGameOver` handler, which is a subroutine with no statements,
    for both the `KeyDown` and the `Tick` events to end the game. Then when the player
    presses the arrow keys or when the timer expires after bag 20 has appeared, nothing
    happens. Of course, this might surprise the user. There are other ways to end
    the game, but we’ll leave this to your imagination if you want to change it later.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`bagCount`大于20（第8行），我们会删除金币袋形状（第9行），并为`KeyDown`和`Tick`事件注册`OnGameOver`处理程序，它是一个没有语句的子程序，用来结束游戏。然后，当玩家按下箭头键，或者在第20个金币袋出现后计时器到期时，什么也不会发生。当然，这可能会让用户感到惊讶。还有其他方式来结束游戏，但如果你以后想修改，留给你发挥的空间。
- en: The next subroutine you need to add is the `OnGameOver()` subroutine shown in
    [Listing 11-9](ch11.html#ch11ex9).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要添加的下一个子程序是[示例 11-9](ch11.html#ch11ex9)中显示的`OnGameOver()`子程序。
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 11-9: The* `OnGameOver()` *subroutine*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11-9：* `OnGameOver()` *子程序*'
- en: If you run the game at this point, the bag of gold should move to random positions
    on the grid every 2 seconds. You can still move the turtle with the arrows. After
    20 bags have appeared, the bag of gold disappears, and the arrow keys will no
    longer move the turtle.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时运行游戏，金币袋应该会每2秒钟移动到网格上的随机位置。你仍然可以使用箭头键来移动海龟。出现20个金币袋后，金币袋会消失，箭头键将无法再移动海龟。
- en: As you test this game, you might decide to give the user more time to pick up
    the bags or to remove the lucky feature where a bag could appear right on top
    of the player. Play around with this code until you think your game is fun to
    play.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试这个游戏时，你可能会决定给用户更多时间来捡起金币袋，或者去掉幸运功能，让金币袋不能直接出现在玩家身上。尽情玩弄这个代码，直到你觉得游戏好玩为止。
- en: '***Step 4: Update the User’s Score***'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 4：更新用户得分***'
- en: To complete the game, add the `CheckTouch()` subroutine in [Listing 11-10](ch11.html#ch11ex10)
    to check whether the player successfully picked up a bag of gold and, if so, increase
    their score.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成游戏，在[示例 11-10](ch11.html#ch11ex10)中添加`CheckTouch()`子程序来检查玩家是否成功捡起了金币袋，如果是的话，就增加他们的得分。
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 11-10: Checking whether the turtle gets to the money*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11-10：检查海龟是否捡到钱*'
- en: If the player’s x- and y-positions are the same as the bag, the turtle grabs
    the bag (line 2). Happy turtle! If the lucky turtle gets the bag of gold, we increase
    the score (line 3), show it (line 4), and use the `Sound` object to play a short
    click (line 5) for a nice audio effect.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家的x和y位置与金币袋相同，海龟就会抓到金币袋（第2行）。快乐的海龟！如果幸运的海龟抓到金币袋，我们就增加分数（第3行），并显示出来（第4行），同时使用`Sound`对象播放短促的点击声（第5行），以带来良好的音效。
- en: We also need to reset the timer to 2 seconds for the new round. We do this by
    pausing the timer (line 6) and then resuming it (line 7). Then we call `NewRound()`
    to set another bag in a random spot after this historic triumph. Can your turtle
    do it again?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将计时器重置为2秒，以开始新的一轮。我们通过暂停计时器（第6行）然后再恢复它（第7行）来实现这一点。接着，我们调用`NewRound()`来在这场历史性胜利之后，在随机位置放置另一个金币袋。你的海龟能再来一次吗？
- en: 'This completes the game, and you should be able to enjoy your creation after
    all this hard work. What’s your top score? (Tip: hold down the arrow key to move
    across squares faster.) Share it with your friends (just click Publish in the
    Toolbar) to see if they can beat your score. Have fun!'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了游戏，在经历了这些努力之后，你应该可以享受自己的创作了。你的最高得分是多少？（提示：按住箭头键可以更快地横跨格子。）与朋友们分享（只需点击工具栏中的发布按钮），看看他们能否打破你的得分。玩得开心！
- en: '**TRY IT OUT 11-5**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试一下 11-5**'
- en: 'Think of some ways to enhance the game, and try out your ideas. Here are some
    ideas you could try:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想有哪些方法可以增强这个游戏，尝试一下你的想法。以下是一些你可以尝试的点子：
- en: • End the game with a bigger bang! Display a message or show some interesting
    graphics.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: • 以更盛大的方式结束游戏！显示一条消息或展示一些有趣的图形。
- en: • Add a second bag of gold.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: • 添加第二个金币袋。
- en: • Make the time limit shorter each time the user grabs the bag.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: • 每次用户抓到金币袋后，缩短时间限制。
- en: Head to *[http://tiny.cc/turtlegame/](http://tiny.cc/turtlegame/)* to share
    your turtle game updates.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 前往*[http://tiny.cc/turtlegame/](http://tiny.cc/turtlegame/)*，分享你的海龟游戏更新。
- en: '**Programming Challenges**'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程挑战**'
- en: If you get stuck, check out *[http://nostarch.com/smallbasic/](http://nostarch.com/smallbasic/)*
    for the solutions and for more resources and review questions for teachers and
    students.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到困难，可以访问*[http://nostarch.com/smallbasic/](http://nostarch.com/smallbasic/)*，查看解决方案以及更多的资源和供教师与学生使用的复习题。
- en: He-Man is hanging out with his friends playing *Twilight* trivia and needs a
    buzzer for when his friends get a question wrong. Make a program that draws a
    big X in the graphics window and plays a sound when He-Man clicks the left mouse
    button. The next click should erase the X. Make sure He-Man can repeat this as
    often as he wants (it’s a long trivia game).
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 希曼正在和他的朋友们一起玩 *暮光* 知识竞赛，需要一个按钮来在朋友答错问题时使用。当希曼点击鼠标左键时，编写一个程序在图形窗口中画出一个大大的 X，并播放一个声音。下次点击应删除这个
    X。确保希曼可以随时重复这一操作（毕竟这是一个漫长的知识竞赛游戏）。
- en: 'Make a program that stamps a turtle-face image where the mouse was clicked
    each time the user clicks the mouse. Get *turtleface.jpg* from this chapter’s
    folder. (Hint: start with the code in [Listing 11-1](ch11.html#ch11ex1), and use
    the `GraphicsWindow.DrawImage()` method to draw your image.)'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，每当用户点击鼠标时，在点击的位置印上一个乌龟脸图像。图像文件 *turtleface.jpg* 可以从本章文件夹中找到。（提示：可以从[清单
    11-1](ch11.html#ch11ex1)中的代码开始，并使用 `GraphicsWindow.DrawImage()` 方法绘制图像。）
- en: Open the *Maze_Incomplete.sb* file from this chapter’s folder. The goal is to
    exit the maze in the shortest possible time, but this maze has no exit yet. Figure
    out how to add a maze exit condition. When the player exits the maze, display
    the time it took to solve the maze.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开本章文件夹中的 *Maze_Incomplete.sb* 文件。目标是以尽可能短的时间退出迷宫，但这个迷宫目前没有出口。找出如何添加迷宫出口条件。当玩家退出迷宫时，显示解决迷宫所用的时间。
