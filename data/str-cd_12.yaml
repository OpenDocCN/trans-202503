- en: '9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9'
- en: PIET
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PIET
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common01.jpg)'
- en: 'Piet (pronounced “Pete”) is a visual esolang. It’s a perfect example of what
    an esolang aims to be: a novel way to embody the process of coding. Piet programs
    are executable pictures. The language is named after Dutch artist Piet Mondrian
    (1872–1944) because Piet programs often appear similar to his abstract, rectangular
    paintings. In Piet, art meets code. People talk about elegance in source code,
    and Piet takes this idea to an entirely new level.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Piet（发音为“皮特”）是一种视觉化的异构编程语言（esolang）。它是异构编程语言的完美范例：一种创新的编码方式。Piet程序是可执行的图像。该语言以荷兰艺术家Piet
    Mondrian（1872–1944）的名字命名，因为Piet程序通常看起来像他抽象的矩形画作。在Piet中，艺术与代码相遇。人们谈论源代码的优雅，而Piet将这个概念提升到了一个全新的层次。
- en: 'Piet is a stack-based language with a minimal instruction set. In Piet, blocks
    of the same color represent positive integers, and transitions from one color
    to another specify the executed instruction. Piet programs are 2D, with code running
    whichever way is desired: left, right, up, or down.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Piet是一种基于堆栈的语言，具有最小的指令集。在Piet中，相同颜色的块表示正整数，从一种颜色到另一种颜色的转换指定执行的指令。Piet程序是二维的，代码可以朝任意方向运行：左、右、上或下。
- en: In this chapter, we’ll first walk through the language to understand how to
    turn a picture into code. Next, we’ll go finger painting and get messy with some
    example programs. Along the way, we’ll learn how to use the interpreter and its
    visual tracing abilities.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先将介绍这门语言，了解如何将一幅画转换成代码。接下来，我们将进行手指画创作，弄得一团糟，同时也会使用一些示例程序。过程中，我们将学习如何使用解释器及其可视化跟踪功能。
- en: After that, we’ll explore the `npiet` visual editor to create a simple tribute
    to Mondrian by turning one of his iconic paintings into code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将探索`npiet`可视化编辑器，通过将Mondrian的经典画作之一转换成代码，来创造一个简单的致敬作品。
- en: Piet’s popularity has created many implementations, associated tools, and even
    assemblers to generate Piet pictures from more traditional, text-based assembly
    code. We’ll take a quick look at the Piet universe to point you toward the resources
    you’ll need if you want to spend more time with Piet. Lastly, as always, we’ll
    conclude the chapter with a brief discussion.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Piet的流行催生了许多实现、相关工具，甚至还有汇编器，可以将更传统的基于文本的汇编代码转化为Piet图形。我们将简要介绍Piet的生态系统，指引你找到如果你想深入了解Piet所需的资源。最后，像往常一样，我们将在章节末尾进行简短的讨论。
- en: '**Installation**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安装**'
- en: Piet’s creator, David Morgan-Mar, has a helpful page at *[https://www.dangermouse.net/esoteric/piet.html](https://www.dangermouse.net/esoteric/piet.html)*.
    The page includes background information and an explanation of Piet’s operation.
    There’s also a nice collection of example programs and a link to third-party tools.
    Do take a look.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Piet的创建者David Morgan-Mar在*[https://www.dangermouse.net/esoteric/piet.html](https://www.dangermouse.net/esoteric/piet.html)*有一个非常有用的页面。页面包括背景信息和Piet的操作说明。还有一系列漂亮的示例程序以及第三方工具的链接。一定要去看看。
- en: To work with Piet, we need an interpreter. We’ll use Erik Schoenfelder’s `npiet`.
    It’s written in C and is fast enough for our purposes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Piet，我们需要一个解释器。我们将使用Erik Schoenfelder的`npiet`。它是用C语言编写的，足够快速，能满足我们的需求。
- en: To install and build `npiet`, first go to *[http://www.bertnase.de/npiet/](http://www.bertnase.de/npiet/)*
    and download *npiet-1.3f.tar.gz* (or any later version you see). The site includes
    a compiled executable for Windows users. The command sequence below, if `libgd`
    is available, should be (largely) appropriate for macOS.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装并构建`npiet`，首先访问*[http://www.bertnase.de/npiet/](http://www.bertnase.de/npiet/)*并下载*npiet-1.3f.tar.gz*（或者任何你看到的较新版本）。该网站为Windows用户提供了编译好的可执行文件。下面的命令序列，如果`libgd`可用，应该（大致）适用于macOS。
- en: 'Once you have *npiet-1.3f.tar.gz* enter the following commands:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完*npiet-1.3f.tar.gz*后，输入以下命令：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After a few warnings, there should be three executable files in the *npiet-1.3f*
    directory: `npiet`, `npietedit`, and `npiet-foogol`. The first is the interpreter.
    The second is a simple editor we’ll use to make our example programs. The third
    translates `foogol` programs into Piet. Foogol is an ALGOL-like language.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在几次警告后，*npiet-1.3f*目录中应该会有三个可执行文件：`npiet`、`npietedit`和`npiet-foogol`。第一个是解释器，第二个是一个简单的编辑器，我们将用它来创建我们的示例程序。第三个将`foogol`程序转换成Piet。Foogol是一种类似于ALGOL的语言。
- en: 'You may need to install additional packages like `groff` and `tk`. If so, this
    should be close to what you need:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要安装额外的软件包，如`groff`和`tk`。如果需要，这里有一些你可能需要的内容：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The book’s GitHub repo includes a *Piet* directory with example programs. I
    suggest copying `npiet` to the *examples* directory, or one level up, to simplify
    execution.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的GitHub仓库包括一个*Piet*目录，里面有示例程序。我建议将`npiet`复制到*examples*目录，或者向上一级目录，以简化执行过程。
- en: To test `npiet`, try
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试`npiet`，请尝试
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you see our favorite greeting, `npiet` is working correctly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到我们最喜欢的问候语，`npiet`就说明它正在正常工作。
- en: '**Understanding Piet**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**理解Piet**'
- en: Piet is unlike any of the languages we’ve previously encountered. Of course,
    we should expect a language using pictures as programs to be unusual. This section
    seeks to understand Piet, meaning how Piet represents numbers, programs, commands,
    and program flow. As a language, Piet is relatively simple. There are only 17
    commands, four of which are solely for input and output. However, program flow
    in Piet is more complex than in traditional languages.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Piet不同于我们之前接触过的任何编程语言。当然，我们应该预料到，使用图片作为程序的语言会非常特殊。本节旨在理解Piet，即Piet如何表示数字、程序、命令和程序流程。作为一门语言，Piet相对简单。它只有17个命令，其中4个仅用于输入和输出。然而，Piet中的程序流程比传统语言更复杂。
- en: We’ll begin with colors, as Piet programs are all about colors. Then we’ll learn
    how to represent numbers and programs. Next, we’ll discuss the command set and
    the unique way Piet implies commands using transitions between colors. Color transitions
    lead naturally to program flow.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从颜色开始，因为Piet程序完全依赖颜色。接下来我们将学习如何表示数字和程序。然后，我们将讨论命令集，以及Piet如何通过颜色之间的过渡来隐含命令。颜色过渡自然引导程序流程。
- en: '***Piet Colors***'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Piet颜色***'
- en: We have a problem at the start. Piet uses color images to represent programs,
    but this book is printed in grayscale. Therefore, referring to the GitHub examples
    is essential. That said, we’ll do what we can without color. For instance, [Figure
    9-1](ch09.xhtml#ch09fig1) presents the specific colors Piet uses as shades of
    gray along with HTML-style hex codes representing the color. A color version of
    this chart is in the file *piet_colors.png*. Lack of color won’t stop us, but
    be aware that color is critical to Piet and how it functions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们有一个问题。Piet使用彩色图像表示程序，而这本书是以灰度印刷的。因此，参考GitHub上的示例至关重要。尽管如此，我们会尽量在没有颜色的情况下进行说明。例如，[图9-1](ch09.xhtml#ch09fig1)展示了Piet所使用的具体颜色作为灰度阴影，并附有表示颜色的HTML风格十六进制代码。该图的彩色版本在文件*piet_colors.png*中。没有颜色并不会阻止我们，但请注意，颜色对Piet及其功能至关重要。
- en: '![Image](Images/09fig01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/09fig01.jpg)'
- en: '*Figure 9-1: Piet color chart*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-1：Piet颜色图*'
- en: Our Piet programs use only the colors in [Figure 9-1](ch09.xhtml#ch09fig1) along
    with black (`#000000`) and white (`#FFFFFF`). Some interpreters treat unknown
    colors as white, but we’ll restrict ourselves to only approved colors. The hex
    color codes specify the mix of red, green, and blue that make up the color.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的Piet程序只使用[图9-1](ch09.xhtml#ch09fig1)中的颜色，以及黑色(` #000000`)和白色(`#FFFFFF`)。一些解释器会将未知颜色当作白色，但我们将仅限于使用已批准的颜色。十六进制颜色代码指定了构成颜色的红、绿、蓝的混合。'
- en: '***Representing Numbers***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***表示数字***'
- en: Piet is stack based, like Forth. Numbers are represented as blocks of the same
    color and the number of pixels in the block specifies the color. Therefore, a
    3×5 pixel block represents 3 × 5 = 15, whereas a square with 5 pixel sides is
    25\. Note that the blocks need not be rectangular or square, but only connected
    on the edges. A block may even contain holes. If that sounds very abstract, don’t
    worry. We’ll see examples below.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Piet是基于栈的，类似于Forth。数字通过相同颜色的块表示，块中像素的数量指定了数字。因此，一个3×5的像素块表示3 × 5 = 15，而一个边长为5像素的正方形则表示25。请注意，块不必是矩形或正方形，只要在边缘上相连即可。一个块甚至可以包含空洞。如果这听起来很抽象，不用担心。下面我们会看到一些例子。
- en: '***Representing Programs***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***表示程序***'
- en: Each pixel of the program is significant. However, if we attempt to look at
    the program at the pixel level, we’ll be hard-pressed to see anything. Therefore,
    we’ll present programs as magnified images. When images are magnified, each pixel
    becomes a square of pixels. The square of pixels mapping to the original pixel
    is called a *codel*. For example, if the image is magnified by a factor of 10,
    each pixel becomes a 10×10 square; therefore, the codels are each a 10×10 pixel
    region.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的每个像素都是重要的。然而，如果我们试图以像素级别查看程序，我们几乎看不出任何东西。因此，我们将以放大图像的方式呈现程序。当图像被放大时，每个像素会变成一个像素块。映射到原始像素的像素块被称为*代码块*。例如，如果图像被放大了10倍，每个像素就变成了一个10×10的方块；因此，代码块就是一个10×10像素的区域。
- en: Consider the example program *add.png*, shown in grayscale in [Figure 9-2](ch09.xhtml#ch09fig2).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑示例程序*add.png*，它在[图 9-2](ch09.xhtml#ch09fig2)中以灰度显示。
- en: '![Image](Images/09fig02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/09fig02.jpg)'
- en: '*Figure 9-2: Adding two numbers, 2 + 2 = 4*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-2：加法操作，2 + 2 = 4*'
- en: The original image is 9 pixels wide and 4 pixels high. The version shown in
    [Figure 9-2](ch09.xhtml#ch09fig2) is magnified by 200, so each pixel becomes a
    200×200 pixel square, a codel. For this example, I added grid lines to explicitly
    mark the codel boundaries.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 原始图像宽度为9像素，高度为4像素。在[图 9-2](ch09.xhtml#ch09fig2)中显示的版本被放大了200倍，因此每个像素变成了200×200像素的方块，一个codel。对于这个例子，我添加了网格线来明确标记codel的边界。
- en: Typesetting alters the codel to pixel mapping, but knowing that *add.png* is
    4 pixels high helps us look at [Figure 9-2](ch09.xhtml#ch09fig2) and understand
    the codels. For example, from bottom to top, the leftmost column is two black
    codels and two light red codels. Piet treats black as a wall, so the two light
    red codels form a 2×1 rectangle, that is, the number 2\. We’ll walk through *add.png*
    below. For now, just focus on the mapping between blocks, pixels, and codels.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 排版会改变codel到像素的映射，但知道*add.png*的高度为4像素，有助于我们查看[图 9-2](ch09.xhtml#ch09fig2)并理解codel。例如，从下到上，最左列是两个黑色codel和两个浅红色codel。Piet将黑色视为墙壁，因此两个浅红色codel形成一个2×1的矩形，也就是数字2。我们将在下面详细讲解*add.png*。目前，请只关注块、像素和codel之间的映射。
- en: '***Piet Commands***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Piet命令***'
- en: Look again at [Figure 9-1](ch09.xhtml#ch09fig1). Beginning with the upper-left
    corner and moving to the right transitions the colors from red to yellow to green
    to cyan to blue, and, wrapping around from the right to the left, back to red.
    Moving along the rows in [Figure 9-1](ch09.xhtml#ch09fig1), we see a change in
    the hue (that is, the color) without a change in lightness. Each move along the
    top row of [Figure 9-1](ch09.xhtml#ch09fig1) changes a single C0[16] to FF[16]
    or vice versa. Similarly, for the middle row, values change from 00[16] to FF[16],
    and for the bottom row, from 00[16] to C0[16].
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看[图 9-1](ch09.xhtml#ch09fig1)。从左上角开始，向右移动时，颜色从红色过渡到黄色，再到绿色、青色、蓝色，然后从右边绕回到红色。在[图
    9-1](ch09.xhtml#ch09fig1)的行中，我们看到色调（即颜色）的变化，而亮度保持不变。每次沿着[图 9-1](ch09.xhtml#ch09fig1)的顶行移动时，都会将一个C0[16]更改为FF[16]或反之。同样，对于中间行，值从00[16]变为FF[16]，对于底行，从00[16]变为C0[16]。
- en: Moving up and down the columns changes the lightness of the color while preserving
    the hue. From top to middle, C0[16] becomes 00[16], whereas from middle to bottom,
    FF[16] becomes C0[16]. As with rows, moving from the darkest color in a column
    to the lightest is also a single transition step. This all means that movement
    along the color table is cyclic.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在列之间上下移动会改变颜色的亮度，同时保持色调不变。从上到中，C0[16]变为00[16]，而从中到下，FF[16]变为C0[16]。与行一样，从列中的最暗颜色移动到最亮颜色也是一个单独的过渡步骤。这一切意味着沿着颜色表的移动是循环的。
- en: Why all this concern about hue and lightness? It’s because Piet does not represent
    commands uniquely. There isn’t a single color that means “push a number” or “add.”
    Instead, it’s the number of hue or lightness steps taken between regions that
    specifies the command. The colors themselves do not matter. The color table is
    cyclic, so it’s possible to move from any initial color to any ending color. This
    means that any command can be specified from any starting color.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么如此关注色调和亮度？这是因为Piet并没有唯一地表示命令。没有一个单一的颜色表示“推入一个数字”或“加法”。相反，指定命令的是在区域之间采取的色调或亮度步骤数。颜色本身并不重要。颜色表是循环的，因此可以从任何初始颜色移动到任何结束颜色。这意味着，任何命令都可以从任何起始颜色指定。
- en: '[Table 9-1](ch09.xhtml#ch09tab1) lists Piet’s commands according to the hue
    and lightness change that causes the command to execute. Here, the rows represent
    a change in hue by that many steps and the columns a similar change in lightness.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-1](ch09.xhtml#ch09tab1)列出了Piet的命令，这些命令是根据色调和亮度变化来执行的。这里，行代表色调的变化步数，列代表亮度的类似变化。'
- en: '**Table 9-1:** Piet Commands as Specified by Transitions in Hue (Row) and Lightness
    (Column) Between Blocks'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-1：** 由色调（行）和亮度（列）之间的过渡指定的Piet命令'
- en: '|  | **0** | **1** | **2** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|  | **0** | **1** | **2** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **0** | none | push | pop |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **0** | none | push | pop |'
- en: '| **1** | + | *–* | × |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **1** | + | *–* | × |'
- en: '| **2** | ÷ | mod | not |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **2** | ÷ | mod | not |'
- en: '| **3** | > | pointer | switch |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **3** | > | pointer | switch |'
- en: '| **4** | dup | roll | inN |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **4** | dup | roll | inN |'
- en: '| **5** | inC | outN | outC |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **5** | inC | outN | outC |'
- en: For example, to push a number on the stack, the transition between blocks must
    involve a lightness change of one step but no change in hue. Therefore, any block
    transition from a particular row of [Figure 9-1](ch09.xhtml#ch09fig1) to the row
    below that keeps the column constant results in a `push` command. The number pushed
    on the stack is the number of codels (pixels) in the block just exited. Recall
    that moving from the darkest to the lightest for any color is also a lightness
    transition of one.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将一个数字压入栈中，块之间的过渡必须涉及亮度变化一个单位，但色调保持不变。因此，从[图 9-1](ch09.xhtml#ch09fig1)中的某一行到下方的行，并保持列不变的块过渡结果会执行
    `push` 命令。压入栈中的数字是刚刚退出的块中 codel（像素）的数量。回想一下，任何颜色从最暗到最亮的过渡也是亮度变化一个单位。
- en: Similarly, to execute an `outC` instruction to output the top stack item as
    an ASCII character, the block transition must change lightness by two and hue
    by five. For example, moving from a block that is light red to one that is dark
    magenta will execute `outC`. Likewise, moving from a cyan block to a light green
    block will also execute `outC`. Count the hue and lightness changes necessary
    using [Figure 9-1](ch09.xhtml#ch09fig1) to convince yourself that moving from
    a cyan block to a light green block will indeed specify an `outC` command.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要执行 `outC` 指令将栈顶项作为 ASCII 字符输出，块之间的过渡必须使亮度变化两个单位，色调变化五个单位。例如，从一个浅红色块移动到一个深品红色块将执行
    `outC`。同样，从一个青色块移动到一个浅绿色块也会执行 `outC`。使用[图 9-1](ch09.xhtml#ch09fig1)计算所需的色调和亮度变化，来确认从青色块到浅绿色块的移动确实会指定一个
    `outC` 命令。
- en: 'Many of the commands in [Table 9-1](ch09.xhtml#ch09tab1) are familiar to us
    after our investigation of Forth in [Chapter 4](ch04.xhtml#ch04). This is especially
    true of the math operators, greater-than, and `dup`, which duplicates the top
    stack item. Also, `push` was described in the previous paragraph. Lastly, `pop`
    is intuitive: drop the top stack item (this is `DROP` in Forth).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表 9-1](ch09.xhtml#ch09tab1)中，许多命令在我们研究 Forth 的[第 4 章](ch04.xhtml#ch04)之后对我们来说是熟悉的。尤其是数学运算符、大于号和
    `dup`，它用于复制栈顶项。此外，`push` 在前面的段落中已有描述。最后，`pop` 是直观的：丢弃栈顶项（在 Forth 中这是 `DROP`）。
- en: Using Forth-style stack effect comments helps to illuminate this set of Piet
    commands.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Forth 风格的栈效果注释有助于阐明这一组 Piet 命令。
- en: '![Image](Images/f0248-02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0248-02.jpg)'
- en: The input and output commands, `inN`, `inC`, `outN`, and `outC`, are similarly
    straightforward. The `N` versions accept a number or output a number. The `C`
    versions accept a character or output the top stack item as an ASCII character.
    For example, `outC` prints `A` if the top stack item is 65—the ASCII code for
    capital *A*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 输入和输出命令 `inN`、`inC`、`outN` 和 `outC` 也类似地直接。`N` 版本接受一个数字或输出一个数字。`C` 版本接受一个字符或将栈顶项输出为
    ASCII 字符。例如，如果栈顶项是 65（大写字母 *A* 的 ASCII 码），`outC` 将输出 `A`。
- en: The remaining instructions, `not`, `pointer`, `switch`, and `roll`, need some
    explanation. The simplest of these is `not`. In this instruction we pop the top
    stack item, and push a 1 on the stack if the item is not 0 and push 0 on the stack
    otherwise. The net effect is to toggle the truth value where 0 is false, and anything
    else is true, as in C. The `npiet` interpreter is written in C, so this behavior
    is natural.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的指令 `not`、`pointer`、`switch` 和 `roll` 需要一些解释。其中最简单的是 `not`。在这个指令中，我们弹出栈顶项，如果该项不为
    0，则将 1 压入栈中，否则将 0 压入栈中。其最终效果是切换真值，其中 0 为假，其他任何值为真，就像 C 语言中的布尔值一样。`npiet` 解释器是用
    C 语言编写的，所以这种行为是自然的。
- en: The `pointer` command rotates the direction pointer (DP) clockwise the number
    of times specified by the top stack item. The `switch` command pops the stack
    and toggles the codel chooser (CC) that many times, ignoring the sign. We’ll cover
    the DP and CC in detail in the next section. For now, just know that `pointer`
    affects the DP and `switch` affects the CC.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`pointer` 命令按栈顶项指定的次数顺时针旋转方向指针（DP）。`switch` 命令弹出栈顶项，并按该次数切换代码选择器（CC），忽略符号。我们将在下一节详细介绍
    DP 和 CC。现在，只需知道 `pointer` 影响 DP，`switch` 影响 CC。'
- en: Piet’s most complex command is `roll`, which is used to manipulate the stack
    by rolling a set number of items a given number of times. Let’s look at an example
    to see what this means.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Piet 最复杂的命令是 `roll`，它用于通过将一定数量的项滚动给定的次数来操控栈。让我们通过一个例子来看这是什么意思。
- en: 'The file *roll32.png* contains a program that places the numbers 1 through
    5 on the stack and sets up a call to `roll` to rotate the top three items two
    times. Visually, *roll32.png* looks like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 *roll32.png* 包含一个程序，将数字 1 到 5 放入栈中，并设置调用 `roll` 旋转顶部三个项目两次。视觉上，*roll32.png*
    看起来是这样的：
- en: '![Image](Images/f0248-01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0248-01.jpg)'
- en: The program flows from left to right, column by column, to push 1, then 2, 3,
    4, and 5 on the stack. The following two columns push 3 and then 2\. The remainder
    of the code calls `roll` to rotate the top three stack items two times and dump
    the stack by repeated calls to `outN`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 程序从左到右逐列执行，依次将 1、2、3、4 和 5 压入栈。接下来的两列依次压入 3 和 2。剩下的代码调用 `roll` 旋转顶部三个栈项两次，然后通过重复调用
    `outN` 弹出栈。
- en: Before the call to `roll`, the stack, from left to right, is
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `roll` 之前，栈从左到右是
- en: '`1 2 3 4 5 3 2`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`1 2 3 4 5 3 2`'
- en: The call to `roll` first pops 2, then 3\. The 2 is the number of times to roll
    the top 3 items. A roll rotates the items so that `3 4 5` becomes `5 3 4`. Therefore,
    two rolls are
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `roll` 的调用首先弹出 2，然后是 3。2 是旋转顶部 3 个项目的次数。一次旋转会让项目顺序变为 `3 4 5` 变为 `5 3 4`。因此，两次旋转后是
- en: '`3 4 5` → `5 3 4` → `4 5 3`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`3 4 5` → `5 3 4` → `4 5 3`'
- en: and the final stack is
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的栈是
- en: '`1 2 4 5 3`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`1 2 4 5 3`'
- en: The stack being popped from right to left implies that the output of *roll32
    .png* should be `35421`, as no spaces are printed. Indeed, this is the output,
    so `roll` behaves as we think it should.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从右到左弹出的栈意味着 *roll32 .png* 的输出应该是 `35421`，因为没有打印空格。确实，这是输出结果，因此 `roll` 的行为符合我们的预期。
- en: '***Program Flow***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***程序流程***'
- en: Program flow in most languages is straightforward. Unless a branch, goto, or
    equivalent happens, statements are executed sequentially. Thinking now of low-level
    machine code, there is a single program counter, something that points to the
    next instruction. In Piet, program flow is more complex. Flow moves from a block
    of the same color to the next block, beginning with the top leftmost block. The
    direction is controlled by the *direction pointer (DP*). When a Piet program begins,
    the DP is to the right.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言中的程序流程是直接的。除非发生分支、跳转或等效操作，否则语句是按顺序执行的。现在考虑低级机器代码，程序计数器是指向下一个指令的东西。在 Piet
    中，程序流程更为复杂。流程从同一颜色的一个块移动到下一个块，从左上角的块开始。流向由 *方向指针（DP）* 控制。当 Piet 程序开始时，DP 在右侧。
- en: At first, we might think we need only a DP; however, there is a minor issue.
    Piet moves from block to block, but to determine the next block, it needs to know
    how far to move along which edge of the current block. This introduces the *codel
    chooser (CC)*. The CC is initially to the left, but it can also be to the right.
    Whose left or right? The DP’s left or right. Therefore, when a Piet program begins,
    the DP is to the right and the CC is to the left, meaning the next block is the
    one to the topmost right edge of the current block. In fact, it is to the furthest
    right extent of the block. Thus, Piet selects the next block by going as far as
    possible in the current block in the direction of the DP and then respecting the
    current value of CC.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们可能认为只需要一个 DP；然而，有一个小问题。Piet 从一个块移动到另一个块，但为了确定下一个块，它需要知道沿着当前块的哪条边移动多远。这引入了
    *代码选择器（CC）*。CC 最初位于左侧，但也可以位于右侧。谁的左或右？是 DP 的左或右。因此，当 Piet 程序开始时，DP 在右侧，CC 在左侧，这意味着下一个块是当前块的最右上角。实际上，它是块的最右端。因此，Piet
    通过在当前块中尽可能向 DP 方向移动，并遵循当前 CC 的值来选择下一个块。
- en: For example, consider the image below.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑下面的图像。
- en: '![Image](Images/f0249-01.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0249-01.jpg)'
- en: The program is currently in the left block, 2×1 codels, and the DP is pointing
    to the right. Which block should be considered next? The top or the bottom of
    the second column? If the CC is to the left, Piet moves to the right from the
    top of the 2×1 block to select the top block of the right column, which is the
    darker block. If the CC were to the right, we would choose the lower block instead.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 程序目前在左块中，2×1 的代码块，DP 正在指向右侧。接下来应该考虑哪个块？第二列的顶部还是底部？如果 CC 在左侧，Piet 将从 2×1 块的顶部向右移动，选择右列的顶部块，也就是较暗的那个块。如果
    CC 在右侧，我们则选择下方的块。
- en: '[Figure 9-3](ch09.xhtml#ch09fig3) presents the relationship between the DP
    and CC in two different ways.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-3](ch09.xhtml#ch09fig3) 展示了 DP 和 CC 之间的关系，采用了两种不同的方式。'
- en: '![Image](Images/09fig03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/09fig03.jpg)'
- en: '*Figure 9-3: The relationship between the direction pointer (DP) and the codel
    chooser (CC)*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-3：方向指针（DP）和代码选择器（CC）之间的关系*'
- en: The diagram on the right shows the DP as arrows leading up, down, left, or right,
    with the CC for each direction marked as *L* or *R*. The numbers correspond to
    the rows of the table on the left of the figure. The table shows DP and CC with
    arrows. The two complementary presentations should clarify how to use DP and CC
    to control program flow.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的图示展示了DP作为箭头指向上、下、左或右，每个方向的CC标记为*L*或*R*。数字对应图左表格中的行。表格展示了带箭头的DP和CC。两个互补的展示方式应当能够帮助理解如何使用DP和CC来控制程序流程。
- en: 'Piet moves from colored block to colored block based on DP and CC, but there
    are two special colors we must also consider: black and white. Black, as stated
    above, acts like a wall or the edge of the image. When Piet encounters black or
    an edge, it begins adjusting the DP and CC to try to find an escape, that is,
    a way out to continue the program. If it can’t find an escape, the program ends.
    Specifically, Piet uses the following steps to move through the image:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Piet根据DP和CC从一个彩色块移动到另一个彩色块，但我们还需要考虑两个特殊的颜色：黑色和白色。正如前面所述，黑色就像一堵墙或图像的边缘。当Piet遇到黑色或边缘时，它会开始调整DP和CC，尝试找到一个出口，也就是继续程序的出路。如果找不到出口，程序将结束。具体来说，Piet通过以下步骤在图像中移动：
- en: From the current position, move as far as possible in the direction of the DP
    until you encounter either a color change or the edge of the image.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从当前位置开始，尽可能沿着DP的方向移动，直到遇到颜色变化或图像边缘。
- en: From the position found in Step 1, move as far as possible to the left or right
    depending on the CC direction. This selects the first codel of the next block.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从步骤1中找到的位置，按照CC的方向尽可能向左或向右移动。这将选择下一个块的第一个代码点。
- en: If the steps above encounter a black block or image edge, we toggle the CC from
    left to right or right to left and repeat the steps above. If this process fails,
    the DP is rotated clockwise and CC toggling repeats. This process continues until
    a path is found to a new block or all moves fail.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果上述步骤遇到黑色块或图像边缘，我们将CC从左切换到右或从右切换到左，并重复上述步骤。如果此过程失败，则DP顺时针旋转，CC切换重复进行。此过程会持续进行，直到找到通向新块的路径或所有操作失败。
- en: If all DP and CC adjustments fail, the program terminates.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有DP和CC调整都失败，程序终止。
- en: The steps above handle colored blocks, black blocks, and image edges. To further
    complicate matters, Piet also allows white blocks. White blocks are no-operation
    blocks called *no-ops.* The interpreter passes through white blocks like any other
    block, but the transition does not imply a command. This allows the programmer
    to change from one colored block to another without executing a command, and,
    as we’ll see below, the arrangement of black and white blocks can act as a control
    structure to enforce desired program flow.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤处理了彩色块、黑色块和图像边缘。为了让问题更复杂，Piet还允许白色块。白色块是无操作块，称为*no-ops*。解释器会像处理其他块一样通过白色块，但过渡并不意味着执行命令。这允许程序员在不执行命令的情况下从一个彩色块切换到另一个彩色块，正如我们下面将看到的，黑色和白色块的排列可以充当控制结构，强制执行所需的程序流程。
- en: '**Piet in Action**'
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Piet实战**'
- en: 'In this section, we’ll get our hands dirty and work through four examples:
    *add.png*, *hi.png*, *countdown.png*, and *random.png*. The first prints the sum
    of 2 + 2; the second, which we saw above, prints `Hi`; the third is a countdown
    loop; and the fourth is a simple pseudorandom number generator.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将实际操作并处理四个示例：*add.png*、*hi.png*、*countdown.png* 和 *random.png*。第一个示例输出2
    + 2的和；第二个示例，正如我们上面看到的，输出`Hi`；第三个是一个倒计时循环；第四个是一个简单的伪随机数生成器。
- en: '***Proving 2 + 2 = 4***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***证明 2 + 2 = 4***'
- en: 'Our first example, *add.png* has a direct analog in the following Forth code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个示例，*add.png*，在下面的Forth代码中有一个直接的类比：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The number 2 is pushed on the stack, followed by another 2, then + pops the
    top two stack items, adds them, and pushes the sum onto the stack which is then
    printed as a number. Let’s walk through the execution of *add.png* to understand
    how it works.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 数字2被推入栈中，接着再推入另一个2，然后+操作从栈顶弹出两个项，将它们相加，并将和推回栈中，然后打印为一个数字。让我们通过执行*add.png*来理解它是如何工作的。
- en: First, run *add.png* using `npiet`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`npiet`运行*add.png*。
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If all `npiet` did was run the program given, we’d be hard-pressed to understand
    program flow, let alone debug it if necessary. Fortunately for us, `npiet` can
    dump an output image and show an execution trace. For example, the following command
    produces an output file, *npiet-trace.png*, as shown in [Figure 9-4](ch09.xhtml#ch09fig4).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`npiet`只执行给定的程序，我们将很难理解程序流，甚至更难在需要时进行调试。幸运的是，`npiet`可以输出一张图像并显示执行追踪。例如，以下命令会生成一个输出文件*npiet-trace.png*，如[图9-4](ch09.xhtml#ch09fig4)所示。
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `-tpic` option produces the trace and `-tpf 80` scales the output so the
    text is easier to read, at least in the output image file if not on the printed
    page.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`-tpic`选项生成追踪图，`-tpf 80`则会缩放输出，使得文本更加易读，至少在输出图像文件中是这样，如果不是在打印页上。'
- en: '![Image](Images/09fig04.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09fig04.jpg)'
- en: '*Figure 9-4: Tracing* add.png'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-4：追踪* add.png'
- en: The top part of [Figure 9-4](ch09.xhtml#ch09fig4) is `npiet`’s output in grayscale.
    The bottom part of the figure traces the program flow to make it easier to follow
    in the book. The file *add.png* consists of five blocks, each 2×1 codels, corresponding
    to the first five circles marked 0 through 4\. Recall that Piet commands are specified
    by hue and lightness transitions, so the commands are printed above the arrows
    moving from block to block.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-4](ch09.xhtml#ch09fig4)的顶部是`npiet`的灰度输出。图的底部追踪了程序的执行流程，使得在书中跟踪变得更加容易。*add.png*文件由五个区块组成，每个区块是2×1的codel，对应标记为0到4的前五个圆圈。回想一下，Piet命令是通过色调和亮度的变化来指定的，所以命令会被打印在从一个区块到另一个区块的箭头上方。'
- en: 'The Forth code above is duplicated by the Piet code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的Forth代码通过Piet代码进行了重复：
- en: '`push(2)` → `push(2)` → `add` → `outN`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`push(2)` → `push(2)` → `add` → `outN`'
- en: After `outN` is a white region, which represents a no-op, so Piet flows through
    the white area following the flow rules above. First, as DP is to the right, Piet
    moves to the end of the first part of the block and encounters a black codel.
    The CC is right, and Piet can’t move further to the right because of the black
    block, so DP rotates to face downward and moves into the light colored block at
    the lower right. This block is surrounded by black or the edge of the image. As
    it moves to the edges of the current block, Piet can find no way out even after
    rotating DP all the way around, so the interpreter gives up and the program ends.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`outN`之后是一个白色区域，表示无操作，因此Piet会按照上面的流程规则穿过这个白色区域。首先，由于DP位于右侧，Piet会移动到区块的第一部分末端并遇到一个黑色codel。CC向右，Piet无法继续向右移动，因为黑色区块阻挡了路径，于是DP旋转面朝下，进入右下角的浅色区块。这个区块被黑色或图像的边缘包围。当它移动到当前区块的边缘时，Piet发现即使旋转DP一圈也找不到出口，于是解释器放弃并结束程序。
- en: If you look at the *npiet-trace.png* image `npiet` created via the `-tpic` option,
    you’ll see color and small substeps showing how CC changes as DP changes. Please
    do look at the trace image, as it is too hard to read the substep indications
    in [Figure 9-4](ch09.xhtml#ch09fig4).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`npiet`通过`-tpic`选项生成的*npiet-trace.png*图像，你会看到颜色和小的子步骤，展示了随着DP变化，CC如何变化。请务必查看追踪图像，因为在[图9-4](ch09.xhtml#ch09fig4)中，子步骤的指示信息太难以阅读。
- en: '***Saying Hi***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***打招呼***'
- en: We tested our Piet installation with *hi.png*. Now let’s walk through the code
    to learn more about how Piet applies flow control rules to select where to move
    next. Unlike *add.png*, *hi.png* doesn’t use simple blocks, so some thought is
    required to understand why the Piet interpreter does what it does.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用*hi.png*测试了我们的Piet安装。现在，让我们通过代码一步一步地了解Piet如何应用流程控制规则来选择接下来的移动位置。与*add.png*不同，*hi.png*没有使用简单的区块，因此需要一些思考来理解为什么Piet解释器会做出这样的行为。
- en: '[Figure 9-5](ch09.xhtml#ch09fig5) shows us a trace of *hi.png* with the program
    flow below it.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-5](ch09.xhtml#ch09fig5)展示了*hi.png*的追踪图，程序流在其下方。'
- en: '![Image](Images/09fig05.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09fig05.jpg)'
- en: '*Figure 9-5: Tracing* hi.png'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-5：追踪* hi.png'
- en: In this case, the blocks have irregular shapes, and it might not be obvious
    why the interpreter selects the path it does. The irregular blocks in [Figure
    9-5](ch09.xhtml#ch09fig5) have been outlined in white to make them easier to see.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，区块的形状不规则，可能不容易看出解释器为什么选择它的路径。为了让它们更容易看见，[图9-5](ch09.xhtml#ch09fig5)中的不规则区块已被用白色框出。
- en: 'The transition from Step 0 to Step 1 is simple enough: Block 0 is a square,
    the DP begins to the right, and CC is to the left (top), so the only place to
    go is Block 1\. However, the transition from Step 1 to Step 2 isn’t immediately
    obvious. Inside Block 1 we expect the flow to move to the right along the top
    edge of the block. Although it is not clearly visible in [Figure 9-5](ch09.xhtml#ch09fig5),
    the top block is black and acts as a barrier. Therefore, according to Piet’s flow
    rules, CC is toggled to be to the right or bottom of the block as DP is to the
    right. This alone might imply rotating DP to face down and selecting the large,
    light-colored irregular block. However, Piet’s flow rules apply to the maximum
    extent of a block in the direction DP is facing. For Block 1, this means the bottom
    of the block, as it is furthest to the right and not stopped by the black square
    at the top. So, Piet moves from Block 1 to the small, light-colored square of
    Step 2.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从步骤0到步骤1的过渡足够简单：块0是一个正方形，DP从右侧开始，CC在左侧（顶部），所以唯一的去处是块1。然而，从步骤1到步骤2的过渡并不是立刻显而易见的。在块1内部，我们预期流程沿着块的顶部边缘向右移动。虽然在[图9-5](ch09.xhtml#ch09fig5)中没有明显显示，但顶部块是黑色的并起到障碍作用。因此，根据Piet的流程规则，CC会切换到块的右侧或底部，因为DP朝右。这可能暗示将DP旋转朝下，并选择大的浅色不规则块。然而，Piet的流程规则适用于DP所面朝的方向下的最大块。因此，对于块1来说，这意味着块的底部，因为它是最右侧的部分，并没有被顶部的黑色正方形阻挡。所以，Piet从块1移动到步骤2的小的浅色正方形。
- en: Flow from Step 2 to Step 10 is straightforward. To go from Step 10 to Step 11,
    we use the same set of rules as going from Step 1 to Step 2, but this time DP
    is facing to the left, so we select the leftmost edge of Block 10 and flow moves
    to Block 12, the terminal block. Block 12 is a trap. DP is to the left and the
    leftmost part of the block is at the bottom, but once there, Piet will find no
    way to move to a new block, thereby ending the program.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从步骤2到步骤10的流程是直接的。从步骤10到步骤11，我们使用与从步骤1到步骤2相同的规则，但这时DP朝左，因此我们选择块10的最左边的边缘，流程移动到块12，终止块。块12是一个陷阱。DP在左侧，而块的最左部分在底部，但一旦进入，Piet会发现无法移动到新的块，从而结束程序。
- en: 'As for the code implied by *hi.png*, it’s quite simple:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 至于*hi.png*所隐含的代码，它相当简单：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: with 9 × 8 = 72, the ASCII code for *H*, and 72 + 11 × 3 = 105, the code for
    *i*, followed by ASCII 10 for the final newline character.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 9 × 8 = 72，这是字符*H*的ASCII代码，72 + 11 × 3 = 105，这是字符*i*的代码，最后是ASCII 10，表示换行符。
- en: '***Countdown***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***倒计时***'
- en: The file *countdown.png* contains a program to count down from 10 to 1\. To
    make our lives easier, as far as tracing goes, we’ll work with the slightly edited
    version in *countdown3.png*, which counts down from 3.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*countdown.png*包含一个从10倒计时到1的程序。为了简化追踪过程，我们将使用稍微编辑过的版本*countdown3.png*，它从3开始倒计时。
- en: 'Running *countdown3.png* produces the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 运行*countdown3.png*会生成以下内容：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: I admit the output of *countdown3.png* is not particularly interesting, but
    this example shows us how to work with loops in Piet, which is. The top part of
    [Figure 9-6](ch09.xhtml#ch09fig6) is a trace of *countdown3.png*. As printed,
    it won’t be possible to see the flow properly. So as with [Figure 9-4](ch09.xhtml#ch09fig4),
    refer instead to the flow diagram at the bottom of [Figure 9-6](ch09.xhtml#ch09fig6)
    and review the file *npiet-trace.png* that `npiet` made for us when executing
    *countdown3.png*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我承认*countdown3.png*的输出并不特别有趣，但这个例子向我们展示了如何在Piet中使用循环，这才是关键。[图9-6](ch09.xhtml#ch09fig6)的上部分是*countdown3.png*的追踪。按原样打印时，无法正确看到流程。因此，像[图9-4](ch09.xhtml#ch09fig4)一样，参见[图9-6](ch09.xhtml#ch09fig6)底部的流程图，并查看`npiet`在执行*countdown3.png*时为我们生成的*npiet-trace.png*文件。
- en: '![Image](Images/09fig06.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/09fig06.jpg)'
- en: '*Figure 9-6: Tracing* countdown3.png'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-6：追踪* countdown3.png'
- en: We might write *countdown3.png* as in [Listing 9-1](ch09.xhtml#ch09list1).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将*countdown3.png*写成[清单9-1](ch09.xhtml#ch09list1)中的样子。
- en: '[PRE8]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 9-1: countdown3.png as text*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-1：作为文本的countdown3.png*'
- en: The code pushes the limit, 3, onto the stack, and then the loop begins by duplicating
    the top stack item so it can be printed as a number ➊. The next block of code
    pushes 10 on the stack and outputs it as a character. For Unix systems, ASCII
    10 is newline ➋.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将3推入堆栈，然后通过复制堆栈顶部项来开始循环，以便打印为数字➊。接下来的代码块将10推入堆栈并作为字符输出。对于Unix系统，ASCII 10是换行符➋。
- en: The counter value is still on the stack, so it’s decremented by 1 ➌. The final
    `dup` in this section of the code sets up for the comparison to see whether the
    countdown is 0.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器的值仍然在栈上，因此它会被递减 1 ➌。代码中的最终 `dup` 指令为后续比较是否计时结束（倒计时为 0）做准备。
- en: 'Piet uses the number of pixels in a block to represent numbers. Therefore,
    it isn’t possible to directly represent 0 and push it on the stack. However, ➍
    shows us a useful Piet idiom: get a 0 on the stack by pushing a 1 and calling
    `not`. The stack is now set up with two copies of the counter value and a 0\.
    The top two stack items are consumed by `>`, leaving a 0 or 1 on the stack.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Piet 使用块中像素的数量来表示数字。因此，不能直接表示 0 并将其推入栈中。然而，➍ 展示了一个有用的 Piet 习惯用法：通过推入 1 并调用 `not`
    来将 0 推入栈中。此时栈中已经设置了两个计数器值和一个 0。`>` 会消耗栈顶的两个值，留下 0 或 1 在栈上。
- en: Here’s where things get interesting. Piet has no explicit branch instruction,
    that is, no direct analog of the `if` statement shown in [Listing 9-1](ch09.xhtml#ch09list1).
    Instead, Piet uses the `pointer` instruction to rotate the DP, which at this point
    in *countdown3.png* is facing left. The `pointer` instruction uses the top stack
    value to rotate DP clockwise by that many steps. The result from `>` is a 0 or
    1\. If 1, it means that the counter value is greater than 0, so we want the loop
    to continue. In that case, `pointer` will rotate DP one position clockwise so
    that it is now facing up. Moving directly up from this part of *countdown3.png*
    puts us right at the beginning of the loop, ➊ in [Listing 9-1](ch09.xhtml#ch09list1).
    The direction pointer is facing up, but there is nowhere to go, so Piet, following
    the flow rules, rotates DP clockwise, so it is now facing right, and the loop
    continues.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里开始变得有趣了。Piet 没有明确的分支指令，也就是说，没有像 [Listing 9-1](ch09.xhtml#ch09list1) 中展示的 `if`
    语句的直接类比。相反，Piet 使用 `pointer` 指令来旋转数据指针（DP），此时在 *countdown3.png* 中它朝向左侧。`pointer`
    指令使用栈顶的值来按该值步数顺时针旋转数据指针。`>` 指令的结果是 0 或 1。如果是 1，表示计数器的值大于 0，因此我们希望循环继续。在这种情况下，`pointer`
    将顺时针旋转数据指针一位，使其现在朝上。从 *countdown3.png* 中这部分直接向上移动将使我们回到循环的起始位置，也就是 [Listing 9-1](ch09.xhtml#ch09list1)
    中的 ➊。此时方向指针朝上，但没有地方可去，因此 Piet 按照流控制规则顺时针旋转数据指针，使其现在朝右，循环继续。
- en: If `>` leaves 0 on the stack, the DP is unaffected by `pointer`, and flow continues
    to the left, ultimately landing in the trap where Piet is unable to find an exit,
    so the program ends.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `>` 在栈上留下 0，`pointer` 将不会影响数据指针，流控制继续向左，最终进入一个陷阱，Piet 无法找到出口，因此程序结束。
- en: '***A Pseudorandom Number Generator***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***伪随机数生成器***'
- en: The final example in this section is *random.png*, a simple pseudorandom number
    generator. The program implements a *linear congruential* pseudorandom number
    generator, which is a simple way to generate a sequence of integers that appears
    random. We’ll work with this type of generator again in [Chapter 13](ch13.xhtml#ch13).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的最后一个示例是 *random.png*，一个简单的伪随机数生成器。程序实现了一个 *线性同余* 伪随机数生成器，这是一种生成看似随机的整数序列的简单方法。我们将在
    [第 13 章](ch13.xhtml#ch13) 中再次使用这种类型的生成器。
- en: The generator itself is the single equation
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器本身就是一个单一方程式。
- en: '*s*[*i*+1] ← *a**s**[i]* mod *m*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*s*[*i*+1] ← *a**s**[i]* mod *m*'
- en: for some initial seed value, *s*[0]. Both *a* and *m* are integer constants.
    If *a* and *m* are properly selected, then the sequence of *s*[*i*] values generated
    by taking the output and using it as the new input will pass statistical tests
    for randomness, or so we hope.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某个初始种子值 *s*[0]，*a* 和 *m* 都是整数常量。如果 *a* 和 *m* 被恰当选择，则通过将输出值作为新输入生成的 *s*[*i*]
    序列将通过随机性统计测试，或者我们希望如此。
- en: 'We can break the equation down into steps: first, multiply the current seed
    value (*s*[*i*]) by the multiplier, *a*. Then, calculate the remainder when dividing
    that product by *m* and set that as the new seed value (*s*[*i*+1]). The modulo
    operation (mod) gives the remainder and, fortunately for us, is one of the math
    operations Piet supports.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将方程分解成几个步骤：首先，将当前种子值 (*s*[*i*]) 乘以乘数 *a*，然后计算该积除以 *m* 的余数，并将其作为新的种子值 (*s*[*i*+1])。模运算（mod）给出余数，幸运的是，Piet
    支持该数学运算。
- en: Of course, we need to select *a* and *m*. Good values are large, but we don’t
    want to work with large integers, as they correspond to large uniform blocks in
    the program image. Linear congruential generators have been studied for decades,
    and many sets of constants have been found. We’ll use *a* = 209 and *m* = 2^(12)
    *–* 3 = 4093 because they are small values.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要选择*a*和*m*。好的值应该很大，但我们不希望处理大整数，因为它们对应于程序图像中的大均匀块。线性同余生成器已经研究了几十年，许多常数集已经被找到。我们将使用*a*
    = 209和*m* = 2^(12) *–* 3 = 4093，因为它们是较小的值。
- en: Okay, we now need a program to take an initial seed value, apply the equation,
    output the new seed value, and repeat. Piet’s stack will hold the current seed
    value. The initial seed value will be pushed onto the stack, after which we’ll
    calculate the new seed, print it, and leave it on the stack for the next pass
    through the loop. We’ll want to capture the sequence of integers, so we’ll loop
    forever and use CTRL-C to stop the program when we’ve generated all the numbers
    we care to output.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们需要一个程序来获取初始种子值，应用方程，输出新种子值，并重复此过程。Piet的栈将保存当前种子值。初始种子值将被压入栈中，然后我们将计算新种子，打印它，并将其留在栈中，供下次循环使用。我们希望捕获整数序列，因此我们将永远循环，并在生成我们所关心的所有数字后使用CTRL-C停止程序。
- en: In text, we might write the program as
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本中，我们可能将程序写成：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: where `goto loop` will be achieved by arranging a sequence of white and black
    regions to force program flow back to the top of the loop.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto loop`将通过安排一系列白色和黑色区域来实现，以迫使程序流返回到循环的顶部。'
- en: We could make an image like the program, but notice the `push(4093)`. That’s
    a rather large block by Piet standards, so let’s replace both `push(209)` and
    `push(4093)` with a set of calculations that end with the proper number on the
    stack. For example, `push(209)` is the same as
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像程序一样制作一个图像，但请注意`push(4093)`。按照Piet的标准，这个块相当大，所以让我们将`push(209)`和`push(4093)`替换为一组计算，最终在栈中得到正确的数字。例如，`push(209)`与以下代码等效：
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: and `push(4093)` is
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 而`push(4093)`是：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It’s not pretty as text, but it is easy to implement as a picture. [Figure 9-7](ch09.xhtml#ch09fig7)
    shows the resulting program (see *random.png*). The program flow is below, where
    adjacent labeled circles are connected in a clockwise direction.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 作为文本看起来不太美观，但作为图像却很容易实现。[图9-7](ch09.xhtml#ch09fig7)显示了结果程序（见*random.png*）。程序流如下，标记的相邻圆圈按顺时针方向连接。
- en: '![Image](Images/09fig07.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/09fig07.jpg)'
- en: '*Figure 9-7: Tracing* random.png'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-7：追踪* random.png'
- en: The transition from Step 0 to Step 1 pushes the initial seed (1) on the stack.
    Steps 2 through Step 24 generate the next seed value and display it as an integer.
    Steps 25 through 27 print the newline. The white region causes the program to
    flow back to Step 2 to generate the next seed. The loop runs until we press CTRL-C
    to quit the interpreter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从步骤0到步骤1的过渡将初始种子（1）压入栈中。步骤2到步骤24生成下一个种子值并将其作为整数显示。步骤25到步骤27打印换行符。白色区域使程序流回到步骤2以生成下一个种子。该循环会一直运行，直到我们按下CTRL-C退出解释器。
- en: Let’s run *random.png* and capture the output so we can analyze it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行*random.png*并捕获输出，以便我们可以分析它。
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let the code run for 10 to 20 seconds and then stop it with CTRL-C. My run produced
    2,333,347 values, which is quite sufficient for our purposes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让代码运行10到20秒钟，然后使用CTRL-C停止它。我的运行产生了2,333,347个值，这对我们的目的来说已经足够。
- en: 'The sequence begins with the following numbers:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 序列以以下数字开始：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This seems “random,” but how can we know? Of course, we know the sequence cannot
    possibly be random, as it was generated deterministically. However, suppose we
    didn’t know that. In that case, we could perform tests to help us decide if the
    sequence is or isn’t worth calling “random.” The entire point of developing high-quality
    pseudorandom number generators is to create deterministic sequences that pass
    all known randomness tests.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来“随机”，但我们怎么知道呢？当然，我们知道这个序列不可能是随机的，因为它是确定性生成的。然而，假设我们不知道这一点。那时，我们可以执行测试来帮助我们决定这个序列是否值得称为“随机”。开发高质量伪随机数生成器的整个目的，就是为了创造通过所有已知随机性测试的确定性序列。
- en: Before we can apply randomness tests, we must convert the text file of integers
    into a binary file of double-precision floating-point numbers in the range [0,1),
    meaning from 0 up to, but not including, 1\. For that, we’ll use *random_double.py*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用随机性测试之前，我们必须将整数的文本文件转换为双精度浮点数的二进制文件，范围为[0,1)，即从0到（但不包括）1。为此，我们将使用*random_double.py*。
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, *random_double.py* produces *random.dat* from *random.txt* by dividing
    each value by 4,093, which is one more than the largest possible integer the generator
    outputs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*random_double.py* 通过将 *random.txt* 中的每个值除以 4093 来生成 *random.dat*，4093 是生成器输出的最大整数加一。
- en: One way to check for randomness is to build a *histogram*. A histogram partitions
    the range of possible integers—in this case, [1,4092]—into several equal-sized
    bins, say 10\. Then we locate the bin each number falls into and increment the
    count for the bin. When all the random values have been tallied, the histogram
    shows us how many have fallen into each bin. If we divide the count per bin by
    the number of values tallied, which in this case is 2,333,347, the counts become
    frequencies telling us the fraction of numbers we can expect in each bin. If we
    want, we can interpret the frequencies as the probability a random value will
    land in that bin.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 检查随机性的一个方法是构建一个 *直方图*。直方图将可能的整数范围——在这个例子中是 [1,4092]——划分为若干个相等大小的桶，假设是 10 个。然后我们找出每个数字所在的桶，并增加该桶的计数。当所有随机值都统计完成后，直方图会显示每个桶中落入的数字个数。如果我们将每个桶的计数除以统计的总值数量，在这个例子中是
    2,333,347，计数就变成了频率，告诉我们每个桶中可能落入的数字比例。如果我们愿意，也可以将频率解释为一个随机值落入该桶的概率。
- en: If the values are randomly distributed, each bin is equally likely, so we expect
    the fraction in each bin to be roughly the same. So, for example, if we have 10
    bins, we expect about 10 percent of the values to fall into each of them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值是随机分布的，每个桶的概率是相同的，所以我们期望每个桶中的比例大致相同。例如，如果我们有 10 个桶，我们期望每个桶大约有 10% 的值。
- en: 'To perform the tallies, we need a bit of Python code and access to the NumPy
    library. The actual code is in the file *random_histogram.py*, but you need not
    install NumPy to run it. The histogram gives us the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行统计，我们需要一些 Python 代码和对 NumPy 库的访问。实际的代码在文件 *random_histogram.py* 中，但你无需安装
    NumPy 就可以运行它。直方图给出了如下结果：
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here I’ve rounded the percentages to three decimals. The first number tells
    us the percent of samples in the range [0,0*.*1), the second the percent in [0*.*1,0*.*2),
    and so on. The percentages are virtually identical. So that’s a good sign that
    *random.png* is giving us well-distributed values.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将百分比四舍五入到三位小数。第一个数字告诉我们在区间 [0,0*.*1) 中的样本百分比，第二个数字告诉我们在 [0*.*1,0*.*2) 中的百分比，依此类推。这些百分比几乎相同。所以这是
    *random.png* 给我们提供了良好分布值的一个好兆头。
- en: Does that mean *random.png* is a good pseudorandom number generator? Not quite.
    If *random.png* were generating 1, 2, 3, 4, and so on modulo 4093, we’d still
    get the histogram above with enough samples. To be a good pseudorandom generator,
    the *i*th value and the *i* + 1th value must not be correlated. In other words,
    there should be no easy way to predict the next value generated from the previous.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着 *random.png* 是一个好的伪随机数生成器？并不完全是。如果 *random.png* 生成的是 1, 2, 3, 4 等依次递增的数值并对
    4093 取模，我们仍然会得到上面的直方图，只要样本足够多。要成为一个好的伪随机生成器，*i* 第i个值和 *i* + 1 第i+1个值之间不能相关。换句话说，不能有简单的方法通过前一个值来预测下一个值。
- en: To check if there is a correlation between one value and the next, we can use
    the code in *corr_test.c*. This program reads *random.dat* and calculates the
    *correlation coefficient*, a single number. If the values are not correlated one
    to the next, the correlation coefficient will be very close to 0 to indicate there
    is no relationship between them.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查一个值和下一个值之间是否存在相关性，我们可以使用 *corr_test.c* 中的代码。该程序读取 *random.dat* 并计算 *相关系数*，这是一个单一的数字。如果值之间没有相关性，相关系数将非常接近
    0，表明它们之间没有关系。
- en: 'Compile *corr_test.c* using the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令编译 *corr_test.c*：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then run it on *random.dat*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后对 *random.dat* 执行它。
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `3` in the command line tells `corr_test` that *random.dat* is a binary
    file of double precision floating-point values.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行中的 `3` 告诉 `corr_test`，*random.dat* 是一个双精度浮点值的二进制文件。
- en: The output has the word `PASSED` in it, in all caps to boot. So *corr_test*
    believes *random.dat* is not correlated. The correlation coefficient is close
    to 0\. The `CI` part of the output is a *confidence interval*. We can read the
    confidence interval as meaning there’s a 95 percent chance the true correlation
    coefficient is between the given limits. Notice that the range includes 0, another
    good sign.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中包含 `PASSED` 这个单词，而且是全大写的。所以 *corr_test* 认为 *random.dat* 没有关联。相关系数接近 0。输出中的
    `CI` 部分是一个 *置信区间*。我们可以将置信区间理解为，真实的相关系数有 95% 的概率落在给定的区间范围内。注意该区间包括了 0，这是另一个好兆头。
- en: Therefore, *random.png* is a good pseudorandom generator, right? Still, not
    quite. We only checked for correlations between one value and the next. There
    might be correlations between a value and some other, later value. You begin to
    see the issue with testing pseudorandom generators. Real generators are tested
    against large test suites that include many different kinds of tests, all of which
    only the best pseudorandom generators pass.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，*random.png* 是一个不错的伪随机生成器，对吧？不过，实际上并非如此。我们只检查了一个值和下一个值之间的相关性。可能还存在一个值与其他后续值之间的相关性。这就开始暴露出测试伪随机生成器的问题了。真正的生成器会经过大型测试套件的检验，包含多种不同类型的测试，只有最好的伪随机生成器能通过这些测试。
- en: We’ll do one more straightforward test of the output in *random.dat*. Let’s
    take successive pairs of values and plot them as a point. Then, we’ll look at
    the resulting plot to see if any pattern jumps out at us. For example, the first
    two values in *random.dat* are 0.05106279 and 0.67212314\. So we’ll plot a point
    at (0.05106279, 0.67212314), then do the same for the next pair. We’ll stop after
    plotting 1,000 points to avoid cluttering the plot.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对*random.dat*的输出进行一次简单的测试。让我们取连续的值对并将其作为一个点绘制出来。然后，我们将查看结果图，看看是否有任何模式突出显示。例如，*random.dat*中的前两个值是0.05106279和0.67212314。因此，我们将在(0.05106279,
    0.67212314)处绘制一个点，然后对下一个值对执行相同操作。我们将在绘制1000个点后停止，以避免图形过于混乱。
- en: Take a look at [Figure 9-8](ch09.xhtml#ch09fig8). Does anything jump out at
    you?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 看看[图9-8](ch09.xhtml#ch09fig8)。有什么引起你的注意吗？
- en: '![Image](Images/09fig08.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/09fig08.jpg)'
- en: '*Figure 9-8: Plotting pairs of pseudorandom values*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-8：绘制伪随机值对*'
- en: 'The points often lie along a diagonal from upper left to lower right. This
    is a strong indication of longer-range correlations in the sequence. At last we
    can now make a statement about the output of *random.dat*: it’s a lousy pseudorandom
    generator. However, it does fill the space. There are no obvious regions in [Figure
    9-8](ch09.xhtml#ch09fig8) where there are no points. So the output of *random.png*
    is sufficient for a simple video game, but don’t make policy decisions related
    to climate change based on simulations using it.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些点通常沿着从左上角到右下角的对角线排列。这是序列中较长距离相关性的强烈迹象。最终我们现在可以对*random.dat*的输出做出结论：它是一个糟糕的伪随机生成器。然而，它确实填充了空间。在[图9-8](ch09.xhtml#ch09fig8)中，没有明显的区域没有点。因此，*random.png*
    的输出对于简单的视频游戏足够了，但不要基于它进行关于气候变化的政策决策。
- en: Pseudorandom number generation will show up again later in the book. For now,
    let’s return to Piet’s artistic roots and create a small tribute to Piet Mondrian.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 伪随机数生成将在本书后续再次出现。现在，让我们回到皮特的艺术根源，并为皮特·蒙德里安创作一幅小小的致敬作品。
- en: '**A Tribute to Piet Mondrian**'
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**致敬皮特·蒙德里安**'
- en: Piet Mondrian was an important member of a group of Dutch artists and architects
    who developed what has come to be known as the *De Stijl* movement. De Stijl,
    literally “the style,” uses abstract forms with basic elements. One of Mondrian’s
    most widely recognized works is his unexpectedly satisfying *Composition II in
    Red, Blue, and Yellow*. The painting is an excellent example of the De Stijl movement.
    As a tribute to Mondrian, let’s make an executable copy of *Composition II*. In
    the process, we’ll learn how to use `npiet`’s editor, `npietedit`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 皮特·蒙德里安是荷兰艺术家和建筑师群体中的重要成员，他们发展了被称为*De Stijl*（风格）运动的艺术风格。De Stijl字面意思是“风格”，它使用基本元素的抽象形式。蒙德里安最广为人知的作品之一就是他意外地令人满意的*《红、蓝、黄的构成
    II》*。这幅画是De Stijl运动的一个出色例子。为了向蒙德里安致敬，我们将制作一个*《红、蓝、黄的构成 II》*的可执行版本。在这个过程中，我们将学习如何使用`npiet`的编辑器`npietedit`。
- en: Duplicating the original painting with a modern graphics program is straightforward.
    [Figure 9-9](ch09.xhtml#ch09fig9) shows the result.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现代图形程序复制原始画作是非常简单的。[图9-9](ch09.xhtml#ch09fig9)显示了结果。
- en: '![Image](Images/09fig09.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/09fig09.jpg)'
- en: '*Figure 9-9: A re-creation of Mondrian’s* Composition II'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-9：再现蒙德里安的*《红、蓝、黄的构成 II》'
- en: The largest block is red, the smaller block on the left is blue, and the smallest
    block on the right is yellow. The remainder of the painting is black and white.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的块是红色的，左边较小的块是蓝色的，而右边最小的块是黄色的。其余部分是黑白相间的。
- en: The original painting is signed on the lower left with *P M 30* for Piet Mondrian,
    1930\. We’ll make the copy executable by embedding a simple program to output
    `PM30` in place of the signature. The code that we need isn’t particularly challenging,
    but it is helpful as an exercise in learning to use `npietedit`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 原始画作的左下角签名为*P M 30*，代表皮特·蒙德里安，1930年。我们将通过嵌入一个简单的程序来输出`PM30`，替代签名，使得这幅画可以执行。我们所需的代码并不复杂，但作为学习使用`npietedit`的练习，它是很有帮助的。
- en: One of the immediate challenges in writing code for Piet is working with colors
    and transitions to get the desired commands. Although we might work with pencil
    and paper, counting from color to new color to get the correct number of hue and
    lightness changes to cause the desired command to execute, we need not be so primitive.
    Instead, the clever `npietedit` program lets us color the program image as needed
    while also calculating the proper color transitions.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 编写Piet代码时，立即面临的一个挑战是如何与颜色和过渡打交道，以得到期望的指令。尽管我们可以使用铅笔和纸，通过从一种颜色过渡到另一种颜色来计算正确的色调和亮度变化，从而触发期望的指令，但我们不必如此原始。相反，巧妙的`npietedit`程序允许我们在需要时对程序图像进行着色，同时计算出适当的颜色过渡。
- en: To output `PM30`, we need to push the ASCII values for each character on the
    stack before calling `outC`. We’ll add a final newline as well to put `PM30` on
    its own line. Therefore, we need a program to output five characters. However,
    we must embed the program in the larger *Composition II* image in a way that isn’t
    too conspicuous. Fortunately for us, the way Piet runs and the structure of *Composition
    II* match nicely. For example, Piet begins in the upper leftmost pixel of the
    image with the DP to the right and CC to the left. As that portion of the image
    is white, Piet will run across to the first black pixel, the beginning of the
    large vertical black bar. We’ll embed our code in this bar, knowing Piet will
    find it. Additionally, we’ll orient the program vertically, with DP moving down.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要输出`PM30`，我们需要在调用`outC`之前将每个字符的ASCII值推入栈中。我们还需要添加一个最终的换行符，以便将`PM30`输出到自己的行上。因此，我们需要一个程序来输出五个字符。然而，我们必须以不显眼的方式将程序嵌入到更大的*Composition
    II*图像中。幸运的是，Piet的运行方式和*Composition II*的结构非常契合。例如，Piet从图像的左上角开始，数据指针（DP）向右，控制指针（CC）向左。由于这一部分图像是白色的，Piet将沿着图像向右移动，直到碰到第一个黑色像素，也就是大垂直黑条的起点。我们将在这个黑条中嵌入我们的代码，因为我们知道Piet会找到它。另外，我们将程序的方向设置为垂直，数据指针（DP）向下移动。
- en: Of course, we must have a program to embed, so let’s use `npietedit` to create
    it. Launch `npietedit` with no arguments.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们必须有一个程序来嵌入，因此让我们使用`npietedit`来创建它。启动`npietedit`，不带任何参数。
- en: '[PRE18]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The interface is in [Figure 9-10](ch09.xhtml#ch09fig10).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 界面如[图9-10](ch09.xhtml#ch09fig10)所示。
- en: '![Image](Images/09fig10.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/09fig10.jpg)'
- en: '*Figure 9-10: The* npietedit *editor*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-10：* npietedit *编辑器*'
- en: The interface consists of a color selector, a command selector, and a drawing
    area showing individual pixels. Select a color and click in the drawing area to
    set that pixel. The command selector is the most valuable part of the editor.
    For example, to push the number 5 on the stack, select any desired color, say
    light red, the top leftmost color. Then, fill in five pixels to make a block,
    say five rows tall and one column wide. Then, as DP will be to the right, select
    the topmost pixel of the block and then select **Push**. The editor, knowing the
    current color is light red, switches the color to red, one lightness level darker.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 界面由颜色选择器、命令选择器和绘图区域组成，绘图区域显示了单独的像素。选择一种颜色并点击绘图区域以设置该像素。命令选择器是编辑器中最有价值的部分。例如，要将数字5压入栈中，选择任何一种想要的颜色，比如浅红色，也就是左上角的颜色。然后，填充五个像素以形成一个块，比如五行一列的高度。然后，鉴于数据指针（DP）位于右侧，选择该块的最顶部像素，并选择**Push**。编辑器会知道当前颜色是浅红色，因此会将颜色切换为红色，亮度级别降低一级。
- en: Changing the lightness by 1 is how Piet specifies `push`, so this is the correct
    color. Click the top pixel to the immediate right of the light red block to place
    a single red pixel. Given how DP is pointed, Piet will correctly push 5 on the
    stack. In this way, it is possible to draw any sequence of commands, with a little
    practice and attention paid to selecting the proper color before clicking the
    command to arrive at the necessary hue and lightness change.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将亮度改变1，Piet指定了`push`操作，所以这是正确的颜色。点击紧挨着浅红色块右边的顶部像素，放置一个红色像素。由于数据指针（DP）指向的位置，Piet会正确地将5压入栈中。通过这种方式，只要稍加练习，并在点击命令之前注意选择合适的颜色，便能绘制出任何指令序列，达到所需的色调和亮度变化。
- en: Use the buttons at the top of the interface to control `npietedit`. They are
    largely self explanatory. However, Save and Load will not bring up the usual file
    selection dialog. Instead, they write and read a fixed filename, `npietedit-filename.ppm`.
    So, use Save to dump the drawing and then rename `npietedit-filename.ppm` to something
    else to preserve the program. Likewise, copy a saved version of a program to the
    same filename to then load it into `npietedit`. The *.ppm* file format is a portable
    pixmap image. The `npiet` interpreter will use these files as they are. Most graphics
    programs will load and display portable pixmap images as well. If you wish to
    change to another filetype, use something like `gimp` or `convert`, a command
    line tool that is part of ImageMagick (*[https://imagemagick.org/index.php](https://imagemagick.org/index.php)*).
    ImageMagick is included in the base Ubuntu installation.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用界面顶部的按钮来控制`npietedit`。它们大多数都是自解释的。然而，保存和加载不会弹出常规的文件选择对话框。相反，它们会写入和读取固定的文件名`npietedit-filename.ppm`。因此，使用保存来保存图像，然后将`npietedit-filename.ppm`重命名为其他名称以保存程序。同样，复制已保存的程序版本到同一文件名下，再加载到`npietedit`中。*.ppm*文件格式是一种可移植的位图图像格式。`npiet`解释器将直接使用这些文件。大多数图形程序也能加载并显示可移植的位图图像。如果你想更改为其他文件类型，可以使用类似`gimp`或`convert`的工具，后者是ImageMagick的一个命令行工具（*
    [https://imagemagick.org/index.php](https://imagemagick.org/index.php)*）。ImageMagick已包含在基础的Ubuntu安装中。
- en: 'Our program needs to push ASCII values on the stack and then call `outC`. The
    Forth equivalent of this is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序需要将ASCII值压入栈中，然后调用`outC`。Forth中相应的代码如下：
- en: '[PRE19]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The Forth word `emit` has the same effect as Piet’s `outC` command, and multiplication
    of smaller numbers is used to prevent large blocks of one color.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 词汇`emit`与Piet的`outC`命令效果相同，且使用较小的数字相乘可防止出现大片单一颜色块。
- en: Let’s translate the Forth code into Piet using `npietedit`. The only twist is
    that we want the code to run vertically so we can embed it in the black part of
    the larger *Composition II* image. To do this, we must rotate DP downward from
    the right. This is easily done by a white region with a 90-degree turn.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`npietedit`将Forth代码翻译成Piet。唯一的变化是我们希望代码垂直运行，这样就可以将它嵌入到较大的*Composition II*图像的黑色部分中。为此，我们必须将DP从右侧旋转到下方。这个操作可以通过一个包含90度转弯的白色区域轻松完成。
- en: The file *composition.ppm* contains the necessary Piet code as a direct translation
    of the Forth above. If you run it, you’ll see that it produces the desired output.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*composition.ppm*包含必要的Piet代码，直接翻译自上面的Forth代码。如果你运行它，将看到它生成了预期的输出。
- en: '[PRE20]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To see the code in `npietedit`, copy *composition.ppm* to *npietedit-filename.ppm*
    in the same directory as `npietedit`, launch the editor, and click **Load**. The
    result is [Figure 9-11](ch09.xhtml#ch09fig11). The code runs from top to bottom.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`npietedit`中查看代码，请将*composition.ppm*复制到与`npietedit`位于同一目录下的*npietedit-filename.ppm*中，启动编辑器并点击**加载**。结果见[图
    9-11](ch09.xhtml#ch09fig11)。代码从上到下运行。
- en: '![Image](Images/09fig11.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09fig11.jpg)'
- en: '*Figure 9-11: Code to output PM30*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-11：输出 PM30 的代码*'
- en: We’re almost finished with our tribute. All that remains is to embed *composition.ppm*
    in the redrawn *Composition II*, which is in the file *mondrian* *.png*. To do
    the embedding, I use `gimp` to load both images, select the actual image portion
    of *composition.ppm*, copy it, and paste it into *mondrian.png*, moving it over
    to the central vertical black region.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的致敬工作快完成了。剩下的就是将*composition.ppm*嵌入重新绘制的*Composition II*中，该文件为*mondrian*.png。为了进行嵌入，我使用`gimp`加载这两张图像，选择*composition.ppm*的实际图像部分，复制它，然后粘贴到*mondrian.png*中，将其移动到中央的垂直黑色区域。
- en: The Piet interpreter will pass over the white region on the upper left, so we
    need to add a single white pixel after positioning the code so that the vertical
    bar is now
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Piet 解释器将跳过左上角的白色区域，因此我们需要在定位代码后添加一个白色像素，使垂直条现在是
- en: '![Image](Images/f0266-01.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0266-01.jpg)'
- en: with arrows showing how DP changes direction to execute the code vertically.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过箭头展示 DP 如何改变方向以垂直执行代码。
- en: The resulting combined image is in *compositionII_pm30.png*. If you run it with
    `npiet`, you get the expected `PM30` output. Take a look at the image itself.
    It looks like *Composition II* with a splash of color toward the top.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的合成图像保存在*compositionII_pm30.png*中。如果使用`npiet`运行它，你将得到预期的`PM30`输出。看一下图像本身。它看起来像是*Composition
    II*，顶部有一抹色彩。
- en: '**The Piet Universe**'
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Piet 宇宙**'
- en: A successful esolang engenders a following. People use it, share it, modify
    it, build tools for it, and create websites about it. By this measure, Piet is
    successful. What follows are links to excellent Piet code examples, tools, and
    generally anything else worth noting about Piet. The list is by no means exhaustive,
    and worthy entries have doubtless been missed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一种成功的esolang能够吸引一批追随者。人们使用它，分享它，修改它，为它构建工具，创建相关网站。按照这个标准，Piet是成功的。接下来是一些优秀的Piet代码示例、工具和其他值得注意的内容的链接。这个列表并不详尽，肯定还有一些值得列出的内容被遗漏了。
- en: '***About Piet***'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***关于Piet***'
- en: Piet has generated a collection of blog posts and many online discussions. The
    short list here explores more about the language itself and includes some interesting
    (unusual) Piet experiments.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Piet已经生成了大量的博客文章和在线讨论。这里的短列表探讨了更多关于该语言的内容，并包括一些有趣的（不寻常的）Piet实验。
- en: '**Main Piet site**  The main Piet page by creator David Morgan-Mar. Start here
    to learn more about the language. (*[https://www.dangermouse.net/esoteric/piet.html](https://www.dangermouse.net/esoteric/piet.html)*)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**Piet官方网站** 由创始人David Morgan-Mar创建的Piet主页面。从这里开始，了解更多关于这门语言的信息。 (*[https://www.dangermouse.net/esoteric/piet.html](https://www.dangermouse.net/esoteric/piet.html)*)'
- en: '**Piet tutorial**  This is a nice, basic tutorial to programming in Piet and
    works well as an adjunct to what we’ve discussed in this chapter. (*[https://www.youtube.com/watch?v=4kH4T8uwHMw/](https://www.youtube.com/watch?v=4kH4T8uwHMw/)*)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**Piet教程** 这是一个很好的基础教程，适合用来学习Piet编程，并且与本章讨论的内容互为补充。 (*[https://www.youtube.com/watch?v=4kH4T8uwHMw/](https://www.youtube.com/watch?v=4kH4T8uwHMw/)*)'
- en: '**Piet in the literature**  Piet is an example in this paper about code visualization.
    Alex McLean’s dissertation is also online and similarly mentions Piet. See “Visualisation
    of live code," Electronic Visualisation and the Arts (EVA 2010), 26–30.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**Piet在文献中的应用** Piet是这篇关于代码可视化的论文中的一个示例。Alex McLean的博士论文也在线可查，并且同样提到了Piet。请参见《实时代码的可视化》，《电子可视化与艺术》（EVA
    2010），26-30页。'
- en: '**Running classic paintings as Piet programs**  This is an experiment in mixing
    Piet and classic works of art. Piet fans are nothing if not creative. (*[http://omnigatherum.ca/wp/?p=57/](http://omnigatherum.ca/wp/?p=57/)*)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**将经典画作作为Piet程序运行** 这是一个将Piet与经典艺术作品相结合的实验。Piet爱好者的创造力无穷无尽。 (*[http://omnigatherum.ca/wp/?p=57/](http://omnigatherum.ca/wp/?p=57/)*)'
- en: '**Piet meets poetry**  An experiment with Piet and poetry. The final product,
    *bark.png*, generates a haiku. (*[http://theorangeduck.com/page/making-poetry-piet/](http://theorangeduck.com/page/making-poetry-piet/)*)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**Piet与诗歌的结合** 这是一个Piet与诗歌的实验。最终产品，*bark.png*，生成了一首俳句。 (*[http://theorangeduck.com/page/making-poetry-piet/](http://theorangeduck.com/page/making-poetry-piet/)*)'
- en: '***Code***'
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: The best way to learn a language is to review examples in that language. Therefore,
    should Piet draw you further in, the examples here will help you improve your
    Piet prowess.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 学习一门语言最好的方法是回顾该语言中的例子。因此，如果Piet能吸引你深入了解，下面的例子将帮助你提升你的Piet水平。
- en: '**Main Piet examples page**  The best place for Piet examples is off the main
    Piet site. Not all of these examples work with `npiet`, but most do. The works
    of the great masters are here; check them out. (*[https://www.dangermouse.net/esoteric/piet/samples.html](https://www.dangermouse.net/esoteric/piet/samples.html)*)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**Piet示例主页面** 最好的Piet示例页面在Piet的官方网站上。并非所有的示例都能与`npiet`兼容，但大多数可以。这些是伟大大师的作品，快去看看吧。
    (*[https://www.dangermouse.net/esoteric/piet/samples.html](https://www.dangermouse.net/esoteric/piet/samples.html)*)'
- en: '**FizzBuzz**  Historically, a common programming interview question was to
    write code to generate the numbers from 1 to 100 but replace multiples of 3 with
    “Fizz,” multiples of 5 with “Buzz,” and multiples of 3 and 5 with “FizzBuzz.”
    FizzBuzz is a simple program and therefore a favorite target for esolangs. A Piet
    version of FizzBuzz is at *[http://www.toothycat.net/~sham/fizzbuzz.png](http://www.toothycat.net/~sham/fizzbuzz.png)*,
    and, should you feel like diving into far too much detail about FizzBuzz, you
    can read Tom Dalling’s blog post at *[https://www.tomdalling.com/blog/software-design/fizzbuzz-in-too-much-detail/](https://www.tomdalling.com/blog/software-design/fizzbuzz-in-too-much-detail/)*.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**FizzBuzz** 历史上，一个常见的编程面试题是写一个程序，生成1到100之间的数字，但将3的倍数替换为“Fizz”，将5的倍数替换为“Buzz”，将3和5的倍数替换为“FizzBuzz”。FizzBuzz是一个简单的程序，因此成为了esolang的常见目标。FizzBuzz的Piet版本可以在
    *[http://www.toothycat.net/~sham/fizzbuzz.png](http://www.toothycat.net/~sham/fizzbuzz.png)*
    找到。如果你想深入了解FizzBuzz，可以阅读Tom Dalling的博客文章，链接在 *[https://www.tomdalling.com/blog/software-design/fizzbuzz-in-too-much-detail/](https://www.tomdalling.com/blog/software-design/fizzbuzz-in-too-much-detail/)*。'
- en: '**Tic-tac-toe**  A fully interactive, unbeatable Piet version of tic-tac-toe
    (naughts and crosses) is worth a bit of your time. (*[https://freesoft.dev/program/9705871/](https://freesoft.dev/program/9705871/)*)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**井字棋** 一个完全互动、无敌的Piet版本井字棋（圈叉游戏）值得你花点时间体验。(* [https://freesoft.dev/program/9705871/](https://freesoft.dev/program/9705871/)
    *)'
- en: '***Implementations and Tools***'
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实现与工具***'
- en: Computer people love to build things. The description of Piet on the main page
    mentioned earlier is begging to be written up in some language or another. The
    implementations here are in many different languages, like C++, Python, Rust,
    and even Haskell. Not every implementation can run every example program, but
    most perform reasonably well.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机爱好者喜欢构建东西。前面提到的主页面上的Piet描述迫切需要用某种语言编写。这里的实现使用了多种不同的编程语言，如C++、Python、Rust，甚至Haskell。并不是每个实现都能运行所有的示例程序，但大多数的表现都相当不错。
- en: A Python interpreter, *[https://www.dangermouse.net/esoteric/piet/Piet_py.txt](https://www.dangermouse.net/esoteric/piet/Piet_py.txt)*
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Python解释器，* [https://www.dangermouse.net/esoteric/piet/Piet_py.txt](https://www.dangermouse.net/esoteric/piet/Piet_py.txt)
    *
- en: Another Python interpreter, *[https://github.com/JensBouman/Piet_interpreter/](https://github.com/JensBouman/Piet_interpreter/)*
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个Python解释器，* [https://github.com/JensBouman/Piet_interpreter/](https://github.com/JensBouman/Piet_interpreter/)
    *
- en: An interpreter in Haskell, *[https://hackage.haskell.org/package/piet-0.1/docs/Language-Piet-Interpreter.html](https://hackage.haskell.org/package/piet-0.1/docs/Language-Piet-Interpreter.html)*
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 用Haskell编写的解释器，* [https://hackage.haskell.org/package/piet-0.1/docs/Language-Piet-Interpreter.html](https://hackage.haskell.org/package/piet-0.1/docs/Language-Piet-Interpreter.html)
    *
- en: An interpreter in C++, *[https://www.matthias-ernst.eu/fpiet.html](https://www.matthias-ernst.eu/fpiet.html)*
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 用C++编写的解释器，* [https://www.matthias-ernst.eu/fpiet.html](https://www.matthias-ernst.eu/fpiet.html)
    *
- en: An interpreter in Rust, *[https://github.com/dfockler/rustpiet/](https://github.com/dfockler/rustpiet/)*
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 用Rust编写的解释器，* [https://github.com/dfockler/rustpiet/](https://github.com/dfockler/rustpiet/)
    *
- en: A browser-based interpreter and IDE in TypeScript, *[https://gitlab.hsrw.eu/thomas.richter/piet-ide/](https://gitlab.hsrw.eu/thomas.richter/piet-ide/)*
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基于浏览器的TypeScript解释器和IDE，* [https://gitlab.hsrw.eu/thomas.richter/piet-ide/](https://gitlab.hsrw.eu/thomas.richter/piet-ide/)
    *
- en: Several projects have gone the other way to produce assemblers or compilers
    from a text-based language to Piet. That is, the output is an image implementing
    the program in Piet. Again, computer people are a creative bunch.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一些项目则采用另一种方式，从文本语言生成汇编器或编译器到Piet。也就是说，输出的是一个实现Piet程序的图像。再次强调，计算机爱好者是非常富有创意的一群人。
- en: GitHub repositories devoted to Piet, *[https://github.com/topics/piet/](https://github.com/topics/piet/)*
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 专门用于Piet的GitHub仓库，* [https://github.com/topics/piet/](https://github.com/topics/piet/)
    *
- en: An assembler and compiler producing Piet code, *[https://www.toothycat.net/wiki/wiki.pl?MoonShadow/Piet/](https://www.toothycat.net/wiki/wiki.pl?MoonShadow/Piet/)*
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一个生成Piet代码的汇编器和编译器，* [https://www.toothycat.net/wiki/wiki.pl?MoonShadow/Piet/](https://www.toothycat.net/wiki/wiki.pl?MoonShadow/Piet/)
    *
- en: The PietC compiler, which produces Piet code as output, *[https://github.com/cjayross/pietc/](https://github.com/cjayross/pietc/)*
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: PietC编译器，生成Piet代码作为输出，* [https://github.com/cjayross/pietc/](https://github.com/cjayross/pietc/)
    *
- en: Another assembler generating Piet output, *[https://github.com/sl236/Piet/](https://github.com/sl236/Piet/)*
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个生成Piet输出的汇编器，* [https://github.com/sl236/Piet/](https://github.com/sl236/Piet/)
    *
- en: '**Discussion**'
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Piet is a procedural language with arbitrary-sized programs. There are no variables,
    but the stack is unlimited. So we might suspect that Piet is Turing complete.
    In fact, Piet is definitely Turing complete because a clever individual has written
    a Brainfuck (BF) interpreter in Piet and BF is known to be Turing complete as
    we’ll see next in [Chapter 10](ch10.xhtml#ch10). The BF interpreter (*[https://lutter.cc/piet/](https://lutter.cc/piet/)*)
    is worth a look, perhaps after reading [Chapter 10](ch10.xhtml#ch10). To test
    it, don’t forget to add a pipe (`|`) at the end of the BF code even if the code
    itself does not accept any input. I tried it with “Hello, world!” and `npiet`
    and it works. Don’t forget to add the `-q` command line option to suppress the
    input prompt.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Piet是一种过程式语言，支持任意大小的程序。没有变量，但堆栈是无限的。因此我们可能怀疑Piet是图灵完备的。事实上，Piet绝对是图灵完备的，因为有个聪明的人已经用Piet编写了一个Brainfuck（BF）解释器，而BF是公认的图灵完备语言，正如我们在[第10章](ch10.xhtml#ch10)中将看到的那样。BF解释器(*
    [https://lutter.cc/piet/](https://lutter.cc/piet/) *)值得一看，也许可以在阅读[第10章](ch10.xhtml#ch10)后再查看它。测试时，别忘了在BF代码的末尾添加一个管道符号(`|`)，即使代码本身不接受任何输入。我用“Hello,
    world!”和`npiet`试过，它能正常工作。别忘了加上`-q`命令行选项来抑制输入提示。
- en: Okay, Piet is a Turing complete language. What else can we say about it? Programming
    in Piet is quite a challenge, perhaps because it is so alien to standard text-based
    programming or even standard visual programming languages that ty the drag-and-drop
    of components.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，Piet 是一个图灵完备的语言。我们还能说些什么呢？编程在 Piet 中确实是一个挑战，可能是因为它与标准的基于文本的编程甚至是标准的可视化编程语言（那些使用拖放组件的语言）非常不同。
- en: I find it fascinating that loops in Piet are, literally, loops—the image structure
    itself controls the flow of the program, so a loop really does find its way back
    to the starting point. For example, the loop in *random.png* is implemented by
    a long white block along the bottom of the program image followed by a 90-degree
    turn to force DP to point in the right direction to encounter the beginning of
    the loop. Also, Piet’s flow control rules make it such that the DP will rotate
    again to the right to be pointing in the proper direction to repeat the loop endlessly,
    all without a single bit of standard syntax. In a way, Piet has no syntax, just
    flow rules; the image itself becomes the syntax. In that sense, Piet programs
    are not unique, as multiple, nearly infinite, ways to draw the required flow exist.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得很有趣的是，Piet 中的循环，字面上就是循环——图像结构本身控制着程序的流向，因此循环确实能够回到起点。例如，*random.png* 中的循环通过程序图像底部的一块长白色块实现，接着是一个
    90 度的转弯，强制 DP 指向正确的方向以遇到循环的起始点。此外，Piet 的流程控制规则使得 DP 会再次向右旋转，指向正确的方向以无限循环地重复这个循环，而这一切都不需要任何标准的语法。从某种意义上说，Piet
    没有语法，只有流规则；图像本身就是语法。从这个角度来看，Piet 程序并不独特，因为存在多种、几乎无限的方式来绘制所需的流向。
- en: Piet’s method for implying commands using hue and lightness changes, as opposed
    to assigning specific colors to the commands, is equally clever and again magnifies
    the number of possible Piet programs considerably. Even if we choose the same
    layout, sequence of blocks, and image size, we get many options simply by selecting
    a different starting color. Piet’s instruction set is small, so learning the necessary
    transitions for each command isn’t too difficult. If you experiment with Piet
    for any length of time, you’ll begin to pick up on these transitions. For example,
    changing lightness by 1 is `push`, which is a command you’ll learn quickly.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Piet 使用色调和明度变化来暗示命令，而不是为命令指定具体颜色，这种方法同样巧妙，并且再次大大增加了可能的 Piet 程序数量。即使我们选择相同的布局、代码块顺序和图像大小，仅通过选择不同的起始颜色，我们也会得到许多不同的选项。Piet
    的指令集很小，所以学习每个命令的必要转换并不难。如果你在 Piet 中进行一段时间的实验，你会开始掌握这些转换。例如，通过改变明度 1 来表示 `push`，这是一个你会很快学会的命令。
- en: It’s also interesting that Piet separates block size and commands. For example,
    if we want to execute `push(4)` and know that the next instruction is `push(3)`,
    we might make the first block 2×2 pixels, say light red, and make the second block
    three vertical pixels of red. The transition from light red to red implies `push`
    with the argument, 4, from the size of the light red block. The push command does
    not care about the size of the new block, only that it is red, one lightness level
    darker. The fact that the new block is of size 3 is useful to push 3 when transitioning
    to the next block, which must be dark red, so we combine a number with a color
    transition, thereby making the code more compact. Of course, color transitions
    are commands, so it might sometimes be necessary to use a white block to change
    color without executing a command.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的地方是，Piet 区分了块的大小和命令。例如，如果我们想执行 `push(4)` 并且知道下一个指令是 `push(3)`，我们可能会将第一个代码块做成
    2×2 像素，颜色为浅红色，然后将第二个代码块做成三垂直像素的红色块。从浅红到红的过渡暗示了带有参数 4 的 `push` 命令，参数 4 来自浅红色块的大小。`push`
    命令不关心新代码块的大小，只关心它是红色的，比之前的块暗一个明度级别。新块的大小为 3 对于推送 3 时过渡到下一个必须是深红色的块非常有用，因此我们将数字与颜色过渡结合起来，使得代码更加紧凑。当然，颜色过渡也是命令，因此有时可能需要使用白色块来更改颜色而不执行命令。
- en: In the end, Piet is a fun esolang and an excellent example of a novel way to
    think about coding. Some forethought is necessary when designing a program, as
    it isn’t easy, even with tools like `npietedit`, to suddenly add new code by moving
    an existing block to make room, but editors capable of such actions are certainly
    possible.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，Piet 是一种有趣的超语言，也是思考编码的一种新颖方式的绝佳例子。在设计程序时需要一些前瞻性思维，因为即使有像 `npietedit` 这样的工具，通过移动现有的代码块来腾出空间突然添加新代码也不是一件容易的事，但能够进行此类操作的编辑器是完全可能的。
- en: Piet is Turing complete, but extensions to the language might be of interest.
    For example, the ability to access the stack as an array adds variables. Also,
    some kind of subroutine ability would make coding easier. All of these are exercises
    for the ambitious reader.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Piet是图灵完备的，但语言的扩展可能也值得关注。例如，能够将堆栈作为数组访问便增加了变量。此外，某种子程序功能会使编程变得更容易。这些都是针对有抱负的读者的练习。
- en: '**Summary**'
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter introduced us to Piet, the language where pictures are programs.
    First, we walked through the elements of the language to understand how it works
    and how to code with colors. Next, we went finger painting and got messy learning
    how specific programs worked, step by step. This led us to a simple tribute to
    Piet Mondrian, whose style and name inspired Piet’s creation. Piet has grown in
    popularity, at least as far as esolangs go, to the point where many program examples,
    implementations, and ancillary tools are now available. We cataloged several of
    them should you wish to explore further. Then, as always, we ended the chapter
    with some thoughts on the language and its capabilities.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Piet，这是一种将图片作为程序的编程语言。首先，我们了解了语言的元素，理解了它是如何运作的，以及如何用颜色进行编程。接着，我们进行了一些手指画，边学边弄脏手，逐步了解了特定程序的工作原理。这引导我们创作了一个简单的致敬作品，向皮特·蒙德里安致敬，他的风格和名字启发了Piet的创作。Piet在至少作为恶搞语言方面已经逐渐流行，现在已经有了许多程序示例、实现和辅助工具。如果你有兴趣进一步探索，我们列出了其中的一些。然后，正如往常一样，我们以一些关于语言及其功能的思考结束了本章。
- en: Our next esolang is perhaps the best known of all. We’re simply calling it *BF*.
    If Piet is a local celebrity, BF is a superstar.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个恶搞语言或许是最著名的了。我们直接称之为*BF*。如果Piet是地方名人，那么BF就是超级明星。
