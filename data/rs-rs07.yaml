- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Macros
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 宏
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Macros are, in essence, a tool for making the compiler write code for you. You
    give the compiler a formula for generating code given some input parameters, and
    the compiler replaces every invocation of the macro with the result of running
    through the formula. You can think of macros as automatic code substitution where
    you get to define the rules for the substitution.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 宏本质上是一个让编译器为你编写代码的工具。你给编译器提供一个生成代码的公式，并且根据一些输入参数，编译器会将每次调用宏的地方替换为公式运行后的结果。你可以将宏看作是自动代码替换，规则由你定义。
- en: Rust’s macros come in many different shapes and sizes to make it easy to implement
    many different forms of code generation. The two primary types are *declarative*
    macros and *procedural* macros, and we will explore both of them in this chapter.
    We’ll also look at some of the ways macros can come in handy in your everyday
    coding and some of the pitfalls that arise with more advanced use.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的宏有许多不同的形态和大小，旨在使实现各种代码生成变得简单。两种主要类型是*声明式*宏和*程序化*宏，我们将在本章中探讨这两种类型。我们还将探讨一些宏如何在日常编码中派上用场，以及更高级使用时可能出现的一些陷阱。
- en: Programmers coming from C-based languages may be used to the unholy land of
    C and C++ where you can use `#define` to change each `true` to `false`, or to
    remove all occurrences of the `else` keyword. If that’s the case for you, you’ll
    need to disassociate macros from a feeling of doing something “bad.” Macros in
    Rust are far from the Wild West of C macros. They follow (mostly) well-defined
    rules and are fairly misuse-resistant.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 来自C语言及其衍生语言的程序员可能已经习惯了C和C++的“邪恶领域”，在这里你可以使用`#define`将每个`true`改成`false`，或者移除所有`else`关键字。如果你有这种经验，你需要将宏与做“坏事”的感觉分开。Rust中的宏远不是C语言宏的“西部荒野”。它们遵循（大部分）良好定义的规则，并且具有相当的抗滥用能力。
- en: Declarative Macros
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明式宏
- en: 'Declarative macros are those defined using the `macro_rules!` syntax, which
    lets you conveniently define function-like macros without having to resort to
    writing a dedicated crate for the purpose (as you do with procedural macros).
    Once you’ve defined a declarative macro, you can invoke it using the name of the
    macro followed by an exclamation mark. I like to think of this kind of macro as
    a sort of compiler-assisted search and replace: it does the job for many regular,
    well-structured transformation tasks, and for eliminating repetitive boilerplate.
    In your experience with Rust up until this point, most of the macros you have
    recognized as macros are likely to have been declarative macros. Note, however,
    that not all function-like macros are declarative macros; `macro_rules!` itself
    is one example of this, and `format_args!` is another. The `!` suffix merely indicates
    to the compiler that the macro invocation will be replaced with different source
    code at compile time.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式宏是使用`macro_rules!`语法定义的宏，它允许你方便地定义类似函数的宏，而不需要为此编写专门的crate（就像你做程序化宏时那样）。一旦定义了声明式宏，你可以通过宏的名称后跟感叹号来调用它。我喜欢把这种宏看作是编译器辅助的搜索和替换：它为许多常规的、结构化良好的转换任务提供了解决方案，并且能够消除重复的模板代码。在你至今为止使用Rust的经验中，你认定的大多数宏可能就是声明式宏。需要注意的是，并非所有类似函数的宏都是声明式宏；`macro_rules!`本身就是一个例子，`format_args!`也是。`!`后缀仅仅是告诉编译器宏调用将在编译时被替换成不同的源代码。
- en: It may not be immediately obvious why declarative macros are called declarative.
    After all, don’t you “declare” everything in your program? In this context, *declarative*
    refers to the fact that you don’t say how the macro’s inputs should be translated
    into the output, just that you want the output to look like A when the input is
    B. You declare that it shall be so, and the compiler figures out all the parsing
    rewiring that has to happen to make your declaration reality. This makes declarative
    macros concise and expressive, though it also has a tendency to make them rather
    cryptic since you have a limited language with which to express your declarations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么声明式宏被称为声明式宏，可能一开始并不显而易见。毕竟，你不是在程序中“声明”所有东西吗？在这里，*声明式*指的是你不需要说明宏的输入如何转换成输出，只是声明当输入是B时，你希望输出是A。你声明它应该是这样的，然后编译器会处理所有需要的解析和重排工作，把你的声明变成现实。这使得声明式宏简洁而富有表现力，尽管它也有使得宏显得相当晦涩的倾向，因为你只有一个有限的语言来表达你的声明。
- en: When to Use Them
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时使用宏
- en: Declarative macros are primarily useful when you find yourself writing the same
    code over and over, and you’d like to, well, not do that. They’re best suited
    for fairly mechanical replacements—if you’re aiming to do fancy code transformations
    or lots of code generation, procedural macros are likely a better fit.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式宏主要在你发现自己反复写相同代码时派上用场，这时你可能希望不再这样做。它们最适合做一些比较机械的替换——如果你打算做一些复杂的代码转换或大量的代码生成，过程宏可能更合适。
- en: I most frequently use declarative macros in cases where I find myself writing
    repetitive and structurally similar code, such as in tests and trait implementations.
    For tests, I often want to run the same test multiple times but with slightly
    different configurations. I might have something like what is shown in [Listing
    7-1](#listing7-1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我最常使用声明式宏的场景是当我发现自己编写重复且结构相似的代码时，比如在测试和 trait 实现中。对于测试，我通常希望多次运行相同的测试，但使用稍微不同的配置。我可能会有像[清单
    7-1](#listing7-1)中展示的那种代码。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 7-1: Repetitive testing code'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-1：重复的测试代码
- en: While this works, it’s too verbose, too repetitive, and too prone to manual
    error. With macros we can do much better, as shown in [Listing 7-2](#listing7-2).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样做是可行的，但它过于冗长、重复，而且容易出错。使用宏，我们可以做得更好，正如在[清单 7-2](#listing7-2)中展示的那样。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 7-2: Making a macro repeat for you'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-2：让宏为你重复执行
- en: This macro expands each comma-separated directive into its own module that then
    contains two tests, one that calls `test_inner` with `true`, and one with `false`.
    While the macro definition isn’t trivial, it makes adding more tests much easier.
    Each type is one line in the `test_battery!` invocation, and the macro will take
    care of generating tests for both `true` and `false` arguments. We could also
    have it generate tests for different values for `init`. We’ve now significantly
    reduced the likelihood that we’ll forget to test a particular configuration!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏将每个以逗号分隔的指令展开为一个单独的模块，每个模块包含两个测试，一个使用`test_inner`并传入`true`，另一个传入`false`。虽然宏的定义并不简单，但它使得添加更多的测试变得更加容易。每个类型都是`test_battery!`调用中的一行，宏将自动生成针对`true`和`false`参数的测试。我们还可以让它为`init`的不同值生成测试。现在，我们大大减少了忘记测试某个特定配置的可能性！
- en: The story for trait implementations is similar. If you define your own trait,
    you’ll often want to implement that trait for a number of types in the standard
    library, even if those implementations are trivial. Let’s imagine you invented
    the `Clone` trait and want to implement it for all the `Copy` types in the standard
    library. Instead of manually writing an implementation for each one, you can use
    a macro like the one in [Listing 7-3](#listing7-3).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: trait 实现的情况类似。如果你定义了自己的 trait，通常你会希望为标准库中的多个类型实现这个 trait，即使这些实现很简单。假设你发明了`Clone`
    trait，并希望为标准库中所有`Copy`类型实现它。你可以像[清单 7-3](#listing7-3)中的宏一样，使用宏而不是手动为每个类型编写实现。
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 7-3: Using a macro to implement a trait for many similar types in one
    fell swoop'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-3：使用宏一次性为多个相似类型实现一个 trait
- en: 'Here, we generate an implementation of `Clone` for each provided type whose
    body just uses `*` to `copy` out of `&self`. You may wonder why we don’t add a
    blanket implementation of `Clone for T where T: Copy`. We could do that, but a
    big reason not to is that it would force types in other crates to also use that
    same implementation of `Clone` for their own types that happen to be `Copy`. An
    experimental compiler feature called *specialization* could offer a workaround,
    but at the time of writing the stabilization of that feature is still some way
    off. So, for the time being, we’re better off enumerating the types specifically.
    This pattern also extends beyond simple forwarding implementations: for example,
    you could easily alter the code in [Listing 7-3](#listing7-3) to implement an
    `AddOne` trait to all integer types!'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们为每个提供的类型生成一个`Clone`的实现，其主体仅使用`*`从`&self`中`copy`。你可能会想，为什么我们不为`T: Copy`类型添加一个通用的`Clone`实现呢？我们可以这么做，但一个主要的原因是，这样做会迫使其他
    crate 中的类型也使用相同的`Clone`实现，尤其是那些恰好是`Copy`的类型。一个名为*特化*的实验性编译器功能可能提供一个解决方法，但在写这篇文章时，该功能的稳定化还有一段时间。因此，目前来说，我们最好具体列举类型。这个模式不仅适用于简单的转发实现：例如，你可以轻松修改[清单
    7-3](#listing7-3)中的代码，为所有整数类型实现一个`AddOne` trait！'
- en: How They Work
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它们是如何工作的
- en: Every programming language has a *grammar* that dictates how the individual
    characters that make up the source code can be turned into *tokens*. Tokens are
    the lowest-level building blocks of a language, such as numbers, punctuation characters,
    string and character literals, and identifiers; at this level, there’s no distinction
    between language keywords and variable names. For example, the text `(value +
    4)` would be represented by the five-token sequence `(`, `value`, `+`, `4`, `)`
    in Rust-like grammar. The process of turning text into tokens also provides a
    layer of abstraction between the rest of the compiler and the gnarly low-level
    details of parsing text. For example, in the token representation, there is no
    notion of whitespace, and `/*"foo"*/` and `"/*foo*/"` have distinct representations
    (the former is no token, and the latter is a string literal token with the content
    `/*foo*/`).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言都有一个*语法*，它规定了组成源代码的各个字符如何转换成*符号*。符号是语言的最低级构建块，如数字、标点符号、字符串和字符字面量、标识符等；在这一层级，语言关键字和变量名之间没有区别。例如，文本`(value
    + 4)`在类似Rust的语法中会被表示为五个符号序列`(`、`value`、`+`、`4`、`)`。将文本转换成符号的过程还为编译器的其余部分与解析文本的复杂低级细节之间提供了一层抽象。例如，在符号表示中没有空白字符的概念，`/*"foo"*/`和`"/*foo*/"`有不同的表示（前者不是符号，后者是一个字符串字面量符号，内容为`/*foo*/`）。
- en: Once the source code has been turned into a sequence of tokens, the compiler
    walks that sequence and assigns syntactic meaning to the tokens. For example,
    `()`-delimited tokens make up a group, `!` tokens denote macro invocations, and
    so on. This is the process of *parsing*, which ultimately produces an abstract
    syntax tree (AST) that describes the structure represented by the source code.
    As an example, consider the expression `let x = || 4`, which consists of the sequence
    of tokens `let` (keyword), `x` (identifier), `=` (punctuation), two instances
    of `|` (punctuation), and `4` (literal). When the compiler turns that into a syntax
    tree, it represents it as a *statement* whose *pattern* is the *identifier* `x`
    and whose right-hand *expression* is a *closure* that has an empty *argument list*
    and a *literal expression* of the *integer literal* `4` as its body. Notice how
    the syntax tree representation is much richer than the token sequence, since it
    assigns syntactic meaning to the token combinations following the language’s grammar.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦源代码被转换成符号序列，编译器会遍历该序列并为符号分配语法意义。例如，`()`定界符的符号表示一个分组，`!`符号表示宏调用，依此类推。这就是*解析*过程，它最终生成一个描述源代码结构的抽象语法树（AST）。举个例子，考虑表达式`let
    x = || 4`，它由符号序列`let`（关键字）、`x`（标识符）、`=`（标点符号）、两个`|`（标点符号）和`4`（字面量）组成。当编译器将其转换成语法树时，它表示为一个*语句*，其中*模式*是*标识符*`x`，其右侧的*表达式*是一个*闭包*，该闭包有一个空的*参数列表*，并且其主体是*整数字面量*`4`的*字面量表达式*。请注意，语法树表示比符号序列更加丰富，因为它为符号组合分配了语法意义，这符合语言的语法规则。
- en: Rust macros dictate the syntax tree that a given sequence of tokens gets turned
    into—when the compiler encounters a macro invocation during parsing, it has to
    evaluate the macro to determine the replacement tokens, which will ultimately
    become the syntax tree for the macro invocation. At this point, however, the compiler
    is still parsing the tokens and might not be in a position to evaluate a macro
    yet, since all it has done is parse the tokens of the macro definition. Instead,
    then, the compiler defers the parsing of anything contained within the delimiters
    of a macro invocation and remembers the input token sequence. When the compiler
    is ready to evaluate the indicated macro, it evaluates the macro over the token
    sequence, parses the tokens it yields, and substitutes the resulting syntax tree
    into the tree where the macro invocation was.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Rust宏决定了给定符号序列转换成的语法树——当编译器在解析过程中遇到宏调用时，它必须先求值宏，以确定替换的符号，这些符号最终将成为宏调用的语法树。然而，此时编译器仍然在解析符号，可能还没有准备好求值宏，因为它所做的仅仅是解析宏定义的符号。因此，编译器会推迟解析宏调用的定界符中的内容，并记住输入的符号序列。当编译器准备好评估指定的宏时，它会在符号序列上求值宏，解析它生成的符号，并将结果语法树替换到宏调用的位置。
- en: 'Technically, the compiler does do a little bit of parsing for the input to
    a macro. Specifically, it parses out basic things like string literals and delimited
    groups and so produces a sequence of token *trees* rather than just tokens. For
    example, the code `x - (a.b + 4)` parses as a sequence of three token trees. The
    first token tree is a single token that is the identifier `x`, the second is a
    single token that is the punctuation character `-`, and the third is a group (using
    parentheses as the delimiter), which itself consists of a sequence of five token
    trees: `a` (an identifier), `.` (punctuation), `b` (another identifier), `+` (another
    punctuation token), and `4` (a literal). This means that the input to a macro
    does not necessarily have to be valid Rust, but it must consist of code that the
    Rust compiler can parse. For example, you couldn’t write `for <- x` in Rust outside
    of a macro invocation, but inside of a macro invocation you can, as long as the
    macro produces valid syntax. On the other hand, you cannot pass `for {` to a macro
    because it doesn’t have a closing brace.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，编译器确实会为宏的输入做一些解析。具体来说，它会解析出基本的内容，如字符串字面量和分隔组，从而生成一系列令牌*树*，而不仅仅是令牌。例如，代码
    `x - (a.b + 4)` 会解析成三个令牌树的序列。第一个令牌树是单个令牌，它是标识符 `x`；第二个是单个令牌，它是标点符号 `-`；第三个是一个组（使用圆括号作为分隔符），它本身包含五个令牌树的序列：`a`（标识符）、`.`（标点符号）、`b`（另一个标识符）、`+`（另一个标点符号）、`4`（字面量）。这意味着传递给宏的输入不一定是有效的
    Rust，但必须是 Rust 编译器可以解析的代码。例如，你不能在 Rust 中写出 `for <- x`，除非它在宏调用中，但如果宏生成有效语法，则可以这么做。另一方面，你不能将
    `for {` 传递给宏，因为它没有闭合的括号。
- en: 'Declarative macros always generate valid Rust as output. You cannot have a
    macro generate, say, the first half of a function invocation or an `if` without
    the block that follows it. A declarative macro must generate an expression (basically
    anything that you can assign to a variable), a statement such as `let x = 1;`,
    an item like a trait definition or `impl` block, a type, or a `match` pattern.
    This makes Rust macros resistant to misuse: you simply cannot write a declarative
    macro that generates invalid Rust code, because the macro definition itself would
    not compile!'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式宏始终生成有效的 Rust 输出。你不能让一个宏生成，比如说，一个函数调用的一半，或者一个没有后续代码块的`if`。声明式宏必须生成一个表达式（基本上是任何你可以赋值给变量的内容），一个语句，如`let
    x = 1;`，一个项，如 trait 定义或 `impl` 块，一个类型，或一个 `match` 模式。这使得 Rust 宏不容易被滥用：你根本不能写出一个生成无效
    Rust 代码的声明式宏，因为宏定义本身无法编译！
- en: That’s really all there is to declarative macros at a high level—when the compiler
    encounters a macro invocation, it passes the tokens contained within the invocation
    delimiters to the macro, parses the resulting token stream, and replaces the macro
    invocation with the resulting AST.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是声明式宏的高级概述——当编译器遇到宏调用时，它会将调用分隔符中的令牌传递给宏，解析结果令牌流，并用生成的 AST 替换宏调用。
- en: How to Write Declarative Macros
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何编写声明式宏
- en: An exhaustive explanation of all the syntax that declarative macros support
    is outside the scope of this book. However, we’ll cover the basics as there are
    some oddities worth pointing out.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对声明式宏支持的所有语法的详尽解释超出了本书的范围。然而，我们会涵盖一些基础知识，因为有些细节值得指出。
- en: 'Declarative macros consist of two main parts: *matchers* and *transcribers*.
    A given macro can have many matchers, and each matcher has an associated transcriber.
    When the compiler finds a macro invocation, it walks the macro’s matchers from
    first to last, and when it finds a matcher that matches the tokens in the invocation,
    it substitutes the invocation by walking the tokens of the corresponding transcriber.
    [Listing 7-4](#listing7-4) shows how the different parts of a declarative macro
    rule fit together.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式宏由两个主要部分组成：*匹配器* 和 *转录器*。一个宏可以有多个匹配器，每个匹配器都有一个关联的转录器。当编译器遇到宏调用时，它会从第一个到最后一个遍历宏的匹配器，当找到一个匹配调用中令牌的匹配器时，它会通过遍历相应转录器的令牌来替换宏调用。[列表
    7-4](#listing7-4)展示了声明式宏规则的不同部分是如何配合工作的。
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 7-4: Declarative macro definition components'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-4：声明式宏定义组件
- en: Matchers
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 匹配器
- en: You can think of a macro matcher as a token tree that the compiler tries to
    twist and bend in predefined ways to match the input token tree it was given at
    the invocation site. As an example, consider a macro with the matcher `$a:ident
    + $b:expr`. That matcher will match any identifier (`:ident`) followed by a plus
    sign followed by any Rust expression (`:expr`). If the macro is invoked with `x
    + 3 * 5`, the compiler notices that the matcher matches if it sets `$a = x` and
    `$b = 3 * 5`. Even though `*` never appears in the matcher, the compiler realizes
    that `3 * 5` is a valid expression and that it can therefore be matched with `$b:expr`,
    which accepts anything that is an expression (the `:expr` part).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将宏匹配器视为一个符号树，编译器尝试以预定义的方式扭曲和弯曲它，以匹配它在调用处给定的输入符号树。举个例子，考虑一个带有匹配器`$a:ident
    + $b:expr`的宏。这个匹配器会匹配任何标识符（`:ident`）后跟一个加号，再后跟任何Rust表达式（`:expr`）。如果宏被调用时传入`x +
    3 * 5`，编译器会发现，匹配器会匹配，当它将`$a = x`和`$b = 3 * 5`时，即使`*`没有出现在匹配器中，编译器仍然意识到`3 * 5`是一个有效的表达式，因此可以用`$b:expr`进行匹配，因为`$b:expr`接受任何表达式（`:`expr`部分）。
- en: 'Matchers can get pretty hairy, but they have huge expressive power, much like
    regular expressions. For a not-too-hairy example, this matcher accepts a sequence
    (`$()`) of one or more (`+`) comma-separated (`),`) key/value pairs given in `key
    => value` format:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配器可能会变得相当复杂，但它们具有巨大的表达能力，就像正则表达式一样。举个不那么复杂的例子，这个匹配器接受一个或多个（`+`）由逗号分隔（`),`）的键/值对，格式为`key
    => value`：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And, crucially, code that invokes a macro with this matcher can give an arbitrarily
    complex expression for the key or value—the magic of matchers will make sure that
    the key and value expressions are partitioned appropriately.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，调用带有此匹配器的宏的代码可以为键或值提供任意复杂的表达式——匹配器的魔力将确保键和值表达式被适当地分割。
- en: Macro rules support a wide variety of *fragment types*; you’ve already seen
    `:ident` for identifiers and `:expr` for expressions, but there is also `:ty`
    for types and even `:tt` for any single token tree! You can find a full list of
    the fragment types in Chapter 3 of the Rust language reference ([https://doc.rust-lang.org/reference/macros-by-example.html](https://doc.rust-lang.org/reference/macros-by-example.html)).
    These, plus the mechanism for matching a pattern repeatedly (`$()`), enable you
    to match most straightforward code patterns. If, however, you find that it is
    difficult to express the pattern you want with a matcher, you may want to try
    a procedural macro instead, where you don’t need to follow the strict syntax that
    `macro_rules!` requires. We’ll look at these in more detail later in the chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 宏规则支持多种*片段类型*；你已经见过用于标识符的`:ident`和用于表达式的`:expr`，但还有用于类型的`:ty`，甚至还有适用于任何单个符号树的`:tt`！你可以在Rust语言参考的第3章中找到完整的片段类型列表（[https://doc.rust-lang.org/reference/macros-by-example.html](https://doc.rust-lang.org/reference/macros-by-example.html)）。这些片段类型，加上用于重复匹配模式的机制（`$()`），使你能够匹配大多数简单的代码模式。不过，如果你发现很难用匹配器表达你想要的模式，可能想尝试使用过程宏，在那里你不需要遵循`macro_rules!`所要求的严格语法。我们将在本章稍后更详细地讨论这些内容。
- en: Transcribers
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 转录器
- en: 'Once the compiler has matched a declarative macro matcher, it generates code
    using the matcher’s associated transcriber. The variables defined by a macro matcher
    are called *metavariables*, and the compiler substitutes any occurrence of each
    metavariable in the transcriber (like `$key` in the example in the previous section)
    with the input that matches that part of the matcher. If you have repetition in
    the matcher (like `$(),+` in that same example), you can use the same syntax in
    the transcriber and it will be repeated once for each match in the input, with
    each expansion holding the appropriate substitution for each metavariable for
    that iteration. For example, for the `$key` and `$value` matcher, we could write
    the following transcriber to generate an `insert` call into some map for each
    `$key`/`$value` pair that was matched:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译器匹配了声明性宏匹配器，它会使用匹配器的相关转录器生成代码。宏匹配器定义的变量被称为*元变量*，编译器会在转录器中替换每个元变量的任何出现（如上一节中的`$key`）为匹配该部分匹配器的输入。如果匹配器中有重复（例如，那个示例中的`$(),+`），你可以在转录器中使用相同的语法，它会对输入中的每个匹配重复一次，每次扩展都持有该迭代的适当元变量替换。例如，对于`$key`和`$value`匹配器，我们可以编写以下转录器，为每个匹配到的`$key`/`$value`对生成一次`insert`调用，将其插入到某个映射中：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that here we want a semicolon for each repetition, not just to delimit
    the repetition, so we place the semicolon inside the repetition parentheses.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里我们希望每次重复时都有一个分号，而不仅仅是用来分隔重复，因此我们将分号放在重复的括号内。
- en: Hygiene
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 卫生
- en: You may have heard that Rust macros are *hygienic*, and perhaps that being hygienic
    makes them safer or nicer to work with, without necessarily understanding what
    that means. When we say Rust macros are hygienic, we mean that a declarative macro
    (generally) cannot affect variables that aren’t explicitly passed to it. A trivial
    example is that if you declare a variable with the name `foo`, and then call a
    macro that also defines a variable named `foo`, the macro’s `foo` is by default
    not visible at the call site (the place where the macro is called from). Similarly,
    macros cannot access variables defined at the call site (even `self`) unless they
    are explicitly passed in.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过 Rust 宏是*卫生的*，也许你认为卫生性使得它们更安全或更容易使用，但可能并不完全理解这意味着什么。当我们说 Rust 宏是卫生性的，我们的意思是声明式宏（通常）不能影响那些没有显式传递给它的变量。一个简单的例子是，如果你声明一个名为`foo`的变量，然后调用一个也定义了名为`foo`的宏，那么宏的`foo`默认在调用位置（即宏被调用的地方）是不可见的。同样，除非显式传递给宏，否则宏不能访问在调用位置定义的变量（包括`self`）。
- en: You can, most of the time, think of macro identifiers as existing in their own
    namespace that is separate from that of the code they expand into. For an example,
    take a look at the code in [Listing 7-5](#listing7-5), which has a macro that
    tries (and fails) to shadow a variable at the call site.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你可以将宏标识符看作是存在于与它们扩展到的代码不同的命名空间中。例如，看看[示例 7-5](#listing7-5)中的代码，它包含一个宏，尝试（并失败）在调用位置遮蔽一个变量。
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 7-5: Macros exist in their own little universes. Mostly.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-5：宏存在于它们自己的小宇宙中。大多数情况下是这样。
- en: After the compiler expands `let_foo!(2)`, the assert looks like it should fail.
    However, the `foo` from the original code and the one generated by the macro exist
    in different universes and have no relationship to one another beyond that they
    happen to share a human-readable name. In fact, the compiler will complain that
    the `let foo` in the macro is an unused variable. This hygiene is very helpful
    in making macros easier to debug—you don’t have to worry about accidentally shadowing
    or overwriting variables in the macro caller just because you happened to choose
    the same variable names!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译器展开`let_foo!(2)`之后，断言看起来应该会失败。然而，原始代码中的`foo`和宏生成的`foo`存在于不同的宇宙中，它们之间没有任何关系，除了它们恰好共享一个人类可读的名字。事实上，编译器会抱怨宏中的`let
    foo`是一个未使用的变量。这种卫生性在调试宏时非常有帮助——你不必担心由于恰好选择了相同的变量名而在宏调用者中意外地遮蔽或覆盖变量！
- en: This hygienic separation does not apply beyond variable identifiers, however.
    Declarative macros do share a namespace for types, modules, and functions with
    the call site. This means your macro can define new functions that can be called
    in the invoking scope, add new implementations to a type defined elsewhere (and
    not passed in), introduce a new module that can then be accessed where the macro
    was invoked, and so on. This is by design—if macros could not affect the broader
    code like this, it would be much more cumbersome to use them to generate types,
    trait implementations, and functions, which is where they come in most handy.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种卫生性分离仅适用于变量标识符。声明式宏确实共享类型、模块和函数的命名空间与调用位置。这意味着你的宏可以定义新函数，并且这些函数可以在调用作用域中被调用，向其他地方（而非传入的地方）定义的类型添加新实现，引入一个新模块，在宏调用的位置可以访问该模块，等等。这是设计上的考虑——如果宏不能像这样影响更广泛的代码，那么在生成类型、特征实现和函数时使用它们就会更加繁琐，而这些正是宏最为有用的地方。
- en: The lack of hygiene for types in macros is particularly important when writing
    a macro you want to export from your crate. For the macro to truly be reusable,
    you cannot assume anything about what types will be in scope at the caller. Maybe
    the code that calls your macro has a `mod std {}` defined or has imported its
    own `Result` type. To be on the safe side, make sure you use fully specified types
    like `::core::option::Option` or `::alloc::boxed::Box`. If you specifically need
    to refer to something in the crate that defines the macro, use the special metavariable
    `$crate`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 宏中类型的非卫生性在编写你希望从 crate 中导出的宏时尤其重要。为了使宏真正可重用，你不能假设调用者作用域中会有什么类型。也许调用你宏的代码中定义了
    `mod std {}` 或导入了自己的 `Result` 类型。为了安全起见，请确保使用完全指定的类型，比如 `::core::option::Option`
    或 `::alloc::boxed::Box`。如果你特别需要引用定义宏的 crate 中的某些内容，使用特殊的元变量 `$crate`。
- en: You can choose to share identifiers between a macro and its caller if you want
    the macro to affect a specific variable in the caller’s scope. The key is to remember
    where the identifier originated, because that’s the namespace the identifier will
    be tied to. If you put `let foo = 1;` in a macro, the identifier `foo` originates
    in the macro and will never be available to the identifier namespace at the caller.
    If, on the other hand, the macro takes `$foo:ident` as an argument and then writes
    `let $foo = 1;`, when the caller invokes the macro with `!(foo)`, the identifier
    will have originated in the caller and will therefore refer to `foo` in the caller’s
    scope.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望宏影响调用者作用域中的特定变量，你可以选择在宏和调用者之间共享标识符。关键是要记住标识符的来源，因为这就是标识符将绑定到的命名空间。如果你在宏中写
    `let foo = 1;`，那么标识符 `foo` 的来源是宏，它将永远不会在调用者的标识符命名空间中可用。另一方面，如果宏接受 `$foo:ident`
    作为参数，然后写 `let $foo = 1;`，当调用者用 `!(foo)` 调用宏时，标识符将来源于调用者，因此将引用调用者作用域中的 `foo`。
- en: The identifier does not have to be quite so explicitly passed, either; any identifier
    that appears in code that originates outside the macro will refer to the identifier
    in the caller’s scope. In the example in [Listing 7-6](#listing7-6), the variable
    identifier appears in an `:expr` but nonetheless has access to the variable in
    the caller’s scope.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符不必明确传递；在宏外部源代码中出现的任何标识符都会引用调用者作用域中的标识符。在[示例 7-6](#listing7-6)中，变量标识符出现在 `:expr`
    中，但仍然可以访问调用者作用域中的变量。
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 7-6: Giving macros access to identifiers at the call site'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-6：让宏访问调用站点的标识符
- en: We could have used `= $i + 1` in the macro instead, but we could not have used
    `= x + 1` as the name `x` is not available in the macro’s definition scope.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以在宏中使用 `= $i + 1`，但不能使用 `= x + 1`，因为 `x` 这个名称在宏的定义作用域内是不可用的。
- en: 'One last note on declarative macros and scoping: unlike pretty much everything
    else in Rust, declarative macros exist in the source code only after they are
    declared. If you try to use a macro that you define further down in the file,
    this will not work! This applies globally to your project; if you declare a macro
    in one module and want to use it in another, the module you declare the macro
    in must appear earlier in the crate, not later. If `foo` and `bar` are modules
    at the root of a crate, and `foo` declares a macro that `bar` wants to use, then
    `mod foo` must appear before `mod bar` in *lib.rs*!'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 关于声明式宏和作用域的最后一点：与 Rust 中几乎所有其他内容不同，声明式宏在声明之前在源代码中是不存在的。如果你尝试在文件后面使用一个宏定义，这将不起作用！这对你的整个项目都适用；如果你在一个模块中声明了一个宏，并希望在另一个模块中使用它，那么声明宏的模块必须出现在
    crate 的前面，而不是后面。如果 `foo` 和 `bar` 是 crate 根目录下的模块，并且 `foo` 声明了一个 `bar` 想要使用的宏，那么
    `mod foo` 必须出现在 `mod bar` 之前，在 *lib.rs* 中！
- en: Procedural Macros
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过程宏
- en: You can think of a procedural macro as a combination of a parser and code generation,
    where you write the glue code in between. At a high level, with procedural macros,
    the compiler gathers the sequence of input tokens to the macro and runs your program
    to figure out what tokens to replace them with.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将过程宏看作是一个解析器和代码生成器的组合，其中你编写连接代码。在高层次上，通过过程宏，编译器收集输入给宏的标记序列，并运行你的程序来确定用什么标记替换它们。
- en: Procedural macros are so called because you define *how* to generate code given
    some input tokens rather than just writing what code gets generated. There are
    very few smarts involved on the compiler’s side—as far as it is aware, the procedural
    macro is more or less a source code preprocessor that may replace code arbitrarily.
    The requirement that your input can be parsed as a stream of Rust tokens still
    holds, but that’s about it!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 过程宏之所以如此命名，是因为你定义了*如何*根据输入的令牌生成代码，而不是仅仅编写生成的代码。编译器端几乎没有智能——在它看来，过程宏充其量是一个源代码预处理器，可能会任意替换代码。要求你的输入可以被解析为一串
    Rust 令牌仍然有效，但仅此而已！
- en: Types of Procedural Macros
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过程宏的类型
- en: 'Procedural macros come in three different flavors, each specialized to a particular
    common use case:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 过程宏有三种不同的类型，每种类型都针对特定的常见用例：
- en: Function-like macros, like the ones that `macro_rules!` generates
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似函数的宏，比如 `macro_rules!` 生成的那些
- en: Attribute macros, like `#[test]`
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性宏，比如 `#[test]`
- en: Derive macros, like `#[derive(Serialize)]`
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生宏，比如 `#[derive(Serialize)]`
- en: 'All three types use the same underlying mechanism: the compiler provides your
    macro with a sequence of tokens, and it expects you to produce a sequence of tokens
    in return that are (probably) related to the input tree. However, they differ
    in how the macro is invoked and how its output is handled. We’ll cover each one
    briefly.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种类型都使用相同的底层机制：编译器将一个令牌序列提供给你的宏，并期望你返回一个令牌序列，该序列（可能）与输入树相关。然而，它们在宏的调用方式和输出处理方式上有所不同。我们将简要介绍每一种。
- en: Function-Like Macros
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类似函数的宏
- en: 'The function-like macro is the simplest form of procedural macro. Like a declarative
    macro, it simply replaces the macro code at the call site with the code that the
    procedural macro returns. However, unlike with declarative macros, all the guard
    rails are off: these macros (like all procedural macros) are not required to be
    hygienic and will not protect you from interacting with identifiers in the surrounding
    code at the call site. Instead, your macros are expected to explicitly call out
    which identifiers should overlap with the surrounding code (using `Span::call_site`)
    and which should be treated as private to the macro (using `Span::mixed_site`,
    which we’ll discuss later).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 类似函数的宏是过程宏中最简单的形式。像声明式宏一样，它只是将宏代码替换为过程宏返回的代码。然而，与声明式宏不同的是，这些宏（像所有过程宏一样）不需要保持卫生性，并且不会保护你避免与调用站点周围代码中的标识符交互。相反，你的宏需要明确指出哪些标识符应该与周围代码重叠（使用
    `Span::call_site`），哪些应该视为宏的私有（使用 `Span::mixed_site`，我们稍后会讨论）。
- en: Attribute Macros
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 属性宏
- en: 'The attribute macro also replaces the item that the attribute is assigned to
    wholesale, but this one takes two inputs: the token tree that appears in the attribute
    (minus the attribute’s name) and the token tree of the entire item it is attached
    to, including any other attributes that item may have. Attribute macros allow
    you to easily write a procedural macro that transforms an item, such as by adding
    a prelude or epilogue to a function definition (like `#[test]` does) or by modifying
    the fields of a struct.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 属性宏也会整体替换它所附加的项目，但它需要两个输入：出现在属性中的令牌树（去掉属性名称）和整个项的令牌树，包括该项可能包含的其他属性。属性宏使你能够轻松编写一个过程宏，来转换某个项，例如通过向函数定义添加前言或尾声（就像
    `#[test]` 所做的那样），或修改结构体的字段。
- en: Derive Macros
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 派生宏
- en: The derive macro is slightly different from the other two in that it adds to,
    rather than replaces, the target of the macro. Even though this limitation may
    seem severe, derive macros were one of the original motivating factors behind
    the creation of procedural macros. Specifically, the `serde` crate needed derive
    macros to be able to implement its now-well-known `#[derive(Serialize, Deserialize)]`
    magic.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 派生宏与另外两个宏有所不同，它不是替换宏的目标，而是向宏的目标添加内容。尽管这种限制看起来可能很严苛，但派生宏是促使创建过程宏的最初动因之一。具体来说，`serde`
    crate 需要派生宏来实现它现在广为人知的 `#[derive(Serialize, Deserialize)]` 魔法。
- en: 'Derive macros are arguably the simplest of the procedural macros, since they
    have such a rigid form: you can append items only after the annotated item; you
    can’t replace the annotated item, and you cannot have the derivation take arguments.
    Derive macros do allow you to define *helper attributes*—attributes that can be
    placed inside the annotated type to give clues to the derive macro (like `#[serde(skip)]`)—but
    these function mostly like markers and are not independent macros.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 派生宏可以说是最简单的程序宏，因为它们有非常严格的格式：你只能在被注解的项后追加项；你不能替换被注解的项，也不能让派生过程接受参数。派生宏确实允许你定义*辅助属性*——这些属性可以放置在被注解的类型内部，以提供给派生宏线索（如`#[serde(skip)]`）——但这些属性主要像标记一样，不能作为独立的宏存在。
- en: The Cost of Procedural Macros
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 程序宏的成本
- en: Before we talk about when each of the different procedural macro types is appropriate,
    it’s worth discussing why you may want to think twice before you reach for a procedural
    macro—namely, increased compile time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论每种不同类型的程序宏何时适用之前，值得讨论一下为什么在使用程序宏之前你可能需要三思——也就是增加的编译时间。
- en: Procedural macros can significantly increase compile times for two main reasons.
    The first is that they tend to bring with them some pretty heavy dependencies.
    For example, the `syn` crate, which provides a parser for Rust token streams that
    makes the experience of writing procedural macros much easier, can take tens of
    seconds to compile with all features enabled. You can (and should) mitigate this
    by disabling features you do not need and compiling your procedural macros in
    debug mode rather than release mode. Code often compiles several times faster
    in debug mode, and for most procedural macros, you won’t even notice the difference
    in execution time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 程序宏可以显著增加编译时间，主要有两个原因。第一个是它们通常带来一些比较重的依赖。例如，`syn` crate，它提供了一个用于 Rust 令牌流的解析器，使得编写程序宏的体验更加轻松，但启用所有特性后，它的编译可能需要几十秒。你可以（并且应该）通过禁用不需要的特性以及在调试模式下编译程序宏，而不是在发布模式下编译，来减轻这一问题。代码在调试模式下通常编译速度是发布模式的几倍，而且对于大多数程序宏来说，你甚至不会注意到执行时间的差异。
- en: The second reason why procedural macros increase compile time is that they make
    it easy for you to generate a lot of code without realizing it. While the macro
    saves you from having to actually type the generated code, it does not save the
    compiler from having to parse, compile, and optimize it. As you use more procedural
    macros, that generated boilerplate adds up, and it can bloat your compile times.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 程序宏增加编译时间的第二个原因是，它们让你在不自觉的情况下生成大量代码。虽然宏可以让你免去实际输入生成代码的麻烦，但它并不能减轻编译器必须解析、编译和优化这些代码的负担。随着你使用更多程序宏，生成的模板代码会不断累积，这可能会导致编译时间的膨胀。
- en: That said, the actual execution time of procedural macros is rarely a factor
    in overall compile time. While the compiler has to wait for the procedural macro
    to do its thing before it can continue, in practice, most procedural macros don’t
    do any heavy computation. That said, if your procedural macro is particularly
    involved, you may end up with your compiles spending a significant chunk of execution
    time on your procedural macro code, which is worth keeping an eye out for!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，程序宏的实际执行时间在整体编译时间中很少成为一个重要因素。虽然编译器必须等待程序宏完成其操作后才能继续，但实际上，大多数程序宏不会做任何复杂的计算。尽管如此，如果你的程序宏特别复杂，编译时间可能会在程序宏代码上消耗相当大的执行时间，这一点值得关注！
- en: So You Think You Want a Macro
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所以你认为你需要一个宏
- en: 'Let’s now look at some good uses for each type of procedural macro. We’ll start
    with the easy one: derive macros.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看每种程序宏的好用场景。我们先从简单的开始：派生宏。
- en: When to Use Derive Macros
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时使用派生宏
- en: 'Derive macros are used for one thing, and one thing only: to automate the implementation
    of a trait where automation is possible. Not all traits have obvious automated
    implementations, but many do. In practice, you should consider adding a derive
    macro for a trait only if the trait is implemented often and if its implementation
    for any given type is fairly obvious. The first of these conditions may seem like
    common sense; if your trait is going to be implemented only once or twice, it’s
    probably not worth writing and maintaining a convoluted derive macro for it.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 派生宏仅用于一件事：自动化实现一个可以自动化的特征。并非所有特征都有明显的自动化实现，但很多特征是有的。实际上，只有当特征经常被实现，并且对于任何给定类型的实现非常明显时，才应考虑为该特征添加一个派生宏。第一个条件看起来像常识；如果你的特征只会实现一两次，那么编写和维护一个复杂的派生宏可能并不值得。
- en: 'The second condition may seem stranger, however: what does it mean for the
    implementation to be “obvious”? Consider a trait like `Debug`. If you were told
    what `Debug` does and were shown a type, you would probably expect an implementation
    of `Debug` to output the name of each field alongside the debug representation
    of its value. And that’s what `derive(Debug)` does. What about `Clone`? You’d
    probably expect it to just clone every field—and again, that’s what `derive(Clone)`
    does. With `derive(serde::Serialize)`, we expect it to serialize every field and
    its value, and it does just that. In general, you want the derivation of a trait
    to match the developer’s intuition for what it probably does. If there is no obvious
    derivation for a trait, or worse yet, if your derivation does not match the obvious
    implementation, then you’re probably better off not giving it a derive macro.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个条件可能看起来更奇怪：什么是“明显”的实现？考虑一个像`Debug`这样的特征。如果你知道`Debug`的作用，并且看到一个类型，你可能会期望`Debug`的实现输出每个字段的名称，以及字段值的调试表示。这正是`derive(Debug)`所做的。那`Clone`呢？你可能会期望它只克隆每个字段——同样，这正是`derive(Clone)`所做的。对于`derive(serde::Serialize)`，我们期望它序列化每个字段及其值，而它确实做到了。一般来说，你希望特征的派生能匹配开发者对于其可能作用的直觉。如果某个特征没有明显的派生方式，或者更糟的是，如果你的派生方式与明显的实现不匹配，那么你可能最好不要为它提供一个派生宏。
- en: When to Use Function-Like Macros
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时使用类似函数的宏
- en: Function-like macros are harder to give a general rule of thumb for. You might
    say you should use function-like macros when you want a function-like macro but
    can’t express it with `macro_rules!`, but that’s a fairly subjective guideline.
    You can do a lot with declarative macros if you really put your mind to it, after
    all!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类似函数的宏，很难给出一个通用的经验法则。你可能会说，当你想使用类似函数的宏，但无法通过`macro_rules!`来表达时，应该使用类似函数的宏，但这是一个相当主观的指南。毕竟，如果你真心投入，声明式宏可以做很多事情！
- en: 'There are two particularly good reasons to reach for a function-like macro:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个特别好的理由可以选择使用类似函数的宏：
- en: If you already have a declarative macro, and its definition is becoming so hairy
    that the macro is hard to maintain.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你已经有了一个声明式宏，并且它的定义变得越来越复杂，以至于宏难以维护。
- en: If you have a pure function that you need to be able to execute at compile time
    but cannot express it with `const fn`. An example of this is the `phf` crate,
    which generates a hash map or set using a perfect hash function when given a set
    of keys provided at compile time. Another is `hex-literal`, which takes a string
    of hexadecimal characters and replaces it with the corresponding bytes. In general,
    anything that does not merely transform the input at compile time but actually
    computes over it is likely to be a good candidate.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有一个纯函数，需要在编译时执行，但无法使用`const fn`来表达。一个例子是`phf` crate，它在编译时接收到一组键，并使用完美哈希函数生成一个哈希映射或集合。另一个例子是`hex-literal`，它接收一个十六进制字符的字符串，并将其替换为相应的字节。一般来说，任何不仅仅在编译时转换输入，而是对输入进行实际计算的内容，都是一个很好的候选者。
- en: I do not recommend reaching for a function-like macro just so that you can break
    hygiene within your macro. Hygiene for function-like macros is a feature that
    avoids many debugging headaches, and you should think very carefully before you
    intentionally break it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我不推荐仅仅为了打破宏的卫生规则而去使用类似函数的宏。类似函数的宏的卫生特性可以避免许多调试上的麻烦，在故意破坏它之前，你应该三思而后行。
- en: When to Use Attribute Macros
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时使用属性宏
- en: That leaves us with attribute macros. Though these are arguably the most general
    of procedural macros, they are also the hardest to know when to use. Over the
    years and time and time again, I have seen four ways in which attribute macros
    add tremendous value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们得到了属性宏。尽管这些可以说是过程宏中最通用的，但也是最难知道何时使用的。多年来，我一再看到属性宏增加了四种方式，为代码添加了巨大的价值。
- en: '**Test generation**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试生成**'
- en: 'It is very common to want to run the same test under multiple different configurations,
    or many similar tests with the same bootstrapping code. While a declarative macro
    may let you express this, your code is often easier to read and maintain if you
    have an attribute like `#[foo_test]` that introduces a setup prelude and postscript
    in each annotated test, or a repeatable attribute like `#[test_case(1)] #[test_case(2)]`
    to mark that a given test should be repeated multiple times, once with each input.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '很常见的情况是希望在多个不同配置下运行相同的测试，或者在相同引导代码下运行许多类似的测试。虽然声明性宏可以帮助您表达这一点，但如果您有类似 `#[foo_test]`
    的属性，它在每个注解测试中引入设置序言和后记，或者像 `#[test_case(1)] #[test_case(2)]` 这样的可重复属性，标记给定测试应多次重复执行，那么您的代码通常更易于阅读和维护。'
- en: '**Framework annotations**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**框架注解**'
- en: 'Libraries like `rocket` use attribute macros to augment functions and types
    with additional information that the framework then uses without the user having
    to do a lot of manual configuration. It’s so much more convenient to be able to
    write `#[get("/<name>")] fn hello(name: String)` than to have to set up a configuration
    struct with function pointers and the like. Essentially, the attributes make up
    a miniature domain-specific language (DSL) that hides a lot of boilerplate that’d
    otherwise be necessary. Similarly, the asynchronous I/O framework `tokio` lets
    you use `#[tokio::main] async fn main()` to automatically set up a runtime and
    run your asynchronous code, thereby saving you from writing the same runtime setup
    in every asynchronous application’s `main` function.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '类似 `rocket` 的库使用属性宏来增强函数和类型，使框架可以在用户无需进行大量手动配置的情况下使用这些信息。能够写 `#[get("/<name>")]
    fn hello(name: String)` 要比设置一个包含函数指针等内容的配置结构体方便得多。基本上，这些属性构成了一个小型领域特定语言（DSL），隐藏了许多必要的样板代码。类似地，异步
    I/O 框架 `tokio` 允许您使用 `#[tokio::main] async fn main()` 自动设置运行时并运行您的异步代码，从而避免在每个异步应用程序的
    `main` 函数中编写相同的运行时设置。'
- en: '**Transparent middleware**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**透明中间件**'
- en: Some libraries want to inject themselves into your application in unobtrusive
    ways to provide added value that does not change the application’s functionality.
    For example, tracing and logging libraries like `tracing` and metric collection
    libraries like `metered` allow you to transparently instrument a function by adding
    an attribute to it, and then every call to that function will run some additional
    code dictated by the library.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些库希望以不显眼的方式注入到您的应用程序中，以提供不改变应用程序功能的增值服务。例如，跟踪和日志记录库如 `tracing` 和度量收集库如 `metered`
    允许您通过向函数添加属性来透明地为其加入一些额外的代码，然后该函数的每次调用都将执行库所指定的一些附加代码。
- en: '**Type transformers**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型转换器**'
- en: 'Sometimes you want to go beyond merely deriving traits for a type and actually
    change the type’s definition in some fundamental way. In these cases, attribute
    macros are the way to go. The `pin_project` crate is a great example of this:
    its primary purpose is not to implement a particular trait but rather to ensure
    that all pinned access to fields of a given type happens according to the strict
    rules that are set forth by Rust’s `Pin` type and the `Unpin` trait (we’ll talk
    more about those types in Chapter 8). It does this by generating additional helper
    types, adding methods to the annotated type, and introducing static safety checks
    to ensure that users don’t accidentally shoot themselves in the foot. While `pin_project`
    could have been implemented with a procedural derive macro, that derived trait
    implementation would likely not have been obvious, which violates one of our rules
    for when to use procedural macros.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时，你希望不仅仅为某个类型派生特性，而是实际以某种根本的方式更改该类型的定义。在这些情况下，属性宏是解决方案。`pin_project` crate就是一个很好的例子：它的主要目的是确保所有对给定类型字段的固定访问都按照Rust的`Pin`类型和`Unpin`特性所设定的严格规则进行（我们将在第8章详细讨论这些类型）。它通过生成额外的辅助类型、向注解的类型添加方法，并引入静态安全检查，确保用户不会不小心自我陷害。虽然`pin_project`本可以通过过程派生宏来实现，但那种派生的特性实现可能并不明显，这违背了我们使用过程宏的规则之一。
- en: How Do They Work?
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它们是如何工作的？
- en: At the heart of all procedural macros is the `TokenStream` type, which can be
    iterated over to get the individual `TokenTree` items that make up that token
    stream. A `TokenTree` is either a single token—like an identifier, punctuation,
    or a literal—or another `TokenStream` enclosed in a delimiter like `()` or `{}`.
    By walking a `TokenStream`, you can parse out whatever syntax you wish as long
    as the individual tokens are valid Rust tokens. If you want to parse your input
    specifically as Rust code, you will likely want to use the `syn` crate, which
    implements a complete Rust parser and can turn a `TokenStream` into an easy-to-traverse
    Rust AST.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所有过程宏的核心是`TokenStream`类型，它可以被迭代以获取组成该令牌流的单独`TokenTree`项。一个`TokenTree`可以是单个令牌——例如标识符、标点符号或字面量——或者是另一个被定界符如`()`或`{}`括起来的`TokenStream`。通过遍历`TokenStream`，你可以解析出任何你想要的语法，只要这些单独的令牌是有效的Rust令牌。如果你想将输入专门解析为Rust代码，你可能需要使用`syn`
    crate，它实现了一个完整的Rust解析器，并可以将`TokenStream`转换为一个易于遍历的Rust AST。
- en: With most procedural macros, you want to not only parse a `TokenStream` but
    also produce Rust code to be injected into the program that invokes the procedural
    macro. There are two main ways to do so. The first is to manually construct a
    `TokenStream` and extend it one `TokenTree` at a time. The second is to use `TokenStream`’s
    implementation of `FromStr`, which lets you parse a string that contains Rust
    code into a `TokenStream` with `"".parse::<TokenStream>()`. You can also mix and
    match these; if you want to prepend some code to your macro’s input, just construct
    a `TokenStream` for the prologue, and then use the `Extend` trait to append the
    original input.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数过程宏，你不仅想要解析一个`TokenStream`，还需要生成Rust代码，将其注入到调用该过程宏的程序中。有两种主要方法可以做到这一点。第一种是手动构造一个`TokenStream`并逐一扩展每个`TokenTree`。第二种是使用`TokenStream`的`FromStr`实现，它允许你解析包含Rust代码的字符串，转换成`TokenStream`，方法是`"".parse::<TokenStream>()`。你也可以混合使用这两种方法；如果你想在宏的输入前添加一些代码，只需为前言构造一个`TokenStream`，然后使用`Extend`特性来追加原始输入。
- en: Tokens are very slightly more magical than I’ve described so far in that every
    token, and indeed every `TokenTree`, also has a *span*. Spans are how the compiler
    ties generated code back to the source code that generated it. Every token’s span
    marks where that token originated. For example, consider a (declarative) macro
    like the one in [Listing 7-7](#listing7-7), which generates a trivial `Debug`
    implementation for the provided type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌比我目前所描述的要稍微神奇一点，因为每个令牌，实际上每个`TokenTree`，也都有一个*跨度*。跨度是编译器将生成的代码与产生该代码的源代码关联的方式。每个令牌的跨度标记了该令牌的起源。例如，考虑一个（声明式）宏，如[列表
    7-7](#listing7-7)中所示，它为提供的类型生成一个简单的`Debug`实现。
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 7-7: A very simple macro for implementing `Debug`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-7：实现`Debug`的一个非常简单的宏
- en: Now let’s imagine that someone invokes this macro with `name_as_debug!(u31)`.
    Technically, the compiler error occurs inside the macro, specifically where we
    write `for $t` (the other use of `$t` can handle an invalid type). But we’d like
    the compiler to point the user at the `u31` in their code—and indeed, that’s what
    spans let us do.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设有人用`name_as_debug!(u31)`调用了这个宏。从技术上讲，编译错误发生在宏内部，特别是在我们写`for $t`的位置（`$t`的另一个用法可以处理无效的类型）。但我们希望编译器能将错误指向用户代码中的`u31`——实际上，这就是跨度所能做到的。
- en: The span of the `$t` in the generated code is the code mapped to `$t` in the
    macro invocation. That information is then carried through the compiler and associated
    with the eventual compiler error. When that compiler error is eventually printed,
    the compiler will print the error from inside the macro saying that the type `u31`
    does not exist but will highlight the `u31` argument in the macro invocation,
    since that’s the error’s associated span!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的代码中，`$t`的跨度是映射到宏调用中的`$t`的代码。然后，这些信息会被传递到编译器，并与最终的编译错误关联。当编译器最终打印出该错误时，编译器会从宏内部打印错误，提示类型`u31`不存在，但会高亮显示宏调用中的`u31`参数，因为这就是错误所关联的跨度！
- en: Spans are quite flexible, and they enable you to write procedural macros that
    can produce sophisticated error messages if you use the `compile_error!` macro.
    As its name implies, `compile_error!` causes the compiler to emit an error wherever
    it is placed with the provided string as the message. This may not seem very useful,
    until you pair it with a span. By setting the span of the `TokenTree` you generate
    for the `compile_error!` invocation to be equal to the span of some subset of
    the input, you are effectively telling the compiler to emit this compiler error
    and point the user to this part of the source. Together, these two mechanisms
    let a macro produce errors that seem to stem from the relevant part of the code,
    even though the actual compiler error is somewhere in the generated code that
    the user never even sees!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 跨度非常灵活，它们使得你能够编写过程宏，如果使用`compile_error!`宏，可以生成复杂的错误消息。顾名思义，`compile_error!`会使编译器在其所在位置发出错误，并使用提供的字符串作为错误消息。这看起来可能不太有用，直到你将它与跨度配合使用。通过将你为`compile_error!`调用生成的`TokenTree`的跨度设置为输入某些子集的跨度，你实际上是在告诉编译器发出此编译错误，并将用户指向源代码中的这一部分。结合这两种机制，宏可以生成看似源自相关代码部分的错误，即使实际的编译错误出现在生成代码中，用户甚至从未看到过这些生成的代码！
- en: The power of spans doesn’t end there; spans are also how Rust’s macro hygiene
    is implemented. When you construct an `Ident` token, you also give the span for
    that identifier, and that span dictates the scope of that identifier. If you set
    the identifier’s span to be `Span::call_site()`, the identifier is resolved where
    the macro was called from and will thus not be isolated from the surrounding scope.
    If, on the other hand, you set it to `Span::mixed_site()` then (variable) identifiers
    are resolved at the macro definition site, and so will be completely hygienic
    with respect to similarly named variables at the call site. `Span::mixed_site`
    is so called because it matches the rules around identifier hygiene for `macro_rules!`,
    which, as we discussed earlier, “mixes” identifier resolution between using the
    macro definition site for variables and using the call site for types, modules,
    and everything else.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 跨度的强大功能不止于此；跨度也是Rust宏清洁性实现的方式。当你构造一个`Ident`标记时，你还需要为该标识符提供跨度，这个跨度决定了该标识符的作用域。如果你将标识符的跨度设置为`Span::call_site()`，则该标识符会在宏调用的地方解析，从而不会与周围的作用域隔离。另一方面，如果你将其设置为`Span::mixed_site()`，则（变量）标识符会在宏定义的地方解析，因此在调用站点中与同名变量完全保持清洁。`Span::mixed_site`之所以这样命名，是因为它遵循`macro_rules!`的标识符清洁规则，正如我们之前所讨论的那样，它在变量使用宏定义站点时与使用调用站点解析类型、模块及其他内容时“混合”了标识符解析。
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we covered both declarative and procedural macros, and looked
    at when you might find each of them useful in your own code. We also took a deeper
    dive into the mechanisms that underpin each type of macro and some of the features
    and gotchas to be aware of when you write your own macros. In the next chapter,
    we’ll start our journey into asynchronous programming and the `Future` trait.
    I promise—it’s just on the next page.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们介绍了声明式宏和过程宏，并探讨了你在自己代码中可能会发现它们各自有用的时机。我们还深入探讨了支撑每种类型宏的机制，以及在编写自己宏时需要注意的一些特性和陷阱。在下一章，我们将开始我们的异步编程之旅，介绍`Future`特性。我保证——它就在下一页。
