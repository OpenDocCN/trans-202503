- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Request Forgery and Hijacking
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 请求伪造与劫持
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: When attackers execute hijacking and forgery-based attacks against servers and
    clients, they can take sensitive actions with potentially devastating outcomes.
    In this chapter, we’ll test for these vulnerabilities and learn about defenses
    an application might implement to mitigate these types of flaws.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当攻击者针对服务器和客户端执行劫持和伪造型攻击时，他们可能会采取敏感操作，造成潜在的严重后果。在本章中，我们将测试这些漏洞，并了解应用程序可能实现的防御措施，以缓解这些类型的缺陷。
- en: '*Request forgery* occurs when an attacker is able to carry out an action, ideally
    a sensitive one, on behalf of a client or server. When attackers target clients,
    they may, for example, try to force the client to transfer money to a digital
    wallet or bank account that they control. When attackers target servers, they
    may instead aim to obtain sensitive server-side data, probe for hidden or internal
    services, make internal requests to restricted networks, access cloud environment–related
    information, and more. By contrast, *hijacking* refers to the ability to steal
    another user’s session.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*请求伪造*是指攻击者能够代表客户端或服务器执行某个操作，理想情况下是一个敏感操作。当攻击者针对客户端时，他们可能会试图强制客户端将钱转移到他们控制的数字钱包或银行账户。当攻击者针对服务器时，他们可能会试图获取敏感的服务器端数据，探测隐藏或内部服务，向受限网络发起内部请求，访问与云环境相关的信息等等。相对而言，*劫持*指的是窃取另一个用户的会话。'
- en: 'In the context of GraphQL, each of these attack vectors poses a threat. We’ll
    discuss three forms that these attacks can take: cross-site request forgery (CSRF),
    server-side request forgery (SSRF), and cross-site WebSocket hijacking (CSWSH).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GraphQL 的背景下，这些攻击方式都构成威胁。我们将讨论这些攻击可能采取的三种形式：跨站请求伪造（CSRF）、服务器端请求伪造（SSRF）和跨站
    WebSocket 劫持（CSWSH）。
- en: Cross-Site Request Forgery
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨站请求伪造
- en: Often pronounced *sea-surf*, *CSRF* is a client-side attack that causes victims
    to execute unwanted actions on a website to which they are authenticated. In such
    an attack, the attacker writes code and embeds it in a website that they operate
    (or, sometimes, in a third-party site that allows them to do so). They then force
    the victim to visit that site by leveraging attacks such as social engineering.
    When the code executes in the victim’s browser, it forges and sends a request
    to the server.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通常发音为 *sea-surf*，*CSRF* 是一种客户端攻击，导致受害者在已认证的网页上执行不希望的操作。在这种攻击中，攻击者编写代码并将其嵌入到他们操作的网站中（有时也可以是允许他们这样做的第三方网站）。然后，他们通过社会工程学等攻击手段迫使受害者访问该站点。当代码在受害者的浏览器中执行时，它会伪造并向服务器发送请求。
- en: More often than not, these requests perform state-changing actions. They might
    update the email or password of an account, transfer money from one account to
    another, disable account security settings such as multifactor authentication,
    grant permissions, or even add a new account to an application. [Figure 9-1](#figure9-1)
    illustrates the typical CSRF attack flow, using a banking website as an example.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些请求往往会执行改变状态的操作。它们可能会更新账户的电子邮件或密码，从一个账户转账到另一个账户，禁用账户的安全设置，如多因素认证，授予权限，甚至向应用程序添加新账户。[图
    9-1](#figure9-1)展示了典型的 CSRF 攻击流程，以下以银行网站为例。
- en: '![](image_fi/502840c09/F09001.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c09/F09001.png)'
- en: 'Figure 9-1: The flow of a CSRF attack'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-1：CSRF 攻击流程
- en: CSRF takes advantage of the fact that, when a client is logged in to an application,
    the browser sends necessary information in every HTTP request it makes to the
    site, such as session cookies (in the `Cookie` header), and other standard headers
    like `Host` or `User-Agent`. Web servers have no way to distinguish between legitimate
    requests and those that result from a user being tricked, which is why CSRF attacks
    work well when no mitigations are in place to prevent them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF 利用这样一个事实：当客户端已登录应用程序时，浏览器在每次发出的 HTTP 请求中都会发送必要的信息，如会话 cookie（在 `Cookie`
    头中），以及 `Host` 或 `User-Agent` 等其他标准头部。Web 服务器无法区分合法请求与用户被欺骗后发出的请求，这就是为什么当没有采取防范措施时，CSRF
    攻击会非常有效的原因。
- en: Attackers use many techniques to achieve CSRF, but one common tactic relies
    on specially crafted HTML forms, created using `<form>` tags. The attacker waits
    for a user to submit a form on their website or, to increase their chances of
    success, does so automatically using JavaScript code. When a condition allows
    an attacker to perform a CSRF attack using the GET method, they might also use
    HTML tags such as `<a>` and `<img>` as vectors. These tags, which aren’t usually
    considered harmful, could provide an attacker with the option to embed CSRF payloads
    in websites that allow the insertion of image links and hyperlinks. These tags
    can make only plain GET requests, so if a website has anti-CSRF tokens in place,
    the attack probably won’t work.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者使用多种技术来实现 CSRF，但一种常见的策略依赖于使用 `<form>` 标签创建的特殊 HTML 表单。攻击者等待用户在其网站上提交表单，或者为了提高成功的几率，使用
    JavaScript 代码自动提交表单。当条件允许攻击者使用 GET 方法执行 CSRF 攻击时，他们还可能使用诸如 `<a>` 和 `<img>` 等 HTML
    标签作为载体。这些标签通常不会被认为是有害的，但它们可能为攻击者提供在允许插入图像链接和超链接的网站中嵌入 CSRF 有效载荷的选项。这些标签只能发起普通的
    GET 请求，因此如果一个网站已经设置了反 CSRF 令牌，攻击可能不会成功。
- en: Because a CSRF attack relies on the victim’s authenticated session, the attacker
    can take only those actions that the victim is allowed to perform on the website.
    For example, if a victim is logged in to a banking website but can transfer only
    $1,000 a day, a CSRF attack would be limited to transferring that dollar amount.
    Additionally, if a particular request requires administrator-level privileges
    that the client session doesn’t have, the request will fail. Chapter 7 provides
    techniques for bypassing certain GraphQL authorization controls.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 CSRF 攻击依赖于受害者的已验证会话，攻击者只能执行受害者在网站上被允许执行的操作。例如，如果受害者登录到银行网站，但每天只能转账 1,000
    美元，则 CSRF 攻击将仅限于转账这一金额。此外，如果某个请求需要管理员级别的权限，而客户端会话没有该权限，请求将会失败。第七章提供了绕过某些 GraphQL
    授权控制的技术。
- en: CSRF is at least two decades old. The first CSRF-related vulnerability with
    an assigned CVE identifier we could find, CVE-2002-1648, is from 2002, although
    some people suggest that CSRF vulnerabilities may go back as far as 2001\. When
    it comes to GraphQL, developers may use either queries or mutations to build schemas
    that support performing sensitive actions (such as changing account settings or
    transferring money from one account to another). This may allow an attacker to
    perform state-changing actions. As you’ve learned, state-changing actions are
    usually done with mutations. However, developers may choose to implement these
    using queries.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF 至少已经有二十年的历史。我们能找到的第一个与 CSRF 相关的漏洞，CVE-2002-1648，来自 2002 年，虽然有些人认为 CSRF
    漏洞可能早在 2001 年就已经存在。当谈到 GraphQL 时，开发者可以使用查询或突变来构建支持执行敏感操作（例如更改账户设置或从一个账户转账到另一个账户）的模式。这可能允许攻击者执行状态改变操作。正如你所学到的，状态改变操作通常通过突变来执行。然而，开发者可能选择通过查询来实现这些操作。
- en: Locating State-Changing Actions
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定位状态改变操作
- en: A *state-changing action* alters the application in some way. For example, changing
    DVGA’s mode from Beginner to Expert, or vice versa, is considered a state-changing
    operation. If you’re hunting for CSRF, you should target these actions. As you
    know by now, state-changing actions in GraphQL are typically performed using mutations.
    However, you can sometimes perform write operations that are state changing by
    using GraphQL queries.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*状态改变操作*以某种方式更改应用程序。例如，将 DVGA 的模式从“初学者”更改为“专家”，或反之，这被视为状态改变操作。如果你在寻找 CSRF 漏洞，你应该瞄准这些操作。正如你现在所知，GraphQL
    中的状态改变操作通常通过突变（mutations）来执行。然而，有时你也可以通过使用 GraphQL 查询来执行改变状态的写操作。'
- en: 'Let’s begin with the more likely scenario: identifying state-changing operations
    based on mutations. To find impactful CSRF vulnerabilities, try extracting the
    list of available mutations and searching for ones that give you a foothold in
    the application or allow you to escalate your existing privileges. The introspection
    query shown in [Listing 9-1](#listing9-1) should return the mutation fields that
    exist in a schema.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从更可能的场景开始：根据突变（mutations）识别状态改变操作。为了找到有影响的 CSRF 漏洞，可以尝试提取可用突变的列表，并寻找那些能够让你在应用中占据立足点或允许你提升现有权限的突变。清单
    [9-1](#listing9-1) 中显示的 introspection 查询应该返回模式中存在的突变字段。
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 9-1: Introspection query to extract mutation field names'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-1：提取突变字段名称的 introspection 查询
- en: Go ahead and run this query against DVGA by using Altair, ensuring that DVGA’s
    mode is set to Beginner. You should identify a few state-changing actions, such
    as `createUser`, `importPaste`, `editPaste`, `uploadPaste`, `deletePaste`, and
    `createPaste`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Altair 对 DVGA 执行此查询，确保 DVGA 的模式设置为初学者。你应该能够识别出一些状态变化的操作，例如 `createUser`、`importPaste`、`editPaste`、`uploadPaste`、`deletePaste`
    和 `createPaste`。
- en: In cases when you don’t notice any sensitive actions, the next thing to look
    for is whether you can use queries to perform state-changing actions. GraphQL
    servers sometimes support operations over GET, and when they do, they might intentionally
    reject GET-based mutations to allow read operations using GET only. This provides
    a degree of protection against CSRF-like vulnerabilities, as you’ll learn later
    in this chapter. However, if our target uses any GET-based queries to perform
    important state changes, that mitigation is useless. Execute the introspection
    query shown in [Listing 9-2](#listing9-2) to fetch the names of the available
    queries.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有发现任何敏感操作，接下来要查看的是是否可以使用查询来执行状态变化的操作。GraphQL 服务器有时支持通过 GET 进行操作，当它们这样做时，可能会故意拒绝基于
    GET 的突变操作，只允许通过 GET 执行读取操作。这为防止类似 CSRF 的漏洞提供了一定的保护，正如你将在本章后面学到的那样。然而，如果我们的目标使用任何基于
    GET 的查询来执行重要的状态变化，那么这个缓解措施就是无效的。执行[列表 9-2](#listing9-2)中显示的自省查询，以获取可用查询的名称。
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 9-2: Introspection query to extract query field names'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-2：提取查询字段名称的自省查询
- en: 'Here is an excerpt of the returned list:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是返回列表的一个摘录：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Does any query name stand out? The list has a few potential state-changing queries,
    but `deleteAllPastes` is particularly interesting. A query that deletes all pastes
    would fit better as a mutation than a query. However, because this application
    is vulnerable, it doesn’t take CSRF issues into consideration.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有哪个查询名称特别引人注目？列表中有几个潜在的状态变化查询，但 `deleteAllPastes` 尤为引人注意。一个删除所有粘贴的查询比查询更适合做为突变操作。然而，由于这个应用程序存在漏洞，它没有考虑到
    CSRF 问题。
- en: Testing for POST-Based Vulnerabilities
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试基于 POST 的漏洞
- en: Now that we’ve identified a few state-changing queries and mutations, we can
    attempt to craft an HTML form that exploits them. Our attack might trick a user
    into clicking a link that redirects them to a malicious website containing a form
    like the one in [Listing 9-3](#listing9-3). When submitted, it will make a POST
    request to DVGA by using the `createPaste` mutation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经识别出一些状态变化的查询和突变，可以尝试构造一个 HTML 表单来利用它们。我们的攻击可能会诱使用户点击一个链接，该链接会将他们重定向到一个恶意网站，网站上包含像[列表
    9-3](#listing9-3)中的表单。提交后，它将使用 `createPaste` 突变向 DVGA 发起一个 POST 请求。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 9-3: HTML-form POST-based CSRF exploit'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-3：基于 HTML 表单的 POST 类型 CSRF 利用
- en: 'We use the `method` attribute to define a POST-based form named `query`. This
    form will perform the request to the DVGA’s URL, defined in the `action` attribute.
    You’ll notice that we also define a hidden `<input>` tag by setting the `type`
    attribute to `hidden`. This ensures that the form used to execute the query will
    remain invisible to the victim; it won’t display in their browser. We encode and
    define the GraphQL mutation in the `value` attribute. The decoded version of the
    mutation looks like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `method` 属性定义一个名为 `query` 的 POST 类型表单。该表单将向 DVGA 的 URL 发起请求，该 URL 定义在 `action`
    属性中。你会注意到，我们还通过将 `type` 属性设置为 `hidden` 来定义一个隐藏的 `<input>` 标签。这确保了用于执行查询的表单对受害者来说是不可见的；它不会在他们的浏览器中显示。我们在
    `value` 属性中对 GraphQL 突变进行编码并定义。该突变的解码版本如下：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To observe how this form would work in an attack, download the CSRF proof-of-concept
    code from the book’s GitHub repository at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/post_csrf_submit.html](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/post_csrf_submit.html).
    Save this file to Kali’s desktop with the extension *.html*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要观察这个表单在攻击中的表现，从本书的 GitHub 仓库下载 CSRF 概念验证代码：[https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/post_csrf_submit.html](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/post_csrf_submit.html)。将此文件保存到
    Kali 的桌面，扩展名为 *.html*。
- en: Next, let’s use Burp Suite to view the outbound requests sent in a CSRF attack.
    Launch Burp Suite and open its built-in browser by clicking **Open Browser**.
    Make sure it’s currently set to not intercept requests. Then, drag and drop the
    HTML file from your desktop into the browser window. You should see the Submit
    button shown in [Figure 9-2](#figure9-2).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 Burp Suite 查看在 CSRF 攻击中发送的外部请求。启动 Burp Suite 并通过点击**打开浏览器**来打开其内置浏览器。确保当前设置为不拦截请求。然后，将桌面上的
    HTML 文件拖放到浏览器窗口中。你应该会看到[图 9-2](#figure9-2)中显示的“提交”按钮。
- en: '![](image_fi/502840c09/F09002.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c09/F09002.png)'
- en: 'Figure 9-2: A POST-based CSRF example'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2：基于 POST 的 CSRF 示例
- en: In Burp, toggle the Intercept button to **Intercept Is On**. Now, click **Submit**
    in the form and observe the resulting request in Burp’s Proxy tab. It should look
    similar to [Figure 9-3](#figure9-3).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Burp 中，切换拦截按钮到 **拦截已开启**。现在，点击表单中的 **提交** 按钮，并观察 Burp 的代理标签中产生的请求。它应该与 [图
    9-3](#figure9-3) 类似。
- en: '![](image_fi/502840c09/F09003.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c09/F09003.png)'
- en: 'Figure 9-3: The POST request sent from a victim’s browser after a CSRF attack'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-3：受害者浏览器在 CSRF 攻击后发送的 POST 请求
- en: As you can see, the mutation is encoded and sent as a single value to the `query`
    body parameter. This happens because POST-based HTML forms transform `<input>`
    tags into HTTP body parameters, and we used an input tag named `query`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，变更被编码并作为单一值发送到 `query` 请求体参数。这是因为基于 POST 的 HTML 表单将 `<input>` 标签转化为 HTTP
    请求体参数，而我们使用了一个名为 `query` 的输入标签。
- en: Because HTML forms can’t send JSON-formatted data without some help from a language
    like JavaScript, the submitted mutation isn’t sent as JSON, as indicated by the
    `Content-Type` header. Here, it is set to `application/x-www-form-urlencoded`
    rather than `application/json`. Even so, some GraphQL servers may convert the
    payload back to JSON in the backend, despite lacking the proper `Content-Type`
    header.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 HTML 表单在没有像 JavaScript 这样的语言帮助下无法发送 JSON 格式的数据，所以提交的变更并没有作为 JSON 发送，这一点可以从
    `Content-Type` 头部看出。这里，它被设置为 `application/x-www-form-urlencoded` 而不是 `application/json`。尽管如此，一些
    GraphQL 服务器可能会在后台将有效负载转换回 JSON，即使没有正确的 `Content-Type` 头部。
- en: 'When an HTML form employs the POST method, we can use one of the following
    three encoding types to encode the data: `application/x-www-form-urlencoded`,
    `multipart/form-data`, or `text/plain`. By default, when the `enctype` attribute
    isn’t set, such as in our exploit code, the form uses `application/x-www-form-urlencoded`,
    which encodes all characters before sending them to the server. Now that you’ve
    seen how the CSRF exploit triggered a GraphQL query, click **Forward** to send
    it to the server.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当 HTML 表单使用 POST 方法时，我们可以使用以下三种编码类型之一来编码数据：`application/x-www-form-urlencoded`、`multipart/form-data`
    或 `text/plain`。默认情况下，当未设置 `enctype` 属性时，例如在我们的利用代码中，表单使用 `application/x-www-form-urlencoded`，它会在发送到服务器之前对所有字符进行编码。现在你已经看到
    CSRF 利用如何触发一个 GraphQL 查询，点击 **转发** 将其发送到服务器。
- en: Automatically Submitting a CSRF Form
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动提交 CSRF 表单
- en: Enticing a user to click a button could introduce challenges. If the user hesitates
    and doesn’t go through with it, our attack fails. What if we could submit the
    form automatically, as soon as they visit the page? This is possible to do with
    JavaScript code. [Listing 9-4](#listing9-4) executes the form two seconds after
    someone visits the page.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 诱使用户点击按钮可能会带来一些挑战。如果用户犹豫不决而未继续操作，我们的攻击就会失败。假如我们能在用户访问页面后立即自动提交表单呢？这可以通过 JavaScript
    代码来实现。[列表 9-4](#listing9-4) 会在有人访问页面后两秒自动执行表单提交。
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 9-4: Automatic form submission with JavaScript'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-4：使用 JavaScript 自动提交表单
- en: The two-second delay is there to give you some time to understand what you are
    looking at. In real-world scenarios, you’ll want to forge the request on behalf
    of the victim immediately, without any delay.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这两秒的延迟是为了让你有时间理解你正在查看的内容。在实际应用中，你将希望立即代表受害者伪造请求，而无需任何延迟。
- en: To see this attack in action, download the file at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/post_csrf_submit_auto.html](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/post_csrf_submit_auto.html)
    to Kali’s desktop. Next, toggle on Burp’s intercept mode; then drag and drop the
    downloaded file into the browser. As soon as you drop it, the message `This form
    is going to submit itself in 2 seconds` should appear. Next, you should see the
    intercepted POST request in Burp. If you click Forward, you should see a response
    from the GraphQL API in the browser indicating that the mutation resulted in the
    creation of a new paste, including some metadata, like the paste’s ID, title,
    and so on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此攻击的实际效果，请下载文件 [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/post_csrf_submit_auto.html](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/post_csrf_submit_auto.html)
    到 Kali 的桌面。接下来，切换 Burp 的拦截模式；然后将下载的文件拖放到浏览器中。只要你放下它，`此表单将在 2 秒内自动提交` 的消息应该会出现。接下来，你应该能在
    Burp 中看到被拦截的 POST 请求。如果你点击转发，你应该会看到浏览器中来自 GraphQL API 的响应，表明变更导致创建了一个新的粘贴，并包括一些元数据，如粘贴的
    ID、标题等。
- en: To verify that the paste creation has indeed worked, open the DVGA user interface
    at *http://localhost:5013* and visit the Public Pastes page. You should see the
    newly created paste shown in [Figure 9-4](#figure9-4).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证粘贴创建是否成功，打开 DVGA 用户界面，访问*http://localhost:5013*，并进入公共粘贴页面。你应该能够在[图 9-4](#figure9-4)中看到新创建的粘贴。
- en: '![](image_fi/502840c09/F09004.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c09/F09004.png)'
- en: 'Figure 9-4: A paste created via a CSRF attack'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-4：通过 CSRF 攻击创建的粘贴
- en: Congratulations! You just simulated forging a paste mutation on behalf of a
    victim.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你！你刚刚成功模拟了代表受害者伪造粘贴变更操作。
- en: Testing for GET-Based Vulnerabilities
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试基于 GET 的漏洞
- en: 'Many GraphQL implementations forbid any use of GET, but sending mutations by
    using the GET method is especially taboo, because it’s considered a security risk
    that could lead to CSRF vulnerabilities, as you’ve learned. More often than not,
    GraphQL servers will reject any incoming queries that use a mutation over the
    GET method. To test whether a GraphQL server supports them, you could send a cURL
    command like this one:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 GraphQL 实现禁止使用 GET 方法，但通过 GET 方法发送变更操作（mutation）尤其被视为禁忌，因为这被认为是一个安全风险，可能导致
    CSRF 漏洞，正如你所学到的那样。通常，GraphQL 服务器会拒绝任何使用 GET 方法的变更请求。要测试一个 GraphQL 服务器是否支持它们，你可以发送如下的
    cURL 命令：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `%20` indicates spaces, `%7B` and `%7D` are the URL-encoded opening and
    closing curly brackets (`{}`) of the mutation query, and the plus sign (`+`) is
    an encoded space. When sent to DVGA, the response to this cURL command is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`%20`表示空格，`%7B`和`%7D`是变更查询的 URL 编码形式的左花括号（`{`）和右花括号（`}`），加号（`+`）表示编码后的空格。将此发送给
    DVGA 后，cURL 命令的响应如下：'
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, DVGA does not allow mutations using the GET method. However,
    in penetration tests, assume that nothing is off the table and test all hypotheses,
    because you never know when you will run into a completely custom GraphQL implementation
    that deviates from the standard.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，DVGA 不允许使用 GET 方法进行变更操作。然而，在渗透测试中，假设没有什么是不可行的，测试所有假设，因为你永远不知道何时会遇到一个完全自定义的
    GraphQL 实现，它可能偏离了标准。
- en: 'GET-based CSRF attacks are somewhat more interesting than POST-based ones because
    applications often won’t implement anti-CSRF protections on GET requests. This
    is because state-changing actions typically use other HTTP methods. If a server
    allows mutations over GET, we could exploit the HTML anchor (`<a>`) tag with the
    hypertext reference attribute (`href`) to build a hyperlink that will send the
    mutation to the server. The anchor tag executes only GET-based requests, which
    is why it isn’t a great candidate for POST-based CSRF exploitation:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 GET 的 CSRF 攻击比基于 POST 的攻击更有趣，因为应用程序通常不会在 GET 请求上实现反 CSRF 防护。这是因为状态变化的操作通常使用其他
    HTTP 方法。如果服务器允许通过 GET 方法进行变更操作，我们可以利用 HTML 锚点（`<a>`）标签和超文本引用属性（`href`）构建一个超链接，将变更操作发送到服务器。锚点标签只执行基于
    GET 的请求，这也是为什么它不适合用来进行 POST 基础的 CSRF 攻击：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Alternatively, we could use image tags (`<img>`) with the source (`src`) attribute
    to embed our mutation, like so:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用带有源（`src`）属性的图片标签（`<img>`）来嵌入我们的变更操作，像这样：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This technique works on any platform that lets you specify innocent-looking
    HTML tags such as `<a>` and `<img>`. Thus, in addition to tricking victims to
    visit an attacker-controlled website containing these links, you might be able
    to use them in legitimate websites that accept URLs and render the links on the
    client side. As a result, clients will make direct GET requests to another site
    chosen by the attacker.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术适用于任何允许你指定看起来无害的 HTML 标签（如`<a>`和`<img>`）的平台。因此，除了诱使受害者访问包含这些链接的攻击者控制的网站之外，你还可以在接受
    URL 并在客户端渲染链接的合法网站中使用它们。结果，客户端会向攻击者选择的另一个网站发出直接的 GET 请求。
- en: Although we can’t send mutations to DVGA by using the GET method, we can try
    using GET to send the state-changing query `deleteAllPastes`. As the name implies,
    the `deleteAllPastes` query will delete all pastes in the server’s database. We
    can exploit this query by using either GET or POST.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不能通过 GET 方法向 DVGA 发送变更操作，但我们可以尝试使用 GET 方法发送会改变状态的查询`deleteAllPastes`。顾名思义，`deleteAllPastes`
    查询将删除服务器数据库中的所有粘贴。我们可以通过 GET 或 POST 来利用这个查询。
- en: 'To perform such a CSRF attack, this HTML file uses `<form>` tags to submit
    the query. JavaScript code defined using the `<script>` HTML tags makes the request
    automatically, as soon as the victim loads the page:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这样的 CSRF 攻击，本文档使用`<form>`标签来提交查询。通过`<script>` HTML标签定义的 JavaScript 代码会在受害者加载页面后自动发起请求：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To test this attack, save the file at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/get_csrf_submit_auto.html](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/get_csrf_submit_auto.html)
    to your desktop as an HTML file. Make sure Burp Suite is intercepting traffic,
    and then drag and drop the HTML file into your browser window. You should see
    the outbound HTTP GET request sent after two seconds:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试此攻击，将文件 [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/get_csrf_submit_auto.html](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/get_csrf_submit_auto.html)
    保存到桌面作为 HTML 文件。确保 Burp Suite 正在拦截流量，然后将 HTML 文件拖放到浏览器窗口中。你应该能在两秒钟后看到发送的外发 HTTP
    GET 请求：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’re able to use CSRF to forge a GET-based query that deletes all pastes. Now
    let’s try using HTML tags such as `<a>` and `<img>` to trigger a GET-based CSRF.
    One way to do this is to create an HTML page that performs a GET request using
    an `<img>` tag, such as the one in [Listing 9-5](#listing9-5).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用 CSRF 来伪造一个删除所有粘贴内容的 GET 查询。现在让我们尝试使用 HTML 标签（例如 `<a>` 和 `<img>`）来触发基于
    GET 的 CSRF 攻击。做到这一点的一种方法是创建一个 HTML 页面，通过 `<img>` 标签执行 GET 请求，就像[列表 9-5](#listing9-5)中的示例一样。
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 9-5: GET-based CSRF using image tags'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-5：使用图片标签的 GET 基于 CSRF 攻击
- en: Save this as an HTML file. As before, it will execute as soon as the page loads,
    because the browser will try to fetch the URL defined using the `src` attribute
    and send a GraphQL query.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为 HTML 文件。如前所述，页面加载后它将立即执行，因为浏览器会尝试获取 `src` 属性中定义的 URL，并发送 GraphQL 查询。
- en: Using HTML Injection
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 HTML 注入
- en: A second way we could exploit GET-based CSRF is by abusing another vulnerability,
    such as *HTML injection*, which allows an attacker to inject HTML tags into a
    web page. If a victim visits the site, their browser will render the HTML code.
    In particular, if an attacker is able to inject a hyperlink using the `<a>` tag
    or an image link using the `<img>` tag, clients will initiate the GET request
    when they visit the page, following the tags’ default behavior.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过滥用另一种漏洞来利用基于 GET 的 CSRF 攻击，例如*HTML 注入*，它允许攻击者将 HTML 标签注入网页中。如果受害者访问该网站，他们的浏览器将渲染这些
    HTML 代码。特别是，如果攻击者能够使用 `<a>` 标签注入超链接或使用 `<img>` 标签注入图片链接，客户端在访问页面时会发起 GET 请求，遵循标签的默认行为。
- en: Can we trigger CSRF on DVGA using HTML injection? Let’s find out. Open Firefox,
    navigate to ***http://localhost:5013***, and go to the **Public Pastes** page.
    Next, open Developer Tools (CTRL-SHIFT-I) and go to the **Network** tab. Ensure
    that Altair is pointing to *http://localhost:5013/graphql* and enter the mutation
    in [Listing 9-6](#listing9-6), which will create a new paste with a CSRF payload
    as its content.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否通过 HTML 注入在 DVGA 上触发 CSRF 攻击？让我们来看看。打开 Firefox，导航到 ***http://localhost:5013***，并转到
    **Public Pastes** 页面。接着，打开开发者工具（CTRL-SHIFT-I），并转到 **Network** 标签。确保 Altair 指向
    *http://localhost:5013/graphql*，然后输入 [列表 9-6](#listing9-6) 中的突变代码，这将创建一个带有 CSRF
    有效负载的粘贴内容。
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 9-6: Creating a paste containing a CSRF payload'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-6：创建包含 CSRF 有效负载的粘贴内容
- en: This request injects the `<img>` tag containing the `deleteAllPastes` query
    into the Public Pastes page. To do so, it relies on the fact that DVGA fetches
    paste data by using GraphQL subscriptions (with WebSocket as the transport protocol).
    Your browser subscribes to new paste-creation events, so whenever a new paste
    is created, the subscription automatically populates the page with its title,
    content, and other information. By putting our payload in the `createPaste` `content`
    field, we effectively embed it on the page.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此请求将包含 `deleteAllPastes` 查询的 `<img>` 标签注入到公共粘贴页面中。为了做到这一点，它依赖于 DVGA 通过使用 GraphQL
    订阅（以 WebSocket 作为传输协议）来获取粘贴数据的事实。你的浏览器订阅了新的粘贴创建事件，因此每当创建新粘贴时，订阅会自动将其标题、内容和其他信息填充到页面中。通过将我们的有效负载放入
    `createPaste` 的 `content` 字段，我们有效地将其嵌入到页面中。
- en: Now, when clients send queries using `createPaste` and the `content` field,
    they will render the payload. Take a close look at what happens in your Network
    tab once you send the query. You should see the outbound GET request shown in
    [Figure 9-5](#figure9-5).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当客户端使用 `createPaste` 和 `content` 字段发送查询时，它们会渲染该有效负载。仔细观察当你发送查询后网络标签中发生的情况。你应该看到图
    [9-5](#figure9-5) 中显示的外发 GET 请求。
- en: '![](image_fi/502840c09/F09005.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c09/F09005.png)'
- en: 'Figure 9-5: A GET-based query sent through an HTML image tag containing a CSRF
    payload'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-5：通过 HTML 图片标签发送的 GET 查询，包含 CSRF 有效负载
- en: If you refresh your browser, you should no longer see any pastes, as the CSRF
    attack should have deleted them. Click **Rollback DVGA**, located in the top-right
    drop-down menu, to restore the server to its original state.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刷新浏览器，你应该不会再看到任何粘贴内容，因为 CSRF 攻击应已将其删除。点击位于右上角下拉菜单中的 **回滚 DVGA** 以恢复服务器的原始状态。
- en: We’ve discussed GET- and POST-based CSRF attacks. We’ve also discussed how some
    GraphQL servers attempt to prevent CSRF by rejecting mutations using the GET method,
    and how to test for those as well. Next, let’s use BatchQL and GraphQL Cop to
    automatically flag GraphQL servers that might be vulnerable to CSRF.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了基于 GET 和 POST 的 CSRF 攻击。我们还讨论了部分 GraphQL 服务器如何通过拒绝使用 GET 方法的变更操作来防止 CSRF
    攻击，以及如何对此进行测试。接下来，让我们使用 BatchQL 和 GraphQL Cop 自动标记可能存在 CSRF 漏洞的 GraphQL 服务器。
- en: Automating Testing with BatchQL and GraphQL Cop
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 BatchQL 和 GraphQL Cop 自动化测试
- en: 'BatchQL has multiple CSRF-related test cases. Let’s run it against DVGA to
    see what information we’re able to get about its CSRF vulnerabilities:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: BatchQL 有多个与 CSRF 相关的测试用例。让我们将其应用于 DVGA，看看我们能获得哪些关于其 CSRF 漏洞的信息：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, we used `grep` with the `-i` flag to filter out results unrelated
    to CSRF vulnerabilities. BatchQL detected that both GET and POST allow non-JSON-based
    queries.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用了带 `-i` 标志的 `grep` 来筛选出与 CSRF 漏洞无关的结果。BatchQL 检测到 GET 和 POST 都允许非 JSON
    基础的查询。
- en: 'GraphQL Cop is similar to BatchQL in the way it tests for CSRF vulnerabilities,
    except it additionally tests whether the server supports mutations over GET:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL Cop 在测试 CSRF 漏洞方面与 BatchQL 相似，只不过它额外测试服务器是否支持 GET 方法下的变更操作：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Automated tools may introduce false positives, so we recommend always manually
    verifying that their results are accurate.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化工具可能会引入误报，因此我们建议始终手动验证其结果的准确性。
- en: Preventing CSRF
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止 CSRF
- en: In the years since CSRF was discovered, browser vendors such as Mozilla and
    Google have significantly improved their CSRF mitigations. Various open source
    web server frameworks have also made CSRF vulnerabilities tremendously harder
    to exploit. This section explains the CSRF mitigations that exist today at the
    browser and server levels.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 自 CSRF 被发现以来，浏览器厂商如 Mozilla 和 Google 已大大改进了其 CSRF 缓解措施。各种开源 Web 服务器框架也使得 CSRF
    漏洞变得极难利用。本节解释了今天浏览器和服务器层面上存在的 CSRF 缓解措施。
- en: The SameSite Flag
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SameSite 标志
- en: Browsers have started supporting a special HTTP cookie attribute called `SameSite`.
    This attribute allows developers to decide whether the client browser should attach
    the cookie when making cross-site requests. To set this cookie attribute, the
    application needs to set a `Set-Cookie` response header. This interferes with
    a CSRF attack’s attempt to send a request from the attacker website (say, *attacker.com*)
    to a target website of interest (*banking.com*).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器已开始支持一种特殊的 HTTP cookie 属性，名为 `SameSite`。这个属性允许开发人员决定在进行跨站请求时，客户端浏览器是否应附带该
    cookie。要设置此 cookie 属性，应用程序需要设置一个 `Set-Cookie` 响应头。这可以阻止 CSRF 攻击从攻击者网站（如 *attacker.com*）向目标网站（如
    *banking.com*）发送请求。
- en: One challenge with using the `SameSite` attribute is that older browsers may
    not support it. However, most of the modern browsers do. Mozilla’s Developer website
    has a dedicated section about `SameSite` browser support that developers can use
    as a reference.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `SameSite` 属性的一大挑战是旧版浏览器可能不支持该属性。然而，大多数现代浏览器都支持该属性。Mozilla 的开发者网站有一个专门的板块，介绍了
    `SameSite` 在浏览器中的支持情况，开发者可以作为参考。
- en: 'The `SameSite` cookie attribute accepts three values:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`SameSite` cookie 属性接受三个值：'
- en: '`Strict` Send the cookie only when the user is browsing within the same origin'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Strict` 仅在用户浏览同一源时发送 cookie'
- en: '`Lax` Send cookies only when the request uses HTTP GET and was not initiated
    by a script, such as by top-level navigation'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lax` 仅在请求使用 HTTP GET 并且不是由脚本发起时（例如通过顶级导航）发送 cookies。'
- en: '`None` Send the cookie on cross-site requests, effectively providing no protection'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`None` 在跨站请求时发送 cookie，实际上提供了零保护。'
- en: 'GraphQL servers that set cookies with the `SameSite` attribute will return
    a `Set-Cookie` HTTP response header:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了 `SameSite` 属性的 GraphQL 服务器将返回一个 `Set-Cookie` HTTP 响应头：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When a website sets a cookie without specifying the `SameSite` attribute, modern
    browsers such as Chrome assume it is set to `Lax`. When a cookie is set with a
    value of `Strict`, the cookie won’t be sent on cross-site requests if a CSRF attack
    takes place.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当网站设置 cookie 时未指定 `SameSite` 属性时，现代浏览器（如 Chrome）会默认将其设置为 `Lax`。当 cookie 的值设置为
    `Strict` 时，如果发生 CSRF 攻击，cookie 将不会在跨站请求中发送。
- en: Anti-CSRF Tokens
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 反 CSRF 令牌
- en: To protect against CSRF vulnerabilities at the server level, web frameworks
    introduced *anti-CSRF tokens*. These are hard-to-guess, cryptographically strong,
    and unique strings generated on the server. The server expects the client to pass
    an anti-CSRF token on every request. When a server sees an incoming request without
    such a token, the server rejects that request.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在服务器级别防止 CSRF 漏洞，web 框架引入了 *反 CSRF 令牌*。这些令牌是难以猜测、加密强度高且唯一的字符串，由服务器生成。服务器期望客户端在每个请求中都传递反
    CSRF 令牌。当服务器看到没有此类令牌的请求时，会拒绝该请求。
- en: Servers can generate anti-CSRF tokens per request or once for the lifetime of
    a user session. Generating a token per request is stronger mitigation and more
    difficult to defeat because it reduces the amount of time an attacker has to obtain
    a valid token. Once a token gets invalidated, the server should no longer accept
    it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以每次请求生成反 CSRF 令牌，或者为用户会话的生命周期生成一次。每次请求生成令牌是一种更强的缓解措施，也更难以被攻破，因为它减少了攻击者获取有效令牌的时间。一旦令牌失效，服务器应该不再接受该令牌。
- en: 'Clients typically send anti-CSRF tokens to the server by using an HTTP request
    header, such as `X-CSRF-TOKEN`, or in an HTTP body parameter, such as `csrf-token`.
    Many web frameworks have built-in support for CSRF protection, allowing developers
    to build secure applications without requiring them to implement CSRF defenses
    from scratch. Here is an example HTTP request that contains an anti-CSRF token:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端通常通过 HTTP 请求头（如 `X-CSRF-TOKEN`）或 HTTP 请求体参数（如 `csrf-token`）将反 CSRF 令牌发送到服务器。许多
    web 框架内置支持 CSRF 防护，使开发者能够构建安全的应用程序，而无需从头实现 CSRF 防御。以下是一个包含反 CSRF 令牌的 HTTP 请求示例：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It’s important to remember that, just like any other security control, tokens
    can be defeated if implemented incorrectly. Here are a few ways an attacker might
    go about bypassing anti-CSRF tokens:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，像其他任何安全控制一样，如果令牌实现不当，也可能被攻破。以下是攻击者可能绕过反 CSRF 令牌的一些方式：
- en: '**Removing the CSRF token value.** Some anti-CSRF implementations may fail
    when a CSRF parameter exists but no value is set, resulting in a null value.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移除 CSRF 令牌值。** 一些反 CSRF 实现可能会在存在 CSRF 参数但未设置值的情况下失败，导致空值。'
- en: '**Removing the CSRF parameter and token value altogether.** Some anti-CSRF
    implementations may fail when the parameter is not set.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全移除 CSRF 参数和令牌值。** 一些反 CSRF 实现可能会在未设置参数时失败。'
- en: '**Reusing a CSRF token in subsequent requests.** If an attacker can capture
    one valid anti-CSRF token, such as one belonging to their own session, and the
    server doesn’t invalidate already-used tokens, it’s possible to reuse that token
    in CSRF attacks.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在后续请求中重复使用 CSRF 令牌。** 如果攻击者能够捕获一个有效的反 CSRF 令牌，例如属于他们自己会话的令牌，并且服务器没有使已经使用的令牌失效，那么该令牌可能会在
    CSRF 攻击中被重用。'
- en: '**Replacing the CSRF token with a random string of the same character length.**
    Some servers may simply look at the token value and check its length. If the length
    is equal to that of a normal token (for example, 14 characters), they may let
    the request go through.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用相同字符长度的随机字符串替换 CSRF 令牌。** 一些服务器可能只检查令牌值并验证其长度。如果长度与正常令牌的长度相等（例如，14 个字符），它们可能会允许请求通过。'
- en: '**Brute-forcing the CSRF token.** Some CSRF tokens may be cryptographically
    weak, allowing an attacker to brute-force them. For example, they might be short
    in length, use a predictable pattern, or employ a weak cryptographic algorithm.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暴力破解 CSRF 令牌。** 一些 CSRF 令牌可能在加密上较弱，允许攻击者进行暴力破解。例如，它们可能较短，使用可预测的模式，或采用较弱的加密算法。'
- en: When combined, browser- and server-level CSRF protections follow the defense-in-depth
    security principle and make CSRF harder for attackers to exploit.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器和服务器级别的 CSRF 防护结合在一起，遵循深度防御安全原则，使得 CSRF 攻击更难以被攻击者利用。
- en: Server-Side Request Forgery
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端请求伪造
- en: '*SSRF* allows an attacker to perform requests on behalf of an impacted server.
    Using SSRF, attackers could force the server to establish connections to internal
    services, often providing access to restricted network zones, internal APIs, and
    sensitive data. Web applications can introduce SSRF in many ways. Frequently,
    applications expose functionality to clients that takes input from them and uses
    it to perform a particular action. For example, consider an application that lets
    the user supply a URL to a photo they like from a specific website, such as *imgur.com*.
    The application then downloads the photo and sends it to the user over email as
    an attachment.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*SSRF*允许攻击者代表受影响的服务器执行请求。使用SSRF，攻击者可以迫使服务器建立与内部服务的连接，通常提供对受限网络区域、内部API和敏感数据的访问。Web应用程序可以通过多种方式引入SSRF。应用程序经常向客户端公开功能，让客户端提供输入，并使用它执行特定的操作。例如，考虑一个允许用户提供来自特定网站（如*imgur.com*）的照片URL的应用程序。然后，应用程序会下载照片，并将其作为附件通过电子邮件发送给用户。'
- en: 'In this example, the application expects two inputs: a URL to *imgur.com* containing
    an image, and an email address. What if an attacker supplies other inputs, such
    as a URL like *http://lab.blackhatgraphql.com/cat.png* and an email address like
    *info@blackhatgraphql.com*? If the application doesn’t validate the inputs by,
    say, ensuring that the URL’s domain is *imgur.com*, then, once the user submits
    this information, the application might instead attempt to reach the attacker-controlled
    website, download the image to disk, and save it to a folder. It might then use
    a command line utility or a script to send the email with the attachment to the
    user.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，应用程序期望两个输入：一个指向包含图像的*imgur.com*的URL，和一个电子邮件地址。如果攻击者提供其他输入，比如类似*http://lab.blackhatgraphql.com/cat.png*这样的URL和*info@blackhatgraphql.com*这样的电子邮件地址，会怎么样？如果应用程序不验证输入，比如确保URL的域名是*imgur.com*，那么一旦用户提交这些信息，应用程序可能会尝试访问由攻击者控制的网站，将图像下载到磁盘并保存到文件夹中。然后可能会使用命令行实用程序或脚本将带有附件的电子邮件发送给用户。
- en: An attacker could also supply a variety of URLs as input, including URLs that
    contain addresses of private, non-routable IP addresses (such as *172.16.0.0/24*
    or *10.10.0.0/24*). If the server happens to exist on a network where these ranges
    exist, it may perform calls to internal services, such as databases or internal
    websites on the network, allowing an attacker to read responses from servers they
    shouldn’t otherwise be able to reach. An attacker can also attempt to guess internal
    URLs in hopes of landing on a valid one that resolves to an internal address (such
    as *internal.example.com*, *internal2.example.com*, and so on).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者还可以提供各种URL作为输入，包括包含私有非路由IP地址的URL（如*172.16.0.0/24*或*10.10.0.0/24*）。如果服务器恰好存在于这些范围存在的网络上，可能会执行对内部服务的调用，如数据库或网络上的内部网站，允许攻击者读取本应无法访问的服务器的响应。攻击者还可以尝试猜测内部URL，希望能够着陆到解析为内部地址的有效URL（如*internal.example.com*、*internal2.example.com*等）。
- en: With the adoption of cloud infrastructure, SSRF has become one of the greatest
    vulnerabilities for hackers to find. This is because many cloud providers host
    metadata endpoint URLs, which allow cloud instances to read information about
    themselves, such as the role assigned to the instance and the credentials in use.
    Because SSRF could allow an attacker to make internal calls, it could provide
    them with the ability to obtain this sensitive information about the vulnerable
    server.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云基础设施的采用，SSRF已成为黑客发现的最大漏洞之一。这是因为许多云提供商托管元数据端点URL，允许云实例读取关于自身的信息，如分配给实例的角色和正在使用的凭据。由于SSRF可能允许攻击者进行内部调用，它可以使他们能够获取有关易受攻击服务器的敏感信息的能力。
- en: Attackers can attempt SSRF on a variety of protocols other than HTTP, such as
    File Transfer Protocol (FTP), Server Message Block (SMB), Lightweight Directory
    Access Protocol (LDAP), and so on. And, just like other API technologies, GraphQL
    isn’t immune to SSRF vulnerabilities.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以尝试对除了HTTP之外的多种协议进行SSRF，例如文件传输协议（FTP）、服务器消息块（SMB）、轻量目录访问协议（LDAP）等等。而且，就像其他API技术一样，GraphQL对SSRF漏洞也并不免疫。
- en: Understanding the Types of SSRF
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解SSRF的类型
- en: You might encounter three kinds of SSRF vulnerability when performing a GraphQL
    penetration test. Much like the blind SQL injection you learned about in Chapter
    8, *blind SSRF* vulnerabilities provide no concrete visual indication that the
    vulnerability exists. Instead, an attacker may be able to infer the presence of
    a vulnerability by using out-of-band exploitation tools that can listen to various
    protocol messages.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行 GraphQL 渗透测试时，可能会遇到三种类型的 SSRF 漏洞。就像你在第八章学到的盲目 SQL 注入一样，*盲目 SSRF* 漏洞不会提供任何具体的可视化标志来表明漏洞的存在。相反，攻击者可以通过使用可以监听各种协议消息的带外利用工具，推断漏洞的存在。
- en: For example, recall the URL image-fetching service we discussed earlier. When
    exploiting a blind SSRF, an attacker may be able to tell that the application
    is vulnerable by capturing traffic on the remote server that hosts *lab.blackhatgraphql.com*.
    When the attacker submits the URL *http://lab.blackhatgraphql.com/cat.png*, the
    application may initiate certain connections on different protocols before it
    attempts to perform the image fetch over HTTP, such as TCP connections on port
    80\. This could indicate that the application is attempting to reach the attacker-controlled
    server.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，回想一下我们之前讨论的 URL 图像获取服务。在利用盲目 SSRF 时，攻击者可能能够通过捕获托管 *lab.blackhatgraphql.com*
    的远程服务器上的流量来判断应用程序是否存在漏洞。当攻击者提交 URL *http://lab.blackhatgraphql.com/cat.png* 时，应用程序可能会在尝试通过
    HTTP 执行图像获取之前，先在不同协议上发起某些连接，例如在端口 80 上的 TCP 连接。这可能表明应用程序正在尝试连接攻击者控制的服务器。
- en: Another way to determine the existence of a blind SSRF is through timing analysis.
    An attacker can introduce an intentional, artificial delay in the HTTP responses
    that the attacker-controlled server returns, and then determine whether the attack
    succeeded based on the amount of time it takes for the vulnerable application
    to return a response.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种确定盲目 SSRF 存在的方法是通过时序分析。攻击者可以在人为控制的服务器返回的 HTTP 响应中引入故意的人工延迟，然后通过受害应用程序返回响应所花费的时间来确定攻击是否成功。
- en: As the name implies, a *semi-blind SSRF* offers some evidence, but not a full
    indication, that an SSRF vulnerability exists. The information could include errors
    or partial server responses. Imagine that an attacker tries submitting various
    internal URLs to the image-fetching service in an attempt to discover which network
    the host is on. For example, they might submit *http://10.10.0.254/index.html*
    or *http://172.12.0.254/index.html*. In a successful attempt, the application
    may send an email without the attachment, while for a failed attempt, it wouldn’t
    send an email at all.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，*半盲 SSRF* 提供了一些证据，但不是完全的指示，表明 SSRF 漏洞存在。这些信息可能包括错误或部分服务器响应。想象一下，攻击者尝试提交各种内部
    URL 给图像获取服务，以试图发现主机所在的网络。例如，他们可能提交 *http://10.10.0.254/index.html* 或 *http://172.12.0.254/index.html*。在成功的尝试中，应用程序可能会发送没有附件的电子邮件，而在失败的尝试中，则根本不会发送电子邮件。
- en: 'The last type of SSRF is the kind you should hope to discover as a penetration
    tester: *non-blind SSRF* (also called *full-read SSRF*), in which the server returns
    a full response to the attacker, indicating that the SSRF vulnerability exists.
    In the example of the image-fetching service, we may see the full HTTP response
    after providing a non-image-based URL to the application.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种类型的 SSRF 是渗透测试人员希望发现的类型：*非盲 SSRF*（也称为 *完全读取 SSRF*），在这种情况下，服务器会向攻击者返回完整的响应，表明
    SSRF 漏洞的存在。在图像获取服务的示例中，我们可能会在向应用程序提供非图像类 URL 后看到完整的 HTTP 响应。
- en: Searching for Vulnerable Operations, Fields, and Arguments
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索易受攻击的操作、字段和参数
- en: When testing GraphQL servers for SSRF, examine all possible operations, whether
    they’re mutations or queries. As you might expect, SSRF typically affects one
    or more vulnerable GraphQL arguments that accept values, such as scalars.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试 GraphQL 服务器是否存在 SSRF 时，需要检查所有可能的操作，无论是变更操作还是查询操作。如你所料，SSRF 通常影响一个或多个接受值的易受攻击的
    GraphQL 参数，例如标量。
- en: 'Also pay close attention to GraphQL field names to see what they were designed
    to do. For example, fields whose names include verbs such as *fetch*, *import*,
    *download*, or *read* could all imply that the server performs an action, such
    as reading from somewhere or fetching a resource. In addition to field names,
    certain argument names could suggest that the server is attempting to perform
    an outbound connection to resolve the query. Here are a few examples:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 还要特别注意 GraphQL 字段名称，看看它们的设计目的是什么。例如，字段名包含动词如 *fetch*、*import*、*download* 或 *read*，可能暗示着服务器执行某个操作，如从某个地方读取数据或获取资源。除了字段名称，某些参数名称可能表明服务器正在尝试执行外部连接以解析查询。以下是一些例子：
- en: '`ip`'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ip`'
- en: '`url`'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`url`'
- en: '`host`'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`host`'
- en: '`network`'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`network`'
- en: '`domain`'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`domain`'
- en: '`site`'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`site`'
- en: '`target`'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`target`'
- en: '`fetch`'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fetch`'
- en: '`img_url`'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`img_url`'
- en: '`target_url`'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`target_url`'
- en: '`remote_url`'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`remote_url`'
- en: This is a partial list, but it should give you an idea of which keywords could
    be telling.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个部分列表，但它可以帮助你了解哪些关键词可能具有提示作用。
- en: Testing for SSRF
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试 SSRF 漏洞
- en: Let’s go ahead and test for SSRF vulnerabilities in DVGA by using Burp Suite.
    Open the built-in browser by clicking **Open Browser**. Then, quickly tour DVGA’s
    web interface. Does anything jump out at you? How about the Import a Paste page,
    shown in [Figure 9-6](#figure9-6)?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 Burp Suite 来测试 DVGA 的 SSRF 漏洞。点击**打开浏览器**，打开内置浏览器。然后，快速浏览 DVGA 的网页界面。有任何异常之处吗？比如在[图
    9-6](#figure9-6)中显示的导入粘贴页面呢？
- en: '![](image_fi/502840c09/F09006.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c09/F09006.png)'
- en: 'Figure 9-6: DVGA’s Import a Paste page'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-6：DVGA 的导入粘贴页面
- en: 'The Import from URL form takes a URL and attempts to import the paste from
    it. To see what happens when you submit a URL, toggle on the Intercept mode in
    Burp Suite, enter any URL into the search bar, and click **Submit**. (Here is
    an example paste you could import: *https://pastebin.com/raw/LQ6u1qyi*.) You should
    see a request like the following in Burp:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从 URL 导入表单接收一个 URL 并尝试从中导入粘贴内容。要查看提交 URL 后发生的情况，在 Burp Suite 中启用拦截模式，输入任意 URL
    到搜索框，然后点击**提交**。（这是一个可以导入的粘贴示例：*https://pastebin.com/raw/LQ6u1qyi*。）你应该能在 Burp
    中看到类似以下的请求：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, the request uses the `importPaste` mutation, which accepts
    four arguments: `host`, `port`, `path`, and `scheme`. The POST JSON payload includes
    the `variables` key to pass the URL components (values) to these arguments.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，请求使用了 `importPaste` 变更操作，接受四个参数：`host`、`port`、`path` 和 `scheme`。POST JSON
    负载包含 `variables` 键，用于将 URL 组件（值）传递给这些参数。
- en: Behind the scenes, DVGA uses the URL as part of an HTTP GET request, reads the
    response, and adds it into its paste database. To see the imported content, click
    the **Forward** button in Burp Suite to send the request to the GraphQL server,
    toggle off Intercept mode, and go to the **Private Pastes** page.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，DVGA 使用 URL 作为 HTTP GET 请求的一部分，读取响应，并将其添加到粘贴数据库中。要查看导入的内容，点击 Burp Suite
    中的**转发**按钮，将请求发送到 GraphQL 服务器，关闭拦截模式，然后进入**私人粘贴**页面。
- en: Under the hood, GraphQL made an HTTP call to retrieve this content from the
    URL. This type of functionality screams SSRF! Let’s manually explore the same
    GraphQL query, changing some of the values. The mutation is shown in [Listing
    9-7](#listing9-7).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从底层来看，GraphQL 发起了一个 HTTP 请求，从 URL 中检索该内容。这种功能明显是 SSRF 漏洞的表现！让我们手动探索相同的 GraphQL
    查询，修改其中的一些值。变更操作见[清单 9-7](#listing9-7)。
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 9-7: The `importPaste` mutation'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-7：`importPaste` 变更操作
- en: If you look closely, the four arguments compose the building blocks of a URL
    that GraphQL will construct (in this case, *https://pastebin.com:443/raw/LQ6u1qyi*).
    If we can use the HTTP (or HTTPS) scheme and provide any domain and port that
    we desire, nothing stops us from poking around for other services on DVGA’s network,
    right?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，这四个参数组成了 GraphQL 构建 URL 的基本元素（在这个例子中是 *https://pastebin.com:443/raw/LQ6u1qyi*）。如果我们能使用
    HTTP（或 HTTPS）协议，并提供任意的域名和端口，那么就没有什么可以阻止我们在 DVGA 网络上探查其他服务了，对吧？
- en: Let’s see what happens when we specify an internal URL instead of an external
    one. In [Listing 9-8](#listing9-8), we specify a different URL destination to
    import a paste from. The mutation will force DVGA to import a paste by making
    an HTTP request to *http://localhost:8080/paste.txt*. Note that while `localhost`
    is a valid host, port `8080` is not open on the DVGA container. Therefore, this
    request won’t return anything meaningful.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们指定内部 URL 而非外部 URL 时会发生什么。在[清单 9-8](#listing9-8)中，我们指定了一个不同的 URL 目的地来导入粘贴内容。该变更操作将迫使
    DVGA 通过 HTTP 请求从 *http://localhost:8080/paste.txt* 导入粘贴。请注意，虽然 `localhost` 是一个有效的主机，但端口
    `8080` 在 DVGA 容器上并未开放，因此这个请求不会返回任何有意义的内容。
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 9-8: The malicious version of the `importPaste` mutation'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-8：恶意版本的 `importPaste` 变更请求
- en: 'After running the mutation, you should see this response from Altair:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行变更请求后，你应该从 Altair 中看到如下响应：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The server returns an empty `result` object value. We were able to get this
    response in Altair pretty quickly. (In our lab, we received it within 100 milliseconds.)
    So, we now know that we get an immediate result without any data in the `result`
    JSON key if we probe a port that isn’t open.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器返回了一个空的 `result` 对象值。我们在 Altair 中很快就得到了这个响应。（在我们的实验室中，我们在 100 毫秒内就收到了。）因此，我们现在知道，如果我们探测一个未打开的端口，就会立即收到没有数据的
    `result` JSON 键。
- en: 'Next, let’s simulate an SSRF vulnerability by probing for a service that does
    exist. To simulate an additional service on the DVGA container, we’ll use Netcat.
    First, start a Netcat listener in the DVGA container by running the following
    Docker command in Kali’s terminal:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过探测一个存在的服务来模拟 SSRF 漏洞。为了模拟 DVGA 容器上的额外服务，我们将使用 Netcat。首先，在 Kali 终端中运行以下
    Docker 命令，在 DVGA 容器中启动一个 Netcat 监听器：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, we’ll construct a payload to send an HTTP probe to the port Netcat is
    binding to (7773), as shown in [Listing 9-9](#listing9-9).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构造一个有效载荷，向 Netcat 正在绑定的端口（7773）发送 HTTP 探测请求，如 [清单 9-9](#listing9-9) 所示。
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 9-9: A mutation query to abuse an SSRF vulnerability'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-9：利用 SSRF 漏洞的变更查询
- en: If you send this query, you should receive output similar to [Listing 9-10](#listing9-10)
    in your Netcat listener.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发送此查询，你应该会在 Netcat 监听器中看到类似 [清单 9-10](#listing9-10) 的输出。
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 9-10: DVGA request reached the internal service'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-10：DVGA 请求到达内部服务
- en: This shows that DVGA made a GET request to an internal, unexposed port. Note
    that this port is not directly accessible by the Kali machine; we’re using DVGA
    itself to reach it, illustrating how an SSRF vulnerability can give an attacker
    access to services they otherwise wouldn’t be able to reach directly. This SSRF
    attack is more specifically a *cross-site port attack (XSPA)*, which falls under
    the SSRF vulnerability category.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 DVGA 向一个内部的、未公开的端口发送了 GET 请求。请注意，这个端口并不直接由 Kali 机器访问；我们是通过 DVGA 本身来访问它，说明了
    SSRF 漏洞如何让攻击者访问他们本不应直接访问的服务。这个 SSRF 攻击更具体地说是一种 *跨站端口攻击（XSPA）*，属于 SSRF 漏洞类别。
- en: You may have also noticed that Altair hangs after sending the `importPaste`
    mutation in [Listing 9-10](#listing9-10). This happens because the Netcat listener
    we opened won’t return a response, but Altair waits until it receives a response
    from the GraphQL API. This is effectively a blind SSRF, because we have no direct
    access to the response as the attacker; all we know is that the client hangs when
    we probe a port that’s open. You can close the Netcat listener by pressing CTRL-C.
    Altair’s state should then return to normal.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到，在发送了 `importPaste` 变更请求后，Altair 会卡住，见 [清单 9-10](#listing9-10)。这是因为我们打开的
    Netcat 监听器没有返回响应，而 Altair 等待直到收到来自 GraphQL API 的响应。这实际上是一个盲 SSRF，因为作为攻击者我们无法直接访问响应；我们所知道的只是，当我们探测一个打开的端口时，客户端会卡住。你可以通过按
    CTRL-C 来关闭 Netcat 监听器。此时，Altair 状态应该恢复正常。
- en: Preventing SSRF
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止 SSRF
- en: 'To determine whether an application might be vulnerable to SSRF, we can ask
    ourselves this question: Does a client have control over any of the target URLs
    the API flows use? SSRF mostly involves manipulating target URLs by directing
    them to unexpected and restricted internal or external locations. Here are some
    strategies for protecting against this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要判断一个应用是否可能容易受到 SSRF 攻击，我们可以问自己这个问题：客户端是否控制 API 流程中任何目标 URL？SSRF 主要涉及通过将目标 URL
    定向到意外的、受限的内部或外部位置来操纵目标 URL。以下是一些防范此类攻击的策略：
- en: '**Input validation.** Allows rejecting dangerous characters passed to GraphQL
    arguments that accept URLs as part of a query or mutation. Ensures that only authorized
    URLs are accepted and helps reduce the risk of SSRF.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入验证。** 允许拒绝传递给接受 URL 作为查询或变更的一部分的 GraphQL 参数中的危险字符。确保仅接受授权的 URL，并帮助降低 SSRF
    风险。'
- en: '**Network segmentation.** Helps minimize the risk by ensuring that applications
    can communicate with only the relevant internal networks. A vulnerable GraphQL
    API in your staging network shouldn’t be able to reach another GraphQL API in
    your production network.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络分段。** 通过确保应用程序只能与相关的内部网络通信，帮助最小化风险。在你的暂存网络中，如果一个脆弱的 GraphQL API 不应当能够访问生产网络中的另一个
    GraphQL API。'
- en: '**Threat modeling.** Allows identifying potential risks earlier in the development
    life cycle of GraphQL APIs and, more specifically, in queries or mutations that
    have the potential to be vulnerable to SSRF.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**威胁建模**。可以在 GraphQL API 的开发生命周期中及早识别潜在风险，更具体地说，识别可能受到 SSRF 攻击的查询或突变。'
- en: '**Least privileges principle.** Helps minimize the blast radius. Ensure that
    the instance on which GraphQL runs does not have overly permissive permissions
    and cannot perform privileged actions across applications.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小权限原则**。有助于最小化影响范围。确保 GraphQL 运行的实例没有过度宽松的权限，并且无法在多个应用间执行特权操作。'
- en: In the next section, we’ll pivot to talking about hijacking-based vulnerabilities
    that impact GraphQL subscriptions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论基于劫持的漏洞，这些漏洞影响 GraphQL 订阅。
- en: Cross-Site WebSocket Hijacking
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨站点 WebSocket 劫持
- en: If an attacker can hijack a user’s session by getting their hands on session
    cookies that grant special privileges on an application, they can perform actions
    using the victim’s privileges and access their sensitive data. *CSWSH* is a CSRF
    vulnerability that impacts the handshake part of WebSocket communications, which
    use cookie-based authentication. Because GraphQL APIs can use WebSocket for subscription
    operations, they risk being vulnerable to CSWSH.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者能够通过获取会话 cookie 来劫持用户会话，这些 cookie 授予应用程序的特殊权限，他们就可以使用受害者的权限执行操作并访问其敏感数据。*CSWSH*
    是一种影响 WebSocket 通信握手部分的 CSRF 漏洞，这些通信使用基于 cookie 的认证。因为 GraphQL API 可以使用 WebSocket
    进行订阅操作，所以它们面临着 CSWSH 漏洞的风险。
- en: 'In Chapter 3, we showed the handshake request and response sent between a GraphQL
    client and server when using subscriptions over WebSocket to communicate. Clients
    initiate these WebSocket handshakes over HTTP and may include a cookie like the
    following if the WebSocket server implements authentication:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 章中，我们展示了在使用 WebSocket 进行 GraphQL 订阅通信时，客户端和服务器之间发送的握手请求和响应。客户端通过 HTTP 发起这些
    WebSocket 握手，并且如果 WebSocket 服务器实现了认证，可能会包括类似以下的 cookie：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: CSWSH can occur when a WebSocket connection handshake doesn’t include an anti-CSRF
    token to prevent attackers from performing cross-origin requests. When no such
    token exists, it’s easy for an attacker to develop special code that forges WebSocket
    messages on behalf of the victim and uses their authenticated session.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: CSWSH 可能发生在 WebSocket 连接握手中未包含反 CSRF 令牌时，这样攻击者就可以执行跨源请求。当没有此类令牌时，攻击者可以轻松编写特定代码，伪造
    WebSocket 消息，代表受害者使用其认证会话。
- en: In addition to anti-CSRF tokens, WebSocket servers should also validate the
    `Origin` header in the WebSocket handshake request. The `Origin` header has an
    important security function, as it identifies the request’s source. If a server
    doesn’t check this header, it won’t know whether the handshake request was forged.
    Any handshake with an unauthorized origin should return a *403 Forbidden* response
    code rather than *101 Switching Protocols*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 除了反 CSRF 令牌外，WebSocket 服务器还应该验证 WebSocket 握手请求中的 `Origin` 头部。`Origin` 头部具有重要的安全功能，因为它标识了请求的来源。如果服务器没有检查此头部，它将无法知道握手请求是否是伪造的。任何来自未经授权来源的握手请求应该返回
    *403 Forbidden* 响应码，而不是 *101 Switching Protocols*。
- en: Finding Subscription Operations
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找订阅操作
- en: CSWSH vulnerabilities lie at the transport protocol level and so aren’t flaws
    in GraphQL itself. In the context of GraphQL, you’ll find them only when a GraphQL
    API uses subscriptions to perform real-time updates. Thus, to test for CSWSH,
    we’ll first want to know whether the target application has any subscription-related
    fields. To discover this, we can use an introspection query that relies on the
    `subscriptionType` to get field names, as shown in [Listing 9-11](#listing9-11).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: CSWSH 漏洞存在于传输协议层，因此并不是 GraphQL 本身的缺陷。在 GraphQL 的上下文中，只有当 GraphQL API 使用订阅进行实时更新时，你才会发现这些漏洞。因此，为了测试
    CSWSH，我们首先需要知道目标应用是否有任何与订阅相关的字段。为了发现这一点，我们可以使用依赖于 `subscriptionType` 的 introspection
    查询来获取字段名，如 [示例 9-11](#listing9-11) 所示。
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 9-11: Getting subscription field names by using introspection'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-11：通过使用 introspection 获取订阅字段名
- en: If you run this query in Altair against DVGA, you should notice a field in the
    schema named `paste` that the subscription operation can use.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Altair 中针对 DVGA 运行此查询，你应该会注意到架构中有一个名为 `paste` 的字段，订阅操作可以使用该字段。
- en: Hijacking a Subscription Query
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 劫持订阅查询
- en: Now let’s hijack a subscription query and exfiltrate its response. To simulate
    this attack, we’ll take the following steps. From the attacker’s perspective,
    we’ll open a Netcat TCP listener on port 4444, where we’ll receive the exfiltrated
    response. Next, from the victim’s perspective, we’ll simulate a user falling victim
    to a social-engineering attack by dropping an HTML file into the browser so it
    loads the JavaScript code, hijacking the user’s session to perform a WebSocket
    handshake and subscribe to the `paste` event. We’ll also create a new paste in
    DVGA for the subscription query to pick up. This will simulate website activity
    that the victim may have access to that the attacker shouldn’t. Finally, we’ll
    read the exfiltrated response obtained by Netcat.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们劫持一个订阅查询并提取它的响应。为了模拟这个攻击，我们将采取以下步骤。从攻击者的角度来看，我们将在端口4444上打开一个Netcat TCP监听器，用于接收提取的响应。接下来，从受害者的角度来看，我们将通过将一个HTML文件拖入浏览器来模拟用户成为社交工程攻击的受害者，这样它会加载JavaScript代码，劫持用户的会话，进行WebSocket握手并订阅`paste`事件。我们还将在DVGA中创建一个新的粘贴内容，以供订阅查询提取。这将模拟受害者可能访问但攻击者不应访问的网站活动。最后，我们将读取通过Netcat获取的提取响应。
- en: Let’s start by first examining the underlying code to understand the attack
    pattern. Save the CSWSH hijacking code at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/websockets_hijack.html](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/websockets_hijack.html)
    to your desktop. Make sure the filename has the *.html* extension. [Listing 9-12](#listing9-12)
    shows the code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先检查底层代码，了解攻击模式。将CSWSH劫持代码保存到[https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/websockets_hijack.html](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/websockets_hijack.html)并保存在桌面上。确保文件名具有*.html*扩展名。[清单9-12](#listing9-12)显示了代码。
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 9-12: JavaScript code that performs WebSocket hijacking'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 清单9-12：执行WebSocket劫持的JavaScript代码
- en: We initialize a new `WebSocket` object and specify the DVGA’s subscription URL
    ❶. At ❷, we declare a `query` variable containing the subscription query. This
    query subscribes to the `paste` event and fetches fields such as `id`, `title`,
    `content`, `ipAddr`, `userAgent`, `public`, and the owner’s `name`. At ❸, we send
    a JSON string containing this query over the WebSocket protocol. After the message
    is sent, the `ws.onmessage` event handler is called when incoming WebSocket messages
    are received. This handler will parse the message as a JSON object ❹. Once the
    message is parsed, the code at ❺ will exfiltrate the response to a destination
    (in this case, *http://localhost:4444*) by using GET URL parameters.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化一个新的`WebSocket`对象，并指定DVGA的订阅URL ❶。在❷处，我们声明一个`query`变量，其中包含订阅查询。该查询订阅`paste`事件，并提取字段，如`id`、`title`、`content`、`ipAddr`、`userAgent`、`public`和所有者的`name`。在❸处，我们通过WebSocket协议发送一个包含此查询的JSON字符串。发送完消息后，当收到WebSocket消息时，将调用`ws.onmessage`事件处理程序。该处理程序会将消息解析为JSON对象
    ❹。消息解析完成后，代码在❺处通过使用GET URL参数将响应提取到目标位置（在此情况下是*http://localhost:4444*）。
- en: 'Let’s get things started! In a terminal window, run the following command to
    start the Netcat listener:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！在终端窗口中，运行以下命令以启动Netcat监听器：
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `-vlp` flags we pass to Netcat tell it to listen (`-l`) in verbose mode
    (`-v`) on port (`-p`) 4444\. Next, open a browser window and drop the HTML file
    you downloaded earlier into the browser’s window. You should see the page shown
    in [Figure 9-7](#figure9-7).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给Netcat的`-vlp`标志告诉它在端口(`-p`)4444上以详细模式(`-v`)进行监听(`-l`)。接下来，打开一个浏览器窗口，并将你之前下载的HTML文件拖入浏览器窗口。你应该会看到[图9-7](#figure9-7)所示的页面。
- en: '![](image_fi/502840c09/F09007.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c09/F09007.png)'
- en: 'Figure 9-7: The WebSocket hijacking demo'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-7：WebSocket劫持演示
- en: Next, open another browser window and click **Create Paste** on the left to
    open the Create a Paste page on *http://localhost:5013*. Enter something you’ll
    recognize as the title and your message, as shown in [Figure 9-8](#figure9-8).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开另一个浏览器窗口，点击左侧的**创建粘贴**以打开*http://localhost:5013*上的“创建粘贴”页面。输入你能识别的标题和信息，如[图9-8](#figure9-8)所示。
- en: '![](image_fi/502840c09/F09008.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c09/F09008.png)'
- en: 'Figure 9-8: A paste creation in DVGA'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-8：DVGA中的粘贴创建
- en: 'Next, click **Submit**, and pay close attention the terminal window in which
    Netcat is running. You should see output similar to this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击**提交**，并密切关注Netcat运行的终端窗口。你应该会看到类似这样的输出：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Netcat received a GET request from the victim containing the exfiltrated paste
    data. You can see that the request’s URL parameters start with `/?{%22type`. The
    payload is URL encoded, but when you decode it, you can immediately tell it’s
    the paste data we created using DVGA’s user interface. You can perform this URL
    decoding with a website such as [https://meyerweb.com/eric/tools/dencoder](https://meyerweb.com/eric/tools/dencoder)
    or by using Python from the terminal, as shown in [Listing 9-13](#listing9-13).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Netcat 接收到来自受害者的 GET 请求，包含提取的粘贴数据。你可以看到请求的 URL 参数以 `/?{%22type` 开头。有效载荷经过 URL
    编码，但解码后，你可以立即识别出它是我们通过 DVGA 用户界面创建的粘贴数据。你可以使用类似 [https://meyerweb.com/eric/tools/dencoder](https://meyerweb.com/eric/tools/dencoder)
    的网站，或者通过在终端使用 Python 来进行这种 URL 解码，如 [示例 9-13](#listing9-13) 所示。
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 9-13: URL decoding with Python'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-13：使用 Python 进行 URL 解码
- en: We were able to exfiltrate data by forcing a client to visit an attacker-controlled
    website, where custom code sent forged, cross-site WebSocket messages and exfiltrated
    their responses to a remote Netcat listener.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过强制客户端访问一个攻击者控制的网站，成功地提取了数据。该网站的自定义代码发送伪造的跨站 WebSocket 消息，并将响应数据传送到远程 Netcat
    监听器。
- en: Preventing CSWSH
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止 CSWSH
- en: Because CSWSH is a CSRF attack, you can prevent it by using CSRF mitigation
    techniques. WebSocket servers that use forms of authentication other than cookies
    to authenticate clients, such as JWT, can also offer protections. When a server
    uses JWT tokens, cross-site WebSocket messages won’t be able to authenticate without
    the proper headers, resulting in a handshake failure.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 CSWSH 是一种 CSRF 攻击，你可以通过使用 CSRF 防护技术来防止它。使用除 cookies 以外的身份验证方式（如 JWT）来认证客户端的
    WebSocket 服务器，也可以提供保护。当服务器使用 JWT 令牌时，跨站 WebSocket 消息如果没有正确的头部将无法进行身份验证，从而导致握手失败。
- en: Validation of the `Origin` header is also crucial to preventing CSWSH attacks,
    and from a hacker’s perspective, this validation is worth testing for bypasses.
    Servers may check the header in odd ways. For instance, if the application allows
    only the origin *example.com*, an attacker might try creating a domain that uses
    it as its subdomain, like *example.com.attacker.net*. If the server validates
    the `Origin` header in a naive way (for instance, by checking for the string *example.com*),
    such an attack might pass the validation logic.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 验证 `Origin` 头部对于防止 CSWSH 攻击也至关重要，从黑客的角度来看，这项验证值得测试是否能绕过。服务器可能会以不同的方式检查该头部。例如，如果应用程序只允许
    *example.com* 作为来源，攻击者可能会尝试创建一个将其用作子域的域名，如 *example.com.attacker.net*。如果服务器以简单的方式（例如，仅检查字符串
    *example.com*）验证 `Origin` 头部，这样的攻击可能会绕过验证逻辑。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about attacks affecting GraphQL API consumers and
    servers. Using GET- and POST-based CSRF, attackers could forge queries and mutations
    on behalf of clients. By hijacking WebSocket communications by using CSWSH, an
    attacker could exfiltrate GraphQL subscription responses. Finally, SSRF allows
    attackers to forge requests on behalf of servers and potentially reach internal
    resources.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了影响 GraphQL API 消费者和服务器的攻击。通过基于 GET 和 POST 的 CSRF 攻击，攻击者可以伪造客户端的查询和突变。通过使用
    CSWSH 劫持 WebSocket 通信，攻击者可以提取 GraphQL 订阅响应。最后，SSRF 允许攻击者伪造服务器请求，并可能访问内部资源。
