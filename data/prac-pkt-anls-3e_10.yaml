- en: '**10**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10**'
- en: '**BASIC REAL-WORLD SCENARIOS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**基础现实世界场景**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: Beginning with this chapter, we’ll dig into the meat of packet analysis as we
    use Wireshark to analyze real-world network problems. I’ll introduce a series
    of problem scenarios by describing the context of the problem and providing the
    information that was available to the analyst at the time. Having laid the groundwork,
    we’ll turn to analysis as I describe the method used to capture the appropriate
    packets and step you through the process of working toward a diagnosis. Once analysis
    is complete, I’ll point toward potential solutions and give an overview of the
    lessons learned.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一章开始，我们将深入数据包分析的核心内容，使用Wireshark分析现实世界中的网络问题。我将通过描述问题的背景并提供分析师当时获得的信息来介绍一系列问题场景。在打下基础后，我们将转向分析部分，我会描述用于捕获适当数据包的方法，并引导你一步步向诊断迈进。一旦分析完成，我将指出潜在的解决方案并概述学到的经验教训。
- en: Throughout, remember that analysis is a very dynamic process. Thus, the methods
    I use to analyze each scenario may not be the same ones that you would use. Everyone
    approaches problem solving and reasoning through their own lens. The most important
    thing is that the result of the analysis solves a problem, but even when it doesn’t,
    it’s critical to learn from failures as well. Experience is the thing we get when
    we don’t get what we want, after all.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中，请记住，分析是一个非常动态的过程。因此，我用来分析每个场景的方法可能和你使用的方法不同。每个人通过自己的视角来解决问题和推理。最重要的是，分析的结果能解决问题，即使没有解决问题，从失败中学习也是至关重要的。毕竟，经验是我们在没有得到想要的结果时获得的。
- en: In addition, most problems discussed in this chapter can probably be solved
    with methods that don’t necessarily involve a packet sniffer, but what’s the fun
    in that? When I was first learning how to analyze packets, I found it helpful
    to examine typical problems in atypical ways by using packet analysis techniques,
    which is why I present these scenarios to you.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章讨论的大多数问题可能通过不一定需要使用数据包嗅探器的方法来解决，但那样有什么趣味呢？当我第一次学习如何分析数据包时，我发现通过使用数据包分析技巧以不寻常的方式分析典型问题很有帮助，这也是我向你们展示这些场景的原因。
- en: '**Missing Web Content**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**缺失的网页内容**'
- en: '*http_espn_fail.pcapng*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*http_espn_fail.pcapng*'
- en: In the first scenario we’ll look at, our user is Packet Pete, a college basketball
    fan who doesn’t keep late hours and usually misses the West Coast games. The first
    thing he does when he sits down at his workstation every morning is visit *[http://www.espn.com/](http://www.espn.com/)*
    for the previous night’s final scores. When Pete browses to ESPN this morning,
    he finds that the page is taking a long time to load, and when it finally does,
    most of the images and content are missing ([Figure 10-1](ch10.xhtml#ch10fig1)).
    Let’s help Pete diagnose this issue.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们要查看的第一个场景中，我们的用户是数据包皮特，他是一个大学篮球迷，不熬夜，通常错过西海岸的比赛。每当他早上坐到工作站时，他首先做的事就是访问*[http://www.espn.com/](http://www.espn.com/)*查看前一晚的比赛最终得分。当皮特今天早上浏览ESPN时，他发现页面加载非常缓慢，最终加载完成时，大部分图片和内容都缺失了（[图10-1](ch10.xhtml#ch10fig1)）。让我们帮皮特诊断这个问题。
- en: '![image](../images/f200-01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f200-01.jpg)'
- en: '*Figure 10-1: ESPN is failing to load properly.*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-1：ESPN加载不正常*'
- en: '***Tapping into the Wire***'
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***连接到线路***'
- en: This issue is isolated to Pete’s workstation and is not affecting any others,
    so we’ll start by capturing packets directly from there. To do this, we’ll install
    Wireshark and capture packets while browsing to the ESPN website. Those packets
    are found in the file *http_espn_fail.pcapng*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题仅限于皮特的工作站，并没有影响到其他工作站，所以我们将从皮特的工作站直接捕获数据包来开始。为此，我们将安装Wireshark并在浏览ESPN网站时捕获数据包。这些数据包存储在文件*http_espn_fail.pcapng*中。
- en: '***Analysis***'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分析***'
- en: We know Pete’s issue is that he’s unable to view a website he is browsing to,
    so we’re primarily going to be looking at the HTTP protocol. If you read the previous
    chapter, you should have a basic understanding of what HTTP traffic between a
    client and server looks like. A good place to start looking is at the HTTP requests
    being made to the remote server. You can do this by applying a filter for `GET`
    requests (using http.request.method == "GET"), but this can also be done by simply
    selecting **Statistics** ▶ **HTTP** ▶ **Requests** from the main drop-down menu
    ([Figure 10-2](ch10.xhtml#ch10fig2)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道Pete的问题是他无法查看他正在浏览的网站，因此我们主要会查看HTTP协议。如果你阅读了上一章，你应该对客户端和服务器之间的HTTP流量有一个基本的了解。一个好的起点是查看向远程服务器发出的HTTP请求。你可以通过应用`GET`请求的过滤器（使用http.request.method
    == "GET"）来做到这一点，但也可以通过从主下拉菜单中选择**统计信息** ▶ **HTTP** ▶ **请求**来实现这一点（[图10-2](ch10.xhtml#ch10fig2)）。
- en: '![image](../images/f201-01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f201-01.jpg)'
- en: '*Figure 10-2: Viewing HTTP requests to ESPN*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-2：查看向ESPN发送的HTTP请求*'
- en: From this overview, it appears the capture is limited to seven different HTTP
    requests, and they all look like they are associated with the ESPN website. Each
    request contains the string `espn` within the domain name, with the exception
    of *[cdn.optimizely.com](http://cdn.optimizely.com)*, which is a *content delivery
    network* (CDN) used to deliver advertising to a multitude of sites. It’s common
    to see requests to various CDNs when browsing to websites that host advertisements
    or other external content.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个概述中看，捕获内容似乎仅限于七个不同的HTTP请求，而且它们看起来都与ESPN网站相关。每个请求的域名中都包含`espn`这个字符串，唯一例外的是
    *[cdn.optimizely.com](http://cdn.optimizely.com)*，它是一个*内容分发网络*(CDN)，用于向多个网站投放广告。浏览到托管广告或其他外部内容的网站时，看到对各种CDN的请求是很常见的。
- en: With no clear leads to follow, the next step is to look at the protocol hierarchy
    of the capture file by selecting **Statistics** ▶ **Protocol Hierarchy**. This
    will allow us to spot unexpected protocols or peculiar distributions of traffic
    per protocol ([Figure 10-3](ch10.xhtml#ch10fig3)). Keep in mind that the protocol
    hierarchy screen is based on the currently applied display filter. Be sure to
    clear the previously applied filter to get the expected results based on the entire
    packet capture.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有明确的线索可供追踪，下一步是通过选择**统计信息** ▶ **协议层级**来查看捕获文件的协议层级。这将帮助我们发现意外的协议或每种协议的流量分布情况（[图10-3](ch10.xhtml#ch10fig3)）。请记住，协议层级屏幕基于当前应用的显示过滤器。请确保清除先前应用的过滤器，以便基于整个数据包捕获获得预期结果。
- en: '![image](../images/f202-01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f202-01.jpg)'
- en: '*Figure 10-3: Reviewing the protocol hierarchy of the browsing session*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-3：查看浏览会话的协议层级*'
- en: 'The protocol hierarchy isn’t too complex, and we can quickly decipher that
    there are only two application-layer protocols at work: HTTP and DNS. As you learned
    in [Chapter 9](ch09.xhtml#ch09), DNS is used to translate domain names to IP addresses.
    So, when you browse to a site like *[http://www.espn.com/](http://www.espn.com/)*,
    your system may need to send out a DNS query to find the IP address of the remote
    web server if it doesn’t already know it. Once a DNS reply with the appropriate
    IP address comes back, that information can be added to a local cache, and HTTP
    communication (using TCP) can commence.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 协议层级并不复杂，我们可以迅速解读出只有两个应用层协议在工作：HTTP 和 DNS。正如你在[第9章](ch09.xhtml#ch09)中所学，DNS用于将域名转换为IP地址。因此，当你浏览像
    *[http://www.espn.com/](http://www.espn.com/)* 这样的网站时，如果系统尚未知道远程服务器的IP地址，可能需要发送DNS查询来查找该IP地址。一旦收到包含适当IP地址的DNS回复，该信息可以被添加到本地缓存中，然后可以开始进行HTTP通信（使用TCP）。
- en: Although nothing looks out of the ordinary here, the 14 DNS packets are notable.
    A DNS request for a single domain name is typically contained in a single packet,
    and the response also constitutes a single packet (unless it’s very large, in
    which case DNS will utilize TCP). Since there are 14 DNS packets here, it’s possible
    that as many as seven DNS queries were generated (7 queries + 7 replies = 14 packets).
    [Figure 10-2](ch10.xhtml#ch10fig2) did show HTTP requests to seven different domains,
    but Pete only typed a single URL into his browser. Why are all of these extra
    requests being made?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里看起来并没有什么异常，但14个DNS数据包是值得注意的。一个域名的DNS请求通常会包含在一个数据包中，响应也会构成一个数据包（除非数据包非常大，在这种情况下DNS会使用TCP）。由于这里有14个DNS数据包，可能生成了多达七个DNS查询（7个查询
    + 7个回复 = 14个数据包）。[图10-2](ch10.xhtml#ch10fig2)确实显示了对七个不同域名的HTTP请求，但Pete在浏览器中只输入了一个URL。为什么会发出这么多额外的请求呢？
- en: In a simple world, visiting a web page would be as easy as querying one server
    and pulling all of its content in a single HTTP conversation. In reality, an individual
    web page may provide content hosted on multiple servers. All of the text-based
    content could be in one place, the graphics could be in another, and embedded
    videos could be in a third. That doesn’t include ads, which could be hosted on
    multiple providers spanning dozens of individual servers. Whenever an HTTP client
    parses HTML code and finds a reference to content on another host, it will attempt
    to query that host for the content, which can generate additional DNS queries
    and HTTP requests. This is exactly what happened here when Pete visited ESPN.
    While he may have intended to view content only from a single source, references
    to additional content were found in the HTML code, and his browser automatically
    requested that content from multiple other domains.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个简单的世界里，访问一个网页可能就像查询一个服务器并通过一次HTTP对话拉取所有内容一样简单。实际上，单个网页可能会提供托管在多个服务器上的内容。所有基于文本的内容可能在一个地方，图形可能在另一个地方，嵌入的视频可能在第三个地方。除此之外，还有广告，这些广告可能由多个提供商托管，跨越数十个独立的服务器。每当HTTP客户端解析HTML代码并找到引用其他主机内容的链接时，它会尝试查询该主机以获取内容，这就可能生成额外的DNS查询和HTTP请求。这正是Pete访问ESPN时发生的情况。尽管他可能只打算查看来自单一来源的内容，但在HTML代码中找到了对其他内容的引用，他的浏览器自动向多个不同的域名请求这些内容。
- en: Now that we understand why all of these extra requests exist, our next step
    is to examine the individual conversations associated with each request (**Statistics
    ▶ Conversations**). Reviewing the Conversations window ([Figure 10-4](ch10.xhtml#ch10fig4))
    provides an important clue.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了所有这些额外请求的存在原因，接下来的步骤是检查与每个请求相关的个别对话（**统计 ▶ 对话**）。查看对话窗口（[图10-4](ch10.xhtml#ch10fig4)）提供了一个重要线索。
- en: '![image](../images/f203-01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f203-01.jpg)'
- en: '*Figure 10-4: Reviewing IP conversations*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-4：审查IP对话*'
- en: We discovered earlier that there were seven DNS requests and seven HTTP requests
    to match. With that in mind, it would be reasonable to expect that there would
    also be seven matching IP conversations, but that isn’t the case. There are eight.
    How can that be explained?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前发现有七个DNS请求和七个HTTP请求相匹配。考虑到这一点，合理的预期是会有七个匹配的IP对话，但事实并非如此。实际上有八个。那该如何解释呢？
- en: 'One thought might be that the capture was “contaminated” by an additional conversation
    unrelated to the problem at hand. Ensuring your analysis doesn’t suffer due to
    irrelevant traffic is certainly something you should be cognizant of, but that
    isn’t the issue with this conversation. If you examine each HTTP request and note
    the IP address the request was sent to, you should be left with one conversation
    that doesn’t have a matching HTTP request. The endpoints for this conversation
    are Pete’s workstation (172.16.16.154) and the remote IP 203.0.113.94\. This conversation
    is represented by the bottom line in [Figure 10-4](ch10.xhtml#ch10fig4). We note
    that 6,774 bytes were sent to this unknown host but zero bytes were sent back:
    that’s worth digging into.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的想法是，捕获的数据中可能有与当前问题无关的额外对话“污染”了分析结果。确保分析不受无关流量的影响是非常重要的，但这并不是本次对话中的问题。如果你检查每个HTTP请求并记录请求发送的IP地址，你应该会发现有一个对话没有匹配的HTTP请求。这个对话的终端是Pete的工作站（172.16.16.154）和远程IP（203.0.113.94）。这个对话在[图10-4](ch10.xhtml#ch10fig4)的底部表示。我们注意到，6,774字节被发送到这个未知主机，但没有字节被返回：这值得进一步探究。
- en: If you filter down into this conversation (right-click the conversation and
    choose **Apply As Filter ▶ Selected ▶ A<->B**), you can apply your knowledge of
    TCP to identify what’s gone wrong ([Figure 10-5](ch10.xhtml#ch10fig5)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个对话进行过滤（右键点击该对话并选择**应用为过滤器 ▶ 选择 ▶ A<->B**），你可以运用你对TCP的知识来识别出了什么问题（[图10-5](ch10.xhtml#ch10fig5)）。
- en: '![image](../images/f203-02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f203-02.jpg)'
- en: '*Figure 10-5: Reviewing the unexpected connection*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-5：回顾意外连接*'
- en: With normal TCP communication, you expect to see a standard SYNSYN/ACK-ACK handshake
    sequence. In this case, Pete’s workstation sent a SYN packet to 203.0.113.94,
    but we never see a SYN/ACK response. Not only this, but Pete’s workstation sent
    multiple SYN packets to no avail, eventually leading his machine to send TCP retransmission
    packets. We’ll talk more about the specifics of TCP retransmissions in [Chapter
    11](ch11.xhtml#ch11), but the key takeaway here is that one host is sending packets
    that it never receives a response to. Looking at the Time column, we see that
    the retransmissions continue for 95 seconds without a response. In network communications,
    this is slower than molasses.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的TCP通信中，你会看到标准的SYNSYN/ACK-ACK握手序列。在这种情况下，Pete的工作站向203.0.113.94发送了一个SYN数据包，但我们从未看到SYN/ACK响应。不仅如此，Pete的工作站多次发送SYN数据包也未能成功，最终导致他的计算机发送TCP重传数据包。我们将在[第11章](ch11.xhtml#ch11)中详细讨论TCP重传的具体情况，但这里的关键要点是，一个主机发送了数据包，却没有收到任何响应。从时间列中可以看到，重传持续了95秒而没有得到响应。在网络通信中，这比蜂蜜还慢。
- en: We have identified seven DNS requests, seven HTTP requests, and eight IP conversations.
    Since we know that the capture is not contaminated with extra data, it’s reasonable
    to think that the mysterious eighth IP conversation is probably the source of
    Pete’s slowly and incompletely loading web page. For some reason, Pete’s workstation
    is trying to communicate with a device that either doesn’t exist or just isn’t
    listening. To understand why this is happening, we won’t look at what’s in the
    capture file; instead, we’ll consider what isn’t there.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经识别出七个DNS请求、七个HTTP请求和八个IP对话。由于我们知道捕获的数据没有被额外数据污染，因此可以合理推测神秘的第八个IP对话可能是Pete的网页加载缓慢且不完全的原因。由于某种原因，Pete的工作站正在尝试与一个不存在或根本没有响应的设备进行通信。为了理解为什么会发生这种情况，我们不去查看捕获文件中的内容，而是考虑文件中缺失的部分。
- en: When Pete browsed to *[http://www.espn.com/](http://www.espn.com/)*, his browser
    identified resources hosted on other domains. To retrieve that data, his workstation
    generated DNS requests to find their IP addresses, then connected to them via
    TCP so that an HTTP request for the content could be sent. For the conversation
    with 203.0.113.94, there is no DNS request to be found. So, how did Pete’s workstation
    know about that address?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当Pete浏览到 *[http://www.espn.com/](http://www.espn.com/)* 时，他的浏览器识别出了托管在其他域名上的资源。为了检索这些数据，他的工作站生成了DNS请求来查找它们的IP地址，然后通过TCP连接到这些地址，以便发送HTTP请求获取内容。在与203.0.113.94的对话中，并没有找到DNS请求。那么，Pete的工作站是如何知道这个地址的呢？
- en: If you remember our discussion about DNS in [Chapter 9](ch09.xhtml#ch09) or
    are otherwise familiar with it, you know that most systems implement some form
    of DNS caching. This allows them to reference a local DNS-to-IP address mapping
    that has already been retrieved without having to generate a DNS request every
    time you visit a domain that you frequently communicate with. Eventually, these
    DNS-to-IP mappings expire, and a new request must be generated. However, if a
    DNS-to-IP mapping changes and a device doesn’t generate a DNS request to get the
    new address when visiting the next time, the device will attempt to connect to
    an address that is no longer valid.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得我们在[第9章](ch09.xhtml#ch09)中讨论的DNS内容，或者你对DNS有一定了解，你就知道大多数系统都实现了某种形式的DNS缓存。这使得它们可以引用已经检索到的本地DNS到IP地址的映射，而无需每次访问一个常用域名时都生成DNS请求。最终，这些DNS到IP的映射会过期，必须生成新的请求。然而，如果DNS到IP的映射发生了变化，而设备在下次访问时没有生成DNS请求来获取新的地址，那么该设备将尝试连接一个已经失效的地址。
- en: In Pete’s case, that is exactly what happened. Pete’s workstation already had
    a cached DNS-to-IP mapping for a domain that hosts content for ESPN. Since this
    cached entry exists, a DNS request was not generated, and his system attempted
    to go ahead and connect to the old address. However, that address was no longer
    configured to respond to requests. As a result, the requests timed out, and the
    content never loaded.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在皮特的情况下，正是发生了这种情况。皮特的工作站已经缓存了一个 DNS 到 IP 的映射，该映射指向托管 ESPN 内容的域名。由于这个缓存条目存在，DNS
    请求没有被生成，他的系统尝试直接连接到旧的地址。然而，那个地址已经不再配置为响应请求。因此，请求超时，内容也没有加载出来。
- en: Fortunately for Pete, clearing his DNS cache manually is possible with a few
    keystrokes on the command line or in a terminal window. Alternatively, he could
    also just try again in a few minutes when the DNS cache entry will probably have
    expired so a new request will be generated.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于皮特来说，手动清除 DNS 缓存只需要在命令行或终端窗口中敲几下键就能完成。或者，他也可以等几分钟，等 DNS 缓存条目过期时，再尝试一次，这时会生成一个新的请求。
- en: '***Lessons Learned***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***经验教训***'
- en: That’s a lot of work just to find out that Kentucky beat Duke by 90 points,
    but we walk away with a deeper understanding of the relationship between network
    hosts. In this scenario, we were able to work toward a solution by assessing multiple
    data points related to the requests and conversations occurring within the capture.
    From there, we were able to spot a few inconsistencies that took us down a path
    toward finding the failed communication between the client and one of ESPN’s content
    delivery servers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一项大工程，目的只是为了知道肯塔基大学以 90 分的优势击败了杜克大学，但我们却从中获得了对网络主机关系更深的理解。在这个场景中，我们通过评估与请求和通信相关的多个数据点，逐步找到了问题的解决办法。通过这些数据点，我们发现了一些不一致之处，进而发现了客户端与
    ESPN 内容分发服务器之间的通信故障。
- en: In the real world, diagnosing problems is rarely as simple as scrolling through
    a list of packets and looking for the ones that look funny. Troubleshooting even
    the simplest problems can result in very large captures that rely on the use of
    Wireshark’s analysis and statistics features to spot anomalies. Getting familiar
    with this style of analysis is critical to successful troubleshooting at the packet
    level.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，诊断问题很少像滚动查看数据包列表并寻找看起来奇怪的数据包那么简单。即便是最简单的问题，排除故障也可能导致非常大的抓包文件，这时就需要依赖
    Wireshark 的分析和统计功能来识别异常。熟悉这种分析方式对于在数据包级别上成功排查故障至关重要。
- en: If you’d like to see an example of what normal communication looks like between
    a web browser and ESPN, try browsing to the site while capturing traffic yourself
    and see if you can identify all of the servers responsible for delivering content.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看看正常的 web 浏览器与 ESPN 之间的通信示例，试着自己访问该网站并捕获流量，看看你能否识别出所有负责传递内容的服务器。
- en: '**Unresponsive Weather Service**'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**无响应的天气服务**'
- en: '*weather_broken.pcapng weather_working.pcapng*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*weather_broken.pcapng weather_working.pcapng*'
- en: Our second scenario once again involves our pal Packet Pete. Among his many
    hobbies, Pete fancies himself an amateur meteorologist and doesn’t go more than
    a few hours without checking current conditions and the forecast. He doesn’t rely
    solely on the local news forecast though; he actually runs a small weather station
    outside his home that reports data up to *[https://www.wunderground.com/](https://www.wunderground.com/)*
    for aggregation and viewing. Today, Pete went to check his weather station to
    see how much the temperature had dropped overnight, but found that his station
    hadn’t reported in to Wunderground in over nine hours, since around midnight ([Figure
    10-6](ch10.xhtml#ch10fig6)).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个场景再次涉及到我们的朋友数据包皮特。在他众多的爱好中，皮特自认为是一个业余气象学家，几乎每隔几个小时就会检查当前的天气状况和预报。不过，他并不完全依赖当地新闻的天气预报；他实际上在家外面安装了一个小型气象站，将数据报告上传到*
    [https://www.wunderground.com/](https://www.wunderground.com/)*，以便聚合和查看。今天，皮特去检查他的气象站，看看气温一夜之间下降了多少，但发现他的气象站已经超过九个小时没有向
    Wunderground 报告数据了，从大约午夜开始（[图 10-6](ch10.xhtml#ch10fig6)）。
- en: '![image](../images/f205-01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f205-01.jpg)'
- en: '*Figure 10-6: The weather station hasn’t sent a report in nine hours.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-6：气象站已经九小时没有报告数据了。*'
- en: '***Tapping into the Wire***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***深入了解数据线***'
- en: In Pete’s network, the weather station mounted on his roof connects to a receiver
    inside his house through an RF connection. That receiver plugs into his network
    switch and reports statistics to Wunderground through the internet. This architecture
    is diagrammed in [Figure 10-7](ch10.xhtml#ch10fig7).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pete的网络中，安装在他屋顶上的气象站通过RF连接与屋内的接收器相连。接收器连接到他的网络交换机，并通过互联网向Wunderground报告统计数据。这种架构在[图10-7](ch10.xhtml#ch10fig7)中进行了示意。
- en: '![image](../images/f206-01.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f206-01.jpg)'
- en: '*Figure 10-7: Weather station network architecture*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-7：气象站网络架构*'
- en: The receiver has a simple web-based management page, but Pete logged into it
    only to find a cryptic message about the last synchronization time with no additional
    guidance for troubleshooting—the software doesn’t provide any detailed error logging.
    Since the receiver is the hub of communication for the weather station infrastructure,
    it makes sense to capture packets transmitted to and from that device to try to
    diagnose the issue. This is a home network, so port mirroring is probably not
    an option on the SOHO switch. Our best bet is to use a cheap tap or to perform
    ARP cache poisoning to intercept these packets. The captured packets are contained
    in the file *weather_broken.pcapng*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接收器有一个简单的基于网页的管理页面，但Pete登录后只看到一条关于最后一次同步时间的晦涩信息，并没有提供任何额外的故障排除指导——软件没有提供详细的错误日志。由于接收器是气象站基础设施的通信枢纽，捕获传入和传出的数据包来诊断问题是有意义的。这是一个家庭网络，所以在SOHO交换机上可能没有端口镜像功能。我们最好的选择是使用便宜的taps，或者执行ARP缓存中毒来拦截这些数据包。捕获的数据包存储在文件*weather_broken.pcapng*中。
- en: '***Analysis***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分析***'
- en: Upon opening the capture file, you’ll see that we’re dealing with HTTP communication
    once again. The packet capture is limited to a single conversation between Pete’s
    local weather receiver 172.16.16.154 and an unknown remote device on the internet,
    38.102.136.125 ([Figure 10-8](ch10.xhtml#ch10fig8)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 打开捕获文件后，你会发现我们再次处理的是HTTP通信。数据包捕获仅限于Pete本地气象接收器172.16.16.154与互联网中一个未知远程设备38.102.136.125之间的单一对话（见[图10-8](ch10.xhtml#ch10fig8)）。
- en: '![image](../images/f206-02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f206-02.jpg)'
- en: '*Figure 10-8: Isolated weather station receiver communication*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-8：隔离的气象站接收器通信*'
- en: Before we examine the characteristics of the conversation, let’s see if we can
    identify the unknown IP. Without extensive research, we might not be able to find
    out whether this is the exact IP address that Pete’s weather receiver should be
    talking to, but we can at least verify that it is part of the Wunderground infrastructure
    by doing a WHOIS query. You can conduct a WHOIS query through most domain registration
    or regional internet registry websites, such as *[http://whois.arin.net/](http://whois.arin.net/)*.
    In this case, it looks like the IP belongs to Cogent, an *internet service provider
    (ISP)* ([Figure 10-9](ch10.xhtml#ch10fig9)). PSINet Inc. is also mentioned here,
    but a quick search reveals that most PSINet assets were acquired by Cogent in
    the early 2000s.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们检查对话的特征之前，先看看能否识别出这个未知IP。在没有广泛研究的情况下，我们可能无法确定这个IP是否是Pete的气象接收器应该连接的确切IP地址，但我们至少可以通过进行WHOIS查询验证它是否属于Wunderground的基础设施。你可以通过大多数域名注册或区域互联网注册网站进行WHOIS查询，例如*[http://whois.arin.net/](http://whois.arin.net/)*。在这种情况下，看起来该IP属于Cogent，一家*互联网服务提供商（ISP）*（见[图10-9](ch10.xhtml#ch10fig9)）。PSINet
    Inc.也在这里提到，但通过快速搜索发现，PSINet的大多数资产在2000年代初被Cogent收购。
- en: '![image](../images/f207-01.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f207-01.jpg)'
- en: '*Figure 10-9: WHOIS data identifies the owner of this IP.*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-9：WHOIS数据识别了该IP的所有者。*'
- en: In some cases, if an IP address is registered directly to an organization, the
    WHOIS query will return that organization’s name. However, many times a company
    will simply utilize IP address space from an ISP without registering it directly
    to itself. In these cases, another useful tactic is to search for the *autonomous
    system number (ASN)* that is associated with an IP address. Organizations are
    required to register for an ASN to support certain types of routing on the public
    internet. There are a number of ways to look up IP-to-ASN associations (some WHOIS
    lookups provide it automatically), but I like using Team Cymru’s automated lookup
    tool (*[https://asn.cymru.com/](https://asn.cymru.com/)*). Using that tool for
    38.102.136.125, we see that it is associated with AS 36347, which is associated
    with “Wunderground – The Weather Channel, LLC, US” ([Figure 10-10](ch10.xhtml#ch10fig10)).
    That tells us that the device the weather station is communicating with is at
    least in the right neighborhood. If we were unable to identify the correct affiliation
    for this address, it might be worth exploring whether Pete’s receiver was talking
    to the wrong device, but the address checks out.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，如果一个 IP 地址直接注册到某个组织，WHOIS 查询会返回该组织的名称。然而，很多时候公司只是利用互联网服务提供商（ISP）的 IP
    地址空间，而没有将其直接注册到自己名下。在这些情况下，另一个有用的策略是搜索与 IP 地址相关联的 *自治系统号码（ASN）*。组织需要注册 ASN 以支持公共互联网中的某些类型路由。有多种方式可以查找
    IP 到 ASN 的关联（一些 WHOIS 查询会自动提供），但我喜欢使用 Team Cymru 的自动查找工具 (*[https://asn.cymru.com/](https://asn.cymru.com/)*)。通过这个工具查询
    38.102.136.125，我们看到它与 AS 36347 相关联，而 AS 36347 又与“Wunderground – The Weather Channel,
    LLC, US”相关联（[图 10-10](ch10.xhtml#ch10fig10)）。这告诉我们，天气站正在与设备进行通信，至少该设备在正确的网络环境中。如果我们无法识别该地址的正确归属，可能需要探索
    Pete 的接收器是否与错误的设备通信，但该地址是正确的。
- en: '![image](../images/f208-01.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f208-01.jpg)'
- en: '*Figure 10-10: IP-to-ASN lookup for the external IP address*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-10：外部 IP 地址的 IP 到 ASN 查找*'
- en: With the unknown host characterized, we can dig into details of the communication.
    The conversation is relatively short. There is a TCP handshake, a single HTTP
    `GET` request and response, and a TCP teardown. The handshake and teardown appear
    to be successful, so whatever issue we are experiencing is probably contained
    with the HTTP request itself. To examine this closely, we’ll follow the TCP stream
    ([Figure 10-11](ch10.xhtml#ch10fig11)).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在明确了未知主机之后，我们可以深入研究通信的细节。整个通信过程相对简短。它包括一次 TCP 握手，一个 `GET` 请求和响应，以及一次 TCP 拆除。握手和拆除看起来是成功的，因此我们遇到的问题很可能仅限于
    HTTP 请求本身。为了仔细检查这一点，我们将跟踪 TCP 流（[图 10-11](ch10.xhtml#ch10fig11)）。
- en: '![image](../images/f208-02.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f208-02.jpg)'
- en: '*Figure 10-11: Following the TCP stream of the weather receiver communication*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-11：跟踪天气接收器通信的 TCP 流*'
- en: The HTTP communication begins with a `GET` request from Pete’s weather receiver
    to Wunderground. No HTTP content was transmitted, but a significant amount of
    data was transmitted in the URL ➊. Transferring data through the URL query string
    is common for web applications, and it looks like the receiver is passing weather
    updates using this mechanism. For instance, you see fields like `tempf=43.0`,
    `dewptf=13.6`, and `windchillf=43.0`. The Wunderground collection server is parsing
    the list of fields and parameters from the URL and storing them in a database.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 通信从 Pete 的天气接收器向 Wunderground 发送的 `GET` 请求开始。没有传输 HTTP 内容，但在 URL ➊ 中传输了大量数据。通过
    URL 查询字符串传输数据在 Web 应用中很常见，看来接收器正通过这种机制传递天气更新。例如，你可以看到字段如 `tempf=43.0`、`dewptf=13.6`
    和 `windchillf=43.0`。Wunderground 的收集服务器正在从 URL 中解析字段和参数列表，并将它们存储在数据库中。
- en: At first glance, everything looks fine with the `GET` request to the Wunderground
    server. But a look at the corresponding reply shows an error was reported. The
    server responded with an `HTTP/1.0 200 OK` response code ➋, indicating that the
    `GET` request was received and successful, but the body of the response contains
    a useful message, `INVALIDPASSWORDID|Password or key and/or id are incorrect`
    ➌.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，向 Wunderground 服务器发送的 `GET` 请求似乎一切正常。但查看相应的回复时发现报告了一个错误。服务器响应了一个 `HTTP/1.0
    200 OK` 响应代码 ➋，表示 `GET` 请求已接收并成功，但响应体中包含一条有用的消息：`INVALIDPASSWORDID|密码或密钥和/或 ID
    不正确` ➌。
- en: If you look back up at the request URL, you’ll see the first two parameters
    passed are `ID` and `PASSWORD`. These are used to identify the weather station
    call sign and authenticate it to the Wunderground server.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回过头看一下请求 URL，你会发现传递的前两个参数是`ID`和`PASSWORD`。这两个参数用于识别气象站的呼号并将其认证到 Wunderground
    服务器。
- en: In this case, Pete’s weather station ID is correct, but his password is not.
    For some unknown reason, it has been replaced by zeros. Since the last known successful
    communication was at midnight, it’s possible an update was applied or the receiver
    rebooted and lost the password configuration.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Pete 的气象站 ID 是正确的，但密码不正确。由于某种未知原因，它被替换成了零。由于上次已知的成功通信发生在午夜，因此有可能是应用了某次更新，或者接收器重启后丢失了密码配置。
- en: '**NOTE**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*While many developers choose to pass parameters in URLs, it’s generally frowned
    upon to do this with passwords as seen here. That’s because requested URLs are
    transmitted in plaintext when using HTTP without added encryption, such as HTTPS.
    Therefore, a malicious user who happens to be listening on the wire could intercept
    your password.*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然许多开发人员选择在 URL 中传递参数，但通常不推荐像这里一样将密码放在 URL 中。因为在使用 HTTP 时，所请求的 URL 会以明文形式传输，除非添加了加密，例如
    HTTPS。因此，任何一个恰巧监听网络的恶意用户都可能拦截你的密码。*'
- en: At this point, Pete was able to access his receiver and type in the new password.
    Shortly thereafter, his weather station began syncing data again. An example of
    successful weather station communication can be found in *weather_working.pcapng*.
    The communication stream is shown in [Figure 10-12](ch10.xhtml#ch10fig12).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，Pete 能够访问他的接收器并输入新密码。没过多久，他的气象站开始重新同步数据。成功的气象站通信示例可以在 *weather_working.pcapng*
    中找到。通信流如 [图 10-12](ch10.xhtml#ch10fig12) 所示。
- en: '![image](../images/f209-01.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f209-01.jpg)'
- en: '*Figure 10-12: Successful weather station communication*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-12：成功的气象站通信*'
- en: The password is now correct ➊, and the Wunderground server responds with a `success`
    message in the HTTP response body ➋.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在密码是正确的 ➊，Wunderground 服务器在 HTTP 响应体中返回了 `success` 消息 ➋。
- en: '***Lessons Learned***'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***经验教训***'
- en: In this scenario, we encountered a third-party service that facilitated network
    communication by using features available within another protocol (HTTP). Fixing
    communication problems with third-party services is something you’ll encounter
    often, and packet analysis techniques are very well suited for troubleshooting
    these services when proper documentation or error logging isn’t available. This
    is becoming more common now that Internet of Things (IoT) devices, such as this
    weather station, are popping up all around us.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们遇到了一个第三方服务，通过使用另一种协议（HTTP）中可用的功能来促进网络通信。解决第三方服务的通信问题是你经常会遇到的事情，而当没有合适的文档或错误日志时，数据包分析技术非常适合用于排查这些服务的问题。随着物联网（IoT）设备的普及，如本示例中的气象站，这种情况变得越来越常见。
- en: Fixing such problems requires the ability to inspect unknown traffic sequences
    and derive how things are supposed to be working. Some applications, such as the
    HTTP-based weather data transmission in this scenario, are fairly simple. Others
    are quite complex, requiring multiple transactions, the addition of encryption,
    or even custom protocols that Wireshark may not natively parse.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题需要能够检查未知的流量序列，并推断出事物应该如何工作。一些应用程序，如本场景中的基于 HTTP 的气象数据传输，比较简单。而其他一些应用则相当复杂，可能涉及多个事务、添加加密，甚至是
    Wireshark 无法原生解析的自定义协议。
- en: As you investigate more third-party services, you’ll eventually start learning
    about common patterns developers use to facilitate network communication. This
    knowledge will increase your effectiveness when troubleshooting them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调查更多第三方服务时，你最终会开始了解开发人员用来促进网络通信的常见模式。这些知识将提高你在排查问题时的效率。
- en: '**No Internet Access**'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**无互联网访问**'
- en: In many scenarios, you may need to diagnose and solve internet connectivity
    problems. We’ll cover some common problems you might encounter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你可能需要诊断和解决互联网连接问题。我们将讨论一些你可能遇到的常见问题。
- en: '***Gateway Configuration Problems***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***网关配置问题***'
- en: '*nowebaccess1.pcapng*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*nowebaccess1.pcapng*'
- en: 'Our next scenario presents a common problem: a user cannot access the internet.
    We have verified that the user can access all the internal resources of the network,
    including shares on other workstations and applications hosted on local servers.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个场景呈现了一个常见问题：用户无法访问互联网。我们已确认用户可以访问网络的所有内部资源，包括其他工作站的共享资源和本地服务器上托管的应用程序。
- en: The network architecture is straightforward, as all clients and servers connect
    to a series of simple switches. Internet access is handled through a single router
    serving as the default gateway, and IP-addressing information is provided by DHCP.
    This is a very common scenario in small offices.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 网络架构非常简单，因为所有的客户端和服务器都连接到一系列简单的交换机。互联网接入通过一个路由器处理，该路由器作为默认网关，IP地址信息由DHCP提供。这是小型办公室中非常常见的场景。
- en: '**Tapping into the Wire**'
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**接入网络**'
- en: To determine the cause of the issue, we can have the user attempt to browse
    the internet while our sniffer is listening on the wire. We use the information
    from [Chapter 2](ch02.xhtml#ch02) (see [Figure 2-15](ch02.xhtml#ch02fig15)) to
    determine the most appropriate method for placing our sniffer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定问题的原因，我们可以让用户在我们监听网络时尝试浏览互联网。我们使用[第2章](ch02.xhtml#ch02)中的信息（见[图2-15](ch02.xhtml#ch02fig15)）来确定放置嗅探器的最合适方法。
- en: The switches on our network don’t support port mirroring. We already have to
    interrupt the user to conduct our test, so we can assume that it is okay to take
    them offline once again. Even though this isn’t a high-throughput scenario, a
    TAP would be appropriate here if one were available. The resulting file is *nowebaccess1.pcapng*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们网络中的交换机不支持端口镜像。我们已经需要中断用户以进行测试，因此我们可以假设再次将用户下线是可以的。即使这不是一个高吞吐量的场景，如果有TAP设备，使用它也是合适的。生成的文件是*nowebaccess1.pcapng*。
- en: '**Analysis**'
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**分析**'
- en: The traffic capture begins with an ARP request and reply, as shown in [Figure
    10-13](ch10.xhtml#ch10fig13). In packet 1, the user’s computer, with a MAC address
    of 00:25:b3:bf:91:ee and IP address 172.16.0.8, sends an ARP broadcast packet
    to all computers on the network segment in an attempt to find the MAC address
    associated with the IP address of its default gateway, 172.16.0.10.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 流量捕获始于一个ARP请求和回复，如[图10-13](ch10.xhtml#ch10fig13)所示。在数据包1中，用户的计算机，MAC地址为00:25:b3:bf:91:ee，IP地址为172.16.0.8，向网络段上的所有计算机广播ARP数据包，试图找到与其默认网关的IP地址172.16.0.10相关联的MAC地址。
- en: '![image](../images/f211-01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f211-01.jpg)'
- en: '*Figure 10-13: ARP request and reply for the computer’s default gateway*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-13：计算机默认网关的ARP请求和回复*'
- en: A response is received in packet 2, and the user’s computer learns that 172.16.0.10
    is at 00:24:81:a1:f6:79\. Once this reply is received, the computer has a route
    to a gateway that should be able to direct it to the internet.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据包2中接收到一个响应，用户的计算机得知172.16.0.10的MAC地址是00:24:81:a1:f6:79。一旦接收到这个回复，计算机便有了通往网关的路由，网关应该能够将其引导到互联网。
- en: Following the ARP reply, the computer must attempt to resolve the DNS name of
    the website to an IP address using DNS in packet 3\. As shown in [Figure 10-14](ch10.xhtml#ch10fig14),
    the computer does this by sending a DNS query packet to its primary DNS server,
    4.2.2.2 ➊.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在ARP回复之后，计算机必须尝试通过DNS解析网站的DNS名称为IP地址，在数据包3中完成。如[图10-14](ch10.xhtml#ch10fig14)所示，计算机通过向其主要DNS服务器4.2.2.2发送DNS查询数据包来执行此操作➊。
- en: '![image](../images/f211-02.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f211-02.jpg)'
- en: '*Figure 10-14: A DNS query sent to 4.2.2.2*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-14：发送到4.2.2.2的DNS查询*'
- en: Under normal circumstances, a DNS server would respond to a DNS query very quickly,
    but that’s not the case here. Rather than a response, we see the same DNS query
    sent a second time to a different destination address. As shown in [Figure 10-15](ch10.xhtml#ch10fig15),
    in packet 4, the second DNS query is sent to the secondary DNS server configured
    on the computer, which is 4.2.2.1 ➊.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，DNS服务器会非常快速地响应DNS查询，但这里并非如此。我们没有收到响应，而是看到同样的DNS查询第二次发送到不同的目标地址。如[图10-15](ch10.xhtml#ch10fig15)所示，在数据包4中，第二个DNS查询被发送到计算机上配置的备用DNS服务器4.2.2.1➊。
- en: '![image](../images/f211-03.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f211-03.jpg)'
- en: '*Figure 10-15: A second DNS query sent to 4.2.2.1*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-15：发送到4.2.2.1的第二个DNS查询*'
- en: Again, no reply is received from the DNS server, and the query is sent again
    1 second later to 4.2.2.2\. This process repeats itself, alternating between the
    primary ➊ and secondary ➋ configured DNS servers over the next several seconds,
    as shown in [Figure 10-16](ch10.xhtml#ch10fig16). The entire process takes around
    8 seconds ➌, or until the user’s internet browser reports that a website is inaccessible.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，由于没有收到DNS服务器的回复，查询在1秒后再次发送到4.2.2.2。这个过程会重复进行，在接下来的几秒钟内，查询会在主DNS服务器➊和备用DNS服务器➋之间交替进行，如[图10-16](ch10.xhtml#ch10fig16)所示。整个过程大约需要8秒钟➌，或者直到用户的互联网浏览器报告无法访问网站。
- en: '![image](../images/f212-01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f212-01.jpg)'
- en: '*Figure 10-16: DNS queries are repeated until communication stops.*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-16：DNS查询会一直重复，直到通信停止。*'
- en: Based on the packets we’ve seen, we can begin to pinpoint the source of the
    problem. First, we see a successful ARP request to what we believe is the default
    gateway router for the network, so we know that device is online and communicating.
    We also know that the user’s computer is actually transmitting packets on the
    network, so we can assume there isn’t an issue with the protocol stack on the
    computer itself. The problem clearly begins to occur when the DNS request is made.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们看到的数据包，我们可以开始定位问题的根源。首先，我们看到一个成功的ARP请求，目标是我们认为是网络默认网关路由器的设备，所以我们知道该设备在线并且在通信。我们还知道用户的计算机实际上正在向网络发送数据包，因此可以假设计算机本身的协议栈没有问题。问题显然在DNS请求发出时发生。
- en: In the case of this network, DNS queries are resolved by an external server
    on the internet (4.2.2.2 or 4.2.2.1). This means that for resolution to take place
    correctly, the router responsible for routing packets to the internet must successfully
    forward the DNS queries to the server, and the server must respond. This all must
    happen before HTTP can be used to request the web page itself.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在该网络中，DNS查询由互联网上的外部服务器（4.2.2.2或4.2.2.1）解析。这意味着，要正确解析，负责将数据包路由到互联网的路由器必须成功地将DNS查询转发到服务器，并且服务器必须做出响应。在HTTP请求网页之前，这一切都必须先发生。
- en: Because no other users are having issues connecting to the internet, the network
    router and remote DNS server are probably not the source of the problem. The only
    thing remaining to investigate is the user’s computer itself.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因为没有其他用户遇到连接互联网的问题，所以网络路由器和远程DNS服务器可能不是问题的根源。剩下需要调查的唯一问题就是用户的计算机本身。
- en: Upon deeper examination of the affected computer, we find that rather than receiving
    a DHCP-assigned address, the computer has manually assigned addressing information,
    and the default gateway address is set incorrectly. The address set as the default
    gateway is not a router and cannot forward the DNS query packets outside the network.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在对受影响的计算机进行更深入检查后，我们发现计算机并没有收到由DHCP分配的地址，而是手动设置了地址信息，并且默认网关地址设置错误。设置为默认网关的地址不是路由器，无法将DNS查询数据包转发到网络外部。
- en: '**Lessons Learned**'
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**经验教训**'
- en: The problem in this scenario resulted from a misconfigured client. While the
    problem itself turned out to be simple, it significantly impacted the user. Troubleshooting
    a simple misconfiguration like this one could take quite some time for someone
    lacking knowledge of the network or the ability to perform a quick packet analysis,
    as we’ve done here. As you can see, packet analysis is not limited to large and
    complex problems.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景中的问题源于客户端配置错误。虽然问题本身很简单，但对用户的影响却很大。对于缺乏网络知识或无法进行快速数据包分析的人员来说，像这样一个简单的配置错误可能需要相当长的时间来排除，就像我们这里所做的那样。正如你所看到的，数据包分析并不限于大型复杂的问题。
- en: Notice that because we didn’t enter the scenario knowing the IP address of the
    network’s gateway router, Wireshark didn’t identify the problem exactly, but it
    did tell us where to look, saving valuable time. Rather than examining the gateway
    router, contacting our ISP, or trying to find the resources to troubleshoot the
    remote DNS server, we were able to focus our troubleshooting efforts on the computer
    itself, which was, in fact, the source of the problem.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们在进入场景时并不知道网络网关路由器的IP地址，Wireshark没有准确识别问题，但它确实告诉我们该往哪里找，节省了宝贵的时间。与其检查网关路由器、联系ISP，或尝试找到资源来排除远程DNS服务器的问题，我们能够将故障排除的重点放在计算机本身，事实证明，问题的根源就在于此。
- en: '**NOTE**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Had we been more familiar with this particular network’s IP-addressing scheme,
    analysis could have been even faster. The problem could have been identified immediately
    once we noticed that the ARP request was sent to an IP address different from
    that of the gateway router. These simple misconfigurations are often the source
    of network problems and can typically be resolved quickly with a bit of packet
    analysis.*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果我们对该特定网络的IP地址分配方案更为熟悉，分析可能会更加迅速。一旦我们发现ARP请求发送到了与网关路由器不同的IP地址，我们就能立即识别出问题。这类简单的配置错误通常是网络问题的根源，并且通过一些数据包分析通常可以迅速解决。*'
- en: '***Unwanted Redirection***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***不需要的重定向***'
- en: '*nowebaccess2.pcapng*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*nowebaccess2.pcapng*'
- en: In this scenario, we again have a user who is having trouble accessing the internet
    from their workstation. However, unlike the user in the previous scenario, this
    user can access the internet. Their problem is that they can’t access their home
    page, *[https://www.google.com/](https://www.google.com/)*. When the user attempts
    to reach any domain hosted by Google, they are directed to a browser page that
    says, “Internet Explorer cannot display the web page.” This issue is affecting
    only this particular user.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们再次遇到一个用户，正在遇到无法从工作站访问互联网的问题。然而，与前一情形中的用户不同，这个用户能够访问互联网。他们的问题是无法访问主页，*
    [https://www.google.com/](https://www.google.com/)*。当用户尝试访问任何由Google托管的域时，他们被引导到一个浏览器页面，显示“Internet
    Explorer无法显示网页”。这个问题只影响这个特定的用户。
- en: As with the previous scenario, this is a small network with a few simple switches
    and a single router serving as the default gateway.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的情况一样，这也是一个小型网络，拥有一些简单的交换机和一个作为默认网关的路由器。
- en: '**Tapping into the Wire**'
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**接入网络**'
- en: To begin our analysis, we have the user attempt to browse to *[https://www.google.com/](https://www.google.com/)*
    while we use a tap to listen to the traffic that is generated. The resulting file
    is *nowebaccess2.pcapng*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始分析，我们让用户尝试访问*[https://www.google.com/](https://www.google.com/)*，同时我们通过一个监听点来捕获生成的流量。结果生成的文件是*nowebaccess2.pcapng*。
- en: '**Analysis**'
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**分析**'
- en: The capture begins with an ARP request and reply, as shown in [Figure 10-17](ch10.xhtml#ch10fig17).
    In packet 1, the user’s computer, with a MAC address of 00:25:b3:bf:91:ee and
    an IP address of 172.16.0.8, sends an ARP broadcast packet to all computers on
    the network segment in an attempt to find the MAC address associated with the
    host’s IP address 172.16.0.102\. We don’t immediately recognize this address.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获开始时是一个ARP请求和回复，如[图10-17](ch10.xhtml#ch10fig17)所示。在数据包1中，用户的计算机，MAC地址为00:25:b3:bf:91:ee，IP地址为172.16.0.8，向网络段上的所有计算机广播ARP数据包，试图找到与主机IP地址172.16.0.102关联的MAC地址。我们暂时没有识别出这个地址。
- en: '![image](../images/f213-01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f213-01.jpg)'
- en: '*Figure 10-17: ARP request and reply for another device on the network*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-17：网络上另一个设备的ARP请求和回复*'
- en: In packet 2, the user’s computer learns that the IP address 172.16.0.102 is
    at 00:21:70:c0:56:f0\. Based on the previous scenario, we might assume that this
    is the gateway router’s address and that address is used so that packets can once
    again be forwarded to the external DNS server. However, as shown in [Figure 10-18](ch10.xhtml#ch10fig18),
    the next packet is not a DNS request but a TCP packet from 172.16.0.8 to 172.16.0.102\.
    It has the SYN flag set ➌, indicating that this is the first packet in the handshake
    for a new TCP-based connection between the two hosts.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据包2中，用户的计算机得知IP地址172.16.0.102对应的MAC地址是00:21:70:c0:56:f0。基于之前的情形，我们可能会假设这是网关路由器的地址，并且该地址被用来转发数据包到外部DNS服务器。然而，如[图10-18](ch10.xhtml#ch10fig18)所示，接下来的数据包并不是DNS请求，而是从172.16.0.8到172.16.0.102的TCP数据包。它设置了SYN标志➌，表明这是两个主机之间建立新TCP连接的握手中的第一个数据包。
- en: '![image](../images/f214-01.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f214-01.jpg)'
- en: '*Figure 10-18: TCP SYN packet sent from one internal host to another*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-18：从一个内部主机发送到另一个主机的TCP SYN数据包*'
- en: Notably, the TCP connection attempt is made to port 80 ➋ on 172.16.0.102 ➊,
    which is typically associated with HTTP traffic.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，TCP连接尝试是向172.16.0.102 ➊的端口80 ➋发起的，该端口通常与HTTP流量相关。
- en: As shown in [Figure 10-19](ch10.xhtml#ch10fig19), this connection attempt is
    abruptly halted when host 172.16.0.102 sends a TCP packet in response (packet
    4) with the RST and ACK flags set ➊.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图10-19](ch10.xhtml#ch10fig19)所示，当主机172.16.0.102发送一个TCP数据包（数据包4）并设置了RST和ACK标志➊时，连接尝试被突然中断。
- en: '![image](../images/f214-02.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f214-02.jpg)'
- en: '*Figure 10-19: TCP RST packet sent in response to the TCP SYN*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-19：响应TCP SYN的TCP RST数据包*'
- en: Recall from [Chapter 8](ch08.xhtml#ch08) that a packet with the RST flag set
    is used to terminate a TCP connection. Here, the host at 172.16.0.8 attempted
    to establish a TCP connection to the host at 172.16.0.102 on port 80\. Unfortunately,
    because that host has no services configured to listen to requests on port 80,
    the TCP RST packet is sent to terminate the connection. This process repeats three
    times before communication finally ends, as shown in [Figure 10-20](ch10.xhtml#ch10fig20).
    At this point, the user receives a message in their browser saying that the page
    can’t be displayed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第8章](ch08.xhtml#ch08)，当RST标志位设置时，数据包用于终止TCP连接。在这里，IP地址为172.16.0.8的主机尝试与IP地址为172.16.0.102的主机在80端口建立TCP连接。不幸的是，因为该主机没有配置监听80端口请求的服务，所以发送了TCP
    RST数据包来终止连接。此过程重复了三次，最终通信结束，正如在[图10-20](ch10.xhtml#ch10fig20)中所示。此时，用户在浏览器中收到一条消息，表示页面无法显示。
- en: '![image](../images/f215-01.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f215-01.jpg)'
- en: '*Figure 10-20: The TCP SYN and RST packets are seen three times in total.*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-20：TCP SYN和RST数据包共出现了三次。*'
- en: 'After examining the configuration of another network device that is working
    correctly, we are concerned by the ARP request and reply in packets 1 and 2, because
    the ARP request isn’t for the gateway router’s actual MAC address but for some
    unknown device. Following the ARP request and reply, we would expect to see a
    DNS query sent to our configured DNS server in order to find the IP address associated
    with *[https://www.google.com/](https://www.google.com/)*, but we don’t. There
    are two conditions that could prevent a DNS query from being made:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查了另一台正常工作的网络设备的配置后，我们对数据包1和2中的ARP请求和回复感到担忧，因为ARP请求不是针对网关路由器的实际MAC地址，而是针对某个未知设备。紧接着ARP请求和回复，我们预计会看到一个DNS查询发送到我们配置的DNS服务器，以便查找与*[https://www.google.com/](https://www.google.com/)*相关联的IP地址，但实际上没有。可能阻止DNS查询发生的两种情况是：
- en: •     The device initiating the connection already has the DNS name-to-IP address
    mapping in its DNS cache (as in the first scenario in this chapter).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: •     发起连接的设备已经在其DNS缓存中拥有DNS名称到IP地址的映射（如本章第一个场景所示）。
- en: •     The device connecting to the DNS name already has the DNS name-to-IP address
    mapping specified in its *hosts* file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: •     连接到DNS名称的设备已经在其*hosts*文件中指定了DNS名称到IP地址的映射。
- en: Upon further examination of the client computer, we find that the computer’s
    *hosts* file has an entry for *[https://www.google.com/](https://www.google.com/)*
    associated with the internal IP address 172.16.0.102\. This erroneous entry is
    the source of our user’s problems.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步检查客户端计算机后，我们发现该计算机的*hosts*文件中有一条与内部IP地址172.16.0.102关联的*[https://www.google.com/](https://www.google.com/)*条目。这个错误的条目是导致用户问题的根源。
- en: A computer will typically use its *hosts* file as the authoritative source for
    DNS name-to-IP address mappings, and it will check that file before querying an
    outside source. In this scenario, the user’s computer checked its *hosts* file,
    found the entry for *[https://www.google.com/](https://www.google.com/)*, and
    decided that *[https://www.google.com/](https://www.google.com/)* was actually
    on its own local network segment. Next, it sent an ARP request to the host, received
    a response, and attempted to initiate a TCP connection to 172.16.0.102 on port
    80\. However, because the remote system was not configured as a web server, it
    wouldn’t accept the connection attempts.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机通常会将其*hosts*文件作为DNS名称到IP地址映射的权威来源，并且在查询外部源之前会检查该文件。在这个场景中，用户的计算机检查了其*hosts*文件，发现了与*[https://www.google.com/](https://www.google.com/)*相关的条目，并决定*[https://www.google.com/](https://www.google.com/)*实际上位于它自己的本地网络段。接下来，它发送了一个ARP请求到该主机，收到了响应，并尝试与172.16.0.102的80端口建立TCP连接。然而，由于远程系统未配置为Web服务器，它未能接受连接尝试。
- en: Once the *hosts* file entry was removed, the user’s computer began communicating
    correctly and was able to access *[https://www.google.com/](https://www.google.com/)*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦移除了*hosts*文件中的条目，用户的计算机开始正确地进行通信，并且能够访问*[https://www.google.com/](https://www.google.com/)*。
- en: '**NOTE**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To examine your* hosts *file on a Windows system, open* C:\Windows\System32\
    drivers\etc\hosts*. On Linux, view* /etc/hosts.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*要检查Windows系统上的*hosts*文件，请打开*C:\Windows\System32\drivers\etc\hosts*。在Linux上，查看*/etc/hosts*。'
- en: This very common scenario is one that malware has been using for years to redirect
    users to websites hosting malicious code. Imagine if an attacker were to modify
    your *hosts* file so that every time you went to do your online banking, you were
    redirected to a fake site designed to steal your account credentials!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种非常常见的情况是恶意软件多年来一直在使用的，用来将用户重定向到托管恶意代码的网站。试想，如果攻击者修改了你的*hosts*文件，让你每次进行网上银行操作时，都被重定向到一个旨在窃取账户凭证的假网站！
- en: '**Lessons Learned**'
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**经验教训**'
- en: As you continue to analyze traffic, you will learn both how the various protocols
    work and how to break them. In this scenario, the DNS query wasn’t sent because
    the client was misconfigured, not because of any external limitations or misconfigurations.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当你继续分析流量时，你会了解到各种协议如何工作以及如何破坏它们。在这个场景中，DNS查询没有发送，是因为客户端配置错误，而不是由于外部的限制或配置错误。
- en: By examining this problem at the packet level, we were able to quickly spot
    an IP address that was unknown and to determine that the DNS, a key component
    of this communication process, was missing. Using this information, we were able
    to identify the client as the source of the problem.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在数据包级别检查这个问题，我们能够迅速发现一个未知的IP地址，并确定通信过程中的关键组件DNS丢失。通过这些信息，我们能够将问题源归结为客户端。
- en: '***Upstream Problems***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***上游问题***'
- en: '*nowebaccess3.pcapng*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*nowebaccess3.pcapng*'
- en: As with the previous two scenarios, in this scenario, a user complains of no
    internet access from their workstation. This user has narrowed the issue down
    to a single website, *[https://www.google.com/](https://www.google.com/)*. Upon
    further investigation, we find that this issue is affecting everyone in the organization—no
    one can access Google domains.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与前两个场景类似，在这个场景中，用户抱怨工作站无法访问互联网。该用户已将问题缩小到一个网站，* [https://www.google.com/](https://www.google.com/)*。进一步调查后，我们发现这个问题影响了组织中的所有人——没有人能够访问Google域名。
- en: The network is configured as in the two prior scenarios, with a few simple switches
    and a single router connecting the network to the internet.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 网络配置与之前的两个场景相同，只有一些简单的交换机和一台路由器将网络连接到互联网。
- en: '**Tapping into the Wire**'
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**接入线路**'
- en: To troubleshoot this issue, we first browse to *[https://www.google.com/](https://www.google.com/)*
    to generate traffic. Because this issue is network-wide, ideally any device in
    the network should be able to reproduce the issue using most capture methods.
    The file resulting from the capture via a tap is *nowebaccess3.pcapng*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们首先访问* [https://www.google.com/](https://www.google.com/)* 来生成流量。由于这个问题是全网络范围的，理想情况下网络中的任何设备都应该能够通过大多数捕获方法重现这个问题。通过接入捕获得到的文件是
    *nowebaccess3.pcapng*。
- en: '**Analysis**'
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**分析**'
- en: This packet capture begins with DNS traffic instead of the ARP traffic we are
    used to seeing. Because the first packet in the capture is to an external address,
    and packet 2 contains a reply from that address, we can assume that the ARP process
    has already happened and the MAC-to-IP address mapping for our gateway router
    already exists in the host’s ARP cache at 172.16.0.8.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据包捕获从DNS流量开始，而不是我们习惯看到的ARP流量。因为捕获中的第一个数据包是发送到外部地址的，且数据包2包含来自该地址的回复，我们可以假设ARP过程已经完成，网关路由器的MAC到IP地址映射已经存在于主机的ARP缓存中，地址为172.16.0.8。
- en: As shown in [Figure 10-21](ch10.xhtml#ch10fig21), the first packet in the capture
    is from the host 172.16.0.8 to address 4.2.2.1 ➊ and is a DNS packet ➋. Examining
    the contents of the packet, we see that it is a query for the A record for *[www.google.com](http://www.google.com)*
    ➌ that will map the DNS name to an IP address.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图10-21](ch10.xhtml#ch10fig21)所示，捕获中的第一个数据包是从主机172.16.0.8发送到地址4.2.2.1 ➊，这是一个DNS数据包
    ➋。检查数据包的内容，我们看到这是一个查询* [www.google.com](http://www.google.com)*的A记录 ➌，用于将DNS名称映射到IP地址。
- en: '![image](../images/f217-01.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f217-01.jpg)'
- en: '*Figure 10-21: DNS query for* [www.google.com](http://www.google.com) *A record*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-21：* [www.google.com](http://www.google.com) *的DNS查询A记录*'
- en: The response to the query from 4.2.2.1 is the second packet in the capture file,
    as shown in [Figure 10-22](ch10.xhtml#ch10fig22). Here, we see that the name server
    that responded to this request provided multiple answers to the query ➊. At this
    point, all looks good, and communication is occurring as it should.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 来自4.2.2.1的查询响应是捕获文件中的第二个数据包，如[图10-22](ch10.xhtml#ch10fig22)所示。在这里，我们看到响应这个请求的名称服务器为查询提供了多个答案
    ➊。此时，一切看起来都正常，通信也按预期进行。
- en: '![image](../images/f217-02.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f217-02.jpg)'
- en: '*Figure 10-22: DNS reply with multiple A records*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-22：DNS回复包含多个A记录*'
- en: Now that the user’s computer has determined the web server’s IP address, it
    can attempt to communicate with the server. As shown in [Figure 10-23](ch10.xhtml#ch10fig23),
    this process is initiated in packet 3, with a TCP packet sent from 172.16.0.8
    to 74.125.95.105 ➊. This destination address comes from the first A record provided
    in the DNS query response seen in packet 2\. The TCP packet has the SYN flag set
    ➋, and it’s attempting to communicate with the remote server on port 80 ➌.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用户的计算机已经确定了Web服务器的IP地址，它可以尝试与服务器进行通信。如[图10-23](ch10.xhtml#ch10fig23)所示，这一过程在数据包3中开始，TCP数据包从172.16.0.8发送到74.125.95.105
    ➊。这个目标地址来自DNS查询响应中看到的第一个A记录，即数据包2中的内容。该TCP数据包的SYN标志被设置 ➋，并且它尝试与远程服务器在端口80上进行通信
    ➌。
- en: '![image](../images/f218-01.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f218-01.jpg)'
- en: '*Figure 10-23: The SYN packet is attempting to initiate a connection on port
    80.*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-23：SYN数据包正在尝试在端口80上发起连接。*'
- en: Because this is a TCP handshake process, we know that we should see a TCP SYN/ACK
    packet sent in response, but instead, after a short time, another SYN packet is
    sent from the source to the destination. This process occurs once more after approximately
    one second, as shown in [Figure 10-24](ch10.xhtml#ch10fig24), at which point communication
    stops and the browser reports that the website could not be found.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个TCP握手过程，我们知道应该会收到一个TCP SYN/ACK数据包作为响应，但实际上，在短暂的时间后，源主机再次向目标发送了另一个SYN数据包。大约一秒钟后，这一过程再次发生，如[图10-24](ch10.xhtml#ch10fig24)所示，随后通信停止，浏览器显示无法找到该网站。
- en: '![image](../images/f218-02.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f218-02.jpg)'
- en: '*Figure 10-24: The TCP SYN packet is attempted three times with no response
    received.*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-24：尝试三次发送TCP SYN数据包，但没有收到响应。*'
- en: As we troubleshoot this scenario, consider that we know that the workstation
    within our network can connect to the outside world because the DNS query to our
    external DNS server at 4.2.2.1 is successful. The DNS server responds with what
    appears to be a valid address, and our hosts attempt to connect to one of those
    addresses. Also, the local workstation we are attempting to connect from appears
    to be functioning.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们排查这个问题时，请考虑到，我们知道网络内的工作站能够连接到外部世界，因为向外部DNS服务器（4.2.2.1）的DNS查询成功。DNS服务器响应了一个看起来有效的地址，我们的主机尝试连接这些地址之一。此外，我们试图连接的本地工作站似乎也是正常的。
- en: 'The problem is that the remote server simply isn’t responding to our connection
    requests; a TCP RST packet is not sent. This might occur for several reasons:
    a misconfigured web server, a corrupted protocol stack on the web server, or a
    packet-filtering device on the remote network (such as a firewall). Assuming there
    is no local packet-filtering device in place, all other potential solutions are
    on the remote network and beyond our control. In this case, the web server was
    not functioning correctly, and no attempt to access it succeeded. Once the problem
    was corrected on Google’s end, communication was able to proceed.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于远程服务器根本没有响应我们的连接请求；没有发送TCP RST数据包。这可能由多种原因引起：配置错误的Web服务器、Web服务器上的协议栈损坏，或者远程网络中的数据包过滤设备（如防火墙）。假设没有本地的数据包过滤设备，所有其他潜在的解决方案都在远程网络上，超出了我们的控制范围。在这种情况下，Web服务器无法正常工作，访问尝试均未成功。问题解决后，Google端修复了问题，通信才得以继续。
- en: '**Lessons Learned**'
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**经验教训**'
- en: In this scenario, the problem wasn’t one that we could correct. Our analysis
    determined that the issue wasn’t with the hosts on our network, our router, or
    the external DNS server providing us with name resolution services. The issue
    lay outside our network infrastructure.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，问题并不是我们能解决的。我们的分析表明，问题不在于我们网络中的主机、我们的路由器，或者提供名称解析服务的外部DNS服务器。问题在我们的网络基础设施之外。
- en: Sometimes discovering that a problem isn’t really ours not only relieves stress
    but also saves face when management comes knocking. I have fought with many ISPs,
    vendors, and software companies who claim that an issue is not their fault, but
    as you’ve just seen, packets don’t lie.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，发现问题并非我们自己的问题，不仅能减轻压力，还能在管理层找上门时挽回面子。我曾与许多ISP、供应商和软件公司发生过争执，他们声称问题不在他们，但正如你刚刚看到的，数据包是不会撒谎的。
- en: '**Inconsistent Printer**'
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**不稳定的打印机**'
- en: In the next scenario, an IT help desk administrator is having trouble resolving
    a printing issue. Users in the sales department are reporting that the high-volume
    printer is malfunctioning. When a user sends a large print job to the printer,
    it will print several pages and then stop printing before the job is done. Multiple
    driver configuration changes have been attempted but have been unsuccessful. The
    help desk staff would like you to ensure that this isn’t a network problem.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个场景中，一位 IT 帮助台管理员正在解决打印问题。销售部门的用户报告称，高容量打印机出现故障。当用户将大打印任务发送到打印机时，打印机会打印几页，然后在任务完成前停止打印。虽然已经尝试了多次驱动程序配置更改，但都没有成功。帮助台工作人员希望你能确保这不是网络问题。
- en: '***Tapping into the Wire***'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***连接到数据线***'
- en: '*inconsistent_printer.pcapng*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*inconsistent_printer.pcapng*'
- en: The common thread in this problem is the printer, so we begin by placing our
    sniffer as close to the printer as we can. While we can’t install Wireshark on
    the printer itself, the switches used in this network are advanced layer 3 switches,
    so we can use port mirroring. We’ll mirror the port used by the printer to an
    empty port and connect a laptop with Wireshark installed to this port. Once this
    setup is complete, we’ll have a user send a large print job to the printer so
    we can monitor the output. The resulting capture file is *inconsistent_printer.pcapng*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的共同点是打印机，因此我们首先将嗅探器放置在尽可能靠近打印机的位置。虽然我们不能在打印机上安装 Wireshark，但该网络使用的是先进的 3
    层交换机，因此我们可以使用端口镜像。我们将打印机使用的端口镜像到一个空闲端口，并将安装了 Wireshark 的笔记本电脑连接到该端口。一旦设置完成，我们将让用户向打印机发送大打印任务，以便我们监控输出。结果生成的捕获文件是
    *inconsistent_printer.pcapng*。
- en: '***Analysis***'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分析***'
- en: A TCP handshake between the network workstation sending the print job (172.16.0.8)
    and the printer (172.16.0.253) initiates the connection at the start of the capture
    file. Following the handshake, a 1,460-byte TCP data packet ➊ is sent to the printer
    in packet 4 ([Figure 10-25](ch10.xhtml#ch10fig25)). The amount of data can be
    seen in the far right side of the Info column in the Packet List pane or at the
    bottom of the TCP header information in the Packet Details pane.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 网络工作站（172.16.0.8）与打印机（172.16.0.253）之间的 TCP 握手开始时发起连接，并出现在捕获文件的开头。握手之后，一个 1,460
    字节的 TCP 数据包 ➊ 被发送到打印机，出现在数据包 4 中（[图 10-25](ch10.xhtml#ch10fig25)）。数据的数量可以在包列表窗格的最右侧的“信息”列中或在包详细信息窗格的
    TCP 头部信息的底部看到。
- en: '![image](../images/f220-01.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f220-01.jpg)'
- en: '*Figure 10-25: Data being transmitted to the printer over TCP*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-25：通过 TCP 向打印机传输的数据*'
- en: Following packet 4, another data packet is sent containing 1,460 bytes of data
    ➊, as you can see in [Figure 10-26](ch10.xhtml#ch10fig26). This data is acknowledged
    by the printer in packet 6 ➋.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据包 4 之后，又发送了一个数据包，包含 1,460 字节的数据 ➊，如[图 10-26](ch10.xhtml#ch10fig26)所示。打印机在数据包
    6 ➋ 中确认接收了这些数据。
- en: '![image](../images/f220-02.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f220-02.jpg)'
- en: '*Figure 10-26: Normal data transmission and TCP acknowledgments*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-26：正常的数据传输和 TCP 确认*'
- en: The flow of data continues until the last few packets in the capture are reached.
    Packet 121 is a TCP retransmission packet, and a sign of trouble, as shown in
    [Figure 10-27](ch10.xhtml#ch10fig27).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流会一直持续，直到捕获到最后几包数据。数据包 121 是一个 TCP 重传数据包，这是一个问题的迹象，如[图 10-27](ch10.xhtml#ch10fig27)所示。
- en: A TCP retransmission packet is sent when one device sends a TCP packet to a
    remote device and the remote device doesn’t acknowledge the transmission. Once
    a retransmission threshold is reached, the sending device assumes that the remote
    device did not receive the data, and it retransmits the packet. This process is
    repeated a few times before communication effectively stops.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个设备向远程设备发送 TCP 数据包，而远程设备没有确认接收时，会发送一个 TCP 重传数据包。一旦达到重传阈值，发送设备假设远程设备没有接收到数据，并重新传输该数据包。这个过程会重复几次，直到通信最终停止。
- en: '![image](../images/f221-01.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f221-01.jpg)'
- en: '*Figure 10-27: These TCP retransmission packets are a sign of a potential problem.*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-27：这些 TCP 重传数据包是潜在问题的迹象。*'
- en: In this scenario, the retransmission is sent from the client workstation to
    the printer because the printer failed to acknowledge the transmitted data. As
    shown in [Figure 10-27](ch10.xhtml#ch10fig27), if you expand the SEQ/ACK analysis
    portion of the TCP header ➊ along with the additional information beneath it,
    you can view the details of why this is a retransmission. According to the details
    processed by Wireshark, packet 121 is a retransmission of packet 120 ➌. Additionally,
    the retransmission timeout (RTO) for the retransmitted packet was around 5.5 seconds
    ➋.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，重传是从客户端工作站发送到打印机的，因为打印机未能确认已传输的数据。如[图10-27](ch10.xhtml#ch10fig27)所示，如果你展开TCP头部的SEQ/ACK分析部分➊以及其下的附加信息，你可以查看为何这是一次重传的详细信息。根据Wireshark处理的细节，第121包是第120包的重传➌。此外，重传数据包的重传超时（RTO）大约是5.5秒➋。
- en: When analyzing the delay between packets, you can change the time display format
    to suit your situation. In this case, because we want to see how long the retransmissions
    occurred after the previous packet was sent, change this option by selecting **View
    ▶ Time Display Format** and select **Seconds Since Previous Captured Packet**.
    Then, as shown in [Figure 10-28](ch10.xhtml#ch10fig28), you can clearly see that
    the retransmission in packet 121 occurs 5.5 seconds after the original packet
    (packet 120) is sent ➊.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析数据包之间的延迟时，你可以根据自己的情况调整时间显示格式。在本例中，由于我们希望查看重传发生在前一个数据包发送后多长时间，可以通过选择**查看 ▶
    时间显示格式**并选择**自上一捕获数据包以来的秒数**来更改此选项。然后，如[图10-28](ch10.xhtml#ch10fig28)所示，你可以清楚地看到，第121包的重传发生在原始数据包（第120包）发送后5.5秒➊。
- en: '![image](../images/f221-02.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f221-02.jpg)'
- en: '*Figure 10-28: Viewing the time between packets is useful for troubleshooting.*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-28：查看数据包之间的时间对于故障排除非常有用。*'
- en: The next packet is another retransmission of packet 120\. The RTO of this packet
    is 11.10 seconds, which includes the 5.5 seconds from the RTO of the previous
    packet. A look at the Time column of the Packet List pane tells us that this retransmission
    was sent 5.6 seconds after the previous retransmission. This appears to be the
    last packet in the capture file, and, not coincidentally, the printer stops printing
    at approximately this time.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个数据包是第120包的另一次重传。这个数据包的RTO是11.10秒，其中包括前一个数据包的5.5秒RTO。从数据包列表窗格的时间列中，我们可以看到这次重传是在前一次重传后5.6秒发送的。这似乎是捕获文件中的最后一个数据包，并且巧合的是，打印机大约在此时停止打印。
- en: In this scenario, we have the benefit of dealing with only two devices inside
    our own network, so we just need to determine whether the client workstation or
    the printer is to blame. We can see that data is flowing correctly for quite some
    time, and then at some point, the printer simply stops responding to the workstation.
    The workstation gives its best effort to get the data to its destination, as evidenced
    by the retransmissions, but the effort is met with no response. This issue is
    reproducible and happens regardless of which computer sends a print job, so we
    assume the printer is the source of the problem.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们的优势是只涉及到两个设备，且都在我们自己的网络内，因此我们只需要确定是客户端工作站还是打印机出了问题。我们可以看到，数据流在一段时间内是正常的，然后在某个时刻，打印机就停止了响应工作站。工作站尽力将数据发送到目的地，正如重传所证明的那样，但结果没有任何响应。这个问题是可以重现的，并且无论哪台计算机发送打印任务都会发生，所以我们推测问题出在打印机上。
- en: After further analysis, we find that the printer’s RAM is malfunctioning. When
    large print jobs are sent to the printer, it prints only a certain number of pages,
    likely until certain regions of memory are accessed. At that point, the memory
    issue causes the printer to be unable to accept any new data, and it ceases communication
    with the host transmitting the print job.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 经过进一步分析，我们发现打印机的RAM出现故障。当大量打印任务发送到打印机时，它只能打印一定数量的页面，可能直到访问到内存的某些区域为止。此时，内存问题导致打印机无法接收任何新数据，并停止与发送打印任务的主机通信。
- en: '***Lessons Learned***'
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***经验教训***'
- en: Although this printer problem wasn’t the result of a network issue, we were
    able to use Wireshark to pinpoint the problem. Unlike previous scenarios, this
    one centered solely on TCP traffic. Since TCP is concerned about reliably transmitting
    data, it often leaves us with useful information when two devices simply stop
    communicating.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这次打印机问题并非由网络故障引起，但我们仍然能够使用Wireshark定位问题。与之前的场景不同，这次问题完全集中在TCP流量上。由于TCP关注的是可靠的数据传输，因此当两个设备停止通信时，它通常会留下有用的信息。
- en: In this case, when communication abruptly stopped, we were able to pinpoint
    the location of the problem based on nothing more than TCP’s built-in retransmission
    functionality. As we continue through our scenarios, we will often rely on functionality
    like this to troubleshoot more complex issues.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当通信突然中断时，我们仅凭TCP的内建重传功能就能准确定位问题所在。在接下来的场景中，我们将经常依赖此类功能来排查更复杂的问题。
- en: '**No Branch Office Connectivity**'
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**分支办公室无法连接**'
- en: '*stranded_clientside.pcapng stranded_branchdns.pcapng*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*stranded_clientside.pcapng stranded_branchdns.pcapng*'
- en: In this scenario, we have a company with a central headquarters office and a
    newly deployed remote branch office. The company’s IT infrastructure is mostly
    contained within the central office using a Windows server-based domain. This
    infrastructure is supported by a domain controller, a DNS server, and an application
    server used to host web-based software used daily by the organization’s employees.
    The branch office is connected by routers to establish a wide area network (WAN)
    link. Inside the branch office are user workstations and a slave DNS server that
    should receive its resource record information from the upstream DNS server at
    the corporate headquarters. [Figure 10-29](ch10.xhtml#ch10fig29) shows a map of
    each office and how the offices are linked together.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一家公司，拥有一个中央总部办公室和一个新部署的远程分支办公室。公司的IT基础设施大多集中在总部办公室，使用基于Windows服务器的域。该基础设施由一个域控制器、一个DNS服务器和一个应用服务器组成，后者用于托管公司员工每天使用的基于Web的软件。分支办公室通过路由器连接，建立广域网（WAN）连接。分支办公室内部有用户工作站和一个从属DNS服务器，应该从总部的上游DNS服务器接收其资源记录信息。[图
    10-29](ch10.xhtml#ch10fig29)展示了每个办公室的地图以及办公室之间的连接方式。
- en: '![image](../images/f223-01.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f223-01.jpg)'
- en: '*Figure 10-29: The relevant components for the stranded branch office issue*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-29：孤立分支办公室问题相关组件*'
- en: The deployment team is rolling out new infrastructure to the branch office when
    it finds that no one can access the intranet web application server from the branch
    office network. This server is located at the main office and is accessed through
    the WAN link. This connectivity issue affects all users at the branch office.
    All users can access the internet and other resources within the branch.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 部署团队正在向分支办公室部署新基础设施时发现，没有人能够从分支办公室网络访问内网Web应用服务器。该服务器位于总部，通过WAN链接进行访问。这个连接问题影响了分支办公室的所有用户。所有用户都能访问互联网以及分支办公室内的其他资源。
- en: '***Tapping into the Wire***'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***接入网络***'
- en: Because the problem lies in communication between the main and branch offices,
    there are a couple of places we could collect data to start tracking down the
    problem. The problem could be with the clients inside the branch office, so we’ll
    start by port mirroring one of those computers to check what it sees on the wire.
    Once we’ve collected that information, we can use it to point toward other collection
    locations that might help solve the problem. The initial capture file obtained
    from one of the clients is *stranded_clientside.pcapng*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因为问题出在总部和分支办公室之间的通信，我们可以从几个地方收集数据，以开始追踪问题。问题可能出在分支办公室内部的客户端，因此我们将从镜像其中一台计算机的端口开始，检查它在网络中看到的内容。一旦收集到这些信息，我们可以利用它指向其他收集点，以帮助解决问题。从其中一台客户端获取的初始捕获文件是*stranded_clientside.pcapng*。
- en: '***Analysis***'
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分析***'
- en: As shown in [Figure 10-30](ch10.xhtml#ch10fig30), our first capture file begins
    when the user at the workstation address 172.16.16.101 attempts to access an application
    hosted on the headquarter’s app server, 172.16.16.200\. This capture contains
    only two packets. It appears as though a DNS request is sent to 172.16.16.251
    ➊ for the A record ➌ for `appserver` ➋ in the first packet. This is the DNS name
    for the server at 172.16.16.200 in the central office.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 10-30](ch10.xhtml#ch10fig30)所示，我们的第一个捕获文件开始于工作站地址172.16.16.101的用户尝试访问总部应用服务器172.16.16.200上托管的应用程序时。此捕获文件仅包含两个数据包。似乎第一个数据包发送了一个DNS请求到172.16.16.251
    ➊，请求`appserver` ➋的A记录 ➌。这是总部中央办公室中172.16.16.200服务器的DNS名称。
- en: As you can see in [Figure 10-31](ch10.xhtml#ch10fig31), the response to this
    packet is a server failure ➊, which indicates that something is preventing the
    DNS query from resolving successfully. Notice that this packet does not answer
    the query ➋ since it is an error (server failure).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 10-31](ch10.xhtml#ch10fig31)所示，响应此数据包的是服务器故障 ➊，这表明某些因素正在阻止DNS查询成功解析。请注意，此数据包没有回答查询
    ➋，因为它是一个错误（服务器故障）。
- en: '![image](../images/f224-01.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f224-01.jpg)'
- en: '*Figure 10-30: Communication begins with a DNS query for the `appserver` A
    record.*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-30：通信开始于 `appserver` A 记录的 DNS 查询。*'
- en: '![image](../images/f224-02.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f224-02.jpg)'
- en: '*Figure 10-31: The query response indicates a problem upstream.*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-31：查询响应表明上游存在问题。*'
- en: We now know that the communication problem is related to some DNS issue. Because
    the DNS queries at the branch office are resolved by the on-site DNS server at
    172.16.16.251, that’s our next stop.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道，通信问题与某些 DNS 问题有关。由于分支办公室的 DNS 查询是由位于 172.16.16.251 的本地 DNS 服务器解析的，因此这是我们下一个要检查的地方。
- en: To capture the appropriate traffic from the branch DNS server, we’ll leave our
    sniffer in place and simply change the port-mirroring assignment so that the DNS
    server’s traffic, rather than the workstation’s traffic, is now mirrored to our
    sniffer. The result is the file *stranded_branchdns.pcapng*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获来自分支 DNS 服务器的适当流量，我们将保持嗅探器不变，只需更改端口镜像分配，使得现在镜像到嗅探器的流量来自 DNS 服务器，而不是工作站的流量。结果就是文件
    *stranded_branchdns.pcapng*。
- en: As shown in [Figure 10-32](ch10.xhtml#ch10fig32), this capture begins with the
    query and response we saw earlier, along with one additional packet. This additional
    packet looks a bit odd because it is attempting to communicate with the primary
    DNS server at the central office (172.16.16.250) ➊ on the standard DNS server
    port 53 ➌, but it is not the UDP ➋ we’re used to seeing.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 10-32](ch10.xhtml#ch10fig32)所示，这次捕获从我们之前看到的查询和响应开始，并且有一个附加的数据包。这个附加的数据包看起来有点奇怪，因为它试图与总部的主
    DNS 服务器（172.16.16.250） ➊ 在标准 DNS 服务器端口 53 ➌ 进行通信，但它不是我们习惯看到的 UDP ➋。
- en: '![image](../images/f225-01.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f225-01.jpg)'
- en: '*Figure 10-32: This SYN packet uses port 53 but is not UDP.*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-32：这个 SYN 数据包使用了 53 端口，但不是 UDP。*'
- en: To figure out the purpose of this packet, recall our discussion of DNS in [Chapter
    9](ch09.xhtml#ch09). DNS usually uses UDP, but it uses TCP when the response to
    a query exceeds a certain size. In that case, we’ll see some initial UDP traffic
    that triggers the TCP traffic. TCP is also used for DNS during a zone transfer,
    when resource records are transferred between DNS servers, which is likely the
    case here.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要弄清楚这个数据包的目的，回想一下我们在[第 9 章](ch09.xhtml#ch09)中讨论的 DNS 内容。DNS 通常使用 UDP，但当查询的响应超过一定大小时，它会使用
    TCP。在这种情况下，我们会看到一些初始的 UDP 流量，进而触发 TCP 流量。在 DNS 区域传输期间，当资源记录在 DNS 服务器之间传输时，TCP
    也会被用于 DNS，这很可能就是这里的情况。
- en: The DNS server at the branch office location is a slave to the DNS server at
    the central office, meaning that it relies on it in order to receive resource
    records. The application server that users in the branch office are trying to
    access is located inside the central office, which means that the central office
    DNS server is authoritative for that server. For the branch office server to resolve
    a DNS request for the application server, the DNS resource record for that server
    must be transferred from the central office DNS server to the branch office DNS
    server. This is likely the source of the SYN packet in this capture file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 分支办公室的 DNS 服务器是总部 DNS 服务器的从服务器，这意味着它依赖于总部 DNS 服务器来接收资源记录。分支办公室用户尝试访问的应用服务器位于总部内部，这意味着总部
    DNS 服务器对该服务器具有权威性。为了让分支办公室的服务器解析应用服务器的 DNS 请求，该服务器的 DNS 资源记录必须从总部 DNS 服务器传输到分支办公室
    DNS 服务器。这很可能就是这个捕获文件中 SYN 数据包的来源。
- en: The lack of response to this SYN packet tells us that the DNS problem is the
    result of a failed zone transfer between the branch and central office DNS servers.
    Now we can go one step further by figuring out why the zone transfer is failing.
    The possible culprits for the issue can be narrowed down to the routers between
    the offices or the central office DNS server itself. To determine which is at
    fault, we can sniff the traffic of the central office DNS server to see whether
    the SYN packet is making it to the server.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个 SYN 数据包没有响应告诉我们，DNS 问题是由于分支和总部 DNS 服务器之间的区域传输失败导致的。现在我们可以进一步探究区域传输失败的原因。可能的原因可以缩小到办公室之间的路由器或总部
    DNS 服务器本身。为了确定是哪一方出现问题，我们可以嗅探总部 DNS 服务器的流量，看看 SYN 数据包是否到达了服务器。
- en: I haven’t included a capture file for the central office DNS server traffic
    because there was none. The SYN packet never reached the server. Upon dispatching
    technicians to review the configuration of the routers connecting the two offices,
    it was found that inbound port 53 traffic on the central office router was configured
    to allow only UDP traffic and to block inbound TCP traffic. This simple misconfiguration
    prevented zone transfers from occurring between servers, thus preventing clients
    within the branch office from resolving queries for devices in the central office.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有包括中央办公室DNS服务器流量的捕获文件，因为没有此类流量。SYN数据包从未到达服务器。在派遣技术人员检查连接两地办公室路由器的配置时，发现中央办公室路由器的入站53端口流量配置仅允许UDP流量，阻止了入站的TCP流量。这个简单的配置错误导致了服务器之间的区域传输失败，从而阻止了分支办公室的客户端解析中央办公室设备的查询。
- en: '***Lessons Learned***'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***经验教训***'
- en: You can learn a lot about investigating network communication issues by watching
    crime dramas. When a crime occurs, the detectives begin by interviewing those
    most affected. Leads that result from that examination are pursued, and the process
    continues until a culprit is found.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观看犯罪剧，你可以学到很多关于调查网络通信问题的技巧。当犯罪发生时，侦探们通常会从最受影响的人开始采访。由此得到的线索会被追踪，直到最终找出罪犯。
- en: In this scenario, we began by examining the target (the workstation) and established
    leads by finding the DNS communication issue. Our leads led us to the branch DNS
    server, then to the central DNS server, and finally to the router, which was the
    source of the problem.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们首先检查了目标（工作站），并通过发现DNS通信问题获得了线索。我们的线索引导我们来到了分支DNS服务器，然后是中央DNS服务器，最后是路由器，最终找到了问题的根源。
- en: When performing analysis, try thinking of packets as clues. The clues don’t
    always tell you who committed the crime, but they often take you to the culprit
    eventually.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行分析时，试着将数据包视为线索。这些线索并不总是能直接告诉你谁是罪犯，但它们通常最终会将你引向罪犯。
- en: '**Software Data Corruption**'
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**软件数据损坏**'
- en: '*tickedoffdeveloper.pcapng*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*tickedoffdeveloper.pcapng*'
- en: Some of the most frequent arguments in IT are between developers and network
    administrators. Developers always blame poor network engineering and malfunctioning
    equipment for program errors. In turn, network administrators tend to blame bad
    code for network errors and slow communication.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: IT领域最常见的争论之一发生在开发人员和网络管理员之间。开发人员总是将程序错误归咎于网络工程不良和设备故障。而网络管理员则往往将网络错误和通信延迟归咎于坏代码。
- en: In this scenario, a programmer has developed an application for tracking the
    sales at multiple stores and reporting back to a central database. To save bandwidth
    during normal business hours, the application does not update in real time. Data
    is accumulated throughout the day and then transmitted at night as a comma-separated
    value (CSV) file to be inserted into the central database.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，一名程序员开发了一个用于追踪多家商店销售情况并将数据回传至中央数据库的应用程序。为了节省在正常营业时间的带宽，应用程序不会实时更新。数据在一天中不断积累，然后在晚上作为逗号分隔值（CSV）文件传输，并插入到中央数据库中。
- en: This newly developed application isn’t functioning correctly. The files sent
    from the stores are being received by the server, but the data being inserted
    into the database is not correct. Sections are missing, data is in the wrong place,
    and some portions of the data are missing. Much to the dismay of the network administrator,
    the programmer blames the network for the issue. They are convinced that the files
    are becoming corrupted while in transit from the stores to the central data repository.
    Our goal is to determine whether they are right.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新开发的应用程序没有正常工作。来自商店的文件虽然被服务器接收到，但插入数据库的数据并不正确。部分内容缺失，数据放错了位置，有些数据甚至完全丢失。令网络管理员十分沮丧的是，程序员将问题归咎于网络。他们坚信文件在从商店传输到中央数据存储库的过程中发生了损坏。我们的目标是确定他们的判断是否正确。
- en: '***Tapping into the Wire***'
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***深入探测网络***'
- en: To collect the data we need, we can capture packets at one of the stores or
    at the central office. Because the issue is affecting all the stores, it should
    occur at the central office if it is network related—that is the only common thread
    among all stores (other than the software itself).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了收集所需的数据，我们可以在其中一家商店或中央办公室捕获数据包。因为这个问题影响到所有商店，如果问题是网络相关的，那么它应该在中央办公室发生——这是所有商店的共同点（除了软件本身）。
- en: The network switches support port mirroring, so we’ll mirror the port the server
    is plugged into and sniff its traffic. The traffic capture will be isolated to
    a single instance of a store uploading its CSV file to the collection server.
    This result is the capture file *tickedoffdeveloper.pcapng*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 网络交换机支持端口镜像，因此我们将镜像服务器所在端口，并嗅探其流量。流量捕获将被限制为商店将其CSV文件上传到集合服务器的单一实例。该结果即为捕获文件*
    tickenoffdeveloper.pcapng*。
- en: '***Analysis***'
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分析***'
- en: We know nothing about the application the programmer has developed, other than
    the basic flow of information on the network. The capture file appears to start
    with some FTP traffic, so we’ll investigate to see whether it is indeed the mechanism
    that is transporting this file.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对程序员开发的应用了解不多，除了网络上的基本信息流动。捕获文件似乎是从一些FTP流量开始的，因此我们将进行调查，看它是否真的是传输此文件的机制。
- en: Looking at the packet list first ([Figure 10-33](ch10.xhtml#ch10fig33)), we
    can see that 172.16.16.128 ➊ initiates communication to 172.16.16.121 ➋ with a
    TCP handshake. Since 172.16.16.128 initiates the communication, we can assume
    that it is the client and that 172.16.16.121 is the server that compiles and processes
    the data. Following the handshake completion, we begin seeing FTP requests from
    the client and responses from the server ➌.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 首先查看包列表（[图10-33](ch10.xhtml#ch10fig33)），我们可以看到172.16.16.128 ➊发起了与172.16.16.121
    ➋的TCP握手通信。由于172.16.16.128发起了通信，我们可以假设它是客户端，而172.16.16.121是编译和处理数据的服务器。完成握手后，我们开始看到来自客户端的FTP请求和来自服务器的响应
    ➌。
- en: '![image](../images/f227-01.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f227-01.jpg)'
- en: '*Figure 10-33: The initial communication helps identify the client and server.*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-33：初始通信有助于识别客户端和服务器。*'
- en: We know that some transfer of data should be happening here, so we can use our
    knowledge of FTP to locate the packet where this transfer begins. The FTP connection
    and data transfer are initiated by the client, so from 172.16.16.128 we should
    see the FTP `STOR` command, which is used to upload data to an FTP server. The
    easiest way to find this command is to build a filter.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这里应该发生一些数据传输，因此我们可以利用FTP的知识来定位数据传输开始的包。FTP连接和数据传输是由客户端发起的，所以从172.16.16.128我们应该能看到FTP的`STOR`命令，这是用来上传数据到FTP服务器的。找到这个命令的最简单方法是构建一个过滤器。
- en: 'Because this capture file is littered with FTP request commands, rather than
    sorting through the hundreds of protocols and options in the expression builder,
    we can build the filter we need directly from the Packet List pane. To do so,
    we first need to select a packet with an FTP request command present. We’ll choose
    packet 5, since it’s near the top of our list. Then expand the FTP section in
    the Packet Details pane and expand the USER section. Right-click the **Request
    Command: USER** field and select **Prepare a Filter**. Finally, choose **Selected**.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该捕获文件中充满了FTP请求命令，我们不需要在表达式构建器中筛选数百个协议和选项，而是可以直接从包列表窗格中构建所需的过滤器。为此，我们首先需要选择一个包含FTP请求命令的包。我们选择第5个包，因为它靠近列表顶部。然后展开包详细信息窗格中的FTP部分，并展开USER部分。右键点击**请求命令：USER**字段并选择**准备过滤器**。最后，选择**选定**。
- en: This will prepare a filter for all packets that contain the `FTP USER` request
    command and put it in the filter dialog. Next, as shown in [Figure 10-34](ch10.xhtml#ch10fig34),
    edit the filter by replacing the word `USER` with the word STOR ➊.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为所有包含`FTP USER`请求命令的包准备一个过滤器，并将其放入过滤器对话框中。接下来，如[图10-34](ch10.xhtml#ch10fig34)所示，编辑过滤器，将`USER`替换为`STOR`
    ➊。
- en: '![image](../images/f227-02.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f227-02.jpg)'
- en: '*Figure 10-34: This filter helps identify where data transfer begins.*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-34：此过滤器有助于识别数据传输的开始位置。*'
- en: We could narrow down the filter further by providing the client’s IP address
    and specifying it as the source of the connection by adding `&& ip.src == 172.16.16.128`
    to the filter, but since this capture file is already isolated to a single client,
    that isn’t necessary here.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提供客户端的IP地址并将其指定为连接的来源，进一步缩小过滤器范围，通过在过滤器中添加`&& ip.src == 172.16.16.128`，但由于该捕获文件已经限制为单一客户端，因此在这里并不需要。
- en: Now apply this filter by pressing ENTER, and you’ll see that only one instance
    of the `STOR` command exists in the capture file, at packet 64 ➋.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按下ENTER应用这个过滤器，你会看到在捕获文件中只有一个`STOR`命令实例，出现在第64个包 ➋。
- en: Now that we know where data transfer begins, click the packet to select it and
    clear the filter by clicking the **X** button above the Packet List pane. Your
    screen should now show all the packets with packet 64 selected.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道数据传输的起始位置，点击该包进行选择，然后通过点击包列表窗格上方的**X**按钮清除筛选器。此时，您的屏幕应该显示所有数据包，并且包64已被选中。
- en: Examining the capture file beginning with packet 64, we see that this packet
    specifies the transfer of the file *store4829-03222010.csv* ➊, as shown in [Figure
    10-35](ch10.xhtml#ch10fig35).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 检查从包64开始的捕获文件，我们看到该包指定了文件*store4829-03222010.csv*的传输➊，如[图10-35](ch10.xhtml#ch10fig35)所示。
- en: '![image](../images/f228-01.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f228-01.jpg)'
- en: '*Figure 10-35: The CSV file is being transferred using FTP.*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-35：CSV文件正在通过FTP传输。*'
- en: The packets following the `STOR` command use a different port but are identified
    as part of an FTP-DATA transmission. We’ve verified that data is being transferred,
    but we have yet to establish whether the programmer is right or wrong. To do so,
    we need to show whether the contents of the file are intact after traversing the
    network, so we’ll proceed to extract the transferred file from the captured packets.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 紧随`STOR`命令的包使用了不同的端口，但被识别为FTP-DATA传输的一部分。我们已经验证了数据正在传输，但我们尚未确定程序员是否正确。为了做到这一点，我们需要展示文件内容在穿越网络后是否完整，因此我们将继续从捕获的包中提取传输的文件。
- en: When a file is transferred across a network in an unencrypted format, it is
    broken down into segments and reassembled at its destination. In this scenario,
    we captured packets as they reached their destination but before they were reassembled.
    The data is all there; we simply need to reassemble it by extracting the file
    as a data stream. To perform the reassembly, select any of the packets in the
    FTP-DATA stream (such as packet 66) and click **Follow TCP Stream**. The results
    are displayed as shown in [Figure 10-36](ch10.xhtml#ch10fig36). This looks like
    a normal CSV-formatted text file containing sales order data.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件以未加密的格式通过网络传输时，它会被分解成多个片段，并在目标处重新组装。在此场景中，我们捕获了到达目标的包，但在它们被重新组装之前。数据是完整的；我们只需要通过提取数据流来重新组装它。为了执行重新组装，选择FTP-DATA流中的任何包（例如包66），然后点击**跟踪TCP流**。结果将如[图10-36](ch10.xhtml#ch10fig36)所示。看起来像一个包含销售订单数据的正常CSV格式文本文件。
- en: The data appears because it is being transferred in plaintext over FTP, but
    we can’t be sure that the file is intact based on the stream alone. To reassemble
    the data so as to extract it in its original format, click the **Save As** button
    and specify the name of the file as displayed in packet 64\. Then click **Save**.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 数据出现是因为它通过FTP以明文形式传输，但仅凭流数据我们无法确定文件是否完整。为了重新组装数据并以原始格式提取它，请点击**另存为**按钮，并指定文件名，如包64中所示。然后点击**保存**。
- en: The result of this save operation should be a CSV file that is an exact byte-level
    copy of the file originally transferred from the store system. The file can be
    verified by comparing the MD5 hash of the original file with that of the extracted
    file. The MD5 hashes should be the same, as shown in [Figure 10-37](ch10.xhtml#ch10fig37).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此保存操作的结果应为一个CSV文件，它是从商店系统原始传输文件的精确字节级副本。可以通过比较原始文件的MD5哈希值与提取文件的MD5哈希值来验证该文件。MD5哈希值应该是相同的，如[图10-37](ch10.xhtml#ch10fig37)所示。
- en: '![image](../images/f229-01.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f229-01.jpg)'
- en: '*Figure 10-36: The TCP stream shows what appears to be the data being transferred.*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-36：TCP流显示的是似乎正在传输的数据。*'
- en: '![image](../images/f229-02.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f229-02.jpg)'
- en: '*Figure 10-37: The MD5 hashes of the original file and the extracted file are
    equivalent.*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-37：原始文件和提取文件的MD5哈希值是相等的。*'
- en: Once the files are compared, we can state that the network is not to blame for
    the database corruption occurring within the application. The file transferred
    from the store to the collection server is intact when it reaches the server,
    so any corruption must be occurring when the file is processed by the application
    on the server side.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件被比较，我们可以断言，网络并不是导致应用程序中数据库损坏的原因。从商店到集线器服务器传输的文件在到达服务器时是完整的，因此任何损坏都必须发生在文件由服务器端应用程序处理时。
- en: '***Lessons Learned***'
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***经验教训***'
- en: One great thing about packet-level analysis is that you don’t need to deal with
    the clutter of applications. Poorly coded applications greatly outnumber the good
    ones, but at the packet level, none of that matters. In this case, the programmer
    was concerned about all of the mysterious components their application was dependent
    upon, but at the end of the day, their complicated data transfer that took hundreds
    of lines of code is still no more than FTP, TCP, and IP. Using what we know about
    these basic protocols, we were able to ensure the communication process was flowing
    correctly and even extract files to prove the soundness of the network. It’s crucial
    to remember that no matter how complex the issue at hand, it still comes down
    to packets.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包级分析的一个优点是，你不需要处理应用程序的杂乱。编写不良的应用程序数量远远超过了优秀的应用程序，但在数据包级别，这些都不重要。在这个案例中，程序员担心他们的应用程序所依赖的所有神秘组件，但归根结底，他们复杂的数据传输——那些需要数百行代码的内容——仍然不过是FTP、TCP和IP。利用我们对这些基本协议的了解，我们能够确保通信过程正常流畅，甚至提取文件以证明网络的可靠性。必须记住，不论问题多么复杂，最终归结起来还是数据包的问题。
- en: '**Final Thoughts**'
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**最终思考**'
- en: In this chapter, we’ve covered several scenarios in which packet analysis allowed
    us to gain a better understanding of problematic communication. Using basic analysis
    of common protocols, we were able to track down and solve network problems in
    a timely manner. While you may not encounter exactly the same scenarios on your
    network, the analysis techniques presented here should prove useful as you analyze
    your own unique problems.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了几个通过数据包分析帮助我们更好地理解通信问题的场景。通过对常见协议的基本分析，我们能够及时跟踪并解决网络问题。虽然在你的网络中可能不会遇到完全相同的场景，但这里介绍的分析技术应该对你分析自己独特的问题有所帮助。
