- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '6'
- en: HASH FUNCTIONS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: 'Hash functions—such as MD5, SHA-1, SHA-256, SHA-3, and BLAKE2—comprise the
    cryptographer’s Swiss Army Knife: they are used in digital signatures, public-key
    encryption, integrity verification, message authentication, password protection,
    key agreement protocols, and many other cryptographic protocols. Whether you’re
    encrypting an email, sending a message on your mobile phone, connecting to an
    HTTPS website, or connecting to a remote machine through IPSec or SSH, there’s
    a hash function somewhere under the hood.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数——例如 MD5、SHA-1、SHA-256、SHA-3 和 BLAKE2——是加密学家的瑞士军刀：它们广泛应用于数字签名、公钥加密、完整性验证、消息认证、密码保护、密钥协商协议及许多其他加密协议中。无论是加密电子邮件、发送手机消息、连接
    HTTPS 网站，还是通过 IPSec 或 SSH 连接远程机器，背后都可能有某种哈希函数在发挥作用。
- en: 'Hash functions are by far the most versatile and ubiquitous of all crypto algorithms.
    There are many examples of their use in the real world: cloud storage systems
    use them to identify identical files and to detect modified files; the Git revision
    control system uses them to identify files in a repository; host-based intrusion
    detection systems (HIDS) use them to detect modified files; network-based intrusion
    detection systems (NIDS) use hashes to detect known-malicious data going through
    a network; forensic analysts use hash values to prove that digital artifacts have
    not been modified; Bitcoin uses a hash function in its proof-of-work systems—and
    there are many more.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数无疑是所有加密算法中最具多功能性和最为普及的。它们在现实世界中有很多应用实例：云存储系统利用哈希函数识别相同的文件并检测文件是否被修改；Git
    版本控制系统利用哈希函数识别仓库中的文件；基于主机的入侵检测系统（HIDS）利用哈希值检测修改过的文件；基于网络的入侵检测系统（NIDS）通过哈希值检测通过网络的已知恶意数据；取证分析师使用哈希值证明数字文物未被篡改；比特币在其工作量证明系统中使用哈希函数——这些应用举不胜举。
- en: '![image](../images/f06-01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f06-01.jpg)'
- en: '*Figure 6-1: A hash function’s input and output*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：哈希函数的输入和输出*'
- en: Unlike stream ciphers, which create a long output from a short one, hash functions
    take a long input and produce a short output, called a *hash value* or *digest*
    (see [Figure 6-1](ch06.xhtml#ch6fig1)).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于流密码，流密码将一个短的输入转化为一个长的输出，哈希函数则接受一个长的输入并输出一个短的值，称为 *哈希值* 或 *摘要*（见 [图 6-1](ch06.xhtml#ch6fig1)）。
- en: 'This chapter revolves around two main topics. First, security: what does it
    mean for a hash function to be secure? To that end, I introduce two essential
    notions—namely, collision resistance and preimage resistance. The second big topic
    revolves around hash functions construction. We look at the high-level techniques
    used by modern hash functions and then review the internals of the most common
    hash functions: SHA-1, SHA-2, SHA-3, and BLAKE2\. Lastly, we see how secure hash
    functions can behave insecurely if misused.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要围绕两个主题展开。首先是安全性：什么样的哈希函数才算是安全的？为此，我介绍了两个关键概念——碰撞抵抗性和预影像抵抗性。第二个主要主题是哈希函数的构造。我们将研究现代哈希函数所使用的高层次技术，并回顾最常见的哈希函数：SHA-1、SHA-2、SHA-3
    和 BLAKE2。最后，我们将看到如果不当使用，安全哈希函数也可能表现得不安全。
- en: '**NOTE**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Do not confuse cryptographic hash functions with* noncryptographic *ones.
    Noncryptographic hash functions are used in data structures such as hash tables
    or to detect accidental errors, and they provide no security whatsoever. For example,
    cyclic redundancy checks (CRCs) are noncryptographic hashes used to detect accidental
    modifications of a file.*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要将加密哈希函数与* 非加密 *哈希函数混淆。非加密哈希函数用于数据结构，如哈希表或用于检测偶然错误，它们根本不提供任何安全性。例如，循环冗余检验（CRC）是非加密哈希函数，用于检测文件的偶然修改。*'
- en: Secure Hash Functions
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全哈希函数
- en: '![image](../images/f06-02.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f06-02.jpg)'
- en: '*Figure 6-2: A hash function in a digital signature scheme. The hash acts as
    a proxy for the message.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：数字签名方案中的哈希函数。哈希值充当消息的代理。*'
- en: The notion of security for hash functions is different from what we’ve seen
    thus far. Whereas ciphers protect data confidentiality in an effort to guarantee
    that data sent in the clear can’t be read, hash functions protect data integrity
    in an effort to guarantee that data—whether sent in the clear or encrypted—hasn’t
    been modified. If a hash function is secure, two distinct pieces of data should
    always have different hashes. A file’s hash can thus serve as its identifier.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数的安全性概念与我们之前看到的有所不同。密码算法保护数据的机密性，目的是确保明文传输的数据无法被读取，而哈希函数则保护数据的完整性，目的是确保数据——无论是明文还是加密——没有被修改。如果哈希函数是安全的，那么两份不同的数据应该始终有不同的哈希值。因此，一个文件的哈希值可以作为它的标识符。
- en: 'Consider the most common application of a hash function: *digital signatures*,
    or just *signatures*. When digital signatures are used, applications process the
    hash of the message to be signed rather than the message itself, as shown in [Figure
    6-2](ch06.xhtml#ch6fig2). The hash acts as an identifier for the message. If even
    a single bit is changed in the message, the hash of the message will be totally
    different. The hash function thus helps ensure that the message has not been modified.
    Signing a message’s hash is as secure as signing the message itself, and signing
    a short hash of, say, 256 bits is much faster than signing a message that may
    be very large. In fact, most signature algorithms can only work on short inputs
    such as hash values.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑哈希函数的最常见应用：*数字签名*，或简称*签名*。当使用数字签名时，应用程序处理待签名消息的哈希值，而不是消息本身，如[图6-2](ch06.xhtml#ch6fig2)所示。哈希值充当消息的标识符。如果消息中的任何一位发生变化，消息的哈希值将完全不同。因此，哈希函数有助于确保消息没有被修改。签署消息的哈希值与签署消息本身一样安全，签署一个256位的短哈希值要比签署一个可能非常大的消息要快得多。事实上，大多数签名算法只能处理如哈希值这样短的输入。
- en: '*Unpredictability Again*'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*不可预测性再次出现*'
- en: All of the cryptographic strength of hash functions stems from the unpredictability
    of their outputs. Take the 256-bit hexadecimal values shown next; these hashes
    are computed using the NIST standard hash function SHA-256 with the ASCII letters
    `a`, `b`, and `c` as inputs. As you can see, though the values `a`, `b`, and `c`
    differ by only one or two bits (`a` is the bit sequence 01100001, `b` is 01100010,
    and `c` is 01100011), their hash values are completely different.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数的所有加密强度都来自其输出的不可预测性。以接下来的256位十六进制值为例；这些哈希值是使用NIST标准哈希函数SHA-256计算的，输入为ASCII字母`a`、`b`和`c`。如你所见，尽管`a`、`b`和`c`仅相差一到两位（二进制：`a`是01100001，`b`是01100010，`c`是01100011），它们的哈希值却完全不同。
- en: '![image](../images/f0107-01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0107-01.jpg)'
- en: Given only these three hashes, it would be impossible to predict the value of
    the SHA-256 hash of `d` or any of its bits. Why? Because hash values of a secure
    hash function are *unpredictable*. A secure hash function should be like a black
    box that returns a random string each time it receives an input.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 仅凭这三个哈希值，无法预测`d`的SHA-256哈希值或其中任何一位的值。为什么？因为安全哈希函数的哈希值是*不可预测的*。一个安全的哈希函数应该像一个黑盒子，每次接收到输入时都会返回一个随机字符串。
- en: 'The general, theoretical definition of a secure hash function is that it behaves
    like a truly random function (sometimes called a *random oracle*). Specifically,
    a secure hash function shouldn’t have any property or pattern that a random function
    wouldn’t have. This definition is helpful for theoreticians, but in practice we
    need more specific notions: namely, preimage resistance and collision resistance.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 安全哈希函数的一般理论定义是，它的行为像一个真正的随机函数（有时称为*随机预言机*）。具体而言，安全哈希函数不应具有任何随机函数没有的特性或模式。这个定义对理论学者有帮助，但在实际应用中我们需要更具体的概念：即预影像抗性和碰撞抗性。
- en: '*Preimage Resistance*'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*预影像抗性*'
- en: A *preimage* of a given hash value, *H*, is any message, *M*, such that **Hash**(*M*)
    = *H*. Preimage *resistance* describes the security guarantee that given a random
    hash value, an attacker will never find a preimage of that hash value. Indeed,
    hash functions are sometimes called *one-way* *functions* because you can go from
    the message to its hash, but not the other way.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 给定哈希值*H*的*预影像*是任何消息*M*，使得**Hash**(*M*) = *H*。预影像*抗性*描述了这样一个安全保证：给定一个随机的哈希值，攻击者永远无法找到该哈希值的预影像。事实上，哈希函数有时被称为*单向*
    *函数*，因为你可以从消息得到其哈希值，但无法反向操作得到原消息。
- en: 'First, note that a hash function can’t be inverted, even given unlimited computing
    power. For example, suppose that I hash some message using the SHA-256 hash function
    and get this 256-bit hash value:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意到即使有无限的计算能力，哈希函数也无法反转。例如，假设我使用SHA-256哈希函数对某个消息进行哈希，并得到这个256位的哈希值：
- en: '`f67a58184cef99d6dfc3045f08645e844f2837ee4bfcc6c949c9f7674367adfd`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`f67a58184cef99d6dfc3045f08645e844f2837ee4bfcc6c949c9f7674367adfd`'
- en: Even given unlimited computing power, you would never be able to determine *the*
    message that I picked to produce this particular hash, since there are many messages
    hashing to the same value. You would therefore find *some* messages that produce
    this hash value (possibly including the one I picked), but would be unable to
    determine the message that I used.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有无限的计算能力，你也永远无法确定我选择的*那个*消息来生成这个特定的哈希值，因为有许多消息哈希到相同的值。因此，你会找到*一些*生成这个哈希值的消息（可能包括我选择的那个），但你无法确定我使用的消息。
- en: For example, there are 2^(256) possible values of a 256-bit hash (a typical
    length with hash functions used in practice), but there are many more values of,
    say, 1024-bit messages (namely, 2^(1024) possible values). Therefore, it follows
    that, on average, each possible 256-bit hash value will have 2^(1024) / 2^(256)
    = 2^(1024 – 256) = 2^(768) preimages of 1024 bits each.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个256位哈希（这是实际中常用的哈希函数长度）有2^(256)个可能的值，但例如1024位消息有更多的值（即，2^(1024)个可能的值）。因此，平均而言，每个可能的256位哈希值将有2^(1024)
    / 2^(256) = 2^(1024 - 256) = 2^(768)个1024位的预像。
- en: In practice, we must be sure that it is practically impossible to find *any*
    message that maps to a given hash value, not just the message that was used, which
    is what preimage resistance actually stands for. Specifically, we speak of first-preimage
    and second-preimage resistance. *First-preimage resistance* (or just *preimage
    resistance*) describes cases where it is practically impossible to find a message
    that hashes to a given value. *Second-preimage resistance*, on the other hand,
    describes the case that when given a message, *M*[1], it’s practically impossible
    to find another message, *M*[2], that hashes to the same value that *M*[1] does.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，我们必须确保几乎不可能找到*任何*映射到给定哈希值的消息，而不仅仅是使用的消息，这正是预像抗性的含义。具体来说，我们讨论的是第一预像抗性和第二预像抗性。*第一预像抗性*（或简称*预像抗性*）描述的是几乎不可能找到一个映射到给定值的消息的情况。另一方面，*第二预像抗性*描述的是在给定一个消息*M*[1]的情况下，几乎不可能找到另一个消息*M*[2]，使得*M*[1]和*M*[2]哈希到相同的值。
- en: The Cost of Preimages
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 预像的代价
- en: Given a hash function and a hash value, you can search for first preimages by
    trying different messages until one hits the target hash. You would do this using
    an algorithm similar to `find-preimage()` in [Listing 6-1](ch06.xhtml#ch6list1).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个哈希函数和一个哈希值，你可以通过尝试不同的消息直到找到目标哈希来搜索第一个预像。你可以使用类似于[Listing 6-1](ch06.xhtml#ch6list1)中`find-preimage()`的算法来完成这项工作。
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 6-1: The optimal preimage search algorithm for a secure hash function*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-1：安全哈希函数的最优预像搜索算法*'
- en: In [Listing 6-1](ch06.xhtml#ch6list1), `random_message()` generates a random
    message (say, a random 1024-bit value). Obviously, `find-preimage()` will never
    complete if the hash’s bit length, *n*, is large enough, because it will take
    on average 2^(*n*) attempts before finding a preimage. That’s a hopeless situation
    when working with *n* = 256, as in modern hashes like SHA-256 and BLAKE2.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Listing 6-1](ch06.xhtml#ch6list1)中，`random_message()`生成一个随机消息（例如，随机的1024位值）。显然，如果哈希的位长*n*足够大，`find-preimage()`将永远无法完成，因为平均需要2^(*n*)次尝试才能找到一个预像。当处理*n*
    = 256时，这种情况是绝望的，就像现代的SHA-256和BLAKE2哈希一样。
- en: Why Second-Preimage Resistance Is Weaker
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为什么第二预像抗性较弱
- en: I claim that if you can find first preimages, you can find second preimages
    as well (for the same hash function). As proof, if the algorithm `solve-preimage()`
    returns a preimage of a given hash value, you can use the algorithm in [Listing
    6-2](ch06.xhtml#ch6list2) to find a second preimage of some message, *M*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我声明，如果你能找到第一个预像，你也能找到第二个预像（对于相同的哈希函数）。作为证明，如果算法`solve-preimage()`返回给定哈希值的一个预像，你可以使用[Listing
    6-2](ch06.xhtml#ch6list2)中的算法来找到某个消息*M*的第二个预像。
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 6-2: How to find second preimages if you can find first preimages*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-2：如果你能找到第一个预像，如何找到第二个预像*'
- en: That is, you’ll find the second preimage by seeing it as a preimage problem
    and applying the preimage attack. It follows that any second-preimage resistant
    hash function is also preimage resistant. (Were it not, it wouldn’t be second
    preimage resistant either, per the preceding `solve-second-``preimage` algorithm.)
    In other words, the best attack we can use to find second preimages is almost
    identical to the best attack we can use to find first preimages (unless the hash
    function has some defect that allows for more efficient attacks). Also note that
    a preimage search attack is essentially the same as a key recovery attack on a
    block cipher or stream cipher—namely, a brute-force search for a single magic
    value.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，你可以通过将其视为预映像问题并应用预映像攻击来找到第二预映像。由此可以得出，任何二次预映像抗性的哈希函数也是预映像抗性的。（如果不是，它也不会是二次预映像抗性的，按前面的`solve-second-``preimage`算法来判断。）换句话说，我们可以用来找到第二预映像的最佳攻击几乎与我们用来找到第一次预映像的最佳攻击完全相同（除非哈希函数存在某些缺陷，允许更高效的攻击）。另请注意，预映像搜索攻击本质上与块密码或流密码的密钥恢复攻击相同——即，对单一魔法值的暴力搜索。
- en: '*Collision Resistance*'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*碰撞抗性*'
- en: Whatever hash function you choose to use, collisions will inevitably exist due
    to the *pigeonhole principle*, which states that if you have *m* holes and *n*
    pigeons to put into those holes, and if *n* is greater than *m*, at least one
    hole must contain more than one pigeon.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择使用什么哈希函数，由于*鸽巢原理*，碰撞是不可避免的。鸽巢原理表明，如果你有*m*个孔和*n*只鸽子要放入这些孔中，并且如果*n*大于*m*，那么至少有一个孔里必须有多于一只鸽子。
- en: '**NOTE**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This can be generalized to other items and containers as well. For example,
    any 27-word sequence in the US Constitution includes at least two words that start
    with the same letter. In the world of hash functions, holes are the hash values,
    and pigeons are the messages. Because we know that there are many more possible
    messages than hash values, collisions* must *exist.*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*这可以推广到其他物品和容器。例如，美国宪法中任何27个单词的序列，至少包含两个以相同字母开头的单词。在哈希函数的世界中，孔是哈希值，鸽子是消息。因为我们知道可能的消息数量远远超过哈希值的数量，所以碰撞*必须*存在。*'
- en: However, despite the inevitable, collisions should be as hard to find as the
    original message in order for a hash function to be considered *collision resistant*—in
    other words, attackers shouldn’t be able to find two distinct messages that hash
    to the same value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管碰撞是不可避免的，碰撞应该和原始消息一样难以找到，才能使一个哈希函数被认为是*碰撞抗性*的——换句话说，攻击者不应该能够找到两个哈希值相同的不同消息。
- en: 'The notion of collision resistance is related to the notion of second-preimage
    resistance: if you can find second preimages for a hash function, you can also
    find collisions, as shown in [Listing 6-3](ch06.xhtml#ch6list3).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞抗性的概念与二次预映像抗性的概念相关：如果你能找到哈希函数的第二预映像，你也能找到碰撞，正如[清单 6-3](ch06.xhtml#ch6list3)所示。
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 6-3: The naive collision search algorithm*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-3：天真碰撞搜索算法*'
- en: That is, any collision-resistant hash is also second preimage resistant. If
    this were not the case, there would be an efficient solve-second-preimage algorithm
    that could be used to break collision resistance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，任何碰撞抗性的哈希函数也是二次预映像抗性的。如果不是这样的话，就会有一个高效的`solve-second-preimage`算法可用于破解碰撞抗性。
- en: '*Finding Collisions*'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*找到碰撞*'
- en: 'It’s faster to find collisions than it is to find preimages, on the order of
    about 2^(*n*/2) operations instead of 2^(*n*), thanks to the *birthday attack*,
    whose key idea is the following: given *N* messages and as many hash values, you
    can produce a total of *N* × (*N* – 1) / 2 potential collisions by considering
    each *pair* of two hash values (a number of the same order of magnitude as *N*²).
    It’s called *birthday* attack because it’s usually illustrated using the so-called
    *birthday paradox*, or the fact that a group of only 23 persons will include two
    persons having the same birth date with probability 1/2.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 找到碰撞比找到预映像要快，大约需要2^(*n*/2)次操作，而不是2^(*n*)，这要归功于*生日攻击*，其关键思想如下：给定*N*个消息和相同数量的哈希值，通过考虑每一对哈希值的*对*，你可以产生*N*
    × (*N* – 1) / 2个潜在的碰撞（一个与*N*²数量级相同的数字）。之所以称之为*生日*攻击，是因为它通常使用所谓的*生日悖论*来说明，即只有23个人的群体，便有1/2的概率包含两个人拥有相同的生日。
- en: '**NOTE**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: N × (N – *1) / 2 is the count of pairs of two* distinct *messages, where we
    divide by 2 because we view* (M[1], M[2]) *and* (M[2], M[1]) *as a same pair.
    In other words, we don’t care about the ordering.*
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: N × (N – *1*) / 2 是两个*不同*消息对的数量，我们除以 2，因为我们把* (M[1], M[2])* 和* (M[2], M[1])*
    视为相同的对。换句话说，我们不在乎顺序。
- en: 'For the sake of comparison, in the case of a preimage search, *N* messages
    only get you *N* candidate preimages, whereas the same *N* messages give approximately
    *N*² potential collisions, as just discussed. With *N*² instead of *N*, we say
    that there are *quadratically* more chances to find a solution. The complexity
    of the search is in turn quadratically lower: in order to find a collision, you’ll
    need to use the square root of 2^(*n*) messages; that is, 2^(*n*/2) instead of
    2^(*n*).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行比较，在预影像搜索的情况下，*N* 个消息只会得到 *N* 个候选预影像，而相同的 *N* 个消息则给出大约 *N*² 个潜在碰撞，正如前面所讨论的那样。通过
    *N*² 而不是 *N*，我们可以说找到解决方案的机会是*二次*增长的。搜索的复杂度也因此*二次*降低：为了找到一个碰撞，你只需要使用 2^(*n*/2)
    个消息，也就是 2^(*n*/2)，而不是 2^(*n*)。
- en: The Naive Birthday Attack
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 天真的生日攻击
- en: 'Here’s the simplest way to carry out the birthday attack in order to find collisions:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是执行生日攻击以寻找碰撞的最简单方法：
- en: Compute 2^(*n*/2) hashes of 2^(*n*/2) arbitrarily chosen messages and store
    all the message/hash pairs in a list.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 2^(*n*/2) 个哈希值，对 2^(*n*/2) 个任意选择的消息进行哈希，并将所有消息/哈希对存储在一个列表中。
- en: Sort the list with respect to the hash value to move any identical hash values
    next to each other.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据哈希值对列表进行排序，以便将所有相同的哈希值放置在一起。
- en: Search the sorted list to find two consecutive entries with the same hash value.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在排序列表中搜索，找到两个连续的条目，它们具有相同的哈希值。
- en: Unfortunately, this method requires a lot of memory (enough to store 2^(*n*/2)
    message/hash pairs), and sorting lots of elements slows down the search, requiring
    about *n*2^(*n*) basic operations on average using even the quicksort algorithm.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种方法需要大量内存（足以存储 2^(*n*/2) 个消息/哈希对），而且排序大量元素会减慢搜索速度，使用快速排序算法时平均需要进行约 *n*2^(*n*)
    次基本操作。
- en: 'Low-Memory Collision Search: The Rho Method'
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 低内存碰撞搜索：Rho 方法
- en: 'The *Rho method* is an algorithm for finding collisions that, unlike the naive
    birthday attack, requires only a small amount of memory. It works like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*Rho 方法*是一种寻找碰撞的算法，与天真的生日攻击不同，它只需要少量的内存。它的工作原理如下：'
- en: Given a hash function with *n*-bit hash values, pick some random hash value
    (*H*[1]), and define *H*[1] = *H′*[1].
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个 *n* 位的哈希值，选择一个随机的哈希值 (*H*[1])，并定义 *H*[1] = *H′*[1]。
- en: Compute *H*[2] = **Hash**(*H*[1]), and *H′*[2] = **Hash**(**Hash**(*H′*[1]));
    that is, in the first case we apply the hash function once, while in the second
    case we apply it twice.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 *H*[2] = **Hash**(*H*[1])，以及 *H′*[2] = **Hash**(**Hash**(*H′*[1])); 也就是说，在第一个情况下，我们应用哈希函数一次，而在第二个情况下，我们应用两次。
- en: Iterate the process and compute *H*[*i*] [+ 1] = **Hash**(*H*[*i*]), *H′*[*i*]
    [+ 1] = **Hash**(**Hash**(*H′*[*i*])), until you reach *i* such that *H*[*i*]
    [+ 1] = *H**′*[*i*] [+ 1].
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反复进行该过程，计算 *H*[*i*] [+ 1] = **Hash**(*H*[*i*])， *H′*[*i*] [+ 1] = **Hash**(**Hash**(*H′*[*i*]))，直到你找到
    *i* 使得 *H*[*i*] [+ 1] = *H′*[*i*] [+ 1]。
- en: '[Figure 6-3](ch06.xhtml#ch6fig3) will help you to visualize the attack, where
    an arrow from, say, *H*[1] to *H*[2] means *H*[2] = **Hash**(*H*[1]). Observe
    that the sequence of *H*[*i*]s eventually enters a loop, also called a *cycle*,
    which resembles the Greek letter rho (ρ) in shape. The cycle starts at *H*[5]
    and is characterized by the collision **Hash**(*H*[4]) = **Hash**(*H*[10]) = *H*[5].
    The key observation here is that in order to find a collision, you simply need
    to find such a cycle. The algorithm above allows an attacker to detect the position
    of the cycle, and therefore to find the collision.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](ch06.xhtml#ch6fig3) 将帮助你可视化攻击，其中例如从 *H*[1] 到 *H*[2] 的箭头表示 *H*[2] =
    **Hash**(*H*[1])。请注意，*H*[*i*] 的序列最终进入一个循环，也称为 *cycle*，其形状类似于希腊字母 rho (ρ)。这个循环从
    *H*[5] 开始，并且具有碰撞 **Hash**(*H*[4]) = **Hash**(*H*[10]) = *H*[5]。这里的关键观察是，要找到碰撞，你只需要找到这样的一个循环。上面的算法允许攻击者检测循环的位置，因此找到碰撞。'
- en: '![image](../images/f06-03.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f06-03.jpg)'
- en: '*Figure 6-3: The structure of the Rho hash function. Each arrow represents
    an evaluation of the hash function. The cycle beginning at* H[5] *corresponds
    to a collision*, ***Hash***(H[4]) = ***Hash***(H[10]) = H[5].'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：Rho 哈希函数的结构。每个箭头表示一次哈希函数的评估。以 *H[5]* 为起点的循环对应一个碰撞，***Hash***(H[4]) =
    ***Hash***(H[10]) = H[5]。'
- en: Advanced collision-finding techniques work by first detecting the start of the
    cycle and then finding the collision, without storing numerous values in memory
    and without needing to sort a long list. The Rho method takes about 2^(*n*/2)
    operations to succeed. Indeed, [Figure 6-3](ch06.xhtml#ch6fig3) has many fewer
    hash values than would an actual function with digests of 256 bits or more. On
    average, the cycle and the tail (the part that extends from *H*[1] to *H*[5] in
    [Figure 6-3](ch06.xhtml#ch6fig3)) each include about 2^(*n*/2) hash values, where
    *n* is the bit length of the hash values. Therefore, you’ll need at least 2^(*n*/2)
    + 2^(*n*/2) evaluations of the hash to find a collision.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 高级碰撞查找技术通过首先检测循环的起始位置，再找到碰撞，而不需要在内存中存储大量值，也不需要排序长列表。Rho方法需要大约2^(*n*/2)次操作才能成功。事实上，[图6-3](ch06.xhtml#ch6fig3)的哈希值要比实际的256位或更长的摘要函数少得多。平均而言，循环和尾部（从[图6-3](ch06.xhtml#ch6fig3)中*H*[1]到*H*[5]的部分）每个包含大约2^(*n*/2)个哈希值，其中*n*是哈希值的位长度。因此，您需要至少2^(*n*/2)
    + 2^(*n*/2)次哈希评估才能找到碰撞。
- en: Building Hash Functions
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建哈希函数
- en: 'In the 1980s, cryptographers realized that the simplest way to hash a message
    is to split it into chunks and process each chunk consecutively using a similar
    algorithm. This strategy is called *iterative hashing*, and it comes in two main
    forms:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在1980年代，密码学家意识到对消息进行哈希的最简单方法是将其拆分为多个块，并使用相似的算法依次处理每个块。这种策略被称为*迭代哈希*，它有两种主要形式：
- en: Iterative hashing using a *compression function* that transforms an input to
    a *smaller output*, as shown in [Figure 6-4](ch06.xhtml#ch6fig4). This technique
    is also known as the *Merkle–Damgård* construction (named after the cryptographers
    Ralph Merkle and Ivan Damgård).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*压缩函数*进行迭代哈希，该函数将输入转换为*较小的输出*，如[图6-4](ch06.xhtml#ch6fig4)所示。这种技术也被称为*Merkle–Damgård*构造（以密码学家Ralph
    Merkle和Ivan Damgård的名字命名）。
- en: Iterative hashing using a function that transforms an input to an output of
    the *same size*, such that any two different inputs give two different outputs
    (that is, a *permutation*), as shown in [Figure 6-7](ch06.xhtml#ch6fig7). Such
    functions are called *sponge* *functions*.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个将输入转换为相同大小输出的函数进行迭代哈希，使得任何两个不同的输入产生两个不同的输出（即*置换*），如[图6-7](ch06.xhtml#ch6fig7)所示。这样的函数被称为*海绵函数*。
- en: We’ll now discuss how these constructions actually work and how compression
    functions look in practice.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将讨论这些构造如何实际运作，以及压缩函数在实践中的样子。
- en: '*Compression-Based Hash Functions: The Merkle–Damgård Construction*'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*基于压缩的哈希函数：Merkle–Damgård构造*'
- en: 'All hash functions developed from the 1980s through the 2010s are based on
    the Merkle–Damgård (M–D) construction: MD4, MD5, SHA-1, and the SHA-2 family,
    as well as the lesser-known RIPEMD and Whirlpool hash functions. The M–D construction
    isn’t perfect, but it is simple and has proven to be secure enough for many applications.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从1980年代到2010年代开发的所有哈希函数都基于Merkle–Damgård（M-D）构造：MD4、MD5、SHA-1及SHA-2家族，以及较不为人知的RIPEMD和Whirlpool哈希函数。M-D构造虽然并不完美，但它简单且已证明对于许多应用足够安全。
- en: '**NOTE**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In MD4, MD5, and RIPEMD, the* MD *stands for* message digest, *not* Merkle–Damgård.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*在MD4、MD5和RIPEMD中，*MD*代表*消息摘要*，而不是Merkle–Damgård。*'
- en: To hash a message, the M–D construction splits the message into blocks of identical
    size and mixes these blocks with an internal state using a compression function,
    as shown in [Figure 6-4](ch06.xhtml#ch6fig4). Here, *H*[0] is the initial value
    (denoted IV) of the internal state, the values *H*[1], *H*[2], … are called the
    *chaining values*, and the final value of the internal state is the message’s
    hash value.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对消息进行哈希，M-D构造将消息拆分成大小相同的块，并使用压缩函数将这些块与内部状态混合，如[图6-4](ch06.xhtml#ch6fig4)所示。这里，*H*[0]是内部状态的初始值（记作IV），*H*[1]、*H*[2]、…被称为*链值*，而内部状态的最终值即为消息的哈希值。
- en: '![image](../images/f06-04.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f06-04.jpg)'
- en: '*Figure 6-4: The Merkle–Damgård construction using a compression function called
    Compress*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：使用名为Compress的压缩函数的Merkle–Damgård构造*'
- en: The message blocks are usually 512 or 1024 bits, but they can, in principle,
    be of any size. However, the block length is fixed for a given hash function.
    For example, SHA-256 works with 512-bit blocks and SHA-512 works with 1024-bit
    blocks.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 消息块通常是512或1024位，但原则上可以是任意大小。然而，给定哈希函数的块长度是固定的。例如，SHA-256使用512位块，而SHA-512使用1024位块。
- en: Padding Blocks
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 填充块
- en: 'What happens if you want to hash a message that can’t be split into a sequence
    of complete blocks? For example, if blocks are 512 bits, then a 520-bit message
    will consist of one 512-bit block plus 8 bits. In such a case, the M–D construction
    forms the last block as follows: take the chunk of bits left (8 in our example),
    append 1 bit, then append 0 bits, and finally append the length of the original
    message, encoded on a fixed number of bits. This padding trick guarantees that
    any two distinct messages will give a distinct sequence of blocks, and thus a
    distinct hash value.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想哈希一个无法分割成完整块的消息会发生什么呢？例如，如果块是 512 位，那么一个 520 位的消息将包含一个 512 位块加上 8 位。在这种情况下，M–D
    结构将按如下方式形成最后一个块：取剩余的比特块（在我们的例子中是 8 位），附加 1 位，然后附加 0 位，最后附加原始消息的长度，并以固定的比特数进行编码。这种填充技巧确保了任何两个不同的消息都会产生不同的块序列，从而得到不同的哈希值。
- en: 'For example, if you hash the 8-bit string 10101010 using SHA-256, which is
    a hash function with 512-bit message blocks, the first and only block will appear,
    in bits, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你使用 SHA-256 对 8 位字符串 10101010 进行哈希运算，而 SHA-256 是一个具有 512 位消息块的哈希函数，那么第一个且唯一的块将以比特形式如下所示：
- en: '![image](../images/f0112-01.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0112-01.jpg)'
- en: Here, the message bits are the first eight bits (10101010), and the padding
    bits are all the subsequent bits (shown in italic). The *1000* at the end of the
    block (underlined) is the message’s length, or 8 encoded in binary. The padding
    thus produces a 512-bit message composed of a single 512-bit block, ready to be
    processed by SHA-256’s compression function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，消息的比特是前八个比特（10101010），而填充比特是所有后续的比特（以斜体显示）。块末尾的 *1000*（下划线部分）是消息的长度，或以二进制编码的
    8。填充最终生成一个由单个 512 位块组成的 512 位消息，准备好由 SHA-256 的压缩函数处理。
- en: Security Guarantees
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 安全性保障
- en: 'The Merkle–Damgård construction is essentially a way to turn a secure compression
    function that takes small, fixed-length inputs into a secure hash function that
    takes inputs of arbitrary lengths. If a compression function is preimage and collision
    resistant, then a hash function built on it using the M–D construction will also
    be preimage and collision resistant. This is true because any successful preimage
    attack for the M–D hash could be turned into a successful preimage attack for
    the compression function, as Merkle and Damgård both demonstrated in their 1989
    papers (see [“Further Reading”](ch06.xhtml#lev1sec44) on page 126). The same is
    true for collisions: an attacker can’t break the hash’s collision resistance without
    breaking the underlying compression function’s collision resistance; hence, the
    security of the latter guarantees the security of the hash.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Merkle-Damgård 结构本质上是一种将小的、固定长度输入的安全压缩函数转换为接受任意长度输入的安全哈希函数的方法。如果一个压缩函数是抗预像和抗碰撞的，那么基于它使用
    M–D 结构构建的哈希函数也将具有抗预像和抗碰撞的特性。这是因为任何成功的预像攻击都可以转化为针对压缩函数的成功预像攻击，正如 Merkle 和 Damgård
    在他们 1989 年的论文中所展示的那样（见[“进一步阅读”](ch06.xhtml#lev1sec44) 第 126 页）。碰撞的情况也是如此：攻击者无法破解哈希函数的碰撞抗性，除非首先破解底层压缩函数的碰撞抗性；因此，后者的安全性保障了哈希的安全性。
- en: Note that the converse argument is wrong, because a collision for the compression
    function doesn’t necessarily give a collision for the hash. A collision, **Compress**(*X*,
    *M*[1]) = **Compress**(*Y*, *M*[2]), for chaining values *X* and *Y*, both distinct
    from *H*[0], won’t get you a collision for the hash because you can’t plug the
    collision into the iterative chain of hashes—except if one of the chaining values
    happens to be *X* and the other *Y*, but that’s unlikely to happen.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，反向的论点是错误的，因为压缩函数的碰撞不一定会导致哈希函数的碰撞。对于链接值 *X* 和 *Y*（都不同于 *H*[0]），**Compress**(*X*,
    *M*[1]) = **Compress**(*Y*, *M*[2]) 的碰撞不会给你哈希碰撞，因为你不能将碰撞插入到哈希的迭代链中——除非其中一个链值恰好是
    *X*，另一个是 *Y*，但这种情况发生的可能性极低。
- en: Finding Multicollisions
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查找多重碰撞
- en: 'A *multicollision* occurs when a set of three or more messages hash to the
    same value. For example, the triplet (*X*, *Y*, *Z*), such that **Hash**(*X*)
    = **Hash**(*Y*) = **Hash**(*Z*) is called a *3-collision*. Ideally, multicollisions
    should be much harder to find than collisions, but there is a simple trick for
    finding them at almost the same cost as that of a single collision. Here’s how
    it works:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*多重碰撞* 发生在三个或更多消息哈希到相同的值时。例如，三元组 (*X*, *Y*, *Z*)，使得 **Hash**(*X*) = **Hash**(*Y*)
    = **Hash**(*Z*) 被称为 *3-碰撞*。理想情况下，多重碰撞应该比碰撞更难发现，但有一个简单的技巧可以在几乎与单一碰撞相同的成本下找到它们。其工作原理如下：'
- en: 'Find a first collision: **Compress**(*H*[0], *M*[1.1]) = **Compress**(*H*[0],
    *M*[1.2]) = *H*[1]. Now you have a 2-collision, or two messages hashing to the
    same value.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到第一次碰撞：**Compress**(*H*[0], *M*[1.1]) = **Compress**(*H*[0], *M*[1.2]) = *H*[1]。现在你有一个
    2-碰撞，或两个消息哈希到相同的值。
- en: 'Find a second collision with *H*[1] as a starting chaining value: **Compress**(*H*[1],
    *M*[2.1]) = **Compress**(*H*[1], *M*[2.2]) = *H*[2]. Now you have a 4-collision,
    with four messages hashing to the same value *H*[2]: *M*[1.1] || *M*[2.1], *M*[1.1]
    || *M*[2.2], *M*[1.2] || *M*[2.1], and *M*[1.2] || *M*[2.2].'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用 *H*[1] 作为起始链式值找到第二次碰撞：**Compress**(*H*[1], *M*[2.1]) = **Compress**(*H*[1],
    *M*[2.2]) = *H*[2]。现在你有一个 4-碰撞，四个消息哈希到相同的值 *H*[2]：*M*[1.1] || *M*[2.1]，*M*[1.1]
    || *M*[2.2]，*M*[1.2] || *M*[2.1]，和 *M*[1.2] || *M*[2.2]。
- en: Repeat and find *N* times a collision, and you’ll have 2^(*N*) *N*-block messages
    hashing to the same value, or a 2^(*N*)-collision, at the cost of “only” about
    *N*2^(*N*) hash computations.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复并找到 *N* 次碰撞，你将得到 2^(*N*) *N* 块消息哈希到相同的值，或者 2^(*N*)-碰撞，代价是“大约”只有 *N*2^(*N*)
    次哈希计算。
- en: In practice, this trick isn’t all that practical because it requires you to
    find a basic 2-collision in the first place.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这个技巧并不特别实用，因为它首先要求你找到一个基本的 2-碰撞。
- en: 'Building Compression Functions: The Davies–Meyer Construction'
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建压缩函数：Davies-Meyer 构造
- en: '![image](../images/f06-05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f06-05.jpg)'
- en: '*Figure 6-5: The Davies–Meyer construction. The dark triangle shows where the
    block cipher''s key is input.*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：Davies-Meyer 构造。黑色三角形显示了块密码的密钥输入位置。*'
- en: All compression functions used in real hash functions such as SHA-256 and BLAKE2
    are based on block ciphers, because that is the simplest way to build a compression
    function. [Figure 6-5](ch06.xhtml#ch6fig5) shows the most common of the block
    cipher–based compression functions, the *Davies–Meyer construction*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 实际哈希函数中使用的所有压缩函数，例如 SHA-256 和 BLAKE2，都基于块密码，因为这是构建压缩函数的最简单方式。[图 6-5](ch06.xhtml#ch6fig5)
    显示了基于块密码的压缩函数中最常见的，即 *Davies-Meyer 构造*。
- en: Given a message block, *M*[*i*], and the previous chaining value *H*[*i* − 1],
    the Davies–Meyer compression function uses a block cipher, **E**, to compute the
    new chaining value as
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个消息块，*M*[*i*]，和前一个链式值 *H*[*i* − 1]，Davies-Meyer 压缩函数使用块密码 **E** 来计算新的链式值，公式如下：
- en: '*H[i]* = **E**(*M[i]*, *H*[*i* − 1]) ⊕ *H*[*i* − 1]'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*H[i]* = **E**(*M[i]*, *H*[*i* − 1]) ⊕ *H*[*i* − 1]'
- en: The message block *M*[*i*] acts as the block cipher key, and the chaining value
    *H*[*i*] [– 1] acts as its plaintext block. As long as the block cipher is secure,
    the resulting compression function is secure as well as collision and preimage
    resistant. Without the XOR of the preceding chaining value (⊕ *H*[*i*] [– 1]),
    Davies–Meyer would be insecure because you could invert it, going from the new
    chaining value to the previous one using the block cipher’s decryption function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 消息块 *M*[*i*] 充当块密码的密钥，链式值 *H*[*i*] [– 1] 充当其明文块。只要块密码是安全的，结果的压缩函数也是安全的，并且具有抗碰撞和抗原像性。若没有前一个链式值的
    XOR 操作（⊕ *H*[*i*] [– 1]），Davies-Meyer 将不安全，因为你可以反转它，通过使用块密码的解密函数，从新的链式值推导出前一个链式值。
- en: '**NOTE**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The Davies–Meyer construction has a surprising property: you can find* fixed
    points, *or chaining values, that are unchanged after applying the compression
    function with a given message block. It suffices to take* H[*i* – 1] = **D**(M[i],
    *0) as a chaining value, where* **D** *is the decryption function corresponding
    to* **E**. *The new chaining value* H[i] *is therefore equal to the original*
    H[i – 1]:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*Davies-Meyer 构造有一个令人惊讶的性质：你可以找到* 固定点，*或者链式值，在应用压缩函数和给定消息块后保持不变。只需要取* H[*i*
    – 1] = **D**(M[i], *0) 作为链式值，其中* **D** *是与**E**对应的解密函数。* 新的链式值* H[i] *因此等于原始的*
    H[i – 1]：'
- en: '![image](../images/f0114-01.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0114-01.jpg)'
- en: '*We get* H[i] = H[i – 1] *because plugging the decryption of zero into the
    encryption function yields zero—the term **E***(M[i], ***D***(M[i], *0))—leaving
    only the* ⊕ H[i – 1] *part of the equation in the expression of the compression
    function’s output. You can then find fixed points for the compression functions
    of the SHA-2 functions, as with the standards MD5 and SHA-1, which are also based
    on the Davies–Meyer construction. Fortunately, fixed points aren’t a security
    risk.*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们得到* H[i] = H[i – 1] *因为将零的解密值输入加密函数会得到零——即项 **E***(M[i], ***D***(M[i], *0))——只留下
    ⊕ H[i – 1] *部分，作为压缩函数输出的表达式。你可以找到 SHA-2 函数的压缩函数的固定点，类似于标准的 MD5 和 SHA-1，它们也基于 Davies-Meyer
    构造。幸运的是，固定点并不是安全隐患。*'
- en: There are many block cipher–based compression functions other than Davies–Meyer,
    such as those shown in [Figure 6-6](ch06.xhtml#ch6fig6), but they are less popular
    because they’re more complex or require the message block to be the same length
    as the chaining value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Davies–Meyer之外，还有许多基于分组密码的压缩函数，如[图6-6](ch06.xhtml#ch6fig6)所示，但它们不太流行，因为它们更复杂或要求消息数据块与链值的长度相同。
- en: '![image](../images/f06-06.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f06-06.jpg)'
- en: '*Figure 6-6: Other secure block cipher–based compression function constructions*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：其他安全的基于分组密码的压缩函数构造*'
- en: '*Permutation-Based Hash Functions: Sponge Functions*'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*基于置换的哈希函数：海绵函数*'
- en: After decades of research, cryptographers know everything there is to know about
    block cipher–based hashing techniques. Still, shouldn’t there be a simpler way
    to hash? Why bother with a block cipher, an algorithm that takes a secret key,
    when hash functions don’t take a secret key? Why not build hash functions with
    a fixed-key block cipher, a single permutation algorithm?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 经过数十年的研究，密码学家已知晓基于分组密码的哈希技术的所有知识。但难道就没有一种更简单的哈希方法吗？为什么要使用分组密码这种需要密钥的算法，而哈希函数不需要密钥？为什么不使用固定密钥的分组密码，结合单一的置换算法来构建哈希函数？
- en: Those simpler hash functions are called sponge functions, and they use a single
    permutation instead of a compression function and a block cipher (see [Figure
    6-7](ch06.xhtml#ch6fig7)). Instead of using a block cipher to mix message bits
    with the internal state, sponge functions just do an XOR operation. Sponge functions
    are not only simpler than Merkle–Damgård functions, they’re also more versatile.
    You will find them used as hash functions and also as deterministic random bit
    generators, stream ciphers, pseudorandom functions (see [Chapter 7](ch07.xhtml#ch7)),
    and authenticated ciphers (see [Chapter 8](ch08.xhtml#ch8)). The most famous sponge
    function is Keccak, also known as SHA-3.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 那些更简单的哈希函数被称为海绵函数，它们使用单一的置换而不是压缩函数和分组密码（参见[图6-7](ch06.xhtml#ch6fig7)）。海绵函数不是使用分组密码将消息位与内部状态混合，而是直接执行异或操作。海绵函数不仅比Merkle–Damgård函数更简单，而且更具通用性。你会发现它们不仅用作哈希函数，还可以用作确定性随机位生成器、流密码、伪随机函数（参见[第7章](ch07.xhtml#ch7)）和认证密码（参见[第8章](ch08.xhtml#ch8)）。最著名的海绵函数是Keccak，也称为SHA-3。
- en: '![image](../images/f06-07.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f06-07.jpg)'
- en: '*Figure 6-7: The sponge construction*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-7：海绵构造*'
- en: 'A sponge function works as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 海绵函数的工作方式如下：
- en: It XORs the first message block, *M*[1], to *H*[0], a predefined initial value
    of the internal state (for example, the all-zero string). Message blocks are all
    the same size and smaller than the internal state.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将第一个消息数据块*M*[1]与**H**[0]进行异或操作，**H**[0]是预定义的内部状态初始值（例如，全零字符串）。消息数据块的大小相同，且小于内部状态的大小。
- en: A permutation, **P**, transforms the internal state to another value of the
    same size.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 置换**P**将内部状态转换为另一个相同大小的值。
- en: It XORs block *M*[2] and applies **P** again, and then repeats this for the
    message blocks *M*[3], *M*[4], and so on. This is called the *absorbing phase*.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它对数据块*M*[2]进行异或操作，并再次应用**P**，然后对消息数据块*M*[3]、*M*[4]等重复此操作。这称为*吸收阶段*。
- en: After injecting all the message blocks, it applies **P** again and extracts
    a block of bits from the state to form the hash. (If you need a longer hash, apply
    **P** again and extract a block.) This is called the *squeezing phase*.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在注入所有消息数据块后，它再次应用**P**，并从状态中提取一块比特形成哈希。（如果需要更长的哈希，重复应用**P**并提取一块。）这称为*挤压阶段*。
- en: The security of a sponge function depends on the length of its internal state
    and the length of the blocks. If message blocks are *r*-bit long and the internal
    state is *w*-bit long, then there are *c* = *w* – *r* bits of the internal state
    that can’t be modified by message blocks. The value of *c* is called a sponge’s
    *capacity*, and the security level guaranteed by the sponge function is *c*/2\.
    For example, to reach 256-bit security with 64-bit message blocks, the internal
    state should be *w* = 2 × 256 + 64 = 576 bits. Of course, the security level also
    depends on the length, *n*, of the hash value. The complexity of a collision attack
    is therefore the smallest value between 2^(*n*/2) and 2^(*c*/2), while the complexity
    of a second preimage attack is the smallest value between 2^(*n*) and 2^(*c*/2).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 海绵函数的安全性取决于其内部状态的长度和数据块的长度。如果消息块的长度为 *r* 位，内部状态的长度为 *w* 位，那么有 *c* = *w* – *r*
    位的内部状态是无法被消息块修改的。*c* 的值称为海绵函数的 *容量*，而海绵函数所保证的安全级别是 *c*/2。例如，为了在使用 64 位消息块时达到 256
    位的安全性，内部状态应该是 *w* = 2 × 256 + 64 = 576 位。当然，安全级别还取决于哈希值的长度 *n*。因此，碰撞攻击的复杂度是 2^(*n*/2)
    和 2^(*c*/2) 之间的最小值，而第二预影像攻击的复杂度是 2^(*n*) 和 2^(*c*/2) 之间的最小值。
- en: To be secure, the permutation **P** should behave like a random permutation,
    without statistical bias and without a mathematical structure that would allow
    an attacker to predict outputs. As in compression function–based hashes, sponge
    functions also pad messages, but the padding is simpler because it doesn’t need
    to include the message’s length. The last message bit is simply followed by a
    1 bit and as many zeroes as necessary.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保安全，置换 **P** 应该像随机置换一样运作，没有统计偏差，也没有允许攻击者预测输出的数学结构。与基于压缩函数的哈希一样，海绵函数也会对消息进行填充，但由于不需要包含消息的长度，填充更加简单。最后的消息位后面跟着一个
    1 位，接着是必要数量的零位。
- en: The SHA Family of Hash Functions
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SHA 哈希函数族
- en: The Secure Hash Algorithm (SHA) hash functions are standards defined by NIST
    for use by non-military federal government agencies in the US. They are considered
    worldwide standards, and only certain non-US governments opt for their own hash
    algorithms (such as China’s SM3, Russia’s Streebog, and Ukraine’s Kupyna) for
    reasons of sovereignty rather than a lack of trust in SHA’s security. The US SHAs
    have been more extensively reviewed by cryptanalysts than the non-US ones.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 安全哈希算法（SHA）哈希函数是由美国国家标准与技术研究院（NIST）为非军事的美国联邦政府机构定义的标准。它们被认为是全球标准，只有一些非美国政府出于主权原因而选择自己的哈希算法（如中国的
    SM3、俄罗斯的 Streebog 和乌克兰的 Kupyna），而非因对 SHA 安全性的缺乏信任。美国的 SHA 哈希函数比非美国的哈希函数经过了更多密码分析学家的审查。
- en: '**NOTE**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Message Digest 5 (MD5) was the most popular hash function from 1992 until
    it was broken around 2005, and many applications then switched to one of the SHA
    hash functions. MD5 processes 512-bit block messages and updates a 128-bit internal
    state to produce a 128-bit hash, thus providing at best 128-bit preimage security
    and 64-bit collision security. In 1996, cryptanalysts warned of a collision for
    MD5’s compression function, but their warning went unheeded until 2005 when a
    team of Chinese cryptanalysts discovered how to compute collisions for the full
    MD5 hash. As I write this, it takes only seconds to find a collision for MD5,
    yet many systems still use or support MD5, often for reasons of backward compatibility.*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*消息摘要 5 (MD5) 是从 1992 年到大约 2005 年最流行的哈希函数，直到它被攻破为止，许多应用程序随后转向了某种 SHA 哈希函数。MD5
    处理 512 位的消息块并更新一个 128 位的内部状态以生成一个 128 位的哈希，从而提供最多 128 位的预影像安全性和 64 位的碰撞安全性。1996
    年，密码分析师警告 MD5 的压缩函数存在碰撞问题，但他们的警告没有得到重视，直到 2005 年，中国的密码分析团队发现了如何计算 MD5 哈希的碰撞。直到现在，计算
    MD5 的碰撞只需要几秒钟，但许多系统仍然使用或支持 MD5，通常是出于向后兼容的原因。*'
- en: '*SHA-1*'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*SHA-1*'
- en: The SHA-1 standard arose from a failure in the NSA’s original SHA-0 hash function.
    In 1993, NIST standardized the NSA’s SHA-0 hash algorithm, but in 1995 the NSA
    released SHA-1 to fix an unidentified security issue in SHA-0\. The reason for
    the tweak became clear when in 1998 two researchers discovered how to find collisions
    for SHA-0 in about 2^(60) operations instead of the 2^(80) expected for 160-bit
    hash functions such as SHA-0 and SHA-1\. Later attacks reduced the complexity
    to around 2^(33) operations, leading to actual collisions in less than an hour
    for SHA-0.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-1 标准源于美国国家安全局（NSA）原始 SHA-0 哈希函数的失败。1993年，NIST 将 NSA 的 SHA-0 哈希算法标准化，但在1995年，NSA
    发布了 SHA-1 以修复 SHA-0 中未明示的安全问题。1998年，两个研究人员发现如何在大约 2^(60) 次操作中找到 SHA-0 的碰撞，而不是预期的
    2^(80) 次操作（对于 160 位哈希函数，如 SHA-0 和 SHA-1）。后来的攻击将复杂度降低到大约 2^(33) 次操作，使得 SHA-0 在不到一小时内出现实际碰撞。
- en: SHA-1 Internals
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: SHA-1 内部结构
- en: 'SHA-1 combines a Merkle–Damgård hash function with a Davies–Meyer compression
    function based on a specially crafted block cipher, sometimes called SHACAL. That
    is, SHA-1 works by iterating the following operation over 512-bit message blocks
    (*M*):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-1 结合了 Merkle–Damgård 哈希函数和基于特制块密码的 Davies–Meyer 压缩函数，后者有时被称为 SHACAL。即，SHA-1
    通过对 512 位消息块（*M*）迭代以下操作工作：
- en: '*H* = **E**(*M*, *H*) + *H*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*H* = **E**(*M*, *H*) + *H*'
- en: 'Here, the use of a plus sign (+) rather than ⊕ (XOR) is intentional. **E**(*M*,
    *H*) and *H* are viewed as arrays of 32-bit integers, and each two words at a
    same position are added together: the first 32-bit word of **E**(*M*, *H*) with
    the first 32-bit word of *H*, and so on. The initial value of *H* is constant
    for any message, then *H* is modified as per the above equation, and the final
    value of *H* after processing all blocks is returned as the hash of the message.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用加号（+）而不是 ⊕（异或）是有意为之。**E**(*M*, *H*) 和 *H* 被视为 32 位整数的数组，每个相同位置的两个字被加在一起：**E**(*M*,
    *H*) 的第一个 32 位字与 *H* 的第一个 32 位字相加，依此类推。*H* 的初始值对于任何消息都是常量，然后根据上述公式修改 *H*，处理完所有块后，返回
    *H* 的最终值作为消息的哈希值。
- en: Once the block cipher is run using the message block as a key and the current
    160-bit chaining value as a plaintext block, the 160-bit result is seen as an
    array of five 32-bit words, each of which is added to its 32-bit counterpart in
    the initial *H* value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用消息块作为密钥，并将当前 160 位链接值作为明文块运行块密码，得到的 160 位结果被视为五个 32 位字的数组，每个字与初始 *H* 值中的相应
    32 位字相加。
- en: '[Listing 6-4](ch06.xhtml#ch6list4) shows SHA-1’s compression function, `SHA1-compress()`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-4](ch06.xhtml#ch6list4) 显示了 SHA-1 的压缩函数 `SHA1-compress()`：'
- en: '[PRE3]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 6-4: SHA-1’s compression function*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-4：SHA-1 的压缩函数*'
- en: SHA-1’s block cipher `SHA1-blockcipher()`, shown in bold in [Listing 6-5](ch06.xhtml#ch6list5),
    takes a 512-bit message block, *M*, as a key and transforms the five 32-bit words
    (`a`, `b`, `c`, `d`, and `e`) by iterating 80 steps of a short sequence of operations
    to replace the word `a` with a combination of all five words. It then shifts the
    other words in the array, as in a shift register.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-1 的块密码 `SHA1-blockcipher()`，在 [列表 6-5](ch06.xhtml#ch6list5) 中以粗体显示，接受一个
    512 位消息块 *M* 作为密钥，通过迭代 80 步短序列的操作，将五个 32 位字（`a`、`b`、`c`、`d` 和 `e`）转换，替换字 `a` 为所有五个字的组合。然后，它会像移位寄存器一样将数组中的其他字移动。
- en: '[PRE4]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 6-5: SHA-1’s block cipher*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-5：SHA-1 的块密码*'
- en: The `expand()` function shown in [Listing 6-6](ch06.xhtml#ch6list6) creates
    an array of eighty 32-bit words, *W*, from the 16-word message block by setting
    *W*’s first 16 words to *M* and the subsequent ones to an XOR combination of previous
    words, rotated one bit to the left.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 6-6](ch06.xhtml#ch6list6) 中显示的 `expand()` 函数通过将 *W* 的前 16 个字设置为 *M*，并将其余字设置为前面字的异或组合（左移一位），从
    16 字消息块创建了一个由 80 个 32 位字组成的数组 *W*。
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 6-6: SHA-1’s expand() function*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-6：SHA-1 的 expand() 函数*'
- en: The `<<< 1` operation in [Listing 6-6](ch06.xhtml#ch6list6) is the only difference
    between the SHA-1 and SHA-0 functions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 6-6](ch06.xhtml#ch6list6) 中的 `<<< 1` 操作是 SHA-1 和 SHA-0 函数之间的唯一差异。
- en: Finally, the `f()` function (see [Listing 6-7](ch06.xhtml#ch6list7)) in `SHA1-blockcipher()`
    is a sequence of basic bitwise logical operations (a Boolean function) that depends
    on the round number.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`f()` 函数（见 [列表 6-7](ch06.xhtml#ch6list7)）在 `SHA1-blockcipher()` 中是一个基本的按位逻辑操作（布尔函数）序列，取决于轮次。
- en: '[PRE6]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 6-7: SHA-1’s f() function.*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-7：SHA-1 的 f() 函数*'
- en: The second and fourth Boolean functions in [Listing 6-7](ch06.xhtml#ch6list7)
    simply XOR the three input words together, which is a linear operation. In contrast,
    the first and third functions use the non-linear & operator (logical AND) to protect
    against differential cryptanalysis, which as you recall, exploits the predictable
    propagation of bitwise difference. Without the & operator (in other words, if
    `f()` were always `b` ⊕ `c` ⊕ `d`, for example), SHA-1 would be easy to break
    by tracing patterns within its internal state.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 6-7](ch06.xhtml#ch6list7)中的第二和第四个布尔函数仅仅是将三个输入字进行 XOR 运算，这是一种线性操作。相比之下，第一和第三个函数使用非线性
    & 运算符（逻辑与）来防止差分密码分析，差分密码分析正如你记得的那样，利用了位差传播的可预测性。如果没有 & 运算符（换句话说，如果 `f()` 始终是 `b`
    ⊕ `c` ⊕ `d`，例如），那么通过追踪内部状态中的模式，SHA-1 将很容易被破解。
- en: Attacks on SHA-1
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: SHA-1 攻击
- en: Though more secure than SHA-0, SHA-1 is still insecure, which is why the Chrome
    browser marks websites using SHA-1 in their HTTPS connection as insecure. Although
    its 160-bit hash should grant it 80-bit collision resistance, in 2005 researchers
    found weaknesses in SHA-1 and estimated that finding a collision would take approximately
    2^(63) calculations. (That number would be 2^(80) if the algorithm were flawless.)
    A real SHA-1 collision only came twelve years later when after years of cryptanalysis,
    Marc Stevens and other researchers presented two colliding PDF documents through
    a joint work with Google researchers (see *[https://shattered.io/](https://shattered.io/)*).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管比 SHA-0 更安全，但 SHA-1 仍然不安全，这也是 Chrome 浏览器将使用 SHA-1 的 HTTPS 网站标记为不安全的原因。尽管其
    160 位哈希应该赋予其 80 位碰撞抗性，但在 2005 年，研究人员发现了 SHA-1 的弱点，并估计找到一个碰撞大约需要 2^(63) 次计算。（如果算法完美无缺，这个数字应该是
    2^(80)）。真正的 SHA-1 碰撞直到十二年后才出现，当时，Marc Stevens 和其他研究人员通过与 Google 研究人员的合作，展示了两个相撞的
    PDF 文档（见 *[https://shattered.io/](https://shattered.io/)*）。
- en: The upshot is that you should not use SHA-1\. As mentioned, internet browsers
    now mark SHA-1 as insecure, and SHA-1 is no longer recommended by NIST. Use SHA-2
    hash functions instead, or BLAKE2 or SHA-3.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是你不应该使用 SHA-1。如前所述，互联网浏览器现在将 SHA-1 标记为不安全，NIST 也不再推荐 SHA-1。请改用 SHA-2 哈希函数，或者
    BLAKE2 或 SHA-3。
- en: '*SHA-2*'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*SHA-2*'
- en: 'SHA-2, the successor to SHA-1, was designed by the NSA and standardized by
    NIST. SHA-2 is a family of four hash functions: SHA-224, SHA-256, SHA-384, and
    SHA-512, of which SHA-256 and SHA-512 are the two main algorithms. The three-digit
    numbers represent the bit lengths of each hash.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-2 是 SHA-1 的继任者，由 NSA 设计并由 NIST 标准化。SHA-2 是四个哈希函数的系列：SHA-224、SHA-256、SHA-384
    和 SHA-512，其中 SHA-256 和 SHA-512 是两个主要算法。这些三位数字表示每个哈希的位长。
- en: SHA-256
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: SHA-256
- en: The initial motivation behind the development of SHA-2 was to generate longer
    hashes and thus deliver higher security levels than SHA-1\. For example, whereas
    SHA-1 has 160-bit chaining values, SHA-256 has 256-bit chaining values or eight
    32-bit words. Both SHA-1 and SHA-256 have 512-bit message blocks; however, whereas
    SHA-1 makes 80 rounds, SHA-256 makes 64 rounds, expanding the 16-word message
    block to a 64-word message block using the `expand256()` function shown in [Listing
    6-8](ch06.xhtml#ch6list8).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 开发 SHA-2 的最初动机是生成更长的哈希，从而提供比 SHA-1 更高的安全性。例如，虽然 SHA-1 的链接值为 160 位，但 SHA-256
    的链接值为 256 位，或者说是八个 32 位字。SHA-1 和 SHA-256 都有 512 位的消息块；然而，SHA-1 执行 80 轮，而 SHA-256
    执行 64 轮，通过 `expand256()` 函数将 16 字的消息块扩展为 64 字的消息块，这在[列表 6-8](ch06.xhtml#ch6list8)中有所展示。
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 6-8: SHA-256’s expand256() function*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-8：SHA-256 的 expand256() 函数*'
- en: Note how SHA-2’s `expand256()` message expansion is more complex than SHA-1’s
    `expand()`, shown previously in [Listing 6-6](ch06.xhtml#ch6list6), which in contrast
    simply performs XORs and a 1-bit rotation. The main loop of SHA-256’s compression
    function is also more complex than that of SHA-1, performing 26 arithmetic operations
    per iteration compared to 11 for SHA-1\. Again, these operations are XORs, logical
    ANDs, and word rotations.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，SHA-2 的 `expand256()` 消息扩展比 SHA-1 的 `expand()` 更为复杂，后者如之前在[列表 6-6](ch06.xhtml#ch6list6)中所示，简单地执行
    XOR 和 1 位旋转。而 SHA-256 的压缩函数的主要循环也比 SHA-1 更复杂，每次迭代执行 26 次算术操作，而 SHA-1 只有 11 次。再一次，这些操作是
    XOR、逻辑与（AND）和字旋转。
- en: Other SHA-2 Algorithms
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 其他 SHA-2 算法
- en: The SHA-2 family includes SHA-224, which is algorithmically identical to SHA-256
    except that its initial value is a different set of eight 32-bit words, and its
    hash value length is 224 bits, instead of 256 bits, and is taken as the first
    224 bits of the final chaining value.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-2系列包括SHA-224，它与SHA-256在算法上完全相同，唯一不同的是其初始值是一组不同的8个32位字，而其哈希值长度为224位，而不是256位，并且该值取自最终链接值的前224位。
- en: The SHA-2 family also includes the algorithms SHA-512 and SHA-384\. SHA-512
    is similar to SHA-256 except that it works with 64-bit words instead of 32-bit
    words. As a result, it uses 512-bit chaining values (eight 64-bit words) and ingests
    1024-bit message blocks (sixteen 64-bit words), and it makes 80 rounds instead
    of 64\. The compression function is otherwise almost the same as that of SHA-256,
    though with different rotation distances to cope with the wider word size. (For
    example, SHA-512 includes the operation `a >>> 34`, which wouldn’t make sense
    with SHA-256’s 32-bit words.) SHA-384 is to SHA-512 what SHA-224 is to SHA-256—namely,
    the same algorithm but with a different initial value and a final hash truncated
    to 384 bits.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-2系列还包括SHA-512和SHA-384算法。SHA-512与SHA-256相似，只是它使用64位字而不是32位字。因此，它使用512位的链接值（8个64位字），并处理1024位的消息块（16个64位字），并执行80轮操作，而不是64轮。压缩函数在其他方面几乎与SHA-256相同，只是为适应更宽的字大小，旋转距离有所不同。（例如，SHA-512包含操作`a
    >>> 34`，如果是SHA-256的32位字，这个操作就没有意义。）SHA-384是SHA-512的变种，类似于SHA-224与SHA-256的关系——也就是说，相同的算法，只是初始值不同，最终的哈希值被截断为384位。
- en: 'Security-wise, all four SHA-2 versions have lived up to their promises so far:
    SHA-256 guarantees 256-bit preimage resistance, SHA-512 guarantees about 256-bit
    collision resistance, and so on. Still, there is no genuine proof that SHA-2 functions
    are secure; we’re talking about probable security.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全性角度来看，所有四个SHA-2版本至今都兑现了它们的承诺：SHA-256保证256位的原像抗性，SHA-512则保证约256位的碰撞抗性，等等。然而，SHA-2函数的安全性没有得到真正的证明；我们讨论的只是可能的安全性。
- en: 'That said, after practical attacks on MD5 and on SHA-1, researchers and NIST
    grew concerned about SHA-2’s long-term security due to its similarity to SHA-1,
    and many believed that attacks on SHA-2 were just a matter of time. As I write
    this, though, we have yet to see a successful attack on SHA-2\. Regardless, NIST
    developed a backup plan: SHA-3.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在MD5和SHA-1遭遇实际攻击之后，研究人员和NIST开始对SHA-2的长期安全性产生担忧，因为SHA-2与SHA-1相似，许多人认为SHA-2被攻击只是时间问题。然而，截至目前，我们尚未看到对SHA-2的成功攻击。不管怎样，NIST制定了备选方案：SHA-3。
- en: '*The SHA-3 Competition*'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*SHA-3竞赛*'
- en: 'Announced in 2007, the NIST Hash Function Competition (the official name of
    the SHA-3 competition) began with a call for submissions and some basic requirements:
    hash submissions were to be at least as secure and as fast as SHA-2, and they
    should be able to do at least as much as SHA-2\. SHA-3 candidates also shouldn’t
    look too much like SHA-1 and SHA-2 in order to be immune to attacks that would
    break SHA-1 and potentially SHA-2\. By 2008, NIST had received 64 submissions
    from around the world, including from universities and large corporations (BT,
    IBM, Microsoft, Qualcomm, and Sony, to name a few). Of these 64 submissions, 51
    matched the requirements and entered the first round of the competition.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 2007年宣布的NIST哈希函数竞赛（SHA-3竞赛的官方名称）开始时发布了征集公告，并给出了基本要求：哈希算法的安全性和速度至少要与SHA-2一样，并且至少要具备与SHA-2相同的功能。SHA-3的候选算法还应该与SHA-1和SHA-2有足够的区别，以避免遭受破坏SHA-1甚至SHA-2的攻击。到2008年，NIST收到了来自全球的64个提交，包括来自大学和大型企业（如BT、IBM、微软、Qualcomm和索尼等）的提交。在这64个提交中，51个符合要求，进入了第一轮比赛。
- en: 'During the first weeks of the competition, cryptanalysts mercilessly attacked
    the submissions. In July 2009, NIST announced 14 second-round candidates. After
    spending 15 months analyzing and evaluating the performance of these candidates,
    NIST chose five finalists:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在竞赛的最初几周，密码分析师们对各个提交进行了毫不留情的攻击。2009年7月，NIST宣布了14个第二轮候选算法。经过15个月对这些候选算法的分析和评估，NIST选出了五个决赛入围者：
- en: '**BLAKE** An enhanced Merkle–Damgård hash whose compression function is based
    on a block cipher, which is in turn based on the core function of the stream cipher
    ChaCha, a chain of additions, XORs, and word rotations. BLAKE was designed by
    a team of academic researchers based in Switzerland and the UK, including myself.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**BLAKE** 是一种增强型Merkle-Damgård哈希，其压缩函数基于块密码，块密码又基于流密码ChaCha的核心函数，包括一系列加法、XOR运算和字轮转。BLAKE由一个包括我在内的瑞士和英国的学术研究团队设计。'
- en: '**Grøstl** An enhanced Merkle–Damgård hash whose compression function uses
    two permutations (or fixed-key block ciphers) based on the core function of the
    AES block cipher. Grøstl was designed by a team of seven academic researchers
    from Denmark and Austria.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**Grøstl** 一种增强型Merkle–Damgård哈希，其压缩函数使用基于AES块密码核心功能的两种置换（或固定密钥块密码）。Grøstl由来自丹麦和奥地利的七位学术研究人员团队设计。'
- en: '**JH** A tweaked sponge function construction wherein message blocks are injected
    before and after the permutation rather than just before. The permutation also
    performs operations similar to a substitution–permutation block cipher (as discussed
    in [Chapter 4](ch04.xhtml#ch4)). JH was designed by a cryptographer from a university
    in Singapore.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**JH** 一种调整过的海绵函数构造，其中消息块在置换之前和之后都被注入，而不仅仅是在之前。该置换还执行类似于替代–置换块密码的操作（如[第4章](ch04.xhtml#ch4)所讨论）。JH由一位来自新加坡大学的密码学家设计。'
- en: '**Keccak** A sponge function whose permutation performs only bitwise operations.
    Keccak was designed by a team of four cryptographers working for a semiconductor
    company based in Belgium and Italy, and included one of the two designers of AES.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**Keccak** 一种海绵函数，其置换仅执行按位操作。Keccak由一个位于比利时和意大利的半导体公司工作的四人密码学家团队设计，其中包括AES的两位设计者之一。'
- en: '**Skein** A hash function based on a different mode of operation than Merkle–Damgård,
    and whose compression function is based on a novel block cipher that uses only
    integer addition, XOR, and word rotation. Skein was designed by a team of eight
    cryptographers from academia and industry, all but one of whom is based in the
    US, including the renowned Bruce Schneier.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**Skein** 一种基于不同于Merkle–Damgård操作模式的哈希函数，其压缩函数基于一种新型块密码，仅使用整数加法、XOR和字轮转。Skein由来自学术界和工业界的八位密码学家团队设计，其中除了一个人之外，其他人均位于美国，包括著名的布鲁斯·施奈尔（Bruce
    Schneier）。'
- en: 'After extensive analysis of the five finalists, NIST announced a winner: Keccak.
    NIST’s report rewarded Keccak for its “elegant design, large security margin,
    good general performance, excellent efficiency in hardware, and its flexibility.”
    Let’s see how Keccak works.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在对五个候选算法进行了广泛分析后，NIST宣布Keccak为最终获胜者。NIST的报告称Keccak具有“优雅的设计、大的安全余量、良好的通用性能、卓越的硬件效率和灵活性”。让我们来看一下Keccak是如何工作的。
- en: '*Keccak (SHA-3)*'
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*Keccak (SHA-3)*'
- en: One of the reasons that NIST chose Keccak is that it’s completely different
    from SHA-1 and SHA-2\. For one thing, it’s a sponge function. Keccak’s core algorithm
    is a permutation of a 1600-bit state that ingests blocks of 1152, 1088, 832, or
    576 bits, producing hash values of 224, 256, 384, or 512 bits, respectively—the
    same four lengths produced by SHA-2 hash functions. But unlike SHA-2, SHA-3 uses
    a single core algorithm rather than two algorithms for all four hash lengths.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: NIST选择Keccak的原因之一是它与SHA-1和SHA-2完全不同。首先，它是一种海绵函数。Keccak的核心算法是一种1600位状态的置换，它可以处理1152、1088、832或576位的块，分别产生224、256、384或512位的哈希值——这与SHA-2哈希函数产生的四种长度相同。但与SHA-2不同，SHA-3使用单一核心算法来处理所有四种哈希长度，而不是使用两种算法。
- en: Another reason is that Keccak is more than just a hash. The SHA-3 standard document
    FIPS 202 defines four hashes—SHA3-224, SHA3-256, SHA3-384, and SHA3-512—and two
    algorithms called SHAKE128 and SHAKE256\. (The name *SHAKE* stands for *Secure
    Hash Algorithm with Keccak*.) These two algorithms are *extendable-output functions*
    *(XOFs)*, or hash functions that can produce hashes of variable length, even very
    long ones. The numbers 128 and 256 represent the security level of each algorithm.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是Keccak不仅仅是一个哈希。SHA-3标准文档FIPS 202定义了四种哈希——SHA3-224、SHA3-256、SHA3-384和SHA3-512——以及两种算法，分别为SHAKE128和SHAKE256。(*SHAKE*代表*带Keccak的安全哈希算法*)。这两种算法是*可扩展输出函数*（*XOFs*），即可以生成可变长度哈希的哈希函数，甚至可以生成非常长的哈希值。数字128和256代表每个算法的安全级别。
- en: The FIPS 202 standard itself is lengthy and hard to parse, but you’ll find open-source
    implementations that are reasonably fast and make the algorithm easier to understand
    than the specifications. For example, the MIT-licensed tiny_sha3 (*[https://github.com/mjosaarinen/tiny_sha3/](https://github.com/mjosaarinen/tiny_sha3/)*)
    by Markku-Juhani O. Saarinen, explains Keccak’s core algorithm in 19 lines of
    C, as partially reproduced in [Listing 6-9](ch06.xhtml#ch6list9).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: FIPS 202标准本身冗长且难以解析，但你会发现开源实现通常速度较快，并且比规范更容易理解该算法。例如，Markku-Juhani O. Saarinen的MIT许可证tiny_sha3
    (*[https://github.com/mjosaarinen/tiny_sha3/](https://github.com/mjosaarinen/tiny_sha3/)*
    )在19行C代码中解释了Keccak的核心算法，部分代码如[Listing 6-9](ch06.xhtml#ch6list9)所示。
- en: '[PRE8]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 6-9: The tiny_sha3 implementation*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-9: tiny_sha3实现*'
- en: 'The tiny_sha3 program implements the permutation, **P**, of Keccak, an invertible
    transformation of a 1600-bit state viewed as an array of twenty-five 64-bit words.
    As you review the code, notice that it iterates a series of rounds, where each
    round consists of four main steps (as marked by ❶, ❷, ❸, and ❹):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: tiny_sha3程序实现了Keccak的置换**P**，这是对一个1600位状态的可逆变换，状态被视为25个64位字的数组。查看代码时，请注意它会迭代一系列回合，每个回合由四个主要步骤组成（如❶、❷、❸和❹所标记）：
- en: The first step, `Theta` ❶, includes XORs between 64-bit words or a 1-bit rotated
    value of the words (the `ROTL64(w, 1)` operation left-rotates a word `w` of 1
    bit).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一步，`Theta` ❶，包括64位字之间的XOR操作，或是对字的1位旋转值进行XOR（`ROTL64(w, 1)`操作是将字`w`向左旋转1位）。
- en: The second step, `Rho Pi` ❷, includes rotations of 64-bit words by constants
    hardcoded in the `keccakf_rotc[]` array.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二步，`Rho Pi` ❷，包括将64位字旋转，通过硬编码在`keccakf_rotc[]`数组中的常数进行旋转。
- en: The third step, `Chi` ❸, includes more XORs, but also logical ANDs (the & operator)
    between 64-bit words. These ANDs are the only nonlinear operations in Keccak,
    and they bring with them cryptographic strength.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三步，`Chi` ❸，包括更多的XOR操作，但也包含64位字之间的逻辑与（& 运算符）。这些与操作是Keccak中唯一的非线性操作，它们带来了加密强度。
- en: The fourth step, `Iota` ❹, includes a XOR with a 64-bit constant, hardcoded
    in the `keccakf_rndc[]`.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四步，`Iota` ❹，包括与一个64位常数进行XOR操作，该常数被硬编码在`keccakf_rndc[]`中。
- en: These operations provide SHA-3 with a strong permutation algorithm free of any
    bias or exploitable structure. SHA-3 is the product of more than a decade of research,
    and hundreds of skilled cryptanalysts have failed to break it. It’s unlikely to
    be broken anytime soon.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作为SHA-3提供了一个强大的置换算法，没有任何偏差或可利用的结构。SHA-3是经过十多年研究的成果，数百名经验丰富的密码分析师都未能破解它。它在短时间内不太可能被破解。
- en: The BLAKE2 Hash Function
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BLAKE2哈希函数
- en: Security may matter most, but speed comes second. I’ve seen many cases where
    a developer wouldn’t switch from MD5 to SHA-1 simply because MD5 is faster, or
    from SHA-1 to SHA-2 because SHA-2 is noticeably slower than SHA-1\. Unfortunately,
    SHA-3 isn’t faster than SHA-2, and because SHA-2 is still secure, there are few
    incentives to upgrade to SHA-3\. So how to hash faster than SHA-1 and SHA-2 and
    be even more secure? The answer lies in the hash function BLAKE2, released after
    the SHA-3 competition.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性可能是最重要的，但速度排在第二位。我见过许多开发者仅仅因为MD5比SHA-1快，而不愿意从MD5切换到SHA-1，或者因为SHA-2比SHA-1明显更慢，而不愿从SHA-1切换到SHA-2。不幸的是，SHA-3并没有比SHA-2更快，并且由于SHA-2仍然安全，因此升级到SHA-3的动机不大。那么，如何比SHA-1和SHA-2更快地进行哈希并且更加安全呢？答案就在哈希函数BLAKE2中，它是在SHA-3竞赛后发布的。
- en: '**NOTE**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Full disclosure: I’m a designer of BLAKE2, together with Samuel Neves, Zooko
    Wilcox-O’Hearn, and Christian Winnerlein.*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*完全披露：我是BLAKE2的设计者之一，和Samuel Neves、Zooko Wilcox-O’Hearn、Christian Winnerlein一起设计的。*'
- en: 'BLAKE2 was designed with the following ideas in mind:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: BLAKE2的设计考虑了以下几点：
- en: It should be least as secure as SHA-3, if not stronger.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该至少与SHA-3同样安全，甚至可能更强。
- en: It should be faster than all previous hash standards, including MD5.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该比所有之前的哈希标准都更快，包括MD5。
- en: It should be suited for use in modern applications, and able to hash large amounts
    of data either as a few large messages or many small ones, with or without a secret
    key.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该适用于现代应用程序，能够处理大量数据，无论是作为少量大消息还是大量小消息，带或不带秘密密钥。
- en: It should be suited for use on modern CPUs supporting parallel computing on
    multicore systems as well as instruction-level parallelism within a single core.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该适用于支持多核系统并行计算的现代CPU，以及单核中的指令级并行性。
- en: 'The outcome of the engineering process is a pair of main hash functions:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 该工程过程的结果是一对主要的哈希函数：
- en: BLAKE2b (or just BLAKE2), optimized for 64-bit platforms, produces digests ranging
    from 1 to 64 bytes.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BLAKE2b（或简称BLAKE2），针对64位平台进行了优化，能够生成从1到64字节不等的哈希值。
- en: BLAKE2s, optimized for 8- to 32-bit platforms, can produce digests ranging from
    1 to 32 bytes.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BLAKE2s，针对8到32位平台进行了优化，能够生成从1到32字节不等的哈希值。
- en: Each function has a parallel variant that can leverage multiple CPU cores. The
    parallel counterpart of BLAKE2b, BLAKE2bp, runs on four cores, whereas BLAKE2sp
    runs on eight cores. The former is the fastest on modern server and laptop CPUs
    and can hash at close to 2 Gbps on a laptop CPU. In fact, BLAKE2 is the fastest
    secure hash available today, and its speed and features have made it the most
    popular non-NIST-standard hash. BLAKE2 is used in countless software applications
    and has been integrated into major cryptography libraries such as OpenSSL and
    Sodium.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都有一个并行变体，可以利用多个 CPU 核心。BLAKE2b 的并行版本 BLAKE2bp 可以在四个核心上运行，而 BLAKE2sp 可以在八个核心上运行。前者在现代服务器和笔记本电脑的
    CPU 上最快，并且在笔记本电脑 CPU 上的哈希速度接近 2 Gbps。事实上，BLAKE2 是目前最快的安全哈希，其速度和特点使它成为最受欢迎的非 NIST
    标准哈希。BLAKE2 被广泛应用于各种软件，并已集成到 OpenSSL 和 Sodium 等主要的加密库中。
- en: '**NOTE**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can find BLAKE2’s specifications and reference code at* [https://blake2.net/](https://blake2.net/),
    *and you can download optimized code and libraries from* [https://github.com/BLAKE2/](https://github.com/BLAKE2/).
    *The reference code also provides BLAKE2X, an extension of BLAKE2 that can produce
    hash values of arbitrary length.*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以在* [https://blake2.net/](https://blake2.net/) *找到 BLAKE2 的规格和参考代码，* [https://github.com/BLAKE2/](https://github.com/BLAKE2/)
    *可以下载优化过的代码和库。参考代码还提供了 BLAKE2X，这是 BLAKE2 的扩展，可以生成任意长度的哈希值。*'
- en: '![image](../images/f06-08.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f06-08.jpg)'
- en: '*Figure 6-8: BLAKE2’s compression function. The two halves of the state are
    XORed together after the block cipher.*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-8：BLAKE2 的压缩函数。在分组密码之后，状态的两个半部分通过异或操作结合。*'
- en: BLAKE2’s compression function, shown in [Figure 6-8](ch06.xhtml#ch6fig8), is
    a variant of the Davies–Meyer construction that takes parameters as additional
    input—namely, a *counter* (which ensures that each compression function behaves
    like a different function) and a *flag* (which indicates whether the compression
    function is processing the last message block, for increased security).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: BLAKE2 的压缩函数，如[图 6-8](ch06.xhtml#ch6fig8)所示，是 Davies-Meyer 构造的一个变种，采用参数作为附加输入——即一个
    *计数器*（确保每个压缩函数的行为像不同的函数）和一个 *标志*（指示压缩函数是否正在处理最后一个消息块，以提高安全性）。
- en: 'The block cipher in BLAKE2’s compression function is based on the stream cipher
    ChaCha, itself a variant of the Salsa20 stream cipher discussed in [Chapter 5](ch05.xhtml#ch5).
    Within this block cipher, BLAKE2b’s core operation is composed of the following
    chain of operations, which transforms a state of four 64-bit words using two message
    words, *M*[*i*] and *M*[*j*]:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: BLAKE2 压缩函数中的分组密码基于流密码 ChaCha，而 ChaCha 本身是[第五章](ch05.xhtml#ch5)讨论的 Salsa20 流密码的变种。在这个分组密码中，BLAKE2b
    的核心操作由以下一系列操作组成，这些操作通过两个消息字 *M*[*i*] 和 *M*[*j*] 转换四个 64 位字的状态：
- en: '![image](../images/f0124-01.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0124-01.jpg)'
- en: BLAKE2s’s core operation is similar but works with 32-bit instead of 64-bit
    words (and thus uses different rotation values).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: BLAKE2s 的核心操作类似，但使用的是 32 位而不是 64 位字（因此使用不同的旋转值）。
- en: How Things Can Go Wrong
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误发生的方式
- en: 'Despite their apparent simplicity, hash functions can cause major security
    troubles when used at the wrong place or in the wrong way—for example, when weak
    checksum algorithms like CRCs are used instead of a crypto hash to check file
    integrity in applications transmitting data over a network. However, this weakness
    pales in comparison to some others, which can cause total compromise in seemingly
    secure hash functions. We’ll see two examples of failures: the first one applies
    to SHA-1 and SHA-2, but not to BLAKE2 or SHA-3, whereas the second one applies
    to all of these four functions.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管哈希函数表面上看起来很简单，但当在错误的地方或以错误的方式使用时，可能会引发严重的安全问题——例如，当像 CRC 这样的弱校验和算法被用来替代加密哈希函数检查文件完整性，尤其是在传输数据的网络应用中。然而，这种弱点与一些其他弱点相比显得微不足道，后者可能会导致看似安全的哈希函数完全失效。我们将看到两个失败的例子：第一个例子适用于
    SHA-1 和 SHA-2，但不适用于 BLAKE2 或 SHA-3，而第二个例子适用于这四个函数。
- en: '*The Length-Extension Attack*'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*长度扩展攻击*'
- en: The *length-extension attack*, shown in [Figure 6-9](ch06.xhtml#ch6fig9), is
    the main threat to the Merkle–Damgård construction.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*长度扩展攻击*，如[图 6-9](ch06.xhtml#ch6fig9)所示，是对 Merkle-Damgård 构造的主要威胁。'
- en: '![image](../images/f06-09.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f06-09.jpg)'
- en: '*Figure 6-9: The length-extension attack*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-9：长度扩展攻击*'
- en: Basically, if you know **Hash**(*M*) for some *unknown* message, *M*, composed
    of blocks *M*[1] and *M*[2] (after padding), you can determine **Hash**(*M*[1]
    || *M*[2] || *M*[3]) for any block, *M*[3]. Because the hash of *M*[1] || *M*[2]
    is the chaining value that follows immediately after *M*[2], you can add another
    block, *M*[3], to the hashed message, even though you don’t know the data that
    was hashed. What’s more, this trick generalizes to any number of blocks in the
    unknown message (*M*[1] || *M*[2] here) or in the suffix (*M*[3]).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，如果你知道某个*未知*消息*M*的**哈希**(*M*)，它由块*M*[1]和*M*[2]（经过填充）组成，你可以为任何块*M*[3]确定**哈希**(*M*[1]
    || *M*[2] || *M*[3])。因为*M*[1] || *M*[2]的哈希值是紧接着*M*[2]之后的链式值，你可以添加另一个块*M*[3]到哈希消息中，即使你不知道已经哈希的数据。而且，这个技巧可以推广到任何数量的未知消息块（这里是*M*[1]
    || *M*[2]）或后缀（*M*[3]）。
- en: The length-extension attack won’t affect most applications of hash functions,
    but it can compromise security if the hash is used a bit too creatively. Unfortunately,
    SHA-2 hash functions are vulnerable to the length-extension attack, even though
    the NSA designed the functions and NIST standardized them while both were well
    aware of the flaw. This flaw could have been avoided simply by making the last
    compression function call different from all others (for example, by taking a
    1 bit as an extra parameter while the previous calls take a 0 bit). And that is
    in fact what BLAKE2 does.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 长度扩展攻击不会影响哈希函数的大多数应用，但如果哈希函数使用得过于创意，它可能会危及安全。不幸的是，SHA-2哈希函数容易受到长度扩展攻击，尽管NSA设计了这些函数，而NIST也在两者都知道这个缺陷的情况下对它们进行了标准化。这个缺陷本可以通过让最后一次压缩函数调用与其他所有调用不同来避免（例如，在前面的调用使用0位时，最后一次调用可以使用1位作为额外参数）。实际上，BLAKE2就是这样做的。
- en: '*Fooling Proof-of-Storage Protocols*'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*欺骗存储证明协议*'
- en: Cloud computing applications have used hash functions within *proof-of-storage*
    protocols—that is, protocols where a server (the cloud provider) proves to a client
    (a user of a cloud storage service) that the server does in fact store the files
    that it’s supposed to store on behalf of the client.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算应用已在*存储证明*协议中使用哈希函数——即，协议中服务器（云服务提供商）向客户端（云存储服务的用户）证明服务器确实存储了它应该为客户端存储的文件。
- en: 'In 2007, the paper “SafeStore: A Durable and Practical Storage System” *([https://www.cs.utexas.edu/~lorenzo/papers/p129-kotla.pdf](https://www.cs.utexas.edu/~lorenzo/papers/p129-kotla.pdf)*)
    by Ramakrishna Kotla, Lorenzo Alvisi, and Mike Dahlin proposed a proof-of-storage
    protocol to verify the storage of some file, *M*, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '2007年，Ramakrishna Kotla、Lorenzo Alvisi和Mike Dahlin发表的论文“SafeStore: A Durable
    and Practical Storage System” *([https://www.cs.utexas.edu/~lorenzo/papers/p129-kotla.pdf](https://www.cs.utexas.edu/~lorenzo/papers/p129-kotla.pdf)*)
    提出了一个存储证明协议来验证某个文件*M*的存储，具体如下：'
- en: The client picks a random value, *C,* as a *challenge*.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端随机选择一个值，*C*，作为*挑战*。
- en: The server computes **Hash**(*M* || *C*) as a *response* and sends the result
    to the client.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器计算**哈希**(*M* || *C*)作为*响应*并将结果发送给客户端。
- en: The client also computes **Hash**(*M* || *C*) and checks that it matches the
    value received from the server.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端还计算**哈希**(*M* || *C*)并检查它是否与从服务器接收到的值匹配。
- en: 'The premise of the paper is that the server shouldn’t be able to fool the client
    because if the server doesn’t know *M*, it can’t guess **Hash**(*M* || *C*). But
    there’s a catch: in reality, **Hash** will be an iterated hash that processes
    its input block by block, computing intermediate chaining values between each
    block. For example, if **Hash** is SHA-256 and *M* is 512 bits long (the size
    of a block in SHA-256), the server can cheat. How? The first time the server receives
    *M*, it computes *H*[1] = **Compress**(*H*[0], *M*[1]), the chaining value obtained
    from SHA-256’s initial value, *H*[0], and from the 512-bit *M*. It then records
    *H*[1] in memory and discards *M*, at which point it no longer stores *M*.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 论文的前提是，服务器不应该能够欺骗客户端，因为如果服务器不知道*M*，它就无法猜测**哈希**(*M* || *C*)。但有一个问题：实际上，**哈希**将是一个迭代哈希，它按块处理输入，每个块之间计算中间链式值。例如，如果**哈希**是SHA-256，而*M*的长度为512位（即SHA-256中的一个块大小），那么服务器可以作弊。如何作弊？当服务器第一次接收到*M*时，它计算
    *H*[1] = **压缩**(*H*[0], *M*[1])，这是从SHA-256的初始值*H*[0]和512位的*M*中得到的链式值。然后它将 *H*[1]
    记录在内存中并丢弃 *M*，此时它不再存储 *M*。
- en: Now when the client sends a random value, *C*, the server computes **Compress**(*H*[1],
    *C*), after adding the padding to *C* to fill a complete block, and returns the
    result as **Hash**(*M* || *C*). The client then believes that, because the server
    returned the correct value of **Hash**(*M* || *C*), it holds the complete message—except
    that it may not, as you’ve seen.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当客户端发送一个随机值*C*时，服务器计算**Compress**(*H*[1], *C*)，并在*C*上添加填充以填满一个完整的块，然后将结果作为**Hash**(*M*
    || *C*)返回。客户端随后会认为，由于服务器返回了**Hash**(*M* || *C*)的正确值，它持有完整的消息——但是，正如你所看到的，事实可能并非如此。
- en: 'This trick will work for SHA-1, SHA-2, as well as SHA-3 and BLAKE2\. The solution
    is simple: ask for **Hash**(*C* || *M*) instead of **Hash**(*M* || *C*).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧适用于SHA-1、SHA-2、SHA-3和BLAKE2。解决方案很简单：请求**Hash**(*C* || *M*)而不是**Hash**(*M*
    || *C*)。
- en: Further Reading
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about hash functions, read the classics from the 1980s and 90s:
    research articles like Ralph Merkle’s “One Way Hash Functions and DES” and Ivan
    Damgård’s “A Design Principle for Hash Functions.” Also read the first thorough
    study of block cipher-based hashing, “Hash Functions Based on Block Ciphers: A
    Synthetic Approach” by Preneel, Govaerts, and Vandewalle.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 想深入了解哈希函数，可以阅读1980年代和1990年代的经典文献：例如拉尔夫·梅尔克尔的《单向哈希函数与DES》和伊万·达姆高德的《哈希函数的设计原则》。另外，还可以阅读第一篇全面研究基于分组密码的哈希方法的论文《基于分组密码的哈希函数：一种综合方法》，该文由普雷内尔、戈瓦尔茨和范德瓦尔勒撰写。
- en: For more on collision search, read the 1997 paper “Parallel Collision Search
    with Cryptanalytic Applications” by van Oorschot and Wiener. To learn more about
    the theoretical security notions that underpin preimage resistance and collision
    resistance, as well as length-extension attacks, search for *indifferentiability*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多碰撞搜索的内容，可以阅读1997年由范·奥尔肖特和维纳撰写的论文《带有密码分析应用的并行碰撞搜索》。想深入了解支撑预映像抗性、碰撞抗性以及长度扩展攻击的理论安全概念，可以搜索*不可区分性*。
- en: For more recent research on hash functions, see the archives of the SHA-3 competition,
    which include all the different algorithms and how they were broken. You’ll find
    many references on the SHA-3 Zoo at *[http://ehash.iaik.tugraz.at/wiki/The_SHA-3_Zoo](http://ehash.iaik.tugraz.at/wiki/The_SHA-3_Zoo)*,
    and on NIST’s page, *[http://csrc.nist.gov/groups/ST/hash/sha-3/](http://csrc.nist.gov/groups/ST/hash/sha-3/)*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有关哈希函数的最新研究，请参阅SHA-3竞赛的档案，其中包括所有不同的算法及其被破解的方式。你可以在* [http://ehash.iaik.tugraz.at/wiki/The_SHA-3_Zoo](http://ehash.iaik.tugraz.at/wiki/The_SHA-3_Zoo)
    *上找到关于SHA-3 Zoo的许多参考资料，另一个是在NIST的页面，* [http://csrc.nist.gov/groups/ST/hash/sha-3/](http://csrc.nist.gov/groups/ST/hash/sha-3/)
    *。
- en: For more on the SHA-3 winner Keccak and sponge functions, see *[http://keccak.noekeon.org/](http://keccak.noekeon.org/)*
    and *[http://sponge.noekeon.org/](http://sponge.noekeon.org/)*, the official pages
    of the Keccak designers.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于SHA-3冠军Keccak和海绵函数的内容，请访问* [http://keccak.noekeon.org/](http://keccak.noekeon.org/)
    *和* [http://sponge.noekeon.org/](http://sponge.noekeon.org/) *，这是Keccak设计者的官方网站。
- en: 'Last but not least, research these two real exploitations of weak hash functions:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，研究以下两个弱哈希函数的实际利用案例：
- en: The nation-state malware Flame exploited an MD5 collision to make a counterfeit
    certificate and appear to be a legitimate piece of software.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国家级恶意软件Flame利用了MD5碰撞来制造伪造证书，并伪装成合法的软件。
- en: The Xbox game console used a weak block cipher (called TEA) to build a hash
    function, which was exploited to hack the console and run arbitrary code on it.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xbox游戏主机使用了一个弱的分组密码（称为TEA）来构建哈希函数，这被利用来破解主机并在其上运行任意代码。
