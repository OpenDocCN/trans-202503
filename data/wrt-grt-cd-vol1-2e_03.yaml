- en: '**4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4'
- en: FLOATING-POINT REPRESENTATION**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**浮点表示**'
- en: '![Image](../images/comm1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/comm1.jpg)'
- en: Floating-point arithmetic is an approximation of real arithmetic that solves
    the major problem with integer data types—the inability to represent fractional
    values. However, the inaccuracies in this approximation can lead to serious defects
    in application software. In order to write great software that produces correct
    results when using floating-point arithmetic, programmers must be aware of the
    machine’s underlying numeric representation and exactly how floating-point arithmetic
    approximates real arithmetic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点算术是实数算术的近似，它解决了整数数据类型的一个主要问题——无法表示小数值。然而，这种近似中的不准确性可能会导致应用软件中的严重缺陷。为了编写能够在使用浮点算术时产生正确结果的优秀软件，程序员必须了解计算机底层的数字表示，并准确理解浮点算术如何近似实数算术。
- en: '**4.1 Introduction to Floating-Point Arithmetic**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**4.1 浮点算术简介**'
- en: There is an infinite number of possible real values. Floating-point representation
    uses a finite number of bits and, therefore, can represent a finite number of
    different values. When a given floating-point format cannot exactly represent
    some real value, the closest value that the format *can* exactly represent is
    used. This section describes how the floating-point format works so you can better
    understand the drawbacks of these approximations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有无限多的实数值。浮点表示使用有限数量的位，因此只能表示有限数量的不同值。当给定的浮点格式无法精确表示某个实数值时，会使用该格式*可以*精确表示的最接近的值。本节将描述浮点格式的工作原理，以便你更好地理解这些近似值的缺点。
- en: Consider a couple of problems with integer and fixed-point formats. Integers
    cannot represent any fractional values, and they can represent only values in
    the range 0 through 2^(*n*) – 1 or –2^(*n*)^(–1) through 2^(*n*)^(–1) – 1\. Fixed-point
    formats represent fractional values, but at the expense of the range of integer
    values they can represent. This problem, which the floating-point format solves,
    is one of *[dynamic range](gloss01.xhtml#gloss01_85)*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下整数和定点格式的一些问题。整数不能表示任何小数值，它们只能表示范围在0到2^(*n*) – 1或–2^(*n*)^(–1)到2^(*n*)^(–1)
    – 1之间的值。定点格式表示小数值，但以牺牲它们可以表示的整数值的范围为代价。浮点格式解决的这个问题就是*【动态范围】(gloss01.xhtml#gloss01_85)*。
- en: Consider a simple 16-bit unsigned fixed-point format that uses 8 bits for the
    fractional component and 8 bits for the integer component of the number. The integer
    component can represent values in the range 0 through 255, and the fractional
    component can represent the values 0 and fractions between 2^(–8) and 1 (with
    a resolution of about 2^(–8)). If in a string of calculations you need only 2
    bits to represent the fractional values 0.0, 0.25, 0.5, and 0.75, the extra 6
    bits in the fractional part of the number go to waste. Wouldn’t it be nice if
    we could utilize those bits in the integer portion of the number to extend its
    range from 0 through 255 to 0 through 16,383? Well, that’s the basic concept behind
    the floating-point representation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的16位无符号定点格式，它使用8位表示小数部分，8位表示整数部分。整数部分可以表示0到255之间的值，小数部分可以表示0和介于2^(–8)与1之间的小数（精度大约为2^(–8)）。如果在一串计算中只需要2位表示小数值0.0、0.25、0.5和0.75，那么小数部分的额外6位就浪费了。如果我们能将这些位用在数字的整数部分，将其范围从0到255扩展到0到16,383，那该多好呢？这就是浮点表示的基本概念。
- en: In a floating-point value, the radix point (binary point) can float between
    digits in the number as needed. So, in a 16-bit binary number that needs only
    2 bits of precision for the fractional component, the binary point can float down
    between bits 1 and 2, leaving bits 2 through 15 for the integer portion. A floating-point
    format needs one additional field to specify the position of the radix point within
    the number, equivalent to the exponent in scientific notation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在浮点值中，基数点（二进制点）可以根据需要在数字的各个数字之间浮动。因此，在一个16位二进制数中，如果只需要2位精度表示小数部分，那么二进制点可以在第1位和第2位之间浮动，从而将第2位到第15位用于整数部分。浮点格式需要一个额外的字段来指定基数点在数字中的位置，这相当于科学计数法中的指数部分。
- en: Most floating-point formats use some number of bits to represent a mantissa
    and a smaller number of bits to represent an exponent*.* The *[mantissa](gloss01.xhtml#gloss01_145)*
    is a base value that usually falls within a limited range (for example, between
    0 and 1). The *[exponent](gloss01.xhtml#gloss01_92)* is a multiplier that, when
    applied to the mantissa, produces values outside this range. The big advantage
    of the mantissa/exponent configuration is that a floating-point format can represent
    values across a wide range. However, separating the number into these two parts
    means floating-point formats can represent only numbers with a specific number
    of *significant* digits. If the difference between the smallest and largest exponent
    is greater than the number of significant digits in the mantissa (and it usually
    is), then the floating-point format cannot exactly represent all the integers
    between the smallest and largest values in the floating-point representation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数浮点格式使用若干位来表示尾数，并用较少的位来表示指数*.* *[尾数](gloss01.xhtml#gloss01_145)*是一个通常位于有限范围内的基本值（例如，介于0和1之间）。*[指数](gloss01.xhtml#gloss01_92)*是一个乘数，应用于尾数后，能生成超出该范围的值。尾数/指数配置的一个大优点是，浮点格式可以表示广泛范围的值。然而，将数字分为这两部分意味着浮点格式只能表示具有特定数量*有效*数字的数字。如果最小指数与最大指数之间的差值大于尾数中有效数字的数量（通常是这样的），那么浮点格式就无法精确表示浮点表示中最小和最大值之间的所有整数。
- en: To see the impact of limited-precision arithmetic, we’ll adopt a simplified
    *decimal* floating-point format for our examples. Our floating-point format will
    use a mantissa with three significant digits and a decimal exponent with two digits.
    The mantissa and exponents are both signed values, as shown in [Figure 4-1](ch04.xhtml#ch04fig01).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到有限精度算术的影响，我们将采用一个简化的*十进制*浮点格式作为例子。我们的浮点格式将使用一个有三位有效数字的尾数，并使用一个有两位数字的十进制指数。尾数和指数都是有符号值，如[图4-1](ch04.xhtml#ch04fig01)所示。
- en: '![image](../images/04fig01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/04fig01.jpg)'
- en: '*Figure 4-1: Simple floating-point format*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-1：简单的浮点格式*'
- en: This particular floating-point representation can approximate all the values
    between 0.00 and 9.99 × 10^(99). However, this format cannot represent all (integer)
    values in this range (that would take 100 digits of precision!). A value like
    9,876,543,210 would be approximated with 9.88 × 10⁹ (or `9.88e+9` in programming
    language notation, which this book will generally use).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特定的浮点表示可以逼近0.00到9.99 × 10^(99)之间的所有值。然而，这种格式无法表示这个范围内的所有（整数）值（那需要100位的精度！）。像9,876,543,210这样的值将被逼近为9.88
    × 10⁹（或`9.88e+9`，这是本书中通常使用的编程语言表示法）。
- en: You cannot *exactly* represent as many different values with a floating-point
    format as with an integer format because the floating-point format encodes multiple
    representations (that is, different bit patterns) for the same value. In the simplified
    decimal floating-point format shown in [Figure 4-1](ch04.xhtml#ch04fig01), for
    example, `1.00e` `+` `1` and `0.10e + 2` are different representations of the
    same value. Because the number of different possible representations is finite,
    whenever a single value has two possible representations, that’s one less unique
    value the format can represent.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点格式无法像整数格式那样**精确**表示那么多不同的值，因为浮点格式对同一值编码了多种表示（即不同的位模式）。例如，在[图4-1](ch04.xhtml#ch04fig01)中展示的简化十进制浮点格式中，`1.00e`
    `+` `1`和`0.10e + 2`是同一值的不同表示。由于不同可能表示的数量是有限的，每当一个值有两个可能的表示时，这就意味着该格式能表示的唯一值少了一个。
- en: Furthermore, the floating-point format, a form of scientific notation, complicates
    arithmetic somewhat. When adding and subtracting two numbers in scientific notation,
    you must adjust the two values so that their exponents are the same. For example,
    when adding `1.23e1` and `4.56e0`, you could convert `4.56e0` to `0.456e1` and
    then add them. The result, `1.686e1`, does not fit into the three significant
    digits of our current format, so we must either *round* or *truncate* the result
    to three significant digits. Rounding generally produces the most accurate result,
    so let’s round the result to obtain `1.69e1`. The lack of *[precision](gloss01.xhtml#gloss01_202)*
    (the number of digits or bits maintained in a computation) affects the *[accuracy](gloss01.xhtml#gloss01_4)*
    (the correctness of the computation).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，浮点格式（科学计数法的一种形式）使得算术运算变得稍微复杂一些。在进行科学计数法下的加法和减法时，必须调整两个数值，使它们的指数相同。例如，在加法运算`1.23e1`与`4.56e0`时，可以将`4.56e0`转换为`0.456e1`，然后再进行相加。结果`1.686e1`无法符合我们当前格式的三位有效数字，因此我们必须将结果*四舍五入*或*截断*至三位有效数字。通常，四舍五入能产生最准确的结果，因此我们将结果四舍五入为`1.69e1`。缺乏*[精度](gloss01.xhtml#gloss01_202)*（在计算中保持的数字或位数）会影响*[准确性](gloss01.xhtml#gloss01_4)*（计算的正确性）。
- en: In the previous example, we were able to round the result because we maintained
    *four* significant digits *during* the calculation. If our floating-point calculation
    were limited to three significant digits during computation, we would have had
    to truncate (throw away) the last digit of the smaller number, obtaining `1.68e1`,
    which is even less correct. Therefore, to improve the accuracy, we use extra digits
    during the calculation. These extra digits are known as *guard digits* (or *guard
    bits* in the case of a binary format). They greatly enhance accuracy during a
    long chain of computations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们能够四舍五入结果，因为我们在计算过程中保持了*四*位有效数字。如果我们的浮点计算在计算过程中仅限于三位有效数字，我们就必须截断（舍弃）较小数字的最后一位，得到`1.68e1`，这结果甚至不那么准确。因此，为了提高准确性，我们在计算过程中使用额外的数字。这些额外的数字被称为*守卫数字*（在二进制格式中称为*守卫位*）。它们在一长串计算过程中大大提高了准确性。
- en: 'The accuracy lost during a single computation usually isn’t bad. However, the
    error can accumulate over a sequence of floating-point operations and greatly
    affect the computation itself. For example, suppose we add `1.23e3` and `1.00e0`.
    Adjusting the numbers so their exponents are the same before the addition produces
    `1.23e3` `+` `0.001e3`. The sum of these two values, even after rounding, is `1.23e3`.
    This might seem perfectly reasonable to you: if we can maintain only three significant
    digits, adding in a small value shouldn’t affect the result. However, suppose
    we add `1.00e0` to `1.23e3` *10 times*. The first time we add `1.00e0` to `1.23e3`,
    we get `1.23e3`. Likewise, we get this same result the second, third, fourth .
    . . and tenth time. Had we added `1.00e0` to itself 10 times, then added the result
    (`1.00e1`) to `1.23e3`, we would obtain a different result, `1.24e3`. This is
    an important rule of limited-precision arithmetic:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 单次计算中丧失的准确性通常不会很严重。然而，误差可能会在一系列浮点运算中累积，从而对整个计算结果产生较大影响。例如，假设我们将`1.23e3`与`1.00e0`相加。调整这两个数值，使它们的指数相同后进行加法得到`1.23e3`
    `+` `0.001e3`。即使四舍五入后，这两者之和仍为`1.23e3`。这可能看起来完全合理：如果我们只能保持三位有效数字，添加一个小值应该不会影响结果。然而，假设我们将`1.00e0`与`1.23e3`*相加10次*。第一次加法时，我们得到`1.23e3`。同样，第二次、第三次、第四次……直到第十次，我们都得到相同的结果。如果我们将`1.00e0`与自己相加10次，然后将结果（`1.00e1`）加到`1.23e3`，我们将得到一个不同的结果`1.24e3`。这是有限精度算术中的一个重要规则：
- en: The order of evaluation can affect the accuracy of the result.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 计算顺序可能会影响结果的准确性。
- en: Adding or subtracting numbers with relative magnitudes (that is, the sizes of
    the exponents) that are similar produces better results. If you’re performing
    a chain calculation involving addition and subtraction, you should group the operations
    so that you can add or subtract values whose magnitudes are close to one another
    before adding or subtracting values whose magnitudes are not as close.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 加法或减法操作涉及到相对大小（即指数的大小）相似的数字时，能得到更好的结果。如果你正在进行一个包含加法和减法的链式计算，应该将运算分组，以便先加或减那些大小接近的数值，再加或减那些差距较大的数值。
- en: 'Another problem with addition and subtraction is *[false precision](gloss01.xhtml#gloss01_94)*.
    Consider the computation `1.23e0` `-` `1.22e0`. This produces `0.01e0`. Although
    this is mathematically equivalent to `1.00e` `–` `2`, this latter form suggests
    that the last two digits (in the thousandths and ten-thousandths place) are both
    exactly 0\. Unfortunately, we only have a single significant digit after this
    computation, which is in the hundredths place, and some FPUs or floating-point
    software packages might actually insert random digits (or bits) into the LO positions.
    This brings up a second important rule:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关于加法和减法的问题是*[虚假精度](gloss01.xhtml#gloss01_94)*。考虑计算`1.23e0` `-` `1.22e0`。这产生了`0.01e0`。尽管这在数学上等同于`1.00e`
    `–` `2`，但后者形式暗示最后两位数字（千分位和万分位）都是精确的0。遗憾的是，经过此计算后，我们只有一个有效数字，这个数字在百分位上，而一些FPU或浮点软件包可能实际上会将随机数字（或位）插入低位位置。这引出了第二条重要规则：
- en: Whenever subtracting two numbers with the same signs or adding two numbers with
    different signs, the accuracy of the result may be less than the precision available
    in the floating-point format.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你从两个同号数字中减去，或从两个异号数字中相加时，结果的精度可能会低于浮点格式中可用的精度。
- en: 'Multiplication and division do not suffer from these problems, because you
    don’t have to adjust the exponents before the operation; all you need to do is
    add the exponents and multiply the mantissas (or subtract the exponents and divide
    the mantissas). By themselves, multiplication and division do not produce particularly
    poor results. However, they exacerbate any accuracy error that already exists
    in a value. For example, if you multiply `1.23e0` by 2, when you should be multiplying
    `1.24e0` by 2, the result is even less accurate than it was. This brings up a
    third important rule:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法和除法不受这些问题的影响，因为在操作之前你无需调整指数；你只需将指数相加并乘以尾数（或将指数相减并除以尾数）。就其本身而言，乘法和除法不会产生特别差的结果。然而，它们会加剧值中已经存在的任何精度误差。例如，如果你将`1.23e0`乘以2，而应该将`1.24e0`乘以2，那么结果会比之前的更不准确。这引出了第三条重要规则：
- en: When performing a chain of calculations involving addition, subtraction, multiplication,
    and division, perform the multiplication and division operations first.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行涉及加法、减法、乘法和除法的计算链时，先执行乘法和除法操作。
- en: 'Often, by applying normal algebraic transformations, you can arrange a calculation
    so the multiplication and division operations occur first. For example, suppose
    you want to compute the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，通过应用常规的代数变换，你可以安排计算，使得乘法和除法操作先进行。例如，假设你想计算以下内容：
- en: '*x* × (*y* + *z*)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* × (*y* + *z*)'
- en: 'Normally, you would add *y* and *z* together and multiply their sum by *x*.
    However, you’ll get a little more accuracy if you first transform the expression
    to the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会将*y*和*z*相加，然后将它们的和乘以*x*。然而，如果你首先将表达式转化为以下形式，你会获得更高的精度：
- en: '*x* × *y* + *x* × *z*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* × *y* + *x* × *z*'
- en: Now you can compute the result by performing the multiplications first.^([1](footnotes.xhtml#fn4_1a))
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过先执行乘法来计算结果。^([1](footnotes.xhtml#fn4_1a))
- en: 'Multiplication and division have other problems as well. When you multiply
    two very large or very small numbers, *[overflow](gloss01.xhtml#gloss01_188)*
    or *[underflow](gloss01.xhtml#gloss01_249)* may occur. The same situation occurs
    when you divide a small number by a large number, or a large number by a small
    number. This brings up a fourth rule:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法和除法也有其他问题。当你将两个非常大的或非常小的数字相乘时，可能会发生*[溢出](gloss01.xhtml#gloss01_188)*或*[下溢](gloss01.xhtml#gloss01_249)*。当你将一个小数字除以一个大数字，或一个大数字除以一个小数字时，也会发生这种情况。这引出了第四条规则：
- en: When multiplying and dividing sets of numbers, try to multiply and divide numbers
    that have the same relative magnitudes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在乘法和除法数字集合时，尽量选择具有相同相对大小的数字进行相乘或相除。
- en: Comparing floating-point numbers is very dangerous. Given the inaccuracies inherent
    in any computation (including converting an input string to a floating-point value),
    you should *never* compare two floating-point values to see if they are equal.
    Different computations that produce the same (mathematical) result may differ
    in their least significant bits. For example, adding `1.31e0` and `1.69e0` should
    produce `3.00e0`. Likewise, adding `1.50e0` and `1.50e0` should produce `3.00e0`.
    However, were you to compare (`1.31e0` `+` `1.69e0`) to (`1.50e0` + `1.50e0`),
    you might find that these sums are *not* equal. Because two seemingly equivalent
    floating-point computations will not necessarily produce exactly equal results,
    a straight comparison for equality—which succeeds if and only if all bits (or
    digits) in the two operands are the same—may fail.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 比较浮点数是非常危险的。考虑到任何计算中固有的不准确性（包括将输入字符串转换为浮点值），你*永远不要*直接比较两个浮点值是否相等。不同的计算可能会产生相同的（数学上的）结果，但它们的最低有效位可能不同。例如，将`1.31e0`与`1.69e0`相加应该得到`3.00e0`。同样，将`1.50e0`与`1.50e0`相加也应该得到`3.00e0`。然而，如果你将（`1.31e0`
    + `1.69e0`）与（`1.50e0` + `1.50e0`）进行比较，你可能会发现这两个和*不*相等。因为两个看似等效的浮点计算不一定会产生完全相等的结果，直接进行相等比较——只有在两个操作数的所有位（或数字）完全相同的情况下才会成功——可能会失败。
- en: 'To test for equality between floating-point numbers, determine how much error
    (or tolerance) you’ll allow in a comparison, and then check to see if one value
    is within this error range of the other, like so:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试浮点数是否相等，首先确定在比较中允许的误差（或容差）范围，然后检查一个值是否在另一个值的误差范围内，像这样：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'More efficient is to use a statement of the form:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 更高效的方法是使用如下形式的语句：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The value for error should be slightly greater than the largest amount of error
    that will creep into your computations. The exact value depends upon the particular
    floating-point format you use and the magnitudes of the values you are comparing.
    So, the final rule is this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 误差值应稍大于你在计算中允许的最大误差值。确切的误差值取决于你使用的特定浮点格式以及你正在比较的值的大小。因此，最终的规则是：
- en: When comparing two floating-point numbers for equality, always compare the values
    to see if the difference between two values is less than some small error value.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较两个浮点数是否相等时，始终比较这两个值之间的差异，看它是否小于某个小的误差值。
- en: Checking two floating-point numbers for equality is a very famous problem, one
    that almost every introductory programming text discusses. The same problems with
    comparing for less than or greater than, however, are not as well known. Suppose
    that a sequence of floating-point calculations produces a result that is accurate
    only to within ±error, even though the floating-point representation provides
    better accuracy than error suggests. If you compare such a result against some
    other calculation computed with less accumulated error, and those two values are
    very close to each other, then comparing them for less than or greater than may
    produce incorrect results.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 检查两个浮点数是否相等是一个非常著名的问题，几乎所有的入门编程教材都会讨论这个问题。然而，对于小于或大于的比较，类似的问题并没有那么广为人知。假设一系列浮点计算的结果仅在±误差范围内准确，尽管浮点表示提供的精度比误差所暗示的更好。如果你将这样的结果与某个计算误差较小的结果进行比较，并且这两个值非常接近，那么进行小于或大于的比较可能会产生不正确的结果。
- en: For example, suppose that some chain of calculations in our simplified decimal
    representation produces 1.25, which is accurate only to ±0.05 (that is, the real
    value could be somewhere between 1.20 and 1.30), and a second chain of calculations
    produces 1.27, which is accurate to the full precision of our floating-point representation
    (that is, the actual value, before rounding, is somewhere between 1.265 and 1.275).
    Comparing the result of the first calculation (1.25) to the result of the second
    calculation (1.27) finds that the first result is less than the second. Unfortunately,
    given the inaccuracy of the first calculation, this might not be true—for example,
    if the correct result of the first computation is in the range 1.27 to 1.30 (exclusive).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们在简化的十进制表示中进行的一系列计算得出1.25，这个结果的准确度仅为±0.05（即，真实值可能在1.20和1.30之间），而第二个计算链产生的结果是1.27，且其准确度达到浮点表示的最大精度（即，在四舍五入之前，实际值可能在1.265和1.275之间）。将第一个计算结果（1.25）与第二个计算结果（1.27）进行比较时，发现第一个结果小于第二个结果。不幸的是，鉴于第一个计算的不准确性，这可能并不成立——例如，如果第一个计算的正确结果在1.27到1.30之间（不包括1.30）。
- en: About the only reasonable test is to see if the two values are within the error
    tolerance of each other. If so, treat the values as equal (neither is considered
    less than or greater than the other). If the values are not equal within the desired
    error tolerance, you can compare them to see if one value is less than or greater
    than the other. This is known as a *miserly approach*; that is, we try to find
    as few values that are less than or greater than as possible.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一合理的测试方法是检查这两个值是否在误差容限范围内。如果是，则视为相等（两者不认为小于或大于对方）。如果这些值在期望的误差容限内不相等，你可以将它们进行比较，看是否一个值小于或大于另一个值。这被称为*吝啬方法*；也就是说，我们尽量找出最少的值小于或大于的情况。
- en: 'The other possibility is to use an *eager approach*, which attempts to make
    the result of the comparison `true` as often as possible. Given two values to
    compare and an error tolerance, here’s how you’d eagerly compare the two values
    for less than or greater than:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是使用*急功近利方法*，它试图尽可能使比较结果为`true`。给定两个要比较的值和一个误差容限，下面是如何急功近利地比较两个值的大小：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Don’t forget that calculations like (`B +` error) are subject to their own inaccuracies,
    depending on the relative magnitudes of the values `B` and error, and the inaccuracy
    of this calculation may affect the final result of the comparison.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，像（`B +`误差）这样的计算也可能会有自己的不准确性，这取决于值`B`和误差的相对大小，以及此计算的不准确性可能会影响比较的最终结果。
- en: '**NOTE**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Due to space limitations, this book merely touches on some major problems
    that can occur when you’re using floating-point values and why you can’t treat
    floating-point arithmetic like real arithmetic. For further details, consult a
    good text on numerical analysis or even scientific computing. If you’re going
    to be working with floating-point arithmetic,* in any language, *take some time
    to study the effects of limited-precision arithmetic on your computations.*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于篇幅限制，本书仅简单介绍了在使用浮点值时可能出现的一些主要问题，以及为什么你不能将浮点运算当作实数运算来看待。如需详细了解，请查阅一本优秀的数值分析或科学计算教材。如果你打算使用浮点运算，*无论使用哪种语言，*都应花时间研究有限精度运算对计算结果的影响。*'
- en: '**4.2 IEEE Floating-Point Formats**'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**4.2 IEEE浮点格式**'
- en: When Intel planned to introduce a floating-point unit (FPU) for its original
    8086 microprocessor, the company was smart enough to realize that the electrical
    engineers and solid-state physicists who design chips probably didn’t have the
    necessary numerical analysis background to design a good floating-point representation.
    So, Intel went out and hired the best numerical analyst it could find to design
    a floating-point format for its 8087 FPU. That person then hired two other experts
    in the field, and the three of them (Kahan, Coonen, and Stone) designed the *KCS
    Floating-Point Standard*. They did such a good job that the IEEE organization
    used this format as the basis for the IEEE Std 754 floating-point format.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当英特尔计划为其原始的8086微处理器引入浮点单元（FPU）时，公司足够聪明地意识到，设计芯片的电气工程师和固态物理学家可能没有足够的数值分析背景来设计一个好的浮点表示。所以，英特尔出资雇用了它能找到的最优秀的数值分析师来为其8087
    FPU设计浮点格式。那位专家随后雇用了另外两位该领域的专家，他们三人（卡汉、库宁和斯通）共同设计了*KCS浮点标准*。他们的工作非常出色，以至于IEEE组织将此格式作为IEEE
    Std 754浮点格式的基础。
- en: 'To handle a wide range of performance and accuracy requirements, Intel actually
    introduced *three* floating-point formats: single precision, double precision,
    and extended precision. The single- and double-precision formats corresponded
    to C’s `float` and `double` types or FORTRAN’s `real` and `double precision` types.
    Extended precision contains 16 extra bits that long chains of computations can
    use as guard bits before rounding down to a double-precision value when storing
    the result.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理广泛的性能和精度要求，英特尔实际上引入了*三种*浮点格式：单精度、双精度和扩展精度。单精度和双精度格式对应于C语言中的`float`和`double`类型，或FORTRAN中的`real`和`double
    precision`类型。扩展精度包含16个额外的位，长链计算可以使用这些位作为保护位，在将结果四舍五入到双精度值时进行存储。
- en: '***4.2.1 Single-Precision Floating-Point Format***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.2.1 单精度浮点格式***'
- en: 'The single-precision format uses a 24-bit mantissa and an 8-bit exponent. The
    mantissa represents a value between 1.0 and just less than 2.0\. The HO bit of
    the mantissa is always `1` and represents a value just to the left of the binary
    point. The remaining 23 mantissa bits appear to the right of the binary point
    and represent the value:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 单精度格式使用24位尾数和8位指数。尾数表示一个值，范围在1.0到接近2.0之间。尾数的HO位始终为`1`，表示二进制点的左侧值。剩余的23位尾数位出现在二进制点右侧，表示该值：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The mantissa is always greater than or equal to 1 because of the implied `1`
    bit. Even if the other mantissa bits are all `0`, the implied `1` bit always gives
    us the value `1`. Each position to the right of the binary point represents a
    value (`0` or `1`) times a successive negative power of 2, but even if we had
    an almost infinite number of `1` bits after the binary point, they still would
    not add up to 2\. So, the mantissa can represent values in the range 1.0 to just
    less than 2.0.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于隐含的`1`位，尾数始终大于或等于1。即使其他尾数位都是`0`，隐含的`1`位也总是给我们值`1`。二进制点右侧的每个位置表示一个值（`0`或`1`）乘以连续的负二次幂，但即使我们在二进制点后有几乎无限多个`1`位，它们仍然不能加到2。因此，尾数可以表示的值范围是1.0到接近2.0。
- en: 'Some examples would probably be useful here. Consider the decimal value 1.7997\.
    Here are the steps we could go through to compute the binary mantissa for this
    value:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能需要一些例子。考虑十进制值1.7997。以下是我们可以用来计算此值的二进制尾数的步骤：
- en: Subtract 2⁰ from 1.7997 to produce 0.7997 and `%1.00000000000000000000000`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从1.7997中减去2⁰，得到0.7997和`%1.00000000000000000000000`。
- en: Subtract 2^(–1) (¹/[2]) from 0.7997 to produce 0.2997 and `%1.10000000000000000000000`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从0.7997中减去2^(–1) (¹/[2])，得到0.2997和`%1.10000000000000000000000`。
- en: Subtract 2^(–2) (¹/[4]) from 0.2997 to produce 0.0497 and `%1.11000000000000000000000`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从0.2997中减去2^(–2) (¹/[4])，得到0.0497和`%1.11000000000000000000000`。
- en: Subtract 2^(–5) (¹/[32]) from 0.0497 to produce 0.0185 and `%1.11001000000000000000000`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从0.0497中减去2^(–5) (¹/[32])，得到0.0185和`%1.11001000000000000000000`。
- en: Subtract 2^(–6) (¹/[64]) from 0.0185 to produce 0.00284 and `%1.11001100000000000000000`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从0.0185中减去2^(–6) (¹/[64])，得到0.00284和`%1.11001100000000000000000`。
- en: Subtract 2^(–9) (¹/[512]) from 0.00284 to produce 0.000871 and `%1.11001100100000000000000`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从0.00284中减去2^(–9) (¹/[512])，得到0.000871和`%1.11001100100000000000000`。
- en: Subtract 2^(-10) (¹/[1,024]) from 0.000871 to (approximately) produce 0 and
    `%1.11001100110000000000000`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从0.000871中减去2^(-10) (¹/[1,024])，（大约）得到0和`%1.11001100110000000000000`。
- en: Although there is an infinite number of values between 1 and 2, we can represent
    only 8 million (2^(23) ) of them because we use a 23-bit mantissa (the 24th bit
    is always `1`), and therefore have only 23 bits of precision.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管1和2之间有无穷多个值，但我们只能表示其中的800万（2^(23)）个，因为我们使用的是23位尾数（第24位总是`1`），因此只有23位的精度。
- en: The mantissa uses a *one’s complement* format rather than two’s complement.
    This means that the 24-bit value of the mantissa is simply an unsigned binary
    number, and the sign bit, in bit position 31, determines whether that value is
    positive or negative. One’s complement has the unusual property that there are
    two representations for `0` (with the sign bit set or clear). Generally, this
    is important only to the person designing the floating-point software or hardware
    system. We’ll assume that the value `0` always has the sign bit clear.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尾数使用的是*反码*格式，而不是二进制补码。这意味着尾数的24位值仅仅是一个无符号的二进制数，符号位在第31位，决定该值是正数还是负数。反码有一个不寻常的特性，那就是`0`有两个表示（符号位可以设置或清除）。通常，这一点对于设计浮点软件或硬件系统的人来说很重要。我们假设`0`的符号位始终是清除的。
- en: The single-precision floating-point format is shown in [Figure 4-2](ch04.xhtml#ch04fig02).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 单精度浮点格式如[图4-2](ch04.xhtml#ch04fig02)所示。
- en: '![image](../images/04fig02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/04fig02.jpg)'
- en: '*Figure 4-2: Single-precision (32-bit) floating-point format*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-2：单精度（32位）浮点格式*'
- en: We represent values outside the range of the mantissa by raising 2 to the power
    specified by the exponent and then multiplying the result by the mantissa. The
    exponent is 8 bits and uses an [*excess-127* format](gloss01.xhtml#gloss01_89)
    (sometimes called *bias-127 exponents*). In excess-127 format, the exponent 2⁰
    is represented by the value 127 (`$7f`). To convert an exponent to excess-127
    format, add 127 to the exponent value. For example, the single-precision representation
    for 1.0 is `$3f800000`. The mantissa is 1.0 (including the implied bit) and the
    exponent is 2⁰, encoded as 127 (`$7f`). The representation for 2.0 is `$40000000`,
    with the exponent 2¹ encoded as 128 (`$80`).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将2的指数指定的幂次方提升，然后将结果与尾数相乘来表示超出尾数范围的值。指数是8位，采用[*超出127格式*](gloss01.xhtml#gloss01_89)（有时称为*偏置-127指数*）。在超出127格式中，指数2⁰由值127（`$7f`）表示。要将一个指数转换为超出127格式，需要将127加到指数值上。例如，1.0的单精度表示为`$3f800000`。尾数是1.0（包括隐含位），指数是2⁰，编码为127（`$7f`）。2.0的表示为`$40000000`，指数2¹编码为128（`$80`）。
- en: The excess-127 exponent makes it easy to compare two floating-point numbers
    for less than or greater than as though they were unsigned integers, as long as
    we handle the sign bit (bit 31) separately. If the signs of the two values are
    not equal, then the positive value (the one with bit 31 set to `0`) is greater
    than the value that has the HO bit set to `1`.^([2](footnotes.xhtml#fn4_2a)) If
    the sign bits are both `0`, we use a straight unsigned binary comparison. If the
    signs are both `1`, we do an unsigned comparison but invert the result (that is,
    we treat less than as greater than and vice versa). On some CPUs, where a 32-bit
    unsigned comparison is much faster than a 32-bit floating-point comparison, it’s
    probably worthwhile to do the comparison using integer arithmetic rather than
    floating-point arithmetic.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 超出127的指数使得比较两个浮点数是否小于或大于变得容易，仿佛它们是无符号整数，只要我们单独处理符号位（第31位）。如果两个值的符号不同，那么符号位为`0`的正值大于符号位为`1`的值^([2](footnotes.xhtml#fn4_2a))。如果符号位都为`0`，我们使用直接的无符号二进制比较。如果符号位都为`1`，我们做无符号比较，但将结果反转（即，我们将“较小”视为“较大”，反之亦然）。在某些CPU上，32位无符号比较的速度远快于32位浮点比较，因此，使用整数运算而非浮点运算进行比较可能会更有效。
- en: A 24-bit mantissa provides approximately 6½ decimal digits of precision (one-half
    digit of precision means that the first six digits can be in the range 0..9, but
    the seventh digit can only be in the range 0 through *x* where *x* < 9 and is
    generally close to 5). With an 8-bit excess-127 exponent, the dynamic range of
    single-precision floating-point numbers is approximately 2^(±128) or about 10^(±38).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个24位的尾数提供大约6½位十进制精度（半位精度意味着前六位数字可以在0..9的范围内，而第七位数字只能在0到*x*的范围内，其中*x* < 9且通常接近5）。通过一个8位的超出127的指数，单精度浮点数的动态范围大约是2^(±128)，即大约10^(±38)。
- en: Although single-precision floating-point numbers are perfectly suitable for
    many applications, the dynamic range is unsuitable for many financial, scientific,
    and other applications. Furthermore, during long chains of computations, the limited
    accuracy may introduce significant error. For serious calculations, we need a
    floating-point format with more precision.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管单精度浮点数非常适合许多应用，但它的动态范围对于许多金融、科学及其他应用来说并不合适。此外，在长链计算中，有限的精度可能会引入显著的误差。对于精确的计算，我们需要一种具有更高精度的浮点格式。
- en: '***4.2.2 Double-Precision Floating-Point Format***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.2.2 双精度浮点格式***'
- en: The double-precision format helps overcome the problems of the single-precision
    floating-point. Using twice the space, the double-precision format has an 11-bit
    excess-1,023 exponent, a 53-bit mantissa (including an implied HO bit of `1`),
    and a sign bit. This provides a dynamic range of about 10^(±308) and 15 to 16+
    digits of precision, which is sufficient for most applications. Double-precision
    floating-point values take the form shown in [Figure 4-3](ch04.xhtml#ch04fig03).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 双精度格式有助于克服单精度浮点数的问题。使用两倍的空间，双精度格式具有11位的超出-1,023的指数，53位的尾数（包括一个隐含的HO位`1`）和一个符号位。这提供了大约10^(±308)的动态范围和15到16+位的精度，对于大多数应用程序来说已经足够。双精度浮点值的形式如[图4-3](ch04.xhtml#ch04fig03)所示。
- en: '![image](../images/04fig03.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/04fig03.jpg)'
- en: '*Figure 4-3: Double-precision (64-bit) floating-point format*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-3：双精度（64位）浮点格式*'
- en: '***4.2.3 Extended-Precision Floating-Point Format***'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.2.3 扩展精度浮点格式***'
- en: 'To ensure accuracy during long chains of computations involving double-precision
    floating-point numbers, Intel designed the extended-precision format. The extended-precision
    format uses 80 bits: a 64-bit mantissa, a 15-bit excess-16,383 exponent, and a
    1-bit sign. The mantissa does not have an implied HO bit that is always `1`. The
    format for the extended-precision floating-point value appears in [Figure 4-4](ch04.xhtml#ch04fig04).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保在涉及双精度浮动点数的长链计算中保持准确性，英特尔设计了扩展精度格式。扩展精度格式使用80位：64位尾数、15位超出16,383的指数和1位符号。尾数没有隐含的HO位，始终为`1`。扩展精度浮动点值的格式见[图4-4](ch04.xhtml#ch04fig04)。
- en: '![image](../images/04fig04.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/04fig04.jpg)'
- en: '*Figure 4-4: Extended-precision (80-bit) floating-point format*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-4：扩展精度（80位）浮动点格式*'
- en: On the 80x86 FPUs, all computations use the extended-precision form. Whenever
    you load a single- or double-precision value, the FPU automatically converts it
    to an extended-precision value. Likewise, when you store a single- or double-precision
    value to memory, the FPU automatically rounds the value down to the appropriate
    size before storing it. The extended-precision format guarantees the inclusion
    of a large number of guard bits in 32- and 64-bit computations, which helps ensure
    (but not guarantee) that you’ll get full 32- or 64-bit accuracy in your computations.
    Some error will inevitably creep into the LO bits because the FPUs provide no
    guard bits for 80-bit computations (the FPU uses only 64 mantissa bits during
    80-bit computations). While you can’t assume that you’ll get an accurate 80-bit
    computation, you can usually do better than 64 bits when using the extended-precision
    format.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在80x86 FPU上，所有计算都使用扩展精度格式。每当你加载单精度或双精度值时，FPU会自动将其转换为扩展精度值。同样，当你将单精度或双精度值存储到内存时，FPU会在存储前自动将该值四舍五入到适当的大小。扩展精度格式确保32位和64位计算中包含大量的保护位，这有助于确保（但不能保证）你在计算中获得完整的32位或64位精度。由于FPU在80位计算中不提供保护位（FPU在80位计算中仅使用64位尾数），因此一些误差不可避免地会渗入LO位。虽然你不能假设你会得到准确的80位计算结果，但通常使用扩展精度格式时，你的计算结果会比64位更好。
- en: Non-Intel CPUs that support floating-point arithmetic generally provide only
    the 32-bit and 64-bit formats. Therefore, calculations on those CPUs may produce
    less accurate results than the equivalent string of calculations on the 80x86
    using 80-bit calculations. Also note that modern x86-64 CPUs have additional floating-point
    hardware as part of the SSE extensions; however, those SSE extensions support
    only 64- and 32-bit floating-point calculations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 支持浮动点运算的非英特尔CPU通常只提供32位和64位格式。因此，在这些CPU上进行的计算可能比在使用80位计算的80x86上进行的等效计算结果更不准确。还需注意，现代x86-64
    CPU具有作为SSE扩展一部分的额外浮动点硬件；然而，这些SSE扩展只支持64位和32位浮动点计算。
- en: '***4.2.4 Quad-Precision Floating-Point Format***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.2.4 四倍精度浮动点格式***'
- en: The original 80-bit extended-precision floating-point format was a stopgap measure.
    From a “types should be consistent” point of view, the proper extension to the
    64-bit floating-point format should have been a 128-bit floating-point format.
    Alas, when Intel was working on floating-point formats in the late 1970s, a quad-precision
    (128-bit) floating-point format was too expensive to implement in hardware, so
    the 80-bit extended-precision format became the interim compromise. Today, a few
    CPUs (such as IBM’s POWER9 and later-version ARMs) are capable of quad-precision
    floating-point arithmetic.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的80位扩展精度浮动点格式是一个过渡措施。从“类型应保持一致”的角度来看，64位浮动点格式的正确扩展应该是128位浮动点格式。可惜，当英特尔在1970年代末期研究浮动点格式时，四倍精度（128位）浮动点格式在硬件上实现成本过高，因此80位扩展精度格式成为了过渡的折衷方案。今天，一些CPU（如IBM的POWER9及后续版本的ARM）能够进行四倍精度浮动点运算。
- en: The IEEE Std 754 quad-precision floating-point format uses a single sign bit,
    a 15-bit excess-16,383 biased exponent, and a 112-bit (with implied 113th bit)
    mantissa (see [Figure 4-5](ch04.xhtml#ch04fig05)). This provides 36 decimal digits
    of precision and exponents in the approximate range 10^(±4932).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: IEEE Std 754四倍精度浮动点格式使用一个符号位、一个15位的超出16,383的偏移指数和一个112位（含隐含113位）尾数（见[图4-5](ch04.xhtml#ch04fig05)）。这提供了36位十进制数字的精度，并且指数的大致范围为10^(±4932)。
- en: '![image](../images/04fig05.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/04fig05.jpg)'
- en: '*Figure 4-5: Extended-precision (80-bit) floating-point format*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-5：扩展精度（80位）浮动点格式*'
- en: '**4.3 Normalization and Denormalized Values**'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**4.3 归一化和非归一化值**'
- en: To maintain maximum precision during floating-point computations, most computations
    use *normalized* values. A normalized floating-point value is one whose HO mantissa
    bit contains `1`. A floating-point computation will be more accurate if it involves
    only normalized values because the mantissa has that many fewer bits of precision
    available for computation if several HO bits of the mantissa are all `0`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在浮点运算中保持最大精度，大多数计算使用*规范化*值。一个规范化的浮点值是其高阶尾数位包含`1`的值。如果浮点计算仅涉及规范化值，则计算将更加精确，因为如果尾数的多个高阶位都为`0`，尾数的可用精度位数就会大大减少，从而影响计算精度。
- en: You can normalize almost any unnormalized value by shifting the mantissa bits
    to the left and decrementing the exponent until a `1` appears in the mantissa’s
    HO bit.^([3](footnotes.xhtml#fn4_3a)) Remember, the exponent is a binary exponent.
    Each time you increment the exponent, you multiply the floating-point value by
    2\. Likewise, whenever you decrement the exponent, you divide the floating-point
    value by 2\. By the same token, shifting the mantissa to the left one bit position
    multiplies the floating-point value by 2, and shifting it to the right divides
    the floating-point value by 2\. Therefore, shifting the mantissa to the left one
    position *and* decrementing the exponent does not change the value of the floating-point
    number (this is why, as you saw earlier, there are multiple representations for
    certain numbers in the floating-point format).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以通过将尾数位向左移动并减少指数，直到尾数的高阶位出现`1`，来规范化任何非规范化值^([3](footnotes.xhtml#fn4_3a))。记住，指数是二进制指数。每次增加指数时，浮点值会乘以2。同样，每次减少指数时，浮点值会除以2。因此，将尾数向左移动一位并减小指数不会改变浮点数的值（这就是为什么，如你之前所见，某些数字在浮点格式中有多个表示方法）。
- en: 'Here’s an example of an unnormalized value:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个非规范化值的示例：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Shift the mantissa to the left one position and decrement the exponent to normalize
    it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将尾数向左移动一位，并将指数减小，以便将其规范化：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are two important cases in which a floating-point number cannot be normalized.
    First, 0 cannot be normalized because the floating-point representation contains
    all `0` bits in the exponent and mantissa fields. This, however, is not a problem,
    because we can exactly represent 0 with a single `0` bit, and extra bits of precision
    are unnecessary.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种重要的情况，浮点数无法被规范化。首先，0无法规范化，因为浮点表示在指数和尾数字段中都包含所有的`0`位。不过这并不成问题，因为我们可以用一个单一的`0`位精确表示0，额外的精度位是没有必要的。
- en: We also cannot normalize a floating-point number when we have some HO bits in
    the mantissa that are `0` but the biased exponent^([4](footnotes.xhtml#fn4_4a))
    is also `0` (and we can’t decrement it to normalize the mantissa). Rather than
    prohibiting certain small values whose HO mantissa bits and biased exponent are
    `0` (the most negative exponent possible), the IEEE standard permits special *denormalized*
    values in these cases.^([5](footnotes.xhtml#fn4_5a)) Although the use of denormalized
    values enables IEEE floating-point computations to produce better results than
    if underflow occurred, denormalized values offer fewer bits of precision.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当尾数的某些高阶位为`0`，但是偏置指数^([4](footnotes.xhtml#fn4_4a))也为`0`时，我们也无法规范化浮点数（并且我们不能通过减小指数来规范化尾数）。IEEE标准允许在这些情况下使用特殊的*非规范化*值，而不是禁止某些高阶尾数位和偏置指数均为`0`的小值（这是可能的最小指数）。尽管使用非规范化值使得IEEE浮点运算能够在不发生下溢的情况下产生更好的结果，但非规范化值提供的精度位数较少。
- en: '**4.4 Rounding**'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**4.4 四舍五入**'
- en: 'During a calculation, floating-point arithmetic functions may produce a result
    with greater precision than the floating-point format supports (the *guard bits*
    in the calculation maintain this extra precision). When the calculation is complete
    and the code needs to store the result back into a floating-point variable, something
    must be done about those extra bits of precision. How the system uses guard bits
    to affect the remaining bits is known as *rounding*, and how rounding is done
    can affect the accuracy of the computation. Traditionally, floating-point software
    and hardware use one of four different ways to round values: truncation, rounding
    up, rounding down, or rounding to nearest.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算过程中，浮点算术函数可能会产生比浮点格式支持的精度更高的结果（计算中的*保护位*保持了这部分额外的精度）。当计算完成后，代码需要将结果存储回浮点变量时，必须处理这些多余的精度位。系统如何使用保护位影响剩余位数的方式称为*舍入*，而舍入的方式会影响计算的准确性。传统上，浮点软件和硬件使用四种不同的方式来舍入值：截断、向上舍入、向下舍入或舍入到最接近值。
- en: Truncation is easy, but it generates the least accurate results in a chain of
    computations. Few modern floating-point systems use truncation except as a means
    for converting floating-point values to integers (truncation is the standard conversion
    for coercing a floating-point value to an integer).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 截断操作很简单，但在一系列计算中产生的结果最不准确。除了将浮点值转换为整数的手段外，现代的浮点系统几乎不使用截断（截断是将浮点值强制转换为整数的标准方式）。
- en: Rounding up leaves the value alone if the guard bits are all `0`, but if the
    current mantissa does not exactly fit into the destination bits, then rounding
    up sets the mantissa to the smallest possible larger value in the floating-point
    format. Like truncation, this is not a normal rounding mode. It is, however, useful
    for implementing functions like `ceil()`, which rounds a floating-point value
    to the smallest possible larger integer.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 向上舍入会保持数值不变，如果保护位（guard bits）全为`0`，但如果当前的尾数无法精确适应目标位数，向上舍入会将尾数设置为浮点格式中可能的最小较大值。像截断一样，这并不是一种常规的舍入方式。然而，它对于实现像`ceil()`这样的函数非常有用，`ceil()`会将浮点值舍入为最小可能的较大整数。
- en: 'Rounding down is just like rounding up, except it rounds the result to the
    largest possible smaller value. This may sound like truncation, but there’s a
    subtle difference: truncation always rounds toward 0\. For positive numbers, truncation
    and rounding down do the same thing. For negative values, truncation simply uses
    the existing bits in the mantissa, whereas rounding down will add a `1` bit to
    the LO position if the result was negative. This is also not a normal rounding
    mode, but it’s useful for implementing functions like `floor()`, which rounds
    a floating-point value to the largest possible smaller integer.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 向下舍入与向上舍入类似，只不过它将结果舍入为最大的可能较小值。这听起来像是截断，但有一个微妙的区别：截断始终朝着0舍入。对于正数来说，截断和向下舍入执行的是相同的操作。对于负数，截断只是使用尾数中的现有位数，而向下舍入则会在最低有效位置（LO
    position）添加一个`1`位。如果结果为负数，向下舍入也会与截断不同。这也不是常规的舍入方式，但它对于实现像`floor()`这样的函数非常有用，`floor()`会将浮点值舍入为最大的可能较小整数。
- en: Rounding to nearest is the most intuitive way to process the guard bits. If
    the value of the guard bits is less than half the value of the mantissa’s LO bit,
    then rounding to nearest truncates the result to the largest possible smaller
    value (ignoring the sign). If the guard bits represent some value that is greater
    than half of the value of the LO mantissa bit, then rounding to nearest rounds
    the mantissa to the smallest possible greater value (ignoring the sign). If the
    guard bits represent a value that is exactly half the value of the mantissa’s
    LO bit, then the IEEE floating-point standard says that half the time it should
    round up and half the time it should round down. You do this by rounding the mantissa
    to the value that has a `0` in the LO bit position. That is, if the current mantissa
    already has a `0` in its LO bit, you use the current mantissa; if the current
    mantissa has a `1` in its LO bit, then you add 1 to round it up to the smallest
    possible larger value with a `0` in the LO bit. This scheme, mandated by the IEEE
    floating-point standard, produces the best possible result when loss of precision
    occurs.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 四舍五入到最近是处理守护位的最直观方式。如果守护位的值小于尾数 LO 位的一半，那么四舍五入到最近将结果截断为最大的可能较小值（忽略符号）。如果守护位表示的值大于尾数
    LO 位的一半，则四舍五入到最近将尾数舍入为最小的可能较大值（忽略符号）。如果守护位表示的值正好是尾数 LO 位的一半，那么 IEEE 浮动点标准规定，应该有一半的时间向上舍入，一半的时间向下舍入。你可以通过将尾数舍入到
    LO 位为 `0` 的值来实现这一点。也就是说，如果当前尾数的 LO 位已经是 `0`，则使用当前尾数；如果当前尾数的 LO 位是 `1`，则加 1 以将其舍入到
    LO 位为 `0` 的最小较大值。根据 IEEE 浮动点标准，采用这种方案，在精度丢失的情况下可以产生最佳的结果。
- en: 'Here are some examples of rounding, using 24-bit mantissas, with 4 guard bits
    (that is, these examples round 28-bit numbers to 24-bit numbers using the rounding
    to nearest algorithm):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些四舍五入的例子，使用 24 位尾数，4 个守护位（即这些例子使用四舍五入到最近算法将 28 位数字四舍五入为 24 位数字）：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**4.5 Special Floating-Point Values**'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**4.5 特殊浮动点值**'
- en: The IEEE floating-point format provides a special encoding for several special
    values. In this section, we’ll look these special values, their purpose and meaning,
    and their representation in the floating-point format.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: IEEE 浮动点格式为几个特殊值提供了特殊编码。在本节中，我们将探讨这些特殊值，它们的目的和意义，以及它们在浮动点格式中的表示。
- en: Under normal circumstances, the exponent bits of a floating-point number do
    not contain all `0`s or all `1`s. An exponent containing all `1` or `0` bits indicates
    a special value.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，浮动点数的指数位不会包含所有 `0` 或所有 `1`。包含所有 `1` 或 `0` 位的指数表示特殊值。
- en: If the exponent contains all `1`s and the mantissa is nonzero (discounting the
    implied bit), then the HO bit of the mantissa (again discounting the implied bit)
    determines whether the value represents a *quiet not-a-number* (QNaN) or a *signaling
    not-a-number* (SNaN) (see [Table 4-1](ch04.xhtml#ch04tab01)). These not-a-number
    (NaN) results tell the system that some serious miscalculation has taken place
    and that the result of the calculation is completely undefined. QNaNs represent
    *indeterminate* results, while SNaNs specify that an *invalid* operation has taken
    place. Any calculation involving a NaN produces a NaN result, regardless of the
    values of any other operand(s). Note that the sign bit is irrelevant for NaNs.
    The binary representations of NaNs are shown in [Table 4-1](ch04.xhtml#ch04tab01).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指数包含所有 `1`，且尾数非零（不考虑隐式位），则尾数的 HO 位（同样不考虑隐式位）决定该值是否表示 *安静的非数字*（QNaN）或 *信号非数字*（SNaN）（见
    [表 4-1](ch04.xhtml#ch04tab01)）。这些非数字（NaN）结果告诉系统发生了严重的误算，计算结果是完全未定义的。QNaN 表示 *不确定*
    的结果，而 SNaN 表示发生了 *无效* 操作。任何涉及 NaN 的计算都会产生 NaN 结果，无论其他操作数的值如何。请注意，对于 NaN，符号位无关紧要。NaN
    的二进制表示见 [表 4-1](ch04.xhtml#ch04tab01)。
- en: '**Table 4-1:** Binary Representations for NaN'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-1：** NaN 的二进制表示'
- en: '| **NaN** | **FP format** | **Value** |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **NaN** | **FP 格式** | **值** |'
- en: '| SNaN | 32 bits | `%s_11111111_0`xxxx...xx(The value of `s` is irrelevant—at
    least one of the x bits must be nonzero.) |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| SNaN | 32 位 | `%s_11111111_0`xxxx...xx（`s` 的值无关紧要—至少有一个 x 位必须为非零。） |'
- en: '| SNaN | 64 bits | `%s_1111111111_0`xxxxx`...`x(The value of `s` is irrelevant—at
    least one of the x bits must be nonzero.) |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| SNaN | 64 位 | `%s_1111111111_0`xxxxx`...`x（`s` 的值无关紧要—至少有一个 x 位必须为非零。） |'
- en: '| SNaN | 80 bits | `%``s_1111111111_0`xxxxx...x(The value of `s` is irrelevant—at
    least one of the x bits must be nonzero.) |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| SNaN | 80位 | `%``s_1111111111_0`xxxxx...x（`s`的值无关紧要——至少有一个x位必须非零。） |'
- en: '| QNaN | 32 bits | `%s_11111111_1`xxxx...xx(The value of `s` is irrelevant.)
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| QNaN | 32位 | `%s_11111111_1`xxxx...xx（`s`的值无关紧要。） |'
- en: '| QNaN | 64 bits | `%s_1111111111_1`xxxxx...x(The value of `s` is irrelevant.)
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| QNaN | 64位 | `%s_1111111111_1`xxxxx...x（`s`的值无关紧要。） |'
- en: '| QNaN | 80 bits | `%s_1111111111_1`xxxxx...x(The value of `s` is irrelevant.)
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| QNaN | 80位 | `%s_1111111111_1`xxxxx...x（`s`的值无关紧要。） |'
- en: Two other special values are represented when the exponent contains all 1 bits,
    and the mantissa contains all 0s. In such a case, the sign bit determines whether
    the result is the representation for +*infinity* or –*infinity*. Whenever a calculation
    involves infinity as one of the operands, the result will be one of the (well-defined)
    values found in [Table 4-2](ch04.xhtml#ch04tab02).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另有两个特殊值，当指数包含全1位，尾数包含全0时进行表示。在这种情况下，符号位决定结果是表示+*infinity*还是–*infinity*。每当一个计算涉及到无限大作为其中一个操作数时，结果将会是[表4-2](ch04.xhtml#ch04tab02)中定义的（明确的）值之一。
- en: '**Table 4-2:** Operations Involving Infinity'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**表4-2：** 涉及无限大的操作'
- en: '| **Operation** | **Result** |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **结果** |'
- en: '| `n / ±infinity` | `0` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `n / ±infinity` | `0` |'
- en: '| `±infinity × ±infinity` | `±infinity` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `±infinity × ±infinity` | `±infinity` |'
- en: '| `±nonzero / 0` | `±infinity` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `±nonzero / 0` | `±infinity` |'
- en: '| `infinity + infinity` | `infinity` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `infinity + infinity` | `infinity` |'
- en: '| `n + infinity` | `infinity` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `n + infinity` | `infinity` |'
- en: '| `n - infinity` | `-infinity` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `n - infinity` | `-infinity` |'
- en: '| `±0 / ±0` | `NaN` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `±0 / ±0` | `NaN` |'
- en: '| `infinity - infinity` | `NaN` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `infinity - infinity` | `NaN` |'
- en: '| `±infinity / ±infinity` | `NaN` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `±infinity / ±infinity` | `NaN` |'
- en: '| `±infinity × 0` | `NaN` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `±infinity × 0` | `NaN` |'
- en: Finally, if the exponent bits are all `0`, the sign bit indicates which of the
    two special values, –0 or +0, the floating-point number represents. Because the
    floating-point format uses a one’s complement notation, there are two separate
    representations for 0\. Note that with respect to comparisons, arithmetic, and
    other operations, +0 is equal to –0.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果指数位全为`0`，符号位指示浮点数表示的是两个特殊值中的哪一个，即–0或+0。因为浮点格式使用的是反码表示法，所以0有两种不同的表示。需要注意的是，在比较、算术和其他操作中，+0与–0是相等的。
- en: Using Multiple Representations of Zero
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多重零表示
- en: The IEEE floating-point format supports both +0 and –0 (depending on the value
    of the sign bit), which are treated as equivalent by arithmetic calculations and
    comparisons—the sign bit is ignored. Software operating on floating-point values
    that represent 0 can use the sign bit as a flag to indicate different things.
    For example, you could use the sign bit to indicate that the value is exactly
    0 (with the sign bit clear) or to indicate that it is nonzero but too small to
    represent with the current format (with the sign bit set). Intel recommends using
    the sign bit to indicate that 0 was produced via underflow of a negative value
    (with the sign bit set) or underflow of a positive number (with the sign bit clear).
    Presumably, their FPUs set the sign bit according to their recommendations when
    the FPUs produce a `0` result.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: IEEE浮点格式支持+0和–0（取决于符号位的值），它们在算术运算和比较中被视为相等——符号位被忽略。操作浮点值的软件可以使用符号位作为标志来表示不同的含义。例如，可以使用符号位指示值为0（符号位清除）或表示该值非零但太小，无法用当前格式表示（符号位设置）。英特尔建议使用符号位来指示0是通过负值的下溢（符号位设置）或正值的下溢（符号位清除）产生的。假设它们的FPU会根据推荐的方式设置符号位，当FPU产生`0`结果时。
- en: '**4.6 Floating-Point Exceptions**'
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**4.6 浮点异常**'
- en: 'The IEEE floating-point standard defines certain degenerate conditions under
    which the floating-point processor (or software-implemented floating-point code)
    should notify the application software. These exceptional conditions include the
    following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: IEEE浮点标准定义了一些退化条件，在这些条件下，浮点处理器（或软件实现的浮点代码）应当通知应用程序。这些特殊条件包括：
- en: Invalid operation
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无效操作
- en: Division by zero
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除零
- en: Denormalized operand
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非规格化操作数
- en: Numeric overflow
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值溢出
- en: Numeric underflow
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值下溢
- en: Inexact result
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不精确的结果
- en: Of these, inexact result is the least serious, because most floating-point calculations
    will produce an inexact result. A denormalized operand also isn’t too serious
    (though this exception indicates that your calculation may be less accurate as
    a result of less available precision). The other exceptions indicate a more serious
    problem, and you shouldn’t ignore them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些异常中，不精确的结果是最轻微的，因为大多数浮动点计算都会产生不精确的结果。非规格化操作数也不算太严重（尽管这个异常表明你的计算可能因为精度不足而不那么准确）。其他的异常则表示更严重的问题，你不应该忽视它们。
- en: How the computer system notifies your application of these exceptions depends
    on the CPU/FPU, operating system, and programming language, so we can’t really
    go into how you might handle these exceptions. Generally, though, you can use
    the exception handling facilities in your programming language to trap these conditions
    as they occur. Note that most computer systems won’t notify you when one of the
    exceptional conditions exists unless you explicitly set up a notification.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机系统如何通知应用程序这些异常情况，取决于 CPU/FPU、操作系统和编程语言，因此我们无法详细讨论你可能如何处理这些异常。然而，一般来说，你可以使用编程语言中的异常处理机制来捕捉这些条件。请注意，大多数计算机系统不会在出现异常条件时通知你，除非你明确设置了通知机制。
- en: '**4.7 Floating-Point Operations**'
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**4.7 浮动点运算**'
- en: Although most modern CPUs support an FPU that does floating-point arithmetic
    in hardware, it’s worthwhile to develop a set of software floating-point arithmetic
    routines to get a solid feel for what’s involved. Generally, you’d use assembly
    language to write the math functions because speed is a primary design goal for
    a floating-point package. However, because here we’re writing a floating-point
    package simply to get a clearer picture of the process, we’ll opt for code that
    is easy to write, read, and understand.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数现代 CPU 支持硬件浮动点运算单元（FPU），但开发一套软件浮动点运算例程仍然值得尝试，这样可以更好地理解涉及的过程。通常，你会使用汇编语言来编写数学函数，因为速度是浮动点包的设计目标之一。然而，因为我们在这里编写浮动点包只是为了更清楚地了解过程，所以我们将选择容易编写、阅读和理解的代码。
- en: As it turns out, floating-point addition and subtraction are easy to do in a
    high-level language like C/C++ or Pascal, so we’ll implement these functions in
    these languages. Floating-point multiplication and division are easier to do in
    assembly language than in a high-level language, so we’ll write those routines
    using High-Level Assembly (HLA).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，浮动点加法和减法在 C/C++ 或 Pascal 这样的高级语言中非常容易实现，因此我们将在这些语言中实现这些函数。而浮动点乘法和除法在汇编语言中比在高级语言中更容易实现，所以我们将使用高级汇编语言（HLA）编写这些例程。
- en: '***4.7.1 Floating-Point Representation***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.7.1 浮动点表示***'
- en: This section will use the IEEE 32-bit single-precision floating-point format
    (shown earlier in [Figure 4-2](ch04.xhtml#ch04fig02)), which uses a one’s complement
    representation for signed values. This means that the sign bit (bit 31) contains
    a `1` if the number is negative and a `0` if the number is positive. The exponent
    is an 8-bit excess-127 exponent sitting in bits 23 through 30, and the mantissa
    is a 24-bit value with an implied HO bit of `1`. Because of the implied HO bit,
    this format does not support denormalized values.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将使用 IEEE 32 位单精度浮动点格式（如前面[图 4-2](ch04.xhtml#ch04fig02)所示），该格式采用补码表示法来表示带符号值。这意味着，如果数字为负数，则符号位（第
    31 位）为`1`，如果数字为正数，则符号位为`0`。指数是一个 8 位的超出 127 的指数，位于第 23 到第 30 位之间，尾数是一个 24 位的值，并且隐含的
    HO 位为`1`。由于有隐含的 HO 位，因此该格式不支持非规格化值。
- en: '***4.7.2 Floating-Point Addition and Subtraction***'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.7.2 浮动点加法和减法***'
- en: Addition and subtraction use essentially the same code. After all, computing
    `X` `-` `Y` is equivalent to computing `X + (-` `Y)`. If we can add a negative
    number to some other value, then we can also perform subtraction by first negating
    some number and then adding it to another value. And because the IEEE floating-point
    format uses the one’s complement representation, negating a value is trivial—we
    just invert the sign bit.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 加法和减法基本上使用相同的代码。毕竟，计算`X` `-` `Y` 相当于计算 `X + (-` `Y)`。如果我们能将负数加到某个其他值上，那么我们也能通过先将某个数字取反再加到另一个值上来进行减法。而且，由于
    IEEE 浮动点格式使用补码表示法，取反一个值是非常简单的——我们只需要反转符号位即可。
- en: 'Because we’re using the standard IEEE 32-bit single-precision floating-point
    format, we could theoretically get away with using the C/C++ `float` data type
    (assuming the underlying C/C++ compiler also uses this format, as most do on modern
    machines). However, you’ll soon see that when doing floating-point calculations
    in software, we need to manipulate various fields within the floating-point format
    as bit strings and integer values. Therefore, it’s more convenient to use a 32-bit
    `unsigned` integer type to hold the bit representation for our floating-point
    values. To avoid confusing our real values with actual integer values in a program,
    we’ll define the following `real` data type, which assumes that `unsigned` `long`s
    are 32-bit values in your implementation of C/C++ (this section assumes the `uint32_t`
    type achieves that, which is something like `typedef unsigned long uint32_t`),
    and declare all our real variables using this type:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用的是标准的 IEEE 32 位单精度浮点格式，理论上我们可以使用 C/C++ 的 `float` 数据类型（假设底层 C/C++ 编译器也使用这种格式，现代机器大多数都采用这种格式）。然而，你很快会发现，在软件中进行浮点计算时，我们需要将浮点格式中的各个字段作为位串和整数值进行操作。因此，使用
    32 位的 `unsigned` 整型来存储浮点值的位表示会更加方便。为了避免将我们的 `real` 值与程序中的实际整数值混淆，我们将定义以下 `real`
    数据类型，假设 `unsigned long` 是你 C/C++ 实现中的 32 位值（这一部分假设 `uint32_t` 类型实现了这一点，即类似于 `typedef
    unsigned long uint32_t`），并使用这种类型声明我们所有的 `real` 变量：
- en: '[PRE7]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: One advantage of using the same floating-point format that C/C++ uses for float
    values is that we can assign floating-point literal constants to our `real` variables,
    and we can perform other floating-point operations such as input and output using
    existing library routines. However, one potential problem is that C/C++ will attempt
    to automatically convert between integer and floating-point formats if we use
    a `real` variable in a floating-point expression (remember, as far as C/C++ is
    concerned, `real` is just an `unsigned long` integer value). This means that we
    need to tell the compiler to treat the bit patterns found in our `real` variables
    as though they were `float` objects.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C/C++ 用于浮点值的相同浮点格式有一个优点，那就是我们可以将浮点字面常量赋值给我们的 `real` 变量，并且可以使用现有的库例程执行其他浮点操作，如输入和输出。然而，一个潜在的问题是，如果我们在浮点表达式中使用
    `real` 变量，C/C++ 会尝试在整数和浮点格式之间自动转换（记住，在 C/C++ 中，`real` 只是一个 `unsigned long` 整数值）。这意味着我们需要告诉编译器将我们
    `real` 变量中的位模式视为 `float` 对象，而不是进行转换。
- en: 'A simple type coercion like `(float)` realVariable won’t work. The C/C++ compiler
    will emit code to convert the integer it believes realVariable contains into the
    equivalent floating-point value. However, we want the C/C++ compiler to treat
    the bit pattern it finds in realVariable as a `float` without doing any conversion.
    The following C/C++ macro is a sneaky way to do this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `(float)` realVariable 这样的简单类型强制转换是行不通的。C/C++ 编译器将生成代码，把它认为 realVariable 包含的整数转换为等效的浮点值。然而，我们希望
    C/C++ 编译器将 realVariable 中找到的位模式视为 `float`，而不进行任何转换。以下是一个巧妙的 C/C++ 宏实现：
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This macro requires a single parameter that must be a `real` variable. The result
    is a variable that the compiler believes is a `float` variable.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏需要一个参数，该参数必须是一个 `real` 变量。结果是一个编译器认为是 `float` 变量的变量。
- en: 'Now that we have our `float` variable, we’ll develop two C/C++ functions to
    compute floating-point addition and subtraction: `fpadd()` and `fpsub()`. These
    two functions each take three parameters: the left and right operands of the operator
    and a pointer to a destination where these functions will store their result.
    The prototypes for these functions are the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `float` 变量，我们将开发两个 C/C++ 函数来计算浮点加法和减法：`fpadd()` 和 `fpsub()`。这两个函数每个接受三个参数：操作符的左右操作数和一个指向目标的指针，这些函数将把结果存储到该目标中。这些函数的原型如下：
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `fpsub()` function negates the right operand and calls the `fpadd()` function.
    Here’s the code for the `fpsub()` function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`fpsub()` 函数对右操作数取反，并调用 `fpadd()` 函数。以下是 `fpsub()` 函数的代码：'
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `fpadd()` function is where all the real work is done. To make `fpadd()`
    a little easier to understand and maintain, we’ll decompose it into several different
    functions that help with various tasks. In an actual software floating-point library
    routine, you wouldn’t do this decomposition, because the extra subroutine calls
    would be a little slower; however, we’re developing `fpadd()` for educational
    purposes, and besides, if you need high-performance floating-point addition, you’ll
    probably use a hardware FPU rather than a software implementation.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`fpadd()`函数是执行所有实际工作的地方。为了让`fpadd()`更易于理解和维护，我们将其分解为几个不同的函数，每个函数执行不同的任务。在实际的软件浮点库程序中，通常不会这样分解，因为额外的子程序调用会稍微降低效率；然而，我们开发`fpadd()`是为了教学目的，而且如果你需要高性能的浮点加法，可能会使用硬件FPU而非软件实现。'
- en: The IEEE floating-point formats are good examples of packed data types. As you’ve
    seen in previous chapters, packed data types are great for reducing storage requirements
    for a data type, but not so much when you need to use the packed fields in actual
    calculations. Therefore, one of the first things our floating-point functions
    will do is unpack the sign, exponent, and mantissa fields from the floating-point
    representation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: IEEE浮点格式是打包数据类型的一个很好的例子。如你在前几章中所见，打包数据类型对于减少数据类型的存储需求非常有用，但在需要在实际计算中使用这些打包字段时就不太合适。因此，我们的浮点函数首先要做的一件事就是从浮点表示中解包符号、指数和尾数字段。
- en: The first unpacking function, `extractSign()`, extracts the sign bit (bit 31)
    from our packed floating-point representation and returns the value `0` (for positive
    numbers) or `1` (for negative numbers).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个解包函数`extractSign()`从我们打包的浮点表示中提取符号位（第31位），并返回值`0`（表示正数）或`1`（表示负数）。
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This code could have also extracted the sign bit using this (possibly more
    efficient) expression:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也可以使用这个（可能更高效的）表达式来提取符号位：
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: However, shifting bit 31 down to bit 0 is, arguably, easier to understand.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将第31位移到第0位可以说更容易理解。
- en: The next utility function, `extractExponent()`, unpacks the exponent from bits
    23 through 30 in the packed real format. It does this by shifting the real value
    to the right by 23 bits, masking out the sign bit, and converting the excess-127
    exponent to a two’s complement format (by subtracting 127).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个工具函数`extractExponent()`从打包的实数格式中解包指数位，范围为第23到30位。它通过将实数值右移23位，屏蔽符号位，并将超出127的指数转换为二进制补码格式（通过减去127）来实现。
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next is the `extractMantissa()` function, which extracts the mantissa from the
    real value. To extract the mantissa, we must mask out the exponent and sign bits
    and then insert the implied HO bit of `1`. The only catch is that we must return
    `0` if the entire value is `0`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`extractMantissa()`函数，它从实数值中提取尾数。为了提取尾数，我们必须屏蔽指数和符号位，然后插入隐含的`1`高位。唯一需要注意的是，如果整个值为`0`，我们必须返回`0`。
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you learned earlier, whenever adding or subtracting two values using scientific
    notation (which the IEEE floating-point format uses), you must first adjust the
    two values so that they have the same exponent. For example, to add the two decimal
    (base-10) numbers `1.2345e3` and `8.7654e1`, we must first adjust one or the other
    so that their exponents are the same. We can reduce the exponent of the first
    number by shifting the decimal point to the right. For example, the following
    values are all equivalent to `1.2345e3`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如你之前所学，每当使用科学计数法（IEEE浮点格式所使用的格式）进行加法或减法时，必须首先调整两个数值的指数，使它们相同。例如，要将两个十进制（基数为10）的数`1.2345e3`和`8.7654e1`相加，我们必须先调整其中一个数，使它们的指数相同。我们可以通过将第一个数的小数点右移来减少它的指数。例如，以下值都等价于`1.2345e3`：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Likewise, we can increase the value of an exponent by shifting the decimal
    point to the left. The following values are all equal to `8.7654e1`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以通过将小数点向左移动来增加指数的值。以下值都等价于`8.7654e1`：
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For floating-point addition and subtraction involving binary numbers, we can
    make the binary exponents the same by shifting the mantissa one position to the
    left and decrementing the exponent, or by shifting the mantissa one position to
    the right and incrementing the exponent.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于涉及二进制数的浮点加法和减法，我们可以通过将尾数左移一位并递减指数，或者将尾数右移一位并递增指数来使二进制指数相同。
- en: 'Shifting the mantissa bits to the right means that we reduce the precision
    of our number (because the bits wind up going off the LO end of the mantissa).
    To maintain as much accuracy as possible in our calculations, we shouldn’t truncate
    the bits we shift out of the mantissa, but rather round the result to the nearest
    value we can represent with the remaining mantissa bits. These are the IEEE rules
    for rounding, in order:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将尾数位右移意味着我们减少了数字的精度（因为这些位最终会被移出尾数的低位端）。为了在计算中尽可能保持准确性，我们不应截断右移出去的尾数位，而应该将结果四舍五入到我们可以用剩余的尾数位表示的最接近的值。这些是
    IEEE 四舍五入的规则，按顺序：
- en: Truncate the result if the last bit shifted out was a `0`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果最后被右移出去的位是 `0`，则截断结果。
- en: Increment the mantissa by 1 if the last bit shifted out was a `1` and there
    was at least one bit set to `1` in all the other bits that were shifted out.^([6](footnotes.xhtml#fn4_6a))
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果最后被右移出去的位是 `1`，并且所有其他被右移出去的位中至少有一个位被设置为 `1`，则将尾数加 1。^([6](footnotes.xhtml#fn4_6a))
- en: If the last bit we shifted out was a `1`, and all the other bits were `0`s,
    then round the resulting mantissa up by 1 if the mantissa’s LO bit contains a
    `1`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们右移出去的最后一位是 `1`，且所有其他位都是 `0`，则如果尾数的低位包含 `1`，则将结果尾数向上四舍五入 1。
- en: 'Shifting the mantissa and rounding it is a relatively complex operation, and
    it will occur a couple of times in the floating-point addition code. Therefore,
    it’s another candidate for a utility function. Here’s the C/C++ code that implements
    this function, `shiftAndRound()`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 右移尾数并进行四舍五入是一个相对复杂的操作，并且在浮点加法代码中会发生几次。因此，它是另一个可以作为工具函数的候选项。以下是实现此功能的 C/C++ 代码，`shiftAndRound()`：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The “trick” in this code is that it uses a couple of lookup tables, `masks`
    and `HOmasks`, to extract those bits that the mantissa will use from the shift
    right operation. The `masks` table entries contain `1` bits (set bits) in the
    positions that will be lost during the shift. The `HOmasks` table entries contain
    a single set bit in the position specified by the index into the table; that is,
    the entry at index 0 contains a `1` in bit position 0, the entry at index 1 contains
    a `1` in bit position 1, and so on. This code selects an entry from each of these
    tables based on the number of mantissa bits it needs to shift to the right.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的“技巧”在于它使用了几个查找表，`masks` 和 `HOmasks`，来提取尾数在右移操作中使用的那些位。`masks` 表中的条目包含 `1`
    位（已设置的位），这些位是右移过程中将会丢失的位置。`HOmasks` 表中的条目在由索引指定的位置包含一个单独的设置位；也就是说，索引为 0 的条目在位位置
    0 包含 `1`，索引为 1 的条目在位位置 1 包含 `1`，依此类推。该代码根据尾数需要右移的位数，从这两个表中各自选择一个条目。
- en: If the original mantissa value, logically ANDed with the appropriate entry in
    `masks`, is greater than the corresponding entry in `HOmasks`, then the `shiftAndRound()`
    function rounds the shifted mantissa to the next greater value. If the ANDed mantissa
    value is equal to the corresponding `HOmasks` element, this code rounds the shifted
    mantissa value according to its LO bit (note that the expression `(*valToShift
    & 1)` produces `1` if the mantissa’s LO bit is `1`, and it produces `0` otherwise).
    Finally, if the ANDed mantissa value is less than the entry from the `HOmasks`
    table, then this code doesn’t have to do anything because the mantissa is already
    rounded down.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果原始尾数值与 `masks` 中适当条目按位与的结果大于 `HOmasks` 中相应条目的值，则 `shiftAndRound()` 函数将右移后的尾数四舍五入到下一个较大的值。如果按位与后的尾数值等于相应的
    `HOmasks` 元素，则代码根据尾数的低位（LO 位）来四舍五入右移后的尾数值（请注意，表达式 `(*valToShift & 1)` 如果尾数的低位是
    `1` 会产生 `1`，否则产生 `0`）。最后，如果按位与后的尾数值小于 `HOmasks` 表中的条目，则代码不需要做任何操作，因为尾数已经被四舍五入到较小的值。
- en: Once we’ve adjusted one of the values so that the exponents of both operands
    are the same, the next step in the addition algorithm is to compare the signs
    of the values. If the signs of the two operands are the same, we add their mantissas
    (using a standard integer add operation). If the signs differ, we have to subtract,
    rather than add, the mantissas. Because floating-point values use one’s complement
    representation, and standard integer arithmetic uses two’s complement, we cannot
    simply subtract the negative value from the positive value. Instead, we have to
    subtract the smaller value from the larger value and determine the sign of the
    result based on the signs and magnitudes of the original operands. [Table 4-3](ch04.xhtml#ch04tab03)
    describes how to accomplish this.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们调整了其中一个值，使得两个操作数的指数相同，下一步就是在加法算法中比较值的符号。如果两个操作数的符号相同，我们将它们的尾数相加（使用标准整数加法操作）。如果符号不同，我们必须进行减法，而不是加法。由于浮点值使用的是反码表示，而标准整数运算使用的是补码表示，我们不能简单地将负值从正值中减去。相反，我们必须从较大的值中减去较小的值，并根据原始操作数的符号和大小确定结果的符号。[表
    4-3](ch04.xhtml#ch04tab03) 说明了如何实现这一点。
- en: '**Table 4-3:** Dealing with Operands That Have Different Signs'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-3：** 处理具有不同符号的操作数'
- en: '| **Left sign** | **Right sign** | **Left mantissa > right mantissa?** | **Compute
    mantissa as** | **Result****sign is** |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| **左符号** | **右符号** | **左尾数 > 右尾数？** | **计算尾数为** | **结果符号为** |'
- en: '| – | + | Yes | LeftMantissa `-` RightMantissa | – |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| – | + | 是 | 左尾数 `-` 右尾数 | – |'
- en: '| + | – | Yes | LeftMantissa `-` RightMantissa | + |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| + | – | 是 | 左尾数 `-` 右尾数 | + |'
- en: '| – | + | No | RightMantissa `-` LeftMantissa | + |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| – | + | 否 | 右尾数 `-` 左尾数 | + |'
- en: '| + | – | No | RightMantissa `-` LeftMantissa | – |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| + | – | 否 | 右尾数 `-` 左尾数 | – |'
- en: 'Whenever you’re adding or subtracting two 24-bit numbers, it’s possible to
    produce a result that requires 25 bits (in fact, this is common when you’re dealing
    with normalized values). Immediately after an addition or subtraction, the floating-point
    code has to check the result to see if overflow has occurred. If so, it needs
    to shift the mantissa right by 1 bit, round the result, and then increment the
    exponent. After completing this step, all that remains is to pack the resulting
    sign, exponent, and mantissa fields into the 32-bit IEEE floating-point format.
    The following `packFP()` function is responsible for packing the `sign`, `exponent`,
    and `mantissa` fields into the 32-bit floating-point format:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你加减两个 24 位数时，可能会产生一个需要 25 位的结果（实际上，当处理规范化值时，这是常见的）。加法或减法操作后，浮点代码必须检查结果，看看是否发生了溢出。如果发生溢出，它需要将尾数右移
    1 位，四舍五入结果，然后递增指数。完成此步骤后，剩下的就是将结果的符号、指数和尾数字段打包到 32 位 IEEE 浮点格式中。以下 `packFP()`
    函数负责将 `sign`、`exponent` 和 `mantissa` 字段打包到 32 位浮点格式中：
- en: '[PRE18]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that this function works for normalized values, denormalized values, and
    zero, but does not work for NaNs and infinities.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此函数适用于规范化值、非规范化值和零，但不适用于 NaN 和无穷大。
- en: 'With the utility routines out of the way, take a look at the `fpadd()` function,
    which adds two floating-point values, producing a 32-bit real result:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完实用程序例程后，看看 `fpadd()` 函数，它用于将两个浮点值相加，产生一个 32 位实数结果：
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To conclude this discussion of the software implementation of the `fpadd()`
    and `fsub()` functions, here’s a C `main()` function demonstrating their use:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为总结关于 `fpadd()` 和 `fsub()` 函数的软件实现讨论，以下是一个展示它们使用的 C `main()` 函数：
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here’s the output produced by compiling with Microsoft Visual C++ (and defining
    `uint32_t` as an `unsigned long`):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 Microsoft Visual C++ 编译（并将 `uint32_t` 定义为 `unsigned long`）时产生的输出：
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***4.7.3 Floating-Point Multiplication and Division***'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.7.3 浮点数乘法和除法***'
- en: Most software floating-point libraries are actually written in hand-optimized
    assembly language, not in a high-level language (HLL). As the previous section
    shows, it’s possible to write floating-point routines in an HLL and, particularly
    in the case of single-precision floating-point addition and subtraction, you could
    write the code efficiently. Given the right library routines, you could also write
    the floating-point multiplication and division routines in an HLL. However, because
    their implementation is actually easier in assembly language, this section presents
    an HLA implementation of the single-precision floating-point multiplication and
    division algorithms.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数软件浮点库实际上是用手工优化的汇编语言编写的，而不是用高级语言（HLL）编写的。正如前一节所示，实际上可以用高级语言编写浮点运算例程，特别是在单精度浮点加法和减法的情况下，您可以高效地编写代码。只要有合适的库函数，您还可以用高级语言编写浮点乘法和除法例程。然而，由于它们的实现实际上在汇编语言中更容易，因此本节展示了单精度浮点乘法和除法算法的HLA实现。
- en: 'The HLA code in this section implements two functions, `fpmul()` and `fpdiv()`,
    that have the following prototypes:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的HLA代码实现了两个函数，`fpmul()`和`fpdiv()`，它们有以下原型：
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Beyond the fact that this code is written in assembly language rather than C,
    it differs in two main ways from the code in the previous section. First, it uses
    the built-in `real32` data type rather than creating a new data type for the real
    values, because we can easily coerce any 32-bit memory object to `real32` or `dword`
    in assembly language. Second, these prototypes support only two parameters; there
    is no destination parameter. These functions simply return the `real32` result
    in the EAX register.^([7](footnotes.xhtml#fn4_7a))
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这段代码是用汇编语言而不是C语言编写的之外，它与前一节的代码有两个主要不同之处。首先，它使用内置的`real32`数据类型，而不是为实数值创建新的数据类型，因为我们可以轻松地将任何32位内存对象强制转换为`real32`或`dword`类型。其次，这些原型只支持两个参数；没有目标参数。这些函数简单地将`real32`结果返回在EAX寄存器中。^([7](footnotes.xhtml#fn4_7a))
- en: '**4.7.3.1 Floating-Point Multiplication**'
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**4.7.3.1 浮点乘法**'
- en: 'Whenever you multiply two values in scientific notation, you compute the result
    sign, exponent, and mantissa as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你在科学计数法中乘以两个值时，你需要按以下方式计算结果符号、指数和尾数：
- en: The result sign is the exclusive-OR of the operand signs. That is, the result
    is positive if both operand signs were the same, and the result sign is negative
    if the operand signs were different.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果符号是操作数符号的异或运算。也就是说，如果两个操作数的符号相同，结果符号为正；如果操作数的符号不同，结果符号为负。
- en: The result exponent is the sum of the operands’ exponents.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果指数是操作数指数的和。
- en: The result mantissa is the integer (fixed-point) product of the two operand
    mantissas.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果尾数是两个操作数尾数的整数（定点）乘积。
- en: 'There are a few additional rules that affect the floating-point multiplication
    algorithm that are a direct result of the IEEE floating-point format:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些附加规则影响浮点乘法算法，这些规则是IEEE浮点格式的直接结果：
- en: If either, or both, of the operands are `0`, the result is `0` (this is a special
    case because the representation for `0` is special).
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任一或两个操作数为`0`，结果就是`0`（这是一个特例，因为`0`的表示是特殊的）。
- en: If either operand is infinity, the result is infinity.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任一操作数是无穷大，结果就是无穷大。
- en: If either operand is a NaN, the result is that same NaN.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任一操作数是NaN，结果就是那个相同的NaN。
- en: The `fpmul()` procedure begins by checking if either of the operands is `0`.
    If so, the function immediately returns `0.0` to the caller. Next, the `fpmul()`
    code checks for NaN or infinity values in the `left` and `right` operands. If
    it finds one of these values, it returns that same value to the caller.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`fpmul()`过程首先检查任一操作数是否为`0`。如果是，函数立即返回`0.0`给调用者。接着，`fpmul()`代码检查`left`和`right`操作数是否为NaN或无穷大。如果发现其中一个值为NaN或无穷大，它将该值返回给调用者。'
- en: 'If both of the `fpmul()` operands are reasonable floating-point values, then
    the `fpmul()` code extracts the sign, exponent, and mantissa fields of the packed
    floating-point value. Actually, *extract* isn’t the correct term here; *isolate*
    is a better description. Here’s the code that isolates the sign bits of the two
    operands and computes the result sign:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`fpmul()`的两个操作数都是合理的浮点值，那么`fpmul()`代码将提取打包浮点值的符号、指数和尾数字段。实际上，*提取*在这里并不是正确的术语；*隔离*是更好的描述。以下是隔离两个操作数符号位并计算结果符号的代码：
- en: '[PRE23]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code exclusive-ORs the two operands and then masks out bits 0 through 30,
    leaving only the result sign value in bit 31 of the EBX register. This procedure
    doesn’t bother moving the sign bit down to bit 0 (as you’d normally do when unpacking
    data), because it would just have to move this bit back to bit 31 when it repacks
    the floating-point value later.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码对两个操作数进行异或运算，然后屏蔽掉第0到第30位，只留下EBX寄存器中第31位的符号值。这一过程没有将符号位移到第0位（通常在解包数据时需要这么做），因为在后续重新打包浮点值时，这个位会重新被移动回第31位。
- en: 'To process the exponent, `fpmul()` isolates bits 23 through 30 and operates
    on the exponent in place. When multiplying two values using scientific notation,
    you must add the values of the exponents together. However, you must subtract
    127 from the exponent’s sum, since adding excess-127 exponents ends up adding
    the bias twice. The following code isolates the exponent bits, adjusts for the
    extra bias, and adds the exponents together:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理指数，`fpmul()`会隔离第23到第30位，并在原地操作指数。在使用科学计数法进行两个值的乘法时，你必须将指数值相加。然而，你必须从指数和中减去127，因为添加超出127的指数会导致偏差被加两次。以下代码隔离指数位，调整额外的偏差，并将指数相加：
- en: '[PRE24]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First, notice that this code subtracts 126 rather than 127\. The reason is that
    later we’ll need to double the result of the multiplication of the mantissas.
    Subtracting 126 rather than 127 does this multiplication by 2 implicitly (saving
    an instruction later on).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意这段代码减去的是126而不是127。原因是稍后我们需要将尾数相乘的结果乘以2。减去126而不是127，隐式地完成了乘2的操作（这样可以节省后续的一条指令）。
- en: If the sum of the exponents with `add(eax, ecx)` in the preceding code is too
    large to fit into 8 bits, there will be a carry out of bit 30 into bit 31 of ECX,
    which will set the 80x86 overflow flag. If overflow occurs on a multiplication,
    our code will return `infinity` as the result.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面代码中使用`add(eax, ecx)`的指数和过大，无法容纳在8位中，就会导致从ECX的第30位向第31位发生进位，这会设置80x86溢出标志。如果乘法发生溢出，我们的代码将返回`infinity`作为结果。
- en: If overflow does not occur, then the `fpmul()` procedure needs to set the implied
    HO bit of the two mantissa values. The following code handles this chore, strips
    out all the exponent and sign bits from the mantissas, and left-justifies the
    mantissa bits up against bit position 31 in EAX and EDX.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有发生溢出，那么`fpmul()`过程需要设置两个尾数值的隐式高位。以下代码处理这项工作，去除尾数中的所有指数和符号位，并将尾数位左对齐至EAX和EDX的第31位。
- en: '[PRE25]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once the mantissas are shifted to bit 31 in EAX and EDX, we multiply using
    the 80x86 `mul()` instruction:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦尾数被移到EAX和EDX的第31位，我们就使用80x86的`mul()`指令进行乘法：
- en: '[PRE26]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This instruction computes the 64-bit product of EAX and EDX, leaving the result
    in EDX:EAX (the HO double word is in EDX, and the LO double word is in EAX). Because
    the product of any two *n*-bit integers could require as many as 2×*n* bits, the
    `mul()` instruction computes EDX:EAX = EAX×EDX. Left-justifying the mantissas
    in EAX and EDX before doing the multiplication ensures the mantissa of the product
    winds up in bits 7 through 30 of EDX. We actually need them in bit positions 8
    through 31 of EDX—that’s why earlier this code subtracted only 126, rather than
    127, when adjusting for the excess-127 value (this multiplies the result by 2,
    which is equivalent to shifting the bits left one position). As these numbers
    were normalized prior to the multiplication, bit 30 of EDX will contain a `1`
    after the multiplication unless the result is `0`. The 32-bit IEEE real format
    does not support denormalized values, so we don’t have to worry about this case
    when using 32-bit floating-point values.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令计算EAX和EDX的64位乘积，并将结果存储在EDX:EAX中（高双字在EDX中，低双字在EAX中）。由于任意两个*n*位整数的乘积可能需要最多2×*n*位，因此`mul()`指令计算EDX:EAX
    = EAX×EDX。在进行乘法之前将尾数左对齐确保了乘积的尾数会出现在EDX的第7到第30位。我们实际上需要它们出现在EDX的第8到第31位——这就是为什么前面这段代码在调整超出127的值时，减去的是126而不是127（这样乘法结果会乘2，相当于将位移左移一个位置）。由于这些数字在乘法前已经规范化，所以除非结果为`0`，否则EDX的第30位在乘法后会包含`1`。32位IEEE浮点格式不支持非规范化值，因此在使用32位浮点数时，我们不需要担心这种情况。
- en: 'Because the mantissas are 24 bits each, the product of the mantissas could
    have as many as 48 significant bits. Our result mantissa can hold only 24 bits,
    so we need to round the value to produce a 24-bit result (using the IEEE rounding
    algorithm — see “Rounding” on [page 71](#page_71)). Here’s the code that rounds
    the value in EDX to 24 significant bits (in positions 8..31):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因为尾数每个都是24位，尾数的乘积可能有多达48位的有效位数。我们的结果尾数只能容纳24位，因此需要对值进行舍入以产生24位的结果（使用 IEEE 舍入算法
    — 参见“Rounding” 页面71）。以下是将 EDX 中的值舍入为24位有效位数（位于位置8..31）的代码：
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The number may need to be renormalized after rounding. If the mantissa contains
    all `1` bits and needs to be rounded up, this will produce an overflow out of
    the HO bit of the mantissa. The `rcr()` and `inc()` instructions at the end of
    this code sequence put the overflow bit back into the mantissa if overflow occurs.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在舍入后可能需要重新规范化数字。如果尾数包含所有的 `1` 位并且需要向上舍入，则会导致尾数的 HO 位溢出。此代码序列末尾的 `rcr()` 和 `inc()`
    指令将溢出位放回尾数中（如果发生溢出）。
- en: 'The only thing left to do after this is pack the destination sign, exponent,
    and mantissa into the 32-bit EAX register. The following code does this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后要做的唯一事情是将目标符号、指数和尾数打包到32位的 EAX 寄存器中。以下代码实现了这一点：
- en: '[PRE28]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The only tricky thing in this code is the use of the `lea()` (load effective
    address) instruction to compute the sum of EDX (the mantissa) and ECX (the exponent)
    and move the result to EAX all with a single instruction.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码中唯一棘手的部分是使用 `lea()`（加载有效地址）指令来计算 EDX（尾数）和 ECX（指数）的和，并将结果移动到 EAX 中，所有这些只需一条指令。
- en: '**4.7.3.2 Floating-Point Division**'
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**4.7.3.2 浮点除法**'
- en: Floating-point division is a little bit more involved than multiplication because
    the IEEE floating-point standard says many things about degenerate conditions
    that can occur during division. We’re not going to discuss all the code that handles
    those conditions here. Instead, see the discussion of the conditions for `fpmul()`
    earlier, and check out the complete code listing for `fdiv()` later in this section.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点除法比乘法复杂一些，因为 IEEE 浮点标准在除法过程中可能发生多种退化条件。我们不打算在此处讨论处理这些条件的所有代码。相反，请参阅前面关于 `fpmul()`
    条件的讨论，并查看本节后面关于 `fdiv()` 的完整代码清单。
- en: 'Assuming we have reasonable numbers to divide, the division algorithm first
    computes the result sign using the same algorithm (and code) as for multiplying.
    When dividing two values using scientific notation, we have to subtract their
    exponents. In contrast to the multiplication algorithm, here it’s more convenient
    to truly unpack the exponents for the two division operands and convert them from
    excess-127 to two’s complement form. Here’s the code that does this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有合理的数字进行除法，除法算法首先使用与乘法相同的算法（和代码）计算结果符号。在使用科学记数法除法两个值时，我们必须减去它们的指数。与乘法算法相反，在这里真正拆开两个除法操作数的指数并将它们从
    excess-127 转换为二进制补码形式更为方便。以下是执行此操作的代码：
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The 80x86 `div()` instruction absolutely, positively requires the quotient
    to fit into 32 bits. If this condition is not true, the CPU may abort the operation
    with a divide exception. As long as the HO bit of the divisor contains a `1` and
    the HO 2 bits of the dividend contain `%01`, we won’t get a division error. Here’s
    the code that prepares the operands prior to the division operation:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 的 `div()` 指令绝对要求商适合32位。如果此条件不成立，则 CPU 可能会因为除法异常而中止操作。只要除数的 HO 位包含 `1`，被除数的
    HO 2 位包含 `%01`，我们就不会得到除法错误。以下是准备除法操作前操作数的代码：
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The next step is to actually do the division. As noted earlier, in order to
    prevent a division error, we have to shift the dividend 1 bit to the right (to
    set the HO 2 bits to `%01`), as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤是实际执行除法。正如前面提到的，为了防止除法错误，我们必须将被除数向右移动1位（将 HO 2 位设置为 `%01`），具体如下：
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once the `div()` instruction executes, the quotient is sitting in the HO 24
    bits of EAX, and the remainder is in AL:EDX. We now need to normalize and round
    the result. Rounding is a little easier because AL:EDX contains the remainder
    after the division; if we need to round down, it will contain a value less than
    `$80:0000_0000` (that is, the 80x86 AL register contains `$80` and EDX contains
    `0`); if we need to round up, it will contain a value greater than `$80:0000_`;
    and if we need to round to the nearest value, it will contain exactly `$80:0000_0000`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`div()`指令执行完毕，商就会存储在EAX的高24位中，余数则存储在AL:EDX中。接下来，我们需要对结果进行标准化和四舍五入。四舍五入会稍微简单一些，因为AL:EDX包含了除法后的余数；如果我们需要向下取整，它会包含一个小于`$80:0000_0000`的值（即80x86的AL寄存器包含`$80`，而EDX包含`0`）；如果我们需要向上取整，它会包含一个大于`$80:0000_`的值；如果我们需要四舍五入到最接近的值，它将包含恰好`$80:0000_0000`。
- en: 'Here’s the code that does this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是执行此操作的代码：
- en: '[PRE32]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The last step in `fpdiv` is to add the bias back into the exponent (and verify
    that overflow doesn’t occur) and then pack the quotient’s sign, exponent, and
    mantissa fields into the 32-bit floating-point format. Here’s the code that does
    this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`fpdiv`的最后一步是将偏置值加回到指数中（并验证不会发生溢出），然后将商的符号、指数和尾数字段打包成32位浮点格式。以下是执行此操作的代码：'
- en: '[PRE33]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Whew! This has been a lot of code. However, going through all of it just to
    see how floating-point operations work has hopefully given you an appreciation
    of exactly what an FPU does for you.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这一部分代码真不少。然而，阅读所有这些代码只是为了理解浮点运算的工作原理，希望它能让你更好地理解FPU到底为你做了什么。
- en: '**4.8 For More Information**'
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**4.8 获取更多信息**'
- en: 'Hyde, Randall. *The Art of Assembly Language*. 2nd ed. San Francisco: No Starch
    Press, 2010.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 'Hyde, Randall. *《汇编语言的艺术》* 第二版. 旧金山: No Starch Press, 2010年。'
- en: '———. “Webster: The Place on the Internet to Learn Assembly.” *[http://plantation-productions.com/Webster/index.html](http://plantation-productions.com/Webster/index.html)*.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '———. “Webster: 学习汇编的互联网平台。” *[http://plantation-productions.com/Webster/index.html](http://plantation-productions.com/Webster/index.html)*。'
- en: 'Knuth, Donald E. *The Art of Computer Programming, Volume 2: Seminumerical
    Algorithms*. 3rd ed. Boston: Addison-Wesley, 1998.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 'Knuth, Donald E. *《计算机程序设计艺术》第2卷：半数值算法* 第3版. 波士顿: Addison-Wesley, 1998年。'
