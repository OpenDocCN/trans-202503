- en: Chapter 10. Time
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章 时间
- en: 'Within a program, we may be interested in two kinds of time:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个程序中，我们可能对两种类型的时间感兴趣：
- en: '*Real time*: This is the time as measured either from some standard point (*calendar*
    time) or from some fixed point (typically the start) in the life of a process
    (*elapsed* or *wall clock* time). Obtaining the calendar time is useful to programs
    that, for example, timestamp database records or files. Measuring elapsed time
    is useful for a program that takes periodic actions or makes regular measurements
    from some external input device.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实时时间*：这是从某个标准时间点（*日历*时间）或某个固定时间点（通常是进程开始时刻）测量的时间（通常是*经过的*或*墙钟*时间）。获取日历时间对于需要例如给数据库记录或文件加上时间戳的程序非常有用。测量经过的时间对于那些定期执行操作或从外部输入设备获取定期数据的程序也非常有用。'
- en: '*Process time*: This is the amount of CPU time used by a process. Measuring
    process time is useful for checking or optimizing the performance of a program
    or algorithm.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*进程时间*：这是一个进程使用的CPU时间量。测量进程时间对于检查或优化程序或算法的性能非常有用。'
- en: Most computer architectures have a built-in hardware clock that enables the
    kernel to measure real and process time. In this chapter, we look at system calls
    for dealing with both sorts of time, and library functions for converting between
    human-readable and internal representations of time. Since human-readable representations
    of time are dependent on the geographical location and on linguistic and cultural
    conventions, discussion of these representations leads us into an investigation
    of timezones and locales.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算机架构都有一个内建的硬件时钟，使得内核能够测量实时时间和进程时间。在本章中，我们将研究处理这两种时间的系统调用，以及在可读时间和内部时间表示之间进行转换的库函数。由于人类可读的时间表示依赖于地理位置以及语言和文化习惯，因此讨论这些表示方式会引导我们进一步探讨时区和区域设置。
- en: Calendar Time
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日历时间
- en: Regardless of geographic location, UNIX systems represent time internally as
    a measure of seconds since the Epoch; that is, since midnight on the morning of
    1 January 1970, Universal Coordinated Time (UTC, previously known as Greenwich
    Mean Time, or GMT). This is approximately the date when the UNIX system came into
    being. Calendar time is stored in variables of type *time_t*, an integer type
    specified by SUSv3.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 不论地理位置如何，UNIX系统都将时间内部表示为自纪元以来的秒数；也就是说，从1970年1月1日午夜起的协调世界时（UTC，之前称为格林威治标准时间，或GMT）。这大约是UNIX系统诞生的日期。日历时间存储在类型为*time_t*的变量中，这是SUSv3定义的一个整数类型。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On 32-bit Linux systems, *time_t*, which is a signed integer, can represent
    dates in the range 13 December 1901 20:45:52 to 19 January 2038 03:14:07\. (SUSv3
    leaves the meaning of negative *time_t* values unspecified.) Thus, many current
    32-bit UNIX systems face a theoretical *Year 2038* problem, which they may encounter
    before 2038, if they do calculations based on dates in the future. This problem
    will be significantly alleviated by the fact that by 2038, probably all UNIX systems
    will have long become 64-bit and beyond. However, 32-bit embedded systems, which
    typically have a much longer lifespan than desktop hardware, may still be afflicted
    by the problem. Furthermore, the problem will remain for any legacy data and applications
    that maintain time in a 32-bit *time_t* format.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在32位Linux系统上，*time_t*（一个有符号整数）可以表示从1901年12月13日20:45:52到2038年1月19日03:14:07的日期范围。（SUSv3没有指定负*time_t*值的含义。）因此，许多当前的32位UNIX系统面临着理论上的*2038年问题*，如果它们基于未来的日期进行计算，可能会在2038年之前就遇到此问题。这个问题到2038年可能会得到显著缓解，因为到那时，几乎所有UNIX系统都会转为64位及更高位。然而，32位嵌入式系统通常比桌面硬件有更长的生命周期，因此仍可能遭遇这个问题。此外，任何以32位*time_t*格式保存时间的旧数据和应用程序，也将持续受到此问题的影响。
- en: The *gettimeofday()* system call returns the calendar time in the buffer pointed
    to by *tv*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*gettimeofday()* 系统调用将日历时间返回到由*tv*指针指向的缓冲区。'
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: 'The *tv* argument is a pointer to a structure of the following form:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*tv* 参数是指向以下结构的指针：'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Although the *tv_usec* field affords microsecond precision, the accuracy of
    the value it returns is determined by the architecture-dependent implementation.
    (The *u* in *tv_usec* derives from the resemblance to the Greek letter µ (“mu”)
    used in the metric system to denote one-millionth.) On modern x86-32 systems (i.e.,
    Pentium systems with a Timestamp Counter register that is incremented once at
    each CPU clock cycle), *gettimeofday()* does provide microsecond accuracy.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*tv_usec*字段提供微秒级精度，但它返回的值的准确性由依赖于架构的实现决定。(*tv_usec*中的*u*源自希腊字母µ（“mu”），该字母在公制系统中表示百万分之一。)
    在现代x86-32系统（即带有时间戳计数器寄存器的Pentium系统，该寄存器在每个CPU时钟周期时递增一次）上，*gettimeofday()*确实提供微秒级精度。
- en: The *tz* argument to *gettimeofday()* is a historical artifact. In older UNIX
    implementations, it was used to retrieve timezone information for the system.
    This argument is now obsolete and should always be specified as `NULL`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*gettimeofday()*的*tz*参数是一个历史遗留问题。在早期的UNIX实现中，使用它来检索系统的时区信息。现在该参数已废弃，应始终指定为`NULL`。'
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If the *tz* argument is supplied, then it returns a *timezone* structure whose
    fields contain whatever values were specified in the (obsolete) *tz* argument
    in a previous call to *settimeofday()*. This structure contains two fields: *tz_minuteswest*
    and *tz_dsttime*. The *tz_minuteswest* field indicates the number of minutes that
    must be added to times in this zone to match UTC, with a negative value indicating
    that an adjustment of minutes to the east of UTC (e.g., for Central European Time,
    one hour ahead of UTC, this field would contain the value -60). The *tz_dsttime*
    field contains a constant that was designed to represent the daylight saving time
    (DST) regime in force in this timezone. It is because the DST regime can’t be
    represented using a simple algorithm that the *tz* argument is obsolete. (This
    field has never been supported on Linux.) See the *gettimeofday(2)* manual page
    for further details.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了*tz*参数，则返回一个*timezone*结构，其字段包含在之前调用*settimeofday()*时指定的（已废弃）*tz*参数的值。该结构包含两个字段：*tz_minuteswest*和*tz_dsttime*。*tz_minuteswest*字段表示必须加到此时区的时间中的分钟数，以匹配UTC，负值表示需要调整为UTC东部的分钟数（例如，对于中欧时间，比UTC快一个小时，该字段的值为-60）。*tz_dsttime*字段包含一个常量，用于表示此时区内施行的夏令时（DST）制度。由于夏令时制度无法通过简单的算法表示，因此*tz*参数已经废弃。（该字段在Linux上从未被支持。）有关更多详情，请参见*gettimeofday(2)*手册页。
- en: The *time()* system call returns the number of seconds since the Epoch (i.e.,
    the same value that *gettimeofday()* returns in the *tv_sec* field of its *tv*
    argument).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*time()*系统调用返回自Epoch以来的秒数（即与*gettimeofday()*在其*tv*参数的*tv_sec*字段中返回的值相同）。'
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of seconds since the Epoch, or *(time_t)* -1 on error
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 返回自Epoch以来的秒数，或在出错时返回*(time_t)* -1。
- en: If the *timep* argument is not `NULL`, the number of seconds since the Epoch
    is also placed in the location to which *timep* points.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*timep*参数不为`NULL`，则自Epoch以来的秒数也将被存储在*timep*指向的位置。
- en: 'Since *time()* returns the same value in two ways, and the only possible error
    that can occur when using *time()* is to give an invalid address in the *timep*
    argument (`EFAULT`), we often simply use the following call (without error checking):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*time()*以两种方式返回相同的值，并且使用*time()*时唯一可能发生的错误是给出无效的地址作为*timep*参数（`EFAULT`），我们通常仅使用以下调用（不进行错误检查）：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The reason for the existence of two system calls (*time()* and *gettimeofday()*)
    with essentially the same purpose is historical. Early UNIX implementations provided
    *time()*. 4.2BSD added the more precise *gettimeofday()* system call. The existence
    of *time()* as a system call is now redundant; it could be implemented as a library
    function that calls *gettimeofday()*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两个系统调用（*time()*和*gettimeofday()*），它们本质上具有相同的目的，这一事实源于历史。早期的UNIX实现提供了*time()*。4.2BSD增加了更精确的*gettimeofday()*系统调用。*time()*作为系统调用的存在现在是多余的；它可以作为一个库函数来实现，该函数调用*gettimeofday()*。
- en: Time-Conversion Functions
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间转换函数
- en: '[Figure 10-1](ch10.html#functions_for_retrieving_and_working_wit "Figure 10-1. Functions
    for retrieving and working with calendar time") shows the functions used to convert
    between *time_t* values and other time formats, including printable representations.
    These functions shield us from the complexity brought to such conversions by timezones,
    daylight saving time (DST) regimes, and localization issues. (We describe timezones
    in [Timezones](ch10.html#timezones "Timezones") and locales in Section 10.4.)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-1](ch10.html#functions_for_retrieving_and_working_wit "图 10-1. 用于获取和处理日历时间的函数")
    显示了用于在 *time_t* 值和其他时间格式（包括可打印表示）之间转换的函数。这些函数将我们从时区、夏令时（DST）制度和本地化问题带来的复杂性中解救出来。（我们在
    [时区](ch10.html#timezones "时区") 和本地化设置在第 10.4 节中描述了时区。）'
- en: '![Functions for retrieving and working with calendar time](figs/web/10-1_TIME_DATE-functions-scale90.png.jpg)Figure 10-1. Functions
    for retrieving and working with calendar time'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![用于获取和处理日历时间的函数](figs/web/10-1_TIME_DATE-functions-scale90.png.jpg)图 10-1.
    用于获取和处理日历时间的函数'
- en: Converting *time_t* to Printable Form
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 *time_t* 转换为可打印格式
- en: The *ctime()* function provides a simple method of converting a *time_t* value
    into printable form.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*ctime()* 函数提供了一种将 *time_t* 值转换为可打印格式的简单方法。'
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to statically allocated string terminated by newline and `\0`
    on success, or `NULL` on error
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回指向静态分配字符串的指针，该字符串以换行符和 `\0` 结束，出错时返回 `NULL`
- en: 'Given a pointer to a *time_t* value in *timep*, *ctime()* returns a 26-byte
    string containing the date and time in a standard format, as illustrated by the
    following example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个指向 *time_t* 值的指针 *timep*，*ctime()* 返回一个 26 字节的字符串，包含日期和时间，格式为标准格式，如以下示例所示：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The string includes a terminating newline character and a terminating null byte.
    The *ctime()* function automatically accounts for local timezone and DST settings
    when performing the conversion. (We explain how these settings are determined
    in Section 10.3.) The returned string is statically allocated; future calls to
    *ctime()* will overwrite it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串包括一个终止的换行符和一个终止的空字节。*ctime()* 函数在执行转换时会自动考虑本地时区和夏令时设置。（我们将在第 10.3 节解释这些设置是如何确定的。）返回的字符串是静态分配的；将来的
    *ctime()* 调用会覆盖它。
- en: SUSv3 states that calls to any of the functions *ctime()*, *gmtime()*, *localtime()*,
    or *asctime()* may overwrite the statically allocated structure that is returned
    by any of the other functions. In other words, these functions may share single
    copies of the returned character array and *tm* structure, and this is done in
    some versions of *glibc*. If we need to maintain the returned information across
    multiple calls to these functions, we must save local copies.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 规定，调用任何 *ctime()*、*gmtime()*、*localtime()* 或 *asctime()* 函数时，可能会覆盖由其他函数返回的静态分配结构。换句话说，这些函数可能共享返回的字符数组和
    *tm* 结构的单一副本，而在某些版本的 *glibc* 中正是这样实现的。如果我们需要在多次调用这些函数时保持返回的信息，必须保存本地副本。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A reentrant version of *ctime()* is provided in the form of *ctime_r()*. (We
    explain reentrancy in [Reentrant and Async-Signal-Safe Functions](ch21.html#reentrant_and_async-signal-safe_function
    "Reentrant and Async-Signal-Safe Functions").) This function permits the caller
    to specify an additional argument that is a pointer to a (caller-supplied) buffer
    that is used to return the time string. Other reentrant versions of functions
    mentioned in this chapter operate similarly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*ctime()* 的重入版本以 *ctime_r()* 形式提供。（我们在 [重入函数和异步信号安全函数](ch21.html#reentrant_and_async-signal-safe_function
    "重入函数和异步信号安全函数") 中解释了重入性。）此函数允许调用者指定一个额外的参数，它是一个指向（调用者提供的）缓冲区的指针，用于返回时间字符串。本章中提到的其他重入版本的函数也有类似的操作。'
- en: Converting Between *time_t* and Broken-Down Time
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 *time_t* 和分解时间之间转换
- en: The *gmtime()* and *localtime()* functions convert a *time_t* value into a so-called
    *broken-down time*. The broken-down time is placed in a statically allocated structure
    whose address is returned as the function result.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*gmtime()* 和 *localtime()* 函数将 *time_t* 值转换为所谓的 *分解时间*。分解时间被存放在一个静态分配的结构中，该结构的地址作为函数的返回值。'
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return a pointer to a statically allocated broken-down time structure on
    success, or `NULL` on error
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 两者成功时返回指向静态分配的分解时间结构的指针，出错时返回 `NULL`
- en: The *gmtime()* function converts a calendar time into a broken-down time corresponding
    to UTC. (The letters *gm* derive from Greenwich Mean Time.) By contrast, *localtime()*
    takes into account timezone and DST settings to return a broken-down time corresponding
    to the system’s local time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*gmtime()*函数将日历时间转换为与UTC对应的拆分时间。（*gm*字母源自格林威治标准时间。）相比之下，*localtime()*考虑了时区和夏令时设置，返回与系统本地时间对应的拆分时间。'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Reentrant versions of these functions are provided as *gmtime_r()* and *localtime_r()*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的可重入版本分别为*gmtime_r()*和*localtime_r()*。
- en: 'The *tm* structure returned by these functions contains the date and time fields
    broken into individual parts. This structure has the following form:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数返回的*tm*结构包含将日期和时间字段拆分为单独部分的内容。该结构具有以下形式：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The *tm_sec* field can be up to 60 (rather than 59) to account for the leap
    seconds that are occasionally applied to adjust human calendars to the astronomically
    exact (the so-called *tropical*) year.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*tm_sec*字段可以最大为60（而不是59），以考虑偶尔对人类日历进行调整的闰秒，使其与天文学上精确的（即所谓的*热带*）年保持一致。'
- en: If the `_BSD_SOURCE` feature test macro is defined, then the *glibc* definition
    of the *tm* structure also includes two additional fields containing further information
    about the represented time. The first of these, *long int tm_gmtoff*, contains
    the number of seconds that the represented time falls east of UTC. The second
    field, *const char *tm_zone*, is the abbreviated timezone name (e.g., *CEST* for
    Central European Summer Time). SUSv3 doesn’t specify either of these fields, and
    they appear on only a few other UNIX implementations (mainly BSD derivatives).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了`_BSD_SOURCE`特性测试宏，则*glibc*对*tm*结构的定义还包括两个额外的字段，包含有关表示时间的进一步信息。第一个字段，*long
    int tm_gmtoff*，包含表示时间距离UTC的秒数。第二个字段，*const char *tm_zone*，是时区的缩写名称（例如，*CEST*表示中欧夏令时）。SUSv3没有指定这两个字段，它们只出现在一些其他UNIX实现中（主要是BSD衍生版本）。
- en: The *mktime()* function translates a broken-down time, expressed as local time,
    into a *time_t* value, which is returned as the function result. The caller supplies
    the broken-down time in a *tm* structure pointed to by *timeptr*. During this
    translation, the *tm_wday* and *tm_yday* fields of the input *tm* structure are
    ignored.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*mktime()*函数将一个拆分的时间（表示为本地时间）转换为一个*time_t*值，该值作为函数的返回结果。调用者提供指向拆分时间的*tm*结构，该结构由*timeptr*指向。在此转换过程中，输入的*tm*结构的*tm_wday*和*tm_yday*字段会被忽略。'
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns seconds since the Epoch corresponding to *timeptr* on success, or *(time_t)*
    -1 on error
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回自Epoch以来的秒数，失败时返回*(time_t)* -1
- en: The *mktime()* function may modify the structure pointed to by *timeptr*. At
    a minimum, it ensures that the *tm_wday* and *tm_yday* fields are set to values
    that correspond appropriately to the values of the other input fields.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*mktime()*函数可能会修改由*timeptr*指向的结构。至少，它会确保*tm_wday*和*tm_yday*字段被设置为与其他输入字段的值相对应的合适值。'
- en: In addition, *mktime()* doesn’t require the other fields of the *tm* structure
    to be restricted to the ranges described earlier. For each field whose value is
    out of range, *mktime()* adjusts that field’s value so that it is in range and
    makes suitable adjustments to the other fields. All of these adjustments are performed
    before *mktime()* updates the *tm_wday* and *tm_yday* fields and calculates the
    returned *time_t* value.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，*mktime()*不要求其他字段的*tm*结构限制在先前描述的范围内。对于任何超出范围的字段，*mktime()*会调整该字段的值，使其落入有效范围，并对其他字段进行适当的调整。这些调整会在*mktime()*更新*tm_wday*和*tm_yday*字段并计算返回的*time_t*值之前进行。
- en: For example, if the input *tm_sec* field were 123, then on return, the value
    of this field would be 3, and the value of the *tm_min* field would have 2 added
    to whatever value it previously had. (And if that addition caused *tm_min* to
    overflow, then the *tm_min* value would be adjusted and the *tm_hour* field would
    be incremented, and so on.) These adjustments even apply for negative field values.
    For example, specifying -1 for *tm_sec* means the 59th second of the previous
    minute. This feature is useful since it allows us to perform date and time arithmetic
    on a broken-down time value.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果输入的*tm_sec*字段为123，则返回时，该字段的值将为3，*tm_min*字段的值将在原有基础上加2。（如果这个加法导致*tm_min*溢出，则*tm_min*值会被调整，*tm_hour*字段会递增，以此类推。）这些调整甚至适用于负值字段。例如，指定*tm_sec*为-1意味着前一分钟的第59秒。这个功能非常有用，因为它允许我们对拆分的时间值进行日期和时间运算。
- en: 'The timezone setting is used by *mktime()* when performing the translation.
    In addition, the DST setting may or may not be used, depending on the value of
    the input *tm_isdst* field:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 时区设置由 *mktime()* 在进行转换时使用。此外，夏令时设置可能会被使用，也可能不会，取决于输入的 *tm_isdst* 字段的值：
- en: If *tm_isdst* is 0, treat this time as standard time (i.e., ignore DST, even
    if it would be in effect at this time of year).
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *tm_isdst* 为 0，则将此时间视为标准时间（即忽略夏令时，即使在此时段夏令时本应生效）。
- en: If *tm_isdst* is greater than 0, treat this time as DST (i.e., behave as though
    DST is in effect, even if it would not normally be so at this time of year).
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *tm_isdst* 大于 0，则将此时间视为夏令时（即使在此时段夏令时本应不生效，也要按夏令时处理）。
- en: If *tm_isdst* is less than 0, attempt to determine if DST would be in effect
    at this time of the year. This is typically the setting we want.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *tm_isdst* 小于 0，则尝试确定此时段是否会生效夏令时。这通常是我们希望的设置。
- en: On completion (and regardless of the initial setting of *tm_isdst*), *mktime()*
    sets the *tm_isdst* field to a positive value if DST is in effect at the given
    date, or to 0 if DST is not in effect.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后（无论 *tm_isdst* 的初始设置如何），*mktime()* 会将 *tm_isdst* 字段设置为正值，表示在给定日期生效了夏令时；如果没有生效，则设置为
    0。
- en: Converting Between Broken-Down Time and Printable Form
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从分解时间到可打印形式的转换
- en: In this section, we describe functions that convert a broken-down time to printable
    form, and vice versa.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了将分解时间转换为可打印形式的函数，以及反向转换的函数。
- en: Converting from broken-down time to printable form
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从分解时间到可打印形式的转换
- en: Given a pointer to a broken-down time structure in the argument *tm*, *asctime()*
    returns a pointer to a statically allocated string containing the time in the
    same form as *ctime()*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个指向分解时间结构的指针 *tm*，*asctime()* 返回一个指向静态分配的字符串的指针，该字符串包含与 *ctime()* 相同格式的时间。
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to statically allocated string terminated by newline and `\0`
    on success, or `NULL` on error
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回指向以换行符和 `\0` 终止的静态分配字符串的指针，出错时返回 `NULL`。
- en: By contrast with *ctime()*, local timezone settings have no effect on *asctime()*,
    since it is converting a broken-down time that is typically either already localized
    via *localtime()* or in UTC as returned by *gmtime()*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *ctime()* 相比，*asctime()* 不受本地时区设置的影响，因为它转换的是一个通常已通过 *localtime()* 本地化，或者是
    *gmtime()* 返回的 UTC 时间的分解时间。
- en: As with *ctime()*, we have no control over the format of the string produced
    by *asctime()*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *ctime()* 类似，我们无法控制 *asctime()* 输出字符串的格式。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A reentrant version of *asctime()* is provided in the form of *asctime_r()*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了 *asctime()* 的可重入版本 *asctime_r()*。
- en: '[Example 10-1](ch10.html#retrieving_and_converting_calendar_times "Example 10-1. Retrieving
    and converting calendar times") demonstrates the use of *asctime()*, as well as
    all of the time-conversion functions described so far in this chapter. This program
    retrieves the current calendar time, and then uses various time-conversion functions
    and displays their results. Here is an example of what we see when running this
    program in Munich, Germany, which (in winter) is on Central European Time, one
    hour ahead of UTC:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-1](ch10.html#retrieving_and_converting_calendar_times "示例 10-1. 获取和转换日历时间")
    演示了 *asctime()* 的使用，以及本章迄今为止描述的所有时间转换函数。该程序检索当前的日历时间，然后使用各种时间转换函数并显示其结果。以下是我们在德国慕尼黑运行该程序时看到的示例（冬季时，慕尼黑处于中欧时间，比
    UTC 快一小时）：'
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Example 10-1. Retrieving and converting calendar times
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-1. 获取和转换日历时间
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The *strftime()* function provides us with more precise control when converting
    a broken-down time into printable form. Given a broken-down time pointed to by
    *timeptr*, *strftime()* places a corresponding null-terminated, date-plus-time
    string in the buffer pointed to by *outstr*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*strftime()* 函数在将分解时间转换为可打印形式时，提供了更精确的控制。给定一个指向分解时间的指针 *timeptr*，*strftime()*
    会将相应的以空字符终止的日期加时间字符串放入 *outstr* 指向的缓冲区中。'
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of bytes placed in *outstr* (excluding terminating null byte)
    on success, or 0 on error
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回放入 *outstr* 中的字节数（不包括终止的空字节），出错时返回 0。
- en: The string returned in *outstr* is formatted according to the specification
    in *format*. The *maxsize* argument specifies the maximum space available in *outstr*.
    Unlike *ctime()* and *asctime()*, *strftime()* doesn’t include a newline character
    at the end of the string (unless one is included in *format*).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的字符串 *outstr* 会根据 *format* 中的规范进行格式化。*maxsize* 参数指定 *outstr* 中可用的最大空间。与 *ctime()*
    和 *asctime()* 不同，*strftime()* 不会在字符串末尾添加换行符（除非 *format* 中包含换行符）。
- en: On success, *strftime()* returns the number of bytes placed in *outstr*, excluding
    the terminating null byte. If the total length of the resulting string, including
    the terminating null byte, would exceed *maxsize* bytes, then *strftime()* returns
    0 to indicate an error, and the contents of *outstr* are indeterminate.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时，*strftime()* 返回存入 *outstr* 中的字节数，不包括终止的空字节。如果结果字符串的总长度（包括终止的空字节）超过了 *maxsize*
    字节，则 *strftime()* 返回0表示出错，并且 *outstr* 的内容是不确定的。
- en: The *format* argument to *strftime()* is a string akin to that given to *printf()*.
    Sequences beginning with a percent character (`%`) are conversion specifications,
    which are replaced by various components of the date and time according to the
    specifier character following the percent character. A rich set of conversion
    specifiers is provided, a subset of which is listed in [Table 10-1](ch10.html#selected_conversion_specifiers_for_strft
    "Table 10-1. Selected conversion specifiers for strftime()"). (For a complete
    list, see the *strftime(3)* manual page.) Except as otherwise noted, all of these
    conversion specifiers are standardized in SUSv3.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*strftime()* 的 *format* 参数是一个类似于给 *printf()* 的字符串。以百分号（`%`）开头的序列是转换说明符，会根据其后的说明符字符替换为日期和时间的各个组成部分。提供了丰富的转换说明符，其中的一部分列在
    [表10-1](ch10.html#selected_conversion_specifiers_for_strft "表10-1. *strftime()*
    的选择性转换说明符") 中。（完整列表请参见 *strftime(3)* 手册页。）除非另有说明，所有这些转换说明符都是在 SUSv3 中标准化的。'
- en: The `%U` and `%W` specifiers both produce a week number in the year. The `%U`
    week numbers are calculated such that the first week containing a Sunday is numbered
    1, and the partial week preceding that is numbered 0\. If Sunday happens to fall
    as the first day of the year, then there is no week 0, and the last day of the
    year falls in week 53\. The `%W` week numbers work in the same way, but with Monday
    rather than Sunday.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`%U` 和 `%W` 说明符都表示年份中的周数。`%U` 的周数是这样计算的：包含一个星期天的第一周被编号为1，之前的部分周被编号为0。如果星期天恰好是年份的第一天，那么就没有第0周，且年份的最后一天会落在第53周。'
- en: Often, we want to display the current time in various demonstration programs
    in this book. For this purpose we provide the function *currTime()*, which returns
    a string containing the current time as formatted by *strftime()* when given the
    argument *format*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望在本书的各种示范程序中显示当前时间。为此，我们提供了函数 *currTime()*，当传入 *format* 参数时，它返回一个包含当前时间的字符串，该字符串格式化方式由
    *strftime()* 确定。
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to statically allocated string, or `NULL` on error
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向静态分配字符串的指针，出错时返回`NULL`
- en: The *currTime()* function implementation is shown in [Example 10-2](ch10.html#a_function_that_returns_a_string_contain
    "Example 10-2. A function that returns a string containing the current time").
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*currTime()* 函数的实现见 [示例 10-2](ch10.html#a_function_that_returns_a_string_contain
    "示例 10-2. 一个返回当前时间字符串的函数")。'
- en: Table 10-1. Selected conversion specifiers for *strftime()*
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 表10-1. *strftime()* 的选择性转换说明符
- en: '| Specifier | Description | Example |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 说明符 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `%%` | A `%` character | `%` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `%%` | 百分号字符 | `%` |'
- en: '| `%a` | Abbreviated weekday name | `Tue` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `%a` | 缩写的星期几名称 | `Tue` |'
- en: '| `%A` | Full weekday name | `Tuesday` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `%A` | 完整的星期几名称 | `Tuesday` |'
- en: '| `%b`, `%h` | Abbreviated month name | `Feb` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `%b`, `%h` | 缩写的月份名称 | `Feb` |'
- en: '| `%B` | Full month name | `February` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `%B` | 完整的月份名称 | `February` |'
- en: '| `%c` | Date and time | `Tue Feb 1 21:39:46 2011` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `%c` | 日期和时间 | `Tue Feb 1 21:39:46 2011` |'
- en: '| `%d` | Day of month (2 digits, 01 to 31) | `01` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `%d` | 月中的哪一天（2位数字，01到31） | `01` |'
- en: '| `%D` | American date (same as `%m/%d/%y`) | `02/01/11` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `%D` | 美国日期（与 `%m/%d/%y` 相同） | `02/01/11` |'
- en: '| `%e` | Day of month (2 characters) | `1` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `%e` | 月中的哪一天（2个字符） | `1` |'
- en: '| `%F` | ISO date (same as `%Y-%m-%d`) | `2011-02-01` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `%F` | ISO 日期（与 `%Y-%m-%d` 相同） | `2011-02-01` |'
- en: '| `%H` | Hour (24-hour clock, 2 digits) | `21` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `%H` | 小时（24小时制，2位数字） | `21` |'
- en: '| `%I` | Hour (12-hour clock, 2 digits) | `09` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `%I` | 小时（12小时制，2位数字） | `09` |'
- en: '| `%j` | Day of year (3 digits, 001 to 366) | `032` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `%j` | 年中的第几天（3位数字，001到366） | `032` |'
- en: '| `%m` | Decimal month (2 digits, 01 to 12) | `02` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `%m` | 十进制月份（2位数字，01到12） | `02` |'
- en: '| `%M` | Minute (2 digits) | `39` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `%M` | 分钟（2位数字） | `39` |'
- en: '| `%p` | AM/PM | `PM` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `%p` | AM/PM | `PM` |'
- en: '| `%P` | am/pm (GNU extension) | `pm` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `%P` | am/pm（GNU扩展） | `pm` |'
- en: '| `%R` | 24-hour time (same as `%H:%M`) | `21:39` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `%R` | 24小时制时间（与 `%H:%M` 相同） | `21:39` |'
- en: '| `%S` | Second (00 to 60) | `46` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `%S` | 秒（00到60） | `46` |'
- en: '| `%T` | Time (same as `%H:%M:%S`) | `21:39:46` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `%T` | 时间（与 `%H:%M:%S` 相同） | `21:39:46` |'
- en: '| `%u` | Weekday number (1 to 7, Monday = 1) | `2` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `%u` | 星期几编号（1 到 7，星期一 = 1） | `2` |'
- en: '| `%U` | Sunday week number (00 to 53) | `05` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `%U` | 星期天所在周数（00 到 53） | `05` |'
- en: '| `%w` | Weekday number (0 to 6, Sunday = 0) | `2` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `%w` | 星期几编号（0 到 6，星期日 = 0） | `2` |'
- en: '| `%W` | Monday week number (00 to 53) | `05` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `%W` | 星期一所在周数（00 到 53） | `05` |'
- en: '| `%x` | Date (localized) | `02/01/11` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `%x` | 日期（本地化） | `02/01/11` |'
- en: '| `%X` | Time (localized) | `21:39:46` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `%X` | 时间（本地化） | `21:39:46` |'
- en: '| `%y` | 2-digit year | `11` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `%y` | 2 位数年份 | `11` |'
- en: '| `%Y` | 4-digit year | `2011` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `%Y` | 4 位数年份 | `2011` |'
- en: '| `%Z` | Timezone name | `CET` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `%Z` | 时区名称 | `CET` |'
- en: Example 10-2. A function that returns a string containing the current time
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-2。返回当前时间的字符串的函数
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Converting from printable form to broken-down time
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从可打印形式转换为分解后的时间
- en: The *strptime()* function is the converse of *strftime()*. It converts a date-plus-time
    string to a broken-down time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*strptime()* 函数是 *strftime()* 的逆操作。它将一个日期和时间字符串转换为分解后的时间。'
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to next unprocessed character in *str* on success, or `NULL`
    on error
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时，返回指向 *str* 中下一个未处理字符的指针，出错时返回`NULL`
- en: The *strptime()* function uses the specification given in *format* to parse
    the date-plus-time string given in *str*, and places the converted broken-down
    time in the structure pointed to by *timeptr*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*strptime()* 函数使用 *format* 中给定的规格来解析 *str* 中的日期和时间字符串，并将转换后的分解时间放入 *timeptr*
    指向的结构中。'
- en: On success, *strptime()* returns a pointer to the next unprocessed character
    in *str*. (This is useful if the string contains further information to be processed
    by the calling program.) If the complete format string could not be matched, *strptime()*
    returns `NULL` to indicate the error.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时，*strptime()* 返回指向 *str* 中下一个未处理字符的指针。（如果字符串包含进一步需要处理的信息供调用程序使用，这一点很有用。）如果无法匹配完整的格式字符串，*strptime()*
    返回 `NULL` 以表示错误。
- en: 'The format specification given to *strptime()* is akin to that given to *scanf(3)*.
    It contains the following types of characters:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 给 *strptime()* 的格式说明符类似于给 *scanf(3)* 的说明符。它包含以下几种类型的字符：
- en: conversion specifications beginning with a percent character (`%`);
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以百分号字符（`%`）开头的转换说明符；
- en: white-space characters, which match zero or more white spaces in the input string;
    and
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空格字符，匹配输入字符串中的零个或多个空格；
- en: non-white-space characters (other than `%`), which must match exactly the same
    characters in the input string.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非空格字符（除了 `%` 之外），这些字符必须与输入字符串中的相应字符完全匹配。
- en: The conversion specifications are similar to those given to *strftime()* ([Table 10-1](ch10.html#selected_conversion_specifiers_for_strft
    "Table 10-1. Selected conversion specifiers for strftime()")). The major difference
    is that the specifiers are more general. For example, both `%a` and `%A` can accept
    a weekday name in either full or abbreviated form, and `%d` or `%e` can be used
    to read a day of the month with or without a leading 0 in the case of single-digit
    days. In addition, case is ignored; for example, *May* and *MAY* are equivalent
    month names. The string `%%` is used to match a percent character in the input
    string. The *strptime(3)* manual page provides more details.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 转换说明符类似于给 *strftime()* 的说明符（[表 10-1](ch10.html#selected_conversion_specifiers_for_strft
    "表 10-1. strftime() 的选定转换说明符")）。主要区别在于这些说明符更为通用。例如，`%a` 和 `%A` 都可以接受全称或简写形式的星期几名称，而
    `%d` 或 `%e` 可以用于读取带有或不带有前导零的单数字日期。此外，大小写被忽略；例如，*May* 和 *MAY* 都是等效的月份名称。字符串 `%%`
    用于匹配输入字符串中的百分号字符。*strptime(3)* 手册页提供了更多细节。
- en: The *glibc* implementation of *strptime()* doesn’t modify those fields of the
    *tm* structure that are not initialized by specifiers in *format*. This means
    that we can employ a series of *strptime()* calls to construct a single *tm* structure
    from information in multiple strings, such as a date string and a time string.
    While SUSv3 permits this behavior, it doesn’t require it, and so we can’t rely
    on it on other UNIX implementations. In a portable application, we must ensure
    that *str* and *format* contain input that will set all fields of the resulting
    *tm* structure, or make sure that the *tm* structure is suitably initialized before
    calling *strptime()*. In most cases, it would be sufficient to zero out the entire
    structure using *memset()*, but be aware that a value of 0 in the *tm_mday* field
    corresponds to the last day of the previous month in *glibc* and many other implementations
    of the time-conversion functions. Finally, note that *strptime()* never sets the
    value of the *tm_isdst* field of the *tm* structure.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*glibc*实现的*strptime()*不会修改*tm*结构中那些未被*format*中的说明符初始化的字段。这意味着我们可以通过一系列*strptime()*调用，将多个字符串中的信息（如日期字符串和时间字符串）构建成一个单一的*tm*结构。虽然SUSv3允许这种行为，但并不要求它，因此我们不能在其他UNIX实现中依赖这种行为。在可移植应用程序中，我们必须确保*str*和*format*包含能设置所有*tm*结构字段的输入，或者在调用*strptime()*之前确保*tm*结构已适当初始化。在大多数情况下，使用*memset()*将整个结构归零就足够了，但要注意，在*glibc*和许多其他时间转换函数的实现中，*tm_mday*字段的值为0表示上个月的最后一天。最后，注意*strptime()*从不设置*tm*结构中*tm_isdst*字段的值。'
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The GNU C library also provides two other functions that serve a similar purpose
    to *strptime()*: *getdate()* (specified in SUSv3 and widely available) and its
    reentrant analog *getdate_r()* (not specified in SUSv3 and available on only a
    few other UNIX implementations). We don’t describe these functions here, because
    they employ an external file (identified by the environment variable `DATEMSK`)
    to specify the format used for scanning the date, which makes them somewhat awkward
    to use and also creates security vulnerabilities in set-user-ID programs.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: GNU C 库还提供了两个与*strptime()*类似的函数：*getdate()*（在SUSv3中指定并广泛可用）及其可重入版本*getdate_r()*（在SUSv3中未指定，仅在少数其他UNIX实现中可用）。我们在此不描述这些函数，因为它们使用外部文件（由环境变量`DATEMSK`指定）来确定扫描日期时使用的格式，这使得它们使用起来有些笨拙，并且在设置用户ID程序时会带来安全漏洞。
- en: '[Example 10-3](ch10.html#retrieving_and_converting_calendar_t "Example 10-3. Retrieving
    and converting calendar times") demonstrates the use of *strptime()* and *strftime()*.
    This program takes a command-line argument containing a date and time, converts
    this to a broken-down time using *strptime()*, and then displays the result of
    performing the reverse conversion using *strftime()*. The program takes up to
    three arguments, of which the first two are required. The first argument is the
    string containing a date and time. The second argument is the format specification
    to be used by *strptime()* to parse the first argument. The optional third argument
    is the format string to be used by *strftime()* for the reverse conversion. If
    this argument is omitted, a default format string is used. (We describe the *setlocale()*
    function used in this program in Section 10.4.) The following shell session log
    shows some examples of the use of this program:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-3](ch10.html#retrieving_and_converting_calendar_t "示例 10-3. 获取并转换日历时间")演示了*strptime()*和*strftime()*的使用。该程序接受一个包含日期和时间的命令行参数，使用*strptime()*将其转换为拆分后的时间，然后显示使用*strftime()*进行反向转换的结果。该程序最多接受三个参数，其中前两个是必需的。第一个参数是包含日期和时间的字符串。第二个参数是*strptime()*用于解析第一个参数的格式规范。可选的第三个参数是*strftime()*用于反向转换的格式字符串。如果省略此参数，则使用默认格式字符串。（我们在第10.4节中描述了该程序中使用的*setlocale()*函数。）以下是该程序的一些使用示例：'
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following usage is similar, but this time we explicitly specify a format
    for *strftime()*:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下用法相似，但这次我们显式指定了*strftime()*的格式：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Example 10-3. Retrieving and converting calendar times
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-3. 获取并转换日历时间
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Timezones
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时区
- en: Different countries (and sometimes even different regions within a single country)
    operate on different timezones and DST regimes. Programs that input and output
    times must take into account the timezone and DST regime of the system on which
    they are run. Fortunately, all of the details are handled by the C library.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的国家（有时即使是同一国家的不同地区）使用不同的时区和夏令时制度。输入和输出时间的程序必须考虑它们运行的系统的时区和夏令时制度。幸运的是，所有这些细节都由C库处理。
- en: Timezone definitions
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 时区定义
- en: Timezone information tends to be both voluminous and volatile. For this reason,
    rather than encoding it directly into programs or libraries, the system maintains
    this information in files in standard formats.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 时区信息通常是庞大且易变的。因此，系统将此信息保存在标准格式的文件中，而不是直接编码到程序或库中。
- en: These files reside in the directory `/usr/share/zoneinfo`. Each file in this
    directory contains information about the timezone regime in a particular country
    or region. These files are named according to the timezone they describe, so we
    may find files with names such as `EST` (US Eastern Standard Time), `CET` (Central
    European Time), `UTC`, `Turkey`, and `Iran`. In addition, subdirectories can be
    used to hierarchically group related timezones. Under a directory such as `Pacific`,
    we may find the files `Auckland`, `Port_Moresby`, and `Galapagos`. When we specify
    a timezone for use by a program, in effect, we are specifying a relative pathname
    for one of the timezone files in this directory.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件存放在`/usr/share/zoneinfo`目录下。该目录中的每个文件包含一个特定国家或地区的时区信息。这些文件的命名根据所描述的时区，因此我们可能会找到如`EST`（美国东部标准时间）、`CET`（中欧时间）、`UTC`、`Turkey`和`Iran`等文件。此外，子目录可用于按层次结构组织相关的时区。在如`Pacific`的目录下，我们可能会找到`Auckland`、`Port_Moresby`和`Galapagos`等文件。当我们为程序指定时区时，实际上是为该目录中的某个时区文件指定了一个相对路径名。
- en: The local time for the system is defined by the timezone file `/etc/localtime`,
    which is often linked to one of the files in `/usr/share/zoneinfo`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的本地时间由时区文件`/etc/localtime`定义，该文件通常链接到`/usr/share/zoneinfo`目录中的某个文件。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The format of timezone files is documented in the *tzfile(5)* manual page. Timezone
    files are built using *zic(8)*, the *zone information compiler*. The *zdump(8)*
    command can be used to display the time as it would be currently according to
    the timezone in a specified timezone file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 时区文件的格式在*tzfile(5)*手册页中有说明。时区文件是使用*zic(8)*，即*时区信息编译器*构建的。*zdump(8)*命令可用于显示根据指定时区文件中的时区当前的时间。
- en: Specifying the timezone for a program
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为程序指定时区
- en: To specify a timezone when running a program, we set the `TZ` environment variable
    to a string consisting of a colon (`:`) followed by one of the timezone names
    defined in `/usr/share/zoneinfo`. Setting the timezone automatically influences
    the functions *ctime()*, *localtime()*, *mktime()*, and *strftime()*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行程序时指定时区，我们将`TZ`环境变量设置为一个字符串，格式为一个冒号（`:`）后跟`/usr/share/zoneinfo`中定义的某个时区名称。设置时区会自动影响函数*ctime()*、*localtime()*、*mktime()*和*strftime()*。
- en: 'To obtain the current timezone setting, each of these functions uses *tzset(3)*,
    which initializes three global variables:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取当前的时区设置，每个这些函数都使用*tzset(3)*，它初始化了三个全局变量：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The *tzset()* function first checks the `TZ` environment variable. If this variable
    is not set, then the timezone is initialized to the default defined in the timezone
    file `/etc/localtime`. If the `TZ` environment variable is defined with a value
    that can’t be matched to a timezone file, or it is an empty string, then UTC is
    used. The `TZDIR` environment variable (a nonstandard GNU-extension) can be set
    to the name of a directory in which timezone information should be sought instead
    of in the default `/usr/share/zoneinfo`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*tzset()* 函数首先检查`TZ`环境变量。如果该变量没有设置，则时区会初始化为在时区文件`/etc/localtime`中定义的默认时区。如果`TZ`环境变量被定义为无法匹配到时区文件的值，或者为空字符串，则使用UTC。`TZDIR`环境变量（一个非标准的GNU扩展）可以设置为指定的目录名称，在该目录中查找时区信息，而不是默认的`/usr/share/zoneinfo`。'
- en: We can see the effect of the `TZ` variable by running the program in [Example 10-4](ch10.html#demonstrate_the_effect_of_timezones_and
    "Example 10-4. Demonstrate the effect of timezones and locales"). In the first
    run, we see the output corresponding to the system’s default timezone (Central
    European Time, CET). In the second run, we specify the timezone for New Zealand,
    which at this time of year is on daylight saving time, 12 hours ahead of CET.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行[示例10-4](ch10.html#demonstrate_the_effect_of_timezones_and "示例10-4.
    展示时区和区域设置的影响")程序来查看`TZ`变量的效果。在第一次运行中，我们看到与系统默认时区（中欧时间，CET）对应的输出。在第二次运行中，我们指定了新西兰的时区，此时新西兰正处于夏令时，比中欧时间早12小时。
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Example 10-4. Demonstrate the effect of timezones and locales
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 示例10-4. 展示时区和区域设置的影响
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: SUSv3 defines two general ways in which the `TZ` environment variable can be
    set. As just described, `TZ` can be set to a character sequence consisting of
    a colon plus a string that identifies the timezone in an implementation-specific
    manner, typically as a pathname for a timezone description file. (Linux and some
    other UNIX implementations permit the colon to be omitted when using this form,
    but SUSv3 doesn’t specify this; for portability, we should always include the
    colon.)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3定义了设置`TZ`环境变量的两种通用方式。如前所述，`TZ`可以设置为一个字符序列，包括一个冒号和一个以实现特定方式标识时区的字符串，通常作为时区描述文件的路径名。（Linux和其他一些UNIX实现允许在使用这种形式时省略冒号，但SUSv3并没有规定这一点；为了便于移植性，我们应始终包含冒号。）
- en: 'The other method of setting `TZ` is fully specified in SUSv3\. In this method,
    we assign a string of the following form to `TZ`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`TZ`的另一种方法在SUSv3中有详细说明。在这种方法中，我们将以下格式的字符串分配给`TZ`：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Spaces are included in the line above for clarity, but none should appear in
    the `TZ` value. The brackets (`[]`) are used to indicate optional components.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的行中包括空格是为了清晰，但`TZ`值中不应包含空格。括号（`[]`）用于表示可选组件。
- en: The *std* and *dst* components are strings that define names for the standard
    and DST timezones; for example, *CET* and *CEST* for Central European Time and
    Central European Summer Time. The *offset* in each case specifies the positive
    or negative adjustment to add to the local time to convert it to UTC. The final
    four components provide a rule describing when the change from standard time to
    DST occurs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*std*和*dst*组件是定义标准时区和夏令时时区名称的字符串；例如，中欧时间（CET）和中欧夏令时（CEST）。每个组件中的*offset*指定要添加到本地时间的正或负调整，以将其转换为UTC。最后四个组件提供一个规则，描述从标准时间到夏令时的切换时间。'
- en: The dates can be specified in a variety of forms, one of which is `M`*`m`*`.`*`n`*`.`d.
    This notation means day *d* (0 = Sunday, 6 = Saturday) of week *n* (1 to 5, where
    5 always means the last *d* day) of month *m* (1 to 12). If the *time* is omitted,
    it defaults to 02:00:00 (2 AM) in each case.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 日期可以以多种形式指定，其中一种是`M`*`m`*`.`*`n`*`.`d。这种表示法意味着星期*n*（1到5，其中5总是指最后一个*d*日）的第*d*天（0=星期天，6=星期六）的月份*m*（1到12）。如果省略了*时间*，它默认为每次02:00:00（凌晨2点）。
- en: 'Here is how we could define `TZ` for Central Europe, where standard time is
    one hour ahead of UTC, and DST—running from the last Sunday in March to the last
    Sunday in October—is 2 hours ahead of UTC:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何为中欧定义`TZ`，其中标准时间比UTC快一小时，夏令时（从三月的最后一个星期天到十月的最后一个星期天）比UTC快两小时：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We omitted the specification of the time for the DST changeover, since it occurs
    at the default of 02:00:00\. Of course, the preceding form is less readable than
    the Linux-specific near equivalent:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了夏令时切换的时间规格，因为它发生在默认的02:00:00。当然，前述格式的可读性不如Linux特定的近似形式：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Locales
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区域设置
- en: Several thousand languages are spoken across the world, of which a significant
    percentage are regularly used on computer systems. Furthermore, different countries
    use different conventions for displaying information such as numbers, currency
    amounts, dates, and times. For example, in most European countries, a comma, rather
    than a decimal point, is used to separate the integer and fractional parts of
    (real) numbers, and most countries use formats for writing dates that are different
    from the *MM/DD/YY* format used in the United States. SUSv3 defines a *locale*
    as the “subset of a user’s environment that depends on language and cultural conventions.”
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上有几千种语言，其中相当大一部分在计算机系统中被定期使用。此外，不同国家使用不同的惯例来显示信息，如数字、货币金额、日期和时间。例如，在大多数欧洲国家，使用逗号而非小数点来分隔（实数）数字的整数部分和小数部分，大多数国家使用的日期书写格式不同于美国使用的*MM/DD/YY*格式。SUSv3将*区域*定义为“依赖于语言和文化惯例的用户环境子集。”
- en: Ideally, all programs designed to run in more than one location should deal
    with locales in order to display and input information in the user’s preferred
    language and format. This constitutes the complex subject of *internationalization*.
    In the ideal world, we would write a program once, and then, wherever it was run,
    it would automatically do the right things when performing I/O; that is, it would
    perform the task of *localization*. Internationalizing programs is a somewhat
    time-consuming job, although various tools are available to ease the task. Program
    libraries such as *glibc* also provide facilities to help with internationalization.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，所有设计用于在多个位置运行的程序都应处理区域设置，以便以用户首选的语言和格式显示和输入信息。这构成了复杂的*国际化*主题。在理想情况下，我们只需编写一次程序，然后无论它运行在哪里，它都会在执行输入输出操作时自动做出正确的处理；也就是说，它会执行*本地化*的任务。使程序国际化是一项相当耗时的工作，尽管有各种工具可以简化这个过程。像*glibc*这样的程序库也提供了帮助国际化的功能。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The term *internationalization* is often written as *I18N*, for *I* plus 18
    letters plus *N*. As well as being quicker to write, this term has the advantage
    of avoiding the difference in the spelling of the term itself in British and American
    English.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*国际化*这个术语常被写作*I18N*，即*I*加18个字母加*N*。这个术语不仅写起来更快，还有一个优点，即避免了英国英语和美式英语中拼写差异的问题。'
- en: Locale definitions
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 区域定义
- en: Like timezone information, locale information tends to be both voluminous and
    volatile. For this reason, rather than requiring each program and library to store
    locale information, the system maintains this information in files in standard
    formats.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 与时区信息类似，区域信息通常既庞大又不断变化。因此，系统通过标准格式的文件来存储这些信息，而不是要求每个程序和库都存储区域信息。
- en: 'Locale information is maintained in a directory hierarchy under `/usr/share/locale`
    (or `/usr/lib/locale` in some distributions). Each subdirectory under this directory
    contains information about a particular locale. These directories are named using
    the following convention:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 区域信息在`/usr/share/locale`（或某些发行版中的`/usr/lib/locale`）的目录层次结构中维护。该目录下的每个子目录包含有关特定区域的信息。这些目录使用以下约定命名：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The *language* is a two-letter ISO language code, and the *territory* is a
    two-letter ISO country code. The *codeset* designates a character-encoding set.
    The *modifier* provides a means of distinguishing multiple locale directories
    whose language, territory, and codeset are the same. An example of a complete
    locale directory name is `de_DE.utf-8@euro`, as the locale for: German language,
    Germany, UTF-8 character encoding, employing the euro as the monetary unit.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*语言*是一个两字母的ISO语言代码，*地区*是一个两字母的ISO国家代码。*字符集*指定一个字符编码集。*修饰符*提供了一种区分具有相同语言、地区和字符集的多个区域目录的方法。一个完整的区域目录名称的示例是`de_DE.utf-8@euro`，表示：德语语言，德国，UTF-8字符编码，使用欧元作为货币单位。'
- en: As indicated by the brackets shown in the directory naming format, various parts
    of the name of a locale directory can be omitted. Often the name consists of just
    a language and a territory. Thus, the directory `en_US` is the locale directory
    for the (English-speaking) United States, and `fr_CH` is the locale directory
    for the French-speaking region of Switzerland.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如目录命名格式中所示的括号所示，区域目录名称的各个部分可以省略。通常，名称仅包含语言和地区。因此，目录`en_US`是针对（讲英语的）美国的区域目录，而`fr_CH`是针对瑞士法语区的区域目录。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *CH* stands for *Confoederatio Helvetica*, the Latin (and thus locally language-neutral)
    name for Switzerland. With four official national languages, Switzerland is an
    example of a locale analog of a country with multiple timezones.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*CH*代表*Confoederatio Helvetica*，这是瑞士的拉丁文名称（因此是本地语言中立的）。瑞士有四种官方语言，是一个具有多个时区的国家类比的语言环境示例。'
- en: 'When we specify a locale to be used within a program, we are, in effect, specifying
    the name of one of the subdirectories under `/usr/share/locale`. If the locale
    specified to the program doesn’t match a locale directory name exactly, then the
    C library searches for a match by stripping components from the specified locale
    in the following order:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为程序指定要使用的语言环境时，实际上是指定了`/usr/share/locale`下某个子目录的名称。如果程序指定的语言环境名称与某个语言环境目录名称完全不匹配，则C库会按以下顺序通过去除组件来查找匹配项：
- en: codeset
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: codeset
- en: normalized codeset
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 规范化代码集
- en: territory
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: territory
- en: modifier
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: modifier
- en: The normalized codeset is a version of the codeset name in which all nonalphanumeric
    characters are removed, all letters are converted to lowercase, and the resulting
    string is preprended with the characters `iso`. The aim of normalizing is to handle
    variations in the capitalization and punctuation (e.g., extra hyphens) of codeset
    names.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 规范化的代码集是代码集名称的一种版本，其中所有非字母数字字符被移除，所有字母都转换为小写，并且结果字符串前加上字符`iso`。规范化的目的是处理代码集名称中大写字母和标点符号（例如，额外的连字符）的变化。
- en: As an example of this stripping process, if the locale for a program is specified
    as `fr_CH.utf-8`, but no locale directory by that name exists, then the `fr_CH`
    locale directory will be matched if it exists. If the `fr_CH` directory doesn’t
    exist, then the `fr` locale directory will be used. In the unlikely event that
    the `fr` directory doesn’t exist, then the *setlocale()* function, described shortly,
    will report an error.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 作为此剥离过程的示例，如果程序的语言环境指定为`fr_CH.utf-8`，但没有该名称的语言环境目录，则如果`fr_CH`语言环境目录存在，将匹配该目录。如果`fr_CH`目录不存在，则将使用`fr`语言环境目录。如果`fr`目录也不存在，则即将介绍的*setlocale()*函数将报告错误。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The file `/usr/share/locale/locale.alias` defines alternative ways of specifying
    locales to a program. See the *locale.aliases(5)* manual page for details.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`/usr/share/locale/locale.alias`定义了为程序指定语言环境的替代方式。有关详细信息，请参见*locale.aliases(5)*手册页面。
- en: 'Under each locale subdirectory is a standard set of files that specify the
    conventions for this locale, as shown in [Table 10-2](ch10.html#contents_of_locale-specific_subdirectori
    "Table 10-2. Contents of locale-specific subdirectories"). Note the following
    further points concerning the information in this table:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 每个语言环境子目录下都有一组标准文件，指定该语言环境的约定，如[表10-2](ch10.html#contents_of_locale-specific_subdirectori
    "Table 10-2. Contents of locale-specific subdirectories")所示。请注意以下关于此表中信息的进一步说明：
- en: The `LC_COLLATE` file defines a set of rules describing how the characters in
    a character set are ordered (i.e., the “alphabetical” order for the character
    set). These rules determine the operation of the *strcoll(3)* and *strxfrm(3)*
    functions. Even languages using Latin-based scripts don’t follow the same ordering
    rules. For example, several European languages have additional letters that, in
    some cases, sort after the letter *Z*. Other special cases include the Spanish
    two-letter sequence *ll*, which sorts as a single letter after *l*, and the German
    umlauted characters such as *ä*, which corresponds to *ae* and sorts as those
    two letters.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LC_COLLATE`文件定义了一组规则，描述字符集中的字符如何排序（即字符集的“字母顺序”）。这些规则决定了*strcoll(3)*和*strxfrm(3)*函数的操作。即使是使用拉丁字母的语言也不遵循相同的排序规则。例如，一些欧洲语言有额外的字母，在某些情况下，这些字母排序在字母*Z*之后。其他特殊情况包括西班牙语的双字母序列*ll*，它作为一个单独的字母排序在*l*之后，以及德语的变音字符，如*ä*，它对应于*ae*并按这两个字母排序。'
- en: The `LC_MESSAGES` directory is one step toward internationalizing the messages
    displayed by a program. More extensive internationalization of program messages
    can be accomplished through the use of either message catalogs (see the *catopen(3)*
    and *catgets(3)* manual pages) or the GNU *gettext* API (available at [http://www.gnu.org/](http://www.gnu.org/)).
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LC_MESSAGES`目录是朝着国际化程序显示消息迈出的第一步。通过使用消息目录（参见*catopen(3)*和*catgets(3)*手册页面）或GNU
    *gettext* API（可在[http://www.gnu.org/](http://www.gnu.org/)找到），可以实现程序消息的更广泛国际化。'
- en: Note
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Version 2.2.2 of *glibc* introduced a number of new, nonstandard locale categories.
    `LC_ADDRESS` defines rules for the locale-specific representation of a postal
    address. `LC_IDENTIFICATION` specifies information identifying the locale. `LC_MEASUREMENT`
    defines the measurement system for the locale (e.g., metric versus imperial).
    `LC_NAME` defines the locale-specific rules for representation of a person’s names
    and title. `LC_PAPER` defines the standard paper size for the locale (e.g., US
    letter versus the A4 format used in most other countries). `LC_TELEPHONE` defines
    the rules for locale-specific representation of domestic and international telephone
    numbers, as well as the international country prefix and international dial-out
    prefix.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*glibc* 版本2.2.2引入了多个新的非标准区域设置类别。`LC_ADDRESS`定义了区域特定的邮政地址表示规则。`LC_IDENTIFICATION`指定了标识区域设置的信息。`LC_MEASUREMENT`定义了该区域的测量系统（例如，公制与英制）。`LC_NAME`定义了表示个人姓名和头衔的区域特定规则。`LC_PAPER`定义了该区域的标准纸张大小（例如，美国信纸与大多数其他国家使用的A4格式）。`LC_TELEPHONE`定义了区域特定的国内和国际电话号码表示规则，以及国际国家前缀和国际拨出前缀。'
- en: Table 10-2. Contents of locale-specific subdirectories
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 表10-2. 区域设置特定子目录的内容
- en: '| Filename | Purpose |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 文件名 | 作用 |'
- en: '| --- | --- |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `LC_CTYPE` | A file containing character classifications (see *isalpha(3)*)
    and rules for case conversion |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `LC_CTYPE` | 一个包含字符分类（参见 *isalpha(3)*) 和大小写转换规则的文件 |'
- en: '| `LC_COLLATE` | A file containing the collation rules for a character set
    |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `LC_COLLATE` | 包含字符集排序规则的文件 |'
- en: '| `LC_MONETARY` | A file containing formatting rules for monetary values (see
    *localeconv(3)* and `<locale.h>`) |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `LC_MONETARY` | 包含货币值格式化规则的文件（参见 *localeconv(3)* 和 `<locale.h>`） |'
- en: '| `LC_NUMERIC` | A file containing formatting rules for numbers other than
    monetary values (see *localeconv(3)* and `<locale.h>`) |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `LC_NUMERIC` | 包含除货币值以外的数字格式化规则的文件（参见 *localeconv(3)* 和 `<locale.h>`） |'
- en: '| `LC_TIME` | A file containing formatting rules for dates and times |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `LC_TIME` | 一个包含日期和时间格式化规则的文件 |'
- en: '| `LC_MESSAGES` | A directory containing files specifying formats and values
    used for affirmative and negative (yes/no) responses |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `LC_MESSAGES` | 一个包含用于肯定和否定（是/否）响应格式和数值的文件夹 |'
- en: The actual locales that are defined on a system can vary. SUSv3 doesn’t make
    any requirements about this, except that a standard locale called *POSIX* (and
    synonymously, *C*, a name that exists for historical reasons) must be defined.
    This locale mirrors the historical behavior of UNIX systems. Thus, it is based
    on an ASCII character set, and uses English for names of days and months, and
    for yes/no responses. The monetary and numeric components of this locale are undefined.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 系统上定义的实际区域设置可能会有所不同。SUSv3并未对此做出任何要求，除了必须定义一个名为*POSIX*的标准区域设置（同义词为*C*，这是一个历史原因存在的名称）。该区域设置反映了UNIX系统的历史行为。因此，它基于ASCII字符集，并使用英语表示星期几和月份的名称，以及“是/否”的回应。该区域设置的货币和数字组件未定义。
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: The *locale* command displays information about the current locale environment
    (within the shell). The command *locale -a* lists the full set of locales defined
    on the system.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*locale* 命令显示关于当前区域设置环境的信息（在Shell中）。命令 *locale -a* 列出系统上定义的所有区域设置。'
- en: Specifying the locale for a program
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为程序指定区域设置
- en: The *setlocale()* function is used to both set and query a program’s current
    locale.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*setlocale()* 函数用于设置和查询程序的当前区域设置。'
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: Returns pointer to a (usually statically allocated) string identifying the new
    or current locale on success, or `NULL` on error
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回指向（通常是静态分配的）字符串的指针，标识新的或当前的区域设置，出错时返回`NULL`
- en: The *category* argument selects which part of the locale to set or query, and
    is specified as one of a set of constants whose names are the same as the locale
    categories listed in [Table 10-2](ch10.html#contents_of_locale-specific_subdirectori
    "Table 10-2. Contents of locale-specific subdirectories"). Thus, for example,
    it is possible to set the locale for time displays to be Germany, while setting
    the locale for monetary displays to US dollars. Alternatively, and more commonly,
    we can use the value `LC_ALL` to specify that we want to set all aspects of the
    locale.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*category* 参数用于选择要设置或查询的区域设置部分，并作为一组常量之一指定，这些常量的名称与[表10-2](ch10.html#contents_of_locale-specific_subdirectori
    "表10-2. 区域设置特定子目录的内容")中列出的区域类别相同。因此，例如，可以将时间显示的区域设置为德国，同时将货币显示的区域设置为美元。或者，更常见的做法是使用值`LC_ALL`来指定希望设置区域设置的所有方面。'
- en: 'There are two different methods of setting the locale using *setlocale()*.
    The *locale* argument may be a string specifying one of the locales defined on
    the system (i.e., the name of one of the subdirectories under `/usr/lib/locale`),
    such as `de_DE` or `en_US`. Alternatively, *locale* may be specified as an empty
    string, meaning that locale settings should be taken from environment variables:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 设置区域的方法有两种，使用*setlocale()*。*locale*参数可以是一个字符串，指定系统上定义的某个区域（即`/usr/lib/locale`下的子目录名称），如`de_DE`或`en_US`。另外，*locale*也可以指定为空字符串，表示区域设置应从环境变量中获取：
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We must make this call in order for a program to be cognizant of the locale
    environment variables. If the call is omitted, these environment variables will
    have no effect on the program.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须进行此调用，才能使程序意识到区域环境变量。如果遗漏此调用，这些环境变量将不会对程序产生任何影响。
- en: 'When running a program that makes a *setlocale(LC_ALL, “”)* call, we can control
    various aspects of the locale using a set of environment variables whose names
    again correspond to the categories listed in [Table 10-2](ch10.html#contents_of_locale-specific_subdirectori
    "Table 10-2. Contents of locale-specific subdirectories"): `LC_CTYPE`, `LC_COLLATE`,
    `LC_MONETARY`, `LC_NUMERIC`, `LC_TIME`, and `LC_MESSAGES`. Alternatively, we can
    use the `LC_ALL` or the `LANG` environment variable to specify the setting of
    the entire locale. If more than one of the preceding variables is set, then `LC_ALL`
    has precedence over all of the other `LC_*` environment variables, and `LANG`
    has lowest precedence. Thus, it is possible to use `LANG` to set a default locale
    for all categories, and then use individual `LC_*` variables to set aspects of
    the locale to something other than this default.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行一个调用了*setlocale(LC_ALL, “”)*的程序时，我们可以使用一组环境变量来控制区域的各个方面，这些环境变量的名称与[表10-2](ch10.html#contents_of_locale-specific_subdirectori
    "表10-2. 区域特定子目录的内容")中列出的类别对应：`LC_CTYPE`、`LC_COLLATE`、`LC_MONETARY`、`LC_NUMERIC`、`LC_TIME`和`LC_MESSAGES`。另外，我们也可以使用`LC_ALL`或`LANG`环境变量来指定整个区域的设置。如果设置了多个上述变量，则`LC_ALL`优先于所有其他`LC_*`环境变量，而`LANG`的优先级最低。因此，可以使用`LANG`为所有类别设置默认区域，然后使用单独的`LC_*`变量将区域的某些方面设置为与此默认值不同。
- en: As its result, *setlocale()* returns a pointer to a (usually statically allocated)
    string that identifies the locale setting for this category. If we are interested
    only in discovering the current locale setting, without changing it, then we can
    specify the *locale* argument as `NULL`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 其结果是，*setlocale()*返回一个指向（通常是静态分配的）字符串的指针，该字符串标识此类别的区域设置。如果我们仅仅是想查看当前的区域设置，而不进行更改，那么可以将*locale*参数指定为`NULL`。
- en: 'Locale settings control the operation of a wide range of GNU/Linux utilities,
    as well as many functions in *glibc*. Among these are the functions *strftime()*
    and *strptime()* ([Converting Between Broken-Down Time and Printable Form](ch10.html#converting_between_broken-down_time_and
    "Converting Between Broken-Down Time and Printable Form")), as shown by the results
    from *strftime()* when we run the program in [Example 10-4](ch10.html#demonstrate_the_effect_of_timezones_and
    "Example 10-4. Demonstrate the effect of timezones and locales") in a number of
    different locales:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 区域设置控制着广泛的GNU/Linux工具的操作，以及*glibc*中的许多函数。包括*strftime()*和*strptime()*（[在已解析的时间与可打印格式之间转换](ch10.html#converting_between_broken-down_time_and
    "在已解析的时间与可打印格式之间转换")），如我们在[示例10-4](ch10.html#demonstrate_the_effect_of_timezones_and
    "示例10-4. 演示时区和区域的影响")中运行程序时，`strftime()`的结果在不同区域下的表现所示：
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next run demonstrates that the `LC_TIME` has precedence over `LANG`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下一次运行演示了`LC_TIME`优先于`LANG`：
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And this run demonstrates that `LC_ALL` has precedence over `LC_TIME`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这次运行演示了`LC_ALL`优先于`LC_TIME`：
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Updating the System Clock
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新系统时钟
- en: 'We now look at two interfaces that update the system clock: *settimeofday()*
    and *adjtime()*. These interfaces are rarely used by application programs (since
    the system time is usually maintained by tools such as the *Network Time Protocol*
    daemon), and they require that the caller be privileged (`CAP_SYS_TIME`).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看两种更新系统时钟的接口：*settimeofday()*和*adjtime()*。这些接口很少被应用程序使用（因为系统时间通常由像*网络时间协议*守护进程这样的工具维护），并且要求调用者具有特权（`CAP_SYS_TIME`）。
- en: 'The *settimeofday()* system call performs the converse of *gettimeofday()*
    (which we described in [Calendar Time](ch10.html#calendar_time "Calendar Time")):
    it sets the system’s calendar time to the number of seconds and microseconds specified
    in the *timeval* structure pointed to by *tv*.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*settimeofday()* 系统调用执行的是 *gettimeofday()* 的相反操作（我们在 [日历时间](ch10.html#calendar_time
    "Calendar Time") 中描述了它）：它将系统的日历时间设置为 *timeval* 结构中由 *tv* 指定的秒数和微秒数。'
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: As with *gettimeofday()*, the use of the *tz* argument is obsolete, and this
    argument should always be specified as `NULL`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *gettimeofday()* 一样，*tz* 参数的使用已过时，应始终将该参数指定为 `NULL`。
- en: The microsecond precision of the *tv.tv_usec* field doesn’t mean that we have
    microsecond accuracy in controlling the system clock, since the clock’s granularity
    may be larger than one microsecond.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*tv.tv_usec* 字段的微秒精度并不意味着我们在控制系统时钟时具有微秒级的精度，因为时钟的粒度可能大于一微秒。'
- en: Although *settimeofday()* is not specified in SUSv3, it is widely available
    on other UNIX implementations.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 *settimeofday()* 在 SUSv3 中没有被指定，但在其他 UNIX 实现中广泛可用。
- en: Note
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Linux also provides the *stime()* system call for setting the system clock.
    The difference between *settimeofday()* and *stime()* is that the latter call
    allows the new calendar time to be expressed with a precision of only 1 second.
    As with *time()* and *gettimeofday()*, the reason for the existence of both *stime()*
    and *settimeofday()* is historical: the latter, more precise call was added by
    4.2BSD.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 还提供了 *stime()* 系统调用来设置系统时钟。*settimeofday()* 和 *stime()* 的区别在于后者的调用允许以
    1 秒的精度来表示新的日历时间。与 *time()* 和 *gettimeofday()* 一样，*stime()* 和 *settimeofday()*
    都是历史遗留问题：后者更精确的调用是由 4.2BSD 添加的。
- en: Abrupt changes in the system time of the sort caused by calls to *settimeofday()*
    can have deleterious effects on applications (e.g., *make(1)*, a database system
    using timestamps, or time-stamped log files) that depend on a monotonically increasing
    system clock. For this reason, when making small changes to the time (of the order
    of a few seconds), it is usually preferable to use the *adjtime()* library function,
    which causes the system clock to gradually adjust to the desired value.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由 *settimeofday()* 引起的系统时间的突然变化可能会对依赖单调递增系统时钟的应用程序（例如 *make(1)*、使用时间戳的数据库系统或带时间戳的日志文件）产生不良影响。因此，在进行小范围的时间调整（几秒钟）时，通常建议使用
    *adjtime()* 库函数，它会使系统时钟逐渐调整到所需的值。
- en: '[PRE32]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: The *delta* argument points to a *timeval* structure that specifies the number
    of seconds and microseconds by which to change the time. If this value is positive,
    then a small amount of additional time is added to the system clock each second,
    until the desired amount of time has been added. If the *delta* value is negative,
    the clock is slowed down in a similar fashion.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*delta* 参数指向一个 *timeval* 结构，该结构指定了要改变时间的秒数和微秒数。如果该值为正，则每秒钟向系统时钟添加少量的额外时间，直到添加完所需的时间。如果
    *delta* 值为负，则时钟以类似的方式被减速。'
- en: Note
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The rate of clock adjustment on Linux/x86-32 amounts to 1 second per 2000 seconds
    (or 43.2 seconds per day).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux/x86-32 上，时钟调整速率为每 2000 秒 1 秒（即每天 43.2 秒）。
- en: It may be that an incomplete clock adjustment was in progress at the time of
    the *adjtime()* call. In this case, the amount of remaining, unadjusted time is
    returned in the *timeval* structure pointed to by *olddelta*. If we are not interested
    in this value, we can specify *olddelta* as `NULL`. Conversely, if we are interested
    only in knowing the currently outstanding time correction to be made, and don’t
    want to change the value, we can specify the *delta* argument as `NULL`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 *adjtime()* 时，可能正在进行不完整的时钟调整。在这种情况下，剩余的未调整时间会以 *timeval* 结构的形式返回，该结构由 *olddelta*
    指向。如果我们不关心这个值，可以将 *olddelta* 指定为 `NULL`。相反，如果我们只关心当前未完成的时间修正，并且不想改变值，我们可以将 *delta*
    参数指定为 `NULL`。
- en: Although not specified in SUSv3, *adjtime()* is available on most UNIX implementations.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 SUSv3 中没有指定，*adjtime()* 在大多数 UNIX 实现中都可用。
- en: Note
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux, *adjtime()* is implemented on top of a more general (and complex)
    Linux-specific system call, *adjtimex()*. This system call is employed by the
    *Network Time Protocol* (NTP) daemon. For further information, refer to the Linux
    source code, the Linux *adjtimex(2)* manual page, and the NTP specification ([Mills,
    1992]).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，*adjtime()*是建立在更一般（且复杂）的Linux特定系统调用*adjtimex()*之上的。该系统调用由*网络时间协议*（NTP）守护进程使用。有关详细信息，请参阅Linux源代码、Linux的*adjtimex(2)*手册页以及NTP规范（[Mills，1992]）。
- en: The Software Clock (Jiffies)
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件时钟（Jiffies）
- en: The accuracy of various time-related system calls described in this book is
    limited to the resolution of the system *software clock*, which measures time
    in units called *jiffies*. The size of a jiffy is defined by the constant `HZ`
    within the kernel source code. This is the unit in which the kernel allocates
    the CPU to processes under the round-robin time-sharing scheduling algorithm ([Process
    Priorities (Nice Values)](ch35.html#process_priorities_open_parenthesis_nice "Process
    Priorities (Nice Values)")).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的各种与时间相关的系统调用的精度受到系统*软件时钟*的限制，软件时钟以称为*jiffies*的单位来度量时间。一个jiffy的大小由内核源代码中的常量`HZ`定义。内核在使用轮询时间共享调度算法分配CPU给进程时，单位就是这个（[进程优先级（Nice值）](ch35.html#process_priorities_open_parenthesis_nice
    "进程优先级（Nice值）")）。
- en: On Linux/x86-32 in kernel versions up to and including 2.4, the rate of the
    software clock was 100 hertz; that is, a jiffy is 10 milliseconds.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux/x86-32内核版本2.4及之前，软件时钟的频率为100赫兹；也就是说，一个jiffy等于10毫秒。
- en: Because CPU speeds have greatly increased since Linux was first implemented,
    in kernel 2.6.0, the rate of the software clock was raised to 1000 hertz on Linux/x86-32\.
    The advantages of a higher software clock rate are that timers can operate with
    greater accuracy and time measurements can be made with greater precision. However,
    it isn’t desirable to set the clock rate to arbitrarily high values, because each
    clock interrupt consumes a small amount of CPU time, which is time that the CPU
    can’t spend executing processes.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 由于自Linux首次实现以来，CPU速度大幅提高，因此在内核2.6.0版本中，Linux/x86-32上的软件时钟频率提高到了1000赫兹。软件时钟频率更高的优点在于定时器可以更精确地运行，时间测量也可以更精确。然而，不建议将时钟频率设置为任意高的值，因为每个时钟中断都会消耗少量的CPU时间，而这些时间本应被CPU用于执行进程。
- en: 'Debate among kernel developers eventually resulted in the software clock rate
    becoming a configurable kernel option (under *Processor type and features, Timer
    frequency*). Since kernel 2.6.13, the clock rate can be set to 100, 250 (the default),
    or 1000 hertz, giving jiffy values of 10, 4, and 1 milliseconds, respectively.
    Since kernel 2.6.20, a further frequency is available: 300 hertz, a number that
    divides evenly for two common video frame rates: 25 frames per second (PAL) and
    30 frames per second (NTSC).'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 内核开发人员的辩论最终导致软件时钟频率成为一个可配置的内核选项（在*处理器类型和功能，定时器频率*下）。自内核2.6.13以来，时钟频率可以设置为100、250（默认值）或1000赫兹，分别对应10、4和1毫秒的jiffy值。从内核2.6.20开始，还提供了300赫兹的频率，这个频率能均匀地适用于两种常见的视频帧率：25帧每秒（PAL）和30帧每秒（NTSC）。
- en: Process Time
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程时间
- en: 'Process time is the amount of CPU time used by a process since it was created.
    For recording purposes, the kernel separates CPU time into the following two components:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 进程时间是自进程创建以来所使用的CPU时间。为了记录目的，内核将CPU时间分为以下两个组成部分：
- en: '*User CPU time* is the amount of time spent executing in user mode. Sometimes
    referred to as *virtual time*, this is the time that it appears to the program
    that it has access to the CPU.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用户CPU时间*是指在用户模式下执行的时间。 有时也称为*虚拟时间*，这是程序看起来它可以访问CPU的时间。'
- en: '*System CPU time* is amount of time spent executing in kernel mode. This is
    the time that the kernel spends executing system calls or performing other tasks
    on behalf of the program (e.g., servicing page faults).'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*系统CPU时间*是指在内核模式下执行的时间。 这是内核花费时间执行系统调用或为程序执行其他任务（例如处理页面错误）。'
- en: Sometimes, we refer to process time as the *total CPU time* consumed by the
    process.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们将进程时间称为进程消耗的*总CPU时间*。
- en: 'When we run a program from the shell, we can use the *time(1)* command to obtain
    both process time values, as well as the real time required to run the program:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从Shell中运行程序时，可以使用*time(1)*命令获取进程时间值以及运行程序所需的实际时间：
- en: '[PRE33]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The *times()* system call retrieves process time information, returning it in
    the structure pointed to by *buf*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*times()*系统调用检索进程时间信息，并将其返回到由*buf*指针指向的结构中。'
- en: '[PRE34]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of clock ticks (*sysconf(_SC_CLK_TCK)*) since “arbitrary” time
    in past on success, or *(clock_t)* -1 on error
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 返回自“任意”过去时间点以来的时钟滴答数 (*sysconf(_SC_CLK_TCK)*)，成功时返回，出错时返回 *(clock_t)* -1
- en: 'This *tms* structure pointed to by *buf* has the following form:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由 *buf* 指向的 *tms* 结构体具有以下形式：
- en: '[PRE35]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first two fields of the *tms* structure return the user and system components
    of CPU time used so far by the calling process. The last two fields return information
    about the CPU time used by all child processes that have terminated and for which
    the parent (i.e., the caller of *times()*) has done a *wait()* system call.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*tms* 结构体的前两个字段返回调用进程到目前为止使用的用户和系统部分的 CPU 时间。最后两个字段返回所有已终止的子进程所使用的 CPU 时间的信息，这些子进程的父进程（即
    *times()* 的调用者）已执行了 *wait()* 系统调用。'
- en: The *clock_t* data type used to type the four fields of the *tms* structure
    is an integer type that measures time in units called *clock ticks*. We can call
    *sysconf(_SC_CLK_TCK)* to obtain the number of clock ticks per second, and then
    divide a *clock_t* value by this number to convert to seconds. (We describe *sysconf()*
    in Section 11.2.)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 用于类型化 *tms* 结构体四个字段的 *clock_t* 数据类型是一种整数类型，衡量的是以 *clock ticks* 为单位的时间。我们可以调用
    *sysconf(_SC_CLK_TCK)* 来获取每秒的时钟滴答数，然后将 *clock_t* 值除以这个数字，转换为秒。（我们将在第 11.2 节中描述
    *sysconf()*。）
- en: Note
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On most Linux hardware architectures, *sysconf(_SC_CLK_TCK)* returns the number
    100\. This corresponds to the kernel constant `USER_HZ`. However, `USER_HZ` can
    be defined with a value other than 100 on a few architectures, such as Alpha and
    IA-64.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数 Linux 硬件架构上，*sysconf(_SC_CLK_TCK)* 返回数字 100。这对应于内核常量 `USER_HZ`。然而，在某些架构上（如
    Alpha 和 IA-64），`USER_HZ` 可以定义为除 100 以外的其他值。
- en: On success, *times()* returns the elapsed (real) time in clock ticks since some
    arbitrary point in the past. SUSv3 deliberately does not specify what this point
    is, merely stating that it will be constant during the life of the calling process.
    Therefore, the only portable use of this return value is to measure elapsed time
    in the execution of the process by calculating the difference in the value returned
    by pairs of *times()* calls. However, even for this use, the return value of *times()*
    is unreliable, since it can overflow the range of *clock_t*, at which point the
    value would cycle to start again at 0 (i.e., a later *times()* call could return
    a number that is lower than an earlier *times()* call). The reliable way to measure
    the passage of elapsed time is to use *gettimeofday()* (described in [Calendar
    Time](ch10.html#calendar_time "Calendar Time")).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时，*times()* 返回自某个任意时刻以来经过的（实际）时间，单位为时钟滴答。SUSv3 刻意没有指定这个时刻是什么，仅声明它在调用进程的生命周期内是常量。因此，这个返回值唯一的可移植用途是通过计算多次
    *times()* 调用返回值之间的差异来衡量进程执行期间经过的时间。然而，即便是这个用途，*times()* 的返回值也不可靠，因为它可能会超出 *clock_t*
    的范围，届时该值会循环重新从 0 开始（即后续的 *times()* 调用返回的值可能低于先前的 *times()* 调用返回的值）。可靠的测量经过时间的方法是使用
    *gettimeofday()*（在 [日历时间](ch10.html#calendar_time "Calendar Time") 中描述）。
- en: On Linux, we can specify *buf* as `NULL`; in this case, *times()* simply returns
    a function result. However, this is not portable. The use of `NULL` for *buf*
    is not specified in SUSv3, and many other UNIX implementations require a non-`NULL`
    value for this argument.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，我们可以将 *buf* 设置为 `NULL`；在这种情况下，*times()* 只是简单地返回一个函数结果。然而，这样做并不具备可移植性。SUSv3
    中没有指定将 *buf* 设置为 `NULL`，并且许多其他 UNIX 实现要求此参数必须是非 `NULL` 值。
- en: The *clock()* function provides a simpler interface for retrieving the process
    time. It returns a single value that measures the total (i.e., user plus system)
    CPU time used by the calling process.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*clock()* 函数提供了一个更简洁的接口来获取进程时间。它返回一个单一的值，表示调用进程使用的总（即用户加系统）CPU时间。'
- en: '[PRE36]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns total CPU time used by calling process measured in `CLOCKS_PER_SEC`,
    or *(clock_t)* -1 on error
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 返回调用进程所使用的总 CPU 时间，单位为 `CLOCKS_PER_SEC`，或者在出错时返回 *(clock_t)* -1
- en: The value returned by *clock()* is measured in units of `CLOCKS_PER_SEC`, so
    we must divide by this value to arrive at the number of seconds of CPU time used
    by the process. `CLOCKS_PER_SEC` is fixed at 1 million by POSIX.1, regardless
    of the resolution of the underlying software clock ([The Software Clock (Jiffies)](ch10.html#the_software_clock_open_parenthesis_jiff
    "The Software Clock (Jiffies)")). The accuracy of *clock()* is nevertheless limited
    to the resolution of the software clock.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*clock()*返回的值是以`CLOCKS_PER_SEC`为单位测量的，因此我们必须除以该值，才能得出进程使用的CPU时间的秒数。`CLOCKS_PER_SEC`由POSIX.1固定为100万，无论底层软件时钟的分辨率如何（参见[软件时钟（Jiffies）](ch10.html#the_software_clock_open_parenthesis_jiff
    "软件时钟（Jiffies）")）。尽管如此，*clock()*的精度仍然受限于软件时钟的分辨率。'
- en: Note
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although the *clock_t* return type of *clock()* is the same data type that is
    used in the *times()* call, the units of measurement employed by these two interfaces
    are different. This is the result of historically conflicting definitions of *clock_t*
    in POSIX.1 and the C programming language standard.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*clock()*的*clock_t*返回类型与*times()*调用中使用的数据类型相同，但这两个接口采用的测量单位是不同的。这是因为POSIX.1和C语言标准中对*clock_t*的定义历史上存在冲突。
- en: Even though `CLOCKS_PER_SEC` is fixed at 1 million, SUSv3 notes that this constant
    could be an integer variable on non-XSI-conformant systems, so that we can’t portably
    treat it as a compile-time constant (i.e., we can’t use it in `#ifdef` preprocessor
    expressions). Because it may be defined as a long integer (i.e., `1000000L`),
    we always cast this constant to *long* so that we can portably print it with *printf()*
    (see [System Data Types](ch03.html#system_data_types "System Data Types")).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`CLOCKS_PER_SEC`固定为100万，SUSv3指出该常量在非XSI兼容的系统上可能是一个整数变量，因此我们不能便捷地将其视为编译时常量（即，不能在`#ifdef`预处理器表达式中使用它）。因为它可能被定义为长整数（即`1000000L`），我们总是将此常量转换为*long*类型，以便能在*printf()*中便捷地打印它（参见[系统数据类型](ch03.html#system_data_types
    "系统数据类型")）。
- en: SUSv3 states that *clock()* should return “the processor time used by the process.”
    This is open to different interpretations. On some UNIX implementations, the time
    returned by *clock()* includes the CPU time used by all waited-for children. On
    Linux, it does not.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3指出，*clock()*应该返回“进程使用的处理器时间”。这可以有不同的解释。在某些UNIX实现中，*clock()*返回的时间包括所有等待的子进程使用的CPU时间。在Linux中则不包括。
- en: Example program
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: 'The program in [Example 10-5](ch10.html#retrieving_process_cpu_times "Example 10-5. Retrieving
    process CPU times") demonstrates the use of the functions described in this section.
    The *displayProcessTimes()* function prints the message supplied by the caller,
    and then uses *clock()* and *times()* to retrieve and display process times. The
    main program makes an initial call to *displayProcessTimes()*, and then executes
    a loop that consumes some CPU time by repeatedly calling *getppid()*, before again
    calling *displayProcessTimes()* once more to see how much CPU time has been consumed
    within the loop. When we use this program to call *getppid()* 10 million times,
    this is what we see:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例10-5](ch10.html#retrieving_process_cpu_times "示例10-5. 检索进程CPU时间")中的程序演示了本节中描述的函数的使用。*displayProcessTimes()*函数打印调用者提供的消息，然后使用*clock()*和*times()*来检索并显示进程时间。主程序首先调用*displayProcessTimes()*，然后执行一个循环，通过重复调用*getppid()*来消耗一些CPU时间，接着再次调用*displayProcessTimes()*来查看循环中消耗了多少CPU时间。当我们使用这个程序调用*getppid()*
    1000万次时，结果如下所示：'
- en: '[PRE37]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Example 10-5. Retrieving process CPU times
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 示例10-5. 检索进程CPU时间
- en: '[PRE38]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概要
- en: Real time corresponds to the everyday definition of time. When real time is
    measured from some standard point, we refer to it as calendar time, by contrast
    with elapsed time, which is measured from some point (usually the start) in the
    life of a process.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 实时时间对应于日常定义的时间。当实时时间从某个标准时间点开始计算时，我们称之为日历时间，与从进程生命周期中的某一点（通常是开始点）测量的经过时间相对。
- en: Process time is the amount of CPU time used by a process, and is divided into
    user and system components.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 进程时间是进程使用的CPU时间量，分为用户和系统组件。
- en: Various system calls enable us to get and set the system clock value (i.e.,
    calendar time, as measured in seconds since the Epoch), and a range of library
    functions allow conversions between calendar time and other time formats, including
    broken-down time and human-readable character strings. Describing such conversions
    took us into a discussion of locales and internationalization.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 各种系统调用使我们能够获取和设置系统时钟值（即从纪元开始计算的日历时间，以秒为单位），而一系列库函数允许在日历时间和其他时间格式之间进行转换，包括分解时间和人类可读的字符字符串。描述这些转换将我们引入了关于区域设置和国际化的讨论。
- en: Using and displaying times and dates is an important part of many applications,
    and we’ll make frequent use of the functions described in this chapter in later
    parts of this book. We also say a little more about the measurement of time in
    [Chapter 23](ch23.html "Chapter 23. Timers and Sleeping").
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用和显示时间与日期是许多应用程序中重要的一部分，我们将在本书后续部分频繁使用本章中描述的函数。我们还会在[第23章](ch23.html "第23章.
    定时器与睡眠")中进一步介绍时间测量的内容。
- en: Further information
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多信息
- en: Details of how the Linux kernel measures time can be found in [Love, 2010].
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Linux内核如何测量时间的详细信息可以参考[Love, 2010]。
- en: An extensive discussion of timezones and internationalization can be found in
    the GNU C library manual (online at [http://www.gnu.org/](http://www.gnu.org/)).
    The SUSv3 documents also cover locales in detail.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 关于时区和国际化的详细讨论可以在GNU C库手册中找到（在线地址：[http://www.gnu.org/](http://www.gnu.org/)）。SUSv3文档也详细介绍了区域设置。
- en: Exercise
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Assume a system where the value returned by the call *sysconf(_SC_CLK_TCK)*
    is 100\. Assuming that the *clock_t* value returned by *times()* is an unsigned
    32-bit integer, how long will it take before this value cycles so that it restarts
    at 0? Perform the same calculation for the `CLOCKS_PER_SEC` value returned by
    *clock()*.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设一个系统，其中调用*sysconf(_SC_CLK_TCK)*返回的值为100。假设*times()*返回的*clock_t*值是一个无符号32位整数，多久之后这个值会循环并重新从0开始？对*clock()*返回的`CLOCKS_PER_SEC`值进行相同的计算。
