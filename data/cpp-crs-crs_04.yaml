- en: '**2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2'
- en: TYPES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型**'
- en: '*Hardin once said, “To succeed, planning alone is insufficient. One must improvise
    as well.” I’ll improvise.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*哈丁曾说过：“成功仅靠计划是不够的，还必须即兴发挥。”我会即兴发挥。'
- en: —Isaac Asimov,* Foundation
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —艾萨克·阿西莫夫，《基地》
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: As discussed in [Chapter 1](ch01.xhtml#ch01), a type declares how an object
    will be interpreted and used by the compiler. Every object in a C++ program has
    a type. This chapter begins with a thorough discussion of fundamental types and
    then introduces user-defined types. Along the way, you’ll learn about several
    control flow structures.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](ch01.xhtml#ch01)所述，类型声明了编译器如何解释和使用一个对象。在C++程序中，每个对象都有一个类型。本章首先对基本类型进行详细讨论，然后介绍用户自定义类型。在这个过程中，你将学习到几种控制流结构。
- en: '**Fundamental Types**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**基本类型**'
- en: '*Fundamental types* are the most basic types of object and include integer,
    floating-point, character, Boolean, `byte`, `size_t`, and `void`. Some refer to
    fundamental types as *primitive* or *built-in* types because they’re part of the
    core language and almost always available to you. These types will work on any
    platform, but their features, such as size and memory layout, depend on implementation.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*基本类型*是最基本的对象类型，包括整数、浮点数、字符、布尔值、`byte`、`size_t`和`void`。有些人称这些基本类型为*原始*类型或*内建*类型，因为它们是核心语言的一部分，几乎总是可以使用。这些类型可以在任何平台上使用，但它们的特性，如大小和内存布局，取决于实现。'
- en: Fundamental types strike a balance. On one hand, they try to map a direct relationship
    from C++ construct to computer hardware; on the other hand, they simplify writing
    cross-platform code by allowing a programmer to write code once that works on
    many platforms. The sections that follow provide additional detail about these
    fundamental types.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 基本类型在两者之间取得了平衡。一方面，它们尝试映射C++构造与计算机硬件之间的直接关系；另一方面，它们通过允许程序员编写一次代码并在多个平台上运行，从而简化了跨平台编程。接下来的部分将进一步介绍这些基本类型的细节。
- en: '***Integer Types***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***整型类型***'
- en: 'Integer types store whole numbers: those that you can write without a fractional
    component. The four sizes of integer types are *short int*, *int*, *long int*,
    and *long long int*. Each can be either signed or unsigned. A *signed* variable
    can be positive, negative, or zero, and an *unsigned* variable must be non-negative.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 整型类型存储整数：即那些没有小数部分的数字。整型的四种大小是*short int*、*int*、*long int*和*long long int*。每种类型可以是有符号或无符号的。*有符号*变量可以是正数、负数或零，而*无符号*变量必须是非负数。
- en: 'Integer types are signed and `int` by default, which means you can use the
    following shorthand notations in your programs: `short`, `long`, and `long long`
    rather than `short int`, `long int`, and `long long int`. [Table 2-1](ch02.xhtml#ch02tab01)
    lists all available C++ integer types, whether each is signed or unsigned, the
    size of each (in bytes) across platforms, as well as the format specifier for
    each.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 整型类型默认是有符号的`int`，这意味着你可以在程序中使用以下简写：`short`、`long`和`long long`，而不是`short int`、`long
    int`和`long long int`。[表2-1](ch02.xhtml#ch02tab01)列出了所有可用的C++整型类型，指出每种类型是有符号还是无符号，跨平台时每种类型的大小（以字节为单位），以及每种类型的格式说明符。
- en: '**Table 2-1:** Integer Types, Sizes, and Format Specifiers'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 整型类型、大小和格式说明符'
- en: '| **Type** | **Signed** | **Size in bytes** | **printf format specifier** |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **有符号** | **字节大小** | **printf格式说明符** |'
- en: '| **32-bit OS** | **64-bit OS** |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **32位操作系统** | **64位操作系统** |'
- en: '| **Windows** | **Linux/Mac** | **Windows** | **Linux/Mac** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **Windows** | **Linux/Mac** | **Windows** | **Linux/Mac** |'
- en: '| `Short` | Yes | 2 | 2 | 2 | 2 | `%hd` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `Short` | 是 | 2 | 2 | 2 | 2 | `%hd` |'
- en: '| `unsigned short` | No | 2 | 2 | 2 | 2 | `%hu` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned short` | 否 | 2 | 2 | 2 | 2 | `%hu` |'
- en: '| `int` | Yes | 4 | 4 | 4 | 4 | `%d` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 是 | 4 | 4 | 4 | 4 | `%d` |'
- en: '| `unsigned int` | No | 4 | 4 | 4 | 4 | `%u` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned int` | 否 | 4 | 4 | 4 | 4 | `%u` |'
- en: '| `long` | Yes | 4 | 4 | 4 | 8 | `%ld` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `long` | 是 | 4 | 4 | 4 | 8 | `%ld` |'
- en: '| `unsigned long` | No | 4 | 4 | 4 | 8 | `%lu` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned long` | 否 | 4 | 4 | 4 | 8 | `%lu` |'
- en: '| `long long` | Yes | 8 | 8 | 8 | 8 | `%lld` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `long long` | 是 | 8 | 8 | 8 | 8 | `%lld` |'
- en: '| `unsigned long long` | No | 8 | 8 | 8 | 8 | `%llu` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned long long` | 否 | 8 | 8 | 8 | 8 | `%llu` |'
- en: 'Notice that the integer type sizes vary across platforms: 64-bit Windows and
    Linux/Mac have different sizes for a `long` integer (4 and 8, respectively).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，整型类型的大小在不同平台上有所不同：64位的Windows和Linux/Mac对于`long`整数的大小不同（分别是4和8）。
- en: Usually, a compiler will warn you of a mismatch between format specifier and
    integer type. But you must ensure that the format specifiers are correct when
    you’re using them in `printf` statements. Format specifiers appear here so you
    can print integers to console in examples to follow.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编译器会警告格式说明符和整数类型之间的不匹配。但在使用 `printf` 语句时，你必须确保格式说明符是正确的。这里列出格式说明符，以便在后续的示例中可以将整数打印到控制台。
- en: '**Note**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you want to enforce guaranteed integer sizes, you can use integer types
    in the `<cstdint>` library. For example, if you need a signed integer with exactly
    8, 16, 32, or 64 bits, you could use `int8_t`, `int16_t`, `int32_t`, or `int64_t`.
    You’ll find options for the fastest, smallest, maximum, signed, and unsigned integer
    types to meet your requirements. But because this header is not always available
    in every platform, you should only use `cstdint` types when there is no other
    alternative.*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想强制使用保证的整数大小，可以使用 `<cstdint>` 库中的整数类型。例如，如果你需要一个恰好为 8、16、32 或 64 位的有符号整数，你可以使用
    `int8_t`、`int16_t`、`int32_t` 或 `int64_t`。你可以找到符合要求的最快、最小、最大、有符号和无符号整数类型。但由于并非每个平台都可以使用这个头文件，所以你应仅在没有其他替代方案时使用
    `cstdint` 类型。*'
- en: 'A *literal* is a hardcoded value in a program. You can use one of four hardcoded,
    *integer* *literal* representations:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*字面量* 是程序中的硬编码值。你可以使用四种硬编码的 *整数* *字面量* 表示法：'
- en: '**`binary`** Uses the prefix `0b`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**`二进制`** 使用前缀 `0b`'
- en: '**`octal`** Uses the prefix `0`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**`八进制`** 使用前缀 `0`'
- en: '**`decimal`** This is the default'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**`十进制`** 这是默认值'
- en: '**`hexadecimal`** Uses the prefix `0x`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**`十六进制`** 使用前缀 `0x`'
- en: These are four different ways of writing the same set of whole numbers. For
    example, [Listing 2-1](ch02.xhtml#ch02ex01) shows how you might assign several
    integer variables with integer literals using each of the non-decimal representations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种不同的表示法都用于表示相同的整数集合。例如，[列表 2-1](ch02.xhtml#ch02ex01)展示了如何使用每种非十进制表示法为多个整数变量赋值，并使用整数字面量。
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 2-1: A program that assigns several integer variables and prints them
    with the appropriate format specifier*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-1：一个分配多个整数变量并用适当格式说明符打印它们的程序*'
- en: This program uses each of the non-decimal integer representations (binary ➊,
    octal ➋, and hexadecimal ➌) and prints each with `printf` using the appropriate
    format specifier listed in [Table 2-1](ch02.xhtml#ch02tab01). The output from
    each `printf` appears as a following comment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序使用每种非十进制整数表示法（如二进制 ➊、八进制 ➋ 和十六进制 ➌），并通过 `printf` 打印每个值，使用适当的格式说明符，具体见[表 2-1](ch02.xhtml#ch02tab01)。每个
    `printf` 的输出会作为以下注释出现。
- en: '**NOTE**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Integer literals can contain any number of single quotes ('') for readability.
    These are completely ignored by the compiler. For example, `1000000` and `1''000''000`
    are both integer literals equal to one million.*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*整数字面量可以包含任意数量的单引号（''），以提高可读性。这些单引号会被编译器完全忽略。例如，`1000000` 和 `1''000''000` 都是等于一百万的整数字面量。*'
- en: Sometimes, it’s useful to print an unsigned integer in its hexadecimal representation
    or (rarely) its octal representation. You can use the `printf` specifiers `%x`
    and `%o` for these purposes, respectively, as shown in [Listing 2-2](ch02.xhtml#ch02ex02).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，打印无符号整数的十六进制表示法或（很少）八进制表示法是有用的。你可以分别使用 `printf` 格式说明符 `%x` 和 `%o`，如[列表 2-2](ch02.xhtml#ch02ex02)所示。
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 2-2: A program that uses octal and hexadecimal representations of
    unsigned integers*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-2：一个使用无符号整数的八进制和十六进制表示法的程序*'
- en: The hexadecimal representation of the decimal `3669732608` is `dabbad00`, which
    appears in the first line of output as a result of the hexadecimal format specifier
    `%x` ➊. The decimal 69 is 105 in octal. The format specifiers for unsigned integer
    `%u` ➋ and octal integer `%o` ➌ correspond with the arguments at ➍ and ➎, respectively.
    The `printf` statement substitutes these quantities ➋➌ into the format string,
    yielding the message `There are 69,105 leaves in here`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制 `3669732608` 的十六进制表示为 `dabbad00`，它出现在输出的第一行，作为十六进制格式说明符 `%x` ➊ 的结果。十进制的
    69 在八进制中是 105。无符号整数格式说明符 `%u` ➋ 和八进制整数格式说明符 `%o` ➌ 分别对应于 ➍ 和 ➎ 的参数。`printf` 语句将这些数值
    ➋➌ 替换到格式字符串中，输出信息为 `这里有 69,105 片叶子`。
- en: '**Warning**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*The octal prefix is a holdover from the B language, back in the days of the
    PDP-8 computer and ubiquitous octal literals. C, and by extension C++, continues
    the dubious tradition. You must be careful, for example, when you’re hardcoding
    ZIP codes:*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*八进制前缀源自B语言，当时PDP-8计算机和八进制字面量非常普遍。C语言及其扩展C++延续了这个可疑的传统。你必须小心，例如在硬编码邮政编码时：*'
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Eliminate leading zeros on decimal literals; otherwise, they’ll cease to be
    decimal. This line doesn’t compile because 9 is not an octal digit.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*去掉十进制字面量中的前导零，否则它们将不再是十进制数。这行代码无法编译，因为 9 不是八进制数字。*'
- en: 'By default, an integer literal’s type is one of the following: `int`, `long`,
    or `long long`. An integer literal’s type is the smallest of these three types
    that fits. (This is defined by the language and will be enforced by the compiler.)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，整数字面量的类型是以下之一：`int`、`long` 或 `long long`。整数字面量的类型是这三种类型中最小的那一个。（这是由语言定义的，并会由编译器强制执行。）
- en: 'If you want more control, you can supply *suffixes* to an integer literal to
    specify its type (suffixes are case insensitive, so you can choose the style you
    like best):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更多控制，可以为整数字面量提供*后缀*来指定其类型（后缀不区分大小写，因此你可以选择自己喜欢的样式）：
- en: The `unsigned` suffix `u` or `U`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsigned` 后缀 `u` 或 `U`'
- en: The `long` suffix `l` or `L`
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long` 后缀 `l` 或 `L`'
- en: The `long long` suffix `ll` or `LL`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long long` 后缀 `ll` 或 `LL`'
- en: You can combine the `unsigned` suffix with either the `long` or the `long long`
    suffix to specify signed-ness and size. [Table 2-2](ch02.xhtml#ch02tab02) shows
    the possible types that a suffix combination can take. Allowed types are shown
    with a check mark (✓). For binary, octal, and hexadecimal literals, you can omit
    the `u` or `U` suffix. These are depicted with an asterisk (*).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `unsigned` 后缀与 `long` 或 `long long` 后缀结合使用，以指定符号性和大小。[表 2-2](ch02.xhtml#ch02tab02)
    显示了后缀组合可能的类型。允许的类型用勾号（✓）表示。对于二进制、八进制和十六进制字面量，你可以省略 `u` 或 `U` 后缀。这些用星号（*）表示。
- en: '**Table 2-2:** Integer Suffixes'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-2：** 整数后缀'
- en: '| **Type** | **(none)** | **l/L** | **ll/LL** | **u/U** | **ul/UL** | **ull/ULL**
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **(无)** | **l/L** | **ll/LL** | **u/U** | **ul/UL** | **ull/ULL**
    |'
- en: '| `int` | ✓ |  |  |  |  |  |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `int` | ✓ |  |  |  |  |  |'
- en: '| `long` | ✓ | ✓ |  |  |  |  |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `long` | ✓ | ✓ |  |  |  |  |'
- en: '| `long long` | ✓ | ✓ | ✓ |  |  |  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `long long` | ✓ | ✓ | ✓ |  |  |  |'
- en: '| `unsigned int` | * |  |  | ✓ |  |  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned int` | * |  |  | ✓ |  |  |'
- en: '| `unsigned long` | * | * |  | ✓ | ✓ |  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned long` | * | * |  | ✓ | ✓ |  |'
- en: '| `unsigned long long` | * | * | * | ✓ | ✓ | ✓ |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned long long` | * | * | * | ✓ | ✓ | ✓ |'
- en: The smallest allowed type that still fits the integer literal is the resulting
    type. This means that among all types allowed for a particular integer, the smallest
    type will apply. For example, the integer literal `112114` could be an `int`,
    a `long`, or a `long long`. Since an `int` can store 112114, the resulting integer
    literal is an `int`. If you really want, say, a `long`, you can instead specify
    `112114L` (or `112114l`).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最小允许的类型仍然适应整数字面量的类型即为结果类型。这意味着，在所有允许的类型中，最小的类型将适用。例如，整数字面量 `112114` 可以是 `int`、`long`
    或 `long long`。由于 `int` 可以存储 112114，因此结果类型是 `int`。如果你真的希望使用 `long`，你可以指定 `112114L`（或
    `112114l`）。
- en: '***Floating-Point Types***'
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***浮点类型***'
- en: Floating-point types store approximations of real numbers (which in our case
    can be defined as any number that has a decimal point and a fractional part, such
    as 0.33333 or 98.6). Although it’s not possible to represent an arbitrary real
    number exactly in computer memory, it’s possible to store an approximation. If
    this seems hard to believe, just think of a number like π, which has infinitely
    many digits. With finite computer memory, how could you possibly represent infinitely
    many digits?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点类型存储的是实数的近似值（在我们的定义中，实数可以是任何有小数点和分数部分的数字，例如 0.33333 或 98.6）。虽然无法在计算机内存中精确表示任意实数，但可以存储一个近似值。如果这让你难以相信，只需想一想像
    π 这样的数字，它有无限多的位数。考虑到计算机内存是有限的，你怎么可能表示无限多的位数呢？
- en: 'As with all types, floating-point types take up a finite amount of memory,
    which is called the type’s *precision*. The more precision a floating-point type
    has, the more accurate it will be at approximating a real number. C++ offers three
    levels of precision for approximations:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有类型一样，浮点类型占用有限的内存，这被称为类型的*精度*。浮点类型的精度越高，近似实数时就越准确。C++ 提供了三种精度级别的近似：
- en: '`**float**` single precision'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`**float**` 单精度'
- en: '`**double**` double precision'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`**double**` 双精度'
- en: '`**long double**` extended precision'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`**long double**` 扩展精度'
- en: As with integer types, each floating-point representation depends on implementation.
    This section won’t go into detail about floating-point types, but note that there
    is substantial nuance involved in these implementations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与整数类型一样，每种浮点数表示方式都依赖于实现。此部分不会详细讨论浮点类型，但请注意，这些实现中有许多细微差别。
- en: On major desktop operating systems, the `float` level usually has 4 bytes of
    precision. The `double` and `long double` levels usually have 8 bytes of precision
    (*double precision*).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在主要的桌面操作系统中，`float`类型通常有4字节的精度。`double`和`long double`类型通常有8字节的精度（*双精度*）。
- en: Most users not involved in scientific computing applications can safely ignore
    the details of floating-point representation. In such cases, a good general rule
    is to use a `double`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数不涉及科学计算应用的用户可以放心忽略浮点表示的细节。在这种情况下，一个好的通用规则是使用`double`。
- en: '**NOTE**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For those who cannot safely ignore the details, look at the floating-point
    specification relevant to your hardware platform. The predominant implementation
    of floating-point storage and arithmetic is outlined in* The IEEE Standard for
    Floating-Point Arithmetic, IEEE 754.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于那些无法忽略细节的用户，请查看与你的硬件平台相关的浮点规格。浮点存储和算术的主要实现概述在* IEEE 浮点运算标准 IEEE 754中。'
- en: '**Floating-Point Literals**'
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**浮点字面量**'
- en: 'Floating-point literals are double precision by default. If you need single
    precision, use an `f` or `F` suffix; for extended precision, use `l` or `L`, as
    shown here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点字面量默认是双精度。如果需要单精度，使用`f`或`F`后缀；要使用扩展精度，使用`l`或`L`后缀，如下所示：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also use scientific notation in literals:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在字面量中使用科学计数法：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: No spaces are permitted between the *significand* (the base ➊) and the *suffix*
    (the exponential portion ➋).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不允许在*有效数字*（基数➊）和*后缀*（指数部分➋）之间有空格。
- en: '**Floating-Point Format Specifiers**'
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**浮点格式说明符**'
- en: The format specifier `%f` displays a `float` with decimal digits, whereas `%e`
    displays the same number in scientific notation. You can let `printf` decide which
    of these two to use with the `%g` format specifier, which selects the more compact
    of `%e` or `%f`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 格式说明符`%f`显示带有小数位的`float`，而`%e`则以科学计数法显示相同的数字。你可以让`printf`决定使用这两者中的哪一个，使用`%g`格式说明符，它选择`%e`或`%f`中更紧凑的一个。
- en: For `double`, you simply prepend an `l` (lowercase *L*) to the desired specifier;
    for `long double`, prepend an `L`. For example, if you wanted a `double` with
    decimal digits, you would specify `%lf`, `%le`, or `%lg`; for a long double, you
    would specify `%Lf`, `%Le`, or `%Lg`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`double`，只需在所需的说明符前添加`l`（小写*L*）；对于`long double`，则添加`L`。例如，如果你想要一个带有小数位的`double`，你可以指定`%lf`、`%le`或`%lg`；对于`long
    double`，则指定`%Lf`、`%Le`或`%Lg`。
- en: Consider [Listing 2-3](ch02.xhtml#ch02ex03), which explores the different options
    for printing floating points.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[列出 2-3](ch02.xhtml#ch02ex03)，该示例探讨了打印浮点数的不同选项。
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 2-3: A program printing several floating points*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 2-3：一个打印多个浮点数的程序*'
- en: This program declares a `double` called `an` ➊. The format specifier `%le` ➋
    gives you scientific notation `6.022141e-23`, and `%lf` ➌ gives the decimal representation
    `602214090000000006225920.000000`. The `%lg` ➍ specifier chose the scientific
    notation `6.02214e-23`. The `float` called `hp` ➎ produces similar `printf` output
    using the `%e` and `%f` specifiers. But the format specifier `%g` decided to provide
    the decimal representation 9.75 rather than scientific notation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本程序声明了一个名为`an`的`double` ➊。格式说明符`%le` ➋ 给出科学计数法`6.022141e-23`，而`%lf` ➌ 给出了十进制表示`602214090000000006225920.000000`。`%lg`
    ➍ 说明符选择了科学计数法`6.02214e-23`。名为`hp`的`float` ➎ 使用`%e`和`%f`说明符产生类似的`printf`输出。但格式说明符`%g`决定提供十进制表示9.75，而不是科学计数法。
- en: As a general rule, use `%g` to print floating-point types.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，使用`%g`来打印浮点类型。
- en: '**NOTE**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In practice, you can omit the `l` prefix on the format specifiers for `double`,
    because `printf` promotes `float` arguments to `double` precision.*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*实际上，你可以省略`double`格式说明符前的`l`前缀，因为`printf`会将`float`类型的参数提升为`double`精度。*'
- en: '***Character Types***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字符类型***'
- en: 'Character types store human language data. The six character types are:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类型用于存储人类语言数据。六种字符类型包括：
- en: '`**char**` The default type, always 1 byte. May or may not be signed. (Example:
    ASCII.)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`**char**` 默认类型，始终为1字节。可能是有符号也可能是无符号。（示例：ASCII。）'
- en: '`**char16_t**` Used for 2-byte character sets. (Example: UTF-16.)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`**char16_t**` 用于2字节字符集。（示例：UTF-16。）'
- en: '`**char32_t**` Used for 4-byte character sets. (Example: UTF-32.)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`**char32_t**` 用于4字节字符集。（示例：UTF-32。）'
- en: '`**signed char**` Same as `char` but guaranteed to be signed.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`**signed char**` 与`char`相同，但保证为有符号。'
- en: '`**unsigned char**` Same as `char` but guaranteed to be unsigned.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`**unsigned char**` 与`char`相同，但保证为无符号。'
- en: '`**wchar_t**` Large enough to contain the largest character of the implementation’s
    locale. (Example: Unicode.)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`**wchar_t**` 大到足以容纳实现区域中最大字符。（示例：Unicode。）'
- en: The character types `char`, `signed char`, and `unsigned char` are called *narrow
    characters*, whereas `char16_t`, `char32_t`, and `wchar_t` are called *wide characters*
    due to their relative storage requirements.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`char`、`signed char` 和 `unsigned char` 被称为*窄字符*，而 `char16_t`、`char32_t` 和 `wchar_t`
    被称为*宽字符*，这是由于它们相对的存储需求。'
- en: '**Character Literals**'
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符常量**'
- en: 'A *character literal* is a single, constant character. Single quotation marks
    (`'' ''`) surround all characters. If the character is any type but `char`, you
    must also provide a prefix: `L` for `wchar_t`, `u` for `char16_t`, and `U` for
    `char32_t`. For example, `''J''` declares a `char` literal and `L''J''` declares
    a `wchar_t`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符常量* 是单个常量字符。所有字符都被单引号（`'' ''`）括起来。如果字符不是 `char` 类型，你还必须提供一个前缀：`L` 表示 `wchar_t`，`u`
    表示 `char16_t`，`U` 表示 `char32_t`。例如，`''J''` 声明了一个 `char` 常量，而 `L''J''` 声明了一个 `wchar_t`
    常量。'
- en: '**Escape Sequences**'
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**转义序列**'
- en: Some characters don’t display on the screen. Instead, they force the display
    to do things like move the cursor to the left side of the screen (carriage return)
    or move the cursor down one line (newline). Other characters can display onscreen,
    but they’re part of the C++ language syntax, such as single or double quotes,
    so you must use them very carefully. To put these characters into a `char`, you
    use the *escape sequences*, as listed in [Table 2-3](ch02.xhtml#ch02tab03).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有些字符不会在屏幕上显示。相反，它们会强制显示执行一些操作，比如将光标移动到屏幕左侧（回车符）或将光标向下移动一行（换行符）。其他字符虽然会显示在屏幕上，但它们是
    C++ 语言语法的一部分，如单引号或双引号，因此你必须非常小心地使用它们。为了将这些字符放入 `char` 中，你可以使用 *转义序列*，如 [表 2-3](ch02.xhtml#ch02tab03)
    中所列。
- en: '**Table 2-3:** Reserved Characters and Their Escape Sequences'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-3：** 保留字符及其转义序列'
- en: '| **Value** | **Escape sequence** |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **值** | **转义序列** |'
- en: '| Newline | `\n` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 换行符 | `\n` |'
- en: '| Tab (horizontal) | `\t` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 水平制表符 | `\t` |'
- en: '| Tab (vertical) | `\v` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 垂直制表符 | `\v` |'
- en: '| Backspace | `\b` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 退格符 | `\b` |'
- en: '| Carriage return | `\r` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 回车符 | `\r` |'
- en: '| Form feed | `\f` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 换页符 | `\f` |'
- en: '| Alert | `\a` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 响铃符 | `\a` |'
- en: '| Backslash | `\\` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 反斜杠 | `\\` |'
- en: '| Question mark | `?` or `\?` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 问号 | `?` 或 `\?` |'
- en: '| Single quote | `\''` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 单引号 | `\''` |'
- en: '| Double quote | `\"` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 双引号 | `\"` |'
- en: '| The null character | `\0` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 空字符 | `\0` |'
- en: '**Unicode Escape Characters**'
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Unicode 转义字符**'
- en: 'You can specify Unicode character literals using the *universal character names*,
    and you can form a universal character name in one of two ways: the prefix `\u`
    followed by a 4-digit Unicode code point or the prefix `\U` followed by an 8-digit
    Unicode code point. For example, you can represent the `A` character as `''\u0041''`
    and represent the beer mug character ![Image](../images/fig38_1.jpg) as `U''\U0001F37A''`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 *通用字符名称* 来指定 Unicode 字符常量，并且你可以通过两种方式来形成通用字符名称：前缀 `\u` 后跟 4 位十六进制 Unicode
    码点，或者前缀 `\U` 后跟 8 位十六进制 Unicode 码点。例如，你可以将字符 `A` 表示为 `'\u0041'`，将啤酒杯字符 ![Image](../images/fig38_1.jpg)
    表示为 `U'\U0001F37A'`。
- en: '**Format Specifiers**'
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**格式说明符**'
- en: The `printf` format specifier for `char` is `%c`. The `wchar_t` format specifier
    is `%lc`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`char` 的 `printf` 格式说明符是 `%c`。`wchar_t` 的格式说明符是 `%lc`。'
- en: '[Listing 2-4](ch02.xhtml#ch02ex04) initializes two character literals, `x`
    and `y`. You use these variables to build a `printf` call.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-4](ch02.xhtml#ch02ex04) 初始化了两个字符常量 `x` 和 `y`。你可以使用这些变量来构建 `printf` 调用。'
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 2-4: A program that assigns several character-typed variables and
    prints them*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-4：一个程序，赋值给多个字符类型的变量并打印它们*'
- en: This program outputs *Windows binaries start with MZ*. Even though the *M* is
    a narrow character `char` and the *Z* is a wide character, `printf` works because
    the program uses the correct format specifiers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序输出 *Windows 二进制文件以 MZ 开头*。尽管 *M* 是窄字符 `char`，而 *Z* 是宽字符，但 `printf` 可以正常工作，因为程序使用了正确的格式说明符。
- en: '**NOTE**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The first two bytes of all Windows binaries are the characters M and Z, an
    homage to Mark Zbikowski, the designer of the MS-DOS executable binary file format*.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有 Windows 二进制文件的前两个字节是字符 M 和 Z，这是对 MS-DOS 可执行文件格式设计者 Mark Zbikowski 的致敬*。'
- en: '***Boolean Types***'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***布尔类型***'
- en: 'Boolean types have two states: true and false. The sole Boolean type is `bool`.
    Integer types and the `bool` types convert readily: the `true` state converts
    to 1, and `false` converts to 0\. Any non-zero integer converts to true, and 0
    converts to `false`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔类型有两种状态：真（true）和假（false）。唯一的布尔类型是 `bool`。整数类型和 `bool` 类型可以方便地进行转换：`true` 状态转换为
    1，`false` 转换为 0。任何非零整数都转换为 true，0 转换为 `false`。
- en: '**Boolean Literals**'
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**布尔常量**'
- en: To initialize Boolean types, you use two Boolean literals, `true` and `false`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化布尔类型，你可以使用两个布尔常量：`true` 和 `false`。
- en: '**Format Specifiers**'
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**格式说明符**'
- en: There is no format specifier for `bool`, but you can use the `int` format specifier
    `%d` within `printf` to yield a `1` for true and a `0` for false. The reason is
    that `printf` promotes any integral value smaller than an `int` to an `int`. [Listing
    2-5](ch02.xhtml#ch02ex05) illustrates how to declare a Boolean variable and inspect
    its value.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool` 类型没有格式说明符，但你可以在 `printf` 中使用 `int` 格式说明符 `%d` 来输出 `true` 为 `1`，`false`
    为 `0`。原因是 `printf` 会将任何小于 `int` 的整型值提升为 `int`。[列表 2-5](ch02.xhtml#ch02ex05)展示了如何声明一个布尔变量并检查其值。'
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 2-5: Printing `bool` variables with a `printf` statement*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-5：使用 `printf` 语句打印 `bool` 变量*'
- en: You initialize `b1` to `true` ➊ and `b2` to `false` ➋. By printing `b1` and
    `b2` as integers (using `%d` format specifiers), you get 1 for `b1` and 0 for
    `b2` ➌.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你将 `b1` 初始化为 `true` ➊，将 `b2` 初始化为 `false` ➋。通过将 `b1` 和 `b2` 作为整数打印（使用 `%d` 格式说明符），你会得到
    `b1` 为 1，`b2` 为 0 ➌。
- en: '**Comparison Operators**'
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**比较运算符**'
- en: '*Operators* are functions that perform computations on *operands*. Operands
    are simply objects. (“Logical Operators” on [page 182](ch07.xhtml#page_182) covers
    a full menu of operators.) In order to have meaningful examples using `bool` types,
    you’ll take a quick look at comparison operators in this section and logical operators
    in the next.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*运算符* 是对 *操作数* 执行计算的函数。操作数只是对象。（关于运算符的详细内容请参考 [第 182 页](ch07.xhtml#page_182)的“逻辑运算符”部分。）为了能够使用
    `bool` 类型给出有意义的示例，你将在本节快速了解比较运算符，在下一节了解逻辑运算符。'
- en: You can use several operators to build Boolean expressions. Recall that comparison
    operators take two arguments and return a `bool`. The available operators are
    equality (`==`), inequality (`!=`), greater than (`>`), less than (`<`), greater
    than or equal to (`>=`), and less than or equal to (`<=`).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用多个运算符来构建布尔表达式。回忆一下，比较运算符接受两个参数并返回一个 `bool`。可用的运算符有相等（`==`）、不等（`!=`）、大于（`>`）、小于（`<`）、大于或等于（`>=`）以及小于或等于（`<=`）。
- en: '[Listing 2-6](ch02.xhtml#ch02ex06) shows how you can use these operators to
    produce Booleans.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-6](ch02.xhtml#ch02ex06)展示了如何使用这些运算符来产生布尔值。'
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 2-6: Using comparison operators*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-6：使用比较运算符*'
- en: Each comparison produces a Boolean result ➋, and the `printf` statement prints
    the Boolean as an `int` ➊.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 每个比较产生一个布尔结果 ➋，并且 `printf` 语句将布尔值打印为 `int` ➊。
- en: '**Logical Operators**'
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**逻辑运算符**'
- en: '*Logical operators* evaluate Boolean logic on `bool` types. You characterize
    operators by how many operands they take. A *unary operator* takes a single operand,
    a *binary operator* takes two, a *ternary operator* takes three, and so on. You
    categorize operators further by describing the types of their operands.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*逻辑运算符* 对 `bool` 类型的布尔逻辑进行求值。你可以通过它们需要的操作数个数来分类运算符。*一元运算符* 需要一个操作数，*二元运算符*
    需要两个，*三元运算符* 需要三个，以此类推。你还可以通过描述它们操作数的类型进一步对运算符进行分类。'
- en: The unary *negation* operator (`!`) takes a single operand and returns its opposite.
    In other words, `!true` yields `false`, and `!false` yields `true`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一元 *取反* 运算符（`!`）接受一个操作数并返回其相反值。换句话说，`!true` 得到 `false`，而 `!false` 得到 `true`。
- en: The logical operators AND (`&&`) and OR (`||`) are binary. Logical AND returns
    `true` only if both of its operands are `true`. Logical OR returns `true` if either
    or both of its operands are `true`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符与（`&&`）和或（`||`）是二元运算符。逻辑与仅在两个操作数都为 `true` 时返回 `true`。逻辑或只要任一操作数为 `true`
    就返回 `true`。
- en: '**NOTE**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When you’re reading a Boolean expression, the `!` is pronounced “not,” as
    in “a and not b” for the expression `a && !b`*.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你读取布尔表达式时，`!` 读作“非”，例如“a 且 非 b”表示表达式 `a && !b`*。'
- en: Logical operators might seem confusing at first, but they quickly become intuitive.
    [Listing 2-7](ch02.xhtml#ch02ex07) showcases the logical operators.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符刚开始可能看起来让人困惑，但它们很快就变得直观。[列表 2-7](ch02.xhtml#ch02ex07)展示了逻辑运算符的用法。
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 2-7: A program that illustrates the use of logical operators*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-7：展示使用逻辑运算符的程序*'
- en: Here, you see the negation operator ➊, the logical AND operator ➋➌, and the
    logical OR operator ➍➎.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到取反运算符 ➊、逻辑与运算符 ➋➌ 和逻辑或运算符 ➍➎。
- en: '***The std::byte Type***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***std::byte 类型***'
- en: System programmers sometimes work directly with *raw memory*, which is a collection
    of bits without a type. Employ the `std::byte` type, available in the `<cstddef>`
    header, in such situations. The `std::byte` type permits bitwise logical operations
    (which you’ll meet in [Chapter 7](ch07.xhtml#ch07)) and little else. Using this
    type for raw data rather than an integral type can help to avoid common sources
    of difficult-to-debug programming errors.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 系统程序员有时需要直接处理*原始内存*，它是没有类型的位的集合。在这种情况下，使用`std::byte`类型，该类型可以在`<cstddef>`头文件中找到。`std::byte`类型允许进行按位逻辑运算（你将在[第7章](ch07.xhtml#ch07)中遇到这些），除此之外几乎没有其他功能。将此类型用于原始数据而不是整型可以帮助避免常见的难以调试的编程错误。
- en: Note that unlike most other fundamental types in `<cstddef>`, `std::byte` doesn’t
    have an exact corollary type in the C language (a “C type”). Like C++, C has `char`
    and `unsigned char`. These types are less safe to use because they support many
    operations that `std::byte` doesn’t. For example, you can perform arithmetic,
    like addition (`+`), on a `char` but not a `std::byte`. The odd-looking `std::`
    prefix is called a *namespace*, which you’ll meet in “Namespaces” on [page 216](ch08.xhtml#page_216)
    (for now, just think of the namespace `std::` as part of the type name).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与`<cstddef>`中的大多数其他基本类型不同，`std::byte`在C语言中没有完全对应的类型（即“C类型”）。像C++一样，C语言有`char`和`unsigned
    char`。这些类型使用起来不那么安全，因为它们支持许多`std::byte`不支持的操作。例如，你可以对`char`执行算术运算（如加法`+`），但不能对`std::byte`执行类似的操作。奇怪的`std::`前缀称为*命名空间*，你将在“命名空间”一节中了解更多内容（见[第216页](ch08.xhtml#page_216)）（现在，暂时将命名空间`std::`视为类型名称的一部分）。
- en: '**NOTE**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There are two schools of thought on how to pronounce *std*. One is to treat
    it as an initialism, as in “ess-tee-dee,” and another is to treat it as an acronym,
    as in “stood.” When referring to a class in the `std` namespace, speakers typically
    imply the namespace operator `::`. So you could pronounce `std::byte` as “stood
    byte” or, if you’re not into the whole brevity thing, as “ess-tee-dee colon colon
    byte.”*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*关于如何发音*std*有两种观点。一种是将其视为首字母缩略词，发音为“ess-tee-dee”；另一种是将其视为首字母缩写，发音为“stood”。当提到`std`命名空间中的类时，通常会隐含命名空间运算符`::`。所以你可以将`std::byte`发音为“stood
    byte”，或者，如果你不喜欢简洁的表达方式，可以发音为“ess-tee-dee colon colon byte”。*'
- en: '***The size_t Type***'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***size_t 类型***'
- en: You use the `size_t` type, also available in the `<cstddef>` header, to encode
    size of objects. The `size_t` objects guarantee that their maximum values are
    sufficient to represent the maximum size in bytes of all objects. Technically,
    this means a `size_t` could take 2 bytes or 200 bytes depending on the implementation.
    In practice, it’s usually identical to an `unsigned long long` on 64-bit architectures.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`size_t`类型，该类型也可以在`<cstddef>`头文件中找到，用来编码对象的大小。`size_t`对象保证它们的最大值足以表示所有对象的最大字节数。从技术上讲，这意味着`size_t`可能占用2个字节或200个字节，具体取决于实现。在实践中，它通常与64位架构上的`unsigned
    long long`相同。
- en: '**NOTE**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The type `size_t` is a C type in the C library header, but it’s identical
    to the C++ version, which resides in the `std` namespace. Occasionally, you’ll
    see the (technically correct) construction `std::size_t` instead.*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*`size_t`类型是C库头文件中的C类型，但它与C++版本相同，后者位于`std`命名空间中。有时，你会看到（技术上正确的）构造`std::size_t`。*'
- en: '**sizeof**'
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**sizeof**'
- en: The unary operator `sizeof` takes a type operand and returns the size (in bytes)
    of that type. The `sizeof` operator always returns a `size_t`. For example, `sizeof(float)`
    returns the number of bytes of storage a `float` takes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一元运算符`sizeof`接受一个类型操作数，并返回该类型的大小（以字节为单位）。`sizeof`运算符始终返回一个`size_t`。例如，`sizeof(float)`返回`float`类型所占的字节数。
- en: '**Format Specifiers**'
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**格式说明符**'
- en: The usual format specifiers for a `size_t` are `%zu` for a decimal representation
    or `%zx` for a hexadecimal representation. [Listing 2-8](ch02.xhtml#ch02ex08)
    shows how you might check a system for several integer types’ sizes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`size_t`的常用格式说明符是`%zu`（用于十进制表示）或`%zx`（用于十六进制表示）。[列表2-8](ch02.xhtml#ch02ex08)展示了你如何检查系统上多个整数类型的大小。'
- en: '[PRE10]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 2-8: A program that prints the sizes in bytes of several integer types.
    (The output comes from a Windows 10 x64 machine.)*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表2-8：一个打印多个整数类型字节大小的程序。（输出来自Windows 10 x64机器。）*'
- en: '[Listing 2-8](ch02.xhtml#ch02ex08) evaluates the `sizeof` a `char` ➊, a `short`
    ➋, an `int` ➌, a `long` ➍, and a `long long` ➎ and prints their sizes using the
    `%zu` format specifier. Results will vary depending on the operating system. Recall
    from [Table 2-1](ch02.xhtml#ch02tab01) that each environment defines its own sizes
    for the integer types. Pay special attention to the return value of `long` in
    [Listing 2-8](ch02.xhtml#ch02ex08); Linux and macOS define 8-byte `long` types.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-8](ch02.xhtml#ch02ex08)评估`char` ➊、`short` ➋、`int` ➌、`long` ➍和`long long`
    ➎的`sizeof`，并使用`%zu`格式说明符打印它们的大小。结果将根据操作系统有所不同。回想一下[表 2-1](ch02.xhtml#ch02tab01)，每个环境定义了其自身的整数类型大小。特别注意[清单
    2-8](ch02.xhtml#ch02ex08)中`long`类型的返回值；Linux和macOS定义了8字节的`long`类型。'
- en: '***void***'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***void***'
- en: 'The `void` type has an empty set of values. Because a `void` object cannot
    hold a value, C++ disallows void objects. You use `void` in special situations,
    such as the return type for functions that don’t return any value. For example,
    the function `taunt` doesn’t return a value, so you declare its return type `void`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`void`类型没有值的集合。因为`void`对象不能保存任何值，所以C++不允许使用`void`对象。你在特殊情况下使用`void`，例如用于没有返回值的函数的返回类型。例如，`taunt`函数不返回任何值，因此它的返回类型声明为`void`：'
- en: '[PRE11]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In [Chapter 3](ch03.xhtml#ch03), you’ll learn about other special `void` uses.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.xhtml#ch03)中，你将学习其他`void`类型的特殊用途。
- en: '**Arrays**'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数组**'
- en: 'Arrays are sequences of identically typed variables. *Array types* include
    the contained type and the number of contained elements. You weave this information
    together in the declaration syntax: the element type precedes square brackets
    enclosing the array’s size.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是具有相同类型变量的序列。*数组类型*包括元素类型和包含的元素数量。你可以将这些信息结合在一起，通过声明语法来表示：元素类型位于方括号前，方括号内包含数组的大小。
- en: 'For example, the following line declares an array of 100 `int` objects:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面一行声明了一个包含100个`int`对象的数组：
- en: '[PRE12]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***Array Initialization***'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数组初始化***'
- en: 'There’s a shortcut for initializing arrays with values using braces:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个简便的方法可以用花括号初始化数组的值：
- en: '[PRE13]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can omit the length of the array because it can be inferred from the number
    of elements in the braces at compile time.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以省略数组的长度，因为它可以根据花括号内的元素数量在编译时推断出来。
- en: '***Accessing Array Elements***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***访问数组元素***'
- en: You access array elements by using square brackets to enclose the desired index.
    Array indexing is zero based in C++, so the first element is at index `0`, the
    tenth element is at index `9`, and so on. [Listing 2-9](ch02.xhtml#ch02ex09) illustrates
    reading and writing array elements.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用方括号来访问数组元素，方括号中包含所需的索引。在C++中，数组索引是从0开始的，因此第一个元素位于索引`0`，第十个元素位于索引`9`，依此类推。[清单
    2-9](ch02.xhtml#ch02ex09)演示了如何读取和写入数组元素。
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 2-9: A program that indexes into an array*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-9：一个索引数组的程序*'
- en: This code declares a four-element array named `arr` containing the elements
    `1`, `2`, `3`, and `4` ➊. On the next line ➋, it prints the third element. It
    then assigns the third element to 100 ➌, so when it reprints the third element
    ➍, the value is `100`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码声明了一个名为`arr`的四元素数组，包含元素`1`、`2`、`3`和`4` ➊。在下一行 ➋，它打印第三个元素。然后，它将第三个元素赋值为100
    ➌，所以当它重新打印第三个元素 ➍时，值为`100`。
- en: '***A Nickel Tour of for Loops***'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***for 循环概览***'
- en: 'A `for` loop lets you repeat (or iterate) the execution of a statement a specified
    number of times. You can stipulate a starting point and other conditions. The
    *init statement* executes before the first iteration executes, so you can initialize
    variables used in the `for` loop. The *conditional* is an expression that is evaluated
    before each iteration. If it evaluates to `true`, iteration proceeds. If `false`,
    the `for` loop terminates. The *iteration statement* executes after each iteration,
    which is useful in situations where you must increment a variable to cover a range
    of values. The `for` loop syntax is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环让你重复（或迭代）执行语句指定次数。你可以规定一个起始点和其他条件。*初始化语句*在第一次迭代之前执行，因此你可以在`for`循环中初始化使用的变量。*条件表达式*是在每次迭代之前评估的表达式。如果它的结果为`true`，则继续迭代。如果为`false`，则`for`循环终止。*迭代语句*在每次迭代后执行，当你需要增加变量以覆盖一系列值时，这很有用。`for`循环的语法如下：'
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For example, [Listing 2-10](ch02.xhtml#ch02ex10) shows you how to use a `for`
    loop to find the maximum of an array.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[清单 2-10](ch02.xhtml#ch02ex10)展示了如何使用`for`循环查找数组中的最大值。
- en: '[PRE16]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 2-10: Finding the maximum value contained in an array*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-10：查找数组中包含的最大值*'
- en: You initialize `maximum` ➊ to the smallest value possible; here that’s 0 because
    it’s unsigned. Next, you initialize the array `values` ➋, which you iterate over
    using the `for` loop ➌. The iterator variable `i` ranges from 0 to 4 inclusive.
    Within the `for` loop, you access each element of `values` and check whether the
    element is greater than the current `maximum` ➍. If it is, you set `maximum` to
    that new value ➎. When the loop is complete, `maximum` will equal the greatest
    value in the array, which prints the value of `maximum` ➏.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你将`maximum` ➊初始化为可能的最小值；这里是0，因为它是无符号的。接下来，你初始化数组`values` ➋，并使用`for`循环 ➌对其进行迭代。迭代器变量`i`的范围从0到4（包括4）。在`for`循环内，你访问`values`中的每个元素，并检查该元素是否大于当前的`maximum`
    ➍。如果是，你将`maximum`设置为该新值 ➎。当循环完成时，`maximum`将等于数组中的最大值，接着打印`maximum`的值 ➏。
- en: '**NOTE**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’ve programmed C or C++ before, you might be wondering why [Listing
    2-10](ch02.xhtml#ch02ex10) employs `size_t` instead of an `int` for the type of
    `i`. Consider that `values` could theoretically take up the maximum storage allowed.
    Although `size_t` is guaranteed to be able to index any value within it, `int`
    is not. In practice, it makes little difference, but technically `size_t` is correct.*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你之前编写过C或C++代码，你可能会想知道为什么[列表 2-10](ch02.xhtml#ch02ex10)使用`size_t`而不是`int`作为`i`的类型。考虑到`values`理论上可能占用最大允许的存储空间，虽然`size_t`保证能够索引其中的任何值，而`int`不能。在实际中，这没有太大区别，但从技术上讲，`size_t`是正确的。*'
- en: '**The Range-Based for Loop**'
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**基于范围的for循环**'
- en: 'In [Listing 2-10](ch02.xhtml#ch02ex10), you saw how to use the `for` loop at
    ➌ to iterate over the elements of the array. You can eliminate the iterator variable
    `i` by using a *range-based for loop*. For certain objects like arrays, `for`
    understands how to iterate over the range of values within an object. Here’s the
    syntax for a range-based for loop:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 2-10](ch02.xhtml#ch02ex10)中，你已经看到如何使用`for`循环 ➌来迭代数组的元素。通过使用*基于范围的for循环*，你可以省略迭代器变量`i`。对于某些对象，如数组，`for`理解如何迭代对象内的值范围。以下是基于范围的for循环的语法：
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You declare an iterator variable `element-name` ➋ with type `element-type` ➊.
    The `element-type` must match the types within the array you’re iterating over.
    This array is called `array-name` ➌.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明一个迭代器变量`element-name` ➋，其类型为`element-type` ➊。`element-type`必须与正在迭代的数组中的元素类型匹配。这个数组称为`array-name`
    ➌。
- en: '[Listing 2-11](ch02.xhtml#ch02ex11) refactors [Listing 2-10](ch02.xhtml#ch02ex10)
    with a range-based `for` loop.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-11](ch02.xhtml#ch02ex11) 用基于范围的`for`循环重构了[列表 2-10](ch02.xhtml#ch02ex10)。'
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 2-11: Refactoring [Listing 2-10](ch02.xhtml#ch02ex10) with a range-based
    for loop*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-11：用基于范围的for循环重构[列表 2-10](ch02.xhtml#ch02ex10)*'
- en: '**NOTE**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You’ll learn about expressions in [Chapter 7](ch07.xhtml#ch07). For now, think
    of an expression as some bit of code that produces an effect on your program.*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*你将在[第7章](ch07.xhtml#ch07)学习关于表达式的内容。现在，先把表达式想象成一些代码片段，它们对你的程序产生影响。*'
- en: '[Listing 2-11](ch02.xhtml#ch02ex11) greatly improves [Listing 2-10](ch02.xhtml#ch02ex10).
    At a glance, you know that the `for` loop iterates over `values` ➊. Because you’ve
    discarded the iterator variable `i`, the body of the `for` loop simplifies nicely;
    for that reason, you can use each element of values directly ➋➌.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-11](ch02.xhtml#ch02ex11)大大改进了[列表 2-10](ch02.xhtml#ch02ex10)。一眼看去，你就知道`for`循环在迭代`values`
    ➊。由于你已经丢弃了迭代器变量`i`，`for`循环的主体简化了；因此，你可以直接使用`values`中的每个元素 ➋➌。'
- en: Use range-based `for` loops generously.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 慷慨使用基于范围的`for`循环。
- en: '**Number of Elements in an Array**'
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**数组中的元素数量**'
- en: 'Use the `sizeof` operator to obtain the total size in bytes of an array. You
    can use a simple trick to determine the number of elements in an array: divide
    the size of the array by the size of a single constituent element:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sizeof`运算符来获取数组的总字节大小。你可以使用一个简单的技巧来确定数组中的元素数量：将数组的大小除以单个元素的大小：
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: On most systems, `sizeof(array)` ➊ will evaluate to 16 bytes and `sizeof(short)`
    ➋ will evaluate to 2 bytes. Regardless of the size of a `short`, `n_elements`
    will always initialize to 8 because the factor will cancel. This evaluation happens
    at compile time, so there is no runtime cost in evaluating the length of an array
    in this way.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数系统上，`sizeof(array)` ➊将计算为16字节，而`sizeof(short)` ➋将计算为2字节。无论`short`的大小如何，`n_elements`将始终初始化为8，因为该因子会相互抵消。此计算发生在编译时，因此以这种方式计算数组的长度不会产生运行时成本。
- en: The `sizeof(x)/sizeof(y)` construction is a bit of a hack, but it’s widely used
    in older code. In [Part II](part02.xhtml#part02), you’ll learn other options for
    storing data that don’t require external computation of their lengths. If you
    really must use an array, you can safely obtain the number of elements using the
    `std::size` function available in the `<iterator>` header.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`sizeof(x)/sizeof(y)`这种写法有点像黑客技术，但它在旧代码中广泛使用。在[第二部分](part02.xhtml#part02)中，你将学习其他存储数据的选项，这些选项不需要外部计算它们的长度。如果你真的必须使用数组，你可以安全地通过`std::size`函数来获取元素的数量，该函数在`<iterator>`头文件中可用。'
- en: '**NOTE**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As an additional benefit, `std::size` can be used with any container that
    exposes a `size` method. This includes all the containers in [Chapter 13](ch13.xhtml#ch13).
    This is especially useful when writing generic code, a topic you’ll explore in
    [Chapter 6](ch06.xhtml#ch06). Further, it will refuse to compile if you accidentally
    pass an unsupported type, like a pointer.*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*作为附加好处，`std::size`可以与任何公开`size`方法的容器一起使用。这包括[第13章](ch13.xhtml#ch13)中的所有容器。这在编写泛型代码时尤其有用，这是你将在[第6章](ch06.xhtml#ch06)中探讨的主题。此外，如果你意外地传递了不支持的类型，如指针，它会拒绝编译。*'
- en: '***C-Style Strings***'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***C风格字符串***'
- en: '*Strings* are contiguous blocks of characters. A *C-style string* or *null-terminated
    string* has a zero-byte appended to its end (a null) to indicate the end of the
    string. Because array elements are contiguous, you can store strings in arrays
    of character types.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串*是连续的字符块。*C风格字符串*或*空字符终止字符串*在其末尾附加一个零字节（一个空字符）以表示字符串的结束。由于数组元素是连续的，你可以将字符串存储在字符类型的数组中。'
- en: '**String Literals**'
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串字面量**'
- en: 'Declare string literals by enclosing text in quotation marks (`""`). Like character
    literals, string literals support Unicode: just prepend the literal with the appropriate
    prefix, such as `L`. The following example assigns string literals to the arrays
    `english` and `chinese`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将文本括在引号（`""`）中来声明字符串字面量。像字符字面量一样，字符串字面量支持Unicode：只需在字面量前添加适当的前缀，如`L`。以下示例将字符串字面量分配给数组`english`和`chinese`：
- en: '[PRE20]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**NOTE**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Surprise! You’ve been using string literals all along: the format strings
    of your `printf` statements are string literals.*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*惊讶！你一直在使用字符串字面量：你的`printf`语句的格式化字符串就是字符串字面量。*'
- en: 'This code generates two variables: `english`, which contains `A book holds
    a house of gold.`, and `chinese`, which contains the Unicode characters for 书中自有黄金屋.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成了两个变量：`english`，其内容是`A book holds a house of gold.`，以及`chinese`，其内容是书中自有黄金屋的Unicode字符。
- en: '**Format Specifier**'
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**格式说明符**'
- en: 'The format specifier for narrow strings (`char*`) is `%s`. For example, you
    can incorporate strings into format strings as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 窄字符字符串（`char*`）的格式说明符是`%s`。例如，你可以将字符串包含到格式化字符串中，如下所示：
- en: '[PRE21]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**NOTE**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Printing Unicode to the console is surprisingly complicated. Typically, you
    need to ensure that the correct code page is selected, and this topic is well
    beyond the scope of this book. If you need to embed Unicode characters into a
    string literal, look at `wprintf` in the `<cwchar>` header.*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*将Unicode打印到控制台是出奇的复杂。通常，你需要确保选择了正确的代码页，而这个话题远远超出了本书的范围。如果你需要将Unicode字符嵌入到字符串字面量中，请查看`wprintf`，它位于`<cwchar>`头文件中。*'
- en: 'Consecutive string literals get concatenated together, and any intervening
    whitespaces or newlines get ignored. So, you can place string literals on multiple
    lines in your source, and the compiler will treat them as one. For example, you
    could refactor this example as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 连续的字符串字面量会被连接在一起，任何中间的空格或换行都会被忽略。因此，你可以在源代码中将字符串字面量分布在多行，编译器会将它们当作一个整体来处理。例如，你可以将这个例子重构如下：
- en: '[PRE22]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Usually, such constructions are useful for readability only when you have a
    long string literal that would span multiple lines in your source code. The generated
    programs are identical.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你的源代码中有一个长字符串字面量，会跨越多行时，这种结构只在提高可读性时有用。生成的程序是相同的。
- en: '**ASCII**'
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**ASCII**'
- en: The *American Standard Code for Information Interchange (ASCII)* table assigns
    integers to characters. [Table 2-4](ch02.xhtml#ch02tab04) shows the ASCII table.
    For each integer value in decimal (0d) and hex (0x), the given control code or
    printable character is shown.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*美国标准信息交换码（ASCII）*表将整数分配给字符。[表 2-4](ch02.xhtml#ch02tab04)显示了ASCII表。对于每个十进制（0d）和十六进制（0x）的整数值，都会显示相应的控制代码或可打印字符。'
- en: '**Table 2-4:** The ASCII Table'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-4：** ASCII 表'
- en: '| **Control codes** | **Printable characters** |  |  |  |  |  |  |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| **控制代码** | **可打印字符** |  |  |  |  |  |  |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **0d** | **0x** | **Code** | **0d** | **0x** | **Char** | **0d** | **0x**
    | **Char** | **0d** | **0x** | **Char** |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| **0d** | **0x** | **Code** | **0d** | **0x** | **Char** | **0d** | **0x**
    | **Char** | **0d** | **0x** | **Char** |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | 0 | `NULL` | 32 | 20 | `SPACE` | 64 | 40 | `@` | 96 | 60 | `` ` `` |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | `NULL` | 32 | 20 | `SPACE` | 64 | 40 | `@` | 96 | 60 | `` ` `` |'
- en: '| 1 | 1 | `SOH` | 33 | 21 | `!` | 65 | 41 | `A` | 97 | 61 | `a` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | `SOH` | 33 | 21 | `!` | 65 | 41 | `A` | 97 | 61 | `a` |'
- en: '| 2 | 2 | `STX` | 34 | 22 | `"` | 66 | 42 | `B` | 98 | 62 | `b` |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 | `STX` | 34 | 22 | `"` | 66 | 42 | `B` | 98 | 62 | `b` |'
- en: '| 3 | 3 | `ETX` | 35 | 23 | `#` | 67 | 43 | `C` | 99 | 63 | `c` |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 3 | `ETX` | 35 | 23 | `#` | 67 | 43 | `C` | 99 | 63 | `c` |'
- en: '| 4 | 4 | `EOT` | 36 | 24 | `$` | 68 | 44 | `D` | 100 | 64 | `d` |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 4 | `EOT` | 36 | 24 | `$` | 68 | 44 | `D` | 100 | 64 | `d` |'
- en: '| 5 | 5 | `ENQ` | 37 | 25 | `%` | 69 | 45 | `E` | 101 | 65 | `e` |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 5 | `ENQ` | 37 | 25 | `%` | 69 | 45 | `E` | 101 | 65 | `e` |'
- en: '| 6 | 6 | `ACK` | 38 | 26 | `&` | 70 | 46 | `F` | 102 | 66 | `f` |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 6 | `ACK` | 38 | 26 | `&` | 70 | 46 | `F` | 102 | 66 | `f` |'
- en: '| 7 | 7 | `BELL` | 39 | 27 | `''` | 71 | 47 | `G` | 103 | 67 | `g` |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 7 | `BELL` | 39 | 27 | `''` | 71 | 47 | `G` | 103 | 67 | `g` |'
- en: '| 8 | 8 | `BS` | 40 | 28 | `(` | 72 | 48 | `H` | 104 | 68 | `h` |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 8 | `BS` | 40 | 28 | `(` | 72 | 48 | `H` | 104 | 68 | `h` |'
- en: '| 9 | 9 | `HT` | 41 | 29 | `)` | 73 | 49 | `I` | 105 | 69 | `i` |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 9 | `HT` | 41 | 29 | `)` | 73 | 49 | `I` | 105 | 69 | `i` |'
- en: '| 10 | 0a | `LF` | 42 | 2a | `*` | 74 | 4a | `J` | 106 | 6a | `j` |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 0a | `LF` | 42 | 2a | `*` | 74 | 4a | `J` | 106 | 6a | `j` |'
- en: '| 11 | 0b | `VT` | 43 | 2b | `+` | 75 | 4b | `K` | 107 | 6b | `k` |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 0b | `VT` | 43 | 2b | `+` | 75 | 4b | `K` | 107 | 6b | `k` |'
- en: '| 12 | 0c | `FF` | 44 | 2c | `,` | 76 | 4c | `L` | 108 | 6c | `l` |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 0c | `FF` | 44 | 2c | `,` | 76 | 4c | `L` | 108 | 6c | `l` |'
- en: '| 13 | 0d | `CR` | 45 | 2d | `-` | 77 | 4d | `M` | 109 | 6d | `m` |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 0d | `CR` | 45 | 2d | `-` | 77 | 4d | `M` | 109 | 6d | `m` |'
- en: '| 14 | 0e | `SO` | 46 | 2e | `.` | 78 | 4e | `N` | 110 | 6e | `n` |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 0e | `SO` | 46 | 2e | `.` | 78 | 4e | `N` | 110 | 6e | `n` |'
- en: '| 15 | 0f | `SI` | 47 | 2f | `/` | 79 | 4f | `O` | 111 | 6f | `o` |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 0f | `SI` | 47 | 2f | `/` | 79 | 4f | `O` | 111 | 6f | `o` |'
- en: '| 16 | 10 | `DLE` | 48 | 30 | `0` | 80 | 50 | `P` | 112 | 70 | `p` |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 10 | `DLE` | 48 | 30 | `0` | 80 | 50 | `P` | 112 | 70 | `p` |'
- en: '| 17 | 11 | `DC1` | 49 | 31 | `1` | 81 | 51 | `Q` | 113 | 71 | `q` |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 17 | 11 | `DC1` | 49 | 31 | `1` | 81 | 51 | `Q` | 113 | 71 | `q` |'
- en: '| 18 | 12 | `DC2` | 50 | 32 | `2` | 82 | 52 | `R` | 114 | 72 | `r` |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 12 | `DC2` | 50 | 32 | `2` | 82 | 52 | `R` | 114 | 72 | `r` |'
- en: '| 19 | 13 | `DC3` | 51 | 33 | `3` | 83 | 53 | `S` | 115 | 73 | `s` |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 19 | 13 | `DC3` | 51 | 33 | `3` | 83 | 53 | `S` | 115 | 73 | `s` |'
- en: '| 20 | 14 | `DC4` | 52 | 34 | `4` | 84 | 54 | `T` | 116 | 74 | `t` |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 14 | `DC4` | 52 | 34 | `4` | 84 | 54 | `T` | 116 | 74 | `t` |'
- en: '| 21 | 15 | `NAK` | 53 | 35 | `5` | 85 | 55 | `U` | 117 | 75 | `u` |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 21 | 15 | `NAK` | 53 | 35 | `5` | 85 | 55 | `U` | 117 | 75 | `u` |'
- en: '| 22 | 16 | `SYN` | 54 | 36 | `6` | 86 | 56 | `V` | 118 | 76 | `v` |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 22 | 16 | `SYN` | 54 | 36 | `6` | 86 | 56 | `V` | 118 | 76 | `v` |'
- en: '| 23 | 17 | `ETB` | 55 | 37 | `7` | 87 | 57 | `W` | 119 | 77 | `w` |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 23 | 17 | `ETB` | 55 | 37 | `7` | 87 | 57 | `W` | 119 | 77 | `w` |'
- en: '| 24 | 18 | `CAN` | 56 | 38 | `8` | 88 | 58 | `X` | 120 | 78 | `x` |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 24 | 18 | `CAN` | 56 | 38 | `8` | 88 | 58 | `X` | 120 | 78 | `x` |'
- en: '|  25  | 19 | `EM` | 57 | 39 | `9` | 89 | 59 | `Y` | 121 | 79 | `y` |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '|  25  | 19 | `EM` | 57 | 39 | `9` | 89 | 59 | `Y` | 121 | 79 | `y` |'
- en: '| 26 | 1a | `SUB` | 58 | 3a | `:` | 90 | 5a | `Z` | 122 | 7a | `z` |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 26 | 1a | `SUB` | 58 | 3a | `:` | 90 | 5a | `Z` | 122 | 7a | `z` |'
- en: '| 27 | 1b | `ESC` | 59 | 3b | `;` | 91 | 5b | `[` | 123 | 7b | `{` |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| 27 | 1b | `ESC` | 59 | 3b | `;` | 91 | 5b | `[` | 123 | 7b | `{` |'
- en: '| 28 | 1c | `FS` | 60 | 3c | `<` | 92 | 5c | `\` | 124 | 7c | `&#124;` |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 28 | 1c | `FS` | 60 | 3c | `<` | 92 | 5c | `\` | 124 | 7c | `&#124;` |'
- en: '| 29 | 1d | `GS` | 61 | 3d | `=` | 93 | 5d | `]` | 125 | 7d | `}` |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 29 | 1d | `GS` | 61 | 3d | `=` | 93 | 5d | `]` | 125 | 7d | `}` |'
- en: '| 30 | 1e | `RS` | 62 | 3e | `>` | 94 | 5e | `^` | 126 | 7e | `~` |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 30 | 1e | `RS` | 62 | 3e | `>` | 94 | 5e | `^` | 126 | 7e | `~` |'
- en: '| 31 | 1f | `US` | 63 | 3f | `?` | 95 | 5f | `_` | 127 | 7f | `DEL` |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 31 | 1f | `US` | 63 | 3f | `?` | 95 | 5f | `_` | 127 | 7f | `DEL` |'
- en: 'ASCII codes 0 to 31 are the *control code characters* that control devices.
    These are mostly anachronisms. When the American Standards Association formalized
    ASCII in the 1960s, modern devices included teletype machines, magnetic tape readers,
    and dot-matrix printers. Some control codes still in common use are the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII 码 0 到 31 是 *控制字符*，用于控制设备。这些字符大多已经过时。当美国标准协会在 1960 年代正式化 ASCII 时，现代设备包括打字机、磁带读卡器和点阵打印机。一些仍在常用的控制代码如下：
- en: 0 (NULL) is used as a string terminator by programming languages.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 (NULL) 被编程语言用作字符串终止符。
- en: 4 (EOT), the end of transmission, terminates shell sessions and PostScript printer
    communications.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 (EOT)，传输结束符，终止 shell 会话和 PostScript 打印机通信。
- en: 7 (BELL) causes a device to make a noise.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7 (BELL) 使设备发出声音。
- en: 8 (BS), the backspace, causes the device to erase the last character.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8 (BS)，退格键，使设备擦除最后一个字符。
- en: 9 (HT), the horizontal tab, moves a cursor several spaces to the right.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 9（HT），水平制表符，将光标移动若干个空格到右侧。
- en: 10 (LF), the line feed, is used as the end-of-line marker on most operating
    systems.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10（LF），换行符，在大多数操作系统中用作行结束符。
- en: 13 (CR), the carriage return, is used in combination with LF as the end-of-line
    marker on Windows systems.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 13（CR），回车符，和 LF 结合使用，在 Windows 系统上作为行结束符。
- en: 26 (SUB), the substitute character/end of file/`ctrl`-Z, suspends the currently
    executing interactive process on most operating systems.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 26（SUB），替代字符/文件结束符/`ctrl`-Z，暂停当前正在执行的交互式进程，在大多数操作系统上均适用。
- en: The remainder of the ASCII table, codes from 32 to 127, is the printable characters.
    These represent the English characters, digits, and punctuation.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII 表的其余部分，即从 32 到 127 的编码，是可打印字符。这些字符表示英文字母、数字和标点符号。
- en: On most systems, the `char` type’s representation is ASCII. Although this relationship
    is not strictly guaranteed, it is a de facto standard.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数系统中，`char` 类型的表示为 ASCII。虽然这种关系并非严格保证，但它已成为事实上的标准。
- en: Now it’s time to combine your knowledge of `char` types, arrays, `for` loops,
    and the ASCII table. [Listing 2-12](ch02.xhtml#ch02ex12) shows how to build an
    array with the letters of the alphabet, print the result, and then convert this
    array to uppercase and print again.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将你对 `char` 类型、数组、`for` 循环和 ASCII 表的知识结合起来了。[示例 2-12](ch02.xhtml#ch02ex12)
    展示了如何创建一个包含字母的数组，打印结果，然后将该数组转换为大写字母并再次打印。
- en: '[PRE23]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 2-12: Printing the letters of the alphabet in lowercase and uppercase
    using ASCII*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-12：使用 ASCII 打印小写和大写字母*'
- en: First, you declare a `char` array of length 27 to hold the 26 English letters
    plus a null terminator ➊. Next, employ a `for` loop to iterate from 0 to 25 using
    the iterator `i`. The letter *a* has the value 97 in ASCII. By adding 97 to the
    iterator `i`, you can generate all the lowercase letters in the `alphabet` ➋.
    To make `alphabet` a null-terminated string, you set `alphabet[26]` to 0 ➌. You
    then print the result ➍.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你声明一个长度为 27 的 `char` 数组来保存 26 个英文字母以及一个空终止符 ➊。接下来，使用 `for` 循环从 0 到 25 进行迭代，迭代器为
    `i`。字母 *a* 在 ASCII 中的值为 97。通过将 97 加到迭代器 `i`，你可以生成 `alphabet` 中的所有小写字母 ➋。为了使 `alphabet`
    成为一个空终止字符串，你将 `alphabet[26]` 设置为 0 ➌。然后，你打印结果 ➍。
- en: Next, you print the uppercase alphabet. The letter *A* has the value 65 in ASCII,
    so you reset each element of the alphabet accordingly ➎ and invoke `printf` again
    ➏.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你打印大写字母。字母 *A* 在 ASCII 中的值为 65，因此你需要相应地重置字母表中的每个元素 ➎ 并再次调用 `printf` ➏。
- en: '**User-Defined Types**'
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**用户定义类型**'
- en: '*User-defined types* are types that the user can define. The three broad categories
    of user-defined types are these:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*用户定义类型* 是用户可以定义的类型。用户定义类型的三大类如下：'
- en: '**Enumerations** The simplest of the user-defined types. The values that an
    enumeration can take are restricted to a set of possible values. Enumerations
    are excellent for modeling categorical concepts.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**枚举类型** 是用户定义类型中最简单的一种。枚举类型可以取的值被限制为一组可能的值。枚举非常适合用来建模类别概念。'
- en: '**Classes** More fully featured types that give you flexibility to pair data
    and functions. Classes that only contain data are called plain-old-data classes;
    you’ll learn about them in this section.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**类** 是功能更全面的类型，它使你能够灵活地将数据和函数配对。仅包含数据的类称为普通数据类；你将在本节中学习它们。'
- en: '**Unions** A boutique user-defined type. All members share the same memory
    location. Unions are dangerous and easy to misuse.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**联合类型** 是一种特别的用户定义类型。所有成员共享同一内存位置。联合类型很危险，容易被误用。'
- en: '***Enumeration Types***'
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***枚举类型***'
- en: Declare enumerations using the keywords `enum class` followed by the type name
    and a listing of the values it can take. These values are arbitrary alphanumeric
    strings that will represent whatever categories you want to represent. Under the
    hood, these values are simply integers, but they allow you to write safer, more
    expressive code by using programmer-defined types rather than integers that could
    mean anything. For example, [Listing 2-13](ch02.xhtml#ch02ex13) declares an `enum
    class` called `Race` that can take one of seven values.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关键字 `enum class` 来声明枚举类型，后跟类型名称和它可以取的值的列表。这些值是任意的字母数字字符串，代表你想表示的任何类别。在底层，这些值只是整数，但它们使得你能够通过使用程序员定义的类型，而不是任意整数，从而编写更安全、更具表现力的代码。例如，[示例
    2-13](ch02.xhtml#ch02ex13) 声明了一个名为 `Race` 的 `enum class`，它可以取七个值之一。
- en: '[PRE24]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 2-13: An enumeration class containing all the races from Neal Stephenson’s*
    Seveneves'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-13：一个包含 Neal Stephenson 的《Seveneves》中的所有种族的枚举类*'
- en: 'To initialize an enumeration variable to a value, use the name of the type
    followed by two colons `::` and the desired value. For example, here’s how to
    declare the variable `langobard_race` and initialize its value to `Aidan`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要将枚举变量初始化为某个值，使用类型名称后跟两个冒号`::`和所需的值。例如，以下是如何声明变量`langobard_race`并将其值初始化为`Aidan`：
- en: '[PRE25]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**NOTE**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Technically, an `enum class` is one of two kinds of enumerations: it’s called
    a scoped enum. For compatibility with C, C++ also supports an unscoped enum, which
    is declared with `enum` rather than `enum class`. The major difference is that
    scoped enums require the enum’s type followed by `::` to precede the values, whereas
    unscoped enums don’t. Unscoped `enum` classes are less safe to use than scoped
    enums, so shy away from them unless absolutely necessary. They’re supported in
    C++ for mainly historical reasons, especially interoperation with C code. See
    Effective Modern C++ by Scott Meyers, Item 10, for details.*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*从技术上讲，`enum class`是两种枚举类型之一：它被称为作用域枚举。为了与C语言兼容，C++还支持一种非作用域枚举，它使用`enum`而不是`enum
    class`声明。主要的区别在于作用域枚举要求在值之前使用枚举类型后跟`::`，而非作用域枚举则不需要。非作用域`enum`类比作用域枚举更不安全，因此除非绝对必要，最好避免使用它们。它们在C++中主要是出于历史原因，特别是为了与C代码的互操作性。有关详细信息，请参阅Scott
    Meyers的《Effective Modern C++》，第10项。*'
- en: '**Switch Statements**'
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**switch语句**'
- en: The *switch statement* transfers control to one of several statements depending
    on the value of a *condition*, which evaluates to either an integer or enumeration
    type. The `switch` keyword denotes a switch statement.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*switch语句*根据*条件*的值将控制权转移到多个语句之一，该条件可以是整数类型或枚举类型。`switch`关键字表示一个switch语句。'
- en: Switch statements provide conditional branching. When a switch statement executes,
    control transfers to the *case* fitting the condition or to a *default condition*
    if no case matches the condition expression. The `case` keyword denotes a case,
    whereas the `default` keyword denotes the default condition.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: switch语句提供了条件分支。当执行switch语句时，控制权转移到符合条件的*case*，或者如果没有任何case匹配条件表达式，则转移到*default
    condition*。`case`关键字表示一个case，而`default`关键字表示默认条件。
- en: Somewhat confusingly, execution will continue until the end of the switch statement
    or the `break` keyword. You’ll almost always find a `break` at the end of each
    condition.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 有点令人困惑的是，执行会继续直到switch语句的末尾或遇到`break`关键字。你几乎总是会在每个条件的末尾找到一个`break`。
- en: Switch statements have a lot of components. [Listing 2-14](ch02.xhtml#ch02ex14)
    shows how they fit together.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: switch语句有很多组件。[列表 2-14](ch02.xhtml#ch02ex14)展示了它们是如何组合的。
- en: '[PRE26]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 2-14: A sketch of how switch statements fit together*'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-14：展示switch语句如何组合在一起的草图*'
- en: All switch statements begin with the `switch` keyword ➊ followed by the `condition`
    in parentheses ➋. Each case begins with the `case` keyword ➌ followed by the case’s
    enumeration or integral value ➍. If `condition` ➋ equals `case-a` ➍, for example,
    the code in the block containing `Handle case a here` will execute. After each
    statement following a case ➎, you place a `break` keyword ➏. If `condition` matches
    none of the cases, the `default` case ➐ executes.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的switch语句都以`switch`关键字 ➊开始，后面跟着括号中的`condition` ➋。每个case以`case`关键字 ➌开始，后面跟着该case的枚举或整数值
    ➍。例如，如果`condition` ➋等于`case-a` ➍，则包含`Handle case a here`的代码块将执行。在每个case语句后 ➎，你需要放一个`break`关键字
    ➏。如果`condition`与任何case都不匹配，则执行`default` case ➐。
- en: '**NOTE**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The braces enclosing each case are optional but highly recommended. Without
    them, you’ll sometimes get surprising behavior.*'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*每个case的括号是可选的，但强烈建议使用它们。如果不使用括号，有时会出现意外的行为。*'
- en: '**Using a Switch Statement with an Enumeration Class**'
  id: totrans-306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用枚举类的switch语句**'
- en: '[Listing 2-15](ch02.xhtml#ch02ex15) uses a switch statement on a `Race` enumeration
    class to generate a bespoke greeting.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-15](ch02.xhtml#ch02ex15)使用switch语句对`Race`枚举类进行操作，生成定制的问候语。'
- en: '[PRE27]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 2-15: A program that prints a greeting that depends on the `Race`
    selected*'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-15：根据选择的`Race`打印不同问候语的程序*'
- en: The `enum class` ➊ declares the enumeration type `Race`, which you use to initialize
    `race` to `Dinan` ➋. The switch statement ➌ evaluates the condition `race` to
    determine which condition to hand control to. Because you hardcoded this to `Dinan`
    earlier in the code, execution transfers to ➍, which prints `You work hard.` The
    `break` at ➎ terminates the switch statement.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum class` ➊声明了枚举类型`Race`，你用它将`race`初始化为`Dinan` ➋。switch语句 ➌评估条件`race`以确定应该将控制权转交给哪个条件。由于你在代码的前面已经将其硬编码为`Dinan`，所以执行将转到
    ➍，并打印`You work hard.` 在 ➎的`break`终止了switch语句。'
- en: The `default` condition at ➏ is a safety feature. If someone adds a new `Race`
    value to the enumeration class, you’ll detect that unknown race at runtime and
    print an error message.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➏ 的 `default` 条件是一个安全功能。如果有人向枚举类中添加了新的 `Race` 值，程序将在运行时检测到该未知的种族并打印错误信息。
- en: Try setting `race` ➋ to different values. How does the output change?
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将 `race` ➋ 设置为不同的值。输出结果是如何变化的？
- en: '***Plain-Old-Data Classes***'
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***普通数据类（POD）***'
- en: '*Classes* are user-defined types that contain data and functions, and they’re
    the heart and soul of C++. The simplest kind of classes are *plain-old-data classes
    (PODs)*. PODs are simple containers. Think of them as a sort of heterogeneous
    array of elements of potentially *different* types. Each element of a class is
    called a *member*.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '*类*是用户定义的包含数据和函数的类型，它们是 C++ 的核心和灵魂。最简单的类是 *普通数据类（POD）*。POD 是简单的容器。你可以把它们看作是包含潜在
    *不同* 类型元素的异构数组。类中的每个元素称为 *成员*。'
- en: 'Every POD begins with the keyword `struct` followed by the POD’s desired name.
    Next, you list the members’ types and names. Consider the following `Book` class
    declaration with four members:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 POD 都以关键字 `struct` 开头，后面跟着 POD 的名称。接下来，你列出成员的类型和名称。考虑以下声明具有四个成员的 `Book` 类：
- en: '[PRE28]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A single `Book` contains a `char` array called `name` ➊, an `int year` ➋, an
    `int pages` ➌, and a `bool hardcover` ➍.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Book` 包含一个 `char` 数组 `name` ➊、一个 `int year` ➋、一个 `int pages` ➌ 和一个 `bool
    hardcover` ➍。
- en: 'You declare POD variables just like any other variables: by type and name.
    You can then access members of the variable using the dot operator (`.`).'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你像声明其他变量一样声明 POD 变量：通过类型和名称。然后，你可以使用点运算符（`.`）访问变量的成员。
- en: '[Listing 2-16](ch02.xhtml#ch02ex16) uses the `Book` type.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-16](ch02.xhtml#ch02ex16) 使用了 `Book` 类型。'
- en: '[PRE29]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 2-16: Example using the POD type `Book` to read and write members*'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-16：使用 POD 类型 `Book` 来读取和写入成员的示例*'
- en: First, you declare a `Book` variable `neuromancer` ➊. Next, you set the number
    of pages of `neuromancer` to 271 using the dot operator (`.`) ➋. Finally, you
    print a message and extract the number of pages from `neuromancer`, again using
    the dot operator ➌.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你声明一个 `Book` 类型的变量 `neuromancer` ➊。接着，使用点运算符（`.`）将 `neuromancer` 的页数设置为 271
    ➋。最后，你打印一条消息并提取 `neuromancer` 的页数，再次使用点运算符 ➌。
- en: '**NOTE**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*PODs have some useful low-level features: they’re C compatible, you can employ
    machine instructions that are highly efficient to copy or move them, and they
    can be efficiently represented in memory.*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*POD 类型具有一些有用的低级特性：它们与 C 兼容，可以使用高效的机器指令来复制或移动它们，并且可以高效地表示在内存中。*'
- en: '*C++ guarantees that members will be sequential in memory, although some implementations
    require members to be aligned along word boundaries, which depend on CPU register
    length. As a general rule, you should order members from largest to smallest within
    POD definitions.*'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '*C++ 保证成员在内存中是按顺序排列的，尽管某些实现要求成员沿着字边界对齐，这取决于 CPU 寄存器的长度。通常的做法是，在 POD 定义中按照从大到小的顺序排列成员。*'
- en: '***Unions***'
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***联合体***'
- en: The union is a cousin of the POD that puts all of its members in the same place.
    You can think of unions as different views or interpretations of a block of memory.
    They can be useful in some low-level situations, such as when marshalling structures
    that must be consistent across architectures, dealing with type-checking issues
    related to C/C++ interoperation, and even when packing bitfields.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 联合体是 POD 类型的“表亲”，它将所有成员放在同一位置。你可以把联合体看作是对一块内存的不同视图或解释。它们在某些低级场景中非常有用，比如在跨架构一致的结构体序列化中、处理与
    C/C++ 互操作相关的类型检查问题，甚至在打包位域时。
- en: '[Listing 2-17](ch02.xhtml#ch02ex17) illustrates how you declare a union: simply
    use the `union` keyword instead of `struct`.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-17](ch02.xhtml#ch02ex17) 演示了如何声明一个联合体：只需使用 `union` 关键字代替 `struct`。'
- en: '[PRE30]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 2-17: An example union*'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-17：一个示例联合体*'
- en: The union `Variant` can be interpreted as a `char[10]`, an `int`, or a `double`.
    It takes up only as much memory as its largest member (probably `string` in this
    case).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 联合体 `Variant` 可以被解释为一个 `char[10]`、一个 `int` 或一个 `double`。它仅占用与其最大成员（在此情况下可能是
    `string`）相同的内存空间。
- en: You use the dot operator (`.`) to specify a union’s interpretation. Syntactically,
    this looks like accessing a member of a POD, but it’s completely different under
    the hood.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用点运算符（`.`）来指定联合体的解释。从语法上看，这与访问 POD 成员类似，但在底层完全不同。
- en: Because all members of a union are in the same place, you can cause data corruption
    very easily. [Listing 2-18](ch02.xhtml#ch02ex18) illustrates the danger.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 由于联合体的所有成员都在同一位置，你很容易导致数据损坏。[清单2-18](ch02.xhtml#ch02ex18)展示了这一危险。
- en: '[PRE31]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 2-18: A program using the union `Variant` from [Listing 2-17](ch02.xhtml#ch02ex17)*'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单2-18：使用联合体`Variant`的程序，参见[清单2-17](ch02.xhtml#ch02ex17)*'
- en: You declare a `Variant v` at ➊. Next, you interpret `v` as an integer, set its
    value to 42 ➋, and print it ➌. You then reinterpret `v` as a `float` and reassign
    its value ➍. You print it to the console, and all appears well ➎. So far so good.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你在➊声明了一个`Variant v`。接下来，你将`v`解释为整数，设置它的值为42 ➋，并打印它 ➌。然后，你将`v`重新解释为`float`并重新赋值
    ➍。你将它打印到控制台，所有看起来都很好 ➎。到目前为止一切正常。
- en: Disaster strikes only when you try to interpret `v` as an integer again ➏. You
    clobbered over the original value of `v` (42) ➋ when assigning Euler’s number
    ➍.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 灾难发生在你再次试图将`v`解释为整数时 ➏。你在将欧拉数 ➍ 赋值时覆盖了`v`的原始值（42） ➋。
- en: 'That’s the main problem with unions: it’s up to you to keep track of which
    interpretation is appropriate. The compiler won’t help you.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是联合体的主要问题：你需要自己跟踪哪种解释是合适的。编译器不会帮助你。
- en: You should avoid using unions in all but the rarest of cases, and you won’t
    see them in this book. “variant” on [page 379](ch12.xhtml#page_379) discusses
    some safer options when you require poly-type functionality.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该避免在除非极少数情况外使用联合体，在本书中你不会看到它们。[第379页](ch12.xhtml#page_379)的“variant”讨论了当你需要多类型功能时，一些更安全的选项。
- en: '**Fully Featured C++ Classes**'
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**功能全面的C++类**'
- en: POD classes contain only data members, and sometimes that’s all you want from
    a class. However, designing a program using only PODs can create a lot of complexity.
    You can fight such complexity with *encapsulation*, a design pattern that binds
    data with the functions that manipulate it. Placing related functions and data
    together helps to simplify code in at least two ways. First, you can put related
    code in one place, which helps you to reason about your program. You can understand
    how a code segment works because it describes in one place both program state
    and how your code modifies that state. Second, you can hide some of a class’s
    code and data from the rest of your program using a practice called *information
    hiding*.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: POD类只包含数据成员，有时这就是你从类中需要的全部。然而，仅使用POD设计程序可能会带来很多复杂性。你可以通过*封装*来应对这种复杂性，封装是一种将数据与操作它的函数绑定的设计模式。将相关的函数和数据放在一起有助于简化代码，至少有两种方式。首先，你可以把相关代码放在一个地方，这有助于你推理程序的行为。你可以理解代码片段是如何工作的，因为它在一个地方描述了程序的状态以及代码如何修改该状态。其次，你可以使用称为*信息隐藏*的做法，将类的一些代码和数据隐藏起来，避免它们被程序的其他部分访问。
- en: In C++, you achieve encapsulation by adding methods and access controls to class
    definitions.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，你通过在类定义中添加方法和访问控制来实现封装。
- en: '***Methods***'
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***方法***'
- en: '*Methods* are member functions. They create an explicit connection among a
    class, its data members, and some code. Defining a method is as simple as adding
    a function to a class definition. Methods have access to all of a class’s members.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法*是成员函数。它们在类、数据成员和某些代码之间创建了一个明确的连接。定义一个方法就像在类定义中添加一个函数一样简单。方法可以访问类的所有成员。'
- en: 'Consider an example class `ClockOfTheLongNow` that keeps track of the year.
    You define an `int year` member and an `add_year` method that increments it:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个示例类`ClockOfTheLongNow`，它跟踪年份。你定义一个`int year`成员和一个递增它的`add_year`方法：
- en: '[PRE32]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `add_year` method’s declaration ➊ looks like any other function that takes
    no parameters and returns no value. Within the method, you increment ➋ the member
    `year` ➌. [Listing 2-19](ch02.xhtml#ch02ex19) shows how you can use the class
    to keep track of a year.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_year`方法的声明➊看起来像是任何一个不带参数且不返回值的函数。在方法内部，你会递增➋成员变量`year` ➌。[清单2-19](ch02.xhtml#ch02ex19)展示了如何使用该类来跟踪年份。'
- en: '[PRE33]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 2-19: A program using the `ClockOfTheLongNow` struct*'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单2-19：使用`ClockOfTheLongNow`结构的程序*'
- en: You declare the `ClockOfTheLongNow` instance `clock` ➊ and then set the `year`
    of `clock` to `2017` ➋. Next, you call the `add_year` method on `clock` ➌ and
    then print the value of `clock.year` ➍. You complete the program by incrementing
    ➎ and printing ➏ once more.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明了`ClockOfTheLongNow`实例`clock` ➊，然后将`clock`的`year`设置为`2017` ➋。接下来，你在`clock`上调用`add_year`方法
    ➌，然后打印`clock.year`的值 ➍。你通过递增 ➎并再次打印 ➏来完成程序。
- en: '***Access Controls***'
  id: totrans-351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***访问控制***'
- en: '*Access controls* restrict class-member access. *Public* and *private* are
    the two major access controls. Anyone can access a public member, but only a class
    can access its private members. All `struct` members are public by default.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '*访问控制* 限制类成员的访问。*公共* 和 *私有* 是两种主要的访问控制。任何人都可以访问公共成员，但只有类本身可以访问其私有成员。所有 `struct`
    成员默认都是公共的。'
- en: 'Private members play an important role in encapsulation. Consider again the
    `ClockOfTheLongNow` class. As it stands, the `year` member can be accessed from
    anywhere—for both reading and writing. Suppose you want to protect against the
    value of the `year` being less than 2019\. You can accomplish this in two steps:
    you make `year` private, and you require anyone using the class (consumers) to
    interact with `year` only through the struct’s methods. [Listing 2-20](ch02.xhtml#ch02ex20)
    illustrates this approach.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 私有成员在封装中扮演着重要角色。再考虑一下 `ClockOfTheLongNow` 类。目前，`year` 成员可以从任何地方访问——无论是读取还是写入。假设你想防止
    `year` 的值小于 2019。你可以通过两步来实现这一点：你将 `year` 设为私有，并要求所有使用该类的用户（消费者）只能通过类的方法与 `year`
    进行交互。[清单 2-20](ch02.xhtml#ch02ex20) 说明了这种方法。
- en: '[PRE34]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 2-20: An updated `ClockOfTheLongNow` from [Listing 2-19](ch02.xhtml#ch02ex19)
    that encapsulates `year`*'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-20：一个更新版的 `ClockOfTheLongNow`，来自 [清单 2-19](ch02.xhtml#ch02ex19)，封装了 `year`*'
- en: 'You’ve added two methods to `ClockOfTheLongNow`: a *setter* ➊ and a *getter*
    ➌ for `year`. Rather than allowing a user of `ClockOfTheLongNow` to modify `year`
    directly, you set the `year` with `set_year`. This addition of input validation
    ensures that `new_year` will never be less than 2019 ➋. If it is, the code returns
    `false` and leaves `year` unmodified. Otherwise, `year` is updated and returns
    `true`. To obtain the value of `year`, the user calls `get_year`.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 你已为 `ClockOfTheLongNow` 添加了两个方法：一个 *setter* ➊ 和一个 *getter* ➌，用于 `year`。你不允许
    `ClockOfTheLongNow` 的用户直接修改 `year`，而是通过 `set_year` 设置 `year`。这种输入验证确保了 `new_year`
    永远不会小于 2019 ➋。如果小于 2019，代码返回 `false` 并且 `year` 保持不变。否则，`year` 会被更新并返回 `true`。要获取
    `year` 的值，用户需要调用 `get_year`。
- en: You’ve used the access control label `private` ➍ to prohibit consumers from
    accessing `year`. Now, users can access `year` only from within `ClockOfTheLongNow`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用访问控制标签 `private` ➊ 禁止消费者访问 `year`。现在，用户只能在 `ClockOfTheLongNow` 内部访问 `year`。
- en: '**The class Keyword**'
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**class 关键字**'
- en: 'You can replace the `struct` keyword with the `class` keyword, which declares
    members `private` by default. Aside from default access control, classes declared
    with the `struct` and `class` keywords are the same. For example, you could declare
    `ClockOfTheLongNow` in the following way:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `struct` 关键字替换为 `class` 关键字，后者默认声明成员为 `private`。除了默认的访问控制外，使用 `struct`
    和 `class` 关键字声明的类是一样的。例如，你可以通过以下方式声明 `ClockOfTheLongNow`：
- en: '[PRE35]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Which way you declare classes is a matter of style. There is absolutely no difference
    between `struct` and `class` aside from the default access control. I prefer using
    `struct` keywords because I like having the public members listed first. But you’ll
    see all kinds of conventions out in the wild. Cultivate a style and stick to it.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 声明类的方式是个人风格问题。除了默认的访问控制外，`struct` 和 `class` 没有任何区别。我偏爱使用 `struct` 关键字，因为我喜欢先列出公共成员。但你会看到各种各样的约定，外面的人使用的风格不同。培养一种风格并坚持下去。
- en: '**Initializing Members**'
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**初始化成员**'
- en: Having encapsulated `year`, you must now use methods to interact with `ClockOfTheLongNow`.
    [Listing 2-21](ch02.xhtml#ch02ex21) shows how you can stitch these methods together
    into a program that attempts to set the year to 2018\. This fails, and the program
    then sets the year to 2019, increments the year, and prints its final value.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 既然已经封装了 `year`，你现在必须使用方法来与 `ClockOfTheLongNow` 交互。[清单 2-21](ch02.xhtml#ch02ex21)
    展示了如何将这些方法组合成一个程序，尝试将年份设置为 2018。操作失败后，程序将年份设置为 2019，增加年份，然后打印最终的值。
- en: '[PRE36]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 2-21: A program using the ClockOfTheLongNow to illustrate the use
    of methods*'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-21：使用 `ClockOfTheLongNow` 的程序，演示如何使用方法*'
- en: You declare a clock ➊ and attempt to set its year to 2018 ➋. This fails because
    2018 is less than 2019, and the program then sets the year to 2019 ➌. You increment
    the year once ➍ and then print its value.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明了一个时钟 ➊ 并尝试将其年份设置为 2018 ➋。这失败了，因为 2018 小于 2019，程序随后将年份设置为 2019 ➌。你将年份增加了一次
    ➍ 然后打印其值。
- en: 'In [Chapter 1](ch01.xhtml#ch01), you saw how uninitialized variables can contain
    random data as you stepped through the debugger. The `ClockOfTheLongNow` struct
    has the same problem: when `clock` is declared ➊, `year` is uninitialized. You
    want to guarantee that `year` is never less than 2019 *under any circumstances*.
    Such a requirement is called a *class invariant*: a feature of a class that is
    always true (that is, it never varies).'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml#ch01)中，你看到未初始化的变量可能会包含随机数据，在调试时你可以观察到这一点。`ClockOfTheLongNow`
    结构体也有同样的问题：当 `clock` 被声明 ➊ 时，`year` 是未初始化的。你希望保证 `year` 在*任何情况下*都不小于2019。这种要求被称为*类不变性*：类的一个特性，它始终为真（即永远不会改变）。
- en: In this program, `clock` eventually gets into a good state ➌, but you can do
    better by employing a *constructor*. Constructors initialize objects and enforce
    class invariants from the very beginning of an object’s life.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，`clock` 最终达到了一个良好的状态 ➌，但你可以通过使用*构造函数*来做得更好。构造函数从对象生命周期的开始就初始化对象，并强制执行类的不变性。
- en: '***Constructors***'
  id: totrans-369
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构造函数***'
- en: Constructors are special methods with special declarations. Constructor declarations
    don’t state a return type, and their name matches the class’s name. For example,
    the constructor in [Listing 2-22](ch02.xhtml#ch02ex22) takes no arguments and
    sets `year` to 2019, which causes `year` to default to 2019.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是具有特殊声明的特殊方法。构造函数的声明不指定返回类型，且它们的名称与类名相同。例如，[清单 2-22](ch02.xhtml#ch02ex22)中的构造函数没有参数，并将
    `year` 设置为2019，这使得 `year` 默认为2019。
- en: '[PRE37]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 2-22: Improving [Listing 2-21](ch02.xhtml#ch02ex21) with a parameterless
    constructor*'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-22：通过无参构造函数改进 [清单 2-21](ch02.xhtml#ch02ex21)*'
- en: The constructor takes no arguments ➊ and sets `year` to 2019 ➋. When you declare
    a new `ClockOfTheLongNow` ➌, `year` defaults to 2019\. You access `year` using
    `get_year` and print it to the console ➍.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 该构造函数不接受任何参数 ➊，并将 `year` 设置为2019 ➋。当你声明一个新的 `ClockOfTheLongNow` ➌ 时，`year` 默认为2019。你通过
    `get_year` 访问 `year` 并将其打印到控制台 ➍。
- en: What if you want to initialize a `ClockOfTheLongNow` with a custom year? Constructors
    can take any number of arguments. You can implement as many constructors as you’d
    like, as long as their argument types differ.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想用自定义的年份初始化一个 `ClockOfTheLongNow` 呢？构造函数可以接受任意数量的参数。你可以实现任意多个构造函数，只要它们的参数类型不同。
- en: Consider the example in [Listing 2-23](ch02.xhtml#ch02ex23) where you add a
    constructor taking an `int`. The constructor initializes `year` to the argument’s
    value.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[清单 2-23](ch02.xhtml#ch02ex23)中的例子，在其中你添加了一个接受 `int` 的构造函数。构造函数将 `year` 初始化为该参数的值。
- en: '[PRE38]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 2-23: Elaborating [Listing 2-22](ch02.xhtml#ch02ex22) with another
    constructor*'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-23：通过另一个构造函数扩展 [清单 2-22](ch02.xhtml#ch02ex22)*'
- en: The new constructor ➊ takes a single `year_in` argument of type `int`. You call
    `set_year` with `year_in` ➋. If `set_year` returns false, the caller provided
    bad input, and you override `year_in` with the default value of 2019 ➌. In `main`,
    you make a clock with the new constructor ➍ and then print the result ➎.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 新的构造函数 ➊ 接受一个类型为 `int` 的 `year_in` 参数。你调用 `set_year` 并传入 `year_in` ➋。如果 `set_year`
    返回false，说明调用者提供了无效输入，你会用默认值2019覆盖 `year_in` ➌。在 `main` 中，你使用新构造函数 ➍ 创建一个时钟对象，然后打印结果
    ➎。
- en: The conjuration `ClockOfTheLongNow clock{ 2020 };` is called an initialization.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClockOfTheLongNow clock{ 2020 };` 的调用被称为初始化。'
- en: '**NOTE**'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You might not like the idea that invalid `year_in` instances were silently
    corrected to 2019 ➌. I don’t like it either. Exceptions solve this problem; you’ll
    learn about them in “Exceptions” on [page 98](ch04.xhtml#page_98).*'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能不喜欢无声地将无效的 `year_in` 实例修正为2019 ➌。我也不喜欢这样。异常可以解决这个问题；你将在“异常”一节中学习它们，详见 [第98页](ch04.xhtml#page_98)。*'
- en: '***Initialization***'
  id: totrans-382
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***初始化***'
- en: '*Object initialization*, or simply *initialization,* is how you bring objects
    to life. Unfortunately, object initialization syntax is complicated. Fortunately,
    the initialization process is straightforward. This section distills the bubbling
    cauldron of C++ object initialization into a palatable narrative.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象初始化*，或者简单地说，*初始化*，是将对象“唤醒”的过程。不幸的是，对象初始化的语法较为复杂。幸运的是，初始化过程是直接的。本节将C++对象初始化的复杂过程提炼成易于理解的叙述。'
- en: '**Initializing a Fundamental Type to Zero**'
  id: totrans-384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将基础类型初始化为零**'
- en: 'Let’s start by initializing an object of fundamental type to zero. There are
    four ways to do so:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从初始化一个基础类型的对象为零开始。可以通过四种方式实现这一点：
- en: '[PRE39]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Three of these are reliable: explicitly set the value using a literal ➊, use
    braces `{}` ➋, or use the equals-plus-braces approach `= {}` ➌. Declaring the
    object with no extra notation ➍ is unreliable; it works only in certain situations.
    Even if you know what these situations are, you should avoid relying on this behavior
    because it sows confusion.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 其中三种方法是可靠的：使用文字值显式设置值 ➊，使用花括号`{}` ➋，或使用等号加花括号`= {}` ➌。没有额外标记声明对象 ➍ 是不可靠的；它只在某些特定情况下有效。即使你知道这些情况，也不应依赖这种行为，因为它会引起混淆。
- en: Using braces `{}` to initialize a variable is, unsurprisingly, called *braced
    initialization*. Part of the reason C++ initialization syntax is such a mess is
    that the language grew out of C, where object life cycles are primitive, into
    a language with a robust and featureful object life cycle. Language designers
    incorporated braced initialization into modern C++ to help smooth over the sharp
    corners this has caused in the initialization syntax. In short, no matter the
    object’s scope or type, *braced initialization is always applicable*, whereas
    the other notations are not. Later in the chapter, you’ll learn a general rule
    that encourages widespread use of braced initialization.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 使用花括号`{}`来初始化变量，不出所料，称为*花括号初始化*。C++初始化语法混乱的部分原因在于，语言最初从C语言发展而来，而C语言中的对象生命周期是原始的，后来发展为具有强大和丰富功能的对象生命周期。语言设计者将花括号初始化引入现代C++，以帮助平滑过渡因初始化语法产生的尖锐问题。简而言之，无论对象的作用域或类型如何，*花括号初始化始终适用*，而其他表示法则不然。在本章后续部分，你将学习一条通用规则，鼓励广泛使用花括号初始化。
- en: '**Initializing a Fundamental Type to an Arbitrary Value**'
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将基本类型初始化为任意值**'
- en: 'Initializing to an arbitrary value is similar to initializing a fundamental
    type to zero:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化为任意值类似于将基本类型初始化为零：
- en: '[PRE40]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'There are four ways: equals ➊, braced initialization ➋, equals-plus-braces
    initialization ➌, and parentheses ➍. All of these produce identical code.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种方法：等号 ➊、花括号初始化 ➋、等号加花括号初始化 ➌ 和圆括号 ➍。所有这些都会产生相同的代码。
- en: '**Initializing PODs**'
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**初始化POD类型**'
- en: The notation for initializing a POD mostly follows fundamental types. [Listing
    2-24](ch02.xhtml#ch02ex24) illustrates the similarity by declaring a POD type
    containing three members and initializing instances of it with various values.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化POD的标记通常遵循基本类型的规则。[示例 2-24](ch02.xhtml#ch02ex24)通过声明一个包含三个成员的POD类型，并使用不同的值初始化其实例，展示了它们的相似性。
- en: '[PRE41]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 2-24: A program illustrating various ways to initialize a POD*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-24：一个展示多种方式初始化POD的程序*'
- en: 'Initializing a POD object to zero is similar to initializing objects of fundamental
    types to zero. The braces ➊ and equals-plus-braces ➋ approaches produce the same
    code: fields initialize to zero.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 将POD对象初始化为零类似于将基本类型的对象初始化为零。花括号 ➊ 和等号加花括号 ➋ 方法产生相同的代码：字段初始化为零。
- en: '**WARNING**'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*You cannot use the equals-zero approach with PODs. The following will not
    compile because it’s expressly forbidden in the language rules:*'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '*你不能使用等号零方法来初始化POD类型。以下代码无法编译，因为在语言规则中明确禁止使用：*'
- en: '[PRE42]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**Initializing PODs to Arbitrary Values**'
  id: totrans-401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将POD初始化为任意值**'
- en: You can initialize fields to arbitrary values using braced initializers. The
    arguments within braced initializers must match types with POD members. The order
    of arguments from left to right matches the order of members from top to bottom.
    Any omitted members are zeroed. Members `a` and `b` initialize to `42` and `Hello`
    after the initialization of `initialized_pod3` ➌, and `c` is zeroed (set to false)
    because you omitted it from the braced initialization. The initialization of `initialized_pod4`
    ➍ includes an argument for `c` (`true`), so its value is set to true after initialization.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用花括号初始化器将字段初始化为任意值。花括号初始化器中的参数必须与POD成员的类型匹配。参数从左到右的顺序与成员从上到下的顺序匹配。任何省略的成员都会被置为零。成员`a`和`b`在初始化`initialized_pod3`
    ➌ 后分别初始化为`42`和`Hello`，而`c`则被置为零（设置为false），因为你在花括号初始化中省略了它。`initialized_pod4` ➍
    的初始化包括了`c`的参数（`true`），因此其值在初始化后被设置为true。
- en: 'The equals-plus-braces initialization works identically. For example, you could
    replace ➍ with this:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 等号加花括号初始化的工作方式完全相同。例如，你可以将 ➍ 替换为：
- en: '[PRE43]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can only omit fields from right to left, so the following won’t compile:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能从右到左省略字段，因此以下代码无法编译：
- en: '[PRE44]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**WARNING**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*You cannot use parentheses to initialize PODs. The following will not compile:*'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '*你不能使用圆括号来初始化POD类型。以下代码无法编译：*'
- en: '[PRE45]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '**Initializing Arrays**'
  id: totrans-410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**初始化数组**'
- en: You initialize arrays like PODs. The main difference between array and POD declarations
    is that arrays specify length. Recall that this argument goes in square brackets
    `[]`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 你像初始化POD类型一样初始化数组。数组和POD声明的主要区别在于数组指定了长度。回想一下，这个参数写在方括号`[]`中。
- en: When you use braced initializers to initialize arrays, the length argument becomes
    optional; the compiler can infer the size argument from the number of braced initializer
    arguments.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用花括号初始化器来初始化数组时，长度参数变得可选；编译器可以根据花括号初始化器中的参数数量推断出大小参数。
- en: '[Listing 2-25](ch02.xhtml#ch02ex25) illustrates some ways to initialize an
    array.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-25](ch02.xhtml#ch02ex25)展示了初始化数组的一些方法。'
- en: '[PRE46]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*Listing 2-25: A program listing various ways to initialize an array*'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-25：一个程序列出初始化数组的各种方式*'
- en: The array `array_1` has length three, and its elements equal 1, 2, and 3 ➊.
    The array `array_2` has length five because you specified a length argument ➋.
    The braced initializer is empty, so all five elements initialize to zero. The
    array `array_3` also has length five, but the braced initializer is not empty.
    It contains three elements, so the remaining two elements initialize to zero ➌.
    The array `array_4` has no braced initializer, so it contains uninitialized objects
    ➍.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 数组`array_1`的长度为三，元素值为1、2和3 ➊。数组`array_2`的长度为五，因为你指定了长度参数 ➋。花括号初始化器为空，因此所有五个元素初始化为零。数组`array_3`的长度也是五，但花括号初始化器不为空。它包含三个元素，因此剩余的两个元素初始化为零
    ➌。数组`array_4`没有花括号初始化器，因此它包含未初始化的对象 ➍。
- en: '**WARNING**'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Whether `array_4` is initialized or not actually depends on the same rules
    as does initializing a fundamental type. The object’s storage duration, which
    you’ll learn about in “An Object’s Storage Duration” on [page 89](ch04.xhtml#page_89),
    determines the rules. You don’t have to memorize these rules if you’re explicit
    about initialization*.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '*`array_4`是否初始化实际上取决于与初始化基本类型相同的规则。对象的存储持续时间，你将在《对象的存储持续时间》章节中学习，位于[第89页](ch04.xhtml#page_89)，决定了这些规则。如果你明确初始化，这些规则无需记忆*。'
- en: '**Fully Featured Classes**'
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**完全特性的类**'
- en: Unlike fundamental types and PODs, fully featured classes are *always initialized*.
    In other words, one of a fully featured class’s constructors always gets called
    during initialization. Which constructor is called depends on the arguments given
    during initialization.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 与基本类型和POD类型不同，完全特性的类*总是被初始化*。换句话说，完全特性类的构造函数在初始化过程中总是会被调用。调用哪个构造函数取决于在初始化时提供的参数。
- en: The class in [Listing 2-26](ch02.xhtml#ch02ex26) helps clarify how to use fully
    featured classes.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-26](ch02.xhtml#ch02ex26)中的类有助于澄清如何使用完全特性的类。'
- en: '[PRE47]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 2-26: A class announcing which of its several constructors gets called
    during initialization*'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-26：一个类在初始化时宣布其调用的构造函数*'
- en: 'The `Taxonomist` class has four constructors. If you supply no argument, the
    constructor with no arguments gets called ➊. If you supply a `char`, `int`, or
    `float` during initialization, the corresponding constructor gets called: ➋, ➌,
    or ➍, respectively. In each case, the constructor alerts you with a `printf` statement.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`Taxonomist`类有四个构造函数。如果不提供参数，将调用无参数构造函数➊。如果在初始化时提供了`char`、`int`或`float`，则分别调用相应的构造函数：➋、➌或➍。在每种情况下，构造函数会通过`printf`语句提醒你。'
- en: '[Listing 2-27](ch02.xhtml#ch02ex27) initializes several `Taxonomists` using
    different syntaxes and arguments.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-27](ch02.xhtml#ch02ex27)使用不同的语法和参数初始化了几个`Taxonomists`。'
- en: '[PRE48]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Listing 2-27: A program using the `Taxonomist` class with various initialization
    syntaxes*'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-27：一个程序使用`Taxonomist`类的各种初始化语法*'
- en: Without any braces or parentheses, the no argument constructor gets called ➊.
    Unlike with POD and fundamental types, you can rely on this initialization no
    matter where you’ve declared the object. With braced initializers, the `char`
    ➋, `int` ➌, and `float` ➍ constructors get called as expected. You can also use
    parentheses ➎ and the equals-plus-braces syntaxes ➏; these invoke the expected
    constructors.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有任何花括号或圆括号，将调用无参数构造函数➊。与POD和基本类型不同，你可以依赖这种初始化，无论你在哪里声明该对象。使用花括号初始化器时，`char`
    ➋，`int` ➌和`float` ➍构造函数按预期调用。你还可以使用圆括号➎和等号加花括号语法➏；这些都会调用预期的构造函数。
- en: Although fully featured classes always get initialized, some programmers like
    the uniformity of using the same initialization syntax for all objects. This is
    no problem with braced initializers; the default constructor gets invoked as expected
    ➐.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管功能完整的类总是会被初始化，但有些程序员喜欢对所有对象使用相同的初始化语法以保持统一性。使用大括号初始化器时，这没有问题；默认构造函数会按预期被调用
    ➐。
- en: Unfortunately, using parentheses ➑ causes some surprising behavior. You get
    no output.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，使用圆括号 ➑ 会导致一些令人惊讶的行为。你不会得到任何输出。
- en: If you squint a little bit, this initialization ➑ looks like a function declaration,
    and that’s because it is. Because of some arcane language-parsing rules, what
    you’ve declared to the compiler is that a yet-to-be-defined function `t8` takes
    no arguments and returns an object of type `Taxonomist`. Ouch.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你稍微眯一下眼睛，这个初始化 ➑ 看起来像一个函数声明，事实上它就是一个。由于一些晦涩的语言解析规则，你所声明给编译器的是一个尚未定义的函数`t8`，它不接受任何参数，并返回一个`Taxonomist`类型的对象。哎呀。
- en: '**NOTE**'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Function Declarations” on [page 244](ch09.xhtml#page_244) covers function
    declarations in more detail. But for now, just know that you can provide a function
    declaration that defines a function’s modifiers, name, arguments, and return type
    and then later provide the body in its definition*.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第244页](ch09.xhtml#page_244)的*函数声明*部分详细讲解了函数声明。但目前，你只需知道你可以提供一个函数声明，定义函数的修饰符、名称、参数和返回类型，然后在稍后的定义中提供函数体*。
- en: This widely known problem is called the *most vexing parse*, and it’s a major
    reason why the C++ community added braced initialization syntax to the language.
    *Narrowing conversions* are another problem.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这个广为人知的问题被称为*最烦人的解析*，也是C++社区将大括号初始化语法引入语言的主要原因之一。*窄化转换*是另一个问题。
- en: '**Narrowing Conversions**'
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**窄化转换**'
- en: 'Braced initialization will generate warnings whenever implicit narrowing conversions
    are encountered. This is a nice feature that can save you from nasty bugs. Consider
    the following example:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 每当遇到隐式窄化转换时，大括号初始化会生成警告。这是一个很好的功能，可以帮助你避免一些严重的错误。考虑以下示例：
- en: '[PRE49]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Dividing two `float` literals yields a float. When initializing `narrowed_result`
    ➊, the compiler silently narrows the result of `a/b` (0.5) to 0 because you’ve
    used parentheses `( )` to initialize. When you use braced initializers, the compiler
    generates a warning ➋.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个`float`字面量相除会得到一个float类型的结果。在初始化`narrowed_result` ➊时，编译器会默默地将`a/b`（0.5）的结果窄化为0，因为你使用了圆括号`(
    )`来初始化。当你使用大括号初始化器时，编译器会生成警告 ➋。
- en: '**Initializing Class Members**'
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**初始化类成员**'
- en: 'You can use braced initializers to initialize the members of classes, as demonstrated
    here:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用大括号初始化器来初始化类的成员，如此处所示：
- en: '[PRE50]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `gold` member is initialized using the equals initialization ➊, `year_of_smelting_accident`
    using braced initialization ➋, and `key_location` using braces-plus-equals initialization
    ➌. It’s not possible to use parentheses to initialize member variables.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`gold`成员使用等号初始化 ➊，`year_of_smelting_accident`使用大括号初始化 ➋，而`key_location`使用大括号加等号初始化
    ➌。不能使用圆括号来初始化成员变量。'
- en: '**Brace Yourself**'
  id: totrans-443
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**准备好大括号**'
- en: 'The options for initializing objects bewilder even experienced C++ programmers.
    Here’s a general rule to make initialization simple: *use braced initializers
    everywhere*. Braced initializers work as intended almost everywhere, and they
    cause the fewest surprises. For this reason, braced initialization is also called
    *uniform initialization*. The remainder of the book follows this guidance.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化对象的选项甚至让经验丰富的C++程序员感到困惑。这里有一个通用的规则，可以简化初始化过程：*在所有地方都使用大括号初始化器*。大括号初始化器几乎在所有情况下都能按预期工作，并且能带来最少的意外。因此，大括号初始化也被称为*统一初始化*。本书的其余部分都会遵循这一指导原则。
- en: '**WARNING**'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*You’ll break the use braced initializers everywhere rule for certain classes
    in C++ stdlib. [Part II](part02.xhtml#part02) will make these exceptions to the
    rule very clear.*'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '*在某些C++标准库类中，你将打破使用大括号初始化器的规则。第[二部分](part02.xhtml#part02)会清楚地阐明这些规则的例外情况。*'
- en: '***The Destructor***'
  id: totrans-447
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***析构函数***'
- en: 'An object’s *destructor* is its cleanup function. The destructor is invoked
    before an object is destroyed. Destructors are almost never called explicitly:
    the compiler will ensure that each object’s destructor is called as appropriate.
    You declare a class’s destructor with the tilde `~` followed by the name of the
    class.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象的*析构函数*是它的清理函数。析构函数在对象销毁之前被调用。析构函数几乎从不被显式调用：编译器会确保每个对象的析构函数在适当的时候被调用。你通过使用波浪符`~`后跟类的名称来声明一个类的析构函数。
- en: 'The following `Earth` class has a destructor that prints `Making way for hyperspace
    bypass`:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`Earth`类具有一个析构函数，打印`Making way for hyperspace bypass`：
- en: '[PRE51]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Defining a destructor is optional. If you do decide to implement a destructor,
    it must not take any arguments. Examples of actions you might want to take in
    a destructor include releasing file handles, flushing network sockets, and freeing
    dynamic objects.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 定义析构函数是可选的。如果决定实现析构函数，则它不能接受任何参数。你可能希望在析构函数中执行的操作包括释放文件句柄、刷新网络套接字和释放动态对象。
- en: If you don’t define a destructor, a default destructor is automatically generated.
    The default destructor’s behavior is to perform no action.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有定义析构函数，系统会自动生成一个默认析构函数。默认析构函数的行为是不会执行任何操作。
- en: You’ll learn a whole lot more about destructors in “Tracing the Object Life
    Cycle” on [page 96](ch04.xhtml#page_94).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在“追踪对象生命周期”章节中学习更多关于析构函数的内容，详见[第96页](ch04.xhtml#page_94)。
- en: '**Summary**'
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter presented the foundation of C++, which is its type system. You
    first learned about fundamental types, the building blocks of all other types.
    Then you continued with user-defined types, including the `enum class`, POD classes,
    and fully featured C++ classes. You capped off your tour of classes with a discussion
    of constructors, initialization syntax, and destructors.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了C++的基础知识，即其类型系统。你首先学习了基本类型，它们是所有其他类型的构建块。接着，你学习了用户定义的类型，包括`enum class`、POD类和完全特性的C++类。最后，你通过讨论构造函数、初始化语法和析构函数结束了对类的学习。
- en: '**COMMAND LINE NOTATION**'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令行符号**'
- en: '**2-1.** Create an `enum class Operation` that has values `Add`, `Subtract`,
    `Multiply`, and `Divide`.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '**2-1.** 创建一个`enum class Operation`，其值为`Add`、`Subtract`、`Multiply`和`Divide`。'
- en: '**2-2.** Create a `struct Calculator. It should have a single constructor that
    takes an Operation.`'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '**2-2.** 创建一个`struct Calculator`。它应该有一个构造函数，接受一个`Operation`。'
- en: '**2-3.** Create a method on `Calculator` called `int calculate(int a, int b)`.
    Upon invocation, this method should perform addition, subtraction, multiplication,
    or division based on its constructor argument and return the result.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '**2-3.** 在`Calculator`上创建一个名为`int calculate(int a, int b)`的方法。调用时，该方法应根据构造函数的参数执行加法、减法、乘法或除法，并返回结果。'
- en: '**2-4.** Experiment with different means of initializing `Calculator` instances.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '**2-4.** 尝试不同的方式初始化`Calculator`实例。'
- en: '**FURTHER READING**'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*ISO International Standard ISO/IEC (2017) – Programming Language C++* (International
    Organization for Standardization; Geneva, Switzerland; *[https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/))*'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ISO国际标准ISO/IEC（2017年）— C++编程语言*（国际标准化组织；瑞士日内瓦；* [https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)）'
- en: '*The C++ Programming Language*, 4th Edition, by Bjarne Stroustrup (Pearson
    Education, 2013)'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《C++程序设计语言》*，第4版，作者：Bjarne Stroustrup（Pearson Education，2013年）'
- en: '*Effective Modern C++* by Scott Meyers (O’Reilly Media, 2014)'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《有效的现代C++》*，作者：Scott Meyers（O’Reilly Media，2014年）'
- en: '*C++ Made Easier: Plain Old Data” by Andrew Koenig and Barbara E. Moo (Dr.
    Dobb’s, 2002; [http://www.drdobbs.com/c-made-easier-plain-old-data/184401508/](http://www.drdobbs.com/c-made-easier-plain-old-data/184401508/))*'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《C++简化：普通数据类型》*，作者：Andrew Koenig 和 Barbara E. Moo（Dr. Dobb’s，2002年；[http://www.drdobbs.com/c-made-easier-plain-old-data/184401508/](http://www.drdobbs.com/c-made-easier-plain-old-data/184401508/)）'
