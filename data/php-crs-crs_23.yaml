- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 18 DECLARING CLASSES AND CREATING OBJECTS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18 声明类并创建对象
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In this chapter, you’ll learn how to define the structure of a class by using
    a class-declaration file, and you’ll practice creating individual objects of that
    class. You’ll see that classes with public properties let you directly change
    an object’s data, while classes with private properties mean you can change an
    object’s data only via its methods, some of which can perform validation. You’ll
    also learn about PHP “magic” methods that make it easier to write object-oriented
    code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何通过使用类声明文件来定义类的结构，并练习创建该类的各个对象。您将看到，具有公共属性的类允许您直接更改对象的数据，而具有私有属性的类则意味着您只能通过其方法来更改对象的数据，其中一些方法可以执行验证。您还将学习PHP的“魔术”方法，这些方法使编写面向对象的代码变得更容易。
- en: Declaring a Class
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明类
- en: 'A *class declaration* defines a class: it lays out the properties (variables)
    each object of that class will have, as well as the methods (functions) that can
    act upon those properties. A class declaration also establishes any relationship
    that class has with other classes (such as inheritance, which you’ll learn about
    in [Chapter 19](chapter19.xhtml)).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*类声明*定义了一个类：它列出了该类的每个对象将拥有的属性（变量），以及可以作用于这些属性的方法（函数）。类声明还建立了该类与其他类的任何关系（例如继承，您将在[第19章](chapter19.xhtml)中学习到）。'
- en: Like function declarations, class declarations are stored in PHP files in the
    *src* directory of a project. For all the projects in this book, each class will
    be declared in its own file; if a project has five classes, it will have five
    class-declaration files, and so on.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 像函数声明一样，类声明存储在项目的*src*目录中的PHP文件中。对于本书中的所有项目，每个类将声明在其自己的文件中；如果一个项目有五个类，那么它将有五个类声明文件，依此类推。
- en: NOTE
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*In this book, we won’t explore the advanced topic of* anonymous classes*,
    which is one of the few cases where more than one class may be declared in a single
    file. You can learn more at* [https://www.php.net/manual/en/language.oop5.anonymous.php](https://www.php.net/manual/en/language.oop5.anonymous.php)*.*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本书中，我们不会探讨*匿名类*这一高级主题，它是少数几个可以在一个文件中声明多个类的情况之一。您可以在[https://www.php.net/manual/en/language.oop5.anonymous.php](https://www.php.net/manual/en/language.oop5.anonymous.php)了解更多信息。*'
- en: By a well-established convention in OOP, both class names and class-declaration
    filenames always start with a capital letter. If the name includes multiple words,
    each word should start with a capital letter, with no spaces between the words.
    This is known as *upper camel case*, or sometimes *Pascal case*. Examples of valid
    class names include Product, NetworkSupplier, DesktopComputer, ReferenceBook,
    and InventoryItem.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据面向对象编程（OOP）中的约定，类名和类声明文件名始终以大写字母开头。如果名称包含多个单词，每个单词应以大写字母开头，且单词之间不应有空格。这被称为*大驼峰命名法*，有时也称为*Pascal命名法*。有效的类名示例包括Product、NetworkSupplier、DesktopComputer、ReferenceBook和InventoryItem。
- en: Throughout this chapter, we’ll work with a class called Product that can represent
    various items for sale through an e-commerce site. Let’s declare it now. Create
    a new directory for a new project, and in it create a *src* directory. In this
    *src* directory, create a *Product.php* file and enter the contents of [Listing
    18-1](#lis18-1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一个名为Product的类，它可以表示通过电子商务网站销售的各种商品。现在让我们来声明它。创建一个新目录用于新项目，并在其中创建一个*src*目录。在此*src*目录中，创建一个*Product.php*文件并输入[列表18-1](#lis18-1)的内容。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 18-1: The Product.php file to declare the Product class'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18-1：声明Product类的Product.php文件
- en: 'We start with the standard PHP beginning code tag, since we use PHP code to
    declare classes. Then we use the class keyword to state that we’re declaring a
    new class named Product. After the class name, enclosed in curly brackets, we
    define any properties or methods that will be associated with objects of that
    class. In this example, we declare two properties for each object of the Product
    class: name, which will be a string, and price, which will be a float. We declare
    both properties as public, meaning any part of our program with access to a Product
    object can read and change the values of its properties. We’ll explore the implications
    of public properties later in the chapter.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从标准的 PHP 起始代码标签开始，因为我们使用 PHP 代码来声明类。接着我们使用 class 关键字来声明一个名为 Product 的新类。类名后面跟着大括号，我们在其中定义与该类对象相关的任何属性或方法。在这个例子中，我们为每个
    Product 类的对象声明了两个属性：name，类型为字符串，以及 price，类型为浮点数。我们将两个属性声明为 public，这意味着程序的任何部分，只要能够访问
    Product 对象，都可以读取和修改其属性值。我们将在本章后面探讨 public 属性的含义。
- en: If we want all objects to have a *default value* for a property, we can assign
    a property a value in the class declaration. For example, if our system set an
    initial –1 price for every new Product object, we could have written public float
    $price = -1.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望所有对象在某个属性上都有一个*默认值*，我们可以在类声明中为该属性赋值。例如，如果我们的系统为每个新的 Product 对象设置一个初始的
    -1 价格，我们可以这样写：`public float $price = -1`。
- en: '[Figure 18-1](#fig18-1) shows a *Unified Modeling Language (UML)* class diagram
    visualizing the class we’ve just written. UML is a common tool for representing
    classes, objects, and their interactions through diagrams and text.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-1](#fig18-1) 显示了一个*统一建模语言（UML）*类图，直观地展示了我们刚刚编写的类。UML 是一种常用的工具，用于通过图表和文本表示类、对象及其交互。'
- en: '![](../images/figure18-1.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure18-1.jpg)'
- en: 'Figure 18-1: The Product class'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18-1：Product 类
- en: The top row of the diagram indicates the class name (Product), and the second
    row lists the properties associated with that class, along with the data type
    expected for each property. The plus sign before each property name indicates
    that the properties have public visibility.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图表的第一行表示类名（Product），第二行列出了与该类相关的属性，并显示了每个属性预期的数据类型。每个属性名前的加号表示这些属性具有公共可见性。
- en: Creating an Object
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建对象
- en: You use the PHP keyword new to create an object of a class. The new keyword
    is followed by the name of the class for which an object is to be created, then
    a set of parentheses. Inside the parentheses, you may pass arguments for initialization,
    as we’ll discuss in “Initializing Values with a Constructor Method” on [page 346](#pg_346).
    The general form of a statement to create an object is thus new ClassName(). Creating
    an object is also called *instantiation*, since the object is an *instance* of
    the class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 PHP 关键字 new 来创建类的对象。new 关键字后跟类的名称，然后是一对圆括号。在圆括号内，你可以传递初始化参数，正如我们在《使用构造方法初始化值》一节中讨论的那样，参见
    [第 346 页](#pg_346)。创建对象的语句的一般形式是 `new ClassName()`。创建对象也叫做*实例化*，因为该对象是该类的*实例*。
- en: By writing the new keyword and a class name, you’re asking PHP to create a new
    object of the named class. When an object is created in the computer’s memory
    with the new keyword, the PHP engine automatically returns a reference to the
    new object. In most cases, you’ll want to store the reference to that newly created
    object in a variable—for example, $myObject = new ClassName(). It’s important
    to understand that with such statements, the variable $myObject doesn’t actually
    contain the object itself, but rather a *reference to* the object. It’s possible
    for several variables, or none, to refer to a particular object in memory.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过写下新关键字和类名，你是在要求 PHP 创建一个指定类的新对象。当一个对象在计算机内存中使用 new 关键字创建时，PHP 引擎会自动返回对新对象的引用。在大多数情况下，你会希望将对该新创建对象的引用存储在一个变量中——例如，`$myObject
    = new ClassName()`。重要的是要理解，对于这样的语句，变量 `$myObject` 实际上并不包含对象本身，而是包含了*对*该对象的引用。多个变量，甚至没有变量，都有可能引用内存中的同一个对象。
- en: Once you have a reference to an object, use the *object operator* (->) to access
    properties and methods of that object. For example, you could write $myObject->description
    to access the description property of the object referred to by $myObject. Likewise,
    you could invoke a setDescription() method of an object by writing something like
    $myObject->setDescription('small carpet'). The parentheses or lack thereof are
    important, since they tell the PHP engine (and people reading the code) whether
    a statement is attempting to access a property (no parentheses present) or a method
    (parentheses present).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你引用了一个对象，使用*对象操作符*（->）来访问该对象的属性和方法。例如，你可以写 $myObject->description 来访问由 $myObject
    引用的对象的 description 属性。同样，你可以通过写类似 $myObject->setDescription('small carpet') 的代码来调用对象的
    setDescription() 方法。括号的有无很重要，因为它们告诉 PHP 引擎（以及阅读代码的人）一条语句是在访问属性（没有括号）还是在调用方法（有括号）。
- en: 'With all this in mind, let’s create an object. We’ll write an *index.php* script
    to read in the *Product.php* class-declaration file, create a Product object,
    and set the values of its properties. [Figure 18-2](#fig18-2) shows our goal:
    a $product1 variable that stores a reference to a Product object whose properties
    have the values ''hammer'' and 9.99.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些，我们来创建一个对象。我们将编写一个 *index.php* 脚本，读取 *Product.php* 类声明文件，创建一个 Product 对象，并设置它的属性值。[图18-2](#fig18-2)展示了我们的目标：一个
    $product1 变量，存储了对一个 Product 对象的引用，该对象的属性值为 'hammer' 和 9.99。
- en: '![](../images/figure18-2.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure18-2.jpg)'
- en: 'Figure 18-2: The $product1 variable references an object of the Product class.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-2：$product1 变量引用了一个 Product 类的对象。
- en: For simplicity, we’ll start by creating a Product object and setting only its
    name property. To make sure our code is working, we’ll also print the value of
    the object’s name property to the project’s home page. In your project directory,
    create a *public* folder, and in that folder create an *index.php* file containing
    the code in [Listing 18-2](#lis18-2).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，我们将从创建一个 Product 对象并仅设置它的 name 属性开始。为了确保我们的代码正常工作，我们还将打印该对象的 name 属性值到项目的主页。在你的项目目录中，创建一个
    *public* 文件夹，并在该文件夹中创建一个包含[清单18-2](#lis18-2)中代码的 *index.php* 文件。
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 18-2: An index.php script to create and manipulate a Product object'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 清单18-2：一个创建和操作 Product 对象的 index.php 脚本
- en: We read in the declaration for the Product class, using the __DIR__ magic constant
    to create a path from the location of this *index.php* file (in *public*) to the
    location of the *Product.php* file (in *src*). Then we use the new keyword to
    create a new object of the Product class. Since this class doesn’t require any
    initial values or options when creating objects, we don’t pass any arguments in
    the parentheses after the class name.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在声明 Product 类时，使用 __DIR__ 魔术常量从 *index.php* 文件所在位置（位于 *public* 文件夹内）创建路径到
    *Product.php* 文件所在位置（位于 *src* 文件夹内）。然后我们使用 new 关键字来创建一个 Product 类的新对象。由于该类在创建对象时不需要任何初始值或选项，我们在类名后面不传递任何参数。
- en: If you aren’t passing any arguments when you create a new object, PHP (unlike
    most object-oriented languages) allows you to omit the parentheses after the class
    name. Writing new Product() is the same as writing new Product. However, there
    are several good reasons to always include the parentheses, and so this is the
    style you’ll see throughout this book. Perhaps the most important reason to always
    use parentheses after the keyword new is to remind ourselves that a constructor
    method may be executed as the new object is created; we’ll look at such methods
    in “Initializing Values with a Constructor Method” on [page 346](#pg_346).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在创建新对象时没有传递任何参数，PHP（与大多数面向对象语言不同）允许你省略类名后面的括号。写 new Product() 和写 new Product
    是等价的。然而，有几个很好的理由总是包含括号，因此你将在本书中看到这种风格。也许最重要的理由是，始终在 new 关键字后使用括号可以提醒我们，构造方法可能会在新对象创建时执行；我们将在“使用构造方法初始化值”章节中讨论这类方法，详见[第346页](#pg_346)。
- en: The new Product() expression creates the new object and returns a reference
    to it, which we store in the $product1 variable. To reiterate, $product1 doesn’t
    contain the object itself, nor does it contain a copy of the object. It contains
    just a *reference to* the object created in the computer system’s memory. In “Object
    Variables as References” on [page 351](#pg_351), we’ll have two variables refer
    to the same object to help illustrate this concept.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `Product()` 表达式创建了一个新对象，并返回一个对它的引用，我们将这个引用存储在 `$product1` 变量中。为了重申，`$product1`
    并不包含对象本身，也不包含对象的副本。它仅仅包含一个指向计算机系统内存中创建的对象的*引用*。“对象变量作为引用”一节在 [第351页](#pg_351)
    中，我们将用两个变量引用同一个对象来帮助说明这个概念。
- en: Next, we set the value of the object’s name property to the string 'hammer';
    we can do this because the property was declared as public. We use the object
    operator (->) after the $product1 variable to refer to the name property of that
    object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对象的名称属性值设置为字符串 'hammer'；我们之所以能这样做，是因为该属性被声明为 public。我们在 `$product1` 变量后使用对象操作符
    `->` 来引用该对象的名称属性。
- en: '> WARNING'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '> 警告'
- en: '*Do* not *write a dollar sign after the* -> *characters:* $product->name *is
    correct, and* $product->$name *is wrong. The PHP engine won’t create a warning
    or error if you write the latter, but it will interpret the code as meaning there’s
    a variable called* $name *whose value is the name of a property you want to access
    on the* $product *object. This is very different from accessing the value of the*
    $product *object’s* name *property. If your code is behaving strangely, check
    for this possible programming mistake.*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要* 在 `->` *字符后写美元符号*：`$product->name` *是正确的，而* `$product->$name` *是错误的。如果你写后者，PHP
    引擎不会产生警告或错误，但它会将代码解释为：有一个名为* `$name` *的变量，其值是你想访问的* `$product` *对象上的属性名。这与访问*
    `$product` *对象的* name *属性的值是完全不同的。如果你的代码行为异常，请检查是否有这个编程错误。*'
- en: 'Finally, the script ends by printing a message featuring the value retrieved
    from the $product object’s name property. If you run the web server and visit
    the project’s home page, you should see this line of text displayed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，脚本通过打印一条消息来结束，消息中包含从 `$product` 对象的名称属性中检索到的值。如果你运行 web 服务器并访问项目的主页，你应该能看到这行文本显示出来：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The -> operator lets you manipulate any of an object’s public properties by
    name. Let’s update our script to set and display the price of the object as well
    as its name. Modify the *index.php* file as shown in [Listing 18-3](#lis18-3).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`->` 操作符允许你通过名称操作对象的任何公共属性。让我们更新脚本，以设置并显示对象的价格以及名称。修改 *index.php* 文件，如 [列表
    18-3](#lis18-3) 所示。'
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 18-3: Setting and displaying the product price in index.php'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18-3：在 `index.php` 中设置并显示产品价格
- en: We set the object’s price property to 9.99 following the same format we used
    in [Listing 18-2](#lis18-2) to set the name property. Then we display the value
    of the property. Notice that this time we use a double-quoted string to combine
    the message and property value. This illustrates that in double-quoted strings,
    a reference to a public property of an object, such as $product1->price, will
    be parsed and the resulting value will be output, just as with a simple variable.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对象的价格属性设置为 9.99，格式与 [列表 18-2](#lis18-2) 中设置名称属性时使用的格式相同。然后我们显示该属性的值。请注意，这次我们使用双引号字符串将消息和属性值组合在一起。这说明在双引号字符串中，指向对象公共属性的引用，例如
    `$product1->price`，将被解析，结果值将被输出，就像简单变量一样。
- en: 'Visiting the home page again, you should see both the product name and price
    displayed:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 再次访问主页时，你应该能看到产品名称和价格显示出来：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We’ve now created an object of the Product class, and since the class’s properties
    are public, we were able to set and retrieve the properties’ values directly.
    In practice, however, most classes are written with private rather than public
    properties.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了一个 `Product` 类的对象，并且由于该类的属性是 public，我们可以直接设置和获取这些属性的值。然而，在实际开发中，大多数类会使用
    private 而不是 public 属性。
- en: Private Properties with Public Accessor Methods
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有公共访问器方法的私有属性
- en: When properties are declared as private, they can’t be accessed by code outside
    the class declaration itself. Instead, they’re available through public *accessor
    methods*, functions that allow object property values to be retrieved (*getter
    methods*) or updated (*setter methods*). This mechanism of private properties
    with public accessor methods reduces the risk of invalid property values; when
    changes to a property must take place through a setter method, you can implement
    validation logic as part of the method (for example, preventing negative values
    or out-of-range values). Also, related properties or other objects might need
    to be updated together, such as the balance of one bank account being reduced
    by the same value that another account is increased. With setter methods and private
    properties, you can easily enforce such rules so that the data in the application
    stays correct and internally consistent.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性声明为private时，它们不能被类声明外的代码访问。相反，它们可以通过公共的*访问器方法*来访问，这些方法允许检索（*getter方法*）或更新（*setter方法*）对象属性值。使用私有属性和公共访问器方法的机制可以减少无效属性值的风险；当必须通过setter方法修改属性时，可以在方法中实现验证逻辑（例如，防止负值或超出范围的值）。此外，相关属性或其他对象可能需要一起更新，比如一个银行账户的余额减少与另一个账户的余额增加相同的数值。通过setter方法和私有属性，可以轻松强制执行这些规则，以确保应用程序中的数据保持正确且内部一致。
- en: The default visibility for class members is public, so if no access modifier
    is provided for a property, the PHP engine will automatically declare it as having
    public visibility. Even with this default behavior, it’s still good practice to
    explicitly use the public access modifier in the class declaration when you want
    a class member to have public visibility. Otherwise, use the private access modifier
    to make the member private.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 类成员的默认可见性是public，因此如果没有为属性提供访问修饰符，PHP引擎会自动将其声明为具有public可见性。即使有默认行为，当你希望类成员具有public可见性时，最好在类声明中明确使用public访问修饰符。否则，使用private访问修饰符将成员声明为私有。
- en: NOTE
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*In addition to* public *and* private*, a third access modifier,* protected*,
    can be used in conjunction with inheritance. We’ll explore this topic in [Chapter
    19](chapter19.xhtml).*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了*public*和*private*，还有第三种访问修饰符，*protected*，可以与继承一起使用。我们将在[第19章](chapter19.xhtml)中探讨这个话题。
- en: For PHP and almost all OOP languages, a getter or setter method’s name usually
    starts with the word *get* or *set*, followed by the property name the method
    affects, with its first letter capitalized. According to this convention, the
    getter method for the name property of our Product class should be getName(),
    and its setter method should be setName(). For the price property, the methods
    should be getPrice() and setPrice(). An exception to this convention is made when
    a property contains a Boolean true/false value. In this case, naming the getter
    method isPropertyName rather than getPropertyName is customary. For example, if
    the Product class had a dangerousItem property that contained true or false, its
    getter would be named isDangerousItem().
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PHP和几乎所有的OOP语言，getter或setter方法的名称通常以*get*或*set*开头，后跟该方法影响的属性名称，并且首字母大写。根据这一惯例，我们的Product类的name属性的getter方法应为getName()，setter方法应为setName()。对于price属性，方法应为getPrice()和setPrice()。这个惯例的例外情况是当属性包含一个布尔值（true/false）时。在这种情况下，getter方法通常命名为isPropertyName，而不是getPropertyName。例如，如果Product类有一个名为dangerousItem的属性，其值为true或false，那么getter方法应命名为isDangerousItem()。
- en: A getter method usually returns a value of the same data type as the property
    it’s paired with (although sometimes we have multiple getter methods for different
    representations of an object’s property, such as methods to return both rounded-up
    integer and float values of a float property). A setter method usually takes in
    a parameter of the same type and stores its value in the property, perhaps conducting
    validation checks in the process. Usually, setter methods don’t return any value
    and so are declared to return void.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: getter方法通常返回与它所配对的属性相同数据类型的值（尽管有时我们会为对象属性的不同表示形式编写多个getter方法，例如返回浮动属性的四舍五入整数和浮动值的方法）。setter方法通常接收一个相同类型的参数，并将其值存储在属性中，可能在过程中进行验证检查。通常，setter方法不会返回任何值，因此它们声明为返回void。
- en: Let’s revise the declaration for the Product class, making its name and price
    properties private and adding four public accessor methods, two for each property.
    Update the *src/Product.php* file as shown in [Listing 18-4](#lis18-4).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改Product类的声明，将其name和price属性设为私有，并添加四个公共访问器方法，每个属性各两个。请按照[列表18-4](#lis18-4)所示更新*src/Product.php*文件。
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 18-4: Modifying the Product class to use getter and setter methods'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18-4：修改Product类以使用getter和setter方法
- en: First, we change the declaration of the two properties to private. Then we declare
    getName(), the public getter method for the name property ❶. Methods in classes
    can use the special pseudo-variable $this to reference the calling object; that
    is, $this is a stand-in for the object whose properties and methods we’re working
    with. Our getName() method thus returns the value in the name property of whichever
    Product object the method is currently being called on. The method has a string
    return type, since the name property is a string.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将两个属性的声明修改为私有。然后，我们声明getName()，这是name属性的公共getter方法❶。类中的方法可以使用特殊的伪变量$`this`来引用调用对象；也就是说，$this代表我们正在操作的对象的属性和方法。因此，我们的getName()方法返回当前调用该方法的Product对象的name属性值。该方法的返回类型是字符串，因为name属性是一个字符串。
- en: We next declare setName(), the public setter method for the name property ❷.
    This method takes in a new string name value through the $name parameter and stores
    this value in the name property for the current object, again using $this to reference
    the object. This setter method returns void. The getter and setter methods for
    price follow the same pattern.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明setName()，这是name属性的公共setter方法❷。该方法通过$name参数接收一个新的字符串name值，并将该值存储到当前对象的name属性中，再次使用$`this`来引用该对象。此setter方法没有返回值。price的getter和setter方法遵循相同的模式。
- en: Notice in the body of setName() how PHP distinguishes between the $name parameter
    and the name property for the current object ❸. The former is prefixed by a dollar
    sign, while the latter is attached to $this-> and doesn’t have a dollar sign to
    indicate it’s a property of the current object. In other words, $name in the setName()
    method unambiguously refers to the value of the argument passed to the method,
    while the private name property of the object that has been sent the setName()
    message is unambiguously referred to by $this->name. The same goes for the float
    $price parameter of the setPrice() method versus the price property of the object
    the method is being called on.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在setName()方法体内，PHP如何区分$name参数和当前对象的name属性❸。前者以美元符号$开头，而后者附加在$`this->`后面，并且没有美元符号，表示它是当前对象的属性。换句话说，setName()方法中的$name明确指的是传递给该方法的参数值，而通过setName()方法接收到消息的对象的私有name属性则通过$`this->name`明确指代。同样的情况适用于setPrice()方法中的float
    $price参数和调用该方法的对象的price属性。
- en: When you write methods in a class-declaration file, you must always keep in
    mind that the same methods may be executed on zero, one, or thousands of objects,
    in response to objects receiving a message with the name of the method (and any
    required arguments). Although you may plan to create and use only one instance
    (object) of a class when you first write the declaration, a well-written class
    encapsulates the data (properties) and behavior (methods) for *any* object of
    that class. When you keep the general use in mind while programming, you can often
    use a class in other parts of the same project, or different projects altogether,
    with few or no changes required to the class declaration. Well-written class declarations
    lend themselves to reuse.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在类声明文件中编写方法时，必须时刻记住，同样的方法可能会在零个、一个或成千上万个对象上执行，这取决于对象收到带有方法名称（及任何必要参数）的消息。尽管你可能在编写声明时只打算创建并使用类的一个实例（对象），但一个编写良好的类封装了该类的*任何*对象的数据（属性）和行为（方法）。当你在编程时考虑到通用使用时，通常可以在同一个项目的其他部分，甚至是完全不同的项目中使用该类，而无需或几乎无需更改类声明。编写良好的类声明有助于复用。
- en: NOTE
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*While you can type out accessor methods yourself, many code editors, including
    PhpStorm, offer an automated feature to generate simple getter and setter methods
    for you. Autogenerating code is faster than typing it out by hand, and it ensures
    error-free scripts that follow PHP programming conventions.*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然你可以手动编写访问器方法，但许多代码编辑器，包括PhpStorm，提供了自动化功能来为你生成简单的getter和setter方法。自动生成代码比手动输入更快，并且可以确保生成遵循PHP编程规范的无错误脚本。*'
- en: Getting and Setting Private Properties
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取和设置私有属性
- en: Since the two properties of any Product object are now declared private, we
    can’t access them directly, such as by writing $product1->name or $product1->price.
    If you run the existing *index.php* script, you’ll get a fatal error about not
    being able to access the private name property. Instead, we have to read and modify
    these private properties by using their public accessor methods. [Listing 18-5](#lis18-5)
    shows how to update *index.php* to make use of these new methods.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任何 Product 对象的两个属性现在被声明为私有，我们无法直接访问它们，比如通过写 `$product1->name` 或 `$product1->price`。如果你运行现有的
    *index.php* 脚本，你会遇到一个关于无法访问私有 name 属性的致命错误。相反，我们必须通过使用它们的公共访问器方法来读取和修改这些私有属性。[列表
    18-5](#lis18-5) 显示了如何更新 *index.php* 来使用这些新方法。
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 18-5: Using accessor methods in index.php'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18-5：在 index.php 中使用访问器方法
- en: As in [Listing 18-3](#lis18-3), we create the $product1 object, set its properties,
    and print out those properties. This time, however, we rely entirely on accessor
    methods. We use setter methods to update the values of the object properties,
    such as $product1->setName('hammer'). Likewise, we use getter methods to retrieve
    values from the object, such as $product1->getName(). Thanks to these methods,
    the data in the $product1 object is safely encapsulated but still accessible.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在 [列表 18-3](#lis18-3) 中一样，我们创建了 $product1 对象，设置了它的属性，并打印出了这些属性。然而这次，我们完全依赖于访问器方法。我们使用
    setter 方法来更新对象属性的值，比如 `$product1->setName('hammer')`。同样，我们使用 getter 方法来从对象中获取值，比如
    `$product1->getName()`。得益于这些方法，$product1 对象中的数据被安全地封装，但仍然可以访问。
- en: Screening for Invalid Data
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 筛选无效数据
- en: One of the advantages of protecting the data properties of objects is that you
    can add validation logic to the setter methods to prevent invalid values from
    being stored in the properties. For example, most businesses probably wouldn’t
    want to set a negative price for a product (although something might be a free
    gift, so we’ll allow for a price of 0). We should therefore add an if statement
    to the setPrice() method that updates the stored price only if the new value is
    greater than or equal to 0\. [Listing 18-6](#lis18-6) shows how to update the
    method in *src/Product.php*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 保护对象数据属性的一个优点是，你可以向 setter 方法中添加验证逻辑，以防止无效值存储在属性中。例如，大多数企业可能不希望为产品设置负数价格（尽管某些东西可能是免费的赠品，因此我们会允许价格为
    0）。因此，我们应该在 setPrice() 方法中添加一个 if 语句，只有当新值大于或等于 0 时才更新存储的价格。[列表 18-6](#lis18-6)
    显示了如何更新 *src/Product.php* 中的方法。
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 18-6: Adding validation logic to the setPrice() method of the Product
    class'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18-6：向 Product 类的 setPrice() 方法添加验证逻辑
- en: In our validation logic, we confirm that the new $price argument is greater
    than or equal to 0 before setting the value of the object’s price property. To
    make sure the validation check works, we can update our *index.php* script to
    attempt to set an invalid, negative price value. We should see that the invalid
    values aren’t stored in the object. [Listing 18-7](#lis18-7) adds extra statements
    to *index.php* for two tests of the validation logic.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的验证逻辑中，我们确认新传入的 $price 参数大于或等于 0，然后再设置对象的价格属性。为了确保验证检查有效，我们可以更新 *index.php*
    脚本，尝试设置一个无效的负价格值。我们应该看到无效值不会被存储在对象中。[列表 18-7](#lis18-7) 为 *index.php* 添加了额外的语句，用于验证逻辑的两次测试。
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 18-7: Testing the setter validation logic in index.php'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18-7：在 index.php 中测试 setter 验证逻辑
- en: 'As before, we create a new Product object and set its price to 9.99. Then we
    try to set the price to an invalid negative value, and then a valid positive value
    that’s different from its initial value, printing the product price each time.
    Here’s the output of this script in the browser:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们创建一个新的 Product 对象并将其价格设置为 9.99。然后我们尝试将价格设置为无效的负数值，再设置一个有效的正数值，这个值与初始值不同，并且每次都打印出产品价格。以下是该脚本在浏览器中的输出：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For test 1 (a negative price of -0.5), the stored price remains unchanged at
    9.99. For test 2 (a nonnegative value of 22), the stored price is updated. Our
    validation logic has worked. In this example, we simply ignored the invalid value,
    but it’s generally better to somehow indicate that there was a problem. One option
    is for setters to return a Boolean false value when no value was set. Another
    option is to throw an Exception object, as we’ll explore in [Chapter 23](chapter23.xhtml).  ###
    Overriding Default Class Behavior with Magic Methods'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试 1（负价格 -0.5），存储的价格保持不变，仍为 9.99。对于测试 2（非负值 22），存储的价格被更新。我们的验证逻辑已经起作用。在这个例子中，我们只是忽略了无效值，但通常最好以某种方式表明存在问题。一种选择是，当没有设置值时，setters返回布尔值false。另一种选择是抛出一个异常对象，我们将在[第23章](chapter23.xhtml)中讨论。
- en: PHP offers several *magic methods* that override default behavior of an object.
    For example, the __construct() magic method overrides the default way objects
    of a class are created, and the __toString() magic method overrides the way objects
    are handled in print statements and other contexts requiring a string. We’ll explore
    each of these magic methods in this section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: PHP提供了多个*魔术方法*，用于重写对象的默认行为。例如，__construct()魔术方法重写了创建类的对象的默认方式，而__toString()魔术方法重写了在打印语句和其他需要字符串的上下文中处理对象的方式。在本节中，我们将逐一探讨这些魔术方法。
- en: Despite their name, magic methods are unrelated to PHP magic constants. Magic
    methods are a feature of object-oriented PHP, allowing the default behavior of
    an object to be changed. All magic methods have names beginning with double underscore
    characters (__); therefore, you should name methods with such a prefix only when
    declaring a magic method for a class. You can find a list of all the PHP magic
    methods at *[https://www.php.net/manual/en/language.oop5.magic.php](https://www.php.net/manual/en/language.oop5.magic.php)*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名称中有“魔术”二字，魔术方法与PHP的魔术常量无关。魔术方法是面向对象PHP的一个特性，它允许更改对象的默认行为。所有魔术方法的名称都以双下划线（__）开头；因此，当你为类声明一个魔术方法时，应以此前缀命名方法。你可以在*[https://www.php.net/manual/en/language.oop5.magic.php](https://www.php.net/manual/en/language.oop5.magic.php)*中找到所有PHP魔术方法的列表。
- en: Initializing Values with a Constructor Method
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用构造方法初始化值
- en: It’s common to want to set some (or all) of an object’s properties as soon as
    that object has been created. As shown in [Listing 18-5](#lis18-5), you can do
    this by first creating an object and then having a sequence of statements invoking
    setter methods to set values for each property. However, initializing object properties
    immediately after creating an object is such a common requirement that PHP enables
    you to combine these actions into a single step by writing a magic method called
    a *constructor* as part of the class declaration.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望在创建对象后立即设置该对象的一些（或所有）属性。如[清单 18-5](#lis18-5)所示，你可以通过首先创建对象，然后依次调用setter方法来设置每个属性的值。然而，立即在创建对象后初始化对象属性是一个非常常见的需求，因此PHP允许你通过编写一个名为*构造函数*的魔术方法，将这些操作合并为一步，并将其作为类声明的一部分。
- en: 'Every class-declaration file either declares no constructor method (as you’ve
    seen so far in this chapter) or declares a single constructor magic method named
    __construct(). It’s magic in the sense that it overrides the default way of creating
    an object: creating it without setting any of its properties. The __construct()
    method takes in a series of parameters and assigns them as initial values of the
    newly created object’s properties. Using a constructor method in an *index.php*
    file is as simple as providing the initial values as arguments in the parentheses
    after the class name: $myObject = new ClassName($value1, $value2), for example.
    Thanks to the use of the new keyword, PHP automatically links the arguments with
    the constructor, even though __construct() isn’t called explicitly.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类声明文件要么不声明构造方法（如本章前面所述），要么声明一个名为__construct()的单一构造魔术方法。它被称为“魔术”是因为它重写了创建对象的默认方式：在不设置任何属性的情况下创建对象。__construct()方法接收一系列参数，并将它们作为新创建的对象属性的初始值。例如，在*index.php*文件中使用构造方法，只需在类名后的小括号内提供初始值作为参数：$myObject
    = new ClassName($value1, $value2)。得益于new关键字的使用，PHP会自动将参数与构造方法关联，即使__construct()没有显式调用。
- en: NOTE
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*PHP is quite unusual as an object-oriented language in that the constructor
    method doesn’t have the same name as the class. In most other object-oriented
    languages, a* Product() *method in the* Product *class would be a constructor
    method, but in PHP, there’s nothing special about a method that has the same name
    as the class in which it’s declared.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*PHP 作为面向对象的语言有些不同，构造函数方法的名称并不与类名相同。在其他大多数面向对象语言中，`Product()` 方法在 `Product`
    类中将是构造函数方法，但在 PHP 中，方法名称与声明所在类名相同并没有什么特别之处。*'
- en: Setting properties as part of the constructor method can save some code when
    it comes to creating new objects. For example, if we know we’ll want to set the
    name and price properties upon creation of a Product object, we can add a constructor
    method to the Product class that takes in $name and $price arguments to set these
    properties automatically. That way, when we create our $product1 object in *index.php*,
    we can replace these three statements
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将属性作为构造函数方法的一部分来设置，可以在创建新对象时节省一些代码。例如，如果我们知道在创建 `Product` 对象时需要设置名称和价格属性，我们可以为
    `Product` 类添加一个构造函数方法，该方法接受 `$name` 和 `$price` 参数，自动设置这些属性。这样，当我们在 *index.php*
    中创建 `$product1` 对象时，就可以将以下三条语句替换为一条语句：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'with just a single statement:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 只需一条语句：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Update *Product.php* as shown in [Listing 18-8](#lis18-8) to add a constructor
    method that sets the name and price properties.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 *Product.php* 如[列表 18-8](#lis18-8)所示，添加一个构造函数方法来设置名称和价格属性。
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 18-8: Adding a constructor method to the Product class'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18-8：为 Product 类添加构造函数方法
- en: 'We declare a new __construct() method. It replaces the default no-parameter
    creation of an object via new Product() with a method requiring two parameters:
    the initial string name and float price values for the new Product object. Note
    that constructor methods don’t specify any return type. Within the __construct()
    method definition, we call the setName() and setPrice() methods, which we’ve already
    defined elsewhere in the Product class declaration, feeding them the $name and
    $price parameters. This may not seem easier than calling those methods in the
    *index.php* script, but as you start creating more instances of the same object,
    setting properties through the constructor quickly becomes much more efficient.
    This approach also ensures that exactly the same validation is applied when values
    are set at the time of object construction as when values are changed at a later
    time with a direct call to a setter method.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个新的 `__construct()` 方法。它通过要求两个参数（新 `Product` 对象的初始字符串 `name` 和 `float`
    类型的 `price` 值）来替代默认的无参创建对象方式 `new Product()`。请注意，构造函数方法不指定任何返回类型。在 `__construct()`
    方法定义中，我们调用了 `setName()` 和 `setPrice()` 方法，这些方法已经在 `Product` 类声明的其他地方定义过，并将 `$name`
    和 `$price` 参数传递给它们。虽然这看起来并不比在 *index.php* 脚本中调用这些方法更简单，但随着你开始创建更多相同对象的实例，通过构造函数设置属性会变得更高效。这种方法还确保了，在对象构造时设置值与之后通过直接调用
    setter 方法更改值时，所应用的验证完全相同。
- en: NOTE
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Many IDEs (such as PhpStorm) offer an interactive constructor method generator
    that enables you to add selected properties as parameters and have their values
    set by the generated constructor method code.*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*许多集成开发环境（例如 PhpStorm）提供了交互式构造函数生成器，允许你将选定的属性作为参数添加，并通过生成的构造函数代码设置它们的值。*'
- en: Listing 18-9 shows how to simplify *index.php* to take advantage of the new
    constructor method.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18-9 展示了如何简化 *index.php* 以利用新的构造函数方法。
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 18-9: The simpler index.php script, using the constructor method'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18-9：简化的 *index.php* 脚本，使用构造函数方法
- en: 'When we create the $product1 object, we pass the desired initial values for
    the name and price properties as arguments for the constructor. As noted previously,
    this collapses three lines of code (creating the object and setting each of its
    two properties) into a single line.  #### Converting Objects to Strings'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们创建 `$product1` 对象时，我们将所需的初始值（名称和价格属性）作为构造函数的参数传入。如前所述，这将把三行代码（创建对象并设置其两个属性）合并为一行。
    #### 将对象转换为字符串'
- en: It’s common to want to summarize the contents of an object as a string, sometimes
    to display details about the object, or sometimes for debugging and logging purposes.
    One common reason to convert objects to strings is to generate a list of objects
    for a web interface, such as a drop-down menu. [Figure 18-3](#fig18-3) shows an
    example drop-down menu with a list of some of the courses I teach.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象的内容总结为字符串是很常见的做法，有时用于显示对象的详细信息，有时用于调试和记录目的。将对象转换为字符串的一个常见原因是生成 Web 界面上的对象列表，例如下拉菜单。[图
    18-3](#fig18-3) 显示了一个包含我教授的一些课程的下拉菜单示例。
- en: '![](../images/figure18-3.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure18-3.jpg)'
- en: 'Figure 18-3: A list of courses summarized as strings'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18-3：作为字符串总结的课程列表
- en: You can imagine that each of these courses is represented in PHP by a Course
    object, which has properties like courseNumber and courseName. To generate the
    drop-down menu, PHP converts each Course object to a string in the form courseNumber
    - courseName, such as COMP H2029 - Web Development Server-Side. These strings
    can then be fed into the HTML code for displaying the menu.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，这些课程中的每一门都在 PHP 中由一个 Course 对象表示，拥有像 courseNumber 和 courseName 这样的属性。为了生成下拉菜单，PHP
    会将每个 Course 对象转换为字符串，格式为 courseNumber - courseName，例如 COMP H2029 - Web Development
    Server-Side。然后，这些字符串可以传递到 HTML 代码中，用于显示菜单。
- en: 'How does that conversion to a string happen? Most object-oriented languages,
    including PHP, offer a way to implement a special method to return a string when
    an object is used in an expression that requires a string (for example, something
    like print $course1, where $course1 is a reference to a Course object). In PHP,
    this functionality comes from another magic method prefixed with two underscore
    characters: __toString().'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何将其转换为字符串呢？大多数面向对象的语言，包括 PHP，都提供了一种方法，在需要字符串的表达式中使用对象时返回一个字符串（例如，像 `print
    $course1` 这样的表达式，其中 $course1 是指向一个 Course 对象的引用）。在 PHP 中，这一功能来自另一个魔术方法，方法名前有两个下划线字符：__toString()。
- en: You don’t *have* to implement a __toString() method for every class, but if
    you know you’ll need a string summary of an object (such as for a drop-down HTML
    menu), or if you want to log details about objects to a report, then __toString()
    methods are useful. If a class has no __toString() method and you try to reference
    an object of that class in an expression requiring a string, you’ll get a could
    not be converted to string fatal error. Let’s see this happen by replacing the
    print statements at the end of our *index.php* script with print $product1. Update
    *index.php* to match [Listing 18-10](#lis18-10).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你并不*必须*为每个类实现 __toString() 方法，但如果你知道自己需要对象的字符串摘要（例如，用于下拉 HTML 菜单），或者你想将对象的详细信息记录到报告中，那么
    __toString() 方法是非常有用的。如果一个类没有 __toString() 方法，而你尝试在需要字符串的表达式中引用该类的对象，则会出现“无法转换为字符串”的致命错误。让我们通过将
    *index.php* 脚本末尾的 print 语句替换为 print $product1 来看看这个问题。更新 *index.php* 以匹配 [Listing
    18-10](#lis18-10)。
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 18-10: Trying to output details of an object via print in index.php'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 18-10：尝试在 index.php 中通过 print 输出对象的详细信息
- en: We pass the expression $product1 to a print statement. Because print statements
    expect a string expression and $product1 isn’t a string, PHP will try to convert
    it to one. Since the PHP engine can’t convert an object reference to a string
    without a __toString() method, a fatal error occurs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将表达式 $product1 传递给 print 语句。因为 print 语句期望的是字符串表达式，而 $product1 不是字符串，PHP 会尝试将其转换为字符串。由于
    PHP 引擎无法在没有 __toString() 方法的情况下将对象引用转换为字符串，因此会发生致命错误。
- en: Let’s now implement a __toString() method for our Product class, both to explore
    this common feature of OOP and to allow us to use the simplified *index.php* script
    in [Listing 18-10](#lis18-10). [Listing 18-11](#lis18-11) shows the new __toString()
    method added to the *src/Product.php* file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为 Product 类实现一个 __toString() 方法，既为了探索面向对象编程的这一常见特性，又为了让我们能够使用简化的 *index.php*
    脚本，参考 [Listing 18-10](#lis18-10)。[Listing 18-11](#lis18-11) 显示了新添加的 __toString()
    方法，该方法已被加入到 *src/Product.php* 文件中。
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 18-11: Adding a __toString() method to the Product class'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 18-11：为 Product 类添加 __toString() 方法
- en: We add a new __toString() method to the class. It contains a single statement
    that builds and returns a string summarizing the object property values. Note
    that we generalized the string message to start with '(Product) ' rather than
    'product 1 ' ❶. Since this is a method of a class and therefore will potentially
    be used by many objects, we shouldn’t hardcode the name of the variable referring
    to a particular object into the general class declaration file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为类添加了一个新的__toString()方法。这个方法包含一个简单的语句，用于构建并返回一个总结对象属性值的字符串。请注意，我们将字符串消息的一部分进行了泛化，改为从'(Product)
    '开头，而不是'product 1 '❶。由于这是类的方法，且可能会被多个对象使用，所以我们不应该在类的通用声明文件中硬编码引用特定对象的变量名称。
- en: 'Run the *index.php* script as it was updated in [Listing 18-10](#lis18-10),
    and you should see that the print $product1 statement works correctly, thanks
    to the new __toString() method.  ### Object Variables as References'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[列表18-10](#lis18-10)中更新的方式运行*index.php*脚本，你应该看到print $product1语句正确执行，这要归功于新增的__toString()方法。###
    对象变量作为引用
- en: As noted earlier, the $product1 variable used throughout this chapter is a reference
    to a Product object in memory, not a Product object itself. One implication of
    this distinction is that more than one variable can reference the same object
    in memory. This can occur in lots of ways. For example, it would happen when you
    need to loop through a collection of objects and perform actions on each. In this
    case, a temporary local variable would reference the current object being worked
    on, but the collection would also still have a separate reference to that object.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，贯穿本章的$product1变量是指向内存中一个Product对象的引用，而不是Product对象本身。这个区别的一个含义是，多个变量可以引用同一个内存中的对象。这种情况可能在很多场景下发生。例如，当你需要遍历一个对象集合并对每个对象进行操作时，就会出现这种情况。在这种情况下，一个临时的局部变量会引用当前正在处理的对象，而集合中也会持有对该对象的另一个引用。
- en: To see how object variables are just references to locations in memory, update
    *index.php* as shown in [Listing 18-12](#lis18-12). In this code, we create $variable2,
    make it a reference to the same object as $product1, and change one of the object’s
    properties through $variable2. As you’ll see, this change impacts the object referenced
    by $product1 as well, proving both variables are referencing the same object.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看对象变量如何只是内存位置的引用，请更新*index.php*，如[列表18-12](#lis18-12)所示。在这段代码中，我们创建了$variable2，使其引用与$product1相同的对象，并通过$variable2修改了该对象的一个属性。如你所见，这一修改同样影响了$product1引用的对象，证明了这两个变量引用的是同一个对象。
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 18-12: Updating index.php to illustrate how object variables are references'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18-12：更新index.php，演示对象变量是如何作为引用的
- en: 'We make $variable2 a reference to the same object as $product1 ❶. Then we call
    setPrice() to the object that $variable2 refers to, changing the value of the
    object’s price property to 20.00. We then print $product1 a second time. Since
    $product1 is a reference to an object, its __toString() method will be invoked.
    This produces the following output in the browser:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将$variable2设置为与$product1引用同一个对象❶。然后我们调用setPrice()方法，修改$variable2所引用的对象的价格属性，将其设置为20.00。接着我们第二次打印$product1。由于$product1是一个对象引用，它的__toString()方法将被调用。这会在浏览器中产生以下输出：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The object referenced by $product1 has had its price changed to 20, even though
    we made the price change through $variable2. Therefore, the two variables must
    be referencing the same object.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过$variable2修改价格时，$product1引用的对象的价格被改为了20。因此，这两个变量必须引用同一个对象。
- en: Handling Missing Objects
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理缺失对象
- en: Sometimes code is written in such a way that you expect a variable to refer
    to an object, but no such object is found. That variable would be NULL, so it’s
    often important to include checks for NULL when you’re writing object-oriented
    code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有时代码的编写方式是，你期望一个变量引用某个对象，但并未找到该对象。在这种情况下，该变量会是NULL，因此，在编写面向对象的代码时，通常需要包含NULL检查。
- en: Let’s consider an example. Imagine you’re writing code for a blog. To display
    a particular blog post, the code expects a valid ID of a blog post from an HTTP
    request, then uses that ID to retrieve data from a database and construct a Blog
    object. If no ID is found in the request, if the ID is invalid, or if the ID doesn’t
    match any item in the database, then the application can’t create a Blog object,
    and so the code would return NULL instead of an object reference.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个示例。假设你正在为一个博客编写代码。为了显示一篇特定的博客文章，代码期望从 HTTP 请求中获取一个有效的博客文章 ID，然后使用该 ID
    从数据库中检索数据并构建一个 Blog 对象。如果请求中没有找到 ID，或者 ID 无效，或者 ID 与数据库中的任何项都不匹配，那么应用程序就无法创建 Blog
    对象，因此代码会返回 NULL，而不是对象引用。
- en: To account for this situation, other code expecting to work with a Blog object
    would first test for NULL and then decide whether to deal with an invalid ID (say
    0 or negative) or with a successfully retrieved Blog object. [Listing 18-13](#lis18-13)
    shows an example method that might come from a database-driven blog website to
    illustrate this point.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这种情况，其他期望与 Blog 对象一起工作的代码会首先测试 NULL，然后决定是处理无效的 ID（比如 0 或负数），还是处理成功检索到的 Blog
    对象。[清单 18-13](#lis18-13)展示了一个示例方法，可能来自数据库驱动的博客网站，用来说明这一点。
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 18-13: Using a nullable return type'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 18-13：使用可空返回类型
- en: This blogFromId() method takes in a value for an $id and returns either a reference
    to a Blog object or NULL, using the nullable return type ?Blog. (We could also
    have written this as union return type Blog|NULL.) The method tests whether $id
    is numeric and greater than 0 ❶. If so, it passes the valid $id to the find()
    method of the blogRepository property and returns the value from this method (either
    NULL or the Blog object found for this ID in the database). If the $id isn’t valid,
    NULL is returned.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 blogFromId() 方法接受一个 $id 值，并返回一个 Blog 对象的引用或 NULL，使用可空返回类型 ?Blog。（我们也可以将其写作联合返回类型
    Blog|NULL。）该方法测试 $id 是否为数字且大于 0 ❶。如果是，它将有效的 $id 传递给 blogRepository 属性的 find()
    方法，并返回该方法的值（无论是 NULL 还是数据库中为此 ID 查找到的 Blog 对象）。如果 $id 无效，则返回 NULL。
- en: 'This example is making lots of assumptions, but the point is that the variable
    set to the result of calling the blogFromId() method will either have a reference
    to an object or be NULL. Code like this is quite common in OOP (as you’ll see
    in [Part VI](part6.xhtml)), which is why you often test for a NULL value of a
    variable you expect to be a reference to an object, to identify whether any object
    is being referred to. This compares to working with non-object-oriented PHP variables,
    where NULL can mean, for example, that a variable hasn’t been initialized or that
    no string value was received for a URL-encoded variable in an HTTP form submission.  ###
    Custom Methods and Virtual Attributes'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例做了很多假设，但关键是，调用 blogFromId() 方法的结果所赋值的变量，要么是指向一个对象的引用，要么是 NULL。像这样的代码在面向对象编程（OOP）中非常常见（如你将在[第六部分](part6.xhtml)中看到的），这也是为什么你经常需要测试一个你期望是对象引用的变量是否为
    NULL，以确定是否有对象被引用。这与处理非面向对象的 PHP 变量相比，其中 NULL 可能意味着，例如，变量尚未初始化，或 HTTP 表单提交中的 URL
    编码变量没有接收到任何字符串值。
- en: You can write all sorts of custom methods for a class, beyond the standard getters
    and setters and the __construct() and __toString() magic methods. Remember, methods
    are simply functions attached to a class of objects, so *custom methods* are functions
    to implement logic and calculations relating to objects of the class. For example,
    our Product class might come with a method for calculating the total price of
    a product, including tax. The tax rate will be a float value, such as 0.5 (for
    50 percent). Such a method would still be functioning as a getter, but instead
    of simply returning a stored property value, it would be dynamically calculating
    a value each time it’s invoked.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为一个类编写各种自定义方法，除了标准的 getter、setter 和 __construct() 及 __toString() 魔术方法。记住，方法只是附加在对象类上的函数，因此*自定义方法*是实现与类的对象相关的逻辑和计算的函数。例如，我们的
    Product 类可能会包含一个计算产品总价的方法，包括税费。税率将是一个浮动值，比如 0.5（即 50%）。这样的一个方法仍然可以作为 getter 使用，但与简单地返回存储的属性值不同，它会在每次调用时动态计算一个值。
- en: To see how it works, we’ll add a getPriceIncludingTax() method to our Product
    class declaration. The method will retrieve the tax rate and the pretax price
    of a product from the appropriate object properties, perform the necessary calculation,
    and return the total price with tax. For a tax rate of 0.1 (10 percent) and a
    price of 5.00, for instance, the method should return 1.1 * 5.00 = 5.50. To create
    the method, we also need to add a private taxRate property to the class, along
    with accessor methods for setting and getting the tax rate for a product.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看它是如何工作的，我们将在Product类声明中添加一个getPriceIncludingTax()方法。该方法将从相应的对象属性中获取税率和产品的税前价格，进行必要的计算，并返回包含税费的总价格。例如，对于一个税率为0.1（10%）且价格为5.00的产品，该方法应返回1.1
    * 5.00 = 5.50。为了创建这个方法，我们还需要在类中添加一个私有的taxRate属性，以及用于设置和获取产品税率的访问器方法。
- en: Listing 18-14 shows an updated *Product.php* class-declaration file. In addition
    to adding the taxRate property, its accessors, and the custom method, we also
    modify the __toString() method to display the results of the tax calculation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 示例18-14展示了更新后的*Product.php*类声明文件。除了添加taxRate属性、它的访问器和自定义方法外，我们还修改了__toString()方法，以显示税费计算的结果。
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 18-14: Adding the taxRate property and associated methods to the Product
    class'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 示例18-14：向Product类中添加taxRate属性及相关方法
- en: We declare the taxRate property ❶ along with its simple getter and setter methods
    ❷. Then we declare the getPriceIncludingTax() method ❸. It returns the price with
    the tax rate factored in.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了taxRate属性❶及其简单的getter和setter方法❷。然后，我们声明了getPriceIncludingTax()方法❸。该方法返回含税后的价格。
- en: 'As you can see, our getPriceIncludingTax() custom method is simply a function
    that performs a useful calculation for our class. In this case, it’s essentially
    an extra getter method that provides a variation on one of the class’s stored
    properties, price. In fact, it’s quite common in OOP to see what amounts to multiple
    getter methods for the same property of an object: methods that return pre- and
    post-tax prices of a product, methods that return the same property with different
    levels of precision (rounded to the nearest whole number versus including up to
    two decimal places), methods that retrieve the same property converted to different
    currencies or units (dollars versus euros, feet versus meters), and so on.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的getPriceIncludingTax()自定义方法只是一个为我们的类执行有用计算的函数。在这种情况下，它本质上是一个额外的getter方法，提供了对类存储属性price的变化。实际上，在面向对象编程中，看到多个getter方法用于同一对象属性是非常常见的：返回产品税前和税后价格的方法，返回同一属性但精度不同的方法（例如，四舍五入到最接近的整数或包括最多两位小数），以及返回相同属性转换成不同货币或单位的方法（如美元与欧元、英尺与米）等。
- en: 'In other cases, custom methods can act as *virtual attributes*: rather than
    provide a variation on an existing property, such methods perform calculations
    to arrive at a completely new piece of information. An example of a virtual attribute
    might be a method to calculate the age of a product. If products had a dateReceived
    property, the age of a product could be dynamically calculated as part of a getProductAge()
    method. The method would subtract dateReceived from the current date. In this
    case, the product’s age isn’t actually stored as a property of the object, but
    thanks to the getProductAge() method, the information is available as if it were
    a property.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，自定义方法可以充当*虚拟属性*：它们不仅提供现有属性的变体，还通过计算得到全新的信息。虚拟属性的一个例子可能是一个计算产品年龄的方法。如果产品有一个dateReceived属性，产品的年龄可以通过getProductAge()方法动态计算。该方法将当前日期减去dateReceived。在这种情况下，产品的年龄实际上并没有作为对象的属性存储，但由于有了getProductAge()方法，信息就像属性一样可以被获取。
- en: 'Custom methods highlight some of the power of OOP: the person writing code
    that uses a public getProductAge() method of a Product object doesn’t need to
    worry about how that method is implemented. All that counts is that the method
    works. If the implementation of the method is changed (perhaps changing the data
    type of the dateReceived property from stored MySQL datetime values to Linux timestamps)
    but its behavior remains correct and unchanged, it makes no difference to the
    parts of the system that are sending messages to Product objects and using the
    values returned by those methods.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义方法突显了OOP的一些强大功能：编写代码的人使用Product对象的public getProductAge()方法时，不需要担心该方法是如何实现的。唯一重要的是该方法能正常工作。如果方法的实现发生变化（例如将dateReceived属性的数据类型从存储的MySQL
    datetime值更改为Linux时间戳），但其行为保持正确且不变，那么这对系统中向Product对象发送消息并使用这些方法返回值的部分没有任何影响。
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered how to declare classes, how to read those declarations
    into an *index.php* file and use them to create objects, and how to invoke methods
    of objects to set and retrieve their property values. You saw how to protect an
    object’s data properties by declaring them as private, and how to use getter and
    setter methods declared as public to manage access to the object’s properties
    and perform validation where relevant. We also discussed how to perform common
    useful actions with PHP “magic” methods, such as creating new objects with some
    properties initialized via a constructor method and generating a string message
    representing an object’s properties by declaring a __toString() method.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何声明类，如何将这些声明读取到*index.php*文件并用它们创建对象，以及如何调用对象的方法来设置和获取它们的属性值。你了解了如何通过将对象的数据属性声明为private来保护对象的属性数据，以及如何使用声明为public的getter和setter方法来管理对对象属性的访问并在相关情况下进行验证。我们还讨论了如何使用PHP的“魔术”方法执行一些常见的有用操作，例如通过构造方法创建新对象并初始化某些属性，以及通过声明__toString()方法生成表示对象属性的字符串消息。
- en: Exercises
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '1.   Write a PHP class declaration for a Cat class, with public properties
    of name, breed, and age. Then write an *index.php* file to read in the class declaration
    and create a Cat object. Store a reference to the new object in a variable named
    $cat1 and set its properties as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   为Cat类编写PHP类声明，包含public属性name、breed和age。然后编写一个*index.php*文件来读取类声明并创建一个Cat对象。将对新对象的引用存储在名为$cat1的变量中，并按以下方式设置它的属性：
- en: name = 'Mr. Fluffy'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: name = 'Mr. Fluffy'
- en: breed = 'long-haired mix'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: breed = 'long-haired mix'
- en: age = 2
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: age = 2
- en: Finally, add statements to print the data values for each property of $cat1.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加语句来打印$cat1的每个属性的数据值。
- en: 2.   Write a PHP class declaration for a Pet class, with a private name property
    and public get and set accessor methods for this name variable. Then write an
    *index.php* file to read in the class declaration and create a Pet object referenced
    by a variable named $pet1. Use the setter to set its name to 'Fifi', and add a
    statement to print the name stored in this object.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   为Pet类编写PHP类声明，包含一个private的name属性，以及用于该name变量的public get和set访问器方法。然后编写一个*index.php*文件来读取类声明并创建一个由名为$pet1的变量引用的Pet对象。使用setter方法将其name设置为'Fifi'，并添加语句打印该对象存储的name。
- en: '3.   Add a constructor method to your Pet class so you can create new Pet objects
    with an initial value of the name variable by using a statement like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   为你的Pet类添加一个构造方法，这样你就可以使用类似以下的语句来创建具有初始值name变量的新Pet对象：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Update your *index.php* file to use this constructor method rather than setting
    the name with the setter method.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 更新你的*index.php*文件，使用此构造方法，而不是通过setter方法设置name。
- en: '4.   For the following properties and types, write their corresponding accessor
    (getter/setter) method names:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   对于以下属性和类型，编写它们对应的访问器（getter/setter）方法名称：
- en: age // integer
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: age // 整数
- en: houseNumber // integer
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: houseNumber // 整数
- en: color // string
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: color // 字符串
- en: length // float
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: length // 浮动值
- en: heavy // bool
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: heavy // 布尔值
