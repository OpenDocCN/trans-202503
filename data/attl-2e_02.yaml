- en: '2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '2'
- en: A BRIEF INTRODUCTION TO THE GNU AUTOTOOLS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: GNU Autotools简要介绍
- en: '*We shall not cease from exploration And the end of all our exploring Will
    be to arrive where we started And know the place for the first time.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将不会停止探索，所有探索的终点将是回到我们开始的地方，并第一次认识这个地方。  '
- en: '—T.S. Eliot, “Quartet No. 4: Little Gidding”*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ——T.S. 艾略特，《四重奏第4号：小吉丁》*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: 'As stated in the preface to this book, the purpose of the GNU Autotools is
    to make life simpler for the end user, not the maintainer. Nevertheless, using
    the Autotools will make your job as a project maintainer easier in the long run,
    although maybe not for the reasons you suspect. The Autotools framework is as
    simple as it can be, given the functionality it provides. The real purpose of
    the Autotools is twofold: it serves the needs of your users, and it makes your
    project incredibly portable—even to systems on which you’ve never tested, installed,
    or built your code.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书前言中所述，GNU Autotools的目的是为了简化最终用户的工作，而非维护者的工作。然而，长期使用Autotools将使你作为项目维护者的工作变得更加轻松，尽管这可能不是你所预期的原因。鉴于其提供的功能，Autotools框架尽可能简化。Autotools的真正目的是双重的：它满足用户的需求，并且使你的项目变得极其可移植——即使是在你从未测试、安装或构建过代码的系统上。
- en: 'Throughout this book, I will often use the term *Autotools*, although you won’t
    find a package in the GNU archives with this label. I use this term to signify
    the following three GNU projects, which are considered by the community to be
    part of the GNU build system:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我将经常使用*Autotools*这一术语，尽管你在GNU档案中找不到这个标签的包。我使用这个术语来指代以下三个GNU项目，这些项目被社区认为是GNU构建系统的一部分：
- en: Autoconf, which is used to generate a configuration script for a project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Autoconf，用于为项目生成配置脚本
- en: Automake, which is used to simplify the process of creating consistent and functional
    makefiles
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Automake，用于简化创建一致且功能完整的makefile的过程
- en: Libtool, which provides an abstraction for the portable creation of shared libraries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Libtool，用于提供便捷的跨平台共享库创建抽象
- en: Other build tools, such as the open source projects CMake and SCons, attempt
    to provide the same functionality as the Autotools but in a more user-friendly
    manner. However, because these tools attempt to hide much of their complexity
    behind GUI interfaces and script builders, they actually end up being less functional,
    and more difficult to manage, because the build system is not as transparent.
    In the final analysis, this transparency is what makes the Autotools both simpler
    to use and simpler to understand. Initial frustration with the Autotools, therefore,
    comes not from their complexity—for they are truly very simple—but from their
    extensive use of less well understood tools and subsystems, such as the Linux
    command shell (Bash), the `make` utility, and the M4 macro processor and accompanying
    macro libraries. Indeed, the meta-language provided by Automake is so simple it
    can be entirely digested and comprehended within a few hours of perusing the manual
    (though the ramifications of this meta-language may take a bit longer to thoroughly
    internalize).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 其他构建工具，如开源项目CMake和SCons，试图提供与Autotools相同的功能，但以更用户友好的方式实现。然而，由于这些工具试图通过图形界面和脚本生成器隐藏大部分复杂性，它们实际上变得功能更少，且更难以管理，因为构建系统不再那么透明。归根结底，这种透明性正是Autotools使其既易于使用又易于理解的原因。因此，最初对Autotools的挫败感并非来自其复杂性——因为它们实际上非常简单——而是来自于它们广泛使用了一些不太为人所熟知的工具和子系统，比如Linux命令行（Bash）、`make`工具以及M4宏处理器和随附的宏库。实际上，Automake提供的元语言是如此简单，以至于只需几个小时的手册阅读，就能完全消化和理解（尽管这种元语言的深层含义可能需要更多的时间来彻底内化）。
- en: Who Should Use the Autotools?
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 谁应该使用Autotools？
- en: If you’re writing open source software that targets Unix or Linux systems, you
    should absolutely be using the GNU Autotools, and even if you’re writing proprietary
    software for Unix or Linux systems, you’ll still benefit significantly from using
    them. The Autotools provide you with a build environment that allows your project
    to build successfully on future versions or distributions with virtually no changes
    to the build scripts. This is useful even if you only intend to target a single
    Linux distribution, because—let’s be honest—you really *can’t* know in advance
    whether or not your company will want your software to run on other platforms
    in the future.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写面向Unix或Linux系统的开源软件，你绝对应该使用GNU Autotools，即使你编写的是针对Unix或Linux系统的专有软件，使用Autotools仍然会带来显著的好处。Autotools为你提供了一个构建环境，使你的项目能够在未来版本或发行版中成功构建，而几乎无需修改构建脚本。即使你只打算针对单一的Linux发行版，这也是有用的，因为——说实话——你真的*无法*预知你的公司是否希望你的软件将来能在其他平台上运行。
- en: When Should You Not Use the Autotools?
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么时候不应该使用Autotools？
- en: About the only time it makes sense not to use the Autotools is when you’re writing
    software that will *only* run on non-Unix platforms, such as Microsoft Windows.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一不使用Autotools的合理情况是当你编写的软件*只*会在非Unix平台上运行，比如Microsoft Windows。
- en: Autotools support for Windows requires an Msys^([1](footnote.xhtml#ch02fn1))
    environment in order to work correctly, because Autoconf-generated configuration
    scripts are Bourne-shell scripts, and Windows doesn’t provide a native Bourne
    shell.^([2](footnote.xhtml#ch02fn2)) Unix and Microsoft tools are just different
    enough in command line options and runtime characteristics that it’s often simpler
    to use Windows ports of GNU tools, such as Cygwin, Msys2, or MinGW, to build Windows
    programs with an Autotools build system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Windows上的Autotools支持需要一个Msys^([1](footnote.xhtml#ch02fn1))环境才能正常工作，因为Autoconf生成的配置脚本是Bourne
    shell脚本，而Windows不提供原生的Bourne shell。^([2](footnote.xhtml#ch02fn2)) Unix和Microsoft工具在命令行选项和运行时特性上有些微差异，因此通常更简单的方法是使用GNU工具的Windows移植版本，如Cygwin、Msys2或MinGW，通过Autotools构建Windows程序。
- en: For these reasons, I’ll focus mostly on using the Autotools on POSIX-compliant
    platforms. Nevertheless, if you’re interested in trying out the Autotools on Windows,
    check out [Chapter 17](ch17.xhtml) for an in-depth overview.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些原因，我将主要集中在POSIX兼容平台上使用Autotools。然而，如果你有兴趣在Windows上尝试Autotools，可以参考[第17章](ch17.xhtml)获取详细概述。
- en: '**NOTE**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I’m not a typical Unix bigot. While I love Unix (and especially Linux), I
    also appreciate Windows for the areas in which it excels.^([3](footnote.xhtml#ch02fn3))
    For Windows development, I highly recommend using Microsoft tools. The original
    reasons for using GNU tools to develop Windows programs are more or less academic
    nowadays because Microsoft has made the better part of its tools available for
    download at no cost. For download information, see Visual Studio Community at*
    [https://visualstudio.microsoft.com/vs/express/](https://visualstudio.microsoft.com/vs/express/).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*我不是典型的Unix偏执者。虽然我热爱Unix（尤其是Linux），但我也欣赏Windows在其擅长的领域中的表现。^([3](footnote.xhtml#ch02fn3))
    对于Windows开发，我强烈推荐使用Microsoft工具。使用GNU工具开发Windows程序的初衷现在更像是学术上的讨论，因为Microsoft已经免费提供了大部分工具。有关下载信息，请参阅Visual
    Studio Community：[https://visualstudio.microsoft.com/vs/express/](https://visualstudio.microsoft.com/vs/express/)。*'
- en: Apple Platforms and Mac OS X
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 苹果平台和Mac OS X
- en: The Macintosh operating system has been POSIX compliant since 2007 when the
    “Leopard” release of macOS version 10 (OS X) was published. OS X is derived from
    NeXTSTEP/OpenStep, which is based on the Mach kernel, with parts taken from FreeBSD
    and NetBSD. As a POSIX-compliant operating system, OS X provides all the infrastructure
    required by the Autotools. The problems you’ll encounter with OS X will most likely
    involve Apple’s graphical user interface and package management systems, both
    of which are specific to the Mac.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Macintosh操作系统自2007年发布的macOS 10版本“Leopard”以来，一直是POSIX兼容的。OS X源自NeXTSTEP/OpenStep，基于Mach内核，并部分采用FreeBSD和NetBSD。作为一个POSIX兼容的操作系统，OS
    X提供了Autotools所需的所有基础设施。你在OS X上遇到的问题很可能涉及Apple的图形用户界面和软件包管理系统，这些是特定于Mac的。
- en: The user interface presents the same issues you encounter when dealing with
    the X Window system on other Unix platforms, and then some. The primary difference
    is that the X Window system is used exclusively on most Unix systems, but macOS
    has its own graphical user interface called *Cocoa*. While the X Window system
    can be used on the Mac (Apple provides a window manager that makes X applications
    look a lot like native Cocoa apps), Mac programmers will sometimes wish to take
    full advantage of the native user interface features provided by the operating
    system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面呈现了与在其他 Unix 平台上使用 X Window 系统时相遇的相同问题，甚至更多。主要区别在于，X Window 系统大多只用于 Unix
    系统，而 macOS 则有自己的图形用户界面，称为 *Cocoa*。虽然 X Window 系统可以在 Mac 上使用（苹果提供了一种窗口管理器，使得 X
    应用程序看起来像原生的 Cocoa 应用程序），但 Mac 程序员有时希望充分利用操作系统提供的本地用户界面功能。
- en: The Autotools skirt the issue of package management differences between Unix
    platforms by simply ignoring them. Instead, they create packages that are little
    more than compressed source archives using the `tar` and `gzip` utilities, and
    they install and uninstall products from the `make` command line. The macOS package
    management system is an integral part of installing an application on an Apple
    system, and projects like Fink (*[http://www.finkproject.org/](http://www.finkproject.org/)*)
    and MacPorts (*[http://www.macports.org/](http://www.macports.org/)*) help make
    existing open source packages available on the Mac by providing simplified mechanisms
    for converting Autotools packages into installable Mac packages.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Autotools 通过简单地忽略 Unix 平台之间的包管理差异来回避这个问题。相反，它们创建的包只是使用 `tar` 和 `gzip` 工具压缩的源代码归档，并通过
    `make` 命令行安装和卸载产品。macOS 的包管理系统是安装应用程序时的一个重要部分，像 Fink (*[http://www.finkproject.org/](http://www.finkproject.org/))*
    和 MacPorts (*[http://www.macports.org/](http://www.macports.org/))* 等项目通过提供简化的机制将
    Autotools 包转换为可安装的 Mac 包，帮助使现有的开源包在 Mac 上可用。
- en: The bottom line is that the Autotools can be used quite effectively on Apple
    Macintosh systems running OS X or later, as long as you keep these caveats in
    mind.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，只要记住这些注意事项，Autotools 在运行 OS X 或更高版本的 Apple Macintosh 系统上可以非常有效地使用。
- en: The Choice of Language
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语言选择
- en: 'Your choice of programming language is another important factor to consider
    when deciding whether to use the Autotools. Remember that the Autotools were designed
    by GNU people to manage GNU projects. In the GNU community, two factors determine
    the importance of a computer programming language:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 选择编程语言是决定是否使用 Autotools 时需要考虑的另一个重要因素。请记住，Autotools 是由 GNU 团队为管理 GNU 项目而设计的。在
    GNU 社区中，有两个因素决定计算机编程语言的重要性：
- en: Are there any GNU packages written in the language?
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有任何 GNU 软件包是用该语言编写的？
- en: Does the GNU compiler tool set support the language?
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU 编译器工具集是否支持该语言？
- en: 'Autoconf provides native support for the following languages based on these
    two criteria (by *native support*, I mean that Autoconf will compile, link, and
    run source-level feature checks in these languages):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf 根据这两个标准提供对以下语言的本地支持（*本地支持*意味着 Autoconf 可以在这些语言中编译、链接并运行源代码级特性检查）：
- en: C
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C
- en: C++
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++
- en: Objective C
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Objective C
- en: Objective C++
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Objective C++
- en: Fortran
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fortran
- en: Fortran 77
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fortran 77
- en: Erlang
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Erlang
- en: Go
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go
- en: Therefore, if you want to build a Java package, you can configure Automake to
    do so (as you’ll see in [Chapters 14](ch14.xhtml) and [15](ch15.xhtml)), but you
    can’t ask Autoconf to compile, link, or run Java-based checks,^([4](footnote.xhtml#ch02fn4))
    because Autoconf simply doesn’t natively support Java. However, you can find Autoconf
    macros (which I will cover in more detail in later chapters) that enhance Autoconf’s
    ability to manage the configuration process for projects written in Java.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想构建一个 Java 包，可以配置 Automake 来执行此操作（正如你将在[第 14 章](ch14.xhtml)和[第 15 章](ch15.xhtml)中看到的那样），但你不能要求
    Autoconf 来编译、链接或运行基于 Java 的检查^([4](footnote.xhtml#ch02fn4))，因为 Autoconf 本身不支持
    Java。然而，你可以找到 Autoconf 宏（我将在后续章节中详细介绍），这些宏增强了 Autoconf 管理 Java 项目配置过程的能力。
- en: The general feeling is that Java has plenty of its own build environments and
    tools that work very well (maven, for instance); therefore, adding full support
    for Java seems like a wasted effort. This is especially true since Java and its
    build tools are themselves highly portable—even to non-Unix/Linux platforms such
    as Windows.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的观点认为，Java 自带许多运行良好的构建环境和工具（例如 Maven）；因此，增加对 Java 的完全支持似乎是一种浪费。尤其是在 Java 及其构建工具本身具有很高的可移植性——甚至可以运行在
    Windows 等非 Unix/Linux 平台上。
- en: Rudimentary support does exist in Automake for Java compilers and JVMs. I’ve
    used these features myself on projects, and they work well, as long as you don’t
    try to push them too far.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Automake确实提供了对Java编译器和JVM的基础支持。我自己在项目中使用过这些功能，它们运行得很好，只要你不试图将它们推得太远。
- en: If you’re into Smalltalk, ADA, Modula, Lisp, Forth, or some other non-mainstream
    language, you’re probably not too interested in porting your code to dozens of
    platforms and CPUs. However, if you *are* using a non-mainstream language and
    you’re concerned about the portability of your build systems, consider adding
    support for your language to the Autotools yourself. This is not as daunting a
    task as you may think, and I guarantee that you’ll be an Autotools expert when
    you’re finished.^([5](footnote.xhtml#ch02fn5))
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对Smalltalk、ADA、Modula、Lisp、Forth或其他非主流语言感兴趣，你可能并不太想将你的代码移植到数十个平台和CPU上。然而，如果你*确实*使用非主流语言并且关心构建系统的可移植性，考虑自己为Autotools添加对你语言的支持。这并不像你想象的那样令人畏惧，我保证当你完成后，你将成为Autotools专家。^([5](footnote.xhtml#ch02fn5))
- en: Generating Your Package Build System
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成你的软件包构建系统
- en: 'The GNU Autotools framework includes three main packages: Autoconf, Automake,
    and Libtool. The tools in these packages can depend on utilities and functionality
    from the gettext, M4, sed, make, and Perl packages, among others; however, the
    build systems generated by these packages rely only on a Bourne shell and the
    `make` utility.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: GNU Autotools框架包括三个主要的软件包：Autoconf、Automake和Libtool。这些软件包中的工具可能依赖于gettext、M4、sed、make和Perl等包的实用程序和功能；然而，这些软件包生成的构建系统仅依赖于Bourne
    shell和`make`工具。
- en: With respect to the Autotools, it’s important to distinguish between a *maintainer’s*
    system and an *end user’s* system. The design goals of the Autotools specify that
    an Autotools-generated build system should rely only on tools that are readily
    available and preinstalled on the end user’s machine (assuming the end user’s
    system has rudimentary support for building programs from source code). For example,
    the machine a maintainer uses to create distributions requires a Perl interpreter,
    but a machine on which an end user builds products from release distribution source
    archives should not require Perl (unless, of course, the project sources are written
    in Perl).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Autotools方面，重要的是区分*维护者*的系统和*最终用户*的系统。Autotools的设计目标规定，Autotools生成的构建系统应该只依赖于最终用户机器上现成可用并已预安装的工具（假设最终用户的系统具有从源代码构建程序的基础支持）。例如，维护者用来创建发行版的机器需要一个Perl解释器，但最终用户用来从发布版源代码归档构建产品的机器不应需要Perl（除非该项目的源代码是用Perl编写的）。
- en: A corollary is that an end user’s machine doesn’t need to have the Autotools
    installed—an end user’s system only requires a reasonably POSIX-compliant version
    of `make` and some variant of the Bourne shell that can execute the generated
    configuration script. And, of course, any package will also require compilers,
    linkers, and other tools needed to convert source files into executable binary
    programs, help files, and other runtime resources.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个推论是，最终用户的机器不需要安装Autotools——最终用户的系统只需要一个合理符合POSIX的`make`版本和一个可以执行生成的配置脚本的Bourne
    shell变种。当然，任何软件包也会要求编译器、链接器以及将源文件转换为可执行二进制程序、帮助文件和其他运行时资源所需的工具。
- en: Configuration
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置
- en: Most developers understand the purpose of the `make` utility, but what’s the
    point of `configure`? While Unix systems have followed the de facto standard Unix
    kernel interface for decades, most software has to stretch beyond these boundaries.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者都理解`make`工具的用途，但`configure`有什么用呢？尽管Unix系统已经遵循事实上的标准Unix内核接口几十年了，大多数软件仍然需要超越这些边界。
- en: Originally, configuration scripts were hand-coded shell scripts designed to
    set environment variables based on platform-specific characteristics. They also
    allowed users to configure package options before running `make`. This approach
    worked well for decades, but as the number of Linux distributions and Unix-like
    systems grew, the variety of features and installation and configuration options
    exploded, so it became very difficult to write a decent portable configuration
    script. In fact, it was much more difficult to write a portable configuration
    script than it was to write makefiles for a new project. Therefore, most people
    just created configuration scripts for their projects by copying and modifying
    the script for a similar project.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，配置脚本是手工编写的 shell 脚本，旨在根据平台特定的特征设置环境变量。它们还允许用户在运行 `make` 之前配置软件包选项。这种方法在几十年里效果良好，但随着
    Linux 发行版和类 Unix 系统的数量增加，特性、安装和配置选项的多样性也爆炸性增长，因此编写一个体面的便携式配置脚本变得非常困难。事实上，编写一个便携式配置脚本比编写新项目的
    makefile 还要困难。因此，大多数人只是通过复制和修改类似项目的脚本来为自己的项目创建配置脚本。
- en: In the early 1990s, it was apparent to many open source software developers
    that project configuration would become painful if something wasn’t done to ease
    the burden of writing massive complex shell scripts to manage configuration options.
    The number of GNU project packages had grown to hundreds, and maintaining consistency
    across their separate build systems had become more time-consuming than simply
    maintaining the code for these projects. These problems had to be solved.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在1990年代初期，许多开源软件开发者明显意识到，如果不采取措施简化编写庞大复杂的 shell 脚本来管理配置选项的负担，项目配置将变得异常困难。GNU
    项目包的数量已经增长到数百个，而保持这些独立构建系统的一致性比维护这些项目的代码本身更为费时。这些问题必须得到解决。
- en: Autoconf
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Autoconf
- en: Autoconf ^([6](footnote.xhtml#ch02fn6)) changed this paradigm almost overnight.
    David MacKenzie started the Autoconf project in 1991, but a look at the *AUTHORS*
    file in the Savannah Autoconf project^([7](footnote.xhtml#ch02fn7)) repository
    will give you an idea of the number of people who had a hand in making the tool.
    Although configuration scripts were long and complex, users needed to specify
    only a few variables when executing them. Most of these variables were simply
    choices about components, features, and options, such as *Where can the build
    system find libraries and header files? Where do I want to install my finished
    products? Which optional components do I want to build into my products?*
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf ^([6](footnote.xhtml#ch02fn6)) 几乎一夜之间改变了这种局面。David MacKenzie 于1991年启动了
    Autoconf 项目，但通过查看 Savannah Autoconf 项目^([7](footnote.xhtml#ch02fn7)) 仓库中的 *AUTHORS*
    文件，你可以大致了解有多少人参与了这款工具的开发。尽管配置脚本长且复杂，但用户在执行时只需指定少数几个变量。这些变量大多数仅仅是关于组件、特性和选项的选择，比如
    *构建系统在哪里可以找到库文件和头文件？我想把成品安装到哪里？我想将哪些可选组件编译到我的产品中？*
- en: Instead of modifying and debugging hundreds of lines of supposedly portable
    shell script, developers can now write a short metascript file using a concise,
    macro-based language, and Autoconf will generate a perfect configuration script
    that is more portable, more accurate, and more maintainable than a hand-coded
    one. In addition, Autoconf often catches semantic or logic errors that could otherwise
    take days to debug. Another benefit of Autoconf is that the shell code it generates
    is portable between most variations of the Bourne shell. Mistakes made in portability
    between shells are very common and, unfortunately, are the most difficult kinds
    of mistakes to find, because no one developer has access to all Bourne-like shells.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者现在不需要修改和调试成百上千行本应便携的 shell 脚本，而是可以使用一种简洁的、基于宏的语言编写一个简短的元脚本文件，Autoconf 会生成一个完美的配置脚本，该脚本比手工编写的更加便携、准确和易于维护。此外，Autoconf
    经常能够捕捉到语义或逻辑错误，这些错误如果不加以调试，可能需要几天的时间才能发现。Autoconf 的另一个优点是，它生成的 shell 代码在大多数 Bourne
    shell 的变体之间是便携的。在 shell 之间的便携性问题是非常常见的，且不幸的是，这些错误是最难以发现的，因为没有任何开发者能访问到所有 Bourne-like
    的 shell。
- en: '**NOTE**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*While portable scripting languages like Perl and Python are now more pervasive
    than the Bourne shell, this was not the case when the idea for Autoconf was first
    conceived.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管像 Perl 和 Python 这样的便携式脚本语言现在比 Bourne shell 更为普及，但在最初构思 Autoconf 时并非如此。*'
- en: Autoconf-generated configuration scripts provide a common set of options that
    are important to all portable software projects running on POSIX systems. These
    include options to modify standard locations (a concept I’ll cover in more detail
    in [Chapter 3](ch03.xhtml)), as well as project-specific options defined in the
    *configure.ac* file (which I’ll discuss in [Chapter 5](ch05.xhtml)).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf 生成的配置脚本提供了一组通用选项，这些选项对于所有在 POSIX 系统上运行的可移植软件项目都很重要。这些选项包括修改标准位置的选项（这是我将在[第
    3 章](ch03.xhtml)中详细介绍的概念），以及在 *configure.ac* 文件中定义的项目特定选项（我将在[第 5 章](ch05.xhtml)中讨论）。
- en: 'The autoconf package provides several programs, including the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: autoconf 包提供了多个程序，包括以下内容：
- en: '`autoconf`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autoconf`'
- en: '`autoreconf`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autoreconf`'
- en: '`autoheader`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autoheader`'
- en: '`autoscan`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autoscan`'
- en: '`autoupdate`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autoupdate`'
- en: '`ifnames`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifnames`'
- en: '`autom4te`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autom4te`'
- en: The `autoconf` program is a simple Bourne shell script. Its main task is to
    ensure that the current shell contains the functionality necessary to execute
    the `m4` macro processor. (I’ll discuss Autoconf’s use of M4 in detail in [Chapter
    4](ch04.xhtml).) The remainder of the script parses command line parameters and
    executes `autom4te`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoconf` 程序是一个简单的 Bourne shell 脚本。它的主要任务是确保当前的 shell 包含执行 `m4` 宏处理器所需的功能。（我将在[第
    4 章](ch04.xhtml)中详细讨论 Autoconf 如何使用 M4。）脚本的其余部分解析命令行参数并执行 `autom4te`。'
- en: '*autoreconf*'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*autoreconf*'
- en: The `autoreconf` utility executes the configuration tools in the autoconf, automake,
    and libtool packages as required by the project. This utility minimizes the amount
    of regeneration required to address changes in timestamps, features, and project
    state. It was written as an attempt to consolidate existing maintainer-written,
    script-based utilities that ran all the required Autotools in the right order.
    You can think of `autoreconf` as a sort of smart Autotools bootstrap utility.
    If all you have is a *configure.ac* file, you can run `autoreconf` to execute
    all the tools you need, in the correct order, so that `configure` will be properly
    generated. [Figure 2-1](ch02.xhtml#ch02fig01) shows how `autoreconf` interacts
    with other utilities in the Autotools suite.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoreconf` 工具会根据项目的需要执行 autoconf、automake 和 libtool 包中的配置工具。该工具最小化了由于时间戳、特性和项目状态变化而需要重新生成的内容。它的编写旨在整合现有的维护者编写的脚本工具，这些工具会按照正确的顺序运行所有必需的
    Autotools。你可以将 `autoreconf` 看作是一种智能的 Autotools 启动工具。如果你只有一个 *configure.ac* 文件，可以运行
    `autoreconf` 来执行所有必需的工具，并确保 `configure` 文件能够正确生成。[图 2-1](ch02.xhtml#ch02fig01)
    展示了 `autoreconf` 如何与 Autotools 套件中的其他工具交互。'
- en: '![Image](../images/02fig01.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig01.jpg)'
- en: '*Figure 2-1: A dataflow diagram for the `autoreconf` utility*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：`autoreconf` 工具的数据流图*'
- en: Nevertheless, there are times when a project requires more than simply bootstrapping
    the Autotools to get a developer up and running on a newly checked-out repository
    work area. In these cases, a small shell script that runs `autoreconf`, along
    with any non-Autotools-related processes, is appropriate. Many projects name such
    a script `autogen.sh`, but this is often confusing to developers because there
    is a GNU Autogen project. A better name would be something like `bootstrap.sh`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时项目需要的不仅仅是启动 Autotools 来让开发人员在新检出的代码库工作区上快速开始。在这种情况下，一个运行 `autoreconf` 和任何非
    Autotools 相关进程的小型 shell 脚本是合适的。许多项目将这样的脚本命名为 `autogen.sh`，但由于有一个 GNU Autogen 项目，这常常会让开发人员感到困惑。一个更好的命名应该是像
    `bootstrap.sh` 这样的名称。
- en: Additionally, when used with the `-i` option, `autoreconf` will bootstrap a
    project into a distributable state by adding missing files that are recommended
    or required by GNU for proper open source projects. These include a proper *ChangeLog*
    and template *INSTALL*, *README*, and *AUTHORS* files and so on.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当与 `-i` 选项一起使用时，`autoreconf` 会通过添加 GNU 推荐或要求的缺失文件，将项目启动到可分发状态。这些文件包括适当的 *ChangeLog*
    文件、模板 *INSTALL*、*README* 和 *AUTHORS* 文件等。
- en: '*autoheader*'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*autoheader*'
- en: The `autoheader` utility generates a C/C++ compatible header file template from
    various constructs in *configure.ac*. This file is usually called *config.h.in*.
    When the end user executes `configure`, the configuration script generates *config.h*
    from *config.h.in*. As maintainer, you’ll use `autoheader` to generate the template
    file you will include in your distribution package. (We’ll examine `autoheader`
    in greater detail in [Chapter 4](ch04.xhtml).)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoheader`工具从*configure.ac*中的各种结构生成一个C/C++兼容的头文件模板。这个文件通常被称为*config.h.in*。当最终用户执行`configure`时，配置脚本会从*config.h.in*生成*config.h*。作为维护者，你将使用`autoheader`来生成你将在发布包中包含的模板文件。（我们将在[第4章](ch04.xhtml)中更详细地探讨`autoheader`。）'
- en: '*autoscan*'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*autoscan*'
- en: The `autoscan` program generates a default *configure.ac* file for a new project;
    it can also examine an existing Autotools project for flaws and opportunities
    for enhancement. (We’ll discuss `autoscan` in more detail in [Chapters 4](ch04.xhtml)
    and [14](ch14.xhtml).) `autoscan` is very useful as a starting point for a project
    that uses a non-Autotools-based build system, but it may also be useful for suggesting
    features that might enhance an existing Autotools-based project.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoscan`程序为一个新项目生成默认的*configure.ac*文件；它还可以检查现有的Autotools项目中的缺陷和改进机会。（我们将在[第4章](ch04.xhtml)和[第14章](ch14.xhtml)中更详细地讨论`autoscan`。）`autoscan`是为使用非Autotools构建系统的项目提供的一个很好的起点，但它也可以为增强现有Autotools项目提供建议。'
- en: '*autoupdate*'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*自动更新*'
- en: The `autoupdate` utility is used to update *configure.ac* or the template (*.in*)
    files to match the syntax supported by current versions of the Autotools.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoupdate`工具用于更新*configure.ac*或模板（*.in*）文件，以匹配当前版本的Autotools所支持的语法。'
- en: '*ifnames*'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*ifnames*'
- en: The `ifnames` program is a small and generally underused utility that accepts
    a list of source file names on the command line and displays a list of C-preprocessor
    definitions. This utility was designed to help maintainers determine what to put
    into the *configure.ac* and *Makefile.am* files to make them portable. If your
    project was written with some level of portability in mind, `ifnames` can help
    you determine where those attempts at portability are located in your source tree
    and give you the names of potential portability definitions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifnames`程序是一个小型且通常未充分使用的工具，它接受命令行上的源文件名列表，并显示C预处理器定义的列表。这个工具旨在帮助维护者确定应该将哪些内容放入*configure.ac*和*Makefile.am*文件中，以使其具有可移植性。如果你的项目在一定程度上考虑了可移植性，`ifnames`可以帮助你确定这些可移植性的尝试在源代码树中的位置，并为你提供潜在的可移植性定义名称。'
- en: '*autom4te*'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*autom4te*'
- en: The `autom4te` utility is a Perl-based intelligent caching wrapper for `m4`
    that is used by most of the other Autotools. The `autom4te` cache decreases the
    time successive tools spend accessing *configure.ac* constructs by as much as
    30 percent.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`autom4te`工具是一个基于Perl的智能缓存包装器，用于`m4`，它被大多数其他Autotools工具使用。`autom4te`缓存通过减少后续工具访问*configure.ac*构造的时间，最多可以提高30%的效率。'
- en: I won’t spend a lot of time on `autom4te` (pronounced *automate*) because it’s
    primarily used internally by the Autotools. The only sign that it’s working is
    the *autom4te.cache* directory that appears in your top-level project directory
    after you run `autoconf` or `autoreconf`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会花太多时间讲解`autom4te`（发音为*自动化*），因为它主要由Autotools内部使用。它工作的唯一迹象是在你运行`autoconf`或`autoreconf`后，在你的顶层项目目录中出现的*autom4te.cache*目录。
- en: '*Working Together*'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*协作工作*'
- en: Of the previously listed tools, `autoconf` and `autoheader` are the only ones
    project maintainers use when generating a `configure` script, and `autoreconf`
    is the only one that the developer needs to directly execute. [Figure 2-2](ch02.xhtml#ch02fig02)
    shows the interaction between input files and `autoconf` and `autoheader` that
    generates the corresponding product files.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前列出的工具中，`autoconf`和`autoheader`是项目维护者在生成`configure`脚本时唯一会使用的工具，而`autoreconf`是开发者需要直接执行的唯一工具。[图
    2-2](ch02.xhtml#ch02fig02)展示了输入文件与`autoconf`和`autoheader`之间的交互，它们生成相应的产品文件。
- en: '![Image](../images/02fig02.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig02.jpg)'
- en: '*Figure 2-2: A data flow diagram for `autoconf` and `autoheader`*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：`autoconf`和`autoheader`的数据流图*'
- en: '**NOTE**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I use the data flow diagram format shown in [Figure 2-2](ch02.xhtml#ch02fig02)
    throughout this book. Dark boxes represent objects provided either by the user
    or by an Autotools package. Light boxes represent generated objects. Boxes with
    square corners are scripts and programs, and boxes with rounded corners are data
    files. The meaning of most of the labels here should be obvious, but at least
    one deserves an explanation: the term ac-vars refers to Autoconf-specific replacement
    text. I’ll explain the gradient shading of the aclocal.m4 box shortly.*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在本书中使用的数据流图格式如 [图 2-2](ch02.xhtml#ch02fig02) 所示。深色框代表由用户或 Autotools 包提供的对象。浅色框代表生成的对象。方角框是脚本和程序，圆角框是数据文件。大部分标签的含义应该是显而易见的，但至少有一个需要解释：术语
    ac-vars 指的是 Autoconf 特定的替换文本。我会稍后解释 aclocal.m4 框的渐变阴影效果。*'
- en: The primary task of this suite of tools is to generate a configuration script
    that can be used to configure a project build directory for a target platform
    (not necessarily the local host). This script does not rely on the Autotools themselves;
    in fact, `autoconf` is designed to generate configuration scripts that will run
    on all Unix-like platforms and in most variations of the Bourne shell. This means
    that you can generate a configuration script using `autoconf` and then successfully
    execute that script on a machine that does not have the Autotools installed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这套工具的主要任务是生成一个配置脚本，该脚本可用于为目标平台（不一定是本地主机）配置项目构建目录。这个脚本不依赖于 Autotools 本身；事实上，`autoconf`
    旨在生成可以在所有类 Unix 平台和大多数 Bourne shell 变种中运行的配置脚本。这意味着，你可以使用 `autoconf` 生成配置脚本，然后在没有安装
    Autotools 的机器上成功执行该脚本。
- en: The `autoconf` and `autoheader` programs are executed either directly by you
    or indirectly by `autoreconf`. They take their input from your project’s *configur**e**.ac*
    file and various Autoconf-flavored M4 macro definition files (which, by convention,
    have a *.m4* extension), using `autom4te` to maintain cache information. The `autoconf`
    program generates a configuration script called `configure`, a very portable Bourne
    shell script that enables your project to offer many useful configuration capabilities.
    The program `autoheader` generates the *config.h.in* template based on certain
    macro definitions in *configure.ac*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoconf` 和 `autoheader` 程序要么由你直接执行，要么由 `autoreconf` 间接执行。它们从你的项目的 *configur**e**.ac*
    文件和各种 Autoconf 风格的 M4 宏定义文件（按照惯例，这些文件扩展名为 *.m4*）中获取输入，并使用 `autom4te` 来维护缓存信息。`autoconf`
    程序生成一个配置脚本，名为 `configure`，它是一个非常便携的 Bourne shell 脚本，使你的项目能够提供许多有用的配置功能。程序 `autoheader`
    根据 *configure.ac* 中的某些宏定义生成 *config.h.in* 模板。'
- en: Automake
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Automake
- en: Once you’ve done it a few times, writing a basic makefile for a new project
    is fairly simple. But problems may occur when you try to do more than just the
    basics. And let’s face it—what project maintainer has ever been satisfied with
    just a basic makefile?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你做了几次，写一个新项目的基本 makefile 就相对简单了。但当你试图做的不仅仅是基础操作时，可能会出现问题。让我们面对现实——哪个项目维护者会满足于一个基本的
    makefile 呢？
- en: 'Attention to detail is what makes an open source project successful. Users
    lose interest in a project fairly easily—especially when functionality they expect
    is missing or improperly written. For example, power users have come to expect
    makefiles to support certain standard targets or goals, specified on the `make`
    command line, like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 细节决定一个开源项目的成功。用户很容易对一个项目失去兴趣——尤其是当他们期望的功能缺失或编写不当时。例如，资深用户已经习惯了 makefile 支持某些标准目标或目标，这些目标在
    `make` 命令行中指定，如下所示：
- en: '[PRE0]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Common `make` targets include `all`, `clean`, and `install`. In this example,
    `install` is the target. But you should realize that none of these are *real*
    targets: a *real target* is a filesystem object that is produced by the build
    system—usually a file (but sometimes a directory or a link). When building an
    executable called `doofabble`, for instance, you’d expect to be able to enter:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的 `make` 目标包括 `all`、`clean` 和 `install`。在这个例子中，`install` 是目标。但你应该意识到，这些都不是
    *真实的* 目标：*真实目标* 是构建系统生成的文件系统对象——通常是一个文件（但有时是目录或链接）。例如，当构建名为 `doofabble` 的可执行文件时，你会期望能够输入：
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For this project, `doofabble` is a real target, and this command works for the
    doofabble project. However, requiring the user to enter real targets on the `make`
    command line is asking a lot of them, because each project must be built differently—`make
    doofabble`, `make foodabble`, `make abfooble`, and so on. Standardized targets
    for `make` allow all projects to be built in the same way using commonly known
    commands like `make all` and `make clean`. But *commonly known* doesn’t mean *automatic*,
    and writing and maintaining makefiles that support these targets is tedious and
    error prone.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，`doofabble`是一个真实的目标，并且该命令适用于doofabble项目。然而，要求用户在`make`命令行上输入真实目标要求比较高，因为每个项目的构建方式不同——`make
    doofabble`、`make foodabble`、`make abfooble`，等等。标准化的`make`目标允许所有项目通过使用像`make all`和`make
    clean`这样的常见命令以相同的方式构建。但*常见的*并不意味着*自动化的*，编写和维护支持这些目标的makefile既繁琐又容易出错。
- en: Automake’s job is to convert a simplified specification of your project’s build
    process into boilerplate makefile syntax that always works correctly the first
    time *and provides all the standard functionality expected*. Automake creates
    projects that support the guidelines defined in the *GNU Coding Standards* (discussed
    in [Chapter 3](ch03.xhtml)).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Automake的任务是将您项目构建过程的简化规范转换为可以始终正确工作的模板makefile语法，并且*提供所有预期的标准功能*。Automake创建的项目支持在*GNU编码标准*中定义的准则（在[第3章](ch03.xhtml)中讨论）。
- en: Just like `autoconf` produces a `configure` script that is portable to many
    flavors of the Bourne shell, `automake` produces `make` script that is portable
    to many flavors of `make`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`autoconf`生成的`configure`脚本可以移植到多种类型的Bourne shell中，`automake`生成的`make`脚本也可以移植到多种类型的`make`中。
- en: 'The automake package provides the following tools in the form of Perl scripts:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: automake包提供了以下形式为Perl脚本的工具：
- en: '`automake`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`automake`'
- en: '`aclocal`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aclocal`'
- en: '*automake*'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*automake*'
- en: The `automake` program generates standard makefile templates (named *Makefile.in*)
    from high-level build specification files (named *Makefile.am*). These *Makefile.am*
    input files are essentially just regular makefiles. If you were to put only the
    few required Automake definitions in a *Makefile.am* file, you’d get a *Makefile.in*
    file containing several hundred lines of parameterized `make` script.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`automake`程序从高级构建规范文件（命名为*Makefile.am*）生成标准makefile模板（命名为*Makefile.in*）。这些*Makefile.am*输入文件本质上只是常规的makefile。如果你只在*Makefile.am*文件中放入几个必需的Automake定义，你将得到一个包含数百行参数化`make`脚本的*Makefile.in*文件。'
- en: If you add additional `make` syntax to a *Makefile.am* file, Automake will move
    this code to the most functionally correct location in the resulting *Makefile.in*
    file. In fact, you can write your *Makefile.am* files so all they contain is ordinary
    `make` script, and the resulting makefiles will work just fine. This pass-through
    feature gives you the ability to extend Automake’s functionality to suit your
    project’s specific requirements.^([8](footnote.xhtml#ch02fn8))
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向*Makefile.am*文件中添加额外的`make`语法，Automake会将这段代码移动到结果*Makefile.in*文件中功能最正确的位置。事实上，你可以编写*Makefile.am*文件，让它们只包含普通的`make`脚本，而生成的makefile也能正常工作。这种通行特性使你能够扩展Automake的功能，以适应项目的特定需求。^([8](footnote.xhtml#ch02fn8))
- en: '*aclocal*'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*aclocal*'
- en: In the *GNU Automake Manual*, the `aclocal` utility is documented as a temporary
    workaround for a certain lack of flexibility in Autoconf. Automake enhances Autoconf
    by adding an extensive set of macros, but Autoconf was not really designed with
    this level of enhancement in mind.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在*GNU Automake手册*中，`aclocal`工具被描述为针对Autoconf某些灵活性不足的临时解决方法。Automake通过添加大量宏来增强Autoconf，但Autoconf并不是为了这种程度的增强而设计的。
- en: The original documented method for adding user-defined macros to an Autoconf
    project was to create a file called *aclocal.m4*, place the user-defined macros
    in this file, and place the file in the same directory as *configure.ac*. Autoconf
    then automatically includes this set of macros while processing *configure.ac*.
    The designers of Automake found this extension mechanism too useful to pass up;
    however, users would have been required to add an `m4_include` statement to a
    possibly unnecessary *aclocal.m4* file in order to include the Automake macros.
    Since both user-defined macros and the use of M4 itself are considered advanced
    concepts, this was deemed too harsh a requirement.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 添加用户定义的宏到Autoconf项目的最初文档方法是创建一个名为*aclocal.m4*的文件，将用户定义的宏放入该文件，并将文件放置在与*configure.ac*相同的目录中。Autoconf在处理*configure.ac*时会自动包含这一组宏。Automake的设计者发现这一扩展机制非常有用，因此无法放弃；然而，用户需要在可能不必要的*aclocal.m4*文件中添加`m4_include`语句，以包含Automake宏。由于用户定义的宏和M4的使用都被认为是高级概念，这一要求被认为过于苛刻。
- en: The `aclocal` script was designed to solve this problem. This utility generates
    an *aclocal.m4* file for a project that contains both user-defined macros and
    all required Automake macros.^([9](footnote.xhtml#ch02fn9)) Instead of adding
    user-defined macros directly to *aclocal.m4*, project maintainers should now add
    them to a new file called *acinclude.m4*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`aclocal`脚本旨在解决这个问题。这个工具为一个项目生成一个*aclocal.m4*文件，包含用户定义的宏和所有必需的Automake宏。^([9](footnote.xhtml#ch02fn9))
    项目维护者现在应将用户定义的宏添加到一个新文件中，称为*acinclude.m4*，而不是直接将其添加到*aclocal.m4*中。'
- en: To make it clear to readers that Autoconf doesn’t depend on Automake (and perhaps
    due to a bit of stubbornness), the *GNU Autoconf Manual* doesn’t make much mention
    of the `aclocal` utility. The *GNU Automake Manual* originally suggested that
    you rename *aclocal.m4* to *acinclude.m4* when adding Automake to an existing
    Autoconf project, and this approach is still commonly used. The flow of data for
    `aclocal` is depicted in [Figure 2-3](ch02.xhtml#ch02fig03).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让读者清楚地知道Autoconf并不依赖于Automake（也许出于一些固执的原因），*GNU Autoconf手册*并没有过多提到`aclocal`工具。*GNU
    Automake手册*最初建议，在将Automake添加到现有Autoconf项目时，应该将*aclocal.m4*重命名为*acinclude.m4*，这一方法仍然被广泛使用。`aclocal`的数据流如[图
    2-3](ch02.xhtml#ch02fig03)所示。
- en: '![Image](../images/02fig03.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/02fig03.jpg)'
- en: '*Figure 2-3: A data flow diagram for `aclocal`*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：`aclocal`的数据流图*'
- en: However, the latest documentation for both Autoconf and Automake suggests that
    the entire paradigm is now obsolete. Developers should now specify a directory
    that contains a set of M4 macro files. The current recommendation is to create
    a directory in the project root directory called *m4* and add macros as individual
    *.m4* files to it. All files in this directory will be gathered into *aclocal.m4*
    before Autoconf processes *configure.ac*.^([10](footnote.xhtml#ch02fn10))
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最新的Autoconf和Automake文档建议，整个范式现在已过时。开发者现在应指定一个包含M4宏文件集的目录。目前的推荐做法是，在项目的根目录中创建一个名为*m4*的目录，并将宏作为单独的*.m4*文件添加到其中。该目录中的所有文件将在Autoconf处理*configure.ac*之前被收集到*aclocal.m4*中。^([10](footnote.xhtml#ch02fn10))
- en: It may now be more apparent why the *aclocal.m4* box in [Figure 2-2](ch02.xhtml#ch02fig02)
    couldn’t decide which color it should be. When you’re using it without Automake
    and Libtool, you write *aclocal.m4* by hand. However, when you’re using it with
    Automake, the file is generated by the `aclocal` utility, and you provide project-specific
    macros either in *acinclude.m4* or in an *m4* directory.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能更容易理解为什么[图 2-2](ch02.xhtml#ch02fig02)中的*aclocal.m4*框无法决定应该使用哪种颜色。当你在没有Automake和Libtool的情况下使用它时，你需要手动编写*aclocal.m4*。然而，当你与Automake一起使用时，该文件是由`aclocal`工具生成的，你需要将项目特定的宏提供给*acinclude.m4*或*m4*目录中。
- en: Libtool
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Libtool
- en: How do you build shared libraries on different Unix platforms without adding
    a lot of very platform-specific conditional code to your build system and source
    code? This is the question that the Libtool project tries to address.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在不同的Unix平台上构建共享库，而不需要向构建系统和源代码中添加大量非常特定于平台的条件代码？这是Libtool项目试图解决的问题。
- en: There’s a significant amount of common functionality among Unix-like platforms.
    However, one very significant difference has to do with how shared libraries are
    built, named, and managed. Some platforms name their libraries *lib*name*.so*,
    others use *lib*name*.a* or even *lib*name*.sl*. The Cygwin system for Windows
    names Cygwin-generated shared libraries *cyg*name*.dll*. Still others don’t even
    provide native shared libraries. Some platforms provide *libdl.so* to allow software
    to dynamically load and access library functionality at runtime, while others
    provide different mechanisms, and some platforms don’t provide this functionality
    at all.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 类Unix平台之间有大量的共通功能。然而，有一个非常显著的区别与共享库的构建、命名和管理方式有关。一些平台将它们的库命名为 *lib*name*.so*，而另一些则使用
    *lib*name*.a*，甚至 *lib*name*.sl*。Windows 的 Cygwin 系统将 Cygwin 生成的共享库命名为 *cyg*name*.dll*。还有一些平台甚至不提供本地共享库。有些平台提供
    *libdl.so*，以允许软件在运行时动态加载并访问库的功能，而其他平台则提供不同的机制，甚至有些平台根本不提供此功能。
- en: The developers of Libtool have carefully considered all of these differences.
    Libtool supports dozens of platforms, not only providing a set of Autoconf macros
    that hide library-naming differences in makefiles but also offering an optional
    library of dynamic loader functionality that can be added to programs. This functionality
    allows maintainers to make their runtime, dynamic shared-object management code
    more portable and easier to maintain.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Libtool 的开发者仔细考虑了所有这些差异。Libtool 支持数十个平台，不仅提供一组可以在 makefile 中隐藏库命名差异的 Autoconf
    宏，还提供了一个可选的动态加载器功能库，可以添加到程序中。这些功能使得维护者能够使其运行时的动态共享对象管理代码更具可移植性，并更容易维护。
- en: 'The libtool package provides the following programs, libraries, and header
    file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: libtool 包提供以下程序、库和头文件：
- en: '`libtool` (program)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libtool`（程序）'
- en: '`libtoolize` (program)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libtoolize`（程序）'
- en: '*ltdl* (static and shared libraries)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ltdl*（静态和共享库）'
- en: '*ltdl.h* (header file)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ltdl.h*（头文件）'
- en: '*libtool*'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*libtool*'
- en: The `libtool` shell script that ships with the libtool package is a generic
    version of the custom script that `libtoolize` generates for a project.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 随 libtool 包一起发布的 `libtool` shell 脚本是一个通用版本，用于生成 `libtoolize` 为项目生成的自定义脚本。
- en: '*libtoolize*'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*libtoolize*'
- en: The `libtoolize` shell script prepares your project to use Libtool. It generates
    a custom version of the generic `libtool` script and adds it to your project directory.
    This custom script is shipped with the project along with the Automake-generated
    makefiles, which execute the script on the user’s system at the appropriate time.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`libtoolize` shell 脚本为你的项目准备使用 Libtool。它会生成一个自定义版本的通用 `libtool` 脚本，并将其添加到你的项目目录中。这个自定义脚本与项目一起发布，并与
    Automake 生成的 makefile 一起，在用户系统上的适当时刻执行该脚本。'
- en: '*ltdl, the Libtool C API*'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*ltdl，Libtool 的 C API*'
- en: The libtool package also provides the *ltdl* library and associated header files,
    which provide a consistent runtime shared-object manager across platforms. The
    *ltdl* library may be linked statically or dynamically into your programs, giving
    them a consistent runtime shared-library access interface between platforms.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: libtool 包还提供了 *ltdl* 库及相关的头文件，提供跨平台的一致性运行时共享对象管理器。*ltdl* 库可以静态或动态链接到你的程序中，从而为不同平台之间提供一致的运行时共享库访问接口。
- en: '[Figure 2-4](ch02.xhtml#ch02fig04) illustrates the interaction between the
    `automake` and `libtool` scripts, and the input files used to create products
    that configure and build your projects.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-4](ch02.xhtml#ch02fig04) 展示了 `automake` 和 `libtool` 脚本之间的互动，以及用于创建配置和构建项目的输入文件。'
- en: Automake and Libtool are both standard pluggable options that can be added to
    *configure.ac* with just a few simple macro calls.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Automake 和 Libtool 都是标准的可插拔选项，可以通过简单的宏调用添加到 *configure.ac* 中。
- en: '![Image](../images/02fig04.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig04.jpg)'
- en: '*Figure 2-4: A data flow diagram for `automake` and `libtool`*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：`automake` 和 `libtool` 的数据流图*'
- en: Building Your Package
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建你的包
- en: As maintainer, you probably build your software packages fairly often, and you’re
    also probably intimately familiar with your project’s components, architecture,
    and build system. However, you should make sure that your users’ build experiences
    are much simpler than your own. One way to do this is to give users a simple,
    easy-to-understand pattern to follow when building your software packages. In
    the following sections, I’ll show you the build pattern supported by the Autotools.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 作为维护者，你可能经常构建你的软件包，而且你也可能非常熟悉你项目的组件、架构和构建系统。然而，你应该确保你的用户的构建体验比你自己的更加简化。一种方法是为用户提供一个简单易懂的构建模式，以便他们在构建你的软件包时能够轻松跟随。在接下来的部分中，我将展示Autotools支持的构建模式。
- en: '*Running configure*'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*运行configure*'
- en: After running the Autotools, you’re left with a shell script called `configure`
    and one or more *Makefile.in* files. These files are intended to be shipped with
    your project release distribution packages.^([11](footnote.xhtml#ch02fn11)) Your
    users will download these packages, unpack them, and enter `./configure && make`
    from the top-level project directory. The `configure` script will generate makefiles
    (called *Makefile*) from the *Makefile.in* templates created by `automake` and
    a *config.h* header file from the *config.h.in* template generated by `autoheader`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行完Autotools后，你会得到一个名为`configure`的shell脚本和一个或多个*Makefile.in*文件。这些文件是作为项目发布包的一部分进行分发的。^([11](footnote.xhtml#ch02fn11))
    你的用户将下载这些包，解压后，从顶层项目目录输入`./configure && make`。`configure`脚本将根据`automake`生成的*Makefile.in*模板和由`autoheader`生成的*config.h.in*模板，生成makefile（称为*Makefile*）和*config.h*头文件。
- en: Automake generates *Makefile.in* templates rather than makefiles because without
    makefiles, your users can’t run `make`; you don’t want them to run `make` until
    after they’ve run `configure`, and this functionality guards against them doing
    so. *Makefile.in* templates are nearly identical to makefiles you might write
    by hand, except that you didn’t have to. They also do a lot more than most people
    are willing to hand-code. Another reason for not shipping ready-to-run makefiles
    is that it gives `configure` the chance to insert platform characteristics and
    user-specified optional features directly into the makefiles. This makes them
    a better fit for their target platforms and the end user’s build preferences.
    Finally, the makefiles can also be generated outside the source tree, which means
    you can create custom build systems in different directories for the same source
    directory tree. I’ll discuss this topic in greater detail in “Building Outside
    the Source Directory” on [page 28](ch02.xhtml#page_28).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Automake生成*Makefile.in*模板，而不是makefile，因为没有makefile，用户就无法运行`make`；你不希望他们在运行`configure`之前就运行`make`，而这种功能正是防止他们这样做的原因。*Makefile.in*模板与你手动编写的makefile几乎相同，除了你不需要亲自编写它们。它们还做了许多大多数人不愿意手动编写的事情。不提供直接运行的makefile的另一个原因是，这样可以让`configure`有机会将平台特性和用户指定的可选功能直接插入到makefile中。这使得makefile更加适合其目标平台和最终用户的构建偏好。最后，makefile还可以在源代码树之外生成，这意味着你可以为同一源代码目录树在不同的目录中创建自定义构建系统。我将在[第28页](ch02.xhtml#page_28)的“构建源代码目录之外”部分详细讨论这个话题。
- en: '[Figure 2-5](ch02.xhtml#ch02fig05) illustrates the interaction between `configure`
    and the scripts it executes during the configuration process in order to create
    the makefiles and the *config.h* header file.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-5](ch02.xhtml#ch02fig05)展示了`configure`与在配置过程中执行的脚本之间的交互，以便生成makefile和*config.h*头文件。'
- en: '![Image](../images/02fig05.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/02fig05.jpg)'
- en: '*Figure 2-5: A data flow diagram for `configure`*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：`configure`的数据流图*'
- en: The `configure` script has a bidirectional relationship with another script
    called `config.status`. You may have thought that your `configure` script generated
    your makefiles. But actually, the only file (besides a log file) that `configure`
    generates is `config.status`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure`脚本与另一个名为`config.status`的脚本有双向关系。你可能认为你的`configure`脚本生成了makefile。但实际上，`configure`生成的唯一文件（除了日志文件）是`config.status`。'
- en: The `configure` script is designed to determine platform characteristics and
    features available on the user’s system, as specified in the maintainer-written
    *configure.ac*. Once it has this information, it generates `config.status`, which
    contains all of the check results, and then it executes this script. The `config.status`
    script, in turn, uses the check information embedded within it to generate platform-specific
    *config.h* and makefiles, as well as any other template-based output files specified
    in *configure.ac*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure` 脚本的设计目的是确定用户系统上可用的平台特性和功能，这些内容在维护者编写的 *configure.ac* 文件中有说明。一旦获得这些信息，它就会生成
    `config.status`，该文件包含所有的检查结果，然后执行该脚本。`config.status` 脚本反过来使用其中嵌入的检查信息来生成平台特定的
    *config.h* 和 Makefile 文件，以及 *configure.ac* 中指定的任何其他基于模板的输出文件。'
- en: '**NOTE**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As the double-ended fat arrow in [Figure 2-5](ch02.xhtml#ch02fig05) shows,
    *`config.status`* can also call *`configure`*. When used with the *`--recheck`*
    option, *`config.status`* will call *`configure`* using the same command line
    options used to originally generate *`config.status`*.*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*如[图 2-5](ch02.xhtml#ch02fig05)中的双头粗箭头所示，*`config.status`* 也可以调用 *`configure`*。当与
    *`--recheck`* 选项一起使用时，*`config.status`* 将使用生成 *`config.status`* 时使用的相同命令行选项来调用
    *`configure`*。*'
- en: The `configure` script also generates a log file called *config.log*, which
    will contain very useful information in the event that an execution of `configure`
    fails on the user’s system. As the maintainer, you can use this information for
    debugging. The *config.log* file also logs how `configure` was executed. (You
    can run `config.status --version` to discover the command line options used to
    generate `config.status`.) This feature can be particularly handy when, for example,
    a user returns from vacation and can’t remember which options they used to originally
    generate the project build directory.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure` 脚本还会生成一个名为 *config.log* 的日志文件，如果 `configure` 在用户的系统上执行失败，该日志文件将包含非常有用的信息。作为维护者，你可以利用这些信息进行调试。*config.log*
    文件还记录了 `configure` 的执行方式。（你可以运行 `config.status --version` 来发现生成 `config.status`
    时使用的命令行选项。）当用户，比如说，度假归来并且不记得他们最初生成项目构建目录时使用了哪些选项时，这个功能尤其有用。'
- en: '**NOTE**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To regenerate makefiles and the* config.h *header files, just enter* *`./config.status`*
    *from within the project build directory. The output files will be generated using
    the same options originally used to generate* *`config.status`*.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*要重新生成 Makefile 和 config.h 头文件，只需在项目构建目录中输入* *`./config.status`* *。输出文件将使用最初用于生成*
    *`config.status`* 的相同选项生成。*'
- en: The *config.site* file can be used to customize the way `configure` works based
    on the `--prefix` option passed to it. The *config.site* file is a script, but
    it’s not meant to be executed directly. Rather, `configure` looks for *$(prefix)/share/config**.**site*
    and “sources” it (incorporates it as part of its own script) before executing
    any of its own code. This can be a handy way of specifying the same set of options
    for many packages, all destined to be built and installed the same way. Since
    `configure` is just a shell script, *config.site* should just contain shell code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*config.site* 文件可用于根据传递给它的 `--prefix` 选项自定义 `configure` 的工作方式。*config.site*
    文件是一个脚本，但它并不打算直接执行。相反，`configure` 会查找 *$(prefix)/share/config**.**site* 并将其“源”作为自己脚本的一部分，之后才会执行它自己的代码。这是指定许多软件包的相同选项的便捷方式，所有这些软件包都将按相同的方式构建并安装。由于
    `configure` 只是一个 shell 脚本，*config.site* 应该只包含 shell 代码。'
- en: The *config.cache* file is generated by `configure` when the `-C` or `--config-cache`
    options are used. The results of configuration tests are cached in this file and
    are reusable by subdirectory `configure` scripts or by future runs of `configure`.
    By default, *config.cache* is disabled because it can be a potential source of
    configuration errors. If you’re confident with your configuration process, *config.cache*
    can really speed up the configuration process between executions of `configure`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*config.cache* 文件是当使用 `-C` 或 `--config-cache` 选项时，由 `configure` 生成的。配置测试的结果会缓存到此文件中，供子目录中的
    `configure` 脚本或未来的 `configure` 执行使用。默认情况下，*config.cache* 是禁用的，因为它可能会成为配置错误的潜在来源。如果你对配置过程很有信心，*config.cache*
    可以显著加快每次执行 `configure` 时的配置速度。'
- en: Building Outside the Source Directory
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在源目录之外构建
- en: A little-known feature of Autotools build environments is that they don’t need
    to be generated within a project source tree. That is, if a user executes `configure`
    from a directory other than the project source directory, they can generate a
    full build environment within an isolated build directory.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Autotools 构建环境的一个鲜为人知的特点是，它们不需要在项目源代码树内生成。也就是说，如果用户从源代码目录以外的目录执行 `configure`，他们仍然可以在一个独立的构建目录中生成完整的构建环境。
- en: 'In the following example, the user downloads *doofabble-3.0.tar.gz*, unpacks
    it, and creates two sibling directories called *doofabble-3.0.debug* and *doofabble-3.0.release*.
    They change into the *doofabble-3.0.debug* directory; execute doofabble’s `configure`
    script, using a relative path, with a doofabble-specific `debug` option; and then
    run `make` from within this same directory. Then they switch over to the *doofabble-3.0.release*
    directory and do the same thing, this time running `configure` without the `debug`
    option:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，用户下载 *doofabble-3.0.tar.gz*，解压缩后创建两个兄弟目录，分别命名为 *doofabble-3.0.debug*
    和 *doofabble-3.0.release*。他们切换到 *doofabble-3.0.debug* 目录；使用相对路径执行 doofabble 的
    `configure` 脚本，并使用专为 doofabble 定制的 `debug` 选项；然后在同一目录内运行 `make`。接着，他们切换到 *doofabble-3.0.release*
    目录，执行相同的操作，这次运行 `configure` 时不使用 `debug` 选项：
- en: '[PRE2]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Users generally don’t care about remote build functionality, because all they
    usually want to do is configure, build, and install your code on their platforms.
    Maintainers, on the other hand, find remote build functionality very useful, as
    it allows them to not only maintain a reasonably pristine source tree but also
    to maintain multiple build environments for their project, each with complex configuration
    options. Rather than reconfigure a single build environment, a maintainer can
    simply switch to another build directory that has been configured with different
    options.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通常不关心远程构建功能，因为他们通常只希望在自己的平台上配置、构建和安装代码。而维护者则认为远程构建功能非常有用，因为它不仅可以保持一个相对干净的源代码树，还可以为他们的项目维护多个构建环境，每个环境都可以有不同的复杂配置选项。维护者无需重新配置单个构建环境，只需切换到另一个已配置不同选项的构建目录即可。
- en: There is one case, however, where a user might wish to use remote-build. Consider
    the case where one obtains the full unpacked source code of a project on CD or
    has access to it via a read-only NFS mount. The ability to build outside the source
    tree can grant the ability to build the project without having to copy it to writable
    media.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种情况，用户可能希望使用远程构建。假设用户获取了一个项目的完整解压源代码（例如通过 CD 或只读 NFS 挂载方式）。在源代码树外构建的能力可以使用户在不需要将项目复制到可写介质的情况下进行构建。
- en: '*Running make*'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*运行 make*'
- en: Finally, you run plain old `make`. The designers of the Autotools went to a
    *lot* of trouble to ensure that you didn’t need any special version or brand of
    `make`. [Figure 2-6](ch02.xhtml#ch02fig06) depicts the interaction between `make`
    and the makefiles that are generated during the build process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行普通的 `make`。Autotools 的设计者们花费了*大量*的精力，确保你不需要任何特殊版本或品牌的 `make`。[图 2-6](ch02.xhtml#ch02fig06)
    展示了 `make` 与在构建过程中生成的 makefile 之间的交互。
- en: '**NOTE**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There has been some discussion on the Autotools mailing lists during the last
    few years about supporting only GNU *`make`*, as modern GNU *`make`* is so much
    more functional than other *`make`* utilities. Almost all Unix-y platforms (and
    even Microsoft Windows) have a version of GNU *`make`* today, so the rationale
    for continuing to support other brands of *`make`* is no longer as important as
    it once was.*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*近几年，关于只支持 GNU *`make`* 的讨论出现在 Autotools 邮件列表中，因为现代的 GNU *`make`* 比其他 *`make`*
    工具要功能强大得多。几乎所有类 Unix 平台（甚至包括微软 Windows）今天都有 GNU *`make`* 版本，因此继续支持其他品牌的 *`make`*
    已不再像以前那样重要。*'
- en: As you can see, `make` runs several generated scripts, but these are all really
    ancillary to the `make` process. The generated makefiles contain commands that
    execute these scripts under the appropriate conditions. These scripts are part
    of the Autotools, and they are either shipped with your package or generated by
    your configuration script.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`make` 会运行几个生成的脚本，但这些脚本实际上都是 `make` 过程的辅助部分。生成的 makefile 包含在适当条件下执行这些脚本的命令。这些脚本是
    Autotools 的一部分，通常随你的软件包一起提供，或者由配置脚本生成。
- en: '![Image](../images/02fig06.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig06.jpg)'
- en: '*Figure 2-6: A data flow diagram for `make`*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：`make` 的数据流图*'
- en: Installing the Most Up-to-Date Autotools
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装最新版本的 Autotools
- en: 'If you’re running a variant of Linux and you’ve chosen to install the compilers
    and tools used for developing C-language software, you probably already have some
    version of the Autotools installed on your system. To determine which versions
    of Autoconf, Automake, and Libtool you’re using, simply open a terminal window
    and type the following commands (if you don’t have the `which` utility on your
    system, try type -p instead):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行某个Linux变种，并且已经选择安装用于开发C语言软件的编译器和工具，你可能已经在系统上安装了某个版本的Autotools。要确定你正在使用的Autoconf、Automake和Libtool的版本，只需打开一个终端窗口并输入以下命令（如果你的系统没有`which`工具，可以尝试输入`type
    -p`代替）：
- en: '[PRE3]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**NOTE**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you have the Linux-distribution varieties of these Autotools packages installed
    on your system, the executables will probably be found in* /usr/bin *rather than*
    /usr/local/bin, *as you can see from the output of the *`which`* command here.*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你已经在系统中安装了这些Autotools包的Linux发行版版本，执行文件可能会出现在* /usr/bin *而不是* /usr/local/bin*中，*正如你可以从此处的*`which`*命令输出看到的那样。*'
- en: 'If you choose to download, build, and install the latest released version of
    any one of these packages from the GNU website, you must do the same for all of
    them, because the Automake and Libtool packages install macros into the Autoconf
    macro directory. If you don’t already have the Autotools installed, you can install
    them using your system package manager (for example, `yum` or `apt`), or from
    source, using their GNU distribution source archives. The latter can be done with
    the following commands (be sure to change the version numbers as necessary):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择从GNU网站下载、构建并安装任何这些包的最新发布版本，则必须对它们全部执行相同的操作，因为Automake和Libtool包会将宏安装到Autoconf宏目录中。如果你尚未安装Autotools，可以通过系统包管理器（例如`yum`或`apt`）或通过源代码安装，使用它们的GNU发行版源档案来安装。后者可以通过以下命令完成（确保根据需要更改版本号）：
- en: '[PRE4]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding example shows how to use the associated *.sig* files to validate
    the signature on GNU packages. The example assumes you have not configured a gpg
    key server on your system and that you have not installed the public key for any
    of these packages. If you have already configured a preferred key server, you
    can skip the `gpg` command line `--keyserver` options. Once you’ve imported the
    public keys for these packages, you need not do it again.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例展示了如何使用相关的*.sig*文件验证GNU包的签名。该示例假设你尚未在系统上配置gpg密钥服务器，并且没有安装任何这些包的公钥。如果你已经配置了首选的密钥服务器，可以跳过`gpg`命令行中的`--keyserver`选项。一旦你导入了这些包的公钥，以后就不需要再做一次了。
- en: You may also wish to install in a manner that does not require root access via
    `sudo`. To do this, execute `configure` with a `--prefix` option such as `--prefix=$HOME/autotools`
    and then add *~/autotools/bin* to your `PATH` environment variable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还希望以不需要root权限通过`sudo`的方式进行安装。为此，请执行带有`--prefix`选项的`configure`，例如`--prefix=$HOME/autotools`，然后将*~/autotools/bin*添加到你的`PATH`环境变量中。
- en: You should now be able to successfully execute the version-check commands from
    the previous example. If you still see older versions, ensure your `PATH` environment
    variable properly contains */usr/local/bin* (or wherever you installed to) before
    */usr/bin*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够成功执行前面示例中的版本检查命令。如果你仍然看到旧版本，请确保你的`PATH`环境变量中正确地包含了*/usr/local/bin*（或者你安装的任何位置），并且排在*/usr/bin*之前。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, I presented a high-level overview of the Autotools to give
    you a feel for how everything ties together. I also showed you the pattern to
    follow when building software from distribution tarballs created by Autotools
    build systems. Finally, I showed you how to install the Autotools and how to tell
    which versions you have installed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我提供了Autotools的高层次概述，以便让你了解如何将所有内容结合在一起。我还展示了在使用Autotools构建系统创建的分发tarball时，构建软件的模式。最后，我展示了如何安装Autotools，以及如何查看已安装的版本。
- en: 'In [Chapter 3](ch03.xhtml), we’ll step away from the Autotools briefly and
    begin creating a hand-coded build system for a toy project called *Jupiter*. You’ll
    learn the requirements of a reasonable build system, and you’ll become familiar
    with the rationale behind the original design of the Autotools. With this background
    knowledge, you’ll begin to understand why the Autotools do things the way they
    do. I can’t really emphasize this enough: *[Chapter 3](ch03.xhtml) is one of the
    most important chapters in this book, because it will get you past any emotional
    stigma you may have associated with the Autotools due to misconceptions*.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.xhtml)中，我们将暂时离开Autotools，开始为一个名为*Jupiter*的玩具项目创建一个手工编码的构建系统。你将了解一个合理构建系统的需求，并且熟悉Autotools最初设计背后的理念。通过这些背景知识，你将开始理解为什么Autotools会以这种方式操作。我无法过多强调这一点：*[第3章](ch03.xhtml)是本书中最重要的章节之一，因为它将帮助你克服因误解而对Autotools产生的任何情感偏见*。
