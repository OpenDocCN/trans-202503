- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 4 CONDITIONAL EXECUTION
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4 条件执行
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: The if command, which is quite likely common to all programming languages, causes
    one or more lines of code to be executed only when a condition is true, and a
    different section of code can be executed only when that condition is false.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: if 命令，几乎所有编程语言中都有，是在条件为真时执行一行或多行代码，而在该条件为假时执行不同的代码块。
- en: The basics are straightforward, but in Batch the *conditional clause*, or the
    entity that evaluates to true or false, is quite different from similar clauses
    in other languages. Most of the compare operators are unique to Batch, and in
    this chapter you’ll learn the syntax to determine whether a path or file exists
    and whether a variable is populated. It’s also important to understand the different
    techniques for evaluating the return code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 基本概念很简单，但在 Batch 中，*条件子句*，或评估为真或假的实体，与其他语言中的类似子句有很大不同。大多数比较运算符在 Batch 中是独有的，在本章中你将学习如何使用语法来确定路径或文件是否存在，以及变量是否已赋值。了解评估返回码的不同技术也很重要。
- en: In addition, you’ll learn how to efficiently manage instances where multiple
    conditions need to be evaluated as well as some common stumbling blocks to avoid.
    It’s disturbingly easy to write an if command that works most of the time but
    either aborts or fails to execute as intended under certain data conditions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还将学习如何有效管理需要评估多个条件的情况，以及如何避免一些常见的障碍。编写一个大部分时间都能正常工作的 if 命令并不难，但在某些数据条件下，它可能会中断或无法按预期执行。
- en: The Basic if Command
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本的 if 命令
- en: In its most basic incarnation, the if command executes one or more lines of
    code if a condition is true. I’ll show how you can expand this command to execute
    a different bit of code if that same condition is false, but let’s start with
    its basic structure.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的形式中，if 命令会在条件为真时执行一行或多行代码。我将展示如何扩展此命令，在相同条件为假时执行不同的代码，但我们先从其基本结构开始。
- en: Nearly every Batch command implementation starts with the command name itself
    and is often followed by arguments and/or options. For instance, the set command
    always starts with those three letters. Usually, it’s followed by an argument
    consisting of a variable name, an equal sign, and a value, but in [Chapter 2](chapter2.xhtml)
    you learned that it works with no arguments or options at all. (Such a command
    writes out a list of active variables.)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个 Batch 命令实现都以命令名称本身开始，通常后跟参数和/或选项。例如，set 命令总是以这三个字母开始。通常，它后面跟着一个由变量名、等号和一个值组成的参数，但在[第2章](chapter2.xhtml)中，你已经学到它也可以在没有任何参数或选项的情况下工作。（这样的命令会输出活动变量的列表。）
- en: 'The if command is unique. It also starts with its command name, but the similarities
    end there; it can span multiple lines and has two major components. Here’s the
    general form where you’d replace the italicized text with code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: if 命令是独特的。它也以命令名称开始，但相似之处止于此；它可以跨越多行，并且有两个主要组件。以下是一般形式，你可以用代码替换斜体部分的文本：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The *conditional clause* is an expression that evaluates to true or false. If
    it’s true, the interpreter executes the command or commands inside the *true code
    block*, and if it’s false, this code doesn’t execute. In [Chapter 16](chapter16.xhtml),
    I’ll discuss code blocks in more depth, but for now, a code block is simply one
    or more lines of code set between parentheses.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*条件子句*是一个会计算为真或假的表达式。如果它为真，解释器会执行*真代码块*中的命令；如果它为假，则不会执行这些代码。在[第16章](chapter16.xhtml)中，我会更深入地讨论代码块，但目前为止，代码块只是放在括号之间的一行或多行代码。'
- en: 'With this syntax, the open parenthesis must not only follow the conditional
    clause; it also must be on the same line. Other languages allow (or even encourage)
    you to put the open parenthesis on the next line and line it up with the close
    parenthesis, but this is verboten in Batch. However, good form dictates that the
    close parenthesis should line up with the beginning of the if command with the
    intervening commands indented. My convention calls for three spaces of indentation,
    but any amount will do. Here’s a functioning example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种语法时，左括号不仅必须紧跟在条件子句后面，而且还必须位于同一行。其他语言可能允许（甚至鼓励）你将左括号放在下一行，并与右括号对齐，但在 Batch
    中这是不允许的。然而，良好的格式要求右括号应与 if 命令的开头对齐，而中间的命令需要缩进。我的惯例是使用三个空格缩进，但任何数量的缩进都可以。以下是一个有效的示例：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The conditional clause, "%today%" equ "07/04/2026", is looking for equality
    between a resolved variable and some hardcoded text. This conditional clause is
    fairly straightforward, but I’ll soon demonstrate far more impressive ones using
    different compare operators, keywords, and even an option. Many coding languages
    put the conditional clause inside parentheses; for better or worse, the clause
    stands on its own in Batch, and the parentheses are used to enclose the upcoming
    code block.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句 "%today%" equ "07/04/2026" 正在寻找一个已解析的变量和一些硬编码文本之间的相等性。这个条件语句相对简单，但我很快会展示使用不同的比较运算符、关键字甚至选项的更为复杂的语句。许多编程语言将条件语句放在括号内；无论好坏，在
    Batch 中，条件语句是独立存在的，括号用来包围即将出现的代码块。
- en: If the conditional clause is true, the command in the code block (in this example,
    the set command) is executed, resulting in event being set to the term for a quarter-millennium
    celebration.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件语句为真，将执行代码块中的命令（在这个例子中是 set 命令），导致 event 被设置为一个表示四分之一千年庆典的术语。
- en: 'The following more compact format fitting on a single line is functionally
    equivalent to the previous example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下更加紧凑的单行格式与之前的例子功能等效：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You no longer need the parentheses when using a single line. The following
    is functionally equivalent to both prior examples:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单行时不再需要括号。以下代码在功能上与前面的两个例子等效：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Technically, because of the lack of parentheses, the set command is no longer
    in a code block. In lieu of a concise term, it’s now just the command that executes
    when the conditional clause is true.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，由于缺少括号，set 命令不再位于代码块中。没有一个简洁的术语，它现在仅仅是当条件语句为真时执行的命令。
- en: In both of the prior examples, I’ve left two spaces after the conditional clause,
    and I often leave more than two. Syntactically this isn’t needed, but since nothing
    clearly delineates the conditional clause from what comes after it, readability
    is enhanced with a little separation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的两个例子中，我在条件语句后留下了两个空格，而且我通常会留下超过两个空格。从语法上讲，这并不是必须的，但由于没有明确区分条件语句和后续内容，稍作分隔可以提高可读性。
- en: 'You can even execute multiple commands on a single line with the & command
    separator, as discussed in [Chapter 2](chapter2.xhtml):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以在单行中执行多个命令，通过 & 命令分隔符，如[第二章](chapter2.xhtml)中所讨论：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If the conditional clause is true, an additional set command, which happens
    to be self-critiquing of the code, is executed. I’ve seen this technique used
    on occasion, usually when setting an error code and error message, but in instances
    such as this, using a single line just makes the code inscrutable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件语句为真，将执行一个额外的 set 命令，这个命令恰好对代码进行自我审查。我偶尔见过这种技巧，通常是在设置错误代码和错误信息时使用，但在这种情况下，使用单行代码会让代码难以理解。
- en: 'If there’s anything remotely interesting in the logic being performed, use
    multiple lines of code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行的逻辑中有任何稍微有趣的地方，请使用多行代码：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Elegant is undoubtedly a gross overstatement here, but I hope you agree that
    this technique makes the code far more readable. With just a glance, the reader
    knows that if the condition is true, two variables are set.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: “优雅”在这里无疑是个过誉的说法，但我希望你同意，这种技巧使得代码更加易读。只需一眼，读者就能知道，如果条件为真，两个变量将被设置。
- en: The Conditional Clause
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件语句
- en: The examples in the previous section all use a straightforward conditional clause,
    but the clause can be far more dynamic, taking on many other forms and using different
    operators and keywords.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节中的例子都使用了简单的条件语句，但该语句可以更加动态，采取许多不同的形式，并使用不同的运算符和关键字。
- en: Compare Operators
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 比较运算符
- en: A *compare operator*, unsurprising enough, compares two operands for equality
    or for one being greater than the other. You may have guessed that the equ operator
    in the previous examples represents equality, and you’d be right.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*比较运算符*，顾名思义，用于比较两个操作数是否相等，或者一个是否大于另一个。你可能已经猜到，前面例子中的 equ 运算符表示相等，没错。
- en: 'Here’s the complete list of Batch compare operators:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Batch 比较运算符的完整列表：
- en: equ **or** ==    Equal
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: equ **或** ==    相等
- en: neq    Not equal
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: neq    不相等
- en: lss    Less than
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: lss    小于
- en: leq    Less than or equal
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: leq    小于或等于
- en: gtr    Greater than
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: gtr    大于
- en: geq    Greater than or equal
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: geq    大于或等于
- en: You can choose between two functionally equivalent alternatives for the equality
    operator. To differentiate from the single equal sign used for assignment, such
    as in a set command, Batch uses double equal signs for the compare operator. My
    preferred syntax is the equ operator because it looks similar to the others, but
    some coders prefer the == operator for the opposite reason.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择两个功能等效的替代选项作为等号运算符。为了与用于赋值的单个等号区分开来，例如在 set 命令中，Batch 使用双等号作为比较运算符。我偏好的语法是
    equ 运算符，因为它看起来与其他的类似，但有些程序员因为相反的原因更喜欢使用 == 运算符。
- en: 'The neq operator evaluates the conditional clause to true if the two operands
    being compared are *not* equal. The last four operators determine which operand
    is greater or less than the other. For example, assuming that age is set to a
    numeric value, the following one-line code block executes only if the variable
    is set to a value greater than 12:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: neq 运算符会在比较的两个操作数不相等时将条件子句评估为 true。最后四个运算符用于判断哪个操作数大于或小于另一个。例如，假设 age 被设置为一个数字值，以下单行代码块仅在变量设置为大于
    12 的值时执行：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You might be tempted to try %age% > 12 as the conditional clause, but the greater-than
    sign already has a defined purpose in Batch; in fact, it’s being used in this
    code block to write a short message to the console. For this reason, you must
    use the three-character alpha code of gtr as the operator. Similarly, the operators
    listed in this section are needed for greater-than or equal, less-than, and less-than
    or equal compares.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会尝试将 %age% > 12 作为条件子句，但大于符号在 Batch 中已经有一个定义的用途；事实上，它在此代码块中用于向控制台写一条短消息。因此，你必须使用三个字符的字母代码
    gtr 作为运算符。同样，本节列出的运算符用于大于或等于、小于以及小于或等于比较。
- en: Less intuitively, these operators also work on alphanumeric values. All numbers
    are less than all letters; a is less than A; A is less than b; b is less than
    B; and so on. This’ll do nothing to end the larger debate, but at least in the
    Batch universe, Picard is greater than Kirk.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不太直观的是，这些运算符也适用于字母数字值。所有数字小于所有字母；a 小于 A；A 小于 b；b 小于 B；以此类推。这不会结束更大的争论，但至少在 Batch
    的世界里，Picard 大于 Kirk。
- en: Conditional Clause Keywords
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 条件子句关键字
- en: 'You’ll find the following indispensable keywords in the help for the if command,
    but make no mistake; these keywords are specific to the conditional clause:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在 if 命令的帮助文档中找到以下不可或缺的关键字，但不要搞错了；这些关键字是特定于条件子句的：
- en: 'exist    The exist keyword checks for the existence of either a path or a file
    and returns true if found. You can hardcode the path or file, or for flexibility,
    you can use a variable containing the potential path or file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: exist    exist 关键字检查路径或文件是否存在，如果找到则返回 true。你可以将路径或文件硬编码，或者为了灵活性，你可以使用包含潜在路径或文件的变量：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can also string multiple variables together to build the path or filename.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将多个变量串联在一起以构建路径或文件名。
- en: 'defined    The following conditional clause using the defined keyword checks
    whether a variable is defined—that is, does it resolve to anything, even a space?
    A common mistake is to use percent signs around the variable, but here’s the correct
    syntax using this keyword:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: defined    使用 defined 关键字的以下条件子句检查变量是否已定义——也就是说，它是否解析为任何值，即使是一个空格？一个常见的错误是将百分号放在变量两边，但以下是使用该关键字的正确语法：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is functionally equivalent to the following with percent signs resolving
    the variable:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下使用百分号解析变量的代码功能等效：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This keyword is often used to validate expected input variables. If one or more
    is not defined, you can take appropriate action, possibly initiating an abort.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关键字常用于验证期望的输入变量。如果一个或多个变量未定义，你可以采取适当的措施，可能会启动中止操作。
- en: 'not    The not keyword negates any conditional clause when used at the very
    beginning of the clause. This is extremely useful in setting defaults for variables
    in the event that they’ve not yet been set by someone or something else. For instance,
    the following ensures that skyColor is set to its usual color:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: not    not 关键字在条件子句的最前面时会否定整个条件子句。这在为变量设置默认值时非常有用，特别是在变量尚未被其他人或其他程序设置时。例如，下面的代码确保
    skyColor 被设置为它通常的颜色：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can couple the not keyword with the exist keyword to determine whether a
    specific file doesn’t exist. Armed with that knowledge, you can then create a
    file, initiate an abort, or do whatever makes sense for your application. Some
    coders use the not keyword with the equ operator, but I find this iffy at best
    and much prefer the neq operator alone. Logically there’s no difference, but whatever
    your preference, be consistent.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 not 关键字与 exist 关键字结合使用，以判断特定文件是否不存在。掌握了这一点，你就可以创建文件、发起中止操作，或者根据你的应用需求做其他事情。一些程序员会将
    not 关键字与 equ 运算符一起使用，但我认为这样做最多只是勉强可行，我更倾向于单独使用 neq 运算符。从逻辑上讲没有区别，但不论你偏好哪种方式，都要保持一致。
- en: WARNING
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '*After two decades of Batch coding I still try to add s to the end of the exist
    keyword more often than I care to admit. Notepad++ faithfully alerts me every
    time because it emboldens keywords; that spurious character drops the bold font
    for the entire word, making it stand out. Code without an editor like this at
    your own peril.*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*经过二十年的批处理编码，我仍然会不自觉地在 exist 关键字末尾加上 s，尽管我不太愿意承认这一点。Notepad++ 每次都会忠实地提醒我，因为它会加粗关键字；那个多余的字符会让整个单词失去加粗效果，从而使它显得突出。没有这样的编辑器，自己写代码要小心。*'
- en: The Case-Insensitive Option
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不区分大小写选项
- en: The if command has exactly one option, and much like the keywords we’ve looked
    at so far, it applies to the conditional clause. The /i option makes the equality
    (and inequality) operator in the conditional clause case-insensitive.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: if 命令有一个选项，就像我们之前看到的关键字一样，它适用于条件语句。/i 选项使得条件语句中的相等（和不等）运算符不区分大小写。
- en: 'To demonstrate, the conditional clause without the option in the following
    if command evaluates to true only if myMood resolves exactly to happy—the hardcoded
    value on the right side of the inequality:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，下面的 if 命令中，如果没有选项，条件语句只有在 myMood 完全等于 happy 时才会返回 true——这是不等式右侧的硬编码值：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here’s the same code with the addition of the /i option:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是添加了 /i 选项的相同代码：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The conditional clause now evaluates to true if the variable resolves to HAPPY,
    Happy, happy, or any of the other 29 possible permutations on the capitalization
    of the word.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果变量的值为 HAPPY、Happy、happy 或该词大小写变化的其他 29 种可能组合时，条件语句就会返回 true。
- en: NOTE
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The /i option probably looks a bit different from others that I’ve mentioned
    already and ones yet to come. As mentioned previously, I use lowercase for Batch
    commands even though the case doesn’t matter to the interpreter. Options also
    work regardless of the case. Even so, since options are usually just a forward
    slash followed by a single character, I typically capitalize them for emphasis.
    But depending on the font, the capital I often looks like a lowercase L, so I
    depart from my personal convention for the /i option, used most often with the
    if command. And yes, the irony that this is the option concerned with case-insensitivity
    has not been lost on me.*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*/i 选项可能看起来与我之前提到的其他选项以及未来提到的选项有点不同。如前所述，尽管解释器不区分大小写，我在写批处理命令时总是使用小写字母。选项也不受大小写影响。尽管如此，由于选项通常只是一个斜杠后跟一个字符，我通常会将其大写以突出显示。但根据字体的不同，大写字母
    I 经常看起来像小写字母 L，因此我在使用 /i 选项时会偏离我的个人习惯，这个选项最常与 if 命令一起使用。是的，我知道这个选项与不区分大小写有关，讽刺的是这一点我并不忽视。*'
- en: The errorlevel Variable
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: errorlevel 变量
- en: 'After calling an executable or performing many Batch commands, a return code
    is stored in the errorlevel pseudo-environment variable. (The command in [Chapter
    1](chapter1.xhtml) that copied a file is one example of many to come that will
    set this variable.) You’ll learn more about pseudo-environment variables in [Chapter
    21](chapter21.xhtml), but for now, consider errorlevel to be a variable containing
    a return code that you shouldn’t set with the set command. (If you do, you’ll
    just break the errorlevel variable.) The errorlevel variable can be evaluated
    like any other in Batch as part of an if command. For example, the following recognizes
    a return code of 1 or greater as a failure:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用可执行文件或执行多个批处理命令后，返回代码会存储在 errorlevel 伪环境变量中。（[第1章](chapter1.xhtml)中复制文件的命令就是一个会设置此变量的例子。）你将在[第21章](chapter21.xhtml)中了解更多关于伪环境变量的内容，但现在，先把
    errorlevel 看作是一个包含返回代码的变量，你不应该使用 set 命令设置它。（如果你这样做，就会破坏 errorlevel 变量。）errorlevel
    变量可以像其他变量一样在 Batch 中通过 if 命令进行评估。例如，下面的命令将返回代码为 1 或更大的情况视为失败：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Batch also supports an archaic syntax that works only for this unique variable,
    where the percent signs and the equality operator are removed. The following is
    functionally equivalent to the previous example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Batch 还支持一种古老的语法，仅适用于这个特殊变量，其中百分号符号和等号运算符被省略。以下代码与前面的示例功能等效：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At first this may seem simplified and appealing because content has been dropped
    with nothing added, but the syntax disguises a surprising batveat. Many Batch
    coders mistakenly interpret this conditional clause as looking for equality between
    the return code and 1. After all, testing it with a return code of 0 correctly
    returns false, and testing it with a return code of 1 correctly returns true.
    But the conditional clause errorlevel 1 is equivalent to both %errorlevel% geq
    1 and %errorlevel% gtr 0. It evaluates to true for all positive integers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这看起来可能简化且吸引人，因为省略了内容而没有新增任何内容，但语法掩盖了一个令人惊讶的陷阱。许多 Batch 编程人员误将这个条件语句理解为检查返回码是否等于
    1。毕竟，用返回码 0 测试时，确实返回 false，用返回码 1 测试时，确实返回 true。但条件语句 `errorlevel 1` 等同于 `%errorlevel%
    geq 1` 和 `%errorlevel% gtr 0`。它对所有正整数返回 true。
- en: 'Couple this syntax with the not keyword for something truly opaque:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将这种语法与 `not` 关键字结合使用，效果将更加晦涩：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Doesn’t this look like a conditional clause that would evaluate to true when
    the return code isn’t equal to 0? It’s really the negation of the return code
    being greater than or equal to 0. The %errorlevel% lss 0 conditional clause is
    functionally equivalent and far more readable.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是一个在返回码不等于 0 时评估为 true 的条件语句吗？实际上它是返回码大于或等于 0 的否定。`%errorlevel% lss 0`
    条件语句功能等效，且可读性更强。
- en: Another problem with the syntax lacking a compare operator is that more often
    than not, 0 represents a good return code, and all others, including negative
    values, indicate a problem of some sort.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏比较运算符的语法的另一个问题是，通常情况下，0 代表良好的返回码，而其他所有值，包括负值，都表示某种问题。
- en: 'The neq operator results in this conditional clause being true for all nonzero
    values:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`neq` 运算符使得这个条件语句对所有非零值返回 true：'
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You may run across the arcane syntax, so it’s important to understand how it
    works, but it’s more important to not propagate it. Always use percent signs (or
    exclamation marks) and a compare operator to evaluate the errorlevel pseudo-environment
    variable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到这种晦涩的语法，因此理解其工作原理很重要，但更重要的是不要传播它。始终使用百分号符号（或感叹号）和比较运算符来评估 `errorlevel`
    伪环境变量。
- en: The if...else Construct
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if...else 结构
- en: 'One of the unwritten rules of coding languages is that an if command must come
    with the possibility of an else keyword. The keywords I mentioned earlier are
    associated with the conditional clause, but this one is tied to the if command
    itself. Here’s the general form of the if...else construct, where once again the
    italicized text must be replaced with code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言中的一条不成文规则是，if 命令必须配有 else 关键字。前面提到的关键字与条件语句相关，但这个关键字则与 if 命令本身紧密相连。下面是 if...else
    结构的一般形式，再次提醒，斜体文本必须替换为代码：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first two lines and the close parenthesis starting the third are identical
    to the general form I showed at the beginning of this chapter. The else keyword
    follows, and it in turn is followed by the false code block, set between a second
    set of parentheses. This represents the code that executes when the conditional
    clause evaluates to false.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行和第三行开头的右括号与我在本章开头展示的通用形式相同。接下来是 else 关键字，紧随其后的是 false 代码块，用第二对括号括起来。这表示当条件语句评估为
    false 时执行的代码。
- en: 'Here’s a simple example of an if...else construct:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的 if...else 结构示例：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If the fahrenheit variable is greater than 70, the pants variable is set to
    shorts. Otherwise, the pants variable is set to jeans. One or the other code block
    will always execute.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `fahrenheit` 变量大于 70，则 `pants` 变量设置为 shorts。否则，`pants` 变量设置为 jeans。总有一个代码块会被执行。
- en: 'You can condense this construct into a single line of code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将此结构压缩成一行代码：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The parentheses surrounding the code in the false code block are technically
    optional, but they should be included for readability.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 包围 false 代码块的括号在技术上是可选的，但为了可读性，建议包含括号。
- en: Unless you have contempt for those that’ll be reading your code, the one-line
    if...else construct is usually bad practice, although you might make exceptions
    for the simplest of tasks.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你对阅读你代码的人不屑一顾，否则单行的 if...else 结构通常不是一个好习惯，虽然对于最简单的任务你可能会例外。
- en: Unlike in other languages, in Batch the else keyword can’t be coded on a line
    of its own; it can’t even start or end a line. To clearly demarcate the two code
    blocks, it’s best to code the keyword sandwiched between the close and open parentheses
    on a single line.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言不同，在 Batch 中，else 关键字不能单独写在一行上；它甚至不能是行的开头或结尾。为了清晰地标记这两个代码块，最好将关键字夹在一对闭合和打开的括号之间，写在同一行。
- en: The else if Construct
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: else if 构造
- en: The if...else construct is great when there are exactly two branches in the
    logical flow, one for true and one for false. When there are more than two branches,
    the else if construct allows for multiple conditional clauses. [Listing 4-1](#Lis4-1)
    has three clauses and four branches, one branch for each conditional clause and
    a default branch that executes when none of the clauses evaluates to true.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: if...else 构造非常适合逻辑流程中只有两个分支的情况，一个用于 true，另一个用于 false。当分支超过两个时，else if 构造允许多个条件语句。[清单
    4-1](#Lis4-1)有三个语句和四个分支，每个条件语句对应一个分支，默认分支则在没有任何条件语句评估为 true 时执行。
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 4-1: An else if construct with four logical branches'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-1：具有四个逻辑分支的 else if 构造
- en: This logic assumes that fahrenheit is set to an integer describing the temperature.
    If it’s greater than 80 degrees, the first set command executes. If it’s greater
    than 60, which is to say between 61 and 80, inclusive, the second set command
    executes. If the first two conditional clauses are false and the mercury registers
    as above freezing, the third set command executes. If all three clauses are false,
    the temperature is 32 degrees or below, so the fourth and final set command assigns
    a very warm pair of pants.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 该逻辑假设 fahrenheit 被设置为描述温度的整数。如果大于 80 度，第一个 set 命令将执行。如果大于 60 度，也就是说在 61 到 80
    度之间（包括 80），第二个 set 命令将执行。如果前两个条件语句为 false 且温度高于冰点，第三个 set 命令将执行。如果所有三个条件语句为 false，则温度为
    32 度或更低，第四个也是最后一个 set 命令会分配一条非常暖和的裤子。
- en: There’s no open parenthesis immediately after the first else keyword. Instead,
    it’s followed by another if command with a conditional clause of its own and only
    then by the open parenthesis.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个 else 关键字后面没有紧跟着左括号。相反，它后面跟着另一个 if 命令，并带有自己的条件语句，然后才是左括号。
- en: '[Listing 4-1](#Lis4-1) contains two else if clauses, but you can code any number
    depending on the need. The interpreter executes the code block corresponding to
    the first conditional clause that evaluates to true; afterward, control jumps
    to the end of the entire construct without evaluating the other clauses.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-1](#Lis4-1)包含两个 else if 语句，但根据需要你可以编写任意数量的条件语句。解释器会执行第一个评估为 true 的条件语句对应的代码块；之后，控制跳转到整个结构的末尾，不会继续评估其他语句。'
- en: Many times, you’ll want a final code block executed if none of the conditional
    clauses is true—that is, a default code block. For instance, if [Listing 4-1](#Lis4-1)
    fails to set a certain variable, someone is in danger of leaving the house without
    the proper attire. The final else keyword is not followed by an if command, so
    its code block, the default code block, executes if none of the three conditional
    clauses prior to it evaluated to true.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，如果没有任何条件语句为 true，你可能需要执行一个最终的代码块，也就是默认的代码块。例如，如果[清单 4-1](#Lis4-1)未能设置某个变量，那么有人可能会在没有穿适当衣物的情况下离开家。最后的
    else 关键字后面没有 if 命令，因此它的代码块（默认代码块）会在前面三个条件语句都未评估为 true 时执行。
- en: 'In [Listing 4-1](#Lis4-1), fahrenheit is being interrogated to determine in
    which of four ranges it falls. This is a popular use of else if conditional clauses,
    but they don’t have to be so closely linked. Each conditional clause can interrogate
    completely different variables or make use of the three keywords covered earlier.
    For example, here’s a reimagining of [Listing 4-1](#Lis4-1) with only the three
    conditional clauses changed:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 4-1](#Lis4-1)中，fahrenheit 被用来判断它落在哪四个范围中的哪个范围。这是使用 else if 条件语句的常见方式，但它们并不一定要紧密关联。每个条件语句可以检查完全不同的变量，或者使用之前提到的三个关键字。例如，下面是[清单
    4-1](#Lis4-1)的重新构想，只有三个条件语句发生了变化：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first conditional clause performs a case-insensitive compare for equality
    of a resolved variable and hardcoded text. The second clause is looking for the
    existence of a file, and the third is looking to see whether the value of the
    celsius variable is above the freezing point. Once again, due to the default code
    block, this code is guaranteed to set the variable to one of the four values.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个条件子句执行不区分大小写的相等比较，比较已解析的变量与硬编码文本。第二个子句是检查文件是否存在，第三个子句是检查 celsius 变量的值是否高于冰点。再次由于默认的代码块，这段代码保证将变量设置为四个值之一。
- en: Enhanced Equality Determination Techniques
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增强的相等性判定技巧
- en: 'I would be remiss if I didn’t mention an important batveat associated with
    these conditional clauses. In some of the examples in this chapter I’ve surrounded
    each side of the equality with double quotes in a conditional clause, but without
    them the commands would still work—most of the time. The following two if commands
    are very similar but *not* functionally equivalent:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我不提到与这些条件子句相关的一个重要警告，我将感到遗憾。在本章的一些示例中，我将相等式两侧都用双引号括起来，但即使没有它们，命令通常仍然会工作。以下两个
    if 命令非常相似，但*功能上不*等价：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If myMood is set to happy, the clause evaluates to true, and if it’s set to
    sad, the result is false. Either way, it works for both commands.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 myMood 设置为 happy，则子句评估为 true；如果设置为 sad，结果为 false。无论哪种情况，它对这两个命令都有效。
- en: 'That’s great, but now imagine that the variable hasn’t been set or that it’s
    been set to null or some number of spaces. The command without the double quotes
    will crash, but it hints at the issue with the following cryptic message (assuming
    you haven’t used the echo off command mentioned in [Chapter 2](chapter2.xhtml)):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒，但现在假设变量没有设置，或者它被设置为 null 或某些空格。没有双引号的命令会崩溃，但它通过以下含糊的消息提示了问题（假设你没有使用 [第 2
    章](chapter2.xhtml) 中提到的 echo off 命令）：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first line here is the error message, and it’s followed by what has confused
    the interpreter. To understand the error, we must think like the interpreter.
    Once it sees the if command start the line, it expects one out of a finite list
    of items to come next (maybe not, exist, defined, or /i), with anything unrecognizable
    assumed to be the left side of a conditional clause. Obviously, it finds /i. Assuming
    that one of the three keywords doesn’t come next, the interpreter is now expecting
    exactly three items in a specific order: some text; an operator such as equ, neq,
    or ==; and some more text. If the value of myMood is pretty much anything, it
    will resolve to be the first text field. The interpreter will then be pleased
    to find the equ operator, and knowing that it’s dealing with an equality, it’ll
    interpret the hardcoded happy as being the right side of that equality. *Success*.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一行是错误消息，接下来是困惑解释器的内容。要理解这个错误，我们必须像解释器一样思考。一旦它看到 if 命令开始这一行，它期望接下来是有限列表中的某个项（可能是
    not、exist、defined 或 /i），任何无法识别的内容都会被假定为条件语句的左侧部分。显然，它找到了 /i。假设接下来没有出现三个关键字之一，解释器现在期望的是三个特定顺序的项目：一些文本；一个运算符，如
    equ、neq 或 ==；以及更多文本。如果 myMood 的值几乎是任何东西，它将被解析为第一个文本字段。解释器接着会很高兴地找到 equ 运算符，并且知道它正在处理一个相等式，它会将硬编码的
    happy 解释为这个相等式的右侧。*成功*。
- en: This all blows up when the variable resolves to nothing or any number of spaces.
    The interpreter sees if /i to start the statement, so it doesn’t expect to see
    equ next. The not keyword would’ve made sense, but not equ. As a result, it incorrectly
    considers equ to be the left side of what might be an equality and what comes
    next to be the operator. But what comes next is the happy text, and the list of
    operators clearly doesn’t contain this word. As the message states, the interpreter
    doesn’t expect to see happy at this time. *Failure*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量解析为空或任何数量的空格时，所有的逻辑就会崩溃。解释器看到 if /i 开始语句，因此它不期望接下来看到 equ。not 关键字本来是合理的，但不是
    equ。因此，它错误地认为 equ 是可能的相等式的左侧，而接下来的内容应该是运算符。但接下来是 happy 文本，而运算符列表显然不包含这个单词。正如消息所述，解释器此时不期望看到
    happy。*失败*。
- en: Fortunately, there are two methods of evaluating variables that might resolve
    to nothing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有两种评估可能解析为空的变量的方法。
- en: The Preceding Dot Technique
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 前导点技巧
- en: 'One common technique to get around this issue is to prefix each side of the
    equality with a dot, or almost any character as long as it’s applied consistently,
    so that the interpreter will definitely find something on both sides of the equality:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种常见技巧是，在等式的每一边加上一个点符号，或者几乎任何字符，只要它一致应用，这样解释器就一定能在等式两边找到内容：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding dot technique works nicely when the variable is set to null, as
    the command resolves to if /i . equ .happy. The dot isn’t equal to the dot followed
    by the word, so it evaluates to false, and we move on. If the variable had been
    set to happy, the command would’ve been resolved to if /i .happy equ .happy, and
    equality would’ve been found. *Success.*
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前导点技巧在变量设置为空时效果很好，因为命令会解析为if /i . equ .happy。点符号不等于点符号加上单词，所以它被评估为false，然后我们继续。如果变量被设置为happy，命令将解析为if
    /i .happy equ .happy，并且会找到相等性。*成功*。
- en: 'But I’m not a fan of this technique because it’s susceptible to yet another
    batveat. Now imagine that the variable is set to a two-word mood, such as irritably
    depressed—not good on many levels having nothing to do with the Batch code. Again,
    it blows up:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 但我不太喜欢这种技巧，因为它容易受到另一个陷阱的影响。现在假设变量被设置为一个由两个单词组成的情绪，比如“恼怒的沮丧”——从多个方面来看，这与 Batch
    代码无关，实在不好处理。再次出现问题：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Don’t get down. The interpreter is fooled by the embedded space. Don’t tell
    anyone, but it really isn’t that bright. It thinks that .irritably is the left
    side of the clause and finds depressed to be a completely unexpected operator.
    *Failure*. But there’s another technique.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 别灰心。解释器被嵌入的空格骗了。别告诉别人，但它真的没有那么聪明。它认为.irritably是子句的左边，并将depressed视为完全意外的运算符。*失败*。但是，还有另一种技巧。
- en: The Double Quotes Technique
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 双引号技巧
- en: 'Coming full circle, this brings us back to the example with the double quotes
    around each side of the equality:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 回到最初的例子，这将我们带回到在等式两边加上双引号的情况：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The double quotes here provide something on either side of the equality just
    as the dot did, but that’s not all.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的双引号与前导点提供的内容类似，但并不仅仅是如此。
- en: 'The interpreter considers everything inside the double quotes to be one entity.
    When the variable with the embedded space is resolved, the interpreter sees this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器将双引号内的所有内容视为一个整体。当带有嵌入空格的变量被解析时，解释器会看到如下内容：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Despite the embedded space, the interpreter treats "irritably depressed" as
    one entity, or in this case the left side of the equality, with the right side
    being "happy". The upshot is that Batch correctly recognizes these two entities
    as not being equal. *Success*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有嵌入空格，解释器将“irritably depressed”视为一个整体，或者在这种情况下视为等式的左侧，右侧为“happy”。结果是 Batch
    正确地识别出这两个实体是不相等的。*成功*。
- en: If there’s a chance that the alphanumeric variable being interrogated might
    not be set or that it might contain embedded spaces, I almost always encase each
    side of the clause with double quotes. However, you may have noticed that I don’t
    have double quotes encasing %errorlevel% when used in a conditional clause. That
    variable will always be set to a number, so there’s no need for the quotes. Even
    more important, when the interpreter sees numbers being compared without quotes,
    it does a numeric compare, meaning that 000 is equivalent to 0. Adding the quotes
    results in a text compare, and "000" isn’t equal to "0".
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果被查询的字母数字变量可能未设置，或者可能包含嵌入的空格，我几乎总是会在等式的每一边加上双引号。然而，你可能注意到我在条件子句中没有加上双引号来包围%errorlevel%。该变量总是被设置为一个数字，因此不需要引号。更重要的是，当解释器看到没有引号的数字进行比较时，它会做数值比较，意味着000等于0。加上引号则会进行文本比较，“000”就不等于“0”了。
- en: Preceding Dot vs. Double Quotes
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 前导点与双引号
- en: When comparing alphanumeric values, I *usually* encase each side of the equality
    with double quotes. It works when a value is null; it works when a value is one
    or more spaces; it works when a value has embedded spaces; and it works for more
    typical non-null spaceless values. However, I’m using the nondefinitive qualifier
    *usually* because of an extremely fine point.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较字母数字值时，我*通常*会在等式的每一边加上双引号。当一个值为空时有效；当一个值是一个或多个空格时有效；当一个值中有嵌入的空格时有效；当一个值是更典型的非空格值时也有效。然而，我之所以使用非定语修饰词*通常*，是因为有一个非常细微的点。
- en: Consider the case of a variable containing a value with a trailing space. Perhaps
    the value sad is padded with a trailing space to make a four-character value.
    Is that equal to the three-character value sad? In the purest and most accurate
    sense, no, they aren’t equal—and using the double quote method correctly finds
    them to be different. But in a less strict scenario you might consider these values
    to be equivalent.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个变量包含一个带有尾随空格的值。也许值sad是通过在尾部添加空格来填充的，变成了四个字符的值。这与三个字符的值sad相等吗？从最纯粹和最准确的角度来看，不，它们是不相等的——使用双引号方法正确地可以发现它们是不同的。但在一个不那么严格的场景下，你可能会认为这些值是相等的。
- en: Using the dot method will find equality between the two values because the trailing
    space becomes just another space between the left side of the equality and the
    operator. In this narrow instance of trailing spaces, the dot method is better,
    but it’ll work only if the variables don’t have any embedded spaces.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用点号方法会找到两个值相等，因为尾随空格只是成为了等号左侧与操作符之间的一个普通空格。在这种尾随空格的狭窄情况中，点号方法更好，但它只在变量没有嵌入空格的情况下才有效。
- en: In the final analysis, the double quote technique is far superior to the dot
    method, with one very distinctive case when it isn’t. Get into the habit of using
    double quotes for almost all non-numeric compares.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最终分析，双引号技巧远胜于点号方法，虽然在某些特定情况下它不是。养成几乎在所有非数字比较中使用双引号的习惯。
- en: NOTE
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Batch provides an interesting and compact alternative to the if command, although
    it does behave differently. It’s not a command, it doesn’t have any keywords,
    and it doesn’t even support a conditional clause. In [Chapter 28](chapter28.xhtml),
    I’ll return to the topic of conditional execution and provide more details about
    what it is than what it isn’t.*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*Batch提供了一个有趣且紧凑的替代方案来代替`if`命令，尽管它的行为有所不同。它不是一个命令，没有任何关键字，甚至不支持条件语句。在[第28章](chapter28.xhtml)中，我将回到条件执行的话题，并提供更多关于它是什么的信息，而不是它不是什么。*'
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: The if command is instrumental in virtually all, if not all, coding languages,
    and Batch is no different. In this chapter you learned about the conditional clause,
    including its valid operators for comparing two operands and its keywords for
    proving out the existence of a variable, path, or file, and what happens when
    the clause evaluates to true and false. You also learned how to evaluate multiple
    clauses so as to execute multiple branches of logic conditionally.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`命令在几乎所有，甚至是所有，编程语言中都是必不可少的，Batch也不例外。在本章中，你了解了条件语句，包括其比较两个操作数的有效运算符，以及用于验证变量、路径或文件是否存在的关键字，以及当条件为真或假时会发生什么。你还学习了如何评估多个条件语句，以便有条件地执行多个逻辑分支。'
- en: As is often the case, Batch gives you a little more to consider, so I detailed
    useful techniques to enhance your conditional clauses comparing both alphanumeric
    and numeric values. But what makes a value alphanumeric or numeric? I’ll answer
    that question in the next two chapters concerning data types.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如常见情况，Batch给了你更多需要考虑的内容，因此我详细介绍了增强条件语句的有用技巧，比较了字母数字值和数字值。但是，什么样的值算作字母数字值或数字值呢？我将在接下来的两章中讨论数据类型，来回答这个问题。
