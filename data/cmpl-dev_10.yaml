- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">AUTHORIZATION
    WITH OAUTH</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">使用OAuth进行授权</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/Drop-image.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Drop-image.jpg)'
- en: Certain apps store data about users as part of a login workflow. There are many
    ways to implement this authentication and authorization, but one of the easiest
    is to use OAuth2 to piggyback on the existing accounts of well-known companies.
    *OAuth2*, or simply *OAuth*, is an open standard for access delegation, and you’ve
    probably encountered it if you’ve ever used an app’s “log in with Facebook, GitHub,
    or Google Account” feature.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 某些应用程序会在登录工作流中存储有关用户的数据。实现此身份验证和授权的方法有很多种，但最简单的方法之一是使用OAuth2，借用知名公司现有账户进行登录。*OAuth2*，简称*OAuth*，是一种开放的访问委托标准，如果你曾使用过某个应用的“用
    Facebook、GitHub 或 Google 账户登录”功能，可能已经遇到过它。
- en: The OAuth protocol essentially allows our web application to access another
    application’s login data without requiring the third party to share a user’s credentials
    with us. To do so, the user grants our application access rights to their third-party
    account through the creation of an access token. OAuth is the accepted standard
    for authorization-based access delegation, and Amazon, Google, Facebook, Microsoft,
    and GitHub all support OAuth workflows.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth协议本质上允许我们的Web应用访问另一个应用的登录数据，而无需第三方与我们共享用户凭证。为了实现这一点，用户通过创建访问令牌授予我们的应用其第三方账户的访问权限。OAuth是授权访问委托的公认标准，亚马逊、谷歌、Facebook、微软和GitHub都支持OAuth工作流。
- en: This chapter will introduce you to the OAuth workflow and then explore the structure
    of the bearer tokens used for its access delegation, laying the foundation for
    implementing OAuth2 into your Food Finder application in [Part II](part2.xhtml).
    In [Exercise 9](#Exe9) on page 168, we won’t update our sample Next.js application
    with an OAuth flow but instead manually walk through the OAuth authorization process.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍OAuth工作流，然后探讨用于访问委托的持有者令牌的结构，为在[第二部分](part2.xhtml)中将OAuth2集成到你的“食物查找器”应用中奠定基础。在第168页的[练习9](#Exe9)中，我们不会通过OAuth流程更新我们的示例Next.js应用，而是手动演示OAuth授权过程。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How OAuth Works</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">OAuth如何工作</samp>
- en: Before we explore OAuth, you need to understand the differences between authentication
    and authorization. In short, we use authentication to verify the identity of a
    user, whereas authorization specifies the permissions that the authenticated user
    possesses and enforces those permissions. OAuth allows for that process to be
    delegated to a third party with which the user already has an account, which simplifies
    the login process for the user.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨OAuth之前，你需要理解身份验证和授权之间的区别。简而言之，我们使用身份验证来验证用户的身份，而授权则指定经过身份验证的用户所拥有的权限，并强制执行这些权限。OAuth允许将这一过程委托给用户已经拥有账户的第三方，从而简化了用户的登录过程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authentication vs.
    Authorization</samp>
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">身份验证与授权</samp>
- en: Every time an app receives a login request, it checks the user’s credentials
    before allowing access, a process called *authentication*. Usually, those credentials
    consist of a username and a password, but they could also be hardware tokens or
    involve biometric factors such as fingerprints or facial recognition. The application
    then verifies that the credentials match the ones stored in the database.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每次应用收到登录请求时，都会在允许访问之前检查用户的凭证，这个过程叫做*身份验证*。通常，这些凭证包括用户名和密码，但也可能是硬件令牌，或者涉及生物特征因素，如指纹或面部识别。然后，应用验证凭证是否与数据库中存储的匹配。
- en: The simplest form of authentication is *single-factor authentication*, which
    requires only one factor, usually a password. Unfortunately, it is also the least
    secure method of implementing authentication. A more robust and recommended form
    is *multifactor authentication*, in which a user must supply at least two factors.
    These might be something the user *knows*, such as a password, as well as something
    the user *has*, such as a physical token, or something the user *is*, such as
    the owner of a fingerprint. You probably use multifactor authentication when you
    log in to PayPal or Google, both of which require you to supply your password
    and an additional one-time password (OTP).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的认证方式是*单因素认证*，只需要一个因素，通常是密码。不幸的是，它也是实施认证的最不安全的方法。更强大且推荐的方式是*多因素认证*，在这种方式中，用户必须提供至少两个因素。这些因素可能是用户*知道*的东西，比如密码，或者是用户*拥有*的东西，比如实体令牌，或是用户*具备*的东西，比如指纹拥有者。你在登录PayPal或Google时可能会使用多因素认证，这两个平台都要求你提供密码和一个额外的一次性密码（OTP）。
- en: The OTP is a code that is created based on a secret shared between you and the
    application when you register your account. Both actors regenerate the pair in
    short intervals. Yours may be generated by an authenticator app, like Google Authenticator,
    or received in a text message. The application at which you have the account (for
    example, PayPal or Google) generates its own OTP code and keeps it on the server.
    As soon as you send yours, the server verifies that the codes cryptographically
    match.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: OTP是一个基于你与应用程序在注册账户时共享的秘密生成的代码。两个参与方会在短时间间隔内重新生成这一对代码。你的OTP可能是通过类似Google Authenticator的身份验证器应用生成，或者通过短信接收。你拥有账户的应用程序（例如PayPal或Google）会生成自己的OTP代码并将其保存在服务器上。你发送的OTP一旦到达服务器，服务器就会加密验证这些代码是否匹配。
- en: We perform authorization after we’ve authenticated a user. Broadly speaking,
    this involves looking at the user’s data and deciding whether they have the access
    rights needed to access a resource. A typical full-stack application can either
    handle this user data or enable users to log in without providing user data. There
    are benefits to the latter approach, as handling and storing user data can be
    inconvenient. It also comes with additional responsibilities, such as the need
    to adhere to stricter privacy and data retention laws, and requires your users
    to create another account.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在验证用户身份后执行授权。广义上说，这涉及查看用户的数据并决定他们是否拥有访问资源所需的权限。一个典型的全栈应用程序要么处理用户数据，要么允许用户在不提供用户数据的情况下登录。后者的做法有其优势，因为处理和存储用户数据可能不方便。它还伴随着额外的责任，比如需要遵守更严格的隐私和数据保留法律，并且要求用户创建另一个账户。
- en: Suppose you provide users with the option to log in with an existing account
    through an authorization provider. In that case, you’ve removed an entry barrier.
    Also, you don’t need to worry about handling their data. If you need user data—for
    example, to bill your customers—you can use an OAuth workflow and save the data
    you receive from the provider, such as the user’s payment details, in your own
    database if necessary.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你为用户提供通过授权提供者使用现有账户登录的选项，那么你就移除了一个进入门槛。同时，你也无需担心处理他们的数据。如果你需要用户数据——例如，用于向客户收费——你可以使用OAuth工作流，并在必要时将从提供者接收到的数据（如用户的支付信息）保存在你自己的数据库中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Role of OAuth</samp>
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">OAuth的作用</samp>
- en: Every time a web application enables you to log in through a third-party provider
    such as Facebook, GitHub, or Google, it uses the OAuth authorization code flow
    behind the scenes. OAuth isn’t authentication; rather, it’s a way of authorizing
    the web application you use to perform actions or to access resources on your
    behalf. Common actions include posting to your Facebook feed and accessing data
    such as your name, profile picture, or email address. Consequently, each time
    you use an OAuth-based login function, the application asks for particular permissions
    and can use only those you grant to it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个Web应用程序允许你通过第三方提供者（如Facebook、GitHub或Google）登录时，它背后使用的是OAuth授权码流。OAuth并不是认证；它是一种授权你使用的Web应用程序代你执行操作或访问资源的方式。常见的操作包括发布到你的Facebook动态和访问诸如姓名、头像或电子邮件地址等数据。因此，每次你使用基于OAuth的登录功能时，应用程序会请求特定的权限，并且只能使用你授予的权限。
- en: To understand OAuth, you must understand its terminology. Each OAuth flow uses
    a set of RESTful APIs to authorize the *client* (an application) to get resources
    (such as the user’s profile information) from a *resource provider* (such as Facebook,
    GitHub, or Google) that has the protected resources the client wants to access.
    In addition, we call the server that provides the OAuth API endpoints the *authorization
    server*, and the party that owns the access rights (and, hence, has the ability
    to grant an application access to a resource) the *resource owner*. In most scenarios,
    the resource owner is the application’s end user.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 OAuth，你必须了解它的术语。每种 OAuth 流程都使用一组 RESTful API 授权*客户端*（即应用程序）从*资源提供者*（如 Facebook、GitHub
    或 Google）获取资源（例如用户的个人信息），而这些资源是客户端希望访问的受保护资源。此外，我们将提供 OAuth API 端点的服务器称为*授权服务器*，将拥有访问权限（因此能够授权应用访问资源）的方称为*资源所有者*。在大多数情况下，资源所有者是应用的最终用户。
- en: To get the resource owner’s authorization, the client application sends its
    client credentials, the ID, the secret, and the user credentials to the authorization
    server, which usually is part of the same system as the resource provider. The
    authorization server authenticates the resource owner and handles the OAuth flow
    that results in granting them an *access token*, which allows the user to access
    the protected resources on the resource provider. Both the authorization server
    and the resource provider are two sets of APIs on the same system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取资源所有者的授权，客户端应用将其客户端凭证（包括ID、密钥和用户凭证）发送到授权服务器，授权服务器通常是与资源提供者相同系统的一部分。授权服务器验证资源所有者的身份，并处理
    OAuth 流程，从而授予其*访问令牌*，该令牌允许用户访问资源提供者上的受保护资源。授权服务器和资源提供者都是同一系统上的两组 API。
- en: The *client ID* is a public identifier for the client app; you can make it public
    and store it in the code. Unlike the client ID, the *client secret* should be
    kept private; it is the app-specific password, and you should never store it in
    your code. Instead, handle it using Next.js’s environment files or your server’s
    environment variables.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*客户端 ID*是客户端应用的公共标识符；你可以将其公开并存储在代码中。与客户端 ID 不同，*客户端密钥*应该保持私密；它是应用程序专用的密码，绝不应该存储在代码中。相反，应该使用
    Next.js 的环境文件或服务器的环境变量来处理它。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Grant Types</samp>
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">授权类型</samp>
- en: 'There are several variants of the OAuth flow. Each of these *grant types* covers
    a specific use case, but all result in the generation of an access token. OAuth
    specifies four grant types: the client credentials flow, the implicit flow, the
    authorization code flow, and the resource owner password credentials flow.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 流程有多个变体。每种*授权类型*都覆盖一个特定的用例，但所有类型都最终生成访问令牌。OAuth 定义了四种授权类型：客户端凭证流程、隐式流程、授权码流程和资源所有者密码凭证流程。
- en: The *client credentials flow* covers machine-to-machine communication; we use
    it when no actual end user authorization is necessary, as in the case of automated
    tasks that connect to an API. Here, the task itself is both the client and the
    resource owner. It knows the resource owner’s credentials, the client ID, and
    the client secret and passes these to the authorization server to receive an access
    token.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*客户端凭证流程*涵盖机器对机器的通信；当不需要实际的最终用户授权时（例如自动化任务连接到 API 时），我们使用它。在这种情况下，任务本身既是客户端也是资源所有者。它知道资源所有者的凭证、客户端
    ID 和客户端密钥，并将这些信息传递给授权服务器以获取访问令牌。'
- en: The most common grant type for full-stack web development is the *authorization
    code flow*. In this scenario, our web application is a client, and it makes two
    calls to two separate API endpoints. The first is to receive an authorization
    grant code, and the second is to exchange this authorization grant for an access
    token. “The Authorization Code Flow” on page 161 provides a deep dive into this
    process.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 完整栈网页开发中最常见的授权类型是*授权码流程*。在这种情况下，我们的网页应用是一个客户端，它会分别调用两个不同的 API 端点。第一个是接收授权授权码，第二个是用该授权码交换访问令牌。第161页的“授权码流程”深入讲解了这一过程。
- en: The last two grant types shouldn’t be used. The *implicit flow* is similar to
    the authorization code flow, but instead of making separate requests to receive
    the authorization grant and access token, the client receives the access token
    directly. This flow skips the authorization step, doesn’t include client authentication,
    and is deprecated. The *resource owner password credentials flow* should be avoided
    because it involves the end user passing their user credentials to the client
    and then the client sending these credentials to the OAuth server to exchange
    them for the access token. While this sounds straightforward, sending actual user
    credentials to the remote authorization server is an immense security risk.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两种授权类型不应该使用。*隐式流程*类似于授权代码流程，但不同之处在于，客户端直接接收访问令牌，而不需要分别发送请求以接收授权许可和访问令牌。这个流程跳过了授权步骤，不包含客户端认证，并且已经被弃用。*资源所有者密码凭证流程*应该避免使用，因为它涉及终端用户将自己的凭据传递给客户端，然后客户端将这些凭据发送给
    OAuth 服务器以交换访问令牌。虽然这听起来很直接，但将实际用户凭据发送给远程授权服务器是一个巨大的安全风险。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bearer Tokens</samp>
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">承载令牌</samp>
- en: After the client application initiates an OAuth flow, it receives a shared access
    token, most commonly a *bearer token* that is easy to implement. This access token
    replaces the user’s credentials; hence, anyone who has the token can access the
    data. To prevent security gaps caused by stolen tokens, a bearer token usually
    has a defined shelf life. Upon expiration, the token can be refreshed only with
    a valid *refresh token*. These are long-lived tokens that we use to generate new
    bearer tokens.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序启动 OAuth 流程后，会收到一个共享访问令牌，最常见的是容易实现的*承载令牌*。这个访问令牌替代了用户的凭据；因此，任何拥有该令牌的人都可以访问数据。为了防止因令牌被盗而导致的安全漏洞，承载令牌通常有一个定义的有效期。过期后，令牌只能通过有效的*刷新令牌*进行刷新。这些是长期有效的令牌，我们用它们来生成新的承载令牌。
- en: Refreshing the token can be done implicitly or explicitly, and there are multiple
    strategies for preventing stolen refresh tokens from compromising the OAuth access.
    For example, the OAuth provider can require a unique ID or the client secret to
    issue a new token. The provider usually rotates the refresh token each time a
    new bearer token is issued and accepts each refresh token only once. From our
    perspective as OAuth clients, the details of the refresh token are unimportant,
    as the OAuth provider handles this token.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新令牌可以通过隐式或显式方式进行，并且有多种策略可以防止被盗的刷新令牌危及 OAuth 访问。例如，OAuth 提供者可以要求一个唯一的 ID 或客户端密钥来发放新令牌。每次发放新的承载令牌时，提供者通常会旋转刷新令牌，并且每个刷新令牌只能使用一次。从我们作为
    OAuth 客户端的角度来看，刷新令牌的细节并不重要，因为 OAuth 提供者会处理这个令牌。
- en: The bearer token that contains the user session and authentication data is a
    *JSON Web Token (JWT)*. JWT is an open standard for securely transmitting data
    in a JSON object. Because JSON is fairly compact, JWTs can be sent as URL parameters,
    as part of the POST data, or even inside an HTTP header, all without impacting
    the application’s performance.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 包含用户会话和认证数据的承载令牌是*JSON Web Token（JWT）*。JWT 是一个开放标准，用于安全地传输 JSON 对象中的数据。由于 JSON
    格式相对紧凑，JWT 可以作为 URL 参数、POST 数据的一部分，甚至嵌入 HTTP 头中发送，且不会影响应用程序的性能。
- en: JWT tokens can be signed as well as encrypted, saving the application from needing
    to make an additional request to verify it or retrieve extra data. *Encrypted
    tokens* hide the contained data from other parties. These aren’t very common in
    OAuth due to their additional overhead, so we can ignore them for now. *Signed
    tokens* guarantee the integrity of the contained data, because any modification
    to the token would change its signature. Thus, the application can trust the information
    stored in it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 令牌既可以签名也可以加密，从而避免应用程序需要额外请求来验证或获取额外数据。*加密令牌*将其中的数据隐藏起来，防止其他方访问。这种方式在 OAuth
    中不常见，因为它带有额外的开销，所以我们现在可以忽略它们。*签名令牌*保证了其中数据的完整性，因为对令牌的任何修改都会改变其签名。因此，应用程序可以信任其中存储的信息。
- en: 'The most common cryptographic algorithm for signing JWTs is *hash-based message
    authentication code (HMAC)* with the SHA-256 hash algorithm. An HMAC is a type
    of message authentication code (MAC). A MAC’s main feature is that it enables
    you to verify the authenticity of a message by calculating a checksum from the
    message. The checksum uses a mathematical function to produce a unique, reproducible
    value or data string based on the initial message. If the message changes, the
    checksum changes as well. This way, we can quickly verify the integrity of the
    data. For the JWT token, we use two checks: the authenticity check confirms that
    the actual sender sent the message, whereas the data integrity checks verify that
    the message’s content did not change.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 签名JWT最常用的加密算法是*基于哈希的消息认证码（HMAC）*，并使用SHA-256哈希算法。HMAC是一种消息认证码（MAC）。MAC的主要特点是，它能够通过从消息中计算校验和来验证消息的真实性。校验和使用数学函数根据初始消息生成唯一且可重现的值或数据字符串。如果消息发生变化，校验和也会发生变化。通过这种方式，我们可以快速验证数据的完整性。对于JWT令牌，我们使用两个检查：真实性检查确认实际发送者确实发送了消息，而数据完整性检查则验证消息的内容未发生变化。
- en: Unlike other types of MACs, HMAC uses a cryptographic hash function and a secret
    key. You can freely choose the cryptographic hash function, but the strength of
    your HMAC implementation depends on the cryptographic strength of the selected
    function. JWTs commonly use the SHA-256 hash function, a fast and collision-resistant
    cryptographic function from the SHA-2 collection also used for authenticating
    Debian software packages and Bitcoin transactions. In cryptography, *collisions*
    occur when two different inputs result in the same output. The higher the possibility
    of a collision, the less we can trust the checksum of the hash function. If a
    collision is likely, our message could be replaced with a different one, but the
    hash function could indicate that it hasn’t changed. Therefore, we want collision-resistant
    cryptographic functions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类型的MAC不同，HMAC使用加密哈希函数和密钥。你可以自由选择加密哈希函数，但HMAC实现的强度取决于所选函数的加密强度。JWT通常使用SHA-256哈希函数，这是SHA-2集合中的一种快速且抗碰撞的加密函数，广泛应用于Debian软件包认证和比特币交易验证。在加密学中，*碰撞*指的是两个不同的输入产生相同的输出。当碰撞的可能性较高时，我们就无法信任哈希函数的校验和。如果发生碰撞，我们的消息可能被替换为不同的内容，但哈希函数却可能表明消息没有变化。因此，我们希望使用抗碰撞的加密函数。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Authorization Code Flow</samp>
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">授权码流程</samp>
- en: To understand how an OAuth interaction takes place using the authorization code
    flow mentioned earlier, let’s return to our fictional weather service. Imagine
    that you want to grant weather stations the ability to write data to the application
    by using the API, but a station should be able to modify only its own ZIP code.
    You also want the application to display the weather stations’ locations and additional
    details about them. Additionally, you prefer not to deal with the maintenance
    of user accounts or to manually set up permissions for each station, so using
    OAuth is your best bet.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解如何使用前面提到的授权码流程进行OAuth交互，我们回到我们的虚拟天气服务。假设你希望通过API授予气象站向应用程序写入数据的权限，但一个气象站只能修改它自己的邮政编码。你还希望应用程序能够显示气象站的位置及其其他详细信息。此外，你更倾向于不处理用户账户的维护或为每个站点手动设置权限，因此使用OAuth是最佳选择。
- en: Let’s assume that each weather station already has a social media account for
    publishing weather updates. These accounts include typical user information and
    the stations’ ZIP codes. We could easily use the social media provider as an OAuth
    authorization provider to access this data. The stations would log in to the weather
    app using the social media provider, and the app would request access to the weather
    station’s user profile. We could then check the ZIP code stored in the OAuth session
    against the one in our dataset, provide the appropriate write access, and retrieve
    any other data we need.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设每个气象站已经拥有一个用于发布天气更新的社交媒体账户。这些账户包含典型的用户信息和气象站的邮政编码。我们可以轻松地使用社交媒体提供商作为OAuth授权提供者来访问这些数据。气象站会使用社交媒体提供商登录到天气应用，应用则请求访问气象站的用户资料。然后，我们可以检查OAuth会话中存储的邮政编码与我们数据集中的邮政编码是否匹配，从而提供适当的写入权限，并检索所需的其他数据。
- en: Only a few steps are necessary for implementing this authorization code flow.
    [Figure 9-1](chapter9.xhtml#fig9-1) is a simplified description of these steps.
    Usually, developers use an SDK or a Node.js module to implement the steps and
    need to provide only a few properties, such as the client ID, client secret, and
    callback URL.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个授权码流程只需要几个步骤。[图 9-1](chapter9.xhtml#fig9-1)是这些步骤的简化描述。通常，开发者使用SDK或Node.js模块来实现这些步骤，只需要提供几个属性，例如客户端ID、客户端密钥和回调URL。
- en: '![](../images/Figure9-1.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 9-1: A simplified OAuth
    authorization grant flow</samp>'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 9-1：简化的OAuth授权码流程</samp>
- en: To register our app as an OAuth client, we need to provide GitHub with a *callback
    URL* to our application, to which GitHub will redirect the user after the authorization
    request. This endpoint on our application receives the authorization grant. Recent
    OAuth implementations require the callback URL to use HTTPS as a way to protect
    the token from being intercepted.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的应用注册为OAuth客户端，我们需要向GitHub提供一个*回调URL*，该URL会在授权请求后将用户重定向到我们的应用程序。我们应用程序中的此端点接收授权码。最近的OAuth实现要求回调URL使用HTTPS，以保护令牌免受拦截。
- en: Our app must use the resource owner’s credentials and the client credentials,
    an ID, and a secret to communicate with GitHub’s authorization server. The ID
    identifies the client, and the secret authenticates it. The app can then request
    the authorization to access specific resources, such as a weather station’s profile
    data. To do so, the weather station user needs to log in to GitHub’s authorization
    server. They’ll see a prompt that summarizes the requested access resources, such
    as read and write access to the profile or stream. If the user authorizes the
    requests with their user credentials, the OAuth client receives the authorization
    grant as a GET parameter in the callback URL, and the OAuth SDK we use in our
    application exchanges the authorization grant for an access token at the authorization
    server in the next step of the flow.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序必须使用资源所有者的凭据和客户端凭据（ID和密钥）与GitHub的授权服务器进行通信。ID用于标识客户端，密钥用于验证客户端身份。然后，应用程序可以请求授权以访问特定资源，例如天气站的个人资料数据。为此，天气站用户需要登录到GitHub的授权服务器。他们将看到一个提示，概述请求的访问资源，例如读取和写入个人资料或流数据。如果用户使用其凭据授权请求，OAuth客户端将在回调URL中以GET参数形式接收授权码，并且我们在应用程序中使用的OAuth
    SDK将在流程的下一步中将授权码交换为访问令牌。
- en: Here, the OAuth client uses the client credentials, which are the client ID
    and client secret, in combination with the previously received authorization grant
    to request an access token from the OAuth provider’s authorization server. It
    is part of the GitHub infrastructure, and to complete the authorization flow,
    the authorization server authenticates the identity and verifies that the grant
    is valid for this identity. Finally, the app receives the bearer token from here
    and stores it in the user session.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，OAuth客户端使用客户端凭据（客户端ID和客户端密钥），并结合先前收到的授权码向OAuth提供者的授权服务器请求访问令牌。它是GitHub基础设施的一部分，为了完成授权流程，授权服务器会验证身份并确认该授权码对该身份有效。最后，应用程序从此处接收承载令牌并将其存储在用户会话中。
- en: With the token and the user session received from the OAuth provider, our app
    can now act on the user’s behalf and access their protected resources, such as
    the profile data from the resource server. To act on their behalf, we add the
    bearer token to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Authorization</samp>
    header in the HTTP requests; the OAuth provider checks our granted permission
    and verifies our identity with this token. To access the user’s data, we simply
    extract it from the session data and use it in our application’s code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用从OAuth提供者接收到的令牌和用户会话，我们的应用程序现在可以代表用户行动并访问他们的受保护资源，例如来自资源服务器的个人资料数据。为了代表他们行动，我们在HTTP请求的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Authorization</samp>头中添加承载令牌；OAuth提供者检查我们的授权权限，并通过该令牌验证我们的身份。为了访问用户的数据，我们只需从会话数据中提取并在应用程序的代码中使用它。
- en: For the weather application, we could use the second option to query location-specific
    weather data from our database. We’d need to read the location property from the
    user’s session data and use that value as the ZIP code supplied to our API endpoint.
    In addition, we can access other properties, such as the description and the name
    or profile picture, to display them on the weather application’s status page for
    each station.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于天气应用程序，我们可以使用第二种选项从数据库中查询特定位置的天气数据。我们需要从用户的会话数据中读取位置属性，并将该值作为 ZIP 代码传递给我们的
    API 端点。此外，我们还可以访问其他属性，如描述、姓名或个人资料图片，并将其显示在天气应用程序的每个站点状态页面上。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating a JWT Token</samp>
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">创建 JWT 令牌</samp>
- en: 'Most bearer tokens are JWTs, and while the authorization server automatically
    issues them, it’s good to know what kind of information you can find in them.
    This section will walk you through the process of creating an example OAuth JWT
    for the weather service app. The JWT is a string made up of three sections divided
    by periods (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>): the header,
    the payload, and the signature. The first two sections are Base64-encoded JSON
    objects, whereas the signature is a checksum of the previous two.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数持有者令牌都是 JWT，虽然授权服务器会自动发布它们，但了解其中包含的信息是很有帮助的。本节将引导您通过为天气服务应用创建示例 OAuth JWT
    的过程。JWT 是由三部分组成的字符串，这三部分通过句点 (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>)
    分隔：头部、有效负载和签名。前两部分是 Base64 编码的 JSON 对象，而签名则是前两部分的校验和。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Header</samp>
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">头部</samp>
- en: The first string we create is the *header*, which defines basic metadata such
    as the token’s type and the signatures used for the signing algorithm. [Listing
    9-1](chapter9.xhtml#Lis9-1) shows the creation of a simple header in JavaScript
    with the most essential metadata.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的第一个字符串是*头部*，它定义了基本的元数据，如令牌的类型和用于签名算法的签名。[列表 9-1](chapter9.xhtml#Lis9-1)展示了在
    JavaScript 中创建一个简单头部的过程，其中包含最基本的元数据。
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 9-1: The JWT header for the OAuth2 weather service'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-1：OAuth2 天气服务的 JWT 头部
- en: We set the type of the weather service’s token to <samp class="SANS_TheSansMonoCd_W5Regular_11">JWT</samp>
    and specify that we use the HMAC-SHA-256 algorithm to calculate the signature
    later. Finally, we store the JSON object in a constant to use later.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将天气服务的令牌类型设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">JWT</samp>，并指定后续使用
    HMAC-SHA-256 算法来计算签名。最后，我们将 JSON 对象存储在常量中，以便后续使用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Payload</samp>
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">有效负载</samp>
- en: 'Next, we create the second string, the *payload*, which stores the token’s
    data. Each property of the payload is called a *claim*. In OAuth, the claims describe
    the user object and, usually, the session data. The JWT specification contains
    three types of claims: registered, public, and private.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建第二个字符串，*有效负载*，它存储令牌的数据。有效负载的每个属性称为*声明*。在 OAuth 中，声明描述用户对象，通常也描述会话数据。JWT
    规范包含三种类型的声明：注册声明、公共声明和私有声明。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Registered Claims</samp>
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">注册声明</samp>
- en: There are seven registered claims, each three letters long. While not necessary
    in general JWTs, the <samp class="SANS_TheSansMonoCd_W5Regular_11">iss</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">auth</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> registered claims
    are required for OAuth JWTs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有七个注册声明，每个声明由三个字母组成。虽然在一般的 JWT 中不必要，但 <samp class="SANS_TheSansMonoCd_W5Regular_11">iss</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">auth</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> 这些注册声明是 OAuth JWT 中必须的。
- en: The *issuer claim*, <samp class="SANS_TheSansMonoCd_W5Regular_11">iss</samp>,
    contains a unique identifier for the entity that issued the JWT. A good value
    might be the application’s URL, as shown in [Listing 9-2](chapter9.xhtml#Lis9-2).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*发行者声明*，<samp class="SANS_TheSansMonoCd_W5Regular_11">iss</samp>，包含一个唯一的标识符，用于标识发布
    JWT 的实体。一个好的值可能是应用程序的 URL，如 [列表 9-2](chapter9.xhtml#Lis9-2) 所示。'
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 9-2: A registered issuer claim'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-2：一个注册的发行者声明
- en: The *subject claim*, <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>,
    identifies the principal to which the JWT belongs. For an OAuth client authentication
    flow, the subject claim must be the client ID of the OAuth client, whereas for
    an OAuth authorization grant, the subject should identify the resource owner or
    should pseudonymously identify an anonymous user. We create a sample subject claim
    in [Listing 9-3](chapter9.xhtml#Lis9-3).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*主题声明*，<samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>，标识 JWT 所属的主体。对于
    OAuth 客户端认证流程，主题声明必须是 OAuth 客户端的客户端 ID；而对于 OAuth 授权授权，主题应该标识资源所有者，或者以化名标识匿名用户。我们在[清单
    9-3](chapter9.xhtml#Lis9-3)中创建了一个示例主题声明。'
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 9-3: A registered subject claim'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-3：已注册的主题声明
- en: The *audience claim*, <samp class="SANS_TheSansMonoCd_W5Regular_11">aud</samp>,
    identifies the token’s recipient. Its value could be the token endpoint URL on
    the authorization server or anything else that identifies the recipient, such
    as an application ID. See [Listing 9-4](chapter9.xhtml#Lis9-4) for an example.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*受众声明*，<samp class="SANS_TheSansMonoCd_W5Regular_11">aud</samp>，标识令牌的接收者。它的值可以是授权服务器上的令牌端点
    URL，也可以是其他任何标识接收者的内容，例如应用 ID。请参见[清单 9-4](chapter9.xhtml#Lis9-4)中的示例。'
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 9-4: A registered audience claim'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-4：已注册的受众声明
- en: The *expiration claim*, <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>,
    identifies the time window during which the token is valid. After that period,
    the authorization server will reject the token and you’ll need to request a new
    one. An expiration claim’s value is a number whose date is defined in “seconds
    since the Unix Epoch,” a common format for timestamps. It is calculated by counting
    the number of seconds that have elapsed since January 1, 1970\. [Listing 9-5](chapter9.xhtml#Lis9-5)
    shows an example.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*过期声明*，<samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>，标识令牌有效的时间窗口。超过该时间段后，授权服务器将拒绝该令牌，您需要请求一个新的令牌。过期声明的值是一个数字，其日期以“自
    Unix 纪元以来的秒数”定义，这是一个常见的时间戳格式。它通过计算自 1970 年 1 月 1 日以来经过的秒数来确定。[清单 9-5](chapter9.xhtml#Lis9-5)展示了一个示例。'
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 9-5: A registered expiration claim'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-5：已注册的过期声明
- en: The *issued at claim*, <samp class="SANS_TheSansMonoCd_W5Regular_11">iat</samp>,
    is optional and identifies the time at which the authorization server issued the
    token. You can determine a token’s age from this claim, which is also defined
    in seconds since the Unix Epoch, as shown in [Listing 9-6](chapter9.xhtml#Lis9-6).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*颁发时间声明*，<samp class="SANS_TheSansMonoCd_W5Regular_11">iat</samp>，是可选的，用于标识授权服务器颁发令牌的时间。您可以从此声明中确定令牌的年龄，它也是自
    Unix 纪元以来的秒数，如[清单 9-6](chapter9.xhtml#Lis9-6)所示。'
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 9-6: A registered issued at claim'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-6：已注册的颁发时间声明
- en: The *not before claim*, <samp class="SANS_TheSansMonoCd_W5Regular_11">nfb</samp>,
    is optional and identifies the time at which the authorization server should start
    accepting the token. The authorization server will reject every token with an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nfb</samp> claim in the future.
    We define it as a number in seconds since the Unix Epoch, as you can see in [Listing
    9-7](chapter9.xhtml#Lis9-7).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*不早于声明*，<samp class="SANS_TheSansMonoCd_W5Regular_11">nfb</samp>，是可选的，用于标识授权服务器应开始接受令牌的时间。授权服务器将拒绝未来带有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nfb</samp> 声明的每个令牌。我们将其定义为自 Unix
    纪元以来的秒数，正如在[清单 9-7](chapter9.xhtml#Lis9-7)中所示。'
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 9-7: A registered not before claim'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-7：已注册的“不早于”声明
- en: The *JWT claim*, <samp class="SANS_TheSansMonoCd_W5Regular_11">jti</samp>, is
    optional and sets a unique ID for the token (see [Listing 9-8](chapter9.xhtml#Lis9-8)).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*JWT 声明*，<samp class="SANS_TheSansMonoCd_W5Regular_11">jti</samp>，是可选的，为令牌设置一个唯一的
    ID（参见[清单 9-8](chapter9.xhtml#Lis9-8)）。'
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 9-8: A registered JWT claim'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-8：已注册的 JWT 声明
- en: The authorization server might keep a list of recent tokens and their expiration
    dates to check whether the token is being reused in a *replay attack*, which occurs
    when an attacker tries to access data by reusing a previously issued token.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器可能会保留一个最近令牌及其过期日期的列表，以检查令牌是否在 *重放攻击* 中被重复使用，重放攻击发生在攻击者试图通过重新使用先前颁发的令牌访问数据时。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Public Claims</samp>
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">公共声明</samp>
- en: A token’s issuer can define public claims for the purpose of adding an application-specific
    public API. Unlike private claims, these are custom properties defined for public
    access. The issuer should register these claims in the JWT Claims registry or
    use collision-resistant names with custom namespaces—for example, a UUID or the
    application’s name. Also, as public claims are meant for public consumption, they
    should never include private or sensitive information.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌的发布者可以定义公共声明，用于添加特定于应用程序的公共 API。与私有声明不同，这些是为公共访问定义的自定义属性。发布者应将这些声明注册到 JWT
    声明注册表中，或使用具有自定义命名空间的防碰撞名称——例如 UUID 或应用程序的名称。此外，由于公共声明是供公众使用的，它们永远不应包含私密或敏感信息。
- en: A public claim for the OAuth JWT of our fictional weather service might include
    the ZIP code to directly provide each station’s location data. By making the ZIP
    code a public claim, we won’t need to parse the user object and extract the ZIP
    code manually. Also, as the location is publicly available information on social
    media profiles, it’s not sensitive.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们虚构的天气服务的 OAuth JWT 的公共声明可能包括邮政编码，以直接提供每个站点的位置数据。通过将邮政编码作为公共声明，我们无需解析用户对象并手动提取邮政编码。此外，由于位置是社交媒体个人资料上公开的信息，因此它并不敏感。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Private Claims</samp>
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">私有声明</samp>
- en: Private claims are custom claims that are neither registered claims nor public
    claims. We can define them to our liking, and they can be specific to our application
    or use case. Even though they don’t need to be collision resistant, using a private
    namespace is recommended. Unlike public claims, private claims contain information
    specific to the application and are intended to be used only internally. Whereas
    the public claims store generic information such as the name, the private claims
    contain the application’s user ID and role. For example, we could define a private
    claim for the OAuth JWT of our fictional weather service to specify the type of
    service we are using.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 私有声明是自定义声明，它们既不是已注册声明也不是公共声明。我们可以根据需要定义它们，它们可以是特定于我们的应用程序或用例的。尽管它们不需要防止碰撞，但建议使用私有命名空间。与公共声明不同，私有声明包含特定于应用程序的信息，并且仅供内部使用。而公共声明存储的是诸如姓名等通用信息，私有声明则包含应用程序的用户
    ID 和角色。例如，我们可以为虚构天气服务的 OAuth JWT 定义一个私有声明，以指定我们使用的服务类型。
- en: Now that you understand the payload object’s possible properties, you can create
    a complete payload like the one in [Listing 9-9](chapter9.xhtml#Lis9-9), which
    specifies GitHub as the service.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了有效载荷对象可能的属性，你可以创建一个完整的有效载荷，比如在[清单 9-9](chapter9.xhtml#Lis9-9)中展示的那样，它指定了
    GitHub 作为服务。
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 9-9: The JWT payload for the OAuth weather service'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-9：OAuth 天气服务的 JWT 有效载荷
- en: Again, we create a constant and store the object there. Our payload has three
    claims, each of a different type. It’s up to the publisher of the JWT token to
    decide which claims to include; for this example, we limit the size of the token
    to one of each type. The registered claim <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    sets the expiration date and time, <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp>
    is a public claim, and <samp class="SANS_TheSansMonoCd_W5Regular_11">role</samp>
    is a private claim. Both use the custom namespace <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    to minimize the risk of a collision.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们创建一个常量并将对象存储在那里。我们的有效载荷包含三个声明，每个声明的类型不同。由 JWT 令牌的发布者决定包含哪些声明；对于这个例子，我们将令牌的大小限制为每种类型一个声明。已注册的声明<samp
    class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>设置过期日期和时间，<samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp>是一个公共声明，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">role</samp>是一个私有声明。它们都使用自定义命名空间<samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>来减少碰撞的风险。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Signature</samp>
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">签名</samp>
- en: With the header and payload in place, we create a JWT signature by using the
    algorithm specified in the header to calculate the checksum. We pass the header
    and payload as Base64-encoded strings and a custom secret to the checksum function.
    As an exercise, we’ll create the signature in TypeScript with the code from [Listing
    9-10](chapter9.xhtml#Lis9-10). You’ll see that the secret is hardcoded for simplicity
    here. In production code, this secret should be stored in an environment variable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在头部和负载就位后，我们使用头部中指定的算法来计算校验和，从而创建 JWT 签名。我们将头部和负载作为 Base64 编码字符串，并传递自定义密钥给校验和函数。作为练习，我们将使用
    [列表 9-10](chapter9.xhtml#Lis9-10) 中的代码在 TypeScript 中创建签名。你会看到这里的密钥是硬编码的，为了简单起见。生产代码中，这个密钥应存储在环境变量中。
- en: Save the code as *index.ts* in a TypeScript project, or use <samp class="SANS_TheSansMonoCd_W5Regular_11">npx
    ts-node index.ts</samp> to run it locally. If you prefer, you can also use a TypeScript
    sandbox at [*https://<wbr>codesandbox<wbr>.io*](https://codesandbox.io) or [*https://<wbr>stackblitz<wbr>.com*](https://stackblitz.com)
    to run it. Generate a fresh secret (*[https://www.usemodernfullstack.dev/generate-secret](https://www.usemodernfullstack.dev/generate-secret)*)
    and use it instead of the one in the listing to see how the token changes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码保存为*index.ts*，放入 TypeScript 项目中，或者使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">npx
    ts-node index.ts</samp> 在本地运行。如果你愿意，也可以使用 TypeScript 沙盒在[*https://<wbr>codesandbox<wbr>.io*](https://codesandbox.io)
    或 [*https://<wbr>stackblitz<wbr>.com*](https://stackblitz.com) 进行运行。生成一个新的密钥 (*[https://www.usemodernfullstack.dev/generate-secret](https://www.usemodernfullstack.dev/generate-secret)*)
    并使用它替换列表中的密钥，以查看令牌如何变化。
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 9-10: An index.ts file to calculate the JWT signature for the OAuth2
    weather service'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-10：一个用于计算 OAuth2 天气服务 JWT 签名的 index.ts 文件
- en: We use Node.js’s standard crypto module and then create a library for transforming
    the JSON objects into Base64-encoded strings via buffers. We pass the strings
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">secret</samp> to the crypto
    module’s <samp class="SANS_TheSansMonoCd_W5Regular_11">createHmac</samp> function
    to initialize the HMAC object with <samp class="SANS_TheSansMonoCd_W5Regular_11">sha256</samp>
    as the hashing algorithm, Then we feed the Base64-encoded header and payload string,
    separated by a period, to the HMAC object. Finally, we convert the result to a
    hexadecimal format.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Node.js 的标准 crypto 模块，然后创建一个库，通过缓冲区将 JSON 对象转换为 Base64 编码字符串。我们将这些字符串和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">secret</samp> 传递给 crypto 模块的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">createHmac</samp> 函数，以 <samp class="SANS_TheSansMonoCd_W5Regular_11">sha256</samp>
    作为哈希算法来初始化 HMAC 对象。然后，我们将 Base64 编码的头部和负载字符串（用点分隔）传递给 HMAC 对象。最后，我们将结果转换为十六进制格式。
- en: To obtain the JWT string, we create an array containing the Base64-encoded strings
    from the header and payload objects, as well as the Base64-encoded signature.
    To convert the array into a string that uses a period to separate every part,
    we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Array.join</samp> with a
    period as a separator and return the resulting JWT.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取 JWT 字符串，我们创建一个数组，包含来自头部和负载对象的 Base64 编码字符串，以及 Base64 编码的签名。为了将数组转换为一个使用点（.）分隔各部分的字符串，我们调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Array.join</samp>，并使用点作为分隔符，返回结果的
    JWT。
- en: To generate the JWT, we run the script. The final JWT token logged to the console
    should look similar to the one in [Listing 9-11](chapter9.xhtml#Lis9-11).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成 JWT，我们运行脚本。最终在控制台中记录的 JWT 令牌应该与 [列表 9-11](chapter9.xhtml#Lis9-11) 中的类似。
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 9-11: The final JWT token for the OAuth2 weather service'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-11：OAuth2 天气服务的最终 JWT 令牌
- en: In the next section, we’ll use our new knowledge to walk through an actual OAuth
    flow.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将运用新学的知识，走一遍实际的 OAuth 流程。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 9: Access a Protected Resource</samp>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 9：访问受保护资源</samp>
- en: Now that you understand OAuth’s components and the theory behind the authorization
    code flow, let’s work with a practical example. We’ll try to access the protected
    resource hosted by an OAuth server at *[https://www.usemodernfullstack.dev/protected/resource](https://www.usemodernfullstack.dev/protected/resource)*.
    Run the exercise’s cURL commands from your terminal to follow along.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 OAuth 的组件和授权码流的理论，让我们通过一个实际的例子来操作。我们将尝试访问由 OAuth 服务器托管的受保护资源，地址为 *[https://www.usemodernfullstack.dev/protected/resource](https://www.usemodernfullstack.dev/protected/resource)*。从终端运行本练习的
    cURL 命令，跟着操作。
- en: 'First, attempt to access the protected resource without an access token by
    sending a GET request for it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尝试在没有访问令牌的情况下访问受保护的资源，通过发送 GET 请求：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp> flag to output
    the headers, and when we search the response for the HTTP code, we see a *401*
    status code, which tells us that we’re not authorized to access the resource and
    must obtain an access token.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp> 标志输出头部信息，当我们在响应中搜索
    HTTP 代码时，我们看到 *401* 状态码，这告诉我们我们没有权限访问该资源，必须获取访问令牌。
- en: To get an access token, we’ll set up an OAuth client by creating a user account
    and registering it with the provider to receive a client ID and client secret.
    Then we’ll make a request to the */oauth/authorize* endpoint, log in with the
    user’s credentials, and receive the authorization grant on our callback URL. Next,
    we’ll exchange the grant code for an access token on the */oauth/access_token*
    endpoint. Finally, we’ll make the same request again, providing the access token
    in the header.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取访问令牌，我们将通过创建一个用户帐户并将其注册到提供者来设置一个 OAuth 客户端，以接收客户端 ID 和客户端密钥。然后，我们将向 */oauth/authorize*
    端点发起请求，使用用户凭证登录，并在回调 URL 上接收授权凭证。接下来，我们将在 */oauth/access_token* 端点将授权凭证交换为访问令牌。最后，我们将再次发起相同的请求，在头部提供访问令牌。
- en: The callback URL can be any URL here, as we’re not sending any actual data to
    it. But for a real authorization grant flow, it needs to be an endpoint on your
    application. Usually, an OAuth SDK provides these, as it handles the response
    and tokens.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 回调 URL 在这里可以是任何 URL，因为我们不会向其发送任何实际数据。但对于一个真实的授权凭证流程，它需要是你应用中的一个端点。通常，OAuth SDK
    会提供这些，因为它处理响应和令牌。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting Up the Client</samp>
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">设置客户端</samp>
- en: Before we start the OAuth flow, we need to create a user and register an OAuth
    client. Open [*https://<wbr>www<wbr>.usemodernfullstack<wbr>.dev<wbr>/register*](https://www.usemodernfullstack.dev/register)
    in your browser. On the form shown in [Figure 9-2](chapter9.xhtml#fig9-2), create
    a user account with a username and password of your choice.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始 OAuth 流程之前，我们需要创建一个用户并注册一个 OAuth 客户端。在浏览器中打开 [*https://<wbr>www<wbr>.usemodernfullstack<wbr>.dev<wbr>/register*](https://www.usemodernfullstack.dev/register)。在
    [图 9-2](chapter9.xhtml#fig9-2) 中显示的表单上，创建一个用户名和密码自定义的用户帐户。
- en: '![](../images/Figure9-2.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 9-2: Creating a user
    account with the OAuth provider</samp>'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 9-2：与 OAuth 提供者创建用户帐户</samp>
- en: Then proceed to register a client by providing a callback URL ([Figure 9-3](chapter9.xhtml#fig9-3)).
    This callback URL points to the OAuth callback endpoint on our application. Usually,
    the SDK or the OAuth provider supplies you with instructions on how to set this
    up.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后继续注册一个客户端，通过提供回调 URL（[图 9-3](chapter9.xhtml#fig9-3)）。这个回调 URL 指向我们应用中的 OAuth
    回调端点。通常，SDK 或 OAuth 提供者会提供如何设置此 URL 的说明。
- en: '![](../images/Figure9-3.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 9-3: Registering a
    client application with the OAuth server to receive the client credentials</samp>'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 9-3：向 OAuth 服务器注册客户端应用以接收客户端凭证</samp>
- en: The form is prefilled with a callback URL similar to a typical OAuth callback
    structure. Usually, you find them in the SDK’s documentation. Don’t worry that
    the URL *http://localhost:3000/oauth/callback* doesn’t exist on your application.
    For this exercise, we won’t send any actual data to it; instead, we’ll see that
    it’s part of the request and response flow when we go through the API calls. Click
    the button to move on to the next step, where you create the OAuth client. Make
    sure to write down your username, password, client ID, and client secret. You’ll
    need all of these for the next steps. Then click **Register Your OAuth Client**
    to complete the process.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 表单预填充了类似于典型 OAuth 回调结构的回调 URL。通常，你可以在 SDK 的文档中找到这些 URL。不要担心 URL *http://localhost:3000/oauth/callback*
    在你的应用中不存在。对于这次练习，我们不会向其发送任何实际数据；相反，我们将在进行 API 调用时看到它是请求和响应流程的一部分。点击按钮进入下一步，在那里你将创建
    OAuth 客户端。确保记下你的用户名、密码、客户端 ID 和客户端密钥。你将在接下来的步骤中需要这些信息。然后点击 **注册你的 OAuth 客户端**
    来完成这个过程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Logging In to Receive
    the Authorization Grant</samp>
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">登录以接收授权凭证</samp>
- en: Now the user we registered must use their credentials to log in to the OAuth
    provider, allowing the client application to access their resources. We call the
    OAuth REST API endpoint */oauth/authorize* and (as the resource owner) log in
    with our user credentials, which is the first step of the flow. The API response
    returns a redirect to the callback URL, which contains the authorization grant
    in the URL parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">code</samp>.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们注册的用户必须使用他们的凭据登录到 OAuth 提供者，以允许客户端应用程序访问他们的资源。我们调用 OAuth REST API 端点 */oauth/authorize*
    并（作为资源所有者）使用我们的用户凭据登录，这是流程的第一步。API 响应返回一个重定向到回调 URL，该 URL 参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">code</samp>
    中包含授权码。
- en: 'In a real application, the resource owner would click some “Log in with OAuth”
    button and enter their credentials, and the API calls would happen behind the
    scenes. But for the purposes of this exercise, we’ll perform all API requests
    manually. By using the raw API calls, we’ll see the actions that SDKs usually
    abstract. Call the REST endpoint directly with the following cURL command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，资源所有者会点击某个“使用 OAuth 登录”按钮并输入他们的凭据，API 调用会在后台进行。但为了本练习的目的，我们将手动执行所有 API
    请求。通过使用原始 API 调用，我们将看到 SDK 通常会抽象的操作。直接使用以下 cURL 命令调用 REST 端点：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This POST request logs in to the OAuth provider. We set the URL to the *oauth/authenticate*
    endpoint, as well as our <samp class="SANS_TheSansMonoCd_W5Regular_11">Accept</samp>
    header and the appropriate <samp class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</samp>
    header, <samp class="SANS_TheSansMonoCd_W5Regular_11">application/x-www-form-urlencoded</samp>,
    for form data.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此 POST 请求用于登录 OAuth 提供者。我们将 URL 设置为 *oauth/authenticate* 端点，并设置 <samp class="SANS_TheSansMonoCd_W5Regular_11">Accept</samp>
    头以及适当的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</samp> 头，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">application/x-www-form-urlencoded</samp>，用于表单数据。
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-d</samp> flag to send
    the POST data indicating that we’re looking for an authorization code. To split
    the POST data into readable chunks, we need to use double quotes (<samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp>)
    to wrap it and the backslash (<samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp>)
    for line breaks. We add the client ID we received from the OAuth provider and
    the callback URL we discussed earlier. The <samp class="SANS_TheSansMonoCd_W5Regular_11">scope</samp>
    parameter specifies the permissions we’re asking for, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">state</samp>
    parameter contains a unique random string that mitigates cross-site request forgery
    (CSRF) attacks. The OAuth provider should return this <samp class="SANS_TheSansMonoCd_W5Regular_11">state</samp>
    parameter along with the authorization code so that we can verify that its value
    hasn’t changed, proving that the response originated from the correct API and
    not from a third party. In addition, we send the user credentials we registered
    before.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">-d</samp> 标志发送 POST 数据，指示我们正在寻找授权码。为了将
    POST 数据拆分为可读的块，我们需要使用双引号 (<samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp>)
    将其括起来，并使用反斜杠 (<samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp>) 进行换行。我们添加了从
    OAuth 提供者获得的客户端 ID 和之前讨论的回调 URL。<samp class="SANS_TheSansMonoCd_W5Regular_11">scope</samp>
    参数指定我们请求的权限，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">state</samp> 参数包含一个独特的随机字符串，以缓解跨站请求伪造（CSRF）攻击。OAuth
    提供者应该返回此 <samp class="SANS_TheSansMonoCd_W5Regular_11">state</samp> 参数以及授权码，以便我们验证其值未发生变化，证明响应来源于正确的
    API，而不是第三方。此外，我们发送了之前注册的用户凭据。
- en: The response headers show us that everything worked as expected. The OAuth API
    responds with a status code of *302* and redirects to the callback URL we provided.
    As you can see in the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp>
    header, the redirect to the callback URL contains the authorization grant in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">code</samp> parameter, as well as
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">state</samp> parameter we sent.
    Unlike the state, which is just being reflected, the authorization grant is unique
    and depends on the request data.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 响应头告诉我们一切按预期工作。OAuth API 以 *302* 状态码响应并重定向到我们提供的回调 URL。正如你在 <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp>
    头中看到的，重定向到回调 URL 包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">code</samp>
    参数中的授权码，以及我们发送的 <samp class="SANS_TheSansMonoCd_W5Regular_11">state</samp> 参数。与仅被反射的
    state 不同，授权码是唯一的，取决于请求数据。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using the Authorization
    Grant to Get the Access Token</samp>
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用授权授权获取访问令牌</samp>
- en: 'Next, we use the authorization grant to request an access token from the OAuth
    server. Copy the code you received in the preceding step and use it to request
    the bearer access token with the client credentials from the */oauth/access_token*
    API endpoint:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用授权授权从OAuth服务器请求访问令牌。复制前一步收到的代码，并使用它通过客户端凭据请求bearer访问令牌，API端点为*/oauth/access_token*：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This POST request to the OAuth server uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Accept</samp>
    header to accept a JSON response and sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</samp>
    header to a value for POST form data. We send the form data itself with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">data-raw</samp> flag. The data contains
    the authorization grant we received in the <samp class="SANS_TheSansMonoCd_W5Regular_11">code</samp>
    parameter, a <samp class="SANS_TheSansMonoCd_W5Regular_11">grant_type</samp> parameter
    that tells the API endpoint to expect an authorization grant flow, and the same
    redirect URL as before. We also pass in the client ID and secret.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 向OAuth服务器发送的POST请求使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Accept</samp>头部接受JSON响应，并将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</samp>头部设置为POST表单数据的值。我们通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">data-raw</samp>标志发送表单数据。数据包含我们在<samp class="SANS_TheSansMonoCd_W5Regular_11">code</samp>参数中收到的授权授权、一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">grant_type</samp>参数，告诉API端点预期收到授权授权流程，以及与之前相同的重定向URL。我们还传递了客户端ID和密钥。
- en: The response has an HTTP status code of *200*, which means the request succeeded.
    In the response body, we received the access token and additional details. Copy
    the access token’s value for the next step.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 响应的HTTP状态码为*200*，这意味着请求成功。在响应体中，我们收到了访问令牌及其他详细信息。复制访问令牌的值以进行下一步操作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using the Access
    Token to Get the Protected Resource</samp>
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用访问令牌获取受保护的资源</samp>
- en: 'We now have an access token from the OAuth server that we can use to retrieve
    the protected resource we couldn’t access at the beginning of this exercise. Use
    the same cURL command to request *[https://www.usemodernfullstack.dev/protected/resource](https://www.usemodernfullstack.dev/protected/resource)*,
    and replace the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ACCESS_TOKEN</samp>
    placeholder with the access token:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经从OAuth服务器获得了访问令牌，可以用来检索之前无法访问的受保护资源。使用相同的cURL命令请求*[https://www.usemodernfullstack.dev/protected/resource](https://www.usemodernfullstack.dev/protected/resource)*，并将<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ACCESS_TOKEN</samp>占位符替换为访问令牌：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Authorization</samp>
    header with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Bearer</samp> keyword
    and the access token we received from the authorization grant flow in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">access_token</samp> property. When we
    search for the HTTP status code, we see that instead of a code of *401*, we receive
    a code of *200*. On closer inspection, we also see that the response’s body contains
    the secured content.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用包含<samp class="SANS_TheSansMonoCd_W5Regular_11">Authorization</samp>头部、带有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Bearer</samp>关键字以及我们从授权授权流程中收到的访问令牌（位于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">access_token</samp>属性）的HTTP请求。当我们查看HTTP状态码时，发现收到的状态码是*200*，而不是*401*。仔细检查后，我们还发现响应体中包含了安全内容。
- en: We manually walked through all the necessary steps for receiving a working access
    token. This exercise is appropriate for educational purposes only; as mentioned
    earlier in this chapter, we usually use an SDK or a library such as *next-auth*
    to implement an OAuth flow.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们手动完成了接收有效访问令牌所需的所有步骤。此练习仅适用于教育目的；正如本章前面提到的，我们通常使用SDK或库（如*next-auth*）来实现OAuth流程。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: Authentication involves using credentials to authorize access, whereas authorization
    defines and grants access rights. This chapter covered implementing authorization
    with the OAuth2 protocol. You became familiar with the authorization grant flow,
    the most common OAuth flow used in full-stack web applications, and learned how
    to create JWTs. Then you practiced manually working with OAuth, getting and using
    the JWT bearer token, and applying the OAuth flow to your application from a bird’s-eye
    view.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证涉及使用凭证来授权访问，而授权则定义并授予访问权限。本章介绍了如何使用 OAuth2 协议实现授权。你已经熟悉了授权授权流，这是在全栈 web
    应用程序中最常用的 OAuth 流程，并学习了如何创建 JWT。接着，你实践了手动操作 OAuth，获取和使用 JWT 承载令牌，并从鸟瞰图的角度将 OAuth
    流程应用到你的应用程序中。
- en: You can find additional resources, tutorials, and specifications at [*https://<wbr>oauth<wbr>.net*](https://oauth.net).
    The next chapter covers Docker, a containerization platform that decouples your
    development environment from your local machine.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[*https://<wbr>oauth<wbr>.net*](https://oauth.net)找到更多资源、教程和规范。下一章将介绍 Docker，一个容器化平台，它将你的开发环境与本地机器解耦。
