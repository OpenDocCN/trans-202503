- en: Chapter 3. Game Logic
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 游戏逻辑
- en: At this point, we’ve created an intro screen with a New Game button and a single
    bubble that a player can fire off the screen. In this chapter, we’ll turn the
    *Bubble Shooter* into more of a game. You’ll learn how to draw the game board
    and display the level to the player, and then learn about collision detection.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我们已经创建了一个包含新游戏按钮和一个玩家可以发射的泡泡的介绍屏幕。在这一章中，我们将把*泡泡射手*变得更加完整，变成一个真正的游戏。你将学习如何绘制游戏面板并显示关卡信息给玩家，然后了解碰撞检测。
- en: '*Collisions* are central to many games and happen when sprites touch. Once
    you can detect collisions, you can write code that makes the sprites react to
    them. In the *Bubble Shooter*, collisions occur when a fired bubble slams into
    a bubble in the game grid. We’ll implement two reactions: the fired bubble will
    stick to the board if it doesn’t form a color group of three or more bubbles,
    or it will cause a valid group to fall from the board.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*碰撞*是许多游戏的核心，当精灵碰撞时就会发生。 一旦你能够检测到碰撞，就可以编写代码让精灵做出反应。在*泡泡射手*中，碰撞发生在发射的泡泡撞到游戏面板中的另一个泡泡时。我们将实现两种反应：如果发射的泡泡没有形成三个或更多泡泡的颜色组，它将粘附在面板上，或者它将导致一个有效的颜色组从面板上掉落。'
- en: But before we can calculate collisions, we need an object for a bubble to collide
    with. The first section of this chapter discusses drawing the initial board and
    setting up the game state. To do so, we’ll need to follow a process containing
    a number of steps, shown in [Figure 3-1](ch03.html#game_loop_starts_by_drawing_the_board_an
    "Figure 3-1. The game loop starts by drawing the board and ends by showing the
    score.").
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们计算碰撞之前，我们需要一个对象来与泡泡发生碰撞。本章的第一部分讨论了如何绘制初始面板和设置游戏状态。为此，我们需要遵循一个包含多个步骤的过程，如[图3-1](ch03.html#game_loop_starts_by_drawing_the_board_an
    "图3-1。游戏循环从绘制面板开始，最后显示得分。")所示。
- en: '![The game loop starts by drawing the board and ends by showing the score.](httpatomoreillycomsourcenostarchimages2184509.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![游戏循环从绘制面板开始，最后显示得分。](httpatomoreillycomsourcenostarchimages2184509.png)'
- en: Figure 3-1. The game loop starts by drawing the board and ends by showing the
    score.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-1。游戏循环从绘制面板开始，最后显示得分。
- en: We’ll draw the game board first and then add collision detection to the bubble
    that’s been fired. In the next chapter, we’ll implement the mechanism to pop groups
    of bubbles based on matching color.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先绘制游戏面板，然后为发射的泡泡添加碰撞检测。在下一章中，我们将实现根据颜色匹配弹出泡泡组的机制。
- en: Let’s work through the steps and turn them into code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步实现这些步骤并将它们转化为代码。
- en: Drawing the Game Board
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制游戏面板
- en: The game board has a similar structure for every level, and each board contains
    rows of bubbles in four different colors. Alternate rows contain either an odd
    or even number of bubbles depending on whether the row is odd or even. We’ll store
    all this state information in a `Board` object and store the current board as
    a variable in the `Game` object.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每一关的游戏面板结构相似，每个面板包含四种颜色的泡泡行。交替的行包含奇数或偶数个泡泡，具体取决于该行的行号是奇数还是偶数。我们将把这些状态信息存储在一个`Board`对象中，并将当前的面板作为变量存储在`Game`对象中。
- en: 'The object structure you choose should vary depending on the game design, but
    the goals should be the same as when you’re deciding how to structure code in
    web applications: group objects that perform similar operations, and strike a
    balance with how much common functions are abstracted. Don’t define several classes
    that contain very little code, but don’t create too few classes with long code
    listings that will be difficult to read and understand. Game developers often
    base initial structural decisions on instinct and experience as well as on hard-and-fast
    rules. Always be prepared to refactor code if you think your original choices
    are no longer valid.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择的对象结构应根据游戏设计的不同而有所变化，但目标应该与决定如何在Web应用程序中组织代码时相同：将执行相似操作的对象分组，并在抽象公共功能的程度上保持平衡。不要定义几个包含非常少代码的类，但也不要创建太少类，并将它们的代码写得很长，这样会难以阅读和理解。游戏开发者通常根据直觉、经验以及硬性规则来做出初步的结构决策。如果你认为最初的选择不再有效，始终准备重构代码。
- en: The rows that make up the board will be an array of `Bubble` objects. We’ll
    create this array when we instantiate the `Board` object. Later, we’ll transfer
    the drawing of the board elements to the DOM from within *ui.js*. Ending up with
    a large mass of code within a `Game` class is easy to do but undesirable; therefore,
    take the opportunity to hand off responsibilities to other classes whenever possible,
    especially when rendering objects to the screen.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 组成棋盘的行将是一个`Bubble`对象的数组。当我们实例化`Board`对象时，会创建这个数组。稍后，我们将把棋盘元素的绘制从*ui.js*转移到DOM中。将大量代码放入`Game`类中很容易，但这并不是我们想要的；因此，尽可能将职责交给其他类，特别是在将对象渲染到屏幕时。
- en: 'In *game.js*, we need to create a variable to hold the board and a new instance
    of a `Board` object. The board is generated when the New Game button is clicked.
    Add the following new code to *game.js*:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在*game.js*中，我们需要创建一个变量来存储棋盘和一个新的`Board`对象实例。当点击“新游戏”按钮时，棋盘会被生成。将以下新代码添加到*game.js*中：
- en: '*game.js*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`Board` is a new constructor that we need to make. Create a new file called
    *board.js* and add it to the list of files to load in `Modernizr.load` in *index.html*.
    Add the following code to the new file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`Board`是我们需要创建的一个新构造函数。创建一个名为*board.js*的新文件，并将其添加到`Modernizr.load`在*index.html*中的加载文件列表中。将以下代码添加到新文件中：'
- en: '*board.js*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*board.js*'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`NUM_ROWS` ➊ and `NUM_COLS` ➋ are constants that determine the number of rows
    and columns that make up the bubble board grid. The number of columns may seem
    high, since we certainly won’t have 32 bubbles in a row. The reason for such a
    large column value is that we’ll create a grid entry for every half bubble width,
    because odd and even rows are offset on the game board. This design decision results
    in a more visually appealing layout, making it look like bubbles are stacking
    on top of each other. It also creates more interesting angles for the player to
    fire at.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`NUM_ROWS` ➊ 和 `NUM_COLS` ➋ 是常量，决定了气泡棋盘网格的行数和列数。列数可能看起来很大，因为我们肯定不会在一行中放32个气泡。设置这么大的列数的原因是，我们将为每个气泡的半宽度创建一个网格项，因为奇数行和偶数行在棋盘上是错开的。这一设计决策使得布局更具视觉吸引力，看起来像气泡堆叠在一起。它还为玩家提供了更多有趣的角度来射击。'
- en: 'All the bubbles on the first row and every subsequent odd row will have odd
    *y*-coordinates, and those on even rows will have even *y*-coordinates. The rows
    increment in integer steps, but the array we’ll use starts with an index of zero:
    the first row will be at index 0, the second will be at index 1, and so on. Thus,
    the bubble coordinates (*x*,*y*), starting from the top-left corner of the bubble
    board, will be labeled as shown in [Figure 3-2](ch03.html#coordinates_of_the_bubbles_in_the_game_g
    "Figure 3-2. Coordinates of the bubbles in the game grid"). Specifying coordinates
    this way and having a half-populated grid avoids having to work with half values
    and decimal points. In addition, we can store the layout of the board in arrays
    indexed by integers. Working with integers rather than decimals doesn’t change
    the process we’ll follow to calculate collisions, but it does make the code more
    readable.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行和每个随后的奇数行上的所有气泡将具有奇数的*y*坐标，而偶数行上的气泡将具有偶数的*y*坐标。行数以整数步进增加，但我们将使用的数组从零开始索引：第一行在索引0，第二行在索引1，以此类推。因此，气泡坐标(*x*,*y*)，从气泡棋盘的左上角开始，标记如下图[图3-2](ch03.html#coordinates_of_the_bubbles_in_the_game_g
    "图3-2. 游戏网格中气泡的坐标")所示。通过这种方式指定坐标并使用半填充的网格，避免了使用半值和小数点。此外，我们可以将棋盘布局存储在由整数索引的数组中。使用整数而不是小数并不会改变我们计算碰撞时的过程，但它确实使代码更具可读性。
- en: '![Coordinates of the bubbles in the game grid](httpatomoreillycomsourcenostarchimages2184511.png.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![游戏网格中气泡的坐标](httpatomoreillycomsourcenostarchimages2184511.png.jpg)'
- en: Figure 3-2. Coordinates of the bubbles in the game grid
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-2. 游戏网格中气泡的坐标
- en: 'In the code, we’ll now call the `createLayout` function ➌, which returns a
    two-dimensional array of rows and columns. We provide public access to this array
    in the next line ➍. Once we have a `Board` object, we can retrieve the bubble
    at any specific row and column position. For example, to access a bubble at coordinate
    (4,1) we would write:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们现在将调用`createLayout`函数 ➌，它返回一个二维的行列数组。在下一行 ➍ 中，我们提供了对这个数组的公共访问。一旦我们拥有了`Board`对象，就可以检索到任何特定行列位置的气泡。例如，要访问坐标(4,1)处的气泡，我们可以写：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Bubbles are accessed by row and then column number. First, we grab all the rows
    with `board.getRows`, and then we store the first row from the board as `row`.
    Next, we access the fourth bubble within `row` by its column number. Because the
    `row` array is only half populated, all odd entries in even-indexed rows (starting
    at zero) and all even entries in odd rows will be null.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 泡泡是按行然后按列号访问的。首先，我们通过`board.getRows`获取所有行，然后将棋盘中的第一行存储为`row`。接下来，我们通过列号访问`row`中的第四个泡泡。由于`row`数组只有一半被填充，在偶数索引行中的所有奇数位置以及奇数索引行中的所有偶数位置将为null。
- en: The `createLayout` function contains a loop ➎. For each row we want to create,
    `startCol` ➏ calculates whether to start on column 1 or 0 depending on whether
    the row is odd or even, respectively. Then another loop increments to the maximum
    column number, creates a new `Bubble` object ➐, and adds it to the row array,
    which is returned on completion.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`createLayout`函数包含一个循环➎。对于我们想要创建的每一行，`startCol` ➏会根据行是奇数行还是偶数行来决定是否从第1列或第0列开始。然后，另一个循环会递增到最大列数，创建一个新的`Bubble`对象➐，并将其添加到行数组中，完成后返回该数组。'
- en: For this function to work, we need to adapt the `Bubble` class to accept row
    and column input coordinates, and we need to make a change to the `Bubble.create`
    method. Also, if a `Bubble` object knows its position in the grid by storing its
    coordinates, that information will be useful when we need to calculate groups
    to pop. When we know a bubble’s position, we can access that bubble, as it’s stored
    within the `Board` object. Then given a bubble, we can interrogate it to determine
    its position. Each bubble will have a `type` property, which corresponds to its
    color, and the property will be determined at creation time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此函数工作，我们需要调整`Bubble`类以接受行和列的输入坐标，并且我们需要修改`Bubble.create`方法。此外，如果一个`Bubble`对象通过存储其坐标来知道自己在网格中的位置，当我们需要计算需要爆炸的泡泡群时，这些信息将非常有用。当我们知道一个泡泡的位置时，可以访问该泡泡，因为它存储在`Board`对象中。然后，给定一个泡泡，我们可以查询它的位置。每个泡泡都有一个`type`属性，对应于它的颜色，该属性在创建时确定。
- en: When you start coding your own game ideas, the decisions about where to store
    data and how to access it are critical. Your solution will depend on the type
    of game you’re building. In *Bubble Shooter*, we store a relatively small number
    of `Bubbles` within a `Board` object. To find out information about a particular
    bubble, we can access the data that the `Board` stores by retrieving data from
    the `rows` array.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始编码自己的游戏想法时，关于数据存储和访问方式的决策至关重要。你的解决方案将取决于你所构建的游戏类型。在*泡泡射手*中，我们将相对较少的`Bubbles`存储在一个`Board`对象中。要获取某个特定泡泡的信息，我们可以通过从`rows`数组中提取数据来访问`Board`所存储的数据。
- en: Depending on how we need to use that bubble data, this method might not be the
    most elegant solution. For example, imagine we want to find all of the red bubbles
    in the game. Currently, we would have to loop over every space on the board, check
    whether the bubble is red, and then store the outcome. The game grid is small,
    so modern processors can perform this operation quickly. As long as we don’t run
    the color check too many times a second, the current code structure should work.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们如何使用这些泡泡数据，这种方法可能不是最优雅的解决方案。例如，假设我们想要找到游戏中所有的红色泡泡。目前，我们必须遍历棋盘上的每个位置，检查泡泡是否为红色，然后存储结果。由于游戏网格较小，现代处理器能够快速执行这个操作。只要我们不在每秒钟内运行太多次颜色检查，当前的代码结构应该能够正常工作。
- en: 'But now imagine *thousands* of bubbles on the screen. Looping over all the
    bubbles just to find red ones would consume too much processing power. Instead,
    we might want to store bubbles in multiple arrays—one for all the red bubbles,
    one for all the green bubbles, and so on—for instant access to all bubbles of
    each color. However, there would still be a tradeoff: to check whether a given
    space on the board is occupied by a bubble, regardless of color, we would have
    to look at multiple arrays.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在想象一下屏幕上有*成千上万*个泡泡。遍历所有泡泡仅仅为了找到红色的泡泡将消耗太多处理能力。因此，我们可能想要将泡泡存储在多个数组中——一个存储所有红色泡泡，一个存储所有绿色泡泡，依此类推——以便快速访问每种颜色的所有泡泡。然而，这样做仍然存在权衡：为了检查棋盘上的某个位置是否被泡泡占据（不论颜色如何），我们必须查看多个数组。
- en: When you have only a rough sense of how fast a processor can run an operation,
    it’s best to make your code clear and simple. If your game is playable and runs
    sufficiently fast, you won’t need to experiment with different ways to access
    data. Alternatively, if you identify bottlenecks, you’ll then have to refactor
    some sections to increase their speed. Game development is an iterative process;
    you’ll revisit existing lines of code as much as you write new ones.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只是大概知道处理器能够执行操作的速度时，最好使你的代码清晰简洁。如果你的游戏可以正常玩且运行速度足够快，你就不需要尝试不同的方式来访问数据。另一方面，如果你发现瓶颈，你就必须重构一些部分以提高速度。游戏开发是一个迭代过程；你将会像写新代码一样，反复修改已有的代码行。
- en: 'How you design objects and where you store their data will vary from game to
    game. But remember this: if the `Game` object needs to use that data, one way
    or another you must allow the object to access it. Whether data is stored directly
    in a variable or in an array within `Game`, or is accessed through an intermediate
    object that `Game` has access to (such as the `Board` object in *Bubble Shooter*),
    the code will need to access that object’s state if it needs to make decisions
    about that object.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何设计对象以及如何存储它们的数据会因游戏而异。但请记住这一点：如果`Game`对象需要使用这些数据，无论如何，你必须允许该对象访问这些数据。无论数据是直接存储在变量中，还是存储在`Game`中的数组中，或是通过`Game`可以访问的中介对象（如*Bubble
    Shooter*中的`Board`对象）进行访问，代码都需要访问该对象的状态，如果它需要对该对象做出决策的话。
- en: 'To support a bubble storing its position on the board and its color, amend
    *bubble.js* as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持泡泡存储其在棋盘上的位置和颜色，修改*`bubble.js`*如下：
- en: '*bubble.js*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*`bubble.js`*'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Bubble` now takes grid coordinates and a bubble type as well as the sprite
    object ➊, where type corresponds to colors that were specified in *game.css*.
    The Bubble.create method accepts the same parameters ➋; if type isn’t passed ➌,
    one of the four types (colors) is chosen at random ➍.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bubble`现在接受网格坐标和泡泡类型，以及精灵对象 ➊，其中类型对应于*game.css*中指定的颜色。`Bubble.create`方法接受相同的参数
    ➋；如果没有传入类型 ➌，则随机选择四种类型（颜色）之一 ➍。'
- en: Now we have a `Board` object, plenty of bubbles, and their types and positions.
    But all this information is entirely in memory and is stored within the `Board`
    object’s `rows` property. Next, we’ll render the level using this information
    so players can see the game board.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个`Board`对象，许多泡泡，以及它们的类型和位置。但所有这些信息完全存储在内存中，并存储在`Board`对象的`rows`属性中。接下来，我们将使用这些信息渲染关卡，以便玩家能够看到游戏棋盘。
- en: Rendering the Level
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染关卡
- en: Drawing the level is a perfect job for the `ui` class, because `ui` represents
    the game state but doesn’t affect that state.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制关卡是`ui`类的完美任务，因为`ui`表示游戏状态，但不影响该状态。
- en: Separating the code that calculates an object’s position from the code that
    renders that object to the screen is a principle you should apply in all of your
    game ideas. Not only does it separate rendering code from game logic, thereby
    improving readability, but it also allows you to more easily change how objects
    are rendered. For example, if the *Bubble Shooter* board was larger and didn’t
    fit on the screen but we wanted to implement a zoom or pan feature, we could change
    the code that renders the board to either offset the rendering position or to
    scale up or down to draw a different size board. The power of separating rendering
    from game logic will become apparent when we switch from DOM-based sprites to
    drawing onto the HTML `canvas` element in [Chapter 6](ch06.html "Chapter 6. Rendering
    Canvas Sprites").
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将计算对象位置的代码与渲染该对象到屏幕上的代码分开，是你在所有游戏设计中应该遵循的原则。这不仅将渲染代码与游戏逻辑分离，从而提高了可读性，还使你更容易更改对象的渲染方式。例如，如果*Bubble
    Shooter*的棋盘更大且无法完全显示在屏幕上，但我们希望实现缩放或平移功能，我们可以更改渲染棋盘的代码，通过偏移渲染位置或缩放大小来绘制不同大小的棋盘。当我们从基于DOM的精灵切换到绘制到HTML
    `canvas`元素时，[第6章](ch06.html "第6章. 渲染Canvas精灵")中分离渲染与游戏逻辑的强大作用将变得显而易见。
- en: 'Because the creation of a `bubble` object involves creating a DOM sprite element,
    the rendering process needs to place this element in the document and position
    it correctly. These simple steps follow:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建`bubble`对象涉及创建一个DOM精灵元素，因此渲染过程需要将此元素放入文档中并正确定位。以下是这些简单步骤：
- en: Loop over all the rows and columns and pull out each `bubble` object.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历所有行和列，提取每个`bubble`对象。
- en: Write the bubble’s HTML into the DOM.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将泡泡的HTML写入DOM。
- en: Position the bubble in the correct position.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将泡泡放置在正确的位置。
- en: 'The next piece of code you add will apply these steps. Open *ui.js*, add a
    new method (`drawBoard`) after `fireBubble`, and then add a new `ROW_HEIGHT` constant
    at the top:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加的下一段代码将应用这些步骤。打开 *ui.js*，在 `fireBubble` 后添加一个新方法（`drawBoard`），然后在顶部添加一个新的
    `ROW_HEIGHT` 常量：
- en: '*ui.js*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*ui.js*'
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `drawBoard` method retrieves the board rows and columns ➊ and loops over
    them ➋. If there’s a bubble ➌ (recall that every other *x*-coordinate position
    is `null` due to the sparse grid system), `drawBoard` grabs the `sprite` object
    ➍, appends it to the board ➎, and calculates its coordinates before setting its
    position ➏.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawBoard` 方法获取棋盘的行和列 ➊ 并对它们进行循环 ➋。如果有一个泡泡 ➌（回想一下，由于稀疏网格系统，其他 *x* 坐标位置是 `null`），`drawBoard`
    会获取 `sprite` 对象 ➍，将其附加到棋盘上 ➎，并计算其坐标后设置位置 ➏。'
- en: 'To determine a bubble’s position, `drawBoard` first calculates the left coordinate,
    which is the bubble’s column number multiplied by half its width. To calculate
    the top coordinate, we’ll use a value slightly smaller than the `BUBBLE_DIMS`
    height. The odd and even rows are staggered, and we want the bubbles to look like
    they fit together. To create the stacking effect, the vertical separation will
    be slightly less than the horizontal distance. At the top of *ui.js*, `ROW_HEIGHT`
    has been set to 40, which is 4 pixels less than the height. This value was determined
    through trial and error rather than geometrical calculation: adjust the numbers
    until the bubble grid looks pleasing to you.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定泡泡的位置，`drawBoard` 首先计算左侧坐标，即泡泡所在列数乘以它宽度的一半。为了计算顶部坐标，我们会使用一个比 `BUBBLE_DIMS`
    高度稍小的值。奇数行和偶数行是错开的，我们希望泡泡看起来像是紧密排列在一起的。为了创建堆叠效果，垂直间距会稍微小于水平间距。在 *ui.js* 的顶部，`ROW_HEIGHT`
    已经设置为 40，比高度少了 4 像素。这个值是通过反复试验确定的，而不是通过几何计算得出的：调整这些数字，直到泡泡网格看起来合适为止。
- en: Reload and click **New Game**; you should see a nicely rendered board. You can
    even fire a bubble at the rest of the board; unfortunately, it should just go
    straight through without hitting anything and continue off the screen as before.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载并点击 **新游戏**；你应该能看到一个渲染良好的棋盘。你甚至可以向棋盘的其他地方发射泡泡；不幸的是，泡泡应该直接穿过而不碰到任何东西，并像之前一样继续飞出屏幕。
- en: Because we have only one bubble, we need to refresh to retry the process. Before
    we begin working on collision detection, we’ll make sure we can keep firing one
    bubble after another.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们只有一个泡泡，我们需要刷新才能重新尝试这个过程。在开始处理碰撞检测之前，我们将确保可以连续发射一个泡泡接一个泡泡。
- en: The Bubble Queue
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泡泡队列
- en: Although the player will have only a finite number of bubbles to fire, the game
    needs to provide those bubbles in a constant stream. Therefore, we’ll need to
    add a function that creates a new bubble, adds it to the DOM, and queues up the
    next bubble as soon as the user fires the first one.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管玩家只有有限数量的泡泡可以发射，但游戏需要提供持续不断的泡泡流。因此，我们需要添加一个函数，创建一个新的泡泡，将其添加到 DOM 中，并在玩家发射第一个泡泡后立即排队准备下一个泡泡。
- en: 'In *game.js*, add the following variables and functions and change the initialization
    for `curBubble` to call a new `getNextBubble` function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *game.js* 中，添加以下变量和函数，并更改 `curBubble` 的初始化，调用一个新的 `getNextBubble` 函数：
- en: '*game.js*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The new code first creates a variable ➊ to store the number of bubbles the player
    has fired. Because the number of fired bubbles is an integer—a basic data type—we’ll
    store it as a variable in `Game`. If, for example, we had a time limit that a
    level had to be completed within, we might create an object to store time remaining
    along with bubbles remaining rather than continuing to create variables in `Game`.
    As it is, the variable suits our purpose.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码首先创建了一个变量 ➊ 来存储玩家已发射的泡泡数量。因为发射的泡泡数量是一个整数——一种基本数据类型——所以我们将它作为变量存储在 `Game`
    中。例如，如果我们有一个时间限制，需要在某个时间内完成关卡，我们可能会创建一个对象来存储剩余时间和剩余泡泡，而不是继续在 `Game` 中创建多个变量。就目前来说，这个变量已经能满足我们的需求。
- en: The code also sets a constant for the maximum number of bubbles ➋ the player
    can fire. When a level is started, it sets the number of bubbles remaining to
    the value of `MAX_BUBBLES` ➌ and calls a new function in *ui.js* to display the
    number of remaining bubbles on the screen ➍. Finally, the code calls `getNextBubble`
    ➎ each time a bubble is fired to prepare a new one.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 代码还设置了一个常量，表示玩家可以发射的最大泡泡数量 ➋。当关卡开始时，代码将剩余泡泡数设置为 `MAX_BUBBLES` 的值 ➌，并调用 *ui.js*
    中的新函数以显示屏幕上剩余泡泡的数量 ➍。最后，每次发射泡泡时，代码都会调用 `getNextBubble` ➎ 准备下一个泡泡。
- en: 'We also want to show the player the number of remaining bubbles available to
    fire within a level, so create the `drawBubblesRemaining` method in *ui.js*, appending
    this new function to the `ui` object:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望显示玩家在关卡中剩余可发射的气泡数量，因此在*ui.js*中创建`drawBubblesRemaining`方法，将这个新函数添加到`ui`对象中：
- en: '*ui.js*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*ui.js*'
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Additionally, we need to display the number of remaining bubbles, so add a
    new element in *index.html*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要显示剩余气泡的数量，所以在*index.html*中添加一个新元素：
- en: '*index.html*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*index.html*'
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add some styling for the `bubbles_remaining` div into *main.css*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为`bubbles_remaining` div添加一些样式到*main.css*：
- en: '*main.css*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*main.css*'
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now refresh the game. You should be able to fire bubbles into the distance,
    get a new one as soon as the first is fired (until you’ve used 70 bubbles, or
    whatever value you used for `MAX_BUBBLES`), and be able to fire that new bubble
    immediately.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在刷新游戏。你应该能够把气泡射到远处，每当第一个气泡发射后，立刻得到一个新气泡（直到你使用了70个气泡，或者你为`MAX_BUBBLES`设置的其他值），并能立即发射那个新气泡。
- en: Often, you can break down a game into a repeating *turn loop*. The loop is usually
    initiated by a player action and then closed when that action has been resolved.
    In *Bubble Shooter*, the loop commences when the player clicks the screen to fire
    the button and completes when the next bubble is ready to fire. At this point
    we have the basic turn loop, but to create the game, we need to flesh out the
    middle part of the loop to calculate where to stop a bubble and whether to pop
    bubbles.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以将游戏分解为一个重复的*回合循环*。这个循环通常由玩家操作启动，然后在操作解决后结束。在*Bubble Shooter*中，循环在玩家点击屏幕发射按钮时开始，当下一个气泡准备好发射时结束。此时我们有了基本的回合循环，但为了创建游戏，我们需要完善循环的中间部分，计算气泡停止的位置以及是否需要爆炸气泡。
- en: Detecting Collisions
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: Although you can now fire bubbles, they pass straight through the board without
    affecting the bubble grid. The game design calls for them to collide with the
    board and either become part of the board or cause groups of bubbles that are
    the same color to pop. The next task is to work out where collisions occur.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管现在你可以发射气泡，但它们会直接穿过板面，不会影响气泡网格。游戏设计要求它们与板面碰撞，并要么成为板面的一部分，要么导致相同颜色的气泡组爆炸。接下来的任务是计算碰撞发生的地方。
- en: 'We can calculate collisions in two ways:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式计算碰撞：
- en: Move a sprite forward a few pixels for each frame and then try to detect any
    overlaps with other sprites. If there’s an overlap, we know we’ve hit another
    bubble.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每帧将一个精灵向前移动几个像素，然后尝试检测是否与其他精灵重叠。如果发生重叠，我们就知道已经碰到另一个气泡。
- en: Use geometry to calculate where the sprite might collide with another bubble
    before it even starts moving.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用几何学来计算精灵在开始移动之前可能与其他气泡发生碰撞的地方。
- en: In fast-paced arcade games, you might choose the first option, as long as there’s
    no chance objects will pass through each other without a collision being detected.
    These pass-throughs can happen when objects move at high speeds, and collision
    checks occur after an object has moved numerous pixels since the previous check.
    For example, in a game in which you fire a bullet at a one-foot-thick wall, the
    bullet would only be guaranteed to collide with the wall if you check for collisions
    every foot. If you checked for collisions every two feet instead, you might check
    for a collision just before the bullet should hit and find no wall. Then two feet
    further along when you check again, the bullet would be past the wall, again resulting
    in no collision.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在快节奏的街机游戏中，只要没有发生物体穿透而未检测到碰撞的可能性，你可能会选择第一种方案。这些穿透可能发生在物体以高速移动时，而碰撞检查发生在物体自上次检查以来已经移动了多个像素之后。例如，在一个射击子弹的游戏中，如果你向一堵一英尺厚的墙开火，只有每英尺检查一次碰撞，才能确保子弹与墙碰撞。如果你每两英尺检查一次碰撞，可能会在子弹应该击中之前检查碰撞，结果发现没有墙壁。然后在再检查两英尺时，子弹已经穿过墙壁，从而导致没有碰撞。
- en: 'To work around the fast-moving-object problem, we could make sure the steps
    are always small enough that pass-throughs never happen; however, that requires
    more calculations, which may not be possible without significant computing power.
    This problem is more likely to surface in a browser environment: because we never
    know the specs of the end user’s computer, we can’t take processing power for
    granted.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过快速移动物体的问题，我们可以确保每一步的距离足够小，以避免物体穿透；然而，这需要更多的计算，可能在没有强大计算能力的情况下无法实现。这个问题在浏览器环境中更容易出现：因为我们无法预知最终用户计算机的规格，所以不能假设处理能力。
- en: 'The second option, using geometry, is more accurate if it’s feasible. Fortunately,
    our game design has fairly simplistic geometric properties. Unfortunately, this
    option isn’t possible in games in which sprites have more complex shapes. In that
    case, you’d have to check whether pixels overlap on a frame-by-frame basis and
    test thoroughly to ensure you don’t see any side effects. For *Bubble Shooter*,
    we’ll use a geometrical approach because we have the following advantages:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用几何方法，如果可行的话，它更为准确。幸运的是，我们的游戏设计具有相对简单的几何特性。不幸的是，在精灵具有更复杂形状的游戏中，这种方法不可行。在这种情况下，您必须逐帧检查像素是否重叠，并进行彻底测试以确保不会出现任何副作用。对于*Bubble
    Shooter*（气泡射手），我们将采用几何方法，因为我们具备以下优势：
- en: The game is on a regular grid.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏使用规则网格。
- en: All the objects (the bubbles) are identical.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有物体（气泡）都是相同的。
- en: We’re working in only two dimensions.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只在二维空间中进行工作。
- en: The player moves only one object.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家只移动一个物体。
- en: All the objects are simple geometric shapes (circles), so the calculation of
    where edges meet is easy.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的物体都是简单的几何形状（圆形），因此计算边缘相交的位置非常简单。
- en: These conditions make geometric calculations for collisions relatively straightforward.
    Because game development often involves a lot of geometry, having a good grounding
    in trigonometry and vectors is essential. The next section discusses the geometry
    involved in this game. Then we’ll turn that geometry into code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些条件使得碰撞的几何计算相对简单。由于游戏开发通常涉及大量的几何学，因此掌握三角学和向量是至关重要的。下一部分将讨论游戏中的几何形状，然后我们将把这些几何形状转化为代码。
- en: Collision Geometry
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞几何
- en: When you need to calculate collisions, draw the geometry on a piece of paper
    before you write the detection code. You’ll then be able to visualize the values
    you’ll need to calculate, as shown in [Figure 3-3](ch03.html#visualizing_the_geometry_behind_a_bubble
    "Figure 3-3. Visualizing the geometry behind a bubble collision").
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要计算碰撞时，先在纸上画出几何图形，然后再编写检测代码。这样，您将能够可视化您需要计算的值，如[图 3-3](ch03.html#visualizing_the_geometry_behind_a_bubble
    "图 3-3。可视化气泡碰撞背后的几何形状")所示。
- en: '![Visualizing the geometry behind a bubble collision](httpatomoreillycomsourcenostarchimages2184513.png.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![可视化气泡碰撞背后的几何形状](httpatomoreillycomsourcenostarchimages2184513.png.jpg)'
- en: Figure 3-3. Visualizing the geometry behind a bubble collision
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-3。可视化气泡碰撞背后的几何形状
- en: The bubble being fired should cause a collision when its center passes within
    2*R* (where *R* is a bubble’s radius) of another bubble’s center, meaning that
    the two circumferences are touching. Because the intersection point will always
    be normal (at 90 degrees) to the colliding bubble’s edge and the edge of the bubble
    being hit, we need to check for a collision only if the path of the moving bubble’s
    center comes within 2*R* of another bubble’s center.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当发射气泡的中心距离另一个气泡的中心小于 2*R*（其中 *R* 是气泡的半径）时，应该发生碰撞，这意味着两个气泡的圆周接触。由于交点总是与碰撞气泡的边缘以及被撞气泡的边缘成
    90 度垂直，因此我们只需要检查当移动气泡的中心路径距离另一个气泡的中心小于 2*R* 时，是否发生碰撞。
- en: To determine where collisions occur, we need to check every other bubble on
    the board to determine whether the fired bubble’s path passes through it. If it
    overlaps with multiple bubbles, as it does in [Figure 3-4](ch03.html#fired_bubble_may_be_on_a_path_to_collide
    "Figure 3-4. The fired bubble may be on a path to collide with multiple other
    bubbles."), we need to make sure that the struck bubble we pick is the first collision
    that occurs, which will be the one in which the firing bubble has traveled the
    least distance.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定碰撞发生的位置，我们需要检查棋盘上的每个其他气泡，判断发射的气泡的路径是否经过它。如果它与多个气泡重叠，就像在[图 3-4](ch03.html#fired_bubble_may_be_on_a_path_to_collide
    "图 3-4。发射的气泡可能会与多个其他气泡发生碰撞。")中所示，我们需要确保我们选中的撞击气泡是第一个发生碰撞的气泡，也就是发射气泡行进距离最短的那个。
- en: '![The fired bubble may be on a path to collide with multiple other bubbles.](httpatomoreillycomsourcenostarchimages2184515.png.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![发射的气泡可能会与多个其他气泡发生碰撞。](httpatomoreillycomsourcenostarchimages2184515.png.jpg)'
- en: Figure 3-4. The fired bubble may be on a path to collide with multiple other
    bubbles.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-4。发射的气泡可能会与多个其他气泡发生碰撞。
- en: Detecting a collision is equivalent to detecting when a vector drawn from the
    center line of the bubble we’re firing intersects with a circle with a radius
    double that of our bubbles. This will be known as a bubble’s *hitbox*. [Figure 3-5](ch03.html#if_the_fired_bubbleapostrophes_travel_pa
    "Figure 3-5. If the fired bubble’s travel path intersects a stationary bubble’s
    circular hitbox, a collision occurs.") shows how we can redraw this concept to
    help us think about it in a way that’s easier to compute.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 检测碰撞等同于检测从我们发射的气泡的中心线绘制的向量与一个半径为我们气泡两倍的圆相交的时刻。这将被称为气泡的 *碰撞框*。[图 3-5](ch03.html#if_the_fired_bubbleapostrophes_travel_pa
    "图 3-5. 如果发射的气泡的运动路径与一个静止气泡的圆形碰撞框相交，就会发生碰撞。") 展示了我们如何重新绘制这个概念，帮助我们以一种更容易计算的方式理解它。
- en: '![If the fired bubble’s travel path intersects a stationary bubble’s circular
    hitbox, a collision occurs.](httpatomoreillycomsourcenostarchimages2184517.png.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![如果发射的气泡的运动路径与一个静止气泡的圆形碰撞框相交，就会发生碰撞。](httpatomoreillycomsourcenostarchimages2184517.png.jpg)'
- en: Figure 3-5. If the fired bubble’s travel path intersects a stationary bubble’s
    circular hitbox, a collision occurs.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-5. 如果发射的气泡的运动路径与一个静止气泡的圆形碰撞框相交，就会发生碰撞。
- en: In this diagram, the small filled circle marks the center of the bubble being
    fired. The bubble it will collide with is the inner circle, and the intersection
    with the bubble’s hitbox (the point marked with the arrow 2*R*, which is double
    a bubble’s radius) is where the bubble will stop.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图示中，填充的小圆圈标记了发射气泡的中心。它将碰撞的气泡是内圈，而气泡的碰撞框（标记为箭头指示的2*R*点，即气泡半径的两倍）是气泡停止的地方。
- en: Turning the diagram into a mathematical formula means using vectors. Rather
    than working through the math before showing any code, let’s go straight into
    the necessary JavaScript, which includes explanatory annotations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将图示转化为数学公式意味着使用向量。我们不需要在展示任何代码之前先进行数学推导，而是直接进入必要的 JavaScript 代码，并附上说明性注释。
- en: Simplifying Hitboxes
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 简化碰撞检测框
- en: Because we are working with circles, creating a hitbox is simpler than it might
    be if you were dealing with, for example, a figure that runs and jumps, as in
    a platform game. In that case, you might not want to detect collisions just by
    checking whether pixels overlap because of possible performance issues; instead,
    you could simplify the geometry of the main character and create a rectangular
    hitbox to check against. Not all games lend themselves to this approach. However,
    if you can reduce complex character outlines to simple geometrical shapes, you
    can detect collisions with much greater precision and less processing power than
    by checking whether pixels have overlapped. Always look for creative, efficient
    solutions to avoid brute-force techniques that monopolize resources.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处理的是圆形，创建一个碰撞检测框比处理例如像平台游戏中的人物那样的角色要简单。在那种情况下，你可能不希望仅仅通过检查像素是否重叠来检测碰撞，因为可能会出现性能问题；相反，你可以简化主角的几何形状，创建一个矩形的碰撞检测框来进行检测。并非所有游戏都适合这种方法。然而，如果你能够将复杂的角色轮廓简化为简单的几何形状，你就能够比通过检查像素重叠来检测碰撞更加精确且消耗更少的计算资源。总是要寻找创造性和高效的解决方案，避免占用资源的暴力计算方法。
- en: 'The calculation is a large block of code with a specific function, so we’ll
    put it in its own file. Create a file called *collision-detector.js* and add it
    to the `Modernizr.load` call in *index.html*. Type in the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算是一个包含特定功能的大块代码，因此我们将其放入一个单独的文件中。创建一个名为 *collision-detector.js* 的文件，并将其添加到
    *index.html* 中的 `Modernizr.load` 调用中。输入以下内容：
- en: '*collision-detector.js*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*collision-detector.js*'
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In a moment I’ll break down the code in *collision-detector.js*. But first,
    notice the call to a new method in *bubble.js* called `getCoords` ➊, which returns
    the center (*x*,*y*) coordinate of a bubble based on its position in the row/column
    hierarchy. You’ll need to amend the bubble class to add the new method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我将拆解 *collision-detector.js* 中的代码。但首先，注意到在 *bubble.js* 中调用了一个名为 `getCoords`
    ➊ 的新方法，它根据气泡在行/列层次结构中的位置返回气泡的中心坐标（*x*, *y*）。你需要修改气泡类以添加这个新方法：
- en: '*bubble.js*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*bubble.js*'
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The game coordinates of a bubble are simple to calculate: you start by finding
    each top-left corner coordinate. The *x*-coordinate (left) is the column number
    ➊ multiplied by half the bubble sprite’s width ➋. The *y*-coordinate (top) is
    the row number ➌ multiplied by the row height ➍, which is slightly less than the
    bubble’s full height. To find the center of a bubble, just add half the bubble’s
    dimensions ➎ to both *x* and *y*.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 气泡的游戏坐标非常简单计算：首先找到每个左上角的坐标。*x*坐标（左侧）是列号➊乘以气泡精灵宽度的一半➋。*y*坐标（顶部）是行号➌乘以行高➍，它稍微小于气泡的完整高度。要找到气泡的中心，只需将气泡的宽度和高度的一半➎分别加到*x*和*y*上。
- en: When you’re developing game logic, the center coordinates of an object are more
    often the focus, whereas for rendering purposes, you’ll usually specify the top-left
    corner along with a width and a height. Building a handy method into the object
    that converts from one to the other will save you from writing out the math each
    time you need to switch.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发游戏逻辑时，通常更关注一个物体的中心坐标，而在渲染过程中，通常会指定左上角坐标以及宽度和高度。为物体构建一个从一种坐标系统转换为另一种坐标系统的便捷方法，可以避免每次切换时都需要手动编写数学公式。
- en: Collision Detection Logic
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞检测逻辑
- en: Now let’s walk through the entire `findIntersection` routine in *CollisionDetector.js*
    block by block. If you don’t want to dig into the math right now, you can skip
    this breakdown—it’s purely the math of detecting collisions and doesn’t contain
    any new HTML5 or game development concepts. However, know that in almost every
    game you write, you’ll break down the complexities of how objects interact into
    a model that you can manipulate with relatively simple mathematics.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们逐步解析`findIntersection`函数在*CollisionDetector.js*中的实现。如果你现在不想深入数学细节，可以跳过这部分内容——它仅仅是关于检测碰撞的数学原理，并没有涉及新的HTML5或游戏开发概念。然而，请知道，在几乎所有你编写的游戏中，你都会将物体之间的交互复杂性分解为可以用相对简单的数学运算来操作的模型。
- en: Starting Position and Direction Vector
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 起始位置和方向向量
- en: 'The first part added to *collision-detector.js* is the standard library intro:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到*collision-detector.js*的第一部分是标准库的引入：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We’ve created an object called `CollisionDetector`. Now let’s look at the first
    method on that object:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`CollisionDetector`的对象。现在让我们来看一下该对象中的第一个方法：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When you call `CollisionDetector`, you’ll use `BubbleShoot.CollisionDetector.findIntersection`.
    It accepts the parameters `curBubble` (an instance of the `Bubble` class), the
    `board` variable (an instance of `Board`), and the angle at which the bubble is
    being fired, giving the function everything it needs to know about the starting
    situation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`CollisionDetector`时，你将使用`BubbleShoot.CollisionDetector.findIntersection`。它接受`curBubble`（`Bubble`类的实例）、`board`变量（`Board`类的实例）以及气泡发射的角度作为参数，提供给函数关于初始情况的所有必要信息。
- en: 'Now, examine the first variables within `findIntersection`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查`findIntersection`中的第一个变量：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We’ll loop over each row to check for collisions, so let’s grab the board rows
    into a local variable. Assuming there’s no collision by default, this will be
    the state returned by the function if no intersections occur. As a result, if
    the fired bubble doesn’t hit another bubble, it will keep moving forward.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将循环遍历每一行以检查碰撞，因此我们将把棋盘的行数存储到一个局部变量中。假设默认情况下没有碰撞发生，那么如果没有发生交集，函数将返回这个状态。结果是，如果发射的气泡没有击中其他气泡，它将继续向前移动。
- en: 'The starting value of `collision` is `null` instead of `false` because if an
    intersection occurs, it will hold the bubble that’s been collided with, plus some
    other information, rather than a Boolean that indicates whether or not a collision
    has occurred. We need to know that a collision has occurred (which would be a
    “true” or “false” result), but more important, we need to send back information
    about what was collided with and where the collision occurred:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`collision`的初始值是`null`而不是`false`，因为如果发生了交集，它将保存被碰撞的气泡及其相关信息，而不是一个表示是否发生碰撞的布尔值。我们需要知道碰撞是否发生（这将是一个“真”或“假”的结果），但更重要的是，我们需要返回有关发生碰撞的物体及碰撞发生位置的信息：'
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next pair of variables retrieves the bubble’s starting position (on the
    screen) as an object with top and left properties:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下一对变量检索气泡的起始位置（在屏幕上的位置），并以一个具有`top`和`left`属性的对象形式表示：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, `dx` and `dy` define how much a bubble moves left or right (`dx`)
    or up (`dy`) relative to the total distance the bubble will move. With those variables
    defined, we can loop through the rows and columns of the game board:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`dx` 和 `dy` 定义了气泡相对于其将移动的总距离，分别向左或向右（`dx`）或向上（`dy`）移动的距离。有了这些变量定义后，我们可以遍历游戏板的行和列：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We’ll start at the top left of the game board and work our way down and to the
    right. Because we only fire bubbles upward, we know that a bubble will never collide
    with another from the top of the game board. We also know that if multiple collision
    candidates are present along the bubble’s path, we want to grab the one where
    the bubble has traveled the least distance—that is, the collision that happened
    first. Remember that because columns are sparsely populated (every other entry
    is null), we also need to make sure we’re actually looking at a bubble before
    we try to do anything with it—hence the `if(bubble)` check.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从游戏板的左上角开始，逐步向下和向右移动。因为我们只会向上发射气泡，所以我们知道气泡永远不会与来自游戏板顶部的其他气泡发生碰撞。我们还知道，如果在气泡路径上有多个碰撞候选气泡，我们希望选取气泡移动距离最小的那个——也就是最先发生的碰撞。记住，因为列是稀疏分布的（每隔一项是空的），我们还需要确保在尝试对气泡进行操作之前，我们实际正在查看一个气泡——因此需要进行`if(bubble)`检查。
- en: Calculating Collisions
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算碰撞
- en: 'Next we need to use some geometry to check whether the fired bubble’s hitbox
    collided with another bubble. We’ll determine where the vector defined by (*dx*,*dy*),
    which begins at the center of the fired bubble, intersects with the circle drawn
    in [Figure 3-4](ch03.html#fired_bubble_may_be_on_a_path_to_collide "Figure 3-4. The
    fired bubble may be on a path to collide with multiple other bubbles."). Let’s
    start with the equation of a circle:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用一些几何学来检查发射的气泡的碰撞框是否与另一个气泡相撞。我们将确定由(*dx*,*dy*)定义的向量（该向量从发射气泡的中心开始）与[图3-4](ch03.html#fired_bubble_may_be_on_a_path_to_collide
    "图3-4. 发射的气泡可能与多个其他气泡发生碰撞。")中绘制的圆相交的位置。我们从圆的方程式开始：
- en: (*x* – *c*[x])² + (*y* – *c*[y])² = *r*²
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: (*x* – *c*[x])² + (*y* – *c*[y])² = *r*²
- en: Here, *x* and *y* are the points on the circle’s circumference, *c*[x] and *c*[y]
    are the center points of the circle, and *r* is the radius of the circle. We’ll
    need those points to find the distance to the starting bubble.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*x*和*y*是圆周上的点，*c*[x]和*c*[y]是圆心点，*r*是圆的半径。我们将需要这些点来找到与起始气泡的距离。
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This part of the loop contains a bubble to check a collision against, so let’s
    get *c*[x] and *c*[y], the center coordinates of the bubble (`coords` in the preceding
    code), and calculate the distance between this point and the fired bubble’s coordinates.
    We don’t yet know whether or not a collision will occur.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的循环包含了一个气泡，用来检查是否发生碰撞，因此我们获取*c*[x]和*c*[y]，即气泡的中心坐标（在前面的代码中是`coords`），并计算这个点与发射气泡坐标之间的距离。我们还不知道是否会发生碰撞。
- en: 'The bubble being fired follows a set of coordinates defined by the equations:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 发射的气泡遵循一组由以下方程式定义的坐标：
- en: '| *p*[x] = | *e*[x] + *td*[x] |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| *p*[x] = | *e*[x] + *td*[x] |'
- en: '| *p*[y] = | *e*[y] + *td*[y] |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| *p*[y] = | *e*[y] + *td*[y] |'
- en: 'where *p*[x] and *p*[y] are points on the trajectory of the bubble’s center
    point. The calculation of *p*[x] and *p*[y] happens in jQuery’s `animate` method
    and is the standard equation for moving a point along a line. Next, we’ll calculate
    *t* at the closest point on this line to the center of the bubble that we’re checking
    against:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *p*[x] 和 *p*[y] 是气泡中心点的轨迹上的点。*p*[x] 和 *p*[y] 的计算发生在 jQuery 的 `animate` 方法中，这是沿直线移动点的标准方程式。接下来，我们将计算*
    t *在与我们检查的气泡中心最近的线上点：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This line tells us at what proportion of the fired bubble’s total movement
    it will be closest to the candidate bubble’s center. From this, we can calculate
    the screen coordinates where this happens:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行告诉我们，在发射气泡的总运动中，哪一个比例它最接近候选气泡的中心。由此，我们可以计算出发生这种情况时的屏幕坐标：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With these coordinates, we can find the distance of *e* (the closest point
    on the fired bubble’s center line to the center of the candidate bubble):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些坐标，我们可以找到*e*（发射气泡中心线到候选气泡中心的最近点）的距离：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If the distance `distEC` is less than double the candidate bubble’s radius,
    a collision occurs. If not, the fired bubble will not collide with this candidate
    bubble.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果距离`distEC`小于候选气泡半径的两倍，则发生碰撞。如果不是，发射的气泡将不会与这个候选气泡发生碰撞。
- en: Trial and Error vs. Calculation
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 试错法与计算法
- en: Note that although `BubbleShoot.ui.BUBBLE_DIMS` gives the width and height of
    the sprite, we’re checking `distEC` against a bubble image that is actually slightly
    smaller. Multiplying the `BUBBLE_DIMS` value by 0 .75 (obtained from a bit of
    trial and error) gives a diameter for a bubble that works in the game.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然`BubbleShoot.ui.BUBBLE_DIMS`给出了精灵的宽度和高度，但我们正在检查的`distEC`是与一个实际上稍小的气泡图像进行比较的。将`BUBBLE_DIMS`值乘以0.75（通过一些反复试验得出的）得到一个适用于游戏的气泡直径。
- en: We can arrive at a more precise value for `distEC` by measuring the width of
    the bubble, which is 44 pixels in the images in this book. Dividing by the `BUBBLE_DIMS`
    of 50 pixels, the result is a multiplier of 0 .88\. Although this larger value
    might be more exact, it requires the player to be more accurate when trying to
    fire bubbles through gaps. Therefore, 0 .75 just feels better to the player, because
    it gives them more chances to make shots that they would find very difficult if
    the math were precise.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过测量气泡的宽度来得到一个更精确的`distEC`值，书中的图像中气泡宽度为44像素。将其除以50像素的`BUBBLE_DIMS`，结果是一个0.88的倍数。虽然这个较大的值可能更精确，但它要求玩家在尝试通过间隙发射气泡时更精确。因此，0.75这个值对玩家来说感觉更好，因为它给予了玩家更多的机会来完成那些如果精确计算的话非常困难的投篮。
- en: Often in game development, you’ll make decisions based on trial and error as
    much as by calculation. In this case, by using a slightly smaller value, you give
    the player the opportunity to fire bubbles through small gaps in the game board.
    Players won’t notice the lax enforcement of the laws of physics, and they’ll enjoy
    the game more.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，通常你会根据反复试验和计算做出决定。在这种情况下，通过使用一个稍小的值，你给了玩家在游戏板上通过小间隙发射气泡的机会。玩家不会注意到物理法则的松懈执行，他们会更享受游戏。
- en: 'If `distEC` is less than three-quarters of the bubble sprite width, we know
    that the fired bubble’s travel path intersects the candidate bubble’s hitbox at
    some point:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`distEC`小于气泡精灵宽度的四分之三，我们知道发射的气泡路径在某个点与候选气泡的碰撞框相交：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Most likely, a second intersection point will occur where the line exits the
    bubble’s hitbox (see [Figure 3-5](ch03.html#if_the_fired_bubbleapostrophes_travel_pa
    "Figure 3-5. If the fired bubble’s travel path intersects a stationary bubble’s
    circular hitbox, a collision occurs."), which shows the center line of the fired
    bubble passing through the hitbox at two points), but we only want the first.
    Two calculations will ensure that we have the correct intersection. Let’s look
    at the first calculation:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，第二个交点会出现在线条退出气泡碰撞框的地方（见[图3-5](ch03.html#if_the_fired_bubbleapostrophes_travel_pa
    "图3-5。如果发射气泡的路径与静止气泡的圆形碰撞框相交，会发生碰撞。")，其中显示了发射气泡的中心线在两个点穿过碰撞框），但我们只关心第一个交点。通过两个计算，我们可以确保得到正确的交点。让我们看看第一个计算：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we find the distance between the center of the struck bubble and the
    closest point on the fired bubble’s path. The second calculation follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们计算了被撞气泡的中心与发射气泡路径上最近点之间的距离。第二个计算如下：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The points on the line that cross the stationary bubble’s center are calculated
    here as offsets from the fired bubble’s path at point `t`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过计算穿过静止气泡中心的线上的点，这些点作为从发射气泡路径上`t`点的偏移量被计算出来。
- en: Finding the Correct Collision Point
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 找到正确的碰撞点
- en: 'Now we want to choose which intersection we’ll encounter first—that is, which
    point is closest to where we’re firing `curBubble` from—so we need the distances
    to each potential collision point:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想选择首先遇到的交点——也就是说，选择距离我们发射`curBubble`的地方最近的点——所以我们需要计算到每个潜在碰撞点的距离：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we’ll choose the correct collision point and calculate where `curBubble`
    needs to stop by adding the starting coordinates back into the system:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将选择正确的碰撞点，并通过将起始坐标重新添加到系统中来计算`curBubble`需要停止的位置。
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Most of the time, if the center of the bubble being fired collides with the
    edge of another bubble, it’ll cross twice: once on the way in and once on the
    way out. In the rare cases where it just brushes past and only a single collision
    point occurs, we’ll get two identical results, so it doesn’t matter which one
    we choose.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，如果被发射的气泡的中心与另一个气泡的边缘发生碰撞，它会有两个交点：一次是进入时，另一次是退出时。在少数情况下，它只是擦过并且只会有一个碰撞点发生，我们会得到两个相同的结果，因此选择哪一个并不重要。
- en: At this point, the function will loop over every bubble in the display and check
    for collisions; however, we don’t want to know about *every* collision—just the
    *nearest* one that occurs earliest in `curBubble`’s movement path.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，函数将遍历显示中的每个气泡并检查碰撞；然而，我们不需要知道 *每个* 碰撞——只需要知道 *最接近的* 碰撞，并且该碰撞应该发生在 `curBubble`
    的运动路径中最早的时刻。
- en: 'To store the current best-match collision, we use the `collision` variable,
    which was set to `null` before the loop started. Then, each time we find a collision,
    we check to see if the new collision is closer than the previous best. If no previous
    collision happened, the first one we find will be the best. The `collision` object
    stores a reference to the stationary bubble that the fired bubble collides with,
    the distance to the collision, and the coordinates where it happened:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储当前最佳匹配的碰撞，我们使用 `collision` 变量，该变量在循环开始前被设置为 `null`。然后，每次我们发现一个碰撞时，我们都会检查新碰撞是否比之前的最佳碰撞更接近。如果没有发生过先前的碰撞，那么我们找到的第一个碰撞将是最佳的。`collision`
    对象存储了被碰撞的静止气泡的引用、碰撞的距离以及发生碰撞的坐标：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now the `findIntersection` function will return an object with all the data
    we need if a collision is found or `null` if no collision occurs. All of these
    calculations happen before the bubble has even started moving.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果发现碰撞，`findIntersection` 函数将返回一个包含所有我们需要的数据的对象；如果没有碰撞发生，则返回 `null`。所有这些计算都在气泡开始移动之前完成。
- en: Reacting to Collisions
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应碰撞
- en: We now need to use the collision coordinates we have in an amended version of
    `clickGameScreen` in *game.js* so we can fire and stop bubbles. We’ve written
    the first step in detecting a collision by resolving what the bubble has collided
    with (which may be *nothing*!). Now, `Game` needs to decide how to react to that
    information.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在 *game.js* 中的 `clickGameScreen` 修改版中使用我们获得的碰撞坐标，以便我们可以发射和停止气泡。我们已经编写了检测碰撞的第一步，通过解析气泡碰撞的对象（可能是
    *没有碰撞*！）。现在，`Game` 需要根据这些信息来决定如何反应。
- en: 'First, we check for a collision. If one occurs, we move the bubble to wherever
    the collision occurred. If one doesn’t occur, we fire the bubble off the screen.
    Change the existing `clickGameScreen` function in *game.js* to the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查是否发生了碰撞。如果发生了碰撞，我们将气泡移动到碰撞发生的位置。如果没有碰撞发生，我们将气泡发射到屏幕外。将现有的 `clickGameScreen`
    函数修改为以下内容：
- en: '*game.js*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If the distance the bubble moves has changed due to a collision, the time it
    needs to get there should also change, so all bubbles fire at the same velocity.
    We’ll use the collision data to recalculate that duration ➊.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果气泡移动的距离由于碰撞发生了变化，那么到达目标所需的时间也应该发生变化，这样所有气泡才能以相同的速度发射。我们将使用碰撞数据重新计算该持续时间 ➊。
- en: 'Reload the game and fire a bubble. The bubble should stop when it hits the
    main group. But it still doesn’t look quite right. The bubble stops, but it doesn’t
    integrate itself into the board. It just sticks wherever it hits. Also, if you
    fire more bubbles, they just pile on top of each other; new bubbles won’t collide
    with previously fired bubbles. The problem is that the board state doesn’t change
    to synchronize with the display state, so we’ll correct this using two steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载游戏并发射一个气泡。气泡应该在碰到主组时停止。但它仍然看起来不太对。气泡停止了，但并没有整合到棋盘上。它只是停在了碰撞的位置。此外，如果你发射更多气泡，它们会堆叠在一起；新气泡不会与之前发射的气泡发生碰撞。问题在于棋盘状态没有与显示状态同步变化，因此我们将通过两个步骤来纠正这一问题：
- en: Add the fired bubble to the board state in the correct row and column.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将发射的气泡添加到棋盘状态中的正确行和列。
- en: When the fired bubble stops, lock it into a tidy grid position.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发射的气泡停止时，将其锁定到一个整齐的网格位置。
- en: The second step will use information from the first.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步将使用第一步中的信息。
- en: Adding the bubble Object to the Board
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将气泡对象添加到棋盘
- en: The `bubble` object, `curBubble`, is in the DOM and should end up close to the
    correct position on the screen, so we can add it to the board’s row/column array
    when we know where it should fit.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`bubble` 对象 `curBubble` 在 DOM 中，应该最终接近正确的位置，所以我们可以在知道它应该放置的位置时将其添加到棋盘的行/列数组中。'
- en: To calculate the row number, we divide the *y*-coordinate by the height of rows
    and round down the result. Calculating the column number is similar, except we
    need to snap to either odd column numbers on even rows (including zero) or even
    column numbers on odd rows. Finally, we can add the bubble to the `rows` property
    of the `Board` object, because `Board` is where we’re storing positional information
    for all of the bubbles.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算行号，我们将*y*坐标除以行的高度并向下取整。计算列号类似，只不过我们需要将列号调整为偶数行的奇数列号（包括零）或奇数行的偶数列号。最后，我们可以将气泡添加到`Board`对象的`rows`属性中，因为`Board`是我们存储所有气泡位置数据的地方。
- en: 'The function to add the fired bubble is trivial, so we’ll put that in *board.js*.
    Within the definition of the board class and after the `getRows` method, add the
    following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 发射气泡的函数非常简单，所以我们会把它放到*board.js*中。在board类的定义中，`getRows`方法之后，添加如下内容：
- en: '*board.js*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*board.js*'
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note that as well as adding the bubble into the correct row-column position
    in `rows[][]` ➊, we’re also passing the calculated row ➋ and column ➌ numbers
    to the `bubble` object so it knows its location relative to the other bubbles.
    We don’t have those method calls yet, so let’s create them now in *bubble.js*
    in the `Bubble` class definition:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在将气泡添加到`rows[][]`的正确行列位置时 ➊，我们还将计算得到的行 ➋ 和列 ➌ 数字传递给`bubble`对象，以便它了解自己相对于其他气泡的位置。我们还没有这些方法调用，所以现在让我们在*bubble.js*中为`Bubble`类定义它们：
- en: '*bubble.js*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*bubble.js*'
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, amend *game.js* to call this new method in `clickGameScreen`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改*game.js*，在`clickGameScreen`中调用这个新方法：
- en: '*game.js*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Reload the game and shoot a few bubbles. They should start to pile up, although
    some may still overlap because they don’t quite settle properly into the grid.
    It’s progress, but we want the bubbles to line up nicely when they collide—that’s
    what we’ll do next.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载游戏并发射一些气泡。它们应该开始堆积，尽管有些气泡可能仍然会重叠，因为它们没有完全正确地放入网格中。这是进步，但我们希望气泡在碰撞时能够排列整齐——这就是我们接下来要做的。
- en: Locking the bubble Object into the Grid
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将气泡对象锁定到网格中
- en: When the fired bubbles collide with the rest of the board, we want to lock them
    in place rather than just having them stop wherever they hit. The current movement
    works well, but we need to add another step that locks the bubble into position
    when it reaches its destination.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当发射的气泡与棋盘上的其他气泡发生碰撞时，我们希望将它们锁定在原地，而不是让它们停在任何它们碰到的地方。当前的运动效果很好，但我们需要再添加一步，当气泡到达目的地时，将它锁定在位置上。
- en: After `board.addBubble` has been run, the `bubble` object knows which row and
    column it’s located in; therefore, calling its `getCoords` method (which calculates
    based on row and column) will retrieve the coordinates where it should be rather
    than the coordinates where it actually stopped. To nudge it into place, we’ll
    add a `complete` function that can be set as part of a jQuery `animate` call and
    use the information the bubble already has. As a result, we can fire the bubble
    and forget about it rather than creating a process to tidy up bubbles as they
    land. jQuery’s `complete` callback function is a useful place to put code that
    needs to run when an animation has finished. For example, in a game with an explosion
    effect, the frames of the animation could run, and when the animation finishes,
    the DOM elements that formed the explosion could be removed from the screen.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在`board.addBubble`执行后，`bubble`对象知道它位于哪个行列位置；因此，调用它的`getCoords`方法（根据行列计算）将获取它应该位于的位置坐标，而不是它实际停止的位置坐标。为了将它调整到正确的位置，我们将添加一个`complete`函数，它可以作为jQuery
    `animate`调用的一部分设置，并使用气泡已经拥有的信息。这样，我们就可以发射气泡并不再担心它，而不是创建一个过程来整理气泡的落地情况。jQuery的`complete`回调函数是一个非常有用的地方，用于放置动画结束时需要运行的代码。例如，在一个带有爆炸效果的游戏中，动画的帧可以运行，动画结束时，构成爆炸的DOM元素可以从屏幕上移除。
- en: 'The `complete` property is called when the animation has ended. In *ui.js*
    amend `fireBubble` as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画结束时，会调用`complete`属性。在*ui.js*中，修改`fireBubble`如下：
- en: '*ui.js*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*ui.js*'
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When you reload, the bubbles you fire should settle into the grid system. Note
    that we use `getRow` to check whether a collision has occurred ➊, because `getRow`
    should return `null` for a bubble that misses all other bubbles and moves off
    the screen.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载后，您发射的气泡应该会落入网格系统。请注意，我们使用`getRow`来检查是否发生了碰撞 ➊，因为`getRow`应该为错过所有其他气泡并离开屏幕的气泡返回`null`。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Now that fired bubbles collide with the others on the board, *Bubble Shooter*
    is starting to act more like a game. We’ve moved sprites across the screen using
    jQuery, made the game react to the player’s input, and set up some of the basic
    game logic. However, currently there’s no way to pop bubbles, and it won’t be
    much of a game without that functionality. Popping logic and displaying an animation
    are the subjects of the next chapter.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，已发射的气泡与板上的其他气泡发生碰撞，*泡泡射手* 开始更像一个游戏了。我们已经使用 jQuery 移动了精灵，令游戏响应玩家的输入，并设置了一些基本的游戏逻辑。然而，目前还没有办法爆破气泡，如果没有这个功能，游戏就不完整了。爆破逻辑和显示动画将是下一章的内容。
- en: Further Practice
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步练习
- en: Each row of the game board is offset to form a staggered pattern. Change the
    code in `createLayout` so the bubbles form a regular grid. How will this change
    the game?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏板的每一行都有偏移，形成一个错落的图案。修改 `createLayout` 中的代码，使气泡形成规则的网格。这会如何改变游戏？
- en: Now that you can make `createLayout` build a different grid pattern, write code
    to generate an entirely new layout. For example, you could draw only every alternate
    column or build a more creative layout.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以让 `createLayout` 构建不同的网格图案，编写代码生成一个全新的布局。例如，你可以仅绘制每隔一列的气泡，或者构建一个更具创意的布局。
- en: '*Bubble Shooter* has a simple object structure that consists of a `Game`, a
    `Board`, and a set of `Bubbles`. What sort of objects would you need if you were
    building a game like *Angry Birds*, *Bejeweled*, or *Candy Crush*?'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*泡泡射手* 具有一个简单的对象结构，包含 `Game`、`Board` 和一组 `Bubbles`。如果你正在构建像 *愤怒的小鸟*、*宝石迷阵*
    或 *糖果传奇* 这样的游戏，你会需要哪些对象？'
