- en: Chapter 42. Advanced Features of Shared Libraries
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第42章：共享库的高级特性
- en: 'The previous chapter covered the fundamentals of shared libraries. This chapter
    describes a number of advanced features of shared libraries, including the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章讲解了共享库的基础知识。本章描述了共享库的若干高级特性，包括以下内容：
- en: dynamically loading shared libraries;
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态加载共享库；
- en: controlling the visibility of symbols defined by a shared library;
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制共享库中定义的符号的可见性；
- en: using linker scripts to create versioned symbols;
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用链接器脚本创建版本化符号；
- en: using initialization and finalization functions to automatically execute code
    when a library is loaded and unloaded;
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用初始化和终结函数在库加载和卸载时自动执行代码；
- en: shared library preloading; and
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享库预加载；以及
- en: using `LD_DEBUG` to monitor the operation of the dynamic linker.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`LD_DEBUG`来监视动态链接器的操作。
- en: Dynamically Loaded Libraries
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态加载的共享库
- en: When an executable starts, the dynamic linker loads all of the shared libraries
    in the program’s dynamic dependency list. Sometimes, however, it can be useful
    to load libraries at a later time. For example, a plug-in is loaded only when
    it is needed. This functionality is provided by an API to the dynamic linker.
    This API, usually referred to as the *dlopen* API, originated on Solaris, and
    much of it is now specified in SUSv3.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当可执行文件启动时，动态链接器会加载程序的所有共享库依赖列表。然而，有时可以在稍后的时间加载库。例如，插件只有在需要时才会加载。这种功能由动态链接器的API提供。这个API通常称为*dlopen*
    API，最初出现在Solaris中，现在许多部分都在SUSv3中进行了规范。
- en: The *dlopen* API enables a program to open a shared library at run time, search
    for a function by name in that library, and then call the function. A shared library
    loaded at run time in this way is commonly referred to as a *dynamically loaded
    library*, and is created in the same way as any other shared library.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*dlopen* API使得程序能够在运行时打开共享库，在该库中按名称查找函数，然后调用该函数。以这种方式在运行时加载的共享库通常被称为*动态加载的库*，并且与其他共享库一样创建。'
- en: 'The core *dlopen* API consists of the following functions (all of which are
    specified in SUSv3):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 核心的*dlopen* API包含以下函数（所有函数都在SUSv3中进行了规范）：
- en: The *dlopen()* function opens a shared library, returning a handle used by subsequent
    calls.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*dlopen()*函数打开一个共享库，返回一个句柄，用于后续调用。'
- en: The *dlsym()* function searches a library for a symbol (a string containing
    the name of a function or variable) and returns its address.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*dlsym()*函数在库中查找一个符号（包含函数或变量名称的字符串），并返回其地址。'
- en: The *dlclose()* function closes a library previously opened by *dlopen()*.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*dlclose()*函数关闭通过*dlopen()*打开的库。'
- en: The *dlerror()* function returns an error-message string, and is used after
    a failure return from one of the preceding functions.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*dlerror()*函数返回一个错误消息字符串，并在前面函数返回失败时使用。'
- en: The *glibc* implementation also includes a number of related functions, some
    of which we describe below.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*glibc*的实现还包括若干相关函数，下面我们将描述其中一些。'
- en: To build programs that use the *dlopen* API on Linux, we must specify the *-ldl*
    option, in order to link against the *libdl* library.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上构建使用*dlopen* API的程序时，我们必须指定* -ldl*选项，以便链接*libdl*库。
- en: 'Opening a Shared Library: *dlopen()*'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打开共享库：*dlopen()*
- en: The *dlopen()* function loads the shared library named in *libfilename* into
    the calling process’s virtual address space and increments the count of open references
    to the library.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*dlopen()*函数将名为*libfilename*的共享库加载到调用进程的虚拟地址空间，并增加对该库的打开引用计数。'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns library handle on success, or `NULL` on error
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回库句柄，出错时返回`NULL`
- en: If *libfilename* contains a slash (`/`), *dlopen()* interprets it as an absolute
    or relative pathname. Otherwise, the dynamic linker searches for the shared library
    using the rules described in [Finding Shared Libraries at Run Time](ch41.html#finding_shared_libraries_at_run_time
    "Finding Shared Libraries at Run Time").
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*libfilename*包含斜杠（`/`），*dlopen()*将其解释为绝对路径或相对路径。否则，动态链接器将使用[运行时查找共享库](ch41.html#finding_shared_libraries_at_run_time
    "Finding Shared Libraries at Run Time")中描述的规则来查找共享库。
- en: On success, *dlopen()* returns a handle that can be used to refer to the library
    in subsequent calls to functions in the *dlopen* API. If an error occurred (e.g.,
    the library couldn’t be found), *dlopen()* returns `NULL`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功时，*dlopen()*返回一个句柄，后续可以使用该句柄调用*dlopen* API中的函数。如果发生错误（例如，无法找到库），*dlopen()*返回`NULL`。
- en: If the shared library specified by *libfilename* contains dependencies on other
    shared libraries, *dlopen()* also automatically loads those libraries. This procedure
    occurs recursively if necessary. We refer to the set of such loaded libraries
    as this library’s *dependency tree*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*libfilename*指定的共享库依赖于其他共享库，*dlopen()*也会自动加载这些库。如果需要，加载过程会递归进行。我们将这些加载的库称为该库的*依赖树*。
- en: It is possible to call *dlopen()* multiple times on the same library file. The
    library is loaded into memory only once (by the initial call), and all calls return
    the same *handle* value. However, the *dlopen* API maintains a reference count
    for each library handle. This count is incremented by each call to *dlopen()*
    and decremented by each call to *dlclose()*; only when the count reaches 0 does
    *dlclose()* unload the library from memory.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可以多次调用*dlopen()*加载同一个库文件。该库只会被加载到内存一次（通过初始调用），所有调用都会返回相同的*handle*值。然而，*dlopen*
    API会为每个库句柄维护一个引用计数。每次调用*dlopen()*时，计数会递增，每次调用*dlclose()*时，计数会递减；只有当计数为0时，*dlclose()*才会将库从内存中卸载。
- en: 'The *flags* argument is a bit mask that must include exactly one of the constants
    `RTLD_LAZY` or `RTLD_NOW`, with the following meanings:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*flags*参数是一个位掩码，必须包括`RTLD_LAZY`或`RTLD_NOW`中的一个常量，且具有以下含义：'
- en: '`RTLD_LAZY`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTLD_LAZY`'
- en: Undefined function symbols in the library should be resolved only as the code
    is executed. If a piece of code requiring a particular symbol is not executed,
    that symbol is never resolved. Lazy resolution is performed only for function
    references; references to variables are always resolved immediately. Specifying
    the `RTLD_LAZY` flag provides behavior that corresponds to the normal operation
    of the dynamic linker when loading the shared libraries identified in an executable’s
    dynamic dependency list.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 库中的未定义函数符号应仅在代码执行时解析。如果一段代码未执行某个符号的需求，该符号就不会被解析。懒加载只会对函数引用进行解析；对变量的引用始终会立即解析。指定`RTLD_LAZY`标志提供的行为与动态链接器在加载可执行文件的动态依赖列表中标识的共享库时的正常操作相对应。
- en: '`RTLD_NOW`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTLD_NOW`'
- en: All undefined symbols in the library should be immediately resolved before *dlopen()*
    completes, regardless of whether they will ever be required. As a consequence,
    opening the library is slower, but any potential undefined function symbol errors
    are detected immediately instead of at some later time. This can be useful when
    debugging an application, or simply to ensure that an application fails immediately
    on an unresolved symbol, rather than doing so only after executing for a long
    time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 库中的所有未定义符号应该在*dlopen()*完成之前立即解析，无论它们是否会被需要。因此，打开库的速度较慢，但任何潜在的未定义函数符号错误会立即被检测到，而不是在某个后续的时间点。这对于调试应用程序时很有用，或者简单地确保应用程序在遇到未解析的符号时会立即失败，而不是在长时间运行后才发生错误。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By setting the environment variable `LD_BIND_NOW` to a nonempty string, we can
    force the dynamic linker to immediately resolve all symbols (i.e., like `RTLD_NOW`)
    when loading the shared libraries identified in an executable’s dynamic dependency
    list. This environment variable is effective in *glibc* 2.1.1 and later. Setting
    `LD_BIND_NOW` overrides the effect of the *dlopen()* `RTLD_LAZY` flag.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将环境变量`LD_BIND_NOW`设置为非空字符串，我们可以强制动态链接器在加载可执行文件的动态依赖列表中标识的共享库时立即解析所有符号（即，像`RTLD_NOW`一样）。此环境变量在*glibc*
    2.1.1及以后版本中有效。设置`LD_BIND_NOW`会覆盖*dlopen()*中`RTLD_LAZY`标志的效果。
- en: 'It is also possible to include further values in *flags*. The following flags
    are specified in SUSv3:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在*flags*中包含更多的值。以下是SUSv3中指定的标志：
- en: '`RTLD_GLOBAL`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTLD_GLOBAL`'
- en: Symbols in this library and its dependency tree are made available for resolving
    references in other libraries loaded by this process and also for lookups via
    *dlsym()*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 该库及其依赖树中的符号可以用于解析由该进程加载的其他库中的引用，并且也可以通过*dlsym()*进行查找。
- en: '`RTLD_LOCAL`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTLD_LOCAL`'
- en: This is the converse of `RTLD_GLOBAL` and the default if neither constant is
    specified. It specifies that symbols in this library and its dependency tree are
    not available to resolve references in subsequently loaded libraries.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`RTLD_GLOBAL`的相反，且如果没有指定任何常量时为默认值。它指定该库及其依赖树中的符号不可用于解析随后的加载库中的引用。
- en: SUSv3 doesn’t specify a default if neither `RTLD_GLOBAL` nor `RTLD_LOCAL` is
    specified. Most UNIX implementations assume the same default (`RTLD_LOCAL`) as
    Linux, but a few assume a default of `RTLD_GLOBAL`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定`RTLD_GLOBAL`或`RTLD_LOCAL`，SUSv3并未规定默认值。大多数UNIX实现假设与Linux相同的默认值（`RTLD_LOCAL`），但也有少数实现假设默认值为`RTLD_GLOBAL`。
- en: 'Linux also supports a number of flags that are not specified in SUSv3:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Linux还支持一些在SUSv3中未指定的标志：
- en: '`RTLD_NODELETE` (since *glibc* 2.2)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTLD_NODELETE`（自*glibc* 2.2起）'
- en: Don’t unload the library during a *dlclose()*, even if the reference count falls
    to 0\. This means that the library’s static variables are not reinitialized if
    the library is later reloaded by *dlopen()*. (We can achieve a similar effect
    for libraries loaded automatically by the dynamic linker by specifying the *gcc
    -Wl,-znodelete* option when creating the library.)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在*dlclose()*时不要卸载库，即使引用计数降为0。这意味着如果库稍后通过*dlopen()*重新加载，库的静态变量不会被重新初始化。（对于由动态链接器自动加载的库，我们可以通过在创建库时指定*gcc
    -Wl,-znodelete*选项来实现类似效果。）
- en: '`RTLD_NOLOAD` (since *glibc* 2.2)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTLD_NOLOAD`（自*glibc* 2.2起）'
- en: Don’t load the library. This serves two purposes. First, we can use this flag
    to check if a particular library is currently loaded as part of the process’s
    address space. If it is, *dlopen()* returns the library’s handle; if it is not,
    *dlopen()* returns `NULL`. Second, we can use this flag to “promote” the *flags*
    of an already loaded library. For example, we can specify `RTLD_NOLOAD | RTLD_GLOBAL`
    in *flags* when using *dlopen()* on a library previously opened with `RTLD_LOCAL`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不加载库。这样做有两个目的。首先，我们可以使用这个标志检查某个特定库是否已作为进程地址空间的一部分被加载。如果加载了，*dlopen()* 会返回该库的句柄；如果没有，*dlopen()*
    会返回`NULL`。其次，我们可以使用这个标志来“提升”已加载库的*flags*。例如，当对一个之前使用`RTLD_LOCAL`打开的库调用*dlopen()*时，我们可以在*flags*中指定`RTLD_NOLOAD
    | RTLD_GLOBAL`。
- en: '`RTLD_DEEPBIND` (since *glibc* 2.3.4)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTLD_DEEPBIND`（自*glibc* 2.3.4起）'
- en: When resolving symbol references made by this library, search for definitions
    in the library before searching for definitions in libraries that have already
    been loaded. This allows a library to be self-contained, using its own symbol
    definitions in preference to global symbols with the same name defined in other
    shared libraries that have already been loaded. (This is similar to the effect
    of the *-Bsymbolic* linker option described in [Run-Time Symbol Resolution](ch41.html#run-time_symbol_resolution
    "Run-Time Symbol Resolution").)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析此库做出的符号引用时，首先在库中查找定义，再去查找已经加载的其他库中的定义。这允许库自包含，优先使用其自己的符号定义，而不是其他已加载共享库中具有相同名称的全局符号定义。（这类似于[运行时符号解析](ch41.html#run-time_symbol_resolution
    "Run-Time Symbol Resolution")中描述的*-Bsymbolic*链接选项的效果。）
- en: The `RTLD_NODELETE` and `RTLD_NOLOAD` flags are also implemented in the Solaris
    *dlopen* API, but are available on few other UNIX implementations. The `RTLD_DEEPBIND`
    flag is Linux-specific.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTLD_NODELETE`和`RTLD_NOLOAD`标志也在Solaris的*dlopen* API中实现，但在其他一些UNIX实现中很少可用。`RTLD_DEEPBIND`标志是Linux特有的。'
- en: As a special case, we can specify *libfilename* as `NULL`. This causes *dlopen()*
    to return a handle for the main program. (SUSv3 refers to this as a handle for
    the “global symbol object.”) Specifying this handle in a subsequent call to *dlsym()*
    causes the requested symbol to be sought in the main program, followed by all
    shared libraries loaded at program startup, and then all libraries dynamically
    loaded with the `RTLD_GLOBAL` flag.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 作为特例，我们可以将*libfilename*指定为`NULL`。这会导致*dlopen()*返回主程序的句柄。（SUSv3将其称为“全局符号对象”的句柄。）在随后的*dlopen()*调用中指定此句柄会使请求的符号首先在主程序中查找，然后在程序启动时加载的所有共享库中查找，最后在使用`RTLD_GLOBAL`标志动态加载的所有库中查找。
- en: 'Diagnosing Errors: *dlerror()*'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误诊断：*dlerror()*
- en: If we receive an error return from *dlopen()* or one of the other functions
    in the *dlopen* API, we can use *dlerror()* to obtain a pointer to a string that
    indicates the cause of the error.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从*dlopen()*或*dlopen* API中的其他函数接收到错误返回值，我们可以使用*dlerror()*获取指向字符串的指针，以指示错误的原因。
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to error-diagnostic string, or `NULL` if no error has occurred
    since previous call to *dlerror()*
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向错误诊断字符串的指针，或者如果自上次调用*dlerror()*以来没有发生错误，则返回`NULL`。
- en: The *dlerror()* function returns `NULL` if no error has occurred since the last
    call to *dlerror()*. We’ll see how this is useful in the next section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自上次调用*dlerror()*以来没有发生错误，*dlerror()*函数会返回`NULL`。我们将在下一节看到这如何有用。
- en: 'Obtaining the Address of a Symbol: *dlsym()*'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取符号的地址：*dlsym()*
- en: The *dlsym()* function searches for the named *symbol* (a function or variable)
    in the library referred to by *handle* and in the libraries in that library’s
    dependency tree.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*dlsym()* 函数在由 *handle* 引用的库以及该库的依赖树中的库中查找命名的 *symbol*（一个函数或变量）。'
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns address of *symbol*, or `NULL` if *symbol* is not found
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 *symbol* 的地址，如果 *symbol* 没有找到，则返回 `NULL`。
- en: If *symbol* is found, *dlsym()* returns its address; otherwise, *dlsym()* returns
    `NULL`. The *handle* argument is normally a library handle returned by a previous
    call to *dlopen()*. Alternatively, it may be one of the so-called pseudohandles
    described below.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到了 *symbol*，*dlsym()* 返回其地址；否则，*dlsym()* 返回 `NULL`。*handle* 参数通常是通过之前调用 *dlopen()*
    返回的库句柄。或者，它可能是下面描述的所谓伪句柄之一。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A related function, *dlvsym(handle, symbol, version)*, is similar to *dlsym()*,
    but can be used to search a symbol-versioned library for a symbol definition whose
    version matches the string specified in *version*. (We describe symbol versioning
    in [Symbol Versioning](ch42.html#symbol_versioning "Symbol Versioning").) The
    `_GNU_SOURCE` feature test macro must be defined in order to obtain the declaration
    of this function from `<dlfcn.h>`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的函数 *dlvsym(handle, symbol, version)* 与 *dlsym()* 类似，但它可以用于在符号版本库中查找符号定义，并确保其版本与
    *version* 中指定的字符串匹配。（我们在[符号版本控制](ch42.html#symbol_versioning "Symbol Versioning")中描述了符号版本控制。）必须定义
    `_GNU_SOURCE` 特性测试宏，才能从 `<dlfcn.h>` 获取该函数的声明。
- en: The value of a symbol returned by *dlsym()* may be `NULL`, which is indistinguishable
    from the “symbol not found” return. In order to differentiate the two possibilities,
    we must call *dlerror()* beforehand (to make sure that any previously held error
    string is cleared) and then if, after the call to *dlsym()*, *dlerror()* returns
    a non-`NULL` value, we know that an error occurred.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*dlsym()* 返回的符号值可能是 `NULL`，这与“符号未找到”的返回值无法区分。为了区分这两种情况，我们必须事先调用 *dlerror()*（以确保清除任何之前的错误字符串），然后，如果在调用
    *dlsym()* 后，*dlerror()* 返回一个非 `NULL` 的值，就说明发生了错误。'
- en: 'If *symbol* is the name of a variable, then we can assign the return value
    of *dlsym()* to an appropriate pointer type, and obtain the value of the variable
    by dereferencing the pointer:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *symbol* 是一个变量的名称，那么我们可以将 *dlsym()* 的返回值赋给一个适当的指针类型，并通过解引用该指针来获取变量的值：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If *symbol* is the name of a function, then the pointer returned by *dlsym()*
    can be used to call the function. We can store the value returned by *dlsym()*
    in a pointer of the appropriate type, such as the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *symbol* 是一个函数的名称，那么 *dlsym()* 返回的指针可以用来调用该函数。我们可以将 *dlsym()* 返回的值存储在适当类型的指针中，例如如下：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, we can’t simply assign the result of *dlsym()* to such a pointer,
    as in the following example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能直接将 *dlsym()* 的结果赋值给这样的指针，如下所示的示例：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The reason is that the C99 standard forbids assignment between a function pointer
    and *void **. The solution is to use the following (somewhat clumsy) cast:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是 C99 标准禁止在函数指针和 *void ** 之间进行赋值。解决方法是使用以下（稍显笨拙的）强制转换：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Having used *dlsym()* to obtain a pointer to the function, we can then call
    the function using the usual C syntax for dereferencing function pointers:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *dlsym()* 获取函数指针后，我们可以使用标准的 C 语法来解引用该函数指针，调用该函数：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Instead of the **(void **)* syntax shown above, one might consider using the
    following seemingly equivalent code when assigning the return value of *dlsym()*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 替代上面所示的 **(void **)* 语法，当赋值 *dlsym()* 的返回值时，可以考虑使用以下看似等效的代码：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: However, for this code, *gcc -pedantic* warns that “ANSI C forbids the use of
    cast expressions as lvalues.” The **(void **)* syntax doesn’t incur this warning
    because we are assigning to an address *pointed to* by the assignment’s lvalue.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于这段代码，*gcc -pedantic* 警告：“ANSI C 禁止将强制转换表达式用作左值。” **(void **)* 语法不会触发这个警告，因为我们是在为赋值的左值指向的地址
    *赋值*。
- en: 'On many UNIX implementations, we can use casts such as the following to eliminate
    warnings from the C compiler:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多 UNIX 实现中，我们可以使用如下的强制转换来消除 C 编译器的警告：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, the specification of *dlsym()* in SUSv3 *Technical Corrigendum Number
    1* notes that the C99 standard nevertheless requires compilers to generate a warning
    for such a conversion, and proposes the **(void **)* syntax shown above.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，SUSv3 *技术修正第 1 号* 中对 *dlsym()* 的规范指出，C99 标准仍然要求编译器为这种转换生成警告，并提出了上述 **(void
    **)* 语法。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 TC1 noted that because of the need for the **(void **)* syntax, a future
    version of the standard may define separate *dlsym()*-like APIs for handling data
    and function pointers. However, SUSv4 contains no changes with respect to this
    point.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 TC1 指出，由于需要 **(void **)* 语法，标准的未来版本可能会定义单独的 *dlsym()* 类似 API 来处理数据和函数指针。然而，SUSv4
    在这一点上没有任何变化。
- en: Using library pseudohandles with *dlsym()*
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用库伪句柄与 *dlsym()*
- en: 'Instead of specifying a library handle returned by a call to *dlopen()*, either
    of the following *pseudohandles* may be specified as the *handle* argument for
    *dlsym()*:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可以指定以下任一 *伪句柄* 作为 *dlsym()* 的 *handle* 参数，而不是指定由 *dlopen()* 调用返回的库句柄：
- en: '`RTLD_DEFAULT`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTLD_DEFAULT`'
- en: Search for *symbol* starting with the main program, and then proceeding in order
    through the list of all shared libraries loaded, including those libraries dynamically
    loaded by *dlopen()* with the `RTLD_GLOBAL` flag. This corresponds to the default
    search model employed by the dynamic linker.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从主程序开始搜索 *symbol*，然后按照顺序搜索加载的所有共享库，包括通过带有 `RTLD_GLOBAL` 标志的 *dlopen()* 动态加载的库。这对应于动态链接器使用的默认搜索模型。
- en: '`RTLD_NEXT`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTLD_NEXT`'
- en: Search for *symbol* in shared libraries loaded after the one invoking *dlsym()*.
    This is useful when creating a wrapper function with the same name as a function
    defined elsewhere. For example, in our main program, we may define our own version
    of *malloc()* (which perhaps does some bookkeeping of memory allocation), and
    this function can invoke the real *malloc()* by first obtaining its address via
    the call *func = dlsym(RTLD_NEXT, “malloc”)*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 *dlsym()* 的库之后，搜索 *symbol*。这在创建与其他地方定义的函数同名的包装函数时非常有用。例如，在我们的主程序中，我们可能会定义自己的
    *malloc()* 版本（可能会执行一些内存分配的记账），然后这个函数可以通过首先通过调用 *func = dlsym(RTLD_NEXT, “malloc”)*
    获取真实的 *malloc()* 地址来调用实际的 *malloc()*。
- en: The pseudohandle values listed above are not required by SUSv3 (which nevertheless
    reserves them for future use), and are not available on all UNIX implementations.
    In order to get the definitions of these constants from `<dlfcn.h>`, we must define
    the `_GNU_SOURCE` feature test macro.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上面列出的伪句柄值不是 SUSv3 所要求的（尽管它为未来使用保留了这些值），并且并非所有 UNIX 实现都支持它们。为了从 `<dlfcn.h>` 获取这些常量的定义，我们必须定义
    `_GNU_SOURCE` 功能测试宏。
- en: Example program
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 42-1](ch42.html#using_the_dlopen_api "Example 42-1. Using the dlopen
    API") demonstrates the use of the *dlopen* API. This program takes two command-line
    arguments: the name of a shared library to load and the name of a function to
    execute within that library. The following examples demonstrate the use of this
    program:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 42-1](ch42.html#using_the_dlopen_api "示例 42-1. 使用 dlopen API") 演示了如何使用
    *dlopen* API。该程序接受两个命令行参数：要加载的共享库的名称和在该库中要执行的函数的名称。以下示例展示了如何使用此程序：'
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the first of the above commands, *dlopen()* notes that the library path includes
    a slash and thus interprets it as a relative pathname (in this case, to a library
    in the current working directory). In the second command, we specify a library
    search path in `LD_LIBRARY_PATH`. This search path is interpreted according to
    the usual rules of the dynamic linker (in this case, likewise to find the library
    in the current working directory).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述第一个命令中，*dlopen()* 注意到库路径包含斜杠，因此将其解释为相对路径名（在这种情况下，是指向当前工作目录中的库）。在第二个命令中，我们指定了
    `LD_LIBRARY_PATH` 中的库搜索路径。这个搜索路径会根据动态链接器的常规规则进行解释（在这种情况下，同样是为了找到当前工作目录中的库）。
- en: Example 42-1. Using the *dlopen* API
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 42-1. 使用 *dlopen* API
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Closing a Shared Library: *dlclose()*'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭共享库：*dlclose()*
- en: The *dlclose()* function closes a library.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*dlclose()* 函数用于关闭一个库。'
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，错误时返回 -1
- en: The *dlclose()* function decrements the system’s counter of open references
    to the library referred to by *handle*. If this reference count falls to 0, and
    no symbols in the library are required by other libraries, then the library is
    unloaded. This procedure is also (recursively) performed for the libraries in
    this library’s dependency tree. An implicit *dlclose()* of all libraries is performed
    on process termination.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*dlclose()* 函数会递减系统对由 *handle* 引用的库的打开引用计数。如果该引用计数降为 0，并且该库中的符号不再被其他库需要，则该库将被卸载。此过程也会（递归地）对该库依赖树中的库进行处理。进程终止时，会隐式执行所有库的
    *dlclose()* 操作。'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: From *glibc* 2.2.3 onward, a function within a shared library can use *atexit()*
    (or *on_exit()*) to establish a function that is called automatically when the
    library is unloaded.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *glibc* 2.2.3 开始，共享库中的函数可以使用 *atexit()*（或 *on_exit()*）来建立一个在库被卸载时自动调用的函数。
- en: 'Obtaining Information About Loaded Symbols: *dladdr()*'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取已加载符号的信息：*dladdr()*
- en: Given an address in *addr* (typically, one obtained by an earlier call to *dlsym()*),
    *dladdr()* returns a structure containing information about that address.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 *addr* 中的一个地址（通常是通过之前调用 *dlsym()* 获取的地址），*dladdr()* 会返回一个包含该地址信息的结构体。
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns nonzero value if *addr* was found in a shared library, otherwise 0
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *addr* 在共享库中找到了，则返回非零值，否则返回 0。
- en: 'The *info* argument is a pointer to a caller-allocated structure that has the
    following form:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*info* 参数是指向调用者分配的结构体的指针，该结构体具有以下形式：'
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first two fields of the *Dl_info* structure specify the pathname and run-time
    base address of the shared library containing the address specified in *addr*.
    The last two fields return information about that address. Assuming that *addr*
    points to the exact address of a symbol in the shared library, then *dli_saddr*
    returns the same value as was passed in *addr*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dl_info* 结构的前两个字段指定了包含 *addr* 指定地址的共享库的路径名和运行时基地址。最后两个字段返回该地址的相关信息。假设 *addr*
    指向共享库中符号的准确地址，那么 *dli_saddr* 返回的值与传入的 *addr* 相同。'
- en: SUSv3 doesn’t specify *dladdr()*, and this function is not available on all
    UNIX implementations.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 并没有规定 *dladdr()*，并且并非所有 UNIX 实现都提供这个函数。
- en: Accessing Symbols in the Main Program
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问主程序中的符号
- en: Suppose that we use *dlopen()* to dynamically load a shared library, use *dlsym()*
    to obtain the address of a function *x()* from that library, and then call *x()*.
    If *x()* in turn calls a function *y()*, then *y()* would normally be sought in
    one of the shared libraries loaded by the program.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用 *dlopen()* 动态加载一个共享库，使用 *dlsym()* 获取该库中函数 *x()* 的地址，然后调用 *x()*。如果 *x()*
    又调用了函数 *y()*，那么 *y()* 通常会在程序加载的某个共享库中被寻找。
- en: 'Sometimes, it is desirable instead to have *x()* invoke an implementation of
    *y()* in the main program. (This is similar to a callback mechanism.) In order
    to do this, we must make the (global-scope) symbols in the main program available
    to the dynamic linker, by linking the program using the *--export-dynamic* linker
    option:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望 *x()* 调用的是主程序中实现的 *y()*。这类似于回调机制。为了实现这一点，我们必须通过使用 *--export-dynamic*
    链接器选项将主程序中的（全局作用域）符号提供给动态链接器：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Equivalently, we can write the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 等效地，我们可以写出以下代码：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using either of these options allows a dynamically loaded library to access
    global symbols in the main program.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些选项中的任何一个，都可以让动态加载的库访问主程序中的全局符号。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *gcc -rdynamic* option and the *gcc -Wl,-E* option are further synonyms
    for *-Wl,--export-dynamic*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*gcc -rdynamic* 选项和 *gcc -Wl,-E* 选项是 *-Wl,--export-dynamic* 的其他同义词。'
- en: Controlling Symbol Visibility
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制符号的可见性
- en: 'A well-designed shared library should make visible only those symbols (functions
    and variables) that form part of its specified application binary interface (ABI).
    The reasons for this are as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的共享库应该只暴露那些构成其指定应用程序二进制接口（ABI）的一部分的符号（函数和变量）。其原因如下：
- en: If the shared library designer accidentally exports unspecified interfaces,
    then authors of applications that use the library may choose to employ these interfaces.
    This creates a compatibility problem for future upgrades of the shared library.
    The library developer expects to be able to change or remove any interfaces other
    than those in the documented ABI, while the library user expects to continue using
    the same interfaces (with the same semantics) that they currently employ.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果共享库设计者不小心导出了未指定的接口，那么使用该库的应用程序作者可能会选择使用这些接口。这就为共享库的未来升级带来了兼容性问题。库开发者希望能够更改或删除任何不属于文档化
    ABI 的接口，而库用户希望继续使用他们当前使用的相同接口（保持相同语义）。
- en: During run-time symbol resolution, any symbols that are exported by a shared
    library might interpose definitions that are provided in other shared libraries
    ([Run-Time Symbol Resolution](ch41.html#run-time_symbol_resolution "Run-Time Symbol
    Resolution")).
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时符号解析过程中，任何由共享库导出的符号可能会插入由其他共享库提供的定义（[运行时符号解析](ch41.html#run-time_symbol_resolution
    "Run-Time Symbol Resolution")）。
- en: Exporting unnecessary symbols increases the size of the dynamic symbol table
    that must be loaded at run time.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出不必要的符号会增加动态符号表的大小，从而导致在运行时必须加载更多的内容。
- en: 'All of these problems can be minimized or avoided altogether if the library
    designer ensures that only the symbols required by the library’s specified ABI
    are exported. The following techniques can be used to control the export of symbols:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果库的设计者确保只导出库指定ABI所需的符号，所有这些问题都可以最小化甚至完全避免。可以使用以下技术来控制符号的导出：
- en: In a C program, we can use the `static` keyword to make a symbol private to
    a source-code module, thus rendering it unavailable for binding by other object
    files.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C程序中，我们可以使用`static`关键字将符号设为源代码模块的私有，从而使其无法被其他目标文件绑定。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As well as making a symbol private to a source-code module, the `static` keyword
    also has a converse effect. If a symbol is marked as `static`, then all references
    to the symbol in the same source file will be bound to that definition of the
    symbol. Consequently, these references won’t be subject to run-time interposition
    by definitions from other shared libraries (in the manner described in [Run-Time
    Symbol Resolution](ch41.html#run-time_symbol_resolution "Run-Time Symbol Resolution")).
    This effect of the `static` keyword is similar to the *-Bsymbolic* linker option
    described in [Run-Time Symbol Resolution](ch41.html#run-time_symbol_resolution
    "Run-Time Symbol Resolution"), with the difference that the `static` keyword affects
    a single symbol within a single source file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将符号设为源代码模块的私有外，`static`关键字还有一个相反的效果。如果一个符号被标记为`static`，那么同一源文件中对该符号的所有引用将绑定到该符号的定义。因此，这些引用不会受到其他共享库定义的运行时插入（如在[运行时符号解析](ch41.html#run-time_symbol_resolution
    "Run-Time Symbol Resolution")中所描述的方式）。`static`关键字的这个效果类似于[运行时符号解析](ch41.html#run-time_symbol_resolution
    "Run-Time Symbol Resolution")中描述的*-Bsymbolic*链接选项，区别在于`static`关键字只影响单个源文件中的单个符号。
- en: 'The GNU C complier, *gcc*, provides a compiler-specific attribute declaration
    that performs a similar task to the `static` keyword:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU C 编译器，*gcc*，提供了一个编译器特定的属性声明，它执行的任务与`static`关键字类似：
- en: '[PRE17]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Whereas the `static` keyword limits the visibility of a symbol to a single source
    code file, the `hidden` attribute makes the symbol available across all source
    code files that compose the shared library, but prevents it from being visible
    outside the library.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而`static`关键字将符号的可见性限制在单一的源代码文件内，`hidden`属性则使符号在构成共享库的所有源代码文件中可用，但防止它在库外部可见。
- en: Note
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As with the `static` keyword, the `hidden` attribute also has the converse effect
    of preventing symbol interposition at run time.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与`static`关键字类似，`hidden`属性也有防止符号在运行时插入的相反效果。
- en: Version scripts ([Linker Version Scripts](ch42.html#linker_version_scripts "Linker
    Version Scripts")) can be used to precisely control symbol visibility and to select
    the version of a symbol to which a reference is bound.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本脚本（[链接器版本脚本](ch42.html#linker_version_scripts "Linker Version Scripts")）可以用来精确控制符号的可见性，并选择引用所绑定的符号版本。
- en: 'When dynamically loading a shared library ([Opening a Shared Library: *dlopen()*](ch42.html#opening_a_shared_library_colon_dlopen_op
    "Opening a Shared Library: dlopen()")), the *dlopen()* `RTLD_GLOBAL` flag can
    be used to specify that the symbols defined by the library should be made available
    for binding by subsequently loaded libraries, and the *—export-dynamic* linker
    option ([Accessing Symbols in the Main Program](ch42.html#accessing_symbols_in_the_main_program
    "Accessing Symbols in the Main Program")) can be used to make the global symbols
    of the main program available to dynamically loaded libraries.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在动态加载共享库时（[打开共享库：*dlopen()*](ch42.html#opening_a_shared_library_colon_dlopen_op
    "Opening a Shared Library: dlopen()")），可以使用*dlopen()*的`RTLD_GLOBAL`标志来指定库定义的符号应当对后续加载的库可用，*—export-dynamic*链接选项（[访问主程序中的符号](ch42.html#accessing_symbols_in_the_main_program
    "Accessing Symbols in the Main Program")）可以用来使主程序的全局符号在动态加载的库中可用。'
- en: For further details on the topic of symbol visibility, see [Drepper, 2004 (b)].
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 关于符号可见性主题的更多详细信息，请参见[Drepper, 2004 (b)]。
- en: Linker Version Scripts
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接器版本脚本
- en: 'A *version script* is a text file containing instructions for the linker, *ld*.
    In order to use a version script, we must specify the *—version-script* linker
    option:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*版本脚本*是一个包含链接器*ld*指令的文本文件。为了使用版本脚本，我们必须指定*—version-script*链接选项：'
- en: '[PRE18]*`myscriptfile.map`*`` `...`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE18]*`myscriptfile.map`*`` `...`'
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: $ `gcc -g -c -fPIC -Wall vis_comm.c vis_f1.c vis_f2.c`
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: $ `gcc -g -c -fPIC -Wall vis_comm.c vis_f1.c vis_f2.c`
- en: $ `gcc -g -shared -o vis.so vis_comm.o vis_f1.o vis_f2.o`
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: $ `gcc -g -shared -o vis.so vis_comm.o vis_f1.o vis_f2.o`
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: $ `readelf --syms --use-dynamic vis.so | grep vis_`
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: $ `readelf --syms --use-dynamic vis.so | grep vis_`
- en: '30  12: 00000790    59    FUNC GLOBAL DEFAULT  10 vis_f1'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '30  12: 00000790    59    FUNC GLOBAL DEFAULT  10 vis_f1'
- en: '25  13: 000007d0    73    FUNC GLOBAL DEFAULT  10 vis_f2'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '25  13: 000007d0    73    FUNC GLOBAL DEFAULT  10 vis_f2'
- en: '27  16: 00000770    20    FUNC GLOBAL DEFAULT  10 vis_comm'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '27  16: 00000770    20    FUNC GLOBAL DEFAULT  10 vis_comm'
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: $ `cat vis.map`
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: $ `cat vis.map`
- en: VER_1 {
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: VER_1 {
- en: 'global:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'global:'
- en: vis_f1;
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: vis_f1;
- en: vis_f2;
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: vis_f2;
- en: 'local:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'local:'
- en: '*;'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*;'
- en: '};'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: $ `gcc -g -c -fPIC -Wall vis_comm.c vis_f1.c vis_f2.c`
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: $ `gcc -g -c -fPIC -Wall vis_comm.c vis_f1.c vis_f2.c`
- en: $ `gcc -g -shared -o vis.so vis_comm.o vis_f1.o vis_f2.o \`
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: $ `gcc -g -shared -o vis.so vis_comm.o vis_f1.o vis_f2.o \`
- en: '`-Wl,--version-script,vis.map`'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`-Wl,--version-script,vis.map`'
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: $ `readelf --syms --use-dynamic vis.so | grep vis_`
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: $ `readelf --syms --use-dynamic vis.so | grep vis_`
- en: '25   0: 00000730    73    FUNC GLOBAL DEFAULT  11 vis_f2'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '25   0: 00000730    73    FUNC GLOBAL DEFAULT  11 vis_f2'
- en: '29  16: 000006f0    59    FUNC GLOBAL DEFAULT  11 vis_f1'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '29  16: 000006f0    59    FUNC GLOBAL DEFAULT  11 vis_f1'
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: $ `cat sv_lib_v1.c`
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: $ `cat sv_lib_v1.c`
- en: '#include <stdio.h>'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <stdio.h>'
- en: void xyz(void) { printf("v1 xyz\n"); }
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: void xyz(void) { printf("v1 xyz\n"); }
- en: $ `cat sv_v1.map`
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: $ `cat sv_v1.map`
- en: VER_1 {
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: VER_1 {
- en: 'global: xyz;'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'global: xyz;'
- en: 'local:  *;      # Hide all other symbols'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'local:  *;      # 隐藏所有其他符号'
- en: '};'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: $ `gcc -g -c -fPIC -Wall sv_lib_v1.c`
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: $ `gcc -g -c -fPIC -Wall sv_lib_v1.c`
- en: $ `gcc -g -shared -o libsv.so sv_lib_v1.o -Wl,--version-script,sv_v1.map`
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: $ `gcc -g -shared -o libsv.so sv_lib_v1.o -Wl,--version-script,sv_v1.map`
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: $ `cat sv_prog.c`
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: $ `cat sv_prog.c`
- en: '#include <stdlib.h>'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <stdlib.h>'
- en: int
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: main(int argc, char *argv[])
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: main(int argc, char *argv[])
- en: '{'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: void xyz(void);
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: void xyz(void);
- en: xyz();
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: xyz();
- en: exit(EXIT_SUCCESS);
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: exit(EXIT_SUCCESS);
- en: '}'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: $ `gcc -g -o p1 sv_prog.c libsv.so`
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: $ `gcc -g -o p1 sv_prog.c libsv.so`
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: $ `LD_LIBRARY_PATH=. ./p1`
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: $ `LD_LIBRARY_PATH=. ./p1`
- en: v1 xyz
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: v1 xyz
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: $ `cat sv_lib_v2.c`
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: $ `cat sv_lib_v2.c`
- en: '#include <stdio.h>'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <stdio.h>'
- en: __asm__(".symver xyz_old,xyz@VER_1");
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: __asm__(".symver xyz_old,xyz@VER_1");
- en: __asm__(".symver xyz_new,xyz@@VER_2");
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: __asm__(".symver xyz_new,xyz@@VER_2");
- en: void xyz_old(void) { printf("v1 xyz\n"); }
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: void xyz_old(void) { printf("v1 xyz\n"); }
- en: void xyz_new(void) { printf("v2 xyz\n"); }
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: void xyz_new(void) { printf("v2 xyz\n"); }
- en: void pqr(void) { printf("v2 pqr\n"); }
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: void pqr(void) { printf("v2 pqr\n"); }
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: $ `cat sv_v2.map`
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: $ `cat sv_v2.map`
- en: VER_1 {
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: VER_1 {
- en: 'global: xyz;'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'global: xyz;'
- en: 'local:  *;      # Hide all other symbols'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'local:  *;      # 隐藏所有其他符号'
- en: '};'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: VER_2 {
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: VER_2 {
- en: 'global: pqr;'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'global: pqr;'
- en: '} VER_1;'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '} VER_1;'
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '} VER_1;'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '} VER_1;'
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: $ `gcc -g -c -fPIC -Wall sv_lib_v2.c`
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: $ `gcc -g -c -fPIC -Wall sv_lib_v2.c`
- en: $ `gcc -g -shared -o libsv.so sv_lib_v2.o -Wl,--version-script,sv_v2.map`
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: $ `gcc -g -shared -o libsv.so sv_lib_v2.o -Wl,--version-script,sv_v2.map`
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: $ `gcc -g -o p2 sv_prog.c libsv.so`
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: $ `gcc -g -o p2 sv_prog.c libsv.so`
- en: $ `LD_LIBRARY_PATH=. ./p2`
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: $ `LD_LIBRARY_PATH=. ./p2`
- en: v2 xyz                                        *Uses* *xyz@VER_2*
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: v2 xyz                                        *使用* *xyz@VER_2*
- en: $ `LD_LIBRARY_PATH=. ./p1`
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: $ `LD_LIBRARY_PATH=. ./p1`
- en: v1 xyz                                        *Uses* *xyz@VER_1*
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: v1 xyz                                        *使用* *xyz@VER_1*
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: $ `objdump -t p1 | grep xyz`
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: $ `objdump -t p1 | grep xyz`
- en: 08048380       F *UND*  0000002e              xyz@@VER_1
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 08048380       F *UND*  0000002e              xyz@@VER_1
- en: $ `objdump -t p2 | grep xyz`
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: $ `objdump -t p2 | grep xyz`
- en: 080483a0       F *UND*  0000002e              xyz@@VER_2
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 080483a0       F *UND*  0000002e              xyz@@VER_2
- en: '[PRE33]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: void __attribute__ ((constructor)) some_name_load(void)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: void __attribute__ ((constructor)) some_name_load(void)
- en: '{'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: /* Initialization code */
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /* 初始化代码 */
- en: '}'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: void __attribute__ ((destructor)) some_name_unload(void)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: void __attribute__ ((destructor)) some_name_unload(void)
- en: '{'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: /* Finalization code */
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /* 终结代码 */
- en: '}'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: $ `./prog`
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: $ `./prog`
- en: Called mod1-x1 DEMO
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 mod1-x1 DEMO
- en: Called mod2-x2 DEMO
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 mod2-x2 DEMO
- en: '[PRE36]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: $ `LD_PRELOAD=libalt.so ./prog`
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: $ `LD_PRELOAD=libalt.so ./prog`
- en: Called mod1-x1 ALT
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 mod1-x1 ALT
- en: Called mod2-x2 DEMO
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 mod2-x2 DEMO
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: $ `LD_DEBUG=help date`
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: $ `LD_DEBUG=help date`
- en: 'Valid options for the LD_DEBUG environment variable are:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: LD_DEBUG 环境变量的有效选项包括：
- en: libs       display library search paths
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: libs       显示库搜索路径
- en: reloc      display relocation processing
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: reloc      显示重定位处理
- en: files      display progress for input file
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: files      显示输入文件的进度
- en: symbols    display symbol table processing
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: symbols    显示符号表处理
- en: bindings   display information about symbol binding
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: bindings   显示符号绑定信息
- en: versions   display version dependencies
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: versions   显示版本依赖关系
- en: all        all previous options combined
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: all        所有之前的选项组合
- en: statistics display relocation statistics
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: statistics 显示重定位统计信息
- en: unused     determine unused DSOs
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: unused     确定未使用的 DSO
- en: help       display this help message and exit
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: help       显示此帮助信息并退出
- en: To direct the debugging output into a file instead of standard output
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将调试输出定向到文件而非标准输出
- en: a filename can be specified using the LD_DEBUG_OUTPUT environment variable.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 LD_DEBUG_OUTPUT 环境变量指定文件名。
- en: '[PRE38]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: $ `LD_DEBUG=libs date`
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: $ `LD_DEBUG=libs date`
- en: '10687:     find library=librt.so.1 [0]; searching'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10687:     找到库=librt.so.1 [0]; 正在搜索'
- en: '10687:      search cache=/etc/ld.so.cache'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10687:      搜索缓存=/etc/ld.so.cache'
- en: '10687:       trying file=/lib/librt.so.1'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10687:       尝试文件=/lib/librt.so.1'
- en: '10687:     find library=libc.so.6 [0]; searching'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10687:     找到库=libc.so.6 [0]; 正在搜索'
- en: '10687:      search cache=/etc/ld.so.cache'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10687:      搜索缓存=/etc/ld.so.cache'
- en: '10687:       trying file=/lib/libc.so.6'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10687:       尝试文件=/lib/libc.so.6'
- en: '10687:     find library=libpthread.so.0 [0]; searching'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10687:     找到库=libpthread.so.0 [0]; 正在搜索'
- en: '10687:      search cache=/etc/ld.so.cache'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10687:      搜索缓存=/etc/ld.so.cache'
- en: '10687:       trying file=/lib/libpthread.so.0'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10687:       尝试文件=/lib/libpthread.so.0'
- en: '10687:     calling init: /lib/libpthread.so.0'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10687:     调用 init: /lib/libpthread.so.0'
- en: '10687:     calling init: /lib/libc.so.6'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10687:     调用 init: /lib/libc.so.6'
- en: '10687:     calling init: /lib/librt.so.1'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10687:     调用 init: /lib/librt.so.1'
- en: '10687:     initialize program: date'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10687:     初始化程序：date'
- en: '10687:     transferring control: date'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10687:     转交控制：date'
- en: Tue Dec 28 17:26:56 CEST 2010
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年12月28日 星期二 17:26:56 CEST
- en: '10687:     calling fini: date [0]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10687:     调用 fini: date [0]'
- en: '10687:     calling fini: /lib/librt.so.1 [0]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10687:     调用 fini: /lib/librt.so.1 [0]'
- en: '10687:     calling fini: /lib/libpthread.so.0 [0]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10687:     调用 fini: /lib/libpthread.so.0 [0]'
- en: '10687:     calling fini: /lib/libc.so.6 [0]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10687:     调用 fini: /lib/libc.so.6 [0]'
- en: '```'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The value 10687 displayed at the start of each line is the process ID of the
    process being traced. This is useful if we are monitoring several processes (e.g.,
    parent and child).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 每行开头显示的值10687是被追踪进程的进程ID。如果我们在监控多个进程（例如父进程和子进程）时，这个信息非常有用。
- en: By default, `LD_DEBUG` output is written to standard error, but we can direct
    it elsewhere by assigning a pathname to the `LD_DEBUG_OUTPUT` environment variable.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`LD_DEBUG`的输出写入标准错误，但我们可以通过将路径名分配给`LD_DEBUG_OUTPUT`环境变量将其重定向到其他地方。
- en: If desired, we can assign multiple options to `LD_DEBUG` by separating them
    with commas (no spaces should appear). The output of the *symbols* option (which
    traces symbol resolution by the dynamic linker) is particularly voluminous.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们可以通过逗号分隔（不要有空格）为`LD_DEBUG`分配多个选项。*symbols*选项（跟踪动态链接器的符号解析）的输出特别庞大。
- en: '`LD_DEBUG` is effective both for libraries implicitly loaded by the dynamic
    linker and for libraries dynamically loaded by *dlopen()*.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`LD_DEBUG`对于动态链接器隐式加载的库和通过*dlopen()*动态加载的库都有效。'
- en: For security reasons, `LD_DEBUG` is (since *glibc* 2.2.5) ignored in set-user-ID
    and set-group-ID programs.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全原因，`LD_DEBUG`（自*glibc* 2.2.5起）在设置了用户ID和组ID的程序中会被忽略。
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: The dynamic linker provides the *dlopen* API, which allows programs to explicitly
    load additional shared libraries at run time. This allows programs to implement
    plug-in functionality.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 动态链接器提供了*dlopen* API，它允许程序在运行时显式地加载额外的共享库。这使得程序能够实现插件功能。
- en: An important aspect of shared library design is controlling symbol visibility,
    so that the library exports only those symbols (functions and variables) that
    should actually be used by programs linked against the library. We looked at a
    range of techniques that can be used to control symbol visibility. Among these
    techniques was the use of version scripts, which provide fine-grained control
    of symbol visibility.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库设计的一个重要方面是控制符号可见性，以便库只导出那些程序实际使用的符号（函数和变量）。我们研究了可以用来控制符号可见性的各种技术。其中一种技术是使用版本脚本，它提供了精细的符号可见性控制。
- en: We also showed how version scripts can be used to implement a scheme that allows
    a single shared library to export multiple definitions of a symbol for use by
    different applications linked against the library. (Each application uses the
    definition that was current when the application was statically linked against
    the library.) This technique provides an alternative to the traditional library
    versioning approach of using major and minor version numbers in the shared library
    real name.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还展示了如何使用版本脚本实现一个方案，使得单一共享库可以为不同链接到该库的应用程序导出多个符号定义。（每个应用程序使用在静态链接时该应用程序所使用的当前符号定义。）这种技术提供了一个替代传统的库版本控制方法，即在共享库的实际名称中使用主版本号和次版本号。
- en: Defining initialization and finalization functions within a shared library allows
    us to automatically execute code when the library is loaded and unloaded.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在共享库中定义初始化和终结函数使我们能够在库被加载和卸载时自动执行代码。
- en: The `LD_PRELOAD` environment variable allows us to preload shared libraries.
    Using this mechanism, we can selectively override functions and other symbols
    that the dynamic linker would normally find in other shared libraries.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`LD_PRELOAD` 环境变量允许我们预加载共享库。通过使用这一机制，我们可以有选择性地覆盖动态链接器通常会在其他共享库中找到的函数和其他符号。'
- en: We can assign various values to the `LD_DEBUG` environment variable in order
    to monitor the operation of the dynamic linker.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为`LD_DEBUG`环境变量赋予不同的值，以监控动态链接器的操作。
- en: Further information
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步信息
- en: Refer to the sources of further information listed in [Summary](ch41.html#summary-id40
    "Summary").
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[摘要](ch41.html#summary-id40 "Summary")中列出的进一步信息来源。
- en: Exercises
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Write a program to verify that if a library is closed with *dlclose()*, it is
    not unloaded if any of its symbols are used by another library.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序来验证，如果一个库通过*dlclose()*关闭，当其符号被另一个库使用时，该库不会被卸载。
- en: Add a *dladdr()* call to the program in [Example 42-1](ch42.html#using_the_dlopen_api
    "Example 42-1. Using the dlopen API") (`dynload.c`) in order to retrieve information
    about the address returned by *dlsym()*. Print out the values of the fields of
    the returned *Dl_info* structure, and verify that they are as expected.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向[示例 42-1](ch42.html#using_the_dlopen_api "Example 42-1. Using the dlopen API")（`dynload.c`）中的程序添加一个*dladdr()*调用，以便检索由*dlsym()*返回的地址的信息。打印出返回的*Dl_info*结构体字段的值，并验证它们是否符合预期。
