- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">NEIGHBORS
    AND NEIGHBORHOODS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">邻居与邻域</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Almost every algorithm in this book requires interacting with a node’s *neighbors*.
    The idea of a neighbor is intuitively quite familiar; in an undirected graph,
    the neighbors of a given node are those nodes with which it shares an edge. The
    terminology for neighbors is a little more complex in directed graphs, where there
    are different types of neighbors depending on whether the edge is incoming or
    outgoing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的几乎每个算法都需要与节点的*邻居*进行交互。邻居的概念直观上是非常熟悉的；在无向图中，给定节点的邻居是与该节点共享边的节点。在有向图中，邻居的术语稍微复杂一些，因为邻居的种类取决于边是入边还是出边。
- en: Identifying the set of neighbors for a given node is a foundational step in
    most graph algorithms, such as searching for paths through a new graph, and many
    real-world tasks. When planning a trip through a transportation network, for example,
    we might ask which cities we can reach directly from the current one.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 确定给定节点的邻居集合是大多数图算法中的基础步骤，例如，在新的图中搜索路径，以及许多现实世界中的任务。例如，在规划一趟交通网络之旅时，我们可能会问自己，从当前城市可以直接到达哪些城市。
- en: 'This chapter introduces the formal definition of neighbors and presents some
    basic functions we’ll use throughout the book. It also introduces two example
    neighbor-based metrics: a node’s degree and its clustering coefficient. These
    metrics provide insights about a node’s neighborhood that help us analyze the
    characteristics of graphs. A node’s degree tells us its number of connections
    and its clustering coefficient tells us about the interconnectedness of its neighbors.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了邻居的正式定义，并展示了我们将在本书中使用的一些基本函数。它还介绍了两个基于邻居的度量：节点的度和聚类系数。这些度量提供了有关节点邻域的洞察，帮助我们分析图的特征。节点的度告诉我们它的连接数量，而聚类系数则告诉我们它的邻居之间的互联程度。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Neighbors in Undirected Graphs</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">无向图中的邻居</samp>
- en: Many metrics and algorithms require determining the set of nodes in immediate
    proximity to a given node *v*. In an undirected graph, the *neighbors* of node
    *v* are all nodes connected to *v* by an edge. [Figure 2-1](#fig2-1) shows an
    example graph and lists the neighbors for each node. Node 0 has three neighbors
    (1, 3, and 4), while node 3 has only one neighbor (0).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 许多度量和算法需要确定与给定节点*v*直接相邻的节点集合。在无向图中，节点*v*的*邻居*是所有与*v*通过边相连的节点。[图 2-1](#fig2-1)展示了一个示例图，并列出了每个节点的邻居。节点
    0 有三个邻居（1、3 和 4），而节点 3 只有一个邻居（0）。
- en: '![Six nodes are labeled 0 through 5\. Each node is a circle and edges are lines
    joining a pair of circles. Each node also lists its set of neighbors. For example,
    node 0 is labeled with the set {1, 3, 4}.](../images/f02001.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![六个节点标记为 0 到 5。每个节点都是一个圆圈，边是连接一对圆圈的线。每个节点还列出了它的邻居集合。例如，节点 0 标有集合 {1, 3, 4}。](../images/f02001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: An undirected graph
    with neighbors listed for each node</samp>'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-1：一个无向图，每个节点列出了其邻居</samp>
- en: We can add a short helper function to our <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>
    class to compute the set of neighbors in an undirected graph, as shown in [Listing
    2-1](#list2-1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为我们的<samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>类添加一个简短的辅助函数，用于计算无向图中邻居的集合，如[清单
    2-1](#list2-1)所示。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-1: Determining the
    set of neighboring nodes in an undirected graph</samp>'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 2-1：确定无向图中邻居节点的集合</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp> function
    in [Listing 2-1](#list2-1) creates an empty <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    data structure, then iterates through each of the node’s edges and adds the corresponding
    neighbor to the set.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-1](#list2-1)中的<samp class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp>函数创建一个空的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">set</samp>数据结构，然后遍历每个节点的边，将相应的邻居添加到集合中。'
- en: Consider a graph representing a social network, where each person is a node
    and an undirected edge between node *v* and node *u* indicates those two people
    are friends. We might use a node’s neighbors to compose a guest list for a party,
    or to model how a rumor spreads within the network.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个表示社交网络的图，其中每个人是一个节点，节点 *v* 和节点 *u* 之间的无向边表示这两个人是朋友。我们可以使用节点的邻居来编制派对的宾客名单，或模拟谣言在网络中的传播。
- en: As another application of determining a node’s neighbors, consider the age-old
    question, “Who was in a movie with that particular star?” This is a question we
    will consider in more detail later in the chapter. We can build a co-occurrence
    graph that represents which actors appear together in a movie. Each node represents
    a single person. An edge indicates that two people have appeared in the same movie
    together. Since this relationship is always symmetric, we use an undirected graph
    to model these co-occurrences.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为确定节点邻居的另一个应用，考虑那个古老的问题，“哪位明星和某个特定的演员一起出演过电影？”这是我们将在本章稍后详细讨论的问题。我们可以构建一个共现图，表示哪些演员一起出现在电影中。每个节点代表一个人。一条边表示两个人曾一起出演过同一部电影。由于这种关系始终是对称的，我们使用无向图来建模这些共现。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Neighbors in Directed Graphs</samp>
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">有向图中的邻居</samp>
- en: 'In directed graphs, we could consider several types of nodes to be neighbors:
    the nodes at the end of outgoing edges from *v*, the nodes at the beginning of
    incoming edges to *v*, or the nodes on either side of a directed edge. To resolve
    this ambiguity, we divide neighbors for such graphs into two main types. *In-neighbors*
    are all nodes that have edges with *v* as the destination; in other words, the
    edge is incoming from node *v*’s perspective. In a directed social network where
    friendships are not symmetrical, for example, *v*’s in-neighbors are the friends
    who would tell them the latest gossip. *Out-neighbors* are all nodes to which
    *v* has an outgoing edge, representing the friends to which *v* would pass gossip.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在有向图中，我们可以将几种类型的节点视为邻居：*v* 的出边终点上的节点、*v* 的入边起点上的节点，或者是有向边两侧的节点。为了解决这个模糊性，我们将此类图的邻居分为两种主要类型。*入邻居*是所有具有以
    *v* 为目标的边的节点；换句话说，从 *v* 角度看，边是传入的。例如，在一个朋友关系不对称的有向社交网络中，*v* 的入邻居是那些会告诉他们最新八卦的朋友。*出邻居*是所有有出边指向
    *v* 的节点，表示 *v* 会将八卦传给这些朋友。
- en: The code we add to <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>
    class for computing out-neighbors in a directed graph is identical to the code
    presented in [Listing 2-1](#list2-1) for undirected graphs, except for the name
    of the function, as shown in [Listing 2-2](#list2-2).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> 类中添加的计算出邻居的代码与[清单
    2-1](#list2-1)中无向图的代码相同，唯一不同的是函数的名称，如[清单 2-2](#list2-2)所示。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-2: Determining the
    set of out-neighbors in a directed graph</samp>'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 2-2：在有向图中确定出邻居集合</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_out_neighbors()</samp>
    function iterates through all the edges and collects the destination nodes in
    a set that it then returns. The social equivalent would be compiling a list of
    people to whom one person sends messages.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">get_out_neighbors()</samp> 函数遍历所有边，并将目标节点收集到一个集合中，然后返回该集合。社交上的等价物是编制一个列表，列出一个人发送消息的对象。
- en: In contrast, the code for computing the set of in-neighbors requires us to search
    through every node in the graph, because we do not maintain lists of edges pointing
    *into* a given node, as shown in [Listing 2-3](#list2-3). This code is called
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class so that
    it has access to the full list of nodes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，计算入邻居集合的代码需要我们遍历图中的每个节点，因为我们并不维护指向给定节点的边的列表，如[清单 2-3](#list2-3)所示。此代码从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> 类调用，因此它可以访问所有节点的完整列表。
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-3: Determining the
    set of in-neighbors</samp>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 2-3：确定入邻居集合</samp>
- en: Like other neighbor algorithms, the code constructs the neighbors from an initially
    empty set. The function iterates over each node and checks whether the target
    node has an entry in that node’s <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp>
    dictionary ❶. If the target node has an entry in the node’s edges dictionary,
    the neighbor is added to the set.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他邻居算法一样，代码从一个最初为空的集合构建邻居。该函数遍历每个节点，检查目标节点是否在该节点的 <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp>
    字典中有条目❶。如果目标节点在该节点的边字典中有条目，则将邻居添加到集合中。
- en: What happens if we run [Listing 2-3](#list2-3) on an undirected graph? Not only
    does the function not fail, but it also produces the correct set of neighbors.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_in_neighbors()</samp> function
    considers the same neighboring nodes as the code in [Listing 2-1](#list2-1), but
    from the opposite side of the edge. However, <samp class="SANS_TheSansMonoCd_W5Regular_11">get_in_neighbors()</samp>
    is significantly less efficient than <samp class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp>
    on an undirected graph because it iterates over all nodes in the graph and not
    just the ones connected to the target node.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在无向图上运行[清单 2-3](#list2-3)会发生什么？不仅该函数不会失败，而且它还会产生正确的邻居集合。<samp class="SANS_TheSansMonoCd_W5Regular_11">get_in_neighbors()</samp>
    函数考虑的邻居节点与[清单 2-1](#list2-1)中的代码相同，但来自边的相反方向。然而，<samp class="SANS_TheSansMonoCd_W5Regular_11">get_in_neighbors()</samp>
    在无向图上的效率显著低于 <samp class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp>，因为它会遍历图中的所有节点，而不仅仅是与目标节点连接的那些节点。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Self-Loops</samp>
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">自环</samp>
- en: One additional complexity when defining neighbors is the potential for *self-loops*,
    in which an edge links a node to itself. For example, in [Figure 2-2](#fig2-2),
    node 1 has an edge to itself.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 定义邻居时的另一个复杂性是可能存在的 *自环*，即一条边将一个节点链接到其自身。例如，在[图 2-2](#fig2-2)中，节点 1 有一条指向自己的边。
- en: '![A graph with four nodes. Node 1 has an arrow from the node back to itself.](../images/f02002.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含四个节点的图。节点 1 有一条从节点回到自身的箭头。](../images/f02002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: A graph with a
    self-loop</samp>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-2：带自环的图</samp>
- en: Self-loops work like circular roads that return to their starting points. More
    topically, we can visualize them in the context of my conversations about this
    very book. If we use a weighted graph to represent the number of conversations
    I had with various people, the largest weighted edge would be a self-loop indicating
    the number of times I mumbled to myself while trying to work something out.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 自环就像是返回起点的环形道路。更具体地说，我们可以在我关于这本书的对话中将其可视化。如果我们使用加权图来表示我与不同的人进行的对话次数，那么最大的加权边就是一个自环，表示我在努力解决某个问题时自言自语的次数。
- en: In the adjacency list representation, a self-loop is represented by the inclusion
    of an edge whose destination matches its origin. In the adjacency matrix representation,
    a self-loop for node *v* is represented by a nonzero value along the diagonal
    of the matrix (row = *v*, column = *v*).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在邻接表表示中，自环通过包含一条目标与起点相同的边来表示。在邻接矩阵表示中，节点 *v* 的自环通过矩阵对角线上的非零值来表示（行 = *v*，列 =
    *v*）。
- en: If node *v* has a self-loop, we consider it a neighbor of itself. In the case
    of a directed graph, this means node *v* is both its own in-neighbor and its own
    out-neighbor, since the edge starts and ends at node *v*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节点 *v* 有自环，我们认为它是自己的邻居。在有向图的情况下，这意味着节点 *v* 既是它自己的入邻居，又是它自己的出邻居，因为边从节点 *v*
    开始并以节点 *v* 结束。
- en: Throughout this book, we use the common computer science convention of allowing
    self-loops only in directed graphs. While many algorithms can handle undirected
    graphs with self-loops, and most of the rest can easily be adapted to do so, these
    loops often do not make sense in the context of the problems that the undirected
    graphs are modeling. For example, the graph-coloring problem examined in [Chapter
    16](chapter16.xhtml) requires us to assign different colors to any two nodes connected
    by an edge. Self-loops make no sense in such a problem formulation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们采用计算机科学中常见的约定，只在有向图中允许自环。虽然许多算法可以处理带自环的无向图，并且其他大多数算法也能轻松适配，但这些自环在无向图所建模的问题的背景下通常是没有意义的。例如，在[第16章](chapter16.xhtml)中讨论的图着色问题要求我们为任何两个通过边连接的节点分配不同的颜色。自环在这样的题目设定中没有意义。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Degree</samp>
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">度数</samp>
- en: One useful statistic for understanding a node’s connectivity is its *degree*,
    the number of times edges connect to a node. [Figure 2-3](#fig2-3) shows an example
    undirected graph where each node is labeled with its degree. Node 0 has a degree
    of 3, while node 5 has a degree of 2.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 理解一个节点的连接性时，一个有用的统计量是其*度数*，即与该节点相连接的边的数量。[图 2-3](#fig2-3)展示了一个无向图示例，图中的每个节点都标注了其度数。节点
    0 的度数为 3，而节点 5 的度数为 2。
- en: '![A graph with six nodes labeled with their degrees. Node zero is connected
    to nodes one, three, and four and labeled with degree 3.](../images/f02003.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含六个节点的图，每个节点都标有度数。节点 0 连接到节点 1、3 和 4，度数为 3。](../images/f02003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-3: An undirected graph
    with each node’s degree shown</samp>'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-3：一个无向图，显示每个节点的度数</samp>
- en: In social networks, a node’s degree would indicate the number of friends that
    person has. We can use this as a rough proxy for how popular or well-connected
    that person is.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在社交网络中，一个节点的度数表示该人拥有的朋友数量。我们可以将其作为该人受欢迎程度或社交连接的一个粗略代理。
- en: From a mathematical standpoint, edges forming self-loops in undirected graphs
    are counted twice for the degree, since they contact the node on each end. While
    we do not use self-loops in undirected graphs for the algorithms in this book,
    we will include this check for completeness when computing degree in [Chapter
    18](chapter18.xhtml).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学角度来看，在无向图中形成自环的边会被计算两次，因为它们分别与每个端点的节点相接触。尽管在本书的算法中我们不使用无向图中的自环，但在计算度数时为了完整性，我们仍会包括此检查，详见[第18章](chapter18.xhtml)。
- en: In directed graphs, we break the concept of degrees into two separate measures,
    as we do for neighbors. A node’s *out-degree* measures the number of connections
    out of that node, while its *in-degree* measures the number of edges from other
    nodes into the given node. In a social network, your in-degrees and out-degrees
    could represent the number of people with whom you share news and the number of
    people who share news with you, respectively. Good confidants are friends with
    a high in-degree and a low out-degree. Good sources of gossip have both a high
    in-degree, to collect tidbits, and a high out-degree, indicating their willingness
    to pass those tidbits along.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在有向图中，我们将度数的概念分为两个独立的度量，就像邻居一样。一个节点的*出度*衡量该节点的连接数，而其*入度*衡量其他节点指向该节点的边的数量。在社交网络中，您的入度和出度可能分别代表您与多少人分享新闻，以及有多少人向您分享新闻。好的知己是具有高入度和低出度的朋友。好的八卦源则拥有高入度以收集小道消息，并且有高出度，表明他们愿意传播这些小道消息。
- en: Edges forming self-loops in directed graphs have the same *origin* and *destination*.
    They count once toward the in-degree and once toward the out-degree. For example,
    [Figure 2-4](#fig2-4) shows a directed graph and the degrees for each node. The
    left-hand side of the figure shows each node’s out-degree, while the right-hand
    side shows their in-degrees.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在有向图中，形成自环的边具有相同的*起点*和*终点*。它们会分别计算一次入度和一次出度。例如，[图 2-4](#fig2-4)展示了一个有向图以及每个节点的度数。图的左侧展示了每个节点的出度，而右侧展示了它们的入度。
- en: '![Two graphs with six nodes each. In both, node 0 has outgoing arrows to nodes
    1 and 3 and an incoming arrow from node 4\. In the graph on the left, node 0 has
    a label of 2\. In the graph on the right, Node 0 has a label of 1.](../images/f02004.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![两个包含六个节点的图。在两个图中，节点 0 都有指向节点 1 和 3 的出箭头，以及来自节点 4 的入箭头。在左侧图中，节点 0 的标签为 2；在右侧图中，节点
    0 的标签为 1。](../images/f02004.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-4: A directed graph
    labeling each node’s out-degree (a) and in-degree (b)</samp>'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-4：一个有向图，标注了每个节点的出度（a）和入度（b）</samp>
- en: Computing a node’s in-degree or out-degree in a connected graph requires counting
    the number of incoming or outgoing edges. To do so, we can adapt the neighbor
    computation code from the previous section by keeping a counter instead of building
    a set.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个连通图中，计算节点的入度或出度需要统计传入或传出的边的数量。为此，我们可以通过保持计数器而不是构建集合，改编前一节中的邻居计算代码。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Clustering Coefficient</samp>
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">聚类系数</samp>
- en: The *clustering coefficient* of a node (sometimes called the *local clustering
    coefficient*) is a metric that characterizes how interconnected the node’s neighbors
    are with each other. In the context of a social network, the clustering coefficient
    effectively asks, “To what extent are my friends also friends with each other?”
    At zero, the metric indicates that none of our friends like each other, leading
    to extremely awkward parties. At the other extreme, a value of one indicates that
    every one of our friends is connected to every other friend.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的 *聚类系数*（有时称为 *局部聚类系数*）是一个衡量节点邻居之间相互连接程度的指标。在社交网络的背景下，聚类系数实际上是在问：“我的朋友们在多大程度上也互相是朋友？”当该值为零时，表示我们的朋友们互相不喜欢对方，这样的聚会会非常尴尬。另一方面，当值为一时，表示我们的每一个朋友都与每个其他朋友有连接。
- en: Formally, the clustering coefficient for a node *v* in an undirected graph is
    the fraction of possible edges among *v*’s neighbors that exist. We find the set
    of all neighbors (all nodes that share an edge with *v*), count how many of those
    neighbors share an edge with each other, and divide that by the total number of
    possible edges within that set. If node *v* has *k* neighbors, there could be
    up to *k* (*k* – 1) / 2 possible edges between them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正式来说，在一个无向图中，节点 *v* 的聚类系数是 *v* 的邻居之间存在的边占所有可能边的比例。我们找出所有邻居的集合（即与 *v* 共享一条边的所有节点），统计这些邻居之间共享的边数，然后将其除以该集合内所有可能的边数。如果节点
    *v* 有 *k* 个邻居，则它们之间可能存在最多 *k* (*k* – 1) / 2 条边。
- en: Nodes with one or fewer neighbors need special treatment because their neighbors
    have zero possible connections. If someone has no friends, it makes no sense to
    compute the percentage of their friends who like each other. For simplicity, we
    return a value of 0 in these cases, reflecting the lack of local connections.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个或更少邻居的节点需要特殊处理，因为它们的邻居没有任何可能的连接。如果某人没有朋友，那么计算他们的朋友之间互相喜欢的百分比就没有意义。为了简化处理，在这种情况下我们返回值
    0，表示没有局部连接。
- en: We can define a function to compute the clustering coefficient of a given node
    with index <samp class="SANS_TheSansMonoCd_W5Regular_11">ind</samp> in an undirected
    graph, as shown in [Listing 2-4](#list2-4).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个函数来计算给定节点索引为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ind</samp>
    的无向图中节点的聚类系数，如[列表 2-4](#list2-4)所示。
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-4: Code to compute
    the local clustering coefficient</samp>'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 2-4：计算局部聚类系数的代码</samp>
- en: The code for the <samp class="SANS_TheSansMonoCd_W5Regular_11">clustering_coefficient()</samp>
    function starts by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp>
    function ❶ from [Listing 2-1](#list2-1) to generate the set of all neighboring
    nodes. It then uses a pair of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops to check each unique pair of neighbors. The first <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop iterates over the node’s neighbors, and the second iterates over the neighbor’s
    edges.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">clustering_coefficient()</samp>`
    函数的代码首先使用来自[列表 2-1](#list2-1)的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp>`
    函数 ❶ 来生成所有邻居节点的集合。然后，它使用一对嵌套的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>`
    循环检查每一对唯一的邻居。第一个 `<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>` 循环遍历节点的邻居，第二个则遍历邻居的边。'
- en: For each edge that includes the neighboring node, the code checks that the node
    on the other side of the edge has an index greater than the current neighbor node
    and is also a neighbor of the original node ❷. The first check is necessary to
    avoid double-counting the neighbors. Undirected edges appear twice in the adjacency
    lists but should be counted only once. Each edge (*u*, *v*) is counted only when
    *u* < *v*. If the edge passes this test, it is counted.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个包含邻居节点的边，代码会检查边的另一端的节点是否具有大于当前邻居节点的索引，并且是否也是原始节点的邻居 ❷。第一个检查是为了避免重复计数邻居。在邻接列表中，无向边会出现两次，但只应计数一次。每条边
    (*u*, *v*) 仅当 *u* < *v* 时才会被计数。如果边通过了这一检查，则会被计数。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">clustering_coefficient()</samp>
    function finishes by returning the fraction of total possible edges among neighbors
    that are observed, taking care to avoid a divide-by-zero if a node has one or
    zero neighbors ❸.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">clustering_coefficient()</samp>`
    函数最终返回的是邻居节点之间观测到的边的总数占所有可能边的比例，同时会避免在节点有一个或零个邻居时出现除以零的情况 ❸。'
- en: '[Figure 2-5](#fig2-5) shows an example graph that lists the clustering coefficient
    for each node.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-5](#fig2-5) 显示了一个示例图，其中列出了每个节点的聚类系数。'
- en: '![Each node in this six-node graph is labeled with its clustering coefficient.
    Node 0 is connected to nodes 1, 3, and 4\. Of those neighbors, only nodes 1 and
    4 share a connection. node 0 has a coefficient of 1/3.](../images/f02005.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![每个节点在这个六节点图中都标注了它的聚类系数。节点 0 与节点 1、3 和 4 相连。在这些邻居中，只有节点 1 和 4 之间有连接。节点 0 的系数为
    1/3。](../images/f02005.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-5: A graph with clustering
    coefficients</samp>'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-5：带有聚类系数的图</samp>
- en: Node 0 has three neighbors (1, 3, and 4), which can have three edges among themselves,
    but only a single pair of its neighbors (1 and 4) are connected, giving it a clustering
    coefficient of 1/3\. In contrast, node 5 has two neighbors that share an edge,
    giving it a clustering coefficient of 1\. Node 3 has only one neighbor and is
    therefore assigned a value of 0.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 节点 0 有三个邻居（1、3 和 4），它们之间最多可以有三条边，但只有一对邻居（1 和 4）相互连接，这使得它的聚类系数为 1/3。相比之下，节点 5
    有两个共享边的邻居，因此它的聚类系数为 1。节点 3 只有一个邻居，因此聚类系数为 0。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Computing the Average
    Clustering Coefficient</samp>
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">计算平均聚类系数</samp>
- en: The clustering coefficient tells us only about the characteristics of the graph
    around a single node. We can extend the insights provided by computing the *average
    local clustering coefficient* for all nodes of the graph, which provides a numerical
    measure of the local interconnectedness of an undirected graph.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类系数仅告诉我们关于单个节点周围图的特征。我们可以通过计算所有节点的*平均局部聚类系数*来扩展这个洞察，这为无向图的局部互联程度提供了一个数值度量。
- en: 'We can calculate this measure for an undirected graph by computing the clustering
    coefficient for each neighbor, then taking the average, as shown in the following
    code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过计算每个邻居的聚类系数，然后取平均值来计算无向图的这个度量，代码如下所示：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ave_clustering_coefficient()</samp>
    function loops through each node, calls <samp class="SANS_TheSansMonoCd_W5Regular_11">clustering_coefficient()</samp>
    on that node, and adds the result to a running total. As long as the function
    has seen at least one node, it returns the total divided by the number of nodes.
    For example, the graph in [Figure 2-5](#fig2-5) has a local clustering coefficient
    of approximately 0.5278.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ave_clustering_coefficient()</samp>
    函数循环遍历每个节点，对该节点调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">clustering_coefficient()</samp>，并将结果累加到一个总数中。只要该函数已经处理过至少一个节点，它就会返回总数除以节点数。例如，图
    [2-5](#fig2-5) 中的图有一个局部聚类系数，约为 0.5278。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Handling Limitations</samp>
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">处理局限性</samp>
- en: The clustering coefficient only provides information about the neighboring nodes’
    connectivity relative to a single given node, without telling us anything about
    those nodes’ connectivity in general. For example, consider the graph in [Figure
    2-6](#fig2-6). Node 0 has a clustering coefficient of 1, indicating that all its
    neighbors are mutually connected. However, this doesn’t tell us anything about
    the network one step farther away, much less *all* its neighbors’ connections.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类系数只提供有关邻居节点相对于单个给定节点的连接性的信息，而无法告诉我们这些节点的连接性。例如，考虑图 [2-6](#fig2-6)。节点 0 的聚类系数为
    1，表示它的所有邻居都是互相连接的。然而，这并没有告诉我们更远一步的网络情况，更别提*所有*邻居的连接了。
- en: '![A six-node graph. Node 0 is connected directly to nodes 1 and 2\. Nodes 3,
    4, and 5 all connect to node 1 and to each other; they are shaded to indicate
    they are not part of node 0’s clustering coefficient calculation.]](../images/f02006.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![一个六节点图。节点 0 直接与节点 1 和 2 相连。节点 3、4 和 5 都与节点 1 相连，并且相互之间也有连接；它们被阴影标示出来，表示它们不参与节点
    0 聚类系数的计算。]](../images/f02006.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-6: The interconnections
    of node 0 and its immediate neighbors versus those neighbors’ connections</samp>'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-6：节点 0 及其直接邻居的相互连接与这些邻居的连接</samp>
- en: In [Figure 2-6](#fig2-6), node 1 has many additional connections that are not
    considered by the clustering coefficient because they are not directly connected
    to node 0’s neighbors. These connections are shown in gray, while immediate neighbors
    are shown in black. In this case, node 1 is part of two different sets of interconnected
    nodes, {0, 1, 2} and {1, 3, 4, 5}.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图2-6](#fig2-6)中，节点1有许多额外的连接，这些连接没有被聚类系数考虑，因为它们没有直接与节点0的邻居连接。这些连接以灰色显示，而直接邻居以黑色显示。在这种情况下，节点1属于两个不同的互联节点集合，{0,
    1, 2}和{1, 3, 4, 5}。
- en: In our social network example, this means that the clustering coefficient cannot
    tell us about our friends’ friends. Our friends may get along with each other
    but also be part of other groups. Practically speaking, the local clustering coefficient
    can tell us if the people we invited to our party will get along, but it cannot
    tell us whether there is a bigger party they’ll go to instead. For example, if
    both nodes 0 and 4 from [Figure 2-6](#fig2-6) throw a party, node 1 would enjoy
    either event but would have more friends at node 4’s party.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的社交网络示例中，这意味着聚类系数不能告诉我们关于我们朋友的朋友的信息。我们的朋友可能彼此相处得很好，但也可能属于其他群体。实际上，局部聚类系数可以告诉我们我们邀请的派对宾客是否会相互合得来，但它不能告诉我们是否有更大的派对他们会去参加。例如，如果图2-6中的节点0和节点4分别举办派对，节点1会喜欢任何一个派对，但在节点4的派对上会有更多的朋友。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Generating Neighborhood Subgraphs</samp>
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">生成邻域子图</samp>
- en: We can extend the idea of neighbors to determine a *neighborhood subgraph* in
    an undirected graph, which includes both the neighboring nodes and the edges between
    them. We define two types of neighborhoods in undirected graphs depending on whether
    we want to include the original node. An *open-neighborhood* subgraph of node
    *v* consists of the neighbors of *v* and the edges between them. A *closed-neighborhood*
    subgraph of node *v* consists of node *v* and all its neighbors, as well as the
    edges between those nodes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展邻居的概念，在无向图中确定一个*邻域子图*，该子图包括邻居节点及其之间的边。根据是否包含原始节点，我们可以定义两种类型的邻域子图。在节点*v*的*开集邻域*子图中，包括节点*v*的邻居以及它们之间的边。而节点*v*的*闭集邻域*子图则包括节点*v*及其所有邻居，以及这些节点之间的边。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: 'We can create a function within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    class to generate the open- or closed-neighborhood subgraph around a given node
    (with index <samp class="SANS_TheSansMonoCd_W5Regular_11">ind</samp>) in an undirected
    graph. This function operates by determining the neighboring nodes and using them
    to seed a new graph, then adding the appropriate edges:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在<samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>类中创建一个函数，用于生成给定节点（索引为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ind</samp>）周围的开集或闭集邻域子图（在无向图中）。这个函数通过确定邻居节点，并利用它们生成一个新的图，然后添加适当的边来操作：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code for the <samp class="SANS_TheSansMonoCd_W5Regular_11">make_undirected_neighborhood_subgraph()</samp>
    function starts by checking if the graph is undirected and, if not, raising a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueError</samp> ❶. While this
    is not strictly necessary and the code will produce some results for directed
    graphs, it helps ensure the function is used as designed. Next, the code extracts
    the target node’s set of neighbors with the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp>
    function from [Listing 2-1](#list2-1) ❷. This set, <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes_to_use</samp>,
    comprises all the nodes that will be used in the subgraph. If the subgraph is
    a closed-neighborhood subgraph, the code adds the target node itself to that set.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">make_undirected_neighborhood_subgraph()</samp>函数的代码首先检查图是否为无向图，如果不是，则抛出一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ValueError</samp> ❶。虽然这不是严格必要的，并且代码对有向图也能产生一些结果，但它有助于确保该函数按照设计使用。接下来，代码通过从[清单2-1](#list2-1)
    ❷中的<samp class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp>函数提取目标节点的邻居集合。这个集合<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nodes_to_use</samp>包含将用于子图的所有节点。如果子图是闭集邻域子图，代码会将目标节点本身添加到该集合中。
- en: The code for generating neighborhood subgraphs is complicated slightly by the
    way the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class indexes
    the nodes. Since our graph uses numeric indices in the range [0, |*V* | – 1],
    where |*V* | is the number of nodes, any subgraph might use different indices
    for a given node. To account for this, the code builds a dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">index_map</samp>
    that maps the old node index to the new node index ❸. This allows the generated
    subgraph to use numeric indices without gaps. As we will see later in [Figure
    2-8](#fig2-8), we can use alternate information, like the label, to preserve the
    identities of the nodes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 生成邻域子图的代码稍微复杂一些，因为<samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>类对节点的索引方式。由于我们的图使用的是范围为[0,
    |*V*| – 1]的数字索引，其中|*V*|是节点的数量，因此任何子图可能会对给定节点使用不同的索引。为了解决这个问题，代码构建了一个字典<samp class="SANS_TheSansMonoCd_W5Regular_11">index_map</samp>，将旧的节点索引映射到新的节点索引
    ❸。这允许生成的子图使用没有间隙的数字索引。正如我们稍后在[图 2-8](#fig2-8)中看到的，我们可以使用替代信息，如标签，来保留节点的身份。
- en: Finally, the code creates the new graph, using a pair of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops to do so. This code mirrors the local clustering coefficient code from [Listing
    2-4](#list2-4). The first <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop iterates over the nodes in <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes_to_use</samp>,
    while the second iterates over that node’s edges. By testing that the neighboring
    node’s index (<samp class="SANS_TheSansMonoCd_W5Regular_11">edge.to_node</samp>)
    is greater than the index of the current node <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>,
    the function guarantees it will insert each undirected edge only once ❹. A new
    edge is added only if both nodes are in <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes_to_use</samp>
    and the other node has not already been processed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp> function
    handles correctly inserting the undirected edge using the new node indices.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码通过一对嵌套的<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环创建了新的图。这段代码与[清单
    2-4](#list2-4)中的本地聚类系数代码类似。第一个<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环遍历<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nodes_to_use</samp>中的节点，而第二个则遍历该节点的边。通过测试邻接节点的索引（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">edge.to_node</samp>）是否大于当前节点<samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>的索引，函数可以确保每条无向边只被插入一次
    ❹。只有当两个节点都在<samp class="SANS_TheSansMonoCd_W5Regular_11">nodes_to_use</samp>中并且另一个节点尚未被处理时，才会添加一条新的边。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>类的<samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp>函数正确地使用新的节点索引插入无向边。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个示例</samp>
- en: 'Consider what happens when we build a neighborhood subgraph from the graph
    in [Figure 2-7](#fig2-7). Returning to the earlier example of the movie star network,
    this graph could represent the seven stars (Alice, Bob, Carl, Dan, Edward, Fiona,
    and Gwen) who appear in the world-famous *Graph Theory* series of action thrillers:
    *Graph Theory* (with stars Alice and Bob), *Graph Theory 2: A New Node* (with
    stars Bob and Carl), *Graph Theory 3: The Lost Edge* (with stars Bob, Fiona, and
    Gwen), and so forth. Each node is labeled with the first letter of the star’s
    name and maps their connections to their co-stars.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑从[图 2-7](#fig2-7)中的图构建一个邻域子图时会发生什么。回到之前关于电影明星网络的例子，这个图可以表示出出现在世界著名的*图论*系列动作惊悚片中的七位明星（爱丽丝、鲍勃、卡尔、丹、爱德华、菲奥娜和格温）：*图论*（主演爱丽丝和鲍勃）、*图论
    2：新节点*（主演鲍勃和卡尔）、*图论 3：失落的边缘*（主演鲍勃、菲奥娜和格温）等等。每个节点都以明星名字的首字母标记，并映射出他们与其他明星的关系。
- en: '![A graph with seven nodes. Node 1 is connected to nodes 0, 2, 5, and 6.](../images/f02007.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含七个节点的图。节点 1 与节点 0、2、5 和 6 相连。](../images/f02007.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-7: An undirected graph
    representing the stars of the</samp> <samp class="SANS_Futura_Std_Book_11">Graph
    Theory</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">series</samp>'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-7：一个表示《图论》系列明星的无向图</samp>
    <samp class="SANS_Futura_Std_Book_11">图论</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">系列</samp>
- en: To understand more about the appearances of Bob and his co-stars, we create
    a closed-neighborhood subgraph around Bob (node 1). This represents the stars
    with whom Bob has shared the screen and captures the interactions among them.
    [Figure 2-8](#fig2-8) shows the operation to build this graph. The left column
    shows the full graph, with the current node being processed indicated by a dashed
    circle, and the right column shows the new subgraph at that point. As noted earlier,
    the subgraph’s nodes use different indices; in this case, we might store the star’s
    name in the node’s label.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解 Bob 和他的共同出演者的出现情况，我们在 Bob（节点 1）周围构建了一个闭邻域子图。这表示了 Bob 曾与之同框的明星，并捕捉了他们之间的互动。[图
    2-8](#fig2-8) 展示了构建此图的操作。左列显示了完整的图，其中当前正在处理的节点由虚线圆圈标示，右列则显示了该时刻的新子图。如前所述，子图的节点使用不同的索引；在这种情况下，我们可能会将明星的名字存储在节点的标签中。
- en: '![Six rows indicating the steps of the neighborhood construction algorithm,
    labeled with letters a through f from top to bottom.](../images/f02008.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![六行显示邻域构建算法步骤，按字母 a 到 f 从上到下标注。](../images/f02008.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-8: The steps to construct
    a closed-neighborhood subgraph around Bob</samp>'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 2-8：围绕 Bob 构建闭邻域子图的步骤</samp>
- en: '[Figure 2-8(a)](#fig2-8) begins by creating a new graph containing just Bob
    and his co-stars. The set of neighbors includes everyone with whom Bob has appeared
    on-screen. Alice is included from their appearance together in the original *Graph
    Theory* film, while the links to stars Fiona and Gwen come from the third, and
    best reviewed, installment in the series.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-8(a)](#fig2-8)首先创建了一个只包含 Bob 和他的共同演员的新图。邻居集合包括了所有与 Bob 同屏的人。Alice 是从他们在原版《Graph
    Theory》电影中的合作中加入的，而与明星 Fiona 和 Gwen 的联系则来自该系列的第三部，也是评价最好的一部。'
- en: The indexing also changes in the new graph. As shown in the figure, three of
    the people are given the same indices (nodes 0, 1, and 2), while two are assigned
    new indices (5 and 6). The node index for Fiona changes from 5 to 3 in the subgraph,
    and from 6 to 4 for Gwen. In [Appendix A](appendix_A.xhtml), we’ll discuss how
    to expand the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> structure
    to use string-based labels, which obviate the need for this index remapping.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 索引在新图中也发生了变化。如图所示，三个人被赋予相同的索引（节点 0、1 和 2），而另外两个人则被分配了新的索引（5 和 6）。Fiona 的节点索引在子图中从
    5 改为 3，Gwen 从 6 改为 4。在[附录 A](appendix_A.xhtml)中，我们将讨论如何扩展 <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    结构，以使用基于字符串的标签，从而无需进行此类索引重映射。
- en: After setting up the new graph, we iterate one by one through the people under
    consideration (Bob and his co-stars) and add new edges to the subgraph. When considering
    node 0 in [Figure 2-8(b)](#fig2-8), we add only one of their two edges, (0, 1).
    This is because both Alice and Bob are being considered. In contrast, Edward (node
    4) was only in the disastrous spin-off attempt *The Golden Vertex* with Alice.
    Since Edward never appeared on-screen with Bob, he is not part of Bob’s neighborhood
    subgraph.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立新图后，我们逐一遍历考虑的人员（Bob 和他的共同演员），并向子图添加新的边。当考虑到[图 2-8(b)](#fig2-8)中的节点 0 时，我们只添加了他们的两个边中的一个（0,
    1）。这是因为 Alice 和 Bob 都被考虑在内。相反，Edward（节点 4）只和 Alice 一起出演过灾难性的衍生剧《The Golden Vertex》。由于
    Edward 从未与 Bob 同屏，他不属于 Bob 的邻域子图。
- en: When we get to Bob, who represents the franchise staple, we add edges to three
    new co-stars in [Figure 2-8(c)](#fig2-8). We do not add an edge back to Alice
    because we have already processed that node and its edges. The code continues
    through Carl in [Figure 2-8(d)](#fig2-8), Fiona in [Figure 2-8(e)](#fig2-8), and
    Gwen in [Figure 2-8(f)](#fig2-8). Since Edward and Dan didn’t co-star with Bob,
    they are not in the list of neighbors and are never considered. The final subgraph
    is shown on the right-hand side of [Figure 2-8(f)](#fig2-8).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理到 Bob，作为该系列的标志性人物时，我们在[图 2-8(c)](#fig2-8)中向三个新的共同演员添加了边。我们没有向 Alice 添加边，因为我们已经处理过该节点及其边。代码继续处理[图
    2-8(d)](#fig2-8)中的 Carl，[图 2-8(e)](#fig2-8)中的 Fiona 和[图 2-8(f)](#fig2-8)中的 Gwen。由于
    Edward 和 Dan 并未与 Bob 同演，他们不在邻域列表中，因此不会被考虑。最终的子图显示在[图 2-8(f)](#fig2-8)的右侧。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">为什么这很重要</samp>
- en: A graph’s neighbors provide fundamental information about the local structure
    and interconnections around a given node. For the most part, the formal definitions
    of these terms are conveniently intuitive. When traversing a graph, we ask which
    nodes are neighbors of the current node and are thus reachable. Neighbors will
    form the basis of our discussion of graph search algorithms in later chapters,
    as many of these algorithms share the core loop of iterating over a node’s edges
    and seeing which other nodes share them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图的邻居提供了关于给定节点周围局部结构和互联信息的基础。大多数情况下，这些术语的正式定义直观且便于理解。当遍历图时，我们会问哪些节点是当前节点的邻居，因此可以到达。邻居将构成我们在后续章节中讨论图搜索算法的基础，因为许多这些算法共享遍历节点边并查看哪些其他节点与之共享的核心循环。
- en: Concepts like a node’s degree and its local clustering coefficient provide concrete
    metrics about its immediate neighbors and neighborhood. These example metrics
    are only a fraction of the multitude of ways to quantify the properties of a graph.
    Numerous metrics have been developed to analyze the properties of real-world graphs,
    from their level of interconnectedness to their width. A comprehensive review
    of all graph metrics is well outside the scope of this book, but upcoming chapters
    discuss some additional analytics.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的度数和局部聚类系数等概念提供了关于其直接邻居和邻域的具体度量。这些示例度量只是量化图属性的众多方式中的一部分。已经开发出大量度量标准来分析现实世界图的属性，从它们的互联程度到它们的宽度。对所有图度量的全面回顾超出了本书的范围，但接下来的章节将讨论一些额外的分析方法。
- en: 'In the next chapter, we consider another foundational graph algorithm concept:
    paths. Paths provide a description of movements throughout the graph and allow
    us to record how to traverse from one node to another.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论另一个基础的图算法概念：路径。路径描述了图中的移动，并允许我们记录如何从一个节点遍历到另一个节点。
