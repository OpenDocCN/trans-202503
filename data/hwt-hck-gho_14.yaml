- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: The Enemy Inside
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 内在的敌人
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In the previous chapter, we took over MXR Ads’ delivery cluster. This yielded
    hundreds of secrets, ranging from AWS access keys to GitHub tokens, promising
    access to pretty much any database involved in the delivery of an ad. We are not
    yet admins of the AWS account, but it’s barely a nudge away. We need to make sense
    of all the data we gathered and use it to find a way to escalate privileges, and
    even perhaps uncover the hidden link between MXR Ads and Gretsch Politico.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们接管了 MXR Ads 的交付集群。这为我们提供了数百个密钥，从 AWS 访问密钥到 GitHub 令牌，几乎可以访问参与广告交付的任何数据库。我们还不是
    AWS 账户的管理员，但离成为管理员只有一步之遥。我们需要整理所有收集到的数据，并利用这些数据找到提升权限的方法，甚至可能揭示 MXR Ads 与 Gretsch
    Politico 之间的隐藏联系。
- en: The Path to Apotheosis
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成神之路
- en: 'We load the AWS access keys we retrieved from Kube and check out the permissions
    of a random user. Kevin from Chapter 8, for instance, is as good a target as any:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们加载了从 Kube 获取的 AWS 访问密钥，并检查了一个随机用户的权限。例如，第 8 章中的 Kevin 就是一个很好的目标：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We know that, by default, IAM users have absolutely zero rights on AWS. They
    cannot even change their own passwords. Companies will therefore almost always
    grant users just enough rights on the IAM service that handles users and permissions
    to perform basic operations like changing passwords, listing policies, enabling
    multifactor authentication, and so on.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，默认情况下，IAM 用户在 AWS 上没有任何权限。他们甚至无法更改自己的密码。因此，公司通常会为用户在处理用户和权限的 IAM 服务上授予足够的权限，以执行基本操作，如更改密码、列出策略、启用多因素认证等。
- en: 'To limit the scope of these permissions, admins will often add a condition
    to accept IAM API calls targeting only the calling user. For example, Kevin is
    probably allowed to list his own permissions, but not those attached to other
    users:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制这些权限的范围，管理员通常会添加条件，要求 IAM API 调用仅针对调用用户。例如，Kevin 可能被允许列出自己的权限，但不能列出其他用户的权限：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Indeed, we get an error as soon as we call an IAM command on a resource other
    than Kevin, like so:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，当我们对 Kevin 以外的资源调用 IAM 命令时，就会出现错误，情况如下：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'AWS runs a tight ship when it comes to access rights. Thankfully, the names
    of Kevin’s policies are explicit enough that we can guess their content: mxrads-eks-admin
    indicates Kevin is admin over the EKS, and mxrads-read-only probably confers Kevin
    read access to a subset of the 165 AWS services used by MXR Ads. It’s just a matter
    of trying to deduce which ones. The last policy, mxrads-self-manage, should contain
    the set of permissions for Kevin to manage his account.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 在访问权限方面严格把控。幸运的是，Kevin 的策略名称足够明确，我们可以猜测它们的内容：mxrads-eks-admin 表明 Kevin 是
    EKS 的管理员，mxrads-read-only 可能赋予 Kevin 只读权限，涉及 MXR Ads 使用的 165 个 AWS 服务中的一部分。现在的问题只是尝试推测具体是哪一部分。最后一个策略，mxrads-self-manage，应该包含
    Kevin 管理其账户的权限集。
- en: 'Each of these services could take hours, even days, to fully explore, especially
    for a company so invested in AWS and with such a complex business architecture.
    We need to keep our focus straight: we’re looking for anything remotely related
    to Gretsch Politico—specifically information on their clients or data profiling
    activity. This might come in the form of an S3 bucket holding *Digital Ad Ratings
    (DAR)* segments (used to measure the performance of an advertising campaign),
    a table on an RDS database, a web server running on EC2, a proxy service on API
    Gateway, a messaging queue on AWS Simple Queue Service (SQS) . . . in any of the
    dozen AWS regions currently available. Yes, I feel and share your frustration.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务可能需要几个小时，甚至几天，才能完全探索，尤其是对于一个如此依赖 AWS 且业务架构复杂的公司。我们需要保持专注：我们在寻找任何与 Gretsch
    Politico 相关的信息——特别是关于他们的客户或数据分析活动的信息。这可能表现为一个存储 *数字广告评级 (DAR)* 段（用于衡量广告活动表现）的
    S3 桶，一个 RDS 数据库上的表格，一个在 EC2 上运行的 Web 服务器，一个在 API Gateway 上的代理服务，一个在 AWS 简单队列服务
    (SQS) 上的消息队列……这些都可能分布在当前可用的多个 AWS 区域中。是的，我理解并与你分享这种挫败感。
- en: 'Luckily, AWS has a useful API that spans multiple resource types and services
    in a given region: the Resource Groups Tagging API. This API returns S3 buckets,
    VPC endpoints, databases, and so on, provided that the object possesses a tag
    or a label. Any company with minimal infrastructure hygiene will make sure to
    tag its resources, if only for billing purposes, so we can be fairly confident
    that the results returned by this API call are accurate and comprehensive. We
    start by listing the resources for the *eu-west-1* region, as shown in [Listing
    10-1](#listing10-1).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，AWS有一个有用的API，跨多个资源类型和服务，适用于给定的区域：资源组标记API。只要对象拥有标签或标识符，该API就会返回S3存储桶、VPC终端节点、数据库等。任何具有最基本基础设施管理的公司都会确保对其资源进行标记，哪怕只是为了计费目的，因此我们可以相当有信心这个API返回的结果是准确且全面的。我们首先列出*eu-west-1*区域的资源，如[列表10-1](#listing10-1)所示。
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 10-1: Listing resources for `eu-west-1`'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10-1：列出`eu-west-1`的资源
- en: Had Kevin lacked the necessary privileges to list resource tags (`tag:GetResources`),
    we would have had no choice but to manually start exploring the most commonly
    used AWS services, such as EC2, S3, Lambda, RDS, DynamoDB, API Gateway, ECR, KMS,
    and Redshift. *Redshift* is a managed PostgreSQL optimized for analytics, *DynamoDB*
    is a managed nonrelational database modeled after MongoDB, *API Gateway* is a
    managed proxy that relays requests to the backend of your choice, and *Lambda*
    is a service that runs your code on AWS’s own instances (more on that later).
    These primitive services are even used by AWS itself internally to build more
    complex offerings like EKS, which is in fact nothing more than the combination
    of EC2, ECR, API Gateway, Lambda, DynamoDB, and other services.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Kevin没有列出资源标签（`tag:GetResources`）的必要权限，我们只能手动开始探索最常用的AWS服务，如EC2、S3、Lambda、RDS、DynamoDB、API
    Gateway、ECR、KMS和Redshift。*Redshift*是一个优化用于分析的托管PostgreSQL，*DynamoDB*是一个托管的非关系型数据库，模仿MongoDB，*API
    Gateway*是一个托管代理，转发请求到你选择的后端，*Lambda*是一个在AWS自己的实例上运行你代码的服务（稍后会详细介绍）。这些基础服务甚至被AWS自身用于构建更复杂的服务，如EKS，实际上它不过是EC2、ECR、API
    Gateway、Lambda、DynamoDB和其他服务的组合。
- en: 'From [Listing 10-1](#listing10-1) we pulled well over 8,000 tagged resources
    from MXR Ads’ account, so naturally we turn to our trusted `grep` command to look
    for references to GP:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从[列表10-1](#listing10-1)中，我们从MXR Ads的账户中提取了超过8,000个标记资源，因此我们自然会转向我们信赖的`grep`命令来查找有关GP的引用：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Marvelous! There’s our hidden needle. MXR Ads has a Lambda function that seems
    to exchange data with Gretsch Politico. AWS Lambda is the gold standard of the
    serverless world. You package Python source code, a Ruby script, or a Go binary
    in a ZIP file, send it to AWS Lambda along with a few environment variables and
    CPU/memory specifications, and AWS runs it for you.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们的隐藏线索在这里。MXR Ads有一个Lambda函数，似乎与Gretsch Politico交换数据。AWS Lambda是无服务器世界中的黄金标准。你将Python源代码、Ruby脚本或Go二进制文件打包成ZIP文件，连同一些环境变量和CPU/内存配置一起发送到AWS
    Lambda，AWS会为你运行它。
- en: The process involves none of the hassle of machine provisioning, systemd setup,
    and SSH. You simply point to a ZIP file and it’s executed at the time of your
    choosing. A Lambda function can even be triggered by external events fired by
    other AWS services, like a file reception on S3\. Lambda is a glorified crontab
    that has changed the way people orchestrate their workloads.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程不涉及机器配置、systemd设置和SSH。你只需指定一个ZIP文件，它会在你选择的时间执行。Lambda函数甚至可以由其他AWS服务触发的外部事件启动，比如S3上的文件接收。Lambda是一个被美化的crontab，改变了人们编排工作负载的方式。
- en: Let’s take a closer look at this `dmp-sync` Lambda function (see [Listing 10-2](#listing10-2)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看一下这个`dmp-sync` Lambda函数（参见[列表10-2](#listing10-2)）。
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 10-2: Description of the `dmp-sync` Lambda function'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10-2：`dmp-sync` Lambda函数的描述
- en: 'We see in [Listing 10-2](#listing10-2) that the Lambda function retrieves the
    compiled code it needs to execute from the S3 path *mxrads-lambdas/dmp-sync-gp*.
    We immediately rush to the keyboard and start typing our next command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[列表10-2](#listing10-2)中看到，Lambda函数从S3路径*mxrads-lambdas/dmp-sync-gp*中获取它需要执行的编译代码。我们立刻冲向键盘，开始输入下一个命令：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But alas, Kevin is not trusted enough to be granted access to this bucket. We
    could build a wall with all the “Access Denied” messages we received over the
    last couple of days.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但遗憾的是，Kevin没有足够的权限来访问这个存储桶。过去几天我们收到的“访问被拒绝”信息多得足以堆成一堵墙。
- en: Instead, we look closer at the Lambda definition and see that it impersonates
    the AWS role `lambda-dmp-sync` and that it relies on a couple of environment variables
    to do its bidding (see [Listing 10-3](#listing10-3)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们更仔细地查看Lambda定义，发现它模拟了AWS角色`lambda-dmp-sync`，并依赖几个环境变量来执行其任务（参见[清单10-3](#listing10-3)）。
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 10-3: Configuration of the `dmp-sync` Lambda function'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 清单10-3：`dmp-sync` Lambda函数的配置
- en: These settings suggest that the code operates on MXR Ads’ logs 1 and maybe hydrates
    them with additional information related to delivery campaigns before sending
    them to Gretsch Politico’s S3 bucket 2.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置表明代码处理的是MXR Ads的日志1，并且可能会在将其发送到Gretsch Politico的S3桶2之前，用与投放活动相关的额外信息填充这些日志。
- en: We figure out that this GP bucket is a foreign bucket because it does not appear
    in our current list of MXR Ads buckets. Needless to say, our current access key
    will be monumentally denied from even listing that foreign bucket, but we know
    for a fact that the role associated with the Lambda (`lambda-dmp-sync`) can. The
    question is, how do we impersonate this role?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现这个GP桶是一个外部桶，因为它不出现在我们当前的MXR Ads桶列表中。不用说，我们当前的访问密钥根本无法列出这个外部桶，但我们知道与Lambda（`lambda-dmp-sync`）相关联的角色可以。问题是，我们如何模拟这个角色呢？
- en: One possible way to impersonate the Lambda role is to go after the GitHub repo
    containing the source code of this Lambda function—assuming we can find an account
    with read/write access. We could then smuggle in a few lines of code to retrieve
    the role’s access keys at runtime and use them to read the bucket’s contents.
    It’s tempting, but that procedure carries significant exposure. Between Slack
    notifications and GitHub emails, the smallest commit could be broadcast to the
    entire tech team. Not exactly ideal.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的方式是通过获取包含此Lambda函数源代码的GitHub仓库来模拟Lambda角色——假设我们能找到一个具有读写权限的账户。然后，我们可以偷偷地将几行代码加入其中，在运行时获取角色的访问密钥，并用它们读取桶中的内容。这很诱人，但该过程存在显著风险。通过Slack通知和GitHub邮件，最小的提交都可能广播给整个技术团队。显然，这并不是理想的选择。
- en: AWS does offer a natural way to impersonate any role through the STS API, but,
    boy, do we need some privileges to call this command. No sensible admin would
    include STS APIs in a read-only policy assigned to developers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: AWS确实提供了一种通过STS API模拟任何角色的自然方式，但，天哪，我们需要一些权限才能调用此命令。没有理智的管理员会将STS API包括在分配给开发人员的只读策略中。
- en: Let’s put a pin in this role impersonation idea and continue exploring other
    AWS services. Surely there is something we can abuse to elevate privileges.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时放下模拟角色的想法，继续探索其他AWS服务。肯定有我们可以利用的服务来提升权限。
- en: Let’s poke around the EC2 service and describe all the running instances (see
    [Listing 10-4](#listing10-4)). Remember how last time we tried this in Chapter
    8 we were constrained to Kubernetes nodes? Thanks to Kevin’s wide read-only policy,
    those chains were unshackled.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下EC2服务，并描述所有运行的实例（参见[清单10-4](#listing10-4)）。还记得我们在第8章尝试时，受限于Kubernetes节点吗？感谢Kevin的广泛只读权限，这些限制已经被解除。
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 10-4: Describing the EC2 instances of `eu-west-1`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 清单10-4：描述`eu-west-1`的EC2实例
- en: We discover close to 2,000 machines in the `eu-west-1` region alone—almost three
    times more servers than the Kubernetes production cluster handles. MXR Ads is
    barely dabbling with Kube; it has yet to migrate the rest of its workloads and
    databases.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现，仅在`eu-west-1`区域就有接近2,000台机器——几乎是Kubernetes生产集群所处理的三倍。MXR Ads几乎没有深入使用Kube；它还没有迁移其余的工作负载和数据库。
- en: From theses 2,000 machines, we need to pick a target. Let’s forget about business
    applications; we learned the hard way that MXR Ads severely locks down its IAM
    roles. We struggled with each access we snatched in the beginning to perform basic
    reconnaissance. No, to achieve complete dominion over AWS, we need to pwn an infrastructure
    management tool.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这2,000台机器中，我们需要选择一个目标。让我们不考虑业务应用程序；我们通过艰难的经验学到，MXR Ads严格限制了其IAM角色。最开始，我们在进行基本侦查时，每次获取访问权限都非常困难。不，若要完全控制AWS，我们需要接管一款基础设施管理工具。
- en: Automation Tool Takeover
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化工具接管
- en: Even with all the automation AWS offers, no team could handle 2,000 servers
    and hundreds of microservices without the help of an extensive toolset to schedule,
    automate, and standardize operations. We’re looking for something like Rundeck,
    Chef, Jenkins, Ansible, Terraform, TravisCI, or any one of the hundreds of DevOps
    tools.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有 AWS 提供的所有自动化工具，没有一支团队能够在没有广泛工具集的帮助下管理 2000 台服务器和数百个微服务，而这些工具集需要调度、自动化和标准化操作。我们正在寻找像
    Rundeck、Chef、Jenkins、Ansible、Terraform、TravisCI 或任何其他数百种 DevOps 工具中的某一个。
- en: 'Terraform helps keep track of the components running on AWS, Ansible configures
    servers and installs the required packages, Rundeck schedules maintenance jobs
    across databases, and Jenkins builds applications and deploys them to production.
    The bigger a company scales, the more it needs a solid set of tools and standards
    to support and fuel that growth. We loop through the list of running machines
    looking for tool names:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 帮助追踪在 AWS 上运行的组件，Ansible 配置服务器并安装所需的软件包，Rundeck 在数据库之间调度维护任务，而 Jenkins
    则构建应用程序并将其部署到生产环境中。随着公司规模的扩大，它需要一套稳固的工具和标准来支持和推动这种增长。我们正在浏览运行机器的列表，寻找工具名称：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Wonderful! We get hits for Jenkins and Chef. Let’s focus on these two components,
    as they have great potential.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们找到了关于 Jenkins 和 Chef 的信息。让我们聚焦这两个组件，因为它们具有巨大的潜力。
- en: Jenkins Almighty
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jenkins 万能
- en: Jenkins is a complex piece of software that can take on many roles. Developers,
    for instance, can use it to compile, test, and release their code in an automated
    fashion. For this purpose, when a new file is pushed to a repo, GitHub triggers
    a POST request (webhook) to Jenkins, which runs end-to-end tests on the newly
    pushed version of the application. Once the code is merged, Jenkins automatically
    triggers another job that deploys the code on the production servers. This process
    is commonly known as *continuous* *integration/continuous delivery (CI/CD)*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 是一款复杂的软件，可以承担多种角色。例如，开发者可以使用它以自动化方式编译、测试和发布他们的代码。为此，当一个新文件被推送到仓库时，GitHub
    会触发一个 POST 请求（webhook）到 Jenkins，后者会对新推送的应用版本进行端到端测试。一旦代码合并，Jenkins 会自动触发另一个作业，将代码部署到生产服务器。这一过程通常被称为*持续*
    *集成/持续交付 (CI/CD)*。
- en: Admins, on the other hand, can use it to run certain infrastructure tasks, like
    creating Kubernetes resources or spawning a new machine on AWS. Data scientists
    may schedule their workloads to pull data from a database, transform it, and push
    it to S3\. The use cases abound in the enterprise world and are limited only by
    the imagination (and sometimes sobriety) of the DevOps folks.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，管理员可以用它来执行某些基础设施任务，如创建 Kubernetes 资源或在 AWS 上生成新机器。数据科学家可能会安排他们的工作负载，从数据库中提取数据，进行转换，然后推送到
    S3。企业界的使用场景非常丰富，只受 DevOps 从业人员的想象力（有时也受限于清醒程度）限制。
- en: Tools like Jenkins are literally the agents that enable and empower the utopian
    ideas blatantly pushed forward by the DevOps philosophy. Indeed, it would be next
    to impossible for every company to implement from scratch something as complex
    as continuous testing and delivery. The almost pathological obsession with automating
    every tiny operation promotes tools like Jenkins from simple testing frameworks
    to the almighty gods of any infrastructure.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Jenkins 这样的工具，实际上是推动并实现 DevOps 思想中那些理想化的理念的代理。的确，对于每家公司来说，从零开始实现像持续测试和交付这样复杂的系统几乎是不可能的。对每一个细小操作的近乎病态的自动化痴迷，使得像
    Jenkins 这样的工具从简单的测试框架，逐渐发展成任何基础设施中的至高神明。
- en: Since Jenkins needs to dynamically test and build applications, there’ll often
    be a GitHub token sitting somewhere on disk. It also needs to deploy applications
    and containers to production, so an admin will often add in AWS access keys with
    ECR, EC2, and possibly S3 write access to the Jenkins config file. Admins also
    want to leverage Jenkins to run their Terraform commands, and Terraform has, by
    design, complete control over AWS. Now so does Jenkins. And since Terraform is
    managed by Jenkins jobs, why not add in Kubernetes commands as well to centralize
    operations? Grab those cluster admin privileges, will you? Jenkins needs them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Jenkins 需要动态地测试和构建应用程序，因此通常会有一个 GitHub token 存储在某个磁盘位置。它还需要将应用程序和容器部署到生产环境中，因此管理员通常会将包含
    ECR、EC2 以及可能的 S3 写权限的 AWS 访问密钥添加到 Jenkins 配置文件中。管理员还希望利用 Jenkins 执行 Terraform
    命令，而 Terraform 本身完全控制 AWS。现在，Jenkins 也拥有这种控制权。而且由于 Terraform 是由 Jenkins 作业管理的，为什么不将
    Kubernetes 命令也添加进去，以便集中管理操作呢？来吧，给我获取那些集群管理员权限，Jenkins 需要它们。
- en: When not monitored closely, these CI/CD pipelines—Jenkins, in this case—can
    quickly develop into the intersection of a complex network of infrastructure nerve
    fibers that, if stroked gently and knowingly, could lead to ecstasy—and that’s
    exactly what we’re going to do.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有密切监控，这些 CI/CD 管道——在这种情况下是 Jenkins——很快就会发展成复杂网络的交汇点，基础设施神经纤维的交织处，如果被轻柔而熟练地刺激，可能会导致狂喜——而这正是我们要做的。
- en: 'We candidly try reaching Jenkins directly with no authentication. Jenkins listens
    by default on port 8080, so we use our existing meterpreter shell to issue an
    HTTP query to the server:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们坦率地尝试直接访问 Jenkins 而不进行身份验证。Jenkins 默认监听在 8080 端口，所以我们使用现有的 meterpreter shell
    向服务器发出 HTTP 查询：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We get turned down immediately. It’s only normal, after all, that any half
    decent company that relies on such a critical component for delivery puts minimal
    protection in place. The way to Jenkins is not through the front door but rather
    through a small crack in the alley window: the Chef server that probably helped
    set up Jenkins in the first place.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会立即被拒绝。这完全正常，毕竟，任何依赖这种关键组件进行交付的合格公司都会采取最低限度的保护措施。通往 Jenkins 的道路并不是从正门，而是通过小巷窗口中的一个小缝隙：那个可能最初帮助设置
    Jenkins 的 Chef 服务器。
- en: Hell’s Kitchen
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 地狱厨房
- en: Chef, just like Ansible, is a software configuration tool. You enroll a newly
    installed machine into Chef, and it pulls and executes a set of predefined instructions
    that set up tools on your machine automatically. If your machine is a web app,
    for instance, Chef will install Nginx, set up a MySQL client, copy the SSH configuration
    file, add an admin user, and add any other specified software that’s needed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Chef，像 Ansible 一样，是一个软件配置工具。你将一台新安装的机器注册到 Chef，然后它会拉取并执行一组预定义的指令，自动设置机器上的工具。例如，如果你的机器是一个
    web 应用，Chef 会安装 Nginx，设置 MySQL 客户端，复制 SSH 配置文件，添加管理员用户，并安装任何其他所需的软件。
- en: The configuration instructions are written in Ruby and grouped into what Chef
    calls—in an elaborate conceit—cookbooks and recipes. [Listing 10-5](#listing10-5)
    is an example of a Chef recipe that creates a config.json file and adds a user
    to the *docker* group.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 配置指令用 Ruby 编写，并按 Chef 的说法分组为所谓的 cookbook 和 recipe。[列表 10-5](#listing10-5) 是一个
    Chef 配方的例子，它创建了一个 config.json 文件并将用户添加到 *docker* 组。
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 10-5: A Chef recipe that creates a *config.json* file and adds a user
    to the *docker* group'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-5：一个 Chef 配方，它创建一个 *config.json* 文件并将用户添加到 *docker* 组
- en: Secrets and passwords are a crucial element of any server’s configuration—especially
    one that, by the very nature of its design, talks to almost every component of
    the infrastructure. I am talking about Jenkins, of course!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 密码和密钥是任何服务器配置中的关键元素——尤其是像 Jenkins 这样，由于其设计的性质，几乎与基础设施的每个组件都有交互的服务器。没错，我说的就是
    Jenkins！
- en: If you follow good DevOps practices to the letter, everything should be automated,
    reproducible, and, more importantly, versioned. You can’t just install Jenkins
    or any other tool by hand. You must use a management tool, like Chef or Ansible,
    to describe your Jenkins configuration and deploy it on a brand-new machine. Any
    change to this configuration, like upgrading a plug-in or adding a user, should
    go through this management tool, which tracks, versions, and tests the changes
    before applying them to production. That’s the essence of infrastructure as code.
    What’s a developer’s favorite versioning system for storing code? GitHub, of course!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你严格遵循良好的 DevOps 实践，一切都应该是自动化的、可重复的，更重要的是，有版本控制。你不能手动安装 Jenkins 或任何其他工具。你必须使用像
    Chef 或 Ansible 这样的管理工具来描述你的 Jenkins 配置，并将其部署到一台全新的机器上。对这个配置的任何更改，比如升级插件或添加用户，都应该通过这个管理工具，它会跟踪、版本控制并测试这些更改，然后再将其应用到生产环境中。这就是基础设施即代码的本质。开发人员最喜欢的代码版本控制系统是什么？当然是
    GitHub！
- en: 'We can quickly verify that Chef recipes are stored on GitHub for this task
    by listing all of MXR Ads’ private repos and looking for any mention of Jenkins-related
    Chef cookbooks. Remember, we already have a valid GitHub token courtesy of Kubernetes.
    We first extract the list of repos:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过列出 MXR Ads 的所有私有仓库，并查找任何提到 Jenkins 相关的 Chef cookbook，快速验证 Chef 配方是否存储在
    GitHub 上以供此任务使用。记住，我们已经有一个有效的 GitHub token，得益于 Kubernetes。我们首先提取仓库列表：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We then search for references to keywords such as *cookbook*, *Jenkins*, *Chef*,
    *recipe*, and so forth (see [Listing 10-6](#listing10-6)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们搜索 *cookbook*、*Jenkins*、*Chef*、*recipe* 等关键字的引用（见 [列表 10-6](#listing10-6)）。
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 10-6: A list of MXR Ads’ repos matching at least one of the keywords
    *cookbook*, *Jenkins*, and *Chef*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10-6：符合至少一个关键字*cookbook*、*Jenkins*和*Chef*的MXR Ads仓库列表
- en: 'Bingo 1! We download the cookbook-mxrads-jenkins-ci repo:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 命中 1！我们下载了cookbook-mxrads-jenkins-ci仓库：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And then we go through the source code hoping to find some hardcoded credentials:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过源代码，希望找到一些硬编码的凭据：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We find that close to 50 secrets are defined in a file conveniently called
    *secrets.rb*, but don’t get excited just yet. These are no mere cleartext passwords.
    They all start with the six magic letters `AQICAH`, which suggests they use AWS
    KMS, a key management service provided by AWS to encrypt/decrypt data at rest.
    Access to their decryption key requires specific IAM rights, which our user Kevin
    most likely lacks. The README file of the cookbook is pretty clear about secret
    management:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现，约有50个密钥在一个方便的文件*secrets.rb*中定义，但不要急于兴奋。这些可不是普通的明文密码。它们的开头都以六个魔法字母`AQICAH`开头，这表明它们使用了AWS
    KMS，这是AWS提供的密钥管理服务，用于加密/解密静态数据。访问它们的解密密钥需要特定的IAM权限，而我们的用户Kevin很可能没有这些权限。该cookbook的README文件对密钥管理有明确说明：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The one keyword I love in that sentence is “now.” This suggests that not so
    long ago secrets were handled differently, probably not encrypted at all. We take
    a look at the Git commit history:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的那个句子中的关键字是“现在”。这表明不久前，密钥的处理方式可能与现在不同，可能根本没有加密。我们查看了Git提交历史：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Someone must have properly cleaned it up. All previous versions of *secrets.rb*
    contain the same encrypted data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一定有人对它进行了彻底清理。所有之前版本的*secrets.rb*都包含相同的加密数据。
- en: That’s okay. GitHub is not the only versioned repository to store cookbooks.
    Chef has its own local datastore where it keeps different versions of its resources.
    With some luck, maybe we can download an earlier version of the cookbook that
    contained cleartext credentials.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 没关系。GitHub并不是唯一一个存储cookbooks的版本化仓库。Chef有自己的本地数据存储库，用于存储其资源的不同版本。运气好的话，也许我们可以下载一个包含明文凭据的早期版本的cookbook。
- en: Communication with the Chef server is usually well protected. Each server managed
    by Chef gets a dedicated private key to download cookbooks, policies, and other
    resources. Admins may also use an API token to perform tasks remotely.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与Chef服务器的通信通常是经过充分保护的。每台由Chef管理的服务器都会获得一个专用的私钥，用于下载cookbooks、策略和其他资源。管理员还可以使用API令牌来执行远程任务。
- en: The silver lining, however, is that there is no segregation between resources.
    All we need is a valid private key, belonging to a dummy test server for all we
    care, to be able to read every cookbook file ever stored on Chef. What’s life
    without trust!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得庆幸的是，资源之间没有隔离。我们所需要的只是一个有效的私钥，哪怕是属于某个虚拟测试服务器的私钥，也能读取Chef上曾存储过的每个cookbook文件。生活不就是信任吗！
- en: That private key should not be too hard to find. We have read access to the
    EC2 API, spanning around 2,000 servers. Surely one of them has a hardcoded Chef
    private key in its user data. We just need to perform 2,000 API calls.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那个私钥应该不难找到。我们可以读取EC2 API，涉及约2,000台服务器。肯定有一台服务器的用户数据中硬编码了Chef私钥。我们只需要执行2,000次API调用。
- en: 'What may seem like a daunting and fastidious task at first can actually be
    easily automated. Thanks to the cookbooks stored in MXR Ads’ GitHub repos, we
    already know which services rely on Chef: Cassandra (NoSQL database), Kafka (streaming
    software), Jenkins, Nexus (code repository), Grafana (dashboards and metrics),
    and a few more.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 起初看似繁琐且细致的任务其实可以轻松自动化。多亏了存储在MXR Ads GitHub仓库中的cookbooks，我们已经知道哪些服务依赖于Chef：Cassandra（NoSQL数据库）、Kafka（流处理软件）、Jenkins、Nexus（代码仓库）、Grafana（仪表板和度量）等。
- en: 'We store these service names as keywords in a file and then feed them to a
    loop that retrieves the instances bearing a tag name matching the keyword, as
    shown next. We extract the first instance ID of every pool of machines belonging
    to the same service since, for example, all Cassandra machines will probably share
    the same user data, so we only need one instance:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些服务名称作为关键字存储在文件中，然后将它们输入到一个循环中，从中获取带有匹配关键字标签名称的实例，如下所示。我们提取每个机器池中每个服务的第一个实例ID，因为例如，所有Cassandra机器可能共享相同的用户数据，所以我们只需要一个实例：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This rather improvised sampling method gives us about 20 instance IDs, each
    referring to a machine hosting a different service:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种相对临时的采样方法让我们得到了大约20个实例ID，每个ID对应一台承载不同服务的机器：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We loop through this file calling the `ec2 describe-instance-attribute` API
    to fetch the user data, decode it, and store it in a file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们循环遍历这个文件，调用`ec2 describe-instance-attribute` API来获取用户数据，解码并将其存储到文件中：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We check to see how many files were created and confirm the files contain user
    data scripts:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查创建了多少个文件，并确认这些文件包含用户数据脚本：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Perfect. Now for the moment of truth. Do any of these fine servers have a Chef
    private key declared in their user data? We look for the “RSA PRIVATE KEY” keywords:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。现在到了关键时刻。这些出色的服务器中有哪一台在其用户数据中声明了 Chef 私钥？我们寻找“RSA PRIVATE KEY”关键字：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It’s almost too easy. The first snippet of code defines key parameters used
    by Chef and stores them in the *client.rb* file. The second snippet writes a private
    key to a file called *validation.pem*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎太简单了。第一段代码定义了 Chef 使用的关键参数，并将其存储在 *client.rb* 文件中。第二段代码将私钥写入名为 *validation.pem*
    的文件。
- en: This private key is different from the one we were hoping for, but we will make
    it work. The key we obtained is a validation key, the private key of the *chef-validator*
    user assigned to instances to establish their first contact with the Chef server.
    The *chef-validator* is not allowed to list machines, cookbooks, or other sensitive
    operations, but it has the ultimate power of registering clients (machines), which
    in the end grants them private keys that can perform said operations. All’s well
    that ends well.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个私钥与我们希望获得的不同，但我们会让它发挥作用。我们获得的密钥是一个验证密钥，它是 *chef-validator* 用户的私钥，分配给实例以建立它们与
    Chef 服务器的第一次联系。*chef-validator* 不允许列出机器、食谱或执行其他敏感操作，但它拥有注册客户端（机器）的最终权限，最终授予它们可以执行上述操作的私钥。事事顺利，最终大功告成。
- en: This user’s private key is shared among all instances wishing to join the Chef
    server. So, naturally, we can also use it to register an additional machine and
    receive our very own private key. We just have to mimic a real client configuration
    and nicely ask the Chef server from within the VPC.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用户的私钥在所有希望加入 Chef 服务器的实例之间共享。所以，自然地，我们也可以使用它注册一台额外的机器，并获得我们自己的私钥。我们只需要模拟一个真实的客户端配置，并在
    VPC 内部向 Chef 服务器请求。
- en: 'We create the required files to initiate a machine registration—*client.rb*
    1 and *validation.pem* 2—and populate them with the data harvested from the user
    data script, as shown next. This is just lazy copy-pasting, really:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建所需的文件来启动机器注册——*client.rb* 1 和 *validation.pem* 2——并将从用户数据脚本中收集到的数据填充到这些文件中，如下所示。这只是懒惰的复制粘贴而已：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We then download and execute the Chef client from within our backdoor to initiate
    the registration process of our machine:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从我们的后门中下载并执行 Chef 客户端，启动我们的机器注册过程：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That’s it. We are done. We smuggled a new machine into the Chef server’s catalog
    and received a new private key called *client.pem*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们完成了。我们偷偷将一台新机器加入了 Chef 服务器的目录，并收到了一个名为 *client.pem* 的新私钥。
- en: 'The `chef-client` executable handles the state of the machine, including applying
    the relevant cookbook, registering the machine, and more. To explore the resources
    defined on the Chef server, we need to use the `knife` utility. This is part of
    the Chef standard package, but it needs a small configuration file to run properly.
    Here’s a sample config file, based on the output of the `chef-client` command
    executed earlier (to retrieve the machine’s name) and the *client.rb* configuration:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`chef-client` 可执行文件负责处理机器的状态，包括应用相关的食谱、注册机器等。为了探索在 Chef 服务器上定义的资源，我们需要使用 `knife`
    工具。它是 Chef 标准包的一部分，但需要一个小的配置文件才能正常运行。下面是一个配置文件示例，基于之前执行的 `chef-client` 命令的输出（用来获取机器的名称）和
    *client.rb* 配置：'
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With `knife` configured, let’s use it to list the Chef server’s cookbook catalog:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好 `knife` 后，让我们使用它列出 Chef 服务器的食谱目录：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Fantastic, there is our dear jenkins-ci cookbook. Let’s take a closer look
    at the version history of that cookbook:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们亲爱的 jenkins-ci 食谱就在这里。让我们仔细看看这个食谱的版本历史：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can see that the sneaky Chef server is keeping more than 50 versions of this
    cookbook, from 10.9.5 all the way down to 3.9.1\. Now we need to find the most
    recent cookbook with cleartext credentials—ideally, right before the switch to
    KMS.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，狡猾的 Chef 服务器保存了超过 50 个版本的食谱，从 10.9.5 一直到 3.9.1。现在，我们需要找到带有明文凭证的最新食谱——理想情况下，是在切换到
    KMS 之前的版本。
- en: 'We start checking different versions, beginning with the latest ones, and after
    a few attempts we land on cookbook version 10.8.6:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始检查不同的版本，从最新版本开始，经过几次尝试后，我们最终找到了 10.8.6 版本的食谱：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Holy cow, we have it! Jenkins’s own AWS access keys in cleartext 1. If this
    little baby is not admin of the AWS account, I don’t know who is.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我的天，我们找到了！Jenkins 自己的 AWS 访问密钥以明文形式存储1。如果这个小家伙不是 AWS 账户的管理员，那我真不知道谁能是了。
- en: In [Listing 10-7](#listing10-7), we chain a couple of AWS API calls to get the
    IAM username associated with these credentials, its attached policies, their latest
    versions, and finally their content.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表10-7](#listing10-7)中，我们通过链式调用几个AWS API来获取与这些凭证关联的IAM用户名、其附加的策略、最新版本，最后是它们的内容。
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 10-7: Retrieving access rights granted to the Jenkins account'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10-7：获取授予Jenkins账户的访问权限
- en: Look at all those stars in the policy output. Stars. Stars everywhere. Literally.
    Jenkins has access to every AWS service used by MXR Ads, from IAM to Lambda and
    more. We finally have total and undisputed control over MXR Ads’ AWS account.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 看看策略输出中的所有星号。星星。到处都是星星。真的是。Jenkins可以访问MXR Ads使用的每一个AWS服务，从IAM到Lambda以及更多。我们终于对MXR
    Ads的AWS账户拥有了完全且无可争议的控制权。
- en: Taking Over Lambda
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接管Lambda
- en: 'We loop back to our initial goal that sparked this tangent adventure: impersonating
    the IAM role attached to the Lambda function `dmp-sync`, which copies data over
    to Gretsch Politico.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回到最初激发这个冒险的目标：假扮附加到Lambda函数`dmp-sync`的IAM角色，它将数据复制到Gretsch Politico。
- en: Now that we have unlimited access to the IAM service, let’s explore this Lambda’s
    role (see [Listing 10-8](#listing10-8)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们拥有了对IAM服务的无限访问权限，让我们来探索这个Lambda的角色（见[列表10-8](#listing10-8)）。
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 10-8: The IAM role policy of the `lambda-dmp-sync` role'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10-8：`lambda-dmp-sync`角色的IAM角色策略
- en: The `AssumeRolePolicyDocument` property designates which entity is allowed to
    impersonate a given role. Notice that the only entity trusted to assume this role
    is the AWS Lambda service itself ([lambda.amazonaws.com](http://lambda.amazonaws.com)).
    To properly impersonate this role, we need to register a new Lambda, assign it
    this new role, and execute whatever code we like. Alternatively, we could update
    the current Lambda’s code to do our bidding.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssumeRolePolicyDocument`属性指定了哪些实体被允许假扮给定角色。请注意，唯一被信任来假扮此角色的实体是AWS Lambda服务本身（[lambda.amazonaws.com](http://lambda.amazonaws.com)）。为了正确地假扮这个角色，我们需要注册一个新的Lambda，将其分配给这个新角色，并执行我们喜欢的任何代码。或者，我们也可以更新当前Lambda的代码来执行我们的命令。'
- en: A third option, and probably the easiest option, is to temporarily update the
    role’s policy to include the Jenkins user. This change cannot linger, as anyone
    executing a `terraform plan` in that precise window of time would notice the extra
    account and might raise an eyebrow or two. Therefore, we need to be swift. We’ll
    alter the “assume role” policy, generate temporary credentials that last 12 hours,
    and revert back to the original policy. In and out in less than a second.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种选择，可能是最简单的一种选择，就是临时更新角色的策略，将Jenkins用户包括在内。这个变更不能持续太久，因为在这个特定时间窗口内执行`terraform
    plan`的任何人都会注意到额外的账户，可能会引起一些怀疑。因此，我们需要迅速行动。我们将修改“假设角色”策略，生成有效期为12小时的临时凭证，然后恢复原始策略。完成所有操作的时间不到一秒钟。
- en: 'In [Listing 10-9](#listing10-9), we save the current role policy in a file
    and sneak in the line `"AWS": "arn:aws:iam::886371554408:user/jenkins"` to add
    Jenkins as a trusted user.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '在[列表10-9](#listing10-9)中，我们将当前角色策略保存到一个文件，并偷偷插入一行`"AWS": "arn:aws:iam::886371554408:user/jenkins"`，以便将Jenkins添加为受信任的用户。'
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 10-9: An IAM role policy to allow Jenkins to impersonate the IAM role
    used by the Lambda'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10-9：允许Jenkins假扮Lambda所用IAM角色的IAM角色策略
- en: 'We submit this new role policy and quickly issue the `assume-role` API call
    to get the temporary credentials to impersonate the `lambda-dmp-sync` role:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提交这个新角色策略，并迅速发出`assume-role` API调用，获取临时凭证来假扮`lambda-dmp-sync`角色：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Good. These temporary credentials will stay valid for 12 hours, even though
    Jenkins is no longer in the trust policy. Finally, we restore the original policy
    to avoid any suspicion:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。这些临时凭证将在12小时内有效，即使Jenkins不再在信任策略中。最后，我们恢复原始策略，以避免任何怀疑：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We load the new keys into our AWS CLI and proceed to explore Gretsch Politico’s
    bucket, gretsch-streaming-jobs ([Listing 10-10](#listing10-10)). This is the same
    one used by the `dmp-sync` Lambda, as we discovered earlier in the chapter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将新密钥加载到AWS CLI中，继续探索Gretsch Politico的桶gretsch-streaming-jobs（[列表10-10](#listing10-10)）。这就是前面章节中提到的`dmp-sync`
    Lambda使用的桶。
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 10-10: A list of objects stored in the gretsch-streaming-jobs bucket'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10-10：gretsch-streaming-jobs桶中存储的对象列表
- en: MXR Ads seems to be giving away bid responses to GP, which tells them which
    video was displayed to a given cookie ID on a given website. There are also other
    key metrics that, oddly enough, many companies would consider sensitive material,
    such as raw logs of every bid request, campaign data of other clients . . . the
    list goes on.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: MXR广告似乎在向GP提供竞标响应，这些响应告诉他们在某个网站上、给定的cookie ID上展示了哪个视频。还有其他一些关键指标，奇怪的是，许多公司会认为这些是敏感材料，例如每个竞标请求的原始日志，其他客户的活动数据……列表还在继续。
- en: The gretsch-streaming-jobs bucket is truly huge. It contains terabytes of raw
    data that we simply cannot process, nor do we wish to. GP is better equipped to
    do that. We’d better follow this trail of breadcrumbs and hope it leads us to
    the final cake.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: gretsch-streaming-jobs存储桶真的是巨大的。它包含了数以TB计的原始数据，而我们根本无法处理这些数据，也不愿意去处理。GP更适合做这类事情。我们最好沿着这条面包屑线索走下去，希望它能把我们带到最终的“蛋糕”。
- en: 'Amid this gigantic data lake, hidden under the all-too-tempting `helpers` key,
    we find some curious executables that were altered only a couple of weeks ago:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个巨大的数据湖中，隐藏在诱人的`helpers`键下，我们发现了一些在几周前才被修改过的有趣可执行文件：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Interesting. Here we have executable objects that are likely executed on machines
    owned and operated by GP. This could very well be our ticket inside Gretsch Politico’s
    AWS account. Our Lambda role can, by definition, write to the gretsch-streaming-jobs
    bucket. The question is, was GP savvy enough to solely restrict the Lambda to
    the `rtb-bid-resp` subkeys? Let’s test it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣。在这里，我们发现了一些可执行对象，很可能在GP拥有并操作的机器上执行。这可能正是我们进入Gretsch Politico的AWS账户的钥匙。根据定义，我们的Lambda角色可以写入gretsch-streaming-jobs存储桶。问题是，GP是否足够聪明，只将Lambda限制在`rtb-bid-resp`子键上？让我们来测试一下：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: No errors. Consider it an invitation to cross the border, folks! These helper
    scripts are probably fetched and executed by a GP resource. If we alter them,
    we can hijack the execution flow and call our custom stager, granting us a new
    shell on a GP component!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 没有错误。就当是邀请我们越过边界吧，伙计们！这些助手脚本很可能是由GP的资源提取并执行的。如果我们修改它们，就可以劫持执行流程，调用我们自己的自定义stager，从而在GP组件上获得一个新的shell！
- en: 'We download *helpers/ecr-login.sh*, append a command to execute our custom
    meterpreter stager, and resubmit the file. As usual, the stager will be hosted
    in yet another fake bucket in our own AWS account, gretsch-helpers:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下载*helpers/ecr-login.sh*，附加一个命令来执行我们的自定义meterpreter stager，然后重新提交该文件。像往常一样，这个stager将托管在我们自己AWS账户中的另一个假存储桶gretsch-helpers中：
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: And now we wait. We wait for a few hours. We wait until someone, somewhere,
    triggers our payload, if ever. After all, we have no guarantee that the *ecr-login*
    helper is indeed used. We didn’t even bother checking what it really did. Anyway,
    it’s too late now. Let’s cross our fingers and hope for the best.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们等待。我们等上几个小时，等待某个地方、某个人触发我们的有效载荷，如果它真的会被触发的话。毕竟，我们无法保证*ecr-login*助手确实被使用了。我们甚至没有费心去检查它到底做了什么。无论如何，现在已经太晚了。让我们祈祷一切顺利吧。
- en: Resources
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源
- en: The documentation for AWS STS is at [https://amzn.to/38j05GM](https://amzn.to/38j05GM).
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS STS的文档可以在[https://amzn.to/38j05GM](https://amzn.to/38j05GM)找到。
- en: 'For more on the power of AWS Lambda, see the talk “Kubernetes and the Path
    to Serverless” by Kelsey Hightower (Google staff), shown at KubeCon 2018: [http://bit.ly/2RtothP](http://bit.ly/2RtothP)*.*
    (Yes, you read that right—he works at Google.)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于AWS Lambda的强大功能，请参见Kelsey Hightower（Google员工）在KubeCon 2018上展示的演讲《Kubernetes
    and the Path to Serverless》：[http://bit.ly/2RtothP](http://bit.ly/2RtothP)*.*（没错，你没看错——他在Google工作。）
