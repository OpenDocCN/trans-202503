- en: '**14'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**14'
- en: PIVOTING AND PRIVILEGE ESCALATION**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**旋转与权限提升**'
- en: '*What I cannot create, I do not understand.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*我无法创造的，我无法理解。*'
- en: –Richard Feynman
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: –理查德·费曼
- en: '![image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: By this point in the book, we’ve explored many ways of compromising a single
    machine. But attackers often want full control of the entire private network they’re
    targeting. With full control of the network, the attacker can move freely from
    machine to machine, extracting information and implanting malware as they please.
    Moreover, once the attacker has control of the network, removing them can be very
    difficult because they could be hiding anywhere. In this chapter we’ll explore
    two techniques for moving through the network.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中我们已经探索了多种妥协单一机器的方法。但是攻击者通常希望完全控制他们所针对的整个私有网络。通过完全控制网络，攻击者可以在机器之间自由移动，提取信息并植入恶意软件。此外，一旦攻击者控制了网络，想要将其移除将变得非常困难，因为他们可能隐藏在任何地方。在本章中，我们将探索两种在网络中移动的技术。
- en: First, you’ll learn a pivoting technique that attackers can use to gain access
    to a private network by routing traffic through a dual-homed machine with access
    to both a public network and private network. Second, we’ll extract user credentials
    from a machine’s memory using a privilege escalation attack. In some cases, we
    can use the stolen credentials to log in to another machine on the private network.
    Using stolen credentials is one of the best ways an attacker can move around in
    a network.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将学习一种旋转技术，攻击者可以通过将流量路由通过一台既连接公有网络又连接私有网络的双网卡设备，从而访问私有网络。其次，我们将使用权限提升攻击从机器的内存中提取用户凭据。在某些情况下，我们可以使用窃取的凭据登录到私有网络中的另一台机器。使用窃取的凭据是攻击者在网络中自由移动的最佳方式之一。
- en: '**Pivoting from a Dual-Homed Device**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**从双网卡设备进行旋转**'
- en: We often refer to networks that are open to anyone as public networks. For example,
    the internet is a public network. On the other hand, networks that are closed
    to the public, such as a network inside an organization, are called private networks.
    However, users on a private network will often need access to resources on a public
    network such as the internet. For example, employees in a corporation still need
    access to Google. Thus, companies often use firewalls to safely bridge the public
    network (the internet) and the private, corporate network. Because the firewall
    is connected to both the public and private networks, we refer to the machine
    running the firewall as a *dual-homed device*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常将任何对所有人开放的网络称为公有网络。例如，互联网就是一个公有网络。另一方面，向公众关闭的网络，例如组织内部的网络，被称为私有网络。然而，私有网络上的用户通常需要访问公有网络上的资源，比如互联网。例如，公司的员工仍然需要访问谷歌。因此，公司通常使用防火墙来安全地桥接公有网络（互联网）和私有公司网络。由于防火墙连接着公有和私有网络，我们将运行防火墙的机器称为*双网卡设备*。
- en: Dual-homed devices are critical for attackers because most attackers on a public
    network who hope to access an organization’s private network must pass through
    this firewall. Routing traffic through a dual-homed machine to gain access to
    a network is a technique called *pivoting*. Let’s set up a test network to demonstrate
    pivoting. We’ll compromise the Metasploitable virtual machine, which we’ll configure
    as a dual-homed device, and use it as a proxy to access the private network to
    attack an Ubuntu virtual machine.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 双网卡设备对攻击者至关重要，因为大多数希望访问组织私有网络的公有网络上的攻击者必须通过这个防火墙。通过双网卡设备路由流量以访问网络的技术被称为*旋转*。让我们设置一个测试网络来演示旋转。我们将妥协Metasploitable虚拟机，并将其配置为双网卡设备，使用它作为代理来访问私有网络，并攻击一台Ubuntu虚拟机。
- en: '***Configuring a Dual-Homed Device***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置双网卡设备***'
- en: The pfSense machine in our virtual environment is an example of a dualhomed
    device because it acts as a bridge between our private network and the public
    internet. However, we don’t want to compromise our pfSense machine in our pivoting
    demonstration; it protects our devices from being attacked by real attackers on
    the internet. Instead, we’ll convert the Metasploitable virtual machine into a
    dual-homed device and attach it to another private network containing an Ubuntu
    virtual machine. [Figure 14-1](ch14.xhtml#ch14fig1) depicts the network we’ll
    be attacking.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们虚拟环境中的 pfSense 机器是一个双网卡设备的例子，因为它充当了我们的私人网络和公共互联网之间的桥梁。然而，我们不希望在我们的横向渗透演示中妥协
    pfSense 机器；它保护我们的设备免受互联网上真正攻击者的攻击。相反，我们将把 Metasploitable 虚拟机转换为一个双网卡设备，并将其连接到另一个包含
    Ubuntu 虚拟机的私人网络。[图 14-1](ch14.xhtml#ch14fig1) 展示了我们将要攻击的网络。
- en: '![image](../images/ch14fig01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch14fig01.jpg)'
- en: '*Figure 14-1: An overview of the network*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-1：网络概述*'
- en: The Metasploitable server’s primary interface is denoted at ➊. This is the interface
    we’ll connect to our simulated public network containing the Kali Linux virtual
    machine. The second interface ➋ is connected to the private network. Our goal
    will be to compromise the Metasploitable server and use it to route traffic from
    the primary interface to the private network on the secondary interface. But first,
    we must set up the virtual environment.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploitable 服务器的主接口在 ➊ 处表示。这是我们将连接到包含 Kali Linux 虚拟机的模拟公共网络的接口。第二个接口 ➋ 连接到私人网络。我们的目标是利用
    Metasploitable 服务器并通过它将流量从主接口路由到第二个接口上的私人网络。但首先，我们必须设置虚拟环境。
- en: We’ll begin by enabling the second interface on the Metasploitable virtual machine
    and then connecting it to a private network. To do this, navigate to Metasploitable’s
    settings in VirtualBox ([Figure 14-2](ch14.xhtml#ch14fig2)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先启用 Metasploitable 虚拟机的第二个网络接口，然后将其连接到私人网络。为此，请导航到 VirtualBox 中 Metasploitable
    的设置（[图 14-2](ch14.xhtml#ch14fig2)）。
- en: '![image](../images/ch14fig02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch14fig02.jpg)'
- en: '*Figure 14-2: Configuring the second network interface*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：配置第二个网络接口*'
- en: Select the **Network** tab ➊, click the second adapter ➋, and then enable it
    ➌. Name the private network **Private LAN** ➍.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 **网络** 标签 ➊，点击第二个适配器 ➋，然后启用它 ➌。将私人网络命名为 **Private LAN** ➍。
- en: 'Next we must assign an IP address to the interface we just enabled. We’ll do
    that by editing the Metasploitable server’s network *interface* file. Run the
    following command to open the file in `vim`, which comes preinstalled on Metasploitable:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须为刚启用的接口分配一个 IP 地址。我们将通过编辑 Metasploitable 服务器的网络 *接口* 文件来完成此操作。运行以下命令在
    `vim` 中打开该文件，Metasploitable 已预安装该编辑器：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you open the file, you should see the primary interface defined at ➊. This
    interface is usually connected to the public network. The value `iface eth0` refers
    to the Ethernet (`eth0`) interface. See [Chapter 1](ch01.xhtml#ch1) for a discussion
    on interfaces. Next, `inet` represents IPv4 addressing, and `dhcp` means we’ll
    allow the *dynamic host configuration protocol (DHCP)* server to assign an IP
    address to the interface. DHCP is the protocol routers normally use to assign
    IP addresses to machines when they join a network. For example, your home Wi-Fi
    router has a DHCP server built in, meaning that your laptop uses the DHCP protocol
    to obtain an IP address when it connects. This ensures that your laptop doesn’t
    use the same IP address as a machine already connected to your network. Alternatively,
    a value of `static` means that we’ll manually assign an IP address.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件时，您应该看到主接口在 ➊ 定义。这个接口通常连接到公共网络。值 `iface eth0` 指的是以太网（`eth0`）接口。有关接口的讨论，请参见
    [第 1 章](ch01.xhtml#ch1)。接下来，`inet` 表示 IPv4 地址，`dhcp` 表示我们将允许 *动态主机配置协议（DHCP）*
    服务器为接口分配 IP 地址。DHCP 是路由器通常用来为设备分配 IP 地址的协议，当它们加入网络时。例如，您的家庭 Wi-Fi 路由器内置有一个 DHCP
    服务器，这意味着您的笔记本电脑在连接时使用 DHCP 协议获取 IP 地址。这可以确保您的笔记本电脑不会使用已经连接到网络的设备的相同 IP 地址。或者，`static`
    的值意味着我们将手动分配 IP 地址。
- en: 'We’ll configure the second interface and set it to have a static IPv4 address
    ➋ of `10.0.0.1` ➌ and then set its subnet mask to `255.255.255.0` ➍. Save the
    file and then start the `eth1` interface by running the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将配置第二个接口，并将其设置为静态 IPv4 地址 ➋ 为 `10.0.0.1` ➌，然后将子网掩码设置为 `255.255.255.0` ➍。保存文件后，运行以下命令启动
    `eth1` 接口：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Lastly, restart the networking interface:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重启网络接口：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***Connecting a Machine to Your Private Network***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将计算机连接到您的私人网络***'
- en: Now that we’ve set up our dual-homed machine, we can move the Ubuntu virtual
    machine to our new private network. However, as soon as we do, it will no longer
    have access to the internet. So before we move it, let’s take the opportunity
    to configure it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了双网卡机器，可以将Ubuntu虚拟机移动到新的私有网络。但是，一旦我们这么做，它将无法再访问互联网。所以在移动之前，让我们利用这个机会进行配置。
- en: 'We’ll use OpenSSH to log in to the Ubuntu machine. OpenSSH is an open source
    implementation of an SSH server that allows users to connect to a machine using
    SSH. Log in to your Ubuntu virtual machine and install the OpenSSH server:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用OpenSSH登录到Ubuntu机器。OpenSSH是一个开源的SSH服务器实现，它允许用户通过SSH连接到机器。登录到你的Ubuntu虚拟机并安装OpenSSH服务器：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once the installation completes, move your Ubuntu virtual machine to the private
    network by updating the interface in VirtualBox to connect to **Private LAN**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，通过更新VirtualBox中的接口，将Ubuntu虚拟机移动到私有网络，连接到**私有局域网**。
- en: Next, you’ll need to assign an IP address to the interface on the Ubuntu virtual
    machine. This is because our private network doesn’t have a DHCP server. Set the
    static IP address on your Ubuntu virtual machine by opening **Settings** ([Figure
    14-3](ch14.xhtml#ch14fig3)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要为Ubuntu虚拟机上的接口分配一个IP地址。因为我们的私有网络没有DHCP服务器。通过打开**设置** ([图14-3](ch14.xhtml#ch14fig3))来在Ubuntu虚拟机上设置静态IP地址。
- en: '![image](../images/ch14fig03.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch14fig03.jpg)'
- en: '*Figure 14-3: Setting up a static IP address on the Ubuntu machine*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：在Ubuntu机器上设置静态IP地址*'
- en: Select **Network**, click the **Settings** gear icon, and click the **IPv4**
    tab. Select **Manual** configuration and set the IP address to **10.0.0.15**,
    the subnet mask to **255.255.255.0**, and the default gateway to **10.0.0.1**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**网络**，点击**设置**齿轮图标，然后点击**IPv4**标签。选择**手动**配置，将IP地址设置为**10.0.0.15**，子网掩码设置为**255.255.255.0**，默认网关设置为**10.0.0.1**。
- en: 'Check that you can access the Metasploitable server from the Ubuntu virtual
    machine by pinging it. If you can reach the Metasploitable server, you should
    get the following, with no packets lost:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过ping测试，检查是否能从Ubuntu虚拟机访问Metasploitable服务器。如果能连接到Metasploitable服务器，你应该看到以下信息，且没有丢失数据包：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Press CTRL-C to end the ping.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 按下CTRL-C结束ping操作。
- en: Although your Ubuntu virtual machine can reach the Metasploitable machine, it
    doesn’t have access to anything outside of the private network. Similarly, no
    machines outside of the private network can access the Ubuntu virtual machine.
    This means that you’ve correctly set up your dual-homed machine and private network.
    Now let’s discuss how you can gain access to the private network by compromising
    the Metasploitable machine and transforming it into a bridge between the virtual
    environment’s internal LAN and the private LAN. We commonly refer to this bridge
    as a *proxy*, which is a program that takes data from one connection and passes
    it to another. You can think of it as an intermediary that facilitates a connection
    between two machines.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你的Ubuntu虚拟机可以访问Metasploitable机器，但它无法访问私有网络之外的任何内容。同样，私有网络之外的机器也无法访问Ubuntu虚拟机。这意味着你已经正确设置了双网卡机器和私有网络。现在，让我们讨论如何通过攻击Metasploitable机器并将其转变为虚拟环境内部局域网和私有局域网之间的桥梁来访问私有网络。我们通常将这个桥梁称为*代理*，它是一个程序，负责从一个连接获取数据并将其传递到另一个连接。你可以把它想象成一个中介，帮助两台机器之间建立连接。
- en: '***Pivoting with Metasploit***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用Metasploit进行pivoting***'
- en: The Metasploit Framework has a built-in proxy capability, so let’s use it to
    execute a pivoting attack from start to finish. We’ll begin by scanning the Metasploitable
    server from our Kali Linux virtual machine. Once we’ve found a vulnerability,
    we’ll exploit it and upload a reverse shell. Then we’ll check to see if the Metasploitable
    server has access to multiple networks.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit框架内置了代理功能，让我们利用它从头到尾执行一次pivoting攻击。我们将从Kali Linux虚拟机扫描Metasploitable服务器开始。一旦找到漏洞，我们将利用它并上传一个反向Shell。然后我们将检查Metasploitable服务器是否可以访问多个网络。
- en: After we’ve discovered that it does, we’ll use the Metasploitable server as
    a proxy to access the private network containing our Ubuntu virtual machine. Then,
    we’ll use stolen SSH credentials to log in to the Ubuntu virtual machine on the
    private network and upload another reverse shell. Lastly, we’ll control the reverse
    shell in the private LAN by routing our commands through the proxy on the Metasploitable
    server.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们发现它可以后，我们将使用 Metasploitable 服务器作为代理，访问包含我们 Ubuntu 虚拟机的私有网络。然后，我们将使用盗取的 SSH
    凭据登录到私有网络中的 Ubuntu 虚拟机，并上传另一个反向 shell。最后，我们通过 Metasploitable 服务器上的代理路由我们的命令，从而控制私有局域网中的反向
    shell。
- en: Let’s get started. Scan the Metasploitable server using a vulnerability scanner
    like the ones we discussed in [Chapter 8](ch08.xhtml#ch8). The *Nexpose* vulnerability
    scanner allows you to perform scans from the Metasploit console. Keep in mind
    that these scanners use heuristics, meaning that they might incorrectly identify
    vulnerabilities. Thus, you might need to try multiple vulnerabilities before you
    discover one that gives you access to the machine.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。使用我们在[第 8 章](ch08.xhtml#ch8)中讨论的漏洞扫描器扫描 Metasploitable 服务器。*Nexpose*
    漏洞扫描器允许你从 Metasploit 控制台进行扫描。请记住，这些扫描器使用启发式方法，这意味着它们可能错误地识别漏洞。因此，你可能需要尝试多个漏洞，直到发现一个能让你访问机器的漏洞。
- en: 'We discussed scanning in [Chapter 8](ch08.xhtml#ch8), so I will assume you
    have already identified some vulnerabilities. For variety, instead of exploiting
    our trusty FTP vulnerability, let’s exploit a vulnerability in the Postgres server
    that lets us upload a reverse shell by exploiting a configuration error. If you
    haven’t already, start Metasploit on Kali Linux:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 8 章](ch08.xhtml#ch8)中讨论了扫描，因此我假设你已经识别了一些漏洞。为了多样化，我们不利用我们可靠的 FTP 漏洞，而是利用
    Postgres 服务器中的一个漏洞，该漏洞允许我们通过利用配置错误上传一个反向 shell。如果你还没开始，请在 Kali Linux 上启动 Metasploit：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, select the Postgres exploit by entering the `**use**` keyword followed
    by the path to the exploit. We didn’t select a payload, so Metasploit will default
    to the `reverse_tcp` Meterpreter payload. See [Chapter 10](ch10.xhtml#ch10) for
    an overview of the different types of payloads and how to select them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，输入`**use**`关键字并指定漏洞利用路径来选择 Postgres 漏洞利用。由于我们没有选择有效载荷，Metasploit 将默认使用`reverse_tcp`
    Meterpreter 有效载荷。有关不同类型有效载荷及其选择方法的概述，请参见[第 10 章](ch10.xhtml#ch10)。
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then, we’ll set the IP address of the remote host (`RHOST`). In our case, this
    is the IP address of the Metasploitable server (`192.168.1.101`). We’ll then execute
    the exploit by entering `**run**`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将设置远程主机的 IP 地址（`RHOST`）。在我们的例子中，这是 Metasploitable 服务器的 IP 地址（`192.168.1.101`）。接着，我们通过输入`**run**`来执行漏洞利用。
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have a Meterpeter shell, let’s check the interfaces on the Metasploitable
    server:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了 Meterpreter shell，接下来让我们检查 Metasploitable 服务器上的接口：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For simplicity I’ve omitted the loopback and primary interfaces in the output
    as these are always present in a network-connected device. We see a new interface
    ➊, which indicates that this machine is connected to another network. We can now
    add a *route* that allows us to send traffic from the virtual environment’s internal
    LAN to the private LAN ➋. A *route* is an entry in the network table that instructs
    the operating system how to forward packets between interfaces. Once we’ve added
    the route, we’ll send the Meterpreter session to the background so that we can
    access the original Metasploit console. Deselect the current module using the
    `**back**` command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我在输出中省略了回环接口和主接口，因为它们在网络连接设备中始终存在。我们看到了一个新的接口➊，这表示该机器已连接到另一个网络。现在我们可以添加一个*路由*，允许我们将流量从虚拟环境的内部局域网发送到私有局域网➋。*路由*是网络表中的一项条目，它指示操作系统如何在接口之间转发数据包。添加路由后，我们将把
    Meterpreter 会话发送到后台，以便我们可以访问原始的 Metasploit 控制台。使用`**back**`命令取消当前模块的选择：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now let’s load a reverse shell onto the Ubuntu virtual machine. Although you
    could simply log in to Ubuntu to do this, we’ll simulate a real attack scenario
    by assuming that you don’t know the credentials ahead of time. Instead, let’s
    pretend you’ve obtained several credentials during the OSINT phase of the attack
    that you can now use in a dictionary-based attack. We’ll try each of these credentials
    and hope that one of them allows us to log in to the SSH server. Create a file
    on your Kali Linux desktop containing the username and password of the Ubuntu
    machine called *Ubuntu_passwords.txt*. Each username–password pair should be on
    its own line with the username and password separated by a space. Add some dummy
    credentials, but remember to also include the username and password for your Ubuntu
    machine so that you can access the machine. Here is an example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将一个反向shell加载到Ubuntu虚拟机上。虽然你可以直接登录Ubuntu来完成此操作，但我们将通过假设你事先不知道凭证，来模拟一个真实的攻击场景。假设在攻击的OSINT阶段，你已经获取了一些凭证，现在可以使用这些凭证进行基于字典的攻击。我们将尝试每个凭证，并希望其中一个能够让我们登录到SSH服务器。在你的Kali
    Linux桌面上创建一个名为*Ubuntu_passwords.txt*的文件，里面包含Ubuntu机器的用户名和密码。每一对用户名和密码应该单独一行，用户名和密码之间用空格分隔。添加一些虚假的凭证，但记得也包括你Ubuntu机器的用户名和密码，以便可以访问该机器。以下是一个示例：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use this file in a dictionary-based attack on the SSH server. We’ll begin by
    selecting Metasploit’s `ssh_login` module. Then we set the remote host, supply
    the password file, and run the module:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此文件在SSH服务器上进行基于字典的攻击。我们首先选择Metasploit的`ssh_login`模块。然后设置远程主机，提供密码文件，最后运行该模块：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When the attack completes, you should have a shell running on the Ubuntu virtual
    machine. Run the following command to view a list of all your sessions:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当攻击完成后，你应该可以在Ubuntu虚拟机上运行一个shell。运行以下命令查看所有会话的列表：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Session 2 is the Linux shell running on the Ubuntu machine. The Connection
    column shows that the connection to the shell flows from 192.168.1.115 (Kali Linux)
    to 192.168.1.112 (Metasploitable) to 10.0.0.15 (Ubuntu). To execute commands on
    the Ubuntu virtual machine, run the following command to select session 2\. Then
    try running a terminal command like `**ls**`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 会话2是运行在Ubuntu机器上的Linux shell。连接栏显示，从192.168.1.115（Kali Linux）到192.168.1.112（Metasploitable）再到10.0.0.15（Ubuntu）之间的连接流。要在Ubuntu虚拟机上执行命令，运行以下命令选择会话2。然后尝试运行像`**ls**`这样的终端命令：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now you can control the Ubuntu virtual machine on the private LAN from a machine
    outside of that network.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以从外部网络控制私有局域网中的Ubuntu虚拟机。
- en: In this example, we used Metasploit’s proxy. Next, we’ll discuss how you can
    write your own proxy.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了Metasploit的代理。接下来，我们将讨论如何编写你自己的代理。
- en: '***Writing an Attacker Proxy***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写攻击者代理***'
- en: 'Create a folder called *ProxyFun* and copy the following code into a new file
    within that folder called *proxy.py*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为*ProxyFun*的文件夹，并将以下代码复制到该文件夹中的新文件*proxy.py*：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The proxy starts a TCP server to listen to the private LAN’s IP address ➌. Remember
    that our target, the Ubuntu virtual machine, can only access IP addresses on the
    private network. So if we want to communicate with it, we must set up a TCP server
    to listen on an IP address associated with the interface connected to the private
    network.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 代理启动一个TCP服务器，监听私有局域网的IP地址➌。记住，我们的目标，Ubuntu虚拟机，只能访问私有网络中的IP地址。所以，如果我们想与它通信，必须设置一个TCP服务器，监听与连接到私有网络的接口关联的IP地址。
- en: For now, we’ll assume that we’ve already implanted a reverse shell on the Ubuntu
    virtual machine, so we can focus on seeing how the data flows from the reverse
    shell in the private LAN, through the proxy, and into the attacker’s Kali Linux
    machine on our simulated public network.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们假设已经在Ubuntu虚拟机上植入了反向shell，因此我们可以专注于查看数据如何从私有局域网中的反向shell，通过代理流向攻击者的Kali
    Linux机器，并进入模拟的公共网络。
- en: First, the reverse shell will connect to the proxy’s IP address on the private
    LAN. When the shell connects to the proxy and sends its first message, the proxy
    will extract the data from the message ➊ and open a new TCP connection on the
    external LAN to the hacker’s server. The proxy will send data from the shell in
    the private LAN to the external LAN, acting as a bridge ➋. The proxy will also
    listen for traffic from the external LAN, which it will send to the shell on the
    private LAN. Great! You should now have a two-way bridge between the private LAN
    and the external LAN.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，反向 shell 将连接到私有局域网中的代理 IP 地址。当 shell 连接到代理并发送其第一条消息时，代理将从消息中提取数据 ➊，并在外部局域网上打开到黑客服务器的新
    TCP 连接。代理将把来自私有局域网的 shell 数据转发到外部局域网，充当桥梁 ➋。代理还将监听来自外部局域网的流量，并将其转发到私有局域网中的 shell。太棒了！现在，你应该有一个连接私有局域网和外部局域网的双向桥梁。
- en: 'Now let’s test our proxy. Instead of running the TCP server code we wrote in
    [Chapter 4](ch04.xhtml#ch4), we’ll keep this test lightweight. We’ll use netcat
    (`nc`) to start a new TCP server that listens (`l`) on port (`p`) 5050\. We’ll
    also enable the verbose flag (`v`) to print out information on the connection:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试一下代理。我们不再运行我们在 [第 4 章](ch04.xhtml#ch4)中编写的 TCP 服务器代码，而是保持此测试轻量级。我们将使用
    netcat (`nc`) 启动一个新的 TCP 服务器，该服务器在端口 (`p`) 5050 上监听（`l`）。我们还将启用详细标志（`v`），以打印出连接信息：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, copy the *proxy.py* file onto the Metasploitable server and run it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 *proxy.py* 文件复制到 Metasploitable 服务器并运行：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that the proxy is up and running, open the Ubuntu virtual machine on the
    private network. Instead of using the reverse shell we wrote in [Chapter 4](ch04.xhtml#ch4),
    we’ll use netcat to connect to the proxy.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，代理已经启动并运行，打开私有网络上的 Ubuntu 虚拟机。我们不再使用我们在 [第 4 章](ch04.xhtml#ch4)中编写的反向 shell，而是使用
    netcat 连接到代理。
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Enter the phrase `**BOT Reporting For Duty**` in the Ubuntu terminal running
    netcat. If the proxy is working correctly, it will route the private LAN’s traffic
    to the terminal on your Kali Linux machine.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 netcat 的 Ubuntu 终端中输入短语 `**BOT Reporting For Duty**`。如果代理正常工作，它将把私有局域网的流量路由到你
    Kali Linux 机器上的终端。
- en: '**Extracting Password Hashes on Linux**'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在 Linux 上提取密码哈希**'
- en: Once you’ve gained access to a machine, you can try to extract user credentials
    from the machine’s memory that you can use to log in to other machines and move
    around the network. This section describes how you can extract usernames and password
    hashes from a Linux machine using privilege escalation techniques.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了机器的访问权限，你可以尝试从机器的内存中提取用户凭证，用于登录其他机器并在网络中移动。本节介绍了如何使用特权提升技术从 Linux 机器中提取用户名和密码哈希。
- en: '***Where Linux Stores Usernames and Passwords***'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Linux 存储用户名和密码的位置***'
- en: 'The operating system stores usernames in the */etc/passwd* file, which anyone
    on the system can read. The file’s name is deceiving, because it doesn’t contain
    any passwords. Still, we can often glean useful information from this file, such
    as whether an account requires a password. Run the following command to view the
    contents of this file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 操系统将用户名存储在*/etc/passwd* 文件中，任何人都可以读取该文件。文件名具有误导性，因为它不包含任何密码。不过，我们仍然可以从这个文件中获取有用的信息，例如账户是否需要密码。运行以下命令查看该文件的内容：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A colon separates each property of entries, which follow this format:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个条目的属性由冒号分隔，格式如下：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The second property, `has_password`, specifies whether the user has a password.
    An `x` in this property means that the user account has a password, and an empty
    field means it’s a guest account that doesn’t require a password.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个属性 `has_password` 指示用户是否具有密码。该属性中的 `x` 表示用户账户有密码，空字段则表示是一个不需要密码的访客账户。
- en: So, where does the operating system store the passwords? After all, it must
    keep a copy of the passwords to compare them to the value a user enters when they
    log in. Linux doesn’t store plaintext passwords. Instead, it stores an HMAC-SHA256
    hash of the passwords in the file */etc/shadow*. When a user logs in, Linux hashes
    their password, compares it to the stored hash, and gives access if they match.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，操作系统将密码存储在哪里呢？毕竟，它必须保留密码的副本，以便与用户登录时输入的值进行比较。Linux 不存储明文密码。相反，它将密码的 HMAC-SHA256
    哈希存储在文件*/etc/shadow*中。当用户登录时，Linux 会对密码进行哈希运算，将其与存储的哈希进行比较，如果匹配，则授予访问权限。
- en: 'You can extract these password hashes by reading the */etc/shadow* file; however,
    you’ll need root permissions to do so, as you can see by running the `**ls**`
    command with the `**-l**` option:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过读取*/etc/shadow* 文件来提取这些密码哈希；然而，如通过运行`**ls**`命令并使用`**-l**`选项所见，你需要 root
    权限才能执行此操作：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The label `-rw-r-----` represents the file’s permissions. [Figure 14-4](ch14.xhtml#ch14fig4)
    explains the structure of Linux permissions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 标签`-rw-r-----`表示文件的权限。[图 14-4](ch14.xhtml#ch14fig4)解释了 Linux 权限的结构。
- en: The permissions on the */etc/shadow/* file indicate that only the owner (`root`)
    and the group (`shadow`) can read the file, and that only a root user can write
    to it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/shadow/* 文件的权限表明，只有所有者（`root`）和组（`shadow`）可以读取该文件，并且只有 root 用户可以写入该文件。'
- en: If we’re lucky, we’ve found credentials for a user with root permissions and
    can gain root access to the system by entering `sudo -i`. But suppose we aren’t
    this lucky. In that case, we can still gain root access by exploiting a vulnerability
    in the operating system, a process commonly known as *privilege escalation*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运气好，我们可能已经找到了一个具有 root 权限的用户凭证，并可以通过输入`sudo -i`获得 root 访问权限。但假设我们运气不好，依然可以通过利用操作系统中的漏洞来获得
    root 权限，这一过程通常被称为*权限提升*。
- en: '![image](../images/ch14fig04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch14fig04.jpg)'
- en: '*Figure 14-4: Linux permissions*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：Linux 权限*'
- en: An attacker might use a variety of techniques to gain root privileges on a system.
    For example, they might use a buffer overflow attack to inject code into a kernel
    module or driver. The kernel module would then execute the code with root-level
    permissions, giving the hacker a reverse shell with root permissions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可能使用多种技术来获取系统的 root 权限。例如，他们可能使用缓冲区溢出攻击向内核模块或驱动程序注入代码。然后，内核模块将以 root 权限执行该代码，从而让黑客获得一个具有
    root 权限的反向 Shell。
- en: An attacker could also take advantage of incorrect permissions on a file or
    directory to escalate privileges. For example, if a process executes a file with
    root privileges, an attacker could modify the file to contain code that runs a
    reverse shell.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者还可以利用文件或目录上的不正确权限来提升权限。例如，如果一个进程以 root 权限执行某个文件，攻击者可以修改该文件，使其包含运行反向 Shell
    的代码。
- en: 'The `unix-privesc` tool is preinstalled on Kali Linux and allows you to check
    a system for vulnerabilities that might allow a privilege escalation attack:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`unix-privesc`工具预装在 Kali Linux 中，允许你检查系统中可能允许权限提升攻击的漏洞：'
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The Meterpreter shell has similar functionality built in. You can use the command
    `getsystem` to search for and exploit possible privilege escalation vulnerabilities:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Meterpreter shell 也内建了类似的功能。你可以使用`getsystem`命令搜索并利用可能的权限提升漏洞：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After you gain root privileges, run the Meterpreter module `**hashdump**` to
    extract the hashes from the system.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 获得 root 权限后，运行 Meterpreter 模块`**hashdump**`来从系统中提取哈希值。
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that we’ve looked at these privilege escalations in general, let’s take
    a look at an example.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经大致了解了这些权限提升的方式，接下来让我们看一个例子。
- en: '***Performing a Dirty COW Privilege Escalation Attack***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***执行一个 Dirty COW 权限提升攻击***'
- en: In 2016, Phil Oester discovered a kernel-level vulnerability nicknamed *Dirty
    COW*. The vulnerability (CVE-2016-5195) allows an attacker without root privileges
    to edit any file by exploiting a bug in how the Linux kernel manages memory. Among
    other things, an attacker could use this vulnerability to create a new user with
    root privileges by editing the */etc/shadow* file we discussed earlier.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 2016 年，Phil Oester 发现了一个被称为*Dirty COW*的内核级漏洞。该漏洞（CVE-2016-5195）允许没有 root 权限的攻击者通过利用
    Linux 内核管理内存的错误来编辑任何文件。除了其他的漏洞外，攻击者可以利用该漏洞编辑我们之前讨论的*/etc/shadow* 文件，从而创建一个具有 root
    权限的新用户。
- en: The vulnerability takes its name from the process the Linux kernel uses to manage
    *virtual memory*. Virtual memory is the mechanism operating systems use to give
    processes their own isolated memory spaces. It does this by creating a table that
    maps the process’s virtual memory address to a real physical address in memory.
    Because separate processes may share libraries or files, two processes may have
    virtual memory addresses that point to the same physical memory. The virtual memory
    will only create a copy if one process writes to the memory, a procedure known
    as *copy-on-write (COW)*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞得名于 Linux 内核管理*虚拟内存*的过程。虚拟内存是操作系统用来为进程提供独立内存空间的机制。它通过创建一个表格，将进程的虚拟内存地址映射到内存中的实际物理地址。因为不同的进程可能共享库或文件，所以两个进程可能会有虚拟内存地址指向相同的物理内存。只有当一个进程写入内存时，虚拟内存才会创建副本，这个过程称为*写时复制（COW）*。
- en: The Dirty COW vulnerability tricks the operating system into letting a user
    edit a file they don’t own. It does this by exploiting a race condition in the
    Linux kernel. A *race condition* occurs when two or more threads rush to access
    a variable and the program’s output depends on the order in which the threads
    finish. Attackers can exploit race conditions by repeatably performing multiple
    order-sensitive operations until they achieve a favorable order of events.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**脏牛漏洞**（Dirty COW）通过欺骗操作系统让用户编辑他们不拥有的文件。它利用了 Linux 内核中的竞态条件（*race condition*）。当两个或更多线程同时争抢访问一个变量，而程序的输出依赖于线程完成的顺序时，就会发生竞态条件。攻击者可以通过重复执行多个对顺序敏感的操作，直到它们达到一个有利的事件顺序，从而利用竞态条件。'
- en: 'The Dirty COW vulnerability exploits a race condition related to how the Linux
    kernel reads and writes files. The Linux kernel blocks processes from writing
    to read-only files, but it does allow a process to write to a copy of a read-only
    file. When a process writes to its own copy, the Linux kernel would normally execute
    the following events in order: 1) open a processspecific copy of the file, 2)
    write to the copy, and 3) discard the changes and map back to the original file,
    thus leaving the original file unchanged.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 脏牛漏洞利用了与 Linux 内核读取和写入文件相关的竞态条件。Linux 内核阻止进程写入只读文件，但它允许进程写入只读文件的副本。当一个进程写入它自己的副本时，Linux
    内核通常会按以下顺序执行事件：1）打开一个特定进程的文件副本，2）写入副本，3）丢弃更改并映射回原始文件，从而保持原始文件不变。
- en: 'However, if an attacker uses two threads to independently write and discard
    changes, a race condition can occur that causes the kernel to execute the sequence
    out of order: 1) open a process-specific copy of the file, 3) discard the changes
    and map back to the original file, and 2) write to the copy, which is now the
    original file. In this scenario, the attacker was able to trick the kernel into
    allowing them to write to a read-only file.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果攻击者使用两个线程独立地写入和丢弃更改，就可能发生竞态条件，导致内核执行顺序错误：1）打开一个特定进程的文件副本，3）丢弃更改并映射回原始文件，2）写入副本，而此时副本已变成原始文件。在这种情况下，攻击者成功欺骗了内核，允许他们写入一个只读文件。
- en: 'We can use this vulnerability to edit the read-only password file and add a
    new user with root privileges. Let’s execute this privilege escalation attack
    on the Metasploitable server. We’ll start by discovering whether your server is
    vulnerable in the first place. Log in to it and then run the `**whoami**` command
    to get the current user, and `**uname -a**` to get the current version of Linux:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这个漏洞来编辑只读的密码文件，并添加一个具有 root 权限的新用户。让我们在 Metasploitable 服务器上执行这个权限提升攻击。我们首先开始确认服务器是否存在漏洞。登录到服务器后，运行
    `**whoami**` 命令获取当前用户，运行 `**uname -a**` 命令获取当前的 Linux 版本：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you have the server’s Linux version, use `searchsploit` to search for
    known vulnerabilities affecting that version:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你得知服务器的 Linux 版本时，使用 `searchsploit` 来搜索已知的影响该版本的漏洞：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, there are several implementations of Dirty COW. Some implementations
    use the vulnerability to change the password file, whereas others use it to inject
    shell code into a file with SUID privileges. *SUID* is a Linux permission that
    allows a regular user to execute a file with the privileges of that file’s owner.
    For example, a regular user can execute the `ping` command with root privileges
    even if they aren’t root because the SUID permission is set.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Dirty COW有多个实现方式。一些实现利用该漏洞更改密码文件，而其他实现则利用它将Shell代码注入具有SUID权限的文件中。*SUID*是Linux中的一种权限，允许普通用户以文件所有者的权限执行文件。例如，普通用户可以用root权限执行`ping`命令，即使他们不是root用户，因为设置了SUID权限。
- en: Some exploits are more reliable than others. The *Dirty COW PTRACE* exploit
    works reliably on the Linux version running on the Metasploitable server.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一些漏洞比其他漏洞更可靠。*Dirty COW PTRACE*漏洞在运行Metasploitable服务器的Linux版本上表现得非常稳定。
- en: 'The code for the exploit is available on your Kali Linux virtual machine. Using
    `**searchsploit**`, supply the exploit number `**40839.c**`, and use the `**-p**`
    option to find the path to the exploit code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞利用代码可在你的Kali Linux虚拟机上找到。使用`**searchsploit**`，提供漏洞编号`**40839.c**`，并使用`**-p**`选项查找漏洞代码的路径：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, copy the code onto the Metasploitable machine:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将代码复制到Metasploitable机器上：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Compile and execute the exploit:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并执行漏洞利用代码：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now run the exploit (`kernelexploit`). You’ll be prompted to create a new root
    user (`firefart`) and provide it with a password. I’ve chosen `147` here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行漏洞利用代码（`kernelexploit`）。系统会提示你创建一个新的root用户（`firefart`），并为其设置密码。我在这里选择了`147`：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Switch to the newly created user with root privileges:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到新创建的具有root权限的用户：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now you should be able to read the */etc/shadow* file containing the password
    hashes:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够读取包含密码哈希的*/etc/shadow*文件：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The entry should contain the HMAC-SHA256 hash of the users’ passwords. You can
    crack these hashes using the tools introduced in [Chapter 12](ch12.xhtml#ch12).
    If you succeed, you’ll have escalated your privileges and extracted the plaintext
    passwords for the system’s users.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该条目应包含用户密码的HMAC-SHA256哈希值。你可以使用[第12章](ch12.xhtml#ch12)中介绍的工具来破解这些哈希。如果成功，你将提升权限并提取系统用户的明文密码。
- en: You can now use these credentials to log in to other machines. The best credentials
    to extract are admin credentials because admins maintain the network and normally
    have access to all machines. However, regular user credentials can also be useful
    because they might have access to other machines on the network, like desktops
    or printers. Tools like `spray` allow you to test multiple passwords and connections
    simultaneously. However, these tools do unusual things and could generate security
    alerts, so you’ll want to be careful when using them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用这些凭据登录到其他机器。最好的凭据是管理员凭据，因为管理员负责维护网络，并通常可以访问所有机器。然而，普通用户的凭据也很有用，因为他们可能能够访问网络上的其他机器，比如桌面或打印机。像`spray`这样的工具可以让你同时测试多个密码和连接。然而，这些工具会做一些不寻常的事情，可能会生成安全警报，所以你在使用时要小心。
- en: What about the hashes that you couldn’t crack? You might still be able to use
    them to perform other attacks, such as the *pass-the-hash attacks* that we’ll
    look at in [Chapter 15](ch15.xhtml#ch15).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 那些你无法破解的哈希值怎么办？你仍然可以利用它们执行其他攻击，例如我们将在[第15章](ch15.xhtml#ch15)中讨论的*传递哈希攻击*。
- en: '**Exercises**'
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**练习**'
- en: These exercises are designed to enhance your understanding of privilege escalations
    and pivoting. In the first exercise, you extend your Metasploitable machine so
    that it can route traffic out of the private network, transforming it into a fully
    functional router. The second exercise provides some suggested reading on privilege
    escalation for Windows devices.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习旨在增强你对权限提升和跳板攻击的理解。在第一个练习中，你将扩展你的Metasploitable机器，使其能够将流量从私有网络路由出去，将其转变为一个完全功能的路由器。第二个练习提供了一些关于Windows设备权限提升的推荐阅读材料。
- en: '***Adding NAT to Your Dual-Homed Device***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***为双网卡设备添加NAT***'
- en: 'Allow your dual-homed device to route packets out of the private network, as
    a router would, by enabling NAT. First, you must enable IP forwarding:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启用NAT，允许你的双网卡设备像路由器一样将数据包从私有网络路由出去。首先，你必须启用IP转发：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As in the ARP spoofing attack you performed in [Chapter 2](ch02.xhtml#ch2),
    we need to enable `ip_forward` so that the machine can accept and forward packets
    that don’t match its IP address. Next, set `iptables` to allow the Metasploitable
    virtual machine to route packets from your private network to your virtual environment’s
    internal network:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在[第2章](ch02.xhtml#ch2)中执行的ARP欺骗攻击一样，我们需要启用`ip_forward`，这样机器就能接收并转发那些IP地址不匹配的包。接下来，设置`iptables`，允许Metasploitable虚拟机将来自私有网络的数据包路由到虚拟环境的内部网络：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Check to see whether you can access the outside world by pinging the pfSense
    firewall from your Ubuntu virtual machine in the private LAN:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从你的Ubuntu虚拟机在私有局域网中ping pfSense防火墙，检查是否能够访问外部世界：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***Suggested Reading on Windows Privilege Escalation***'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Windows权限提升的推荐阅读***'
- en: 'Check out Hanno Heinrichs’ blog post “Exploiting GlobalProtect for Privilege
    Escalation, Part One: Windows” at *[https://www.crowdstrike.com/blog/exploiting-escalation-of-privileges-via-globalprotect-part-1/](https://www.crowdstrike.com/blog/exploiting-escalation-of-privileges-via-globalprotect-part-1/)*.
    Crowdstrike’s blog is a great place to find information on new vulnerabilities.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Hanno Heinrichs的博客文章《利用GlobalProtect进行权限提升，第1部分：Windows》，地址为*[https://www.crowdstrike.com/blog/exploiting-escalation-of-privileges-via-globalprotect-part-1/](https://www.crowdstrike.com/blog/exploiting-escalation-of-privileges-via-globalprotect-part-1/)*。Crowdstrike的博客是查找新漏洞信息的好地方。
- en: 'Another great privilege escalation bug is the Sudo buffer overflow bug (CVE-2021-3156);
    you can read more about it here: *[https://github.com/stong/CVE-2021-3156](https://github.com/stong/CVE-2021-3156)*.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很棒的权限提升漏洞是Sudo缓冲区溢出漏洞（CVE-2021-3156）；你可以在这里阅读更多内容：[https://github.com/stong/CVE-2021-3156](https://github.com/stong/CVE-2021-3156)。
