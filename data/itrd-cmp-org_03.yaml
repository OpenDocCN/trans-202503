- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3'
- en: COMPUTER ARITHMETIC**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算机算术**'
- en: '![Image](../images/pg23_Image_2.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg23_Image_2.jpg)'
- en: The reality of computing is that we have a finite number of bits. In the previous
    chapter, you learned that each data item must fit within a fixed number of bits,
    depending on its data type. This chapter will show you that this limit complicates
    even our most basic mathematical operations. For both signed and unsigned numbers,
    a limited number of bits is a constraint we don’t normally think about when doing
    math on paper or in our heads.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 计算的现实是我们有有限的比特数。在上一章中，你学到了每个数据项必须适应固定数量的比特，这取决于它的数据类型。本章将向你展示，这一限制甚至使我们最基本的数学运算变得复杂。对于有符号和无符号的数字，有限的比特数是一个我们在纸上或脑中做数学时通常不会想到的约束。
- en: The CPU includes memory for a set of single-bit *condition flags*. Among them
    are a *carry flag (*C*)* and an *overflow flag (*V*)* that enable us to detect
    when adding or subtracting binary numbers yields results that exceed the allocated
    number of bits for the data type. We’ll dig deeper into the carry flag and the
    overflow flag in subsequent chapters, but for now, let’s take a look at how addition
    and subtraction affect them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 包括用于一组单比特 *状态标志* 的内存。它们中有一个 *进位标志（C）* 和一个 *溢出标志（V）*，使我们能够检测到加法或减法操作后，二进制数的结果超过了分配给数据类型的比特数。我们将在后续章节中深入探讨进位标志和溢出标志，但现在让我们看看加法和减法如何影响它们。
- en: '### **Unsigned Integers in the Decimal Number System**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '### **十进制数系统中的无符号整数**'
- en: When computers do arithmetic, they do it in the binary number system. The operations
    may seem difficult at first, but if you remember the details of performing decimal
    arithmetic by hand, binary arithmetic becomes much easier. Although most people
    do addition on a calculator these days, reviewing all the steps required to do
    it by hand will help us develop the algorithms to do addition and subtraction
    in binary and hexadecimal.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机做算术时，它们是在二进制数系统中进行的。这些运算一开始可能看起来很困难，但如果你记得手工做十进制算术的细节，二进制算术就变得容易多了。虽然现在大多数人使用计算器做加法，但回顾手工做加法所需的所有步骤将帮助我们开发出在二进制和十六进制中进行加法和减法的算法。
- en: '**NOTE**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Most computer architectures provide arithmetic instructions in other number
    systems, but those are somewhat specialized. We will not consider them in this
    book.*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*大多数计算机架构提供其他进制的算术指令，但那些是比较专业的。我们在本书中不会讨论这些。*'
- en: '***Addition***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加法***'
- en: 'Let’s restrict ourselves to two-digit decimal numbers. Consider two of these,
    *x* = 67 and *y* = 79\. Adding these by hand on paper would look like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们限制在两位十进制数上。考虑这两个数字，*x* = 67 和 *y* = 79。用手工在纸上加法会是这样的：
- en: '![Image](../images/pg66_Image_18.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg66_Image_18.jpg)'
- en: 'We start by working from the right, adding the two decimal digits in the ones
    place: 7 + 9 = 16, which exceeds 10 by 6\. We show this by placing a 6 in the
    sum’s ones place and carrying a 1 to the tens place:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从右侧开始，首先加上个位上的两个十进制数字：7 + 9 = 16，超过了10，差6。我们通过在和的个位放一个6，并将1进位到十位上来表示：
- en: '![Image](../images/pg66_Image_19.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg66_Image_19.jpg)'
- en: 'Next, we add the three decimal digits in the tens place: 1 (the carry from
    the ones place) + 6 + 7\. The sum of these three digits exceeds 10 by 4, which
    we show by placing a 4 in the tens place and then recording the fact that there
    is an ultimate carry of 1\. Because we’re using only two digits, there is no hundreds
    place.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们加上十位上的三个十进制数字：1（来自个位的进位）+ 6 + 7。三个数字的和超过了10，差4，我们通过在十位放一个4，并记录最终进位为1来表示。因为我们只用两位数字，所以没有百位。
- en: 'The following algorithm shows the procedure for adding two decimal integers,
    *x* and *y*. In this algorithm, *x[i]* and *y[i]* are the *i*th digits of *x*
    and *y*, respectively, numbered from right to left:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法展示了加两个十进制整数，*x* 和 *y* 的过程。在这个算法中，*x[i]* 和 *y[i]* 分别是 *x* 和 *y* 的第 *i* 位数字，从右到左编号：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This algorithm works because we use positional notation when writing numbers;
    a digit one place to the left counts 10 times more. The carry from the current
    position one place to the left is always 0 or 1.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法之所以有效，是因为我们在写数字时使用了位置表示法；数字向左移动一位，值就增加10倍。当前位进位到左边一位时总是0或1。
- en: 'We use 10 in the `/` and `%` operations because there are exactly 10 digits
    in the decimal number system: 0, 1, 2, . . . , 9\. Since we are working in an
    *N*-digit system, we restrict our result to *N* digits. The ultimate carry, *Carry[N]*,
    is either 0 or 1 and is part of the result, along with the *N*-digit sum.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `/` 和 `%` 操作中使用10，因为十进制数系统中恰好有10个数字：0, 1, 2, . . . , 9。由于我们在 *N* 位系统中工作，我们将结果限制为
    *N* 位。最终的进位，*Carry[N]*，要么是0，要么是1，并且它是结果的一部分，与 *N* 位的和一起。
- en: '***Subtraction***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***减法***'
- en: 'For subtraction, you sometimes have to borrow from the next higher-order digit
    in the *minuend* (the number being subtracted from). We’ll do the subtraction
    with the same numbers we used earlier (67 and 79) and go through this in steps
    so you can understand the process. “Scratch” work will be in the borrowing row
    above the two numbers:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于减法，有时你需要从被减数的下一个高位借位（即被减的数字）。我们将使用之前用过的数字（67和79）来进行减法，并分步骤说明，以便你理解这个过程。借位的工作将在两个数字上方的借位行中进行：
- en: '![Image](../images/pg67_Image_20.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg67_Image_20.jpg)'
- en: 'First, we need to borrow 1 from the 6 in the tens place and add it to the 7
    in the ones place. Then, we can subtract 9 from 17 and get 8:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从十位上的6借1，并把它加到个位上的7。然后，我们就可以从17中减去9，得到8：
- en: '![Image](../images/pg67_Image_21.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg67_Image_21.jpg)'
- en: 'Next, we need to borrow from beyond the two digits, which we mark by placing
    a 1 in the “carry” position. That gives us 15 in the tens place, from which we
    subtract 7:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要从两位数以外的地方借位，我们通过在“进位”位置标记一个1来表示。这样我们就得到了十位上的15，然后从中减去7：
- en: '![Image](../images/pg67_Image_22.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg67_Image_22.jpg)'
- en: 'This is shown in the following algorithm, where *x* is the minuend and *y*
    is the number being subtracted from it (the *subtrahend*). If *Borrow* is 1 at
    the end of this algorithm, it shows that you had to borrow from beyond the *N*
    digits of the two values, so the *N*-digit result is incorrect. Although it’s
    called the *carry flag*, its purpose is to show when the operation gives a result
    that will not fit within the number of bits for the data type. Thus, the carry
    flag shows the value of *Borrow* (from beyond the size of the data type) at the
    completion of the subtraction operation:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这在下面的算法中有所体现，其中 *x* 是被减数，*y* 是被减数（*减数*）。如果在这个算法结束时 *Borrow* 为1，这表明你必须从两个数的 *N*
    位数以外的地方借位，因此 *N* 位的结果是错误的。虽然它叫做 *进位标志*，但它的作用是表明操作结果无法适应数据类型的位数。因此，进位标志在减法操作完成时显示
    *Borrow* 的值（来自超出数据类型大小的部分）：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This algorithm isn’t nearly as complicated as it first looks (but it took me
    a long time to figure it out!). If the digit we’re subtracting from is the same
    as or larger than the one we’re subtracting ❶, we’re done with that place in the
    number. Otherwise, we need to borrow from the next place to the left ❷. If the
    next digit we’retrying to borrow from is 0, then we need to continue moving to
    the left until we find a nonzero digit or until we reach the leftmost end of the
    number ❸. If we reach the number of digits allocated for the number ❹, we indicate
    that by setting *Borrow* to 1 ❺.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法看起来并没有那么复杂（但我花了很长时间才搞明白！）。如果我们正在减的数字与被减数的数字相同或更大❶，我们就完成了该位的操作。否则，我们需要从左边的下一个位借位❷。如果我们尝试从的下一个数字是0，我们需要继续向左移动，直到找到一个非零数字，或者直到我们到达数字的最左端❸。如果我们达到为数字分配的位数❹，我们通过将
    *Borrow* 设置为1来表示这一点❺。
- en: After we have borrowed from positions to the left, we work our way back to the
    position we’re dealing with ❻ and perform the subtraction ❼. When you do subtraction
    on paper, you do all these things automatically, in your head, but that probably
    won’t be as intuitive for you in the binary and hexadecimal systems. (I cheat
    and write my intermediate borrows in decimal.)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从左边的各位借位之后，我们会回到当前处理的位置❻，并进行减法❼。当你在纸上做减法时，你会自动在脑海中完成这些步骤，但在二进制和十六进制系统中，可能不会那么直观。（我会作弊，把中间的借位写成十进制。）
- en: If you’re having trouble, don’t worry. You don’t need a thorough understanding
    of this algorithm to understand the material in this book, but I think working
    through it can help you learn how to develop algorithms for other computing problems.
    Translating everyday procedures into the logical statements used by programming
    languages is often a difficult task.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到困难，不用担心。你不需要深入理解这个算法来理解本书中的内容，但我认为通过它可以帮助你学习如何为其他计算问题开发算法。将日常程序转化为编程语言使用的逻辑语句通常是一个困难的任务。
- en: '**Unsigned Integers in the Binary System**'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**二进制系统中的无符号整数**'
- en: In this section, you’ll learn how to perform addition and subtraction operations
    on unsigned binary integers. Before going any further, take a good look at [Table
    3-1](ch03.xhtml#ch3tab1) (especially the binary bit patterns). You probably won’t
    memorize this table right away, but after you have worked with the binary and
    hexadecimal number systems for a while, it will become natural to think of, say,
    10, `a`, or `1010` as being the same numbers, just in different number systems.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何对无符号二进制整数执行加法和减法运算。在继续之前，请仔细查看 [表 3-1](ch03.xhtml#ch3tab1)（特别是二进制位模式）。您可能不会立刻记住这个表，但在您使用二进制和十六进制数字系统一段时间后，您会发现将
    10、`a` 或 `1010` 看作是相同的数字，只是在不同的数字系统中表示。
- en: '**Table 3-1:** Corresponding Bit Patterns and Unsigned Decimal Values for the
    Hexadecimal Digits'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-1：** 十六进制数字的对应位模式和无符号十进制值'
- en: '| **One hexadecimal digit** | **Four binary digits (bits)** | **Unsigned decimal**
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **一个十六进制数字** | **四个二进制位（比特）** | **无符号十进制** |'
- en: '| --- | --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `0` | `0000` | 0 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0000` | 0 |'
- en: '| `1` | `0001` | 1 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0001` | 1 |'
- en: '| `2` | `0010` | 2 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `0010` | 2 |'
- en: '| `3` | `0011` | 3 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `0011` | 3 |'
- en: '| `4` | `0100` | 4 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `4` | `0100` | 4 |'
- en: '| `5` | `0101` | 5 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `5` | `0101` | 5 |'
- en: '| `6` | `0110` | 6 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `6` | `0110` | 6 |'
- en: '| `7` | `0111` | 7 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `7` | `0111` | 7 |'
- en: '| `8` | `1000` | 8 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `8` | `1000` | 8 |'
- en: '| `9` | `1001` | 9 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `9` | `1001` | 9 |'
- en: '| `a` | `1010` | 10 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `a` | `1010` | 10 |'
- en: '| `b` | `1011` | 11 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `b` | `1011` | 11 |'
- en: '| `c` | `1100` | 12 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `c` | `1100` | 12 |'
- en: '| `d` | `1101` | 13 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `d` | `1101` | 13 |'
- en: '| `e` | `1110` | 14 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `e` | `1110` | 14 |'
- en: '| `f` | `1111` | 15 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `f` | `1111` | 15 |'
- en: Now that you’ve become familiar with [Table 3-1](ch03.xhtml#ch3tab1), let’s
    discuss unsigned integers. As we do so, don’t forget that as far as the value
    of the number goes, it doesn’t matter whether we think of an integer as being
    in decimal, hexadecimal, or binary—they are all mathematically equivalent. However,
    we might wonder whether a computer performing arithmetic in binary gets the same
    results we do when doing the same calculation using decimal arithmetic. Let’s
    take a closer look at some specific operations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了 [表 3-1](ch03.xhtml#ch3tab1)，我们来讨论无符号整数。这样做时，请不要忘记，就数字的值而言，无论我们将整数视为十进制、十六进制还是二进制，它们在数学上是等价的。然而，我们可能会想知道计算机在二进制中执行算术时，是否得到与我们使用十进制算术进行相同计算时相同的结果。让我们仔细看一些具体的运算。
- en: '***Addition***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加法***'
- en: 'In the following examples, we use 4-bit values. First, consider adding the
    two unsigned integers 2 and 4:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们使用 4 位值。首先，考虑将两个无符号整数 2 和 4 相加：
- en: '![Image](../images/pg69_Image_23.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg69_Image_23.jpg)'
- en: The decimal value 2 is represented in binary as `0010`, and decimal 4 is represented
    by `0100`. The carry flag, or `C`, is equal to `0`, because the result of the
    addition operation is also 4 bits long. We add the digits (shown in both binary
    and hex here, though the carries are shown only in binary) in the same relative
    positions as we do in decimal.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制值 2 在二进制中表示为 `0010`，而十进制 4 在二进制中表示为 `0100`。进位标志，或称 `C`，等于 `0`，因为加法运算的结果也是
    4 位长。我们像在十进制中一样，在相同的位置上进行加法操作（这里以二进制和十六进制显示，进位只在二进制中显示）。
- en: 'Next, consider two larger integers. Keeping our 4-bit storage space, we’ll
    add the two unsigned integers 4 and 14:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，考虑两个更大的整数。在保持我们 4 位存储空间的情况下，我们将两个无符号整数 4 和 14 相加：
- en: '![Image](../images/pg70_Image_24.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg70_Image_24.jpg)'
- en: In this case, the carry flag equals `1`, because the result of the operation
    exceeded the 4 bits that we allocated for storing the integers. Thus, our result
    is incorrect. If we included the carry flag in the result, we would get a 5-bit
    value and the result would be `10010`[2] = 18[10], which is correct. In this case,
    we’d have to account for the carry flag in software.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，进位标志等于 `1`，因为运算结果超过了我们为存储整数分配的 4 位。因此，我们的结果是错误的。如果我们将进位标志包括在结果中，我们将得到一个
    5 位值，结果为 `10010`[2] = 18[10]，这是正确的。在这种情况下，我们需要在软件中考虑进位标志。
- en: '***Subtraction***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***减法***'
- en: 'Let’s subtract 14 from 4, or `1110` from `0100`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从4中减去14，或者从`1110`中减去`0100`：
- en: '![Image](../images/pg70_Image_25.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg70_Image_25.jpg)'
- en: The CPU can indicate that we had to borrow from beyond the 4 bits by setting
    the carry flag to `1`, which means the 4-bit result in this subtraction is incorrect.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: CPU可以通过将进位标志设置为`1`，表示我们必须从4位之外借位，这意味着此减法的4位结果是错误的。
- en: These 4-bit arithmetic examples generalize to any size arithmetic performed
    by the computer. The AArch64 architecture has an addition instruction that sets
    the carry flag to `0` if there is no ultimate (or final) carry and sets it to
    `1` if there is an ultimate carry as a result of the addition. Similarly, there
    is a subtraction instruction that sets the carry flag to `0` if no borrow from
    the “outside” is required or to `1` if a borrow is required as a result of the
    subtraction.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些4位算术示例可以推广到计算机执行的任何大小的算术运算。AArch64架构有一个加法指令，当没有最终进位时，它将进位标志设置为`0`；如果加法结果有最终进位，则将进位标志设置为`1`。类似地，还有一个减法指令，如果减法不需要借位，它会将进位标志设置为`0`；如果减法需要借位，则将进位标志设置为`1`。
- en: '**NOTE**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Our C compiler does not use these addition and subtraction instructions. There
    is no indication of carry or borrow when performing an addition or subtraction
    operation. We’ll look at this more closely in [Chapter 15](ch15.xhtml), when we
    discuss embedding assembly language in C code.*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们的C编译器并没有使用这些加法和减法指令。在执行加法或减法运算时，并没有进位或借位的指示。我们将在[第15章](ch15.xhtml)中详细讨论这一点，当时我们会讨论如何将汇编语言嵌入到C代码中。*'
- en: '**YOUR TURN**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮到你了**'
- en: 3.1     How many bits are required to store a single decimal digit? Invent a
    code for storing eight decimal digits in 32 bits. Using this code, does binary
    addition produce the correct results? You saw such a code in [Chapter 2](ch02.xhtml),
    with some reasons for its usefulness.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 3.1     存储一个十进制数字需要多少位？发明一种用于在32位中存储八个十进制数字的编码。使用这种编码，二进制加法是否能产生正确的结果？你在[第2章](ch02.xhtml)中见过这种编码，并了解了它的有用性。
- en: 3.2     Develop an algorithm for adding fixed-width integers in the binary number
    system.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 3.2     开发一个算法，用于在二进制数系统中加法定长整数。
- en: 3.3     Develop an algorithm for adding fixed-width integers in the hexadecimal
    number system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 3.3     开发一个算法，用于在十六进制数系统中加法定长整数。
- en: 3.4     Develop an algorithm for subtracting fixed-width integers in the binary
    number system.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 3.4     开发一个算法，用于在二进制数系统中减去定长整数。
- en: 3.5     Develop an algorithm for subtracting fixed-width integers in the hexadecimal
    number system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 3.5     开发一个算法，用于在十六进制数系统中减去定长整数。
- en: '**Adding and Subtracting Signed Integers**'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**加法和减法的有符号整数**'
- en: 'When representing nonzero signed decimal integers, there are two possibilities:
    they can be positive or negative. With only two options, we need to use only 1
    bit for the sign. We could use a *sign-magnitude code* by simply using the highest-order
    bit for signed numbers—say, where `0` means + and `1` means –. But if we do this,
    we’ll run into some problems. As an example, consider adding +2 and –2:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当表示非零有符号十进制整数时，有两种可能性：它们可以是正数或负数。由于只有两种选择，我们只需要使用1位作为符号位。我们可以使用*符号幅度码*，通过简单地使用最高位来表示有符号数——比如`0`表示正，`1`表示负。但如果这样做，我们会遇到一些问题。举个例子，考虑加法
    +2 和 -2：
- en: '![Image](../images/pg71_Image_26.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg71_Image_26.jpg)'
- en: The result, `1100`[2], is equal to –4[10] in our code, which is arithmetically
    incorrect. The simple addition we used for unsigned numbers will not work correctly
    for signed numbers when using a sign-magnitude code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，`1100`[2]，在我们的代码中等于 –4[10]，这在算术上是不正确的。我们对于无符号数使用的简单加法方法，在使用符号幅度码时，对于有符号数将无法正确工作。
- en: 'Some computer architectures do use 1 bit for the sign when using signed decimal
    integers. They have a special *signed add* instruction that handles cases like
    this. (A fun aside: such computers have both a +0 and a –0!) But most computers
    employ a different encoding to represent signed numbers that allows the use of
    a simple add instruction for signed addition. Let’s look at this now.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一些计算机架构在使用有符号十进制整数时确实使用1位作为符号位。它们有一个特殊的*有符号加法*指令来处理类似的情况。（顺便提一句：这类计算机有+0和–0！）但大多数计算机使用不同的编码方式来表示有符号数，从而允许使用简单的加法指令进行有符号加法。让我们现在来看一下。
- en: '***Understanding Two’s Complement***'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***理解二的补码***'
- en: In mathematics, the *complement* of a quantity is the amount that must be added
    to make it “whole.” When applying this concept to numbers, the definition of *whole*
    depends on the radix (or base) you’re working in and the number of digits you
    allow to represent the numbers. If *x* is an *n*-digit number in radix *r*, its
    *radix complement*, ¬*x*, is defined such that *x* + (¬*x*) = *radix^n*, where
    *radix^n* is 1 followed by *n* 0s. For example, if we’re working with two-digit
    decimal numbers, then the radix complement of 37 is 63, because 37 + 63 = 10²
    = 100\. Another way of saying this is that adding a number to its radix complement
    results in 0, with a carry beyond the *n* digits.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，*补码*是指必须加上去才能使其“完整”的数值。当将这一概念应用于数字时，*完整*的定义取决于你所使用的基数（或进制）以及你允许表示数字的位数。如果*x*是基数*r*下的*n*位数，那么它的*基数补码*，¬*x*，被定义为使得*x*
    + (¬*x*) = *radix^n*，其中*radix^n*是1后跟*n*个0。例如，如果我们使用的是两位十进制数，那么37的基数补码是63，因为37
    + 63 = 10² = 100。换句话说，将一个数字与它的基数补码相加会得到0，进位超出*n*位数。
- en: 'Another useful concept is the *diminished radix complement*, which is defined
    such that *x* + *diminished_radix_complement* = *radix^n* – 1\. For example, the
    diminished radix complement of 37 is 62, because 37 + 62 = 10² – 1 = 99\. If you
    add a number to its diminished radix complement, the result is *n* of the largest
    digits in the radix: two 9s in this example of two digits in radix 10.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的概念是*缩小基数补码*，它的定义是使得*x* + *diminished_radix_complement* = *radix^n* – 1。例如，37的缩小基数补码是62，因为37
    + 62 = 10² – 1 = 99。如果你将一个数字与它的缩小基数补码相加，结果是基数中最大位数的*n*个数字：在这个例子中是两个9（基数10的两位数）。
- en: To see how the radix complement can be used to represent negative numbers, consider
    an audiotape cassette player, which plays a cassette tape containing magnetic
    tape wound back and forth between two spools.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解基数补码如何表示负数，考虑一个录音带播放器，它播放一盘包含磁带的录音带，磁带在两个卷轴之间来回绕动。
- en: The audio recording on the tape is an analog signal that does not include information
    about the position along the tape. Many audiotape cassette players have a four-digit
    counter that represents the tape position. You can insert a tape cassette and
    push a reset button to set the counter to 0000\. As you move the tape forward
    and backward, the counter registers the movement. These counters provide a “coded”
    representation of the relative tape position in arbitrary units. Now, assume we
    can insert a cassette, somehow move it to its center, and push the reset button.
    Moving the tape forward—in the positive direction—will cause the counter to increment.
    Moving the tape backward—in the negative direction—will cause the counter to decrement.
    In particular, if we start at 0000 and move to +1, the “code” on the tape counter
    will show 0001\. On the other hand, if we start at 0000 and move to –1, the “code”
    on the tape counter will show 9999.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 磁带上的音频录音是一个模拟信号，不包含关于磁带位置的信息。许多录音带播放器都有一个四位数的计数器，表示磁带的位置。你可以插入一盘磁带并按下重置按钮，将计数器设为0000。当你向前或向后移动磁带时，计数器会记录移动。这些计数器提供了磁带位置的“编码”表示，单位是任意的。现在，假设我们可以插入一盘磁带，设法将其移到中心，然后按下重置按钮。向前移动磁带（正方向）将使计数器递增。向后移动磁带（负方向）将使计数器递减。特别地，如果我们从0000开始，移动到+1，磁带计数器上的“代码”将显示0001。另一方面，如果我们从0000开始，移动到–1，磁带计数器上的“代码”将显示9999。
- en: 'We can use our tape system to perform the arithmetic in the previous example,
    (+2) + (–2):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用磁带系统执行之前示例中的运算，(+2) + (–2)：
- en: Move the tape forward to (+2); the counter shows 0002.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将磁带向前移动到(+2)；计数器显示0002。
- en: Add (–2) by moving the tape backward two steps on the counter; the counter now
    shows 0000, which is 0 according to our code.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将磁带向后移动两步，给计数器加上(–2)；现在计数器显示0000，这在我们的编码中代表0。
- en: 'Next, we’ll perform the same arithmetic starting with (–2) and then adding
    (+2):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将执行相同的运算，从(–2)开始，然后加上(+2)：
- en: Move the tape backward to (–2); the counter shows 9998.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将磁带向后移动到(–2)；计数器显示9998。
- en: Add (+2) by moving the tape forward two steps on the counter; the counter now
    shows 0000, but there is a carry (9998 + 2 = 0000 with carry = 1).
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将磁带向前移动两步，给计数器加上(+2)；现在计数器显示0000，但有进位（9998 + 2 = 0000，进位 = 1）。
- en: 'If we ignore the carry, the answer is correct: 9998 is the 10’s complement
    (the radix is 10) of 0002\. When adding two signed integers using radix complement
    notation, the carry is irrelevant. Adding two signed numbers can give a result
    that will not fit within the number of bits allocated for storing the result,
    just as with unsigned numbers. But our tape example just illustrated that the
    carry flag will probably not show us that the result will not fit. We will discuss
    this issue in the next section.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忽略进位，答案是正确的：9998 是 0002 的 10 的补码（基数为 10）。当使用基数补码表示法加两个带符号整数时，进位是无关紧要的。加两个带符号数字时，结果可能无法适应为存储结果分配的位数，就像无符号数字一样。但是我们的“磁带”示例刚刚说明，进位标志可能不会告诉我们结果无法适应。我们将在下一节讨论这个问题。
- en: Computers work in the binary number system, where the radix is 2\. Let’s look
    at the *two’s complement* notation for representing signed integers. It uses the
    same general pattern as the tape counter for representing signed decimal integers
    in bit patterns.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机使用二进制数字系统，其中的基数是 2。让我们来看一下用于表示带符号整数的 *二进制补码* 表示法。它使用与带符号十进制整数在位模式中表示的“磁带计数器”相同的通用模式。
- en: '[Table 3-2](ch03.xhtml#ch3tab2) shows the correspondence between hexadecimal,
    binary, and signed decimal (in two’s complement notation) for 4-bit values. In
    binary, moving the “tape” one place back (negative) from 0 would go from `0000`
    to `1111`. In hexadecimal, it would go from `0` to `f`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-2](ch03.xhtml#ch3tab2) 显示了 4 位值的十六进制、二进制和带符号十进制（以二进制补码表示法）之间的对应关系。在二进制中，将“磁带”从
    0 向后移动一位（负数），从 `0000` 到 `1111`。在十六进制中，从 `0` 到 `f`。'
- en: '**Table 3-2:** Four-Bit Two’s Complement Notation'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-2：** 四位二进制补码表示法'
- en: '| **One hexadecimal digit** | **Four binary digits (bits)** | **Signed decimal**
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **一个十六进制数字** | **四个二进制数字（位）** | **带符号十进制** |'
- en: '| --- | --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `8` | `1000` | –8 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `8` | `1000` | –8 |'
- en: '| `9` | `1001` | –7 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `9` | `1001` | –7 |'
- en: '| `a` | `1010` | –6 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `a` | `1010` | –6 |'
- en: '| `b` | `1011` | –5 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `b` | `1011` | –5 |'
- en: '| `c` | `1100` | –4 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `c` | `1100` | –4 |'
- en: '| `d` | `1101` | –3 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `d` | `1101` | –3 |'
- en: '| `e` | `1110` | –2 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `e` | `1110` | –2 |'
- en: '| `f` | `1111` | –1 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `f` | `1111` | –1 |'
- en: '| `0` | `0000` |   0 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0000` |   0 |'
- en: '| `1` | `0001` | +1 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0001` | +1 |'
- en: '| `2` | `0010` | +2 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `0010` | +2 |'
- en: '| `3` | `0011` | +3 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `0011` | +3 |'
- en: '| `4` | `0100` | +4 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `4` | `0100` | +4 |'
- en: '| `5` | `0101` | +5 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `5` | `0101` | +5 |'
- en: '| `6` | `0110` | +6 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `6` | `0110` | +6 |'
- en: '| `7` | `0111` | +7 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `7` | `0111` | +7 |'
- en: 'Here are some important observations about this table:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于此表的一些重要观察：
- en: The high-order bit of each positive number is `0`, and the high-order bit of
    each negative number is `1`.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个正数的高位是 `0`，每个负数的高位是 `1`。
- en: Although changing the sign of (*negating*) a number is more complicated than
    simply changing the high-order bit, it is common to call the high-order bit the
    *sign bit*.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管改变一个数字的符号（即取反）比单纯改变高位更复杂，但通常会将高位称为 *符号位*。
- en: The notation allows for one more negative number than positive numbers.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该表示法允许比正数多一个负数。
- en: The range of integers, *x*, that can be represented in this notation (with 4
    bits) is
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种表示法（使用 4 位）能够表示的整数范围 *x* 为：
- en: '![Image](../images/pg73_Image_27.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg73_Image_27.jpg)'
- en: 'or:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '![Image](../images/pg73_Image_28.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg73_Image_28.jpg)'
- en: 'The last observation can be generalized for *n* bits to the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的观察可以推广到 *n* 位的以下公式：
- en: '![Image](../images/pg73_Image_29.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg73_Image_29.jpg)'
- en: 'When using two’s complement notation, the negative of any *n*-bit integer *x*
    is defined as:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二进制补码表示法时，任何 *n* 位整数 *x* 的负值定义为：
- en: '![Image](../images/pg73_Image_30.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg73_Image_30.jpg)'
- en: Notice that 2*^n* written in binary is `1` followed by *n* `0`s. In other words,
    in the *n*-bit two’s complement notation, adding a number to its negative produces
    *n* `0`s and a carry of `1`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，2*^n* 在二进制中写成 `1` 后跟 *n* 个 `0`。换句话说，在 *n* 位二进制补码表示法中，将一个数加上它的负值会得到 *n* 个
    `0` 和一个进位 `1`。
- en: '#### ***Computing Two’s Complement***'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***计算二进制补码***'
- en: 'We’ll derive a way to compute the negative of a number by using two’s complement
    notation. Solving the defining equation for –*x*, we get:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用二进制补码表示法推导出计算一个数字负值的方法。解出 *x* 的定义方程，我们得到：
- en: '![Image](../images/pg74_Image_31.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg74_Image_31.jpg)'
- en: This may look odd to a mathematician, but keep in mind that *x* in this equation
    is restricted to *n* bits, while 2*^n* has *n* + 1 bits (`1` followed by *n* `0`s).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这对数学家来说可能看起来很奇怪，但请记住，在这个方程中，*x* 被限制为 *n* 位，而 2*^n* 有 *n* + 1 位（`1` 后跟 *n* 个
    `0`）。
- en: 'For example, if we want to compute –123 in binary (using two’s complement notation)
    in 8 bits, we perform the arithmetic:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想在8位二进制中计算–123（使用二的补码表示），我们进行如下算术运算：
- en: '![Image](../images/pg74_Image_32.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg74_Image_32.jpg)'
- en: 'This subtraction operation is error-prone, so let’s do a bit of algebra on
    our equation for computing –*x*. We’ll subtract 1 from both sides and rearrange
    a little:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个减法运算容易出错，所以让我们对计算–*x*的方程式做一些代数处理。我们将两边都减去1，并稍微调整一下：
- en: '![Image](../images/pg74_Image_33.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg74_Image_33.jpg)'
- en: 'This gives us:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了：
- en: '![Image](../images/pg74_Image_34.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg74_Image_34.jpg)'
- en: 'If this looks more complicated than our first equation, don’t worry. Let’s
    consider the quantity (2*^n* – 1). Since 2*^n* is written in binary as `1` followed
    by *n* `0`s, (2*^n* – 1) is written as *n* `1`s. For example, for *n* = 8:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来比我们的第一个方程式更复杂，不用担心。我们来考虑量 (2*^n* – 1)。因为 2*^n* 在二进制中是 `1` 后跟 *n* 个 `0`，所以
    (2*^n* – 1) 就是 *n* 个 `1`。例如，对于 *n* = 8：
- en: '![Image](../images/pg74_Image_35.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg74_Image_35.jpg)'
- en: Thus, we can say
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以说：
- en: '![Image](../images/pg74_Image_36.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg74_Image_36.jpg)'
- en: where 11 *. . .* 1[2] designates *n* `1`s.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 11 *. . .* 1[2] 表示 *n* 个`1`。
- en: 'Although it may not be immediately obvious, you’ll see how easy this subtraction
    is when you consider the previous example of computing –123 in 8-bit binary. Let
    *x* = 123, giving:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能一开始不明显，但当你考虑之前在8位二进制下计算–123的示例时，你会发现这个减法是多么简单。设 *x* = 123，得到：
- en: '![Image](../images/pg74_Image_37.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg74_Image_37.jpg)'
- en: 'Or, in hexadecimal, giving:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用十六进制表示，得到：
- en: '![Image](../images/pg74_Image_38.jpg) Since all the quantities here have *n*
    bits, this computation is easy—simply flip all the bits, giving the diminished
    radix complement, also called the *one’s complement* in the binary number system.
    A `1` becomes a `0` and a `0` becomes a `1`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg74_Image_38.jpg) 因为这里所有量都有 *n* 位，所以这个计算很简单——只需翻转所有位，得到减小的基数补码，也称为二进制系统中的*一的补码*。`1`变为`0`，`0`变为`1`。'
- en: 'All that remains to compute the negative is to add `1` to the result. Finally,
    we have the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 计算负数所需要做的就是将`1`加到结果中。最后，我们得到以下结果：
- en: '![Image](../images/pg75_Image_39.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg75_Image_39.jpg)'
- en: '**HINT**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '*To double-check your arithmetic, pay attention to whether the value you are
    converting is even or odd. It will be the same in all number bases.*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了重新检查你的算术运算，注意你正在转换的数值是偶数还是奇数。这在所有数字进制中都是相同的。*'
- en: '**YOUR TURN**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮到你了**'
- en: 3.6     Develop an algorithm to convert signed decimal integers to two’s complement
    binary.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 3.6     开发一个算法，将带符号十进制整数转换为二的补码二进制。
- en: 3.7     Develop an algorithm to convert integers in two’s complement binary
    notation to signed decimal.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 3.7     开发一个算法，将二的补码二进制表示的整数转换为带符号十进制。
- en: 3.8     The following 16-bit hexadecimal values are stored in two’s complement
    notation. What are the equivalent signed decimal numbers?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 3.8     以下16位十六进制值以二的补码表示。它们对应的带符号十进制数是什么？
- en: (a)     `1234`
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: (a)     `1234`
- en: (b)     `ffff`
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: (b)     `ffff`
- en: (c)     `8000`
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: (c)     `8000`
- en: (d)     `7fff`
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: (d)     `7fff`
- en: '3.9     Show how each of the following signed decimal integers would be stored
    in 16-bit two’s complement notation. Give your answers in hexadecimal:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 3.9     展示如何将以下每个带符号十进制整数存储为16位二的补码表示。请用十六进制给出你的答案：
- en: (a)     +1,024
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: (a)     +1,024
- en: (b)     –1,024
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: (b)     –1,024
- en: (c)     –256
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: (c)     –256
- en: (d)     –32,767
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: (d)     –32,767
- en: '**Adding and Subtracting Signed Integers in Binary**'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**二进制中带符号整数的加法与减法**'
- en: The number of bits used to represent a value is determined at the time a program
    is written by the computer architecture and programming language used. This is
    why you can’t just add more digits (bits) if the result is too large, as you would
    on paper. For unsigned integers, the solution to this problem is the carry flag,
    which indicates when the sum of two unsigned integers exceeds the number of bits
    allocated for it. In this section, you’ll learn that adding two signed numbers
    can also produce a result that exceeds the allocated number of bits, but in this
    case, the carry flag alone does not indicate the error.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 用来表示值的位数是在程序编写时由计算机架构和使用的编程语言决定的。这就是为什么如果结果过大，你不能像在纸上那样增加更多数字（位）。对于无符号整数，解决这个问题的方法是进位标志，它指示两个无符号整数的和是否超过了分配给它的位数。在这一节中，你将学习到，两个带符号数相加也可能会得到超过分配位数的结果，但在这种情况下，只有进位标志并不能指示错误。
- en: 'The CPU can indicate when the sum of signed numbers has gotten too big for
    its bits by using the *overflow flag*, `V`. The value of the overflow flag is
    given by an operation that may not seem intuitive at first: the *exclusive or
    (XOR)* of the penultimate and ultimate carries. As an example, let’s say we’re
    adding the two 8-bit numbers `15`[16] and `6f`[16]:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 可以通过使用 *溢出标志* `V` 来指示符号数的和超出了它的位数。溢出标志的值是通过一个可能一开始看起来不直观的操作计算得出的：倒数第二个进位和最终进位的
    *异或 (XOR)* 运算。举个例子，假设我们正在相加两个 8 位数 `15`[16] 和 `6f`[16]：
- en: '![Image](../images/pg76_Image_40.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg76_Image_40.jpg)'
- en: In this example, the carry is `0` and the penultimate carry is `1`. The `V`
    flag is equal to the XOR of the ultimate carry and penultimate carry, `V` = `C`
    ⊻ *(penultimate_carry)*, where ⊻ is the XOR operator. In this case, `V` = `0`
    ⊻ `1` = `1`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，进位是 `0`，倒数第二个进位是 `1`。`V` 标志等于最终进位和倒数第二个进位的异或，`V` = `C` ⊻ *(penultimate_carry)*，其中
    ⊻ 是异或运算符。在这个例子中，`V` = `0` ⊻ `1` = `1`。
- en: 'Case by case, we’ll see why the `V` flag indicates the validity of adding two
    signed integers in the two’s complement representation. In the next three sections,
    we’ll discuss the three possible cases: the two numbers can have opposite signs,
    both be positive, or both be negative.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 逐一查看，我们会看到为什么 `V` 标志指示了在二进制补码表示下加法结果的有效性。在接下来的三节中，我们将讨论三种可能的情况：两个数的符号相反，两个数都为正，或者两个数都为负。
- en: '***Two Numbers of the Opposite Sign***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***符号相反的两个数***'
- en: 'Let *x* be the negative number and *y* the positive number. We can express
    *x* and *y* in binary as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 设 *x* 为负数，*y* 为正数。我们可以将 *x* 和 *y* 表示为二进制如下：
- en: '![Image](../images/f0076-01.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0076-01.jpg)'
- en: That is, the high-order (sign) bit of one number is `1` and the high-order (sign)
    bit of the other is `0`, regardless of what the other bits are.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，一个数的高位（符号位）是 `1`，而另一个数的高位（符号位）是 `0`，无论其他位是什么。
- en: 'The result of *x* + *y* always remains within the range of the two’s complement
    representation:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* + *y* 的结果始终保持在二进制补码表示的范围内：'
- en: '![Image](../images/pg76_Image_41.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg76_Image_41.jpg)'
- en: 'If we add *x* and *y*, there are two possible carry results:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 *x* 和 *y* 相加，可能会有两种进位结果：
- en: 'If the penultimate carry is `0`:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果倒数第二个进位是 `0`：
- en: '![Image](../images/pg76_Image_42.jpg) *   If the penultimate carry is `1`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg76_Image_42.jpg) * 如果倒数第二个进位是 `1`：'
- en: '![Image](../images/pg77_Image_43.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg77_Image_43.jpg)'
- en: Adding two integers of opposite signs always yields `0` for the overflow flag,
    so the sum is always within the allocated range.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 相加两个符号相反的整数时，溢出标志 `0` 总是为零，因此和始终在分配的范围内。
- en: '***Two Positive Numbers***'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***两个正数***'
- en: 'If both *x* and *y* are positive, we can express them in binary as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *x* 和 *y* 都是正数，我们可以将它们表示为二进制如下：
- en: '![Image](../images/pg77_Image_44.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg77_Image_44.jpg)'
- en: Here, the high-order (sign) bit of both numbers is `0`, regardless of what the
    other bits are.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，无论其他位是什么，两个数的高位（符号位）都是 `0`。
- en: 'Again, if we add *x* and *y*, there are two possible carry results:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果我们将 *x* 和 *y* 相加，可能会有两种进位结果：
- en: 'If the penultimate carry is `0`:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果倒数第二个进位是 `0`：
- en: '![Image](../images/pg77_Image_45.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg77_Image_45.jpg)'
- en: This addition produces `V = 0` ⊻ `0 = 0`. The high-order bit of the sum is `0`,
    so it’s a positive number, and the sum is in range.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个加法产生了 `V = 0` ⊻ `0 = 0`。和的高位是 `0`，因此是正数，并且和在范围内。
- en: 'If the penultimate carry is `1`:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果倒数第二个进位是 `1`：
- en: '![Image](../images/pg77_Image_46.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg77_Image_46.jpg)'
- en: This addition produces `V = 0` ⊻ `1 = 1`. The high-order bit of the sum is `1`,
    so it’s a negative number. Adding two positive numbers cannot give a negative
    sum, so the sum must have exceeded the allocated range.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个加法产生了 `V = 0` ⊻ `1 = 1`。和的高位是 `1`，因此是负数。两个正数相加不可能得到负数，因此和必定超出了分配的范围。
- en: '***Two Negative Numbers***'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***两个负数***'
- en: 'If both *x* and *y* are negative, we can express them in binary as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *x* 和 *y* 都是负数，我们可以将它们表示为二进制如下：
- en: '![Image](../images/pg77_Image_47.jpg) In this case, the high-order (sign) bit
    of both numbers is `1`, regardless of what the other bits are.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg77_Image_47.jpg) 在这种情况下，两个数的高位（符号位）都是 `1`，无论其他位是什么。'
- en: 'If we add *x* and *y*, there are two possible carry results:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 *x* 和 *y* 相加，可能会有两种进位结果：
- en: If the penultimate carry is `0`:![Image](../images/pg78_Image_48.jpg)
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果倒数第二个进位是 `0`：![Image](../images/pg78_Image_48.jpg)
- en: This gives `V = 1` ⊻ `0 = 1`. The high-order bit of the sum is `0`, so it’s
    a positive number. But adding two negative numbers cannot give a positive sum,
    so the sum has exceeded the allocated range.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '这给出了`V = 1` ⊻ `0 = 1`。和的高位是`0`，所以它是正数。但两个负数相加不能得到正数，因此和已经超出了分配的范围。  '
- en: If the penultimate carry is `1`:![Image](../images/pg78_Image_49.jpg)
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果倒数第二个进位是`1`：![Image](../images/pg78_Image_49.jpg)  '
- en: This gives `V = 1` ⊻ `1 = 0`. The high-order bit of the sum is `1`, so it’s
    a negative number and the sum is within range.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '这给出了`V = 1` ⊻ `1 = 0`。和的高位是`1`，所以它是负数，且和在范围内。  '
- en: We won’t go into subtraction here. The same rules apply there, and I invite
    you to explore them on your own.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在这里不会讨论减法。相同的规则也适用，邀请你自行探索。  '
- en: 'We can state the following rules for adding or subtracting two *n*-bit numbers,
    based on what you just learned and what we did in “Unsigned Integers in the Binary
    System” on [page 40](ch03.xhtml#ch03lev1sec2):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以根据你刚才学到的内容以及我们在[第40页](ch03.xhtml#ch03lev1sec2)《二进制系统中的无符号整数》中所做的内容，陈述以下加法或减法规则：  '
- en: When the program treats the result as unsigned, the carry flag, `C`, is `0`
    if and only if the result is within the *n*-bit range; `V` is irrelevant.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '当程序将结果视为无符号时，进位标志`C`的值为`0`，当且仅当结果在*n*位范围内；`V`不相关。  '
- en: When the program treats the result as signed, the overflow flag, `V`, is `0`
    if and only if the result is within the *n*-bit range; `C` is irrelevant.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '当程序将结果视为有符号时，溢出标志`V`的值为`0`，当且仅当结果在*n*位范围内；`C`不相关。  '
- en: '**NOTE**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**  '
- en: '*Using two’s complement notation means the CPU does not need additional instructions
    for signed addition and subtraction, thus simplifying the hardware. The CPU just
    sees bit patterns. The AArch64 architecture includes add and subtract instructions
    that set* C *and* V *according to the rules of the respective binary arithmetic
    operation, regardless of how the program treats the numbers. The distinction between
    signed and unsigned is completely determined by the program. After each addition
    or subtraction operation, the program should check the state of* C *for unsigned
    integers or* V *for signed integers and at least indicate when the sum is in error.
    Many high-level languages do not perform this check, which can lead to some obscure
    program bugs.*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用二进制补码表示法意味着CPU不需要额外的指令来进行有符号加法和减法，从而简化了硬件。CPU只看到位模式。AArch64架构包括加法和减法指令，根据相应二进制运算规则设置*
    C *和* V *，无论程序如何处理数字。有符号和无符号的区别完全由程序决定。每次加法或减法操作后，程序应检查无符号整数的* C *或有符号整数的* V *的状态，并至少指示和是否出错。许多高级语言不会执行此检查，这可能导致一些难以察觉的程序错误。*  '
- en: '### **The Circular Nature of Integer Codes**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '### **整数编码的循环特性**  '
- en: The notations used for both unsigned integers and signed integers are circular
    in nature—for a given number of bits, each code “wraps around.” [Figure 3-1](ch03.xhtml#ch3fig1)
    shows this using the “decoder ring” for 3-bit numbers.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '无符号整数和有符号整数使用的符号表示法具有循环特性——对于给定的位数，每个编码“回绕”。[图 3-1](ch03.xhtml#ch3fig1)使用3位数字的“解码环”展示了这一点。  '
- en: '![Image](../images/pg79_Image_50.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg79_Image_50.jpg)  '
- en: '*Figure 3-1: A “decoder ring” for 3-bit signed and unsigned integers*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：3位有符号和无符号整数的“解码环”*  '
- en: 'To use this decoder ring to add or subtract two integers, follow these steps:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '要使用此解码环加法或减法两个整数，请按照以下步骤操作：  '
- en: Pick the ring corresponding to the type of integer you’re using (signed or unsigned).
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '选择与所用整数类型（有符号或无符号）对应的解码环。  '
- en: Move to the location on that ring corresponding to the first integer.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '移动到解码环上对应第一个整数的位置。  '
- en: Move along that ring the number of “spokes” equal to the second integer. Move
    clockwise to add and counterclockwise to subtract.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 沿着该环移动与第二个整数相等的“辐条”数量。顺时针移动表示加法，逆时针移动表示减法。
- en: The result is correct if you do not cross the top for unsigned integers or cross
    the bottom for signed integers.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '如果未超出无符号整数的上限或未超出有符号整数的下限，则结果是正确的。  '
- en: '**YOUR TURN**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮到你了**  '
- en: '3.10     Use the decoder ring in [Figure 3-1](ch03.xhtml#ch3fig1) to perform
    the following arithmetic. Indicate whether the result is “right” or “wrong”:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '3.10 使用[图 3-1](ch03.xhtml#ch3fig1)中的解码环进行以下算术运算。请指出结果是“正确”还是“错误”：  '
- en: '(a)     Unsigned integers: 1 + 3'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '(a) 无符号整数：1 + 3  '
- en: '(b)     Unsigned integers: 3 + 4'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '(b) 无符号整数：3 + 4  '
- en: '(c)     Unsigned integers: 5 + 6'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '(c) 无符号整数：5 + 6  '
- en: '(d)     Signed integers: (+1) + (+3)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '(d) 有符号整数：（+1）+（+3）  '
- en: '(e)     Signed integers: (–3) – (+3)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '(e) 有符号整数：（–3）–（+3）  '
- en: '(f)     Signed integers: (+3) + (–4)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: (f)     有符号整数：（+3）+（–4）
- en: '3.11     Add the following pairs of 8-bit numbers (shown in hexadecimal) and
    indicate whether your result is “right” or “wrong.” First treat them as unsigned
    values and then as signed values (stored in two’s complement):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 3.11     将下列一对8位数字（以十六进制显示）相加，并指明结果是“正确”还是“错误”。首先将它们视为无符号值，然后再视为有符号值（以二补码存储）：
- en: (a)     `55 + aa`
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: (a)     `55 + aa`
- en: (b)     `55 + f0`
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: (b)     `55 + f0`
- en: (c)     `80 + 7b`
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: (c)     `80 + 7b`
- en: (d)     `63 + 7b`
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: (d)     `63 + 7b`
- en: (e)     `0f + ff`
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: (e)     `0f + ff`
- en: (f)     `80 + 80`
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: (f)     `80 + 80`
- en: '3.12     Add the following pairs of 16-bit numbers (shown in hexadecimal) and
    indicate whether your result is “right” or “wrong.” First treat them as unsigned
    values and then as signed values (stored in two’s complement):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 3.12     将下列一对16位数字（以十六进制显示）相加，并指明结果是“正确”还是“错误”。首先将它们视为无符号值，然后再视为有符号值（以二补码存储）：
- en: (a)     `1234 + edcc`
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: (a)     `1234 + edcc`
- en: (b)     `1234 + fedc`
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: (b)     `1234 + fedc`
- en: (c)     `8000 + 8000`
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: (c)     `8000 + 8000`
- en: (d)     `0400 + ffff`
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: (d)     `0400 + ffff`
- en: (e)     `07d0 + 782f`
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: (e)     `07d0 + 782f`
- en: (f)     `8000 + ffff`
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: (f)     `8000 + ffff`
- en: '**What You’ve Learned**'
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你所学到的**  '
- en: '**Binary arithmetic**   Computers perform addition and subtraction in the binary
    number system. Addition of two numbers may yield a result that is 1 bit wider
    than each of the two numbers. Subtraction of one number from another may require
    borrowing from 1 bit beyond the width of the two numbers.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**二进制运算**   计算机在二进制数字系统中执行加法和减法。两个数字相加可能会得到一个比每个数字宽1位的结果。从一个数字中减去另一个数字可能需要从超出两个数字宽度的1位借位。'
- en: '**Representing signed/unsigned**   Bit patterns can be treated as representing
    either signed or unsigned integers. Two’s complement notation is commonly used
    to represent signed integers.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**有符号/无符号表示**   位模式可以被视为表示有符号或无符号整数。二补码表示法通常用于表示有符号整数。'
- en: '**Carry flag**   The CPU includes a 1-bit carry flag, `C`, that can show whether
    the result of addition or subtraction exceeds the number of bits allowed for an
    unsigned integer.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**进位标志**   CPU包括一个1位的进位标志`C`，它可以显示加法或减法的结果是否超过了无符号整数所允许的位数。'
- en: '**Overflow flag**   The CPU includes a 1-bit overflow flag, `V`, that can show
    whether the result of addition or subtraction exceeds the number of bits allowed
    for a signed integer using two’s complement notation.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**溢出标志**   CPU包括一个1位的溢出标志`V`，它可以显示加法或减法的结果是否超过了使用二补码表示的有符号整数所允许的位数。'
- en: In the next chapter, you’ll learn how to perform Boolean algebra. Although it
    may seem a bit strange at first, once we get going, you’ll see that it’s actually
    easier than elementary algebra. For one thing, everything evaluates to either
    `0` or `1`!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将学习如何进行布尔代数。虽然一开始可能觉得有点陌生，但一旦我们开始，你会发现它实际上比初等代数要简单。因为在布尔代数中，所有的结果都只会是`0`或`1`！
