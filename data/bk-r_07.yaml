- en: '**6**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6**'
- en: '**SPECIAL VALUES, CLASSES, AND COERCION**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**特殊值、类和强制转换**'
- en: '![image](../images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common-01.jpg)'
- en: You’ve now learned about numeric values, logicals, character strings, and factors,
    as well as their unique properties and applications. Now you’ll look at some special
    values in R that aren’t as well-defined. You’ll see how they might come about
    and how to handle and test for them. Then you’ll look at different data types
    in R and some general object class concepts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经了解了数值型、逻辑型、字符型和因子型，以及它们的独特属性和应用。接下来，你将学习 R 中一些不太明确的特殊值。你将看到它们是如何产生的，以及如何处理和测试它们。然后，你将了解
    R 中的不同数据类型以及一些通用的对象类概念。
- en: '**6.1 Some Special Values**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.1 一些特殊值**'
- en: Many situations in R call for special values. For example, when a data set has
    missing observations or when a practically infinite number is calculated, the
    software has some unique terms that it reserves for these situations. These special
    values can be used to mark abnormal or missing values in vectors, arrays, or other
    data structures.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，许多情况需要使用特殊值。例如，当数据集中存在缺失的观测值，或者计算出一个近似无限大的数时，软件会为这些情况保留一些特殊的术语。这些特殊值可以用于标记向量、数组或其他数据结构中的异常值或缺失值。
- en: '***6.1.1 Infinity***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.1.1 无限大***'
- en: In [Section 2.1](ch02.xhtml#ch02lev1sec09), I mentioned that R imposes limits
    on how extreme a number can be before the software cannot reliably represent it.
    When a number is too large for R to represent, the value is deemed to be *infinite*.
    Of course, the mathematical concept of infinity (∞) does not correspond to a specific
    number—R simply has to define an extreme cutoff point. The precise cutoff value
    varies from system to system and is governed in part by the amount of memory R
    has access to. This value is represented by the special object `Inf`, which is
    case sensitive. Because it represents a numeric value, `Inf` can be associated
    only with numeric vectors. Let’s create some objects to test it out.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2.1节](ch02.xhtml#ch02lev1sec09)中，我提到过 R 对数字的极限有一定的限制，当数字过大，软件无法可靠地表示时，值会被认为是*无限大*。当然，数学中的无限大（∞）并不对应一个特定的数字——R
    只需要定义一个极限值。这个精确的截止值会因系统而异，部分由 R 可以访问的内存量决定。这个值由特殊对象 `Inf` 表示，大小写敏感。因为它代表一个数值，`Inf`
    只能与数值型向量关联。让我们创建一些对象来进行测试。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, you’ve defined an object `foo` that is a single instance of an infinite
    value. You’ve also defined a numeric vector, `bar`, with two infinite elements,
    and then raised 90,000 to a power of 100 in `baz` to produce a result R deems
    infinite.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你定义了一个对象 `foo`，它是一个无限大值的单一实例。你还定义了一个数值向量 `bar`，其中包含两个无限大元素，然后在 `baz` 中将 90,000
    的 100 次方运算得到 R 认为是无限大的结果。
- en: R can also represent negative infinity, with `-Inf`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: R 还可以表示负无穷，用 `-Inf` 表示。
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This creates a vector with two negative-infinite values and one positive-infinite
    value.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个包含两个负无穷值和一个正无穷值的向量。
- en: Though infinity does not represent any specific value, to a certain extent you
    can still perform mathematical operations on infinite values in R. For example,
    multiplying `Inf` by any negative value will result in `-Inf`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管无限大并不代表任何特定的数值，但在一定程度上，你仍然可以在 R 中对无限大值进行数学运算。例如，将 `Inf` 乘以任何负数将得到 `-Inf`。
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you add to or multiply infinity, you also get infinity as a result.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对无限大进行加法或乘法运算，结果仍然是无限大。
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Zero and infinity go hand in hand when it comes to division. Any (finite) numeric
    value divided by infinity, positive or negative, will result in zero.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 零与无限大在除法运算中是密切相关的。任何（有限的）数值除以正或负的无限大都会得到零。
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Though it isn’t mathematically defined, note that in R, any nonzero value divided
    by zero will result in infinity (positive or negative depending on the sign of
    the numerator).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在数学上没有明确的定义，但请注意，在 R 中，任何非零值除以零都会得到无限大（根据分子符号的不同，可能是正无穷或负无穷）。
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Often, you’ll simply want to detect infinite values in a data structure. The
    functions `is.infinite` and `is.finite` take in a collection of values, typically
    a vector, and return for each element a logical value answering the question posed.
    Here’s an example using `qux` from earlier:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你只是想检测数据结构中的无限大值。`is.infinite` 和 `is.finite` 函数接受一个值的集合，通常是一个向量，并为每个元素返回一个逻辑值，回答提出的问题。这里是一个使用之前的
    `qux` 的例子：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that these functions do not distinguish between positive or negative infinity,
    and the result of `is.finite` will always be the opposite (the negation) of the
    result of `is.infinite`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些函数不会区分正无穷和负无穷，而`is.finite`的结果总是与`is.infinite`的结果相反（即否定）。
- en: Finally, relational operators function as you might expect.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关系运算符的功能如你所预期的那样。
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, the first line confirms that `-Inf` is indeed treated as less than `Inf`,
    and the second line shows that `Inf` is not greater than `Inf`. The third and
    fourth lines, again using `qux`, test for equality, which is a useful way to distinguish
    between positive and negative infinity if you need to.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第一行确认`-Inf`确实被视为小于`Inf`，第二行显示`Inf`不是大于`Inf`。第三行和第四行再次使用`qux`，测试等式，这是区分正负无穷的一个有用方式，特别是如果你需要做这样的区分。
- en: '***6.1.2 NaN***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.1.2 NaN***'
- en: In some situations, it’s impossible to express the result of a calculation using
    a number, `Inf`, or `-Inf`. These difficult-to-quantify special values are labeled
    `NaN` in R, which stands for *Not a Number*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，无法用数字、`Inf`或`-Inf`表示计算结果。这些难以量化的特殊值在R中被标记为`NaN`，即*不是一个数字*。
- en: As with infinite values, `NaN` values are associated only with numeric observations.
    It’s possible to define or include a `NaN` value directly, but this is rarely
    the way they’re encountered.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 和无穷大值一样，`NaN`值仅与数值型观察相关。虽然可以直接定义或包含`NaN`值，但这并不是它们常见的方式。
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Typically, `NaN` is the unintended result of attempting a calculation that’s
    impossible to perform with the specified values.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`NaN`是尝试进行无法执行的计算时的意外结果，计算中涉及的值不可用。
- en: In [Section 6.1.1](ch06.xhtml#ch06lev2sec55), you saw that adding or subtracting
    from `Inf` or `-Inf` will simply result again in `Inf` or `-Inf`. However, if
    you attempt to cancel representations of infinity in any way, the result will
    be `NaN`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6.1.1节](ch06.xhtml#ch06lev2sec55)中，你看到将`Inf`或`-Inf`加减后仍然得到`Inf`或`-Inf`。然而，如果你试图以任何方式抵消无穷大的表示，结果将是`NaN`。
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, the first line won’t result in zero because positive and negative infinity
    can’t be interpreted in that numeric sense, so you get `NaN` as a result. The
    same thing happens if you attempt to divide `Inf` by itself. In addition, although
    you saw earlier that a nonzero value divided by zero will result in positive or
    negative infinity, `NaN` results when *zero* is divided by zero.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一行不会得到零，因为正负无穷大不能以数值的方式进行解释，因此结果是`NaN`。如果你尝试将`Inf`除以它本身，也会出现相同的情况。此外，虽然你之前看到过非零值除以零会得到正无穷或负无穷，但当*零*除以零时，结果是`NaN`。
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that any mathematical operation involving `NaN` will simply result in `NaN`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，任何涉及`NaN`的数学运算都会简单地得到`NaN`。
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the first line, adding 1 to “not a number” is still `NaN`. In the second
    line, you obtain `NaN` from the `(4-4)/0`, which is clearly `0/0`, so the result
    is also `NaN`. In the third line, `NaN` results from `-Inf/Inf`, so the result
    of the remaining calculation is again `NaN`. This begins to give you an idea of
    how `NaN` or infinite values might unintentionally crop up. If you have a function
    where various values are passed to a fixed calculation and you don’t take care
    to prevent, for example, `0/0` from occurring, then the code will return `NaN`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，将1加到“不是一个数字”上仍然是`NaN`。在第二行，你从`(4-4)/0`中得到`NaN`，这显然是`0/0`，因此结果也是`NaN`。在第三行，`-Inf/Inf`的结果是`NaN`，因此剩余的计算结果再次是`NaN`。这开始让你明白`NaN`或无穷大的值是如何无意中出现的。如果你有一个函数，其中多个值被传递给固定计算，并且没有防止出现例如`0/0`的情况，那么代码将返回`NaN`。
- en: 'Like with `Inf`, a special function (`is.nan`) is used to detect the presence
    of `NaN` values. Unlike infinite values, however, relational operators cannot
    be used with `NaN`. Here’s an example using `bar`, which was defined earlier:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Inf`一样，使用特殊函数(`is.nan`)来检测`NaN`值的存在。然而，与无穷大值不同，关系运算符不能与`NaN`一起使用。这里是一个使用之前定义的`bar`的示例：
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using the `is.nan` function on `bar` flags the two `NaN` positions as `TRUE`.
    In the second example, you use the negation operator `!` to flag the positions
    where the elements are NOT `NaN`. Using the element-wise OR, `|` (see [Section
    4.1.3](ch04.xhtml#ch04lev2sec39)), you then identify elements that are either
    `NaN` OR infinite. Finally, the last line uses `which` to convert these logical
    values into numeric index positions so that you can remove them with negative
    indexes in square brackets (see [Section 4.1.5](ch04.xhtml#ch04lev2sec41) for
    a refresher on using `which`).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`is.nan`函数对`bar`进行操作，会将两个`NaN`位置标记为`TRUE`。在第二个示例中，你使用否定操作符`!`来标记那些元素不是`NaN`的位置。然后，使用按元素的逻辑“或”运算符`|`（参见[第4.1.3节](ch04.xhtml#ch04lev2sec39)），你可以识别那些既是`NaN`又是无限大的元素。最后，最后一行使用`which`将这些逻辑值转换为数字索引位置，这样你就可以通过方括号中的负索引将其移除（关于如何使用`which`的复习，请参见[第4.1.5节](ch04.xhtml#ch04lev2sec41)）。
- en: You can find more details on the functionality and behavior of `NaN` and `Inf`
    in the R help file by entering `?Inf` at the prompt.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在提示符下输入`?Inf`来获取更多关于`NaN`和`Inf`功能和行为的详细信息。
- en: '**Exercise 6.1**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 6.1**'
- en: 'Store the following vector:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储以下向量：
- en: '[PRE13]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, do the following:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，进行以下操作：
- en: Output all elements of `foo` that, when raised to a power of 75, are NOT infinite.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出所有`foo`中的元素，这些元素在升到75次方时不为无限大。
- en: Return the elements of `foo`, excluding those that result in negative infinity
    when raised to a power of 75.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`foo`的元素，排除那些在升到75次方时结果为负无穷大的元素。
- en: 'Store the following 3 × 4 matrix as the object `bar`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下3 × 4矩阵存储为对象`bar`：
- en: '![image](../images/f0108-01.jpg)'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0108-01.jpg)'
- en: 'Now, do the following:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，进行以下操作：
- en: Identify the coordinate-specific indexes of the entries of `bar` that are `NaN`
    when you raise `bar` to a power of 65 and divide by infinity.
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当将`bar`的元素升到65次方并除以无穷大时，识别出`NaN`的坐标特定索引。
- en: Return the values in `bar` that are NOT `NaN` when `bar` is raised to a power
    of 67 and infinity is added to the result. Confirm this is identical to identifying
    those values in `bar` that, when raised to a power of 67, are not equal to negative
    infinity.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`bar`中那些在`bar`升到67次方并加上无穷大后不为`NaN`的值。确认这与识别那些在升到67次方时不等于负无穷大的`bar`值是相同的。
- en: Identify those values in `bar` that are either negative infinity OR finite when
    you raise `bar` to a power of 67.
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将`bar`的元素升到67次方时，识别出那些负无穷大或有限的值。
- en: '***6.1.3 NA***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.1.3 NA***'
- en: In statistical analyses, data sets often contain missing values. For example,
    someone filling out a questionnaire may not respond to a particular item, or a
    researcher may record some observations from an experiment incorrectly. Identifying
    and handling missing values is important so that you can still use the rest of
    the data. R provides a standard special term to represent missing values, `NA`,
    which reads as *Not Available*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在统计分析中，数据集经常包含缺失值。例如，有人填写问卷时可能未回答某个项目，或者研究人员可能错误地记录了实验中的一些观察值。识别和处理缺失值很重要，这样你就可以继续使用其余数据。R提供了一个标准的特殊术语来表示缺失值，`NA`，即*不可用*。
- en: '`NA` entries are not the same as `NaN` entries. Whereas `NaN` is used only
    with respect to numeric operations, missing values can occur for any type of observation.
    As such, `NA`s can exist in both numeric and non-numeric settings. Here’s an example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`NA`条目与`NaN`条目不同。`NaN`仅用于数字操作，而缺失值可以出现在任何类型的观察值中。因此，`NA`可以存在于数字和非数字设置中。以下是一个示例：'
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The object `foo` is a character vector with entries 3 and 6 missing; `bar` is
    a factor vector of length 11 with elements 2, 3, 7, and 10 missing; and `baz`
    is a numeric matrix with row 1, columns 2 and 3, and row 3, column 3, elements
    missing. In the factor vector, note that the `NA`s are printed as `<NA>`. This
    is to differentiate between bona fide levels of the factor and the missing observations,
    to prevent `NA` from being mistakenly interpreted as one of the levels.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对象`foo`是一个字符向量，其中第3和第6项缺失；`bar`是一个长度为11的因子向量，其中第2、3、7和10项缺失；`baz`是一个数值矩阵，第1行、第2和3列、第3行第3列缺失元素。在因子向量中，请注意`NA`被打印为`<NA>`。这是为了区分因子的真实水平和缺失的观察值，防止将`NA`误解为某个因子水平。
- en: 'Like the other special values so far, you can identify `NA` elements using
    the function `is.na`. This is often useful for removing or replacing `NA` values.
    Consider the following numeric vector:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面讨论的其他特殊值一样，你可以使用`is.na`函数来识别`NA`元素。这通常对删除或替换`NA`值很有用。考虑以下数字向量：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This vector has a total of 14 entries, including `NA`, `NaN`, and `Inf`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该向量总共有14个条目，包括`NA`、`NaN`和`Inf`。
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, `is.na` flags the corresponding `NA` entries in `qux` as `TRUE`.
    But this is not all—note that it also flags elements 7 and 14, which are `NaN`,
    not `NA`. Strictly speaking, `NA` and `NaN` are different entities, but numericly
    they are practically the same since there is almost nothing you can do with either
    value. Using `is.na` labels both as `TRUE`, allowing the user to remove or recode
    both at the same time.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`is.na`将`qux`中相应的`NA`条目标记为`TRUE`。但这并非全部——请注意，它还标记了元素7和14，它们是`NaN`，而不是`NA`。严格来说，`NA`和`NaN`是不同的实体，但在数值上它们几乎是相同的，因为你几乎无法对这两者做任何事情。使用`is.na`将它们都标记为`TRUE`，允许用户同时删除或重新编码这两者。
- en: 'If you want to identify `NA` and `NaN` entries separately, you can use `is.nan`
    in conjunction with logical operators. Here’s an example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想单独标识`NA`和`NaN`条目，可以将`is.nan`与逻辑运算符结合使用。以下是一个示例：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This identifies the index positions whose elements are specifically `NaN`.
    If you want to identify `NA` entries only, try the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这标识出具体为`NaN`的元素索引位置。如果你只想标识`NA`条目，可以尝试以下方法：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This identifies the element indexes for only the `NA` entries (by checking for
    entries where `is.na` is `TRUE` AND where `is.nan` is NOT `TRUE`).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅标识`NA`条目的元素索引（通过检查`is.na`为`TRUE`并且`is.nan`不为`TRUE`的条目）。
- en: After locating the offending elements, you could use negative indexes in square
    brackets to remove them, though R offers a more direct option. The function `na.omit`
    will take a structure and delete all `NA`s from it; `na.omit` will also apply
    to `NaN`s if the elements are numeric.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在找到问题元素后，你可以使用方括号中的负索引将它们移除，尽管R提供了一个更直接的选项。函数`na.omit`将接收一个结构并删除其中所有的`NA`；如果元素是数字类型，`na.omit`也会应用于`NaN`。
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that the structure passed to `na.omit` is given as the argument `object`
    and that some additional output is displayed in printing the returned object.
    These extra details are provided to inform the user that there were elements in
    the original vector that were removed (in this case, the element positions provided
    in the attribute `na.action`). Attributes will be discussed more in [Section 6.2.1](ch06.xhtml#ch06lev2sec59).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，传递给`na.omit`的结构作为参数`object`给出，并且打印返回对象时会显示一些额外的输出。这些额外的细节旨在告知用户原始向量中有一些元素被删除（在本例中，被删除的元素位置在属性`na.action`中提供）。属性将在[第6.2.1节](ch06.xhtml#ch06lev2sec59)中进一步讨论。
- en: Similar to `NaN`, arithmetic calculations with `NA` result in `NA`. Using relational
    operators with either `NaN` or `NA` will also result in `NA`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`NaN`，对`NA`进行算术计算也会得到`NA`。使用关系运算符与`NaN`或`NA`进行操作时，结果也会是`NA`。
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can find more details on the usage and finer technicalities of `NA` values
    by entering `?NA`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入`?NA`来获取更多关于`NA`值的使用和技术细节。
- en: '***6.1.4 NULL***'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.1.4 NULL***'
- en: Finally, you’ll look at the *null* value, written as `NULL`. This value is often
    used to explicitly define an “empty” entity, which is quite different from a “missing”
    entity specified with `NA`. An instance of `NA` clearly denotes an existing position
    that can be accessed and/or overwritten if necessary—not so for `NULL`. You can
    see an indication of this if you compare the assignment of `NA` with the assignment
    of a `NULL`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来看一下*null*值，即`NULL`。这个值通常用来显式定义一个“空”的实体，这与用`NA`表示的“缺失”实体有所不同。`NA`的实例清晰地表示一个可以访问和/或在必要时被覆盖的位置——而`NULL`则不是如此。如果你将`NA`的赋值与`NULL`的赋值进行比较，你会看到这点的体现。
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that `bar`, the `NA` object, is printed with an index position `[1]`. This
    suggests you have a vector with a single element. In contrast, you explicitly
    instructed `foo` to be empty with `NULL`. Printing this object doesn’t provide
    a position index because there is no position to access.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`bar`，即`NA`对象，以索引位置`[1]`打印。这表明你有一个包含单个元素的向量。相比之下，你显式地用`NULL`指示`foo`为空。打印该对象时不会显示位置索引，因为没有可访问的位置。
- en: 'This interpretation of `NULL` also applies to vectors that have other well-defined
    items. Consider the following two lines of code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对`NULL`的这种解释同样适用于那些具有其他明确定义项目的向量。考虑以下两行代码：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The first line creates a vector of length 4, with the third position coded
    as `NA`. The second line creates a similar vector but using `NULL` instead of
    `NA`. The result is a vector with a length of only 3\. That’s because `NULL` cannot
    take up a position in the vector. As such, it makes no sense to assign `NULL`
    to multiple positions in a vector (or any other structure). Again, here’s an example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个长度为4的向量，第三个位置编码为`NA`。第二行创建了一个类似的向量，但使用`NULL`代替`NA`。结果是一个长度只有3的向量。这是因为`NULL`无法在向量中占据一个位置。因此，将`NULL`赋值给向量中的多个位置（或任何其他结构）是没有意义的。再举一个例子：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first line can be interpreted as “three possible slots with unrecorded observations.”
    The second line simply provides “emptiness three times,” which is interpreted
    as one single, unsubsettable, empty object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行可以解释为“有三个可能的槽位，其中包含未记录的观测值。”第二行只是简单地提供了“三次空值”，它被解释为一个单一的、无法子集化的空对象。
- en: At this point, you might wonder why there is even a need for `NULL`. If something
    is empty and doesn’t exist, why define it in the first place? The answer lies
    in the need to be able to explicitly state or check whether a certain object has
    been defined. This occurs often when calling functions in R. For example, when
    a function contains optional arguments, internally the function has to check which
    of those arguments have been supplied and which are missing or empty. The `NULL`
    value is a useful and flexible tool that the author of a function can use to facilitate
    such checks. You’ll see examples of this later on in [Chapter 11](ch11.xhtml#ch11).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可能会想，为什么甚至需要`NULL`。如果某个东西为空且不存在，为什么一开始要定义它？答案在于需要能够明确声明或检查某个对象是否已被定义。这在调用R中的函数时经常发生。例如，当一个函数包含可选参数时，函数内部必须检查这些参数中哪些已提供，哪些缺失或为空。`NULL`值是一个有用且灵活的工具，函数的作者可以利用它来方便地进行此类检查。你将在[第11章](ch11.xhtml#ch11)看到这些的示例。
- en: The `is.null` function is used to check whether something is explicitly `NULL`.
    Suppose you have a function with an optional argument named `opt.arg` and that,
    if supplied, `opt.arg` should be a character vector of length 3\. Let’s say a
    user calls this function with the following.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`is.null`函数用于检查某个东西是否明确为`NULL`。假设你有一个包含名为`opt.arg`的可选参数的函数，如果提供了，`opt.arg`应该是一个长度为3的字符向量。假设用户以以下方式调用该函数。'
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now if you check whether the argument was supplied using `NA`, you might call
    this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你检查是否使用`NA`提供了参数，你可能会调用这个：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The position-specific nature of `NA` means that this check is element-wise and
    returns an answer for each value in `opt.arg`. This is problematic because you
    want only a single answer—is `opt.arg` empty or is it supplied? This is when `NULL`
    comes to the party.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`NA`的位置信息性质意味着此检查是逐元素进行的，并且会为`opt.arg`中的每个值返回一个答案。这是有问题的，因为你只想要一个答案——`opt.arg`是空的，还是已经提供？这时`NULL`就派上用场了。'
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Quite clearly `opt.arg` is not empty, and the function can proceed as necessary.
    If the argument is empty, using `NULL` over `NA` for the check is again better
    for these purposes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`opt.arg`不是空的，函数可以按需继续。如果参数为空，使用`NULL`而不是`NA`进行检查，出于这些目的，通常更为合适。
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As noted earlier, filling a vector with `NULL` isn’t usual practice; it’s done
    here just for illustration. But usage of `NULL` is far from specific to this particular
    example. It’s commonly used throughout both ready-to-use and user-contributed
    functionality in R.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，填充向量时使用`NULL`并不是一种常规做法；这里这样做只是为了说明。但`NULL`的使用远不止限于此特定示例。在R中，无论是现成的功能还是用户贡献的功能中，它都被广泛使用。
- en: The empty `NULL` has an interesting effect if it’s included in arithmetic or
    relational comparisons.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将空的`NULL`包含在算术或关系比较中，它有一个有趣的效果。
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Rather than `NULL` as you might expect, the result is an “empty” vector of a
    type determined by the nature of the operation attempted. `NULL` typically dominates
    any arithmetic, even if it includes other special values.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 结果并不是你可能预期的`NULL`，而是一个“空的”向量，其类型由所尝试的操作的性质决定。`NULL`通常主导任何算术运算，即使它包含其他特殊值。
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`NULL` also occurs naturally when examining lists and data frames. For example,
    define a new list `foo`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`NULL`在检查列表和数据框时也自然出现。例如，定义一个新的列表`foo`。'
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This list obviously doesn’t include a member called `member3`. Look at what
    happens when you try to access a member in `foo` by that name:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表显然不包含名为`member3`的成员。看看当你尝试通过该名称访问`foo`中的成员时会发生什么：
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The result of `NULL` signals that a member called `member3` in `foo` doesn’t
    exist, or in R terms, is empty. Therefore, it can be filled with whatever you
    want.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`NULL` 的结果表示在 `foo` 中没有名为 `member3` 的成员，或者用 R 的术语来说，就是为空。因此，你可以用任何你想要的内容填充它。'
- en: '[PRE32]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The same principle applies when querying a data frame for a nonexistent column
    or variable using the dollar operator (as in [Section 5.2.2](ch05.xhtml#ch05lev2sec53)).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用美元符号操作符查询数据框中不存在的列或变量时，同样的原则适用（如 [第 5.2.2 节](ch05.xhtml#ch05lev2sec53)所示）。
- en: For more technical details on how `NULL` and `is.null` are handled by R, see
    the help file accessed by `?NULL`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `NULL` 和 `is.null` 在 R 中如何处理的更多技术细节，请参阅通过 `?NULL` 访问的帮助文件。
- en: '**Exercise 6.2**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 6.2**'
- en: 'Consider the following line of code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下代码行：
- en: '[PRE33]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Decide yourself which of the following statements are true and which are false
    and then use R to confirm:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自己判断以下哪些语句是真，哪些是假的，然后使用 R 来确认：
- en: The length of `foo` is 8.
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`foo` 的长度是 8。'
- en: Calling `which(x=is.na(x=foo))` will not result in `4` and `8`.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `which(x=is.na(x=foo))` 不会返回 `4` 和 `8`。
- en: Checking `is.null(x=foo)` will provide you with the locations of the two `NULL`
    values that are present.
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `is.null(x=foo)` 将提供你当前存在的两个 `NULL` 值的位置。
- en: Executing `is.na(x=foo[8])+4/NULL` will not result in `NA`.
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `is.na(x=foo[8])+4/NULL` 不会导致 `NA`。
- en: 'Create and store a list containing a single member: the vector `c(7,7,NA,3,NA,1,1,5,NA)`.
    Then, do the following:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并存储一个包含单个成员的列表：向量 `c(7,7,NA,3,NA,1,1,5,NA)`。然后，执行以下操作：
- en: Name the member `"alpha"`.
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将成员命名为 `"alpha"`。
- en: Confirm that the list doesn’t have a member with the name `"beta"` using the
    appropriate logical valued function.
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适当的逻辑值函数确认列表中没有名为 `"beta"` 的成员。
- en: Add a new member called `beta`, which is the vector obtained by identifying
    the index positions of `alpha` that are `NA`.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `beta` 的新成员，该成员是通过标识 `alpha` 中为 `NA` 的索引位置得到的向量。
- en: '**6.2 Understanding Types, Classes, and Coercion**'
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.2 理解类型、类和强制转换**'
- en: By now, you’ve studied many of the fundamental features in the R language for
    representing, storing, and handling data. In this section, you’ll examine how
    to formally distinguish between different kinds of values and structures and look
    at some simple examples of conversion from one type to another.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了 R 语言中用于表示、存储和处理数据的许多基本特性。在本节中，你将研究如何正式区分不同类型的值和结构，并查看一些从一种类型转换到另一种类型的简单示例。
- en: '***6.2.1 Attributes***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.2.1 属性***'
- en: Each R object you create has additional information about the nature of the
    object itself. This additional information is referred to as the object’s *attributes*.
    You’ve see a few attributes already. In [Section 3.1.3](ch03.xhtml#ch03lev2sec26),
    you identified the dimensions attribute of a matrix using `dim`. In [Section 4.3.1](ch04.xhtml#ch04lev2sec46),
    you used `levels` to get the levels attribute of a factor. It was also noted that
    `names` can get the member names of a list in [Section 5.1.2](ch05.xhtml#ch05lev2sec50),
    and in [Section 6.1.3](ch06.xhtml#ch06lev2sec57), that an attribute annotates
    the result of applying `na.omit`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的每个 R 对象都有关于该对象本身性质的附加信息。这些附加信息被称为对象的 *属性*。你已经见过一些属性。在 [第 3.1.3 节](ch03.xhtml#ch03lev2sec26)中，你通过
    `dim` 确定了矩阵的维度属性。在 [第 4.3.1 节](ch04.xhtml#ch04lev2sec46)中，你使用 `levels` 获取了因子的层次属性。还在
    [第 5.1.2 节](ch05.xhtml#ch05lev2sec50)中提到过，`names` 可以获取列表的成员名，在 [第 6.1.3 节](ch06.xhtml#ch06lev2sec57)中，属性注释了应用
    `na.omit` 的结果。
- en: 'In general, you can think of attributes as either *explicit* or *implicit*.
    Explicit attributes are immediately visible to the user, while R determines implicit
    attributes internally. You can print explicit attributes for a given object with
    the `attributes` function, which takes any object and returns a named list. Consider,
    for example, the following 3 × 3 matrix:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你可以将属性视为 *显式* 或 *隐式* 的。显式属性对用户是立即可见的，而 R 内部决定隐式属性。你可以使用 `attributes` 函数打印给定对象的显式属性，该函数接受任何对象并返回一个命名的列表。例如，考虑以下的
    3 × 3 矩阵：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, calling `attributes` returns a list with one member: `dim`. Of course,
    you can retrieve the contents of `dim` with `attributes(foo)$dim`, but if you
    know the name of an attribute, you can also use `attr`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，调用 `attributes` 返回一个包含一个成员的列表：`dim`。当然，你可以通过 `attributes(foo)$dim` 检索 `dim`
    的内容，但如果你知道一个属性的名称，也可以使用 `attr`：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This function takes the object in as `x` and the name of the attribute as `which`.
    Recall that names are specified as character strings in R. To make things even
    more convenient, the most common attributes have their own functions (usually
    named after the attribute) to access the corresponding value. For the dimensions
    of a matrix, you’ve already seen the function `dim`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将对象作为 `x` 输入，并将属性名称作为 `which`。回忆一下，在 R 中，名称是作为字符字符串指定的。为了更加方便，最常见的属性都有自己的函数（通常以属性名命名）来访问对应的值。对于矩阵的维度，你已经看到过函数
    `dim`。
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: These attribute-specific functions are useful because they also allow access
    to implicit attributes, which, while still controllable by the user, are set automatically
    by the software as a matter of necessity. The `names` and `levels` functions mentioned
    earlier are also both attribute-specific functions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特定属性的函数很有用，因为它们还允许访问隐式属性，这些属性虽然仍然可以由用户控制，但作为必要性，软件会自动设置它们。前面提到的 `names` 和
    `levels` 函数也是特定属性的函数。
- en: 'Explicit attributes are often optional; if they aren’t specified, they are
    `NULL`. For example, when building a matrix with the `matrix` function, you can
    use the optional argument `dimnames` to annotate the rows and columns with names.
    You pass `dimnames` a list made up of two members, both character vectors of the
    appropriate lengths—the first giving row names and the second giving column names.
    Let’s define the matrix `bar` as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 显式属性通常是可选的；如果没有指定，它们默认为 `NULL`。例如，在使用 `matrix` 函数构建矩阵时，你可以使用可选参数 `dimnames`
    来为行和列添加名称。你将 `dimnames` 传递一个由两个成员组成的列表，每个成员都是一个适当长度的字符向量——第一个给出行名，第二个给出列名。我们可以如下定义矩阵
    `bar`：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Because the dimension names are attributes, the `dimnames` appear when you call
    `attributes(bar)`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因为维度名称是属性，所以当你调用 `attributes(bar)` 时，`dimnames` 会出现。
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that `dimnames` is itself a list, nested inside the larger attributes list.
    Again, to extract the values of this attribute, you can use list member referencing,
    you can use `attr` as shown earlier, or you can use the attribute-specific function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`dimnames` 本身是一个列表，嵌套在更大的属性列表中。同样，为了提取这个属性的值，你可以使用列表成员引用，使用前面提到的 `attr`，或者使用特定属性的函数。
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Some attributes can be modified after an object has been created (as you saw
    already in [Section 5.1.2](ch05.xhtml#ch05lev2sec50), where you renamed members
    of a list). Here, to make `foo` match `bar` exactly, you can give `foo` some `dimnames`
    by assigning them to the attribute-specific function:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有些属性可以在对象创建后进行修改（如你在[第 5.1.2 节](ch05.xhtml#ch05lev2sec50)中看到的那样，在那里你重新命名了列表的成员）。在这里，为了使
    `foo` 完全匹配 `bar`，你可以通过将 `dimnames` 分配给特定属性的函数来给 `foo` 添加一些 `dimnames`：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: I’ve used matrices in the discussion here, but optional attributes for other
    objects in R are treated the same way. Attributes are not restricted to built-in
    R objects, either. Objects you build yourself can be defined with their own attributes
    and attribute-specific functions. Just remember that the role of an attribute
    is typically to provide descriptive data about an object, or you could end up
    overcomplicating your object structures unnecessarily.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的讨论中我使用了矩阵，但在 R 中，其他对象的可选属性也以相同的方式处理。属性不仅仅局限于内置的 R 对象。你自己构建的对象也可以定义自己的属性和特定属性的函数。只要记住，属性的作用通常是提供关于对象的描述性数据，否则你可能会不必要地使对象结构变得复杂。
- en: '***6.2.2 Object Class***'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.2.2 对象类***'
- en: An object’s *class* is one of the most useful attributes for describing an entity
    in R. Every object you create is identified, either implicitly or explicitly,
    with at least one class. R is an *object-oriented* programming language, meaning
    entities are stored as objects and have methods that act upon them. In such a
    language, class identification is formally referred to as *inheritance*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象的 *class* 是描述 R 中实体最有用的属性之一。你创建的每个对象都会被标识，隐式或显式地至少有一个类。R 是一种 *面向对象* 的编程语言，意味着实体作为对象存储，并且具有可操作它们的方法。在这种语言中，类的标识正式被称为
    *继承*。
- en: '**NOTE**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This section will focus on the most common classing structure used in R, called*
    S3\. *There is another structure,* S4*, which is essentially a more formal set
    of rules for the identification and treatment of different objects. For most practical
    intents and certainly for beginners, understanding and using S3 will be sufficient.
    You can find further details in R’s online documentation.*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*本节将重点介绍R中最常用的分类结构——S3结构。* S4 *是另一种结构，基本上是对不同对象的识别和处理的更正式的规则集。对于大多数实际用途，尤其是对于初学者，理解和使用S3就足够了。你可以在R的在线文档中找到更多细节。*'
- en: The class of an object is explicit in situations where you have user-defined
    object structures or an object such as a factor vector or data frame where other
    attributes play an important part in the handling of the object itself—for example,
    level labels of a factor vector, or variable names in a data frame, are modifiable
    attributes that play a primary role in accessing the observations of each object.
    Elementary R objects such as vectors, matrices, and arrays, on the other hand,
    are implicitly classed, which means the class is not identified with the `attributes`
    function. Whether implicit or explicit, the class of a given object can always
    be retrieved using the attribute-specific function `class`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些情况下，对象的类别是显式的，比如在你有用户自定义的对象结构或因子向量或数据框等对象时，其他属性在处理对象本身时发挥着重要作用——例如，因子向量的级别标签或数据框中的变量名是可修改的属性，在访问每个对象的观测值时起着主要作用。另一方面，像向量、矩阵和数组这样的基础R对象是隐式分类的，这意味着类别不能通过`attributes`函数来识别。无论是隐式还是显式，给定对象的类别始终可以通过特定的属性函数`class`来获取。
- en: '**Stand-Alone Vectors**'
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**独立向量**'
- en: Let’s create some simple vectors to use as examples.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些简单的向量作为示例。
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can pass any object to the `class` function, and it returns a character
    vector as output. Here are examples using the vectors just created:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将任何对象传递给`class`函数，它会返回一个字符向量作为输出。以下是使用刚刚创建的向量的示例：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The output from using `class` on the character vector, the logical vector, and
    the factor vector simply match the kind of data that has been stored. The output
    from the number vectors is a little more intricate, however. So far, I’ve referred
    to any object with an arithmetically valid set of numbers as “numeric.” If all
    the numbers stored in a vector are whole, then R identifies the vector as `"integer"`.
    Numbers with decimal places (called *floating-point* numbers), on the other hand,
    are identified as `"numeric"`. This distinction is necessary because some tasks
    strictly require integers, not floating-point numbers. Colloquially, I’ll continue
    to refer to both types as “numeric” and in fact, the `is.numeric` function will
    return `TRUE` for both integer and floatingpoint structures, as you’ll see in
    [Section 6.2.3](ch06.xhtml#ch06lev2sec61).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`class`函数在字符向量、逻辑向量和因子向量上的输出结果仅仅是数据存储的类型。然而，数值向量的输出稍微复杂一些。到目前为止，我将所有包含算术有效数字的对象称为“numeric”。如果向量中存储的所有数字都是整数，那么R会将该向量识别为`"integer"`。另一方面，带有小数点的数字（称为*浮动点*数字）会被识别为`"numeric"`。这种区分是必要的，因为某些任务严格要求使用整数，而非浮动点数字。在口语上，我将继续把这两种类型称为“numeric”，事实上，`is.numeric`函数会对整数和浮动点结构都返回`TRUE`，正如你在[第6.2.3节](ch06.xhtml#ch06lev2sec61)中所看到的。
- en: '**Other Data Structures**'
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**其他数据结构**'
- en: As mentioned earlier, R’s classes are essentially designed to facilitate object-oriented
    programming. As such, `class` usually reports on the nature of the data *structure*,
    rather than the type of data that’s stored—it returns the data type only when
    used on stand-alone vectors. Let’s try it on some matrices.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，R的类别本质上是为了方便面向对象编程而设计的。因此，`class`通常报告的是数据*结构*的性质，而不是存储的数据类型——它仅在用于独立向量时才返回数据类型。让我们在一些矩阵上试试这个函数。
- en: '[PRE43]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note from [Section 4.3.1](ch04.xhtml#ch04lev2sec46) that factors are used only
    in vector form, so `fac.vec` is not included here. Now check these matrices with
    `class`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在[第4.3.1节](ch04.xhtml#ch04lev2sec46)中提到，因子只能以向量形式使用，因此`fac.vec`不包括在这里。现在检查这些矩阵的`class`。
- en: '[PRE44]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You see that regardless of the data type, `class` reports the structure of the
    object itself—all matrices. The same is true for other object structures, like
    arrays, lists, and data frames.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，无论数据类型如何，`class`报告的是对象本身的结构——所有的矩阵都是如此。其他对象结构，如数组、列表和数据框，也一样。
- en: '**Multiple Classes**'
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**多种类**'
- en: Certain objects will have multiple classes. A variant on a standard form of
    an object, such as an ordered factor vector, will inherit the usual factor class
    and also contain the additional `ordered` class. Both are returned if you use
    the `class` function.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 某些对象会有多个类。一个对象的变种形式，如有序因子向量，会继承常规因子类，并且还会包含额外的 `ordered` 类。如果使用 `class` 函数，它们都会被返回。
- en: '[PRE45]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Earlier, `fac.vec` was identified as `"factor"` only, but the class of `ordfac.vec`
    has two components. It’s still identified as `"factor"`, but it also includes
    `"ordered"`, which identifies the variant of the `"factor"` class also present
    in the object. Here, you can think of `"ordered"` as a *subclass* of `"factor"`.
    In other words, it is a special case that inherits from, and therefore behaves
    like, a `"factor"`. For further technical details on R subclasses, I recommend
    [Chapter 9](ch09.xhtml#ch09) of *The Art of R Programming* by Matloff ([2011](ref.xhtml#ref44)).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，`fac.vec` 被标识为仅为 `"factor"`，但 `ordfac.vec` 的类有两个组成部分。它仍然被标识为 `"factor"`，但还包括
    `"ordered"`，这标识了该对象中存在的 `"factor"` 类的变体。这里，您可以将 `"ordered"` 看作是 `"factor"` 的 *子类*。换句话说，它是一个从
    `"factor"` 继承并因此表现得像 `"factor"` 的特殊情况。有关 R 子类的更多技术细节，我推荐 Matloff 的 *《R 编程艺术》*（[2011](ref.xhtml#ref44)）第
    9 章。
- en: '**NOTE**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I have focused on the* `class` *function here because it’s directly relevant
    to the object-oriented programming style exercised in this text, especially in
    [Part II](part02.xhtml#part02). There are other functions that show some of the
    complexities of R’s classing rules. For example, the function* `typeof` *reports
    the type of data contained within an object, not just for vectors but also for
    matrices and arrays. Note, however, that the terminology in the output of* `typeof`
    *doesn’t always match the output of* `class`*. See the help file* `?typeof` *for
    details on the values it returns.*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在这里重点讲解* `class` *函数，因为它与本书中采用的面向对象编程风格直接相关，特别是在[第二部分](part02.xhtml#part02)中。还有其他一些函数展示了
    R 类规则的复杂性。例如，函数* `typeof` *报告对象中包含的数据类型，不仅适用于向量，还适用于矩阵和数组。然而请注意，* `typeof` *输出中的术语不一定与*
    `class` *的输出相匹配。有关它返回值的详细信息，请参阅帮助文件* `?typeof` *。*'
- en: To summarize, an object’s class is first and foremost a descriptor of the data
    structure, though for simple vectors, the `class` function reports the type of
    data stored. If the vector entries are exclusively whole numbers, then R classes
    the vector as `"integer"`, whereas `"numeric"` is used to label a vector with
    floating-point numbers.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，一个对象的类首先是数据结构的描述符，尽管对于简单的向量，`class` 函数报告的是存储的数据类型。如果向量中的条目完全是整数，那么 R 会将该向量归类为
    `"integer"`，而 `"numeric"` 则用来标记包含浮点数的向量。
- en: '***6.2.3 Is-Dot Object-Checking Functions***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.2.3 Is-Dot 对象检查函数***'
- en: Identifying the class of an object is essential for functions that operate on
    stored objects, especially those that behave differently depending on the class
    of the object. To check whether the object is a specific class or data type, you
    can use the *is-dot* functions on the object and it will return a `TRUE` or `FALSE`
    logical value.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 确定对象的类对于操作存储对象的函数至关重要，尤其是那些根据对象类的不同表现不同的函数。要检查对象是否属于特定的类或数据类型，可以对该对象使用 *is-dot*
    函数，返回 `TRUE` 或 `FALSE` 逻辑值。
- en: 'Is-dot functions exist for almost any sensible check you can think of. For
    example, consider once more the `num.vec1` vector from [Section 6.2.2](ch06.xhtml#ch06lev2sec60)
    and the following six checks:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于几乎任何合理的检查，都会有对应的 is-dot 函数。例如，再次考虑 [第 6.2.2 节](ch06.xhtml#ch06lev2sec60)中的
    `num.vec1` 向量和以下六个检查：
- en: '[PRE46]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The first, second, and sixth is-dot functions check the kind of data stored
    in the object, while the others check the structure of the object itself. The
    results are to be expected: `num.vec1` *is* an “integer” (and *is* “numeric”),
    and it *is* a “vector.” It’s not a matrix or a data frame, nor is it logical.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个、第二个和第六个 is-dot 函数检查对象中存储的数据类型，而其他函数检查对象本身的结构。结果是可以预期的：`num.vec1` *是* “整数”（并且
    *是* “数值型”），它 *是* 一个“向量”。它不是矩阵或数据框，也不是逻辑型。
- en: Briefly, it’s worth noting that these checks use more general categories than
    the formal classes identified with `class`. Recall that `num.vec1` was identified
    solely as `"integer"` in [Section 6.2.2](ch06.xhtml#ch06lev2sec60), but using
    `is.numeric` here still returns `TRUE`. In this example, the `num.vec1` with integer
    data is generalized to be `"numeric"`. Similarly, for a data frame, an object
    of class `"data.frame"` will return `TRUE` for `is.data.frame` *and* `is.list`
    because a data frame is intuitively generalized to a list.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，值得注意的是，这些检查使用的类别比通过`class`标识的正式类要更一般化。回想一下，在[第6.2.2节](ch06.xhtml#ch06lev2sec60)中，`num.vec1`仅被标识为`"integer"`，但在这里使用`is.numeric`仍然返回`TRUE`。在这个例子中，带有整数数据的`num.vec1`被概括为`"numeric"`。类似地，对于数据框，类为`"data.frame"`的对象会对`is.data.frame`
    *和* `is.list`返回`TRUE`，因为数据框本质上被概括为列表。
- en: There’s a difference between the object is-dot functions detailed here and functions
    such as `is.na` discussed in [Section 6.1](ch06.xhtml#ch06lev1sec21). The functions
    to check for the special values like `NA` should be thought of as a check for
    equality; they exist because it is not legal syntax to write something like `foo==NA`.
    Those functions from [Section 6.1](ch06.xhtml#ch06lev1sec21) thus operate in R’s
    element-wise fashion, whereas the object is-dot functions inspect the object *itself*,
    returning only a single logical value.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里详细说明的对象 is-dot 函数与在[第6.1节](ch06.xhtml#ch06lev1sec21)中讨论的诸如`is.na`等函数之间存在差异。用于检查特殊值（如`NA`）的函数应该被视为一个等式检查；它们存在的原因是写出像`foo==NA`这样的语法是非法的。因此，来自[第6.1节](ch06.xhtml#ch06lev1sec21)的那些函数以元素逐一的方式在R中操作，而对象
    is-dot 函数则检查对象 *本身*，并只返回一个逻辑值。
- en: '***6.2.4 As-Dot Coercion Functions***'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.2.4 As-Dot 强制转换函数***'
- en: You’ve seen different ways to modify an object after it’s been created—by accessing
    and overwriting elements, for example. But what about the structure of the object
    itself and the type of data contained within?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了在对象创建后修改对象的不同方式——例如，通过访问和覆盖元素。但对象本身的结构以及其中包含的数据类型呢？
- en: 'Converting from one object or data type to another is referred to as *coercion*.
    Like other features of R you’ve met so far, coercion is performed either implicitly
    or explicitly. Implicit coercion occurs automatically when elements need to be
    converted to another type in order for an operation to complete. In fact, you’ve
    come across this behavior already, in [Section 4.1.4](ch04.xhtml#ch04lev2sec40),
    for example, when you used numeric values for logical values. Remember that logical
    values can be thought of as integers—one for `TRUE` and zero for `FALSE`. Implicit
    coercion of logical values to their numeric counterparts occurs in lines of code
    like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个对象或数据类型转换到另一个对象或数据类型被称为*强制转换*。像你迄今遇到的其他R功能一样，强制转换可以是隐式的，也可以是显式的。隐式强制转换会在元素需要转换为另一种类型以完成操作时自动发生。事实上，你已经遇到过这种行为，例如在[第4.1.4节](ch04.xhtml#ch04lev2sec40)中，当你使用数值代替逻辑值时。记住，逻辑值可以被视为整数——`TRUE`为1，`FALSE`为0。逻辑值隐式转换为其数值对等物的强制转换在像这样的代码行中发生：
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this operation, R recognizes that you’re attempting an arithmetic calculation
    with `+`, so it expects numeric quantities. Since the logical vector is not in
    this form, the software internally coerces it to ones and zeros before completing
    the task.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个操作中，R识别出你正在尝试进行一个算术计算（使用`+`），因此它期望数值型量。由于逻辑向量不是这种形式，软件会在内部将其强制转换为1和0，然后再完成任务。
- en: 'Another frequent example of implicit coercion is when `paste` and `cat` are
    used to glue together character strings, as explored in [Section 4.2.2](ch04.xhtml#ch04lev2sec43).
    Non-character entries are automatically coerced to strings before the concatenation
    takes place. Here’s an example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的隐式强制转换例子是，当使用`paste`和`cat`将字符字符串拼接在一起时，如[第4.2.2节](ch04.xhtml#ch04lev2sec43)中探讨的那样。非字符项在拼接之前会自动转换为字符串。这里是一个例子：
- en: '[PRE48]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, the integer `34` and the logical `T` are implicitly coerced to characters
    since R knows the output of `paste` must be a string.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，整数`34`和逻辑值`T`被隐式地转换为字符，因为R知道`paste`的输出必须是字符串。
- en: In other situations, coercion won’t happen automatically and must be carried
    out by the user. This explicit coercion can be achieved with the *as-dot* functions.
    Like is-dot functions, as-dot functions exist for most typical R data types and
    object classes. The previous two examples can be coerced explicitly, as follows.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，强制转换不会自动发生，必须由用户进行。这种显式强制转换可以通过*as-dot*函数来实现。像is-dot函数一样，as-dot函数也适用于大多数典型的R数据类型和对象类。前面的两个例子可以显式地进行强制转换，如下所示。
- en: '[PRE49]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Coercions are possible in most cases that “make sense.” For example, it’s easy
    to see why R is able to read something like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，强制转换是“合理”的。例如，很容易理解为什么 R 能够读取如下内容：
- en: '[PRE50]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'However, the following conversion makes no sense:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下转换是没有意义的：
- en: '[PRE51]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Since there is no logical way to translate “g’day mate” into numbers, the entry
    is returned as `NA` (in this case, R has also issued a warning message). This
    means that in certain cases, multiple coercions are needed to attain the final
    result. Suppose, for example, you have the character vector `c("1","0","1","0","0")`
    and you want to coerce it to a logical-valued vector. Direct character to logical
    coercion is not possible, because even if all the character strings contained
    numbers, there is no guarantee in general that they would all be ones and zeros.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有逻辑方式将“g’day mate”翻译成数字，因此该条目返回 `NA`（在这种情况下，R 还发出了警告信息）。这意味着在某些情况下，可能需要多次强制转换才能获得最终结果。例如，假设你有字符型向量
    `c("1","0","1","0","0")`，并希望将其强制转换为逻辑值向量。直接的字符到逻辑的强制转换是不可行的，因为即使所有字符字符串都包含数字，也无法保证它们全都是
    1 和 0。
- en: '[PRE52]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'However, you know that character string numbers can be converted to a numeric
    data type, and you know that ones and zeros are easily coerced to logicals. So,
    you can perform the coercion in those two steps, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您知道字符型数字可以转换为数字数据类型，且 1 和 0 很容易被强制转换为逻辑值。因此，您可以按照以下两步执行强制转换：
- en: '[PRE53]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Not all data-type coercion is entirely straightforward. Factors, for example,
    are trickier because R treats the levels as integers. In other words, regardless
    of how the levels of a given factor are actually labeled, the software will refer
    to them internally as level 1, level 2, and so on. This is clear if you try to
    coerce a factor to a numeric data type.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有的数据类型强制转换都完全简单明了。例如，因子更复杂，因为 R 将级别视为整数。换句话说，无论给定因子的级别如何标记，软件内部都会将其作为级别 1、级别
    2 等处理。如果尝试将因子强制转换为数字数据类型，这一点会很明显。
- en: '[PRE54]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, you see that R has assigned the numeric representation of the factor in
    the stored order of the factor labels (alphabetic by default). Level 1 refers
    to `female`, and level 2 refers to `male`. This example is simple enough, though
    it’s important to be aware of the behavior since coercion from factors with numeric
    levels can cause confusion.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到 R 已根据因子标签的存储顺序（默认按字母顺序）分配了因子的数字表示。级别 1 代表 `female`，级别 2 代表 `male`。这个例子相对简单，但重要的是要意识到这种行为，因为从具有数字级别的因子进行强制转换可能会导致混淆。
- en: '[PRE55]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The numeric representation of the factor `qux` is `c(1,1,2,3)`. This highlights
    again that the levels of `qux` are simply treated as level 1 (even though it has
    a label of `2`), level 2 (which has a label of `3`), and level 3 (which has a
    label of `5`).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因子的数字表示 `qux` 是 `c(1,1,2,3)`。这再次强调，`qux` 的级别简单地被视为级别 1（即使它的标签是 `2`）、级别 2（标签为
    `3`）和级别 3（标签为 `5`）。
- en: Coercion between object classes and structures can also be useful. For example,
    you might need to store the contents of a matrix as a single vector.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对象类和结构之间的强制转换也非常有用。例如，您可能需要将矩阵的内容存储为单一的向量。
- en: '[PRE56]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that `as.vector` has coerced the matrix by “stacking” the columns into
    a single vector. The same column-wise deconstruction occurs for higher-dimensional
    arrays, in order of layer or block.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`as.vector` 通过“堆叠”列将矩阵强制转换为单一向量。对于更高维度的数组，也会发生相同的按列解构，按层次或区块的顺序进行。
- en: '[PRE57]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can see that `as.matrix` stores the array as a 12 × 1 matrix, and `as.vector`
    stores it as a single vector. Similar commonsense rules for data types apply to
    coercion when working with object structures. For example, coercing the following
    list `baz` to a data frame produces an error:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，`as.matrix` 将数组存储为 12 × 1 的矩阵，而 `as.vector` 将其存储为单一向量。类似的常识性数据类型规则也适用于在处理对象结构时的强制转换。例如，将以下列表
    `baz` 强制转换为数据框会产生错误：
- en: '[PRE58]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The error occurs because the variables do not have matching lengths. But there
    is no problem with coercing the list `qux`, shown here, which has equal-length
    members:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 错误发生是因为变量的长度不匹配。但对于这里所示的 `qux` 列表，它的成员长度相同，所以没有问题。
- en: '[PRE59]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This stores the variables as a data set in a column-wise fashion, in the order
    that your list supplies them as members.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以列方式存储变量，按你的列表提供的顺序将其作为成员存入数据集。
- en: This discussion on object classes, data types, and coercion is not exhaustive,
    but it serves as a useful introduction to how R deals with issues surrounding
    the formal identification, description, and handling of the objects you create—issues
    that are present for most high-level languages. Once you’re more familiar with
    R, the help files (such as the one accessed by entering `?as` at the prompt) provide
    further details about object handling in the software.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 关于对象类别、数据类型和强制转换的讨论并不全面，但它作为一个有用的介绍，帮助你了解 R 是如何处理与所创建对象的正式识别、描述和处理相关的问题的——这些问题在大多数高级语言中都是存在的。一旦你对
    R 更加熟悉，可以通过帮助文件（例如，输入 `?as` 以访问的帮助文件）获取更多有关对象处理的详细信息。
- en: '**Exercise 6.3**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 6.3**'
- en: Identify the class of the following objects. For each object, also state whether
    the class is explicitly or implicitly defined.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定以下对象的类别。对于每个对象，还需要说明该类别是显式定义的还是隐式定义的。
- en: '`foo <- array(data=1:36,dim=c(3,3,4))`'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`foo <- array(data=1:36,dim=c(3,3,4))`'
- en: '`bar <- as.vector(foo)`'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bar <- as.vector(foo)`'
- en: '`baz <- as.character(bar)`'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`baz <- as.character(bar)`'
- en: '`qux <- as.factor(baz)`'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`qux <- as.factor(baz)`'
- en: '`quux <- bar+c(-0.1,0.1)`'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`quux <- bar+c(-0.1,0.1)`'
- en: For each object defined in (a), find the sum of the result of calling `is.numeric`
    and `is.integer` on it separately. For example, `is.numeric(foo)+is.integer(foo)`
    would compute the sum for (i). Turn the collection of five results into a factor
    with levels `0`, `1`, and `2`, identified by the results themselves. Compare this
    factor vector with the result of coercing it to a numeric vector.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于在（a）中定义的每个对象，分别调用 `is.numeric` 和 `is.integer` 来计算结果的总和。例如，`is.numeric(foo)+is.integer(foo)`
    将计算（i）的总和。将这五个结果的集合转换为一个因子，具有 `0`、`1` 和 `2` 这三个级别，并由结果本身标识。将此因子向量与将其强制转换为数值向量的结果进行比较。
- en: 'Turn the following:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下操作：
- en: '[PRE60]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'into the following:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 转换为以下内容：
- en: '[PRE61]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Store the following matrix:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储以下矩阵：
- en: '![image](../images/f0126-01.jpg)'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0126-01.jpg)'
- en: 'Then, do the following:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，执行以下操作：
- en: Coerce the matrix to a data frame.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将矩阵强制转换为数据框。
- en: As a data frame, coerce the second column to be logical-valued.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为数据框，将第二列强制转换为逻辑值。
- en: As a data frame, coerce the third column to be factor-valued.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为数据框，将第三列强制转换为因子值。
- en: '**Important Code in This Chapter**'
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**本章重要代码**'
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| **函数/运算符** | **简要描述** | **首次出现** |'
- en: '| --- | --- | --- |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Inf`, `-Inf` | Value for ±infinity | [Section 6.1.1](ch06.xhtml#ch06lev2sec55),
    [p. 104](ch06.xhtml#page_104) |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `Inf`, `-Inf` | ±无穷大的值 | [第6.1.1节](ch06.xhtml#ch06lev2sec55), [第104页](ch06.xhtml#page_104)
    |'
- en: '| `is.infinite` | Element-wise check for `Inf` | [Section 6.1.1](ch06.xhtml#ch06lev2sec55),
    [p. 105](ch06.xhtml#page_105) |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `is.infinite` | 元素级别检查 `Inf` | [第6.1.1节](ch06.xhtml#ch06lev2sec55), [第105页](ch06.xhtml#page_105)
    |'
- en: '| `is.finite` | Element-wise check for finiteness | [Section 6.1.1](ch06.xhtml#ch06lev2sec55),
    [p. 105](ch06.xhtml#page_105) |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `is.finite` | 元素级别检查是否有限 | [第6.1.1节](ch06.xhtml#ch06lev2sec55), [第105页](ch06.xhtml#page_105)
    |'
- en: '| `NaN` | Value for invalid numerics | [Section 6.1.2](ch06.xhtml#ch06lev2sec56),
    [p. 106](ch06.xhtml#page_106) |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `NaN` | 无效数值的值 | [第6.1.2节](ch06.xhtml#ch06lev2sec56), [第106页](ch06.xhtml#page_106)
    |'
- en: '| `is.nan` | Element-wise check for `NaN` | [Section 6.1.2](ch06.xhtml#ch06lev2sec56),
    [p. 107](ch06.xhtml#page_107) |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `is.nan` | 元素级别检查 `NaN` | [第6.1.2节](ch06.xhtml#ch06lev2sec56), [第107页](ch06.xhtml#page_107)
    |'
- en: '| `NA` | Value for missing observation | [Section 6.1.3](ch06.xhtml#ch06lev2sec57),
    [p. 108](ch06.xhtml#page_108) |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `NA` | 缺失观测的值 | [第6.1.3节](ch06.xhtml#ch06lev2sec57), [第108页](ch06.xhtml#page_108)
    |'
- en: '| `is.na` | Element-wise check for `NA` OR `NaN` | [Section 6.1.3](ch06.xhtml#ch06lev2sec57),
    [p. 109](ch06.xhtml#page_109) |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `is.na` | 元素级别检查 `NA` 或 `NaN` | [第6.1.3节](ch06.xhtml#ch06lev2sec57), [第109页](ch06.xhtml#page_109)
    |'
- en: '| `na.omit` | Delete all `NA`s and `NaN`s | [Section 6.1.3](ch06.xhtml#ch06lev2sec57),
    [p. 110](ch06.xhtml#page_110) |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `na.omit` | 删除所有 `NA` 和 `NaN` | [第6.1.3节](ch06.xhtml#ch06lev2sec57), [第110页](ch06.xhtml#page_110)
    |'
- en: '| `NULL` | Value for “empty” | [Section 6.1.4](ch06.xhtml#ch06lev2sec58), [p.
    110](ch06.xhtml#page_110) |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `NULL` | “空”值 | [第6.1.4节](ch06.xhtml#ch06lev2sec58), [第110页](ch06.xhtml#page_110)
    |'
- en: '| `is.null` | Check for `NULL` | [Section 6.1.4](ch06.xhtml#ch06lev2sec58),
    [p. 111](ch06.xhtml#page_111) |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `is.null` | 检查 `NULL` | [第6.1.4节](ch06.xhtml#ch06lev2sec58), [第111页](ch06.xhtml#page_111)
    |'
- en: '| `attributes` | List explicit attributes | [Section 6.2.1](ch06.xhtml#ch06lev2sec59),
    [p. 114](ch06.xhtml#page_114) |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `attributes` | 列出显式属性 | [第6.2.1节](ch06.xhtml#ch06lev2sec59), [第114页](ch06.xhtml#page_114)
    |'
- en: '| `attr` | Obtain specific attribute | [Section 6.2.1](ch06.xhtml#ch06lev2sec59),
    [p. 115](ch06.xhtml#page_115) |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `attr` | 获取特定属性 | [第6.2.1节](ch06.xhtml#ch06lev2sec59), [第115页](ch06.xhtml#page_115)
    |'
- en: '| `dimnames` | Get array dimension names | [Section 6.2.1](ch06.xhtml#ch06lev2sec59),
    [p. 116](ch06.xhtml#page_116) |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `dimnames` | 获取数组维度名称 | [第6.2.1节](ch06.xhtml#ch06lev2sec59)，[第116页](ch06.xhtml#page_116)
    |'
- en: '| `class` | Get object class (S3) | [Section 6.2.2](ch06.xhtml#ch06lev2sec60),
    [p. 117](ch06.xhtml#page_117) |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `class` | 获取对象类别（S3） | [第6.2.2节](ch06.xhtml#ch06lev2sec60)，[第117页](ch06.xhtml#page_117)
    |'
- en: '| `is._` | Object-checking functions | [Section 6.2.3](ch06.xhtml#ch06lev2sec61),
    [p. 120](ch06.xhtml#page_120) |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `is._` | 对象检查函数 | [第6.2.3节](ch06.xhtml#ch06lev2sec61)，[第120页](ch06.xhtml#page_120)
    |'
- en: '| `as._` | Object-coercion functions | [Section 6.2.4](ch06.xhtml#ch06lev2sec62),
    [p. 121](ch06.xhtml#page_121) |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `as._` | 对象强制转换函数 | [第6.2.4节](ch06.xhtml#ch06lev2sec62)，[第121页](ch06.xhtml#page_121)
    |'
