- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: I²C Low-Level Hardware
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: I²C 低级硬件
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: The I²C bus is a worldwide standard for communication between integrated circuits
    (ICs) on printed circuit boards (PCBs) and across multiple PCBs within a system.
    According to NXP Semiconductors, I²C is in use on more than 1,000 different ICs
    made by more than 50 different manufacturers. Without question, I²C is one of
    the more popular inter-IC data communication schemes available (Serial Peripheral
    Interface [SPI] being another).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: I²C 总线是一个全球标准，用于在印刷电路板（PCB）上的集成电路（IC）之间以及系统内多个 PCB 之间的通信。根据 NXP 半导体公司的说法，I²C
    被超过 50 家不同制造商生产的 1,000 多种不同的 IC 所使用。毫无疑问，I²C 是现有的较为流行的 IC 数据通信方案之一（串行外设接口 [SPI]
    是另一种）。
- en: The popularity of the I²C bus increased with the introduction of hobbyist-level
    single-board computers (SBCs) such as the Arduino and Raspberry Pi that include
    I²C support. Today, tens of thousands of programmers have learned the basics of
    the I²C bus because they wanted to interface some device to an Arduino- or Pi-class
    system. Because of the vast amount of open source library code available, it is
    possible to use and program devices on the I²C bus without really understanding
    its low-level signal protocols. However, to truly make the most of a design employing
    I²C peripherals, you need to understand those protocols, both hardware and software.
    This chapter introduces the low-level hardware aspects of the I²C, which you’ll
    need to understand before learning about the signal protocols.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Arduino 和 Raspberry Pi 等支持 I²C 的爱好者级单板计算机（SBC）的推出，I²C 总线的流行度不断增加。今天，成千上万的程序员已经学习了
    I²C 总线的基础知识，因为他们想将某个设备与 Arduino 或 Pi 系统连接起来。由于大量的开源库代码，用户可以在不完全理解其低级信号协议的情况下使用和编程
    I²C 总线上的设备。然而，要真正充分利用使用 I²C 外设的设计，你需要理解这些协议，包括硬件和软件。 本章介绍了 I²C 的低级硬件方面，在学习信号协议之前，你需要了解这些内容。
- en: 1.1 I²C Overview
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 I²C 概述
- en: Before buses such as the I²C bus, different components of a computer system
    communicated with one another using traditional CPU-style buses. These buses typically
    used 8 to 32 data lines and some number of address signals. Connecting a single
    8-bit parallel I/O device to a CPU required a fair amount of PCB space to hold
    all the signal traces. Of course, adding additional I/O increased signal, space,
    and noise accordingly. In addition to space, those lines also increased the amount
    of noise that system engineers had to deal with in their designs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 I²C 总线等总线出现之前，计算机系统的不同组件使用传统的 CPU 风格总线进行通信。这些总线通常使用 8 到 32 条数据线以及一些地址信号。将一个
    8 位并行 I/O 设备连接到 CPU 需要相当大的 PCB 空间来容纳所有信号线路。当然，增加额外的 I/O 会相应地增加信号、空间和噪声。除了空间，这些线路还增加了系统工程师在设计中需要处理的噪声量。
- en: The I²C bus was invented to alleviate these problems. With the I²C bus, a single
    pair of signal lines (PCB traces) can connect a wide variety of different I/O
    peripherals to a CPU. This reduces cost and eliminates many problems when building
    complex (embedded) computer systems (see the text box “Advantages of the I²C Bus”
    for more information).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: I²C 总线的发明是为了解决这些问题。有了 I²C 总线，一对信号线（PCB 路径）就可以将各种不同的 I/O 外设连接到 CPU。这减少了成本，并且在构建复杂（嵌入式）计算机系统时消除了许多问题（更多信息请参见文本框“
    I²C 总线的优势”）。
- en: 'I²C devices are divided into two general categories: controller devices (formerly
    known as masters) and peripheral devices (formerly slaves). A *controller device*,
    as its name suggests, controls the communication between the controller and the
    peripheral device. The *peripheral device* does not initiate any communication
    on its own and relies on the controller to manage the communication process.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: I²C 设备分为两类：控制器设备（以前称为主设备）和外设设备（以前称为从设备）。*控制器设备*，顾名思义，控制着控制器和外设设备之间的通信。*外设设备*则不会主动发起任何通信，而是依赖控制器来管理通信过程。
- en: 'The I²C protocol is a synchronous serial communication using two signal lines:
    *SCL*, which stands for “serial clock,” and *SDA*, which stands for “serial data.”
    The controller drives the clock line. When the peripheral is sending data to the
    controller, it puts the data bits on the data line; when the peripheral is receiving
    data, the controller places the serial data bits on the data line. Except for
    one special case—clock stretching, discussed later in this chapter—the peripheral
    never controls the clock line.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: I²C协议是一种同步串行通信，使用两条信号线：*SCL*，代表“串行时钟”，和*SDA*，代表“串行数据”。控制器驱动时钟线。当外设向控制器发送数据时，它将数据位放置在数据线上；当外设接收数据时，控制器将串行数据位放置到数据线上。除了一个特殊情况——时钟拉伸，稍后会在本章讨论——外设永远不会控制时钟线。
- en: A typical system has a single controller and one or more peripheral devices.
    Each peripheral device has an address unique to a given I²C bus, which the controller
    uses to differentiate multiple peripherals on the same bus. In theory, a single
    I²C bus supports up to 127 or even 1,024 different peripheral devices, though
    practical matters limit the number of peripheral devices to a much smaller number.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的系统有一个控制器和一个或多个外设设备。每个外设设备在给定的I²C总线上都有一个唯一的地址，控制器通过该地址区分同一总线上的多个外设。从理论上讲，单个I²C总线支持最多127个甚至1,024个不同的外设设备，尽管实际情况会将外设设备的数量限制在更小的范围内。
- en: Although a typical system has only a single controller, the I²C bus supports
    multiple controllers on the same bus. This allows multiple controllers to share
    a common set of peripheral devices. A given system can also support multiple I²C
    buses, so peripheral devices with the same address, which cannot be used together
    on the same I²C bus, can still be deployed in a given system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一个典型的系统只有一个控制器，但I²C总线支持同一总线上有多个控制器。这允许多个控制器共享一组公共外设设备。给定的系统还可以支持多个I²C总线，因此具有相同地址的外设设备，不能在同一I²C总线上一起使用，仍然可以在给定的系统中部署。
- en: The controller-peripheral relationship is fundamental to the I²C protocol. While,
    in theory, it is possible for a single IC to behave either as a controller or
    as a peripheral and even switch between these two functions in a given system,
    such activity is rare; in general, a device functions either as a peripheral or
    as a controller within a system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器与外设之间的关系是I²C协议的基础。虽然理论上，一个单一的集成电路可以既作为控制器也作为外设，并且在给定的系统中在这两种功能之间切换，但这种情况较为罕见；通常，设备要么作为外设，要么作为控制器在系统中运行。
- en: 1.2 Open-Drain (Open-Collector) Logic and Four-Wire Mode
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 开漏（开集电极）逻辑和四线模式
- en: One of the most fundamental electrical aspects of the I²C bus is that it is
    based on an open-drain (or open-collector) logic system. That is, a device connected
    to the I²C bus does not *drive* the signal lines high or low; instead, it can
    only *pull* these lines low using an open-drain (FET) connection. Pullup resistors
    that connect the signal lines on the I²C bus to a power supply pull the two bus
    lines, SDA and SCL, high by default. This design allows multiple controllers and
    peripherals to control the data and clock lines without running into problems
    associated with connecting multiple output pins to the same signal line.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: I²C总线的一个最基本的电气特性是它基于开漏（或开集电极）逻辑系统。也就是说，连接到I²C总线的设备不会*驱动*信号线的高电平或低电平；相反，它只能通过开漏（FET）连接将这些信号线拉低。连接I²C总线信号线到电源的上拉电阻默认将总线的两条信号线SDA和SCL拉高。这种设计允许多个控制器和外设控制数据线和时钟线，而不会遇到多个输出引脚连接到同一信号线时的问题。
- en: To place a logic 1 on one of the lines, a device puts its open-drain (or open-collector,
    if using bipolar devices) into the high-impedance state. This allows the default
    logic 1 to appear on the line, placed there by the pullup resistor. To place a
    logic 0 on one of the lines, the device activates its open-drain device, which
    shorts the line to ground.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要在其中一条信号线上放置逻辑1，设备将其开漏（或如果使用双极性设备，则为开集电极）设置为高阻抗状态。这样，上拉电阻会将默认的逻辑1放置到信号线上。要在其中一条信号线上放置逻辑0，设备激活其开漏设备，将信号线拉到地面。
- en: Most I²C devices provide open-drain signals to connect to the I²C bus, so you
    don’t need to have any additional hardware to interface such devices to the bus.
    However, it is also possible to connect arbitrary logic devices to the I²C bus
    by routing them through a bipolar transistor (open-collector), JFET, MOSFET, or
    other open-drain device to control the electrical access to the I²C bus. The following
    subsection provides an example of this.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数I²C设备提供开漏信号以连接到I²C总线，因此你不需要额外的硬件来连接这些设备到总线。然而，也可以通过将任意逻辑设备通过双极性晶体管（开集电极）、JFET、MOSFET或其他开漏设备连接到I²C总线，来控制I²C总线的电气访问。以下小节提供了这个例子的说明。
- en: 'The SDA and SCL lines, by definition, are bidirectional on the controller device
    and are often bidirectional on peripheral devices. Certain single-board computers
    or CPUs might not support digital I/O pins that can operate in a bidirectional
    mode—that is, they can be programmed only as an input pin or an output pin. To
    resolve this, some system designers implement I²C in *four-wire mode*. In four-wire
    mode the I²C bus still has two wires, but the controller uses two wires to implement
    each of the signals: two output pins and two input pins. [Figure 1-1](#figure1-1)
    diagrams this four-wire controller connection.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: SDA和SCL线路根据定义在控制器设备上是双向的，并且在外围设备上通常也是双向的。某些单板计算机或CPU可能不支持能够在双向模式下工作的数字I/O引脚——也就是说，它们只能被编程为输入引脚或输出引脚。为了解决这个问题，一些系统设计师实现了I²C的*四线模式*。在四线模式下，I²C总线仍然有两条线路，但控制器使用两条线路实现每个信号：两条输出引脚和两条输入引脚。[图1-1](#figure1-1)展示了这个四线控制器连接。
- en: '![](image_fi/502468c01/f01001.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c01/f01001.png)'
- en: 'Figure 1-1: Four-wire controller connection'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-1：四线控制器连接
- en: To prevent electrical conflicts (connecting two outputs together), the output
    pins drive the base of a transistor (gate on a FET or MOSFET), and the collector
    (drain) connects to the appropriate bus line. Then the controller CPU can simultaneously
    read the data on the bus lines using the input pins while writing data on the
    output pins with no electrical conflict and without support for bidirectional
    I/O pins.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止电气冲突（将两个输出连接在一起），输出引脚驱动晶体管的基极（FET或MOSFET的栅极），集电极（漏极）连接到相应的总线线路。然后，控制器CPU可以同时使用输入引脚读取总线线路上的数据，同时使用输出引脚写入数据，从而避免电气冲突，并且无需支持双向I/O引脚。
- en: 1.3 I²C Signal Levels
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 I²C信号电平
- en: When the I²C was designed in the early 1980s, 5 V logic was the prevalent design
    technology, so the original I²C assumed the use of 5-V logic signals. However,
    as the I²C bus is based on open-drain connections, the high voltage level is completely
    determined by the power supply that the pullup resistors connect to when designing
    the system. As computer systems started using 3.3 V or even down to 1.8 V, system
    designers began hooking up those pullup resistors to power supplies other than
    5 V.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当I²C在1980年代初期设计时，5 V逻辑是主流的设计技术，因此原始的I²C假设使用5 V逻辑信号。然而，由于I²C总线基于开漏连接，高电压电平完全由系统设计时上拉电阻连接的电源决定。随着计算机系统开始使用3.3
    V甚至低至1.8 V，系统设计师开始将这些上拉电阻连接到5 V以外的电源。
- en: From the perspective of the I²C bus, as long as the controllers and peripherals
    can handle and properly work with the voltage levels appearing on the bus, any
    voltage *should* work fine. In reality, however, some voltages may cause problems.
    For this reason, recent I²C standards state that the voltage on the bus must be
    at least 2 V (so 1.8-V logic won’t work). They also specify that a logic high
    is defined as greater than 70 percent of the power supply voltage and a logic
    low is defined as less than 30 percent of the power supply voltage. Today, generic
    I²C devices almost always expect 5-V or 3.3-V logic.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从I²C总线的角度来看，只要控制器和外围设备能够处理并正确地工作于总线上出现的电压电平，任何电压*应该*都能正常工作。然而，实际上，一些电压可能会导致问题。为此，最近的I²C标准规定，总线上的电压必须至少为2
    V（因此1.8 V逻辑无法工作）。它们还规定，逻辑高电平定义为高于电源电压的70%，而逻辑低电平定义为低于电源电压的30%。如今，通用的I²C设备几乎总是期望使用5
    V或3.3 V逻辑。
- en: 1.3.1 Level Shifting
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.1 电平转换
- en: What happens if you want to mix 3.3-V and 5-V I²C devices on the same bus? Sending
    a 3.3-V signal into a 5-V device probably won’t damage it, but the device may
    not interpret 3.3 V as a logic 1, because the standard calls for a logic 1 are
    equal to 3.5 V on a 5-V system (70 percent of 5 V is 3.5 V). Sending a 5-V signal
    into a 3.3-V device is far worse; often, this will destroy the device. Clearly,
    you should avoid this situation at all costs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在同一条总线上混合使用3.3V和5V的I²C设备，会发生什么情况？将3.3V信号发送到5V设备可能不会损坏它，但设备可能无法将3.3V识别为逻辑1，因为标准要求在5V系统中，逻辑1等于3.5V（5V的70%是3.5V）。将5V信号发送到3.3V设备则更为严重；通常情况下，这会损坏设备。显然，你应该尽一切可能避免这种情况。
- en: When mixing 3.3-V and 5-V (or other different voltage range) devices on the
    same I²C bus, you must use *voltage translation*, or *level shifting*, to convert
    the actual voltage on the bus to something that is compatible with the device(s).
    NXP Semiconductors provides a technical note describing how to do this using discrete
    MOSFETs (see “For More Information” at the end of this chapter). Another solution
    is to purchase a commercial-off-the-shelf (COTS) part such as the Adafruit, four-channel,
    I²C-safe, bidirectional logic level converter (BSS138). The Adafruit BSS138 device
    provides a bridge between two I²C buses operating at 3.3 V and 5 V—or, if you
    need a larger voltage range, it’s rated down to 1.8 V and up to 10 V. As I’m writing
    this, these Adafruit devices cost about $4 each (US) and support two independent
    I²C bus level shifters (the I²C bus requires two level shifters, one for the SDA
    line and one for the SCL line).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当在同一个I²C总线上混合使用3.3V和5V（或其他不同电压范围）设备时，必须使用*电压转换*或*电平转换*，将总线上的实际电压转换为与设备兼容的电压。NXP半导体公司提供了一份技术说明，描述了如何使用离散MOSFET进行此操作（参见本章结尾的“更多信息”）。另一种解决方案是购买现成的商用部件，如Adafruit的四通道I²C安全双向电平转换器（BSS138）。Adafruit
    BSS138设备提供了一个桥接器，用于连接运行在3.3V和5V的两个I²C总线——或者，如果需要更大的电压范围，它的工作电压范围为1.8V至10V。正如我写这段文字时所说，这些Adafruit设备的价格大约是每个4美元（美国），并支持两个独立的I²C总线电平转换器（I²C总线需要两个电平转换器，一个用于SDA线，另一个用于SCL线）。
- en: A third option is to level-shift with the TCA9548A I²C multiplexer device. This
    IC will split the I²C bus into eight separately controlled I²C buses. Each independent
    bus can have its own pullup resistor to an independent power supply (for example,
    3.3 V or 5 V). Therefore, you can put the 3.3-V devices on one bus and the 5-V
    devices into another. The incoming bus (from the CPU to the TCA9548A) can be either
    voltage. See Chapter 12 for more information.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种选择是使用TCA9548A I²C多路复用器进行电平转换。这个集成电路将I²C总线分成八个分别控制的I²C总线。每个独立的总线可以连接到独立的电源（例如，3.3V或5V）并配备独立的上拉电阻。因此，你可以将3.3V设备放在一条总线上，将5V设备放在另一条总线上。传入的总线（从CPU到TCA9548A）可以是任何电压。更多信息请参见第12章。
- en: 1.4 Choosing Pullup Resistor Sizes
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 选择上拉电阻的大小
- en: Choosing resistor sizes for the SDA and SCL pullup resistors requires a bit
    of thought. While I won’t go into the heavy math behind this choice, keep in mind
    that pullup resistors should be somewhere in the range of 1 kΩ to about 20 kΩ
    based on the supply voltage and bus capacitance. The higher the bus capacitance
    (in particular, the longer your I²C bus lines are), the lower the resistor should
    be. The minimum value is generally determined by the power supply voltage. For
    3.3-V systems, you can go to slightly below 1 kΩ, if you have to. For 5-V systems,
    1.5 kΩ is probably as low as you should go.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 选择SDA和SCL上拉电阻的大小需要一些思考。虽然我不会深入讲解这个选择背后的复杂数学原理，但请记住，上拉电阻的大小应该在1 kΩ到大约20 kΩ之间，具体取决于电源电压和总线电容。总线电容越大（特别是当I²C总线较长时），电阻应该越小。最小值通常由电源电压决定。对于3.3V系统，如果需要，可以将电阻值设置为略低于1
    kΩ。对于5V系统，1.5 kΩ大概是你应该选择的最低值。
- en: Generally, most systems start out with 4.7-kΩ pullups and go down from there
    if necessary. Note that if you are using commonly available COTS parts, such as
    breakout boards from Adafruit, SparkFun, or Seeed Studio, the boards often have
    pullup resistors already installed. If you attach two or more of these devices
    to your system, you have to compute the final resistance using a parallel resistance
    calculation (1/*R* = 1/*R*[1] + 1/*R*[2] + . . . + 1/*R*[*n*]). This means if
    you install two boards, each with a 4.7-kΩ pullup, you’ve actually got 2.35-kΩ
    pullups on the two lines. If you add too many of these boards on the same bus,
    you can wind up with pullup values below the minimum suggested resistances.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，大多数系统开始时会使用4.7 kΩ的上拉电阻，并在必要时逐步降低。请注意，如果你使用的是常见的COTS零件，例如Adafruit、SparkFun或Seeed
    Studio的扩展板，这些板子上通常已经安装了上拉电阻。如果你将两个或更多此类设备连接到系统中，必须通过并联电阻计算来计算最终的电阻值（1/*R* = 1/*R*[1]
    + 1/*R*[2] + . . . + 1/*R*[*n*]）。这意味着如果你安装了两块板子，每块板子上有4.7 kΩ的上拉电阻，你实际上在这两条线路上有2.35
    kΩ的上拉电阻。如果你在同一总线上添加过多这样的板子，可能会导致上拉电阻值低于建议的最小电阻值。
- en: 1.5 Bus Capacitance and Pullup Resistor Values
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 总线电容和上拉电阻值
- en: 'The speed of the I²C bus, which I’ll discuss further in the next section, is
    largely determined by the value of the pullup resistors (*R*[*p*]) and the bus
    capacitance (*C*[*p*]). Although the system designer has direct control over the
    value of the pullup resistors, bus capacitance is mostly a function of two things:
    input capacitance of the devices connected to the bus, and the length of the bus
    itself. Capacitance increases with bus length, as does resistance, though only
    by a small and generally insignificant amount. Why do these two parameters affect
    bus speed?'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: I²C总线的速度（在下一节中我会进一步讨论）主要由上拉电阻的值（*R*[*p*]）和总线电容的值（*C*[*p*]）决定。虽然系统设计师可以直接控制上拉电阻的值，但总线电容主要取决于两件事：连接到总线的设备的输入电容和总线本身的长度。总线长度增加时，电容也会增加，尽管电阻的增加非常小，通常可以忽略不计。那么，这两个参数为什么会影响总线速度呢？
- en: From electronics theory you know that the product of resistance and capacitance
    is time. In particular, 1 Ω × 1 farad = 1 second. When a device pulls one of the
    bus lines low or releases a bus line so that the pullup resistor returns the signal
    high, the bus capacitance and resistance affect the amount of time it takes for
    the signal to rise or fall. If this time exceeds a certain value, the I²C bus
    will not be able to operate at its full rated speed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 根据电子学原理，你知道电阻和电容的乘积是时间。具体来说，1 Ω × 1 法拉 = 1 秒。当设备拉低某条总线线路或释放总线线路，以便上拉电阻将信号拉高时，总线电容和电阻会影响信号上升或下降所需的时间。如果这个时间超过一定值，I²C总线将无法以其最大额定速度运行。
- en: The I²C standard limits bus capacitance to 400 pF (*picofarads*, each of which
    is one trillionth of a farad). A typical pullup resistor on the I²C bus is between
    1 kΩ and 10 kΩ. This produces rise times in the range of 0.4 μsec (*microseconds*)
    to 4 μsec. If the I²C bus is operating at 100 kHz (that is, a 10-μsec period),
    a 10-kΩ pullup (4-μsec rise time) will likely not work out well. The solution
    is to reduce the capacitance or the resistance.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: I²C标准将总线电容限制为400 pF（*皮法*，每个皮法是法拉的十亿分之一）。I²C总线上的典型上拉电阻值在1 kΩ到10 kΩ之间。这会产生0.4
    μsec（*微秒*）到4 μsec的上升时间。如果I²C总线以100 kHz的频率工作（即10 μsec周期），使用10 kΩ的上拉电阻（4 μsec上升时间）可能无法正常工作。解决方案是减少电容或电阻。
- en: The primary way to reduce bus capacitance is to keep the bus as short as possible.
    Longer bus lines dramatically increase the bus capacitance. You can also reduce
    bus capacitance by putting fewer I²C devices on the bus. If you must put a fixed
    number of devices on the bus, you can reduce the number of devices on a given
    bus by using two separate buses.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 减少总线电容的主要方法是尽量缩短总线的长度。较长的总线线路会显著增加总线电容。你还可以通过减少总线上I²C设备的数量来降低总线电容。如果必须在总线上连接固定数量的设备，可以通过使用两个独立的总线来减少每条总线上的设备数量。
- en: Of course, another solution to reducing the rise time is to reduce the value
    of the pullup resistor. Using a 4.7-kΩ resistor rather than a 10-kΩ resistor,
    for example, cuts the rise time by about one half.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，减少上升时间的另一个解决方案是减小上拉电阻的值。例如，使用4.7 kΩ电阻而不是10 kΩ电阻可以将上升时间减少大约一半。
- en: 1.5.1 What If the Bus Capacitance Is Too High?
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.1 如果总线电容过高怎么办？
- en: Reducing bus capacitance can be a difficult process. Shortening the I²C bus
    length is the primary approach. You can also use better cabling if the I²C signals
    are transmitted across wires, or you can reduce the number of devices on the bus
    (for example, move half the devices to a second I²C bus).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 降低总线电容可能是一个困难的过程。缩短I²C总线长度是主要的方法。如果I²C信号通过导线传输，你还可以使用更好的电缆，或者减少总线上的设备数量（例如，将一半设备移到第二条I²C总线上）。
- en: 'If these solutions are impossible or insufficient, reduce the bus speed. If
    you’re running at 400 kHz, drop down to 100 kHz; if you’re already at 100 kHz,
    drop down to 50 kHz, and so on. If this doesn’t solve the problem, a major circuit
    redesign may be necessary. Another solution to consider at this point is a differential
    bus driver like the SparkFun QwiicBus Kit: [https://www.sparkfun.com/products/17250](https://www.sparkfun.com/products/17250).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些解决方案不可行或不足以解决问题，可以降低总线速度。如果当前速度为400 kHz，可以降低到100 kHz；如果已经是100 kHz，可以降低到50
    kHz，以此类推。如果这仍然无法解决问题，可能需要进行重大电路重设计。此时，另一个可以考虑的解决方案是像SparkFun QwiicBus Kit这样的差分总线驱动器：[https://www.sparkfun.com/products/17250](https://www.sparkfun.com/products/17250)。
- en: 1.6 I²C Bus Speeds
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 I²C 总线速度
- en: 'As discussed, the I²C bus has two signal lines: serial data and serial clock.
    Controllers transmit data to and from peripherals on the SDA line. The SCL line
    controls the speed at which this serial data transfer takes place. The frequency
    of the signal on the SCL line controls how fast data moves between the controller
    and peripheral devices. The I²C bus standard defines the following data transfer
    rates:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，I²C总线有两条信号线：串行数据线和串行时钟线。控制器通过SDA线与外设之间传输数据。SCL线控制着串行数据传输的速度。SCL线上的信号频率决定了数据在控制器和外设之间的传输速度。I²C总线标准定义了以下数据传输速率：
- en: '*Standard mode*: 100-kHz SCL frequency, transferring data between devices at
    100 kbit/sec'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标准模式*：100 kHz的SCL频率，在设备之间以100 kbit/sec的速度传输数据。'
- en: '*Fast mode*: 400-kHz SCL frequency, transferring data between the controller
    and peripherals at 400 kbit/sec'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*快速模式*：400 kHz的SCL频率，在控制器和外设之间以400 kbit/sec的速度传输数据。'
- en: '*Fast mode plus*: 1-MHz SCL frequency, transferring data between the controller
    and peripherals at 1 Mbit/sec'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*快速模式加*：1 MHz的SCL频率，在控制器和外设之间以1 Mbit/sec的速度传输数据。'
- en: '*High-speed mode*: Up to 3.4-MHz SCL frequency, transferring data between the
    controller and peripherals at up to 3.4 Mbit/sec'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高速模式*：最高支持3.4 MHz的SCL频率，在控制器和外设之间以最高3.4 Mbit/sec的速度传输数据。'
- en: '*Ultra-fast mode*: 5-MHz SCL frequency, though data transmission is unidirectional
    only'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*超高速模式*：5 MHz的SCL频率，但数据传输仅为单向。'
- en: In practice, the upper bound on the I²C bus frequency is largely determined
    by the bus capacitance pullup resistors on the bus. However, there generally isn’t
    a lower bound on the frequency. Indeed, many peripheral devices will actually
    freeze data transmission using *clock stretching* (see section 1.9, “Clock Stretching,”
    later in this chapter) to provide the peripheral time to process data coming from
    the controller, which effectively reduces the clock speed and average data transmission
    speed. Furthermore, there is no requirement that the controller device place a
    100-kHz signal (or whatever frequency) on the SCL line. It could run SCL at 50
    kHz or any other frequency less than the usual clock speed, if desired.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，I²C总线频率的上限主要由总线上拉电阻的总线电容决定。然而，通常没有频率的下限。实际上，许多外设会使用*时钟拉伸*（参见本章后面的第1.9节“时钟拉伸”）来冻结数据传输，以便外设有时间处理来自控制器的数据，这有效地降低了时钟速度和平均数据传输速度。此外，控制器设备不要求在SCL线上输出100
    kHz信号（或其他频率）。如果需要，SCL频率可以设置为50 kHz或任何低于常规时钟速度的频率。
- en: The SCL signal is *not* a free-running clock. The I²C controller explicitly
    toggles this line when it shifts a bit onto the SDA line. When the controller
    is not transmitting or receiving data on the SDA line, the controller leaves the
    SCL line programmed high. The I²C bus frequency, therefore, is the SCL frequency
    during data transactions on the I²C bus.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: SCL信号*不是*一个自由运行的时钟。当控制器将一个比特移到SDA线上时，I²C控制器显式地切换该线。当控制器不在SDA线上发送或接收数据时，控制器会将SCL线保持为高电平。因此，I²C总线频率就是数据传输过程中的SCL频率。
- en: Probably the main limitation on the I²C bus speed is that you have to run the
    bus at the speed of the slowest devices on the bus. If there is a 100-kbit/sec
    peripheral on the bus, you must run the bus at 100 kHz, even when communicating
    with 400-kbit/sec (or faster) peripherals on the same bus. Because most I²C-compatible
    ICs are 100- or 400-kbit/sec devices, systems rarely run the I²C bus above 400
    kHz except for some very special hardware-specific cases. Typically, if you want
    to run above 400 kHz, you switch to the SPI bus.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: I²C 总线速度的主要限制可能是你必须以总线上最慢设备的速度运行总线。如果总线上有一个 100 kbit/sec 的外设，你必须以 100 kHz 的速度运行总线，即使与同一总线上的
    400 kbit/sec（或更快）外设通信也是如此。因为大多数 I²C 兼容的集成电路是 100 或 400 kbit/sec 的设备，所以除了一些非常特殊的硬件特定情况外，系统很少将
    I²C 总线运行超过 400 kHz。通常，如果你想运行超过 400 kHz，你会切换到 SPI 总线。
- en: 1.7 Multicontroller I²C Bus Clock Synchronization
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7 多控制器 I²C 总线时钟同步
- en: The I²C bus optionally supports multiple controllers on the same bus, which
    is known as a *multicontroller* *configuration*. In such cases the SCL frequencies
    of the two controllers must match, and they must both support multicontroller
    operation. However, running at the same frequency is not a sufficient condition
    for a multicontroller environment; their clocks must also be synchronized. Two
    controllers operate asynchronously with respect to one other. That is, if the
    bus is currently not being used by either controller, both controllers could decide
    to use the bus at the same time. However, it’s unlikely that both controllers
    will decide to activate their SCL lines at exactly the same instant. The I²C protocol
    requires the two controllers’ clock signals to rise and fall at roughly the same
    time to maintain appropriate timing. To achieve this, the I²C protocol introduces
    a clock synchronization operation that delays the start of one of the signals
    so they rise and fall approximately together after the synchronization operation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: I²C 总线可选地支持多个控制器在同一总线上运行，这被称为*多控制器* *配置*。在这种情况下，两个控制器的 SCL 时钟频率必须匹配，并且它们必须都支持多控制器操作。然而，仅仅在相同频率下运行并不足以满足多控制器环境的要求；它们的时钟也必须同步。两个控制器是相对于彼此异步运行的。也就是说，如果总线当前没有被任何控制器使用，两个控制器可能都会决定同时使用总线。然而，两个控制器几乎不可能在完全相同的时刻决定激活它们的
    SCL 线。I²C 协议要求两个控制器的时钟信号大致在同一时刻上升和下降，以保持适当的时序。为此，I²C 协议引入了一种时钟同步操作，延迟其中一个信号的开始，使得它们在同步操作后大致同时上升和下降。
- en: Clock synchronization relies on a feature of an open-drain bus known as *wired-AND
    operation* that simulates a logical-AND circuit without additional hardware. The
    (two-input) logical-AND function produces a true result if and only if its two
    inputs are true. If either or both are false, the logical-AND function produces
    a false result. If you consider two open-drain devices connected to the SCL line,
    the result is equivalent to a logical-AND circuit. If both devices are programmed
    with a 1, so their outputs are in a high-impedance state, the pullup resistor
    on the SCL line pulls the bus high. If either or both devices are programmed such
    that the open-drain output is active, this pulls the SCL line to Gnd, resulting
    in a 0 on the SCL line.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟同步依赖于一种开漏总线的特性，称为*有线与操作*，它通过无需额外硬件的方式模拟逻辑与电路。逻辑与（两输入）函数仅在两个输入都为真时才产生正确的结果。如果任意一个或两个输入为假，逻辑与函数则产生错误的结果。如果考虑将两个开漏设备连接到
    SCL 线，那么结果就相当于一个逻辑与电路。如果两个设备都被编程为 1，使它们的输出处于高阻抗状态，那么 SCL 线上的上拉电阻将把总线拉高。如果任意一个或两个设备被编程为使开漏输出处于激活状态，则将
    SCL 线拉至 Gnd，从而使 SCL 线为 0。
- en: Clock synchronization uses the wired-AND capabilities of the bus to synchronize
    the two clocks between controllers competing for the bus. The first controller
    to pull the SCL line low begins counting off its low period, approximately one
    half of the clock period. Sometime later (still within the low period), the second
    controller pulls the SCL line low. When the first controller reaches the end of
    its low period, it releases the SCL line. However, as the second controller is
    still pulling the SCL line low, it remains low. Later, when the second controller
    releases the SCL line, it goes high since both controllers have released the SCL
    line, as shown in [Figure 1-2](#figure1-2).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟同步利用总线的有线与功能来同步两个控制器之间的时钟，这些控制器竞争使用总线。第一个将 SCL 线拉低的控制器开始计数它的低电平周期，大约是一个半时钟周期。稍后（仍在低电平周期内），第二个控制器将
    SCL 线拉低。当第一个控制器到达其低电平周期的结束时，它释放 SCL 线。然而，由于第二个控制器仍然拉低 SCL 线，它保持低电平。稍后，当第二个控制器释放
    SCL 线时，它将变为高电平，因为两个控制器都已释放 SCL 线，如 [图 1-2](#figure1-2) 所示。
- en: '![](image_fi/502468c01/f01002.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c01/f01002.png)'
- en: 'Figure 1-2: SCL driven low by multiple controllers'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-2：多个控制器驱动低 SCL
- en: The first controller should note that the SCL line has not gone high and will
    delay counting off a one-half clock period (with SCL high, its *high period*)
    until it notices that the SCL line has actually gone high, as shown in [Figure
    1-3](#figure1-3). Then both controllers will start counting off the high period
    with the SCL line high. The first to count off the one-half clock period will
    pull the SCL line low; the second should follow shortly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个控制器应该注意到 SCL 线没有变为高电平，并将延迟计数一个半时钟周期（此时 SCL 为高电平，其 *高电平周期*），直到它注意到 SCL 线确实已经变为高电平，如
    [图 1-3](#figure1-3) 所示。然后，两个控制器都开始计数高电平周期，SCL 线为高电平。第一个计数完一个半时钟周期的控制器将把 SCL 线拉低；第二个控制器应紧随其后。
- en: '![](image_fi/502468c01/f01003.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502468c01/f01003.png)'
- en: 'Figure 1-3: SCL clock synchronization by multiple controllers'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-3：多个控制器进行 SCL 时钟同步
- en: At this point, the clocks should be fairly synchronized, with the low SCL period
    being the longest of the two controllers and the high SCL period being the shortest
    of the two. The two controllers will have similar, but not perfectly identical,
    timing for their clock periods.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，时钟应该已大致同步，其中低 SCL 周期为两个控制器中最长的，而高 SCL 周期为两个控制器中最短的。两个控制器的时钟周期将相似，但不会完全相同。
- en: 1.8 Multicontroller I²C Bus Arbitration
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.8 多控制器 I²C 总线仲裁
- en: Although synchronizing clocks is a necessary condition to allow multicontroller
    access to the I²C bus, it is not a sufficient condition. Even if two controllers
    have synchronized clocks, they could both be writing different data to the SDA
    line; that would corrupt the data on the bus and yield unreliable results. *Arbitration*
    is the process by which two (or more) controllers decide who can actually control
    the bus.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然时钟同步是允许多控制器访问 I²C 总线的必要条件，但它不是充分条件。即使两个控制器的时钟已经同步，它们也可能同时将不同的数据写入 SDA 线；这样会破坏总线上的数据，并导致不可靠的结果。*仲裁*是两个（或更多）控制器决定谁可以实际控制总线的过程。
- en: Before grabbing the I²C bus for its own use, a controller first checks to see
    if the bus is already in use. It does this by looking at the SDA and SCL lines
    for more than one half of a clock period and verifying that both signals remain
    high during this time. If so, it emits an I²C bus *start sequence* (see Chapter
    2) and begins transmitting data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器获取 I²C 总线使用权限之前，它首先会检查总线是否已经被占用。它通过观察 SDA 和 SCL 线超过一个半时钟周期，并验证在此期间两个信号是否保持高电平来实现。如果是这样，它会发出一个
    I²C 总线 *启动序列*（见第 2 章），并开始传输数据。
- en: Of course, there is no guarantee that the bus is actually free after this sequence,
    because a second controller could have started this same process at almost the
    same time. Therefore, the data the two controllers are placing on the bus could
    be in conflict. To detect this problem, the I²C bus arbitration system takes advantage
    of the wired-AND operation of the bus. If both devices write a 1 to the SDA line
    or both devices write a 0 to SDA, this line will correctly reflect the data signals
    being written by both controllers. However, if one controller writes a 0 while
    the other writes a 1, the controller writing the 0 will “win the war” on the SDA
    line—that is, the SDA line will be pulled low. To handle bus arbitration, the
    two controllers always look at the data they write on the SDA line to verify it
    contains what they’ve written. If a controller writes a value to the bus and then
    reads back a different value, then the two controllers have lost the arbitration
    and must stop controlling the bus.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这个序列之后并不能保证总线真的空闲，因为第二个控制器可能几乎在同一时间启动了相同的过程。因此，两个控制器在总线上放置的数据可能会发生冲突。为了检测这个问题，I²C总线仲裁系统利用了总线的线性与（wired-AND）操作。如果两个设备都向SDA线写入1，或者两个设备都向SDA写入0，这条线将正确反映两个控制器写入的数据。然而，如果一个控制器写入0，而另一个写入1，那么写入0的控制器将“赢得战争”——即SDA线将被拉低。为了处理总线仲裁，两个控制器始终查看它们写入SDA线的数据，以确认其包含的是它们所写入的内容。如果一个控制器向总线写入一个值，然后读取回一个不同的值，那么两个控制器就失去了仲裁，必须停止控制总线。
- en: Note that while the controllers are checking the data on the SDA line, they
    are also looking at the information appearing on the SCL line to synchronize the
    clocks while arbitrating for the bus.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在控制器检查SDA线上的数据时，它们还会观察SCL线上的信息，以便在仲裁总线时同步时钟。
- en: 1.9 Clock Stretching
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.9 时钟拉伸
- en: Clock signals are always generated by controller devices on the I²C bus. Controllers
    expect peripheral devices to operate properly at whatever clock frequency the
    controller signals on the SCL line. If the peripheral is incapable of operating
    at that frequency, the controller must be reprogrammed to talk to the peripheral
    at a lower clock speed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟信号始终由I²C总线上的控制器设备生成。控制器期望外设在控制器在SCL线上发出的时钟频率下正常运行。如果外设无法在该频率下操作，则必须重新编程控制器，以便以较低的时钟频率与外设通信。
- en: As you’ll see in the next chapter, data communication on the I²C bus consists
    of a string of 8-bit bytes transmitted to a peripheral with the peripheral acknowledging
    each byte, using an *acknowledge bit*. When transmitting the acknowledge bit back
    to the controller, the peripheral has the option of holding the clock line inactive
    for an arbitrary period of time. As noted in a couple of earlier sections, this
    is known as *clock stretching* (see sections 1.6 and 1.1, “I²C Bus Speeds” and
    “I²C Overview,” respectively). It effectively pauses the controller while the
    peripheral deals with the data that was transmitted to it (that is, clock stretching
    adds wait states to the I²C clock).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在下一章中将看到的，I²C总线上的数据通信由一串8位字节组成，这些字节传输到外设，外设通过使用*确认位*来确认每个字节。当外设将确认位传回控制器时，外设可以选择将时钟线保持为不活动状态，持续一个任意的时间段。如前几个章节所述，这就是所谓的*时钟拉伸*（参见1.6节和1.1节，分别为“I²C总线速度”和“I²C概述”）。它有效地暂停了控制器的操作，直到外设处理完接收到的数据（即时钟拉伸为I²C时钟添加了等待状态）。
- en: As with arbitration and clock synchronization, clock stretching takes advantage
    of the wired-AND operation of the I²C bus. If the peripheral is pulling the SCL
    line low when the controller sets it high, the SCL line remains low. The controller
    looks for this behavior and pauses data and clock output until the peripheral
    releases the SCL line.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与仲裁和时钟同步一样，时钟拉伸利用了I²C总线的线性与操作。如果外设在控制器将SCL线设为高时将其拉低，那么SCL线将保持低电平。控制器会监视这种行为，并暂停数据和时钟输出，直到外设释放SCL线。
- en: Clock stretching is an optional feature of the I²C protocol, meaning controllers
    don’t have to support this feature. Obviously, if a peripheral uses clock stretching,
    that device will be incompatible with controllers that don’t support this feature.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟拉伸是I²C协议的一个可选功能，这意味着控制器不必支持该功能。显然，如果外设使用时钟拉伸，则该设备将与不支持此功能的控制器不兼容。
- en: 1.10 Cross Talk
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.10 交叉干扰
- en: Another problem that can befall I²C communications is cross talk. If you run
    the SDA and SCL lines in parallel, especially over a long distance, signal changes
    on one line can affect the other. The SCL line affecting the SDA line is the most
    common problem. To reduce the problem of cross talk, the simple solution is to
    run a ground trace between the SCL and SDA lines on a PCB. Likewise, on a ribbon
    cable, running a ground line—or better yet, a power and a ground line—between
    the SDA and SCL conductors can reduce the incidence of cross talk.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: I²C 通信中可能遇到的另一个问题是串扰。如果你将 SDA 和 SCL 线并行布置，尤其是在较长距离下，一条线上的信号变化可能会影响另一条线。最常见的问题是
    SCL 线影响 SDA 线。为减少串扰问题，简单的解决方案是在 PCB 上的 SCL 和 SDA 线之间加一条接地走线。同样，在排线电缆中，在 SDA 和
    SCL 导线之间加一条接地线——或者更好的是，一条电源线和一条接地线——可以减少串扰发生的可能性。
- en: Although cross talk between the SCL and SDA lines represents the most common
    cross talk problems on the I²C bus, keep in mind that other signals can also induce
    noise on these two signal lines. When laying out PCBs, try to keep other high-frequency
    or high-current lines away from the SDA and SCL traces. Following good PCB design
    rules can really help. Likewise, when running I²C signals or ribbon cables (or
    other wiring), interleaving a ground wire between the SDA and SCL signals can
    reduce noise in the system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 SCL 和 SDA 线之间的串扰是 I²C 总线上最常见的串扰问题，但请记住，其他信号也可能在这两条信号线上引入噪声。在布置 PCB 时，尽量将其他高频或高电流的线路远离
    SDA 和 SCL 走线。遵循良好的 PCB 设计规则真的会有所帮助。同样，当运行 I²C 信号或排线（或其他布线）时，在 SDA 和 SCL 信号之间交错布置接地线可以减少系统中的噪声。
- en: One solution to the cross talk problem is to use differential line drivers on
    the I²C. SparkFun provides the QwiicBus Kit to solve cross talk and other issues
    with bus length. See “For More Information.”
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 解决串扰问题的一种方法是使用差分线驱动器在 I²C 上。SparkFun 提供了 QwiicBus 套件来解决串扰和其他由于总线长度导致的问题。详见“更多信息”。
- en: 1.11 Chapter Summary
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.11 小结
- en: 'In this chapter, you learned that the I²C bus solves several problems that
    designers of early embedded systems encountered when adding I/O to their designs.
    The two-wire (serial data and clock) interface reduces PCB size, noise, and design
    effort. The I²C bus features the following specifications:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了 I²C 总线解决了早期嵌入式系统设计人员在为设计添加 I/O 时遇到的几个问题。双线（串行数据和时钟）接口减少了 PCB 的尺寸、噪声和设计难度。I²C
    总线具有以下规格：
- en: Open-drain (open-collector) bus signals allowing multiple controllers and bidirectional
    communication on a single data line
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开漏（开集电极）总线信号，允许多个控制器在单条数据线上进行双向通信
- en: 100-kHz, 400-kHz, 1-MHz, 3.4 MHz, and 5-MHz bus speeds
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 100 kHz、400 kHz、1 MHz、3.4 MHz 和 5 MHz 总线速度
- en: 2 V to 5 V operation (via pullup resistors)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 V 到 5 V 工作（通过上拉电阻）
- en: Bus arbitration and clock stretching to resolve timing issues
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总线仲裁和时钟拉伸以解决时序问题
- en: A wide variety of I²C peripheral ICs that can be connected to any I²C bus
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可连接到任何 I²C 总线的各种 I²C 外设 IC
