- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 8 THE GENETIC ALGORITHM
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8 遗传算法
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/icon.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/icon.jpg)'
- en: Many wonders of modern science were inspired by nature. Airplane and glider
    designs were based on the flight of birds. Camouflage—a tactic for survival—derives
    from mimicry, a form of antipredator adaptation. The hooked barbs of a thistle
    led to the invention of Velcro. Even rather dull-looking termite mounds teach
    us about natural ventilation and cooling, an idea used in modern architecture.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现代科学的许多奇迹都受到大自然的启发。飞机和滑翔机的设计灵感来自鸟类的飞行。伪装——一种生存战术——源自拟态，这是一种抗捕食者适应形式。蓟的钩状刺使得魔术贴的发明成为可能。即使是看似普通的白蚁巢也教会了我们自然通风和降温的概念，这一理念被应用于现代建筑中。
- en: The world of computing is no different. The exciting field of machine learning,
    especially deep learning, is inspired by how the human brain processes information.
    By copying natural strategies that evolved over millions of years, we’ve developed
    algorithms to solve problems that were previously thought to be unsolvable with
    traditional mathematical tools.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学的世界也不例外。机器学习，特别是深度学习，的激动人心领域，灵感来源于人脑如何处理信息。通过模仿自然界数百万年来进化出的策略，我们已经发展出了能够解决以前认为传统数学工具无法解决的问题的算法。
- en: In this chapter and the next, you’ll learn how these nature-inspired algorithms
    work, about their advantages and limitations, and how to implement them in Kotlin.
    This chapter focuses on the genetic algorithm, an evolutionary process–based method.
    The next chapter covers particle swarm optimization and ant colony systems, two
    methods that mimic the behavior of biological agents or species. For each method,
    I’ll start with the key concepts and then show you how to code and apply them
    to real-world problems.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和下章中，你将了解这些自然启发式算法是如何工作的，它们的优势和局限性，以及如何在Kotlin中实现它们。本章重点介绍遗传算法，这是一种基于进化过程的方法。下章将介绍粒子群优化和蚁群系统，这两种方法模仿了生物体或物种的行为。对于每种方法，我将从关键概念开始，然后向你展示如何编写代码并将其应用于现实问题。
- en: Nature-Inspired Algorithms
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自然启发式算法
- en: Nature-inspired computing refers to observing how nature solves complex biological
    or physical problems and then applying similar strategies to contemporary scientific,
    engineering, or management problems. The core of nature-inspired computing is
    *nature-inspired algorithms (NIAs)*, which rely on strategies learned from nature.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 自然启发式计算指的是观察大自然如何解决复杂的生物学或物理问题，然后将类似的策略应用于当代的科学、工程或管理问题。自然启发式计算的核心是*自然启发式算法（NIAs）*，这些算法依赖于从自然界中学到的策略。
- en: Biology-based NIAs can be observed in natural processes, such as the evolution
    of a species or the functioning of neurons in the human brain. These processes
    led to the development of genetic algorithms and deep neural networks. Individual
    and collective behaviors of members (or *agents*) of a population can also form
    the basis for new NIAs. For example, the foraging behavior of ants around their
    colony inspired the ant colony optimization algorithm. Whereas ants tend to work
    independently without any explicit collaboration with other members of the colony,
    the behavior of a large school of fish or birds indicates swarm intelligence,
    which has led to the development of the particle swarm optimization algorithm.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 基于生物学的NIAs可以在自然过程中观察到，例如物种的进化或人脑中神经元的运作。这些过程促使了遗传算法和深度神经网络的发展。个体和群体成员（或*代理人*）的行为也可以为新的NIAs提供基础。例如，蚂蚁在巢穴周围觅食的行为启发了蚁群优化算法。而蚂蚁通常独立工作，不与其他巢穴成员明确协作，然而大群鱼群或鸟群的行为则显示出群体智能，这促使了粒子群优化算法的发展。
- en: Even nonliving natural processes involve embedded strategies optimized for meeting
    certain goals. Examples of such algorithms include gravitational search (based
    on Newton’s law of gravity) and simulated annealing (based on thermodynamics).
    In general, these algorithms serve as powerful tools for optimizing various processes
    or systems, resulting in significant gains in efficiency and cost savings.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是无生命的自然过程也涉及为实现特定目标而优化的嵌入式策略。这类算法的例子包括引力搜索（基于牛顿引力定律）和模拟退火（基于热力学）。通常，这些算法作为优化各种过程或系统的强大工具，能够显著提高效率并节省成本。
- en: Before going into detail on genetic algorithms, I’ll introduce the concepts
    of optimization and global solutions. Additionally, I’ll highlight instances where
    NIAs prove more effective than traditional mathematical tools for solving real-world
    problems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讲解遗传算法之前，我将介绍优化和全局解的概念。此外，我还将重点强调 NIAs 在解决现实问题时，相较于传统数学工具的优势。
- en: The Optimization Problem
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 优化问题
- en: NIAs are well suited to solving optimization problems, in which we want to find
    the best solution of all possible solutions. To solve such problems, we minimize
    or maximize an *objective function*, a mathematical expression that represents
    the goal of what we want to achieve through optimization. It is expressed in terms
    of one or more *decision variables*, quantities we can adjust to optimize the
    objective function.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: NIAs 非常适合解决优化问题，在这些问题中，我们希望找到所有可能解中的最佳解。为了解决这类问题，我们通过最小化或最大化一个*目标函数*来实现，目标函数是一个数学表达式，代表了我们通过优化所要达成的目标。它是通过一个或多个*决策变量*来表示的，这些是我们可以调整的量，以优化目标函数。
- en: For real-world problems, the decision variables will be bounded. Additional
    constraints may limit and define the decision space within which the optimal solution
    must be found.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现实世界中的问题，决策变量通常是有界的。额外的约束条件可能会限制并定义决策空间，在这个空间内必须找到最优解。
- en: 'Let’s consider a simple example with only one bounded decision variable:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个只有一个有界决策变量的简单例子：
- en: $Equation$ (8.1)$Equation$ ![](../images/eq8-1.jpg)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: $方程$ (8.1)$方程$ ![](../images/eq8-1.jpg)
- en: In Equation 8.1, *f*(*x*) is an objective function of a single variable *x*.
    Our goal is to find the value of *x* for which *f*(*x*) will be minimum, provided
    *x* stays within ±3.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在方程 8.1 中，*f*(*x*) 是一个单变量 *x* 的目标函数。我们的目标是找到一个 *x* 的值，使得 *f*(*x*) 达到最小值，前提是
    *x* 保持在 ±3 的范围内。
- en: Since *x* in this case has an exponent of 2, *x*² will always be positive (irrespective
    of whether *x* is positive or negative) and will continue to increase as *x* increases
    in absolute terms. Therefore, the right-hand side of Equation 8.1 will have the
    smallest value when *x* = 0\. In other words, the optimal solution (marked by
    an asterisk) for this problem is *x** = 0, and the corresponding optimum value
    of the function is *f*(*x*)* = –2.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在这种情况下 *x* 的指数是 2，*x*² 总是为正数（无论 *x* 是正数还是负数），并且随着 *x* 的绝对值增大，它的值也会持续增加。因此，方程
    8.1 右侧的值将在 *x* = 0 时最小。换句话说，这个问题的最优解（由星号标记）是 *x* = 0，且对应的最优函数值是 *f*(*x*) = –2。
- en: '[Figure 8-1](chapter8.xhtml#fig8-1) shows a visual representation of this function,
    which takes the shape of a parabola with its vertex at (0, –2). We can also visually
    confirm that *f*(*x*) has its minimum at point C (the vertex of the parabola).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-1](chapter8.xhtml#fig8-1) 显示了该函数的可视化表示，函数呈抛物线形状，其顶点位于 (0, –2)。我们还可以直观地确认
    *f*(*x*) 在点 C（抛物线的顶点）处达到最小值。'
- en: '![](../images/Figure8-1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-1.jpg)'
- en: 'Figure 8-1: The optimal value for a parabolic function'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-1：抛物线函数的最优值
- en: A property of this function allows us to identify the optimal solution without
    knowing its exact location. The dashed lines touching the function at points A,
    B, and C in [Figure 8-1](chapter8.xhtml#fig8-1) show the *slope*, also called
    the *gradient*, of the function at those locations. The slope of a function measures
    how much the value of a function changes when the value of the decision variable
    changes by a small amount. Notice that the gradient at point C, where the function
    value is minimum, is 0 (the dashed line is horizontal). Thus, if we randomly started
    our search for the optimal solution at point A, we could have moved in the direction
    of decreasing gradient (for example, from A to B or from B to C) until the gradient
    becomes 0\. If we continue to move beyond the vertex to the opposite side, the
    slope will change its direction and start increasing. This will cause the function
    value to increase, and we’ll move away from the optimal solution.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的一个特性使我们可以在不需要知道确切位置的情况下识别最优解。[图 8-1](chapter8.xhtml#fig8-1) 中接触函数的虚线显示了在
    A、B 和 C 点处的*斜率*，也称为*梯度*。函数的斜率衡量的是当决策变量发生微小变化时，函数值的变化量。请注意，在函数值最小的点 C，梯度为 0（虚线是水平的）。因此，如果我们随机从点
    A 开始寻找最优解，我们可以沿着梯度减小的方向（例如，从 A 到 B 或从 B 到 C）移动，直到梯度变为 0。如果我们继续超越顶点，进入对侧，斜率将改变方向并开始增大。这将导致函数值增大，并使我们远离最优解。
- en: For a function that is smooth (no kinks) and continuous (no jumps) and has only
    one maximum or minimum within the decision space, the gradient-based search strategy
    will always work in finding the *global optimum*— the best possible solution for
    a given problem. In fact, for a well-behaved function like this, we can find the
    optimal solution by simply setting the slope of the function with respect to the
    decision variable (called the derivative in differential calculus) to 0 and solving
    the resulting equation for the optimal solution. This approach will also work
    for functions with two or more decision variables as long as the function is *well
    behaved*, meaning it is both smooth and continuous.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个光滑（无拐点）且连续（无跳跃）并且在决策空间内仅有一个最大值或最小值的函数，基于梯度的搜索策略总是能找到*全局最优解*——给定问题的最佳解决方案。事实上，对于这种表现良好的函数，我们可以通过将函数关于决策变量的导数（在微积分中称为导数）设为0并求解得到最优解来找到最优解。只要函数*表现良好*，即光滑且连续，这种方法也适用于具有两个或更多决策变量的函数。
- en: Things get messier when we deal with a multimodal function with multiple locations
    where the gradient is 0, as shown in [Figure 8-2](chapter8.xhtml#fig8-2).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理一个具有多个梯度为0的位置的多模态函数时，事情变得更加复杂，如[图 8-2](chapter8.xhtml#fig8-2)所示。
- en: '![](../images/Figure8-2.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-2.jpg)'
- en: 'Figure 8-2: Local and global minima for a univariate function'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-2：单变量函数的局部和全局极小值
- en: '[Figure 8-2](chapter8.xhtml#fig8-2) shows four local minima at points A, C,
    D, and E, and one global minimum at point B within the decision space. In a situation
    like this, whether an algorithm based on gradient descent will converge to the
    global minimum depends on the point from which we start the search. Nothing guarantees
    that we’ll find the global minimum unless we make multiple attempts from different
    starting points (initial conditions).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-2](chapter8.xhtml#fig8-2)展示了决策空间内A、C、D、E点的四个局部极小值，以及B点的一个全局极小值。在这种情况下，基于梯度下降的算法是否能收敛到全局极小值，取决于我们从哪个点开始搜索。除非从不同的起始点（初始条件）进行多次尝试，否则无法保证找到全局极小值。'
- en: For a better appreciation of the challenge involved when we try to find global
    optima for a multivariate function, consider the graph in [Figure 8-3](chapter8.xhtml#fig8-3).
    This shows the results of the two-variable Eggholder function, discussed further
    in the final project of this chapter. For a problem like this, a simple gradient-based
    algorithm can easily get stuck at one of the many local minima. To make things
    worse, the equations defining such functions are typically not differentiable,
    and we cannot use calculus-based tools to estimate the global optima.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解在寻找多变量函数的全局最优解时所面临的挑战，请参考[图 8-3](chapter8.xhtml#fig8-3)中的图形。该图展示了两个变量Eggholder函数的结果，后续章节的最终项目将进一步讨论此函数。对于这样的一个问题，一个简单的基于梯度的算法很容易陷入多个局部极小值中的一个。更糟糕的是，定义这些函数的方程通常是不可微分的，因此我们不能使用基于微积分的工具来估算全局极小值。
- en: '![](../images/Figure8-3.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-3.jpg)'
- en: 'Figure 8-3: The Eggholder function with numerous local minima'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-3：具有多个局部极小值的Eggholder函数
- en: 'Functions of two decision variables have a silver lining, however: we can create
    3D plots of these functions for a bounded decision space. Based on a visual inspection
    of the surface or contour plots, it may then be possible to narrow down the search
    space to a number of smaller subzones where we can conduct an extensive local
    search to uncover the global minima (more than one global minimum could exist).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，具有两个决策变量的函数有一个银 lining：我们可以为有限决策空间中的这些函数绘制三维图。通过对表面图或等高线图的视觉检查，可能可以将搜索空间缩小到一些较小的子区域，在这些区域进行广泛的局部搜索，以发现全局极小值（可能存在多个全局极小值）。
- en: What about functions of higher dimensions? In fact, complex real-world optimization
    problems can have hundreds of decision variables. It is not humanly possible to
    conceive what a function of several hundred variables might look like in a *hyperspace*
    (a higher-dimensional space beyond human comprehension). Our best bet for identifying
    an optimal or near-optimal solution in a hyperspace is to conduct a broad-based
    search combining *heuristics* (special knowledge about the nature of the problem)
    and *randomization* (selecting initial conditions or intermediate values randomly).
    This strategy is likely to allow the algorithm to escape local optima and find
    solutions that are superior to what a pure random search might reveal. We typically
    repeat this process numerous times and accept the best-so-far solution as a proxy
    for the unknown global optima.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 那么高维函数呢？实际上，复杂的现实世界优化问题可能涉及数百个决策变量。人类不可能想象出一个由数百个变量组成的函数在*超空间*（超出人类理解的高维空间）中的样子。我们在超空间中识别最优或近似最优解的最佳方法是进行广泛的搜索，结合*启发式*（关于问题性质的特殊知识）和*随机化*（随机选择初始条件或中间值）。这一策略很可能使算法逃脱局部最优，找到比纯随机搜索更优秀的解。我们通常会多次重复这一过程，并将目前最好的解作为未知全局最优解的代理。
- en: Even when looking for an optimal combination of decision variables that can
    have only discrete values (whole numbers), the brute-force approach of trying
    out all possible combinations normally doesn’t work in higher dimensions. This
    is because the number of combinations may be so large that it is practically impossible
    to complete that search in a reasonable amount of time. It’s in this context that
    nature-inspired algorithms come to our rescue.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在寻找只有离散值（整数）的决策变量的最优组合时，暴力破解所有可能的组合通常也无法在更高维度中奏效。这是因为组合的数量可能大到几乎不可能在合理的时间内完成搜索。在这种情况下，自然启发算法能够救我们于水深火热之中。
- en: When to Use NIAs
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时使用自然启发算法（NIA）
- en: Compared to traditional mathematical tools, NIAs are less sensitive to the nature
    or complexity of the optimization problem. An objective function may be nonlinear,
    nonsmooth, multidimensional, and multimodal, but these attributes are not a big
    concern for NIAs (though we still have to choose the right tool from the basket
    of options). NIAs are especially suitable for solving very large optimization
    problems and finding near-optimal solutions without expending too many resources
    (such as computational time or energy use).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统数学工具相比，自然启发算法（NIA）对优化问题的性质或复杂度不那么敏感。一个目标函数可能是非线性、不光滑、多维的或多模态的，但这些特性对自然启发算法来说并不是什么大问题（尽管我们仍然需要从众多选项中选择合适的工具）。自然启发算法尤其适用于解决非常大的优化问题，并能在不消耗过多资源（如计算时间或能源）情况下找到近似最优解。
- en: 'Traditional optimization methods, whether they employ a gradient descent algorithm
    or not, are deterministic: if we start the search from a given point, we’ll always
    reach the same solution or approximation after a given number of steps. This feature
    makes deterministic algorithms more prone to getting stuck at local optima because
    no built-in freedom exists to explore a different path unless the initial condition
    is changed.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 传统优化方法，无论是否使用梯度下降算法，都是确定性的：如果我们从一个给定的点开始搜索，经过一定步数后，我们总是会到达相同的解或近似解。这个特性使得确定性算法更容易陷入局部最优，因为除非改变初始条件，否则没有内建的自由度去探索不同的路径。
- en: NIAs, on the other hand, are *stochastic*, meaning that their results cannot
    be predicted beforehand. This is because NIAs typically have multiple built-in
    steps that rely on random selection. For the same initial condition, a stochastic
    algorithm can produce very different results. This innate ability to randomly
    choose a different path allows NIAs to avoid getting stuck at local optima and
    to eventually find the global or near-global optima.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，自然启发算法是*随机的*，这意味着它们的结果无法提前预测。这是因为自然启发算法通常包含多个依赖于随机选择的内置步骤。对于相同的初始条件，随机算法可能会产生非常不同的结果。这种内在的随机选择不同路径的能力使得自然启发算法能够避免陷入局部最优，并最终找到全局最优或近似全局最优解。
- en: In addition, some NIAs are based on the efforts of agents that operate independently
    (for example, ants in the ant colony optimization algorithm). This allows us to
    implement the algorithm so that it can benefit from parallel processing to improve
    computational efficiency.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些自然启发算法基于独立操作的代理（例如，蚁群优化算法中的蚂蚁）。这使我们能够实现算法，从而利用并行处理提高计算效率。
- en: In sum, we can use NIAs to solve large, complex, multidimensional optimization
    problems for which no known analytical solutions exist or for which such solutions
    cannot be found due to the nature of the problem. However, NIAs are not the ideal
    choice for solving the many optimization problems that can be efficiently solved
    using deterministic methods (for example, using linear or integer programming
    or various graph search algorithms).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们可以使用自然启发算法来解决一些大型、复杂的多维优化问题，这些问题没有已知的解析解，或者由于问题的性质，无法找到这样的解。然而，NIA并非解决许多可以通过确定性方法高效解决的优化问题的理想选择（例如，使用线性或整数规划或各种图搜索算法）。
- en: An Overview of the Genetic Algorithm
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遗传算法概述
- en: The genetic algorithm is among the best-known NIAs. It is modeled after the
    biological evolution of species driven by both the sexual reproduction of parents,
    who contribute genetic materials, and natural selection (survival of the fittest).
    In addition to inheriting genes from its parents, the offspring’s *chromosomes*
    (collections of genes) undergo random alterations called *mutation* that introduce
    new features to its gene pool. The offspring is then subjected to a selection
    process based on its *fitness* (a measure of how well an individual contributes
    to reaching a certain goal) before it is allowed to reproduce. The process eventually
    leads to a generation of individuals with a significantly enhanced gene pool.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法是最著名的自然启发算法（NIA）之一。它的模型灵感来源于物种的生物进化过程，受父母的性繁殖（父母提供遗传物质）和自然选择（适者生存）驱动。除了继承父母的基因外，后代的*染色体*（基因集合）会经历随机变异，称为*突变*，这为基因库引入新的特征。随后，后代将通过基于*适应度*（衡量个体如何为实现某个目标做出贡献的标准）的选择过程，决定是否可以繁殖。最终，这一过程会导致一代具有显著增强基因库的个体的出现。
- en: '[Figure 8-4](chapter8.xhtml#fig8-4) shows the main components of the genetic
    algorithm.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-4](chapter8.xhtml#fig8-4)展示了遗传算法的主要组成部分。'
- en: '![](../images/Figure8-4.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-4.jpg)'
- en: 'Figure 8-4: The key components of the genetic algorithm'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-4：遗传算法的关键组成部分
- en: All genetic algorithms start with a population of randomly created individuals.
    Each individual is essentially a potential solution represented by its gene pool.
    These individuals are evaluated and screened based on their fitness, which we
    attempt to maximize or minimize until a termination condition is met. Otherwise,
    we choose a batch of individuals with better fitness values who are then allowed
    to mate, produce offspring, and replace their parents as the next generation.
    I’ll explain these steps further in the upcoming sections.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所有遗传算法都从一群随机创建的个体开始。每个个体本质上是一个潜在的解决方案，通过其基因库来表示。这些个体会根据其适应度进行评估和筛选，我们会尽力最大化或最小化适应度，直到满足终止条件。否则，我们会选择一批具有更好适应度值的个体，它们将进行交配、产生后代，并取代父母成为下一代。我将在接下来的章节中进一步解释这些步骤。
- en: Genetic Operators
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遗传算子
- en: Genetic operators include the three core components of genetic algorithms—selection,
    crossover, and mutation—that work in tandem and allow the algorithm to converge
    toward a solution. *Selection* refers to the process of choosing an individual
    from a population based on their fitness (their potential contribution to finding
    the optimal solution). Selection may involve the entire population or a subset
    of the population, as individuals are drawn at random based on specific strategies.
    *Crossover* involves combining genetic materials from parents to create offspring.
    In the genetic algorithm, it always involves two parents and is therefore a binary
    operator. *Mutation* is a random alteration of an individual’s genetic information.
    It is a unary operator because it is applied to one individual at a time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算子的核心组件包括遗传算法的三大要素——选择、交叉和变异，它们协同工作，使算法能够收敛到一个解。*选择*是指根据个体的适应度（其对找到最优解的潜在贡献）从种群中选择个体的过程。选择可以涉及整个种群，也可以是种群的一个子集，因为个体是根据特定策略随机抽取的。*交叉*是指结合父母的遗传材料来创造后代。在遗传算法中，它总是涉及两个父母，因此是一个二元操作。*变异*是对个体遗传信息的随机改变。它是一个单一操作，因为它一次只应用于一个个体。
- en: '#### Selection'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 选择'
- en: The selection operation ensures that better genes are passed on from one generation
    to the next. The implementation of this process may vary depending on the problem,
    but the end goal is to select two parents (chromosomes) to participate in the
    reproduction through crossover. The commonly used strategies for selection include
    tournament, roulette wheel, and rank-based selection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 选择操作确保更好的基因从一代传到下一代。这个过程的实现可能会根据问题的不同而有所变化，但最终目标是选择两个父母（染色体），通过交叉参与繁殖。常用的选择策略包括锦标赛、轮盘赌和基于排名的选择。
- en: Tournament
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 锦标赛
- en: The tournament selection process is based on running fitness-based competitions
    among randomly selected individuals, as shown in [Figure 8-5](chapter8.xhtml#fig8-5).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 锦标赛选择过程基于在随机选择的个体之间进行适应度竞赛，如[图8-5](chapter8.xhtml#fig8-5)所示。
- en: '![](../images/Figure8-5.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-5.jpg)'
- en: 'Figure 8-5: Using tournaments to select parents'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-5：使用锦标赛选择父母
- en: To create a new child, the process starts by randomly selecting four individuals
    grouped into two pairs. From each pair, the individual with better fitness is
    selected as a parent. The process selects two parents per round who will reproduce
    via crossover (explained later) to give birth to an offspring.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个新的后代，过程开始时会随机选择四个个体并将其分为两对。从每一对中，选择适应度较好的个体作为父母。这个过程每轮选择两个父母，它们将通过交叉（稍后会解释）进行繁殖，产生一个后代。
- en: Roulette Wheel
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 轮盘赌
- en: As the name implies, roulette wheel selection is comparable to spinning a dial
    on a board divided into segments. The area of these segments is proportional to
    the relative fitness of the members of the population from which parents are to
    be chosen. Let me explain the process with a numerical example, as shown in [Table
    8-1](chapter8.xhtml#tab8-1).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，轮盘赌选择类似于旋转一个分成若干部分的圆盘。这些部分的面积与从中选择父母的种群成员的相对适应度成正比。让我通过一个数字例子来解释这个过程，如[表8-1](chapter8.xhtml#tab8-1)所示。
- en: 'Table 8-1: Roulette Wheel Data'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-1：轮盘赌数据
- en: '| Individual | Fitness | Relative fitness (RF) | Cumulative RF |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 个体 | 适应度 | 相对适应度 (RF) | 累积RF |'
- en: '| --- | --- | --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| P1 | 12 | 0.286 | 0.286 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| P1 | 12 | 0.286 | 0.286 |'
- en: '| P2 | 5 | 0.119 | 0.405 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| P2 | 5 | 0.119 | 0.405 |'
- en: '| P3 | 8 | 0.190 | 0.595 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| P3 | 8 | 0.190 | 0.595 |'
- en: '| P4 | 10 | 0.238 | 0.833 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| P4 | 10 | 0.238 | 0.833 |'
- en: '| P5 | 4 | 0.095 | 0.929 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| P5 | 4 | 0.095 | 0.929 |'
- en: '| P6 | 3 | 0.071 | 1.000 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| P6 | 3 | 0.071 | 1.000 |'
- en: '| SUM = | 42 | 1.000 |  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 总和 = | 42 | 1.000 |  |'
- en: '[Figure 8-6](chapter8.xhtml#fig8-6) shows the graphical representation of the
    example in [Table 8-1](chapter8.xhtml#tab8-1).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-6](chapter8.xhtml#fig8-6)展示了[表8-1](chapter8.xhtml#tab8-1)中的示例图示。'
- en: '![](../images/Figure8-6.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-6.jpg)'
- en: 'Figure 8-6: Selecting parents using the roulette wheel method'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-6：使用轮盘赌方法选择父母
- en: In this example, we consider a population of six individuals, P1 through P6\.
    Their fitness values are given in the second column of [Table 8-1](chapter8.xhtml#tab8-1).
    The relative fitness (RF) values are calculated by dividing individual fitness
    values by the sum of all individual fitness values (for example, RF for P1 = 12/42).
    The last column represents the cumulative RF (CRF), which is created by adding
    all RF values up to a certain row. For example, the CRF corresponding to P2 =
    0.286 + 0.119 = 0.405\. The last CRF, which is the sum of all individual RF values,
    will be 1.0\. In the roulette wheel scheme, RF values are used as proxy probabilities
    for individuals to be selected at random when an unbiased virtual dial is spun.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们考虑了一个由六个个体（P1 到 P6）组成的群体。它们的适应度值在[表 8-1](chapter8.xhtml#tab8-1)的第二列中给出。相对适应度（RF）值是通过将个体的适应度值除以所有个体适应度值之和计算得出的（例如，P1
    的 RF = 12/42）。最后一列表示累积 RF（CRF），它是通过将所有 RF 值累加到某一行得到的。例如，P2 对应的 CRF = 0.286 + 0.119
    = 0.405。最后的 CRF，即所有个体 RF 值的总和，将为 1.0。在轮盘赌方案中，RF 值作为个体随机选择的代理概率，当一个没有偏见的虚拟拨盘旋转时，它将决定被选择的个体。
- en: 'In [Figure 8-6](chapter8.xhtml#fig8-6), these six individuals are represented
    by six different segments whose areas are the same as their RF values (shown next
    to the individual names). To implement the roulette wheel method, we draw a random
    number between 0 and 1 from a uniform distribution, which has the same effect
    as spinning the dial. (This is done programmatically by using the random() method
    in the standard Kotlin math library.) Let’s say that the value of this random
    number is 0.68, equivalent to having the dial stop inside the fourth segment (between
    CRFs of 0.595 and 0.833). Based on this draw, we would select P4 as parent 1 and
    repeat the process one more time to choose parent 2.  ##### Rank-Based Selection'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 8-6](chapter8.xhtml#fig8-6)中，这六个个体被表示为六个不同的区域，其面积与它们的 RF 值相同（在个体名称旁边显示）。为了实现轮盘赌方法，我们从
    0 到 1 的均匀分布中随机抽取一个数字，这与旋转拨盘的效果相同。（通过使用 Kotlin 标准数学库中的 random() 方法可以编程实现此操作。）假设该随机数的值为
    0.68，相当于拨盘停在第四个区域内（介于 0.595 和 0.833 的 CRF 之间）。根据这个抽取结果，我们会选择 P4 作为父母 1，并再次重复这一过程选择父母
    2。##### 基于排名的选择
- en: The third selection method, rank-based selection, is very similar to the roulette
    wheel method. Here, we order the individuals in ascending or descending order,
    depending on the problem, and assign each individual a rank based on their fitness.
    If two or more individuals have the same fitness, they are assigned an average
    value (based on their positions in the ordered list) as their rank. Finally, the
    ranks are used to calculate RF values and select the mating parents as we would
    using the roulette wheel scheme.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种选择方法，基于排名的选择，非常类似于轮盘赌方法。在这种方法中，我们根据问题的不同，将个体按升序或降序排序，并根据它们的适应度分配一个排名。如果两个或更多个体的适应度相同，它们将根据在有序列表中的位置被分配一个平均排名。最后，利用这些排名计算
    RF 值，并像使用轮盘赌方法一样选择配对父母。
- en: Crossover
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 交叉
- en: The crossover operation is designed to intermix the genes of two parents to
    create one or two offspring who become members of the next generation. As with
    the selection operator, many ways of splitting the chromosomes and recombining
    the genes are available. [Figure 8-7](chapter8.xhtml#fig8-7) shows the schema
    for a simple but effective approach to this operation, called a single-point crossover.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉操作旨在将两个父母的基因混合，生成一个或两个后代，后代将成为下一代的成员。与选择操作符一样，分裂染色体和重组基因的方法有很多种。[图 8-7](chapter8.xhtml#fig8-7)展示了一种简单但有效的交叉操作方法，称为单点交叉。
- en: '![](../images/Figure8-7.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-7.jpg)'
- en: 'Figure 8-7: The single-point crossover operation'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-7：单点交叉操作
- en: We start the process by identifying two parents through the selection operation.
    These parents would normally have chromosomes consisting of different genes. In
    the example in [Figure 8-7](chapter8.xhtml#fig8-7), both parents have chromosomes
    made of binary genes denoted by 0 or 1\. Parent 1’s genes are shown as white cells,
    whereas parent 2’s genes are gray cells.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过选择操作识别两个父母来开始这一过程。这些父母通常会有由不同基因组成的染色体。在[图 8-7](chapter8.xhtml#fig8-7)中的例子里，两个父母都有由二进制基因（以
    0 或 1 表示）组成的染色体。父母 1 的基因以白色单元格表示，而父母 2 的基因以灰色单元格表示。
- en: The first step of the crossover operation is to draw a random integer from a
    uniform distribution between 1 and the number of genes minus 1, which would be
    between 1 and 5 (inclusive) in our example. Let’s say the integer drawn is 4\.
    We’d then split chromosomes of both parents at this location (between the fourth
    and fifth genes shown in [Figure 8-7](chapter8.xhtml#fig8-7)). Finally, we’d swap
    the split parts by adding the last two genes from parent 2 to parent 1 (the two
    gray cells of child 1) and adding the last two genes from parent 1 to parent 2
    (the two white cells of child 2).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉操作的第一步是从1到基因数量减1之间的均匀分布中抽取一个随机整数，在我们的示例中，该值将位于1到5之间（包括1和5）。假设抽到的整数是4。然后，我们将在此位置（[图
    8-7](chapter8.xhtml#fig8-7)中的第四和第五个基因之间）分割两个父代的染色体。最后，我们将交换分割部分：将父代2的最后两个基因添加到父代1中（子代1的两个灰色单元格），并将父代1的最后两个基因添加到父代2中（子代2的两个白色单元格）。
- en: In this example, we used two parents to create two children. However, we could
    also decide to produce only one child per iteration to keep the algorithm simple
    and easy to code. For *real-coded genes*—genes represented by real numbers—a crossover
    operation will produce only one child because of the way the method is implemented.
    We’ll discuss real-coded genes further in the final project of this chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了两个父代来创造两个子代。然而，我们也可以决定每次迭代只产生一个子代，以保持算法简单并便于编码。对于*实数编码基因*（由实数表示的基因），由于方法的实现方式，交叉操作将只产生一个子代。我们将在本章的最终项目中进一步讨论实数编码基因。
- en: Many other types of crossover operations, such as multipoint crossover and ordered
    crossover, exist. For real-coded genes used in mathematical function optimization,
    crossover operations could be based on an arithmetic, geometric, or weighted mean
    of fitness values.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他类型的交叉操作，例如多点交叉和有序交叉。对于用于数学函数优化的实数编码基因，交叉操作可以基于适应度值的算术、几何或加权均值。
- en: Mutation
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 突变
- en: Mutation involves randomly changing the values of genes or, for real-coded genes,
    adding a small noise to those values before adding a child to the next generation.
    Mutation is applied to every gene in the chromosome one at a time. First, we randomly
    draw a real number between 0 and 1 and compare that with a mutation threshold
    (probability), typically set to a very small value. If the random value drawn
    is less than or equal to the mutation threshold, we alter the genetic content
    for that gene. For a binary chromosome where the genes are either 1 or 0 (indicating
    inclusion or exclusion of some entity in the solution), this alteration is conducted
    by flipping the gene value from 0 to 1 or vice versa.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 突变涉及随机改变基因的值，或者对于实数编码的基因，在将后代添加到下一代之前，向这些值添加一些小的噪声。突变应用于染色体中的每个基因，一次一个。首先，我们从0到1之间随机抽取一个实数，并将其与突变阈值（概率）进行比较，通常该值设置为非常小的值。如果抽取的随机值小于或等于突变阈值，我们将改变该基因的遗传内容。对于一个二进制染色体，其中的基因值为1或0（表示某个实体在解中是否包含），这种改变是通过将基因值从0翻转为1或反之进行的。
- en: '[Figure 8-8](chapter8.xhtml#fig8-8) visually explains this process.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-8](chapter8.xhtml#fig8-8)以图形方式解释了这一过程。'
- en: '![](../images/Figure8-8.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-8.jpg)'
- en: 'Figure 8-8: Mutation in a binary chromosome'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-8：二进制染色体中的突变
- en: In [Figure 8-8](chapter8.xhtml#fig8-8), the second and fifth genes have been
    randomly selected for mutation. Given that these are binary genes, their gene
    values have been flipped from 0 to 1.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 8-8](chapter8.xhtml#fig8-8)中，第二个和第五个基因被随机选择进行突变。鉴于这些是二进制基因，它们的基因值已经从0翻转为1。
- en: Elitism
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 精英主义
- en: Before we move on to tackling our first genetic algorithm project, I’ll introduce
    one more important concept—*elitism*. This technique involves sorting the current
    population based on their fitness, then adding a fraction of that sorted population
    to the next generation before attempting crossover and mutation. This operation
    is called elitism because it favors the fittest individuals. Elitism generally
    helps reduce the number of computations needed to locate the optimal solution
    because it protects some of the best chromosomes from getting altered or diluted
    by crossover and mutation operations.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始解决第一个遗传算法项目之前，我还会介绍一个重要的概念——*精英主义*。这种技术涉及根据适应度对当前种群进行排序，然后将排序后的一部分个体添加到下一代，再进行交叉和突变操作。这个操作被称为精英主义，因为它偏向于保留最适应的个体。精英主义通常有助于减少寻找最优解所需的计算量，因为它保护了一些最优秀的染色体，避免它们在交叉和突变操作中被改变或稀释。
- en: 'Project 33: Evolve Gibberish into Shakespeare'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 33：将胡言乱语演变为莎士比亚语言
- en: 'In our first coding project, we’ll create a population with random collections
    of genes as their chromosomes. We’ll then use a genetic algorithm to refine those
    chromosomes until one of the individuals becomes as eloquent as Shakespeare and
    repeats Hamlet’s famous line “To be, or not to be: that is the question,” expressed
    in its gene sequence!'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个编码项目中，我们将创建一个包含随机基因集合作为染色体的种群。接着，我们将使用遗传算法来优化这些染色体，直到其中一个个体变得像莎士比亚一样口才出众，并重复《哈姆雷特》中那句著名的台词：“生存还是毁灭，这是个问题”，并将其表达在基因序列中！
- en: The Strategy
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 策略
- en: To solve this problem, we’ll create a population of size 100\. No hard-and-fast
    rule applies on this, and a bit of experimentation is required to estimate a reasonable
    size for a given problem. Many factors are at play that will determine the convergence
    rate of the algorithm, including population size, the way the genetic operators
    are implemented, and the stopping condition. One possible strategy is to start
    with a smaller population size and then gradually increase it until further improvements
    in the solution become negligible.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将创建一个大小为100的种群。对此没有严格的规定，需要通过一些实验来估计给定问题的合理种群规模。影响算法收敛速度的因素有很多，包括种群规模、遗传操作的实现方式以及停止条件。一种可能的策略是从较小的种群规模开始，然后逐步增加，直到进一步改进解决方案变得微不足道。
- en: Next, we need to determine the size of the chromosomes. For this specific problem,
    each individual’s chromosome will have 42 genes—the length of the text we aim
    to reproduce using the algorithm. These genes will be randomly selected from a
    pool of 87 genes, which in this case is a collection of alphanumeric characters
    (including punctuation and parentheses). Since our goal is to exactly match the
    target text, this collection includes both uppercase and lowercase letters.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确定染色体的大小。对于这个特定的问题，每个个体的染色体将包含42个基因——这是我们希望通过算法再现的文本的长度。这些基因将从87个基因的池中随机选择，这些基因池包含字母数字字符（包括标点符号和括号）。由于我们的目标是精确匹配目标文本，因此这个基因池包含了大写字母和小写字母。
- en: In our genetic algorithm implementation, we’ll use elitism and tournament-based
    selection as our operators. Additionally, we’ll employ a single-point crossover
    scheme. For mutation, we will use a threshold of 1/42 to ensure that on average
    one gene will mutate for each new child created via crossover.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的遗传算法实现中，我们将使用精英策略和基于竞赛的选择作为操作符。此外，我们将采用单点交叉方案。对于突变，我们将使用1/42的阈值，以确保每次交叉创建新个体时，平均每个基因会发生一次突变。
- en: The Code
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: The overall structure of the code closely resembles the general structure of
    the genetic algorithm described in [Figure 8-4](chapter8.xhtml#fig8-4). We’ll
    discuss each of its components in the following sections.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的整体结构与[图8-4](chapter8.xhtml#fig8-4)中描述的遗传算法的一般结构非常相似。我们将在接下来的章节中讨论它的每个组成部分。
- en: Global Declarations
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 全局声明
- en: In this code segment, we create a data class, and declare and/or set required
    global parameters and collections. We also create two mutable lists of data objects
    to store population states for the current and next generations.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码段中，我们创建了一个数据类，并声明和/或设置了所需的全局参数和集合。我们还创建了两个可变的数据对象列表，用来存储当前代和下一代的种群状态。
- en: '[PRE0]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s walk through this segment step by step. At the top of the block, we create
    a Solution object (data class) that will be used to create the individuals who
    will make up the population and undergo genetic alterations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步地讲解这个代码段。在代码块的顶部，我们创建了一个Solution对象（数据类），它将用于创建构成种群的个体，并进行基因变化。
- en: Next, we define the target string or the desired end state for the fittest individual
    in the population ❶. The target string has 42 characters (including spaces), which
    are stored in a string named TARGET. The target string is built from a pool of
    genes—characters that we typically use while composing phrases in English. This
    gene pool is saved as VALID_GENES ❷.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义目标字符串或种群中最适应个体的期望最终状态❶。目标字符串包含42个字符（包括空格），并存储在名为TARGET的字符串中。该目标字符串是从一个基因池构建的——这些字符是我们在英语中常用来构建短语的字符。这个基因池保存为VALID_GENES❷。
- en: We set the population size (POP_SIZE) to 100 and the number of generations (MAX_GEN)
    to 1,000\. We also employ elitism. Fifteen percent of the population (the top
    15 fittest individuals) will be automatically included in the next generation.
    The remaining members of the next generation will be produced through selection,
    crossover, and mutation. The threshold for mutation has been set to 1.0/chromosomeLength
    ❸ so that on average 1 gene out of 42 will undergo mutation per offspring. (You
    may need to adjust this rule of thumb for other optimization problems. For example,
    you may have to explicitly set the mutation threshold from 1 to 3 percent when
    too few genes exist in the chromosome.)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将种群大小（POP_SIZE）设置为100，将代数（MAX_GEN）设置为1,000。我们还使用了精英主义。种群中15%（即最适应的前15个个体）将自动进入下一代。下一代的其余成员将通过选择、交叉和变异生成。变异阈值已设置为1.0/chromosomeLength
    ❸，因此每个后代中平均会有42个基因中有1个基因发生变异。（对于其他优化问题，可能需要调整这个经验规则。例如，当染色体中基因较少时，可能需要将变异阈值从1%设置为3%。）
- en: The last two lines create two mutable lists of type Solution, which store the
    individuals belonging to the current generation (population) and to the next generation
    (nextgen).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的两行代码创建了两个可变类型为Solution的列表，这些列表分别存储当前代（种群）和下一代（nextgen）个体。
- en: Initializing Population and Fitness Evaluation
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 初始化种群和适应度评估
- en: The initial population is created by making a call to the initPopulation() function,
    which in turn relies on the getFitness() helper function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 初始种群通过调用initPopulation()函数创建，该函数依赖于getFitness()辅助函数。
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The initPopulation() function creates the number of individuals specified by
    POP_SIZE (100, in this case) whose chromosomes are created by randomly picking
    individual genes (all 42 of them) from the supplied gene pool, VALID_GENES ❶.
    Once the chromosome is complete, its fitness is evaluated by calling the getFitness()
    function. A new Solution is created using the chromosome and fitness value and
    then added to the population ❷.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: initPopulation()函数创建了POP_SIZE指定数量的个体（在本例中为100个），这些个体的染色体是通过随机从提供的基因池VALID_GENES
    ❶中选取个体基因（共42个）来生成的。染色体完成后，通过调用getFitness()函数来评估其适应度。然后，使用染色体和适应度值创建一个新的Solution并将其添加到种群中
    ❷。
- en: Before exiting this function, we sort the population in descending order and
    print the best solution from the initial population. This presorting is needed
    to check for the termination condition and implement elitism for the first generation
    inside the runGA() function. For subsequent generations, sorting is done at the
    end of each iteration inside runGA().
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在退出该函数之前，我们按降序对种群进行排序，并打印出初始种群中的最佳解。此排序是为了检查终止条件并在runGA()函数内实现精英主义，以处理第一代。对于后续代，排序将在每次迭代结束时进行。
- en: Within the getFitness() function, we create a list named pairs of type Pair<Char,
    Char> and calculate the fitness value for the given chromosome based on pair-wise
    comparisons. For each matching gene, fitness is incremented by 1 ❸. If a chromosome
    matches the target string exactly, it will have a maximum fitness value of 42.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在getFitness()函数内，我们创建了一个名为pairs的列表，类型为Pair<Char, Char>，并根据基因对的比较来计算给定染色体的适应度值。对于每个匹配的基因，适应度加1
    ❸。如果一个染色体完全匹配目标字符串，它将拥有最大适应度值42。
- en: The Driver Function
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 驱动函数
- en: In the code block for the runGA() function, we implement the core components
    of the genetic algorithm. This includes iterating over multiple generations, checking
    for the termination condition, and creating the next generation by using elitism,
    selection, crossover, and mutation—the entire collection of genetic operators.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在runGA()函数的代码块中，我们实现了遗传算法的核心组件。这包括遍历多个代，检查终止条件，并通过精英主义、选择、交叉和变异——即一整套遗传操作符——来创建下一代。
- en: '[PRE2]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The outermost for loop ❶ runs the genetic processes for the specified number
    of generations. Inside this loop, we first check for the termination condition
    by comparing the best fitness value from the current population with the maximum
    possible fitness ❷. If the condition is met, the program terminates after printing
    a message that it has reached the target. If the condition is not met, we implement
    elitism by calling the selectElites() function ❸, discussed in detail in the next
    section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最外层的 for 循环❶执行指定代数的遗传过程。在这个循环内，我们首先通过将当前人口的最佳适应度值与最大可能适应度值❷进行比较来检查终止条件。如果满足条件，程序会在打印达到目标的消息后终止。如果条件不满足，我们通过调用selectElites()函数❸来实现精英策略，下一节将详细讨论该函数。
- en: We then move on to the first inner for loop ❹, which creates the remaining members
    of the next generation by selecting new parents by tournament, creating a child
    by calling the crossover() function (which also applies mutation to the newly
    created chromosome, as discussed in the next section), and then adding the child
    to the mutable nextgen list.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们进入第一个内部 for 循环❹，该循环通过竞赛选择新父代、调用crossover()函数创建子代（该函数还会对新创建的染色体应用变异，具体内容将在下一节讨论），然后将子代添加到可变的nextgen列表中，创建下一代的其余成员。
- en: We use a second inner for loop ❺ to individually copy the next-generation solutions
    (nextgen) to population before nextgen is cleared for the next iteration. Notice
    that given the simple structure of the Solution data class, the copy() method
    applied to the elements of nextgen creates a deep copy and prevents cross-referencing
    between population and nextgen. In addition, transferring nextgen values to population
    at the end of each iteration eliminates the need to store multiple generations
    of solutions, which saves a lot of memory.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用第二个内部 for 循环❺将下一代的解决方案（nextgen）逐一复制到population中，然后清空nextgen以便进行下一次迭代。需要注意的是，由于Solution数据类结构简单，应用copy()方法复制nextgen中的元素时，会创建深拷贝，防止population和nextgen之间发生交叉引用。此外，将nextgen的值转移到population中后，无需存储多个代的解决方案，从而节省了大量内存。
- en: 'In the final segment of the outermost for loop, we sort the newly updated population
    in descending order ❻ and print three key values per generation: the iteration
    number, the chromosome with the best fitness, and the corresponding fitness ❼.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在最外层的 for 循环的最后一部分，我们将新更新的人口按降序排序❻，并打印每一代的三个关键值：迭代次数、适应度最佳的染色体以及对应的适应度❼。
- en: The Operator Functions
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 操作函数
- en: The runGA() function relies on several operator functions that perform the key
    genetic operations.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: runGA()函数依赖于几个操作函数来执行关键的遗传操作。
- en: '[PRE3]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The selectElites() function is a one-liner. It promotes the top 15 individuals
    (eliteSize = 15) from the current generation to the next generation without subjecting
    them to further genetic processes ❶.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: selectElites()函数是一行代码。它将当前代中最优秀的15个个体（eliteSize = 15）直接提升到下一代，而不再进行遗传过程❶。
- en: The tournament() function randomly picks two individuals from the current population
    and returns the winner of the competition based on their fitness values ❷.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: tournament()函数从当前人口中随机选出两个个体，并根据它们的适应度值返回竞争的胜者❷。
- en: The crossover() function takes in two parents as arguments, splits their chromosomes
    at a random location, and combines the split parts from both parents to create
    a new chromosome for the offspring ❸. Next, this newly created chromosome (crossChromosome)
    is passed to the mutation() function ❹, which returns the final chromosome saved
    as newChromosome. A single offspring is then returned once the fitness value for
    the newly created chromosome is calculated by making a call to getFitness() ❺.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: crossover()函数接受两个父代作为参数，在随机位置切割它们的染色体，并将两个父代的切割部分组合起来，为后代创建一个新的染色体❸。接下来，将这个新创建的染色体（crossChromosome）传递给mutation()函数❹，该函数返回最终的染色体，并将其保存为newChromosome。然后，计算新创建的染色体的适应度值，调用getFitness()❺后返回一个后代。
- en: Finally, the mutation() function applies mutation to randomly selected genes.
    It first converts the chromosome from a string object to a character array because
    strings are immutable in Kotlin. The mutation operation, triggered by the MUTATION_THRESHOLD
    parameter ❻, is applied to each gene in the chromosome. Once the mutation operation
    is done, the character array is converted back to a string and returned as the
    new (mutated) chromosome ❼.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，mutation() 函数对随机选择的基因进行突变。它首先将染色体从字符串对象转换为字符数组，因为在 Kotlin 中，字符串是不可变的。突变操作由
    MUTATION_THRESHOLD 参数 ❻ 触发，应用于染色体中的每个基因。突变操作完成后，字符数组会被转换回字符串，并作为新的（突变后的）染色体 ❼
    返回。
- en: The main() Function
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: main() 函数
- en: The main() function simply prints a few key problem-specific parameters and
    makes two function calls to finish the job.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: main() 函数仅仅打印了一些与问题相关的关键参数，并进行两次函数调用来完成任务。
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first call to initPopulation() initializes the current population with random
    chromosomes. The second call to runGA() conducts the necessary genetic operations.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用 initPopulation() 会用随机的染色体初始化当前种群。第二次调用 runGA() 执行必要的遗传操作。
- en: The Result
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: Each time you run this program, it will take a different number of iterations
    to exactly match the target string. This is because we’re using a stochastic method
    that depends on many internal levels of random selection. This is a very helpful
    feature for solving large real-world problems that may not have a deterministic
    or known solution.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行这个程序时，需要的迭代次数会不同，以精确匹配目标字符串。这是因为我们使用的是一种随机方法，依赖于多个内部的随机选择层次。这是解决大型现实世界问题的一个非常有用的特性，因为这些问题可能没有确定的或已知的解决方案。
- en: 'Here is some sample output from the program:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是程序的一些示例输出：
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this instance, starting with chromosomes that had no resemblance to the target
    string, it took 379 generations for the algorithm to re-create the target string
    exactly. We haven’t made any attempt to fine-tune the global parameter values
    to increase the speed of convergence, yet the code converges to the optimal solution
    almost instantly (the processing time will depend on the configuration of your
    device). Pretty impressive!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实例中，起初染色体与目标字符串没有任何相似之处，算法用了 379 代才精确地重建出目标字符串。我们还没有对全局参数值进行任何调整来加速收敛过程，但代码几乎即时就收敛到最优解（处理时间将取决于你设备的配置）。相当令人印象深刻！
- en: 'Project 34: Solve the Knapsack Problem'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 34：解决背包问题
- en: 'You’re likely familiar with Noah’s ark, the vessel Noah and his followers built
    to save themselves from a great deluge. The challenge that Noah faced was massive:
    he had to build a vessel of unprecedented size and choose who or what to take
    on board. To a mathematician, this latter decision is a classic example of an
    optimization problem where one tries to maximize the value of the objects that
    can be accommodated within a limited space.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉诺亚方舟，诺亚和他的追随者为了躲避大洪水而建造的船只。诺亚所面临的挑战是巨大的：他必须建造一艘前所未有的庞大船只，并选择谁或什么可以上船。对数学家来说，后者的决定是一个经典的优化问题，试图最大化可以容纳在有限空间内的物品的价值。
- en: Let’s build a miniature version of this challenge and solve it using the genetic
    algorithm. We’ll name this project Jonah’s ark. Jonah lives in a flood plain that
    faces the risk of flash floods. Jonah knows he must be ready to leave the area
    at short notice. His quickest route to safety involves using a small-engine boat
    to get away from the rising river through a tributary beyond the reach of flood
    waters. Of course, the boat is small and can carry only so many items without
    sinking. Jonah must decide which of the valuable objects in his possession he
    should take with him without exceeding the capacity of the boat.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建这个挑战的一个简化版本，并使用遗传算法来解决它。我们将这个项目命名为乔纳的方舟。乔纳住在一个易受洪水侵袭的平原上，面临着山洪爆发的风险。乔纳知道，他必须时刻准备好在短时间内离开这个地方。他最快的逃生路线是通过小型引擎船沿着一条支流逃离上涨的河水，驶往洪水无法触及的地方。当然，这艘船很小，只能载有限的物品，否则就会沉没。乔纳必须决定将哪些珍贵物品带走，而不超过船的承载能力。
- en: Jonah was able to come up with a short list of the 12 objects most valuable
    to him—which is still too many to take on board. Now he needs to figure out which
    combination of those objects he should choose so that their total worth (sum of
    assigned values) to him will be maximized without exceeding the capacity of his
    boat.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 约拿能够列出对他最有价值的12个物品——但这仍然太多，无法全部带上船。现在，他需要弄清楚应该选择哪些物品的组合，以便这些物品对他来说的总价值（分配的价值总和）最大化，同时不超过船的承载能力。
- en: The Strategy
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 策略
- en: 'The Jonah’s ark problem is a variation of what is known in mathematics as the
    *knapsack problem*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 约拿方舟问题是数学中*背包问题*的一个变种：
- en: Let n be the number of objects one has to choose from. Let ***V*** = [v[1],
    v[2], . . . , vn] be the list of values (worth) of those objects and ***W*** =
    [w[1], w[2], . . . , wn] be the list of weights of those objects. Also, let ***W***max
    be the maximum weight that the knapsack can carry. The goal is to find a subset
    of m objects so that the sum of values for that subset is maximized while ensuring
    that the sum of corresponding weights remains ≤ ***W***m[ax].
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 设n为可供选择的物品数量。设***V*** = [v[1], v[2], . . . , vn]为这些物品的价值列表，***W*** = [w[1],
    w[2], . . . , wn]为这些物品的重量列表。同时，设***W***max为背包的最大承载重量。目标是找到一个包含m个物品的子集，使得该子集的总价值最大化，同时确保相应的物品总重量不超过***W***max。
- en: We’ll leverage the genetic algorithm to address this problem. It’s evident that
    we’ll have to make changes to the problem definition part of the code. First,
    given that Jonah now has a choice among 12 distinct objects, we’ll set the number
    of chromosomes to 12\. Each gene in the chromosome will assume a binary value,
    where 1 signifies the inclusion of an object in the solution and 0 denotes its
    exclusion. We’ll also calculate the fitness of a solution differently based on
    which objects are included and their respective values and weights. I’ll explain
    this further when we discuss the related code segment.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用遗传算法来解决这个问题。显然，我们需要对代码中的问题定义部分做出调整。首先，由于约拿现在有12个不同的物品可以选择，我们将设置染色体的数量为12。染色体中的每个基因将具有二进制值，其中1表示将该物品包含在解决方案中，0表示排除它。我们还将根据选择的物品及其各自的价值和重量，以不同的方式计算解决方案的适应度。关于这一点，我将在讨论相关代码段时进一步解释。
- en: One important consideration is the composition of the initial population. We
    need to ensure that the initial population has some diversity. If all genes are
    randomly assigned, we might get a population with zero fitness. This would make
    crossover useless, and we would be relying solely on mutation, which is a very
    slow process. Therefore, while initiating the population, we’ll force each member
    to have a nonzero fitness.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的考虑因素是初始种群的组成。我们需要确保初始种群具有一定的多样性。如果所有基因都是随机分配的，可能会得到一个适应度为零的种群。这将使交叉操作变得无效，我们将仅依赖突变，这个过程非常缓慢。因此，在初始化种群时，我们将强制每个成员具有非零适应度。
- en: Before we start coding, we need to address a few technical considerations. First,
    we’ll adopt a 0-1 approach to solve this problem, meaning we’ll either include
    an object or completely exclude it in the solution. We’re not allowed to take
    a fraction of an object (and a fraction of its value). Second, we assume that
    we have only one copy of each object, so we cannot repeat any object in our solution.
    Third, we assume that we have only one knapsack to fill.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写代码之前，我们需要解决一些技术上的问题。首先，我们将采用0-1方法来解决这个问题，意味着我们要么选择一个物品，要么完全排除它。我们不允许选择物品的部分（以及部分的价值）。其次，我们假设每个物品只有一份，因此我们不能在解决方案中重复任何物品。第三，我们假设只有一个背包可供填充。
- en: The Code
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: We developed a fully functional genetic algorithm program in [Project 33](chapter8.xhtml#pre-33).
    For the most part, we’ll reuse that code and make a few adjustments needed to
    describe and solve the knapsack problem (or the Jonah’s ark problem).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第33章](chapter8.xhtml#pre-33)开发了一个完整功能的遗传算法程序。大部分代码我们将重用，并进行一些必要的调整以描述和解决背包问题（或约拿方舟问题）。
- en: Problem Definition and Global Parameters
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题定义和全局参数
- en: This code segment is composed of an import statement, data class declarations,
    the creation of a list of items to choose from, global parameters, and the creation
    of mutable lists to track population states for both the current and the next
    generations, as well as the best solutions from each generation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码由导入语句、数据类声明、创建可供选择的项目列表、全局参数以及创建可变列表以跟踪当前和下一代的种群状态、每代的最佳解决方案等组成。
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code segment begins with a single import statement for the roundToInt()
    method that we’ll use shortly. We then define two simple data classes, Solution
    and Item, which are used to create individual members of the population and objects
    with their key attributes (value and weight). Notice that we’re creating the chromosome
    as an integer array and not as a string, as in [Project 33](chapter8.xhtml#pre-33).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段以单个导入语句开始，导入了我们将稍后使用的roundToInt()方法。接着，我们定义了两个简单的数据类，Solution和Item，用于创建种群中的个体成员以及带有其关键属性（值和重量）的对象。请注意，我们创建的是整数数组类型的染色体，而不是像[项目33](chapter8.xhtml#pre-33)中那样创建字符串类型的染色体。
- en: NOTE
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Depending on your IDE, you might encounter a “weak warning” while declaring
    the first data class of this project (*Solution*). This is because we’re using
    a property with an* Array *type (*chromosome*) in a data class (*Solution*). While
    this warning indicates potential issues for certain use cases, it does not apply
    to the problems discussed in this chapter and the next. If you find the warning
    bothersome, an alternative approach would be to use regular classes instead of
    data classes. In that case, you can manually add necessary custom methods that
    a data class generates automatically, such as* copy() *and* toString()*. I encourage
    you to experiment with this approach as a further learning opportunity.*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*根据你的IDE，你可能会在声明本项目的第一个数据类（*Solution*）时遇到“弱警告”。这是因为我们在数据类（*Solution*）中使用了一个属性，其类型为*Array*（*chromosome*）。虽然该警告表明某些用例可能存在潜在问题，但对于本章和下一章讨论的问题并不适用。如果你觉得这个警告烦人，可以尝试用常规类代替数据类。在这种情况下，你可以手动添加数据类自动生成的必要自定义方法，例如*copy()*和*toString()*。我鼓励你尝试这种方法，作为进一步学习的机会。*'
- en: Next, we create a List of type Item with the 12 objects ❶. The capacity limit
    for the boat (maxWeight) is set to 175 units ❷ (we’ll assume this is in addition
    to Jonah’s own weight).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个包含12个对象❶的Item类型的List。船的容量限制（maxWeight）设置为175单位❷（我们假设这是除了约拿自身重量之外的限制）。
- en: Given the relatively small number of objects to choose from, we’ve set the population
    size (POP_SIZE) to 25 and the number of generations (MAX_GEN) to a modest 30\.
    Elitism has been set to 0.1, or 10 percent. The MUTATION_THRESHOLD value is set
    a bit differently (its value is rounded off to three significant digits after
    the decimal point) ❸, but it still complies with the rule of thumb.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于可选择的对象相对较少，我们将种群大小（POP_SIZE）设置为25，代数（MAX_GEN）设置为适中的30。精英选择比例设置为0.1，即10%。变异阈值（MUTATION_THRESHOLD）的值设置得稍有不同（其值保留三位有效数字），❸，但它仍然遵循经验法则。
- en: Note that the mutation threshold can be rounded to a few decimal places without
    affecting the results. This can speed up the calculations for more complex problems
    that need larger populations and longer runs to converge.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，变异阈值可以四舍五入到几个小数位，而不会影响结果。这可以加速更复杂问题的计算，这些问题需要更大的种群和更长的运行时间才能收敛。
- en: The last three lines of code create three mutable lists to store members of
    the current and next generations and the set of best solutions picked from successive
    generations.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后三行创建了三个可变列表，用于存储当前和下一代成员，以及从连续代中挑选出的最佳解集合。
- en: Initializing Population and Fitness Evaluation
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 初始化种群和适应度评估
- en: This section differs in just a few ways to what we developed for [Project 33](chapter8.xhtml#pre-33).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本节与我们为[项目33](chapter8.xhtml#pre-33)开发的内容只有少数几个不同之处。
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Within the initPopulation() function, we first create each chromosome as an
    integer array ❶. This is because we’re allowing only binary gene values (0 or
    1) in individual chromosomes. Initially, all the genes will be set to 0 while
    the chromosome is initialized. We then randomly change these values to 1 and 0
    inside a while loop ❷. Further, we add only solutions that have nonzero or positive
    fitness values to the initial population ❸. This will help us get started with
    a better set of chromosomes and avoid a situation where all initial solutions
    have zero fitness values, which is difficult to improve on!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在initPopulation()函数中，我们首先将每个染色体创建为一个整数数组❶。这是因为我们仅允许在染色体中使用二进制基因值（0或1）。最初，所有基因都将设置为0，当染色体初始化时。然后，我们在一个while循环❷中随机改变这些值为1或0。此外，我们只将具有非零或正适应度值的解添加到初始种群中❸。这样有助于我们从更好的染色体集合开始，避免所有初始解的适应度值都为零的情况，因为这种情况是很难改进的！
- en: The remaining part of the function is the same as before—we’re sorting the initial
    population to get it ready for elitism inside the runGA() function and printing
    out the current best solution from the initial population.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的其余部分与之前相同——我们在对初始种群进行排序，以为runGA()函数中的精英选择做好准备，并打印出初始种群中的当前最佳解。
- en: The helper function getFitness() receives a chromosome as its parameter and
    evaluates its fitness. It calculates the fitness as the weighted sum of values
    (sumValue), where weights are the genes from the chromosome ❹. It also calculates
    the weighted sum of weights as sumWeight ❺. If the sum of weights ≤ Wmax, the
    function returns the chromosome’s fitness; otherwise, 0 is returned.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数getFitness()接受一个染色体作为参数，并评估其适应度。它将适应度计算为值的加权和（sumValue），其中权重为染色体中的基因❹。它还计算了加权和的重量作为sumWeight❺。如果重量的总和≤
    Wmax，函数返回染色体的适应度值；否则，返回0。
- en: As mentioned earlier, we must ensure that both sumWeight ≤ Wmax and sumValue
    > 0\. We enforce the former condition in this function. The latter is enforced
    inside the while loop of the initPopulation() function. A chromosome is used only
    if its fitness, as returned by the getFitness() function, is greater than zero
    ❸.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们必须确保sumWeight ≤ Wmax且sumValue > 0。我们在此函数中强制执行前一个条件。后一个条件则是在initPopulation()函数的while循环内强制执行的。只有当染色体的适应度值（由getFitness()函数返回）大于零时，染色体才会被使用❸。
- en: The Driver Function
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 驱动函数
- en: We likewise need to make only minor changes to this part of the code, which
    was developed for [Project 33](chapter8.xhtml#pre-33). First, we’ll delete the
    termination condition at the beginning. For knapsack problems, the optimal solution
    is generally unknown beforehand. We have to run the code several times to get
    a sense of what the best solution might be. Second, we’ll now save the best solutions
    from all generations in a list and pick the best overall solution from that list
    as the potential optimal solution.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们同样需要对这部分代码做一些小的修改，代码最初是为[项目33](chapter8.xhtml#pre-33)开发的。首先，我们将在开头删除终止条件。对于背包问题，最佳解通常事先未知。我们需要运行代码几次，以了解可能的最佳解。其次，我们现在会将所有代的最佳解保存在一个列表中，并从该列表中挑选出整体最优的解作为潜在的最佳解。
- en: 'Here is the revised code for the runGA() function:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是修订后的runGA()函数的代码：
- en: '[PRE8]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Apart from deleting the termination condition based on the fitness value, both
    of the revisions to the code are at the end of the code segment. First, the fittest
    solution from each generation is now added to the mutable bestSolutions list ❶.
    Second, we’ve added a new print function called printSolution() ❷ to tidy up the
    printing without adding clutter to runGA(). This function simply formats and prints
    the generation number along with the chromosome and fitness of the fittest solution
    for each generation.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 除了删除基于适应度值的终止条件外，代码的两个修改都位于代码段的末尾。首先，每代中最优的解现在被添加到可变的bestSolutions列表中❶。其次，我们添加了一个新的打印函数，名为printSolution()❷，以整理打印输出而不增加runGA()的混乱。该函数简单地格式化并打印出每代的代数、染色体和最优解的适应度值。
- en: '[PRE9]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function prints a line composed of three substrings. The first substring
    represents the generation or iteration number. We assign 10 character spaces for
    this, of which 4 are allocated for displaying the number; the remaining spaces
    will be added after the number as padding (white spaces). The second substring
    simply contains the sequence of 12 genes converted into a string. The third substring
    contains the fitness value. We assign six spaces for the number, of which up to
    three will be used to display the fitness value; the remaining spaces will be
    added as padding in front of the characters displaying the fitness value.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数打印一行由三个子字符串组成的内容。第一个子字符串表示代数或迭代次数。我们为此分配了10个字符空格，其中4个用于显示数字，其余的空格将在数字后作为填充（空白字符）。第二个子字符串简单地包含了12个基因的序列，转换成字符串。第三个子字符串包含适应度值。我们为数字分配了六个空格，其中最多三个将用于显示适应度值，其余空格将作为填充，位于显示适应度值的字符前面。
- en: The Operator Functions
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 操作符函数
- en: We’ll skip discussing the selectElites() and tournament() functions as no changes
    are required to use them in this example (you can copy them from [Project 33](chapter8.xhtml#pre-33)).
    However, we have a different chromosome structure for the knapsack problem and
    additional constraints to satisfy. This means we’ll have to make changes to the
    crossover() and mutation() functions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跳过讨论selectElites()和tournament()函数，因为在此示例中使用它们不需要做任何更改（你可以从[项目33](chapter8.xhtml#pre-33)中复制它们）。然而，我们有一个不同的染色体结构来解决背包问题，并且需要满足额外的约束条件。这意味着我们需要对crossover()和mutation()函数进行修改。
- en: '[PRE10]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As before, the crossover() function starts with randomly locating a point to
    split the chromosomes ❶. We use the copyRangeOf() method to copy different ranges
    of genes from parent 1 and parent 2 because the chromosomes are of type IntArray
    instead of String. The new chromosome is created by combining the first part of
    parent 1 with the second part of parent 2 (creating one child per crossover) ❷.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如同之前，crossover()函数首先随机定位一个点来分割染色体❶。我们使用copyRangeOf()方法从父代1和父代2复制不同范围的基因，因为染色体的类型是IntArray而不是String。新染色体是通过将父代1的前半部分与父代2的后半部分组合而成的（每次交叉生成一个子代）❷。
- en: Next, we call the mutation() function to mutate this newly created chromosome
    in place ❸. Since arrays are passed by reference (memory location) rather than
    by value, all the genetic alterations will be applied directly to the selected
    elements of newChromosome, and we don’t need to return a separate mutated chromosome
    to the calling function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用mutation()函数对新创建的染色体进行变异❸。由于数组是按引用（内存位置）而非按值传递的，因此所有遗传变异将直接应用到newChromosome的选定元素上，我们无需将变异后的染色体返回给调用函数。
- en: Once this step is complete, a new child (Solution) is created and returned by
    using the newly created chromosome and its fitness ❹.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦此步骤完成，使用新创建的染色体和其适应度❹，将创建并返回一个新的子代（Solution）。
- en: Finally, the mutation() function scans every gene in the chromosome and applies
    mutation to a gene by comparing a random number between 0 and 1 with the MUTATION_THRESHOLD.
    When the condition is met, it flips the value of the gene from 0 to 1 or vice
    versa ❺.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，mutation()函数扫描染色体中的每个基因，并通过将一个介于0和1之间的随机数与MUTATION_THRESHOLD进行比较来对基因进行变异。当条件满足时，它会将基因的值从0翻转为1，或反之❺。
- en: '##### The main() Function'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '##### main()函数'
- en: 'The main() function for this project is similar to that of [Project 33](chapter8.xhtml#pre-33),
    with one additional call to printBestSolution() to print the best overall solution.
    Here is the code snippet including the print function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的main()函数与[项目33](chapter8.xhtml#pre-33)中的main()函数相似，只是多了一次调用printBestSolution()来打印最佳总体解。以下是包含打印功能的代码片段：
- en: '[PRE11]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The main() function is very short. It starts with printing key global parameters,
    then calls initPopulation() to create the initial population of solutions and
    the driver function runGA() to run the genetic algorithm that we’ve customized
    for the knapsack problem. Finally, it prints the best overall solution by calling
    the printBestSolution() function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: main()函数非常简短。它首先打印关键的全局参数，然后调用initPopulation()创建初始解集，并调用驱动函数runGA()来运行我们为背包问题定制的遗传算法。最后，调用printBestSolution()函数打印最佳总体解。
- en: Next, the bestSolutions list is sorted in descending order so that the first
    item represents the best overall solution ❶. The properties of this item are then
    deconstructed as chromosome and fitness ❷. Finally, the sum of weights of the
    objects in this optimal (or near-optimal) solution is calculated as a weighted
    sum, the weights being the individual gene values (0, 1) ❸. The last line prints
    the sum of weights and fitness for the best overall solution.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，bestSolutions列表按降序排序，使得第一个项目代表最优解❶。然后，解构该项目的属性为染色体和适应度❷。最后，计算此最优（或近似最优）解中物品的总重量作为加权总和，权重为各个基因值（0，1）❸。最后一行打印最佳总体解的重量和适应度总和。
- en: The Result
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: 'The following sample output from a run of the code provides an indication of
    what to expect when you run the code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行代码时的示例输出，提供了运行代码时可以期待的结果：
- en: '[PRE12]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The optimal solution for Jonah is to choose objects 1, 2, 3, 4, and 12, which
    will give Jonah a combined value of 311 units. The total weight of the optimal
    choice is 173 units, just shy of the maximum allowable weight of 175 units.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Jonah的最优解是选择物品1、2、3、4和12，这将使Jonah的总价值为311个单位。最优选择的总重量为173个单位，接近最大允许重量175个单位。
- en: How do we know that no better solutions exist? In this case, you can verify
    the solution by using a brute-force approach—generating all possible combinations
    and checking corresponding sums of values and weights. I encourage you to search
    online for relevant tools or code examples you can use to confirm that 311 is
    indeed the best value Jonah can get under the circumstances.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道没有更好的解存在？在这种情况下，你可以通过使用暴力方法来验证解——生成所有可能的组合并检查相应的值和权重之和。我鼓励你在线搜索相关工具或代码示例，以确认
    311 确实是 Jonah 在这种情况下能获得的最佳值。
- en: Again, remember that the genetic algorithm is a stochastic algorithm, meaning
    no two runs will produce identical results. Moreover, nothing guarantees that
    for a given set of parameter values, the algorithm will consistently converge
    to the optimal solution every time you run the program. You may have to run the
    program multiple times or adjust the program parameters to eventually locate the
    optimal solution.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，遗传算法是一种随机算法，这意味着不同的运行不会产生相同的结果。此外，没有任何保障可以确保对于一组给定的参数值，算法每次运行时都会一致地收敛到最优解。你可能需要多次运行程序或调整程序参数，才能最终找到最优解。
- en: On the other hand, genetic algorithms can help solve real-world combinatorial
    problems with hundreds of decision variables, where checking all possible combinations
    for the global optimal solution is impractical or impossible. They take far less
    time and require significantly less computational effort to generate near-optimal
    solutions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，遗传算法可以帮助解决现实世界中的组合问题，这些问题涉及数百个决策变量，在这种情况下，检查所有可能的组合以找到全局最优解既不实际也不可能。它们所需的时间远少于传统方法，并且生成近似最优解所需的计算努力显著较少。
- en: 'Project 35: Optimize a Multivariate Function with the Genetic Algorithm'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 35：使用遗传算法优化多元函数
- en: In this final project, we’ll learn how to apply the genetic algorithm to multivariate
    function optimization. The only requirement for the function is that it be defined
    in terms of the independent variables within the decision space. In contrast to
    gradient-based algorithms, this function does not have to be smooth or differentiable.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最终项目中，我们将学习如何将遗传算法应用于多元函数优化。对于函数的唯一要求是，它必须在决策空间内以独立变量的形式定义。与基于梯度的算法不同，这个函数不需要是平滑的或可微的。
- en: 'We’ll use a sufficiently challenging two-dimensional function known as the
    Eggholder function, defined by two independent variables: *x*[1] and *x*[2].'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个足够具有挑战性的二维函数，即 Eggholder 函数，它由两个独立变量定义：*x*[1] 和 *x*[2]。
- en: $Equation$ (8.2) ![](../images/eq8-2.jpg)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: $方程式$ (8.2) ![](../images/eq8-2.jpg)
- en: 'We’ll find the minimum value of this function in the decision space defined
    as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在如下定义的决策空间中找到该函数的最小值：
- en: $Equation$ ![](../images/pg333.jpg)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: $方程式$ ![](../images/pg333.jpg)
- en: As shown earlier in [Figure 8-3](chapter8.xhtml#fig8-3), the Eggholder function
    has a very complex shape with numerous peaks and troughs. Because of this, deterministic
    gradient-based algorithms will have a hard time finding the global minimum. Deterministic
    search attempts will usually get stuck at local optima unless we use a hybrid
    approach that incorporates some random search features. In contrast, given enough
    diversity (population size) and time (number of generations), a genetic algorithm
    can locate the global minimum fairly quickly for this problem.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，在[图 8-3](chapter8.xhtml#fig8-3)中，Eggholder 函数具有非常复杂的形状，拥有众多的峰值和谷值。正因为如此，基于梯度的确定性算法很难找到全局最小值。确定性搜索方法通常会陷入局部最优解，除非我们采用一种结合随机搜索特征的混合方法。相比之下，给定足够的多样性（种群大小）和时间（代数），遗传算法能够相对快速地为该问题找到全局最小值。
- en: The Strategy
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 策略
- en: To implement function optimization in a genetic algorithm, the decision variables
    are treated as individual genes, meaning the two-variable Eggholder function will
    have two genes. This time, however, these genes will be represented as real numbers,
    including fractions, instead of characters (as in [Project 33](chapter8.xhtml#pre-33))
    or binary values (as in [Project 34](chapter8.xhtml#pre-34)).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在遗传算法中实现函数优化，决策变量被视为个体基因，这意味着二维 Eggholder 函数将有两个基因。然而，这些基因将作为实数表示，包括分数，而不是字符（如在[项目
    33](chapter8.xhtml#pre-33)中）或二进制值（如在[项目 34](chapter8.xhtml#pre-34)中）。
- en: We also need to address the fact that this is a minimization problem, not a
    maximization problem as in the previous two projects. In those cases, the goal
    was to find a solution with the greatest fitness, whereas now we want to find
    the solution with the smallest fitness. Fortunately, we can easily handle this
    case by multiplying the objective function by –1\. This adjustment allows us to
    continue using the existing code developed for maximization problems. Notably,
    if we were to switch back to a maximization problem, we could use the same code
    without needing to multiply the objective function by –1.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要解决一个问题：这次是最小化问题，而不是像之前两个项目中的最大化问题。在那些情况下，目标是找到一个具有最大适应度的解决方案，而现在我们要找到一个具有最小适应度的解决方案。幸运的是，我们可以通过将目标函数乘以–1来轻松处理这个问题。这个调整使我们可以继续使用为最大化问题开发的现有代码。值得注意的是，如果我们要切换回最大化问题，我们可以使用相同的代码，而不需要再次将目标函数乘以–1。
- en: Finally, we need a new way to implement mutation for function optimization.
    In previous projects, we introduced mutation by randomly replacing a character
    or a binary value, but that approach does not make sense for a real number. Digits
    in a real number cannot be arbitrarily replaced, as their relative position within
    the number has additional significance. Therefore, for real-valued genes, mutation
    is introduced as a small noise that is randomly added to or subtracted from the
    genes (we still use a probability threshold). The magnitude of the noise is calculated
    as a small fraction of the range for a specific gene (decision variable). By doing
    so, we can properly scale the magnitude of the noise or mutation without having
    to worry about the underlying units used for the corresponding decision variable
    in the function.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一种新的方式来实现函数优化的变异。在之前的项目中，我们通过随机替换字符或二进制值引入变异，但这种方法对于实数来说没有意义。实数的数字不能随意替换，因为它们在数字中的相对位置具有额外的意义。因此，对于实值基因，变异是通过向基因中随机添加或减去一个小的噪声来实现的（我们仍然使用概率阈值）。噪声的大小被计算为特定基因（决策变量）范围的一小部分。通过这种方式，我们可以适当地调整噪声或变异的大小，而无需担心函数中相应决策变量所使用的底层单位。
- en: The Code
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: The code for function optimization has the same general structure as Projects
    33 and 34\. It is worth reiterating that for minimization of the objective function,
    we’ll have to multiply it by –1, whereas for maximization no alteration to the
    objective function is needed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 函数优化的代码与项目33和34具有相同的一般结构。值得再次强调的是，若要最小化目标函数，我们需要将其乘以–1，而对于最大化目标函数，则无需对其进行任何修改。
- en: '##### Problem Definition and Global Parameters'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 问题定义与全局参数'
- en: 'This code segment includes the import block, a data class, global parameters,
    and several collections of mutable lists:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包括导入块、数据类、全局参数以及几个可变列表的集合：
- en: '[PRE13]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code segment begins by importing the necessary math functions to calculate
    the function value or fitness. Remember to import only the methods you need, instead
    of importing all of them using an import kotlin.math.* statement. We then declare
    the chromosome to be of type DoubleArray ❶ to deal with real-coded genes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先导入必要的数学函数，以计算函数值或适应度。记得只导入你需要的方法，而不是使用`import kotlin.math.*`语句导入所有方法。然后，我们声明染色体为DoubleArray类型❶，以处理实数编码的基因。
- en: We also define getFitness as a variable and assign it a reference to the Eggholder
    function ❷. This approach allows us to define other functions later. And to use
    those, we simply need to reassign getFitness to the desired function.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将getFitness定义为一个变量，并将其引用赋值给Eggholder函数❷。这种方法使得我们以后可以定义其他函数。要使用这些函数，我们只需将getFitness重新赋值为所需的函数。
- en: Because the Eggholder function is a function of two independent variables (*x*[1]
    and *x*[2]), we will need two real-coded genes per chromosome ❸.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Eggholder函数是一个由两个独立变量（*x*[1] 和 *x*[2]）决定的函数，我们每个染色体需要两个实数编码的基因❸。
- en: The next two lines set the bounds for the decision variables and calculate the
    range for each. For real-coded genes, the magnitude of mutation is typically set
    to a small value relative to the range of the decision variables. This approach
    has the benefit of being scale independent.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行设置决策变量的边界，并计算每个变量的范围。对于实数编码的基因，变异的大小通常设置为相对于决策变量范围的一个小值。这种方法的优点是与尺度无关。
- en: The remaining part of the code segment is similar to that of previous projects.
    This time, the population is composed of 100 individuals (POP_SIZE), and it will
    evolve for 200 generations (MAX_GEN). The MUTATION_THRESHOLD is now set to 0.5
    ❹, in line with the practice of setting the mutation probability equal to the
    inverse of the number of genes.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 代码段的其余部分与之前的项目相似。这次，种群由100个个体（POP_SIZE）组成，并将进化200代（MAX_GEN）。MUTATION_THRESHOLD现在设为0.5❹，符合将突变概率设置为基因数的倒数的惯例。
- en: Of course, we could’ve tried many other combinations of parameter values. The
    values used in this code segment were chosen based on a number of trials to ensure
    that the global minima for the Eggholder function can be found quickly.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以尝试许多其他参数值的组合。此代码段中使用的值是通过多次试验选择的，以确保可以快速找到Eggholder函数的全局最小值。
- en: Initializing Population and Fitness Evaluation
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 初始化种群和适应度评估
- en: 'The general organization of this code snippet is very similar to that of the
    two previous projects, with a few problem-specific adjustments:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的总体结构与前两个项目非常相似，只是做了一些与问题相关的调整：
- en: '[PRE14]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We generate the chromosome as a DoubleArray with two elements (*x*[0] will be
    gene 1, and *x*[1] will be gene 2) ❶. We then initialize the genes randomly, ensuring
    they stay within their respective bounds (defined by the decision space) ❷. The
    rest of the code segment assigns the solutions to the mutable list population,
    sorts the population in descending order, and prints the best solution from the
    initial population ❸.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将染色体生成一个DoubleArray，包含两个元素（*x*[0]为基因1，*x*[1]为基因2）❶。然后，我们随机初始化这些基因，确保它们保持在各自的边界内（由决策空间定义）❷。其余的代码段将解分配给可变列表population，按降序对population进行排序，并打印初始种群中的最佳解❸。
- en: As mentioned earlier, this code doesn’t include a getFitness function; instead,
    we had pointed getFitness to the eggHolder() function, which returns the value
    of the objective function (fitness). For convenience, we’ve broken down the objective
    function given by Equation 8.2 into three parts, which are later combined to calculate
    the fitness value ❹. Notice that we’re multiplying the fitness by –1 before returning
    the value to getFitness. Doing so enables us to use the code developed for maximization
    problems to solve a minimization problem.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这段代码没有包括getFitness函数；相反，我们将getFitness指向了eggHolder()函数，它返回目标函数（适应度）的值。为了方便，我们将方程8.2给出的目标函数分解为三部分，稍后将这些部分合并计算适应度值❹。请注意，我们在返回值给getFitness之前，将适应度乘以-1。这样做可以使我们使用为最大化问题开发的代码来解决最小化问题。
- en: We’ll skip reviewing the runGA() function as it is identical to the one used
    for [Project 34](chapter8.xhtml#pre-34). The same goes for the selectElites()
    and tournament() functions. Therefore, we’ll move straight to the crossover()
    and mutation() functions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跳过runGA()函数的审查，因为它与[项目34](chapter8.xhtml#pre-34)中使用的相同。selectElites()和tournament()函数也是如此。因此，我们将直接进入crossover()和mutation()函数。
- en: Operator Functions for Crossover and Mutation
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Crossover 和 Mutation 的操作函数
- en: We’ll now move on to the two key operator functions performing crossover and
    mutation to examine the differences introduced for the real-coded genes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论执行交叉和突变的两个关键操作函数，看看针对实值基因引入的差异。
- en: '[PRE15]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The purpose of the crossover function for real-valued genes remains the same:
    to produce a new chromosome for the child by using genetic materials from the
    parents. Several methods are available for creating the new chromosome or genes.
    In this example, we’re using a random-weighted scheme based on a randomly selected
    value *s* between 0 and 1 ❶. (If we used a fixed weight, s=0.5, that would be
    equivalent to using the arithmetic average of the gene values from two parents
    to create a new gene.)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 实数基因的交叉函数目的仍然相同：通过使用父代的遗传物质为子代生成新的染色体。可以使用几种方法来创建新的染色体或基因。在这个示例中，我们使用基于随机选择的值*s*（范围在0和1之间）❶的随机加权方案。
    （如果使用固定的权重，s=0.5，那就相当于用两个父代基因值的算术平均值来创建一个新的基因。）
- en: We use the weighted average scheme to generate two new genes (x1 and x2) and
    ensure that these values are within the bounds of the decision variables. We then
    compose the new chromosome xNew as a DoubleArray, with two genes as its elements
    ❷.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用加权平均方案来生成两个新基因（x1和x2），并确保这些值在决策变量的范围内。然后，我们将新的染色体xNew组合为一个DoubleArray，包含两个基因作为其元素❷。
- en: Next, we call the mutation() function to mutate this newly created chromosome
    in place ❸. Since arrays are passed by reference (memory location), mutations
    can be directly applied to the elements (genes) of the array, and we don’t need
    to return anything to the calling function. Once mutation is applied, a new child
    (Solution) is created and returned using the newly created chromosome and its
    fitness ❹.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用 mutation() 函数对在位置 ❸ 创建的染色体进行变异。由于数组是通过引用传递的（内存地址），因此变异可以直接作用于数组的元素（基因），我们不需要返回任何内容给调用函数。变异应用后，使用新创建的染色体及其适应度
    ❹ 创建并返回一个新子代（解）。
- en: The mutation() function, similar to [Project 34](chapter8.xhtml#pre-34), scans
    each gene and mutates it if a random number between 0 and 1 is less than MUTATION_THRESHOLD.
    It randomly picks the sign of the mutation (positive or negative) ❺ and calculates
    the value as the sign times the decision variable’s range times MUTATION_FACTOR
    ❻. It also ensures that the mutated genes are within the bounds of the corresponding
    decision variables.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: mutation() 函数，类似于 [项目 34](chapter8.xhtml#pre-34)，扫描每个基因，如果 0 到 1 之间的随机数小于 MUTATION_THRESHOLD，则对其进行变异。它随机选择变异的符号（正或负）
    ❺ 并计算该值，公式为符号乘以决策变量的范围再乘以 MUTATION_FACTOR ❻。它还确保变异后的基因值在相应决策变量的边界内。
- en: 'Before we proceed to the main() function, we need to adjust the printSolution()
    function from [Project 34](chapter8.xhtml#pre-34). It now takes a solution with
    a chromosome of type DoubleArray instead of an IntArray. Use the following updated
    function in your code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续 main() 函数之前，我们需要调整来自 [项目 34](chapter8.xhtml#pre-34) 的 printSolution()
    函数。现在它接受一个类型为 DoubleArray 的染色体解，而非 IntArray。请在代码中使用以下更新后的函数：
- en: '[PRE16]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can review this code and compare it with the program output as an exercise,
    since you are familiar with these helper functions.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以回顾这段代码，并将其与程序输出进行比较作为练习，因为你已经熟悉这些辅助函数。
- en: The main() Function
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: main() 函数
- en: The code snippet for the main() function, including the printBestSolution()
    function, is likewise similar to the main() functions in previous projects.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: main() 函数的代码片段，包括 printBestSolution() 函数，与之前项目中的 main() 函数类似。
- en: '[PRE17]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The main() function starts by printing key global parameters. It then calls
    initPopulation() to initialize the population and launches the driver function
    runGA() to carry out function minimization using a genetic algorithm.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: main() 函数首先打印关键的全局参数。然后它调用 initPopulation() 来初始化种群，并启动驱动函数 runGA()，通过遗传算法执行函数最小化。
- en: In the printBestSolution() function, we format and print the two real-valued
    genes on the same line by using a for loop. Finally, we print the negative fitness
    value to get the correct sign for the minimum fitness.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 printBestSolution() 函数中，我们使用 for 循环将两个实数基因格式化并打印在同一行。最后，我们打印负适应度值，以获取正确的最小适应度符号。
- en: The Result
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: 'We’re now ready to run the code and examine the results. If you use the same
    global parameter values that I have used for this project, you are likely to get
    the global optimal solution within five to seven attempts. Let’s look at a sample
    output:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行代码并查看结果。如果你使用与我为此项目所使用的相同全局参数值，你很可能在五到七次尝试内获得全局最优解。让我们来看一个示例输出：
- en: '[PRE18]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first section of the results shows the global parameters used for solving
    this problem—population size (100) and number of generations (200). Elitism is
    set to 0.1, or 10 percent. We used a mutation threshold of 0.5 because we have
    two genes, but we could have used a lower threshold if this threshold caused the
    best solutions to oscillate rather than converge. Due to the presence of many
    near-optimal solutions within the decision space of this problem, a higher-than-usual
    mutation threshold may have helped the algorithm to get out of local minima and
    explore other regions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的第一部分展示了用于解决该问题的全局参数——种群大小（100）和代数（200）。精英策略设置为 0.1，即 10%。我们使用了 0.5 的变异阈值，因为我们有两个基因，但如果该阈值导致最佳解发生波动而非收敛，我们本可以使用更低的阈值。由于该问题的决策空间内存在许多接近最优的解，较高的变异阈值可能有助于算法跳出局部最小值并探索其他区域。
- en: The initial best fitness value was –809.63, which is not that close to the global
    minimum of –959.64 located after 117 iterations (not shown in the partial output
    above). Once this value was reached, the best solution remained unchanged until
    the program ended after completing the maximum number of iterations.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的最佳适应度值为 -809.63，这与全局最小值 -959.64 的差距不大，全局最小值出现在117次迭代后（在上面的部分输出中没有显示）。一旦达到了这个值，最佳解保持不变，直到程序在完成最大迭代次数后结束。
- en: We can see from the last part of the results that the optimal solution is located
    at *x*[1] = 512.0 and *x*[2] = 404.23\. [Figure 8-9](chapter8.xhtml#fig8-9) shows
    this point as a white half-circle near the top-right corner of the contour plot
    of the Eggholder function.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果的最后部分可以看出，最优解位于 *x*[1] = 512.0 和 *x*[2] = 404.23。图[8-9](chapter8.xhtml#fig8-9)显示了这个点，作为在
    Eggholder 函数等高线图的右上角附近的白色半圆。
- en: '![](../images/Figure8-9.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-9.jpg)'
- en: 'Figure 8-9: The contour plot of the Eggholder function'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-9：Eggholder 函数的等高线图
- en: In this case, the global solution is literally on the right-hand boundary of
    the decision space in [Figure 8-10](chapter8.xhtml#fig8-10). The grayscale bar
    indicates that the darker regions are troughs and the lighter regions are peaks.
    Clearly, the fitness values are close to the global minima in many cases (based
    on the darkness of the shade). This is why it is so difficult to find the global
    minima for the Eggholder function.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，全局解实际上位于[图 8-10](chapter8.xhtml#fig8-10)中决策空间的右侧边界。灰度条显示，较暗的区域为谷底，较亮的区域为山峰。显然，在许多情况下，适应度值接近全局最小值（根据阴影的深浅）。这就是为什么在
    Eggholder 函数中如此难以找到全局最小值的原因。
- en: '[Figure 8-10](chapter8.xhtml#fig8-10) shows the convergence pattern for this
    problem. The fitness value improves in a stepwise manner with the number of generations
    (iterations) until it reaches the global minima.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图[8-10](chapter8.xhtml#fig8-10)展示了这个问题的收敛模式。适应度值随着代数（迭代次数）的增加而逐步改善，直到达到全局最小值。
- en: '![](../images/Figure8-10.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-10.jpg)'
- en: 'Figure 8-10: The convergence pattern for the Eggholder function using the genetic
    algorithm'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-10：使用遗传算法求解 Eggholder 函数的收敛模式
- en: We’ll revisit this problem using particle swarm optimization (another NIA) and
    draw the corresponding convergence pattern in the next chapter. You’ll see that
    while both methods are capable of identifying the global optima, particle swarm
    optimization will do that much quicker!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章使用粒子群优化（另一种 NIA）重新解决这个问题，并绘制相应的收敛模式。你将看到，虽然两种方法都能找到全局最优解，但粒子群优化会更快完成这一过程！
- en: Stopping Condition for Genetic Algorithms
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遗传算法的停止条件
- en: When solving real-world optimization problems, we often lack knowledge of the
    global optimal solution. Consequently, we cannot directly use it as a stopping
    condition. To address this challenge, we can employ several strategies. In this
    section, I’ll discuss commonly used approaches for defining stopping conditions
    in genetic algorithms.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决现实世界的优化问题时，我们通常无法获得全局最优解。因此，我们不能直接使用它作为停止条件。为了解决这个挑战，我们可以采用几种策略。在本节中，我将讨论在遗传算法中常用的停止条件定义方法。
- en: First, the stopping condition can be implemented as the maximum number of generations,
    as we’ve done for all three projects on the genetic algorithm. In general, you
    wouldn’t know how many iterations it might take to solve a previously unsolved
    problem. This will depend on the nature of the problem, the global parameter values,
    and the specific schemes used for various operator functions. You’ll have to gradually
    adjust the number of iterations (along with other parameters) to find a combination
    of values that works for the problem at hand. Interestingly, we can use the genetic
    algorithm to find optimal combinations of global parameters. In the field of deep
    learning, the genetic algorithm has been used to optimize global parameters and
    quickly train neural networks that produce high-quality results.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，停止条件可以设置为最大代数，就像我们在所有三个遗传算法项目中所做的那样。通常情况下，你无法知道解决一个之前未解决的问题可能需要多少次迭代。这将取决于问题的性质、全局参数值以及各种操作符函数所使用的特定方案。你需要逐步调整迭代次数（以及其他参数），以找到适合当前问题的参数组合。有趣的是，我们可以使用遗传算法来找到全局参数的最佳组合。在深度学习领域，遗传算法已经被用来优化全局参数，并快速训练出能够产生高质量结果的神经网络。
- en: Second, you could stop the algorithm from iterating if the best solution’s fitness
    does not show noticeable improvements for several generations (for example, very
    little or no improvement over the past 30 or 50 generations). This will require
    additional coding to track improvements dynamically, but this can be a strategy
    to let the algorithm stop automatically, even when the maximum number of iterations
    has not been reached.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，如果最佳解的适应度在几代内没有显著改善（例如，在过去的30或50代中几乎没有改善），你可以停止算法的迭代。这将需要额外的编码来动态跟踪改进，但这可以成为一种让算法自动停止的策略，即使最大迭代次数未达到。
- en: Third, for certain types of problems, you may be able to set a target for the
    fitness and have the program terminate once that target is reached (recall that
    we had a text-matching target for the first project). When the target is difficult
    to reach, you could also terminate the program when a predetermined percentage
    of that target is reached (instead of matching the target exactly).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，对于某些类型的问题，你可以为适应度设置一个目标，当达到该目标时程序终止（回想一下我们在第一个项目中有一个文本匹配目标）。当目标难以达成时，你还可以在达到该目标的预定百分比时终止程序（而不是精确匹配目标）。
- en: A lot more could be said about genetic algorithms, and researchers are frequently
    developing new adaptive or hybrid strategies and finding new applications. If
    you are interested in the state of the art, I suggest reviewing recent journal
    articles on the application of the genetic algorithm in your field of interest.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 关于遗传算法还有很多可以讨论的内容，研究人员经常开发新的自适应或混合策略，并发现新的应用。如果你对前沿技术感兴趣，我建议你查阅近期的期刊文章，了解遗传算法在你感兴趣领域的应用。
- en: 'In [Project 35](chapter8.xhtml#pre-35), we revised the code developed for function
    maximization to handle a minimization problem. However, changing the code back
    and forth can easily lead to errors. Therefore, in the next exercise you will
    develop new code to directly handle function minimization problems.  ### Summary'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '在[项目35](chapter8.xhtml#pre-35)中，我们修改了用于函数最大化的代码，以处理一个最小化问题。然而，代码的来回修改容易导致错误。因此，在下一个练习中，你将开发新的代码，直接处理函数最小化问题。
    ### 总结'
- en: 'In this chapter, you explored the fascinating world of nature-inspired algorithms,
    computational methods that mimic natural phenomena to solve complex problems.
    One key feature of these algorithms is that they are stochastic in nature: they
    exploit built-in randomness to tackle problems that are intractable or too complex
    for conventional methods. You learned about the benefits and challenges of using
    nature-inspired algorithms and focused on one of the most popular and powerful
    examples: the genetic algorithm.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你探讨了自然启发式算法的迷人世界，这些计算方法模仿自然现象来解决复杂问题。此类算法的一个关键特点是它们具有随机性：它们利用内建的随机性来处理那些常规方法难以解决或过于复杂的问题。你了解了使用自然启发式算法的优势和挑战，并重点讨论了最受欢迎且最强大的例子之一：遗传算法。
- en: 'The genetic algorithm is inspired by the process of natural evolution and uses
    a population of candidate solutions that undergo selection, crossover, and mutation
    to find the best solution for a given problem. You learned several ways to implement
    these operations and adjust the parameters of the algorithm to achieve the best
    performance. You also applied genetic algorithms to three different projects in
    order to:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法受到自然进化过程的启发，使用一组候选解，通过选择、交叉和变异来找到给定问题的最佳解。你学习了几种实现这些操作的方法，并调整算法的参数以获得最佳性能。你还将遗传算法应用于三个不同的项目，以：
- en: Generate a target string from a random population of characters
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个随机字符种群中生成目标字符串
- en: Maximize the value of items in a knapsack with a limited capacity
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在有限容量的背包中最大化物品的价值
- en: Find the global optimum solution for a real-valued and highly complex multivariate
    objective function
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为一个实值且高度复杂的多变量目标函数找到全局最优解
- en: In addition, you completed a set of exercises that cover additional techniques
    for the crossover operation and dedicated methods for solving minimization problems
    directly. By the end of this chapter, you gained a solid understanding of the
    theory and practice of genetic algorithms, and how they can be used to solve various
    types of optimization problems.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你完成了一组涵盖交叉操作的附加技术和解决最小化问题的专门方法的练习。到本章结束时，你对遗传算法的理论和实践有了坚实的理解，并掌握了如何使用它们来解决各种类型的优化问题。
- en: Resources
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源
- en: 'Brownlee, Jason. *Clever Algorithms: Nature-Inspired Programming Recipes*.
    Electronic version, June 16, 2012\. *[https://github.com/clever-algorithms/CleverAlgorithms](https://github.com/clever-algorithms/CleverAlgorithms)*.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Brownlee, Jason. *《聪明的算法：自然启发的编程技巧》*. 电子版, 2012年6月16日. *[https://github.com/clever-algorithms/CleverAlgorithms](https://github.com/clever-algorithms/CleverAlgorithms)*.
- en: 'Buontempo, Frances. *Genetic Algorithms and Machine Learning for Programmers*.
    Raleigh, NC: The Pragmatic Bookshelf, 2019.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 'Buontempo, Frances. *《遗传算法与程序员的机器学习》*. Raleigh, NC: The Pragmatic Bookshelf,
    2019.'
- en: 'Gen, Mitsuo, and Runwei Cheng. *Genetic Algorithms and Engineering Optimization*.
    New York: John Wiley & Sons, 2000.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 'Gen, Mitsuo, 和 Runwei Cheng. *《遗传算法与工程优化》*. New York: John Wiley & Sons, 2000.'
- en: 'Goldberg, David. *Genetic Algorithms in Search, Optimization and Machine Learning*.
    Reading, MA: Addison-Wesley Professional, 1989.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 'Goldberg, David. *《搜索、优化与机器学习中的遗传算法》*. Reading, MA: Addison-Wesley Professional,
    1989.'
- en: 'Haupt, Randy L., and Sue Ellen Haupt. *Practical Genetic Algorithms*. 2nd ed.
    Hoboken, NJ: John Wiley & Sons, 2004.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 'Haupt, Randy L., 和 Sue Ellen Haupt. *《实用遗传算法》*. 第二版. Hoboken, NJ: John Wiley
    & Sons, 2004.'
- en: 'Yang, Xin-She. *Nature-Inspired Optimization Algorithms*. 2nd ed. London: Academic
    Press, 2021.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 'Yang, Xin-She. *《自然启发的优化算法》*. 第二版. London: Academic Press, 2021.'
