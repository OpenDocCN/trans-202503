- en: '**8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8'
- en: SECURE BOOT AND SYSTEM INTEGRITY**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全启动与系统完整性**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: 'During the boot process of embedded systems, the initialization of basic hardware
    as well as the startup of an OS take place. Many of these steps involve firmware
    stored in flash memory since that provides device engineers with the possibility
    to update. However, this replaceability comes at a price: attackers are able to
    tamper with that data for their own advantage.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式系统的启动过程中，基本硬件的初始化以及操作系统的启动都在进行。这些步骤中的许多涉及存储在闪存中的固件，因为这样可以让设备工程师进行更新。然而，这种可替换性是有代价的：攻击者可以篡改这些数据以谋取自己的利益。
- en: In this chapter, I’ll explain the complexity of boot processes and various protection
    concepts. After introducing the classic secure boot chain concept, I’ll discuss
    practical considerations like the impact of secure boot process on development
    and production processes. As usual, theory and practice are not one and the same,
    so I’ll include a case study on implementing secure boot on the STM32MP157F platform.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将解释启动过程的复杂性和各种保护概念。在介绍经典的安全启动链概念后，我将讨论实际问题，如安全启动过程对开发和生产过程的影响。像往常一样，理论和实践并不完全相同，因此我将包括一个关于在STM32MP157F平台上实现安全启动的案例研究。
- en: Based on boot process integrity, you might wonder whether device integrity can
    be taken further, so this chapter also describes how to achieve integrity protections
    for filesystems and more. Finally, I’ll look at a low-cost firmware integrity
    solution for microcontroller-based systems that don’t rely on external flash memory
    and a complex boot process.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 基于启动过程的完整性，您可能会想知道设备的完整性是否可以进一步加强，因此本章还描述了如何为文件系统等实现完整性保护。最后，我将介绍一种低成本的固件完整性解决方案，适用于不依赖外部闪存和复杂启动过程的微控制器系统。
- en: '**System Boot Complexity**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**系统启动复杂性**'
- en: Many modern microchips for embedded systems contain a variety of submodules
    and are therefore called *system-on-chips (SoCs)*. In addition to the availability
    of multiple CPU cores, GPUs, real-time cores, and similar supporting coprocessors
    contribute to a system’s complexity. Also, SoCs that include an FPGA continue
    to gain popularity and add bitstream handling to the equation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代嵌入式系统的微芯片包含多种子模块，因此被称为*系统芯片（SoC）*。除了多个CPU核心的可用性外，GPU、实时核心以及类似的支持协处理器也增加了系统的复杂性。此外，包含FPGA的SoC也越来越受欢迎，并在方程中加入了比特流处理。
- en: Further, some SoCs provide a *trusted execution environment (TEE)*, which is
    used to separate the execution of critical software logically or physically—on
    a dedicated processing unit—from the ordinary firmware. In ARM-based SoCs, you’ll
    come across the terms *ARM TrustZone* and *ARM Trusted Firmware* that represent
    ARM’s TEE. The initialization of such an environment often takes place during
    the boot process. And, although those features aim for higher security, it can’t
    be denied that these technologies also lead to even more complexity—the natural
    enemy of intelligibility and security.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些SoC提供*受信执行环境（TEE）*，用于将关键软件的执行从普通固件中逻辑或物理地分离—在一个专用处理单元上。在基于ARM的SoC中，您会遇到*ARM
    TrustZone*和*ARM Trusted Firmware*这两个术语，它们代表ARM的TEE。这样的环境初始化通常发生在启动过程中。而且，尽管这些特性旨在提高安全性，但不可否认的是，这些技术也导致了更大的复杂性——可理解性和安全性的天然敌人。
- en: SoC devices also usually require further components on the PCB—for example,
    volatile double data rate (DDR) memory and nonvolatile storage, such as an embedded
    MultiMediaCard (eMMC) or similar flash memories. Initialization of necessary on-chip
    controllers and their parameters are further crucial parts of modern boot processes.
    [Figure 8-1](ch08.xhtml#ch08fig01) gives an overview of typical software and hardware
    components of an SoC involved in its boot process.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: SoC设备通常还需要在PCB上添加其他组件，例如，易失性的双倍数据速率（DDR）内存和非易失性存储器，如嵌入式多媒体卡（eMMC）或类似的闪存。必要的片上控制器及其参数的初始化是现代启动过程中的关键部分。[图8-1](ch08.xhtml#ch08fig01)概述了SoC启动过程中涉及的典型软件和硬件组件。
- en: '![Image](../images/08fig01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/08fig01.jpg)'
- en: '*Figure 8-1: The components of a typical SoC boot process*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-1：典型SoC启动过程的组件*'
- en: After power up, the boot procedure is initiated in hardware based on a boot
    read-only memory (ROM) ➊ that initializes internal structures and loads a minimalist
    first-stage bootloader (FSBL) like U-Boot SPL that’s copied to internal SRAM memory
    ➋. This piece of software initializes the external DDR memory and places a fully-fledged
    second-stage bootloader (SSBL) there ➌. The SSBL is able to provide several convenience
    features like boot medium selection, debugging, console access, and more. Afterward,
    the OS kernel, which in the embedded system context is often Linux, is started
    ➍. At this point, the boot process is “officially” over, and the device is in
    its runtime state.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 开机后，启动程序由硬件启动，通过一个启动只读存储器（ROM）➊ 初始化内部结构并加载一个极简的第一阶段引导加载程序（FSBL），例如U-Boot SPL，该程序被复制到内部SRAM内存中➋。这段软件初始化外部DDR内存，并将一个完整的第二阶段引导加载程序（SSBL）放置在其中➌。SSBL能够提供多种便捷功能，如引导介质选择、调试、控制台访问等。随后，操作系统内核（在嵌入式系统中通常是Linux）被启动
    ➍。此时，启动过程“正式”结束，设备进入其运行状态。
- en: '[Figure 8-2](ch08.xhtml#ch08fig02) shows the necessary steps for booting in
    temporal order.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-2](ch08.xhtml#ch08fig02)显示了按时间顺序启动所需的步骤。'
- en: '![Image](../images/08fig02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/08fig02.jpg)'
- en: '*Figure 8-2: The steps of a typical boot process*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-2：典型启动过程的步骤*'
- en: 'There is one basic property to highlight at this point: subsequent stages in
    a boot process always “trust” their predecessors. That means, for example, without
    external monitoring measures, an OS can’t tell a malicious boot-loader from the
    original one; it just relies on every configuration set and the parameters passed
    to it. Therefore, optimal boot-process protection has to start at its very beginning:
    in hardware.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个基本属性需要强调：启动过程中后续的各个阶段始终“信任”其前置阶段。这意味着，例如，在没有外部监控措施的情况下，操作系统无法辨别恶意引导加载程序和原始引导加载程序的区别；它只依赖于每个配置设置及传递给它的参数。因此，最佳的启动过程保护必须从一开始就着手：在硬件层面。
- en: '**Boot Protection Concepts**'
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**启动保护概念**'
- en: From the perspective of a customer or a device user, integrity is usually a
    desired protection goal for a device’s firmware and software. One relevant risk
    scenario is that cybercriminals try to persist malicious software in firmware
    to survive a reboot of the system—for example, to enable long-lasting backdoor
    access. Also, the manipulation of low-level configuration parameters and OS settings
    wouldn’t be possible with verification routines running at boot time. Even attacks
    that modify a device’s software during delivery, as reported to be performed by
    intelligence services, would render a product nonfunctional if solid integrity
    protection is implemented.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户或设备用户的角度来看，完整性通常是设备固件和软件的期望保护目标。一种相关的风险情景是，网络犯罪分子试图将恶意软件永久植入固件中，以便在系统重启后依然能够存活——例如，启用持久的后门访问。此外，如果在启动时运行验证程序，低级配置参数和操作系统设置的篡改也将变得不可能。即使是情报部门所报道的在交付过程中修改设备软件的攻击，如果实施了可靠的完整性保护，也会导致产品无法正常工作。
- en: The authors of IEC 62443 (Part 4-2) also seem to have these scenarios in mind.
    The embedded device requirement (EDR) 3.14 for security level (SL) 1 or higher
    aims for integrity of the boot process. It requests that a device must be able
    to perform integrity verification of the firmware, software, and configuration
    data used in the device’s boot and runtime processes prior to their execution.
    Starting at SL 2, the standard even requires authenticity of all replaceable parts
    of the boot process.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: IEC 62443（第4-2部分）的作者似乎也考虑到了这些情景。安全级别（SL）1或更高的嵌入式设备要求（EDR）3.14旨在确保启动过程的完整性。它要求设备必须能够在执行固件、软件和配置数据之前，对其启动和运行过程中的固件、软件和配置数据进行完整性验证。从SL
    2开始，标准甚至要求对所有可更换的引导过程部分进行真实性验证。
- en: 'Device manufacturers usually agree on the importance of integrity and authenticity
    of firmware and software because that also prevents attackers from installing
    custom software for reverse-engineering purposes. However, they have another risk
    to consider: loss of intellectual property. Even at early boot stages, such know-how
    might be cast in software, like optimized algorithms, proprietary protocols, and
    secrets. Therefore, in some cases, vendors would like to encrypt all firmware,
    software, and configuration data used during the boot process in order to protect
    their confidentiality.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 设备制造商通常一致认同固件和软件的完整性和真实性的重要性，因为这还可以防止攻击者安装自定义软件进行逆向工程。然而，他们还需要考虑另一个风险：知识产权的丧失。即使在早期启动阶段，这些技术诀窍也可能以软件的形式存在，比如优化算法、专有协议和机密信息。因此，在某些情况下，供应商希望加密启动过程中的所有固件、软件和配置数据，以保护其机密性。
- en: 'The third stakeholder in this game is the chip-manufacturing industry that
    provides several protection measures advertised by associated marketing terms.
    The following list provides an overview of typical keywords, but of course, it
    might not capture all future marketing creativity:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程中第三方利益相关者是芯片制造行业，它提供了许多由相关营销术语宣传的保护措施。以下列表提供了典型关键词的概述，但当然，它可能无法涵盖所有未来的营销创意：
- en: '**Secure boot**    This generic term is the “classic” and most popular one.
    It usually stands for the step-by-step verification of integrity and authenticity
    of software components used throughout the boot process. From a cryptographic
    point of view, the verification is based on digital signatures and asymmetric
    algorithms like RSA or ECDSA. Whenever a signature verification fails, the boot
    process stops. Its details are explained in “Classic Secure Boot Chain” on [page
    145](ch08.xhtml#ch00lev1_65).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全启动**    这个通用术语是“经典”且最流行的术语。它通常指的是在整个启动过程中逐步验证软件组件的完整性和真实性。从加密的角度来看，验证是基于数字签名和RSA或ECDSA等非对称算法。当签名验证失败时，启动过程会停止。其详细信息在[第145页](ch08.xhtml#ch00lev1_65)的《经典安全启动链》中解释。'
- en: '**Verified boot**    Similar to secure boot, this term stresses the cryptographic
    verification of the software parts executed in the boot chain. Intel uses this
    term, among others, as part of its Boot Guard technology, and Google utilizes
    it for Android and Chrome OSs.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**验证启动**    与安全启动类似，这个术语强调启动链中软件部分的加密验证。英特尔将这个术语作为其Boot Guard技术的一部分，谷歌则在Android和Chrome
    OS中使用该术语。'
- en: '**High-assurance boot**    NXP works with this label to highlight boot-process
    protection for i.MX devices. Among other protections, this approach also uses
    digital signatures to verify integrity and authenticity as described by secure
    boot.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**高保障启动**    NXP使用这个标签来突出i.MX设备的启动过程保护。除了其他保护措施外，这种方法还使用数字签名来验证完整性和真实性，正如安全启动所描述的那样。'
- en: '**Authenticated boot**    This term might seem to express the authentication
    of firmware and other software components. However, the Trusted Computing Group
    (TCG) uses this term to describe a boot process that allows for reporting “an
    accurate record of the way that the platform booted.” That means pieces of software
    are hashed during the boot process and written to a TPM. The startup procedure
    is not interrupted if manipulated software is to be executed, but the later state,
    be it original or altered, can be reported to an external party or used by the
    TPM to grant or deny access to stored secrets.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证启动**    这个术语可能看起来像是指固件和其他软件组件的认证。然而，受信计算组（TCG）使用这个术语来描述一种启动过程，允许报告“平台启动方式的准确记录。”这意味着在启动过程中，软件的各个部分被哈希并写入TPM。如果要执行经过篡改的软件，启动过程不会被中断，但之后的状态，无论是原始的还是已更改的，可以报告给外部方，或由TPM用于授予或拒绝访问存储的机密信息。'
- en: '**Measured boot**    Microsoft uses this term in the context of TPM-based boot
    protection in which software is *measured*, or hashed, during the boot process.
    It’s similar to TCG’s authenticated boot.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**测量启动**    微软在基于TPM的启动保护中使用这个术语，其中软件在启动过程中被*测量*或哈希。它类似于TCG的认证启动。'
- en: '**Trusted boot**    This is sometimes found in close relation to TPM-protected
    boot processes. However, Microsoft also uses it to describe the verification of
    the Windows kernel and OS components.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**受信启动**    这个术语有时与TPM保护的启动过程密切相关。然而，微软也用它来描述Windows内核和操作系统组件的验证。'
- en: '**Encrypted boot**    In contrast to all other listed forms of boot protection,
    this concept aims for confidentiality. In this case, firmware and related software
    are stored in an encrypted way, usually based on symmetric encryption algorithms.
    The decryption happens on the fly during boot and is usually supported by hardware.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**加密启动**与所有其他列出的启动保护形式不同，这一概念旨在实现保密性。在这种情况下，固件和相关软件是以加密的方式存储的，通常基于对称加密算法。解密在启动过程中实时发生，通常由硬件支持。'
- en: '**WARNING**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Be careful whenever it comes to marketing terms for boot process protection.
    They can be misleading and sometimes implement only part of what you expect!*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*当涉及到启动过程保护的营销术语时，要小心。它们可能会误导人，并且有时只实现了你所期望的部分内容！*'
- en: '**Classic Secure Boot Chain**'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**经典安全启动链**'
- en: For embedded devices, the most important variant of boot-process protection
    is the classic secure boot chain in which every component involved in the boot
    process verifies the next before handing over execution. Therefore, integrity
    and authenticity of all the software parts in a boot process can be achieved,
    which are often desirable requirements for several stakeholders.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于嵌入式设备，最重要的启动过程保护变种是经典的安全启动链，其中每个参与启动过程的组件在交给下一步执行之前都会验证下一个组件。因此，启动过程中的所有软件部分的完整性和真实性可以得到保障，这是许多利益相关者所期望的要求。
- en: '[Figure 8-3](ch08.xhtml#ch08fig03) shows a linear secure boot process from
    power up in hardware up to the point when the OS is running.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-3](ch08.xhtml#ch08fig03) 显示了从硬件上电到操作系统运行时的线性安全启动过程。'
- en: '![Image](../images/08fig03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/08fig03.jpg)'
- en: '*Figure 8-3: The steps in a classic secure boot process*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-3：经典安全启动过程的步骤*'
- en: In comparison to [Figure 8-2](ch08.xhtml#ch08fig02), notice the set of additional
    keys at every stage. These are public keys based on asymmetric crypto like RSA
    or ECDSA, which means they don’t carry any secret but are necessary to verify
    the signature of the subsequent boot stage. For example, the DDR bootloader has
    to carry the public key related to the signature of the OS kernel executed in
    the following boot step.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与[图 8-2](ch08.xhtml#ch08fig02)相比，请注意每个阶段都有一组额外的密钥。这些是基于非对称加密（如RSA或ECDSA）的公钥，这意味着它们不包含任何秘密，但对于验证随后的启动阶段的签名是必要的。例如，DDR启动加载程序必须携带与下一启动步骤中执行的操作系统内核签名相关的公钥。
- en: 'Although these keys aren’t required to stay confidential, they have a very
    important protection goal to fulfill: integrity. The reason for that is simple.
    If an attacker is able to replace a public key, a self-generated one can be stored
    instead. By changing a verification key, it becomes possible to correctly verify
    a forged, self-generated signature of a manipulated piece of software, which would
    break the secure boot chain.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些密钥不要求保持机密，但它们有一个非常重要的保护目标需要实现：完整性。原因很简单。如果攻击者能够替换公钥，那么可以存储一个自生成的公钥。通过更改验证密钥，就可以正确验证伪造的、自生成的、被篡改的软件签名，这会破坏安全启动链。
- en: '[Figure 8-4](ch08.xhtml#ch08fig04) shows how the involved public keys are stored
    in various places within an SoC. Most obviously, some of them are usually stored
    in flash memory, which is easy for attackers to manipulate.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-4](ch08.xhtml#ch08fig04) 显示了涉及的公钥是如何存储在SoC内部的各个位置的。最显而易见的是，其中一些通常存储在闪存中，这很容易被攻击者篡改。'
- en: '![Image](../images/08fig04.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/08fig04.jpg)'
- en: '*Figure 8-4: The SoC components involved in a secure boot process*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-4：参与安全启动过程的SoC组件*'
- en: The “trick” for handling this issue is that the integrity of the secure boot
    chain can be reduced to the integrity of the first verification key. If this initial
    key is stored in flash memory, the guarantees of the secure boot process hold
    only as long as an attacker is not able to alter this memory content.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的“窍门”是，安全启动链的完整性可以简化为第一个验证密钥的完整性。如果这个初始密钥存储在闪存中，那么只有当攻击者无法篡改此内存内容时，安全启动过程的保障才能成立。
- en: Microchips supporting secure boot usually provide OTP memory to physically burn
    the first public key or its hash into the device. This key is then used during
    boot ROM execution ➊ to verify the FSBL. The key for SSBL verification is included
    in the FSBL ➋, and the SSBL carries the public key to verify the OS kernel ➌,
    reaching the integrity goal for the whole boot chain. This verification chain
    might even be extended to kernel modules or application software by integrating
    further public keys into the OS kernel ➍.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 支持安全启动的微芯片通常提供 OTP 存储器，将第一个公钥或其哈希值物理地烧录到设备中。然后，在启动 ROM 执行过程中 ➊ 使用该密钥来验证 FSBL。用于
    SSBL 验证的密钥包含在 FSBL 中 ➋，而 SSBL 则携带公钥来验证操作系统内核 ➌，从而实现整个启动链的完整性目标。通过将进一步的公钥集成到操作系统内核中，验证链甚至可能扩展到内核模块或应用软件
    ➍。
- en: '**NOTE**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Keep in mind that only a secure boot chain starting in ROM within an SoC is
    a robust protection against boot software manipulation, because all protection
    guarantees can be traced back to the beginning of the boot chain.*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*请记住，只有从 SoC 中的 ROM 开始的安全启动链，才能提供对启动软件篡改的强大保护，因为所有保护保证都可以追溯到启动链的开始。*'
- en: '**Considerations for Implementing Secure Boot**'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实施安全启动的注意事项**'
- en: Unfortunately, the implementation of secure boot is not like activating a single
    option in a configuration menu, which is probably why secure boot on embedded
    systems is still uncommon in the market. However, the following details aren’t
    meant to scare developers away, but rather to serve as a list of tasks to keep
    in mind if you decide to take on secure boot.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，安全启动的实现并不像在配置菜单中激活单个选项那样简单，这也可能是为什么嵌入式系统上的安全启动在市场上仍然不常见的原因。然而，以下细节并非为了让开发者退缩，而是作为一份任务清单，帮助你在决定实施安全启动时牢记。
- en: '***Hardware and Software Requirements***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***硬件和软件要求***'
- en: First, it’s important to understand that a consistent secure boot chain requires
    every part of that chain to support signature verification based on asymmetric
    crypto. Of course, that includes the chosen microcontroller running all software.
    If secure boot was not a requirement during chip purchase, integrating it afterward
    might not be possible.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是要理解，完整的安全启动链要求链中的每个部分都支持基于非对称加密的签名验证。当然，这也包括运行所有软件的微控制器。如果在购买芯片时没有要求安全启动，事后集成可能就不再可行。
- en: Be sure to make secure boot a requirement during device architecture discussions.
    If the central microchip doesn’t support it, you’re forced to postpone the secure
    boot feature to the next device generation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在设备架构讨论中将安全启动作为一项要求。如果核心微芯片不支持安全启动，你将被迫将安全启动功能推迟到下一代设备。
- en: In addition, if software components don’t support signature verification, as
    might be the case for certain bootloaders, and you can’t integrate the functionality
    yourself, you’ll need to start the possibly tedious process of finding and implementing
    suitable replacements.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果软件组件不支持签名验证（例如某些引导程序可能不支持），且你无法自己集成该功能，你将需要开始可能繁琐的寻找和实现适当替代方案的过程。
- en: At the far end of the boot process, verifying the operating system kernel as
    a final step might be enough. However, on Linux, for example, you might also want
    to verify integrity and authenticity of kernel modules, or even extend the verification
    process to filesystems and applications as discussed in “Integrity Protection
    Beyond the Boot Process” on [page 154](ch08.xhtml#ch00lev1_69).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动过程的最后一步，验证操作系统内核作为最终步骤可能已经足够。然而，举例来说，在 Linux 中，你可能还希望验证内核模块的完整性和真实性，或者甚至将验证过程扩展到文件系统和应用程序，正如在[第
    154 页](ch08.xhtml#ch00lev1_69)的《启动过程之外的完整性保护》中所讨论的那样。
- en: But even if all your software already supports digital signature verification,
    several changes are necessary to incorporate secure boot, from hardware initialization
    to bootloader settings and maybe even OS kernel configuration.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 即使所有软件已经支持数字签名验证，实现安全启动仍然需要进行若干更改，从硬件初始化到引导程序设置，甚至可能涉及操作系统内核配置。
- en: '***Development Process***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***开发过程***'
- en: On the development side, the signature generation process (for example, within
    a CI pipeline), has to be established. Depending on the hardware and software
    used within the device, integrating vendor-specific tools, such as for signing
    and final image generation, might be necessary. If you’re lucky, the use of the
    `openssl` command line tool will be sufficient.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发方面，必须建立签名生成过程（例如，在 CI 管道中）。根据设备中使用的硬件和软件，可能需要集成特定厂商的工具，例如用于签名和最终镜像生成的工具。如果运气好，使用
    `openssl` 命令行工具就足够了。
- en: '**WARNING**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*The image-signing process is crucial for secure boot implementation. However,
    it involves private keys that have a strong need for confidentiality protection.
    If they become compromised, authenticity and integrity for device software can
    no longer be guaranteed.*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*镜像签名过程对于安全启动实现至关重要。然而，它涉及到私钥，这些私钥需要强有力的保密保护。如果这些密钥被泄露，设备软件的真实性和完整性将无法得到保证。*'
- en: A common obstacle to overcome during development of devices protected by secure
    boot is the handling of test images and devices. Various approaches exist, all
    valid on their own for specific situations. On the one hand, you might want to
    perform early testing without any secure boot restrictions on completely open
    devices. However, you wouldn’t be able to discover issues related to secure boot.
    On the other hand, you might want to use one or more test signing keys on test
    devices to authenticate images meant for testing only. However, this bears the
    risk of unintentionally locking test devices with incorrect configurations or
    keys, which might turn them into electronic bricks.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发由安全启动保护的设备时，一个常见的障碍是如何处理测试镜像和设备。存在多种方法，每种方法在特定情况下都有效。一方面，您可能希望在完全开放的设备上进行早期测试，而不受安全启动限制。然而，这样您将无法发现与安全启动相关的问题。另一方面，您可能希望在测试设备上使用一个或多个测试签名密钥，只认证用于测试的镜像。然而，这样做可能会有风险，可能会不小心将测试设备锁定，导致错误的配置或密钥，将设备变成“电子砖”。
- en: In any case, be careful when using different key pairs for testing and production
    use cases. If they get mixed up, test images (with additional tools or fewer restrictions)
    might verify correctly and run on devices in the field.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，在使用不同的密钥对进行测试和生产使用时要小心。如果它们混淆，测试镜像（可能带有额外工具或更少的限制）可能会正确验证，并能在现场设备上运行。
- en: '***Production and Lifetime***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***生产和生命周期***'
- en: Another area relevant for secure boot implementations is the production of devices.
    Since configuration data and keys have to be burned into OTP memory, the production
    process has to be adapted to enable secure boot. In-production testing of secure
    boot can also be a reasonable extension. Just imagine if all the previous steps
    were taken with great care and effort, but then the devices leave production with
    an incorrectly activated secure boot process that can be circumvented easily in
    the field. At best, that would be a motivational disaster for all security engineers,
    probably worse.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与安全启动实现相关的领域是设备的生产。由于配置数据和密钥必须烧录到 OTP 存储器中，因此生产过程必须进行调整，以支持安全启动。对安全启动的生产测试也是一个合理的扩展。想象一下，如果之前所有的步骤都经过仔细和努力地执行，但设备在生产过程中以不正确激活的安全启动流程离开，且这个流程在现场很容易被绕过。那么，最好的情况可能是对所有安全工程师来说，这是一次激励上的灾难，可能更糟。
- en: As if the task isn’t already complicated enough, secure boot implementations
    are also an attractive target for attackers and researchers. Therefore, the signing
    keys could get compromised in your development infrastructure, or vulnerabilities
    in hardware or firmware affecting boot process security could be found by external
    parties. Both cases lead to the necessity of replacing parts of the firmware with
    updated versions, maybe including a newly generated public verification key. A
    secure update functionality, as described in [Chapter 9](ch09.xhtml#ch09), as
    well as a solid key- and firmware-management process, are essential to handle
    these circumstances professionally.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任务本身已经足够复杂一样，安全启动实现也是攻击者和研究人员的一个诱人目标。因此，签名密钥可能会在您的开发基础设施中被泄露，或者硬件或固件中影响启动过程安全性的漏洞可能会被外部方发现。这两种情况都要求必须用更新的固件版本替换固件的一部分，可能还包括重新生成的公钥验证密钥。正如[第
    9 章](ch09.xhtml#ch09)中所描述的，安全更新功能以及一个稳健的密钥和固件管理过程，对于专业地处理这些情况至关重要。
- en: '**NOTE**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Implementation of secure boot requires developers, IT environment administrators,
    and production engineers to work together. Make sure that device security is considered
    a common goal for all people involved.*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*实现安全启动需要开发人员、IT 环境管理员和生产工程师的共同努力。确保设备安全被视为所有相关人员的共同目标。*'
- en: '**Open Source Licenses vs. Secure Boot**'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**开源许可证与安全启动**'
- en: 'The possibility to nail down a specific software version to hardware is valuable
    for device manufacturers, but this game has another player: the free and open
    source software community.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 钉住特定软件版本与硬件绑定对设备制造商来说非常有价值，但这场博弈还有另一方参与：自由和开源软件社区。
- en: Around the year 2000, a company named TiVo developed a digital video recorder
    (DVR) that prevented the execution of modified software by users. TiVo not only
    was a secure boot pioneer but also attracted the attention of Richard Stallman
    and the Free Software Foundation (FSF). The DVR device was running software licensed
    under the GNU General Public License version 2 (GPLv2), like Linux, which was
    meant to enable users to run their own customized software. Since then, the term
    *tivoization* has been used to describe mechanisms that restrict or prohibit the
    execution of custom open source software on a device.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2000 年左右，一家名为 TiVo 的公司开发了一种数字视频录像机（DVR），该设备阻止用户执行修改版软件。TiVo 不仅是安全启动的先驱，还吸引了理查德·斯托尔曼和自由软件基金会（FSF）的关注。该
    DVR 设备运行的软件下载自 GNU 通用公共许可证版本 2（GPLv2），就像 Linux 一样，旨在使用户能够运行自己定制的软件。从那时起，*TiVo
    化*这一术语被用来描述限制或禁止设备上执行自定义开源软件的机制。
- en: 'Following this conflict, the FSF developed GPLv3, a license that makes the
    implicit claims of GPLv2 explicit:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这场冲突之后，FSF 开发了 GPLv3，这是一种将 GPLv2 中隐含的声明变为明确的许可证：
- en: The Corresponding Source conveyed under this section must be accompanied by
    the Installation Information. [. . .] Installation Information [. . .] means any
    methods, [. . .] authorization keys, [. . .] required to install and execute modified
    versions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本节所传达的相应源代码必须附带安装信息。[... ] 安装信息 [... ] 指的是任何安装和执行修改版所需的方法，[... ] 授权密钥，[... ]
    等。
- en: While the Linux kernel and the popular embedded system bootloader U-Boot are
    available under GPLv2, other software like the GNU Grand Unified Bootloader (GRUB)
    is subject to GPLv3 and might lead to legal conflicts when implemented in a secure
    boot scenario.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Linux 内核和流行的嵌入式系统引导程序 U-Boot 是基于 GPLv2 许可证的，但像 GNU 大统一引导程序（GRUB）这样的其他软件是基于
    GPLv3 许可证的，这在安全启动场景中可能引发法律冲突。
- en: Clarifying the opposing goals of open source software licenses and secure boot
    protection for your individual case is absolutely necessary before going to market
    in order to save you quite some trouble.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在将产品推向市场之前，明确开源软件许可证与安全启动保护的对立目标是非常必要的，这能帮助你避免不少麻烦。
- en: 'It might seem not worth thinking about, but in some cases, developers seek
    a solution that satisfies both requirements: boot-process protection and the possibility
    to install modified software. One way to achieve such a compromise is to implement
    an unlock feature within the boot process. This feature allows the deactivation
    of secure boot verification in order to enable execution of custom (boot) software,
    but at the same time, the device has to ensure that all sensitive data, such as
    decryption keys, authenticators, and proprietary knowledge, are wiped from memory.
    This approach is already used by a variety of Android mobile phone vendors.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎不值得深思，但在某些情况下，开发者会寻求一种既能保护启动过程又能安装修改版软件的解决方案。实现这种妥协的一种方式是在启动过程中实现一个解锁功能。该功能允许停用安全启动验证，从而启用自定义（启动）软件的执行，但同时，设备必须确保所有敏感数据，如解密密钥、身份验证器和专有知识，都会从内存中清除。这种方法已经被多家
    Android 手机厂商采用。
- en: '**Case Study: Secure Boot Process on an STM32MP157F Device**'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**案例研究：STM32MP157F 设备的安全启动过程**'
- en: In this section, I take a look at the specific boot-process protection measures
    of the STM32MP157F device and its corresponding software packages. However, keep
    in mind that this is a broad overview and not a step-by-step tutorial. A comprehensive
    secure boot implementation requires substantial efforts and a lot of fine-tuning.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我将探讨 STM32MP157F 设备及其相应软件包的具体启动过程保护措施。然而，请记住，这只是一个广泛的概述，并非逐步教程。全面的安全启动实现需要大量的工作和细致的调试。
- en: '***The Boot Process***'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启动过程***'
- en: The microcontroller at hand exhibits a common boot-process complexity, as shown
    in [Figure 8-5](ch08.xhtml#ch08fig05).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 手头的微控制器展示了一个常见的启动过程复杂性，如[图 8-5](ch08.xhtml#ch08fig05)所示。
- en: '![Image](../images/08fig05.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/08fig05.jpg)'
- en: '*Figure 8-5: The boot chain of STM32MP157F devices*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-5：STM32MP157F设备的启动链*'
- en: After power-up, the ROM code performs basic initialization of the platform,
    loads the FSBL to internal RAM, and hands over execution to the FSBL. In this
    case, the FSBL is the Boot Loader stage 2 (BL2) part of the Trusted Firmware-A
    (TF-A) provided by ARM. In a simple setup, this BL2 initializes the DDR memory
    of the device, loads the SSBL into it, and executes the SSBL. However, if use
    of ARM TrustZone is desired, the FSBL loads not only the SSBL but also the runtime
    software for the secure world, and then jumps to the SSBL afterward.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在上电后，ROM代码执行平台的基本初始化，将FSBL加载到内部RAM，并将执行权交给FSBL。在这种情况下，FSBL是ARM提供的受信固件A（TF-A）中的引导加载程序阶段2（BL2）部分。在简单的设置中，这个BL2初始化设备的DDR内存，将SSBL加载到其中，并执行SSBL。然而，如果需要使用ARM
    TrustZone，FSBL不仅会加载SSBL，还会加载安全世界的运行时软件，然后跳转到SSBL。
- en: By default, the STM32MP157F platform uses the popular embedded system bootloader
    U-Boot as the SSBL. U-Boot comes with a variety of features and is commonly used
    to boot embedded Linux kernels. Next, Linux takes over control, launches its kernel
    modules, services, and user-space applications, and concludes the boot process.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，STM32MP157F平台使用流行的嵌入式系统引导加载程序U-Boot作为SSBL。U-Boot具有多种功能，常用于引导嵌入式Linux内核。接下来，Linux接管控制，启动其内核模块、服务和用户空间应用程序，并完成启动过程。
- en: Another feature of STM32MP157F devices, also increasingly seen for other microcontroller
    products and manufacturers, is the availability of a coprocessor. Here, an additional
    ARM Cortex-M4 microcontroller with dedicated RAM is integrated to allow for the
    robust execution of real-time tasks, as discussed in [Chapter 10](ch10.xhtml#ch10).
    Loading firmware to this additional controller might also be part of the boot
    process. This can be initiated either directly by an SSBL like U-Boot or later,
    out of the running Linux OS.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'STM32MP157F设备的另一个特点，也是其他微控制器产品和厂商日益常见的特性，是提供协处理器。在这里，集成了一个额外的ARM Cortex-M4微控制器，配有专用RAM，以支持实时任务的强健执行，如[第10章](ch10.xhtml#ch10)中所讨论的那样。将固件加载到这个附加控制器可能也是启动过程的一部分。这可以通过像U-Boot这样的SSBL直接发起，也可以在运行中的Linux操作系统后加载。 '
- en: Many developers would stop here, use the platform as described, and be happy
    if the boot process “just works.” However, until now, no protection against modification
    of any firmware parts has been considered.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者会停在这里，按描述使用该平台，并且如果启动过程“正常工作”就会感到满意。然而，直到现在，还没有考虑到任何固件部分被修改的保护。
- en: '***Secure Boot Starts in Hardware***'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安全启动从硬件开始***'
- en: Robust secure boot concepts have to start in hardware. For this purpose, the
    ROM code needs to provide a verification routine that can be used to authenticate
    the FSBL image. Luckily, STM32MP157F devices have an integrated feature for that
    purpose. [Figure 8-6](ch08.xhtml#ch08fig06) shows an overview of the related key
    generation, signing, and authentication process.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 强大的安全启动概念必须从硬件开始。因此，ROM代码需要提供一个验证程序，用于认证FSBL镜像。幸运的是，STM32MP157F设备具备为此目的而集成的功能。[图
    8-6](ch08.xhtml#ch08fig06)展示了相关的密钥生成、签名和认证过程概述。
- en: '![Image](../images/08fig06.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/08fig06.jpg)'
- en: '*Figure 8-6: The firmware signing and provisioning process for STM32MP157F
    devices*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-6：STM32MP157F设备的固件签名和供应过程*'
- en: The chip at hand utilizes the ECDSA algorithm to achieve integrity and authenticity
    of firmware images. In comparison to RSA, this enables faster signing and shorter
    keys, but the verification at boot time might take a bit longer. On the developers’
    side, the ECC key pair has to be generated by the STM32MP Key Generator tool,
    which results in a private key, a corresponding public key, and the SHA-256 hash
    of the public key. The latter is useful because it requires less OTP memory in
    the chip compared to storing the whole public key.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 手头的芯片利用ECDSA算法来实现固件镜像的完整性和真实性。与RSA相比，这可以实现更快的签名和更短的密钥，但在启动时的验证可能会稍微花费更多时间。在开发者一方，ECC密钥对必须通过STM32MP密钥生成工具生成，结果会得到一个私钥、一个对应的公钥和公钥的SHA-256哈希值。后者非常有用，因为它比存储完整的公钥占用的OTP内存少。
- en: To prepare the device for secure boot, the public-key hash has to be burned
    into its fuse memory. This can be achieved in various ways. You can use the ST-provided
    STM32 Cube Programmer or the U-Boot `stm32key` command. Also, the secure secret
    provisioning (SSP) feature might be of interest to you because it establishes
    a protected channel between a programmer and the STM32MP157F device, making it
    especially useful for secure production purposes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备设备进行安全启动，必须将公钥哈希烧录到其熔丝存储器中。这可以通过多种方式实现。你可以使用ST提供的STM32 Cube Programmer或U-Boot的`stm32key`命令。此外，安全密钥配置（SSP）功能可能对你有帮助，因为它在编程器和STM32MP157F设备之间建立了一个受保护的通道，尤其在安全生产环境中非常有用。
- en: '**NOTE**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The STM32MP157F device can be locked after writing the public-key hash to
    its OTP memory. This is mandatory for production but should be considered with
    caution during development.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*在将公钥哈希写入STM32MP157F的OTP存储器后，该设备可以被锁定。生产过程中这是强制要求的，但在开发阶段应谨慎考虑。*'
- en: After key provisioning in the device, the image has to be prepared for authenticated
    execution. Again, specific software, the STM32MP Signing Tool, is provided that
    processes the pre-generated ECDSA private key and the SHA-256 hash of the FSBL
    image in order to obtain the corresponding digital signature for this firmware
    part. The resulting image also contains the ECDSA public key and can be placed
    in the nonvolatile memory of the device.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备中完成密钥配置后，镜像需要准备好进行认证执行。同样，提供了特定的软件STM32MP签名工具，该工具处理预生成的ECDSA私钥和FSBL镜像的SHA-256哈希，以获得该固件部分的相应数字签名。生成的镜像还包含ECDSA公钥，并可以放置在设备的非易失性存储器中。
- en: 'At boot time, the ROM code verifies the integrity and authenticity of the presented
    FSBL image. First, the provided public key is verified by comparing its hash to
    the one stored in OTP memory. If correct, the key is used to verify the validity
    of the stored signature and the hash of the provided image. If successful, the
    FSBL payload is executed, and `NOTICE: Bootrom authentication succeeded` is output
    to the console. In any other case, the boot process halts.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '启动时，ROM代码会验证所提供的FSBL镜像的完整性和真实性。首先，通过将提供的公钥的哈希与OTP存储器中存储的哈希进行比较，验证公钥的有效性。如果正确，公钥将用于验证存储的签名和所提供镜像的哈希。如果验证成功，则执行FSBL负载，并在控制台输出`NOTICE:
    Bootrom authentication succeeded`。在其他任何情况下，启动过程将停止。'
- en: '***Secure Boot Based on BL2 TF-A***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基于BL2 TF-A的安全启动***'
- en: For the FSBL, STM32MP157F devices rely on ARM’s BL2 TF-A that also provides
    secure boot support. However, it’s disabled by default and has to be activated
    by setting the `TRUSTED_BOARD_BOOT=1` build flag. Afterward, the digital signatures
    of binaries loaded by BL2 are verified for integrity and authenticity based on
    asymmetric cryptography.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于FSBL，STM32MP157F设备依赖于ARM的BL2 TF-A，它也提供了安全启动支持。然而，默认情况下该功能是禁用的，必须通过设置`TRUSTED_BOARD_BOOT=1`构建标志来激活。之后，通过BL2加载的二进制文件会根据非对称加密技术验证其完整性和真实性。
- en: The BL2 TF-A requires a firmware image package (FIP) that can be generated with
    the `fiptool` application. It contains all binaries to be loaded and executed
    and the cryptographic data necessary to verify these binaries. The binaries include,
    for example, an SSBL and a TEE implementation like OP-TEE that runs in the ARM
    TrustZone. The TEE is denoted as BL32, and the SSBL is known as BL33 in the TF-A
    taxonomy.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: BL2 TF-A需要一个固件镜像包（FIP），该包可以通过`fiptool`应用程序生成。它包含所有需要加载和执行的二进制文件以及验证这些二进制文件所需的加密数据。这些二进制文件包括例如在ARM
    TrustZone中运行的SSBL和TEE实现，如OP-TEE。TEE被标记为BL32，而SSBL在TF-A的分类中被称为BL33。
- en: Again, the first step is the generation of key pairs (X.509 certificates in
    this case) that can be used for signing and verification of firmware parts. For
    this task, ST provides the `cert_create` tool.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，第一步是生成密钥对（在本例中是X.509证书），这些密钥可用于签署和验证固件部分。为此，ST提供了`cert_create`工具。
- en: The TF-A requires all certificates to be part of a chain of trust (CoT). By
    default, the public key stored in the STM32MP157F’s OTP memory is taken as the
    root key, so the corresponding private key is a mandatory input for the `cert_create`
    tool.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: TF-A要求所有证书都必须是信任链（CoT）的一部分。默认情况下，存储在STM32MP157F的OTP存储器中的公钥作为根密钥，因此对应的私钥是`cert_create`工具的强制输入。
- en: After all the binaries and corresponding certificates are finalized, the FIP
    can be generated, and the result can be deployed to the device. During the boot
    process, the BL2 TF-A will use Mbed TLS for certificate parsing and the STM32MP
    Crypto Lib for signature verification in order to use the hardware hashing module.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有二进制文件和相应的证书最终确定后，可以生成FIP，并将结果部署到设备上。在启动过程中，BL2 TF-A将使用Mbed TLS进行证书解析，并使用STM32MP
    Crypto库进行签名验证，以便使用硬件哈希模块。
- en: The order of binary loading and execution is as follows. First, BL2 loads BL32
    (OP-TEE) to memory and verifies its signature. Afterward, the same happens for
    BL33 (U-Boot). Only after successful verification, the execution of BL32 is started,
    which, in turn, calls BL33 after its own completion.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制加载和执行的顺序如下。首先，BL2将BL32（OP-TEE）加载到内存并验证其签名。随后，BL33（U-Boot）也会进行相同的操作。仅在验证成功后，才开始执行BL32，BL32完成后将调用BL33。
- en: '***U-Boot’s Secure Boot Feature***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***U-Boot的安全启动功能***'
- en: After the ROM code and the BL2 TF-A, the third implementation involved in the
    device’s secure boot is U-Boot’s image-authentication procedure. In 2013, the
    groundwork for U-Boot’s secure boot support was laid by introducing RSA-based
    signature verification for Flattened Image Tree (FIT) images.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在ROM代码和BL2 TF-A之后，设备安全启动中的第三个实现涉及U-Boot的镜像认证过程。2013年，通过引入基于RSA的签名验证，用于扁平化镜像树（FIT）镜像，为U-Boot的安全启动支持奠定了基础。
- en: To activate these features, several configuration options also have to be enabled—for
    example, RSA crypto functionality (`CONFIG_RSA`), FIT support (`CONFIG_FIT`),
    and signature handling in FIT images (`CONFIG_FIT_SIGNATURE`).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了激活这些功能，还必须启用几个配置选项——例如，RSA加密功能（`CONFIG_RSA`）、FIT支持（`CONFIG_FIT`）以及FIT镜像中的签名处理（`CONFIG_FIT_SIGNATURE`）。
- en: Again, key generation is a fundamental step. However, since U-Boot is an open
    source project, key generation is also possible with open source tools such as
    the `openssl` command line tool. At the time of writing, U-Boot supports digital
    signatures based on RSA-2048, RSA-3072, RSA-4096, and ECDSA with a 256-bit curve.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，密钥生成是一个基本步骤。然而，由于U-Boot是一个开源项目，密钥生成也可以使用开源工具，如`openssl`命令行工具。在撰写本文时，U-Boot支持基于RSA-2048、RSA-3072、RSA-4096和ECDSA（使用256位曲线）的数字签名。
- en: '[Listing 8-1](ch08.xhtml#ch08list01) shows the two commands that generate a
    typical 2,048-bit RSA key and a corresponding X.509 certificate. Both are required
    for the later signing and image-generation process.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-1](ch08.xhtml#ch08list01)展示了生成典型2048位RSA密钥和相应X.509证书的两个命令。两者都需要在后续的签名和镜像生成过程中使用。'
- en: '[PRE0]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 8-1: The key generation for U-Boot’s image verification*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-1：U-Boot镜像验证的密钥生成*'
- en: To generate a correctly signed FIT image, an Image Tree Source (ITS) file has
    to be created. [Listing 8-2](ch08.xhtml#ch08list02) shows an example.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个正确签名的FIT镜像，必须创建一个图像树源（ITS）文件。[列表 8-2](ch08.xhtml#ch08list02)展示了一个示例。
- en: '[PRE1]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 8-2: An example of a FIT image source*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-2：FIT镜像源示例*'
- en: This FIT image source example assumes the Linux kernel is available as `zImage`
    ➊ and its device tree blob (DTB) for the STM32MP157F-DK2 board is stored as *stm32mp157f-dk2.dtb*
    ➋. Both are hashed by SHA-256 ➌, but U-Boot would also support SHA-384 and SHA-512.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个FIT镜像源示例假设Linux内核作为`zImage` ➊ 可用，并且其设备树二进制文件（DTB）对于STM32MP157F-DK2开发板存储为*stm32mp157f-dk2.dtb*
    ➋。两者都通过SHA-256 ➌ 哈希处理，但U-Boot还支持SHA-384和SHA-512。
- en: Note that the kernel and DTB are combined only in the `configurations` section
    ➍ of the ITS file. This thwarts mix-and-match attacks that would try to boot and
    misuse unwanted pairs of kernels and DTBs. Using an RSA-2048 signature ➎ generated
    by the key *dev.key* ➏ on the configuration consisting of a specific kernel and
    a specific DTB grants only the execution of this explicit combination.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，内核和DTB仅在ITS文件的`configurations`部分 ➍ 中合并。这有效地防止了混合攻击，这种攻击试图启动并滥用不合适的内核和DTB组合。使用由密钥*dev.key*
    ➏ 生成的RSA-2048签名 ➎ 来验证包含特定内核和特定DTB的配置，只允许执行这种明确的组合。
- en: After processing the ITS file with the `mkimage` tool, the last firmware part
    is signed and ready to be stored on the STM32MP157F device’s memory card. On successful
    verification during U-Boot’s boot procedure, you’ll see a message in the serial
    console output similar to the one shown in [Listing 8-3](ch08.xhtml#ch08list03).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mkimage`工具处理ITS文件后，最后一个固件部分将被签名，并准备好存储到STM32MP157F设备的内存卡中。在U-Boot的启动过程中，验证成功时，你将在串口控制台输出中看到类似[列表
    8-3](ch08.xhtml#ch08list03)所示的消息。
- en: '[PRE2]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 8-3: A successful kernel and DTB verification by U-Boot*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-3：U-Boot成功的内核和DTB验证*'
- en: Subsequently, the execution of the verified Linux kernel is the worthy reward
    for your hard work.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，执行经过验证的Linux内核就是你辛勤工作后的值得回报。
- en: 'Even if the whole verification chain “works” up to this point, you still have
    two important tasks to do:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 即使整个验证链到目前为止“有效”，你仍然有两个重要的任务要完成：
- en: '**Perform comprehensive testing**    Confirm that every modification of a firmware
    part is actually detected and that the boot process is stopped accordingly. It
    might well be that, by mistake, a small part of the created image is not protected
    by a corresponding signature, which could open the door for manipulations.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**进行全面测试**    确保每次固件部分的修改都能被检测到，并且启动过程会相应地停止。很可能，由于疏忽，创建的映像的某个小部分未被相应的签名保护，这可能会为篡改提供机会。'
- en: '**Check hardware for known weaknesses**    Vulnerabilities in hardware components
    relevant for your boot process might break the security of the whole verification
    chain. Just as an example, CVE-2017-7932 and CVE-2017-7936 describe such hardware
    issues that can’t be fixed after production.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查硬件已知漏洞**    启动过程相关的硬件组件的漏洞可能会破坏整个验证链的安全性。例如，CVE-2017-7932和CVE-2017-7936描述了这种硬件问题，在生产后无法修复。'
- en: '**Integrity Protection Beyond the Boot Process**'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**启动过程之外的完整性保护**'
- en: The classic secure boot chain usually terminates at the point where the OS takes
    over control. However, device architects might quite rightly want to extend integrity
    and authenticity protection beyond that stage.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的安全启动链通常在操作系统接管控制的地方终止。然而，设备架构师可能会有充分理由希望将完整性和真实性保护延伸到此阶段之后。
- en: '***Kernel Module Verification***'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内核模块验证***'
- en: Loadable Linux kernel modules enable a modular and dynamic way of extending
    kernel functionality. However, modification of such a loadable module paves the
    way for malicious code execution with kernel rights by attackers. Therefore, verifying
    integrity and authenticity of these modules during the loading process is desirable.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 可加载的Linux内核模块提供了一种模块化和动态的方式来扩展内核功能。然而，修改这样的可加载模块为攻击者通过内核权限执行恶意代码打开了大门。因此，在加载过程中验证这些模块的完整性和真实性是很有必要的。
- en: The Linux kernel already provides support for this security feature. There,
    RSA-based signatures of kernel modules can be verified upon loading a certain
    kernel module, but this functionality is disabled by default. It has to be activated
    in the `Enable Loadable Module Support` section of the kernel’s configuration
    (`CONFIG_MODULE_SIG`).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核已经支持这个安全功能。在此，基于RSA的内核模块签名可以在加载某个内核模块时进行验证，但该功能默认是禁用的。它必须在内核配置的“启用可加载模块支持”部分启用（`CONFIG_MODULE_SIG`）。
- en: 'By default, kernel-module signature verification runs in *permissive* mode:
    modules without signatures or corresponding public keys are marked as tainted
    but are still loaded. To enforce valid module signatures, the `CONFIG _MODULE_SIG_FORCE`
    option has to be enabled.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，内核模块签名验证以*宽容*模式运行：没有签名或相应公钥的模块被标记为污染，但仍然会加载。要强制验证有效的模块签名，必须启用`CONFIG_MODULE_SIG_FORCE`选项。
- en: With standard settings for module signing, the kernel build process automatically
    generates signing keys and associated X.509 certificates at compile time by using
    OpenSSL. The created private keys are used to sign compiled kernel modules and
    might be discarded afterward. Of course, the certificates containing the public
    verification keys have to be integrated into the Linux kernel to enable successful
    verification at runtime.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块签名的标准设置下，内核构建过程会自动在编译时使用OpenSSL生成签名密钥和相关的X.509证书。创建的私钥用于签署已编译的内核模块，之后可能会被丢弃。当然，包含公钥验证的证书必须集成到Linux内核中，以便在运行时进行成功的验证。
- en: '***Filesystem Integrity***'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文件系统完整性***'
- en: As part of the Linux startup process, the kernel usually will mount one or more
    filesystems. These may contain application binaries, configuration data, trusted
    certificates, and public keys, all prone to tampering by adversaries. Standard
    filesystems like ext3 and ext4 incorporate mechanisms to deal with accidental
    data corruption but don’t provide integrity protection from a security point of
    view.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Linux启动过程的一部分，内核通常会挂载一个或多个文件系统。这些文件系统可能包含应用程序二进制文件、配置数据、受信任的证书和公钥，所有这些都可能被对手篡改。像ext3和ext4这样的标准文件系统包含处理意外数据损坏的机制，但从安全角度来看并不提供完整性保护。
- en: When looking at integrity protection for filesystem data, it’s important to
    distinguish between protecting data at rest (for example, in the power-off state)
    and protecting against data manipulation at runtime.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑文件系统数据的完整性保护时，重要的是要区分保护静态数据（例如，在关机状态下）与保护运行时数据不被篡改。
- en: '**MAC-Based Filesystem Protection**'
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**基于MAC的文件系统保护**'
- en: Stacked filesystems like EncFS and gocryptfs, mentioned for confidentiality
    protection in [Chapter 5](ch05.xhtml#ch05), can additionally provide integrity
    protection in the form of HMACs or authenticated encryption. These mechanisms
    target data-at-rest protection because changing data at runtime is desired and,
    of course, possible. They generate cryptographic checksums whenever files are
    written and verify them upon reading.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 像EncFS和gocryptfs这样的堆叠文件系统，在[第5章](ch05.xhtml#ch05)中提到过用于机密性保护的，可以额外提供完整性保护，形式为HMAC或认证加密。这些机制主要针对静态数据保护，因为在运行时更改数据是被允许的，当然也是可能的。它们在文件写入时生成加密校验和，并在读取时验证这些校验和。
- en: Further, integrity protection can also be achieved at the block device level.
    The popular `dm-crypt` crypto target for the Linux device mapper infrastructure
    can use `dm-integrity` (`CONFIG_DM_INTEGRITY`) that generates authentication tags
    when writing and verifies them when data is read. Also, `dm-crypt` supports authenticated
    encryption ciphers like AES-GCM and ChaCha20-Poly1305\. However, if only integrity
    protection is desired, `dm-integrity` can also be used standalone. Again, these
    measures aim for integrity protection against attackers modifying data in nonvolatile
    memory.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，完整性保护也可以在块设备级别实现。流行的`dm-crypt`加密目标用于Linux设备映射器基础设施，可以使用`dm-integrity`（`CONFIG_DM_INTEGRITY`），在写入时生成认证标签，并在读取数据时验证这些标签。同时，`dm-crypt`支持如AES-GCM和ChaCha20-Poly1305等认证加密算法。然而，如果仅需要完整性保护，`dm-integrity`也可以单独使用。这些措施的目标是保护数据免受攻击者修改非易失性内存中的数据。
- en: '**Read-Only Filesystems**'
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**只读文件系统**'
- en: If you’re concerned about filesystem modifications at runtime, an even simpler
    solution exists. Read-only filesystems like CramFS and SquashFS don’t implement
    write access for files, which means there’s simply no way to alter disk data at
    runtime, even if a system is compromised. A further nonsecurity advantage is the
    compressed storage of these filesystems, decreasing the demand for nonvolatile
    memory. However, attackers with offline access to the mass storage media can replace
    the filesystem at will.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你担心运行时文件系统的修改，还有一个更简单的解决方案。只读文件系统如CramFS和SquashFS不实现文件的写入访问，这意味着即使系统被攻破，也没有办法在运行时修改磁盘数据。这些文件系统的另一个非安全优势是它们的压缩存储，减少了对非易失性内存的需求。然而，具有离线访问存储介质的攻击者可以随意替换文件系统。
- en: '**Comprehensive Integrity Protection**'
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**全面的完整性保护**'
- en: 'Finally, one solution provides integrity protection against both offline and
    runtime attacks: the `dm-verity` module (`CONFIG_DM_VERITY`). Originating from
    the Chrome OS community, it’s meant as a direct extension of secure boot to filesystem
    integrity. Also, Android 4.4 introduced support for it in 2013, and it was strictly
    enforced in 2016, beginning with Android 7.0.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个解决方案提供了对离线和运行时攻击的完整性保护：`dm-verity`模块（`CONFIG_DM_VERITY`）。该模块源于Chrome OS社区，旨在作为安全启动与文件系统完整性之间的直接扩展。此外，Android
    4.4于2013年引入了对它的支持，并且在2016年开始严格执行，从Android 7.0开始。
- en: From a technical point of view, `dm-verity` uses a hash tree in which each data
    block in a given block device is hashed. Then, sets of hash values are hashed
    to obtain next-level hashes, and so on, until a single root hash remains. If this
    root-hash value is incorporated into the secure boot verification process, the
    integrity of all data within the block device can be guaranteed. At runtime, for
    each file access, the hash tree is verified up to the root hash. This, of course,
    leads to a read-only filesystem. The initialization process of such a volume is
    supported by the `veritysetup` user-space tool after filesystem image creation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，`dm-verity`使用哈希树，其中每个数据块在给定的块设备中都被哈希化。然后，将一组哈希值继续哈希，直到得到下一级哈希，以此类推，直到剩下一个根哈希值。如果将此根哈希值纳入安全启动验证过程，就可以保证块设备中所有数据的完整性。在运行时，每次访问文件时，哈希树都会被验证，直到根哈希。当然，这导致了一个只读文件系统。这样的卷的初始化过程由`veritysetup`用户空间工具在文件系统镜像创建后提供支持。
- en: '**Write Protection as a Low-Cost Solution**'
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**写保护作为一种低成本解决方案**'
- en: For some microcontrollers, especially low-cost and low-performance variants,
    secure boot is not available. However, that’s not a valid excuse for missing firmware
    protection.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些微控制器，尤其是低成本和低性能的变种，安全启动可能无法实现。然而，这并不能成为缺乏固件保护的有效理由。
- en: The boot process of these platforms is usually much simpler because they use
    an RTOS or even just run bare-metal software. Further, their software and data
    are considerably smaller and often reside at least partially in *internal* flash
    memory. But still, the goals of integrity and authenticity can be important to
    protect devices from malicious modifications.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些平台的启动过程通常要简单得多，因为它们使用实时操作系统（RTOS）或甚至仅运行裸机软件。此外，它们的软件和数据通常更小，并且往往至少部分存储在*内部*闪存中。但即便如此，完整性和真实性的目标对于保护设备免受恶意修改仍然很重要。
- en: A simple yet powerful feature in this context is the activation of write protection
    for internal flash memory. The firmware is written to the device and the memory
    is “locked” afterward. Also, debugging interfaces like Joint Test Action Group
    (JTAG) should be deactivated. Following the principle of defense in depth, it
    makes sense to implement verification functions within such firmware that check
    whether lock-bits and other anti-debugging measures are set properly. Then, even
    if write-protection mechanisms are circumvented—for example, by physical attacks—an
    adversary still has to invest a substantial amount of reverse engineering to completely
    break the firmware integrity protection.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一个简单但强大的功能是激活内部闪存的写保护。固件被写入设备后，内存会随之“锁定”。同时，调试接口（如联合测试行动组（JTAG））应当被禁用。遵循深度防御原则，在此类固件中实现验证功能是有意义的，这些功能检查锁定位和其他反调试措施是否设置正确。这样，即使写保护机制被绕过——例如通过物理攻击——攻击者仍然需要投入大量的逆向工程工作才能完全破坏固件的完整性保护。
- en: Of course, this internal, integrity-protected software might implement cryptographic
    signature verification and become the starting point of a verification chain that
    transfers the internal protection goals to data stored in external memories.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个内部的、完整性保护的软件可能会实现加密签名验证，并成为验证链的起点，进而将内部保护目标转移到存储在外部内存中的数据上。
- en: '**Summary**'
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Processor hardware and its manufacturers play an important role in the implementation
    of secure boot processes for embedded systems. Proprietary architectures, heterogeneous
    multicore complexity, and a conglomeration of marketing terms contribute to the
    high barrier that device architects and developers have to climb when aiming for
    a protected boot process.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器硬件及其制造商在嵌入式系统安全启动过程的实现中扮演着重要角色。专有架构、异构多核复杂性以及各种市场营销术语共同构成了设备架构师和开发人员在追求受保护启动过程时必须克服的高障碍。
- en: 'The basic principle is simple: an immutable hardware component verifies the
    first software component to be loaded for integrity and authenticity. If successful,
    execution is handed over to that software, which again might verify the next piece
    of software, and so on. However, in practice, as shown in this chapter’s case
    study, every stage of the boot process is different and requires product-specific
    knowledge and often vendor-specific tools. In addition, a series of cryptographic
    keys has to be managed, and device production processes even have to be prepared
    for secure boot support. The promising gain of this protection measure for the
    overall device security exacts its toll.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 基本原理很简单：一个不可变的硬件组件验证第一个加载的软件组件的完整性和真实性。如果验证成功，执行控制将交给该软件，之后该软件可能会验证下一个软件组件，以此类推。然而，实际上，如本章的案例研究所示，启动过程的每个阶段都不同，需要特定产品的知识，并且通常需要厂商特定的工具。此外，还必须管理一系列加密密钥，设备生产过程也必须为支持安全启动做好准备。此保护措施对整体设备安全性的显著提升是有代价的。
- en: A robust secure boot implementation is a strong foundation for further security
    measures like kernel-module verification, filesystem integrity protection, and
    a variety of runtime integrity measures. It even has a positive impact on reverse-engineering
    protection and the secure data storage approaches described in [Chapter 5](ch05.xhtml#ch05),
    because it prevents attackers from executing custom code on your product and thereby
    exploring its internals.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个健壮的安全启动实现是进一步安全措施的坚实基础，如内核模块验证、文件系统完整性保护和多种运行时完整性措施。它甚至对逆向工程保护和[第5章](ch05.xhtml#ch05)中描述的安全数据存储方法产生积极影响，因为它可以防止攻击者在你的产品上执行自定义代码，从而探索其内部结构。
