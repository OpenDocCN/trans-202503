- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">STRONGLY
    CONNECTED COMPONENTS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">强连通分量</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Previous chapters used connected components on undirected graphs to answer questions
    like “Can we get to a given location from here?” or “Would removing this edge
    break the graph’s connectivity?” Such questions and the algorithms that answer
    them become more complex once we start thinking about *directionality*. When examining
    *reachability* on a directed graph, it is no longer enough to say, “We can get
    from A to B.” We need to understand whether we can get back to A and, if not,
    how that impacts travel through the graph.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章使用无向图上的连通分量来回答诸如“我们能从这里到达某个位置吗？”或“移除此边会破坏图的连通性吗？”这类问题。随着我们开始思考*方向性*，这些问题和解答它们的算法变得更加复杂。当我们考察有向图上的*可达性*时，单纯地说“我们能从A到B”已经不再足够。我们需要理解是否能返回到A，如果不能，这将如何影响图的遍历。
- en: This chapter explores the concept of *strongly connected components*, sets of
    nodes in a directed graph such that any node in the set is reachable from any
    other node in the set. These components help us understand the structure of the
    graph and how it can be traversed. We start by formally introducing the concept
    of strongly connected components and providing example code for checking whether
    a set of nodes is strongly connected. We describe a few real-world applications
    of strongly connected components, including modeling how computer programs get
    stuck on certain states and how information would flow through a social network,
    then examine an example algorithm for identifying a graph’s strongly connected
    components.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了*强连通分量*的概念，这是有向图中一组节点，使得该组中的任何节点都可以从该组中的任何其他节点到达。这些分量帮助我们理解图的结构以及如何遍历图。我们首先正式介绍强连通分量的概念，并提供检查一组节点是否强连通的示例代码。我们还描述了一些强连通分量的实际应用，包括建模计算机程序如何在某些状态下卡住，以及信息如何通过社交网络流动，然后讨论一个识别图的强连通分量的示例算法。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Defining Strongly Connected Components</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">定义强连通分量</samp>
- en: The formal definition of a strongly connected component in a directed graph
    is a maximal set of nodes *V'* ⊆ *V* such that for any two nodes *u* ∈ *V'* and
    *v* ∈ *V'*, there exists a path of directed edges from *u* to *v*. In other words,
    you can reach any node in the strongly connected component when starting from
    any other node in the same component. If every node in a directed graph is part
    of the same strongly connected component, we call the graph *strongly connected*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有向图中强连通分量的正式定义是一个最大节点集*V'* ⊆ *V*，使得对于任何两个节点*u* ∈ *V'*和*v* ∈ *V'*，存在一条从*u*到*v*的有向边路径。换句话说，您可以从同一分量中的任何其他节点出发，到达强连通分量中的任何节点。如果有向图中的每个节点都属于同一个强连通分量，则我们称该图为*强连通*。
- en: We can visualize the importance of strongly connected components in the context
    of transportation networks. Let’s return to the magical labyrinth designed by
    an evil wizard, as introduced in [Chapter 11](chapter11.xhtml). To thwart wandering
    adventurers, the wizard uses one-way doors to connect each of their labyrinth’s
    rooms, as shown in [Figure 12-1](#fig12-1). They thus give each path a predefined
    flow. For example, adventurers can use the door between rooms A and B to travel
    from A to B, but not the other way around.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过交通网络来直观地理解强连通分量的重要性。让我们回到一个邪恶巫师设计的神奇迷宫，如[第 11 章](chapter11.xhtml)所介绍的那样。为了阻止冒险者迷路，巫师使用单向门连接迷宫中的每个房间，如[图
    12-1](#fig12-1)所示。这样，他们就给每条路径设定了预定义的流向。例如，冒险者可以通过房间A和B之间的门从A到B，但无法反向通过。
- en: '![The graph has six nodes and directed edges (A, B), (B, C), (B, E), (C, F),
    (D, A), (E, D), and (E, F).](../images/f12001.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![该图有六个节点和有向边 (A, B)、(B, C)、(B, E)、(C, F)、(D, A)、(E, D) 和 (E, F)。](../images/f12001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: A graph modeling
    the one-way doors between six rooms</samp>'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-1：一个模型，表示六个房间之间的单向门</samp>
- en: 'This approach succeeds beyond the wizard’s expectations. They had hoped simply
    to prevent adventurers from backtracking and surprising their minions from behind.
    Instead, they find that certain rooms become unreachable from other rooms. The
    labyrinth contains multiple strongly connected components: {A, B, D, E}, {C},
    and {F}. Adventurers can wander from room A to B to E to D and back to A without
    running afoul of the doors. However, disaster strikes as soon as they need to
    leave that component. Adventurers who have ventured into room C soon find there
    is no path for them to return to rooms A, B, D, or E. As time goes on, adventurers
    are effectively funneled into room F, which allows the wizard to trap the adventurers
    in that room with a boss-level monster.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法超出了巫师的预期。他们原本只希望防止冒险者回溯并从后方袭击他们的爪牙。然而，他们发现某些房间变得无法从其他房间到达。迷宫包含多个强连通组件：{A,
    B, D, E}，{C} 和 {F}。冒险者可以从房间 A 穿越到 B，再到 E，再到 D，并返回 A，而不会触及任何门。然而，一旦他们需要离开这个组件，灾难就发生了。进入房间
    C 的冒险者很快发现，他们无法找到回到房间 A、B、D 或 E 的路径。随着时间的推移，冒险者实际上被引导进入房间 F，这使得巫师能够将他们困在这个房间，并让他们与一只BOSS级怪物对抗。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Determining
    Which Nodes Are Mutually Reachable</samp>'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">确定哪些节点是相互可达的</samp>'
- en: The key aspect to understanding and building strongly connected components is
    determining which nodes are *mutually reachable*. Let’s start by reviewing what
    it means for node *v* to be reachable from node *u*. As noted in “Reachability”
    in [Chapter 3](chapter3.xhtml), node *v* is reachable from node *u* only if there
    exists a sequence of (directed) edges forming a continuous path starting at node
    *u* and terminating at node *v*. Under this definition, every node is reachable
    from itself by using the empty set of edges; we can always get to where we already
    are by not moving.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 理解并构建强连通组件的关键在于确定哪些节点是*相互可达*的。让我们首先回顾一下节点 *v* 从节点 *u* 可达的含义。如在[第 3 章](chapter3.xhtml)的“可达性”中所述，节点
    *v* 只有在存在一系列（有向）边，形成从节点 *u* 到节点 *v* 的连续路径时，才算从节点 *u* 可达。根据这个定义，每个节点都可以从自身可达，方法是使用空边集；我们可以通过不移动到达自己所在的位置。
- en: We can define a helper function <samp class="SANS_TheSansMonoCd_W5Regular_11">get_reachable()</samp>
    that uses a breadth-first search to retrieve the set of all other nodes that are
    reachable in a directed graph <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    from a given starting index (<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>).
    We use a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> data structure
    to track both the reachable nodes and the nodes seen during the current search,
    as shown in [Listing 12-1](#list12-1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个辅助函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">get_reachable()</samp>，通过广度优先搜索来获取从给定起始索引（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">index</samp>）开始，在有向图 <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    中所有可达节点的集合。我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> 数据结构来追踪当前搜索过程中可达的节点以及已经访问过的节点，如[列表
    12-1](#list12-1)所示。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-1: Retrieving a
    set of node indices reachable from the given node</samp>'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 12-1：获取从给定节点可达的节点索引集合</samp>
- en: 'The code starts by setting up the data structures: a set of seen and thus reachable
    nodes (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>) and a queue
    of future node indices to explore (<samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>).
    Note that the use of the queue data structure requires us to include <samp class="SANS_TheSansMonoCd_W5Regular_11">import
    queue</samp> in the file. The code adds the initial node (<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>)
    to both its <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> set and
    its queue of node indices to explore ❶.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先设置数据结构：一个已经访问过的、因此可达的节点集合（<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>）和一个待探索的未来节点索引队列（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>）。注意，使用队列数据结构要求我们在文件中包含
    <samp class="SANS_TheSansMonoCd_W5Regular_11">import queue</samp>。代码将初始节点（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">index</samp>）同时添加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>
    集合和待探索的节点索引队列 ❶ 中。
- en: The code uses a breadth-first search to discover all other reachable nodes in
    the graph. While there are nodes to explore (and thus <samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>
    is not empty) ❷, the code dequeues the next index, retrieves the node, and checks
    each of its neighbors using a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop. If the code has not previously encountered a neighbor, that neighbor’s index
    is added to both the queue and the <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>
    set ❸. When the code runs out of nodes to explore, it returns the set of seen
    indices. This set includes every node that can be reached from <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码使用广度优先搜索来发现图中所有其他可达的节点。当仍有节点可供探索（即<samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>不为空）❷时，代码将出队下一个索引，检索该节点，并使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环检查其每个邻居。如果代码之前未遇到过某个邻居，则该邻居的索引将被添加到队列和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>集合中❸。当代码没有更多节点可供探索时，它返回已见索引的集合。该集合包括所有可以从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">index</samp>到达的节点。
- en: The algorithm in [Listing 12-1](#list12-1) operates like a methodical adventurer
    planning their trip through a magical labyrinth to which they have a map. The
    adventurer maintains a list (queue) of rooms to evaluate, starting with just the
    entrance on the list. At each step, they take the top room from their list, cross
    it out, carefully locate it on their map, and check for adjacent rooms. They add
    any unexplored neighbors to the bottom of their list before drawing a tidy checkmark
    next to the room on the map. They then continue evaluating rooms, taking the top
    (or oldest) item on their list, until their list runs out.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例12-1](#list12-1)中的算法就像一个有条不紊的冒险者在规划穿越魔法迷宫的旅程，且他们手中有一张地图。冒险者维护一个待评估房间的列表（队列），列表初始时只有入口一个房间。在每一步，他们从列表中取出顶部的房间，划去它，仔细在地图上找到它的位置，并检查相邻的房间。他们将任何未探索的邻居添加到列表的底部，并在地图上为该房间画上整齐的勾号。然后，他们继续评估房间，从列表中取出顶部（或最旧）的项，直到列表为空。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Determining Whether
    Nodes Are Strongly Connected</samp>
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">确定节点是否强连接</samp>
- en: 'We can use the reachability function from [Listing 12-1](#list12-1) to define
    a brute-force check as to whether a set of nodes, given by a list of indices (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">inds</samp>), are strongly connected,
    as shown in the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用[示例12-1](#list12-1)中的可达性函数来定义一种暴力检查，来判断一组节点（由索引列表<samp class="SANS_TheSansMonoCd_W5Regular_11">inds</samp>给出）是否强连接，如下代码所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code uses a pair of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops to check whether every node in the component is reachable from every other
    node. It starts at each node index in <samp class="SANS_TheSansMonoCd_W5Regular_11">inds</samp>
    and uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_reachable()</samp>
    helper function from [Listing 12-1](#list12-1) to generate a set of reachable
    nodes. It then checks whether each index in <samp class="SANS_TheSansMonoCd_W5Regular_11">inds</samp>
    occurs in this reachable set. If any node is not reachable from any other, the
    function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. Otherwise,
    it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码使用一对嵌套的<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环来检查组件中每个节点是否可以从其他每个节点到达。它从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">inds</samp>中的每个节点索引开始，并使用来自[示例12-1](#list12-1)的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_reachable()</samp>辅助函数生成可达节点的集合。然后，它检查<samp
    class="SANS_TheSansMonoCd_W5Regular_11">inds</samp>中的每个索引是否出现在此可达集合中。如果任何节点无法从其他节点到达，则该函数返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。否则，它返回<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。
- en: Although the <samp class="SANS_TheSansMonoCd_W5Regular_11">check_strongly_connected()</samp>
    function is simple, consisting of just two loops and a helper search function,
    it is not an efficient approach. We introduce it here because it provides an easily
    understandable and intuitive overview of what is required for a set of nodes to
    be strongly connected. It is the computational equivalent of a hapless adventurer
    who begins a new exploration of the labyrinth from every possible room and records
    which destinations they reach. For a set of |*V* | nodes, the function needs to
    run |*V* | searches and then check the other |*V* | – 1 nodes against the resulting
    reachable set.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 <samp class="SANS_TheSansMonoCd_W5Regular_11">check_strongly_connected()</samp>
    函数很简单，仅由两个循环和一个辅助搜索函数组成，但它不是一种高效的方法。我们在这里介绍它，是因为它提供了一个易于理解和直观的概述，说明了一个节点集合需要满足什么条件才能是强连通的。它相当于一个不幸的冒险者，每次从可能的每个房间开始探索迷宫，并记录他们到达的目的地。对于一组
    |*V*| 节点，该函数需要运行 |*V*| 次搜索，然后检查其他 |*V*| – 1 个节点与结果可达集合的关系。
- en: Worse, the <samp class="SANS_TheSansMonoCd_W5Regular_11">check_strongly_connected()</samp>
    function does not tell us whether nodes are missing from the strongly connected
    component. Remember that strongly connected components are *maximal* sets of nodes
    that are mutually reachable. The function tells us only whether each pair of nodes
    in the list is mutually reachable. It does not tell us what other nodes could
    be part of the set.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，<samp class="SANS_TheSansMonoCd_W5Regular_11">check_strongly_connected()</samp>
    函数并没有告诉我们是否有节点缺失在强连通分量中。记住，强连通分量是*最大*的互相可达节点集合。该函数仅告诉我们列表中每一对节点是否互相可达，但没有告诉我们其他哪些节点可能属于该集合。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp>
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">用例</samp>
- en: 'Identifying strongly connected components in a graph is essential for understanding
    possible movement throughout the graph. This section provides some real-world
    applications for identifying strongly connected components: analyzing the flow
    of operations through a program, the flow of gossip through a network, and the
    ability to traverse a transportation network.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中识别强连通分量对于理解图中的可能移动至关重要。本节提供了一些识别强连通分量的实际应用：分析程序中的操作流、网络中的八卦传播流以及交通网络的遍历能力。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Modeling Computer
    Program States</samp>
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">计算机程序状态建模</samp>
- en: We can model the states of a computer program as a directed graph. The startup
    state might be a single node with edges to states for loading initial data, initializing
    variables, and checking the network connection. For example, [Figure 12-2](#fig12-2)
    shows a diagram of states in a video game. Individual states of the program represent
    processing user input and rendering the screen. The dotted line indicates the
    core game loop, which forms a strongly connected component where each state is
    reachable from each other state. However, states such as loading the initial data
    files or exiting the game are not part of this component; once you load the initial
    data files, the program never returns to that state.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将计算机程序的状态建模为有向图。启动状态可能是一个节点，连接到加载初始数据、初始化变量和检查网络连接的状态。例如，[图 12-2](#fig12-2)
    显示了视频游戏中的状态图。程序的各个状态代表处理用户输入和渲染屏幕。虚线表示核心游戏循环，它形成一个强连通分量，其中每个状态都可以从其他状态到达。然而，诸如加载初始数据文件或退出游戏的状态不属于该分量；一旦加载了初始数据文件，程序就不会再返回到该状态。
- en: '![A graph with nine nodes representing program states. The middle of the graph
    has a loop consisting of the nodes “Process Input,” “Move characters,” “Check
    conditions,” and “Render Screen.”](../images/f12002.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含九个节点的图，表示程序状态。图的中间有一个由“处理输入”、“移动角色”、“检查条件”和“渲染屏幕”节点组成的循环。](../images/f12002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-2: A toy video game
    modeled as a set of program states</samp>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-2：作为程序状态集建模的一个玩具视频游戏</samp>
- en: Computer programs may have multiple strongly connected components encapsulating
    different actions or logic. For example, a data analysis program might have one
    strongly connected component for batch processing data from a file and another
    to allow user interaction.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序可能有多个强连通分量，封装了不同的操作或逻辑。例如，一个数据分析程序可能有一个强连通分量用于批量处理文件中的数据，另一个用于允许用户交互。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding a Gossip
    Network</samp>
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">理解一个八卦网络</samp>
- en: The ability to find a graph’s strongly connected components can help us determine
    how far information can spread in directed communication networks. For such a
    network, a strongly connected component would be a group of people such that if
    one person knows something, the whole group knows it. That is, information passes
    from any node in the group to every other node in that same group.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找图的强连通分量的能力可以帮助我们确定信息在有向通信网络中的传播范围。对于这样的网络，一个强连通分量就是一组人，如果其中一个人知道某些信息，那么整组人都会知道。也就是说，信息会从该组中的任何一个节点传递到该组中所有其他节点。
- en: Consider the diagram of a social network in [Figure 12-3](#fig12-3), where each
    node represents an individual. An edge from node *u* to node *v* indicates that
    person *u* will tell person *v* an exciting rumor about the release of a new graph
    algorithms book. The lack of an edge indicates the lack of such communication.
    If any node shares a rumor, this information travels to all nodes that are reachable
    from the starting node.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑图示 [图12-3](#fig12-3) 中的社交网络，其中每个节点代表一个个体。从节点 *u* 到节点 *v* 的边表示人 *u* 会告诉人 *v*
    一个关于新图算法书籍发布的激动人心的谣言。没有边表示没有这种沟通。如果某个节点分享了一个谣言，那么这些信息将传播到从起始节点可达的所有节点。
- en: '![A graph with six nodes and directed edges (0, 1), (1, 4), (2, 5), (3, 4),
    (4, 0), (4, 3), (5, 2) and (5, 4).](../images/f12003.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含六个节点和有向边的图（0, 1）、（1, 4）、（2, 5）、（3, 4）、（4, 0）、（4, 3）、（5, 2）和（5, 4）](../images/f12003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-3: A graph modeling
    a communication network</samp>'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图12-3：一个模拟通信网络的图</samp>
- en: Strongly connected components provide an insight into groups that fully share
    information. In [Figure 12-3](#fig12-3), nodes 0, 1, 3, and 4 form a strongly
    connected component. Any information that person 4 shares will eventually be learned
    by those other nodes in the group.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 强连通分量提供了对完全共享信息的群体的洞察。在 [图12-3](#fig12-3) 中，节点 0、1、3 和 4 形成了一个强连通分量。任何节点 4 分享的信息最终都会被该分量中的其他节点了解。
- en: Remember that information can still flow between two nodes in different strongly
    connected components. In [Figure 12-3](#fig12-3), any information shared by node
    5 will eventually make its way to node 0 by way of node 4\. However, the inverse
    is not true. Since node 4 does not share information with node 5, both nodes 5
    and 2 are cut off from the secrets originating from the graph’s left side. They
    will not learn about the upcoming graph algorithms book until it is officially
    announced.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，信息仍然可以在不同强连通分量之间的两个节点之间流动。在 [图12-3](#fig12-3) 中，节点 5 分享的任何信息最终都会通过节点 4 传递到节点
    0。然而，反过来则不成立。由于节点 4 不与节点 5 分享信息，因此节点 5 和 2 被切断了来自图左侧的秘密。直到该图算法书籍正式发布前，他们不会知道这本书的消息。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Planning a Travel
    Network</samp>
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">规划一个旅行网络</samp>
- en: When planning out a real-world travel network, it’s essential to understand
    the strongly connected components involved. In the travel context, a strongly
    connected component is necessary for a traveler to make a round trip. If two locations
    are not in the same strongly connected component, such as the wizard’s dungeon
    with one-way doors, anyone traversing the network could get stuck in a subset
    of locations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在规划一个真实世界的旅行网络时，理解其中涉及的强连通分量是至关重要的。在旅行的上下文中，一个强连通分量对于旅行者进行圆形旅行是必需的。如果两个地点不在同一个强连通分量中，比如带有单向门的巫师地牢，那么任何穿越该网络的人可能会陷入某些地点的子集中。
- en: For example, in an airline network, any city *v* reachable from city *u* must
    be part of the same strongly connected component. Otherwise, both planes and passengers
    from the first component will get stuck in the second component. If an airline
    offers a set of flights from Toronto to Perth, they will need another set of flights
    that can return the planes and passengers to Toronto.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个航空网络中，从城市 *u* 可到达的任何城市 *v* 必须属于同一个强连通分量。否则，第一组的飞机和乘客将被困在第二组中。如果一家航空公司提供从多伦多到珀斯的一系列航班，它们还需要提供另一组航班，将飞机和乘客送回多伦多。
- en: Note that it is not strictly necessary for the airline network to form a single
    connected component, as the airline can serve two disjoint markets with two different
    strongly connected components. Perhaps it operates a commuter network serving
    cities in Florida and a separate network for New England. However, each subnetwork
    must be strongly connected.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，航空网络不必严格地形成一个单一的连通分量，因为航空公司可以用两个不同的强连通分量服务两个不相交的市场。也许它运营着一个服务佛罗里达城市的通勤网络，并且有一个独立的网络覆盖新英格兰。然而，每个子网络必须是强连通的。
- en: The same considerations apply when designing any travel network. It would be
    a disaster to have a section of the city with only incoming one-way roads. Commuters
    would drive into the section and be unable to leave. The area would soon fill
    with cars and persistent honking as desperate drivers tried to find any way out.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 设计任何交通网络时，都会考虑到相同的因素。如果城市某个区域只有单向的进站路，那将是一个灾难。通勤者只能开车进入该区域，却无法离开。这个区域很快就会被汽车塞满，绝望的司机试图寻找任何逃离的办法，持续的鸣笛声让局面更加混乱。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Kosaraju-Sharir’s Algorithm</samp>'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">Kosaraju-Sharir算法</samp>'
- en: '*Kosaraju-Sharir’s algorithm* (or just *Kosaraju’s algorithm*) is a practical,
    understandable, and visualizable algorithm for finding strongly connected components.
    In their book *Data Structures and Algorithms* (Addison-Wesley, 1983), Aho, Hopcroft,
    and Ullman describe the approach as being independently invented by computer scientists
    S. Rao Kosaraju and M. Sharir. This algorithm identifies strongly connected components
    by using a pair of depth-first searches along with an inverted graph.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*Kosaraju-Sharir算法*（或简称*Kosaraju算法*）是一种实用、易懂且可视化的算法，用于查找强连通分量。在他们的书《数据结构与算法》（Addison-Wesley，1983年）中，Aho、Hopcroft和Ullman描述了这一方法是由计算机科学家S.
    Rao Kosaraju和M. Sharir独立发明的。该算法通过使用一对深度优先搜索和一个反转图来识别强连通分量。'
- en: Kosaraju-Sharir’s algorithm begins by performing a depth-first search of the
    graph that effectively asks, “What nodes can I reach from this starting node?”
    Throughout the search, it records the *finishing time* of each node. The finishing
    time, also called *post-order index*, is a counter that records the order in which
    a search finishes processing a node. The first node finished is given a time of
    0, the second a time of 1, and so on. In our labyrinth example, this corresponds
    to the wizard walking the labyrinth’s rooms with a depth-first search—only proceeding
    through doors in the correct direction—and recording the final time they left
    each room.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Kosaraju-Sharir算法首先通过执行图的深度优先搜索来进行，该搜索有效地提出了“我可以从这个起始节点到达哪些节点？”在整个搜索过程中，它记录了每个节点的*完成时间*。完成时间，也叫做*后序索引*，是一个计数器，记录了搜索完成处理一个节点的顺序。第一个完成的节点时间为0，第二个为1，依此类推。在我们的迷宫示例中，这相当于巫师使用深度优先搜索走过迷宫的房间——只通过正确方向的门——并记录下他们离开每个房间的最终时间。
- en: 'Let’s return to the wizard inspecting their upgraded labyrinth shown in [Figure
    12-1](#fig12-1). During the initial inspection, they disable the one-way door
    spells so they can roam their own dungeon freely. The wizard then starts their
    inspection at room A. They walk to B, then C, then F before hitting their first
    dead end. Since there is nowhere to go, F gets a finishing order of 0\. The wizard
    backtracks to room C (whose door they kept open because they control the labyrinth),
    realizes there is nowhere new to go, and gives room C a finishing order of 1\.
    It isn’t until they backtrack to B that they find a new path forward. This time
    they go to room E, then room D, as they need to explore that path before they
    can call room B finished. This search progresses by assigning finishing times
    as follows: F = 0, C = 1, D = 2, E = 3, B = 4, and A = 5\. The ordering from this
    first search depends not only on the structure of the graph but also on the starting
    node chosen. If the wizard started their inspection at room D, they would finish
    that room last and get a finishing order of F = 0, C = 1, E = 2, B = 3, A = 4,
    and D = 5.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到巫师检查他们升级版迷宫的场景，如[图 12-1](#fig12-1)所示。在初步检查时，他们禁用了单向门的魔法，以便可以自由地漫游自己的迷宫。然后，巫师从房间
    A 开始检查。他们走到 B，然后到 C，再到 F，最后遇到第一个死胡同。由于没有地方可去，F 的结束顺序是 0\。巫师回溯到 C（因为他们控制着迷宫，所以保持了那扇门是开的），意识到没有新的地方可以去，并给
    C 房间分配了结束顺序 1\。直到他们回溯到 B，才发现了一条新的前进路径。这次，他们去到房间 E，再到房间 D，因为在标记 B 房间完成之前，需要探索这条路径。此搜索通过如下方式分配结束时间：F
    = 0，C = 1，D = 2，E = 3，B = 4，A = 5\。从第一次搜索得到的顺序不仅依赖于图的结构，还依赖于选择的起始节点。如果巫师从房间 D
    开始检查，他们将最后完成该房间，并得到结束顺序：F = 0，C = 1，E = 2，B = 3，A = 4，D = 5。
- en: The second phase of the algorithm reverses the direction of the graph’s edges
    and runs another set of depth-first searches. By doing so, it effectively pivots
    from asking, “What nodes can I reach from this starting node?” to “Where can I
    start if I want to reach this node?” This corresponds to the wizard inspecting
    their labyrinth in the reverse direction of the one-way doors. At each room, they
    use a depth-first search that travels in the opposite direction of the one-way
    doors, allowing them to see which rooms lead to the current one.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的第二阶段反转图的边的方向，并运行另一组深度优先搜索。通过这样做，它有效地将问题从“从这个起始节点可以到达哪些节点？”转变为“如果我想到达这个节点，我从哪里开始？”这相当于巫师检查迷宫时，逆向查看单向门的方向。在每个房间，他们使用深度优先搜索，沿着单向门的相反方向行进，从而能够看到哪些房间通向当前房间。
- en: To see this, consider the simple graph in [Figure 12-4(a)](#fig12-4) and its
    reverse in [Figure 12-4(b)](#fig12-4). A depth-first search that starts from node
    0 will find nodes reachable from node 0 (in this case, node 1). However, the same
    search on the reversed graph in [Figure 12-4(b)](#fig12-4) will find nodes that
    could reach node 0 in the original graph (that is, node 2).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看清楚这一点，请考虑[图 12-4(a)](#fig12-4)中的简单图和其反向图[图 12-4(b)](#fig12-4)。从节点 0 开始的深度优先搜索将找到从节点
    0 可达的节点（在这个例子中是节点 1）。然而，在[图 12-4(b)](#fig12-4)中对反向图进行相同的搜索，将找到能够到达原始图中节点 0 的节点（即节点
    2）。
- en: '![Two graphs with three nodes. In (A), the graph has directed edges (2, 0)
    and (0, 1). In (B), the graph has directed edges (1, 0) and (0, 2).](../images/f12004.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![两个图，每个图有三个节点。在 (A) 中，图有有向边 (2, 0) 和 (0, 1)。在 (B) 中，图有有向边 (1, 0) 和 (0, 2)。](../images/f12004.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-4: A simple graph
    (a) and its reverse (b)</samp>'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-4：一个简单的图（a）及其反向图（b）</samp>
- en: 'By running the second search on the reversed graph and choosing our starting
    nodes by *decreasing* finishing order, Kosaraju-Sharir’s algorithm combines the
    two questions: “What nodes can I reach from this starting node?” and “Where can
    I start if I want to reach this node?” During the second phase, the algorithm
    starts a new search (on the reversed graph) from each previously unvisited node
    and records which nodes are newly visited. The set of nodes visited during each
    search makes up a strongly connected component in the graph.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在反向图上运行第二次搜索，并按照*递减*的结束顺序选择我们的起始节点，Kosaraju-Sharir 算法结合了两个问题：“从这个起始节点可以到达哪些节点？”和“如果我想到达这个节点，我从哪里开始？”在第二阶段，算法从每个之前未访问的节点开始新的搜索（在反向图上），并记录哪些节点是新访问的。在每次搜索期间访问的节点集合构成了图中的强连通分量。
- en: 'Although Kosaraju-Sharir’s algorithm performs multiple depth-first searches,
    each node is visited at most two times: once in the original graph and once in
    the reversed graph. During each visit, the algorithm checks the current node’s
    outgoing edges exactly once, requiring time proportional to |*V* | + |*E*| for
    each search. Reversing the graph requires another iteration over all nodes and
    their outgoing edges, scaling proportional to |*V* | + |*E*|. The overall running
    time of the algorithm therefore scales as |*V* | + |*E*|.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Kosaraju-Sharir算法执行了多次深度优先搜索，但每个节点最多只会被访问两次：一次是在原图中，一次是在反转图中。每次访问时，算法会检查当前节点的出边，要求的时间是|*V*|
    + |*E*|，每次搜索所需的时间都是成比例的。反转图需要再次遍历所有节点及其出边，时间复杂度同样是|*V*| + |*E*|。因此，算法的总体运行时间为|*V*|
    + |*E*|。
- en: The reasoning behind why this algorithm works is a bit complex, and a full proof
    is outside the scope of the book. The interested reader can find a good discussion
    of this in algorithmic texts such as *Data Structures and Algorithms* and Sedgewick
    and Wayne’s *Algorithms*, 4th edition (Addison-Wesley, 2011). For now, let’s examine
    how this algorithm builds off those in [Chapters 4](chapter4.xhtml) and [11](chapter11.xhtml)
    to solve a novel problem.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法为何有效的推理有点复杂，完整的证明超出了本书的范围。有兴趣的读者可以在算法学类的书籍中找到相关讨论，比如《数据结构与算法》和Sedgewick与Wayne的《算法》第4版（Addison-Wesley,
    2011）。目前，让我们来看看这个算法是如何基于[第4章](chapter4.xhtml)和[第11章](chapter11.xhtml)中的算法来解决一个新问题的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Transposed Graphs</samp>
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">转置图</samp>
- en: A core step of Kosaraju-Sharir’s algorithm is performing the depth-first search
    on a version of the graph with its edges reversed, known as a *transposed graph*.
    This term comes from the *matrix transpose operation*, which reverses each edge’s
    direction; we’ll discuss this in greater detail shortly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Kosaraju-Sharir算法的核心步骤是对图的边反向版本进行深度优先搜索，这个版本称为*转置图*。这个术语来源于*矩阵转置操作*，它反转每条边的方向；我们稍后将详细讨论这一点。
- en: 'For our adjacency list representation of a graph, we define a <samp class="SANS_TheSansMonoCd_W5Regular_11">make_transpose
    _graph()</samp> function that creates a transposed graph by iterating through
    each of the graph’s edges and adding the inverse edge to a new graph:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图的邻接表表示法，我们定义了一个<`samp` class="SANS_TheSansMonoCd_W5Regular_11">make_transpose_graph()</samp>函数，它通过遍历图中的每条边并将反向边添加到一个新图中来创建转置图：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">make_transpose_graph()</samp>
    code starts by creating an empty graph (<samp class="SANS_TheSansMonoCd_W5Regular_11">g2</samp>)
    with the correct number of nodes and copying the original graph’s <samp class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp>
    setting ❶. It then iterates through each node in the original graph and each of
    its edges. For each edge, the code adds an edge in the opposite direction to the
    new graph. The code finishes by returning the new graph.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">make_transpose_graph()</samp>代码首先创建一个空图（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">g2</samp>），并设置正确的节点数量，并复制原图的<`samp` class="SANS_TheSansMonoCd_W5Regular_11">无向</samp>设置❶。然后，它遍历原图中的每个节点及其每条边。对于每条边，代码会在新图中添加一条相反方向的边。最后，代码返回新图。
- en: We can picture this function in the context of our earlier labyrinth example
    by considering a change to the underlying environment. An apprentice evil wizard,
    looking for an accomplishment on which to base their reputation, decides to reverse
    the direction of *every* door in the labyrinth. They execute this audacious plan
    by starting with a fresh map, considering each door on the old map, and adding
    it to the new map with the inverse direction. Once every door has been processed,
    they submit it to their supervisor and await the inevitable praise.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过考虑底层环境的变化来将这个函数与前面提到的迷宫示例相结合。一位学徒邪恶巫师，为了在自己的声誉上有所成就，决定将迷宫中*每个*门的方向反转。他们通过从一张新的地图开始，考虑旧地图中的每个门，并将其添加到新地图中，方向相反来执行这一大胆的计划。每个门处理完后，他们将其提交给导师，等待不可避免的赞扬。
- en: Note that while the <samp class="SANS_TheSansMonoCd_W5Regular_11">make_transpose_graph()</samp>
    function technically supports undirected graphs by copying the original graph’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp> setting, it is
    useful only for directed graphs. The transpose of an undirected graph will be
    equivalent to the original graph.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管<sup><samp class="SANS_TheSansMonoCd_W5Regular_11">make_transpose_graph()</samp></sup>函数在技术上通过复制原始图的<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp></sup>设置支持无向图，但它仅对有向图有用。无向图的转置将等于原始图。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: 'The code for Kosaraju-Sharir’s algorithm uses a helper function that implements
    the individual searches needed during each phase of the algorithm, performing
    a modified depth-first search over unseen nodes and adding each newly visited
    node to a given list in order of increasing finish time:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Kosaraju-Sharir算法的代码使用了一个辅助函数，该函数实现了每个算法阶段所需的单独搜索，执行针对未访问节点的修改版深度优先搜索，并按递增的完成时间将每个新访问的节点添加到给定的列表中：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In addition to the graph (<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>)
    and the current index (<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>),
    the function takes in a Boolean list (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>)
    indicating which nodes have been seen and a list of node indices representing
    the finish order (<samp class="SANS_TheSansMonoCd_W5Regular_11">reachable</samp>).
    The code starts by marking the current node index as seen and retrieving the node
    data structure. A single <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop iterates over the unseen neighbors and recursively explores them. When the
    search has finished processing a node, it adds that node to the end of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">reachable</samp> list. Since the node
    index is added at the end of the function, the final list will be sorted in order
    of increasing finish times once recursive exploration completes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了图（<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>）和当前索引（<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>）外，该函数还接受一个布尔列表（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>），指示哪些节点已经被访问过，以及一个表示完成顺序的节点索引列表（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">reachable</samp>）。代码首先将当前节点索引标记为已访问，并检索节点数据结构。一个简单的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环遍历未访问的邻居节点并递归探索它们。当搜索完成处理一个节点时，它会将该节点添加到<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">reachable</samp></sup>列表的末尾。由于节点索引是在函数的末尾添加的，因此一旦递归探索完成，最终列表将按完成时间递增的顺序排序。
- en: 'The code for the full Kosaraju-Sharir’s algorithm consists of iterating through
    the list of nodes twice and calling the helper functions on currently unvisited
    nodes:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Kosaraju-Sharir算法的完整代码包括两次遍历节点列表，并在当前未访问的节点上调用辅助函数：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The code starts by setting up the data structures for the first search: a Boolean
    list indicating whether each node has been seen (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen1</samp>)
    and a single list of the node indices ordered by *increasing* finish time (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">finish_ordered</samp>). The <samp class="SANS_TheSansMonoCd_W5Regular_11">finish_ordered</samp>
    list is initially empty because no nodes have been visited. A <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop then performs the first phase of the algorithm by iterating through each
    node index and starting a depth-first search from any unvisited nodes ❶. Since
    the code uses the same <samp class="SANS_TheSansMonoCd_W5Regular_11">finish_ordered</samp>
    list for each call, all the nodes are included in a single list.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过设置数据结构来开始第一次搜索：一个布尔列表表示每个节点是否已被访问（<samp class="SANS_TheSansMonoCd_W5Regular_11">seen1</samp>），以及一个按*递增*完成时间排序的节点索引列表（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">finish_ordered</samp>）。<samp class="SANS_TheSansMonoCd_W5Regular_11">finish_ordered</samp>列表最初为空，因为没有节点被访问过。然后，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环执行算法的第一阶段，通过遍历每个节点索引并从任何未访问的节点开始深度优先搜索
    ❶。由于代码在每次调用时使用相同的<samp class="SANS_TheSansMonoCd_W5Regular_11">finish_ordered</samp>列表，因此所有节点都包含在一个单独的列表中。
- en: The second phase starts by reversing the edges of the graph using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">make_transpose_graph()</samp> function
    ❷. The code creates a new Boolean list to indicate which nodes it has seen during
    the second round of searches (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen2</samp>),
    then creates an empty list of components (<samp class="SANS_TheSansMonoCd_W5Regular_11">components</samp>).
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">components</samp> list will
    be a list of lists where each entry contains a list of all node indices in that
    strongly connected component. A <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop iterates over the nodes in order of *decreasing* finish order ❸, achieving
    this ordering by treating the <samp class="SANS_TheSansMonoCd_W5Regular_11">finish_ordered</samp>
    list as a stack and popping off the last element during each iteration. The stack
    size shrinks by one and the code checks a new node index (<samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp>)
    to see if it needs to start a search from that node.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">make_transpose_graph()</samp>
    函数反转图的边❷开始。代码创建一个新的布尔列表来指示在第二轮搜索过程中它已经访问过的节点（<samp class="SANS_TheSansMonoCd_W5Regular_11">seen2</samp>），然后创建一个空的组件列表（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">components</samp>）。<samp class="SANS_TheSansMonoCd_W5Regular_11">components</samp>
    列表将是一个包含多个列表的列表，每个条目包含一个强连通分量中所有节点的索引。一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    循环按 *递减* 完成顺序❸遍历节点，通过将 <samp class="SANS_TheSansMonoCd_W5Regular_11">finish_ordered</samp>
    列表当作栈来实现这一排序，每次迭代时弹出栈中的最后一个元素。栈的大小减小一个，代码检查一个新的节点索引（<samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp>），看看是否需要从该节点开始新的搜索。
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">add_reachable()</samp>
    function, the code starts a new search from each unvisited node ❹. Each time,
    it passes in a new empty result list (<samp class="SANS_TheSansMonoCd_W5Regular_11">new_component</samp>)
    to represent the current strongly connected component. The function fills the
    list with the node indices of the new strongly connected component. The code then
    appends the <samp class="SANS_TheSansMonoCd_W5Regular_11">new_component</samp>
    list to <samp class="SANS_TheSansMonoCd_W5Regular_11">components</samp>.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">add_reachable()</samp> 函数，代码从每个未访问的节点开始新的搜索❹。每次，它传入一个新的空结果列表（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">new_component</samp>）来表示当前的强连通分量。该函数将该列表填充为新的强连通分量的节点索引。然后，代码将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">new_component</samp> 列表附加到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">components</samp> 列表中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个示例</samp>
- en: Let’s examine how Kosaraju-Sharir’s algorithm behaves on the example graph shown
    in [Figure 12-5](#fig12-5).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 Kosaraju-Sharir 算法在示例图 [12-5](#fig12-5) 中的表现。
- en: '![A graph with six nodes and directed edges (0, 2), (2, 3), (3, 0), (3, 5),
    (4, 5), and (5, 4).](../images/f12005.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含六个节点和有向边 (0, 2), (2, 3), (3, 0), (3, 5), (4, 5), (5, 4) 的图。](../images/f12005.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-5: A directed graph
    with six nodes</samp>'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-5：一个包含六个节点的有向图</samp>
- en: The first stage of the algorithm is shown in [Figure 12-6](#fig12-6) and considers
    the nodes in order of increasing node index. The algorithm runs a depth-first
    search starting from node 0 and computes the order in which each node finishes.
    Node 4 is at the end of a long dead end and thus finishes first. In contrast,
    node 0 does not finish until its depth-first search finds four other nodes. After
    the first depth-first search completes, node 1 is still unvisited, so the algorithm
    starts a new search there. The final ordering is 4, 5, 3, 2, 0, 1, as shown by
    the finish order indicated outside each node.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的第一阶段如图 [12-6](#fig12-6) 所示，按照节点索引递增的顺序考虑节点。算法从节点 0 开始进行深度优先搜索，并计算每个节点完成的顺序。节点
    4 位于一条长长的死胡同的尽头，因此最先完成。相比之下，节点 0 直到它的深度优先搜索发现四个其他节点后才完成。在第一次深度优先搜索完成后，节点 1 仍未访问，因此算法从该节点开始新的搜索。最终的排序为
    4, 5, 3, 2, 0, 1，如每个节点外部指示的完成顺序所示。
- en: '![The nodes in the graph are labeled node 0 = 4, node 1 = 5, node 2 = 3, node
    3 = 2, node 4 = 0, and node 5 = 1.](../images/f12006.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图中的节点标记为节点 0 = 4，节点 1 = 5，节点 2 = 3，节点 3 = 2，节点 4 = 0，节点 5 = 1。](../images/f12006.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-6: The first iteration
    of Kosaraju-Sharir’s algorithm produces an ordering of nodes.</samp>'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-6：Kosaraju-Sharir 算法的第一次迭代产生了节点的排序。</samp>
- en: In this phase of the algorithm, we start a new depth-first search from every
    unvisited node, as in the case of node 1\. Nodes that are not reachable from node
    0 are thus included in later depth-first searches and added to the end of the
    ordering.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法的这一阶段，我们从每个未访问的节点开始新的深度优先搜索，如节点 1 的情况。不能从节点 0 到达的节点因此会在后续的深度优先搜索中被包含，并添加到排序的末尾。
- en: 'In its second stage, Kosaraju-Sharir’s algorithm transposes the graph, uses
    a new array of unseen markers, and repeats this sequence of up to |*V* | depth-first
    searches. Instead of searching the nodes in arbitrary order, such as using increasing
    node index, the algorithm chooses the starting nodes using the inverse of the
    finish ordering from the first step: 1, 0, 2, 3, 5, 4\. The last node to finish
    becomes the starting point for the first search. Each time the algorithm hits
    an unseen node during our outer loop, it starts a new depth-first search from
    that node. It adds all unseen nodes encountered during this depth-first search
    to the current component and marks them as seen.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二阶段，Kosaraju-Sharir 算法对图进行转置，使用一个新的未见标记数组，并重复执行最多 |*V* | 次深度优先搜索序列。算法不会按照任意顺序（例如使用递增的节点索引）来搜索节点，而是使用第一步中完成顺序的反向来选择起始节点：1、0、2、3、5、4。最后完成的节点成为第一次搜索的起点。每当算法在外部循环中遇到一个未见的节点时，它就从该节点开始新的深度优先搜索。它将所有在此次深度优先搜索中遇到的未见节点添加到当前组件中，并标记它们为已见。
- en: '[Figure 12-7](#fig12-7) shows the three searches performed during the second
    stage on our example graph, starting from node 1 in [Figure 12-7(a)](#fig12-7),
    node 0 in [Figure 12-7(b)](#fig12-7), and finally node 5 in [Figure 12-7(c)](#fig12-7).
    Nodes circled with dashed lines indicate the nodes visited during each depth-first
    search, while gray nodes indicate the nodes with a <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>
    value set to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> by either
    the current search or a previous one.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-7](#fig12-7) 显示了我们在示例图中第二阶段执行的三次搜索，从[图 12-7(a)](#fig12-7)中的节点 1、[图 12-7(b)](#fig12-7)中的节点
    0，以及最终在[图 12-7(c)](#fig12-7)中的节点 5开始。用虚线圈起的节点表示在每次深度优先搜索中访问的节点，而灰色节点表示由当前搜索或先前的搜索将其<samp
    class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>值设置为<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>的节点。'
- en: '![Three subfigures show different searches. In (A), node 1 is circled. In (B),
    nodes 0, 2, and 3 are circled. In (C), nodes 4 and 5 are circled.](../images/f12007.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![三个子图显示了不同的搜索。在 (A) 中，节点 1 被圈起。在 (B) 中，节点 0、2 和 3 被圈起。在 (C) 中，节点 4 和 5 被圈起。](../images/f12007.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-7: The second stage
    of Kosaraju-Sharir’s algorithm</samp>'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-7：Kosaraju-Sharir 算法的第二阶段</samp>
- en: As shown in [Figure 12-6](#fig12-6), we only start searches at unseen nodes,
    and individual searches do not visit already seen nodes from previous searches.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 12-6](#fig12-6)所示，我们只在未见的节点上启动搜索，单个搜索不会访问先前搜索中已见的节点。
- en: The first depth-first search, shown in [Figure 12-7(a)](#fig12-7), starts at
    node 1\. In [Figure 12-7(b)](#fig12-7), the depth-first search of the reversed
    graph starts at node 0 and progresses to node 3 and then node 2\. At this point,
    it hits a dead end and backtracks. When the depth-first search returns to node
    0, we know that we have visited all nodes that both could reach node 0 and are
    reachable from node 0 in the original graph. The third and final depth-first search
    is shown in [Figure 12-7(c)](#fig12-7) and explores nodes 4 and 5.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次深度优先搜索，如[图 12-7(a)](#fig12-7)所示，从节点 1 开始。在[图 12-7(b)](#fig12-7)中，反向图的深度优先搜索从节点
    0 开始，依次访问节点 3，然后是节点 2。此时，它遇到死胡同并回溯。当深度优先搜索返回到节点 0 时，我们知道我们已经访问了所有可以到达节点 0并且在原始图中从节点
    0可达的节点。第三次也是最后一次深度优先搜索，如[图 12-7(c)](#fig12-7)所示，探索了节点 4 和 5。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">为什么这很重要</samp>
- en: Strongly connected components provide insight into the subsets of nodes that
    are mutually reachable. The concepts in this chapter provide both a practical
    tool for thinking about real-world problems, such as transportation networks or
    gossip networks, and a foundation for thinking about the fundamental structure
    of a graph itself. For example, identifying the strongly connected components
    provides one mechanism for partitioning a large graph into meaningful subgraphs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 强连通分量揭示了相互可达的节点子集。本文中的概念不仅为解决现实世界问题（如交通网络或谣言网络）提供了一个实用工具，而且为思考图的基本结构提供了基础。例如，识别强连通分量提供了一种将大图分割成有意义子图的机制。
- en: The algorithms presented in this chapter build off the basic depth-first search
    from [Chapter 4](chapter4.xhtml) to analyze reachability within graphs and construct
    strongly connected components. Kosaraju-Sharir’s algorithm provides both a practical
    and visualizable approach to finding connected components and shows how we can
    continue to adapt search algorithms to more complex problems.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的算法基于[第4章](chapter4.xhtml)中的基本深度优先搜索，用于分析图中的可达性并构建强连通分量。Kosaraju-Sharir算法提供了一种既实用又易于可视化的查找连通分量的方法，展示了我们如何继续将搜索算法应用于更复杂的问题。
- en: Beyond the algorithm covered in this chapter, a variety of other approaches
    have been developed to find strongly connected components. For example, Robert
    Tarjan proposed an algorithm for this purpose that relies on just a single depth-first
    search, using the same principles as his algorithms discussed in [Chapter 11](chapter11.xhtml).
    As with all topics in this book, a rich variety of approaches with different trade-offs
    exist. The goal of this chapter is to provide a foundation for understanding and
    comparing these different approaches.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本章介绍的算法外，还有多种其他方法被开发出来用于查找强连通分量。例如，罗伯特·塔尔贾恩（Robert Tarjan）提出了一种算法，仅依靠一次深度优先搜索，并使用与他在[第11章](chapter11.xhtml)中讨论的算法相同的原理。和本书中的所有主题一样，存在多种具有不同权衡的解决方案。本章的目标是为理解和比较这些不同方法提供基础。
- en: The next chapter discusses random walks through graphs, building on the concepts
    behind strongly connected components to examine how walks can get stuck in absorption
    states or wander around forever.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章讨论了图中的随机游走，基于强连通分量的概念，研究了游走如何陷入吸收状态或永远漫游下去。
