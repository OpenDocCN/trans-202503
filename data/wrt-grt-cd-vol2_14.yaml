- en: '**14**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**14**'
- en: '**ITERATIVE CONTROL STRUCTURES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代控制结构**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: 'Most programs spend the majority of their time executing machine instructions
    within a loop. Therefore, if you want to improve your applications’ execution
    speed, first you should see if you can improve the performance of the loops in
    your code. This chapter will describe the following varieties of loops:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序的大部分时间都在循环中执行机器指令。因此，如果你想提高应用程序的执行速度，首先应该看看能否提高代码中循环的性能。本章将介绍以下几种循环形式：
- en: '`while` loops'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: '`repeat..until/do..while` loops'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repeat..until/do..while` 循环'
- en: '`forever` (infinite) loops'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forever`（无限）循环'
- en: '`for` (definite) loops'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`（确定性）循环'
- en: '**14.1 The while Loop**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**14.1 while 循环**'
- en: 'The `while` loop is perhaps the most general-purpose iterative statement that
    HLLs provide, so compilers generally work hard at emitting optimal code for it.
    The `while` loop tests a Boolean expression at the top of the loop body and, if
    the expression evaluates to `true`, executes the loop body. When the loop body
    completes execution, control transfers back to the test and the process repeats.
    When the Boolean control expression evaluates to `false`, the program transfers
    control to the first statement beyond the loop’s body. This means that if the
    Boolean expression evaluates to `false` when the program first encounters the
    `while` statement, the program immediately skips over all statements in the loop
    body without executing any of them. The following example demonstrates a Pascal
    `while` loop:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环可能是高级语言（HLL）提供的最通用的迭代语句，因此编译器通常会努力生成最优的代码。`while` 循环在循环体的顶部测试一个布尔表达式，如果表达式计算结果为
    `true`，则执行循环体。当循环体执行完毕后，控制权返回到测试语句，过程重复。当布尔控制表达式计算结果为 `false` 时，程序将控制转移到循环体之外的第一个语句。这意味着如果程序首次遇到
    `while` 语句时布尔表达式计算结果为 `false`，程序将跳过循环体中的所有语句而不执行它们。以下示例演示了一个 Pascal 的 `while`
    循环：'
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can easily simulate a `while` loop in an HLL by using an `if` statement
    and a `goto` statement. Consider the following C/C++ `while` loop and the semantically
    equivalent code using an `if` and a `goto`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `if` 语句和 `goto` 语句在高级语言中轻松模拟 `while` 循环。考虑以下 C/C++ 的 `while` 循环以及使用
    `if` 和 `goto` 的语义等效代码：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Assume for the sake of this example that `x` is less than `y` when the `if`/`goto`
    combination first executes. This being `true`, the body of the loop (the `then`
    portion of the `if` statement) executes. At the bottom of the loop body, the `goto`
    statement transfers control back to just before the `if` statement. This means
    that the code will test the expression again, just as the `while` loop does. Whenever
    the `if` expression evaluates to `false`, control will transfer to the first statement
    after the `if` (which transfers control beyond the `goto` statement in this code).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设为了这个示例，当 `if`/`goto` 组合首次执行时，`x` 小于 `y`。既然这一条件为 `true`，那么循环体（`if` 语句的 `then`
    部分）就会执行。在循环体的底部，`goto` 语句将控制转移回到 `if` 语句之前的位置。这意味着代码会再次测试该表达式，就像 `while` 循环那样。每当
    `if` 表达式计算结果为 `false` 时，控制将转移到 `if` 后的第一个语句（这将控制转移到 `goto` 语句之后的部分）。
- en: 'Although the `if`/`goto` arrangement is semantically identical to the `while`
    loop, that’s not to suggest that the `if`/`goto` scheme presented here is more
    efficient than what a typical compiler would generate. It’s not. The following
    assembly code shows what you’d get from a mediocre compiler for the previous `while`
    loop:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `if`/`goto` 组合在语义上与 `while` 循环相同，但这并不意味着这里呈现的 `if`/`goto` 方案比典型编译器生成的代码更高效。并不是的。以下汇编代码展示了你从一个平庸的编译器中获得的
    `while` 循环的代码：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A decent compiler will improve upon this slightly by using a technique known
    as *code movement* (or *expression rotation*). Consider this slightly more efficient
    implementation of the previous `while` loop:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优秀的编译器会通过使用一种叫做*代码移动*（或*表达式旋转*）的技术稍微改进这一点。考虑一下这个比之前的 `while` 循环更高效的实现：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This example has exactly the same number of machine instructions as the previous
    example, but the test for loop termination has been moved to the bottom of the
    loop. To preserve the semantics of a `while` loop (so that we don’t execute the
    loop body if the expression evaluates to `false` upon first encountering the loop),
    the first statement in this sequence is a `jmp` statement that transfers control
    down to the code that tests the loop termination expression. If that test evaluates
    to `true`, the program transfers control to the body of the `while` loop (immediately
    after `whlLabel`).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例与前一个示例的机器指令数量完全相同，但循环终止的测试已移至循环的底部。为了保留`while`循环的语义（以便我们在第一次遇到循环时，如果表达式求值为`false`，就不执行循环体），该序列中的第一条语句是一个`jmp`语句，将控制转移到测试循环终止表达式的代码。如果该测试求值为`true`，程序将控制转移到`while`循环体（紧跟在`whlLabel`之后）。
- en: Although this code has the same number of statements as the previous example,
    there’s a subtle difference between the two implementations. In this latter example,
    the initial `jmp` instruction executes only once—the very first time the loop
    executes. For each iteration thereafter, the code skips the execution of this
    statement. In the original example, the corresponding `jmp` statement is at the
    bottom of the loop’s body, and it executes on each iteration of the loop. Therefore,
    if the loop body executes more than once, the second version runs faster (on the
    other hand, if the `while` loop rarely executes the loop body even once, then
    the first version is slightly more efficient). If your compiler does not generate
    the best code for a `while` statement, consider getting a different compiler.
    As [Chapter 13](ch13.xhtml#ch13) discussed, attempting to write optimal code in
    an HLL by using `if` and `goto` statements will produce difficult-to-read spaghetti
    code and, more often than not, `goto` statements in your code will actually impair
    the compiler’s ability to produce decent output.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此代码与前一个示例有相同数量的语句，但两者之间有一个微妙的区别。在这个后者的示例中，初始的`jmp`指令仅执行一次——也就是循环执行的第一次。此后的每次迭代，代码都会跳过该语句的执行。在原始示例中，相应的`jmp`语句位于循环体的底部，并且在每次循环迭代时都会执行。因此，如果循环体执行多于一次，第二个版本会运行得更快（另一方面，如果`while`循环即使一次也很少执行循环体，那么第一个版本会稍微更高效）。如果你的编译器没有为`while`语句生成最佳代码，考虑使用不同的编译器。正如[第13章](ch13.xhtml#ch13)所讨论的那样，尝试通过使用`if`和`goto`语句在高级语言中编写优化代码会产生难以阅读的意大利面条代码，而且通常情况下，代码中的`goto`语句实际上会损害编译器生成良好输出的能力。
- en: '**NOTE**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When this chapter discusses the repeat..until/do..while loop, you’ll see an
    alternative to the if..goto scheme that will produce more structured code that
    the compiler may be able to handle. Still, if your compiler cannot make a simple
    transformation like this one, chances are the efficiency of the compiled while
    loops is among the least of your problems.*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*当本章讨论repeat..until/do..while循环时，你会看到一个替代方案，它不同于if..goto方案，并且会产生更结构化的代码，编译器可能更容易处理。尽管如此，如果你的编译器无法进行像这样的简单转换，那么编译后的`while`循环的效率可能是你最小的问题之一。*'
- en: Compilers that do a decent job of optimizing `while` loops typically make certain
    assumptions about the loop, the biggest one being that the loop has exactly one
    entry point and one exit point. Many languages provide statements allowing the
    premature exit of a loop (for example, `break`, as discussed in “Restricted Forms
    of the `goto` Statement” on [page 459](ch13.xhtml#page_459)). Of course, many
    languages provide some form of the `goto` statement that will allow you to enter
    or exit the loop at an arbitrary point. However, keep in mind that using such
    statements, while probably legal, may severely affect the compiler’s ability to
    optimize the code. So use them with caution.^([1](footnotes.xhtml#ch14fn1)) The
    `while` loop is one area where you should let the compiler do its job rather than
    trying to optimize the code yourself (actually, this applies for all loops, as
    compilers generally do a good job of optimizing loops).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 做得不错的编译器通常会对`while`循环进行优化，并假设该循环有一个入口点和一个出口点。许多语言提供语句允许提前退出循环（例如，`break`，如“`goto`语句的受限形式”一节中在[第459页](ch13.xhtml#page_459)讨论过的那样）。当然，许多语言也提供某种形式的`goto`语句，允许你在任意点进入或退出循环。然而，记住，尽管使用这样的语句可能是合法的，但它们可能会严重影响编译器优化代码的能力。所以要小心使用它们。^([1](footnotes.xhtml#ch14fn1))
    `while`循环是一个你应该让编译器处理优化，而不是自己试图优化代码的地方（实际上，这适用于所有循环，因为编译器通常在优化循环时做得很好）。
- en: '**14.1.1 Forcing Complete Boolean Evaluation in a while Loop**'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**14.1.1 强制在 `while` 循环中完全布尔求值**'
- en: The execution of a `while` statement depends upon the semantics of Boolean expression
    evaluation. As with the `if` statement, sometimes the correct execution of a `while`
    loop depends upon whether the Boolean expression uses complete evaluation or short-circuit
    evaluation. This section describes ways to force a `while` loop to use full Boolean
    evaluation, and the following section will demonstrate ways to force short-circuit
    evaluation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`语句的执行依赖于布尔表达式求值的语义。与`if`语句类似，有时`while`循环的正确执行取决于布尔表达式是否使用完全求值或短路求值。本节介绍了如何强制`while`循环使用完全布尔求值，下一节将展示如何强制短路求值。'
- en: At first blush, you might guess that forcing complete Boolean evaluation in
    a `while` loop is done the same way as in an `if` statement. However, if you look
    back at the solutions given for the `if` statement (see “Forcing Complete Boolean
    Evaluation in an `if` Statement” on [page 465](ch13.xhtml#page_465)), you’ll realize
    that the approaches we used for the `if` statement (nesting `if`s and temporary
    calculations) won’t work for a `while` statement. We need a different approach.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，你可能会猜测在`while`循环中强制完全布尔求值的方法与在`if`语句中一样。然而，如果你回顾一下针对`if`语句给出的解决方案（请参见[第465页](ch13.xhtml#page_465)的“强制在`if`语句中进行完全布尔求值”），你会意识到我们在`if`语句中使用的方法（嵌套`if`和临时计算）对于`while`语句是行不通的。我们需要一种不同的方法。
- en: '**14.1.1.1 Using Functions the Easy but Inefficient Way**'
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**14.1.1.1 以简单但低效的方式使用函数**'
- en: 'One easy way to force complete Boolean evaluation is to write a function that
    computes the result of the Boolean expression and use complete Boolean evaluation
    within that function. The following C code implements this idea:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 强制完全布尔求值的一个简单方法是写一个函数来计算布尔表达式的结果，并在该函数内使用完全布尔求值。以下C代码实现了这个思路：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s the code that GCC (x86) emits for this C code (with a little cleanup
    to remove superfluous lines):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是GCC（x86）为这段C代码生成的代码（经过一些清理，去除了多余的行）：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As the assembly code demonstrates, the problem with this approach is that this
    code must make a function call and return (both of which are slow operations)
    in order to compute the value of the expression. For many expressions, the overhead
    of the call and return is more expensive than the actual computation of the expression’s
    value.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如汇编代码所示，这种方法的问题在于，代码必须进行函数调用和返回（这两者都是较慢的操作），才能计算表达式的值。对于许多表达式来说，调用和返回的开销比实际计算表达式值的成本更高。
- en: '**14.1.1.2 Using Inline Functions**'
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**14.1.1.2 使用内联函数**'
- en: 'The previous approach definitely doesn’t yield the greatest code you could
    obtain, in terms of either space or speed. If your compiler supports inline functions,
    you can produce a much better result by inlining `func()` in this example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前一种方法显然并不是你能够得到的最优代码，无论是在空间还是速度上。如果你的编译器支持内联函数，你可以通过在这个例子中将`func()`内联，从而生成一个更好的结果：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s the conversion to (32-bit) x86 Gas assembly by the GCC compiler:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是GCC编译器将其转换为（32位）x86 Gas汇编的代码：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As this example demonstrates, GCC compiles the function directly into the `while`
    loop’s test, sparing this program the overhead associated with the function call
    and return.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个例子所示，GCC将函数直接编译到`while`循环的测试中，避免了与函数调用和返回相关的开销。
- en: '**14.1.1.3 Using Bitwise Logical Operations**'
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**14.1.1.3 使用按位逻辑运算**'
- en: 'In the C programming language, which supports Boolean operations on bits (also
    known as *bitwise logical operations*), you can use the same trick employed for
    the `if` statement to force complete Boolean evaluation—just use the bitwise operators.
    In the special case where the left and right operands of the `&&` or *||* operators
    are always `0` or `1`, you can use code like the following to force complete Boolean
    evaluation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，支持对位进行布尔操作（也称为*按位逻辑操作*），你可以使用与`if`语句相同的技巧来强制进行完全的布尔求值——只需使用按位运算符。在`&&`或*||*运算符的左右操作数始终为`0`或`1`的特殊情况下，你可以像下面这样写代码，强制进行完全的布尔求值：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here’s the assembly code that Borland C++ generates for this C source code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Borland C++为这段C源代码生成的汇编代码：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see in this 80x86 output, the compiler generates semantically equivalent
    code when using the bitwise logical operators. Just keep in mind that this code
    is valid only if you use `0` and `1` for the Boolean values `false` and `true`,
    respectively.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这段 80x86 输出中看到的，使用位运算逻辑运算符时，编译器生成的是语义等效的代码。只需记住，这段代码只有在你使用`0`和`1`分别表示布尔值`false`和`true`时才有效。
- en: '**14.1.1.4 Using Unstructured Code**'
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**14.1.1.4 使用非结构化代码**'
- en: 'If you don’t have inline function capability or if bitwise logical operators
    aren’t available, you can use unstructured code to force complete Boolean evaluation
    as a last resort. The basic idea is to create an infinite loop and then write
    code to explicitly exit the loop if the condition fails. Generally, you’d use
    a `goto` statement (or a limited form of the `goto` statement like C’s `break`
    or `continue` statements) to control loop termination. Consider the following
    example in C:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有内联函数的能力，或者位运算逻辑运算符不可用，你可以使用非结构化代码强制进行完全的布尔运算，作为最后的手段。基本思路是创建一个无限循环，然后编写代码在条件失败时显式退出循环。通常，你会使用`goto`语句（或类似
    C 的`break`或`continue`语句的有限形式）来控制循环终止。请看下面的 C 语言示例：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By using an infinite loop with an explicit break, we were able to compute the
    two components of the Boolean expression using separate C statements (hence, forcing
    the compiler to execute both subexpressions). Here’s the code that the MSVC++
    compiler produces:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用无限循环并显式地中断，我们能够通过独立的 C 语句计算布尔表达式的两个部分（因此，强制编译器执行两个子表达式）。这是 MSVC++ 编译器生成的代码：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, this program always evaluates both parts of the original Boolean
    expression (that is, you get complete Boolean evaluation).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个程序总是会评估原始布尔表达式的两个部分（也就是说，你得到了完整的布尔运算）。
- en: You should be careful using unstructured code in this way. Not only is the result
    harder to read, but it’s difficult to coerce the compiler into producing the code
    you want. Furthermore, code sequences that produce good code on one compiler won’t
    produce comparable code on other compilers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你在以这种方式使用非结构化代码时应该小心。不仅结果更难以阅读，而且很难迫使编译器生成你想要的代码。此外，在一个编译器上生成的有效代码序列，在其他编译器上可能无法生成相同的代码。
- en: If your particular language doesn’t support a statement like `break`, you can
    always use a `goto` statement to break out of the loop and achieve the same result.
    Although injecting `goto`s into your code isn’t a great idea, in some cases it’s
    your only option.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的编程语言不支持像`break`这样的语句，你可以始终使用`goto`语句跳出循环并实现相同的效果。尽管将`goto`语句注入到代码中并不是一个好主意，但在某些情况下，它是你唯一的选择。
- en: '**14.1.2 Forcing Short-Circuit Boolean Evaluation in a while Loop**'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**14.1.2 强制在 while 循环中进行短路布尔运算**'
- en: Sometimes you need to guarantee short-circuit evaluation of the Boolean expression
    in a `while` statement even if the language (such as BASIC or Pascal) doesn’t
    implement that scheme. For the `if` statement, you can force short-circuit evaluation
    by rearranging the way you compute the loop-control expression in your program.
    Unlike in the `if` statement, you can’t use nested `while` statements or preface
    your `while` loop with other statements to force short-circuit evaluation, but
    it’s still possible to do in most programming languages.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，即使语言（如 BASIC 或 Pascal）没有实现该方案，你也需要确保在`while`语句中强制进行短路运算。对于`if`语句，你可以通过重新安排程序中计算循环控制表达式的方式来强制进行短路运算。与`if`语句不同的是，你不能使用嵌套的`while`语句或在`while`循环前加上其他语句来强制短路运算，但在大多数编程语言中，依然可以做到这一点。
- en: 'Consider the following C code fragment:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下 C 代码片段：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code could fail if C didn’t guarantee short-circuit evaluation of the Boolean
    expression.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 C 没有保证布尔表达式的短路运算，这段代码可能会失败。
- en: As with forcing complete Boolean evaluation, the easiest approach in a language
    like Pascal is to write a function that computes and returns the Boolean result
    using short-circuit Boolean evaluation. However, this scheme is relatively slow
    because of the high overhead of a function call. Consider the following Pascal
    example:^([2](footnotes.xhtml#ch14fn2))
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 和强制进行完全布尔运算一样，在像 Pascal 这样的语言中，最简单的方法是编写一个函数，使用短路布尔运算计算并返回布尔结果。然而，由于函数调用的高开销，这种方法相对较慢。请看下面的
    Pascal 示例：^([2](footnotes.xhtml#ch14fn2))
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And now consider this 80x86 assembly code produced by Borland’s Delphi compiler
    (and disassembled with IDAPro):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一下这个由 Borland 的 Delphi 编译器生成的 80x86 汇编代码（并通过 IDAPro 反汇编）：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `sub_408570` procedure contains the function that will compute the short-circuit
    Boolean evaluation of an expression similar to the one appearing in the earlier
    C code. As you can see, the code that dereferences `thePtr` never executes if
    `thePtr` contains NIL (`0`).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`sub_408570`过程包含计算类似于早期C代码中表达式的短路布尔求值的函数。正如你所看到的，如果`thePtr`包含NIL（`0`），则解引用`thePtr`的代码永远不会执行。'
- en: 'If a function call is out of the question, then about the only reasonable solution
    is to use an unstructured approach. The following is a Pascal version of the `while`
    loop in the earlier C code that forces short-circuit Boolean evaluation:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数调用不可行，那么唯一合理的解决方案就是使用非结构化的方法。以下是早期C代码中`while`循环的Pascal版本，强制短路布尔求值：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Again, producing unstructured code, like the code in this example, is something
    you should do only as a last resort. But if the language (or compiler) you’re
    using doesn’t guarantee short-circuit evaluation and you need those semantics,
    unstructured code or inefficient code (using a function call) might be the only
    solution.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，像本例中的非结构化代码，应该仅作为最后的手段来编写。但是，如果你使用的语言（或编译器）不保证短路求值，并且你需要这些语义，那么非结构化代码或低效代码（使用函数调用）可能是唯一的解决方案。
- en: '**14.2 The repeat..until (do..until/do..while) Loop**'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**14.2 repeat..until（do..until/do..while）循环**'
- en: 'Another common loop that appears in most modern programming languages is `repeat..until`.
    This loop tests for its terminating condition at the bottom of the loop. This
    means that the loop’s body always executes at least once, even if the Boolean
    control expression evaluates to `false` on the first iteration of the loop. Although
    the `repeat..until` loop is a little less broadly applicable than the `while`
    loop, and you won’t use it anywhere near as often, there are many situations where
    the `repeat..until` loop is the best choice of control structure for the job.
    Perhaps the classic example is reading input from the user until the user inputs
    a certain value. The following Pascal code fragment is very typical:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在大多数现代编程语言中常见的循环是`repeat..until`。这个循环在循环底部测试终止条件。这意味着循环体至少会执行一次，即使布尔控制表达式在循环的第一次迭代中评估为`false`。尽管`repeat..until`循环的适用范围比`while`循环小，你也不会像使用`while`循环那样频繁使用它，但在很多情况下，`repeat..until`循环是最适合的控制结构。经典的例子可能是读取用户输入，直到用户输入某个特定值。以下是一个典型的Pascal代码片段：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This loop always executes the body once. This, of course, is necessary because
    you must execute the loop’s body to read the user-entered value, which the program
    checks to determine when loop execution is complete.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环总是执行一次循环体。当然，这是必要的，因为你必须执行循环体来读取用户输入的值，程序会检查这个值来判断循环何时结束。
- en: 'The `repeat..until` loop terminates when its Boolean control expression evaluates
    to `true` (rather than `false`, as for the `while` loop), as implied by the word
    *until*. Note, however, that this is a minor syntactical issue; the C/C++/Java/Swift
    languages (and many languages that share a C heritage) provide a `do..while` loop
    that repeats execution of the loop’s body as long as the loop condition evaluates
    to `true`. From an efficiency point of view, there’s absolutely no difference
    between these two loops, and you can easily convert one loop termination condition
    to the other by using your language’s logical NOT operator. The following examples
    demonstrate the syntax of the Pascal, HLA, and C/C++ `repeat..until` and `do..while`
    loops. Here’s the Pascal `repeat..until` loop example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat..until`循环在布尔控制表达式评估为`true`时终止（而不是`false`，像`while`循环那样），正如词语*until*所暗示的那样。然而，值得注意的是，这是一个小的语法问题；C/C++/Java/Swift语言（以及许多继承了C语言的语言）提供了`do..while`循环，它会在循环条件评估为`true`时重复执行循环体。从效率的角度来看，这两种循环完全没有区别，你可以通过使用语言的逻辑非操作符轻松将一种循环终止条件转换为另一种。以下示例演示了Pascal、HLA和C/C++中的`repeat..until`和`do..while`循环的语法。以下是Pascal的`repeat..until`循环示例：'
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now here’s the C/C++ `do..while` version of the same loop:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里是相同循环的C/C++ `do..while`版本：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And here is the HLA `repeat..until` loop:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是HLA的`repeat..until`循环：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Converting the `repeat..until` (or `do..while`) loop into assembly language
    is relatively easy and straightforward. All the compiler needs to do is substitute
    code for the Boolean loop control expression and branch back to the beginning
    of the loop’s body if the expression evaluates affirmative (`false` for `repeat..until`
    or `true` for `do..while`). Here’s the straightforward pure assembly implementation
    of the earlier HLA `repeat..until` loop (compilers for C/C++ and Pascal would
    generate nearly identical code for the other examples):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将`repeat..until`（或`do..while`）循环转换为汇编语言相对简单直接。编译器只需要为布尔循环控制表达式替换代码，并在表达式为真时（对于`repeat..until`是`false`，对于`do..while`是`true`）跳转回循环体的开头。下面是早期HLA
    `repeat..until`循环的直接纯汇编实现（C/C++和Pascal编译器对于其他示例会生成几乎相同的代码）：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see, the code that a typical compiler generates for a `repeat..until`
    (or `do..while`) loop is usually a bit more efficient than the code you’ll get
    for a regular `while` loop. Thus, you should consider using the `repeat..until`/`do..while`
    form if semantically possible. In many programs, the Boolean control expression
    always evaluates to `true` on the first iteration of some loop constructs. For
    example, it’s not that uncommon to find a loop like the following in an application:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，典型编译器为`repeat..until`（或`do..while`）循环生成的代码通常比常规的`while`循环生成的代码更高效。因此，如果语义上可行，你应该考虑使用`repeat..until`/`do..while`形式。在许多程序中，布尔控制表达式在某些循环构造的第一次迭代时总是评估为`true`。例如，在应用程序中，遇到如下循环并不罕见：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This `while` loop is easily converted to a `do..while` loop as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`while`循环可以轻松地转换为如下的`do..while`循环：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This conversion is possible because we know that `i`’s initial value (`0`) is
    less than `100`, so the loop’s body always executes at least once.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换之所以可行，是因为我们知道`i`的初始值（`0`）小于`100`，因此循环体总是至少执行一次。
- en: As you’ve seen, you can help the compiler generate better code by using the
    more appropriate `repeat..until`/`do..while` loop rather than a regular `while`
    loop. Keep in mind, however, that the efficiency gain is small, so make sure you’re
    not sacrificing readability or maintainability by doing so. Always use the most
    logically appropriate loop construct. If the body of the loop always executes
    at least once, you should use a `repeat..until`/`do..while` loop, even if a `while`
    loop would work equally well.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通过使用更合适的`repeat..until`/`do..while`循环，而非常规的`while`循环，你可以帮助编译器生成更好的代码。然而，请记住，效率的提升很小，因此确保你不会因此牺牲可读性或可维护性。始终使用最合乎逻辑的循环结构。如果循环体总是至少执行一次，你应该使用`repeat..until`/`do..while`循环，即使`while`循环也同样有效。
- en: '**14.2.1 Forcing Complete Boolean Evaluation in a repeat..until Loop**'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**14.2.1 强制`repeat..until`循环中的完全布尔求值**'
- en: 'Because the test for loop termination occurs at the bottom of the loop on a
    `repeat..until` (or `do..while`) loop, you force complete Boolean evaluation for
    it, similarly to how you do for an `if` statement. Consider the following C/C++
    code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在`repeat..until`（或`do..while`）循环中，测试循环终止发生在循环的底部，因此你可以像在`if`语句中一样强制完全布尔求值。考虑以下C/C++代码：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here’s the GCC output for the PowerPC (using short-circuit evaluation, which
    is standard for C) for the `do..while` loop:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是GCC为PowerPC（使用短路求值，这是C的标准）生成的`do..while`循环的输出：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This program skips over the test for `b > g(y)` to label `L3` if the expression
    `a < f(x)` is `false` (that is, if `a >= f(x)`).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式`a < f(x)`为`false`（即`a >= f(x)`），这个程序会跳过`b > g(y)`的测试，直接跳转到标签`L3`。
- en: 'To force complete Boolean evaluation in this situation, our C source code needs
    to compute the subcomponents of the Boolean expression just prior to the `while`
    clause (keeping the results of the subexpressions in temporary variables) and
    then test only the results in the `while` clause:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制完全布尔求值，我们的C源代码需要在`while`子句之前计算布尔表达式的子组件（将子表达式的结果保存在临时变量中），然后仅测试`while`子句中的结果：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here’s the conversion to PowerPC code by GCC:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是GCC将代码转换为PowerPC的结果：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Of course, the actual Boolean expression (`temp1 && temp2`) still uses short-circuit
    evaluation, but only for the temporary variables created. The loop computes both
    of the original subexpressions regardless of the result of the first one.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，实际的布尔表达式（`temp1 && temp2`）仍然使用短路求值，但仅针对所创建的临时变量。无论第一个子表达式的结果如何，循环都会计算两个原始子表达式。
- en: '**14.2.2 Forcing Short-Circuit Boolean Evaluation in a repeat..until Loop**'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**14.2.2 强制`repeat..until`循环中的短路布尔求值**'
- en: 'If your programming language provides a facility to break out of a `repeat..until`
    loop, such as C’s `break` statement, then forcing short-circuit evaluation is
    fairly easy. Consider the C `do..while` loop from the previous section that forces
    complete Boolean evaluation:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的编程语言提供了一种能够跳出`repeat..until`循环的功能，例如C语言的`break`语句，那么强制短路运算就非常简单。考虑前一部分中强制进行完全布尔运算的C语言`do..while`循环：
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following shows one way to convert this code so that it evaluates the termination
    expression using short-circuit Boolean evaluation:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了一种转换代码的方式，使其使用短路布尔运算来评估终止表达式：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here’s the code that GCC emits for the PowerPC for the `do..while` loop in
    this code sequence:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是GCC为PowerPC生成的`do..while`循环代码：
- en: '[PRE29]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If `a` is greater than or equal to the value that `f(x)` returns, this code
    immediately breaks out of the loop (at label `L3`) without testing to see if `b`
    is greater than the value `g(y)` returns. Hence, this code simulates short-circuit
    Boolean evaluation of the C/C++ expression `a < f(x) && b > g(y)`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`a`大于或等于`f(x)`返回的值，则该代码会立即跳出循环（在标签`L3`处），而不需要测试`b`是否大于`g(y)`返回的值。因此，这段代码模拟了C/C++表达式`a
    < f(x) && b > g(y)`的短路布尔运算。
- en: 'If the compiler you’re using doesn’t support a statement equivalent to C/C++’s
    `break` statement, you’ll have to use slightly more sophisticated logic. Here’s
    one way to do that:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的编译器不支持类似于C/C++的`break`语句的语句，你将需要使用稍微复杂一点的逻辑。这里有一种方法：
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And here’s the PowerPC code that GCC produces for this example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是GCC为此示例生成的PowerPC代码：
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Although these examples have been using the conjunction operation (logical
    AND), using the disjunction operator (logical OR) is just as easy. To close off
    this section, consider this Pascal sequence and its conversion:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些示例使用了与运算符（逻辑与），但使用或运算符（逻辑或）同样简单。为了结束这一部分，考虑这个Pascal序列及其转换：
- en: '[PRE32]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here’s the conversion to force complete Boolean evaluation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是强制进行完全布尔运算的转换：
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here’s the code that Borland’s Delphi produces for the two loops (assuming
    you select *complete Boolean evaluation* in the compiler’s options):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是Borland Delphi为这两个循环生成的代码（假设在编译器选项中选择了*完全布尔运算*）：
- en: '[PRE34]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The code that the Delphi compiler generates for this forced short-circuit evaluation
    is nowhere near as good as the code it would generate if you allowed it to do
    this job for you. Here’s the Delphi code with the *complete Boolean evaluation*
    option unselected (that is, instructing Delphi to use short-circuit evaluation):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Delphi编译器为这种强制短路运算生成的代码，远不如它为你做这项工作的代码效果好。下面是未选中*完全布尔运算*选项的Delphi代码（即指示Delphi使用短路运算）：
- en: '[PRE35]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: While this trick is useful for forcing short-circuit evaluation when the compiler
    does not support it, this latter Delphi example reiterates that you should use
    the compiler’s facilities if at all possible—you’ll generally get better machine
    code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种技巧在编译器不支持时很有用，可以强制短路运算，但这个Delphi示例再次强调，如果可能的话，应该使用编译器提供的功能——通常这样会生成更好的机器代码。
- en: '**14.3 The forever..endfor Loop**'
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**14.3 forever..endfor 循环**'
- en: The `while` loop tests for loop termination at the beginning (top) of the loop.
    The `repeat..until` loop tests for loop termination at the end (bottom) of the
    loop. The only place left to test for loop termination is somewhere in the middle
    of the loop’s body. The `forever..endfor` loop, along with some special loop termination
    statements, handles this case.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环在循环开始（顶部）时测试是否结束。`repeat..until`循环在循环结束（底部）时测试是否结束。唯一可以在循环体的中间测试循环终止的位置是循环体的某个位置。`forever..endfor`循环以及一些特殊的循环终止语句处理这种情况。'
- en: Most modern programming languages provide a `while` loop and a `repeat..until`
    loop (or their equivalents). Interestingly enough, only a few modern imperative
    programming languages provide an explicit `forever..endfor` loop.^([3](footnotes.xhtml#ch14fn3))
    This is especially surprising because the `forever..endfor` loop (along with a
    loop termination test) is actually the most general of the three forms. You can
    easily synthesize a `while` loop or a `repeat..until` loop from a single `forever..endfor`
    loop.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代编程语言提供了`while`循环和`repeat..until`循环（或它们的等效形式）。有趣的是，只有少数现代命令式编程语言提供了显式的`forever..endfor`循环。^([3](footnotes.xhtml#ch14fn3))
    这尤其令人惊讶，因为`forever..endfor`循环（以及一个循环终止测试）实际上是三种形式中最通用的一种。你可以轻松地从单个`forever..endfor`循环合成`while`循环或`repeat..until`循环。
- en: 'Fortunately, it’s easy to create a simple `forever..endfor` loop in any language
    that provides a `while` loop or a `repeat..until`/`do..while` loop. All you need
    do is supply a Boolean control expression that always evaluates to `false` for
    `repeat..until` or `true` for `do..while`. In Pascal, for example, you could use
    code such as the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在任何提供`while`循环或`repeat..until`/`do..while`循环的语言中，创建一个简单的`forever..endfor`循环都很容易。你只需要提供一个布尔控制表达式，对于`repeat..until`，它始终评估为`false`，对于`do..while`，它始终评估为`true`。例如，在Pascal中，你可以使用如下代码：
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The big problem with standard Pascal is that it doesn’t provide a mechanism
    (other than a generic `goto` statement) for explicitly breaking out of a loop.
    Fortunately, many modern Pascals, like Delphi and Free Pascal, provide a statement
    like `break` to immediately exit the current loop.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 标准Pascal的一个大问题是，它没有提供一种机制（除了通用的`goto`语句）来显式地跳出循环。幸运的是，许多现代Pascal语言，如Delphi和Free
    Pascal，提供了类似`break`的语句，可以立即退出当前的循环。
- en: 'Although the C/C++ language does not provide an explicit statement that creates
    a `forever` loop, the syntactically bizarre `for(;;)` statement has served this
    purpose since the very first C compiler was written. Therefore, C/C++ programmers
    can create a `forever..endfor` loop as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管C/C++语言没有提供显式的语句来创建`forever`循环，但语法上奇怪的`for(;;)`语句自从第一个C编译器编写以来，就一直用于此目的。因此，C/C++程序员可以按如下方式创建`forever..endfor`循环：
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'C/C++ programmers can use C’s `break` statement (along with an `if` statement)
    to place a loop termination condition in the middle of a loop, like so:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++程序员可以使用C语言的`break`语句（与`if`语句一起）在循环中间设置一个循环终止条件，如下所示：
- en: '[PRE38]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The HLA language provides an explicit (high-level) `forever..endfor` statement
    (along with a `break` and a `breakif` statement) that lets you terminate the loop
    somewhere in the middle. This HLA `forever..endfor` loop tests for loop termination
    in the middle of the loop:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: HLA语言提供了一个显式的（高级）`forever..endfor`语句（以及`break`和`breakif`语句），允许你在循环中途终止循环。这个HLA的`forever..endfor`循环在循环中间测试是否终止循环：
- en: '[PRE39]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Converting a `forever..endfor` loop into pure assembly language is trivial—all
    you need is a single `jmp` instruction that can transfer control from the bottom
    of the loop back to the top of the loop. The implementation of the `break` statement
    is just as simple: it’s just a jump (or conditional jump) to the first statement
    following the loop. The following two code fragments demonstrate an HLA `forever..endfor`
    loop (along with a `breakif`) and the corresponding “pure” assembly code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将`forever..endfor`循环转换为纯汇编语言是很简单的——你只需要一个`jmp`指令，它可以将控制从循环底部转移回循环顶部。`break`语句的实现也同样简单：它只是一个跳转（或条件跳转）到循环之后的第一条语句。以下两个代码片段展示了一个HLA的`forever..endfor`循环（以及一个`breakif`）和相应的“纯”汇编代码：
- en: '[PRE40]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Of course, you can also rotate this code to create a slightly more efficient
    version:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以调整这段代码，创建一个稍微更高效的版本：
- en: '[PRE41]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If the language you’re using doesn’t support a `forever..endfor` loop, any decent
    compiler will convert a `while(true)` statement into a single jump instruction.
    If your compiler doesn’t do so, then it does a poor job of optimization, and any
    attempts to manually optimize the code are a lost cause. For reasons you’ll soon
    see, you shouldn’t try to create the `forever..endfor` loop using a `goto` statement.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的语言不支持`forever..endfor`循环，任何一款不错的编译器都会将`while(true)`语句转换为一个单一的跳转指令。如果你的编译器没有这么做，那它在优化方面做得很差，任何尝试手动优化代码的努力都是徒劳的。出于你很快就会明白的原因，你不应该尝试使用`goto`语句来创建`forever..endfor`循环。
- en: '**14.3.1 Forcing Complete Boolean Evaluation in a forever Loop**'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**14.3.1 强制在`forever`循环中进行完整的布尔评估**'
- en: Because you exit from a `forever` loop using an `if` statement, the techniques
    for forcing complete Boolean evaluation when exiting a `forever` loop are the
    same as for an `if` statement. See “Forcing Complete Boolean Evaluation in an
    `if` Statement” on [page 465](ch13.xhtml#page_465) for details.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你是通过`if`语句退出`forever`循环的，所以强制在退出`forever`循环时进行完整的布尔评估的技巧与在`if`语句中相同。有关详细信息，请参见[第465页](ch13.xhtml#page_465)的《强制在`if`语句中进行完整布尔评估》。
- en: '**14.3.2 Forcing Short-Circuit Boolean Evaluation in a forever Loop**'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**14.3.2 强制在`forever`循环中进行短路布尔评估**'
- en: Likewise, because you exit from a `forever` loop using an `if` statement, the
    techniques for forcing short-circuit Boolean evaluation when exiting a `forever`
    loop are the same as for a `repeat..until` statement. See “Forcing Short-Circuit
    Boolean Evaluation in a `repeat..until` Loop” on [page 524](ch14.xhtml#page_524)
    for details.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，由于你是通过 `if` 语句退出 `forever` 循环，因此在退出 `forever` 循环时强制短路布尔运算的技巧与在 `repeat..until`
    语句中的技巧相同。详细内容请参见 [第524页](ch14.xhtml#page_524) 中的“在 `repeat..until` 循环中强制短路布尔运算”。
- en: '**14.4 The Definite Loop (for Loops)**'
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**14.4 确定性循环（for 循环）**'
- en: 'The `forever..endfor` loop is an *infinite* loop (assuming you don’t break
    out of it via a `break` statement). The `while` and `repeat..until` loops are
    examples of *indefinite* loops because, in general, the program cannot determine
    how many iterations they will execute when it first encounters them. For a *definite*
    loop, on the other hand, the program can determine exactly how many iterations
    the loop will repeat prior to executing the first statement of the loop’s body.
    A good example of a definite loop in a traditional HLL is Pascal’s `for` loop,
    which uses the following syntax:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`forever..endfor` 循环是一个 *无限* 循环（假设你没有通过 `break` 语句跳出它）。`while` 和 `repeat..until`
    循环是 *不确定* 循环的例子，因为通常情况下，程序无法在首次遇到它们时确定它们将执行多少次迭代。另一方面，对于 *确定* 循环，程序可以在执行循环体的第一条语句之前准确地确定循环将执行多少次迭代。传统高级语言中的一个确定性循环的好例子是
    Pascal 的 `for` 循环，它使用以下语法：'
- en: '[PRE42]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: which iterates over the range `expr1..expr2` if expr1 is less than or equal
    to expr2, or
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `expr1` 小于或等于 `expr2` 时，它会遍历 `expr1..expr2` 范围，或者
- en: '[PRE43]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'which iterates over the range `expr1..expr2` if expr1 is greater than or equal
    to expr2. Here’s a typical example of a Pascal `for` loop:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `expr1` 大于或等于 `expr2` 时，它会遍历 `expr1..expr2` 范围。以下是一个典型的 Pascal `for` 循环示例：
- en: '[PRE44]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This loop always executes exactly 10 times; hence, it’s a definite loop. However,
    this doesn’t imply that a compiler has to be able to determine the number of loop
    iterations at compile time. Definite loops also allow the use of expressions that
    force the program to determine the number of iterations at runtime. For example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环总是精确执行 10 次；因此，它是一个确定性循环。然而，这并不意味着编译器必须能够在编译时确定循环迭代次数。确定性循环也允许使用表达式，强制程序在运行时确定迭代次数。例如：
- en: '[PRE45]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The Pascal compiler cannot determine the number of iterations this loop will
    execute. In fact, because the number of iterations is dependent upon user input,
    it could vary each time this loop executes in a single execution of the enclosing
    program. However, the program can determine exactly how many iterations the loop
    will execute, indicated by the value in the `cnt` variable, whenever it encounters
    this loop. Note that Pascal (like most languages that support definite loops)
    expressly forbids code such as the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal 编译器无法确定此循环将执行的迭代次数。事实上，由于迭代次数依赖于用户输入，它在一次程序执行中每次执行时都可能有所不同。然而，每当程序遇到此循环时，它可以确定循环将执行多少次迭代，这由
    `cnt` 变量中的值指示。请注意，Pascal（像大多数支持确定性循环的语言一样）明确禁止如下代码：
- en: '[PRE46]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You are not allowed to change the value of the loop control variable during
    the execution of the loop’s body. In this example, should you try to change the
    `for` loop’s control variable, a high-quality Pascal compiler will detect that
    attempt and report an error. Also, a definite loop computes the starting and ending
    values only once. Therefore, if the `for` loop modifies a variable that appears
    as the second expression, it does not reevaluate the expression on each iteration
    of the loop. For example, if the body of the `for` loop in the previous example
    modifies the value of `j`, this will not affect the number of loop iterations.^([4](footnotes.xhtml#ch14fn4))
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环体执行过程中不允许更改循环控制变量的值。在这个例子中，如果你试图更改 `for` 循环的控制变量，一个高质量的 Pascal 编译器会检测到这个尝试并报告错误。此外，确定性循环只计算起始值和结束值一次。因此，如果
    `for` 循环的体内修改了作为第二个表达式的变量，它不会在每次循环迭代时重新计算该表达式。例如，如果前面示例中的 `for` 循环体修改了 `j` 的值，这不会影响循环迭代次数。^([4](footnotes.xhtml#ch14fn4))
- en: Definite loops have certain special properties that allow a (good) compiler
    to generate better machine code. In particular, because the compiler can determine
    how many iterations the loop will execute prior to executing the first statement
    of the loop’s body, the compiler can often dispense with complex tests for loop
    termination and simply decrement a register down to `0` to control the number
    of loop iterations. The compiler can also use induction to optimize access to
    the loop control variable in a definite loop (see the description of induction
    in “Optimization of Arithmetic Statements” on [page 397](ch12.xhtml#page_397)).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性循环具有某些特殊属性，允许（好的）编译器生成更好的机器代码。特别是，因为编译器可以在执行循环体的第一条语句之前确定循环将执行多少次，它通常可以不需要复杂的循环终止测试，而直接将一个寄存器递减至`0`来控制循环的迭代次数。编译器还可以使用归纳法优化在确定性循环中对循环控制变量的访问（有关归纳法的描述请参见[第397页](ch12.xhtml#page_397)的“算术语句优化”部分）。
- en: 'C/C++/Java users should note that the `for` loop in these languages is not
    a true definite loop; rather, it is a special case of the indefinite `while` loop.
    Most good C/C++ compilers will attempt to determine if a `for` loop is a definite
    loop and, if so, they’ll generate decent code. You can help your compiler by following
    these guidelines:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++/Java用户应注意，这些语言中的`for`循环并不是一个真正的确定性循环；它只是一个不确定的`while`循环的特例。大多数优秀的C/C++编译器会尝试确定一个`for`循环是否是确定性循环，如果是，它们会生成高效的代码。你可以通过遵循以下指导原则来帮助编译器：
- en: Your C/C++ `for` loops should use the same semantics as the definite (`for`)
    loops in languages such as Pascal. That is, the `for` loop should initialize a
    single loop control variable, test for loop termination when that value is less
    than or greater than some ending value, and increment or decrement the loop control
    variable by 1.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的C/C++ `for`循环应使用与像Pascal这样的语言中的确定性(`for`)循环相同的语义。也就是说，`for`循环应初始化一个单一的循环控制变量，当该值小于或大于某个结束值时进行终止条件测试，并且将循环控制变量增减1。
- en: Your C/C++ `for` loops should not modify the value of the loop control variable
    within the loop.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的C/C++ `for`循环不应在循环内修改循环控制变量的值。
- en: The test for loop termination remains static over the execution of the loop’s
    body. That is, the loop body should not be able to change the termination condition
    (which, by definition, would make the loop an indefinite loop). For example, if
    the loop termination condition is `i < j`, the loop body should not modify the
    value of `i` or `j`.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环终止条件的测试在循环体执行过程中保持静态。也就是说，循环体不应能够改变终止条件（这将使得循环变为不确定循环）。例如，如果循环终止条件是`i < j`，则循环体不应修改`i`或`j`的值。
- en: The loop body does not pass the loop control variable or any variable appearing
    in the loop termination condition by reference to a function if that function
    modifies the actual parameter.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环体不会通过引用将循环控制变量或出现在循环终止条件中的任何变量传递给函数，如果该函数会修改实际参数。
- en: '**14.5 For More Information**'
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**14.5 更多信息**'
- en: “For More Information” on [page 501](ch13.xhtml#page_501) applies to this chapter
    as well. Please see that section for more details.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第501页](ch13.xhtml#page_501)的“更多信息”部分同样适用于本章节。请参阅该部分以获取更多详细信息。
