- en: '14'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '14'
- en: 'FLAIM: AN AUTOTOOLS EXAMPLE'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: FLAIM：一个AUTOTOOLS示例
- en: '*Uncle Abner said . . . a person that started in to carry a cat home by the
    tail was gitting knowledge that was always going to be useful to him*.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*阿布内尔叔叔说……一个人开始提着猫的尾巴回家，是在获得一种永远有用的知识。*'
- en: —Mark Twain, Tom Sawyer Abroad
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —马克·吐温，《汤姆·索亚在海外》
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: So far in this book, I’ve taken you on a whirlwind tour of the main features
    of Autoconf, Automake, and Libtool, as well as other tools that work well with
    the Autotools. I’ve done my best to explain them in a manner that is not only
    simple to digest but also easy to retain— especially if you’ve had the time and
    inclination to follow along with my examples on your own. I’ve always believed
    that no form of learning comes anywhere close to the learning that happens while
    doing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我已经带你快速浏览了Autoconf、Automake和Libtool的主要特性，以及与Autotools配合得好的其他工具。我尽力以一种既简洁易懂又便于记忆的方式进行解释——特别是如果你有时间和兴趣跟随我提供的示例进行实践。我始终认为，没有什么学习方式能比在实践中获得的学习更有效。
- en: In this chapter and the next, we’ll continue learning about the Auto­tools by
    studying the process I used to convert an existing, real-world, open source project
    from a complex handcoded makefile to a complete GNU Autotools build system. The
    examples I provide in these chapters illustrate the decisions I had to make during
    the conversion process as well as some concrete uses of Autotools features, including
    a few that I haven’t yet presented in previous chapters. These two chapters will
    round out our study of the Autotools by presenting real solutions to real problems.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章及下一章中，我们将继续通过研究我用来将一个现有的、真实的开源项目从一个复杂的手写makefile转换为一个完整的GNU Autotools构建系统的过程，来学习更多关于Autotools的内容。我在这些章节中提供的示例说明了在转换过程中我做出的决策以及一些Autotools特性的具体应用，包括一些我在之前的章节中尚未展示的特性。这两章将通过展示解决实际问题的真实方案，完成我们对Autotools的学习。
- en: The project I chose to convert is called *FLAIM*, which stands for *FLexible
    Adaptable Information Management*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择转换的项目叫做*FLAIM*，它代表着*灵活适应性信息管理*。
- en: What Is FLAIM?
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是FLAIM？
- en: FLAIM is a highly scalable database-management library written in C++ and built
    on its own thin portability layer called the FLAIM toolkit. Some readers may recognize
    FLAIM as the database used by both Novell^([1](footnote.xhtml#ch14fn1)) eDirectory
    and the Novell GroupWise server. FLAIM originated at WordPerfect in the late 1980s,
    and it became part of Novell’s software portfolio during the Novell/WordPerfect
    merger in 1994\. Novell eDirectory used a spin-off of a then-late version of FLAIM
    to manage directory information bases that contain over a billion objects, and
    GroupWise used a much earlier spin-off to manage various server-side databases.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: FLAIM是一个高可扩展的数据库管理库，使用C++编写，并建立在名为FLAIM工具包的自身轻量级可移植性层之上。有些读者可能会认识到FLAIM是Novell^([1](footnote.xhtml#ch14fn1))
    eDirectory和Novell GroupWise服务器使用的数据库。FLAIM起源于1980年代末的WordPerfect，并在1994年Novell和WordPerfect合并时成为Novell软件组合的一部分。Novell
    eDirectory使用FLAIM的一个衍生版本来管理包含超过十亿个对象的目录信息库，GroupWise则使用一个更早的衍生版本来管理各种服务器端数据库。
- en: Novell made the FLAIM source code available as an open source project licensed
    under the GNU Lesser General Public License (LGPL) version 2^([2](footnote.xhtml#ch14fn2))
    in 2006\. The FLAIM project is currently hosted by [SourceForge.net](http://SourceForge.net),
    and it is the result of 25 years of development and hardening in various WordPerfect
    and Novell products and projects.^([3](footnote.xhtml#ch14fn3))
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Novell在2006年将FLAIM源代码作为开源项目发布，并采用GNU较宽松公共许可证（LGPL）版本2^([2](footnote.xhtml#ch14fn2))。FLAIM项目目前托管在[SourceForge.net](http://SourceForge.net)上，经过了25年的开发和在各种WordPerfect和Novell产品及项目中的巩固与完善。^([3](footnote.xhtml#ch14fn3))
- en: Why FLAIM?
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么选择FLAIM？
- en: While FLAIM is far from a mainstream OSS project, it has several qualities that
    make it a perfect example for showing how to convert a project to use the Autotools.
    For one, FLAIM is currently built using a handcoded GNU makefile that contains
    over 2,000 lines of complex make script. The FLAIM makefile contains a number
    of GNU Make–specific constructs, and thus you can only process this makefile using
    GNU Make. Individual (but nearly identical) makefiles are used to build the *flaim*,
    *xflaim*, and *flaimsql* database libraries, and the FLAIM toolkit (*ftk*), as
    well as several utility and sample programs on Linux, various flavors of Unix,
    Windows, and NetWare.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 FLAIM 远不是一个主流的开源软件项目，但它具有若干特质，使其成为展示如何将项目转换为使用 Autotools 的完美示例。首先，FLAIM 当前是使用一个手写的
    GNU Makefile 构建的，该 Makefile 包含超过 2000 行复杂的 make 脚本。FLAIM 的 Makefile 包含许多 GNU Make
    特有的构造，因此只能使用 GNU Make 来处理这个 Makefile。多个（但几乎相同的）Makefile 被用来构建 *flaim*、*xflaim*
    和 *flaimsql* 数据库库，以及 FLAIM 工具包（*ftk*），并在 Linux、各种 Unix 版本、Windows 和 NetWare 上构建几个实用程序和示例程序。
- en: The existing FLAIM build system targets several different flavors of Unix, including
    AIX, Solaris, and HP-UX, as well as Apple’s macOS. It also targets multiple compilers
    on these systems. These features make FLAIM ideal for this sample conversion project
    because I can show you how to handle differences in operating systems and toolsets
    in the new *configure.ac* files.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的 FLAIM 构建系统支持多种不同版本的 Unix 操作系统，包括 AIX、Solaris 和 HP-UX，以及 Apple 的 macOS。它还支持这些系统上的多种编译器。这些特性使得
    FLAIM 成为该示例转换项目的理想选择，因为我可以向你展示如何在新的 *configure.ac* 文件中处理操作系统和工具集的差异。
- en: The existing build system also contains rules for many of the standard Automake
    targets, such as distribution tarballs. Additionally, it provides rules for building
    binary installation packages, as well as RPMs for systems that can build and install
    RPM packages. It even provides targets for building Doxygen^([4](footnote.xhtml#ch14fn4))
    description files, which it then uses to build source documentation. I’ll spend
    a few paragraphs showing you how you can add these types of targets to the infrastructure
    provided by Automake.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的构建系统还包含许多标准 Automake 目标的规则，例如分发 tar 包。此外，它还提供了构建二进制安装包的规则，以及为能够构建和安装 RPM
    包的系统提供的 RPM 规则。它甚至提供了构建 Doxygen^([4](footnote.xhtml#ch14fn4)) 描述文件的目标，之后用于生成源代码文档。我将用几段话向你展示如何将这些类型的目标添加到
    Automake 提供的基础设施中。
- en: The FLAIM toolkit is a portability library that third-party projects can incorporate
    and consume independently. We can use the toolkit to demonstrate Autoconf’s ability
    to manage separate subprojects as optional subdirectories within a project. If
    the user already has the FLAIM toolkit installed on their build machine, they
    can use the installed version or, optionally, override it with a local copy. On
    the other hand, if the toolkit is not installed, then the local, subdirectory-based
    copy will be used by default.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: FLAIM 工具包是一个可移植性库，第三方项目可以独立地将其集成并使用。我们可以使用该工具包展示 Autoconf 如何将独立的子项目作为可选子目录管理在一个项目中。如果用户的构建机器上已经安装了
    FLAIM 工具包，他们可以使用已安装的版本，或者选择覆盖为本地副本。另一方面，如果未安装工具包，则默认使用本地子目录版的工具包。
- en: The FLAIM project also provides code to build both Java and C# language bindings,
    so I’ll delve into those esoteric realms a bit. I won’t go into great detail on
    building either Java or C# applications, but I will cover how to write *Makefile.am*
    files that generate both Java and C# programs and language-binding libraries.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: FLAIM 项目还提供了用于构建 Java 和 C# 语言绑定的代码，因此我将稍微探讨这些晦涩的领域。我不会深入讲解如何构建 Java 或 C# 应用程序，但我会介绍如何编写生成
    Java 和 C# 程序及语言绑定库的 *Makefile.am* 文件。
- en: The FLAIM project makes good use of unit tests. These are built as individual
    programs that run without command line options, so I can easily show you how to
    add real-world unit tests to the new FLAIM Autotools build system using Automake’s
    trivial test framework.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: FLAIM 项目很好地利用了单元测试。这些测试作为独立程序构建，可以在没有命令行选项的情况下运行，因此我可以轻松向你展示如何使用 Automake 的简单测试框架将实际的单元测试添加到新的
    FLAIM Autotools 构建系统中。
- en: The FLAIM project and its original build system employ a reasonably modular
    directory layout, making it rather simple to convert to an Autotools modular build
    system. A simple pass of the `diff` utility over the directory tree should suffice.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: FLAIM 项目及其原始构建系统采用了相当模块化的目录布局，使其转换为 Autotools 模块化构建系统变得相当简单。对目录树进行一次简单的 `diff`
    工具比较就足够了。
- en: Logistics
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后勤
- en: When the first edition of this book was published in 2010, FLAIM had just been
    released as an open source project on [SourceForge.net](http://SourceForge.net)
    using Subversion to manage its source code repository. Since that time, the FLAIM
    project has become, more or less, inactive. No one I’m aware of is actively using
    the code base. As I am the only remaining maintainer of the source code, I’ve
    made a GitHub repository for FLAIM specifically for [Chapters 14](ch14.xhtml)
    and [15](ch15.xhtml) of this second edition of this book. You can find this repository
    at the NSP-Autotools area on GitHub under the FLAIM project.^([5](footnote.xhtml#ch14fn5))
    I’ve updated the information in this chapter to be relevant to FLAIM’s storage
    in a git repository.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当本书的第一版在2010年发布时，FLAIM刚刚作为一个开源项目在[SourceForge.net](http://SourceForge.net)上发布，并使用Subversion管理其源代码库。从那时起，FLAIM项目基本上变得不活跃。我所知道的没有人正在积极使用该代码库。由于我是唯一剩下的源代码维护者，我为FLAIM创建了一个GitHub仓库，专门用于本书第二版的[第14章](ch14.xhtml)和[第15章](ch15.xhtml)。您可以在GitHub的FLAIM项目下的NSP-Autotools区域找到这个仓库。^([5](footnote.xhtml#ch14fn5))
    我已经更新了本章中的信息，以便与FLAIM在git仓库中的存储方式相关。
- en: The source code repository for this chapter follows a somewhat different style
    than that for preceding chapters. The original Autotools build system changes
    I made to the FLAIM [SourceForge.net](http://SourceForge.net) project are buried
    beneath, and intermixed with, several dozen unrelated changes. Rather than spend
    hours separating out these changes in an effort to provide you with proper before
    and after snapshots of the FLAIM code base, I simply chose to commit the final
    FLAIM code, with its Autotools build system, to the GitHub project.^([6](footnote.xhtml#ch14fn6))
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码库与前几章的源代码库风格略有不同。我对FLAIM [SourceForge.net](http://SourceForge.net) 项目所做的原始Autotools构建系统更改被埋藏在几十个无关的更改之下，并与之交织在一起。与其花费数小时将这些更改分离开来，以便为您提供FLAIM代码库的前后快照，不如直接选择将最终的FLAIM代码和其Autotools构建系统提交到GitHub项目中。^([6](footnote.xhtml#ch14fn6))
- en: Do not be discouraged about FLAIM’s current activity status—it continues to
    provide a wide variety of opportunities to learn about Autotools build system
    techniques in real-world projects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 不要对FLAIM当前的活动状态感到灰心——它仍然为我们提供了在现实世界项目中学习Autotools构建系统技术的各种机会。
- en: An Initial Look
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初步观察
- en: Let me start by saying that converting FLAIM from GNU makefiles to an Autotools
    build system is not a trivial project. It took me a couple of weeks, and much
    of that time was spent determining exactly what to build and how to do it—in other
    words, analyzing the legacy build system. Another significant portion of my time
    was spent converting aspects that lay on the outer fringes of Autotools functionality.
    For example, I spent *much* more time converting build system rules for building
    C# language bindings than I did converting rules for building the core C++ libraries.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我要说明将FLAIM从GNU makefile转换为Autotools构建系统并不是一个简单的项目。这花费了我几周的时间，其中大部分时间都用来确定具体需要构建什么以及如何构建——换句话说，就是分析遗留的构建系统。我花费的另一大部分时间则是在转换那些位于Autotools功能边缘的方面。例如，我花了*更多*时间来转换用于构建C#语言绑定的构建系统规则，而不是转换用于构建核心C++库的规则。
- en: The first step in this conversion project is to analyze FLAIM’s existing directory
    structure and build system. What components are actually built, and which components
    depend on which others? Can individual components be built, distributed, and consumed
    independently? These types of component-level relationships are important because
    they’ll often determine how you’ll lay out your project directory structure.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个转换项目的第一步是分析FLAIM现有的目录结构和构建系统。哪些组件实际上被构建，哪些组件依赖于其他组件？是否可以单独构建、分发和消费各个组件？这些组件级别的关系非常重要，因为它们通常决定了你如何布局项目的目录结构。
- en: 'The FLAIM project is actually several small projects under one umbrella project
    within its repository. There are three separate and distinct database products:
    *flaim*, *xflaim*, and *flaimsql*. The flaim subproject is the original FLAIM
    database library used by eDirectory and GroupWise. The xflaim project is a hierarchical
    XML database developed for internal projects at Novell; it is optimized for path-oriented,
    node-based access. The flaimsql project is an SQL layer on top of the FLAIM database.
    It was written as a separate library in order to optimize the lower-level FLAIM
    API for SQL access. This project was an experiment that, frankly, isn’t quite
    finished (but it does compile).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: FLAIM 项目实际上是在其代码库中由多个小项目组成的一个大项目。这里有三个独立且不同的数据库产品：*flaim*、*xflaim* 和 *flaimsql*。flaim
    子项目是最初的 FLAIM 数据库库，用于 eDirectory 和 GroupWise。xflaim 项目是为 Novell 内部项目开发的分层 XML
    数据库；它针对基于路径的节点访问进行了优化。flaimsql 项目是 FLAIM 数据库之上的 SQL 层。它被写作一个独立的库，目的是优化 FLAIM 的底层
    API 以支持 SQL 访问。这个项目是一个实验，坦白说，它还没有完全完成（但它可以编译）。
- en: 'The point is that all three of these database libraries are separate and unrelated
    to each other, with no interlibrary dependencies. Since they may easily be used
    independently of one another, they can actually be shipped as individual distributions.
    You could consider each an open source project in its own right. This, then, will
    become one of my primary goals: to allow the FLAIM open source project to be easily
    broken up into smaller open source projects that can be managed independently
    of one another.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于，这三种数据库库彼此独立且无关，没有相互依赖。由于它们可以彼此独立使用，因此实际上可以作为独立的发行版进行发布。你可以将它们看作是各自独立的开源项目。那么，这将成为我的主要目标之一：允许
    FLAIM 开源项目轻松拆分为多个可以独立管理的开源项目。
- en: The FLAIM toolkit is also an independent project. While it’s tailored specifically
    for the FLAIM database libraries, providing just the system service abstractions
    required for a DBMS, it depends on nothing but itself, and thus it may easily
    be used as the basis for portability within other projects without dragging along
    any unnecessary database baggage.^([7](footnote.xhtml#ch14fn7))
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: FLAIM 工具包也是一个独立的项目。尽管它专门为 FLAIM 数据库库量身定制，仅提供数据库管理系统所需的系统服务抽象，但它完全依赖于自身，因此可以轻松地作为其他项目中可移植性的基础，而不带任何不必要的数据库负担。^([7](footnote.xhtml#ch14fn7))
- en: 'The original FLAIM project was laid out in its repository as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 原始 FLAIM 项目在其代码库中的布局如下：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The complete tree is fairly broad and somewhat deep in places, including significant
    utilities, tests, and other such binaries that are built by the legacy build system.
    At some point during the trek down into this hierarchy, I simply had to stop and
    consider whether it was worth converting that additional utility or layer. (If
    I hadn’t done that, this chapter would be twice as long and half as useful.) To
    this end, I’ve decided to convert the following elements:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 整个目录结构相当广泛，并且在某些地方稍显深入，包括由传统构建系统构建的显著实用程序、测试以及其他此类二进制文件。在深入到这个层级结构的过程中，我不得不停下来思考是否值得转换那个额外的实用程序或层。（如果我没有这么做，本章的长度会翻倍，实用性却会减半。）为此，我决定转换以下内容：
- en: The database libraries
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库库
- en: The unit and library interface tests
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元和库接口测试
- en: The utilities and other such high-level programs found in various *util* directories
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种*util*目录中找到的实用程序和其他此类高级程序
- en: The Java and C# language bindings found in the *xflaim* library
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *xflaim* 库中找到的 Java 和 C# 语言绑定
- en: I’ll also convert the C# unit tests, but I won’t go into the Java unit tests,
    because I’m already converting the Java language bindings using Automake’s `JAVA`
    primary. Since Automake provides no help for C#, I have to provide everything
    myself anyway, so I’ll convert the entire C# code base. This will provide an example
    of writing the code for an entirely unsupported Automake product class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我还会转换 C# 单元测试，但不会涉及 Java 单元测试，因为我已经在使用 Automake 的 `JAVA` 主文件转换 Java 语言绑定。由于
    Automake 对 C# 没有支持，我不得不自己提供一切，因此我将转换整个 C# 代码库。这将提供一个编写完全不受支持的 Automake 产品类代码的示例。
- en: Getting Started
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入门
- en: 'As stated earlier, my first true design decision was how to organize the original
    FLAIM project into subprojects. As it turns out, the existing directory layout
    is almost perfect. I’ve created a master *configure.ac* file in the top-level
    *flaim* directory, which is just under the repository root directory. This topmost
    *configure.ac* file acts as a sort of Autoconf control file for each of the four
    lower-level projects: ftk, flaim, flaimsql, and xflaim.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我的第一个真正的设计决策是如何将原始的FLAIM项目组织成子项目。结果表明，现有的目录布局几乎是完美的。我在顶层的*flaim*目录中创建了一个主*configure.ac*文件，该目录就在版本库的根目录下。这个最上层的*configure.ac*文件充当每个四个下级项目（ftk、flaim、flaimsql和xflaim）的Autoconf控制文件。
- en: I’ve managed the database library dependencies on the FLAIM toolkit by treating
    the toolkit as a pure external dependency defined by the `make` variables `FTKINC`
    and `FTKLIB`. I’ve conditionally defined these variables to point to one of a
    few different sources, including installed libraries and even locations given
    in user-specified configuration script options.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过将工具包视为一个纯外部依赖项来管理FLAIM工具包的数据库库依赖关系，该依赖项由`make`变量`FTKINC`和`FTKLIB`定义。我有条件地定义了这些变量，以指向多个不同的来源，包括已安装的库，甚至是用户指定的配置脚本选项中的位置。
- en: '*Adding the configure.ac Files*'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*添加configure.ac文件*'
- en: In the following directory layout, I’ve used an annotation column to indicate
    the placement of individual *configure.ac* files. Each of these files represents
    a project that may be packaged and distributed independently.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下的目录布局中，我使用了注释列来指示每个*configure.ac*文件的位置。这些文件代表一个可能被打包并独立分发的项目。
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: My next task was to create these *configure.ac* files. The top-level file was
    trivial, so I created it by hand. The project-specific files were more complex,
    so I allowed the `autoscan` utility to do the bulk of the work for me. [Listing
    14-1](ch14.xhtml#ch14ex1) shows the top-level *configure.ac* file.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我的下一个任务是创建这些*configure.ac*文件。顶层文件非常简单，因此我手动创建了它。与项目相关的文件更复杂，因此我让`autoscan`工具为我完成大部分工作。[Listing
    14-1](ch14.xhtml#ch14ex1)展示了顶层的*configure.ac*文件。
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 14-1*: configure.ac: *The umbrella project’s Autoconf input file*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-1*: configure.ac: *Umbrella项目的Autoconf输入文件*'
- en: This *configure.ac* file is short and simple because it doesn’t do much; nevertheless,
    there are some new and important concepts here. I invented the name `flaim-projects`
    and the version number `1.0` at ➊. These are not likely to change unless really
    dramatic changes take place in the project directory structure or the maintainers
    decide to ship a complete bundle of the subprojects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*configure.ac*文件简短而简单，因为它没有做太多工作；尽管如此，这里有一些新的重要概念。我在➊处发明了`flaim-projects`这个名称和版本号`1.0`。除非项目目录结构发生重大变化，或者维护者决定发布一个包含所有子项目的完整捆绑包，否则这些内容不太可能改变。
- en: '**NOTE**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For your own projects, consider using the optional third argument to the *`AC_INIT`*
    macro. You can add an email or web address here to indicate to users where they
    can submit a bug report. The contents of this argument show up in* configure *output.*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于你自己的项目，考虑使用`AC_INIT`宏的可选第三个参数。你可以在此处添加电子邮件或网址，指示用户可以在哪里提交 bug 报告。此参数的内容会显示在*configure*输出中。*'
- en: 'The most important aspect of an umbrella project like this is the `AC_CONFIG_SUBDIRS`
    macro at ➏, which I have yet to cover in this book. The argument is a whitespace-separated
    list of the subprojects to be built, where each is a complete *GCS*-compliant
    project in its own right. Here’s the prototype for this macro:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的Umbrella项目中最重要的方面是➏处的`AC_CONFIG_SUBDIRS`宏，这是本书中我尚未介绍的。该参数是一个以空格分隔的子项目列表，每个子项目都是一个完全符合*GCS*标准的独立项目。以下是该宏的原型：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It allows the maintainer to set up a hierarchy of projects in much the same
    way that Automake `SUBDIRS` configures the directory hierarchy for Automake within
    a single project.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许维护者以与 Automake `SUBDIRS` 配置单个项目中的目录层次结构类似的方式设置项目层次结构。
- en: Because the four subprojects contain all the actual build functionality, this
    *configure.ac* file acts merely as a control file, passing all specified configuration
    options to each of the subprojects in the order they’re given in the macro’s argument.
    The FLAIM toolkit project must be built first since the other projects depend
    on it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这四个子项目包含所有实际的构建功能，所以这个*configure.ac*文件只是充当一个控制文件，将所有指定的配置选项传递给宏参数中给出的顺序中的每个子项目。必须首先构建FLAIM工具包项目，因为其他项目依赖于它。
- en: Automake in the Umbrella Project
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Umbrella 项目中的 Automake
- en: Automake usually requires the existence of several text files in the top-level
    project directory, including the *AUTHORS*, *COPYING*, *INSTALL*, *NEWS*, *README*,
    and *ChangeLog* files. It would be nice not to have to deal with these files in
    the umbrella project. One way to accomplish this is to simply not use Automake
    in the umbrella project. I’d either have to write my own *Makefile.in* template
    for this directory or use Automake just once to generate a *Makefile.in* template
    that I could then check into the repository as part of the project, along with
    the *install-sh* and *missing* scripts added by `automake` `--add-missing` (or
    `autoreconf -i`). Once these files were in place, I could remove `AM_INIT_AUTOMAKE`
    from the master *configure.ac* file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Automake通常要求在顶层项目目录中存在几个文本文件，包括*AUTHORS*、*COPYING*、*INSTALL*、*NEWS*、*README*和*ChangeLog*文件。最好在总项目中不必处理这些文件。实现这一目标的一种方法是干脆不在总项目中使用Automake。我要么得为这个目录编写自己的*Makefile.in*模板，要么只用一次Automake来生成一个*Makefile.in*模板，然后将其与`automake
    --add-missing`（或`autoreconf -i`）添加的*install-sh*和*missing*脚本一起提交到仓库中，作为项目的一部分。一旦这些文件到位，我就可以从主*configure.ac*文件中删除`AM_INIT_AUTOMAKE`。
- en: Another option would be to keep Automake and simply use the `foreign` option
    in `AM_INIT_AUTOMAKE` (which I did at ➋) in the macro’s optional parameter. This
    parameter contains a string of whitespace-separated options that tell Automake
    how to act in lieu of specific Automake command line options. When `automake`
    parses the *configure.ac* file, it notes these options and enables them as if
    they’d been passed on the command line. The `foreign` option tells Automake that
    the project will not entirely follow GNU standards, and thus Automake will not
    require the usual GNU project text files.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是保留Automake，并在`AM_INIT_AUTOMAKE`的宏可选参数中使用`foreign`选项（这是我在 ➋ 所做的）。这个参数包含一串以空格分隔的选项，告诉Automake如何替代特定的Automake命令行选项。当`automake`解析*configure.ac*文件时，它会记录下这些选项并启用它们，就像它们是从命令行传递的一样。`foreign`选项告诉Automake，该项目不会完全遵循GNU标准，因此Automake不会要求常见的GNU项目文本文件。
- en: I chose the latter of the two methods because I might want to alter the list
    of subordinate projects at some point and I don’t want to have to tweak a generated
    *Makefile.in* template by hand. I’ve also passed the `-Wall` and `-Werror` options
    in this list, which indicate that Automake should enable all Automake-specific
    warnings and report them as errors. These options have nothing to do with the
    user’s compilation environment—only Automake processing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择了两种方法中的后者，因为我可能会在某个时候想修改下属项目的列表，而不希望每次都手动调整生成的*Makefile.in*模板。我还在这个列表中传递了`-Wall`和`-Werror`选项，这表明Automake应该启用所有Automake特有的警告并将其报告为错误。这些选项与用户的编译环境无关——仅与Automake处理相关。
- en: Why Add the Libtool Macros?
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为什么要添加Libtool宏？
- en: Why include those expensive Libtool macros at ➍? Well, even though I don’t do
    anything with Libtool in the umbrella project, the lower-level projects expect
    a containing project to provide all the necessary scripts, and the `LT_INIT` macro
    provides the *ltmain.sh* script. If you don’t initialize Libtool in the umbrella
    project, tools like `autoreconf`, which actually looks in the *parent* directory
    to determine if the current project is itself a subproject, will fail when they
    can’t find scripts that the current project’s *configure.ac* file requires.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在 ➍ 包含这些昂贵的Libtool宏？好吧，尽管我在总项目中没有使用Libtool，但低级项目期望包含项目提供所有必要的脚本，而`LT_INIT`宏提供了*ltmain.sh*脚本。如果你在总项目中没有初始化Libtool，像`autoreconf`这样的工具（它实际上会在*父*目录中查找，来判断当前项目是否为子项目）会因为找不到当前项目的*configure.ac*文件所需要的脚本而失败。
- en: 'For instance, `autoreconf` expects to find a file called *../ltmain.sh* within
    the ftk project’s top-level directory. Note the reference to the parent directory
    here: `autoreconf` noticed, by examining the parent directory, that ftk was actually
    a subproject of a larger project. Rather than install all the auxiliary scripts
    multiple times, the Autotools generate code that looks for scripts in the project’s
    parent directory. This is done in an effort to reduce the number of copies of
    these scripts that are installed into multiproject packages.^([8](footnote.xhtml#ch14fn8))
    If I don’t use `LT_INIT` in the umbrella project, I can’t successfully run `autoreconf`
    in the subprojects, because the *ltmain.sh* script won’t be in the project’s parent
    directory.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`autoreconf`期望在ftk项目的顶级目录中找到名为*../ltmain.sh*的文件。注意这里对父目录的引用：`autoreconf`通过检查父目录发现，ftk实际上是一个更大项目的子项目。为了避免多次安装所有辅助脚本，Autotools生成代码，查找项目父目录中的脚本。这是为了减少将这些脚本安装到多项目包中的副本数量。^([8](footnote.xhtml#ch14fn8))
    如果我在主项目中不使用`LT_INIT`，则无法在子项目中成功运行`autoreconf`，因为*ltmain.sh*脚本将不会出现在项目的父目录中。
- en: Adding a Macro Subdirectory
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加宏子目录
- en: 'The `AC_CONFIG_MACRO_DIRS` macro at ➎ indicates the name of a subdirectory
    in which the `aclocal` utility can find all project-specific M4 macro files. Here’s
    the prototype:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ➎处的`AC_CONFIG_MACRO_DIRS`宏表示一个子目录的名称，`aclocal`工具可以在该目录中找到所有特定于项目的M4宏文件。以下是原型：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The *.m4* macro files in this directory are ultimately referenced with an `m4_include`
    statement in the `aclocal`-generated *aclocal.m4* file, which `autoconf` reads.
    This macro replaces the original *acinclude.m4* file with a directory containing
    individual macros or smaller sets of macros, each defined in its own *.m4* file.^([9](footnote.xhtml#ch14fn9))
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本目录中的*.m4*宏文件最终通过`m4_include`语句引用，在`aclocal`生成的*aclocal.m4*文件中，`autoconf`会读取该文件。这个宏用一个包含单独宏或较小宏集合的目录替换了原来的*acinclude.m4*文件，每个宏都定义在各自的*.m4*文件中。^([9](footnote.xhtml#ch14fn9))
- en: I’ve indicated by the parameter to `AC_CONFIG_MACRO_DIRS` that all of the local
    macro files to be added to *aclocal.m4* are in a subdirectory called *m4*. As
    a bonus, when `autoreconf -i` is executed, and then when it executes the required
    Autotools with their respective *add-missing* options, these tools will note the
    use of this macro in *configure.ac* and add any required system macro files that
    are missing to the *m4* directory.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过`AC_CONFIG_MACRO_DIRS`参数指明，所有要添加到*aclocal.m4*中的本地宏文件都位于一个名为*m4*的子目录中。作为附带功能，当执行`autoreconf
    -i`时，然后执行带有各自*add-missing*选项的必要Autotools工具时，这些工具会注意到*configure.ac*中使用了此宏，并将任何缺少的系统宏文件添加到*m4*目录中。
- en: The reason I chose to use `AC_CONFIG_MACRO_DIRS` here is that Libtool will not
    add its additional macro files to the project if you haven’t enabled the macro
    directory option in this manner. Instead, it will complain that you should add
    these files to *acinclude.m4* yourself.^([10](footnote.xhtml#ch14fn10))
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择在这里使用`AC_CONFIG_MACRO_DIRS`的原因是，如果没有以这种方式启用宏目录选项，Libtool将不会将其附加的宏文件添加到项目中。相反，它会抱怨应该将这些文件添加到*acinclude.m4*中。^([10](footnote.xhtml#ch14fn10))
- en: Since this is a fairly complex project and I wanted the Autotools to do this
    job for me, I decided to use this macro-directory feature. Future releases of
    the Autotools will likely require this form because it’s considered the more modern
    way of adding macro files to *aclocal.m4*, as opposed to using a single user-generated
    *acinclude.m4* file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个相对复杂的项目，我希望Autotools为我完成这项工作，因此决定使用这个宏目录功能。未来的Autotools版本可能会要求使用这种形式，因为它被认为是将宏文件添加到*aclocal.m4*的更现代的方式，而不是使用单一的用户生成的*acinclude.m4*文件。
- en: 'One final thought on this macro: if you look for it in the Autoconf manual,
    you won’t find it—at least not yet, because it’s not an Autoconf macro but an
    Automake macro. It’s prefixed with `AC_` because it was always intended that a
    future release of Autoconf would take on this macro. It’s more functional than
    its singular predecessor, which *is* documented in the Autoconf manual, but the
    functionality was not needed until Automake came along. In fact, I have it on
    pretty good authority (the pre-release Autoconf *ChangeLog*) that ownership will
    change hands when Autoconf 2.70 is published.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个宏的最后一个思考：如果你在 Autoconf 手册中查找它，你是找不到的——至少目前找不到，因为它不是一个 Autoconf 宏，而是一个 Automake
    宏。它的前缀是 `AC_`，因为最初的设计目标是未来某个版本的 Autoconf 会接管这个宏。它比它的单一前身功能更强大，后者在 Autoconf 手册中有文档，但在
    Automake 出现之前，这个功能并不需要。事实上，我有相当可靠的消息来源（预发布的 Autoconf *ChangeLog*），表示当 Autoconf
    2.70 发布时，这个宏的所有权将会转移。
- en: The one item that we haven’t yet covered here is the `AM_PROG_AR` macro at ➌.
    This is a newer Automake macro. The first edition of this book didn’t use it.
    When I updated the Autotools, suddenly `autoreconf` complained that I needed it,
    so I added it and the complaint went away. The Autoconf manual says simply that
    you need it if you want to use an archiver (`ar`) that has an unusual interface
    (such as Microsoft `lib`). The fact is, the real complainer here was Libtool,
    which seems to have a habit of complaining about not including features of the
    other Autotools that it thinks you should be using. I added it to silence the
    warning.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里尚未讨论的一个项目是 ➌ 位置的 `AM_PROG_AR` 宏。这是一个较新的 Automake 宏。本书的第一版没有使用它。当我更新 Autotools
    时，突然 `autoreconf` 报告需要它，所以我加上了它，问题就解决了。Autoconf 手册简单地说明，如果你想使用具有特殊接口（如 Microsoft
    `lib`）的归档器（`ar`），你需要它。事实上，真正发出抱怨的是 Libtool，它似乎习惯性地抱怨没有包含它认为你应该使用的其他 Autotools
    特性。我添加了它以消除警告。
- en: '*The Top-Level Makefile.am File*'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*顶层 Makefile.am 文件*'
- en: The only other point to be covered regarding the umbrella project is the top-level
    *Makefile.am* file, shown in [Listing 14-2](ch14.xhtml#ch14ex2).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 关于总项目的唯一其他要点是顶层 *Makefile.am* 文件，如[清单 14-2](ch14.xhtml#ch14ex2)所示。
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 14-2*: Makefile.am: *The umbrella project Automake input file*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-2*: Makefile.am: *总项目 Automake 输入文件*'
- en: According to the Automake documentation, the `ACLOCAL_AMFLAGS` variable at ➊
    should be defined in the top-level *Makefile.am* file of any project that uses
    `AC_CONFIG_MACRO_DIR` (singular) in its *configure.ac* file. The flags specified
    on this line tell `aclocal` where it should look for macro files when it’s executed
    by rules defined in *Makefile.am*. The format of this option is similar to that
    of a C-compiler command line include (`-I`) directive; you can specify other `aclocal`
    command line options as well.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Automake 文档，在 ➊ 位置定义的 `ACLOCAL_AMFLAGS` 变量应该在任何使用 `AC_CONFIG_MACRO_DIR`（单数）作为
    *configure.ac* 文件中的配置项的项目的顶层 *Makefile.am* 文件中定义。此行指定的标志告诉 `aclocal` 在执行时应该在哪里查找宏文件，这些规则是在
    *Makefile.am* 中定义的。此选项的格式类似于 C 编译器命令行的 `-I` 指令；你也可以指定其他 `aclocal` 命令行选项。
- en: This variable used to be required when using a macro subdirectory with the older
    `AC_CONFIG_MACRO_DIR`, but with the advent of the newer `AC_CONFIG_MACRO_DIRS`,
    you no longer need this variable, as it generates code that allows Automake to
    understand which options it should pass to `aclocal`. Unfortunately, Libtool just
    can’t help but pipe up during `autoreconf` when it sees you using a macro directory
    without this variable in your *Makefile.am* files. I’m hoping this noise will
    go away when Autoconf takes ownership of the newer macro (with a subsequent release
    of Libtool, of course).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用旧版 `AC_CONFIG_MACRO_DIR` 时，此变量曾经是必需的，但随着新版 `AC_CONFIG_MACRO_DIRS` 的出现，你不再需要此变量，因为它生成的代码使
    Automake 能够理解应该传递给 `aclocal` 的选项。不幸的是，当 Libtool 看到你在 *Makefile.am* 文件中使用宏目录而没有这个变量时，它还是会在
    `autoreconf` 时发出警告。我希望当 Autoconf 接管了这个新宏（当然，还需要 Libtool 的后续版本发布）时，这个噪音会消失。
- en: The Autotools use this variable in two unrelated places. The first is in a `make`
    rule generated to update the *aclocal.m4* file from all of its various input sources.
    This rule and its supporting variable definitions are shown in [Listing 14-3](ch14.xhtml#ch14ex3),
    which is a code snippet copied from an Autotools-generated makefile.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Autotools 在两个不相关的地方使用这个变量。第一个是在生成的 `make` 规则中，用于根据各种输入源更新 *aclocal.m4* 文件。此规则及其支持的变量定义见于[清单
    14-3](ch14.xhtml#ch14ex3)，这是从 Autotools 生成的 Makefile 中复制的代码片段。
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 14-3: The `make` rule and the variables used to update* aclocal.m4
    *from its various dependencies*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-3：用于更新* aclocal.m4 *的`make` 规则和所使用的变量，它们来自各种依赖项*'
- en: The `ACLOCAL_AMFLAGS` definition is also used during execution of `autoreconf`,
    which scans the top-level *Makefile.am* file for this definition and passes the
    value text directly to `aclocal` on the command line. Be aware that `autoreconf`
    does no variable expansion on this string, so if you add shell or `make` variable
    references to the text, they won’t be expanded when `autoreconf` executes `aclocal`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACLOCAL_AMFLAGS` 定义也在执行 `autoreconf` 时使用，`autoreconf` 会扫描顶级 *Makefile.am*
    文件中的此定义，并直接将该值传递给命令行中的 `aclocal`。请注意，`autoreconf` 不会对这个字符串进行变量扩展，因此如果你在文本中添加了
    shell 或 `make` 变量引用，它们在 `autoreconf` 执行 `aclocal` 时将不会被扩展。'
- en: Returning to [Listing 14-2](ch14.xhtml#ch14ex2), I’ve used the `EXTRA_DIST`
    variable at ➋ to ensure that a few additional top-level files get distributed—these
    files and directories are specific to the Windows build system. This isn’t critical
    to the umbrella project, since I don’t intend to create distributions at this
    level, but I like to be complete.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到[清单 14-2](ch14.xhtml#ch14ex2)，我在 ➋ 使用了 `EXTRA_DIST` 变量，以确保几个额外的顶级文件能够被分发——这些文件和目录是特定于
    Windows 构建系统的。对于总体项目来说，这并不是至关重要的，因为我不打算在这个层次上创建分发包，但我喜欢做到完整。
- en: The `SUBDIRS` variable at ➌ duplicates the information in the *configure.ac*
    file’s `AC_CONFIG_SUBDIRS` macro. I tried creating a shell substitution variable
    and exporting it with `AC_SUBST`, but it didn’t work—when I ran `autoreconf`,
    I got an error indicating that I should use literals in the `AC_CONFIG_SUBDIRS`
    macro argument.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ 处的 `SUBDIRS` 变量重复了 *configure.ac* 文件中 `AC_CONFIG_SUBDIRS` 宏的信息。我尝试创建一个 shell
    替代变量，并用 `AC_SUBST` 导出它，但没有成功——当我运行 `autoreconf` 时，出现了一个错误，提示我应该在 `AC_CONFIG_SUBDIRS`
    宏参数中使用字面量。
- en: The `rpms` and `srcrpm` targets at ➍ allow the end user to build RPM packages
    for RPM-based Linux systems. The shell commands in this rule simply pass the user-specified
    targets and variables down to each of the lower-level projects in succession,
    just as we did with our handcoded makefiles and *Makefile.in* templates in [Chapters
    3](ch03.xhtml), [4](ch04.xhtml), and [5](ch05.xhtml).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`rpms` 和 `srcrpm` 目标在 ➍ 处允许最终用户为基于 RPM 的 Linux 系统构建 RPM 包。这个规则中的 shell 命令只是将用户指定的目标和变量依次传递给每个低级项目，就像我们在[第
    3 章](ch03.xhtml)、[第 4 章](ch04.xhtml)和[第 5 章](ch05.xhtml)中用手写的 makefile 和 *Makefile.in*
    模板所做的那样。'
- en: When passing control to lower-level makefiles in the manner shown in the commands
    for these RPM targets, you should strive to follow this pattern. Passing the expansion
    of `AM_MAKEFLAGS` allows lower-level makefiles access to the same `make` flags
    defined in the current or parent makefile. However, you can add more functionality
    to such recursive `make` code. To see how Automake passes control down to lower-level
    makefiles for its own targets, open an Automake-generated *Makefile.in* template
    and search for the text “`$(am__recursive_targets):`”. The code beneath this target
    shows exactly how Automake does it. While it looks complex at first glance, the
    code performs only two additional tasks. First, it ensures that continue-after-error
    functionality (`make -k`) works properly. Second, it ensures that the current
    directory (`.`) is handled properly if found in the `SUBDIRS` variable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在以这种方式将控制权传递给低级 makefile 时，你应该努力遵循这个模式。传递 `AM_MAKEFLAGS` 的扩展使得低级 makefile 能够访问当前或父级
    makefile 中定义的相同 `make` 标志。然而，你可以为这种递归的 `make` 代码添加更多功能。要查看 Automake 如何将控制权传递给低级
    makefile 以处理它自己的目标，可以打开一个 Automake 生成的 *Makefile.in* 模板，并搜索文本 "`$(am__recursive_targets):`"。该目标下的代码准确地显示了
    Automake 是如何做的。虽然初看起来很复杂，但这段代码实际上只执行了两项额外的任务。首先，它确保 `make -k` 的继续错误功能能够正常工作。其次，它确保如果
    `SUBDIRS` 变量中包含当前目录（`.`），则会正确处理。
- en: 'This brings me to my final point about this code: if you choose to write your
    own recursive targets in this manner (and we’ll see other examples of this later
    when we discuss conversion of the flaim build system), you should either avoid
    using a dot in the `SUBDIRS` variable or enhance the shell code to handle this
    special case. If you don’t, your users will likely find themselves in an endless
    recursion loop when they attempt to make one of these targets. For a more extensive
    treatise on this topic, see “Item 2: Implementing Recursive Extension Targets”
    on [page 505](ch18.xhtml#page_505).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我想到了关于这段代码的最后一点：如果你选择以这种方式编写自己的递归目标（稍后我们将在讨论FLAIM构建系统转换时看到其他示例），你应该避免在`SUBDIRS`变量中使用点，或者增强shell代码以处理这种特殊情况。如果不这样做，用户在尝试构建这些目标时，可能会陷入无休止的递归循环。有关此主题的更广泛讨论，请参见[第505页](ch18.xhtml#page_505)的“条目2：实现递归扩展目标”。
- en: The FLAIM Subprojects
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: FLAIM子项目
- en: I used `autoscan` to generate a starting point for the ftk project. The `autoscan`
    utility is a bit finicky about where it will look for information. If your project
    doesn’t contain a makefile named exactly *Makefile*, or if your project already
    contains an Autoconf *Makefile.in* template, `autoscan` will not add any information
    about required libraries to the *configure.scan* output file. It has no way of
    determining this information except to look into your old build system, and it
    won’t do this unless conditions are just right.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`autoscan`为ftk项目生成了一个起点。`autoscan`工具在查找信息时有些挑剔。如果你的项目没有一个名为*Makefile*的makefile，或者如果你的项目已经包含了一个Autoconf的*Makefile.in*模板，`autoscan`将不会将任何关于所需库的信息添加到*configure.scan*输出文件中。它无法通过任何其他方式来确定这些信息，除非查看你旧的构建系统，而它只有在条件完全合适的情况下才会这么做。
- en: Given the complexity of the ftk project’s legacy makefile, I was quite impressed
    with `autoscan`’s ability to parse it for library information. [Listing 14-4](ch14.xhtml#ch14ex4)
    shows a portion of the resulting *configure.scan* file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于ftk项目遗留的makefile的复杂性，我对`autoscan`解析它以获取库信息的能力印象深刻。[示例 14-4](ch14.xhtml#ch14ex4)展示了结果中*configure.scan*文件的一部分。
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 14-4: A portion of the output from `autoscan` when run over the ftk
    project directory structure*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 14-4：在ftk项目目录结构上运行`autoscan`时输出的一部分*'
- en: '*The FLAIM Toolkit configure.ac File*'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*FLAIM工具包configure.ac文件*'
- en: After this *configure.scan* file was modified and renamed, the resulting *configure.ac*
    file contained many new constructs, which I’ll discuss in the next few sections.
    In order to facilitate the discussion, I split this file into two parts, the first
    half of which is shown in [Listing 14-5](ch14.xhtml#ch14ex5).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改并重命名这个*configure.scan*文件后，结果生成的*configure.ac*文件包含了许多新的构造，接下来几节我将讨论这些内容。为了便于讨论，我将这个文件分成了两部分，第一部分显示在[示例
    14-5](ch14.xhtml#ch14ex5)中。
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 14-5*: ftk/configure.ac: *The first half of the ftk project’s* configure.ac
    *file*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 14-5*：ftk/configure.ac：*ftk项目的configure.ac文件的前半部分*'
- en: At ➊, you will see that I substituted real values for the placeholders `autoscan`
    left in the `AC_INIT` macro. I added calls to `AM_INIT_AUTOMAKE`, `LT_PREREQ`,
    and `LT_INIT` at ➋, and I added a call to `AC_CONFIG_MACRO_DIRS` at ➍. (For now,
    just ignore the `AM_PROG_AR` macro—I’ll explain it later in this chapter.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，你会看到我为`autoscan`在`AC_INIT`宏中留下的占位符替换了真实值。在➋处，我添加了对`AM_INIT_AUTOMAKE`、`LT_PREREQ`和`LT_INIT`的调用，在➍处，我添加了对`AC_CONFIG_MACRO_DIRS`的调用。（暂时忽略`AM_PROG_AR`宏——我稍后会在本章中解释它。）
- en: '**NOTE**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I didn’t use the *`foreign`* keyword in *`AM_INIT_AUTOMAKE`* this time. Since
    it’s a real open source project, the FLAIM developers will (or at least, should)
    want these files. I used the *`touch`* command to create empty versions of the
    GNU project text files,^([11](footnote.xhtml#ch14fn11)) except for* COPYING *and*
    INSTALL, *which *`autoreconf`* adds.*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*这次我没有在*`AM_INIT_AUTOMAKE`*中使用*`foreign`*关键字。由于这是一个真正的开源项目，FLAIM的开发者（或者至少应该）希望拥有这些文件。我使用了*`touch`*命令来创建GNU项目文本文件的空版本，^([11](footnote.xhtml#ch14fn11))，除了*COPYING*和*INSTALL*，*这两个文件是*`autoreconf`*添加的。*'
- en: A new construct at ➌ is the `AC_LANG` macro, which indicates the programming
    language (and thus, the compiler) that Autoconf should use when generating compilation
    tests in `configure`. I’ve passed `C++` as the parameter so Autoconf will compile
    these tests using the C++ compiler via the `CXX` variable, rather than the default
    C compiler via the `CC` variable. I then deleted the `AC_PROG_CC` macro call,
    since the source code for this project is written entirely in C++.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 新的结构出现在 ➌ 处，它是 `AC_LANG` 宏，表示 Autoconf 在生成 `configure` 中的编译测试时应使用的编程语言（从而确定编译器）。我传递了
    `C++` 作为参数，这样 Autoconf 就会通过 `CXX` 变量使用 C++ 编译器来编译这些测试，而不是通过 `CC` 变量使用默认的 C 编译器。然后，我删除了
    `AC_PROG_CC` 宏调用，因为该项目的源代码完全是用 C++ 编写的。
- en: I changed the `AC_CONFIG_SRCDIR` file argument at ➎ to one that made more sense
    to me than the one randomly chosen by `autoscan`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我将 ➎ 处的 `AC_CONFIG_SRCDIR` 文件参数改成了一个对我来说更合适的参数，而不是 `autoscan` 随机选择的那个。
- en: 'The `FLM_PROG_TRY_DOXYGEN` macro at ➏ is a custom macro that I wrote. Here’s
    the prototype:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`FLM_PROG_TRY_DOXYGEN` 宏在 ➏ 处是我编写的自定义宏。下面是它的原型：'
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I’ll cover the details of how this macro works in [Chapter 16](ch16.xhtml).
    For now, just know that it manages a precious variable called `DOXYGEN`. If the
    variable is already set, this macro does nothing; if the variable is not set,
    it scans the system search path for a `doxygen` program, setting the variable
    to the program name if it finds one. I’ll explain Autoconf precious variables
    when we get to the xflaim project.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在 [第 16 章](ch16.xhtml) 中详细讲解这个宏是如何工作的。目前只需要知道它管理一个名为 `DOXYGEN` 的宝贵变量。如果该变量已经设置，这个宏什么也不做；如果该变量没有设置，它会扫描系统搜索路径，查找
    `doxygen` 程序，如果找到了，就将该变量设置为程序名称。我会在介绍 xflaim 项目时解释 Autoconf 的宝贵变量。
- en: At ➐, I added a couple of configuration options to `configure`’s command line
    parser with `AC_ARG_ENABLE`. I’ll discuss the details of these calls more completely
    as we come to other new constructs that use the variables these macros define.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➐ 处，我使用 `AC_ARG_ENABLE` 向 `configure` 的命令行解析器添加了几个配置选项。当我们讨论其他使用这些宏定义的变量的新结构时，我会更全面地讨论这些调用的细节。
- en: Automake Configuration Features
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Automake 配置特性
- en: 'Automake provides the `AM_CONDITIONAL` macro I used at ➑; it has the following
    prototype:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Automake 提供了我在 ➑ 处使用的 `AM_CONDITIONAL` 宏；它的原型如下：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The *`variable`* argument is an Automake conditional name that you can use
    in your *Makefile.am* files to test the associated condition. The *`condition`*
    argument is a *shell condition*—a bit of shell script that could be used as the
    condition in a shell `if-then` statement. In fact, this is exactly how the macro
    uses the *`condition`* argument internally, so it must be formatted as a proper
    `if-then` statement *condition* expression:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*`variable`* 参数是一个 Automake 条件名称，你可以在 *Makefile.am* 文件中使用它来测试相关条件。*`condition`*
    参数是一个 *shell 条件*——一段 shell 脚本，可以用作 shell `if-then` 语句中的条件。事实上，这正是该宏内部如何使用 *`condition`*
    参数的方式，所以它必须格式化为一个正确的 `if-then` 语句 *条件* 表达式：'
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `AM_CONDITIONAL` macro always defines two Autoconf substitution variables
    named *`variable`*`_TRUE` and *`variable`*`_FALSE`. If *`condition`* is true,
    *`variable`*`_TRUE` is empty and *`variable`*`_FALSE` is defined as a hash mark
    (`#`), which indicates the beginning of a comment in a makefile. If *`condition`*
    is false, the definitions of these two substitution variables are reversed; that
    is, *`variable`*`_FALSE` is empty, and *`variable`*`_TRUE` becomes the hash mark.
    Automake uses these variables to conditionally comment out portions of your makefile
    script that are defined within Automake conditional statements.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`AM_CONDITIONAL` 宏总是定义两个 Autoconf 替换变量，分别是 *`variable`*`_TRUE` 和 *`variable`*`_FALSE`。如果
    *`condition`* 为真，*`variable`*`_TRUE` 为空，而 *`variable`*`_FALSE` 被定义为一个井号（`#`），表示在
    makefile 中注释的开始。如果 *`condition`* 为假，这两个替换变量的定义会被反转；也就是说，*`variable`*`_FALSE` 为空，而
    *`variable`*`_TRUE` 变成了井号。Automake 使用这些变量有条件地注释掉你在 Automake 条件语句中定义的 makefile
    脚本部分。'
- en: This instance of `AM_CONDITIONAL` defines the conditional name `HAVE_DOXYGEN`,
    which you can use in the project’s *Makefile.am* files to do something conditionally,
    based on whether or not `doxygen` can be executed successfully (via the `DOXYGEN`
    variable). Any lines of `make` script found within a test for truth in *Makefile.am*
    are prefixed with `@`*`variable`*`_TRUE@` in the Automake-generated *Makefile.in*
    template. Conversely, any lines found within an Automake conditional test for
    falseness are prefixed with `@`*`variable`*`_FALSE@`. When `config.status` generates
    *Makefile* from *Makefile.in*, these lines are either commented out (prefixed
    with hash marks) or not, depending on the truth or falseness of the condition.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这一实例的`AM_CONDITIONAL`定义了条件名`HAVE_DOXYGEN`，您可以在项目的*Makefile.am*文件中使用它，根据是否能够成功执行`doxygen`（通过`DOXYGEN`变量）有条件地执行某些操作。在*Makefile.am*中的条件为真时，`make`脚本中的任何行都以`@`*`variable`*`_TRUE@`为前缀，在Automake生成的*Makefile.in*模板中。相反，任何在Automake条件测试为假时找到的行都以`@`*`variable`*`_FALSE@`为前缀。当`config.status`从*Makefile.in*生成*Makefile*时，这些行根据条件的真假被注释掉（以井号为前缀）或不被注释掉。
- en: 'There’s just one caveat with using `AM_CONDITIONAL`: you cannot call it conditionally
    (for instance, within a shell `if-then-else` statement) in the *configure.ac*
    file. You can’t define substitution variables conditionally—you can define their
    contents differently based on the specified condition, but the variables themselves
    are either defined or not at the time Autoconf creates the `configure` script.
    Since Automake-generated template files are created long before the user executes
    `configure`, Automake must be able to rely on the existence of these variables,
    regardless of how they’re defined.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`AM_CONDITIONAL`有一个注意事项：您不能在*configure.ac*文件中有条件地调用它（例如，在shell的`if-then-else`语句中）。您不能有条件地定义替换变量——您可以根据指定的条件不同地定义它们的内容，但这些变量本身在Autoconf创建`configure`脚本时要么已定义，要么未定义。由于Automake生成的模板文件是在用户执行`configure`之前很久就创建的，因此Automake必须能够依赖这些变量的存在，无论它们是如何定义的。
- en: 'Within the `configure` script, you may want to perform other Autoconf operations
    based on the value of Automake conditionals. This is where the (commented) Automake-provided
    `AM_COND_IF` macro at ➒ comes into play.^([12](footnote.xhtml#ch14fn12)) Its prototype
    is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`configure`脚本中，您可能希望根据Automake条件的值执行其他Autoconf操作。这时，位于➒的（已注释的）Automake提供的`AM_COND_IF`宏就发挥作用了。^([12](footnote.xhtml#ch14fn12))
    它的原型如下：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If *`conditional-variable`* is defined as true by a previous call to `AM_CONDITIONAL`,
    the *`if-true`* shell script (including any Autoconf macro calls) is executed.
    Otherwise, the *`if-false`* shell script is executed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*`conditional-variable`*在先前调用`AM_CONDITIONAL`时被定义为真，则执行*`if-true`* shell脚本（包括任何Autoconf宏调用）。否则，执行*`if-false`*
    shell脚本。
- en: Now let’s suppose, for example, that you want to conditionally build a portion
    of your project directory structure—say, the *xflaim/docs/doxygen* directory—based
    on the Automake conditional `HAVE_DOXYGEN`. Perhaps you are appending the subdirectory
    in question onto the `SUBDIRS` variable within an Automake conditional statement
    in your *Makefile.am* file (I’m actually doing this, as you’ll see in “The FLAIM
    Toolkit Makefile.am File” on [page 388](ch14.xhtml#page_388)). Since `make` won’t
    be building this portion of the project directory structure if the condition is
    false, there’s certainly little reason to have `config.status` process the *doxyfile.in*
    template within that directory during configuration. Therefore, you might use
    the code shown in [Listing 14-6](ch14.xhtml#ch14ex6) in your *configure.ac* file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设，举个例子，您希望有条件地构建项目目录结构的一部分——例如，基于Automake条件`HAVE_DOXYGEN`构建*xflaim/docs/doxygen*目录。也许您在*Makefile.am*文件中的Automake条件语句内将该子目录附加到`SUBDIRS`变量中（我实际上正在做这件事，正如您将在[第388页](ch14.xhtml#page_388)的“FLAIM工具包Makefile.am文件”一节中看到的）。由于如果条件为假，`make`不会构建项目目录结构的这一部分，因此在配置过程中没有理由让`config.status`处理该目录中的*doxyfile.in*模板。因此，您可以在*configure.ac*文件中使用[列出14-6](ch14.xhtml#ch14ex6)中显示的代码。
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 14-6*: ftk/configure.ac: *Using `AM_COND_IF` to conditionally configure
    a template*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出14-6*: ftk/configure.ac: *使用`AM_COND_IF`有条件地配置模板*'
- en: With this code in place, `configure` simply will not process the *doxyfile.in*
    template at all within the *docs* directory if `doxygen` isn’t installed on the
    user’s system.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码存在的情况下，如果用户系统上未安装`doxygen`，`configure`将根本不会处理*docs*目录中的*doxyfile.in*模板。
- en: '**NOTE**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The* docs/Makefile.in *template should not be included here because the *`dist`*
    target must be able to process all directories in the project—whether or not they’re
    conditionally built—during execution of build targets such as *`all`* and *`clean`*.
    Thus, you should never conditionally process* Makefile.in *templates within* configure.ac.
    *However, you can certainly process other types of templates conditionally.*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*docs/Makefile.in*模板不应该包含在这里，因为*`dist`*目标必须能够在执行诸如*`all`*和*`clean`*等构建目标时，处理项目中的所有目录——无论它们是否是有条件构建的。因此，你不应在configure.ac中有条件地处理*Makefile.in*模板。*然而，你当然可以有条件地处理其他类型的模板。*'
- en: 'The line following the line at ➒ is an alternative method of accomplishing
    the same thing using *M4sh*—a macro library built into Autoconf that’s designed
    to make it easier to write portable Bourne shell script. Here is the prototype:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在➒行之后的那一行是使用*M4sh*（一种内置于Autoconf的宏库，旨在简化编写可移植的Bourne shell脚本）的替代方法来完成相同的事情。这里是原型：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The optional, elided parameters between the second and last ones shown are pairs
    of *`test`*`N` and *`run-if-true`* arguments. Ultimately, this macro works much
    like an `if-then-elif...` shell statement with a user-specified number of `elif`
    conditions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个和最后一个参数之间省略的可选参数是*`test`*`N`和*`run-if-true`*参数的配对。最终，这个宏的工作方式就像一个`if-then-elif...`的Shell语句，带有用户指定数量的`elif`条件。
- en: '[Listing 14-7](ch14.xhtml#ch14ex7) shows the second half of ftk’s *configure.ac*
    file.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 14-7](ch14.xhtml#ch14ex7)展示了ftk的*configure.ac*文件的后半部分。'
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 14-7*: ftk/configure.ac: *The second half of the ftk project’s* configure.ac
    *file*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-7*: ftk/configure.ac: *ftk项目的* configure.ac *文件的后半部分*'
- en: At ➊, I’ve called the `AC_SYS_LARGEFILE` macro. If the user has a 32-bit system,
    this macro ensures that appropriate C-preprocessor definitions (and possibly compiler
    options) that force the use of 64-bit file addressing (also called *large files*)
    are added to the *config.h.in* template. With these variables in place, C-library
    large-address-aware file I/O functions become available to the project source
    code. FLAIM, as a database system, cares very much about this feature.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我调用了`AC_SYS_LARGEFILE`宏。如果用户使用的是32位系统，该宏会确保向*C预处理器定义（以及可能的编译器选项）*中添加适当的定义，从而强制使用64位文件寻址（也称为*大文件*）。有了这些变量，C库中的大地址感知文件I/O函数就可以在项目源代码中使用。作为一个数据库系统，FLAIM非常重视这个特性。
- en: In the last few years, 32-bit general-purpose computer systems have become less
    popular as companies like Intel and Microsoft have made media statements concerning
    future versions of their products that will no longer support 32-bit address spaces.
    However, market pressures caused by the millions of existing 32-bit systems have
    cause them to back off a bit on the rhetoric and return to a more pragmatic perspective.
    Nevertheless, 32-bit PCs are on their way out the door in the not-too-distant
    future. Even so, Linux will continue to run on 32-bit systems because many embedded
    systems still get significant benefits from using smaller, less-power-hungry 32-bit
    microprocessors.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 近几年，32位通用计算机系统已经不再那么流行，因为像英特尔和微软这样的公司在关于未来版本产品的声明中表示，将不再支持32位地址空间。然而，由于市场压力，数百万现有的32位系统使得它们稍微放缓了这一言辞，回归了更务实的视角。尽管如此，32位PC将在不久的将来退出历史舞台。即便如此，Linux仍将继续在32位系统上运行，因为许多嵌入式系统仍然从使用更小、更节能的32位微处理器中获得显著的好处。
- en: Doing Threads the Right Way
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 正确处理线程
- en: There is another new construct, `AX_PTHREAD`, at ➋. In the Jupiter project,
    I simply linked the `jupiter` program with the *pthreads* library via the `-lpthread`
    linker flag. But frankly, this is the wrong way to use *pthreads*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在➋处有另一个新的构造体，`AX_PTHREAD`。在Jupiter项目中，我仅通过`-lpthread`链接器标志将`jupiter`程序与*pthreads*库链接起来。但坦白说，这不是使用*pthreads*的正确方式。
- en: In the presence of multiple threads of execution, you must configure many of
    the standard C-library functions to act in a thread-safe manner. You can do this
    by ensuring that one or more preprocessor definitions are visible to all of the
    standard library header files as they’re being compiled into the program. These
    C-preprocessor definitions must be defined on the compiler command line, and they’re
    not standardized between compiler vendors.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在存在多个执行线程的情况下，必须配置许多标准C库函数以使其以线程安全的方式运行。你可以通过确保一个或多个预处理器定义在所有标准库头文件被编译到程序中时可见来实现这一点。这些C预处理器定义必须在编译器命令行上定义，并且在编译器供应商之间没有标准化。
- en: Some vendors provide entirely different standard libraries for building single-threaded
    versus multithreaded programs, because adding thread safety to a library reduces
    performance to a degree. Compiler vendors believe (correctly) that they’re doing
    you a favor by giving you different versions of the standard library for these
    purposes. In this scenario, it’s necessary to tell the linker to use the correct
    runtime libraries.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一些供应商为构建单线程和多线程程序提供完全不同的标准库，因为将线程安全性添加到库中会在某种程度上降低性能。编译器供应商（正确地）认为，通过为这些目的提供不同版本的标准库，他们是在帮你一个忙。在这种情况下，必须告诉链接器使用正确的运行时库。
- en: 'Unfortunately, every vendor does multithreading in its own way, from compiler
    options to library names to preprocessor definitions. But there is a reasonable
    solution to the problem: the GNU Autoconf Archive^([13](footnote.xhtml#ch14fn13))
    provides a macro called `AX_PTHREAD` that checks out a user’s compiler and provides
    the correct flags and options for a wide variety of platforms.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，每个供应商都有自己实现多线程的方式，从编译器选项到库名称再到预处理器定义。但这个问题有一个合理的解决方案：GNU Autoconf Archive^([13](footnote.xhtml#ch14fn13))提供了一个名为`AX_PTHREAD`的宏，它检查用户的编译器，并为各种平台提供正确的标志和选项。
- en: 'This macro is very simple to use:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏非常简单易用：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It sets several environment variables, including `PTHREAD_CFLAGS`, `PTHREAD``_CXXFLAGS`,
    and `PTHREAD_LIBS`. It’s up to the caller to use these variables properly by adding
    shell code to the *`action-if-found`* argument. If all of your project’s code
    is multithreaded, things are simpler: you need only append these variables to,
    or consume them from within, the standard `CFLAGS`, `CXXFLAGS`, and `LIBS` variables.
    The FLAIM project code base is completely multithreaded, so I chose to do this.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 它设置了几个环境变量，包括`PTHREAD_CFLAGS`、`PTHREAD_CXXFLAGS`和`PTHREAD_LIBS`。调用者需要通过向*`action-if-found`*参数添加Shell代码来正确使用这些变量。如果你的整个项目都是多线程的，事情就更简单了：你只需要将这些变量附加到标准的`CFLAGS`、`CXXFLAGS`和`LIBS`变量中，或者在这些变量内使用它们。FLAIM项目的代码库完全是多线程的，所以我选择了这样做。
- en: If you examine the contents of the *ax_pthread.m4* file in the *ftk/m4* directory,
    you might expect to find a large `case` statement that sets options for every
    compiler and platform combination known to man—but that’s not the Autoconf way.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查*ftk/m4*目录中的*ax_pthread.m4*文件，你可能会期待看到一个大的`case`语句，用于设置已知平台和编译器组合的选项，但那并不是Autoconf的方式。
- en: Instead, the macro incorporates a long list of known *pthreads* compiler options,
    and the generated `configure` script uses the host compiler to compile a small
    *pthreads* program with each one of these options in turn. The flags that are
    recognized by the compiler, and that therefore properly build the test program,
    are added to the `PTHREAD_CFLAGS` and `PTHREAD_CXXFLAGS` variables. This way,
    `AX_PTHREAD` stands a good chance of continuing to work properly, even in the
    face of significant changes to compiler options in the future—and this *is* the
    Autoconf way.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，该宏包含了一个已知的*pthread*编译器选项长列表，生成的`configure`脚本使用主机编译器依次用这些选项编译一个小的*pthreads*程序。编译器识别并能正确构建测试程序的标志将被添加到`PTHREAD_CFLAGS`和`PTHREAD_CXXFLAGS`变量中。通过这种方式，`AX_PTHREAD`即使在未来编译器选项发生重大变化时，也有很大可能继续正常工作——这就是Autoconf的方式。
- en: Getting Just the Right Libraries
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 获取恰到好处的库
- en: I deleted the *FIXME* comments (see *configure.scan* in [Listing 14-4](ch14.xhtml#ch14ex4)
    on [page 378](ch14.xhtml#page_378)) above each of the `AC_CHECK_LIB` macro calls
    at ➌ in [Listing 14-7](ch14.xhtml#ch14ex7). I started to replace the main placeholders
    in these macros with actual library function names, but then I began to wonder
    if all of those libraries were really necessary. I wasn’t as concerned about `autoscan`’s
    abilities as I was about the veracity of the original makefile. In handcoded build
    systems, I’ve occasionally noticed that the author will cut and paste sets of
    library names from one makefile to another until the program builds without missing
    symbols.^([14](footnote.xhtml#ch14fn14))
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我删除了每个`AC_CHECK_LIB`宏调用上方的*FIXME*注释（见[Listing 14-4](ch14.xhtml#ch14ex4)中的*configure.scan*，[page
    378](ch14.xhtml#page_378)），这些注释位于[Listing 14-7](ch14.xhtml#ch14ex7)的➌位置。我开始用实际的库函数名称替换这些宏中的主要占位符，但随后我开始怀疑这些库是否都真的必要。我对`autoscan`的能力并不太担心，而是更关注原始makefile的真实性。在手写构建系统中，我偶尔会注意到作者会将一组库名称从一个makefile复制到另一个，直到程序可以在没有丢失符号的情况下构建成功。^([14](footnote.xhtml#ch14fn14))
- en: Instead of blindly continuing this trend, I chose to simply comment out all
    of the calls to `AC_CHECK_LIB` to see how far I could get in the build, adding
    them back in one at a time as required to resolve missing symbols. Unless your
    project consumes literally hundreds of libraries, this will only take a few extra
    minutes. I like to link only the libraries that are necessary for my project;
    it speeds up the link process and, when done religiously, provides a good form
    of project-level documentation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有盲目地继续这种趋势，而是选择简单地注释掉所有 `AC_CHECK_LIB` 的调用，看看在构建过程中能走多远，然后根据需要逐个添加它们，以解决缺失的符号。除非你的项目需要消耗数百个库，否则这只需要几分钟的额外时间。我喜欢只链接对我的项目必要的库；这不仅能加速链接过程，而且在严格执行时，能为项目提供很好的文档。
- en: The *configure.scan* file contained 14 such calls to `AC_CHECK_LIB`. As it turned
    out, the FLAIM toolkit on my 64-bit Linux system only required three of them—*pthread*,
    *ncurses*, and *rt*—so I deleted the remaining entries and swapped out the placeholder
    parameters for real functions in the *ncurses* and *rt* libraries. In retrospect,
    it appears that my gambit paid off rather handsomely, because I dropped from 14
    libraries to 2\. The third library was the POSIX Thread (*pthreads*) library,
    which is added via the `AX_PTHREAD` macro I discussed in the previous section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*configure.scan* 文件包含了 14 个 `AC_CHECK_LIB` 的调用。事实证明，我的 64 位 Linux 系统上的 FLAIM
    工具包只需要其中的三个——*pthread*、*ncurses* 和 *rt*——所以我删除了剩下的条目，并用 *ncurses* 和 *rt* 库中的实际函数替换了占位符参数。回头看，这个策略似乎非常成功，因为我从
    14 个库减少到了 2 个。第三个库是 POSIX 线程（*pthreads*）库，通过我在前一节中讨论的 `AX_PTHREAD` 宏来添加。'
- en: I also converted the *ncurses* `AC_CHECK_LIB` call to `AC_SEARCH_LIBS` because
    I suspect that future FLAIM platforms may use different library names for *curses*
    functionality. I’d like to prepare the build system to have additional libraries
    searched on these platforms. The *ncurses* library is an optional library on most
    platforms, so I added the `AC_CHECK_HEADER` macro to check for *curses.h*, display
    a message in the *`action-if-not-found`* (third) argument that the user should
    install the *curses-development* package, and exit the configuration process with
    an error. The rule is to find problems early, during configuration, rather than
    during compilation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将 *ncurses* 的 `AC_CHECK_LIB` 调用转换为 `AC_SEARCH_LIBS`，因为我怀疑未来的 FLAIM 平台可能会使用不同的库名称来实现
    *curses* 功能。我希望为这些平台的构建系统做好准备，搜索额外的库。*ncurses* 库在大多数平台上是可选的，因此我添加了 `AC_CHECK_HEADER`
    宏来检查 *curses.h*，并在 *`action-if-not-found`*（第三个）参数中显示用户应安装 *curses-development*
    包的消息，同时以错误退出配置过程。这个规则是在配置阶段尽早发现问题，而不是在编译阶段。
- en: Maintainer-Defined Command Line Options
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 维护者定义的命令行选项
- en: The next four libraries are checked within an Autoconf conditional statement
    at ➍. This statement is based on the end user’s use of the `--enable-openssl`
    command line argument, which `AC_ARG_ENABLE` provides (see ➐ in [Listing 14-5](ch14.xhtml#ch14ex5)
    on [page 379](ch14.xhtml#page_379)).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四个库在 ➍ 处的 Autoconf 条件语句中进行了检查。这个语句基于最终用户使用 `--enable-openssl` 命令行参数，`AC_ARG_ENABLE`
    提供了该参数（请参见 [Listing 14-5](ch14.xhtml#ch14ex5) 中的 ➐，在 [第 379 页](ch14.xhtml#page_379)）。
- en: I use `AS_IF` here instead of a shell `if-then` statement because, if any of
    the macros called within the conditional statement require additional macros to
    be expanded in order to operate correctly, `AS_IF` will ensure that these dependencies
    are expanded first, outside of the conditional statement. As well as being part
    of the *M4sh* library, the `AS_IF` macro is part of the Autoconf auto-dependency
    framework (also discussed in detail in “Autoconf and M4” on [page 439](ch16.xhtml#page_439)).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用了 `AS_IF`，而不是 shell 的 `if-then` 语句，因为如果条件语句中的任何宏调用需要额外的宏来展开才能正常工作，`AS_IF`
    将确保这些依赖项首先在条件语句外部展开。`AS_IF` 宏不仅是 *M4sh* 库的一部分，也是 Autoconf 自动依赖框架的一部分（该框架在《Autoconf
    与 M4》一书的 [第 439 页](ch16.xhtml#page_439)中详细讨论）。
- en: In this case, the `openssl` variable is defined to either `yes` or `no` based
    on the default value given to `AC_ARG_ENABLE` and on the end user’s command line
    choices.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`openssl` 变量根据 `AC_ARG_ENABLE` 提供的默认值以及最终用户的命令行选项被定义为 `yes` 或 `no`。
- en: The `AC_DEFINE` macro, called in the first argument of `AS_IF`, ensures that
    the C-preprocessor variable `FLM_OPENSSL` is defined in the *config.h* header
    file. The `AC_CHECK_LIB` macros then ensure that `-lssl`, `-lcrypto`, `-ldl`,
    and `-lz` strings are added to the `LIBS` variable, but only if the `openssl`
    variable is set to `yes`. We don’t want to insist that the user have those libraries
    installed unless they have asked for features that need them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`AC_DEFINE`宏，在`AS_IF`的第一个参数中调用，确保C预处理器变量`FLM_OPENSSL`在*config.h*头文件中被定义。接着，`AC_CHECK_LIB`宏确保将`-lssl`、`-lcrypto`、`-ldl`和`-lz`字符串添加到`LIBS`变量中，但仅在`openssl`变量被设置为`yes`时才会添加。我们并不希望强制要求用户安装这些库，除非他们请求了需要这些库的功能。'
- en: 'You can get as sophisticated as you want when dealing with maintainer-defined
    command line options such as `--enable-openssl`. But be careful: some levels of
    automation can surprise your users. For instance, automatically enabling the option
    because your checks found that the OpenSSL libraries were installed and accessible
    can be a bit disconcerting.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在处理维护者定义的命令行选项（如`--enable-openssl`）时变得尽可能复杂。但要小心：某些级别的自动化可能会让用户感到惊讶。例如，自动启用该选项，因为你的检查发现OpenSSL库已安装并且可以访问，这可能会让人感到有些不安。
- en: I left all the header file and library function checks at ➎, as specified by
    `autoscan`, because a simple text scan through the source code for header files
    and function names is probably pretty accurate.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我把所有头文件和库函数检查都留在了➎位置，正如`autoscan`所规定的，因为通过源代码进行简单的文本扫描来查找头文件和函数名称可能相当准确。
- en: 'Notice, however, that `autoscan` did not put *all* of the header files used
    by ftk source code into the `AC_CHECK_HEADERS` argument. The `autoscan` utility’s
    algorithm is simple but effective: it adds all header files included conditionally
    by your source code. This approach assumes that any header file you include conditionally
    might be included differently on different platforms due to portability issues.
    While this approach is usually correct, it’s not always correct, so you should
    look at each of the headers added, find the conditional inclusion in your source
    code, and make a more intelligent assessment of whether or not it should be added
    to `AC_CHECK_HEADERS` in *configure.ac*.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，`autoscan`并没有将ftk源代码中使用的*所有*头文件都放入`AC_CHECK_HEADERS`参数中。`autoscan`工具的算法简单但有效：它会添加所有源代码中条件性包含的头文件。这种方法假设任何你条件性包含的头文件可能会由于移植性问题，在不同平台上以不同的方式包含。虽然这种方法通常是正确的，但并不总是正确的，所以你应该查看每个添加的头文件，找到源代码中的条件性包含，并更智能地评估是否应该将其添加到*configure.ac*中的`AC_CHECK_HEADERS`。
- en: A good example in this project is the conditional inclusion of *stdlib.h*. As
    it happens, *stdlib.h* is included for Windows builds, and it’s also included
    for Unix builds. It is not, however, included for NetWare builds. Regardless,
    it doesn’t really need to be checked for in `AC_CHECK_HEADERS` for two reasons.
    First, it’s widely standardized across platforms, and second, this build system
    is specifically designed for Unix systems.^([15](footnote.xhtml#ch14fn15)) The
    point is, you should carefully examine what `autoscan` does for you to determine
    if it should be done in your project.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，一个很好的例子是*stdlib.h*的条件性包含。事实上，*stdlib.h*会在Windows构建时包含，也会在Unix构建时包含。但它不会在NetWare构建时包含。无论如何，`AC_CHECK_HEADERS`中并不需要检查它，有两个原因。首先，它在平台间已经得到广泛标准化；其次，这个构建系统是专为Unix系统设计的。^([15](footnote.xhtml#ch14fn15))
    重点是，你应该仔细检查`autoscan`为你做了什么，以确定是否应该在你的项目中执行此操作。
- en: At ➏, we see the conditional (`AS_IF`) use of `AC_DEFINE` based on the contents
    of the `debug` variable. This is another environment variable that’s conditionally
    defined based on the results of a command line parameter given to `configure`.
    The `--enable-debug` option sets the debug variable to `yes`, which ultimately
    enables the `FLM_DEBUG` C-preprocessor definition within *config.h*. Both `FLM_OPENSSL`
    and `FLM_DEBUG` were already used within the FLAIM project source code. Using
    `AC_DEFINE` in this manner allows the end user to determine which features are
    compiled into the libraries.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在➏位置，我们看到基于`debug`变量内容的条件性（`AS_IF`）使用了`AC_DEFINE`。这是另一个环境变量，根据传递给`configure`的命令行参数的结果条件性地定义。`--enable-debug`选项将`debug`变量设置为`yes`，这最终启用了*config.h*中的`FLM_DEBUG`
    C预处理器定义。`FLM_OPENSSL`和`FLM_DEBUG`已经在FLAIM项目源代码中使用。以这种方式使用`AC_DEFINE`允许最终用户决定哪些功能被编译到库中。
- en: I left a fairly large chunk of code out of the listing at ➐ that deals with
    compiler and tool optimizations, which I’ll present in the next chapter. This
    code is identical in all of the projects’ *configure.ac* files.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 ➐ 处省略了一大块涉及编译器和工具优化的代码，这些代码将在下一章中呈现。这个代码在所有项目的 *configure.ac* 文件中都是相同的。
- en: Finally, I added references to the makefiles in the *docs*, *obs*, *src*, and
    *util* directories, as well as the *obs/flaimtk.spec* and *src/libflaimtk.pc*
    files at ➑ to the `AC_CONFIG_FILES` macro call, and then I added my usual `cat`
    statement at ➒ near the bottom for some visual verification of my configuration
    status. For now, just ignore the `sed` command right above the `cat` statement.
    I’ll cover that in “Transitive Dependencies” on [page 401](ch14.xhtml#page_401).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我将对位于 ➑ 处的 *docs*、*obs*、*src* 和 *util* 目录中的 makefile 以及 *obs/flaimtk.spec*
    和 *src/libflaimtk.pc* 文件添加了对 `AC_CONFIG_FILES` 宏调用的引用，并在底部附近添加了我常用的 `cat` 语句，作为对我的配置状态的可视化验证。现在，只需忽略
    `cat` 语句上方的 `sed` 命令。我将在《传递依赖》章节中详细介绍它，见 [第 401 页](ch14.xhtml#page_401)。
- en: '*The FLAIM Toolkit Makefile.am File*'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*FLAIM 工具包的 Makefile.am 文件*'
- en: If we ignore the commands for Doxygen- and RPM-specific targets (for now), the
    *ftk/Makefile.am* file is fairly trivial. [Listing 14-8](ch14.xhtml#ch14ex8) shows
    the entire file.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们暂时忽略 Doxygen 和 RPM 特定目标的命令，*ftk/Makefile.am* 文件相对简单。[Listing 14-8](ch14.xhtml#ch14ex8)
    显示了整个文件内容。
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 14-8*: ftk/Makefile.am: *The entire contents of the FLAIM toolkit’s
    top-level makefile*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-8*: ftk/Makefile.am: *FLAIM 工具包顶层 makefile 的全部内容*'
- en: In this file you’ll find the usual `ACLOCAL_AMFLAGS`, `EXTRA_DIST`, and `SUBDIRS`
    variable definitions, but you can also see the use of an Automake conditional
    at ➊. The `if` statement allows me to append another directory (*docs*) to the
    `SUBDIRS` list, but only if the `doxygen` program is available (according to `configure`).
    I used a separate variable here (`DOXYDIR`), but the Automake conditional could
    just as well have surrounded a statement that directly appends the directory name
    (`doc`) to the `SUBDIRS` variable using the Automake `+=` operator.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，你会发现常见的 `ACLOCAL_AMFLAGS`、`EXTRA_DIST` 和 `SUBDIRS` 变量定义，但你也可以看到在 ➊ 处使用了
    Automake 条件。`if` 语句允许我将另一个目录（*docs*）添加到 `SUBDIRS` 列表中，但前提是 `configure` 检测到 `doxygen`
    程序可用。我在这里使用了一个单独的变量（`DOXYDIR`），但 Automake 条件也可以直接包围一个语句，通过 Automake `+=` 运算符将目录名（`doc`）追加到
    `SUBDIRS` 变量中。
- en: '**NOTE**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Don’t confuse Automake conditionals with GNU Make conditionals, which use
    the keywords *`ifeq`*, *`ifneq`*, *`ifdef`*, and *`ifndef`*. If you try to use
    an Automake conditional in* Makefile.am *without a corresponding *`AM_CONDITIONAL`*
    statement in* configure.ac, *Automake will complain about it. When this construct
    is used properly, Automake converts it to something that *`make`* understands
    before *`make`* sees it.*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要将 Automake 条件与 GNU Make 条件混淆，后者使用关键字 *`ifeq`*、*`ifneq`*、*`ifdef`* 和 *`ifndef`*。如果你尝试在*Makefile.am*中使用一个
    Automake 条件，而没有在*configure.ac*中添加相应的 *`AM_CONDITIONAL`* 语句，Automake 会对此发出警告。正确使用这个结构时，Automake
    会在 *`make`* 看到它之前，将其转换为 *`make`* 可以理解的内容。*'
- en: Another new construct (at least in a top-level *Makefile.am* file) is the use
    of the `doc_DATA` variable at ➋. The FLAIM toolkit provides some extra documentation
    files in its top-level directory that I’d like to have installed. By using the
    `doc` prefix on the `DATA` primary, I’m telling Automake that I’d like these files
    to be installed as data files in the `$(docdir)` directory, which ultimately resolves
    to the `$(prefix)`*/share/doc* directory, by default.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个新的结构（至少在顶层 *Makefile.am* 文件中）是使用了 ➋ 处的 `doc_DATA` 变量。FLAIM 工具包在其顶层目录中提供了一些额外的文档文件，我希望将它们安装上。通过在
    `DATA` 主要部分使用 `doc` 前缀，我告诉 Automake 希望将这些文件作为数据文件安装到 `$(docdir)` 目录，默认情况下最终解析到
    `$(prefix)`*/share/doc* 目录中。
- en: Files mentioned in `DATA` variables that don’t already have special meaning
    to Automake are not automatically distributed (that is, they’re not added to distribution
    tarballs), so you have to manually distribute them by adding them to the files
    listed in the `EXTRA_DIST` variable.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DATA` 变量中提到的文件，如果它们没有 Automake 的特殊含义，默认不会自动分发（即不会被加入到分发的 tar 包中），因此你需要手动分发它们，方法是将它们添加到
    `EXTRA_DIST` 变量中列出的文件中。
- en: '**NOTE**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I did not have to list the standard GNU project text files in *`EXTRA_DIST`*
    because they’re always distributed automatically. However, I did have to mention
    theses files in the *`doc_DATA`* variable, because Automake makes no assumptions
    about which files you want to install.*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*我不需要在 *`EXTRA_DIST`* 中列出标准的 GNU 项目文本文件，因为它们总是会自动分发。然而，我确实需要在 *`doc_DATA`*
    变量中提到这些文件，因为 Automake 不假设你想要安装哪些文件。*'
- en: I’ll defer a discussion of the RPM targets at ➌ to the next chapter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我将推迟讨论 ➌ 处的 RPM 目标，直到下一章。
- en: Automake -hook and -local Rules
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Automake -hook 和 -local 规则
- en: 'Automake recognizes two types of integrated extensions, which I call `-local`
    targets and `-hook` targets. Automake recognizes and honors `-local` extensions
    for the following standard targets:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Automake 识别两种类型的集成扩展，我称之为 `-local` 目标和 `-hook` 目标。Automake 识别并遵循 `-local` 扩展，适用于以下标准目标：
- en: '| `all` | `install-data` | `installcheck` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `all` | `install-data` | `installcheck` |'
- en: '| `check` | `install-dvi` | `installdirs` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `check` | `install-dvi` | `installdirs` |'
- en: '| `clean` | `install-exec` | `maintainer-clean` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `clean` | `install-exec` | `maintainer-clean` |'
- en: '| `distclean` | `install-html` | `mostlyclean` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `distclean` | `install-html` | `mostlyclean` |'
- en: '| `dvi` | `install-info` | `pdf` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `dvi` | `install-info` | `pdf` |'
- en: '| `html` | `install-pdf` | `ps` |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `html` | `install-pdf` | `ps` |'
- en: '| `info` | `install-ps` | `uninstall` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `info` | `install-ps` | `uninstall` |'
- en: Appending `-local` to any of these in your *Makefile.am* files will cause the
    associated commands to be executed *before* the standard target. Automake does
    this by generating the rule for the standard target so that the `-local` version
    is one of its dependencies (if it exists).^([16](footnote.xhtml#ch14fn16)) In
    “Cleaning Your Room” on [page 404](ch14.xhtml#page_404), I’ll show an example
    of this concept using a `clean-local` target.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 *Makefile.am* 文件中将 `-local` 添加到这些目标中的任何一个，将导致相关命令在标准目标 *之前* 执行。Automake
    通过为标准目标生成规则来实现这一点，使得 `-local` 版本成为其依赖项之一（如果存在的话）。^([16](footnote.xhtml#ch14fn16))
    在《整理你的房间》（见 [第404页](ch14.xhtml#page_404)）中，我将展示一个使用 `clean-local` 目标的示例。
- en: The `-hook` targets are a bit different in that they are executed *after* the
    corresponding standard target is executed.^([17](footnote.xhtml#ch14fn17)) Automake
    does this by adding another command to the end of the standard target command
    list. This command merely executes `$(MAKE)` on the containing makefile, with
    the `-hook` target as the command line target. Thus, the `-hook` target is executed
    at the end of the standard target commands in a recursive fashion.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`-hook` 目标稍有不同，它们在相应的标准目标执行 *之后* 执行。^([17](footnote.xhtml#ch14fn17)) Automake
    通过在标准目标命令列表的末尾添加另一个命令来实现这一点。该命令仅执行 `$(MAKE)` 在包含的 makefile 上，将 `-hook` 目标作为命令行目标。因此，`-hook`
    目标以递归方式在标准目标命令的末尾执行。'
- en: 'The following standard Automake targets support `-hook` versions:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标准的 Automake 目标支持 `-hook` 版本：
- en: '| `dist` | `install-data` | `uninstall` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `dist` | `install-data` | `uninstall` |'
- en: '| `distcheck` | `install-exec` |  |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `distcheck` | `install-exec` |  |'
- en: Automake automatically adds all existing `-local` and `-hook` targets to the
    `.PHONY` rule within the generated makefile.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Automake 会自动将所有现有的 `-local` 和 `-hook` 目标添加到生成的 makefile 中的 `.PHONY` 规则中。
- en: In the first edition of this book, I used the `dist-hook` target at ➍ in *Makefile.am*
    (now commented out) to adjust the distribution directory after it’s built but
    before `make` builds a distribution archive from its contents. The `rm` command
    removed extraneous files and directories that became part of the distribution
    directory as a result of my adding entire directories to the `EXTRA_DIST` variable.
    When you add directory names to `EXTRA_DIST` (*debian*, *netware*, and *win32*,
    in this case), everything in those directories is added to the distribution—even
    hidden repository control files and directories.^([18](footnote.xhtml#ch14fn18))
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一版中，我在 *Makefile.am* 中使用了 `dist-hook` 目标（现在已被注释掉）来调整分发目录，调整发生在构建后，但在 `make`
    从其内容构建分发档案之前。`rm` 命令删除了由于我将整个目录添加到 `EXTRA_DIST` 变量中而成为分发目录一部分的多余文件和目录。当你将目录名称添加到
    `EXTRA_DIST` 中时（在本例中为 *debian*、*netware* 和 *win32*），这些目录中的所有内容都会被添加到分发中——甚至包括隐藏的仓库控制文件和目录。^([18](footnote.xhtml#ch14fn18))
- en: '[Listing 14-9](ch14.xhtml#ch14ex9) is a portion of the generated *Makefile*
    that shows how Automake incorporates `dist-hook` into the final makefile. The
    relevant portions are highlighted.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 14-9](ch14.xhtml#ch14ex9) 是生成的 *Makefile* 的一部分，展示了 Automake 如何将 `dist-hook`
    融入到最终的 makefile 中。相关部分已被高亮显示。'
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 14-9: The results of defining the `dist-hook` target in* ftk/Makefile.am'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-9：定义 `dist-hook` 目标的结果，在* ftk/Makefile.am'
- en: '**NOTE**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Don’t be afraid to dig into the generated makefiles to see exactly what Automake
    is doing with your code. While there is a fair amount of ugly shell code in the
    *`make`* commands, most of it is safe to ignore. You’re usually more interested
    in the *`make`* rules that Automake is generating, and it’s easy to separate these
    out.*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要害怕深入生成的makefile，查看Automake如何处理你的代码。虽然*`make`*命令中有相当多的丑陋shell代码，但大多数可以忽略。你通常更关心Automake生成的*`make`*规则，且很容易将它们分离出来。*'
- en: '*Designing the ftk/src/Makefile.am File*'
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*设计ftk/src/Makefile.am文件*'
- en: 'I now need to create *Makefile.am* files in the *src* and *utils* directories
    for the FLAIM toolkit project. I want to ensure that all of the original functionality
    is preserved from the old build system as I’m creating these files. Basically,
    this includes:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在需要在FLAIM工具包项目的*src*和*utils*目录中创建*Makefile.am*文件。在创建这些文件时，我希望确保所有原有功能都得以保留。基本上，这包括：
- en: Properly building the ftk shared and static libraries
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确构建ftk共享和静态库
- en: Properly specifying installation locations for all installed files
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确指定所有已安装文件的安装位置
- en: Setting the ftk shared-library version information correctly
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确设置ftk共享库的版本信息
- en: Ensuring that all remaining unused files are distributed
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保所有剩余的未使用文件都被分发
- en: Ensuring that platform-specific compiler options are used
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保使用平台特定的编译器选项
- en: The template shown in [Listing 14-10](ch14.xhtml#ch14ex10) should cover most
    of these points, so I’ll be using it for all of the FLAIM library projects, with
    appropriate additions and subtractions, based on the needs of each individual
    library.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单14-10](ch14.xhtml#ch14ex10)中展示的模板应该涵盖大多数这些要点，因此我将在所有FLAIM库项目中使用它，并根据每个库的需求进行适当的增减。
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 14-10: A framework for the src and utils directory* Makefile.am *files*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单14-10：src和utils目录的框架* Makefile.am *文件*'
- en: The original *GNUMakefile* told me that the library was named *libftk.so*. This
    is a bad name for a library on Linux, because most of the three-letter library
    names are already taken. Thus, I made an executive decision and renamed the *ftk*
    library to *flaimtk*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的*GNUMakefile*告诉我库的名称是*libftk.so*。这个名字在Linux上并不好，因为大多数三字母的库名已经被占用了。因此，我做出了一个决定，将*ftk*库重命名为*flaimtk*。
- en: '[Listing 14-11](ch14.xhtml#ch14ex11) shows most of the final *ftk/src/Makefile.am*
    file.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单14-11](ch14.xhtml#ch14ex11)显示了最终的*ftk/src/Makefile.am*文件的大部分内容。'
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 14-11*: ftk/src/Makefile.am: *The entire file contents, minus a few
    dozen source files*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单14-11*：ftk/src/Makefile.am：*整个文件内容，减去一些几十个源文件*'
- en: 'I added the Libtool library name, *libflaimtk.la*, to the `lib_LTLIBRARIES`
    list at ➋ and changed the *`xxxxx`* portions of the remaining macros in [Listing
    14-10](ch14.xhtml#ch14ex10) to `libflaimtk`. I could have entered all the source
    files by hand, but I noticed while reading the original makefile that it used
    the GNU `make` function macro `$(wildcard src/*.cpp)` to build the file list from
    the contents of the *src* directory. This tells me that all of the *.cpp* files
    within the *src* directory are required (or at least consumed) by the library.
    To get the file list into *Makefile.am*, I used a simple shell command to concatenate
    it to the end of the *Makefile.am* file (assuming I’m in the *ftk/src* directory):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我将Libtool库名称*libflaimtk.la*添加到`lib_LTLIBRARIES`列表中的➋，并将[清单14-10](ch14.xhtml#ch14ex10)中其余宏的*`xxxxx`*部分更改为`libflaimtk`。我本可以手动输入所有源文件，但在阅读原始makefile时，我注意到它使用了GNU
    `make`的函数宏`$(wildcard src/*.cpp)`来从*src*目录的内容构建文件列表。这告诉我，*src*目录中的所有*.cpp*文件都是库所需的（或者至少会被使用）。为了将文件列表添加到*Makefile.am*中，我使用了一个简单的shell命令，将其拼接到*Makefile.am*文件的末尾（假设我在*ftk/src*目录中）：
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This left me with a single-column, backslash-terminated, alphabetized list of
    all of the *.cpp* files in the *ftk/src* directory at the bottom of *ftk/src/Makefile.am*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我在*ftk/src/Makefile.am*的底部得到了一个单列、以反斜杠结束、按字母顺序排列的所有*.cpp*文件列表。
- en: '**NOTE**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Do not forget the single quotes around the *`printf`* argument, which are
    necessary to keep the first pair of backslashes from being interpreted by the
    shell as escape characters during generation of the list. Regardless of quoting,
    *`printf`* understands and interprets the *`\n`* character properly.*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要忘记在*`printf`*参数周围加上单引号，这对于防止在生成列表时，第一个反斜杠对shell作为转义字符的解释是必要的。不管怎么引用，*`printf`*都会正确理解并解析*`\n`*字符。*'
- en: I moved the list up to just below the `libflaimtk_la_SOURCES` line at ➎, added
    a backslash character after the equal sign, and removed the one after the last
    file. Another formatting technique is to simply wrap the line with a backslash
    and a carriage return approximately every 70 characters, but I prefer to put each
    file on a separate line, especially early in the conversion process, so I can
    easily extract files from or add files to the lists as needed. Leaving the files
    on separate lines also gets you the benefit of having source lists be easier to
    compare when reviewing differences in pull-request reviews and other `diff`-style
    output.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我将列表移到`libflaimtk_la_SOURCES`行下方➎，在等号后添加了一个反斜杠字符，并删除了最后一个文件后的反斜杠。另一种格式化技巧是简单地在每大约70个字符后用反斜杠和换行符包裹一行，但我更倾向于将每个文件放在单独的一行，特别是在转换过程的早期，这样我可以根据需要轻松地从列表中提取文件或添加文件。将文件放在单独的行上还能带来一个好处，即在查看拉取请求和其他`diff`风格的输出时，源文件列表更容易进行对比。
- en: I had to manually examine each header file in the *src* directory in order to
    determine its use in the project. There were only four header files, and, as it
    turns out, the only one the FLAIM toolkit does *not* use on Unix and Linux platforms
    is *ftknlm.h*, which is specific to the NetWare build. I added this file to the
    `EXTRA_DIST` list at ➊ so it would be distributed; just because the build doesn’t
    use it doesn’t mean that users won’t want or need it.^([19](footnote.xhtml#ch14fn19))
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须手动检查*src*目录中的每个头文件，以确定它在项目中的使用情况。这里只有四个头文件，结果发现，FLAIM工具包在Unix和Linux平台上唯一没有使用的是*ftknlm.h*，它是专门用于NetWare构建的。我将这个文件添加到➊位置的`EXTRA_DIST`列表中，以便进行分发；仅仅因为构建不使用它并不意味着用户不需要或不希望使用它。^([19](footnote.xhtml#ch14fn19))
- en: The (newly renamed) *flaimtk.h* file is the only public header file, so I moved
    it into the `include_HEADERS` list at ➌. The other two files are used internally
    in the library build, so I left them in the `libflaimtk_la_SOURCES` list. Had
    this been my own project, I would have moved *flaimtk.h* into an *include* directory
    off the project root directory, but remember that one of my goals here was to
    limit changes to the directory structure and the source code. Moving this header
    file is a philosophical decision that I decided to leave to the maintainers.^([20](footnote.xhtml#ch14fn20))
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: （重新命名后的）*flaimtk.h*文件是唯一的公共头文件，因此我将它移入了➌位置的`include_HEADERS`列表。其他两个文件在库的构建过程中是内部使用的，因此我将它们保留在`libflaimtk_la_SOURCES`列表中。如果这是我自己的项目，我会将*flaimtk.h*移动到项目根目录下的*include*目录中，但记住，我的一个目标是尽量限制对目录结构和源代码的更改。移动这个头文件是一个哲学性的决定，我决定将其留给维护者来做出决定。^([20](footnote.xhtml#ch14fn20))
- en: Finally, I noticed in the original makefile that the last release of the *ftk*
    library published an interface version of 4.0\. However, since I changed the name
    of the library from *libftk* to *libflaimtk*, I reset this value to 0.0 because
    it’s a different library. I replaced *`x`*`:`*`y`*`:`*`z`* with `0:0:0` in the
    `-version-info` option at ➏ within the `libflaimtk_la_LDFLAGS` variable.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我在原始makefile中注意到，*ftk*库的最后一个版本发布了4.0的接口版本。然而，由于我将库的名称从*libftk*更改为*libflaimtk*，我将此值重置为0.0，因为它是一个不同的库。我在➏位置的`libflaimtk_la_LDFLAGS`变量中的`-version-info`选项里将*`x`*`:`*`y`*`:`*`z`*替换为`0:0:0`。
- en: '**NOTE**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A version string of *`0:0:0`* is the default, so I could have removed the
    argument entirely and achieved the same result. However, including it gives new
    developers some insight into how to change the interface version in the future.*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*`0:0:0`的版本字符串是默认值，因此我本可以完全移除该参数并达到相同的效果。然而，包含它可以为新开发者提供一些关于如何在未来更改接口版本的见解。*'
- en: I added the `pkgconfigdir` and `pkgconfig_DATA` variables at ➍ in order to provide
    support for installing pkg-config metadata files for this project. For more on
    the pkg-config system, see [Chapter 10](ch10.xhtml).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我在➍位置添加了`pkgconfigdir`和`pkgconfig_DATA`变量，以便为此项目提供支持安装pkg-config元数据文件的功能。有关pkg-config系统的更多信息，请参见[第10章](ch10.xhtml)。
- en: '*Moving On to the ftk/util Directory*'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*继续处理ftk/util目录*'
- en: 'Properly designing *Makefile.am* for the *util* directory requires examining
    the original makefile again for more products. A quick glance at the *ftk/util*
    directory showed that there was only one source file: *ftktest.cpp*. This appeared
    to be some sort of testing program for the *ftk* library, but I know that the
    FLAIM developers use it all the time in various ways besides simply for testing
    a build. So I had a design decision to make here: should I build this as a normal
    program or as a check program?'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正确设计*Makefile.am*用于*util*目录时，需要再次检查原始的makefile，以便支持更多的产品。快速浏览*ftk/util*目录后发现，那里只有一个源文件：*ftktest.cpp*。这看起来像是一个针对*ftk*库的测试程序，但我知道FLAIM的开发者在多种场景中都在使用它，除了仅仅用于测试构建。所以在这里，我需要做出一个设计决策：我应该把它作为一个普通程序还是作为一个检查程序来构建？
- en: '*Check programs* are only built when `make check` is executed, and they’re
    never installed. If I want `ftktest` built as a regular program, but not installed,
    I have to use the `noinst` prefix rather than the usual `bin` prefix in the program
    list variable.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*检查程序*只有在执行`make check`时才会被构建，并且它们永远不会被安装。如果我希望`ftktest`作为常规程序构建，但不安装，我必须在程序列表变量中使用`noinst`前缀，而不是通常的`bin`前缀。'
- en: In either case, I probably want to add `ftktest` to the list of tests that are
    executed during `make check`, so the two questions here are (1) whether I want
    to automatically run `ftktest` during `make check` and (2) whether I want to install
    the `ftktest` program. Given that the FLAIM toolkit is a mature product, I opted
    to build `ftktest` during `make check` and leave it uninstalled.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，我可能都希望将`ftktest`添加到`make check`期间执行的测试列表中，所以这里有两个问题：（1）我是否希望在`make check`期间自动运行`ftktest`，（2）我是否希望安装`ftktest`程序。考虑到FLAIM工具包是一个成熟的产品，我选择在`make
    check`期间构建`ftktest`并保持它未安装。
- en: Listing 14-12 shows my final *ftk/util/Makefile.am* file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-12展示了我的最终*ftk/util/Makefile.am*文件。
- en: '[PRE22]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 14-12*: ftk/util/Makefile.am: *The final contents of this file*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表14-12*：ftk/util/Makefile.am：*此文件的最终内容*'
- en: I hope that by now you can see the relationship between `TESTS` and `check_PROGRAMS`.
    To be blunt, there really is *no* relationship between the files listed in `check_PROGRAMS`
    and those listed in `TESTS`. The `check` target simply ensures that `check_PROGRAMS`
    are built before the `TESTS` programs and scripts are executed. `TESTS` can refer
    to anything that can be executed without command line parameters. This separation
    of duties makes for a very clean and flexible system.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望到现在为止你已经理解了`TESTS`和`check_PROGRAMS`之间的关系。坦率地说，`check_PROGRAMS`中列出的文件与`TESTS`中列出的文件之间**没有**任何关系。`check`目标只是确保在执行`TESTS`程序和脚本之前，`check_PROGRAMS`已经被构建。`TESTS`可以指任何不需要命令行参数即可执行的内容。这种职责分离使得系统非常简洁且灵活。
- en: And that’s it for the FLAIM toolkit library and utilities. I don’t know about
    you, but I’d much rather maintain this small set of short files than a single
    2,200-line makefile!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是FLAIM工具包库和工具的全部内容。我不知道你怎么想，但我宁愿维护这一小组简短的文件，而不愿意去维护一个单一的2,200行的makefile！
- en: Designing the XFLAIM Build System
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计XFLAIM构建系统
- en: Now that I’ve finished with the FLAIM toolkit, I’ll move on to the xflaim project.
    I’m choosing to start with xflaim, rather than flaim, because it supplies the
    most build features that can be converted to the Autotools, including the Java
    and C# language bindings (which I won’t actually discuss in detail until the next
    chapter). After xflaim, covering the remaining database projects would be redundant,
    because the processes are identical, if not a little simpler. However, you can
    find the other build system files in this book’s GitHub repositories.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我完成了FLAIM工具包的工作，接下来我将进入xflaim项目。我选择从xflaim开始，而不是flaim，因为它提供了最多的构建功能，可以转换为Autotools，包括Java和C#语言绑定（这些内容我将在下一章详细讨论）。在完成xflaim之后，覆盖其余的数据库项目就显得多余了，因为它们的过程是相同的，甚至更简单一些。不过，你可以在本书的GitHub仓库中找到其他构建系统文件。
- en: I generated the *configure.ac* file using `autoscan` once again. It’s important
    to use `autoscan` in each of the individual projects, because the source code
    for each project is different and will thus cause different macros to be written
    into each *configure.scan* file.^([21](footnote.xhtml#ch14fn21)) I then used the
    same techniques I used on the FLAIM toolkit to create xflaim’s *configure.ac*
    file.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我再次使用`autoscan`生成了*configure.ac*文件。在每个独立项目中使用`autoscan`非常重要，因为每个项目的源代码不同，因此会导致不同的宏被写入每个*configure.scan*文件中。^([21](footnote.xhtml#ch14fn21))
    接着，我使用了在FLAIM工具包中使用的相同技术来创建xflaim的*configure.ac*文件。
- en: '*The XFLAIM configure.ac File*'
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*XFLAIM的configure.ac文件*'
- en: After hand-modifying the generated *configure.scan* file and renaming it *configure.ac*,
    I found it to be similar in many ways to the toolkit’s *configure.ac* file. It’s
    fairly long, so I’ll show you only the most significant differences in [Listing
    14-13](ch14.xhtml#ch14ex13).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在手动修改生成的*configure.scan*文件并将其重命名为*configure.ac*之后，我发现它在许多方面与工具包的*configure.ac*文件类似。它相当长，因此我只会展示[列表14-13](ch14.xhtml#ch14ex13)中的最重要区别。
- en: '[PRE23]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 14-13*: xflaim/configure.ac: *The most significant portions of this
    Autoconf input file*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表14-13*：xflaim/configure.ac：*这个Autoconf输入文件中最重要的部分*'
- en: 'First, notice that I’ve invented a few more `FLM_PROG_TRY_*` macros at ➊. Here
    I’m checking for the existence of the following programs: a C# compiler, a C#
    virtual machine, a Java compiler, a JNI header and stub generator, a Javadoc generation
    tool, a Java archive tool, and Doxygen. I’ve written separate macro files for
    each of these checks and added them to my *xflaim/m4* directory.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意到我在➊处发明了几个更多的`FLM_PROG_TRY_*`宏。在这里，我正在检查以下程序的存在：C#编译器、C#虚拟机、Java编译器、JNI头文件和存根生成器、Javadoc生成工具、Java归档工具和Doxygen。我为这些检查编写了单独的宏文件，并将它们添加到我的*xflaim/m4*目录中。
- en: As with the `FLM_PROG_TRY_DOXYGEN` macro used in the toolkit, each of these
    macros attempts to locate the associated program, but these macros don’t fail
    the configuration process if they can’t find the program. I want to be able to
    use these programs if they’re available, but I don’t want to require the user
    to have them in order to build the base libraries.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 与工具包中使用的`FLM_PROG_TRY_DOXYGEN`宏一样，这些宏中的每一个都会尝试定位相关程序，但如果找不到程序，它们不会导致配置过程失败。我希望在这些程序可用时能使用它们，但不希望要求用户必须拥有它们才能构建基础库。
- en: You’ll find a new macro, `AC_ARG_VAR`, at ➋. Like the `AC_ARG_ENABLE` and `AC_ARG_WITH`
    macros, `AC_ARG_VAR` allows the project maintainer to extend the command line
    interface of the `configure` script. This macro is different, however, in that
    it adds a public variable, rather than a command line option, to the list of public
    variables that `configure` cares about. In this case, I’m adding two public variables,
    `FTKINC` and `FTKLIB`. These will show up in `configure`’s help text under the
    section “Some influential environment variables.” The *GNU Autoconf Manual* calls
    these variables *precious*. All of my `FLM_PROG_TRY_*` macros use the `AC_ARG_VAR`
    macro internally to make the associated variables both public and precious.^([22](footnote.xhtml#ch14fn22))
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在➋处找到一个新宏，`AC_ARG_VAR`。像`AC_ARG_ENABLE`和`AC_ARG_WITH`宏一样，`AC_ARG_VAR`允许项目维护者扩展`configure`脚本的命令行接口。然而，这个宏不同之处在于，它将一个公共变量，而不是命令行选项，添加到`configure`关心的公共变量列表中。在这个例子中，我添加了两个公共变量，`FTKINC`和`FTKLIB`。它们将在`configure`的帮助文本中出现在“一些影响环境变量”部分下。*GNU
    Autoconf手册*将这些变量称为*珍贵的*。我的所有`FLM_PROG_TRY_*`宏都在内部使用`AC_ARG_VAR`宏，使相关变量既是公共的，也是珍贵的。^([22](footnote.xhtml#ch14fn22))
- en: '**NOTE**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The lines of code from* ➋ *through* ➐ *are found in the GitHub repository
    under* xflaim/m4/flm_ftk_search.m4\. *By the end of [Chapter 15](ch15.xhtml),
    all discrepancies are resolved between the listings in this chapter and the files
    in the GitHub repository.*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*从* ➋ *到* ➐ *的代码行可以在GitHub仓库的* xflaim/m4/flm_ftk_search.m4 *中找到*。*到[第15章](ch15.xhtml)结束时，本章中的列表和GitHub仓库中的文件之间的所有差异都已解决。*'
- en: 'The large chunk of code beginning at ➌ actually uses these variables to set
    other variables used in the build system. The user can set the public variables
    in the environment, or they can specify them on `configure`’s command line in
    this manner:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从➌开始的大段代码实际上使用这些变量来设置构建系统中使用的其他变量。用户可以在环境中设置这些公共变量，或者可以通过这种方式在`configure`的命令行上指定它们：
- en: '[PRE24]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First, I’ll check to see that either both or neither of the `FTKINC` and `FTKLIB`
    variables is specified. If only one of them is given, I have to fail with an error.
    The user isn’t allowed to tell me where to find only *half* the toolkit; I need
    both the header file and the library.^([23](footnote.xhtml#ch14fn23)) If neither
    of these variables is specified, I search for them at ➍ by looking for a subdirectory
    of the xflaim project directory called *ftk*. If I find one, I’ll configure that
    directory as a subproject to be processed by Autoconf, using the `AC_CONFIG_SUBDIRS`
    macro.^([24](footnote.xhtml#ch14fn24)) I’ll also set both of these variables to
    point to the appropriate relative locations within the ftk subproject.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我会检查`FTKINC`和`FTKLIB`变量是否都指定了，或者都没有指定。如果只指定了其中一个，我必须因为出错而失败。用户不能只告诉我在哪里找到*半*个工具包；我需要同时拥有头文件和库。^([23](footnote.xhtml#ch14fn23))
    如果这两个变量都没有指定，我会在➍通过查找名为*ftk*的子目录来寻找它们。如果找到了，我将使用`AC_CONFIG_SUBDIRS`宏将该目录配置为一个由Autoconf处理的子项目。^([24](footnote.xhtml#ch14fn24))
    我还会将这两个变量设置为指向ftk子项目中适当的相对位置。
- en: 'If I don’t find *ftk* as a subdirectory, I’ll look for it in the parent directory
    at ➎. If I find it there, I’ll set the variables appropriately. This time, I don’t
    need to configure the located *ftk* directory as a subproject, because I’m assuming
    that the xflaim project is itself a subproject of the umbrella project. If I don’t
    find *ftk* as either a subproject or a sibling project, I’ll use the standard
    `AC_CHECK_LIB` and `AC_CHECK_HEADERS` macros at ➏ to see if the user’s host has
    the toolkit library installed. In that case, I need only add `-lflaimtk` to the
    `LIBS` variable. Also in that case, the header file will be in the standard location:
    usually */usr(/local)/include*. The default functionality of the optional third
    argument to `AC_CHECK_LIB` would automatically add the library reference to the
    `LIBS` variable, but since I’ve overridden this default functionality, I have
    to manually add the toolkit library reference to `LIBS`.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到*ftk*子目录，我会在父目录的➎查找。如果在那里找到了，我会相应地设置变量。这次，我不需要将找到的*ftk*目录配置为子项目，因为我假设xflaim项目本身是上层项目的一个子项目。如果我没有找到*ftk*，无论是作为子项目还是同级项目，我会在➏使用标准的`AC_CHECK_LIB`和`AC_CHECK_HEADERS`宏来检查用户的主机是否安装了工具包库。在这种情况下，我只需要将`-lflaimtk`添加到`LIBS`变量中。在这种情况下，头文件将位于标准位置：通常是*/usr(/local)/include*。`AC_CHECK_LIB`的可选第三个参数的默认功能会自动将库引用添加到`LIBS`变量中，但由于我覆盖了这个默认功能，我必须手动将工具包库引用添加到`LIBS`中。
- en: If I don’t find the library, I give up with an error message indicating that
    xflaim can’t be built without the FLAIM toolkit. However, after making it through
    all these checks, if the `FTKLIB` variable is no longer empty, I use `AC_SUBST`
    at ➐ to publish the `FTK_INCLUDE` and `FTK_LTLIB` variables, which contain derivations
    of `FTKINC` and `FTKLIB` appropriate for use as command line options to the preprocessor
    and the linker.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到库，我会放弃并显示一个错误信息，提示xflaim无法在没有FLAIM工具包的情况下构建。然而，在通过所有这些检查后，如果`FTKLIB`变量不再为空，我会在➐使用`AC_SUBST`来发布`FTK_INCLUDE`和`FTK_LTLIB`变量，这些变量包含适用于预处理器和链接器命令行选项的`FTKINC`和`FTKLIB`的衍生值。
- en: '**NOTE**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*[Chapter 16](ch16.xhtml) converts the large chunk of code between* ➌ *and*
    ➑ *into a custom M4 macro called *`FLM_FTK_SEARCH`**.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*[第16章](ch16.xhtml)将➌到➑之间的大段代码转换成一个名为*`FLM_FTK_SEARCH`*的自定义M4宏。*'
- en: The remaining code at ➑ calls `AM_CONDITIONAL` for Java, C#, and Doxygen in
    a manner similar to the way I handled Doxygen in the ftk project. These macros
    are configured to generate warning messages indicating that the Java or C# portions
    of the xflaim project will not be built if those tools can’t be found, but I allow
    the build to continue in any case.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ➑处的剩余代码以类似于我在ftk项目中处理Doxygen的方式，调用`AM_CONDITIONAL`来处理Java、C#和Doxygen。这些宏配置为生成警告信息，指出如果找不到Java或C#工具，xflaim项目的这些部分将不会被构建，但无论如何，我允许构建继续进行。
- en: '*Creating the xflaim/src/Makefile.am File*'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*创建 xflaim/src/Makefile.am 文件*'
- en: 'I’m skipping the *xflaim/Makefile.am* file, because it’s nearly identical to
    *ftk/Makefile.am*. Instead, we’ll move on to *xflaim/src/Makefile.am*, which I
    wrote by following the same design principles used with the *ftk/src* version.
    It looks very similar to its ftk counterpart, with one exception: according to
    the original build system makefile, the Java native interface (JNI) and C# native
    language–binding sources are compiled and linked right into the *xflaim* shared
    library.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我跳过了*xflaim/Makefile.am*文件，因为它与*ftk/Makefile.am*几乎相同。相反，我们将继续讨论*xflaim/src/Makefile.am*，这是我按照与*ftk/src*版本相同的设计原则编写的。它看起来与ftk的对应文件非常相似，唯一的例外是：根据原始构建系统的makefile，Java本地接口（JNI）和C#本地语言绑定源文件直接编译并链接到*xflaim*共享库中。
- en: This is not an uncommon practice, and it’s quite useful because it alleviates
    the need for extra library objects built specifically for these languages. Essentially,
    the *xflaim* shared library exports native interfaces for these languages, which
    are then consumed by their corresponding native wrappers.^([25](footnote.xhtml#ch14fn25))
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一种不常见的做法，而且非常有用，因为它避免了为这些语言专门构建额外的库对象。基本上，*xflaim*共享库导出了这些语言的本地接口，然后这些接口被相应的本地封装器使用。^([25](footnote.xhtml#ch14fn25))
- en: I’m going to ignore these language bindings for now, but later, when I’m finished
    with the entire xflaim project, I’ll turn my attention back to properly hooking
    them into the library. With this exception then, the *Makefile.am* file shown
    in [Listing 14-14](ch14.xhtml#ch14ex14) looks almost identical to its ftk counterpart.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在暂时忽略这些语言绑定，但稍后当我完成整个xflaim项目时，我会重新关注如何将它们正确地集成到库中。除去这个例外，[清单14-14](ch14.xhtml#ch14ex14)中展示的*Makefile.am*文件与其ftk对应文件几乎一模一样。
- en: '[PRE25]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 14-14*: xflaim/src/Makefile.am: *The xflaim project src directory
    Automake input file*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单14-14*：xflaim/src/Makefile.am：*xflaim项目src目录的Automake输入文件*'
- en: I’ve conditionally defined the contents of the `SUBDIRS` variable here based
    on variables defined by corresponding Automake conditional statements in *configure.ac*.
    When `make all` is executed, the `SUBDIRS` variable conditionally recurses into
    the *java* and *cs* subdirectories. But when `make dist` is executed, a hidden
    `DIST_SUBDIRS` variable (which is created by Automake from *all of the possible
    contents* of the `SUBDIRS` variable) references all directories appended, either
    conditionally or unconditionally, to `SUBDIRS`.^([26](footnote.xhtml#ch14fn26))
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我根据*configure.ac*中相应Automake条件语句定义了`SUBDIRS`变量的内容。当执行`make all`时，`SUBDIRS`变量会根据条件递归到*java*和*cs*子目录中。但当执行`make
    dist`时，一个隐藏的`DIST_SUBDIRS`变量（由Automake根据`SUBDIRS`变量的*所有可能内容*创建）引用了无论是条件性还是无条件附加到`SUBDIRS`中的所有目录。^([26](footnote.xhtml#ch14fn26))
- en: '**NOTE**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The library interface version information was extracted from the original
    makefile.*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*库接口版本信息是从原始makefile中提取的。*'
- en: '*Turning to the xflaim/util Directory*'
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*转向xflaim/util目录*'
- en: The *util* directory for xflaim is a bit more complex. According to the original
    makefile, it generates several utility programs as well as a convenience library
    that is consumed by these utilities.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: xflaim的*util*目录稍微复杂一些。根据原始makefile，它生成了几个实用程序以及一个被这些工具使用的便捷库。
- en: It was somewhat more difficult to find out which source files belong to which
    utilities and which were not used at all. Several of the files in the *xflaim/util*
    directory are not used by any of the utilities. Do we distribute these extra source
    files? I chose to do so, because they were already being distributed by the original
    build system and adding them to the `EXTRA_DIST` list makes it obvious to later
    observers that they aren’t used.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 找出哪些源文件属于哪些工具，哪些根本没有被使用，稍微有些困难。*xflaim/util*目录中的几个文件并没有被任何工具使用。我们是否需要分发这些额外的源文件？我选择分发它们，因为它们已经被原始构建系统分发，并将它们添加到`EXTRA_DIST`列表中使得后来的人可以明显看出它们没有被使用。
- en: '[Listing 14-15](ch14.xhtml#ch14ex15) shows a portion of the *xflaim/util/Makefile.am*
    file; the parts that are missing are redundant.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单14-15](ch14.xhtml#ch14ex15)展示了*xflaim/util/Makefile.am*文件的一部分；缺失的部分是冗余的。'
- en: '[PRE26]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 14-15*: xflaim/util/Makefile.am: *The xflaim project’s* util *directory
    Automake input file*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单14-15*：xflaim/util/Makefile.am：*xflaim项目的* util *目录Automake输入文件*'
- en: In this example, you can see by the elided sections that I left out several
    long lists of files and products. This makefile builds 22 unit tests, but because
    they’re all identical, except for naming differences and the source files from
    which they’re built, I only left the descriptions for two of them (at ➌).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您可以通过省略的部分看到，我省略了多个长文件列表和产品清单。这个 Makefile 构建了 22 个单元测试，但由于它们几乎完全相同，除了命名差异和构建源文件的不同，我只保留了其中两个的描述（见
    ➌）。
- en: I’ve defined the file-global `AM_CPPFLAGS` and `LDADD` variables at ➊ in order
    to associate the `XFLAIM` and `FTK` include and library files with each of the
    projects listed in this *Makefile.am* file. This way, I don’t have to explicitly
    append this information to each product.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 ➊ 处定义了文件全局的 `AM_CPPFLAGS` 和 `LDADD` 变量，用于将 `XFLAIM` 和 `FTK` 的头文件和库文件与这个 *Makefile.am*
    文件中列出的每个项目关联起来。这样，我就不需要显式地将这些信息附加到每个产品上。
- en: Transitive Dependencies
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 传递性依赖
- en: Notice, however, that the `AM_CPPFLAGS` variable uses both the `XFLAIM_INCLUDE`
    and `FTK_INCLUDE` variables—the xflaim utilities clearly require information from
    both sets of header files. So why doesn’t the `LDADD` variable reference the *ftk*
    library? This is because Libtool manages transitive dependencies for you and does
    so in a very portable manner, because some systems don’t have a native mechanism
    for managing transitive dependencies. Because I reference *libxflaim.la* through
    `XFLAIM_LDADD`, and because *libxflaim.la* lists *libflaimtk.la* as a dependency,
    Libtool is able to provide the transitive reference for me on the utility programs’
    linker command lines.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，`AM_CPPFLAGS` 变量同时使用了 `XFLAIM_INCLUDE` 和 `FTK_INCLUDE` 变量——xflaim 工具显然需要来自两组头文件的信息。那么，为什么
    `LDADD` 变量没有引用 *ftk* 库呢？这是因为 Libtool 为您管理传递性依赖，并且它以非常便捷的方式做到这一点，因为某些系统没有本地的机制来管理传递性依赖。由于我通过
    `XFLAIM_LDADD` 引用了 *libxflaim.la*，并且 *libxflaim.la* 将 *libflaimtk.la* 列为依赖项，Libtool
    能够在工具程序的链接器命令行中为我提供传递性引用。
- en: For a clearer picture of this, examine the contents of *libxflaim.la* (in your
    build directory under *xflaim/src*—you will have to build the project first; run
    `autoreconf -i; ./configure && make`). You’ll find a few lines near the middle
    of the file that look very much like the contents of [Listing 14-16](ch14.xhtml#ch14ex16).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地了解这一点，请查看 *libxflaim.la* 的内容（在您的构建目录下的 *xflaim/src* 文件夹中——您需要先构建该项目；运行
    `autoreconf -i; ./configure && make`）。您会在文件中间附近找到几行，内容看起来非常像 [Listing 14-16](ch14.xhtml#ch14ex16)
    中的内容。
- en: '[PRE27]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 14-16: The portion of xflaim/src*/libxflaim.la *that shows dependency
    libraries*'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-16：xflaim/src* 中的部分 *libxflaim.la* 文件内容，显示了依赖库。'
- en: The path information for *libflaimtk.la* is listed here so we don’t have to
    specify it in the `LDADD` statement for the xflaim utilities.^([27](footnote.xhtml#ch14fn27))
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了 *libflaimtk.la* 的路径信息，这样我们就不需要在 xflaim 工具的 `LDADD` 语句中显式指定它。^([27](footnote.xhtml#ch14fn27))
- en: Like Libtool, the GNU linker and the Linux loader can manage transitive dependencies
    (TDs). This is done by having `ld` incorporate these indirect dependencies into
    the ELF binaries it generates when appropriate linker command line options are
    used. Libtool’s mechanism relies on a recursive search of a hierarchy of *.la*
    files, whereas Linux’s native mechanism simply recursively searches the library
    hierarchy at build time and embeds all required library references directly into
    the built program or library. The loader then sees and uses these references at
    load time. A nice aspect of using such native TD management is that, if a library
    is updated in a newer version of a package, the loader will immediately begin
    to reference the updated secondary symbols from the new library’s updated reference
    list, and projects built against that library will immediately begin using the
    new version’s transitive dependencies.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Libtool 一样，GNU 链接器和 Linux 加载器也能管理传递性依赖（TD）。这通过在适当的链接器命令行选项使用时，让 `ld` 将这些间接依赖合并到它生成的
    ELF 二进制文件中来实现。Libtool 的机制依赖于对 *.la* 文件层级结构的递归搜索，而 Linux 的本地机制则是在构建时递归地搜索库层级，并将所有必需的库引用直接嵌入到构建的程序或库中。加载器随后在加载时看到并使用这些引用。使用这种本地
    TD 管理的一个好处是，如果库在包的较新版本中更新，加载器将立即开始引用新库更新后的二级符号，而基于该库构建的项目将立即开始使用新版本的传递性依赖。
- en: Recently, some distro vendors have decided it’s worth taking advantage of this
    feature on their platforms. The problem is, Libtool’s TD management reduces the
    perceived advantages of using `ld`’s (and the system loader’s) internal TD management—it
    gets in the way, so to speak. To solve this issue, these vendors have decided
    to release a modified version of Libtool on their platforms, wherein its TD management
    feature is effectively disabled. The result is that you must now specify all direct
    and indirect libraries on the linker (`libtool`) command line or modify your build
    system to use the non-portable native TD management linker options.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，一些发行版供应商决定在他们的平台上利用这个特性。问题在于，Libtool的TD管理减少了使用`ld`（以及系统加载器）内部TD管理的优势——它在某种程度上妨碍了这一点。为了解决这个问题，这些供应商决定发布一个修改版的Libtool，其中其TD管理功能被有效地禁用。结果是，你现在必须在链接器（`libtool`）命令行上明确指定所有直接和间接库，或者修改你的构建系统以使用非便携的本地TD管理链接器选项。
- en: Since native TD management is not supported on all platforms, and Libtool’s
    text file–based approach is completely portable, we often rely heavily on Libtool
    to do the right thing when indirect dependencies are required while linking our
    programs and libraries on systems that don’t have a native TD management system.
    When you use a “distro-crippled” Libtool package to build projects designed to
    take advantage of Libtool’s TD management features, your build simply fails at
    the link stage with “missing DSO” (dynamic shared object) messages.^([28](footnote.xhtml#ch14fn28))
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并非所有平台都支持本地TD管理，而Libtool的基于文本文件的方法完全是可移植的，我们通常会在没有本地TD管理系统的系统上依赖Libtool来正确处理间接依赖，尤其是在链接程序和库时。当你使用“被发行版破坏”的Libtool包来构建设计为利用Libtool
    TD管理功能的项目时，你的构建将在链接阶段失败，并出现“缺少DSO”（动态共享对象）消息。^([28](footnote.xhtml#ch14fn28))
- en: The `sed` command in *configure.ac* searches for the text `link_all_deplibs=no`
    in the *libtool* script and replaces it with `link_all_deplibs=yes`. It’s in there
    twice, and the `sed` command will replace both occurrences. `AC_OUTPUT` executes
    `config.status`, which generates the *libtool* script in the project directory,
    so the `sed` command must follow `AC_OUTPUT` to be effective.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*configure.ac*中的`sed`命令会在*libtool*脚本中搜索`link_all_deplibs=no`文本，并将其替换为`link_all_deplibs=yes`。它出现了两次，`sed`命令会替换这两个实例。`AC_OUTPUT`执行`config.status`，它会在项目目录中生成*libtool*脚本，因此`sed`命令必须跟随`AC_OUTPUT`才能生效。'
- en: '**NOTE**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It doesn’t hurt to use this *`sed`* command, even on systems that do not exhibit
    the problem—*`sed`* simply won’t find anything to replace in your* libtool *script.
    Be aware, however, that if your package is picked up for distribution by a Linux
    vendor that uses internal TD management, they’ll probably ship your package with
    these sorts of commands “patched out.”*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*即使在没有出现问题的系统上使用这个*`sed`*命令也不会有任何不良影响——*`sed`* 只会在你的*libtool*脚本中找不到任何内容来替换。不过要注意的是，如果你的软件包被某个使用内部TD管理的Linux供应商选中进行分发，他们很可能会把这类命令“修补”掉。*'
- en: Of course, another option is to forgo the use of automatic transitive dependency
    management entirely by simply specifying all of the link dependencies you know
    you’ll need on the linker’s command line for every program or library you build.
    Pkg-config actually does this for you anyway, so if you can rely on pkg-config
    for all your library management needs, then your projects are simply not affected
    by this issue. This can be done manually in the flaim, xflaim, and flaimsql projects
    by adding `$(FTK_LTLIB)` to the `LDADD` variables as, for example, at ➊ in [Listing
    14-15](ch14.xhtml#ch14ex15).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，另一种选择是完全放弃使用自动传递依赖管理，通过在每个程序或库的链接器命令行上明确指定你知道需要的所有链接依赖项来实现。实际上，Pkg-config已经为你做了这件事，因此如果你能够依赖pkg-config来满足所有的库管理需求，那么你的项目就不会受到这个问题的影响。这可以通过在flam、xflaim和flaimsql项目中手动添加`$(FTK_LTLIB)`到`LDADD`变量中来实现，具体可以参见[Listing
    14-15](ch14.xhtml#ch14ex15)中的➊。
- en: Feel free to try this by commenting out the `sed` commands in *configure.ac*
    and then rebuilding the project. Assuming you’re building on a platform where
    Libtool has been modified, your build will fail at the point where the flaim and
    xflaim projects try to link their utilities only against the *libflaim.la* and
    *libxflaim.la*. To make it work again, update your `LDADD` variables as I mentioned
    earlier.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 可以尝试通过注释掉*configure.ac*中的`sed`命令来进行测试，然后重新构建项目。假设你在一个修改过Libtool的平台上构建项目，那么在flam和xflaim项目尝试仅通过*libflaim.la*和*libxflaim.la*链接它们的工具时，构建将会失败。为了让它重新工作，按照之前提到的方式更新`LDADD`变量。
- en: Stamp Targets
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 时间戳目标
- en: In creating this makefile, I ran across another minor problem that I hadn’t
    anticipated. At least one of the unit tests seemed to require that some XML data
    files be present in the directory from which the test is executed. The test failed,
    and when I dug into it, I noticed that it failed while trying to open these files.
    Looking around a bit lead me to the *xflaim/util/xmldata* directory, which contained
    several dozen XML files.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建这个 Makefile 时，我遇到了一个没有预料到的小问题。至少有一个单元测试似乎要求在执行测试的目录中存在一些 XML 数据文件。测试失败了，当我深入调查时，我注意到它在尝试打开这些文件时失败了。稍微四处看看，我发现了*xflaim/util/xmldata*目录，其中包含了几十个
    XML 文件。
- en: I needed to copy those files into the build hierarchy’s *xflaim/util* directory
    before I could run the unit tests. I know that products prefixed with `check`
    are built before `TESTS` are executed, so it occurred to me that I might list
    these files at ➋ in a `check_DATA PLV`. The `check_DATA` variable refers to a
    file called *copy-xml-files.stamp*, which is a special type of file target called
    a *stamp* target. Its purpose is to replace a group of unspecified files, or a
    non-file-based operation, with one single, representative file. This stamp file
    is used to indicate to the build system that all the XML data files have been
    copied into the *util* directory. Automake often uses stamp files in its own generated
    rules.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要将这些文件复制到构建层次结构中的*xflaim/util*目录，然后才能运行单元测试。我知道以 `check` 为前缀的产品在执行 `TESTS`
    之前会先构建，所以我想到我可以在 ➋ 处在 `check_DATA PLV` 中列出这些文件。`check_DATA` 变量引用一个名为*copy-xml-files.stamp*的文件，它是一个特殊类型的文件目标，称为*stamp*目标。它的目的是用一个单一的代表文件替代一组未指定的文件，或者一个非基于文件的操作。这个时间戳文件用于向构建系统指示所有
    XML 数据文件已经被复制到*util*目录中。Automake 在它自己生成的规则中经常使用时间戳文件。
- en: 'The rule for generating the stamp file at ➍ also copies the XML data files
    into the test execution directory. The `echo` statement simply creates a file
    named *copy-xml-files.stamp* that contains a single word: *Timestamp*. The file
    may contain anything (or nothing at all). The important point here is that the
    file exists and has a time and date associated with it. The `make` utility uses
    this information to determine whether the copy operation needs to be executed.
    In this case, since *copy-xml-files.stamp* has no dependencies, its mere existence
    indicates to `make` that the operation has already been done. Delete the stamp
    file to get `make` to perform the copy operation on the next build.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 生成时间戳文件的规则 ➍ 也将 XML 数据文件复制到测试执行目录中。`echo` 语句仅仅创建一个名为*copy-xml-files.stamp*的文件，文件中包含一个单词：*Timestamp*。这个文件可以包含任何内容（甚至什么都不包含）。这里的重要点是文件存在并且有一个时间和日期与之相关联。`make`
    工具利用这些信息来确定是否需要执行复制操作。在这种情况下，由于*copy-xml-files.stamp*没有依赖项，它的存在仅仅意味着 `make` 已经完成了操作。删除时间戳文件可以让
    `make` 在下一次构建时执行复制操作。
- en: This is a sort of hybrid between a true file-based rule and a phony target.
    Phony targets are always executed—they aren’t real files, so `make` has no way
    of determining whether the associated operation should be performed based on file
    attributes. The timestamps of file-based rules can be checked against their dependency
    lists to determine whether they should be re-executed. Stamp rules like this are
    executed only if the stamp file is missing, because there are no dependencies
    against which the target’s time and date should be compared.^([29](footnote.xhtml#ch14fn29))
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种介于真实基于文件的规则和伪目标之间的混合体。伪目标总是会被执行——它们不是实际的文件，因此 `make` 无法根据文件属性确定是否应该执行相关操作。基于文件的规则的时间戳可以与它们的依赖列表进行检查，以确定是否需要重新执行它们。像这样的时间戳规则只有在时间戳文件丢失时才会执行，因为没有依赖项可以与目标的时间和日期进行比较。^([29](footnote.xhtml#ch14fn29))
- en: Cleaning Your Room
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清理你的房间
- en: All files placed in the build directory should be cleaned up when the user enters
    `make clean` at the command prompt. Since I placed XML data files into the build
    directory, I also need to clean them up. Files listed in `DATA` variables are
    not cleaned up automatically, because `DATA` files are not necessarily generated.
    Sometimes the `DATA` primary is used to list static project files that need to
    be installed. I “created” a bunch of XML files and a stamp file, so I needed to
    remove these during `make clean`. To this end, I added the `clean-local` target
    at ➎, along with its associated `rm` commands.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 所有放置在构建目录中的文件都应该在用户输入`make clean`时被清理掉。由于我将XML数据文件放入了构建目录，因此我也需要清理它们。列在`DATA`变量中的文件不会自动清理，因为`DATA`文件不一定是生成的。有时，`DATA`主变量用于列出需要安装的静态项目文件。我“创建”了一些XML文件和一个标记文件，所以在`make
    clean`时需要删除它们。为此，我在➎处添加了`clean-local`目标，以及其相关的`rm`命令。
- en: '**NOTE**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Be careful when deleting files copied from the source tree into the corresponding
    location in the build tree—you may inadvertently delete source files when building
    from within the source tree. You can compare *`$(srcdir)`* to “*`.`*” within *`make`*
    commands to see if the user is building in the source tree.*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*当删除从源树复制到构建树相应位置的文件时要小心——你可能会不小心删除源文件，尤其是当在源树内构建时。你可以在*`make`*命令中将*`$(srcdir)`*与“*`.`*”进行比较，看看用户是否在源树中构建。*'
- en: 'There is another way to ensure that files created using your own `make` rules
    get cleaned up during execution of the `clean` target. You can define the `CLEANFILES`
    variable to contain a whitespace-separated list of files (or wildcard specifications)
    to be removed. I used a `clean-local` target in this case, because the `CLEANFILES`
    variable has one caveat: it won’t remove directories, only files. Each of the
    `rm` commands that removes a wildcard file specification refers to at least one
    directory. I’ll show you a proper use of `CLEANFILES` in [Chapter 15](ch15.xhtml).'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种方法可以确保在执行`clean`目标时，使用你自己的`make`规则创建的文件能够被清理掉。你可以定义`CLEANFILES`变量，包含一个以空格分隔的文件列表（或通配符规范），以供删除。我在这个例子中使用了`clean-local`目标，因为`CLEANFILES`变量有一个限制：它不能删除目录，只能删除文件。每个删除通配符文件规范的`rm`命令都涉及到至少一个目录。我将在[第15章](ch15.xhtml)中展示如何正确使用`CLEANFILES`。
- en: Regardless of how well your unit tests clean up after themselves, you still
    might want to write `clean` rules that attempt to clean up intermediary test files.
    That way, your makefiles will clean up droppings from interrupted tests and debug
    runs.^([30](footnote.xhtml#ch14fn30)) Remember that the user may be building in
    the source directory. Try to make your wildcards as specific as possible so you
    don’t inadvertently remove source files.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的单元测试清理得多么干净，你仍然可能需要编写`clean`规则来尝试清理中间的测试文件。这样，你的makefile将清理被中断的测试和调试运行留下的残余文件。^([30](footnote.xhtml#ch14fn30))
    请记住，用户可能在源目录中构建。尽量让你的通配符尽可能具体，以免不小心删除源文件。
- en: I use the Automake-supported `clean-local` target here as a way to extend the
    `clean` target. The `clean-local` target is executed as a dependency of (and thus
    executed before) the `clean` target, if it exists. [Listing 14-17](ch14.xhtml#ch14ex17)
    shows the corresponding code from the Automake-generated *Makefile.in* template,
    so you can see how this infrastructure is wired up. The interesting bits are highlighted.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用了Automake支持的`clean-local`目标，作为扩展`clean`目标的一种方式。如果存在，`clean-local`目标会作为依赖项（因此会在`clean`目标之前执行）。[列表14-17](ch14.xhtml#ch14ex17)展示了来自Automake生成的*Makefile.in*模板的相应代码，您可以看到这个基础设施是如何连接起来的。关键部分已被突出显示。
- en: '[PRE28]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 14-17*: xflaim/util/Makefile.in: *The clean rules generated by Automake
    from* xflaim/util/Makefile.am'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表14-17*：xflaim/util/Makefile.in：*从* xflaim/util/Makefile.am *生成的清理规则*'
- en: Automake noted that I had a target named `clean-local` in *Makefile.am*, so
    it added `clean-local` to the dependency list for `clean-am` at ➊ and then added
    it to the `.PHONY` variable at ➋. Had I not written a `clean-local` target, these
    references would have been missing from the generated *Makefile*.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Automake注意到我在*Makefile.am*中有一个名为`clean-local`的目标，因此它在➊处将`clean-local`添加到`clean-am`的依赖列表中，然后在➋处将其添加到`.PHONY`变量中。如果我没有编写`clean-local`目标，这些引用就不会出现在生成的*Makefile*中。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Well, those are the basics. If you’ve followed along and understood what we
    did in this chapter, then you should be able to convert nearly any project to
    use an Autotools-based build system. For more details on the topics covered here,
    I refer you to the Autotools manuals. Often just knowing the name of a concept
    so you can easily find it in the manual or in an online search is worth a great
    deal.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这些就是基础知识。如果你跟随并理解了本章中的内容，那么你应该能够将几乎任何项目转换为使用基于Autotools的构建系统。有关此处涉及主题的更多细节，请参考Autotools手册。通常，知道一个概念的名称，以便你可以轻松地在手册或在线搜索中找到它，价值非常大。
- en: In [Chapter 15](ch15.xhtml), I’ll cover the stranger aspects of converting this
    project, including the details of building Java and C# code, adding compiler-specific
    optimization flags and command line options, and even building RPM packages using
    user-defined `make` targets in your *Makefile.am* files.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15章](ch15.xhtml)中，我将介绍将此项目转换的更奇特方面，包括构建Java和C#代码的细节，添加特定编译器的优化标志和命令行选项，甚至使用用户定义的`make`目标在你的*Makefile.am*文件中构建RPM包。
