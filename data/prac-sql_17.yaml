- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Saving Time with Views, Functions, and Triggers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过视图、函数和触发器节省时间
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: 'One advantage of using a programming language is that we can automate repetitive,
    boring tasks. That’s what this chapter is about: taking the queries or steps you
    might do over and over and turning them into reusable database objects that you
    code once and can call later to let the database do the work. Programmers call
    this the DRY principle: Don’t Repeat Yourself.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编程语言的一个优势是我们可以自动化重复的、枯燥的任务。这就是本章的内容：将你可能一遍又一遍执行的查询或步骤转化为可重用的数据库对象，你只需编写一次代码，之后可以调用它们让数据库完成工作。程序员称之为DRY原则：不要重复自己。
- en: You’ll start by learning to store queries as reusable database *views*. Next,
    you’ll explore how to create database functions you can use to operate on your
    data, the same way you’ve used built-in functions like `round()` and `upper()`.
    Then you’ll set up *triggers* to run your functions automatically when certain
    events occur on a table. All these techniques are useful not only for reducing
    repetitive work but for ensuring data integrity too.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先学习如何将查询存储为可重用的数据库*视图*。接下来，你将探索如何创建数据库函数，像使用`round()`和`upper()`这样的内置函数一样操作数据。然后，你将设置*触发器*，当表上发生特定事件时，自动运行这些函数。所有这些技巧不仅有助于减少重复工作，还能确保数据完整性。
- en: We’ll practice these techniques on tables created from examples in earlier chapters.
    All the code for this chapter is available for download along with the book’s
    resources at [https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在前面章节中的示例上练习这些技巧。本章的所有代码都可以通过[https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/)与本书的资源一起下载。
- en: Using Views to Simplify Queries
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用视图简化查询
- en: A *view* is essentially a stored query with a name that you can work with as
    if it were a table. For example, a view might store a query that calculates total
    population by state. As with a table, you could query that view, join the view
    to tables (or to other views), and use the view to update or insert data into
    a table it’s based on, albeit with some caveats. The stored query in a view can
    be simple, referencing just one table, or complex, with multiple table joins.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*视图*本质上是一个存储的查询，带有一个名称，你可以像操作表一样使用它。例如，一个视图可能存储一个计算每个州总人口的查询。与表一样，你可以查询这个视图，将视图与表（或其他视图）连接，并使用视图更新或插入数据到它所依赖的表，尽管有一些限制。视图中的存储查询可以很简单，只引用一个表，或者很复杂，涉及多个表的连接。'
- en: 'Views are especially useful in the following scenarios:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 视图在以下情况下尤其有用：
- en: '**Avoiding duplicate effort:** They let you write a complex query once and
    access the results when needed.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免重复劳动：** 它们让你能够只写一次复杂的查询，并在需要时访问结果。'
- en: '**Reducing clutter:** They can trim the amount of information you need to wade
    through by showing only columns relevant to your needs.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少杂乱：** 通过只显示与你需求相关的列，它们可以减少你需要浏览的信息量。'
- en: '**Providing security:** Views can limit access to only certain columns in a
    table.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供安全性：** 视图可以限制对表中某些列的访问。'
- en: In this section, we’ll look at two kinds of views. The first—a standard view—contains
    PostgreSQL syntax that’s largely in line with the ANSI SQL standard for views.
    Every time you access a standard view, the stored query runs and generates a temporary
    set of results. The second is a *materialized view*, which is specific to PostgreSQL,
    Oracle, and a limited number of other database systems. When you create a materialized
    view, the data returned by its query is stored permanently in the database like
    a table; you can refresh the view to update the stored data if needed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍两种类型的视图。第一种——标准视图——包含与ANSI SQL标准大致一致的PostgreSQL语法。每次访问标准视图时，存储的查询都会运行并生成一组临时结果。第二种是*物化视图*，这是PostgreSQL、Oracle以及少数其他数据库系统特有的。当你创建物化视图时，它的查询返回的数据会像表一样永久存储在数据库中；如果需要，你可以刷新视图以更新存储的数据。
- en: Views are easy to create and maintain. Let’s work through several examples to
    see how they work.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 视图易于创建和维护。让我们通过几个示例来看看它们是如何工作的。
- en: Creating and Querying Views
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和查询视图
- en: In this section, we’ll return to the census estimates table `us_counties_pop_est_2019`
    you imported in Chapter 5. [Listing 17-1](#listing17-1) creates a standard view
    that returns just the population of Nevada counties. The original table has sixteen
    columns; the view will return just four of them. This would be useful for making
    a subset of Nevada census data quickly accessible when we’re referring to it often
    or using the data in an application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将返回到你在第5章导入的人口普查估计表`us_counties_pop_est_2019`。[清单17-1](#listing17-1)创建了一个标准视图，仅返回内华达州县的总人口。原始表有16列；该视图将只返回其中的4列。当我们经常引用数据或在应用程序中使用这些数据时，这样做会方便我们快速访问内华达州的人口普查数据的子集。
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 17-1: Creating a view that displays Nevada 2019 counties'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 清单17-1：创建一个显示内华达州2019年县数据的视图
- en: We define the view using the keywords `CREATE OR REPLACE VIEW` 1 followed by
    the view’s name, `nevada_counties_pop_2019`, and then `AS`. (We can name the view
    any way we’d like; I prefer a name that’s descriptive of the view’s results.)
    Next, we use a standard SQL `SELECT` 2 to fetch the 2019 population estimate (the
    `pop_est_2019` column) for each Nevada county from the `us_counties_pop_est_2019`
    table.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用关键字`CREATE OR REPLACE VIEW`1定义视图，后面是视图的名称`nevada_counties_pop_2019`，然后是`AS`。（我们可以根据需要命名视图；我更倾向于给视图起一个描述性名称。）接下来，我们使用标准SQL的`SELECT`2查询`us_counties_pop_est_2019`表中每个内华达州县的2019年人口估计（`pop_est_2019`列）。
- en: 'Notice the `OR REPLACE` keywords after `CREATE`. These are optional and tell
    the database that if a view with this name already exists, then replace it with
    the new definition. It’s helpful to include these keywords if you’re iterating
    on creating a view and want to refine the query. There is one caveat: if you’re
    replacing an existing view, the new query 2 must generate the same column names
    with the same data types and in the same order as the one it’s replacing. You
    can add columns, but they must be placed at the end of the column list. If you
    try to do otherwise, the database will respond with an error message.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`CREATE`后面的`OR REPLACE`关键字。这些是可选的，表示如果已经存在同名的视图，则用新定义替换它。如果你在迭代创建视图并希望完善查询时，加入这些关键字会很有帮助。有一个警告：如果你要替换现有视图，新查询2必须生成相同的列名，且数据类型和顺序必须与要替换的视图一致。你可以添加列，但它们必须放在列列表的末尾。如果尝试做其他操作，数据库会返回错误消息。
- en: Run the code in [Listing 17-1](#listing17-1) using pgAdmin. The database should
    respond with the message `CREATE VIEW`. To find the new view, in pgAdmin’s object
    browser, right-click the `analysis` database and click **Refresh**. Choose **Schemas**▶**public**▶**Views**
    to see all views. When you right-click your new view and click **Properties**,
    you should see a more verbose version of the query (with the table name prepended
    to each column name) on the Code tab in the dialog that opens. That’s a handy
    way to inspect views you might find in a database.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pgAdmin运行[清单17-1](#listing17-1)中的代码。数据库应返回`CREATE VIEW`消息。要找到新视图，在pgAdmin的对象浏览器中，右键点击`analysis`数据库并点击**刷新**。选择**Schemas**▶**public**▶**Views**来查看所有视图。当你右键点击新视图并点击**属性**时，应该能在弹出的对话框中的“代码”标签页看到查询的详细版本（表名会添加到每个列名之前）。这是检查数据库中可能存在的视图的一种方便方式。
- en: This type of view—one that isn’t materialized—holds no data at this point; instead,
    the stored `SELECT` query it contains will run when you access the view from another
    query. For example, the code in [Listing 17-2](#listing17-2) returns all columns
    in the view. As with a typical `SELECT` query, we can use `ORDER BY` to sort results,
    this time using the county’s Federal Information Processing Standards (FIPS) code—the
    standard designator the US Census Bureau and other federal agencies use to specify
    each county and state. We also add a `LIMIT` clause to display just five rows.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的视图——一个非物化的视图——此时不包含任何数据；相反，它包含的`SELECT`查询将在你从另一个查询访问该视图时执行。例如，[清单17-2](#listing17-2)中的代码返回视图中的所有列。与典型的`SELECT`查询一样，我们可以使用`ORDER
    BY`对结果进行排序，这次使用的是县的联邦信息处理标准（FIPS）代码——美国人口普查局和其他联邦机构用来指定每个县和州的标准标识符。我们还添加了一个`LIMIT`子句，只显示五行。
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 17-2: Querying the `nevada_counties_pop_2010` view'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 清单17-2：查询`nevada_counties_pop_2010`视图
- en: 'Aside from the five-row limit, the result should be the same as if you had
    run the `SELECT` query used to create the view in [Listing 17-1](#listing17-1):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了五行的限制外，结果应该与运行[清单17-1](#listing17-1)中用于创建视图的`SELECT`查询相同：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This simple example isn’t useful unless quickly listing Nevada county population
    is a task you’ll perform frequently. So, let’s imagine a question data-minded
    analysts in a political research organization might ask often: what was the percent
    change in population for each county in Nevada (or any other state) from 2010
    to 2019?'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的示例除非你需要频繁列出内华达州的县人口，否则没有什么实际用处。那么，让我们想象一个政治研究组织中的数据分析师可能经常会问的问题：2010年到2019年期间，每个内华达州（或其他州）县的人口百分比变化是多少？
- en: We wrote a query to answer this question in Chapter 7, and though it wasn’t
    onerous to create, it did require joining tables on two columns and using a percent
    change formula that involved rounding and type casting. To avoid repeating that
    work, we can create a view that stores a query similar to the one in Chapter 7
    as a view, as shown in [Listing 17-3](#listing17-3).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第7章写过一个查询来回答这个问题，虽然创建这个查询并不繁琐，但它确实需要在两列上进行表连接，并使用包含四舍五入和类型转换的百分比变化公式。为了避免重复这项工作，我们可以创建一个视图，将类似于第7章中的查询作为视图存储，如[清单
    17-3](#listing17-3)所示。
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 17-3: Creating a view showing population change for US counties'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 17-3：创建一个显示美国县人口变化的视图
- en: We start the view definition with `CREATE OR REPLACE VIEW` 1, followed by the
    name of the view and `AS`. The `SELECT` query 2 names columns from the census
    tables and includes a column definition with a percent change calculation 3 that
    you learned about in Chapter 6. Then we join the 2019 and 2010 census tables 4
    using the state and county FIPS codes. Run the code, and the database should again
    respond with `CREATE VIEW`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`CREATE OR REPLACE VIEW` 1开始定义视图，接着是视图的名称和`AS`。`SELECT` 查询 2 从人口普查表中选择列，并包括一个百分比变化计算的列定义
    3，这是你在第6章学习过的内容。然后，我们使用州和县的FIPS代码连接2019年和2010年的人口普查表 4。运行代码后，数据库应该再次返回`CREATE
    VIEW`。
- en: Now that we’ve created the view, we can use the code in [Listing 17-4](#listing17-4)
    to run a simple query using the new view that retrieves data for Nevada counties.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了视图，可以使用[清单 17-4](#listing17-4)中的代码，通过新的视图运行一个简单查询，检索内华达州县的数据。
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 17-4: Selecting columns from the `county_pop_change_2019_2010` view'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 17-4：从`county_pop_change_2019_2010`视图中选择列
- en: In [Listing 17-2](#listing17-2), in the query that referenced our `nevada_counties_pop_2019`
    view, we retrieved every column in the view by using the asterisk wildcard after
    `SELECT`. [Listing 17-4](#listing17-4) shows that, as with a query on a table,
    we can name specific columns when querying a view. Here, we specify four of the
    `county_pop_change_2019_2010` view’s seven columns. One is `pct_change_2019_2010`
    1, which returns the result of the percent change calculation we’re looking for.
    As you can see, it’s much simpler to write the column name like this than the
    whole formula. We’re also filtering the results using a `WHERE` clause 2, similar
    to how we’d filter any query.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 17-2](#listing17-2)中，引用我们`nevada_counties_pop_2019`视图的查询中，我们通过在`SELECT`后使用星号通配符，检索了视图中的所有列。[清单
    17-4](#listing17-4)显示了与查询表格一样，我们在查询视图时可以指定具体的列。这里，我们指定了`county_pop_change_2019_2010`视图的七列中的四列。其中一列是`pct_change_2019_2010`
    1，它返回我们需要的百分比变化计算结果。如你所见，像这样写列名比写整个公式要简单得多。我们还通过`WHERE`子句 2 对结果进行了过滤，这与我们过滤任何查询的方式类似。
- en: 'After querying the four columns from the view, the results should look like
    this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 查询视图中的四列后，结果应该是这样的：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now we can revisit this view as often as we like to pull data for presentations
    or to answer questions about the percent change in population for any county in
    America from 2010 to 2019.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以根据需要随时重新查看这个视图，以便提取数据进行演示，或回答关于2010年到2019年间任何美国县人口百分比变化的问题。
- en: 'Looking at just these five rows, you can see a couple of interesting stories
    emerge: the continued rapid growth of Clark County, which includes the city of
    Las Vegas, as well as a strong percent increase in Esmeralda County, one of the
    smallest counties in the United States and home to several ghost towns.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 仅看这五行数据，你可以看到几个有趣的故事：克拉克县的持续快速增长，这里包括了拉斯维加斯市；以及埃斯梅拉达县的强劲百分比增长，埃斯梅拉达县是美国最小的县之一，还是几个鬼镇的所在地。
- en: Creating and Refreshing a Materialized View
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和刷新物化视图
- en: A materialized view differs from a standard view in that upon its creation,
    the materialized view’s stored query is executed, and the results it generates
    are saved in the database. In effect, this creates a new table. The view retains
    its stored query, so you can update the saved data by issuing a command to refresh
    the view. A good use for materialized views is to preprocess complex queries that
    take a while to run and make those results available for faster querying.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 物化视图与标准视图的不同之处在于，在创建时，物化视图的存储查询会被执行，并且它生成的结果会保存在数据库中。实际上，这相当于创建了一个新表。视图保留其存储的查询，因此你可以通过发出刷新视图的命令来更新存储的数据。物化视图的一个好用途是预处理需要较长时间运行的复杂查询，并使这些结果可供更快查询。
- en: Let’s drop the `nevada_counties_pop_2019` view and re-create it as a materialized
    view using the code in [Listing 17-5](#listing17-5).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除`nevada_counties_pop_2019`视图，并使用[清单 17-5](#listing17-5)中的代码重新创建它作为物化视图。
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 17-5: Creating a materialized view'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 17-5：创建物化视图
- en: First, we use a `DROP VIEW` 1 statement to remove the `nevada_counties_pop_2019`
    view from the database. Then, we run `CREATE MATERIALIZED VIEW` 2 to make the
    view. Notice that the syntax is the same as the one for making a standard view,
    except for the added `MATERIALIZED` keyword and the omission of `OR REPLACE`,
    which is not available in the materialized view syntax. After running the statement,
    the database should respond with the message `SELECT 17`, telling you that the
    view’s query produced 17 rows to be stored in the view. We can now query this
    data as with a standard view.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`DROP VIEW`语句删除数据库中的`nevada_counties_pop_2019`视图。然后，我们运行`CREATE MATERIALIZED
    VIEW`语句来创建视图。请注意，语法与创建标准视图相同，只是在添加了`MATERIALIZED`关键字，并且省略了`OR REPLACE`，因为物化视图语法中不支持该选项。运行该语句后，数据库应该会响应`SELECT
    17`消息，告诉你视图的查询生成了17行数据，将被存储在视图中。现在，我们可以像使用标准视图一样查询这些数据。
- en: Let’s say that the population estimates stored in `us_counties_pop_est_2019`
    are revised. To update the data stored in the materialized view, we can use the
    `REFRESH` keyword, as in [Listing 17-6](#listing17-6).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设存储在`us_counties_pop_est_2019`中的人口估算值已经被修订。要更新存储在物化视图中的数据，我们可以使用`REFRESH`关键字，如[清单
    17-6](#listing17-6)所示。
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 17-6: Refreshing a materialized view'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 17-6：刷新物化视图
- en: Executing this statement reruns the query stored in the `nevada_counties_pop_2019`
    view; the server will respond with the message `REFRESH MATERIALIZED VIEW`. The
    view will now reflect any updates to the data referenced by the view’s query.
    When you have a query that takes some time to run, you can save time by storing
    its results in a materialized view that’s refreshed periodically, letting users
    quickly access the stored data rather than run a lengthy query.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 执行该语句会重新运行存储在`nevada_counties_pop_2019`视图中的查询；服务器将响应`REFRESH MATERIALIZED VIEW`消息。该视图将反映视图查询引用的任何数据更新。当你有一个需要一定时间来运行的查询时，可以通过将其结果存储在定期刷新的物化视图中节省时间，从而让用户快速访问存储的数据，而不是运行一个冗长的查询。
- en: To delete a materialized view, we use a `DROP MATERIALIZED VIEW` statement.
    Also, note that materialized views appear in a different part of pgAdmin’s object
    browser, under **Schemas**▶**public**▶**Materialized Views**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个物化视图，我们使用`DROP MATERIALIZED VIEW`语句。另外，请注意，物化视图会出现在pgAdmin对象浏览器的不同部分，位于**Schemas**▶**public**▶**Materialized
    Views**下。
- en: Inserting, Updating, and Deleting Data Using a View
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用视图插入、更新和删除数据
- en: With nonmaterialized views, you can update or insert data in the underlying
    table being queried as long as the view meets certain conditions. One requirement
    is that the view must reference a single table or updatable view. If the view’s
    query joins tables, as with the population change view we just built in the previous
    section, you can’t perform inserts or updates to the original table directly.
    Also, the view’s query can’t contain `DISTINCT`, `WITH`, `GROUP BY`, or other
    clauses. (See a complete list of restrictions at [https://www.postgresql.org/docs/current/sql-createview.html](https://www.postgresql.org/docs/current/sql-createview.html).)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非物化视图，只要视图满足某些条件，你可以更新或插入被查询的底层表中的数据。一个要求是，视图必须引用单个表或可更新的视图。如果视图的查询连接了多个表，如我们在上一节中构建的人口变化视图，则不能直接对原始表执行插入或更新操作。另外，视图的查询不能包含`DISTINCT`、`WITH`、`GROUP
    BY`或其他子句。（有关限制的完整列表，请参见[https://www.postgresql.org/docs/current/sql-createview.html](https://www.postgresql.org/docs/current/sql-createview.html)。）
- en: You already know how to directly insert and update data on a table, so why do
    it through a view? One reason is that a view is one way you can exercise control
    over which data a user can update. Let’s work through an example to see how this
    works.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何直接在表中插入和更新数据，那么为什么要通过视图来操作呢？其中一个原因是，视图是控制用户可以更新哪些数据的一种方式。让我们通过一个例子来看看如何操作。
- en: Creating a View of Employees
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建员工视图
- en: 'In the Chapter 7 lesson on joins, we created and filled the `departments` and
    `employees` tables with four rows about people and where they work (if you skipped
    that section, you can revisit [Listing 7-1](c07.xhtml#listing7-1)). Running a
    quick `SELECT * FROM employees ORDER BY emp_id;` query shows the table’s contents,
    as you can see here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章的联接课程中，我们创建并填充了`departments`和`employees`表，包含了关于员工和他们工作地点的四行数据（如果你跳过了那部分内容，可以回顾[Listing
    7-1](c07.xhtml#listing7-1)）。运行一个快速的`SELECT * FROM employees ORDER BY emp_id;`查询，可以查看表的内容，如下所示：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let’s say we want to use a view to give users in the Tax Department (its `dept_id`
    is `1`) the ability to add, remove, or update their employees’ names without letting
    them change salary information or the data of employees in another department.
    To do this, we can set up a view using [Listing 17-7](#listing17-7).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望通过视图使税务部门的用户（其`dept_id`为`1`）能够添加、删除或更新他们员工的姓名，但不允许他们更改薪资信息或其他部门员工的数据。为此，我们可以使用[Listing
    17-7](#listing17-7)中的视图定义来实现。
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 17-7: Creating a view on the `employees` table'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 17-7: 在`employees`表上创建视图'
- en: This view is similar to others we’ve created so far, but with a few additions.
    First, in the `CREATE OR REPLACE VIEW` statement, we add the keywords `WITH (security_barrier)`
    1. This enables a level of database security to prevent a malicious user from
    getting around restrictions that the view places on rows and columns. (See [https://www.postgresql.org/docs/current/rules-privileges.html](https://www.postgresql.org/docs/current/rules-privileges.html)
    for how someone might subvert a view if you omit this type of security.)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图与我们之前创建的其他视图类似，但有一些额外的功能。首先，在`CREATE OR REPLACE VIEW`语句中，我们添加了关键字`WITH (security_barrier)`
    1。这为数据库增加了一层安全性，防止恶意用户绕过视图对行和列的限制。（有关如何防止用户绕过视图安全性的详细信息，请参见[https://www.postgresql.org/docs/current/rules-privileges.html](https://www.postgresql.org/docs/current/rules-privileges.html)。）
- en: In the view’s `SELECT` query, we pick the columns we want to show from the `employees`
    table and use `WHERE` to filter the results on `dept_id = 1` 2 to list only Tax
    Department staff. The view itself will restrict updates or deletes to rows matching
    the condition in the `WHERE` clause. Adding the keywords `WITH LOCAL CHECK OPTION`
    3 restricts inserts as well, allowing users to add new Tax Department employees
    only (if the view definition omitted those keywords, you could use it to insert
    a row with a `dept_id` of `3`, for example). The `LOCAL CHECK OPTION` also prevents
    a user from changing an employee’s `dept_id` to a value other than `1`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图的`SELECT`查询中，我们从`employees`表中选择要显示的列，并使用`WHERE`条件过滤出`dept_id = 1`的数据，只列出税务部门的员工。视图本身会限制对符合`WHERE`条件的行进行更新或删除。添加关键字`WITH
    LOCAL CHECK OPTION` 3 也会限制插入操作，只允许用户添加新的税务部门员工（如果视图定义中没有这些关键字，用户还可以插入`dept_id`为`3`的行）。`LOCAL
    CHECK OPTION`还会防止用户将员工的`dept_id`更改为`1`以外的值。
- en: 'Create the `employees_tax_dept` view by running the code in [Listing 17-7](#listing17-7).
    Then run `SELECT * FROM employees_tax_dept ORDER BY emp_id;`, which should provide
    these two rows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行[Listing 17-7](#listing17-7)中的代码来创建`employees_tax_dept`视图。然后运行`SELECT *
    FROM employees_tax_dept ORDER BY emp_id;`，应该会返回以下两行数据：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The result shows the employees who work in the Tax Department; they’re two of
    the four rows in the entire `employees` table.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 查询结果显示了在税务部门工作的员工；他们是整个`employees`表中四行数据中的两行。
- en: Now, let’s look at how inserts and updates work via this view.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下通过这个视图如何进行插入和更新操作。
- en: Inserting Rows Using the employees_tax_dept View
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`employees_tax_dept`视图插入行
- en: We can use a view to insert or update data, but instead of using the table name
    in the `INSERT` or `UPDATE` statement, we substitute the view name. After we add
    or change data using a view, the change is applied to the underlying table, which
    in this case is `employees`. The view then reflects the change via the query it
    runs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用视图来插入或更新数据，但在`INSERT`或`UPDATE`语句中，我们不使用表名，而是使用视图名作为替代。在我们通过视图添加或更改数据后，变化会应用到底层表中，这里是`employees`。视图然后通过它所运行的查询来反映这些变化。
- en: '[Listing 17-8](#listing17-8) shows two examples that attempt to add new employee
    records via the `employees_tax_dept` view. The first succeeds, but the second
    fails.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 17-8](#listing17-8)展示了两个通过`employees_tax_dept`视图尝试添加新员工记录的例子。第一个成功，第二个失败。'
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 17-8: Successful and rejected inserts via the `employees_tax_dept`
    view'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-8：通过`employees_tax_dept`视图成功和拒绝的插入
- en: In the first `INSERT` 1, which uses the insert syntax you learned in Chapter
    2, we supply the first and last names of Suzanne Legere plus her `emp_id` and
    `dept_id`. Because the new row will satisfy the `LOCAL CHECK` in the view—it contains
    the same columns and `dept_id` is `1`—the insert succeeds when it executes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个`INSERT` 1中，我们使用了在第2章中学到的插入语法，提供了Suzanne Legere的名字和姓氏，以及她的`emp_id`和`dept_id`。由于新行符合视图中的`LOCAL
    CHECK`—它包含相同的列且`dept_id`为`1`—因此插入在执行时成功。
- en: But when we run the second `INSERT` 2 to add an employee named Jamil White using
    a `dept_id` of `2`, the operation fails with the error message `new row violates
    check option for view "employees_tax_dept"`. The reason is that when we created
    the view, we used a `WHERE` clause to return only rows with `dept_id = 1`. The
    `dept_id` of `2` doesn’t pass the `LOCAL CHECK`, so it’s prevented from being
    inserted.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当我们运行第二个`INSERT` 2，尝试使用`dept_id`为`2`的Jamil White来添加员工时，操作失败，出现错误信息`new row
    violates check option for view "employees_tax_dept"`。原因是当我们创建视图时，使用了`WHERE`子句来仅返回`dept_id
    = 1`的行。`dept_id`为`2`的行没有通过`LOCAL CHECK`，因此被阻止插入。
- en: 'Run the `SELECT` statement 3 on the view to check that Suzanne Legere was successfully
    added:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`SELECT`语句3，查看Suzanne Legere是否成功添加：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We also query the `employees` table 4 to see that, in fact, Suzanne Legere was
    added to the full table. The view queries the `employees` table each time we access
    it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还查询了`employees`表4，确实发现Suzanne Legere已经被添加到完整的表中。每次访问视图时，它都会查询`employees`表。
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see from the addition of Suzanne Legere, the data we add using a
    view is also added to the underlying table. However, because the view doesn’t
    include the `salary` column, the value in her row is `NULL`. If you attempt to
    insert a salary value using this view, you would receive the error message `column
    "salary" of relation "employees_tax_dept" does not exist`. The reason is that
    even though the `salary` column exists in the underlying `employees` table, it’s
    not referenced in the view. Again, this is one way to limit access to sensitive
    data. Check the links I provided in the note in the section “Using Views to Simplify
    Queries” to learn more about granting permissions to users and adding `WITH (security_barrier)`
    if you plan to take on database administrator responsibilities.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从Suzanne Legere的添加中看到的那样，我们通过视图添加的数据也会添加到底层表中。然而，由于视图不包含`salary`列，所以她行中的值为`NULL`。如果你尝试通过该视图插入薪资值，将会收到错误信息`column
    "salary" of relation "employees_tax_dept" does not exist`。原因是即使`salary`列在底层的`employees`表中存在，它在视图中并未被引用。同样，这是限制对敏感数据访问的一种方式。如果你打算承担数据库管理员的责任，可以查看我在“使用视图简化查询”一节中的笔记中提供的链接，了解更多关于授权用户和添加`WITH
    (security_barrier)`的内容。
- en: Updating Rows Using the employees_tax_dept View
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`employees_tax_dept`视图更新行
- en: The same restrictions on accessing data in an underlying table apply when we
    update data using the `employees_tax_dept` view. [Listing 17-9](#listing17-9)
    shows a standard query to change the spelling of Suzanne’s last name using `UPDATE`
    (as a person with more than one uppercase letter in their last name, I can confirm
    such corrections aren’t unusual).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`employees_tax_dept`视图更新数据时，访问底层表数据的相同限制适用。[列表 17-9](#listing17-9)展示了一个标准查询，通过`UPDATE`更正Suzanne姓氏的拼写（作为一个姓氏中有多个大写字母的人，我可以确认这种更正并不罕见）。
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 17-9: Updating a row via the `employees_tax_dept` view'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-9：通过`employees_tax_dept`视图更新行
- en: 'Run the code, and the result from the `SELECT` query should show the updated
    last name, which occurs in the underlying `employees` table:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码后，`SELECT`查询的结果应显示更新后的姓氏，这会反映在底层的`employees`表中：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Suzanne’s last name is now correctly spelled as Le Gere, not Legere.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Suzanne的姓氏现在正确拼写为Le Gere，而不是Legere。
- en: However, if we try to update the name of an employee who’s not in the Tax Department,
    the query fails just as it did when we tried to insert Jamil White in [Listing
    17-8](#listing17-8). Trying to use this view to update the salary of an employee—even
    one in the Tax Department—will also fail. If the view doesn’t reference a column
    in the underlying table, you can’t access that column through the view. Again,
    the fact that updates on views are restricted in this way offers ways to secure
    and hide certain pieces of data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试更新一位不在税务部门的员工的姓名，查询会像在[示例 17-8](#listing17-8)中尝试插入 Jamil White 时一样失败。即使是在税务部门的员工，尝试通过此视图更新薪水也会失败。如果视图没有引用基础表中的某个列，你就无法通过视图访问该列。同样，视图上的更新受到这种限制，提供了保护和隐藏某些数据的方式。
- en: Deleting Rows Using the employees_tax_dept View
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 `employees_tax_dept` 视图删除行
- en: Now, let’s explore how to delete rows using a view. The restrictions on which
    data you can affect apply here as well. For example, if Suzanne Le Gere gets a
    better offer from another firm and decides to leave, you could remove her from
    `employees` through the `employees_tax_dept` view. [Listing 17-10](#listing17-10)
    shows the query in the standard `DELETE` syntax.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探讨如何使用视图删除行。这里也会有对哪些数据可以影响的限制。例如，如果 Suzanne Le Gere 从另一家公司获得了更好的报价并决定离开，你可以通过
    `employees_tax_dept` 视图将她从 `employees` 中移除。[示例 17-10](#listing17-10) 显示了标准 `DELETE`
    语法中的查询。
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 17-10: Deleting a row via the `employees_tax_dept` view'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 17-10：通过 `employees_tax_dept` 视图删除一行
- en: Run the query, and PostgreSQL should respond with `DELETE 1`. However, when
    you try to delete a row for an employee in a department other than the Tax Department,
    PostgreSQL won’t allow it and will report `DELETE 0`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 运行查询时，PostgreSQL 应该会返回 `DELETE 1`。但是，当你尝试删除一个不在税务部门的员工所在行时，PostgreSQL 会拒绝操作，并返回
    `DELETE 0`。
- en: In summary, views not only give you control over access to data, but also give
    you shortcuts for working with data. Next, let’s explore how to use functions
    to save keystrokes and time.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，视图不仅可以让你控制数据的访问，还能为你提供处理数据的快捷方式。接下来，让我们探讨如何使用函数来节省击键次数和时间。
- en: Creating Your Own Functions and Procedures
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建你自己的函数和过程
- en: You’ve used functions throughout the book, such as to capitalize letters with
    `upper()` or add numbers with `sum()`. Behind these functions is a significant
    amount of (sometimes complex) programming that executes a series of actions and
    may, depending on the job of the function, return a response. We’ll avoid complicated
    code here, but we’ll build some basic functions that you can use as a launchpad
    for your own ideas. Even simple functions can help you avoid repeating code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你已经使用过函数，例如使用 `upper()` 转换字母为大写，或使用 `sum()` 计算总和。这些函数背后有大量（有时复杂的）编程代码，它执行一系列操作，可能根据函数的功能返回响应。我们在这里避免使用复杂的代码，但会构建一些基本函数，作为你自己想法的跳板。即使是简单的函数也能帮助你避免重复代码。
- en: Much of the syntax in this section is specific to PostgreSQL, which supports
    both user-defined functions and *procedures* (the difference between the two is
    subtle, and I’ll give examples of both). You can define functions and procedures
    using plain SQL, but you also can choose from other options. One is a PostgreSQL-specific
    *procedural language* called PL/pgSQL that adds features not found in standard
    SQL, such as logical control structures (`IF ... THEN ... ELSE`). Other options
    include PL/Python and PL/R for the Python and R programming languages.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的大部分语法是 PostgreSQL 特有的，它支持用户自定义的函数和*过程*（两者之间的区别微妙，我会给出两者的例子）。你可以使用普通 SQL
    来定义函数和过程，但你也可以选择其他选项。一个选项是 PostgreSQL 特有的*过程语言* PL/pgSQL，它增加了一些标准 SQL 中没有的特性，例如逻辑控制结构（`IF
    ... THEN ... ELSE`）。其他选项包括 PL/Python 和 PL/R，分别用于 Python 和 R 编程语言。
- en: Note that major database systems including Microsoft SQL Server, Oracle, and
    MySQL implement their own variations of functions and procedures. If you’re using
    another database management system, this section will be useful for understanding
    concepts related to functions, but you’ll need to check your database’s documentation
    for specifics on its implementation of functions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，主要的数据库系统（包括 Microsoft SQL Server、Oracle 和 MySQL）都实现了自己变种的函数和过程。如果你使用的是其他数据库管理系统，本节将帮助你理解与函数相关的概念，但你需要查看数据库文档以了解其对函数的具体实现。
- en: Creating the percent_change() Function
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 `percent_change()` 函数
- en: 'A function processes data and returns a value. As an example, let’s write a
    function to simplify a staple of data analysis: calculating the percent change
    between two values. In Chapter 6, you learned that we express the percent change
    formula this way:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 函数处理数据并返回一个值。作为例子，让我们编写一个函数，简化数据分析中的常见任务：计算两个值之间的百分比变化。在第 6 章中，你学习了我们如何表达百分比变化公式：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Rather than writing that formula each time we need it, we can create a function
    called `percent_change()` that takes the new and old numbers as inputs and returns
    the result rounded to a user-specified number of decimal places. Let’s walk through
    the code in [Listing 17-11](#listing17-11) to see how to declare a simple function
    that uses SQL.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必每次都写这个公式，可以创建一个名为 `percent_change()` 的函数，接受新的和旧的数字作为输入，并返回结果，四舍五入到用户指定的小数位数。让我们通过
    [Listing 17-11](#listing17-11) 中的代码来了解如何声明一个使用 SQL 的简单函数。
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 17-11: Creating a `percent_change()` function'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 17-11: 创建 `percent_change()` 函数'
- en: A lot is happening in this code, but it’s not as complicated as it looks. We
    start with the command `CREATE OR REPLACE FUNCTION` 1. As with the syntax to create
    a view, the `OR REPLACE` keywords are optional. We then give the name of the function
    2 and, in parentheses, a list of *arguments* that determine the function’s inputs.
    Each argument will serve as an input to the function and gets a name and data
    type. For example, `new_value` and `old_value` are `numeric` and require that
    the user of the function supply input values matching that type, whereas `decimal_places`
    (which specifies the number of places to round results) is `integer`. For `decimal_places`,
    we specify `1` as the `DEFAULT` 3 value—this makes the argument optional and,
    if it’s omitted by the user, will set the argument to `1` by default.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码发生了很多事情，但它并不像看起来那么复杂。我们从命令 `CREATE OR REPLACE FUNCTION` 1 开始。与创建视图的语法一样，`OR
    REPLACE` 关键字是可选的。接着，我们给出函数的名称 2，并在括号中列出确定函数输入的 *参数*。每个参数都作为函数的输入，具有名称和数据类型。例如，`new_value`
    和 `old_value` 是 `numeric` 类型，要求函数用户提供匹配该类型的输入值，而 `decimal_places`（指定四舍五入结果的小数位数）是
    `integer` 类型。对于 `decimal_places`，我们指定 `1` 作为 `DEFAULT` 3 值——这使得该参数是可选的，如果用户省略了该参数，默认值将设置为
    `1`。
- en: We then use the keywords `RETURNS numeric AS` 4 to tell the function to return
    its calculation as type `numeric`. If this were a function to concatenate strings,
    we might return `text`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用关键字 `RETURNS numeric AS` 4 来告诉函数将其计算结果作为 `numeric` 类型返回。如果这是一个用于连接字符串的函数，我们可能会返回
    `text` 类型。
- en: Next, we write the meat of the function that performs the calculation. Inside
    single quotes, we place a `SELECT` query 5 that includes the percent change calculation
    nested inside a `round()` function. In the formula, we use the function’s argument
    names instead of numbers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写函数的核心部分，执行计算。在单引号内，我们放入一个 `SELECT` 查询 5，其中包含嵌套在 `round()` 函数中的百分比变化计算。在公式中，我们使用函数的参数名而不是数字。
- en: We then supply a series of keywords that define the function’s attributes and
    behavior. The `LANGUAGE` 6 keyword specifies that we’ve written this function
    using plain SQL as opposed to one of other languages PostgreSQL supports for creating
    functions. Next, the `IMMUTABLE` keyword 7 indicates that the function cannot
    modify the database and will always return the same result for a given set of
    arguments. The line `RETURNS NULL ON NULL INPUT` 8 guarantees that the function
    will supply a `NULL` response if any input that is not supplied by default is
    a `NULL`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们提供一系列定义函数属性和行为的关键字。`LANGUAGE` 6 关键字指定我们使用的是普通 SQL，而不是 PostgreSQL 支持的其他编程语言来创建函数。接下来，`IMMUTABLE`
    关键字 7 表示该函数不能修改数据库，并且对于给定的一组参数，它始终返回相同的结果。`RETURNS NULL ON NULL INPUT` 8 这一行保证了如果任何默认未提供的输入为
    `NULL`，函数将返回 `NULL`。
- en: Run the code using pgAdmin to create the `percent_change()` function. The server
    should respond with the message `CREATE FUNCTION`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pgAdmin 运行代码以创建 `percent_change()` 函数。服务器应返回 `CREATE FUNCTION` 消息。
- en: Using the percent_change() Function
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `percent_change()` 函数
- en: To test the new `percent_change()` function, run it by itself using `SELECT`,
    as shown in [Listing 17-12](#listing17-12).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试新的 `percent_change()` 函数，可以像 [Listing 17-12](#listing17-12) 中所示，单独运行它，使用
    `SELECT`。
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 17-12: Testing the `percent_change()` function'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 17-12: 测试 `percent_change()` 函数'
- en: This example uses a value of `110` for the new number, `108` for the old number,
    and `2` as the desired number of decimal places to round the result.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用 `110` 作为新值，`108` 作为旧值，`2` 作为四舍五入结果的小数位数。
- en: 'Run the code; the result should look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码；结果应如下所示：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The result tells us there’s a 1.85 percent increase between 108 and 110\. Experiment
    with other numbers to see how the results change. Also, try changing the `decimal_places`
    argument to values including `0`, or omit it, to see how that affects the output.
    You should see results that have more or fewer numbers after the decimal point,
    based on your input.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 结果告诉我们，108和110之间的百分比增加为1.85%。你可以尝试使用其他数字，看看结果如何变化。还可以尝试将`decimal_places`参数更改为包括`0`在内的值，或者省略它，看看这如何影响输出。你应该看到结果的小数点后面有更多或更少的数字，具体取决于你的输入。
- en: We created this function to avoid writing the full percent change formula in
    queries. Let’s use it to calculate percent change using a version of the census
    estimates population change query we wrote in Chapter 7, as shown in [Listing
    17-13](#listing17-13).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了这个函数，以避免在查询中编写完整的百分比变化公式。让我们使用它来计算百分比变化，使用我们在第七章编写的普查估计人口变化查询的版本，如[清单17-13](#listing17-13)所示。
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 17-13: Testing `percent_change()` on census data'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 清单17-13：在普查数据上测试`percent_change()`函数
- en: '[Listing 17-13](#listing17-13) modifies the original query from Chapter 7 to
    add the `percent_change()` function 1 as a column in `SELECT`. We also include
    the explicit percent change formula 2 so we can compare results. As inputs, we
    use the 2019 population estimate column (`c2019.pop_est_2019`) as the new number
    and the 2010 estimates base as the old (`c2010.estimates_base_2010`).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单17-13](#listing17-13)修改了第七章中的原始查询，在`SELECT`中添加了`percent_change()`函数1作为一列。我们还包括了明确的百分比变化公式2，以便我们可以比较结果。作为输入，我们使用2019年人口估算列（`c2019.pop_est_2019`）作为新数字，使用2010年估算基数作为旧数字（`c2010.estimates_base_2010`）。'
- en: 'The query results should display the five counties with the greatest percent
    change in population, and the results from the function should match the results
    from the formula entered directly into the query. Note that each value in the
    `pct_chg_func` column has one decimal place, the function’s default value, because
    we didn’t provide the optional third argument. Here’s the result with both the
    function and the formula:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 查询结果应显示人口变化百分比最大的五个县，并且函数的结果应与直接输入查询中的公式结果相匹配。请注意，`pct_chg_func`列中的每个值都有一个小数位，这是函数的默认值，因为我们没有提供可选的第三个参数。以下是同时使用函数和公式的结果：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now that we know the function works as intended, we can use `percent_change()`
    any time we need to solve that calculation—and that’s much faster than writing
    out the formula!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道函数按预期工作，我们可以在任何需要解决该计算时使用`percent_change()`——这比编写公式要快得多！
- en: Updating Data with a Procedure
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用过程更新数据
- en: As implemented in PostgreSQL, a *procedure* is a close relative of a function,
    albeit with some significant differences. Both procedures and functions can perform
    data operations that don’t return a value, such as an update. Procedures, on the
    other hand, don’t have a clause to return a value, while functions do. Also, procedures
    can incorporate the transaction commands we covered in Chapter 10 such as `COMMIT`
    and `ROLLBACK`, and functions cannot. Many database managers implement procedures,
    which are sometimes referred to as *stored procedures*. PostgreSQL added procedures
    as of version 11 and are part of the SQL standard, though PostgreSQL syntax is
    not fully compatible.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在PostgreSQL中实现的*过程*与函数非常相似，尽管有一些显著的不同之处。过程和函数都可以执行不返回值的数据操作，例如更新。然而，过程没有返回值的子句，而函数有。此外，过程可以包含我们在第10章中讲解的事务命令，例如`COMMIT`和`ROLLBACK`，而函数不能。许多数据库管理系统实现了过程，通常称为*存储过程*。PostgreSQL从版本11开始添加了过程，它们是SQL标准的一部分，但PostgreSQL的语法并不完全兼容。
- en: We can simplify routine updates to data using procedures. In this section, we’ll
    write a procedure that updates a record of the correct number of personal days
    off a teacher gets (in addition to vacation days) based on the time elapsed since
    their hire date.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用过程简化常规的数据更新。在本节中，我们将编写一个过程，根据教师的雇佣日期以来的时间，更新教师的个人休假天数（除了假期天数）。
- en: For this exercise, we’ll return to the `teachers` table from the first lesson
    in Chapter 2. If you skipped “Creating a Table” in that chapter, create the `teachers`
    table and insert the data now using the example code in Listings 2-2 and 2-3.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将返回到第二章第一节的`teachers`表。如果你跳过了该章节中的“创建表格”部分，现在使用清单2-2和2-3中的示例代码创建`teachers`表并插入数据。
- en: Let’s add a column to `teachers` to hold the teachers’ personal days using the
    code in [Listing 17-14](#listing17-14). The new column will be empty until we
    fill it later using a procedure.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向`teachers`表添加一列，用于存储教师的个人假期，使用[列表 17-14](#listing17-14)中的代码。新列在我们稍后使用过程填充之前将为空。
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 17-14: Adding a column to the `teachers` table and seeing the data'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-14：向`teachers`表添加一列并查看数据
- en: '[Listing 17-14](#listing17-14) updates the teachers table using `ALTER` and
    adds the `personal_days` column using the keywords `ADD COLUMN`. We then run the
    `SELECT` statement to view the data, in which we also include the names and hire
    dates of each teacher. When both queries finish, you should see the following
    six rows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 17-14](#listing17-14) 使用`ALTER`更新教师表，并通过`ADD COLUMN`关键字添加`personal_days`列。然后，我们运行`SELECT`语句查看数据，同时也包括每个教师的姓名和聘用日期。当两个查询完成后，你应该看到以下六行：'
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `personal_days` column contains only `NULL` values because we haven’t inserted
    anything yet.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`personal_days`列目前只包含`NULL`值，因为我们尚未插入任何内容。'
- en: 'Now, let’s create a procedure called `update_personal_days()` that populates
    the `personal_days` column with their earned personal days (in addition to vacation
    days). We’ll use the following criteria:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为`update_personal_days()`的过程，该过程将根据获得的个人假期（除了假期天数）填充`personal_days`列。我们将使用以下标准：
- en: 'Less than 10 years since hire: 3 personal days'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自聘用之日起不到 10 年：3 天个人假期
- en: '10 to less than 15 years since hire: 4 personal days'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自聘用之日起 10 年至 15 年：4 天个人假期
- en: '15 to less than 20 years since hire: 5 personal days'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自聘用之日起 15 年至 20 年：5 天个人假期
- en: '20 years to less than 25 years since hire: 6 personal days'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自聘用之日起 20 年至 25 年：6 天个人假期
- en: '25 years or more since hire: 7 personal days'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自聘用之日起 25 年或以上：7 天个人假期
- en: The code in [Listing 17-15](#listing17-15) creates a procedure. This time, instead
    of using plain SQL, we’ll incorporate elements of the PL/pgSQL procedural language,
    which is an additional language PostgreSQL supports for writing functions. Let’s
    walk through some differences.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 17-15](#listing17-15)中的代码创建了一个过程。这一次，我们不仅使用纯SQL，还结合了PL/pgSQL过程语言的元素，这是PostgreSQL支持的一种额外语言，用于编写函数。让我们来看看一些不同之处。'
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 17-15: Creating an `update_personal_days()` function'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-15：创建`update_personal_days()`函数
- en: We begin with `CREATE OR REPLACE PROCEDURE` and give the procedure a name. This
    time, we provide no arguments because no user input is required—the procedure
    operates on predetermined columns with set values for calculating intervals.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以`CREATE OR REPLACE PROCEDURE`开始，并为过程指定一个名称。这一次，我们没有提供参数，因为不需要用户输入——该过程操作的是预定的列，并具有用于计算间隔的固定值。
- en: Often, when writing PL/pgSQL-based functions, the PostgreSQL convention is to
    use the non-ANSI SQL standard dollar-quote (`$$`) to mark the start 1 and end
    5 of the string that contains all the function’s commands. (As with the `percent_change()`
    SQL function earlier, you could use single quote marks to enclose the string,
    but then any single quotes in the string would need to be doubled, and that not
    only looks messy but can be confusing.) So, everything between the pair of `$$`
    is the code that does the work. You can also add some text between the dollar
    signs, like `$namestring$`, to create a unique pair of beginning and ending quotes.
    This is useful, for example, if you need to quote a query inside the function.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写基于PL/pgSQL的函数时，PostgreSQL的约定通常是使用非ANSI SQL标准的美元引号（`$$`）来标记包含所有函数命令的字符串的开始和结束（就像之前的`percent_change()`
    SQL函数一样，你可以使用单引号来包围字符串，但那样字符串中的任何单引号就需要加倍，这不仅看起来凌乱，还可能引起混淆）。所以，`$$`之间的所有内容就是执行工作的代码。你也可以在美元符号之间添加一些文本，比如`$namestring$`，以创建一对独特的起始和结束引号。这在某些情况下很有用，比如你需要在函数内部引用一个查询时。
- en: Right after the first `$$` we start a `BEGIN ... END;` 2 block. This is a PL/pgSQL
    convention that delineates the start and end of a section of code within a function
    or procedure; as with dollar quotes, it is possible to nest one `BEGIN ... END;`
    inside another to facilitate logical groupings of code. Inside that block, we
    place an `UPDATE` statement that uses a `CASE` statement 3 to determine the number
    of days each teacher gets. We subtract the `hire_date` from the current date,
    which is retrieved from the server by the `now()` function. Depending on which
    range `now() - hire_date` falls into, the `CASE` statement returns the number
    of personal days corresponding to the range. We use the PL/pgSQL keywords `RAISE
    NOTICE` 4 to display a message that the procedure is done. Finally, we use the
    `LANGUAGE` keyword 6 so the database knows to interpret what we’ve written according
    to the syntax specific to PL/pgSQL.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着第一个 `$$` 后，我们开始一个 `BEGIN ... END;` 2 块。这是 PL/pgSQL 的约定，用于标识函数或过程中的代码段的开始和结束；与美元符号引号一样，可以将一个
    `BEGIN ... END;` 块嵌套在另一个块内，以便逻辑分组代码。在这个块内，我们放置了一个 `UPDATE` 语句，该语句使用 `CASE` 语句
    3 来确定每位教师的个人假期天数。我们通过 `now()` 函数从服务器获取当前日期，并用其减去 `hire_date`。根据 `now() - hire_date`
    所在的时间范围，`CASE` 语句返回对应的个人假期天数。我们使用 PL/pgSQL 关键字 `RAISE NOTICE` 4 来显示过程完成的消息。最后，我们使用
    `LANGUAGE` 关键字 6 使数据库知道我们编写的代码需要按照 PL/pgSQL 特定的语法进行解释。
- en: 'Run the code in [Listing 17-15](#listing17-15) to create the `update_personal_days()`
    procedure. To invoke the procedure, we use the `CALL` command, which is part of
    the ANSI SQL standard:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 [示例 17-15](#listing17-15) 中的代码来创建 `update_personal_days()` 过程。要调用该过程，我们使用
    `CALL` 命令，这是 ANSI SQL 标准的一部分：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When the procedure runs, the server responds with the notice it raises, which
    is `personal_days updated!`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当过程运行时，服务器会响应并显示它所引发的通知，内容为 `personal_days updated!`。
- en: When you rerun the `SELECT` statement in [Listing 17-14](#listing17-14), you
    should see that each row of the `personal_days` column is filled with the appropriate
    values. Note that results will vary depending on when you run this function, because
    calculations using `now()` change as time passes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当您重新运行 [示例 17-14](#listing17-14) 中的 `SELECT` 语句时，您应该会看到 `personal_days` 列的每一行都填充了相应的值。请注意，结果会有所不同，具体取决于您运行此函数的时间，因为使用
    `now()` 的计算会随时间变化而变化。
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You could use the `update_personal_days()` function to regularly update data
    manually after performing certain tasks, or you could use a task scheduler such
    as pgAgent (a separate open source tool) to run it automatically. You can learn
    about pgAgent and other tools in “PostgreSQL Utilities, Tools, and Extensions”
    in the appendix.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在执行某些任务后手动使用 `update_personal_days()` 函数定期更新数据，或者可以使用任务调度程序（如 pgAgent，一个独立的开源工具）自动运行它。您可以在附录的《PostgreSQL
    实用工具、工具和扩展》中了解有关 pgAgent 和其他工具的更多信息。
- en: Using the Python Language in a Function
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在函数中使用 Python 语言
- en: Previously, I mentioned that PL/pgSQL is the default procedural language within
    PostgreSQL, but the database also supports creating functions using open source
    languages, such as Python and R. This support allows you to take advantage of
    features and modules from those languages within functions you create. For example,
    with Python, you can use the `pandas` library for analysis. The documentation
    at [https://www.postgresql.org/docs/current/server-programming.html](https://www.postgresql.org/docs/current/server-programming.html)
    provides a comprehensive review of the languages included with PostgreSQL, but
    here I’ll show you a simple function using Python.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我提到过 PL/pgSQL 是 PostgreSQL 中的默认过程语言，但数据库还支持使用开源语言（如 Python 和 R）创建函数。这种支持使您能够在创建的函数中利用这些语言的特性和模块。例如，使用
    Python，您可以使用 `pandas` 库进行分析。有关 PostgreSQL 中包含的语言的详细信息，请参考 [https://www.postgresql.org/docs/current/server-programming.html](https://www.postgresql.org/docs/current/server-programming.html)
    上的文档，但在这里我将展示一个使用 Python 的简单函数。
- en: To enable PL/Python, you must create the extension using the code in [Listing
    17-16](#listing17-16).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 PL/Python，您必须使用 [示例 17-16](#listing17-16) 中的代码创建扩展。
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 17-16: Enabling the PL/Python procedural language'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 17-16：启用 PL/Python 过程语言
- en: If you get an error, such as `image not found`, that means the PL/Python extension
    is not installed on your system. Depending on the operating system, installation
    of PL/Python typically requires installation of Python and additional configuration
    beyond the basic PostgreSQL install. For this, refer to the installation instructions
    for your operating system in Chapter 1.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到错误信息，如`image not found`，那意味着系统上未安装PL/Python扩展。根据操作系统的不同，PL/Python的安装通常需要安装Python并进行一些基本PostgreSQL安装之外的额外配置。有关详细信息，请参考第1章中针对你操作系统的安装说明。
- en: After enabling the extension, we can create a function using syntax similar
    to the examples you’ve tried so far, but using Python for the body of the function.
    [Listing 17-17](#listing17-17) shows how to use PL/Python to create a function
    called `trim_county()` that removes the word *County* from the end of a string.
    We’ll use this function to clean up names of counties in the census data.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 启用扩展后，我们可以使用类似你之前尝试过的语法创建一个函数，但在函数体中使用Python。[Listing 17-17](#listing17-17)展示了如何使用PL/Python创建一个名为`trim_county()`的函数，该函数移除字符串末尾的*County*。我们将使用这个函数来清理人口普查数据中的县名。
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 17-17: Using PL/Python to create the `trim_county()` function'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 17-17: 使用PL/Python创建`trim_county()`函数'
- en: The structure should look familiar. After naming the function and its text input,
    we use the `RETURNS` keyword 1 to specify that the function will send text back.
    After the opening `$$` quotes, we get straight to the Python code, starting with
    a statement to import the Python regular expressions module, `re` 2. Even if you
    don’t know much about Python, you can probably deduce that the next two lines
    of code 3 set a variable called `cleaned` to the results of a Python regular expression
    function called `sub()`. That function looks for a space followed by the word
    *County* in the `input_string` passed into the function and substitutes an empty
    string, which is denoted by two apostrophes. Then the function returns the content
    of the variable `cleaned`. To end, we specify `LANGUAGE plpython3u` 4 to note
    we’re writing the function with PL/Python.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 结构看起来应该很熟悉。为函数命名并定义其文本输入后，我们使用`RETURNS`关键字1来指定该函数将返回文本。在开头的`$$`符号之后，我们直接写入Python代码，从导入Python正则表达式模块`re`
    2开始。即使你不太了解Python，你也许可以推测接下来的两行代码3是设置一个变量`cleaned`，它保存了Python正则表达式函数`sub()`的结果。该函数在`input_string`中查找一个空格后跟单词*County*的模式，并将其替换为空字符串（由两个撇号表示）。然后该函数返回`cleaned`变量的内容。最后，我们指定`LANGUAGE
    plpython3u` 4来标明我们使用PL/Python编写函数。
- en: Run the code to create the function, and then execute the `SELECT` statement
    in [Listing 17-18](#listing17-18) to see it in action.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码以创建函数，然后执行[Listing 17-18](#listing17-18)中的`SELECT`语句，查看函数执行效果。
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 17-18: Testing the `trim_county()` function'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 17-18: 测试`trim_county()`函数'
- en: 'We use the `county_name` column in the `us_counties_pop_est_2019` table as
    input to `trim_county()`. That should return these results:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`county_name`列作为输入，传递给`us_counties_pop_est_2019`表中的`trim_county()`函数。那应该返回以下结果：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, the `trim_county()` function evaluated each value in the `county_name`
    column and removed a space and the word *County* when present. Although this is
    a trivial example, it shows how easy it is to use Python—or one of the other supported
    procedural languages—inside a function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`trim_county()`函数检查了`county_name`列中的每个值，并在存在时删除了空格和单词*County*。虽然这是一个简单的例子，但它展示了如何轻松地在函数中使用Python（或其他支持的过程语言）。
- en: Next, you’ll learn how to use triggers to automate your database.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何使用触发器来自动化数据库操作。
- en: Automating Database Actions with Triggers
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用触发器自动化数据库操作
- en: A database *trigger* executes a function whenever a specified event, such as
    an `INSERT`, `UPDATE`, or `DELETE`, occurs on a table or a view. You can set a
    trigger to fire before, after, or instead of the event, and you can also set it
    to fire once for each row affected by the event or just once per operation. For
    example, let’s say you delete 20 rows from a table. You could set the trigger
    to fire once for each of the 20 rows deleted or just one time.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中的*触发器*在每次发生指定事件（例如`INSERT`、`UPDATE`或`DELETE`）时都会执行一个函数。你可以设置触发器在事件发生前、后，或代替事件触发，并且可以设置它仅对每一行受到事件影响的记录触发一次，或者每次操作只触发一次。例如，假设你从一个表中删除了20行数据。你可以设置触发器，在每删除一行时都触发一次，或者只触发一次。
- en: We’ll work through two examples. The first example keeps a log of changes made
    to grades at a school. The second automatically classifies temperatures each time
    we collect a reading.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过两个例子进行演示。第一个例子记录学校成绩的变化日志。第二个例子每次收集温度读数时，自动对温度进行分类。
- en: Logging Grade Updates to a Table
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将成绩更新记录到表格中
- en: 'Let’s say we want to automatically track changes made to a student `grades`
    table in our school’s database. Every time a row is updated, we want to record
    the old and new grade plus the time the change occurred (search online for *David
    Lightman and grades* and you’ll see why this might be worth tracking). To handle
    this task automatically, we’ll need three items:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要自动跟踪我们学校数据库中学生 `grades` 表的变化。每次更新一行数据时，我们想记录旧成绩、新成绩以及更改发生的时间（在线搜索 *David
    Lightman and grades*，你会理解为什么这值得跟踪）。为了自动处理这个任务，我们需要三项内容：
- en: A `grades_history` table to record the changes to grades in a `grades` table
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `grades_history` 表，用来记录 `grades` 表中成绩的变化
- en: A trigger to run a function every time a change occurs in the `grades` table,
    which we’ll name `grades_update`
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个触发器，每次 `grades` 表发生变化时都会运行一个函数，我们将其命名为 `grades_update`
- en: The function the trigger will execute, which we’ll call `record_if_grade_changed()`
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发器将执行的函数，我们称之为 `record_if_grade_changed()`
- en: Creating Tables to Track Grades and Updates
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建表格以跟踪成绩和更新
- en: Let’s start by making the tables we need. [Listing 17-19](#listing17-19) includes
    the code to first create and fill `grades` and then create `grades_history`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从创建所需的表格开始。[清单 17-19](#listing17-19) 包含了首先创建并填充 `grades` 表，然后创建 `grades_history`
    表的代码。
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 17-19: Creating the `grades` and `grades_history` tables'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 17-19：创建 `grades` 和 `grades_history` 表
- en: These commands are straightforward. We use `CREATE` to make a `grades` table
    1 and add four rows using `INSERT` 2, where each row represents a student’s grade
    in a class. Then we use `CREATE TABLE` to make the `grades_history` table 3 to
    hold the data we log each time an existing grade is altered. The `grades_history`
    table has columns for the new grade, old grade, and the time of the change. Run
    the code to create the tables and fill the `grades` table. We insert no data into
    `grades_history` here because the trigger process will handle that task.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令很简单。我们使用 `CREATE` 创建一个 `grades` 表 1，并使用 `INSERT` 2 添加四行数据，每一行表示一名学生在某门课程中的成绩。接着，我们使用
    `CREATE TABLE` 创建 `grades_history` 表 3，用于记录每次现有成绩被更改时的日志。`grades_history` 表有新成绩、旧成绩和更改时间的列。运行代码以创建这些表格并填充
    `grades` 表。在这里我们不往 `grades_history` 表插入任何数据，因为触发器会处理这项任务。
- en: Creating the Function and Trigger
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建函数和触发器
- en: Next, let’s write the `record_if_grade_changed()` function that the trigger
    will execute (note that the PostgreSQL documentation refers to such functions
    as *trigger procedures*). We must write the function before naming it in the trigger.
    Let’s go through the code in [Listing 17-20](#listing17-20).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写触发器将执行的 `record_if_grade_changed()` 函数（注意，PostgreSQL 文档中将此类函数称为 *触发器过程*）。我们必须在触发器中引用该函数之前先编写它。让我们查看
    [清单 17-20](#listing17-20) 中的代码。
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 17-20: Creating the `record_if_grade_changed()` function'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 17-20：创建 `record_if_grade_changed()` 函数
- en: The `record_if_grade_changed()` function follows the pattern of earlier examples
    but with differences specific to working with triggers. First, we specify `RETURNS
    trigger` 1 instead of a data type. We use dollar-quotes to delineate the code
    portion of the function, and because `record_if_grade_changed()` is a PL/pgSQL
    function, we also place the code to execute inside a `BEGIN ... END;` block. Next,
    we start the procedure using an `IF ... THEN` statement 2, which is one of the
    control structures PL/pgSQL provides. We use it here to run the `INSERT` statement
    only if the updated grade is different from the old grade, which we check using
    the `<>` operator.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`record_if_grade_changed()` 函数遵循早期示例的模式，但在与触发器配合使用时有一些特定的区别。首先，我们指定 `RETURNS
    trigger` 1，而不是数据类型。我们使用美元引号来分隔函数的代码部分，并且由于 `record_if_grade_changed()` 是一个 PL/pgSQL
    函数，我们还将执行代码放在 `BEGIN ... END;` 块中。接下来，我们使用 `IF ... THEN` 语句 2 启动过程，这是 PL/pgSQL
    提供的控制结构之一。我们在这里使用它来仅在更新的成绩与旧成绩不同的情况下运行 `INSERT` 语句，我们通过 `<>` 运算符来进行检查。'
- en: When a change occurs to the `grades` table, the trigger (which we’ll create
    next) will execute. For each row that’s changed, the trigger will pass two collections
    of data into `record_if_grade_changed()`. The first is the row values *before*
    they were changed, noted with the prefix `OLD`. The second is the row values *after*
    they were changed, noted with the prefix `NEW`. The function can access the original
    row values and the updated row values, which it will use for a comparison. If
    the `IF ... THEN` statement evaluates as `true`, indicating that the old and new
    `grade` values are different, we use `INSERT` to add a row to `grades_history`
    that contains both `OLD.grade` 3 and `NEW.grade` 4. Finally, we include a `RETURN`
    statement 5 with a value of `NULL`; the trigger procedure performs a database
    `INSERT`, so we do not need a value returned.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `grades` 表发生变化时，将执行我们接下来要创建的触发器。对于每一行的更改，触发器将把两个数据集传递到 `record_if_grade_changed()`
    中。第一个是更改之前的行值，以 `OLD` 前缀标记。第二个是更改之后的行值，以 `NEW` 前缀标记。函数可以访问原始行值和更新后的行值，用于比较。如果
    `IF ... THEN` 语句评估为 `true`，表明旧的和新的 `grade` 值不同，我们使用 `INSERT` 将包含 `OLD.grade` 3
    和 `NEW.grade` 4 的行添加到 `grades_history`。最后，我们包含一个带有 `NULL` 值的 `RETURN` 语句 5；触发器过程执行数据库
    `INSERT`，因此我们不需要返回值。
- en: Run the code in [Listing 17-20](#listing17-20) to create the function. Then,
    add the `grades_update` trigger to the `grades` table using [Listing 17-21](#listing17-21).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 [列表 17-20](#listing17-20) 中的代码来创建函数。然后，使用 [列表 17-21](#listing17-21) 将 `grades_update`
    触发器添加到 `grades` 表中。
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 17-21: Creating the `grades_update` trigger'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-21：创建`grades_update`触发器
- en: In PostgreSQL, the syntax for creating a trigger follows the ANSI SQL standard
    (although not all aspects of the standard are supported, per the documentation
    at [https://www.postgresql.org/docs/current/sql-createtrigger.html](https://www.postgresql.org/docs/current/sql-createtrigger.html)).
    The code begins with a `CREATE TRIGGER` 1 statement, followed by clauses that
    control when the trigger runs and how it behaves. We use `AFTER UPDATE` 2 to specify
    that we want the trigger to fire after the update occurs on the `grades` row.
    We could also use the `BEFORE` or `INSTEAD OF` keywords depending on the need.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PostgreSQL 中，创建触发器的语法遵循 ANSI SQL 标准（尽管文档中并不支持标准的所有方面，详情请见 [https://www.postgresql.org/docs/current/sql-createtrigger.html](https://www.postgresql.org/docs/current/sql-createtrigger.html)）。代码以
    `CREATE TRIGGER` 1 语句开头，接着是控制触发器何时运行以及如何运行的子句。我们使用 `AFTER UPDATE` 2 来指定我们希望触发器在
    `grades` 行更新后执行。根据需要，我们还可以使用 `BEFORE` 或 `INSTEAD OF` 关键字。
- en: We write `FOR EACH ROW` 3 to tell the trigger to execute the procedure once
    for each row updated in the table. For example, if someone runs an update that
    affects three rows, the procedure will run three times. The alternate (and default)
    is `FOR EACH STATEMENT`, which runs the procedure once. If we didn’t care about
    capturing changes to each row and simply wanted to record that grades were changed
    at a certain time, we could use that option. Finally, we use `EXECUTE PROCEDURE`
    4 to name `record_if_grade_changed()` as the function the trigger should run.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `FOR EACH ROW` 3 来告诉触发器在更新表中的每一行时执行该过程。例如，如果某人运行的更新影响了三行，该过程将运行三次。另一种（也是默认的）是
    `FOR EACH STATEMENT`，它只运行一次过程。如果我们不关心捕获每一行的更改，只想记录在特定时间内更改了成绩，我们可以使用该选项。最后，我们使用
    `EXECUTE PROCEDURE` 4 来指定触发器应运行的函数为 `record_if_grade_changed()`。
- en: Create the trigger by running the code in [Listing 17-21](#listing17-21) in
    pgAdmin. The database should respond with the message `CREATE TRIGGER`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pgAdmin 中运行 [列表 17-21](#listing17-21) 中的代码来创建触发器。数据库应该会响应 `CREATE TRIGGER`
    消息。
- en: Testing the Trigger
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试触发器
- en: 'Now that we’ve created the trigger and the function, it should run when data
    in the `grades` table changes; let’s see what the process does. First, let’s check
    the current status of our data. When you run `SELECT * FROM grades_history;`,
    you’ll see that the table is empty because we haven’t made any changes to the
    `grades` table yet and there’s nothing to track. Next, when you run `SELECT *
    FROM grades ORDER BY student_id, course_id;`, you should see the grade data that
    you inserted in [Listing 17-19](#listing17-19), as shown here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了触发器和函数，当`grades`表中的数据发生变化时，它应该会运行；让我们看看这个过程是如何运行的。首先，让我们检查我们数据的当前状态。当你运行
    `SELECT * FROM grades_history;` 时，你会看到表是空的，因为我们还没有对 `grades` 表进行任何更改，没有需要跟踪的内容。接下来，当你运行
    `SELECT * FROM grades ORDER BY student_id, course_id;` 时，你应该会看到你在 [列表 17-19](#listing17-19)
    中插入的成绩数据，如下所示：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: That Biology 2 grade doesn’t look very good. Let’s update it using the code
    in [Listing 17-22](#listing17-22).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 那个生物学 2 等级看起来不怎么好。让我们使用 [列表 17-22](#listing17-22) 中的代码进行更新。
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 17-22: Testing the `grades_update` trigger'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 17-22: 测试 `grades_update` 触发器'
- en: 'When you run the `UPDATE`, pgAdmin doesn’t display anything to let you know
    that the trigger executed in the background. It just reports `UPDATE 1`, meaning
    a row was updated. But our trigger did run, which we can confirm by examining
    columns in `grades_history` using this `SELECT` query:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行 `UPDATE` 后，pgAdmin 不会显示任何内容来告知您后台执行了触发器。它只会报告 `UPDATE 1`，表示已更新一行。但我们的触发器确实运行了，我们可以通过检查使用此
    `SELECT` 查询查看 `grades_history` 表中的列来确认：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When you run this query, you should see that the `grades_history` table, which
    contains all changes to grades, now has one row:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此查询时，您应该看到 `grades_history` 表中包含了一行变更：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This row displays the old Biology 2 grade of `F`, the new value `C`, and `change_time`,
    showing the time of update (your result should reflect your date and time). Note
    that the addition of this row to `grades_history` happened in the background without
    the knowledge of the person making the update. But the `UPDATE` event on the table
    caused the trigger to fire, which executed the `record_if_grade_changed()` function.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此行显示了旧的生物学 2 等级 `F`，新值 `C`，以及 `change_time`，显示了更新的时间（你的结果应反映出你的日期和时间）。请注意，将此行添加到
    `grades_history` 是在没有更新者知情的情况下背景进行的。但是表格上的 `UPDATE` 事件触发了触发器执行了 `record_if_grade_changed()`
    函数。
- en: If you’ve ever used a content management system, such as WordPress or Drupal,
    this sort of revision tracking might be familiar. It provides a helpful record
    of changes made to content for reference, auditing, and, unfortunately, occasional
    finger-pointing. Regardless, the ability to trigger actions on a database automatically
    gives you more control over your data.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经使用过内容管理系统，例如 WordPress 或 Drupal，这种修订跟踪可能会很熟悉。它提供了一个有用的记录内容变更的方式，用于参考、审计，以及偶尔的责备。无论如何，自动触发数据库操作的能力让您对数据有了更多的控制。
- en: Automatically Classifying Temperatures
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动分类温度
- en: In Chapter 13, we used the SQL `CASE` statement to reclassify temperature readings
    into descriptive categories. The `CASE` statement is also part of the PL/pgSQL
    procedural language, and we can use its capability to assign values to variables
    to automatically store those category names in a table each time we add a temperature
    reading. If we’re routinely collecting temperature readings, using this technique
    to automate the classification spares us from having to handle the task manually.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 13 章中，我们使用 SQL 的 `CASE` 语句将温度读数重新分类为描述性类别。`CASE` 语句也是 PL/pgSQL 过程化语言的一部分，我们可以利用它的能力为变量赋值，以便每次添加温度读数时自动将这些类别名称存储在表格中。如果我们经常收集温度读数，使用这种技术自动化分类可以避免手动处理任务。
- en: 'We’ll follow the same steps we used for logging the grade changes: we first
    create a function to classify the temperatures and then create a trigger to run
    the function each time the table is updated. Use [Listing 17-23](#listing17-23)
    to create a `temperature_test` table for the exercise.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照记录成绩变化的相同步骤进行操作：首先创建一个函数来分类温度，然后创建一个触发器，在每次更新表格时运行该函数。使用 [列表 17-23](#listing17-23)
    来创建一个名为 `temperature_test` 的表格以供练习使用。
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 17-23: Creating a `temperature_test` table'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 17-23: 创建一个名为 `temperature_test` 的表格'
- en: The `temperature_test` table contains columns to hold the name of the station
    and date of the temperature observation. Let’s imagine that we have some process
    to insert a row once a day that provides the maximum and minimum temperature for
    that location, and we need to fill the `max_temp_group` column with a descriptive
    classification of the day’s high reading to provide text to a weather forecast
    we’re distributing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`temperature_test` 表包含用于保存站点名称和温度观测日期的列。假设我们有某个过程，每天插入一行数据，提供该位置的最高和最低温度，并且我们需要填写
    `max_temp_group` 列以提供天气预报的描述性分类的文本。'
- en: To do this, we first make a function called `classify_max_temp()`, as shown
    in [Listing 17-24](#listing17-24).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们首先创建一个名为 `classify_max_temp()` 的函数，如 [列表 17-24](#listing17-24) 所示。
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Listing 17-24: Creating the `classify_max_temp()` function'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 17-24: 创建 `classify_max_temp()` 函数'
- en: By now, these functions should look familiar. What’s new here is the PL/pgSQL
    version of the `CASE` syntax 1, which differs slightly from the SQL syntax. The
    PL/pgSQL syntax includes a semicolon after each `WHEN ... THEN` clause. Also new
    is the *assignment operator* `:=`, which we use to assign the descriptive name
    to the `NEW.max_temp_group` column based on the outcome of the `CASE` function.
    For example, the statement `NEW.max_temp_group := 'Cold'` assigns the string `'Cold'`
    to `NEW.max_temp_group` when the temperature value is greater than or equal to
    33 degrees but less than 50 degrees Fahrenheit. When the function returns the
    `NEW` row to be inserted in the table, it will include the string value `Cold`.
    Run the code to create the function.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这些函数应该看起来很熟悉。这里的新内容是`CASE`语法的PL/pgSQL版本 1，它与SQL语法稍有不同。PL/pgSQL语法在每个`WHEN
    ... THEN`子句后面都包括一个分号。另一个新内容是*赋值运算符* `:=`，我们用它根据`CASE`函数的结果为`NEW.max_temp_group`列赋予描述性名称。例如，语句`NEW.max_temp_group
    := 'Cold'`会在温度值大于或等于33度但小于50度华氏度时，将字符串`'Cold'`赋给`NEW.max_temp_group`。当函数将`NEW`行返回以插入表中时，`NEW.max_temp_group`列会包含字符串值`Cold`。运行代码以创建该函数。
- en: Next, using the code in [Listing 17-25](#listing17-25), create a trigger to
    execute the function each time a row is added to `temperature_test`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用[清单17-25](#listing17-25)中的代码，创建一个触发器，每次向`temperature_test`添加一行数据时执行该函数。
- en: '[PRE41]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 17-25: Creating the `temperature_insert` trigger'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 清单17-25：创建`temperature_insert`触发器
- en: In this example, we classify `max_temp` and create a value for `max_temp_group`
    prior to inserting the row into the table. Doing so is more efficient than performing
    a separate update after the row is inserted. To specify that behavior, we set
    the `temperature_insert` trigger to fire `BEFORE INSERT` 1.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在将行插入表之前对`max_temp`进行分类，并为`max_temp_group`创建一个值。这样做比在插入后执行单独的更新操作更高效。为了指定这种行为，我们将`temperature_insert`触发器设置为在`BEFORE
    INSERT` 1时触发。
- en: We also want the trigger to fire `FOR EACH ROW` 2 because we want each `max_temp`
    recorded in the table to get a descriptive classification. The final `EXECUTE
    PROCEDURE` statement names the `classify_max_temp()` function 3 we just created.
    Run the `CREATE TRIGGER` statement in pgAdmin, and then test the setup using [Listing
    17-26](#listing17-26).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望触发器以`FOR EACH ROW` 2触发，因为我们希望表中记录的每个`max_temp`都能获得一个描述性的分类。最终的`EXECUTE
    PROCEDURE`语句指定了我们刚创建的`classify_max_temp()`函数 3。运行`CREATE TRIGGER`语句在pgAdmin中创建触发器，然后使用[清单17-26](#listing17-26)测试设置。
- en: '[PRE42]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 17-26: Inserting rows to test the `temperature_insert` trigger'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 清单17-26：插入行以测试`temperature_insert`触发器
- en: 'Here we insert five rows into `temperature_test`, and we expect the `temperature_insert`
    trigger to fire for each row—and it does! The `SELECT` statement in the listing
    should display these results:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向`temperature_test`插入了五行数据，并且我们期望每行都会触发`temperature_insert`触发器——而它确实做到了！清单中的`SELECT`语句应显示这些结果：
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Thanks to the trigger and function, each `max_temp` inserted automatically receives
    the appropriate classification in the `max_temp_group` column—including the instance
    where we had no reading for that value. Note that the trigger’s update of the
    column will override any user-supplied values during insert.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢触发器和函数的帮助，每个插入的`max_temp`都会自动在`max_temp_group`列中获得适当的分类——即使该值没有读取。请注意，触发器对该列的更新将在插入过程中覆盖任何用户提供的值。
- en: This temperature example and the earlier grade-change auditing example are rudimentary,
    but they give you a glimpse of how useful triggers and functions can be in simplifying
    data maintenance.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个温度示例和之前的成绩变更审计示例虽然比较基础，但它们让你初步了解了触发器和函数在简化数据维护方面的强大作用。
- en: Wrapping Up
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Although the techniques you learned in this chapter begin to merge with those
    of a database administrator, you can apply the concepts to reduce the amount of
    time you spend repeating certain tasks. I hope these approaches will help you
    free up more time to find interesting stories in your data.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你在本章中学到的技术开始与数据库管理员的技能重合，但你可以应用这些概念来减少重复某些任务所花费的时间。我希望这些方法能帮助你腾出更多时间，从数据中发现有趣的故事。
- en: This chapter concludes our discussion of analysis techniques and the SQL language.
    The next two chapters offer workflow tips to help you increase your command of
    PostgreSQL. They include how to connect to a database and run queries from your
    computer’s command line and how to maintain your database.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了我们对分析技术和SQL语言的讨论。接下来的两章将提供一些工作流程技巧，帮助你提升对PostgreSQL的掌握。内容包括如何从计算机的命令行连接数据库并运行查询，以及如何维护你的数据库。
