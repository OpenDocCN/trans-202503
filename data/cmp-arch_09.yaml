- en: '**7**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7**'
- en: '**DIGITAL CPU DESIGN**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**数字CPU设计**'
- en: '![Image](../images/f0155-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0155-01.jpg)'
- en: We’ve been building up larger and larger components of digital electronic computers,
    from transistors, to logic gates, to simple machines such as decoders and adders.
    Now it’s time to put everything together at the top level to make a digital electronic
    CPU. At least until very recently, the CPU has been the heart of digital electronic
    computers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在构建越来越大的数字电子计算机组件，从晶体管、逻辑门到简单的机器，如解码器和加法器。现在是时候将所有这些组件组合起来，构建数字电子CPU了。至少直到最近，CPU一直是数字电子计算机的核心。
- en: 'The aim of this chapter is to overcome your fear of digital electronic CPUs.
    Modern CPUs are probably the second most complex device known to humanity, after
    the human brain. If you look at a CPU circuit under a microscope and see all the
    wiring without first preparing your mind, you’ll likely go crazy. As with driving,
    you don’t study a modern, state-of-the-art machine immediately; you start with
    a bicycle, then an old beat-up car, and then, as you get a feel for the systems,
    you progress to more powerful and modern machines. Likewise, we’ll use one of
    the first and simplest digital electronic CPU systems as our example for this
    chapter: the Manchester Baby. Contemporary CPUs are much more complicated and
    may vary or break many or all of the design principles covered here, but they’re
    still based on classical ideas. Seeing how they play out in a historical machine
    like the Baby will help us understand the basics.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是克服你对数字电子CPU的恐惧。现代CPU可能是人类已知的第二复杂的设备，仅次于人脑。如果你在显微镜下观察CPU电路，并看到所有的接线而没有事先准备好自己的思维，你很可能会崩溃。就像开车一样，你不会直接学习现代最先进的机器；你从自行车开始，然后是破旧的老车，随着你对系统的熟悉，你会逐步过渡到更强大、更现代的机器。同样，我们将在本章中使用最初和最简单的数字电子CPU系统作为例子：曼彻斯特婴儿。现代的CPU复杂得多，可能会偏离或打破这里介绍的许多设计原则，但它们仍然基于经典的理念。通过观察历史机器如婴儿是如何实现这些理念的，我们可以帮助自己理解基本概念。
- en: We’ve already seen and understood the basic structure of a CPU from Babbage’s
    Analytical Engine, so here we’ll focus on the digital electronic implementations
    of the same overall design. As with Babbage, we’ll play a bit fast and loose with
    the actual details and history of the Manchester Baby; the point is to use it
    to get a flavor of digital CPUs in general. The original Baby’s digital electronics
    were built from vacuum tubes rather than transistors, and didn’t necessarily use
    the same structures that we’d use today to re-implement its functionality. Nonetheless,
    the simple machines that we’ve studied can be used to build a modernized implementation
    of the Baby. We’ll build such an implementation here, capable of running real
    programs, using LogiSim. But first, we’ll learn what the Baby needs to be capable
    of by programming it as a user.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解并理解了来自巴贝奇分析机的CPU基本结构，因此这里我们将重点介绍相同总体设计的数字电子实现。像巴贝奇一样，我们会对曼彻斯特婴儿的实际细节和历史稍微有些松散的处理；重点是用它来体验数字CPU的基本特征。原始婴儿的数字电子元件是用真空管而非晶体管构建的，并且不一定使用我们今天重新实现其功能时所用的相同结构。尽管如此，我们研究过的简单机器可以用来构建婴儿的现代化实现。我们将在这里构建这样一个实现，能够运行实际程序，使用LogiSim。但首先，我们将通过将婴儿作为用户进行编程，来了解婴儿需要具备哪些能力。
- en: The Baby’s Programmer Interface
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 婴儿的程序员接口
- en: Unlike the Analytical Engine, von Neumann architectures such as the Baby store
    their instructions and data in the same RAM space. A program is thus a list of
    lines that are all copied into RAM. Each line has a number, and it gets copied
    to the RAM address of that same number. Like the Analytical Engine, a program
    is made up of binary *machine code* corresponding to a series of instructions
    from its instruction set.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与分析机不同，像婴儿这样的冯·诺依曼架构将指令和数据存储在相同的RAM空间中。一个程序因此就是一个指令列表，所有指令都会被复制到RAM中。每一行都有一个编号，它会被复制到该编号对应的RAM地址。像分析机一样，程序由二进制*机器代码*组成，对应着指令集中的一系列指令。
- en: Here’s the Baby’s complete instruction set. We’ll discuss each instruction in
    more detail in the following sections.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是婴儿的完整指令集。我们将在接下来的章节中更详细地讨论每一条指令。
- en: HLT Halt the Baby and light the stop lamp
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: HLT 停止婴儿并点亮停止灯
- en: LDN Load the negated content of the specified address
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: LDN 加载指定地址的取反内容
- en: STO Store the latest result to the specified address
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: STO 将最新结果存储到指定地址
- en: SUB Subtract the content of the specified address from the result
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: SUB 从结果中减去指定地址的内容
- en: JMP Jump to the line number stored in the given address
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JMP 跳转到给定地址中存储的行号
- en: JRP Jump forward by the number of lines stored in the given address
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: JRP 跳转到给定地址中存储的行数
- en: 'SKN Compare the result: if less than 0, skip the next instruction'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SKN 比较结果：如果小于 0，则跳过下一条指令
- en: '**NOTE**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The Baby’s designers really wanted to have a regular load instruction, as
    in the Analytical Engine and most modern computers, to load a copy of the data
    stored at the address. But due to technical limitations of the time, they were
    forced to replace this with `LDN`, “load negated,” which also inverts each of
    the bits from the data as they are loaded. This is a famous quirk of the Baby
    that gives its programming a distinctive problem-solving flavor.*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*Baby 的设计者们真心希望能有一种像分析引擎和大多数现代计算机中那样的常规加载指令，用于加载存储在某个地址的数据副本。但由于当时的技术限制，他们不得不将其替换为
    `LDN`，即“加载取反”，在加载数据时会反转每一位。这是 Baby 的一个著名特性，使得它的编程具有独特的解决问题的风格。*'
- en: '*Halting*'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*停止*'
- en: 'The `HLT` instruction stops the machine. This prevents execution of any further
    instructions and turns on a light bulb to tell the user that the work has finished,
    so they know when to inspect the results. The simplest Baby program is thus:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`HLT` 指令使机器停止。这会阻止任何进一步指令的执行，并点亮一个灯泡，告诉用户工作已经完成，这样他们就知道何时检查结果。最简单的 Baby 程序就是这样：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The line number 01 on the left of the instruction is also the RAM address where
    the instruction will be stored. When this program is loaded into the Baby’s RAM,
    address 1 of RAM will contain the binary machine code for `HLT`. After loading
    the program, it can be run. The Baby begins execution from address 1 (not address
    0, because the program counter is incremented just before each fetch) so the `HLT`
    will be executed, causing the Baby to halt.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 指令左侧的行号 01 也是该指令将存储的 RAM 地址。当这个程序被加载到 Baby 的 RAM 中时，RAM 的地址 1 将包含 `HLT` 的二进制机器码。加载程序后，可以执行该程序。Baby
    从地址 1 开始执行（不是从地址 0，因为程序计数器在每次取指之前都会增加 1），所以 `HLT` 指令将会执行，导致 Baby 停止运行。
- en: '*Constants*'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*常量*'
- en: 'Lines with `NUM` aren’t true instructions but are used to place *data* at their
    address when the code is first loaded into RAM. For example, consider the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 `NUM` 的行并不是真正的指令，而是在代码首次加载到 RAM 中时，用来将 *数据* 放置到它们的地址上的。例如，考虑以下代码：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When this is loaded into RAM, the constants 10, 5, and 0 will be placed into
    addresses 2, 3, and 4, respectively, as well as the `HLT` instruction being placed
    into address 1.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个程序加载到 RAM 中时，常量 10、5 和 0 将分别被放置到地址 2、3 和 4，而 `HLT` 指令则被放置到地址 1。
- en: If you actually run the program it will begin at line 1, execute the `HLT` instruction,
    and immediately halt. The `HLT` instruction here is very important; the CPU tries
    to read and execute the instructions in order, starting from address 1, but the
    values that we’ve placed into addresses 2, 3, and 4 are intended to be used as
    data, not instructions. The `HLT` instruction stops the CPU from getting to address
    2 and beyond, preventing the data values from being treated as instructions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你实际运行这个程序，它将从第 1 行开始，执行 `HLT` 指令，并立即停止。这里的 `HLT` 指令非常重要；CPU 会按照顺序从地址 1 开始读取并执行指令，但我们放入地址
    2、3 和 4 的值本意是作为数据使用，而不是指令。`HLT` 指令阻止 CPU 访问地址 2 及之后的地址，从而防止数据值被当作指令执行。
- en: This method of writing the program and data together, and storing them in the
    same RAM together, is the defining characteristic of von Neumann architectures.
    When programming von Neumann machines, it’s very important that we only ever execute
    instruction lines, and that we don’t try to execute data lines. It’s a programming
    error—that is, a bug—to write code that ends up trying to execute data as if it
    were part of the program.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将程序和数据写在一起并存储在相同 RAM 中的方法，是冯·诺依曼架构的定义特征。在编程冯·诺依曼机器时，非常重要的一点是，我们只执行指令行，而不要尝试执行数据行。写出试图将数据当作程序的一部分执行的代码是一种编程错误，也就是
    bug。
- en: '**NOTE**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Execution of data can have unpredictable and dangerous behavior. That’s why
    it’s often used as a security attack technique: if you want to break into someone
    else’s program and have it execute your own code, you can sometimes do this by
    entering your code as data to that program, then somehow trick the program into
    executing it.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据的执行可能会导致不可预测和危险的行为。这就是为什么它常常作为一种安全攻击技术被使用：如果你想入侵他人的程序并执行你自己的代码，有时可以通过将代码作为数据输入到该程序中，然后以某种方式欺骗程序执行它。*'
- en: '*Load and Store*'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*加载与存储*'
- en: The constants in the above code never enter the CPU; rather, the whole code
    is loaded into the RAM locations given as the line numbers by some other mechanism
    before the CPU is even turned on. To make use of data from RAM in actual computations,
    we need to execute load and store instructions, which copy data from RAM into
    the CPU, and from the CPU to RAM.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的常量从未进入CPU；相反，整个代码在CPU启动之前通过其他机制被加载到给定的RAM位置中，位置是由行号指定的。为了在实际计算中使用RAM中的数据，我们需要执行加载和存储指令，它们将数据从RAM复制到CPU，再从CPU复制回RAM。
- en: 'For example, the following Baby program loads the (negation of the) number
    in address 20, then stores a copy of it into address 21:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下Baby程序将地址20中的（取反后的）数字加载到CPU，然后将其副本存储到地址21：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, the number –10 is initially placed at address 20, but it gets
    loaded into the CPU as +10, its inverse, due to the Baby’s automatic negation
    of loaded data. This number 10 is then stored to address 21, overwriting the 0
    initially placed there. Note that the executable program is stored in addresses
    01 through 03, and is terminated with `HLT`; higher addresses are used for data
    storage to avoid the risk of executing data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，数字–10最初被放置在地址20处，但由于Baby的自动数据取反，它被加载到CPU时变为+10，即其逆值。然后，这个数字10被存储到地址21，覆盖了最初存放在那里
    的0。请注意，可执行程序存储在地址01到03之间，并以`HLT`结束；更高的地址则用于数据存储，以避免执行数据的风险。
- en: '*Arithmetic*'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*算术*'
- en: 'The Baby has one arithmetic instruction: subtraction. It works like Pascal’s
    calculator: you first load one number into the CPU with a load instruction, then
    you give a `SUB` instruction that subtracts a second number from it. For example,
    the following program computes 10 – 3 = 7:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Baby只有一条算术指令：减法。它的工作原理类似于Pascal的计算器：首先使用加载指令将一个数字加载到CPU中，然后使用`SUB`指令将第二个数字从中减去。例如，以下程序计算10–3=7：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The integers –10 and 3 are placed in addresses 20 and 21 by lines 20 and 21
    when the whole program is first loaded into memory. Line 1 loads the (negated)
    integer from address 20 into the CPU. Line 2 subtracts the integer from address
    21 from it. Line 3 stores the result in address 22, overwriting the 0 initially
    placed there.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 整数–10和3在程序加载到内存时，分别由第20行和第21行放置到地址20和21中。第1行将（取反后的）整数从地址20加载到CPU。第2行从中减去地址21中的整数。第3行将结果存储到地址22，覆盖了最初存放在该位置的0。
- en: '*Jumps*'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*跳转*'
- en: 'The `JMP` instruction makes program execution jump to the line whose address
    is one plus the number stored at the address given in the instruction. This operation
    is called an *indirect jump*, as opposed to a *direct jump*, which would encode
    the target address itself as part of the instruction, instead of, as in this case,
    the *location* of the target address. For example, consider the following program:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`JMP`指令使得程序执行跳转到指令中给定地址的地址所存储的数字加一的那一行。这一操作称为*间接跳转*，与*直接跳转*相对，后者会将目标地址本身编码为指令的一部分，而不是像在本例中那样，编码目标地址的*位置*。例如，考虑以下程序：'
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the `JMP 23` instruction at line 05 will cause a jump to line 01, because
    the integer 0 is stored at address 23, and 1 is the number after 0\. This program
    loops and runs forever as a result of the `JMP` instruction.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第05行的`JMP 23`指令会导致跳转到第01行，因为整数0存储在地址23，而1是0之后的数字。由于`JMP`指令的存在，该程序会不断循环并永远运行下去。
- en: '*Branches*'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*分支*'
- en: 'Branching in the Baby is performed by the `SKN` instruction (skip next), which
    has no operand. `SKN` tests whether the current result is negative. If so, it
    skips the next instruction, moving to the one after it. `SKN` is usually paired
    with a jump (`JMP`) in the next instruction to create something similar to an
    if statement. If the result is negative, then `SKN` skips over the `JMP` instruction
    in the next line, and the program continues running from the line after it. If
    the result is positive, the jump is made and we continue running somewhere else
    in the program. For example, consider the following Baby program:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Baby中的分支由`SKN`指令（跳过下一个）执行，该指令没有操作数。`SKN`会检查当前结果是否为负数。如果是，它会跳过下一条指令，继续执行其后的指令。`SKN`通常与下一条指令中的跳转（`JMP`）配合使用，创建类似于if语句的功能。如果结果为负数，则`SKN`会跳过下一行的`JMP`指令，程序会从下一行继续执行。如果结果为正数，则会执行跳转，程序会继续在其他地方运行。例如，考虑以下Baby程序：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This program computes the absolute value of an integer input from address 20
    and stores the result in address 23\. That is, if the input is either –10 or 10,
    then the output will be 10; any negative sign is removed. Lines 03 and 04 are
    the `SKN-JMP` pair.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序计算来自地址20的整数输入的绝对值，并将结果存储在地址23中。也就是说，如果输入为-10或10，输出将是10；任何负号都会被去掉。第03行和第04行是`SKN-JMP`指令对。
- en: Assemblers
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 汇编器
- en: The programs we’ve been looking at for the Baby—and those seen previously for
    the Analytical Engine—are written using human-readable ASCII symbols spelling
    out mnemonics such as `LDN` for “load negated,” and decimal or hex numerals. Such
    notations are known as *assembly languages* or just *assembly*. CPUs don’t understand
    such symbols; they require binary encodings of them, the *machine code*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所看过的宝宝程序——以及之前看到的分析机程序——是使用人类可读的ASCII符号编写的，这些符号拼写出了像`LDN`（表示“加载取反”）这样的助记符，并使用十进制或十六进制数字。这些符号被称为*汇编语言*，或简称*汇编*。CPU并不理解这些符号；它们需要将这些符号转换为二进制编码，即*机器码*。
- en: For the Analytical Engine, machine code takes the form of punches on punch cards,
    and the human programmer needs to manually translate their human-readable mnemonics
    into these binary punches before running their program. Similarly, for von Neumann
    machines such as the Baby, programs need to be translated into binary machine
    code and then placed into RAM before the CPU can execute them. The original Baby
    programmers had to do this by hand, using a pencil to work out the machine code,
    then a system of electronic switches to copy the machine code into RAM before
    turning on the CPU.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于分析机，机器码的形式是打孔卡上的孔位，程序员需要手动将人类可读的助记符转换成这些二进制孔位，然后才能运行程序。类似地，对于冯·诺依曼架构的机器（如宝宝），程序需要先被转换成二进制机器码，然后加载到RAM中，CPU才能执行它们。最初的宝宝程序员必须手动完成这些操作，使用铅笔计算机器码，然后通过一套电子开关系统将机器码复制到RAM中，再启动CPU。
- en: If you’re programming a modern implementation of the Baby—or any other computer—in
    assembly today, you don’t need to do the translation manually; there are other
    programs, called *assemblers*, that automate the process, translating human-readable
    assembly programs into machine code for you. A file of 0s and 1s corresponding
    to machine code is called an *executable*, as it can be executed directly by the
    CPU once copied into RAM. Multiple assembly languages are possible for the same
    target machine. For example, they could use different mnemonics for the instructions
    (as we have in this book compared to other implementations of the Baby).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你今天正在为宝宝或任何其他计算机编写汇编程序，你不需要手动进行转换；还有其他程序，称为*汇编器*，能够自动化这个过程，将人类可读的汇编程序翻译成机器码给你。一个由0和1组成的文件，对应机器码，被称为*可执行文件*，因为它可以在复制到RAM后直接由CPU执行。对于同一目标机器，可以使用多种汇编语言。例如，它们可能使用不同的助记符来表示指令（就像本书中与其他宝宝实现相比所做的那样）。
- en: The Baby’s machine code uses one 32-bit word per instruction. The lowest 13
    bits are called the *operand* and encode the numerical value used by the instruction
    (or are ignored for instructions that don’t come with a number). The next 3 bits
    are known as the *opcode* and encode the type of instruction, obtained by direct
    translation of the assembler mnemonics, as in [Table 7-1](ch07.xhtml#ch07tab1).
    The remaining 16 bits are ignored.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 宝宝机的机器码每条指令使用一个32位的字。最低的13位被称为*操作数*，用于编码指令使用的数值（对于不带数值的指令，这部分会被忽略）。接下来的3位称为*操作码*，用于编码指令类型，直接通过汇编助记符的翻译得到，如[表7-1](ch07.xhtml#ch07tab1)所示。剩下的16位被忽略。
- en: '**Table 7-1:** The Manchester Baby Opcodes'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-1：** 曼彻斯特宝宝操作码'
- en: '| **Opcode** | **Mnemonic** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **操作码** | **助记符** |'
- en: '| --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | `JMP` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 0 | `JMP` |'
- en: '| 1 | `JRP` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `JRP` |'
- en: '| 2 | `LDN` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `LDN` |'
- en: '| 3 | `STO` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 3 | `STO` |'
- en: '| 4 | `SUB` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 4 | `SUB` |'
- en: '| 5 | `SUB` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 5 | `SUB` |'
- en: '| 6 | `SKN` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 6 | `SKN` |'
- en: '| 7 | `HLT` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 7 | `HLT` |'
- en: The following listing is an assembler for the Baby written in Python. If you
    know Python, you’ll see how a dictionary is used to translate the instructions
    to opcodes, and how conversions between decimal, hex, and binary are used on the
    operands.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个用Python编写的宝宝汇编器。如果你懂Python，你将看到如何使用字典将指令转换为操作码，以及如何对操作数进行十进制、十六进制和二进制之间的转换。
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is a Baby program for long division, written by Alan Turing during
    his work testing and documenting the Baby at Manchester:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是阿兰·图灵在曼彻斯特测试和记录宝宝时编写的长除法宝宝程序：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following shows the machine code for Turing’s program, as generated by
    the Python assembler:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是图灵程序的机器码，由 Python 汇编器生成：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this display of the binary machine code, the bit positions are printed with
    the zeroth bit on the left (contrary to modern convention), so the opcodes appear
    in the three bits just to the left of the middle of each word, with the operands
    to their left. This was the format used by the historical Baby, so our machine
    code could be entered using this convention.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个二进制机器码的显示中，位的位置是按从左到右的顺序打印的第零位（与现代惯例相反），所以操作码出现在每个字的中间偏左的三个位中，操作数在它们的左侧。这是历史上
    Baby 使用的格式，因此我们可以使用这种约定输入机器码。
- en: The test program and the machine code each have 32 lines so that they exactly
    and unambiguously fill the Baby’s 32 addresses of memory. The programmer needs
    to put something in all 32 addresses so those that aren’t in use are explicitly
    filled with zeros. Note that the line numbers aren’t encoded in the machine code;
    rather, they specify which address the machine code will be placed at. Also note
    that the data lines are translated as single 32-bit numbers, as `NUM` isn’t an
    instruction but rather just a comment to tell the assembler that the line contains
    raw data. The Baby uses two’s complement, so hex values such as `ffff0000` represent
    negative integers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 测试程序和机器码各有 32 行，这样它们恰好并且明确地填充了 Baby 的 32 个内存地址。程序员需要将某些内容放入所有 32 个地址，因此未使用的地址需要显式填充为零。请注意，行号并未编码在机器码中；而是指定机器码将放置在哪个地址。另外，请注意，数据行被转换为单个
    32 位数字，因为 `NUM` 不是指令，而只是一个注释，告诉汇编器该行包含原始数据。Baby 使用补码表示，因此像 `ffff0000` 这样的十六进制值表示负整数。
- en: '**NOTE**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Until the mid-1990s, many large applications and games were written by human
    programmers in assembly language, including* Street Fighter II *and the RISC OS
    operating system. Most modern programming isn’t done in assembly language, but
    rather in a higher-level language such as C, C++, or Python. Programs written
    in these languages are first converted to assembly code by a compiler, before
    being assembled by an assembler.*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*直到 1990 年代中期，许多大型应用程序和游戏是由人工程序员使用汇编语言编写的，包括* 街头霸王 II *和 RISC OS 操作系统。大多数现代编程不再使用汇编语言，而是使用像
    C、C++ 或 Python 这样的高级语言编写。用这些语言编写的程序首先通过编译器转换为汇编代码，然后由汇编器汇编。*'
- en: The Baby’s Internal Structures
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Baby 的内部结构
- en: 'Now we’ll turn to the Baby’s internal structures. As we did for the Analytical
    Engine, we’ll first introduce the subcomponents within the digital CPU, and then
    consider the dynamics of how they behave and interact to execute programs. The
    main digital CPU substructures are exactly the same as for the Analytical Engine:
    registers, an arithmetic logic unit (ALU), and a control unit (CU). They have
    the same functions as in the Analytical Engine but are built from the digital
    logic simple machines we studied in the previous chapter, rather than from Babbage’s
    mechanical simple machines.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将讨论 Baby 的内部结构。与分析引擎一样，我们首先介绍数字 CPU 中的子组件，然后考虑它们如何相互作用以执行程序。主要的数字 CPU 子结构与分析引擎完全相同：寄存器、算术逻辑单元（ALU）和控制单元（CU）。它们在功能上与分析引擎中的相同，但它们是由我们在上一章学习的数字逻辑简单机器构建的，而不是由巴贝奇的机械简单机器构建的。
- en: We won’t follow the exact implementation of the original Manchester Baby here;
    rather, I’ll show general digital logic implementations that *could* be used to
    implement the Baby’s programmer interface in a more modern style. These implementations
    are built from simple machines of digital logic, which in turn are built from
    logic gates that could be implemented equally well using modern transistors or
    the Baby’s original vacuum tubes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会完全按照原始曼彻斯特 Baby 的实现方式进行，而是展示可以用于更现代风格实现 Baby 程序员接口的通用数字逻辑实现。这些实现由数字逻辑的简单机器构建，而这些简单机器又是由逻辑门构建的，后者可以使用现代晶体管或
    Baby 原始的真空管同样很好地实现。
- en: '*Registers*'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*寄存器*'
- en: Registers are fast word-length memory, usually made today as arrays of D-type
    flip-flops, which live inside the CPU and are readable and writable by the CU
    and ALU. Most CPUs include several types of register used for different purposes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器是快速的字长内存，通常今天由 D 型触发器阵列组成，位于 CPU 内部，控制单元（CU）和算术逻辑单元（ALU）可以读取和写入它们。大多数 CPU
    包含几种不同类型的寄存器，用于不同的目的。
- en: The sizes of the registers in a CPU are usually taken to define the CPU’s word
    length; for example, an 8-bit machine uses 8-bit words that are stored in 8-bit
    registers, and a 32-bit machine uses 32-bit words that are stored in 32-bit registers.
    The Baby is a 32-bit machine in this sense. The words use the data representations
    seen in [Chapter 2](ch02.xhtml), which require an array of bits to store numbers,
    text, and other data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 中寄存器的大小通常用来定义 CPU 的字长；例如，8 位机器使用 8 位字，它们存储在 8 位寄存器中，而 32 位机器使用 32 位字，它们存储在
    32 位寄存器中。从这个角度看，Baby 是一台 32 位机器。字使用在 [第 2 章](ch02.xhtml) 中看到的数据表示方法，需要一个比特数组来存储数字、文本和其他数据。
- en: Like the individual flip-flops that compose them, registers must be timed to
    enable correct synchronization of reads and writes. An update signal can be sent
    to the clock inputs of all the flip-flops making up the register. Usually writes
    to the register are performed on the rising edge of this signal. Each register
    also continually outputs its latest stored value for reading as a set of parallel
    wires, regardless of the updates. The register structure is shown in [Figure 7-1](ch07.xhtml#ch07fig1).
    The write is triggered when you press the button.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 就像组成寄存器的各个触发器一样，寄存器必须同步时序，以确保读写的正确同步。一个更新信号可以发送到构成寄存器的所有触发器的时钟输入。通常对寄存器的写入是在该信号的上升沿进行的。每个寄存器还会持续输出其最新存储的值，供读取，作为一组并行电线，无论是否有更新。寄存器结构如
    [图 7-1](ch07.xhtml#ch07fig1) 所示。写入操作是在按下按钮时触发的。
- en: '![Image](../images/f0164-01.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0164-01.jpg)'
- en: '*Figure 7-1: A 3-bit register made from flip-flops*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：由触发器组成的 3 位寄存器*'
- en: Registers can also be notated using a single symbol suggesting a pile of flip-flops,
    as in [Figure 7-2](ch07.xhtml#ch07fig2).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器也可以使用单个符号表示，暗示由触发器堆叠而成，如 [图 7-2](ch07.xhtml#ch07fig2) 所示。
- en: '![Image](../images/f0165-01.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0165-01.jpg)'
- en: '*Figure 7-2: A 4-bit register as a single symbol, connected to input switches,
    write update button, and output LEDs*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：作为单个符号的 4 位寄存器，连接到输入开关、写入更新按钮和输出 LED*'
- en: Here, the D input and Q output are each groups of wires, shown as thick lines,
    then split into single wires.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，D 输入和 Q 输出是各自的一组电线，显示为粗线条，然后分成单根电线。
- en: '**User Registers**'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**用户寄存器**'
- en: '*User registers* are usually the only registers that are visible to the assembly
    language programmer, who can give instructions to act on their contents.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*用户寄存器* 通常是汇编语言程序员可以看到的唯一寄存器，他们可以向其内容发出指令。'
- en: 'An *accumulator* is a user register that functions both as an input and to
    store the results of calculations in the same place. As we’ve seen, Pascal’s calculator
    is one big accumulator because it stores both one of the inputs to an addition
    and also its result, destroying the original representation of the input in the
    process. Your desktop calculator is also an accumulator: it only ever stores one
    number, the current result seen on the screen, which you can add to or multiply
    by, and which is updated to store the result. For example, if you enter 2, this
    is stored in the accumulator. If you then enter +3 the accumulator stores and
    shows the result 5\. The original value 2 and the operation +3 are lost, and only
    the accumulated result is available.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*累加器* 是一个既作为输入又用于存储计算结果的用户寄存器。如我们所见，Pascal 的计算器就是一个大型累加器，因为它既存储加法的输入之一，也存储其结果，在此过程中销毁输入的原始表示。你的桌面计算器也是一个累加器：它只存储一个数字，即当前显示在屏幕上的结果，你可以将其加上或乘以，并更新存储结果。例如，如果你输入
    2，它会被存储在累加器中。如果你再输入 +3，累加器会存储并显示结果 5。原始值 2 和操作 +3 会丢失，只有累加的结果可用。'
- en: '*Accumulator architectures* are those that have only a single user register
    that acts as an accumulator. The Baby uses this simple style of architecture.
    This forces all computation to be done in the accumulator style because there
    are no other registers in which to keep inputs separate from outputs. By contrast,
    more complex CPUs may have other user registers, in addition to or instead of
    an accumulator.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*累加器架构* 是指只有一个用户寄存器作为累加器的架构。Baby 就使用这种简单的架构风格。这迫使所有计算都必须在累加器样式中进行，因为没有其他寄存器来将输入与输出分开。相反，更复杂的
    CPU 可能除了累加器外，还会有其他用户寄存器。'
- en: '**Internal Registers**'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**内部寄存器**'
- en: In addition to the user registers, most CPUs require further registers for their
    own internal operations. These *internal registers* may be invisible to the user,
    so you can’t write assembly programs that access or modify them. Rather, they’re
    used to make the CPU itself work, and to enable it to read and execute user programs.
    Let’s look at the two most important internal registers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '除了用户寄存器外，大多数 CPU 还需要一些额外的寄存器来执行内部操作。这些 *内部寄存器* 可能对用户不可见，因此你无法编写访问或修改它们的汇编程序。相反，它们用于使
    CPU 本身工作，并使其能够读取和执行用户程序。让我们来看一下两个最重要的内部寄存器。  '
- en: A CPU needs to keep track of where it currently is in the execution of its program.
    In the Analytical Engine, the current line of the program was stored using the
    mechanical state of the program card reader. Like typewriter paper, the program
    was mechanically fast-forwarded and rewound so that the current line was positioned
    on the reader. In an electronic CPU, there is no mechanically moving state, so
    we must instead keep track of where we are in the program by storing the current
    line number in a register, called the *program counter* (*PC* in the listings
    in this chapter). As we’ve seen, von Neumann architectures—such as the Baby and
    most modern computers—store the program in main memory, along with other data,
    so these “line numbers” are actually memory addresses that store the instructions
    of the program.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 'CPU 需要跟踪它当前在程序执行中的位置。在分析引擎中，程序的当前行通过机械的程序卡片读取器状态来存储。就像打字机纸一样，程序通过机械方式快进和倒带，以便将当前行定位到读取器上。在电子
    CPU 中，没有机械移动的状态，因此我们必须通过将当前行号存储在一个寄存器中来跟踪程序的位置，这个寄存器被称为 *程序计数器*（在本章的列表中为 *PC*）。正如我们所见，冯·诺依曼架构——例如
    Baby 计算机和大多数现代计算机——将程序存储在主存储器中，连同其他数据一起存储，因此这些“行号”实际上是存储程序指令的内存地址。  '
- en: The *instruction register (IR)* stores a copy of the current instruction, copied
    in from its address (as kept in the program counter) in memory.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*指令寄存器（IR）* 存储当前指令的副本，该副本是从其地址（如程序计数器中保存的地址）在内存中复制过来的。  '
- en: '*Arithmetic Logic Unit*'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*算术逻辑单元*  '
- en: Just like the Analytical Engine’s ALU, a digital logic–based ALU consists of
    a collection of simple machines, each performing one kind of arithmetic operation.
    Due to a quirk in its hardware, the original Baby had only a subtractor, but here
    we’ll build a more general and powerful ALU that also includes addition, multiplication,
    and division. [Figure 7-3](ch07.xhtml#ch07fig3) shows a 32-bit ALU with these
    operations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '就像分析引擎的 ALU 一样，基于数字逻辑的 ALU 由一组简单的机器组成，每个机器执行一种算术操作。由于硬件上的一个特殊情况，原始的 Baby 计算机只有一个减法器，但在这里我们将构建一个更通用且强大的
    ALU，其中还包括加法、乘法和除法。 [图 7-3](ch07.xhtml#ch07fig3) 展示了一个具有这些操作的 32 位 ALU。  '
- en: '![Image](../images/f0166-01.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0166-01.jpg)  '
- en: '*Figure 7-3: A 32-bit, four-operation ALU*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：一个 32 位的四操作 ALU*  '
- en: Here there are two data inputs, *a* and *b*, each containing a 32-bit, two’s
    complement integer. They’re both sent to all four simple arithmetic machines,
    a subtractor, adder, multiplier, and divider, each of which calculates an output.
    Just one of these outputs is then selected and passed to the ALU’s output, *r*.
    To choose which arithmetic operation you want to do, place its 2-bit code on the
    *c* input. The decoder then activates one of the four 32-bit multiplexers, enabling
    the desired operation’s output to be passed to and through the 32-bit OR gate
    array. A copy of the final output from the OR gate array is passed into a *comparator*,
    which tests if the number is zero and outputs a single status flag with this Boolean.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个数据输入，*a* 和 *b*，每个输入都包含一个 32 位的二进制补码整数。它们都被发送到四个简单的算术机器——减法器、加法器、乘法器和除法器，每个机器都计算一个输出。然后只选择其中一个输出并将其传递到
    ALU 的输出 *r*。要选择你想要执行的算术操作，将其 2 位代码放置在 *c* 输入上。解码器随后激活四个 32 位多路复用器中的一个，使得所需操作的输出可以传递到
    32 位的 OR 门阵列中。最终输出从 OR 门阵列传递到 *比较器*，后者测试该数字是否为零，并输出一个带有该布尔值的单一状态标志。
- en: The comparator can be implemented simply by NOR gating together all of the bits
    in the number. More advanced ALUs often test for other interesting properties
    of the result, such as being positive or negative, having created an overflow
    (which can be seen on the carry out lines of the simple machines), or division
    by zero; they then output a set of flags rather than just this zero test.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '比较器可以通过将数字中的所有位使用 NOR 门连接在一起来简单地实现。更先进的 ALU 通常会测试结果的其他有趣属性，比如是否为正数或负数，是否发生了溢出（可以在简单机器的进位线中看到），或者是否发生了除零错误；然后它们会输出一组标志，而不仅仅是零测试。  '
- en: Note that we could build this ALU with less silicon by using a single multiplexer
    with 2-bit input to select directly between the four arithmetic machines. Duplication
    of digital logic could be reduced by sharing structures between operations—for
    example, using two’s complement enables adders to be reused as subtractors. You
    might also be concerned about the waste of energy from running all of the arithmetic
    options on each set of inputs but throwing all but one result away. You could
    find ways to redesign the network to reduce this energy usage. However, I’ve chosen
    the present structure for educational reasons, as it will help you to more easily
    understand CUs in the next section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以通过使用一个具有2比特输入的单一多路复用器直接在四个算术机器之间进行选择，从而减少硅的使用。通过在操作之间共享结构，可以减少数字逻辑的重复——例如，使用二补码使得加法器可以作为减法器重复使用。你可能还会担心在每组输入上运行所有算术选项并丢弃所有结果，除了一个结果之外，造成的能量浪费。你可以通过重新设计网络来减少这种能量消耗。然而，我选择了当前的结构是出于教育目的，因为它将帮助你在下一节中更容易理解控制单元。
- en: '*Control Unit*'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*控制单元*'
- en: Digital logic CUs implement the same concept as Babbage’s timing barrel, acting
    like a musical conductor to trigger all of the other CPU components at the right
    times. There are many ways to do this, so CUs vary far more than registers and
    ALUs. They’re usually considered to be the hardest and most central part of CPU
    design. We’ll choose a particular style here for ease of understanding rather
    than for computational or energy efficiency.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 数字逻辑控制单元（CU）实现了与巴贝奇计时桶相同的概念，像指挥家一样在正确的时间触发所有其他CPU组件。实现这一功能的方法有很多种，因此控制单元的设计比寄存器和ALU更加多样化。它们通常被认为是CPU设计中最难且最核心的部分。为了易于理解，我们在这里选择一种特定风格，而非为了计算或能效。
- en: 'This style is based on two structures: first, a counter that, like Babbage’s
    barrel, rotates regularly, and whose value is used to time the required events;
    second, a switching mechanism that determines the type of event to be triggered
    and makes temporary connections between components—such as registers, the ALU,
    and RAM—in response. In Babbage’s machine, these connections were made and broken
    using mechanical levers. For our digital logic version, we’ll use multiplexers,
    as we did in the ALU. These multiplexers have two data inputs, each of word length—32
    bits for the Baby. One is hardwired to zeros and the other is from the temporary
    input source. They have a single-bit switch that switches between relaying the
    temporary input onto the output and sending all zeros to the output. [Figure 7-4](ch07.xhtml#ch07fig4)
    shows how this works.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风格基于两个结构：首先是一个计数器，像巴贝奇的计数桶一样定期旋转，其值用于定时所需的事件；其次是一个开关机制，用于确定触发事件的类型，并根据需要在组件之间建立临时连接——例如寄存器、算术逻辑单元（ALU）和随机存取存储器（RAM）。在巴贝奇的机器中，这些连接是通过机械杠杆来实现的。对于我们的数字逻辑版本，我们将使用多路复用器，就像在ALU中那样。这些多路复用器有两个数据输入，每个输入的字长为32位（对于Baby计算机而言）。其中一个接地为零，另一个来自临时输入源。它们有一个单比特开关，用于在将临时输入传送到输出和将全零传送到输出之间进行切换。[图7-4](ch07.xhtml#ch07fig4)展示了这一工作原理。
- en: '![Image](../images/f0168-01.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0168-01.jpg)'
- en: '*Figure 7-4: A multiplexer used to enable or disable a connection of 32 wires*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：用于启用或禁用32根电缆连接的多路复用器*'
- en: As in the ALU, where multiple sources can potentially connect to a destination,
    they each get their own multiplexer. Then an OR array combines the multiplexer
    outputs, allowing the non-zero output to pass through.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在ALU中，多个源可能连接到同一个目标，它们每个都会有自己的多路复用器。然后，使用一个或门（OR）阵列将这些多路复用器的输出组合起来，允许非零输出通过。
- en: We’ll create a sequence of temporary connections between components. Some of
    these connections can be triggered simply by the time shown on the counter. This
    can be done with a decoder, taking the time as input and activating a particular
    trigger wire as output. Other connections need to be triggered by a combination
    of a time and some other value, such as the identity of the current instruction.
    These can be done by AND gating the appropriate trigger wire to signals representing
    the other required conditions. [Figure 7-5](ch07.xhtml#ch07fig5) shows an example
    of this structure.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个组件之间的临时连接序列。其中一些连接仅通过计数器上显示的时间来触发。这可以通过解码器来实现，解码器将时间作为输入，并激活一个特定的触发线作为输出。其他连接需要通过时间与其他值的组合来触发，例如当前指令的标识。这些可以通过将适当的触发线与代表其他所需条件的信号进行与门（AND）连接来实现。[图7-5](ch07.xhtml#ch07fig5)展示了这种结构的一个示例。
- en: '![Image](../images/f0168-02.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0168-02.jpg)'
- en: '*Figure 7-5: A minimal CU based on a 3-bit counter, a decoder, and multiplexer
    switches*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：基于3位计数器、解码器和多路复用器开关的最简CU*'
- en: The 3-bit counter and decoder on the left form the sequencer. Using 3 bits gives
    us 2³ = 8 times, from 0 to 7, looping back to 0 after each 7\. The figure shows
    triggers only at ticks 0, 1, and 7\. The triggers at ticks 0 and 1 (the upper
    two outputs from the decoder) depend only on the time and make connections between
    32-bit wire groups. At tick 7, there are two possible triggers, which depend on
    conditions cond1 and cond2 being met, respectively, represented by the two switches
    near the bottom-left of the figure. Note that either, neither, or both of these
    conditions (and thus triggers) could be active at this time. The OR symbol here
    represents an array of 32 OR gates. It allows two different inputs to be connected
    to the same shared output (SO) on different triggers. (Triggers from times 2 through
    6 inclusive are omitted in this figure, but you can imagine those wires from the
    decoder connecting to similar triggers.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的3位计数器和解码器构成了序列发生器。使用3位可以给我们2³ = 8个时间段，从0到7，每个7后循环回0。图中只显示了在0、1和7时刻的触发信号。在时刻0和1的触发信号（来自解码器的上两个输出）仅依赖于时间，并在32位电缆组之间建立连接。在时刻7，有两个可能的触发信号，分别依赖于条件cond1和cond2是否满足，这些条件由图左下角的两个开关表示。请注意，这些条件（因此触发信号）可能处于激活、未激活或同时激活的状态。这里的OR符号代表32个OR门的阵列。它允许将两个不同的输入连接到不同触发信号上的同一共享输出（SO）。(图中省略了时刻2到6的触发信号，但你可以想象从解码器出来的电缆连接到类似的触发信号。)
- en: Let’s introduce a little extra notation at this point to help make our diagrams
    more readable. [Figure 7-6](ch07.xhtml#ch07fig6) shows exactly the same minimal
    CU, but introduces *tunnels*, which are named points (t0 to t7 and c0 to c1) taking
    the place of wires. All tunnels having the same name are assumed to be connected
    to one another. For example, the t0 tunnel coming out of the decoder connects
    to the t0 tunnel going into the multiplexer near the top right of the figure.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在此引入一些额外的符号，以帮助使我们的图示更易读。[图7-6](ch07.xhtml#ch07fig6)显示了完全相同的最简CU，但引入了*隧道*，这些隧道是命名的点（t0到t7和c0到c1），取代了电缆。所有具有相同名称的隧道被假定是相互连接的。例如，从解码器出来的t0隧道连接到图中右上角靠近多路复用器的t0隧道。
- en: '![Image](../images/f0169-01.jpg)![Image](../images/f0169-02.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0169-01.jpg)![Image](../images/f0169-02.jpg)'
- en: '*Figure 7-6: The same minimal CU as in [Figure 7-5](ch07.xhtml#ch07fig5), redrawn
    using tunnel notation*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：与[图7-5](ch07.xhtml#ch07fig5)相同的最简CU，使用隧道符号重新绘制*'
- en: This tunnel notation avoids the need to draw the rat’s nest of wires formed
    as the CU sends its triggers all over the rest of the CPU. We’ve also encapsulated
    the 3-bit counter into a single block, CTR3, as provided off-the-shelf by LogiSim.
    (This block has some additional inputs and features that we don’t use here.)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种隧道符号避免了绘制复杂的电缆图，避免了CU在整个CPU中发送触发信号所形成的“鼠巢”电线。我们还将3位计数器封装成了一个单独的模块CTR3，这是LogiSim现成提供的。（这个模块有一些额外的输入和功能，在这里我们没有使用。）
- en: Putting It All Together
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将所有内容结合起来
- en: Now that we’ve seen each of the basic ingredients of a Baby implementation,
    let’s put them all together—along with suitably timed CU dynamics—to build a complete,
    functioning Baby. We’ll do this by considering the three main stages of operation—fetch,
    decode, and execution—in turn, just as we did when we discussed the Analytical
    Engine in [Chapter 3](ch03.xhtml).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了Baby实现的每个基本组成部分，让我们将它们全部结合起来——并适当安排CU的动态——来构建一个完整的、功能齐全的Baby。我们将依次考虑操作的三个主要阶段——取指、解码和执行，就像我们在[第3章](ch03.xhtml)讨论分析引擎时所做的那样。
- en: '*Fetch*'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*取指*'
- en: The aim of the fetch stage is to bring a copy of the next instruction from RAM
    into the IR in the CPU. Fetching assumes that the address of the next instruction
    is already in the program counter. When the CPU is first turned on, the program
    counter—like all registers—is initialized to 0, but is immediately incremented
    to 1, so the first instruction must be stored at address 1 and will be fetched.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 取指阶段的目的是将下一条指令的副本从RAM带入CPU的IR。取指假设下一条指令的地址已经在程序计数器中。当CPU首次开启时，程序计数器——像所有寄存器一样——初始化为0，但立即递增到1，因此第一条指令必须存储在地址1，并会被取出。
- en: To perform a fetch, the program counter is temporarily connected to the address
    lines of RAM, on tick 1\. The data out lines of RAM can be permanently connected
    to the IR data in, but the IR takes only a copy of the word from these lines when
    write-enabled and clocked at tick 2\. The network in [Figure 7-7](ch07.xhtml#ch07fig7)
    is set to perform fetch for the Baby’s 32×32 RAM (32 = 2⁵ addresses, each containing
    one 32-bit word) by making these connections on ticks 1 and 2 of its eight-count
    control cycle, and breaking them on the other steps. In our Baby, the program
    counter is a 5-bit register and the IR is a 32-bit register.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行取指操作，程序计数器在第1个时钟周期暂时连接到RAM的地址线。RAM的数据输出线可以永久连接到IR的数据输入，但只有在写使能且在第2个时钟周期时，IR才会从这些线复制字数据。[图7-7](ch07.xhtml#ch07fig7)中的网络设置为执行Baby的32×32
    RAM的取指操作（32 = 2⁵个地址，每个地址包含一个32位字），通过在其八个计数周期的第1和第2个时钟周期建立这些连接，并在其他步骤中断开连接。在我们的Baby中，程序计数器是一个5位寄存器，IR是一个32位寄存器。
- en: '![Image](../images/f0170-01.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0170-01.jpg)'
- en: '*Figure 7-7: A fetch, triggered on ticks 1 and 2*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：取指操作，在第1和第2个时钟周期触发*'
- en: 'We can write the fetch sequence as:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将取指序列写成：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This style of notation is a form of *register transfer language (RTL)*. The
    symbols before the colon on each line are the triggers, which in this case are
    ticks 1 and 2\. The arrows denote that a temporary connection from a source to
    a destination is made only when the trigger is active. The arrows thus correspond
    to the multiplexers used in our implementation style, with the triggers corresponding
    to the switching inputs of these multiplexers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种符号风格是一种*寄存器传输语言（RTL）*。每行冒号前的符号是触发器，在本例中是第1和第2个时钟周期。箭头表示当触发器处于活动状态时，从源到目的地的临时连接被建立。因此，箭头对应于我们实现风格中使用的多路复用器，而触发器对应于这些多路复用器的切换输入。
- en: '**NOTE**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*RTL is not assembly language or machine code. It’s a lower-level description
    of how the CPU works, whose function is ultimately to execute the machine code
    program written by the user and stored in RAM.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*RTL不是汇编语言或机器码。它是CPU工作方式的低级描述，其功能最终是执行由用户编写并存储在RAM中的机器码程序。*'
- en: '*Decode*'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解码*'
- en: We now have a copy of the next instruction sitting in the IR. It consists of
    a word of machine code, with some bits specifying the opcode and the other bits
    possibly containing zero, one, or more operands. In the Baby, bits 13 to 15 are
    the opcode, bits 0 to 12 are a single operand for some instructions, and the remaining
    16 bits aren’t used. This encoding now needs to be decoded. We need to split up
    the opcode and operand, then convert the opcode into an activation signal. [Figure
    7-8](ch07.xhtml#ch07fig8) shows our implementation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了下一条指令的副本，它存储在IR中。它由一组机器码组成，其中一些位指定了操作码，其他位可能包含一个、零个或多个操作数。在Baby中，第13至15位是操作码，第0至12位是某些指令的单一操作数，剩下的16位未被使用。现在需要对这种编码进行解码。我们需要将操作码和操作数分开，然后将操作码转换为激活信号。[图7-8](ch07.xhtml#ch07fig8)展示了我们的实现。
- en: '![Image](../images/f0171-01.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0171-01.jpg)'
- en: '*Figure 7-8: Decoding, triggered at tick 2*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-8：解码操作，在第2个时钟周期触发*'
- en: The IR output is first split into three sets of wires, for the first 13, next
    3, and remaining 16 bits. The middle 3 bits, containing the opcode, are connected
    to a 3-bit decoder. The decoder activates one of its 2³ = 8 output lines, which
    is connected to a tunnel and will be used as a condition to trigger multiplexers
    in other steps. These tunnels are named as their corresponding assembly mnemonics.
    The 13 operand bits of the IR are further split into the 5 lower-order bits, which
    are used for address selection and will have wires connected to them later, and
    the 8 higher-order bits, which have nothing to address and are ignored.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: IR输出首先被分为三组线，分别对应前13位、接下来的3位和剩余的16位。中间的3位包含操作码，它们连接到一个3位解码器。解码器激活其2³ = 8个输出线之一，这些输出线连接到一个隧道，并将作为触发其他步骤中的多路复用器的条件。这些隧道被命名为它们对应的汇编语言助记符。IR的13个操作数字段进一步分为5个低位，用于地址选择，并将在稍后连接相应的线路，以及8个高位，这些高位没有地址用途，因此会被忽略。
- en: There’s no sequential logic used here, so decoding happens roughly instantaneously
    once the IR content is updated on tick 2.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有使用顺序逻辑，因此一旦IR内容在第2个时钟周期更新，解码过程几乎是瞬间完成的。
- en: '*Execute*'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*执行*'
- en: 'Unlike fetching and decoding, what happens during the execute stage depends
    on the instruction that has been fetched and decoded. Different instructions specify
    the activation of different structures that do different things: load, store,
    arithmetic, and program flow control. We’ll look at how to execute each of these
    possible actions in turn.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与获取和解码不同，执行阶段发生的事情取决于已获取和解码的指令。不同的指令指定不同结构的激活，这些结构执行不同的操作：加载、存储、算术操作和程序流程控制。我们将依次查看如何执行这些可能的操作。
- en: '**Load**'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**加载**'
- en: 'To execute a load, we temporarily connect the operand to the RAM’s address
    input at tick 3, and then temporarily connect the RAM’s data output to the accumulator
    (Acc) at tick 4\. These tick numbers are chosen to take place after the previous
    fetch and decode. We can write this in RTL style as:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行加载操作，我们在第 3 时钟周期临时将操作数连接到 RAM 的地址输入，然后在第 4 时钟周期将 RAM 的数据输出临时连接到累加器（Acc）。这些时钟周期被选择在前一个获取和解码操作之后。我们可以将其写成
    RTL 风格如下：
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the triggers before the colon now include both a tick and the `LDN`
    condition. The square brackets in `IR[operand]` indicate that only the operand
    bits of IR are to be used, rather than the entire register content.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，冒号前的触发条件现在包括时钟周期和 `LDN` 条件。在 `IR[operand]` 中的方括号表示只使用 IR 的操作数字段，而不是整个寄存器内容。
- en: '[Figure 7-9](ch07.xhtml#ch07fig9) shows the digital logic for our Baby implementation’s
    load. (As the Baby’s load operation also negates the loaded values, we pass the
    RAM data out through a negator on its way to the accumulator. This would not usually
    be done on a modern machine.)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-9](ch07.xhtml#ch07fig9) 显示了我们 Baby 实现的加载数字逻辑。（由于 Baby 的加载操作还会对加载的值进行取反，因此我们将
    RAM 数据通过一个取反器传送到累加器。这在现代计算机中通常不会这样做。）'
- en: In an accumulator architecture such as the Baby, the load always places the
    data from RAM into the accumulator register. In more complex architectures with
    more user registers, an additional operand is needed to specify the target, and
    more digital logic is needed to connect the right register to the data line.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 Baby 这样的累加器架构中，加载操作总是将数据从 RAM 放入累加器寄存器。在具有更多用户寄存器的更复杂架构中，需要一个额外的操作数来指定目标寄存器，并且需要更多的数字逻辑来将正确的寄存器连接到数据线。
- en: '**Store**'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**存储**'
- en: Storing a value from the CPU into memory is similar but opposite to loading.
    In the Baby, the value to be stored is always taken from the accumulator.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将值从 CPU 存储到内存的过程与加载相似，但相反。在 Baby 中，要存储的值始终来自累加器。
- en: 'At tick 3, we temporarily connect the STO instruction’s operand (the address
    to store at) to the RAM’s address lines. The accumulator output can be permanently
    connected to the RAM data input, but only write-enabled at tick 3\. The RTL for
    this is:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 个时钟周期，我们临时将 STO 指令的操作数（存储地址）连接到 RAM 的地址线。累加器的输出可以永久连接到 RAM 数据输入，但仅在第 3
    个时钟周期时启用写入。该 RTL 为：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Figure 7-10](ch07.xhtml#ch07fig10) shows the digital logic implementing this
    for our Baby.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-10](ch07.xhtml#ch07fig10) 显示了实现这一操作的 Baby 数字逻辑。'
- en: '![Image](../images/f0173-01.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0173-01.jpg)'
- en: '*Figure 7-9: Executing a load, triggered at ticks 3 and 4*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-9：执行加载操作，在第 3 和第 4 时钟周期触发*'
- en: '![Image](../images/f0173-02.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0173-02.jpg)'
- en: '*Figure 7-10: Executing a store, triggered at tick 3*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-10：执行存储操作，在第 3 时钟周期触发*'
- en: In architectures with more user registers, another operand can be used to specify
    which register’s contents are to be stored, and more switching logic is then needed
    to connect the right register to the data line.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有更多用户寄存器的架构中，可以使用另一个操作数来指定要存储的寄存器内容，然后需要更多的切换逻辑来将正确的寄存器连接到数据线。
- en: '**Arithmetic**'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**算术**'
- en: To execute an ALU operation, the CU makes temporary connections to the ALU’s
    inputs from CPU registers, and creates and sends an ALU command to the ALU’s command
    inputs. The ALU output is then temporarily connected to a destination register.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行 ALU 操作，CU 会临时连接 CPU 寄存器到 ALU 的输入，并创建并发送 ALU 命令到 ALU 的命令输入。ALU 的输出会临时连接到目标寄存器。
- en: The Baby’s ALU is especially simple, as it contains only a subtractor. The `SUB`
    instruction triggers a read from RAM, similar to a load instruction, but the RAM
    data is sent to the subtractor rather than to the accumulator. The subtractor
    takes its other input from the accumulator and writes its output back to the accumulator.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Baby 的算术逻辑单元（ALU）特别简单，因为它只包含一个减法器。`SUB` 指令触发从 RAM 读取数据，类似于加载指令，但 RAM 数据被发送到减法器，而不是累加器。减法器将其另一个输入来自累加器，并将输出写回累加器。
- en: '[Figure 7-11](ch07.xhtml#ch07fig11) shows our Baby ALU implementation. The
    RAM read is triggered on tick 3, and the accumulator update on tick 4\. The subtractor
    is on the far left of the figure.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-11](ch07.xhtml#ch07fig11)展示了我们的Baby ALU实现。RAM读取在第3个时钟周期触发，累加器更新在第4个时钟周期触发。减法器位于图的最左侧。'
- en: '![Image](../images/f0174-01.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0174-01.jpg)'
- en: '*Figure 7-11: Executing an ALU operation, triggered at ticks 3 and 4*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-11：执行ALU操作，在第3和第4时钟周期触发*'
- en: 'This can also be described in RTL as:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以用RTL描述为：
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: More complex architectures having more arithmetic operations than just subtraction
    would package them up into a single ALU structure, with select lines to specify
    which to activate, as you saw in [Figure 7-3](ch07.xhtml#ch07fig3). The decoder
    would then need to recognize multiple different arithmetic opcodes, and route
    each one through some logic to activate the corresponding selection.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的架构，拥有比减法更多的算术操作，会将它们打包成一个单一的ALU结构，通过选择线来指定激活哪个操作，就像在[图 7-3](ch07.xhtml#ch07fig3)中看到的那样。解码器随后需要识别多个不同的算术操作码，并通过某些逻辑将每个操作路由到对应的选择逻辑。
- en: '**Flow Control**'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**流程控制**'
- en: At the start of each instruction, the Baby moves to the next address (line)
    of the program. This can be done by incrementing (adding 1 to) the program counter
    at tick 0.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在每条指令开始时，Baby会移动到程序的下一个地址（行）。这可以通过在第0个时钟周期将程序计数器加1来实现。
- en: If the current instruction is a flow control instruction—that is, a jump or
    branch—then its execution step also needs to update the program counter to get
    it ready for the next instruction.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前指令是流程控制指令——即跳转或分支——则其执行步骤也需要更新程序计数器，以便为下一条指令做好准备。
- en: Modern (direct) jump instructions contain the line number to jump to in their
    operand, so they can be implemented by copying the operand directly into the program
    counter. As we’ve seen, however, the Baby uses an indirect jump instruction, `JMP`,
    in which the operand contains the *address* that in turn contains the actual jump
    target. To implement this indirect jump we thus first attach the operand to the
    RAM address lines at tick 4, then attach the RAM data lines to the program counter
    at tick 5.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现代（直接）跳转指令的操作数中包含跳转到的行号，因此它们可以通过将操作数直接复制到程序计数器来实现。然而，正如我们所看到的，Baby使用了间接跳转指令`JMP`，其中操作数包含一个*地址*，该地址进一步包含实际的跳转目标。为了实现这种间接跳转，我们首先在第4个时钟周期将操作数附加到RAM地址线，然后在第5个时钟周期将RAM数据线连接到程序计数器。
- en: The Baby also has a relative jump, `JRP`, which works similarly to `JMP` except
    that the address in the operand contains a number of lines to advance the program
    counter, rather than an absolute address.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Baby还有一个相对跳转`JRP`，其工作方式类似于`JMP`，只不过操作数中的地址包含了一个表示程序计数器应该前进多少行的数字，而不是一个绝对地址。
- en: For the branch instruction, `SKN`, we check its condition and behave as normal
    if it’s false, or increment the program counter an extra time if it’s true, to
    skip over one line of code. (Usually the skipped line will be chosen by the programmer
    to be a jump to another part of the code.) To implement this, we send the output
    of the accumulator to a comparator that tests if it’s less than zero. The truth
    or falsehood of this condition is then used (thanks to Boole) as an integer 0
    or 1, which is added to the program counter at tick 5 when the branch instruction
    is active.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于分支指令`SKN`，我们检查其条件，如果为假，则按常规行为执行；如果为真，则额外增加一次程序计数器，以跳过一行代码。（通常跳过的代码行是由程序员选择的，通常是跳转到程序的其他部分。）为了实现这一点，我们将累加器的输出发送到一个比较器，该比较器测试累加器是否小于零。该条件的真假随后（借助布尔代数）作为整数0或1使用，在分支指令激活时，在第5个时钟周期加到程序计数器上。
- en: If the current instruction isn’t a control flow instruction (that is, if it’s
    `SUB`, `LDN`, or `STO`), then no further changes are made to the program counter.
    This is implemented simply by wiring the program counter’s output directly to
    its input at tick 5.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前指令不是控制流指令（即它是`SUB`、`LDN`或`STO`），则程序计数器不会再发生任何变化。这通过在第5个时钟周期将程序计数器的输出直接连接到其输入来实现。
- en: '[Figure 7-12](ch07.xhtml#ch07fig12) shows our Baby implementation of flow control.
    In RTL notation, this corresponds to:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-12](ch07.xhtml#ch07fig12)展示了我们Baby实现的流程控制。用RTL表示法，这对应于：'
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once the program counter has been updated by any of the means described here,
    the fetch-decode-execute cycle is complete, and everything is set up for the next
    cycle to begin.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序计数器通过上述任一方式更新，取指-解码-执行周期就完成了，一切准备就绪，下一周期可以开始。
- en: '![Image](../images/f0176-01.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0176-01.jpg)'
- en: '*Figure 7-12: Program flow control, triggered at ticks 0, 4, and 5*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-12：程序流程控制，触发时刻为 0、4 和 5*'
- en: '*Complete Baby Implementation*'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*完整的 Baby 实现*'
- en: '[Figure 7-13](ch07.xhtml#ch07fig13) shows our complete, working Baby CPU, with
    all of the above systems shown together. In the lower-left it adds a register
    and lamp that activate when the halt instruction is executed, preventing any further
    execution. If you get tired of manually triggering the clock, it also adds a switch
    connecting the clock signal to an oscillator.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-13](ch07.xhtml#ch07fig13) 显示了我们完整的、可工作的 Baby CPU，所有上述系统都一同展示。在左下角，它增加了一个寄存器和灯，当
    halt 指令被执行时，它们会被激活，防止任何进一步的执行。如果你厌倦了手动触发时钟，它还增加了一个开关，将时钟信号连接到振荡器。'
- en: '![Image](../images/f0177-01.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0177-01.jpg)'
- en: '*Figure 7-13: A complete, working Baby implementation, including sequencer,
    fetch, decode, execute, and control flow logic. The RAM contents are now shown
    in full.*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-13：一个完整、可工作的 Baby 实现，包括序列发生器、取指、解码、执行和控制流逻辑。现在 RAM 内容已完整显示。*'
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We now have a complete computer in digital logic, able to execute machine code
    programs in RAM.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经拥有了一台完整的数字逻辑计算机，能够在 RAM 中执行机器码程序。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小结
- en: The purpose of a digital logic CPU is to execute machine code programs, which
    can be assembled from human-readable assembly language. These programs need to
    be placed into memory before the CPU starts its work. They consist of a series
    of instructions that are in turn read into the CPU and executed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 数字逻辑 CPU 的目的是执行机器码程序，这些程序可以通过人类可读的汇编语言进行组装。这些程序需要在 CPU 开始工作之前被加载到内存中。它们由一系列指令组成，这些指令依次被读取到
    CPU 并执行。
- en: CPUs can initially scare those trying to understand them. Even a minimal example
    such as our Baby might take thousands of transistors; modern CPU chips can contain
    billions. But you’ve seen in this chapter that the basic structure isn’t so complex
    if you think hierarchically, like an architect. From this perspective, you already
    saw how to build a variety of simple machines that each perform a basic task;
    a basic CPU then just connects a small number of these simple machines.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 最初可能会让那些试图理解它的人感到害怕。即使像我们的 Baby 这样的最小示例也可能需要成千上万的晶体管；现代的 CPU 芯片则可以包含数十亿个晶体管。但你在本章中已经看到，如果从层次化的角度思考，就不会觉得基本结构那么复杂，像一个建筑师那样思考。从这个角度来看，你已经学会了如何构建多种执行基本任务的简单机器；然后一个基础的
    CPU 只是将少数这些简单机器连接起来。
- en: The CU can be built from a sequencer, which triggers the fetch, decode, and
    execute stages. The execute stage is the hardest one to implement, as it involves
    different actions depending on what instruction was decoded. The sub-steps of
    the execute stage therefore need some additional logic to activate the different
    options.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 控制单元（CU）可以由一个序列发生器构成，它触发取指、解码和执行阶段。执行阶段是最难实现的，因为它涉及根据解码的指令执行不同的操作。因此，执行阶段的子步骤需要一些额外的逻辑来激活不同的选项。
- en: This chapter has shown roughly how the Manchester Baby was and can be put together.
    The architecture we built still forms the basic plan for many modern CPUs. Pressures
    from Moore’s law have complicated this plan, however. They prevent modern machines
    from simply being clocked faster, but they allow them to use many more transistors.
    In the next chapter you’ll see some of the more complex uses that modern CPUs
    can make of these extra transistors.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本章大致展示了曼彻斯特 Baby 是如何被构建的，并且它是如何被拼装的。我们所构建的架构仍然构成了许多现代 CPU 的基本计划。然而，摩尔定律的压力使得这一计划变得更加复杂。它们阻止了现代机器仅仅通过提高时钟速度来提升性能，但却允许它们使用更多的晶体管。在下一章中，你将看到现代
    CPU 如何利用这些额外的晶体管进行更复杂的应用。
- en: Exercises
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '**Build a Baby**'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**构建一个 Baby**'
- en: Build the Baby design from [Figure 7-13](ch07.xhtml#ch07fig13) in LogiSim Evolution.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 LogiSim Evolution 中构建 [图 7-13](ch07.xhtml#ch07fig13) 中的 Baby 设计。
- en: Once you start working at this level of complexity with sequential logic, it’s
    very easy and common to create hardware bugs around trigger timing. Working architects
    spend a lot of their time debugging timing issues. The hardware equivalent of
    a debugger is a *chronogram* ([Figure 7-14](ch07.xhtml#ch07fig14)), a diagram
    that plots the state of several wires in the system over time. LogiSim Evolution
    has a built-in tool for generating these (**Simulate ▸ Timing diagram**). Find
    out how to use it to test some of the sequential subcircuits from the Baby. Recall
    that sequential logic—write enables for RAM and registers, and RAM read addresses—is
    usually triggered at the *instant* the clock signal rises from 0 to 1, while combinatorial
    logic is active at all times. There are also hardware logic analyzers that will
    capture and display similar data from breadboards, either standalone or sending
    the data to your PC for analysis.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你开始在这种复杂度的顺序逻辑层面上工作，很容易且常见会在触发定时上产生硬件错误。硬件架构师通常会花费大量时间调试定时问题。硬件调试器的对应工具是*时序图*（[图
    7-14](ch07.xhtml#ch07fig14)），它绘制了系统中几条电线随时间变化的状态。LogiSim Evolution 有一个内建的工具来生成这些时序图（**模拟
    ▸ 时序图**）。了解如何使用它来测试 Baby 中的一些顺序子电路。回想一下，顺序逻辑——RAM 和寄存器的写使能，RAM 读取地址——通常在时钟信号从
    0 上升到 1 的*瞬间*触发，而组合逻辑则始终处于活动状态。也有硬件逻辑分析仪可以捕捉并显示来自面包板的类似数据，无论是独立使用还是将数据发送到你的 PC
    进行分析。
- en: '![Image](../images/f0179-01.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0179-01.jpg)'
- en: '*Figure 7-14: A LogiSim chronogram*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-14：LogiSim 时序图*'
- en: '**Programming the Baby**'
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**编程 Baby 计算机**'
- en: Assemble the test programs—including Turing’s division program—discussed in
    this chapter, and run them in your LogiSim Baby. Use the Python assembler provided,
    with the `for_logisim` flag on line 3 set to True. Save the output in a text file
    and load it as a RAM image in LogiSim by right-clicking the RAM and selecting
    **Load Image**. You can step through CPU cycles manually by clicking the clock,
    or by setting it to tick automatically with **Simulate ▸ Auto-tick** in the menu
    bar. Turing’s program divides 36 by 5, to give result 7 (111[2]), which gets stored—padded
    with zeros—in address 28, so it appears as E000000[16]. Try editing lines 29 to
    31 to perform different divisions.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 汇编本章讨论的测试程序——包括图灵的除法程序——并在 LogiSim Baby 中运行它们。使用提供的 Python 汇编器，确保第 3 行的 `for_logisim`
    标志设置为 True。将输出保存在文本文件中，并通过右键点击 RAM 选择 **加载映像** 将其作为 RAM 映像加载到 LogiSim 中。你可以通过点击时钟手动步进
    CPU 循环，或者通过在菜单栏中选择 **模拟 ▸ 自动步进** 来设置时钟自动跳动。图灵的程序将 36 除以 5，结果是 7（111[2]），并将其存储——用零填充——在地址
    28，所以它显示为 E000000[16]。尝试编辑第 29 到 31 行执行不同的除法操作。
- en: Can you explain how Turing’s code works? Remember that the Baby’s two main quirks
    are that it negates values when loading them, and it has only a subtractor rather
    than an adder. These lead to a few programming idioms.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能解释一下图灵的代码是如何工作的？记住，Baby 计算机有两个主要特点：加载时会否定值，并且它只有一个减法器，而不是加法器。这些特点导致了一些编程习惯。
- en: '**Challenging**'
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**具有挑战性**'
- en: 'We’ve used several layers of notational abstraction in our CPU designs: packaging
    up transistors, gates, and simple machines into boxes. Estimate how many logic
    gates, then how many transistors are used in our final design. How does the number
    of transistors compare with those used in the actual historical designs in [Chapter
    1](ch01.xhtml)? How could these be reduced if we preferred an implementation using
    less silicon rather than an educationally easy-to-understand design?'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 CPU 设计中使用了多个层次的符号抽象：将晶体管、门电路和简单的机器打包成盒子。估算一下在我们的最终设计中使用了多少逻辑门，再估算一下使用了多少晶体管。这些晶体管的数量与[第一章](ch01.xhtml)中实际历史设计使用的数量相比如何？如果我们更倾向于使用较少硅片而非容易理解的教育性设计，如何减少这些数量？
- en: '**More Challenging**'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**更具挑战性**'
- en: The Baby is a very small, simple computer, but it’s possible to extend it into
    a fairly serious modern machine by modifying our design. Try doing this using
    the following steps.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Baby 计算机虽然很小，且结构简单，但通过修改我们的设计，它是有可能扩展成一台相当强大的现代计算机的。尝试按照以下步骤进行操作。
- en: Increase the RAM size. To do this, you’ll need to increase the size of the addresses
    throughout the design.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加 RAM 的大小。为此，你需要在整个设计中增加地址的大小。
- en: Replace the Baby’s LDN with a more normal LOAD instruction, which just loads
    without negation. Or retain LDN and create a new LOAD in addition to it, if you
    want to retain back-compatibility with old code. This will lead to more complexity
    and silicon, but will keep existing users happy, so is representative of a typical
    dilemma architects face.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将宝贝的LDN指令替换为更常见的LOAD指令，该指令仅加载而不进行取反。或者，如果你想保留与旧代码的向后兼容性，可以保留LDN并创建一个新的LOAD指令。这会增加更多的复杂性和硅片，但能让现有用户满意，因此这也是架构师面临的典型困境。
- en: Replace the single subtraction module with a full two’s complement integer ALU,
    including add, subtract, multiply, and divide. Create extra instructions to trigger
    these operations.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将单一的减法模块替换为完整的二进制补码整数ALU，包括加法、减法、乘法和除法。创建额外的指令以触发这些操作。
- en: Look at the later Manchester Mark I and Ferranti Mark I machines to see how
    the original Baby was actually extended to commercialization. Try to emulate them
    in LogiSim.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看后来的曼彻斯特Mark I和费兰蒂Mark I机器，了解原始宝贝计算机如何扩展到商业化。尝试在LogiSim中模拟它们。
- en: Further Reading
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For the nearest we have to an official modern manual for the Manchester Baby,
    see the University of Manchester’s current web page, *[http://curation.cs.manchester.ac.uk/computer50/www.computer50.org/mark1/prog98/ssemref.html](http://curation.cs.manchester.ac.uk/computer50/www.computer50.org/mark1/prog98/ssemref.html)*.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于我们所拥有的最接近曼彻斯特宝贝的官方现代手册，请参阅曼彻斯特大学当前的网页，* [http://curation.cs.manchester.ac.uk/computer50/www.computer50.org/mark1/prog98/ssemref.html](http://curation.cs.manchester.ac.uk/computer50/www.computer50.org/mark1/prog98/ssemref.html)*。
- en: 'For the original publication describing the real Baby, see F.C. Williams, T.
    Kilburn, and G.C. Tootill, “Universal High-Speed Digital Computers: A Small-Scale
    Experimental Machine,” *Proceedings of the IEE [Part II](part02.xhtml): Power
    Engineering* 98, no. 61 (1951): 13–28.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '有关描述真正的宝贝计算机的原始文献，请参见F.C. Williams、T. Kilburn和G.C. Tootill在《*Proceedings of
    the IEE [Part II](part02.xhtml): Power Engineering*》第98卷，第61期（1951年）：第13–28页中的“通用高速数字计算机：一种小规模实验机器”一文。'
- en: 'For details of the later Manchester Mark I, see R.B.E. Napper, “The Manchester
    Mark 1 Computers,” in *The First Computers: History and Architectures*, ed. Raúl
    Rojas and Ulf Hashagen (Cambridge, MA: MIT Press, 2000), 365–377.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '有关后期曼彻斯特Mark I的详细信息，请参见R.B.E. Napper在《*The First Computers: History and Architectures*》一书中的“曼彻斯特Mark
    1计算机”（编辑Raúl Rojas和Ulf Hashagen，剑桥，马萨诸塞：MIT出版社，2000年），第365–377页。'
