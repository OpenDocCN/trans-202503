- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 8 LOCAL INFORMATION GATHERING
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 本地信息收集
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In the previous two chapters, we gained an initial foothold on several hosts.
    In this chapter, we’ll perform local reconnaissance to identify assets of interest,
    leaving no stone unturned on the path to taking over other hosts on the network.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们已经在多个主机上获得了初步立足点。在这一章中，我们将进行本地侦察，识别感兴趣的资产，在征服网络中其他主机的道路上，不留下任何遗漏。
- en: 'Knowing where to find sensitive information once you successfully compromise
    a host is a critical skill. We’ll focus on key categories of information you can
    gather: identities (like users and groups), files (including logs and configurations),
    network information, automation workflows, installed software and firmware, running
    processes, and security mechanisms. We’ll cover other information, such as credentials,
    in [Chapter 9](chapter9.xhtml), when we discuss privilege escalation techniques.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功控制了主机，知道在哪里找到敏感信息是一项关键技能。我们将专注于你可以收集的关键信息类别：身份（如用户和组）、文件（包括日志和配置文件）、网络信息、自动化工作流、已安装的软件和固件、正在运行的进程以及安全机制。在[第9章](chapter9.xhtml)中，当我们讨论特权提升技术时，还会涉及其他信息，如凭证。
- en: 'In real-life scenarios, the post-compromise phase is also where your chances
    of getting caught by defenders increase, as the information you gather could leave
    a trail. For this reason, we’ll default as much as possible to using native Linux
    utilities and files to collect information in an attempt to *live off the land*:
    making do with what’s available on a host while avoiding the use of external tools,
    which could trigger alerts.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活场景中，后渗透阶段也是你被防守方抓住的几率增加的阶段，因为你收集的信息可能会留下痕迹。出于这个原因，我们会尽可能默认使用本地的Linux工具和文件来收集信息，尝试做到*利用现有资源*：利用主机上已有的工具，而避免使用外部工具，这些工具可能会触发警报。
- en: Try running the shell commands presented in the chapter on all the hosts you’ve
    compromised thus far, as well as any new machines you compromise as you progress
    through the book. You could even build a script from these commands to easily
    execute the same ones on all machines.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在你目前已控制的所有主机上运行本章介绍的shell命令，以及在继续阅读过程中你所控制的任何新机器。你甚至可以根据这些命令编写脚本，在所有机器上轻松执行相同的命令。
- en: The Filesystem Hierarchy Standard
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统层次结构标准
- en: Data of interest could live in many areas of a Linux filesystem. To efficiently
    explore the systems on which you’ve obtained shell access, consult the *Filesystem
    Hierarchy Standard (FHS)*, which describes the structure of directories and their
    locations on a Linux system. This hierarchical standard makes it easier for users
    and programs to search for files of interest, such as log or configuration files.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 感兴趣的数据可能分布在Linux文件系统的多个区域。为了高效探索你获得shell访问权限的系统，参考*文件系统层次结构标准（FHS）*，它描述了Linux系统中文件夹的结构及其位置。这一层次结构标准使得用户和程序能够更容易地搜索感兴趣的文件，如日志文件或配置文件。
- en: The Linux filesystem’s hierarchy starts at the root (*/*) directory, which is
    the entry point into the filesystem directory tree structure. [Table 8-1](chapter8.xhtml#tab8-1)
    shows the main subdirectories under root and their primary uses.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Linux文件系统的层次结构从根目录（*/*）开始，这是进入文件系统目录树结构的起点。[表 8-1](chapter8.xhtml#tab8-1)展示了根目录下的主要子目录及其主要用途。
- en: 'Table 8-1: Filesystem Hierarchy Standard Directory Layout'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-1：文件系统层次结构标准目录布局
- en: '| Directory | Description |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 目录 | 描述 |'
- en: '| --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| / | Primary parent directory, also called the root directory. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| / | 主目录，也叫根目录。 |'
- en: '| /var | Directory for nonstatic (variable) files. Often contains application
    logfiles under the /var/log directory or contains processed tasks, such as scheduled
    and print jobs, under /var/spool. It may also contain cache files in /var/cache
    and system-related runtime data under /var/run. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| /var | 用于非静态（可变）文件的目录。通常包含/var/log目录下的应用日志文件，或包含处理过的任务，如定时任务和打印作业，存放在/var/spool目录下。它也可能包含/var/cache下的缓存文件，以及/var/run下的系统相关运行时数据。
    |'
- en: '| /etc | Directory for configuration files. Application software installed
    on the system keeps dedicated configuration files in this directory (usually with
    the *.conf extension). This directory also contains files such as /etc/passwd,
    /etc/group, and /etc/shadow, where user accounts, group information, and password
    hashes, respectively, exist. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| /etc | 存放配置文件的目录。安装在系统上的应用程序将其专用的配置文件保存在此目录中（通常以 *.conf 后缀）。该目录还包含诸如 /etc/passwd、/etc/group
    和 /etc/shadow 等文件，分别存储用户账户、组信息和密码哈希。 |'
- en: '| /bin | Directory for binary utilities. Commonly used for storing binaries
    related to system tasks such as navigation commands (cd), file copying (cp), directory
    creation (mkdir), or file creation (touch). |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| /bin | 存放二进制工具的目录。通常用于存放与系统任务相关的二进制文件，如导航命令（cd）、文件复制（cp）、目录创建（mkdir）或文件创建（touch）。
    |'
- en: '| /sbin | Directory for system binaries, such as system debugging, disk manipulation,
    and service management utilities that are intended for use by the system administrator.
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| /sbin | 存放系统二进制文件的目录，例如用于系统调试、磁盘操作和服务管理的工具，主要供系统管理员使用。 |'
- en: '| /dev | Directory that represents and provides access to device files, such
    as disk partitions, thumb drives, and external hard drives. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| /dev | 表示并提供访问设备文件（如磁盘分区、U 盘和外部硬盘驱动器）的目录。 |'
- en: '| /boot | Directory for bootloaders, kernel files, and initial random-access
    memory (RAM) disks (initrd). |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| /boot | 存放引导加载程序、内核文件和初始随机存取内存（RAM）磁盘（initrd）的目录。 |'
- en: '| /home | Directory containing the home directory of local system user accounts.
    Active system user accounts usually have a subdirectory as their assigned home
    directory. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| /home | 存放本地系统用户账户的家目录的目录。活动的系统用户账户通常会有一个子目录作为其分配的家目录。 |'
- en: '| /root | Directory containing the home directory of the root user account.
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| /root | 存放 root 用户家目录的目录。 |'
- en: '| /tmp | Directory for temporarily written files and directories. The /var/tmp
    directory is another temporary directory often used for temporary files. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| /tmp | 存放临时文件和目录的目录。/var/tmp 是另一个常用于临时文件的临时目录。 |'
- en: '| /proc | Virtual filesystem for processes and kernel data. Gets automatically
    created on system boot. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| /proc | 存放进程和内核数据的虚拟文件系统。在系统启动时自动创建。 |'
- en: '| /usr | Directory for user binaries, manual pages, kernel sources, header
    files, and more (including games, in the past). |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| /usr | 存放用户二进制文件、手册页、内核源代码、头文件等的目录（过去还包括游戏）。 |'
- en: '| /run | Directory for runtime data. Describes the state of the system since
    it was last booted. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| /run | 存放运行时数据的目录。描述自上次启动以来系统的状态。'
- en: '| /opt | Directory for software applications. Often hosts data related to third-party
    software installations. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| /opt | 存放软件应用程序的目录。通常用于存放与第三方软件安装相关的数据。 |'
- en: '| /mnt | Directory for mounting network shares or other network devices, mostly
    used for mounting devices to the local filesystem either temporarily or permanently.
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| /mnt | 用于挂载网络共享或其他网络设备的目录，主要用于将设备挂载到本地文件系统，可以是临时的也可以是永久的。 |'
- en: '| /media | Directory for removable devices, such as CD drives. Serves as a
    mount point. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| /media | 存放可移动设备的目录，例如 CD 驱动器。作为挂载点使用。 |'
- en: '| /lib, /lib32, /lib64 | Directory for shared libraries needed to boot the
    system and run commands. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| /lib, /lib32, /lib64 | 存放启动系统和运行命令所需共享库的目录。 |'
- en: '| /srv | Directory for data commonly served by network services, such as web
    servers and file servers. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| /srv | 存放常见网络服务数据的目录，例如 Web 服务器和文件服务器的数据。 |'
- en: Production systems could have thousands of files scattered across their systems,
    so it’s important to know what sensitive data to search for and where to search
    for it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 生产系统可能有成千上万个文件分布在各个位置，因此了解需要搜索的敏感数据以及搜索位置非常重要。
- en: While FHS aims to standardize the layout of the filesystem, systems can deviate
    from the standard. Additionally, the system administrator can store application
    files wherever they like. For example, nothing stops a system administrator from
    serving their entire web server content from a directory such as */mywebsite*
    and writing logs to a directory such as */data/logs*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 FHS 旨在标准化文件系统的布局，但系统可以偏离标准。此外，系统管理员可以将应用程序文件存储在任何位置。例如，系统管理员完全可以将整个 Web 服务器内容服务于像*/mywebsite*
    这样的目录，并将日志写入像*/data/logs* 这样的目录。
- en: The Shell Environment
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Shell 环境
- en: From an information-gathering perspective, the shell environment is important
    because it can reveal information such as where the system looks for executables
    to run. Custom applications may add new directory paths to the PATH environment
    variable so that the application can run custom libraries and executables from
    nonstandard locations. You might also find credentials and other secrets in these
    custom configurations.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从信息收集的角度来看，shell环境非常重要，因为它可以揭示系统查找可执行文件的路径。自定义应用程序可能会向PATH环境变量中添加新的目录路径，以便应用程序能够从非标准位置运行自定义库和可执行文件。你也可能会在这些自定义配置中发现凭证和其他机密信息。
- en: Environment Variables
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境变量
- en: When compromising a host, it’s often useful to dump its environment variables
    by using the env or printenv commands. Administrators tend to store credentials
    in environment variables to avoid writing the credentials to files on disk. Delivery
    systems can inject credentials into the application’s runtime via these environment
    variables, which the application then reads. In addition, you may find other important
    information in environment variables, such as addresses of adjacent servers and
    runtime configurations.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当入侵主机时，使用env或printenv命令转储其环境变量通常是很有用的。管理员往往将凭证存储在环境变量中，以避免将凭证写入磁盘文件。交付系统可以通过这些环境变量将凭证注入到应用程序的运行时，应用程序然后读取这些凭证。此外，你还可能在环境变量中找到其他重要信息，如相邻服务器的地址和运行时配置。
- en: Sensitive Information in Bash Profiles
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: bash配置文件中的敏感信息
- en: 'In [Chapter 2](chapter2.xhtml), we used the *~/.bashrc* file and bash aliases
    to set up shortcuts to commands. System administrators could easily include credentials
    in shell scripts such as *~/.bashrc* to avoid having to manually supply credentials
    on the command line, so always poke around to see if any customizations were made;
    you may find credentials or commands used for administration purposes. Here are
    some common profile files to look for: */etc/profile*, */etc/bashrc*, *~/.bashrc*,
    *~/.profile*, *~/.bash_profile*, *~/.env*, *~/.bash_login*, and *~/.bash_logout*.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](chapter2.xhtml)中，我们使用了*~/.bashrc*文件和bash别名来设置命令的快捷方式。系统管理员可以轻松地在像*~/.bashrc*这样的shell脚本中包含凭证，以避免在命令行上手动输入凭证，因此总是要仔细检查是否做了任何自定义设置；你可能会找到凭证或用于管理目的的命令。以下是一些常见的配置文件，可以检查一下：*/etc/profile*、*/etc/bashrc*、*~/.bashrc*、*~/.profile*、*~/.bash_profile*、*~/.env*、*~/.bash_login*和*~/.bash_logout*。
- en: Shells other than bash, such as the Z Shell, can also exist on a system. In
    these cases, you might want to look at files such as */etc/zprofile*, */etc/zshrc*,
    *~/.zprofile*, and *~/.zshrc*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了bash外，系统上也可能存在其他shell，如Z Shell。在这种情况下，你可能需要查看像*/etc/zprofile*、*/etc/zshrc*、*~/.zprofile*和*~/.zshrc*这样的文件。
- en: Use the man command to learn more about the environment and profile files of
    the various shells. For example, run man bash for the bash shell, man zsh for
    the Z Shell, and man csh for the C Shell.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用man命令来了解各种shell的环境和配置文件。例如，运行man bash可以查看bash shell，man zsh可以查看Z Shell，man
    csh可以查看C Shell。
- en: Users and Groups
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户和组
- en: You should gather information about the various users and groups found on the
    system. Systems can be provisioned with user accounts for human operators, but
    you may also run into systems that have no accounts other than the default ones
    of a Linux machine. This is especially true in environments where hosts are spun
    up and down many times per day, such as in containerized environments. Short-lived
    servers aren’t generally managed using local system accounts; rather, orchestration
    and provisioning tools automate the entire process of rollouts, upgrades, downgrades,
    scaling in and out, scaling up and down, and so on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该收集系统中各种用户和组的信息。系统可以为人类操作员配置用户账户，但你也可能会遇到除了Linux机器的默认账户外没有其他账户的系统。尤其是在容器化环境中，主机可能每天会频繁创建和销毁。短生命周期的服务器通常不会使用本地系统账户进行管理；相反，编排和配置工具会自动化整个部署、升级、降级、扩展等过程。
- en: Local Accounts
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地账户
- en: Linux systems come with several default users and groups. You can find user
    accounts in */etc/passwd* and groups in */etc/group*, which even low-privileged
    users should be able to read. These files don’t contain sensitive data but can
    help you figure out other directories and files to look for, as everything on
    a Linux system is owned by a user and group.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Linux系统有多个默认的用户和组。你可以在*/etc/passwd*中找到用户账户，在*/etc/group*中找到组信息，即使是权限较低的用户也应该能够读取这些文件。这些文件不包含敏感数据，但可以帮助你找到其他目录和文件，因为Linux系统中的一切都有用户和组的所有权。
- en: NOTE
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Hackers frequently go after both* /etc/passwd *and* /etc/group*, so security
    defenders with proper monitoring in place will watch for any read or write attempts
    made to these files.*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*黑客通常会攻击* /etc/passwd *和* /etc/group *文件，因此，安全防御者需要通过适当的监控来观察是否有任何读取或写入这些文件的行为。*'
- en: Let’s view the */etc/passwd* files on the compromised hosts. Run the command
    in [Listing 8-1](chapter8.xhtml#Lis8-1) on *p-web-01* (172.16.10.10), *p-web-02*
    (172.16.10.12), and *p-jumpbox-01* (172.16.10.13) to see the list of users and
    their properties.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看被攻陷主机上的 */etc/passwd* 文件。在 *p-web-01*（172.16.10.10）、*p-web-02*（172.16.10.12）和
    *p-jumpbox-01*（172.16.10.13）上运行[清单 8-1](chapter8.xhtml#Lis8-1)中的命令，查看用户列表及其属性。
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 8-1: Viewing users on a system'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-1：查看系统上的用户
- en: As you can see, we get a list of values separated by colons (:). Each line is
    a unique user account, and each field represents specific information about it.
    Of particular interest to us is the first line in the output, which indicates
    that there is a *root* user account. [Table 8-2](chapter8.xhtml#tab8-2) breaks
    this line into its constituent fields.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们得到一个由冒号（:）分隔的值列表。每一行都是一个唯一的用户账户，每个字段表示该账户的特定信息。我们特别关注输出中的第一行，这一行表示有一个
    *root* 用户账户。[表格 8-2](chapter8.xhtml#tab8-2) 将这一行拆分成其组成字段。
- en: 'Table 8-2: Fields of the /etc/passwd File'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 8-2：/etc/passwd 文件的字段
- en: '| Account | Password | User ID | Group ID | Comment | Home directory | Default
    shell |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 账户 | 密码 | 用户 ID | 组 ID | 注释 | 主目录 | 默认 shell |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| root | x | 0 | 0 | root | /root | /bin/bash |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| root | x | 0 | 0 | root | /root | /bin/bash |'
- en: The first field is the account’s username, and the *x* in the second field represents
    the password. You can find corresponding password hashes in a separate file named
    */etc/shadow*, which we’ll cover in later chapters when we discuss credential
    access. The third and fourth fields represent the user’s user ID (UID) and group
    ID (GID), respectively. The fifth field is a comment field that can contain details
    about the user (such as their full name, location, and employee ID). The sixth
    field represents the user’s home directory (in this case, */root*), and the seventh
    field represents their default shell environment (in this case, */bin/bash*).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字段是账户的用户名，第二个字段中的 *x* 表示密码。你可以在名为 */etc/shadow* 的单独文件中找到相应的密码哈希，我们将在后面的章节中讨论凭证访问时提及该文件。第三和第四个字段分别表示用户的用户
    ID（UID）和组 ID（GID）。第五个字段是注释字段，可以包含有关用户的详细信息（例如全名、位置和员工 ID）。第六个字段表示用户的主目录（在本例中为
    */root*），第七个字段表示其默认的 shell 环境（在本例中为 */bin/bash*）。
- en: Using bash, we can parse the */etc/passwd* output to extract certain desired
    fields. For example, to extract the username (in the first field), the home directory
    (in the sixth field), and the default shell (in the seventh field) of each user,
    run the command in [Listing 8-2](chapter8.xhtml#Lis8-2).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 bash，我们可以解析 */etc/passwd* 的输出，提取特定的字段。例如，要提取每个用户的用户名（第一个字段）、主目录（第六个字段）和默认
    shell（第七个字段），请运行[清单 8-2](chapter8.xhtml#Lis8-2)中的命令。
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 8-2: Extracting key information from /etc/passwd'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-2：从 /etc/passwd 中提取关键信息
- en: Because the fields are separated by colons, we can easily use awk and sed to
    retrieve the fields of interest.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字段是由冒号分隔的，我们可以轻松使用 awk 和 sed 来提取感兴趣的字段。
- en: Local Groups
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地组
- en: Next, run the command in [Listing 8-3](chapter8.xhtml#Lis8-3) to see the list
    of local groups.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行[清单 8-3](chapter8.xhtml#Lis8-3)中的命令，查看本地组列表。
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 8-3: Viewing groups on a system'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-3：查看系统上的组
- en: 'The */etc/group* file is formatted as follows: the first field is a unique
    value representing the group’s name, the second field represents the password,
    the third field is the GID, and the last field is the list of members of each
    group, separated by commas. As you can see in the bolded part of the output, the
    *ubuntu* user account is part of the *adm* group, which is a group used for system
    administration tasks such as viewing logs.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/group* 文件的格式如下：第一个字段是表示组名的唯一值，第二个字段表示密码，第三个字段是 GID，最后一个字段是每个组成员的列表，成员之间由逗号分隔。正如你在输出的加粗部分所看到的，*ubuntu*
    用户账户是 *adm* 组的一部分，*adm* 组用于系统管理任务，如查看日志。'
- en: Home Folder Access
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主文件夹访问
- en: By default, only the user or a superuser, such as the *root* user, can access
    that user’s home directory. Run the command in [Listing 8-4](chapter8.xhtml#Lis8-4)
    to list all user home directories and their permissions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，只有用户或超级用户（如 *root* 用户）可以访问该用户的主目录。在[清单 8-4](chapter8.xhtml#Lis8-4)中运行命令，列出所有用户的主目录及其权限。
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 8-4: Viewing home directories and permissions'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-4：查看 home 目录和权限
- en: As you can see, each home directory is owned by the user to which it belongs.
    We’ll discuss directory permissions in more detail in [Chapter 9](chapter9.xhtml).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，每个 home 目录都归其所属的用户所有。我们将在[第 9 章](chapter9.xhtml)中更详细地讨论目录权限。
- en: Let’s write a small bash script to check whether we can access users’ home directories.
    This is useful because permissions can get messed up by mistake, such as when
    they’re changed recursively or when they’re part of large systems that may have
    dozens of user accounts.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个小的 bash 脚本来检查是否能够访问用户的 home 目录。这是非常有用的，因为权限可能会因错误而被搞乱，例如在权限被递归修改时，或者在涉及大量用户账户的大型系统中。
- en: NOTE
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*This chapter’s scripts are available at* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch08](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch08).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章节的脚本可以在* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch08](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch08)
    获取。'
- en: 'The script in [Listing 8-5](chapter8.xhtml#Lis8-5) will take the following
    steps: check whether the running user can read */etc/passwd*, and if so, read
    its contents; extract the default home directory path of each user account; check
    whether the current user can read each home directory; and print the results.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-5](chapter8.xhtml#Lis8-5) 中的脚本将执行以下步骤：检查运行用户是否可以读取 */etc/passwd*，如果可以，则读取其内容；提取每个用户账户的默认
    home 目录路径；检查当前用户是否可以读取每个 home 目录；并打印结果。'
- en: home_dir _access_check.sh
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: home_dir _access_check.sh
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 8-5: Attempting to access users’ home directories'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-5：尝试访问用户的 home 目录
- en: In a while loop, we read the */etc/passwd* file line by line ❶. At ❷ and ❸,
    we assign the account and home_dir variables to the first and sixth fields of
    each line, respectively. We then check whether the home directory starts with
    the string /home by using the caret (^) character ❹ and the grep -q (quiet) option
    so that the output of the command won’t be printed to the standard output stream.
    At ❺, if our previous check succeeded, we check whether the home directory is
    readable with -r and print the result to the screen.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 while 循环中，我们逐行读取 */etc/passwd* 文件 ❶。在 ❷ 和 ❸ 处，我们分别将账户和 home_dir 变量赋值为每行的第一个和第六个字段。接着，我们使用插入符号
    (^) 字符和 grep -q（安静模式）选项检查 home 目录是否以 /home 开头，确保命令的输出不会打印到标准输出流中。在 ❺ 处，如果我们之前的检查成功，我们会检查
    home 目录是否可读，并将结果打印到屏幕上。
- en: Valid Shells
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有效的 Shell
- en: 'We mentioned that the seventh field of */etc/passwd* is the user’s default
    shell. However, the system administrator can assign users an invalid shell as
    a security hardening measure. For hackers, accounts with real shells (such as
    */bin/bash*) should thus indicate one of two possibilities: that the account belongs
    to a real user or service with a possible need to log in, or that the account
    has a possible misconfiguration.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过 */etc/passwd* 的第七个字段是用户的默认 shell。然而，系统管理员可以为用户分配一个无效的 shell 作为安全加固措施。对于黑客来说，具有真实
    shell（例如 */bin/bash*）的账户应该表明两种可能性之一：账户属于一个需要登录的真实用户或服务，或者账户存在配置错误。
- en: 'When system administrators add an account to a Linux machine by using the command
    useradd or adduser, the default shell is determined by the SHELL setting in the
    file */etc/default/useradd* or by DSHELL in */etc/adduser.conf*, as you can see
    here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统管理员使用 useradd 或 adduser 命令向 Linux 机器添加账户时，默认的 shell 由 */etc/default/useradd*
    文件中的 SHELL 设置或 */etc/adduser.conf* 中的 DSHELL 设置决定，正如你在这里看到的：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With some advanced bash and awk, we can filter for lines containing valid shells
    such as */bin/bash* or */bin/sh*, then focus our future efforts on those accounts
    only ([Listing 8-6](chapter8.xhtml#Lis8-6)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些高级 bash 和 awk，我们可以筛选出包含有效 shell（例如 */bin/bash* 或 */bin/sh*）的行，然后将后续工作集中在这些账户上（[列表
    8-6](chapter8.xhtml#Lis8-6)）。
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 8-6: Using advanced awk syntax to find accounts with active shells'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-6：使用高级 awk 语法查找具有活动 shell 的账户
- en: We’ve intentionally made this command slightly more complicated than necessary
    so you can see how powerful awk can be for parsing purposes. In [Listing 8-6](chapter8.xhtml#Lis8-6),
    awk uses its built-in if condition and an OR operator (||) to check whether the
    seventh field of the file equals */bin/sh* or */bin/bash*. It then prints the
    first and seventh fields if the expression is true.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意让这个命令比必要的稍微复杂一些，以便让你看到 awk 在解析方面的强大功能。在[列表 8-6](chapter8.xhtml#Lis8-6)中，awk
    使用内建的 if 条件和 OR 操作符 (||) 来检查文件的第七个字段是否等于 */bin/sh* 或 */bin/bash*。如果表达式为真，它会打印第一个和第七个字段。
- en: Just as with anything in bash, you can achieve the same objective with an even
    simpler command ([Listing 8-7](chapter8.xhtml#Lis8-7)).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 bash 中做任何事一样，你也可以通过一个更简单的命令来实现相同的目标（[列表 8-7](chapter8.xhtml#Lis8-7)）。
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 8-7: Using grep to find accounts with active shells'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-7：使用 grep 查找具有活动 shell 的账户
- en: This simpler grep command is more prone to errors, however, because it will
    print any field that contains either of the two strings (not specifically the
    seventh field, where the default shell is defined).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个更简单的 grep 命令更容易出错，因为它会打印包含这两个字符串的任何字段（而不仅仅是第七个字段，其中定义了默认的 shell）。
- en: Processes
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程
- en: Enumerating running processes is an extremely important step of successful reconnaissance.
    Processes help us identify all code that a system is running, allowing us to focus
    our efforts on specific applications. Processes are also important because they
    help us understand a host’s defense systems.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举运行中的进程是成功侦察的重要步骤。进程帮助我们识别系统正在运行的所有代码，从而使我们能够集中精力针对特定应用程序。进程还很重要，因为它们帮助我们了解主机的防御系统。
- en: Viewing Process Files
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看进程文件
- en: Each process on a Linux host has a dedicated directory under */proc* that is
    named after its process identifier (PID), which is a numerical value. Let’s run
    a simple ls command (using the -1 option to list one file per line) and grep with
    a special regular expression to list all files in this directory that have numbers
    as their name ([Listing 8-8](chapter8.xhtml#Lis8-8)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Linux 主机上的进程都有一个专门的目录，在 */proc* 下，目录名称与其进程标识符（PID）相同，PID 是一个数值。让我们运行一个简单的
    ls 命令（使用 -1 选项每行列出一个文件），然后使用带有特殊正则表达式的 grep 来列出该目录中所有名称为数字的文件（[列表 8-8](chapter8.xhtml#Lis8-8)）。
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 8-8: Filtering for PIDs in the /proc directory'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-8：在 /proc 目录中筛选 PID
- en: 'Because new processes frequently spawn and then die, you’ll likely see different
    PID numbers from those in this output (with the exception of 1, also called the
    *init process*, which should always be present). Let’s explore the information
    available to us in the folder for the init process:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因为新进程经常会生成并随之终止，所以你可能会看到与此输出中的 PID 不同的 PID 数字（除了 1，通常称为 *init 进程*，它应该始终存在）。让我们探索
    init 进程的文件夹中可用的信息：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The folder contains many files, some of which are more interesting than others
    to penetration testers. For example, the following files contain useful information:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件夹包含许多文件，其中一些对渗透测试人员更为有趣。例如，以下文件包含有用的信息：
- en: '***/proc/<pid>/cmdline*** Contains the full command used to start the process.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '***/proc/<pid>/cmdline*** 包含启动进程时使用的完整命令。'
- en: '***/proc/<pid>/cwd*** Points to the working directory of the process.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '***/proc/<pid>/cwd*** 指向进程的工作目录。'
- en: '***/proc/<pid>/environ*** Contains the environment variables at the process’s
    start time.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '***/proc/<pid>/environ*** 包含进程启动时的环境变量。'
- en: '***/proc/<pid>/exe*** Points to the binary that started the process.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '***/proc/<pid>/exe*** 指向启动该进程的二进制文件。'
- en: '***/proc/<pid>/task*** Contains subdirectories for each thread started by the
    process.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '***/proc/<pid>/task*** 包含进程启动的每个线程的子目录。'
- en: '***/proc/<pid>/status*** Contains information about the process, such as its
    state, virtual memory size, number of threads, thread ID, and process *umask*
    (a four-digit value used to determine the permissions of freshly created files).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '***/proc/<pid>/status*** 包含关于进程的信息，例如其状态、虚拟内存大小、线程数量、线程 ID 和进程的 *umask*（一个四位数值，用于确定新创建文件的权限）。'
- en: '***/proc/<pid>/fd*** Contains the *file descriptors* in use. File descriptors
    are nonnegative (unsigned) integers used by processes to describe open files.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '***/proc/<pid>/fd*** 包含正在使用的 *文件描述符*。文件描述符是进程用于描述打开文件的非负整数（无符号整数）。'
- en: 'Let’s explore some of these files to see what they can tell us about PID 1
    on the system. On *p-web-01* (172.16.10.10), run the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这些文件，看看它们能告诉我们关于系统上 PID 1 的信息。在 *p-web-01*（172.16.10.10）上，运行以下命令：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, a python3 command starts this process. The output is a little
    hard to read because its elements are separated by null bytes. We can make it
    more readable by using the following command to replace null bytes with spaces:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，启动此进程的是一个 python3 命令。由于其元素由空字节分隔，输出有些难以阅读。我们可以使用以下命令将空字节替换为空格，使其更易读：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, look at the symbolic link */proc/1/cwd* to determine the working directory
    of process 1 by running the following ls command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，查看符号链接 */proc/1/cwd*，通过运行以下 ls 命令来确定进程 1 的工作目录：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first character in the output is l, which stands for a symbolic link. You
    can also see we have an arrow (->) from */proc/1/cwd* to */app*, indicating that
    the *cwd* symbolic link points to the */app* directory.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的第一个字符是l，表示符号链接。你还可以看到从*/proc/1/cwd*到*/app*有一个箭头（->），表明*cwd*符号链接指向*/app*目录。
- en: We encourage you to discover any other files that live under the */proc* directory
    and their purposes. You can find a well-explained list of these files in the proc
    manual page (by running man proc).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励你发现*/proc*目录下的任何其他文件及其用途。你可以在proc手册页中找到对这些文件的详细解释（通过运行man proc）。
- en: Running ps
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行ps
- en: 'Utilities such as ps can enable us to explore processes without having to manually
    navigate the /*proc* directory. Run the following command to see the list of processes:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 类似ps这样的工具使我们能够探索进程，而无需手动浏览/*proc*目录。运行以下命令以查看进程列表：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The output is lightweight because the lab runs on containers, and containers
    are designed to use the smallest number of resources possible. On production systems
    running non-container-based servers, you’ll likely see many more processes. You
    can run the same command on your Kali host to see the differences in the output.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是轻量级的，因为实验室运行在容器上，而容器旨在尽可能使用最少的资源。在运行非容器化服务器的生产系统上，你可能会看到更多的进程。你可以在你的Kali主机上运行相同的命令，查看输出的差异。
- en: 'The ps command uses the */proc* virtual filesystem to display process information
    in a more digestible way. Let’s use some of its built-in filtering capabilities
    to extract key information from the output, such as the running user, the PID,
    and the executed command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ps命令使用*/proc*虚拟文件系统以更易于理解的方式显示进程信息。让我们利用它的一些内置过滤功能，从输出中提取关键信息，如运行用户、PID和执行的命令：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the same command against all boxes we’ve compromised so far and note your
    results.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们目前已攻破的所有机器运行相同的命令，并记录你的结果。
- en: Examining Root Processes
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查Root进程
- en: The ownership of processes is also an important element to consider. Processes
    running as root can lead to privilege escalation vulnerabilities if they are written
    insecurely. For example, when we compromised the *p-web-01* web server (172.16.10.10),
    we landed in the shell as the *root* user because the *root* user initialized
    and started the application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 进程的所有权也是一个需要考虑的重要因素。以root身份运行的进程如果编写不安全，可能会导致权限提升漏洞。例如，当我们攻破*p-web-01*网站服务器（172.16.10.10）时，由于*root*用户初始化并启动了应用程序，我们进入了shell并以*root*用户身份登录。
- en: Running applications as a superuser is generally considered bad practice, but
    it makes our lives as penetration testers much easier. If the application were
    started with a custom application user, we would have had to seek privilege escalation
    opportunities. As you may recall, when we compromised the *p-web-02* (172.16.10.12)
    machine, we landed as the *www-data* user, not root.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以超级用户身份运行应用程序通常被认为是不好的做法，但这使得我们作为渗透测试者的工作变得更加轻松。如果应用程序是以自定义应用用户启动的，我们就得寻找权限提升的机会。正如你可能记得的那样，当我们攻破*p-web-02*（172.16.10.12）机器时，我们作为*www-data*用户登录，而不是root用户。
- en: As another example of why using the *root* user for an application runtime is
    bad practice, imagine that a bash script executes a file called */tmp/update.sh*
    every 10 minutes as a background job run by root, and say the file also happens
    to be writable by other system users. In this example, someone could write an
    instruction inside the file to grant themselves additional permissions, and since
    the process runs as root, the execution of the *update.sh* file would also run
    in the *root* user context.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个使用*root*用户运行应用程序时不推荐的例子，假设有一个bash脚本每10分钟由root用户以后台任务的方式执行一个名为*/tmp/update.sh*的文件，并且假设该文件也可以被其他系统用户写入。在这个例子中，某人可以在文件中写入一条指令，授予自己额外的权限，由于该进程是以root身份运行的，执行*update.sh*文件时也会以*root*用户的身份执行。
- en: The Operating System
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统
- en: The Linux operating system has so many variations that special websites such
    as *[https://distrowatch.com](https://distrowatch.com)* are dedicated to tracking
    them. How do you know exactly which operating system is running on the box you
    just took over?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Linux操作系统有如此多的变种，以至于像*[https://distrowatch.com](https://distrowatch.com)*这样的网站专门用于跟踪它们。你如何确定你刚刚攻破的主机上运行的到底是哪种操作系统？
- en: 'Operating systems may place information about themselves in different places,
    but for the most part, you’ll find it under the */etc* directory. Check the following
    locations: */etc/os-release*, */etc/issue*, */usr/lib/os-release*, */proc/version*,
    */etc/*-release*, and */etc/*-version*. For example, on the Ubuntu-based *p-web-01*
    machine (172.16.10.10), you should be able to find information about the operating
    system in */etc/os-release*.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统可能会将其相关信息存放在不同的位置，但大多数情况下，你会在*/etc*目录下找到。检查以下位置：*/etc/os-release*、*/etc/issue*、*/usr/lib/os-release*、*/proc/version*、*/etc/*-release*和*/etc/*-version*。例如，在基于
    Ubuntu 的*p-web-01*机器（172.16.10.10）上，你应该能在*/etc/os-release*中找到操作系统的信息。
- en: In addition to files, some utilities could also help you identify the operating
    system. Try running uname -o or uname -a, lsb_release, hostnamectl, and hostname.
    Although commands such as hostname and hostnamectl aren’t designed to show operating
    system information, they could reveal it if the system administrator set the machine’s
    hostname to include the operating type, such as *ubuntu-prod-01*. The same applies
    to the built-in environment variable $HOSTNAME, which also holds the hostname
    value.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 除了文件，一些工具也能帮助你识别操作系统。试试运行`uname -o`或`uname -a`、`lsb_release`、`hostnamectl`和`hostname`。尽管像`hostname`和`hostnamectl`这样的命令并不是为了显示操作系统信息而设计的，但如果系统管理员将机器的主机名设置为包含操作类型（如*ubuntu-prod-01*），它们也可能揭示操作系统信息。同样，内置的环境变量$HOSTNAME也保存着主机名的值。
- en: 'Exercise 12: Writing a Linux Operating System Detection Script'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 12：编写一个 Linux 操作系统检测脚本
- en: Try writing a script that can identify the operating system type (such as Ubuntu,
    Debian, or other) of any Linux-based operating system. To achieve this, the script
    should look for specific files of interest and extract information from them.
    Also, because anyone should be able to run the script on any Linux system and
    expect it to fail gracefully, you need to think about how you’ll handle errors.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编写一个脚本，能够识别任何基于 Linux 的操作系统的操作系统类型（例如 Ubuntu、Debian 或其他）。为此，脚本应查找感兴趣的特定文件并从中提取信息。此外，因为任何人都应该能够在任何
    Linux 系统上运行该脚本并期望它能够优雅地失败，你需要考虑如何处理错误。
- en: 'Here are the steps the script should take:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是脚本应采取的步骤：
- en: 1.  The script should use one or more of the available methods to gather the
    operating system–related information we highlighted earlier, using either a command
    or a file. You can also perform your own research to implement other local operating
    system discovery methods.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  脚本应使用一个或多个可用的方法，通过命令或文件收集我们之前强调的与操作系统相关的信息。你也可以进行自己的研究，以实现其他本地操作系统发现方法。
- en: 2.  If you haven’t found an operating system detection method, the script needs
    to handle this condition and indicate it to the user.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  如果你没有找到操作系统检测方法，脚本需要处理这种情况，并向用户指示。
- en: 3.  The script should exit with the correct status code for the runtime result.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  脚本应在运行结果正确的状态码下退出。
- en: The script *os_detect.sh* in this book’s GitHub repository is an example of
    an operating system detection script.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 本书 GitHub 仓库中的脚本*os_detect.sh*是一个操作系统检测脚本的示例。
- en: Login Sessions and User Activity
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录会话和用户活动
- en: When a user logs in to a system or opens a new terminal session, the system
    records this information. This occurs no matter whether the user logs in locally
    (on a laptop, for example) or remotely, over a protocol such as SSH or Telnet.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户登录系统或打开一个新的终端会话时，系统会记录下这些信息。无论用户是本地登录（例如在笔记本电脑上）还是通过如 SSH 或 Telnet 等协议远程登录，都会发生这种情况。
- en: This information is valuable because it could tell you about previous connections,
    including source IP addresses used to connect. For example, if a system administrator
    uses a dedicated management server to connect to other servers, collecting login
    sessions would reveal the IP address of the management server.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息非常有价值，因为它可以告诉你有关以前连接的情况，包括用于连接的源 IP 地址。例如，如果系统管理员使用专用的管理服务器连接到其他服务器，收集登录会话将揭示管理服务器的
    IP 地址。
- en: Collecting User Sessions
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收集用户会话
- en: 'To view the current users on a system, use the w or who commands:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看系统上的当前用户，可以使用`w`或`who`命令：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These commands show information such as the user’s username, their login time,
    and the command of their current process. The commands read this information from
    the */var/run/utmp* file.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令显示的信息包括用户的用户名、登录时间以及当前进程的命令。命令从*/var/run/utmp*文件中读取这些信息。
- en: 'The last command shows historical logins taken from the file */var/log/wtmp*,
    which contains both current and past user sessions:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: last 命令显示来自 */var/log/wtmp* 文件的历史登录记录，该文件包含当前和过去的用户会话：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Attempt these commands on the *p-jumpbox-01* machine (172.16.10.13) after logging
    in via SSH with the backup user.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过 SSH 使用备份用户登录后，尝试在 *p-jumpbox-01* 机器（172.16.10.13）上运行这些命令。
- en: Another useful command is lastb (last bad). This command displays a list of
    bad login attempts, taken from */var/log/btmp*, if such a file exists on the filesystem.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的命令是 lastb（last bad）。该命令显示一个失败登录尝试的列表，数据来源于 */var/log/btmp* 文件（如果该文件存在于文件系统中）。
- en: Files such as */var/run/utmp* and */var/log/wtmp* are binary files. If you try
    to read them by using the cat command, the output will be garbled. Some systems
    may have the utmpdump command, which takes in these files as arguments and prints
    them in proper format to the screen.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 像 */var/run/utmp* 和 */var/log/wtmp* 这样的文件是二进制文件。如果您尝试使用 cat 命令读取它们，输出将会是乱码。某些系统可能提供
    utmpdump 命令，它可以将这些文件作为参数，并以正确的格式将内容输出到屏幕上。
- en: Investigating Executed Commands
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调查已执行的命令
- en: When a user starts executing commands in the shell, the system captures this
    information and writes it to *history files*, which are usually hidden files (those
    starting with a dot) stored in the user’s home folder. For example, the *root*
    user’s history file is located at */root/.bash_history*. For normal users, the
    history file is usually saved under */home/<user>/.bash_history*. Different shells
    may name history files differently. For example, the Z Shell history file is named
    *.zsh_history*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户开始在 shell 中执行命令时，系统会捕获这些信息并将其写入 *历史文件*，这些通常是隐藏文件（以点开头的文件），存储在用户的主目录中。例如，*root*
    用户的历史文件位于 */root/.bash_history*。对于普通用户，历史文件通常保存在 */home/<user>/.bash_history*。不同的
    shell 可能会以不同的方式命名历史文件。例如，Z Shell 的历史文件命名为 *.zsh_history*。
- en: 'History files are interesting because they’re essentially a summary of a user’s
    actions on the command line. If someone ran a curl command with credentials to
    authenticate to a remote website, the command, along with the credentials, would
    be recorded in the history file. To see the history file of the current user,
    run the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 历史文件很有趣，因为它们本质上是用户在命令行上的操作摘要。如果某人使用凭证运行 curl 命令来认证远程网站，命令及其凭证将被记录在历史文件中。要查看当前用户的历史文件，可以运行以下命令：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A quick bash one-liner using find can help us search for hidden files with the
    *_history* suffix ([Listing 8-9](chapter8.xhtml#Lis8-9)).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 bash 一行命令和 find 可以帮助我们搜索带有 *_history* 后缀的隐藏文件（[列表 8-9](chapter8.xhtml#Lis8-9)）。
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 8-9: Searching for shell command history files'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-9：搜索 shell 命令历史文件
- en: This command starts the search from the root directory (*/*) and performs a
    case-sensitive search of files (-type f) whose filenames end with the string *_history*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令从根目录（*/*）开始搜索，并对文件进行区分大小写的搜索（-type f），查找文件名以字符串 *_history* 结尾的文件。
- en: Networking
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络
- en: 'Network information is among the most important data to gather about a system.
    During penetration tests, you may know of only one network (the one you’re connected
    to physically if you’re on an on-site engagement, for example), but that doesn’t
    mean this is the only network available. You may discover new networks if you
    happen to hack a *multi-homed* host: a machine with multiple network interfaces
    connected to different networks.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 网络信息是收集系统数据中最重要的部分之一。在渗透测试中，您可能只知道一个网络（例如，如果您在现场参与测试时，您可能只知道您物理连接的网络），但这并不意味着这是唯一可用的网络。如果您恰好入侵了一个
    *multi-homed* 主机，即一台具有多个网络接口并连接到不同网络的机器，您可能会发现新网络。
- en: Network Interfaces and Routes
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络接口和路由
- en: 'On a compromised host, a simple way to obtain all network interfaces is by
    looking at the files under the */sys/class/net* directory. Go ahead and try listing
    files on the compromised boxes. The following examples are from the *p-web-01*
    box (172.16.10.10):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在被入侵的主机上，一种获取所有网络接口的简单方法是查看 */sys/class/net* 目录下的文件。继续尝试在被入侵的机器上列出文件。以下示例来自
    *p-web-01* 主机（172.16.10.10）：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Each file is a symbolic link containing the name of a network interface, and
    each link points to a directory under */sys/devices/virtual/net/*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件都是一个符号链接，包含一个网络接口的名称，每个链接指向 */sys/devices/virtual/net/* 目录下的一个子目录：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You could also use this network interface analysis to identify whether a network
    device is physical or virtual. It’s worth noting that an administrator can change
    network interface names, so these aren’t reliable indicators. However, physical
    network devices should show up differently when you list files under */sys/devices/virtual/net*.
    Run the previous command on your Kali machine. You should see output similar to
    the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用网络接口分析来判断一个网络设备是物理的还是虚拟的。值得注意的是，管理员可以更改网络接口的名称，因此这些并不是可靠的指标。不过，物理网络设备在你列出
    */sys/devices/virtual/net* 下的文件时应该会有不同的表现。你可以在 Kali 机器上运行之前的命令，应该会看到类似以下的输出：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, all devices are virtual except eth0, which has a Peripheral
    Component Interconnect bus identifier, pci0000:00/0000:00:03.0. On your machine,
    this might look different depending on the network card you’re using.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，除了 eth0 之外，所有设备都是虚拟的，eth0 有一个外设组件互联总线标识符 pci0000:00/0000:00:03.0。在你的机器上，根据你使用的网卡，这可能会有所不同。
- en: NOTE
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Definitively identifying a target as a physical or a virtual server requires
    using multiple heuristics. Network collection can produce false positives.*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*要确定目标是物理服务器还是虚拟服务器，需要使用多种启发式方法。网络收集可能会产生假阳性。*'
- en: 'Another way to print all network interfaces without using special network utilities
    is by inspecting the */proc/net/route* file, which contains information about
    network routing. Manually inspecting this file can be useful on hardened hosts
    or lightweight Linux containers, where you may not have access to common network
    utilities such as ifconfig, ip, netstat, or ss (socket statistics):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种不使用特殊网络工具打印所有网络接口的方法是检查 */proc/net/route* 文件，该文件包含有关网络路由的信息。在强化的主机或轻量级 Linux
    容器中手动检查此文件非常有用，因为你可能无法访问常见的网络工具，如 ifconfig、ip、netstat 或 ss（套接字统计）：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The first line of the file is the column headers line, and each subsequent
    line corresponds to a network route, its network interface, and other routing-related
    information in hexadecimal format. For example, in the first line, under Gateway,
    the value 010A10AC represents the gateway IP address of the network interface.
    If you convert each byte to a decimal value, you should get the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的第一行是列标题行，每一行之后的内容对应一个网络路由、其网络接口以及以十六进制格式表示的其他路由相关信息。例如，在第一行中，Gateway 下的值
    010A10AC 表示网络接口的网关 IP 地址。如果你将每个字节转换为十进制值，你应该得到如下结果：
- en: 011
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 011
- en: 0A10
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 0A10
- en: 1016
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 1016
- en: AC172
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: AC172
- en: 'This is 172.16.10.1, the gateway IP address for the interface eth0, in little-endian
    format. You can use *[https://ascii.cl/conversion.htm](https://ascii.cl/conversion.htm)*
    to convert values from hexadecimal to decimal or do so with bash:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 172.16.10.1，eth0 接口的网关 IP 地址，以小端格式表示。你可以使用 *[https://ascii.cl/conversion.htm](https://ascii.cl/conversion.htm)*
    来将值从十六进制转换为十进制，或者使用 bash 进行转换：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Using the arithmetic operators $(()) and the character sequence 16#, which represents
    hexadecimal (or *base16*), you can convert any hexadecimal value to a decimal
    number.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用算术运算符 $(()) 和字符序列 16#，表示十六进制（或 *base16*），你可以将任何十六进制值转换为十进制数。
- en: 'The */proc/net/route* file didn’t give us the IP addresses of the network interfaces
    on the host. However, we can get this information by looking at the */proc/net/fib_trie*
    file. This file contains data that looks like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*/proc/net/route* 文件没有给我们主机上网络接口的 IP 地址。然而，我们可以通过查看 */proc/net/fib_trie* 文件来获取这些信息。这个文件包含类似这样的数据：'
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To parse this output to obtain only the network interface IP addresses, we can
    use the bash script in [Listing 8-10](chapter8.xhtml#Lis8-10).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要解析此输出并仅获取网络接口的 IP 地址，我们可以使用 [列表 8-10](chapter8.xhtml#Lis8-10) 中的 bash 脚本。
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 8-10: Extracting the IP addresses of network interfaces'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-10：提取网络接口的 IP 地址
- en: 'What about MAC addresses, the physical addresses of the network interfaces?
    We can get this information through the */sys* virtual filesystem too:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，MAC 地址，网络接口的物理地址呢？我们也可以通过 */sys* 虚拟文件系统获取这些信息：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On nonhardened hosts, you may have access to network utilities such as ifconfig,
    a very popular command found on Linux hosts. This command lets you view all the
    necessary network information in a more digestible way:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在非强化主机上，你可能可以访问如 ifconfig 这样的网络工具，这是一个在 Linux 主机上非常流行的命令。这个命令可以让你以更易于理解的方式查看所有必要的网络信息：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You should receive information such as MAC addresses, netmask and broadcast
    addresses, and some network statistics for each interface, such as the number
    of bytes of transmitted and received packets. By default, ifconfig will display
    only network interfaces that are in an “up” state; use the -a flag to display
    all interfaces.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会收到每个接口的信息，如 MAC 地址、子网掩码和广播地址，以及一些网络统计数据，如发送和接收数据包的字节数。默认情况下，ifconfig 只会显示处于“up”状态的网络接口；使用
    -a 标志可以显示所有接口。
- en: An alternative command to ifconfig is ip, which displays the same type of information,
    including routing details. Run ip addr to show all network interfaces and ip addr
    to show all network routes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ifconfig 的替代命令是 ip，它显示相同类型的信息，包括路由详情。运行 ip addr 显示所有网络接口，运行 ip route 显示所有网络路由。
- en: Try running these commands on the remaining boxes (*p-web-02* and *p-jumpbox-01*);
    you should notice that one of the boxes is connected to another internal network
    at the address 10.1.0.0/24\. This means one of the compromised hosts has a network
    leg into another network!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在其余的机器（*p-web-02* 和 *p-jumpbox-01*）上运行这些命令；你应该会注意到其中一台机器连接到了另一个内部网络，地址为 10.1.0.0/24。这意味着其中一台受损主机拥有进入另一个网络的网络接口！
- en: Connections and Neighbors
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接和邻居
- en: Networks are talkative; packets move in and out of systems continuously. Hosts
    that serve a purpose are rarely idle, and you can passively learn about their
    environment without sending network packets by simply collecting connection information.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是非常活跃的；数据包不断进出系统。提供服务的主机很少闲置，你可以通过收集连接信息，主动了解它们的环境，而无需发送网络数据包。
- en: 'Try collecting such information directly from the */proc* virtual filesystem
    by using the */proc/net/tcp* file:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试直接通过使用 */proc* 虚拟文件系统从 */proc/net/tcp* 文件收集这些信息：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output of this file is a *TCP socket table* in which each row represents
    a connection between two addresses: a local address (local_address) and a remote
    address (rem_address). The data is in hexadecimal, so we must once again convert
    it to decimal to understand the IP addresses and ports behind each connection:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的输出是一个 *TCP 套接字表*，每一行代表两个地址之间的连接：本地地址（local_address）和远程地址（rem_address）。数据是十六进制的，因此我们必须再次将其转换为十进制，以便理解每个连接背后的
    IP 地址和端口：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We use awk to print the second and third fields only, then pipe these to the
    tail -n +2 command to remove the table headers from the output. This table will
    grow as more connections are made between the compromised host and other clients
    and servers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 awk 只打印第二列和第三列，然后将其通过管道传递给 tail -n +2 命令，以去除输出中的表头。随着更多连接在受损主机与其他客户端和服务器之间建立，这个表格将会增长。
- en: 'You can also use Netstat to print network connections. Netstat prettifies the
    output of each connection and helps highlight which connections are currently
    active, which ones have timed out, and which PID and program name they are related
    to. Run the following command on *p-web-01* (172.16.10.10):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 Netstat 来打印网络连接。Netstat 美化了每个连接的输出，并帮助突出显示当前哪些连接是活动的，哪些已经超时，以及它们与哪个 PID
    和程序名称相关联。在 *p-web-01*（172.16.10.10）上运行以下命令：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let’s focus on the columns that are most valuable to us. The first column represents
    the protocol (for example, TCP or UDP), the fourth column is the local address
    and port, the fifth column is the *foreign address* (the remote address of the
    connection), and the sixth column is the program name and PID. Note that when
    Netstat is executed using a nonroot user, the PID column may not have information
    such as the PID and program name populated.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注对我们最有价值的列。第一列表示协议（例如，TCP 或 UDP），第四列是本地地址和端口，第五列是 *外部地址*（连接的远程地址），第六列是程序名称和
    PID。请注意，当 Netstat 以非 root 用户身份执行时，PID 列可能没有填充 PID 和程序名称等信息。
- en: 'When we executed the Netstat command, no connections were being made to the
    web application. Let’s simulate an incoming connection to see the socket table
    change. On your Kali host, run the following Netcat command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行 Netstat 命令时，没有连接到 web 应用程序。让我们模拟一个传入连接，看看套接字表如何变化。在你的 Kali 主机上，运行以下 Netcat
    命令：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, run the Netstat command we showed previously on the compromised *p-web-01*
    host (172.16.10.10):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在受损的 *p-web-01* 主机（172.16.10.10）上运行我们之前展示的 Netstat 命令：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, a new line was added to the connection table, representing the
    remote IP address of the client connecting on port 8081\. This remote address
    belongs to the host on which you ran Netcat (in this case, Kali).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，连接表中添加了一行，表示客户端通过 8081 端口连接时的远程 IP 地址。这个远程地址属于你运行 Netcat 的主机（在此案例中是 Kali）。
- en: Firewall Rules
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防火墙规则
- en: Host *firewall rules* are also a source of network information. A firewall table
    may include rules that block certain networks or individual IP addresses from
    communicating with the host. This information can teach us about other nearby
    networks, servers, or clients.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 主机的 *防火墙规则* 也是网络信息的来源。防火墙表可能包含一些规则，阻止某些网络或单个 IP 地址与主机通信。这些信息可以帮助我们了解其他邻近的网络、服务器或客户端。
- en: 'A common host firewall found on Linux servers is iptables. Let’s run the following
    iptables command to see the rules configured on *p-web-01* (172.16.10.10):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 服务器上常见的主机防火墙是 iptables。让我们运行以下 iptables 命令来查看 *p-web-01*（172.16.10.10）上的配置规则：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, a rule blocks the network 10.1.0.0/24 from connecting to the
    *p-web-01* box; this is another indication that an adjacent network at 10.1.0.0/24
    exists. Note that reading the rule table with the iptables command usually requires
    elevated permissions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一条规则阻止了网络 10.1.0.0/24 连接到 *p-web-01* 主机；这再次表明 10.1.0.0/24 网络是存在的。请注意，使用
    iptables 命令查看规则表通常需要提升权限。
- en: Network Interface Configuration Files
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络接口配置文件
- en: 'Network interfaces may have dedicated configuration files that, for example,
    configure a network IP address statically for a specific interface or ensure that
    a network card is enabled on boot by default. Linux distributions can place their
    network configurations in different places, but you’ll commonly find them in the
    following locations: */etc/network/interfaces*, */etc/network/interfaces.d/*,
    */etc/netplan/*, */lib/netplan/*, */run/netplan/*, and */etc/sysconfig/network-scripts/*.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 网络接口可能有专门的配置文件，例如，为特定接口静态配置网络 IP 地址，或确保网络卡默认在启动时启用。Linux 发行版可以将其网络配置放在不同的位置，但通常你会在以下位置找到它们：*/etc/network/interfaces*，*/etc/network/interfaces.d/*，*/etc/netplan/*，*/lib/netplan/*，*/run/netplan/*，以及
    */etc/sysconfig/network-scripts/*。
- en: 'If configured statically, network interfaces can shed light on the DNS servers
    in use. Network interfaces can also provide information such as the IP scheme,
    gateway addresses, and more. Here is a static network configuration file available
    in later versions of Ubuntu-based Linux systems:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是静态配置，网络接口可以揭示正在使用的 DNS 服务器。网络接口还可以提供诸如 IP 方案、网关地址等信息。以下是后续版本的基于 Ubuntu 的
    Linux 系统中的静态网络配置文件：
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This file configures the eth0 network interface with a default gateway of 172.16.10.1,
    as well as Google DNS servers 8.8.8.8 and 8.8.4.4.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件配置了 eth0 网络接口，默认网关为 172.16.10.1，并且配置了 Google DNS 服务器 8.8.8.8 和 8.8.4.4。
- en: Domain Resolvers
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 域名解析器
- en: Hosts are usually configured to use DNS to translate domain names, such as *example.com*,
    to IP addresses. DNS servers can be hosted locally on the network or in other
    places, such as public cloud instances. No matter where they’re running, they
    can be vulnerable.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 主机通常被配置为使用 DNS 将域名（如 *example.com*）转换为 IP 地址。DNS 服务器可以托管在本地网络中，也可以托管在其他地方，如公共云实例中。无论它们运行在哪里，都可能存在安全漏洞。
- en: 'You could find DNS server configurations in a few places on a Linux operating
    system, including in the */etc/resolv.conf* file using a nameserver entry, like
    so:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Linux 操作系统的多个位置找到 DNS 服务器的配置，包括在 */etc/resolv.conf* 文件中，使用 nameserver 条目，格式如下：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'DNS servers can also be configured within the */etc/hosts* configuration file,
    as shown here for *p-web-01* (172.16.10.10). This */etc/hosts* file may include
    a list of alternative networks and hosts you could target:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 服务器还可以在 */etc/hosts* 配置文件中进行配置，如此处为 *p-web-01*（172.16.10.10）所示。这个 */etc/hosts*
    文件可能包括一个你可以目标的其他网络和主机列表：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: DNS servers can also be configured in the individual network interface files,
    as discussed in the preceding section.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 服务器也可以在单独的网络接口文件中进行配置，如前一部分所讨论的。
- en: DNS servers can also be configured automatically by using a *Dynamic Host Configuration
    Protocol* server, a network service responsible for handing out network configurations
    dynamically, in which case the DNS server won’t be explicitly set in any configuration
    file.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 服务器还可以通过使用 *动态主机配置协议*（DHCP）服务器进行自动配置，DHCP 是一个负责动态分配网络配置的网络服务，在这种情况下，DNS
    服务器不会在任何配置文件中明确设置。
- en: Software Installations
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件安装
- en: Unmaintained operating system images tend to suffer from a wide variety of vulnerabilities,
    especially if they include many packages installed by default. We should investigate
    the software bundled with an operating system because it can lead us to interesting
    vulnerabilities that can help us escalate our privileges or obtain access to unauthorized
    information.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 维护不当的操作系统映像通常会受到各种漏洞的影响，特别是如果它们默认安装了许多软件包。我们应该调查与操作系统捆绑的软件，因为它可以引导我们发现有趣的漏洞，帮助我们提升权限或获取未经授权的信息。
- en: 'One way to investigate installed software is with a package manager. You’ll
    find a few types of package managers commonly available on Linux operating systems:
    Advanced Package Tool (APT) on systems such as Debian and Ubuntu, Yellowdog Updater
    Modified on systems such as Red Hat, CentOS, and Fedora, and Alpine Package Keeper
    on container-based operating systems such as Alpine Linux.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 调查已安装软件的一种方法是使用包管理器。您将在Linux操作系统上找到几种常用的包管理器：在Debian和Ubuntu等系统上是高级软件包工具（APT），在Red
    Hat、CentOS和Fedora等系统上是Yellowdog Updater Modified，以及在基于容器的操作系统（如Alpine Linux）上是Alpine
    Package Keeper。
- en: 'Try running the following apt command to list installed packages on any of
    the compromised hosts:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在任何受损主机上运行以下apt命令以列出已安装的软件包：
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can get a slightly nicer output by using dpkg instead. Note that this command
    is mostly found on Ubuntu- or Debian-based Linux systems:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 dpkg 获得稍微更好的输出。请注意，此命令主要在基于Ubuntu或Debian的Linux系统中找到：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To get a list of packages using other software managers, you could try any
    of the following commands:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用其他软件管理器获取软件包列表，您可以尝试以下任何一条命令：
- en: yum list installed
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: yum list installed
- en: apk list --installed
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: apk list --installed
- en: rpm -qa
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: rpm -qa
- en: 'We can use bash to parse these package lists and obtain the software’s name
    and version, as well as do some clever searches. To list only the package names,
    run this command:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 bash 解析这些软件包列表并获取软件的名称和版本，还可以进行一些聪明的搜索。要仅列出软件包名称，请运行此命令：
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Use the following to list only the package versions:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下内容仅列出软件包版本：
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'What if we want to search for a specific package and then print its version
    by using an exact match search? We can do so with awk:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想搜索特定软件包并通过精确匹配搜索打印其版本，该怎么办？我们可以使用awk来实现：
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We use an awk delimiter (-F) consisting of a forward slash and a space and surround
    it with square brackets [/] to define more than one delimiter. We then check whether
    the first field equals openssl; if it does, we print the third field, which is
    the version field.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个awk分隔符（-F），由斜杠和空格组成，并用方括号[/]括起来定义多个分隔符。然后检查第一个字段是否等于openssl；如果是，则打印第三个字段，即版本字段。
- en: 'We can even use awk to partially match package names:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用awk部分匹配软件包名称：
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To see the total number of installed packages, run apt list and pipe it to
    the wc (word count) command:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看安装的软件包总数，请运行 apt list 并将其管道传输到 wc（word count）命令：
- en: '[PRE43]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You could use these package names and versions as lookup queries on websites
    that source vulnerability data, such as the National Vulnerability Database (*[https://nvd.nist.gov](https://nvd.nist.gov)*)
    or the MITRE Common Vulnerabilities and Exposures (CVE) database (*[https://cve.mitre.org](https://cve.mitre.org)*).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这些软件包名称和版本作为查找漏洞数据来源的网站上的查询，例如国家漏洞数据库（*[https://nvd.nist.gov](https://nvd.nist.gov)*）或MITRE公共漏洞和暴露（CVE）数据库（*[https://cve.mitre.org](https://cve.mitre.org)*）。
- en: Note that the package manager might not list all software installed on a server.
    For example, a server could install Java directly from the source without using
    package management tools, in which case it won’t be shown in the package list.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，包管理器可能不会列出服务器上安装的所有软件。例如，服务器可能直接从源安装Java，而不使用包管理工具，在这种情况下，它不会显示在软件包列表中。
- en: Storage
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储
- en: From a security perspective, server storage is interesting for several reasons.
    Multiple servers could share the same storage system or use it to share files
    with end users. And if you can write into storage systems, you might be able to
    achieve code execution on adjacent servers if they source files, such as shell
    scripts, from the compromised storage system.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度看，服务器存储有几个有趣的原因。多个服务器可以共享同一存储系统或使用它与最终用户共享文件。如果您可以写入存储系统，则可能能够在相邻服务器上实现代码执行，如果它们从受损的存储系统中获取文件（例如shell脚本）。
- en: Server storage can be virtual or physical, and servers can run on a single local
    disk or multiple local disks. Servers can also use multiple disks to form a redundant
    array of inexpensive disks system, which provides improved redundancy and performance
    and can back up critical data.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器存储可以是虚拟的或物理的，服务器可以运行在单个本地磁盘或多个本地磁盘上。服务器还可以使用多个磁盘来形成冗余阵列的廉价磁盘系统，这可以提高冗余性和性能，并且能够备份关键数据。
- en: Linux systems can mount remote storage systems as local directories (usually
    under the */mnt* directory). These can act as an integral part of the operating
    system. You’ll see remote storage implemented using network-attached storage or
    storage area network devices and protocols like Network File System or Common
    Internet File System.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 系统可以将远程存储系统挂载为本地目录（通常在 */mnt* 目录下）。这些可以作为操作系统的重要组成部分。你将看到远程存储通过网络附加存储或存储区域网络设备和协议（如网络文件系统或公共互联网文件系统）实现。
- en: 'Remote storage is useful to investigate because systems can use it for a variety
    of purposes: as a data backup location, for centralized security logging, as a
    remote file share, or even to store remote user home folders. Application logs
    are often written to remote storage devices in a folder like */mnt/log_storage/*,
    which might be physically connected to a completely different server.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 远程存储非常有用，因为系统可以将其用于多种目的：作为数据备份位置、集中式安全日志存储、远程文件共享，甚至存储远程用户的主文件夹。应用程序日志通常写入到远程存储设备的
    */mnt/log_storage/* 文件夹中，该文件夹可能物理连接到完全不同的服务器。
- en: Let’s explore ways to identify disks, partitions, and mount points on a compromised
    host.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何在受损主机上识别磁盘、分区和挂载点。
- en: Block Devices
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 块设备
- en: 'First, let’s look at which block devices exist by using the command lsblk.
    *Block devices* are data storage devices such as CDs, floppy disks, and hard disks.
    The following output is from *p-web-01* (172.16.10.10):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用命令 lsblk 来查看存在哪些块设备。*块设备* 是数据存储设备，如光盘、软盘和硬盘。以下输出来自 *p-web-01*（172.16.10.10）：
- en: '[PRE44]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As you can see, we have two primary devices: sr0 and vda. The sr0 device is
    of type rom, and vda is of type disk. The other names you see on the list, such
    as vda1, vda2, and vda5, are all partitions of the vda disk. Run the same command
    against the remaining compromised machines you have access to and take note of
    the findings.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有两个主要设备：sr0 和 vda。sr0 设备是 ROM 类型，vda 设备是磁盘类型。你在列表中看到的其他名称，如 vda1、vda2
    和 vda5，都是 vda 磁盘的分区。对你可以访问的其余受损机器运行相同的命令，并记录下结果。
- en: 'Another way to view the list of partitions is by reading */proc/partitions*:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种查看分区列表的方法是读取 */proc/partitions*：
- en: '[PRE45]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The */proc* filesystem also exposes a file named */proc/mounts*, which provides
    a list of all mounts, their mount options, and additional attributes about the
    mount points:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*/proc* 文件系统还暴露了一个名为 */proc/mounts* 的文件，它提供了所有挂载点的列表、挂载选项以及挂载点的其他属性：'
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Alternatively, you could just call the mount command to get this information:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以直接调用 mount 命令来获取这些信息：
- en: '[PRE47]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A quick way to get a view of the various mounted filesystems is by using the
    df command, which will also indicate the available and total disk sizes of each
    filesystem:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 获取各种挂载文件系统视图的快速方法是使用 df 命令，该命令还会显示每个文件系统的可用和总磁盘大小：
- en: '[PRE48]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The -h and -T flags will print out a human-readable version of the output and
    the filesystem type, respectively.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: -h 和 -T 标志将分别输出人类可读的版本和文件系统类型。
- en: You may have noticed a mount point at */mnt/scripts* on *p-web-01* (172.16.10.10).
    Take note of this, as it will come in handy in later chapters.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到 *p-web-01*（172.16.10.10）上的挂载点 */mnt/scripts*。请记下这一点，因为它将在后续章节中派上用场。
- en: The Filesystem Tab File
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件系统标签文件
- en: The */etc/fstab* file is a static configuration file that controls the mounting
    of devices and partitions. Mounting devices and partitions without the necessary
    security measures can lead to filesystem-level vulnerabilities.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/fstab* 文件是一个静态配置文件，控制设备和分区的挂载。如果在没有必要的安全措施的情况下挂载设备和分区，可能会导致文件系统级的漏洞。'
- en: You can mount a device or partition at specific filesystem locations by using
    special options that control what can and cannot be done using the mount point.
    For example, you could configure a volume from a remote storage system to be mounted
    on */mnt/external_storage* upon system boot. You could also configure it to be
    a read-only filesystem, which wouldn’t allow writes, or remove execution options,
    so users won’t be able to run binaries from it.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用特殊选项将设备或分区挂载到特定的文件系统位置，这些选项控制在挂载点上可以或不能做什么。例如，你可以配置一个来自远程存储系统的卷，在系统启动时挂载到
    */mnt/external_storage* 上。你还可以将其配置为只读文件系统，这样就不允许写入，或者移除执行选项，以使用户无法从中运行二进制文件。
- en: 'Here are a few mount options that can be beneficial to know about as penetration
    testers:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是渗透测试人员可能需要了解的一些有用的挂载选项：
- en: dev Interprets special block devices, such as device files.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: dev 解释特殊块设备，例如设备文件。
- en: nodev The opposite of dev; will not interpret special block devices.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: nodev 与 dev 相反；不会解释特殊块设备。
- en: noexec Forbids the execution of binaries. Scripts such as bash will still be
    allowed.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: noexec 禁止执行二进制文件。像 bash 这样的脚本仍然允许执行。
- en: suid Allows the use of programs set with the setuid flag, which lets users execute
    a program by using the permissions of the file’s user or group owner.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: suid 允许使用设置了 setuid 标志的程序，用户可以使用文件的用户或组所有者的权限执行该程序。
- en: nosuid The opposite of the suid option; won’t allow the use of programs set
    with the setuid flag.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: nosuid 与 suid 选项相反；不允许使用设置了 setuid 标志的程序。
- en: exec Allows the execution of binaries and other types of files.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: exec 允许执行二进制文件和其他类型的文件。
- en: ro Forbids writing into the filesystem; in other words, creates a read-only
    filesystem.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ro 禁止写入文件系统；换句话说，创建只读文件系统。
- en: rw Allows writing into the filesystem as well as reading.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: rw 允许对文件系统进行读写操作。
- en: nosymfollow Restricts the following of symbolic links created on the filesystem.
    This option would still allow creating symbolic links.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: nosymfollow 限制跟踪文件系统上创建的符号链接。此选项仍然允许创建符号链接。
- en: 'defaults Uses the following mount options: rw, suid, dev, exec, and a few others.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: defaults 使用以下挂载选项：rw、suid、dev、exec 等。
- en: If you return to the mount command output shown previously, you’ll see what
    mount options are set on each mount point, if defined.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你返回到前面显示的挂载命令输出，你将看到每个挂载点上已设置的挂载选项（如果已定义）。
- en: Logs
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志
- en: Applications usually generate some sort of runtime output, and this output is
    sometimes written into logfiles. The content of these logfiles will vary depending
    on the application but generally indicates whether everything is working correctly
    or if an error has occurred.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常会生成某种类型的运行时输出，这些输出有时会写入日志文件。这些日志文件的内容会根据应用程序的不同而有所变化，但通常会指示一切是否正常工作，或者是否发生了错误。
- en: Certain logfiles are part of the Linux operating system, while others are related
    to third-party applications such as web servers and databases. Additionally, you
    might find custom application logs written by the company against which you’re
    performing a penetration test.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 某些日志文件是 Linux 操作系统的一部分，而其他则与第三方应用程序如 Web 服务器和数据库相关。此外，你还可能会找到由你进行渗透测试的公司编写的自定义应用程序日志。
- en: 'On Linux systems, both system and application logfiles are usually written
    to the */var/log* directory. Custom applications can write their logs anywhere
    but generally write them to files under the */var* directory too. Here is an example
    find command that can search for logfiles:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 系统上，系统和应用程序日志通常会写入到 */var/log* 目录。自定义应用程序可以将日志写入任何位置，但通常也会将其写入到 */var*
    目录下的文件中。以下是一个示例查找命令，可以用于搜索日志文件：
- en: '[PRE49]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This command finds files with the extensions *.log* and *.out*.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令用于查找扩展名为 *.log* 和 *.out* 的文件。
- en: System Logs
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统日志
- en: 'Here is a list of common system logs on Linux systems:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Linux 系统上常见的系统日志列表：
- en: '*/var/log/auth.log                     /var/log/faillog*'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*/var/log/auth.log                     /var/log/faillog*'
- en: '*/var/log/secure                       /var/log/lastlog*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*/var/log/secure                       /var/log/lastlog*'
- en: '*/var/log/audit/audit.log         /var/log/dpkg*'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*/var/log/audit/audit.log         /var/log/dpkg*'
- en: '*/var/log/dmesg                      /var/log/boot.log*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*/var/log/dmesg                      /var/log/boot.log*'
- en: '*/var/log/messages                 /var/log/cron*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*/var/log/messages                 /var/log/cron*'
- en: '*/var/log/syslog*'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*/var/log/syslog*'
- en: Of particular interest are files such as */var/log/auth.log*, */var/log/secure*,
    and */var/log/lastlog*, which are related to authentication and can contain juicy
    information regarding clients connecting to servers. The */var/log/audit/audit.log*
    file is used by auditing systems such as Auditd to log events such as command
    line activity, authentication attempts, and general system calls.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 特别感兴趣的是诸如*/var/log/auth.log*、*/var/log/secure*和*/var/log/lastlog*等文件，它们与认证有关，可能包含有关连接到服务器的客户端的重要信息。*/var/log/audit/audit.log*
    文件由审计系统如 Auditd 使用，用于记录命令行活动、认证尝试和一般系统调用等事件。
- en: Application Logs
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序日志
- en: Application logs can also contain interesting information for penetration testers.
    For example, if a server is running a website, the web engine may generate logs
    about clients connecting to it and the web paths they are requesting. This could
    reveal other clients and servers that are on the network.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序日志还可能包含对渗透测试人员有趣的信息。例如，如果服务器运行网站，则 Web 引擎可能会生成关于连接到其的客户端以及请求的 Web 路径的日志。这可能会显示出网络上其他客户端和服务器。
- en: Web servers like Apache and nginx usually write their logs to directories such
    as */var/log/apache2/*, */var/log/httpd/*, or */var/log/nginx/*. Other types of
    applications, such as proxies, email servers, printer servers, file transfer servers,
    relational databases, message queues, and cache databases, also produce logs you’ll
    want to look out for. [Table 8-3](chapter8.xhtml#tab8-3) lists the locations of
    common application logs you may run into.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Apache 和 nginx 这样的 Web 服务器通常将其日志写入*/var/log/apache2/*、*/var/log/httpd/*或*/var/log/nginx/*等目录。其他类型的应用程序，如代理、电子邮件服务器、打印服务器、文件传输服务器、关系数据库、消息队列和缓存数据库，也会生成您需要注意的日志。[表
    8-3](chapter8.xhtml#tab8-3) 列出了您可能遇到的常见应用程序日志的位置。
- en: 'Table 8-3: Log Locations'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '表 8-3: 日志位置'
- en: '| Log type | Logfiles |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| 日志类型 | 日志文件 |'
- en: '| --- | --- |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Web servers | /var/log/apache2/access.log /var/log/httpd/access.log'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '| Web 服务器 | /var/log/apache2/access.log /var/log/httpd/access.log'
- en: /var/log/nginx/access.log
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: /var/log/nginx/access.log
- en: /var/log/lighttpd/access.log |
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: /var/log/lighttpd/access.log |
- en: '| Databases | /var/log/mysql/mysql.log /var/log/postgresql'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '| 数据库 | /var/log/mysql/mysql.log /var/log/postgresql'
- en: /var/log/redis
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: /var/log/redis
- en: /var/log/mongodb/mongod.log
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: /var/log/mongodb/mongod.log
- en: /var/log/elasticsearch/elasticsearch.log |
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: /var/log/elasticsearch/elasticsearch.log |
- en: '| Printer servers | /var/log/cups |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 打印服务器 | /var/log/cups |'
- en: '| File transfer servers | /var/log/vsftpd /var/log/proftpd |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 文件传输服务器 | /var/log/vsftpd /var/log/proftpd |'
- en: '| Monitoring systems | /var/log/icinga2 /var/log/zabbix'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '| 监控系统 | /var/log/icinga2 /var/log/zabbix'
- en: /var/log/logstash
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: /var/log/logstash
- en: /var/log/nagios/nagios.log
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: /var/log/nagios/nagios.log
- en: /var/log/cacti |
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: /var/log/cacti |
- en: Note that some logs will require elevated privileges because of their sensitivity.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于其敏感性，一些日志将需要提升的权限。
- en: 'Exercise 13: Recursively Searching for Readable Logfiles'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '练习 13: 递归搜索可读取的日志文件'
- en: 'In this exercise, you’ll write a script that looks for logfiles. It should
    do the following:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在此练习中，您将编写一个查找日志文件的脚本。它应执行以下操作：
- en: 1.  Take a path as command line input. By default, it should use */var/log*
    if no argument is specified.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  接受路径作为命令行输入。如果未指定参数，默认应使用*/var/log*。
- en: 2.  Recursively walk through the path to find readable files.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  递归遍历路径以查找可读文件。
- en: 3.  Copy these files into a centralized directory of your choice.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  将这些文件复制到您选择的中心化目录中。
- en: 4.  Compress the folder by using the tar command.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  使用 tar 命令压缩文件夹。
- en: To aid your script writing, we recommend looking into the find command, which
    has many powerful built-in features that allow you to search by user and group
    ownership.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您编写脚本，我们建议您查看 find 命令，它具有许多强大的内置功能，可以按用户和组所有权进行搜索。
- en: You can find a full solution, *recursive_file_search.sh*, in the book’s GitHub
    repository.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在该书的 GitHub 仓库中找到一个完整的解决方案，*recursive_file_search.sh*。
- en: Kernels and Bootloaders
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核和引导加载程序
- en: The main component of operating systems such as Linux is called the *kernel*.
    The kernel is responsible for core functionalities such as process and memory
    management, drivers, security, and more. It is a highly complex piece of software
    and, as such, is prone to vulnerabilities. One example of a kernel exploit is
    the *Dirty COW vulnerability* (CVE-2016-5195), which allowed remote execution
    and the ability to obtain root access without leaving system traces.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统如 Linux 的主要组件称为*内核*。内核负责核心功能，如进程和内存管理、驱动程序、安全性等。它是一个非常复杂的软件组件，因此容易受到漏洞的影响。一个内核漏洞的例子是*Dirty
    COW 漏洞*（CVE-2016-5195），它允许远程执行并获得 root 访问权限而不留下系统痕迹。
- en: 'Discovering the version of the kernel running on a system may allow you to
    escalate privileges with kernel exploits. To check the kernel version, use the
    following command:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 发现系统上运行的内核版本可能帮助你通过内核漏洞提升权限。要检查内核版本，请使用以下命令：
- en: '[PRE50]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As the lab machines are based on Docker, they share the host’s (Kali’s) kernel,
    and running uname will print Kali’s kernel version.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实验室机器基于 Docker，它们共享主机（Kali）的内核，运行 `uname` 命令将会显示 Kali 的内核版本。
- en: 'A Linux system could have more than one kernel version installed to allow for
    rollbacks in cases of system failure. Kernel files are located under the */boot*
    directory. You can also find out which kernels are installed by running either
    of the following commands:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Linux 系统可能会安装多个内核版本，以便在系统故障时进行回滚。内核文件位于 */boot* 目录下。你还可以通过运行以下命令来查看安装了哪些内核：
- en: '[PRE51]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Make sure to use the correct package manager command for the host system.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 确保使用正确的包管理器命令来适应主机系统。
- en: Unstable kernel exploits are dangerous to run and can crash and take down a
    server if they aren’t tested properly. We recommend obtaining explicit authorization
    before attempting to run these types of exploits.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 不稳定的内核漏洞利用程序非常危险，如果没有经过充分测试，它们可能会导致服务器崩溃。我们建议在尝试运行这些类型的漏洞时，先获得明确的授权。
- en: Configuration Files
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置文件
- en: We’ve already highlighted a few types of configuration files in this chapter.
    Though these files are highly application dependent, they can often include sensitive
    data. During local reconnaissance, you’ll want to go after them, especially those
    that are related to web applications, which generally rely on many services as
    part of their normal operations. The web applications need to connect to these
    services, usually with some form of authentication, so you’ll probably find credentials
    nearby.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经提到了几种类型的配置文件。虽然这些文件高度依赖于具体的应用程序，但它们通常包含敏感数据。在本地侦察过程中，你需要特别关注它们，尤其是那些与
    Web 应用程序相关的文件，因为 Web 应用程序通常依赖许多服务来完成日常操作。Web 应用程序需要连接这些服务，通常需要某种形式的身份验证，因此你可能会在附近找到凭据。
- en: 'Configuration files primarily live under the */etc* directory and may or may
    not have an associated file extension, such as **.conf*, **.cfg*, **.ini **, *.cnf*,
    and **.cf*. You might also find configuration files under users’ hidden directories,
    such as */home/user/.config/* or */home/user/.local*. To perform a wide search
    for configuration files, use this command:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件通常位于 */etc* 目录下，可能有也可能没有关联的文件扩展名，如 **.conf**、**.cfg**、**.ini**、*.cnf* 和
    **.cf**。你也可能会在用户的隐藏目录下找到配置文件，例如 */home/user/.config/* 或 */home/user/.local*。要执行广泛的配置文件搜索，可以使用以下命令：
- en: '[PRE52]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To search a specific folder, change the find / portion of the command to another
    directory, such as find /etc. You can even chain multiple directories together,
    like so:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索特定文件夹，可以将命令中的 `find /` 部分更改为另一个目录，例如 `find /etc`。你甚至可以将多个目录连接在一起，如下所示：
- en: '[PRE53]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Third-party software also tends to include custom configuration that can be
    interesting. For example, WordPress usually uses a database for storing blog-related
    data, and its config file, *wp-config.php*, usually contains credentials related
    to databases such as MySQL:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方软件通常也会包含自定义的配置，这可能很有趣。例如，WordPress 通常使用数据库来存储与博客相关的数据，其配置文件 *wp-config.php*
    通常包含与数据库（如 MySQL）相关的凭据信息：
- en: '[PRE54]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The location of this file depends on where WordPress was installed because
    it usually resides within the application’s root directory, such as */var/www/html/wp-config.php*.
    As you can see, it has a.*php* extension, because WordPress is written in the
    PHP language. The search we used earlier wouldn’t have caught this file, but we
    can tweak our command to search for files with the word *config* in them:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件的位置取决于 WordPress 的安装位置，因为它通常位于应用程序的根目录下，例如 */var/www/html/wp-config.php*。正如你所看到的，它有一个
    .*php* 扩展名，因为 WordPress 是用 PHP 语言编写的。我们之前使用的搜索方法不会捕捉到这个文件，但我们可以调整命令，搜索包含 *config*
    的文件：
- en: '[PRE55]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We already know that the *p-web-02* server (172.16.10.12) runs WordPress; can
    you find its configuration file? Hint: it lives alongside the application in the
    web root directory.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道 *p-web-02* 服务器（172.16.10.12）运行着 WordPress；你能找到它的配置文件吗？提示：它与应用程序一起位于 Web
    根目录下。
- en: Being aware of common configuration files and their locations helps when you
    identify services of interest that are running on the host. [Table 8-4](chapter8.xhtml#tab8-4)
    lists some examples.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 了解常见的配置文件及其位置对于识别主机上正在运行的感兴趣服务很有帮助。[表 8-4](chapter8.xhtml#tab8-4) 列出了几个示例。
- en: 'Table 8-4: Common Configuration File Locations'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-4：常见配置文件位置
- en: '| Server type | File location |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| 服务器类型 | 文件位置 |'
- en: '| --- | --- |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Web servers | /etc/httpd/httpd.conf /etc/httpd/conf/httpd.conf'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '| Web 服务器 | /etc/httpd/httpd.conf /etc/httpd/conf/httpd.conf'
- en: /etc/apache2/apach2.conf
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: /etc/apache2/apach2.conf
- en: /etc/lighttpd/lighttpd.conf
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: /etc/lighttpd/lighttpd.conf
- en: /etc/nginx/nginx.conf |
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: /etc/nginx/nginx.conf |
- en: '| File-sharing and file-transfer servers | /etc/vsftpd/vsftpd.conf /etc/protftpd.conf
    /usr/local'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '| 文件共享和文件传输服务器 | /etc/vsftpd/vsftpd.conf /etc/protftpd.conf /usr/local'
- en: /etc/proftpd.conf
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: /etc/proftpd.conf
- en: /etc/samba/smb.conf |
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: /etc/samba/smb.conf |
- en: '| Databases | /etc/mysql/my.cnf /etc/my.cnf'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '| 数据库 | /etc/mysql/my.cnf /etc/my.cnf'
- en: /etc/redis/redis.conf
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: /etc/redis/redis.conf
- en: /etc/mongo.conf
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: /etc/mongo.conf
- en: /etc/cassandra |
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: /etc/cassandra |
- en: '| Domain name servers | /etc/bind/named.conf /etc/dnsmasq.conf |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| 域名服务器 | /etc/bind/named.conf /etc/dnsmasq.conf |'
- en: '| Mail servers | /etc/postfix/main.cf /etc/mail/sendmail.cf'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '| 邮件服务器 | /etc/postfix/main.cf /etc/mail/sendmail.cf'
- en: /etc/dovecot/dovecot.conf |
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: /etc/dovecot/dovecot.conf |
- en: '| Virtual private network servers | /etc/openvpn /etc/ipsec.conf |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| 虚拟专用网络服务器 | /etc/openvpn /etc/ipsec.conf |'
- en: This table isn’t comprehensive, but it should give you an idea of where popular
    network servers commonly store their configurations.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格并不全面，但它应该能让你了解常见的网络服务器通常将其配置文件存储在哪里。
- en: Scheduled Tasks
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定时任务
- en: '*Scheduled tasks* allow you to specify a command or script for the system to
    run automatically at a specified interval. They’re interesting from a penetration-testing
    standpoint because they can often be written in a way that allows for privilege
    escalation conditions.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '*定时任务* 允许你为系统指定一个命令或脚本，系统将在指定的时间间隔自动运行。它们在渗透测试中非常有趣，因为它们经常以可以引发权限提升的方式编写。'
- en: For example, a task could read and execute instructions from world-writable
    files, and if a malicious user is able to write malicious instructions into them,
    the system might execute them with elevated privileges. A user could then take
    malicious actions, such as creating a privileged user, changing the folder permissions
    of a protected folder like */root*, adding permissions to the existing user, starting
    custom malicious processes, and deleting or overwriting sensitive information
    in files.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个任务可能会读取并执行来自全局可写文件的指令，如果恶意用户能够将恶意指令写入这些文件，系统可能会以提升的权限执行它们。用户可能会采取恶意行为，例如创建特权用户、修改类似
    */root* 这样的受保护文件夹的权限、为现有用户添加权限、启动自定义恶意进程，或删除或覆盖文件中的敏感信息。
- en: 'On Linux, we have two common mechanisms for scheduling tasks: Cron and At.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，我们有两种常见的任务调度机制：Cron 和 At。
- en: Cron
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cron
- en: Let’s write a small script that creates a file and appends the current date
    and time to it ([Listing 8-11](chapter8.xhtml#Lis8-11)).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个小脚本，它创建一个文件并将当前的日期和时间附加到该文件中（[清单 8-11](chapter8.xhtml#Lis8-11)）。
- en: '[PRE56]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Listing 8-11: A simple cron job'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-11：一个简单的 Cron 任务
- en: Save this file and give it the name *cron_task.sh*. Make sure it is executable
    by using chmod u+x cron_task.sh.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 保存该文件并命名为 *cron_task.sh*。确保它是可执行的，使用 chmod u+x cron_task.sh 命令。
- en: 'Next, we’ll use Cron to run this script every minute. Run the following to
    open a text editor:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 Cron 每分钟运行该脚本。运行以下命令以打开文本编辑器：
- en: '[PRE57]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now append the following to the end of the */etc/crontab* file and save it.
    Make sure you change the path to the place where you saved your script:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将以下内容附加到 */etc/crontab* 文件的末尾并保存。确保你更改路径为你保存脚本的位置：
- en: '[PRE58]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You may be asking yourself what those five asterisks (*) are all about. Cron
    has special syntax to describe its execution schedule. The format is as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么有五个星号（*）呢？Cron 有一种特殊的语法来描述它的执行计划。其格式如下：
- en: '[PRE59]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'For instance, the following syntax describes an echo task that will run every
    day at 11:30 PM:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下语法描述了一个回显任务，它将在每天晚上 11:30 执行：
- en: '[PRE60]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The Cron process should execute the script. To make sure it worked, run ls
    in the */tmp* folder. You should see the file */tmp/my_scheduled_job* containing
    updates about the time:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Cron 进程应该执行该脚本。为了确认它是否生效，可以在 */tmp* 文件夹中运行 ls。你应该会看到 */tmp/my_scheduled_job*
    文件，其中包含关于时间的更新：
- en: '[PRE61]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the context of penetration testing, cron jobs can be insecure. For example,
    a task may copy sensitive files to paths that are world-readable, allowing untrusted
    local users to obtain access to them. Here is an example of a backup job that
    is very insecure if it runs with the context of the *root* user:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试的背景下，Cron 任务可能不安全。例如，一个任务可能会将敏感文件复制到全局可读的路径，这样不信任的本地用户就可以访问这些文件。以下是一个备份任务的示例，如果它以
    *root* 用户身份运行，则非常不安全：
- en: '[PRE62]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Cron jobs like this will copy the sensitive directories */etc* and */var* to
    the */home* directory. Since the */home* directory is accessible to all local
    users, anyone with read access can copy this file or view it.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的 Cron 作业将会把敏感目录 */etc* 和 */var* 复制到 */home* 目录中。由于 */home* 目录对所有本地用户可访问，任何具有读取权限的用户都可以复制或查看这些文件。
- en: '[Table 8-5](chapter8.xhtml#tab8-5) lists additional files that Cron uses for
    its runtime.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-5](chapter8.xhtml#tab8-5) 列出了 Cron 在运行时使用的其他文件。'
- en: 'Table 8-5: Cron Files'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '表 8-5: Cron 文件'
- en: '| Purpose | Files |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| 目的 | 文件 |'
- en: '| --- | --- |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Cron logs | /var/spool/cron /var/spool/cron/crontab |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| Cron 日志 | /var/spool/cron /var/spool/cron/crontab |'
- en: '| Job configuration | /etc/crontab /etc/cron.d'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '| 作业配置 | /etc/crontab /etc/cron.d |'
- en: /etc/cron.hourly
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: /etc/cron.hourly
- en: /etc/cron.daily
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: /etc/cron.daily
- en: /etc/cron.weekly
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: /etc/cron.weekly
- en: /etc/cron.monthly |
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: /etc/cron.monthly |
- en: '| Cron security | /etc/cron.deny /etc/cron.allow |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| Cron 安全 | /etc/cron.deny /etc/cron.allow |'
- en: A user’s cron jobs are usually stored in */var/spool/cron/crontab/USER*, and
    system-wide cron jobs are defined at */etc/crontab*. Directories such as */etc/cron.hourly*,
    */etc/cron.daily*, */etc/cron.weekly*, and */etc/cron.monthly* contain shell scripts
    executed by the Cron process, and the */etc/crontab* file defines the intervals
    at which scripts in these directories are executed.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的 cron 作业通常存储在 */var/spool/cron/crontab/USER* 中，系统范围的 cron 作业定义在 */etc/crontab*
    中。像 */etc/cron.hourly*、*/etc/cron.daily*、*/etc/cron.weekly* 和 */etc/cron.monthly*
    这样的目录包含由 Cron 进程执行的 shell 脚本，而 */etc/crontab* 文件定义了这些目录中的脚本执行的时间间隔。
- en: 'System administrators can restrict users from creating cron jobs. Two access
    control files define who can run the crontab command: */etc/cron.allow* and */etc/cron.deny*.
    If the */etc/cron.allow* file exists, users listed in this file will be able to
    schedule tasks with Cron. If it doesn’t exist, all users can schedule tasks except
    for any user listed in */etc/cron.deny*. If neither file exists, only privileged
    users can schedule tasks. If a user is listed in both the allow and deny files,
    the user will still be able to schedule tasks.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员可以限制用户创建 cron 作业。两个访问控制文件定义了谁可以运行 crontab 命令：*/etc/cron.allow* 和 */etc/cron.deny*。如果
    */etc/cron.allow* 文件存在，列在该文件中的用户将能够使用 Cron 调度任务。如果该文件不存在，除非在 */etc/cron.deny*
    中列出，否则所有用户都可以调度任务。如果两个文件都不存在，只有特权用户可以调度任务。如果一个用户同时出现在允许和拒绝文件中，该用户仍然可以调度任务。
- en: At
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: At
- en: '*At* is another job-scheduling tool in Linux, though it’s less common than
    Cron and uses a simpler approach. It works by specifying the shell command in
    the at prompt or piping the command to at as standard input by using |. The following
    example uses the at prompt to schedule a task:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '*At* 是 Linux 中的另一种作业调度工具，尽管它比 Cron 少见，且采用更简单的方式。它通过在 at 提示符中指定 shell 命令，或通过使用
    | 将命令作为标准输入传递给 at 来工作。以下示例使用 at 提示符安排一个任务：'
- en: '[PRE63]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We start by specifying the schedule, using now + 1 minute to tell At to run
    commands one minute from now. At also takes in schedule syntax in additional formats.
    Here are a few examples of schedule definitions:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先指定调度，使用 now + 1 minute 告诉 At 在 1 分钟后运行命令。At 还支持其他格式的调度语法。以下是一些调度定义的示例：
- en: '[PRE64]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The first example schedules commands to run at 10 PM in military time. The second
    example runs at 11 PM three days from today. The third example runs commands tomorrow
    at the current time, and the fourth on Sunday at the current time. The final example
    runs on May 27, 2050.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例安排命令在军用时间晚上 10 点运行。第二个示例安排在三天后的晚上 11 点运行。第三个示例安排在明天的当前时间运行，第四个示例安排在周日的当前时间运行。最后一个示例安排在
    2050 年 5 月 27 日运行。
- en: After specifying the time, At will drop your shell into a dedicated command
    prompt (at>), where you can enter shell commands line by line. To save the job,
    use CTRL-D.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 指定时间后，At 会将您的 shell 提示符切换到专用的命令行（at>），您可以逐行输入 shell 命令。要保存作业，使用 CTRL-D。
- en: 'The at command also provides a way to see the queue of jobs (by using atq)
    and remove them (by using atrm). To list all queued At jobs, run the following
    command:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: at 命令还提供了一种查看作业队列的方式（使用 atq）以及移除作业的方式（使用 atrm）。要列出所有排队的 At 作业，运行以下命令：
- en: '[PRE65]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Each job has an ID (1 and 2 in this case), the time at which they will execute,
    and the user who scheduled it. After a job is submitted, you can generally find
    the job definition located under */var/spool/cron/atjobs*:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 每个作业都有一个 ID（此例中为 1 和 2），它们的执行时间和调度该作业的用户。在提交作业后，您通常可以在 */var/spool/cron/atjobs*
    下找到作业定义：
- en: '[PRE66]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: By default, unprivileged users cannot read this directory. Other possible At
    job directories include */var/spool/cron/atspool*, */var/spool/at*, and */var/spool/
    at/spool*.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，普通用户无法读取此目录。其他可能的 At 作业目录包括 */var/spool/cron/atspool*、*/var/spool/at*
    和 */var/spool/at/spool*。  '
- en: 'You can remove queued jobs by using atrm followed by the job ID:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以使用 `atrm` 命令后跟作业 ID 来删除排队的作业：  '
- en: '[PRE67]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Like Cron, At uses deny (*/etc/at.deny*) and allow (*/etc/at.allow*) files to
    determine which users can schedule jobs.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '和 Cron 一样，At 使用 deny（*/etc/at.deny*）和 allow（*/etc/at.allow*）文件来确定哪些用户可以调度作业。  '
- en: 'Exercise 14: Writing a Cron Job Script to Find Credentials'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '练习 14：编写 Cron 作业脚本以查找凭据  '
- en: 'The objective of this exercise is to write a monitoring cron job script. This
    script should periodically search the system for files containing credentials.
    Create a cron job to do the following:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '这项练习的目标是编写一个监控 cron 作业脚本。这个脚本应该定期搜索系统中的文件，查找包含凭据的文件。创建一个 cron 作业来执行以下操作：  '
- en: 1.  Run every 10 minutes, every day of the week, all year.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '1. 每 10 分钟运行一次，每周每天，全年无休。  '
- en: 2.  Look for files containing the words *username* or *password* under the */tmp*
    directory.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '2. 在 */tmp* 目录下查找包含 *username* 或 *password* 字样的文件。  '
- en: 3.  When such a file is found, run grep on the line containing the strings to
    write only the strings to a writable location of your choice.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '3. 当找到这样的文件时，运行 grep 命令查找包含字符串的行，并将这些字符串写入你选择的可写位置。  '
- en: To test your script, you can create a fake file containing the string username=administrator
    or password=12345 and save it into the */tmp* directory. If your cron job is working
    as expected, you should be able to see these two strings in the destination directory.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '要测试你的脚本，你可以创建一个包含字符串 `username=administrator` 或 `password=12345` 的假文件，并将其保存到
    */tmp* 目录。如果你的 cron 作业按预期工作，你应该能够在目标目录中看到这两个字符串。  '
- en: Hardware
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '硬件  '
- en: You can collect hardware-related information, such as memory allocation details,
    the number of CPUs and cores, and the manufacturer of hardware components such
    as the motherboard, network card, and other peripherals. To collect these details,
    you use commands such as lshw, dmidecode, and hwinfo.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以收集与硬件相关的信息，例如内存分配详情、CPU 和核心数量，以及硬件组件的制造商，例如主板、网卡和其他外设。要收集这些信息，你可以使用如 lshw、dmidecode
    和 hwinfo 等命令。  '
- en: These commands may show only partial information when run using a nonprivileged
    user, because they often read from system files accessible only to the *root*
    user. They also may not necessarily be installed by default, so you might have
    to manually gather hardware information by looking at specific files and directories
    under */proc*, */dev*, and */sys*.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '这些命令在使用非特权用户运行时可能只显示部分信息，因为它们通常从仅 *root* 用户可访问的系统文件中读取。它们也可能不是默认安装的，因此你可能需要手动通过查看
    */proc*、*/dev* 和 */sys* 下的特定文件和目录来收集硬件信息。  '
- en: 'Let’s take a look at the output we get by running lshw on one of the lab machines,
    such as *p-web-01* (172.16.10.10):'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们来看一下在其中一台实验室机器上运行 lshw 命令时得到的输出，例如 *p-web-01*（172.16.10.10）：  '
- en: '[PRE68]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Remember that our lab is virtual, so the output may not accurately report the
    underlying physical hardware, such as the size of the memory, motherboard vendor,
    and sound card.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '请记住，我们的实验室是虚拟的，因此输出可能无法准确报告底层物理硬件的信息，如内存大小、主板厂商和声卡。  '
- en: 'The lshw command takes a -class (-C) argument, which allows you to view specific
    classes of hardware, such as disk (-C disk), processor (-C cpu), and network (-C
    network):'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 'lshw 命令带有一个 -class (-C) 参数，允许你查看特定类别的硬件，例如磁盘（-C disk）、处理器（-C cpu）和网络（-C network）：  '
- en: '[PRE69]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In this disk example, you can see that the vendor name is VirtualBox, which
    hints that we ran this command in a virtual machine.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个磁盘示例中，你可以看到厂商名称是 VirtualBox，这暗示我们在虚拟机中运行了这个命令。  '
- en: Hardware utilities gather information from various files. [Table 8-6](chapter8.xhtml#tab8-6)
    compiles some of the files and directories from which these tools aggregate hardware
    information.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '硬件实用工具从各种文件中收集信息。[表 8-6](chapter8.xhtml#tab8-6) 汇总了这些工具从中聚合硬件信息的一些文件和目录。  '
- en: 'Table 8-6: Hardware Information Locations in the Filesystem'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '表 8-6：文件系统中的硬件信息位置  '
- en: '| Virtual filesystem | Files and directories |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| 虚拟文件系统 | 文件和目录 |  '
- en: '| --- | --- |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |  '
- en: '| /proc | /proc/bus/usb/devices /proc/dma'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '| /proc | /proc/bus/usb/devices /proc/dma  '
- en: /proc/interrupts
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '/proc/interrupts  '
- en: /proc/partitions
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '/proc/partitions  '
- en: /proc/modules
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '/proc/modules  '
- en: /proc/cpuinfo
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '/proc/cpuinfo  '
- en: /proc/devices-tree
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '/proc/devices-tree  '
- en: /proc/devices
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '/proc/devices  '
- en: /proc/efi/systab
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: /proc/efi/systab
- en: /proc/ide
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '/proc/ide  '
- en: /proc/kcore
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '/proc/kcore  '
- en: /proc/mounts
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '/proc/mounts  '
- en: /proc/net/dev
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '/proc/net/dev  '
- en: /proc/scsi
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '/proc/scsi  '
- en: /proc/sys
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '/proc/sys  '
- en: /proc/sys/abi
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '/proc/sys/abi  '
- en: /proc/sys/dev/sensors |
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '/proc/sys/dev/sensors |  '
- en: '| /sys | /sys/bus /sys/class'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '| /sys | /sys/bus /sys/class'
- en: /sys/devices
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: /sys/devices
- en: /sys/firmware
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: /sys/firmware
- en: /sys/firmware/dmi/tables/DMI |
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: /sys/firmware/dmi/tables/DMI |
- en: '| /dev | /dev/cdrom /dev/input'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '| /dev | /dev/cdrom /dev/input'
- en: /dev/fb*
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: /dev/fb*
- en: /dev/machines
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: /dev/machines
- en: /dev/snd
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: /dev/snd
- en: /dev/mem
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: /dev/mem
- en: /dev/scsi* |
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: /dev/scsi* |
- en: Virtualization
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟化
- en: Administrators could install an operating system directly on a physical server
    or run a hypervisor (such as VirtualBox, Microsoft Hyper-V, or VMware ESXi) to
    host multiple virtual machines on the same hardware. Alternatively, they might
    use containerization technology to run virtual servers as containers.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员可以直接在物理服务器上安装操作系统，或者运行一个虚拟化程序（如 VirtualBox、Microsoft Hyper-V 或 VMware ESXi）在同一硬件上托管多个虚拟机。或者，他们可能使用容器技术将虚拟服务器作为容器运行。
- en: Determining whether an environment is virtual or physical is often important
    in the context of defense evasion. For example, malicious software often implements
    checks for virtual environments so they can evade reverse engineering attempts,
    since analysts often examine malware in such virtual environments.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 确定一个环境是虚拟的还是物理的，通常在防御规避的背景下很重要。例如，恶意软件常常会检查虚拟环境，以便规避逆向工程的尝试，因为分析人员通常会在这种虚拟环境中分析恶意软件。
- en: As in previous scenarios, we can use dedicated tools as well as living-off-the-land
    approaches to find this information. We’ll explore both options.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前的场景一样，我们可以使用专用工具以及“利用现有资源”方法来获取这些信息。我们将探索这两种方法。
- en: Using Dedicated Tools
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用专用工具
- en: 'Tools such as virt-who and virt-what can examine a system to determine whether
    it is physical or virtual. Here is the output of virt-what when run on Kali in
    VirtualBox:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 像 virt-who 和 virt-what 这样的工具可以检查系统，以确定它是物理系统还是虚拟系统。以下是 virt-what 在 VirtualBox
    上的 Kali 系统中的输出结果：
- en: '[PRE70]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Another useful tool, systemd-detect-virt, offers a comprehensive list of enumeration
    techniques to identify virtual environments for systemd-based systems. It can
    fingerprint numerous hypervisors and container runtime environments, a list of
    which you can find here: *[https://www.freedesktop.org/software/systemd/man/systemd-detect-virt.html](https://www.freedesktop.org/software/systemd/man/systemd-detect-virt.html)*.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的工具 systemd-detect-virt 提供了一份详尽的虚拟环境枚举技术列表，用于 systemd 系统。它能够识别多个虚拟机监控程序和容器运行环境，您可以在这里找到相关列表：*[https://www.freedesktop.org/software/systemd/man/systemd-detect-virt.html](https://www.freedesktop.org/software/systemd/man/systemd-detect-virt.html)*。
- en: 'Try running systemd-detect-virt on any of the lab machines to see the output:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在实验室的任意一台机器上运行 systemd-detect-virt 查看输出结果：
- en: '[PRE71]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Using the dmesg command, you can also read virtualization information from
    the kernel ring buffer log:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 dmesg 命令，您还可以从内核环形缓冲日志中读取虚拟化信息：
- en: '[PRE72]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In this example, oracle is the virtualization software, as we’re running VirtualBox,
    which is developed and maintained by Oracle.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，oracle 是虚拟化软件，因为我们正在运行由 Oracle 开发和维护的 VirtualBox。
- en: Living Off the Land
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用现有资源
- en: Let’s highlight a few of the ways we can determine whether a system is running
    virtually.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们强调几种可以确定系统是否在虚拟环境中运行的方式。
- en: 'The Desktop Management Interface (DMI) is a management and tracking framework
    for hardware and software in a system. Under the */sys/class/dmi/id* directory,
    a few files related to DMI could give away information about the various virtualization
    vendors. These files include *product_name*, *sys_vendor*, *board_vendor*, *bios_vendor*,
    and *product_version*. Take a look at their contents:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面管理接口（DMI）是一个用于系统硬件和软件管理跟踪的框架。在*/sys/class/dmi/id*目录下，一些与 DMI 相关的文件可能会泄露有关各种虚拟化供应商的信息。这些文件包括*product_name*、*sys_vendor*、*board_vendor*、*bios_vendor*和*product_version*。查看它们的内容：
- en: '[PRE73]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The file */sys/hypervisor/type* might also hint at the underlying hypervisor.
    For example, The Xen hypervisor might insert the value xen in that file, whereas
    Microsoft Hyper-V would use Hyper-V.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*/sys/hypervisor/type*也可能暗示底层的虚拟化程序。例如，Xen 虚拟化程序可能会在该文件中插入值 xen，而 Microsoft
    Hyper-V 则会使用 Hyper-V。
- en: Another file, accessible only to the *root* user, */proc/1/environ*, may contain
    an environment variable named container= with relevant information. For example,
    Linux containers may use container=lxc, while Podman containers may use container=podman.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个只有*root*用户可以访问的文件，*/proc/1/environ*，可能包含一个名为 container= 的环境变量，其中包含相关信息。例如，Linux
    容器可能会使用 container=lxc，而 Podman 容器可能会使用 container=podman。
- en: 'Some container technologies, including Podman and Docker, use *env* files placed
    in specific locations. The existence of either of these would indicate a container
    environment:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 一些容器技术，包括 Podman 和 Docker，使用放置在特定位置的*env*文件。任何一个文件的存在都表明这是一个容器环境：
- en: '*/run/.containerenv*'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '*/run/.containerenv*'
- en: '*/.dockerenv*'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '*/.dockerenv*'
- en: 'On systemd systems, the */run/systemd/container* file may exist:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在 systemd 系统上，可能存在 */run/systemd/container* 文件：
- en: '[PRE74]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Try running this command in any of the lab machines you have access to.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在你能访问的任何实验机上运行此命令。
- en: Automating Information Gathering with LinEnum
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 LinEnum 自动化信息收集
- en: By now, you should realize that valuable information can live anywhere on the
    operating system. To efficiently cover certain base areas, including users and
    groups, cron jobs, processes, and so on, we can run information-gathering scripts,
    which rely on the predictability of file locations and common search patterns.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在，你应该已经意识到，操作系统上任何地方都可能存在有价值的信息。为了高效地覆盖某些基础领域，包括用户和组、cron 任务、进程等，我们可以运行信息收集脚本，这些脚本依赖于文件位置的可预测性和常见的搜索模式。
- en: '*LinEnum* is a local information-gathering shell script used to automatically
    gather data from a host. It covers collection areas such as system information,
    user information, services and processes, versions, and privileges.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '*LinEnum* 是一个本地信息收集的 shell 脚本，用于自动从主机收集数据。它覆盖了系统信息、用户信息、服务和进程、版本和权限等收集领域。'
- en: Let’s use LinEnum to collect files locally in an automated fashion. First, we
    need to get LinEnum onto the compromised machine. As it’s a single shell script
    file, we can simply copy and paste it into a new file on the machine. Copy the
    content of */home/kali/tools/LinEnum.sh* and save the file as *LinEnum.sh* on
    the compromised machines.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 LinEnum 以自动化方式在本地收集文件。首先，我们需要将 LinEnum 放到被攻破的机器上。由于它是一个单一的 shell 脚本文件，我们可以简单地将其复制并粘贴到机器上的新文件中。复制
    */home/kali/tools/LinEnum.sh* 的内容，并将该文件保存为 *LinEnum.sh*，然后放到被攻破的机器上。
- en: 'Now run LinEnum with -t (thorough collection) and -r (report) to specify a
    file to send the output to:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行 LinEnum 时，使用 -t（彻底收集）和 -r（报告）选项来指定一个文件，将输出发送到该文件：
- en: '[PRE75]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Read through the findings to see the kind of information that was collected.
    In the following exercise, you’ll read LinEnum’s code, build new functionality,
    and tailor it to your needs.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读收集到的结果，以查看收集了哪些信息。在接下来的练习中，你将阅读 LinEnum 的代码，构建新功能，并根据自己的需求进行定制。
- en: 'Exercise 15: Adding Custom Functionality to LinEnum'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 15：为 LinEnum 添加自定义功能
- en: During penetration testing, you may find yourself repurposing proof-of-concept
    exploit code and scripts to suit a particular use case. This is an important skill
    to master because if you can avoid writing scripts from scratch, you can save
    a lot of time.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试过程中，你可能会发现自己需要重新使用概念验证漏洞代码和脚本来适应特定的用例。这是一个非常重要的技能，因为如果你能避免从头编写脚本，就能节省大量时间。
- en: 'In this exercise, your goal is to modify the LinEnum source code to build new
    features into it:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，你的目标是修改 LinEnum 的源代码，为其添加新功能：
- en: 1.  Carefully read the LinEnum script’s source code. While it contains roughly
    1,300 lines, it should be pretty simple to understand because it follows a consistent
    pattern, such as executing commands and then saving the output to variables.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  仔细阅读 LinEnum 脚本的源代码。虽然它大约包含 1300 行代码，但应该相对容易理解，因为它遵循一致的模式，例如执行命令并将输出保存到变量中。
- en: 2.  Modify the source code to collect the content of files that you are interested
    in and that it doesn’t already collect. Alternatively, implement your own idea
    for a new feature.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  修改源代码，收集你感兴趣的文件内容，或者是 LinEnum 尚未收集的文件内容。或者，实现你自己的新功能的想法。
- en: 3.  Add another command line option to LinEnum to compress (-c) the report into
    a *tar.gz* file by using the tar command.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  为 LinEnum 添加另一个命令行选项，使用 tar 命令将报告压缩为 *tar.gz* 文件（-c 选项）。
- en: Reading foreign code is just as important as writing code. Everyone has their
    own style of writing and way of implementing logic, and you can learn a lot about
    the internal plumbing of tools as well as ways to tailor them to your needs.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读外部代码与编写代码同样重要。每个人都有自己编写代码的风格和实现逻辑的方式，你可以从中学到很多关于工具内部结构以及如何根据自己的需求定制它们的知识。
- en: Summary
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we highlighted the major categories of data collection you
    can conduct on a compromised host, such as the operating system and kernel, adjacent
    networks and connections, running processes and user activity sessions, environment
    data, user and group identities, system and third-party logfiles, and configuration
    files. In addition, we used Cron and At to schedule the execution of shell scripts.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们强调了你可以在被攻破的主机上进行的数据收集的主要类别，例如操作系统和内核、相邻网络和连接、正在运行的进程和用户活动会话、环境数据、用户和组身份、系统和第三方日志文件以及配置文件。此外，我们使用
    Cron 和 At 来调度执行 shell 脚本。
- en: As you progress through the book, you’ll continue collecting data to aid with
    privilege escalation, credential access, and other nefarious hacking activities.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你阅读本书的过程，你将继续收集数据，以帮助特权升级、凭证访问和其他不端黑客活动。
