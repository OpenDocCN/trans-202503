- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: How User Space Starts
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间如何启动
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: The point where the kernel starts init, its first user-space process, is significant—not
    just because the memory and CPU are finally ready for normal system operation,
    but because that’s where you can see how the rest of the system builds up as a
    whole. Prior to this point, the kernel follows a well-controlled path of execution
    defined by a relatively small number of software developers. User space is far
    more modular and customizable, and it’s also quite easy to see what goes into
    the user-space startup and operation. If you’re feeling a little adventurous,
    you can use this to an advantage, because understanding and changing the user-space
    startup requires no low-level programming.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 内核启动init，即它的第一个用户空间进程，具有重要意义——不仅仅是因为内存和CPU终于准备好进行正常的系统操作，而且因为在这个时候，你可以看到系统其余部分是如何整体构建起来的。在此之前，内核遵循由少数软件开发人员定义的严格执行路径。用户空间则更加模块化和可定制，也很容易看到用户空间启动和操作的内容。如果你有点冒险精神，你可以利用这一点，因为理解和更改用户空间的启动并不需要低级编程知识。
- en: 'User space starts in roughly this order:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间大致按以下顺序启动：
- en: init
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: init
- en: Essential low-level services, such as udevd and syslogd
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本低层服务，如udevd和syslogd
- en: Network configuration
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络配置
- en: Mid- and high-level services (cron, printing, and so on)
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中高层服务（cron、打印等）
- en: Login prompts, GUIs, and high-level applications, such as web servers
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录提示、GUI和高层应用程序，如Web服务器
- en: 6.1 Introduction to init
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 init简介
- en: '*init* is a user-space program like any other program on the Linux system,
    and you’ll find it in */sbin* along with many of the other system binaries. Its
    main purpose is to start and stop the essential service processes on the system.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*init*是一个用户空间程序，就像Linux系统上的其他程序一样，你可以在*/sbin*目录下找到它，以及其他许多系统二进制文件。它的主要作用是启动和停止系统上的基本服务进程。'
- en: On all current releases of major Linux distributions, the standard implementation
    of init is systemd. This chapter focuses on how systemd works and how to interact
    with it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前所有主要Linux发行版的版本中，init的标准实现是systemd。本章将重点介绍systemd是如何工作的，以及如何与之交互。
- en: There are two other varieties of init that you may encounter on older systems.
    System V init is a traditional sequenced init (Sys V, usually pronounced “sys-five,”
    with origins in Unix System V), found on Red Hat Enterprise Linux (RHEL) prior
    to version 7.0 and Debian 8\. Upstart is the init on Ubuntu distributions prior
    to version 15.04.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在旧系统上遇到两种其他版本的init。System V init是传统的顺序化init（Sys V，通常发音为“sys-five”，起源于Unix
    System V），在Red Hat Enterprise Linux（RHEL）7.0版本之前和Debian 8中使用。Upstart是Ubuntu发行版15.04版本之前的init。
- en: Other versions of init exist, especially on embedded platforms. For example,
    Android has its own init, and a version called *runit* is popular on lightweight
    systems. The BSDs also have their own version of init, but you’re unlikely to
    see them on a contemporary Linux machine. (Some distributions have also modified
    the System V init configuration to resemble the BSD style.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在其他版本的init，尤其是在嵌入式平台上。例如，Android有自己的init版本，名为*runit*的版本在轻量级系统中很受欢迎。BSD系统也有自己版本的init，但你不太可能在当代Linux机器上看到它们。（一些发行版也修改了System
    V init配置，使其类似于BSD风格。）
- en: Different implementations of init have been developed to address several shortcomings
    in System V init. To understand the problems, consider the inner workings of a
    traditional init. It’s basically a series of scripts that init runs, in sequence,
    one at a time. Each script usually starts one service or configures an individual
    piece of the system. In most cases, it’s relatively easy to resolve dependencies,
    plus there’s a lot of flexibility to accommodate unusual startup requirements
    by modifying scripts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决System V init中的若干缺点，开发了不同实现的init。为了理解这些问题，可以考虑传统init的内部工作原理。它基本上是一系列的脚本，init按顺序逐一执行每个脚本。每个脚本通常启动一个服务或配置系统的某个部分。在大多数情况下，解决依赖关系相对容易，而且通过修改脚本，具有相当大的灵活性来适应特殊的启动需求。
- en: 'However, this scheme suffers from some significant limitations. These can be
    grouped into “performance problems” and “system management hassles.” The most
    important of these are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方案存在一些显著的局限性。这些问题可以分为“性能问题”和“系统管理麻烦”两大类。最重要的包括以下几点：
- en: Performance suffers because two parts of the boot sequence cannot normally run
    at once.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能受到影响，因为引导序列的两个部分通常不能同时运行。
- en: Managing a running system can be difficult. Startup scripts are expected to
    start service daemons. To find the PID of a service daemon, you need to use `ps`,
    some other mechanism specific to the service, or a semistandardized system of
    recording the PID, such as */var/run/myservice.pid*.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理一个正在运行的系统可能会很困难。启动脚本需要启动服务守护进程。要找到服务守护进程的PID，你需要使用`ps`，或者某些特定于该服务的机制，或者使用半标准化的PID记录系统，如*/var/run/myservice.pid*。
- en: Startup scripts tend to include a lot of standard “boilerplate” code, sometimes
    making it difficult to read and understand what they do.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动脚本往往包含大量标准的“模板”代码，有时使得它们的阅读和理解变得困难。
- en: There is little notion of on-demand services and configuration. Most services
    start at boot time; system configuration is largely set at that time as well.
    At one time, the traditional inetd daemon was able to handle on-demand network
    services, but it has largely fallen out of use.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大多数系统来说，服务和配置的按需加载并不常见。大多数服务在启动时启动；系统配置通常也在此时设定。曾几何时，传统的inetd守护进程能够处理按需网络服务，但它已大多不再使用。
- en: Contemporary init systems have dealt with these problems by changing how services
    start, how they are supervised, and how the dependencies are configured. You’ll
    soon see how this works in systemd, but first, you should make sure that you’re
    running it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当代的init系统通过改变服务的启动方式、监督方式以及依赖项的配置方式来解决这些问题。你很快就会看到在systemd中是如何实现的，但首先，你应该确保你的系统正在运行systemd。
- en: 6.2 Identifying Your init
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 确认你的init
- en: 'Determining your system’s version of init usually isn’t difficult. Viewing
    the init(1) manual page normally tells you right away, but if you’re not sure,
    check your system as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 确定系统的init版本通常不难。查看init(1)手册页通常会立刻告诉你，但如果你不确定，可以按如下方法检查你的系统：
- en: If your system has */usr/lib/systemd* and */etc/systemd* directories, you have
    systemd.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的系统有*/usr/lib/systemd*和*/etc/systemd*目录，那么你正在使用systemd。
- en: If you have an */etc/init* directory that contains several *.conf* files, you’re
    probably running Upstart (unless you’re running Debian 7 or older, in which case
    you probably have System V init). We won’t cover Upstart in this book because
    it has been widely supplanted by systemd.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有一个包含多个*.conf*文件的*/etc/init*目录，你可能正在运行Upstart（除非你正在运行Debian 7或更早版本，在这种情况下你可能使用的是System
    V init）。本书不会讨论Upstart，因为它已经被systemd广泛取代。
- en: If neither of the above is true, but you have an */etc/inittab* file, you’re
    probably running System V init. Go to Section 6.5.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果上述两种情况都不成立，但你有一个*/etc/inittab*文件，那么你可能正在运行System V init。请参见第6.5节。
- en: 6.3 systemd
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 systemd
- en: The systemd init is one of the newest init implementations on Linux. In addition
    to handling the regular boot process, systemd aims to incorporate the functionality
    of a number of standard Unix services, such as cron and inetd. It takes some inspiration
    from Apple’s launchd.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: systemd init是Linux上最新的init实现之一。除了处理常规的启动过程外，systemd还旨在集成许多标准Unix服务的功能，如cron和inetd。它也受到Apple的launchd的启发。
- en: Where systemd really stands out from its predecessors is its advanced service
    management capabilities. Unlike a traditional init, systemd can track individual
    service daemons after they start, and group together multiple processes associated
    with a service, giving you more power and insight into exactly what is running
    on the system.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: systemd相较于其前辈真正脱颖而出的是其先进的服务管理能力。与传统的init不同，systemd在服务启动后能够追踪单个服务守护进程，并将与服务相关的多个进程组合在一起，这使你可以更好地掌握并洞察系统中到底有什么正在运行。
- en: systemd is goal-oriented. At the top level, you can think of defining a goal,
    called a *unit*, for some system task. A unit can contain instructions for common
    startup tasks, such as starting a daemon, and it also has dependencies, which
    are other units. When starting (or *activating*) a unit, systemd attempts to activate
    its dependencies and then moves on to the details of the unit.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: systemd是目标导向的。在最高层级，你可以将定义一个系统任务的目标称为一个*单元*（unit）。一个单元可以包含常见启动任务的指令，例如启动一个守护进程，它也有依赖项，即其他单元。在启动（或*激活*）一个单元时，systemd会尝试激活其依赖项，然后继续执行单元的详细内容。
- en: When starting services, systemd does not follow a rigid sequence; instead, it
    activates units whenever they are ready. After boot, systemd can react to system
    events (such as the uevents outlined in Chapter 3) by activating additional units.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 启动服务时，systemd并不遵循严格的顺序；相反，它会在服务准备好时激活它们。系统启动后，systemd可以通过响应系统事件（例如第3章中列出的uevents）来激活其他单元。
- en: Let’s start by looking at a top-level view of units, activation, and the initial
    boot process. Then you’ll be ready to see the specifics of unit configuration
    and the many varieties of unit dependencies. Along the way, you’ll get a grip
    on how to view and control a running system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个顶层视图开始，了解单元、激活以及初始启动过程。然后你将准备好查看单元配置的具体细节以及各种单元依赖关系。在这个过程中，你将掌握如何查看和控制正在运行的系统。
- en: 6.3.1 Units and Unit Types
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 单元和单元类型
- en: One way that systemd is more ambitious than previous versions of init is that
    it doesn’t just operate processes and services; it can also manage filesystem
    mounts, monitor network connection requests, run timers, and more. Each capability
    is called a *unit type*, and each specific function (such as a service) is called
    a *unit*. When you turn on a unit, you *activate* it. Each unit has its own configuration
    file; we’ll explore those files in Section 6.3.3.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 比之前版本的 init 更为雄心勃勃的一个方面是，它不仅仅管理进程和服务；它还可以管理文件系统挂载、监控网络连接请求、运行定时器等。每个功能被称为*单元类型*，每个具体的功能（如服务）被称为*单元*。当你启动一个单元时，你是在*激活*它。每个单元都有自己的配置文件；我们将在
    6.3.3 节中探讨这些文件。
- en: 'These are the most significant unit types that perform the boot-time tasks
    on a typical Linux system:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是执行典型 Linux 系统启动任务的最重要单元类型：
- en: Service units Control the service daemons found on a Unix system.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务单元控制 Unix 系统中的服务守护进程。
- en: Target units Control other units, usually by grouping them.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标单元控制其他单元，通常通过将它们分组来实现。
- en: Socket units Represent incoming network connection request locations.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 套接字单元表示传入的网络连接请求位置。
- en: Mount units Represent the attachment of filesystems to the system.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挂载单元表示文件系统与系统的连接。
- en: Of these, service and target units are the most common and the easiest to understand.
    Let’s take a look at how they fit together when you boot a system.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些单位中，服务单元和目标单元是最常见且最容易理解的。我们来看一下它们在系统启动时是如何相互配合的。
- en: 6.3.2 Booting and Unit Dependency Graphs
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 启动与单元依赖图
- en: When you boot a system, you’re activating a default unit, normally a target
    unit called *default.target* that groups together a number of service and mount
    units as dependencies. As a result, it’s somewhat easy to get a partial picture
    of what’s going to happen when you boot. You might expect the unit dependencies
    to form a tree—with one unit at the top, branching into several units below for
    later stages of the boot process—but they actually form a graph. A unit that comes
    late in the boot process can depend on several previous units, making earlier
    branches of a dependency tree join back together. You can even create a dependency
    graph with the `systemd-analyze dot` command. The entire graph is quite large
    on a typical system (requiring significant computing power to render), and it’s
    hard to read, but there are ways to filter units and zero in on individual portions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动系统时，你激活的是一个默认单元，通常是一个目标单元，称为*default.target*，它将多个服务单元和挂载单元作为依赖项进行分组。因此，了解启动时发生的事情就显得相对容易。你可能会期望单元依赖关系形成一棵树——树顶有一个单元，下面分支出多个单元，用于启动过程的后续阶段——但实际上，它们形成了一个图。启动过程后期的单元可能依赖于前面几个单元，从而使依赖树的早期分支重新汇合。你甚至可以使用
    `systemd-analyze dot` 命令创建依赖图。整个图在典型系统上相当庞大（需要大量计算资源来渲染），并且难以阅读，但有一些方法可以过滤单元并专注于某些部分。
- en: '[Figure 6-1](#figure6-1) shows a very small part of the dependency graph for
    the *default.target* unit found on a typical system. When you activate that unit,
    all of the units below it also activate.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-1](#figure6-1) 显示了在典型系统上找到的 *default.target* 单元的依赖图的一个非常小的部分。当你激活该单元时，所有在其下的单元也会被激活。'
- en: '![f06001_new](image_fi/500402c06/f06001_new.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![f06001_new](image_fi/500402c06/f06001_new.png)'
- en: 'Figure 6-1: Unit dependency graph'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-1：单元依赖图
- en: This figure is a greatly simplified view. On your own system, you won’t find
    it feasible to sketch out the dependencies just by looking at the unit configuration
    file at the top and working your way down. We’ll take a closer look at how dependencies
    work in Section 6.3.6.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图是一个大大简化的视图。在你自己的系统中，你不会发现仅凭查看单元配置文件从顶部向下工作，就能绘制出依赖关系。我们将在 6.3.6 节中更详细地了解依赖关系是如何工作的。
- en: 6.3.3 systemd Configuration
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.3 systemd 配置
- en: 'The systemd configuration files are spread among many directories across the
    system, so you might need to do a little hunting when you’re looking for a particular
    file. There are two main directories for systemd configuration: the *system unit*
    directory (global configuration; usually */lib/systemd/system* or */usr/lib/systemd/system*)
    and the *system configuration* directory (local definitions; usually */etc/systemd/system*).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: systemd配置文件分布在系统的多个目录中，因此当你寻找特定文件时，可能需要进行一些查找。systemd配置有两个主要目录：*system unit*目录（全局配置；通常是*/lib/systemd/system*或*/usr/lib/systemd/system*）和*system
    configuration*目录（本地定义；通常是*/etc/systemd/system*）。
- en: 'To prevent confusion, stick to this rule: avoid making changes to the system
    unit directory, because your distribution will maintain it for you. Make your
    local changes to the system configuration directory. This general rule also applies
    systemwide. When given the choice between modifying something in */usr* and */etc*,
    always change */etc*.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免混淆，遵循这个规则：避免对系统单元目录进行更改，因为你的发行版会为你维护它。将本地更改应用到系统配置目录。这一通用规则也适用于整个系统。当有选择在*/usr*和*/etc*之间修改时，总是选择修改*/etc*。
- en: 'You can check the current systemd configuration search path (including precedence)
    with this command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令检查当前的systemd配置搜索路径（包括优先级）：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To see the system unit and configuration directories on your system, use the
    following commands:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看系统单元和配置目录，请使用以下命令：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Unit Files
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元文件
- en: The format for unit files is derived from the XDG Desktop Entry specification
    (used for *.desktop* files, which are very similar to *.ini* files on Microsoft
    systems), with section names in square brackets (`[]`) and variable and value
    assignments (options) in each section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 单元文件的格式源自XDG桌面条目规范（用于*.desktop*文件，它们与Microsoft系统上的*.ini*文件非常相似），其中部分名称使用方括号（`[]`），每个部分内包含变量和值的分配（选项）。
- en: 'As an example, consider the *dbus-daemon.service* unit file for the desktop
    bus daemon:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，考虑桌面总线守护进程的*dbus-daemon.service*单元文件：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are two sections, `[Unit]` and `[Service]`. The `[Unit]` section gives
    some details about the unit and contains description and dependency information.
    In particular, this unit requires the *dbus.socket* unit as a dependency.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该单元文件包含两个部分，`[Unit]`和`[Service]`。`[Unit]`部分提供了关于该单元的一些详细信息，并包含描述和依赖信息。特别是，该单元需要*dbus.socket*单元作为依赖。
- en: In a service unit such as this, you’ll find the details about the service in
    the `[Service]` section, including how to prepare, start, and reload the service.
    You’ll find a complete listing in the systemd.service(5) and systemd.exec(5) manual
    pages, as well as in the discussion of process tracking in Section 6.3.5.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在像这样的服务单元中，你会在`[Service]`部分找到关于该服务的详细信息，包括如何准备、启动和重新加载服务。你可以在systemd.service(5)和systemd.exec(5)手册页中找到完整的列表，也可以在第6.3.5节的进程跟踪讨论中找到相关内容。
- en: Many other unit configuration files are similarly straightforward. For example,
    the service unit file *sshd.service* enables remote secure shell logins by starting
    sshd.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他单元配置文件也同样简单明了。例如，服务单元文件*sshd.service*通过启动sshd来启用远程安全Shell登录。
- en: Variables
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变量
- en: 'You’ll often find variables inside unit files. Here’s a section from a different
    unit file, this one for the secure shell that you’ll learn about in Chapter 10:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会在单元文件中找到变量。以下是来自另一个单元文件的一个部分，这是你将在第10章学习的安全Shell的部分：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Everything that starts with a dollar sign (`$`) is a variable. Although these
    variables have the same syntax, their origins are different. The `$OPTIONS` and
    `$CRYPTO_POLICY` options, which you can pass to sshd upon unit activation, are
    defined in the file specified by the `EnvironmentFile` setting. In this particular
    case, you can look at */etc/sysconfig/sshd* to determine if the variables are
    set and, if so, what their values are.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以美元符号（`$`）开头的所有内容都是变量。尽管这些变量具有相同的语法，但它们的来源不同。`$OPTIONS`和`$CRYPTO_POLICY`选项是你可以在单元激活时传递给sshd的，这些选项在由`EnvironmentFile`设置指定的文件中定义。在这个特定的情况下，你可以查看*/etc/sysconfig/sshd*来确定变量是否已设置，如果已设置，则查看其值。
- en: In comparison, `$MAINPID` contains the ID of the *tracked process* of the service
    (see Section 6.3.5). Upon unit activation, systemd records and stores this PID
    so that you can use it to manipulate a service-specific process later on. The
    *sshd.service* unit file uses `$MAINPID` to send a hangup (HUP) signal to sshd
    when you want to reload the configuration (this is a very common technique for
    dealing with reloads and restarting Unix daemons).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`$MAINPID` 包含服务的 *跟踪进程* 的 ID（见第 6.3.5 节）。在单元激活时，systemd 会记录并存储此 PID，以便你稍后可以使用它来操作特定服务的进程。*sshd.service*
    单元文件使用 `$MAINPID` 向 sshd 发送挂起信号（HUP），当你希望重新加载配置时使用此方法（这是处理重新加载和重启 Unix 守护进程的常见技巧）。
- en: Specifiers
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 说明符
- en: A *specifier* is a variable-like feature often found in unit files. Specifiers
    start with a percent sign (`%`). For example, the `%n` specifier is the current
    unit name, and the `%H` specifier is the current hostname.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*说明符*是单元文件中常见的类似变量的特性。说明符以百分号（`%`）开头。例如，`%n` 说明符表示当前单元名称，`%H` 说明符表示当前主机名。'
- en: You can also use specifiers to create multiple copies of a unit from a single
    unit file. One example is the set of `getty` processes that control the login
    prompts on virtual consoles, such as *tty1* and *tty2*. To use this feature, add
    an @ symbol to the end of the unit name, before the dot in the unit filename.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用说明符从单个单元文件创建多个单元副本。一个例子是控制虚拟控制台登录提示符的 `getty` 进程集，例如 *tty1* 和 *tty2*。要使用此功能，请在单元名称的末尾添加
    @ 符号，紧接着单元文件名中的点号之前。
- en: For example, the `getty` unit filename is *getty@.service* in most distributions,
    allowing for the dynamic creation of units, such as *getty@tty1* and *getty@tty2*.
    Anything after the @ is called the *instance*. When you look at one of these unit
    files, you may also see a `%I` or `%i` specifier. When activating a service from
    a unit file with instances, systemd replaces the `%I` or `%i` specifier with the
    instance to create the new service name.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`getty` 单元文件名在大多数发行版中为 *getty@.service*，允许动态创建单元，如 *getty@tty1* 和 *getty@tty2*。@
    后面的部分被称为 *实例*。当你查看其中一个单元文件时，你也可能看到 `%I` 或 `%i` 说明符。通过带有实例的单元文件激活服务时，systemd 会用实例替换
    `%I` 或 `%i` 说明符，以创建新的服务名称。
- en: 6.3.4 systemd Operation
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.4 systemd 操作
- en: You’ll interact with systemd primarily through the `systemctl` command, which
    allows you to activate and deactivate services, list status, reload the configuration,
    and much more.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你将主要通过 `systemctl` 命令与 systemd 交互，该命令允许你激活和停用服务、列出状态、重新加载配置等等。
- en: The most essential commands help you to obtain unit information. For example,
    to view a list of active units on your system, issue a `list-units` command. (This
    is the default command for `systemctl`, so technically you don’t need the `list-units`
    argument.)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的命令帮助你获取单元信息。例如，要查看系统上活动单元的列表，执行 `list-units` 命令。（这是 `systemctl` 的默认命令，因此从技术上讲，你不需要
    `list-units` 参数。）
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output format is typical of a Unix information-listing command. For example,
    the header and the line for *-.mount* (the root filesystem) looks like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出格式典型于 Unix 信息列出命令。例如，*-.mount*（根文件系统）的标题和行如下所示：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By default, `systemctl list-units` produces a lot of output, because a typical
    system has numerous active units, but it’s still an abridged form because `systemctl`
    truncates any really large unit names. To see the full names of the units, use
    the `--full` option, and to see all units (not just those that are active), use
    the `--all` option.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`systemctl list-units` 会产生大量输出，因为典型系统中有许多活动单元，但这仍然是简化的形式，因为 `systemctl`
    会截断任何非常长的单元名称。要查看单元的完整名称，使用 `--full` 选项，若要查看所有单元（不仅仅是活动单元），使用 `--all` 选项。
- en: 'A particularly useful `systemctl` operation is getting the status of a specific
    unit. For example, here’s a typical `status` command and some of its output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别有用的 `systemctl` 操作是获取特定单元的状态。例如，这是一个典型的 `status` 命令及其输出：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A number of log messages may also follow this output. If you’re used to a traditional
    init system, you might be surprised by the amount of useful information available
    from this one command. You get not only the state of the unit but also the processes
    associated with the service, when the unit started, and a number of log messages,
    if available.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这段输出后面可能还会跟着一些日志消息。如果你习惯于传统的 init 系统，你可能会对这条命令提供的大量有用信息感到惊讶。你不仅能看到单元的状态，还能看到与服务关联的进程、单元启动时间以及若有日志消息，也会显示出来。
- en: The output for other unit types includes similar useful information; for example,
    the output from mount units includes when the mount happened, the exact command
    line used for it, and its exit status.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 其他单元类型的输出也包括类似的有用信息；例如，挂载单元的输出包括挂载发生的时间、用于挂载的确切命令行及其退出状态。
- en: One interesting piece of the output is the control group (cgroup) name. In the
    preceding example, the control group is `/system.slice/sshd.service`, and the
    processes in the cgroup are shown below it. However, you may also see control
    groups named starting with `systemd:/system` if the processes of a unit (for example,
    a mount unit) have already terminated. You can view systemd-related cgroups without
    the rest of the unit status with the `systemd-cgls` command. You’ll learn more
    about how systemd uses cgroups in Section 6.3.5, and how cgroups work in Section
    8.6.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的一个有趣部分是控制组（cgroup）名称。在上面的示例中，控制组是`/system.slice/sshd.service`，其下显示了该控制组中的进程。然而，你还可能会看到以`systemd:/system`开头的控制组名称，
    如果某个单元的进程（例如挂载单元）已经终止。你可以使用`systemd-cgls`命令查看与 systemd 相关的控制组，而不显示其他单元状态。你将在第
    6.3.5 节中了解更多关于 systemd 如何使用控制组的信息，在第 8.6 节中了解控制组如何工作。
- en: 'The `status` command also displays only the most recent diagnostic log messages
    for the unit. You can view all of a unit’s messages like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`status` 命令还仅显示单元的最新诊断日志信息。你可以通过以下方式查看单元的所有消息：'
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You’ll learn much more about `journalctl` in Chapter 7.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 7 章，你将学到更多关于`journalctl`的内容。
- en: How Jobs Relate to Starting, Stopping, and Reloading Units
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 作业与启动、停止和重新加载单元的关系
- en: 'To activate, deactivate, and restart units, you use the commands `systemctl
    start`, `systemctl stop`, and `systemctl restart`. However, if you’ve changed
    a unit configuration file, you can tell systemd to reload the file in one of two
    ways:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活、停用和重启单元，你可以使用命令`systemctl start`、`systemctl stop`和`systemctl restart`。然而，如果你已经更改了单元配置文件，你可以通过以下两种方式之一告诉
    systemd 重新加载该文件：
- en: '`systemctl reload` `unit` Reloads just the configuration for `unit`.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`systemctl reload` `unit` 仅重新加载`unit`的配置。'
- en: '`systemctl daemon-reload` Reloads all unit configurations.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`systemctl daemon-reload` 重新加载所有单元配置。'
- en: 'Requests to activate, reactivate, and restart units are called *jobs* in systemd,
    and they are essentially unit state changes. You can check the current jobs on
    a system with:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 systemd 中，激活、重新激活和重启单元的请求被称为*作业*，本质上它们是单元状态的变化。你可以使用以下命令查看系统上当前的作业：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If a system has been up for some time, you can reasonably expect there to be
    no active jobs because all activations required to start the system should be
    complete. However, at boot time, you can sometimes log in fast enough to see jobs
    for units that start very slowly. For example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统已经运行了一段时间，你可以合理地预期没有活跃的作业，因为启动系统所需的所有激活操作应该都已经完成。然而，在启动时，你有时可以快速登录，看到启动非常慢的单元的作业。例如：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, job 76, the *sendmail.service* unit startup, is taking a really
    long time. The other listed jobs are in a waiting state, most likely because they’re
    all waiting for job 76\. When *sendmail.service* finishes starting and is fully
    active, job 76 will complete, the rest of the jobs will also complete, and the
    job list will be empty.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，作业 76，即*sendmail.service*单元的启动，花费了非常长的时间。其他列出的作业处于等待状态，很可能是因为它们都在等待作业
    76。当*sendmail.service*启动完成并完全激活后，作业 76 将完成，其他作业也将完成，作业列表将变为空。
- en: See Section 6.6 to learn how to shut down and reboot the system.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见第 6.6 节，了解如何关闭和重启系统。
- en: Adding Units to systemd
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将单元添加到 systemd 中
- en: Adding units to systemd is primarily a matter of creating, then activating and
    possibly enabling, unit files. You should normally put your own unit files in
    the system configuration directory (*/etc/systemd/system*)so that you won’t confuse
    them with anything that came with your distribution and so that the distribution
    won’t overwrite them when you upgrade.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将单元添加到 systemd 中，主要是创建单元文件，然后激活并可能启用它们。你应该通常将自己的单元文件放在系统配置目录（*/etc/systemd/system*）中，这样你就不会把它们与发行版自带的文件混淆，而且当你升级时，发行版不会覆盖它们。
- en: 'Because it’s easy to create target units that don’t actually do anything or
    interfere with your system, give it a try. To create two targets, one with a dependency
    on the other, follow these steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于很容易创建实际上不起作用或干扰系统的目标单元，试试看吧。要创建两个目标，其中一个依赖于另一个，请按照以下步骤操作：
- en: 'Create a unit file named *test1.target* in */etc/systemd/system*:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*/etc/systemd/system*中创建名为*test1.target*的单元文件：
- en: '[PRE10]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a *test2.target* file with a dependency on *test1.target*:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个依赖于*test1.target*的*test2.target*文件：
- en: '[PRE11]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `Wants` keyword here defines a dependency that causes *test1.target* to
    activate when you activate *test2.target*. Activate the *test2.target* unit to
    see it in action:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Wants` 关键字在这里定义了一个依赖关系，当你激活 *test2.target* 时，*test1.target* 会激活。激活 *test2.target*
    单元查看其实际效果：'
- en: '[PRE12]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Verify that both units are active:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证两个单元是否都处于活动状态：
- en: '[PRE13]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If your unit file has an `[Install]` section, you need to “enable” the unit
    before activating it:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的单元文件有一个 `[Install]` 部分，在激活之前你需要“启用”该单元：
- en: '[PRE14]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `[Install]` section is another way to create a dependency. We’ll look at
    it (and dependencies as a whole) in more detail in Section 6.3.6.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Install]` 部分是创建依赖关系的另一种方式。我们将在第 6.3.6 节中更详细地讨论它（以及整体依赖关系）。'
- en: Removing Units from systemd
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从 systemd 中移除单元
- en: 'To remove a unit, follow these steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除一个单元，请按照以下步骤操作：
- en: 'Deactivate the unit if necessary:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如有必要，请停用该单元：
- en: '[PRE15]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If the unit has an `[Install]` section, disable the unit to remove any symbolic
    links created by the dependency system:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果该单元有一个 `[Install]` 部分，请禁用该单元，以移除依赖系统创建的任何符号链接：
- en: '[PRE16]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can then remove the unit file if you like.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你可以移除单元文件。
- en: 6.3.5 systemd Process Tracking and Synchronization
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.5 systemd 进程跟踪与同步
- en: systemd wants a reasonable amount of information and control over every process
    it starts. This has been difficult historically. A service can start in different
    ways; it could fork new instances of itself or even daemonize and detach itself
    from the original process. There’s also no telling how many subprocesses the server
    can spawn.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 希望对它启动的每个进程有合理的控制和信息。这在历史上是很困难的。服务的启动方式可以多种多样；它可能会分叉出新的实例，甚至会守护进程并与原始进程分离。还无法预知服务器会启动多少个子进程。
- en: 'In order to manage activated units easily, systemd uses the previously mentioned
    cgroups, a Linux kernel feature that allows for finer tracking of a process hierarchy.
    The use of cgroups also helps minimize the work that a package developer or administrator
    needs to do in order to create a working unit file. In systemd, you don’t have
    to worry about accounting for every possible startup behavior; all you need to
    know is whether a service startup process forks. Use the `Type` option in your
    service unit file to indicate startup behavior. There are two basic startup styles:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于管理已激活的单元，systemd 使用前面提到的 cgroups，它是 Linux 内核的一个特性，可以更细粒度地跟踪进程层次结构。使用 cgroups
    也有助于减少软件包开发者或管理员在创建有效单元文件时需要做的工作。在 systemd 中，你不需要担心考虑每种可能的启动行为；你只需要知道服务的启动进程是否会分叉。使用服务单元文件中的
    `Type` 选项来指示启动行为。有两种基本的启动方式：
- en: '`Type=simple` The service process doesn’t fork and terminate; it remains the
    main service process.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Type=simple` 服务进程不会分叉并终止；它保持为主要的服务进程。'
- en: '`Type=forking` The service forks, and systemd expects the original service
    process to terminate. Upon this termination, systemd assumes the service is ready.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Type=forking` 服务会进行分叉，systemd 期望原始服务进程终止。终止后，systemd 假设服务已准备好。'
- en: 'The `Type=simple` option doesn’t account for the fact that a service may take
    some time to initiate, and as a result systemd doesn’t know when to start any
    dependent units that absolutely require such a service to be ready. One way to
    deal with this is to use delayed startup (see Section 6.3.7). However, some `Type`
    startup styles can indicate that the service itself will notify systemd when it’s
    ready:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Type=simple` 选项没有考虑到服务可能需要一些时间来启动，因此 systemd 无法知道何时启动任何依赖于该服务准备好的单元。一种处理方法是使用延迟启动（见第
    6.3.7 节）。不过，某些 `Type` 启动方式可以表明服务会在准备好时通知 systemd：'
- en: '`Type=notify` When ready, the service sends a notification specific to systemd
    with a special function call.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Type=notify` 当准备好时，服务会发送一个特定于 systemd 的通知，并进行特殊的函数调用。'
- en: '`Type=dbus` When ready, the service registers itself on the D-Bus (Desktop
    Bus).'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Type=dbus` 当准备好时，服务会在 D-Bus（桌面总线）上注册自己。'
- en: Another service startup style is specified with `Type=oneshot`; here the service
    process terminates completely with no child processes after starting. It’s like
    `Type=simple`, except that systemd does not consider the service to be started
    until the service process terminates. Any strict dependencies (which you’ll see
    soon) will not start until that termination. A service using `Type=oneshot` also
    gets a default `RemainAfterExit=yes` directive so that systemd regards a service
    as active even after its processes terminate.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种服务启动风格是通过`Type=oneshot`指定的；在这种情况下，服务进程在启动后会完全终止且没有子进程。它像`Type=simple`一样，唯一的区别是
    systemd 不认为服务已启动，直到服务进程终止。任何严格依赖（你很快就会看到）都不会启动，直到该进程终止。使用`Type=oneshot`的服务还会得到默认的`RemainAfterExit=yes`指令，因此即使服务进程终止，systemd
    仍然会认为该服务是活动的。
- en: A final option is `Type=idle`. This works like the `simple` style, but it instructs
    systemd not to start the service until all active jobs finish. The idea here is
    just to delay a service start until other services have started to keep services
    from stepping on one another’s output. Remember, once a service has started, the
    systemd job that started it terminates, so waiting for all other jobs to finish
    ensures that nothing else is starting.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的选项是`Type=idle`。它的作用类似于`simple`风格，但它指示 systemd 在所有活动任务完成之前不启动服务。这里的思路是仅仅延迟服务的启动，直到其他服务已经启动，以防服务之间互相干扰输出。记住，一旦服务启动，启动它的
    systemd 任务就会终止，因此等待所有其他任务完成可以确保没有其他任务在启动。
- en: If you’re interested in how cgroups work, we’ll explore them in more detail
    in Section 8.6.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 cgroups 的工作原理感兴趣，我们将在第 8.6 节中详细探讨它们。
- en: 6.3.6 systemd Dependencies
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.6 systemd 依赖关系
- en: A flexible system for boot-time and operational dependencies requires some degree
    of complexity, because overly strict rules can cause poor system performance and
    instability. For example, say you want to display a login prompt after starting
    a database server, so you define a strict dependency from the login prompt to
    the database server. This means if the database server fails, the login prompt
    will also fail, and you won’t even be able to log in to your machine to fix the
    issue!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一种灵活的系统启动时和操作时依赖关系需要一定的复杂性，因为过于严格的规则可能会导致系统性能不佳和不稳定。例如，假设你希望在启动数据库服务器后显示登录提示，因此你将登录提示与数据库服务器定义为严格依赖。这意味着如果数据库服务器失败，登录提示也会失败，你甚至无法登录机器来修复问题！
- en: Unix boot-time tasks are fairly fault tolerant and can often fail without causing
    serious problems for standard services. For example, if you removed a system’s
    data disk but left its */etc/fstab* entry (or mount unit in systemd), the boot-time
    filesystem mount would fail. Though this failure might affect application servers
    (such as web servers), it typically wouldn’t affect standard system operation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 启动时的任务具有相当高的容错性，通常可以在不造成标准服务严重问题的情况下失败。例如，如果你移除了系统的数据磁盘，但保留了其*/etc/fstab*条目（或者在
    systemd 中的挂载单元），那么启动时的文件系统挂载会失败。尽管这个失败可能会影响应用服务器（如 Web 服务器），但通常不会影响标准的系统操作。
- en: 'To accommodate the need for flexibility and fault tolerance, systemd offers
    several dependency types and styles. Let’s first look at the basic types, labeled
    by their keyword syntax:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足灵活性和容错性的需求，systemd 提供了几种依赖类型和风格。我们首先来看一下基本的类型，它们通过关键词语法进行标记：
- en: '`Requires  ` Strict dependencies. When activating a unit with a `Requires`
    dependency unit, systemd attempts to activate the dependency unit. If the dependency
    unit fails, systemd also deactivates the dependent unit.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Requires` 严格依赖。当激活一个具有`Requires`依赖项的单元时，systemd 会尝试激活依赖单元。如果依赖单元失败，systemd
    也会停用该依赖单元。'
- en: '`Wants`  Dependencies for activation only. Upon activating a unit, systemd
    activates the unit’s `Wants` dependencies, but it doesn’t care if those dependencies
    fail.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Wants` 仅为激活依赖。在激活一个单元时，systemd 会激活该单元的`Wants`依赖关系，但如果这些依赖失败，systemd 并不关心。'
- en: '`Requisite` Units that must already be active. Before activating a unit with
    a `Requisite` dependency, systemd first checks the status of the dependency. If
    the dependency hasn’t been activated, systemd fails on activation of the unit
    with the dependency.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Requisite` 单元必须已经激活。在激活一个具有`Requisite`依赖关系的单元之前，systemd 会首先检查依赖项的状态。如果依赖项尚未激活，systemd
    在激活该单元时会失败。'
- en: '`Conflicts`  Negative dependencies. When activating a unit with a `Conflict`
    dependency, systemd automatically deactivates the opposing dependency if it’s
    active. Simultaneous activation of conflicting units fails.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Conflicts`  负依赖关系。当激活一个带有 `Conflict` 依赖的单元时，如果对立的依赖关系处于活动状态，systemd 会自动停用它。冲突单元的同时激活会失败。'
- en: The `Wants` dependency type is especially significant because it doesn’t propagate
    failures to other units. The systemd.service(5) manual page states that this is
    how you should specify dependencies if possible, and it’s easy to see why. This
    behavior produces a much more robust system, giving you the benefit of a traditional
    init, where the failure of an earlier startup component doesn’t necessarily prohibit
    later components from starting.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wants` 依赖类型特别重要，因为它不会将失败传播到其他单元。systemd.service(5) 手册页面指出，如果可能的话，应该指定这种依赖关系，原因也很容易理解。这种行为使系统更加稳健，带来了传统初始化系统的好处，即早期启动组件的失败不一定会阻止后续组件的启动。'
- en: 'You can view a unit’s dependencies with the `systemctl` command, as long as
    you specify a type of dependency, such as `Wants` or `Requires`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `systemctl` 命令查看单元的依赖关系，只要你指定依赖关系的类型，例如 `Wants` 或 `Requires`：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Ordering
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 排序
- en: So far, the dependency syntax you’ve seen hasn’t explicitly specified order.
    For example, activating most service units with `Requires` or `Wants` dependencies
    causes these units to start at the same time. This is optimal, because you want
    to start as many services as possible as quickly as possible to reduce boot time.
    However, there are situations when one unit must start after another. For instance,
    in the system that [Figure 6-1](#figure6-1) is based on, the *default.target*
    unit is set to start after *multi-user.target* (this order distinction is not
    shown in the figure).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你看到的依赖语法并没有明确指定顺序。例如，使用 `Requires` 或 `Wants` 依赖激活大多数服务单元时，这些单元会同时启动。这是最优的，因为你希望尽可能快地启动尽可能多的服务，以减少启动时间。然而，也有一些情况需要一个单元在另一个单元之后启动。例如，在[图
    6-1](#figure6-1)所基于的系统中，*default.target* 单元被设置为在 *multi-user.target* 之后启动（图中未显示这一顺序区别）。
- en: 'To activate units in a particular order, use the following dependency modifiers:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 若要按特定顺序激活单元，请使用以下依赖修饰符：
- en: '`Before`  The current unit will activate before the listed unit(s). For example,
    if `Before=bar.target` appears in *foo.target*, systemd activates *foo.target*
    before *bar.target*.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Before`  当前单元将在列出的单元之前激活。例如，如果 `Before=bar.target` 出现在 *foo.target* 中，systemd
    会在 *bar.target* 之前激活 *foo.target*。'
- en: '`After`  The current unit activates after the listed unit(s).'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`After`  当前单元在列出的单元激活后激活。'
- en: When you use ordering, systemd waits until a unit has an active status before
    activating its dependent units.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用排序时，systemd 会等待一个单元处于活动状态后，才会激活它的依赖单元。
- en: Default and Implicit Dependencies
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 默认和隐式依赖
- en: As you explore dependencies (especially with `systemd-analyze`), you might start
    to notice that some units acquire dependencies that aren’t explicitly stated in
    unit files or other visible mechanisms. You’re most likely to encounter this in
    target units with `Wants` dependencies—you’ll find that systemd adds an `After`
    modifier alongside any unit listed as a `Wants` dependency. These additional dependencies
    are internal to systemd, calculated at boot time, and not stored in configuration
    files.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索依赖关系时（尤其是使用 `systemd-analyze` 时），你可能会开始注意到一些单元获得了在单元文件或其他可见机制中没有显式声明的依赖关系。你最可能遇到这种情况的是在带有
    `Wants` 依赖的目标单元中——你会发现 systemd 会在任何列为 `Wants` 依赖的单元旁边添加一个 `After` 修饰符。这些额外的依赖关系是
    systemd 内部的，在启动时计算出来的，并且不存储在配置文件中。
- en: The added `After` modifier is called a *default dependency*, an automatic addition
    to the unit configuration meant to avoid common mistakes and keep unit files small.
    These dependencies vary according to the type of unit. For example, systemd doesn’t
    add the same default dependencies for target units as it does for service units.
    These differences are listed in the DEFAULT DEPENDENCIES sections of the unit
    configuration manual pages, such as systemd.service(5) and systemd.target(5).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的 `After` 修饰符称为 *默认依赖关系*，它是对单元配置的自动添加，旨在避免常见错误并保持单元文件的简洁。这些依赖关系根据单元类型而有所不同。例如，systemd
    为目标单元添加的默认依赖关系与为服务单元添加的不同。这些差异在单元配置手册页面的 DEFAULT DEPENDENCIES 部分列出，例如 systemd.service(5)
    和 systemd.target(5)。
- en: You can disable a default dependency in a unit by adding `DefaultDependencies=no`
    to its configuration file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在配置文件中添加 `DefaultDependencies=no` 来禁用单元的默认依赖关系。
- en: Conditional Dependencies
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 条件依赖关系
- en: 'You can use several *conditional dependency* parameters to test various operating
    system states rather than systemd units. For example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用多个*条件依赖*参数来测试不同的操作系统状态，而不是 systemd 单元。例如：
- en: '`ConditionPathExists=p`  True if the (file) path *p* exists in the system.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ConditionPathExists=p`  如果路径 *p* 在系统中存在，则为真。'
- en: '`ConditionPathIsDirectory=p`  True if *p* is a directory.'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ConditionPathIsDirectory=p`  如果 *p* 是一个目录，则为真。'
- en: '`ConditionFileNotEmpty=p`  True if *p* is a file and it’s not zero-length.'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ConditionFileNotEmpty=p`  如果 *p* 是一个文件且其长度非零，则为真。'
- en: If a conditional dependency in a unit is false when systemd tries to activate
    the unit, the unit does not activate, although this applies only to the unit in
    which it appears. That is, if you activate a unit that has a conditional dependency
    and some unit dependencies, systemd attempts to activate those unit dependencies
    regardless of whether the condition is true or false.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统尝试激活单元时，单元中的条件依赖为假，则该单元不会激活，尽管这仅适用于其中出现的单元。也就是说，如果你激活一个具有条件依赖和一些单元依赖的单元，systemd
    会尝试激活这些单元依赖，不管条件是否为真。
- en: Other dependencies are primarily variations on the preceding ones. For example,
    the `RequiresOverridable` dependency is just like `Requires` when running normally,
    but it acts like a `Wants` dependency if a unit is manually activated. For a full
    list, see the systemd.unit(5) manual page.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 其他依赖关系主要是前述依赖关系的变种。例如，`RequiresOverridable` 依赖关系在正常运行时与 `Requires` 相同，但如果单元是手动激活的，它就像
    `Wants` 依赖关系。完整的依赖列表请参见 systemd.unit(5) 手册页。
- en: The [Install] Section and Enabling Units
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`[Install]` 部分和启用单元'
- en: So far, we’ve been looking at how to define dependencies in a dependent unit’s
    configuration file. It’s also possible to do this “in reverse”—that is, by specifying
    the dependent unit in a dependency’s unit file. You can do this by adding a `WantedBy`
    or `RequiredBy` parameter in the `[Install]` section. This mechanism allows you
    to alter when a unit should start without modifying additional configuration files
    (for example, when you’d rather not edit a system unit file).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在讨论如何在依赖单元的配置文件中定义依赖关系。也可以“反向”进行操作——即通过在依赖项的单元文件中指定依赖单元。你可以通过在 `[Install]`
    部分添加 `WantedBy` 或 `RequiredBy` 参数来实现这一点。这个机制允许你在不修改其他配置文件的情况下更改单元启动的时机（例如，当你不想编辑系统单元文件时）。
- en: 'To see how this works, consider the example units back in Section 6.3.4. We
    had two units, *test1.target* and *test2.target*, with *test2.target* having a
    `Wants` dependency on *test1.target*. We can change them so that *test1.target*
    looks like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这个是如何工作的，请参考第 6.3.4 节中的示例单元。我们有两个单元，*test1.target* 和 *test2.target*，其中 *test2.target*
    依赖于 *test1.target*。我们可以将它们修改为 *test1.target* 看起来像这样：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And *test2.target* is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*test2.target* 如下所示：'
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Because you now have a unit with an `[Install]` section, you need to *enable*
    the unit with `systemctl` before you can start it. Here’s how that works with
    *test1.target*:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你现在有了一个包含 `[Install]` 部分的单元，在启动之前，你需要使用 `systemctl` 来*启用*该单元。以下是如何通过 *test1.target*
    来实现的：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice the output here—the effect of enabling a unit is to create a symbolic
    link in a *.wants* subdirectory corresponding to the dependent unit (*test2.target*
    in this case). You can now start both units at the same time with `systemctl start
    test2.target` because the dependency is in place.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里的输出——启用单元的效果是创建一个符号链接，该链接位于对应于依赖单元的 *.wants* 子目录中（在本例中是 *test2.target*）。现在，由于依赖关系已建立，你可以通过
    `systemctl start test2.target` 同时启动两个单元。
- en: 'To disable the unit (and remove the symbolic link), use `systemctl` as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用单元（并删除符号链接），可以按如下方式使用 `systemctl`：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The two units in this example also give you a chance to experiment with different
    startup scenarios. For example, see what happens when you try to start only *test1.target*,
    or when you try to start *test2.target* without enabling *test1.target*. Or, try
    changing `WantedBy` to `RequiredBy`. (Remember, you can check the status of a
    unit with `systemctl status`.)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的两个单元还为你提供了实验不同启动场景的机会。例如，查看当你仅尝试启动 *test1.target* 时会发生什么，或者当你尝试在没有启用 *test1.target*
    的情况下启动 *test2.target* 时会发生什么。或者，尝试将 `WantedBy` 更改为 `RequiredBy`。（记住，你可以通过 `systemctl
    status` 检查单元的状态。）
- en: During normal operation, systemd ignores the `[Install]` section in a unit but
    notes its presence and, by default, considers the unit to be disabled. Enabling
    a unit survives reboots.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常操作期间，systemd 会忽略单元中的 `[Install]` 部分，但会注意到它的存在，并默认将该单元视为禁用状态。启用单元后，其状态会在重启后保留。
- en: The `[Install]` section is usually responsible for the *.wants* and *.requires*
    directories in the system configuration directory (*/etc/systemd/system*). However,
    the unit configuration directory (*[/usr]/lib/systemd/system*) also contains *.wants*
    directories, and you may also add links that don’t correspond to `[Install]` sections
    in the unit files. These manual additions are a simple way to add a dependency
    without modifying a unit file that may be overwritten in the future (by a software
    upgrade, for instance), but they’re not particularly encouraged because a manual
    addition is difficult to trace.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Install]`部分通常负责系统配置目录（*/etc/systemd/system*）中的*.wants*和*.requires*目录。然而，单元配置目录（*[/usr]/lib/systemd/system*）也包含*.wants*目录，你还可以添加与单元文件中的`[Install]`部分不对应的链接。这些手动添加是一种简单的方法，可以在不修改可能在未来被覆盖的单元文件（例如通过软件升级）的情况下添加依赖项，但并不特别推荐，因为手动添加很难追踪。'
- en: 6.3.7 systemd On-Demand and Resource-Parallelized Startup
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.7 systemd按需和资源并行启动
- en: 'One of systemd’s features is the ability to delay a unit startup until it is
    absolutely needed. The setup typically works like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: systemd的一个特点是能够延迟单元的启动，直到绝对需要时再启动。通常的设置流程如下：
- en: You create a systemd unit (call it Unit A) for the system service you’d like
    to provide.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你为你希望提供的系统服务创建一个systemd单元（称为单元A）。
- en: You identify a system resource, such as a network port/socket, file, or device,
    that Unit A uses to offer its services.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你确定一个系统资源，比如网络端口/套接字、文件或设备，单元A用来提供其服务。
- en: You create another systemd unit, Unit R, to represent that resource. These units
    are classified into types, such as socket units, path units, and device units.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你创建另一个systemd单元，单元R，用来表示该资源。这些单元被分类为不同类型，如socket单元、path单元和device单元。
- en: You define the relationship between Unit A and Unit R. Normally, this is implicit
    based on the units’ names, but it can also be explicit, as we’ll see shortly.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你定义单元A和单元R之间的关系。通常，这基于单元的名称是隐式的，但它也可以是显式的，正如我们稍后会看到的那样。
- en: 'Once in place, the operation proceeds as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好，操作过程如下：
- en: Upon activation of Unit R, systemd monitors the resource.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当激活单元R时，systemd监控该资源。
- en: When anything tries to access the resource, systemd blocks the resource, and
    the input to the resource is buffered.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当任何东西尝试访问资源时，systemd会阻塞资源，且对资源的输入会被缓冲。
- en: systemd activates Unit A.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: systemd激活单元A。
- en: When ready, the service from Unit A takes control of the resource, reads the
    buffered input, and runs normally.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备好后，来自单元A的服务接管资源，读取缓冲的输入并正常运行。
- en: 'There are a few concerns here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个需要注意的点：
- en: You must make sure that your resource unit covers every resource that the service
    provides. This normally isn’t a problem, because most services have just one point
    of access.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须确保你的资源单元覆盖了服务提供的每个资源。通常这不是问题，因为大多数服务只有一个访问点。
- en: You need to make sure your resource unit is tied to the service unit that it
    represents. This can be implicit or explicit, and in some cases, many options
    represent different ways for systemd to perform the handoff to the service unit.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要确保你的资源单元与它所代表的服务单元绑定在一起。这可以是隐式的或显式的，在某些情况下，许多选项代表了systemd为服务单元执行交接的不同方式。
- en: Not all servers know how to interface with the resource units systemd can provide.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有服务器都知道如何与systemd可以提供的资源单元进行交互。
- en: If you already know what traditional utilities like inetd, xinetd, and automount
    do, you’ll see many similarities. Indeed, the concept is nothing new; systemd
    even includes support for automount units.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经了解传统的工具如inetd、xinetd和automount的功能，你会发现它们之间有很多相似之处。事实上，这个概念并不新鲜；systemd甚至包括对automount单元的支持。
- en: An Example Socket Unit and Service
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例Socket单元和服务
- en: Let’s look at an example, a simple network echo service. This is somewhat advanced
    material, and you might not fully understand it until you’ve read the discussion
    of TCP, ports, and listening in Chapter 9 and sockets in Chapter 10, but you should
    be able to get the basic idea.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，一个简单的网络回显服务。这些内容有点高级，直到你阅读了第9章关于TCP、端口和监听的讨论以及第10章关于套接字的内容后，你可能才完全理解，但你应该能够理解基本概念。
- en: 'The idea of an echo service is to repeat anything that a network client sends
    after connecting; ours will listen on TCP port 22222\. We’ll start building it
    with a *socket unit* to represent the port, as shown in the following *echo.socket*
    unit file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一个回显服务的理念是重复网络客户端连接后发送的任何内容；我们的服务将监听TCP端口22222。我们将通过一个*socket单元*来表示该端口，以下是*echo.socket*单元文件的构建示例：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that there’s no mention of the service unit that this socket supports inside
    the unit file. So, what is that corresponding service unit file?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在单元文件中没有提到该套接字支持的服务单元。那么，那个对应的服务单元文件是什么呢？
- en: 'Its name is *echo@.service*. The link is established by naming convention;
    if a service unit file has the same prefix as a *.socket* file (in this case,
    *echo*), systemd knows to activate that service unit when there’s activity on
    the socket unit. In this case, systemd creates an instance of *echo@.service*
    when there’s activity on *echo.socket*. Here’s the *echo@.service* unit file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 它的名称是*echo@.service*。通过命名约定建立了连接；如果一个服务单元文件与一个*.socket*文件有相同的前缀（在此例中为*echo*），systemd会在该套接字单元有活动时激活该服务单元。在这种情况下，当*echo.socket*上有活动时，systemd会创建一个*echo@.service*实例。以下是*echo@.service*单元文件：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To get this example unit running, you need to start the *echo.socket* unit:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个示例单元，你需要启动*echo.socket*单元：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now you can test the service by connecting to your local TCP port 22222 with
    a utility such as `telnet`. The service repeats what you enter; here’s an example
    interaction:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过像`telnet`这样的工具连接到本地TCP端口22222来测试该服务。服务会重复你输入的内容；以下是一个示例交互：
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When you’re bored with this and want to get back to your shell, press ctrl-]
    on a line by itself and then press ctrl-D. To stop the service, stop the socket
    unit like so:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当你厌倦了这一切，想回到你的shell时，按下ctrl-]单独一行，然后按ctrl-D。要停止服务，可以像这样停止套接字单元：
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Instances and Handoff
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实例与交接
- en: Because the *echo@.service* unit supports multiple simultaneous instances, there’s
    an *@* in the name (recall that the *@* specifier signifies parameterization).
    Why would you want multiple instances? Say you have more than one network client
    connecting to the service at the same time, and you want each connection to have
    its own instance. In this case, the service unit *must* support multiple instances
    because we included the `Accept=true` option in *echo.socket*. That option instructs
    systemd not only to listen on the port, but also to accept incoming connections
    on behalf of the service unit and pass it to them, creating a separate instance
    for each connection. Each instance reads data from the connection as standard
    input, but it doesn’t necessarily need to know that the data is coming from a
    network connection.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*echo@.service*单元支持多个同时实例，所以名称中有一个`@`（回想一下，`@`修饰符表示参数化）。为什么需要多个实例呢？假设有多个网络客户端同时连接到该服务，并且你希望每个连接都有自己的实例。在这种情况下，服务单元*必须*支持多个实例，因为我们在*echo.socket*中包含了`Accept=true`选项。该选项指示systemd不仅要监听端口，还要代表服务单元接受传入的连接并将其传递给它们，为每个连接创建一个单独的实例。每个实例将数据作为标准输入读取，但它不一定需要知道这些数据来自网络连接。
- en: If a service unit can do the work of accepting a connection, don’t put an *@*
    in its unit filename, and don’t put `Accept=true` in the socket unit. In this
    case, the service unit takes complete control of the socket from systemd, which
    in turn does not attempt to listen on the network port again until the service
    unit finishes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个服务单元可以完成接受连接的工作，就不要在其单元文件名中放置`@`，也不要在套接字单元中放置`Accept=true`。在这种情况下，服务单元将完全控制套接字，不会再尝试监听网络端口，直到服务单元完成工作。
- en: The many different resources and options for handoff to service units make it
    difficult to provide a categorical summary. Not only that, but the documentation
    for the options is spread out over several manual pages. For the resource-oriented
    units, check systemd.socket(5), systemd.path(5), and systemd.device(5). One document
    that’s often overlooked for service units is systemd.exec(5), which contains information
    about how the service unit can expect to receive a resource upon activation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于交接到服务单元的资源和选项种类繁多，很难提供一个分类的总结。不仅如此，这些选项的文档分散在多个手册页中。对于面向资源的单元，查看systemd.socket(5)、systemd.path(5)和systemd.device(5)。一个常常被忽视的文档是systemd.exec(5)，它包含了有关服务单元如何在激活时接收资源的信息。
- en: Boot Optimization with Auxiliary Units
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用辅助单元进行启动优化
- en: An overall goal of systemd is to simplify dependency order and speed up boot
    time. Resource units such as socket units provide a way to do this that’s similar
    to on-demand startup. We’ll still have a service unit and an auxiliary unit representing
    the service unit’s offered resource, except that in this case, systemd starts
    the service unit as soon as it activates the auxiliary unit rather than waiting
    around for a request.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 的一个总体目标是简化依赖顺序并加快启动时间。像套接字单元这样的资源单元提供了一种类似于按需启动的方法。我们仍然有一个服务单元和代表服务单元提供资源的辅助单元，但在这种情况下，systemd
    在激活辅助单元后立即启动服务单元，而不是等待请求。
- en: The reason for this scheme is that essential boot-time service units such as
    *systemd-journald.service* take some time to start, and many other units depend
    on them. However, systemd can offer the essential resource of a unit (such as
    a socket unit) very quickly, and then it can immediately activate not only the
    essential unit but also any units that depend on it. Once the essential unit is
    ready, it takes control of the resource.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方案的原因是，像 *systemd-journald.service* 这样的重要启动时服务单元需要一些时间来启动，并且许多其他单元依赖于它们。然而，systemd
    可以非常快速地提供单元的重要资源（如套接字单元），然后它可以立即激活不仅是该重要单元，还有任何依赖于它的单元。一旦重要单元准备就绪，它就控制该资源。
- en: '[Figure 6-2](#figure6-2) shows how this might work in a traditional sequential
    system. In this boot timeline, Service E provides an essential Resource R. Services
    A, B, and C depend on this resource (but not on each other) and must wait until
    Service E has started. Because the system will not start a new service until it’s
    done starting the preceding one, it takes quite a long time to get around to starting
    Service C.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-2](#figure6-2) 展示了这在传统顺序系统中可能是如何工作的。在这个启动时间线中，服务 E 提供了一个重要的资源 R。服务 A、B
    和 C 依赖于此资源（但彼此之间并不依赖），必须等到服务 E 启动完成。因为系统在启动完前一个服务之前不会启动新的服务，所以启动服务 C 需要相当长的时间。'
- en: '![f06002](image_fi/500402c06/f06002.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![f06002](image_fi/500402c06/f06002.png)'
- en: 'Figure 6-2: Sequential boot timeline with a resource dependency'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-2：顺序启动时间线与资源依赖关系
- en: '[Figure 6-3](#figure6-3) shows a possible equivalent systemd boot configuration.
    The services are represented by Units A, B, C, and E, with a new Unit R representing
    the resource that Unit E provides. Because systemd can provide an interface for
    Unit R while Unit E starts, Units A, B, C, and E can all be started at the same
    time. When ready, Unit E takes over for Unit R. An interesting point here is that
    Unit A, B, or C may not need to access the resource that Unit R provides before
    finishing startup. What we’re doing is providing them with the *option* to start
    accessing the resource as soon as possible.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](#figure6-3) 展示了一个可能的等效 systemd 启动配置。服务由单元 A、B、C 和 E 表示，新的单元 R 表示单元
    E 提供的资源。因为 systemd 可以在单元 E 启动时为单元 R 提供接口，所以单元 A、B、C 和 E 可以同时启动。准备就绪后，单元 E 接管单元
    R。一个有趣的地方是，单元 A、B 或 C 在完成启动之前可能不需要访问单元 R 提供的资源。我们正在做的是尽快为它们提供访问资源的*选择*。'
- en: '![f06003](image_fi/500402c06/f06003.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![f06003](image_fi/500402c06/f06003.png)'
- en: 'Figure 6-3: systemd boot timeline with a resource unit'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-3：带有资源单元的 systemd 启动时间线
- en: The takeaway is that, although you’re not creating an on-demand unit startup
    in this case, you’re using the same features that make on-demand startup possible.
    For common real-world examples, see the journald and D-Bus configuration units
    on a machine running systemd; they’re very likely to be parallelized in this way.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于，尽管在这种情况下您没有创建按需单元启动，但您正在使用使按需启动成为可能的相同功能。对于常见的真实世界示例，请参见运行 systemd 的机器上的
    journald 和 D-Bus 配置单元；它们很可能以这种方式并行化。
- en: 6.3.8 systemd Auxiliary Components
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.8 systemd 辅助组件
- en: As systemd has grown in popularity, it has grown to include support for a few
    tasks not related to startup and service management, both directly and through
    auxiliary compatibility layers. You may notice the numerous programs in */lib/systemd*;
    these are the executables related to those functions.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 systemd 的普及，它不仅直接支持启动和服务管理相关的任务，还通过辅助兼容层支持一些与之无关的任务。您可能会注意到 */lib/systemd*
    中的众多程序；这些是与这些功能相关的可执行文件。
- en: 'Here are a few specific system services:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个特定的系统服务：
- en: udevd You learned about this in Chapter 3; it’s part of systemd.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: udevd 您在第 3 章学到了这一点；它是 systemd 的一部分。
- en: journald A logging service that handles a few different logging mechanisms,
    including the traditional Unix `syslog` service. You’ll read more about this in
    Chapter 7.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: journald 是一种日志服务，处理多种不同的日志机制，包括传统的 Unix `syslog` 服务。你将在第 7 章了解更多。
- en: resolved A name service caching daemon for DNS; you’ll learn about that in Chapter
    9.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: resolved 是一个 DNS 名称服务缓存守护进程；你将在第 9 章了解更多。
- en: All of the executables for these services are prefixed with `systemd-`. For
    example, the systemd-integrated udevd is called `systemd-udevd`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务的所有可执行文件都以 `systemd-` 为前缀。例如，systemd 集成的 udevd 被称为 `systemd-udevd`。
- en: If you dig deeper, you’ll find that some of these programs are relatively simple
    wrappers. Their function is to run standard system utilities and notify systemd
    of the results. One example is `systemd-fsck`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果深入了解，你会发现这些程序其实是相对简单的包装器。它们的功能是运行标准的系统工具，并将结果通知 systemd。一个例子是`systemd-fsck`。
- en: If you see a program in */lib/systemd* that you can’t identify, check for a
    manual page. There’s a good chance that it will describe not only the utility
    but also the type of unit it’s meant to augment.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在*/lib/systemd*目录中看到一个无法识别的程序，可以查看手册页。很可能它不仅会描述该工具，还会描述它所要增强的单元类型。
- en: 6.4 System V Runlevels
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 System V 运行级别
- en: Now that you’ve learned about systemd and how it works, let’s shift gears and
    look at some aspects of the traditional System V init. At any given time on a
    Linux system, a certain base set of processes (such as crond and udevd) is running.
    In System V init, this state of the machine is called its *runlevel*, which is
    denoted by a number from 0 through 6\. A system spends most of its time in a single
    runlevel, but when you shut down the machine, init switches to a different runlevel
    in order to terminate the system services in an orderly fashion and tell the kernel
    to stop.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 systemd 及其工作原理，让我们转变一下，看看传统的 System V 初始化的某些方面。在 Linux 系统中，任何给定时刻都会有一组基本的进程（如
    crond 和 udevd）在运行。在 System V 初始化中，这种机器的状态被称为*运行级别*，用从 0 到 6 的数字表示。一个系统大多数时间都处于一个运行级别，但当你关闭机器时，init
    会切换到另一个运行级别，以便有序地终止系统服务并告诉内核停止。
- en: 'You can check your system’s runlevel with the `who -r` command like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `who -r` 命令来检查系统的运行级别，如下所示：
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This output tells us that the current runlevel is 5, as well as the date and
    time that the runlevel was established.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出告诉我们当前的运行级别是 5，以及该运行级别被设置的日期和时间。
- en: Runlevels serve various purposes, but the most common one is to distinguish
    between system startup, shutdown, single-user mode, and console mode states. For
    example, most systems traditionally used runlevels 2 through 4 for the text console;
    a runlevel of 5 means that the system starts a GUI login.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 运行级别有多种用途，但最常见的是区分系统启动、关机、单用户模式和控制台模式。例如，大多数系统传统上使用运行级别 2 到 4 来表示文本控制台；运行级别
    5 表示系统启动图形用户界面登录。
- en: But runlevels are becoming a thing of the past. Even though systemd supports
    them, it considers runlevels obsolete as end states for the system, preferring
    target units instead. To systemd, runlevels exist primarily to start services
    that support only the System V init scripts.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，运行级别正逐渐成为过去式。即使 systemd 支持它们，它也认为运行级别作为系统的结束状态已经过时，更倾向于使用目标单元。对于 systemd
    来说，运行级别主要存在是为了启动仅支持 System V 初始化脚本的服务。
- en: 6.5 System V init
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 System V 初始化
- en: The System V init implementation is among the oldest used on Linux; its core
    idea is to support an orderly bootup to different runlevels with a carefully constructed
    startup sequence. System V init is now uncommon on most server and desktop installations,
    but you may encounter it in versions of RHEL prior to version 7.0, as well as
    in embedded Linux environments, such as routers and phones. In addition, some
    older packages may only provide startup scripts designed for System V init; systemd
    can handle those with a compatibility mode that we’ll discuss in Section 6.5.5.
    We’ll look at the basics here, but keep in mind that you might not actually encounter
    anything covered in this section.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: System V 初始化实现是 Linux 上最古老的实现之一；其核心思想是支持有序启动到不同的运行级别，并通过精心构建的启动顺序来实现。System
    V 初始化在大多数服务器和桌面安装中已经不常见，但你可能会在版本 7.0 之前的 RHEL 版本中遇到它，或者在嵌入式 Linux 环境中遇到，例如路由器和手机。此外，一些旧的软件包可能仅提供为
    System V 初始化设计的启动脚本；systemd 可以通过兼容模式处理这些脚本，我们将在 6.5.5 节讨论这一点。在这里我们将介绍基本知识，但请记住，你可能不会实际遇到这一部分中涵盖的内容。
- en: 'A typical System V init installation has two components: a central configuration
    file and a large set of boot scripts augmented by a symbolic link farm. The configuration
    file */etc/inittab* is where it all starts. If you have System V init, look for
    a line like the following in your *inittab* file:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的 System V init 安装包含两个部分：一个中央配置文件和一组大量的启动脚本，后者通过符号链接构成。配置文件 */etc/inittab*
    是一切的起点。如果你使用的是 System V init，查看你的 *inittab* 文件中是否有类似以下的行：
- en: '[PRE28]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This indicates that the default runlevel is 5\.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示默认的运行级别是 5\。
- en: 'All lines in *inittab* take the following form, with four fields separated
    by colons in this order:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 *inittab* 中的行都采取以下形式，字段由冒号分隔，顺序如下：
- en: A unique identifier (a short string, such as `id` in the previous example).
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个唯一的标识符（一个短字符串，例如前面示例中的 `id`）。
- en: The applicable runlevel number(s).
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适用的运行级别编号。
- en: The action that init should take (default runlevel to 5 in the previous example).
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: init 应该执行的操作（在前面的示例中默认运行级别是 5）。
- en: A command to execute (optional).
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个要执行的命令（可选）。
- en: 'To see how commands work in an *inittab* file, consider this line:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看命令如何在 *inittab* 文件中工作，可以参考这一行：
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This particular line is important because it triggers most of the system configuration
    and services. Here, the `wait` action determines when and how System V init runs
    the command: run `/etc/rc.d/rc 5` once when entering runlevel 5 and then wait
    for this command to finish before doing anything else. The `rc 5` command executes
    anything in */etc/rc5.d* that starts with a number (in numeric order). We’ll cover
    this in more detail shortly.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行特别重要，因为它触发了大多数系统配置和服务。在这里，`wait` 动作决定了 System V init 何时以及如何执行命令：在进入运行级别 5
    时运行 `/etc/rc.d/rc 5` 一次，然后等待该命令执行完成后再进行其他操作。`rc 5` 命令按数字顺序执行 */etc/rc5.d* 中以数字开头的所有内容。稍后我们将更详细地讨论这一点。
- en: 'The following are some of the most common *inittab* actions in addition to
    `initdefault` and `wait`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`initdefault`和`wait`之外，以下是一些最常见的 *inittab* 动作：
- en: '`respawn`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`respawn`'
- en: 'The `respawn` action tells init to run the command that follows and, if the
    command finishes executing, to run it again. You’re likely to see something like
    this in an *inittab* file:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`respawn` 动作告诉 init 执行后续的命令，并且如果命令执行完毕，就再次运行它。你可能会在 *inittab* 文件中看到如下内容：'
- en: '[PRE30]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `getty` programs provide login prompts. The preceding line is used for the
    first virtual console (*/dev/tty1*), which is the one you see when you press alt-F1
    or ctrl-alt-F1 (see Section 3.4.7). The `respawn` action brings the login prompt
    back after you log out.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getty` 程序提供登录提示。前面的这一行用于第一个虚拟控制台（*/dev/tty1*），这是你按下 alt-F1 或 ctrl-alt-F1 时看到的控制台（参见第
    3.4.7 节）。`respawn` 动作会在你注销后再次显示登录提示。'
- en: '`ctrlaltdel`'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctrlaltdel`'
- en: The `ctrlaltdel` action controls what the system does when you press ctrl-alt-del
    on a virtual console. On most systems, this is some sort of reboot command using
    the `shutdown` command (discussed in Section 6.6).
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ctrlaltdel` 动作控制当你在虚拟控制台上按下 ctrl-alt-del 时系统的行为。在大多数系统中，这通常是某种使用 `shutdown`
    命令的重启命令（在第 6.6 节中讨论）。'
- en: '`sysinit`'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`sysinit`'
- en: The `sysinit` action is the first thing that init should run when starting,
    before entering any runlevels.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sysinit` 动作是 init 启动时应该首先执行的内容，在进入任何运行级别之前。'
- en: '6.5.1 System V init: Startup Command Sequence'
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1 System V init：启动命令顺序
- en: 'Now let’s look at how System V init starts system services, just before it
    lets you log in. Recall this *inittab* line from earlier:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 System V init 是如何启动系统服务的，在允许你登录之前。回想一下之前提到的 *inittab* 行：
- en: '[PRE31]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This short line triggers many other programs. In fact, `rc` stands for *run
    commands*, which many people refer to as *scripts*, *programs*, or *services*.
    But where are these commands?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这一简短的行触发了许多其他程序。事实上，`rc` 代表 *运行命令*，许多人称之为 *脚本*、*程序* 或 *服务*。但是这些命令在哪里呢？
- en: 'The `5` in this line tells us that we’re talking about runlevel 5\. The commands
    are probably in either */etc/rc.d/rc5.d* or */etc/rc5.d*. (Runlevel 1 uses *rc1.d*,
    runlevel 2 uses *rc2.d*, and so on.) For example, you might find the following
    items in the *rc5.d* directory:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行中的 `5` 告诉我们我们正在讨论运行级别 5\。这些命令可能位于 */etc/rc.d/rc5.d* 或 */etc/rc5.d* 目录中。（运行级别
    1 使用 *rc1.d*，运行级别 2 使用 *rc2.d*，以此类推。）例如，你可能会在 *rc5.d* 目录中找到以下项目：
- en: '[PRE32]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `rc 5` command starts programs in the *rc5.d* directory by executing the
    following commands in this sequence:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`rc 5` 命令通过按以下顺序执行命令来启动 *rc5.d* 目录中的程序：'
- en: '[PRE33]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice the `start` argument in each command. The capital *S* in a command name
    means that the command should run in *start* mode, and the number (00 through
    99) determines where in the sequence `rc` starts the command. The *rc*.d* commands
    are usually shell scripts that start programs in */sbin* or */usr/sbin*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个命令中的`start`参数。命令名中的大写*S*表示该命令应该以*start*模式运行，数字（00到99之间）决定了`rc`在序列中启动命令的位置。*rc*.d*中的命令通常是启动*/sbin*或*/usr/sbin*目录中程序的shell脚本。
- en: Normally, you can figure out what a particular command does by viewing the script
    with `less` or another pager program.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以通过使用`less`或其他分页程序查看脚本来弄清楚特定命令的作用。
- en: You can run these commands by hand; however, normally you’ll want to do so through
    the *init.d* directory instead of the *rc*.d* directories, which we’ll look at
    next.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以手动运行这些命令；然而，通常你会通过*init.d*目录而不是*rc*.d*目录来执行，我们接下来将讨论这一点。
- en: 6.5.2 The System V init Link Farm
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.2 System V初始化链接农场
- en: 'The contents of the *rc*.d* directories are actually symbolic links to files
    in yet another directory, *init.d*. If your goal is to interact with, add, delete,
    or modify services in the *rc*.d* directories, you need to understand these symbolic
    links. A long listing of a directory such as *rc5.d* reveals a structure like
    this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*rc*.d*目录的内容实际上是指向另一个目录*init.d*中文件的符号链接。如果你的目标是与*rc*.d*目录中的服务进行交互、添加、删除或修改服务，你需要理解这些符号链接。比如，*rc5.d*目录的长列表显示出如下结构：'
- en: '[PRE34]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A large number of symbolic links across several subdirectories like this is
    called a *link farm*. Linux distributions contain these links so that they can
    use the same startup scripts for all runlevels. This is a convention, not a requirement,
    but it simplifies organization.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的多个子目录中的大量符号链接被称为*链接农场*。Linux发行版包含这些链接，以便它们可以在所有运行级别中使用相同的启动脚本。这是一种约定，而不是要求，但它简化了组织结构。
- en: Starting and Stopping Services
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启动和停止服务
- en: To start and stop services by hand, use the script in the *init.d* directory.
    For example, one way to start the httpd web server program manually is to run
    `init.d/httpd start`. Similarly, to kill a running service, you can use the `stop`
    argument (`httpd stop`, for instance).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动启动和停止服务，使用*init.d*目录中的脚本。例如，手动启动httpd网页服务器程序的一种方法是运行`init.d/httpd start`。类似地，要停止正在运行的服务，可以使用`stop`参数（例如`httpd
    stop`）。
- en: Modifying the Boot Sequence
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改启动序列
- en: 'Changing the boot sequence in System V init is normally done by modifying the
    link farm. The most common change is to prevent one of the commands in the *init.d*
    directory from running in a particular runlevel. You have to be careful about
    how you do this, however. For example, you might consider removing the symbolic
    link in the appropriate *rc*.d* directory. But if you ever need to put the link
    back, you might have trouble remembering its exact name. One of the best approaches
    is to add an underscore (`_`) at the beginning of the link name, like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在System V初始化中，通常通过修改链接农场来更改启动序列。最常见的更改是阻止*init.d*目录中的某个命令在特定运行级别下运行。然而，在进行此操作时需要小心。例如，你可能会考虑在适当的*rc*.d*目录中删除符号链接。但如果你需要恢复该链接，可能会很难记住它的确切名称。最好的方法之一是，在链接名称的开头添加一个下划线(`_`)，像这样：
- en: '[PRE35]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This change causes `rc` to ignore *_S99httpd* because the filename no longer
    starts with *S* or *K*, but the original name still indicates its purpose.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改导致`rc`忽略了*_S99httpd*，因为文件名不再以*S*或*K*开头，但原始名称仍然表明其用途。
- en: To add a service, create a script like those in the *init.d* directory and then
    create a symbolic link in the correct *rc*.d* directory. The easiest way to do
    this is to copy and modify one of the scripts already in *init.d* that you understand
    (see Chapter 11 for more information on shell scripts).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加服务，创建一个像*init.d*目录中的脚本，然后在正确的*rc*.d*目录中创建一个符号链接。最简单的做法是复制并修改你理解的*init.d*中现有的一个脚本（有关shell脚本的更多信息，请参见第11章）。
- en: When adding a service, choose an appropriate place in the boot sequence to start
    it. If the service starts too soon, it may not work due to a dependency on some
    other service. For nonessential services, most systems administrators prefer numbers
    in the 90s, which puts the services after most of the services that came with
    the system.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 添加服务时，选择启动序列中的合适位置来启动它。如果服务启动得太早，可能因为依赖其他服务而无法正常工作。对于非关键服务，大多数系统管理员更倾向于选择90年代的数字，这样服务就会在大多数系统自带的服务之后启动。
- en: 6.5.3 run-parts
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.3 run-parts
- en: The mechanism that System V init uses to run the *init.d* scripts has found
    its way into many Linux systems, regardless of whether they use System V init.
    It’s a utility called `run-parts`, and the only thing it does is run a bunch of
    executable programs in a given directory, in some kind of predictable order. You
    can think of `run-parts` as almost like a person who enters the `ls` command in
    some directory and then just runs whatever programs are listed in the output.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: System V init用于运行*init.d*脚本的机制已被许多Linux系统采用，无论它们是否使用System V init。它是一个名为`run-parts`的工具，唯一的作用就是按照某种可预测的顺序运行给定目录中的一堆可执行程序。你可以把`run-parts`看作是一个人，他在某个目录中输入`ls`命令，然后运行列在输出中的所有程序。
- en: The default behavior is to run all programs in a directory, but you often have
    the option to select certain programs and ignore others. In some distributions,
    you don’t need much control over the programs that run. For example, Fedora ships
    with a very simple `run-parts` utility.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 默认行为是运行目录中的所有程序，但你通常可以选择某些程序并忽略其他程序。在一些发行版中，你不需要太多控制正在运行的程序。例如，Fedora 配备了一个非常简单的`run-parts`实用程序。
- en: Other distributions, such as Debian and Ubuntu, have a more complicated `run-parts`
    program. Their features include the ability to run programs based on a regular
    expression (for example, using the `S[0-9]{2}` expression for running all “start”
    scripts in an */etc/init.d* runleveldirectory) and to pass arguments to the programs.
    These capabilities allow you to start and stop System V runlevels with a single
    command.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 其他发行版，如 Debian 和 Ubuntu，拥有更复杂的`run-parts`程序。它们的功能包括基于正则表达式运行程序（例如，使用`S[0-9]{2}`表达式来运行*/etc/init.d*中的所有“启动”脚本），以及向程序传递参数。这些功能允许你使用单个命令启动和停止System
    V运行级别。
- en: You don’t really need to understand the details of how to use `run-parts`; in
    fact, most people don’t know that it even exists. The main things to remember
    are that it shows up in scripts from time to time and that it exists solely to
    run the programs in a given directory.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要真正理解如何使用`run-parts`的细节；事实上，大多数人甚至不知道它的存在。需要记住的主要事项是，它偶尔会出现在脚本中，且它仅用于运行给定目录中的程序。
- en: 6.5.4 System V init Control
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.4 System V init 控制
- en: 'Occasionally, you’ll need to give init a little kick to tell it to switch runlevels,
    to reread its configuration, or to shut down the system. To control System V init,
    you use `telinit`. For example, to switch to runlevel 3, enter:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，你需要给init一点“推力”，告诉它切换运行级别、重新读取配置，或关闭系统。控制System V init时，你使用`telinit`。例如，要切换到运行级别3，输入：
- en: '[PRE36]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When switching runlevels, init tries to kill off any processes not in the *inittab*
    file for the new runlevel, so be careful when changing runlevels.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 切换运行级别时，init会尝试杀死所有不在新运行级别的*inittab*文件中的进程，因此在更改运行级别时要小心。
- en: 'When you need to add or remove jobs, or make any other change to the *inittab*
    file, you must tell init about the change and have it reload the file. The `telinit`
    command for this is:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要添加或移除作业，或对*inittab*文件进行其他更改时，必须告知init进行更改并重新加载该文件。执行此操作的`telinit`命令是：
- en: '[PRE37]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can also use `telinit s` to switch to single-user mode.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`telinit s`切换到单用户模式。
- en: 6.5.5 systemd System V Compatibility
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.5 systemd System V兼容性
- en: 'One feature that sets systemd apart from other newer-generation init systems
    is that it tries to do a more complete job of tracking services started by System
    V–compatible init scripts. It works like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 使systemd与其他新一代init系统不同的一个特点是，它尝试更完整地跟踪由System V兼容init脚本启动的服务。其工作方式如下：
- en: First, systemd activates *runlevel<N>.target*, where *N* is the runlevel.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，systemd 激活*runlevel<N>.target*，其中*N*是运行级别。
- en: For each symbolic link in */etc/rc<N>.d*, systemd identifies the script in */etc/init.d*.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于*/etc/rc<N>.d*中的每个符号链接，systemd 会识别*/etc/init.d*中的脚本。
- en: systemd associates the script name with a service unit (for example, */etc/init.d/foo*
    would be *foo.service*).
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: systemd 将脚本名称与服务单元关联起来（例如，*/etc/init.d/foo*将是*foo.service*）。
- en: systemd activates the service unit and runs the script with either a `start`
    or `stop` argument, based on its name in *rc<N>.d*.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: systemd 激活服务单元，并根据其在*rc<N>.d*中的名称，使用`start`或`stop`参数运行脚本。
- en: systemd attempts to associate any processes from the script with the service
    unit.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: systemd 尝试将脚本中的任何进程与服务单元关联起来。
- en: Because systemd makes the association with a service unit name, you can use
    `systemctl` to restart the service or view its status. But don’t expect any miracles
    from System V compatibility mode; it still must run the init scripts serially,
    for example.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 systemd 与服务单元名称相关联，你可以使用 `systemctl` 来重启服务或查看其状态。但不要指望在 System V 兼容模式下有什么奇迹；它仍然必须按顺序执行
    init 脚本，例如。
- en: 6.6 Shutting Down Your System
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 关闭系统
- en: init controls how the system shuts down and reboots. The commands to shut down
    the system are the same regardless of which version of init you run. The proper
    way to shut down a Linux machine is to use the `shutdown` command.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: init 控制系统如何关闭和重启。关闭系统的命令在不同版本的 init 中是相同的。正确的关机方式是使用 `shutdown` 命令。
- en: 'There are two basic ways to use `shutdown`. If you *halt* the system, it shuts
    the machine down and keeps it down. To make the machine halt immediately, run
    this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `shutdown` 有两种基本方法。如果你 *停止* 系统，它将关闭机器并保持关闭状态。要立即停止机器，可以运行以下命令：
- en: '[PRE38]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: On most machines and versions of Linux, a halt cuts the power to the machine.
    You can also *reboot* the machine. For a reboot, use `-r` instead of `-h`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数机器和 Linux 版本上，halt 会切断机器的电源。你也可以 *重启* 机器。若要重启，使用 `-r` 代替 `-h`。
- en: The shutdown process takes several seconds. You should avoid resetting or powering
    off a machine during a shutdown.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 关机过程需要几秒钟。你应该避免在关机过程中重置或关闭机器。
- en: In the preceding example, `now` is the time to shut down. Including a time argument
    is mandatory, but there are many ways to specify it. For example, if you want
    the machine to shut down sometime in the future, you can use `+``n`, where `n`
    is the number of minutes `shutdown` should wait before proceeding. See the shutdown(8)
    manual page for other options.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`now` 表示关机的时间。包括时间参数是必须的，但有很多种方法可以指定它。例如，如果你希望机器在未来某个时间关机，可以使用 `+n`，其中
    `n` 是 `shutdown` 在执行前等待的分钟数。有关其他选项，请参阅 shutdown(8) 手册页。
- en: 'To make the system reboot in 10 minutes, enter:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要使系统在 10 分钟后重启，请输入：
- en: '[PRE39]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: On Linux, `shutdown` notifies anyone logged on that the machine is going down,
    but it does little real work. If you specify a time other than `now`, the `shutdown`
    command creates a file called */etc/nologin*. When this file is present, the system
    prohibits logins by anyone except the superuser.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，`shutdown` 告知所有已登录用户机器将关闭，但它本身不会做太多实际工作。如果你指定了除 `now` 以外的时间，`shutdown`
    命令会创建一个名为 */etc/nologin* 的文件。当该文件存在时，系统将禁止除超级用户外的任何人登录。
- en: 'When the system shutdown time finally arrives, `shutdown` tells init to begin
    the shutdown process. On systemd, this means activating the shutdown units, and
    on System V init, it means changing the runlevel to 0 (halt) or 6 (reboot). Regardless
    of the init implementation or configuration, the procedure generally goes like
    this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统关机时间最终到来时，`shutdown` 告诉 init 开始关机过程。在 systemd 中，这意味着激活关机单元，而在 System V init
    中，这意味着将运行级别更改为 0（停止）或 6（重启）。无论是哪个 init 实现或配置，程序大致如下：
- en: init asks every process to shut down cleanly.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: init 请求每个进程干净地关闭。
- en: If a process doesn’t respond after a while, init kills it, first trying a TERM
    signal.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果进程在一段时间后没有响应，init 会终止它，首先尝试发送 TERM 信号。
- en: If the TERM signal doesn’t work, init uses the KILL signal on any stragglers.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 TERM 信号不起作用，init 会对任何未结束的进程使用 KILL 信号。
- en: The system locks system files into place and makes other preparations for shutdown.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统将系统文件锁定并为关机做其他准备。
- en: The system unmounts all filesystems other than the root.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统卸载除了根文件系统之外的所有文件系统。
- en: The system remounts the root filesystem read-only.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统将根文件系统重新挂载为只读模式。
- en: The system writes all buffered data out to the filesystem with the `sync` program.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统使用 `sync` 程序将所有缓冲数据写入文件系统。
- en: The final step is to tell the kernel to reboot or stop with the `reboot(2)`
    system call. This can be done by init or an auxiliary program, such as `reboot`,
    `halt`, or `poweroff`.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是通过 `reboot(2)` 系统调用告诉内核重启或停止。这个操作可以由 init 或辅助程序来执行，例如 `reboot`、`halt` 或
    `poweroff`。
- en: The `reboot` and `halt` programs behave differently depending on how they’re
    called, which may cause confusion. By default, these programs call `shutdown`
    with the `-r` or `-h` options. However, if the system is already at a halt or
    reboot runlevel, the programs tell the kernel to shut itself off immediately.
    If you really want to shut down your machine in a hurry, regardless of any potential
    damage from a disorderly shutdown, use the `-f` (force) option.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`reboot` 和 `halt` 程序的行为取决于它们的调用方式，这可能会引起混淆。默认情况下，这些程序会使用 `-r` 或 `-h` 选项调用 `shutdown`。然而，如果系统已经处于停止或重启的运行级别，这些程序会指示内核立即关闭。如果你真的想要快速关闭计算机，不管不规范关机可能带来的任何损坏，可以使用
    `-f`（强制）选项。'
- en: 6.7 The Initial RAM Filesystem
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 初始 RAM 文件系统
- en: 'The Linux boot process is, for the most part, fairly straightforward. However,
    one component has always been somewhat confounding: *initramfs*, or the *initial
    RAM filesystem*. Think of it as a little user-space wedge that goes in front of
    the normal user mode start. But first, let’s talk about why it exists.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 启动过程大体上是相当简单的。然而，有一个组件一直让人困惑：*initramfs*，即*初始 RAM 文件系统*。可以把它看作是一个在正常用户模式启动之前的小型用户空间插入。首先，让我们来探讨一下它为何存在。
- en: The problem stems from the availability of many different kinds of storage hardware.
    Remember, the Linux kernel does not talk to the PC BIOS interface or EFI to get
    data from disks, so in order to mount its root filesystem, it needs driver support
    for the underlying storage mechanism. For example, if the root is on a RAID array
    connected to a third-party controller, the kernel needs the driver for that controller
    first. Unfortunately, there are so many storage controller drivers that distributions
    can’t include all of them in their kernels, so many drivers are shipped as loadable
    modules. But loadable modules are files, and if your kernel doesn’t have a filesystem
    mounted in the first place, it can’t load the driver modules that it needs.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 问题源于多种存储硬件的可用性。请记住，Linux 内核并不直接与 PC BIOS 接口或 EFI 交互来从磁盘获取数据，因此，为了挂载其根文件系统，它需要为底层存储机制提供驱动支持。例如，如果根文件系统在一个通过第三方控制器连接的
    RAID 阵列上，内核首先需要该控制器的驱动。不幸的是，由于存储控制器驱动程序种类繁多，发行版无法将所有驱动都包含在内核中，因此许多驱动作为可加载模块发布。但是，可加载模块是文件，如果你的内核本身没有挂载文件系统，它就无法加载所需的驱动模块。
- en: The workaround is to gather a small collection of kernel driver modules along
    with a few other utilities into an archive. The boot loader loads this archive
    into memory before running the kernel. Upon start, the kernel reads the contents
    of the archive into a temporary RAM filesystem (the initramfs), mounts it at */*,
    and performs the user-mode handoff to the init on the initramfs. Then, the utilities
    included in the initramfs allow the kernel to load the necessary driver modules
    for the real root filesystem. Finally, the utilities mount the real root filesystem
    and start the true init.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是将一小部分内核驱动模块和一些其他工具集合到一个归档文件中。引导加载程序在运行内核之前将这个归档文件加载到内存中。启动时，内核会将归档内容读取到一个临时的
    RAM 文件系统（initramfs）中，并将其挂载到 */*，然后将用户模式的控制权交给 initramfs 上的 init。接着，initramfs 中包含的工具允许内核加载真实根文件系统所需的驱动模块。最后，这些工具挂载真实的根文件系统并启动真正的
    init。
- en: Implementations vary and are ever-evolving. On some distributions, the init
    on the initramfs is a fairly simple shell script that starts a udevd to load drivers,
    and then mounts the real root and executes the init there. On distributions that
    use systemd, you’ll typically see an entire systemd installation there with no
    unit configuration files and just a few udevd configuration files.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 实现方式各不相同，并且不断发展变化。在一些发行版中，initramfs 上的 init 是一个相当简单的 shell 脚本，它启动 udevd 来加载驱动程序，然后挂载真实的根文件系统并在那里执行
    init。在使用 systemd 的发行版中，你通常会看到一个完整的 systemd 安装，没有单元配置文件，只有几个 udevd 配置文件。
- en: One basic characteristic of the initial RAM filesystem that has (so far) remained
    unchanged since its inception is the ability to bypass it if you don’t need it.
    That is, if your kernel has all the drivers it needs to mount your root filesystem,
    you can omit the initial RAM filesystem in your boot loader configuration. When
    successful, eliminating the initial RAM filesystem slightly shortens boot time.
    Try it yourself at boot time by using the GRUB menu editor to remove the `initrd`
    line. (It’s best not to experiment by changing the GRUB configuration file, as
    you can make a mistake that will be difficult to repair.) It has gradually become
    a little more difficult to bypass the initial RAM filesystem because features
    such as mount-by-UUID may not be available with generic distribution kernels.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 初始 RAM 文件系统的一个基本特性是自其创建以来（至今）未曾改变过，那就是如果不需要它，可以绕过它。也就是说，如果你的内核已经具备挂载根文件系统所需的所有驱动程序，你可以在启动加载器配置中省略初始
    RAM 文件系统。成功时，去除初始 RAM 文件系统会稍微缩短启动时间。你可以在启动时尝试，通过使用 GRUB 菜单编辑器删除 `initrd` 行。（最好不要通过更改
    GRUB 配置文件来实验，因为你可能会犯下难以修复的错误。）由于某些特性（如按 UUID 挂载）在通用发行版内核中可能不可用，绕过初始 RAM 文件系统变得越来越困难。
- en: You can check the contents of your initial RAM filesystem, but you’ll need to
    do a little bit of detective work. Most systems now use archives created by `mkinitramfs`
    that you can unpack with `unmkinitramfs`. Others might be older compressed `cpio`
    archives (see the cpio(1) manual page).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以检查初始 RAM 文件系统的内容，但需要做一些侦探工作。现在大多数系统使用 `mkinitramfs` 创建的归档文件，你可以使用 `unmkinitramfs`
    解压它。其他系统可能使用较旧的压缩 `cpio` 归档文件（请参阅 cpio(1) 手册页）。
- en: One particular piece of interest is the “pivot” near the very end of the init
    process on the initial RAM filesystem. This part is responsible for removing the
    contents of the temporary filesystem (to save memory) and permanently switch to
    the real root.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别值得关注的部分是初始 RAM 文件系统中 init 过程接近结束时的“pivot”操作。该部分负责移除临时文件系统的内容（以节省内存），并永久切换到真实的根文件系统。
- en: You won’t typically create your own initial RAM filesystem, as it’s a painstaking
    process. There are a number of utilities for creating initial RAM filesystem images,
    and your distribution likely comes with one. Two of the most common are `mkinitramfs`
    and `dracut`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常不会自己创建初始 RAM 文件系统，因为这是一个费力的过程。有许多工具可以用来创建初始 RAM 文件系统镜像，你的发行版可能已经自带了其中之一。最常见的两个工具是
    `mkinitramfs` 和 `dracut`。
- en: 6.8 Emergency Booting and Single-User Mode
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.8 紧急启动和单用户模式
- en: 'When something goes wrong with the system, your first recourse is usually to
    boot the system with a distribution’s “live” image or with a dedicated rescue
    image, such as SystemRescueCD, that you can put on removable media. A live image
    is simply a Linux system that can boot and run without an installation process;
    most distributions’ installation images double as live images. Common tasks for
    fixing a system include the following:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统出现问题时，你的第一个应急措施通常是使用发行版的“实时”镜像或使用专门的救援镜像启动系统，例如你可以放在可移动媒体上的 SystemRescueCD。实时镜像只是一个无需安装过程即可启动和运行的
    Linux 系统；大多数发行版的安装镜像也可以作为实时镜像使用。修复系统的常见任务包括以下内容：
- en: Checking filesystems after a system crash.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在系统崩溃后检查文件系统。
- en: Resetting a forgotten password.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重置遗忘的密码。
- en: Fixing problems in critical files, such as */etc/fstab* and */etc/passwd.*
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复关键文件中的问题，如*/etc/fstab* 和 */etc/passwd*。
- en: Restoring from backups after a system crash.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统崩溃后从备份中恢复。
- en: Another option for booting quickly to a usable state is *single-user mode*.
    The idea is that the system quickly boots to a root shell instead of going through
    the whole mess of services. In the System V init, single-user mode is usually
    runlevel 1\. In systemd, it’s represented by *rescue.target*. You normally enter
    the mode with the `-s` parameter to the boot loader. You may need to type the
    root password to enter single-user mode.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个快速启动到可用状态的选项是*单用户模式*。这个方法的思想是系统快速启动到根 shell，而不是经过一系列复杂的服务。在 System V init
    中，单用户模式通常是运行级别 1。在 systemd 中，它由*rescue.target*表示。你通常通过在启动加载器中使用 `-s` 参数进入此模式。你可能需要输入
    root 密码才能进入单用户模式。
- en: The biggest problem with single-user mode is that it doesn’t offer many amenities.
    The network almost certainly won’t be available (and if it is, it will be hard
    to use), you won’t have a GUI, and your terminal may not even work correctly.
    For this reason, live images are nearly always considered preferable.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 单用户模式的最大问题是它没有提供很多便利功能。网络几乎肯定不可用（即使可以使用，也很难操作），你也不会拥有图形用户界面（GUI），甚至终端可能无法正常工作。因此，实时镜像几乎总是被认为是更好的选择。
- en: 6.9 Looking Forward
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.9 展望未来
- en: You’ve now seen the kernel and user-space startup phases of a Linux system,
    and how systemd tracks services once they’ve started. Next we’ll go a little deeper
    into user space. There are two areas to explore, starting with a number of system
    configuration files that all Linux programs use when interacting with certain
    elements of user space. Then we’ll see essential services that systemd starts.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经了解了 Linux 系统的内核和用户空间启动阶段，以及 systemd 如何在服务启动后跟踪它们。接下来，我们将更深入地探讨用户空间。首先，我们将查看一些系统配置文件，这些文件是所有
    Linux 程序在与用户空间的某些元素交互时使用的。然后，我们将看到 systemd 启动的基本服务。
