- en: '**6**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6**'
- en: DECIPHERING SECRET MESSAGES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解密秘密信息
- en: '![Image](../images/circle.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/circle.jpg)'
- en: You’ve probably sent secret, encoded notes to your friends to try to hide the
    messages from your parents or teachers. In this chapter, we’ll be doing something
    similar as we create a Secret Messages app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能曾经给朋友发送过加密的秘密便条，试图隐藏消息不被父母或老师发现。在本章中，我们将做类似的事情，创建一个秘密信息应用。
- en: Our previous app, the Hi-Lo guessing game, was all about numbers—too high, too
    low, or just right. By contrast, our Secret Messages app will focus on text. You’ll
    learn to work with text strings and manipulate character values in Java to produce
    the encoded messages.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的应用，Hi-Lo猜数字游戏，全部围绕数字展开——太高、太低或刚好。相比之下，我们的秘密信息应用将专注于文本。你将学习如何处理文本字符串，并在Java中操作字符值，以生成加密信息。
- en: The Caesar Cipher
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 凯撒密码
- en: Our app will encode and decode secret messages using the *Caesar cipher*, an
    algorithm developed more than 2,000 years ago that uses letter substitutions to
    encode messages.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用将使用*凯撒密码*来加密和解密秘密信息，凯撒密码是一种2000多年前开发的算法，通过字母替换来加密信息。
- en: '![Images](../images/f0126-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0126-01.jpg)'
- en: '*Figure 6-1: A Caesar cipher disk, showing a key value of 13*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：凯撒密码盘，显示了13的关键值*'
- en: The Caesar cipher is named for the  Roman emperor Julius Caesar (100–44 BCE).
    Historians say Caesar liked to encode his private messages, such as notes to his
    military generals, by “shifting” the letters of the alphabet. For example, the
    cipher disk shown in [Figure 6-1](ch6.xhtml#ch6fig1) shifts the alphabet by 13
    letters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码得名于罗马皇帝尤利乌斯·凯撒（公元前100–44年）。历史学家称凯撒喜欢通过“移动”字母表中的字母来加密他的私人信息，例如给军事将领的备忘录。例如，[图6-1](ch6.xhtml#ch6fig1)中的密码盘将字母表移动了13个字母。
- en: 'In the disk, the outer letters align with the inner letters they should be
    substituted with, so an *A* becomes an *N*, a *B* becomes an *O*, and so on. This
    is the cipher that created the following example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码盘中，外侧字母与它们应该替换的内侧字母对齐，因此一个*A*变成*N*，一个*B*变成*O*，依此类推。这就是生成以下示例的密码：
- en: Secret messages are so cool!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密信息真酷！
- en: Frperg zrffntrf ner fb pbby!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Secreg messagef ar so cool!
- en: 'The first line is the *plaintext*: the original, readable version of the message.
    The second line is the *ciphertext*, the encoded version of the same message.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是*明文*：消息的原始可读版本。第二行是*密文*：相同消息的加密版本。
- en: 'Try decoding this message back to its original plaintext by reversing the substitution:
    find each inner letter and substitute it with the corresponding outer letter.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 试着通过逆向替换来解码这个信息：找到每个内侧字母，并用对应的外侧字母替代。
- en: Not all Caesar ciphers are symmetric like this one. *Symmetric* means that the
    same process can be used for both encoding and decoding a message. For example,
    *F* becomes *S* when encoding by adding 13, and *S* becomes *F* when decoding
    by subtracting 13, and you can use the same disk and *key*—the number used to
    shift the letters—for both processes. The number to shift the letters by (in this
    case 13) is called a key because knowing it “unlocks” the cipher. The Secret Messages
    app we’ll build will allow us to use any key value.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有凯撒密码都像这个一样对称。*对称*意味着相同的过程可以用来同时对消息进行编码和解码。例如，*F*通过加13编码变为*S*，而通过减13解码，*S*变为*F*，你可以使用相同的密码盘和*关键*（用于移动字母的数字）进行这两个过程。用于移动字母的数字（在此为13）称为“密钥”，因为知道它就能“解锁”密码。我们将构建的秘密信息应用将允许我们使用任何密钥值。
- en: Setting Up the Secret Messages App
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置秘密信息应用
- en: 'We’ll build the Secret Messages app just like we did the Hi-Lo guessing game:
    first, we’ll create a command line version, then a GUI for the desktop, and, finally,
    an Android mobile app. The command line version will look fairly simple, as shown
    in [Figure 6-2](ch6.xhtml#ch6fig2), but it will allow us to test the secret message
    algorithm quickly and easily.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像制作Hi-Lo猜数字游戏一样制作秘密信息应用：首先，我们将创建一个命令行版本，然后是桌面GUI，最后是Android移动应用。命令行版本看起来相当简单，如[图6-2](ch6.xhtml#ch6fig2)所示，但它将使我们能够快速轻松地测试秘密信息算法。
- en: '![Images](../images/f0126-02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0126-02.jpg)'
- en: '*Figure 6-2: The command line version of the Secret Messages app*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：秘密信息应用的命令行版本*'
- en: As you can see in [Figure 6-2](ch6.xhtml#ch6fig2), the program asks the user
    to enter a message to encode or decode, followed by a secret key value. The program
    then responds with the encoded message. Note that when we start coding the app,
    the entire message will be encoded, including spaces and punctuation. In the final
    version, we’ll add some logic to encode only letters, as shown in [Figure 6-2](ch6.xhtml#ch6fig2).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 6-2](ch6.xhtml#ch6fig2)所示，程序提示用户输入要编码或解码的消息，随后是一个密钥值。程序然后会返回编码后的消息。请注意，当我们开始编码应用程序时，整个消息都会被编码，包括空格和标点符号。在最终版本中，我们会添加一些逻辑，只对字母进行编码，如[图
    6-2](ch6.xhtml#ch6fig2)所示。
- en: '*Creating the Secret Messages Project in Eclipse*'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*在 Eclipse 中创建 Secret Messages 项目*'
- en: Let’s begin by opening Eclipse. If you still have files open from previous projects,
    close those files now. To create a new Java Project, go to **File** ▸ **New**
    ▸ **Java Project** and name the project *SecretMessages*. Click **Finish**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先打开 Eclipse。如果你还有之前项目的文件未关闭，现在请关闭那些文件。要创建一个新的 Java 项目，请选择 **文件** ▸ **新建**
    ▸ **Java 项目** 并命名项目为 *SecretMessages*。点击 **完成**。
- en: In the Package Explorer pane, expand the *SecretMessages* project folder to
    see the *src* folder. Right-click the *src* folder and go to **New** ▸ **Class**
    to create a new Java source code file, which you’ll also name *SecretMessages*.
    Select the checkbox to create a `main()` method, as shown in [Figure 6-3](ch6.xhtml#ch6fig3).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在包资源管理器面板中，展开 *SecretMessages* 项目文件夹，查看 *src* 文件夹。右键点击 *src* 文件夹，选择 **新建** ▸
    **类** 来创建一个新的 Java 源代码文件，你也将该文件命名为 *SecretMessages*。选择勾选框以创建一个 `main()` 方法，如[图
    6-3](ch6.xhtml#ch6fig3)所示。
- en: '![Images](../images/f0127-01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0127-01.jpg)'
- en: '*Figure 6-3: Create a new Java project, with a new class file called* SecretMessages,
    *and select the checkbox to create a main() method stub.*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：创建一个新的 Java 项目，并创建一个名为* SecretMessages *的新类文件，同时选择勾选框来创建一个 main() 方法的代码框架。*'
- en: Click **Finish**, and you’ll see the *SecretMessages.java* file in the main
    window in Eclipse. Let’s get started coding the Secret Messages app!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **完成**，你将在 Eclipse 的主窗口中看到 *SecretMessages.java* 文件。让我们开始编码 Secret Messages
    应用程序吧！
- en: '*Beginning to Code SecretMessages.java*'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*开始编写 SecretMessages.java 代码*'
- en: 'At the top of the *SecretMessages.java* file, above the `public class SecretMessages`
    declaration, add the `import` statement for `java.util.Scanner` so we can ask
    the user for input:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *SecretMessages.java* 文件的顶部，即 `public class SecretMessages` 声明之上，添加 `import`
    语句引入 `java.util.Scanner`，以便我们可以请求用户输入：
- en: import java.util.Scanner;
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.Scanner;
- en: public class SecretMessages {
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: public class SecretMessages {
- en: public static void main(String[] args) {
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: ➊ Scanner scan = new Scanner(System.in);
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ Scanner scan = new Scanner(System.in);
- en: ➋ System.out.println("Enter a message to encode or decode:");
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ System.out.println("请输入要编码或解码的消息：");
- en: '}'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Inside the `main()` method, at ➊, we set up a `Scanner` object named `scan`.
    Then, at ➋, we prompt the user to enter a message to encode or decode.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 方法内，在 ➊ 处，我们设置一个名为 `scan` 的 `Scanner` 对象。然后，在 ➋ 处，我们提示用户输入要编码或解码的消息。
- en: 'After the user prompt, we’ll create a `String` variable, called `message`,
    to accept the line of text the user enters:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户提示后，我们将创建一个名为 `message` 的 `String` 变量，用于接受用户输入的文本：
- en: System.out.println("Enter a message to encode or decode:");
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("请输入要编码或解码的消息：");
- en: String message = scan.nextLine();
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: String message = scan.nextLine();
- en: Then, we get the user’s next full line of input, up to an ENTER or RETURN character,
    using the `nextLine()` method of the `scan` object, and we store it in the string
    `message`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `scan` 对象的 `nextLine()` 方法获取用户的下一行完整输入，直到按下 ENTER 或 RETURN 键，并将其存储在字符串
    `message` 中。
- en: So far, the app can ask the user for a message and scan that message into a
    variable. Now we need to learn how to manipulate the characters inside a string
    to create an encoded version of the message. Save your file before continuing
    to the next section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，应用程序可以请求用户输入消息，并将该消息扫描到一个变量中。现在我们需要学习如何操作字符串中的字符，以便创建消息的编码版本。在继续下一部分之前，请保存你的文件。
- en: '*Messing with Strings*'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*处理字符串*'
- en: Up to this point, the Secret Messages app looks pretty similar to the Hi-Lo
    guessing game app. We set up an input scanner, prompt the user for some input,
    scan the console for the user’s response, and then capture the input in a variable.
    What’s going to make the Secret Messages app different is its ability to work
    with the characters inside the string.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Secret Messages 应用程序看起来与 Hi-Lo 猜数字游戏应用程序非常相似。我们设置了一个输入扫描器，提示用户输入内容，扫描控制台获取用户的响应，并将输入内容存储到一个变量中。使
    Secret Messages 应用程序与众不同的是，它能够处理字符串中的字符。
- en: The Caesar cipher command line app will take a lot of steps to complete, so
    we’ll build our app in *iterations*. That means that instead of writing out the
    whole app all at once and hoping the code works in the end, we’ll create our app
    bit by bit, or one iteration at a time, and test it as we go along so that we’ll
    have a functioning app at each point. Each iteration might not have all the features
    we need, but we’ll eventually get to the complete, full-featured app.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码命令行应用程序将需要很多步骤才能完成，因此我们将以*迭代*的方式构建我们的应用程序。这意味着，和一次性写出整个应用程序并希望最终代码能正常工作不同，我们将一点一点地构建应用程序，或者每次迭代一次，并在过程中进行测试，以确保每个阶段都有一个功能正常的应用程序。每次迭代可能没有我们所需的所有功能，但我们最终会得到一个完整且功能丰富的应用程序。
- en: We’ll need to use text processing to manipulate the inputted string into an
    output string. To begin working with strings of text in Java, we’ll build a simple
    message reverser. In other words, we’ll take the message the user entered and
    then give it back to them with the letters in reverse order. So, for example,
    `"Meet me at the arcade at 5pm"` would become `"mp5 ta edacra eht ta em teeM"`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用文本处理来将输入的字符串转换为输出字符串。为了开始在Java中处理字符串，我们将构建一个简单的消息反转器。换句话说，我们将获取用户输入的消息，并将其反向输出。举个例子，`"Meet
    me at the arcade at 5pm"`将变成`"mp5 ta edacra eht ta em teeM"`。
- en: 'First, we create a variable called `output` for the reversed string and set
    it equal to an empty string:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`output`的变量来存储反转后的字符串，并将其初始化为空字符串：
- en: String message = scan.nextLine();
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: String message = scan.nextLine();
- en: String output = "";
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: String output = "";
- en: 'We’ll need a loop to run through the characters in the message. We can choose
    a `for` loop for convenience, because we know the number of characters in the
    message. (Later, we’ll use the `message.length()` method to tell us how many characters
    the message contains.) A `for` loop declaration in Java needs to do three things:
    *initialize* a loop variable, test a *condition* to keep going, and *update* the
    loop variable before the next iteration. We place semicolons between each of the
    three parts to separate them. The syntax looks like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个循环来遍历消息中的字符。为了方便，我们可以选择使用`for`循环，因为我们知道消息中的字符数。（稍后，我们将使用`message.length()`方法来告诉我们消息包含多少个字符。）Java中的`for`循环声明需要做三件事：*初始化*一个循环变量，测试*条件*以继续循环，并在下一次迭代前*更新*循环变量。我们在这三部分之间放置分号来分隔它们。语法如下所示：
- en: for ( initialization; condition; update ) { body }
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: for ( initialization; condition; update ) { body }
- en: 'For example, open JShell and enter this code to create a `for` loop:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，打开JShell并输入以下代码来创建一个`for`循环：
- en: jshell> for ( int x = 0; x < 10; x++ ) { System.out.println(x); }
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: jshell> for ( int x = 0; x < 10; x++ ) { System.out.println(x); }
- en: This loop will print the numbers `0` through `9`. The initialization sets the
    first looping variable `x` to `0`. The condition tests to make sure `x` is less
    than `10` before proceeding. Finally, the update adds 1 to `x` after each pass
    through the loop. `x++` uses a shortcut called the *increment operator* because
    it increments, or adds 1 to, `x` each time through the loop. `x++` is equivalent
    to the statement `x = x` `+` `1`. In this example, the `for` loop prints the value
    of `x` each time through the loop, repeating 10 times and stopping when `x` is
    no longer less than `10`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环将打印从`0`到`9`的数字。初始化将第一个循环变量`x`设置为`0`。条件测试确保在继续之前`x`小于`10`。最后，更新操作在每次通过循环后将`x`加1。`x++`使用了一种快捷方式，称为*自增操作符*，因为它每次通过循环时都会将`x`加1。`x++`等同于语句`x
    = x + 1`。在这个示例中，`for`循环在每次通过循环时打印`x`的值，重复执行10次，当`x`不再小于`10`时停止。
- en: 'So, to reverse the characters in the message string, we might initialize a
    variable to the position number, or *index*, of the last character in the string
    and then loop through the characters from last to first (in reverse order), going
    backward through the string. In our example, this would look like:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，为了反转消息字符串中的字符，我们可能会初始化一个变量，设置为字符串中最后一个字符的位置编号或*索引*，然后从最后一个字符到第一个字符（反向顺序）循环遍历字符串。在我们的示例中，这将是：
- en: for ( int x = message.length()-1; x >= 0; x-- ) { }
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: for ( int x = message.length()-1; x >= 0; x-- ) { }
- en: The character positions in a string in Java are numbered from `0` (the index
    of the first character) to the length minus 1\. The first character is at index
    `0`, and the *n*th character in a string is at index (*n* − 1).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Java中字符串的字符位置从`0`（第一个字符的索引）到长度减1。第一个字符的索引是`0`，字符串中的第*n*个字符的索引是(*n* − 1)。
- en: In [Figure 6-4](ch6.xhtml#ch6fig4), the first 10 characters of our sample message
    are shown. The index of each character in the string is shown below the character.
    The first letter, `M`, is at index `0`, the first `e` is at index `1`, and so
    on. Notice that spaces count as characters—there are two spaces shown here, at
    indexes `4` and `7`. The 10th character in the message is at index `9`, the letter
    `t`. This continues all the way to the last character in the message, at index
    `message.length()-1`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6-4](ch6.xhtml#ch6fig4)中，显示了我们示例消息的前10个字符。每个字符在字符串中的索引值显示在字符下方。第一个字母`M`的索引为`0`，第一个`e`的索引为`1`，依此类推。注意，空格也算作字符——这里有两个空格，分别位于索引`4`和`7`。消息中的第10个字符位于索引`9`，即字母`t`。这个过程一直持续到消息中的最后一个字符，其索引为`message.length()-1`。
- en: '![Images](../images/f0129-01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0129-01.jpg)'
- en: '*Figure 6-4: The characters in a message labeled with their indexes*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：消息中字符的索引标记*'
- en: 'We want to start our reversed message at the end of the string, so we initialize
    `x` to the `message.length()-1`, the index of the last character in the message.
    The condition is `x >=` `0` because we want to keep going all the way down to
    the first character of the message, at index `0`. Finally, the update is `x--`
    because we’re stepping backward through the string. The opposite of `x++`, `x--`
    uses the *decrement operator*, which decreases the value of `x` by 1 each time.
    Come back into Eclipse and begin writing the `for` loop just below the previous
    line of code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望从字符串的末尾开始反转消息，因此我们将`x`初始化为`message.length()-1`，即消息中最后一个字符的索引。条件为`x >= 0`，因为我们希望一直执行直到消息的第一个字符，索引为`0`。最后，更新为`x--`，因为我们是从字符串末尾向前遍历。`x--`与`x++`相反，使用的是*递减运算符*，每次将`x`的值减1。返回到Eclipse并开始在前一行代码下编写`for`循环：
- en: String output = "";
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: String output = "";
- en: for ( int x = message.length()-1; x >= 0; x-- ) {
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: for ( int x = message.length()-1; x >= 0; x-- ) {
- en: '}'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'To get the character at a specific position in a string, we use the `charAt()`
    (“character at”) method and give it the index location of the character we want.
    To append or add a character to a string, we use the `+` operator. Putting those
    together, we can build the reverse version of the string `message` and store it
    in the string `output`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取字符串中特定位置的字符，我们使用`charAt()`（“字符在”）方法，并给它我们想要的字符的索引位置。要将字符附加或添加到字符串中，我们使用`+`运算符。将这些结合起来，我们可以构建字符串`message`的反转版本，并将其存储在字符串`output`中：
- en: for ( int x = message.length()-1; x >= 0; x-- ) {
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: for ( int x = message.length()-1; x >= 0; x-- ) {
- en: output += message.charAt(x);
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: output += message.charAt(x);
- en: '}'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The body of the `for` loop is a single line. We’re getting the character at
    the `x`th index of `message` and adding it to `output`. Remember to use open and
    close braces around the body of the `for` loop, because we’ll want to add more
    lines inside the loop as the app grows.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的主体是一行代码。我们获取`message`中索引为`x`的字符，并将其添加到`output`中。记得在`for`循环的主体周围加上大括号，因为随着应用程序的增长，我们将希望在循环内添加更多行。'
- en: Now we just need to show the output message to the screen, which we can do with
    `System.out.println(output)`. The full message-reversing iteration of the app
    is shown in [Listing 6-1](ch6.xhtml#ch6list1).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要将输出消息显示到屏幕上，可以通过`System.out.println(output)`来完成。应用程序的完整消息反转迭代展示在[清单6-1](ch6.xhtml#ch6list1)中。
- en: import java.util.Scanner;
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.Scanner;
- en: public class SecretMessages {
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: public class SecretMessages {
- en: public static void main(String[] args) {
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: Scanner scan = new Scanner(System.*in*);
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Scanner scan = new Scanner(System.*in*);
- en: System.*out*.println("Enter a message to encode or decode:");
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: System.*out*.println("请输入要编码或解码的消息：");
- en: String message = scan.nextLine();
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: String message = scan.nextLine();
- en: String output = "";
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: String output = "";
- en: for ( int x = message.length()-1; x >= 0; x-- ) {
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: for ( int x = message.length()-1; x >= 0; x-- ) {
- en: output += message.charAt(x);
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: output += message.charAt(x);
- en: '}'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: System.*out*.println(output);
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: System.*out*.println(output);
- en: '}'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '*Listing 6-1: The first iteration of the Secret Messages app reverses the characters
    in the user’s message.*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-1：秘密消息应用的第一次迭代反转了用户消息中的字符。*'
- en: You can run the program in Eclipse and test it with your own message, as shown
    in [Figure 6-5](ch6.xhtml#ch6fig5). This isn’t our finished Secret Messages app,
    but it does make the message harder to read and easy to decode.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Eclipse中运行程序，并使用你自己的消息进行测试，如[图6-5](ch6.xhtml#ch6fig5)所示。这还不是我们完成的秘密消息应用程序，但它确实使消息变得更难读取，并且容易解码。
- en: '![Images](../images/f0131-01.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0131-01.jpg)'
- en: '*Figure 6-5: Run the program and enter your own message to reverse in the console
    window at the bottom of the screen.*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：运行程序并在屏幕底部的控制台窗口中输入您自己的消息进行反转。*'
- en: You can even decode a message by copying the encoded, reversed message and pasting
    it into the program, as shown in [Figure 6-6](ch6.xhtml#ch6fig6). So you can type
    a message, encode it, and paste it into a message to a friend, and then they can
    decode it by pasting the encoded message into the same program. You’ve built your
    first secret message encoder!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以通过复制编码后的反转消息并将其粘贴到程序中来解码消息，如[图6-6](ch6.xhtml#ch6fig6)所示。因此，您可以输入一条消息，编码它，然后将其粘贴到发送给朋友的消息中，之后他们可以通过将编码后的消息粘贴到相同的程序中来解码。您已经构建了您的第一个秘密信息编码器！
- en: '![Images](../images/f0131-02.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0131-02.jpg)'
- en: '*Figure 6-6: Copy and paste an encoded message into the running program to
    decode it.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：将编码后的消息复制并粘贴到正在运行的程序中进行解码。*'
- en: This version of the app is simple enough that you can read the messages without
    running them through the program, so it’s not a very secure way to send messages
    to your friends. But you did learn how to loop through a string of text using
    a `for` loop, how to get the string’s `length()`, how to access a specific character
    at a given index or position in the string using `charAt()`, and how to add characters
    to the end of a string using the `+` operator. In the next section, you’ll learn
    how to change the values of the individual characters in the message to make it
    harder to read, but still easy for our program to decode.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的应用足够简单，您可以直接阅读消息，而无需通过程序处理，因此它并不是一种非常安全的方式来向朋友发送消息。但您确实学会了如何使用`for`循环遍历字符串、如何获取字符串的`length()`、如何使用`charAt()`访问字符串中给定索引或位置的特定字符，以及如何使用`+`运算符将字符添加到字符串的末尾。在下一部分，您将学习如何改变消息中每个字符的值，使其更难阅读，但仍然容易让我们的程序解码。
- en: Characters and Values in Java
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java中的字符和数值
- en: Building a better secret message encoder requires the ability to work with character
    values in strings of text. For the Caesar cipher, we need to be able to shift
    those values—for example, changing an *A* to an *N*, and an *N* to an *A*. To
    do this, you need to understand how characters are stored in a computer.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个更好的秘密信息编码器需要能够操作字符串中文本字符的值。对于凯撒密码，我们需要能够移动这些值——例如，将*A*变为*N*，将*N*变为*A*。为此，您需要了解字符在计算机中的存储方式。
- en: 'In Java, individual characters, such as `''A''`, can be stored in their own
    data type: `char`. Notice that we use single quotation marks to contain character
    values. The `charAt()` method of a string returns a `char` value representing
    a single character. Java uses 16-bit Unicode characters. *Unicode* is an international
    character set containing thousands of characters and symbols from all over the
    world that are represented as numeric values. The `char` type is a way to store
    Unicode characters, such as `''A''`, `''ñ''`, and `''ç''`, by their numeric values.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，单个字符，例如`'A'`，可以存储在自己的数据类型中：`char`。注意我们使用单引号来包含字符值。字符串的`charAt()`方法返回一个`char`值，表示单个字符。Java使用16位Unicode字符。*Unicode*是一种国际字符集，包含来自世界各地的成千上万的字符和符号，它们以数字值的形式表示。`char`类型是一种存储Unicode字符的方式，例如`'A'`、`'ñ'`和`'ç'`，它们按数字值存储。
- en: We can add to a Unicode `char` value in the same way we can add to an `int`
    variable. With the Secret Messages app, we want to add the `char` value for `'A'`
    (`65`) to the key (`13`) to get the new `char` value (`78`), which represents
    the encoded letter (`'N'`).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像给`int`变量加值一样对Unicode `char`值进行加法操作。在《秘密消息》应用中，我们希望将`'A'`的`char`值（`65`）加到密钥（`13`）上，以获得新的`char`值（`78`），即表示编码后的字母（`'N'`）。
- en: 'For our second iteration of the app, let’s begin coding the Caesar cipher by
    setting up a `char` variable called `key` and storing the value `13` in it. We’ll
    add this below the `String output` line:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用的第二个版本中，首先通过设置一个名为`key`的`char`变量，并将值`13`存储在其中，来开始编写凯撒密码。我们将在`String output`行下方添加这一行：
- en: String output = "";
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: String output = "";
- en: char key = 13;
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: char key = 13;
- en: 'We also need to modify the `for` loop to go from the beginning of the string
    to the end. We’re starting at index `0` this time and moving through the string
    while `x` is less than `message.length()`. Each time we repeat the loop, we’re
    adding 1 to `x`, the character position. Here is the new `for` loop:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改`for`循环，以便从字符串的开头遍历到结尾。这一次我们从索引`0`开始，并在`x`小于`message.length()`时继续遍历字符串。每次重复循环时，我们都会将1加到`x`，即字符位置。以下是新的`for`循环：
- en: char key = 13;
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: char key = 13;
- en: for ( int x = 0; x < message.length(); x++ ) {
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: for ( int x = 0; x < message.length(); x++ ) {
- en: 'Finally, instead of adding the original characters of the `message` string
    to the `output` string, we need to add the key value to each character, making
    sure we get a `char` value that we can add to the output string:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后， instead of将`message`字符串的原始字符添加到`output`字符串中，我们需要将密钥值添加到每个字符上，确保我们获得一个`char`值，然后可以将其添加到输出字符串中：
- en: output += (char)(message.charAt(x) + key);
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: output += (char)(message.charAt(x) + key);
- en: We’ve added the key value to each character in the `message` string, and then
    we’ve taken that sum and cast it to a `char`. Putting `char` in parentheses before
    an expression forces the value to its right to fit into a `char` data type, or
    *casts* the value to that type. We have to cast the output value to `(char)` here
    because in Java, the right side of this equation may result in an `int` value
    by default. [Listing 6-2](ch6.xhtml#ch6list2) shows the program with these changes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将密钥值添加到`message`字符串中的每个字符上，然后将这个和转换成了一个`char`。在表达式前加上`char`强制将其右侧的值转换为`char`数据类型，或者说是*类型转换*。我们必须将输出值转换为`(char)`，因为在Java中，这个等式的右侧默认会得到一个`int`值。[Listing
    6-2](ch6.xhtml#ch6list2)展示了这些更改后的程序。
- en: import java.util.Scanner;
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.Scanner;
- en: public class SecretMessages {
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: public class SecretMessages {
- en: public static void main(String[] args) {
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: Scanner scan = new Scanner(System.in);
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Scanner scan = new Scanner(System.in);
- en: System.out.println("Enter a message to encode or decode:");
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("请输入要编码或解码的消息：");
- en: String message = scan.nextLine();
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: String message = scan.nextLine();
- en: String output = "";
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: String output = "";
- en: char key = 13;
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: char key = 13;
- en: for ( int x = 0; x < message.length(); x++ ) {
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: for ( int x = 0; x < message.length(); x++ ) {
- en: output += (char)(message.charAt(x) + key);
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: output += (char)(message.charAt(x) + key);
- en: '}'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: System.out.println(output);
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(output);
- en: '}'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '*Listing 6-2: The Secret Messages app is still short at just 14 lines, but
    it encodes strings of text now!*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-2: 秘密信息应用程序虽然只有14行，但它现在可以编码文本字符串了！*'
- en: 'If you run the program at this point and enter a message, you should see output
    like the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时运行程序并输入一条消息，您应该会看到类似以下的输出：
- en: 'Enter a message to encode or decode:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请输入要编码或解码的消息：
- en: Secret messages are so cool!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密信息真酷！
- en: '`rp□r?-zr??ntr?-n□r-?|-p||y.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`rp□r?-zr??ntr?-n□r-?|-p||y.'
- en: The message is encoded, but it’s not quite what we were expecting. First of
    all, we’re encoding all characters, including spaces and punctuation marks. Second,
    we’re not wrapping around to the front of the alphabet yet, because we’re *always*
    adding 13 to every character, not taking into account the fact that the letters
    at the end need to wrap back around to the beginning of the alphabet, resulting
    in odd symbols and unprintable characters in the output message. We’ll cover both
    of these issues in the next section. Before moving on, save your program.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 消息已被编码，但它并不是我们预期的那样。首先，我们正在对所有字符进行编码，包括空格和标点符号。其次，我们还没有进行字母表的回绕，因为我们*总是*对每个字符加13，而没有考虑到末尾的字母需要回绕到字母表的开头，这导致了输出消息中出现奇怪的符号和无法打印的字符。我们将在下一节解决这两个问题。在继续之前，请保存您的程序。
- en: Encoding Just the Letters
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只编码字母
- en: Our second iteration of the Secret Messages app gave us an encoded message,
    but it lacks some features that we want in the final app. The upgrades needed
    to create the final app will require some logic in the form of `if` statements
    and conditions to encode only letters (not spaces or punctuation) and to make
    the alphabet wrap around during encoding. We’ll tackle these improvements in our
    third iteration.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二版秘密信息应用给我们带来了一个已编码的消息，但它缺少了一些我们在最终应用中想要的功能。为了创建最终版本的应用，我们需要一些逻辑，比如`if`语句和条件，用于只对字母（而不是空格或标点符号）进行编码，并在编码时使字母表回绕。我们将在第三版中处理这些改进。
- en: 'First, we want to perform some tests on each character in the input message
    instead of just adding the character directly to the output message. Let’s change
    the body of the `for` loop as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们希望对输入消息中的每个字符执行一些测试，而不是直接将字符添加到输出消息中。让我们按如下方式更改`for`循环的主体：
- en: for ( int x = 0; x < message.length(); x++ ) {
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: for ( int x = 0; x < message.length(); x++ ) {
- en: char input = message.charAt(x);
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: char input = message.charAt(x);
- en: '}'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The character stored in `input` will be the first character in `message`, then
    the second, and so on. We need to test each character one by one to check whether
    it’s a character that we want to encode. We want to encode letters by adding the
    key value to them and wrapping to the front of the alphabet if necessary. Otherwise,
    if the character is a space or punctuation, we’ll leave the character unchanged
    and add it to the output message.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 `input` 中的字符将是 `message` 中的第一个字符，然后是第二个，以此类推。我们需要逐一测试每个字符，检查它是否是我们想要编码的字符。我们希望通过将密钥值加到字母上来编码字母，并在必要时将其回绕到字母表的前面。否则，如果字符是空格或标点符号，我们将保持字符不变并将其添加到输出消息中。
- en: 'Let’s add the following `if` statement in the body of our `for` loop:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `for` 循环体内添加以下 `if` 语句：
- en: char input = message.charAt(x);
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: char input = message.charAt(x);
- en: if (input >= 'A' && input <= 'Z')
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: if (input >= 'A' && input <= 'Z')
- en: In the condition inside the `if` statement, we can use either `65` (the value
    of `'A'`) or the character literal `'A'` itself. The condition tests whether the
    character stored in `input` is greater than or equal to `'A'` and less than or
    equal to `'Z'`—in other words, whether `input` contains an uppercase letter. If
    this condition is `true`, we want to add the key value to `input` to shift it,
    producing the Caesar cipher value to substitute for that letter. Notice that this
    is only for uppercase letters—lowercase letters will require a separate test.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `if` 语句内的条件中，我们可以使用 `65`（即 `'A'` 的值）或者字符字面量 `'A'` 本身。该条件测试 `input` 中存储的字符是否大于或等于
    `'A'` 且小于或等于 `'Z'`——换句话说，是否 `input` 包含一个大写字母。如果此条件为 `true`，我们希望将密钥值加到 `input`
    上以进行位移，从而生成凯撒密码的值来替代该字母。注意，这仅适用于大写字母——小写字母将需要另行测试。
- en: 'Now, in the body of the `if` statement, we’ll add the key value to the `input`
    character to encode the letter. This is also where we’ll handle wrapping around
    to the front of the alphabet if the key value shifts a letter past `''Z''`. So
    the code inside the `for` loop will become:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `if` 语句的主体中，我们将密钥值加到 `input` 字符上以编码字母。这也是我们处理回绕到字母表前面（如果密钥值使字母越过 `'Z'`）的地方。因此，`for`
    循环内的代码将变为：
- en: for ( int x = 0; x < message.length(); x++ ) {
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: for ( int x = 0; x < message.length(); x++ ) {
- en: char input = message.charAt(x);
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: char input = message.charAt(x);
- en: if (input >= 'A' && input <= 'Z')
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: if (input >= 'A' && input <= 'Z')
- en: '{'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: ➊ input += key;
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ input += key;
- en: ➋ if (input > 'Z')
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ if (input > 'Z')
- en: ➌ input -= 26;
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ input -= 26;
- en: '}'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ➍ output += input;
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ output += input;
- en: '}'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: After getting the next character from the message and checking to make sure
    it’s an uppercase letter, we encode the letter by adding the key to it ➊. Then,
    we check whether adding the key value pushed the letter past `Z` ➋. If so, at
    ➌ we subtract `26` (the number of letters in the English alphabet) from the encoded
    `input` value to wrap it back around to the front of the alphabet. Finally, we
    can add the resulting `input` character to the `output` string ➍.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取消息中的下一个字符并确保它是大写字母之后，我们通过将密钥加到字母上来对其进行编码 ➊。然后，我们检查添加密钥后，字母是否超过了`Z` ➋。如果是这样，在
    ➌ 我们从编码后的`input`值中减去`26`（即英文字母的个数），以便将其回绕到字母表的前面。最后，我们可以将结果 `input` 字符添加到 `output`
    字符串中 ➍。
- en: 'If you run the program now, you can encode an all-uppercase message as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行该程序，你可以像下面这样编码一个全大写字母的消息：
- en: 'Enter a message to encode or decode:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个要编码或解码的消息：
- en: SECRET MESSAGES ARE SO COOL!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密信息真是太酷了！
- en: FRPERG  ZRFFNTRF  NER FB  PBBY!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: FRPERG  ZRFFNTRF  NER FB  PBBY!
- en: Notice the punctuation and spaces stay the same, and all uppercase letters are
    shifted by 13 characters, wrapping around so that `S` becomes `F`, and so on.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，标点符号和空格保持不变，所有大写字母会被移动 13 个字符，回绕后 `S` 变为 `F`，依此类推。
- en: Encoding the lowercase letters is logically identical to handling the uppercase
    letters. You can copy and paste the same `if` statement code, but change the `A`
    and `Z` to lowercase letters. Don’t forget to add an `else` before the second
    `if` statement. Try it yourself; but if you get stuck, the complete code is provided
    in [Listing 6-3](ch6.xhtml#ch6list3) in the next section.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对小写字母的编码在逻辑上与处理大写字母相同。你可以复制粘贴相同的 `if` 语句代码，但将 `A` 和 `Z` 更改为小写字母。不要忘记在第二个 `if`
    语句前加上 `else`。自己试试看；但如果遇到困难，完整的代码在下一节的 [Listing 6-3](ch6.xhtml#ch6list3) 中提供。
- en: '**ENCODING MESSAGES IN OTHER LANGUAGES**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**编码其他语言的信息**'
- en: The version of the program we’re writing will only work consistently for basic
    Latin characters from *A* to *Z* and *a* to *z*. If your preferred language is
    not English, however, you can adjust the program as long as Unicode has the alphabet
    or symbols of your language grouped together in a contiguous set, one after the
    other. You can test for the first and last character of your preferred language
    just like the English encoder/decoder in this chapter. If your language either
    isn’t provided in a complete set or uses some of the basic Latin alphabet plus
    certain other characters (like how Spanish uses the ñ and French uses the ç, along
    with other accented characters), you could add the key to any character as we
    did in [Listing 6-2](ch6.xhtml#ch6list2). Optionally, you could leave spaces in
    the message by testing with the `Character.isSpace()` method and encode everything
    except spaces. Play with different methods for the alphabet or language of your
    choice to find the encoding scheme that works best for you. Change the program
    and make it do something new—that’s the best way to learn!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在编写的程序版本只会对基本的拉丁字母（从 *A* 到 *Z* 和 *a* 到 *z*）始终如一地工作。然而，如果你的首选语言不是英语，你可以调整程序，只要
    Unicode 中有该语言的字母或符号，并且它们按顺序排布在一个连续的集合中。你可以像处理英语编码器/解码器那样，测试你所选语言的首尾字符。如果你的语言的字符集没有提供完整的字母集，或者使用了基本拉丁字母的部分字符加上某些其他字符（例如西班牙语使用的
    ñ 和法语使用的 ç 以及其他带重音符号的字符），你可以像在[列表 6-2](ch6.xhtml#ch6list2)中一样，给任何字符添加密钥。你也可以选择通过使用
    `Character.isSpace()` 方法在消息中保留空格，编码除了空格以外的所有内容。你可以尝试不同的方法，针对你选择的字母表或语言，找到最适合你的编码方案。修改程序并让它做一些新事情——这是学习的最佳方式！
- en: Closing the Scanner
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭 Scanner
- en: 'There’s one touch we can add here that you may recall from [Chapter 2](ch2.xhtml#ch2).
    The `Scanner` variable `scan` should have a yellow underline, indicating a warning
    in Eclipse telling you there is a resource leak. When you hover your mouse over
    the warning, it pops up with the message `''scan'' is never closed`. Remember
    that we need to close all input/output resources, such as `Scanner` objects, when
    we’re finished using them. To do so, we’ll add the command `scan.close()` right
    after the final `System.out.println` in the `main()` method of the program:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个可以添加的细节，你可能会从[第 2 章](ch2.xhtml#ch2)中回忆起。`Scanner`变量`scan`应该有一个黄色下划线，表示在
    Eclipse 中出现警告，告诉你存在资源泄漏。当你将鼠标悬停在警告上时，会弹出一条信息：`'scan' is never closed`。记住，当我们使用完所有的输入/输出资源（如
    `Scanner` 对象）后，需要关闭它们。为此，我们将在程序的 `main()` 方法中最后一个 `System.out.println` 后添加命令 `scan.close()`：
- en: System.out.println(output);
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(output);
- en: scan.close();
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: scan.close();
- en: Adding this line removes the resource leak warning. See [Listing 6-3](ch6.xhtml#ch6list3)
    for a fully functional Caesar cipher encoder and decoder with a key value of `13`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这一行可以消除资源泄漏警告。参见[列表 6-3](ch6.xhtml#ch6list3)，该列表展示了一个功能完善的凯撒密码编码器和解码器，密钥值为
    `13`。
- en: import java.util.Scanner;
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.Scanner;
- en: public class SecretMessages {
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: public class SecretMessages {
- en: public static void main(String[] args) {
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: Scanner scan = new Scanner(System.*in*);
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Scanner scan = new Scanner(System.*in*);
- en: System.*out*.println("Enter a message to encode or decode:");
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: System.*out*.println("请输入要编码或解码的消息：");
- en: String message = scan.nextLine();
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: String message = scan.nextLine();
- en: String output = "";
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: String output = "";
- en: char key = 13;
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: char key = 13;
- en: for ( int x = 0; x < message.length(); x++ ) {
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: for ( int x = 0; x < message.length(); x++ ) {
- en: char input = message.charAt(x);
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: char input = message.charAt(x);
- en: if (input >= 'A' && input <= 'Z')
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: if (input >= 'A' && input <= 'Z')
- en: '{'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: input += key;
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: input += key;
- en: if (input > 'Z')
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: if (input > 'Z')
- en: input -= 26;
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: input -= 26;
- en: '}'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else if (input >= 'a' && input <= 'z')
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: else if (input >= 'a' && input <= 'z')
- en: '{'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: input += key;
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: input += key;
- en: if (input > 'z')
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: if (input > 'z')
- en: input -= 26;
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: input -= 26;
- en: '}'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: output += input;
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: output += input;
- en: '}'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: System.*out*.println(output);
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: System.*out*.println(output);
- en: scan.close();
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: scan.close();
- en: '}'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '*Listing 6-3: This version of the app is a fully functional Caesar cipher encoder
    and decoder with a key value of 13*.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-3：此版本的应用程序是一个功能完善的凯撒密码编码器和解码器，密钥值为 13*。'
- en: 'Try it out by first running the program and encoding a message. Then copy the
    encoded output and run the program again; when prompted, paste the encoded message
    and press ENTER. The program will respond with the original, decoded message.
    Here are two sample runs of the program in which I’ve copied the encoded output
    from the first message to use as the input for the second run:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过首先运行程序并编码一条消息。然后复制编码后的输出并再次运行程序；当提示时，粘贴编码后的消息并按 ENTER 键。程序将以原始的解码消息进行回应。以下是程序的两次示例运行，我已将第一次消息的编码输出复制，作为第二次运行的输入：
- en: 'Enter a message to encode or decode:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请输入一个消息进行编码或解码：
- en: Secret messages are so cool!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密消息真是太酷了！
- en: Frperg zrffntrf ner fb pbby!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Frperg zrffntrf ner fb pbby!
- en: 'Enter a message to encode or decode:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请输入一个消息进行编码或解码：
- en: Frperg zrffntrf ner fb pbby!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Frperg zrffntrf ner fb pbby!
- en: Secret messages are so cool!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密消息真是太酷了！
- en: Because the Caesar cipher is symmetric, running the program on an encoded message
    decodes the message back to its original plaintext. This means you can run this
    program as it’s written in [Listing 6-3](ch6.xhtml#ch6list3) to encode a message,
    send the encoded version to a friend who also has the encoder program, and have
    them decode your message instantly.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于凯撒密码是对称的，运行该程序对加密后的消息进行解码，会将消息恢复到原始的明文。这意味着，你可以按照[清单 6-3](ch6.xhtml#ch6list3)中的方式运行该程序来加密消息，将加密后的版本发送给也有解码程序的朋友，并让他们立即解码你的消息。
- en: Unfortunately, this means *anyone* running the program (or anyone who figures
    out the cipher) can decode your messages just as quickly as you can. For our next
    iteration, let’s make the code a little more interesting by allowing the user
    to set their own key value. Then, you can pick a different key to send messages
    to different people, or you can use a new key every time.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这意味着*任何人*运行该程序（或任何能破解密码的人）都能像你一样迅速解码你的消息。为了下一版，我们将通过允许用户设置自己的密钥值，使代码更加有趣。这样，你就可以为不同的人选择不同的密钥，或者每次使用一个新密钥发送消息。
- en: Adding a Custom Key Value
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加自定义密钥值
- en: The secret message encoder works well with a key value of `13`, but what if
    we want to encode and decode messages using a different key value, such as `3`
    (the classical Caesar cipher shift) or `5` or `25`?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密消息编码器在`13`的密钥值下工作良好，但如果我们想用不同的密钥值来编码和解码消息，比如`3`（经典凯撒密码位移）或`5`或`25`，该怎么办呢？
- en: 'We’ll need to prompt the user for a key value in addition to the message. We
    can do that by adding a prompt before the line that creates the `char` key variable:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提示用户输入一个密钥值，并附加在消息之前。我们可以通过在创建`char`类型的`key`变量之前添加提示来实现：
- en: String output = "";
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: String output = "";
- en: System.out.println("Enter a secret key (-25 to 25):");
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("请输入一个秘密密钥（-25 到 25）：");
- en: char key = 13;
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: char key = 13;
- en: We’re allowing negative key values as a convenience for decoding messages. If
    you use a key value of `5` to encode your message and send it to a friend, your
    friend can use a key value of `-5` to decode the message.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们允许负密钥值作为解码消息的便利。如果你使用`5`作为密钥值来编码消息并发送给朋友，你的朋友可以使用`-5`的密钥值来解码这条消息。
- en: 'When the user responds with their desired secret key value, we can scan the
    line of input they provide, parse the integer value out of the line of input,
    and store the value in an `int` variable:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入他们想要的秘密密钥值时，我们可以扫描他们提供的输入行，解析出其中的整数值，并将该值存储在一个`int`类型的变量中：
- en: String output = "";
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: String output = "";
- en: System.out.println("Enter a secret key (-25 to 25):");
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("请输入一个秘密密钥（-25 到 25）：");
- en: int keyVal = Integer.parseInt(scan.nextLine());
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: int keyVal = Integer.parseInt(scan.nextLine());
- en: 'Finally, instead of using `13` as the `key` variable, we’ll change the variable
    key to the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将不再使用`13`作为`key`变量，而是将`key`变量更改为如下：
- en: int keyVal = Integer.parseInt(scan.nextLine());
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: int keyVal = Integer.parseInt(scan.nextLine());
- en: char key = (char) keyVal;
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: char key = (char) keyVal;
- en: for ( int x = 0; x < message.length(); x++ ) {
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: for ( int x = 0; x < message.length(); x++ ) {
- en: Here, we’re casting the `keyVal` entered to a `char` and storing that value
    in the variable `key`, since we can’t store an integer directly into a `char`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将输入的`keyVal`转换为`char`类型并存储到变量`key`中，因为我们不能直接将整数存储为`char`类型。
- en: 'To handle negative key values for the decoding process, we’ll need to make
    a change to the logic inside the `if` statements. We have to check whether *subtracting*
    a value (or adding a negative key) would shift the letter past the beginning of
    the alphabet (or less than `''A''`). If that happens, we can shift the letter
    back into the range from `A` to `Z` by *adding* `26`. Add the following code to
    the `if` statement for uppercase letters:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理解码过程中负密钥值，我们需要对`if`语句中的逻辑做出一些调整。我们必须检查*减去*某个值（或加上一个负密钥）是否会导致字母超出字母表的开始部分（即小于`'A'`）。如果发生这种情况，我们可以通过*加上*`26`将字母重新移回`A`到`Z`的范围内。将以下代码添加到针对大写字母的`if`语句中：
- en: if (input >= 'A' && input <= 'Z')
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: if (input >= 'A' && input <= 'Z')
- en: '{'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: input += key;
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: input += key;
- en: if (input > 'Z')
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: if (input > 'Z')
- en: input -= 26;
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: input -= 26;
- en: if (input < 'A')
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: if (input < 'A')
- en: input += 26;
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: input += 26;
- en: '}'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: If we input a negative `key`, we check whether we shifted before `A` and add
    `26` to wrap back around to the end of the alphabet.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们输入一个负数的 `key`，我们检查是否将字符移到了 `A` 之前，并添加 `26` 来回绕到字母表的末尾。
- en: 'Remember to do the same for the lowercase logic inside the `else-if` statement
    that follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 记得对紧跟其后的 `else-if` 语句中的小写字母逻辑做相同的处理：
- en: else if (input >= 'a' && input <= 'z')
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: else if (input >= 'a' && input <= 'z')
- en: '{'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: input += key;
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: input += key;
- en: if (input > 'z')
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: if (input > 'z')
- en: input -= 26;
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: input -= 26;
- en: if (input < 'a')
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: if (input < 'a')
- en: input += 26;
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: input += 26;
- en: '}'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'After these changes, you’ll be able to run the program to encode and decode
    messages with your own, custom key. Your program should work like the following
    example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些修改之后，你将能够运行程序，使用你自己的自定义密钥对消息进行编码和解码。你的程序应该像下面的示例一样工作：
- en: 'Enter a message to encode or decode:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 输入要编码或解码的消息：
- en: You've written a really cool app in Java!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你写了一个非常酷的 Java 应用程序！
- en: 'Enter a secret key (-25 to 25):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个密钥（-25 到 25）：
- en: '7'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: Fvb'cl dypaalu h ylhssf jvvs hww pu Qhch!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Fvb'cl dypaalu h ylhssf jvvs hww pu Qhch!
- en: 'Enter a message to encode or decode:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 输入要编码或解码的消息：
- en: Fvb'cl dypaalu h ylhssf jvvs hww pu Qhch!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Fvb'cl dypaalu h ylhssf jvvs hww pu Qhch!
- en: 'Enter a secret key (-25 to 25):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个密钥（-25 到 25）：
- en: '-7'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '-7'
- en: You've written a really cool app in Java!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你写了一个非常酷的 Java 应用程序！
- en: The first time we ran the program, we used a key of `7`. So, to decode the secret
    message, we ran the program again with the key value `-7`, revealing the original
    plaintext message.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次运行程序时，使用了 `7` 作为密钥。所以，为了解码密文，我们再次运行程序，密钥值为 `-7`，从而揭示了原始的明文消息。
- en: Go ahead and try it out!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 赶紧试试吧！
- en: Encoding Digits
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编码数字
- en: 'Now we have encoded letters, but if we encode a message like the following,
    any digits remain unencoded, in their original plaintext:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编码了字母，但是如果我们编码像下面这样的消息，任何数字仍然保持未编码，保留原始明文：
- en: 'Enter a message to encode or decode:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 输入要编码或解码的消息：
- en: Meet me at the arcade at 5pm.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 5点钟在游戏厅见。
- en: 'Enter a secret key (-25 to 25):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个密钥（-25 到 25）：
- en: '8'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: Ummb um ib bpm izkilm ib 5xu.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Ummb um ib bpm izkilm ib 5xu.
- en: Notice the `5` in `5pm` remains a `5` in the output message. If we want to encode
    numbers as well as letters, we need to add one more section of logic to the `for`
    loop. We’ll need to check whether a character falls between `0` and `9` and then
    encode that character as a different digit. We’ll also have to remember to wrap
    back around to the front or back of the set of 10 digits. We’ll have to handle
    this differently from wrapping around in the set of 26 letters since we’re dealing
    with numbers now.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `5` 在 `5pm` 中保持为输出消息中的 `5`。如果我们想同时编码数字和字母，我们需要在 `for` 循环中再添加一个逻辑部分。我们需要检查一个字符是否落在
    `0` 到 `9` 之间，然后将该字符编码为不同的数字。我们还必须记住将数字环绕回数字集的前面或后面。与字母表中的环绕不同，我们现在处理的是数字。
- en: 'First, let’s add another `else-if` statement right after the `else-if` that
    handles lowercase letters:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在处理小写字母的 `else-if` 后面再加一个 `else-if` 语句：
- en: else if (input >= 'a' && input <= 'z')
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: else if (input >= 'a' && input <= 'z')
- en: '{'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: input += key;
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: input += key;
- en: if (input > 'z')
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: if (input > 'z')
- en: input -= 26;
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: input -= 26;
- en: if (input < 'a')
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: if (input < 'a')
- en: input += 26;
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: input += 26;
- en: '}'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else if (input >= '0' && input <= '9')
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: else if (input >= '0' && input <= '9')
- en: output += input;
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: output += input;
- en: This part looks similar to the previous two `if` conditions, except that we’re
    using the digits `'0'` through `'9'`, instead of the letters `'A'` to `'Z'`, as
    the range.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分看起来类似于之前的两个 `if` 条件，只不过我们使用的是数字 `'0'` 到 `'9'`，而不是字母 `'A'` 到 `'Z'`，作为范围。
- en: 'The next line, inside the brace for the `if` statement, looks a bit different:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的这一行，在 `if` 语句的花括号内部，看起来有点不同：
- en: else if (input >= '0' && input <= '9')
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: else if (input >= '0' && input <= '9')
- en: '{'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: input += (keyVal % 10);
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: input += (keyVal % 10);
- en: First, we’re using the *integer* version of the secret key, `keyVal`, which
    the user entered earlier in the program. Second, we’ve used the modulo operator
    (`%`) to keep the shift value for digits between `-10` and `+10`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用了用户在程序中早些时候输入的 `keyVal` 的*整数*版本。其次，我们使用了取模运算符（`%`）来保持数字的偏移值在 `-10` 到
    `+10` 之间。
- en: 'We also need to test whether adding the `keyVal` pushed a digit past `9` or
    before `0`, just as we checked whether encoding a letter pushed it past `Z` or
    before `A`. But, instead of subtracting `26` to wrap back around to the beginning
    of the alphabet, we need to subtract `10` to keep a digit between `0` and `9`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要测试是否添加 `keyVal` 后将数字推过了 `9` 或者 `0`，就像我们检查编码字母是否越过了 `Z` 或者回到 `A` 一样。但是，代替减去
    `26` 来让字母环绕回到字母表的开头，我们需要减去 `10` 来保持数字在 `0` 到 `9` 之间：
- en: else if (input >= '0' && input <= '9')
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: else if (input >= '0' && input <= '9')
- en: '{'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: input += (keyVal % 10);
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 += (keyVal % 10);
- en: if (input > '9')
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 (输入 > '9')
- en: input -= 10;
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 -= 10;
- en: if (input < '0')
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 (输入 < '0')
- en: input += 10;
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 += 10;
- en: '}'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: output += input;
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 输出 += 输入;
- en: If encoding a digit pushes it past `9`, we subtract `10`. And, if decoding moves
    a digit below `0`, we add `10`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编码一个数字导致它超过 `9`，我们就减去 `10`。而如果解码时数字低于 `0`，我们就加上 `10`。
- en: 'Now we can encode both numbers and letters in the messages we send:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在发送的消息中同时编码数字和字母：
- en: 'Enter a message to encode or decode:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个要编码或解码的消息：
- en: Meet me at the arcade at 5pm and bring $2 to play Pac-Man :)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 下午5点在游戏机厅见我，并带上 $2 玩吃豆人 :)
- en: 'Enter a secret key (-25 to 25):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '输入一个秘密密钥（-25 到 25）:'
- en: '7'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: Tlla tl ha aol hyjhkl ha 2wt huk iypun $9 av wshf Whj-Thu :)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Tlla tl ha aol hyjhkl ha 2wt huk iypun $9 av wshf Whj-Thu :)
- en: The `5` in `5pm` is correctly shifted by seven and wraps back around to `2wt`
    in the encoded message. The `2` in `$2` is shifted by seven to `$9`. You can test
    the preceding secret message by decoding it with a key of `-7`, and you should
    get the original plaintext message back, including the numbers.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`5` 在 `5pm` 中正确地被移动了七位，并且在编码后的消息中回绕回到了 `2wt`。`$2` 中的 `2` 被移动了七位，变成了 `$9`。你可以通过使用
    `-7` 的密钥来解码上述的秘密消息，并且应该能得到原始的明文消息，包括数字。'
- en: The full, final text-based version of the Secret Messages app is given in [Listing
    6-4](ch6.xhtml#ch6list4).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密消息应用程序的完整文本版本可以在 [清单 6-4](ch6.xhtml#ch6list4) 中找到。
- en: import java.util.Scanner;
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 java.util.Scanner;
- en: public class SecretMessages {
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 公共类 SecretMessages {
- en: public static void main(String[] args) {
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 公共静态无效 主方法(String[] args) {
- en: Scanner scan = new Scanner(System.in);
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描仪 scan = 新扫描仪(System.in);
- en: System.out.println("Enter a message to encode or decode:");
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 系统.out.println("输入一个要编码或解码的消息：");
- en: String message = scan.nextLine();
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 消息 = scan.nextLine();
- en: String output = "";
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 输出 = "";
- en: System.out.println("Enter a secret key (-25 to 25):");
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 系统.out.println("输入一个秘密密钥（-25 到 25）：");
- en: int keyVal = Integer.parseInt(scan.nextLine());
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: int keyVal = Integer.parseInt(scan.nextLine());
- en: char key = (char) keyVal;
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 字符 密钥 = (字符) keyVal;
- en: for ( int x = 0; x < message.length(); x++ ) {
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 ( int x = 0; x < message.length(); x++ ) {
- en: char input = message.charAt(x);
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 字符 输入 = 消息.charAt(x);
- en: if (input >= 'A' && input <= 'Z')
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 (输入 >= 'A' && 输入 <= 'Z')
- en: '{'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: input += key;
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 += 密钥;
- en: if (input > 'Z')
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 (输入 > 'Z')
- en: input -= 26;
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 -= 26;
- en: if (input < 'A')
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 (输入 < 'A')
- en: input += 26;
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 += 26;
- en: '}'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else if (input >= 'a' && input <= 'z')
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果 (输入 >= 'a' && 输入 <= 'z')
- en: '{'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: input += key;
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 += 密钥;
- en: if (input > 'z')
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 (输入 > 'z')
- en: input -= 26;
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 -= 26;
- en: if (input < 'a')
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 (输入 < 'a')
- en: input += 26;
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 += 26;
- en: '}'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else if (input >= '0' && input <= '9')
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 否则如果 (输入 >= '0' && 输入 <= '9')
- en: '{'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: input += (keyVal % 10);
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 += (keyVal % 10);
- en: if (input > '9')
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 (输入 > '9')
- en: input -= 10;
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 -= 10;
- en: if (input < '0')
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 (输入 < '0')
- en: input += 10;
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 += 10;
- en: '}'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: output += input;
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 输出 += 输入;
- en: '}'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: System.*out*.println(output);
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 系统.*out*.println(输出);
- en: scan.close();
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: scan.close();
- en: '}'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '*Listing 6-4: The finished command line version of the Secret Messages app*'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-4: 完成的命令行版本的秘密消息应用程序*'
- en: This Secret Messages app can be a fun way to share scrambled messages back and
    forth with friends. But some of your friends may not have Eclipse or the Java
    JDK installed on their computer. Wouldn’t it be nice to be able to share the Secret
    Messages app with them too? In the next section, we’ll see how to run a command
    line Java app without opening Eclipse.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这个秘密消息应用程序可以是一个有趣的方式，和朋友们交换乱序的消息。但是，你的某些朋友可能没有在他们的计算机上安装 Eclipse 或 Java JDK。能不能也把这个秘密消息应用程序分享给他们呢？在接下来的部分，我们将看到如何在不打开
    Eclipse 的情况下运行一个命令行 Java 应用程序。
- en: Running Command Line Apps Without Eclipse
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在没有 Eclipse 的情况下运行命令行应用程序
- en: We’ve built two command line apps so far, but we’ve always run them from inside
    Eclipse. Eclipse provides a convenient console emulator to let us see how a command
    line app would look and feel, but what if we wanted to run the app from an actual
    command line, such as the Command Prompt in Windows or the Terminal on macOS?
    Or what if we wanted to send one of our command line apps to a friend who doesn’t
    have Eclipse installed on their computer?
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了两个命令行应用程序，但我们总是从 Eclipse 内部运行它们。Eclipse 提供了一个方便的控制台模拟器，让我们可以看到命令行应用程序的样子和感觉，但是如果我们想从实际的命令行中运行这个应用程序，比如
    Windows 中的命令提示符或 macOS 上的终端呢？或者如果我们想把我们的命令行应用程序发给一个没有安装 Eclipse 的朋友呢？
- en: Fortunately, most people have at least the JRE, or Java Runtime Environment,
    installed on their computers.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，大多数人至少在他们的计算机上安装了 JRE，或者 Java 运行时环境。
- en: '*Finding Your Workspace Folders*'
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*寻找你的工作空间文件夹*'
- en: To run the app you’ve written and compiled in Eclipse, first start by finding
    your Eclipse *workspace* folder. Open it in File Explorer (or Finder), as shown
    in [Figure 6-7](ch6.xhtml#ch6fig7).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行你在Eclipse中编写和编译的应用程序，首先要找到你的Eclipse*workspace*文件夹。在文件资源管理器（或Finder）中打开它，如[图6-7](ch6.xhtml#ch6fig7)所示。
- en: '![Images](../images/f0141-01.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0141-01.jpg)'
- en: '*Figure 6-7: My* workspace *folder has folders inside it for each of the projects
    we’ve built so far, plus some Eclipse default folders.*'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-7：我的*workspace*文件夹中包含了每个项目的文件夹，以及一些Eclipse默认的文件夹。*'
- en: Open the *SecretMessages* project folder inside your workspace, and you’ll see
    a few files and folders inside it, as shown in [Figure 6-8](ch6.xhtml#ch6fig8).
    The *src* folder has your source code files (ending in *.java*), and the *bin*
    folder has the compiled version of your app (ending in *.class*).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 打开*SecretMessages*项目文件夹，你将看到其中有几个文件和文件夹，如[图6-8](ch6.xhtml#ch6fig8)所示。*src*文件夹包含你的源代码文件（以*.java*结尾），而*bin*文件夹包含你应用程序的已编译版本（以*.class*结尾）。
- en: '![Images](../images/f0142-01.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0142-01.jpg)'
- en: '*Figure 6-8: Find the* bin *folder inside the* SecretMessages *project folder.*'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-8：在*SecretMessages*项目文件夹内找到*bin*文件夹。*'
- en: '*Opening a Command Line Window*'
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*打开命令行窗口*'
- en: Next, open a command line window. On Windows, you can do this by pressing the
    **Start** button, going to the search bar, and typing `cmd` (short for *command*)
    and pressing ENTER. On macOS, use the Spotlight search bar to find Terminal, or
    from a new Finder window, go to **Applications** ▸ **Utilities** ▸ **Terminal**.
    On Linux, open the Terminal application or use Search to find Terminal.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开命令行窗口。在Windows上，你可以通过按**开始**按钮，进入搜索框，输入`cmd`（*command*的缩写）并按ENTER来实现。在macOS上，使用Spotlight搜索栏找到终端，或者在新的Finder窗口中，依次进入**应用程序**
    ▸ **实用工具** ▸ **终端**。在Linux上，打开终端应用程序或使用搜索找到终端。
- en: We need to browse into the *bin* folder described earlier from the command line
    or Terminal prompt. Type `cd` (“change directory”) followed by a space in your
    terminal window. Then, to change directories into the *bin* folder for your app,
    drag the *bin* folder from your File Explorer or Finder window and drop it into
    the Command Prompt or Terminal window, as shown in [Figure 6-9](ch6.xhtml#ch6fig9).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从命令行或终端提示符浏览到之前描述的*bin*文件夹。输入`cd`（“change directory”）后跟一个空格，然后，将*bin*文件夹从文件资源管理器或Finder窗口拖动并放入命令提示符或终端窗口，如[图6-9](ch6.xhtml#ch6fig9)所示。
- en: '![Images](../images/f0142-02.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0142-02.jpg)'
- en: '*Figure 6-9: You can drag and drop the* bin *folder from File Explorer or Finder
    into the command line window to easily copy the directory path.*'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-9：你可以将*bin*文件夹从文件资源管理器或Finder拖放到命令行窗口，轻松复制目录路径。*'
- en: 'Notice that the full path appears after the `cd` command and looks something
    like the following (your *workspace/SecretMessages/bin* folder will be in a slightly
    different location from mine, of course):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`cd`命令之后出现完整路径，类似如下（当然，你的*workspace/SecretMessages/bin*文件夹位置与我的稍有不同）：
- en: cd "C:\Users\Bryson Payne\workspace_ch06\SecretMessages\bin"
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: cd "C:\Users\Bryson Payne\workspace_ch06\SecretMessages\bin"
- en: 'On macOS, the command will be:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，命令将是：
- en: cd /Users/BrysonPayne/Desktop/workspace_ch06/SecretMessages/bin
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: cd /Users/BrysonPayne/Desktop/workspace_ch06/SecretMessages/bin
- en: 'Press ENTER after this command, and the terminal will change the prompt to
    show you that you’re now inside the *bin* folder. On Windows, this looks like:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入此命令后按ENTER，终端将更改提示符，显示你现在已进入*bin*文件夹。在Windows上，界面如下：
- en: C:\Users\Bryson Payne\workspace_ch06\SecretMessages\bin>_
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: C:\Users\Bryson Payne\workspace_ch06\SecretMessages\bin>_
- en: 'Now we’re inside the *bin* folder, where the file *SecretMessages.class* has
    been compiled. To run the program contained in the *SecretMessages.class* bytecode
    file, enter the following command:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进入了*bin*文件夹，其中*SecretMessages.class*文件已经被编译。要运行包含在*SecretMessages.class*字节码文件中的程序，请输入以下命令：
- en: C:\Users\Bryson Payne\workspace_ch06\SecretMessages\bin>java SecretMessages
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: C:\Users\Bryson Payne\workspace_ch06\SecretMessages\bin>java SecretMessages
- en: 'Spelling, capitalization, and spacing all matter in the command, so you’ll
    need to match the name you gave your Java class precisely. If you typed the command
    correctly, the app should run, and you can test it with a message and secret key
    like so:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 拼写、大小写和空格都很重要，因此你需要精确匹配你为Java类指定的名称。如果你正确输入了命令，应用程序应该会运行，并且你可以用如下的消息和密钥进行测试：
- en: C:\Users\Bryson Payne\workspace_ch06\SecretMessages\bin>java SecretMessages
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: C:\Users\Bryson Payne\workspace_ch06\SecretMessages\bin>java SecretMessages
- en: 'Enter a message to encode or decode:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 输入要编码或解码的消息：
- en: I'm running my app directly from the command line terminal!
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我直接从命令行终端运行我的应用程序！
- en: 'Enter a secret key (-25 to 25):'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个秘密密钥（-25到25）：
- en: '12'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: U'y dgzzuzs yk mbb pudqofxk rday ftq oayymzp xuzq fqdyuzmx!
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: U'y dgzzuzs yk mbb pudqofxk rday ftq oayymzp xuzq fqdyuzmx!
- en: You can run the app again by retyping the line `java SecretMessages` or by pressing
    the up arrow key on your keyboard and pressing ENTER. [Figure 6-10](ch6.xhtml#ch6fig10)
    shows a couple of runs encoding and decoding a message from a Windows command
    prompt.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过重新输入`java SecretMessages`命令或按键盘上的上箭头键并按ENTER键再次运行应用程序。[图6-10](ch6.xhtml#ch6fig10)展示了在Windows命令提示符下编码和解码消息的几次运行。
- en: '![Images](../images/f0143-01.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![Images](../images/f0143-01.jpg)'
- en: '*Figure 6-10: Now that you can run your Java app from the command line, you
    can encode and decode messages on any computer with Java installed, with or without
    Eclipse.*'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-10：现在您可以从命令行运行Java应用程序，您可以在任何安装了Java的计算机上编码和解码消息，无论是否使用Eclipse。*'
- en: Now that you know how to run the app on your computer, you can share the *SecretMessages.class*
    file with your friends to exchange encoded messages. If their computer has Java
    (JDK or JRE) installed, all they’ll have to do is open their command line program,
    change directories into the folder containing the *SecretMessages.class* file,
    and run the same `java SecretMessages` command. To exchange messages, just agree
    on a key value to use. You can choose to use the same key every time or use different
    key values with different friends! Remember, though, this message app is just
    for fun—anyone with this program, or with a little time on their hands, can break
    a simple Caesar cipher. We’ll see how to break Caesar ciphers easily in [Chapter
    7](ch7.xhtml#ch7).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何在计算机上运行应用程序后，您可以与朋友共享*SecretMessages.class*文件，以交换编码的消息。如果他们的计算机安装了Java（JDK或JRE），他们只需打开命令行程序，进入包含*SecretMessages.class*文件的文件夹，然后运行相同的`java
    SecretMessages`命令。要交换消息，只需商定一个密钥值即可。您可以选择每次使用相同的密钥，也可以与不同的朋友使用不同的密钥值！不过，请记住，这个消息应用程序仅供娱乐——任何拥有该程序的人，或者有一点空闲时间的人，都可以破解简单的凯撒密码。我们将在[第7章](ch7.xhtml#ch7)中看到如何轻松破解凯撒密码。
- en: What You Learned
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 您学到了什么
- en: 'The Secret Messages app provided a fun way to delve into the world of manipulating
    characters and strings of text in Java. Among the new things you learned in this
    chapter were:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 《秘密消息》应用程序提供了一种有趣的方式，深入探讨了如何在Java中操作字符和文本字符串。在本章中，您学到的新知识包括：
- en: • Using the Caesar cipher to encode and decode simple messages
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用凯撒密码对简单消息进行编码和解码
- en: • Understanding the `char` data type for storing single Unicode characters
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: • 理解用于存储单个Unicode字符的`char`数据类型
- en: • Getting a specific character in a string with the `charAt()` method
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用`charAt()`方法获取字符串中的特定字符
- en: • Accessing a specific location in a string using the index, or position number,
    of a character in the string
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用索引（即字符在字符串中的位置编号）访问字符串中特定位置的字符
- en: • Adding strings and characters together using the `+` operator
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用`+`运算符将字符串和字符连接在一起
- en: • Looping through a string with a `for` loop, using its `length()` function
    to get the number of characters
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用`for`循环遍历字符串，使用其`length()`函数获取字符的数量
- en: • Understanding how the computer stores characters and other data represented
    by number values
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: • 理解计算机如何存储字符和其他由数字值表示的数据
- en: • Running command line apps directly from the command line, without Eclipse
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: • 直接从命令行运行命令行应用程序，无需Eclipse
- en: Programming Challenges
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程挑战
- en: Try these programming challenge exercises to review and practice what you’ve
    learned, as well as to expand your programming skills by trying something new.
    Visit the book’s website at *[https://www.nostarch.com/learnjava/](https://www.nostarch.com/learnjava/)*
    to download sample solutions.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些编程挑战练习，复习和练习您所学的知识，同时通过尝试一些新的内容来扩展您的编程技能。访问本书的网站* [https://www.nostarch.com/learnjava/](https://www.nostarch.com/learnjava/)*
    下载示例解决方案。
- en: '*#1: Looping the Loop*'
  id: totrans-380
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*#1: 循环循环*'
- en: We’ve built a fun message encoder/decoder app that will let us send and receive
    secret texts, emails, tweets, and so on. For your first programming challenge,
    add a loop to the Secret Messages app that will allow you to keep encoding and
    decoding messages as many times as you like.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个有趣的消息编码/解码应用程序，它允许我们发送和接收秘密文本、电子邮件、推文等。对于您的第一个编程挑战，请向《秘密消息》应用程序添加一个循环，使您能够多次进行消息编码和解码。
- en: You can choose to use the same key every time, or you can ask the user for a
    new key each time. If you ask the user to enter a secret key each time through
    the loop, you can enable them to encode and decode messages, one after the other
    (entering `8`, for example, to encode a message to a friend, and `-8` to decode
    a message from that same friend).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择每次使用相同的密钥，或者每次都询问用户输入一个新密钥。如果你让用户每次通过循环输入一个秘密密钥，他们就可以一个接一个地编码和解码消息（例如，输入`8`将消息编码给朋友，输入`-8`则解码该朋友的消息）。
- en: One way to do this is to prompt the user to enter a new message to encode or
    decode or tell them to press ENTER to quit. Then, use an `if` statement to check
    whether the user entered a message or just pressed ENTER.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是提示用户输入一个新的消息进行编码或解码，或者告诉他们按 ENTER 键退出。然后，使用 `if` 语句检查用户是输入了消息，还是只是按了 ENTER
    键。
- en: Give it a shot!
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下吧！
- en: '**HINT**'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '*message.length() will be greater than zero if the user typed something.*'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '*message.length() 大于零表示用户输入了内容。*'
- en: '*#2: Reversing and Encoding*'
  id: totrans-387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*#2: 反转与编码*'
- en: Let’s make our messages even harder to decipher by reversing the message before
    we encode it with the Caesar cipher. This double-encoding version of the app will
    combine the message-reversing approach of the first version in [Listing 6-1](ch6.xhtml#ch6list1)
    on [page 130](ch6.xhtml#page_130) with the Caesar cipher features of the final
    version from [Listing 6-4](ch6.xhtml#ch6list4) on [page 140](ch6.xhtml#page_140).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在编码消息之前先反转消息来让我们的消息更难解密。这个双重编码版本的应用程序将结合 [Listing 6-1](ch6.xhtml#ch6list1)
    中第 130 页的第一版消息反转方法和 [Listing 6-4](ch6.xhtml#ch6list4) 中第 140 页的凯撒密码特性。
- en: Reversing the order of the message is another example of symmetric encryption—doing
    it once reverses the message, and doing it again restores the message. Combining
    the string reversal with the Caesar cipher shift doesn’t make the program much
    more difficult, but it can make your messages even more confusing to an eavesdropper.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 反转消息的顺序是另一种对称加密的例子——执行一次反转消息，执行第二次就能恢复原始消息。将字符串反转与凯撒密码的移位结合并不会让程序变得更加复杂，但可以使得你的消息对于窃听者来说更加难以理解。
- en: Make sure your app correctly encodes and decodes messages, and remember that
    your friends will need the new version of the program to be able to decipher your
    new, doubly scrambled messages! Enjoy!
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的应用程序能正确地编码和解码消息，并记住，你的朋友需要更新后的程序版本才能解密你新的、经过双重加密的消息！享受这个过程吧！
- en: '*#3: Safely Handling Keys with try and catch*'
  id: totrans-391
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*#3: 使用 try 和 catch 安全地处理密钥*'
- en: A final improvement you could make to the Secret Messages app would be to safely
    handle bad numeric input when the user enters a key value. Remember the `try-catch`
    statement?
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对 Secret Messages 应用程序做的最后一个改进是，当用户输入密钥值时，安全地处理错误的数字输入。还记得 `try-catch` 语句吗？
- en: Adding the `try-catch` blocks to this app can be a bit tricky. In addition to
    adding the exception-handling code to prevent the user from crashing the program
    by giving a bad number (for example, by entering text instead of a number when
    prompted for the key value), you’ll need to think about what the app should do
    when bad input is provided. Should it tell the user their key was invalid and
    use a predefined key instead (say, `13`)? Or should it create a loop that will
    keep asking the user for a valid key?
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 向这个应用程序添加 `try-catch` 块可能有点棘手。除了添加异常处理代码以防止用户通过输入错误数字（例如，在要求输入密钥时输入文本）导致程序崩溃之外，你还需要考虑当提供错误输入时，应用程序应该怎么做。它是应该告诉用户密钥无效，并使用预定义的密钥（比如
    `13`）代替？还是应该创建一个循环，不断要求用户输入有效的密钥？
- en: Try coding it both ways and pick the one you like best!
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试两种方式进行编码，选择你最喜欢的一种！
