- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 5 PROCEDURES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5 过程
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In a procedural programming language, the basic unit of code is the procedure.
    A *procedure* is a set of instructions that compute a value or take an action,
    such as printing or reading a character value. This chapter discusses how Gas
    implements procedures, parameters, and local variables. By the end of this chapter,
    you should be well versed in writing your own procedures and functions. You’ll
    also fully understand parameter passing and the ARM application binary interface
    (ABI) calling convention.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程式编程语言中，代码的基本单元是过程。*过程*是一组指令，用来计算一个值或执行一个动作，例如打印或读取字符值。本章讨论了Gas如何实现过程、参数和局部变量。到本章结束时，你应该能够熟练地编写自己的过程和函数。你还将完全理解参数传递和ARM应用程序二进制接口（ABI）调用约定。
- en: 'This chapter covers several topics, including the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下几个主题：
- en: An introduction to assembly language programming style, along with some *aoaa.inc*
    macros to improve the readability of your programs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汇编语言编程风格介绍，以及一些*aoaa.inc*宏，以提高程序的可读性
- en: Gas procedures/functions and their implementation (including the use of the
    bl, br, and ret instructions), along with more *aoaa.inc* macros to allow the
    better declaration of procedures in your source files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gas过程/函数及其实现（包括使用bl、br和ret指令），以及更多*aoaa.inc*宏，允许在源文件中更好地声明过程
- en: Activation records, automatic variables, local symbols, register preservation,
    and the ARM stack
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激活记录、自动变量、局部符号、寄存器保存和ARM堆栈
- en: Various ways to pass parameters to a procedure, including pass by value and
    pass by reference, and how to use procedure pointers and procedural parameters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向过程传递参数的各种方式，包括按值传递和按引用传递，以及如何使用过程指针和过程参数
- en: This chapter also discusses how to return function results to a caller and how
    to call and use recursive functions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还讨论了如何将函数结果返回给调用者，以及如何调用和使用递归函数。
- en: 5.1 Assembly Language Programming Style
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1 汇编语言编程风格
- en: Up until this chapter, I’ve not stressed good assembly language programming
    style for two reasons. First, this book assumes you’re already familiar with the
    need for good programming style based on your experience with HLLs. Second, the
    programs quoted up to this point have been relatively trivial, and programming
    style doesn’t matter much with trivial code. However, as you begin to write more
    advanced ARM assembly language programs, style becomes more important.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 直到本章为止，我没有强调良好的汇编语言编程风格，原因有两个。首先，本书假设你已经通过对高级语言（HLL）的经验了解了良好编程风格的重要性。其次，到目前为止引用的程序相对简单，编程风格在简单代码中并不重要。然而，随着你开始编写更复杂的ARM汇编语言程序，风格变得更加重要。
- en: As you can probably tell by now, ARM assembly language code is nowhere near
    as readable as code written in an HLL such as C/C++, Java, or Swift. Therefore,
    as an assembly language programmer, you must expend extra effort to write assembly
    code that is as readable and maintainable as possible. As I’ve pointed out, the
    GNU assembler was written not as a tool for assembly language programmers but
    as a backend to the GCC compiler to process the compiler’s output. Because of
    this and the fact that Gas attempted to absorb as many features as possible from
    a huge number of assembly languages (for many CPUs, not just the ARM), writing
    high-quality code with Gas is a difficult task.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在可能已经能察觉到的，ARM汇编语言代码的可读性远不如用C/C++、Java或Swift等高级语言编写的代码。因此，作为汇编语言程序员，你必须付出额外的努力，编写尽可能可读和易于维护的汇编代码。正如我指出的，GNU汇编器（Gas）并不是作为一个供汇编语言程序员使用的工具，而是作为GCC编译器的后端，用来处理编译器的输出。由于这一点，以及Gas试图吸收尽可能多的来自众多汇编语言（不仅仅是ARM的汇编语言）特性，使用Gas编写高质量代码是一项困难的任务。
- en: Fortunately, you can use Gas’s macro processor (and ability to take advantage
    of the CPP) to modify the Gas assembly language somewhat, accessing features that
    can help improve your programming style. The *aoaa.inc* include file contains
    a fair number of predefined macros and symbol definitions to help achieve this
    goal. [Chapter 13](chapter13.xhtml) covers the contents of *aoaa.inc* line by
    line and explains how you can use these macros, and create macros of your own,
    to improve the readability of your ARM assembly language programs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以使用 Gas 的宏处理器（以及利用 CPP 的能力）来对 Gas 汇编语言进行一些修改，从而访问一些能帮助你改善编程风格的功能。*aoaa.inc*
    包含了相当数量的预定义宏和符号定义，帮助实现这一目标。[第 13 章](chapter13.xhtml)逐行介绍了 *aoaa.inc* 的内容，并解释了如何使用这些宏以及如何创建你自己的宏，以提高
    ARM 汇编语言程序的可读性。
- en: When you write assembly language source files, feel free to include *aoaa.inc*
    in that code or incorporate any features from that code in your assembly language
    source files. Even if you don’t require the cross-platform portability offered
    by *aoaa.inc*, its macros and other definitions can help you write more readable
    and maintainable code. The *aoaa.inc* header file is open source and covered by
    the Creative Commons 4.0 Attribution license (see section 5.12, “For More Information,”
    on [page 290](chapter5.xhtml#pg_290)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写汇编语言源文件时，可以随意将 *aoaa.inc* 包含在代码中，或将代码中的任何功能整合进你的汇编语言源文件。即使你不需要 *aoaa.inc*
    提供的跨平台可移植性，它的宏和其他定义仍然可以帮助你编写更具可读性和可维护性的代码。*aoaa.inc* 头文件是开源的，并且遵循 Creative Commons
    4.0 Attribution 许可协议（详见[第 290 页](chapter5.xhtml#pg_290)的第 5.12 节，“更多信息”）。
- en: 'As an example of using macros to make code more readable, consider the .code
    macro from *aoaa.inc*. It expands into the following two statements:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用宏使代码更具可读性的示例，考虑一下 *aoaa.inc* 中的 .code 宏。它展开成以下两个语句：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As a general rule, you should always ensure that the .text section is aligned
    on a word boundary (code could get misaligned if you’ve declared some data in
    the previous code section whose length is not a multiple of 4). It’s good programming
    style to always align a .text section; just to be sure an instruction begins at
    a proper address. Rather than clutter up your code with a bunch of extra .align
    directives, I recommend using the .code directive to automatically handle the
    alignment. Having less clutter makes your code easier to read.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你应始终确保 .text 段对齐在字边界（如果在前面的代码段中声明了一些长度不是 4 的倍数的数据，代码可能会出现错位）。始终对齐 .text
    段是良好的编程风格，这样可以确保指令从正确的地址开始。为了避免代码中充斥着大量多余的 .align 指令，我建议使用 .code 指令来自动处理对齐。减少杂乱的代码使得你的代码更容易阅读。
- en: The *aoaa.inc* header file contains several additional macros I will present
    throughout the rest of this chapter that take the 1960s-style Gas syntax and attempt
    to provide features found in more modern assemblers (such as the Microsoft Macro
    Assembler, or MASM, and the HLA assemblers available for the x86 processor family).
    Using these features (such as formal procedure declarations and local variable
    declarations) can help produce easier-to-read assembly language source code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*aoaa.inc* 头文件包含了几个额外的宏，接下来我将在本章的其余部分介绍，这些宏将 1960 年代风格的 Gas 语法与更现代的汇编器（如 Microsoft
    宏汇编器 MASM 和针对 x86 处理器系列的 HLA 汇编器）中的功能相结合。使用这些功能（如正式的过程声明和局部变量声明）可以帮助你编写更易于阅读的汇编语言源代码。'
- en: 'Even when writing traditional assembly language source code, you can follow
    certain rules to produce more readable code. Throughout this book, I’ve generally
    organized assembly language statements as follows (braces surround optional items
    and don’t appear in the actual source code):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在编写传统的汇编语言源代码时，你也可以遵循一些规则来提高代码的可读性。在本书中，我通常将汇编语言语句组织如下（大括号表示可选项，实际源代码中并不出现）：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As a general rule, I try to put all label definitions in column 1 and to line
    up all the instruction mnemonics in column 2\. I try to start the operands in
    column 3\. The exact number of spaces between these columns is not important,
    but be sure that the mnemonics are generally lined up together, in one column,
    and that the operands tend to start in the next column. This is the traditional
    assembly language programming style and the format that most assembly language
    programmers will want to see when reading your code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，我尽量将所有标签定义放在第一列，并将所有指令助记符对齐到第二列。我会尽量将操作数放在第三列。列之间的空格数量并不重要，但要确保助记符通常会对齐在同一列，操作数则倾向于从下一列开始。这是传统的汇编语言编程风格，也是大多数汇编语言程序员在阅读你的代码时希望看到的格式。
- en: NOTE
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*For formatting reasons, this book often compresses the amount of space between
    the columns and sometimes varies the position of each column within the same listing.
    This was done to ensure source lines fit on one line within the book. In a normal
    source file, you should try to keep all the columns aligned (two 4-character tab
    positions for column 2, column 3 around character position 16, and so on).*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于格式化原因，本书常常压缩列之间的空白，并且有时会变化每列在同一列表中的位置。这是为了确保源代码行能在书中保持在一行内。在正常的源文件中，你应该尽量保持所有列对齐（第二列使用两个4字符的制表符位置，第三列大约在字符位置16，依此类推）。*'
- en: In general, don’t try to indent statements as you would blocks in an HLL. Assembly
    language is not a block-structured language and does not lend itself to the same
    indentation techniques that work well for block-structured languages. If you need
    to set apart a sequence of statements, the best approach is to insert two or more
    blank lines before and after that sequence of statements. Comments are also useful
    for differentiating two separate, loosely coupled blocks of code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，不要像在高级语言中那样对语句进行缩进。汇编语言不是块结构化语言，不适合采用在块结构语言中有效的缩进技巧。如果需要将一系列语句区分开，最好的方法是插入两行或更多的空行在这些语句前后。注释也很有用，可以帮助区分两个独立的、松散耦合的代码块。
- en: 'Gas usually expects an entire assembly language instruction to reside on a
    single line of source code. In theory, you could use the backslash character immediately
    before a newline character to break a single statement across two lines:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Gas通常期望一个完整的汇编语言指令出现在源代码的一行中。理论上，你可以在换行符前使用反斜杠字符，将单条语句拆分成两行：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, there’s almost never a good argument for doing this. Keep your instructions
    on a single line unless you have a really good reason to split them across multiple
    lines (for example, if the source line becomes inordinately long for some reason,
    which is rare). The label field is an exception to this rule: labels may appear
    on a line by themselves even if they are associated with the next machine instruction
    in the program.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这几乎从来没有合理的理由去这么做。除非有非常好的理由将指令分成多行，否则应该将指令保持在同一行（例如，如果源代码行因为某些原因变得异常长，尽管这种情况很少见）。标签字段是这个规则的一个例外：即使标签与程序中的下一条机器指令相关联，也可以单独占一行。
- en: Gas (under Linux) allows putting multiple assembly language instructions on
    the same line, separated by a semicolon. However, putting multiple statements
    on the same source line is an even worse idea in assembly language than it is
    in HLLs—don’t do it. In any case, the macOS assembler does not support this feature.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Gas（在Linux下）允许将多个汇编语言指令放在同一行，用分号分隔。然而，将多条语句放在同一行的做法，在汇编语言中比在高级语言中更不推荐——不要这么做。无论如何，macOS汇编器不支持这一特性。
- en: 'With a few assembly language style guidelines out of the way, it’s time to
    consider the main topic of this chapter: procedures (functions) in assembly language.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决了一些汇编语言风格的基本指南之后，现在是时候考虑本章的主要主题：汇编语言中的过程（函数）。
- en: 5.2 Gas Procedures
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2 Gas过程
- en: 'Most procedural programming languages implement procedures by using the call/return
    mechanism. The code calls a procedure, the procedure performs whatever actions
    it was written to do, and then the procedure returns to the caller. The call and
    return operations provide the ARM’s *procedure invocation mechanism*. The calling
    code calls a procedure with the bl instruction, and the procedure returns to the
    caller with the ret instruction. For example, the following ARM instruction calls
    the C stdlib library printf() function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数过程式编程语言通过调用/返回机制来实现过程。代码调用过程，过程执行其编写的操作，然后返回给调用者。调用和返回操作提供了 ARM 的*过程调用机制*。调用代码通过
    bl 指令调用过程，过程通过 ret 指令返回给调用者。例如，以下 ARM 指令调用了 C 标准库中的 printf() 函数：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alas, the C stdlib does not supply all the routines you’ll need. Most of the
    time, you’ll have to write your own Gas procedures. A basic Gas procedure declaration
    takes the following form:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，C 标准库并没有提供你所需要的所有例程。大多数情况下，你需要编写自己的 Gas 过程。一个基本的 Gas 过程声明格式如下：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Technically, the procedure does not need to end with a ret instruction; the
    ret could be somewhere in the middle of the procedure, with a b.al instruction
    at the end. However, it’s considered good programming style to use a ret instruction
    (or an equivalent) as the last instruction of a procedure’s body.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，过程并不需要以 ret 指令结束；ret 可以位于过程的中间，最后以 b.al 指令结尾。然而，作为一种良好的编程风格，建议使用 ret 指令（或等效的指令）作为过程体的最后一条指令。
- en: Procedure declarations appear in the .text section of your program. In the preceding
    syntax example, procName represents the name of the procedure you wish to define.
    This can be any valid (and unique) Gas identifier.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 过程声明出现在程序的 .text 段中。在上述语法示例中，procName 表示你希望定义的过程名称。这个名称可以是任何有效的（且唯一的）Gas 标识符。
- en: 'Here is a concrete example of a Gas procedure declaration. This procedure stores
    0s into the 256 words at which X0 points upon entry into the procedure:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个 Gas 过程声明的具体示例。这个过程在进入时会将 0 存储到 X0 所指向的 256 个字中：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you’ve probably noticed, this simple procedure doesn’t bother with the “magic”
    instructions that add and subtract a value to and from the SP register. Those
    instructions are a requirement of the ARM ABI when the procedure will be calling
    other C/C++ code (or other code written in an ARM ABI–compliant language). Because
    this little function doesn’t call any other procedures, it doesn’t bother executing
    such code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，这个简单的过程没有涉及那些“魔法”指令，这些指令用于在 SP 寄存器上加减值。当过程会调用其他 C/C++ 代码（或其他符合 ARM
    ABI 的语言编写的代码）时，这些指令是 ARM ABI 的要求。由于这个小函数并不调用其他过程，因此它不执行这些代码。
- en: Also note that this code uses the loop index to count down from 1,024 down to
    0 by 4, filling in the 256-word array backward (from end to beginning) rather
    than filling it in from beginning to end. This is a common technique in assembly
    language. Finally, this code decrements X1 by 4 before storing the 0 into memory.
    This is because the loop index (X1) is initialized just beyond the end of the
    array pointed at by X0\. The str instruction does not affect the flags, so the
    bne instruction responds to the flags set by the subs instruction.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，这段代码使用循环索引从 1,024 递减到 0，每次递减 4，并倒序（从后到前）填充 256 字的数组，而不是从前到后填充。这是汇编语言中的常见技巧。最后，这段代码在将
    0 存储到内存之前会将 X1 减少 4。原因是循环索引（X1）初始化时就在 X0 所指向的数组末尾之外。str 指令不会影响标志，因此 bne 指令会响应
    subs 指令设置的标志。
- en: You can use the ARM bl instruction to call this procedure. When, during program
    execution, the code falls into the ret instruction, the procedure returns to whoever
    called it and begins executing the first instruction beyond bl. Listing 5-1 provides
    an example of a call to the zeroBytes routine.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 ARM 的 bl 指令来调用这个过程。当程序执行时，代码跳转到 ret 指令，过程返回到调用它的地方，并开始执行 bl 指令之后的第一条指令。清单
    5-1 提供了一个调用 zeroBytes 例程的示例。
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I won’t bother with a build or run command, as this program doesn’t produce
    any real output beyond saying that it ran and terminated.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会涉及构建或运行命令，因为这个程序除了显示它已运行并终止之外，不会产生任何实际输出。
- en: The Gas language doesn’t really have a syntactical concept of a program component
    we think of as a procedure (or function). It has labels you can call with the
    bl instruction, along with the ret instruction, which you can use to return from
    a procedure. However, it has no syntactical entity you can use to delineate one
    procedure from another in your assembly language source file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Gas语言并没有我们所说的程序组件的语法概念，像过程（或函数）这样的结构。它有可以用`bl`指令调用的标签，以及可以用`ret`指令返回的过程。然而，它没有可以用来在汇编源文件中区分一个过程与另一个过程的语法实体。
- en: 'So far, the few procedures in this book have delineated the code in the procedure
    by using a label and a return statement. For example, the following procedure
    begins with zeroBytes and ends with ret:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中的几个过程通过使用标签和返回语句来区分过程中的代码。例如，以下过程以`zeroBytes`开始，并以`ret`结束：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A comment immediately before the procedure might help separate it from previous
    code. However, the person reading the code has to work to differentiate the zeroBytes
    label from the repeatlp label. In fact, there’s no reason you couldn’t use both
    labels as entry points for a procedure (zeroBytes would always zero out 256 words
    starting at the address passed in X0, and repeatlp would zero out the number of
    words specified in X1/4). Of course, a procedure isn’t required to use just a
    single ret instruction (or any at all, since there are other ways to return from
    a procedure). The last instruction of a procedure also doesn’t have to be a ret.
    Therefore, relying on a statement label and a ret instruction to delineate the
    procedure is not always appropriate.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程之前立即添加注释可能有助于将其与前面的代码区分开。然而，阅读代码的人需要努力区分`zeroBytes`标签和`repeatlp`标签。实际上，完全可以使用这两个标签作为过程的入口点（`zeroBytes`总是从传入的X0地址开始清零256个字，而`repeatlp`则会清零X1/4指定数量的字）。当然，过程并不一定只能使用单一的`ret`指令（或者根本不使用，因为还有其他方式可以从过程返回）。因此，依赖一个语句标签和`ret`指令来界定过程并不总是合适的。
- en: 'Though it’s always a good idea to put comments at the beginning and end of
    your Gas procedures to clarify what’s happening, the best way to solve this problem
    would be to use *syntactical sugar*—statements that clarify meaning without generating
    any code—to delineate procedures. Although Gas does not provide such statements,
    you can write your own macros for the same purpose. The *aoaa.inc* include file
    provides a couple of these macros: proc and endp. Here is their syntax:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在你的Gas过程的开始和结束处添加注释以澄清发生了什么总是一个好主意，但解决这个问题的最佳方式是使用*语法糖*——这些语句可以澄清含义，而不会生成任何代码——来界定过程。虽然Gas没有提供这样的语句，但你可以为相同的目的编写自己的宏。`*aoaa.inc*`包含文件提供了几个这样的宏：`proc`和`endp`。以下是它们的语法：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, procedureName will be the name of the procedure, and you must supply the
    same name in the proc and endp statements. The , public argument is optional,
    as denoted by the meta-symbol braces. If the public argument is present, the proc
    macro will automatically generate a .global directive for the procedure.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`procedureName`将是过程的名称，你必须在`proc`和`endp`语句中提供相同的名称。`, public`参数是可选的，正如元符号大括号所表示的。如果提供了`public`参数，`proc`宏将自动为过程生成`.global`指令。
- en: 'Here’s a very simple example of using the proc and endp macros with the getTitle
    function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`proc`和`endp`宏与`getTitle`函数的非常简单的示例：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These macros generate the usual statements for the getTitle procedure:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏为`getTitle`过程生成了常见的语句：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The endp macro doesn’t generate anything in the program. It simply checks the
    identifier passed as an argument to ensure that it matches the procedure’s name
    in the proc macro invocation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`endp`宏在程序中并不会生成任何内容。它仅仅是检查传递的标识符，以确保它与`proc`宏调用中的过程名称相匹配。'
- en: Because the proc and endp statements neatly isolate a procedure’s body from
    other code in the program, this book uses them for procedures from this point
    forward. I suggest you take advantage of these macros to help make your own future
    procedures more readable too.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`proc`和`endp`语句可以整洁地将一个过程的主体与程序中的其他代码隔离开来，从这一点开始，本书将使用这些语句定义过程。我建议你也利用这些宏来帮助使你自己未来的过程更加易读。
- en: Procedures and functions in an HLL provide useful features in the form of local
    symbols. The next section covers the limited form of local labels supported by
    Gas.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 高级语言中的过程和函数提供了本地符号这一有用的特性。下一节将介绍Gas支持的有限形式的本地标签。
- en: 5.2.1 Gas Local Labels
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1 Gas本地标签
- en: Unlike HLLs, Gas does not support *lexically scoped symbols*. Labels you define
    in a procedure are not limited in scope to that procedure. Except for one special
    case, symbols you define in a Gas procedure, including those defined with proc/endp,
    are visible throughout the source file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与高级语言（HLL）不同，Gas 不支持 *词法作用域符号*。你在一个程序中定义的标签，并不局限于该程序的作用域。除了一个特殊情况外，你在 Gas 程序中定义的符号，包括用
    proc/endp 定义的符号，都是在整个源文件中可见的。
- en: 'However, Gas does support a limited form of *local labels*, which consist of
    a single numeric digit followed by a colon (0: through 9:). In your code, refer
    to these symbols by using Nb or Nf, where N is the digit (0 through 9). A symbol
    of the form Nb references the previous N: label in the source file (b is for *backward*).
    A symbol of the form Nf references the next N: symbol in the source file (f is
    for *forward*).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，Gas 确实支持一种有限形式的 *本地标签*，它由一个数字字符和一个冒号组成（0: 到 9:）。在代码中，使用 Nb 或 Nf 来引用这些符号，其中
    N 是数字（0 到 9）。形式为 Nb 的符号引用源文件中前一个 N: 标签（b 代表 *后退*）。形式为 Nf 的符号引用源文件中下一个 N: 标签（f
    代表 *前进*）。'
- en: 'Here’s an example of a Gas local label in the zeroBytes procedure (rewritten
    from the previous section):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个 Gas 本地标签的示例，位于 zeroBytes 程序中（改写自前一节）：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Local labels are useful when there is no compelling reason to use a more meaningful
    name. Be careful about using these local symbols, though. When used sparingly,
    they help reduce the distraction of meaningless labels in your program, but using
    too many will destroy the readability of your programs (“to which 0 label is this
    code jumping?”).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本地标签在没有充分理由使用更有意义的名称时非常有用。然而，使用这些本地符号时要小心。当适量使用时，它们有助于减少程序中无意义标签的干扰，但使用过多会破坏程序的可读性（“这个代码跳转到哪个
    0 标签？”）。
- en: When you use local labels, your target label should be only a few instructions
    away; if the code jumps any great distance, you run the risk of inserting that
    same local label between the source and targets when enhancing your code later.
    This would produce undesirable consequences, and Gas won’t notify you of the error.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本地标签时，目标标签应仅位于几条指令之内；如果代码跳转的距离过远，你在以后优化代码时有可能会在源代码和目标标签之间插入相同的本地标签。这会产生不良后果，并且
    Gas 不会提醒你错误。
- en: 5.2.2 bl, ret, and br
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2 bl、ret 和 br
- en: Once you can declare a procedure, the next problem is how to call (and return
    from) a procedure. As you’ve seen many times throughout this book, you call procedures
    by using bl and return from those procedures by using ret. This section covers
    those instructions (as well as the br instruction) in more detail, including the
    effects of their use.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你可以声明一个程序，接下来的问题是如何调用（和返回）一个程序。如你在本书中多次看到的那样，你通过使用 bl 调用程序，并通过使用 ret 从程序中返回。本节将更详细地介绍这些指令（以及
    br 指令），包括它们使用的效果。
- en: 'The ARM bl instruction does two things: it copies the (64-bit) address of the
    instruction immediately following the bl to the LR register, and then it transfers
    control to the address of the specified procedure. The value that bl copies to
    LR is known as the *return address*.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ARM bl 指令做两件事：它将紧随 bl 指令后的（64 位）地址复制到 LR 寄存器中，然后将控制转移到指定程序的地址。bl 复制到 LR 的值被称为
    *返回地址*。
- en: When a procedure wants to return to the caller and continue execution with the
    first statement following the bl instruction, that procedure commonly returns
    to its caller by executing a ret instruction. The ret instruction transfers control
    indirectly to that address held in the LR register (X30).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个程序希望返回调用者并继续执行 bl 指令之后的第一条语句时，通常通过执行 ret 指令返回给调用者。ret 指令通过间接转移控制到 LR 寄存器（X30）中保存的地址。
- en: The ARM ret instruction takes two forms
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ARM ret 指令有两种形式
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: where reg64 is one of the ARM’s thirty-two 64-bit registers. If a 64-bit register
    operand appears, the CPU uses the address held in that register as the return
    address; if no register is present, the default is X30 (LR).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 reg64 是 ARM 的三十二个 64 位寄存器之一。如果出现 64 位寄存器操作数，CPU 使用该寄存器中保存的地址作为返回地址；如果没有寄存器，默认使用
    X30（LR）。
- en: The ret instruction is actually a special case of the br (branch indirect through
    register) instruction. The br syntax is
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ret 指令实际上是 br（通过寄存器间接分支）指令的一个特殊情况。br 的语法是
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: where reg64 is one of the ARM’s thirty-two 64-bit registers. This instruction
    also transfers control to the address held in the specified register. Whereas
    the ret reg64 instruction provides a hint to the CPU that this is an actual return-from-subroutine,
    the br reg64 instruction offers no such hint. In some circumstances, the ARM can
    execute the code faster if it’s given the hint. [Chapter 7](chapter7.xhtml) covers
    some uses for the br instruction.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 reg64 是 ARM 的三十二个 64 位寄存器之一。该指令还将控制权转移到指定寄存器中保存的地址。而 ret reg64 指令向 CPU 提供一个提示，表示这是一个实际的子程序返回，而
    br reg64 指令则没有提供这样的提示。在某些情况下，如果给出提示，ARM 可以更快地执行代码。[第 7 章](chapter7.xhtml) 介绍了
    br 指令的一些用法。
- en: 'The following is an example of the minimal Gas procedure:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个最小化 Gas 过程的示例：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you call this procedure with the bl instruction, minimal will simply return
    to the caller. If you fail to put the ret instruction in the procedure, the program
    will not return to the caller upon encountering the endp statement. Instead, the
    program will fall through to whatever code happens to follow the procedure in
    memory.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用这个过程并使用 bl 指令，minimal 将简单地返回到调用者。如果你没有在过程中放置 ret 指令，当程序遇到 endp 语句时，它不会返回到调用者。相反，程序将继续执行紧跟在过程之后的代码。
- en: Listing 5-2 demonstrates this problem. The main program calls noRet, which falls
    straight through to followingProc (printing the followingProc was called message).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-2 演示了这个问题。主程序调用了 noRet，它直接跳转到 followingProc（打印出 followingProc was called
    消息）。
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, there is no ret instruction in noRet, so when the main program
    (asmMain) calls noRet, it will fall straight through into followingProc. Here’s
    the build command and sample execution:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，noRet 中没有 ret 指令，因此当主程序（asmMain）调用 noRet 时，它将直接跳转到 followingProc。以下是构建命令和示例执行：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Although this behavior might be desirable in certain rare circumstances, it
    usually represents a defect in most programs. Therefore, always remember to explicitly
    return from the procedure by using the ret instruction.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在某些罕见情况下这种行为可能是理想的，但在大多数程序中通常表示一个缺陷。因此，请始终记得使用 ret 指令显式地从过程返回。
- en: 5.3 Saving the State of the Machine
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3 保存机器状态
- en: Listing 5-3 attempts to print 20 lines of 40 spaces and an asterisk.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-3 尝试打印 20 行，每行 40 个空格和一个星号。
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Unfortunately, a subtle bug creates an infinite loop. The main program uses
    the bne printLoop instruction to create a loop that calls Print40Spaces 20 times.
    This function uses W19 to count off the 40 spaces it prints, and then returns
    with W19 containing 0\. The main program prints an asterisk and a newline, decrements
    W19, and then repeats because W19 isn’t 0 (it will always contain –1 at this point).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，一个微妙的错误导致了无限循环。主程序使用 bne printLoop 指令创建一个循环，该循环调用 Print40Spaces 20 次。此函数使用
    W19 来计数它打印的 40 个空格，然后返回时 W19 的值为 0。主程序打印一个星号和换行符，递减 W19，然后因为 W19 不为 0（此时它将始终为
    -1）而继续重复。
- en: The problem here is that the print40Spaces subroutine doesn’t preserve the W19
    register. Preserving a register means you save it upon entry into the subroutine
    and restore it before leaving. Had the print40Spaces subroutine preserved the
    contents of the W19 register, Listing 5-3 would have functioned properly. There
    is no need to build and run this program; it just runs in an infinite loop.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是 print40Spaces 子程序没有保存 W19 寄存器。保存寄存器意味着你在进入子程序时保存它，并在离开之前恢复它。如果 print40Spaces
    子程序保存了 W19 寄存器的内容，那么示例 5-3 会正常运行。无需构建和运行该程序；它只是进入了一个无限循环。
- en: 'Consider the following code for print40Spaces:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下的 print40Spaces 代码：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This variant of print40Spaces saves and restores X19 on the stack, along with
    the LR register. Because X19 is a nonvolatile register (in the ARM ABI), it is
    the responsibility of the callee (the procedure) to preserve it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变体的 print40Spaces 会在栈上保存并恢复 X19 寄存器以及 LR 寄存器。由于 X19 是一个非易失性寄存器（在 ARM ABI 中），所以它的保存责任由被调用者（即过程）承担。
- en: Note that print40Spaces uses X19 rather than one of the X0 to X15 registers
    specifically because it is nonvolatile. The printf() function does not have to
    preserve X0 to X15 because they are *volatile* registers in the ARM ABI. Any attempt
    to use those registers would have likely failed because printf() doesn’t have
    to preserve their values.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，print40Spaces 使用的是 X19 而不是 X0 到 X15 寄存器，特别是因为 X19 是非易失性的。printf() 函数不需要保存
    X0 到 X15，因为它们在 ARM ABI 中是*易失性*寄存器。任何尝试使用这些寄存器的操作都可能失败，因为 printf() 不必保留它们的值。
- en: In general, either the caller (the code containing the call instruction) or
    the callee (the subroutine) can take responsibility for preserving the registers.
    When following the ARM ABI, it is the caller’s responsibility to preserve volatile
    registers and the callee’s responsibility to preserve nonvolatile registers. Of
    course, when writing your own procedures that won’t be called by ABI-compliant
    functions and don’t call any ABI-compliant functions, you can choose whichever
    register preservation scheme you prefer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，调用者（包含调用指令的代码）或被调用方（子程序）都可以负责保留寄存器。在遵循 ARM ABI 时，调用者负责保留易失性寄存器，而被调用方负责保留非易失性寄存器。当然，当你编写自己的子程序时，如果这些子程序不会被
    ABI 兼容的函数调用，也不调用任何 ABI 兼容的函数，你可以选择任何你喜欢的寄存器保留方案。
- en: Listing 5-4 shows the corrected version of the program in Listing 5-3, which
    properly preserves X19 in the call to print40Spaces.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-4 显示了清单 5-3 中程序的修正版本，该版本在调用 print40Spaces 时正确地保留了 X19 寄存器。
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here’s the build command and sample output for Listing 5-4:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是清单 5-4 的构建命令和示例输出：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, this program executes properly without entering an infinite
    loop.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，程序正确执行，没有进入无限循环。
- en: 'Callee preservation has two advantages: space and maintainability. If the callee
    (the procedure) preserves all affected registers, only one copy of the str and
    ldr instructions exists—those that the procedure contains. If the caller saves
    the values in the registers, the program needs a set of preservation instructions
    around every call. This makes your programs not only longer but also harder to
    maintain. It’s not easy to remember which registers to save and restore on each
    procedure call.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用方保留寄存器有两个优点：节省空间和易于维护。如果被调用方（子程序）保留所有受影响的寄存器，那么只有一份 str 和 ldr 指令存在——即子程序中的指令。如果调用方保存寄存器中的值，那么程序在每次调用时需要一组保留指令。这不仅使程序更长，而且更难以维护。记住每次调用时哪些寄存器需要保存和恢复并不容易。
- en: On the other hand, a subroutine may unnecessarily preserve some registers if
    it preserves all the registers it modifies. If the caller is preserving the registers,
    the subroutine doesn’t have to save registers it doesn’t care about.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果一个子程序保留了它所修改的所有寄存器，它可能会不必要地保存一些寄存器。如果调用者已经保存了这些寄存器，那么子程序就不需要保存它不关心的寄存器。
- en: One big problem with having the caller preserve registers is that your program
    may change over time. You may modify the calling code or the procedure to use
    additional registers. Such changes, of course, may change the set of registers
    that you must preserve. Worse still, if the modification is in the subroutine
    itself, you will need to locate *every* call to the routine and verify that the
    subroutine does not change any registers that the calling code uses.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 保留寄存器的一个大问题是你的程序可能会随着时间的推移发生变化。你可能会修改调用代码或过程，以使用额外的寄存器。当然，这些变化可能会改变你必须保留的寄存器集合。更糟糕的是，如果修改发生在子程序本身，你将需要定位*每一个*调用该子程序的地方，并验证该子程序是否不会更改调用代码使用的任何寄存器。
- en: 'Assembly language programmers typically use a common convention with respect
    to register preservation: unless there is a good reason (performance) for doing
    otherwise, most programmers will preserve each register that a procedure modifies
    (and doesn’t explicitly return a value in a modified register). This reduces the
    likelihood of defects occurring in a program because a procedure modifies a register
    the caller expects to be preserved. Of course, you could follow the rules concerning
    the ARM ABI with respect to volatile and nonvolatile registers; however, such
    calling conventions impose their own inefficiencies on both programmers and other
    programs. This book generally adheres to the ARM ABI with respect to volatile
    and nonvolatile registers, though many examples preserve all affected registers
    in a procedure.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言程序员通常在寄存器保留方面遵循一种常见约定：除非有充分的理由（性能问题）做出不同的处理，否则大多数程序员会保留每个子程序修改的寄存器（且该寄存器没有显式返回值）。这样可以减少程序出现缺陷的可能性，因为子程序修改了调用方期望被保留的寄存器。当然，你也可以遵循有关
    ARM ABI 的规则，处理易失性和非易失性寄存器；然而，这种调用约定会对程序员和其他程序带来低效。虽然本书一般遵循 ARM ABI 的易失性和非易失性寄存器规则，但许多示例在一个过程里保留所有受影响的寄存器。
- en: There’s more to preserving the environment than preserving registers. You can
    also preserve variables and other values that a subroutine might change.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 保留环境不仅仅是保留寄存器。你还可以保留子程序可能会改变的变量和其他值。
- en: 5.4 Call Trees, Leaf Procedures, and the Stack
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4 调用树、叶过程和堆栈
- en: Imagine a procedure, A, that calls two other procedures B and C. Also assume
    that B calls two procedures D and E, and procedure C calls two other procedures
    F and G. We can diagram this calling sequence by using a *call tree*, as shown
    in [Figure 5-1](chapter5.xhtml#fig5-1).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个过程 A 调用了另外两个过程 B 和 C。还假设 B 调用了两个过程 D 和 E，C 调用了两个过程 F 和 G。我们可以通过使用*调用树*来表示这个调用顺序，如[图
    5-1](chapter5.xhtml#fig5-1)所示。
- en: '![](../images/Figure5-1.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-1.jpg)'
- en: 'Figure 5-1: A call-tree diagram'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-1：调用树示意图
- en: This entire call graph is the tree, and the procedures at the bottom that do
    not call any other procedures—in this case, D, E, F, and G—are known as *leaf
    procedures*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 整个调用图是树形结构，底部那些不调用其他过程的过程——在这个例子中是 D、E、F 和 G——被称为*叶过程*。
- en: Leaf procedures are different from non-leaf procedures in ARM assembly language
    because they can leave the return address in the LR register rather than saving
    it to memory (the stack). As leaf procedures don’t make any other calls via the
    bl instruction, the procedure won’t disturb the value in LR upon entry into the
    procedure. (This assumes that the procedure doesn’t explicitly modify LR, but
    generally, there is no good reason for doing so.) Therefore, leaf procedures can
    be slightly more efficient than non-leaf procedures, as they are spared the need
    to preserve the value in the LR register. Leaf procedures can also make full use
    of the volatile register set without worrying about their values being scrambled
    during a call to another procedure.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 叶过程与非叶过程在 ARM 汇编语言中有所不同，因为它们可以将返回地址保留在 LR 寄存器中，而不是保存到内存（堆栈）。由于叶过程不会通过 bl 指令进行其他调用，因此在进入过程时，该过程不会修改
    LR 中的值。（这假设过程不会显式地修改 LR，但通常来说，修改 LR 没有什么好的理由。）因此，叶过程可能比非叶过程稍微高效一些，因为它们不需要保留 LR
    寄存器中的值。叶过程还可以充分利用易失性寄存器集，而不用担心它们的值在调用其他过程时被扰乱。
- en: 'Non-leaf procedures must preserve the value in the LR register because calls
    they make (via bl) will overwrite the value in LR. A procedure can preserve LR
    in a few places: in another register, on a stack, or in a global memory location,
    as our examples did before [Chapter 3](chapter3.xhtml) introduced the stack.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 非叶过程必须保留 LR 寄存器中的值，因为它们所调用的过程（通过 bl 指令）会覆盖 LR 中的值。一个过程可以在几个地方保留 LR：在另一个寄存器中、在堆栈上，或者在全局内存位置，就像我们在[第
    3 章](chapter3.xhtml)介绍堆栈之前的例子那样。
- en: I’ve already pointed out that using global variables to preserve LR is a poor
    choice in nearly every case. That scheme can handle only one level of calls and
    completely fails when using recursion (see section 5.8, “Recursion,” on [page
    277](chapter5.xhtml#pg_277)) or writing multithreaded applications. It’s also
    slower, uses more code, and is less convenient to use than other schemes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经指出，在几乎所有情况下，使用全局变量来保存 LR 是一个不好的选择。这个方案只能处理一层调用，在使用递归（参见第 5.8 节，“递归”，[第 277
    页](chapter5.xhtml#pg_277)）或编写多线程应用程序时完全失效。它的速度较慢，代码更多，而且比其他方案使用起来不方便。
- en: You could use another register to temporarily hold the return address while
    calling another procedure. Of course, that register must be nonvolatile (or, at
    least, the procedure you’re calling must not modify that register’s value) so
    that it will still contain the saved return address whenever the procedure you
    call returns. Using a register to preserve LR like this is very fast. Unfortunately,
    guaranteeing that other procedures won’t modify the saved value often means you
    have to preserve that value in memory within the second procedure to be called.
    Since you still have to write the value to memory (and read it back), you may
    as well have saved LR directly to memory in the first place.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用另一个寄存器临时保存返回地址，同时调用另一个过程。当然，这个寄存器必须是非易失性的（或者至少，被调用的过程不能修改这个寄存器的值），这样它就能在你调用的过程返回时仍然保存返回地址。像这样使用寄存器来保存
    LR 是非常快速的。不幸的是，确保其他过程不会修改保存的值通常意味着你必须在第二个过程中保留这个值。由于你仍然需要将该值写入内存（并且再次读取它），那么你不如直接将
    LR 保存在内存中。
- en: 'The most common place to save the return address in LR is on the stack. Usually,
    one of the first instructions in a procedure will move the contents of the LR
    register into the stack. This is typically done in one of two ways. The first
    is to directly push the LR register onto the stack:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 保存返回地址到 LR 最常见的位置是堆栈。通常，过程中的第一条指令会将 LR 寄存器的内容移动到堆栈中。这通常有两种方式。第一种是直接将 LR 寄存器压入堆栈：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The second is to adjust the stack down in memory and store LR into the storage
    area just created:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是将堆栈向下调整，并将LR存入刚刚创建的存储区域：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, someAmount is a multiple of 16 (or another value that keeps the stack
    16-byte aligned), and someOffset is an index into the space just allocated on
    the stack by the sub instruction.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，someAmount是16的倍数（或其他保持堆栈16字节对齐的值），而someOffset是通过sub指令在堆栈上刚分配的空间的索引。
- en: Notice that the former example uses the pre-indexed addressing mode to adjust
    SP downward and store LR into the vacated space (because of stack alignment issues,
    this actually reserves 16 bytes, though it uses only 8 of them). The latter example
    uses the indirect-plus-offset addressing mode to simply store the return address
    into the storage allocated by the sub instruction. This book most commonly uses
    the latter form because the cost of sub is often shared by other code that uses
    the stack.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的示例使用了预索引寻址模式来将SP向下调整，并将LR存入空出的空间（由于堆栈对齐问题，这实际上保留了16个字节，虽然只使用了其中的8个字节）。后面的示例使用了间接加偏移寻址模式，简单地将返回地址存入由sub指令分配的存储区域。本书通常使用后一种形式，因为sub的成本通常与其他使用堆栈的代码共享。
- en: 'Wasting 8 bytes by using the pre-indexed addressing mode won’t turn out to
    be an issue. As you’ll see shortly, most of the time you’ll want to preserve the
    value of the FP register along with the return address, so you’ll commonly use
    an stp instruction, like one of the following, that won’t waste any memory:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用预索引寻址模式浪费8个字节不会成为问题。正如你将很快看到的，通常你会希望保留FP寄存器的值和返回地址，因此你通常会使用像以下这些不会浪费内存的stp指令：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: or
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The following subsections cover the use of the stack in procedures, including
    activation records, accessing data within activation records (local and automatic
    variables as well as parameters), how the ARM ABI influences activation records
    and passing parameters, and how to build and destroy activation records.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节将介绍在过程调用中堆栈的使用，包括激活记录、如何访问激活记录中的数据（本地和自动变量以及参数）、ARM ABI如何影响激活记录和参数传递，以及如何构建和销毁激活记录。
- en: 5.4.1 Activation Records
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.1 激活记录
- en: When you call a procedure, the program associates certain information with that
    procedure call, including the return address, parameters, and automatic local
    variables (which I’ll discuss in later sections). To do so, it uses a data structure
    called an *activation record*, also known as a *stack frame*. The program creates
    an activation record when calling (activating) a procedure, and the data in the
    record is organized in a manner identical to structs.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个过程时，程序会将一些信息与该过程调用关联起来，包括返回地址、参数和自动本地变量（我将在后续章节中讨论）。为此，程序使用一种名为*激活记录*的数据结构，也称为*堆栈帧*。程序在调用（激活）过程时创建激活记录，记录中的数据以与结构体相同的方式进行组织。
- en: This section covers traditional activation records created by a hypothetical
    compiler, ignoring the parameter-passing conventions of the ARM ABI. A later section
    of this chapter presents the ARM ABI conventions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了一个假设编译器创建的传统激活记录，忽略了ARM ABI的参数传递约定。本章后续的章节将介绍ARM ABI约定。
- en: Construction of an activation record begins in the code that calls a procedure.
    The caller makes room for the parameter data (if any) on the stack and copies
    the data onto the stack. The bl instruction then passes the return address into
    the procedure. At this point, construction of the activation record continues
    within the procedure itself. The procedure typically pushes the value in LR onto
    the stack along with other registers and other important state information, then
    makes room in the activation record for local variables. The procedure might also
    update the FP register (X29) so that it points at the base address of the activation
    record.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 激活记录的构建始于调用过程的代码。调用者在堆栈上为参数数据（如果有的话）腾出空间，并将数据复制到堆栈上。然后，bl指令将返回地址传入过程。此时，激活记录的构建继续在过程内部进行。过程通常将LR中的值与其他寄存器和其他重要的状态信息一起推送到堆栈上，然后为本地变量在激活记录中腾出空间。过程还可能更新FP寄存器（X29），使其指向激活记录的基地址。
- en: 'To see what a traditional activation record looks like, consider the following
    C++ procedure declaration:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解传统的激活记录是什么样的，可以考虑以下C++过程声明：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Whenever a program calls this ARDemo procedure, it begins by pushing the data
    for the parameters onto the stack. In the original C/C++ calling convention (ignoring
    the ARM ABI), the calling code pushes all the parameters onto the stack in the
    opposite order in which they appear in the parameter list, from right to left.
    Therefore, the calling code pushes first the value for the k parameter, then the
    value for the j parameter, and finally the data for the i parameter (with possible
    padding for the parameters to keep the stack aligned).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每当程序调用该 ARDemo 过程时，它会首先将参数数据推入栈中。在原始的 C/C++ 调用约定中（忽略 ARM ABI），调用代码将所有参数按与它们在参数列表中出现的顺序相反的顺序推入栈中，从右到左。因此，调用代码首先推入
    k 参数的值，然后是 j 参数的值，最后是 i 参数的数据（为了保持栈对齐，可能会为参数添加填充）。
- en: Next, the program calls ARDemo. Immediately upon entry into the ARDemo procedure,
    the stack contains these three items arranged as shown in [Figure 5-2](chapter5.xhtml#fig5-2).
    Since the program pushes the parameters in reverse order, they appear on the stack
    in the correct order, with the first parameter at the lowest address in memory.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，程序调用 ARDemo。ARDemo 过程刚一进入时，栈中就包含了这三个项目，并按[图 5-2](chapter5.xhtml#fig5-2)所示的顺序排列。由于程序是逆序将参数推入栈中，因此它们按正确的顺序出现在栈上，且第一个参数位于内存中的最低地址。
- en: '![](../images/Figure5-2.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-2.jpg)'
- en: 'Figure 5-2: Stack organization immediately upon entry into ARDemo'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-2：ARDemo 进入时的栈组织结构
- en: The first few instructions in ARDemo push the current values of LR and FP onto
    the stack, then copy the value of SP into FP. Next, the code drops the stack pointer
    down in memory to make room for the local variables. This produces the stack organization
    shown in [Figure 5-3](chapter5.xhtml#fig5-3).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ARDemo 中的前几个指令将当前的 LR 和 FP 值推入栈中，然后将 SP 的值复制到 FP。接下来，代码会将栈指针向下调整到内存中，为局部变量腾出空间。这会产生[图
    5-3](chapter5.xhtml#fig5-3)所示的栈组织结构。
- en: '![](../images/Figure5-3.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-3.jpg)'
- en: 'Figure 5-3: The activation record for ARDemo'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-3：ARDemo 的激活记录
- en: Because local variables can be any size in the activation record, their total
    storage might not be a multiple of 16 bytes. However, the entire block of local
    variables must be a multiple of 16 bytes so that SP remains aligned on a 16-byte
    boundary as required by the ARM CPU—hence the presence of possible padding in
    [Figure 5-3](chapter5.xhtml#fig5-3).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于局部变量在激活记录中可以是任意大小，因此它们的总存储空间可能不是 16 字节的倍数。然而，整个局部变量块必须是 16 字节的倍数，以确保栈指针（SP）保持在
    ARM CPU 所要求的 16 字节对齐边界上——因此，[图 5-3](chapter5.xhtml#fig5-3) 中可能会出现填充。
- en: 5.4.2 Objects in the Activation Record
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.2 激活记录中的对象
- en: To access objects in the activation record, you can use offsets from the FP
    register to the desired object. The two items of immediate interest to you are
    the parameters and the local variables. You can access the parameters at positive
    offsets from the FP register; you can access the local variables at negative offsets
    from the FP register, as [Figure 5-4](chapter5.xhtml#fig5-4) shows (the figure
    assumes that the i, j, and k parameters are all 64-bit integers with appropriate
    padding to 8 bytes each).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问激活记录中的对象，可以使用从 FP 寄存器到目标对象的偏移量。你最关心的两个项目是参数和局部变量。你可以通过从 FP 寄存器的正偏移量访问参数；可以通过从
    FP 寄存器的负偏移量访问局部变量，正如[图 5-4](chapter5.xhtml#fig5-4)所示（该图假设 i、j 和 k 参数都是 64 位整数，并已适当填充到
    8 字节每个）。
- en: ARM specifically reserves the X29/FP register for use as a pointer to the base
    of the activation record. This is why you should avoid using the FP register for
    general calculations. If you arbitrarily change the value in the FP register,
    you could lose access to the current procedure’s parameters and local variables.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 特别为 X29/FP 寄存器保留了作为激活记录基址指针的用途。这就是为什么你应该避免将 FP 寄存器用于一般计算。如果你随意更改 FP 寄存器的值，可能会导致无法访问当前过程的参数和局部变量。
- en: '![](../images/Figure5-4.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-4.jpg)'
- en: 'Figure 5-4: Offsets of objects in the ARDemo activation record'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-4：ARDemo 激活记录中对象的偏移量
- en: 'The local variables are aligned on offsets that are equal to their native size:
    chars are aligned on 1-byte addresses; shorts/hwords are aligned on 2-byte addresses;
    longs, ints, unsigned, and words are aligned on 4-byte addresses; and so forth.
    In the ARDemo example, all the locals just happen to be allocated on appropriate
    addresses (assuming a compiler allocates storage in the order of declaration).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量按照与其本地大小相等的偏移量进行对齐：字符（chars）对齐在 1 字节地址上；短整数（shorts/hwords）对齐在 2 字节地址上；长整数、整数、无符号整数和字（longs、ints、unsigned
    和 words）对齐在 4 字节地址上，依此类推。在 ARDemo 示例中，所有局部变量恰好都分配在适当的地址上（假设编译器按声明顺序分配存储）。
- en: 5.4.3 ARM ABI Parameter-Passing Conventions
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.3 ARM ABI 参数传递约定
- en: 'The ARM ABI makes several modifications to the activation record model:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ARM ABI 对激活记录模型进行了若干修改：
- en: The caller passes the first eight (non-floating-point) parameters in registers
    (X0 through X7) rather than on the stack.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用者通过寄存器（X0 至 X7）传递前八个（非浮点）参数，而不是通过栈传递。
- en: Parameters are always 8-byte values, either in registers or on the stack (if
    the formal parameter is fewer than 8 bytes in size, the unused HO bits are undefined).
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数始终是 8 字节值，无论是在寄存器中还是在栈上（如果形式参数小于 8 字节，则未使用的高位（HO bits）是未定义的）。
- en: Structures and unions greater than 16 bytes in size are passed by value on the
    stack above any other parameters, but with a pointer to the value in the normal
    parameter position (in a register or on the stack). Structs and unions that are
    8 bytes (or fewer) are passed in a 64-bit register; those that are 9 to 16 bytes
    are passed in two consecutive registers.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大于 16 字节的结构体和联合体通过值传递在栈上，位于其他参数之上，但在正常的参数位置（寄存器或栈上）传递指向该值的指针。8 字节（或更少）的结构体和联合体通过
    64 位寄存器传递；9 到 16 字节的结构体和联合体通过两个连续的寄存器传递。
- en: You must follow these conventions only when calling ARM ABI–compliant code.
    For assembly language procedures that you write and call, you can use any convention
    you like.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需在调用符合 ARM ABI 的代码时遵循这些约定。对于你编写和调用的汇编语言过程，你可以使用任何约定。
- en: 'Apple’s calling conventions for macOS (iOS, iPadOS, and so on) vary a little
    from the standard ARM ABI. This will affect your assembly code if you’re doing
    the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果的调用约定对于 macOS（iOS、iPadOS 等）与标准 ARM ABI 稍有不同。如果你进行以下操作，可能会影响你的汇编代码：
- en: Passing more than eight parameters to a procedure
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向过程传递超过八个参数
- en: Passing parameters to a variadic procedure
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向变参过程传递参数
- en: When passing parameters on the stack—that is, when you’re passing more than
    eight arguments to a function—Apple packs them on the stack, meaning it doesn’t
    simply allocate 8 bytes for each parameter on the stack. It does ensure that each
    value is aligned in memory on its natural size (chars = 1 byte, half words = 2
    bytes, words = 4 bytes, and so on).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过栈传递参数时——即当你向函数传递超过八个参数时——苹果将它们打包在栈上，这意味着它不会简单地为每个参数分配 8 字节的栈空间。它确实确保每个值在内存中按照其自然大小进行对齐（字符
    = 1 字节，半字 = 2 字节，字 = 4 字节，依此类推）。
- en: '*Variadic procedures* are those with a variable number of parameters, such
    as the C printf() function. Apple passes all variadic parameters on the stack
    and allocates 8 bytes for each parameter, regardless of type. This is the purpose
    behind the vparm2, vparm3, ..., macros in *aoaa.inc*: calls to printf() under
    macOS must pass the arguments on the stack, while the same calls on Linux pass
    the first eight parameters in registers.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*变参过程* 是指具有可变数量参数的过程，例如 C 的 printf() 函数。苹果将所有变参参数放在栈上，并为每个参数分配 8 字节，不管其类型如何。这就是
    *aoaa.inc* 中 vparm2、vparm3 等宏的目的：macOS 下的 printf() 调用必须将参数传递到栈上，而在 Linux 下的相同调用则将前八个参数传递到寄存器中。'
- en: The vparm2, vparm3, and so on, macros automatically generate the appropriate
    code based on the OS (either putting the parameters in the stack or passing them
    in registers).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: vparm2、vparm3 等宏根据操作系统自动生成适当的代码（无论是将参数放入栈中还是通过寄存器传递）。
- en: 5.4.4 Standard Entry Sequence
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.4 标准入口序列
- en: 'The caller of a procedure is responsible for allocating storage for parameters
    on the stack and moving the parameter data to its appropriate location. In the
    simplest case, this just involves moving the data onto the stack by using str
    or stp instructions. It is the procedure’s responsibility to construct the rest
    of the activation record. You can accomplish this by using the following assembly
    language *standard entry sequence* code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个过程的调用者负责为参数在栈上分配存储并将参数数据移动到适当的位置。在最简单的情况下，这只是通过使用 `str` 或 `stp` 指令将数据移动到栈上。构建其余的激活记录是过程的责任。你可以通过使用以下汇编语言的*标准入口序列*代码来实现：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The mov fp, sp instruction copies the current address held in SP into the FP
    register. As SP is currently pointing at the old value of FP pushed on the stack,
    FP will point at the original FP value after the execution of this instruction,
    as shown in [Figure 5-4](chapter5.xhtml#fig5-4). When using the stp instruction
    in the standard entry sequence, make sure to specify the FP register as the first
    argument so that it is stored at location [SP] and LR is stored at location [SP,
    #8]. This ensures that FP will point at the old FP value after the mov instruction.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov fp, sp` 指令将当前保存在 SP 中的地址复制到 FP 寄存器。由于 SP 当前指向栈上压入的旧 FP 值，执行此指令后，FP 将指向原始的
    FP 值，如[图 5-4](chapter5.xhtml#fig5-4)所示。当在标准入口序列中使用 `stp` 指令时，确保将 FP 寄存器作为第一个参数，以便它存储在
    [SP] 位置，而 LR 存储在 [SP, #8] 位置。这确保了在执行 `mov` 指令后，FP 会指向旧的 FP 值。'
- en: In the third instruction, NumVars represents the number of bytes of local variables
    needed by the procedure, a constant that should be a multiple of 16 so that the
    SP register remains aligned on a 16-byte boundary. If the number of bytes of local
    variables in the procedure is not a multiple of 16, round up the value to the
    next higher multiple of 16 before subtracting this constant from SP. Doing so
    will slightly increase the amount of storage the procedure uses for local variables
    but will not otherwise affect the operation of the procedure. If the procedure
    doesn’t have any local variables or call any other functions, the
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三条指令中，NumVars 代表过程所需的本地变量的字节数，这是一个常量，应该是 16 的倍数，以确保 SP 寄存器在 16 字节边界上对齐。如果过程中的本地变量字节数不是
    16 的倍数，则在从 SP 中减去该常量之前，将该值向上舍入到下一个更高的 16 的倍数。这样做会稍微增加过程用于本地变量的存储量，但不会影响过程的操作。如果过程没有本地变量或调用其他函数，
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: instruction isn’t necessary.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 指令不是必须的。
- en: In theory, you could use any register to access the data in the stack frame.
    However, the OS, and especially debugger applications, often depend on the activation
    record being built with FP pointing at the old FP value in the activation record.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，你可以使用任何寄存器来访问栈帧中的数据。然而，操作系统，尤其是调试器应用程序，通常依赖于激活记录的构建，其中 FP 指向激活记录中的旧 FP 值。
- en: If an ARM ABI–compliant program calls your procedure, the stack will be aligned
    on a 16-byte boundary immediately prior to the execution of the bl instruction.
    Pushing LR and FP onto the stack (before copying SP into FP) adds another 16 bytes
    to the stack so that SP remains 16-byte aligned. Therefore, assuming the stack
    was 16-byte aligned prior to the call, and the number you subtract from SP is
    a multiple of 16, the stack will be 16-byte aligned after allocating storage for
    local variables.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个符合 ARM ABI 的程序调用你的过程，在执行 `bl` 指令之前，栈将被对齐到 16 字节边界。将 LR 和 FP 压入栈中（在将 SP 复制到
    FP 之前）会再增加 16 字节的栈空间，以确保 SP 保持 16 字节对齐。因此，假设在调用之前栈已经是 16 字节对齐的，并且从 SP 中减去的数字是
    16 的倍数，那么在为本地变量分配存储之后，栈仍然会保持 16 字节对齐。
- en: The ARDemo activation record from the previous section has only 12 bytes of
    local storage. Therefore, subtracting 12 from SP for the local variables will
    not leave the stack 16-byte aligned. The entry sequence in the ARDemo program
    must subtract 16 (which will include 4 bytes of padding) to keep the stack properly
    aligned (as shown in [Figure 5-4](chapter5.xhtml#fig5-4)).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节中的 ARDemo 激活记录只有 12 字节的本地存储。因此，从 SP 中减去 12 字节用于本地变量将无法保持栈的 16 字节对齐。ARDemo
    程序中的入口序列必须减去 16（其中包括 4 字节的填充），以保持栈的正确对齐（如[图 5-4](chapter5.xhtml#fig5-4)所示）。
- en: 'A possible alternate entry code sequence that is equivalent to the earlier
    example takes this form:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的替代入口代码序列，与前面的示例等效，其形式如下：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The ARM ABI calling convention suggests saving the LR and FP values *below*
    the local variables. However, it is often convenient to allocate parameter space
    for additional procedure calls (from the current procedure) while allocating local
    variables. If you save the LR and FP values at the bottom of the activation record
    in memory, you will need an extra instruction to make room for those parameters,
    and cleaning up the activation record will take more effort when the procedure
    returns.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ARM ABI 调用约定建议将LR和FP值保存*在*局部变量的下面。然而，在分配局部变量的同时，分配额外的参数空间以支持从当前过程的额外过程调用通常是方便的。如果将LR和FP值保存在激活记录的底部，你将需要额外的指令来为这些参数腾出空间，而在过程返回时清理激活记录将更加复杂。
- en: 'Because you’ll so often use the standard entry sequence, the *aoaa.inc* include
    file provides a macro to generate this sequence for you:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你将频繁使用标准的入口序列，*aoaa.inc* 包含文件提供了一个宏来为你生成该序列：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The single constant argument is the amount of stack space to allocate (for
    local variables and other memory objects) in addition to the 16 bytes set aside
    to preserve the LR and FP registers. This macro generates the following sequence
    of instructions for the entry sequence:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的常量参数是要分配的栈空间大小（用于局部变量和其他内存对象），除了为保存LR和FP寄存器所预留的16字节之外。这个宏会为入口序列生成以下指令序列：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The final expression involving numVars ensures that the space allocated on the
    stack is a multiple of 16 bytes, to keep the stack 16-byte aligned.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的表达式涉及numVars，确保在栈上分配的空间是16字节的倍数，以保持栈的16字节对齐。
- en: 5.4.5 Standard Exit Sequence
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.5 标准退出序列
- en: 'The standard exit sequence for an assembly language program is the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言程序的标准退出序列如下：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the *aoaa.inc* include file, the leave macro expands to the original standard
    exit sequence.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *aoaa.inc* 包含文件中，leave宏展开为原始的标准退出序列。
- en: 5.5 Local Variables
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5 局部变量
- en: Procedures and functions in most HLLs let you declare local variables (also
    known as *automatic variables*). The previous sections mentioned that procedures
    maintain local variables in an activation record, but they didn’t really define
    how to create and use them. This section (and the subsections that follow) defines
    local variables and describes how to allocate storage for them and use them.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数高级语言中的过程和函数允许你声明局部变量（也称为*自动变量*）。前面章节提到过，过程将局部变量保存在激活记录中，但它们并没有真正定义如何创建和使用它们。本节（及其后续小节）将定义局部变量，并描述如何为其分配存储空间并使用它们。
- en: 'Local variables possess two special attributes in HLLs: scope and lifetime*.*
    The *scope* of an identifier determines where that identifier is visible (accessible)
    in the source file during compilation. In most HLLs, the scope of a procedure’s
    local variable is the body of that procedure; the identifier is inaccessible outside
    that procedure. Sadly, Gas does not support locally scoped variables in a procedure,
    since Gas has no syntax to determine the bounds of a procedure.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量在高级语言中有两个特殊的属性：作用域和生命周期*。* 标识符的*作用域*决定了该标识符在编译期间在源文件中可见（可访问）的范围。在大多数高级语言中，过程的局部变量的作用域是该过程的主体；标识符在该过程外部不可访问。遗憾的是，Gas
    不支持过程中的局部作用域变量，因为 Gas 没有语法来确定过程的边界。
- en: Whereas scope is a compile-time attribute of a symbol, lifetime is a runtime
    attribute. The *lifetime* of a variable is a range of time, from that point when
    storage is first bound to the variable until the point where the storage is no
    longer available for that variable. Static objects (those you declare in the .data,
    .rodata, .bss, and .text sections) have a lifetime equivalent to the total runtime
    of the application. The program allocates storage for such variables when the
    program first loads into memory, and those variables maintain that storage until
    the program terminates.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域是符号的编译时属性，而生命周期是运行时属性。变量的*生命周期*是一个时间范围，从存储首次绑定到变量的那一刻，直到存储不再可用的时刻。静态对象（那些你在
    .data、.rodata、.bss 和 .text 部分声明的对象）具有与应用程序总运行时间等同的生命周期。程序在加载到内存时为这些变量分配存储空间，并且这些变量在程序终止之前保持该存储空间。
- en: Local variables, more properly known as *automatic variables*, have their storage
    allocated upon entry into a procedure. That storage is then returned for other
    use when the procedure returns to its caller. The name *automatic* refers to the
    program automatically allocating and deallocating storage for the variable on
    procedure invocation and return.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量，更准确地说是*自动变量*，在进入过程时会分配存储空间。该存储空间在过程返回调用者时会被释放，供其他用途。*自动*这一名称意味着程序在调用和返回过程中自动分配和释放变量的存储。
- en: 'Under Linux, a procedure can access any global .data, .bss, or .rodata object
    exactly the same way the main program accesses such variables: by referencing
    the name, using the PC-relative addressing mode (sadly, macOS’s PIE format doesn’t
    allow easy access to non-.text section objects). Accessing global objects is convenient
    and easy. However, accessing global objects makes your programs harder to read,
    understand, and maintain, so you should avoid using global variables within procedures.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux下，一个过程可以像主程序访问全局变量一样，使用PC相对寻址模式访问任何全局的.data、.bss或.rodata对象（遗憾的是，macOS的PIE格式不允许轻松访问非.text节的对象）。访问全局对象是方便且简单的。然而，访问全局对象会让程序更难阅读、理解和维护，因此应该避免在过程内使用全局变量。
- en: Although accessing global variables within a procedure may sometimes be the
    best solution to a given problem, you likely won’t be writing such code at this
    point, so carefully consider your options before doing so. (An example of a legitimate
    use of global variables might be when sharing data between threads in a multithreaded
    application, a bit beyond the scope of this chapter.)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在过程内访问全局变量有时可能是解决特定问题的最佳方案，但你在这个阶段可能不会编写这样的代码，因此在这么做之前需要仔细考虑你的选择。（一个合法使用全局变量的例子可能是在多线程应用程序中共享线程间的数据，这稍微超出了本章的范围。）
- en: This argument against accessing global variables does not apply to other global
    symbols, however. It is perfectly reasonable to access global constants, types,
    procedures, and other objects in your programs.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种反对访问全局变量的论点并不适用于其他全局符号。在程序中访问全局常量、类型、过程和其他对象是完全合理的。
- en: 5.5.1 Low-Level Implementation of Automatic Variables
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.1 自动变量的低级实现
- en: Your program accesses local variables in a procedure by using negative offsets
    from the activation record base address (FP). Consider the Gas procedure in Listing
    5-5, which is intended primarily to demonstrate the use of local variables.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序通过使用从激活记录基址（FP）负偏移量来访问过程中的局部变量。请参考列表5-5中的Gas过程，主要用于演示局部变量的使用。
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This program isn’t runnable, so I won’t bother providing a build command for
    it. The enter macro will actually allocate 16 bytes of storage, rather than the
    8 specified by the argument (for locals a and bb), in order to keep the stack
    16-byte aligned.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序无法运行，因此我不会提供构建命令。enter宏实际上会分配16字节的存储，而不是参数指定的8字节（用于局部变量a和bb），以保持栈的16字节对齐。
- en: The activation record for local_vars appears in [Figure 5-5](chapter5.xhtml#fig5-5).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: local_vars的激活记录出现在[图5-5](chapter5.xhtml#fig5-5)中。
- en: '![](../images/Figure5-5.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-5.jpg)'
- en: 'Figure 5-5: The activation record for the local_vars procedure'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-5：local_vars过程的激活记录
- en: 'Of course, having to refer to the local variables by the numeric offset from
    the FP register is truly horrible. This code is not only difficult to read (Is
    [FP, #-4] the a or the bb variable?) but also hard to maintain. For example, if
    you decide you no longer need the a variable, you’d have to go find every occurrence
    of [FP, #-8] (accessing the bb variable) and change it to [FP, #-4].'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '当然，通过FP寄存器的数值偏移来引用局部变量是非常糟糕的。这段代码不仅难以阅读（[FP, #-4]是a变量还是bb变量？），而且也难以维护。例如，如果你决定不再需要a变量，你就得找到每一个[FP,
    #-8]（访问bb变量）的地方，并将其改成[FP, #-4]。'
- en: A slightly better solution is to create equates for your local variable names.
    Consider the modification to Listing 5-5 shown in Listing 5-6.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微更好的解决方案是为你的局部变量名创建等式。请参考列表5-5的修改版，如列表5-6所示。
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In Listing 5-6, the CPP replaces a and bb with the appropriate indirect-plus-offset
    addressing mode to access those local variables on the stack. This is considerably
    easier to read and maintain than the program in Listing 5-5\. However, this approach
    still requires some manual work to set the local variable offsets in the #define
    statements, and modifying the code (when adding or removing local variables) can
    create maintenance issues. I’ll provide a better solution in the next section.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '在列表 5-6 中，CPP 用适当的间接加偏移寻址模式替换了 a 和 bb，以便在栈上访问这些局部变量。这比列表 5-5 中的程序更容易阅读和维护。然而，这种方法仍然需要一些手动工作来设置
    #define 语句中的局部变量偏移量，并且修改代码（在添加或删除局部变量时）可能会导致维护问题。我将在下一节提供一个更好的解决方案。'
- en: 'One big advantage to automatic storage allocation is that it efficiently shares
    a fixed pool of memory among several procedures. For example, say you call three
    procedures in a row, like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 自动存储分配的一个大优点是，它能够有效地在多个过程之间共享一块固定的内存池。例如，假设你依次调用三个过程，像这样：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this example, ProcA allocates its local variables on the stack. Upon return,
    ProcA deallocates that stack storage. Upon entry into ProcB, the program allocates
    storage for ProcB’s local variables by using the same memory locations just freed
    by ProcA. Likewise, when ProcB returns and the program calls ProcC, ProcC uses
    the same stack space for its local variables that ProcB recently freed up. This
    memory reuse makes efficient use of the system resources and is probably the greatest
    advantage to using automatic variables.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，ProcA 在栈上分配它的局部变量。返回时，ProcA 会释放这块栈存储空间。进入 ProcB 时，程序通过使用 ProcA 刚刚释放的内存位置来分配
    ProcB 的局部变量存储空间。同样，当 ProcB 返回并且程序调用 ProcC 时，ProcC 使用与 ProcB 最近释放的相同栈空间来存储它的局部变量。这种内存重用有效地利用了系统资源，可能是使用自动变量的最大优点。
- en: Now that you’ve seen how assembly language allocates and deallocates storage
    for local variables, it’s easy to understand why automatic variables do not maintain
    their values between two calls to the same procedure. Once the procedure returns
    to its caller, the storage for the automatic variable is lost, and, therefore,
    the value is lost as well. Thus, *you must always assume that a local variable
    object is uninitialized upon entry into a procedure*. If you need to maintain
    the value of a variable between calls to a procedure, you should use one of the
    static variable declaration types.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了汇编语言如何分配和释放局部变量的存储空间，就很容易理解为什么自动变量在两次调用同一个过程之间不会保持它们的值。一旦过程返回到调用者，自动变量的存储就会丢失，因此，值也会丢失。因此，*你必须始终假设进入过程时局部变量对象是未初始化的*。如果你需要在两次调用过程之间保持变量的值，应该使用静态变量声明类型中的一种。
- en: 5.5.2 The locals Macro
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.2 locals 宏
- en: Using equates to maintain local variable references is a lot of work. Granted,
    it’s better than using magic numbers in all your local variable references, but
    even when using equates, inserting and deleting local variables in a procedure
    takes time and effort. What would be really nice is a declaration section that
    lets you declare your local variables in an HLL-like fashion and leave it up to
    the assembler to maintain all the offsets into the activation record. The *aoaa.inc*
    header file provides a set of macros you can use to automate the creation of local
    variables. This section describes those macros.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用等式来维护局部变量引用是一项繁重的工作。诚然，这比在所有局部变量引用中使用魔法数字要好，但即使使用等式，在过程中插入和删除局部变量仍然需要时间和精力。真正理想的情况是有一个声明部分，可以像在高级语言中那样声明局部变量，并让汇编器负责维护所有进入激活记录的偏移量。*aoaa.inc*
    头文件提供了一组宏，你可以用它们来自动化创建局部变量的过程。本节将介绍这些宏。
- en: 'The activation record is a *record* (structure). In theory, you could use the
    struct macro from [Chapter 4](chapter4.xhtml) to define an activation record.
    However, it’s easy enough to modify the struct/ends macros to create something
    even better for local variables. To achieve that, the *aoaa.inc* include file
    includes two additional macros for declaring local variables: locals and endl.
    Use these in a manner almost identical to the struct/ends macros'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 激活记录是一个*记录*（结构体）。理论上，你可以使用[第 4 章](chapter4.xhtml)中的 struct 宏来定义激活记录。然而，修改 struct/ends
    宏来为局部变量创建更好的东西其实并不难。为了实现这一点，*aoaa.inc* 包含了两个额外的宏，用于声明局部变量：locals 和 endl。你可以几乎像使用
    struct/ends 宏那样使用这些宏。
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: where procName is an identifier (usually the name of the procedure that the
    local variables are associated with).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 procName 是标识符（通常是与局部变量关联的过程的名称）。
- en: 'Like the ends macro, endl generates a symbol with the name procName.size that
    is an equate set to the size of the local variable space. You can supply this
    value to the enter macro to specify the amount of space to reserve for the local
    variables:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 像 ends 宏一样，endl 生成一个名为 procName.size 的符号，这是一个等式，设置为局部变量空间的大小。你可以将这个值提供给 enter
    宏，以指定为局部变量保留的空间量：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The locals/endl declarations create a set of equates whose values correspond
    to the offsets of the symbols within an activation record. For example, the symbols
    in the previous example have the following values:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: locals/endl 声明创建了一组等式，这些等式的值对应于激活记录中符号的偏移量。例如，前面的示例中的符号具有以下值：
- en: mp.ptrVar    –8
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: mp.ptrVar    –8
- en: mp.counter    –12
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: mp.counter    –12
- en: mp.inputChar    –13
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: mp.inputChar    –13
- en: mp.endIndex    –20
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: mp.endIndex    –20
- en: 'You can use these offsets with the [FP, #offset] addressing mode to reference
    these local variables in the activation record. For example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以使用这些偏移量与[FP, #offset]寻址模式来引用激活记录中的局部变量。例如：'
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is a whole lot easier than accessing global variables in the .data section!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这比在 .data 区访问全局变量要容易得多！
- en: When allocating offsets for variables between the locals and endl macros, the
    declaration macros first decrease the offset counter by the size of the variable’s
    declaration and then assign the decremented offset value to the symbol. Specifying
    the salign directive will then adjust the offset to the specified boundary (2*^n*,
    where *n* is the salign operand’s value). The next declaration will not use this
    offset, but rather it will first decrement the running offset counter by the size
    of the declaration and assign that offset to the variable. In the earlier example,
    the salign directive set the running offset to –16 (because 13 bytes of variables
    were allocated at that point). The following variable’s offset is –20, because
    mp.endIndex consumes 4 bytes.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当为局部变量和 endl 宏之间的变量分配偏移量时，声明宏首先通过变量声明的大小减少偏移量计数器，然后将减少后的偏移值分配给符号。指定 salign 指令将会将偏移量调整到指定的边界（2*^n*，其中
    *n* 是 salign 操作数的值）。下一个声明将不使用此偏移量，而是首先通过声明的大小递减运行中的偏移量计数器，并将该偏移量分配给变量。在之前的示例中，salign
    指令将运行偏移量设置为 –16（因为当时分配了 13 字节的变量）。接下来的变量偏移量是 –20，因为 mp.endIndex 消耗了 4 字节。
- en: As I mentioned earlier, Gas does not support the concept of lexically scoped
    local variable names, which are private to a procedure. Therefore, all symbols
    you declare within the locals/endl block are visible throughout the source file.
    This can lead to *namespace pollution*, where you wind up creating names in one
    procedure and cannot reuse those names in a different procedure.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所提到的，Gas 不支持词法作用域局部变量名的概念，这些变量名对于一个过程是私有的。因此，你在 locals/endl 块内声明的所有符号在整个源文件中都是可见的。这可能导致
    *命名空间污染*，你可能会在一个过程内创建名字，而不能在另一个过程中重复使用这些名字。
- en: 'In the examples of this section, I use a convention that I continue throughout
    this book to alleviate namespace pollution: I use local variable names of the
    form proc.local, where proc is the procedure’s name (or an abbreviation of the
    procedure’s name) and local is the specific local variable name I want to use.
    For example, mp.ptrVar is the ptrVar local variable within the myProc (mp) procedure.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的示例中，我使用一种惯例，并且在本书中始终使用这种惯例，以避免命名空间污染：我使用形式为 proc.local 的局部变量名，其中 proc 是过程的名称（或过程名称的缩写），local
    是我要使用的具体局部变量名称。例如，mp.ptrVar 是 myProc（mp）过程中的 ptrVar 局部变量。
- en: 5.6 Parameters
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6 参数
- en: Although many procedures are totally self-contained, most procedures require
    input data and return data to the caller (parameters).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多过程是完全自包含的，大多数过程仍需要输入数据并将数据返回给调用者（参数）。
- en: 'The first aspect to consider when discussing parameters is how we pass them
    to a procedure. If you are familiar with Pascal or C/C++, you’ve probably seen
    two ways to pass parameters: pass by value and pass by reference. Anything you
    can do with an HLL can be done in assembly language (obviously, as HLL code compiles
    into machine code), but you have to provide the instruction sequence to access
    those parameters in an appropriate fashion.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论参数时，第一个需要考虑的方面是我们如何将参数传递给过程。如果你熟悉 Pascal 或 C/C++，你可能见过两种传递参数的方式：按值传递和按引用传递。你在高级语言中能做的任何事情，都能在汇编语言中实现（显然，高级语言代码最终会被编译成机器代码），但你必须提供合适的指令序列来访问这些参数。
- en: 'Another concern when dealing with parameters is *where* you pass them. There
    are many places to pass parameters: in registers, on the stack, in the code stream,
    in global variables, or a combination of these. The following subsections cover
    several of the possibilities.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 处理参数时，另一个需要关注的问题是*你在哪里传递它们*。传递参数有许多方式：通过寄存器、栈、代码流、全局变量或它们的组合。以下小节将介绍几种可能性。
- en: 5.6.1 Passing by Value
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.1 按值传递
- en: 'A parameter *passed by value* is just that—the caller passes a value to the
    procedure. Pass-by-value parameters are input-only parameters. You can pass them
    to a procedure, but the procedure cannot return values through them. Consider
    this C/C++ function call:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 按值传递的参数就是这样——调用者将一个值传递给过程。按值传递的参数仅为输入参数。你可以将它们传递给过程，但过程不能通过它们返回值。考虑以下 C/C++
    函数调用：
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you pass I by value, CallProc() does not change the value of I, regardless
    of what happens to the parameter inside CallProc().
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按值传递 I，那么无论 CallProc() 内部如何操作，I 的值都不会改变。
- en: Because you must pass a copy of the data to the procedure, you should use this
    method only for passing small objects like bytes, words, double words, and quad
    words. Passing large arrays and records by value is inefficient, because you must
    create and pass a copy of the object to the procedure.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你必须将数据的副本传递给过程，所以这种方法仅适用于传递像字节、字、双字和四字等小对象。按值传递大型数组和记录效率低，因为你必须创建并传递对象的副本给过程。
- en: 5.6.2 Passing by Reference
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.2 按引用传递
- en: To pass a parameter *by reference*, you must pass the address of a variable
    rather than its value. In other words, you must pass a pointer to the data. The
    procedure must dereference this pointer to access the data. Passing parameters
    by reference is useful when you must modify the actual parameter or when you pass
    large data structures between procedures. Because pointers on the ARM are 64 bits
    wide, a parameter that you pass by reference will consist of a double-word value,
    typically in one of the general-purpose registers.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按引用传递参数，你必须传递一个变量的地址，而不是它的值。换句话说，你必须传递指向数据的指针。过程必须解除引用该指针才能访问数据。当你需要修改实际参数，或者在过程之间传递大型数据结构时，按引用传递参数是很有用的。因为在
    ARM 上指针是 64 位宽的，所以你按引用传递的参数将由一个双字值组成，通常保存在一个通用寄存器中。
- en: You can use the lea macro to take the address of any static variable you’ve
    declared in your .data, .bss, .rodata, or .text sections. Listing 5-7 demonstrates
    how to obtain the address of a static variable (staticVar) and pass that address
    to a procedure (someFunc) in the X0 register.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 lea 宏获取你在 .data、.bss、.rodata 或 .text 段中声明的任何静态变量的地址。清单 5-7 演示了如何获取静态变量（staticVar）的地址，并将该地址传递给一个过程（someFunc），地址通过
    X0 寄存器传递。
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Calculating the address of a nonstatic variable is a bit more work. Unfortunately,
    the adr and adrp instructions compute only the address of a PC-relative memory
    access. If your variable is referenced by one of the other ARM addressing modes,
    you’ll have to manually compute the effective address yourself.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 计算非静态变量的地址则需要更多的工作。不幸的是，adr 和 adrp 指令只计算与程序计数器（PC）相关的内存访问地址。如果你的变量是通过其他 ARM
    寻址模式引用的，你将不得不手动计算有效地址。
- en: '[Table 5-1](chapter5.xhtml#tab5-1) describes the process for effective address
    calculation. In the table, the [Xn, #const] (scaled form) addressing mode describes
    a machine encoding, not an assembler syntax. In source code, the scaled and unscaled
    variants share the same syntax: [Xn, #const]. The assembler will pick the correct
    machine encoding based on the value of the constant.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 5-1](chapter5.xhtml#tab5-1)描述了有效地址计算的过程。在表格中，[Xn, #const]（缩放形式）寻址模式描述的是机器编码，而不是汇编语法。在源代码中，缩放和非缩放形式共享相同的语法：[Xn,
    #const]。汇编程序会根据常数的值选择正确的机器编码。'
- en: 'Table 5-1: Effective Address Calculations'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 5-1：有效地址计算
- en: '| Addressing mode | Effective address | Description |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 寻址模式 | 有效地址 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| [Xn] | Xn | For the register-indirect addressing mode, the effective address
    is just the value held in the register. |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| [Xn] | Xn | 对于寄存器间接寻址模式，有效地址就是寄存器中保存的值。 |'
- en: '| [Xn, #const] | Xn + const | For the indirect-plus-offset addressing mode,
    the sum of the Xn register and the constant is the effective address. This assumes
    the constant is –256 to +255 and the shift is 0. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| [Xn, #const] | Xn + const | 对于间接加偏移寻址模式，有效地址是 Xn 寄存器和常量的和。假设常量范围为 -256 到
    +255，且偏移为 0。 |'
- en: '| [Xn, #const] | Xn + const (scaled) | For the scaled-indirect-plus-offset
    mode (where the scaling factor is determined by the size of the data being loaded
    or stored), the constant has to be multiplied by the size of the memory operand
    prior to adding with the Xn register. For strb/ldrb, the multiplier is 1; for
    strh/ldrh, the multiplier is 2; for str/ldr (word register), the multiplier is
    4; and for str/ldr (dword register), the multiplier is 8\. For strb/ldrb, the
    constant must be in the range 0–4,096\. For strh/ldrh, the constant must be in
    the range 0–8,191 and must be an even number. For ldr/str with a word-sized register
    operand, the constant must be in the range 0–16,383 and must be a multiple of
    4\. For ldr/str with a dword-sized register operand, the constant must be in the
    range 0–32,767 and must be a multiple of 8. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| [Xn, #const] | Xn + const (scaled) | 对于带标度的间接加偏移模式（其中标度因子由加载或存储的数据大小决定），常量在与
    Xn 寄存器相加之前，必须先乘以内存操作数的大小。对于 strb/ldrb，乘数为 1；对于 strh/ldrh，乘数为 2；对于 str/ldr（字寄存器），乘数为
    4；对于 str/ldr（双字寄存器），乘数为 8。对于 strb/ldrb，常量必须在 0 到 4,096 之间。对于 strh/ldrh，常量必须在 0
    到 8,191 之间，并且必须是偶数。对于使用字寄存器操作数的 ldr/str，常量必须在 0 到 16,383 之间，并且必须是 4 的倍数。对于使用双字寄存器操作数的
    ldr/str，常量必须在 0 到 32,767 之间，并且必须是 8 的倍数。 |'
- en: '| [Xn, #const]! | Xn + const | For the pre-indexed addressing mode, the effective
    address is the sum of the Xn register and the constant. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| [Xn, #const]! | Xn + const | 对于预索引寻址模式，有效地址是 Xn 寄存器和常量的和。 |'
- en: '| [Xn], #const | Xn | For the post-indexed addressing mode, the effective address
    is just the value in the Xn register. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| [Xn], #const | Xn | 对于后索引寻址模式，有效地址就是 Xn 寄存器中的值。 |'
- en: '| [Xn, Xm] | Xn + Xm | For the scaled-indexed addressing mode, with a scaling
    factor of 1, the effective address is the sum of the two registers (sign- or zero-extend
    Xm, if specified). |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| [Xn, Xm] | Xn + Xm | 对于标度索引寻址模式，标度因子为 1 时，有效地址是两个寄存器的和（如果指定，Xm 为符号扩展或零扩展）。
    |'
- en: '| [Xn, Xm, extend #s] | Xn + (Xm << s) | For the scaled-indexed addressing
    mode with a shift extension, the effective address is the sum of Xn plus the value
    in Xm shifted to the left s positions (with Xm zero- or sign-extended, if specified).
    |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| [Xn, Xm, extend #s] | Xn + (Xm << s) | 对于带有移位扩展的标度索引寻址模式，有效地址是 Xn 与 Xm 寄存器的值左移
    s 位后的和（如果指定，Xm 为零扩展或符号扩展）。 |'
- en: 'Suppose that a procedure has a local variable and you want to pass that on
    to a second procedure by reference. Because you access local variables by using
    the [FP, #offset] addressing mode, the effective address is FP + offset. You would
    have to use the following instruction to compute the address of that variable
    (leaving the address in X0):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '假设一个过程有一个局部变量，并且你想通过引用将该变量传递给第二个过程。由于你使用 [FP, #offset] 寻址模式访问局部变量，有效地址为 FP
    + 偏移量。你必须使用以下指令来计算该变量的地址（将地址存放在 X0 中）：'
- en: '[PRE40]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Listing 5-8 demonstrates passing a local variable as a reference parameter to
    a procedure.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-8 演示了将局部变量作为引用参数传递给过程。
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Pass by reference is usually less efficient than pass by value. You must dereference
    all pass-by-reference parameters on each access; this is slower than simply using
    a value because it typically requires at least two instructions: one to fetch
    the address into a register and one to fetch the value indirectly through that
    register.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用传递通常比通过值传递效率低。你必须在每次访问时解引用所有按引用传递的参数；这比简单地使用值更慢，因为通常至少需要两条指令：一条将地址取到寄存器中，另一条通过该寄存器间接取值。
- en: However, when passing a large data structure, pass by reference is faster because
    you do not have to copy the large data structure before calling the procedure.
    Of course, you’d probably need to access elements of that large data structure
    (such as an array) by using a pointer, so little efficiency is lost when you pass
    large arrays by reference.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在传递大型数据结构时，通过引用传递更为高效，因为你不需要在调用过程之前复制这个大型数据结构。当然，你可能需要通过指针来访问该大型数据结构的元素（比如数组），所以通过引用传递大型数组时，效率损失几乎可以忽略不计。
- en: 5.6.3 Using Low-Level Parameter Implementation
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.3 使用低级参数实现
- en: A parameter-passing mechanism is a contract between the caller and the callee
    (the procedure). Both parties have to agree on where the parameter data will appear
    and what form it will take (for example, value or address).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 参数传递机制是调用者与被调用者（过程）之间的契约。双方必须达成一致，确定参数数据的出现位置以及它的形式（例如，值或地址）。
- en: If your assembly language procedures are being called only by other assembly
    language code that you’ve written, you control both sides of the contract negotiation
    and get to decide where and how you’re going to pass parameters. However, if external
    code is calling your procedure, or your procedure is calling external code, your
    procedure will have to adhere to whatever calling convention that external code
    uses.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的汇编语言过程仅由你编写的其他汇编语言代码调用，那么你控制着双方的契约协商，并可以决定参数的传递位置和方式。然而，如果外部代码调用你的过程，或者你的过程调用外部代码，那么你的过程必须遵守外部代码使用的任何调用约定。
- en: Before discussing the particular calling conventions, this section considers
    the situation of calling code that you’ve written (and, therefore, have complete
    control over its calling conventions). The following sections describe the various
    ways you can pass parameters in pure assembly language code (without the overhead
    associated with the ARM or macOS ABIs).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论特定的调用约定之前，本节首先考虑了你自己编写的调用代码的情况（因此，你对其调用约定拥有完全的控制权）。接下来的各节描述了你可以在纯汇编语言代码中传递参数的各种方式（没有与ARM或macOS
    ABI相关的开销）。
- en: 5.6.3.1 Passing Parameters in Registers
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.6.3.1 通过寄存器传递参数
- en: Having touched on *how* to pass parameters to a procedure, the next topic to
    discuss is *where* to pass parameters. This depends on the size and number of
    those parameters. If you are passing a small number of parameters to a procedure,
    the registers are an excellent place to pass them. If you are passing a single
    parameter to a procedure, pass that data in X0, as described in [Table 5-2](chapter5.xhtml#tab5-2).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在简要介绍了*如何*传递参数之后，接下来要讨论的是*在哪里*传递参数。这取决于参数的大小和数量。如果你传递的是少量的参数，寄存器是一个非常好的传递位置。如果你传递的是单个参数，将该数据传递在X0中，如[表5-2](chapter5.xhtml#tab5-2)所述。
- en: 'Table 5-2: Parameter Size and Location'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-2：参数大小与位置
- en: '| Parameter size | Location |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 参数大小 | 位置 |'
- en: '| --- | --- |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Byte | Pass a byte parameter in the LO byte of W0. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 字节 | 将字节参数传递在W0的低字节部分。 |'
- en: '| Half word | Pass a halfword parameter in the LO half-word of W0. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 半字 | 将半字参数传递在W0的低半字部分。 |'
- en: '| Word | Pass a word in W0. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 字 | 将字传递在W0中。 |'
- en: '| Dword | Pass a dword in X0. |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| 双字 | 将双字传递在X0中。 |'
- en: '| > 8 bytes | I suggest passing a pointer to the data structure in X0, or the
    value in X0/X1 if 16 bytes or fewer. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| > 8字节 | 我建议在X0中传递指向数据结构的指针，或者如果是16字节或更少，在X0/X1中传递值。 |'
- en: When passing fewer than 32 bits in X0, the macOS ABI requires that the value
    be zero- or sign-extended throughout the X0 register. The ARM ABI does not require
    this. Of course, when passing data to a procedure you’ve written in assembly language,
    it is up to you to define what must be done with the HO bits. The safest course
    of action, portable everywhere, is to zero-extend or sign-extend the value into
    the HO bits (depending on whether the value is unsigned or signed).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当在X0中传递少于32位的数据时，macOS ABI要求该值在整个X0寄存器中进行零扩展或符号扩展。ARM ABI则没有这个要求。当然，在向你编写的汇编语言过程传递数据时，由你来定义如何处理高位。最安全的做法是将值零扩展或符号扩展到高位（取决于值是无符号还是有符号），这种做法在任何地方都具有可移植性。
- en: If you need to pass more than 8 bytes as a parameter, you could also pass that
    data in multiple registers (for example, under macOS and Linux, the C/C++ compiler
    will pass a 16-byte structure in two registers). Whether you pass the argument
    as a pointer or in multiple registers is up to you.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要传递超过8个字节的参数，你也可以通过多个寄存器传递这些数据（例如，在macOS和Linux中，C/C++编译器会通过两个寄存器传递一个16字节的结构）。无论你是将参数作为指针传递，还是通过多个寄存器传递，都取决于你。
- en: For passing parameters to a procedure in registers, the ARM ABI reserves X0
    to X7\. Of course, in pure assembly language code (that won’t call, or be called
    by, ARM ABI–compliant code), you can use whichever registers you choose. However,
    X0 through X7 should probably be your first choice unless you can provide a good
    reason for using other registers.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通过寄存器传递参数，ARM ABI保留了X0到X7寄存器。当然，在纯汇编语言代码中（它不会调用或被ARM ABI兼容代码调用），你可以使用任何你选择的寄存器。然而，X0到X7应该是你的首选，除非你能提供使用其他寄存器的充分理由。
- en: Eight parameters probably cover 95 percent of the procedures ever written. If
    you are passing more than eight parameters to a pure assembly procedure, nothing
    is stopping you from using additional registers (for example, X8 through X15).
    Likewise, nothing is stopping you from passing large objects in multiple registers,
    if you really want to do that.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 八个参数可能涵盖了95%的程序。 如果你传递给纯汇编程序的参数超过八个，没人会阻止你使用更多的寄存器（例如，X8到X15）。同样，如果你真的想这么做，也没人会阻止你通过多个寄存器传递大对象。
- en: '##### 5.6.3.2 Passing Parameters in the Code Stream'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 5.6.3.2 在代码流中传递参数'
- en: 'You can also pass parameters in the code stream immediately after the bl instruction.
    Consider the following print routine that prints a literal string constant to
    the standard output device:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在`bl`指令后立即在代码流中传递参数。考虑以下打印例程，它将一个字面字符串常量打印到标准输出设备：
- en: '[PRE42]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Normally, a subroutine returns control to the first instruction immediately
    following the bl instruction. Were that to happen here, the ARM would attempt
    to interpret the ASCII codes for "This..." as an instruction. This would produce
    undesirable results. Fortunately, you can skip over this string before returning
    from the subroutine.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个子程序会将控制权返回到`bl`指令后的第一条指令。如果在这里发生这种情况，ARM将尝试将"This..."的ASCII码解释为一条指令。这将产生不希望出现的结果。幸运的是，你可以在从子程序返回之前跳过这个字符串。
- en: 'One big issue arises with the design of the ARM CPU, however: all instructions
    must be word-aligned in memory. Therefore, the parameter data appearing in the
    code stream must be a multiple of 4 bytes long (I chose the string in this example
    to contain 39 characters so that the zero-terminating byte made the whole sequence
    40 bytes).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ARM CPU的设计存在一个大问题：所有指令必须在内存中按照字对齐。因此，出现在代码流中的参数数据必须是4字节的倍数（在这个例子中，我选择了包含39个字符的字符串，这样零终止字节使整个序列达到了40字节）。
- en: 'So how do you gain access to these parameters? Easy: the return address in
    LR points at them. Consider the implementation of print in Listing 5-9.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何访问这些参数呢？很简单：LR中的返回地址指向它们。请参考清单5-9中`print`的实现。
- en: '[PRE43]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The print procedure ❶ saves all the registers it modifies (even the volatile
    registers, because the call to write() might overwrite them). This is a normal
    assembly language convention, but it’s especially important for print because
    you want to be able to print (debug) messages without saving register values across
    your calls.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 打印过程 ❶ 保存它所修改的所有寄存器（即使是易失性寄存器，因为调用`write()`可能会覆盖它们）。这是汇编语言的常规约定，但对于打印来说尤其重要，因为你希望能够打印（调试）信息，而不必在每次调用之间保存寄存器值。
- en: LR points at the string to print upon entry into the print procedure ❷. This
    code scans through that string to find the zero-terminating byte; this scan produces
    both the length and the (approximate) return address.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当进入打印过程时，LR指向要打印的字符串 ❷。这段代码扫描该字符串以找到零终止字节；这个扫描会产生字符串的长度和（大致的）返回地址。
- en: Because code must be aligned on a 4-byte boundary, the return address isn’t
    necessarily the byte after the zero-terminating byte. Instead, the code may need
    to pad the end of string pointer by 1 to 3 bytes to advance to the next word boundary
    in the .text section ❸. Adding 3 and then ANDing the result with 0xFFFFFFFFFFFFFFFC
    (-4) pads the return address up to the appropriate boundary. The code then stores
    the return address over the original on the stack ❹.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 因为代码必须在 4 字节对齐的边界上执行，返回地址不一定是零终止字节后的一个字节。相反，代码可能需要将字符串指针的末尾填充 1 到 3 字节，以便在 `.text`
    区段中跳到下一个字边界 ❸。将 3 加上后，再与 0xFFFFFFFFFFFFFFFC（-4）进行按位与运算，填充返回地址到适当的边界。然后，代码会将返回地址覆盖原有的堆栈地址
    ❹。
- en: Once you have the string length, you can call the C stdlib write function to
    print it ❺ (if the first argument is 0, this prints the string to the standard
    output device). On exit, the code restores the registers you saved earlier ❻.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你得到字符串的长度，就可以调用 C 标准库的写入函数来打印它 ❺（如果第一个参数是 0，则将字符串打印到标准输出设备）。在退出时，代码会恢复之前保存的寄存器
    ❻。
- en: For this listing, I included two exclamation marks ❼ so that the length of the
    string (including the zero-terminating byte) is a multiple of four characters.
    This ensures that the following instruction is aligned on a 4-byte boundary.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例程中，我添加了两个感叹号 ❼，使得字符串的长度（包括零终止字节）成为 4 的倍数。这确保了接下来的指令能够在 4 字节对齐的边界上执行。
- en: To avoid a bus fault, the length of the data following the call to print must
    be a multiple of 4 bytes so that the next instruction is properly aligned on a
    4-byte boundary. The length of the string itself doesn’t have to be a multiple
    of 4 bytes; arbitrary padding after the zero-terminating byte is fine. Rather
    than counting the number of characters in the string, you could use the Gas .p2align
    directive. This directive will pad the location counter to a boundary that is
    a multiple of 2*^n* bytes, where *n* is the (first) value in the .p2align operand
    field. For example
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免总线错误，打印调用后跟随的数据长度必须是 4 字节的倍数，以确保下一条指令能够正确地在 4 字节对齐的边界上执行。字符串本身的长度不必是 4 字节的倍数；在零终止字节后加上任意的填充字节是可以的。你可以不必计算字符串中的字符数，而是使用
    Gas 的 `.p2align` 指令。这个指令会将位置计数器对齐到一个是 2*^n* 字节倍数的边界，其中 *n* 是 `.p2align` 操作数字段中的第一个值。例如
- en: '[PRE44]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: pads the location counter to the next word boundary.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 将位置计数器填充到下一个字边界。
- en: 'Using the .p2align 2 directive, you can call the print procedure with an arbitrary-length
    string as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `.p2align 2` 指令，你可以如下所示调用打印过程，传递任意长度的字符串：
- en: '[PRE45]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Remembering to put the .p2align 2 directive in the code can be difficult, not
    to mention that having to type it is a pain, and it clutters up your code. To
    resolve this, the *aoaa.inc* include file includes a wastr (word-aligned string)
    macro that automatically adds the padding for you:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在代码中加入 `.p2align 2` 指令可能会很困难，更不用说需要输入它还很麻烦，而且会让你的代码变得杂乱。为了解决这个问题，*aoaa.inc*
    包含了一个 `wastr`（字对齐字符串）宏，它会自动为你添加填充：
- en: '[PRE46]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Besides showing how to pass parameters in the code stream, the print routine
    also exhibits another concept: *variable-length parameters* (the length of the
    string can be arbitrarily long). The string following the bl can be any practical
    length. The zero-terminating byte marks the end of the parameter list. You can
    handle variable-length parameters in two easy ways: either use a special terminating
    value (like 0) or pass a special length value that tells the subroutine the number
    of parameters you are passing. Both methods have advantages and disadvantages.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 除了展示如何在代码流中传递参数外，打印例程还展示了另一个概念：*可变长度参数*（字符串的长度可以是任意长）。跟在 `bl` 后面的字符串可以是任何实际长度。以零终止的字节标记参数列表的结束。你可以通过两种简单的方式处理可变长度参数：要么使用一个特殊的终止值（如
    0），要么传递一个特殊的长度值，告诉子例程你传递了多少参数。两种方法各有优缺点。
- en: Using a special value to terminate a parameter list requires that you choose
    a value that never appears in the list. For example, print uses 0 as the terminating
    value, so it cannot print the NUL character (whose ASCII code is 0). Sometimes
    this isn’t a limitation. Specifying a length parameter is another mechanism you
    can use to pass a variable-length parameter list. While this doesn’t require any
    special codes or limit the range of possible values that can be passed to a subroutine,
    setting up the length parameter and maintaining the resulting code can be a real
    nightmare; this is especially true if the parameter list changes frequently.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特殊值来终止参数列表要求选择一个永远不会出现在列表中的值。例如，print 使用 0 作为终止值，因此它不能打印 NUL 字符（其 ASCII 码为
    0）。有时，这并不是一个限制。指定长度参数是另一种可以用来传递可变长度参数列表的机制。虽然这不需要任何特殊代码，也不会限制可以传递给子例程的值范围，但设置长度参数并维护结果代码可能会成为一个真正的噩梦；尤其是在参数列表经常变化的情况下，这一点尤为明显。
- en: Despite the convenience afforded by passing parameters in the code stream, this
    method also has disadvantages. First, if you fail to provide the exact number
    of parameters the procedure requires, the subroutine will get confused. Consider
    the print example. It prints a string of characters up to a zero-terminating byte
    and then returns control to the first instruction following that byte. If you
    leave off the zero-terminating byte, the print routine happily prints the following
    opcode bytes as ASCII characters until it finds a 0 byte. Because 0 bytes often
    appear in the middle of an instruction, the print routine might return control
    into the middle of another instruction, which will probably crash the machine.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在代码流中传递参数带来了便利，但这种方法也有缺点。首先，如果没有提供程序所需的精确数量的参数，子例程将会混淆。考虑 print 的例子。它打印一串字符直到遇到一个零终止字节，然后将控制权返回到该字节后的第一条指令。如果没有提供零终止字节，print
    例程会很高兴地将随后的操作码字节作为 ASCII 字符打印，直到找到一个 0 字节。由于 0 字节经常出现在指令的中间，print 例程可能会将控制权返回到另一条指令的中间，这可能会导致机器崩溃。
- en: On the ARM, you must ensure that the parameters you pass in the code stream
    are a multiple of 4 bytes long. The instructions following the parameters must
    lie on a word boundary. Problems notwithstanding, however, the code stream is
    an efficient place to pass parameters whose values do not change.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ARM 上，必须确保传递的参数在代码流中是 4 字节的倍数。紧随其后的指令必须位于字边界上。尽管存在一些问题，然而，代码流仍然是传递那些值不变的参数的高效方式。
- en: 5.6.3.3 Passing Parameters on the Stack
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.6.3.3 在栈上传递参数
- en: Most HLLs use the stack to pass a large number of parameters because this method
    is fairly efficient. Although passing parameters on the stack is slightly less
    efficient than doing so in registers, the register set is limited (especially
    if you’re limiting yourself to the eight registers the ARM ABI sets aside for
    this purpose). The stack, on the other hand, allows you to pass a large amount
    of parameter data without difficulty. This is the reason that most programs pass
    their parameters on the stack (at least, when passing more than eight parameters).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数高级语言（HLL）使用栈来传递大量参数，因为这种方法相当高效。尽管在栈上传递参数的效率稍逊于在寄存器中传递，但寄存器集是有限的（尤其是如果你只限于
    ARM ABI 为此目的预留的 8 个寄存器）。另一方面，栈允许你轻松地传递大量参数数据。这就是为什么大多数程序在栈上传递参数的原因（至少在传递超过 8 个参数时）。
- en: 'To manually pass parameters on the stack, push them immediately before calling
    the subroutine (just remember to keep the stack 16-byte aligned). The subroutine
    then reads this data from the stack memory and operates on it appropriately. Consider
    the following HLL function call:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动在栈上传递参数，在调用子例程之前立即将其压入栈中（只需记住保持栈的 16 字节对齐）。子例程随后从栈内存中读取这些数据并进行适当的操作。考虑以下
    HLL 函数调用：
- en: '[PRE47]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Because keeping SP aligned on a 16-byte boundary is crucial, you can’t simply
    push one argument at a time with a str instruction, nor can you push values smaller
    than 32 bits. Assuming that i, j, and k are 32-bit integers, you would need to
    somehow marshal them together into a 128-bit package (including an extra 32 bits
    of unused data) and push 16 bytes onto the stack. This is so inconvenient that
    ARM code almost never pushes individual (or even pairs of) register values onto
    the stack.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 因为保持 SP 在 16 字节边界上对齐至关重要，所以你不能仅通过 str 指令一次推送一个参数，也不能推送小于 32 位的值。假设 i、j 和 k 是
    32 位整数，你需要将它们以某种方式打包成一个 128 位的单元（包括多余的 32 位未使用数据），然后将 16 字节推送到栈上。这是非常不方便的，因此 ARM
    代码几乎从不将单个（甚至成对的）寄存器值推送到栈上。
- en: 'The common solution in ARM assembly language is first to drop the stack down
    by however many bytes you need (plus any padding, to make sure the stack is aligned
    properly), and then to simply store your parameters into the stack space so allocated.
    For example, to call CallProc, you might use code like the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ARM 汇编语言中常见的解决方案是，首先将栈下移所需的字节数（加上任何填充字节，以确保栈对齐正确），然后将参数存储到这样分配的栈空间中。例如，要调用
    CallProc，你可以使用如下代码：
- en: '[PRE48]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The sub instruction allocates 16 bytes on the stack; you need only 12 for the
    three 32-bit parameters, but you must allocate 16 to keep the stack aligned.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: sub 指令在栈上分配了 16 字节；你只需要 12 字节来存放三个 32 位参数，但必须分配 16 字节以保持栈对齐。
- en: The three str instructions store the parameter data (which is presumed to be
    in W0, W1, and W2 by this code) into the 12 bytes from SP + 0 through SP + 11\.
    The CallProc will simply ignore the extra 4 bytes allocated on the stack.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这三条 str 指令将参数数据（假定该代码将其存储在 W0、W1 和 W2 中）存储到从 SP + 0 到 SP + 11 的 12 字节中。CallProc
    将简单地忽略栈上分配的额外 4 字节。
- en: In this example, the three 32-bit integers are packed into memory, each consuming
    4 bytes on the stack. So the i parameter is found at SP + 0, the j parameter is
    found at SP + 4, and the k parameter is found at SP + 8 upon entry into CallProc
    (see [Figure 5-6](chapter5.xhtml#fig5-6)).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，三个 32 位整数被打包到内存中，每个整数在栈上占用 4 字节。因此，i 参数在进入 CallProc 时位于 SP + 0，j 参数位于
    SP + 4，k 参数位于 SP + 8（见 [图 5-6](chapter5.xhtml#fig5-6)）。
- en: '![](../images/Figure5-6.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-6.jpg)'
- en: 'Figure 5-6: Stack layout upon entry into CallProc'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-6：进入 CallProc 时的栈布局
- en: 'If your procedure includes the standard entry and exit sequences, you may directly
    access the parameter values in the activation record by indexing off the FP register.
    Consider the layout of the activation record for CallProc that uses the following
    declaration:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的过程包含标准的入口和退出序列，你可以通过从 FP 寄存器索引直接访问激活记录中的参数值。考虑以下声明的 CallProc 激活记录布局：
- en: '[PRE49]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'At this point, i’s value can be found at [FP, #16], j’s value can be found
    at [FP, #20], and k’s value can be found at [FP, #24] (see [Figure 5-7](chapter5.xhtml#fig5-7)).'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '此时，i 的值可以在 [FP, #16] 找到，j 的值可以在 [FP, #20] 找到，k 的值可以在 [FP, #24] 找到（见 [图 5-7](chapter5.xhtml#fig5-7)）。'
- en: '![](../images/Figure5-7.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-7.jpg)'
- en: 'Figure 5-7: CallProc activation record after standard entry sequence'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-7：标准入口序列后的 CallProc 激活记录
- en: 'Within the CallProc procedure, you can access the parameter values with these
    instructions:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CallProc 过程内，你可以使用以下指令访问参数值：
- en: '[PRE50]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Of course, using magic numbers such as these to reference the parameter offsets
    is still a bad idea. It would be far better to use equates or, even better, create
    a declaration macro similar to struct and locals to define the parameters for
    a procedure. The *aoaa.inc* file contains just such a macro: args (and enda).
    Listing 5-10 demonstrates the use of this macro.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，像这样使用魔法数字来引用参数偏移量仍然是一个不好的主意。最好使用等式，或者更好的是，创建一个类似于结构体和局部变量的声明宏来定义过程的参数。*aoaa.inc*
    文件包含了这样一个宏：args（和 enda）。清单 5-10 演示了该宏的使用。
- en: '[PRE51]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The args macro requires an argument list name, which can be the procedure name
    or an abbreviation of it, and an optional second argument with a starting offset.
    The second argument defaults to 16, which is an appropriate value if the procedure
    uses the standard entry sequence (pushing the LR and FP registers on the stack).
    Offsets associated with the parameters you declare are offsets from FP in the
    procedure.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: args 宏需要一个参数列表名称，可以是过程名称或其缩写，此外还可以指定一个可选的第二个参数作为起始偏移量。第二个参数默认为 16，这是一个适用于使用标准入口序列的过程的合适值（该序列将
    LR 和 FP 寄存器压入栈中）。你声明的参数的偏移量是相对于过程中的 FP 的偏移量。
- en: 'Here’s the build command and sample output for Listing 5-10:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第 5-10 号列表的构建命令和示例输出：
- en: '[PRE52]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If your procedure does not use the standard entry sequence, you can specify
    an explicit offset as the second argument. For example:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序没有使用标准的进入顺序，你可以将一个显式的偏移量作为第二个参数。例如：
- en: '[PRE53]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If you aren’t pushing anything on the stack in the procedure (or allocating
    local variables), 0 is a good value to use; then the offsets are SP based rather
    than FP based.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在过程中没有将任何内容推入栈中（或分配局部变量），使用 0 是一个不错的值；这样偏移量是基于 SP，而不是基于 FP。
- en: 5.6.3.4 Removing Parameters in Callee vs. Caller Stack Cleanup
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.6.3.4 被调用者与调用者栈清理中的参数移除
- en: When passing parameters on the stack, ultimately those parameters must be removed
    from the stack. The ARM ABI specifies that the caller is responsible for removing
    all parameters it pushes onto the stack. Most of the example programs in this
    book thus far have (implicitly) done this.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过栈传递参数时，这些参数最终必须从栈中移除。ARM ABI 规定调用者负责移除它推入栈中的所有参数。本书中大多数示例程序到目前为止已经（隐式地）完成了这一操作。
- en: Removing the parameters after every procedure call is slow and inefficient.
    Fortunately, an easy optimization eliminates the need to allocate and deallocate
    parameter storage for each function call. Upon entry into a procedure, when allocating
    storage for local variables, include additional storage to be used for parameters
    the procedure passes to other functions. This, in fact, has been the whole purpose
    of the “magic stack allocation” instructions at the beginning of most procedures
    in this book up to this point. The examples thus far have typically reserved 64
    or 256 bytes of storage on the stack (enough for between eight and thirty-two
    64-bit parameters, respectively).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用过程后移除参数是缓慢且低效的。幸运的是，一个简单的优化消除了为每个函数调用分配和释放参数存储的需要。进入过程时，在分配局部变量的存储空间时，额外分配一些存储空间，用于存储过程传递给其他函数的参数。事实上，这也是本书中大多数过程开始时“魔术栈分配”指令的目的。到目前为止的示例通常在栈上保留了
    64 或 256 字节的存储空间（分别足够存储 8 到 32 个 64 位参数）。
- en: Functions that pass parameters on the stack, such as printf() running on macOS,
    can store data into this area prior to calling the function. Upon return from
    the function, your code does not have to worry about cleaning up the parameters.
    That stack space is now available for the next function you want to call that
    requires stack parameters.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 像在 macOS 上运行的 printf() 这样的函数，通过栈传递参数时，可以在调用函数之前将数据存储到这个区域。返回函数时，代码无需担心清理参数，因为该栈空间现在可以供下一个需要栈参数的函数使用。
- en: Ultimately, of course, the parameters must be deallocated from the stack. That
    happens when the procedure executes the leave macro (or manually copies FP into
    SP, which is part of leave’s expansion). When using enter and leave to allocate
    this stack space for the parameters, along with any local variables a procedure
    might need, you need to allocate and deallocate the stack space only once, not
    for each individual procedure call.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最终这些参数必须从栈中释放。这发生在过程执行 leave 宏时（或手动将 FP 复制到 SP，这是 leave 扩展的一部分）。当使用 enter
    和 leave 分配这些栈空间用于参数，以及过程可能需要的任何局部变量时，你只需要分配和释放栈空间一次，而不是为每个单独的过程调用分配和释放。
- en: 'If your procedure doesn’t have any local variables, you can easily allocate
    stack space for parameters by using code like the following:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序没有任何局部变量，你可以像以下代码那样轻松分配栈空间来存储参数：
- en: '[PRE54]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If your procedure requires local variable storage, just specify the extra stack
    space as a dummy local variable at the end of your locals declaration:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序需要局部变量存储，只需将额外的栈空间作为虚拟局部变量放在局部变量声明的末尾：
- en: '[PRE55]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Remember that enter always allocates a multiple of 16 bytes, so we know that
    the stack storage will be aligned on a 16-byte boundary.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，enter 总是分配 16 字节的倍数空间，因此我们知道栈存储会对齐到 16 字节边界。
- en: 5.6.3.5 Passing Parameters to the C/C++ printf() Function
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 5.6.3.5 向 C/C++ 的 printf() 函数传递参数
- en: Under Linux, you pass the first eight printf() parameters in registers, just
    as you would any other nonvariadic function. On macOS, those parameters are always
    passed on the stack, each occupying a dword. Until now, this book has used the
    vparmsn macros to handle the difference in the way parameters are passed (and,
    of course, to avoid dealing with the stack, which the book hadn’t covered in the
    earlier chapters).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 下，你通过寄存器传递前八个 printf() 参数，就像你处理任何其他非变参函数一样。而在 macOS 下，这些参数总是通过栈传递，每个参数占一个双字（dword）。直到现在，本书使用了
    vparmsn 宏来处理传递参数方式的差异（当然，也为了避免处理栈，因为本书在前几章并未涉及栈的相关内容）。
- en: In this book, I strived to write code that is portable between Linux and macOS,
    resorting to OS-specific code only as necessary; this was part of the motivation
    for using the vparmsn macros when calling printf(). Now that you’ve learned how
    these two OSes expect you to pass variadic parameters, you’ll probably want to
    pass parameters in a more flexible manner than using the vparmsn macros. Nevertheless,
    there is great benefit (at least for the source code in this book) to writing
    portable code. Fortunately, with a little sleight of hand, it is possible to directly
    pass the parameters to printf() without using vparmsn and still have the code
    assemble and run on both OSes.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的写作目标是编写可在 Linux 和 macOS 之间移植的代码，仅在必要时使用特定于操作系统的代码；这也是在调用 printf() 时使用 vparmsn
    宏的动机之一。现在你已经了解了这两种操作系统如何传递变参，可能会想用比 vparmsn 宏更灵活的方式来传递参数。不过，编写可移植代码有很大的好处（至少对本书中的源代码而言）。幸运的是，通过一些技巧，完全可以在不使用
    vparmsn 宏的情况下，直接将参数传递给 printf()，并且让代码在这两种操作系统上都能组装和运行。
- en: 'The first rule is to load each printf() argument into X0 through X7\. This
    puts the arguments into the locations where Linux expects them. Once the arguments
    are in these registers, you’ll also store them into the stack storage area at
    SP + 0, SP + 8, SP + 16, ..., SP + 56 (which is where macOS expects them). Here’s
    a typical call to printf() printing the values in X0, X5, and X7:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个规则是将每个 printf() 的参数加载到 X0 到 X7 寄存器中。这会将参数放置到 Linux 期望的位置。一旦参数进入这些寄存器，你还需要将它们存储到栈的存储区（SP
    + 0、SP + 8、SP + 16、...、SP + 56），这是 macOS 期望它们的位置。下面是一个典型的 printf() 调用，打印 X0、X5
    和 X7 中的值：
- en: '[PRE56]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Strictly speaking, the str instructions aren’t necessary when running under
    Linux. To allow the creation of slightly more efficient code, I’ve provided the
    following mstr macro in the *aoaa.inc* include file:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，在 Linux 环境下运行时，str 指令并不是必需的。为了生成稍微更高效的代码，我在 *aoaa.inc* 包含文件中提供了以下的 mstr
    宏：
- en: '[PRE57]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This macro assembles to nothing under Linux and to the corresponding str instruction
    under macOS. If you rewrite the former code by using mstr, it will not generate
    any excess code under Linux:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏在 Linux 下不会生成任何代码，而在 macOS 下则会生成相应的 str 指令。如果你使用 mstr 重写之前的代码，它在 Linux 下不会生成任何多余的代码：
- en: '[PRE58]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Of course, if you’re writing code only for Linux and don’t care at all about
    macOS portability, you can drop the mstr instructions altogether to remove some
    clutter.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你只为 Linux 编写代码，并且完全不关心 macOS 的移植性，你可以完全去掉 mstr 指令，从而减少一些杂乱的代码。
- en: 5.6.4 Accessing Reference Parameters on the Stack
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.4 访问栈上的引用参数
- en: Because you pass the addresses of objects as reference parameters, accessing
    the reference parameters within a procedure is slightly more difficult than accessing
    value parameters, as you must dereference the pointers to the reference parameters.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你传递的是对象的地址作为引用参数，所以在过程内部访问引用参数比访问值参数稍微困难一些，你必须解引用引用参数的指针。
- en: Consider Listing 5-11, which demonstrates a single pass-by-reference parameter.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑列表 5-11，它演示了一个单一的引用传递参数。
- en: '[PRE59]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The refParm procedure fetches the reference parameter (a 64-bit pointer) into
    X1 1 and then immediately dereferences this pointer by fetching the 32-bit word
    at the address in X1\. The mstr macro ❷ stores the second parameter onto the stack
    (under macOS). To pass a variable by reference to refParm ❸, you must compute
    its effective address and pass that.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: refParm 过程将引用参数（一个 64 位指针）加载到 X1 1 中，然后立即通过获取 X1 地址中的 32 位字来解引用此指针。mstr 宏 ❷
    将第二个参数存储到栈中（在 macOS 下）。为了将一个变量通过引用传递给 refParm ❸，你必须计算它的有效地址并将其传递过去。
- en: 'Here is the build command and sample output for the program in Listing 5-11:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是列表 5-11 中程序的构建命令和示例输出：
- en: '[PRE60]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you can see, accessing (small) pass-by-reference parameters is a little less
    efficient than accessing value parameters, because you need an extra instruction
    to load the address into a 64-bit pointer register (not to mention that you have
    to reserve a 64-bit register for this purpose). If you access reference parameters
    frequently, these extra instructions can really begin to add up, reducing the
    efficiency of your program.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，访问（小型）按引用传递的参数比访问值参数效率稍低，因为你需要额外的指令将地址加载到64位指针寄存器中（更不用说你还需要为此目的保留一个64位寄存器）。如果频繁访问引用参数，这些额外的指令会累积起来，降低程序的效率。
- en: Furthermore, it’s easy to forget to dereference a reference parameter and use
    the address of the value in your calculations. Therefore, unless you really need
    to affect the value of the actual parameter, you should use pass by value to pass
    small objects to a procedure.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，容易忘记解引用引用参数并在计算中使用值的地址。因此，除非你确实需要影响实际参数的值，否则你应该使用按值传递将小对象传递给过程。
- en: Passing large objects, like arrays and records, is where using reference parameters
    becomes efficient. When passing these objects by value, the calling code has to
    make a copy of the actual parameter; if it is a large object, the copy process
    can be inefficient. Because computing the address of a large object is just as
    efficient as computing the address of a small scalar object, no efficiency is
    lost when passing large objects by reference. Within the procedure, you must still
    dereference the pointer to access the object, but the efficiency loss due to indirection
    is minimal when you contrast this with the cost of copying that large object.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 传递大型对象，如数组和记录，是使用引用参数变得高效的地方。当按值传递这些对象时，调用代码必须复制实际参数；如果是大型对象，复制过程可能效率低下。因为计算大型对象的地址与计算小型标量对象的地址一样高效，所以按引用传递大型对象时不会丧失效率。在过程内，你仍然需要解引用指针以访问对象，但与复制大型对象的成本相比，由间接访问引起的效率损失可以忽略不计。
- en: Listing 5-12 demonstrates how to use pass by reference to initialize an array
    of structures.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 示例5-12演示了如何使用按引用传递来初始化结构体数组。
- en: '[PRE61]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The code computes the address of the Pts array and passes this array (by reference)
    to the refAryParm procedure ❸. It loads this address into X1 ❶ and uses this pointer
    value as the base address of the array that refAryParm processes ❷.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码计算了Pts数组的地址，并将该数组（按引用）传递给refAryParm过程❸。它将该地址加载到X1 ❶，并使用该指针值作为refAryParm处理的数组的基地址❷。
- en: 'Here’s the build command and sample output:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建命令和示例输出：
- en: '[PRE62]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This output shows how the refAryParm procedure initialized the array.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示了refAryParm过程是如何初始化数组的。
- en: 5.7 Functions and Function Return Results
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7 函数及其返回结果
- en: '*Functions* are procedures that return a result to the caller. In assembly
    language, few syntactical differences exist between a procedure and a function.
    This is why *aoaa.inc* doesn’t provide a specific macro declaration for a function.
    Nevertheless, semantic differences exist; although you can declare them the same
    way in Gas, you use them differently.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*是将结果返回给调用者的过程。在汇编语言中，过程和函数之间的语法差异很小。这就是为什么*aoaa.inc*没有为函数提供特定宏声明的原因。然而，语义上仍然存在差异；虽然你可以在Gas中以相同的方式声明它们，但使用方式却不同。'
- en: '*Procedures* are a sequence of machine instructions that fulfill a task. The
    end result of the execution of a procedure is the accomplishment of that activity.
    Functions, on the other hand, execute a sequence of machine instructions specifically
    to compute a value to return to the caller. Of course, a function can perform
    an activity as well, and procedures can undoubtedly compute values, but the main
    difference is that the purpose of a function is to return a computed result; procedures
    don’t have this requirement.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '*过程*是一系列完成任务的机器指令。过程执行的最终结果是完成该活动。而函数则执行一系列机器指令，专门计算一个值并返回给调用者。当然，函数也可以执行某些活动，过程也可以计算值，但主要的区别是函数的目的是返回一个计算结果；过程则没有这个要求。'
- en: In assembly language, you don’t specifically define a function by using special
    syntax. In Gas, everything is a procedure. A section of code becomes a function
    when the programmer explicitly decides to return a function result via the procedure’s
    execution.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，你不会使用特殊语法来专门定义一个函数。在Gas中，一切都是过程。当程序员明确决定通过过程的执行返回函数结果时，代码段才变成函数。
- en: The registers are the most common place to return function results. The strlen()
    routine in the C stdlib is a good example of a function that returns a value in
    one of the CPU’s registers. It returns the length of the string (whose address
    you pass as a parameter) in the X0 register.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器是返回函数结果最常见的地方。C 标准库中的 strlen() 函数就是一个很好示例，它在 CPU 的一个寄存器中返回一个值。它会将字符串的长度（你作为参数传递的字符串地址）返回在
    X0 寄存器中。
- en: By convention, programmers try to return 8-, 16-, and 32-bit results in the
    W0 register and 64-bit values in the X0 register. This is where most HLLs return
    these types of results, and it’s where the ARM ABI states that you should return
    function results. The exception is floating-point values; I discuss floating-point
    function results in [Chapter 6](chapter6.xhtml).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，程序员会尝试将 8 位、16 位和 32 位的结果返回在 W0 寄存器中，而将 64 位值返回在 X0 寄存器中。这是大多数高级语言（HLL）返回这些类型结果的地方，也是
    ARM ABI 规范中规定返回函数结果的地方。例外的是浮点值；我会在[第 6 章](chapter6.xhtml)中讨论浮点函数结果。
- en: There is nothing particularly sacred about the W0/X0 register. You can return
    function results in any register if it’s more convenient to do so. Of course,
    if you’re calling an ARM ABI–compliant function, such as strlen(), you have no
    choice but to expect the function’s return result in the X0 register. The strlen()
    function returns an integer in X0, for example.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: W0/X0 寄存器并没有什么特别神圣的地方。如果更方便的话，你可以在任何寄存器中返回函数结果。当然，如果你调用的是符合 ARM ABI 规范的函数，比如
    strlen()，那么你只能期待函数的返回结果在 X0 寄存器中。例如，strlen() 函数会将一个整数返回在 X0 中。
- en: If you need to return a function result that is larger than 64 bits, you obviously
    must return it somewhere other than in X0 (which can hold only 64-bit values).
    For values slightly larger than 64 bits (for example, 128 bits or maybe even as
    many as 256 bits), you can split the result into pieces and return those parts
    in two or more registers. It is not uncommon to see functions returning 128-bit
    values in the X1:X0 register pair. Just keep in mind that these schemes are not
    ARM ABI compliant, so they’re practical only when calling code you’ve written.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要返回一个大于 64 位的函数结果，显然必须将其返回到 X0 以外的地方（因为 X0 只能容纳 64 位值）。对于稍大于 64 位的值（例如 128
    位，甚至可能是 256 位），你可以将结果分割成若干部分，并在两个或更多寄存器中返回这些部分。看到函数将 128 位值返回在 X1:X0 寄存器对中并不罕见。只是要记住，这些方案不符合
    ARM ABI 规范，因此仅在调用你自己编写的代码时才实际可用。
- en: If you need to return a large object as a function result (say, an array of
    1,000 elements), you obviously are not going to be able to return the function
    result in the registers. When returning function results greater than 64 bits,
    the ARM ABI specifies that the caller allocate storage for the result and pass
    a pointer to that storage in X8\. The function places the result in that storage,
    and the caller retrieves the data from that location upon return.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要返回一个较大的对象作为函数结果（比如一个包含 1000 个元素的数组），显然你不可能将函数结果返回在寄存器中。当返回超过 64 位的函数结果时，ARM
    ABI 规范要求调用者为结果分配存储空间，并在 X8 中传递指向该存储空间的指针。函数将结果放入该存储空间，调用者在返回时从该位置检索数据。
- en: 5.8 Recursion
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8 递归
- en: '*Recursion* occurs when a procedure calls itself. The following, for example,
    is a recursive procedure:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '*递归* 是指一个过程调用它自身。例如，以下是一个递归过程：'
- en: '[PRE63]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Of course, the CPU will never return from this procedure. Upon entry into Recursive,
    this procedure will immediately call itself again, and control will never pass
    to the end of the procedure. In this case, runaway recursion results in a logical
    infinite loop that produces stack overflow, at which point the OS will raise an
    exception and stop the program.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，CPU 永远不会从这个过程返回。在进入 Recursive 时，这个过程会立即再次调用自身，控制永远不会传递到过程的末尾。在这种情况下，失控的递归会导致逻辑上的无限循环，进而产生栈溢出，此时操作系统会引发异常并停止程序。
- en: 'Like a looping structure, recursion requires a termination condition in order
    to stop infinite recursion. Recursive could be rewritten with a termination condition
    as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于循环结构，递归需要一个终止条件来避免无限递归。递归可以在加上终止条件后重写如下：
- en: '[PRE64]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This modification to the routine causes Recursive to call itself the number
    of times appearing in the X0 register. On each call, Recursive decrements the
    X0 register by 1 and then calls itself again. Eventually, Recursive decrements
    X0 to 0 and returns from each call until it returns to the original caller.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 对该例程的修改使得Recursive按照X0寄存器中显示的次数调用自身。每次调用时，Recursive将X0寄存器减1，然后再次调用自身。最终，Recursive将X0减到0并从每个调用中返回，直到它返回到原始调用者。
- en: 'So far in this section, there hasn’t been a real need for recursion. After
    all, you could efficiently code this procedure as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本节中还没有真正需要递归的地方。毕竟，你可以高效地按照以下方式编写这个过程：
- en: '[PRE65]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Both of these last two examples would repeat the body of the procedure the number
    of times passed in the X0 register. (The latter version will do it considerably
    faster because it doesn’t have the overhead of the bl/ret instructions.) As it
    turns out, you cannot implement only a few recursive algorithms in an iterative
    fashion. However, many recursively implemented algorithms are more efficient than
    their iterative counterparts, and most of the time the recursive form of the algorithm
    is much easier to understand.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个最后的例子会根据X0寄存器传入的次数重复执行过程的主体。（后一种版本会显著更快，因为它没有bl/ret指令的开销。）事实证明，并不是所有的递归算法都能以迭代的方式实现。然而，许多递归实现的算法比其迭代版本更高效，而且大多数情况下递归形式的算法更容易理解。
- en: The *quicksort algorithm* is probably the most famous algorithm that usually
    appears in recursive form. Listing 5-13 shows a Gas implementation of this algorithm.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '*快速排序算法*可能是最著名的通常以递归形式出现的算法。列表5-13展示了该算法的Gas实现。'
- en: '[PRE66]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here’s the build command and output for Listing 5-13:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是列表5-13的构建命令和输出：
- en: '[PRE67]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This output shows the contents of the array prior to sorting and after the quicksort
    procedure has sorted the array.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出展示了数组在排序之前和经过快速排序过程后排序后的内容。
- en: 5.9 Procedure Pointers and Procedural Parameters
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.9 过程指针和过程参数
- en: 'The ARM bl instruction supports an indirect form: blr. This instruction has
    the following syntax:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ARM的bl指令支持间接形式：blr。该指令的语法如下：
- en: '[PRE68]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This instruction fetches the address of a procedure’s first instruction from
    this specified register. It is equivalent to the following pseudo-instructions:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令从指定的寄存器中获取一个过程的第一条指令的地址。它等效于以下伪指令：
- en: '[PRE69]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Gas treats procedure names like static objects. Therefore, you can compute the
    address of a procedure by using the lea macro along with the procedure’s name.
    For example
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Gas将过程名称视为静态对象。因此，你可以通过使用lea宏和过程名称来计算一个过程的地址。例如
- en: '[PRE70]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'loads the address of the very first instruction of the procName procedure into
    X0\. The following code sequence winds up calling the procName procedure:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 将`procName`过程的第一条指令的地址加载到X0寄存器中。以下代码序列最终会调用`procName`过程：
- en: '[PRE71]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Because the address of a procedure fits in a 64-bit object, you can store such
    an address into a double-word variable; in fact, you can initialize a double-word
    variable with the address of a procedure by using code like the following:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 因为过程的地址适合存储在一个64位对象中，你可以将该地址存储到一个双字变量中；事实上，你可以通过以下代码将过程的地址初始化到双字变量中：
- en: '[PRE72]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note that although macOS does not allow you to initialize a dword variable in
    the .text section with the address of an object outside the .text section, it
    will allow you to initialize a pointer (in any section) with the address of some
    code within the .text section.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管macOS不允许你在.text段中使用外部地址初始化一个dword变量，但它允许你使用.text段内某些代码的地址初始化一个指针（无论在任何段中）。
- en: 'As with all pointer objects, you should not attempt to indirectly call a procedure
    through a pointer variable unless you’ve initialized that variable with an appropriate
    address. You can initialize a procedure pointer variable in two ways: you can
    create dword variables with initializers in the .data, .text, and .rodata sections,
    or you can compute the address of a routine (as a 64-bit value) and store that
    64-bit address directly into the procedure pointer at runtime. The following code
    fragment demonstrates both ways to initialize a procedure pointer:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 和所有指针对象一样，除非你已经用合适的地址初始化了指针变量，否则不要尝试通过指针变量间接调用一个过程。你可以通过两种方式初始化过程指针变量：你可以在.data、.text和.rodata段中创建带有初始化器的dword变量，或者你可以计算一个例程的地址（作为64位值）并在运行时将该64位地址直接存储到过程指针中。以下代码片段演示了两种初始化过程指针的方法：
- en: '[PRE73]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Although all the examples in this section use static variable declarations (.data,
    .text, .bss, and .rodata), you aren’t limited to declaring simple procedure pointers
    in the static variable declaration sections. You can also declare procedure pointers
    (which are just dword variables) as local variables, pass them as parameters,
    or declare them as fields of a record or a union.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本节中的所有示例都使用静态变量声明（.data、.text、.bss 和 .rodata），但你并不限于在静态变量声明部分声明简单的程序指针。你还可以将程序指针（它们只是双字变量）声明为局部变量、作为参数传递，或者将它们声明为记录或联合体的字段。
- en: Procedure pointers are also invaluable in parameter lists. Selecting one of
    several procedures to call by passing the address of a procedure is a common operation.
    A *procedural parameter* is just a double-word parameter containing the address
    of a procedure, so passing a procedural parameter is really no different from
    using a local variable to hold a procedure pointer (except, of course, that the
    caller initializes the parameter with the address of the procedure to call indirectly).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 程序指针在参数列表中也非常宝贵。通过传递程序的地址来选择多个程序中的一个进行调用是一种常见操作。*过程参数*仅仅是一个包含程序地址的双字参数，因此传递一个过程参数实际上与使用局部变量保存程序指针没有什么不同（当然，调用者会用间接调用的程序地址来初始化这个参数）。
- en: 5.10 A Program-Defined Stack
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.10 程序定义的栈
- en: Using the pre- and post-indexed addressing modes, along with one of the ARM’s
    64-bit registers, it is possible to create software-controlled stacks that don’t
    use the SP register. Since the ARM CPU provides a hardware stack pointer register,
    it may not be obvious why you’d consider using another stack. As you’ve learned,
    one limitation of the ARM’s hardware stack is that it must be 16-byte aligned
    at all times. Return addresses and other values you might want to preserve on
    the stack are generally 8 bytes or smaller. For example, you cannot push the LR
    register onto the stack by itself without causing a bus error fault. However,
    if you create your own stack, you won’t have this issue.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预索引和后索引寻址模式，再配合 ARM 的 64 位寄存器，可以创建不使用 SP 寄存器的软件控制栈。由于 ARM CPU 提供了硬件栈指针寄存器，可能并不明显为什么你要考虑使用另一个栈。正如你所学到的，ARM
    硬件栈的一个限制是它必须始终保持 16 字节对齐。返回地址和你可能希望保留在栈上的其他值通常为 8 字节或更小。例如，不能单独将 LR 寄存器压入栈中，否则会引发总线错误。然而，如果你创建自己的栈，就不会遇到这个问题。
- en: Perhaps you’re wondering why anyone would ever want to use a second stack in
    their programs. If the normal hardware stack works fine, why add the complexity
    of a second stack? Having two stacks is useful in several situations. Particularly,
    coroutines, generators, and iterators can make use of an extra stack pointer.
    See section 5.12, “For More Information,” on [page 290](chapter5.xhtml#pg_290)
    for a Wikipedia link on this subject. Of course, as just pointed out, not having
    to 16-byte align the stack pointer is another good reason for using a program-defined
    stack.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你在想，为什么会有人在程序中使用第二个栈。如果正常的硬件栈能正常工作，为什么要增加第二个栈的复杂性？在几种情况下，拥有两个栈是有用的。特别是协程、生成器和迭代器可以利用额外的栈指针。请参阅第
    5.12 节“更多信息”（[第 290 页](chapter5.xhtml#pg_290)）中的 Wikipedia 链接了解更多相关信息。当然，正如前面所指出的，不必将栈指针对齐到
    16 字节是使用程序定义栈的另一个好理由。
- en: 'Creating your own stack has two drawbacks: you must dedicate one of the ARM’s
    registers for this purpose, and you must explicitly allocate storage for that
    stack yourself (the OS automatically allocates the hardware stack when it runs
    your program).'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自己的栈有两个缺点：你必须为此目的专门分配一个 ARM 的寄存器，并且必须显式地为该栈分配存储空间（操作系统在运行程序时会自动分配硬件栈）。
- en: 'You can easily allocate storage in the .data segment. A typical stack will
    have at least 128 to 256 bytes of storage. The following is a simple example that
    allocates a 256-byte stack:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地在 .data 段中分配存储空间。一个典型的栈至少会有 128 到 256 字节的存储空间。以下是一个分配 256 字节栈的简单示例：
- en: '[PRE74]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: You may need more than 256 bytes of storage if you use automatic variables in
    your procedures; see section 5.4.1, “Activation Records,” on [page 244](chapter5.xhtml#pg_244)
    and section 5.5, “Local Variables,” on [page 250](chapter5.xhtml#pg_250).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在你的程序中使用自动变量，可能需要超过 256 字节的存储空间；请参见第 5.4.1 节“激活记录”（[第 244 页](chapter5.xhtml#pg_244)）和第
    5.5 节“局部变量”（[第 250 页](chapter5.xhtml#pg_250)）。
- en: Normally, stacks start at the end of their allocated space in memory and grow
    downward toward smaller memory addresses. Having the endSmallStk label at the
    end of the stack in this example gives you a handle with which to initialize your
    stack pointer.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，栈从分配的内存空间的末端开始，并向较小的内存地址方向增长。在这个例子中，将endSmallStk标签放在栈的末端，给你一个句柄来初始化栈指针。
- en: 'Because the ARM uses SP for its hardware stack pointer, you must use a different
    register for your program-defined stack pointer. This needs to be a nonvolatile
    register—you don’t want a function call like printf() to mess with your stack.
    As X30 is already used for LR and X29 is reserved for FP (see [Chapter 1](chapter1.xhtml)),
    X28 is a good choice for a user-defined stack pointer (USP). You can initialize
    it to point at the end of smallStk as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ARM使用SP作为硬件栈指针，因此你必须为程序定义的栈指针使用不同的寄存器。这个寄存器需要是一个非易失性寄存器——你不希望像printf()这样的函数调用干扰你的栈。由于X30已被用于LR，X29保留用于FP（参见[第1章](chapter1.xhtml)），所以X28是一个很好的用户定义栈指针（USP）选择。你可以将它初始化为指向smallStk末尾，如下所示：
- en: '[PRE75]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This leaves USP pointing just beyond the end of the stack, which is exactly
    what you want; the stack pointer should point at the current top of the stack,
    and when the stack is empty, as it is after initialization, the stack pointer
    isn’t pointing at a valid stack address.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，USP寄存器将指向栈的末端，这正是你希望的；栈指针应指向当前栈顶，当栈为空时，正如初始化后那样，栈指针不会指向有效的栈地址。
- en: 'To push and pop data on the stack, use the same str and ldr instructions, along
    with the pre-indexed and post-indexed addressing modes, just as you would with
    the hardware stack. The only differences are that you specify the USP register
    (X28) and you don’t have to keep the stack aligned to 16 bytes (in fact, you technically
    don’t have to keep it aligned to anything, but it will be faster if you keep it
    word or dword aligned). Here’s how you can push the LR register into the user
    stack and pop it off:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 要在栈上推送和弹出数据，可以使用相同的str和ldr指令，以及预索引和后索引寻址模式，就像操作硬件栈一样。唯一的区别是你需要指定USP寄存器（X28），并且不必保持栈对齐到16字节（实际上，技术上你不需要保持对齐，但如果你保持对齐到字或双字，速度会更快）。下面是如何将LR寄存器推送到用户栈并弹出：
- en: '[PRE76]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Listing 5-14 is a rewrite of Listing 5-4 using a software stack.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 清单5-14是使用软件栈重写清单5-4。
- en: '[PRE77]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Upon entry into print40Spaces, the code pushes LR and X19 onto the software
    stack ❶, using an stp instruction to save both registers at the same time. The
    pre-indexed addressing mode decrements USP by 16; then this instruction stores
    the two 8-bit registers on the software stack. Just before returning, print40Spaces
    restores the LR and X19 registers from the software stack ❷, using an lpd instruction
    and the post-indexed addressing mode.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 进入print40Spaces时，代码将LR和X19寄存器推送到软件栈 ❶，使用stp指令同时保存这两个寄存器。预索引寻址模式将USP减少16；然后该指令将两个8位寄存器存储到软件栈中。返回之前，print40Spaces使用lpd指令和后索引寻址模式从软件栈恢复LR和X19寄存器
    ❷。
- en: Although this program demonstrates using a software-controlled stack, it must
    still use the hardware stack for a couple of purposes. In particular, the printf()
    function will push its return address (and parameters, as it turns out) onto the
    hardware stack. Therefore, the main program sets up storage space on the hardware
    stack for this purpose ❸. The program must also preserve the USP register (X28)
    before initializing it to point at the end of the smallStack data area. The space
    just allocated on the hardware stack is the perfect place for this. As long as
    the code is saving USP there, it may as well save LR at the same time, since you
    must always write 16 bytes to the hardware stack.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个程序演示了如何使用软件控制的栈，但它仍然需要在几个目的上使用硬件栈。特别是，printf()函数会将其返回地址（以及参数）推送到硬件栈中。因此，主程序为此目的在硬件栈上设置了存储空间
    ❸。程序还必须在初始化USP寄存器指向smallStack数据区末尾之前，保存USP寄存器（X28）。刚分配的硬件栈空间正是保存它的理想位置。只要代码在此处保存USP寄存器，它也可以同时保存LR寄存器，因为你必须始终向硬件栈写入16字节。
- en: Once the code has preserved USP’s value (because it is a nonvolatile register),
    the next step is to initialize USP with the address of the end of the smallStack
    memory buffer ❹. Loading the address of endSmallStk into USP accomplishes this.
    Once the stack is initialized, the code can use it; for example, this statement
    pushes nonvolatile register X19 onto the software stack ❺ (to preserve it for
    the C++ program).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码保存了 USP 的值（因为它是一个非易失性寄存器），下一步是用小栈内存缓冲区末尾的地址初始化 USP ❹。将 endSmallStk 的地址加载到
    USP 中即可完成此操作。栈初始化后，代码可以使用它；例如，以下语句将非易失性寄存器 X19 推送到软件栈中 ❺（以便为 C++ 程序保存它）。
- en: Before leaving, the code pops the X19 nonvolatile register off the software
    stack to restore its value ❻. Finally, the main program restores USP and LR from
    the hardware stack (and cleans up allocated storage) before returning to the C++
    code ❼.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 离开之前，代码从软件栈中弹出 X19 非易失性寄存器，以恢复其值 ❻。最后，主程序从硬件栈中恢复 USP 和 LR（并清理已分配的存储），然后再返回 C++
    代码 ❼。
- en: 'Just to prove it really works, here’s the build command and sample output for
    the program in Listing 5-14:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明它确实有效，以下是 Listing 5-14 中程序的构建命令和示例输出：
- en: '[PRE78]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: As you can see, Listing 5-14 produces the same output as Listing 5-4.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Listing 5-14 产生的输出与 Listing 5-4 相同。
- en: 5.11 Moving On
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.11 继续前进
- en: This chapter covered considerable material, including an introduction to assembly
    language programming style, basic Gas procedure syntax, local labels, calling
    and returning from procedures, register preservation, activation records, function
    results, and more. Armed with this information, you’re ready to learn how to write
    functions that calculate arithmetic results in the next chapter.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量内容，包括汇编语言编程风格的介绍、基本的 Gas 过程语法、本地标签、过程的调用与返回、寄存器保护、激活记录、函数结果等。有了这些信息，您已准备好在下一章学习如何编写用于计算算术结果的函数。
- en: 5.12 For More Information
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.12 更多信息
- en: For more details on the Creative Commons 4.0 Attribution license, see *[https://<wbr>creativecommons<wbr>.org<wbr>/licenses<wbr>/by<wbr>/4<wbr>.0<wbr>/](https://creativecommons.org/licenses/by/4.0/)*.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欲了解更多关于 Creative Commons 4.0 Attribution 许可证的详情，请访问 *[https://<wbr>creativecommons<wbr>.org<wbr>/licenses<wbr>/by<wbr>/4<wbr>.0<wbr>/](https://creativecommons.org/licenses/by/4.0/)*。
- en: The ARM developer site has more on the AARCH64 (ARM64) calling convention and
    ABI at *[https://<wbr>github<wbr>.com<wbr>/ARM<wbr>-software<wbr>/abi<wbr>-aa<wbr>/releases](https://github.com/ARM-software/abi-aa/releases)*.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARM 开发者网站提供了关于 AARCH64（ARM64）调用约定和 ABI 的更多信息，详见 *[https://<wbr>github<wbr>.com<wbr>/ARM<wbr>-software<wbr>/abi<wbr>-aa<wbr>/releases](https://github.com/ARM-software/abi-aa/releases)*。
- en: Wikipedia provides a useful entry on coroutines, generators, and iterators at
    *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Coroutine](https://en.wikipedia.org/wiki/Coroutine)*.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikipedia 提供了关于协程、生成器和迭代器的有用条目，您可以参考 *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Coroutine](https://en.wikipedia.org/wiki/Coroutine)*。
