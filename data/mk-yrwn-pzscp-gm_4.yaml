- en: '![Image](../images/pg063-01.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg063-01.jpg)'
- en: '4'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: 'Robot Heist: Creating Rules and Obstacles'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人抢劫：创建规则和障碍
- en: In this chapter, you’ll build the *Robot Heist* game from the ground up. You’ll
    make two robot objects that the player will use to navigate each level. You’ll
    also create the backdrop and other objects, such as crates, guns, and panels.
    You’ll use PuzzleScript rules to make these objects interact with one another
    in interesting ways.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将从头开始构建*机器人抢劫*游戏。你将制作两个机器人对象，玩家可以用它们来通过每个关卡。你还会创建背景和其他物体，如箱子、枪支和面板。你将使用PuzzleScript规则使这些物体以有趣的方式相互作用。
- en: Recall from [Chapter 2](ch02.xhtml) that the `RULES` section in your code is
    where you write instructions to change one set of objects into another.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第2章](ch02.xhtml)，在你的代码中的`RULES`部分，你可以编写指令，将一种物体转换成另一种物体。
- en: How Robot Heist Works
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 机器人抢劫游戏的工作原理
- en: In *Robot Heist*, two robots work together to rob a Data Bank. Each robot has
    different capabilities, so the player needs to switch between them to solve puzzles.
    There are security robots and lasers to avoid, and a treasure to steal. You’ll
    find the game at *[http://tinyurl.com/robotheist/](http://tinyurl.com/robotheist/)*.
    This is what the game looks like.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在*机器人抢劫*中，两个机器人合作盗取数据银行。每个机器人都有不同的能力，因此玩家需要在它们之间切换来解决难题。游戏中有需要避免的安全机器人和激光，还有需要偷走的宝藏。你可以在*[http://tinyurl.com/robotheist/](http://tinyurl.com/robotheist/)*找到这个游戏。游戏是这样的。
- en: '![Image](../images/pg064-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg064-01.jpg)'
- en: '*Example level in* Robot Heist'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*机器人抢劫示例关卡*'
- en: The game begins with only one robot named Vertibot because we want the player
    to learn the basics before introducing a second robot. Vertibot can push objects
    vertically (up and down). Later in the game, the player meets another robot named
    Horibot that can push objects horizontally (left and right). To take advantage
    of their different pushing capabilities, the player must make Vertibot and Horibot
    work together to solve the game’s puzzles.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开始时只有一个名为Vertibot的机器人，因为我们希望玩家在引入第二个机器人之前先学会基础操作。Vertibot可以垂直推动物体（上下）。在游戏的后期，玩家将遇到另一个名为Horibot的机器人，它可以水平推动物体（左右）。为了充分利用它们不同的推动能力，玩家必须让Vertibot和Horibot合作来解决游戏中的难题。
- en: Brainstorming Objects and Interactions
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 头脑风暴物体和互动
- en: 'Before I started working on my *Robot Heist* game, I thought carefully about
    what objects I wanted in the game. I didn’t just want objects that were cool:
    I wanted objects that worked together in intriguing ways. Choosing your game’s
    objects is like casting a play, and a play in which none of the characters talk
    to each other would be very boring.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我开始制作*机器人抢劫*游戏之前，我仔细考虑了我想在游戏中加入哪些物体。我不只是想要酷炫的物体：我想要那些能够以引人入胜的方式相互作用的物体。选择游戏的物体就像选角，剧中如果没有角色互相对话，那将非常无聊。
- en: '![Image](../images/pg065-01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg065-01.jpg)'
- en: 'The objects I came up with were the robots (the player characters), crates
    to push, gates to open and close, security lasers, and patrolling guard robots.
    Each of these objects interacts with the others in the following ways:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我构思的物体包括机器人（玩家角色）、可以推动的箱子、可以开关的门、安全激光和巡逻警卫机器人。这些物体之间的互动如下：
- en: '**Robots (the player)** Robots can push crates and open gates. They need to
    avoid lasers and guards.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**机器人（玩家角色）** 机器人可以推动箱子并开关门。他们需要避免激光和警卫。'
- en: '**Crates** Robots can push crates to block lasers or hold gates open. Crates
    can also block guards, so robots can put them in a guard’s path to confuse them.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**箱子** 机器人可以推动箱子来阻挡激光或保持门打开。箱子也可以阻挡警卫，因此机器人可以把箱子放在警卫的路径上来迷惑警卫。'
- en: '**Gates** Robots and guards can open and close gates. Crates can be used to
    keep gates open. Gates block lasers when they’re closed but let lasers through
    when they’re open.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**门** 机器人和警卫可以开关门。箱子可以用来保持门打开。门关闭时会阻挡激光，打开时则让激光通过。'
- en: '**Lasers** A laser will catch the robots if one of them tries to cross it,
    but robots can block a laser with a crate or a gate. Guards can block lasers as
    well, so the robots can sometimes sneak past while a guard is blocking the laser.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**激光** 激光会抓住试图穿越的机器人，但机器人可以用箱子或门来阻挡激光。警卫也能阻挡激光，因此机器人有时可以趁警卫阻挡激光时悄悄通过。'
- en: '**Guards** Guards can open and close gates or block lasers. Guards can catch
    robots, so robots should avoid them. Robots can use crates to block the guards’
    paths.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**警卫** 警卫可以开关门或阻挡激光。警卫可以抓住机器人，因此机器人应该避开它们。机器人可以用箱子来阻挡警卫的路径。'
- en: This is my cast of characters! Because I can make them all interact with each
    other, I should be able to make a lot of fun levels.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的角色阵容！因为我可以让它们相互互动，所以我应该能够制作许多有趣的关卡。
- en: Getting Started
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入门
- en: PuzzleScript remembers the last 20 versions you’ve saved, but it’ll forget any
    versions after that. You can click the **Load** menu at the top of the window
    to see your saved versions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: PuzzleScript会记住你保存的最后20个版本，但之后的版本它会忘记。你可以点击窗口顶部的**加载**菜单查看已保存的版本。
- en: Before you start a new project, be sure to make a copy of the previous one!
    The easiest way to do this is to click **Share** as if you were sharing your game
    and keep a copy of the link. When you click the link, you should see the **hack**
    button that lets you access your game’s code again.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始一个新项目之前，一定要先复制前一个项目！最简单的方法是点击**共享**，就像你要分享游戏一样，并保存链接。当你点击该链接时，你应该能看到**hack**按钮，它可以让你再次访问游戏的代码。
- en: '**NOTE:** You could also copy all the code and email it to yourself. Click
    the **Export** button to create an HTML copy of your game. To find the game code
    in your HTML file, open it using a plain text editor. The text between “sourceCode=”
    and “;compile” is your game code! Copy and paste the unformatted code into a free
    formatting tool like *[https://www.freeformatter.com/javascript-escape.html](https://www.freeformatter.com/javascript-escape.html)*
    and then click **UNESCAPE**. You should now see the complete code of your game.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**你也可以将所有代码复制并通过电子邮件发送给自己。点击**导出**按钮来创建一个游戏的HTML副本。要在HTML文件中找到游戏代码，可以用纯文本编辑器打开它。位于“sourceCode=”和“;compile”之间的文本就是你的游戏代码！将未格式化的代码复制并粘贴到一个免费的格式化工具中，比如*[https://www.freeformatter.com/javascript-escape.html](https://www.freeformatter.com/javascript-escape.html)*，然后点击**UNESCAPE**。你现在应该能看到完整的游戏代码。'
- en: After you’ve backed up your old project, you can start the new one. Click **Load
    Example**▸**Blank Project** to start a new game from scratch.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在你备份了旧项目之后，就可以开始新项目了。点击**加载示例**▸**空白项目**从头开始创建一个新游戏。
- en: '![Image](../images/pg067-01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg067-01.jpg)'
- en: '*Creating a new project*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*创建一个新项目*'
- en: 'Give your new game a title and an author. You can add these at the beginning
    of your code, like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 给你的新游戏添加一个标题和作者。你可以像这样在代码的开头添加它们：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Keep in mind that the title and author should go before your code’s `OBJECTS`
    section. Now that you’ve labeled your new game, you’re ready to start adding objects
    to the game.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，标题和作者应放在代码的`OBJECTS`部分之前。现在你已经为你的新游戏命名，准备好开始向游戏中添加对象了。
- en: Creating Objects
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建对象
- en: Objects are a very important part of your code because they outline all the
    items that make up your game. Whenever you add a new element to your game, you’ll
    follow these steps to create an object for it in your code’s `OBJECTS` section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是你代码中非常重要的一部分，因为它们概述了组成游戏的所有项目。每当你向游戏中添加新元素时，都会按照这些步骤在代码的`OBJECTS`部分为其创建一个对象。
- en: Add an object to the `OBJECTS` section, giving it a name and appearance.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`OBJECTS`部分添加一个对象，给它命名并指定外观。
- en: Add the object to the `LEGEND` section so it appears in the level editor.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对象添加到`LEGEND`部分，以便它能出现在关卡编辑器中。
- en: Add the object to the `COLLISIONLAYERS` section. PuzzleScript won’t run if there
    are objects that don’t have a collision layer, because it won’t know what to do
    if they touch another object.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对象添加到`COLLISIONLAYERS`部分。如果有对象没有碰撞层，PuzzleScript就无法运行，因为它不知道如果这些对象接触到另一个对象该怎么办。
- en: Write the rules that tell PuzzleScript what the object should do.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写规则，告诉PuzzleScript对象应该做什么。
- en: 'To start, let’s add the most basic objects we need: a background and some sort
    of solid wall.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加一些最基本的对象：背景和某种固体墙壁。
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Your background and wall can look like these, or you can use your own colors.
    Keep in mind that if you give an object just a color but no numbered pixels, the
    object will just look like a solid square of that color. For example, in the example
    level shown at the beginning of this chapter, I made the background `Green` without
    including numbered pixels, which means it will be a solid green. But I list two
    colors for the wall: `LightGreen` and `DarkGreen`. Then I use a grid of numbers
    below that to specify that the outer pixels will be in dark green to make a border
    around the light green interior.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你的背景和墙壁可以像这些一样，或者你可以使用自己的颜色。请记住，如果你只给一个对象指定了颜色，而没有指定数字像素，那么这个对象就会呈现为一个单色方块。例如，在本章开头显示的示例关卡中，我将背景设置为`绿色`，而没有包含数字像素，这意味着它将是一个纯绿色。但我为墙壁列出了两种颜色：`浅绿色`和`深绿色`。然后我在下面使用数字网格来指定外层像素为深绿色，以便在浅绿色的内部周围形成一个边框。
- en: Before we can use these objects, we need to add them to the `LEGEND` section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能使用这些对象之前，需要将它们添加到`LEGEND`部分。
- en: Creating the Legend
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建图鉴
- en: 'Adding an object to the legend makes it appear in the level editor so we can
    draw with it. Let’s add the background and wall to the `LEGEND` section and assign
    a symbol to each, as shown here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 向图鉴中添加一个对象会使它在关卡编辑器中出现，以便我们能够用它绘制。让我们将背景和墙壁添加到`LEGEND`部分，并为每个对象分配一个符号，如下所示：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Not all objects need to be in the legend. For example, some objects never appear
    at the very start of a level, so we don’t need them in the level editor. We’ll
    make some objects like that soon.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有对象都需要出现在图鉴中。例如，有些对象在关卡开始时永远不会出现，因此我们不需要在关卡编辑器中显示它们。我们很快会制作一些这样的对象。
- en: 'Now add your new objects to the `COLLISIONLAYERS` section:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将你的新对象添加到`COLLISIONLAYERS`部分：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Keep in mind that objects collide with each other only if they’re on the same
    collision layer. Because the background and wall objects are on different layers
    (each on its own line of code), they can share the same space without colliding.
    This allows the wall to sit on top of a background tile, which acts as the floor.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，只有当对象位于同一碰撞层时，它们才会相互碰撞。由于背景和墙壁对象位于不同的层（每个对象在自己的代码行上），它们可以共享相同的空间而不发生碰撞。这使得墙壁可以位于背景瓦片的上方，背景瓦片充当地面。
- en: We don’t need to add any rules for these objects, because we don’t need them
    to do anything but display on the screen. Any other solid object we add from this
    point forward will need to be on the same collision layer as the wall because
    the walls should be able to block other objects from moving through them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要为这些对象添加任何规则，因为我们只需要它们显示在屏幕上。我们从这一点开始添加的任何其他固体对象都需要与墙壁处于相同的碰撞层，因为墙壁应该能够阻止其他对象穿过它们。
- en: Now that we have our basic building blocks, we can run our game, right? Not
    so fast! PuzzleScript won’t let you run a game unless it has a player object.
    Let’s figure out how our two player robots are going to work!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们有了基本的构建模块，是否就可以运行游戏了？不，别着急！PuzzleScript不会让你运行游戏，除非它有一个玩家对象。我们来看看我们的两个玩家机器人是如何工作的！
- en: Player Swapping
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 玩家切换
- en: Think about what we need the player objects to do. We want two robots that are
    onscreen at the same time, but the player can control only one at a time. The
    player can switch between the two robots at any time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想我们希望玩家对象做什么。我们想要两个机器人同时出现在屏幕上，但玩家一次只能控制其中一个。玩家可以随时在两个机器人之间切换。
- en: '![image](../images/pg070-01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg070-01.jpg)'
- en: One way to think about this scenario is that only one robot is *awake* at any
    given time while the other one is *asleep.* (Just like the cats in *Herding Cats*!)
    When the player presses the *action key*, the sleeping robot wakes up and the
    awake robot goes to sleep.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一种思考这种场景的方式是，始终只有一个机器人处于*醒着*状态，而另一个则处于*睡眠*状态。（就像《*Herding Cats*》中的猫一样！）当玩家按下*行动键*时，睡着的机器人醒来，醒着的机器人则进入睡眠状态。
- en: 'We can program the action key (either X or the spacebar) to do whatever we
    want, and the player can press it during the game. In our game, we’ll use the
    action key to allow the player to switch between robots. This means we need four
    objects in total to pull off this wacky scheme. Because we have two different
    robots, each needs two possible states: awake or asleep.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编程设定行动键（X键或空格键）执行我们希望的任何操作，玩家可以在游戏中按下它。在我们的游戏中，我们将使用行动键允许玩家在机器人之间切换。这意味着我们总共需要四个对象来完成这个疯狂的方案。因为我们有两个不同的机器人，每个机器人需要两种可能的状态：醒着或睡着。
- en: Our robots will also need something to push around, so let’s make a crate object
    while we’re creating the four robot objects. Add the four robot objects and the
    crate object to your game, using the following code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的机器人还需要一些物品来推动，因此在创建四个机器人对象时，我们来制作一个箱子对象。使用以下代码将四个机器人对象和箱子对象添加到游戏中。
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, I drew the Vertibot to look tall and thin and the Horibot to
    look short and stout to make it easy to tell them apart. I made the sleeping version
    of each robot look different from the awake version by making the sleeping robots
    gray. The player should be able to tell just by looking at the colors which robot
    is awake and which is asleep. The crate is a square object that has a yellow border
    around its brown interior.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我画的Vertibot（垂直机器人）看起来又高又瘦，而Horibot（水平机器人）则显得矮胖，这样可以很容易地区分它们。我让每个机器人的睡眠状态与醒着的状态不同，通过将睡眠中的机器人涂成灰色。玩家应该能仅通过颜色区分出哪个机器人醒着，哪个机器人睡着了。箱子是一个方形物体，周围有黄色边框，内部是棕色的。
- en: Updating the Legend
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新图鉴
- en: 'Now we need to put our new objects in the legend so we can use them in our
    levels. I picked the letter *I* for Vertibots because it’s tall and vertical and
    an *H* for Horibot. Let’s update the `LEGEND` section, as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将新对象放入图例中，以便在关卡中使用它们。我选择了字母 *I* 代表 Vertibots，因为它高且垂直，而 *H* 代表 Horibot。让我们更新
    `LEGEND` 部分，如下所示：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Any objects we add to the legend should now appear in the level editor. You
    might notice that we only added two robot objects to the legend: the awake Vertibot
    and the asleep Horibot. The reason is that what we’re drawing in the level editor
    is the starting position for each level. In other words, we’re designing the way
    the level looks at the very beginning of play. Whenever a level begins, one robot
    should be awake and the other asleep. For consistency, I decided that at the start
    of each level, Vertibot will always be the robot that’s awake and Horibot will
    always be asleep.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在添加到图例中的任何对象应该都会出现在关卡编辑器中。你可能会注意到我们只在图例中添加了两个机器人对象：醒着的 Vertibot 和睡着的 Horibot。原因是我们在关卡编辑器中绘制的是每个关卡的起始位置。换句话说，我们正在设计游戏开始时关卡的外观。每当一个关卡开始时，一个机器人应该是醒着的，另一个是睡着的。为了保持一致性，我决定在每个关卡开始时，Vertibot
    总是醒着的，而 Horibot 总是睡着的。
- en: 'PuzzleScript won’t let us run our game until we have a player object. Without
    it, PuzzleScript won’t know which of the two objects to move when the player presses
    the keys. Fortunately, the legend lets us define groups. You can use a group to
    contain multiple objects, which you can then refer to by the same name. For example,
    we can create a group called `Player` and add both robots to it by adding the
    following code to the `LEGEND` section:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: PuzzleScript 不会让我们运行游戏，直到我们有了玩家对象。没有它，PuzzleScript 不知道在玩家按下按键时应该移动哪一个对象。幸运的是，图例允许我们定义组。你可以使用一个组来包含多个对象，然后用相同的名称引用它们。例如，我们可以创建一个名为
    `Player` 的组，并通过将以下代码添加到 `LEGEND` 部分将两个机器人都添加进去：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By writing `Vertibot or Horibot`, we specify that only one of the awake versions
    of the robots counts as a player. Because `VertibotSleeping` and `HoribotSleeping`
    don’t count as players, they won’t move when the player runs the game.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写 `Vertibot or Horibot`，我们指定只有一个醒着的机器人版本算作玩家。因为 `VertibotSleeping` 和 `HoribotSleeping`
    不算作玩家，所以它们在玩家运行游戏时不会移动。
- en: PuzzleScript lets you have as many players onscreen as you like at the same
    time. But in our game, the two robots won’t ever be awake at the same time. Whichever
    one is awake will act as the player and move when the player presses the arrow
    keys.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: PuzzleScript 允许你在屏幕上同时拥有任意数量的玩家。但在我们的游戏中，两个机器人永远不会同时醒着。无论哪个机器人醒着，它都会充当玩家，并在玩家按下箭头键时移动。
- en: Updating the Collision Layers
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新碰撞层
- en: 'Because PuzzleScript won’t run if an object doesn’t have a collision layer,
    we need to put all our newly added objects into the `COLLISIONLAYERS` section.
    We want the robots to bump into walls and to be able to push crates around, so
    we should make sure the robots, crates, and walls are all on the same collision
    layer, as shown here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因为如果一个对象没有碰撞层，PuzzleScript 将无法运行，我们需要将所有新添加的对象放入 `COLLISIONLAYERS` 部分。我们希望机器人能撞到墙壁并能够推动箱子，因此我们应该确保机器人、箱子和墙壁都在同一个碰撞层上，如下所示：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Right now, the only object that should be on a separate collision layer is the
    background, which is on its own line of code. Save your game, and click **Rebuild**
    to make sure everything in your game works. If it does, a `Successful Compilation`
    message should appear under the game window.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，唯一应该放在单独碰撞层上的对象是背景，它位于自己的代码行中。保存你的游戏，然后点击**重建**以确保游戏中的所有内容正常运行。如果一切正常，游戏窗口下方应该会出现
    `编译成功` 的消息。
- en: '![image](../images/pg073-01.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg073-01.jpg)'
- en: '*Successful Compilation message*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*编译成功信息*'
- en: If something is wrong with the code, such as if any of the objects are not in
    the `COLLISIONLAYERS` section or if you forgot to add a player to the `LEGEND`
    section, you might see a bright red error message pop up that looks like this.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码出现问题，比如某些对象没有在 `COLLISIONLAYERS` 部分，或者你忘了将玩家添加到 `LEGEND` 部分，你可能会看到一个明亮的红色错误信息，类似于下面的样子。
- en: '![image](../images/pg074-01.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg074-01.jpg)'
- en: '*Compilation Error message*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*编译错误信息*'
- en: We’re done updating the `COLLISIONLAYERS` section, so let’s create an action
    key that allows the player to switch between robots.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了 `COLLISIONLAYERS` 部分的更新，现在让我们创建一个操作键，允许玩家在机器人之间切换。
- en: Writing Rules to Switch Characters
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写切换角色的规则
- en: As mentioned earlier, we can program an action key to do whatever we want it
    to. Pressing either the X key or spacebar triggers action in PuzzleScript. The
    player can use whichever one they’re more comfortable with. While the player uses
    the arrow keys to move around, they can use the action key to jump, pull a switch,
    put on a hat, or do whatever the rules say happens when the player presses the
    action key.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以编程让行动键执行任何我们希望的操作。按下X键或空格键都可以触发PuzzleScript中的动作。玩家可以选择他们更舒适的按键。玩家用方向键移动时，也可以使用行动键进行跳跃、拉开开关、戴上帽子，或执行任何当玩家按下行动键时规则定义的操作。
- en: 'In our game, the action key will switch between characters by waking up one
    robot and putting the other to sleep. Keep in mind that the action key won’t do
    anything until we write rules telling PuzzleScript what it should do. So let’s
    add the following rules in the `RULES` section:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，行动键会通过唤醒一个机器人并让另一个进入睡眠来切换角色。请记住，直到我们编写规则告诉PuzzleScript该做什么之前，行动键不会有任何作用。所以让我们在`RULES`部分添加以下规则：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: PuzzleScript ignores anything in parentheses, so `(switching characters)` is
    just a note to me to help me remember what this part of the code does when I look
    at it later.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: PuzzleScript会忽略括号内的内容，因此`(switching characters)`只是一个提醒我用的注释，帮助我在稍后查看代码时记得这部分代码的功能。
- en: The two lines of code below the note check to see when the player presses the
    action key and then switches each robot to its sleeping and awake state. In PuzzleScript,
    the action key is based on a condition, just like movement. For example, if `>
    Horibot` represents a moving Horibot, `action Horibot` represents a Horibot that’s
    doing the action.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下方的两行代码会检查玩家按下行动键的时机，然后切换每个机器人的睡眠与清醒状态。在PuzzleScript中，行动键是基于条件的，类似于移动。例如，`>
    Horibot`代表一个正在移动的Horibot，而`action Horibot`代表一个正在执行动作的Horibot。
- en: If the awake Horibot has the action condition, it becomes `HoribotSleeping`,
    and `VertibotSleeping` becomes `Vertibot`, the awake version. And if `Vertibot`
    is the one doing the action, then it goes to sleep and the sleeping Horibot wakes
    up.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果清醒的Horibot满足行动条件，它会变成`HoribotSleeping`，而`VertibotSleeping`则变成清醒状态的`Vertibot`。如果是`Vertibot`在执行动作，它就会进入睡眠状态，而清醒的Horibot则会醒来。
- en: Note that because the characters are enclosed in separate square brackets, they
    don’t need to be next to each other for the switching rule to work. In PuzzleScript
    rules, we use sets of brackets to group objects together. A series of objects
    in the same set of brackets, divided by a vertical bar, indicates objects that
    are next to each other on the level’s grid (for example, `[ Vertibot | HoribotSleeping
    ]`). If we put the two objects together *without* the vertical bar, it means the
    two objects are sharing the same space (for example, `[ Vertibot Background ]`).
    We’ll talk more about this format shortly!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于角色被分别放在不同的方括号中，它们不需要在彼此旁边才能使切换规则生效。在PuzzleScript规则中，我们使用一组方括号将物体组合在一起。一个方括号内有一系列用竖线分隔的物体，表示这些物体在关卡网格中是相邻的（例如，`[
    Vertibot | HoribotSleeping ]`）。如果我们将两个物体放在一起*没有*使用竖线，意味着这两个物体共享同一个空间（例如，`[ Vertibot
    Background ]`）。我们稍后会详细讲解这种格式！
- en: If we put one object in its own set of brackets and one in another set of brackets,
    that just means two objects are in two different grid spaces (for example, `[
    Vertibot ] [ HoribotSleeping ]`). They could be next to each other, or they could
    be across the level from each other. All PuzzleScript checks for is that they’re
    on the same level at the same time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个物体放在它自己的方括号组里，另一个物体放在另一个方括号组里，这意味着这两个物体位于不同的网格空间中（例如，`[ Vertibot ] [
    HoribotSleeping ]`）。它们可以相邻，也可以在关卡的不同位置。PuzzleScript只检查它们是否在同一层级、同一时刻。
- en: But because both characters are listed in each rule, they both need to be in
    the same level for the switch to work. This automatically means that if only one
    character is in the level, the program will ignore these rules. That’s perfect
    if we want to design levels with only one of the characters, like we do in this
    case!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个规则中都列出了这两个角色，它们必须处于相同的层级才能使切换规则生效。这意味着，如果只有一个角色在该层级，程序将忽略这些规则。如果我们想设计只有一个角色的关卡，这样的设计就很完美，正如我们在这个案例中所做的！
- en: Note that even if the objects are in different places, there need to be as many
    objects on the left side of the rule as on the right side. If you entered `[ Vertibot
    ] [ HoribotSleeping ] -> [ VertibotSleeping ]`, PuzzleScript would give you an
    error message. It wouldn’t know what to do with `HoribotSleeping`!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使物体位于不同的位置，规则的左侧和右侧也需要有相同数量的物体。如果你输入了`[ Vertibot ] [ HoribotSleeping ]
    -> [ VertibotSleeping ]`，PuzzleScript会给出错误信息。它不知道如何处理`HoribotSleeping`！
- en: Let’s take a moment to make sure the rules we wrote are working.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间确保我们写的规则有效。
- en: Building a Test Level
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建测试关卡
- en: 'To test our rules, we’ll create a quick test level to make sure everything
    in the game works so far. Enter this text in the `LEVELS` section:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的规则，我们将创建一个快速测试关卡，以确保目前为止游戏中的所有内容都能正常工作。在`LEVELS`部分输入以下文本：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This level includes all the objects we’ve added so far. Recall from the legend
    that the `I` and `H` are the robots, the `*` is a crate, the `#` is the wall,
    and the `.` is the background. Click **Save** and then click **Run**. Now when
    you start the game, you should see something like this.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关卡包括了我们到目前为止添加的所有物体。从图例中回忆一下，`I`和`H`是机器人，`*`是箱子，`#`是墙壁，`.`是背景。点击**保存**，然后点击**运行**。现在，当你开始游戏时，应该能看到类似这样的画面。
- en: '![image](../images/pg076-01.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg076-01.jpg)'
- en: '*Test level*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*测试关卡*'
- en: This level doesn’t look as pretty as it will in the finished game, but for now
    we just want to make sure the basics work. Try pressing the arrow keys to move
    the characters around and X or the spacebar to switch between them. Move one character
    around, switch to the other, move *that* character around, and then switch back.
    The robots shouldn’t be able to move through the walls or the crate because they’re
    on the same collision layer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关卡看起来不如最终游戏中的美观，但目前我们只是想确保基本功能正常。尝试按方向键来移动角色，使用X键或空格键在它们之间切换。移动一个角色，切换到另一个，移动*那个*角色，然后切换回来。机器人应该不能穿过墙壁或箱子，因为它们在同一碰撞层上。
- en: But we don’t want the crate to simply stop the robots. We want the robots to
    be able to *push* the crate around! Let’s add a few rules to make that happen.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不希望箱子仅仅停住机器人。我们希望机器人能够*推动*箱子！让我们添加一些规则来实现这个目标。
- en: Adding Pushing Rules
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加推动规则
- en: 'Here are some rules that let both robots push crates:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些规则，允许两个机器人推动箱子：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This rule is similar to the one we saw in the demo game in [Chapter 1](ch01.xhtml)
    except this one includes `horizontal` and `vertical`. A PuzzleScript rule is applied
    in four different directions. We can specify which direction to apply a rule by
    giving PuzzleScript a specific direction, like `left` or `right` or `down`. In
    this case, `horizontal` means left and right, and `vertical` means up and down.
    This rule tells the program that a moving Horibot can only move a crate left and
    right, and a moving Vertibot can only move a crate up and down.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则与我们在[第1章](ch01.xhtml)的演示游戏中看到的规则类似，只是这次包括了`horizontal`和`vertical`。PuzzleScript规则可以应用于四个不同的方向。我们可以通过给PuzzleScript指定特定的方向，如`left`或`right`或`down`，来指定规则应用的方向。在这个例子中，`horizontal`表示左右，`vertical`表示上下。这个规则告诉程序，移动的Horibot只能左右移动箱子，而移动的Vertibot只能上下移动箱子。
- en: 'Click **Save** and then click **Rebuild**. Try pushing the crate around. Each
    robot should be able to push the crate in two directions: left and right horizontally
    or up and down vertically.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**保存**，然后点击**重建**。尝试推动箱子。每个机器人应该能够推动箱子朝两个方向移动：水平的左和右，或者垂直的上下。
- en: Making Groups of Pushable Objects
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建可推动物体的组
- en: Now our robots can push crates, but what if the awake robot could push around
    the robot that’s asleep? This would create even more chances for teamwork and
    would cut down on traffic jams. For example, if the sleeping robot is in the way
    of the awake robot, instead of having to switch to the sleeping robot to move
    it, the player could just push it out of the way.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的机器人可以推动箱子了，但如果清醒的机器人能够推动正在睡觉的机器人怎么办？这将创造更多的团队合作机会，并减少交通堵塞。例如，如果睡着的机器人挡住了清醒的机器人的路，玩家就不必切换到睡觉的机器人来移动它，而可以直接将其推开。
- en: In the legend, we used a group to tell PuzzleScript that both Vertibot and Horibot
    count as players. Similarly, we can update the legend to say that crates and sleeping
    robots count as pushable objects. Note that the pushable group is a group we’re
    making up. The word “pushable” doesn’t mean anything to PuzzleScript until we
    tell it what it means. After we define a pushable group, we can write rules telling
    the robots to push pushables in general instead of just crates.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在传奇中，我们使用一个组来告诉PuzzleScript，Vertibot和Horibot都算作玩家。同样，我们可以更新传奇，声明箱子和正在睡觉的机器人算作可推动物体。请注意，推送组是我们自己创建的。单词“pushable”对PuzzleScript来说没有任何意义，直到我们告诉它它的含义。在我们定义了推送组之后，我们可以编写规则，指示机器人推动所有可推动物体，而不仅仅是箱子。
- en: Add this line to the `LEGEND` section to tell PuzzleScript that crates and sleeping
    robots all count as pushables.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LEGEND`部分添加这一行代码，告诉PuzzleScript箱子和正在睡觉的机器人都算作可推动物体。
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![image](../images/pg078-01.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg078-01.jpg)'
- en: 'Now when we write a rule using the word `Pushable`, we tell PuzzleScript to
    check for any of those three objects. Let’s go back and change the pushing rules
    we wrote earlier so they check for pushables instead of crates. Replace all instances
    of `Crate` with `Pushable` so the code looks like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们编写规则时，使用“Pushable”这个词，告诉PuzzleScript检查这三种物体中的任何一种。让我们回去修改之前编写的推动规则，使其检查可推动物体，而不是箱子。将所有“Crate”的实例替换为“Pushable”，使代码如下所示：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A robot that is moving toward an object can now push that object if it’s defined
    as `Pushable`, which includes crates and the robot’s sleeping partner. Click **Rebuild**
    and try it out. Of course, Horibot should only be able to push a sleeping Vertibot
    horizontally, and Vertibot should only be able to push a sleeping Horibot vertically.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正在朝某个物体移动的机器人，现在如果该物体被定义为`Pushable`（可推动物体），例如箱子和机器人正在睡觉的伙伴，它就可以推动该物体。点击**Rebuild**并尝试一下。当然，Horibot只能水平推动正在睡觉的Vertibot，而Vertibot只能垂直推动正在睡觉的Horibot。
- en: Allowing Characters to Push Multiple Objects
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 允许角色推动多个物体
- en: What happens when you try pushing the crate into a sleeping robot or a sleeping
    robot into the crate? It stops, and you can’t push it any farther. As they are
    now, the rules only allow a character to push a single pushable at a time. But
    the ability to push in one direction or the other is each robot’s only superpower.
    So they should be able to push as many objects as they want, as long as it’s in
    the right direction.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试将箱子推入一个正在睡觉的机器人，或者将一个正在睡觉的机器人推入箱子时，会发生什么？它会停下，你不能再推动它了。目前的规则只允许一个角色一次推动一个可推动物体。但是，能够推动物体的能力是每个机器人唯一的超级能力。所以只要在正确的方向，它们应该能够推动任意数量的物体。
- en: 'To allow robots to push multiple objects at a time, add this line of code to
    the `RULES` section, under the pushing rules we already have:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许机器人一次推动多个物体，请在`RULES`部分的现有推动规则下添加这一行代码：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that this rule isn’t directional because Vertibot and Horibot already have
    rules telling them which directions they can push. Remember that PuzzleScript
    runs rules in order from top to bottom, and we want this new rule to happen after
    pushing starts. The rule checks whether one pushable is being pushed into another,
    and if it is, the rule tells the second pushable to move in the same direction.
    And because PuzzleScript can run each rule as many times as possible, if the second
    pushable is pushed into a third, that third one will also move in the same direction,
    and so on. Now our robots can push as many objects as they want, as long as there’s
    room.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个规则不是方向性的，因为Vertibot和Horibot已经有规则告诉它们可以推动的方向。记住，PuzzleScript按从上到下的顺序运行规则，我们希望这个新规则发生在推动开始之后。该规则检查一个可推动物体是否被推向另一个物体，如果是，规则会告诉第二个可推动物体朝相同的方向移动。而且因为PuzzleScript可以多次运行每个规则，如果第二个可推动物体被推向第三个物体，那么第三个物体也会朝相同的方向移动，依此类推。现在我们的机器人可以推动任意数量的物体，只要有空间。
- en: Creating Win Conditions
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建胜利条件
- en: How does the player win a *Robot Heist* level and go on to the next one? We
    can specify this by defining our win condition. In our game, a player satisfies
    the win condition, or completes a level, when both characters make it to the exit,
    which is a physical location in the level.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家如何才能在*机器人抢劫*关卡中获胜并进入下一关？我们可以通过定义胜利条件来指定这一点。在我们的游戏中，玩家在两个角色都到达出口时满足胜利条件，出口是关卡中的一个物理位置。
- en: To add this condition to *Robot Heist*, we first need to make a new `Exit` object,
    as shown here.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这个条件添加到*机器人抢劫*中，我们首先需要创建一个新的`Exit`对象，如下所示。
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When the robots are on the exit, the level is finished! I made my exit look
    like a black-and-white checkered flag.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当机器人站在出口上时，关卡就完成了！我把我的出口做成了一个黑白棋盘格的旗帜样式。
- en: '![image](../images/pg080-01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg080-01.jpg)'
- en: 'Add the `Exit` object to your `LEGEND` section, like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Exit` 对象添加到你的 `LEGEND` 部分，像这样：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Of course, I used `X` for `Exit`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我使用了 `X` 来代表 `Exit`。
- en: Adding Exit to a Collision Layer
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将 Exit 添加到碰撞层
- en: 'As with every object we add to a game, we need to assign `Exit` to a collision
    layer. But we’ll put it on a different collision layer than the robots because
    we want them to be able to stand on top of the exit. You can think of the exit
    as a checkered pattern painted on the ground at the end of a racetrack. Update
    the `COLLISIONLAYERS` section like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们向游戏中添加的每个对象一样，我们需要将 `Exit` 分配给一个碰撞层。但我们会将它放在与机器人不同的碰撞层上，因为我们希望机器人能站在出口上。你可以把出口想象成赛车道尽头地面上画的一种黑白棋盘图案。更新
    `COLLISIONLAYERS` 部分，像这样：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The placement of `Exit` gives it its own layer, which means the other objects
    won’t be able to collide with it. In fact, the higher up an object is in the `COLLISIONLAYERS`
    section’s list, the farther back it will be drawn in the game. For example, the
    background layer in the game is all the way in the back. The exit layer is in
    front of the background layer, and the solid objects (robots and crates) layer
    is in front of the exit layer.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exit` 的放置为其提供了一个独立的层，这意味着其他对象无法与它发生碰撞。事实上，`COLLISIONLAYERS` 部分列表中排得越靠前的对象，在游戏中的显示位置就越靠后。例如，游戏中的背景层是最靠后的。出口层位于背景层前面，固体物体（机器人和箱子）层则位于出口层前面。'
- en: 'Now we’re ready to write the win condition. It should state that both robots
    need to be on the `Exit` object to win the level. We could try something like
    this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备编写赢的条件。它应该声明两只机器人都需要站在 `Exit` 对象上才能赢得关卡。我们可以试试类似这样的方法：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: But this condition will work only if Vertibot is awake and Horibot is asleep.
    What if the opposite is true? Or what if only one of the robots is in the level?
    We need code that’s a little more versatile.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个条件只在 Vertibot 清醒而 Horibot 睡着时有效。如果情况正好相反呢？或者如果只有一只机器人在关卡里呢？我们需要写一些更灵活的代码。
- en: Creating the Buddy Group for the Win Condition
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为赢的条件创建 Buddy 组
- en: 'Fortunately, we can use groups for the win condition too. Just like we made
    a pushable group to turn crates and sleeping robots into pushable objects, we
    can make a new group to make robots count as the same thing, whether they’re sleeping
    or awake. Let’s update the legend by adding the following line:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们也可以使用组来设置赢的条件。就像我们创建一个可推组来让箱子和睡着的机器人变成可推物体一样，我们也可以创建一个新的组，使得机器人无论是睡着还是清醒，都算作同一类物体。让我们通过添加以下行来更新
    legend：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that because `Player` already includes `Horibot` and `Vertibot`, we can
    just use `Player` to create a new group called `Buddy` that includes both robots.
    Now, whenever we refer to a `Buddy`, we’re referring to any robot in either state,
    asleep or awake.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，因为 `Player` 已经包含了 `Horibot` 和 `Vertibot`，我们可以直接使用 `Player` 来创建一个新的组，叫做 `Buddy`，包含这两个机器人。现在，每当我们提到
    `Buddy` 时，我们指的就是处于任何状态下的机器人，无论是睡着还是清醒。
- en: 'Let’s update our `WINCONDITIONS` section using `Buddy`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `Buddy` 更新我们的 `WINCONDITIONS` 部分：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code `all Buddy` refers to all `Buddy` objects currently in the level. If
    there’s only one robot in a level, `all Buddy` means just that one robot. If both
    robots are in the level, `all Buddy` means both of them. Because sleeping and
    awake robots count as `Buddy` objects, it doesn’t matter what state they’re in.
    As long as all the `Buddy` objects in the current level are on an `Exit` object,
    the win condition is satisfied.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 代码 `all Buddy` 指的是当前关卡中的所有 `Buddy` 对象。如果关卡中只有一个机器人，那么 `all Buddy` 就只表示那一个机器人。如果关卡中有两个机器人，`all
    Buddy` 就表示这两个机器人。因为处于睡眠状态和清醒状态的机器人都算作 `Buddy` 对象，所以它们的状态并不重要。只要当前关卡中的所有 `Buddy`
    对象都位于 `Exit` 对象上，赢的条件就满足了。
- en: 'One more thing! To make sure that both robots can fit on the exit, each level
    needs to have at least two `Exit` spaces. Add two `Exit` spaces to your level,
    as shown here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事！为了确保两个机器人都能站到出口上，每个关卡需要至少有两个 `Exit` 空间。像这里这样，给关卡添加两个 `Exit` 空间：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can either add two Xs to your `LEVELS` section code, or you could add the
    `Exit` spaces using the level editor (see [Chapter 3](ch03.xhtml) to review how
    to do this). Here’s what the updated level should like:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `LEVELS` 部分的代码中添加两个 X，或者你也可以使用关卡编辑器添加 `Exit` 空间（查看[第3章](ch03.xhtml)以了解如何操作）。更新后的关卡应该像这样：
- en: '![image](../images/pg083-01.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg083-01.jpg)'
- en: '*Creating exits for each robot*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*为每个机器人创建出口*'
- en: Now that we’ve created `Exit` objects and defined our win condition, let’s make
    our game even more fun to play by creating gates that open and close.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经创建了`Exit`对象并定义了我们的胜利条件，现在让我们通过创建开关门来让游戏更有趣。
- en: Making Gates That Open and Close
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 制作开关门
- en: We decided that creating gates that open and close would help foster teamwork
    between the two robots. Because these gates can open only when a robot is holding
    them open, one robot must hold the gate open while the other goes through.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定制作可以开关的门，这样可以促进两个机器人的团队合作。因为这些门只有在机器人保持门打开时才会打开，所以一个机器人必须保持门打开，而另一个机器人则通过门。
- en: Gates are a great idea for our game, but how do they actually work? To keep
    the idea simple, you can think of a gate as a type of wall that can be turned
    on and off. When it’s on, it’s in the same collision layer as the robots and other
    solid objects, acting like a wall. But when it’s off, it’s on another collision
    layer, so the robots can walk over it. In its off state, the gate acts more like
    a floor.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 门是我们游戏中的一个好点子，但它们到底是如何工作的呢？为了保持思路简单，你可以把门想象成一种可以开关的墙。当它开启时，它与机器人和其他固体物体在同一碰撞层上，起到墙壁的作用。但当它关闭时，它在另一个碰撞层上，机器人可以越过它。在关闭状态下，门更像是地板。
- en: We also need some sort of trigger, or switch, for the gate opening and closing.
    Have you ever seen a movie where someone steps on a hidden panel in the floor,
    and then a secret passage opens or a bunch of poison darts fly out of the wall?
    We’ll use this idea to make our trigger a switch panel that robots can step on
    to open gates. This is a good solution because it means that other solid objects,
    like crates and guards, can also activate these switches. When the game finds
    a solid object on top of a panel, the gates will be in floor mode. If there’s
    no object on a switch panel, the gates will be in wall mode.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要某种触发器或开关来控制门的开关。你是否曾经看过电影，其中某人踩到地板上的隐藏面板，然后一个秘密通道打开，或者一堆毒箭从墙中射出？我们将借鉴这个想法，做一个触发开关面板，机器人可以踩上去打开门。这个方案是个不错的选择，因为它意味着其他固体物体，如箱子和警卫，也可以激活这些开关。当游戏发现面板上方有固体物体时，门将处于地板模式。如果没有物体在开关面板上，门将处于墙壁模式。
- en: '![image](../images/pg084-01.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg084-01.jpg)'
- en: Creating the Gate Objects
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建门对象
- en: 'We’ve identified three different objects we need to make our gates work. Similar
    to how we have two versions of each robot (asleep and awake), we need two versions
    of our gate: open and closed. We’ll put the closed version on the same collision
    layer as the robots. The open version will be on a different collision layer.
    The third object we need is the trigger panel that opens the gates.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了三种不同的对象，来让门工作。与每个机器人有两个版本（睡着和醒着）类似，我们也需要两个版本的门：开和关。我们将关闭版本放在与机器人相同的碰撞层上。打开版本将放在不同的碰撞层上。第三个对象是触发面板，用于打开门。
- en: Let’s start by adding these objects to our game and describing what they look
    like.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先从将这些对象添加到游戏中并描述它们的外观开始。
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Creating gates and panel objects*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*创建门和面板对象*'
- en: When objects work together in some way, like the panel and the gate, it’s a
    good idea to make them look similar. This helps the player make the connection
    between the two objects. Here, I made `GateClosed` and `Panel` in the same color
    so they match. I also made `GateOpen` blue but in a darker shade so it’s similar
    to the background. This will let the player know they can pass over it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个对象协同工作时，比如面板和门，最好让它们看起来相似。这样可以帮助玩家理解这两个对象之间的关系。在这里，我将`GateClosed`和`Panel`做成了相同的颜色，以便它们匹配。我还将`GateOpen`做成了蓝色，但使用了较深的色调，以便它与背景相似。这会让玩家知道他们可以通过它。
- en: Adding the Gates to the Legend and the Collision Layers
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将门添加到图例和碰撞层
- en: Now we need to add these objects to the legend so we can use them in the level
    editor. I chose the letter *T* (`T`) for the gate because it looks kind of like
    a fence and a forward slash (`/`) for the panel because it looks like a lever
    you might pull.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将这些对象添加到图例中，这样我们就可以在关卡编辑器中使用它们。我选择了字母* T *（`T`）表示门，因为它看起来有点像栅栏，选择了斜杠（`/`）表示面板，因为它看起来像一个可以拉动的杠杆。
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We don’t need a symbol for an open gate because the gates will start out closed,
    and we’re only defining the start of each level.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要为开门设置符号，因为门会一开始就处于关闭状态，我们只定义了每个关卡的开始。
- en: 'Finally, we need to add our new objects to the `COLLISIONLAYERS` section. Update
    the `COLLISIONLAYERS` section by adding the highlighted objects, like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将新对象添加到`COLLISIONLAYERS`部分。通过像下面这样更新`COLLISIONLAYERS`部分，添加高亮显示的对象：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Because we want the robots to be able to step on or walk through the panel and
    any open gates, they’re in a different layer than the robots. But we want the
    robots to collide with closed gates, so `GateClosed` is in the same layer as the
    robots. Keep in mind that the closer a collision layer is to the top of the list,
    the farther back it is. This is why we need to make sure that the objects the
    robots can step on appear above the robots in code, not below.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们希望机器人能够踩在面板上或穿过任何开着的门，所以它们处于与机器人不同的层次。但我们希望机器人能与关门碰撞，因此`GateClosed`与机器人处于相同的层次。记住，碰撞层越接近列表的顶部，位置越靠后。这就是为什么我们需要确保机器人能够踩上的物体出现在代码中高于机器人，而不是低于它们。
- en: Writing Rules for Gates
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写门的规则
- en: Now we can write the rules that tell our panels and gates what to do. So how
    do our gates work?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写规则来告诉我们的面板和门该怎么做。那么我们的门是如何工作的呢？
- en: Solid object on a panel means gates are open
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面板上有固体物体意味着门是开着的
- en: No solid object on any panels means gates are closed
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面板上没有固体物体意味着门是关着的
- en: 'Which solid objects can activate a panel? The robots, definitely, and crates,
    so robots can use them to keep gates open. It’d be fun to have guards operate
    panels, too. It sounds like we need a new group to contain all the objects that
    can activate a panel. Let’s define a new group called `Depressor` by adding the
    following to the legend (I’ve called the group “Depressor” because these objects
    can *depress* a panel in the floor, not because they’re depressing):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些固体物体可以激活面板？机器人，当然，还有箱子，所以机器人可以利用它们来保持门开着。让守卫操作面板也会很有趣。听起来我们需要一个新的组来包含所有可以激活面板的物体。让我们通过向图例中添加以下内容来定义一个新的组，称为`Depressor`（我称这个组为“Depressor”，是因为这些物体能够*压下*地板上的面板，而不是因为它们让人沮丧）：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Again, I use two groups I’ve already defined to name all the objects I want
    to include in the `Depressor` group. The first is `Player`, which includes the
    awake versions of both robots, and the second is `Pushable`, which includes the
    sleeping versions of both robots, plus crates. This is handy because if I ever
    introduce another pushable object, I only need to update the `Pushable` group.
    Because the `Pushable` group is in the `Depressor` group, it will get updated
    automatically!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我使用了两个已经定义的组来命名我想包含在`Depressor`组中的所有物体。第一个是`Player`，它包括两个机器人处于清醒状态的版本，第二个是`Pushable`，它包括两个机器人处于睡眠状态的版本，以及箱子。这很方便，因为如果我以后再引入一个可推动物体，我只需要更新`Pushable`组即可。由于`Pushable`组在`Depressor`组中，它将会自动更新！
- en: '![image](../images/pg087-01.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg087-01.jpg)'
- en: 'Now let’s translate our ideas into rules PuzzleScript can understand by adding
    the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过添加以下代码，将我们的想法转化为PuzzleScript可以理解的规则：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first rule states that when there’s no depressor on a panel, open gates
    should change to closed gates. The second rule states that when there *is* a depressor
    on a panel, closed gates should change to opened gates.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则规定，当面板上没有压板时，开门应变为关门。第二条规则规定，当面板上*有*压板时，关门应变为开门。
- en: Recall how we check for two objects next to each other. For example, in `[ SleepingCat
    | WakerUpper ]` the vertical bar indicates that the two objects are in two different
    spaces but right next to each other. So if we don’t use a line to separate two
    objects, that would mean that they’re in the same space. So `[Panel Depressor]`
    means that the space contains a panel and a depressor stepping on that panel.
    Similarly, `[Panel no Depressor]` means that there’s a panel in a space with no
    depressor on top of it. Naturally, two objects can share the same space only if
    they’re on different collision layers, which is why we put the panels and the
    depressors on different collision layers in the previous section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们如何检查两个物体是否相邻。例如，在`[ SleepingCat | WakerUpper ]`中，竖线表示这两个物体处于不同的空间，但紧挨着。若我们不使用线来分隔两个物体，这意味着它们处于同一个空间。所以`[Panel
    Depressor]`表示空间中包含一个面板和一个压板正踩在该面板上。类似地，`[Panel no Depressor]`表示该空间内有一个面板，但上面没有压板。自然，两个物体只有在它们处于不同的碰撞层时才能共享同一空间，这就是为什么我们在上一节中将面板和压板放在不同的碰撞层的原因。
- en: When we put two separate, bracketed items next to each other, like `[Panel Depressor]`
    and `[GateClosed]`, it means we’re looking for both states occurring at the same
    time anywhere in the level but not necessarily next to each other. So `[Panel
    Depressor] [GateClosed]` checks for instances where there’s a depressor on a panel
    *anywhere* and a closed gate *anywhere*. If that condition is met, we transform
    the closed gate into an open one.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将两个单独的、括起来的项目放在一起时，比如 `[Panel Depressor]` 和 `[GateClosed]`，这意味着我们在寻找这两种状态同时出现在关卡中的任何地方，但不一定是紧挨着的。所以
    `[Panel Depressor] [GateClosed]` 检查的是面板上的压制器 *无论在哪里* 和关闭的门 *无论在哪里*。如果这个条件满足，我们就把关闭的门变成打开的门。
- en: The full rule is `late [ Panel Depressor ] [ GateClosed ] -> [ Panel Depressor
    ] [ GateOpen ]`. Notice that on the right side of the arrow, `GateClosed` has
    changed to `GateOpen`, but the panel and the depressor haven’t changed. We don’t
    want them to change, so to indicate that to PuzzleScript, we write them in the
    same way on both sides of the arrow.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的规则是 `late [ Panel Depressor ] [ GateClosed ] -> [ Panel Depressor ] [ GateOpen
    ]`。注意，在箭头的右侧，`GateClosed` 已经变成了 `GateOpen`，但是面板和压制器没有改变。我们不希望它们改变，所以为了告诉 PuzzleScript，我们在箭头两边都以相同的方式写它们。
- en: Also, notice that both rules are late. You learned in [Chapter 3](ch03.xhtml)
    that late rules happen after movement, not before. Because we want gates to open
    after a robot has stepped onto a panel, we run this rule late.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，注意到这两个规则都是延迟执行的。你在[第 3 章](ch03.xhtml)中学到，延迟规则是在移动后发生的，而不是发生在移动之前。因为我们希望门在机器人踩上面板后打开，所以我们将这个规则设置为延迟执行。
- en: Testing the Gates
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试门
- en: 'Let’s build a new test level to make sure our gates and panels work the way
    we want. I drew a level with both robots, a long gate, a panel, and a crate for
    the robots to push onto the panel, as shown here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个新的测试关卡，确保我们的门和面板按预期工作。我画了一个包含两个机器人、一个长门、一个面板和一个箱子的关卡，机器人需要推箱子到面板上，见下图：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can either type this in to the `LEVELS` section manually, or you can use
    the level editor. (Press **E** to switch into editing mode, and then click the
    **S** button in the corner to see a text version of your level.)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以手动在 `LEVELS` 部分输入这段代码，或者使用关卡编辑器。（按 **E** 进入编辑模式，然后点击角落的 **S** 按钮查看关卡的文本版。）
- en: Now *playtest* your level. Playtesting is about trying as many features as possible
    in the game to make sure they work. Try to do as many actions as you can think
    of to see how the code handles different scenarios. Imagine you’re a detective,
    carefully trying to find the hidden bugs. There’s one in the game right now. Can
    you find it?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 *进行游戏测试*。游戏测试是尝试尽可能多的游戏功能，以确保它们能正常工作。尽量做你能想到的各种动作，看看代码如何处理不同的场景。想象你是一个侦探，小心翼翼地寻找隐藏的
    bug。现在游戏中有一个 bug，你能找到吗？
- en: To find the bug, have one robot stand on the panel and hold the gate open. Next,
    move the other robot on top of an open gate.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到这个 bug，让一个机器人站在面板上并保持门开启。接下来，将另一个机器人移到打开的门上方。
- en: '![image](../images/pg089-01.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg089-01.jpg)'
- en: '*Holding a gate open*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*保持门开启*'
- en: Then have both robots stand right on top of the open gate. Finally, switch back
    to the first robot and have them step off the panel. What happens?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让两个机器人站在打开的门上。最后，切换回第一个机器人，让它从面板上走开。会发生什么？
- en: '*Boosh!* The robot disappears forever because the closed gate object is on
    the same collision layer as the character object. Two objects on the same collision
    layer can’t share the same space, so when the open gate becomes a closed gate,
    the robot disappears.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*砰！* 机器人永远消失，因为关闭的门对象和角色对象处于同一个碰撞层。两个位于同一碰撞层的物体不能共享同一个空间，因此当开门变为关门时，机器人消失了。'
- en: '![image](../images/pg090-01.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg090-01.jpg)'
- en: '*Finding the bug*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*寻找 bug*'
- en: To fix this bug, we need to tell PuzzleScript to do something normally *except*
    in a specific case. In this case, we want the `GateOpen` to become a `GateClosed`
    *except* when there’s already a depressor on top of it. In other words, when a
    depressor is on top of an open gate, the gate should not close to prevent the
    depressor from disappearing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个 bug，我们需要告诉 PuzzleScript 做一些通常的操作，*除非* 在特定的情况下。在这个例子中，我们希望 `GateOpen`
    变成 `GateClosed`，*除非* 上面已经有压制器。换句话说，当压制器在打开的门上时，门不应关闭，以防压制器消失。
- en: 'Let’s update our rule with this exception by changing `[ GateOpen ]` to `[
    GateOpen no Depressor ]`, as shown here:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将 `[GateOpen]` 更改为 `[GateOpen no Depressor]` 来更新我们的规则，见下图：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Updating the rule to `[ GateOpen no Depressor ]` tells PuzzleScript that if
    no depressor is on top of a panel, only the open gates without a depressor on
    them should close, *except* any that have depressors standing on them. Click **Rebuild**
    to rerun your game, and try to replicate the bug by trying to do the same action
    that caused the robot to disappear previously. Now when an object is on top of
    an open gate, for example, the gate won’t be able to close, even when another
    object is activating the switch. But when nothing is on top of the open gate,
    the gate should close.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 更新规则为`[ GateOpen no Depressor ]`告诉PuzzleScript，如果面板上没有压迫物，只有没有压迫物的打开门应该关闭，*除非*有压迫物站在上面。点击**Rebuild**重新运行游戏，尝试通过做之前导致机器人消失的相同操作来重现这个
    bug。现在，当一个物体位于打开的门上时，门就无法关闭，即使另一个物体正在激活开关。但当打开的门上没有物体时，门应该关闭。
- en: Adding the Security Lasers
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加安全激光
- en: Now that we’ve created crates and gates, and written rules for how they interact,
    we’re ready to introduce *security lasers*, a threat that the robots can avoid
    using the gates and crates! To do this, we’ll make a laser gun that shoots out
    lasers at every turn. If a laser hits a robot, the player loses! But if the laser
    hits another solid object, like a crate or gate, it’ll stop there.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了箱子和门，并编写了它们如何交互的规则，我们准备引入*安全激光*，这是机器人可以通过使用门和箱子避开的威胁！为此，我们将制作一把激光枪，每回合都会发射激光。如果激光击中机器人，玩家就会失败！但如果激光击中另一个固体物体，比如箱子或门，它会在那停止。
- en: Creating the Laser Objects
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建激光物体
- en: 'Let’s start by drawing our objects. We’ll need three objects:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从绘制物体开始。我们需要三个物体：
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The laser gun (`Gun`) is shaped like a cross, and the two lasers (`LaserVertical`
    and `LaserHorizontal`) are beams of red light. The vertical laser, as you can
    imagine, fires up and down, and the horizontal laser fires left and right.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 激光枪（`Gun`）呈十字形，两个激光（`LaserVertical`和`LaserHorizontal`）是红色光束。垂直激光，顾名思义，上下发射，水平激光左右发射。
- en: Adding Lasers to the Legend
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将激光添加到图例中
- en: Because we only need to add objects to the legend that will be at the very beginning
    of the level, we only need to add the guns, which definitely will be at the start
    of the level. The lasers appear only when the guns fire them, so we don’t need
    to give them a symbol here. I used a plus sign (`+`) to represent the gun because
    it’s also plus-shaped.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只需要将物体添加到图例中，而这些物体只会出现在关卡的最开始，我们只需要添加枪，这些枪肯定会出现在关卡开始时。激光只在枪发射时出现，因此我们不需要在这里给它们一个符号。我用加号（`+`）表示枪，因为它本身也是加号形状的。
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Can you think of any groups we should add to the legend before we start writing
    our rules? For example, it would be useful to create a group for objects that
    block the laser, like walls, closed gates, and crates. We’ll group these objects
    into a new group called `Blocker`, as shown here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写规则之前，你能想到需要加入图例的任何组吗？例如，创建一个用于阻挡激光的物体组会很有用，比如墙壁、关闭的门和箱子。我们将这些物体分到一个名为`Blocker`的新组中，如下所示：
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This line tells PuzzleScript that the `Wall`, `GateClosed`, and `Crate` will
    all be able to block the lasers. We don’t use the `Pushable` group here because
    it includes Vertibot and Horibot in their sleeping forms, and we want them to
    trigger an alarm if a laser hits them. Note that we also want the `Gun` to be
    able to block lasers, because we want the lasers to shoot *from* our guns, not
    *through* them.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码告诉PuzzleScript，`Wall`、`GateClosed`和`Crate`都可以阻挡激光。我们在这里没有使用`Pushable`组，因为它包含了处于休眠状态的Vertibot和Horibot，我们希望它们在激光击中时触发警报。需要注意的是，我们也希望`Gun`能够阻挡激光，因为我们希望激光从我们的枪口发射，而不是*穿过*它们。
- en: Because we have two different kinds of lasers, let’s add them to the group `Laser`
    to easily refer to both. This should make it easier to check whether something
    has been hit by a laser. Without this group, we’d have to do two separate checks,
    one for each kind of laser.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有两种不同的激光，我们将它们添加到`Laser`组中，以便轻松引用这两种激光。这样应该更容易检查某物是否被激光击中。如果没有这个组，我们就必须做两个独立的检查，一个针对每种激光。
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Adding Lasers to the Collision Layers
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将激光添加到碰撞层
- en: Now let’s add our new objects to the `COLLISIONLAYERS` section.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将新物体添加到`COLLISIONLAYERS`部分。
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We place the gun on the same layer as all the other solid objects that the robots
    can bump into. The different lasers are on different layers because we want the
    laser beams to be able to pass through the solid objects.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将枪放置在与机器人可以碰撞的所有其他固体物体相同的层上。不同的激光位于不同的层上，因为我们希望激光束能够穿过固体物体。
- en: Notice that each laser is on its own collision layer. The reason is that if
    they were on the same layer, the vertical laser beam would be able to block the
    horizontal laser, and vice versa! In real life, lasers are just beams of light,
    and one laser can’t block another, or can it? If any scientists are reading this,
    please let me know!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个激光都在自己的碰撞层上。原因是，如果它们在同一层上，垂直激光束就能阻挡水平激光，反之亦然！在现实生活中，激光只是光束，一束激光无法阻挡另一束激光，还是可以的？如果有科学家在读这篇文章，请告诉我！
- en: Writing Laser Rules
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写激光规则
- en: 'The laser objects we made are just a single piece of a laser beam, which is
    big enough to fit only a single space in a given level. If we put a bunch of them
    in a row, we’ll have a much longer laser. We want the lasers to keep going until
    they hit a `Blocker`. The following rules make this happen:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的激光物体只是激光束的一小部分，足够大到只能在给定的关卡中占用一个格子。如果我们把它们排成一排，就会得到一个更长的激光。我们希望激光继续延伸，直到它们碰到一个`Blocker`。以下规则实现了这个效果：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, we need to make the laser guns fire. A gun fires laser beams in whatever
    directions aren’t blocked by a blocker. PuzzleScript checks a rule in all four
    directions (up, down, left, and right) unless you tell it to do otherwise. We
    don’t want the horizontal lasers to shoot up and down or the vertical lasers to
    shoot left and right. So we tell PuzzleScript that horizontal lasers fire horizontally
    and vertical lasers fire vertically using `horizontal` and `vertical`, respectively.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要让激光枪开火。激光枪会在没有被阻挡物挡住的方向发射激光束。PuzzleScript会在四个方向（上、下、左、右）检查规则，除非你告诉它做其他设置。我们不希望水平方向的激光上下发射，或垂直方向的激光左右发射。所以，我们告诉PuzzleScript水平方向的激光水平发射，垂直方向的激光垂直发射，分别使用`horizontal`和`vertical`。
- en: In this case, `horizontal [ Gun | no Blocker ] -> [ Gun | LaserHorizontal ]`
    checks that there’s no blocker next to a gun, and if this is true, the space next
    to the gun turns into a horizontal laser beam. We use the same idea for the vertical
    laser beam.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`horizontal [ Gun | no Blocker ] -> [ Gun | LaserHorizontal ]`检查激光枪旁边是否没有阻挡物，如果为真，激光枪旁边的格子会变成水平激光束。我们用相同的思路来处理垂直激光束。
- en: Testing the Lasers
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试激光
- en: 'Let’s return to our `LEVELS` section to test our laser rules. Add a laser to
    the test level by updating the code to look like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`LEVELS`部分来测试我们的激光规则。通过更新代码，使其如下所示，来为测试关卡添加激光：
- en: '[PRE34]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: I’ve put the laser behind the gate so I can test whether gates block lasers
    like they’re supposed to. Click **Rebuild** to run the game, and you should see
    something like this.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我将激光放在门后面，这样我可以测试门是否像预期的那样阻挡激光。点击**重建**来运行游戏，你应该能看到类似下面的效果。
- en: '![image](../images/pg094-01.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg094-01.jpg)'
- en: '*Test level with laser gun*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*带激光枪的测试关卡*'
- en: '![image](../images/pg095-01.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg095-01.jpg)'
- en: As you can see, the lasers fire, but the beams extend only a single space in
    each direction. The laser beams are too short! We need to add a rule that makes
    the beams extend until they eventually hit a blocker. All the objects in PuzzleScript
    are the same size. To create a longer laser, we’ll put a bunch of laser objects
    in a line. We need to add a rule that does that.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，激光会发射，但激光束只在每个方向上延伸一个格子。激光束太短了！我们需要添加一个规则，使得激光束会延伸，直到最终碰到一个阻挡物。PuzzleScript中的所有物体都是相同大小的。为了创建一个更长的激光束，我们将把多个激光物体排成一行。我们需要添加一个规则来实现这个效果。
- en: 'Again, we’ll create separate rules for vertical and horizontal lasers. If every
    laser extended in every direction, it would be *extremely dangerous*, as you can
    imagine. Instead, we’ll extend horizontal lasers left and right and extend vertical
    lasers up and down. Add the following lines of code below your existing laser
    rules:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将为垂直激光和水平激光创建独立的规则。如果每个激光在每个方向上都延伸，那会是*极其危险*的，正如你能想象的那样。相反，我们将水平激光向左右延伸，垂直激光向上下延伸。在现有的激光规则下面添加以下代码行：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: These additional rules check for empty spaces next to the laser beams. As we
    did when we checked for a panel with no depressors on it using `[ Panel no Depressor
    ]`, we use `[ LaserVertical | no blocker ]` to check for a laser with no blocker
    objects next to it. If there’s no blocker in the space next to the laser beam,
    we extend the laser into that space by changing `no blocker` to a `LaserVertical`
    or `LaserHorizontal`. But if there *is* a blocker in the space, the rule would
    stop there.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这些额外的规则会检查激光束旁边的空格。就像我们检查没有压力器的面板时使用`[ Panel no Depressor ]`一样，我们使用`[ LaserVertical
    | no blocker ]`来检查旁边没有阻挡物的激光。如果激光束旁边的空间没有阻挡物，我们就通过将`no blocker`替换为`LaserVertical`或`LaserHorizontal`来延伸激光到那个空间。但是如果该空间中有阻挡物，规则会在这里停止。
- en: PuzzleScript runs a single rule over and over until it stops before moving on
    to the next rule. So this rule continues to run for all adjacent spaces in a laser’s
    path as long as there’s no blocker in those spaces. As a result of this rule,
    a continuous laser beam shoots out from the gun horizontally and vertically.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: PuzzleScript会重复执行一条规则，直到它停止，然后再继续执行下一条规则。因此，这条规则会在激光路径的所有相邻空间中继续执行，只要这些空间没有阻挡物。由于这条规则，激光束会从枪口水平和垂直方向连续射出。
- en: To test the updated laser rules, click **Rebuild** and check whether the laser
    beams extend to the wall. Also, try using the panel to open the gate. The laser
    should extend through the opened gate.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试更新后的激光规则，点击**重建**并检查激光束是否延伸到墙壁上。同时，尝试使用面板打开大门。激光应该穿过打开的大门。
- en: Fixing the Laser Bug
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修复激光BUG
- en: There’s still a problem with the lasers. If you step off the panel, the gate
    closes and blocks the laser, but the laser beam continues on the other side of
    the gate.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 激光仍然存在问题。如果你离开面板，大门会关闭并阻挡激光，但激光束会继续穿过大门的另一边。
- en: '![image](../images/pg096-01.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg096-01.jpg)'
- en: '*Test level showing a laser bug*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*测试关卡展示激光BUG*'
- en: '![image](../images/pg097-01.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg097-01.jpg)'
- en: The game design process often involves adding some code to your game, checking
    how it works, making little changes, and then checking it again. Every time we
    do this, we get a little closer to making our game exactly how we want it. In
    this case, we need to tweak our laser rules so a closed gate completely blocks
    a laser beam.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏设计过程通常包括向游戏中添加一些代码，检查它如何运行，进行一些小的更改，然后再检查一次。每次我们这样做时，都会离我们想要的游戏状态更近一步。在这种情况下，我们需要调整激光规则，以便关闭的大门能够完全阻挡激光束。
- en: 'To do that, we need to remind ourselves what a single turn in a PuzzleScript
    game looks like. PuzzleScript runs a turn whenever the player presses a key (either
    the arrow keys or the action key). This is what happens in a turn:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要提醒自己PuzzleScript游戏中的每回合是如何进行的。每当玩家按下一个键（无论是方向键还是行动键），PuzzleScript就会执行一回合。这是回合中发生的事情：
- en: PuzzleScript marks any player objects that are trying to move (in the rules,
    this looks like `> Vertibot` instead of `Vertibot`).
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PuzzleScript会标记任何试图移动的玩家对象（在规则中，这看起来像`> Vertibot`而不是`Vertibot`）。
- en: PuzzleScript runs every rule in order from top to bottom as many times as it
    can.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PuzzleScript会按照从上到下的顺序尽可能多次执行每条规则。
- en: Anything marked to move moves.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何标记为移动的对象都会移动。
- en: PuzzleScript runs any *late* moves in order from top to bottom as many times
    as it can.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PuzzleScript会尽可能多次执行所有*延迟*的移动规则，按从上到下的顺序。
- en: 'The problem with our current rules is that we never get rid of lasers after
    they’re cut off by a blocker object. Let’s add the following rule that does that:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前规则的问题在于，当激光被阻挡物切断时，我们没有去除激光。让我们添加以下规则来解决这个问题：
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we use the `laser` group we defined earlier. This simple addition tells
    PuzzleScript that any laser beams no longer attached to a gun should disappear.
    The rule also tells PuzzleScript to change the lasers into empty spaces to get
    rid of the laser beams after they’ve been blocked by a closed gate. Then PuzzleScript
    creates new lasers that extend out to erase all the lasers left over from the
    previous turn. The square brackets represent an empty space, so `[ laser ] ->
    [ ]` tells PuzzleScript to find all the laser objects and get rid of them. Then,
    we’ll redraw our lasers based on the *current* layout of the level.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用之前定义的`laser`组。这个简单的补充告诉PuzzleScript，任何不再连接到枪的激光束应该消失。该规则还告诉PuzzleScript，在激光束被关闭的大门阻挡后，将激光转变为空格以消除激光束。接着，PuzzleScript会创建新的激光，将它们延伸出去，消除上一个回合剩余的激光。方括号表示空格，所以`[
    laser ] -> [ ]`告诉PuzzleScript找到所有激光对象并将其移除。然后，我们会根据关卡的*当前*布局重新绘制激光。
- en: Click **Rebuild** and run this test again! Try standing on and moving off the
    panel a few times. We’re a bit closer, but the program is still a little wonky.
    When the robot steps off the panel, the beams *are* cut off, but it doesn’t happen
    until the next turn!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**重建**并再次运行此测试！尝试几次站在面板上并离开。我们稍微接近了一些，但程序仍然有些问题。当机器人从面板上走下时，激光束*会*被切断，但这只会在下一回合发生！
- en: '![image](../images/pg098-01.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg098-01.jpg)'
- en: 'Fortunately, there’s an easy solution to fixing this delay. On any given turn,
    PuzzleScript runs through each rule and then objects move according to the rules.
    Right now the rules governing our lasers are happening *before* the robots move
    on or off of the panel. Let’s make sure those rules happen *after* movement, which
    we can accomplish by simply making the laser rules happen *late*, as shown here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个简单的解决方案来修复这个延迟。在任何给定的回合中，PuzzleScript 会按顺序执行每个规则，然后对象根据规则移动。现在，控制激光的规则发生在机器人移上或移下面板*之前*。让我们确保这些规则发生在移动*之后*，我们可以通过简单地让激光规则在*稍后*执行来实现，如下所示：
- en: '[PRE37]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Notice also that the lasers don’t fire immediately. They wait until after you’ve
    made a move and then fire. To have the lasers begin firing right away, just add
    `run_rules_on_level_start` to the very beginning of your PuzzleScript code, under
    the name of your game, as shown here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，激光并不会立即发射。它们会等你走完一步后才会发射。要让激光立即开始发射，只需在你的 PuzzleScript 代码的最开始，在游戏名称下添加
    `run_rules_on_level_start`，如下所示：
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You might have noticed when you hold down the action button to switch characters,
    the selection flickers back and forth quite quickly. The `norepeat_action` command
    makes sure the action button switches character only once, no matter how long
    you press it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当你按住操作按钮切换角色时，选择会迅速闪烁。`norepeat_action` 命令确保无论你按住多长时间，操作按钮只会切换一次角色。
- en: When you’re done, try the following challenges.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，尝试以下挑战。
- en: Bonus Challenges
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑战任务
- en: 'Try making four different lasers, each of which shoots in only one direction:
    up, down, left, and right.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试制作四种不同的激光，每种激光只能朝一个方向发射：上、下、左和右。
- en: In the finished *Robot Heist* game, there are two kinds of gates and panels,
    pink and blue. There are also some gates that close instead of open when a Depressor
    steps on a panel. See if you can figure out how to do this in your own game!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成的*机器人劫案*游戏中，有两种类型的门和面板，粉色和蓝色。还有一些门，在压制器踩到面板时关闭，而不是打开。看看你能否在自己的游戏中实现这种效果！
- en: If you need help, try clicking the **hack** link in *Robot Heist* (*[http://tinyurl.com/robotheist/](http://tinyurl.com/robotheist/)*)
    to see how this code works.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要帮助，尝试点击*机器人劫案*中的**hack**链接（*[http://tinyurl.com/robotheist/](http://tinyurl.com/robotheist/)）查看这个代码是如何工作的。
- en: What You Learned
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: So far you successfully created the basic building blocks of the *Robot Heist*
    game, including the two robot objects the player will use to navigate the level,
    the background and wall that provide the backdrop, and other objects, such as
    crates, guns, and panels. You learned to write rules for each of these objects
    so they interact with one another in interesting ways. You also created obstacles,
    such as lasers, which some objects can block. But right now, our lasers aren’t
    a real threat because they don’t do anything.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经成功创建了*机器人劫案*游戏的基本构建模块，包括玩家将用来在关卡中导航的两个机器人对象、提供背景的墙壁以及其他物品，如箱子、枪支和面板。你学会了为这些物品编写规则，使它们以有趣的方式相互作用。你还创建了激光等障碍物，其中一些物品可以阻挡它们。但现在，我们的激光并不是真正的威胁，因为它们什么都不做。
- en: In the next chapter, you’ll explore the concept of *losing* in game design and
    learn how to raise the stakes for the player. You’ll also explore PuzzleScript’s
    “realtime” mode by creating obstacles that move on their own. See you there!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将探索游戏设计中*失败*的概念，并学习如何为玩家提高游戏难度。你还将通过创建自动移动的障碍物来探索 PuzzleScript 的“实时”模式。到时候见！
