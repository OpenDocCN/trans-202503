- en: '**7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7'
- en: 'MULTIPLICATION STATION II: REUSING CODE WITH PROCEDURES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**乘法车站 II：通过过程重用代码**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Sometimes you’ll want to reuse a section of code to complete a specific task
    you’ve completed before. In these situations, you can define or create a *procedure*
    that includes those lines of code, and then give that procedure a unique name.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能想要重复使用某段代码来完成之前已经完成的特定任务。在这些情况下，你可以定义或创建一个*过程*，将这些代码行包含在其中，然后为该过程命名一个独特的名字。
- en: This way, whenever you want to execute that task, you can call the procedure
    by name instead of writing the same lines of code over and over again. This also
    means that when you have to correct something in that code, you only have to fix
    the code inside the procedure once.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每当你想执行那个任务时，只需通过名称调用该过程，而无需一遍又一遍地编写相同的代码。这也意味着，当你需要修正那段代码时，只需修正过程中的代码一次。
- en: In this chapter, you’ll learn how to create procedures in App Inventor and use
    them to make the “Multiplication Station II” app. As you’ll see, procedures not
    only help you avoid repeating the same code, they also make long and complicated
    code more organized and easier to read.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在 App Inventor 中创建过程并使用它们来制作“乘法车站 II”应用程序。正如你将看到的，过程不仅帮助你避免重复相同的代码，它们还使得冗长复杂的代码更加有序，易于阅读。
- en: '**PROCEDURES CAN TAKE PARAMETERS**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**过程可以接受参数**'
- en: Let’s use a simple example to see how procedures work. Say you’ve written code
    that calculates how many days there are until someone’s birthday. You can use
    those lines of code to create a procedure and give it a name like `BdayCountDown`.
    Now, whenever you need to count down to someone’s birthday, all you have to do
    is *call* the `BdayCountDown` procedure. Pretty handy!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来看看过程是如何工作的。假设你写了一段代码，用来计算某人生日还有多少天。你可以用这几行代码创建一个过程，并给它起个名字，比如 `BdayCountDown`。现在，每当你需要倒数某人生日时，只需*调用*
    `BdayCountDown` 过程。相当方便吧！
- en: Like the built-in methods we’ve used in some of our apps, a procedure might
    require *parameters* that you’ll have to declare and name when defining the procedure
    itself. In the birthday example, the `BdayCountDown` procedure would take a person’s
    birth month and day as parameters to calculate the result. This means that when
    calling `BdayCountDown`, you’ll need to provide the *arguments* that the procedure
    needs to complete that task. In this case, the procedure would take numbers (for
    the date of birth) as its arguments.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在一些应用程序中使用的内置方法一样，过程可能需要*参数*，这些参数在定义过程时必须声明并命名。在生日示例中，`BdayCountDown` 过程将接受一个人的出生月份和日期作为参数来计算结果。这意味着，在调用
    `BdayCountDown` 时，你需要提供过程所需的*参数*，以完成该任务。在这种情况下，过程将接受表示出生日期的数字作为其参数。
- en: 'Since the arguments passed into the procedure at each call may be different,
    a procedure might produce a different result every time you call it. This makes
    sense in the birthday example, too: since most people have different birthdays,
    the procedure would return different values.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每次调用过程时传入的参数可能不同，因此一个过程可能每次调用时都会产生不同的结果。这在生日示例中也很有道理：由于大多数人生日不同，过程会返回不同的结果。
- en: '**CREATING YOUR OWN PROCEDURE**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建你自己的过程**'
- en: You’ve already used several of App Inventor’s built-in procedures, both with
    and without parameters. For instance, in “Hi, World!” in [Chapter 1](ch01.xhtml#ch01),
    you used the call to the built-in `SpeechRecognizer.GetText` method to convert
    spoken messages to text. And in [Chapter 3](ch03.xhtml#ch03)’s “Fruit Loot” app,
    you moved the `ImageSprite`s around the `Canvas` using the `ImageSprite.Move`
    method call, which required x- and y-coordinates as parameters.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用过 App Inventor 的多个内置过程，既有带参数的，也有不带参数的。例如，在[第1章](ch01.xhtml#ch01)的“你好，世界！”中，你使用了内置的
    `SpeechRecognizer.GetText` 方法来将语音信息转换为文本。在[第3章](ch03.xhtml#ch03)的“水果战利品”应用程序中，你使用了
    `ImageSprite.Move` 方法调用，将 `ImageSprite` 移动到 `Canvas` 上，这需要传递 x 和 y 坐标作为参数。
- en: In addition to built-in methods, App Inventor provides blocks that let you create
    your own procedures, which can return results or not and can have numerous parameters
    or none at all. Once you create a procedure with its own unique name, App Inventor
    creates a block just for that procedure that you can use to call it, complete
    with sockets to plug in any parameter arguments. You’ll find the call block in
    the Procedures blocks drawer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置的方法外，App Inventor还提供了让你创建自己过程的块，这些过程可以有或没有返回结果，并且可以有多个参数或根本没有参数。一旦你创建了一个具有唯一名称的过程，App
    Inventor会为该过程创建一个专用的块，供你调用，块上有插槽可以插入任何参数。你将在“过程”块抽屉中找到调用块。
- en: Let’s try creating our own procedures to change the code in some of the apps
    we’ve already made. We’ll refactor the code in “Fruit Loot” so that we don’t repeat
    the same blocks in the three `EdgeReached` event handlers that tell the app what
    to do after each fruit `ImageSprite` reaches the edge of the `Canvas`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试创建自己的过程来修改我们已经做过的某些应用中的代码。我们将重构“Fruit Loot”中的代码，以便不再在三个`EdgeReached`事件处理程序中重复相同的块，这些块告诉应用在每个果实`ImageSprite`到达`Canvas`边缘后该做什么。
- en: The following code shows the `EdgeReached` event handlers we coded in [Chapter
    3](ch03.xhtml#ch03).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了我们在[第3章](ch03.xhtml#ch03)中编写的`EdgeReached`事件处理程序。
- en: As you can see, we duplicated blocks to create the three separate `EdgeReached`
    event handlers for `FruitSprite1`, `FruitSprite2`, and `FruitSprite3`. In each
    copy, we changed only the few blocks that set the `ImageSprite`’s `X` property
    to make sure that the fruit `ImageSprite`s never collide with each other as they
    fall down the `Canvas`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们复制了块来为`FruitSprite1`、`FruitSprite2`和`FruitSprite3`创建了三个单独的`EdgeReached`事件处理程序。在每个副本中，我们仅修改了几个设置`ImageSprite`的`X`属性的块，以确保果实`ImageSprite`在`Canvas`上掉落时不会相互碰撞。
- en: '![Image](../images/f0127-01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0127-01.jpg)'
- en: Now compare this with the following code, which shows a `backToTop` procedure
    that completes the same tasks, but uses a lot fewer blocks if we call it within
    the event handlers for all three fruit `ImageSprite`s.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将其与以下代码进行对比，该代码展示了一个`backToTop`过程，完成相同任务，但如果我们在所有三个果实`ImageSprite`的事件处理程序中调用它，则所需的块要少得多。
- en: '![Image](../images/f0127-02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0127-02.jpg)'
- en: To create the `backToTop` procedure, we’ll need to define the parameters `sprite`
    and `X`, which are the two pieces of information that may change each time the
    procedure is called—the `ImageSprite` to adjust and the x-coordinate for the point
    at the top of the screen where we want to move that `ImageSprite`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`backToTop`过程，我们需要定义`sprite`和`X`这两个参数，它们是每次调用该过程时可能变化的信息——即要调整的`ImageSprite`和我们希望将其移动到屏幕顶部的x坐标。
- en: '**DEFINING THE PARAMETERS**'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**定义参数**'
- en: Log into App Inventor, and open your “Fruit Loot” app by selecting **Projects**
    ▸ **My Projects** and choosing the “Fruit Loot” app from your list of projects.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 登录App Inventor，选择**项目** ▸ **我的项目**，从你的项目列表中选择“Fruit Loot”应用。
- en: Go to the Blocks Editor and click the **Procedures** blocks drawer in the Blocks
    pane. Drag the to procedure do block to the Viewer, click procedure, and rename
    it by entering backToTop.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 转到块编辑器，点击块面板中的**过程**块抽屉。将“to procedure do”块拖到查看器中，点击“procedure”，并通过输入“backToTop”重命名它。
- en: Then click the blue mutator icon to the left of the words `to backToTop`, drag
    two input:x blocks to the inputs block in the dialog that opens, and rename them
    input:sprite and input:X. Your inputs should look like [Figure 7-1](ch07.xhtml#ch7fig1).
    Once the mutator dialog closes, you also should see the parameters `sprite` and
    `X` listed to the right of the words `to backToTop` in the `to backToTop` block,
    as shown in the previous code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后点击位于`to backToTop`文字左侧的蓝色变异器图标，将两个input:x块拖到弹出对话框中的输入框，并将其重命名为input:sprite和input:X。你的输入框应如下所示[图7-1](ch07.xhtml#ch7fig1)。一旦变异器对话框关闭，你还应该能在`to
    backToTop`块的右侧看到参数`sprite`和`X`，正如前面的代码所示。
- en: '![Image](../images/07fig01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig01.jpg)'
- en: '*Figure 7-1: The blocks that add the parameters for the `backToTop` procedure*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：为`backToTop`过程添加参数的块*'
- en: Now we can program `backToTop` so that it can have the app execute the exact
    same commands that we coded in each of the original `EdgeReached` handlers. But
    instead of using blocks for a specific `ImageSprite`, we’ll use the generic Any
    `ImageSprite` setter blocks. That way, each time we call the procedure, the setter
    blocks will make changes to the `ImageSprite` referred to in the procedure’s `sprite`
    parameter, which will be the `ImageSprite` that hit the edge.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编程`backToTop`，使其执行我们在每个原始`EdgeReached`处理程序中编写的完全相同的命令。但不同的是，代替为特定的`ImageSprite`使用块，我们将使用通用的Any
    `ImageSprite`设置器块。这样，每次调用该过程时，设置器块将会修改过程`sprite`参数中引用的`ImageSprite`，也就是撞击边缘的`ImageSprite`。
- en: To add the setter blocks, click the plus sign to the left of the Any Component
    category listing at the bottom of the Blocks pane and then click the **Any ImageSprite**
    drawer, drag the setImageSprite.Enabled block to the Viewer, and make three copies
    of it. You should now have four copies of the `set ImageSprite.Enabled` block
    on the Viewer. You’ll use these to set the `ImageSprite`’s `Y`, `X`, `Picture`,
    and `Visible` properties as shown earlier.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加设置器块，请点击“块”窗格底部“Any Component”类别列表左侧的加号，然后点击**Any ImageSprite**抽屉，将setImageSprite.Enabled块拖到查看器中，并复制三次。现在你应该在查看器中有四个`set
    ImageSprite.Enabled`块。你将使用这些块来设置`ImageSprite`的`Y`、`X`、`Picture`和`Visible`属性，如前所示。
- en: '**Setting the ImageSprite’s Y and X Properties**'
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**设置ImageSprite的Y和X属性**'
- en: We’ll start by setting the given `ImageSprite`’s `Y` and `X` properties to make
    the `ImageSprite` return to a random spot at the top of the screen before dropping
    again.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设置给定的`ImageSprite`的`Y`和`X`属性，使`ImageSprite`返回到屏幕顶部的随机位置，然后再掉落。
- en: '![Image](../images/f0129-01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0129-01.jpg)'
- en: These blocks first take the `Y` property of the `ImageSprite` that is given
    as the argument for the `sprite` parameter in the `backToTop` procedure call (the
    `ImageSprite` that dropped and hit the edge) and set it to `0`. This moves the
    `ImageSprite` back up to the top of the screen. Drag the first copy of the setImageSprite.Enabled
    block ➊ inside the to backToTop procedure block next to the word `do`, click the
    drop-down arrow to the right of the word `Enabled`, and replace Enabled by selecting
    Y. Then mouse over the procedure’s sprite parameter and drag its get sprite block
    ➋ into the setImageSprite.Y block’s first socket. Drag the number 0 block ➌ from
    the Y property setter block in the original FruitSprite1 EdgeReached handler into
    the second socket.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些块首先获取在`backToTop`过程调用中作为`sprite`参数传递的`ImageSprite`的`Y`属性（即掉落并撞击边缘的`ImageSprite`），并将其设置为`0`。这会将`ImageSprite`移动回屏幕顶部。将第一个setImageSprite.Enabled块
    ➊ 拖到backToTop过程块中的`do`旁边，点击`Enabled`右侧的下拉箭头，选择`Y`替换`Enabled`。然后将过程的`sprite`参数上的获取sprite块
    ➋ 拖到setImageSprite.Y块的第一个插槽。将原来FruitSprite1 EdgeReached处理程序中Y属性设置块的数字0块 ➌ 拖到第二个插槽。
- en: Now, we’ll add blocks that set the given `ImageSprite`’s `X` property to the
    given random `X` value, which moves the `ImageSprite` to a random spot at the
    top of the screen. To do this, drag the second setImageSprite.Enabled block ➍
    into the procedure block under the setImageSprite.Y block, and replace Enabled
    by selecting X in the drop-down. Drag another get sprite block ➎ into the setImageSprite.X
    block’s first socket, mouse over the procedure’s X parameter, and drag its get
    X block ➏ into the second socket.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加块来设置给定的`ImageSprite`的`X`属性为给定的随机`X`值，这会将`ImageSprite`移动到屏幕顶部的随机位置。为此，将第二个setImageSprite.Enabled块
    ➍ 拖到setImageSprite.Y块下方的过程块中，并在下拉菜单中选择`X`来替换`Enabled`。将另一个获取sprite块 ➎ 拖到setImageSprite.X块的第一个插槽，鼠标悬停在过程的`X`参数上，将其获取X块
    ➏ 拖到第二个插槽。
- en: '**Setting the ImageSprite’s Picture and Visible Properties and Adding to fruitsDropped**'
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**设置ImageSprite的Picture和Visible属性并增加fruitsDropped**'
- en: Next, we’ll add blocks that set the given `ImageSprite`’s new `Picture` and
    `Visible` properties and increment the value of the `fruitsDropped` variable.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加设置块，设置给定的`ImageSprite`的新`Picture`和`Visible`属性，并增加`fruitsDropped`变量的值。
- en: '![Image](../images/f0129-02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0129-02.jpg)'
- en: First, we’ll place the blocks that set the given `ImageSprite`’s `Picture` property
    randomly to *1.png*, *2.png*, or *3.png*, each of which is a picture of a different
    piece of fruit. This ensures that players won’t know whether an apple, lemon,
    or orange will drop next. To do this, drag the third setImageSprite.Enabled block
    ➊ into the procedure block under the setImageSprite.X block, and replace Enabled
    by selecting Picture in the drop-down. Drag another get sprite block ➋ into its
    first socket, and drag the join block ➌ from the `Picture` setter block in the
    original `EdgeReached` handler into the second socket.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将放置一些代码块，使得给定的`ImageSprite`的`Picture`属性随机设置为*1.png*、*2.png*或*3.png*，每个图片代表一种不同的水果。这样可以确保玩家不会知道接下来掉落的是苹果、柠檬还是橙子。为了做到这一点，将第三个setImageSprite.Enabled块
    ➊ 拖入`setImageSprite.X`块下的过程块，并通过选择下拉菜单中的`Picture`来替换Enabled。再将另一个get sprite块 ➋
    拖入第一个插槽，然后将原`EdgeReached`事件处理程序中的`Picture`设置器块中的join块 ➌ 拖入第二个插槽。
- en: Then, we’ll add another set of blocks to make the given `ImageSprite` visible
    in case it hit the picker earlier and disappeared. Drag the fourth setImageSprite.Enabled
    block ➍ into the procedure block under the setImageSprite.Picture block, and replace
    Enabled by selecting Visible in the drop-down menu. Drag another get sprite block
    ➎ into its first socket, and drag the true block ➏ from the `Visible` setter block
    in the original `EdgeReached` handler into the second socket.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加另一组代码块，以确保如果图像之前被拾取器碰到并消失，它仍然能显示出来。将第四个setImageSprite.Enabled块 ➍ 拖入`setImageSprite.Picture`块下的过程块，并通过选择下拉菜单中的`Visible`来替换Enabled。再将另一个get
    sprite块 ➎ 拖入第一个插槽，然后将原`EdgeReached`事件处理程序中的`Visible`设置器块中的true块 ➏ 拖入第二个插槽。
- en: Finally, to complete the `backToTop` procedure, we’ll add blocks that increment
    the value of the `fruitsDropped` variable by 1 when the procedure is called. This
    will enable us to keep track of the total number of pieces of fruit dropped in
    the game. To do this, drag the set global fruitsDropped blocks ➐ from the original
    `EdgeReached` handler into the procedure block under the `setImageSprite.Visible`
    block.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了完成`backToTop`过程，我们将添加一些代码块，当调用此过程时，将`fruitsDropped`变量的值加1。这样我们就能跟踪游戏中掉落的水果总数。为此，将原`EdgeReached`事件处理程序中的set
    global fruitsDropped块 ➐ 拖入`setImageSprite.Visible`块下的过程块。
- en: '**CALLING THE PROCEDURE**'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**调用过程**'
- en: With this procedure in place, we no longer need to add the five setter blocks
    to each `EdgeReached` event handler.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个过程，我们不再需要将这五个设置器块添加到每个`EdgeReached`事件处理程序中。
- en: '![Image](../images/f0130-01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0130-01.jpg)'
- en: We can handle the `EdgeReached` event for each fruit `ImageSprite` simply by
    snapping the `call backToTop` block ➊ from the Procedures drawer inside each `ImageSprite`’s
    `EdgeReached` event handler.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单地将`call backToTop`块 ➊ 从过程面板拖入每个`ImageSprite`的`EdgeReached`事件处理程序来处理每个水果`ImageSprite`的`EdgeReached`事件。
- en: We can then click the ImageSprite in the Blocks pane; drag the very last block,
    its getter block ➋, into the call backToTop sprite socket to provide the argument
    for the `sprite` parameter; and drag the random integer blocks ➌ from the X setter
    block in its original `EdgeReached` handler into the call backToTop X socket to
    provide the argument for the `X` parameter. Once you add the call block to the
    `EdgeReached` handler for each `ImageSprite` and fill the parameter sockets as
    described, be sure to delete the five original setter blocks from all three `EdgeReached`
    event handlers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在代码块面板中点击`ImageSprite`；将最后一个代码块，它的getter块 ➋，拖入`call backToTop`精灵插槽中，以提供`sprite`参数的参数；并将原`EdgeReached`事件处理程序中的X设置器块中的随机整数块
    ➌ 拖入`call backToTop X`插槽中，以提供`X`参数的参数。添加了`call`块到每个`ImageSprite`的`EdgeReached`事件处理程序并按照描述填充了参数插槽后，记得从所有三个`EdgeReached`事件处理程序中删除五个原始设置器块。
- en: Now we can use the `backToTop` procedure not just in the “Fruit Loot” game,
    but in any other similar game. Since we’ve created this procedure here, we never
    have to figure out again how to keep moving randomly dropping, non-colliding images
    back to the top of a screen to drop again, whether they’re images of balls, birds,
    or anything else.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不仅可以在“水果掉落”游戏中使用`backToTop`过程，还可以在任何其他类似的游戏中使用。既然我们在这里创建了这个过程，我们就不再需要每次重新思考如何将随机掉落且不碰撞的图像移动回屏幕顶部以便再次掉落，无论它们是球、鸟还是其他任何东西。
- en: '**NOTE**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can transfer a procedure, or any other block, from one app project to
    another by right-clicking on the blocks and selecting Add to Backpack. This action
    adds a copy of the blocks to the backpack located at the top right of the Viewer
    in the Blocks Editor window. To take blocks out of the backpack, click the backpack
    and drag the blocks to the Viewer.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以通过右键点击区块并选择“添加到背包”来将一个程序或任何其他区块从一个应用项目转移到另一个应用项目。这一操作会将区块的副本添加到位于区块编辑器窗口右上角的背包中。要从背包中取出区块，点击背包并将区块拖到查看器中。*'
- en: '**BUILDING THE “MULTIPLICATION STATION II” APP**'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**构建“乘法站 II”应用**'
- en: Let’s define another multiparameter procedure to build on the original “Multiplication
    Station” app from [Chapter 4](ch04.xhtml#ch04). When we’re done, users should
    be able to select from two difficulty levels of multiplication problems. We’ll
    also rework the user interface of the app’s welcome screen, create new global
    list variables to present choices, and include an `if then` block to tell the
    app what to display when a user selects each level of practice problems.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义另一个多参数过程，基于[第4章](ch04.xhtml#ch04)中的原始“乘法站”应用进行扩展。完成后，用户应该可以选择两种难度级别的乘法题目。我们还将重新设计应用的欢迎界面，创建新的全局列表变量来呈现选项，并包含一个`if
    then`区块来告诉应用在用户选择每个练习级别时应显示什么。
- en: To get started, open your original “Multiplication Station” app by selecting
    **Projects** ▸ **My Projects**, as shown in [Figure 7-2](ch07.xhtml#ch7fig2),
    and choosing the “Multiplication Station” app from your list of projects.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开你原来的“乘法站”应用，方法是选择**项目** ▸ **我的项目**，如[图7-2](ch07.xhtml#ch7fig2)所示，从你的项目列表中选择“乘法站”应用。
- en: '![Image](../images/07fig02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig02.jpg)'
- en: '*Figure 7-2: The Projects menu where you open and save projects*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-2：打开和保存项目的项目菜单*'
- en: Once “Multiplication Station” opens, select **Projects** ▸ **Save project as…**
    and rename the project by entering MultiplicationStationII without any spaces,
    and then click **OK**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦“乘法站”打开，选择**项目** ▸ **另存为…**，然后通过输入“MultiplicationStationII”并去掉空格来重命名项目，接着点击**确定**。
- en: '**DECOMPOSING “MULTIPLICATION STATION II”**'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**分解“乘法站 II”**'
- en: We want to change the original “Multiplication Station” app so that when users
    open the app, they can choose level 1 (easier) or level 2 (more challenging) problems
    to practice and will have more time to solve level 2 problems.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望修改原有的“乘法站”应用，使得用户打开应用后，可以选择1级（较易）或2级（更具挑战性）的题目进行练习，并且在2级题目上有更多的时间来解决。
- en: 'We can decompose the new action for “Multiplication Station II” into three
    steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将“乘法站 II”中的新动作分解为三个步骤：
- en: When the user opens the app, play a welcome message. Display the `ListPicker`
    for the user to click to choose a practice level.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户打开应用时，播放欢迎信息。显示`ListPicker`供用户点击选择练习级别。
- en: After the user clicks the `ListPicker` to choose a practice level, play another
    message stating the number of seconds available to answer each problem. Open and
    pass the selected problem level to the practice screen.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户点击`ListPicker`选择练习级别后，播放另一条信息，说明每道题目可用的答题时间。打开并将选定的题目级别传递给练习屏幕。
- en: When the `Clock`’s timer fires, display a random multiplication problem at the
    correct time interval for the selected problem level.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`Clock`的计时器触发时，在正确的时间间隔显示一个随机的乘法问题，具体问题级别根据选定的级别来定。
- en: 'You’ll need the following new components:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要以下新的组件：
- en: ListPicker for the user to click to select problem level and open the practice
    screen (this replaces the original start button on the welcome screen)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于用户点击选择题目级别并打开练习屏幕的`ListPicker`（这将替代欢迎屏幕上的原始开始按钮）
- en: Procedure to display problems and set the `Clock` timer interval according to
    the selected problem level
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示问题并根据选定的题目级别设置`Clock`计时器间隔的过程
- en: Variable (2) to store problem level and timer interval
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储问题级别和计时器间隔的变量（2）
- en: '**LAYING OUT “MULTIPLICATION STATION II” IN THE DESIGNER**'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在设计器中布局“乘法站 II”**'
- en: Right now, the welcome screen gives users only one option—to click the start
    button and start practicing. To allow users to first choose the level of multiplication
    problems, all we have to do is remove `Button1` from the welcome screen and replace
    it with a `ListPicker`. Once we adjust the `ListPicker`’s properties to make it
    look similar to `Button1`, the new welcome screen should look something like [Figure
    7-3](ch07.xhtml#ch7fig3).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，欢迎屏幕只给用户一个选项——点击开始按钮并开始练习。为了让用户先选择乘法题目的难度级别，我们只需要从欢迎屏幕上移除`Button1`，并用`ListPicker`替换它。一旦我们调整`ListPicker`的属性，使其看起来与`Button1`相似，新的欢迎屏幕应该类似于[图
    7-3](ch07.xhtml#ch7fig3)。
- en: '![Image](../images/07fig03.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig03.jpg)'
- en: '*Figure 7-3: The Viewer, Component, and Media panes showing the `Screen1` layout
    for “Multiplication Station II”*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：显示“乘法站 II”布局的查看器、组件和媒体窗格*'
- en: To make these changes, first go to the Designer for `Screen1`. Click Button1
    in the Components pane, and click **Delete** and then **Delete** again in the
    dialog that opens.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行这些更改，首先进入`Screen1`的设计器。点击组件窗格中的Button1，点击**删除**，然后在弹出的对话框中再次点击**删除**。
- en: Now drag a ListPicker from the User Interface drawer and place it on the Viewer
    where you just deleted `Button1`. Adjust the `ListPicker`’s properties so that
    it looks like `Button1`. In the Properties pane, change the background color to
    black by clicking **Default** under BackgroundColor and then clicking **Black**
    when the color list dialog opens. Make its text bold by clicking the checkbox
    under FontBold, and change its shape by clicking the drop-down arrow under **Shape**
    and selecting **rounded**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从用户界面抽屉中拖动一个`ListPicker`，并将其放置在刚才删除`Button1`的位置。调整`ListPicker`的属性，使其看起来像`Button1`。在属性窗格中，点击背景色下的**默认**，然后在颜色列表对话框中点击**黑色**，将背景色改为黑色。通过点击字体粗体下的复选框使文本加粗，并点击**形状**下的下拉箭头选择**圆角**来改变它的形状。
- en: 'Next, enter Choose Your Level in the text box under **Text** so users know
    to click the `ListPicker` to choose their problem level. Then, center the text
    by clicking the drop-down arrow under TextAlignment and selecting **center: 1**,
    and make the text white by clicking **Default** under TextColor and then clicking
    **White** when the color list dialog opens. `Screen1` should now look like [Figure
    7-3](ch07.xhtml#ch7fig3) in the Viewer.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在**文本**下的文本框中输入“选择你的级别”，让用户知道点击`ListPicker`来选择他们的题目级别。然后，点击文本对齐下的下拉箭头并选择**居中：1**，将文本居中，并点击文本颜色下的**默认**，然后在颜色列表对话框中点击**白色**，将文本颜色改为白色。此时，`Screen1`应该在查看器中看起来像[图
    7-3](ch07.xhtml#ch7fig3)。
- en: '**PROGRAMMING “MULTIPLICATION STATION II”**'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程“乘法站 II”**'
- en: Now let’s program the new features for “Multiplication Station II” following
    the steps outlined earlier. To show the correct problems for the selected problem
    level, we’ll create two new list variables and a procedure with parameters. We’ll
    add an `if then` block to the procedure so that the app will know whether to display
    problems for level 1 or level 2 at each `Clock` timer interval.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按照之前概述的步骤为“乘法站 II”编写新的功能程序。为了显示正确的题目级别，我们将创建两个新的列表变量和一个带参数的过程。我们将在过程里添加一个`if
    then`块，以便应用程序知道在每个`Clock`计时器间隔时，应该显示一级题目还是二级题目。
- en: We’ll also program two new event handlers so that the app will know what to
    do before and after the user selects a level with the `ListPicker`. To begin programming,
    click the **Blocks** button to switch to the Blocks Editor and make sure you’re
    on `Screen1`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将编程两个新的事件处理器，以便在用户选择了`ListPicker`中的级别之前和之后，应用程序知道应该怎么做。开始编程时，点击**块**按钮切换到块编辑器，并确保你在`Screen1`上。
- en: '**STEP 1: SETTING PROBLEM LEVEL CHOICES AND PLAYING THE NEW WELCOME MESSAGE**'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**步骤 1：设置题目级别选择并播放新的欢迎信息**'
- en: As soon as the screen opens, we want to display the `ListPicker` with the problem
    level options for the user to select. We’ll prompt the user to select a practice
    problem level by playing the app’s welcome message.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦屏幕打开，我们希望显示带有题目级别选项的`ListPicker`，供用户选择。我们将通过播放应用的欢迎信息提示用户选择练习题目级别。
- en: '**Creating the Global level and seconds List Variables**'
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建全局级别和秒数列表变量**'
- en: 'We’ll use two global list variables in this step: `level`, which stores the
    two problem level choices for `ListPicker1`, and `seconds`, which holds the number
    of seconds available to solve problems in each level. Create the two lists with
    the blocks shown here.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们将使用两个全局列表变量：`level`，它存储 `ListPicker1` 的两个问题级别选项，以及 `seconds`，它保存每个级别解题时可用的秒数。按照这里显示的方块创建这两个列表。
- en: '![Image](../images/f0133-01.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0133-01.jpg)'
- en: To create each variable, click the **Variables** block drawer and drag an initialize
    global name block ➊ to the Viewer, click name, and replace it with the variable
    name (in this case, level and seconds). Then drag a make a list block ➋ from the
    Lists drawer and snap it to the right side of the initialize global block. Finally,
    drag two 0 number blocks ➌ from the Math drawer and snap them into the sockets
    of the make a list block. Then, replace the 0 in each number block with 1 and
    2 in level for the two possible problem levels and 5 and 10 in seconds for the
    number of seconds available for each level.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建每个变量，点击 **变量** 方块抽屉，并将初始化全局名称方块 ➊ 拖到查看器中，点击名称并将其替换为变量名（在此案例中为 level 和 seconds）。然后从列表抽屉中拖动一个创建列表方块
    ➋，并将其连接到初始化全局方块的右侧。最后，从数学抽屉中拖动两个 0 数字方块 ➌，并将它们插入到创建列表方块的插槽中。接着，将每个数字方块中的 0 替换为
    level 中的 1 和 2（对应两个可能的题目级别），以及 seconds 中的 5 和 10（对应每个级别可用的秒数）。
- en: The items we’ve placed in the same index position in the two variables correspond
    to each other. This means that we can see how many seconds are available to solve
    problems for each level by looking at the items that are placed in the same position
    in the `level` and `seconds` variables. Here you can see that there are 5 seconds
    available for level 1 problems, and 10 seconds available for level 2.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在两个变量中放置的相同索引位置的项目是相对应的。这意味着我们可以通过查看 `level` 和 `seconds` 变量中相同位置的项目，来了解每个级别可用的秒数。在这里，你可以看到，级别
    1 的题目有 5 秒可用，级别 2 的题目有 10 秒可用。
- en: '**Programming the Welcome Screen Event Handlers**'
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**编程欢迎屏幕事件处理器**'
- en: 'Now we can start coding the app’s response to the two events in this step:
    the `ListPicker BeforePicking` and the `ScreenInitialize` events. This is where
    we want to set the problem level choices for the `ListPicker` and play the welcome
    message.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始编写应用对这两个事件的响应：`ListPicker BeforePicking` 和 `ScreenInitialize` 事件。这里我们想要为
    `ListPicker` 设置题目级别选项，并播放欢迎信息。
- en: '![Image](../images/f0134-01.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0134-01.jpg)'
- en: Having created `level`, we have the data we need to set `ListPicker1`’s choices.
    Before the user selects from `ListPicker1`, we need to set those choices to the
    items in the `level` list so users can choose between level 1 and level 2\. We’ll
    program this action with the `ListPicker BeforePicking` event handler.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了 `level` 后，我们就有了设置 `ListPicker1` 选项所需的数据。在用户从 `ListPicker1` 选择之前，我们需要将这些选项设置为
    `level` 列表中的项目，以便用户可以在级别 1 和级别 2 之间进行选择。我们将通过 `ListPicker BeforePicking` 事件处理器来编程这一操作。
- en: In the Blocks pane, click ListPicker1 and drag the whenListPicker1.BeforePicking
    event handler block ➊ to the Viewer. Then, click ListPicker1 again and drag its
    setListPicker.Elementsto block ➋ into the whenListPicker1.BeforePicking block
    next to the word `do`. Next, in the Blocks pane, click the **Variables** blocks
    drawer, drag the get global level block ➌ in, and snap it to the right of the
    setListPicker1.Elementsto block. These three blocks create the `BeforePicking`
    event handler, which sets the problem level choices that the user will see when
    clicking `ListPicker1`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在方块面板中，点击 `ListPicker1`，然后将 `whenListPicker1.BeforePicking` 事件处理方块 ➊ 拖到查看器中。接着，再次点击
    `ListPicker1`，将它的 `setListPicker.ElementsTo` 方块 ➋ 拖入，并将其放置在 `whenListPicker1.BeforePicking`
    方块中 `do` 字样旁边。然后，在方块面板中，点击 **变量** 方块抽屉，拖动 `get global level` 方块 ➌ 进去，并将它连接到 `setListPicker1.ElementsTo`
    方块的右侧。这三个方块构成了 `BeforePicking` 事件处理器，用于设置用户在点击 `ListPicker1` 时将看到的题目级别选项。
- en: Finally, for the `whenScreen1.Initialize` event handler, which we already dragged
    to the Viewer for the original “Multiplication Station” app, we can leave all
    blocks the same, except for the string block that holds the argument for the `message`
    parameter of the `callTextToSpeech1.Speak` block. In that string block ➍, change
    the text to read Welcome to Multiplication Station! Choose your problem level
    to begin practicing. so users will hear that message when the app opens.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于`whenScreen1.Initialize`事件处理器，我们已经将其拖到原始“乘法站”应用的查看器中，除了持有`message`参数的字符串块外，我们可以保持所有块不变。在该字符串块➍中，将文本更改为“欢迎来到乘法站！选择您的问题级别开始练习。”这样，用户在打开应用时会听到这个消息。
- en: Live-test these event handlers with a device. When your “Multiplication Station
    II” app opens on your device, you should hear the welcome message. You also should
    see the Choose Your Level button on the screen, and when you click it, you should
    see the two choices, 1 and 2\. Right now, if you try to select either choice,
    nothing should happen. We’ll program that `AfterPicking` action next.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备上进行实时测试这些事件处理器。当您的“乘法站 II”应用在设备上打开时，您应该能听到欢迎消息。您还应该能看到屏幕上的“选择你的级别”按钮，当您点击它时，您应该能看到两个选择，1和2。目前，如果您尝试选择任何一个选项，什么也不会发生。我们接下来将编程该`AfterPicking`操作。
- en: If the app’s not working as described, debug and make sure you’ve created and
    placed your blocks correctly. When everything’s working, leave the app open on
    your device to keep live-testing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用未按描述的方式工作，请调试并确保您已正确创建并放置了块。当一切正常时，请保持应用在设备上打开以继续进行实时测试。
- en: '**STEP 2: STATING THE NUMBER OF SECONDS FOR EACH PROBLEM AND OPENING THE PRACTICE
    SCREEN**'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**步骤 2：声明每道题的秒数并打开练习屏幕**'
- en: Let’s use the `ListPicker AfterPicking` event to tell users how many seconds
    they have to answer each problem, depending on the level they selected. Then we’ll
    program the app to open the practice screen and transfer the value of the selected
    problem level to that screen. Here are the blocks that direct this action.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ListPicker AfterPicking`事件来告诉用户根据他们选择的级别，每道题的回答时间有多少秒。然后，我们将编程让应用程序打开练习屏幕，并将所选问题级别的值传递到该屏幕。以下是指引此操作的块。
- en: '![Image](../images/f0135-01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0135-01.jpg)'
- en: Let’s first program the app to speak after the user chooses a problem level.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们编程让应用程序在用户选择问题级别后发声。
- en: '**Telling the User the Time Limit**'
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**告诉用户时间限制**'
- en: In the Blocks pane, click ListPicker1 and drag the whenListPicker1.AfterPicking
    event handler block ➊ to the Viewer. Then, click TextToSpeech1 and drag its callTexttoSpeech1.Speak
    block ➋ into the whenListPicker1.AfterPicking block next to the word `do`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在“块”面板中，点击ListPicker1并将`whenListPicker1.AfterPicking`事件处理块➊拖到查看器中。然后，点击TextToSpeech1并将其`callTexttoSpeech1.Speak`块➋拖入`whenListPicker1.AfterPicking`块的`do`字样旁边。
- en: Next, to provide the argument for the `callTexttoSpeech1.Speak` block’s `message`
    parameter so the app will know what to say, drag a join block ➌ from the Text
    blocks drawer to the Viewer. Then add another string input to the join block and
    snap it to the right of the callTexttoSpeech1.Speak block next to the word `message`.
    This lets us join three strings together to form the `message` for `TextToSpeech1`.
    If the user selected problem level 1, we fill the `join` block’s inputs to set
    the `message` to You will have 5 seconds to answer each problem., and if the user
    selected problem level 2, we set the `message` to You will have 10 seconds to
    answer each problem.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了提供`callTexttoSpeech1.Speak`块的`message`参数所需的参数，让应用知道该说什么，从文本块面板拖动一个`join`块➌到查看器中。然后，向`join`块中添加另一个字符串输入，并将其拖到`callTexttoSpeech1.Speak`块的`message`旁边。这样，我们就可以将三个字符串组合在一起，形成`TextToSpeech1`的`message`。如果用户选择了问题级别1，我们将填充`join`块的输入，将`message`设置为“你将有5秒来回答每道题”；如果用户选择了问题级别2，我们将`message`设置为“你将有10秒来回答每道题”。
- en: To fill the `join` block’s top and bottom inputs, drag in two empty string blocks
    from the Text blocks drawer, click their text areas, and enter You will have (with
    a space after the word `have`) in the top string block ➍ and seconds to answer
    each problem (with a space before the word `seconds`) in the bottom ➎.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充`join`块的顶部和底部输入，从文本块面板中拖入两个空字符串块，点击它们的文本区域，并在顶部字符串块➍中输入“你将有”（`have`后留一个空格），在底部字符串块➎中输入“秒来回答每道题”（`seconds`前留一个空格）。
- en: Then, for the `join` block’s middle input, we need to add the number of seconds
    the user will have to answer each problem. We’ll get that value by directing the
    app to select the item from the `seconds` list that holds the same index position
    as the user’s `ListPicker` selection in the `level` list.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于`join`块的中间输入，我们需要添加用户回答每道题目所需的秒数。我们将通过让应用选择`seconds`列表中与用户在`level`列表中的`ListPicker`选择相同索引位置的项来获取该值。
- en: To program this, drag in a select list item block ➏ from the List blocks drawer
    and snap it into the join block’s middle input. Then, identify the list from which
    we want the app to select the item by clicking the **Variables** blocks drawer
    and dragging the get global seconds block ➐ into the select list item block’s
    list socket. Finally, identify the index position of the item selected from the
    `seconds` list by clicking ListPicker1 and dragging the ListPicker1.SelectionIndex
    block ➑ into the select list item block’s index socket.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要编程此功能，请从列表块抽屉中拖入一个选择列表项块 ➏，并将其放入`join`块的中间输入。接着，通过点击**变量**块抽屉，拖入获取全局秒数块 ➐，并将其放入选择列表项块的列表插槽，来确定我们希望应用选择的列表。最后，通过点击ListPicker1并拖入ListPicker1.SelectionIndex块
    ➑，将其放入选择列表项块的索引插槽，来确定从`seconds`列表中选择项的索引位置。
- en: '**Moving to the Practice Screen**'
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**进入练习屏幕**'
- en: Once the user selects a problem level, we’ll open `Screen2`, the practice screen,
    and pass the value the user selected in the `ListPicker` to that screen.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户选择了一个问题级别，我们将打开`Screen2`练习屏幕，并将用户在`ListPicker`中选择的值传递到该屏幕。
- en: '![Image](../images/f0136-01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0136-01.jpg)'
- en: In the Blocks pane, click the **Control** blocks drawer, drag in the open another
    screen with start value block ➊, and snap it inside the whenListPicker1.AfterPicking
    block under the `callTexttoSpeech1.Speak` block.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在Blocks窗格中，点击**控制**块抽屉，拖入“用起始值打开另一个屏幕”块 ➊，并将其放入`callTexttoSpeech1.Speak`块下的whenListPicker1.AfterPicking块中。
- en: This `open another screen with start value` block requires us to provide a `screenName`,
    the name of the screen we want to open (`Screen2`), and the `startValue` to pass
    to `Screen2` (the problem level the user selected in `ListPicker1`). To provide
    these values, in the Blocks pane, click the **Text** blocks drawer, drag in another
    empty string block ➋, and snap it into the `screenName` socket. Enter Screen2
    inside the empty string block to provide the name of the screen we want to open.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`用起始值打开另一个屏幕`块要求我们提供一个`screenName`，即我们想要打开的屏幕的名称（`Screen2`），以及要传递给`Screen2`的`startValue`（用户在`ListPicker1`中选择的题目级别）。为了提供这些值，在Blocks窗格中，点击**文本**块抽屉，拖入另一个空字符串块
    ➋，并将其放入`screenName`插槽。然后在空字符串块中输入Screen2，以提供我们想要打开的屏幕名称。
- en: Then, to identify the start value we want to pass to `Screen2`, click ListPicker1,
    drag in its ListPicker1.Selection block ➌, and snap it into the `startValue` socket.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了识别我们想要传递给`Screen2`的起始值，点击ListPicker1，将其ListPicker1.Selection块 ➌拖入，并将其连接到`startValue`插槽。
- en: Test to see how these blocks work. Once you open the app, you should hear the
    welcome message and see the Choose Your Level button. Once you click the button,
    you should see the numbers 1 and 2 as your choices. When you click the number
    1, you should hear the app say you have 5 seconds to answer each problem, and
    when you click 2, it should say you have 10 seconds. Then the app should take
    you to the practice screen.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这些块的功能。打开应用后，你应该会听到欢迎信息并看到“选择你的级别”按钮。点击按钮后，你应该会看到数字1和2作为选项。当你点击数字1时，你应该听到应用说你有5秒钟来回答每道题，而点击数字2时，它应该说你有10秒钟。然后，应用应该会将你带到练习屏幕。
- en: Let’s wait to test whether the app properly transfers the start value to the
    practice screen until after we program the next step. Make sure everything else
    you’ve programmed in the app is working as described, and leave it open on your
    phone for more live-testing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在编写下一步程序后，等待测试应用是否正确传递起始值到练习屏幕。确保你在应用中编程的其他部分按描述工作，并在手机上保持应用开启进行更多的实时测试。
- en: '**STEP 3: DISPLAYING THE PRACTICE PROBLEMS**'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**步骤3：显示练习题**'
- en: Just like the original “Multiplication Station” app, this app displays multiplication
    problems by joining one random integer (the value of global variable `a`), the
    multiplication operator (`×`), and another random integer (the value of global
    variable `b`). The app also gives users a set time interval to answer each problem.
    In this step, we’ll create the `setLevel` procedure that sets the values of `a`
    and `b` and the `Clock` timer interval value in each procedure call, depending
    on the problem level the user selected.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 就像原始的“乘法站”应用一样，这个应用通过将一个随机整数（全局变量`a`的值）、乘法符号（`×`）和另一个随机整数（全局变量`b`的值）连接起来，显示乘法问题。该应用还为用户提供了一个固定的时间间隔来回答每个问题。在这一步，我们将创建`setLevel`过程，根据用户选择的难度级别，设置`a`和`b`的值以及`Clock`计时器的时间间隔。
- en: 'We’ll make the `setLevel` procedure require arguments for five parameters:
    `a1`, `a2`, `b1`, `b2`, and `interval`. Parameters `a1` and `a2` set the random
    integer range for global variable `a`, the first random number in each multiplication
    problem, and parameters `b1` and `b2` set the random integer range for global
    variable `b`, the second random number. The `interval` parameter holds the time
    interval in milliseconds. Once `setLevel` receives these arguments in a procedure
    call, it sets global variable `a` to a random number ranging from `a1` to `a2`,
    sets global variable `b` to a random number ranging from `b1` to `b2`, and sets
    the `Clock` timer interval to `interval`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使`setLevel`过程需要五个参数：`a1`、`a2`、`b1`、`b2`和`interval`。参数`a1`和`a2`设置全局变量`a`的随机整数范围，这个数字是每个乘法问题中的第一个随机数；参数`b1`和`b2`设置全局变量`b`的随机整数范围，这个数字是每个乘法问题中的第二个随机数。`interval`参数则保存时间间隔，单位是毫秒。一旦`setLevel`在过程调用中接收到这些参数，它将把全局变量`a`设置为在`a1`和`a2`之间的随机数，将全局变量`b`设置为在`b1`和`b2`之间的随机数，并将`Clock`计时器的时间间隔设置为`interval`。
- en: Here’s what the `setLevel` procedure looks like.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`setLevel`过程的样子。
- en: '![Image](../images/f0137-01.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0137-01.jpg)'
- en: We’ll call `setLevel` inside an `if then` block to place the correct numbers
    in the multiplication problems and give the user the right amount of practice
    time based on the selected problem level.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个`if then`块中调用`setLevel`，以根据选择的难度级别，在乘法问题中填入正确的数字，并为用户提供适当的练习时间。
- en: '**Creating the setLevel Procedure**'
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建 setLevel 过程**'
- en: To make `setLevel`, click the **Procedures** block drawer in the `Screen2` Blocks
    pane, drag a to procedure do block ➊ to the Viewer, and click procedure to rename
    it by entering setLevel. This procedure block, like the global variables, will
    stand alone outside of all event handlers, allowing us to call the procedure within
    each event handler if we need to.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`setLevel`，请在`Screen2`块面板中点击**过程**块抽屉，将一个到过程执行块 ➊ 拖动到查看器中，然后点击过程并通过输入setLevel来重命名它。这个过程块与全局变量一样，将单独放在所有事件处理程序之外，如果需要，我们可以在每个事件处理程序内调用这个过程。
- en: Next, list the required procedure parameters by clicking the blue mutator icon
    to the left of the words `to setLevel` and dragging five input:x blocks to the
    inputs block in the dialog that opens. Rename them input:a1, input:a2, input:b1,
    input:b2, and input:interval.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过点击位于`to setLevel`左侧的蓝色变更图标，并将五个input:x模块拖动到弹出的对话框中的输入块，列出所需的过程参数。将它们重命名为input:a1、input:a2、input:b1、input:b2和input:interval。
- en: Now let’s program the action `setLevel` will perform. We’ll start with the blocks
    that set global variable `a` to a random number ranging from the argument provided
    for `a1` to the argument provided for `a2`. Click the **Variables** blocks drawer
    and drag a set global a block ➋ into the to setLevel block next to the word `do`.
    Then drag a random integer block ➌ from the Math drawer and snap it to the right
    of the set global a block. Fill the random integer block’s first socket by mousing
    over the procedure’s a1 parameter and dragging in a get a1 block ➍, and fill its
    second socket by mousing over the a2 parameter and dragging in a get a2 block
    ➎.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编程`setLevel`将执行的操作。我们将从设置全局变量`a`为一个在`a1`和`a2`之间随机选择的数字开始。点击**变量**块抽屉，将一个设置全局a块
    ➋ 拖动到`to setLevel`块旁的`do`字样位置。然后从数学块抽屉中拖动一个随机整数块 ➌，并将其连接到设置全局a块的右侧。通过将鼠标悬停在过程的a1参数上并拖入获取a1块
    ➍，将随机整数块的第一个插槽填充，再通过将鼠标悬停在a2参数上并拖入获取a2块 ➎，填充其第二个插槽。
- en: To set global variable b to a random number ranging from b1 to b2, simply repeat
    the process above for global variable b by copying the blocks at ➋ through ➎,
    and snapping the copy under the set global a block. Use the drop-down arrows to
    change global a to global b, a1 to b1, and a2 to b2.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要将全局变量b设置为从b1到b2的随机数，只需按照上述相同的过程，将全局变量b的相关块从➋到➎复制一遍，并将复制的块插入到set global a块下方。使用下拉箭头将全局a更改为全局b，a1更改为b1，a2更改为b2。
- en: Finally, to complete the `setLevel` procedure, we’ll set the `Clock`’s `TimerInterval`
    to the argument provided for `interval` in the procedure call. Click Clock1 in
    the Blocks pane and drag its setClock1.TimerIntervalto block ➏ into the to setLevel
    block under the set global b block. Then mouse over the procedure’s interval parameter
    and snap its get interval block ➐ to the right of the setClock1.TimerIntervalto
    block.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了完成`setLevel`过程，我们将设置`Clock`的`TimerInterval`为过程调用中提供的`interval`参数值。点击块面板中的Clock1，并将其setClock1.TimerIntervalto块
    ➏拖动到set global b块下的setLevel块中。然后将鼠标悬停在过程的interval参数上，并将其get interval块 ➐拖动到setClock1.TimerIntervalto块的右侧。
- en: '**Calling setLevel**'
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**调用setLevel**'
- en: We can now call `setLevel` in the `ClockTimer` event handler so that the app
    displays the correct problems for each level at the right time. The following
    code shows how we’ll call `setLevel` in a new `if then else` block within the
    `whenClock1.Timer` block, providing one set of arguments for the required parameters
    if the start value passed in from `Screen1` equals `1` and another set of arguments
    if it doesn’t.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在`ClockTimer`事件处理程序中调用`setLevel`，这样应用程序就能在正确的时间显示每个级别的正确问题。以下代码展示了如何在新的`if
    then else`块中调用`setLevel`，并在`whenClock1.Timer`块内提供一组参数值，如果从`Screen1`传递的起始值等于`1`，否则提供另一组参数值。
- en: '![Image](../images/f0138-01.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0138-01.jpg)'
- en: Here, we change the original “Multiplication Station” app’s `whenClock1.Timer`
    event handler block by replacing the global variable `a` and global variable `b`
    setter blocks at the top with an `if then else` block. Delete the two setters,
    drag an if then block ➊ to the Viewer from the Control blocks drawer, click the
    blue mutator icon to add an else input, and snap the if then else block inside
    the whenClock1.Timer block next to the word `do`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过将原本“Multiplication Station”应用程序中的`whenClock1.Timer`事件处理程序块中的全局变量`a`和全局变量`b`设置器块替换为`if
    then else`块来进行更改。删除这两个设置器块，拖动一个if then块 ➊从控制块抽屉中到查看器，点击蓝色变换器图标添加else输入，并将if then
    else块插入到whenClock1.Timer块中的`do`旁边。
- en: Now we’ll add blocks to test whether the start value passed in from `Screen1`
    equals `1`, which means that the user selected problem level 1 in the `ListPicker`
    on `Screen1`. Drag an = comparison block ➋ from the Math drawer and snap it into
    the if then else block’s if socket. Fill the = comparison block’s left operand
    socket with a get start value block ➌ from the Control drawer and its right operand
    socket with a 1 number block ➍.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加块来测试从`Screen1`传递的起始值是否等于`1`，这意味着用户在`Screen1`的`ListPicker`中选择了问题级别1。拖动一个=比较块
    ➋到数学抽屉中，并将其插入到if then else块的if插槽中。将=比较块的左操作数插槽填充为从控制抽屉中获取的get start value块 ➌，将右操作数插槽填充为1数字块
    ➍。
- en: The next blocks tell the app how to respond to the answer to that test condition,
    which is whether the start value equals `1`. If the answer is yes, we want the
    app to set the correct problems and time interval for level 1 problems. If the
    answer is no, we want the app to set the correct problems and time interval for
    level 2 problems. In each instance, we’ll direct the action with a call to the
    `setLevel` procedure.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的块告诉应用程序如何响应测试条件的答案，即起始值是否等于`1`。如果答案是是，我们希望应用程序设置级别1问题的正确问题和时间间隔。如果答案是否，我们希望应用程序设置级别2问题的正确问题和时间间隔。在每种情况下，我们都将通过调用`setLevel`过程来指引操作。
- en: To add the blocks for these procedure calls, click the **Procedures** drawer,
    drag one call setLevel block ➎, and snap it into the if then else block’s then
    socket. Then drag another call setLevel block ➏ and snap it into the if then else
    block’s else socket. Next, fill the parameter arguments for each call block with
    the values shown in [Table 7-1](ch07.xhtml#ch07tab1).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加这些过程调用的块，点击**Procedures**抽屉，拖动一个调用setLevel块 ➎并将其插入到if then else块的then插槽中。然后再拖动另一个调用setLevel块
    ➏并将其插入到if then else块的else插槽中。接下来，为每个调用块填充参数值，如[表7-1](ch07.xhtml#ch07tab1)所示。
- en: '**Table 7-1:** Setting Parameters for Calls to `setLevel`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-1：** 调用`setLevel`时设置的参数'
- en: '| if then else **block socket** | a1 | a2 | b1 | b2 | interval |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| if then else **块插槽** | a1 | a2 | b1 | b2 | interval |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| `then` | `1` | `12` | `1` | `12` | `5000` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `then` | `1` | `12` | `1` | `12` | `5000` |'
- en: '| `else` | `13` | `99` | `10` | `99` | `10000` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `else` | `13` | `99` | `10` | `99` | `10000` |'
- en: Each time the `Clock` timer fires, if the start value passed from the welcome
    screen equals `1` (`then`, user chose problem level 1), the app calls the `setLevel`
    procedure to set global variable `a` to a random number ranging from 1 to 12,
    set global variable `b` to a random number ranging from 1 to 12, and set the `Clock`
    timer interval to 5 seconds.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每次`Clock`定时器触发时，如果从欢迎界面传递的起始值等于`1`（`then`，用户选择了问题难度1），应用程序调用`setLevel`过程，将全局变量`a`设置为1到12之间的随机数，将全局变量`b`设置为1到12之间的随机数，并将`Clock`定时器间隔设置为5秒。
- en: If the start value passed from the welcome screen doesn’t equal `1` (`else`,
    user chose level 2), the app calls `setLevel` to set global variable `a` to a
    random number ranging from 13 to 99, set global variable `b` to a random number
    ranging from 10 to 99, and set the `Clock` timer interval to 10 seconds.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从欢迎界面传递的起始值不等于`1`（`else`，用户选择了难度2），应用程序调用`setLevel`过程，将全局变量`a`设置为13到99之间的随机数，将全局变量`b`设置为10到99之间的随机数，并将`Clock`定时器间隔设置为10秒。
- en: Now let’s switch to `Screen1` and test the completed app! When the welcome screen
    opens in your device, you should see the `ListPicker` and hear the welcome message.
    When you click Choose Your Level and make a selection, the app should tell you
    how many seconds you have to answer each problem. The practice screen should also
    open, and, if you chose level 1, problems should appear every 5 seconds, or, if
    you chose level 2, problems should appear every 10 seconds. Also, the problems
    should include numbers from the range expected for the selected problem level.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们切换到`Screen1`并测试已完成的应用！当欢迎界面在你的设备上打开时，你应该能看到`ListPicker`并听到欢迎消息。当你点击选择难度并做出选择时，应用应该告诉你回答每个问题需要多少秒。练习界面也应该打开，如果你选择了难度1，问题应该每5秒出现一次，或者如果你选择了难度2，问题应该每10秒出现一次。此外，问题的数字应该来自于所选问题难度级别的预期范围。
- en: If any part of the app isn’t working as planned, debug and try again. If you
    placed your blocks correctly, the app should work as expected, and you’ve successfully
    created “Multiplication Station II”!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用的任何部分没有按计划工作，请进行调试并重试。如果你正确放置了代码块，应用应该按预期运行，你就成功创建了“乘法车站 II”！
- en: '**SUMMARY**'
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you built the “Multiplication Station II” app, which builds
    on the original “Multiplication Station” app you created in [Chapter 4](ch04.xhtml#ch04)
    to let users choose the difficulty level of the problems and pass that choice
    from one screen to the next. Instead of having to use the same code blocks over
    and over again, you learned how to use a procedure to reuse the code that sets
    the problems and time limit. You also worked more with lists, `if then`, and relational
    operator blocks to control app flow.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你构建了“乘法车站 II”应用，它是在你在[第4章](ch04.xhtml#ch04)创建的原始“乘法车站”应用的基础上开发的，允许用户选择问题的难度级别，并将选择传递到下一个界面。你学会了如何使用过程来复用设置问题和时间限制的代码，而不是一遍遍使用相同的代码块。你还更多地使用了列表、`if
    then`和关系运算符块来控制应用的流程。
- en: In the next chapter, you’ll learn how to create apps that let users draw on
    the screen and drag images around. You’ll create the “Virtual Shades” app, where
    a user can take a selfie, “try on” a variety of sunglasses by dragging them into
    place over the picture, and draw and type on the picture with different-colored
    “ink.”
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何创建允许用户在屏幕上绘制并拖动图像的应用程序。你将创建“虚拟太阳镜”应用，用户可以拍摄自拍照，拖动不同款式的太阳镜放置到照片上，进行“试戴”，并在照片上用不同颜色的“墨水”绘制和输入文字。
- en: '**ON YOUR OWN**'
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**自行完成**'
- en: When you’re ready for a challenge, save new versions of your previous apps,
    and try these exercises. You can find solutions online at *[https://nostarch.com/programwithappinventor/](https://nostarch.com/programwithappinventor/)*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好挑战时，保存之前应用的最新版本，并尝试这些练习。你可以在 *[https://nostarch.com/programwithappinventor/](https://nostarch.com/programwithappinventor/)*
    在线找到解决方案。
- en: In “Multiplication Station II,” try adding a pause button to the practice screen
    so users can temporarily stop practicing when they need to. Write and call a procedure
    as part of this extension.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在《乘法车站 II》中，试着在练习界面添加一个暂停按钮，以便用户在需要时能够暂时停止练习。作为这个扩展的一部分，编写并调用一个过程。
- en: Write and call a procedure that changes the code you wrote in [Chapter 4](ch04.xhtml#ch04)
    to allow users to choose to practice multiplication or division problems.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写并调用一个过程，修改你在[第4章](ch04.xhtml#ch04)中写的代码，以允许用户选择练习乘法或除法题目。
