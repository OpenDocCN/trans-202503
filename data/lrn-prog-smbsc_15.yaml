- en: '**15**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**15**'
- en: '**GROUPING DATA IN ONE-DIMENSIONAL ARRAYS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**将数据分组在一维数组中**'
- en: '![image](graphics/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common01.jpg)'
- en: So far you’ve worked with variables to store single pieces of information, and
    you’ve created some pretty awesome programs. But you can create even more amazing
    programs by storing lots of information in a single variable! In Small Basic,
    you do that by using an array.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经使用变量存储单个信息片段，并创建了一些非常棒的程序。但是，通过将大量信息存储在单个变量中，您可以创建更令人惊叹的程序！在 Small
    Basic 中，您可以通过使用数组来实现这一点。
- en: An *array* is a built-in data type that lets you work with groups of data. For
    example, you wouldn’t build a separate closet for every pair of shoes you own
    (unless you’re a giant who loves shoe shopping); you’d put them all in one closet.
    Well, arrays let you store many pieces of data together to make it easier to work
    with them all at once. You can think of the closet as a one-dimensional array
    that contains a row of shoe boxes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组* 是一种内置数据类型，让您可以处理数据组。例如，您不会为您拥有的每双鞋子建立单独的衣柜（除非您是一个喜欢购鞋的巨人）；您会把它们都放在一个衣柜里。好吧，数组让您一起存储许多数据片段，以便更容易一次性处理它们。您可以将衣柜看作包含一排鞋盒的一维数组。'
- en: 'Small Basic has two types of arrays: indexed arrays and associative arrays.
    The pieces of data in an *indexed array* are referenced using an integer index,
    such as `score[1]`, `name[3]`, and so on. This is like putting a numbered label
    on each shoe box in your closet. But the elements of an *associative array* are
    referenced using a string index, such as `price["apple"]` or `address["John"]`.
    This chapter explores indexed arrays. We’ll cover associative arrays, also called
    *hashes* or *maps*, in the next chapter.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Small Basic 有两种类型的数组：索引数组和关联数组。*索引数组* 中的数据片段使用整数索引引用，例如 `score[1]`，`name[3]`
    等。这就像在衣柜里的每个鞋盒上贴上编号标签一样。但*关联数组* 的元素使用字符串索引引用，例如 `price["apple"]` 或 `address["John"]`。本章将探讨索引数组。我们将在下一章介绍关联数组，也称为*哈希*或*映射*。
- en: '**Getting Started with Indexed Arrays**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**开始使用索引数组**'
- en: Let’s say you want to write a program that takes four test scores from a user
    and then displays them along with their average value. Based on what you’ve learned
    so far, you might write a program like the one in [Listing 15-1](ch15.html#ch15ex1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想编写一个程序，从用户那里获取四个测试分数，然后显示这些分数以及它们的平均值。根据您目前所学的知识，您可能会编写类似于 [清单 15-1](ch15.html#ch15ex1)
    中的程序。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 15-1: Storing scores in separate variables*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-1：将分数存储在单独的变量中*'
- en: This program prompts the user to enter four scores (lines 2–3). It reads these
    scores and saves them in the four variables `s1`, `s2`, `s3`, and `s4` (lines
    4–7). Then it computes the average (line 8), displays the four numbers on a single
    line (lines 9–10), and displays the computed average (line 11).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序提示用户输入四个分数（第 2–3 行）。它读取这些分数并将它们保存在四个变量`s1`，`s2`，`s3`和`s4`中（第 4–7 行）。然后计算平均值（第
    8 行），在一行上显示这四个数字（第 9–10 行），并显示计算出的平均值（第 11 行）。
- en: 'Now imagine that you want a user to input 100 scores instead of 4\. Defining
    100 variables and copying almost the same statement 100 times would take a long
    time. Well, Small Basic’s array stores a collection of values. Using an array,
    you don’t have to create each variable separately. You can put all the values
    into one *array variable*. For example, you can read 10 scores a user enters and
    store them in one array using this loop:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，您希望用户输入 100 个分数而不是 4 个。定义 100 个变量并复制几乎相同的语句 100 次将花费很长时间。好吧，Small Basic
    的数组存储值的集合。使用数组，您不必单独创建每个变量。您可以将所有值放入一个*数组变量*中。例如，您可以读取用户输入的 10 个分数并将它们存储在一个数组中，使用以下循环：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Instead of creating 10 variables, like `s1`, `s2`, and so on to `s10`, you create
    one array variable called `score`. To refer to each piece of data in the `score`
    array, you use the syntax `score[N]`, where `N` is a variable that will take on
    the values 1 through 10\. Writing `score[N]` is like writing `score[1]`, `score[2]`,
    ..., `score[10]`, and the `For` loop increments `N` for you.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要创建 10 个变量，如`s1`，`s2`等到`s10`，而是创建一个名为`score`的数组变量。要引用`score`数组中的每个数据片段，您使用语法`score[N]`，其中`N`是一个将取值
    1 到 10 的变量。编写`score[N]`就像编写`score[1]`，`score[2]`，...，`score[10]`，而`For`循环会为您递增`N`。
- en: Run this code. After you enter 10 different numbers, Small Basic displays the
    `score` array, and you can see all 10 values stored in it (we’ll show you a better
    way to display an array later in this chapter).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码。在输入 10 个不同的数字后，Small Basic 显示`score`数组，并且您可以看到其中存储的所有 10 个值（我们将在本章后面展示更好的显示数组的方法）。
- en: One way to think of an array is as a collection of variables that share the
    same name. For example, the average rainfall in the 10 largest US cities could
    be saved in `rainLevel[1]` through `rainLevel[10]`, and the daily sales for the
    100 McDonalds in your area could be saved in `sales[1]` through `sales[100]`.
    Think of all the Happy Meals!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组看作是共享相同名称的一组变量。例如，美国十大城市的年平均降水量可以保存在`rainLevel[1]`到`rainLevel[10]`中，而你所在地区100家麦当劳的日销售额可以保存在`sales[1]`到`sales[100]`中。想象一下所有的快乐儿童餐！
- en: Arrays can help you organize your data in a way that makes the data much easier
    to change and use. The name of an array follows the same rules and guidelines
    you use for naming variables.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以帮助你以一种方式组织数据，使得数据更容易修改和使用。数组的命名遵循与你为变量命名时相同的规则和指导原则。
- en: '**Array Basics**'
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数组基础**'
- en: 'Each piece of information in an array is called an *element*. To access an
    element in an array, you use this syntax:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的每个信息单元称为*元素*。要访问数组中的一个元素，你可以使用以下语法：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `arrayName` variable is the array’s name, and `index` is an identifier,
    either a number or a string, that identifies an element in the array (see [Figure
    15-1](ch15.html#ch15fig1)). This syntax is known as an *indexed variable*, or
    a *subscripted variable*. The index, which is placed between square brackets,
    uniquely identifies one element in the array.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`arrayName`变量是数组的名称，`index`是一个标识符，可以是数字或字符串，用于标识数组中的元素（参见[图15-1](ch15.html#ch15fig1)）。这种语法被称为*带索引的变量*，或*下标变量*。索引位于方括号中，唯一标识数组中的一个元素。'
- en: '![image](graphics/f15-01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f15-01.jpg)'
- en: '*Figure 15-1: Graphical representation of a one-dimensional array*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-1：一维数组的图形表示*'
- en: 'You can treat an indexed variable just like a regular variable by using the
    proper syntax. For example, the following statements initialize and display the
    first three elements of the `score` array in [Figure 15-1](ch15.html#ch15fig1):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像对待常规变量一样，通过使用正确的语法来处理带有索引的变量。例如，下面的语句会初始化并显示`score`数组中前面三个元素，如[图15-1](ch15.html#ch15fig1)所示：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you run this code, you’ll see this output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，你将看到以下输出：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you wanted to change the first score, you could write this statement:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想改变第一个成绩，你可以写下如下语句：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This line of code adds five to the first `score` at index 1\. If you displayed
    the value of `score` now, you’d see that `score[1] = 85`. You could use the next
    statement to multiply the two elements at indices 1 and 2:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将5加到索引为1的第一个`score`上。如果你现在显示`score`的值，你会看到`score[1] = 85`。你可以使用下一条语句来将索引1和2的两个元素相乘：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If `score[1]` is 80 and `score[2]` is 85, they are multiplied to get 6,800,
    which is saved back into `score[1]`. High score!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`score[1]`是80，`score[2]`是85，它们相乘得到6800，并将结果保存回`score[1]`。高分！
- en: '**Initializing Arrays**'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**初始化数组**'
- en: 'Before using an array in your program, you need to fill it up (or initialize
    it) with some data. In Small Basic, you can do this in two ways: by direct (element-by-element)
    initialization or string initialization.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中使用数组之前，你需要先为它填充（或初始化）一些数据。在Small Basic中，你可以通过两种方式来做到这一点：直接的（逐个元素）初始化或字符串初始化。
- en: 'Let’s say you want to create an array that holds four scores (not the Abe Lincoln
    type). Here’s the direct way to do this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想创建一个包含四个成绩的数组（不是阿布·林肯那种类型的）。这里是直接做法：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also use a *string initializer*, which allows you to set the four values
    in just one line like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用*字符串初始化器*，它允许你仅用一行代码设置四个值，如下所示：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This string initializer has four tokens (or fields), which are terminated by
    semicolons. Each token is in this form (and no, you can’t exchange these tokens
    for prizes):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符串初始化器有四个标记（或字段），它们以分号结束。每个标记的形式如下（不，你不能用这些标记换取奖品）：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, the first token is `1=80`, the second is `2=85`, the third
    is `3=90`, and the fourth is `4=95`. The number before the equal sign is the element’s
    index, and the value after the equal sign is the value stored in that element.
    Note that there are no spaces before or after the equal sign. [Figure 15-2](ch15.html#ch15fig2)
    shows you how this string initializer works.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，第一个标记是`1=80`，第二个是`2=85`，第三个是`3=90`，第四个是`4=95`。等号前面的数字是元素的索引，等号后面的数字是存储在该元素中的值。注意等号前后没有空格。[图15-2](ch15.html#ch15fig2)展示了这个字符串初始化器的工作原理。
- en: '![image](graphics/f15-02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f15-02.jpg)'
- en: '*Figure 15-2: The syntax of an array’s string initializer*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-2：数组字符串初始化器的语法*'
- en: The string initializer lets you fill an array in one statement, but its syntax
    is a bit complex, and you could accidentally introduce errors in your code. Until
    you become more comfortable with arrays, we recommend that you stick to the basic
    element-by-element initialization technique in your programs. But if you do use
    the string initializer and run into problems, try reinitializing your array one
    element at a time. We’ll use both initialization types in this book, to save space
    and to get you more familiar with them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串初始化器允许你在一条语句中填充数组，但其语法有些复杂，且可能不小心引入代码错误。在你更加熟悉数组之前，我们建议你在程序中坚持使用基本的逐个元素初始化方法。不过，如果你使用了字符串初始化器并遇到问题，可以尝试逐个元素地重新初始化数组。本书中将同时使用这两种初始化方法，以节省空间并帮助你更好地掌握它们。
- en: '**NOTE**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Small Basic lets you choose any numbers you want for indices. It even lets
    you use negative and decimal numbers, and it doesn’t require the indices to be
    consecutive. But in this book we’ll always use integer indices starting from 1
    for the first array element.*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*Small Basic允许你为索引选择任何你想要的数字。它甚至允许使用负数和小数，并且不要求索引是连续的。但在本书中，我们将始终使用从1开始的整数索引来表示第一个数组元素。*'
- en: Arrays and `For` loops are often used together. When the size of an array is
    known, you can use a `For` loop to cycle through and perform operations on every
    element in that array. The next examples show you how to use `For` loops to perform
    operations on arrays.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和`For`循环经常一起使用。当数组的大小已知时，你可以使用`For`循环遍历数组并对每个元素执行操作。接下来的示例展示了如何使用`For`循环对数组执行操作。
- en: '**TRY IT OUT 15-1**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试示例 15-1**'
- en: Suppose that the elements in array `S` and variables `A` and `B` have the values
    in [Figure 15-3](ch15.html#ch15fig3). What is `S[A], S[B], S[A * B - 2], S[A +
    B]`, and `S[A] - 2 * S[B]`?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 假设数组`S`中的元素以及变量`A`和`B`的值如[图 15-3](ch15.html#ch15fig3)所示。那么`S[A]`、`S[B]`、`S[A
    * B - 2]`、`S[A + B]`和`S[A] - 2 * S[B]`的值分别是多少？
- en: '![image](graphics/f15-03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f15-03.jpg)'
- en: '*Figure 15-3: Values in* `S` *array and variables* `A` *and* `B`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-3: `S`数组及变量`A`和`B`中的值*'
- en: '**Filling Arrays with a For Loop**'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用For循环填充数组**'
- en: Many times you’ll need to fill the elements of an array with a constant value,
    a random value, a value calculated from a formula, or a value entered by a user.
    Let’s look at each scenario!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，你需要使用常量值、随机值、通过公式计算的值或用户输入的值来填充数组的元素。让我们来看每种情况！
- en: '***Constant Initialization***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***常量初始化***'
- en: The following code snippet shows how to initialize the first 10 elements of
    a tasty array (named `scoobySnack`) with a constant value of 0.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何使用常量值0初始化一个美味的数组（名为`scoobySnack`）的前10个元素。
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `For` loop repeats 10 times. In the first iteration, the value of `N` is
    1, so the loop sets `scoobySnack[1] = 0`. In the second iteration, the value of
    `N` is 2, so the loop sets `scoobySnack[2] = 0`, and so on. This creates an array
    with 10 elements, all of which are 0.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`For`循环执行10次。在第一次迭代中，`N`的值为1，因此循环将`scoobySnack[1] = 0`。在第二次迭代中，`N`的值为2，因此循环将`scoobySnack[2]
    = 0`，依此类推。这样就创建了一个包含10个元素的数组，所有元素的值都为0。'
- en: '***Random Initialization***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***随机初始化***'
- en: 'You can also fill the elements of the `scoobySnack` array with random numbers,
    like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过随机数填充`scoobySnack`数组的元素，如下所示：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `For` loop iterates 10 times. In the `N`th iteration, the element at index
    `N`, `scoobySnack[N]`, is assigned a random number between 1 and 5\. Try displaying
    the value of `scoobySnack` to see what random numbers you get! Add the following
    statement after you set `scoobySnack[N]` inside the `For` loop:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`For`循环迭代10次。在第`N`次迭代中，索引为`N`的元素`scoobySnack[N]`将被赋值为1到5之间的随机数。试着显示`scoobySnack`的值，看看你得到的随机数！在`For`循环中设置`scoobySnack[N]`之后，添加以下语句：'
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***Formula Initialization***'
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***公式初始化***'
- en: 'You can also initialize the elements of an array using a formula. In this example,
    you’ll set the `N`th element of the `scoobySnack` array to `N * 8`; this code
    will store the multiplication table of eight in your array:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用公式初始化数组的元素。在此示例中，你将把`scoobySnack`数组的第`N`个元素设置为`N * 8`；这段代码将把8的乘法表存储在数组中：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Add the code that displays the value of `scoobySnack` to see the results!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 添加代码以显示`scoobySnack`的值，查看结果！
- en: '***User Initialization***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***用户初始化***'
- en: What if you want to initialize the elements of your array using values entered
    by a user? The following program prompts the user to enter five numbers and press
    ENTER after each number. The program then starts a `For` loop to read the five
    numbers and store them in `thunderCat[1]`, `thunderCat[2]`, ..., `thunderCat[5]`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用用户输入的值来初始化数组的元素呢？以下程序提示用户输入五个数字，并在每个数字后按下ENTER键。然后程序开始一个`For`循环，读取这五个数字并将它们存储在`thunderCat[1]`、`thunderCat[2]`、...、`thunderCat[5]`中。
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This technique is very useful for storing lots of data from a user. What other
    collections of data might you ask for? How about `breakfastMenu`, `favoriteGames`,
    `bestPasswords`, `funnyJokes`, or `frozenNames`?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术对于存储用户输入的海量数据非常有用。你还会请求哪些其他的数据集合呢？比如`breakfastMenu`、`favoriteGames`、`bestPasswords`、`funnyJokes`或`frozenNames`？
- en: '**TRY IT OUT 15-2**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**动手实践 15-2**'
- en: Write a program that fills an array called `skeletor` with even integers from
    20 to 40 (for example, `skeletor[1] = 20, skeletor[2] = 22`, ...).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，将一个名为`skeletor`的数组填充从20到40之间的偶数（例如，`skeletor[1] = 20, skeletor[2] = 22`，...）。
- en: '**Displaying Arrays**'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**显示数组**'
- en: 'Let’s say we have an array named `age` that holds the ages of three brothers,
    like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`age`的数组，保存了三兄弟的年龄，像这样：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can display the contents of this array in two ways. The first and easiest
    way is to pass the array’s name to the `WriteLine()` method, like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式显示这个数组的内容。第一种也是最简单的方式是将数组的名称传递给`WriteLine()`方法，像这样：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here’s the output of this statement:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个语句的输出：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This statement displays the elements of the array on a single line separated
    by semicolons. Each token in this string shows the index and the value of the
    array’s element at that index. Can you see now where the array’s string initializer
    syntax came from?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句将在一行内显示数组的元素，每个元素之间用分号隔开。这个字符串中的每个标记显示了数组元素的索引和值。你现在能看出数组的字符串初始化语法是从哪里来的了吗？
- en: 'If you want to display the array in an easier-to-read format, you can use a
    `For` loop to display each element of the array in its own row:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想以更易读的格式显示数组，可以使用`For`循环将数组的每个元素显示在单独的一行中：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here’s the output of this loop:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个循环的输出：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you’re working with a short array, it’s fine to display it on a single line.
    But if you’re working with a lot of data, it’s best to display the array in a
    format that’s easy to read.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你处理的是一个较短的数组，显示在一行上没问题。但如果你处理的是大量数据，最好以易于阅读的格式显示数组。
- en: '**TRY IT OUT 15-3**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**动手实践 15-3**'
- en: Write a program that fills an array called `burps` with five random numbers
    between 80 and 100 and then displays the array. Try displaying the array by passing
    the array’s name to `TextWindow.WriteLine()` and then by using a `For` loop. Which
    looks nicer?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，将一个名为`burps`的数组填充五个介于80到100之间的随机数，并显示这个数组。尝试通过将数组的名称传递给`TextWindow.WriteLine()`来显示数组，然后再通过使用`For`循环来显示数组。哪种方式看起来更好？
- en: '**Processing Arrays**'
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**处理数组**'
- en: Many programs involve processing the elements of an array, such as adding them
    and finding their average, minimum, maximum, and so on. You’ll learn how to do
    these tasks in this section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序涉及处理数组的元素，例如对它们进行求和、找出它们的平均值、最小值、最大值等。你将在本节中学习如何执行这些任务。
- en: '***Finding the Sum***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查找总和***'
- en: 'A superhero named Super Here-O wants to know how much money he rescued from
    10 robbers in his town. The following program lets Super Here-O enter the amounts
    he rescued into an array named `moneyReturned`. The program finds the sum of all
    the elements of this array:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一位名叫Super Here-O的超级英雄想知道他从镇上的10个强盗手中救回了多少钱。以下程序让Super Here-O将他救回的金额输入到一个名为`moneyReturned`的数组中。程序会计算该数组中所有元素的总和：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To find the sum, you start by initializing the `sum` variable to 0\. You then
    run a `For` loop to read each element of the `moneyReturned` array and add it
    to the `sum` variable. When the loop terminates, you start another loop to show
    how much money was rescued from each robber, and then you display the total amount
    returned. Run the program to find out whether it’s enough money to buy a new superhero
    spandex suit!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算总和，首先将`sum`变量初始化为0。然后，运行一个`For`循环，读取`moneyReturned`数组的每个元素并将其加到`sum`变量中。当循环结束时，开始另一个循环，显示每个强盗被救回的金额，然后显示总金额。运行程序，看看这些钱是否足够买一套新的超级英雄紧身衣！
- en: '***Finding the Maximum Element***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查找最大元素***'
- en: 'Say you’re competing with nine of your good friends to see who has the most
    friends on Facebook. Use the following code snippet to find the largest value
    in an array named `friends`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在和九个好朋友竞争，看看谁在 Facebook 上有最多的朋友。使用以下代码片段找到名为 `friends` 的数组中的最大值：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, we filled the 10 elements of the `friends` array with the number of Facebook
    friends that you and your nine closest friends have. In this example, your first
    friend has 10 friends, your second friend has 30, your third friend has 5, and
    so on, and you (number 10 in the array) have 11 friends. Feel free to change these
    numbers. The program starts by assuming that the first element, `friends[1]`,
    is the largest. It then enters a loop that examines the remaining elements of
    the array, starting at the second element. Every time it finds a number larger
    than the current maximum, it updates the maximum, `max`, to that number. When
    the loop terminates, the maximum value displays.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们填充了 `friends` 数组中的 10 个元素，表示你和你九个最亲密的朋友在 Facebook 上的朋友数量。在这个示例中，你的第一个朋友有
    10 个朋友，第二个朋友有 30 个，第三个朋友有 5 个，以此类推，你（数组中的第 10 个）有 11 个朋友。你可以随意更改这些数字。程序开始时假设第一个元素
    `friends[1]` 是最大的。然后它进入一个循环，检查数组中剩下的元素，从第二个元素开始。每次找到一个大于当前最大值的数字时，它会更新最大值 `max`。当循环结束时，最大值会被显示出来。
- en: '**Using String Values in Arrays**'
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在数组中使用字符串值**'
- en: 'Arrays aren’t restricted to numbers. You can also use arrays to store strings.
    Let’s say, for example, that you want to create an array to store the names of
    the books in your collection. You could initialize this array:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 数组不仅仅局限于数字，你也可以使用数组来存储字符串。例如，假设你想创建一个数组，用来存储你收藏书籍的名称。你可以像这样初始化这个数组：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**NOTE**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You could also use a string initializer to initialize the* `book` *array like
    this (make sure the entire statement is on one line):*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*你也可以使用字符串初始化器来初始化* `book` *数组，像这样（确保整个语句在一行内）：*'
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**TRY IT OUT 15-4**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**试一试 15-4**'
- en: 'Write a program that fills two arrays (`noun` and `verb`) with plural nouns
    and verbs of your choice. Have the program display random sentences in this form:
    `noun verb noun` (for example, dogs delight cats).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，填充两个数组（`noun` 和 `verb`），存储你选择的复数名词和动词。让程序以这种形式显示随机句子：`noun verb noun`（例如，dogs
    delight cats）。
- en: '**Saving Records**'
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**保存记录**'
- en: 'You can mix different data types within a single array. You can store numbers,
    both whole and decimal, and strings as different elements in the same array. For
    example, the following array is valid (do you know this building?):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一个数组中混合不同的数据类型。你可以存储数字（整数和小数）和字符串作为数组中的不同元素。例如，以下数组是有效的（你知道这座建筑吗？）：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first and third elements of this array are numbers. The second element is
    a string. These three elements could represent a home’s number, its street name,
    and its ZIP code, respectively. This is one way to create a *record*, which is
    a collection of related pieces of data, in Small Basic.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组的第一个和第三个元素是数字，第二个元素是字符串。这三个元素可以分别代表一个家的号码、街道名称和邮政编码。这是创建一个*记录*的方式，记录是一个包含相关数据片段的集合，在
    Small Basic 中就是这样。
- en: Whew! Well, we’ve covered more than enough to solve oodles of problems. Now
    let’s spend some time writing fun programs!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！好吧，我们已经学习了足够的内容来解决大量的问题。现在让我们花些时间写些有趣的程序吧！
- en: '**Using Indexed Arrays**'
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用索引数组**'
- en: The first example in this section shows you how to select random elements from
    an array. The second example simulates a Magic 8 Ball game in which the computer
    provides randomly selected answers to a player’s questions. Let’s get random!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的第一个示例展示了如何从数组中选择随机元素。第二个示例模拟了一个魔法8号球游戏，计算机会随机选择答案来回应玩家的问题。让我们来进行随机选择吧！
- en: '***Random Selection***'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***随机选择***'
- en: Let’s say we have a bag that contains 10 balls numbered 1 through 10, and we
    want to take out five random balls (see [Figure 15-4](ch15.html#ch15fig4)). We’ll
    write a program that randomly selects five balls and then displays their numbers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个袋子，里面装有编号从 1 到 10 的 10 个球，我们要从中随机取出五个球（见 [图 15-4](ch15.html#ch15fig4)）。我们将编写一个程序，随机选择五个球，然后显示它们的编号。
- en: '![image](graphics/f15-04.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f15-04.jpg)'
- en: '*Figure 15-4: Randomly selecting five balls from a bag*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-4：从袋子中随机选择五个球*'
- en: To create this program, we’ll use an array named `ball` to hold the numbers
    of the 10 balls (`ball[1] = 1`, `ball[2] = 2`, …, `ball[10] = 10`). Then the program
    selects a random number between 1 and 10 to pick a ball. For example, if it picks
    number 2, it sets `ball[2] = 0` to indicate that the second ball has been selected
    and is no longer available. Then it selects another random number. Let’s say that
    the second number is also 2\. First, the program checks `ball[2]`. Because it’s
    0, it knows that `ball[2]` has already been selected (you can’t take the same
    ball out of the bag twice!), and it picks another random number. It continues
    this until it selects five different random numbers. The complete program is shown
    in [Listing 15-2](ch15.html#ch15ex2).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这个程序，我们将使用一个名为`ball`的数组来存储 10 个球的号码（`ball[1] = 1`，`ball[2] = 2`，...，`ball[10]
    = 10`）。然后程序随机选择一个 1 到 10 之间的数字来挑选一个球。例如，如果它选中了 2，那么它会将`ball[2] = 0`，表示第二个球已经被选中并且不再可用。然后它会选择另一个随机数。假设第二个数字也是
    2。首先，程序检查`ball[2]`。由于它是 0，程序知道`ball[2]`已经被选中了（你不能把同一个球从袋子里拿出来两次！），所以它会选择另一个随机数。它会继续这样，直到选出五个不同的随机数。完整的程序请参见[清单
    15-2](ch15.html#ch15ex2)。
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 15-2: Randomly selecting five different balls*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-2：随机选择五个不同的球*'
- en: 'The program starts by setting `ball[1] = 1`, `ball[2] = 2`, ..., `ball[10]
    = 10` in a `For` loop (lines 2–4). It then begins a loop to select the five balls
    (line 6). In each iteration of the loop, it picks a random number, `idx`, between
    1 and 10 (line 7). A `While` loop continually sets `idx` until `ball[idx]` is
    not 0 (lines 8–10). After selecting a unique ball number, the program displays
    the number (line 12), and then it marks that ball as selected by setting its array
    element to 0 (line 13) so it doesn’t try to select that number again. Here’s a
    sample run of this program:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 程序首先通过`For`循环设置`ball[1] = 1`，`ball[2] = 2`，...，`ball[10] = 10`（第 2–4 行）。然后它开始一个循环来选择五个球（第
    6 行）。在每次循环迭代中，它选择一个 1 到 10 之间的随机数`idx`（第 7 行）。一个`While`循环不断设置`idx`，直到`ball[idx]`不为
    0（第 8–10 行）。在选择一个唯一的球号后，程序会显示该号码（第 12 行），然后通过将该球的数组元素设置为 0 来标记它已被选中（第 13 行），以避免再次选择该号码。下面是该程序的一个示例运行：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Run the program to see which numbers you get!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序，看看你会得到哪些数字！
- en: '***A Magic 8 Ball***'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***魔术 8 球***'
- en: In this example, we’ll write a program that simulates a Magic 8 Ball game. A
    user asks a yes or no question, and the computer answers. Of course, it’s just
    for fun, so don’t use it to make important decisions like choosing your spouse
    or house! The complete program is shown in [Listing 15-3](ch15.html#ch15ex3).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将编写一个模拟魔术 8 球游戏的程序。用户提出一个是或否的问题，计算机会给出答案。当然，这只是为了好玩，所以不要用它来做重要决策，比如选择配偶或房子！完整的程序请参见[清单
    15-3](ch15.html#ch15ex3)。
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 15-3: A Magic 8 Ball simulation*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-3：魔术 8 球模拟*'
- en: The game has 10 possible answers saved in the `ans` array. After initializing
    the array (lines 2–11), the game starts an infinite loop to interact with the
    user. In each iteration it asks the user to enter a yes or no question. It reads
    the user’s question (line 15), generates a random number between 1 and 10 (line
    16), and uses that number to display one of the answers using `ans[num]` (line
    17). After displaying the message, we display a blank line (line 18). For someone
    who doesn’t know the trick, the computer might look intelligent! Ask your friends
    to play this game, and see what they think.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏有 10 个可能的答案保存在`ans`数组中。在初始化数组（第 2–11 行）之后，游戏启动一个无限循环与用户互动。在每次循环中，游戏都会询问用户输入一个是或否的问题。它读取用户的问题（第
    15 行），生成一个 1 到 10 之间的随机数（第 16 行），并使用这个数字通过`ans[num]`显示一个答案（第 17 行）。显示完信息后，我们会显示一个空白行（第
    18 行）。对于那些不了解窍门的人，计算机看起来可能很聪明！邀请你的朋友玩这个游戏，看看他们怎么说。
- en: How’re you feeling? Sharp as a sponge and fresh as a tack? Great, because it’s
    game creation time!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你感觉怎么样？像海绵一样敏锐，像钉子一样新鲜？太好了，因为现在是游戏创建时间！
- en: '**TRY IT OUT 15-5**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试一下 15-5**'
- en: Modify the Magic 8 Ball game so it shows each answer only once. End the game
    when all the answers have been displayed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 修改魔术 8 球游戏，使其每个答案只显示一次。当所有答案都显示完时结束游戏。
- en: '**Create the Catch Apples Game**'
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建抓苹果游戏**'
- en: '[Figure 15-5](ch15.html#ch15fig5) shows a game in which apples appear in random
    positions at the top of the graphics window at random times and fall to the ground.
    The player has to move the cart using the mouse to catch the apples before they
    hit the ground. Each apple is worth 1 point. Don’t worry about bruising the apples;
    they’re hard core!'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-5](ch15.html#ch15fig5)显示了一个游戏，在图形窗口的顶部随机位置和时间出现苹果，然后掉落到地面。玩家需要通过鼠标移动手推车，抓住掉落的苹果，避免它们掉到地面。每个苹果值1分。别担心苹果会被撞坏，它们是硬核的！'
- en: '![image](graphics/f15-05.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f15-05.jpg)'
- en: '*Figure 15-5: The Catch Apples game*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-5：捉苹果游戏*'
- en: Follow these steps to put this great game together one piece at a time.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤，一步一步将这个精彩的游戏拼凑在一起。
- en: '***Step 1: Open the Startup File***'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 1：打开启动文件***'
- en: Open the file *CatchApples_Incomplete.sb* in this chapter’s folder. The folder
    also has all the images you’ll need for this program. The startup file contains
    the main code (shown in [Listing 15-4](ch15.html#ch15ex4)) and empty placeholders
    for the four subroutines that you’ll write. Let’s start with the main code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 打开本章文件夹中的文件*CatchApples_Incomplete.sb*。文件夹中还包含了你需要的所有图像。启动文件包含主代码（见[示例 15-4](ch15.html#ch15ex4)）和四个子程序的空占位符，你将编写这些子程序。我们从主代码开始。
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 15-4: The main code for the Catch Apples game*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 15-4：捉苹果游戏的主代码*'
- en: In lines 2–7, we set the graphic window’s title; size, to match the size of
    the background image; font size; and font color. Then we draw the background image
    (line 10) and create the text shape that displays the number of caught and dropped
    apples (lines 12–13). The `MAX_APPLES` variable in line 15 is the maximum number
    of apples that will appear in the graphics window. Once you get the game running,
    experiment with this number to make the game easier or harder.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2–7行中，我们设置了图形窗口的标题；大小与背景图像的大小匹配；字体大小；以及字体颜色。然后，我们绘制背景图像（第10行），并创建显示捕捉和掉落苹果数量的文本形状（第12–13行）。第15行中的`MAX_APPLES`变量是将出现在图形窗口中的最大苹果数量。一旦游戏运行起来，你可以调整这个数字来让游戏更容易或更难。
- en: Line 16 calls the `AddApples()` subroutine to create the array that will hold
    the falling apples. Line 18 adds the cart’s image and saves its identifier in
    `cartImg`; we need this identifier to move the cart.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第16行调用`AddApples()`子程序来创建将保存掉落苹果的数组。第18行添加手推车的图像，并将其标识符保存在`cartImg`中；我们需要这个标识符来移动手推车。
- en: Lines 20–21 initialize the variables `numMissed` (the number of missed apples)
    and `numCaught` (the number of caught apples) to 0\. The code then starts the
    game’s main loop (lines 23–27). In each iteration, we move the cart so its center
    lines up with the mouse’s x position (line 24). Because the cart’s width is 100
    pixels, the cart’s left position is set to `MouseX – 50`. The cart’s y-position
    is fixed. We call the `MoveApples()` subroutine to make apples fall and check
    whether they touch the cart or the ground (line 25); then we wait 5 milliseconds
    before repeating these steps (line 26). But don’t tell your dad to wait 5 milliseconds,
    or he might think you’re sassing!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第20–21行初始化了`numMissed`（错过的苹果数量）和`numCaught`（捕获的苹果数量）变量为0。然后，代码启动了游戏的主循环（第23–27行）。在每次迭代中，我们移动手推车，使其中心与鼠标的x位置对齐（第24行）。由于手推车的宽度是100像素，手推车的左侧位置设置为`MouseX
    – 50`。手推车的y位置是固定的。我们调用`MoveApples()`子程序让苹果掉落，并检查它们是否碰到手推车或地面（第25行）；然后我们等待5毫秒，再重复这些步骤（第26行）。不过不要告诉你爸爸等5毫秒，否则他可能以为你在顶嘴！
- en: Run the game now, and move the mouse. The cart follows the mouse, but no apples
    appear yet. You’ll add the missing subroutines next to finish the game.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行游戏，并移动鼠标。手推车会跟随鼠标，但苹果还没有出现。接下来，你将添加缺失的子程序来完成游戏。
- en: '***Step 2: Add the Apples***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 2：添加苹果***'
- en: Add the `AddApples()` subroutine in [Listing 15-5](ch15.html#ch15ex5).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 15-5](ch15.html#ch15ex5)中添加`AddApples()`子程序。
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 15-5: The* `AddApples()` *subroutine*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 15-5：`AddApples()`子程序*'
- en: The subroutine uses a `For` loop to create the five apples. In each iteration,
    we call `AddImage()` to load the apple’s image from the game’s folder and save
    the returned identifier in the `apple` array (line 3). The first apple is saved
    in `apple[1]`, the second apple is saved in `apple[2]`, and so on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子程序使用`For`循环来创建五个苹果。在每次迭代中，我们调用`AddImage()`从游戏文件夹加载苹果的图像，并将返回的标识符保存在`apple`数组中（第3行）。第一个苹果保存在`apple[1]`，第二个苹果保存在`apple[2]`，以此类推。
- en: To add some variety to the apple game, we’ll change the sizes of the apples.
    In line 4, we set the `scale` variable to a random value from the set {0.4, 0.5,
    0.6, 0.7, 0.8}, which is calculated by `(3 + Math.GetRandomNumber(5)) / 10`. In
    line 5, we pass that value to the `Zoom()` method to change the apple’s size.
    This sets the apple’s size to a fraction (between 40 and 80 percent) of its original
    size.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加游戏的多样性，我们将改变苹果的大小。在第 4 行，我们将 `scale` 变量设置为来自集合 {0.4, 0.5, 0.6, 0.7, 0.8}
    的随机值，计算方式为 `(3 + Math.GetRandomNumber(5)) / 10`。在第 5 行，我们将这个值传递给 `Zoom()` 方法来改变苹果的大小。这样，苹果的大小将是其原始大小的一个比例（介于
    40% 到 80% 之间）。
- en: Next, we’ll call the `SetApplePosition()` subroutine to position the new apple.
    Let’s examine what this subroutine does.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将调用 `SetApplePosition()` 子程序来定位新的苹果。让我们看看这个子程序是如何工作的。
- en: '***Step 3: Position the Apples***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 3：定位苹果***'
- en: Add the `SetApplePosition()` subroutine in [Listing 15-6](ch15.html#ch15ex6).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 15-6](ch15.html#ch15ex6)中添加 `SetApplePosition()` 子程序。
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 15-6: The* `SetApplePosition()` *subroutine*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-6：* `SetApplePosition()` *子程序*'
- en: We set the horizontal position to a random integer between 1 and 420 (line 2)
    and the vertical position to a negative value between –1 and –500 (line 3). The
    call to `Move()` in line 4 puts the apple (at index `aplNum` in the `apple` array)
    at some invisible point above the top edge of the graphics window using the two
    numbers `xPos` and `yPos`. This way, when the apples start falling, they appear
    at the top of the screen at random times; the apple that was placed at `yPos =
    –100` appears sooner than the one placed at `yPos = –500` because it has less
    distance to fall. As you’ll see in a moment, we’ll also call this subroutine when
    the player catches or misses an apple.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将水平位置设置为 1 到 420 之间的随机整数（第 2 行），将垂直位置设置为 -1 到 -500 之间的负值（第 3 行）。在第 4 行调用 `Move()`
    将苹果（在 `apple` 数组中索引为 `aplNum` 的元素）放置在图形窗口顶部的一个不可见的点，使用这两个数字 `xPos` 和 `yPos`。这样，当苹果开始掉落时，它们会在屏幕顶部随机出现；被放置在
    `yPos = -100` 的苹果会比放置在 `yPos = -500` 的苹果更早出现，因为它需要掉落的距离更短。正如你稍后会看到的，我们还将在玩家抓住或错过苹果时调用这个子程序。
- en: '***Step 4: Move the Apples***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 4：移动苹果***'
- en: Now we’re ready to make it rain apples (give the cats and dogs a break). Add
    the code in [Listing 15-7](ch15.html#ch15ex7) to the program in the placeholder
    for the `MoveApples()` subroutine.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备让苹果下雨了（让猫和狗休息一下）。将[清单 15-7](ch15.html#ch15ex7)中的代码添加到 `MoveApples()` 子程序的占位符中。
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 15-7: The* `MoveApples()` *subroutine*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-7：* `MoveApples()` *子程序*'
- en: In line 2, we start a `For` loop to drop five apples. We get the upper-left
    corner of each apple (lines 3–4), and then we move it down by 1 pixel (line 5).
    We then call `CheckCatch()` to see whether this apple was caught by the player
    (line 7). As you’ll see in a moment, this subroutine sets the `gotIt` flag to
    1 if the player caught the apple; otherwise, it sets `gotIt` to 0\. It’s okay
    if you miss an apple. You won’t hurt its peelings.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 行，我们开始一个 `For` 循环来掉落五个苹果。我们获取每个苹果的左上角坐标（第 3–4 行），然后将其向下移动 1 像素（第 5 行）。然后我们调用
    `CheckCatch()` 来检查这个苹果是否被玩家抓住（第 7 行）。正如你稍后会看到的，这个子程序会将 `gotIt` 标志设置为 1，如果玩家抓住了苹果；否则，它会将
    `gotIt` 设置为 0。错过苹果是没关系的，不会伤害到苹果的皮。
- en: When `CheckCatch()` returns, we check the `gotIt` flag. If it’s 1 (line 8),
    that means the apple was caught by the player. In this case, we play a click sound,
    increment `numCaught` by 1, and call `SetApplePosition()` to reposition this apple
    and let it fall again (lines 9–11). On the other hand, if `gotIt` isn’t 1, we
    check the apple’s y-position to see whether it went below the cart’s center, which
    means that the player missed it (line 12). In this case, we increase `numMissed`
    by 1 and call `SetApplePosition()` to reposition this apple and let it fall again
    (lines 13–14). If the apple was neither caught nor missed, then it’s falling and
    will be processed again the next time we call `MoveApples()`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `CheckCatch()` 返回时，我们检查 `gotIt` 标志。如果它是 1（第 8 行），意味着苹果被玩家抓住了。在这种情况下，我们播放点击音效，将
    `numCaught` 增加 1，并调用 `SetApplePosition()` 重新定位苹果并让它再次掉落（第 9–11 行）。另一方面，如果 `gotIt`
    不是 1，我们检查苹果的 y 坐标，看看它是否落到小车中心以下，意味着玩家没有接住它（第 12 行）。在这种情况下，我们将 `numMissed` 增加 1，并调用
    `SetApplePosition()` 重新定位苹果并让它再次掉落（第 13–14 行）。如果苹果既没有被抓住也没有错过，那么它正在掉落，并将在下次调用
    `MoveApples()` 时再次处理。
- en: After moving and checking the status of the five apples, we update the message
    that shows the number of caught and missed apples (lines 18–19).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动并检查五个苹果的状态后，我们更新显示已抓住和错过苹果数量的消息（第 18–19 行）。
- en: '***Step 5: Catch or Miss***'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 5：抓住或错过***'
- en: The last piece to add is the `CheckCatch()` subroutine in [Listing 15-8](ch15.html#ch15ex8).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是添加`CheckCatch()`子程序，见[Listing 15-8](ch15.html#ch15ex8)。
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 15-8: The* `CheckCatch()` *subroutine*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 15-8: The* `CheckCatch()` *子程序*'
- en: This subroutine checks the distance between the center of an apple (whose index
    is given by `aplNum`) and the center of the cart. If the apple is within 20 pixels
    from the cart’s center, the subroutine sets `gotIt` to 1\. Otherwise, it sets
    `gotIt` to 0.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子程序检查苹果中心（其索引由`aplNum`给出）和小车中心之间的距离。如果苹果距离小车中心20像素以内，子程序将`gotIt`设置为1；否则，它将`gotIt`设置为0。
- en: The game is now complete, and you can play it! Maybe you’ll catch enough apples
    for an apple pie.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在已经完成，你可以开始玩了！也许你会捉到足够多的苹果做一个苹果派。
- en: '**TRY IT OUT 15-6**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**试试看 15-6**'
- en: Currently, the Catch Apples game runs forever. Think of a way to end the game,
    and then implement it. Can you think of some other ways to improve the game? Maybe
    you could give the player more points if they catch a big apple! What about the
    statement to move the cart inside the `While` loop? Can you move this statement
    to a new `MouseMove` event handler?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，Catch Apples游戏会一直运行。想想如何结束游戏，然后实现它。你能想到其他一些改进游戏的方法吗？也许如果玩家捉到一个大苹果，你可以给他们更多的分数！关于在`While`循环内移动小车的语句呢？你能把这个语句移到新的`MouseMove`事件处理程序中吗？
- en: '**Programming Challenges**'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程挑战**'
- en: If you get stuck, check out *[http://nostarch.com/smallbasic/](http://nostarch.com/smallbasic/)*
    for the solutions and for more resources and review questions for teachers and
    students.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你卡住了，可以查看* [http://nostarch.com/smallbasic/](http://nostarch.com/smallbasic/)*获取解决方案、更多资源以及供教师和学生使用的复习问题。
- en: 'Write a program that simulates rolling a die. Make the program roll a die 10,000
    times and keep track of how many times each number appears. A sample run of the
    program follows. (Hint: use an array named `dice` that has six elements. If you
    get 1 in a roll, increment `dice[1]`. If you get 2, increment `dice[2]`, and so
    on.)'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个模拟掷骰子的程序。让程序掷骰子10,000次，并跟踪每个数字出现的次数。以下是程序的一个示例运行。（提示：使用一个名为`dice`的数组，它有六个元素。如果掷出1，就增加`dice[1]`；如果掷出2，就增加`dice[2]`，以此类推。）
- en: '[PRE33]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Open the file *PinBall.sb* in this chapter’s folder. This program simulates
    a pinball machine. As shown in the following illustration, the ball is dropped
    at the top of the machine. As it rolls down, it strikes fixed pins and bounces
    to the left or to the right in a random fashion. At the end, the ball lands in
    one of the seven pockets. The program drops the ball 10,000 times and counts the
    number of times it lands in each pocket. Study the program and explain how it
    works.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开本章文件夹中的*PinBall.sb*文件。这个程序模拟了一个弹珠机。如下图所示，球从机器顶部掉下。当它向下滚动时，它会撞击固定的销钉，并以随机的方式向左或向右弹跳。最后，球会落入七个口袋中的一个。程序会让球掉落10,000次，并统计每次球落入哪个口袋。研究程序并解释它是如何工作的。
- en: '![image](graphics/f0224-01.jpg)'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](graphics/f0224-01.jpg)'
- en: Open the file *FlowerAnatomy.sb* from this chapter’s folder. This program presents
    an educational game that quizzes the player on the parts of a flower (shown next).
    The player enters the letters to match the labeled parts of the flower and then
    clicks the Check button to check the answers. The program compares the user’s
    answers with the correct ones; then it shows you how the user did by placing a
    green check mark next to each correct answer and a red X next to each incorrect
    answer. Study the program and explain how it works.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开本章文件夹中的*FlowerAnatomy.sb*文件。这个程序是一个教育游戏，测试玩家对花朵部位的认识（如下图所示）。玩家输入字母以匹配花朵的标签部位，然后点击“检查”按钮来检查答案。程序将用户的答案与正确答案进行比较，然后通过在每个正确答案旁边放一个绿色的对号，在每个错误答案旁边放一个红色的叉号，来显示玩家的成绩。研究这个程序，并解释它是如何工作的。
- en: '![image](graphics/f0224-02.jpg)'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](graphics/f0224-02.jpg)'
- en: Open the file *USMapQuiz_Incomplete.sb* from this chapter’s folder. The folder
    also contains the background image shown here (and the *Yes* and *No* images from
    the previous exercise). Complete the program to make this quiz work. Display the
    two-letter abbreviations for the nine states and provide nine text boxes to let
    the player match each state with its code.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开本章文件夹中的*USMapQuiz_Incomplete.sb*文件。文件夹中还包含此处显示的背景图像（以及前一个练习中的*Yes*和*No*图像）。完善程序，使这个测验能够运行。显示九个州的两字母缩写，并提供九个文本框，让玩家将每个州与其代码匹配。
- en: '![image](graphics/f0225-01.jpg)'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](graphics/f0225-01.jpg)'
