- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 1 BASH BASICS
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 BASH 基础
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: '*Bash* is a command language interpreter that provides an environment in which
    users can execute commands and run applications. As penetration testers and security
    practitioners, we frequently write bash scripts to automate a wide variety of
    tasks, making bash an essential tool for hackers. In this chapter, you’ll set
    up your bash development environment, explore useful Linux commands to include
    in future scripts, and learn the fundamentals of the language’s syntax, including
    variables, arrays, streams, arguments, and operators.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*Bash* 是一种命令语言解释器，提供了一个环境，用户可以在其中执行命令和运行应用程序。作为渗透测试人员和安全从业者，我们经常编写 bash 脚本来自动化各种任务，因此
    bash 是黑客的必备工具。在本章中，你将设置你的 bash 开发环境，探索未来脚本中要使用的有用 Linux 命令，并学习该语言语法的基础知识，包括变量、数组、流、参数和操作符。'
- en: Environmental Setup
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境设置
- en: Before you begin learning bash, you need both a bash shell running in a terminal
    and a text editor. You can access these on any major operating system by following
    the instructions in this section.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始学习 bash 之前，你需要在终端中运行 bash shell 并且有一个文本编辑器。你可以按照本节中的说明，在任何主要操作系统上访问这些工具。
- en: NOTE
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Beginning in [Chapter 4](chapter4.xhtml), you’ll use Kali Linux to run bash
    commands and complete hacking labs. If you’d like to set up Kali now, consult
    the steps included in [Chapter 3](chapter3.xhtml).*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*从[第 4 章](chapter4.xhtml)开始，你将使用 Kali Linux 来运行 bash 命令并完成黑客实验室。如果你现在想设置 Kali，请参考[第
    3 章](chapter3.xhtml)中的步骤。*'
- en: Accessing the Bash Shell
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问 Bash Shell
- en: If you’re running Linux or macOS, bash should already be available. On Linux,
    open the Terminal application by pressing ALT-CTRL-T. On macOS, you can find the
    terminal by navigating to the Launchpad icon on the system dock.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Linux 或 macOS，bash 应该已经可用。在 Linux 上，按 ALT-CTRL-T 打开终端应用程序。在 macOS 上，你可以通过导航到系统
    Dock 上的 Launchpad 图标找到终端。
- en: Kali and macOS use the Z Shell by default, so when you open a new terminal window,
    you’ll have to enter exec bash to switch to a bash shell before you run commands.
    If you want to change your default shell to bash so you don’t have to manually
    switch shells, you can use the chsh -s /bin/bash command.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Kali 和 macOS 默认使用 Z Shell，因此当你打开新的终端窗口时，你需要输入 exec bash 来切换到 bash shell，然后再运行命令。如果你希望将默认
    shell 改为 bash，以后不必手动切换 shell，可以使用 chsh -s /bin/bash 命令。
- en: 'If you’re running Windows, you can use the Windows Subsystem for Linux (WSL),
    which lets you run Linux distributions and access a bash environment. The official
    Microsoft WSL documentation page describes how to install it: *[https://learn.microsoft.com/en-us/windows/wsl/install](https://learn.microsoft.com/en-us/windows/wsl/install)*.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Windows，你可以使用 Windows Subsystem for Linux (WSL)，它允许你运行 Linux 发行版并访问
    bash 环境。官方的 Microsoft WSL 文档页面描述了如何安装它：*[https://learn.microsoft.com/en-us/windows/wsl/install](https://learn.microsoft.com/en-us/windows/wsl/install)*。
- en: An alternative to WSL is *Cygwin*, which emulates a Linux environment by providing
    a collection of Linux utilities and system-call functionalities. To install Cygwin,
    visit *[https://www.cygwin.com/install.html](https://www.cygwin.com/install.html)*
    to download the setup file, and then follow the installation wizard.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: WSL 的替代方案是 *Cygwin*，它通过提供一组 Linux 实用工具和系统调用功能来模拟 Linux 环境。要安装 Cygwin，请访问 *[https://www.cygwin.com/install.html](https://www.cygwin.com/install.html)*
    下载安装文件，然后按照安装向导进行操作。
- en: Cygwin installs itself by default to the *C:\cygwin64\* Windows path. To execute
    your bash scripts, save the scripts in the directory containing your username
    at *C:\cygwin64\home*. For example, if your username is *david*, you should save
    your scripts under *C:\cygwin64\home\david*. Then, from the Cygwin terminal, you’ll
    be able to change the directory to the home directory to run your scripts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Cygwin 默认安装在 *C:\cygwin64\* Windows 路径下。要执行你的 bash 脚本，请将脚本保存在包含你的用户名的目录下，如 *C:\cygwin64\home*。例如，如果你的用户名是
    *david*，你应该将脚本保存在 *C:\cygwin64\home\david* 下。然后，在 Cygwin 终端中，你将能够切换到该 home 目录以运行脚本。
- en: Installing a Text Editor
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装文本编辑器
- en: To start writing bash scripts, you’ll need a text editor, preferably one with
    handy features such as syntax highlighting built in. You can choose between terminal-based
    text editors and graphical user interface–based text editors. Terminal-based text
    editors (such as vi or GNU nano) are useful because during a penetration test
    they may be the only available options when you need to develop a script on the
    spot.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始编写 bash 脚本，你需要一个文本编辑器，最好是内置语法高亮等实用功能的编辑器。你可以选择基于终端的文本编辑器和基于图形用户界面的文本编辑器。基于终端的文本编辑器（如
    vi 或 GNU nano）非常有用，因为在渗透测试过程中，当你需要立即开发脚本时，它们可能是唯一可用的选项。
- en: If you prefer graphical text editors, Sublime Text (*[https://www.sublimetext.com](https://www.sublimetext.com)*)
    is one option you could use. In Sublime Text, you can toggle on the syntax highlighting
    feature for bash scripts by clicking **Plain Text** in the bottom-right corner
    and choosing **Bash** from the drop-down list of languages. If you’re using a
    different text editor, reference its official documentation to learn how to turn
    on syntax highlighting.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢图形化文本编辑器，Sublime Text (*[https://www.sublimetext.com](https://www.sublimetext.com)*)
    是一个你可以使用的选项。在 Sublime Text 中，你可以通过点击右下角的**Plain Text**，然后从下拉的语言列表中选择**Bash**来开启
    bash 脚本的语法高亮功能。如果你使用的是其他文本编辑器，请参考其官方文档了解如何开启语法高亮功能。
- en: Exploring the Shell
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 Shell
- en: Now that you have a functional bash environment, it’s time to learn some basics.
    Although you’ll develop scripts in your text editor, you’ll also probably find
    yourself frequently running single commands in the terminal. This is because you
    often need to see how a command runs and the kind of output it produces before
    including it in a script. Let’s get started by running some bash commands.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个功能齐全的 bash 环境，接下来就该学习一些基础知识了。尽管你将在文本编辑器中开发脚本，但你可能还会经常在终端中运行单个命令。这是因为你通常需要在将命令纳入脚本之前，先查看命令的运行方式和输出结果。让我们通过运行一些
    bash 命令来开始。
- en: 'First, enter the following command to verify that bash is available on your
    system:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，输入以下命令验证系统中是否有 bash：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The version in the output will depend on the operating system you are running.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的版本将取决于你运行的操作系统。
- en: Checking Environment Variables
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查环境变量
- en: When running in a terminal, bash loads a set of *environment variables* with
    every new session that gets invoked. Programs can use these environment variables
    for various purposes, such as discovering the identity of the user running the
    script, the location of their home directory, and their default shell.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中运行时，bash 会在每次启动新会话时加载一组*环境变量*。程序可以使用这些环境变量执行各种任务，比如确定运行脚本的用户身份、用户的主目录位置以及默认的
    shell。
- en: To see the list of environment variables set by bash, run the env command directly
    from the shell ([Listing 1-1](chapter1.xhtml#Lis1-1)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 bash 设置的环境变量列表，可以直接从 shell 中运行 env 命令（[Listing 1-1](chapter1.xhtml#Lis1-1)）。
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 1-1: Listing bash’s environment variables'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 1-1: 列出 bash 的环境变量'
- en: You can read individual environment variables by using the echo command, which
    writes text to the terminal. For example, to print the default shell set for the
    user, use the SHELL environment variable preceded by a dollar sign ($) and surrounded
    by curly brackets ({}). This will cause bash to expand the variable to its assigned
    value, as shown in [Listing 1-2](chapter1.xhtml#Lis1-2).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 echo 命令读取单个环境变量，echo 会将文本输出到终端。例如，要打印用户设置的默认 shell，可以使用 SHELL 环境变量，并在变量前加上美元符号
    ($)，并用大括号（{}）包围。这会使 bash 扩展该变量并显示其分配的值，如[Listing 1-2](chapter1.xhtml#Lis1-2)所示。
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 1-2: Printing an environment variable to the terminal'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 1-2: 将环境变量打印到终端'
- en: 'Here are some of the default environment variables available:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可用的默认环境变量：
- en: BASH_VERSION The bash version running
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: BASH_VERSION 正在运行的 bash 版本
- en: BASHPID The process identifier (PID) of the current bash process
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: BASHPID 当前 bash 进程的进程标识符（PID）
- en: GROUPS A list of groups the running user is a member of
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: GROUPS 当前用户所属的组列表
- en: HOSTNAME The name of the host
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: HOSTNAME 主机名
- en: OSTYPE The type of operating system
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: OSTYPE 操作系统类型
- en: PWD The current working directory
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: PWD 当前工作目录
- en: RANDOM A random number from 0 to 32,767
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: RANDOM 从 0 到 32,767 的随机数
- en: UID The user ID (UID) of the current user
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: UID 当前用户的用户 ID（UID）
- en: SHELL The full pathname to the shell
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SHELL shell 的完整路径名
- en: 'The following examples show how to check the values of a few of these environment
    variables:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何检查这些环境变量中的一些值：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These commands generate a random number, output the current user’s ID, and display
    the operating system type, respectively. You can find the full list of environment
    variables at *[https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html](https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html)*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令分别生成一个随机数、输出当前用户的ID，并显示操作系统类型。你可以在*[https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html](https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html)*找到完整的环境变量列表。
- en: Running Linux Commands
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行Linux命令
- en: The bash scripts you’ll write in this book will run common Linux tools, so if
    you’re not yet familiar with command line navigation and file modification utilities
    such as cd, ls, chmod, mkdir, and touch, try exploring them by using the man (manual)
    command. You can insert it before any Linux command to open a terminal-based guide
    that explains that command’s use and options, as shown in [Listing 1-3](chapter1.xhtml#Lis1-3).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本书中编写的bash脚本将运行常见的Linux工具，所以如果你还不熟悉命令行导航和文件修改工具，如cd、ls、chmod、mkdir和touch，尝试通过使用man（手册）命令进行探索。你可以在任何Linux命令前加上它，打开一个基于终端的指南，解释该命令的用法和选项，如[示例
    1-3](chapter1.xhtml#Lis1-3)所示。
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 1-3: Accessing a command’s manual page'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-3：访问命令的手册页
- en: Linux commands can accept many types of input on the command line. For example,
    you can enter ls without any arguments to see files and directories, or pass it
    arguments to, for instance, display the list of files all on one line.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Linux命令可以在命令行上接受多种类型的输入。例如，你可以输入ls命令而不带任何参数，以查看文件和目录，或者传递参数，例如显示所有文件在一行中。
- en: 'Arguments are passed on the command line by using either short-form or long-form
    argument syntax, depending on the command in use. *Short-form* syntax uses a single
    dash (-) followed by one or more characters. The following example uses ls to
    list files and directories with a short-form argument syntax:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 参数通过命令行传递，使用短格式或长格式的参数语法，这取决于正在使用的命令。*短格式*语法使用一个短横线（-）后跟一个或多个字符。以下示例使用ls命令列出文件和目录，采用短格式的参数语法：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Some commands let you supply multiple arguments by joining them together or
    listing them separately:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一些命令允许你通过将多个参数连接在一起或分别列出它们来传递多个参数：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that some commands may throw errors if you attempt to join two arguments
    with a single dash, so use the man command to learn the syntax that’s permitted.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果尝试用一个单一的短横线连接两个参数，某些命令可能会报错，因此请使用man命令了解允许的语法。
- en: 'Some command options may allow you to use *long-form* argument syntax, such
    as the --help command to list the available options. Long-form argument syntax
    is prepended by the double dash (--) symbol:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有些命令选项允许你使用*长格式*的参数语法，比如--help命令用于列出可用的选项。长格式的参数语法是以双短横线（--）开头的：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Sometimes the same command argument supports both short- and long-form argument
    syntax for convenience. For example, ls supports the argument -a (all) to display
    all files, including those that are hidden. (Files starting with a dot in their
    name are considered hidden in Linux.) However, you could also pass the argument
    --all, and the outcome would be identical:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，为了方便，相同的命令参数支持短格式和长格式两种语法。例如，ls支持参数-a（all），用于显示所有文件，包括隐藏文件。（以点号开头的文件在Linux中被视为隐藏文件。）然而，你也可以传递--all参数，结果将是一样的：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s execute some simple Linux commands so you can see the variation of options
    each offers. First, create a single directory with mkdir:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行一些简单的Linux命令，以便你可以看到每个命令提供的选项变化。首先，使用mkdir创建一个目录：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now let’s create two directories with mkdir:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用mkdir创建两个目录：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, list processes by using ps with short-form argument syntax, supplying
    the arguments separately and then together:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用ps命令列出进程，使用短格式的参数语法，先分别提供参数，然后一起提供：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, let’s display the available disk space by using df with long-form
    argument syntax:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用df命令和长格式参数语法来显示可用的磁盘空间：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Throughout this book, you’ll use Linux commands such as these in your scripts.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你将使用这些Linux命令编写脚本。
- en: Elements of a Bash Script
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bash脚本的元素
- en: In this section, you’ll learn the building blocks of a bash script. You’ll use
    comments to document what a script does, tell Linux to use a specific interpreter
    to execute the script, and style your scripts for better readability.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习bash脚本的构建模块。你将使用注释来记录脚本的功能，告诉Linux使用特定的解释器执行脚本，并为脚本添加样式以提高可读性。
- en: Bash doesn’t have an official style guide, but we recommend adhering to Google’s
    Shell Style Guide (*[https://google.github.io/styleguide/shellguide.html](https://google.github.io/styleguide/shellguide.html)*),
    which outlines best practices to follow when developing bash code. If you work
    on a team of penetration testers and have an exploit code repository, using good
    code styling practices will help your team maintain it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 没有官方的风格指南，但我们建议遵循 Google 的 Shell 风格指南（*[https://google.github.io/styleguide/shellguide.html](https://google.github.io/styleguide/shellguide.html)*），该指南概述了开发
    bash 代码时应遵循的最佳实践。如果你在一个渗透测试团队中工作，并且有一个漏洞利用代码库，使用良好的代码风格实践将帮助你的团队进行维护。
- en: The Shebang Line
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Shebang 行
- en: Every script should begin with the *shebang* line, a character sequence that
    starts with the hash and exclamation marks (#!), followed by the full path to
    the script interpreter. [Listing 1-4](chapter1.xhtml#Lis1-4) shows an example
    of a shebang line for a typical bash script.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每个脚本都应该以*shebang*行开始，这是一个字符序列，起始符号为井号和感叹号（#!），后面跟着脚本解释器的完整路径。[列表 1-4](chapter1.xhtml#Lis1-4)展示了一个典型
    bash 脚本的 shebang 行示例。
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 1-4: A bash shebang line'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-4：Bash Shebang 行
- en: The bash interpreter is typically located at */bin/bash*. If you instead wrote
    scripts in Python or Ruby, your shebang line would include the full path to the
    Python or Ruby interpreter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 解释器通常位于 */bin/bash*。如果你使用 Python 或 Ruby 编写脚本，那么你的 shebang 行会包括 Python 或
    Ruby 解释器的完整路径。
- en: 'You’ll sometimes encounter bash scripts that use a shebang line like this one:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你有时会遇到使用类似下面这种 Shebang 行的 bash 脚本：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You may want to use this shebang line because it is more portable than the one
    in [Listing 1-4](chapter1.xhtml#Lis1-4). Some Linux distributions place the bash
    interpreter in different system locations, and this shebang line will attempt
    to find that location. This approach could be particularly useful in penetration
    tests, where you might not know the location of the bash interpreter on the target
    machine. For simplicity, however, we’ll use the shebang version from [Listing
    1-4](chapter1.xhtml#Lis1-4) throughout this book.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想使用这个 shebang 行，因为它比[列表 1-4](chapter1.xhtml#Lis1-4)中的那个更具可移植性。一些 Linux 发行版将
    bash 解释器放置在不同的系统位置，而这个 shebang 行将尝试找到该位置。这个方法在渗透测试中尤其有用，因为你可能不知道目标机器上 bash 解释器的具体位置。然而，为了简化起见，本书中将使用[列表
    1-4](chapter1.xhtml#Lis1-4)中的 shebang 版本。
- en: 'The shebang line can also take optional arguments to change how the script
    executes. For example, you could pass the special argument -x to your bash shebang,
    like so:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Shebang 行也可以接受可选的参数来改变脚本的执行方式。例如，你可以将特殊参数 -x 传递给你的 bash shebang，像这样：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This option prints all commands and their arguments as they are executed to
    the terminal. It is useful for debugging scripts as you’re developing them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项会将所有命令及其参数在执行时打印到终端。这对于调试脚本非常有用，尤其是在你开发脚本时。
- en: 'Another example of an optional argument is -r:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可选参数的例子是 -r：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This option creates a *restricted bash shell*, which restricts certain potentially
    dangerous commands that could, for example, navigate to certain directories, change
    sensitive environment variables, or attempt to turn off the restricted shell from
    within the script.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项创建了一个*受限的 bash shell*，它限制了某些可能危险的命令，这些命令可能会例如导航到特定目录、修改敏感的环境变量，或者尝试从脚本内部关闭受限的
    shell。
- en: 'Specifying an argument within the shebang line requires modifying the script,
    but you can also pass arguments to the bash interpreter by using this syntax:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 shebang 行中指定一个参数需要修改脚本，但你也可以通过使用以下语法将参数传递给 bash 解释器：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Whether you pass arguments to the bash interpreter on the command line or on
    the shebang line won’t make a difference. The command line option is just an easier
    way to trigger different modes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是在命令行上传递参数给 bash 解释器，还是在 shebang 行中传递，都不会有区别。命令行选项只是触发不同模式的一种更简便的方式。
- en: Comments
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: '*Comments* are parts of a script that the bash interpreter won’t treat as code
    and that can improve the readability of a program. Imagine that you write a long
    script and, a few years later, need to modify some of its logic. If you didn’t
    write comments to explain what you did, you might find it quite challenging to
    remember the purpose of each section.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*注释*是脚本的一部分，bash 解释器不会将其视为代码，它们可以提高程序的可读性。试想一下，你写了一个很长的脚本，几年后需要修改其中的一些逻辑。如果你没有写注释来解释你做了什么，可能会发现很难记住每个部分的目的。'
- en: Comments in bash start with a hash mark (#), as shown in [Listing 1-5](chapter1.xhtml#Lis1-5).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 中的注释以井号 (#) 开始，如[列表 1-5](chapter1.xhtml#Lis1-5)所示。
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 1-5: A comment in a bash script'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-5：bash 脚本中的注释
- en: Except for the shebang line, every line that starts with a hash mark is considered
    a comment. If you wrote the shebang line twice, bash would consider the second
    one to be a comment.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 shebang 行外，所有以井号开头的行都被视为注释。如果你写了两次 shebang 行，bash 会认为第二行是注释。
- en: To write a multiline comment, precede each individual line with the hash mark,
    as shown in [Listing 1-6](chapter1.xhtml#Lis1-6).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写多行注释，请在每行前面加上井号，如[列表 1-6](chapter1.xhtml#Lis1-6)所示。
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 1-6: A multiline comment'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-6：多行注释
- en: In addition to documenting a script’s logic, comments can provide metadata to
    indicate the author, the script’s version, the person to contact for issues, and
    more. These comments usually appear at the top part of the script, below the shebang
    line.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 除了记录脚本的逻辑，注释还可以提供元数据，指示作者、脚本版本、联系问题的人等。这些注释通常出现在脚本的顶部部分，位于 shebang 行下方。
- en: Commands
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令
- en: 'Scripts can be as short as two lines: the shebang line and a Linux command.
    Let’s write a simple script that prints Hello World! to the terminal. Open your
    text editor and enter the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可以简短到只有两行：shebang 行和一条 Linux 命令。让我们写一个简单的脚本，将 Hello World! 打印到终端。打开文本编辑器并输入以下内容：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, we use the shebang statement to specify the interpreter of
    choice, bash. Then we use the echo command to print the string Hello World! to
    the screen.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用 shebang 语句指定了我们选择的解释器 bash。然后我们使用 echo 命令将字符串 Hello World! 打印到屏幕上。
- en: Execution
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行
- en: To run the script, save the file as *helloworld.sh*, open the terminal, and
    navigate to the directory where the script resides. If you saved the file in your
    home directory, you should run the set of commands shown in [Listing 1-7](chapter1.xhtml#Lis1-7).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行脚本，将文件保存为 *helloworld.sh*，然后打开终端并导航到脚本所在的目录。如果你将文件保存在主目录中，你应该运行[列表 1-7](chapter1.xhtml#Lis1-7)中显示的一组命令。
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 1-7: Running a script from the home directory'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-7：从主目录运行脚本
- en: We use the cd command to change directories. The tilde (~) represents the home
    directory of the current running user. Next, we use chmod to set the executable
    (u+x) permissions for the user who owns the file (in this case, us). We run the
    script by using dot-slash notation (./) followed by the script’s name. The dot
    (.) represents the current directory, so we’re essentially telling bash to run
    *helloworld.sh* from the current working directory.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 cd 命令来切换目录。波浪号（~）代表当前运行用户的主目录。接下来，我们使用 chmod 设置文件拥有者（在这个例子中是我们自己）的可执行（u+x）权限。我们通过使用点斜杠符号（./）后跟脚本名称来运行脚本。点（.）表示当前目录，因此我们实际上是在告诉
    bash 从当前工作目录运行*helloworld.sh*。
- en: 'You can also run a bash script with the following syntax:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用以下语法运行 bash 脚本：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Because we specified the bash command, the script will run using the bash interpreter
    and won’t require a shebang line. Also, if you use the bash command, the script
    doesn’t have to be set with an executable permission (+x). In later chapters,
    you’ll learn about the permission model in more depth and explore its importance
    in the context of finding misconfigurations in penetration tests.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们指定了 bash 命令，脚本将使用 bash 解释器运行，并且不需要 shebang 行。另外，如果使用 bash 命令，脚本也不需要设置可执行权限（+x）。在后续章节中，你将更深入了解权限模型，并探讨它在渗透测试中查找配置错误的重要性。
- en: Debugging
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试
- en: 'Errors will inevitably occur when you’re developing bash scripts. Luckily,
    debugging scripts is quite intuitive. An easy way to check for errors early is
    by using the -n parameter when running a script:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 bash 脚本时，错误是不可避免的。幸运的是，调试脚本相当直观。一个简单的早期检查错误的方法是运行脚本时使用 -n 参数：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This parameter will read the commands in the script but won’t execute them,
    so any syntax errors that exist will be shown onscreen. You can think of -n as
    a dry-run method to test the validity of your syntax.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数将读取脚本中的命令，但不会执行它们，因此所有语法错误都会显示在屏幕上。你可以把 -n 当作一种干运行方法，用来测试语法的有效性。
- en: 'You can also use the -x parameter to turn on verbose mode, which lets you see
    commands being executed and will help you debug issues as the script executes
    in real time:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 -x 参数开启详细模式，这样可以看到正在执行的命令，并帮助你在脚本实时执行时调试问题：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you want to start debugging at a given point in the script, include the set
    command in the script itself ([Listing 1-8](chapter1.xhtml#Lis1-8)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在脚本的某个特定位置开始调试，可以在脚本中包含 set 命令（[列表 1-8](chapter1.xhtml#Lis1-8)）。
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 1-8: Using set to debug a script'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-8：使用 set 调试脚本
- en: You can think of set as a valve that turns a certain option on and off. In this
    example, the first command sets the debugging mode (set -x), while the last command
    (set +x) disables it. By using set, you can avoid generating a massive amount
    of noise in your terminal when your script is large and contains a specific problem
    area.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 set 看作是一个开关，用于开启或关闭某个选项。在这个示例中，第一个命令设置调试模式（set -x），而最后一个命令（set +x）禁用调试模式。通过使用
    set，你可以避免在脚本较大且包含特定问题区域时，在终端中生成大量无用信息。
- en: Basic Syntax
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本语法
- en: At this point, you’ve written a two-line script that prints the message Hello
    World! to the screen. You’ve also learned how to run and debug a script. Now you’ll
    learn some bash syntax so you can write more useful scripts.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经编写了一个两行的脚本，向屏幕打印出消息 "Hello World!"。你还学会了如何运行和调试脚本。现在，你将学习一些 bash 语法，以便编写更有用的脚本。
- en: The most basic bash scripts are just lists of Linux commands collected in a
    single file. For example, you could write a script that creates resources on a
    system and then prints information about these resources to the screen ([Listing
    1-9](chapter1.xhtml#Lis1-9)).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的 bash 脚本只是将 Linux 命令收集到一个文件中。例如，你可以编写一个脚本，在系统上创建资源，然后将这些资源的信息打印到屏幕上（[清单
    1-9](chapter1.xhtml#Lis1-9)）。
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 1-9: A bash script that lists directory contents'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-9：列出目录内容的 bash 脚本
- en: In this example, we use mkdir to create a directory named *mydirectory*. Next,
    we use the touch command to create a file named *myfile* within the directory.
    Finally, we run the ls -l command to list the contents of *mydirectory*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用 mkdir 创建一个名为*mydirectory*的目录。接着，我们使用 touch 命令在该目录内创建一个名为*myfile*的文件。最后，我们运行
    ls -l 命令列出*mydirectory*的内容。
- en: 'The output of the script looks as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的输出如下所示：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: However, this line-by-line strategy could be improved in several ways. First,
    when a command runs, bash waits until it finishes before advancing to the next
    line. If you include a long-running command (such as a file download or large
    file copy), the remaining commands won’t be executed until that command has completed.
    We also have yet to implement any checks to validate that all commands have executed
    correctly. You’ll need to write more-intelligent programs to reduce errors during
    runtime.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种逐行执行的策略可以在多个方面进行改进。首先，当命令运行时，bash 会等待命令完成后再继续执行下一行。如果包含一个长时间运行的命令（如文件下载或大文件复制），剩下的命令将在该命令完成之前无法执行。我们还没有实现任何检查机制来验证所有命令是否正确执行。你需要编写更智能的程序，以减少运行时的错误。
- en: Writing sophisticated programs often requires using features like variables,
    conditions, loops, and tests. For example, what if we want to change this script
    so that it checks for enough space on the disk before attempting to create new
    files and directories? Or what if we could check whether the directory and file
    creation actions actually succeeded? This section and [Chapter 2](chapter2.xhtml)
    introduce you to the syntactical elements you’ll need to accomplish these tasks.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 编写复杂程序通常需要使用变量、条件、循环和测试等功能。例如，如果我们希望修改这个脚本，使其在尝试创建新文件和目录之前检查磁盘是否有足够的空间，怎么办？或者如果我们能够检查目录和文件创建操作是否成功呢？本节和[第
    2 章](chapter2.xhtml)将介绍你完成这些任务所需的语法元素。
- en: Variables
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量
- en: Every scripting language has variables. *Variables* are names that we assign
    to memory locations and that hold a value; they act like placeholders or labels.
    We can directly assign values to variables, or we can execute bash commands and
    store their output as variable values to use for various purposes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每种脚本语言都有变量。*变量*是我们分配给内存位置并存储值的名称；它们充当占位符或标签。我们可以直接为变量赋值，或者可以执行 bash 命令并将其输出存储为变量值，以供各种用途。
- en: If you’ve worked with programming languages, you may know that variables can
    be of different types, such as integers, strings, and arrays. In bash, variables
    are untyped; they’re all considered character strings. Even so, you’ll see that
    bash allows you to create arrays, access array elements, or perform arithmetic
    operations so long as the variable value consists of only numbers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾接触过编程语言，你可能知道变量可以有不同的类型，如整数、字符串和数组。在 bash 中，变量是无类型的；它们都被视为字符字符串。尽管如此，你会看到
    bash 允许你创建数组、访问数组元素，或执行算术运算，只要变量值仅由数字组成。
- en: 'The following rules govern the naming of bash variables:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下规则规范了 bash 变量的命名：
- en: They can include alphanumeric characters.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以包含字母数字字符。
- en: They cannot start with a number.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名不能以数字开头。
- en: They can contain an underscore (_).
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名可以包含下划线（_）。
- en: They cannot contain whitespace.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名不能包含空格。
- en: Assigning and Accessing Variables
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变量赋值与访问
- en: 'Let’s assign a variable. Open a terminal and enter the following directly within
    the command prompt:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来赋值一个变量。打开终端并在命令提示符下直接输入以下内容：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We create a variable named book and, by using the equal sign (=), assign the
    value black hat bash to it. Now we can use this variable in a command. In the
    following example, we use the echo command to print the variable to the screen:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为book的变量，并使用等号（=）将值“black hat bash”赋给它。现在我们可以在命令中使用这个变量。在以下示例中，我们使用echo命令将该变量打印到屏幕上：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here we were able to print the variable by using the ${book} syntax within
    an echo command. This will expand the book variable to its value. You can also
    expand a variable by using just the dollar sign ($) followed by the variable:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过在echo命令中使用${book}语法打印变量。这将扩展book变量的值。你也可以通过仅使用美元符号（$）后跟变量名来扩展变量：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Using the ${} syntax makes the code less prone to misinterpretation and helps
    readers understand when a variable starts and ends.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用${}语法可以使代码更不容易被误解，并帮助读者理解变量的开始和结束。
- en: You can also assign the output of a command to a variable by using the command
    substitution syntax $(), placing the desired command within the parentheses. You’ll
    use this syntax often in bash programming. Try running the commands in [Listing
    1-10](chapter1.xhtml#Lis1-10).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用命令替换语法$()，将命令的输出赋值给变量，将所需的命令放在括号内。你将在bash编程中经常使用这种语法。尝试运行[清单1-10](chapter1.xhtml#Lis1-10)中的命令。
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 1-10: Assigning command output to a variable'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 清单1-10：将命令输出赋值给变量
- en: We assign the value of the ls -ld / command to a variable named root_directory
    and then use echo to print the output of the command. In this output, you can
    see that we were able to get metadata about the root directory (/), such as its
    type and permission, size, user and group owners, and the timestamp of the last
    modification.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将命令`ls -ld /`的输出赋值给名为root_directory的变量，然后使用echo打印该命令的输出。在这个输出中，你可以看到我们能够获取有关根目录（/）的元数据，如其类型和权限、大小、用户和组所有者，以及最后修改的时间戳。
- en: 'Note that you shouldn’t leave whitespace around the assignment symbol (=) when
    creating a variable:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在创建变量时，赋值符号（=）两边不应有空格：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The previous variable assignment syntax is considered invalid.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的变量赋值语法被认为是无效的。
- en: Unassigning Variables
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 取消赋值变量
- en: You can unassign assigned variables by using the unset command, as shown in
    [Listing 1-11](chapter1.xhtml#Lis1-11).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用unset命令来取消已赋值的变量，如[清单1-11](chapter1.xhtml#Lis1-11)所示。
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 1-11: Unassigning variables'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 清单1-11：取消变量赋值
- en: If you execute these commands in the terminal, no output will be shown after
    the echo command executes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在终端中执行这些命令，echo命令执行后将不会显示任何输出。
- en: Scoping Variables
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变量作用域
- en: '*Global* variables are those available to the entire program. But variables
    in bash can also be *scoped* so that they are accessible only from within a certain
    block of code. These *local* variables are declared using the local keyword. The
    script in [Listing 1-12](chapter1.xhtml#Lis1-12) shows how local and global variables
    work.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*全局*变量是整个程序都能访问的变量。但是，bash中的变量也可以是*作用域*限定的，只能在特定的代码块内访问。这些*局部*变量是通过使用local关键字声明的。[清单1-12](chapter1.xhtml#Lis1-12)中的脚本展示了局部和全局变量是如何工作的。'
- en: local_scope _variable.sh
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: local_scope _variable.sh
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 1-12: Accessing global and local variables'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 清单1-12：访问全局和局部变量
- en: We assign the value No Starch Press to the variable PUBLISHER and then create
    a function called print_name(). (You’ll learn more about functions in the next
    chapter.) Within the function, we declare a local variable called name and assign
    it the value Black Hat Bash. Then we call print_name() and attempt to access the
    name variable as part of a sentence to be printed using echo.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将值“No Starch Press”赋给变量PUBLISHER，然后创建一个名为print_name()的函数。（你将在下一章学习函数。）在这个函数内，我们声明一个名为name的局部变量，并赋值为“Black
    Hat Bash”。然后我们调用print_name()并尝试将name变量作为一句话的一部分通过echo打印出来。
- en: The echo command at the end of the script file will result in an empty variable,
    as the name variable is locally scoped to the print_name() function, which means
    that nothing outside the function can access it. So, it will simply return without
    a value.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本文件末尾的echo命令将导致空变量，因为name变量的作用域仅限于print_name()函数，这意味着函数外部无法访问它。因此，它将直接返回一个空值。
- en: NOTE
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The scripts in this chapter are available at* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch01](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch01).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章中的脚本可通过以下链接获取*：[https://github.com/dolevf/Black-Hat-Bash/blob/master/ch01](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch01)。'
- en: 'Save this script, remembering to set the executable permission by using chmod,
    and run it by using the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此脚本，记得使用 chmod 设置可执行权限，并使用以下命令运行它：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, the local variable never prints.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，本地变量从未被打印。
- en: Arithmetic Operators
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算术运算符
- en: '*Arithmetic operators* allow you to perform mathematical operations on integers.
    [Table 1-1](chapter1.xhtml#tab1-1) shows some of the arithmetic operators available.
    For the full list, see *[https://tldp.org/LDP/abs/html/ops.html](https://tldp.org/LDP/abs/html/ops.html)*.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*算术运算符*允许你对整数执行数学运算。[表 1-1](chapter1.xhtml#tab1-1)显示了一些可用的算术运算符。完整的列表请参见 *[https://tldp.org/LDP/abs/html/ops.html](https://tldp.org/LDP/abs/html/ops.html)*。'
- en: 'Table 1-1: Arithmetic Operators'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-1：算术运算符
- en: '| Operator | Description |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| + | Addition |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| + | 加法 |'
- en: '| - | Subtraction |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| - | 减法 |'
- en: '| * | Multiplication |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| * | 乘法 |'
- en: '| / | Division |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| / | 除法 |'
- en: '| % | Modulo |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| % | 取模 |'
- en: '| += | Incrementing by a constant |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| += | 常量递增 |'
- en: '| -= | Decrementing by a constant |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| -= | 常量递减 |'
- en: 'You can perform these arithmetic operations in bash in a few ways: using the
    let command, using the double parentheses syntax $((expression)), or using the
    expr command. Let’s consider an example of each method.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过几种方式在 bash 中执行这些算术运算：使用 let 命令、使用双括号语法 $((expression))，或者使用 expr 命令。让我们来看每种方法的一个例子。
- en: In [Listing 1-13](chapter1.xhtml#Lis1-13), we perform a multiplication operation
    by using the let command.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 1-13](chapter1.xhtml#Lis1-13)中，我们通过使用 let 命令执行了一个乘法运算。
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 1-13: Arithmetic with let'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-13：使用 let 进行算术运算
- en: This command takes a variable name and performs an arithmetic calculation to
    resolve its value. In [Listing 1-14](chapter1.xhtml#Lis1-14), we perform another
    multiplication operation using the double parentheses syntax.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令接收一个变量名，并执行算术计算以求解其值。在[清单 1-14](chapter1.xhtml#Lis1-14)中，我们使用双括号语法执行了另一个乘法运算。
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 1-14: Arithmetic with double parentheses syntax'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-14：使用双括号语法进行算术运算
- en: In this case, we perform the calculation within double parentheses. Finally,
    in [Listing 1-15](chapter1.xhtml#Lis1-15), we perform an addition operation using
    the expr command.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在双括号内执行计算。最后，在[清单 1-15](chapter1.xhtml#Lis1-15)中，我们使用 expr 命令执行了加法运算。
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 1-15: Evaluating expressions with expr'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-15：使用 expr 计算表达式
- en: The expr command evaluates expressions, which don’t have to be arithmetic operations;
    for example, you might use it to calculate the length of a string. Use man expr
    to learn more about the capabilities of expr.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: expr 命令用于计算表达式，这些表达式不一定是算术运算；例如，你可以用它来计算字符串的长度。使用 man expr 了解 expr 的更多功能。
- en: Arrays
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组
- en: Bash allows you to create single-dimension arrays. An *array* is a collection
    of elements that are indexed. You can access these elements by using their index
    numbers, which begin at zero. In bash scripts, you might use arrays whenever you
    need to iterate over multiple strings and run the same commands on each one.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 允许你创建一维数组。一个 *数组* 是一个由元素组成的集合，这些元素是有索引的。你可以通过使用它们的索引编号来访问这些元素，索引从零开始。在
    bash 脚本中，每当你需要迭代多个字符串并对每个字符串运行相同的命令时，可能会使用数组。
- en: '[Listing 1-16](chapter1.xhtml#Lis1-16) shows how to create an array in bash.
    Save this code to a file named *array.sh* and execute it.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 1-16](chapter1.xhtml#Lis1-16)展示了如何在 bash 中创建一个数组。将此代码保存为名为 *array.sh* 的文件并执行。'
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 1-16: Creating and accessing arrays'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-16：创建和访问数组
- en: This script uses an array named IP_ADDRESSES that contains three internet protocol
    (IP) addresses. The first echo command prints all the elements in the array by
    passing [*] to the variable name IP_ADDRESSES, which holds the array values. The
    asterisk (*) is a representation of every array element. Finally, another echo
    command prints just the first element in the array by specifying index 0.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本使用名为 IP_ADDRESSES 的数组，其中包含三个互联网协议（IP）地址。第一个 echo 命令通过将 [*] 传递给变量名 IP_ADDRESSES（它保存了数组值）来打印数组中的所有元素。星号（*）表示每个数组元素。最后，另一个
    echo 命令通过指定索引 0 来打印数组中的第一个元素。
- en: 'Running this script should produce the following output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本应产生以下输出：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, we were able to get bash to print all elements in the array,
    as well as just the first element.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们能够让 bash 打印数组中的所有元素，也只打印第一个元素。
- en: You can also delete elements from an array. [Listing 1-17](chapter1.xhtml#Lis1-17)
    will delete 192.168.1.2 from the array.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从数组中删除元素。[列表 1-17](chapter1.xhtml#Lis1-17)会删除数组中的 192.168.1.2。
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 1-17: Deleting array elements'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-17：删除数组元素
- en: 'You can even swap one of the values with another value. This code will replace
    192.168.1.1 with 192.168.1.10:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以用另一个值替换其中一个值。此代码将 192.168.1.1 替换为 192.168.1.10：
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You’ll find arrays particularly useful when you need to iterate over values
    and perform actions against them, such as a list of IP addresses to scan (or a
    list of email addresses to send a phishing email to).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要迭代值并对其执行操作时，数组会特别有用，比如扫描的 IP 地址列表（或要发送钓鱼邮件的电子邮件地址列表）。
- en: Streams
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流
- en: '*Streams* are files that act as communication channels between a program and
    its environment. When you interact with a program (whether a built-in Linux utility
    such as ls or mkdir or one that you wrote yourself), you’re interacting with one
    or more streams. Bash has three standard data streams, as shown in [Table 1-2](chapter1.xhtml#tab1-2).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*流*是充当程序与其环境之间通信通道的文件。当你与程序交互时（无论是内建的 Linux 工具，如 ls 或 mkdir，还是你自己编写的程序），你都在与一个或多个流交互。Bash
    有三个标准数据流，如[表格 1-2](chapter1.xhtml#tab1-2)所示。'
- en: 'Table 1-2: Streams'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-2：流
- en: '| Stream name | Description | File descriptor number |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 流名称 | 描述 | 文件描述符编号 |'
- en: '| --- | --- | --- |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Standard input (stdin) | Data coming into a program as input | 0 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 标准输入（stdin） | 输入到程序中的数据 | 0 |'
- en: '| Standard output (stdout) | Data coming out of a program | 1 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 标准输出（stdout） | 从程序输出的数据 | 1 |'
- en: '| Standard error (stderr) | Errors coming out of a program | 2 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 标准错误（stderr） | 程序输出的错误信息 | 2 |'
- en: So far, we’ve run a few commands from the terminal and written and executed
    a simple script. The generated output was sent to the *standard output stream
    (stdout)*, or in other words, your terminal screen.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经从终端运行了一些命令，并编写并执行了一个简单的脚本。生成的输出被发送到了*标准输出流（stdout）*，换句话说，就是你的终端屏幕。
- en: Scripts can also receive commands as input. When a script is designed to receive
    input, it reads it from the *standard input stream (stdin)*. Finally, scripts
    may display error messages to the screen due to a bug or syntax error in the commands
    sent to it. These messages are sent to the *standard error stream (stderr)*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本也可以接收命令作为输入。当脚本被设计为接收输入时，它会从*标准输入流（stdin）*中读取输入。最后，脚本可能会由于命令中的 bug 或语法错误而向屏幕显示错误信息。这些信息会被发送到*标准错误流（stderr）*。
- en: 'To illustrate streams, we’ll use the mkdir command to create a few directories
    and then use ls to list the content of the current directory. Open your terminal
    and execute the following command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明流的概念，我们将使用 mkdir 命令来创建一些目录，然后使用 ls 来列出当前目录的内容。打开终端并执行以下命令：
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Notice that mkdir generates an error. This is because we pass the directory
    name *directory1* twice on the command line. So, when mkdir runs, it creates *directory1*
    and *directory2*, then fails on the third argument because, at that point, *directory1*
    has already been created. These types of errors are sent to the standard error
    stream.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 mkdir 生成了一个错误。这是因为我们在命令行中将目录名称*directory1*传递了两次。因此，当 mkdir 执行时，它创建了*directory1*和*directory2*，然后在第三个参数时失败，因为此时*directory1*已经被创建。这类错误会被发送到标准错误流。
- en: Next, we execute ls -l, which simply lists the directories. The result of the
    ls command succeeds without any specific errors, so it is sent to the standard
    output stream.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们执行 ls -l，这只是列出目录。ls 命令的结果成功执行，没有特定的错误，因此它被发送到标准输出流。
- en: You’ll practice working with the standard input stream when we introduce redirection
    in “Redirection Operators” on [page 18](#pg_18).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在我们介绍重定向时练习标准输入流的使用，具体内容在“重定向操作符”部分，见[第 18 页](#pg_18)。
- en: Control Operators
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制操作符
- en: '*Control operators* in bash are tokens that perform a control function. [Table
    1-3](chapter1.xhtml#tab1-3) gives an overview of control operators.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 中的*控制操作符*是执行控制功能的标记。[表 1-3](chapter1.xhtml#tab1-3)概述了控制操作符。
- en: 'Table 1-3: Bash Control Operators'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-3：Bash 控制操作符
- en: '| Operator | Description |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| & | Sends a command to the background. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| & | 将命令发送到后台。 |'
- en: '| && | Used as a logical AND. The second command in the expression will be
    evaluated only if the first command evaluates to true. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| && | 用作逻辑与。表达式中的第二个命令只有在第一个命令的结果为真时才会被执行。 |'
- en: '| (and) | Used for command grouping. |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| (和) | 用于命令分组。 |'
- en: '| ; | Used as a list terminator. A command following the terminator will run
    after the preceding command has finished, regardless of whether it evaluates to
    true or not. |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| ; | 用作列表终结符。一个命令在终结符后将运行，在前一个命令完成后，无论它的返回值是否为 true。 |'
- en: '| ;; | Ends a case statement. |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| ;; | 结束一个 case 语句。 |'
- en: '| &#124; | Redirects the output of a command as input to another command. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| &#124; | 将一个命令的输出重定向为另一个命令的输入。 |'
- en: '| &#124;&#124; | Used as a logical OR. The second command will run if the first
    one evaluates to false. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| &#124;&#124; | 用作逻辑 OR。第二个命令将在第一个命令返回 false 时运行。 |'
- en: Let’s see some of these control operators in action. The & operator sends a
    command to the background. If you have a list of commands to run, as in [Listing
    1-18](chapter1.xhtml#Lis1-18), sending the first command to the background will
    allow bash to continue to the next line even if the previous command hasn’t finished
    its work.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这些控制操作符的实际应用。& 操作符将命令发送到后台。如果你有一个命令列表要运行，如[列表 1-18](chapter1.xhtml#Lis1-18)所示，将第一个命令发送到后台可以让
    bash 继续执行下一行，即使前一个命令尚未完成其工作。
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Listing 1-18: Sending a command to the background so execution can move to
    the next line'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-18：将命令发送到后台，以便执行可以移动到下一行
- en: Commands that are long-running are often sent to the background to prevent scripts
    from hanging ❶. You’ll learn about sending commands to the background in more
    depth when we discuss job control in [Chapter 2](chapter2.xhtml).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间运行的命令通常会被发送到后台，以防止脚本挂起 ❶。当我们在[第 2 章](chapter2.xhtml)中讨论作业控制时，你将更深入地了解如何将命令发送到后台。
- en: 'The && operator allows us to perform an AND operation between two commands.
    In the following example, the file *test123* will be created only if the first
    command is successful:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '&& 操作符允许我们在两个命令之间执行 AND 操作。在以下示例中，只有第一个命令成功时，文件 *test123* 才会被创建：'
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The () operator allows us to group commands so they act a single unit when
    we need to redirect them together:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: () 操作符允许我们将多个命令分组，以便在需要一起重定向时将它们视为一个整体：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is generally useful when you need to redirect results from multiple commands
    to a stream, as shown in “Redirection Operators,” next.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常在你需要将多个命令的结果重定向到一个流时非常有用，正如接下来的“重定向操作符”中所示。
- en: 'The ; operator allows us to run multiple commands regardless of their exit
    status:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ; 操作符允许我们运行多个命令，而不管它们的退出状态：
- en: '[PRE47]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As a result, each command is executed one after the other, as soon as the previous
    one finishes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，每个命令都会在前一个命令完成后一个接一个地执行。
- en: 'The || operator allows us to chain commands together using an OR operation:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '|| 操作符允许我们通过 OR 操作将命令连接在一起：'
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this example, the echo command will be executed only if the first command
    fails.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，echo 命令只有在第一个命令失败时才会执行。
- en: Redirection Operators
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重定向操作符
- en: The three standard streams we highlighted earlier can be redirected from one
    program to another. *Redirection* is taking output from one command or script
    and using it as input to another script or file for writing purposes. [Table 1-4](chapter1.xhtml#tab1-4)
    describes the available redirection operators.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到的三个标准流可以从一个程序重定向到另一个程序。*重定向* 是将一个命令或脚本的输出作为另一个脚本或文件的输入，用于写入目的。[表 1-4](chapter1.xhtml#tab1-4)描述了可用的重定向操作符。
- en: 'Table 1-4: Redirection Operators'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-4：重定向操作符
- en: '| Operator | Description |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| > | Redirects stdout to a file |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| > | 将 stdout 重定向到一个文件 |'
- en: '| >> | Redirects stdout to a file by appending it to the existing content |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| >> | 将 stdout 重定向到一个文件，并将内容追加到现有内容中 |'
- en: '| &> or >& | Redirects stdout and stderr to a file |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| &> 或 >& | 将 stdout 和 stderr 重定向到文件 |'
- en: '| &>> | Redirects stdout and stderr to a file by appending them to the existing
    content |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| &>> | 将 stdout 和 stderr 重定向到一个文件，并追加到现有内容中 |'
- en: '| < | Redirects input to a command |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| < | 将输入重定向到一个命令 |'
- en: '| << | Called a here document, or heredoc, redirects multiple input lines to
    a command |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| << | 被称为 here 文档或 heredoc，将多行输入重定向到一个命令 |'
- en: '| &#124; | Redirects output of a command as input to another command |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| &#124; | 将一个命令的输出重定向为另一个命令的输入 |'
- en: 'Let’s practice using redirection operators to see how they work with standard
    streams. The > operator redirects the standard output stream to a file. Any command
    that precedes this character will send its output to the specified location. Run
    the following command directly in your terminal:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们练习使用重定向操作符，看看它们如何与标准流一起工作。> 操作符将标准输出流重定向到一个文件。任何在此字符之前的命令都会将其输出发送到指定的位置。直接在终端中运行以下命令：
- en: '[PRE49]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We redirect the standard output stream to a file named *output.txt*. To see
    the content of *output.txt*, simply run the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将标准输出流重定向到一个名为 *output.txt* 的文件中。要查看 *output.txt* 的内容，只需运行以下命令：
- en: '[PRE50]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Next, we’ll use the >> operator to append some content to the end of the same
    file ([Listing 1-19](chapter1.xhtml#Lis1-19)).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 >> 操作符将一些内容附加到同一个文件的末尾（见 [Listing 1-19](chapter1.xhtml#Lis1-19)）。
- en: '[PRE51]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Listing 1-19: Appending content to a file'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 1-19：将内容附加到文件中
- en: If we had used > instead of >>, the content of *output.txt* would have been
    overwritten completely with the Goodbye! text.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 > 而不是 >>，*output.txt* 的内容将被 Goodbye! 文本完全覆盖。
- en: 'You can redirect both the standard output stream and the standard error stream
    to a file by using &>. This is useful when you don’t want to send any output to
    the screen and instead save everything in a logfile (perhaps for later analysis):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 &> 将标准输出流和标准错误流都重定向到一个文件中。当你不希望将任何输出发送到屏幕，而是将所有内容保存到日志文件中（可能供以后分析）时，这非常有用：
- en: '[PRE52]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: To append both the standard output and standard error streams to a file, use
    the ampersand followed by the double chevron (&>>).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要将标准输出流和标准错误流都附加到文件中，可以使用与符号后跟双箭头 (&>>)。
- en: 'What if we want to send the standard output stream to one file and the standard
    error stream to another? This is also possible using the streams’ file descriptor
    numbers:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将标准输出流发送到一个文件，而将标准错误流发送到另一个文件呢？使用流的文件描述符编号，也可以做到这一点：
- en: '[PRE53]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You may sometimes find it useful to redirect the standard error stream to a
    file, as we’ve done here, so you can log any errors that occur during runtime.
    The next example runs a nonexistent command, lzl. This should generate bash errors
    that will be written into the *error.txt* file:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会发现将标准错误流重定向到文件中非常有用，就像我们在这里所做的那样，这样你可以记录运行时发生的任何错误。下一个示例运行了一个不存在的命令 lzl。这应该会生成
    bash 错误，并将其写入 *error.txt* 文件：
- en: '[PRE54]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Notice that you don’t see the error onscreen because bash sends the error to
    the file instead.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，屏幕上看不到错误信息，因为 bash 将错误信息发送到了文件中。
- en: Next, let’s use the standard input stream. Run the command in [Listing 1-20](chapter1.xhtml#Lis1-20)
    in the shell to supply the contents of *output.txt* as input to the cat command.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用标准输入流。在 shell 中运行 [Listing 1-20](chapter1.xhtml#Lis1-20) 中的命令，将 *output.txt*
    的内容作为输入提供给 cat 命令。
- en: '[PRE55]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Listing 1-20: Using a file as a command’s input'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 1-20：使用文件作为命令的输入
- en: What if we want to redirect multiple lines to a command? Here document redirection
    (<<) can help with this ([Listing 1-21](chapter1.xhtml#Lis1-21)).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将多行内容重定向到一个命令呢？此时，可以使用文档重定向（<<）来帮助完成这项操作（见 [Listing 1-21](chapter1.xhtml#Lis1-21)）。
- en: '[PRE56]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Listing 1-21: Here document redirection'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 1-21：文档重定向
- en: In this example, we pass multiple lines as input to a command. The EOF in this
    example acts as a delimiter, marking the start and end points of the input. *Here
    document redirection* treats the input as if it were a separate file, preserving
    line breaks and whitespace.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将多行作为输入传递给一个命令。示例中的 EOF 起到了分隔符的作用，标记了输入的起始和结束位置。*文档重定向* 将输入当作独立文件处理，保留了换行符和空格。
- en: The *pipe* operator (|) redirects the output of one command and uses it as the
    input of another. For example, we could run the ls command on the root directory
    and then use another command to extract data from it, as shown in [Listing 1-22](chapter1.xhtml#Lis1-22).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*管道* 操作符 (|) 将一个命令的输出重定向，并将其作为另一个命令的输入。例如，我们可以在根目录下运行 ls 命令，然后使用另一个命令从中提取数据，如
    [Listing 1-22](chapter1.xhtml#Lis1-22) 所示。'
- en: '[PRE57]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Listing 1-22: Piping command output into another command'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 1-22：将命令输出通过管道传递到另一个命令
- en: We use ls to print the content of the root directory into the standard output
    stream, then use a pipe to send it as input to the grep command, which filters
    out any lines containing the word *bin*.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 ls 打印根目录的内容到标准输出流中，然后使用管道将其作为输入传递给 grep 命令，后者会过滤掉包含 *bin* 的行。
- en: Positional Arguments
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位置参数
- en: Bash scripts can take *positional arguments* (also called *parameters*) passed
    on the command line. Arguments are especially useful, for example, when you want
    to develop a program that modifies its behavior based on input passed to it by
    another program or user. Arguments can also change features of the script such
    as the output format and how verbose it will be during runtime.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 脚本可以接收 *位置参数*（也称为 *参数*），这些参数由命令行传递给脚本。参数尤其有用，例如，当你希望开发一个程序，使其根据其他程序或用户传递的输入改变行为时。参数还可以改变脚本的特性，比如输出格式或运行时的详细程度。
- en: For example, imagine you develop an exploit and send it to a few colleagues,
    each of whom will use it against a different IP address. Instead of writing a
    script and asking the user to modify it with their network information, you can
    write it to take an IP address argument and then act against this input to avoid
    having to modify the source code in each case.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你开发了一个漏洞并将其发送给几个同事，他们每个人将针对不同的IP地址使用它。你可以编写一个脚本，接受IP地址参数，然后根据该输入执行操作，避免在每次情况下都需要修改源代码。
- en: A bash script can access arguments passed to it on the command line by using
    the variables $1, $2, and so on. The number represents the order in which the
    argument was entered. To illustrate this, the script in [Listing 1-23](chapter1.xhtml#Lis1-23)
    takes in an argument (an IP address or domain name) and performs a ping test against
    it by using the ping utility. Save this file as *ping_with_arguments.sh*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一个bash脚本可以使用变量$1、$2等来访问传递给它的命令行参数。数字代表参数输入的顺序。为了说明这一点，[列表 1-23](chapter1.xhtml#Lis1-23)中的脚本接受一个参数（IP地址或域名），并使用ping工具对其执行ping测试。将此文件保存为*ping_with_arguments.sh*。
- en: ping_with _arguments.sh
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ping_with_arguments.sh
- en: '[PRE58]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Listing 1-23: A script that accepts command line input'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-23：一个接受命令行输入的脚本
- en: This script assigns the first positional argument to the variable TARGET. Notice,
    also, that the argument ${0} is assigned to the SCRIPT_NAME variable. This argument
    contains the script’s name (in this case, *ping_with_arguments.sh*).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本将第一个位置参数赋值给变量TARGET。同时，还要注意，参数${0}被赋值给SCRIPT_NAME变量。这个参数包含脚本的名称（在本例中是*ping_with_arguments.sh*）。
- en: To run this script, use the commands in [Listing 1-24](chapter1.xhtml#Lis1-24).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此脚本，请使用[列表 1-24](chapter1.xhtml#Lis1-24)中的命令。
- en: '[PRE59]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Listing 1-24: Passing arguments to a script'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-24：将参数传递给脚本
- en: This script will perform a ping command against the domain *nostarch.com* passed
    to it on the command line. The value is assigned to the $1 variable; if we passed
    another argument, it would get assigned to the second variable, $2. Use CTRL-C
    to exit this script, as ping may run indefinitely on some operating systems.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本将执行针对命令行传递的域名*nostarch.com*的ping命令。该值被赋值给$1变量；如果传递了另一个参数，它将被赋值给第二个变量$2。使用CTRL-C退出此脚本，因为在某些操作系统上，ping命令可能会无限运行。
- en: What if you want to access all arguments? You can do so using the variable $@.
    Also, using $#, you can get the total number of arguments passed. [Listing 1-25](chapter1.xhtml#Lis1-25)
    demonstrates how this works.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想访问所有参数怎么办？你可以使用变量$@来实现。另外，使用$#，你可以获取传递的参数总数。[列表 1-25](chapter1.xhtml#Lis1-25)展示了这一过程是如何工作的。
- en: '[PRE60]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Listing 1-25: Retrieving all arguments and the total number of arguments'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-25：检索所有参数及参数总数
- en: 'Save this script to a file named *show_args.sh* and run it as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本保存为名为*show_args.sh*的文件，并按如下方式运行：
- en: '[PRE61]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[Table 1-5](chapter1.xhtml#tab1-5) summarizes the variables related to positional
    arguments.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 1-5](chapter1.xhtml#tab1-5)总结了与位置参数相关的变量。'
- en: 'Table 1-5: Special Variables Related to Positional Arguments'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 1-5：与位置参数相关的特殊变量
- en: '| Variable | Description |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| $0 | The name of the script file |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| $0 | 脚本文件的名称 |'
- en: '| $1, $2, $3, ... | Positional arguments |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| $1, $2, $3, ... | 位置参数 |'
- en: '| $# | The number of passed positional arguments |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| $# | 传递的定位参数的数量 |'
- en: '| $* | All positional arguments |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| $* | 所有位置参数 |'
- en: '| $@ | All positional arguments, where each argument is individually quoted
    |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| $@ | 所有位置参数，每个参数单独引用 |'
- en: 'When a script uses "$*" with the quotes included, bash will expand arguments
    into a single word. For instance, the following example groups the arguments into
    one word:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本使用"$*"（包括引号）时，bash会将所有参数展开成一个单一的词。例如，以下示例将参数组合成一个词：
- en: '[PRE62]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When a script uses "$@" (again including the quotes), it will expand arguments
    into separate words:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本使用"$@"（包括引号）时，它会将参数展开成单独的词：
- en: '[PRE63]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In most cases, you will want to use "$@" so that every argument is treated as
    an individual word.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你会想使用"$@"，这样每个参数都会被当作一个独立的词来处理。
- en: 'The following script demonstrates how to use these special variables in a for
    loop:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本演示了如何在for循环中使用这些特殊变量：
- en: '[PRE64]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Input Prompting
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入提示
- en: Some bash scripts don’t take any arguments during execution. However, they may
    need to ask the user for information in an interactive way and have the response
    feed into their runtime. In these cases, we can use the read command. You often
    see applications use *input prompting* when attempting to install software, asking
    the user to enter *yes* to proceed or *no* to cancel the operation.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 bash 脚本在执行时不接受任何参数。然而，它们可能需要以交互方式向用户请求信息，并将响应输入到其运行时中。在这些情况下，我们可以使用 read
    命令。在尝试安装软件时，经常会看到应用程序使用 *输入提示* 要求用户输入 *yes* 以继续或 *no* 以取消操作。
- en: In the bash script in [Listing 1-26](chapter1.xhtml#Lis1-26), we ask the user
    for their first and last names and then print these to the standard output stream.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Listing 1-26](chapter1.xhtml#Lis1-26) 中的 bash 脚本中，我们要求用户输入他们的名和姓，然后将这些信息打印到标准输出流中。
- en: input _prompting.sh
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: input _prompting.sh
- en: '[PRE65]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Listing 1-26: Prompting a user for input'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 1-26: 向用户询问输入'
- en: 'Save and run this script as *input_prompting.sh*:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本保存并运行为 *input_prompting.sh*：
- en: '[PRE66]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Notice that you are prompted to enter information that then gets printed.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，系统会提示您输入信息，然后将其打印出来。
- en: Exit Codes
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 退出码
- en: Bash commands return *exit codes*, which indicate whether the execution of the
    command succeeded. Exit codes fall in the 0 to 255 range, where 0 means success,
    1 means failure, 126 means that the command was found but is not executable, and
    127 means the command was not found. The meaning of any other number depends on
    the specific command being used and its logic.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 命令返回 *退出码*，这些代码指示命令的执行是否成功。退出码范围在 0 到 255 之间，其中 0 表示成功，1 表示失败，126 表示找到命令但不可执行，127
    表示未找到命令。任何其他数字的含义取决于使用的具体命令及其逻辑。
- en: Checking Exit Codes
  id: totrans-332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查退出码
- en: To see exit codes in action, save the script in [Listing 1-27](chapter1.xhtml#Lis1-27)
    to a file named *exit_codes.sh* and run it.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看退出码的实际效果，请将 [Listing 1-27](chapter1.xhtml#Lis1-27) 中的脚本保存到名为 *exit_codes.sh*
    的文件中并运行它。
- en: '[PRE67]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Listing 1-27: Using exit codes to determine a command’s success'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 1-27: 使用退出码确定命令的成功'
- en: We use the special variable $? with the echo command to return the exit codes
    of the executed commands ls and lzl. We also redirect their standard output and
    standard error streams to the file */dev/null*, a special device file that discards
    any data sent to it. When you want to silence commands, you can redirect their
    output to it.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 echo 命令与特殊变量 $? 来返回执行命令 ls 和 lzl 的退出码。我们还将它们的标准输出和标准错误流重定向到文件 */dev/null*，这是一个特殊设备文件，用于丢弃发送到它的任何数据。当您希望静音命令时，可以将其输出重定向到此处。
- en: 'You should see output like the following:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到如下输出：
- en: '[PRE68]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We receive two distinct exit codes, one for each command. The first command
    returns 0 (success), and the second returns 127 (command not found).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到两个不同的退出码，一个用于每个命令。第一个命令返回 0（成功），第二个返回 127（未找到命令）。
- en: WARNING
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 警告
- en: '*Use* /dev/null *with caution. You may miss out on important errors if you
    choose to redirect output to it. When in doubt, redirect standard streams such
    as standard output and standard error to a dedicated logfile instead.*'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '*谨慎使用* /dev/null *。如果选择将输出重定向到其中，您可能会错过重要的错误信息。如果有疑问，请将标准输出和标准错误流重定向到专用日志文件中。*'
- en: To understand why you might want to use exit codes, imagine you’re trying to
    download a 1GB file from the internet by using bash. It might be wise to first
    check whether the file already exists on the filesystem in case someone ran the
    script and retrieved it. Also, you might want to check that you have enough free
    space on the disk before attempting the download. By running commands and looking
    at their returned exit codes, you can decide whether to proceed with the file
    download.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解为什么要使用退出码，请想象一下，您正在尝试使用 bash 从互联网下载 1GB 文件。在尝试下载之前，先检查文件系统中是否已存在该文件可能是明智的选择。此外，您可能需要检查磁盘上是否有足够的空闲空间。通过运行命令并查看它们返回的退出码，您可以决定是否继续进行文件下载。
- en: Setting a Script’s Exit Code
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置脚本的退出码
- en: You can set the exit code of a script by using the exit command followed by
    the code number, as shown in [Listing 1-28](chapter1.xhtml#Lis1-28).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 exit 命令后跟代码编号来设置脚本的退出码，如 [Listing 1-28](chapter1.xhtml#Lis1-28) 所示。
- en: '[PRE69]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Listing 1-28: Setting a script’s exit code'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 1-28: 设置脚本的退出码'
- en: 'Save this script as *set_exit_code.sh* and run it on the command line. Then
    use the special variable $? to see the exit code it returns:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本保存为 *set_exit_code.sh* 并在命令行上运行它。然后使用特殊变量 $? 来查看它返回的退出码：
- en: '[PRE70]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You can use the $? variable to check the returned exit code not only of a script
    but also of individual commands:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `$?` 变量检查不仅是脚本的返回退出码，还可以检查单个命令的退出码：
- en: '[PRE71]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Exit codes are important; they can be used in a series of scripts that call
    one another or within the same script, to control the logical flow of the code
    execution.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 退出码很重要；它们可以用于一系列相互调用的脚本或同一个脚本内，以控制代码执行的逻辑流程。
- en: 'Exercise 1: Recording Your Name and the Date'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 1：记录你的姓名和日期
- en: 'Write a script that does the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个脚本，实现以下功能：
- en: 1.  Accepts two arguments on the command line and assigns them to variables.
    The first argument should be your first name, and the second should be your last
    name.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 接受命令行上的两个参数，并将它们赋值给变量。第一个参数应为你的名字，第二个应为你的姓氏。
- en: 2.  Creates a new file named *output.txt*.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 创建一个名为 *output.txt* 的新文件。
- en: 3.  Writes the current date to *output.txt* by using the date command. (Bonus
    points if you can make the date command print the date in the DD-MM-YYYY format;
    use man date to learn how this works.)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 使用 `date` 命令将当前日期写入 *output.txt*。（如果你能让 `date` 命令以 DD-MM-YYYY 格式输出日期，可以获得加分；使用
    man date 了解如何实现。）
- en: 4.  Writes your full name to *output.txt*.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 将你的全名写入 *output.txt*。
- en: 5.  Makes a backup copy of *output.txt*, named *backup.txt*, using the cp command.
    (Use man cp if you aren’t sure of the command’s syntax.)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 使用 `cp` 命令制作 *output.txt* 的备份副本，命名为 *backup.txt*。（如果你不确定命令的语法，可以使用 man cp
    查阅帮助。）
- en: 6.  Prints the content of the *output.txt* file to the standard output stream.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 将 *output.txt* 文件的内容打印到标准输出流。
- en: You can find an example solution, *exercise_solution.sh*, in the book’s GitHub
    repository.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 GitHub 仓库中找到一个示例解答，名为 *exercise_solution.sh*。
- en: Summary
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you ran simple Linux commands in the terminal and used man
    to learn about command options. You also learned how to pass arguments to scripts
    and execute a sequence of commands from within scripts. We covered the fundamentals
    of bash, such as how to write basic programs that use variables, arrays, redirects,
    exit codes, and arguments. You also learned how to prompt the user to enter arbitrary
    information and use it as part of a script’s flow.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你在终端中运行了简单的 Linux 命令，并使用 man 学习了命令选项。你还学习了如何向脚本传递参数并从脚本中执行一系列命令。我们讲解了 bash
    的基础知识，比如如何编写使用变量、数组、重定向、退出码和参数的基本程序。你还学会了如何提示用户输入任意信息，并将其作为脚本流程的一部分使用。
