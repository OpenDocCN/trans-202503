- en: Chapter 14. Web APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章 Web API
- en: Eventually, you might want to expand your application beyond your website. Popular
    web applications usually also have a native mobile client and sometimes even a
    desktop client. You may also want to integrate data from your application with
    other websites and applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你可能希望将应用程序的范围扩展到网站之外。流行的Web应用程序通常还拥有一个本地移动客户端，有时甚至还有桌面客户端。你可能还希望将应用程序中的数据与其他网站和应用程序集成。
- en: A web *application programming interface* (or *API*) makes all of these things
    possible. Think of an API as a language that applications use to communicate with
    each other. On the Web, the API is usually a REST protocol using JavaScript Object
    Notation (JSON) messages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网页*应用程序编程接口*（或*API*）使这一切成为可能。可以将API看作是应用程序之间进行通信的语言。在Web上，API通常是使用JavaScript对象表示法（JSON）消息的REST协议。
- en: In this chapter, we’ll explore the GitHub API to see how to access detailed
    information about users and repositories. After discussing GitHub’s API, you’ll
    build your own. In the process, I’ll cover details such as JSON, the Hypertext
    Transfer Protocol (HTTP), and token-based authentication.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨GitHub API，了解如何访问有关用户和仓库的详细信息。在讨论GitHub的API后，你将构建自己的API。在此过程中，我将讲解JSON、超文本传输协议（HTTP）和基于令牌的身份验证等细节。
- en: The GitHub API
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitHub API
- en: The GitHub code-hosting service has an extensive API. Many of its features are
    even available without authentication. If you want to continue exploring the GitHub
    API after working through the examples in this chapter, complete details are available
    online at *[https://developer.github.com/](https://developer.github.com/)*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub代码托管服务拥有一个广泛的API。它的许多功能甚至无需身份验证即可使用。如果你在本章的示例讲解后，想继续探索GitHub API，完整的文档可以在线查阅，地址为*[https://developer.github.com/](https://developer.github.com/)*。
- en: 'The GitHub API provides easy access to data about users, organizations, repositories,
    and other site features. For example, go to *[https://api.github.com/orgs/rails/](https://api.github.com/orgs/rails/)*
    in your web browser to see the Rails organization on GitHub:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub API提供了对有关用户、组织、仓库和其他站点功能数据的便捷访问。例如，访问*[https://api.github.com/orgs/rails/](https://api.github.com/orgs/rails/)*，你可以在浏览器中查看GitHub上的Rails组织：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The data returned should be at least partially familiar to anyone who’s worked
    with Rails models. You’ll see fields for `id` ➊, `created_at` ➌, and `updated_at`
    ➍, as seen in all of the models you’ve created so far. The GitHub API also includes
    several `url` fields ➋ that you can use to access more data about the organization.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的数据对于任何与Rails模型打过交道的人来说，应该至少部分是熟悉的。你将看到`id` ➊、`created_at` ➌和`updated_at`
    ➍等字段，这些字段在你迄今为止创建的所有模型中都有。GitHub API还包括几个`url`字段 ➋，你可以使用它们来访问有关组织的更多数据。
- en: For example, go to the `repos_url` (*[https://api.github.com/orgs/rails/repos/](https://api.github.com/orgs/rails/repos/)*)
    to see a list of source code repositories belonging to the Rails organization.
    From there, you can access the details of an individual repository by going to
    its `url`, such as *[https://api.github.com/repos/rails/rails/](https://api.github.com/repos/rails/rails/)*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，访问`repos_url`（*[https://api.github.com/orgs/rails/repos/](https://api.github.com/orgs/rails/repos/)）查看属于Rails组织的源代码仓库列表。从那里，你可以通过访问其`url`来查看单个仓库的详细信息，例如*[https://api.github.com/repos/rails/rails/](https://api.github.com/repos/rails/rails/)*。
- en: Go to *[https://api.github.com/users/username/](https://api.github.com/users/username/)*
    to access information about an individual user. To see my GitHub account, visit
    *[https://api.github.com/users/anthonylewis/](https://api.github.com/users/anthonylewis/)*
    in your browser.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 访问*[https://api.github.com/users/username/](https://api.github.com/users/username/)*可以获取有关单个用户的信息。要查看我的GitHub账户，请在浏览器中访问*[https://api.github.com/users/anthonylewis/](https://api.github.com/users/anthonylewis/)*。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The data returned by these requests is in* JavaScript Object Notation (JSON)
    *format, which is based on a subset of the JavaScript programming language. In
    JSON format, data between curly braces is a single JavaScript object with various
    named properties. Each property consists of a name, followed by a colon, and the
    property value. This format is quite similar to a hash in Ruby.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*这些请求返回的数据是* JavaScript对象表示法（JSON）*格式的，它基于JavaScript编程语言的一个子集。在JSON格式中，大括号之间的数据是一个包含多个命名属性的JavaScript对象。每个属性由名称、后跟冒号以及属性值组成。此格式与Ruby中的哈希结构非常相似。*'
- en: In addition to the simple requests for data you’ve made so far, the GitHub API
    also supports creating and updating objects using the appropriate requests. These
    actions require authentication, of course. But before I can cover API authentication,
    I need to tell you a little more about HTTP.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你目前为止所做的简单数据请求外，GitHub API 还支持使用适当的请求创建和更新对象。当然，这些操作需要身份验证。但在我讲解 API 身份验证之前，我需要先给你多讲一点
    HTTP 的内容。
- en: HTTP
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP
- en: HTTP is the language of the Web. Web servers and browsers use this protocol
    to communicate. I’ve discussed some aspects of HTTP already, such as the HTTP
    verbs (GET, POST, PATCH, and DELETE), while covering the REST architecture in
    [Chapter 4](ch04.html "Chapter 4. Controllers").
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 是 Web 的语言。Web 服务器和浏览器使用该协议进行通信。我已经讨论了一些 HTTP 的方面，例如 HTTP 动词（GET、POST、PATCH
    和 DELETE），同时在[第 4 章](ch04.html "第 4 章. 控制器")中讲解了 REST 架构。
- en: In addition to the data you’ve seen so far, an HTTP response also contains a
    header with more detailed information. You’re probably familiar with part of the
    data in an HTTP response header. Anyone who’s spent any time on the Web has probably
    seen a 404 or 500 response from a web server. Status codes such as these are included
    in every response from a web server.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你目前看到的数据外，HTTP 响应还包含一个包含更多详细信息的头部。你可能熟悉 HTTP 响应头部中的部分数据。任何在 Web 上呆过一段时间的人可能都见过来自
    Web 服务器的 404 或 500 响应。像这样的状态码会包含在 Web 服务器的每个响应中。
- en: Status Codes
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态码
- en: The first line of every response includes an HTTP status code. This three-digit
    numeric code tells the client the type of response to expect.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个响应的第一行都会包含一个 HTTP 状态码。这个三位数字代码告诉客户端应该期待什么类型的响应。
- en: 'Status codes are broken up into five categories based on their first digit:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 状态码根据其首位数字分为五个类别：
- en: 1*xx* Informational
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1*xx* 信息性
- en: 2*xx* Success
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2*xx* 成功
- en: 3*xx* Redirection
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3*xx* 重定向
- en: 4*xx* Client Error
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4*xx* 客户端错误
- en: 5*xx* Server Error
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5*xx* 服务器错误
- en: You shouldn’t encounter any status codes in the 1*xx* range while working with
    APIs. The original HTTP 1.0 specification did not define any codes in this range,
    and in my experience, they are rarely used.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 API 时，你不应该遇到 1*xx* 范围的状态码。原始的 HTTP 1.0 规范并没有定义此范围的任何状态码，在我的经验中，这些状态码很少使用。
- en: Status codes in the 2*xx* range indicate a successful request. Hopefully, you’ll
    encounter many of these. Common codes include *200 OK,* which indicates a successful
    response, typically to a GET request; *201 Created,* which is returned when an
    object is created on the server in response to a POST request; and *204 No Content,*
    which indicates that a request was successful, but there is no additional data
    in the response.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 2*xx* 范围内的状态码表示请求成功。希望你能遇到许多这样的状态码。常见的代码包括 *200 OK*，表示成功的响应，通常是针对 GET 请求的；*201
    Created*，当对象在服务器上被创建以响应 POST 请求时返回；以及 *204 No Content*，表示请求成功，但响应中没有附加数据。
- en: The 3*xx* range of status codes indicates a redirect to a different address.
    Rails issues a *302 Found* response any time you use `redirect_to` in your application.
    To see this in action, log in to your application and watch the log for the redirect.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 3*xx* 范围的状态码表示重定向到其他地址。每当你在应用程序中使用 `redirect_to` 时，Rails 会返回 *302 Found* 响应。要查看这个过程，登录到你的应用程序并查看重定向日志。
- en: Status codes in the 4*xx* range indicate some kind of client error. In other
    words, the user made a mistake. *401 Unauthorized* is returned in response to
    a request for a URL that requires authentication. The *403 Forbidden* status code
    is similar to 401, except the server will not complete the request even if the
    client successfully authenticates. The *404 Not Found* is sent when a client attempts
    to access a URL that does not exist. As you work with APIs, you may encounter
    the *406 Not Acceptable* status code for an invalid request or the *422 Unprocessable
    Entity* status code, which means the request is valid, but the included data could
    not be processed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 4*xx* 范围的状态码表示某种客户端错误。换句话说，用户犯了错误。*401 Unauthorized* 会在请求需要身份验证的 URL 时返回。*403
    Forbidden* 状态码与 401 相似，只是即使客户端成功进行身份验证，服务器也不会完成请求。*404 Not Found* 会在客户端尝试访问一个不存在的
    URL 时发送。当你与 API 打交道时，可能会遇到 *406 Not Acceptable* 状态码，这表示请求无效，或者遇到 *422 Unprocessable
    Entity* 状态码，这表示请求有效，但附带的数据无法处理。
- en: The 5*xx* range of status codes indicates an error on the server. The *500 Internal
    Server Error* code is the most commonly used. It is a general message that does
    not provide any additional data. The *503 Service Unavailable* status code indicates
    a temporary problem with the server.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 5*xx*状态码范围表示服务器错误。*500 内部服务器错误*代码是最常用的。这是一个通用消息，不提供任何额外的数据。*503 服务不可用*状态码表示服务器的临时问题。
- en: To see these codes, you need to examine the HTTP header sent with a response.
    These are not normally displayed by web browsers. Luckily, tools exist that make
    examining HTTP headers easy. One of the most popular is the command-line program
    known as Curl.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这些代码，您需要检查随响应一起发送的HTTP头部。这些通常不会在网页浏览器中显示。幸运的是，有一些工具可以轻松检查HTTP头部。其中最受欢迎的工具之一是命令行程序Curl。
- en: Curl
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Curl
- en: Curl is a free command-line tool for network communication. Curl is included
    with Mac OS X and Linux, and Windows users can download the tool from *[http://curl.haxx.se/](http://curl.haxx.se/)*.
    Curl uses URL syntax, making it an ideal tool for testing web APIs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Curl是一个免费的命令行网络通信工具。Curl包含在Mac OS X和Linux中，Windows用户可以从*[http://curl.haxx.se/](http://curl.haxx.se/)*下载该工具。Curl使用URL语法，因此是测试Web
    API的理想工具。
- en: Open a terminal window and try a few `curl` commands. Let’s start with the GitHub
    API you just looked at.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端窗口并尝试一些`curl`命令。我们从刚才查看过的GitHub API开始。
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This example shows how to retrieve information about a particular user account
    from GitHub. Curl only shows the response data by default; enter **`curl -i`**
    to include the HTTP headers with the response:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了如何从GitHub获取特定用户账户的信息。默认情况下，Curl只显示响应数据；输入**`curl -i`**以将HTTP头部包含在响应中：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The response headers start with the status code of `200 OK` ➊. Also note that
    GitHub API requests are rate limited. The `X-RateLimit-Limit: 60` line ➋ indicates
    that you are limited to 60 requests over a certain period of time. The next line
    says you have 58 requests remaining. Your rate limit resets automatically at the
    time given by the `X-RateLimit-Reset: 1397696651` line ➌.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '响应头部以`200 OK`状态码开始➊。还要注意，GitHub API请求是有速率限制的。`X-RateLimit-Limit: 60`这一行➋表示您在一定时间内最多可以发送60次请求。下一行显示您还剩余58次请求。您的速率限制将在`X-RateLimit-Reset:
    1397696651`这一行➌指定的时间自动重置。'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The number `1397696651` is a Unix timestamp. You can convert it to a normal
    time by entering `Time.at 1397696651` in an IRB session or Rails console.*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*数字`1397696651`是一个Unix时间戳。您可以通过在IRB会话或Rails控制台中输入`Time.at 1397696651`来将其转换为正常时间。*'
- en: Authentication
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证
- en: So far, you’ve only read public data from the GitHub API. You can also use the
    GitHub API to read private data about users and repositories and to create or
    update information, but these actions require authentication.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您只从GitHub API读取了公共数据。您还可以使用GitHub API读取有关用户和仓库的私人数据，以及创建或更新信息，但这些操作需要身份验证。
- en: I covered user authentication in [Chapter 9](ch09.html "Chapter 9. Authentication").
    Users expect to log in to an application once and then browse a site for some
    time. You maintain a user’s log in state in the session, which is stored in a
    cookie that the browser automatically includes with every request.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第9章](ch09.html "第9章. 身份验证")中讲解了用户身份验证。用户期望一次登录后就能在一段时间内浏览网站。您通过会话保持用户的登录状态，会话存储在一个浏览器会自动随每个请求一起发送的cookie中。
- en: API requests don’t maintain a session. Applications accessing an API need to
    provide authentication credentials with each request. A popular choice for API
    requests is *token-based authentication*. In token-based authentication, users
    include a unique API token with each request.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: API请求不会保持会话状态。访问API的应用程序需要在每次请求中提供身份验证凭据。一个常见的API请求身份验证方法是*基于令牌的身份验证*。在基于令牌的身份验证中，用户在每次请求中都包含一个唯一的API令牌。
- en: You can use the `curl` command to test token-based authentication on GitHub.
    First, you need to generate a personal access token on GitHub’s Application Settings
    page. Log in to GitHub, if necessary, and go to *[https://github.com/settings/applications/](https://github.com/settings/applications/)*.
    On that page, click the **Generate New Token** button. Next, you provide a description
    for this token; something like API Testing should be fine. Finally, confirm that
    the checkboxes beside “repo” and “user” are checked, and click the **Generate
    Token** Button.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`curl`命令测试GitHub上的基于令牌的身份验证。首先，您需要在GitHub的应用设置页面生成一个个人访问令牌。如果需要，请登录GitHub，并访问
    *[https://github.com/settings/applications/](https://github.com/settings/applications/)*。在该页面，点击**生成新令牌**按钮。接下来，您为该令牌提供一个描述；类似于API测试的名称就可以。最后，确认“repo”和“user”旁边的复选框已选中，然后点击**生成令牌**按钮。
- en: GitHub should take you back to the Application Settings page and present you
    with a new 40-digit hexadecimal token. Copy your new token and paste it into a
    text file so you can keep up with it. As the on-screen message says, you won’t
    be able to see it again!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub应该将您带回应用设置页面，并展示一个新的40位十六进制令牌。复制您的新令牌并粘贴到文本文件中，以便随时查看。正如屏幕上的信息所说，您将无法再次看到它！
- en: 'To verify your token is working, enter the following `curl` command in your
    terminal. Replace the word ***`token`*** with your actual token in all of these
    requests:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证您的令牌是否有效，请在终端中输入以下`curl`命令。将***`token`***替换为您在所有请求中实际使用的令牌：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, I’ve used the `-H` parameter to `curl` to pass custom header data to
    the server, and, in this case, that data is the `Authorization: Token` header
    followed by my token.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我使用了`-H`参数传递给`curl`，用于向服务器传递自定义头数据，在这种情况下，数据是`Authorization: Token`头后跟我的令牌。'
- en: You should see information about your own account, even though you didn’t specify
    a username. GitHub uses your personal access token to authenticate the request.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您没有指定用户名，您也应该看到关于您自己账户的信息。GitHub使用您的个人访问令牌来验证请求。
- en: You can now use the token to access private information, such as the list of
    Git repositories associated with your account.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用该令牌访问私密信息，例如与您的账户关联的Git仓库列表。
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: GitHub should return an array of repositories created with your account. Depending
    on how many repositories you’ve created, this could be a lot of data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub应该返回一个包含您账户创建的仓库的数组。根据您创建的仓库数量，这可能会是大量数据。
- en: Now that you have a token, you can also add another repository to your account
    using a POST request. As you learned in [Chapter 4](ch04.html "Chapter 4. Controllers"),
    POST means *create* in REST.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您已经有了令牌，您还可以通过POST请求将另一个仓库添加到您的账户中。正如您在[第4章](ch04.html "第4章. 控制器")中所学到的，POST在REST中意味着*创建*。
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `-d` option to `curl` specifies data to be included with the request. Here,
    you send a JSON string with the name `"API Test"` for the new repository ➊. Because
    you’re sending data, `curl` automatically uses a POST request. GitHub responds
    to the request with headers indicating HTTP status `201 Created` ➋, followed by
    information about the newly created repository ➌.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d`选项用于`curl`指定请求中包含的数据。在这里，您发送一个JSON字符串，其中包含名称为“API Test”的新仓库 ➊。因为您正在发送数据，`curl`会自动使用POST请求。GitHub会对请求作出响应，返回指示HTTP状态`201
    Created`的头信息 ➋，随后返回关于新创建仓库的信息 ➌。'
- en: Now that you have some experience with an existing API, let’s create our own
    API for our social application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对现有的API有了一些经验，我们来为我们的社交应用创建一个自己的API。
- en: Your Own API
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的个人 API
- en: You may remember from [Chapter 4](ch04.html "Chapter 4. Controllers") that the
    Rails scaffold generator used the `respond_to` method inside the `PostsController`
    to return different data based on the type of request. This approach is fine for
    some applications, but the addition of user authentication and sessions in your
    application leads to problems.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得在[第4章](ch04.html "第4章. 控制器")中，Rails的脚手架生成器在`PostsController`中使用了`respond_to`方法，根据请求类型返回不同的数据。这种方法对于某些应用程序是可以的，但当您在应用中加入用户身份验证和会话管理时，就会出现问题。
- en: The existing controllers authenticate users by calling the `authenticate_user!`
    method before every action. Your API will use a different method to support token-based
    authentication. The existing controllers also display data, such as posts, based
    on the value of `current_user`. Your API will display all posts when requested.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的控制器通过在每个动作之前调用`authenticate_user!`方法来进行用户身份验证。您的API将使用不同的方法来支持基于令牌的身份验证。现有的控制器还根据`current_user`的值展示数据，如帖子。您的API将在请求时展示所有帖子。
- en: Rather than use the same controllers for the application and the API, you can
    build separate controllers for each. Because your application is mainly about
    posts, you’ll start there when building your API.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用相同的控制器来处理应用程序和API，你可以为每个构建单独的控制器。由于你的应用程序主要是关于帖子的，所以你可以从构建API的帖子控制器开始。
- en: API Routes
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API路由
- en: 'Start by adding routes for API requests. The GitHub API used a subdomain for
    API requests. Because you haven’t set up your own domain, you’ll use a separate
    path for API requests. Open the file *config/routes.rb* and add the following
    block near the end:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先添加API请求的路由。GitHub API使用子域来处理API请求。由于你尚未设置自己的域名，因此你将使用一个单独的路径来处理API请求。打开文件*config/routes.rb*，并在文件末尾添加以下代码块：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `namespace :api` block ➊ indicates that all routes created for the resources
    it contains start with the path *api/*. Additionally, the controller files for
    those resources should be inside a directory named *api*, and the controller classes
    should be inside a module named `Api`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`namespace :api`块 ➊ 表示为其包含的资源创建的所有路由路径都以*api/*开头。此外，这些资源的控制器文件应该位于一个名为*api*的目录中，并且控制器类应该在一个名为`Api`的模块内。'
- en: You can enter the `bin/rake routes` command in a terminal to see the newly created
    routes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在终端中输入`bin/rake routes`命令来查看新创建的路由。
- en: API Controllers
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API控制器
- en: 'Now that you’ve defined the routes, you need to create a controller to handle
    these actions. First, create a directory for the API controllers by entering the
    following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了路由，接下来需要创建一个控制器来处理这些动作。首先，创建一个目录来存放API控制器，方法是输入以下命令：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then create a new file named *app/controllers/api/posts_controller.rb* and
    add the code for the API `PostsController`, as shown here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建一个名为*app/controllers/api/posts_controller.rb*的新文件，并添加API `PostsController`的代码，如下所示：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The file starts with `module Api` to indicate this class belongs to the API
    namespace. Inside the `PostsController` class is a call to the `respond_to` class
    method. Calling `respond_to :json`, indicates that the actions in this controller
    return JSON data ➊.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件以`module Api`开始，表示该类属于API命名空间。在`PostsController`类内部，有一个对`respond_to`类方法的调用。调用`respond_to
    :json`表示该控制器中的动作返回JSON数据 ➊。
- en: The class then defines the `index` action ➋. The `index` action retrieves all
    posts and then uses the `respond_with` method to send them to the client ➌. The
    `respond_with` method automatically formats the data based on the format and HTTP
    verb used in the request. In this case, it should return JSON data in response
    to a GET request for the `index` action.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该类接着定义了`index`动作 ➋。`index`动作检索所有帖子，然后使用`respond_with`方法将其发送到客户端 ➌。`respond_with`方法会根据请求中使用的格式和HTTP动词自动格式化数据。在这种情况下，它应该在响应GET请求时返回JSON数据，用于`index`动作。
- en: 'After you save this file, start the Rails server if it isn’t already started.
    Then you can use `curl` to test your API by entering this command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 保存该文件后，如果Rails服务器尚未启动，请启动它。然后，你可以使用`curl`命令通过输入以下命令来测试你的API：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The API returns an array of posts in response to the posts `index` action.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: API将返回一个帖子的数组，以响应帖子`index`动作。
- en: 'The data is compact and on a single line, which can be hard to read, but several
    free tools can pretty-print JSON data for you. For example, jq is a JSON processor
    that pretty-prints JSON data and adds syntax highlighting. Download jq from *[http://stedolan.github.io/jq/](http://stedolan.github.io/jq/)*.
    Once installed, you can pipe the output through jq’s basic filter by adding `|
    jq ''.''` to the end of the command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是紧凑的并且在一行中，这可能难以阅读，但有几个免费的工具可以帮你格式化JSON数据。例如，jq是一个JSON处理器，可以格式化JSON数据并添加语法高亮。你可以从*[http://stedolan.github.io/jq/](http://stedolan.github.io/jq/)*下载jq。安装后，你可以通过在命令的末尾添加`|
    jq '.'`将输出通过jq的基本过滤器来格式化：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The remaining examples in this chapter are pretty-printed. I leave off the `|
    jq '.'` for brevity, but you should include it if you want your output to look
    like what you see in the book. You can also see JSON output in your web browser.
    Entering *http://localhost:3000/api/posts* in your web browser causes an `ActionController::UnknownFormat`
    error. If you check the server output in your terminal, you’ll see this is a *406
    Not Acceptable* error, as discussed earlier in this chapter. This error occurs
    because the controller only responds to JSON requests, but your web browser asks
    for HTML by default.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余的示例采用了漂亮打印格式。为了简洁起见，我省略了 `| jq '.'`，但如果你想让输出与书中所见相同，应该包括它。你也可以在浏览器中查看 JSON
    输出。在浏览器中输入 *http://localhost:3000/api/posts* 会引发 `ActionController::UnknownFormat`
    错误。如果你查看终端中的服务器输出，会看到这是一个 *406 Not Acceptable* 错误，正如本章之前讨论的那样。发生此错误是因为控制器仅响应 JSON
    请求，而浏览器默认请求 HTML。
- en: Specify a different content type by adding an extension to the URL in the address
    bar. Browsing to *http://localhost:3000/api/posts.json* returns a JSON array of
    posts as expected.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在地址栏的 URL 中添加扩展名来指定不同的内容类型。浏览 *http://localhost:3000/api/posts.json* 会按预期返回一个
    JSON 数组。
- en: Customizing JSON Output
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 JSON 输出
- en: So far your API returns all of the data associated with each post. You may want
    to include additional data with each record, and, in some cases, you may want
    to exclude data from some fields. For example, including data about the author
    of each post is helpful, but you don’t want to include the user’s `password_digest`
    or `api_token`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的 API 返回了与每个帖子相关的所有数据。你可能希望为每条记录包含额外的数据，某些情况下，可能希望排除某些字段的数据。例如，包含每个帖子的作者数据是有帮助的，但你不想包含用户的
    `password_digest` 或 `api_token`。
- en: You can customize the output from your API built in to Rails in a couple of
    ways. Which method you use depends on how much customization you need and your
    personal preference.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过几种方式自定义内置于 Rails 中的 API 输出。你使用哪种方法取决于你需要多少自定义和个人偏好。
- en: as_json
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: as_json
- en: Because this API returns JSON data, you can easily customize the output by changing
    the way Rails converts a model to JSON. Rails first calls the `as_json` method
    on a model to convert it to a hash, which is then converted to a JSON string.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个 API 返回的是 JSON 数据，所以你可以通过更改 Rails 将模型转换为 JSON 的方式来轻松自定义输出。Rails 首先调用模型上的
    `as_json` 方法将其转换为哈希，然后再将哈希转换为 JSON 字符串。
- en: 'You can override the `as_json` method in the `Post` model to customize the
    data returned for each post. Open the file *app/models/post.rb* and add the `as_json`
    method, shown here, to force the method to show only each post’s `id` and `title`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `Post` 模型中重写 `as_json` 方法，以自定义每个帖子的返回数据。打开文件 *app/models/post.rb* 并添加如下所示的
    `as_json` 方法，强制该方法仅显示每个帖子的 `id` 和 `title`：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Be sure to include the `options` parameter with a default value of `{}` ➊ because
    the original `as_json` includes it. You aren’t using the `options` parameter,
    but because you’re overriding an existing method, your definition must match the
    original. Your `as_json` method calls `super`, which invokes the original `as_json`
    method defined by Active Record, with the parameter `only: [:id, :title]` ➋.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '确保包括默认值为 `{}` 的 `options` 参数 ➊，因为原始的 `as_json` 包括了它。你虽然没有使用 `options` 参数，但因为你正在重写现有方法，所以你的定义必须与原始方法匹配。你的
    `as_json` 方法调用 `super`，这将调用 Active Record 中定义的原始 `as_json` 方法，并传递参数 `only: [:id,
    :title]` ➋。'
- en: 'With this method in place, your API should only return the `id` and `title`
    of each post. Use the `curl` command to verify the change:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法后，你的 API 应该仅返回每个帖子的 `id` 和 `title`。使用 `curl` 命令验证此更改：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `as_json` method supports several additional options. Instead of specifying
    fields to include with `:only`, you could exclude fields with the `:except` option.
    You can also include associated models with the `:include` option. For example,
    update the `as_json` method, as shown here, to exclude the `user_id` field and
    include the post’s associated `user` model:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`as_json` 方法支持若干附加选项。你可以使用 `:except` 选项来排除字段，而不是像 `:only` 一样指定包含的字段。你还可以使用
    `:include` 选项来包含关联的模型。例如，更新 `as_json` 方法，如下所示，排除 `user_id` 字段并包含帖子关联的 `user` 模型：'
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `:methods` option calls a list of methods and includes their return values
    in the output. For example, you can use this option to call the `cached_comment_count`
    method you added in [Chapter 12](ch12.html "Chapter 12. Performance"):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`:methods` 选项调用方法列表，并将其返回值包括在输出中。例如，你可以使用此选项调用你在[第12章](ch12.html "第12章：性能")中添加的
    `cached_comment_count` 方法：'
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This option will include the cached number of comments associated with this
    post in the output.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项将包括与该帖子关联的评论数（缓存）的信息。
- en: Overriding `as_json` certainly works, but depending on the level of customization
    required, this can get a bit messy. Fortunately, Rails provides a way to customize
    fully the JSON data returned by your API. Remove the `as_json` method from the
    `Post` model and let’s cover jbuilder.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重写`as_json`当然有效，但根据定制需求的不同，这可能会变得有些杂乱。幸运的是，Rails提供了一种完全定制API返回JSON数据的方式。删除`Post`模型中的`as_json`方法，让我们来学习jbuilder。
- en: Jbuilder
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jbuilder
- en: Jbuilder is a domain-specific language for generating JSON output. The jbuilder
    gem is included by default in the *Gemfile* generated by the `rails new` command.
    Using jbuilder, you can create views for each of your API actions, just as you
    used ERB to create views for web actions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Jbuilder是一个专门用于生成JSON输出的领域特定语言。`jbuilder` gem默认包含在`rails new`命令生成的*Gemfile*中。使用jbuilder，你可以为每个API操作创建视图，就像使用ERB为Web操作创建视图一样。
- en: 'As with your other views, you need to create a directory for your jbuilder
    views. The view directory must match the controller name. Enter the following
    commands to create a directory for API views and a subdirectory for the `PostsController`
    views:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他视图一样，你需要为jbuilder视图创建一个目录。视图目录必须与控制器名称匹配。输入以下命令来为API视图创建一个目录，并为`PostsController`视图创建子目录：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With these directories in place, you can create your first jbuilder view. Create
    a new file named *app/views/api/posts/index.json.jbuilder* and open it in your
    editor. Add this single line of code and save the file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些目录设置好后，你可以创建第一个jbuilder视图。创建一个新文件，命名为*app/views/api/posts/index.json.jbuilder*，并在编辑器中打开它。添加这一行代码并保存文件：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `json.array!` method tells jbuilder to render the value of `@posts` as
    a JSON array. Use Curl to check the output of the index action:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`json.array!`方法告诉jbuilder将`@posts`的值呈现为JSON数组。使用Curl检查索引操作的输出：'
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The output is the same as when you started. Now let’s see about customizing
    this output.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与开始时相同。现在让我们看看如何定制这个输出。
- en: 'The `json.array!` method also accepts a block. Inside the block, you can access
    each individual record in the array. You can then use the `json.extract!` method
    to include only certain fields from the post:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`json.array!`方法也接受一个块。在块内，你可以访问数组中的每个记录。然后，你可以使用`json.extract!`方法仅包含帖子中的特定字段：'
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This example renders the `id`, `title`, `body`, and `url` fields from each post
    as JSON.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将每篇文章的`id`、`title`、`body`和`url`字段呈现为JSON格式。
- en: 'All of the usual view helpers are also available in jbuilder views. For example,
    you can include a URL for each post using the `api_post_url` helper method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所有常见的视图辅助方法在jbuilder视图中也可以使用。例如，你可以使用`api_post_url`辅助方法为每篇文章包含一个URL：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output of method calls, such as `api_post_url(post)` ➊, are automatically
    converted to JSON format. The next example adds some data about the author of
    each post:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用的输出，如`api_post_url(post)` ➊，会自动转换为JSON格式。下一个示例添加了每篇文章的作者数据：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, I’ve used the `json.extract!` method again to include only specific fields
    for each user. You don’t want to make the `password_digest` for users available
    through your public API.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我再次使用了`json.extract!`方法，只包含每个用户的特定字段。你不希望公开API中暴露`password_digest`字段。
- en: Token-Based Authentication
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于令牌的认证
- en: Now let’s add authentication so you can also create posts through your API.
    You’ll add token-based authentication, like you used earlier when accessing the
    GitHub API.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加认证，以便你也可以通过API创建帖子。你将添加基于令牌的认证，就像你之前访问GitHub API时使用的那样。
- en: Generating Tokens
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成令牌
- en: 'First, add a field for the `api_token` string to the `User` model by generating
    a database migration:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过生成数据库迁移，为`User`模型添加一个`api_token`字符串字段：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Remember to enter the `bin/rake db:migrate` command after generating this migration
    to update your database.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在生成此迁移后，输入`bin/rake db:migrate`命令来更新数据库。
- en: 'Now update the `User` model by opening *app/models/user.rb* in your editor
    and adding a validation for the `api_token` field and a `before_validation` call-back
    to generate the API token:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过在编辑器中打开*app/models/user.rb*文件，更新`User`模型，添加对`api_token`字段的验证，并添加`before_validation`回调来生成API令牌：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, you need to validate that the `api_token` is present and unique ➊. Because
    you’re using this value to authenticate, no two users can have the same `api_token`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要验证`api_token`是否存在且唯一 ➊。因为你将使用这个值进行认证，所以两个用户不能拥有相同的`api_token`。
- en: 'Next, you use a `before_validation` callback to call a method to generate the
    `api_token` if it doesn’t already exist ➋. Add the `generate_api_token` method
    at the bottom of the `User` model as shown here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`before_validation`回调调用一个方法，如果`api_token`不存在，则生成它➋。在`User`模型的底部添加`generate_api_token`方法，如下所示：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `generate_api_token` method returns immediately if the `api_token` already
    has a value ➊. If a value is not present for the `api_token`, the method calls
    `SecureRandom.hex` inside an endless `loop` to generate a value ➋. The `SecureRandom`
    class uses the most secure random-number generator available on your computer
    to generate values. On Unix computers, it uses the `/dev/urandom` device; on Windows,
    it uses the Win32 Cryptographic API. The `SecureRandom` class also includes several
    methods for formatting random values. The `hex` method returns a random 32-character
    hexadecimal value. Finally, if a user with this `api_token` doesn’t exist, break
    out of the loop ➌.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`api_token`已经有值，`generate_api_token`方法会立即返回➊。如果`api_token`没有值，方法会在一个无尽的`loop`中调用`SecureRandom.hex`生成一个值➋。`SecureRandom`类使用计算机上最安全的随机数生成器来生成值。在
    Unix 计算机上，它使用`/dev/urandom`设备；在 Windows 上，它使用 Win32 加密 API。`SecureRandom`类还包括几种格式化随机值的方法。`hex`方法返回一个随机的
    32 字符十六进制值。最后，如果没有用户拥有该`api_token`，则跳出循环➌。
- en: 'Now open a Rails console and update the existing users:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Rails 控制台并更新现有用户：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Because the `generate_api_token` method is called automatically using a `before_validation`
    callback, you simply need to load the user into a variable ➊ and then save it
    to the database ➋ to update it. Do this for each of your users. If any user doesn’t
    have a value for `api_token`, it will be created.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`generate_api_token`方法是通过`before_validation`回调自动调用的，您只需要将用户加载到变量中➊，然后将其保存到数据库中➋进行更新。对每个用户执行此操作。如果有任何用户没有`api_token`值，它将被创建。
- en: 'Now update the user `show` view to display the `api_token` when a user views
    his or her own account. Update *app/views/users/show.html.erb* as shown here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更新用户的`show`视图，以便在用户查看自己的账户时显示`api_token`。按照下面所示更新*app/views/users/show.html.erb*：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Because API tokens are essentially passwords, you want to protect them by only
    showing them when the user being displayed is equal to the `current_user` ➊.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 API 令牌本质上是密码，您需要通过仅在显示的用户等于`current_user`时才显示它们，从而保护它们➊。
- en: Authenticating Requests
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 身份验证请求
- en: Now that all users have an API token, let’s put those tokens to use. The process
    of authenticating with a token is similar to the username and password authentication
    you already created. Because you may have more than one controller for your API,
    you should include the authentication method in `ApplicationController`, which
    is the parent class of all other controllers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有用户都有了 API 令牌，让我们开始使用这些令牌。使用令牌进行身份验证的过程类似于您已经创建的用户名和密码身份验证。因为您的 API 可能有多个控制器，您应该将身份验证方法包含在`ApplicationController`中，它是所有其他控制器的父类。
- en: 'First, you need a method to authenticate using an `api_token`. Luckily, Rails
    has a built-in method called `authenticate_or_request_with_http_token` to handle
    the details for you. Open the file *app/controllers/application_ controller.rb*
    and add the following method to see how this works:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要一个方法来使用`api_token`进行身份验证。幸运的是，Rails 提供了一个名为`authenticate_or_request_with_http_token`的内建方法，可以处理这些细节。打开文件*app/controllers/application_controller.rb*，并添加以下方法来查看它是如何工作的：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This method is named `authenticate_token!` to match the `authenticate_user!`
    method you added in [Chapter 9](ch09.html "Chapter 9. Authentication"). The `authenticate_or_request_with_http_token`
    retrieves the token included in the request’s Authorization header and passes
    it to a block. Inside the block, you try to find a user in the database using
    the given token ➊. The `find_by` method returns a `User` object if a matching
    user is found, or `nil` otherwise. This value is assigned to the `@api_user` instance
    variable and returned from the block. If the block returns a false value, such
    as `nil`, the method knows that authentication failed and sends a *401 Unauthorized*
    response to the client.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法命名为`authenticate_token!`，与您在[第9章](ch09.html "第9章. 身份验证")中添加的`authenticate_user!`方法匹配。`authenticate_or_request_with_http_token`从请求的
    Authorization 头部获取令牌，并将其传递给一个代码块。在代码块中，您尝试使用给定的令牌在数据库中查找用户➊。`find_by`方法如果找到匹配的用户，则返回一个`User`对象，否则返回`nil`。此值将赋给`@api_user`实例变量，并从代码块中返回。如果代码块返回一个假值，如`nil`，则方法知道身份验证失败，并向客户端发送*401
    未授权*响应。
- en: You wrote a helper method called `current_user` for accessing the authenticated
    user in [Chapter 9](ch09.html "Chapter 9. Authentication"). For API requests,
    the authenticated user is already assigned to the `@api_user` instance variable,
    so you can use this variable.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你为访问经过身份验证的用户写了一个辅助方法 `current_user`，该方法出现在 [第 9 章](ch09.html "第 9 章。身份验证")
    中。对于 API 请求，经过身份验证的用户已经分配给 `@api_user` 实例变量，因此你可以使用这个变量。
- en: Your token-based authentication solution is ready to go now. Let’s try it out
    by adding the ability to create text posts through your API.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你的基于令牌的身份验证解决方案已经准备好了。让我们尝试通过 API 添加创建文本帖子的功能。
- en: Using Token-Based Authentication
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用基于令牌的身份验证
- en: 'First, you need to add routes for text posts, so open *config/routes.rb* and
    add the `text_posts` resources inside the `:api` namespace:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要为文本帖子添加路由，因此打开 *config/routes.rb* 并在 `:api` 命名空间中添加 `text_posts` 资源：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now you need a controller for text posts. Remember, it needs to be inside the
    *api/* directory because the routes are in the `:api` namespace. Create a file
    named *app/controllers/api/text_posts_controller.rb* and add the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要为文本帖子创建一个控制器。记住，它需要位于 *api/* 目录中，因为路由位于 `:api` 命名空间中。创建一个名为 *app/controllers/api/text_posts_controller.rb*
    的文件，并添加以下代码：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This controller starts the same as the API posts controller. The `TextPostsController`
    class must be inside a module called `Api`. It also includes `respond_to :json`.
    The first change is the addition of `before_action :authenticate_token!` ➊. The
    controller calls the `authenticate_token!` method before each action.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制器的起始方式与 API 帖子控制器相同。`TextPostsController` 类必须位于名为 `Api` 的模块内。它还包括 `respond_to
    :json`。第一个变化是添加了 `before_action :authenticate_token!` ➊。控制器在每个操作之前都会调用 `authenticate_token!`
    方法。
- en: 'You want to create text posts, so add the `create` method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你想创建文本帖子，因此添加 `create` 方法：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `create` method uses the `@api_user` instance variable set inside `authenticate_token!`
    to create a new text post ➊. You then use `respond_with` to send the new text
    post back to the client. Note that you don’t check to see whether the text post
    was actually created. The `respond_with` method automatically sends the appropriate
    error response if `@text_post` contains errors.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`create` 方法使用在 `authenticate_token!` 中设置的 `@api_user` 实例变量来创建一个新的文本帖子 ➊。然后你使用
    `respond_with` 将新的文本帖子发送回客户端。请注意，你没有检查文本帖子是否真正创建。`respond_with` 方法会自动在 `@text_post`
    包含错误时发送适当的错误响应。'
- en: 'Because you also want to specify permitted parameter values, your final addition
    is a `text_post_params` method:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你还想指定允许的参数值，所以你的最终添加是一个 `text_post_params` 方法：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `text_post_params` method permits data for a `:title` and `:body` in a nested
    hash with the key `:text_post` ➊. This is the same as the `text_post_params` method
    in the controller for web requests.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`text_post_params` 方法允许在一个嵌套的哈希中使用 `:title` 和 `:body` 数据，哈希的键是 `:text_post`
    ➊。这与处理 Web 请求时控制器中的 `text_post_params` 方法相同。'
- en: Enter the `curl` command to try out the new API. Make sure to set the `Content-Type`
    header to `application/json` when you run the command, so Rails automatically
    parses the JSON data included with your request. Replace the word ***`token`***
    with the actual `api_token` from one of your application’s users.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `curl` 命令以尝试新的 API。运行命令时，确保将 `Content-Type` 头设置为 `application/json`，这样 Rails
    就会自动解析请求中包含的 JSON 数据。将 ***`token`*** 替换为你应用程序某个用户的实际 `api_token`。
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Something went wrong: The status code *422 Unprocessable Entity* ➊ means the
    data the client passed to the server is not valid. Check the server output in
    your terminal for more information.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 出现了问题：状态码 *422 Unprocessable Entity* ➊ 表示客户端传递给服务器的数据无效。请检查终端中的服务器输出以获取更多信息。
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The data passed to the server is valid but didn’t include a CSRF token ➊. Remember,
    this token is not the same as the API token. The CSRF token is another unique
    token that is sent automatically when you submit form data in your application.
    Because you aren’t submitting a form, you have no way of knowing the correct CSRF
    token.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给服务器的数据有效，但未包含 CSRF 令牌 ➊。请记住，这个令牌与 API 令牌不同。CSRF 令牌是另一个唯一的令牌，当你在应用程序中提交表单数据时，它会自动发送。因为你没有提交表单，所以无法知道正确的
    CSRF 令牌。
- en: When you were updating the `ApplicationController` earlier, you may have noticed
    a helpful comment at the top of the class. Rails normally prevents CSRF attacks
    by raising an exception. This is great for a web application, but it won’t work
    for an API. Instead of raising an exception, you can prevent CSRF attacks by clearing
    out the user’s session data. Now any time the application receives data from a
    user that does not include the CSRF token, it clears the user’s session, effectively
    logging the user out of the application and preventing the attack.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当你之前更新`ApplicationController`时，可能注意到了类顶部的一条有用的注释。Rails 通常通过引发异常来防止 CSRF 攻击。这对于
    Web 应用程序来说很有用，但对 API 无效。你可以通过清除用户的会话数据来防止 CSRF 攻击，而不是引发异常。现在，每当应用程序收到一个不包含 CSRF
    令牌的数据时，它会清除用户的会话，从而有效地将用户从应用程序中登出并防止攻击。
- en: 'Fortunately, rather than store authentication data in the session, API clients
    include the correct API token with each request. So API requests should work fine
    with a null session. Open *app/controllers/application_controller.rb* in your
    editor and make the following update:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '幸运的是，API 客户端在每次请求时都包括正确的 API 令牌，而不是将认证数据存储在会话中。因此，API 请求在空会话下应该可以正常工作。打开*app/controllers/application_controller.rb*文件并进行以下更新： '
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `protect_from_forgery` method call ➊, change the value of the `:with`
    option to `:null_session`, and then try the same request again using `curl`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`protect_from_forgery`方法调用 ➊ 中，将`:with`选项的值更改为`:null_session`，然后使用`curl`再次尝试相同的请求：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The status code is now *201 Created*, which means success ➊. The HTTP headers
    are followed by a JSON representation of the new text post ➋. Because you didn’t
    create a jbuilder view for this action, the default JSON representation is used.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 状态码现在是*201 Created*，表示成功 ➊。HTTP 头部后面是新文本帖子的 JSON 表示 ➋。因为你没有为这个动作创建 jbuilder
    视图，所以使用了默认的 JSON 表示。
- en: You can also open the `posts` index page in your browser, or issue an API request
    for all posts with the command `curl http://localhost:3000/api/posts`, to verify
    the text post was created successfully.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在浏览器中打开`posts`索引页面，或者使用命令`curl http://localhost:3000/api/posts`发出请求来验证文本帖子是否成功创建。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: A Web API can open up your application to collaborations from both your customers
    and third-party applications. With an effective API, you can also build native
    mobile or desktop clients for your application. You could even use another application’s
    API to integrate its data into yours.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Web API 可以让你的应用程序与客户和第三方应用程序进行协作。通过有效的 API，你还可以为你的应用程序构建本地移动或桌面客户端。你甚至可以使用另一个应用程序的
    API 将其数据集成到你的应用程序中。
- en: In this chapter, we discussed the GitHub API and used it to access detailed
    data about users and repositories. After covering the Hypertext Transfer Protocol
    and token-based authentication, you built your own API for your social network
    application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 GitHub API，并使用它访问有关用户和仓库的详细数据。在介绍了超文本传输协议和基于令牌的认证后，你为你的社交网络应用程序构建了自己的
    API。
- en: In the next chapter, you’ll learn how to set up your own server to host Rails
    applications and use the Capistrano remote server automation tool to deploy and
    maintain your applications.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '在下一章，你将学习如何设置自己的服务器来托管 Rails 应用程序，并使用 Capistrano 远程服务器自动化工具来部署和维护你的应用程序。 '
- en: Exercises
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '| Q: | 1\. Verify that your token-based authentication is really working by
    issuing a POST request with a fake token. Use the `curl` command to send the request,
    and be sure to check both the status code in the headers and the response body.
    |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 问： | 1\. 通过发送一个带有假令牌的 POST 请求，验证你的基于令牌的认证是否真的有效。使用`curl`命令发送请求，并确保检查头部中的状态码和响应体。
    |'
- en: '| Q: | 2\. Try to create a text post with invalid data and see what happens.
    You can check the validation for text posts in *app/models/text_post.rb*. Again,
    use the `curl` command to send the request and be sure to check the status code
    in both the headers and the response body. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 问： | 2\. 尝试使用无效数据创建文本帖子，看看会发生什么。你可以在*app/models/text_post.rb*中检查文本帖子的验证。再次使用`curl`命令发送请求，并确保检查头部和响应体中的状态码。
    |'
- en: '| Q: | 3\. Extend the API by adding a `show` action to the posts controller.
    This action should find the correct post using `params[:id]` and then use the
    `respond_with` method to send the post back to the client. Because this is a GET
    request, you can check it with `curl` or in your web browser. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 问： | 3\. 通过在帖子控制器中添加一个`show`动作来扩展 API。这个动作应该使用`params[:id]`查找正确的帖子，然后使用`respond_with`方法将帖子返回给客户端。因为这是一个
    GET 请求，你可以使用`curl`或在你的浏览器中检查它。 |'
