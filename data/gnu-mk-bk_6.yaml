- en: Chapter 6. The GNU Make Standard Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。GNU Make 标准库
- en: The *GNU Make Standard Library (GMSL)* is a SourceForge-hosted, open source
    project that I started to capture common functions that makefile authors end up
    writing over and over again. To prevent makefile writers from reinventing the
    wheel, the GMSL implements common functions, such as reversing lists, uppercasing
    a string, or mapping a function across every element of a list.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*GNU Make 标准库 (GMSL)* 是一个托管在 SourceForge 上的开源项目，由我发起，旨在收集 makefile 作者经常重复编写的常见函数。为了防止
    makefile 编写者重复造轮子，GMSL 实现了常见的函数，例如反转列表、将字符串转为大写，或对列表的每个元素应用一个函数。'
- en: The GMSL has list and string manipulation functions, a complete integer arithmetic
    library, and functions for data structures. Also included are GNU `make` implementations
    of associative arrays, sets, and stacks, as well as built-in debugging facilities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: GMSL 包含了列表和字符串操作函数、完整的整数算术库，以及数据结构的函数。还包括 GNU `make` 对关联数组、集合和栈的实现，并提供内建的调试功能。
- en: In this chapter, you’ll learn how to use the functions of the GMSL in realistic
    makefiles. In addition, you’ll see a complete reference for the different categories
    of GMSL functions. For the latest revision of the GMSL, visit *[http://gmsl.sf.net/](http://gmsl.sf.net/)*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在实际的 makefile 中使用 GMSL 函数。此外，你将看到 GMSL 函数的不同类别的完整参考。要查看 GMSL 的最新版本，请访问
    *[http://gmsl.sf.net/](http://gmsl.sf.net/)*。
- en: Importing the GMSL
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入 GMSL
- en: 'The GMSL is implemented as a pair of makefiles named `gmsl` and `__gmsl`. `__gmsl`
    is imported by `gmsl`, so to include the GMSL in your makefile, just add this:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: GMSL 实现为一对名为 `gmsl` 和 `__gmsl` 的 makefile。`__gmsl` 被 `gmsl` 导入，因此要在你的 makefile
    中包含 GMSL，只需添加以下内容：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can do this in as many files as you want. To prevent multiple definitions
    and unintended error messages, the GMSL automatically detects if it has already
    been included.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任意多个文件中执行此操作。为了防止多次定义和不必要的错误信息，GMSL 会自动检测是否已经包含过。
- en: Of course, GNU `make` must be able to find `gmsl` and `__gmsl`. To do that,
    GNU `make` looks for makefiles in a number of places by default, including `/usr/local/include`,
    `/usr/gnu/include/`, `/usr/include`, the current directory, and any directories
    specified by the GNU `make -I` (or `--include-dirL`) command line option.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，GNU `make` 必须能够找到 `gmsl` 和 `__gmsl`。为了实现这一点，GNU `make` 默认会在多个地方查找 makefile，包括
    `/usr/local/include`、`/usr/gnu/include/`、`/usr/include`、当前目录，以及任何通过 GNU `make
    -I`（或 `--include-dirL`）命令行选项指定的目录。
- en: A good place to put `gmsl` and `__gmsl` is `/usr/local/include`, where they’ll
    be available to all your makefiles.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `gmsl` 和 `__gmsl` 放置在 `/usr/local/include` 是一个好地方，这样它们将对所有你的 makefile 可用。
- en: 'If GNU `make` can’t find `gmsl` or `__gmsl`, you’ll get the regular GNU `make`
    error message:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 GNU `make` 无法找到 `gmsl` 或 `__gmsl`，你将看到常规的 GNU `make` 错误信息：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The GMSL uses a little trick to make the location of `gmsl` completely flexible.
    Because `gmsl` uses `include` to find `__gmsl`, the `gmsl` makefile needs to know
    where to find `__gmsl`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: GMSL 使用了一个小技巧，使得 `gmsl` 的位置完全灵活。由于 `gmsl` 使用 `include` 来查找 `__gmsl`，因此 `gmsl`
    makefile 需要知道在哪里找到 `__gmsl`。
- en: 'Let’s suppose that `gmsl` was stored in `/foo` and included with `include /foo/gmsl`.
    To make this work without having to modify `gmsl` to hardcode the location of
    `__gmsl`, `gmsl` figures out where it’s located using `MAKEFILE_LIST` and then
    prepends the appropriate path to the `include __gmsl`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `gmsl` 存储在 `/foo` 中，并通过 `include /foo/gmsl` 来包含。为了使这个工作正常，而无需修改 `gmsl` 来硬编码
    `__gmsl` 的位置，`gmsl` 会使用 `MAKEFILE_LIST` 来确定它的位置，然后将适当的路径添加到 `include __gmsl` 前面：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That’s a handy technique if you want your makefiles to be location independent.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的 makefile 具有位置独立性，这是一项非常有用的技巧。
- en: Calling a GMSL Function
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 GMSL 函数
- en: 'The functions in the GMSL are implemented as normal GNU `make` function declarations.
    For example, the function `last` (which returns the last element of a list) is
    declared like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GMSL 中的函数实现为普通的 GNU `make` 函数声明。例如，函数 `last`（返回列表的最后一个元素）是这样声明的：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The function is called using GNU `make`’s built-in `$(call)`. For example,
    to return the last element of the list `1 2 3`, do this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数是通过 GNU `make` 的内建 `$(call)` 来调用的。例如，要返回列表 `1 2 3` 的最后一个元素，可以这样做：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will return `3`. `$(call)` expands the variable named in its first argument
    (in this case, `last`), setting special local variables (`$1`, `$2`, `$3`, . .
    .)to the arguments given to `$(call)` after the function name. So `$1` is `1 2
    3` in this case.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回 `3`。`$(call)` 展开其第一个参数中指定的变量（在这个例子中是 `last`），并将特殊的本地变量（`$1`、`$2`、`$3` 等）设置为传递给
    `$(call)` 的参数。所以在这个例子中，`$1` 是 `1 2 3`。
- en: 'The GMSL defines the Boolean values `true` and `false`, which are just variables
    and can be accessed using `$()` or `${}`: for example, `$(true)` or `${false}`.
    `false` is an empty string, and `true` is the letter `T`; these definitions correspond
    to GNU `make`’s notion of true (a non-empty string) and false (an empty string).
    You can use `true` and `false` in GNU `make`’s `$(if)` function or within a preprocessor
    `ifeq`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: GMSL定义了布尔值`true`和`false`，它们只是变量，可以通过`$()`或`${}`访问：例如，`$(true)`或`${false}`。`false`是一个空字符串，`true`是字母`T`；这些定义对应于GNU
    `make`中true（非空字符串）和false（空字符串）的概念。你可以在GNU `make`的`$(if)`函数中或在预处理器`ifeq`中使用`true`和`false`：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These examples are contrived. You’d expect the `$(true)` in the `$(if)` and
    the first `$(true)` in the `ifeq` to be the return values from a function call,
    not a constant value.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子是虚构的。你应该期望`$(true)`在`$(if)`中的返回值和`ifeq`中的第一个`$(true)`是来自函数调用的返回值，而不是常量值。
- en: Checking the GMSL Version
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查GMSL版本
- en: The GMSL includes a function that you can use to check that the version included
    is compatible with your use of the GMSL. The function `gmsl_compatible` checks
    that the version number of the included GMSL is greater than or equal to the version
    number passed as an argument.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: GMSL包含一个可以用来检查包含的版本是否与你使用的GMSL版本兼容的函数。函数`gmsl_compatible`检查包含的GMSL版本号是否大于或等于传入参数的版本号。
- en: 'At the time of this writing, the current GMSL version is `v1.1.7`. To check
    that the included GMSL is at least, say, `v1.1.2`, call `gmsl_compatible` with
    a list argument containing three elements: `1 1 2`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，当前的GMSL版本是`v1.1.7`。要检查包含的GMSL是否至少是`v1.1.2`，请调用`gmsl_compatible`并传入一个包含三个元素的列表参数：`1
    1 2`。
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will return `$(true)` because the current GMSL is `v1.1.7`, which is greater
    than `v1.1.2`. If we asked for `v2.0.0`, we’d get the response `$(false)`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回`$(true)`，因为当前的GMSL版本是`v1.1.7`，大于`v1.1.2`。如果我们请求的是`v2.0.0`，我们将得到`$(false)`的响应：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A simple way to make sure that you are using the right version of GMSL is to
    wrap the call to `gmsl_compatible` in an assertion:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你使用正确版本的GMSL的一个简单方法是将对`gmsl_compatible`的调用包装在一个断言中：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will stop the `make` process with an error if an incompatible version of
    GMSL is found.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现不兼容的GMSL版本，这将停止`make`进程并报错。
- en: Example Real-World GMSL Use
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例：现实世界中的GMSL使用
- en: Now that you’re set up with the GMSL, let’s look at some examples. All of these
    solve problems that real-world makefiles have to deal with, like caseinsensitive
    comparisons and searching a path for a file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置好了GMSL，让我们看一些例子。这些例子解决了现实世界中makefile必须处理的一些问题，比如不区分大小写的比较和在路径中搜索文件。
- en: Case-Insensitive Comparison
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不区分大小写的比较
- en: 'GMSL contains two functions that let you create a simple function to do a case-insensitive
    comparison of two strings:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: GMSL包含两个函数，允许你创建一个简单的函数来进行不区分大小写的字符串比较：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This works by lowercasing its two arguments (using the GMSL `lc` function)
    and then calling `seq` (the GMSL string equality function) to see if they are
    the same. Here’s one way to use `ifcase`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过将两个参数转换为小写（使用GMSL的`lc`函数），然后调用`seq`（GMSL的字符串相等函数）来检查它们是否相同。以下是使用`ifcase`的一种方式：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here it’s used to see if the `DEBUG` variable has been set to `yes`; if it has,
    `-DDEBUG` is added to `CPPFLAGS`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，它用于查看`DEBUG`变量是否已设置为`yes`；如果是，它会将`-DDEBUG`添加到`CPPFLAGS`中。
- en: Finding a Program on the Path
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在路径中查找程序
- en: 'Here’s a function definition that will search the `PATH` for an executable:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个搜索`PATH`中可执行文件的函数定义：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For example, `$(call findpath,cat)` will search the `PATH` for the first `cat`
    program. It uses three functions from the GMSL: `first`, `map`, and `split`. It
    uses two built-in functions: `wildcard` and `addsuffix`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`$(call findpath,cat)`将搜索`PATH`中第一个`cat`程序。它使用了GMSL中的三个函数：`first`、`map`和`split`。同时，它还使用了两个内置函数：`wildcard`和`addsuffix`。
- en: The call to `split` breaks the `PATH` variable into a list, separating it at
    colons. Then the built-in `addsuffix` function is called, which adds `/$1` to
    each element of the `PATH`. `$1` contains the parameter to `findpath`, which is
    the name of the program we’re searching for (in this case, it was `cat`).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`split`将`PATH`变量拆分为一个列表，并在冒号处进行分隔。然后调用内置的`addsuffix`函数，它将`/$1`添加到`PATH`的每个元素中。`$1`包含`findpath`的参数，即我们正在搜索的程序名称（在这种情况下是`cat`）。
- en: Then the GMSL `map` function is called to perform a built-in `wildcard` on each
    possible program filename. With no wildcard characters in the filename, `wildcard`
    will return the name of the file if it exists or an empty string. So `map` has
    the effect of finding the location (or locations) of `cat` on the `PATH` by testing
    each file in turn.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用GMSL的`map`函数，在每个可能的程序文件名上执行内建的`wildcard`。如果文件名中没有通配符字符，`wildcard`将返回文件名（如果存在）或空字符串。因此，`map`的作用是通过依次测试每个文件，找到`cat`在`PATH`上的位置（或多个位置）。
- en: Finally, a call to the GMSL function `first` returns the first element of the
    list that `map` returns (the list of all `cat` programs on the `PATH`).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用GMSL函数`first`返回`map`函数返回的列表中的第一个元素（即`PATH`中所有`cat`程序的第一个位置）。
- en: 'A debugging feature of GMSL is the ability to trace calls to GMSL functions.
    By setting `GMSL_TRACE` to `1`, GMSL will output each call to a GMSL function
    with its parameters. For example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: GMSL的调试功能之一是能够追踪对GMSL函数的调用。通过将`GMSL_TRACE`设置为`1`，GMSL会输出每个对GMSL函数的调用及其参数。例如：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we’re searching for `cat` using the `findpath` function with tracing turned
    on.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用启用了追踪功能的`findpath`函数搜索`cat`。
- en: Using Assertions to Check Inputs
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用断言检查输入
- en: Typically, a makefile is executed specifying a goal for the build (or under
    the assumption that there’s an `all` target or similar at the start of the makefile).
    In addition, there are typically environment variables (like debug options, architecture
    settings, and so on) that affect the build. A quick way to check that these have
    been set correctly is to use GMSL assertion functions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`makefile`是在指定构建目标的情况下执行的（或者假设在`makefile`的开始部分有一个`all`目标或类似目标）。此外，通常还会有影响构建的环境变量（例如调试选项、架构设置等）。检查这些变量是否已正确设置的快速方法是使用GMSL断言函数。
- en: 'Here’s an example that checks that `DEBUG` has been set to `yes` or `no`, that
    `ARCH` contains the word `Linux`, that we’ve specified an output directory in
    the `OUTDIR` variable, and that that directory exists:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，检查`DEBUG`是否已设置为`yes`或`no`，`ARCH`是否包含`Linux`，我们是否在`OUTDIR`变量中指定了输出目录，并且该目录是否存在：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The assertion functions will generate a fatal error if their first argument
    is `$(false)` (that is, an empty string).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果断言函数的第一个参数是`$(false)`（即空字符串），它们会生成一个致命错误。
- en: 'The first assert checks that `$(OUTDIR)` has been set to something. If it has
    a non-empty value, the assertion passed; otherwise, an error is generated:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个断言检查`$(OUTDIR)`是否已设置。如果它有一个非空值，则断言通过；否则，会生成一个错误：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The second assertion is of the form `assert_exists`, which checks to see whether
    its first argument exists in the file system. In this case, it checks to see whether
    the directory pointed to by `$(OUTDIR)` exists. It doesn’t check to see whether
    it’s a directory. We can add another assertion to do that, like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个断言是`assert_exists`形式，用来检查它的第一个参数在文件系统中是否存在。在这个例子中，它检查`$(OUTDIR)`所指向的目录是否存在。它不检查该路径是否是一个目录。如果需要，还可以添加另一个断言来检查这一点，如下所示：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This looks to see if `$(OUTDIR)` contains a dot (**`.`**). If not, `$(OUTDIR)`
    is not a directory, and the call to `wildcard` will return an empty string, causing
    the assertion to fail.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检查`$(OUTDIR)`是否包含一个点 (**`.`**)。如果没有，`$(OUTDIR)`就不是一个目录，调用`wildcard`将返回一个空字符串，从而导致断言失败。
- en: The third assertion checks that `DEBUG` is either `yes` or `no` using the GMSL
    `seq` function to check the value. Finally, we assert using `findstring` that
    `$(ARCH)` must contain the word `Linux` (with the `L` capitalized).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个断言检查`DEBUG`是否为`yes`或`no`，通过GMSL的`seq`函数来验证其值。最后，我们使用`findstring`断言`$(ARCH)`必须包含单词`Linux`（且`L`为大写）。
- en: Is DEBUG Set to Y?
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`DEBUG`是否设置为Y？'
- en: The GMSL has the logical operators `and`, `or`, `xor`, `nand`, `nor`, `xnor`,
    and `not` that work with GNU `make`’s concept of truth values and the GMSL variables
    `$(true)` and `$(false)`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: GMSL有逻辑运算符`and`、`or`、`xor`、`nand`、`nor`、`xnor`和`not`，这些运算符与GNU `make`的布尔值概念以及GMSL变量`$(true)`和`$(false)`一起工作。
- en: You can use GNU `make`’s (and GMSL’s) Boolean values with both GMSL functions
    and GNU `make`’s built-in `$(if)`. The GMSL logical operators were designed for
    use with `$(if)` and the GNU `make` preprocessor `ifeq` directive.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将GNU `make`（和GMSL）的布尔值与GMSL函数以及GNU `make`的内建`$(if)`一起使用。GMSL的逻辑运算符是为与`$(if)`和GNU
    `make`预处理器`ifeq`指令配合使用而设计的。
- en: 'Imagine that a makefile has a debug option, enabled by setting the `DEBUG`
    environment variable to `Y`. Using the GMSL function `seq` (string equal) and
    the `or` operator, you can easily determine whether debugging is desired or not:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个 makefile 有一个调试选项，通过将 `DEBUG` 环境变量设置为 `Y` 来启用。使用 GMSL 函数 `seq`（字符串相等）和 `or`
    运算符，你可以轻松确定是否需要调试：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Because the GMSL has a lowercase function (`lc`), you can write this example
    without the `or`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 GMSL 有一个小写函数（`lc`），你可以不用 `or` 就写出这个示例：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'But the logical operator `or` lets us be even more generous and accept `YES`
    as well as `Y` for the debug option:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但是逻辑运算符 `or` 让我们可以更加宽容，接受 `YES` 和 `Y` 作为调试选项的值：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The function `debug_needed` is case insensitive too.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`debug_needed` 函数对大小写不敏感。'
- en: Is DEBUG Set to Y or N?
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`DEBUG` 是否设置为 Y 或 N？'
- en: 'Another possible use of the logical operators is to force the user of the makefile
    to set `DEBUG` to either `Y` or `N`, thus avoiding problems if they forget about
    the debug option. The GMSL assertion function `assert` will output a fatal error
    if its argument is not true. So we can use it to assert that `DEBUG` must be `Y`
    or `N`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符的另一个可能用途是强制 makefile 的用户将 `DEBUG` 设置为 `Y` 或 `N`，从而避免如果他们忘记调试选项而引发的问题。GMSL
    断言函数 `assert` 会在其参数不为真时输出致命错误。所以我们可以用它来断言 `DEBUG` 必须是 `Y` 或 `N`：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here’s an example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The assertion generates this error if the user makes the mistake of setting
    `DEBUG` to `Oui`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户犯了把 `DEBUG` 设置为 `Oui` 的错误，断言会产生这个错误。
- en: Using Logical Operators in the Preprocessor
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在预处理器中使用逻辑运算符
- en: 'Because GNU `make`’s preprocessor (which has `ifeq`, `ifneq`, and `ifdef` directives)
    doesn’t have any logical operations, it’s difficult to write a complex statement.
    For example, to define a section of a makefile if `DEBUG` is set to `Y` or `Yes`
    in GNU `make`, you must either duplicate a section of code (yuck!) or write a
    statement that’s hard to understand:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 GNU `make` 的预处理器（它有 `ifeq`、`ifneq` 和 `ifdef` 指令）没有逻辑运算，所以很难编写复杂的语句。例如，要在
    GNU `make` 中定义一个 makefile 的部分，当 `DEBUG` 被设置为 `Y` 或 `Yes` 时，你必须重复一段代码（糟糕！）或者写一个难以理解的语句：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This works by filtering the list `Y Yes` with the value of `$(DEBUG)`, which
    returns an empty list if `$(DEBUG)` is not `Y` or `Yes`, or returns the value
    of `$(DEBUG)` if it is. The `ifeq` then compares the resulting value with `$(DEBUG)`.
    That’s pretty ugly, hard to maintain, and contains a subtle bug. (What happens
    if `$(DEBUG)` is empty? Hint: empty is the same as `Y` or `Yes`.) Fixing the bug
    means doing something like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法通过使用 `$(DEBUG)` 的值来过滤列表 `Y Yes`，如果 `$(DEBUG)` 不是 `Y` 或 `Yes`，则返回空列表，如果是，则返回
    `$(DEBUG)` 的值。然后 `ifeq` 会将结果值与 `$(DEBUG)` 进行比较。这种做法很丑陋、难以维护，并且包含一个微妙的 bug。（如果
    `$(DEBUG)` 为空会发生什么？提示：空值等同于 `Y` 或 `Yes`。）修复这个 bug 需要做类似这样的事情：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The GMSL `or` operator makes this much clearer:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: GMSL 的 `or` 运算符使这一点变得更加清晰：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is much more maintainable. It works by `or`ing two calls to `seq` and comparing
    the result with `$(true)`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法更容易维护。它通过对两个 `seq` 调用进行 `or` 操作，并将结果与 `$(true)` 进行比较来工作。
- en: Removing Duplicates from a List
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从列表中移除重复项
- en: The GMSL function `uniq` removes duplicates from a list. GNU `make` has a built-in
    `sort` function that sorts a list and removes duplicates; `uniq` removes duplicates
    without sorting the list (which can be handy if list order is important).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: GMSL 函数 `uniq` 从列表中移除重复项。GNU `make` 有一个内建的 `sort` 函数，可以对列表进行排序并移除重复项；`uniq`
    移除重复项但不排序列表（如果列表顺序很重要，这可以很有用）。
- en: For example, `$(sort c b a a c)` will return `a b c`, whereas `$(call uniq,c
    b a a c)` returns `c b a`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`$(sort c b a a c)` 会返回 `a b c`，而 `$(call uniq,c b a a c)` 会返回 `c b a`。
- en: 'Say you need to simplify the `PATH` variable by removing duplicate entries
    while preserving the order. The `PATH` is typically a colon-separated list of
    paths (like `/usr/bin:/bin:/usr/local/bin:/bin`). Here `simple-path` is the `PATH`
    with duplicates removed and order preserved:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要通过移除重复项并保留顺序来简化 `PATH` 变量。`PATH` 通常是一个以冒号分隔的路径列表（如 `/usr/bin:/bin:/usr/local/bin:/bin`）。这里的
    `simple-path` 是去除重复项并保留顺序后的 `PATH`：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This uses three GMSL functions: `uniq`, `split` (which splits a string into
    a list at a certain separator character; in this case, a colon), and `merge` (which
    merges a list into a string separating list entries with a character; in this
    case, a colon).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了三个 GMSL 函数：`uniq`、`split`（它将字符串按照某个分隔符字符拆分成列表；在此例中是冒号）和 `merge`（它将列表合并成一个字符串，列表项之间用一个字符分隔；在此例中是冒号）。
- en: Automatically Incrementing a Version Number
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动递增版本号
- en: 'When it’s release time for a piece of software, it’s handy to have a way to
    increment the version number automatically. Suppose that a project contains a
    file called `version.c` that contains the current version number as a string:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当软件发布时，能够自动增加版本号是非常方便的。假设一个项目包含一个名为 `version.c` 的文件，其中包含当前版本号的字符串：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It would be ideal to just type `make major-release`, `make minor-release`, or
    `make dot-release` and have one of the three parts of the version number automatically
    update and the `version.c` file change.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的情况是，只需输入 `make major-release`、`make minor-release` 或 `make dot-release`，并让版本号的三个部分之一自动更新，`version.c`
    文件也随之更改。
- en: 'Here’s how to do that:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何实现的：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `VERSION` variable contains the contents of the `version.c` file, which
    will be something like `char * ver = "1.0.0";`. The `PARTS` variable is a list
    created by first removing all the whitespace from `VERSION` and then splitting
    on the double quotes. That splits `VERSION` into the list `char*ver= 1.0.0 ;`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`VERSION` 变量包含 `version.c` 文件的内容，类似于 `char * ver = "1.0.0";`。`PARTS` 变量是一个列表，通过先去除
    `VERSION` 中的所有空白字符，再按双引号分割来创建的。这将 `VERSION` 分割成 `char*ver= 1.0.0 ;` 这个列表。'
- en: 'So `PARTS` is a list with three elements, and the second element is the current
    version number, which is extracted into `VERSION_NUMBER` and turned into a list
    of three elements: `1 0 0`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所以 `PARTS` 是一个包含三个元素的列表，第二个元素是当前的版本号，它被提取到 `VERSION_NUMBER` 中，并转化为一个包含三个元素的列表：`1
    0 0`。
- en: Next, variables called `MAJOR`, `MINOR`, and `DOT` are extracted from `VERSION_NUMBER`.
    If the version number in `version.c` was `1.2.3`, then `MAJOR` will be `1`, `MINOR`
    will be `2`, and `DOT` will be `3`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从 `VERSION_NUMBER` 中提取名为 `MAJOR`、`MINOR` 和 `DOT` 的变量。如果 `version.c` 中的版本号是
    `1.2.3`，那么 `MAJOR` 将是 `1`，`MINOR` 将是 `2`，`DOT` 将是 `3`。
- en: Finally, three rules are defined for major, minor, and dot releases. These use
    some `$(eval)` trickery to use the same rule body to update the major, minor,
    or dot release number depending on which of `major-release`, `minor-release`,
    or `dot-release` was specified on the command line.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，定义了三个规则，用于主版本、次版本和修订版发布。这些规则使用一些 `$(eval)` 技巧，利用相同的规则体来更新主版本、次版本或修订版号，具体取决于命令行中指定的
    `major-release`、`minor-release` 或 `dot-release`。
- en: To understand how it works, follow what happens when you do `make minor-release`
    with an existing version number of `1.0.0`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解它是如何工作的，可以跟随 `make minor-release` 的过程，假设当前版本号是 `1.0.0`。
- en: The `$(eval increment_name := $(call uc,$(subst -release,,$@)))` ➊ first uses
    `$(subst)` to remove `-release` from the target name (so `minor-release` becomes
    simply `minor`).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(eval increment_name := $(call uc,$(subst -release,,$@)))` ➊ 首先使用 `$(subst)`
    去除目标名称中的 `-release`（因此 `minor-release` 就变成了 `minor`）。'
- en: 'Then it calls the GMSL `uc` function (which uppercases a string) to turn `minor`
    into `MINOR`. It stores that in a variable called `increment-name`. Here’s the
    tricky part: `increment-name` will be used as the name of a variable to increment
    (one of `MAJOR`, `MINOR`, or `DOT`).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它调用 GMSL 的 `uc` 函数（该函数将字符串转换为大写），将 `minor` 转换为 `MINOR`。它将其存储在名为 `increment-name`
    的变量中。这里是关键部分：`increment-name` 将用作要增加的变量的名称（`MAJOR`、`MINOR` 或 `DOT` 之一）。
- en: At ➋, `$(eval $(increment_name) := $(call inc,$($(increment_name))))` actually
    does that work. It uses the GMSL `inc` function to increment the value stored
    in the variable whose name is in `increment-name` (notice the `$($(increment-name))`,
    which finds the value of a variable whose name is in another variable) and then
    sets that value to the incremented value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➋，`$(eval $(increment_name) := $(call inc,$($(increment_name))))` 实际上执行了这个工作。它使用
    GMSL 的 `inc` 函数来增加存储在名为 `increment-name` 的变量中的值（注意 `$($(increment-name))`，它用于查找另一个变量中存储的变量名的值），然后将该值设置为增加后的值。
- en: 'Finally, it just creates a new `version.c` containing the new version number
    ➌. For example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它创建一个新的 `version.c` 文件，其中包含新的版本号 ➌。例如：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is the result of using the `-n` option when starting from version 1.0.0
    and asking for the different possible releases.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `-n` 选项时，从版本 1.0.0 开始并要求不同可能的发布版本的结果。
- en: GMSL Reference
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GMSL 参考
- en: This section is a complete reference for the GNU Make Standard Library version
    1.1.7 and covers GMSL logical operators; integer functions; list, string, and
    set manipulation functions; associative arrays; and named stacks. For each category
    of GMSL functions, you’ll see an introduction to the functions, followed by a
    quick reference section that lists arguments and returns. For the latest version
    of the complete reference, check the GMSL website at *[http://gmsl.sf.net/](http://gmsl.sf.net/)*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是GNU Make标准库版本1.1.7的完整参考，涵盖了GMSL逻辑运算符、整数函数、列表、字符串和集合操作函数、关联数组和命名堆栈。对于每一类GMSL函数，你将看到函数的简介，接着是一个快速参考部分，列出了参数和返回值。要查看最新版本的完整参考，请访问GMSL网站：[http://gmsl.sf.net/](http://gmsl.sf.net/)。
- en: If you’re interested in advanced GNU `make` programming, it’s worth studying
    the source code of the GMSL (especially the file `__gmsl`). The techniques used
    to create individual GMSL functions are often useful in other situations.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对高级GNU `make`编程感兴趣，值得研究GMSL的源代码（特别是`__gmsl`文件）。创建各个GMSL函数时使用的技巧通常在其他情况下也很有用。
- en: Logical Operators
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: GMSL has Booleans `$(true)`, a non-empty string actually set to the single character
    `T`, and `$(false)`, an empty string. You can use the following operators with
    those variables or with functions that return those values.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: GMSL有布尔值`$(true)`，它是一个非空字符串，实际上设置为单个字符`T`，以及`$(false)`，它是一个空字符串。你可以使用以下运算符与这些变量或返回这些值的函数一起使用。
- en: 'Although these functions are consistent in that they always return `$(true)`
    or `$(false)`, they are lenient about accepting any non-empty string that indicates
    *true*. For example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些函数在返回值上始终是`$(true)`或`$(false)`，但它们对任何表示*真*的非空字符串都比较宽容。例如：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This tests for the existence of either of two files, `/tmp/foo` and `/tmp/bar`,
    using `$(wildcard)` and the GMSL `or` function. Doing `$(wildcard /tmp/foo)` will
    return `/tmp/foo` if the file exists or an empty string if not. So the output
    of the `$(wildcard /tmp/foo)` can be fed directly into `or`, where `/tmp/foo`
    will be interpreted as *true* and an empty string as *false*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这会测试两个文件`/tmp/foo`和`/tmp/bar`中的任意一个是否存在，使用了`$(wildcard)`和GMSL的`or`函数。执行`$(wildcard
    /tmp/foo)`会返回`/tmp/foo`（如果文件存在），或者返回空字符串（如果文件不存在）。因此，`$(wildcard /tmp/foo)`的输出可以直接传递给`or`，其中`/tmp/foo`会被解释为*真*，空字符串则为*假*。
- en: 'If you feel more comfortable working exclusively with values like `$(true)`
    and `$(false)`, define a `make-bool` function like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢只使用`$(true)`和`$(false)`这样的值，可以像这样定义一个`make-bool`函数：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will turn any non-empty string (after stripping off whitespace) into `$(true)`
    and leave a blank string (or one that had only whitespace in it) as `$(false)`.
    `make-bool` can be handy when whitespace might slip into values returned by functions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把任何非空字符串（去除空格后）转换为`$(true)`，而把空字符串（或仅包含空格的字符串）留作`$(false)`。`make-bool`在函数返回值中可能包含空格时非常有用。
- en: 'For example, here’s a small GNU `make` variable that is `$(true)` if the current
    month is January:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面是一个小的GNU `make`变量，如果当前月份是1月，它的值为`$(true)`：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This runs the `date` shell command, extracts the word `Jan`, and turns it into
    a truth value using `make-bool`. Using `$(filter)` like this treats the result
    of `date` as a list and then filters out any word in the list that is not `Jan`.
    This technique can be handy in other situations for extracting parts of a string.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这会运行`date` shell命令，提取单词`Jan`，并通过`make-bool`将其转换为真值。像这样使用`$(filter)`会把`date`的结果当作一个列表，然后过滤掉列表中任何不是`Jan`的词。这种技术在其他情况下也可以用来提取字符串的部分内容。
- en: 'You can make a generic function to discover if a list contains a word:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个通用函数来判断一个列表中是否包含某个词：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Using `contains-word`, you can redefine `january-now`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`contains-word`，你可以重新定义`january-now`。
- en: not
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: not
- en: 'The GMSL includes all the common logical operators. The simplest is the `not`
    function, which logically negates its argument:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: GMSL包含所有常见的逻辑运算符。最简单的是`not`函数，它对其参数进行逻辑取反：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For example, `$(call not,$(true))` returns `$(false)`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`$(call not,$(true))`返回`$(false)`。
- en: and
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: and
- en: 'The `and` function returns `$(true)` if (and only if) both its arguments are
    true:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`and`函数仅在其两个参数都为真时返回`$(true)`：'
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: For example, `$(call and,$(true),$(false))` returns `$(false)`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`$(call and,$(true),$(false))`返回`$(false)`。
- en: or
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: or
- en: 'The `or` function returns `$(true)` if either of its arguments is true:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`or`函数在其任一参数为真时返回`$(true)`：'
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: For example, `$(call or,$(true),$(false))` returns `$(true)`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`$(call or,$(true),$(false))`返回`$(true)`。
- en: xor
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: xor
- en: 'The `xor` function is *exclusive or*:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`xor`函数是*异或*：'
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For example, `$(call xor,$(true),$(false))` returns `$(true)`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`$(call xor,$(true),$(false))` 返回 `$(true)`。
- en: nand
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: nand
- en: '`nand` is simply *not and*:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`nand` 就是 *非与*：'
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For example, `$(call nand,$(true),$(false))` returns `$(true)` where `$(call
    and,$(true),$(false))` returns `$(false)`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`$(call nand,$(true),$(false))` 返回 `$(true)`，而 `$(call and,$(true),$(false))`
    返回 `$(false)`。
- en: nor
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: nor
- en: '`nor` is simply *not or*:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`nor` 就是 *非或*：'
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For example, `$(call nor,$(true),$(false))` returns `$(false)` where `$(call
    or,$(true),$(false))` returns `$(true)`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`$(call nor,$(true),$(false))` 返回 `$(false)`，而 `$(call or,$(true),$(false))`
    返回 `$(true)`。
- en: xnor
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: xnor
- en: 'The rarely used `xnor` is *not xor*:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 很少使用的 `xnor` 是 *非异或*：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Note that the GMSL logical functions `and` and `or` are not *short circuiting*;
    both of the arguments to those functions are expanded before performing the logical
    `and` or `or`. GNU `make` 3.81 introduced built-in `and` and `or` functions that
    are short circuiting: they evaluate their first argument and then decide whether
    it’s necessary to evaluate their second.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，GMSL 逻辑函数 `and` 和 `or` 不是 *短路*；这两个函数的两个参数会在执行逻辑 `and` 或 `or` 前展开。GNU `make`
    3.81 引入了内建的 `and` 和 `or` 函数，它们是短路的：它们首先评估第一个参数，然后决定是否有必要评估第二个参数。
- en: Integer Arithmetic Functions
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数算术函数
- en: In [Chapter 5](ch05.html "Chapter 5. Pushing the Envelope"), you saw how to
    perform arithmetic inside GNU `make` by representing non-negative integers as
    lists of `x`s. For example, 4 is `x x x x`. GMSL uses the same representation
    for integers and provides a wide range of functions for integer calculations.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第五章](ch05.html "第五章 推动极限")中，您已经看到如何通过将非负整数表示为 `x` 的列表，在 GNU `make` 中执行算术运算。例如，4
    是 `x x x x`。GMSL 使用相同的整数表示法，并提供广泛的函数来进行整数计算。
- en: 'The arithmetic library functions come in two forms: one form of each function
    takes integers as arguments, and the other form takes encoded arguments (`x`s
    created by a call to `int_encode`). For example, there are two `plus` functions:
    `plus` (called with integer arguments, returns an integer) and `int_plus` (called
    with encoded arguments, returns an encoded result).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 算术库函数有两种形式：一种形式的函数接受整数作为参数，另一种形式接受编码参数（由调用 `int_encode` 创建的 `x`）。例如，有两个 `plus`
    函数：`plus`（使用整数参数调用，返回整数）和 `int_plus`（使用编码参数调用，返回编码结果）。
- en: '`plus` will be slower than `int_plus` because its arguments and result must
    be translated between the `x` format and integers. If you’re doing a complex calculation,
    use the `int_*` forms with a single encoding of inputs and single decoding of
    the output. For simple calculations, you can use the direct forms.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`plus` 比 `int_plus` 慢，因为它的参数和结果必须在 `x` 格式和整数之间转换。如果您进行复杂的计算，请使用带有输入单一编码和输出单一解码的
    `int_*` 形式。对于简单的计算，您可以使用直接形式。'
- en: int_decode
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: int_decode
- en: 'The `int_decode` function takes a number in `x`-representation and returns
    the decimal integer that it represents:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`int_decode` 函数接受一个 `x` 表示法的数字并返回它表示的十进制整数：'
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: int_encode
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: int_encode
- en: '`int_encode` is the opposite of `int_decode`: it takes a decimal integer and
    returns the `x`-representation:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`int_encode` 是 `int_decode` 的逆运算：它接受一个十进制整数并返回 `x` 表示法：'
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: int_plus
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: int_plus
- en: '`int_plus` adds two numbers in `x`-representation together and returns their
    sum in `x`-representation:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`int_plus` 在 `x` 表示法中将两个数字相加，并返回它们的和，以 `x` 表示法返回：'
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: plus
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: plus
- en: 'To add decimal integers, use the `plus` function, which converts to and from
    `x`-representation and calls `int_plus`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要加法十进制整数，请使用 `plus` 函数，它会在 `x` 表示法和整数之间转换，并调用 `int_plus`：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: int_subtract
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: int_subtract
- en: '`int_subtract` subtracts two numbers in `x`-representation and returns the
    difference in `x`-representation:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`int_subtract` 在 `x` 表示法中减去两个数字，并返回它们的差值，仍然以 `x` 表示法返回：'
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If the difference will be less than 0 (which can’t be represented), an error
    occurs.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果差值小于 0（无法表示），则会发生错误。
- en: subtract
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: subtract
- en: 'To subtract decimal integers, use the `subtract` function, which converts to
    and from `x`-representation and calls `int_subtract`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要减去十进制整数，请使用 `subtract` 函数，它会在 `x` 表示法和整数之间转换，并调用 `int_subtract`：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If the difference will be less than 0 (which can’t be represented), an error
    occurs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果差值小于 0（无法表示），则会发生错误。
- en: int_multiply
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: int_multiply
- en: '`int_multiply` multiplies two numbers that are in `x`-representation:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`int_multiply` 在 `x` 表示法中乘以两个数字：'
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: multiply
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: multiply
- en: '`multiply` will multiply two decimal integers and return their product. It
    automatically converts to and from `x`-representation and calls `int_multiply`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiply` 将两个十进制整数相乘并返回它们的积。它会自动在 `x` 表示法和整数之间转换，并调用 `int_multiply`：'
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: int_divide
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: int_divide
- en: '`int_divide` divides one number by another; both are in `x`-representation,
    as is the result:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`int_divide` 将一个数字除以另一个；两个数字都以 `x` 表示法表示，结果也是如此：'
- en: '[PRE47]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: divide
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: divide
- en: 'The `divide` function calls `int_divide` to divide two decimal integers, automatically
    converting to and from `x`-representation:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`divide` 函数调用 `int_divide` 来除以两个十进制整数，自动进行 `x` 表示法的转换：'
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: int_max and int_min
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: int_max 和 int_min
- en: '`int_max` and `int_min` return the maximum and minimum, respectively, of two
    numbers in `x`-representation:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`int_max` 和 `int_min` 分别返回两个数字中的最大值和最小值，结果是 `x` 表示法：'
- en: '[PRE49]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: max and min
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: max 和 min
- en: 'The decimal integer equivalents of `int_max` and `int_min` are `max` and `min`;
    they automatically convert to and from `x`-representation:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`int_max` 和 `int_min` 的十进制整数等价物分别是 `max` 和 `min`；它们会自动转换为 `x` 表示法并从中转换：'
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: int_inc
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: int_inc
- en: '`int_inc` is a small helper function that just adds one to an `x`-representation
    number:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`int_inc` 是一个小的辅助函数，它仅仅将一个 `x` 表示法的数字加一：'
- en: '[PRE51]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: inc
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: inc
- en: 'The `inc` function adds one to a decimal integer:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`inc` 函数将一个十进制整数加一：'
- en: '[PRE52]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: int_dec
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: int_dec
- en: 'The opposite of `int_inc` is `int_dec`: it decreases a number by one:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`int_inc` 的反操作是 `int_dec`：它将一个数字减去一：'
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: dec
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: dec
- en: 'The `dec` function decrements a decimal integer by one:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`dec` 函数将一个十进制整数减一：'
- en: '[PRE54]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: int_double
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: int_double
- en: The `double` and `halve` functions (and their `int_double` and `int_halve` equivalents)
    are provided for performance reasons. If you’re multiplying by two or dividing
    by two, these functions will be faster than multiplication and division.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`double` 和 `halve` 函数（以及它们的 `int_double` 和 `int_halve` 等价函数）是为了性能考虑而提供的。如果你需要乘以二或除以二，这些函数的执行速度会比乘法和除法更快。'
- en: '`int_double` will double an integer:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`int_double` 会将整数乘以二：'
- en: '[PRE55]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: double
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: double
- en: '`double` will double a decimal integer:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`double` 会将一个十进制整数乘以二：'
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Internally, it converts to `x`-representation and calls `int_double`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 它在内部将其转换为 `x` 表示法并调用 `int_double`。
- en: int_halve
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: int_halve
- en: 'You can perform an integer division by two by calling `int_halve` on an `x`-representation
    number:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过对一个 `x` 表示法的数字调用 `int_halve` 来执行整数除以二的操作：
- en: '[PRE57]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: halve
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: halve
- en: 'Finally, there’s `halve`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是 `halve`：
- en: '[PRE58]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is the decimal integer equivalent of `int_halve`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `int_halve` 的十进制整数等价物。
- en: Integer Comparison Functions
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数比较函数
- en: 'All the integer comparison functions return `$(true)` or `$(false)`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的整数比较函数返回 `$(true)` 或 `$(false)`：
- en: '[PRE59]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: These can be used with GNU `make` and GMSL functions as well as with directives
    that expect Boolean values (such as the GMSL logical operators).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可以与 GNU `make` 和 GMSL 函数一起使用，也可以与需要布尔值的指令一起使用（如 GMSL 逻辑运算符）。
- en: 'But you are more likely to use these versions of the comparison functions:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你更可能使用这些比较函数的版本：
- en: '[PRE60]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: These operate on decimal integers, not the internal `x`-representation that
    GMSL uses.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数作用于十进制整数，而不是 GMSL 使用的内部 `x` 表示法。
- en: Miscellaneous Integer Functions
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 杂项整数函数
- en: Most likely, you’re not going to need to do anything advanced with GNU `make`
    arithmetic, but the miscellaneous functions detailed here do base conversions
    and generation of numeric sequences. They can, on occasion, be useful.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你不需要做任何复杂的 GNU `make` 算术运算，但是这里详细介绍的杂项函数用于基本转换和数字序列的生成。有时它们会很有用。
- en: sequence
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sequence
- en: 'You use the `sequence` function to generate a sequence of numbers:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `sequence` 函数来生成一个数字序列：
- en: '[PRE61]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: For example, `$(call sequence,10,15)` will be the list `10 11 12 13 14 15`.
    To create a decreasing sequence, you invert the parameters to `sequence`. For
    example, `$(call sequence,15,10)` will be the list `15 14 13 12 11 10`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`$(call sequence,10,15)` 将会得到列表 `10 11 12 13 14 15`。要创建一个递减的序列，你只需要反转 `sequence`
    的参数。例如，`$(call sequence,15,10)` 将会得到列表 `15 14 13 12 11 10`。
- en: dec2hex, dec2bin, and dec2oct
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: dec2hex、dec2bin 和 dec2oct
- en: 'The `dec2hex`, `dec2bin`, and `dec2oct` functions perform conversion between
    decimal numbers and hexadecimal, binary, and octal forms:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`dec2hex`、`dec2bin` 和 `dec2oct` 函数用于在十进制数字和十六进制、二进制、八进制之间进行转换：'
- en: '[PRE62]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: For example, `$(call dec2hex,42)` will be `2a`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`$(call dec2hex,42)` 会得到 `2a`。
- en: 'No options are available for padding with leading zeroes. If that’s necessary,
    you can use GMSL string functions. For example, here’s a padded version of `dec2hex`
    that takes two parameters: a decimal number to be converted to hexadecimal and
    the number of digits to output:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 没有用于填充前导零的选项。如果需要，可以使用 GMSL 字符串函数。例如，下面是一个填充版的 `dec2hex`，它接受两个参数：一个十进制数字要转换为十六进制，以及输出的位数：
- en: '[PRE63]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This works by defining some helper functions. First, `repeat` creates a string
    consisting of a number of copies of another string. For example, `$(call repeat,10,A)`
    will be `AAAAAAAAAA`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个通过定义一些辅助函数来实现。首先，`repeat`会创建一个由若干个相同字符串组成的字符串。例如，`$(call repeat,10,A)` 将返回
    `AAAAAAAAAA`。
- en: 'Some subtle things are happening in this definition. The `repeat` function
    calls `__repeat` with three parameters: `$1` is the string to be repeated, `$2`
    is the number of times to repeat `$1`, and `$3` has been set to a blank string
    by the trailing comma in the `$(call)` to __`repeat`. The `$0` variable contains
    the name of the current function; in `__repeat` it will be `__repeat`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义中发生了一些微妙的事情。`repeat`函数会用三个参数调用`__repeat`：`$1`是要重复的字符串，`$2`是重复`$1`的次数，`$3`在`$(call)`调用`repeat`时通过尾随逗号被设置为空字符串。`$0`变量包含当前函数的名称；在`__repeat`中，它将是`__repeat`。
- en: The `__repeat` function is recursive and uses the `$2` as the recursion guard.
    The `repeat` function converts the number of desired repeats into the `x`-representation
    used by GMSL arithmetic functions and passes it to `__repeat`. For example, `$(call
    repeat,Hello,5)` turns into `$(call __repeat,Hello,x x x x x,)`, and `__repeat`
    chops an `x` off `$2` each time around until `$2` is empty.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`__repeat`函数是递归的，并且使用`$2`作为递归的终止条件。`repeat`函数将所需的重复次数转换为GMSL算术函数使用的`x`表示法，并将其传递给`__repeat`。例如，`$(call
    repeat,Hello,5)` 会变成 `$(call __repeat,Hello,x x x x x,)`，然后`__repeat`会每次从`$2`中去掉一个`x`，直到`$2`为空。'
- en: 'With `repeat` written, we just need a way to pad a string to some number of
    characters with a padding character. The function `pad` achieves that:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`repeat`函数后，我们只需要一种方法来将字符串填充到指定的字符数，并用填充字符来填充。`pad`函数实现了这个功能：
- en: '[PRE64]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Its three arguments are the character to pad with, the total width of the padded
    output in character, and the string to pad. For example, `$(call pad,0,4,2a)`
    would return `002a`. From that, a padded `dec2hex` can easily be defined. It takes
    two parameters: the first is the decimal number to convert to hexadecimal, and
    the second is the number of characters to pad to.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 它的三个参数分别是填充字符、填充后的输出宽度（字符数）和要填充的字符串。例如，`$(call pad,0,4,2a)` 将返回 `002a`。由此，可以轻松地定义一个填充后的`dec2hex`。它接受两个参数：第一个是要转换为十六进制的十进制数字，第二个是填充到的字符数。
- en: As you’d expect, `$(call paddeddec2hex,42,8)` returns `0000002a`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预期的那样，`$(call paddeddec2hex,42,8)` 返回 `0000002a`。
- en: List Manipulation Functions
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表操作函数
- en: In GNU `make` and GMSL terms, a list is a string of characters that has whitespace
    as separators. Both the GNU `make` built-in functions that work on lists and the
    GMSL functions treat multiple whitespaces as a single space. So the lists `1 2
    3` and `1 2 3` are the same.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在GNU `make`和GMSL中，列表是由空格分隔的字符字符串。GNU `make`内建的对列表操作的函数和GMSL函数都将多个空格视为一个空格。所以，`1
    2 3`和`1 2 3`是相同的。
- en: I’ll explain a few of the list manipulation functions in detail in the following
    sections. These functions are more complicated than the others in their use, and
    they’re typically available in functional languages.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在接下来的几节中详细解释一些列表操作函数。这些函数在使用上比其他函数更为复杂，通常在函数式语言中可用。
- en: Applying a Function to a List with map
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将函数应用到列表上，使用map
- en: 'When you’re working with GNU `make` functions (either built-ins or your own),
    you’re actually programming in a simple functional language. In functional programming,
    it’s common to have a map function that applies a function to every element of
    a list. GMSL defines `map` to do exactly that. For example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用GNU `make`函数（无论是内建的还是自定义的）时，实际上你是在一个简单的函数式语言中编程。在函数式编程中，常常会有一个`map`函数，它会将一个函数应用于列表中的每个元素。GMSL定义了`map`来做到这一点。例如：
- en: '[PRE65]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Given a list of filenames (perhaps with paths specified) in `SRCS`, this will
    ensure that all the filenames are lowercased and then apply the `uniq` function
    to get a unique list of source files.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个包含文件名（可能带有路径）的列表`SRCS`，这将确保所有文件名都转为小写，并应用`uniq`函数来获取一个唯一的源文件列表。
- en: This uses the GMSL function `lc` to lowercase each filename in `SRCS`. You can
    use the `map` function with both built-in and user-defined functions. Here, `NORMALIZED`
    would be `src/foo.c src/submodule/bar.c`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了GMSL函数`lc`来将`SRCS`中的每个文件名转为小写。你可以将`map`函数与内建函数和用户自定义函数一起使用。在这里，`NORMALIZED`将会是`src/foo.c
    src/submodule/bar.c`。
- en: 'Another use of `map` might be to get the size of every source file:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`的另一个使用场景是获取每个源文件的大小：'
- en: '[PRE66]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here we define a `size` function that uses `$(shell)` to call `wc`, and then
    we apply it to every file in `SRCS`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们定义了一个`size`函数，它使用`$(shell)`来调用`wc`，然后我们将其应用到`SRCS`中的每个文件。
- en: Here `SOURCE_SIZES` might be something like `1538 1481` with one element for
    each source file.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `SOURCE_SIZES` 可能是类似 `1538 1481` 的内容，每个源文件对应一个元素。
- en: Making a reduce Function
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个 reduce 函数
- en: 'Another common function in functional languages is `reduce`. `reduce` applies
    a function that takes two parameters to successive elements of a list, feeding
    the return value from the function into the next call to it. The GMSL doesn’t
    have a built-in `reduce` function, but you can easily define it:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程语言中，另一个常见的函数是 `reduce`。`reduce` 对列表的连续元素应用一个接受两个参数的函数，并将该函数的返回值作为参数传递给下一个调用。GMSL
    没有内置的 `reduce` 函数，但你可以很容易地定义一个：
- en: '[PRE67]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Summing a List of Numbers Using reduce
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 reduce 对数字列表求和
- en: 'Combining `reduce` with the `plus` function, you can easily make a GNU `make`
    function that sums a list of numbers:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `reduce` 与 `plus` 函数结合使用，你可以轻松创建一个 GNU `make` 函数来对数字列表求和：
- en: '[PRE68]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `sum-list` function takes a single parameter, a list of numbers, and returns
    the sum of those numbers. It passes three things to `reduce`: the name of the
    function to call for each element of the list (in this case, `plus`), the list
    of numbers, and a starting number (in this case, `0`).'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum-list` 函数接受一个参数，即一个数字列表，并返回这些数字的总和。它将三个参数传递给 `reduce`：每个列表元素调用的函数名称（在此为
    `plus`），数字列表，以及一个起始值（在此为 `0`）。'
- en: 'Here’s how it works. Suppose `$(call sum-list,1 2 3 4 5)` is called. The following
    sequence of calls to `plus` will be performed:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它的工作原理。假设调用了 `$(call sum-list,1 2 3 4 5)`。接下来会依次调用 `plus` 函数：
- en: '[PRE69]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The first call uses the first element of the list and the starting number `0`.
    Each subsequent call uses the next element from the list and the last result of
    calling `plus`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用使用列表的第一个元素和起始值 `0`。每一次后续的调用使用列表中的下一个元素和上次调用 `plus` 函数的结果。
- en: 'You could combine `sum-list` with the `SOURCE_SIZES` variable to get the total
    size of the source code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `sum-list` 与 `SOURCE_SIZES` 变量结合使用，以获取源代码的总大小：
- en: '[PRE70]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In this case, `TOTAL_SIZE` would be `3019`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`TOTAL_SIZE` 会是 `3019`。
- en: Mapping a Function Across a Pair of Lists
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对一对列表映射函数
- en: 'The other interesting function that GMSL defines for lists is `pairmap`. It
    takes three arguments: two lists (which should be the same length) and a function.
    The function is applied to the first element of each list, the second element,
    the third element, and so on.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: GMSL 为列表定义的另一个有趣的函数是 `pairmap`。它接受三个参数：两个列表（它们应该有相同的长度）和一个函数。该函数依次作用于每个列表的第一个元素、第二个元素、第三个元素，依此类推。
- en: 'Suppose `SRCS` contains a list of source files. Using the `size` function we
    defined, combined with `map`, we defined `SOURCE_SIZES`, which contains a list
    of the sizes of each source file. Using `pairmap`, we can zip the two lists together
    to output the name of each file and its size:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `SRCS` 包含一个源文件列表。使用我们定义的 `size` 函数，结合 `map`，我们定义了 `SOURCE_SIZES`，它包含了每个源文件的大小列表。通过使用
    `pairmap`，我们可以将这两个列表压缩在一起，输出每个文件的名称及其大小：
- en: '[PRE71]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `zip` function is applied to each source filename and size in turn, and
    makes a string separating the filename and its size with a colon. Using our example
    files and sizes from this section, `SOURCES_WITH_SIZES` would be `src/foo.c:1538
    src/submodule/bar.c:1481`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip` 函数依次作用于每个源文件名和文件大小，并生成一个用冒号分隔文件名和文件大小的字符串。使用我们在本节中的示例文件和大小，`SOURCES_WITH_SIZES`
    可能会是 `src/foo.c:1538 src/submodule/bar.c:1481`。'
- en: first
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: first
- en: '`first` takes in a list and returns its first element:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`first` 函数接收一个列表并返回其第一个元素：'
- en: '[PRE72]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note that `first` is identical to the GNU `make` function `$(firstword)`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`first` 与 GNU `make` 函数 `$(firstword)` 是相同的。
- en: last
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: last
- en: 'The `last` function returns the final element of a list:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`last` 函数返回列表的最后一个元素：'
- en: '[PRE73]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: GNU `make` 3.81 introduced `$(lastword)`, which works the same way `last` does.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 3.81 引入了 `$(lastword)`，它的工作方式与 `last` 相同。
- en: rest
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其余部分
- en: 'The `rest` function is almost the opposite of `first`. It returns everything
    but the first element of a list:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`rest` 函数几乎是 `first` 的相反。它返回列表中的所有元素，除了第一个元素：'
- en: '[PRE74]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: chop
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: chop
- en: 'To remove the last element of a list, use the `chop` function:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除列表中的最后一个元素，请使用 `chop` 函数：
- en: '[PRE75]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: map
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: map
- en: 'The `map` function iterates over a list (its second argument) and calls a function
    (named in its first argument) on each list element. The list of values returned
    by each call to the named function is returned:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 函数遍历一个列表（它的第二个参数），并对每个列表元素调用一个函数（函数名在第一个参数中）。每次调用该函数时返回的值将组成一个列表，并返回该列表：'
- en: '[PRE76]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: pairmap
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pairmap
- en: '`pairmap` is similar to map but iterates over a pair of lists:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`pairmap` 类似于 `map`，但它遍历一对列表：'
- en: '[PRE77]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The function in the first argument is called with two arguments: one element
    from each of the lists being iterated over.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数中的函数被调用时，会传入两个参数：来自每个被迭代列表的一个元素。
- en: leq
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: leq
- en: 'The `leq` list equality testing function will correctly return `$(true)` for
    lists that are identical other than having different whitespace:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`leq` 列表相等性测试函数会正确地为完全相同的列表返回 `$(true)`，即使它们仅因空格不同而有所差异：'
- en: '[PRE78]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: For example, `leq` considers `1 2 3` and `1 2 3` to be the same list.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`leq` 会认为 `1 2 3` 和 `1 2 3` 是相同的列表。
- en: lne
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: lne
- en: '`lne` is the opposite of `leq`: it returns `$(true)` when two lists are not
    equal:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`lne` 是 `leq` 的反操作：当两个列表不相等时，它返回 `$(true)`：'
- en: '[PRE79]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: reverse
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: reverse
- en: To `reverse` a list can be useful (particularly because it can then be fed into
    `$(foreach)` and iterated backward).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 将列表 `reverse` 反转可能是有用的（特别是因为它可以作为输入传递给 `$(foreach)` 并反向迭代）。
- en: '[PRE80]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: uniq
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: uniq
- en: 'The built-in `$(sort)` function will deduplicate a list, but it does so at
    the same time as sorting it. The GMSL `uniq` function deduplicates a list while
    preserving the order in which elements are first found:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 内建的 `$(sort)` 函数会去重列表，但它会在排序的同时进行去重。而 GMSL 的 `uniq` 函数则会去重列表，同时保留元素第一次出现的顺序：
- en: '[PRE81]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: For example, `$(call uniq,a c b a c b)` will return `a c b`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`$(call uniq,a c b a c b)` 将返回 `a c b`。
- en: length
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: length
- en: 'To find out the number of elements in a list, call `length`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出列表中的元素数量，可以调用 `length`：
- en: '[PRE82]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The `length` function is the same as the GNU `make $(words)` function.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`length` 函数与 GNU `make $(words)` 函数相同。'
- en: String Manipulation Functions
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串操作函数
- en: 'A string is a sequence of any characters, including whitespace. The string
    equality (and string inequality) function `seq` works even with strings that contain
    whitespace or consist only of whitespace. For example:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是由任何字符组成的序列，包括空格。字符串相等性（和字符串不等式）函数 `seq` 即使处理包含空格或仅由空格组成的字符串时也能正常工作。例如：
- en: '[PRE83]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This outputs `T` five times, indicating that each call to `seq` or `sne` returned
    `$(true)`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出 `T` 五次，表示每次调用 `seq` 或 `sne` 都返回了 `$(true)`。
- en: As with the list manipulation functions, I’ll cover a few of the more complicated
    functions in detail in the following sections.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表操作函数类似，我将在接下来的部分详细介绍一些更复杂的函数。
- en: Splitting CSV Data into a GNU make List
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 CSV 数据拆分成 GNU make 列表
- en: 'You can use the `split` function to turn a value in CSV format into a GNU `make`
    list. For example, splitting on a comma turns a CSV line into a list from which
    individual items can be extracted:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `split` 函数将 CSV 格式的值转换为 GNU `make` 列表。例如，以逗号为分隔符将 CSV 行分割成一个列表，然后可以从中提取各个项：
- en: '[PRE84]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Notice how the variable `comma` is defined to contain a comma character so it
    can be used in the `$(call)` to the `split` function. This trick was discussed
    in [Chapter 1](ch01.html "Chapter 1. The Basics Revisited").
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 注意变量 `comma` 如何被定义为包含逗号字符，以便它可以在 `$(call)` 中传递给 `split` 函数。这个技巧在[第1章](ch01.html
    "第1章：基础知识回顾")中有讨论。
- en: Making a PATH from a List of Directories
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从目录列表创建 PATH
- en: 'The `merge` function does the opposite of `split`: it makes a string from a
    list by separating the list items by some character. For example, to turn a list
    of directories into a form suitable for the `PATH` (which is usually separated
    by colons), define `list-to-path` as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge` 函数的作用与 `split` 相反：它通过某个字符分隔列表项，将列表转化为一个字符串。例如，要将一个目录列表转换为适合 `PATH`
    的格式（通常由冒号分隔），可以按如下方式定义 `list-to-path`：'
- en: '[PRE85]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This outputs `/usr/bin:/usr/sbin:/usr/local/bin:/home/me/bin`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出 `/usr/bin:/usr/sbin:/usr/local/bin:/home/me/bin`。
- en: Translating Characters Using tr
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `tr` 转换字符
- en: The most complicated string function is `tr`, which operates like the tr shell
    program. It transforms each character from a collection of characters into a corresponding
    character in a second list. The GMSL defines some common character classes for
    use with `tr`. For example, it defines variables called `[A-Z]` and `[a-z]` (yes,
    those are really the names) that contain the uppercase and lowercase characters.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 最复杂的字符串函数是 `tr`，它的操作方式类似于 `tr` shell 程序。它将一个字符集中的每个字符转换为第二个列表中的相应字符。GMSL 为 `tr`
    定义了一些常见的字符类。例如，它定义了名为 `[A-Z]` 和 `[a-z]` 的变量（是的，它们真的是这个名字），分别包含大写字母和小写字母。
- en: 'We can use `tr` to make a function that translates to leet-speak:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `tr` 创建一个函数，将其转换为黑客语言（leet-speak）：
- en: '[PRE86]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This outputs `1 4M 4N 31173 GNU M4K3 H4X0R`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出 `1 4M 4N 31173 GNU M4K3 H4X0R`。
- en: seq
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: seq
- en: 'The slightly confusingly named `seq` function tests whether two strings are
    equal:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 命名略显混乱的 `seq` 函数测试两个字符串是否相等：
- en: '[PRE87]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: sne
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sne
- en: 'The opposite, string inequality, is tested with `sne`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的字符串不等式可以通过 `sne` 来测试：
- en: '[PRE88]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: streln
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: streln
- en: 'The `length` function gets the length of a list; the equivalent for strings
    is `strlen`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`length`函数获取列表的长度；对于字符串，等效的函数是`strlen`：'
- en: '[PRE89]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: substr
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: substr
- en: 'It’s possible to extract a substring using the `substr` function:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`substr`函数提取子字符串：
- en: '[PRE90]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Note that in GMSL, strings start from position 1, not 0.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在GMSL中，字符串从位置1开始，而不是0。
- en: split
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: split
- en: 'To split a string into a list, you use the `split` function:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字符串分割成列表，可以使用`split`函数：
- en: '[PRE91]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Note that if the string contains spaces, the result may not be as expected.
    GNU `make`’s use of spaces as the list delimiter makes working with spaces and
    lists together very difficult. See [Chapter 4](ch04.html "Chapter 4. Pitfalls
    and Problems") for more on GNU `make`’s handling of spaces.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果字符串包含空格，结果可能不符合预期。GNU `make`使用空格作为列表分隔符，使得同时处理空格和列表变得非常困难。有关GNU `make`如何处理空格的更多信息，请参见[第4章](ch04.html
    "第4章.陷阱与问题")。
- en: merge
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: merge
- en: '`merge` is the opposite of `split`. It takes a list and outputs a string with
    a character between each list element:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge`是`split`的相反操作。它接受一个列表，并在每个列表元素之间插入一个字符输出字符串：'
- en: '[PRE92]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: tr
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: tr
- en: 'You use the `tr` function to translate individual characters, and it’s a building
    block for creating the `uc` and `lc` functions:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`tr`函数可以转换单个字符，它是创建`uc`和`lc`函数的构建块：
- en: '[PRE93]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: uc
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: uc
- en: '`uc` performs simple uppercasing of the alphabet a-z:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`uc`对字母a-z进行简单的大写转换：'
- en: '[PRE94]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: lc
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: lc
- en: 'Finally, we have `lc`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有了`lc`：
- en: '[PRE95]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This performs simple lowercasing of the alphabet A-Z.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数对字母A-Z进行简单的小写转换。
- en: Set Manipulation Functions
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合操作函数
- en: Sets are represented by sorted, deduplicated lists. To create a set from a list,
    use `set_create` or start with the `empty_set` and `set_insert` individual elements.
    The empty set is defined by the variable `empty_set`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 集合通过排序去重的列表表示。要从列表中创建集合，可以使用`set_create`，或者从`empty_set`开始并使用`set_insert`插入各个元素。空集合由变量`empty_set`定义。
- en: 'For example, a makefile could keep track of all the directories that it made
    using the marker technique discussed in [Making Directories](ch04.html#making_directories
    "Making Directories"):'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个 makefile 可以使用在[创建目录](ch04.html#making_directories "创建目录")中讨论的标记技术来跟踪它创建的所有目录：
- en: '[PRE96]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Updating the `make_dir` function (which creates rules to make directories) with
    a call to `set_insert` means that the variable `MADE_DIRS` will keep track of
    the set of directories created.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`make_dir`函数（用于创建目录的规则）中调用`set_insert`，意味着变量`MADE_DIRS`将跟踪已创建的目录集合。
- en: In a real makefile, many directories would likely be built, and using a set
    would be an easy way to discover which had been built at any point.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个真实的 makefile 中，可能会构建许多目录，使用集合是一种简单的方式来发现任何时刻哪些目录已经被构建。
- en: Note that because a set is implemented as a GNU `make` list, you can’t insert
    an item that contains a space.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于集合是作为GNU `make`列表实现的，因此无法插入包含空格的项目。
- en: set_create
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: set_create
- en: 'You create a set by using the `set_create` function:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`set_create`函数来创建一个集合：
- en: '[PRE97]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: It takes a list of elements and adds them to a set. The set itself is returned.
    Note that set elements may not contain spaces.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个元素列表并将它们添加到集合中。集合本身会被返回。注意，集合元素不能包含空格。
- en: set_insert
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: set_insert
- en: 'Once a set has been created using `set_create`, you can add an element to it
    using `set_insert`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通过`set_create`创建了集合，可以使用`set_insert`向其中添加元素：
- en: '[PRE98]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: set_remove
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: set_remove
- en: 'To remove an element from a set, call `set_remove`:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 要从集合中移除一个元素，可以调用`set_remove`：
- en: '[PRE99]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: It is not an error to remove an element from a set when that element was not
    present.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 从集合中移除一个元素时，如果该元素不存在，则不会报错。
- en: set_is_member
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: set_is_member
- en: 'To test whether an element is a member of a set, call `set_is_member`. It returns
    a Boolean value indicating whether the element was present:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试一个元素是否是集合的成员，可以调用`set_is_member`。它返回一个布尔值，指示该元素是否存在：
- en: '[PRE100]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: set_union
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: set_union
- en: 'You merge two sets together by calling the `set_union` function on the two
    sets. The merged set is returned:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对两个集合调用`set_union`函数，你可以将两个集合合并。合并后的集合会被返回：
- en: '[PRE101]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: set_intersection
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: set_intersection
- en: 'To determine the elements common to two sets, use `set_intersection`. It returns
    the set of elements that were present in both sets passed in as arguments:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定两个集合的共同元素，可以使用`set_intersection`。它返回作为参数传入的两个集合中都存在的元素集合：
- en: '[PRE102]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: set_is_subset
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: set_is_subset
- en: 'It is sometimes useful to know if one set is a subset of another, which you
    can test by calling `set_is_subset`:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，了解一个集合是否是另一个集合的子集是很有用的，可以通过调用`set_is_subset`来进行测试：
- en: '[PRE103]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '`set_is_subset` returns a Boolean value indicating whether the first set is
    a subset of the second.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_is_subset`返回一个布尔值，指示第一个集合是否是第二个集合的子集。'
- en: set_equal
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: set_equal
- en: 'To determine if two sets are equal, call `set_equal`:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定两个集合是否相等，请调用`set_equal`：
- en: '[PRE104]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '`set_equal` returns `$(true)` if the two sets have exactly the same elements.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_equal`返回`$(true)`，如果两个集合具有完全相同的元素。'
- en: Associative Arrays
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联数组
- en: An *associative array* maps a key value (a string with no spaces in it) to a
    single value (any string). Associative arrays are sometimes referred to as maps
    or even hash tables (although that’s an implementation detail, and the GMSL associative
    arrays do not use hashing).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*关联数组*将一个键值（没有空格的字符串）映射到一个单一的值（任意字符串）。关联数组有时也被称为映射（maps）或哈希表（尽管那是一个实现细节，GMSL
    的关联数组并不使用哈希）。
- en: 'You can use associative arrays as *lookup tables*. For example:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用关联数组作为*查找表*。例如：
- en: '[PRE105]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: This small makefile gets a list of all the `.c` files in the current directory
    and their sizes, and then it makes an associative array mapping from a filename
    to its size.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小的 Makefile 获取当前目录中所有 `.c` 文件及其大小的列表，然后将文件名和大小之间建立关联数组映射。
- en: The `get-size` function uses `wc` to get the number of bytes in a file. The
    `C_FILES` variable contains all the `.c` files in the current directory. The `$(foreach)`
    uses the GMSL `set` function to set a mapping in an associative array called `c_files`
    between each `.c` file and its size.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`get-size`函数使用`wc`获取文件中的字节数。`C_FILES`变量包含当前目录中的所有`.c`文件。`$(foreach)`使用GMSL的`set`函数在名为`c_files`的关联数组中设置每个`.c`文件及其大小的映射。'
- en: 'Here’s an example run:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例运行：
- en: '[PRE106]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The first line is a list of all the `.c` files found; it’s printed using the
    `keys` function to get all the keys in the associative array. The second line
    comes from looking up the length of `foo.c` using `get`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是所有`.c`文件的列表；它是通过`keys`函数获取关联数组中的所有键来打印的。第二行是通过使用`get`查找`foo.c`的长度来得到的。
- en: set
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: set
- en: The GMSL keeps internal track of named associative arrays, but it is not necessary
    to explicitly create them. Simply call `set` to add elements to the array, and
    the array will be created if it does not exist. Note that array keys cannot contain
    spaces.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: GMSL 会跟踪命名的关联数组，但不需要显式创建它们。只需调用`set`来添加元素到数组中，如果数组不存在，它会自动创建。请注意，数组的键不能包含空格。
- en: '[PRE107]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: get
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取
- en: To retrieve an item from an associate array, call `get`. If the key is not present,
    `get` will return an empty string.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 要从关联数组中检索项，请调用`get`。如果键不存在，`get`将返回一个空字符串。
- en: '[PRE108]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: keys
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 键
- en: 'The `keys` function returns a list of all the keys present in an associative
    array. You can use this with `$(foreach)` to iterate an associative array:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`keys`函数返回关联数组中所有键的列表。你可以使用它和`$(foreach)`来遍历关联数组：'
- en: '[PRE109]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: defined
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: defined
- en: 'To test whether a key is present in an associated array, call `defined`:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试某个键是否存在于关联数组中，请调用`defined`：
- en: '[PRE110]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '`defined` returns a Boolean indicating whether the key was defined or not.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`defined`返回一个布尔值，表示键是否已定义。'
- en: Named Stacks
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名栈
- en: 'A *stack* is an ordered list of strings (with no spaces in them). In GMSL,
    stacks are stored internally, and they have names, like associative arrays do.
    For example:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*栈*是一个有序的字符串列表（其中不包含空格）。在GMSL中，栈是内部存储的，并且它们有名称，像关联数组一样。例如：
- en: '[PRE111]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: This small makefile uses a stack to follow a tree of directories.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小的 Makefile 使用栈来跟踪目录树。
- en: traverse-tree
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: traverse-tree
- en: The `traverse-tree` function finds all the subdirectories of its argument (stored
    in `$1`) using the `$(wildcard)` function to find the `.` file that is always
    present in a directory. It uses the `$(patsubst)` function to strip off the trailing
    `/.` from each value returned by `$(wildcard)` to get the full directory name.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`traverse-tree`函数使用`$(wildcard)`函数查找其参数（存储在`$1`中）中的所有子目录，寻找始终存在于目录中的`.`文件。它使用`$(patsubst)`函数去除每个由`$(wildcard)`返回的值中的尾部`/.`，以获得完整的目录名。'
- en: Before it traverses down into that directory, it pushes the directory found
    onto a stack called `dirs`.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历该目录之前，它会将找到的目录推送到名为`dirs`的栈中。
- en: dump-tree
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: dump-tree
- en: The `dump-tree` function `pop`s items off the `dirs` tree until there are none
    left (until the `depth` becomes `0`).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`dump-tree`函数会从`dirs`树中逐个弹出元素，直到没有剩余的元素（直到`depth`变为`0`）。'
- en: '[Example 6-1](ch06.html#directory_structure "Example 6-1. A directory structure")
    shows a directory structure.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-1](ch06.html#directory_structure "示例 6-1. 目录结构")展示了一个目录结构。'
- en: Example 6-1. A directory structure
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-1. 目录结构
- en: '[PRE112]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'If this directory structure exists under `sources`, the makefile will output:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个目录结构存在于`sources`下，Makefile将输出：
- en: '[PRE113]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'If it’s desirable to traverse the directory tree in a depth-first fashion,
    you can use the stack functions to define `dfs`, which searches a directory tree
    and builds the `dirs` stack containing the directories in depth-first order:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如果希望以深度优先的方式遍历目录树，可以使用栈函数来定义 `dfs`，它会搜索目录树并构建包含目录的深度优先顺序的 `dirs` 栈：
- en: '[PRE114]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The `dump-tree` function hasn’t changed (it just outputs everything in the stack
    by successive calls to `pop`). But the `dfs` function is new. It uses a working
    stack called `work` to keep track of directories to visit. It first pushes the
    starting directory onto the `work` stack and then calls the `__dfs` helper.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`dump-tree` 函数没有变化（它通过多次调用 `pop` 来输出栈中的所有内容）。但 `dfs` 函数是新的。它使用一个名为 `work` 的工作栈来跟踪待访问的目录。它首先将起始目录推送到
    `work` 栈中，然后调用 `__dfs` 辅助函数。'
- en: The real work is done by `__dfs`. It pushes the current directory onto the `dirs`
    stack, pushes all the children of that directory onto the `work` stack, and then
    it recurses. Recursion stops when the `work` stack is empty.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 实际工作由 `__dfs` 完成。它将当前目录推送到 `dirs` 栈中，将该目录的所有子目录推送到 `work` 栈中，然后递归。当 `work` 栈为空时，递归停止。
- en: 'The output for the directory structure in [Example 6-1](ch06.html#directory_structure
    "Example 6-1. A directory structure") is now:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 对于目录结构的输出，参见 [示例 6-1](ch06.html#directory_structure "示例 6-1. 一个目录结构") 现在是：
- en: '[PRE115]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: push
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推送
- en: 'Anyone who has used a stack will be familiar with pushing and popping elements.
    The GMSL stack functions are very similar. To add an element to the top of the
    stack, call `push`:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用过栈的人都对推入和弹出元素非常熟悉。GMSL 栈函数非常相似。要将元素添加到栈顶，调用 `push`：
- en: '[PRE116]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: pop
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弹出
- en: 'To retrieve the top element, call `pop`:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取栈顶元素，调用 `pop`：
- en: '[PRE117]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: peek
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看
- en: 'The `peek` function operates like `pop` but doesn’t remove the top stack element;
    it just returns its value:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '`peek` 函数的作用类似于 `pop`，但不会移除栈顶元素；它只返回该元素的值：'
- en: '[PRE118]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: depth
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深度
- en: 'Finally, you can call `depth`:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以调用 `depth`：
- en: '[PRE119]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '`depth` determines how many elements are present on the stack.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`depth` 确定栈中当前有多少个元素。'
- en: Function Memoization
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数记忆化
- en: To reduce the number of calls to slow functions, such as `$(shell)`, a single
    memoization function is provided. For example, suppose a makefile needs to know
    the MD5 values of various files and defines a function `md5`.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少对慢速函数（如 `$(shell)`）的调用，提供了一个单一的记忆化函数。例如，假设一个 Makefile 需要知道各种文件的 MD5 值，并定义了一个
    `md5` 函数。
- en: '[PRE120]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'That’s a pretty expensive function to call (because of the time `md5sum` would
    take to execute), so it would be desirable to call it only once for each file.
    A memoized version of the `md5` function looks like this:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当昂贵的函数调用（因为 `md5sum` 执行时会消耗时间），因此希望每个文件只调用一次。`md5` 函数的记忆化版本如下所示：
- en: '[PRE121]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'It will call the `md5sum` function just once for each inputted filename and
    record the returned value internally so that a subsequent call to `md5once` with
    the same filename returns the MD5 value without having to run `md5sum`. For example:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 它会对每个输入的文件名仅调用一次 `md5sum` 函数，并将返回的值内部记录，以便后续对相同文件名的 `md5once` 调用可以直接返回 MD5 值，而无需重新运行
    `md5sum`。例如：
- en: '[PRE122]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: This prints out the MD5 value of `/etc/passwd` twice but executes `md5sum` only
    once.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出 `/etc/passwd` 的 MD5 值两次，但仅执行一次 `md5sum`。
- en: 'The actual `memoize` function is defined using the GMSL associative array functions:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的 `memoize` 函数是使用 GMSL 关联数组函数定义的：
- en: '[PRE123]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Miscellaneous and Debugging Facilities
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 杂项和调试功能
- en: '[Table 6-1](ch06.html#gmsl_constants "Table 6-1. GMSL Constants") shows constants
    that GMSL defines.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-1](ch06.html#gmsl_constants "表 6-1. GMSL 常量") 显示了 GMSL 定义的常量。'
- en: Table 6-1. GMSL Constants
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1. GMSL 常量
- en: '| Constant | Value | Purpose |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | 值 | 目的 |'
- en: '| --- | --- | --- |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| true | T | The Boolean value true |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| true | T | 布尔值 true |'
- en: '| false | (an empty string) | The Boolean value false |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| false | (一个空字符串) | 布尔值 false |'
- en: '| gmsl_version | 1 1 7 | Current GMSL version number (major minor revision)
    |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| gmsl_version | 1 1 7 | 当前 GMSL 版本号（主版本号、次版本号、修订号） |'
- en: You access these constants as normal GNU `make` variables by wrapping them in
    `$()` or `${}`.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像访问普通 GNU `make` 变量一样，通过将它们包裹在 `$()` 或 `${}` 中来访问这些常量。
- en: gmsl_compatible
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: gmsl_compatible
- en: 'You know the `gmsl_compatible` function from [Checking the GMSL Version](ch06.html#checking_the_gmsl_version
    "Checking the GMSL Version"):'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在 [检查 GMSL 版本](ch06.html#checking_the_gmsl_version "检查 GMSL 版本") 中了解了 `gmsl_compatible`
    函数：
- en: '[PRE124]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: In [Chapter 1](ch01.html "Chapter 1. The Basics Revisited"), you saw a recipe
    for outputting variable values using a pattern rule with target `print-%`. Because
    this is such a useful rule, GMSL defines its own `gmsl-print-%` target that you
    can use to print the value of any variable defined in a makefile that includes
    GMSL.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 基础回顾")中，你看到了一个使用模式规则和目标`print-%`输出变量值的示例。由于这是一个非常有用的规则，GMSL定义了自己的`gmsl-print-%`目标，你可以用它来打印任何在包含GMSL的makefile中定义的变量的值。
- en: 'For example:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE125]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: gmsl-print-%
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: gmsl-print-%
- en: '`gmsl-print-%` can be used to print any makefile variable, including variables
    inside GMSL. For example, `make gmsl-print-gmsl_version` would print the current
    GMSL version.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '`gmsl-print-%`可以用来打印任何makefile变量，包括GMSL内部的变量。例如，`make gmsl-print-gmsl_version`会打印当前的GMSL版本。'
- en: '[PRE126]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: assert
  id: totrans-485
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: assert
- en: 'As discussed in [Makefile Assertions](ch02.html#makefile_assertions "Makefile
    Assertions"), it can be useful to have assertions in a makefile. GMSL provides
    two assertion functions: `assert` and `assert_exists`.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如[Makefile断言](ch02.html#makefile_assertions "Makefile断言")中所讨论的，makefile中的断言是很有用的。GMSL提供了两个断言函数：`assert`和`assert_exists`。
- en: '[PRE127]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: assert_exists
  id: totrans-488
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: assert_exists
- en: 'To assert that an individual file or directory exists, GMSL provides the `assert_exists`
    function:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 要断言某个文件或目录存在，GMSL提供了`assert_exists`函数：
- en: '[PRE128]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Environment Variables
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境变量
- en: '[Table 6-2](ch06.html#gmsl_environment_variables "Table 6-2. GMSL Environment
    Variables") shows GMSL environment variables (or command line overrides), which
    control various bits of functionality.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '[表6-2](ch06.html#gmsl_environment_variables "表6-2. GMSL环境变量")显示了GMSL环境变量（或命令行覆盖项），这些变量控制着各种功能。'
- en: Table 6-2. GMSL Environment Variables
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-2. GMSL环境变量
- en: '| Variable | Purpose |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 目的 |'
- en: '| --- | --- |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GMSL_NO_WARNINGS | If set, prevents GMSL from outputting warning messages.
    For example, arithmetic functions can generate underflow warnings. |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| GMSL_NO_WARNINGS | 如果设置了，防止GMSL输出警告信息。例如，算术函数可能会生成下溢警告。 |'
- en: '| GMSL_NO_ERRORS | If set, prevents GMSL from generating fatal errors: division
    by zero or failed assertions are fatal. |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| GMSL_NO_ERRORS | 如果设置了，防止GMSL生成致命错误：例如除零错误或断言失败都会被认为是致命的。 |'
- en: '| GMSL_TRACE | Enables function tracing. Calls to GMSL functions will result
    in name and arguments being traced. See [Tracing Variable Values](ch02.html#tracing_variable_values
    "Tracing Variable Values") for a discussion of makefile tracing. |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| GMSL_TRACE | 启用函数追踪。调用GMSL函数时，会追踪函数名和参数。有关makefile追踪的讨论，请参见[追踪变量值](ch02.html#tracing_variable_values
    "追踪变量值")。 |'
- en: These environment variables can all be set in the environment or on the command
    line.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 这些环境变量都可以在环境中或命令行中设置。
- en: 'For example, this makefile contains an assertion that will always fail, stopping
    the `make` process:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个makefile包含一个总是失败的断言，导致`make`过程停止：
- en: '[PRE129]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Setting `GMSL_NO_ERRORS` prevents the assertion from stopping the `make` process.
    In that case the output of the `assert` is hidden and `make` continues normally:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`GMSL_NO_ERRORS`可以防止断言停止`make`过程。在这种情况下，`assert`的输出会被隐藏，`make`会正常继续：
- en: '[PRE130]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: A few well-placed GMSL assertions in a makefile can make a big difference. By
    checking for makefile prerequisites (such as the presence of a specific file or
    that a compiler has a certain version number), a conscientious makefile writer
    can alert a user to a problem without forcing them to debug the often arcane output
    from `make`.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在makefile中放置一些适当的GMSL断言可以产生很大的效果。通过检查makefile的前提条件（比如特定文件的存在，或者编译器的版本号），一个有责任心的makefile编写者可以在不迫使用户调试`make`中常常晦涩的输出信息的情况下，提醒用户潜在的问题。
