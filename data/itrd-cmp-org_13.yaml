- en: '**13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**13'
- en: CONTROL FLOW CONSTRUCTS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流构造**
- en: '![Image](../images/pg271_Image_273.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg271_Image_273.jpg)'
- en: When writing a program in C or assembly language, we specify the order in which
    each statement or instruction is executed. This order is called the *control flow*.
    Programming by specifying the control flow is known as *imperative programming*.
    This is in contrast to *declarative programming*, where we state the logic of
    the computation and another program figures out the control flow to perform it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写C语言或汇编语言程序时，我们指定每个语句或指令执行的顺序。这个顺序称为*控制流*。通过指定控制流来编程被称为*命令式编程*。这与*声明式编程*相对，声明式编程中我们只是陈述计算的逻辑，另一个程序则会确定控制流来执行它。
- en: If you have been using `make` to build your programs, as recommended in [Chapter
    2](ch02.xhtml), the statements in your makefile are an example of declarative
    programming. You specify the logic of the results, and the `make` program figures
    out the control flow to produce the results.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直使用`make`来构建你的程序，正如在[第2章](ch02.xhtml)中推荐的那样，你的makefile中的语句就是声明式编程的一个例子。你指定结果的逻辑，而`make`程序则自动确定控制流来生成结果。
- en: 'There are three fundamental control flow constructs: sequence, iteration, and
    selection. You’ve already seen sequence in the programs we’ve written thus far:
    each instruction, or subfunction, is executed in the order in which it’s written.
    In this chapter, I’ll show you how to alter the control flow from the written
    order to iterate the same block of written instructions or to select between several
    blocks of written instructions. You’ll see how each of these control flow constructs
    is implemented at the assembly language level. In [Chapter 14](ch14.xhtml), I’ll
    cover the details of altering control flow by calling a subfunction.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种基本的控制流构造：顺序、迭代和选择。你已经在我们之前写的程序中看到了顺序：每条指令或子函数都是按顺序执行的。在本章中，我将向你展示如何改变控制流，跳过某些指令以迭代相同的指令块，或者在多个指令块之间进行选择。你将看到这些控制流构造如何在汇编语言级别实现。在[第14章](ch14.xhtml)中，我将讲解通过调用子函数来改变控制流的细节。
- en: '**Branches**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**跳转**'
- en: 'A *branch instruction* transfers control flow to the memory location specified
    by the instruction. There are two types of branches: unconditional and conditional.
    Both iteration and selection use conditional branches to alter control flow based
    on a true/false condition. You’ll also often use unconditional branches when implementing
    the iteration and selection flow constructs. We’ll start with those and then look
    at conditional branches.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*跳转指令*将控制流转移到指令指定的内存地址。有两种类型的跳转：无条件跳转和条件跳转。迭代和选择都使用条件跳转来根据真/假的条件改变控制流。在实现迭代和选择流构造时，你也会经常使用无条件跳转。我们先从无条件跳转讲起，然后再看条件跳转。'
- en: '***Unconditional***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***无条件***'
- en: As you learned in [Chapter 9](ch09.xhtml), when an instruction is executed,
    the CPU automatically increments the program counter, `pc`, by 4 to hold the address
    of the next instruction in memory. Instead of adding 4 to the program counter,
    an unconditional branch instruction changes the program counter to the branch
    target address, which causes the CPU to continue program execution at the target
    address.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[第9章](ch09.xhtml)中所学，当一条指令执行时，CPU会自动将程序计数器`pc`加4，以保存内存中下一条指令的地址。无条件跳转指令通过将程序计数器改为跳转目标地址，替代将程序计数器加4，从而使CPU继续在目标地址执行程序。
- en: 'You already learned about one unconditional branch instruction—`ret`, which
    is used to return from functions—in [Chapter 10](ch10.xhtml). There are two others,
    `b` and `br`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了一个无条件跳转指令——`ret`，它用于从函数返回——在[第10章](ch10.xhtml)中讲过。还有两个其他的跳转指令，`b` 和 `br`：
- en: b**—Branch unconditionally**
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: b**—无条件跳转**
- en: '`b` label branches to the address of label within the range of ±128MB from
    this instruction.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`b` label将跳转到距离当前指令±128MB范围内的标签地址。'
- en: br**—Branch register unconditionally**
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: br**—无条件跳转寄存器**
- en: '`br x`s branches to the 64-bit address in `x`s.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`br x`将跳转到`x`中的64位地址。'
- en: The `b` instruction is commonly used together with a conditional branch instruction
    to skip blocks of code or to go back to the beginning of a block of code and execute
    it again. For the `b` instruction, the CPU sign-extends the 26-bit word offset
    between the `b` instruction and label to 64 bits and adds this signed number to
    `pc`. The `br` instruction simply copies the 64 bits in `x`s to `pc`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`b` 指令通常与条件分支指令一起使用，用于跳过代码块或返回代码块的开头并再次执行它。对于 `b` 指令，CPU 会将 `b` 指令与标签之间的 26
    位字偏移符号扩展为 64 位，并将这个符号数加到 `pc` 上。`br` 指令只是将 `x` 寄存器中的 64 位值复制到 `pc` 上。'
- en: Although `br x30` would seem to have the same effect as `ret`, the `br` and
    `ret` instructions are not aliases for each other; they are different instructions.
    The difference is that `br` tells the CPU that this is probably *not* a function
    return, while `ret` tells the CPU that this probably *is* a function return. The
    details are beyond the scope of this book, but these hints can help the CPU optimize
    some of the specifics of executing instructions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `br x30` 看起来与 `ret` 具有相同的效果，但 `br` 和 `ret` 指令并不是彼此的别名；它们是不同的指令。区别在于，`br`
    告诉 CPU 这可能*不是*一个函数返回，而 `ret` 告诉 CPU 这可能*是*一个函数返回。具体细节超出了本书的范围，但这些提示可以帮助 CPU 优化执行指令的某些细节。
- en: '***Conditional***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***条件***'
- en: There are two types of conditional branch instructions. One tests the settings
    of the condition flags in the `nzcv` register (see [Figure 9-4](ch09.xhtml#ch9fig4)
    in [Chapter 9](ch09.xhtml)). We need to use another instruction to set the flags
    before testing them to determine whether to branch or not.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的条件分支指令。一种是测试 `nzcv` 寄存器中的条件标志设置（见[图 9-4](ch09.xhtml#ch9fig4)和[第 9 章](ch09.xhtml)）。我们需要使用另一条指令在测试之前设置标志，以确定是否分支。
- en: The other type of conditional branch instruction tests the value in a register
    to determine whether to branch. Instructions in this group do not depend on the
    condition flags, nor do they change them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的条件分支指令是测试寄存器中的值，以确定是否分支。此组指令不依赖于条件标志，也不会改变它们。
- en: 'I’ll start with the instructions that branch according to the settings of the
    condition flags:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从根据条件标志设置进行分支的指令开始：
- en: b.cond**—Branch conditionally**
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: b.cond**—条件分支**
- en: '`b.`cond label tests the settings in the `nzcv` register and branches to label
    if they match cond, in the range of ±128MB from this instruction. The possible
    values for cond are given in [Table 13-1](ch13.xhtml#ch13tab1).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`b.`cond 标签测试 `nzcv` 寄存器中的设置，如果它们与条件匹配，则跳转到标签，跳转范围为从此指令起的 ±128MB。`cond` 的可能值见[表
    13-1](ch13.xhtml#ch13tab1)。'
- en: '**Table 13-1:** Allowable Branching Condition Codes'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-1：** 允许的分支条件码'
- en: '| **Code** | cond | **Meaning** | **Condition flags** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **代码** | cond | **含义** | **条件标志** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `0000` | `eq` | Equal | *Z* |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `0000` | `eq` | 相等 | *Z* |'
- en: '| `0001` | `ne` | Not equal | ¬*Z* |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `0001` | `ne` | 不相等 | ¬*Z* |'
- en: '| `0010` | `cs` or `hs` | Carry set; unsigned higher or same | *C* |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `0010` | `cs` 或 `hs` | 进位集；无符号大于或相等 | *C* |'
- en: '| `0011` | `cc` or `lo` | Carry not set; unsigned lower | ¬*C* |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `0011` | `cc` 或 `lo` | 进位未设置；无符号小于 | ¬*C* |'
- en: '| `0100` | `mi` | Minus; negative | *N* |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `0100` | `mi` | 负数；负值 | *N* |'
- en: '| `0101` | `pl` | Plus; positive or zero | ¬*N* |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `0101` | `pl` | 正数；正值或零 | ¬*N* |'
- en: '| `0110` | `vs` | Overflow | *V* |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `0110` | `vs` | 溢出 | *V* |'
- en: '| `0111` | `vc` | No overflow | ¬*V* |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `0111` | `vc` | 无溢出 | ¬*V* |'
- en: '| `1000` | `hi` | Unsigned higher | *C* ∧ ¬*Z* |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `1000` | `hi` | 无符号大于 | *C* ∧ ¬*Z* |'
- en: '| `1001` | `ls` | Unsigned lower or same | ¬(*C* ∧ ¬*Z*) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `1001` | `ls` | 无符号小于或相等 | ¬(*C* ∧ ¬*Z*) |'
- en: '| `1010` | `ge` | Signed greater than or equal | *N* = *V* |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `1010` | `ge` | 符号大于或等于 | *N* = *V* |'
- en: '| `1011` | `lt` | Signed less than | ¬(*N* = *V* ) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `1011` | `lt` | 符号小于 | ¬(*N* = *V* ) |'
- en: '| `1100` | `gt` | Signed greater than | ¬*Z* ∧ (*N* = *V* ) |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `1100` | `gt` | 符号大于 | ¬*Z* ∧ (*N* = *V* ) |'
- en: '| `1101` | `le` | Signed less than or equal | ¬(¬*Z* ∧ (*N* = *V* )) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `1101` | `le` | 符号小于或等于 | ¬(¬*Z* ∧ (*N* = *V* )) |'
- en: '| `1110` | `al` | Always | Any |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `1110` | `al` | 总是执行 | 任何 |'
- en: '| `1111` | `nv` | Always | Any |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `1111` | `nv` | 总是执行 | 任何 |'
- en: You should use the `b.`cond instruction when you want to take one of two branches
    in your program, depending on the result of another operation. It’s important
    that the `b.`cond instruction immediately follow the instruction whose result
    is driving the decision to branch. An intervening instruction or function call
    might change the settings of the condition flags, giving an erroneous basis for
    the decision.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在程序中使用`b.`cond指令，当你希望根据另一个操作的结果在两个分支之间做出选择时。重要的是，`b.`cond指令必须紧接在其结果决定分支的指令后面。任何中间的指令或函数调用都可能更改条件标志的设置，从而给出错误的分支依据。
- en: 'In addition to this, there are four instructions that branch depending on the
    value in a general-purpose register:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还有四条指令，它们根据通用寄存器中的值进行分支：
- en: cbz**—Compare and branch if zero**
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: cbz**—如果零则比较并分支**
- en: '`cbz w`s`,` label branches to label if the value in `w`s is `0`, in the range
    of ±1MB from this instruction.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`cbz w`s`,` 如果`w`s中的值为`0`，则跳转到标签，跳转范围为±1MB。'
- en: '`cbz x`s`,` label branches to label if the value in `x`s is `0`, in the range
    of ±1MB from this instruction.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`cbz x`s`,` 如果`x`s中的值为`0`，则跳转到标签，跳转范围为±1MB。'
- en: cbnz**—Compare and branch if not zero**
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: cbnz**—如果不为零则比较并分支**
- en: '`cbnz w`s`,` label branches to label if the value in `w`s is not `0`, in the
    range of ±1MB from this instruction.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`cbnz w`s`,` 如果`w`s中的值不为`0`，则跳转到标签，跳转范围为±1MB。'
- en: '`cbnz x`s`,` label branches to label if the value in `x`s is not `0`, in the
    range of ±1MB from this instruction.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`cbnz x`s`,` 如果`x`s中的值不为`0`，则跳转到标签，跳转范围为±1MB。'
- en: tbz**—Test bit and branch if zero**
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: tbz**—测试位并在零时分支**
- en: '`tbz w`s`,` imm`,` label branches to label if bit number imm in `w`s is `0`,
    in the range of ±1MB from this instruction.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`tbz w`s`,` imm`,` 如果`w`s中的位号imm为`0`，则跳转到标签，跳转范围为±1MB。'
- en: '`tbz x`s`,` imm`,` label branches to label if bit number imm in `x`s is `0`,
    in the range of ±1MB from this instruction.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`tbz x`s`,` imm`,` 如果`x`s中的位号imm为`0`，则跳转到标签，跳转范围为±1MB。'
- en: tbnz**—Test bit and branch if not zero**
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: tbnz**—测试位并在非零时分支**
- en: '`tbnz w`s`,` imm`,` label branches to label if bit number imm in `w`s is not
    `0`, in the range of ±1MB from this instruction.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`tbnz w`s`,` imm`,` 如果`w`s中的位号imm不为`0`，则跳转到标签，跳转范围为±1MB。'
- en: '`tbnz x`s`,` imm`,` label branches to label if bit number imm in `x`s is not
    `0`, in the range of ±1MB from this instruction.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`tbnz x`s`,` imm`,` 如果`x`s中的位号imm不为`0`，则跳转到标签，跳转范围为±1MB。'
- en: '**NOTE**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When using a conditional branch like* b.gt *or* b.le, *it’s easy to forget
    the order of the test: source compared to destination, or destination compared
    to source. When testing my program, I almost always start by using* gdb *and putting
    a breakpoint at the conditional branch instruction. When the program breaks, I
    check the values and use the* si *command to see which way the branch went.*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用条件分支指令如* b.gt *或* b.le *时，*容易忘记测试的顺序：源操作数与目标操作数比较，还是目标与源比较。当调试我的程序时，我几乎总是使用*
    gdb *并在条件分支指令处设置断点。当程序中断时，我检查值并使用* si *命令查看分支的方向。*'
- en: 'Now that you know how to control the flow of instruction execution, I’ll show
    you some programming constructs. We’ll start with repetition. This can be implemented
    in two ways: *iteration*, in which the program loops through a block of code repeatedly
    until a condition is met, and *recursion*, where a function calls itself repeatedly
    until a condition is met.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何控制指令执行的流程，我将向你展示一些编程结构。我们将从重复开始。这可以通过两种方式实现：*迭代*，即程序重复执行一个代码块，直到满足某个条件；以及*递归*，即函数反复调用自身，直到满足条件为止。
- en: I’ll cover iteration in the next section and explain how recursion works when
    I discuss special uses of subfunctions in [Chapter 15](ch15.xhtml).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在下一节中讲解迭代，并在讨论[第15章](ch15.xhtml)时说明递归的特殊用法。
- en: '**Iteration**'
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**迭代**'
- en: Many algorithms use iteration, also known as *looping*. A loop continues the
    iteration of a block of code until the value(s) of the *loop control variable(s)*
    meet a *termination condition* that causes the loop to end. With a looping construct,
    the value(s) of the loop control variable(s) must be changed within the iterated
    block of instructions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 许多算法使用迭代，也称为*循环*。一个循环会持续执行代码块的迭代，直到*循环控制变量*的值满足*终止条件*，导致循环结束。使用循环结构时，*循环控制变量*的值必须在迭代的代码块中发生变化。
- en: Processing a text string one character at a time provides a good example of
    looping. I will use the two system call functions from [Figure 2-1](ch02.xhtml#ch2fig1)
    in [Chapter 2](ch02.xhtml), `write` and `read`, to illustrate the concepts. That
    figure shows that `printf` converts data from its memory storage format to a character
    format and calls the `write` system call function to display the characters on
    the screen. When reading characters from the keyboard, `scanf` calls the `read`
    system call function and converts the characters to a memory storage format.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 逐个字符处理文本字符串是循环的一个很好的例子。我将使用 [图 2-1](ch02.xhtml#ch2fig1) 中的两个系统调用函数，`write` 和
    `read`，来说明这些概念。该图显示，`printf` 将数据从内存存储格式转换为字符格式，并调用 `write` 系统调用函数将字符显示在屏幕上。当从键盘读取字符时，`scanf`
    调用 `read` 系统调用函数，并将字符转换为内存存储格式。
- en: '***write and read System Call Functions***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***write 和 read 系统调用函数***'
- en: The `write` and `read` system call functions see the screen and keyboard as
    files. When a program is first launched, the operating system opens three files—*standard
    input*, *standard output*, and *standard error*—and assigns an integer to each
    file, which is called the *file descriptor*. The program interacts with each file
    by using the file descriptor. The C interfaces for calling `write` and `read`
    are specified in the *Portable Operating System Interface (POSIX)* standard, which
    you can find at *[https://pubs.opengroup.org/onlinepubs/9699919799/](https://pubs.opengroup.org/onlinepubs/9699919799/)*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`write` 和 `read` 系统调用函数将屏幕和键盘视为文件。当程序首次启动时，操作系统打开三个文件——*标准输入*、*标准输出* 和 *标准错误*——并为每个文件分配一个整数，这个整数被称为
    *文件描述符*。程序通过使用文件描述符与每个文件进行交互。调用 `write` 和 `read` 的 C 接口在 *可移植操作系统接口 (POSIX)* 标准中定义，你可以在
    *[https://pubs.opengroup.org/onlinepubs/9699919799/](https://pubs.opengroup.org/onlinepubs/9699919799/)*
    上找到该标准。'
- en: The general formats for calling these two functions are
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这两个函数的一般格式是
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: and
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'where fd is the file descriptor, buf is the address of the character storage,
    and n is the number of characters to write or read. You can read more details
    in the man pages for `write` and `read`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，fd 是文件描述符，buf 是字符存储的地址，n 是要写入或读取的字符数。你可以在 `write` 和 `read` 的手册页中阅读更多细节：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Table 13-2](ch13.xhtml#ch13tab2) shows the file descriptors I’ll use and the
    device each is normally associated with.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 13-2](ch13.xhtml#ch13tab2) 显示了我将使用的文件描述符及其通常关联的设备。'
- en: '**Table 13-2:** The File Descriptors for the `write` and `read` System Call
    Functions'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-2：** `write` 和 `read` 系统调用函数的文件描述符'
- en: '| **Name** | **Number** | **Use** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **编号** | **用途** |'
- en: '| --- | --- | --- |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `STDIN_FILENO` | 0 | Read characters from the keyboard |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `STDIN_FILENO` | 0 | 从键盘读取字符 |'
- en: '| `STDOUT_FILENO` | 1 | Write characters to the screen |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `STDOUT_FILENO` | 1 | 将字符写入屏幕 |'
- en: '| `STDERR_FILENO` | 2 | Write error messages to the screen |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `STDERR_FILENO` | 2 | 将错误信息写入屏幕 |'
- en: These names are defined in the system header file, *unistd.h*, which is located
    at */usr/include/unistd.h* on my Raspberry Pi O (note that the location on your
    system may be different). Now, let’s move on to looping constructs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称在系统头文件 *unistd.h* 中定义，该文件位于我的 Raspberry Pi O 上的 */usr/include/unistd.h*
    （注意，你系统中的位置可能不同）。现在，让我们继续讨论循环结构。
- en: '***while Loop***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***while 循环***'
- en: 'The `while` loop is a fundamental form of looping. Here is the form in C:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环是循环的基本形式。以下是 C 语言中的形式：'
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Before entering the `while` loop, you need to initialize the loop control variable.
    At the beginning of the `while` loop, expression is evaluated as a Boolean. If
    it evaluates to false (`0` in C), control flow continues to next statement. If
    expression evaluates to true—that is, any nonzero value in C—the statements in
    body are executed, the loop control variable is changed, and control flow continues
    at the top with the reevaluation of expression.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入 `while` 循环之前，你需要初始化循环控制变量。在 `while` 循环的开始，表达式会作为布尔值进行求值。如果表达式求值为假（在 C 中为
    `0`），控制流将继续到下一个语句。如果表达式求值为真——即 C 中的任何非零值——则执行循环体内的语句，改变循环控制变量，控制流会重新回到顶部，重新评估表达式。
- en: '[Figure 13-1](ch13.xhtml#ch13fig1) shows the control flow of a `while` loop.
    Although the loop termination condition can be dependent on more than one variable,
    I’ll use just one here to clarify the discussion.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-1](ch13.xhtml#ch13fig1) 显示了 `while` 循环的控制流。虽然循环的终止条件可以依赖于多个变量，但我这里只使用一个变量来澄清讨论。'
- en: '![image](../images/pg276_Image_274.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg276_Image_274.jpg)'
- en: '*Figure 13-1: The control flow of the* while *loop*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：while 循环的控制流*'
- en: '[Listing 13-1](ch13.xhtml#ch13list1) shows how to use a `while` loop to write
    a text string in the terminal window one character at a time.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-1](ch13.xhtml#ch13list1)展示了如何使用`while`循环将文本字符串一个字符一个字符地写入终端窗口。'
- en: '*hello_world.c*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello_world.c*'
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 13-1: A program to write “Hello, World!” one character at a time*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-1：一个将“Hello, World!”一个字符一个字符写入屏幕的程序*'
- en: I use the `#define` directive to give a symbolic name to the `NUL` character
    ❶. The `message_ptr` variable is defined to be a pointer to a `char` type and
    is used as the loop control variable. It’s initialized to point to a text string
    ❷. As you’ll see when we look at the assembly language for this code, the compiler
    will store the text string in a read-only part of memory and store the address
    of the first character in that text string in the `message_ptr` pointer variable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`#define`指令为`NUL`字符 ❶指定了一个符号名称。`message_ptr`变量被定义为指向`char`类型的指针，并作为循环控制变量。它被初始化为指向一个文本字符串
    ❷。正如我们在查看这段代码的汇编语言时看到的，编译器将把文本字符串存储在内存的只读部分，并将该文本字符串中第一个字符的地址存储在`message_ptr`指针变量中。
- en: 'The `while` statement first checks to see if the loop control variable, `message_ptr`,
    is pointing to the `NUL` character ❸; if not, program flow enters the `while`
    loop body and writes the character pointed to by `message_ptr` to the screen ❹.
    The loop control variable is then incremented to point to the next character in
    the text string ❺. Program flow returns to the top of the loop, where the next
    character is checked to see if it’s the `NUL` character. This loop terminates
    when `message_ptr` points to the `NUL` character ❸. Testing for this condition
    first means the program won’t even enter the body of the `while` loop if the string
    is empty, as `message_ptr` will only point to a `NUL` character. This is a subtle
    but important point about `while` loops: the code in the body is never executed
    if the termination condition is already met.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`语句首先检查循环控制变量`message_ptr`是否指向`NUL`字符 ❸；如果不是，程序流程进入`while`循环体，并将`message_ptr`指向的字符写入屏幕
    ❹。然后，循环控制变量递增，指向文本字符串中的下一个字符 ❺。程序流程返回到循环的顶部，检查下一个字符是否是`NUL`字符。当`message_ptr`指向`NUL`字符
    ❸时，循环终止。首先测试这个条件意味着如果字符串为空，程序甚至不会进入`while`循环体，因为`message_ptr`只会指向`NUL`字符。这是一个微妙但重要的`while`循环要点：如果终止条件已经满足，循环体中的代码是永远不会被执行的。'
- en: For [Listing 13-1](ch13.xhtml#ch13list1), the compiler generated the assembly
    language shown in [Listing 13-2](ch13.xhtml#ch13list2).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[示例 13-1](ch13.xhtml#ch13list1)，编译器生成了在[示例 13-2](ch13.xhtml#ch13list2)中显示的汇编语言。
- en: '*hello_world.s*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello_world.s*'
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 13-2: The compiler-generated assembly language for the function in
    [Listing 13-1](ch13.xhtml#ch13list1)*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-2：在[示例 13-1](ch13.xhtml#ch13list1)中的函数对应的编译器生成的汇编语言*'
- en: The assembly language shows that the text string is stored in the `.rodata`
    section ❶. Then, `message_ptr` is initialized to contain the address of the beginning
    of the text string ❷.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言显示，文本字符串存储在`.rodata`部分 ❶。然后，`message_ptr`被初始化为包含文本字符串起始地址的指针 ❷。
- en: Although this assembly language seems to be testing for the termination condition
    at the end of the loop ❹, it follows the logical flow shown in [Figure 13-1](ch13.xhtml#ch13fig1).
    It first branches down to `.L2` ❸, where the test is made for the terminating
    condition, before branching up to `.L3` to start execution of the body of the
    `while` loop ❺. You might notice that the compiler used a `bne` instruction. This
    is the same as `b.ne`; the `.` character is optional when writing the conditional
    branch instructions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这段汇编语言似乎在循环结束时检测终止条件 ❹，但它遵循了[图 13-1](ch13.xhtml#ch13fig1)所示的逻辑流程。首先，它跳转到`.L2`
    ❸，在那里检查终止条件，然后跳转到`.L3`开始执行`while`循环体 ❺。你可能注意到，编译器使用了`bne`指令。它和`b.ne`是一样的；在编写条件分支指令时，`.`字符是可选的。
- en: 'There is a new instruction, `cmp` ❹, in this code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，有一个新的指令，`cmp` ❹：
- en: cmp**—Compare**
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: cmp**—比较**
- en: '`cmp` reg`,` imm subtracts imm from the value in reg and sets the condition
    flags accordingly. The result of the subtraction is discarded.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp` reg`,` imm从寄存器reg的值中减去imm，并根据结果设置条件标志。减法的结果会被丢弃。'
- en: '`cmp` reg1`,` reg2 subtracts the value in reg2 from the value in reg1 and sets
    the condition flags accordingly. The result of the subtraction is discarded.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp` reg1`,` reg2从寄存器reg1的值中减去寄存器reg2的值，并根据结果设置条件标志。减法的结果会被丢弃。'
- en: A `cmp` instruction immediately followed by a conditional branch instruction
    is commonly used to make decisions in a program.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp` 指令紧接着条件分支指令常常用于程序中的决策。'
- en: For comparison with what the compiler did, we’ll follow the `while` loop pattern
    in my assembly language version, shown in [Listing 13-3](ch13.xhtml#ch13list3).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与编译器所做的比较，我们将在我的汇编语言版本中遵循 `while` 循环的模式，如 [清单 13-3](ch13.xhtml#ch13list3)
    所示。
- en: '*hello_world.s*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello_world.s*'
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 13-3: An assembly language program to write Hello, World! one character
    at a time*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-3：一个汇编语言程序，通过一次输出一个字符写出 Hello, World！*'
- en: We could have used a `cbz` instruction in our condition check instead of the
    `cmp` and `b.eq` sequence ❶, but I think the use of `NUL` here is clearer. This
    solution will also work for any terminating character.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以在条件检查中使用 `cbz` 指令，而不是 `cmp` 和 `b.eq` 序列 ❶，但我认为这里使用 `NUL` 更加清晰。这个解决方案同样适用于任何终止字符。
- en: My assembly language solution is less efficient than what the compiler generated
    ([Listing 13-2](ch13.xhtml#ch13list2)), because the `b` instruction is executed
    in addition to the conditional `b.eq` instruction with each iteration of the loop.
    The slight increase in execution time is usually worth the code readability improvement.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我的汇编语言解决方案比编译器生成的代码（[清单 13-2](ch13.xhtml#ch13list2)）效率低，因为每次循环迭代都会执行 `b` 指令，此外还有条件
    `b.eq` 指令。虽然执行时间稍微增加，但通常值得为了代码可读性做出这种权衡。
- en: A `while` loop works well when a *sentinel value*, which is a unique value that
    marks the end of a data sequence, is used as the termination condition. For example,
    the `while` loop in [Listings 13-1](ch13.xhtml#ch13list1) and [13-3](ch13.xhtml#ch13list3)
    works for any length of text string and continues writing one character at a time
    to the screen until it reaches the sentinel value, a `NUL` character. C has another
    looping construct, the `for` loop, that many programmers find to be more natural
    for some algorithms; we’ll look at that next.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用一个 *哨兵值*（这是一个标记数据序列结束的唯一值）作为终止条件时，`while` 循环效果很好。例如，[清单 13-1](ch13.xhtml#ch13list1)
    和 [13-3](ch13.xhtml#ch13list3) 中的 `while` 循环适用于任何长度的文本字符串，并且会继续将一个字符一个字符地写入屏幕，直到遇到哨兵值，即
    `NUL` 字符。C 语言还有另一种循环结构，`for` 循环，许多程序员认为它在某些算法中更自然；我们接下来会看看它。
- en: '***for Loop***'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***for 循环***'
- en: 'Although their C syntax differs, the looping constructs `while` and `for` are
    semantically equivalent. The syntactical difference is that the for *loop* allows
    you to group all three control elements—loop control variable initialization,
    checking, and changing—within the parentheses. The general form of a `for` loop
    in C is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们的 C 语法有所不同，但 `while` 和 `for` 循环结构在语义上是等价的。语法上的区别是，`for` *循环*允许你将所有三个控制元素——循环控制变量初始化、检查和改变——都放在括号内。C
    中 `for` 循环的一般形式如下：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Placing all the control elements within the parentheses is not required. In
    fact, we could also write a `for` loop as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有控制元素放在括号内并非必须。实际上，我们也可以将 `for` 循环写成如下形式：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that the `for` loop syntax does require the inclusion of both semicolons
    in the parentheses.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`for` 循环语法确实要求在括号中包括两个分号。
- en: In [Listing 13-4](ch13.xhtml#ch13list4), I have rewritten the program from [Listing
    13-1](ch13.xhtml#ch13list1) using a `for` loop.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 13-4](ch13.xhtml#ch13list4) 中，我用 `for` 循环重写了 [清单 13-1](ch13.xhtml#ch13list1)
    中的程序。
- en: '*hello_world_for.c*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello_world_for.c*'
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 13-4: A program to write Hello, World! using a* for *loop*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-4：使用* for *循环编写 Hello, World！的程序*'
- en: '**NOTE**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Since the* for *statement in this program controls only one C statement, you
    really don’t need the curly brackets around that statement. I usually include
    them anyway, because if I later modify the program and add another statement,
    I often forget that I then need the curly brackets.*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于此程序中的* for *语句只控制一个 C 语句，实际上你不需要在该语句周围加上大括号。我通常还是会加上它们，因为如果我稍后修改程序并添加另一个语句时，我经常会忘记需要加大括号。*'
- en: You may wonder if either looping construct is better than the other. Here’s
    where your knowledge of assembly language becomes useful. When I used `gcc` to
    generate the assembly language for [Listing 13-4](ch13.xhtml#ch13list4), I got
    the same assembly language code I did for the `while` loop version in [Listing
    13-1](ch13.xhtml#ch13list1). Since the assembly language for the `for` loop is
    shown in [Listing 13-2](ch13.xhtml#ch13list2), I won’t repeat it here.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道哪种循环结构更好。这里正是你汇编语言知识派上用场的时候。当我使用`gcc`生成[清单 13-4](ch13.xhtml#ch13list4)的汇编语言时，得到的汇编语言代码与[清单
    13-1](ch13.xhtml#ch13list1)中的`while`循环版本是一样的。由于`for`循环的汇编语言已在[清单 13-2](ch13.xhtml#ch13list2)中展示，所以这里不再重复。
- en: The conclusion we can reach from this comparison of a `for` loop with a `while`
    loop is that you should use the high-level language looping construct that feels
    natural for the problem you’re solving. It’s usually a subjective choice.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从`for`循环与`while`循环的对比中，我们可以得出结论，你应该使用对于你解决的问题最自然的高级语言循环结构。通常这是一个主观的选择。
- en: 'A `for` loop is often used for a *count-controlled loop*, in which the number
    of iterations is known before the loop is started. You’ll see an example of this
    usage in a moment, when we look at the selection constructs. First, though, let’s
    look at the third looping construct in C. This provides a different behavior:
    whereas the `while` loop and `for` loop constructs will skip the body of the loop
    if the termination conditions are met by the initial value of the loop control
    variable, it will always execute the loop body at least once.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环通常用于*计数控制循环*，其中循环迭代次数在开始循环之前就已确定。稍后我们将看到此用法的示例，当我们讨论选择结构时。首先，让我们看看 C
    语言中的第三种循环结构。它提供了不同的行为：与`while`循环和`for`循环结构在终止条件被循环控制变量的初始值满足时跳过循环体的做法不同，`do-while`循环结构将始终至少执行一次循环体。'
- en: '***do-while Loop***'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***do-while 循环***'
- en: 'In some situations, your algorithm needs to execute the body of the loop at
    least once. In these cases, the do-while *loop* may be more natural. It has the
    following general form:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您的算法需要至少执行一次循环体。在这些情况下，do-while *循环*可能会更自然。它具有以下一般形式：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the `do-while` looping construct, the value of the expression is computed
    at the end of the loop body. Looping continues until this evaluation results in
    a Boolean false.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`do-while`循环结构中，表达式的值是在循环体结束时计算的。循环会持续执行，直到该评估结果为布尔值 false。
- en: In [Listing 13-5](ch13.xhtml#ch13list5), I have rewritten the Hello, World!
    program using a `do-while` loop.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 13-5](ch13.xhtml#ch13list5)中，我使用`do-while`循环重写了 Hello, World! 程序。
- en: '*hello_world_do.c*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello_world_do.c*'
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 13-5: A program to write Hello, World! using a* do-while *loop*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-5：使用* do-while *循环编写 Hello, World! 程序*'
- en: '**NOTE**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This program has a potential bug! The* do-while *loop construct will always
    execute the body of the loop at least once. Consider an empty text string, which
    is a single byte containing the* NUL *character. A* do-while *loop writes the*
    NUL *character to the screen (which does nothing) and then checks the next byte
    in memory, which could be anything. If this byte is not a* NUL *character, the*
    do-while *loop will continue to execute, writing whatever characters this and
    the following bytes represent, until it reaches a* NUL *character. The behavior
    of the program could be different each time it’s run, so the error may not show
    up in your testing.*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个程序有潜在的bug！* do-while *循环结构将始终至少执行一次循环体。考虑一个空的文本字符串，它是一个包含* NUL *字符的单字节。一个*
    do-while *循环会将* NUL *字符写到屏幕上（实际上没有做任何事情），然后检查内存中的下一个字节，这个字节可能是任何内容。如果这个字节不是* NUL
    *字符，* do-while *循环会继续执行，写入该字节及下一个字节所表示的字符，直到遇到* NUL *字符。程序的行为可能每次运行时都不同，因此错误可能不会在你的测试中显现出来。*'
- en: We can use the assembly language generated by `gcc`, which is shown in [Listing
    13-6](ch13.xhtml#ch13list6), to illustrate the difference between the `do-while`
    construct and the `while` and `for` constructs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`gcc`生成的汇编语言（见[清单 13-6](ch13.xhtml#ch13list6)），来说明`do-while`结构与`while`和`for`结构之间的差异。
- en: '*hello_world_do.s*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello_world_do.s*'
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 13-6: The compiler-generated assembly language for the function in
    [Listing 13-5](ch13.xhtml#ch13list5)*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-6：编译器生成的[清单 13-5](ch13.xhtml#ch13list5)函数的汇编语言*'
- en: If you compare the assembly language shown in [Listing 13-6](ch13.xhtml#ch13list6)
    with that in [Listing 13-2](ch13.xhtml#ch13list2), which shows the assembly language
    generated for both the `while` and `for` loops, you’ll see that the only difference
    is that the `do-while` loop doesn’t branch down to perform the loop control check
    ❷ before executing the loop for the first time ❶. The `do-while` construct might
    seem more efficient, but in the assembly language, the only saving is a single
    branch the first time the loop is executed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 [列表 13-6](ch13.xhtml#ch13list6) 中显示的汇编语言与 [列表 13-2](ch13.xhtml#ch13list2)
    中显示的汇编语言进行比较，后者显示了为 `while` 和 `for` 循环生成的汇编语言，你会发现唯一的区别是 `do-while` 循环在第一次执行循环之前不会跳转到循环控制检查
    ❷。`do-while` 结构看起来可能更高效，但在汇编语言中，唯一的优化是第一次执行循环时少了一个跳转。
- en: Next, we’ll look at how to select whether to execute a block of code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将研究如何选择是否执行一段代码。
- en: '**YOUR TURN**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在轮到你了**'
- en: 13.1     Enter the three C programs in [Listings 13-1](ch13.xhtml#ch13list1),
    [13-4](ch13.xhtml#ch13list4), and [13-5](ch13.xhtml#ch13list5), and use the compiler
    to generate the assembly language for each of them. Compare the assembly language
    for the three looping constructs. Compilers change with version changes, so you
    should look at what your version of the compiler does.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 13.1     输入 [列表 13-1](ch13.xhtml#ch13list1)、[13-4](ch13.xhtml#ch13list4) 和 [13-5](ch13.xhtml#ch13list5)
    中的三个 C 程序，并使用编译器为每个程序生成汇编语言。比较三种循环结构的汇编语言。编译器随着版本变化而变化，因此你应该查看你所使用的编译器的输出。
- en: '13.2     Write a program in assembly language that:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 13.2     编写一个汇编语言程序，要求：
- en: (a)     Prompts the user to enter some text
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: (a)     提示用户输入一些文本
- en: (b)     Uses the `read` system call function to read the entered text
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: (b)     使用 `read` 系统调用函数读取输入的文本
- en: (c)     Echoes the user’s entered text in the terminal window
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: (c)     在终端窗口回显用户输入的文本
- en: You will need to allocate space on the stack for storing the characters entered
    by the user.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在栈上分配空间，用于存储用户输入的字符。
- en: '**Conditionals**'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**条件语句**'
- en: Another common flow construct is selection, where we determine whether to execute
    a block of code. I’ll start with the simplest case, determining whether to execute
    a single block based on a Boolean conditional statement, then I’ll show you how
    to use a Boolean conditional statement to select one of two blocks. I’ll end the
    chapter by discussing ways to select between several blocks based on an integral
    value.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的流程控制结构是选择结构，在这里我们决定是否执行某段代码。我将从最简单的情况开始，基于布尔条件语句判断是否执行单个代码块，然后展示如何使用布尔条件语句选择执行两个代码块中的一个。最后，我将讨论如何根据整数值选择多个代码块。
- en: '***if***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***如果***'
- en: 'The general form of an if *conditional* in C is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言中 if *条件语句*的一般形式如下：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The expression is evaluated as a Boolean. If it evaluates to false, or `0` in
    C, control flow continues to next statement. If expression evaluates to true (a
    nonzero value in C), the statements in block are executed, and control flow continues
    to next statement.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 该表达式被计算为布尔值。如果它计算为假，或者在 C 语言中为 `0`，控制流将继续执行下一条语句。如果表达式计算为真（在 C 语言中为非零值），则执行代码块中的语句，控制流将继续到下一条语句。
- en: '[Listing 13-7](ch13.xhtml#ch13list7) gives an example of an `if` statement
    that simulates flipping a coin 10 times and showing when it comes up heads.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13-7](ch13.xhtml#ch13list7) 提供了一个 `if` 语句的示例，模拟抛硬币 10 次并显示每次正面朝上的情况。'
- en: '*coin_flips1.c*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*coin_flips1.c*'
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 13-7: A program to flip a coin and show when it comes up heads*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-7：一个模拟抛硬币并显示正面朝上的程序*'
- en: This program uses a count-controlled `for` loop to simulate flipping a coin
    10 times ❶. The simulation involves calling the `random` function in the C standard
    library ❷. If the random number is in the lower half of all possible values from
    the `random` function ❸, we call that “heads.” To display this result we use the
    `puts` function in the C standard library, which prints a simple text string to
    the screen with an appended newline character ❹. For [Listing 13-7](ch13.xhtml#ch13list7),
    the compiler generated the assembly language shown in [Listing 13-8](ch13.xhtml#ch13list8).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序使用计数控制的 `for` 循环模拟抛硬币 10 次 ❶。模拟过程调用了 C 标准库中的 `random` 函数 ❷。如果随机数在 `random`
    函数所有可能值的下半部分 ❸，我们称之为“正面”。为了显示这个结果，我们使用 C 标准库中的 `puts` 函数，它将一个简单的文本字符串打印到屏幕上，并附加一个换行符
    ❹。对于 [列表 13-7](ch13.xhtml#ch13list7)，编译器生成了 [列表 13-8](ch13.xhtml#ch13list8) 中显示的汇编语言。
- en: '*coin_flips1.s*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*coin_flips1.s*'
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 13-8: The compiler-generated assembly language for the function in
    [Listing 13-7](ch13.xhtml#ch13list7)*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-8：编译器为 [清单 13-7](ch13.xhtml#ch13list7) 中的函数生成的汇编语言*'
- en: The `if` statement is implemented with a simple conditional branch. If the condition—in
    this case, `bgt`, for branch if greater than ❶—is true, the program flow branches
    over the block of code that is controlled by the `if` statement ❷. Next, I’ll
    show you how to select between two different blocks of code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句通过一个简单的条件分支来实现。如果条件成立—在这种情况下，`bgt`，即大于时跳转 ❶—程序流将跳过由 `if` 语句控制的代码块 ❷。接下来，我将向你展示如何在两个不同的代码块之间进行选择。'
- en: '***if-then-else***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***if-then-else***'
- en: 'The general form of an if-then-else *conditional* in C is as follows (C does
    not use a `then` keyword):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: C 中的 if-then-else *条件语句* 的一般形式如下（C 不使用 `then` 关键字）：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The expression is evaluated as a Boolean. If expression evaluates to true, the
    statements in then block are executed and control flow branches to next statement.
    If it evaluates to false (`0` in C), control flow branches to else block and then
    continues to next statement.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式作为布尔值进行评估。如果表达式的结果为真，则执行 `then` 块中的语句，并且控制流跳转到下一个语句。如果结果为假（在 C 中为 `0`），则控制流跳转到
    `else` 块，并继续执行下一个语句。
- en: '[Figure 13-2](ch13.xhtml#ch13fig2) shows the control flow of the `if-then-else`
    conditional.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-2](ch13.xhtml#ch13fig2) 显示了 `if-then-else` 条件语句的控制流。'
- en: '![image](../images/pg286_Image_275.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg286_Image_275.jpg)'
- en: '*Figure 13-2: The control flow of an* if-then-else *conditional*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-2：一个* if-then-else *条件语句的控制流*'
- en: The coin-flipping program in [Listing 13-7](ch13.xhtml#ch13list7) isn’t user-friendly
    because the user doesn’t know the total number of times the coin was flipped.
    We can improve the program by using an `if-then-else` conditional to print a message
    stating when the coin came up tails, as shown in [Listing 13-9](ch13.xhtml#ch13list9).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-7](ch13.xhtml#ch13list7) 中的抛硬币程序不够用户友好，因为用户不知道硬币被抛了多少次。我们可以通过使用 `if-then-else`
    条件语句来改进程序，打印出硬币为反面时的消息，如 [清单 13-9](ch13.xhtml#ch13list9) 所示。'
- en: '*coin_flips2.c*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*coin_flips2.c*'
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 13-9: A program to flip a coin and declare it heads or tails*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-9：一个抛硬币并声明其为正面或反面的程序*'
- en: '[Listing 13-10](ch13.xhtml#ch13list10) shows the assembly language the compiler
    generates for [Listing 13-9](ch13.xhtml#ch13list9).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-10](ch13.xhtml#ch13list10) 显示了编译器为 [清单 13-9](ch13.xhtml#ch13list9) 生成的汇编语言。'
- en: '*coin_flips2.s*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*coin_flips2.s*'
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 13-10: The compiler-generated assembly language for the function in
    [Listing 13-9](ch13.xhtml#ch13list9)*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-10：编译器为 [清单 13-9](ch13.xhtml#ch13list9) 中的函数生成的汇编语言*'
- en: The assembly language shows that we need an unconditional branch at the end
    of the `then` block ❶ to branch over the `else` block ❷.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言显示，我们需要在 `then` 块的末尾 ❶ 进行一次无条件跳转，以跳过 `else` 块 ❷。
- en: My assembly language design of the coin-flipping program differs slightly, as
    shown in [Listing 13-11](ch13.xhtml#ch13list11).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我的抛硬币程序的汇编语言设计略有不同，如 [清单 13-11](ch13.xhtml#ch13list11) 所示。
- en: '*coin_flips2.s*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*coin_flips2.s*'
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 13-11: An assembly language design for the coin-flipping program*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-11：抛硬币程序的汇编语言设计*'
- en: The `random` function returns a random number in the `w0` register. I leave
    it there for comparison with the halfway point, which I’ve loaded into the `w1`
    register ❶. The `w0` and `w1` registers don’t need to be saved in a function.
    The compiler used `w20` for the `random_number` variable, which does need to be
    saved.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`random` 函数返回一个随机数，并存储在 `w0` 寄存器中。我将其保留在那里，与我已经加载到 `w1` 寄存器中的中间值进行比较 ❶。`w0`
    和 `w1` 寄存器不需要在函数中保存。编译器使用 `w20` 作为 `random_number` 变量，它需要被保存。'
- en: When deciding which registers to use for variables in a function, it’s important
    that you check the rules in [Table 11-3](ch11.xhtml#ch11tab3) in [Chapter 11](ch11.xhtml).
    That table says that a function must preserve the value in `x19` for the calling
    function. You can probably see the importance of having agreed-upon rules here.
    Not only must our function return to the calling function with its value in `x19`
    preserved, but we can assume that the functions that our function calls also preserve
    our value in `x19`. So, it’s safe to assume that the value remains the same through
    a function call.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定为函数中的变量选择哪些寄存器时，检查 [第 11 章](ch11.xhtml) 中的 [表 11-3](ch11.xhtml#ch11tab3)
    规则非常重要。该表指出，函数必须保持 `x19` 中的值，以便调用函数使用。你可能会看到在这里遵守规则的重要性。我们的函数不仅必须在返回时保持 `x19`
    的值，而且我们可以假设我们调用的函数也会保持我们在 `x19` 中的值。因此，可以放心地假设，在函数调用期间该值保持不变。
- en: 'I won’t go into the details here, but if you need to select one of several
    blocks of code to execute, you can use the `else-if` statement in a *ladder construct*.
    The general form is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我这里不深入讲解细节，但如果你需要从多个代码块中选择一个执行，你可以在*梯形结构*中使用`else-if`语句。其一般形式如下：
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `if-then-else` selection is based on a Boolean evaluation of the controlling
    expression, but as you’ll see in the next section, there are algorithms in which
    the selection is based on a discrete value, which is used to select one of several
    cases.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-then-else`选择是基于控制表达式的布尔值评估，但正如你将在下一节看到的那样，有些算法中的选择是基于离散值的，这些值用于选择多个情况中的一个。'
- en: '***switch***'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***switch***'
- en: 'C provides a switch *conditional*, where control flow branches to a place in
    a list of code blocks depending on the value of a selector. The general form of
    the `switch` is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: C语言提供了一个`switch` *条件语句*，根据选择器的值，控制流会跳转到代码块列表中的某个位置。`switch`的一般形式如下：
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The selector can be any expression that evaluates to an integer. Each selector_1,
    selector_2, . . . , selector_n must be an integer constant. The `switch` will
    branch to the `case` whose selector_1, selector_2, . . . , selector_n is equal
    to the selector evaluation. If selector does not evaluate to any of the selector_1,
    selector_2, . . . , selector_n integers, the `switch` branches to `default`. After
    executing the corresponding block_1, block_2, . . . , block_n, program flow continues
    through the remaining blocks of code. A `break` statement at any place in the
    `switch` will exit the `switch` at that point and branch down to next statement.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器可以是任何计算结果为整数的表达式。每个selector_1、selector_2、...、selector_n必须是整数常量。`switch`将跳转到`case`，其selector_1、selector_2、...、selector_n等于选择器的评估结果。如果选择器的值没有匹配任何selector_1、selector_2、...、selector_n整数，`switch`将跳转到`default`。在执行完对应的block_1、block_2、...、block_n之后，程序流会继续执行剩余的代码块。`switch`中的任何地方遇到`break`语句都会立即退出`switch`并跳转到下一个语句。
- en: '[Listing 13-12](ch13.xhtml#ch13list12) shows how to use a `switch` statement
    in C.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13-12](ch13.xhtml#ch13list12)展示了如何在C语言中使用`switch`语句。'
- en: '*switch.c*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*switch.c*'
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 13-12: A* switch *statement*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-12：A* `switch` *语句*'
- en: I want this program to execute only the case corresponding to the value of `i`.
    To prevent it from executing the following cases in the `switch`, I end each block
    with a `break` statement, which causes an exit from the `switch` ❶.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这个程序只执行与`i`值对应的情况。为了防止它执行`switch`中的后续情况，我在每个代码块的末尾加上了`break`语句，这会导致程序从`switch`中退出
    ❶。
- en: '[Listing 13-13](ch13.xhtml#ch13list13) shows how the compiler implemented this
    `switch`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13-13](ch13.xhtml#ch13list13)展示了编译器如何实现这个`switch`。'
- en: '*switch.s*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*switch.s*'
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 13-13: Compiler-generated assembly language for the function in [Listing
    13-12](ch13.xhtml#ch13list12)*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-13：编译器生成的汇编语言，针对[列表 13-12](ch13.xhtml#ch13list12)中的函数*'
- en: In [Listing 13-13](ch13.xhtml#ch13list13), the compiler creates two parts for
    the `switch`. The first part is the logic to decide which block of code to execute
    ❶. Depending on the value of the selector, this will transfer program flow to
    the correct block in the second part ❷.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 13-13](ch13.xhtml#ch13list13)中，编译器为`switch`创建了两个部分。第一部分是决定执行哪个代码块的逻辑 ❶。根据选择器的值，这将把程序流转移到第二部分中的正确代码块
    ❷。
- en: 'Now, let’s look at another way to implement a `switch`: a *branch table*, also
    called a *jump table*. A branch table is a table of the block addresses that we
    need to select from. We need to design an algorithm that will select the correct
    address in the table, based on the value of the selector, and then branch to that
    address.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下实现`switch`的另一种方式：*分支表*，也叫做*跳转表*。分支表是我们需要选择的代码块地址的表格。我们需要设计一个算法，根据选择器的值来选择表中的正确地址，然后跳转到该地址。
- en: '[Listing 13-14](ch13.xhtml#ch13list14) shows one way to do this for our current
    example.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13-14](ch13.xhtml#ch13list14)展示了为当前示例实现这一点的一种方式。'
- en: '*switch.s*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*switch.s*'
- en: '[PRE24]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 13-14: An assembly language design for using a branch table*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-14：用于使用分支表的汇编语言设计*'
- en: Each entry in the branch table is the address of the code block to execute for
    the corresponding value of the selector variable. The `.quad` assembler directive
    tells the assembler to allocate 8 bytes of memory and initialize it to the value
    of the operand ❷. We’re using it to store the address of each of the code blocks
    our algorithm will select from. Since the items in our branch table are 64-bit
    addresses, we need to align the beginning of the table at a 64-bit address boundary
    ❶.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 分支表中的每一项是对应选择器变量值的代码块地址。`.quad` 汇编指令告诉汇编器分配 8 字节的内存，并将其初始化为操作数的值 ❷。我们使用它来存储算法将要选择的每个代码块的地址。由于分支表中的项是
    64 位地址，我们需要将表的开始对齐到 64 位地址边界 ❶。
- en: Our algorithm uses `x19` and `x20` as local variables, and the procedure call
    standard states that we need to save their contents for the calling function (see
    [Table 11-3](ch11.xhtml#ch11tab3) in [Chapter 11](ch11.xhtml)) ❸. We can also
    assume that their contents will be preserved by the functions we call from this
    function.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的算法使用 `x19` 和 `x20` 作为局部变量，过程调用标准规定我们需要保存它们的内容，以供调用的函数使用（请参见 [表 11-3](ch11.xhtml#ch11tab3)
    和 [第 11 章](ch11.xhtml)） ❸。我们还可以假设我们从此函数调用的其他函数会保留它们的内容。
- en: We need to determine which block address to load from the branch table. We start
    with the address of the beginning of the table ❹. Then, we compare the current
    value of `i`, in `x19`, with the number of the default case. If the value of `i`
    is lower than the default case, we’ll use the `csel` instruction to move that
    value into `x1`. If it’s the same or higher, the `csel` instruction moves the
    number of the default case in `x20` to `x1` ❹. Now that we have the case number
    in `x1`, we need to subtract 1 to get the offset in the table from the first item
    in the table ❻.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确定从分支表中加载哪个块的地址。我们从表开头的地址开始 ❹。然后，我们将 `x19` 中的当前 `i` 值与默认案例的编号进行比较。如果 `i`
    的值小于默认案例编号，我们将使用 `csel` 指令将该值移入 `x1`。如果 `i` 的值与默认案例编号相同或更高，则 `csel` 指令将默认案例编号（存储在
    `x20` 中）移入 `x1` ❹。现在我们在 `x1` 中有了案例编号，我们需要减去 1，以获得表中从第一个项开始的偏移量 ❻。
- en: Next, we need to convert the case offset to an address offset so we can add
    it to the address of the beginning of the branch table. Each item in the branch
    table is 8 bytes wide. We use an option of the `add` instruction to shift the
    value of our offset, in `x1`, 3 bits to the left ❼. This multiplies the offset
    by 8 before adding it to the beginning address of the branch table, in `x0`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将案例偏移量转换为地址偏移量，以便将其加到分支表开头的地址上。分支表中的每个项占用 8 字节。我们使用 `add` 指令的一个选项，将偏移量的值（在
    `x1` 中）向左移动 3 位 ❼。这样就能在将偏移量加到分支表的起始地址（在 `x0` 中）之前，将偏移量乘以 8。
- en: Now, `x0` contains the address in the branch table of the item we want. We replace
    the address of the item with the item itself, which is the address of the block
    to execute ❽.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`x0` 包含我们想要的项目在分支表中的地址。我们用项目本身的地址替换该项的地址，而该地址是要执行的代码块的地址 ❽。
- en: 'The `csel` instruction can be useful for a simple `if-then-else` construct
    when you’re selecting between two values in registers. It takes this form:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`csel` 指令对于在寄存器中选择两个值时实现简单的 `if-then-else` 构造非常有用。它的形式如下：'
- en: csel**—Conditional select**
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: csel**—条件选择**
- en: '`csel` reg1, reg2, reg3, cond tests the settings in the `nzcv` register and
    moves reg2 to reg1 if cond is true or moves reg3 to reg1 if cond is false.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`csel` reg1, reg2, reg3, cond 会测试 `nzcv` 寄存器中的设置，如果 cond 为真，则将 reg2 移动到 reg1；如果
    cond 为假，则将 reg3 移动到 reg1。'
- en: You now know two ways to implement a `switch` construct. It’s difficult to say
    whether a branch table is more efficient than an `if-else` ladder. For a large
    number of cases, an `if-else` ladder may require many tests before reaching the
    correct case to select. The efficiency also depends on things such as cache usage
    and the internal CPU design, and it can vary between CPU implementations that
    use the same instruction set. Any differences between the two techniques will
    probably be insignificant, so you should choose the one that seems to better match
    the problem you’re solving.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了实现 `switch` 构造的两种方法。很难说分支表是否比 `if-else` 结构更高效。对于大量的案例，`if-else` 结构可能需要进行多次测试，才能选择到正确的案例。效率还取决于缓存使用、内部
    CPU 设计等因素，而且不同的 CPU 实现（即使使用相同的指令集）之间也可能存在差异。两种方法之间的差异可能并不显著，因此你应该选择与所解决问题更匹配的那种方法。
- en: '**YOUR TURN**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮到你了**'
- en: 13.3     Change the assembly language program in [Listing 13-11](ch13.xhtml#ch13list11)
    so that it sees the lowest one-fourth and the highest one-fourth of the random
    numbers (`0` to `RAND_MAX/4` and `3*RAND_MAX/4` to `RAND_MAX`) as heads. It will
    see the middle half of the random numbers (`RAND_MAX/4` to `3*RAND_MAX/4`) as
    tails.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 13.3     修改[清单13-11](ch13.xhtml#ch13list11)中的汇编语言程序，使其将随机数的最低四分之一和最高四分之一（`0`
    到 `RAND_MAX/4` 和 `3*RAND_MAX/4` 到 `RAND_MAX`）视为正面。它将视随机数的中间一半（`RAND_MAX/4` 到 `3*RAND_MAX/4`）为反面。
- en: 13.4     Remove the `break` statements in the program in [Listing 13-12](ch13.xhtml#ch13list12).
    How does this change the behavior of the program? Generate the assembly language
    from your changed program and compare it to that in [Listing 13-13](ch13.xhtml#ch13list13).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 13.4     移除[清单13-12](ch13.xhtml#ch13list12)中的`break`语句。这将如何改变程序的行为？生成更改后的程序的汇编语言，并与[清单13-13](ch13.xhtml#ch13list13)中的程序进行比较。
- en: 13.5     Change the program in [Listing 13-14](ch13.xhtml#ch13list14) so that
    it uses `if` conditionals instead of the `csel` instruction.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 13.5     修改[清单13-14](ch13.xhtml#ch13list14)中的程序，使其使用`if`条件语句，而不是`csel`指令。
- en: 13.6     Rewrite the program in [Listing 13-14](ch13.xhtml#ch13list14) so that
    it uses a ladder of `if-else` conditionals instead of a `switch`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 13.6     重写[清单13-14](ch13.xhtml#ch13list14)中的程序，使其使用`if-else`条件语句的梯形结构，而不是使用`switch`。
- en: '**What You’ve Learned**'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: '**Unconditional branch** Changes the program counter to alter the control flow.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**无条件分支** 更改程序计数器以改变控制流。'
- en: '**Conditional branch** Evaluates Boolean combinations of the status flags in
    the `nzcv` register and alters control flow if the combination evaluates to true.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**条件分支** 评估`nzcv`寄存器中的状态标志的布尔组合，如果组合结果为真，则改变控制流。'
- en: while **loop** Checks for a Boolean condition and then iterates a block of code
    until the condition becomes false.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: while **循环** 检查布尔条件，然后在条件为真时迭代执行代码块，直到条件变为假。
- en: for **loop** Checks for a Boolean condition and then iterates a block of code
    until the condition becomes false.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: for **循环** 检查布尔条件，然后在条件为真时迭代执行代码块，直到条件变为假。
- en: do-while **loop** Executes a block of code once and iterates it until a Boolean
    condition becomes false.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: do-while **循环** 执行一次代码块，并在布尔条件为真时重复执行，直到条件变为假。
- en: if **conditional** Checks for a Boolean condition and then executes a block
    of code if the condition is true.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: if **条件语句** 检查布尔条件，如果条件为真，则执行一段代码块。
- en: if-then-else **conditional** Checks for a Boolean condition and then executes
    one of two blocks of code, depending on whether the condition is true or false.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: if-then-else **条件语句** 检查布尔条件，然后根据条件为真或为假的情况执行两个代码块中的一个。
- en: switch **conditional** Evaluates an expression and then branches to a location
    in a list of blocks of code, depending on the integer value of the expression.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: switch **条件语句** 评估一个表达式，然后根据表达式的整数值跳转到代码块列表中的某个位置。
- en: Now that you know about control flow constructs and the `main` function, we’ll
    move on to discuss how to write your own subfunctions. In the next chapter, you’ll
    learn how to pass arguments and how to access those arguments in the subfunction.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了控制流结构和`main`函数，接下来我们将讨论如何编写自己的子函数。在下一章中，你将学习如何传递参数以及如何在子函数中访问这些参数。
