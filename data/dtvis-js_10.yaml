- en: 'Chapter 10. Building Data-Driven Web Applications: Part 2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 10 章：构建数据驱动的 Web 应用程序：第 2 部分
- en: 'In [Chapter 9](ch09.html "Chapter 9. Building Data-Driven Web Applications:
    Part 1"), we set up the framework of our web application and walked through the
    visualizations that will be displayed for each view. But before our web application
    is complete, we have several other details to attend to. First, we have to make
    the web application communicate with the Nike+ service and account for some quirks
    specific to that service. Then we’ll work on making our application easier to
    navigate. In this chapter we’ll look at the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 9 章](ch09.html "第 9 章：构建数据驱动的 Web 应用程序：第 1 部分")中，我们搭建了 web 应用程序的框架，并展示了每个视图将要显示的可视化内容。但是在我们的
    web 应用程序完成之前，我们还有一些其他的细节需要处理。首先，我们必须使 web 应用程序与 Nike+ 服务进行通信，并处理该服务特有的一些问题。接下来，我们将着手让我们的应用程序更加易于导航。在本章中，我们将讨论以下内容：
- en: How to connect application models with an external REST API
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将应用程序模型与外部 REST API 连接
- en: How to support web browser conventions in a single-page application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在单页应用程序中支持 Web 浏览器约定
- en: Connecting with the Nike+ Service
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到 Nike+ 服务
- en: Although our example application relies on the Nike+ service for its data, we
    haven’t looked at the details of that service’s interface. As I’ve mentioned,
    Nike+ doesn’t quite conform to common REST API conventions that application libraries
    such as Backbone.js expect. But Nike+ isn’t very unusual in that regard. There
    really isn’t a true *standard* for REST APIs, and many other services take approaches
    similar to Nike+’s. Fortunately Backbone.js anticipates this variation. As we’ll
    see in the following steps, extending Backbone.js to support REST API variations
    isn’t all that difficult.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的示例应用程序依赖于 Nike+ 服务来获取数据，但我们并没有查看该服务接口的具体细节。正如我提到的，Nike+ 并没有完全遵循像 Backbone.js
    这样的应用库所期望的常见 REST API 约定。但是在这方面，Nike+ 并不算非常特殊。实际上，REST API 并没有一个真正的 *标准*，许多其他服务也采取了类似于
    Nike+ 的方法。幸运的是，Backbone.js 已经预见到了这种变化。正如我们将在接下来的步骤中看到的，扩展 Backbone.js 以支持 REST
    API 的变化并不像想象中那样困难。
- en: 'Step 1: Authorize Users'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 1：授权用户
- en: As you might expect, Nike+ doesn’t allow anyone on the Internet to retrieve
    details for any user’s runs. Users expect at least some level of privacy for that
    information. Before our app can retrieve any running information, therefore, it
    will need the user’s permission. We won’t go into the details of that process
    here, but its result will be an `authorization_token`. This object is an arbitrary
    string that our app will have to include with every Nike+ request. If the token
    is missing or invalid, Nike+ will deny our app access to the data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能预料到的，Nike+ 并不允许互联网的任何人获取任何用户的跑步详情。用户期望至少对这些信息保持一定的隐私。因此，在我们的应用程序能够获取任何跑步信息之前，它需要用户的许可。我们在这里不详细讨论这个过程，但其结果将是一个
    `authorization_token`。这个对象是一个任意字符串，我们的应用程序必须将其包含在每个 Nike+ 请求中。如果令牌缺失或无效，Nike+
    将拒绝我们的应用程序访问数据。
- en: Up until now we’ve let Backbone.js handle all of the details of the REST API.
    Next, we’ll have to modify how Backbone.js constructs its AJAX calls. Fortunately,
    this isn’t as tricky as it sounds. All we need to do is add a `sync()` method
    to our Runs collection. When a `sync()` method is present in a collection, Backbone.js
    calls it whenever it makes an AJAX request. (If there is no such method for a
    collection, Backbone.js calls its primary `Backbone.sync()` method.) We’ll define
    the new method directly in the collection.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直让 Backbone.js 处理 REST API 的所有细节。接下来，我们需要修改 Backbone.js 构造 AJAX 请求的方式。幸运的是，这并不像听起来那么复杂。我们只需要在我们的
    Runs 集合中添加一个 `sync()` 方法。当集合中存在 `sync()` 方法时，每当 Backbone.js 发起 AJAX 请求时，都会调用它。（如果集合中没有这个方法，Backbone.js
    会调用其主要的 `Backbone.sync()` 方法。）我们将在集合中直接定义这个新方法。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, `sync()` is passed a `method` (`GET`, `POST`, etc.), the collection
    in question, and an object containing options for the request. To send the authorization
    token to Nike+, we can add it as a parameter using this `options` object.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`sync()` 被传递了一个 `method`（如 `GET`、`POST` 等）、相关的集合以及一个包含请求选项的对象。为了将授权令牌发送到
    Nike+，我们可以通过这个 `options` 对象将其作为参数添加进去。
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first line in the method makes sure that the `options` parameter exists.
    If the caller doesn’t provide a value, we set it to an empty object (`{}`). The
    next statement adds a `data` property to the `options` object using the `extend()`
    utility from Underscore.js. The `data` property is itself an object, and in it
    we store the authorization token. We’ll look at how to do that next, but first
    let’s finish up the `sync()` method. Once we’ve added the token, our request is
    a standard AJAX request, so we can let Backbone.js take it from there by calling
    `Backbone.sync()`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 方法中的第一行确保 `options` 参数存在。如果调用者没有提供值，我们将其设置为空对象（`{}`）。接下来的语句使用来自 Underscore.js
    的 `extend()` 工具方法，向 `options` 对象添加一个 `data` 属性。`data` 属性本身是一个对象，我们在其中存储授权令牌。接下来我们将看看如何做到这一点，但首先让我们完成
    `sync()` 方法。一旦添加了令牌，我们的请求就是一个标准的 AJAX 请求，所以我们可以让 Backbone.js 通过调用 `Backbone.sync()`
    来继续处理。
- en: 'Now we can turn our attention to the `settings` object from which our `sync()`
    method obtained the authorization token. We’re using that object to hold properties
    related to the collection as a whole. It’s the collection’s equivalent of a model’s
    attributes. Backbone.js doesn’t create this object for us automatically, but it’s
    easy enough to do it ourselves. We’ll do it in the collection’s `initialize()`
    method. That method accepts two parameters: an array of models for the collection,
    and any collection options.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将注意力转向从 `sync()` 方法中获取授权令牌的 `settings` 对象。我们使用这个对象来保存与集合相关的属性，类似于模型的属性。Backbone.js
    不会自动为我们创建这个对象，但我们可以轻松地自己创建。我们将在集合的 `initialize()` 方法中创建它。该方法接受两个参数：一个是集合的模型数组，另一个是任何集合选项。
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first statement in the `initialize()` method defines a `settings` object
    for the collection and establishes default values for that object. Since there
    isn’t an appropriate default value for the authorization token, we’ll use an empty
    string.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`initialize()` 方法中的第一条语句定义了一个 `settings` 对象用于集合，并为该对象设置了默认值。由于没有合适的默认值用于授权令牌，我们将使用一个空字符串。'
- en: The next statement makes sure that the `options` object exists. If none is passed
    as a parameter, we’ll at least have an empty object.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的语句确保 `options` 对象存在。如果没有作为参数传递，我们至少会有一个空对象。
- en: 'The final statement extracts all the keys in the settings, finds any values
    in the `options` object with the same keys, and updates the `settings` object
    by extending it with those new key values. Once again, we take advantage of some
    Underscore.js utilities: `extend()` and `pick()`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条语句提取 `settings` 中的所有键，查找 `options` 对象中具有相同键的任何值，并通过使用新的键值扩展 `settings` 对象。再次利用了
    Underscore.js 的一些工具：`extend()` 和 `pick()`。
- en: When we first create the Runs collection, we can pass the authorization token
    as a parameter. We supply an empty array as the first parameter because we don’t
    have any models for the collection. Those will come from Nike+. In the following
    code fragment, we’re using a dummy value for the authorization token. A real application
    would use code that Nike provides to get the true value.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次创建 Runs 集合时，可以将授权令牌作为参数传入。我们将一个空数组作为第一个参数，因为目前我们没有任何模型用于集合。这些模型将来自 Nike+。在以下的代码片段中，我们使用一个虚拟值作为授权令牌。真实的应用程序会使用
    Nike 提供的代码来获取真实的值。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With just a small bit of extra code, we’ve added the authorization token to
    our AJAX requests to Nike+.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 只需少量额外的代码，我们就将授权令牌添加到了向 Nike+ 发送的 AJAX 请求中。
- en: 'Step 2: Accept the Nike+ Response'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2 步：接受 Nike+ 响应
- en: When our collection queries Nike+ for a list of user activities, Backbone.js
    is prepared for a response in a particular format. More specifically, Backbone.js
    expects the response to be a simple array of models.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的集合查询 Nike+ 获取用户活动列表时，Backbone.js 已准备好接收特定格式的响应。更具体地说，Backbone.js 期望响应是一个简单的模型数组。
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In fact, however, Nike+ returns its response as an object. The array of activities
    is one property of the object.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实际上，Nike+ 将其响应返回为一个对象。活动数组是该对象的一个属性。
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To help Backbone.js cope with this response, we add a `parse()` method to our
    collection. The job of that function is to take the response that the server provides
    and return the response that Backbone.js expects.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助 Backbone.js 处理这个响应，我们在集合中添加了一个 `parse()` 方法。这个方法的工作是接收服务器提供的响应，并返回 Backbone.js
    所期望的响应格式。
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In our case, we just return the `data` property of the response.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们只是返回响应中的 `data` 属性。
- en: 'Step 3: Page the Collection'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3 步：分页集合
- en: The next aspect of the Nike+ API we’ll tackle is its paging. When we request
    the activities for a user, the service doesn’t normally return *all* of them.
    Users may have thousands of activities stored in Nike+, and returning all of them
    at once might overwhelm the app. It could certainly add a noticeable delay, as
    the app would have to wait for the entire response before it could process it.
    To avoid this problem, Nike+ divides user activities into pages, and it responds
    with one page of activities at a time. We’ll have to adjust our app for that behavior,
    but we’ll gain the benefit of a more responsive user experience.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要处理的 Nike+ API 的一个方面是分页。当我们请求某个用户的活动时，服务通常不会返回*所有*的活动。用户可能在 Nike+ 中存储了成千上万的活动，一次性返回所有活动可能会使应用程序不堪重负。这样做肯定会带来明显的延迟，因为应用程序必须等待整个响应返回才能进行处理。为了避免这个问题，Nike+
    将用户活动分为多个页面，并一次返回一页活动。我们需要调整应用程序以适应这种行为，但我们将获得更加流畅的用户体验。
- en: The first adjustment we’ll make is in our request. We can add parameters to
    that request to indicate how many activities we’re prepared to accept in the response.
    The two parameters are `offset` and `count`. The `offset` tells Nike+ which activity
    we want to be first in the response, while `count` indicates how many activities
    Nike+ should return. If we wanted the first 20 activities, for example, we can
    set `offset` to `1` and `count` to `20`. Then, to get the next 20 activities,
    we’d set `offset` to `21` (and keep `count` at `20`).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要进行的第一个调整是在请求中。我们可以向请求中添加参数，表示我们准备接受多少个活动响应。这两个参数是 `offset` 和 `count`。`offset`
    告诉 Nike+ 在响应中返回哪个活动作为第一个，而 `count` 则表示 Nike+ 应该返回多少个活动。例如，如果我们想要获取前 20 个活动，可以将
    `offset` 设置为 `1`，将 `count` 设置为 `20`。然后，要获取接下来的 20 个活动，我们将 `offset` 设置为 `21`（并保持
    `count` 为 `20`）。
- en: We add these parameters to our request the same way we added the authorization
    token—in the `sync()` method.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像添加授权令牌一样，向请求中添加这些参数——在 `sync()` 方法中。
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will also have to provide default values for those settings during initialization.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在初始化期间为这些设置提供默认值。
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Those values will get the first 25 activities, but that’s only a start. Our
    users will probably want to see all of their runs, not just the first 25\. To
    get the additional activities, we’ll have to make more requests to the server.
    Once we get the first 25 activities, we can request the next 25\. And once those
    arrive, we can ask for 25 more. We’ll keep at this until either we reach some
    reasonable limit or the server runs out of activities.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值将返回前 25 个活动，但这只是一个开始。我们的用户可能希望查看所有的跑步记录，而不仅仅是前 25 个活动。为了获取更多的活动，我们需要向服务器发出更多的请求。一旦我们获得了前
    25 个活动，就可以请求接下来的 25 个活动。当这些活动返回后，我们可以再请求 25 个。我们将继续这样做，直到达到某个合理的限制，或者服务器没有更多的活动可供返回。
- en: First we define a reasonable limit as another settings value. In the following
    code, we’re using `10000` as that limit.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将合理的限制定义为另一个设置值。在下面的代码中，我们将使用 `10000` 作为这个限制。
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next we need to modify the `fetch()` method for our collection since the standard
    Backbone.js `fetch()` can’t handle paging. There are three steps in our implementation
    of the method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改集合的 `fetch()` 方法，因为标准的 Backbone.js `fetch()` 无法处理分页。在我们实现此方法时，有三个步骤：
- en: Save a copy of whatever options Backbone.js is using for the request.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 Backbone.js 在请求中使用的所有选项的副本。
- en: Extend those options by adding a callback function when the request succeeds.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加一个回调函数来扩展这些选项，当请求成功时调用这个回调。
- en: Pass control to the normal Backbone.js `fetch()` method for collections.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将控制权交给正常的 Backbone.js `fetch()` 方法处理集合。
- en: Each of those steps is a line in the following implementation. The last one
    might seem a little tricky, but it makes sense if you take it one piece at a time.
    The expression `Backbone.Collection.prototype.fetch` refers to the normal `fetch()`
    method of a Backbone.js collection. We execute this method using `.call()` so
    that we can set the context for the method to be our collection. That’s the first
    `this` parameter of `call()`. The second parameter holds the options for `fetch()`,
    which are just the extended options we created in Step 2.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤在以下实现中对应一行代码。最后一个步骤看起来可能有点复杂，但如果一步一步地理解，实际上是很有道理的。表达式 `Backbone.Collection.prototype.fetch`
    指的是 Backbone.js 集合的正常 `fetch()` 方法。我们使用 `.call()` 来执行这个方法，这样我们可以为方法设置上下文，使其成为我们的集合。这是
    `call()` 的第一个 `this` 参数。第二个参数包含 `fetch()` 的选项，这些选项就是我们在第 2 步中创建的扩展选项。
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By adding a `success` callback to the AJAX request, we’re asking to be notified
    when the request completes. In fact, we’ve said that we want the `this.fetchMore()`
    function to be called. It’s time to write that function; it, too, is a method
    of the Runs collection. This function checks to see if there are more activities
    left. If so, it executes another call to Backbone.js’s regular collection `fetch()`
    just as in the preceding code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为AJAX请求添加`success`回调，我们请求在请求完成时收到通知。实际上，我们已经指定希望调用`this.fetchMore()`函数。现在是时候编写这个函数了；它也是Runs集合的方法。这个函数会检查是否还有更多活动。如果有，它会像前面的代码一样，执行另一次对Backbone.js常规集合`fetch()`的调用。
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since `fetchMore()` is looking at the settings to decide when to stop, we’ll
    need to update those values. Because we already have a `parse()` method, and because
    Backbone calls this method with each response, that’s a convenient place for the
    update. Let’s add a bit of code before the return statement. If the number of
    activities that the server returns is less than the number we asked for, then
    we’ve exhausted the list of activities. We’ll set the `offset` to the `max` so
    `fetchMore()` knows to stop. Otherwise, we increment `offset` by the number of
    activities.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`fetchMore()`是通过查看设置来决定何时停止的，我们需要更新这些值。因为我们已经有了一个`parse()`方法，并且Backbone会在每次响应时调用这个方法，所以更新操作放在这里是很方便的。我们在`return`语句之前添加一些代码。如果服务器返回的活动数量少于我们请求的数量，那么我们已经用尽了活动列表。我们将`offset`设置为`max`，以便`fetchMore()`知道停止。否则，我们会将`offset`增加活动的数量。
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The code we’ve written so far is almost complete, but it has a problem. When
    Backbone.js fetches a collection, it assumes that it’s fetching the whole collection.
    By default, therefore, each fetched response replaces the models already in the
    collection with those in the response. That behavior is fine the first time we
    call `fetch()`, but it’s definitely not okay for `fetchMore()`, which is meant
    to add to the collection instead of replacing it. Fortunately, we can easily tweak
    this behavior by setting the `remove` option.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写的代码几乎完成，但它有一个问题。当Backbone.js获取一个集合时，它假设是在获取整个集合。因此，默认情况下，每次获取的响应都会将集合中已经存在的模型替换为响应中的模型。这种行为在第一次调用`fetch()`时没问题，但对于`fetchMore()`来说就不合适了，因为`fetchMore()`是为了将数据添加到集合中，而不是替换它。幸运的是，我们可以通过设置`remove`选项轻松地调整这种行为。
- en: In our `fetch()` method, we set that option to `true` so Backbone.js will start
    a new collection.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`fetch()`方法中，我们将这个选项设置为`true`，这样Backbone.js就会开始一个新的集合。
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, in the `fetchMore()` method, we can reset this option to `false`, and Backbone.js
    will add to models instead of replacing them in the collection.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`fetchMore()`方法中，我们可以将这个选项重置为`false`，这样Backbone.js就会将模型添加到集合中，而不是替换它们。
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There is still a small problem with the `fetchMore()` method. That code references
    properties of the collection (`this.fetchoptions` and `this.settings`), but the
    method will be called asynchronously when the AJAX request completes. When that
    occurs, the collection won’t be in context, so `this` won’t be set to the collection.
    To fix that, we can bind `fetchMore()` to the collection during initialization.
    Once again, an Underscore.js utility function comes in handy.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchMore()`方法仍然存在一个小问题。该代码引用了集合的属性（`this.fetchoptions`和`this.settings`），但是该方法将在AJAX请求完成时异步调用。当那时发生时，集合将不在上下文中，所以`this`不会指向集合。为了解决这个问题，我们可以在初始化时将`fetchMore()`绑定到集合。再次地，Underscore.js的一个实用函数派上了用场。'
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For the final part of this step, we can make our collection a little friendlier
    to code that uses it. To keep fetching additional pages, we’ve set the `success`
    callback for the `fetch()` options. What happens if the code that uses our collection
    has its own callback? Unfortunately, we’ve erased that callback to substitute
    our own. It would be better to simply set aside an existing callback function
    and then restore it once we’ve finished fetching the entire collection. We’ll
    do that first in our `fetch()` method. Here’s the full code for the method:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步的最后部分，我们可以使我们的集合对使用它的代码更友好。为了继续获取额外的页面，我们已经为`fetch()`的选项设置了`success`回调。那么，如果使用我们集合的代码有自己的回调怎么办呢？不幸的是，我们已经删除了那个回调，替换成了我们自己的回调。更好的做法是简单地暂时保留一个现有的回调函数，然后在我们完成获取整个集合之后恢复它。我们将在`fetch()`方法中首先执行这一操作。以下是该方法的完整代码：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And here’s the code for `fetchMore()`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`fetchMore()`的代码：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now we can execute that callback in `fetchMore()` when we’ve exhausted the server’s
    list.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们用尽服务器返回的列表时，可以在`fetchMore()`中执行回调。
- en: 'Step 4: Dynamically Update the View'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步：动态更新视图
- en: By fetching the collection of runs in pages, we’ve made our application much
    more responsive. We can start displaying summary data for the first 25 runs even
    while we’re waiting to retrieve the rest of the user’s runs from the server. To
    do that effectively, though, we need to make a small change to our Summary view.
    As it stands now, our view is listening for any changes to the collection. When
    a change occurs, it renders the view from scratch.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分批获取运行记录集合，我们使得应用程序变得更加响应迅速。即使在等待从服务器检索其余用户运行记录时，我们也可以开始显示前 25 条运行记录的汇总数据。然而，要有效地做到这一点，我们需要对我们的汇总视图进行一些小改动。目前，视图正在监听集合的任何变化。当发生变化时，视图会从头开始重新渲染。
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Every time we fetch a new page of runs, the collection will change and our
    code will re-render the entire view. That’s almost certainly going to be annoying
    to our users, as each fetched page will cause the browser to temporarily blank
    out the page and then refill it. Instead, we’d like to render only views for the
    newly added models, leaving existing model views alone. To do that, we can listen
    for an `"add"` event instead of a `"change"` event. And when this event triggers,
    we can just render the view for that model. We’ve already implemented the code
    to create and render a view for a single Run model: the `renderRun()` method.
    Our Summary view, therefore, can be modified as shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们获取新的运行记录页面时，集合会发生变化，代码会重新渲染整个视图。这几乎肯定会让我们的用户感到烦扰，因为每次获取页面时，浏览器会暂时清空页面然后再重新填充内容。相反，我们希望只渲染新添加模型的视图，保持现有模型视图不变。为了做到这一点，我们可以监听
    `"add"` 事件而不是 `"change"` 事件。当该事件触发时，我们只需要渲染该模型的视图。我们已经实现了为单个 Run 模型创建并渲染视图的代码：`renderRun()`
    方法。因此，我们可以按照如下方式修改我们的汇总视图：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now as our collection fetches new Run models from the server, they’ll be added
    to the collection, triggering an `"add"` event, which our view captures. The view
    then renders each run on the page.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们的集合从服务器获取新的运行模型时，它们会被添加到集合中，触发一个 `"add"` 事件，视图会捕获该事件。然后，视图会在页面上渲染每一条运行记录。
- en: 'Step 5: Filter the Collection'
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 5：过滤集合
- en: Although our app is interested only in running, the Nike+ service supports a
    variety of athletic activities. When our collection fetches from the service,
    the response will include those other activities as well. To avoid including them
    in our app, we can filter them from the response.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的应用程序只关注跑步，Nike+ 服务支持多种体育活动。当我们的集合从服务端获取数据时，响应将包含这些其他活动。为了避免将它们包含在我们的应用中，我们可以将它们从响应中过滤掉。
- en: We could filter the response manually, checking every activity and removing
    those that aren’t runs. That’s a lot of work, however, and Backbone.js gives us
    an easier approach. To take advantage of Backbone.js, we’ll first add a `validate()`
    method to our Run model. This method takes as parameters the attributes of a potential
    model as well as any options used when it was created or modified. In our case,
    we care only about the attributes. We’ll check to make sure the `activityType`
    equals `"RUN"`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动过滤响应，检查每项活动并移除非跑步的记录。然而，这样做需要大量的工作，而 Backbone.js 提供了一个更简便的方法。为了利用 Backbone.js，我们将首先向我们的
    Run 模型添加一个 `validate()` 方法。这个方法接收潜在模型的属性和创建或修改时使用的任何选项作为参数。在我们的案例中，我们只关心属性。我们会检查确保
    `activityType` 等于 `"RUN"`。
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can see from this code how `validate()` functions should behave. If there
    is an error in the model, then `validate()` returns a value. The specifics of
    the value don’t matter as long as JavaScript considers it true. If there is no
    error, then `validate()` doesn’t need to return anything at all.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中，你可以看到 `validate()` 函数的行为。如果模型中有错误，`validate()` 会返回一个值。只要 JavaScript 将其视为
    `true`，返回值的具体内容并不重要。如果没有错误，`validate()` 就不需要返回任何值。
- en: Now that our model has a `validate()` method, we need to make sure Backbone.js
    calls it. Backbone.js automatically checks with `validate()` whenever a model
    is created or modified by the code, but it doesn’t normally validate responses
    from the server. In our case, however, we do want to validate the server responses.
    That requires that we set the `validate()` property in the `fetch()` options for
    our Runs collection. Here’s the full `fetch()` method with this change included.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的模型已经有了 `validate()` 方法，我们需要确保 Backbone.js 会调用它。Backbone.js 会在模型被创建或修改时自动检查
    `validate()`，但通常不会验证来自服务器的响应。然而，在我们的情况下，我们确实需要验证来自服务器的响应。这就要求我们在 Runs 集合的 `fetch()`
    选项中设置 `validate()` 属性。以下是包括此更改的完整 `fetch()` 方法。
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now when Backbone.js receives server responses, it passes all of the models
    in those responses through the model’s `validate()` method. Any model that fails
    validation is removed from the collection, and our app never has to bother with
    activities that aren’t runs.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当Backbone.js接收到服务器响应时，它会将响应中的所有模型都传递给模型的`validate()`方法。任何未通过验证的模型都会从集合中移除，我们的应用也不必处理那些不是跑步记录的活动。
- en: 'Step 6: Parse the Response'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第6步：解析响应
- en: As long as we’re adding code to the Run model, there’s another change that will
    make Backbone.js happy. Backbone.js requires models to have an attribute that
    makes each object unique; it can use this identifier to distinguish one run from
    any other. By default, Backbone.js expects this attribute to be `id`, as that’s
    a common convention. Nike+, however, doesn’t have an `id` attribute for its runs.
    Instead, the service uses the `activityId` attribute. We can tell Backbone.js
    about this with an extra property in the model.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们正在为Run模型添加代码，那么还有另一个改动会让Backbone.js感到高兴。Backbone.js要求模型具有一个属性，使每个对象具有唯一性；它可以利用这个标识符来区分不同的跑步记录。默认情况下，Backbone.js期望该属性为`id`，因为这是一个常见的约定。然而，Nike+的跑步记录没有`id`属性。相反，该服务使用`activityId`属性。我们可以通过在模型中添加一个额外的属性，告诉Backbone.js这一点。
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This property lets Backbone.js know that for our runs, the `activityId` property
    is the unique identifier.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性让Backbone.js知道，对于我们的跑步记录，`activityId`属性是唯一的标识符。
- en: 'Step 7: Retrieve Details'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第7步：检索详情
- en: So far we’ve relied on the collection’s `fetch()` method to get running data.
    That method retrieves a list of runs from the server. When Nike+ returns a list
    of activities, however, it doesn’t include the full details of each activity.
    It returns summary information, but it omits the detailed metrics arrays and any
    GPS data. Getting those details requires additional requests, so we need to make
    one more change to our Backbone.js app.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直依赖集合的`fetch()`方法来获取运行数据。该方法从服务器获取一组跑步记录。然而，当Nike+返回活动列表时，它并不包含每个活动的完整细节。它返回的是摘要信息，但省略了详细的度量数组和任何GPS数据。获取这些详细信息需要额外的请求，因此我们需要对我们的Backbone.js应用做出一个小的调整。
- en: We’ll first request the detailed metrics that are the basis for the Charts view.
    When the Runs collection fetches its list of runs from the server, each Run model
    will initially have an empty `metrics` array. To get the details for this array,
    we must make another request to the server with the activity identifier included
    in the request URL. For example, if the URL to get a list of runs is *[https://api.nike.com/v1/me/sport/activities/](https://api.nike.com/v1/me/sport/activities/)*,
    then the URL to get the details for a specific run, including its metrics, is
    *[https://api.nike.com/v1/me/sport/activities/2126456911/](https://api.nike.com/v1/me/sport/activities/2126456911/)*.
    The number *2126456911* at the end of that URL is the run’s `activityId`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先请求作为Charts视图基础的详细度量数据。当Runs集合从服务器获取跑步记录列表时，每个Run模型最初会有一个空的`metrics`数组。为了获取该数组的详细信息，我们必须再次向服务器发送请求，并在请求的URL中包含活动标识符。例如，如果获取跑步记录列表的URL是*[https://api.nike.com/v1/me/sport/activities/](https://api.nike.com/v1/me/sport/activities/)*，那么获取特定跑步记录的详细信息，包括其度量数据的URL是*[https://api.nike.com/v1/me/sport/activities/2126456911/](https://api.nike.com/v1/me/sport/activities/2126456911/)*。这个URL末尾的数字*2126456911*就是该跑步记录的`activityId`。
- en: Thanks to the steps we’ve taken earlier in this section, it’s easy to get these
    details in Backbone.js. All we have to do is `fetch()` the model.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了我们在本节之前所做的步骤，在Backbone.js中获取这些细节变得非常容易。我们所要做的就是`fetch()`模型。
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Backbone.js knows the root of the URL because we set that in the Runs collection
    (and our model is a member of that collection). Backbone.js also knows that the
    unique identifier for each run is the `activityId` because we set that property
    in the previous step. And, fortunately for us, Backbone.js is smart enough to
    combine those bits of information and make the request.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone.js知道URL的根路径，因为我们在Runs集合中设置了它（而且我们的模型是该集合的一部分）。Backbone.js也知道每个跑步记录的唯一标识符是`activityId`，因为我们在前一步中设置了该属性。而且，幸运的是，Backbone.js足够聪明，能够将这些信息结合起来并发起请求。
- en: 'We will have to help Backbone.js in one respect, though. The Nike+ app requires
    an authorization token for all requests, and so far we’ve added code for that
    token only to the collection. We have to add the same code to the model. This
    code is almost identical to the code from Step 1 in this section:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在某些方面必须帮助Backbone.js。Nike+应用对所有请求都需要一个授权令牌，到目前为止，我们只在集合中为该令牌添加了代码。我们还需要将相同的代码添加到模型中。此代码几乎与本节第一步中的代码相同：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We first make sure that the `options` object exists, then extend it by adding
    the authorization token. Finally, we defer to the regular Backbone.js `sync()`
    method. At ➊, we get the value for the token directly from the collection. We
    can use `this.collection` here because Backbone.js sets the `collection` property
    of the model to reference the collection to which it belongs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先确保`options`对象存在，然后通过添加授权令牌来扩展它。最后，我们调用常规的 Backbone.js `sync()`方法。在 ➊ 处，我们直接从集合中获取令牌的值。我们可以在这里使用`this.collection`，因为
    Backbone.js 会将模型的`collection`属性设置为引用它所属的集合。
- en: Now we have to decide when and where to call a model’s `fetch()` method. We
    don’t actually need the metrics details for the Summary view on the main page
    of our app; we should bother getting that data only when we’re creating a Details
    view. We can conveniently do that in the view’s `initialize()` method.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须决定何时以及在哪里调用模型的`fetch()`方法。实际上，我们并不需要在应用主页面上的 Summary 视图中获取度量详情；只有在创建 Details
    视图时，我们才需要去获取这些数据。我们可以方便地在视图的`initialize()`方法中执行此操作。
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You might think that the asynchronous nature of the request could cause problems
    for our view. After all, we’re trying to draw the charts when we render the newly
    created view. Won’t it draw the charts before the server has responded (that is,
    before we have any data for the charts)? In fact, it’s almost guaranteed that
    our view will be trying to draw its charts before the data is available. Nonetheless,
    because of the way we’ve structured our views, there is no problem.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为请求的异步特性可能会给我们的视图带来问题。毕竟，我们在渲染新创建的视图时试图绘制图表。是不是会在服务器响应之前（即在我们还没有任何图表数据之前）就绘制了图表？实际上，几乎可以肯定的是，我们的视图会在数据可用之前就尝试绘制图表。尽管如此，由于我们构建视图的方式，根本没有问题。
- en: The magic is in a single statement in the `initialize()` method of our Charts
    view.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法就在我们 Charts 视图的`initialize()`方法中的一行语句。
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That statement tells Backbone.js that our view wants to know whenever the `metrics`
    (or `gps`) property of the associated model changes. When the server responds
    to a `fetch()` and updates that property, Backbone.js calls the view’s `render()`
    method and will try (again) to draw the charts.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句告诉 Backbone.js，当关联模型的`metrics`（或`gps`）属性发生变化时，我们的视图希望知道。服务器响应`fetch()`并更新该属性后，Backbone.js
    会调用视图的`render()`方法，并尝试（再次）绘制图表。
- en: There’s quite a lot going on in this process, so it may help to look at it one
    step at a time.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程中涉及了很多内容，所以一步步来看可能会更有帮助。
- en: The application calls the `fetch()` method of a Runs collection.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序调用了 Runs 集合的`fetch()`方法。
- en: Backbone.js sends a request to the server for a list of activities.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Backbone.js 向服务器发送请求，获取活动列表。
- en: The server’s response includes summary information for each activity, which
    Backbone.js uses to create the initial Run models.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器的响应包括每个活动的摘要信息，Backbone.js使用这些信息来创建初始的 Run 模型。
- en: The application creates a Details view for a specific Run model.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序为特定的 Run 模型创建一个 Details 视图。
- en: The `initialize()` method of this view calls the `fetch()` method of the particular
    model.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该视图的`initialize()`方法调用了特定模型的`fetch()`方法。
- en: Backbone.js sends a request to the server for that activity’s details.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Backbone.js 向服务器发送请求，获取该活动的详细信息。
- en: Meanwhile, the application renders the Details view it just created.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与此同时，应用程序渲染它刚刚创建的 Details 视图。
- en: The Details view creates a Charts view and renders that view.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Details 视图创建了一个 Charts 视图并渲染了该视图。
- en: Because there is no data for any charts, the Charts view doesn’t actually add
    anything to the page, but it is waiting to hear of any relevant changes to the
    model.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为没有图表的数据，Charts 视图实际上并没有向页面添加任何内容，而是在等待接收任何与模型相关的变化。
- en: Eventually the server responds to the request in Step 6 with details for the
    activity.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，服务器在第 6 步中对请求做出响应，并提供了活动的详细信息。
- en: Backbone.js updates the model with the new details and notices that, as a result,
    the `metrics` property has changed.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Backbone.js 使用新的详细信息更新模型，并注意到`metrics`属性因此发生了变化。
- en: Backbone.js triggers the change event for which the Charts view has been listening.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Backbone.js 触发了 Charts 视图一直在监听的变更事件。
- en: The Charts view receives the event trigger and again renders itself.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Charts 视图接收到事件触发器，并再次渲染自己。
- en: Because chart data is now available, the `render()` method is able to create
    the charts and add them to the page.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于图表数据现在已经可用，`render()`方法能够创建图表并将它们添加到页面上。
- en: Whew! It’s a good thing that Backbone.js takes care of all that complexity.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！幸好 Backbone.js 处理了所有这些复杂性。
- en: At this point we’ve managed to retrieve the detailed metrics for a run, but
    we haven’t yet added any GPS data. Nike+ requires an additional request for that
    data, so we’ll use a similar process. In this case, though, we can’t rely on Backbone
    .js because the URL for the GPS request is unique to Nike+. That URL is formed
    by taking the individual activity’s URL and appending */gps*—for example, *[https://api.nike.com/v1/me/sport/activities/2126456911/gps/](https://api.nike.com/v1/me/sport/activities/2126456911/gps/)*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经成功地检索到跑步的详细指标，但还没有添加任何 GPS 数据。Nike+ 需要一个额外的请求来获取这些数据，所以我们将使用类似的过程。然而，在这种情况下，我们不能依赖
    Backbone.js，因为 GPS 请求的 URL 是 Nike+ 独有的。该 URL 是通过将单个活动的 URL 和 `/gps` 拼接在一起形成的——例如，*
    [https://api.nike.com/v1/me/sport/activities/2126456911/gps/](https://api.nike.com/v1/me/sport/activities/2126456911/gps/)*。
- en: To make the additional request, we can add some code to the regular `fetch()`
    method. We’ll request the GPS data at the same time Backbone.js asks for the metrics
    details. The basic approach, which the following code fragment illustrates, is
    simple. We’ll first see if the activity even has any GPS data. We can do that
    by checking the `isGpsActivity` property, which the server provides on activity
    summaries. If it does, then we can request it. In either case, we also want to
    execute the normal `fetch()` process for the model. We do that by getting a reference
    to the standard `fetch()` method for the model (`Backbone.Model.prototype.fetch`)
    and then calling that method. We pass it the same `options` passed to us.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发出额外的请求，我们可以在常规的 `fetch()` 方法中添加一些代码。我们将在 Backbone.js 请求指标详细信息的同时请求 GPS 数据。基本方法如以下代码片段所示，非常简单。我们首先检查活动是否有任何
    GPS 数据。我们可以通过检查服务器提供的活动摘要中的 `isGpsActivity` 属性来做到这一点。如果有，我们就可以请求该数据。无论如何，我们还需要执行模型的常规
    `fetch()` 过程。我们通过获取模型的标准 `fetch()` 方法的引用（`Backbone.Model.prototype.fetch`），然后调用该方法来实现。我们将相同的
    `options` 参数传递给它。
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next, to make the request to Nike+, we can use jQuery’s AJAX function. Since
    we’re asking for JavaScript objects (JSON data), the `$.getJSON()` function is
    the most appropriate. First we set aside a reference to the run by assigning `this`
    to the local variable `model`. We’ll need that variable because `this` won’t reference
    the model when jQuery executes our callback. Then we call `$.getJSON()` with three
    parameters. First is the URL for the request. We get that from Backbone.js by
    calling the `url()` method for the model and appending the trailing */gps*. The
    second parameter is the data values to be included with the request. As always,
    we need to include an authorization token. Just as we did before, we can get that
    token’s value from the collection. The final parameter is a callback function
    that JQuery executes when it receives the server’s response. In our case, the
    function simply sets the `gps` property of the model to the response data.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了向 Nike+ 发出请求，我们可以使用 jQuery 的 AJAX 函数。由于我们请求的是 JavaScript 对象（JSON 数据），因此
    `$.getJSON()` 函数是最合适的。首先，我们通过将 `this` 赋值给局部变量 `model` 来保留对跑步的引用。我们需要这个变量，因为在 jQuery
    执行我们的回调时，`this` 将不再指向模型。然后，我们调用 `$.getJSON()` 并传递三个参数。第一个参数是请求的 URL。我们通过调用模型的
    `url()` 方法并附加尾部的 `/gps` 来从 Backbone.js 获取这个 URL。第二个参数是请求时要包含的数据值。像往常一样，我们需要包含一个授权令牌。就像之前一样，我们可以从集合中获取该令牌的值。最后一个参数是回调函数，当
    jQuery 收到服务器响应时执行。在我们的例子中，函数会将模型的 `gps` 属性设置为响应数据。
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Not surprisingly, the process of retrieving GPS data works the same way as retrieving
    the detailed metrics. Initially our Map view won’t have the data it needs to create
    a map for the run. Because it’s listening for changes to the `gps` property of
    the model, however, it will be notified when that data is available. At that point
    it can complete the `render` function and the user will be able to view a nice
    map of the run.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 不出所料，检索 GPS 数据的过程与检索详细指标的过程相同。最初，我们的地图视图没有创建跑步地图所需的数据。然而，由于它在监听模型的 `gps` 属性的变化，因此当数据可用时，它会收到通知。此时，它可以完成
    `render` 函数，用户将能够查看跑步的漂亮地图。
- en: Putting It All Together
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将一切整合起来
- en: At this point in the chapter, we have all the pieces for a simple data-driven
    web application. Now we’ll take those pieces and assemble them into the app. At
    the end of this section, we’ll have a complete application. Users start the app
    by visiting a web page, and our JavaScript code takes it from there. The result
    is a *single-page application*, or SPA. SPAs have become popular because JavaScript
    code can respond to user interaction immediately in the browser, which is much
    quicker than traditional websites communicating with a server located halfway
    across the Internet. Users are often pleased with the snappy and responsive result.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们已经具备了构建一个简单数据驱动型Web应用的所有组件。现在，我们将这些组件组装成应用程序。在这一节结束时，我们将拥有一个完整的应用程序。用户通过访问网页启动应用程序，而我们的JavaScript代码则从这里开始运行。结果是一个*单页应用*（SPA）。SPA之所以流行，是因为JavaScript代码能够立即响应用户的操作，这比传统网站通过服务器与位于遥远网络另一端的服务器通信要快得多。用户通常会对这种迅速且响应灵敏的结果感到满意。
- en: Even though our app is executing in a single web page, our users still expect
    certain behaviors from their web browsers. They expect to be able to bookmark
    a page, share it with friends, or navigate using the browser’s forward and back
    buttons. Traditional websites can rely on the browser to support all of those
    behaviors, but a single-page application can’t. As we’ll see in the steps that
    follow, we have to write some additional code to give our users the behavior they
    expect.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的应用程序只在一个网页上执行，但用户仍然期望浏览器能提供某些行为。比如，他们希望能够书签保存页面、与朋友分享，或使用浏览器的前进和后退按钮进行导航。传统的网站可以依赖浏览器来支持这些行为，但单页应用却不能。如我们接下来的步骤所示，我们必须编写一些额外的代码，以实现用户期望的行为。
- en: 'Step 1: Create a Backbone.js Router'
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤1：创建Backbone.js路由器
- en: So far we’ve looked at three Backbone.js components—models, collections, and
    views—all of which may be helpful in any JavaScript application. The fourth component,
    the *router*, is especially helpful for single-page applications. You won’t be
    surprised to learn that we can use Yeoman to create the scaffolding for a router.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过了三个Backbone.js组件——模型、集合和视图——这些都可以在任何JavaScript应用程序中派上用场。第四个组件是*路由器*，它对于单页应用特别有用。你不会惊讶地发现，我们可以使用Yeoman来创建路由器的脚手架。
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that we’ve named our router `app`. As you might expect from this name,
    we’re using this router as the main controller for our application. That approach
    has pros and cons. Some developers feel that a router should be limited strictly
    to routing, while others view the router as the natural place to coordinate the
    overall application. For a simple example such as ours, there isn’t really any
    harm in adding a bit of extra code to the router to control the app. In complex
    applications, however, it might be better to separate routing from application
    control. One of the nice things about Backbone.js is that it’s happy to support
    either approach.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将路由器命名为`app`。正如你从这个名字中可能会预期的那样，我们将这个路由器作为应用程序的主要控制器。这个方法有优缺点。一些开发者认为路由器应该严格限于路由功能，而另一些开发者则认为路由器是协调整个应用程序的自然位置。对于像我们这样简单的示例，将一些额外的代码添加到路由器中来控制应用程序其实并不会带来太大问题。然而，在复杂的应用程序中，最好还是将路由功能与应用程序控制分开。Backbone.js的一个优点就是它能够支持这两种方法。
- en: With the scaffolding in place, we can start adding our router code to the *app.js*
    file. The first property we’ll define is the `routes`. This property is an object
    whose keys are URL fragments and whose values are methods of the router. Here’s
    our starting point.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚手架搭建完成后，我们可以开始将路由器代码添加到*app.js*文件中。我们将定义的第一个属性是`routes`。这个属性是一个对象，其键是URL片段，值是路由器的方法。下面是我们的起点。
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first route has an empty URL fragment (`""`). When a user visits our page
    without specifying a path, the router will call its `summary()` method. If, for
    example, we were hosting our app using the *greatrunningapp.com* domain name,
    then users entering *[http://greatrunningapp.com/](http://greatrunningapp.com/)*
    in their browsers would trigger that route. Before we look at the second route,
    let’s see what the `summary()` method does.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个路由的URL片段为空（`""`）。当用户访问我们的页面且没有指定路径时，路由器将调用其`summary()`方法。例如，如果我们使用*greatrunningapp.com*域名托管我们的应用程序，那么用户在浏览器中输入*[http://greatrunningapp.com/](http://greatrunningapp.com/)*时就会触发这个路由。在我们查看第二个路由之前，让我们看看`summary()`方法的作用。
- en: The code is exactly what we’ve seen before. The `summary()` method creates a
    new Runs collection, fetches that collection, creates a Summary view of the collection,
    and renders that view onto the page. Users visiting the home page for our app
    will see a summary of their runs.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 代码和我们之前看到的一样。`summary()` 方法创建一个新的 Runs 集合，获取该集合，创建该集合的 Summary 视图，并将该视图渲染到页面上。访问我们应用程序首页的用户将看到他们的运行摘要。
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we can consider our second route. It has a URL fragment of *runs/:id*.
    The *runs/* part is a standard URL path, while *:id* is how Backbone.js identifies
    an arbitrary variable. With this route, we’re telling Backbone.js to look for
    a URL that starts out as *[http://greatrunningapp.com/runs/](http://greatrunningapp.com/runs/)*
    and to consider whatever follows as the value for the `id` parameter. We’ll use
    that parameter in the router’s `details()` method. Here’s how we’ll start developing
    that method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以考虑第二条路由。它的 URL 片段是 *runs/:id*。其中 *runs/* 是标准的 URL 路径，而 *:id* 是 Backbone.js
    用来标识任意变量的方式。通过这条路由，我们告诉 Backbone.js 寻找一个以 *[http://greatrunningapp.com/runs/](http://greatrunningapp.com/runs/)*
    开头的 URL，并将其后面的部分视为 `id` 参数的值。我们将在路由器的 `details()` 方法中使用这个参数。下面是我们开始开发该方法的方式：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, the code is almost the same as the `summary()` method, except
    we’re showing only a single run instead of the whole collection. We create a new
    Run model, set its `id` to the value in the URL, fetch the model from the server,
    create a Details view, and render that view on the page.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码几乎与 `summary()` 方法相同，只是我们这里只显示了单个运行，而不是整个集合。我们创建了一个新的 Run 模型，将其 `id`
    设置为 URL 中的值，从服务器获取该模型，创建一个 Details 视图，并将该视图渲染到页面上。
- en: The router lets users go straight to an individual run by using the appropriate
    URL. A URL of *[http://greatrunningapp.com/runs/2126456911](http://greatrunningapp.com/runs/2126456911)*,
    for example, will fetch and display the details for the run that has an `activityId`
    equal to `2126456911`. Notice that the router doesn’t have to worry about what
    specific attribute defines the model’s unique identifier. It uses the generic
    `id` property. Only the model itself needs to know the actual property name that
    the server uses.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器让用户可以直接访问单个运行，通过使用合适的 URL。例如，URL *[http://greatrunningapp.com/runs/2126456911](http://greatrunningapp.com/runs/2126456911)*
    将获取并显示 `activityId` 等于 `2126456911` 的运行的详细信息。注意，路由器无需关心是什么特定的属性定义了模型的唯一标识符。它使用通用的
    `id` 属性。只有模型本身需要知道服务器使用的实际属性名称。
- en: With the router in place, our single-page application can support multiple URLs.
    One shows a summary of all runs, while others show the details of a specific run.
    Because the URLs are distinct, our users can treat them just like different web
    pages. They can bookmark them, email them, or share them on social networks. And
    whenever they or their friends return to a URL, it will show the same contents
    as before. That’s exactly how users expect the Web to behave.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有了路由器，我们的单页面应用程序可以支持多个 URL。一个 URL 显示所有运行的摘要，而其他 URL 显示特定运行的详细信息。由于 URL 是独立的，用户可以像浏览不同的网页一样处理它们。他们可以将其添加到书签，发送电子邮件，或者在社交网络上分享。每当他们或他们的朋友返回某个
    URL 时，它将显示与之前相同的内容。这正是用户对 Web 的期望行为。
- en: There is another behavior that users expect, though, that we haven’t yet supported.
    Users expect to use their browser’s back and forward buttons to navigate through
    their browsing histories. Fortunately, Backbone.js has a utility that takes care
    of that functionality. It’s the *history* feature, and we can enable it during
    the app router’s initialization.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，用户还期望有另一种行为，我们尚未支持。用户希望能使用浏览器的后退和前进按钮在浏览历史中进行导航。幸运的是，Backbone.js 提供了一个工具来处理这个功能。它就是
    *history* 功能，我们可以在应用路由器初始化时启用它。
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: For our simple app, that’s all we have to do to handle browsing histories. Backbone.js
    takes care of everything else.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们简单的应用程序，这就是我们处理浏览历史的全部工作。其余的由 Backbone.js 负责。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Support for multiple URLs will probably require some configuration of your
    web server. More specifically, you’ll want the server to map all URLs to the same
    *index.html* file. The details of this configuration depend on the web server
    technology. With open source Apache servers, the** *.htaccess* **file can define
    the mapping.**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**支持多个 URL 可能需要对您的 Web 服务器进行一些配置。更具体地说，您需要让服务器将所有 URL 映射到同一个 *index.html* 文件。此配置的细节取决于
    Web 服务器技术。对于开源的 Apache 服务器，** *.htaccess* **文件可以定义这种映射。**'
- en: 'Step 2: Support Run Models Outside of Any Collection'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 2：支持不属于任何集合的 Run 模型
- en: 'Unfortunately, if we try to use the preceding code with our existing Run model,
    we’ll encounter some problems. First among them is the fact that our Run model
    relies on its parent collection. It finds the authorization token, for example,
    using `this.collection.settings.authorization_token`. When the browser goes directly
    to the URL for a specific run, however, there won’t be a collection. In the following
    code, we make some tweaks to address this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果我们尝试在现有的 Run 模型中使用上述代码，我们将遇到一些问题。首先是我们的 Run 模型依赖于它的父集合。例如，它使用`this.collection.settings.authorization_token`来找到授权令牌。然而，当浏览器直接访问某个特定
    run 的 URL 时，不会有集合。以下代码对这个问题做了调整：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now we provide the token to the Run model when we create it at ➋. We also make
    its value an option passed to the collection on creation at ➊.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在创建 Run 模型时提供授权令牌 ➋。我们还将其值作为选项传递给在创建时的集合 ➊。
- en: Next we need to modify the Run model to use this new parameter. We’ll handle
    the token the same way we do in the Runs collection.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改 Run 模型，以使用这个新参数。我们将像在 Runs 集合中一样处理令牌。
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We start by defining default values for all the settings. Unlike with the collection,
    the only setting our model needs is the `authorization_token`. Next we make sure
    that we have an `options` object. If none was provided, we create an empty one.
    For the third step, we check to see if the model is part of a collection by looking
    at `this.collection`. If that property exists, then we grab any settings from
    the collection and override our defaults. The final step overrides the result
    with any settings passed to our constructor as options. When, as in the preceding
    code, our router provides an `authorization_token` value, that’s the value our
    model will use. When the model is part of a collection, there is no specific token
    associated with the model. In that case, we fall back to the collection’s token.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为所有设置定义默认值。与集合不同，我们的模型所需的唯一设置是`authorization_token`。接下来，我们确保我们有一个`options`对象。如果没有提供，我们就创建一个空对象。在第三步，我们通过查看`this.collection`来检查模型是否属于一个集合。如果该属性存在，我们就从集合中获取任何设置并覆盖默认值。最后一步将用任何作为选项传递给构造函数的设置来覆盖结果。当像前面的代码一样，我们的路由提供了一个`authorization_token`值时，模型将使用这个值。当模型是集合的一部分时，模型没有与之关联的特定令牌。在这种情况下，我们会回退到集合的令牌。
- en: Now that we have an authorization token, we can add it to the model’s AJAX requests.
    The code is again pretty much the same as our code in the Runs collection. We’ll
    need a property that specifies the URL for the REST service, and we’ll need to
    override the regular `sync()` method to add the token to any requests.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了授权令牌，可以将其添加到模型的 AJAX 请求中。代码与我们在 Runs 集合中的代码几乎相同。我们需要一个属性来指定 REST 服务的 URL，并且我们需要覆盖常规的`sync()`方法，将令牌添加到所有请求中。
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This extra code takes care of the authorization, but there’s still a problem
    with our model. In the previous section, Run models existed only as part of a
    Runs collection, and the act of fetching that collection populated each of its
    models with summary attributes, including, for example, `isGpsActivity`. The model
    could safely check that property whenever we tried to fetch the model details
    and, if appropriate, simultaneously initiate a request for the GPS data. Now,
    however, we’re creating a Run model on its own without the benefit of a collection.
    When we fetch the model, the only property we’ll know is the unique identifier.
    We can’t decide whether or not to request GPS data, therefore, until after the
    server responds to the fetch.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这段额外的代码处理了授权，但我们的模型仍然存在问题。在前一部分中，Run 模型仅作为 Runs 集合的一部分存在，获取该集合的操作会为每个模型填充摘要属性，例如`isGpsActivity`。每当我们尝试获取模型的详细信息时，模型可以安全地检查该属性，并在适当时同时发起
    GPS 数据请求。然而，现在我们单独创建一个 Run 模型，没有集合的帮助。当我们获取模型时，我们唯一知道的属性是唯一标识符。因此，在服务器响应获取请求之前，我们无法决定是否请求
    GPS 数据。
- en: To separate the request for GPS data from the general fetch, we can move that
    request to its own method. The code is the same as before (except, of course,
    we get the authorization token from local settings).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 GPS 数据请求与一般的获取请求分开，我们可以将该请求移到一个独立的方法中。代码与之前相同（当然，唯一的不同是我们从本地设置中获取授权令牌）。
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To trigger this method, we’ll tell Backbone.js that whenever the model changes,
    it should call the `fetchGps()` method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了触发这个方法，我们将告诉 Backbone.js，每当模型发生变化时，它应该调用`fetchGps()`方法。
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Backbone.js will detect just such a change when the `fetch()` response arrives
    and populates the model, at which time our code can safely check `isGpsActivity()`
    and make the additional request.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当`fetch()`响应到达时，Backbone.js会检测到这种变化，并填充模型，此时我们的代码可以安全地检查`isGpsActivity()`并发出额外的请求。
- en: 'Step 3: Let Users Change Views'
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 3：让用户切换视图
- en: Now that our app can correctly display two different views, it’s time to let
    our users in on the fun. For this step, we’ll give them an easy way to change
    back and forth between the views. Let’s first consider the Summary view. It would
    be nice if a user could click on any run that appears in the table and be instantly
    taken to the detailed view for that run.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序能够正确显示两种不同的视图，是时候让用户也参与其中了。在这一步中，我们将为他们提供一种轻松的方式在视图之间切换。首先让我们考虑一下`Summary`视图。如果用户能够点击表格中出现的任何一行并立即跳转到该行的详细视图，那就太好了。
- en: 'Our first decision is where to put the code that listens for clicks. At first,
    it might seem like the SummaryRow view is a natural place for that code. That
    view is responsible for rendering the row, so it seems logical to let that view
    handle events related to the row. If we wanted to do that, Backbone.js makes it
    very simple; all we need is an extra property and an extra method in the view.
    They might look like the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个决定是将监听点击事件的代码放在哪里。起初，可能会觉得`SummaryRow`视图是放置这段代码的自然位置。该视图负责渲染行，因此让该视图处理与行相关的事件似乎是合乎逻辑的。如果我们想这么做，Backbone.js使得这一切变得非常简单；我们只需要在视图中添加一个额外的属性和一个额外的方法。它们可能看起来像下面这样：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `events` property is an object that lists the events of interest to our
    view. In this case there’s only one: the `click` event. The value—in this case,
    `clicked`—identifies the method that Backbone.js should call when the event occurs.
    We’ve skipped the details of that method for now.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`events`属性是一个对象，列出了我们视图感兴趣的事件。在这种情况下，只有一个事件：`click`事件。该值——在此情况下是`clicked`——标识了当事件发生时Backbone.js应调用的方法。我们暂时跳过了该方法的细节。'
- en: There is nothing technically wrong with this approach, and if we were to continue
    the implementation, it would probably work just fine. It is, however, very inefficient.
    Consider a user who has hundreds of runs stored on Nike+. The summary table would
    have hundreds of rows, and each row would have its own function listening for
    `click` events. Those event handlers can use up a lot of memory and other resources
    in the browser and make our app sluggish. Fortunately, there’s a different approach
    that’s far less stressful to the browser.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这种方法没有问题，如果我们继续实现它，可能会很好地工作。然而，它非常低效。想象一个用户在Nike+上存储了数百条跑步记录。摘要表格将有数百行，每一行都将有自己监听`click`事件的函数。这些事件处理程序可能会占用大量内存和其他浏览器资源，导致我们的应用变得迟缓。幸运的是，还有一种不同的方法，对浏览器的压力要小得多。
- en: Instead of having potentially hundreds of event handlers, each listening for
    clicks on a single row, we’d be better off with one event handler listening for
    clicks on all of the table rows. Since the Summary view is responsible for all
    of those rows, it’s the natural place to add that handler. We can still take advantage
    of Backbone .js to make its implementation easy by adding an `events` object to
    our view. In this case, we can do even better, though. We don’t care about `click`
    events on the table header; only the rows in the table body matter. By adding
    a jQuery-style selector after the event name, we can restrict our handler to elements
    that match that selector.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与其为每一行都设置数百个监听`click`事件的事件处理程序，我们不如使用一个事件处理程序监听所有表格行的点击事件。由于`Summary`视图负责所有这些行，它是添加该处理程序的自然位置。我们仍然可以利用Backbone.js使实现变得简单，只需向视图中添加一个`events`对象。然而，我们可以做得更好一些。我们不关心表头的`click`事件，只有表格主体中的行才是我们关心的。通过在事件名称后添加类似jQuery的选择器，我们可以将处理程序限制为匹配该选择器的元素。
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding code asks Backbone.js to watch for `click` events within the `<tbody>`
    element of our view. When an event occurs, Backbone.js will call the `clicked()`
    method of our view.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码要求Backbone.js监听我们视图中的`<tbody>`元素中的`click`事件。当事件发生时，Backbone.js将调用我们视图的`clicked()`方法。
- en: Before we develop any code for that `clicked()` method, we need a way for it
    to figure out which specific run model the user has selected. The event handler
    will be able to tell which row the user clicked, but how will it know which model
    that row represents? To make the answer easy for the handler, we can embed the
    necessary information directly in the markup for the row. That requires a few
    small adjustments to the `renderRun()` method we created earlier.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为`clicked()`方法编写任何代码之前，我们需要一种方法让它弄清楚用户选择了哪个特定的运行模型。事件处理器能够判断用户点击的是哪一行，但它怎么知道那一行代表的是哪个模型呢？为了让处理器能够轻松获取答案，我们可以直接在行的标记中嵌入必要的信息。这需要对我们之前创建的`renderRun()`方法做一些小调整。
- en: The revised method still creates a SummaryRow view for each model, renders that
    view, and appends the result to the table body. Now, though, we’ll add one extra
    step just before the row is added to the page. We add a special attribute, `data-id`,
    to the row and set its value equal to the model’s unique identifier. We use `data-id`
    because the HTML5 standard allows any attribute with a name that begins with `data-`.
    Custom attributes in this form won’t violate the standard and won’t cause browser
    errors.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的方法仍然为每个模型创建一个SummaryRow视图，渲染该视图并将结果添加到表格主体中。不过，现在我们会在将行添加到页面之前，增加一个额外的步骤。我们为该行添加一个特殊的属性`data-id`，并将其值设置为模型的唯一标识符。我们使用`data-id`是因为HTML5标准允许任何以`data-`开头的属性名。这种形式的自定义属性不会违反标准，也不会导致浏览器错误。
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The resulting markup for a run with an identifier of `2126456911` would look
    like the following example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于标识符为`2126456911`的运行，生成的标记大致如下所示：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Once we’ve made sure that the markup in the page has a reference back to the
    Run models, we can take advantage of that markup in our `clicked` event handler.
    When Backbone.js calls the handler, it passes it an event object. From that object,
    we can find the target of the event. In the case of a `click` event, the target
    is the HTML element on which the user clicked.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确保页面中的标记与Run模型有回溯引用，我们就可以在`clicked`事件处理器中利用这些标记。当Backbone.js调用该处理器时，它会传递一个事件对象。从这个对象中，我们可以找到事件的目标。在`click`事件的情况下，目标就是用户点击的HTML元素。
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: From the preceding markup, it’s clear that most of the table row is made up
    of table cells (`<td>` elements), so a table cell will be the likely target of
    the `click` event. We can use the jQuery `parents()` function to find the table
    row that is the parent of the click target.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的标记可以看出，表格行大部分是由表格单元格（`<td>`元素）组成的，因此表格单元格很可能是`click`事件的目标。我们可以使用jQuery的`parents()`函数来查找点击目标的父表格行。
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Once we’ve found that parent row, we extract the `data-id` attribute value.
    To be on the safe side, we also handle the case in which the user somehow manages
    to click on the table row itself rather than an individual table cell.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了那个父行，我们就提取`data-id`属性的值。为了安全起见，我们还要处理用户不小心点击表格行本身而不是单个表格单元格的情况。
- en: After retrieving the attribute value, our view knows which run the user selected;
    now it has to do something with the information. It might be tempting to have
    the Summary view directly render the Details view for the run, but that action
    would not be appropriate. A Backbone.js view should take responsibility only for
    itself and any child views that it contains. That approach allows the view to
    be safely reused in a variety of contexts. Our Summary view, for example, might
    well be used in a context in which the Details view isn’t even available. In that
    case, trying to switch directly to the Details view would, at best, generate an
    error.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取了属性值之后，我们的视图知道了用户选择了哪个运行模型；现在它需要对这些信息进行处理。可能会有一种冲动让Summary视图直接渲染运行模型的Details视图，但这样做并不合适。Backbone.js视图应该只负责自己和它包含的任何子视图。这种做法使得视图可以在各种上下文中安全地复用。例如，我们的Summary视图可能会在一个没有Details视图的上下文中使用。在这种情况下，直接切换到Details视图，充其量会引发错误。
- en: 'Because the Summary view cannot itself respond to the user clicking on a table
    row, it should instead follow the hierarchy of the application and, in effect,
    pass the information “up the chain of command.” Backbone.js provides a convenient
    mechanism for this type of communication: custom events. Instead of responding
    directly to the user click, the Summary view triggers a custom event. Other parts
    can listen for this event and respond appropriately. If no other code is listening
    for the event, then nothing happens, but at least the Summary view can say that
    it’s done its job.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于总结视图本身不能响应用户点击表格行的操作，它应该遵循应用的层次结构，实际上将信息“传递给上层”。Backbone.js 为这种类型的通信提供了一个方便的机制：自定义事件。总结视图不会直接响应用户点击，而是触发一个自定义事件。其他部分可以监听这个事件并作出相应的响应。如果没有其他代码在监听这个事件，那么什么也不会发生，但至少总结视图可以说它已经完成了自己的工作。
- en: 'Here’s how we can generate a custom event in our view:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何在视图中生成自定义事件：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We call the event `select` to indicate that the user has selected a specific
    run, and we pass the identifier of that run as a parameter associated with the
    event. At this point, the Summary view is complete.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将事件命名为 `select`，以表明用户选择了一个特定的运行，并将该运行的标识符作为与事件相关的参数传递。到此为止，总结视图已经完成。
- en: 'The component that should respond to this custom event is the same component
    that created the Summary view in the first place: our app router. We’ll first
    need to listen for the event. We can do that right after we create it in the `summary()`
    method.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 应该响应这个自定义事件的组件是最初创建总结视图的组件：我们的应用路由器。我们首先需要监听这个事件。我们可以在 `summary()` 方法中创建它之后立即进行监听。
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When the user selects a specific run from the Summary view, Backbone.js calls
    our router’s `selected()` method, which will receive any event data as parameters.
    In our case, the event data is the unique identifier, so that becomes the method’s
    parameter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户从总结视图中选择一个特定的运行时，Backbone.js 会调用我们路由器的 `selected()` 方法，并将任何事件数据作为参数传入。在我们的例子中，事件数据是唯一标识符，所以它成为该方法的参数。
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you can see, the event handler code is quite simple. It constructs a URL
    that corresponds to the Details view (`"runs/" + id`) and passes that URL to the
    router’s own `navigate()` method. That method updates the browser’s navigation
    history. The second parameter (`{ trigger: true }`) tells Backbone.js to also
    act as if the user had actually navigated to the URL. Because we’ve set up the
    `details()` method to respond to URLs of the form *runs/:id*, Backbone.js will
    call `details()`, and our router will show the details for the selected run.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '如你所见，事件处理器的代码非常简单。它构造一个对应详细信息视图的 URL（`"runs/" + id`），并将该 URL 传递给路由器的 `navigate()`
    方法。该方法更新浏览器的导航历史记录。第二个参数（`{ trigger: true }`）告诉 Backbone.js，假如用户实际导航到该 URL，也要执行相应的操作。由于我们已经设置了
    `details()` 方法来响应 *runs/:id* 格式的 URL，Backbone.js 会调用 `details()`，然后我们的路由器将显示所选运行的详细信息。'
- en: When users are looking at a Details view, we’d also like to provide a button
    to let them easily navigate to the Summary view. As with the Summary view, we
    can add an event handler for the button and trigger a custom event when a user
    clicks it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户查看详细信息视图时，我们还希望提供一个按钮，让他们能够轻松地导航到总结视图。与总结视图一样，我们可以为按钮添加一个事件处理器，当用户点击按钮时触发一个自定义事件。
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: And, of course, we need to listen for that custom event in our router.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要在路由器中监听这个自定义事件。
- en: '[PRE49]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Once again we respond to the user by constructing an appropriate URL and triggering
    a navigation to it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次通过构造适当的 URL 并触发导航来响应用户。
- en: You might be wondering why we have to explicitly trigger the navigation change.
    Shouldn’t that be the default behavior? Although that may seem reasonable, in
    most cases it wouldn’t be appropriate. Our application is simple enough that triggering
    the route works fine. More complex applications, however, probably want to take
    different actions depending on whether the user performs an action within the
    app or navigates directly to a particular URL. It’s better to have different code
    handling each of those cases. In the first case the app would still want to update
    the browser’s history, but it wouldn’t want to trigger a full navigation action.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么我们必须显式触发导航变化？难道这不是默认行为吗？虽然这看起来合理，但在大多数情况下，这并不合适。我们的应用足够简单，触发路由就能正常工作。然而，更复杂的应用可能希望根据用户是执行了某个操作还是直接导航到特定
    URL 来采取不同的行动。处理每种情况的代码最好分开写。在第一种情况下，应用仍然希望更新浏览器的历史记录，但不希望触发完全的导航操作。
- en: 'Step 4: Fine-Tuning the Application'
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第四步：精细调整应用程序
- en: At this point our app is completely functional. Our users can view their summaries,
    bookmark and share details of specific runs, and navigate the app using the browser’s
    back and forward buttons. Before we can call it complete, however, there’s one
    last bit of housekeeping for us. The app’s performance isn’t optimal, and, even
    more critically, it *leaks* memory, using small amounts of the browser’s memory
    without ever releasing them.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序已经完全功能化。用户可以查看他们的总结，收藏并分享特定运行的详情，并通过浏览器的前进和后退按钮来导航应用程序。然而，在我们宣布它完成之前，还有最后一项清理工作要做。应用程序的性能不是最优的，而且更为关键的是，它存在*内存泄漏*，即占用了浏览器的小部分内存，却从未释放。
- en: 'The most obvious problem is in the router’s `summary()` method, reproduced
    here:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的问题出现在路由器的`summary()`方法中，具体代码如下：
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Every time this method executes, it creates a new collection, fetches that collection,
    and renders a Summary view for the collection. Clearly we have to go through those
    steps the first time the method executes, but there is no need to repeat them
    later. Neither the collection nor its view will change if the user selects a specific
    run and then returns to the summary. Let’s add a check to the method so that we
    take those steps only if the view doesn’t already exist.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每次执行该方法时，它都会创建一个新的集合，获取该集合，并为该集合渲染一个Summary视图。显然，第一次执行该方法时，我们必须经过这些步骤，但之后就不需要重复执行了。如果用户选择了特定的运行记录并返回到总结视图，集合或其视图不会发生变化。我们可以在方法中添加一个检查，只有在视图不存在时才执行这些步骤。
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can also add a check in the `details()` method. When that method executes
    and a Summary view is present, we can “set aside” the Summary view’s markup using
    jQuery’s `detach()` function. That will keep the markup and its event handlers
    ready for a quick reinsertion onto the page should the user return to the summary.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`details()`方法中添加一个检查。当该方法执行并且Summary视图存在时，我们可以使用jQuery的`detach()`函数“搁置”Summary视图的标记。这将保留标记及其事件处理程序，以便用户返回到总结页面时，可以快速重新插入。
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Those changes make switching to and from the Summary view more efficient. We
    can also make some similar changes for the Details view. In the `details()` method
    we don’t have to fetch the run if it’s already present in the collection. We can
    add a check, and if the data for the run is already available, we won’t bother
    with the fetch.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改使得在Summary视图之间的切换更加高效。我们还可以对Details视图做类似的优化。在`details()`方法中，如果运行记录已经存在于集合中，我们就不必重新获取它。我们可以添加一个检查，如果该运行的数据已经可用，就不再进行获取操作。
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the `summary()` method, we don’t want to simply set aside the Details view
    as we did for the Summary view. That’s because there may be hundreds of Details
    views hanging around if a user starts looking at all of the runs available. Instead,
    we want to cleanly delete the Details view. That lets the browser know that it
    can release any memory that the view is consuming.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在`summary()`方法中，我们不希望像处理Summary视图时那样简单地将Details视图搁置一旁。这是因为，如果用户开始查看所有可用的运行记录，可能会有成百上千个Details视图存在。因此，我们希望干净地删除Details视图，这样浏览器就可以释放该视图占用的内存。
- en: As you can see from the following code, we’ll do that in three steps.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如下代码所示，我们将分三个步骤进行操作。
- en: Remove the event handler we added to the Details view to catch `summarize` events.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除我们之前为捕捉`summarize`事件而添加到Details视图的事件处理程序。
- en: Call the view’s `remove()` method so it releases any memory it’s holding internally.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用视图的`remove()`方法，以释放它所占用的内存。
- en: Set `this.detailsView` to `null` to indicate that the view no longer exists.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`this.detailsView`设置为`null`，表示该视图不再存在。
- en: '[PRE54]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: And with that change, our application is complete! You can take a look at the
    final result in the book’s source code (*[http://jsDataV.is/source/](http://jsDataV.is/source/)*).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，我们的应用程序就完成了！你可以在书籍的源代码中查看最终结果 (*[http://jsDataV.is/source/](http://jsDataV.is/source/)*)。
- en: Summing Up
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we completed a data-driven web application. First, we saw how
    Backbone.js gives us the flexibility to interact with REST APIs that don’t quite
    follow the normal conventions. Then we worked with a Backbone.js router to make
    sure our single-page application behaves like a full website so that our users
    can interact with it just as they would expect.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们完成了一个数据驱动的Web应用程序。首先，我们看到Backbone.js如何让我们灵活地与不完全遵循常规的REST API进行交互。接着，我们使用了Backbone.js路由器，确保我们的单页面应用像一个完整的网站一样运行，这样我们的用户可以像期望的那样与之交互。
