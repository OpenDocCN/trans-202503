- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PROGRAM
    STRUCTURE</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">程序结构</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '*with Aaron Ballman*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*与阿龙·巴尔曼合作*'
- en: '![](../images/opener.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Any real-world system is made up of multiple components, such as source files,
    headers, and libraries. Many contain resources including images, sounds, and configuration
    files. Composing a program from smaller logical components is good software engineering
    practice, because these components are easier to manage than a single large file.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 任何现实世界的系统都由多个组件构成，如源文件、头文件和库。许多组件包含资源，包括图像、声音和配置文件。从更小的逻辑组件组成程序是一种良好的软件工程实践，因为这些组件比一个单独的大文件更容易管理。
- en: In this chapter, you’ll learn how to structure your program into multiple units
    consisting of both source and include files. You’ll also learn how to link multiple
    object files together to create libraries and executable files.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何将程序结构化为多个单元，这些单元包含源文件和头文件。你还将学习如何将多个目标文件链接在一起，创建库和可执行文件。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Principles of Componentization</samp>
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">组件化原则</samp>
- en: Nothing prevents you from writing your entire program within the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function of a single source file. However, as the function grows, that approach
    will quickly become unmanageable. For this reason, it makes sense to decompose
    your program into a collection of components that exchange information across
    a shared boundary, or *interface*. Organizing source code into components makes
    it easier to understand and allows you to reuse the code elsewhere in the program,
    or even with other programs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么阻止你在单一源文件的< samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>函数中编写整个程序。然而，随着函数的增长，这种方法将迅速变得难以管理。因此，将程序分解为一组组件，通过共享边界或*接口*交换信息是有意义的。将源代码组织成组件使得它更易于理解，并允许你在程序的其他地方甚至与其他程序一起重用代码。
- en: Understanding how best to decompose a program typically requires experience.
    Many of the decisions programmers make are driven by performance. For example,
    you may need to minimize communication over a high-latency interface. Bad hardware
    can only go so far; you need bad software to really screw up performance.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 理解如何最佳地分解程序通常需要经验。程序员做出的许多决策都是由性能驱动的。例如，你可能需要最小化通过高延迟接口的通信。糟糕的硬件只能走这么远；你需要糟糕的软件才能真正破坏性能。
- en: Performance is only one software quality attribute (ISO/IEC 25000:2014) and
    must be balanced with maintainability, code readability, understandability, safety,
    and security. For example, you may design a client application to handle input
    field validation from the user interface to avoid a round trip to the server.
    This helps performance but can hurt security if inputs to the server are not validated.
    A simple solution is to validate inputs in both locations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 性能只是软件质量属性之一（ISO/IEC 25000:2014），必须与可维护性、代码可读性、可理解性、安全性和安全性平衡。例如，你可能会设计一个客户端应用程序来处理来自用户界面的输入字段验证，以避免到服务器的往返。这有助于性能，但如果服务器的输入没有验证，可能会危害安全性。一个简单的解决方案是在两个地方都验证输入。
- en: Developers frequently do strange things for illusionary gains. The strangest
    of these is invoking the undefined behavior of signed integer overflow to improve
    performance. Frequently, these local code optimizations have no impact on overall
    system performance and are considered *premature optimizations*. Donald Knuth,
    author of *The Art of Computer Programming* (Addison-Wesley, 1997), described
    premature optimization as “the root of all evil.”
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员常常做一些奇怪的事情来获得虚幻的收益。其中最奇怪的是通过调用有符号整数溢出的未定义行为来提高性能。通常，这些局部代码优化对整体系统性能没有影响，且被视为*过早的优化*。《计算机程序设计的艺术》（Addison-Wesley，1997）的作者**唐纳德·克努斯**将过早优化描述为“所有邪恶的根源”。
- en: In this section, we’ll cover some principles of component-based software engineering.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些基于组件的软件工程原则。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Coupling and Cohesion</samp>
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">耦合与内聚</samp>
- en: In addition to performance, the aim of a well-structured program is to achieve
    desirable properties like low coupling and high cohesion. *Cohesion* is a measure
    of the commonality between elements of a programming interface. Assume, for example,
    that a header exposes functions for calculating the length of a string, calculating
    the tangent of a given input value, and creating a thread. This header has low
    cohesion because the exposed functions are unrelated to each other. Conversely,
    a header that exposes functions to calculate the length of a string, concatenate
    two strings together, and search for a substring within a string has high cohesion
    because all the functionality is related. This way, if you need to work with strings,
    you need only to include the string header. Similarly, related functions and type
    definitions that form a public interface should be exposed by the same header
    to provide a highly cohesive interface of limited functionality. We’ll discuss
    public interfaces further in “Data Abstractions” on [page 215](#pg_215).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了性能外，一个结构良好的程序的目标是实现诸如低耦合和高内聚等理想特性。*内聚*是衡量编程接口各元素之间共同性的标准。例如，假设一个头文件暴露了计算字符串长度、计算给定输入值的正切和创建线程的函数。这个头文件的内聚性较低，因为暴露的函数彼此无关。相反，一个暴露了计算字符串长度、连接两个字符串以及在字符串中查找子字符串的函数的头文件则具有较高的内聚性，因为所有功能都是相关的。这样，如果你需要处理字符串，你只需包含字符串头文件。类似地，构成公共接口的相关函数和类型定义应由同一个头文件暴露，以提供一个高度内聚且功能有限的接口。我们将在《数据抽象》一章中进一步讨论公共接口，见[第215页](#pg_215)。
- en: '*Coupling* is a measure of the interdependency of programming interfaces. For
    example, a tightly coupled header can’t be included in a program by itself; instead,
    it must be included with other headers in a specific order. You may couple interfaces
    for a variety of reasons, such as a mutual reliance on data structures, interdependence
    between functions, or the use of a shared global state. But when interfaces are
    tightly coupled, modifying program behavior becomes difficult because changes
    can have a ripple effect across the system. You should always strive to have loose
    coupling between interface components, regardless of whether they’re members of
    a public interface or implementation details of the program.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*耦合*是衡量编程接口相互依赖程度的标准。例如，一个紧耦合的头文件不能单独被包含进程序中；相反，它必须与其他头文件按特定顺序一起包含。你可能因为多种原因将接口耦合在一起，比如共同依赖数据结构、函数之间的相互依赖或使用共享的全局状态。但当接口紧耦合时，修改程序行为变得困难，因为更改可能会对系统产生连锁反应。无论这些接口是公共接口的成员还是程序实现的细节，你都应始终力求保持接口组件之间的松耦合。'
- en: By separating your program logic into distinct, highly cohesive components,
    you make it easier to reason about the components and test the program (because
    you can verify the correctness of each component independently). The result is
    a more maintainable, less buggy system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将程序逻辑分离成不同的、高内聚的组件，你可以更容易地推理各个组件的行为并测试程序（因为你可以独立验证每个组件的正确性）。结果是一个更易于维护、错误更少的系统。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Code Reuse</samp>
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码重用</samp>
- en: '*Code reuse* is the practice of implementing functionality once and then reusing
    it in various parts of the program without duplicating the code. Code duplication
    can lead to subtly unexpected behavior, oversized and bloated executables, and
    increased maintenance costs. And anyway, why write the same code more than once?'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码重用*是一次性实现功能并在程序的不同部分重复使用，而不重复编写相同代码的做法。代码重复可能会导致微妙的意外行为、庞大臃肿的可执行文件以及增加维护成本。再说了，为什么要多次编写相同的代码呢？'
- en: '*Functions* are the lowest-level reusable units of functionality. Any logic
    that you might repeat more than once is a candidate for encapsulating in a function.
    If the functionality has only minor differences, you might be able to create a
    parameterized function that serves multiple purposes. Each function should perform
    work that isn’t duplicated by any other function. You can then compose individual
    functions to solve increasingly sophisticated problems.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*是最低级别的可重用功能单元。任何你可能会重复多次的逻辑，都可以考虑封装成一个函数。如果功能之间只有细微差别，你可能能够创建一个参数化的函数，来实现多个用途。每个函数应当执行其他函数未重复的工作。然后，你可以将单独的函数组合起来，解决越来越复杂的问题。'
- en: Packaging reusable logic into functions can improve maintainability and eliminate
    defects. For example, though you could determine the length of a null-terminated
    string by writing a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, it’s more maintainable to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>
    function from the C standard library. Because other programmers are already familiar
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function,
    they’ll have an easier time understanding what that function is doing than what
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is doing. Furthermore,
    if you reuse existing functionality, you’re less likely to introduce behavioral
    differences in ad hoc implementations, and you make it easier to globally replace
    the functionality with a better-performing algorithm or more secure implementation,
    for example.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将可重用的逻辑封装成函数可以提高可维护性并消除缺陷。例如，尽管你可以通过编写一个简单的 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环来确定一个以空字符结尾的字符串的长度，但使用 C 标准库中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>
    函数会更具可维护性。因为其他程序员已经熟悉 <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>
    函数，他们更容易理解该函数的作用，而不是理解 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环的作用。此外，如果你重用现有的功能，就不太可能在临时实现中引入行为差异，还可以更容易地用性能更高或更安全的算法或实现来全局替换功能。
- en: When designing functional interfaces, a balance must be struck between *generality*
    and *specificity*. An interface that’s specific to the current requirement may
    be lean and effective but hard to modify when requirements change. A general interface
    might allow for future requirements but be cumbersome for foreseeable needs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计功能接口时，必须在 *通用性* 和 *特定性* 之间找到平衡。一个特定于当前需求的接口可能非常简洁有效，但当需求变化时，修改起来会很困难。一个通用接口可能适应未来的需求，但对于可预见的需求来说可能会显得繁琐。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Data Abstractions</samp>
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">数据抽象</samp>
- en: A *data abstraction* is any reusable software component that enforces a clear
    separation between the abstraction’s public interface and the implementation details.
    The *public interface* for each data abstraction includes the data type definitions,
    function declarations, and constant definitions required by the users of the data
    abstraction and is placed in headers. The implementation details of how the data
    abstraction is coded, as well as any private utility functions, are hidden within
    source files or in headers that are in a separate location from the public interface
    headers. This separation of the public interface from the private implementation
    allows you to change the implementation details without breaking code that depends
    on your component.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据抽象* 是任何可重用的软件组件，它强制要求抽象的公共接口与实现细节之间有明确的分离。每个数据抽象的 *公共接口* 包括用户需要的类型定义、函数声明和常量定义，并放置在头文件中。数据抽象的实现细节，以及任何私有的辅助函数，都隐藏在源文件中或放在与公共接口头文件分开的地方。公共接口与私有实现的分离，使你可以在不破坏依赖于该组件的代码的情况下更改实现细节。'
- en: '*Header files* typically contain function declarations and type definitions
    for the component. For example, the C standard library <samp class="SANS_TheSansMonoCd_W5Regular_11"><string.h></samp>
    header provides the public interface for string-related functionality, while <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><threads.h></samp> provides utility functions
    for threading. This logical separation has low coupling and high cohesion, making
    it easier to access only the specific components you need and reduce compile time
    and the likelihood of name collisions. You don’t need to know anything about threading
    application programming interfaces (APIs), for example, if all you need is the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*头文件* 通常包含组件的函数声明和类型定义。例如，C 标准库的 <samp class="SANS_TheSansMonoCd_W5Regular_11"><string.h></samp>
    头文件提供了与字符串相关功能的公共接口，而 <samp class="SANS_TheSansMonoCd_W5Regular_11"><threads.h></samp>
    则提供了线程的实用函数。这样的逻辑分离具有低耦合性和高内聚性，使得你可以更容易地只访问所需的特定组件，减少编译时间和名称冲突的可能性。例如，如果你只需要 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> 函数，你不需要了解线程应用程序编程接口（API）的任何内容。'
- en: Another consideration is whether you should explicitly include the headers required
    by your header or require the users of the header to include them first. It’s
    a good idea for data abstractions to be self-contained and include the headers
    they use. Not doing so is a burden on the users of the abstraction and leaks implementation
    details about the data abstraction. Examples in this book don’t always follow
    this practice to keep these file listings concise.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个考虑因素是，是否应该显式包含你的头文件所需的头文件，还是要求头文件的使用者先自行包含它们。数据抽象最好是自包含的，并包括它们所使用的头文件。没有做到这一点会给抽象的使用者带来负担，并泄露关于数据抽象的实现细节。本书中的示例并不总是遵循这种做法，以保持文件列表的简洁。
- en: '*Source files* implement the functionality declared by a given header or the
    application-specific program logic used to perform whatever actions are needed
    for a given program. For example, if you have a *network.h* header that describes
    a public interface for network communications, you may have a *network.c* source
    file (or *network_win32.c* for Windows only and *network _linux.c* for Linux only)
    that implements the network communication logic.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*源文件*实现给定头文件声明的功能或执行特定程序所需的应用程序逻辑。例如，如果你有一个描述网络通信公共接口的*network.h*头文件，你可能会有一个*network.c*源文件（或者是*network_win32.c*用于仅Windows，*network_linux.c*用于仅Linux），它实现了网络通信逻辑。'
- en: It’s possible to share implementation details between two source files by using
    a header, but the header file should be placed in a distinct location from the
    public interface to prevent accidentally exposing implementation details.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用头文件在两个源文件之间共享实现细节，但头文件应放在与公共接口不同的位置，以防止无意中暴露实现细节。
- en: A *collection* is a good example of a data abstraction that separates the basic
    functionality from the implementation or underlying data structure. A collection
    groups data elements and supports operations such as adding elements to the collection,
    removing data elements from the collection, and checking whether the collection
    contains a specific data element.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*集合*是数据抽象的一个很好的例子，它将基本功能与实现或底层数据结构分离开来。集合将数据元素分组，并支持诸如向集合中添加元素、从集合中移除数据元素以及检查集合是否包含特定数据元素等操作。
- en: There are many ways to implement a collection. For example, a collection of
    data elements may be represented as a flat array, a binary tree, a directed (possibly
    acyclic) graph, or a different structure. The choice of data structure can impact
    an algorithm’s performance, depending on what kind of data you’re representing
    and how much data there is to represent. For example, a binary tree may be a better
    abstraction for a large amount of data that needs good lookup performance, whereas
    a flat array is likely a better abstraction for a small amount of data of fixed
    size. Separating the interface of the collection data abstraction from the implementation
    of the underlying data structure allows the implementation to change without requiring
    changes to code that relies on the collection interface.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实现集合的方式有很多种。例如，一个数据元素的集合可以表示为一个平坦数组、一个二叉树、一个有向（可能是无环的）图，或其他不同的结构。数据结构的选择会影响算法的性能，具体取决于你表示的数据类型以及需要表示的数据量。例如，对于需要良好查找性能的大量数据，二叉树可能是更好的抽象，而对于少量固定大小的数据，平坦数组可能是更好的抽象。将集合数据抽象的接口与底层数据结构的实现分离开来，可以使实现方式发生变化，而无需更改依赖于集合接口的代码。
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Opaque Types</samp>'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">不透明类型</samp>'
- en: Data abstractions are most effective when used with opaque data types that hide
    information. In C, *opaque* (or *private*) data types are those expressed using
    an incomplete type, such as a forward-declared structure type. An *incomplete
    type* is a type that describes an identifier but lacks information needed to determine
    the size of objects of that type or their layout. Hiding internal-only data structures
    discourages programmers who use the data abstraction from writing code that depends
    on implementation details, which may change. The incomplete type is exposed to
    users of the data abstraction, while the fully defined type is accessible only
    to the implementation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 数据抽象在与隐藏信息的不透明数据类型一起使用时最为有效。在C语言中，*不透明*（或*私有*）数据类型是通过不完整类型表示的，如前向声明的结构体类型。*不完整类型*是描述一个标识符但缺少必要信息以确定该类型对象的大小或布局的类型。隐藏仅供内部使用的数据结构可以防止使用数据抽象的程序员编写依赖于实现细节的代码，因为这些细节可能会发生变化。不完整类型对数据抽象的使用者是可见的，而完全定义的类型仅对实现者可访问。
- en: 'Say we want to implement a collection that supports a limited number of operations,
    such as adding an element, removing an element, and searching for an element.
    The following example implements <samp class="SANS_TheSansMonoCd_W5Regular_11">collection_type</samp>
    as an opaque type, hiding the implementation details of the data type from the
    library’s user. To accomplish this, we create two headers: an external *collection.h*
    header included by the user of the data type and an internal header included only
    in files that implement the functionality of the data type.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要实现一个支持有限操作的集合，比如添加元素、移除元素和搜索元素。以下示例将<сamp class="SANS_TheSansMonoCd_W5Regular_11">collection_type</samp>实现为不透明类型，隐藏数据类型的实现细节，使得库的使用者无法访问。为此，我们创建了两个头文件：一个外部*collection.h*头文件由数据类型的使用者包含，另一个内部头文件仅在实现数据类型功能的文件中包含。
- en: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">collection.h</samp>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">collection.h</samp>
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">collection_type</samp> identifier
    is aliased to <samp class="SANS_TheSansMonoCd_W5Regular_11">struct collection_type</samp>
    (an incomplete type). Consequently, functions in the public interface must accept
    a pointer to this type, instead of an actual value type, because of the constraints
    placed on the use of incomplete types in C.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">collection_type</samp>标识符被别名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct collection_type</samp>（一个不完整类型）。因此，公共接口中的函数必须接受指向此类型的指针，而不是实际的值类型，因为在C语言中使用不完整类型时有一定的限制。
- en: 'In the internal header, <samp class="SANS_TheSansMonoCd_W5Regular_11">struct
    collection_type</samp> is fully defined but not visible to a user of the data
    abstraction:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部头文件中，<samp class="SANS_TheSansMonoCd_W5Regular_11">struct collection_type</samp>是完全定义的，但对数据抽象的使用者不可见：
- en: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">collection_priv.h</samp>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">collection_priv.h</samp>
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Users of the data abstraction include only the external *collection.h* file,
    whereas modules that implement the abstract data type also include the internal
    definitions *collection_priv.h* file. This allows the implementation of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">collection_type</samp> data type to remain
    private.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 数据抽象的使用者仅包括外部*collection.h*文件，而实现抽象数据类型的模块还包括内部定义的*collection_priv.h*文件。这使得<samp
    class="SANS_TheSansMonoCd_W5Regular_11">collection_type</samp>数据类型的实现保持私密。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Executables</samp>
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">可执行文件</samp>
- en: In [Chapter 9](chapter9.xhtml), we learned that the compiler is a pipeline of
    translation phases and that the compiler’s ultimate output is object code. The
    last phase of translation, called the *link phase*, takes the object code for
    all the translation units in the program and links them together to form a final
    executable. This can be an executable that a user can run, such as *a.out* or
    *foo.exe*, a library, or a more specialized program such as a device driver or
    a firmware image (machine code to be burned onto read-only memory [ROM]). Linking
    allows you to separate your code into distinct source files that can be compiled
    independently, which helps to build reusable components.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](chapter9.xhtml)，我们学习了编译器是一个由多个翻译阶段组成的流水线，编译器的最终输出是目标代码。翻译的最后一个阶段，称为*链接阶段*，将程序中所有翻译单元的目标代码链接在一起，形成最终的可执行文件。这可以是一个用户可以运行的可执行文件，比如*a.out*或*foo.exe*，一个库，或者一个更专业的程序，如设备驱动程序或固件映像（要烧录到只读存储器[ROM]中的机器代码）。链接使你能够将代码分割成独立的源文件，这些源文件可以独立编译，有助于构建可重用的组件。
- en: '*Libraries* are executable components that cannot be executed independently.
    Instead, you incorporate libraries into executable programs. You can invoke the
    functionality of the library by including the library’s headers in your source
    code and calling the declared functions. The C standard library is an example
    of a library—you include the headers from the library, but you do not directly
    compile the source code that implements the library functionality. Instead, the
    implementation ships with a prebuilt version of the library code.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*库*是不能独立执行的可执行组件。相反，你需要将库集成到可执行程序中。你可以通过在源代码中包含库的头文件并调用已声明的函数来调用库的功能。C标准库就是一个库的例子——你包含来自库的头文件，但不会直接编译实现库功能的源代码。相反，库的实现随预构建版本的库代码一起提供。'
- en: Libraries allow you to build on the work of others for the generic components
    of a program so you can focus on developing the logic that is unique to your program.
    For example, when writing a video game, reusing existing libraries should allow
    you to focus on developing the game logic, not worrying about the details of retrieving
    user input, network communications, or graphics rendering. Libraries compiled
    with one compiler can often be used by programs built with a different compiler.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 库允许你在他人的工作基础上构建程序的通用组件，从而可以专注于开发你程序中独特的逻辑。例如，在编写视频游戏时，重用现有库应当能够让你专注于开发游戏逻辑，而无需担心用户输入、网络通信或图形渲染的细节。使用一个编译器编译的库通常可以被用在使用不同编译器构建的程序中。
- en: Libraries are linked into your application and can be either static or dynamic.
    A *static library*, also known as an *archive*, incorporates its machine or object
    code directly into the resulting executable, which means that a static library
    is often tied to a specific release of the program. Because a static library is
    incorporated at link time, the contents of the static library can be further optimized
    for your program’s use of the library. Library code used by the program can be
    made available for link-time optimizations (for example, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">-flto</samp>
    flag), while unused library code can be stripped from the final executable.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 库被链接到你的应用程序中，可以是静态的或动态的。*静态库*，也称为*归档文件*，将其机器码或目标代码直接合并到生成的可执行文件中，这意味着静态库通常与程序的特定版本绑定在一起。由于静态库在链接时被集成，因此静态库的内容可以针对程序使用该库进行进一步优化。程序使用的库代码可以用于链接时优化（例如，使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-flto</samp>标志），而未使用的库代码则可以从最终的可执行文件中剥离。
- en: A *dynamic library*, also referred to as a *shared library* or a *dynamic shared
    object*, is an executable without the startup routines. It can be packaged with
    the executable or installed separately but must be available when the executable
    calls a function provided by the dynamic library. Many modern operating systems
    will load the dynamic library code into memory once and share it across all the
    applications that need it. You can replace a dynamic library with different versions
    as necessary after your application has been deployed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态库*，也称为*共享库*或*动态共享对象*，是一个没有启动例程的可执行文件。它可以与可执行文件一起打包，或单独安装，但在可执行文件调用动态库提供的函数时必须可用。许多现代操作系统会将动态库的代码加载到内存中一次，并在所有需要它的应用程序之间共享。你可以在应用程序部署后，根据需要替换不同版本的动态库。'
- en: Letting the library evolve separately from the program comes with its own set
    of benefits and risks. A developer can correct bugs in the library after an application
    has already shipped without requiring the application to be recompiled, for instance.
    However, dynamic libraries provide the potential opportunity for a malicious attacker
    to replace a library with a nefarious one or an end user to accidentally use an
    incorrect version of the library. It’s also possible to make a *breaking change*
    in a new library release that results in an incompatibility with existing applications
    that use the library. Static libraries might execute somewhat faster because the
    object code (binary) is included in the executable file, enabling further optimizations.
    The benefits of using dynamic libraries usually outweigh the disadvantages.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让库与程序分开发展有其自身的优点和风险。例如，开发人员可以在应用程序已经发布后修复库中的bug，而无需重新编译应用程序。然而，动态库提供了潜在的机会，让恶意攻击者用恶意库替换库，或者最终用户意外使用错误版本的库。也有可能在新库发布时做出*破坏性更改*，导致与使用该库的现有应用程序不兼容。静态库的执行速度可能稍微更快，因为目标代码（可执行文件中的二进制代码）被包含在可执行文件中，从而实现进一步的优化。通常使用动态库的好处大于其缺点。
- en: Each library has one or more headers that contain the public interface to the
    library and one or more source files that implement the logic for the library.
    You can benefit from structuring your code as a collection of libraries even if
    the components aren’t turned into actual libraries. Using an actual library makes
    it harder to accidentally design a tightly coupled interface where one component
    has special knowledge of the internal details of another component.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个库都有一个或多个头文件，包含库的公共接口，以及一个或多个源文件，实现库的逻辑。即使组件没有被转化为实际的库，通过将代码结构化为库的集合，你也能从中受益。使用实际的库可以减少意外设计紧密耦合接口的可能性，因为在这种接口中，一个组件对另一个组件的内部细节有特殊了解。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Linkage</samp>
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">链接性</samp>
- en: '*Linkage* is a process that controls whether an interface is public or private
    and determines whether any two identifiers refer to the same entity. Ignoring
    macros and macro parameters that are replaced early in the translation phases,
    an *identifier* can denote a standard attribute, an attribute prefix, or an attribute
    name; an object; a function; a tag or a member of a structure, union, or enumeration;
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> name; or a label
    name.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*链接性*是一个过程，控制接口是公共的还是私有的，并决定是否有两个标识符指向相同的实体。忽略在翻译阶段早期替换的宏和宏参数，一个*标识符*可以表示一个标准属性、属性前缀或属性名称；一个对象；一个函数；结构体、联合体或枚举的标签或成员；一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>名称；或一个标签名称。'
- en: 'C provides three kinds of linkage: external, internal, or none. Each declaration
    of an identifier with *external linkage* refers to the same function or object
    everywhere in the program. Identifiers referring to declarations with internal
    linkage refer to the same entity only within the translation unit containing the
    declaration. If two translation units both refer to the same internal linkage
    identifier, they refer to different instances of the entity. If a declaration
    has *no linkage*, it’s a unique entity in each translation unit.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: C语言提供了三种链接性：外部链接性、内部链接性或无链接性。每个具有*外部链接性*的标识符声明在程序中的所有地方都指向相同的函数或对象。引用内部链接性声明的标识符仅在包含该声明的翻译单元内指向同一个实体。如果两个翻译单元都引用相同的内部链接性标识符，它们指向的是该实体的不同实例。如果声明没有*链接性*，它在每个翻译单元中都是一个唯一的实体。
- en: The linkage of a declaration is either explicitly declared or implied. If you
    declare an entity at file scope without explicitly specifying <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>, the entity is
    implicitly given external linkage. Identifiers that have no linkage include function
    parameters, block scope identifiers declared without an <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>
    storage class specifier, or enumeration constants.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 声明的链接性要么是显式声明的，要么是隐含的。如果你在文件作用域内声明一个实体，而没有显式指定<samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">static</samp>，则该实体会被隐式赋予外部链接性。没有链接性的标识符包括函数参数、没有使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>存储类说明符声明的块作用域标识符或枚举常量。
- en: '[Listing 10-1](chapter10.xhtml#Lis10-1) shows examples of declarations of each
    kind of linkage.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-1](chapter10.xhtml#Lis10-1) 显示了每种链接类型声明的示例。'
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-1: Examples of internal,
    external, and no linkage</samp>'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-1：内部链接、外部链接和无链接的示例</samp>
- en: If you explicitly declare an identifier with the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    storage class specifier at file scope, it has internal linkage. The <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    keyword gives internal linkage only to file scope entities. Declaring a variable
    at block scope as <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    creates an identifier with no linkage, but it does give the variable static storage
    duration. As a reminder, static storage duration means its lifetime is the entire
    execution of the program, and its stored value is initialized only once, prior
    to program startup. The different meanings of *static* when used in different
    contexts are obviously confusing and consequently a common interview question.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在文件作用域内显式声明一个标识符为 <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    存储类说明符，它将具有内部链接。<samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> 关键字仅对文件作用域的实体赋予内部链接。如果你在块作用域内将一个变量声明为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>，它将创建一个无链接的标识符，但它确实为该变量提供了静态存储持续时间。提醒一下，静态存储持续时间意味着它的生命周期是程序的整个执行过程，而且它的值只会初始化一次，在程序启动之前。*static*
    在不同上下文中的不同含义显然是令人困惑的，因此它常常成为面试中的一个常见问题。
- en: You can create an identifier with external linkage by declaring it with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> storage class specifier.
    This works only if you haven’t previously declared the linkage for that identifier.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> storage class
    specifier has no effect if a prior declaration gave the identifier linkage.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> 存储类说明符声明一个外部链接标识符。只有在你之前没有声明该标识符的链接时，这才有效。如果之前的声明已经为该标识符指定了链接，那么
    <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> 存储类说明符将不起作用。
- en: Declarations with conflicting linkage can lead to undefined behavior; see CERT
    C rule DCL36-C, “Do not declare an identifier with conflicting linkage classifications,”
    for more information.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 声明中有冲突的链接可能会导致未定义行为；有关更多信息，请参阅 CERT C 规则 DCL36-C，“不要声明具有冲突链接分类的标识符”。
- en: '[Listing 10-2](chapter10.xhtml#Lis10-2) shows sample declarations with implicit
    linkage.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-2](chapter10.xhtml#Lis10-2) 显示了带有隐式链接的示例声明。'
- en: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">foo.c</samp>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">foo.c</samp>
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-2: Examples of implicit
    linkage</samp>'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-2：隐式链接的示例</samp>
- en: '[Listing 10-3](chapter10.xhtml#Lis10-3) shows sample declarations with explicit
    linkage.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-3](chapter10.xhtml#Lis10-3) 显示了带有显式链接的示例声明。'
- en: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">bar.c</samp>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">bar.c</samp>
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-3: Examples of explicit
    linkage</samp>'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-3：显式链接的示例</samp>
- en: The identifiers in your public interface should have external linkage so that
    they can be called from outside their translation unit. Identifiers that are implementation
    details should be declared with internal or no linkage (provided they don’t need
    to be referenced from another translation unit). A common approach to achieving
    this is to declare your public interface functions in a header with or without
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> storage
    class specifier (the declarations implicitly have external linkage, but there
    is no harm in explicitly declaring them with <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>)
    and define the public interface functions in a source file in a similar manner.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你的公共接口中的标识符应该具有外部链接，以便可以从其翻译单元外部调用它们。作为实现细节的标识符应该使用内部链接或无链接进行声明（前提是它们不需要从另一个翻译单元中引用）。实现这一目标的常见方法是在头文件中声明公共接口函数，可以使用也可以不使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> 存储类说明符（这些声明默认具有外部链接，但明确声明它们为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> 也没有坏处），并以类似的方式在源文件中定义公共接口函数。
- en: However, within the source file, all declarations that are implementation details
    should be explicitly declared <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    to keep them private—accessible to just that source file. You can include the
    public interface declared within the header by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>
    preprocessor directive to access its interface from another file. A good rule
    of thumb is that file-scope entities that don’t need to be visible outside the
    file should be declared as <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>.
    This practice limits the global namespace pollution and decreases the chances
    of surprising interactions between translation units.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在源文件中，所有实现细节的声明应显式声明为<samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>，以保持它们的私有性——仅对该源文件可访问。你可以通过使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>预处理指令来包含头文件中声明的公共接口，从而访问另一个文件中的接口。一个好的经验法则是，不需要在文件外部可见的文件作用域实体应声明为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">static</samp>。这种做法有助于减少全局命名空间污染，并降低翻译单元之间发生意外交互的可能性。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Structuring a Simple Program</samp>
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">构建一个简单的程序</samp>
- en: 'To learn how to structure a complex, real-world program, let’s develop a simple
    program to determine whether a number is prime. A *prime number* (or a *prime*)
    is a natural number that cannot be formed by multiplying two smaller natural numbers.
    We’ll write two separate components: a static library containing the testing functionality
    and a command line application that provides a user interface for the library.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了学习如何构建一个复杂的真实世界程序，我们先开发一个简单的程序来判断一个数字是否为质数。*质数*（或称为*素数*）是一个自然数，不能通过将两个较小的自然数相乘得到。我们将编写两个独立的组件：一个包含测试功能的静态库和一个提供库用户界面的命令行应用程序。
- en: The *primetest* program accepts a whitespace-delimited list of integer values
    as input and then outputs whether each value is a prime number. If any of the
    inputs are invalid, the program will output a helpful message explaining how to
    use the interface.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*primetest*程序接受以空格分隔的整数值列表作为输入，然后输出每个值是否为质数。如果任何输入无效，程序将输出一条有用的消息，解释如何使用该界面。'
- en: Before exploring how to structure the program, let’s examine the user interface.
    First, we print the help text for the command line program, as shown in [Listing
    10-4](chapter10.xhtml#Lis10-4).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨如何构建程序之前，我们先来看看用户界面。首先，我们打印命令行程序的帮助文本，如[清单 10-4](chapter10.xhtml#Lis10-4)所示。
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-4: Printing help
    text</samp>'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-4：打印帮助文本</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">print_help</samp> function
    prints usage information about how to use the command to the standard output.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print_help</samp>函数将使用信息打印到标准输出，说明如何使用该命令。
- en: Next, because the command line arguments are passed to the program as textual
    input, we define a utility function to convert them to integer values, as shown
    in [Listing 10-5](chapter10.xhtml#Lis10-5).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，由于命令行参数以文本形式传递给程序，我们定义了一个实用函数，将它们转换为整数值，如[清单 10-5](chapter10.xhtml#Lis10-5)所示。
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-5: Converting a
    single command line argument</samp>'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-5：转换单个命令行参数</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_arg</samp> function
    accepts a string argument as input and uses an output parameter to report the
    converted argument. An *output parameter* returns a function result to the caller
    via a pointer, allowing multiple values to be returned in addition to the function
    return value. The function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    if the argument conversion succeeds and <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>
    if it fails. The <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_arg</samp>
    function uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">strtoull</samp>
    function to convert the string to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long long</samp> integer value and takes care to properly handle conversion errors.
    Additionally, because the definition of a prime number excludes 0, 1, and negative
    values, the <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_arg</samp> function
    treats those as invalid inputs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <`samp class="SANS_TheSansMonoCd_W5Regular_11">convert_arg</samp>`函数接受一个字符串参数作为输入，并使用输出参数报告转换后的结果。*输出参数*通过指针将函数结果返回给调用者，使得除了函数返回值外，还能返回多个值。若参数转换成功，函数返回<`samp
    class="SANS_TheSansMonoCd_W5Regular_11">true</samp>，如果失败则返回<`samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>。`convert_arg`函数使用<`samp
    class="SANS_TheSansMonoCd_W5Regular_11">strtoull</samp>`函数将字符串转换为<`samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long long</samp>整数值，并注意妥善处理转换错误。此外，由于质数的定义排除了0、1和负数，`convert_arg`函数会将这些视为无效输入。
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_arg</samp>
    utility function in the <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_cmd_line_args</samp>
    function, shown in [Listing 10-6](chapter10.xhtml#Lis10-6), which loops over all
    the command line arguments provided and attempts to convert each argument from
    a string to an integer.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[sample](chapter10.xhtml#Lis10-6)中使用了<`samp class="SANS_TheSansMonoCd_W5Regular_11">convert_arg</samp>`工具函数，这个函数位于<`samp
    class="SANS_TheSansMonoCd_W5Regular_11">convert_cmd_line_args</samp>`函数，主要作用是对所有提供的命令行参数进行循环，并尝试将每个参数从字符串转换为整数。
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-6: Processing all
    the command line arguments</samp>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-6：处理所有命令行参数</samp>
- en: If any argument fails to convert, it calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">print_help</samp>
    function to report the proper command line usage to the user and then returns
    a null pointer. This function is responsible for allocating a sufficiently large
    buffer to hold the array of integers. It also handles all error conditions, such
    as running out of memory or failing to convert an argument. If the function succeeds,
    it returns an array of integers to the caller and writes the converted number
    of arguments into the <samp class="SANS_TheSansMonoCd_W5Regular_11">num_args</samp>
    parameter. The returned array is allocated storage and must be deallocated when
    no longer needed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何一个参数无法转换，它会调用<`samp class="SANS_TheSansMonoCd_W5Regular_11">print_help</samp>`函数来向用户报告正确的命令行用法，并返回一个空指针。该函数负责分配一个足够大的缓冲区来存储整数数组。它还处理所有错误情况，比如内存不足或参数转换失败。如果函数成功，它会返回一个整数数组给调用者，并将转换后的参数个数写入<`samp
    class="SANS_TheSansMonoCd_W5Regular_11">num_args</samp>`参数。返回的数组是已分配的存储空间，当不再需要时必须进行释放。
- en: There are several ways to determine whether a number is prime. The naive approach
    is to test a value *N* by determining whether it is evenly divisible by [2..*N*
    – 1]. This approach has poor performance characteristics as the value of *N* gets
    larger. Instead, we’ll use one of the many algorithms designed for testing primality.
    [Listing 10-7](chapter10.xhtml#Lis10-7) shows a nondeterministic implementation
    of the Miller-Rabin primality test that’s suitable for quickly testing whether
    a value is probably prime (Schoof 2008). Please see the Schoof paper for an explanation
    of the mathematics behind the Miller-Rabin primality test algorithm.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以判断一个数字是否为质数。最直接的方法是通过测试一个值*N*，判断它是否能被[2..*N* – 1]整除。这种方法随着*N*值的增大，性能表现较差。相反，我们将使用一种为质数测试设计的算法。[清单10-7](chapter10.xhtml#Lis10-7)展示了Miller-Rabin质数测试的非确定性实现，适用于快速测试一个值是否可能是质数（Schoof
    2008）。请参阅Schoof的论文，了解Miller-Rabin质数测试算法背后的数学原理。
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-7: The Miller-Rabin
    primality test algorithm</samp>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-7：Miller-Rabin质数测试算法</samp>
- en: 'The interface to the Miller-Rabin primality test is the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_prime</samp>
    function shown in [Listing 10-8](chapter10.xhtml#Lis10-8). This function accepts
    two arguments: the number to test (<samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>)
    and the number of times to perform the test (<samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>).
    Larger values of <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp> provide
    a more accurate result but worsen performance. We’ll place the algorithm from
    [Listing 10-6](chapter10.xhtml#Lis10-6) in a static library, along with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">is_prime</samp> function, which will provide
    the library’s public interface.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Miller-Rabin 素性测试的接口是 [清单 10-8](chapter10.xhtml#Lis10-8) 中显示的 <samp class="SANS_TheSansMonoCd_W5Regular_11">is_prime</samp>
    函数。该函数接受两个参数：待测试的数字 (<samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>) 和执行测试的次数
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>)。较大的 <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>
    值提供更精确的结果，但会降低性能。我们将把 [清单 10-6](chapter10.xhtml#Lis10-6) 中的算法与 <samp class="SANS_TheSansMonoCd_W5Regular_11">is_prime</samp>
    函数一起放入静态库中，该库将提供公共接口。
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-8: The interface
    to the Miller-Rabin primality test algorithm</samp>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-8：Miller-Rabin 素性测试算法的接口</samp>
- en: Finally, we need to compose these utility functions into a program. [Listing
    10-9](chapter10.xhtml#Lis10-9) shows the implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function. It uses a fixed number of iterations of the Miller-Rabin test and reports
    whether the input values are probably prime or definitely not prime. It also handles
    deallocating the memory allocated by <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_cmd_line_args</samp>.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将这些工具函数组合成一个程序。[清单 10-9](chapter10.xhtml#Lis10-9) 展示了 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    函数的实现。它使用固定次数的 Miller-Rabin 测试，并报告输入值是可能是素数还是绝对不是素数。它还负责释放由 <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_cmd_line_args</samp>
    分配的内存。
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-9: The</samp> <samp
    class="I">main</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-9： </samp> <samp class="I">main</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function calls
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_cmd_line_args</samp>
    function to convert the command line arguments into an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long long</samp> integers. For each argument in this array, the program loops,
    calling <samp class="SANS_TheSansMonoCd_W5Regular_11">is_prime</samp> to determine
    whether each value is probably prime or not prime using the Miller-Rabin primality
    test implemented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_prime</samp>
    function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 函数调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_cmd_line_args</samp>
    函数，将命令行参数转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long long</samp>
    类型的整数数组。程序对该数组中的每个参数进行循环，调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">is_prime</samp>
    来判断每个值是可能是素数，还是根据 Miller-Rabin 素性测试判断为非素数。
- en: Now that we’ve implemented the program logic, we’ll produce the required build
    artifacts. Our goal is to produce a static library containing the Miller-Rabin
    implementation and a command line application driver.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了程序逻辑，我们将生成所需的构建产物。我们的目标是生成一个静态库，其中包含 Miller-Rabin 实现和一个命令行应用程序驱动程序。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Building the Code</samp>
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">构建代码</samp>
- en: Create a new file named *isprime.c* with the code from Listings 10-8 and 10-9
    (in that order), adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>
    directives for <samp class="SANS_TheSansMonoCd_W5Regular_11">"isprime.h"</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdlib.h></samp> at the top
    of the file. The quotes and angle brackets surrounding the headers are important
    for telling the preprocessor where to search for those files, as discussed in
    [Chapter 9](chapter9.xhtml). Next, create a header named *isprime.h* with the
    code from [Listing 10-10](chapter10.xhtml#Lis10-10) to provide the public interface
    for the static library, with a header guard.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为*isprime.c*的新文件，包含来自清单 10-8 和 10-9 的代码（按此顺序），并在文件顶部添加 <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>
    指令，分别为 <samp class="SANS_TheSansMonoCd_W5Regular_11">"isprime.h"</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><stdlib.h></samp>。引号和尖括号环绕头文件，对于告诉预处理器在哪里查找这些文件非常重要，正如[第9章](chapter9.xhtml)中讨论的那样。接下来，创建一个名为
    *isprime.h* 的头文件，包含来自[清单 10-10](chapter10.xhtml#Lis10-10)的代码，以提供静态库的公共接口，并添加头文件保护。
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-10: The public interface
    for the static library</samp>'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-10：静态库的公共接口</samp>
- en: 'Create a new file named *driver.c* with the code from Listings 10-5, 10-6,
    10-7, and 10-10 (in that order), adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>
    directives for the following: <samp class="SANS_TheSansMonoCd_W5Regular_11">"isprime.h"</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><assert.h></samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11"><errno.h></samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdio.h></samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdlib.h></samp> at the top
    of the file. All three files are in the same directory in our example, but in
    a real-world project, you would likely put the files in different directories,
    depending on the conventions of your build system. Create a local directory named
    *bin*, which is where the build artifacts from this example will be created.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 *driver.c* 的新文件，包含来自清单 10-5、10-6、10-7 和 10-10 的代码（按此顺序），并在文件顶部添加以下 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> 指令：<samp class="SANS_TheSansMonoCd_W5Regular_11">"isprime.h"</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><assert.h></samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11"><errno.h></samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11"><stdio.h></samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdlib.h></samp>。在我们的示例中，所有三个文件都在同一个目录中，但在实际项目中，您可能会根据构建系统的约定将文件放置在不同的目录中。创建一个名为
    *bin* 的本地目录，用于存放本示例的构建产物。
- en: 'We use Clang to create the static library and executable program, but both
    GCC and Clang support the command line arguments in the example, so either compiler
    will work. First, compile both C source files into object files placed in the
    *bin* directory:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Clang 来创建静态库和可执行程序，但 GCC 和 Clang 都支持示例中的命令行参数，因此两者的编译器都能使用。首先，将两个 C 源文件编译成目标文件，并将它们放置在
    *bin* 目录中：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For older compilers, it may be necessary to replace <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=c23</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=c2x</samp>.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于旧版编译器，可能需要将 <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=c23</samp>
    替换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=c2x</samp>。
- en: If you execute the command and get an error such as
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行命令时出现错误，例如
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: then create the local *bin* directory and try the command again. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp>
    flag instructs the compiler to compile the source into an object file without
    invoking the linker to produce executable output. We’ll need the object files
    to create a library. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-o</samp>
    flag specifies the pathname of the output file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建本地 *bin* 目录，并再次尝试该命令。<samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp>
    标志指示编译器将源代码编译为目标文件，而不调用链接器生成可执行输出。我们需要目标文件来创建库。<samp class="SANS_TheSansMonoCd_W5Regular_11">-o</samp>
    标志指定输出文件的路径名。
- en: 'After executing the commands, the *bin* directory should contain two object
    files: *isprime.o* and *driver.o*. These files contain the object code for each
    translation unit. You could link them together directly to create the executable
    program. However, in this case, we’ll make a static library. To do this, execute
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ar</samp> command to generate
    the static library named *libPrimalityUtilities.a* in the *bin* directory:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令后，*bin*目录应包含两个对象文件：*isprime.o*和*driver.o*。这些文件包含每个翻译单元的对象代码。您可以将它们直接链接在一起，生成可执行程序。然而，在这种情况下，我们将创建一个静态库。为此，执行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ar</samp>命令，在*bin*目录中生成名为*libPrimalityUtilities.a*的静态库：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp> option instructs
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ar</samp> command to replace
    any existing files in the archive with the new files, the <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    option creates the archive, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    option writes an object-file index into the archive (which is equivalent to running
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ranlib</samp> command). This
    creates a single archive file that’s structured to allow retrieval of the original
    object files used to create the archive, like a compressed tarball or ZIP file.
    By convention, static libraries on Unix systems are prefixed with *lib* and have
    a *.a* file extension.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>选项指示<samp class="SANS_TheSansMonoCd_W5Regular_11">ar</samp>命令用新文件替换档案中现有的文件，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">c</samp>选项创建档案，<samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>选项将对象文件索引写入档案（这等同于运行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ranlib</samp>命令）。这将创建一个单一的档案文件，其结构允许检索用于创建档案的原始对象文件，就像一个压缩的tarball或ZIP文件。根据约定，Unix系统上的静态库以*lib*为前缀，文件扩展名为*.a*。
- en: 'You can now link the driver object file to the *libPrimalityUtilities.a* static
    library to produce an executable named *primetest*. This can be accomplished either
    by invoking the compiler without the <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp>
    flag, which invokes the default system linker with the appropriate arguments,
    or by invoking the linker directly. Invoke the compiler to use the default system
    linker as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将驱动程序对象文件链接到*libPrimalityUtilities.a*静态库，以生成名为*primetest*的可执行文件。您可以通过不带<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-c</samp>标志来调用编译器，这样会调用默认系统链接器并传递适当的参数，或者直接调用链接器来完成。通过以下方式调用编译器，使用默认系统链接器：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-L</samp> flag instructs the
    linker to look in the local *bin* directory for libraries to link, and the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-l</samp> flag instructs the linker to
    link the *libPrimalityUtilities.a* library to the output. Omit the *lib* prefix
    and the *.a* suffix from the command line argument because the linker adds them
    implicitly. For example, to link against the *libm* math library, specify <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-lm</samp> as the link target. As with
    compiling source files, the output of the linked files is specified by the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-o</samp> flag.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-L</samp>标志指示链接器在本地*bin*目录中查找要链接的库，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-l</samp>标志指示链接器将*libPrimalityUtilities.a*库链接到输出中。在命令行参数中省略*lib*前缀和*.a*后缀，因为链接器会自动添加它们。例如，要链接*libm*数学库，指定<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-lm</samp>作为链接目标。与编译源文件一样，链接文件的输出由<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-o</samp>标志指定。
- en: You can now test the program to see whether values are probably prime or definitely
    not prime. Be sure to try out cases like negative numbers, known prime and nonprime
    numbers, and incorrect input, as shown in [Listing 10-11](chapter10.xhtml#Lis10-11).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以测试程序，看它是否能判断值是可能为素数还是绝对不是素数。一定要尝试负数、已知的素数和非素数，以及不正确的输入，具体请参见[Listing 10-11](chapter10.xhtml#Lis10-11)。
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-11: Running the</samp>
    <samp class="SANS_Futura_Std_Book_11">primetest</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">program
    with sample input</samp>'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-11：使用示例输入运行</samp>
    <samp class="SANS_Futura_Std_Book_11">primetest</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">程序</samp>
- en: The number 8,675,309 is prime.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 数字8,675,309是素数。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter, you learned about the benefits of loose coupling, high cohesion,
    data abstractions, and code reuse. Additionally, you learned about related language
    constructs such as opaque data types and linkage. You were introduced to some
    best practices on how to structure the code in your projects and saw an example
    of building a simple program with different types of executable components. These
    skills are important as you transition from writing practice programs to developing
    and deploying real-world systems.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了松散耦合、高内聚、数据抽象和代码重用的好处。此外，你还学习了相关的语言构造，如不透明数据类型和链接。你了解了一些关于如何在项目中组织代码的最佳实践，并看到了一个通过不同类型的可执行组件构建简单程序的示例。这些技能在你从编写练习程序转向开发和部署现实世界的系统时非常重要。
- en: In the next chapter, we’ll learn how to use various tools and techniques to
    create high-quality systems, including assertions, debugging, testing, and static
    and dynamic analysis. These skills are all necessary to develop safe, secure,
    and performant modern systems.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用各种工具和技术来创建高质量的系统，包括断言、调试、测试，以及静态和动态分析。这些技能都是开发安全、可靠和高效的现代系统所必需的。
