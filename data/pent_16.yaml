- en: Chapter 12. Bypassing Antivirus Applications
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 12 章. 绕过防病毒应用程序
- en: Your pentesting clients will most likely be running some sort of antivirus solution.
    So far in this book we’ve avoided having any of our malicious executables deleted
    by antivirus applications, but antivirus program avoidance is a constantly changing
    field. Typically you will be more likely to avoid detection by using a memory-corruption
    exploit and loading your payload directly into memory—that is, by never touching
    the disk. That said, with the attack landscape shifting to emphasize client-side
    and social-engineering attacks, it may not always be possible to avoid writing
    your payload to disk. In this chapter we’ll look at a few techniques for obscuring
    our malware to try to avoid detection when the payload is written to the disk.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你的渗透测试客户很可能会使用某种防病毒解决方案。到目前为止，本书中的恶意可执行文件没有被防病毒应用程序删除，但防病毒程序规避是一个不断变化的领域。通常，你通过使用内存损坏漏洞并直接将负载加载到内存中——也就是说，永不触及磁盘——更有可能避免被检测到。话虽如此，随着攻击领域的转变，越来越强调客户端和社会工程学攻击，可能并非总能避免将负载写入磁盘。在本章中，我们将研究几种方法，尝试在将负载写入磁盘时隐藏我们的恶意软件，以避免被检测到。
- en: Trojans
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 木马
- en: In [Chapter 4](ch04.xhtml "Chapter 4. Using the Metasploit Framework"), we created
    a standalone malicious executable that runs a Metasploit payload. Though we may
    be able to use social engineering to trick a user into downloading and running
    our malicious file, the lack of any functionality other than our executable’s
    payload could tip off users that something is amiss. We’d be much more likely
    to evade detection if we could hide our payload inside of some legitimate program
    that would run normally, with our payload running in the background. Such a program
    is called a *trojan*, after the legendary wooden horse that ended the Trojan War.
    The horse appeared to be an innocuous offering to the gods and was brought inside
    the previously impenetrable walled city of Troy, with enemy soldiers hiding inside,
    ready to attack.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 4 章](ch04.xhtml "第 4 章. 使用 Metasploit 框架")中，我们创建了一个独立的恶意可执行文件，运行 Metasploit
    负载。尽管我们可能通过社会工程学手段欺骗用户下载并运行我们的恶意文件，但除了执行文件的负载外没有任何其他功能，可能会让用户意识到有异常。如果我们能够将负载隐藏在一个正常运行的合法程序中，并让负载在后台运行，我们将更有可能避开检测。这种程序被称为*木马*，它源自传说中的木马，结束了特洛伊战争。木马看似是一个无害的贡品，被带入曾经固若金汤的特洛伊城墙内，敌军士兵藏身其中，准备发起攻击。
- en: 'We encountered a trojan in [Chapter 8](ch08.xhtml "Chapter 8. Exploitation"):
    The Vsftpd server on our Ubuntu target had a backdoor that could be triggered
    at login by entering a smiley face as part of the username. Attackers compromised
    the source code repositories for Vsftpd and added additional trojan functionality
    to the program. Anyone who downloaded Vsftpd from the official repositories between
    the initial compromise and detection ended up with a trojaned version.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](ch08.xhtml "第 8 章. 利用")中，我们遇到了一个木马：我们 Ubuntu 目标机上的 Vsftpd 服务器有一个后门，可以通过在用户名中输入一个笑脸符号来触发登录。攻击者侵入了
    Vsftpd 的源代码仓库，并在程序中加入了额外的木马功能。从初次被攻破到被发现之间，任何从官方仓库下载 Vsftpd 的人都会得到一个被木马化的版本。
- en: Msfvenom
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Msfvenom
- en: Although reverse-engineering binaries or gaining access to source code and manually
    adding trojan code is beyond the scope of this book, the Msfvenom tool has some
    options we can use to embed a Metasploit payload inside a legitimate binary. [Example 12-1](ch12.xhtml#msfvenom_help_page
    "Example 12-1. Msfvenom help page") shows some important options we have not encountered
    previously in the text.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管反向工程二进制文件或获取源代码并手动添加木马代码超出了本书的范围，但 Msfvenom 工具有一些选项，我们可以用它将 Metasploit 负载嵌入到合法的二进制文件中。[示例
    12-1](ch12.xhtml#msfvenom_help_page "示例 12-1. Msfvenom 帮助页面")展示了我们在之前的内容中未曾遇到的一些重要选项。
- en: Example 12-1. Msfvenom help page
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-1. Msfvenom 帮助页面
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In particular, the `-x` flag ❶ allows us to use an executable file as a template
    in which to embed our chosen payload. However, though the resulting executable
    will look like the original one, the added payload will pause the execution of
    the original, and we shouldn’t expect a user to run an executable that appears
    to hang at startup very many times. Luckily, Msfvenom’s `-k` flag ❷ will keep
    the executable template intact and run our payload in a new thread, allowing the
    original executable to run normally.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，`-x` 标志 ❶ 允许我们使用可执行文件作为模板，在其中嵌入我们选择的有效负载。然而，尽管生成的可执行文件看起来与原始文件相似，添加的有效负载将暂停原始程序的执行，我们不应期望用户在启动时遇到看似挂起的可执行文件会多次运行。幸运的是，Msfvenom
    的 `-k` 标志 ❷ 将保持可执行模板的完整性，并在新线程中运行我们的有效负载，从而允许原始可执行文件正常运行。
- en: Let’s use the `-x` and `-k` flags to build a trojaned Windows executable that
    will appear normal to a user but which will send us a Meterpreter session in the
    background. To do so, we choose the payload with the `-p` flag and set the relevant
    payload options as in [Chapter 4](ch04.xhtml "Chapter 4. Using the Metasploit
    Framework"). Any legitimate executable will do; you’ll find some useful Windows
    binaries for pentesting in Kali Linux at */usr/share/windows-binaries*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `-x` 和 `-k` 标志构建一个被植入木马的 Windows 可执行文件，它对用户看起来是正常的，但将在后台向我们发送一个 Meterpreter
    会话。为此，我们使用 `-p` 标志选择有效负载，并按照 [第 4 章](ch04.xhtml "第 4 章. 使用 Metasploit 框架")中的说明设置相关的有效负载选项。任何合法的可执行文件都可以使用；你可以在
    Kali Linux 的 */usr/share/windows-binaries* 中找到一些有用的 Windows 二进制文件用于渗透测试。
- en: 'To embed our payload inside the *radmin.exe* binary enter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要将有效负载嵌入到 *radmin.exe* 二进制文件中，输入：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our Msfvenom command specifies the payload to generate with the `-p` option.
    We set the `LHOST` option to the IP address of Kali, the system to call back to
    when the payload runs. We can also set the `LPORT` option. As discussed in this
    section, the `-x` option selects an executable in which to embed our payload.
    The `-k` option runs the payload in a separate thread. The `-f` flag tells Msfvenom
    to build the payload in the executable format. Once created, run the trojaned
    binary on either the Windows XP or Windows 7 target. The Radmin Viewer program
    should appear to run normally ([Figure 12-1](ch12.xhtml#trojaned_radmin_viewer_executable
    "Figure 12-1. Trojaned Radmin Viewer executable")), but the embedded payload should
    give us a Meterpreter session if we set up a handler using the *multi/handler*
    module.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Msfvenom 命令使用 `-p` 选项指定生成的有效负载。我们将 `LHOST` 选项设置为 Kali 的 IP 地址，这是有效负载运行时回调的系统。我们还可以设置
    `LPORT` 选项。如本节所讨论，`-x` 选项选择一个可执行文件作为有效负载的嵌入目标。`-k` 选项将在独立线程中运行有效负载。`-f` 标志告诉 Msfvenom
    将有效负载构建为可执行格式。一旦创建完成，在 Windows XP 或 Windows 7 目标上运行这个被植入木马的二进制文件。Radmin Viewer
    程序应该看起来正常运行（[图 12-1](ch12.xhtml#trojaned_radmin_viewer_executable "图 12-1. 被植入木马的
    Radmin Viewer 可执行文件")），但嵌入的有效负载应该为我们提供一个 Meterpreter 会话，前提是我们使用 *multi/handler*
    模块设置了处理程序。
- en: '![Trojaned Radmin Viewer executable](httpatomoreillycomsourcenostarchimages2030404.png.jpg)Figure 12-1. Trojaned
    Radmin Viewer executableChecking for Trojans with the MD5 Hash'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![被植入木马的 Radmin Viewer 可执行文件](httpatomoreillycomsourcenostarchimages2030404.png.jpg)图
    12-1. 被植入木马的 Radmin Viewer 可执行文件 检查 MD5 哈希以查找木马'
- en: Our trojaned binary should convince the average user that the program is legitimate.
    Security-savvy users should verify the integrity of a downloaded file before running
    it by checking its MD5 hash against the value published by the vendor, where available.
    An MD5 hash is a kind of file fingerprint; if changes are made to the file, the
    MD5 hash will change.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的木马二进制文件应该能够让普通用户相信该程序是合法的。具有安全意识的用户应该在运行下载的文件之前，通过检查其 MD5 哈希值与供应商发布的值进行验证文件的完整性，前提是供应商提供了该值。MD5
    哈希是一种文件指纹；如果文件发生更改，MD5 哈希也会随之变化。
- en: Let’s compare the MD5 hashes of the original *radmin.exe* with our trojaned
    version. In Kali Linux, the `md5sum` program will calculate a file’s MD5 hash.
    Run `md5sum` on both binaries, and you’ll find that the hash values are dramatically
    different, as you can see here at ❶ and ❷.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较原始的 *radmin.exe* 与我们被植入木马的版本的 MD5 哈希值。在 Kali Linux 中，`md5sum` 程序将计算文件的
    MD5 哈希值。对两个二进制文件运行 `md5sum`，你会发现它们的哈希值有显著差异，如 ❶ 和 ❷ 所示。
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: However, the MD5 hashing algorithm is not perfect, and a tampered binary could
    have the same MD5 hash as the original file, which is known as an *MD5 collision
    attack*. For this reason, many vendors publish a Secure Hash Algorithm (SHA) hash
    as well.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，MD5 哈希算法并不完美，经过篡改的二进制文件可能与原始文件具有相同的 MD5 哈希值，这被称为 *MD5 碰撞攻击*。因此，许多供应商也会发布一个安全哈希算法（SHA）哈希值。
- en: Of course, checking two separate hash values is better than checking one. The
    SHA family contains multiple hashing algorithms, and the version used will vary
    among vendors. Kali comes with programs for various SHA hashes. For example, `sha512sum`
    calculates the 64-bit block size SHA-2 hash, as shown here.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，检查两个独立的哈希值比检查一个要好。SHA家族包含多种哈希算法，所使用的版本会因厂商而异。Kali自带多种SHA哈希计算工具。例如，`sha512sum`计算64位块大小的SHA-2哈希，如下所示。
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When installing software, be sure to calculate the hash(es) of your downloaded
    version, and compare it to the value(s) published by the vendor.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装软件时，务必计算您下载版本的哈希值，并与厂商发布的值进行比较。
- en: How Antivirus Applications Work
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 杀毒应用程序的工作原理
- en: Before we try different techniques to get our Metasploit payloads past an antivirus
    program, let’s discuss how these programs work. Most antivirus solutions start
    by comparing potentially dangerous code to a set of patterns and rules that make
    up the *antivirus definitions*, which match known malicious code. Antivirus definitions
    are updated regularly as new malware is identified by each vendor. This sort of
    identification is called *static analysis*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试不同的技术将Metasploit有效载荷绕过杀毒程序之前，让我们讨论一下这些程序是如何工作的。大多数杀毒解决方案首先通过将潜在的危险代码与组成*杀毒定义*的一组模式和规则进行比较，来匹配已知的恶意代码。杀毒定义会随着每个厂商识别到新的恶意软件而定期更新。这种识别方式称为*静态分析*。
- en: In addition to static analysis against a set of signatures, more advanced antivirus
    solutions also test for malicious activity, called *dynamic analysis*. For example,
    a program that tries to replace every file on the hard drive or connects to a
    known botnet command and control server every 30 seconds is exhibiting potentially
    malicious activity and may be flagged.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基于签名集的静态分析外，更多高级的杀毒解决方案还会进行恶意活动的检测，称为*动态分析*。例如，一个尝试替换硬盘上所有文件，或每30秒连接到已知的僵尸网络指挥与控制服务器的程序，正在表现出潜在的恶意活动，并可能被标记。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some antivirus products, such as Google’s Bouncer, run new apps that are uploaded
    to the Google Play store and pass static analysis in an isolated sandbox to try
    to detect malicious activity that doesn’t have a known malicious signature.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一些杀毒产品，如Google的Bouncer，会在上传到Google Play商店并通过静态分析的新应用程序中，在隔离的沙盒中运行，以尝试检测没有已知恶意签名的恶意活动。
- en: Microsoft Security Essentials
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微软安全防护软件
- en: As we use different methods in this section to bring down our detection rate,
    keep in mind that even if you not able to get a 0 percent detection rate among
    all antivirus vendors, if you know which antivirus solution is deployed in your
    client’s environment, you can focus your efforts on clearing just that antivirus
    program. In this chapter, we will try to bypass Microsoft Security Essentials
    using various methods.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用不同的方法降低检测率，请记住，即使您未能在所有杀毒厂商中获得0%的检测率，如果您知道客户端环境中部署的是哪种杀毒解决方案，您可以集中精力清除该特定杀毒程序。在本章中，我们将尝试使用各种方法绕过微软安全防护软件。
- en: When we created our Windows 7 target in [Chapter 1](ch01.xhtml "Chapter 1. Setting
    Up Your Virtual Lab"), we installed Microsoft Security Essentials, but we didn’t
    turn on real-time protection to scan files as they are downloaded or installed.
    Now let’s turn on this protection to see if we can create an undetectable trojan.
    Open Microsoft Security Essentials, select the **Settings** tab, choose **Real-time
    protection**, and check the box to turn on the service, as shown in [Figure 12-2](ch12.xhtml#microsoft_security_essentials_real-time
    "Figure 12-2. Microsoft Security Essentials real-time protection"). Click **Save
    changes**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml "第1章 设置虚拟实验室")中创建我们的Windows 7目标时，我们安装了微软安全防护软件，但我们没有开启实时保护功能以扫描下载或安装的文件。现在让我们开启此保护功能，看看是否能创建一个无法被检测到的木马。打开微软安全防护软件，选择**设置**标签，选择**实时保护**，勾选框以开启此服务，如[图12-2](ch12.xhtml#microsoft_security_essentials_real-time
    "图12-2 微软安全防护软件实时保护")所示。点击**保存更改**。
- en: '![Microsoft Security Essentials real-time protection](httpatomoreillycomsourcenostarchimages2030406.png.jpg)Figure 12-2. Microsoft
    Security Essentials real-time protection'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![微软安全防护软件实时保护](httpatomoreillycomsourcenostarchimages2030406.png.jpg)图12-2
    微软安全防护软件实时保护'
- en: As of this writing, even free antivirus solutions like Microsoft Security Essentials
    do a good job of catching Metasploit payloads. For a real test, try installing
    the trojaned *radmin.exe* with real-time protection turned on. You should see
    a pop-up at the bottom-right corner of the screen, like the one shown in [Figure 12-3](ch12.xhtml#malicious_software_detected
    "Figure 12-3. Malicious software detected"). The file is automatically deleted
    before the user can run it—that certainly puts a damper on things.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，即使是免费的防病毒解决方案，如Microsoft Security Essentials，也能有效地捕捉到Metasploit有效载荷。为了进行真实测试，尝试在开启实时保护的情况下安装木马程序*radmin.exe*。您应该会在屏幕右下角看到一个弹出窗口，如[图12-3](ch12.xhtml#malicious_software_detected
    "图12-3. 检测到恶意软件")中所示。该文件会在用户运行之前被自动删除——这无疑会影响事情的进展。
- en: '![Malicious software detected](httpatomoreillycomsourcenostarchimages2030408.png.jpg)Figure 12-3. Malicious
    software detected'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![检测到恶意软件](httpatomoreillycomsourcenostarchimages2030408.png.jpg)图12-3. 检测到恶意软件'
- en: VirusTotal
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VirusTotal
- en: One way to see which antivirus solutions will flag a program as malicious is
    to upload the file in question to the VirusTotal website (*[https://www.virustotal.com/](https://www.virustotal.com/)*).
    As of this writing, VirusTotal scans uploaded files with 51 antivirus programs
    and reports which ones detect malware. VirusTotal is shown in [Figure 12-4](ch12.xhtml#virustotal-id00034
    "Figure 12-4. VirusTotal").
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 查看哪些防病毒解决方案会将某个程序标记为恶意的一种方法是将该文件上传到VirusTotal网站（*[https://www.virustotal.com/](https://www.virustotal.com/)*）。截至目前，VirusTotal使用51个防病毒程序扫描上传的文件，并报告哪些程序检测到恶意软件。VirusTotal在[图12-4](ch12.xhtml#virustotal-id00034
    "图12-4. VirusTotal")中展示。
- en: '![VirusTotal](httpatomoreillycomsourcenostarchimages2030410.png.jpg)Figure 12-4. VirusTotal'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![VirusTotal](httpatomoreillycomsourcenostarchimages2030410.png.jpg)图12-4.
    VirusTotal'
- en: To see which antivirus programs detect our trojaned *radmin.exe* as currently
    written, upload the file to VirusTotal and click **Scan it!**. Because antivirus
    definitions are constantly updated, your results will differ, but as you can see
    in [Figure 12-5](ch12.xhtml#trojaned_binary_antivirus_detection "Figure 12-5. Trojaned
    binary antivirus detection"), 25 of 51 scanners detected our file as malicious.
    (The bottom of the page shows which scanners detected the malware.)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看哪些防病毒程序将我们目前编写的木马程序*radmin.exe*检测为恶意文件，可以将文件上传到VirusTotal并点击**扫描它！**。由于防病毒定义不断更新，您的结果可能会有所不同，但正如在[图12-5](ch12.xhtml#trojaned_binary_antivirus_detection
    "图12-5. 木马二进制防病毒检测")中所示，51个扫描器中有25个检测到我们的文件为恶意文件。（页面底部显示了哪些扫描器检测到恶意软件。）
- en: '![Trojaned binary antivirus detection](httpatomoreillycomsourcenostarchimages2030412.png.jpg)Figure 12-5. Trojaned
    binary antivirus detection'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![木马二进制防病毒检测](httpatomoreillycomsourcenostarchimages2030412.png.jpg)图12-5.
    木马二进制防病毒检测'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: VirusTotal shares uploaded binaries with antivirus vendors so they can write
    signatures to match. Antivirus companies use VirusTotal signatures to improve
    their detection engines, so anything you upload to the site may be caught by antivirus
    software just because you uploaded it. To avoid that risk, you can install the
    antivirus product on a virtual machine and test your trojans manually against
    it, as we did in the previous section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: VirusTotal与防病毒厂商共享上传的二进制文件，以便他们编写匹配的签名。防病毒公司利用VirusTotal的签名来改进其检测引擎，因此您上传到该网站的任何文件可能仅仅因为您上传了它就被防病毒软件检测到。为了避免这个风险，您可以在虚拟机上安装防病毒产品，并像我们在上一节中所做的那样手动测试您的木马。
- en: Getting Past an Antivirus Program
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绕过防病毒程序
- en: Clearly if we want to get past antivirus solutions, we need to try harder to
    hide. Let’s look at some other useful ways to hide our Metasploit payloads besides
    simply placing them inside of an executable.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，如果我们想要绕过防病毒解决方案，我们需要更加努力地隐藏。除了将有效载荷直接放入可执行文件中，我们还可以尝试一些其他有用的方法来隐藏我们的Metasploit有效载荷。
- en: Encoding
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编码
- en: Encoders are tools that allow you to avoid characters in an exploit that would
    break it. (You’ll learn more about these requirements when we write our own exploits
    in [Chapter 16](ch16.xhtml "Chapter 16. A Stack-Based Buffer Overflow in Linux")
    through [Chapter 19](ch19.xhtml "Chapter 19. Fuzzing, Porting Exploits, and Metasploit
    Modules").) At the time of this writing, Metasploit supports 32 encoders. Encoders
    mangle the payload and prepend decoding instructions to be executed in order to
    decode the payload before it is run. It is a common misperception that Metasploit’s
    encoders were designed to help bypass antivirus programs. Some Metasploit encoders
    create polymorphic code, or mutating code, which ensures that the encoded payload
    looks different each time the payload is generated. This process makes it more
    difficult for antivirus vendors to create signatures for the payload, but as we
    will see, it is not enough to bypass most antivirus solutions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 编码器是一些工具，可以帮助你避免在漏洞利用中出现会破坏漏洞利用的字符。（当我们在[第16章](ch16.xhtml "第16章：Linux中的基于栈的缓冲区溢出")到[第19章](ch19.xhtml
    "第19章：模糊测试、漏洞移植和Metasploit模块")编写自己的漏洞利用时，你会了解更多这些要求。）在撰写本文时，Metasploit支持32种编码器。编码器会破坏有效载荷并添加解码指令，确保在执行之前解码有效载荷。普遍的误解是，Metasploit的编码器是为了帮助绕过杀毒软件而设计的。某些Metasploit编码器会生成多态代码或变异代码，确保每次生成的编码有效载荷看起来都不同。这个过程使得杀毒软件厂商更难为有效载荷创建签名，但正如我们将看到的，它不足以绕过大多数杀毒解决方案。
- en: To list all of the encoders available in Msfvenom, use the **`-l encoders`**
    option, as shown in [Example 12-2](ch12.xhtml#msfvenom_encoders "Example 12-2. Msfvenom
    encoders").
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出Msfvenom中所有可用的编码器，请使用**`-l encoders`**选项，正如[示例12-2](ch12.xhtml#msfvenom_encoders
    "示例12-2：Msfvenom编码器")所示。
- en: Example 12-2. Msfvenom encoders
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 示例12-2：Msfvenom编码器
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The only encoder with an excellent rank is *x86/shikata_ga_nai* ❶. *Shikata
    Ga Nai* is Japanese for “It can’t be helped.” Encoder rankings are based on the
    entropy level of the output. With *shikata_ga_nai*, even the decoder stub is polymorphic.
    The nitty-gritty details of how this encoder works are beyond the scope of this
    book, but suffice it to say that it mangles payloads beyond easy recognition.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一一个排名优秀的编码器是* x86/shikata_ga_nai * ❶。*Shikata Ga Nai*是日语，意思是“无能为力”。编码器的排名基于输出的熵值。使用*shikata_ga_nai*时，即使解码器的存根也是多态的。这个编码器如何工作的细节超出了本书的范围，但可以简要地说，它会将有效载荷破坏到难以识别的程度。
- en: Tell Msfvenom to use the *shikata_ga_nai* encoder with the `-e` flag, as shown
    in [Example 12-3](ch12.xhtml#creating_an_encoded_executable_with_msfv "Example 12-3. Creating
    an encoded executable with Msfvenom"). Additionally, for further obfuscation,
    we’ll run our payload through an encoder multiple times, encoding the output from
    the previous round with the `-i` flag and specifying the number of encoding rounds
    (10 in this case).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉Msfvenom使用*shikata_ga_nai*编码器，并使用`-e`标志，正如[示例12-3](ch12.xhtml#creating_an_encoded_executable_with_msfv
    "示例12-3：使用Msfvenom创建编码的可执行文件")所示。此外，为了进一步混淆，我们将通过多个编码器运行有效载荷，每一轮都使用`-i`标志对前一轮的输出进行编码，并指定编码轮数（此例为10轮）。
- en: Example 12-3. Creating an encoded executable with Msfvenom
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 示例12-3：使用Msfvenom创建编码的可执行文件
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now upload the resulting binary to VirusTotal. As you can see in [Figure 12-6](ch12.xhtml#virustotal_results_for_an_encoded_binary
    "Figure 12-6. VirusTotal results for an encoded binary"), 35 of the tested antivirus
    products detected our payload, even with the encoding. That’s a higher detection
    rate than we found when embedding our payload inside a prebuilt executable. In
    other words, *shikata_ga_nai* alone doesn’t do the trick.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将生成的二进制文件上传到VirusTotal。正如你在[图12-6](ch12.xhtml#virustotal_results_for_an_encoded_binary
    "图12-6：VirusTotal对编码二进制文件的检测结果")中看到的，35款测试过的杀毒软件检测到了我们的有效载荷，即使它已经经过编码。与我们将有效载荷嵌入到预构建可执行文件中的检测率相比，这个检测率更高。换句话说，*shikata_ga_nai*单独使用并不能解决问题。
- en: '![VirusTotal results for an encoded binary](httpatomoreillycomsourcenostarchimages2030414.png.jpg)Figure 12-6. VirusTotal
    results for an encoded binary'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![VirusTotal对编码二进制文件的检测结果](httpatomoreillycomsourcenostarchimages2030414.png.jpg)图12-6：VirusTotal对编码二进制文件的检测结果'
- en: To see if we can improve our results, we can try experimenting with using multiple
    Metasploit encoders on our payload. For example, we can combine multiple rounds
    of *shikata_ga_nai* with another Metasploit encoder, *x86/bloxor*, as shown in
    [Example 12-4](ch12.xhtml#multiencoding_with_msfvenom "Example 12-4. Multiencoding
    with Msfvenom").
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看是否可以改进我们的结果，我们可以尝试使用多个Metasploit编码器对有效载荷进行实验。例如，我们可以将多轮*shikata_ga_nai*与另一个Metasploit编码器*x86/bloxor*结合使用，正如[示例12-4](ch12.xhtml#multiencoding_with_msfvenom
    "示例12-4：使用Msfvenom进行多重编码")所示。
- en: Example 12-4. Multiencoding with Msfvenom
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 示例12-4. 使用Msfvenom进行多重编码
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This time, we start out with Msfvenom using the *windows/meterpreter/reverse_tcp*
    payload as usual and encode it with *shikata_ga_nai*, as in the previous example.
    However, instead of setting the format to *.exe*, we output in raw format ❶. Also,
    instead of outputting the results to an *.exe* file as we did previously, this
    time we output the raw bytes into a *.bin* file ❷.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们像之前一样使用Msfvenom，选择*windows/meterpreter/reverse_tcp*有效载荷并使用*shikata_ga_nai*进行编码。然而，与之前设置格式为*.exe*不同，这次我们输出为原始格式❶。另外，这次我们不是将结果输出到*.exe*文件中，而是将原始字节输出到*.bin*文件❷中。
- en: 'Now we take the results of the *shikata_ga_nai* encoding and encode it with
    the *x86/bloxor* encoder. Our syntax for Msfvenom will differ from what we are
    used to. First, we set the payload to null with the option `-p -` ❸. And, because
    we are not setting a payload, we need to tack on two new options to tell Msfvenom
    how to encode our input: `-a x86` ❹ to specify the architecture as 32 bit, and
    `--platform windows` ❺ to specify the Windows platform. Finally, at the end of
    the Msfvenom command, we use the `<` symbol to pipe the *.bin* file from the previous
    command as input into Msfvenom ❻. The resulting executable will be encoded with
    *shikata_ga_nai* and *x86/bloxor*.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用*shikata_ga_nai*编码器的结果，并用*x86/bloxor*编码器进行编码。我们在使用Msfvenom时的语法与我们通常使用的有所不同。首先，我们通过选项`-p
    -` ❸将有效载荷设置为null。并且，由于我们没有设置有效载荷，我们需要附加两个新选项，告诉Msfvenom如何编码我们的输入：`-a x86` ❹指定架构为32位，`--platform
    windows` ❺指定平台为Windows。最后，在Msfvenom命令的末尾，我们使用`<`符号将前一个命令的*.bin*文件作为输入管道传入Msfvenom
    ❻。生成的可执行文件将使用*shikata_ga_nai*和*x86/bloxor*编码。
- en: The resulting executable is detected by 33 antivirus programs on VirusTotal
    as of this writing—slightly better than *shikata_ga_nai* by itself. You may be
    able to improve your results by experimenting with different sets of encoders
    and chaining more than two encoders together, or by combining techniques. For
    example, what if we both embed our payload in a binary and encode it with *shikata_ga_nai*
    as shown here?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的可执行文件在VirusTotal上的33个杀毒程序中被检测到——比单独使用*shikata_ga_nai*稍微好一些。你可能可以通过尝试不同的编码器组合，或将多个编码器连接在一起，或者通过结合不同技术来改善你的结果。例如，如果我们将有效载荷嵌入二进制文件并像这里展示的那样用*shikata_ga_nai*进行编码，结果会怎么样呢？
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This gave only a slight improvement: The payload was detected by 21 antivirus
    programs. And, unfortunately, Microsoft Security Essentials flagged both executables
    as malicious, as shown in [Figure 12-7](ch12.xhtml#microsoft_is_still_flagging_this_binary
    "Figure 12-7. Microsoft is still flagging this binary as malicious."). We need
    to look beyond Metasploit encoders if we’re going to get past antivirus detection
    on our Windows 7 target.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这只带来了轻微的改进：有效载荷被21个杀毒程序检测到。不幸的是，Microsoft Security Essentials将这两个可执行文件都标记为恶意，如[图12-7](ch12.xhtml#microsoft_is_still_flagging_this_binary
    "图12-7. Microsoft仍然将此二进制文件标记为恶意")所示。如果我们要绕过杀毒软件检测，我们需要超越Metasploit编码器，去看更多的解决方案，尤其是针对Windows
    7目标。
- en: '![Microsoft is still flagging this binary as malicious.](httpatomoreillycomsourcenostarchimages2030416.png.jpg)Figure 12-7. Microsoft
    is still flagging this binary as malicious.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![Microsoft仍然将此二进制文件标记为恶意。](httpatomoreillycomsourcenostarchimages2030416.png.jpg)图12-7.
    Microsoft仍然将此二进制文件标记为恶意。'
- en: Custom Cross Compiling
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义交叉编译
- en: As the de facto standard for penetration testing, Metasploit gets a fair amount
    of attention from antivirus vendors who make detecting the signatures for payloads
    generated by Msfvenom a priority. When Msfvenom creates an executable, it uses
    prebuilt templates that antivirus vendors can use to build detection signatures.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为渗透测试的事实标准，Metasploit吸引了相当多的杀毒软件厂商的关注，他们将为Msfvenom生成的有效载荷创建检测特征作为优先任务。当Msfvenom创建可执行文件时，它使用预构建的模板，这些模板可以被杀毒软件厂商用来构建检测特征。
- en: Perhaps we can improve our ability to bypass antivirus solutions by compiling
    an executable ourselves using raw shellcode. Let’s start with a simple C template,
    as shown in [Example 12-5](ch12.xhtml#custom_executable_template "Example 12-5. Custom
    executable template"). (We discussed the basics of C programming in [Chapter 3](ch03.xhtml
    "Chapter 3. Programming"). Review that section if this program doesn’t make sense
    to you.) Save this code to a file called *custommeterpreter.c*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 或许我们可以通过自己编译一个可执行文件来提高绕过杀毒软件的能力，使用原始shellcode。让我们从一个简单的C模板开始，如[示例12-5](ch12.xhtml#custom_executable_template
    "示例12-5. 自定义可执行文件模板")所示。（我们在[第3章](ch03.xhtml "第3章. 编程")中讨论了C编程的基础。如果这个程序对你来说没有意义，请回顾那一节。）将此代码保存到一个名为*custommeterpreter.c*的文件中。
- en: Example 12-5. Custom executable template
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 示例12-5. 自定义可执行文件模板
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We need to fill in data for the variables `random` ❶ and `shellcode` ❷, which
    are both unsigned character arrays. Our hope is that adding some randomness and
    compiling our own C code will be enough to trick antivirus programs. The `random`
    variable will introduce some randomness to the template. The `shellcode` variable
    will hold the raw hexadecimal bytes of the payload we create with Msfvenom. The
    `main` function ❸ runs when our compiled C program starts and executes our shellcode.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为`random`❶和`shellcode`❷变量填充数据，这两个变量都是无符号字符数组。我们的目标是，通过添加一些随机性并编译我们自己的C代码，足以欺骗防病毒程序。`random`变量将为模板引入一些随机性。`shellcode`变量将保存我们使用Msfvenom创建的有效负载的原始十六进制字节。`main`函数❸将在我们编译的C程序启动时运行，并执行我们的shellcode。
- en: Create your payload in Msfvenom as usual, except this time set the format with
    the `-f` flag to `c`, as shown in [Example 12-6](ch12.xhtml#creating_a_raw_payload_in_c_format
    "Example 12-6. Creating a raw payload in C format"). This will create hex bytes
    that we can drop into our C file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样在Msfvenom中创建有效负载，但这次使用`-f`标志将格式设置为`c`，如[示例12-6](ch12.xhtml#creating_a_raw_payload_in_c_format
    "示例12-6. 创建C格式的原始有效负载")所示。这将生成我们可以放入C文件中的十六进制字节。
- en: Example 12-6. Creating a raw payload in C format
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 示例12-6. 创建C格式的原始有效负载
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finally, we need to add some randomness. A good place to find randomness on
    a Linux system is in the */dev/urandom* file. This file is specifically designed
    as a pseudorandom number generator; it generates data using entropy in the Linux
    system.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要加入一些随机性。在Linux系统中，找到随机性的好地方是*/dev/urandom*文件。这个文件是专门设计为伪随机数生成器，利用Linux系统中的熵来生成数据。
- en: But if we just `cat` out data from */dev/urandom*, we’ll get a lot of unprintable
    characters. To get the proper data for a character array, we’ll use the `tr` Linux
    utility to translate the */dev/urandom* data to printable characters. Use `tr
    -dc A-Z-a-z-0-9`, and then pipe the commands into the `head` command to output
    only the first 512 characters from */dev/urandom*, as shown here.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们仅仅使用`cat`命令输出*/dev/urandom*的数据，我们会得到大量不可打印的字符。为了获得适合字符数组的数据，我们将使用Linux的`tr`工具将*/dev/urandom*的数据转换为可打印字符。使用`tr
    -dc A-Z-a-z-0-9`，然后将命令传递给`head`命令，以仅输出来自*/dev/urandom*的前512个字符，如下所示。
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now drop the data from */dev/urandom* into the `random` variable in the C file.
    The finished file is shown in [Example 12-7](ch12.xhtml#finished_custom_c_file
    "Example 12-7. Finished custom C file"). (Of course, your randomness and encoded
    payload will differ.) Be sure to surround the string with quotes and use a semicolon
    (`;`) at the end.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将来自*/dev/urandom*的数据放入C文件中的`random`变量。完成的文件请参见[示例12-7](ch12.xhtml#finished_custom_c_file
    "示例12-7. 完成的自定义C文件")。（当然，你的随机数据和编码的有效负载会有所不同。）确保将字符串用引号括起来，并在末尾加上分号(`;`)。
- en: Example 12-7. Finished custom C file
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 示例12-7. 完成的自定义C文件
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now we need to compile the C program. We can’t use the built-in GCC program
    because it would compile our program to run on Linux systems, and we want to run
    it on a 32-bit Windows system. Instead, we’ll use the Mingw32 cross compiler from
    the Kali Linux repositories, which we installed in [Chapter 1](ch01.xhtml "Chapter 1. Setting
    Up Your Virtual Lab"). If you haven’t already installed it, install it with **`apt-get
    install mingw32`**, and then compile your custom C file with **`i586-mingw32msvc-gcc`**.
    (Other than the program name, the syntax for using the cross compiler is the same
    as for Linux’s built-in GCC, discussed in [Chapter 3](ch03.xhtml "Chapter 3. Programming").)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要编译C程序。我们不能使用内置的GCC程序，因为它会将程序编译成适用于Linux系统的格式，而我们需要在32位Windows系统上运行。相反，我们将使用Kali
    Linux仓库中的Mingw32交叉编译器，这是我们在[第1章](ch01.xhtml "第1章. 设置虚拟实验室")中安装的。如果你还没有安装，使用**`apt-get
    install mingw32`**进行安装，然后使用**`i586-mingw32msvc-gcc`**编译自定义C文件。（除了程序名称，使用交叉编译器的语法与Linux内置的GCC相同，后者在[第3章](ch03.xhtml
    "第3章. 编程")中讨论过。）
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now upload the resulting executable to VirusTotal. As of this writing, 18 antivirus
    products detected the malicious file. That’s an improvement, but Microsoft Security
    Essentials is still catching our file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将生成的可执行文件上传到VirusTotal。截至目前，18款防病毒产品已检测到该恶意文件。这是一个进步，但Microsoft Security Essentials仍然能够捕捉到我们的文件。
- en: We still need to work a little harder to get a malicious executable onto our
    Windows 7 system. (You could have better success with this technique with another
    cross compiler from another repository.)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要更加努力，才能将恶意可执行文件传送到我们的Windows 7系统上。（你可能会通过使用来自其他仓库的另一个交叉编译器获得更好的成功率。）
- en: Encrypting Executables with Hyperion
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Hyperion 加密可执行文件
- en: Another way to obfuscate our payload is to encrypt it. One executable encrypter
    is Hyperion, which uses Advanced Execution Standard (AES) encryption, a current
    industry standard. After encrypting the executable, Hyperion throws away the encryption
    keys. When the executable runs, it brute-forces the encryption key to decrypt
    itself back to the original executable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆有效负载的另一种方法是对其进行加密。一个可用的可执行文件加密工具是 Hyperion，它使用先进的执行标准（AES）加密，这是当前的行业标准。加密可执行文件后，Hyperion
    会丢弃加密密钥。当可执行文件运行时，它会暴力破解加密密钥，将自己解密回原始可执行文件。
- en: If you have any background in cryptography, this process should raise a lot
    of red flags. AES is currently considered a secure encryption standard. If the
    executable doesn’t have access to the encryption key, it should not be able to
    brute-force the key in any reasonable amount of time, certainly not fast enough
    for our program to run in the time window of our pentest. What’s going on?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有加密学方面的背景，整个过程应该引起你很多的警觉。AES 目前被认为是一个安全的加密标准。如果可执行文件无法访问加密密钥，它不应该能够在合理的时间内暴力破解密钥，肯定无法在我们的渗透测试时间窗口内快速破解。那是怎么回事？
- en: As it turns out, Hyperion greatly reduces the possible keyspace for the encryption
    key, which means that binaries encrypted with it shouldn’t be considered cryptographically
    secure. However, because our goal and the goal of the Hyperion authors is to obfuscate
    the code to bypass antivirus detection, the fact that the key can be brute-forced
    is not a problem.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，Hyperion 大大缩小了加密密钥的可能键空间，这意味着用它加密的二进制文件不应该被认为是密码学上安全的。然而，由于我们的目标和 Hyperion
    作者的目标是混淆代码以绕过防病毒检测，因此密钥可以被暴力破解这一点并不是问题。
- en: Let’s start by using Hyperion to encrypt at simple Meterpreter executable with
    no additional antivirus avoidance techniques, as shown in [Example 12-8](ch12.xhtml#running_hyperion
    "Example 12-8. Running Hyperion"). (We installed Hyperion in [Chapter 1](ch01.xhtml
    "Chapter 1. Setting Up Your Virtual Lab")).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用 Hyperion 对一个简单的 Meterpreter 可执行文件进行加密，且不使用任何额外的防病毒规避技术，如 [示例 12-8](ch12.xhtml#running_hyperion
    "示例 12-8. 运行 Hyperion") 所示。（我们在 [第 1 章](ch01.xhtml "第 1 章. 设置你的虚拟实验室") 中安装了 Hyperion。）
- en: Example 12-8. Running Hyperion
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-8。运行 Hyperion
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Hyperion was written to run on Windows systems, but we can run it on Kali Linux
    with the Wine program, as you can see in [Example 12-8](ch12.xhtml#running_hyperion
    "Example 12-8. Running Hyperion"). Be sure to change into the Hyperion directory
    created when you unzipped the source before running *hyperion.exe* with Wine.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Hyperion 是为 Windows 系统编写的，但我们可以通过 Wine 程序在 Kali Linux 上运行它，正如 [示例 12-8](ch12.xhtml#running_hyperion
    "示例 12-8. 运行 Hyperion") 所示。在运行 *hyperion.exe* 之前，请确保切换到解压源代码时创建的 Hyperion 目录。
- en: 'Hyperion takes two arguments: the name of the file to encrypt and the name
    of the encrypted output file. Run Hyperion to encrypt the simple Meterpreter executable
    as shown at ❶. The resulting file is in the Hyperion 1.0 directory, so upload
    it to VirusTotal from there.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Hyperion 接受两个参数：要加密的文件名和加密后的输出文件名。运行 Hyperion 对简单的 Meterpreter 可执行文件进行加密，如 ❶
    所示。生成的文件位于 Hyperion 1.0 目录中，因此可以从那里上传到 VirusTotal。
- en: Using just a Meterpreter executable generated with Msfvenom (with no encoding,
    custom templates, or anything else) and encrypting it with Hyperion resulted in
    27 antivirus programs in VirusTotal detecting the malicious behavior. That’s not
    our lowest detection rate yet, but we have finally achieved our goal. As shown
    in [Figure 12-8](ch12.xhtml#microsoft_security_essentials_does_not_d "Figure 12-8. Microsoft
    Security Essentials does not detect malware."), Microsoft Security Essentials
    did not detect any malicious activity!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用通过 Msfvenom 生成的 Meterpreter 可执行文件（没有编码、没有自定义模板或其他任何东西），并使用 Hyperion 加密，结果是
    VirusTotal 中的 27 个防病毒程序检测到恶意行为。这还不是我们最低的检测率，但我们终于达到了目标。如 [图 12-8](ch12.xhtml#microsoft_security_essentials_does_not_d
    "图 12-8. Microsoft Security Essentials 无法检测恶意软件") 所示，Microsoft Security Essentials
    没有检测到任何恶意活动！
- en: '![Microsoft Security Essentials does not detect malware.](httpatomoreillycomsourcenostarchimages2030418.png.jpg)Figure 12-8. Microsoft
    Security Essentials does not detect malware.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![Microsoft Security Essentials 无法检测恶意软件。](httpatomoreillycomsourcenostarchimages2030418.png.jpg)图
    12-8。Microsoft Security Essentials 无法检测恶意软件。'
- en: Sure enough, we can download and run the Hyperion-encrypted executable on the
    Windows 7 system with antivirus protection and get a Meterpreter session. We haven’t
    achieved a 0 percent detection rate—the holy grail for antivirus bypass researchers—but
    we have been able to meet our pentest goals.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，我们可以在安装了杀毒软件的 Windows 7 系统上下载并运行 Hyperion 加密的可执行文件，并成功获得 Meterpreter 会话。我们还没有达到
    0% 检测率——这是杀毒软件绕过研究者的“圣杯”——但我们已经能够实现我们的渗透测试目标。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To lower our detection rate even more, try combining Hyperion encryption with
    other techniques from this section. For example, using Hyperion with a custom
    template dropped my detection number down to 14.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步降低检测率，可以尝试将 Hyperion 加密与本节中的其他技术结合使用。例如，使用 Hyperion 和自定义模板将我的检测率降至 14。
- en: Evading Antivirus with Veil-Evasion
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Veil-Evasion 绕过杀毒软件
- en: Even though we have successfully reached our goal of bypassing Microsoft Security
    Essentials on Windows 7, the antivirus landscape changes rapidly, so it is worthwhile
    to keep abreast of the latest tools and techniques. Veil-Evasion is a Python framework
    that automates creating antivirus-evading payloads, giving users the choice of
    multiple techniques. We covered installing Veil-Evasion on Kali Linux in [Chapter 1](ch01.xhtml
    "Chapter 1. Setting Up Your Virtual Lab"); refer back if you need a refresher.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们已经成功实现了绕过 Windows 7 上的 Microsoft Security Essentials 的目标，杀毒软件的格局变化迅速，因此，保持对最新工具和技术的关注是值得的。Veil-Evasion
    是一个 Python 框架，自动创建绕过杀毒软件的有效载荷，为用户提供多种技术选择。我们在 [第 1 章](ch01.xhtml "第 1 章. 设置虚拟实验室")中介绍了如何在
    Kali Linux 上安装 Veil-Evasion；如果需要复习，请参考该章节。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As updates are made to Veil-Evasion, your version may be different from what
    is shown here.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Veil-Evasion 更新，你的版本可能与这里显示的不同。
- en: Python Shellcode Injection with Windows APIs
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Windows API 的 Python Shellcode 注入
- en: Previously we looked at using a custom C template to compile and execute shellcode.
    We can do something similar with Python’s Ctypes library, which gives us access
    to Windows API function calls and can create C-compatible data types. We can use
    Ctypes to access the Windows API VirtualAlloc, which creates a new executable
    memory region for the shellcode and locks the memory region in physical memory,
    to avoid a page fault as shellcode is copied in and executed. `RtlMoveMemory`
    is used to copy the shellcode bytes into the memory region created by VirtualAlloc.
    The `CreateThread` API creates a new thread to run the shellcode, and finally,
    `WaitForSingleObject` waits until the created thread is finished and our shellcode
    has finished running.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看过使用自定义 C 模板来编译和执行 shellcode。我们可以使用 Python 的 Ctypes 库来做类似的事情，它让我们能够访问 Windows
    API 函数调用，并且可以创建与 C 兼容的数据类型。我们可以使用 Ctypes 访问 Windows API 的 VirtualAlloc，它为 shellcode
    创建一个新的可执行内存区域，并将该内存区域锁定在物理内存中，以避免 shellcode 被复制并执行时发生页面错误。`RtlMoveMemory` 用于将
    shellcode 字节复制到 VirtualAlloc 创建的内存区域中。`CreateThread` API 创建一个新线程来运行 shellcode，最后，`WaitForSingleObject`
    会等待直到新线程完成并且我们的 shellcode 执行完毕。
- en: These steps collectively are referred to as the *VirtualAlloc injection method*.
    This method, of course, would give us a Python script rather than a Windows executable,
    but you can use multiple tools to convert a Python script into a stand-alone executable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤合起来被称为 *VirtualAlloc 注入方法*。当然，这种方法会给我们一个 Python 脚本，而不是 Windows 可执行文件，但你可以使用多种工具将
    Python 脚本转换为独立的可执行文件。
- en: Creating Encrypted Python-Generated Executables with Veil-Evasion
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Veil-Evasion 创建加密的 Python 生成的可执行文件
- en: One of the methods implemented in Veil-Evasion uses the Python injection technique
    described earlier. To provide further antivirus protection, Veil-Evasion can use
    encryption. For our example, we will use Python VirtualAlloc injection combined
    with AES encryption, as we did in the Hyperion example earlier in this chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Veil-Evasion 中实现的方法之一使用了前面描述的 Python 注入技术。为了进一步提高抗病毒保护，Veil-Evasion 可以使用加密。对于我们的示例，我们将使用结合了
    AES 加密的 Python VirtualAlloc 注入，就像我们在本章前面的 Hyperion 示例中所做的一样。
- en: To start Veil-Evasion, change directories to *Veil-Evasion-master* and run *./Veil-Evasion.py*.
    You should be presented with a menu-based prompt similar to those we saw in SET
    in the previous chapter, as shown in [Example 12-9](ch12.xhtml#running_veil "Example 12-9. Running
    Veil").
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动 Veil-Evasion，切换到 *Veil-Evasion-master* 目录并运行 *./Veil-Evasion.py*。你将看到一个基于菜单的提示，类似于我们在上一章的
    SET 中看到的提示，如 [示例 12-9](ch12.xhtml#running_veil "示例 12-9. 运行 Veil") 所示。
- en: Example 12-9. Running Veil
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-9. 运行 Veil
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To see all the available payloads in Veil-Evasion, enter **`list`** at the prompt,
    as shown in [Example 12-10](ch12.xhtml#veil-evasion_payloads "Example 12-10. Veil-Evasion
    payloads").
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Veil-Evasion 中所有可用的有效载荷，请在提示符下输入**`list`**，如[示例 12-10](ch12.xhtml#veil-evasion_payloads
    "示例 12-10. Veil-Evasion 有效载荷")所示。
- en: Example 12-10. Veil-Evasion payloads
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-10. Veil-Evasion 有效载荷
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As of this writing, there are 28 ways to create executables implemented in Veil-Evasion.
    For this example, choose option 23 ❶ to use the VirtualAlloc injection method
    and encrypt it with AES encryption. Once you choose a method, Veil-Evasion will
    prompt you to change the method options from the default, if desired, as shown
    in [Example 12-11](ch12.xhtml#using_python_virtualalloc_in_veil-evasio "Example 12-11. Using
    Python VirtualAlloc in Veil-Evasion").
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，Veil-Evasion 已经实现了 28 种创建可执行文件的方法。对于本示例，选择第 23 种方法 ❶，使用 VirtualAlloc 注入方法并采用
    AES 加密。一旦选择了方法，Veil-Evasion 会提示您是否更改方法选项，默认情况下，如[示例 12-11](ch12.xhtml#using_python_virtualalloc_in_veil-evasio
    "示例 12-11. 在 Veil-Evasion 中使用 Python VirtualAlloc")所示。
- en: Example 12-11. Using Python VirtualAlloc in Veil-Evasion
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-11. 在 Veil-Evasion 中使用 Python VirtualAlloc
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By default, this payload will compile the Python script into an executable ❶
    using `VirtualAlloc()` as the injection method ❷. These options are correct for
    our example, so enter **`generate`** at the prompt. You are then prompted for
    details about the shellcode, as shown in [Example 12-12](ch12.xhtml#generating_the_executable_in_veil-evasio
    "Example 12-12. Generating the executable in Veil-Evasion").
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，该有效载荷将使用 `VirtualAlloc()` 作为注入方法，将 Python 脚本编译成可执行文件 ❶。这些选项对于我们的示例是正确的，因此在提示符下输入**`generate`**。然后，系统会提示您输入关于
    shellcode 的详细信息，如[示例 12-12](ch12.xhtml#generating_the_executable_in_veil-evasio
    "示例 12-12. 在 Veil-Evasion 中生成可执行文件")所示。
- en: Example 12-12. Generating the executable in Veil-Evasion
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-12. 在 Veil-Evasion 中生成可执行文件
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Veil-Evasion prompts you to select either Msfvenom to generate the shellcode
    or to provide custom shellcode. For our purposes, choose Msfvenom. The default
    payload is *windows/meterpreter/reverse_tcp*, so press enter to select it. You
    should be prompted for the usual options, `LHOST` and `LPORT`, and for a filename
    for the generated executable. Finally, Veil-Evasion offers two Python to executable
    methods. Choose the default, `Pyinstaller`, to have Veil-Evasion generate the
    malicious executable and save it to the *veil-output/compiled* directory.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Veil-Evasion 会提示您选择使用 Msfvenom 生成 shellcode，或提供自定义的 shellcode。为了我们的目的，选择 Msfvenom。默认有效载荷是*windows/meterpreter/reverse_tcp*，按回车键选择它。然后，系统会提示您输入常规选项，如`LHOST`和`LPORT`，并为生成的可执行文件指定文件名。最后，Veil-Evasion
    提供两种将 Python 转换为可执行文件的方法。选择默认的`Pyinstaller`，让 Veil-Evasion 生成恶意可执行文件并保存到*veil-output/compiled*目录。
- en: As of this writing, the resulting executable sails right past Microsoft Security
    Essentials on our Windows 7 box. Veil-Evasion notes that you shouldn’t upload
    the resulting executable to online scanners, so at the author’s request we’ll
    forgo checking this example with VirusTotal. However, we can install other antivirus
    solutions besides Microsoft Security Essentials to see if the executable is flagged.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，我们在 Windows 7 系统中测试的可执行文件可以轻松通过 Microsoft Security Essentials 的检测。Veil-Evasion
    提醒您不要将生成的可执行文件上传到在线扫描器，因此应作者的请求，我们将跳过使用 VirusTotal 检查此示例。然而，我们可以安装其他防病毒解决方案，除了
    Microsoft Security Essentials，看看是否能标记出该可执行文件。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you find the Veil-Evasion executables aren’t working, you might need to update
    Metasploit with Msfupdate. Since Veil-Evasion is not currently in the Kali Linux
    repos, the latest version you pull down when you set up may not match up with
    how Msfvenom works in the default Kali 1.0.6 install. Of course, if you update
    Metasploit with Msfupdate, other exercises in this book may change, as Metasploit’s
    functionality changes frequently. Therefore, you may want to save this exercise
    for a second pass through the book or use a second Kali Linux image if you don’t
    want the update to affect later exercises in the book.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现 Veil-Evasion 生成的可执行文件无法正常工作，可能需要使用 Msfupdate 更新 Metasploit。由于 Veil-Evasion
    当前不在 Kali Linux 的仓库中，您在设置时下载的最新版本可能与 Kali 1.0.6 默认安装中 Msfvenom 的工作方式不匹配。当然，如果您使用
    Msfupdate 更新 Metasploit，书中的其他练习也可能会发生变化，因为 Metasploit 的功能经常更新。因此，如果不希望更新影响后续的练习，您可以选择将此练习留到第二遍阅读时再做，或者使用第二个
    Kali Linux 镜像。
- en: Hiding in Plain Sight
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直言不讳的隐匿
- en: Perhaps the best way to avoid antivirus programs is to avoid traditional payloads
    altogether. If you are familiar with coding for Windows, you can use Windows APIs
    to mimic the functionality of a payload. There is, of course, no rule that legitimate
    applications cannot open a TCP connection to another system and send data—essentially
    what our *windows/meterpreter/reverse_tcp* payload is doing.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 也许避免杀毒软件的最好方法是完全避免使用传统有效载荷。如果你熟悉 Windows 编程，你可以使用 Windows API 来模拟有效载荷的功能。当然，没有规定合法的应用程序不能与其他系统建立
    TCP 连接并发送数据——这实际上就是我们的 *windows/meterpreter/reverse_tcp* 有效载荷的工作方式。
- en: You may find that instead of generating the payload with Msfvenom and attempting
    to hide it with the methods covered in this chapter, you get even better results
    just writing a C program that performs the payload functionality you want. You
    can even invest in a code-signing certificate to sign your binary executable,
    to make it look even more legitimate.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现，与其使用 Msfvenom 生成有效载荷并尝试用本章讨论的方法隐藏它，不如编写一个 C 程序来实现你想要的有效载荷功能，效果可能更好。你甚至可以投资购买代码签名证书，为你的二进制可执行文件签名，以使其看起来更加合法。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Turn Real-time protection in Microsoft Security Essentials back off before moving
    on to post exploitation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行后渗透阶段之前，先关闭 Microsoft Security Essentials 的实时保护。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We’ve looked at only a few techniques for bypassing antivirus detection in this
    chapter. The topic of bypassing antivirus solutions could take up an entire book,
    and by the time it was published, the book would already be wildly out of date.
    Pentesters and researchers are constantly coming up with new techniques to sneak
    past antivirus detection, and antivirus vendors are always adding new signatures
    and heuristics to catch them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们仅探讨了绕过杀毒软件检测的几种技术。绕过杀毒软件的主题可以写成一本书，而且一旦出版，这本书可能会很快过时。渗透测试人员和研究人员不断想出新的方法来突破杀毒软件的检测，而杀毒软件厂商也总是在增加新的签名和启发式算法来抓捕它们。
- en: We looked at ways to use Metasploit to encode and embed payloads in legitimate
    executables. When we found that these techniques weren’t enough to evade Microsoft
    Security Essentials, we turned to techniques beyond Metasploit. We built a custom
    executable template and found that we were able to improve our results by combining
    techniques.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了使用 Metasploit 来编码并将有效载荷嵌入合法可执行文件的方法。当我们发现这些技术不足以绕过 Microsoft Security Essentials
    时，我们转向了 Metasploit 之外的技术。我们构建了一个自定义可执行文件模板，发现通过结合不同的技术，我们能够提高效果。
- en: We were finally able to reach our goal of bypassing Microsoft Security Essentials
    using Hyperion. Though we never reached a 0 percent detection rate, we were able
    to bypass Microsoft Security Essentials as well as several other top antivirus
    solutions. We also looked at another tool, Veil-Evasion, which uses VirtualAlloc
    injection combined with encryption for even better evasion.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终成功达到了绕过 Microsoft Security Essentials 的目标，使用了 Hyperion。虽然我们从未达到 0% 检测率，但我们成功绕过了
    Microsoft Security Essentials 以及其他几个顶级杀毒软件。我们还研究了另一个工具 Veil-Evasion，它结合了 VirtualAlloc
    注入和加密，以实现更好的规避效果。
- en: Having looked at a lot of ways to get onto systems, even ones without readily
    apparent vulnerabilities, we’ll now turn our attention to what we can do once
    we penetrate a system, as we enter the post-exploitation stage of pentesting.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究了许多入侵系统的方法之后，即便是那些没有明显漏洞的系统，我们现在将关注一旦渗透系统后能做什么，进入渗透测试的后渗透阶段。
