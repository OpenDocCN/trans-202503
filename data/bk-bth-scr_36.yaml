- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 33 STACKS, QUEUES, AND REAL-WORLD OBJECTS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 33 堆栈、队列和现实世界中的对象
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: 'In this chapter, I’ll build two more Batch data structures from scratch: stacks
    and queues. Both hold a finite set of ordered values, with the only difference
    being that stacks fit the last-in-first-out paradigm, while queues are first-in-first-out.
    I’ll detail both data structures in general and demonstrate how to build their
    unique functionalities. And of course, you’ll learn applications of these new
    tools, even a Batch pseudo-compiler of other bat files.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将从头开始构建两个 Batch 数据结构：堆栈和队列。它们都存储一组有序的有限值，唯一的区别是堆栈遵循后进先出（LIFO）原则，而队列遵循先进先出（FIFO）原则。我将详细介绍这两种数据结构的一般概念，并展示如何构建它们独特的功能。当然，你还将学习这些新工具的应用，甚至会制作一个将其他
    bat 文件编译的 Batch 伪编译器。
- en: However, this chapter is as much about real-world Batch objects as it’s about
    stacks and queues. I’ll also use what you learned in the previous chapter to construct
    object bat files for each data structure. The objects will allow you to maintain
    multiple stacks or queues simultaneously, and they’ll ideally inspire future real-world
    Batch objects of your own. I’ll even finish up with final thoughts on Batch object-oriented
    design.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本章不仅仅是关于堆栈和队列的，它同样涉及现实世界中的 Batch 对象。我还将使用你在前一章学到的内容，为每个数据结构构建对象 bat 文件。这些对象将允许你同时维护多个堆栈或队列，并且它们理想地会激发你未来设计属于自己的现实世界
    Batch 对象。我甚至会以对 Batch 面向对象设计的最终思考做结尾。
- en: Stacks
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆栈
- en: A *stack* is a data structure containing an ordered list of data items, organized
    as *last-in-first-out (LIFO)*. Undoubtedly, the best metaphor for a stack is a
    spring-loaded cafeteria plate dispenser. The weight of each plate pushes down
    a spring at the base of the dispenser so that only the top plate in the stack
    is available. Add more plates and the stack drops down so that only what’s now
    the top plate is poking up. The first plate added is at the bottom of the stack,
    and the first one retrieved is the last one added to the top of the stack. You
    can’t access a plate lower on the stack without first removing the plates above
    it, one by one. Take that top plate and the stack rises the height of a single
    plate, exposing the one that was just underneath it, while protecting the rest
    from the clumsy and possibly unhygienic hoi polloi.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*堆栈* 是一种包含有序数据项的结构，按*后进先出（LIFO）*的方式组织。毫无疑问，堆栈最好的比喻就是带弹簧的自助餐盘分配器。每个盘子的重量推动分配器底部的弹簧，使得只有堆栈最顶端的盘子可以拿到。增加更多盘子后，堆栈会下沉，只剩下新的顶盘露出。第一个添加的盘子在堆栈底部，而第一个被取出的盘子是堆栈顶端最近添加的盘子。你不能在不先移除上面的盘子的情况下访问堆栈下方的盘子。拿掉顶盘后，堆栈会升高一个盘子的高度，暴露出刚才位于下方的盘子，同时保护其他盘子免受可能不小心且不卫生的干扰。'
- en: Similarly, you can add or *push* a data item onto a stack, followed by more
    data items. At any point, you can retrieve or *pop* the data item at the top of
    the stack—that is, get the item added most recently. Most object-oriented languages
    come with a built-in stack data structure with methods for pushing an item onto
    the stack, popping the last item, and peeking at the last added item without actually
    removing it. There should also be methods to clear the stack and to determine
    whether the stack is empty.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以将一个数据项添加或*压入*堆栈，接着添加更多的数据项。在任何时刻，你都可以检索或*弹出*堆栈顶端的数据项——即获取最近添加的项。大多数面向对象的编程语言都提供了内建的堆栈数据结构，包含将项压入堆栈、弹出最后一项和查看最后添加项（但不移除它）的方法。还应该有方法来清空堆栈，并确定堆栈是否为空。
- en: Batch has no such built-in data structure, but if you’re still with me in this
    final chapter, I’ll assume that you also enjoy the challenge of creating atypical
    Batch functionality. The underlying structure of the stack in Batch is merely
    a single variable. To push the first value onto a stack, we’ll simply assign it
    to the stack variable. Then we’ll push subsequent items onto the stack by prepending
    to that variable, pushing the existing items down the stack.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Batch 没有这种内建的数据结构，但如果你还跟得上本章的内容，我会假设你也喜欢挑战创建非典型的 Batch 功能。Batch 中堆栈的底层结构仅仅是一个单一的变量。要将第一个值压入堆栈，我们只需将其赋值给堆栈变量。然后，我们通过在该变量前面添加新项来将后续数据项压入堆栈，这样会把现有项推到堆栈下方。
- en: To execute a pop request, we’ll extract the leading item in the variable from
    the contents of the variable, leaving the rest. A peek request will be similar,
    except we’ll leave the stack undisturbed. To make this work, we’ll need a delimiter
    between each item guaranteed not to be in the data. Spaces, pipes, and commas
    are good options, depending on the expected data, but my preference is the tab
    character. If it’s possible that your data might have tabs, you should choose
    something else as the delimiter; it can even be a variable itself set by the user.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行pop操作，我们将从变量中提取出第一个项目，剩下的则保留不动。peek操作则类似，只是我们不改变堆栈的内容。为了实现这一点，我们需要确保每个项目之间有一个分隔符，且该分隔符不会出现在数据中。空格、管道符和逗号都是不错的选择，具体取决于数据的预期内容，但我个人偏好使用制表符。如果你的数据中可能包含制表符，建议选择其他符号作为分隔符，甚至可以由用户自定义变量来设定分隔符。
- en: To demonstrate the different pieces of functionality needed to implement a stack,
    I’ll construct and use a stack of friends. The first task is to come up with a
    variable name; any will do, but I’ll use the stkFriends variable. My convention
    is to prepend the name of the stack with stk, making it clear to anyone that stumbles
    across it (who also happens to know this convention) that the variable is the
    manifestation of a stack. In short order, I’ll bring all of this functionality
    into an object, but first I’ll step through the methodology for the push, pop,
    and peek functions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示实现堆栈所需的不同功能模块，我将构建并使用一个朋友堆栈。第一个任务是给变量命名；任何名字都可以，但我会使用stkFriends变量。我的惯例是将堆栈的名称前缀加上stk，以便让任何偶然看到它（且知道这个惯例）的人清楚地知道这个变量是堆栈的体现。很快，我会把这些功能整合到一个对象中，但首先我将逐步讲解push、pop和peek函数的方法。
- en: '**Push**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**Push**'
- en: 'The logical place to start is with the *push*, and this solitary set command
    is all you need to push Walter onto the stack:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 合理的起点是*push*，这条独立的命令就足以将Walter推入堆栈：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, as well as in future listings, I’m using a solid arrow to represent the
    tab character. By default, it is indistinguishable from one or more spaces in
    most editors, but if using Notepad++, you can show tab characters as arrows by
    selecting **View** ▶ **Show Symbol** ▶ **Show Space and Tab**. (Other editors
    have a similar feature, and if you’ve gotten this far into the book using Notepad,
    you are clearly a glutton for punishment.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里以及以后的代码示例中，我使用实心箭头来表示制表符（tab）。默认情况下，大多数编辑器中它与一个或多个空格无法区分，但如果使用Notepad++，你可以通过选择**视图**
    ▶ **显示符号** ▶ **显示空格和制表符**来显示制表符为箭头。（其他编辑器也有类似功能，如果你到现在一直在使用记事本，显然你是一个自虐狂。）
- en: I’m using the stkFriends variable twice in the command, assigning it to itself,
    resolved with percent signs and prepended with the item I’m adding, Walter, and
    the delimiter, a tab character. This has, in effect, added the value to the top
    of the stack. Instead of the hardcoded data item, you can easily use a resolved
    variable in its place for the friend being added.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我在命令中两次使用了stkFriends变量，将其赋值给自身，并用百分号标记解析出来，前面加上我正在添加的项，Walter，以及分隔符——制表符。这实际上已经将该值添加到了堆栈顶部。你可以轻松地将硬编码的数值替换成解析后的变量，代表要添加的朋友。
- en: If the stack is already empty, this command populates it with its first value,
    followed by a tab and nothing else.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果堆栈已经为空，这条命令将其填充为第一个值，然后是一个制表符，后面没有其他内容。
- en: '**Peek**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**Peek**'
- en: The *peek* function finds the item on the top of the stack without altering
    the stack. It just takes a peek, without popping. We don’t know how many values
    are on the stack, if any at all, but we do know that if stkFriends is populated,
    its first tab-delimited value is at the top of the stack.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*peek*函数能够查看堆栈顶部的项，但不会改变堆栈的内容。它只是“偷看”一下，而不是弹出一个项。我们无法知道堆栈中有多少个值，甚至是否有值，但我们知道如果stkFriends已被填充，其第一个制表符分隔的值位于堆栈顶部。'
- en: 'The following code populates aFriend with whatever’s on top of the stack:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将堆栈顶部的内容赋值给aFriend变量：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The parsing of delimited data is clearly a job for the for /F command. I’m using
    the stack variable as text input, and since we’ve delimited the variable by tabs,
    I’m setting the delims keyword to a tab. The tokens=1 clause is implied, meaning
    that the for variable defined as %%s resolves to the first token in the string,
    and since that first token is the last item placed onto the stack, we’ll simply
    capture it as aFriend.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 解析分隔数据显然是`for /F`命令的工作。我正在使用堆栈变量作为文本输入，由于我们用制表符分隔了变量，我将`delims`关键字设置为制表符。`tokens=1`子句是隐式的，这意味着定义为`%%s`的`for`变量解析为字符串中的第一个标记，并且由于第一个标记是最后放入堆栈的项，我们将其捕获为aFriend。
- en: Also notice that I’m wiping out the aFriend variable prior to the for command.
    If the stack is empty, the for /F command doesn’t execute, so initializing the
    variable ensures that an empty stack returns a null value.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在`for`命令之前我清除了aFriend变量。如果堆栈为空，`for /F`命令不会执行，因此初始化变量可以确保空堆栈返回一个空值。
- en: '**Pop**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**弹出**'
- en: 'The *pop* function is remarkably similar to the peek function with one significant
    difference; it also removes the returned data item from the top of the stack.
    Notice that the logic for this task mimics the previous listing with two additions:
    the tokens clause and the final set command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*pop*函数与`peek`函数非常相似，唯一的显著区别是，它还会从堆栈顶部移除返回的数据项。请注意，这个任务的逻辑模仿了之前的列表，但有两个补充：`tokens`子句和最后的`set`命令：'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Instead of using the implied tokens clause, I’m setting the keyword to 1*. This
    has no impact on the for variable, %%s, itself. It still resolves to the top item
    on the stack, but now the interpreter assigns the remainder of the text field
    to the second token, %%t. Since the rest of the text field is the entire stack
    minus the first item, I’m simply reassigning the abbreviated stack to the stack
    variable with the last set command. The entire process is analogous to breaking
    one square off the end of a chocolate bar and pushing the rest of the bar back
    into the wrapper.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有使用隐式的`tokens`子句，而是将关键字设置为`1*`。这对`for`变量`%%s`本身没有影响。它仍然解析为堆栈上的顶部项，但现在解释器将文本字段的其余部分分配给第二个标记`%%t`。由于文本字段的其余部分是整个堆栈减去第一个项，我只需使用最后一个`set`命令将缩略堆栈重新分配给堆栈变量。整个过程类似于从巧克力棒的一端掰下一块，然后把剩余的巧克力棒重新放回包装纸里。
- en: Queues
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 队列
- en: Stacks and queues go together like chocolate and peanut butter. At its core,
    a *queue* is the *first-in-first-out (FIFO)* version of a stack. (This is the
    same as last-in-last-out, but LILO has never caught on.) The metaphor for a stack
    took us to a cafeteria, but the metaphor for a queue takes us to a restaurant.
    If you’re the first to show up without a reservation at a busy time, the host
    staff will likely put your name at the top of a list. They’ll add others to the
    list, and when a table frees up, you’ll be sat first from the list. Each of the
    others on this list will move up and continue to wait their turn in order.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈和队列就像巧克力和花生酱一样搭配。队列的核心是堆栈的*先进先出（FIFO）*版本。（这和后进先出相同，但LILO从未流行起来。）堆栈的比喻带我们去了自助餐厅，而队列的比喻带我们去了餐厅。如果你是没有预约的第一个到达者，在忙碌的时段，接待员可能会把你的名字写在名单的顶部。他们会将其他人添加到名单中，当桌子空出来时，你将是第一个被安排座位的人。名单上的其他人将按顺序上升，继续等待他们的轮次。
- en: Here’s a truly horrible business idea. I’ll open a pancake restaurant, call
    it Stacks, and use a stack for those waiting for a table. The group that arrives
    just as we get busy is first onto the stack, where they’ll wait, perhaps patiently,
    as others are added to and removed from the stack (that is, sat). Even if there
    are 20 groups on the stack, the people who just showed up get the next table.
    Obviously, this is a far better application for a queue.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个真正糟糕的商业创意。我将开一家煎饼餐厅，叫做Stacks，并使用堆栈来等待入座的人。刚好在我们开始忙碌时到达的那一组人首先进入堆栈，他们会等待，或许耐心等待，因为其他人会被加入或从堆栈中移除（即被安排座位）。即使堆栈上有20组人，刚到的人也会得到下一个桌子。显然，这更适合用队列来实现。
- en: 'Implementing a queue in Batch is almost identical to implementing a stack.
    The one significant difference is that when adding a data item to the queue, you’ll
    want to append it to the end of the variable instead of prepending it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在Batch中实现队列几乎与实现堆栈相同。唯一显著的区别是，当向队列添加数据项时，你需要将它附加到变量的末尾，而不是前面：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There are also a couple of differences in nomenclature. First, because the variable
    represents a queue, I’ve changed its leading text from stk to que, but again,
    this is just one convention. Second, the terms *push* and *pop* make sense only
    when thinking about a stack, such as a plate dispenser. When adding and removing
    values from a queue, I’ll instead use the pedestrian yet accurate terms *add*
    and *remove*, respectively.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名法上也有一些区别。首先，因为变量代表的是队列，所以我将其前缀从stk改为que，但这仅仅是其中一种约定。其次，*push*和*pop*这两个术语只有在考虑堆栈时才有意义，比如盘子分发器。当对队列进行值的添加和移除时，我将使用更简单且准确的术语*add*和*remove*，分别表示添加和移除。
- en: Everything else is the same between the two data structures. Notice that the
    previous set command also uses the tab delimiter. The add and remove functions
    are respectively identical to the push and pop functions, other than the variable
    name, since both target the first delimited data item in the variable. In fact,
    they are so similar I’ll hold off showing you these functions until I build the
    queue object.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方面，这两个数据结构是相同的。请注意，之前的set命令也使用了制表符作为分隔符。add和remove函数分别与push和pop函数完全相同，唯一的区别是变量名称，因为它们都针对变量中第一个以分隔符分隔的数据项。事实上，它们是如此相似，以至于我将在构建队列对象时才向你展示这些函数。
- en: WARNING
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '*We live in a finite world, and just as the cafeteria plate dispenser can accept
    only so many plates, Batch has a limitation pertinent to stacks and queues. A
    single variable can’t exceed 32,767 bytes, and since this design of stacks and
    queues relies on a single variable holding the entire data structure, the cumulative
    size of all data items and delimiters in a stack or queue can’t cross this threshold.
    For instance, you can store 16,383 one-byte values or 1,927 sixteen-byte values.
    For most applications, this is sufficient, but if it isn’t, you can instead build
    these data structures with an array and a pointer to keep track of the pertinent
    index.*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们生活在一个有限的世界中，就像自助餐盘分发器只能接受有限数量的盘子一样，批处理也有与堆栈和队列相关的限制。一个变量不能超过32,767字节，且由于堆栈和队列的设计依赖于单个变量来保存整个数据结构，因此堆栈或队列中所有数据项和分隔符的累积大小不能超过这一限制。例如，你可以存储16,383个一字节的值，或者1,927个十六字节的值。对于大多数应用来说，这已经足够，但如果不够，你可以使用数组和指针来构建这些数据结构，以跟踪相关的索引。*'
- en: Real-World Batch Objects
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现实世界中的批处理对象
- en: In [Chapter 32](chapter32.xhtml), I explored Batch object-oriented design. I
    detailed a model that implemented every possible piece of functionality involving
    the four pillars of OOP, but in truth, that model isn’t representative of typical
    object bat files. Fortunately, the stack and queue offer instructive real-world
    examples of Batch objects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第32章](chapter32.xhtml)中，我探讨了批处理面向对象的设计。我详细介绍了一个实现所有可能功能的模型，涉及面向对象编程的四个支柱，但事实上，这个模型并不代表典型的对象bat文件。幸运的是，堆栈和队列为批处理对象提供了有教育意义的现实世界示例。
- en: The Stack Object
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 堆栈对象
- en: 'I’ll show the stack object bat file, *oStack.bat*, in two parts, starting with
    the comments and mainline logic:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我将分两部分展示堆栈对象bat文件，*oStack.bat*，首先是注释和主逻辑：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The most striking difference between this code and the objects from the prior
    chapter is that I’ve replaced the “traffic cop” hiding private methods with a
    call command exposing all the methods as public.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与上一章中的对象最显著的区别是，我将隐藏私有方法的“交通警察”替换为一个call命令，公开所有方法为公共方法。
- en: 'In [Chapter 32](chapter32.xhtml), all object bat files had a for command containing
    the list of public methods, but the *oStack.bat* object bat file has only public
    methods. As a result, instead of maintaining a list, the call command directs
    the execution to the appropriate method, thus making all of the methods public.
    Since the second parameter is the name of the method to be called, I’m stripping
    it of possible double quotes and prepending it with a colon to create the name
    of the called label: :%~2.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第32章](chapter32.xhtml)中，所有的对象bat文件都有一个for命令，包含公共方法的列表，但*oStack.bat*对象bat文件只有公共方法。因此，call命令不再维护列表，而是直接将执行引导到相应的方法，从而使所有方法都变为公共方法。由于第二个参数是要调用的方法名称，我将去掉可能的双引号，并在其前面加上冒号，以形成被调用标签的名称：
    :%~2。
- en: The name of the stack is the first parameter coming into the bat file and also
    the first argument I pass to each of the methods. The second argument passed to
    each method is the third input parameter, and it has different uses dependent
    on the method. But instead of discussing this here, maybe I should instead just
    point you to the comments at the top of the bat file clearly delineating the parameters
    accepted by the object and its public methods.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈的名称是传递到 bat 文件中的第一个参数，也是我传递给每个方法的第一个参数。传递给每个方法的第二个参数是第三个输入参数，它的用途因方法而异。但与其在这里讨论，不如直接指引你查看
    bat 文件顶部的注释，明确列出了该对象及其公共方法所接受的参数。
- en: The two pipes and the code block following the call command is a real-world
    application of conditional execution. (In [Chapter 28](chapter28.xhtml), I provided
    a detailed example of this technique, including why the cmd command at the top
    of the bat file is resetting the return code to 0.) The upshot is that if the
    object receives a valid method, it invokes that method successfully, and if the
    parameter is an invalid method name, this logic writes the error message to *Log.txt*
    and ends the execution. Thus, all methods are public.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 两个管道符和调用命令后的代码块是条件执行的实际应用。（在[第28章](chapter28.xhtml)中，我提供了一个详细的示例，解释了为什么 bat
    文件顶部的 cmd 命令会将返回代码重置为 0。）结论是，如果对象接收到有效的方法，它会成功调用该方法；如果参数是无效的方法名称，则此逻辑会将错误信息写入
    *Log.txt* 并结束执行。因此，所有方法都是公共的。
- en: 'What happens if we don’t have this conditional execution and error handling?
    It works perfectly fine if every call to the bat file passes a valid method name.
    However, if for the first argument someone errantly passes the homophone for Peek
    referring to a mountaintop, the interpreter writes the following to stderr, and
    the execution continues unabated:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这个条件执行和错误处理会发生什么呢？如果每次调用 bat 文件时都传递有效的方法名称，那么它会正常工作。然而，如果第一个参数错误地传递了指代山顶的
    Peek 的同音词，解释器会将以下内容写入 stderr，且执行会继续进行：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The interpreter neither finds nor calls the method, nor does it set the return
    variable, if applicable, resulting in unpredictable downstream results. Something
    like this deserves a hard abort to pique our attention, and that’s exactly what
    the conditional execution and rudimentary error handling is accomplishing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解释器没有找到或调用该方法，也没有设置返回变量（如果适用），则会导致下游结果无法预测。像这样的情况值得立即终止，以引起我们的注意，这正是条件执行和基础错误处理所要完成的任务。
- en: 'Here’s the remainder of *oStack.bat* and its public methods mentioned in the
    prior comments:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 *oStack.bat* 的其余部分及其在之前注释中提到的公共方法：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I’ve already discussed the mechanism for the push, pop, and peek functionality
    in the “Stacks” section, and in this object, you’ll find the polymorphic version
    for each under the appropriately named label. For instance, the :Push method sets
    the stk%~1 variable in lieu of stkFriends. For this object to work with multiple
    stacks, it can’t explicitly reference a particular stack variable. Instead, it
    builds the name of the stack by resolving the first parameter and prepending it
    with the stk text before setting it to the concatenation of %~2, a tab character,
    and !stk%~1!. The second parameter is the value being pushed onto the stack, and
    the tab character is the delimiter. This command uses the stk%~1 variable a second
    time to retrieve the existing values on the stack, resolving the variable with
    exclamation marks and delayed expansion. Ultimately, this pushes the second parameter
    onto the stack.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在“堆栈”部分讨论了推送（push）、弹出（pop）和查看（peek）功能的机制，在这个对象中，你会找到每个功能的多态版本，并且在适当命名的标签下。比如，:Push
    方法将 stk%~1 变量设置为 stkFriends。为了使这个对象能够与多个堆栈一起工作，它不能显式地引用某个特定的堆栈变量。相反，它通过解析第一个参数并将其与
    stk 文本连接起来，来构建堆栈的名称，然后将其设置为 %~2、制表符字符和 !stk%~1! 的拼接结果。第二个参数是被推送到堆栈上的值，制表符字符是分隔符。此命令第二次使用
    stk%~1 变量来检索堆栈上的现有值，通过感叹号和延迟扩展解析该变量。最终，这会将第二个参数推送到堆栈上。
- en: The :Pop and :Peek methods also make use of stk%~1 for setting and/or resolving
    the stack. The only other new feature in these methods is that I’m setting %~2
    to the return value because the second parameter for both methods is the name
    of the variable being returned.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: :Pop 和 :Peek 方法也使用 stk%~1 来设置和/或解析堆栈。这些方法中的唯一新特性是，我将 %~2 设置为返回值，因为这两个方法的第二个参数是要返回的变量的名称。
- en: For this to be a proper stack object, it must provide two more methods typical
    of this data structure in other languages. The first accepts the name of the stack
    as its only parameter and clears all data items from it. To complete the task,
    the :Clear method simply sets stk%~1 to nothing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个对象成为一个合适的堆栈对象，它必须提供两个其他语言中堆栈数据结构典型的方法。第一个方法接受堆栈的名称作为唯一参数，并清空堆栈中的所有数据项。为了完成任务，:Clear
    方法只需将 stk%~1 设置为空。
- en: The other method returns a boolean that evaluates to true if the stack is empty
    or to false if anything is on the stack. The :IsEmpty method determines if stk%~1
    is defined. Depending on the result, it sets the second parameter to either true
    or false.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方法返回一个布尔值，如果堆栈为空，则为 true；如果堆栈中有项，则为 false。:IsEmpty 方法决定 stk%~1 是否已定义。根据结果，它将第二个参数设置为
    true 或 false。
- en: 'Now we’re ready to use the stack object. These four calls add three friends
    to a new stack, with Marty being the last in:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备使用堆栈对象。这四个调用将三个朋友添加到新的堆栈中，其中马蒂是最后一个加入的：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first call is probably unnecessary, but in the off chance that the stkFriends
    variable is defined, this initializes it. You can think of it as a constructor
    even though this design doesn’t have one.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个调用可能不必要，但如果 stkFriends 变量已定义，这个调用会初始化它。即使这个设计没有构造函数，你也可以把它当作构造函数来理解。
- en: 'Execute this multiple times, and the aFriend variable will come back as Marty
    every time because it peeks only at the data item:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 多次执行此操作后，aFriend 变量每次都会返回马蒂，因为它仅查看数据项：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This also returns Marty when called, but only once:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这在调用时也返回马蒂，但仅返回一次：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The next pop invocation returns Donny, the value placed on the stack just before
    Marty.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个 pop 调用返回 Donny，这是在马蒂之前放入堆栈的值。
- en: 'Now only Walter remains on the stack. You can add two more friends, but Walter
    remains in the bottom position:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只有沃尔特仍然留在堆栈中。你可以再添加两个朋友，但沃尔特仍然处于底部位置：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Remember that arguments with embedded spaces need to be encased in double quotes
    and that *oStack.bat* handles them deftly with the use of tildes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，包含空格的参数需要用双引号括起来，*oStack.bat* 使用波浪号巧妙地处理了这些。
- en: 'The isEmpty call returns a boolean variable:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: isEmpty 调用返回一个布尔变量：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The bool variable resolves as false since there are three items on the stack,
    and this logic writes NOT Empty to the console.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于堆栈中有三个项，因此布尔变量的值为 false，这条逻辑在控制台上显示“NOT Empty”。
- en: 'Lastly, to start from scratch, we can empty the stack of all its data items:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了从头开始，我们可以清空堆栈中的所有数据项：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Call the object again to invoke the isEmpty method, and it returns the boolean
    set to true.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 再次调用该对象以调用 isEmpty 方法，它会返回布尔值 true。
- en: The Queue Object
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 队列对象
- en: 'Since stacks and queues are so similar, I’m modeling the queue object on the
    stack object. But still, notice the many subtle differences and just one significant
    difference as you examine the complete contents of the stack object bat file,
    *oQueue.bat*:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于堆栈和队列非常相似，我将队列对象建模为堆栈对象。但是，当你检查堆栈对象 bat 文件 *oQueue.bat* 的完整内容时，仍然可以注意到许多微妙的区别，只有一个显著的不同：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: I’ve changed the stk text leading the variable name to que for obvious reasons.
    The :Push and :Pop methods have given way to the :Add and :Remove methods, respectively,
    and the comments at the top of the object clearly reflect these changes. The significant
    alteration is in the set command ❶ that adds a data item to the queue in the :Add
    method. It now adds the value to the end of the line instead of the beginning,
    meaning that the first item in is the first item out.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将变量名称前的 stk 文本改为 que，原因显而易见。:Push 和 :Pop 方法分别被 :Add 和 :Remove 方法替代，且对象顶部的注释清晰地反映了这些变化。显著的变化在于
    set 命令❶，它将数据项添加到队列中，使用 :Add 方法。现在它将值添加到队列的末尾，而不是开头，这意味着第一个进来的项是第一个出去的项。
- en: 'A couple of the method names are different, but the execution of this object
    should look familiar. Here’s an example of five calls:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名称略有不同，但该对象的执行应该看起来很熟悉。以下是五个调用的示例：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The last call returns aFriend populated with the value of Walter, the first
    data item added to the queue. Compare this to the stack object that returned Marty
    for a very similar call.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的调用返回一个名为 aFriend 的变量，里面包含沃尔特的值，这是第一个添加到队列中的数据项。与堆栈对象相比，它为一个非常类似的调用返回了马蒂。
- en: Stack and Queue Applications
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆栈和队列的应用
- en: You can find applications for the queue object wherever there’s a need to process
    data in order. You might create a queue to hold a list of server names retrieved
    from a source, perhaps one or more files. Then as you remove each server from
    the queue, you can perform a particular task on that server. The task might be
    as simple as verifying that it’s up and running, or it might involve the creation
    of directories or complex file movements. What’s important is that the queue allows
    you to take each server in order.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在需要按顺序处理数据的地方找到队列对象的应用。你可能创建一个队列来保存从某个来源（可能是一个或多个文件）检索到的服务器名称列表。然后，当你从队列中移除每个服务器时，可以对该服务器执行特定的任务。任务可能是简单的验证服务器是否正常运行，或者可能涉及目录创建或复杂的文件移动。重要的是，队列允许你按顺序处理每个服务器。
- en: With interactive Batch, you might ask the user for a list of multiple inputs.
    Instead of retrieving one piece of data, processing it, and then asking for another,
    you can ask for all of the data up front as you add all of it to a queue. Then
    the bat file can process each data item in order without another question.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用交互式批处理，你可能会要求用户提供多个输入。与其一个接一个地获取数据并处理，再询问下一个，你可以提前要求所有数据，并将其全部添加到队列中。然后，bat
    文件可以按顺序处理每个数据项，而无需再提问。
- en: Stack applications aren’t always as obvious, but when you need one, it’s usually
    the only adequate tool for the job. You can use a stack to reverse the order of
    letters or words looking for palindromes. Recursion is another application of
    a stack. With each recursive call, the interpreter pushes the current state of
    all variables onto a stack. You don’t have direct access to this stack, but after
    making too many recursive calls, the interpreter reports that the recursion has
    exceeded “STACK limits” ([Chapter 23](chapter23.xhtml)). That’s not a coincidence.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 栈的应用并不总是显而易见的，但当你需要它时，通常它是唯一适合这个任务的工具。你可以使用栈来逆序排列字母或单词，寻找回文。递归是栈的另一个应用。每次递归调用时，解释器会将所有变量的当前状态推送到栈中。你无法直接访问这个栈，但在递归调用过多时，解释器会报告递归已超过“栈限制”（[第23章](chapter23.xhtml)）。这并非巧合。
- en: Using a stack, you can even create a pseudo-compiler for bat files or other
    uncompiled source code. I don’t want to oversell this; proper compilers perform
    a number of tasks, and while we can go a long way toward performing just one of
    those tasks (the balancing of brackets), it won’t be bullet-proof. The concept
    behind this pseudo-compiler is that an open parenthesis needs a matching close
    parenthesis, just as curly and square brackets must come in pairs. They can be
    deeply nested, but a square bracket can’t close a curly bracket.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用栈，你甚至可以为 bat 文件或其他未编译的源代码创建一个伪编译器。我不想过度宣传这个功能；真正的编译器会执行许多任务，虽然我们可以在执行这些任务中的某一项（括号平衡）上取得很大进展，但它不会是万无一失的。这个伪编译器的概念是，一个开括号需要匹配的闭括号，就像大括号和方括号必须成对出现一样。它们可以深度嵌套，但方括号不能闭合大括号。
- en: 'Here are the complete contents of *PseudoCompiler.bat*, a bat file that attempts
    to balance all sets of brackets in a bat file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 *PseudoCompiler.bat* 的完整内容，这是一个尝试平衡 bat 文件中所有括号的 bat 文件：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: At a high level, this bat file accepts one file to be pseudo-compiled as its
    sole parameter ❶. When this code encounters any type of open bracket (including
    parentheses), it pushes the character onto a stack ❺. Then whenever it sees a
    close bracket of any type, it pops the last open bracket off the stack ❽ and looks
    to see if they are a matching pair. If not, it aborts. When it’s done reading
    the bat file, it needs to verify that the stack is empty ❾, because if it isn’t,
    we must also abort because the input has at least one unclosed bracket.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，这个 bat 文件接受一个文件作为唯一参数进行伪编译❶。当这段代码遇到任何类型的括号（包括圆括号）时，它会将该字符推送到栈中❺。然后，每当它遇到任何类型的闭括号时，它会从栈中弹出最后一个开括号❽，并检查它们是否是匹配的。如果不是，它将中止。当它完成读取
    bat 文件后，需要验证栈是否为空❾，因为如果栈不为空，我们必须中止，因为输入中至少有一个未闭合的括号。
- en: A deeper dive demonstrates many techniques introduced throughout this book,
    and it’s always fun to deconstruct a four-level deep nested for command. After
    clearing the Compiler stack, the outer for /F command ❶ accepts the lone parameter,
    %~1, as its input and reads each record sequentially. You can pseudo-compile any
    bat file by dragging and dropping it onto *PseudoCompiler.bat*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 更深入的探讨展示了本书中介绍的许多技术，拆解一个四层嵌套的 for 命令总是很有趣。在清空编译器栈后，外层的 for /F 命令❶接受唯一的参数 %~1
    作为输入，并按顺序读取每一条记录。你可以通过将 bat 文件拖放到 *PseudoCompiler.bat* 上来伪编译任何 bat 文件。
- en: The for /L command ❷ iterates through each of the first 100 bytes of the input
    record. Double quotes cause issues when resolved in later if commands, so the
    first if command ❸ adeptly filters out the offending character. I’m using two
    escape characters for the comparison, and another one in the next line, where
    I execute an optionless for command ❹ that passes each of the three possible open
    brackets into its code block. It treats the curly and square brackets as text,
    but I must escape the open parenthesis. If I find one of the three characters,
    I push the open bracket onto the stack ❺.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`for /L`命令❷遍历输入记录的前100个字节。双引号在后续的`if`命令解析时会引起问题，因此第一个`if`命令❸巧妙地过滤掉了有问题的字符。我使用了两个转义字符来进行比较，并且在下一行中，我执行了一个不带选项的`for`命令❹，将每一种可能的左括号传递给其代码块。它将大括号和中括号当作文本处理，但我必须对左圆括号进行转义。如果我发现了三个字符中的一个，我将左括号压入栈中❺。'
- en: Another for command ❻ is the driver for finding and handling instances of close
    brackets. It passes all three pairs of open and close brackets, delimited by a
    colon, into its code block, where the final /F command ❼ breaks each pair into
    two tokens. If the byte from the file I’m examining matches the second token,
    I’ve found a close brackets, so I pop the last added item off the stack ❽. If
    that byte is a null, the close bracket is an orphan, so the code aborts and writes
    a rudimentary message to the console. If instead the popped byte doesn’t match
    the corresponding start bracket, the abort message notes the mismatched brackets.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个`for`命令❻是处理闭括号实例的驱动程序。它将三对左右括号（由冒号分隔）传递到其代码块中，最后的`/F`命令❼会将每一对括号拆分为两个标记。如果我检查的文件字节与第二个标记匹配，我就找到了一个闭括号，于是我将栈中最后添加的项目弹出❽。如果该字节为null，则闭括号是孤立的，代码会中止并向控制台写入一个基础消息。如果弹出的字节与相应的左括号不匹配，程序会报告括号不匹配的错误信息。
- en: If we make it through the entire file without finding a mismatch, the trailing
    logic checks that the stack is empty of all brackets ❾ with the use of a boolean.
    If an orphan remains, the code aborts because there’s at least one unmatched open
    bracket. After clearing this last if command, the brackets have all balanced,
    and the code triumphantly reports the success ❿.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在整个文件中都没有发现不匹配的括号，尾部逻辑会检查栈是否为空，确保所有括号都已经匹配❾，并使用布尔值进行判断。如果有孤立的括号存在，代码会中止，因为至少有一个没有匹配的左括号。在清除这个最后的`if`命令之后，括号已经全部平衡，代码成功地报告了匹配成功❿。
- en: This code demonstrates a great use for a stack, but it has limitations and,
    as mentioned, is far from bullet-proof. First and foremost, it assumes that each
    record is 100 bytes or less. The error handling in general also leaves much to
    be desired. At the very least, it should track the line of the infraction.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了栈的一个很好的应用，但它有局限性，正如前面提到的，远非万无一失。首先，它假设每个记录不超过100个字节。一般来说，错误处理方面也有很大的改进空间。至少，它应该追踪违规的行号。
- en: As the interpreter processes each record, it resolves variables delimited by
    exclamation marks, so this routine doesn’t validate any variable names containing
    brackets (think arrays and hash tables). Such variables will likely resolve to
    nothing, but if the two bat files share any variables, that can also cause problems.
    For instance, when I attempted to recursively pseudo-compile *PseudoCompiler.bat*
    (by copying and pasting it onto itself), popped resolved to an open parenthesis,
    resulting in it incorrectly reporting a mismatch. This self-pseudo-compile also
    failed on the unpaired open brackets ❹ being treated as text data.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当解释器处理每个记录时，它会解析由感叹号分隔的变量，因此此例程不会验证包含括号的变量名（例如数组和哈希表）。这些变量可能会解析为空，但如果两个批处理文件共享任何变量，也可能导致问题。例如，当我尝试递归伪编译*PseudoCompiler.bat*（通过复制并粘贴到自身），`popped`解析成了一个左圆括号，导致它错误地报告了一个不匹配错误。这个自我伪编译也在未配对的左括号❹被当作文本数据处理时失败。
- en: 'Even with these limitations that accentuate the *pseudo* in pseudo-compiler,
    this is still a solid means of tracking down most missed parentheses and brackets
    in a typical bat file—and a great application of a stack. Notice that this bat
    file calls the stack object we built earlier for four distinct tasks: clearing
    the stack, pushing, popping, and determining if the stack is empty.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这些限制下，强调了伪编译器中的*伪*性质，这仍然是追踪典型批处理文件中大多数缺失括号的可靠方法——并且是栈的一个伟大应用。注意，这个批处理文件调用了我们之前构建的栈对象，用于四个不同的任务：清空栈、压栈、弹栈，以及判断栈是否为空。
- en: NOTE
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*As a final note on the nested for commands, notice that I’ve chosen descriptive
    for variables that don’t conflict with each other. I capture the entire record
    (%%r) and* *iterate through it with an index (%%i), grabbing individual bytes
    (%%b). Then I pass a pair (%%p) of brackets into a loop, breaking them up into
    the open bracket (%%x) and the implied close bracket (%%y). The last two might
    not be descriptive, but I’m limited because they must be consecutive alphabetical
    characters.*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*关于嵌套for命令的最后一点，注意我为变量选择了描述性名称，确保它们之间不会冲突。我捕获整个记录（%%r），并用索引（%%i）迭代它，抓取单个字节（%%b）。然后，我将一对（%%p）括号传入循环，将它们拆分成开放括号（%%x）和隐含的闭合括号（%%y）。最后两个变量可能不够描述性，但由于它们必须是连续的字母字符，所以我的选择有限。*'
- en: Final Thoughts on Batch Object-Oriented Design
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批处理面向对象设计的最终思考
- en: I could have discussed the stack and queue data structures without presenting
    them as objects. The methods in this chapter would have been routines inside of
    an ordinary bat file with hardcoded names for the data structures, but as important
    as stacks and queues are, this chapter is also about real-world object-oriented
    design.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我本可以讨论堆栈和队列数据结构，而不将它们呈现为对象。本章中的方法本可以是普通批处理文件中的例程，数据结构的名称是硬编码的，但堆栈和队列的重要性使得本章不仅仅是关于这些数据结构，它还涉及到现实世界中的面向对象设计。
- en: The object-oriented example in the prior chapter ([Chapter 32](chapter32.xhtml))
    was pedagogical at its core. It showed as many aspects of Batch object-oriented
    design as possible, but the two objects in this chapter are examples of real-world
    Batch objects. When I code objects, they’re far more likely to resemble *oStack.bat*
    than *oMovie.bat* or *oComedy.bat*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章中的面向对象示例（[第32章](chapter32.xhtml)）本质上是教学性的。它展示了尽可能多的批处理面向对象设计的各个方面，但本章中的这两个对象则是现实世界中批处理对象的示例。当我编写对象时，它们更可能类似于*oStack.bat*，而不是*oMovie.bat*或*oComedy.bat*。
- en: I hope you can see the advantages of putting all of the stack-specific code
    into a single reusable and concise bat file—that is, an object. This allows you
    to code hundreds of future stacks with this one object without ever having to
    consider the details of how the stack itself is implemented. With this in mind,
    you can reconsider arrays and hash tables ([Chapter 29](chapter29.xhtml)), imagining
    an object for each with methods for adding elements, retrieving elements, and
    clearing all elements. Further imagine other methods for displaying the contents
    of the array or hash table, writing all elements to a file, or even sorting the
    elements of the array. If you’re feeling bold, you could even use the stack object
    in the array object to reverse the order of the array elements.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能看到将所有与堆栈相关的代码放入一个可重用且简洁的批处理文件中的优势——也就是一个对象。这使得你能够通过这个对象编写数百个未来的堆栈，而不需要考虑堆栈本身是如何实现的。考虑到这一点，你可以重新审视数组和哈希表（[第29章](chapter29.xhtml)），想象为每个创建一个对象，并为其提供添加元素、检索元素和清除所有元素的方法。进一步想象为显示数组或哈希表内容、将所有元素写入文件，甚至对数组元素进行排序的其他方法。如果你敢于尝试，你甚至可以在数组对象中使用堆栈对象，反转数组元素的顺序。
- en: Real-world Batch objects implement only the functionality of OOP that’s needed
    to get a job done. In a strict object-oriented language, you can’t use an object
    until you invoke the constructor, but in Batch, for better or worse, you have
    more flexibility. The objects in this chapter don’t even have constructors. Since
    Batch is not a true object-oriented language, you’re free to use only the pieces
    of the OOP paradigm that you choose, and there’s no compiler to say otherwise.
    I could have created a constructor (it would’ve looked a lot like the :Clear method),
    but I left it out for no other reason than that I didn’t feel it was needed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界中的批处理对象仅实现完成工作所需的面向对象编程功能。在严格的面向对象语言中，你必须先调用构造函数才能使用对象，但在批处理脚本中，无论好坏，你有更多的灵活性。本章中的对象甚至没有构造函数。由于批处理不是一种真正的面向对象语言，你可以自由选择只使用OOP范式的某些部分，而且没有编译器会对此提出异议。我本可以创建一个构造函数（它看起来会像:Clear方法），但我之所以没有创建它，仅仅是因为我认为不需要它。
- en: There’s also no inheritance in this chapter. You can easily use *oStack.bat*
    and *oQueue.bat* without it, and that’s exactly how I typically implement Batch
    object-oriented design, but you can always extend any object. Some future coder,
    maybe even you, might later build a child object inheriting from one of these
    objects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中也没有继承。你可以轻松地使用*oStack.bat*和*oQueue.bat*，而不需要继承，这正是我通常实现批处理面向对象设计的方式，但你总是可以扩展任何对象。未来的某个程序员，甚至可能是你，可能会创建一个继承自这些对象的子对象。
- en: For instance, if you’re using the queue object to maintain a list of servers
    to be processed in some way, you might also need to look up an IP address for
    each or just verify that it’s on the network. You can encapsulate this new logic
    in an object that also inherits the data and methods from what would then become
    the *parent* queue object, while a procedural coder would resort to artlessly
    cloning the queue logic. (I hope that you can sense the great distain with which
    I typed that last clause.)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你使用队列对象来维护一个需要以某种方式处理的服务器列表，你可能还需要查找每个服务器的IP地址，或者只是验证它是否在网络上。你可以将这种新逻辑封装到一个对象中，同时这个对象也继承了作为*父*队列对象的数据和方法，而程序员通常会通过笨拙地克隆队列逻辑来实现。（我希望你能感受到我输入最后那句时的轻蔑。）
- en: I’ve also shown that you can maintain a list of public methods or simply expose
    all methods in an object as public. All of this shows the flexibility of Batch
    object-oriented design. You can use only the design elements that you want or
    need and not what you don’t want or need. If it makes sense to have a constructor,
    create one; otherwise, don’t. If nothing else, small bat files with narrowly focused
    tasks are ideal. I encourage you to use some or all of the Batch object-oriented
    design paradigm that I’ve shown in these last two chapters in your bat files.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我还展示了如何维护一个公共方法列表，或者简单地将所有方法暴露为公共方法。所有这些都展示了批处理面向对象设计的灵活性。你可以仅使用你想要或需要的设计元素，而不是那些你不需要或不想要的。如果需要构造函数，就创建一个；否则，不必创建。如果没有其他，针对小而专注任务的批处理文件是理想的。我鼓励你在你的批处理文件中使用我在这两章中展示的部分或全部批处理面向对象设计范式。
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this final chapter, I detailed two new data structures, namely, stacks and
    queues, showing you how to push and pop (or add and remove) data items. You also
    learned how to peek at the next value, clear all values, and determine whether
    the data structure is empty. I shared a few ideas about stack and queue applications,
    even creating a pseudo-compiler. It isn’t perfect, but it’s very useful and nicely
    demonstrated how to use a stack.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我详细介绍了两种新的数据结构——栈和队列，并向你展示了如何推入和弹出（或添加和移除）数据项。你还学会了如何查看下一个值、清除所有值，并确定数据结构是否为空。我分享了一些栈和队列应用的想法，甚至创建了一个伪编译器。它不是完美的，但非常有用，并很好地展示了如何使用栈。
- en: I also took all that you learned about stacks and queues and wrapped it up into
    two real-world Batch objects. You learned how to construct similar objects, using
    only the components of object-oriented design that make sense to you, and how
    to invoke those objects. I hope you’ll make use of the stack and queue objects
    and look for future problems in need of an object-oriented solution.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将你学习的关于栈和队列的内容总结成了两个现实世界的批处理对象。你学会了如何构建类似的对象，使用那些对你有意义的面向对象设计组件，并学会了如何调用这些对象。我希望你能利用栈和队列对象，并寻找未来需要面向对象解决方案的问题。
