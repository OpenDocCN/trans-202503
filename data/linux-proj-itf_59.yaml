- en: 'Chapter 59. Sockets: Internet Domains'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第59章. 套接字：互联网域
- en: Having looked at generic sockets concepts and the TCP/IP protocol suite in previous
    chapters, we are now ready in this chapter to look at programming with sockets
    in the IPv4 (`AF_INET`) and IPv6 (`AF_INET6`) domains.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们已了解了通用套接字概念和TCP/IP协议套件，现在在本章中我们将开始探讨如何在IPv4（`AF_INET`）和IPv6（`AF_INET6`）域中进行套接字编程。
- en: 'As noted in [Chapter 58](ch58.html "Chapter 58. Sockets: Fundamentals of TCP/IP
    Networks"), Internet domain socket addresses consist of an IP address and a port
    number. Although computers use binary representations of IP addresses and port
    numbers, humans are much better at dealing with names than with numbers. Therefore,
    we describe the techniques used to identify host computers and ports using names.
    We also examine the use of library functions to obtain the IP address(es) for
    a particular hostname and the port number that corresponds to a particular service
    name. Our discussion of hostnames includes a description of the Domain Name System
    (DNS), which implements a distributed database that maps hostnames to IP addresses
    and vice versa.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[第58章](ch58.html "第58章. 套接字：TCP/IP 网络基础")中所述，互联网域套接字地址由IP地址和端口号组成。尽管计算机使用IP地址和端口号的二进制表示方式，但人类更擅长处理名称而非数字。因此，我们描述了使用名称识别主机计算机和端口的技术。我们还探讨了使用库函数获取特定主机名的IP地址和与特定服务名称对应的端口号的方法。关于主机名的讨论包括了域名系统（DNS）的描述，它实现了一个分布式数据库，用于将主机名映射到IP地址，反之亦然。
- en: Internet Domain Sockets
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互联网域套接字
- en: Internet domain stream sockets are implemented on top of TCP. They provide a
    reliable, bidirectional, byte-stream communication channel.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网域流套接字是基于TCP实现的。它们提供一个可靠的双向字节流通信通道。
- en: 'Internet domain datagram sockets are implemented on top of UDP. UDP sockets
    are similar to their UNIX domain counterparts, but note the following differences:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网域数据报套接字是基于UDP实现的。UDP套接字与其UNIX域对等物类似，但请注意以下区别：
- en: UNIX domain datagram sockets are reliable, but UDP sockets are not—datagrams
    may be lost, duplicated, or arrive in a different order from that in which they
    were sent.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UNIX域数据报套接字是可靠的，但UDP套接字则不是——数据报可能会丢失、重复，或到达的顺序与发送顺序不同。
- en: Sending on a UNIX domain datagram socket will block if the queue of data for
    the receiving socket is full. By contrast, with UDP, if the incoming datagram
    would overflow the receiver’s queue, then the datagram is silently dropped.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在UNIX域数据报套接字上发送数据时，如果接收套接字的数据队列已满，则会阻塞。相比之下，使用UDP时，如果传入的数据报会溢出接收方的队列，那么数据报会被悄无声息地丢弃。
- en: Network Byte Order
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络字节顺序
- en: IP addresses and port numbers are integer values. One problem we encounter when
    passing these values across a network is that different hardware architectures
    store the bytes of a multibyte integer in different orders. As shown in [Figure 59-1](ch59.html#big-endian_and_little-endian_byte_order
    "Figure 59-1. Big-endian and little-endian byte order for 2-byte and 4-byte integers"),
    architectures that store integers with the most significant byte first (i.e.,
    at the lowest memory address) are termed *big endian*; those that store the least
    significant byte first are termed *little endian*. (The terms derive from Jonathan
    Swift’s 1726 satirical novel *Gulliver’s Travels*, in which the terms refer to
    opposing political factions who open their boiled eggs at opposite ends.) The
    most notable example of a little-endian architecture is x86. (Digital’s VAX architecture
    was another historically important example, since BSD was widely used on that
    machine.) Most other architectures are big endian. A few hardware architectures
    are switchable between the two formats. The byte ordering used on a particular
    machine is called the *host byte order*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址和端口号是整数值。当我们将这些值通过网络传输时，遇到的一个问题是，不同的硬件架构以不同的顺序存储多字节整数的字节。如[图59-1](ch59.html#big-endian_and_little-endian_byte_order
    "图59-1. 2字节和4字节整数的大端和小端字节顺序")所示，存储整数时先存储最重要字节（即存储在最低内存地址处）的架构被称为*大端序*；而先存储最不重要字节的架构则被称为*小端序*。（这些术语源自乔纳森·斯威夫特在1726年出版的讽刺小说《格列佛游记》，其中这些术语指的是在开煮蛋时从不同端打开蛋的对立政治派别。）最典型的小端序架构是x86。（数字的VAX架构是另一个历史上重要的例子，因为BSD广泛用于该机器。）大多数其他架构都是大端序。一些硬件架构可以在两种格式之间切换。特定机器上使用的字节顺序被称为*主机字节顺序*。
- en: '![Big-endian and little-endian byte order for 2-byte and 4-byte integers](figs/web/59-1_SOCKINET-byte-order.png.jpg)Figure 59-1. Big-endian
    and little-endian byte order for 2-byte and 4-byte integers'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '![2字节和4字节整数的大端和小端字节序](figs/web/59-1_SOCKINET-byte-order.png.jpg)图59-1：2字节和4字节整数的大端和小端字节序'
- en: Since port numbers and IP addresses must be transmitted between, and understood
    by, all hosts on a network, a standard ordering must be used. This ordering is
    called *network byte order*, and happens to be big endian.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于端口号和IP地址必须在网络上的所有主机之间传输并被理解，因此必须使用标准的字节顺序。这个字节顺序称为*网络字节序*，它正好是大端字节序。
- en: Later in this chapter, we look at various functions that convert hostnames (e.g.,
    [www.kernel.org](http://www.kernel.org)) and service names (e.g., *http*) into
    the corresponding numeric forms. These functions generally return integers in
    network byte order, and these integers can be copied directly into the relevant
    fields of a socket address structure.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，我们将介绍各种函数，它们将主机名（例如，[www.kernel.org](http://www.kernel.org)）和服务名（例如，*http*）转换为相应的数字形式。这些函数通常返回网络字节序中的整数，这些整数可以直接复制到套接字地址结构的相关字段中。
- en: However, we sometimes make direct use of integer constants for IP addresses
    and port numbers. For example, we may choose to hard-code a port number into our
    program, specify a port number as a command-line argument to a program, or use
    constants such as `INADDR_ANY` and `INADDR_LOOPBACK` when specifying an IPv4 address.
    These values are represented in C according to the conventions of the host machine,
    so they are in host byte order. We must convert these values to network byte order
    before storing them in socket address structures.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们有时直接使用整数常量来表示IP地址和端口号。例如，我们可能会选择将端口号硬编码到程序中，作为程序的命令行参数指定端口号，或者在指定IPv4地址时使用`INADDR_ANY`和`INADDR_LOOPBACK`等常量。这些值在C语言中按照主机机器的约定表示，因此它们是主机字节序。我们必须在将这些值存储到套接字地址结构之前，将它们转换为网络字节序。
- en: The *htons(), htonl(), ntohs(), and ntohl()* functions are defined (typically
    as macros) for converting integers in either direction between host and network
    byte order.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*htons()，htonl()，ntohs()，ntohl()* 函数被定义（通常作为宏），用于在主机字节序和网络字节序之间进行整数的双向转换。'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns *host_uint16* converted to network byte order
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 返回*host_uint16*转换为网络字节序
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns *host_uint32* converted to network byte order
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 返回*host_uint32*转换为网络字节序
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns *net_uint16* converted to host byte order
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 返回*net_uint16*转换为主机字节序
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns *net_uint32* converted to host byte order
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 返回*net_uint32*转换为主机字节序
- en: 'In earlier times, these functions had prototypes such as the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期，这些函数的原型如下：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This reveals the origin of the function names—in this case, *host to network
    long*. On most early systems on which sockets were implemented, short integers
    were 16 bits, and long integers were 32 bits. This no longer holds true on modern
    systems (at least for long integers), so the prototypes given above provide a
    more exact definition of the types dealt with by these functions, although the
    names remain unchanged. The *uint16_t* and *uint32_t* data types are 16-bit and
    32-bit unsigned integers.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这揭示了函数名称的来源——在这种情况下是*host to network long*。在大多数早期实现套接字的系统中，短整型是16位，长整型是32位。但在现代系统中这一点已不再成立（至少对于长整型而言），因此上面给出的原型提供了更精确的类型定义，尽管函数名没有变化。*uint16_t*
    和 *uint32_t* 数据类型分别是16位和32位无符号整数。
- en: Strictly speaking, the use of these four functions is necessary only on systems
    where the host byte order differs from network byte order. However, these functions
    should always be used, so that programs are portable to different hardware architectures.
    On systems where the host byte order is the same as network byte order, these
    functions simply return their arguments unchanged.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，这四个函数的使用仅在主机字节序与网络字节序不同的系统上是必要的。然而，应该始终使用这些函数，以便程序能够在不同的硬件架构上移植。在主机字节序与网络字节序相同的系统上，这些函数仅返回未更改的参数。
- en: Data Representation
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据表示
- en: When writing network programs, we need to be aware of the fact that different
    computer architectures use different conventions for representing various data
    types. We have already noted that integer types can be stored in big-endian or
    little-endian form. There are also other possible differences. For example, the
    C *long* data type may be 32 bits on some systems and 64 bits on others. When
    we consider structures, the issue is further complicated by the fact that different
    implementations employ different rules for aligning the fields of a structure
    to address boundaries on the host system, leaving different numbers of padding
    bytes between the fields.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写网络程序时，我们需要意识到不同的计算机架构使用不同的约定来表示各种数据类型。我们已经提到，整数类型可以以大端序或小端序形式存储。还有其他可能的差异。例如，C语言中的*long*数据类型在某些系统上可能是32位，而在其他系统上是64位。当我们考虑结构体时，问题进一步复杂化，因为不同的实现会使用不同的规则将结构体的字段对齐到主机系统的地址边界，从而在字段之间留下不同数量的填充字节。
- en: Because of these differences in data representation, applications that exchange
    data between heterogeneous systems over a network must adopt some common convention
    for encoding that data. The sender must encode data according to this convention,
    while the receiver decodes following the same convention. The process of putting
    data into a standard format for transmission across a network is referred to as
    *marshalling*. Various marshalling standards exist, such as XDR (External Data
    Representation, described in RFC 1014), ASN.1-BER (Abstract Syntax Notation 1,
    [http://www.asn1.org/](http://www.asn1.org/)), CORBA, and XML. Typically, these
    standards define a fixed format for each data type (defining, for example, byte
    order and number of bits used). As well as being encoded in the required format,
    each data item is tagged with extra field(s) identifying its type (and, possibly,
    length).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据表示的差异，跨异构系统之间通过网络交换数据的应用程序必须采用某种共同的编码约定。发送方必须按照此约定对数据进行编码，而接收方则根据相同的约定进行解码。将数据转化为标准格式以便通过网络传输的过程称为*封送处理*。存在各种封送处理标准，例如
    XDR（外部数据表示，描述见 RFC 1014）、ASN.1-BER（抽象语法表示法 1，[http://www.asn1.org/](http://www.asn1.org/)）、CORBA
    和 XML。通常，这些标准为每种数据类型定义固定的格式（例如，定义字节顺序和使用的位数）。除了按照要求的格式进行编码外，每个数据项还会附加标识其类型（以及可能的长度）的额外字段。
- en: 'However, a simpler approach than marshalling is often employed: encode all
    transmitted data in text form, with separate data items delimited by a designated
    character, typically a newline character. One advantage of this approach is that
    we can use *telnet* to debug an application. To do this, we use the following
    command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常采用比封送处理更简单的方法：将所有传输的数据编码为文本形式，数据项通过指定字符（通常是换行符）分隔。此方法的一个优点是我们可以使用*telnet*来调试应用程序。为此，我们使用以下命令：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can then type lines of text to be transmitted to the application, and view
    the responses sent by the application. We demonstrate this technique in [Client-Server
    Example (Stream Sockets)](ch59.html#client-server_example_open_parenthesis_s "Client-Server
    Example (Stream Sockets)").
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以输入要传输到应用程序的文本行，并查看应用程序发送的响应。我们在[客户端-服务器示例（流套接字）](ch59.html#client-server_example_open_parenthesis_s
    "客户端-服务器示例（流套接字）")中演示了此技术。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The problems associated with differences in representation across heterogeneous
    systems apply not only to data transfer across a network, but also to any mechanism
    of data exchange between such systems. For example, we face the same problems
    when transferring files on disk or tape between heterogeneous systems. Network
    programming is simply the most common programming context in which we are nowadays
    likely to encounter this issue.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 跨异构系统的表示差异所带来的问题不仅适用于网络中的数据传输，还适用于这些系统之间的任何数据交换机制。例如，在不同异构系统之间传输磁盘或磁带文件时，我们也面临相同的问题。网络编程只是我们当前最常遇到这一问题的编程场景。
- en: If we encode data transmitted on a stream socket as newline-delimited text,
    then it is convenient to define a function such as *readLine()*, shown in [Example 59-1](ch59.html#reading_data_a_line_at_a_time
    "Example 59-1. Reading data a line at a time").
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将通过流套接字传输的数据编码为以换行符分隔的文本，则可以方便地定义一个像*readLine()*这样的函数，示例见[示例 59-1](ch59.html#reading_data_a_line_at_a_time
    "示例 59-1. 一次读取一行数据")。
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of bytes copied into *buffer* (excluding terminating null byte),
    or 0 on end-of-file, or -1 on error
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 返回复制到*缓冲区*中的字节数（不包括终止的空字节），如果是文件结尾则返回0，出错时返回-1
- en: The *readLine()* function reads bytes from the file referred to by the file
    descriptor argument *fd* until a newline is encountered. The input byte sequence
    is returned in the location pointed to by *buffer*, which must point to a region
    of at least *n* bytes of memory. The returned string is always null-terminated;
    thus, at most *(n - 1)* bytes of actual data will be returned. On success, *readLine()*
    returns the number of bytes of data placed in *buffer*; the terminating null byte
    is not included in this count.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*readLine()*函数从由文件描述符参数*fd*引用的文件中读取字节，直到遇到换行符为止。输入的字节序列将返回到*buffer*指向的位置，*buffer*必须指向至少*n*字节的内存区域。返回的字符串总是以null终止；因此，最多会返回*(n
    - 1)*个实际数据字节。成功时，*readLine()*返回存入*buffer*的字节数；终止空字节不包括在此计数中。'
- en: Example 59-1. Reading data a line at a time
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 59-1。逐行读取数据
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the number of bytes read before a newline is encountered is greater than
    or equal to *(n - 1)*, then the *readLine()* function discards the excess bytes
    (including the newline). If a newline was read within the first *(n - 1)* bytes,
    then it is included in the returned string. (Thus, we can determine if bytes were
    discarded by checking if a newline precedes the terminating null byte in the returned
    *buffer*.) We take this approach so that application protocols that rely on handling
    input in units of lines don’t end up processing a long line as though it were
    multiple lines. This would likely break the protocol, as the applications on either
    end would become desynchronized. An alternative approach would be to have *readLine()*
    read only sufficient bytes to fill the supplied buffer, leaving any remaining
    bytes up to the next newline for the next call to *readLine()*. In this case,
    the caller of *readLine()* would need to handle the possibility of a partial line
    being read.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在遇到换行符之前读取的字节数大于或等于*(n - 1)*，则*readLine()*函数会丢弃多余的字节（包括换行符）。如果在前*(n - 1)*个字节内读取到了换行符，则它会包含在返回的字符串中。（因此，我们可以通过检查返回的*buffer*中的换行符是否位于终止空字节之前，来确定是否丢弃了字节。）我们采取这种方法是为了确保依赖于按行处理输入的应用协议，不会将长行误处理为多行。这可能会破坏协议，因为两端的应用程序将会不同步。另一种方法是让*readLine()*只读取足够的字节以填充提供的缓冲区，将剩余的字节（直到下一个换行符）留给下一次调用*readLine()*。在这种情况下，*readLine()*的调用者需要处理可能读取到部分行的情况。
- en: We employ the *readLine()* function in the example programs presented in [Client-Server
    Example (Stream Sockets)](ch59.html#client-server_example_open_parenthesis_s "Client-Server
    Example (Stream Sockets)").
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在[客户端-服务器示例（流套接字）](ch59.html#client-server_example_open_parenthesis_s "客户端-服务器示例（流套接字）")中，我们在示例程序中使用了*readLine()*函数。
- en: Internet Socket Addresses
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互联网套接字地址
- en: 'There are two types of Internet domain socket addresses: IPv4 and IPv6.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的互联网域套接字地址：IPv4和IPv6。
- en: 'IPv4 socket addresses: *struct sockaddr_in*'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IPv4套接字地址：*struct sockaddr_in*
- en: 'An IPv4 socket address is stored in a *sockaddr_in* structure, defined in `<netinet/in.h>`
    as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4套接字地址存储在*sockaddr_in*结构中，定义在`<netinet/in.h>`中，具体如下：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In [Generic Socket Address Structures: *struct sockaddr*](ch56.html#generic_socket_address_structures_colon
    "Generic Socket Address Structures: struct sockaddr"), we saw that the generic
    *sockaddr* structure commences with a field identifying the socket domain. This
    corresponds to the *sin_family* field in the *sockaddr_in* structure, which is
    always set to `AF_INET`. The *sin_port* and *sin_addr* fields are the port number
    and the IP address, both in network byte order. The *in_port_t* and *in_addr_t*
    data types are unsigned integer types, 16 and 32 bits in length, respectively.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在[通用套接字地址结构：*struct sockaddr*](ch56.html#generic_socket_address_structures_colon
    "通用套接字地址结构：struct sockaddr")中，我们看到通用的*sockaddr*结构开始时有一个字段，用来标识套接字域。这对应于*sockaddr_in*结构中的*sin_family*字段，该字段始终设置为`AF_INET`。*sin_port*和*sin_addr*字段分别是端口号和IP地址，都是网络字节顺序。*in_port_t*和*in_addr_t*数据类型分别是无符号整数类型，长度为16位和32位。
- en: 'IPv6 socket addresses: *struct sockaddr_in6*'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IPv6套接字地址：*struct sockaddr_in6*
- en: 'Like an IPv4 address, an IPv6 socket address includes an IP address plus a
    port number. The difference is that an IPv6 address is 128 bits instead of 32
    bits. An IPv6 socket address is stored in a *sockaddr_in6* structure, defined
    in `<netinet/in.h>` as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与IPv4地址类似，IPv6套接字地址包含IP地址和端口号。不同之处在于，IPv6地址是128位而不是32位。IPv6套接字地址存储在*sockaddr_in6*结构中，定义在`<netinet/in.h>`中，具体如下：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The *sin_family* field is set to `AF_INET6`. The *sin6_port* and *sin6_addr*
    fields are the port number and the IP address. (The *uint8_t* data type, used
    to type the bytes of the *in6_addr* structure, is an 8-bit unsigned integer.)
    The remaining fields, *sin6_flowinfo* and *sin6_scope_id*, are beyond the scope
    of this book; for our purposes, they are always set to 0\. All of the fields in
    the *sockaddr_in6* structure are in network byte order.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*sin_family* 字段被设置为 `AF_INET6`。*sin6_port* 和 *sin6_addr* 字段分别是端口号和 IP 地址。（*uint8_t*
    数据类型，用于定义 *in6_addr* 结构体的字节，是一个 8 位无符号整数。）其余字段，*sin6_flowinfo* 和 *sin6_scope_id*，超出了本书的讨论范围；就我们的目的而言，它们始终被设置为
    0。*sockaddr_in6* 结构体中的所有字段都采用网络字节顺序。'
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: IPv6 addresses are described in RFC 4291\. Information about IPv6 flow control
    (*sin6_flowinfo*) can be found in [Appendix A](apa.html "Appendix A. Tracing System
    Calls") of [Stevens et al., 2004] and in RFCs 2460 and 3697\. RFCs 3493 and 4007
    provide information about *sin6_scope_id*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 地址在 RFC 4291 中进行了描述。有关 IPv6 流量控制（*sin6_flowinfo*）的信息可以在[附录 A](apa.html
    "附录 A. 跟踪系统调用")中找到，此外，RFC 2460 和 3697 也包含相关信息。RFC 3493 和 4007 提供了关于 *sin6_scope_id*
    的信息。
- en: 'IPv6 has equivalents of the IPv4 wildcard and loopback addresses. However,
    their use is complicated by the fact that an IPv6 address is stored in an array
    (rather than using a scalar type). We use the IPv6 wildcard address (`0::0`) to
    illustrate this point. The constant `IN6ADDR_ANY_INIT` is defined for this address
    as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 有与 IPv4 通配符地址和回环地址等效的地址。然而，它们的使用较为复杂，因为 IPv6 地址是存储在数组中的（而不是使用标量类型）。我们使用
    IPv6 通配符地址（`0::0`）来说明这一点。这个地址的常量 `IN6ADDR_ANY_INIT` 定义如下：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux, some details in the header files differ from our description in this
    section. In particular, the *in6_addr* structure contains a union definition that
    divides the 128-bit IPv6 address into 16 bytes, eight 2-byte integers, or four
    32-byte integers. Because of the presence of this definition, the *glibc* definition
    of the `IN6ADDR_ANY_INIT` constant actually includes one more set of nested braces
    than is shown in the main text.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，某些头文件的细节与本节中的描述有所不同。特别是，*in6_addr* 结构体包含一个联合体定义，将 128 位的 IPv6 地址分成
    16 个字节，八个 2 字节整数，或者四个 32 字节整数。由于存在这个定义，*glibc* 对 `IN6ADDR_ANY_INIT` 常量的定义实际上包含比主文本中显示的更多的嵌套大括号。
- en: 'We can use the `IN6ADDR_ANY_INIT` constant in the initializer that accompanies
    a variable declaration, but can’t use it on the right-hand side of an assignment
    statement, since C syntax doesn’t permit structured constants to be used in assignments.
    Instead, we must use a predefined variable, *in6addr_any*, which is initialized
    as follows by the C library:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在伴随变量声明的初始化器中使用 `IN6ADDR_ANY_INIT` 常量，但不能在赋值语句的右侧使用它，因为 C 语法不允许在赋值中使用结构常量。相反，我们必须使用一个预定义的变量
    *in6addr_any*，该变量由 C 库按照如下方式初始化：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Thus, we can initialize an IPv6 socket address structure using the wildcard
    address as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用通配符地址初始化 IPv6 套接字地址结构，如下所示：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The corresponding constant and variable for the IPv6 loopback address (`::1`)
    are `IN6ADDR_LOOPBACK_INIT` and *in6addr_loopback*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的 IPv6 回环地址 (`::1`) 的常量和变量是 `IN6ADDR_LOOPBACK_INIT` 和 *in6addr_loopback*。
- en: Unlike their IPv4 counterparts, the IPv6 constant and variable initializers
    are in network byte order. But, as shown in the above code, we still must ensure
    that the port number is in network byte order.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与 IPv4 地址不同，IPv6 常量和变量初始化器采用网络字节顺序。但正如上面代码所示，我们仍然需要确保端口号采用网络字节顺序。
- en: If IPv4 and IPv6 coexist on a host, they share the same port-number space. This
    means that if, for example, an application binds an IPv6 socket to TCP port 2000
    (using the IPv6 wildcard address), then an IPv4 TCP socket can’t be bound to the
    same port. (The TCP/IP implementation ensures that sockets on other hosts are
    able to communicate with this socket, regardless of whether those hosts are running
    IPv4 or IPv6.)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 IPv4 和 IPv6 在同一主机上共存，它们共享相同的端口号空间。这意味着，如果某个应用程序将 IPv6 套接字绑定到 TCP 端口 2000（使用
    IPv6 通配符地址），那么 IPv4 TCP 套接字就不能绑定到相同的端口。（TCP/IP 实现确保其他主机上的套接字能够与此套接字进行通信，无论这些主机运行的是
    IPv4 还是 IPv6。）
- en: The *sockaddr_storage* structure
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*sockaddr_storage* 结构体'
- en: 'With the IPv6 sockets API, the new generic *sockaddr_storage* structure was
    introduced. This structure is defined to be large enough to hold any type of socket
    address (i.e., any type of socket address structure can be cast and stored in
    it). In particular, this structure allows us to transparently store either an
    IPv4 or an IPv6 socket address, thus removing IP version dependencies from our
    code. The *sockaddr_storage* structure is defined on Linux as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 IPv6 套接字 API 的推出，引入了新的通用 *sockaddr_storage* 结构。该结构被定义为足够大，以容纳任何类型的套接字地址（即，任何类型的套接字地址结构都可以被强制转换并存储在其中）。特别地，该结构使我们能够透明地存储
    IPv4 或 IPv6 套接字地址，从而消除了代码中的 IP 版本依赖性。*sockaddr_storage* 结构在 Linux 中的定义如下：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Overview of Host and Service Conversion Functions
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机和服务转换函数概述
- en: Computers represent IP addresses and port numbers in binary. However, humans
    find names easier to remember than numbers. Employing symbolic names also provides
    a useful level of indirection; users and programs can continue to use the same
    name even if the underlying numeric value changes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机将 IP 地址和端口号表示为二进制。然而，人类更容易记住名字而不是数字。使用符号名称还提供了一种有用的间接性；即使底层的数字值发生变化，用户和程序仍然可以继续使用相同的名称。
- en: A *hostname* is the symbolic identifier for a system that is connected to a
    network (possibly with multiple IP addresses). A *service name* is the symbolic
    representation of a port number.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*主机名* 是连接到网络的系统的符号标识符（可能有多个 IP 地址）。*服务名称* 是端口号的符号表示。'
- en: 'The following methods are available for representing host addresses and ports:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是表示主机地址和端口的方法：
- en: A host address can be represented as a binary value, as a symbolic hostname,
    or in presentation format (dotted-decimal for IPv4 or hex-string for IPv6).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机地址可以表示为二进制值、符号主机名或表示格式（IPv4 的点分十进制或 IPv6 的十六进制字符串）。
- en: A port can be represented as a binary value or as a symbolic service name.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口可以表示为二进制值或符号服务名称。
- en: Various library functions are provided for converting between these formats.
    This section briefly summarizes these functions. The following sections describe
    the modern APIs (*inet_ntop()*, *inet_pton()*, *getaddrinfo()*, *getnameinfo()*,
    and so on) in detail. In [Obsolete APIs for Host and Service Conversions](ch59.html#obsolete_apis_for_host_and_service_conve
    "Obsolete APIs for Host and Service Conversions"), we briefly discuss the obsolete
    APIs (*inet_aton()*, *inet_ntoa()*, *gethostbyname()*, *getservbyname()*, and
    so on).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了各种库函数，用于在这些格式之间进行转换。本节简要总结了这些函数。接下来的章节将详细描述现代 API（*inet_ntop()*、*inet_pton()*、*getaddrinfo()*、*getnameinfo()*
    等）。在[过时的主机和服务转换 API](ch59.html#obsolete_apis_for_host_and_service_conve "过时的主机和服务转换
    API")中，我们简要讨论了过时的 API（*inet_aton()*、*inet_ntoa()*、*gethostbyname()*、*getservbyname()*
    等）。
- en: Converting IPv4 addresses between binary and human-readable forms
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在二进制和人类可读格式之间转换 IPv4 地址
- en: The *inet_aton()* and *inet_ntoa()* functions convert an IPv4 address in dotted-decimal
    notation to binary and vice versa. We describe these functions primarily because
    they appear in historical code. Nowadays, they are obsolete. Modern programs that
    need to do such conversions should use the functions that we describe next.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*inet_aton()* 和 *inet_ntoa()* 函数将点分十进制表示法中的 IPv4 地址转换为二进制格式，并反之亦然。我们主要描述这些函数，因为它们出现在历史代码中。如今，它们已经过时。现代程序如果需要进行此类转换，应使用我们接下来描述的函数。'
- en: Converting IPv4 and IPv6 addresses between binary and human-readable forms
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在二进制和人类可读格式之间转换 IPv4 和 IPv6 地址
- en: The *inet_pton()* and *inet_ntop()* functions are like *inet_aton()* and *inet_ntoa()*,
    but differ in that they also handle IPv6 addresses. They convert binary IPv4 and
    IPv6 addresses to and from *presentation* format—that is, either dotted-decimal
    or hex-string notation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*inet_pton()* 和 *inet_ntop()* 函数类似于 *inet_aton()* 和 *inet_ntoa()*，但不同之处在于它们还处理
    IPv6 地址。它们将二进制的 IPv4 和 IPv6 地址转换为并从 *表示* 格式转换——即点分十进制或十六进制字符串表示法。'
- en: 'Since humans deal better with names than with numbers, we normally use these
    functions only occasionally in programs. One use of *inet_ntop()* is to produce
    a printable representation of an IP address for logging purposes. Sometimes, it
    is preferable to use this function instead of converting (“resolving”) an IP address
    to a hostname, for the following reasons:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于人类处理名字比处理数字更为轻松，我们通常在程序中仅偶尔使用这些函数。*inet_ntop()* 的一个用途是生成可打印的 IP 地址表示形式，以供日志记录使用。有时，使用此函数而不是将
    IP 地址转换（“解析”）为主机名是更可取的，原因如下：
- en: Resolving an IP address to a hostname involves a possibly time-consuming request
    to a DNS server.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析 IP 地址到主机名可能涉及到向 DNS 服务器发送一个可能耗时的请求。
- en: In some circumstances, there may not be a DNS (PTR) record that maps the IP
    address to a corresponding hostname.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，可能没有 DNS（PTR）记录将 IP 地址映射到相应的主机名。
- en: We describe these functions (in [The *inet_pton()* and *inet_ntop()* Functions](ch59.html#the_inet_underscore_pton_open_parenthesi
    "The inet_pton() and inet_ntop() Functions")) before *getaddrinfo()* and *getnameinfo()*,
    which perform conversions between binary representations and the corresponding
    symbolic names, principally because they present a much simpler API. This allows
    us to quickly show some working examples of the use of Internet domain sockets.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [《*inet_pton()* 和 *inet_ntop()* 函数](ch59.html#the_inet_underscore_pton_open_parenthesi
    "The inet_pton() and inet_ntop() Functions")](ch59.html#the_inet_underscore_pton_open_parenthesi)
    中描述了这些函数，*getaddrinfo()* 和 *getnameinfo()* 在它们之前，它们执行二进制表示和相应符号名称之间的转换，主要是因为它们提供了一个更简单的
    API。这使我们能够快速展示一些使用互联网域套接字的工作示例。
- en: Converting host and service names to and from binary form (obsolete)
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将主机和服务名称转换为二进制形式（已废弃）
- en: The *gethostbyname()* function returns the binary IP address(es) corresponding
    to a hostname and the *getservbyname()* function returns the port number corresponding
    to a service name. The reverse conversions are performed by *gethostbyaddr()*
    and *getservbyport()*. We describe these functions because they are widely used
    in existing code. However, they are now obsolete. (SUSv3 marks these functions
    obsolete, and SUSv4 removes their specifications.) New code should use the *getaddrinfo()*
    and *getnameinfo()* functions (described next) for such conversions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*gethostbyname()* 函数返回与主机名对应的二进制 IP 地址，而 *getservbyname()* 函数返回与服务名称对应的端口号。反向转换由
    *gethostbyaddr()* 和 *getservbyport()* 完成。我们描述这些函数是因为它们在现有代码中广泛使用。然而，它们现在已被废弃。（SUSv3
    标记这些函数为废弃，SUSv4 删除了它们的规格。）新代码应使用 *getaddrinfo()* 和 *getnameinfo()* 函数（接下来将描述）来进行这些转换。'
- en: Converting host and service names to and from binary form (modern)
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将主机和服务名称转换为二进制形式（现代）
- en: The *getaddrinfo()* function is the modern successor to both *gethostbyname()*
    and *getservbyname()*. Given a hostname and a service name, *getaddrinfo()* returns
    a set of structures containing the corresponding binary IP address(es) and port
    number. Unlike *gethostbyname()*, *getaddrinfo()* transparently handles both IPv4
    and IPv6 addresses. Thus, we can use it to write programs that don’t contain dependencies
    on the IP version being employed. All new code should use *getaddrinfo()* for
    converting hostnames and service names to binary representation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*getaddrinfo()* 函数是 *gethostbyname()* 和 *getservbyname()* 的现代替代者。给定一个主机名和一个服务名，*getaddrinfo()*
    返回一个包含相应二进制 IP 地址和端口号的结构集合。与 *gethostbyname()* 不同，*getaddrinfo()* 透明地处理 IPv4 和
    IPv6 地址。因此，我们可以使用它编写不依赖于所使用 IP 版本的程序。所有新代码应使用 *getaddrinfo()* 将主机名和服务名转换为二进制表示。'
- en: The *getnameinfo()* function performs the reverse translation, converting an
    IP address and port number into the corresponding hostname and service name.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*getnameinfo()* 函数执行反向转换，将 IP 地址和端口号转换为相应的主机名和服务名。'
- en: We can also use *getaddrinfo()* and *getnameinfo()* to convert binary IP addresses
    to and from presentation format.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 *getaddrinfo()* 和 *getnameinfo()* 将二进制 IP 地址转换为表示格式，或将其从表示格式转换回来。
- en: The discussion of *getaddrinfo()* and *getnameinfo()*, in [Protocol-Independent
    Host and Service Conversion](ch59.html#protocol-independent_host_and_service_co
    "Protocol-Independent Host and Service Conversion"), requires an accompanying
    description of DNS ([Domain Name System (DNS)](ch59.html#domain_name_system_open_parenthesis_dns
    "Domain Name System (DNS)")) and the `/etc/services` file ([The `/etc/services`
    File](ch59.html#the_solidus_etc_solidus_services_file "The /etc/services File")).
    DNS allows cooperating servers to maintain a distributed database that maps binary
    IP addresses to hostnames and vice versa. The existence of a system such as DNS
    is essential to the operation of the Internet, since centralized management of
    the enormous set of Internet hostnames would be impossible. The `/etc/services`
    file maps port numbers to symbolic service names.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [协议独立的主机和服务转换](ch59.html#protocol-independent_host_and_service_co "协议独立的主机和服务转换")
    中讨论的 *getaddrinfo()* 和 *getnameinfo()*，需要附带描述 DNS（[域名系统 (DNS)](ch59.html#domain_name_system_open_parenthesis_dns
    "域名系统 (DNS)")) 和 `/etc/services` 文件（[`/etc/services` 文件](ch59.html#the_solidus_etc_solidus_services_file
    "The /etc/services File")）。DNS 允许合作的服务器维护一个分布式数据库，将二进制 IP 地址映射到主机名，反之亦然。像 DNS
    这样的系统的存在对于互联网的运作至关重要，因为集中管理庞大的互联网主机名集合是不可能的。`/etc/services` 文件将端口号映射到符号服务名称。
- en: The *inet_pton()* and *inet_ntop()* Functions
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*inet_pton()* 和 *inet_ntop()* 函数'
- en: The *inet_pton()* and *inet_ntop()* functions allow conversion of both IPv4
    and IPv6 addresses between binary form and dotted-decimal or hex-string notation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*inet_pton()* 和 *inet_ntop()* 函数允许将 IPv4 和 IPv6 地址在二进制形式和点分十进制或十六进制字符串表示法之间进行转换。'
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 1 on successful conversion, 0 if *src_str* is not in presentation format,
    or -1 on error
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 成功转换时返回 1，如果 *src_str* 不是表示形式格式，则返回 0，或者在错误时返回 -1。
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to *dst_str* on success, or NULL on error
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回指向 *dst_str* 的指针，错误时返回 NULL。
- en: 'The *p* in the names of these functions stands for “presentation,” and the
    n stands for “network.” The presentation form is a human-readable string, such
    as the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数名称中的 *p* 代表“表示形式”（presentation），而 n 代表“网络”（network）。表示形式是人类可读的字符串，例如以下示例：
- en: '`204.152.189.116` (IPv4 dotted-decimal address);'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`204.152.189.116`（IPv4 点分十进制地址）；'
- en: '`::1` (an IPv6 colon-separated hexadecimal address); or'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`::1`（IPv6 冒号分隔的十六进制地址）；或者'
- en: '`::FFFF:204.152.189.116` (an IPv4-mapped IPv6 address).'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`::FFFF:204.152.189.116`（IPv4 映射的 IPv6 地址）。'
- en: The *inet_pton()* function converts the presentation string contained in *src_str*
    into a binary IP address in network byte order. The *domain* argument should be
    specified as either `AF_INET` or `AF_INET6`. The converted address is placed in
    the structure pointed to by *addrptr*, which should point to either an *in_addr*
    or an *in6_addr* structure, according to the value specified in *domain*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*inet_pton()* 函数将 *src_str* 中包含的表示字符串转换为网络字节顺序的二进制 IP 地址。*domain* 参数应指定为 `AF_INET`
    或 `AF_INET6`。转换后的地址将放置在 *addrptr* 指向的结构体中，*addrptr* 应该指向一个 *in_addr* 或 *in6_addr*
    结构体，这取决于 *domain* 中指定的值。'
- en: The *inet_ntop()* function performs the reverse conversion. Again, *domain*
    should be specified as either `AF_INET` or `AF_INET6`, and *addrptr* should point
    to an *in_addr* or *in6_addr* structure that we wish to convert. The resulting
    null-terminated string is placed in the buffer pointed to by *dst_str*. The *len*
    argument must specify the size of this buffer. On success, *inet_ntop()* returns
    *dst_str*. If *len* is too small, then *inet_ntop()* returns `NULL`, with *errno*
    set to `ENOSPC`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*inet_ntop()* 函数执行反向转换。同样，*domain* 应该指定为 `AF_INET` 或 `AF_INET6`，*addrptr* 应该指向我们希望转换的
    *in_addr* 或 *in6_addr* 结构体。转换后的以空字符终止的字符串将被放置在 *dst_str* 指向的缓冲区中。*len* 参数必须指定该缓冲区的大小。成功时，*inet_ntop()*
    返回 *dst_str*。如果 *len* 太小，则 *inet_ntop()* 返回 `NULL`，并将 *errno* 设置为 `ENOSPC`。'
- en: 'To correctly size the buffer pointed to by *dst_str*, we can employ two constants
    defined in `<netinet/in.h>`. These constants indicate the maximum lengths (including
    the terminating null byte) of the presentation strings for IPv4 and IPv6 addresses:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确设置 *dst_str* 指向的缓冲区大小，我们可以使用 `<netinet/in.h>` 中定义的两个常量。这些常量表示 IPv4 和 IPv6
    地址的表示字符串的最大长度（包括终止的空字节）：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We provide examples of the use of *inet_pton()* and *inet_ntop()* in the next
    section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节提供 *inet_pton()* 和 *inet_ntop()* 使用的示例。
- en: Client-Server Example (Datagram Sockets)
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端-服务器示例（数据报套接字）
- en: In this section, we take the case-conversion server and client programs shown
    in [Datagram Sockets in the UNIX Domain](ch57.html#datagram_sockets_in_the_unix_domain
    "Datagram Sockets in the UNIX Domain") and modify them to use datagram sockets
    in the `AF_INET6` domain. We present these programs with a minimum of commentary,
    since their structure is similar to the earlier programs. The main differences
    in the new programs lie in the declaration and initialization of the IPv6 socket
    address structure, which we described in Section 59.4.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将[UNIX域中的数据报套接字](ch57.html#datagram_sockets_in_the_unix_domain "UNIX域中的数据报套接字")中展示的大小写转换服务器和客户端程序修改为使用`AF_INET6`域中的数据报套接字。由于其结构与早期的程序类似，我们将以最少的注释来展示这些程序。新程序的主要区别在于IPv6套接字地址结构的声明和初始化，我们在第59.4节中对此进行了描述。
- en: The client and server both employ the header file shown in [Example 59-2](ch59.html#header_file_used_by_i6d_underscore_ucase
    "Example 59-2. Header file used by i6d_ucase_sv.c and i6d_ucase_cl.c"). This header
    file defines the server’s port number and the maximum size of messages that the
    client and server can exchange.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器都使用了[示例 59-2](ch59.html#header_file_used_by_i6d_underscore_ucase "示例
    59-2. `i6d_ucase_sv.c`和`i6d_ucase_cl.c`使用的头文件")中展示的头文件。该头文件定义了服务器的端口号以及客户端和服务器可以交换的最大消息大小。
- en: Example 59-2. Header file used by `i6d_ucase_sv.c` and `i6d_ucase_cl.c`
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 59-2. `i6d_ucase_sv.c`和`i6d_ucase_cl.c`使用的头文件
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Example 59-3](ch59.html#ipv6_case-conversion_server_using_datagr "Example 59-3. IPv6
    case-conversion server using datagram sockets") shows the server program. The
    server uses the *inet_ntop()* function to convert the host address of the client
    (obtained via the *recvfrom()* call) to printable form.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 59-3](ch59.html#ipv6_case-conversion_server_using_datagr "示例 59-3. 使用数据报套接字的IPv6大小写转换服务器")展示了服务器程序。服务器使用*inet_ntop()*函数将客户端的主机地址（通过*recvfrom()*调用获得）转换为可打印的形式。'
- en: 'The client program shown in [Example 59-4](ch59.html#ipv6_case-conversion_client_using_datagr
    "Example 59-4. IPv6 case-conversion client using datagram sockets") contains two
    notable modifications from the earlier UNIX domain version ([Example 57-7](ch57.html#a_simple_unix_domain_datagram_client
    "Example 57-7. A simple UNIX domain datagram client"), in [Example program](ch57.html#example_program-id72
    "Example program")). The first difference is that the client interprets its initial
    command-line argument as the IPv6 address of the server. (The remaining command-line
    arguments are passed as separate datagrams to the server.) The client converts
    the server address to binary form using *inet_pton()*. The other difference is
    that the client doesn’t bind its socket to an address. As noted in [Port Numbers](ch58.html#port_numbers
    "Port Numbers"), if an Internet domain socket is not bound to an address, the
    kernel binds the socket to an ephemeral port on the host system. We can observe
    this in the following shell session log, where we run the server and the client
    on the same host:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 59-4](ch59.html#ipv6_case-conversion_client_using_datagr "示例 59-4. 使用数据报套接字的IPv6大小写转换客户端")中显示的客户端程序，相比早期的UNIX域版本([示例
    57-7](ch57.html#a_simple_unix_domain_datagram_client "示例 57-7. 一个简单的UNIX域数据报客户端"),
    在[示例程序](ch57.html#example_program-id72 "示例程序")中)，有两个显著的修改。第一个区别是客户端将其初始的命令行参数解释为服务器的IPv6地址。（剩余的命令行参数作为单独的数据报传递给服务器。）客户端使用*inet_pton()*将服务器地址转换为二进制形式。另一个区别是客户端没有将其套接字绑定到地址。如[端口号](ch58.html#port_numbers
    "端口号")中所述，如果一个互联网域套接字没有绑定到地址，内核会将套接字绑定到主机系统的一个临时端口。我们可以在以下的Shell会话日志中观察到这一点，在该日志中，我们在同一主机上运行了服务器和客户端：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: From the above output, we see that the server’s *recvfrom()* call was able to
    obtain the address of the client’s socket, including the ephemeral port number,
    despite the fact that the client did not do a *bind()*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述输出中，我们看到服务器的*recvfrom()*调用能够获得客户端套接字的地址，包括临时端口号，尽管客户端没有进行*bind()*操作。
- en: Example 59-3. IPv6 case-conversion server using datagram sockets
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 59-3. 使用数据报套接字的IPv6大小写转换服务器
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Example 59-4. IPv6 case-conversion client using datagram sockets
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 59-4. 使用数据报套接字的IPv6大小写转换客户端
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Domain Name System (DNS)
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 域名系统（DNS）
- en: In [Protocol-Independent Host and Service Conversion](ch59.html#protocol-independent_host_and_service_co
    "Protocol-Independent Host and Service Conversion"), we describe *getaddrinfo()*,
    which obtains the IP address(es) corresponding to a hostname, and *getnameinfo()*,
    which performs the converse task. However, before looking at these functions,
    we explain how DNS is used to maintain the mappings between hostnames and IP addresses.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在[协议无关的主机与服务转换](ch59.html#protocol-independent_host_and_service_co "Protocol-Independent
    Host and Service Conversion")中，我们描述了 *getaddrinfo()*，它获取与主机名对应的IP地址，以及 *getnameinfo()*，它执行反向操作。然而，在查看这些函数之前，我们将先解释如何使用DNS来维护主机名与IP地址之间的映射。
- en: 'Before the advent of DNS, mappings between hostnames and IP addresses were
    defined in a manually maintained local file, `/etc/hosts`, containing records
    of the following form:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在DNS出现之前，主机名与IP地址之间的映射是定义在一个手动维护的本地文件`/etc/hosts`中的，该文件包含如下形式的记录：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The *gethostbyname()* function (the predecessor to *getaddrinfo()*) obtained
    an IP address by searching this file, looking for a match on either the canonical
    hostname (i.e., the official or primary name of the host) or one of the (optional,
    space-delimited) aliases.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*gethostbyname()* 函数（*getaddrinfo()* 的前身）通过搜索此文件来获取IP地址，寻找与规范主机名（即主机的官方或主名称）或其中一个（可选的、空格分隔的）别名匹配的记录。'
- en: However, the `/etc/hosts` scheme scales poorly, and then becomes impossible,
    as the number of hosts in the network increases (e.g., the Internet, with millions
    of hosts).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`/etc/hosts` 方案的扩展性较差，随着网络中主机数量的增加（例如互联网，拥有数百万主机），这种方法变得不可行。
- en: 'DNS was devised to address this problem. The key ideas of DNS are the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: DNS的设计就是为了解决这个问题。DNS的关键思想如下：
- en: Hostnames are organized into a hierarchical namespace ([Figure 59-2](ch59.html#a_subset_of_the_dns_hierarchy
    "Figure 59-2. A subset of the DNS hierarchy")). Each *node* in the DNS hierarchy
    has a *label* (name), which may be up to 63 characters. At the root of the hierarchy
    is an unnamed node, the “anonymous root.”
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机名被组织成一个层次化的命名空间（[图59-2](ch59.html#a_subset_of_the_dns_hierarchy "Figure 59-2.
    A subset of the DNS hierarchy")）。DNS层次结构中的每个*节点*都有一个*标签*（名称），该名称最多可以包含63个字符。层次结构的根节点是一个没有名称的节点，称为“匿名根节点”。
- en: A node’s *domain name* consists of all of the names from that node up to the
    root concatenated together, with each name separated by a period (`.`). For example,
    `google.com` is the domain name for the node `google`.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个节点的*域名*由从该节点到根节点的所有名称组成，名称之间用句点（`.`）分隔。例如，`google.com` 是节点 `google` 的域名。
- en: A *fully qualified domain name* (FQDN), such as [www.kernel.org](http://www.kernel.org).,
    identifies a host within the hierarchy. A fully qualified domain name is distinguished
    by being terminated by a period, although in many contexts the period may be omitted.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*完全限定域名*（FQDN），例如 [www.kernel.org](http://www.kernel.org)。，在层级结构中标识一个主机。完全限定域名的特点是以句点结尾，尽管在许多上下文中，句点可能会被省略。'
- en: No single organization or system manages the entire hierarchy. Instead, there
    is a hierarchy of DNS servers, each of which manages a branch (a *zone*) of the
    tree. Normally, each zone has a *primary master name server*, and one or more
    *slave name servers* (sometimes also known as *secondary master name servers*),
    which provide backup in the event that the primary master name server crashes.
    Zones may themselves be divided into separately managed smaller zones. When a
    host is added within a zone, or the mapping of a hostname to an IP address is
    changed, the administrator responsible for the corresponding local name server
    updates the name database on that server. (No manual changes are required on any
    other name-server databases in the hierarchy.)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有单一的组织或系统管理整个层级结构。相反，存在一个DNS服务器层级，每个服务器管理树的一个分支（*区域*）。通常，每个区域有一个*主名称服务器*，以及一个或多个*从名称服务器*（有时也称为*二级主名称服务器*），它们在主名称服务器崩溃时提供备份。区域本身也可以被划分为多个单独管理的较小区域。当在区域内添加主机，或更改主机名到IP地址的映射时，负责相应本地名称服务器的管理员会更新该服务器上的名称数据库。（层级结构中其他任何名称服务器数据库无需手动更改。）
- en: Note
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The DNS server implementation employed on Linux is the widely used Berkeley
    Internet Name Domain (BIND) implementation, *named(8)*, maintained by the *Internet
    Systems Consortium* ([http://www.isc.org/](http://www.isc.org/)). The operation
    of this daemon is controlled by the file `/etc/named.conf` (see the *named.conf(5)*
    manual page). The key reference on DNS and BIND is [Albitz & Liu, 2006]. Information
    about DNS can also be found in [Chapter 14](ch14.html "Chapter 14. File Systems")
    of [Stevens, 1994], [Chapter 11](ch11.html "Chapter 11. System Limits and Options")
    of [Stevens et al., 2004], and [Chapter 24](ch24.html "Chapter 24. Process Creation")
    of [Comer, 2000].
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Linux上使用的DNS服务器实现是广泛使用的伯克利互联网名称域（BIND）实现，*named(8)*，由*互联网系统协会*（[http://www.isc.org/](http://www.isc.org/)）维护。该守护进程的操作由文件`/etc/named.conf`控制（请参阅*named.conf(5)*手册页）。关于DNS和BIND的关键参考资料是[Albitz
    & Liu, 2006]。有关DNS的信息也可以在[Stevens, 1994]的[第14章](ch14.html "第14章 文件系统")、[Stevens
    et al., 2004]的[第11章](ch11.html "第11章 系统限制与选项")以及[Comer, 2000]的[第24章](ch24.html
    "第24章 进程创建")中找到。
- en: When a program calls *getaddrinfo()* to *resolve* (i.e., obtain the IP address
    for) a domain name, *getaddrinfo()* employs a suite of library functions (the
    *resolver library*) that communicate with the local DNS server. If this server
    can’t supply the required information, then it communicates with other DNS servers
    within the hierarchy in order to obtain the information. Occasionally, this resolution
    process may take a noticeable amount of time, and DNS servers employ caching techniques
    to avoid unnecessary communication for frequently queried domain names.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个程序调用*getaddrinfo()*来*解析*（即获取域名的IP地址）一个域名时，*getaddrinfo()*会使用一组库函数（*解析库*），这些函数与本地DNS服务器进行通信。如果该服务器无法提供所需的信息，它会与层级中的其他DNS服务器通信以获取该信息。有时，这个解析过程可能需要相当长的时间，而DNS服务器使用缓存技术来避免对频繁查询的域名进行不必要的通信。
- en: Using the above approach allows DNS to cope with large namespaces, and does
    not require centralized management of names.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述方法使得DNS能够应对大型命名空间，并且不需要对名称进行集中管理。
- en: '![A subset of the DNS hierarchy](figs/web/59-2_SOCKINET-DNS-hierarchy-scale90.png.jpg)Figure 59-2. A
    subset of the DNS hierarchy'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![DNS层次结构的一个子集](figs/web/59-2_SOCKINET-DNS-hierarchy-scale90.png.jpg)图59-2.
    DNS层次结构的一个子集'
- en: Recursive and iterative resolution requests
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 递归和迭代解析请求
- en: 'DNS resolution requests fall into two categories: *recursive* and *iterative*.
    In a recursive request, the requester asks the server to handle the entire task
    of resolution, including the task of communicating with any other DNS servers,
    if necessary. When an application on the local host calls *getaddrinfo()*, that
    function makes a recursive request to the local DNS server. If the local DNS server
    does not itself have the information to perform the resolution, it resolves the
    domain name iteratively.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: DNS解析请求分为两类：*递归*和*迭代*。在递归请求中，请求方要求服务器处理整个解析任务，包括与其他DNS服务器的通信任务（如有必要）。当本地主机上的应用程序调用*getaddrinfo()*时，该函数会向本地DNS服务器发起递归请求。如果本地DNS服务器没有足够的信息进行解析，它会迭代地解析域名。
- en: We explain iterative resolution via an example. Suppose that the local DNS server
    is asked to resolve the name [www.otago.ac.nz](http://www.otago.ac.nz). To do
    this, it first communicates with one of a small set of *root name servers* that
    every DNS server is required to know about. (We can obtain a list of these servers
    using the command *dig . NS* or from the web page at [http://www.root-servers.org/](http://www.root-servers.org/).)
    Given the name [www.otago.ac.nz](http://www.otago.ac.nz), the root name server
    refers the local DNS server to one of the nz DNS servers. The local DNS server
    then queries the `nz` server with the name [www.otago.ac.nz](http://www.otago.ac.nz),
    and receives a response referring it to the ac.nz server. The local DNS server
    then queries the ac.nz server with the name [www.otago.ac.nz](http://www.otago.ac.nz),
    and is referred to the otago.ac.nz server. Finally, the local DNS server queries
    the `otago.ac.nz` server with the name [www.otago.ac.nz](http://www.otago.ac.nz),
    and obtains the required IP address.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个示例来解释迭代解析。假设本地DNS服务器被请求解析名称[www.otago.ac.nz](http://www.otago.ac.nz)。为此，它首先与一个小范围的*根名称服务器*进行通信，每个DNS服务器都必须知道这些服务器。（我们可以通过命令*dig
    . NS*或访问[http://www.root-servers.org/](http://www.root-servers.org/)获取这些服务器的列表。）给定名称[www.otago.ac.nz](http://www.otago.ac.nz)，根名称服务器将本地DNS服务器引导到其中一个nz
    DNS服务器。本地DNS服务器随后使用名称[www.otago.ac.nz](http://www.otago.ac.nz)查询`nz`服务器，并收到一个响应，将其指向ac.nz服务器。本地DNS服务器接着用名称[www.otago.ac.nz](http://www.otago.ac.nz)查询ac.nz服务器，并被指引到otago.ac.nz服务器。最后，本地DNS服务器用名称[www.otago.ac.nz](http://www.otago.ac.nz)查询`otago.ac.nz`服务器，并获得所需的IP地址。
- en: If we supply an incomplete domain name to *gethostbyname()*, the resolver will
    attempt to complete it before resolving it. The rules on how a domain name is
    completed are defined in `/etc/resolv.conf` (see the *resolv.conf(5)* manual page).
    By default, the resolver will at least try completion using the domain name of
    the local host. For example, if we are logged in on the machine `oghma.otago.ac.nz`
    and we type the command *ssh octavo*, the resulting DNS query will be for the
    name `octavo.otago.ac.nz`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向*gethostbyname()*提供一个不完整的域名，解析器会在解析之前尝试将其补全。域名如何补全的规则定义在`/etc/resolv.conf`文件中（请参阅*resolv.conf(5)*手册页）。默认情况下，解析器至少会尝试使用本地主机的域名进行补全。例如，如果我们在机器`oghma.otago.ac.nz`上登录并输入命令*ssh
    octavo*，生成的DNS查询将是`octavo.otago.ac.nz`。
- en: Top-level domains
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 顶级域名
- en: 'The nodes immediately below the anonymous root form the so-called *top-level
    domains* (TLDs). (Below these are the *second-level domains*, and so on.) TLDs
    fall into two categories: *generic* and *country*.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名根节点下方的节点构成了所谓的*顶级域名*（TLD）。（在这些节点下方是*二级域名*，依此类推。）TLD分为两类：*通用*和*国家*。
- en: Historically, there were seven *generic* TLDs, most of which can be considered
    international. We have shown four of the original generic TLDs in [Figure 59-2](ch59.html#a_subset_of_the_dns_hierarchy
    "Figure 59-2. A subset of the DNS hierarchy"). The other three are `int`, `mil`,
    and `gov`; the latter two are reserved for the United States. In more recent times,
    a number of new generic TLDs have been added (e.g., `info`, `name`, and `museum`).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，有七个*通用*TLD，大多数可以视为国际性的。在[图59-2](ch59.html#a_subset_of_the_dns_hierarchy
    "图59-2. DNS层次结构的一个子集")中，我们展示了四个最初的通用TLD。其他三个是`int`、`mil`和`gov`；后两者保留给美国。近年来，添加了许多新的通用TLD（例如，`info`、`name`和`museum`）。
- en: 'Each nation has a corresponding *country* (or *geographical*) TLD (standardized
    as ISO 3166-1), with a 2-character name. In [Figure 59-2](ch59.html#a_subset_of_the_dns_hierarchy
    "Figure 59-2. A subset of the DNS hierarchy"), we have shown a few of these: `de`
    (Germany, *Deutschland*), `eu` (a supra-national geographical TLD for the European
    Union), `nz` (New Zealand), and `us` (United States of America). Several countries
    divide their TLD into a set of second-level domains in a manner similar to the
    generic domains. For example, New Zealand has `ac.nz` (academic institutions),
    `co.nz` (commercial), and `govt.nz` (government).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 每个国家都有一个对应的*国家*（或*地理*）TLD（标准化为ISO 3166-1），其名称由两个字符组成。在[图59-2](ch59.html#a_subset_of_the_dns_hierarchy
    "图59-2. DNS层次结构的一个子集")中，我们展示了其中的一些：`de`（德国，*Deutschland*）、`eu`（欧洲联盟的超国家地理TLD）、`nz`（新西兰）和`us`（美国）。几个国家将其TLD划分为一组类似于通用域名的二级域名。例如，新西兰有`ac.nz`（学术机构）、`co.nz`（商业）和`govt.nz`（政府）。
- en: The `/etc/services` File
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`/etc/services` 文件'
- en: As noted in [Port Numbers](ch58.html#port_numbers "Port Numbers"), well-known
    port numbers are centrally registered by IANA. Each of these ports has a corresponding
    *service name*. Because service numbers are centrally managed and are less volatile
    than IP addresses, an equivalent of the DNS server is usually not necessary. Instead,
    the port numbers and service names are recorded in the file `/etc/services`. The
    *getaddrinfo()* and *getnameinfo()* functions use the information in this file
    to convert service names to port numbers and vice versa.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如[端口号](ch58.html#port_numbers "Port Numbers")中所述，知名端口号由IANA集中注册。每个端口都有一个对应的*服务名称*。由于服务号是集中管理的，且比IP地址更稳定，因此通常不需要类似DNS服务器的等效机制。相反，端口号和服务名称被记录在`/etc/services`文件中。*getaddrinfo()*和*getnameinfo()*函数使用该文件中的信息将服务名称转换为端口号，反之亦然。
- en: 'The `/etc/services` file consists of lines containing three columns, as shown
    in the following examples:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/services`文件由包含三列的行组成，如下例所示：'
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The *protocol* is typically either `tcp` or `udp`. The optional (space-delimited)
    *aliases* specify alternative names for the service. In addition to the above,
    lines may include comments starting with the `#` character.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*协议*通常为`tcp`或`udp`。可选的（空格分隔的）*别名*指定服务的替代名称。除上述内容外，行中还可以包含以`#`字符开头的注释。'
- en: As noted previously, a given port number refers to distinct entities for UDP
    and TCP, but IANA policy assigns both port numbers to a service, even if that
    service uses only one protocol. For example, *telnet*, *ssh*, HTTP, and SMTP all
    use TCP, but the corresponding UDP port is also assigned to these services. Conversely,
    NTP uses only UDP, but the TCP port 123 is also assigned to this service. In some
    cases, a service uses both UDP and TCP; DNS and *echo* are examples of such services.
    Finally, there are a very few cases where the UDP and TCP ports with the same
    number are assigned to different services; for example, *rsh* uses TCP port 514,
    while the *syslog* daemon ([Logging Messages and Errors Using *syslog*](ch37.html#logging_messages_and_errors_using_syslog
    "Logging Messages and Errors Using syslog")) uses UDP port 514\. This is because
    these port numbers were assigned before the adoption of the present IANA policy.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，给定的端口号对于UDP和TCP表示不同的实体，但IANA政策为服务分配了这两个端口号，即使该服务仅使用其中一个协议。例如，*telnet*、*ssh*、HTTP和SMTP都使用TCP，但也为这些服务分配了相应的UDP端口。反之，NTP仅使用UDP，但TCP端口123也分配给该服务。在某些情况下，服务同时使用UDP和TCP；DNS和*echo*就是此类服务的例子。最后，也有少数情况，UDP和TCP端口号相同但分配给不同的服务；例如，*rsh*使用TCP端口514，而*syslog*守护进程（[使用*syslog*记录消息和错误](ch37.html#logging_messages_and_errors_using_syslog
    "Logging Messages and Errors Using syslog")）使用UDP端口514。这是因为这些端口号在采用现行IANA政策之前就已被分配。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `/etc/services` file is merely a record of name-to-number mappings. It
    is not a reservation mechanism: the appearance of a port number in `/etc/services`
    doesn’t guarantee that it will actually be available for binding by a particular
    service.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/services`文件仅是名称到数字映射的记录。它不是一种预留机制：端口号出现在`/etc/services`中并不能保证该端口号实际可供某个服务绑定。'
- en: Protocol-Independent Host and Service Conversion
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议独立的主机和服务转换
- en: The *getaddrinfo()* function converts host and service names to IP addresses
    and port numbers. It was defined in POSIX.1g as the (reentrant) successor to the
    obsolete *gethostbyname()* and *getservbyname()* functions. (Replacing the use
    of *gethostbyname()* with *getaddrinfo()* allows us to eliminate IPv4-versus-IPv6
    dependencies from our programs.)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*getaddrinfo()*函数将主机和服务名称转换为IP地址和端口号。它在POSIX.1g中被定义为（可重入）替代过时的*gethostbyname()*和*getservbyname()*函数。（用*getaddrinfo()*替代*gethostbyname()*的使用，允许我们消除程序中的IPv4与IPv6依赖性。）'
- en: The *getnameinfo()* function is the converse of *getaddrinfo()*. It translates
    a socket address structure (either IPv4 or IPv6) to strings containing the corresponding
    host and service name. This function is the (reentrant) equivalent of the obsolete
    *gethostbyaddr()* and *getservbyport()* functions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*getnameinfo()*函数是*getaddrinfo()*的逆操作。它将套接字地址结构（无论是IPv4还是IPv6）转换为包含对应主机和服务名称的字符串。该函数是（可重入）过时的*gethostbyaddr()*和*getservbyport()*函数的等效物。'
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '[Chapter 11](ch11.html "Chapter 11. System Limits and Options") of [Stevens
    et al., 2004] describes *getaddrinfo()* and *getnameinfo()* in detail, and provides
    implementations of these functions. These functions are also described in RFC
    3493.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 11 章](ch11.html "第 11 章. 系统限制和选项") 中的 [Stevens 等，2004] 详细描述了 *getaddrinfo()*
    和 *getnameinfo()*，并提供了这些函数的实现。这些函数也在 RFC 3493 中进行了描述。'
- en: The *getaddrinfo()* Function
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*getaddrinfo()* 函数'
- en: Given a host name and a service name, *getaddrinfo()* returns a list of socket
    address structures, each of which contains an IP address and port number.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个主机名和一个服务名，*getaddrinfo()* 返回一个套接字地址结构体列表，每个结构体包含一个 IP 地址和端口号。
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or nonzero on error
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回非零值
- en: As input, *getaddrinfo()* takes the arguments *host*, *service*, and *hints*.
    The *host* argument contains either a hostname or a numeric address string, expressed
    in IPv4 dotted-decimal notation or IPv6 hex-string notation. (To be precise, *getaddrinfo()*
    accepts IPv4 numeric strings in the more general numbers-and-dots notation described
    in [The *inet_aton()* and *inet_ntoa()* Functions](ch59.html#the_inet_underscore_aton_open_parenthesi
    "The inet_aton() and inet_ntoa() Functions").) The *service* argument contains
    either a service name or a decimal port number. The *hints* argument points to
    an *addrinfo* structure that specifies further criteria for selecting the socket
    address structures returned via *result*. We describe the *hints* argument in
    more detail below.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输入，*getaddrinfo()* 接受 *host*、*service* 和 *hints* 这三个参数。*host* 参数包含主机名或数字地址字符串，表示为
    IPv4 点分十进制表示法或 IPv6 十六进制字符串表示法。（更准确地说，*getaddrinfo()* 接受 IPv4 数字字符串，以 [*inet_aton()*
    和 *inet_ntoa()* 函数](ch59.html#the_inet_underscore_aton_open_parenthesi "inet_aton()
    和 inet_ntoa() 函数") 中描述的更一般的数字与点的表示法。）*service* 参数包含服务名或十进制端口号。*hints* 参数指向一个 *addrinfo*
    结构体，该结构体指定了进一步选择通过 *result* 返回的套接字地址结构体的标准。我们将在下面更详细地描述 *hints* 参数。
- en: 'As output, *getaddrinfo()* dynamically allocates a linked list of *addrinfo*
    structures and sets *result* pointing to the beginning of this list. Each of these
    *addrinfo* structures includes a pointer to a socket address structure corresponding
    to *host* and *service* ([Figure 59-3](ch59.html#structures_allocated_and_returned_by_get
    "Figure 59-3. Structures allocated and returned by getaddrinfo()")). The *addrinfo*
    structure has the following form:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输出，*getaddrinfo()* 动态分配一个 *addrinfo* 结构体的链表，并将 *result* 设置为指向该链表的开始位置。这些 *addrinfo*
    结构体中的每一个都包含一个指向对应于 *host* 和 *service* 的套接字地址结构的指针（[图 59-3](ch59.html#structures_allocated_and_returned_by_get
    "图 59-3. getaddrinfo() 分配并返回的结构体")）。*addrinfo* 结构体的形式如下：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The *result* argument returns a list of structures, rather than a single structure,
    because there may be multiple combinations of host and service corresponding to
    the criteria specified in *host*, *service*, and *hints*. For example, multiple
    address structures could be returned for a host with more than one network interface.
    Furthermore, if *hints.ai_socktype* was specified as 0, then two structures could
    be returned—one for a `SOCK_DGRAM` socket, the other for a `SOCK_STREAM` socket—if
    the given *service* was available for both UDP and TCP.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*result* 参数返回一个结构体列表，而不是单一的结构体，因为可能存在多个主机和服务组合与 *host*、*service* 和 *hints*
    中指定的标准相对应。例如，对于一个有多个网络接口的主机，可能会返回多个地址结构。此外，如果 *hints.ai_socktype* 被指定为 0，那么两个结构体可能会被返回——一个用于
    `SOCK_DGRAM` 套接字，另一个用于 `SOCK_STREAM` 套接字——如果给定的 *service* 同时适用于 UDP 和 TCP。'
- en: The fields of each *addrinfo* structure returned via *result* describe properties
    of the associated socket address structure. The *ai_family* field is set to either
    `AF_INET` or `AF_INET6`, informing us of the type of the socket address structure.
    The *ai_socktype* field is set to either `SOCK_STREAM` or `SOCK_DGRAM`, indicating
    whether this address structure is for a TCP or a UDP service. The *ai_protocol*
    field returns a protocol value appropriate for the address family and socket type.
    (The three fields *ai_family*, *ai_socktype*, and *ai_protocol* supply the values
    required for the arguments used when calling *socket()* to create a socket for
    this address.) The *ai_addrlen* field gives the size (in bytes) of the socket
    address structure pointed to by *ai_addr*. The *in_addr* field points to the socket
    address structure (an *in_addr* structure for IPv4 or an *in6_addr* structure
    for IPv6). The *ai_flags* field is unused (it is used for the *hints* argument).
    The *ai_canonname* field is used only in the first *addrinfo* structure, and only
    if the `AI_CANONNAME` flag is employed in *hints.ai_flags*, as described below.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 每个通过*result*返回的*addrinfo*结构的字段描述了相关套接字地址结构的属性。*ai_family*字段被设置为`AF_INET`或`AF_INET6`，告知我们套接字地址结构的类型。*ai_socktype*字段被设置为`SOCK_STREAM`或`SOCK_DGRAM`，指示该地址结构是用于TCP还是UDP服务。*ai_protocol*字段返回适用于地址族和套接字类型的协议值。（这三个字段*ai_family*、*ai_socktype*和*ai_protocol*提供了在调用*socket()*创建此地址的套接字时所需的参数值。）*ai_addrlen*字段给出了由*ai_addr*指向的套接字地址结构的大小（以字节为单位）。*in_addr*字段指向套接字地址结构（IPv4的*in_addr*结构或IPv6的*in6_addr*结构）。*ai_flags*字段未使用（它用于*hints*参数）。*ai_canonname*字段仅在第一个*addrinfo*结构中使用，且只有在*hints.ai_flags*中使用了`AI_CANONNAME`标志时才会使用，如下所述。
- en: As with *gethostbyname()*, *getaddrinfo()* may need to send a request to a DNS
    server, and this request may take some time to complete. The same applies for
    *getnameinfo()*, which we describe in [The *getnameinfo()* Function](ch59.html#the_getnameinfo_open_parenthesis_close_p
    "The getnameinfo() Function").
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与*gethostbyname()*类似，*getaddrinfo()*可能需要向DNS服务器发送请求，而此请求可能需要一些时间才能完成。对于*getnameinfo()*也是如此，我们在[《*getnameinfo()*函数》](ch59.html#the_getnameinfo_open_parenthesis_close_p
    "The getnameinfo() Function")中进行了描述。
- en: We demonstrate the use of *getaddrinfo()* in [Client-Server Example (Stream
    Sockets)](ch59.html#client-server_example_open_parenthesis_s "Client-Server Example
    (Stream Sockets)").
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[客户端-服务器示例（流套接字）](ch59.html#client-server_example_open_parenthesis_s "Client-Server
    Example (Stream Sockets)")中演示了*getaddrinfo()*的使用。
- en: '![Structures allocated and returned by getaddrinfo()](figs/web/59-3_SOCKINET-addrinfo-list-scale90.png.jpg)Figure 59-3. Structures
    allocated and returned by *getaddrinfo()*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![getaddrinfo()分配并返回的结构](figs/web/59-3_SOCKINET-addrinfo-list-scale90.png.jpg)图59-3.
    *getaddrinfo()*分配并返回的结构'
- en: The *hints* argument
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*hints*参数'
- en: The *hints* argument specifies further criteria for selecting the socket address
    structures returned by *getaddrinfo()*. When used as the *hints* argument, only
    the *ai_flags*, *ai_family*, *ai_socktype*, and *ai_protocol* fields of the *addrinfo*
    structure can be set. The other fields are unused, and should be initialized to
    0 or `NULL`, as appropriate.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*hints*参数指定了选择*getaddrinfo()*返回的套接字地址结构的进一步标准。在作为*hints*参数使用时，只有*ai_flags*、*ai_family*、*ai_socktype*和*ai_protocol*字段可以设置。其他字段未使用，应该根据需要初始化为0或`NULL`。'
- en: The *hints.ai_family* field selects the domain for the returned socket address
    structures. It may be specified as `AF_INET` or `AF_INET6` (or some other `AF_*`
    constant, if the implementation supports it). If we are interested in getting
    back all types of socket address structures, we can specify the value `AF_UNSPEC`
    for this field.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*hints.ai_family*字段选择返回的套接字地址结构的域。它可以指定为`AF_INET`或`AF_INET6`（如果实现支持，也可以是其他`AF_*`常量）。如果我们希望返回所有类型的套接字地址结构，可以为此字段指定值`AF_UNSPEC`。'
- en: The *hints.ai_socktype* field specifies the type of socket for which the returned
    address structure is to be used. If we specify this field as `SOCK_DGRAM`, then
    a lookup is performed for the UDP service, and a corresponding socket address
    structure is returned via *result*. If we specify `SOCK_STREAM`, a lookup for
    the TCP service is performed. If *hints.ai_socktype* is specified as 0, any socket
    type is acceptable.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*hints.ai_socktype*字段指定返回的地址结构将用于的套接字类型。如果我们将此字段指定为`SOCK_DGRAM`，则会执行UDP服务的查找，并通过*result*返回相应的套接字地址结构。如果我们指定为`SOCK_STREAM`，则会执行TCP服务的查找。如果*hints.ai_socktype*指定为0，则接受任何套接字类型。'
- en: The *hints.ai_protocol* field selects the socket protocol for the returned address
    structures. For our purposes, this field is always specified as 0, meaning that
    the caller will accept any protocol.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*hints.ai_protocol*字段选择返回地址结构的套接字协议。对于我们的用途，该字段始终指定为0，这意味着调用者将接受任何协议。'
- en: 'The *hints.ai_flags* field is a bit mask that modifies the behavior of *getaddrinfo()*.
    This field is formed by ORing together zero or more of the following values:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*hints.ai_flags*字段是一个位掩码，用于修改*getaddrinfo()*的行为。此字段通过对以下值进行按位或操作来形成：'
- en: '`AI_ADDRCONFIG`'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`AI_ADDRCONFIG`'
- en: Return IPv4 addresses only if there is at least one IPv4 address configured
    for the local system (other than the IPv4 loopback address), and return IPv6 addresses
    only if there is at least one IPv6 address configured for the local system (other
    than the IPv6 loopback address).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在本地系统配置了至少一个IPv4地址（不包括IPv4回环地址）时，返回IPv4地址；仅在本地系统配置了至少一个IPv6地址（不包括IPv6回环地址）时，返回IPv6地址。
- en: '`AI_ALL`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`AI_ALL`'
- en: See the description of `AI_V4MAPPED` below.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅下面关于`AI_V4MAPPED`的描述。
- en: '`AI_CANONNAME`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`AI_CANONNAME`'
- en: If *host* is not `NULL`, return a pointer to a null-terminated string containing
    the canonical name of the host. This pointer is returned in a buffer pointed to
    by the *ai_canonname* field of the first of the *addrinfo* structures returned
    via *result*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*host*不是`NULL`，则返回指向包含主机规范名称的空终止字符串的指针。该指针在通过*result*返回的第一个*addrinfo*结构的*ai_canonname*字段指向的缓冲区中返回。
- en: '`AI_NUMERICHOST`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`AI_NUMERICHOST`'
- en: Force interpretation of *host* as a numeric address string. This is used to
    prevent name resolution in cases where it is unnecessary, since name resolution
    can be time-consuming.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 强制将*host*解释为数字地址字符串。这用于防止在不必要的情况下进行名称解析，因为名称解析可能会耗时。
- en: '`AI_NUMERICSERV`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`AI_NUMERICSERV`'
- en: Interpret *service* as a numeric port number. This flag prevents the invocation
    of any name-resolution service, which is not required if *service* is a numeric
    string.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将*service*解释为数字端口号。此标志防止调用任何名称解析服务，当*service*是数字字符串时，这些服务是不需要的。
- en: '`AI_PASSIVE`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`AI_PASSIVE`'
- en: Return socket address structures suitable for a passive open (i.e., a listening
    socket). In this case, *host* should be `NULL`, and the IP address component of
    the socket address structure(s) returned by *result* will contain a wildcard IP
    address (i.e., `INADDR_ANY` or `IN6ADDR_ANY_INIT`). If this flag is not set, then
    the address structure(s) returned via *result* will be suitable for use with *connect()*
    and *sendto()*; if *host* is `NULL`, then the IP address in the returned socket
    address structures will be set to the loopback IP address (either `INADDR_LOOPBACK`
    or `IN6ADDR_LOOPBACK_INIT`, according to the domain).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 返回适用于被动打开（即监听套接字）的套接字地址结构。在这种情况下，*host*应为`NULL`，由*result*返回的套接字地址结构中的IP地址部分将包含通配符IP地址（即`INADDR_ANY`或`IN6ADDR_ANY_INIT`）。如果未设置此标志，则通过*result*返回的地址结构将适用于*connect()*和*sendto()*；如果*host*为`NULL`，则返回的套接字地址结构中的IP地址将设置为回环IP地址（根据域名，可能是`INADDR_LOOPBACK`或`IN6ADDR_LOOPBACK_INIT`）。
- en: '`AI_V4MAPPED`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`AI_V4MAPPED`'
- en: If `AF_INET6` was specified in the *ai_family* field of *hints*, then IPv4-mapped
    IPv6 address structures should be returned in *result* if no matching IPv6 address
    could be found. If `AI_ALL` is specified in conjunction with `AI_V4MAPPED`, then
    both IPv6 and IPv4 address structures are returned in *result*, with IPv4 addresses
    being returned as IPv4-mapped IPv6 address structures.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在*hints*的*ai_family*字段中指定了`AF_INET6`，则如果找不到匹配的IPv6地址，应在*result*中返回IPv4映射的IPv6地址结构。如果同时指定了`AI_ALL`和`AI_V4MAPPED`，则在*result*中返回IPv6和IPv4地址结构，IPv4地址将作为IPv4映射的IPv6地址结构返回。
- en: As noted above for `AI_PASSIVE`, *host* can be specified as `NULL`. It is also
    possible to specify *service* as `NULL`, in which case the port number in the
    returned address structures is set to 0 (i.e., we are just interested in resolving
    hostnames to addresses). It is not permitted, however, to specify both *host*
    and *service* as `NULL`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，对于`AI_PASSIVE`，*host*可以指定为`NULL`。还可以将*service*指定为`NULL`，在这种情况下，返回地址结构中的端口号将设置为0（即我们只关心将主机名解析为地址）。但是，不允许将*host*和*service*都指定为`NULL`。
- en: If we don’t need to specify any of the above selection criteria in hints, then
    *hints* may be specified as `NULL`, in which case *ai_socktype* and *ai_protocol*
    are assumed as 0, *ai_flags* is assumed as `(AI_V4MAPPED | AI_ADDRCONFIG)`, and
    *ai_family* is assumed as `AF_UNSPEC`. (The *glibc* implementation deliberately
    deviates from SUSv3, which states that if *hints* is `NULL`, *ai_flags* is assumed
    as 0.)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要在 *hints* 中指定任何上述选择条件，则 *hints* 可以指定为 `NULL`，在这种情况下，*ai_socktype* 和 *ai_protocol*
    默认为 0，*ai_flags* 默认为 `(AI_V4MAPPED | AI_ADDRCONFIG)`，*ai_family* 默认为 `AF_UNSPEC`。（*glibc*
    实现故意偏离了 SUSv3，SUSv3 中规定，如果 *hints* 为 `NULL`，则 *ai_flags* 默认为 0。）
- en: 'Freeing *addrinfo* Lists: *freeaddrinfo()*'
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 释放 *addrinfo* 列表： *freeaddrinfo()*
- en: The *getaddrinfo()* function dynamically allocates memory for all of the structures
    referred to by *result* ([Figure 59-3](ch59.html#structures_allocated_and_returned_by_get
    "Figure 59-3. Structures allocated and returned by getaddrinfo()")). Consequently,
    the caller must deallocate these structures when they are no longer needed. The
    *freeaddrinfo()* function is provided to conveniently perform this deallocation
    in a single step.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*getaddrinfo()* 函数动态分配内存给所有由 *result* 引用的结构体（[图 59-3](ch59.html#structures_allocated_and_returned_by_get
    "图 59-3. getaddrinfo() 分配并返回的结构")）。因此，调用者必须在这些结构体不再需要时释放它们。提供了 *freeaddrinfo()*
    函数，以便通过一步操作方便地执行释放。'
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If we want to preserve a copy of one of the *addrinfo* structures or its associated
    socket address structure, then we must duplicate the structure(s) before calling
    *freeaddrinfo()*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望保留其中一个 *addrinfo* 结构体或其关联的套接字地址结构体的副本，那么在调用 *freeaddrinfo()* 之前，我们必须复制这些结构体。
- en: 'Diagnosing Errors: *gai_strerror()*'
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误诊断： *gai_strerror()*
- en: On error, *getaddrinfo()* returns one of the nonzero error codes shown in [Table 59-1](ch59.html#error_returns_for_getaddrinfo_open_paren
    "Table 59-1. Error returns for getaddrinfo() and getnameinfo()").
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 出现错误时，*getaddrinfo()* 返回 [表 59-1](ch59.html#error_returns_for_getaddrinfo_open_paren
    "表 59-1. getaddrinfo() 和 getnameinfo() 的错误返回") 中所示的非零错误代码之一。
- en: Table 59-1. Error returns for *getaddrinfo()* and *getnameinfo()*
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 表 59-1. *getaddrinfo()* 和 *getnameinfo()* 的错误返回
- en: '| Error constant | Description |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 错误常量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `EAI_ADDRFAMILY` | No addresses for *host exist* in *hints.ai_family* (not
    in SUSv3, but defined on most implementations; *getaddrinfo()* only) |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `EAI_ADDRFAMILY` | 在 *hints.ai_family* 中没有 *host* 的地址（SUSv3 中没有定义，但大多数实现中有定义；仅适用于
    *getaddrinfo()*） |'
- en: '| `EAI_AGAIN` | Temporary failure in name resolution (try again later) |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `EAI_AGAIN` | 名称解析暂时失败（稍后再试） |'
- en: '| `EAI_BADFLAGS` | An invalid flag was specified in *hints.ai_flags* |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `EAI_BADFLAGS` | 在 *hints.ai_flags* 中指定了无效的标志 |'
- en: '| `EAI_FAIL` | Unrecoverable failure while accessing name server |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `EAI_FAIL` | 访问名称服务器时发生无法恢复的故障 |'
- en: '| `EAI_FAMILY` | Address family specified in *hints.ai_family* is not supported
    |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `EAI_FAMILY` | 在 *hints.ai_family* 中指定的地址族不受支持 |'
- en: '| `EAI_MEMORY` | Memory allocation failure |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `EAI_MEMORY` | 内存分配失败 |'
- en: '| `EAI_NODATA` | No address associated with *host* (not in SUSv3, but defined
    on most implementations; *getaddrinfo()* only) |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `EAI_NODATA` | *host* 没有关联的地址（SUSv3 中没有定义，但大多数实现中有定义；仅适用于 *getaddrinfo()*）
    |'
- en: '| `EAI_NONAME` | Unknown *host* or *service*, or both *host* and *service*
    were `NULL`, or `AI_NUMERICSERV` specified and *service* didn’t point to numeric
    string |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `EAI_NONAME` | 未知的 *host* 或 *service*，或者 *host* 和 *service* 都为 `NULL`，或者指定了
    `AI_NUMERICSERV` 但 *service* 没有指向数字字符串 |'
- en: '| `EAI_OVERFLOW` | Argument buffer overflow |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `EAI_OVERFLOW` | 参数缓冲区溢出 |'
- en: '| `EAI_SERVICE` | Specified *service* not supported for *hints.ai_socktype*
    (*getaddrinfo()* only) |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `EAI_SERVICE` | 指定的 *service* 不支持 *hints.ai_socktype*（仅适用于 *getaddrinfo()*）
    |'
- en: '| `EAI_SOCKTYPE` | Specified *hints.ai_socktype* is not supported (*getaddrinfo()*
    only) |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `EAI_SOCKTYPE` | 指定的 *hints.ai_socktype* 不受支持（仅适用于 *getaddrinfo()*） |'
- en: '| `EAI_SYSTEM` | System error returned in *errno* |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `EAI_SYSTEM` | 系统错误，返回值为 *errno* |'
- en: Given one of the error codes in [Table 59-1](ch59.html#error_returns_for_getaddrinfo_open_paren
    "Table 59-1. Error returns for getaddrinfo() and getnameinfo()"), the *gai_strerror()*
    function returns a string describing the error. (This string is typically briefer
    than the description shown in [Table 59-1](ch59.html#error_returns_for_getaddrinfo_open_paren
    "Table 59-1. Error returns for getaddrinfo() and getnameinfo()").)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 [表 59-1](ch59.html#error_returns_for_getaddrinfo_open_paren "表 59-1. getaddrinfo()
    和 getnameinfo() 的错误返回") 中的某个错误代码，*gai_strerror()* 函数会返回描述该错误的字符串。 （该字符串通常比 [表
    59-1](ch59.html#error_returns_for_getaddrinfo_open_paren "表 59-1. getaddrinfo()
    和 getnameinfo() 的错误返回") 中的描述更简洁。）
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to string containing error message
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向包含错误信息的字符串的指针
- en: We can use the string returned by *gai_strerror()* as part of an error message
    displayed by an application.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用由*gai_strerror()*返回的字符串作为应用程序显示的错误消息的一部分。
- en: The *getnameinfo()* Function
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*getnameinfo()*函数'
- en: The *getnameinfo()* function is the converse of *getaddrinfo()*. Given a socket
    address structure (either IPv4 or IPv6), it returns strings containing the corresponding
    host and service name, or numeric equivalents if the names can’t be resolved.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*getnameinfo()*函数是*getaddrinfo()*的反操作。给定一个套接字地址结构（无论是IPv4还是IPv6），它返回包含相应主机和服务名称的字符串，或者如果无法解析名称，则返回数字等效项。'
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or nonzero on error
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回非零值。
- en: The *addr* argument is a pointer to the socket address structure that is to
    be converted. The length of that structure is given in *addrlen*. Typically, the
    values for *addr* and *addrlen* are obtained from a call to *accept()*, *recvfrom()*,
    *getsockname()*, or *getpeername()*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*addr*参数是指向要转换的套接字地址结构的指针。该结构的长度由*addrlen*给出。通常，*addr*和*addrlen*的值是通过调用*accept()*、*recvfrom()*、*getsockname()*或*getpeername()*获得的。'
- en: The resulting host and service names are returned as null-terminated strings
    in the buffers pointed to by *host* and *service*. These buffers must be allocated
    by the caller, and their sizes must be passed in *hostlen* and *servlen*. The
    `<netdb.h>` header file defines two constants to assist in sizing these buffers.
    `NI_MAXHOST` indicates the maximum size, in bytes, for a returned hostname string.
    It is defined as 1025\. `NI_MAXSERV` indicates the maximum size, in bytes, for
    a returned service name string. It is defined as 32. These two constants are not
    specified in SUSv3, but they are defined on all UNIX implementations that provide
    *getnameinfo()*. (Since *glibc* 2.8, we must define one of the feature text macros
    `_BSD_SOURCE`, `_SVID_SOURCE`, or `_GNU_SOURCE` to obtain the definitions of `NI_MAXHOST`
    and `NI_MAXSERV`.)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的主机和服务名称作为以空字符结尾的字符串返回，存储在*host*和*service*指向的缓冲区中。这些缓冲区必须由调用者分配，并且其大小必须通过*hostlen*和*servlen*传递。`<netdb.h>`头文件定义了两个常量来帮助确定这些缓冲区的大小。`NI_MAXHOST`表示返回的主机名字符串的最大大小（以字节为单位）。它被定义为1025。`NI_MAXSERV`表示返回的服务名字符串的最大大小（以字节为单位）。它被定义为32。这两个常量在SUSv3中未指定，但在所有提供*getnameinfo()*的UNIX实现中都已定义。（自*glibc*
    2.8以来，我们必须定义其中一个特性文本宏`_BSD_SOURCE`、`_SVID_SOURCE`或`_GNU_SOURCE`，以获取`NI_MAXHOST`和`NI_MAXSERV`的定义。）
- en: If we are not interested in obtaining the hostname, we can specify *host* as
    `NULL` and *hostlen* as 0\. Similarly, if we don’t need the service name, we can
    specify *service* as `NULL` and *servlen* as 0\. However, at least one of *host*
    and *service* must be non-`NULL` (and the corresponding length argument must be
    nonzero).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不关心获取主机名，可以将*host*指定为`NULL`，并将*hostlen*指定为0。同样，如果我们不需要服务名称，可以将*service*指定为`NULL`，并将*servlen*指定为0。然而，*host*和*service*中至少一个必须非`NULL`（并且相应的长度参数必须非零）。
- en: 'The final argument, *flags*, is a bit mask that controls the behavior of *getnameinfo()*.
    The following constants may be ORed together to form this bit mask:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的参数，*flags*，是一个位掩码，控制*getnameinfo()*的行为。以下常量可以通过按位或运算组合在一起形成该位掩码：
- en: '`NI_DGRAM`'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`NI_DGRAM`'
- en: By default, *getnameinfo()* returns the name corresponding to a *stream* socket
    (i.e., TCP) service. Normally, this doesn’t matter, because, as noted in [The
    `/etc/services` File](ch59.html#the_solidus_etc_solidus_services_file "The /etc/services
    File"), the service names are usually the same for corresponding TCP and UDP ports.
    However, in the few instances where the names differ, the `NI_DGRAM` flag forces
    the name of the datagram socket (i.e., UDP) service to be returned.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，*getnameinfo()*返回与*流*套接字（即TCP）服务对应的名称。通常，这不会产生影响，因为正如在[《/etc/services文件》](ch59.html#the_solidus_etc_solidus_services_file
    "The /etc/services File")中所提到的，服务名称通常在对应的TCP和UDP端口之间相同。然而，在少数名称不同的情况下，`NI_DGRAM`标志会强制返回数据报套接字（即UDP）服务的名称。
- en: '`NI_NAMEREQD`'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`NI_NAMEREQD`'
- en: By default, if the hostname can’t be resolved, a numeric address string is returned
    in *host*. If the `NI_NAMEREQD` flag is specified, an error (`EAI_NONAME`) is
    returned instead.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果无法解析主机名，则在*host*中返回数字地址字符串。如果指定了`NI_NAMEREQD`标志，则返回错误（`EAI_NONAME`）。
- en: '`NI_NOFQDN`'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`NI_NOFQDN`'
- en: By default, the fully qualified domain name for the host is returned. Specifying
    the `NI_NOFQDN` flag causes just the first (i.e., the hostname) part of the name
    to be returned, if this is a host on the local network.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，返回主机的完全限定域名。指定`NI_NOFQDN`标志时，若这是本地网络上的主机，则仅返回名称的第一部分（即主机名）。
- en: '`NI_NUMERICHOST`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`NI_NUMERICHOST`'
- en: Force a numeric address string to be returned in *host*. This is useful if we
    want to avoid a possibly time-consuming call to the DNS server.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 强制返回一个数字地址字符串作为*host*。如果我们希望避免可能耗时的DNS服务器调用，这非常有用。
- en: '`NI_NUMERICSERV`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`NI_NUMERICSERV`'
- en: Force a decimal port number string to be returned in *service*. This is useful
    in cases where we know that the port number doesn’t correspond to a service name—for
    example, if it is an ephemeral port number assigned to the socket by the kernel—and
    we want to avoid the inefficiency of unnecessarily searching `/etc/services`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 强制返回一个十进制端口号字符串作为*service*。在已知端口号不对应服务名称的情况下（例如，如果它是内核分配给套接字的临时端口号），这非常有用，我们希望避免不必要地搜索`/etc/services`带来的低效。
- en: On success, *getnameinfo()* returns 0\. On error, it returns one of the nonzero
    error codes shown in [Table 59-1](ch59.html#error_returns_for_getaddrinfo_open_paren
    "Table 59-1. Error returns for getaddrinfo() and getnameinfo()").
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，*getnameinfo()* 返回 0。如果出错，它将返回[表格 59-1](ch59.html#error_returns_for_getaddrinfo_open_paren
    "表格 59-1. getaddrinfo() 和 getnameinfo() 的错误返回")中列出的非零错误代码之一。
- en: Client-Server Example (Stream Sockets)
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端-服务器示例（流套接字）
- en: 'We now have enough information to look at a simple client-server application
    using TCP sockets. The task performed by this application is the same as that
    performed by the FIFO client-server application presented in [A Client-Server
    Application Using FIFOs](ch44.html#a_client-server_application_using_fifos "A
    Client-Server Application Using FIFOs"): allocating unique sequence numbers (or
    ranges of sequence numbers) to clients.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有足够的信息来查看一个使用TCP套接字的简单客户端-服务器应用程序。该应用程序执行的任务与[A Client-Server Application
    Using FIFOs](ch44.html#a_client-server_application_using_fifos "使用FIFO的客户端-服务器应用程序")中介绍的FIFO客户端-服务器应用程序执行的任务相同：为客户端分配唯一的序列号（或序列号范围）。
- en: In order to handle the possibility that integers may be represented in different
    formats on the server and client hosts, we encode all transmitted integers as
    strings terminated by a newline, and use our *readLine()* function ([Example 59-1](ch59.html#reading_data_a_line_at_a_time
    "Example 59-1. Reading data a line at a time")) to read these strings.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理服务器和客户端主机上整数可能以不同格式表示的情况，我们将所有传输的整数编码为以换行符结束的字符串，并使用我们的*readLine()*函数（[示例 59-1](ch59.html#reading_data_a_line_at_a_time
    "示例 59-1. 逐行读取数据")）来读取这些字符串。
- en: Common header file
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 公共头文件
- en: Both the server and the client include the header file shown in [Example 59-5](ch59.html#header_file_used_by_is_underscore_seqnum
    "Example 59-5. Header file used by is_seqnum_sv.c and is_seqnum_cl.c"). This file
    includes various other header files, and defines the TCP port number to be used
    by the application.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器和客户端都包含[示例 59-5](ch59.html#header_file_used_by_is_underscore_seqnum "示例 59-5.
    由is_seqnum_sv.c和is_seqnum_cl.c使用的头文件")中显示的头文件。此文件包含其他头文件，并定义应用程序将使用的TCP端口号。
- en: Server program
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 服务器程序
- en: 'The server program shown in [Example 59-6](ch59.html#an_iterative_server_that_uses_a_stream_s
    "Example 59-6. An iterative server that uses a stream socket to communicate with
    clients") performs the following steps:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 59-6](ch59.html#an_iterative_server_that_uses_a_stream_s "示例 59-6. 一个使用流套接字与客户端通信的迭代服务器")中显示的服务器程序执行以下步骤：'
- en: Initialize the server’s sequence number either to 1 or to the value supplied
    in the optional command-line argument ![](figs/web/U001.png).
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将服务器的序列号初始化为1，或为可选命令行参数中提供的值 ![](figs/web/U001.png)。
- en: Ignore the `SIGPIPE` signal ![](figs/web/U002.png). This prevents the server
    from receiving the `SIGPIPE` signal if it tries to write to a socket whose peer
    has been closed; instead, the *write()* fails with the error `EPIPE`.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略`SIGPIPE`信号 ![](figs/web/U002.png)。这防止服务器在尝试写入已关闭对等端的套接字时收到`SIGPIPE`信号；相反，*write()*
    会因错误`EPIPE`而失败。
- en: Call *getaddrinfo()* ![](figs/web/U004.png) to obtain a set of socket address
    structures for a TCP socket that uses the port number `PORT_NUM`. (Instead of
    using a hard-coded port number, we would more typically use a service name.) We
    specify the `AI_PASSIVE` flag ![](figs/web/U003.png) so that the resulting socket
    will be bound to the wildcard address ([IP Addresses](ch58.html#ip_addresses "IP
    Addresses")). As a result, if the server is run on a multihomed host, it can accept
    connection requests sent to any of the host’s network addresses.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用*getaddrinfo()* ![](figs/web/U004.png)以获取一组用于TCP套接字的套接字地址结构，该套接字使用端口号`PORT_NUM`。（与使用硬编码端口号不同，我们通常会使用服务名称。）我们指定`AI_PASSIVE`标志
    ![](figs/web/U003.png)，以便生成的套接字将绑定到通配符地址（[IP 地址](ch58.html#ip_addresses "IP Addresses")）。因此，如果服务器在一个多宿主主机上运行，它可以接受发送到主机任何网络地址的连接请求。
- en: Enter a loop that iterates through the socket address structures returned by
    the previous step ![](figs/web/U005.png). The loop terminates when the program
    finds an address structure that can be used to successfully create and bind a
    socket ![](figs/web/U007.png).
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入一个循环，逐个处理前一步返回的套接字地址结构 ![](figs/web/U005.png)。当程序找到一个可以成功创建并绑定套接字的地址结构时，循环终止
    ![](figs/web/U007.png)。
- en: Set the `SO_REUSEADDR` option for the socket created in the previous step ![](figs/web/U006.png).
    We defer discussion of this option until [The *SO_REUSEADDR* Socket Option](ch61.html#the_so_underscore_reuseaddr_socket_optio
    "The SO_REUSEADDR Socket Option"), where we note that a TCP server should usually
    set this option on its listening socket.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为在前一步创建的套接字设置`SO_REUSEADDR`选项 ![](figs/web/U006.png)。我们将在[《*SO_REUSEADDR* 套接字选项》](ch61.html#the_so_underscore_reuseaddr_socket_optio
    "The SO_REUSEADDR Socket Option")中讨论此选项，届时我们会提到，TCP 服务器通常应在其监听套接字上设置此选项。
- en: Mark the socket as a listening socket ![](figs/web/U008.png).
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将套接字标记为监听套接字 ![](figs/web/U008.png)。
- en: 'Commence an infinite `for` loop ![](figs/web/U009.png) that services clients
    iteratively ([Chapter 60](ch60.html "Chapter 60. Sockets: Server Design")). Each
    client’s request is serviced before the next client’s request is accepted. For
    each client, the server performs the following steps:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '启动一个无限`for`循环 ![](figs/web/U009.png)，逐个处理客户端请求（[第60章](ch60.html "Chapter 60.
    Sockets: Server Design")）。每个客户端的请求在接受下一个客户端的请求之前会被处理。对于每个客户端，服务器执行以下步骤：'
- en: Accept a new connection ![](figs/web/U010.png). The server passes non-`NULL`
    pointers for the second and third arguments to *accept()*, in order to obtain
    the address of the client. The server displays the client’s address (IP address
    plus port number) on standard output ![](figs/web/U011.png).
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受一个新的连接 ![](figs/web/U010.png)。服务器为*accept()*的第二个和第三个参数传递非`NULL`指针，以便获取客户端的地址。服务器在标准输出上显示客户端的地址（IP
    地址加端口号） ![](figs/web/U011.png)。
- en: Read the client’s message ![](figs/web/U012.png), which consists of a newline-terminated
    string specifying how many sequence numbers the client wants. The server converts
    this string to an integer and stores it in the variable *reqLen* ![](figs/web/U013.png).
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取客户端的消息 ![](figs/web/U012.png)，该消息是一个以换行符结尾的字符串，指定客户端想要多少个序列号。服务器将此字符串转换为整数，并将其存储在变量*reqLen*中
    ![](figs/web/U013.png)。
- en: Send the current value of the sequence number (*seqNum*) back to the client,
    encoding it as a newline-terminated string ![](figs/web/U014.png). The client
    can assume that it has been allocated all of the sequence numbers in the range
    *seqNum* to *(seqNum + reqLen - 1)*.
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将当前序列号值(*seqNum*)发送回客户端，并将其编码为以换行符结尾的字符串 ![](figs/web/U014.png)。客户端可以假设它已分配了从*seqNum*到*(seqNum
    + reqLen - 1)*范围内的所有序列号。
- en: Update the value of the server’s sequence number by adding *reqLen* to *seqNum*
    ![](figs/web/U015.png).
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将*reqLen*加到*seqNum*来更新服务器的序列号值 ![](figs/web/U015.png)。
- en: Example 59-5. Header file used by `is_seqnum_sv.c` and `is_seqnum_cl.c`
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 59-5. `is_seqnum_sv.c`和`is_seqnum_cl.c`使用的头文件
- en: '[PRE28]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Example 59-6. An iterative server that uses a stream socket to communicate with
    clients
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 59-6. 使用流套接字与客户端通信的迭代服务器
- en: '[PRE29]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Client program
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 客户端程序
- en: 'The client program is shown in [Example 59-7](ch59.html#a_client_that_uses_stream_sockets
    "Example 59-7. A client that uses stream sockets"). This program accepts two arguments.
    The first argument, which is the name of the host on which the server is running,
    is mandatory. The optional second argument is the length of the sequence desired
    by the client. The default length is 1\. The client performs the following steps:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端程序显示在[示例59-7](ch59.html#a_client_that_uses_stream_sockets "示例59-7. 一个使用流套接字的客户端")中。该程序接受两个参数。第一个参数是服务器运行所在主机的名称，这是必需的。可选的第二个参数是客户端期望的序列长度，默认长度为1。客户端执行以下步骤：
- en: Call *getaddrinfo()* to obtain a set of socket address structures suitable for
    connecting to a TCP server bound to the specified host ![](figs/web/U001.png).
    For the port number, the client specifies `PORT_NUM`.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用*getaddrinfo()*获取一组适用于连接到指定主机上的TCP服务器的套接字地址结构！[](figs/web/U001.png)。对于端口号，客户端指定`PORT_NUM`。
- en: Enter a loop ![](figs/web/U002.png) that iterates through the socket address
    structures returned by the previous step, until the client finds one that can
    be used to successfully create ![](figs/web/U003.png) and connect ![](figs/web/U004.png)
    a socket to the server. Since the client has not bound its socket, the *connect()*
    call causes the kernel to assign an ephemeral port to the socket.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入一个循环！[](figs/web/U002.png)，该循环遍历上一步返回的套接字地址结构，直到客户端找到一个可以成功创建！[](figs/web/U003.png)并连接！[](figs/web/U004.png)套接字到服务器的结构。由于客户端尚未绑定其套接字，*connect()*调用导致内核为套接字分配一个临时端口。
- en: Send an integer specifying the length of the client’s desired sequence ![](figs/web/U005.png).
    This integer is sent as a newline-terminated string.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送一个整数，指定客户端期望的序列的长度！[](figs/web/U005.png)。该整数作为以换行符终止的字符串发送。
- en: Read the sequence number sent back by the server (which is likewise a newline-terminated
    string) ![](figs/web/U006.png) and print it on standard output ![](figs/web/U007.png).
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取服务器返回的序列号（同样是一个以换行符终止的字符串）！[](figs/web/U006.png)，并将其打印到标准输出！[](figs/web/U007.png)。
- en: 'When we run the server and the client on the same host, we see the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在同一主机上运行服务器和客户端时，我们看到以下情况：
- en: '[PRE30]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we demonstrate the use of *telnet* for debugging this application:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们演示如何使用*telnet*调试此应用程序：
- en: '[PRE31]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the shell session log, we see that the kernel cycles sequentially through
    the ephemeral port numbers. (Other implementations exhibit similar behavior.)
    On Linux, this behavior is the result of an optimization to minimize hash lookups
    in the kernel’s table of local socket bindings. When the upper limit for these
    numbers is reached, the kernel recommences allocating an available number starting
    at the low end of the range (defined by the Linux-specific `/proc/sys/net/ipv4/ip_local_port_range`
    file).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell会话日志中，我们看到内核按顺序循环遍历临时端口号。(其他实现也表现出类似的行为。) 在Linux上，这种行为是为了优化内核本地套接字绑定表中的哈希查找。当达到这些端口号的上限时，内核会从范围的低端开始重新分配一个可用的端口号（该范围由Linux特有的`/proc/sys/net/ipv4/ip_local_port_range`文件定义）。
- en: Example 59-7. A client that uses stream sockets
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 示例59-7. 一个使用流套接字的客户端
- en: '[PRE32]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: An Internet Domain Sockets Library
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个互联网域套接字库
- en: In this section, we use the functions presented in [Protocol-Independent Host
    and Service Conversion](ch59.html#protocol-independent_host_and_service_co "Protocol-Independent
    Host and Service Conversion") to implement a library of functions to perform tasks
    commonly required for Internet domain sockets. (This library abstracts many of
    the steps shown in the example programs presented in [Client-Server Example (Stream
    Sockets)](ch59.html#client-server_example_open_parenthesis_s "Client-Server Example
    (Stream Sockets)").) Since these functions employ the protocol-independent *getaddrinfo()*
    and *getnameinfo()* functions, they can be used with both IPv4 and IPv6\. [Example 59-8](ch59.html#header_file_for_inet_underscore_sockets
    "Example 59-8. Header file for inet_sockets.c") shows the header file that declares
    these functions.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用[协议无关的主机和服务转换](ch59.html#protocol-independent_host_and_service_co "协议无关的主机和服务转换")中介绍的功能，来实现一个用于执行常见任务的函数库，这些任务通常适用于互联网域套接字。
    (该函数库抽象了[客户端-服务器示例（流套接字）](ch59.html#client-server_example_open_parenthesis_s "客户端-服务器示例（流套接字）")示例程序中展示的许多步骤。)
    由于这些函数使用了协议无关的*getaddrinfo()*和*getnameinfo()*函数，因此它们可以同时用于IPv4和IPv6。[示例59-8](ch59.html#header_file_for_inet_underscore_sockets
    "示例59-8. inet_sockets.c的头文件")展示了声明这些函数的头文件。
- en: 'Many of the functions in this library have similar arguments:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 该库中的许多函数具有相似的参数：
- en: The *host* argument is a string containing either a hostname or a numeric address
    (in IPv4 dotted-decimal, or IPv6 hex-string notation). Alternatively, *host* can
    be specified as a `NULL` pointer to indicate that the loopback IP address is to
    be used.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*host* 参数是一个字符串，包含主机名或数字地址（IPv4 点分十进制或 IPv6 十六进制字符串表示法）。另外，*host* 也可以指定为 `NULL`
    指针，表示使用回环 IP 地址。'
- en: The *service* argument is either a service name or a port number specified as
    a decimal string.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*service* 参数是一个服务名称或端口号，指定为十进制字符串。'
- en: The *type* argument is a socket type, specified as either `SOCK_STREAM` or `SOCK_DGRAM`.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*type* 参数是套接字类型，可以指定为 `SOCK_STREAM` 或 `SOCK_DGRAM`。'
- en: Example 59-8. Header file for `inet_sockets.c`
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 59-8. `inet_sockets.c` 的头文件
- en: '[PRE33]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The *inetConnect()* function creates a socket with the given socket *type*,
    and connects it to the address specified by *host* and *service*. This function
    is designed for TCP or UDP clients that need to connect their socket to a server
    socket.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*inetConnect()* 函数创建一个具有指定套接字 *type* 的套接字，并将其连接到由 *host* 和 *service* 指定的地址。此函数设计用于需要将其套接字连接到服务器套接字的
    TCP 或 UDP 客户端。'
- en: '[PRE34]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns a file descriptor on success, or -1 on error
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回文件描述符，错误时返回 -1
- en: The file descriptor for the new socket is returned as the function result.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 新套接字的文件描述符作为函数结果返回。
- en: The *inetListen()* function creates a listening stream (`SOCK_STREAM`) socket
    bound to the wildcard IP address on the TCP port specified by *service*. This
    function is designed for use by TCP servers.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*inetListen()* 函数创建一个监听流 (`SOCK_STREAM`) 套接字，并绑定到 *service* 指定的 TCP 端口上的通配符
    IP 地址。此函数设计供 TCP 服务器使用。'
- en: '[PRE35]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns a file descriptor on success, or -1 on error
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回文件描述符，错误时返回 -1
- en: The file descriptor for the new socket is returned as the function result.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 新套接字的文件描述符作为函数结果返回。
- en: The *backlog* argument specifies the permitted backlog of pending connections
    (as for *listen()*).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*backlog* 参数指定允许的挂起连接的最大数量（类似于 *listen()*）。'
- en: If *addrlen* is specified as a non-`NULL` pointer, then the location it points
    to is used to return the size of the socket address structure corresponding to
    the returned file descriptor. This value allows us to allocate a socket address
    buffer of the appropriate size to be passed to a later *accept()* call if we want
    to obtain the address of a connecting client.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *addrlen* 被指定为非 `NULL` 指针，则它指向的位置将用于返回与返回的文件描述符对应的套接字地址结构的大小。这个值使我们能够分配适当大小的套接字地址缓冲区，传递给后续的
    *accept()* 调用，以便获取连接客户端的地址。
- en: The *inetBind()* function creates a socket of the given *type*, bound to the
    wildcard IP address on the port specified by *service* and *type*. (The socket
    *type* indicates whether this is a TCP or UDP service.) This function is designed
    (primarily) for UDP servers and clients to create a socket bound to a specific
    address.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*inetBind()* 函数创建一个指定 *type* 的套接字，并将其绑定到由 *service* 和 *type* 指定的端口上的通配符 IP
    地址。（套接字 *type* 表示这是一个 TCP 还是 UDP 服务。）此函数主要设计用于 UDP 服务器和客户端，创建一个绑定到特定地址的套接字。'
- en: '[PRE36]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns a file descriptor on success, or -1 on error
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回文件描述符，错误时返回 -1
- en: The file descriptor for the new socket is returned as the function result.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 新套接字的文件描述符作为函数结果返回。
- en: As with *inetListen()*, *inetBind()* returns the length of the associated socket
    address structure for this socket in the location pointed to by *addrlen*. This
    is useful if we want to allocate a buffer to pass to *recvfrom()* in order to
    obtain the address of the socket sending a datagram. (Many of the steps required
    for *inetListen()* and *inetBind()* are the same, and these steps are implemented
    within the library by a single function, *inetPassiveSocket()*.)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *inetListen()* 类似，*inetBind()* 会返回一个与该套接字关联的套接字地址结构的长度，这个长度存储在 *addrlen* 指向的位置。如果我们想分配一个缓冲区并将其传递给
    *recvfrom()* 以获取发送数据报的套接字地址，这个值就非常有用。（*inetListen()* 和 *inetBind()* 所需的许多步骤是相同的，这些步骤在库中由一个函数
    *inetPassiveSocket()* 实现。）
- en: The *inetAddressStr()* function converts an Internet socket address to printable
    form.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*inetAddressStr()* 函数将互联网套接字地址转换为可打印的形式。'
- en: '[PRE37]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to *addrStr*, a string containing host and service name
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向 *addrStr* 的指针，*addrStr* 是一个包含主机和服务名称的字符串。
- en: 'Given a socket address structure in *addr*, whose length is specified in *addrlen*,
    *inetAddressStr()* returns a null-terminated string containing the corresponding
    hostname and port number in the following form:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个套接字地址结构 *addr*，其长度由 *addrlen* 指定，*inetAddressStr()* 返回一个以空字符终止的字符串，包含相应的主机名和端口号，格式如下：
- en: '[PRE38]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The string is returned in the buffer pointed to by *addrStr*. The caller must
    specify the size of this buffer in *addrStrLen*. If the returned string would
    exceed (*addrStrLen - 1*) bytes, it is truncated. The constant `IS_ADDR_STR_LEN`
    defines a suggested size for the *addrStr* buffer that should be large enough
    to handle all possible return strings. As its function result, *inetAddressStr()*
    returns *addrStr*.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串被返回在*addrStr*指向的缓冲区中。调用者必须在*addrStrLen*中指定此缓冲区的大小。如果返回的字符串超过了(*addrStrLen
    - 1*)字节，则会被截断。常量`IS_ADDR_STR_LEN`定义了*addrStr*缓冲区的建议大小，应该足够大以容纳所有可能的返回字符串。作为其函数结果，*inetAddressStr()*返回*addrStr*。
- en: The implementation of the functions described in this section is shown in [Example 59-9](ch59.html#an_internet_domain_sockets_librar
    "Example 59-9. An Internet domain sockets library").
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中描述的函数实现见[示例 59-9](ch59.html#an_internet_domain_sockets_librar "示例 59-9. 一个互联网域套接字库")。
- en: Example 59-9. An Internet domain sockets library
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 59-9. 一个互联网域套接字库
- en: '[PRE39]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Obsolete APIs for Host and Service Conversions
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机和服务转换的过时API
- en: In the following sections, we describe the older, now obsolete functions for
    converting host names and service names to and from binary and presentation formats.
    Although new programs should perform these conversions using the modern functions
    described earlier in this chapter, a knowledge of the obsolete functions is useful
    because we may encounter them in older code.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下各节中，我们将描述用于将主机名和服务名在二进制格式和表示格式之间转换的旧函数，这些函数现在已经过时。尽管新的程序应该使用本章前面描述的现代函数进行这些转换，但了解这些过时的函数仍然有用，因为我们可能会在旧代码中遇到它们。
- en: The *inet_aton()* and *inet_ntoa()* Functions
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*inet_aton()*和*inet_ntoa()*函数'
- en: The *inet_aton()* and *inet_ntoa()* functions convert IPv4 addresses between
    dotted-decimal notation and binary form (in network byte order). These functions
    are nowadays made obsolete by *inet_pton()* and *inet_ntop()*.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '*inet_aton()*和*inet_ntoa()*函数在点分十进制表示法和二进制形式（网络字节顺序）之间转换IPv4地址。这些函数如今已被*inet_pton()*和*inet_ntop()*所取代。'
- en: The *inet_aton()* (“ASCII to network”) function converts the dotted-decimal
    string pointed to by *str* into an IPv4 address in network byte order, which is
    returned in the *in_addr* structure pointed to by *addr*.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '*inet_aton*（“ASCII到网络”）函数将*str*指向的点分十进制字符串转换为网络字节顺序中的IPv4地址，并返回该地址，存储在*addr*指向的*in_addr*结构中。'
- en: '[PRE40]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 1 (true) if *str* is a valid dotted-decimal address, or 0 (false) on
    error
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*str*是有效的点分十进制地址，则返回1（真），否则在出错时返回0（假）。
- en: The *inet_aton()* function returns 1 if the conversion was successful, or 0
    if *str* was invalid.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*inet_aton()*函数在转换成功时返回1，如果*str*无效则返回0。'
- en: The numeric components of the string given to *inet_aton()* need not be decimal.
    They can be octal (specified by a leading 0) or hexadecimal (specified by a leading
    0x or 0X). Furthermore, *inet_aton()* supports shorthand forms that allow an address
    to be specified using fewer than four numeric components. (See the *inet(3)* manual
    page for details.) The term *numbers-and-dots notation* is used for the more general
    address strings that employ these features.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给*inet_aton()*的字符串的数字组件不必是十进制的。它们可以是八进制（以0开头）或十六进制（以0x或0X开头）。此外，*inet_aton()*支持简写形式，允许使用少于四个数字组件来指定地址。（有关详细信息，请参见*inet(3)*手册页。）术语*numbers-and-dots
    notation*用于指代使用这些特性的更通用的地址字符串。
- en: SUSv3 doesn’t specify *inet_aton()*. Nevertheless, this function is available
    on most implementations. On Linux, we must define one of the feature test macros
    `_BSD_SOURCE`, `_SVID_SOURCE`, or `_GNU_SOURCE` in order to obtain the declaration
    of *inet_aton()* from `<arpa/inet.h>`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3未规定*inet_aton()*。然而，大多数实现都提供此函数。在Linux上，我们必须定义其中一个特性测试宏`_BSD_SOURCE`、`_SVID_SOURCE`或`_GNU_SOURCE`，才能从`<arpa/inet.h>`中获取*inet_aton()*的声明。
- en: The *inet_ntoa()* (“network to ASCII”) function performs the converse of *inet_aton()*.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '*inet_ntoa*（“网络到ASCII”）函数执行*inet_aton()*的反向操作。'
- en: '[PRE41]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to (statically allocated) dotted-decimal string version of *addr*
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向（静态分配的）点分十进制字符串版本的*addr*的指针。
- en: Given an *in_addr* structure (a 32-bit IPv4 address in network byte order),
    *inet_ntoa()* returns a pointer to a (statically allocated) string containing
    the address in dotted-decimal notation.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个*in_addr*结构（一个32位IPv4地址，采用网络字节顺序），*inet_ntoa()*返回一个指向包含该地址的点分十进制表示法的（静态分配的）字符串的指针。
- en: Because the string returned by *inet_ntoa()* is statically allocated, it is
    overwritten by successive calls.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*inet_ntoa()*返回的字符串是静态分配的，因此会被连续调用覆盖。
- en: The *gethostbyname()* and *gethostbyaddr()* Functions
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*gethostbyname()* 和 *gethostbyaddr()* 函数'
- en: The *gethostbyname()* and *gethostbyaddr()* functions allow conversion between
    hostnames and IP addresses. These functions are nowadays made obsolete by *getaddrinfo()*
    and *getnameinfo()*.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*gethostbyname()* 和 *gethostbyaddr()* 函数允许在主机名和 IP 地址之间进行转换。这些函数如今已被 *getaddrinfo()*
    和 *getnameinfo()* 所淘汰。'
- en: '[PRE42]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return pointer to (statically allocated) *hostent* structure on success,
    or NULL on error
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 两者在成功时返回指向（静态分配的）*hostent* 结构体的指针，出错时返回 NULL。
- en: 'The *gethostbyname()* function resolves the hostname given in *name*, returning
    a pointer to a statically allocated *hostent* structure containing information
    about that hostname. This structure has the following form:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '*gethostbyname()* 函数解析给定的 *name* 主机名，返回指向一个静态分配的 *hostent* 结构体的指针，该结构体包含关于该主机名的信息。该结构体的形式如下：'
- en: '[PRE43]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The *h_name* field returns the official name of the host, as a null-terminated
    string. The *h_aliases* fields points to an array of pointers to null-terminated
    strings containing aliases (alternative names) for this hostname.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*h_name* 字段返回主机的正式名称，作为一个以空字符终止的字符串。*h_aliases* 字段指向一个指针数组，数组中的指针指向包含该主机名别名（替代名称）的以空字符终止的字符串。'
- en: The *h_addr_list* field is an array of pointers to IP address structures for
    this host. (A multihomed host has more than one address.) This list consists of
    either *in_addr* or *in6_addr* structures. We can determine the type of these
    structures from the *h_addrtype* field, which contains either `AF_INET` or `AF_INET6`,
    and their length from the *h_length* field. The *h_addr* definition is provided
    for backward compatibility with earlier implementations (e.g., 4.2BSD) that returned
    just one address in the *hostent* structure. Some existing code relies on this
    name (and thus is not multihomed-host aware).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '*h_addr_list* 字段是指向该主机的 IP 地址结构体的指针数组。（多宿主主机有多个地址。）此列表由 *in_addr* 或 *in6_addr*
    结构体组成。我们可以通过 *h_addrtype* 字段来确定这些结构体的类型，该字段包含 `AF_INET` 或 `AF_INET6`，通过 *h_length*
    字段来确定它们的长度。*h_addr* 定义是为了与早期实现（例如 4.2BSD）保持向后兼容，早期实现只在 *hostent* 结构体中返回一个地址。有些现有代码依赖于此名称（因此不支持多宿主主机）。'
- en: With modern versions of *gethostbyname()*, *name* can also be specified as a
    numeric IP address string; that is, numbers-and-dots notation for IPv4 or hex-string
    notation for IPv6\. In this case, no lookup is performed; instead, *name* is copied
    into the *h_name* field of the *hostent* structure, and *h_addr_list* is set to
    the binary equivalent of *name*.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代版本的 *gethostbyname()* 中，*name* 还可以指定为一个数值 IP 地址字符串；即 IPv4 的数字点分表示法或 IPv6
    的十六进制字符串表示法。在这种情况下，系统不会执行查找操作；相反，*name* 会被复制到 *hostent* 结构体的 *h_name* 字段中，*h_addr_list*
    则被设置为 *name* 的二进制等效值。
- en: The *gethostbyaddr()* function performs the converse of *gethostbyname()*. Given
    a binary IP address, it returns a *hostent* structure containing information about
    the host with that address.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '*gethostbyaddr()* 函数执行 *gethostbyname()* 的反向操作。给定一个二进制 IP 地址，它返回一个 *hostent*
    结构体，包含该地址主机的相关信息。'
- en: On error (e.g., a name could not be resolved), both *gethostbyname()* and *gethostbyaddr()*
    return a `NULL` pointer and set the global variable *h_errno*. As the name suggests,
    this variable is analogous to *errno* (possible values placed in this variable
    are described in the *gethostbyname(3)* manual page), and the *herror()* and *hstrerror()*
    functions are analogous to *perror()* and *strerror()*.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在出错时（例如无法解析某个名称），*gethostbyname()* 和 *gethostbyaddr()* 都返回一个 `NULL` 指针并设置全局变量
    *h_errno*。顾名思义，该变量类似于 *errno*（此变量中可能的值在 *gethostbyname(3)* 手册页中有描述），而 *herror()*
    和 *hstrerror()* 函数类似于 *perror()* 和 *strerror()*。
- en: The *herror()* function displays (on standard error) the string given in *str*,
    followed by a colon (`:`), and then a message for the current error in *h_errno*.
    Alternatively, we can use *hstrerror()* to obtain a pointer to a string corresponding
    to the error value specified in *err*.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '*herror()* 函数会在标准错误输出显示 *str* 中给定的字符串，后跟一个冒号（`:`），然后是当前错误在 *h_errno* 中的消息。或者，我们可以使用
    *hstrerror()* 获取一个指向与 *err* 中指定的错误值对应的字符串的指针。'
- en: '[PRE44]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[Example 59-10](ch59.html#using_gethostbyname_open_parenthesis_clo "Example 59-10. Using
    gethostbyname() to retrieve host information") demonstrates the use of *gethostbyname()*.
    This program displays *hostent* information for each of the hosts named on its
    command line. The following shell session demonstrates the use of this program:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 59-10](ch59.html#using_gethostbyname_open_parenthesis_clo "示例 59-10. 使用
    gethostbyname() 获取主机信息") 演示了 *gethostbyname()* 的使用。该程序显示了命令行中列出的每个主机的 *hostent*
    信息。以下 shell 会话演示了该程序的使用：'
- en: '[PRE45]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Example 59-10. Using *gethostbyname()* to retrieve host information
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 59-10. 使用 *gethostbyname()* 获取主机信息
- en: '[PRE46]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The *getservbyname()* and *getservbyport()* Functions
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*getservbyname()* 和 *getservbyport()* 函数'
- en: The *getservbyname()* and *getservbyport()* functions retrieve records from
    the `/etc/services` file ([The `/etc/services` File](ch59.html#the_solidus_etc_solidus_services_file
    "The /etc/services File")). These functions are nowadays made obsolete by *getaddrinfo()*
    and *getnameinfo()*.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '*getservbyname()* 和 *getservbyport()* 函数从 `/etc/services` 文件中检索记录（[`/etc/services`
    文件](ch59.html#the_solidus_etc_solidus_services_file "The /etc/services File")）。这些函数如今已经被
    *getaddrinfo()* 和 *getnameinfo()* 所淘汰。'
- en: '[PRE47]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return pointer to a (statically allocated) *servent* structure on success,
    or `NULL` on not found or error
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都在成功时返回指向（静态分配的）*servent* 结构的指针，未找到或发生错误时返回 `NULL`。
- en: 'The *getservbyname()* function looks up the record whose service name (or one
    of its aliases) matches *name* and whose protocol matches *proto*. The *proto*
    argument is a string such as *tcp* or *udp*, or it can be `NULL`. If *proto* is
    specified as `NULL`, any record whose service name matches *name* is returned.
    (This is usually sufficient since, where both UDP and TCP records with the same
    name exist in the `/etc/services` file, they normally have the same port number.)
    If a matching record is found, then *getservbyname()* returns a pointer to a statically
    allocated structure of the following type:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '*getservbyname()* 函数查找服务名称（或其别名）与 *name* 匹配且协议与 *proto* 匹配的记录。*proto* 参数是一个字符串，如
    *tcp* 或 *udp*，也可以是 `NULL`。如果 *proto* 被指定为 `NULL`，则返回任何服务名称与 *name* 匹配的记录。（通常这是足够的，因为在
    `/etc/services` 文件中，如果存在相同名称的 UDP 和 TCP 记录，它们通常具有相同的端口号。）如果找到匹配的记录，*getservbyname()*
    将返回指向以下类型的静态分配结构的指针：'
- en: '[PRE48]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Typically, we call *getservbyname()* only in order to obtain the port number,
    which is returned in the *s_port* field.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们仅调用 *getservbyname()* 来获取端口号，该端口号将返回在 *s_port* 字段中。
- en: The *getservbyport()* function performs the converse of *getservbyname()*. It
    returns a *servent* record containing information from the `/etc/services` record
    whose port number matches *port* and whose protocol matches *proto*. Again, we
    can specify *proto* as `NULL`, in which case the call will return any record whose
    port number matches the one specified in *port*. (This may not return the desired
    result in the few cases mentioned above where the same port number maps to different
    service names in UDP and TCP.)
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '*getservbyport()* 函数执行 *getservbyname()* 的反向操作。它返回一个包含来自 `/etc/services` 记录的信息的
    *servent* 记录，该记录的端口号与 *port* 匹配，协议与 *proto* 匹配。同样，我们可以将 *proto* 指定为 `NULL`，在这种情况下，调用将返回任何端口号与
    *port* 中指定的端口号匹配的记录。（在上述少数情况下，可能不会返回期望的结果，因为相同的端口号在 UDP 和 TCP 中可能对应不同的服务名称。）'
- en: Note
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An example of the use of the *getservbyname()* function is provided in the file
    `files/t_getservbyname.c` in the source code distribution for this book.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 本书源代码分发中的 `files/t_getservbyname.c` 文件中提供了一个使用 *getservbyname()* 函数的示例。
- en: UNIX Versus Internet Domain Sockets
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UNIX 与互联网域套接字
- en: When writing applications that communicate over a network, we must necessarily
    use Internet domain sockets. However, when using sockets to communicate between
    applications on the same system, we have the choice of using either Internet or
    UNIX domain sockets. In the case, which domain should we use and why?
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写通过网络通信的应用程序时，我们必须使用互联网域套接字。然而，当使用套接字在同一系统上的应用程序之间进行通信时，我们可以选择使用互联网域套接字或 UNIX
    域套接字。在这种情况下，我们应该使用哪个域，为什么？
- en: 'Writing an application using just Internet domain sockets is often the simplest
    approach, since it will work on both a single host and across a network. However,
    there are some reasons why we may choose to use UNIX domain sockets:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用互联网域套接字编写应用程序通常是最简单的方法，因为它可以在单个主机和网络之间工作。然而，我们可能会选择使用 UNIX 域套接字，原因有以下几点：
- en: On some implementations, UNIX domain sockets are faster than Internet domain
    sockets.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些实现中，UNIX 域套接字比互联网域套接字更快。
- en: We can use directory (and, on Linux, file) permissions to control access to
    UNIX domain sockets, so that only applications with a specified user or group
    ID can connect to a listening stream socket or send a datagram to a datagram socket.
    This provides a simple method of authenticating clients. With Internet domain
    sockets, we need to do rather more work if we wish to authenticate clients.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用目录（以及在 Linux 上的文件）权限来控制对 UNIX 域套接字的访问，以便只有具有指定用户或组 ID 的应用程序才能连接到监听流套接字或向数据报套接字发送数据报。这提供了一种简单的客户端身份验证方法。对于互联网域套接字，如果我们希望验证客户端，则需要做更多的工作。
- en: Using UNIX domain sockets, we can pass open file descriptors and sender credentials,
    as summarized in [Passing File Descriptors](ch61.html#passing_file_descriptors
    "Passing File Descriptors").
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 UNIX 域套接字，我们可以传递打开的文件描述符和发送者凭据，如[传递文件描述符](ch61.html#passing_file_descriptors
    "传递文件描述符")中所总结的。
- en: Further Information
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步的信息
- en: 'There is a wealth of printed and online resources on TCP/IP and the sockets
    API:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 TCP/IP 和套接字 API，有大量的印刷和在线资源：
- en: The key book on network programming with the sockets API is [Stevens at al.,
    2004]. [Snader, 2000] adds some useful guidelines on sockets programming.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络编程的关键书籍是[Stevens 等人, 2004]。[Snader, 2000] 提供了一些关于套接字编程的有用指南。
- en: '[Stevens, 1994] and [Wright & Stevens, 1995] describe TCP/IP in detail. [Comer,
    2000], [Comer & Stevens, 1999], [Comer & Stevens, 2000], [Kozierok, 2005], and
    [Goralksi, 2009] also provide good coverage of the same material.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Stevens, 1994] 和 [Wright & Stevens, 1995] 详细描述了 TCP/IP。[Comer, 2000]、[Comer
    & Stevens, 1999]、[Comer & Stevens, 2000]、[Kozierok, 2005] 和 [Goralksi, 2009] 也提供了对相同内容的很好的介绍。'
- en: '[Tanenbaum, 2002] provides general background on computer networks.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Tanenbaum, 2002] 提供了计算机网络的一般背景。'
- en: '[Herbert, 2004] describes the details of the Linux 2.6 TCP/IP stack.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Herbert, 2004] 描述了 Linux 2.6 TCP/IP 堆栈的细节。'
- en: The GNU C library manual (online at [http://www.gnu.org/](http://www.gnu.org/))
    has an extensive discussion of the sockets API.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU C 库手册（在线地址：[http://www.gnu.org/](http://www.gnu.org/)）详细讨论了套接字 API。
- en: The IBM Redbook, *TCP/IP Tutorial and Technical Overview*, provides lengthy
    coverage of networking concepts, TCP/IP internals, the sockets API, and a host
    of related topics. It is freely downloadable from [http://www.redbooks.ibm.com/](http://www.redbooks.ibm.com/).
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IBM 红皮书《*TCP/IP 教程与技术概述*》提供了关于网络概念、TCP/IP 内部结构、套接字 API 及相关主题的详细内容。它可以从 [http://www.redbooks.ibm.com/](http://www.redbooks.ibm.com/)
    免费下载。
- en: '[Gont, 2008] and [Gont, 2009b] provide security assessments of IPv4 and TCP.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Gont, 2008] 和 [Gont, 2009b] 提供了关于 IPv4 和 TCP 的安全评估。'
- en: The Usenet newsgroup *comp.protocols.tcp-ip* is dedicated to questions related
    to the TCP/IP networking protocols.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Usenet 新sgroup *comp.protocols.tcp-ip* 专门讨论与 TCP/IP 网络协议相关的问题。
- en: '[Sarolahti & Kuznetsov, 2002] describes congestion control and other details
    of the Linux TCP implementation.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Sarolahti & Kuznetsov, 2002] 描述了 Linux TCP 实现中的拥塞控制和其他细节。'
- en: 'Linux-specific information can be found in the following manual pages: *socket(7)*,
    *ip(7)*, *raw(7)*, *tcp(7)*, *udp(7)*, and *packet(7)*.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 Linux 特定信息，请参阅以下手册页面：*socket(7)*、*ip(7)*、*raw(7)*、*tcp(7)*、*udp(7)* 和 *packet(7)*。
- en: See also the RFC list in Section 58.7.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另请参见第 58.7 节中的 RFC 列表。
- en: Summary
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Internet domain sockets allow applications on different hosts to communicate
    via a TCP/IP network. An Internet domain socket address consists of an IP address
    and a port number. In IPv4, an IP address is a 32-bit number; in IPv6, it is a
    128-bit number. Internet domain datagram sockets operate over UDP, providing connectionless,
    unreliable, message-oriented communication. Internet domain stream sockets operate
    over TCP, and provide a reliable, bidirectional, byte-stream communication channel
    between two connected applications.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Internet 域套接字允许不同主机上的应用程序通过 TCP/IP 网络进行通信。一个 Internet 域套接字地址由 IP 地址和端口号组成。在
    IPv4 中，IP 地址是一个 32 位的数字；在 IPv6 中，它是一个 128 位的数字。Internet 域数据报套接字通过 UDP 操作，提供无连接、不可靠的面向消息的通信；Internet
    域流套接字通过 TCP 操作，提供可靠的、双向的字节流通信通道，供两个连接的应用程序之间使用。
- en: 'Different computer architectures use different conventions for representing
    data types. For example, integers may be stored in little-endian or big-endian
    form, and different computers may use different numbers of bytes to represent
    numeric types such as *int* or *long*. These differences mean that we need to
    employ some architecture-independent representation when transferring data between
    heterogeneous machines connected via a network. We noted that various marshalling
    standards exist to deal this problem, and also described a simple solution used
    by many applications: encoding all transmitted data in text form, with fields
    delimited by a designated character (usually a newline).'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的计算机架构使用不同的约定来表示数据类型。例如，整数可能以小端或大端形式存储，不同的计算机可能使用不同的字节数来表示数字类型，如 *int* 或 *long*。这些差异意味着在通过网络传输数据时，我们需要采用一些与架构无关的表示方法。我们提到，已经存在多种标准化的解决方案来应对这个问题，并且描述了一种许多应用程序使用的简单解决方法：将所有传输的数据以文本形式编码，并使用指定字符（通常是换行符）分隔字段。
- en: We looked at a range of functions that can be used to convert between (numeric)
    string representations of IP addresses (dotted-decimal for IPv4 and hex-string
    for IPv6) and their binary equivalents. However, it is generally preferable to
    use host and service names rather than numbers, since names are easier to remember
    and continue to be usable, even if the corresponding number is changed. We looked
    at various functions that convert host and service names to their numeric equivalents
    and vice versa. The modern function for translating host and service names into
    socket addresses is *getaddrinfo()*, but it is common to see the historical functions
    *gethostbyname()* and *getservbyname()* in existing code.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了一些可以用来在 IP 地址的（数字）字符串表示（IPv4 的点分十进制和 IPv6 的十六进制字符串）与其二进制等价物之间转换的函数。然而，通常更推荐使用主机名和服务名，而不是数字，因为名字更容易记住，并且即使对应的数字发生变化，依然可以使用。我们研究了各种将主机名和服务名转换为其数字等价物及反向转换的函数。用于将主机名和服务名转换为套接字地址的现代函数是*getaddrinfo()*，但在现有代码中常见的是历史函数*gethostbyname()*和*getservbyname()*。
- en: Consideration of hostname conversions led us into a discussion of DNS, which
    implements a distributed database for a hierarchical directory service. The advantage
    of DNS is that the management of the database is not centralized. Instead, local
    zone administrators update changes for the hierarchical component of the database
    for which they are responsible, and DNS servers communicate with one another in
    order to resolve a hostname.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 对主机名转换的考虑引发了我们对 DNS 的讨论，DNS 实现了一个分布式数据库，用于提供层级目录服务。DNS 的优势在于数据库管理并不集中化。相反，本地区域管理员更新他们负责的数据库层级部分的更改，DNS
    服务器之间相互通信以解析主机名。
- en: Exercises
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: When reading large quantities of data, the *readLine()* function shown in [Example 59-1](ch59.html#reading_data_a_line_at_a_time
    "Example 59-1. Reading data a line at a time") is inefficient, since a system
    call is required to read each character. A more efficient interface would read
    a block of characters into a buffer and extract a line at a time from this buffer.
    Such an interface might consist of two functions. The first of these functions,
    which might be called *readLineBufInit(fd*, *&rlbuf)*, initializes the bookkeeping
    data structure pointed to by *rlbuf*. This structure includes space for a data
    buffer, the size of that buffer, and a pointer to the next “unread” character
    in that buffer. It also includes a copy of the file descriptor given in the argument
    *fd*. The second function, *readLineBuf(&rlbuf)*, returns the next line from the
    buffer associated with *rlbuf*. If required, this function reads a further block
    of data from the file descriptor saved in *rlbuf*. Implement these two functions.
    Modify the programs in [Example 59-6](ch59.html#an_iterative_server_that_uses_a_stream_s
    "Example 59-6. An iterative server that uses a stream socket to communicate with
    clients") (`is_seqnum_sv.c`) and [Example 59-7](ch59.html#a_client_that_uses_stream_sockets
    "Example 59-7. A client that uses stream sockets") (`is_seqnum_cl.c`) to use these
    functions.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当读取大量数据时，如[示例 59-1](ch59.html#reading_data_a_line_at_a_time "示例 59-1. 一次读取一行数据")中显示的*readLine()*函数效率较低，因为每读取一个字符都需要系统调用。一个更高效的接口是将一块字符读取到缓冲区中，然后从缓冲区中一次提取一行数据。这样的接口可能由两个函数组成。第一个函数，可能被称为*readLineBufInit(fd*,
    *&rlbuf)*，初始化由*rlbuf*指向的记账数据结构。这个结构包括一个数据缓冲区的空间、缓冲区的大小和指向该缓冲区中下一个“未读”字符的指针。它还包括一个参数*fd*给定的文件描述符的副本。第二个函数*readLineBuf(&rlbuf)*从与*rlbuf*相关联的缓冲区返回下一行数据。如果需要，这个函数会从保存在*rlbuf*中的文件描述符中读取更多数据块。实现这两个函数。修改[示例
    59-6](ch59.html#an_iterative_server_that_uses_a_stream_s "示例 59-6. 一个使用流套接字与客户端通信的迭代服务器")
    (`is_seqnum_sv.c`) 和[示例 59-7](ch59.html#a_client_that_uses_stream_sockets "示例
    59-7. 一个使用流套接字的客户端") (`is_seqnum_cl.c`)中的程序，使用这两个函数。
- en: Modify the programs in [Example 59-6](ch59.html#an_iterative_server_that_uses_a_stream_s
    "Example 59-6. An iterative server that uses a stream socket to communicate with
    clients") (`is_seqnum_sv.c`) and [Example 59-7](ch59.html#a_client_that_uses_stream_sockets
    "Example 59-7. A client that uses stream sockets") (`is_seqnum_cl.c`) to use the
    *inetListen()* and *inetConnect()* functions provided in [Example 59-9](ch59.html#an_internet_domain_sockets_librar
    "Example 59-9. An Internet domain sockets library") (`inet_sockets.c`).
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[示例59-6](ch59.html#an_iterative_server_that_uses_a_stream_s "Example 59-6.
    An iterative server that uses a stream socket to communicate with clients")（`is_seqnum_sv.c`）和[示例59-7](ch59.html#a_client_that_uses_stream_sockets
    "Example 59-7. A client that uses stream sockets")（`is_seqnum_cl.c`）中的程序，以使用[示例59-9](ch59.html#an_internet_domain_sockets_librar
    "Example 59-9. An Internet domain sockets library")（`inet_sockets.c`）中提供的*inetListen()*和*inetConnect()*函数。
- en: Write a UNIX domain sockets library with an API similar to the Internet domain
    sockets library shown in [An Internet Domain Sockets Library](ch59.html#an_internet_domain_sockets_library
    "An Internet Domain Sockets Library"). Rewrite the programs in [Example 57-3](ch57.html#a_simple_unix_domain_stream_socket_serve
    "Example 57-3. A simple UNIX domain stream socket server") (`us_xfr_sv.c`, in
    [Stream Sockets in the UNIX Domain](ch57.html#stream_sockets_in_the_unix_domain
    "Stream Sockets in the UNIX Domain")) and [Example 57-4](ch57.html#a_simple_unix_domain_stream_socket_clien
    "Example 57-4. A simple UNIX domain stream socket client") (`us_xfr_cl.c`, in
    [Stream Sockets in the UNIX Domain](ch57.html#stream_sockets_in_the_unix_domain
    "Stream Sockets in the UNIX Domain")) to use this library.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个UNIX域套接字库，API类似于[互联网域套接字库](ch59.html#an_internet_domain_sockets_library
    "An Internet Domain Sockets Library")中展示的Internet域套接字库。重写[示例57-3](ch57.html#a_simple_unix_domain_stream_socket_serve
    "Example 57-3. A simple UNIX domain stream socket server")中的程序（`us_xfr_sv.c`，见[UNIX域中的流套接字](ch57.html#stream_sockets_in_the_unix_domain
    "Stream Sockets in the UNIX Domain")）和[示例57-4](ch57.html#a_simple_unix_domain_stream_socket_clien
    "Example 57-4. A simple UNIX domain stream socket client")中的程序（`us_xfr_cl.c`，见[UNIX域中的流套接字](ch57.html#stream_sockets_in_the_unix_domain
    "Stream Sockets in the UNIX Domain")），以使用该库。
- en: Write a network server that stores name-value pairs. The server should allow
    names to be added, deleted, modified, and retrieved by clients. Write one or more
    client programs to test the server. Optionally, implement some kind of security
    mechanism that allows only the client that created the name to delete it or to
    modify the value associated with it.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个网络服务器，用于存储名称-值对。该服务器应允许客户端添加、删除、修改和检索名称。编写一个或多个客户端程序来测试服务器。可选地，实现某种安全机制，允许仅允许创建名称的客户端删除该名称或修改与其关联的值。
- en: Suppose that we create two Internet domain datagram sockets, bound to specific
    addresses, and connect the first socket to the second. What happens if we create
    a third datagram socket and try to send (*sendto()*) a datagram via that socket
    to the first socket? Write a program to determine the answer.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们创建两个Internet域数据报套接字，绑定到特定地址，并将第一个套接字连接到第二个套接字。如果我们创建第三个数据报套接字，并尝试通过该套接字向第一个套接字发送(*sendto()*)一个数据报，结果会怎样？编写程序来确定答案。
