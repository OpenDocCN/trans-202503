- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 16 STAND-ALONE ASSEMBLY LANGUAGE PROGRAMS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16 独立汇编语言程序
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Until now, this book has relied upon a C/C++ main program to call the example
    code written in assembly language. While this is probably the biggest use of assembly
    language in the real world, it is also possible to write stand-alone code (no
    C/C++ main program) in assembly language. In this chapter, you’ll learn how to
    write such stand-alone programs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书依赖于一个 C/C++ 主程序来调用用汇编语言编写的示例代码。虽然这可能是现实世界中使用汇编语言的最大案例，但也可以编写独立的汇编程序（不需要
    C/C++ 主程序）。在本章中，你将学习如何编写这样的独立程序。
- en: For the purposes of this book, *stand-alone assembly language program* means
    that the assembly language code contains an actual *main* program (not asmMain,
    which is just a function that a C++ program calls). Such a program does not make
    any C/C++ stdlib calls; the only external calls to code outside the application
    itself are OS API function calls.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 就本书而言，*独立汇编语言程序*指的是汇编语言代码包含一个实际的 *main* 程序（而不是 asmMain，它只是 C++ 程序调用的一个函数）。这样的程序不进行任何
    C/C++ stdlib 调用；唯一的外部调用是操作系统 API 函数调用。
- en: NOTE
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Some readers might take the term* stand-alone *to mean that an assembly language
    program makes no external function calls, not even to an OS, and handles all I/O
    at the hardware level within the application itself. That’s an appropriate definition
    for embedded systems, but not the definition I use in this book.*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*一些读者可能会将“独立程序”一词理解为汇编语言程序不进行任何外部函数调用，甚至不调用操作系统，而是在应用程序内部以硬件级别处理所有 I/O。这个定义适用于嵌入式系统，但不是本书中的定义。*'
- en: 'Technically, your assembly code will always be called by a C/C++ program. That’s
    because the OS itself is written in C/C++, with a tiny bit of assembly code. When
    the OS transfers control to your assembly code, this is not much different from
    a C/C++ main program calling your assembly code. Nevertheless, “pure” assembly
    applications have some clear advantages: you’re not dragging along the C/C++ library
    code and application runtime system, so your programs can be smaller and you won’t
    have external naming conflicts with C/C++ public names.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，你的汇编代码总是会被 C/C++ 程序调用。这是因为操作系统本身是用 C/C++ 编写的，只有极少量的汇编代码。当操作系统将控制权转交给你的汇编代码时，这与
    C/C++ 主程序调用你的汇编代码没有太大区别。然而，“纯”汇编应用程序有一些明显的优势：你不需要携带 C/C++ 库代码和应用程序运行时系统，因此你的程序可以更小，而且不会与
    C/C++ 公共名称发生外部命名冲突。
- en: 'This chapter covers OS system calls for macOS and Linux (including Pi OS).
    It begins by explaining how to maintain portability in your code, given that system
    calls are not portable between OSes. It then introduces the concept of system
    calls for these two OSes. After discussing the svc (supervisor call) instruction
    used to make calls to OS API functions, it provides two examples: a stand-alone
    “Hello, world!” application and a file I/O application. Finally, it points out
    that macOS frowns on direct system calls and expects you to interface to the OS
    via C library function calls.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了适用于 macOS 和 Linux（包括 Pi OS）的操作系统系统调用。它首先解释了如何在代码中保持可移植性，因为系统调用在不同操作系统之间并不具有可移植性。接下来介绍了这两个操作系统的系统调用概念。在讨论了用于调用操作系统
    API 函数的 svc（超级调用）指令之后，提供了两个示例：一个独立的“Hello, world!”应用程序和一个文件 I/O 应用程序。最后指出，macOS
    不鼓励直接进行系统调用，而是希望你通过 C 库函数调用与操作系统进行交互。
- en: 16.1 Portability Issues with System Calls
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1 系统调用的可移植性问题
- en: 'While most of the example programs appearing in this book so far are portable
    between macOS and Linux, system API calls vary by OS. Code in the previous chapters
    ignored this issue by calling C/C++ stdlib functions that handled the low-level
    OS details, but the example code in this chapter makes OS-specific calls. Therefore,
    portability won’t happen automatically. You have four options for handling this
    issue:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管到目前为止，本书中的大多数示例程序在 macOS 和 Linux 之间是可移植的，但系统 API 调用因操作系统而异。前几章中的代码通过调用 C/C++
    stdlib 函数来处理操作系统的低级细节，忽略了这个问题，但本章中的示例代码则进行了操作系统特定的调用。因此，可移植性不会自动发生。你有四种方法来处理这个问题：
- en: Ignore portability and write a given example program only for macOS or only
    for Linux. In general, I take this approach when writing code specific to an OS.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略可移植性，仅为 macOS 或 Linux 编写给定的示例程序。通常，在编写特定于操作系统的代码时，我会采用这种方法。
- en: 'Write two (nonportable) versions of the same program: one for Linux and one
    for macOS.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写两个（不可移植的）版本的相同程序：一个适用于 Linux，一个适用于 macOS。
- en: Write a single program that uses conditional assembly to include OS-specific
    code, as necessary.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个单一的程序，使用条件汇编根据需要包含操作系统特定的代码。
- en: Create two wrapper files, one that has macOS versions of OS calls and another
    that has Linux version, and include the appropriate wrapper with your main (portable)
    code.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建两个封装文件，一个包含macOS版本的操作系统调用，另一个包含Linux版本的操作系统调用，并将适当的封装文件与主（便携式）代码一起包含。
- en: The appropriate mechanism to use depends on your application. If you are not
    interested in writing portable assembly code that will work across OSes (the most
    common case when writing assembly applications), you’ll use the first approach
    and write code just for the OS you are targeting.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哪种机制取决于你的应用。如果你不打算编写能够跨操作系统工作的便携式汇编代码（编写汇编应用时最常见的情况），你将采用第一种方法，仅为你所针对的操作系统编写代码。
- en: If you do want your assembly application to run on macOS and Linux, your approach
    will depend on the size of the application. If the application is relatively small,
    writing two OS-specific variants is not that difficult (though maintenance may
    be an issue, as you’ll have to maintain two separate versions of the application).
    If the application is large, or you expect to upgrade and maintain it frequently,
    the third or fourth approach is probably better. A single application that uses
    conditional assembly to deal with OS-specific issues is usually much easier to
    maintain and expand than two separate applications, and using wrapper code makes
    it easier to maintain the code for each specific OS.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的汇编应用在macOS和Linux上运行，你的选择将取决于应用的规模。如果应用相对较小，编写两个操作系统特定的变种并不难（尽管维护可能是一个问题，因为你需要维护两个独立版本的应用）。如果应用程序较大，或者你预计会频繁升级和维护它，第三种或第四种方法可能更好。使用条件汇编来处理操作系统特定问题的单一应用程序通常比两个独立的应用程序更容易维护和扩展，而使用封装代码使得维护每个特定操作系统的代码更加容易。
- en: 'There is a fifth approach: write all your OS-dependent code in C/C++ and call
    assembly functions that deal with the non-OS-specific functionality. That’s how
    all the example programs in this book have been written.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第五种方法：将所有操作系统相关的代码用C/C++编写，并调用处理与操作系统无关的功能的汇编函数。这就是本书中所有示例程序的编写方式。
- en: It should go without saying that the code in this chapter does not use the *build*
    script to compile/assemble the example applications. The *build* script assumes
    the use of the *c.cpp* main program (and the whole point of this chapter is to
    stop using that code). Therefore, each example program in this chapter includes
    a makefile that builds the code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，本章中的代码没有使用*build*脚本来编译/汇编示例应用程序。*build*脚本假设使用*c.cpp*主程序（而本章的重点就是停止使用该代码）。因此，本章中的每个示例程序都包含一个makefile，用于构建代码。
- en: 16.2 Stand-Alone Code and System Calls
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2 独立代码与系统调用
- en: The first example program in this book, Listing 1-1 on [page 5](chapter1.xhtml#pg_5),
    is a stand-alone program. Here it is as Listing 16-1, with a couple of changes,
    for the sake of discussion.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的第一个示例程序是[第5页](chapter1.xhtml#pg_5)上的清单1-1，它是一个独立程序。为了讨论的需要，下面是经过几处修改后的清单16-1。
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I’ve made two changes to this code compared with that in Listing 1-1\. At both
    instances of ❶ and ❷, I’ve introduced a new symbol, main (and _main). This is
    because Linux requires the main program to be named main, whereas macOS requires
    the name _main. Were you to attempt to compile Listing 1-1 under Linux, you would
    get something like an undefined reference to `main` message. Rather than mess
    around with conditional assembly (or write two separate versions of Listing 16-1),
    I simply include both symbols in the source file. Linux largely ignores the _main
    symbol, and macOS ignores the main symbol; the program happily compiles under
    either OS.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与清单1-1中的代码相比，我对这段代码进行了两处修改。在❶和❷的位置，我引入了一个新符号，main（和_main）。这是因为Linux要求主程序命名为main，而macOS要求命名为_main。如果你尝试在Linux上编译清单1-1，你会得到类似“未定义的`main`引用”这样的错误消息。我干脆在源文件中同时包含这两个符号，而不是处理条件汇编（或编写两个独立的清单16-1版本）。Linux大多忽略_main符号，macOS忽略main符号；因此，该程序能够在任一操作系统上顺利编译。
- en: 'Listing 16-1 consists of a single instruction: ret ❸. On entry, the LR register
    contains a return address that transfers control back to the OS. Therefore, this
    program (should you actually execute it) returns immediately to the OS.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 清单16-1由一条指令组成：ret ❸。进入时，LR寄存器包含一个返回地址，将控制转回操作系统。因此，这个程序（如果你真的执行它）会立即返回到操作系统。
- en: 'Although returning to the OS via a ret instruction works (particularly if building
    this code with GCC), this isn’t the standard way to return to Linux or macOS.
    Instead, an application should make a call to the exit() API function. To call
    a system API function, a program must load a function number into a register,
    load appropriate parameters into the parameter registers (X0 through X7), and
    then execute the supervisor (OS) call instruction svc #OSint, where OSint is 0
    for Linux and 0x80 for macOS.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '尽管通过 ret 指令返回操作系统有效（特别是在使用 GCC 构建此代码时），但这不是返回 Linux 或 macOS 的标准方式。相反，应用程序应该调用
    exit() API 函数。要调用系统 API 函数，程序必须将函数号加载到寄存器中，将适当的参数加载到参数寄存器（X0 至 X7）中，然后执行超级用户（操作系统）调用指令
    svc #OSint，其中 OSint 对于 Linux 是 0，对于 macOS 是 0x80。'
- en: NOTE
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*In reality, macOS seems to ignore the immediate constant following the* svc
    *instruction. Many online examples use the value 0 as the* svc *operand (and personal
    experiments show that it works). However, the macOS source code seems to use 0x80
    as the constant, so I recommend using this value under macOS.*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*实际上，macOS 似乎忽略了 svc 指令后面的立即数常量。许多在线示例使用值 0 作为 svc 操作数（个人实验也证明它有效）。然而，macOS
    源代码似乎使用 0x80 作为常量，因此我建议在 macOS 下使用该值。*'
- en: 'Under Linux, you load the system call number into the X8 register, while under
    macOS you load this into X16\. I’ve added the following statements in *aoaa.inc*
    to handle this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，您将系统调用号加载到 X8 寄存器中，而在 macOS 中，您将其加载到 X16 寄存器中。我在 *aoaa.inc* 中添加了以下语句来处理此问题：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Under both Linux and macOS, the exit function expects a single integer parameter
    in the X0 register holding the program’s return code (generally this is 0 if no
    errors occurred while running the program). The only question remaining is, “What
    is the system call number for exit()?” Under Linux, the code is 93, while under
    macOS it’s 1 (I’ll discuss how I determined these magic numbers in section 16.3,
    “The svc Interface and OS Portability,” on the next page). Listing 16-2 provides
    a very simple assembly application that immediately returns to the OS and that
    you can compile for macOS or Linux.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 和 macOS 下，exit 函数期望在 X0 寄存器中接收一个整数参数，该参数保存程序的返回码（如果程序运行时没有发生错误，通常为 0）。剩下的唯一问题是，“exit()
    的系统调用号是多少？”在 Linux 下，代码是 93，而在 macOS 下是 1（我将在第 16.3 节“svc 接口与操作系统可移植性”中讨论我是如何确定这些魔法数字的，详情请见下一页）。列表
    16-2 提供了一个非常简单的汇编应用程序，它立即返回到操作系统，您可以为 macOS 或 Linux 编译它。
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Listing 16-2 includes *aoaa.inc* ❶ in order to generate an error if the OS symbol
    (Linux or Darwin) is not defined on the command line (which *aoaa.inc* translates
    to isLinux or isMacOS), as well as to obtain the OSint and svcReg constants.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16-2 包含 *aoaa.inc* ❶ 以便在命令行中未定义操作系统符号（Linux 或 Darwin）时生成错误（*aoaa.inc* 将其转换为
    isLinux 或 isMacOS），并获取 OSint 和 svcReg 常量。
- en: The program uses conditional assembly to generate the different code needed
    for macOS or Linux, setting the constant exitCode equal to the OS’s exit function
    number ❷. This function loads X0 with 0 ❸ to indicate success when it returns.
    It then loads the exitCode function number into the OS’s function number parameter
    register ❹ (svcReg is X8 under Linux and X16 under macOS, as defined in *aoaa.inc*,
    as per the previous example). Finally, the code issues the supervisor call instruction
    to call the OS ❺. Because of the nature of this call, the svc instruction never
    returns control back to the program, so there is no need for a ret instruction.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序使用条件汇编来生成适用于 macOS 或 Linux 的不同代码，将常量 exitCode 设置为操作系统的退出函数号 ❷。该函数将 0 ❸ 加载到
    X0 寄存器中，表示成功并返回。然后，它将 exitCode 函数号加载到操作系统的函数号参数寄存器 ❹（在 Linux 中为 X8，在 macOS 中为
    X16，如 *aoaa.inc* 中定义，参见前面的示例）。最后，代码发出超级用户调用指令，调用操作系统 ❺。由于此调用的性质，svc 指令永远不会将控制返回给程序，因此无需
    ret 指令。
- en: 'Here’s the makefile to build the program in Listing 16-2:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是构建列表 16-2 中程序的 makefile：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To build and run this program, enter the following commands into the shell
    program:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建并运行此程序，请在 shell 程序中输入以下命令：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The program returns without producing any output, as expected.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 程序按预期返回，而没有产生任何输出。
- en: 16.3 The svc Interface and OS Portability
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3 svc 接口与操作系统可移植性
- en: Both macOS and Linux use the supervisor call instruction (svc) to make API calls
    to the OS. However, the exact calling sequence varies considerably between the
    two OSes. This section clarifies the differences between them with respect to
    the functions (the API) that they support—in particular, regarding call numbers,
    parameters, and error handling.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: macOS和Linux都使用主管调用指令（svc）向操作系统发出API调用。然而，两个操作系统之间的实际调用顺序差异很大。本节将阐明它们在支持的功能（API）方面的区别，特别是在调用号、参数和错误处理方面。
- en: Although both OSes are Unix based (and share many POSIX-compliant functions),
    each has its own set of OS-specific functions that may have no equivalence on
    the other system. Even the common (for example, POSIX) functions may expect different
    arguments and produce different return results, meaning you must be especially
    careful when attempting to write assembly code that is portable between these
    two OSes. This is a good example of how using wrappers to localize OS system calls
    can help improve the portability and maintainability of your code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两个操作系统都是基于Unix的（并共享许多符合POSIX标准的功能），每个操作系统都有自己的一套特定的操作系统函数，这些函数在另一个系统中可能没有对应的功能。即使是常见的（例如POSIX）函数，也可能期望不同的参数并产生不同的返回结果，这意味着在编写能够在这两个操作系统之间移植的汇编代码时，必须特别小心。这是一个很好的例子，说明使用包装器来本地化操作系统系统调用有助于提高代码的可移植性和可维护性。
- en: 16.3.1 Call Numbers
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.3.1 调用号
- en: 'As noted earlier, the function call number values differ between OSes, as does
    the location where you pass the call numbers (X8 for Linux, X16 for macOS). It’s
    easy enough to overcome the register location issue by using a #define (or .req
    directive). However, the function call number values are completely OS dependent.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，函数调用号在不同操作系统之间有所不同，传递调用号的位置也不同（Linux使用X8，macOS使用X16）。通过使用#define（或.reqdirective）来克服寄存器位置问题相对容易。然而，函数调用号的值完全依赖于操作系统。
- en: The *sys*/*syscall.h* file is a header file that contains definitions for all
    the system API call numbers. (You can include it in an assembly language source
    file even though it’s a C header file.) This file is generally installed on your
    system when you install your C compiler (GCC or Clang) and is typically found
    in the default include path used by the compiler. See the GCC or Xcode documentation
    for more details.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*sys*/*syscall.h*文件是一个头文件，包含了所有系统API调用号的定义。（即使它是一个C头文件，你也可以在汇编语言源文件中包含它。）当你安装C编译器（如GCC或Clang）时，这个文件通常会安装到你的系统中，并通常位于编译器默认的包含路径中。有关更多详细信息，请参见GCC或Xcode文档。'
- en: 'Although #include <sys/syscall.h> will work on both Linux and macOS, the actual
    definitions may appear in a different file elsewhere in the compiler’s directory
    tree, with an appropriate #include inside *sys*/*syscall.h* leading to the actual
    file.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然#包括<sys/syscall.h>在Linux和macOS上都能工作，但实际的定义可能出现在编译器目录树中的其他文件中，*sys*/*syscall.h*中会有适当的#include指令来指向实际文件。
- en: 'Here are a few lines from *sys/syscall.h* on a macOS machine:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是macOS机器上*sys/syscall.h*文件中的几行内容：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The #ifdef statement in this code is a warning that Apple considers the svc
    API interface to be undocumented and private, as discussed in the “Using svc Under
    macOS” box on the next page.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码中的#ifdef语句是一个警告，Apple认为svc API接口是未记录的并且是私有的，正如下一页“在macOS下使用svc”框中所讨论的那样。
- en: On my macOS system, I used the Unix find command to locate *sys*/*syscall.h*
    buried deep in the Xcode directory path */Library/Developer/CommandLineTools/SDK/
    ...* , but your mileage may vary.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的macOS系统上，我使用Unix的find命令定位*sys*/*syscall.h*，它深埋在Xcode目录路径*/Library/Developer/CommandLineTools/SDK/
    ...* 中，但你的情况可能不同。
- en: 'Under Debian Linux, #include <sys/syscall.h> includes */usr/include/asm -generic/unistd.h*
    (again, use the Unix find command if this file isn’t present at this location).
    Here are a few lines from that file, sorted to match the order of the statements
    in the macOS *syscall.h* file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian Linux下，#include <sys/syscall.h>包括了*/usr/include/asm-generic/unistd.h*（如果该文件不在此位置，可以再次使用Unix的find命令）。以下是该文件中的几行内容，按与macOS
    *syscall.h*文件中语句的顺序排列：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, the function names, the constant names, and the function call
    numbers in the two files don’t agree. For example, Linux generally prefers openat()
    over the open() function. Fortunately, macOS also provides openat(), so it’s possible
    to use the same function on both OSes. However, the symbolic names macOS and Linux
    use for the same functions are quite different, which means including *sys/syscall.h*
    isn’t a portable solution. You’ll still have to provide your own local names that
    map to the corresponding Linux and macOS names (suggestion: use two syscall wrapper
    *.S* files, one for Mac and one for Linux, to resolve these problems).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，两个文件中的函数名、常量名和函数调用号并不一致。例如，Linux 通常更倾向于使用 openat() 而不是 open() 函数。幸运的是，macOS
    也提供了 openat()，因此在两个操作系统上使用相同的函数是可能的。然而，macOS 和 Linux 对相同函数的符号名称却有很大不同，这意味着包含 *sys/syscall.h*
    不是一个可移植的解决方案。你仍然需要提供自己的本地名称，将其映射到对应的 Linux 和 macOS 名称（建议：使用两个 syscall 封装 *.S*
    文件，一个用于 Mac，一个用于 Linux，来解决这些问题）。
- en: 'Unfortunately, the *sys/syscall.h* header files don’t provide the parameter
    lists for the various functions. You can find the parameter information for Linux
    at *[https://<wbr>arm<wbr>.syscall<wbr>.sh](https://arm.syscall.sh)*. For example,
    consider the entry for the exit() function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，*sys/syscall.h* 头文件没有提供各个函数的参数列表。你可以在 *[https://<wbr>arm<wbr>.syscall<wbr>.sh](https://arm.syscall.sh)*
    找到 Linux 的参数信息。例如，考虑 exit() 函数的条目：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This line tells you that X8 must contain 0x5D (93) and X0 must contain the exit
    code (error_code). Linux system calls have a maximum of six parameters (X0 through
    X5), but exit() uses only one of them (in addition to the function call number
    in X8).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行告诉你，X8 必须包含 0x5D（93），而 X0 必须包含退出代码（error_code）。Linux 系统调用最多有六个参数（X0 到 X5），但
    exit() 只使用其中一个（除了函数调用号在 X8 中）。
- en: On macOS, you must use the macOS call number (1 for exit) and load that call
    number into X16\. The parameters are generally the same for equivalent macOS functions,
    subject (of course) to the differences in the Linux versus macOS ABI (see section
    16.8, “For More Information,” on [page 930](chapter16.xhtml#pg_930) for the set
    of system calls).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，你必须使用 macOS 的调用号（exit 的调用号为 1），并将该调用号加载到 X16 中。参数通常对于等效的 macOS 函数相同，但当然受到
    Linux 与 macOS ABI 差异的影响（请参阅第 16.8 节，“更多信息”，在 [930 页](chapter16.xhtml#pg_930) 中查看系统调用的集合）。
- en: 16.3.2 API Parameters
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.3.2 API 参数
- en: 'As a general rule, all the system calls have well-defined names and parameter
    lists, which you can find online by searching for the function’s name or by using
    the man command at the command line. For example, the openat() call has the following
    parameters (from the Linux man page):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，所有系统调用都有明确定义的名称和参数列表，你可以通过搜索函数名称或使用命令行的 man 命令在线查找。例如，openat() 调用具有以下参数（来自
    Linux 手册页）：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The openat code (57 in Linux, 463 under macOS) goes in X8 (Linux) or X16 (macOS),
    a directory descriptor goes in X0, a pointer to the filename (pathname) goes in
    X1, and the flags get passed in X2 (an optional mode parameter can be passed in
    X3). You choose the parameter registers according to the ARM ABI.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: openat 函数的代码（在 Linux 中为 57，在 macOS 中为 463）放在 X8（Linux）或 X16（macOS）寄存器中，目录描述符放在
    X0 中，指向文件名（路径名）的指针放在 X1 中，标志参数传入 X2（一个可选的模式参数可以传入 X3）。你需要根据 ARM ABI 选择参数寄存器。
- en: 'To create code that’s portable between macOS and Linux, you can use the following
    conditional assembly at the beginning of your source file to select the constants
    based on the OS:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建在 macOS 和 Linux 之间可移植的代码，你可以在源文件的开头使用以下条件汇编，根据操作系统选择常量：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From this point forward, you can use the symbols sys_* on either OS. Of course,
    if you don’t require portability between the two OSes, you can simply include
    *sys/syscall.h* and use the SYS_* or _NR_* symbols as appropriate for your OS
    choice.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从此之后，你可以在任一操作系统上使用 sys_* 符号。当然，如果你不需要在两个操作系统之间的可移植性，你可以简单地包含 *sys/syscall.h*
    并根据你的操作系统选择适当使用 SYS_* 或 _NR_* 符号。
- en: 16.3.3 API Error Handling
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.3.3 API 错误处理
- en: One other big difference between macOS and Linux API calls is in the way they
    return an indication of an error. For macOS API calls, the error status is returned
    in the carry flag (C = 1 for error, C = 0 for no error). If the carry flag is
    set, macOS returns an error code in the X0 register. Linux, on the other hand,
    returns –1 in X0 if there is an error; you must then fetch the actual error code
    from the errno variable (as shown in Listing 7-2 on [page 358](chapter7.xhtml#pg_358),
    for example).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: macOS和Linux API调用之间的另一个重大区别在于它们返回错误指示的方式。对于macOS API调用，错误状态通过进位标志返回（C = 1表示错误，C
    = 0表示没有错误）。如果进位标志被设置，macOS会在X0寄存器中返回一个错误代码。而Linux则是在X0中返回–1来表示错误；然后你必须从errno变量中获取实际的错误代码（例如，参见[第358页](chapter7.xhtml#pg_358)中的第7-2号清单）。
- en: 'Dealing with error return values in portable code could be problematic. One
    solution is to use a set of wrapper functions to handle errors in an OS-specific
    fashion for each OS. I’ve chosen to create a small macro to translate the error
    return status to a common value on both macOS and Linux:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在可移植代码中处理错误返回值可能会存在问题。一种解决方案是使用一组包装函数，以操作系统特定的方式处理每个操作系统中的错误。我选择创建一个小宏，将错误返回状态转换为macOS和Linux下通用的值：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Under macOS, if the carry is clear ❶, then this macro does nothing (no error).
    If there is an error (carry set), the macro negates the value in X0 ❷ (which is
    currently a positive error code).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS下，如果进位标志未设置 ❶，则此宏不做任何操作（没有错误）。如果发生错误（进位标志设置），宏会取反X0中的值 ❷（目前是一个正的错误代码）。
- en: Under Linux, an error is indicated by returning –1 in X0, in which case the
    code has to retrieve the actual error code from the errno variable. If the API
    function returns –1 ❸, the code fetches errno’s value ❹ (which is a positive number)
    and negates it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，错误通过在X0中返回–1来表示，在这种情况下，代码必须从errno变量中检索实际的错误代码。如果API函数返回–1 ❸，代码将获取errno的值
    ❹（这是一个正数），并对其取反。
- en: This macro assumes that the API function will return a nonnegative result in
    X0 if there is no error, so it returns a negation of the actual error code if
    there was an error. This will provide a sign-consistent set of values you can
    test for under either OS.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏假设API函数在没有错误时会在X0中返回一个非负值，因此如果发生错误，它会返回实际错误代码的相反值。这将提供一组一致的符号值，你可以在任何操作系统下进行测试。
- en: Although the checkError macro produces a portable set of error codes, do not
    assume that the two OSes will produce exactly the same error codes for any given
    situation. They are more likely to produce slightly different error codes under
    the same circumstances. At the very least, you should be able to handle any error
    return code that either the macOS or Linux man pages list for a given API function
    (yet another argument for using a wrapper function to handle error codes in portable
    code).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管checkError宏生成了一组可移植的错误代码，但不要假设这两个操作系统在任何给定情况下会产生完全相同的错误代码。在相同的情况下，它们更可能产生略有不同的错误代码。至少，你应该能够处理任何macOS或Linux手册页中列出的给定API函数的错误返回代码（这再次证明了使用包装函数来处理可移植代码中的错误代码的必要性）。
- en: You can lift the appropriate defines from the *errno.h* file (or other files
    it may include); this will allow you to refer to Unix-compatible constant names
    like EPERM or EACCES in your assembly source code. Don’t forget that the checkError
    macro negates the error code, so you have to compare against negated *errno.h*
    constants (for example, -EPERM or -EACCES).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从*errno.h*文件（或它可能包含的其他文件）中提取适当的定义；这将允许你在汇编源代码中引用类似EPERM或EACCES的Unix兼容常量名。别忘了，checkError宏会取反错误代码，因此你需要与取反后的*errno.h*常量进行比较（例如，-EPERM或-EACCES）。
- en: 16.4 A Stand-Alone “Hello, World!” Program
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4 独立的“Hello, World!”程序
- en: By convention, the first “real” program to try when writing a stand-alone assembly
    program is “Hello, world!” Under Linux and macOS, you can use the system write()
    function to write a string to the standard output device, as shown in Listing
    16-3.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 按惯例，编写独立汇编程序时第一个“真实”的程序是“Hello, world!”在Linux和macOS下，你可以使用系统的write()函数将字符串写入标准输出设备，如第16-3号清单所示。
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In Listing 16-3, the #include statement loads in the operating-specific constant
    names for the API function call values ❶. The code defines the system call constants
    for macOS ❷. As the write symbol was already defined in the *aoaa.inc* header
    file (the name of the C stdlib write() function), I’ve used sys_write to overcome
    namespace pollution. Likewise, the code defines the Linux system call constants
    ❸.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单 16-3 中，`#include` 语句加载了操作系统特定的常量名称，用于 API 函数调用的值 ❶。该代码定义了 macOS 的系统调用常量
    ❷。由于 `write` 符号已经在 *aoaa.inc* 头文件中定义（即 C 标准库的 `write()` 函数），我使用了 `sys_write` 来避免命名空间污染。同样，代码还定义了
    Linux 系统调用常量 ❸。
- en: Calling the system API write() function prints Hello, world! ❹. This call expects
    a pointer to the string in X1, the string length in X2, and a file descriptor
    value in X0\. For the stdout device, the file descriptor is 1\. Finally, I include
    the usual program termination code ❺.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 调用系统 API `write()` 函数会打印 "Hello, world!" ❹。这个调用期望将字符串的指针放入 X1 寄存器，字符串的长度放入 X2
    寄存器，以及文件描述符的值放入 X0 寄存器。对于 stdout 设备，文件描述符是 1。最后，我包含了通常的程序终止代码 ❺。
- en: Note that the C stdlib write() function is nothing more than facade code that
    directly calls the Linux write() API function. If we were willing to link with
    C code, we could have accomplished the same thing by calling write(), but doing
    so would defeat the purpose of this chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，C 标准库的 `write()` 函数不过是直接调用 Linux `write()` API 函数的外观代码。如果我们愿意与 C 代码链接，我们也可以通过调用
    `write()` 来实现相同的功能，但这样做会违背本章的目的。
- en: 'Here’s the makefile that will build the program in Listing 16-3:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将构建清单 16-3 中程序的 makefile：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here are the commands to build and run the program, along with the sample output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是构建和运行程序的命令，以及示例输出：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that the program did not print Calling Listing16-3 nor Listing16-3 terminated.
    That output is produced by the *c.cpp* main() function, which this code is not
    using.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，程序并没有打印“调用清单16-3”或“清单16-3终止”。这些输出是由 *c.cpp* 中的 main() 函数产生的，而这段代码并没有使用它。
- en: 16.5 A Sample File I/O Program
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.5 一个示例文件 I/O 程序
- en: 'File I/O has been conspicuously absent from the book thus far. While reading
    and writing file data is easily achieved using the C stdlib functions such as
    fopen, fclose, and fprintf, the Linux and macOS APIs provide many useful functions
    (on which the C stdlib is built) for this purpose. This section describes a few
    of these functions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 I/O 在本书中至今一直缺席。尽管使用 C 标准库中的 fopen、fclose 和 fprintf 等函数可以轻松实现读写文件数据，但 Linux
    和 macOS 的 API 提供了许多有用的函数（C 标准库就是基于这些函数构建的），可以用于此目的。本节将介绍其中的一些函数：
- en: open    Open (or create) a file for reading, writing, or appending.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: open    打开（或创建）一个文件，用于读取、写入或追加。
- en: read    Read data from an open file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: read    从打开的文件中读取数据。
- en: write    Write data to an open file.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: write    将数据写入一个打开的文件。
- en: close    Close an open file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: close    关闭一个打开的文件。
- en: 'For the purposes of this example, I’ll implement these calls as a *files* library
    consisting of three source modules:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 出于本示例的目的，我将实现这些调用为一个名为 *files* 的库，包含三个源模块：
- en: '***volatile.S***    A pair of utility functions that save and restore all the
    volatile registers'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '***volatile.S***    一对用于保存和恢复所有易失性寄存器的工具函数。'
- en: '***stdio.S***    A set of I/O routines that write data to the stdout device
    and read data from the stdin device (console I/O)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '***stdio.S***    一组 I/O 例程，用于将数据写入 stdout 设备并从 stdin 设备读取数据（控制台 I/O）。'
- en: '***files.S***    A set of routines for opening, reading, writing, and closing
    files'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '***files.S***    一组用于打开、读取、写入和关闭文件的例程。'
- en: 'I’ve put these files in a *files* subdirectory, along with a *files.mak* makefile
    that will assemble these files and put them in a *file.a* archive file. Here’s
    the makefile:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这些文件放在一个 *files* 子目录中，并提供了一个 *files.mak* makefile，它将汇编这些文件并将它们放入一个 *file.a*
    归档文件中。以下是该 makefile：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After this makefile successfully builds the source files (and combines them
    into the *file.a* archive file) ❶, it copies *file.a* into the parent directory,
    where the application that uses *files.a* appears.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 makefile 成功构建源文件（并将它们组合成 *file.a* 归档文件）后 ❶，它将 *file.a* 复制到父目录中，应用程序会在那里使用
    *files.a*。
- en: 'Before discussing the file library’s source files, I’ll present the *files.inc*
    header file, since it contains definitions that both the library and application
    source code will use:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论文件库的源文件之前，我将首先介绍 *files.inc* 头文件，因为它包含了库和应用程序源代码都将使用的定义：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As mentioned earlier, the macOS SYS_* symbols appear inside an #ifdef block
    that hides the definitions if the symbol __APPLE_API_PRIVATE is not defined. Therefore,
    when including the sys/syscall.h header file under macOS, *files.inc* needs to
    define the symbol __APPLE_API_PRIVATE so that all the SYS_* labels will be processed
    by the CPP ❶.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '如前所述，macOS 的 SYS_* 符号出现在 #ifdef 块内，如果没有定义符号 __APPLE_API_PRIVATE，则会隐藏这些定义。因此，在
    macOS 下包含 sys/syscall.h 头文件时，*files.inc* 需要定义符号 __APPLE_API_PRIVATE，这样所有的 SYS_*
    标签才会被 CPP 处理 ❶。'
- en: The *files.inc* header then defines various symbols whose values differ by OS
    (in particular, the API function call numbers) ❷ ❸. This conditional assembly
    block also defines the O_CREAT symbol, which is different for the two OSes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*files.inc* 头文件随后定义了各种符号，这些符号的值因操作系统而异（特别是 API 函数调用编号） ❷ ❸。这个条件汇编块还定义了 O_CREAT
    符号，它在两个操作系统中是不同的。'
- en: Next, the header defines various constants that will be useful in both the library
    source code and in applications that link against the library ❹. The stdin, stdout,
    and stderr constants are the Unix file descriptor values for the standard input
    device, the standard output device, and the standard error (output) device, respectively.
    The library uses cr, lf, and bs as ASCII character code constants.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，头文件定义了在库源代码和与库链接的应用程序中都将使用的各种常量 ❹。stdin、stdout 和 stderr 常量分别是标准输入设备、标准输出设备和标准错误（输出）设备的
    Unix 文件描述符值。库使用 cr、lf 和 bs 作为 ASCII 字符代码常量。
- en: 'I’ve then inserted several #define statements lifted from *fcntl.h* ❺ (yet
    another C/C++ header file containing useful API constant definitions; you’ll usually
    find it in the same directory as *syscall.h*). These constants are used with the
    openat() function when creating a new file (you supply these constants for the
    mode parameter). As with *errno.h*, you cannot simply include *fcntl.h* because
    Gas will not be able to process the C/C++ statements that appear in it.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '接着，我插入了从 *fcntl.h* ❺ 中提取的几个 #define 语句（这是另一个包含有用 API 常量定义的 C/C++ 头文件；通常你会在与
    *syscall.h* 相同的目录中找到它）。这些常量在使用 openat() 函数创建新文件时使用（你需要将这些常量提供给模式参数）。与 *errno.h*
    类似，你不能简单地包含 *fcntl.h*，因为 Gas 无法处理其中出现的 C/C++ 语句。'
- en: As previously discussed, the library uses the file.checkError macro ❻ after
    svc instructions to check error return results. Finally, the code includes external
    definitions for all the functions that appear in the *files.a* library ❼.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，库在 svc 指令之后使用 file.checkError 宏 ❻ 来检查错误返回结果。最后，代码包含了所有在 *files.a* 库 ❼ 中出现的函数的外部定义。
- en: 16.5.1 volatiles.S Functions
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.5.1 volatiles.S 函数
- en: 'The *volatiles.S* source file contains two functions that save and restore
    all the volatile registers, saveVolatile and restoreVolatile:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*volatiles.S* 源文件包含了两个保存和恢复所有易失性寄存器的函数 saveVolatile 和 restoreVolatile：'
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These functions simply store the registers into successive locations at the
    address held in the FP register. It is the caller’s responsibility to preserve
    FP and load it with the address of the volatile_save structure before calling
    saveVolatile or restoreVolatile. As you can see in *volatiles.S*, this code does
    not preserve the value in the FP register.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数仅仅是将寄存器存储到 FP 寄存器所持有的地址处的连续位置。调用者有责任在调用 saveVolatile 或 restoreVolatile 之前保存
    FP 寄存器，并将其加载为 volatile_save 结构的地址。如你所见，*volatiles.S* 中的代码并不会保存 FP 寄存器中的值。
- en: The purpose behind saveVolatile and restoreVolatile is to overcome the fact
    that the OS API calls can modify the volatile register set. It’s good assembly
    language programming style to always preserve register values unless you are explicitly
    returning a result in a register. The *volatiles.S* functions allow you to conform
    to this style even when calling low-level API functions that trash the volatile
    registers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: saveVolatile 和 restoreVolatile 的目的是克服操作系统 API 调用可能修改易失性寄存器集的问题。在汇编语言编程中，除非明确地在寄存器中返回结果，否则保持寄存器的值是良好的编程风格。*volatiles.S*
    函数使你能够在调用会破坏易失性寄存器的低级 API 函数时，仍然遵循这一编程风格。
- en: The one downside of these functions is that you never know which volatile registers
    a given API function might modify, so you have to preserve them all, even if the
    API function changes only a few. This, sadly, introduces inefficiency into the
    code; reading and writing memory is not especially fast. However, not having to
    worry about volatile registers in your assembly language code is worth the slight
    efficiency loss. (Moreover, file I/O is usually a relatively slow process to begin
    with, so if you’re frequently calling file I/O functions, saving and restoring
    the registers is probably a very small percentage of the running time.)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的一个缺点是，你永远无法知道给定的API函数可能修改哪些易变寄存器，因此你必须保存所有的易变寄存器，即使API函数只改变其中的少数几个。不幸的是，这会给代码带来低效；读写内存并不特别快速。然而，在汇编语言代码中不必担心易变寄存器的保存，还是值得这点小小的效率损失的。（而且，文件I/O通常本身就是一个相对较慢的过程，所以如果你频繁调用文件I/O函数，保存和恢复寄存器的开销可能在运行时间中所占的比例非常小。）
- en: 'The *aoaa.inc* header file contains the following structure to define the layout
    of the registers saved by saveVolatile and loaded by restoreVolatile:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*aoaa.inc*头文件包含了以下结构，用来定义saveVolatile保存的寄存器布局，并由restoreVolatile加载：'
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Because this structure is rather large, saveVolatile and restoreVolatile do
    not refer to the individual fields. The offsets to certain members of this structure
    are too large to encode in the addressing mode offset field of a 32-bit load instruction.
    Nevertheless, these structures do document where saveVolatile and restoreVolatile
    place the data.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个结构体相当大，saveVolatile和restoreVolatile不涉及单独的字段。某些成员的偏移量过大，无法在32位加载指令的寻址模式偏移字段中编码。不过，这些结构体确实记录了saveVolatile和restoreVolatile放置数据的位置。
- en: 16.5.2 files.S File I/O Functions
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.5.2 files.S 文件I/O函数
- en: The *files.S* source file contains the file I/O functions in the library. Because
    this file is rather long, I’ll break it into pieces and discuss each section in
    turn. (I won’t include the parameter values you pass to these functions; these
    are well documented online, or you can use the Unix man command for the read(),
    write(), open(), openat(), and close() functions.)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*files.S*源文件包含了库中的文件I/O函数。由于这个文件相当长，我会将它分成几部分，依次进行讨论。（我不会包含你传递给这些函数的参数值；这些参数在线上有很好的文档，或者你可以使用Unix的man命令来查询read()、write()、open()、openat()和close()函数。）'
- en: 'Most of the *files.S* functions are facade code—that is, they exist to change
    the environment or parameters of another function (in this case, the OS API functions).
    These functions preserve volatile registers so that the caller doesn’t have to
    worry about their preservation; in a few cases (open calls), they automatically
    set up certain default parameters for the caller; or, in the event of an error,
    they modify the return codes to produce a consistent result across OSes. The file.write
    function demonstrates providing a uniform interface (across OSes), preserving
    the volatile registers, and returning a consistent error code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数的*files.S*函数是外观代码——也就是说，它们存在的目的是改变另一个函数（在本例中是操作系统API函数）的环境或参数。这些函数会保存易变寄存器，这样调用者就不需要担心它们的保存问题；在少数情况下（如open调用），它们会为调用者自动设置某些默认参数；或者在发生错误时，它们会修改返回码，以便在不同的操作系统中产生一致的结果。file.write函数演示了如何提供统一的接口（跨操作系统），保存易变寄存器，并返回一致的错误码：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the activation record, file.write reserves space for the volatile register
    save area ❶ and the special variable fw_locals.fpSave ❷. The code will use this
    variable to preserve the FP register across calls to saveVolatile and restoreVolatile.
    Note that fw_locals.fpSave appears last in the activation record, so it will be
    located on the top of the stack when file.write builds the activation record.
    This is a temporary variable that will not be used when system calls use the space
    on the top of the stack (assuming they do).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在激活记录中，file.write为易变寄存器保存区域❶和特殊变量fw_locals.fpSave❷保留了空间。代码会使用这个变量在调用saveVolatile和restoreVolatile时保存FP寄存器。注意，fw_locals.fpSave出现在激活记录的最后，因此当file.write构建激活记录时，它将位于栈顶。这是一个临时变量，当系统调用使用栈顶的空间时（假设它们这样做），该变量将不再使用。
- en: Next, file.write saves all the volatile registers to the volatile save area
    (fw_locals.volSave) ❸. Because saveVolatile expects FP pointing at the save area,
    this code saves FP to the top of the stack (which just happens to be the location
    of the fw_locals.fpSave variable), loads FP with the address of the fw_locals.volSave
    structure, calls saveVolatile, and then restores FP upon return.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，file.write 会将所有的易失性寄存器保存到易失性保存区（fw_locals.volSave） ❸。因为 saveVolatile 期望
    FP 指向保存区，所以这段代码将 FP 保存到栈顶（这恰好是 fw_locals.fpSave 变量的位置），然后将 FP 加载为 fw_locals.volSave
    结构体的地址，调用 saveVolatile，并在返回时恢复 FP。
- en: 'Note that the code could not reference the fw_locals.fpSave variable by using
    the [FP, #fw_locals.fpSave] addressing mode. First, the size of the activation
    record is too large, and the offset of fw_locals.fpSave cannot be encoded into
    a 32-bit instruction. Second, FP is not pointing at the activation record upon
    return from saveVolatile, so the [FP, #fw_locals.fpSave] addressing mode would
    reference the wrong location (even if the offset weren’t too large).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，代码不能通过使用 [FP, #fw_locals.fpSave] 寄存器寻址模式来引用 fw_locals.fpSave 变量。首先，激活记录的大小太大，fw_locals.fpSave
    的偏移量无法编码进 32 位指令。其次，FP 在从 saveVolatile 返回时并不指向激活记录，因此 [FP, #fw_locals.fpSave]
    寄存器寻址模式会引用错误的位置（即使偏移量没有太大问题）。'
- en: The code then actually calls the API function ❹. This code is almost trivial,
    because all the parameters the write() function requires are already in the appropriate
    registers, as they were passed into file.write in those registers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码实际调用了 API 函数 ❹。这段代码几乎可以说是微不足道的，因为 write() 函数所需要的所有参数已经在相应的寄存器中，它们已经通过这些寄存器传递给了
    file.write。
- en: 'The code checks for an error and massages the value in X0 if an error occurred
    during the write operation ❺. The file.write function restores the registers previously
    saved to fw_locals.volSave ❻. The code and explanation are almost identical to
    that at ❸, with one exception: the value in X0\. Because this code returns a function
    result in X0 and restoreVolatile will restore X0 to its original value, this code
    has to save and restore X0 across the call to restoreVolatile. Because the variable
    fw_locals.saveX0 appears in the activation record before fw_locals.volSave, there
    is no problem with the offset when using the [FP, #fw_locals.saveX0] addressing
    mode; only the variables appearing after fw_locals.volSave will have offsets too
    large to use in the addressing mode.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '代码会检查是否发生了错误，并在写入操作过程中如果发生错误，将 X0 中的值进行调整 ❺。file.write 函数会恢复先前保存在 fw_locals.volSave
    中的寄存器 ❻。这段代码和解释几乎与 ❸ 中的相同，唯一的不同是：X0 中的值。因为这段代码将函数结果返回在 X0 中，并且 restoreVolatile
    会将 X0 恢复到原来的值，所以这段代码必须在调用 restoreVolatile 之前保存和恢复 X0。由于变量 fw_locals.saveX0 在激活记录中出现在
    fw_locals.volSave 之前，所以在使用 [FP, #fw_locals.saveX0] 寄存器寻址模式时不会有偏移量过大的问题；只有出现在 fw_locals.volSave
    之后的变量，其偏移量会太大，无法在该寻址模式下使用。'
- en: 'The file.read function is almost identical to the file.write function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: file.read 函数几乎与 file.write 函数相同：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The only real difference between file.read and file.write is the function number
    loaded into the svcReg register.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: file.read 和 file.write 唯一的真正区别在于 svcReg 寄存器中加载的函数号。
- en: 'Next, *files.S* provides the code for the file.open function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，*files.S* 提供了 file.open 函数的代码：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The file.open function is identical to file.write and file.read, except for
    the call to the OS API function ❶. Instead of calling the API open() function,
    file.open calls the API openat() function, a more modern version of open(). Here
    are the C/C++ prototypes for these two functions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: file.open 函数与 file.write 和 file.read 函数相同，唯一不同的是调用了操作系统的 API 函数 ❶。file.open
    并不是调用 API 的 open() 函数，而是调用了 openat() 函数，这是 open() 函数的一个更现代的版本。以下是这两个函数的 C/C++
    原型：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The openat() function has one extra parameter, int dirfd. This complicates matters
    because file.open expects the same parameters as the open() function; therefore,
    upon entry to file.open, the parameters are sitting in the wrong registers for
    a call to openat().
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: openat() 函数有一个额外的参数 int dirfd。这使得问题变得复杂，因为 file.open 期望的参数与 open() 函数相同；因此，在进入
    file.open 时，参数位于错误的寄存器中，无法直接调用 openat()。
- en: This is easily fixed by moving X1 to X2 and X0 to X1, then loading X0 with the
    value AT_FDCWD to make the openat() function behave like open() ❶. The open()
    and openat() functions have an optional third or fourth parameter (respectively)
    that lets you set the permissions when creating a new file. The file.open function
    is intended for opening existing files, so you don’t normally specify that extra
    parameter when calling it. However, just in case the caller specifies O_CREAT
    in X1, this code sets X3 to a reasonable value (read and write permissions for
    everyone).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过将X1移至X2，X0移至X1，然后将X0加载为AT_FDCWD值来修复，从而使openat()函数表现得像open()函数一样❶。open()和openat()函数各有一个可选的第三个或第四个参数（分别），允许你在创建新文件时设置权限。file.open函数用于打开已存在的文件，因此在调用它时通常不需要指定那个额外的参数。然而，万一调用者在X1中指定了O_CREAT，代码就会将X3设置为一个合理的值（为所有人设置读写权限）。
- en: 'The file.openNew function is a variant of file.open used to create new files:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: file.openNew函数是file.open的一个变体，用于创建新文件：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The only difference between file.openNew and file.open is that file .openNew
    expects just a single parameter (the pathname in X0) and automatically supplies
    the flag values (O_CREAT+O_WRONLY+O_EXCL) for the call to openat().
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: file.openNew和file.open之间唯一的区别是，file.openNew只期望一个参数（X0中的路径名），并为调用openat()自动提供标志值（O_CREAT+O_WRONLY+O_EXCL）。
- en: 'The file.close function is the final file I/O function in the *files.S* source
    file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: file.close函数是*files.S*源文件中的最后一个文件I/O函数：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The file.close function expects a file descriptor in X0 (returned by a successful
    call to file.open or file.openNew) and passes that descriptor along to the API
    close() function. Otherwise, it’s similar in form to the file.read and file.write
    functions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: file.close函数期望在X0中传入文件描述符（由成功调用file.open或file.openNew返回），并将该描述符传递给API的close()函数。否则，它的形式与file.read和file.write函数类似。
- en: 16.5.3 stdio.S Functions
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.5.3 stdio.S函数
- en: The last source file in the files library is the *stdio.S* file. This module
    contains functions you can use to read and write strings on the console (standard
    I/O) device. Again, because of its size, I’ve broken this source file into more
    easily digestible pieces.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 文件库中的最后一个源文件是*stdio.S*文件。这个模块包含了你可以用来在控制台（标准I/O）设备上读写字符串的函数。由于它的大小，我将这个源文件拆分成了更易于消化的部分。
- en: 'First, the stdout.puts function writes a (zero-terminated) string to the standard
    output device (usually the display console):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，stdout.puts函数将一个（以零结束的）字符串写入标准输出设备（通常是显示控制台）：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that this code does not preserve all the volatile registers ❶, because
    the stdout.puts function does not directly call an OS API function that might
    modify the registers. Therefore, this function preserves only the actual registers
    it uses.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这段代码并没有保存所有的易失性寄存器❶，因为stdout.puts函数并没有直接调用可能修改寄存器的操作系统API函数。因此，这个函数只保留它实际使用的寄存器。
- en: 'This function will call file.write to write the string to the standard output
    device. The file.write function requires three parameters: a file descriptor (the
    stdout constant works fine for the descriptor value), the address of the data
    (string) to write, and a length value. Although stdout.put has the address of
    the string in X0, there is no length parameter. Therefore this code computes the
    length of the zero-terminated string whose address appears in X0 ❷.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将调用file.write将字符串写入标准输出设备。file.write函数需要三个参数：文件描述符（stdout常量对于描述符值非常合适）、数据的地址（字符串）以及长度值。虽然stdout.puts函数在X0中具有字符串的地址，但没有长度参数。因此，这段代码计算了地址在X0中的以零结束的字符串的长度❷。
- en: NOTE
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Scanning the string a byte at a time is a lame way to compute string length,
    but I’ve done so here because it is simpler than the alternative. If this really
    bothers you, you can link in the C stdlib* strlen() *function. However, keep in
    mind that making the system call and drawing all those pixels on the screen to
    print the string is many orders of magnitude slower than this string-length calculation,
    so you won’t save much time by using faster string-length computation code.*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*一次扫描一个字节来计算字符串长度是一个简陋的方式，但我在这里使用它，因为它比其他方法更简单。如果这真的让你感到困扰，你可以链接C标准库* strlen()
    *函数。不过，请记住，进行系统调用并在屏幕上绘制所有这些像素来打印字符串的速度比这个字符串长度计算慢得多，因此使用更快的字符串长度计算代码并不会节省多少时间。*'
- en: Once the length is computed, the stdout.put function calls file.write to actually
    print the string to the standard output device ❸. After restoring the few registers
    this code changed, the function returns.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算出长度，stdout.put 函数会调用 file.write 将字符串实际打印到标准输出设备 ❸。在恢复这段代码修改过的几个寄存器后，函数返回。
- en: Technically, file.write could return an error code (which stdout.puts ignores
    and doesn’t return to its caller). However, the likelihood of such an error is
    low, so this code ignores errors. One likely problem could be if standard output
    were redirected to a disk file and there was an issue writing to the disk, so
    this bug is worth addressing if this routine finds its way into production code;
    I chose not to address this here to keep the code cleaner (and because of the
    extremely low probability of occurrence).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，file.write 可能返回一个错误代码（stdout.puts 会忽略这个错误并且不会将其返回给调用者）。然而，这种错误的可能性较低，因此这段代码忽略了错误。一个可能的问题是，如果标准输出被重定向到磁盘文件，而写入磁盘时出现问题，那么这个
    bug 就值得关注。如果这个例程要进入生产代码，应该解决这个问题；我选择在这里不处理此问题，以保持代码的简洁（而且发生这种情况的概率极低）。
- en: 'The stdout.newLn function is identical to stdout.puts, except that it writes
    a fixed string (a newline character) to the standard output device:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: stdout.newLn 函数与 stdout.puts 相同，只是它会向标准输出设备写入一个固定的字符串（换行符）：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The stdin.read function is the input complement to stdout.write:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: stdin.read 函数是 stdout.write 的输入补充：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When you pass stdin.read a buffer’s address and size, it will read up to that
    number of characters from the standard input device (usually the keyboard) and
    place those characters into the buffer. This function will stop reading characters
    when it either reads the specified number of characters or encounters a newline
    character (line feed) in the input.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当你传递给 stdin.read 一个缓冲区的地址和大小时，它会从标准输入设备（通常是键盘）读取指定数量的字符，并将这些字符放入缓冲区。当它读取到指定数量的字符或者遇到换行符（换行符）时，读取会停止。
- en: The twist to this otherwise straightforward code is that it has to move the
    address and byte count around ❶ prior to calling the OS read() function. This
    is because the buffer address needs to go in X1 and X2 when calling read(), and
    the function has to load the standard input file descriptor into X0.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这段看似简单的代码的关键在于，在调用操作系统的 read() 函数之前，需要先移动地址和字节数 ❶。这是因为在调用 read() 时，缓冲区的地址需要放入
    X1 和 X2 寄存器中，而函数必须将标准输入文件描述符加载到 X0 寄存器中。
- en: 'The stdin.getc function is a one-character version of stdin.read:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: stdin.getc 函数是 stdin.read 的一个字符版本：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The stdin.getc function returns the character it reads in X0 rather than placing
    it in a buffer. This function has to reserve storage for a buffer ❶ because the
    call to the API read() function requires a buffer. Technically, the buffer needs
    to be only eight characters long, but this function reserves 16 bytes just to
    help keep the stack 16-byte aligned. This code initializes the first 8 bytes of
    the buffer to 0 ❷. The function will actually return all 8 bytes (even though
    the read operation stores only a single byte into the buffer). This function computes
    the address of the buffer to pass to the API read() function ❸.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: stdin.getc 函数返回它在 X0 中读取的字符，而不是将其放入缓冲区。由于调用 API 的 read() 函数需要一个缓冲区，这个函数必须为缓冲区预留存储空间
    ❶。从技术上讲，缓冲区只需要 8 个字符长，但这个函数预留了 16 字节，只是为了帮助保持栈的 16 字节对齐。该代码将缓冲区的前 8 个字节初始化为 0
    ❷。函数实际上会返回所有 8 个字节（即使读取操作只会将一个字节存储到缓冲区）。该函数计算缓冲区的地址并将其传递给 API 的 read() 函数 ❸。
- en: If, somehow, the call to the API read() function returns an error, the code
    will store the negative error return code into the first 8 bytes of the buffer
    ❹. Before returning, stdin.getc loads the 8 bytes at the beginning of the buffer
    into X0 and returns that value (this is either the single character plus seven
    0s, a UTF-8 value, or the 8-byte negative error code) ❺.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某种情况下，调用 API 的 read() 函数返回错误，代码将把负的错误返回代码存储在缓冲区的前 8 个字节中 ❹。在返回之前，stdin.getc
    会将缓冲区开头的 8 个字节加载到 X0 寄存器中，并返回该值（这可以是一个字符加上七个 0，或者一个 UTF-8 值，或者是 8 字节的负错误代码） ❺。
- en: NOTE
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The* stdin.get *function does not read a single character from the keyboard
    and then immediately return to the caller. Instead, the OS will read a whole line
    of text from the* *keyboard and return the first character of that line. Successive
    calls to* stdin.get *will read the remaining characters from that internal OS
    buffer. This is standard Unix behavior, not a specific feature of this function.*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*stdin.get* 函数并不是从键盘读取单个字符并立即返回给调用者。相反，操作系统会从键盘读取整行文本，并返回该行的第一个字符。对 *stdin.get*
    的后续调用将从该操作系统内部缓冲区读取剩余字符。这是标准的 Unix 行为，而非该函数的特定功能。'
- en: 'The last function in the *stdio.S* file is stdin.readln:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*stdio.S* 文件中的最后一个函数是 stdin.readln：'
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This function, intended mainly for interactive use, reads a line of text from
    the keyboard with a modicum of editing (handling backspace characters), placing
    those characters into a buffer. In many respects, it works just like stdin.read,
    except that pressing BACKSPACE deletes a character from the input buffer rather
    than returning the backspace ASCII code as a character of the buffer.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数主要用于交互式使用，它会从键盘读取一行文本并进行适度编辑（处理退格符），将这些字符放入缓冲区。从许多方面来看，它的工作方式就像 stdin.read，只是按下
    BACKSPACE 键会删除输入缓冲区中的一个字符，而不是将退格符 ASCII 代码作为缓冲区中的字符返回。
- en: This function repeatedly calls stdin.getc ❶, reading one character at a time.
    If stdin.getc returns an error (a negative return value), this function immediately
    returns, passing the error code on to its caller.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数重复调用 stdin.getc❶，每次读取一个字符。如果 stdin.getc 返回错误（负返回值），该函数会立即返回，将错误代码传递给调用者。
- en: The code checks whether the input line is complete by comparing the character
    against the ASCII codes for a carriage return or newline (line feed) ❷. If the
    character matches one of these two, the code exits the loop.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过将字符与回车符或换行符（换行符）❷的 ASCII 代码进行比较，检查输入行是否完成。如果字符与这两者中的任何一个匹配，代码会退出循环。
- en: The stdin.readln function then checks for a backspace character ❸. If it is
    a backspace, this function will delete the previous character from the input buffer
    (if there was one). If the character is not a backspace, the code branches down
    to ❹, where it appends the character to the end of the buffer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，stdin.readln 函数会检查是否有退格符❸。如果是退格符，该函数将从输入缓冲区删除之前的字符（如果有的话）。如果字符不是退格符，代码会跳转到❹，在这里它将该字符追加到缓冲区的末尾。
- en: When the function finds a carriage return or line feed in the input stream,
    it transfers control to ❺, where it zero-terminates the string and returns the
    number of characters actually read in the X0 register.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数在输入流中找到回车符或换行符时，它会将控制权转移到❺，在那里它会将字符串终止并返回实际读取的字符数到 X0 寄存器中。
- en: Beyond processing backspace characters, there are two additional differences
    between reading a line of text with stdin.readln and simply calling stdin.read.
    First, stdin.readln will zero-terminate the string read into the buffer. Second,
    stdin.readln does not place the newline character (or carriage return) in the
    buffer.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 除了处理退格符，读取文本行时使用 stdin.readln 和简单调用 stdin.read 之间还有两个额外的区别。首先，stdin.readln 会将读取到缓冲区的字符串终止。其次，stdin.readln
    不会将换行符（或回车符）放入缓冲区。
- en: 16.5.4 File I/O Demo Application
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.5.4 文件 I/O 演示应用
- en: The simple application in Listing 16-4 demonstrates the use of the *file.a*
    library.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 16-4 中的简单应用演示了 *file.a* 库的使用。
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This program begins by prompting the user to enter a filename ❶. It reads this
    filename from the user and then echoes the filename to the display. The program
    opens the file and saves away the file handle that file .open returns ❷. If an
    error occurred opening the file, the program drops down to the badOpen label,
    prints an error message, and quits.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序首先提示用户输入一个文件名❶。它从用户那里读取这个文件名，然后将文件名回显到显示屏上。程序打开该文件并保存由文件 .open 返回的文件句柄❷。如果在打开文件时发生错误，程序会跳转到
    badOpen 标签，打印错误信息并退出。
- en: Next, the program continuously reads a block of (up to) 4,096 bytes until the
    end of the file is reached (or another error occurs) ❸. When reading from a file,
    the file.read function will read the full 4,096 bytes, ignoring any newline characters
    (it stops on newlines only when reading from the standard input). If this function
    reads 0 bytes from the input, it has reached the end of the file, and the loop
    exits.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，程序会不断地读取（最多）4,096 字节的块，直到文件末尾被读取完（或发生其他错误）❸。从文件读取时，file.read 函数会读取完整的 4,096
    字节，忽略所有换行符（仅在从标准输入读取时才会在换行符处停止）。如果该函数从输入中读取到 0 字节，表示已到达文件末尾，循环会退出。
- en: The code then writes the bytes read to the standard output device ❹, using the
    return value from file.read as the byte count on the call to file .write. This
    is because the last block of bytes read from the file might not be 4,096 bytes
    in length; if it read fewer than 4,096 bytes, the next read will return 0 bytes
    and the operation will be complete. Once the program completes, it closes the
    file and quits ❺>.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将读取的字节写入标准输出设备 ❹，并使用file.read的返回值作为调用file.write时的字节计数。这是因为从文件读取的最后一块字节可能不是4,096字节；如果读取的字节少于4,096字节，下一次读取将返回0字节，操作就会完成。一旦程序完成，它会关闭文件并退出
    ❺>。
- en: 'Here’s the makefile that will build the program in Listing 16-4:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将在清单16-4中构建程序的makefile：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here’s a sample build operation and execution of the program:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例构建操作和程序执行：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: I’ve used the *Listing16-4.mak* text file as the input for this run of the program.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了*Listing16-4.mak*文本文件作为这次程序运行的输入。
- en: '### 16.6 Calling System Library Functions Under macOS'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '### 16.6 在macOS下调用系统库函数'
- en: As I mentioned earlier, Apple frowns on applications that make direct calls
    to the macOS kernel via the svc instruction. The company claims the proper way
    to make those calls is via the C library code Apple has provided. This chapter
    has shown you the low-level calls because, well, that was the purpose of this
    chapter; if you’re the one writing the C library code (or similar library code
    that interfaces to the OS), you need to know this information. However, I would
    be remiss if I didn’t show you how Apple recommends interfacing applications with
    macOS.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，苹果公司对直接通过svc指令调用macOS内核的应用程序持反对态度。公司声称，正确的调用方式是通过苹果提供的C库代码。本章展示了低级调用，因为这本章的目的就是这个；如果你是编写C库代码的人（或者是类似的与操作系统交互的库代码），你需要了解这些信息。然而，如果我不向你展示苹果推荐的与macOS接口的方式，我就失职了。
- en: 'I’ve created a variant of the *files.a* library, stored in the *files-macOS*
    directory in the online source code set, that links in the kernel read(), write(),
    open(), and close() functions. To avoid redundancy, I don’t print all that code
    in this chapter, but I’ll list the file.write function here to give you an idea
    of the simplicity of the change:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个变体的*files.a*库，存储在在线源码集中的*files-macOS*目录下，链接了内核的read()、write()、open()和close()函数。为了避免冗余，我没有在本章中打印所有代码，但我将在这里列出file.write函数，给你一个关于修改简单性的概念：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The only difference between this version of file.write and the version in the
    original *files.a* library is that I’ve replaced the svc instruction sequence
    with a call to the _write() function ❶.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的file.write与原始*files.a*库中的版本之间唯一的区别是，我将svc指令序列替换为对_write()函数的调用 ❶。
- en: 'The new *files.a* library also includes a couple of changes to the *files.inc*
    header file. The most important change is to the file.checkError macro:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 新的*files.a*库还包括了对*files.inc*头文件的一些更改。最重要的更改是对file.checkError宏的修改：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The macOS _write() function returns –1 when an error occurs, since C code can’t
    test the carry flag. Therefore, I modified file.checkError to handle errors the
    same way Linux does.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: macOS的_write()函数在发生错误时返回-1，因为C代码无法测试进位标志。因此，我修改了file.checkError函数，以便像Linux那样处理错误。
- en: I had to build the *files-macOS* library first (to create a new version of *file.a*,
    replacing the version that made direct OS calls), then made *Listing16-4.S* by
    using the *file.a* library from *files-macOS*. The program ran the same as the
    original file I/O example from the previous section.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须先构建*files-macOS*库（以创建一个新的*file.a*版本，替换掉直接进行操作系统调用的版本），然后使用*files-macOS*中的*file.a*库创建*Listing16-4.S*。程序的运行与前一节中的原始文件I/O示例相同。
- en: 'In theory, you could use this same approach with Linux, creating slightly more
    portable code between the two OSes. However, the svc API interface under Linux
    is well defined and documented, so there is no reason not to call the API functions
    directly.  ### 16.7 Creating Assembly Applications Without GCC'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，你可以使用相同的方法在Linux上操作，这样可以创建在这两种操作系统之间稍微更具可移植性的代码。然而，Linux下的svc API接口已经明确定义并且有文档，所以没有理由不直接调用API函数。###
    16.7 在没有GCC的情况下创建汇编应用程序
- en: 'Throughout this chapter, I’ve continued to use GCC to assemble and link the
    assembly language files. That’s because most of the example code in this chapter
    includes *aoaa.inc*, and that file depends on the CPP. You might view this approach
    with suspicion, thinking GCC might be sneaking some C code into your program.
    And you would be right: even when you build a “pure” assembly language program
    with GCC, it links in some code to set up the environment prior to the execution
    of your program (so that if you do call any C library code, the environment has
    been set up for it).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我继续使用GCC来汇编和链接汇编语言文件。这是因为本章中的大多数示例代码都包含*aoaa.inc*，而这个文件依赖于CPP。你可能对这种方法有所怀疑，认为GCC可能会偷偷把一些C代码引入到你的程序中。你是对的：即使你用GCC构建一个“纯”汇编语言程序，它也会链接一些代码，在程序执行之前设置环境（这样，如果你确实调用任何C库代码，环境就已经为其做好了准备）。
- en: Generally, such extra code is of little consequence—it executes once, is fairly
    fast, and doesn’t take up that much space. However, if you are an absolute purist
    and you want to execute only the code you’ve written, you can do so with a little
    extra work. You just won’t be able to use *aoaa.inc*, and you’ll have to write
    non-portable code specifically for macOS or Linux.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这类额外的代码影响不大——它只执行一次，执行速度较快，并且占用的空间也不多。然而，如果你是一个绝对的纯粹主义者，并且只希望执行你自己编写的代码，你可以通过一些额外的工作做到这一点。你只是不能使用*aoaa.inc*，而且你必须专门为macOS或Linux编写不可移植的代码。
- en: Listing 16-5 is a “pure” assembly language program written for Linux.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 清单16-5是为Linux编写的“纯”汇编语言程序。
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Please note that this filename must have a lowercase *.s* suffix ❶; you will
    not be compiling this using GCC, so you won’t be using CPP with this code. Under
    Linux, the default program entry point is named _start. Therefore, this code declares
    _start as a global symbol ❷ and uses _start as the entry point for the program
    ❸. I got away with using main (or _main) in earlier examples in this chapter because
    the C code that GCC links in supplies the _start label and transfers control to
    main (or _main); however, as we’re giving up the GCC-generated code, we have to
    explicitly supply the _start label.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个文件名必须有小写的*.s*后缀 ❶；你不会使用GCC进行编译，因此不会在这个代码中使用CPP。在Linux下，默认的程序入口点名为_start。因此，这段代码将_start声明为全局符号
    ❷，并使用_start作为程序的入口点 ❸。在本章早些时候的示例中，我可以使用main（或_main），因为GCC链接的C代码提供了_start标签并将控制权转交给main（或_main）；然而，由于我们放弃了GCC生成的代码，我们必须显式地提供_start标签。
- en: 'To assemble, link, and run this program, use the following Linux commands:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要汇编、链接并运行这个程序，请使用以下Linux命令：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To make this program run under macOS, you must first modify the source code
    to use the appropriate macOS API constants, as shown in Listing 16-6.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个程序在macOS下运行，你必须首先修改源代码，以使用适当的macOS API常量，如清单16-6所示。
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Assembling the code is similar to Linux (note that the program name suffix
    is also a lowercase *.s*):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编代码与Linux类似（请注意，程序名后缀也是小写的*.s*）：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Linking the program, however, is a bit more complex:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，链接程序稍微复杂一些：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It’s best to use a makefile when building pure assembly files under macOS; manually
    typing these commands every time you want to build the application can be quite
    tedious!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS下构建纯汇编文件时，最好使用makefile；每次想要构建应用程序时手动输入这些命令是相当繁琐的！
- en: As you can see, the linker (ld) command still links in a bunch of C code (libSystem).
    There’s no other way (that I know of) to avoid this, which is why I’m perfectly
    happy letting GCC do all this work for me.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，链接器（ld）命令仍然会链接一些C代码（libSystem）。我知道的没有其他方法可以避免这一点，这也是我非常乐意让GCC为我做这些工作的原因。
- en: NOTE
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Apple isn’t kidding when it warns you against writing code like this. Between
    the time I first wrote this “Hello, World!” and the time this chapter was reviewed,
    Apple made changes to its system that broke the program. In particular, the linker
    now expects the program to be named* _main *rather than* _start*, and the command
    line for* ld *has some subtle changes. Moral of the story: stick with GCC (Clang)
    to do all this work for you.*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*Apple并不是开玩笑，当它警告你不要编写这样的代码时。在我第一次编写这个“Hello, World！”程序和本章审阅之间的时间里，Apple对其系统进行了更改，导致程序无法运行。特别是，现在链接器期望程序的名称是*
    _main *而不是* _start *，并且* ld *的命令行有一些微妙的变化。故事的寓意是：坚持使用GCC（Clang）来为你做所有这些工作。*'
- en: 16.8 For More Information
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.8 更多信息
- en: You can find the system call numbers for Linux at *[https://<wbr>github<wbr>.com<wbr>/torvalds<wbr>/linux<wbr>/blob<wbr>/v4<wbr>.17<wbr>/include<wbr>/uapi<wbr>/asm<wbr>-generic<wbr>/unistd<wbr>.h](https://github.com/torvalds/linux/blob/v4.17/include/uapi/asm-generic/unistd.h)*.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在*[https://<wbr>github<wbr>.com<wbr>/torvalds<wbr>/linux<wbr>/blob<wbr>/v4<wbr>.17<wbr>/include<wbr>/uapi<wbr>/asm<wbr>-generic<wbr>/unistd<wbr>.h](https://github.com/torvalds/linux/blob/v4.17/include/uapi/asm-generic/unistd.h)*上找到Linux的系统调用编号。
- en: Find the system call numbers for macOS at *[https://<wbr>github<wbr>.com<wbr>/opensource<wbr>-apple<wbr>/xnu<wbr>/blob<wbr>/master<wbr>/bsd<wbr>/kern<wbr>/syscalls<wbr>.master](https://github.com/opensource-apple/xnu/blob/master/bsd/kern/syscalls.master)*
    or *[https://<wbr>opensource<wbr>.apple<wbr>.com<wbr>/source<wbr>/xnu<wbr>/xnu<wbr>-1504<wbr>.3<wbr>.12<wbr>/bsd<wbr>/kern<wbr>/syscalls<wbr>.master](https://opensource.apple.com/source/xnu/xnu-1504.3.12/bsd/kern/syscalls.master)*.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在*[https://<wbr>github<wbr>.com<wbr>/opensource<wbr>-apple<wbr>/xnu<wbr>/blob<wbr>/master<wbr>/bsd<wbr>/kern<wbr>/syscalls<wbr>.master](https://github.com/opensource-apple/xnu/blob/master/bsd/kern/syscalls.master)*或*[https://<wbr>opensource<wbr>.apple<wbr>.com<wbr>/source<wbr>/xnu<wbr>/xnu<wbr>-1504<wbr>.3<wbr>.12<wbr>/bsd<wbr>/kern<wbr>/syscalls<wbr>.master](https://opensource.apple.com/source/xnu/xnu-1504.3.12/bsd/kern/syscalls.master)*上找到macOS的系统调用编号。
