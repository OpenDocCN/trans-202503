- en: '**9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9**'
- en: SECURE FIRMWARE UPDATE**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全固件更新**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: Security updates are annoying, for consumers, for administrators, and especially
    for manufacturers. The latter constantly need to watch out for possible vulnerabilities
    in their products and react to corresponding notifications, while users and administrators
    have to apply published patches in a timely manner. Since we can regard a device’s
    security as a volatile state that might change tomorrow, having a solid update
    strategy is imperative.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 安全更新对消费者、管理员，尤其是制造商来说，都是令人烦恼的。制造商需要不断监控其产品中可能存在的漏洞，并对相关通知作出反应，而用户和管理员则必须及时应用发布的补丁。由于我们可以将设备的安全性视为一个易变的状态，可能明天就会发生变化，因此拥有一个稳固的更新策略是必不可少的。
- en: However, software update handling is not a trivial process. Only authorized
    entities should be able to supply updates to devices, and they shouldn’t break
    device functionality or turn it into an expensive brick. In addition, safety experts
    are often rather reluctant to introduce patches to their certified devices, while
    corresponding certification bodies increasingly recognize the importance of security
    updates even in safety-critical areas.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，软件更新处理并非一件简单的事情。只有授权的实体应该能够向设备提供更新，而且这些更新不应破坏设备的功能或将其变成一块昂贵的砖头。此外，安全专家往往不愿意向其认证设备引入补丁，而相应的认证机构也越来越认识到安全更新在安全关键领域中的重要性。
- en: This chapter walks through the options for secure update approaches and the
    reasoning behind them. A central consideration is the secure implementation of
    update verification and its reliable application on the device itself. The chapter
    concludes with a practical case study for firmware updates based on the popular
    SWUpdate framework and a Yocto-based toolchain.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了安全更新方法的选择及其背后的原因。一个核心考虑因素是安全地实施更新验证，并确保其在设备上的可靠应用。最后，本章通过一个基于流行的SWUpdate框架和Yocto工具链的固件更新实践案例进行总结。
- en: '**The Inevitability of Updates**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**更新的不可避免性**'
- en: 'In some software and product development communities, a *perpetual beta* phase
    is common: a product never leaves its beta status, and new features are continuously
    added, even if the software or device is already in the field and in productive
    use by customers. This concept is sometimes also described as the *banana principle*,
    because those fruits are harvested when still green and continue to ripen on their
    way to customers and even after purchase. In such cases, it’s blatantly obvious
    that the delivered product isn’t completely finished and requires several software
    updates to develop its full potential. A secure update approach is essential.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些软件和产品开发社区中，*永恒的beta*阶段是常见的：产品永远不会脱离beta状态，新的功能不断添加，即使软件或设备已经投入使用，并由客户在实际环境中使用。这一概念有时也被称为*香蕉原则*，因为这些水果在还未成熟时就被采摘，并在运送到客户的途中甚至购买后继续成熟。在这种情况下，显而易见，交付的产品并没有完全完成，且需要多个软件更新才能开发出其全部潜力。因此，一个安全的更新方法至关重要。
- en: If we look at industrial systems and critical infrastructures, the situation
    is very different. Although these systems usually have a long lifetime, their
    manufacturers and operators may not have seen a need for patch management in the
    past. However, the increase in connectivity and digitalization in this field,
    along with the continuous discovery of vulnerabilities in industrial products,
    forces vendors and users to act and prepare for secure update processes. This
    situation is especially challenging because manufacturer support for security
    updates and operational patch management processes for industrial components usually
    have to run for decades.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下工业系统和关键基础设施，情况就截然不同。虽然这些系统通常具有较长的使用寿命，但其制造商和运营商在过去可能没有看到补丁管理的必要性。然而，随着这一领域的连接性和数字化的增加，以及工业产品中漏洞的不断发现，迫使供应商和用户采取行动并为安全更新过程做好准备。这种情况尤其具有挑战性，因为工业组件的制造商对安全更新的支持和操作补丁管理过程通常需要持续数十年。
- en: 'Even if you work in an industry that has a strong security focus and your development
    processes yield highly secure and robust products, you can’t guarantee that your
    software, your firmware, and your hardware components are free of bugs. Also,
    you don’t know whether new attack methodologies—not even invented at the time
    of product development—will cause security issues for your devices and may demand
    the replacement of crypto algorithms or the further enhancement of security features.
    In a nutshell: no product is perfect. Prepare it to be updatable.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在一个具有强烈安全重点的行业工作，并且你的开发过程产生了高度安全且稳健的产品，你也无法保证你的软件、固件和硬件组件没有漏洞。而且，你无法预知是否会有新的攻击方法——这些方法在产品开发时甚至未曾被发明——会对你的设备造成安全问题，并可能要求更换加密算法或进一步增强安全功能。简而言之：没有任何产品是完美的。你需要让它具备可更新性。
- en: Some prominent cases stress the need for secure update support in embedded and
    IoT devices. The vulnerability collections *Urgent/11* from 2019 and *Ripple20*
    from 2020 showed that fundamental software components like TCP/IP stacks and OSs
    may exhibit severe weaknesses. Millions, if not billions, of devices were affected,
    and many are assumed not to be patchable because they don’t provide the necessary
    means. In the end, that inability forces customers to replace those devices or
    leaves them with insecure systems. At this scale, it might even pose a risk to
    society as a whole because malicious actors know how to invite those IoT products
    to their botnets. The bottom line is that every digital device sold in the 2020s
    should have a secure update mechanism.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一些显著的案例强调了嵌入式和物联网设备需要支持安全更新。2019年的*Urgent/11*和2020年的*Ripple20*漏洞集合显示，像TCP/IP协议栈和操作系统这样的基础软件组件可能存在严重的弱点。数百万，甚至数十亿设备受到影响，许多设备被认为无法修补，因为它们不提供必要的修补手段。最终，这种无法修复的状况迫使客户更换这些设备，或者让他们继续使用不安全的系统。在这种规模下，它甚至可能对整个社会构成风险，因为恶意行为者知道如何将这些物联网产品引入他们的僵尸网络。归根结底，2020年代销售的每一台数字设备都应该具备一个安全的更新机制。
- en: '**NOTE**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I’m not the only one stressing the need for secure update strategies. IEC
    62443 for industrial cybersecurity, United Nations (UN) Regulation 156 for the
    automotive industry, and the cybersecurity part of the US FD&C Act for medical
    devices also agree, just to name a few.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*我并不是唯一一个强调安全更新策略必要性的人。工业网络安全标准IEC 62443、联合国（UN）针对汽车行业的法规156以及美国FD&C法案中针对医疗设备的网络安全部分也有类似的共识，仅举几例。*'
- en: '**Security Requirements**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安全要求**'
- en: As with every concept that has the term *secure* in its title, the obvious question
    is which (protection) goals are associated with it in this specific context. The
    following sections describe requirements you must consider for a secure firmware
    update.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何带有*安全*字眼的概念一样，显而易见的问题是，在这个特定上下文中，它关联了哪些（保护）目标。以下部分描述了你在安全固件更新中必须考虑的要求。
- en: '***Authenticity***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***真实性***'
- en: It is essential that a firmware update can cryptographically prove its authenticity,
    which ensures that it originates from the original manufacturer of the given device.
    This prohibits the installation of maliciously crafted updates and should be mandatory
    for all secure update procedures. This goal is typically achieved by digitally
    signing an update package.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 固件更新必须能够通过加密方式证明其真实性，这确保了更新来自给定设备的原始制造商。这可以防止恶意制作的更新安装，并且应该成为所有安全更新程序的强制要求。这个目标通常是通过数字签名更新包来实现的。
- en: '***Confidentiality***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***保密性***'
- en: Firmware images are regularly used by people to reverse engineer devices for
    the enumeration of software libraries, to identify weaknesses, or to analyze proprietary
    applications for intellectual property and secrets. Confidentiality protection
    can be achieved by the encryption of the update contents as a whole or in parts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 固件镜像通常被人们用来逆向工程设备，以枚举软件库、识别弱点或分析专有应用程序中的知识产权和机密信息。可以通过加密整个更新内容或其部分内容来实现保密性保护。
- en: However, make sure you understand there is a risk because the corresponding
    decryption key needs to be stored on the device, so attackers might either be
    able to extract that key from the device or the plain firmware update after on-device
    decryption.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请确保你理解存在风险，因为相应的解密密钥需要存储在设备上，攻击者可能能够从设备中提取该密钥，或者在设备解密后的固件更新中提取明文。
- en: '***Secure Distribution Channel***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安全分发渠道***'
- en: The first two requirements, authenticity and confidentiality, impose requirements
    on the update file itself. However, the distribution channel also might be worth
    protecting (for example, with TLS).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个要求，即真实性和保密性，对更新文件本身提出了要求。然而，分发渠道本身也值得保护（例如，使用TLS）。
- en: A mutually authenticated and encrypted communication between a device and an
    update server might even be a replacement for the confidentiality protection of
    the update file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 设备与更新服务器之间的相互认证和加密通信，甚至可以替代更新文件的保密保护。
- en: '***Rollback Option***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***回滚选项***'
- en: This one is tricky. Rolling back the software version of a device to an older
    state is sometimes absolutely helpful—for example, if an update introduces severe
    issues that haven’t existed before. On the other hand, attackers might use this
    feature to revert a device’s software to a version containing known vulnerabilities
    that later patches have fixed. In that case, the operation of vulnerable devices
    and their exploitation becomes possible, although the manufacturer provided security
    updates.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这点比较棘手。将设备的软件版本回滚到较早状态有时非常有用——例如，如果更新引入了之前不存在的严重问题。另一方面，攻击者可能利用此功能将设备的软件回滚到包含已知漏洞的版本，而这些漏洞已经被后续的补丁修复。在这种情况下，尽管制造商提供了安全更新，设备仍可能处于易受攻击的状态，攻击者可以利用这些漏洞进行攻击。
- en: If you decide to implement rollback protection, you need corresponding hardware
    support, such as a monotonic, nonvolatile version counter within your main CPU.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定实施回滚保护，那么你需要相应的硬件支持，例如在主CPU中实现一个单调、不易丢失的版本计数器。
- en: '***Version Distribution Monitoring***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***版本分发监控***'
- en: Monitoring the adoption of security updates in the field can be highly valuable,
    because doing so gives you an overview of the situation and the corresponding
    threat landscape for your devices and your customers. You could implement this
    monitoring with a confirmation notice for each device after a new firmware version
    has been successfully installed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 监控现场安全更新的采用情况可能非常有价值，因为这可以帮助你了解设备和客户的整体安全态势和威胁情况。你可以通过在每次成功安装新固件版本后，向每个设备发送确认通知来实施这一监控。
- en: '**Distribution and Deployment of Updates**'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**更新的分发与部署**'
- en: A central question regarding firmware updates is, “How does the update file
    find its way into the device?” Answers to that question have a significant impact
    on usability, processes, and reaction speed for your device’s patch management.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 关于固件更新的一个核心问题是：“更新文件如何找到它所在的设备？”对此问题的回答对设备的可用性、流程和补丁管理的反应速度有着重要影响。
- en: '***Local vs. Remote Updates***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***本地更新 vs. 远程更新***'
- en: Since the 1990s, devices that implement an update mechanism offer some kind
    of interface to upload or to store a firmware file that was previously downloaded
    from the manufacturer’s website. The update file might even be restricted to be
    loaded at a local interface, such as via USB media. While local presence for updating
    can be a security feature, this approach provides pretty poor scalability for
    IoT scenarios. Millions of devices would require millions of customers with security
    awareness and millions of manual update installations, which is hardly feasible
    and results in few updates actually being applied.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 自1990年代以来，实施更新机制的设备通常提供某种接口来上传或存储以前从制造商网站下载的固件文件。更新文件甚至可能被限制只能通过本地接口加载，如通过USB设备。虽然本地更新可能是一项安全特性，但这种方法对于物联网场景的扩展性较差。数百万设备需要数百万具有安全意识的客户以及数百万次手动更新安装，这几乎是不可行的，并且导致实际应用的更新很少。
- en: The automotive industry is an interesting example regarding firmware updates.
    For many years, it was common for a recall to be issued if cars had a significant
    software bug or vulnerability. The owners had to bring their vehicles to an auto
    repair shop, where mechanics installed the software update provided by the corresponding
    car manufacturer that received it from the suppliers of the specific control unit.
    Nowadays, modern cars can receive software updates through their connection to
    mobile networks. This approach is called an *over-the-air (OTA) update*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车行业是一个关于固件更新的有趣例子。多年来，如果汽车存在严重的软件漏洞或缺陷，通常会发布召回通知。车主需要将车辆送到修理厂，由机械师安装汽车制造商提供的软件更新，这些更新通常是由特定控制单元的供应商提供的。如今，现代汽车可以通过连接到移动网络来接收软件更新。这种方法被称为*空中下载（OTA）更新*。
- en: OTA updates are not restricted to cars. They can be applied to all sorts of
    IoT devices, and even if the term suggests that updates are applied over wireless
    channels, update transmission over wired networks is clearly not forbidden. The
    main advantage of this concept is that devices have a connection to an update
    management backend, usually operated by the device’s manufacturer, that provides
    information about new updates. This approach provides decent scalability because
    the update rollout process can be automated and scheduled by manufacturers. However,
    such a system exposes backend servers and devices listening for updates to remote
    attackers and network-based attacks.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: OTA 更新不仅限于汽车。它可以应用于各种物联网设备，尽管这个术语暗示更新是通过无线通道进行的，但通过有线网络传输更新显然并不被禁止。这个概念的主要优势在于设备能够连接到更新管理后台，通常由设备制造商运营，提供关于新更新的信息。这种方法提供了不错的可扩展性，因为更新发布过程可以由制造商自动化并进行计划。然而，这样的系统将后端服务器和监听更新的设备暴露给远程攻击者和基于网络的攻击。
- en: '**NOTE**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In some industrial scenarios, manual local update procedures are still the
    default. I’ve heard from a person who personally visits hundreds of industrial
    robots, plugs in a USB stick, and then waits for the update to complete before
    he continues his journey, which might take weeks for a single update. Crazy!*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*在一些工业场景中，手动本地更新程序仍然是默认的。我听说有个人亲自访问数百台工业机器人，插入USB闪存驱动器，然后等待更新完成后才继续他的旅程，可能一次更新就需要几周时间。疯狂！*'
- en: '***Pull vs. Push Strategy***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***拉式与推式策略***'
- en: 'There’s no doubt that a direct connection between devices and an update server
    in the backend is a reasonable solution for professional update management, but
    one question remains: Who is in control of the update procedure?'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 毋庸置疑，在后端设备与更新服务器之间建立直接连接是专业更新管理的合理解决方案，但仍有一个问题：谁来控制更新过程？
- en: 'Usually, devices follow a *pull strategy* for update management: a client application
    on the device periodically checks for new updates and downloads newly available
    images. Afterward, depending on the owner’s configuration, the device might automatically
    install the update (for example, within a predefined maintenance window) or prompt
    a user or an administrator to approve installation. After a successful update,
    the new software state might be reported to a manufacturer’s server. In this case,
    operators control when and which updates are installed on their devices, which
    is usually the preferred solution for business scenarios, but they also take responsibility
    for regular update schedules.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，设备采用*拉式策略*进行更新管理：设备上的客户端应用程序定期检查是否有新更新，并下载新发布的镜像文件。随后，根据所有者的配置，设备可能会自动安装更新（例如，在预定的维护窗口内），或提示用户或管理员批准安装。更新成功后，新的软件状态可能会报告给制造商的服务器。在这种情况下，操作员控制何时以及安装哪些更新，这通常是商业场景下首选的解决方案，但他们也需要负责定期的更新安排。
- en: Alternatively, manufacturers might opt for a *push strategy* that gives them
    more power over the update process. They might even force devices into an update
    mode. This method could be reasonable if the manufacturer is involved and responsible
    for timely device updates, maybe even by legal obligations. Further, the security
    of specific customer target groups like private users can benefit significantly
    if updates are enforced automatically and they don’t have to organize the process
    themselves. On the other hand, some customers deliberately choose to operate devices
    with old firmware versions, and if they deny those devices access to the update
    server, manufacturers are powerless. However, if such cases are part of your challenges,
    it makes sense to focus on software state monitoring whenever devices connect
    to your online services and deny access if device firmware is too old, keeping
    a large portion of devices in the field in a secure state.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，制造商可能会选择*推式策略*，这将使他们在更新过程中拥有更多的控制权。他们甚至可能强制设备进入更新模式。如果制造商负责及时更新设备，甚至可能有法律义务，这种方法是合理的。此外，如果更新被自动强制执行，特定客户群体（如个人用户）的安全性可以显著提升，因为他们无需自己组织更新过程。另一方面，一些客户故意选择使用旧的固件版本，如果他们拒绝让设备访问更新服务器，制造商也无能为力。然而，如果这类情况是你所面临的挑战，专注于软件状态监控就显得有意义，当设备连接到在线服务时，若固件过旧，则拒绝其访问，确保大量设备保持在安全状态。
- en: Strategies that mix pull and push aspects are possible in practice. You might
    even leave the decision to your customers by providing corresponding configuration
    options for your device. This enables operators to perfectly integrate your device
    into their specific asset and patch-management processes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际操作中，混合拉取和推送策略是可能的。你甚至可以通过为设备提供相应的配置选项，将决定权交给客户。这使得操作人员能够将你的设备完美地集成到他们特定的资产和补丁管理流程中。
- en: '**Update Granularity and Format**'
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**更新粒度和格式**'
- en: The terms *software update* and *firmware update* are often used interchangeably
    and for a broad range of update scenarios, from rewriting all memory contents
    within a device to the change of few configuration parameters within a single
    file. Therefore, for your specific device, it’s absolutely necessary to define
    which parts of your device firmware should be replaceable and in which format
    you would like to distribute that data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*软件更新*和*固件更新*这两个术语通常可以互换使用，并适用于各种更新场景，从重写设备内存的所有内容到更改单个文件中的一些配置参数。因此，对于你的特定设备，明确哪些固件部分是可替换的，以及你希望以何种格式分发这些数据，是绝对必要的。'
- en: '***Firmware Parts***'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***固件部分***'
- en: 'In the PC context, *firmware* is the software programmed to the onboard nonvolatile
    memory of the motherboard, installed daughterboards, and further peripheral devices.
    OSs, software applications, and user data, usually stored on hard disks, are not
    regarded as firmware. In the embedded system context, however, almost everything
    can be regarded as firmware:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在PC环境中，*固件*是指编程到主板、安装的子板以及其他外围设备上的板载非易失性存储器中的软件。操作系统、软件应用程序和用户数据，通常存储在硬盘上，不被视为固件。然而，在嵌入式系统环境中，几乎一切都可以被视为固件：
- en: '**Bootloader**    Modern embedded devices contain at least one boot-loader,
    usually more.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**引导加载程序** 现代嵌入式设备通常至少包含一个引导加载程序，通常不止一个。'
- en: '**Coprocessor firmware**    Recent SoCs include a heterogeneous set of processors
    within one package. Some of these coprocessors might require their own firmware.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**协处理器固件** 最近的SoC（系统级芯片）包括在一个封装内的异构处理器集合。这些协处理器中的一些可能需要自己的固件。'
- en: '**Controller firmware**    On the PCB scale, a single embedded system might
    have several microcontrollers that execute dedicated firmware.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制器固件** 在PCB（印刷电路板）层面，一个嵌入式系统可能有多个微控制器，每个微控制器执行专用的固件。'
- en: '**FPGA bitstream**    As part of an SoC or as a discrete component, FPGAs are
    integrated into a multitude of embedded devices. Their configuration, called the
    *bitstream*, might be read directly from flash memory or loaded by a bootloader
    or an OS application.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**FPGA比特流** 作为SoC的一部分或作为独立组件，FPGA被集成到多种嵌入式设备中。它们的配置，称为*比特流*，可能直接从闪存读取，或由引导加载程序或操作系统应用程序加载。'
- en: '**Bare-metal software**    In devices running without an OS, bare-metal software
    is the main application.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**裸机软件** 在没有操作系统的设备上，裸机软件是主要的应用程序。'
- en: '**OS kernel**    If your device comes with an OS or an RTOS, the corresponding
    OS kernel is the central software component.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作系统内核** 如果你的设备带有操作系统或实时操作系统（RTOS），则相应的操作系统内核是中央软件组件。'
- en: '**Device tree**    The hardware components and their parameters for a specific
    embedded system are often described in a device-tree file that’s loaded by the
    OS kernel.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备树** 特定嵌入式系统的硬件组件及其参数通常在设备树文件中描述，该文件由操作系统内核加载。'
- en: '**Root filesystem**    The basic filesystem on top of which all other filesystems
    and overlays are mounted contains data that’s crucial for the correct functioning
    of an OS.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**根文件系统** 所有其他文件系统和覆盖层都挂载在其上的基本文件系统包含对操作系统正确运行至关重要的数据。'
- en: '**Application software**    Application software might be part of the root
    filesystem but could also be located in one or multiple manufacturer-specific
    partitions.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用软件** 应用软件可能是根文件系统的一部分，但也可能位于一个或多个制造商特定的分区中。'
- en: 'Some of the firmware parts on that list might share a common nonvolatile memory;
    others might come with their own discrete memory component. Make sure you are
    aware of all relevant firmware components when developing a secure update concept.
    However, don’t forget that your device probably carries unique data that must
    not be affected by a software update:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的一些固件部分可能共享一个公共的非易失性存储器；其他部分可能配有自己的独立存储器组件。在开发安全更新方案时，确保你了解所有相关的固件组件。然而，不要忘记，你的设备可能包含一些独特的数据，这些数据不能被软件更新所影响：
- en: '**Unique cryptographic keys**    Data corresponding to your device’s unique
    identity, probably provisioned during production, is essential for trustworthy
    device authentication. Additionally, secrets, like SSH keys that are generated
    at first boot, should survive a software update.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**唯一的加密密钥**    与设备唯一身份相关的数据，可能在生产过程中提供，对于可信的设备认证至关重要。此外，像在首次启动时生成的SSH密钥这样的密钥也应该在软件更新后保持不变。'
- en: '**User-dependent system data**    Customers rely on additional user accounts
    and corresponding credentials as well as custom device configuration files.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户依赖的系统数据**    客户依赖于额外的用户账户及其相应的凭证，以及自定义设备配置文件。'
- en: '**Runtime data partitions**    Your device might collect and store user-specific
    runtime data, like sensor-value histories for data analytics applications, but
    it might also log data that might be relevant for maintenance and repair cases.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行时数据分区**    您的设备可能会收集并存储特定用户的运行时数据，比如用于数据分析应用的传感器值历史记录，也可能会记录与维护和修理相关的数据。'
- en: '***Update Formats***'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***更新格式***'
- en: 'As mentioned previously, the granularity of software components that need to
    be covered by updates varies greatly and doesn’t directly suggest a specific format
    for update distribution. Several requirements should be considered before deciding:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，需要更新的软件组件的粒度差异很大，这并不会直接指示更新分发的具体格式。在决定之前，应该考虑几个要求：
- en: '**Comprehensive coverage**    The chosen format should have the ability to
    update as many of a device’s software components as possible.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**全面覆盖**    所选择的格式应能够更新尽可能多的设备软件组件。'
- en: '**Efficiency**    Since the size of firmware is constantly increasing, it should
    be possible to reduce a firmware update to the parts that are actually new.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**效率**    由于固件的大小不断增加，应该能够将固件更新限制为实际更新的部分。'
- en: '**Atomicity**    The installation of an update should be an *indivisible* operation
    allowing only two final states: successfully updated firmware or, upon failure,
    the original firmware before the update process started.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**原子性**    更新的安装应为*不可分割*的操作，只允许两种最终状态：成功更新的固件，或在失败时回到更新开始前的原始固件。'
- en: 'The following list provides possible update format solutions based on the previously
    posed requirements:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表提供了基于先前提出的要求的可能更新格式解决方案：
- en: '**Files**    A trivial update format would be to supply a device with a set
    of updated files that can be written to their specific paths in a filesystem.
    While this would enable updates for all components available in the device’s filesystem,
    and small, efficient update packages could be created, atomicity is complex. Every
    file created, written, or deleted requires its own operation that might fail or
    succeed. In case of an error, the firmware might end up in an unknown state.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件**    一种简单的更新格式是为设备提供一组更新的文件，这些文件可以写入文件系统中对应的路径。虽然这种方式可以为设备文件系统中所有可用的组件提供更新，并且可以创建小巧高效的更新包，但原子性比较复杂。每个创建、写入或删除的文件都需要进行各自的操作，这些操作可能成功，也可能失败。如果出现错误，固件可能会处于一个未知的状态。'
- en: '**Containers**    Containerized applications have become increasingly popular
    in larger embedded systems. The replacement of whole container images could be
    effective for their update management, but relying only on container-based updates
    would neglect important software components like the host OS running the container
    management.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器**    容器化应用在更大型的嵌入式系统中变得越来越流行。替换整个容器镜像可能对其更新管理有效，但仅依赖容器更新会忽略一些重要的软件组件，如运行容器管理的主机操作系统。'
- en: '**Images**    Updating entire partition images enables updates for many software
    components in an embedded system and has advantages regarding atomicity. This
    approach might lead to larger firmware updates than other formats, but some implementations
    also support compressed update files or differential updates to overcome this
    issue.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**图像**    更新整个分区镜像可以使嵌入式系统中的许多软件组件进行更新，并且在原子性方面具有优势。虽然这种方法可能导致比其他格式更大的固件更新，但一些实现也支持压缩更新文件或差分更新，以解决这个问题。'
- en: '**NOTE**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Firmware parts that aren’t reachable by filesystem access, such as ICs that
    have to be updated based on a proprietary protocol, require customized treatment.
    Consider the pros and cons and make a conscious decision regarding the targeted
    update capabilities for your device.*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*无法通过文件系统访问的固件部分，例如必须基于专有协议进行更新的IC，需要定制的处理。请考虑利弊，并在针对设备的更新能力方面做出有意识的决策。*'
- en: '***Issues with Package Managers***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***包管理器的问题***'
- en: You might wonder why Linux-based embedded devices in most cases don’t rely on
    established package manager applications like `apt-get` or `opkg` that are used
    back and forth on desktop and server systems. The reason lies in the testing complexity
    of systems that are updated on a package basis. Such an approach requires the
    management of *dependencies* among all possible packages in a system, and it multiplies
    the possible software configurations that have to be tested.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么基于 Linux 的嵌入式设备大多数情况下不依赖于像 `apt-get` 或 `opkg` 这样的成熟包管理器，这些包管理器在桌面和服务器系统中广泛使用。原因在于基于包更新的系统的测试复杂性。此类方法需要管理系统中所有可能包之间的*依赖关系*，并且会增加需要测试的可能软件配置数量。
- en: In addition, since embedded devices often operate in critical applications or
    industries, comprehensive testing is a must. Therefore, many manufacturers refrain
    from using package managers and choose an atomic, image-based updating approach
    instead, restricting the interplay of software components to be tested to the
    specific versions in a certain software release.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于嵌入式设备通常在关键应用或行业中运行，因此必须进行全面的测试。因此，许多制造商避免使用包管理器，转而选择基于镜像的原子更新方法，限制软件组件之间的交互，只测试特定版本的软件发布中的组件。
- en: If you want to go down that road, you probably need a partner that offers automated
    and reliable testing services that handle all the mentioned issues, for example,
    as provided by Canonical for their Ubuntu Core OS.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算走这条路，你可能需要一个提供自动化和可靠测试服务的合作伙伴，来处理所有提到的问题，例如 Canonical 为其 Ubuntu Core OS
    提供的服务。
- en: '**Device Partitioning Strategies**'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**设备分区策略**'
- en: A robust update procedure is possible only if the memory partitioning of your
    device supports it. Depending on available memory and willingness to take risks,
    various approaches can be used to design a system’s partition layout to support
    updating processes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当你的设备的内存分区支持时，才能实现可靠的更新过程。根据可用内存和风险承受能力，可以使用不同的方法来设计系统的分区布局，以支持更新过程。
- en: '***Update/Recovery Partition***'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***更新/恢复分区***'
- en: You can enhance robustness against failed firmware updates by introducing an
    additional *recovery partition*. This partition contains tools to download and
    update the main system partition, including the OS kernel and the corresponding
    root filesystem, as shown in [Figure 9-1](ch09.xhtml#ch09fig01).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过引入一个额外的*恢复分区*来增强对固件更新失败的容错性。该分区包含下载和更新主系统分区的工具，包括操作系统内核和相应的根文件系统，如[图 9-1](ch09.xhtml#ch09fig01)所示。
- en: '![Image](../images/09fig01.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig01.jpg)'
- en: '*Figure 9-1: The recovery partition to perform system updates*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：用于执行系统更新的恢复分区*'
- en: The advantage of this approach is the low memory footprint of the extra partition,
    which should be feasible for many devices. However, on the downside, the device
    has to be rebooted to enter the update or recovery mode. If the update process
    fails, the main partition is corrupted and can’t be booted anymore, so the recovery
    partition is booted again, and a fresh update process can be initiated.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是额外分区的内存占用较低，这对于许多设备来说应该是可行的。然而，缺点是设备必须重启才能进入更新或恢复模式。如果更新过程失败，主分区会被损坏并无法再启动，此时会再次启动恢复分区，并可以启动一个全新的更新过程。
- en: '***A/B System Approach***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***A/B 系统方法***'
- en: For devices providing plenty of nonvolatile memory, the *A/B system* approach
    can be an interesting candidate. [Figure 9-2](ch09.xhtml#ch09fig02) depicts the
    basic partition layout and update procedure.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于提供大量非易失性存储器的设备，*A/B 系统*方法可能是一个有趣的候选方案。[图 9-2](ch09.xhtml#ch09fig02)展示了基本的分区布局和更新过程。
- en: '![Image](../images/09fig02.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig02.jpg)'
- en: '*Figure 9-2: Two identical system image copies—A and B*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-2：两个相同的系统镜像副本——A 和 B*'
- en: In this layout, two copies, A and B, of the system partition exist, both holding
    at least the OS kernel and the root filesystem. At boot, the partition marked
    as “bootable” (partition A in [Figure 9-2](ch09.xhtml#ch09fig02)) is used to load
    the OS and the basic filesystem. This includes an update client that’s able to
    receive firmware updates, verify them, and write them to the currently unused
    partition ➊ (B in [Figure 9-2](ch09.xhtml#ch09fig02)). Afterward, the bootloader
    is configured to swap the boot partition from A to B (or vice versa) ➋ before
    rebooting to the new firmware version.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种布局中，系统分区有两个副本，A 和 B，都至少包含操作系统内核和根文件系统。在启动时，标记为“可启动”的分区（在[图 9-2](ch09.xhtml#ch09fig02)中为
    A 分区）用于加载操作系统和基础文件系统。此过程包括一个更新客户端，能够接收固件更新，验证它们，并将其写入当前未使用的分区 ➊（在[图 9-2](ch09.xhtml#ch09fig02)中为
    B 分区）。随后，引导加载程序会被配置为将启动分区从 A 切换到 B（或反之）➋，然后重新启动到新的固件版本。
- en: In case of an update failure or partition corruption, the old version is still
    available in its original state and can be booted again. A significant advantage
    compared to using a recovery partition is that the standard device operation is
    not interrupted during the update download and installation. In addition, the
    newly downloaded firmware can be directly stored on the inactive partition instead
    of requiring an additional storage location for update caching. On Android devices,
    this concept is called *seamless system updates*, and it’s increasingly implemented
    by phone vendors.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更新失败或分区损坏，旧版本仍然保持原样并可以重新启动。与使用恢复分区相比，一个显著的优点是，设备的标准操作在更新下载和安装过程中不会中断。此外，新下载的固件可以直接存储在非活动分区中，而不需要额外的存储位置来缓存更新。在
    Android 设备上，这个概念被称为*无缝系统更新*，并且越来越多的手机厂商开始实现这一功能。
- en: For devices of even higher criticality, both approaches can be combined, as
    shown in [Figure 9-3](ch09.xhtml#ch09fig03).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高关键性的设备，可以将这两种方法结合使用，如[图 9-3](ch09.xhtml#ch09fig03)所示。
- en: '![Image](../images/09fig03.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig03.jpg)'
- en: '*Figure 9-3: The A/B architecture with an additional recovery partition*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-3：带有额外恢复分区的 A/B 架构*'
- en: This design aims for protection against cases in which both system partitions,
    A and B, are corrupted for whatever reason. For such architectures, it makes sense
    to store the recovery partition within a different physical memory than the system
    partitions. Even if the recovery partition can’t successfully reinstall the system
    partitions, it can still report the system failure and perform diagnostics.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该设计旨在防范系统分区 A 和 B 因各种原因而都遭到损坏的情况。对于这种架构，最好将恢复分区存储在与系统分区不同的物理内存中。即使恢复分区无法成功重新安装系统分区，它仍然可以报告系统故障并执行诊断。
- en: '***A Note on Updating Bootloaders***'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***关于更新引导加载程序的说明***'
- en: Bootloaders are used on many embedded systems. They handle basic system initialization,
    select a boot medium, and subsequently load an OS kernel. In many cases, these
    binaries are regarded as an “immutable” firmware part.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序广泛应用于许多嵌入式系统。它们处理基本的系统初始化，选择启动介质，并随后加载操作系统内核。在许多情况下，这些二进制文件被视为“不可更改”的固件部分。
- en: However, these days, bootloaders like U-Boot and GRUB are complex software components
    with a variety of features and capabilities. As a consequence, bootloaders also
    may exhibit bugs or even security vulnerabilities that require updates.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如今像 U-Boot 和 GRUB 这样的引导加载程序已经成为功能复杂的软件组件，具有多种特性和能力。因此，引导加载程序可能会出现错误，甚至出现需要更新的安全漏洞。
- en: From a security point of view, you also might need to replace public keys or
    outdated cryptographic algorithms used for a secure boot process, as described
    in [Chapter 8](ch08.xhtml#ch08). On the functional side, you might come to a point
    when you’d like to update hardware initialization settings, kernel boot parameters,
    or boot configurations. All these reasons render updating boot-loaders and their
    configuration data a valid consideration.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，你可能还需要更换用于安全启动过程的公钥或过时的加密算法，正如[第 8 章](ch08.xhtml#ch08)中所描述的那样。在功能方面，你可能会遇到需要更新硬件初始化设置、内核启动参数或引导配置的情况。所有这些原因都使得更新引导加载程序及其配置数据成为一个有效的考虑事项。
- en: In most systems, however, only a single copy per bootloader is available, which
    means that updating it comes with the risk of breaking the device—for example,
    in the case of power loss or other failures during the bootloader update. Only
    a few SoCs and microcontrollers provide support for additional bootloader instances
    that can be run when the main bootloader fails. Therefore, updating a bootloader
    is always a critical and risky procedure that can well lead to a situation where
    physical access to a device is necessary for repair.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大多数系统中，每个引导加载程序只有一个副本可用，这意味着更新它存在使设备发生故障的风险——例如，在引导加载程序更新期间发生断电或其他故障时。只有少数几个SoC和微控制器提供对额外引导加载程序实例的支持，这些实例可以在主引导加载程序失败时运行。因此，更新引导加载程序始终是一个关键且风险较高的过程，可能导致需要对设备进行物理访问以进行修复的情况。
- en: A compromise solution could be a multistage bootloader approach, splitting the
    functionality in two parts. The first stage is considered immutable and has minimal
    functionality, but provides support for multiple bootloader copies in the next
    stage, which carries the fully fledged bootloader. In such a system, security
    issues in the early stage still remain a problem and would require physical access
    or a risky update procedure, but the second stage can be stored redundantly, which
    allows for low-risk updating. However, this approach isn’t standard and would
    require further development efforts and customizations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一种折衷的解决方案可能是多阶段引导加载程序方法，将功能分成两部分。第一阶段被认为是不可变的，具有最小的功能，但提供对下一阶段中多个引导加载程序副本的支持，后者包含完整的引导加载程序。在这种系统中，早期阶段的安全问题仍然是一个问题，需要物理访问或冒险更新过程，但第二阶段可以冗余存储，从而允许低风险的更新。然而，这种方法不是标准的，并且需要进一步的开发工作和定制。
- en: '**The Interplay Between Development, Backend, and Device**'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**开发、后端和设备之间的相互作用**'
- en: After clarifying all the details influencing your update strategy, it’s time
    to talk about the necessary operational processes for reliable and secure firmware
    updates. As described in [Chapter 1](ch01.xhtml#ch01), it’s the manufacturer’s
    responsibility to monitor device vulnerabilities exploited in the field and take
    vulnerability reports seriously.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在澄清了所有影响更新策略的细节后，是时候讨论可靠且安全的固件更新所需的操作流程了。如[第1章](ch01.xhtml#ch01)所述，制造商有责任监控在现场被利用的设备漏洞，并认真对待漏洞报告。
- en: 'Let’s assume you have that covered already and your development team is able
    to provide fixes in a short time frame. An operational question still remains:
    Should security updates and functional enhancements be merged with firmware updates,
    or should each be available separately?'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经解决了这个问题，并且你的开发团队能够在短时间内提供修复。仍然有一个操作性问题：是否应将安全更新和功能增强与固件更新合并，还是应该将它们分开提供？
- en: Some customers have to perform comprehensive testing of your device within their
    given infrastructure and, therefore, avoid upgrading devices with new functionalities
    that might require retests. However, they’re probably interested in security fixes
    that contribute to the robustness and security of their systems. In such scenarios,
    a split between functional and protective updates is recommended.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一些客户需要在其指定的基础设施中对你的设备进行全面测试，因此避免升级设备以加入可能需要重新测试的新功能。然而，他们可能对有助于提高系统稳健性和安全性的安全修复感兴趣。在这种情况下，建议将功能性更新和保护性更新分开。
- en: In addition, imagine that a new firmware version leads to complications and
    customers have to downgrade to the previous version. If security updates are included
    in this update file, your customers would have to live with known vulnerabilities
    in your devices, at least until the functional issues are fixed. However, taking
    this separation seriously leads to more possible software configurations and more
    testing on the manufacturer side.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，假设一个新的固件版本导致了问题，客户必须降级到之前的版本。如果安全更新包含在此更新文件中，客户将不得不忍受设备中已知的漏洞，至少在功能性问题得到修复之前。然而，认真对待这种分离会导致更多的软件配置和制造商方面更多的测试。
- en: No matter the content of a firmware update, it has to be provided and packaged
    by the development team and corresponding build pipelines. If necessary, the firmware
    has to be encrypted, usually with a symmetric encryption scheme like AES. To achieve
    authenticity and integrity protection, the final firmware image has to be digitally
    signed by appropriate algorithms like RSA or ECDSA.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 无论固件更新的内容如何，都必须由开发团队和相应的构建流水线提供和打包。如果需要，固件必须加密，通常使用像 AES 这样的对称加密方案。为了确保真实性和完整性保护，最终的固件镜像必须使用适当的算法（如
    RSA 或 ECDSA）进行数字签名。
- en: Both tasks include two components that have to match. On the manufacturer side,
    the firmware artifacts yielded by the build system have to be encrypted and signed
    to generate the actual firmware update files to be distributed. On the device
    itself, the signature verification and decryption has to be performed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个任务包含两个必须匹配的组件。在制造商一方，通过构建系统生成的固件工件必须加密并签名，以生成实际的固件更新文件进行分发。在设备本身，需要执行签名验证和解密操作。
- en: 'Several image-based update systems perform those tasks for you: Mender, SWUpdate,
    and RAUC. Mender provides the whole infrastructure, including device client software
    and backend server. SWUpdate and RAUC generate and apply firmware update files,
    but the update distribution and monitoring is typically performed by the Eclipse
    hawkBit backend framework. Further candidates include OSTree and swupd, which
    follow a “Git-like” revision-based approach for firmware updates.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个基于镜像的更新系统可以为你执行这些任务：Mender、SWUpdate 和 RAUC。Mender 提供完整的基础设施，包括设备客户端软件和后端服务器。SWUpdate
    和 RAUC 生成并应用固件更新文件，但更新分发和监控通常由 Eclipse hawkBit 后端框架执行。其他候选方案包括 OSTree 和 swupd，它们采用类似
    Git 的基于修订的固件更新方法。
- en: '**Case Study: Secure Firmware Updates with SWUpdate**'
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**案例研究：使用 SWUpdate 进行安全固件更新**'
- en: This case study provides an example of the necessary practical steps to bring
    a secure firmware update architecture to life. It’s based on the Yocto tool-chain
    delivered by ST for the STM32MP157F-DK2 board.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本案例研究提供了将安全固件更新架构付诸实践所需的步骤示例。它基于 ST 为 STM32MP157F-DK2 开发板提供的 Yocto 工具链。
- en: I’ve chosen SWUpdate as the central software component for this implementation.
    The desired outcome is an update process that verifies the authenticity of updates
    based on digital signatures and guarantees a reliable update procedure taking
    an A/B system approach.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择了 SWUpdate 作为本实现的核心软件组件。期望的结果是一个基于数字签名验证更新真实性，并确保通过 A/B 系统方法保证可靠更新过程的更新流程。
- en: '***SD Card Layout Customization***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SD 卡布局定制***'
- en: The Yocto build system compiles and packages all relevant software for my device’s
    firmware image and provides it in formats like *.ext4* and *.tar.gz*. This is
    useful for further processing, such as for generating an SD card image and creating
    an update file, but let’s take it one step at a time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto 构建系统编译并打包我设备固件镜像的所有相关软件，并以 *.ext4* 和 *.tar.gz* 等格式提供。这对于进一步处理很有用，例如生成
    SD 卡镜像和创建更新文件，但我们先一步一步来。
- en: The STM32 Cube Programmer tool from ST as well as the handy shell script *create_sdcard_from_flashlayout.sh*
    use flash memory layout files in a Tab-Separated Values (TSV) format. Among other
    things, such a TSV file contains a list of partitions, their offset, and the files
    required to populate them. Selected columns of the default flash layout for the
    STM32MP157FDK2 board are shown in [Listing 9-1](ch09.xhtml#ch09list01).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 ST 的 STM32 Cube Programmer 工具以及便捷的 shell 脚本 *create_sdcard_from_flashlayout.sh*
    使用制表符分隔值（TSV）格式的闪存内存布局文件。该 TSV 文件包含多个内容，其中包括分区列表、偏移量以及填充这些分区所需的文件。STM32MP157FDK2
    开发板的默认闪存布局的选定列如 [列表 9-1](ch09.xhtml#ch09list01) 所示。
- en: '[PRE0]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 9-1: The default flash layout for the STM32MP157F-DK2 board*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-1：STM32MP157F-DK2 开发板的默认闪存布局*'
- en: The TSV file contains many lines concerning bootloaders and trusted firmware
    artifacts that are of minor interest at this point. The last three lines, however,
    reveal two important facts. First, a dedicated `bootfs` partition contains U-Boot
    configuration files, device-tree blobs, and the Linux kernel as a `uImage`. Second,
    the `rootfs` partition is a perfect candidate for duplication for an A/B system
    approach. [Listing 9-2](ch09.xhtml#ch09list02) shows the changes I made to the
    TSV file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: TSV文件包含了许多与引导加载程序和受信固件工件相关的行，这些内容在此时并不重要。然而，最后三行揭示了两个重要事实。首先，一个专用的 `bootfs`
    分区包含U-Boot配置文件、设备树二进制文件和作为 `uImage` 的Linux内核。其次，`rootfs` 分区是一个非常适合复制以支持A/B系统方法的候选者。[列表
    9-2](ch09.xhtml#ch09list02)展示了我对TSV文件所做的更改。
- en: '[PRE1]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 9-2: An adjusted partition layout for the A/B update approach*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-2：A/B更新方法的调整分区布局*'
- en: 'The original `rootfs` partition was cloned, resulting in two new partitions:
    `rootfs-a` and `rootfs-b`. Also, a `userfs` partition, already available in the
    toolchain provided by ST, was added to store data that should “survive” an update
    of the root filesystem.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '原始的 `rootfs` 分区被克隆， resulting in two new partitions: `rootfs-a` 和 `rootfs-b`。此外，还添加了一个
    `userfs` 分区，这个分区在ST提供的工具链中已经存在，用于存储在根文件系统更新过程中应该“保留”的数据。'
- en: For SD card image generation with the new parameters, the *create_sdcard _from_flashlayout.sh*
    shell script also had to be adapted to correctly handle the newly introduced partitions
    `rootfs-a` and `rootfs-b`. The SD card image size was set to 2,048MB, while both
    root partitions were configured to occupy 768MB, as already indicated by the offset
    of `0x30000000` in the flash layout file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用新参数生成SD卡镜像，还必须调整 *create_sdcard_from_flashlayout.sh* 脚本，以正确处理新引入的分区 `rootfs-a`
    和 `rootfs-b`。SD卡镜像的大小被设置为2,048MB，同时两个根分区被配置为各占768MB，这在闪存布局文件中的偏移量`0x30000000`已经体现出来。
- en: An important setting in the image creation script is the allocation of individual
    partition UUIDs for partitions `rootfs-a` and `rootfs-b`, as shown in [Listing
    9-3](ch09.xhtml#ch09list03).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在镜像创建脚本中的一个重要设置是为分区 `rootfs-a` 和 `rootfs-b` 分配单独的UUID，如[列表 9-3](ch09.xhtml#ch09list03)所示。
- en: '[PRE2]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 9-3: The individual UUIDs for both copies of the root filesystem*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-3：两个根文件系统副本的独立UUID*'
- en: I reused the UUID of the original `rootfs` partition for `rootfs-a` and randomly
    created a new one for `rootfs-b`. These UUIDs are relevant because they are used
    in U-Boot’s *extlinux.conf* configuration file located in the `bootfs` partition
    to determine the partition to be mounted as the root filesystem by the Linux kernel.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我重用了原始 `rootfs` 分区的UUID用于 `rootfs-a`，并为 `rootfs-b` 随机生成了一个新的UUID。这些UUID非常重要，因为它们用于U-Boot的
    *extlinux.conf* 配置文件中，位于 `bootfs` 分区，用于确定Linux内核挂载为根文件系统的分区。
- en: Afterward, the basic partition architecture for this case study is ready to
    support A/B system updates.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，案例研究的基本分区架构已经准备好支持A/B系统更新。
- en: '***SWUpdate Installation and Configuration***'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SWUpdate的安装和配置***'
- en: SWUpdate, a feature-rich firmware update tool for embedded systems, provides
    the corresponding `meta-swupdate` layer for Yocto. This layer can be cloned from
    its Git repository and added to the STM32MP1 Yocto project.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: SWUpdate 是一款功能丰富的嵌入式系统固件更新工具，它为Yocto提供了相应的 `meta-swupdate` 层。可以从其Git仓库克隆该层，并将其添加到STM32MP1
    Yocto项目中。
- en: '**Addition of Security Features**'
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**安全特性的添加**'
- en: One of the first tasks is to create a recipe that patches the configuration
    of SWUpdate to enable signed and encrypted images. [Listing 9-4](ch09.xhtml#ch09list04)
    shows the three lines that have to be explicitly activated.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务之一是创建一个补丁，修改SWUpdate的配置以启用签名和加密的镜像。[列表 9-4](ch09.xhtml#ch09list04)展示了必须显式激活的三行配置。
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 9-4: Activating important security features of SWUpdate*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-4：激活SWUpdate的重要安全特性*'
- en: The two options `CONFIG_HASH_VERIFY` and `CONFIG_SIGNED_IMAGES` add capabilities
    to SWUpdate that allow it to verify hashes and digital signatures of images included
    in a software update. The `CONFIG_ENCRYPTED_IMAGES` option enables support for
    AES-encrypted images, which we don’t implement at the moment, but it might be
    a valuable option for the future.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 两个选项 `CONFIG_HASH_VERIFY` 和 `CONFIG_SIGNED_IMAGES` 为SWUpdate增加了验证哈希和数字签名的能力，用于验证软件更新中包含的镜像。`CONFIG_ENCRYPTED_IMAGES`
    选项启用了对AES加密镜像的支持，尽管我们目前未实现这一功能，但它可能是未来一个有价值的选项。
- en: '**Key Generation**'
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**密钥生成**'
- en: As explained in [Chapter 2](ch02.xhtml#ch02), digital signatures are an asymmetric
    crypto primitive that allow for verification of integrity and authenticity of
    signed data. SWUpdate can generate signatures based on plain RSA keys or certificates.
    For this case study, I chose to use 4,096-bit RSA keys. Their generation can be
    split into three steps, as shown in [Listing 9-5](ch09.xhtml#ch09list05).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第2章](ch02.xhtml#ch02)中所解释的，数字签名是一种非对称加密原语，允许验证签名数据的完整性和真实性。SWUpdate可以基于普通的RSA密钥或证书生成签名。在这个案例研究中，我选择使用4,096位的RSA密钥。它们的生成可以分为三个步骤，如[清单9-5](ch09.xhtml#ch09list05)所示。
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 9-5: The RSA key generation for update signing and verification*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-5：用于更新签名和验证的RSA密钥生成*'
- en: First, the file *passphrase* is created that should contain a strong password.
    Afterward, the RSA key can be generated (for example, with 4,096-bit length).
    The resulting private key is encrypted based on the given passphrase file and
    stored as *swu_signing_key.pem*. Note that this is the RSA private key used for
    signing a firmware update after the build process. The corresponding public key
    is extracted and saved as *swu_verification_key.pem* in the third line of the
    listing. This is necessary to make that key available in the final device firmware
    because it’s required for update signature verification.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个*密码短语*文件，里面应该包含一个强密码。之后，可以生成RSA密钥（例如，4,096位长度）。生成的私钥基于给定的密码短语文件进行加密，并存储为*swu_signing_key.pem*。请注意，这是在构建过程后，用于签署固件更新的RSA私钥。对应的公钥被提取并保存在清单中的第三行，命名为*swu_verification_key.pem*。这样做是为了将该公钥包含在最终设备固件中，因为它在更新签名验证时是必需的。
- en: '**Software Collection**'
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**软件集合**'
- en: Next, SWUpdate needs to know which Yocto build artifacts should be included
    in the firmware update. This information is stored in the *sw-description* file,
    which is used for update generation, but it’s also included in the firmware update
    package itself.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，SWUpdate需要知道哪些Yocto构建产物应包含在固件更新中。这些信息存储在*sw-description*文件中，该文件用于更新生成，同时也包含在固件更新包中。
- en: '[Listing 9-6](ch09.xhtml#ch09list06) shows the software collection I defined
    for this use case.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单9-6](ch09.xhtml#ch09list06)展示了我为此用例定义的软件集合。'
- en: '[PRE5]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 9-6: The software collection defined in the* sw-description *file*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-6：在* sw-description *文件中定义的软件集合*'
- en: The first point you might stumble upon is the `hardware-compatibility` parameter
    ➊. I set it to `C02` because it’s the hardware and assembly revision of my STM32MP157F-DK2
    board. At runtime, this parameter has to match the data given in */etc/hwrevision*
    (for example, `stm32mp157f-dk2 C02` in my case).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能遇到的第一个问题是`hardware-compatibility`参数 ➊。我将其设置为`C02`，因为这是我的STM32MP157F-DK2开发板的硬件和组装版本。在运行时，这个参数必须与*/etc/hwrevision*中提供的数据匹配（例如，在我的情况下为`stm32mp157f-dk2
    C02`）。
- en: Second, both partitions `rootfs-a` ➋ and `rootfs-b` ➐ are represented in this
    software collection, although only one will be used for updating at runtime. Both
    contain the same filename of the artifact to update ➌—in this case, the root filesystem
    generated by Yocto. The `compressed` parameter ➍ indicates whether the data is
    available in compressed form, while `sha256` ➏ integrates the SHA-256 hash value
    of the provided artifact into the *sw-description* file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这个软件集合中表示了`rootfs-a` ➋和`rootfs-b` ➐两个分区，尽管在运行时只有一个分区会被用于更新。两者都包含了相同的更新目标文件名
    ➌——在这个例子中，是由Yocto生成的根文件系统。`compressed`参数 ➍指示数据是否以压缩形式提供，而`sha256` ➏将提供的目标文件的SHA-256哈希值集成到*sw-description*文件中。
- en: 'The two images differ in only one property: the partition indicated by the
    `device` parameter ➎. This determines where the SWUpdate client writes the update
    to. In this case, */dev/mmcblk0p10* and */dev/mmcblk0p11* are the device names
    under which the earlier created partitions `rootfs-a` and `rootfs-b` are available
    within Linux. If */dev/mmcblk0p10* is the active partition, the update has to
    be written to */dev/mmcblk0p11*, and vice versa.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个映像仅在一个属性上有所不同：由`device`参数 ➎指示的分区。这决定了SWUpdate客户端将更新写入哪里。在本例中，*/dev/mmcblk0p10*和*/dev/mmcblk0p11*是之前创建的`rootfs-a`和`rootfs-b`分区在Linux中的设备名称。如果*/dev/mmcblk0p10*是活动分区，则更新必须写入*/dev/mmcblk0p11*，反之亦然。
- en: '**Recipe for Update File Generation**'
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**更新文件生成配方**'
- en: SWUpdate’s firmware update files have the *.swu* extension. The `meta-swupdate`
    layer comes with a class that supports SWU filegeneration by Yocto based on artifacts
    previously built and stored in Yocto’s *deploy* directory. [Listing 9-7](ch09.xhtml#ch09list07)
    shows the corresponding code for a Yocto recipe that automatically generates a
    valid and digitally signed SWU file.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: SWUpdate的固件更新文件扩展名为*.swu*。`meta-swupdate`层提供了一个类，支持基于先前构建并存储在Yocto的*deploy*目录中的工件，通过Yocto生成SWU文件。[清单
    9-7](ch09.xhtml#ch09list07)显示了一个Yocto配方的相应代码，该配方自动生成有效且经过数字签名的SWU文件。
- en: '[PRE6]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 9-7: The recipe code that generates an SWU update file*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-7：生成SWU更新文件的配方代码*'
- en: The recipe adds the *sw-description* file created earlier and states the dependency
    on the `st-image-core` image. Within Yocto’s *deploy* directory, the desired update
    content (the device’s root filesystem) can be found in files starting with *st-image-core-openstlinux-eglfs*,
    while the target machine is added automatically by SWUpdate.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 配方添加了先前创建的*sw-description*文件，并声明了对`st-image-core`镜像的依赖。在Yocto的*deploy*目录中，所需的更新内容（设备的根文件系统）可以在以*st-image-core-openstlinux-eglfs*开头的文件中找到，同时目标机器会由SWUpdate自动添加。
- en: In contrast to SD card image creation, where the file with the *.ext4* extension
    is used (as shown in [Listing 9-2](ch09.xhtml#ch09list02)), the firmware update
    should be as small as possible to optimize transfer times. Therefore, the compressed
    artifact with *.ext4.gz* is used for the SWU file. Finally, to enable firmware
    update signing, I set `SWUPDATE_SIGNING` to `"RSA"` and provided the paths to
    the private RSA signing key and its corresponding passphrase file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与SD卡镜像创建不同，在SD卡镜像创建中使用带有*.ext4*扩展名的文件（如[清单 9-2](ch09.xhtml#ch09list02)所示），固件更新应尽可能小，以优化传输时间。因此，用于SWU文件的压缩工件采用*.ext4.gz*格式。最后，为了启用固件更新签名，我将`SWUPDATE_SIGNING`设置为`"RSA"`并提供了私有RSA签名密钥及其相应密码文件的路径。
- en: Running this recipe ensures that the `st-image-core` image is built and then
    yields the *swupdate-swu-gen-openstlinux-eglfs-stm32mp1.swu* file within the *deploy*
    directory. This file is actually a copy-in-and-out (CPIO) archive that contains
    the *sw-description* file and its signature *sw-description.sig* file. Additionally,
    the compressed *st-image-core-openstlinux-eglfs-stm32mp1.ext4.gz* file is shipped
    within this archive, which contains the root filesystem.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个配方确保构建了`st-image-core`镜像，然后在*deploy*目录中生成*swupdate-swu-gen-openstlinux-eglfs-stm32mp1.swu*文件。这个文件实际上是一个进出拷贝（CPIO）归档文件，包含*sw-description*文件及其签名*sw-description.sig*文件。此外，压缩的*st-image-core-openstlinux-eglfs-stm32mp1.ext4.gz*文件也包含在此归档中，里面是根文件系统。
- en: '**NOTE**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you wonder why there isn’t any signature file for the root filesystem,
    remember that the* sw-description *file contains the hash of this image, which
    would change if anyone had tampered with it. The signature of the description
    file also protects the authenticity and integrity of the root filesystem.*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想知道为什么根文件系统没有签名文件，记住* sw-description *文件包含该镜像的哈希值，如果有人篡改过该镜像，这个哈希值会发生变化。描述文件的签名也保护了根文件系统的真实性和完整性。*'
- en: '***Device-Specific Customization***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设备特定定制***'
- en: Now let’s turn to the device, the update client, and the necessary customizations
    to make SWUpdate work properly.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看设备、更新客户端以及为了使SWUpdate正常工作所需的定制。
- en: '**Update Daemon**'
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**更新守护进程**'
- en: 'To install SWUpdate’s device client and its web server components, `swupdate`
    and `swupdate-www` have to be added to ST’s core image. For configuration, the
    first consideration on the device side is which update methods it should support.
    In general, SWUpdate provides three typical ways:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装SWUpdate的设备客户端及其Web服务器组件，必须将`swupdate`和`swupdate-www`添加到ST的核心镜像中。对于配置，设备端的第一个考虑是它应该支持哪些更新方法。通常，SWUpdate提供三种典型的更新方式：
- en: '**Mongoose mode**    This daemon provides a simple web interface to allow for
    manual updates over a network.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mongoose模式**    这个守护进程提供了一个简单的Web界面，允许通过网络手动进行更新。'
- en: '**Suricatta mode**    In conjunction with Eclipse’s hawkBit, SWUpdate supports
    comprehensive OTA update setups that can be managed and controlled by a central
    server instance.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**Suricatta模式**    结合Eclipse的hawkBit，SWUpdate支持全面的OTA更新设置，可以由中央服务器实例进行管理和控制。'
- en: '**Local install**    If the SWU file is locally available (for example, on
    a USB flash drive), the update can be directly installed without requiring a network
    connection.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地安装**    如果SWU文件本地可用（例如在USB闪存驱动器上），可以直接安装更新，无需网络连接。'
- en: For this case study, I’ve chosen the mongoose daemon. As the system at hand
    uses `systemd` for Linux service configuration and management, a service file
    (*swupdate.service*) can be created as shown in [Listing 9-8](ch09.xhtml#ch09list08)
    and installed in the */etc/systemd/system/* directory.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例研究中，我选择了 mongoose 守护进程。由于该系统使用 `systemd` 进行 Linux 服务配置和管理，因此可以创建如 [列表 9-8](ch09.xhtml#ch09list08)
    所示的服务文件 (*swupdate.service*)，并将其安装到 */etc/systemd/system/* 目录中。
- en: '[PRE7]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 9-8: A basic service file to start* swupdate *in mongoose mode after
    boot*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-8：一个基本的服务文件，用于在启动后以 mongoose 模式启动* swupdate'
- en: SWUpdate’s binary is located at */usr/bin/swupdate*. It can be started in mongoose
    daemon mode at system boot with the `-w` command line parameter. The `-r /www`
    and `-p 8080` arguments following in single quotes tell it to use the default
    web application located at */www* and to bind its web server to port 8080.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: SWUpdate 的二进制文件位于 */usr/bin/swupdate*。它可以在系统启动时通过 `-w` 命令行参数以 mongoose 守护进程模式启动。紧随其后的
    `-r /www` 和 `-p 8080` 参数告诉它使用位于 */www* 的默认 Web 应用，并将其 Web 服务器绑定到 8080 端口。
- en: The string provided after the `-e` option defines which part of the expected
    software collection should be installed in the case of an update. In the default
    scenario, where `rootfs-a` is the active partition, the daemon should be started
    with `-e 'stable,rootfs-b'` to make sure that a potential update is written to
    `rootfs-b`, the inactive partition.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`-e` 选项后提供的字符串定义了在更新情况下应该安装的预期软件集合的部分。在默认情况下，如果 `rootfs-a` 是活动分区，则守护进程应使用 `-e
    ''stable,rootfs-b''` 启动，以确保潜在的更新写入 `rootfs-b`，即非活动分区。'
- en: Besides setting configuration options with command line arguments, you could
    also provide the *swupdate.cfg* configuration file at a path matching the client’s
    compile-time configuration—for example, */etc/swupdate/*. As shown in [Listing
    9-9](ch09.xhtml#ch09list09), logging parameters, paths to keys, and post-update
    shell scripts are typical settings you might want to place here.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过命令行参数设置配置选项外，您还可以提供与客户端编译时配置匹配的 *swupdate.cfg* 配置文件路径——例如，*/etc/swupdate/*。如
    [列表 9-9](ch09.xhtml#ch09list09) 所示，日志参数、密钥路径和更新后 shell 脚本是您可能希望放置在此处的典型设置。
- en: '[PRE8]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 9-9: An example configuration file for* swupdate'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-9：一个 swupdate 的示例配置文件*'
- en: However, whether you use command line arguments or a configuration file is mainly
    a matter of taste.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用命令行参数还是配置文件，主要取决于个人喜好。
- en: '**Post-Update Tasks**'
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**更新后任务**'
- en: Every device, its architecture, and its update strategy is different. Therefore,
    a general tool like SWUpdate can’t automatically derive what to do before and
    after a firmware update is written to its corresponding memory device or partition.
    On the command line, the `-p` and `-P` parameters allow for defining paths to
    *post-update* and *pre-update* commands, respectively.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备、其架构和更新策略都不同。因此，像 SWUpdate 这样的通用工具无法自动推断在固件更新写入相应的存储设备或分区之前和之后该做什么。在命令行中，`-p`
    和 `-P` 参数分别用于定义 *更新后* 和 *更新前* 命令的路径。
- en: In my case, only a post-update routine was necessary to prepare the device for
    booting the new firmware version. [Listing 9-10](ch09.xhtml#ch09list010) shows
    the contents of the *postupdate.sh* shell script that’s executed after the update
    installation, as defined in *swupdate.cfg*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的案例中，只需要一个更新后的例程来准备设备引导新的固件版本。[列表 9-10](ch09.xhtml#ch09list010) 显示了 *postupdate.sh*
    shell 脚本的内容，该脚本在更新安装后执行，正如 *swupdate.cfg* 中所定义的那样。
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 9-10: A script to prepare a device for booting the updated firmware*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-10：一个脚本，用于准备设备引导更新后的固件*'
- en: The first `if` statement ➊ checks whether the board’s U-Boot configuration file,
    *stm32mp157f-dk2_extlinux.conf*, located at */boot/mmc0_extlinux/*, contains the
    default partition UUID `e91c4e10-16e6-4c0e-bd0e-77becf4a3582`. If so, `rootfs-a`
    is the active partition, and the update was just written to `rootfs-b`. Therefore,
    the *swupdate.service* configuration file on the new partition has to be set to
    update the soon-to-be-inactive partition, `rootfs-a` ➋.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `if` 语句 ➊ 检查板卡的 U-Boot 配置文件 *stm32mp157f-dk2_extlinux.conf* 是否位于 */boot/mmc0_extlinux/*，并且是否包含默认的分区
    UUID `e91c4e10-16e6-4c0e-bd0e-77becf4a3582`。如果是，那么 `rootfs-a` 是活动分区，更新刚刚写入 `rootfs-b`。因此，新分区上的
    *swupdate.service* 配置文件必须设置为更新即将变为非活动的分区 `rootfs-a` ➋。
- en: Afterward, the partition UUID in U-Boot’s configuration file is replaced by
    the one representing `rootfs-b` ➌. This ensures that U-Boot starts the Linux kernel
    with the new root filesystem. If anything fails before this operation or a power
    loss occurs, the device will just boot into the existing firmware. But if everything
    goes well, the partition for the root filesystem is swapped and the device is
    deliberately rebooted ➍. Of course, the same procedure works the opposite way
    if the script detects that `rootfs-b` is the active partition.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，U-Boot 配置文件中的分区 UUID 被替换为代表 `rootfs-b` 的 UUID ➌。这样可以确保 U-Boot 启动具有新根文件系统的
    Linux 内核。如果在此操作之前发生任何故障或发生断电，设备将仅启动现有的固件。但如果一切顺利，根文件系统的分区会被交换，设备会被故意重启 ➍。当然，如果脚本检测到
    `rootfs-b` 是活动分区，反向过程也同样适用。
- en: Obviously, this is just one possible implementation of a post-update script
    that works for the specific architecture in this case study. Your device might
    require completely different reconfigurations before or after installing a firmware
    update.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这只是针对本案例研究中特定架构的后更新脚本的一个可能实现。您的设备在安装固件更新之前或之后，可能需要完全不同的重新配置。
- en: '***Update Process Evaluation***'
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***更新过程评估***'
- en: To conclude this case study, I flashed the previously created 2GB image to a
    16GB microSD card and booted my STM32MP157F-DK2 board from it. First, I checked
    which root filesystem partition was currently active. [Listing 9-11](ch09.xhtml#ch09list011)
    shows that both copies A (`mmcblk0p10`) and B (`mmcblk0p11`) are available and
    correctly sized. The slash at the right end of the line indicates that `rootfs-a`
    is currently mounted as the root filesystem.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 总结这个案例研究时，我将之前创建的 2GB 镜像写入到 16GB 的 microSD 卡中，并从中启动了我的 STM32MP157F-DK2 板卡。首先，我检查了当前活动的根文件系统分区。[Listing
    9-11](ch09.xhtml#ch09list011) 显示了 A 复制 (`mmcblk0p10`) 和 B 复制 (`mmcblk0p11`) 都可用且大小正确。行末的斜杠表示
    `rootfs-a` 当前被挂载为根文件系统。
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 9-11: The* mmcblk0p10 *partition mounted as the root filesystem*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-11: 挂载为根文件系统的* mmcblk0p10 *分区*'
- en: As a second step, I printed the logs of the installed `swupdate` daemon. [Listing
    9-12](ch09.xhtml#ch09list012) shows selected lines of the output.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步，我打印了已安装的 `swupdate` 守护进程的日志。[Listing 9-12](ch09.xhtml#ch09list012) 显示了输出的部分选定行。
- en: '[PRE11]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 9-12: The* swupdate *service logs*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-12: swupdate 服务日志*'
- en: The result indicates that the daemon started ➊ and the board as well, as the
    hardware revision was read correctly ➋. Further, the configuration that a potential
    update should be written to `rootfs-b` ➌ is shown as desired. In addition, the
    start of the included web server with the configured port and given directory
    is confirmed ➍.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，守护进程启动了➊，并且板卡也启动了，因为硬件版本被正确读取了➋。进一步，显示出期望的配置，即潜在更新应该写入 `rootfs-b` ➌。此外，包含的
    Web 服务器已启动，且配置了端口和指定的目录，得到了确认 ➍。
- en: I used a common browser to connect to the device’s IP address on port 8080,
    and it immediately showed the default web interface of SWUpdate. There, the SWU
    file created by Yocto could be uploaded to the device, and a progress bar showed
    the percentage of update completion. Shortly after reaching 100 percent, the device
    rebooted as expected, and a second look at `lsblk`, as shown in [Listing 9-13](ch09.xhtml#ch09list013),
    indicated that the swapping from copy A to copy B succeeded. The second update
    attempt also worked successfully and swapped the root filesystem back to `mmcblk0p10`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了一款常见的浏览器，通过 8080 端口连接到设备的 IP 地址，并且立即显示了 SWUpdate 的默认 Web 界面。在这里，可以将 Yocto
    创建的 SWU 文件上传到设备，进度条显示了更新完成的百分比。在达到 100% 后，设备如预期重新启动，再次查看 `lsblk`，如 [Listing 9-13](ch09.xhtml#ch09list013)
    所示，表明从 A 复制到 B 的交换成功。第二次更新尝试也成功，并将根文件系统交换回 `mmcblk0p10`。
- en: '[PRE12]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 9-13: The* mmcblk0p11 *partition mounted as the root filesystem after
    the update*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-13: 更新后挂载为根文件系统的* mmcblk0p11 *分区*'
- en: Finally, to test digital signature verification, I also tried to maliciously
    modify the firmware update file by extracting the original files, changing the
    target partition of `rootfs-a` to `/dev/mmcblk0p9`, and combining the modified
    files into a valid CPIO archive again. However, when uploading over the web interface,
    it soon responds with the message `Update failed`. Looking at the log data on
    the device shows that the signature verification failed as expected ([Listing
    9-14](ch09.xhtml#ch09list014)).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了测试数字签名验证，我还尝试恶意修改固件更新文件，方法是提取原始文件，将`rootfs-a`的目标分区更改为`/dev/mmcblk0p9`，然后将修改后的文件重新合并成一个有效的CPIO归档。然而，当通过Web界面上传时，它很快就响应了“`更新失败`”的信息。查看设备上的日志数据，显示签名验证失败，正如预期的那样（[列表
    9-14](ch09.xhtml#ch09list014)）。
- en: '[PRE13]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 9-14: The signature verification fails for the modified firmware update.*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-14：修改后的固件更新的签名验证失败。*'
- en: Testing software update verification routines for their correct *rejection behavior*
    is not only valuable during development. It also makes absolute sense to integrate
    similar test cases into release or production testing, because it wouldn’t be
    the first time that verification got switched off by accident.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 测试软件更新验证例程的正确*拒绝行为*不仅在开发过程中有价值，在发布或生产测试中集成类似的测试用例也非常有意义，因为验证被意外关闭的情况并非第一次发生。
- en: '**Summary**'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Providing software and firmware updates for devices doesn’t seem like a very
    difficult task at first glance. However, if all requirements regarding security,
    scalability, and reliability are considered, it becomes a complex topic that impacts
    development pipelines, nonvolatile memory layouts, backend services, and customer
    processes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为设备提供软件和固件更新乍看之下似乎不是一项很难的任务。然而，如果考虑到所有关于安全性、可扩展性和可靠性的要求，它就变成了一个复杂的话题，影响着开发流程、非易失性存储布局、后端服务以及客户流程。
- en: This chapter stressed the inevitable need to provide secure update mechanisms
    for all kinds of IoT devices because none of them is perfect, and at some point,
    manufacturers as well as customers will demand firmware updates that have to be
    distributed and applied securely and must not break the device. To achieve these
    requirements, manufacturers have to ensure authenticity and integrity protection,
    they have to discuss update formats and granularity, and the memory partitioning
    has to support atomic and fail-safe update procedures. Also, backend servers that
    schedule, distribute, and monitor update deployments in the field have to be operated.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本章强调了为各种物联网设备提供安全更新机制的迫切需要，因为没有一款设备是完美的，在某些时候，制造商和客户都会要求进行固件更新，并且这些更新必须以安全的方式分发并应用，且不能导致设备故障。为了满足这些要求，制造商必须确保真实性和完整性保护，必须讨论更新格式和粒度，且内存分区必须支持原子和故障安全的更新过程。此外，还必须运营调度、分发并监控现场更新部署的后端服务器。
- en: If you still think it’s all too much for you to handle, and maybe your devices
    will never need any updates because that was the case during past decades, pull
    out the risk analysis for your networked device and reconsider the impact ratings
    in the event that you wouldn’t be able to fix vulnerabilities. Also, make sure
    you add “update misuse” to your list of threats if you’re going with an update
    mechanism that resembles an invitation for adversaries to install their custom
    software.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然觉得这对于你来说太复杂，可能你的设备永远不需要更新，因为在过去的几十年里确实是这样的情况，那么请拿出你的网络设备的风险分析，并重新考虑如果无法修复漏洞时的影响评级。此外，如果你使用的更新机制像是邀请对手安装自定义软件，请确保将“更新误用”添加到你的威胁列表中。
