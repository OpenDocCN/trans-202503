- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: ABUSING DATABASES AND FILESYSTEMS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 滥用数据库和文件系统
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common.jpg)'
- en: 'Now that we’ve covered the majority of common network protocols used for active
    service interrogation, command and control, and other malicious activity, let’s
    switch our focus to an equally important topic: data pillaging.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了大多数用于主动服务查询、指挥控制和其他恶意活动的常见网络协议，让我们将焦点转向另一个同样重要的话题：数据掠夺。
- en: Although data pillaging may not be as exciting as initial exploitation, lateral
    network movement, or privilege escalation, it’s a critical aspect of the overall
    attack chain. After all, we often need data in order to perform those other activities.
    Commonly, the data is of tangible worth to an attacker. Although hacking an organization
    is thrilling, the data itself is often a lucrative prize for the attacker and
    a damning loss for the organization.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数据掠夺可能没有初期的漏洞利用、横向网络移动或权限提升那么刺激，但它是整个攻击链中至关重要的一环。毕竟，我们通常需要数据来执行其他活动。通常，数据对攻击者来说具有实际价值。虽然攻击一个组织令人兴奋，但数据本身往往是攻击者的丰厚奖品，而对组织来说却是灾难性的损失。
- en: Depending on which study you read, a breach in 2020 can cost an organization
    approximately $4 to $7 million. An IBM study estimates it costs an organization
    $129 to $355 per record stolen. Hell, a black hat hacker can make some serious
    coin off the underground market by selling credit cards at a rate of $7 to $80
    per card ([*http://online.wsj.com/public/resources/documents/secureworks_hacker_annualreport.pdf*](http://online.wsj.com/public/resources/documents/secureworks_hacker_annualreport.pdf)).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你阅读的研究，2020年的一次数据泄露可能会让一个组织损失约400万到700万美元。IBM的研究估计，每条被盗记录的损失在129美元到355美元之间。天哪，黑帽黑客通过在地下市场上以每张卡7美元到80美元的价格出售信用卡，能够赚取可观的利润（[*http://online.wsj.com/public/resources/documents/secureworks_hacker_annualreport.pdf*](http://online.wsj.com/public/resources/documents/secureworks_hacker_annualreport.pdf)）。
- en: The Target breach alone resulted in a compromise of 40 million cards. In some
    cases, the Target cards were sold for as much as $135 per card (*[http://www.businessinsider.com/heres-what-happened-to-your-target-data-that-was-hacked-2014-10/](http://www.businessinsider.com/heres-what-happened-to-your-target-data-that-was-hacked-2014-10/)*).
    That’s pretty lucrative. We, in no way, advocate that type of activity, but folks
    with a questionable moral compass stand to make a lot of money from data pillaging.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 单单是Target的数据泄露就导致了4000万张卡片的泄露。在某些情况下，Target的卡片甚至以每张135美元的价格出售（*[http://www.businessinsider.com/heres-what-happened-to-your-target-data-that-was-hacked-2014-10/](http://www.businessinsider.com/heres-what-happened-to-your-target-data-that-was-hacked-2014-10/)*）。这相当可观。我们绝不提倡这种行为，但那些道德底线存疑的人通过数据掠夺可以赚大钱。
- en: Enough about the industry and fancy references to online articles—let’s pillage!
    In this chapter, you’ll learn to set up and seed a variety of SQL and NoSQL databases
    and learn to connect and interact with those databases via Go. We’ll also demonstrate
    how to create a database and filesystem data miner that searches for key indicators
    of juicy information.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 够了，关于行业和在线文章的华丽参考——让我们开始掠夺吧！在本章中，你将学习如何设置和初始化各种SQL和NoSQL数据库，并学习如何通过Go连接并与这些数据库进行交互。我们还将演示如何创建一个数据库和文件系统数据挖掘器，用来搜索有价值信息的关键指标。
- en: Setting Up Databases with Docker
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Docker设置数据库
- en: In this section, you’ll install various database systems and then seed them
    with the data you’ll use in this chapter’s pillaging examples. Where possible,
    you’ll use Docker on an Ubuntu 18.04 VM. *Docker* is a software container platform
    that makes it easy to deploy and manage applications. You can bundle applications
    and their dependencies in a manner that makes their deployment straightforward.
    The container is compartmentalized from the operating system in order to prevent
    the pollution of the host platform. This is nifty stuff.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将安装各种数据库系统，然后用你将在本章的数据掠夺示例中使用的数据对它们进行初始化。在可能的情况下，你将使用Docker在Ubuntu 18.04虚拟机上进行操作。*Docker*
    是一个软件容器平台，使得应用程序的部署和管理变得更加简便。你可以将应用程序及其依赖项打包在一起，从而简化它们的部署。容器与操作系统是隔离的，以防止污染宿主平台。这是相当巧妙的技术。
- en: And for this chapter, you will use a variety of prebuilt Docker images for the
    databases you’ll be working with. If you don’t have it already, install Docker.
    You can find Ubuntu instructions at [*https://docs.docker.com/install/linux/docker-ce/ubuntu/*](https://docs.docker.com/install/linux/docker-ce/ubuntu/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你将使用各种预构建的Docker镜像来处理你将要使用的数据库。如果你还没有安装Docker，请安装它。你可以在[*https://docs.docker.com/install/linux/docker-ce/ubuntu/*](https://docs.docker.com/install/linux/docker-ce/ubuntu/)找到Ubuntu的安装说明。
- en: '**NOTE**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ve specifically chosen to omit details on setting up an Oracle instance.
    Although Oracle provides VM images that you can download and use to create a test
    database, we felt that it was unnecessary to walk you through these steps, since
    they’re fairly similar to the MySQL examples below. We’ll leave the Oracle-specific
    implementation as an exercise for you to do independently.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们特意选择省略了设置Oracle实例的细节。虽然Oracle提供了可以下载并用于创建测试数据库的虚拟机镜像，但我们认为没有必要带你完成这些步骤，因为它们与下面的MySQL示例非常相似。我们将Oracle特定的实现作为一个独立的练习留给你去做。*'
- en: Installing and Seeding MongoDB
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装并初始化MongoDB
- en: '*MongoDB* is the only NoSQL database that you’ll use in this chapter. Unlike
    traditional relational databases, MongoDB doesn’t communicate via SQL. Instead,
    MongoDB uses an easy-to-understand JSON syntax for retrieving and manipulating
    data. Entire books have been dedicated to explaining MongoDB, and a full explanation
    is certainly beyond the scope of this book. For now, you’ll install the Docker
    image and seed it with fake data.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*MongoDB*是本章唯一使用的NoSQL数据库。与传统的关系型数据库不同，MongoDB不通过SQL进行通信。相反，MongoDB使用易于理解的JSON语法来检索和操作数据。整本书都可以用来解释MongoDB，而全面的解释显然超出了本书的范围。现在，你将安装Docker镜像并用虚假数据进行初始化。'
- en: 'Unlike traditional SQL databases, MongoDB is *schema-less*, which means that
    it doesn’t follow a predefined, rigid rule system for organizing table data. This
    explains why you’ll see only `insert` commands in [Listing 7-1](ch07.xhtml#ch7list1)
    without any schema definitions. First, install the MongoDB Docker image with the
    following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的SQL数据库不同，MongoDB是*无模式的*，这意味着它不遵循预定义的、僵化的规则系统来组织表数据。这也解释了为什么你在[清单 7-1](ch07.xhtml#ch7list1)中只会看到`insert`命令，而没有任何模式定义。首先，使用以下命令安装MongoDB
    Docker镜像：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command downloads the image named `mongo` from the Docker repository, spins
    up a new instance named `some-mongo`—the name you give the instance is arbitrary—and
    maps local port `27017` to the container port `27017`. The port mapping is key,
    as it allows us to access the database instance directly from our operating system.
    Without it, it would be inaccessible.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令从Docker仓库下载名为`mongo`的镜像，启动一个名为`some-mongo`的新实例——你给实例起的名字是随意的——并将本地端口`27017`映射到容器端口`27017`。端口映射非常关键，因为它允许我们直接从操作系统访问数据库实例。如果没有这个映射，将无法访问。
- en: 'Check that the container started automatically by listing all the running containers:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过列出所有正在运行的容器，检查容器是否已自动启动：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the event your container doesn’t start automatically, run the following
    command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的容器没有自动启动，请运行以下命令：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `start` command should get the container going.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`命令应该可以启动容器。'
- en: 'Once your container starts, connect to the MongoDB instance by using the `run`
    command—passing it the MongoDB client; that way, you can interact with the database
    to seed data:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦容器启动，使用`run`命令连接到MongoDB实例——传递MongoDB客户端，这样你就可以与数据库交互来初始化数据：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This magical command runs a disposable, second Docker container that has the
    MongoDB client binary installed—so you don’t have to install the binary on your
    host operating system—and uses it to connect to the `some-mongo` Docker container’s
    MongoDB instance. In this example, you’re connecting to a database named `test`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个神奇的命令运行了一个临时的第二个Docker容器，该容器已安装MongoDB客户端二进制文件——因此你不必在宿主操作系统上安装该二进制文件——并使用它连接到`some-mongo`
    Docker容器的MongoDB实例。在这个例子中，你将连接到一个名为`test`的数据库。
- en: In [Listing 7-1](ch07.xhtml#ch7list1), you insert an array of documents into
    the `transactions` collection. (All the code listings at the root location of
    / exist under the provided github repo *[https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)*.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 7-1](ch07.xhtml#ch7list1)中，你将一组文档插入到`transactions`集合中。（所有位于根目录下的代码清单都存在于提供的github仓库*
    [https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)* 中。）
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 7-1: Inserting transactions into a MongoDB collection (*[/ch-7/db/seed-mongo.js](https://github.com/blackhat-go/bhg/blob/master/ch-7/db/seed-mongo.js)*)*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-1：将事务插入到MongoDB集合中 (*[/ch-7/db/seed-mongo.js](https://github.com/blackhat-go/bhg/blob/master/ch-7/db/seed-mongo.js)*)*'
- en: That’s it! You’ve now created your MongoDB database instance and seeded it with
    a `transactions` collection that contains three fake documents for querying. You’ll
    get to the querying part in a bit, but first, you should know how to install and
    seed traditional SQL databases.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你现在已经创建了MongoDB数据库实例，并使用包含三条虚假文档的`transactions`集合进行了初始化，供查询使用。你稍后会进行查询部分，但首先，你应该了解如何安装和初始化传统的SQL数据库。
- en: Installing and Seeding PostgreSQL and MySQL Databases
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装和初始化 PostgreSQL 和 MySQL 数据库
- en: '*PostgreSQL* (also called *Postgres*) and *MySQL* are probably the two most
    common, well-known, enterprise-quality, open source relational database management
    systems, and official Docker images exist for both. Because of their similarity
    and the general overlap in their installation steps, we batched together installation
    instructions for both here.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*PostgreSQL*（也叫*Postgres*）和*MySQL*可能是最常见、最知名的企业级开源关系型数据库管理系统，并且它们都有官方的 Docker
    镜像。由于它们的相似性以及安装步骤的一般重叠，我们将两者的安装步骤集中在一起进行说明。'
- en: 'First, much in the same way as for the MongoDB example in the previous section,
    download and run the appropriate Docker image:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，像之前 MongoDB 示例中的操作一样，下载并运行相应的 Docker 镜像：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After your containers are built, confirm they are running, and if they aren’t,
    you can start them via the docker start name command.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器构建完成后，确认它们是否正在运行。如果没有运行，可以通过 `docker start name` 命令启动它们。
- en: Next, you can connect to the containers from the appropriate client—again, using
    the Docker image to prevent installing any additional files on the host—and proceed
    to create and seed the database. In [Listing 7-2](ch07.xhtml#ch7list2), you can
    see the MySQL logic.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以通过适当的客户端连接到容器——再次使用 Docker 镜像以避免在主机上安装额外的文件——并继续创建和填充数据库。在 [清单 7-2](ch07.xhtml#ch7list2)
    中，你可以看到 MySQL 的逻辑。
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 7-2: Creating and initializing a MySQL database*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-2：创建和初始化 MySQL 数据库*'
- en: The listing, like the one that follows, starts a disposable Docker shell that
    executes the appropriate database client binary. It creates and connects to the
    database named `store` and then creates a table named `transactions`. The two
    listings are identical, with the exception that they are tailored to different
    database systems.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 该清单与接下来的清单一样，启动一个一次性 Docker shell，并执行适当的数据库客户端二进制文件。它创建并连接到名为 `store` 的数据库，然后创建一个名为
    `transactions` 的表。这两个清单是相同的，唯一的区别是它们分别针对不同的数据库系统进行定制。
- en: In [Listing 7-3](ch07.xhtml#ch7list3), you can see the Postgres logic, which
    differs slightly in syntax from MySQL.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 7-3](ch07.xhtml#ch7list3) 中，你可以看到 Postgres 的逻辑，它在语法上与 MySQL 稍有不同。
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 7-3: Creating and initializing a Postgres database*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-3：创建和初始化 Postgres 数据库*'
- en: In both MySQL and Postgres, the syntax is identical for inserting your transactions.
    For example, in [Listing 7-4](ch07.xhtml#ch7list4), you can see how to insert
    three documents into a MySQL `transactions` collection.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MySQL 和 Postgres 中，插入事务的语法是相同的。例如，在 [清单 7-4](ch07.xhtml#ch7list4) 中，你可以看到如何将三个文档插入到
    MySQL `transactions` 集合中。
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 7-4: Inserting transactions into MySQL databases (*[/ch-7/db/seed-pg-mysql.sql](https://github.com/blackhat-go/bhg/blob/master/ch-7/db/seed-pg-mysql.sql)*)*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-4：将事务插入 MySQL 数据库 (*[/ch-7/db/seed-pg-mysql.sql](https://github.com/blackhat-go/bhg/blob/master/ch-7/db/seed-pg-mysql.sql)*)*'
- en: Try inserting the same three documents into your Postgres database.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将相同的三个文档插入到你的 Postgres 数据库中。
- en: Installing and Seeding Microsoft SQL Server Databases
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装和初始化 Microsoft SQL Server 数据库
- en: 'In 2016, Microsoft began making major moves to open-source some of its core
    technologies. One of those technologies was Microsoft SQL (MSSQL) Server. It feels
    pertinent to highlight this information while demonstrating what, for so long,
    wasn’t possible—that is, installing MSSQL Server on a Linux operating system.
    Better yet, there’s a Docker image for it, which you can install with the following
    command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 2016 年，微软开始大力推动开源一些核心技术，其中之一就是 Microsoft SQL (MSSQL) Server。值得一提的是，在展示这些曾经不可能做到的操作时，尤其是在
    Linux 操作系统上安装 MSSQL Server 更显得重要。更棒的是，它有一个 Docker 镜像，你可以通过以下命令安装它：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That command is similar to the others you ran in the previous two sections,
    but per the documentation, the `SA_PASSWORD` value needs to be complex—a combination
    of uppercase letters, lowercase letters, numbers, and special characters—or you
    won’t be able to authenticate to it. Since this is just a test instance, the preceding
    value is trivial but minimally meets those requirements—just as we see on enterprise
    networks all the time!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令与前两节中运行的命令类似，但根据文档要求，`SA_PASSWORD` 的值必须复杂——即包含大写字母、小写字母、数字和特殊字符——否则你将无法进行身份验证。由于这是一个测试实例，前面的值只是满足了这些基本要求——这也是我们在企业网络中经常看到的情况！
- en: With the image installed, start the container, create the schema, and seed the
    database, as in [Listing 7-5](ch07.xhtml#ch7list5).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完镜像后，启动容器，创建架构，并填充数据库，参见 [清单 7-5](ch07.xhtml#ch7list5)。
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 7-5: Creating and seeding an MSSQL database*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-5：创建并填充 MSSQL 数据库*'
- en: The previous listing replicates the logic we demonstrated for MySQL and Postgres
    earlier. It uses Docker to connect to the service, creates and connects to the
    `store` database, and creates and seeds a `transactions` table. We’re presenting
    it separately from the other SQL databases because it has some MSSQL-specific
    syntax.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例复现了我们之前在 MySQL 和 Postgres 中演示的逻辑。它使用 Docker 连接到服务，创建并连接到 `store` 数据库，并创建并填充
    `transactions` 表。我们将其与其他 SQL 数据库分开呈现，因为它有一些 MSSQL 特定的语法。
- en: Connecting and Querying Databases in Go
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Go 中连接并查询数据库
- en: Now that you have a variety of test databases to work with, you can build the
    logic to connect to and query those databases from a Go client. We’ve divided
    this discussion into two topics—one for MongoDB and one for traditional SQL databases.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有多种测试数据库可以使用，你可以构建逻辑来从 Go 客户端连接并查询这些数据库。我们将此讨论分为两个主题——一个是 MongoDB，一个是传统的
    SQL 数据库。
- en: Querying MongoDB
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查询 MongoDB
- en: Despite having an excellent standard SQL package, Go doesn’t maintain a similar
    package for interacting with NoSQL databases. Instead you’ll need to rely on third-party
    packages to facilitate this interaction. Rather than inspect the implementation
    of each third-party package, we’ll focus purely on MongoDB. We’ll use the `mgo`
    (pronounce *mango*) DB driver for this.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Go 拥有一个优秀的标准 SQL 包，但它并没有维护一个类似的包来与 NoSQL 数据库进行交互。相反，你需要依赖第三方包来促进这种交互。我们将不检查每个第三方包的实现，而是专注于
    MongoDB。我们将使用 `mgo`（发音为 *mango*）数据库驱动来进行操作。
- en: 'Start by installing the `mgo` driver with the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用以下命令安装 `mgo` 驱动：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can now establish connectivity and query your `store` collection (the equivalent
    of a table), which requires even less code than the SQL sample code we’ll create
    later (see [Listing 7-6](ch07.xhtml#ch7list6)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以建立连接并查询你的 `store` 集合（相当于表），这比我们稍后将创建的 SQL 示例代码所需的代码还要少（见 [示例 7-6](ch07.xhtml#ch7list6)）。
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 7-6: Connecting to and querying a MongoDB database (*[/ch-7/db/mongo-connect/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-7/db/mongo-connect/main.go)*)*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-6：连接并查询 MongoDB 数据库 (*[/ch-7/db/mongo-connect/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-7/db/mongo-connect/main.go)*)*'
- en: First, you define a type, `Transaction`, which will represent a single document
    from your `store` collection ❶. The internal mechanism for data representation
    in MongoDB is binary JSON. For this reason, use tagging to define any marshaling
    directives. In this case, you’re using tagging to explicitly define the element
    names to be used in the binary JSON data.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义一个类型 `Transaction`，它将表示来自 `store` 集合的单个文档 ❶。MongoDB 中的数据表示机制是二进制 JSON。因此，使用标记来定义任何序列化指令。在这种情况下，你使用标记显式定义要在二进制
    JSON 数据中使用的元素名称。
- en: 'In your `main()` function ❷, call `mgo.Dial()` to create a session by establishing
    a connection to your database, testing to make sure no errors occurred, and deferring
    a call to close the session. You then use the `session` variable to query the
    `store` database ❸, retrieving all the records from the `transactions` collection.
    You store the results in a `Transaction` slice, named `results`. Under the covers,
    your structure tags are used to unmarshal the binary JSON to your defined type.
    Finally, loop over your result set and print them to the screen ❹. In both this
    case and the SQL sample in the next section, your output should look similar to
    the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `main()` 函数 ❷ 中，调用 `mgo.Dial()` 通过建立与数据库的连接来创建会话，测试以确保没有错误发生，并延迟调用以关闭会话。然后，你使用
    `session` 变量查询 `store` 数据库 ❸，从 `transactions` 集合中检索所有记录。你将结果存储在一个名为 `results`
    的 `Transaction` 切片中。在底层，你的结构标签被用来将二进制 JSON 解组为你定义的类型。最后，循环遍历结果集并将其打印到屏幕上 ❹。在这种情况下和下一节中的
    SQL 示例中，你的输出应类似于以下内容：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Querying SQL Databases
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查询 SQL 数据库
- en: Go contains a standard package, called `database/sql`, that defines an interface
    for interacting with SQL and SQL-like databases. The base implementation automatically
    includes functionality such as connection pooling and transaction support. Database
    drivers adhering to this interface automatically inherit these capabilities and
    are essentially interchangeable, as the API remains consistent between drivers.
    The function calls and implementation in your code are identical whether you’re
    using Postgres, MSSQL, MySQL, or some other driver. This makes it convenient to
    switch backend databases with minimal code change on the client. Of course, the
    drivers can implement database-specific capabilities and use different SQL syntax,
    but the function calls are nearly identical.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Go包含一个标准包，名为`database/sql`，它定义了与SQL及类似SQL的数据库交互的接口。基本实现自动包含了连接池和事务支持等功能。遵循此接口的数据库驱动程序自动继承这些功能，并且基本上是可以互换的，因为API在驱动程序之间保持一致。无论你使用Postgres、MSSQL、MySQL还是其他驱动程序，代码中的函数调用和实现都是相同的。这使得切换后端数据库变得方便，只需要在客户端做最小的代码修改。当然，驱动程序可以实现特定于数据库的功能并使用不同的SQL语法，但函数调用几乎相同。
- en: 'For this reason, we’ll show you how to connect to just one SQL database—MySQL—and
    leave the other SQL databases as an exercise for you. You start by installing
    the driver with the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个原因，我们将展示如何连接到一个SQL数据库——MySQL——并将其他SQL数据库留作练习。你首先通过以下命令安装驱动程序：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then, you can create a basic client that connects to the database and retrieves
    the information from your `transactions` table—using the script in [Listing 7-7](ch07.xhtml#ch7list7).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以创建一个基本客户端，连接到数据库并从你的`transactions`表中检索信息——使用[列表 7-7](ch07.xhtml#ch7list7)中的脚本。
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 7-7: Connecting to and querying a MySQL database (*[/ch-7/db/mysql-connect/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-7/db/mysql-connect/main.go)*)*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-7：连接和查询MySQL数据库（*[/ch-7/db/mysql-connect/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-7/db/mysql-connect/main.go)*)*'
- en: The code begins by importing Go’s `database/sql` package ❶. This allows you
    to utilize Go’s awesome standard SQL library interface to interact with the database.
    You also import your MySQL database driver ❷. The leading underscore indicates
    that it’s imported anonymously, which means its exported types aren’t included,
    but the driver registers itself with the `sql` package so that the MySQL driver
    itself handles the function calls.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先通过导入Go的`database/sql`包❶开始。这使你能够利用Go强大的标准SQL库接口与数据库交互。你还导入了你的MySQL数据库驱动程序❷。前导下划线表示它是匿名导入的，这意味着它的导出类型没有被包含，但驱动程序会将自己注册到`sql`包中，这样MySQL驱动程序本身就能处理函数调用。
- en: Next, you call `sql.Open()` to establish a connection to our database ❸. The
    first parameter specifies which driver should be used—in this case, the driver
    is `mysql`—and the second parameter specifies your connection string. You then
    query your database, passing an SQL statement to select all rows from your `transactions`
    table ❹, and then loop over the rows, subsequently reading the data into your
    variables and printing the values ❺.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你调用`sql.Open()`来建立与我们数据库的连接❸。第一个参数指定应使用哪个驱动程序——在这种情况下，驱动程序是`mysql`——第二个参数指定你的连接字符串。然后，你查询数据库，传递一个SQL语句来选择`transactions`表中的所有行❹，接着遍历这些行，随后将数据读取到你的变量中并打印出值❺。
- en: 'That’s all you need to do to query a MySQL database. Using a different backend
    database requires only the following minor changes to the code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你查询MySQL数据库所需做的全部工作。使用不同的后端数据库只需要对代码做以下小的修改：
- en: Import the correct database driver.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入正确的数据库驱动程序。
- en: Change the parameters passed to `sql.Open()`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改传递给`sql.Open()`的参数。
- en: Tweak the SQL syntax to the flavor required by your backend database.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据你的后端数据库的要求调整SQL语法。
- en: Among the several database drivers available, many are pure Go, while a handful
    of others use `cgo` for some underlying interaction. Check out the list of available
    drivers at *[https://github.com/golang/go/wiki/SQLDrivers/](https://github.com/golang/go/wiki/SQLDrivers/)*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个可用的数据库驱动程序中，许多是纯Go编写的，而少数使用`cgo`进行一些底层交互。查看可用驱动程序的列表，网址是*[https://github.com/golang/go/wiki/SQLDrivers/](https://github.com/golang/go/wiki/SQLDrivers/)。
- en: Building a Database Miner
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建一个数据库挖掘器
- en: In this section, you will create a tool that inspects the database schema (for
    example, column names) to determine whether the data within is worth pilfering.
    For instance, say you want to find passwords, hashes, social security numbers,
    and credit card numbers. Rather than building one monolithic utility that mines
    various backend databases, you’ll create separate utilities—one for each database—and
    implement a defined interface to ensure consistency between the implementations.
    This flexibility may be somewhat overkill for this example, but it gives you the
    opportunity to create reusable and portable code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建一个工具，用来检查数据库架构（例如，列名），以确定其中的数据是否值得盗取。例如，假设你想找出密码、哈希值、社会安全号码和信用卡号码。与其构建一个单一的工具来挖掘各种后端数据库，不如为每个数据库创建独立的工具，并实现一个定义好的接口，以确保不同实现之间的一致性。虽然这个灵活性在本例中可能有些过度，但它给你提供了创建可重用和可移植代码的机会。
- en: The interface should be minimal, consisting of a few basic types and functions,
    and it should require the implementation of a single method to retrieve database
    schema. [Listing 7-8](ch07.xhtml#ch7list8), called *dbminer.go*, defines the database
    miner’s interface.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口应该是简洁的，包含一些基本类型和函数，并且只需要实现一个方法来检索数据库架构。[清单 7-8](ch07.xhtml#ch7list8)，即名为*dbminer.go*的文件，定义了数据库挖掘器的接口。
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 7-8: Database miner implementation (*[/ch-7/db/dbminer/dbminer.go](https://github.com/blackhat-go/bhg/blob/master/ch-7/db/dbminer/dbminer.go)*)*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-8：数据库挖掘器实现（*[/ch-7/db/dbminer/dbminer.go](https://github.com/blackhat-go/bhg/blob/master/ch-7/db/dbminer/dbminer.go)*)*'
- en: The code begins by defining an interface named `DatabaseMiner` ❶. A single method,
    called `GetSchema()`, is required for any types that implement the interface.
    Because each backend database may have specific logic to retrieve the database
    schema, the expectation is that each specific utility can implement the logic
    in a way that’s unique to the backend database and driver in use.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先定义了一个名为`DatabaseMiner`的接口❶。任何实现该接口的类型都需要包含一个名为`GetSchema()`的方法。由于每个后端数据库可能有特定的逻辑来检索数据库架构，预期是每个特定的工具都能以独特的方式实现该逻辑，适配不同的后端数据库和驱动程序。
- en: Next, you define a `Schema` type, which is composed of a few subtypes also defined
    here ❷. You’ll use the `Schema` type to logically represent the database schema—that
    is, databases, tables, and columns. You might have noticed that your `GetSchema()`
    function, within the interface definition, expects implementations to return a
    `*Schema`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你定义了一个`Schema`类型，该类型由几个子类型组成，也在此定义❷。你将使用`Schema`类型来逻辑上表示数据库架构——即数据库、表和列。你可能已经注意到，在接口定义中的`GetSchema()`函数，预期实现返回一个`*Schema`。
- en: Now, you define a single function, called `Search()`, which contains the bulk
    of the logic. The `Search()` function expects a `DatabaseMiner` instance to be
    passed to it during the function call, and stores the miner value in a variable
    named `m` ❸. The function starts by calling `m.GetSchema()` to retrieve the schema
    ❹. The function then loops through the entire schema, searching against a list
    of regular expression (regex) values for column names that match ❺. If it finds
    a match, the database schema and matching field are printed to the screen.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你定义了一个名为`Search()`的单一函数，其中包含大部分逻辑。`Search()`函数在调用时预期传入一个`DatabaseMiner`实例，并将矿工值存储在名为`m`的变量中❸。该函数首先调用`m.GetSchema()`来获取架构❹。然后，函数循环遍历整个架构，搜索与常见的正则表达式（regex）值匹配的列名❺。如果找到匹配项，数据库架构和匹配的字段将被打印到屏幕上。
- en: Lastly, define a function named `getRegex()` ❻. This function compiles regex
    strings by using Go’s `regexp` package and returns a slice of these values. The
    regex list consists of case-insensitive strings that match against common or interesting
    field names such as `ccnum`, `ssn`, and `password`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，定义一个名为`getRegex()`的函数❻。该函数使用Go的`regexp`包编译正则表达式字符串，并返回这些值的切片。正则表达式列表由不区分大小写的字符串组成，用来匹配常见或有趣的字段名称，如`ccnum`、`ssn`和`password`。
- en: With your database miner’s interface in hand, you can create utility-specific
    implementations. Let’s start with the MongoDB database miner.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有了数据库挖掘器接口之后，你可以创建特定工具的实现。让我们从MongoDB数据库挖掘器开始。
- en: Implementing a MongoDB Database Miner
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现MongoDB数据库挖掘器
- en: The MongoDB utility program in [Listing 7-9](ch07.xhtml#ch7list9) implements
    the interface defined in [Listing 7-8](ch07.xhtml#ch7list8) while also integrating
    the database connectivity code you built in [Listing 7-6](ch07.xhtml#ch7list6).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 7-9](ch07.xhtml#ch7list9) 中的 MongoDB 工具程序实现了 [Listing 7-8](ch07.xhtml#ch7list8)
    中定义的接口，并且还集成了你在 [Listing 7-6](ch07.xhtml#ch7list6) 中构建的数据库连接代码。'
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 7-9: Creating a MongoDB database miner (*[/ch-7/db/mongo/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-7/db/mongo/main.go)*)*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 7-9：创建一个 MongoDB 数据库挖掘器 (*[/ch-7/db/mongo/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-7/db/mongo/main.go)*)*'
- en: You start by importing the `dbminer` package that defines your `DatabaseMiner`
    interface ❶. Then you define a `MongoMiner` type that will be used to implement
    the interface ❷. For convenience, you define a `New()` function that creates a
    new instance of your `MongoMiner` type ❸, calling a method named `connect()` that
    establishes a connection to the database ❹. The entirety of this logic essentially
    bootstraps your code, connecting to the database in a fashion similar to that
    discussed in [Listing 7-6](ch07.xhtml#ch7list6).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先通过导入定义 `DatabaseMiner` 接口的 `dbminer` 包 ❶。然后你定义一个 `MongoMiner` 类型，用于实现该接口
    ❷。为了方便起见，你定义了一个 `New()` 函数，它创建一个新的 `MongoMiner` 类型实例 ❸，并调用一个名为 `connect()` 的方法来建立与数据库的连接
    ❹。这段逻辑实际上是初始化你的代码，以类似于 [Listing 7-6](ch07.xhtml#ch7list6) 中讨论的方式连接到数据库。
- en: The most interesting portion of the code is your implementation of the `GetSchema()`
    interface method ❺. Unlike in the previous MongoDB sample code in [Listing 7-6](ch07.xhtml#ch7list6),
    you are now inspecting the MongoDB metadata, first retrieving database names ❻
    and then looping over those databases to retrieve each database’s collection names
    ❼. Lastly, the function retrieves the raw document that, unlike a typical MongoDB
    query, uses lazy unmarshaling ❽. This allows you to explicitly unmarshal the record
    into a generic structure so that you can inspect field names ❾. If not for lazy
    unmarshaling, you would have to define an explicit type, likely using `bson` tag
    attributes, in order to instruct your code how to unmarshal the data into a struct
    you defined. In this case, you don’t know (or care) about the field types or structure—you
    just want the field names (not the data)—so this is how you can unmarshal structured
    data without needing to know the structure of that data beforehand.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中最有趣的部分是你实现的 `GetSchema()` 接口方法 ❺。与 [Listing 7-6](ch07.xhtml#ch7list6) 中的
    MongoDB 示例代码不同，现在你正在检查 MongoDB 元数据，首先获取数据库名称 ❻，然后遍历这些数据库以获取每个数据库的集合名称 ❼。最后，函数检索原始文档，不同于典型的
    MongoDB 查询，它使用了懒加载解组 ❽。这使得你可以显式地将记录解组到一个通用结构中，从而检查字段名称 ❾。如果没有懒加载解组，你将不得不定义一个显式类型，可能使用
    `bson` 标签属性，来指示代码如何将数据解组到你定义的结构体中。在这种情况下，你不知道（也不关心）字段的类型或结构——你只需要字段名称（而非数据）——因此你可以在不知道数据结构的情况下解组结构化数据。
- en: Your `main()` function expects the IP address of your MongoDB instance as its
    lone argument, calls your `New()` function to bootstrap everything, and then calls
    `dbminer.Search()`, passing to it your `MongoMiner` instance ❿. Recall that `dbminer.Search()`
    calls `GetSchema()` on the received `DatabaseMiner` instance; this calls your
    `MongoMiner` implementation of the function, which results in the creation of
    `dbminer.Schema` that is then searched against the regex list in [Listing 7-8](ch07.xhtml#ch7list8).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `main()` 函数期望接收一个 MongoDB 实例的 IP 地址作为唯一参数，调用你的 `New()` 函数来初始化所有内容，然后调用 `dbminer.Search()`，并将你的
    `MongoMiner` 实例传递给它 ❿。回想一下，`dbminer.Search()` 调用接收到的 `DatabaseMiner` 实例上的 `GetSchema()`；这会调用你在
    `MongoMiner` 中实现的函数，进而创建 `dbminer.Schema`，然后在 [Listing 7-8](ch07.xhtml#ch7list8)
    中的正则表达式列表中进行搜索。
- en: 'When you run your utility, you are blessed with the following output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行你的工具时，你将看到以下输出：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You found a match! It may not look pretty, but it gets the job done—successfully
    locating the database collection that has a field named `ccnum`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你找到匹配项了！它可能看起来不太好看，但它能完成任务——成功地定位到包含名为 `ccnum` 字段的数据库集合。
- en: With your MongoDB implementation built, in the next section, you’ll do the same
    for a MySQL backend database.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在你构建了 MongoDB 实现后，接下来的部分，你将为 MySQL 后端数据库做同样的事情。
- en: Implementing a MySQL Database Miner
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现一个 MySQL 数据库挖掘器
- en: 'To make your MySQL implementation work, you’ll inspect the `information_schema.columns`
    table. This table maintains metadata about all the databases and their structures,
    including table and column names. To make the data the simplest to consume, use
    the following SQL query, which removes information about some of the built-in
    MySQL databases that are of no consequence to your pillaging efforts:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的 MySQL 实现正常工作，你需要检查`information_schema.columns`表。该表维护关于所有数据库及其结构的元数据，包括表名和列名。为了使数据更容易处理，可以使用以下
    SQL 查询，去除一些与你的收集工作无关的内置 MySQL 数据库的信息：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The query produces results resembling the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询产生的结果类似于以下内容：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Although using that query to retrieve schema information is pretty straightforward,
    the complexity in your code comes from logically trying to differentiate and categorize
    each row while defining your `GetSchema()` function. For example, consecutive
    rows of output may or may not belong to the same database or table, so associating
    the rows to the correct `dbminer.Database` and `dbminer.Table` instances becomes
    a somewhat tricky endeavor.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用该查询来检索模式信息相对简单，但代码中的复杂性来自于在定义`GetSchema()`函数时，如何逻辑上区分和分类每一行。例如，连续的输出行可能属于同一个数据库或表，也可能不属于，因此将这些行关联到正确的`dbminer.Database`和`dbminer.Table`实例是一个相对棘手的任务。
- en: '[Listing 7-10](ch07.xhtml#ch7list10) defines the implementation.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-10](ch07.xhtml#ch7list10)定义了该实现。'
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 7-10: Creating a MySQL database miner (*[/ch-7/db/mysql/main.go/](https://github.com/blackhat-go/bhg/blob/master/ch-7/db/mysql/main.go)*)*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-10：创建一个 MySQL 数据库矿工 (*[/ch-7/db/mysql/main.go/](https://github.com/blackhat-go/bhg/blob/master/ch-7/db/mysql/main.go)*)*'
- en: A quick glance at the code and you’ll probably realize that much of it is very,
    very similar to the MongoDB example in the preceding section. As a matter of fact,
    the `main()` function is identical.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 快速浏览代码，你可能会发现它和前一节中的 MongoDB 示例非常相似。事实上，`main()`函数是完全相同的。
- en: The bootstrapping functions are also similar—you just change the logic to interact
    with MySQL rather than MongoDB. Notice that this logic connects to your `information_schema`
    database ❶, so that you can inspect the database schema.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 引导函数也类似——你只需改变逻辑以与 MySQL 而非 MongoDB 进行交互。注意，这段逻辑连接到了你的`information_schema`数据库
    ❶，以便你检查数据库的模式。
- en: Much of the code’s complexity resides within the `GetSchema()` implementation.
    Although you are able to retrieve the schema information by using a single database
    query ❷, you then have to loop over the results ❸, inspecting each row so you
    can determine what databases exist, what tables exist in each database, and what
    columns exist for each table. Unlike in your MongoDB implementation, you don’t
    have the luxury of JSON/BSON with attribute tags to marshal and unmarshal data
    into complex structures; you maintain variables to track the information in your
    current row and compare it with the data from the previous row, in order to determine
    whether you’ve encountered a new database or table. Not the most elegant solution,
    but it gets the job done.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的复杂性大部分体现在`GetSchema()`的实现中。虽然你能够通过使用单个数据库查询 ❷ 来检索模式信息，但之后你需要遍历结果 ❸，检查每一行，以便确定存在哪些数据库、每个数据库中有哪些表以及每个表中有哪些列。与
    MongoDB 实现不同的是，你没有 JSON/BSON 属性标签来将数据编组和解组到复杂的结构中；你需要维护变量来跟踪当前行中的信息，并将其与上一行的数据进行比较，以确定是否遇到了新的数据库或表。这不是最优雅的解决方案，但它能完成工作。
- en: Next, you check whether the database name for your current row differs from
    your previous row ❹. If so, you create a new `miner.Database` instance. If it
    isn’t your first iteration of the loop, add the table and database to your `miner.Schema`
    instance. You use similar logic to track and add `miner.Table` instances to your
    current `miner.Database` ❺. Lastly, add each of the columns to our `miner.Table`
    ❻.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要检查当前行的数据库名称是否与上一行不同 ❹。如果不同，你就创建一个新的`miner.Database`实例。如果这不是你循环的第一次迭代，就将表和数据库添加到你的`miner.Schema`实例中。你可以使用类似的逻辑来跟踪并将`miner.Table`实例添加到当前的`miner.Database`
    ❺。最后，将每一列添加到我们的`miner.Table` ❻。
- en: 'Now, run the program against your Docker MySQL instance to confirm that it
    works properly, as shown here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行程序以检查它是否能够正常工作，方法是对你的 Docker MySQL 实例进行测试，如下所示：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The output should be almost indiscernible from your MongoDB output. This is
    because your `dbminer.Schema` isn’t producing any output—the `dbminer.Search()`
    function is. This is the power of using interfaces. You can have specific implementations
    of key features, yet still utilize a single, standard function to process your
    data in a predictable, usable manner.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该几乎无法与您的 MongoDB 输出区分开。这是因为您的`dbminer.Schema`并没有产生任何输出——是`dbminer.Search()`函数产生了输出。这就是使用接口的强大之处。您可以为关键特性提供具体的实现，同时仍然利用单一、标准的函数以可预测、可用的方式处理您的数据。
- en: In the next section, you’ll step away from databases and instead focus on pillaging
    filesystems.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，您将暂时离开数据库，转而专注于掠夺文件系统。
- en: Pillaging a Filesystem
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 掠夺文件系统
- en: In this section, you’ll build a utility that walks a user-supplied filesystem
    path recursively, matching against a list of interesting filenames that you would
    deem useful as part of a post-exploitation exercise. These files may contain,
    among other things, personally identifiable information, usernames, passwords,
    system logins, and password database files.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，您将构建一个实用工具，它会递归地遍历用户提供的文件系统路径，并与您认为在后期利用练习中有用的有趣文件名列表进行匹配。这些文件可能包含个人身份信息、用户名、密码、系统登录信息和密码数据库文件等内容。
- en: The utility looks specifically at filenames rather than file contents, and the
    script is made much simpler by the fact that Go contains standard functionality
    in its `path/filepath` package that you can use to easily walk a directory structure.
    You can see the utility in [Listing 7-11](ch07.xhtml#ch7list11).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 该实用工具专门关注文件名，而不是文件内容，且由于 Go 在其`path/filepath`包中包含了标准功能，使得您可以轻松地遍历目录结构，脚本因此大大简化。您可以在[清单
    7-11](ch07.xhtml#ch7list11)中看到该实用工具。
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 7-11: Walking and searching a filesystem (*[/ch-7/filesystem/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-7/filesystem/main.go)*)*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-11：遍历和搜索文件系统 (*[/ch-7/filesystem/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-7/filesystem/main.go)*)*'
- en: In contrast to your database-mining implementations, the filesystem pillaging
    setup and logic might seem a little too simple. Similar to the way you created
    your database implementations, you define a regex list for identifying interesting
    filenames ❶. To keep the code minimal, we limited the list to just a handful of
    items, but you can expand the list to accommodate more practical usage.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与您的数据库挖掘实现相比，文件系统掠夺的设置和逻辑看起来可能显得有些简单。类似于您创建数据库实现的方式，您定义了一个用于识别有趣文件名的正则表达式列表
    ❶。为了保持代码简洁，我们将列表限制为仅包含少数几个项，但您可以扩展列表以适应更多实际使用场景。
- en: Next, you define a function, named `walkFn()`, that accepts a file path and
    some additional parameters ❷. The function loops over your regular expression
    list and checks for matches ❸, displaying them to stdout. The `walkFn()` function
    ❹ is used in the `main()` function, and passed as a parameter to `filepath.Walk()`.
    The `Walk()` function expects two parameters—a root path and a function (in this
    case, `walkFn()`)—and recursively walks the directory structure starting at the
    value supplied as the root path, calling `walkFn()` for every directory and file
    it encounters.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您定义一个名为`walkFn()`的函数，该函数接受一个文件路径和一些附加参数 ❷。该函数会遍历您的正则表达式列表并检查匹配项 ❸，并将匹配项显示到标准输出。`walkFn()`函数
    ❹ 在`main()`函数中使用，并作为参数传递给`filepath.Walk()`。`Walk()`函数期望接收两个参数——根路径和一个函数（在这种情况下是`walkFn()`）——并从提供的根路径开始递归遍历目录结构，对于每一个遇到的目录和文件都会调用`walkFn()`。
- en: 'With your utility complete, navigate to your desktop and create the following
    directory structure:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 完成实用工具后，导航到您的桌面并创建以下目录结构：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Running your utility against this same `targetpath` directory produces the
    following output, confirming that your code works splendidly:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一`targetpath`目录下运行您的实用工具，产生以下输出，确认您的代码运行得非常顺利：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That’s just about all there is to it. You can improve the sample code through
    the inclusion of additional or more-specific regular expressions. Further, we
    encourage you to improve the code by applying the regular expression check only
    to filenames, not directories. Another enhancement we encourage you to make is
    to locate and flag specific files with a recent modified or access time. This
    metadata can lead you to more important content, including files used as part
    of critical business processes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这差不多就是全部内容了。你可以通过加入更多或更具体的正则表达式来改进示例代码。此外，我们建议你改进代码，将正则表达式检查仅应用于文件名，而不是目录。另一个我们建议的改进是定位并标记具有最近修改或访问时间的特定文件。这些元数据可以帮助你找到更重要的内容，包括作为关键业务流程一部分的文件。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we dove into database interactions and filesystem walking,
    using both Go’s native packages and third-party libraries to inspect database
    metadata and filenames. For an attacker, these resources often contain valuable
    information, and we created various utilities that allow us to search for this
    juicy information.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们深入探讨了数据库交互和文件系统遍历，使用了Go语言的本地包和第三方库来检查数据库元数据和文件名。对于攻击者来说，这些资源通常包含宝贵的信息，我们创建了各种工具，允许我们搜索这些有价值的信息。
- en: In the next chapter, you’ll take a look at practical packet processing. Specifically,
    you’ll learn how to sniff and manipulate network packets.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习实际的包处理。具体来说，你将学习如何嗅探和操控网络数据包。
