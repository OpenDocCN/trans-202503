- en: '**7 Cellular Automata**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7个细胞自动机**'
- en: '*Individually, we are one drop. Together, we are an ocean.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*单独来看，我们是一个水滴。一起，我们就是一片海洋。*'
- en: —Ryunosuke Satoro
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: —— 佐藤龙之介
- en: '![Image](../images/pg399_Image_610.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/pg399_Image_610.jpg)'
- en: '**Kente cloth (photo by ZSM)**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**肯特布（照片由ZSM提供）**'
- en: Originating from the Akan people of Ghana, kente cloth is a woven fabric celebrated
    for its vibrant colors and intricate patterns. Woven in narrow strips, each design
    is unique, and when joined, the strips form a tapestry of complex and emergent
    patterns that tell a story or carry a message. The image shows three typical Ewe
    kente stripes, highlighting the diverse weaving traditions that reflect the rich
    cultural tapestry of Ghana.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 起源于加纳的阿干族，肯特布是一种因其鲜艳的色彩和复杂的图案而备受赞誉的织物。布料由狭窄的条纹织成，每种设计都是独一无二的，当这些条纹拼接在一起时，便形成了一幅复杂且不断变化的挂毯，讲述一个故事或传递信息。图像展示了三条典型的埃维肯特布条纹，突出了反映加纳丰富文化图景的多样编织传统。
- en: In [Chapter 5](ch05.xhtml#ch05), I defined a complex system as a network of
    elements with short-range relationships, operating in parallel, that exhibit emergent
    behavior. I created a flocking simulation to demonstrate how a complex system
    adds up to more than the sum of its parts. In this chapter, I’m going to turn
    to developing other complex systems known as cellular automata.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.xhtml#ch05)中，我定义了复杂系统为一组具有短程关系、并行运作的元素网络，这些元素表现出涌现行为。我创建了一个群体行为模拟，展示了复杂系统如何比单纯的部分之和更为复杂。在本章中，我将转向开发另一类复杂系统，即细胞自动机。
- en: 'In some respects, this shift may seem like a step backward. No longer will
    the individual elements of my systems be members of a physics world, driven by
    forces and vectors to move around the canvas. Instead, I’ll build systems out
    of the simplest digital element possible: a single bit. This bit is called a **cell**,
    and its value (0 or 1) is called its **state**. Working with such simple elements
    will help reveal how complex systems operate, and will offer an opportunity to
    elaborate on some programming techniques that apply to code-based projects. Building
    cellular automata will also set the stage for the rest of the book, where I’ll
    increasingly focus on systems and algorithms rather than vectors and motion—albeit
    systems and algorithms that I can and will apply to moving bodies.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从某些方面来看，这一转变可能似乎是一步倒退。我的系统中的个体元素将不再是物理世界的成员，不再受到力和向量的驱动在画布上移动。相反，我将从最简单的数字元素——一个比特开始构建系统。这个比特被称为**细胞**，它的值（0或1）被称为它的**状态**。使用这样简单的元素有助于揭示复杂系统的运作方式，并为阐述一些适用于基于代码的项目的编程技巧提供机会。构建细胞自动机还为本书的其余部分奠定了基础，我将在后续章节中更多地关注系统和算法，而不是向量和运动——尽管这些系统和算法我可以并且会应用于运动物体。
- en: '**What Is a Cellular Automaton?**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**什么是细胞自动机？**'
- en: 'A **cellular automaton** (**cellular automata** plural, or **CA** for short)
    is a model of a system of cell objects with the following characteristics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**细胞自动机**（复数形式为**细胞自动机**，简称**CA**）是一个由细胞对象组成的系统模型，具有以下特点：'
- en: The cells live on a **grid**. (I’ll include examples in both one and two dimensions
    in this chapter, though a CA can exist in any finite number of dimensions.)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 细胞生活在一个**网格**中。（本章中我会提供一维和二维的示例，尽管细胞自动机可以存在于任何有限维度的空间中。）
- en: Each cell has a **state**, though a cell’s state can vary over time. The number
    of possible states is typically finite. The simplest example has the two possibilities
    of 1 and 0 (otherwise referred to as *on* and *off*, or *alive* and *dead*).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个细胞都有一个**状态**，尽管细胞的状态可以随时间变化。状态的可能数量通常是有限的。最简单的例子只有1和0两种可能（也称为*开*和*关*，或*生*与*死*）。
- en: Each cell has a **neighborhood**. This can be defined in any number of ways,
    but it’s typically all the cells adjacent to that cell.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个细胞都有一个**邻域**。邻域可以通过多种方式定义，但通常是指与该细胞相邻的所有细胞。
- en: It’s important to stress that the cells in a CA don’t refer to biological cells
    (although you’ll see how CA can mimic lifelike behavior and have applications
    in biology). Instead, they simply represent discrete units in a grid, similar
    to the cells in a spreadsheet (as in Microsoft Ex*cel*). [Figure 7.1](ch07.xhtml#ch7fig1)
    illustrates a CA and its various characteristics.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，细胞自动机中的细胞并不指生物学上的细胞（尽管你将看到细胞自动机如何模仿生物行为，并在生物学中有所应用）。相反，它们仅仅代表网格中的离散单元，类似于电子表格中的单元格（如Microsoft
    Ex*cel*）。[图 7.1](ch07.xhtml#ch7fig1)展示了一个细胞自动机及其各个特点。
- en: The second CA feature I listed—the idea that a cell’s state can vary over time—is
    an important new development. So far in this book, the objects (movers, particles,
    vehicles, boids, bodies) have generally existed in only one state. They might
    have moved with sophisticated behaviors and physics, but ultimately they remained
    the same type of object over the course of their digital lifetime. I’ve alluded
    to the possibility that these entities can change over time (for example, the
    weights of steering “desires” can vary), but I haven’t fully put this into practice.
    Now, with CA, you’ll see how an object’s state can change based on a system of
    rules.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我列出的第二个元胞自动机特性——即单元格的状态可以随着时间变化——是一个重要的新发展。到目前为止，在本书中，物体（如移动物体、粒子、车辆、群体、物体）通常只存在于一种状态下。它们可能具有复杂的行为和物理特性，但最终它们在其数字生命周期中保持相同的物体类型。我曾提到这些实体可以随着时间变化（例如，转向“愿望”的权重可以变化），但我尚未完全实践这一点。现在，通过元胞自动机，你将看到一个物体的状态如何根据一套规则发生变化。
- en: '![Image](../images/pg401_Image_611.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg401_Image_611.jpg)'
- en: 'Figure 7.1: A 2D grid of cells, each with a state of *on* or *off*. A neighborhood
    is a subsection of the large grid, usually consisting of all the cells adjacent
    to a given cell (circled).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：一个 2D 网格的单元格，每个单元格的状态为*开*或*关*。邻域是大网格的一个子区域，通常由所有与给定单元格相邻的单元格组成（以圆圈标出）。
- en: 'The development of CA systems is typically attributed to Stanisław Ulam and
    John von Neumann, who were both researchers at the Los Alamos National Laboratory
    in New Mexico in the 1940s. Ulam was studying the growth of crystals, and von
    Neumann was imagining a world of self-replicating robots. You read that right:
    robots that can build copies of themselves.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 元胞自动机系统的发展通常归功于斯坦尼斯瓦夫·乌拉姆和约翰·冯·诺依曼，他们都是20世纪40年代新墨西哥州洛斯阿拉莫斯国家实验室的研究人员。乌拉姆研究的是晶体的生长，而冯·诺依曼则设想了一个自我复制的机器人世界。没错，你没有看错：机器人可以建造出自己的复制品。
- en: 'Von Neumann’s original cells had 29 possible states, so perhaps the idea of
    self-replicating robots is a bit too complex of a starting point. Instead, imagine
    a row of dominoes; each domino can be in one of two states: standing upright (1)
    or knocked down (0). Just as dominoes react to their neighboring dominoes, the
    behavior of each cell in a CA is influenced by the states of its neighboring cells.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 冯·诺依曼最初的单元格有29种可能的状态，因此自我复制机器人这一想法可能是一个过于复杂的起点。相反，想象一排多米诺骨牌；每个骨牌可以处于两种状态之一：竖立（1）或倒下（0）。正如多米诺骨牌会受到相邻骨牌的影响一样，元胞自动机中每个单元格的行为也会受到其邻近单元格状态的影响。
- en: This chapter explores how even the most basic rules of something like dominoes
    can lead to a wide array of intricate patterns and behaviors, similar to natural
    processes like biological reproduction and evolution. Von Neumann’s work in self-replication
    and CA is conceptually similar to what’s probably the most famous CA, the Game
    of Life, which I’ll discuss in detail later in the chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了即使是像多米诺骨牌这样最基本的规则，也能引发一系列复杂的模式和行为，类似于自然过程中的生物繁殖和进化。冯·诺依曼在自我复制和元胞自动机方面的工作在概念上与可能是最著名的元胞自动机——生命游戏相似，我将在本章稍后详细讨论。
- en: 'Perhaps the most significant (and lengthy) scientific work studying CA arrived
    in 2002: Stephen Wolfram’s 1,280-page *A New Kind of Science* (*[https://www.wolframscience.com/nks](https://www.wolframscience.com/nks)*).
    Available in its entirety for free online, Wolfram’s book discusses how CA aren’t
    simply neat tricks but are relevant to the study of biology, chemistry, physics,
    and all branches of science. In a moment, I’ll turn to building a simulation of
    Wolfram’s work, although I’ll barely scratch the surface of the theories he outlines—my
    focus will be on the code implementation, not the philosophical implications.
    If the examples spark your curiosity, you’ll find plenty more to read about in
    Wolfram’s book, as well as in his ongoing research at the Wolfram Physics Project
    (*[https://www.wolframphysics.org](https://www.wolframphysics.org)*).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最重要（而且最冗长）的关于元胞自动机的科学工作出现在2002年：斯蒂芬·沃尔夫勒姆的1280页著作《新科学的种类》（*[https://www.wolframscience.com/nks](https://www.wolframscience.com/nks)*）。这本书可以在网上完全免费阅读，沃尔夫勒姆的书讨论了元胞自动机不仅仅是一些巧妙的技巧，而是与生物学、化学、物理学以及所有科学分支的研究相关的。稍后，我将转向构建沃尔夫勒姆工作的模拟，尽管我仅仅触及了他所阐述的理论的皮毛——我的重点将放在代码实现上，而非哲学含义。如果这些例子激发了你的好奇心，你会在沃尔夫勒姆的书中以及他在沃尔夫勒姆物理学项目中的持续研究中找到更多值得阅读的内容（*[https://www.wolframphysics.org](https://www.wolframphysics.org)*）。
- en: '**Elementary Cellular Automata**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**基础元胞自动机**'
- en: 'What’s the simplest CA you can imagine? For Wolfram, an elementary CA has three
    key elements:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想象的最简单的CA是什么？对于沃尔夫勒姆来说，一个基本的CA有三个关键元素：
- en: Grid
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格
- en: States
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态
- en: Neighborhood
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邻域
- en: 'The simplest grid would be 1D: a line of cells ([Figure 7.2](ch07.xhtml#ch7fig2)).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的网格是1D：一行单元（[图7.2](ch07.xhtml#ch7fig2)）。
- en: '![Image](../images/pg402_Image_612.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg402_Image_612.jpg)'
- en: 'Figure 7.2: A 1D line of cells'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：一行1D单元
- en: 'The simplest set of states (beyond having only one state) would be two states:
    0 or 1 ([Figure 7.3](ch07.xhtml#ch7fig3)). Perhaps the initial states are set
    randomly.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的状态集合（除了只有一个状态）是两种状态：0或1（[图7.3](ch07.xhtml#ch7fig3)）。也许初始状态是随机设置的。
- en: '![Image](../images/pg402_Image_613.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg402_Image_613.jpg)'
- en: 'Figure 7.3: A 1D line of cells marked with state 0 or 1\. What familiar programming
    data structure could represent this sequence?'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：一行1D单元，标记为状态0或1。哪个熟悉的编程数据结构可以表示这个序列？
- en: 'The simplest neighborhood in one dimension for any given cell would be the
    cell itself and its two adjacent neighbors: one to the left and one to the right
    ([Figure 7.4](ch07.xhtml#ch7fig4)). I’ll have to decide what I want to do with
    the cells on the left and right edges, since those have only one neighbor each,
    but I can sort out this detail later.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何给定单元，一维的最简单邻域是单元本身以及它的两个相邻邻居：一个在左边，一个在右边（[图7.4](ch07.xhtml#ch7fig4)）。我必须决定如何处理左右边缘的单元，因为这些单元只有一个邻居，但我可以稍后再处理这个细节。
- en: '![Image](../images/pg402_Image_614.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg402_Image_614.jpg)'
- en: 'Figure 7.4: A neighborhood in one dimension is three cells.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：一维邻域是三个单元。
- en: 'I have a line of cells, each with an initial state, and each with two neighbors.
    The exciting thing is, even with this simplest CA imaginable, the properties of
    complex systems can emerge. But I haven’t yet discussed perhaps the most important
    detail of how CA work: change over time.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一行单元，每个单元有一个初始状态，并且每个单元有两个邻居。令人兴奋的是，即使是这个最简单的CA，也可以出现复杂系统的特性。但我还没有讨论可能是CA工作中最重要的细节：随时间变化。
- en: 'I’m not talking about real-world time here, but rather about the CA developing
    across a series of discrete time steps, which could also be called **generations**.
    In the case of a CA in p5.js, time will likely be tied to the frame count of the
    animation. The question, as depicted in [Figure 7.5](ch07.xhtml#ch7fig5), is this:
    Given the states of the cells at time equals 0 (or generation 0), how do I compute
    the states for all cells at generation 1? And then how do I get from generation
    1 to generation 2? And so on and so forth.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我不是在谈论现实世界的时间，而是在谈论CA在一系列离散的时间步骤中发展，这些步骤也可以称为**代**。在p5.js中的CA，时间可能与动画的帧数相关。如[图7.5](ch07.xhtml#ch7fig5)所示，问题是这样的：给定时间为0（或第一代）时单元的状态，如何计算第一代所有单元的状态？然后，如何从第一代到第二代？依此类推。
- en: '![Image](../images/pg403_Image_615.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg403_Image_615.jpg)'
- en: 'Figure 7.5: The states for generation 1 are calculated using the states of
    the cells from generation 0.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：第一代的状态是通过使用第二代单元的状态来计算的。
- en: 'Let’s say that the CA has an individual cell called cell. The formula for calculating
    the cell’s state at any given time *t* (cell[*t*]) is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设CA有一个叫做cell的独立单元。计算某一时刻 *t* （cell[*t*]）单元状态的公式如下：
- en: cell[*t*] = *f*(cell neighborhood[*t*−1])
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: cell[*t*] = *f*(cell neighborhood[*t*−1])
- en: In other words, a cell’s new state is a function of all the states in the cell’s
    neighborhood at the previous generation (time *t* − 1). A new state value is calculated
    by looking at the previous generation’s neighbor states ([Figure 7.6](ch07.xhtml#ch7fig6)).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，单元的新状态是上一代单元邻域中所有单元状态的函数（时间 *t* − 1）。通过查看上一代邻域的状态，可以计算出新的状态值（[图7.6](ch07.xhtml#ch7fig6)）。
- en: '![Image](../images/pg403_Image_616.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg403_Image_616.jpg)'
- en: 'Figure 7.6: The state of a cell at generation 1 is a function of the previous
    generation’s neighborhood.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：第一代的单元状态是上一代邻域的函数。
- en: 'You can compute a cell’s state from its neighbors’ states in many ways. Consider
    blurring an image. (Guess what? Image processing works with CA-like rules!) A
    pixel’s new state (its color) is the average of its neighbors’ colors. Similarly,
    a cell’s new state could be the sum of all its neighbors’ states. However, in
    Wolfram’s elementary CA, the process takes a different approach: instead of mathematical
    operations, new states are determined by predefined rules that account for every
    possible configuration of a cell and its neighbors. These rules are known collectively
    as a **ruleset**.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过多种方式计算一个单元格的状态，依据的是它邻居的状态。考虑模糊处理图像。（猜猜看？图像处理也使用类似 CA 的规则！）一个像素的新状态（颜色）是其邻居颜色的平均值。同样，单元格的新状态可以是所有邻居状态的总和。然而，在沃尔夫勒姆的基础
    CA 中，过程采用了不同的方法：不是数学运算，而是通过预定义的规则来确定新状态，这些规则涵盖了单元格及其邻居的每一种可能配置。这些规则统称为**规则集**。
- en: This approach might seem ridiculous at first—wouldn’t there be way too many
    possibilities for it to be practical? Well, let’s give it a try. A neighborhood
    consists of three cells, each with a state of 0 or 1\. How many possible ways
    can the states in a neighborhood be configured? A quick way to figure this out
    is to think of each neighborhood configuration as a binary number. Binary numbers
    use *base 2*, meaning they’re represented with only two possible digits (0 and
    1). In this case, each neighborhood configuration corresponds to a 3-bit number,
    and how many values can you represent with 3 bits? Eight, from 0 (000) up to 7
    (111). [Figure 7.7](ch07.xhtml#ch7fig7) shows how.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法一开始可能看起来很荒谬——难道不会有太多可能性，使得它不切实际吗？好吧，让我们试试看。一个邻域由三个单元格组成，每个单元格的状态是 0 或 1。一个邻域的状态可以有多少种可能的配置？一种快速的方法是将每个邻域配置看作一个二进制数。二进制数使用*基数
    2*，意味着它们只用两个可能的数字（0 和 1）来表示。在这种情况下，每个邻域配置对应一个 3 位的数字，你可以用 3 位表示多少个值？八个，从 0（000）到
    7（111）。[图 7.7](ch07.xhtml#ch7fig7)展示了这一点。
- en: '![Image](../images/pg404_Image_617.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg404_Image_617.jpg)'
- en: 'Figure 7.7: Counting with 3 bits in binary, or the eight possible configurations
    of a three-cell neighborhood'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7：用 3 位二进制进行计数，或者说是三单元格邻域的八种可能配置
- en: 'Once all the possible neighborhood configurations are defined, an outcome (new
    state value: 0 or 1) is specified for each configuration. In Wolfram’s original
    notation and other common references, these configurations are written in descending
    order. [Figure 7.8](ch07.xhtml#ch7fig8) follows this convention, starting with
    111 and counting down to 000.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了所有可能的邻域配置，就为每种配置指定一个结果（新状态值：0 或 1）。在沃尔夫勒姆的原始符号和其他常见的参考资料中，这些配置是按降序排列的。[图
    7.8](ch07.xhtml#ch7fig8)遵循了这个惯例，从 111 开始，倒数到 000。
- en: '![Image](../images/pg404_Image_618.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg404_Image_618.jpg)'
- en: 'Figure 7.8: A ruleset shows the outcome for each possible configuration of
    three cells.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8：规则集展示了三个单元格每种可能配置的结果。
- en: Keep in mind that unlike the sum or averaging method, the rulesets in elementary
    CA don’t follow any arithmetic logic—they’re just arbitrary mappings of inputs
    to outputs. The input is the current configuration of the neighborhood (one of
    eight possibilities), and the output is the next state of the middle cell in the
    neighborhood (0 or 1—it’s up to you to define the rule).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，不像求和或平均方法，基础 CA 中的规则集不遵循任何算术逻辑——它们只是输入到输出的任意映射。输入是当前邻域的配置（八种可能性之一），输出是邻域中间单元格的下一个状态（0
    或 1——由你来定义规则）。
- en: Once you have a ruleset, you can set the CA in motion. The standard Wolfram
    model is to start generation 0 with all cells having a state of 0 except for the
    middle cell, which should have a state of 1\. You can do this with any size (length)
    grid, but for clarity, I’ll use a 1D CA of nine cells so that the middle is easy
    to pick out (see [Figure 7.9](ch07.xhtml#ch7fig9)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了规则集，就可以让 CA 开始运作。标准的沃尔夫勒姆模型是从第 0 代开始，除了中间单元格的状态为 1 外，其他单元格的状态都是 0。你可以使用任何大小（长度）的网格来实现这一点，但为了清晰起见，我将使用一个
    9 单元格的 1D CA，这样可以轻松识别中间单元格（见[图 7.9](ch07.xhtml#ch7fig9)）。
- en: '![Image](../images/pg404_Image_619.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg404_Image_619.jpg)'
- en: 'Figure 7.9: Generation 0 in a Wolfram CA, with the center cell set to 1'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9：沃尔夫勒姆 CA 的第 0 代，其中间单元格的状态设为 1
- en: Based on the ruleset in [Figure 7.8](ch07.xhtml#ch7fig8), how do the cells change
    from generation 0 to generation 1? [Figure 7.10](ch07.xhtml#ch7fig10) shows how
    the center cell, with a neighborhood of 010, switches from a 1 to a 0\. Try applying
    the ruleset to the remaining cells to fill in the rest of the generation 1 states.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 基于[图 7.8](ch07.xhtml#ch7fig8)中的规则集，细胞如何从第 0 代变为第 1 代？[图 7.10](ch07.xhtml#ch7fig10)展示了如何通过邻域
    010，使中心细胞从 1 变为 0。试着应用规则集到剩余的细胞，以填充第 1 代的其余状态。
- en: '![Image](../images/pg405_Image_620.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg405_Image_620.jpg)'
- en: 'Figure 7.10: Determining a state for generation 1 by using the CA ruleset'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10：通过使用 CA 规则集确定第 1 代的状态
- en: 'Now for a slight change: instead of representing the cells’ states with 0s
    and 1s, I’ll indicate them with visual cues—white for 0 and black for 1 (see [Figure
    7.11](ch07.xhtml#ch7fig11)). Although this might seem counterintuitive, as 0 usually
    signifies black in computer graphics, I’m using this convention because the examples
    in this book have a white background, so “turning on” a cell corresponds to switching
    its color from white to black.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在稍作改变：我将不再用 0 和 1 来表示细胞的状态，而是用视觉提示来表示——白色代表 0，黑色代表 1（参见[图 7.11](ch07.xhtml#ch7fig11)）。虽然这看起来可能不符合直觉，因为在计算机图形学中，0
    通常表示黑色，但我使用这种约定是因为本书中的示例背景是白色的，所以“激活”一个细胞就意味着将其颜色从白色变为黑色。
- en: '![Image](../images/pg405_Image_621.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg405_Image_621.jpg)'
- en: 'Figure 7.11: A white cell indicates 0, and a black cell indicates 1.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11：白色细胞表示 0，黑色细胞表示 1。
- en: With this switch from numerical representations to visual forms, the fascinating
    dynamics and patterns of CA will come into view! To show them even more clearly,
    instead of drawing one generation at a time, I’ll also start stacking the generations,
    with each new generation appearing below the previous one, as shown in [Figure
    7.12](ch07.xhtml#ch7fig12).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将数值表示转变为视觉形式，CA 的迷人动态和模式将展现出来！为了更清晰地展示它们，我不再一次画出一代，而是开始叠加各代，每一代都出现在前一代的下方，如[图
    7.12](ch07.xhtml#ch7fig12)所示。
- en: '![Image](../images/pg406_Image_622.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg406_Image_622.jpg)'
- en: 'Figure 7.12: Translating a grid of 0s and 1s to white and black squares'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12：将 0 和 1 的网格转换为白色和黑色方块
- en: The low-resolution shape that emerges in [Figure 7.12](ch07.xhtml#ch7fig12)
    is the **Sierpiński triangle**. Named after the Polish mathematician Wacław Sierpiński,
    it’s a famous example of a **fractal**. I’ll examine fractals more closely in
    [Chapter 8](ch08.xhtml#ch08), but briefly, they’re patterns in which the same
    shapes repeat themselves at different scales. To give you a better sense of this,
    [Figure 7.13](ch07.xhtml#ch7fig13) shows the CA over several more generations
    and with a wider grid size.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7.12](ch07.xhtml#ch7fig12)中出现的低分辨率形状是**谢尔宾斯基三角形**。它以波兰数学家瓦茨瓦夫·谢尔宾斯基命名，是一个著名的**分形**示例。我将在[第
    8 章](ch08.xhtml#ch08)中更详细地探讨分形，但简而言之，分形是一些在不同尺度上重复相同形状的模式。为了更好地理解这一点，[图 7.13](ch07.xhtml#ch7fig13)展示了经过几代演化后的元胞自动机（CA），并且使用了更大的网格。'
- en: '![Image](../images/pg406_Image_623.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg406_Image_623.jpg)'
- en: 'Figure 7.13: The Wolfram elementary CA'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13：沃尔夫勒姆基础元胞自动机
- en: And [Figure 7.14](ch07.xhtml#ch7fig14) shows the CA again, this time with cells
    that are just a single pixel wide so the resolution is much higher.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7.14](ch07.xhtml#ch7fig14)再次展示了 CA，这一次每个细胞的宽度仅为一个像素，因此分辨率大大提高。'
- en: '![Image](../images/pg407_Image_624.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg407_Image_624.jpg)'
- en: 'Figure 7.14: The Wolfram elementary CA at higher resolution'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14：高分辨率下的沃尔夫勒姆基础元胞自动机
- en: Take a moment to let the enormity of what you’ve just seen sink in. Using an
    incredibly simple system of 0s and 1s, with little neighborhoods of three cells,
    I was able to generate a shape as sophisticated and detailed as the Sierpiński
    triangle. This is the beauty of complex systems.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间让你刚刚看到的这一切沉淀下来。通过使用一个极其简单的 0 和 1 系统，配合三个细胞的小邻域，我能够生成一个像谢尔宾斯基三角形这样复杂且精细的形状。这就是复杂系统的美妙之处。
- en: Of course, this particular result didn’t happen by accident. I picked the set
    of rules in [Figure 7.8](ch07.xhtml#ch7fig8) because I knew the pattern it would
    generate. The mere act of defining a ruleset doesn’t guarantee visually exciting
    results. In fact, for a 1D CA in which each cell can have two possible states,
    there are exactly 256 possible rulesets to choose from, and only a handful are
    on par with the Sierpiński triangle. How do I know there are 256 possible rulesets?
    It comes down to a little more binary math.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个特定的结果并不是偶然发生的。我选择了[图 7.8](ch07.xhtml#ch7fig8)中的规则集，因为我知道它将生成的模式。仅仅定义一个规则集并不能保证产生令人兴奋的视觉效果。事实上，对于一个
    1D CA，其中每个单元格可以有两个可能的状态，共有 256 种可能的规则集可供选择，只有少数几种能够与谢尔宾斯基三角形相媲美。我怎么知道有 256 种可能的规则集呢？这涉及到更多的二进制数学运算。
- en: '**Defining Rulesets**'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**定义规则集**'
- en: Take a look back at [Figure 7.7](ch07.xhtml#ch7fig7) and notice again the eight
    possible neighborhood configurations, from 000 to 111\. These are a ruleset’s
    inputs, and they remain constant from ruleset to ruleset. Only the outputs vary
    from one ruleset to another—the individual 0 or 1 paired with each neighborhood
    configuration. [Figure 7.8](ch07.xhtml#ch7fig8) represented a ruleset entirely
    with 0s and 1s. Now [Figure 7.15](ch07.xhtml#ch7fig15) shows the same ruleset
    visualized with white and black squares.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 再回头看看[图 7.7](ch07.xhtml#ch7fig7)，再次注意到八种可能的邻域配置，从 000 到 111。这些是规则集的输入，它们在不同的规则集中保持不变。只有输出在不同的规则集中有所变化——即与每个邻域配置配对的单个
    0 或 1。[图 7.8](ch07.xhtml#ch7fig8)用 0 和 1 完全表示了一个规则集。现在，[图 7.15](ch07.xhtml#ch7fig15)则用黑白方块来可视化同一个规则集。
- en: '![Image](../images/pg407_Image_625.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg407_Image_625.jpg)'
- en: 'Figure 7.15: Representing the same ruleset (from [Figure 7.8](ch07.xhtml#ch7fig8))
    with white and black squares'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15：用黑白方块表示相同的规则集（来自[图 7.8](ch07.xhtml#ch7fig8)）
- en: Since the eight possible inputs are the same no matter what, potential shorthand
    for indicating a ruleset is to specify just the outputs, writing them as a sequence
    of eight 0s or 1s—in other words, an 8-bit binary number. For example, the ruleset
    in [Figure 7.15](ch07.xhtml#ch7fig15) could be written as 01011010\. The 0 on
    the right corresponds to input configuration 000, the 1 next to it corresponds
    to input 001, and so on. On Wolfram’s website, CA rules are illustrated using
    a combination of this binary shorthand and the black-and-white square representation,
    yielding depictions like [Figure 7.16](ch07.xhtml#ch7fig16).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于八种可能的输入无论如何都相同，因此指示规则集的简写方式是仅指定输出，并将其写成一串八个 0 或 1——换句话说，就是一个 8 位的二进制数字。例如，[图
    7.15](ch07.xhtml#ch7fig15)中的规则集可以写作 01011010。右侧的 0 对应输入配置 000，紧接着的 1 对应输入 001，依此类推。在
    Wolfram 的网站上，CA 规则通常使用二进制简写和黑白方块表示法的组合来展示，形成像[图 7.16](ch07.xhtml#ch7fig16)这样的图像。
- en: '![Image](../images/pg408_Image_626.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg408_Image_626.jpg)'
- en: 'Figure 7.16: How the Wolfram website represents a ruleset'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16：Wolfram 网站如何表示一个规则集
- en: I’ve said that each ruleset can essentially be boiled down to an 8-bit number,
    and how many combinations of eight 0s and 1s are there? Exactly 2⁸, or 256\. You
    might remember this from when you first learned about RGB color in p5.js. When
    you write `background(r, g, b)`, each color component (red, green, and blue) is
    represented by an 8-bit number ranging from 0 to 255 in decimal, or 00000000 to
    11111111 in binary.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，每个规则集本质上可以简化为一个 8 位数字，那么八个 0 和 1 的组合有多少种呢？正好是 2⁸，即 256 种。你可能还记得在学习 p5.js
    中的 RGB 颜色时学到过这一点。当你写下 `background(r, g, b)` 时，每个颜色分量（红色、绿色和蓝色）都由一个从 0 到 255 的
    8 位数字表示，或者说是从 00000000 到 11111111 的二进制数。
- en: The ruleset in [Figure 7.16](ch07.xhtml#ch7fig16) could be called rule 01011010,
    but Wolfram instead refers to it as rule 90\. Where does 90 come from? To make
    ruleset naming even more concise, Wolfram uses decimal (or base 10) representations
    rather than binary. To name a rule, you convert its 8-bit binary number to its
    decimal counterpart. The binary number 01011010 translates to the decimal number
    90, and therefore it’s named rule 90.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7.16](ch07.xhtml#ch7fig16)中的规则集可以称为规则 01011010，但 Wolfram 反而称它为规则 90。90 是怎么来的？为了使规则集命名更加简洁，Wolfram
    使用十进制（或基数 10）表示法，而不是二进制。命名规则时，你需要将其 8 位二进制数字转换为十进制数字。二进制数字 01011010 转换为十进制数字 90，因此它被命名为规则
    90。'
- en: Since there are 256 possible combinations of eight 0s and 1s, there are also
    256 unique rulesets. Let’s check out another one. How about rule 11011110, or
    more commonly, rule 222? [Figure 7.17](ch07.xhtml#ch7fig17) shows how it looks.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于八个 0 和 1 的组合有 256 种可能性，因此也有 256 种独特的规则集。让我们来看另一个例子。比如规则 11011110，或者更常见的规则
    222？[图 7.17](ch07.xhtml#ch7fig17)展示了它的样子。
- en: '![Image](../images/pg408_Image_627.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg408_Image_627.jpg)'
- en: 'Figure 7.17: The Wolfram elementary CA, rule 222'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17：Wolfram 基础元胞自动机，规则 222
- en: The result is a recognizable shape, though it certainly isn’t as exciting as
    the Sierpiński triangle. As I said earlier, most of the 256 elementary rulesets
    don’t produce compelling outcomes. However, it’s still quite incredible that even
    just a few of these rulesets—simple systems of cells with only two possible states—can
    produce fascinating patterns seen every day in nature. For example, [Figure 7.18](ch07.xhtml#ch7fig18)
    shows a snail shell resembling Wolfram’s rule 30\. This demonstrates how valuable
    CAs can be in simulation and pattern generation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个可识别的形状，尽管它显然不像谢尔宾斯基三角形那样激动人心。正如我之前所说，大部分 256 个基础规则集不会产生令人信服的结果。然而，令人惊讶的是，即便是其中的一些规则集——由仅有两种可能状态的简单细胞系统构成——也能产生大自然中每天都能看到的迷人图案。例如，[图
    7.18](ch07.xhtml#ch7fig18)展示了一个类似 Wolfram 规则 30 的蜗牛壳。这展示了元胞自动机在仿真和模式生成中的巨大价值。
- en: '![Image](../images/pg409_Image_628.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg409_Image_628.jpg)'
- en: 'Figure 7.18: A textile cone snail (*Conus textile*), Cod Hole, Great Barrier
    Reef, Australia (photo by Richard Ling)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18：一只纺织圆锥螺（*Conus textile*），科德霍尔，澳大利亚大堡礁（理查德·林拍摄）
- en: Before I go too far down the road of characterizing the results of different
    rulesets, though, let’s look at how to build a p5.js sketch that generates and
    visualizes a Wolfram elementary CA.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我进一步探讨不同规则集的结果之前，先让我们看看如何构建一个 p5.js 草图，生成并可视化一个 Wolfram 基础元胞自动机。
- en: '**Programming an Elementary CA**'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**编程一个基础元胞自动机**'
- en: 'You may be thinking, “Okay, I have this cell thing. And the cell thing has
    properties, like a state, what generation it’s on, who its neighbors are, and
    where it lives pixel-wise on the screen. And maybe it has functions, like to display
    itself and determine its new state.” This line of thinking is an excellent one
    and would likely lead you to write code like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：“好吧，我有了这个细胞的概念。这个细胞有一些属性，比如状态、它所在的代数、它的邻居是谁，以及它在屏幕上的像素位置。它可能还有一些函数，比如显示自己和确定它的新状态。”这种思路非常好，可能会引导你编写类似如下的代码：
- en: '[PRE0]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, this isn’t the road I want to travel down right now. Later in this
    chapter, I’ll discuss why an object-oriented approach could prove valuable in
    developing a CA simulation, but to begin, it’s easier to work with a more elementary
    data structure. After all, what is an elementary CA but a list of 0s and 1s? Why
    not describe a generation of a 1D CA by using an array?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是我现在想要走的道路。在本章稍后的部分，我会讨论面向对象的方法在开发元胞自动机（CA）仿真中的潜在价值，但一开始，使用更基础的数据结构会更容易。毕竟，一个基础的元胞自动机不就是由一列
    0 和 1 组成的列表吗？为什么不通过使用数组来描述一代 1D 元胞自动机呢？
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This array corresponds to the row of cells shown in [Figure 7.19](ch07.xhtml#ch7fig19).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组对应于[图 7.19](ch07.xhtml#ch7fig19)中显示的细胞行。
- en: '![Image](../images/pg409_Image_629.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg409_Image_629.jpg)'
- en: 'Figure 7.19: One generation of a 1D CA'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.19：一代 1D 元胞自动机
- en: 'To show that array, I check whether each element is a 0 or a 1, choose a fill
    color accordingly, and draw a rectangle:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这个数组，我会检查每个元素是 0 还是 1，然后选择相应的填充颜色，并绘制一个矩形：
- en: '![Image](../images/pg410_Image_630.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg410_Image_630.jpg)'
- en: 'The array describes the cell states in the current generation. Now I need a
    mechanism to compute the next generation’s states. Here’s the pseudocode describing
    what I want to achieve:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组描述了当前代的细胞状态。现在，我需要一个机制来计算下一代的状态。这里是描述我想要实现的伪代码：
- en: 'For every cell in the array:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组中的每个细胞：
- en: 'Take a look at the neighborhood states: left, middle, right.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看邻域的状态：左侧、中间、右侧。
- en: Look up the new value for the cell state according to a ruleset.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据规则集查找细胞状态的新值。
- en: Set the cell’s state to that new value.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将细胞的状态设置为这个新值。
- en: 'This pseudocode may suggest writing code like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个伪代码可能暗示着编写类似以下的代码：
- en: '![Image](../images/pg410_Image_631.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg410_Image_631.jpg)'
- en: I’m fairly close to getting this right but have a few issues to resolve. For
    one, I’m farming out the calculation of a new state value to a function called
    `rules()`. Obviously, I’m going to have to write this function, so my work isn’t
    done, but what I’m aiming for here is modularity. I want a `for` loop that provides
    a basic framework for managing any CA, regardless of the specific ruleset. If
    I want to try different rulesets, I shouldn’t have to touch that framework at
    all; I can just rewrite the `rules()` function to compute the new states differently.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我离正确的解决方案已经很接近了，但还有一些问题需要解决。首先，我把计算新状态值的工作交给了一个叫做`rules()`的函数。显然，我需要编写这个函数，所以我的工作还没完成，但我这里的目标是模块化。我希望有一个`for`循环，它提供一个基本框架来管理任何CA，无论具体的规则集是什么。如果我想尝试不同的规则集，我不应该修改这个框架；我只需重写`rules()`函数，改变计算新状态的方式。
- en: So I still have the `rules()` function to write, but more important, I’ve made
    one minor blunder and one major blunder in the `for` loop. Let’s examine the code
    more closely.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我仍然需要编写`rules()`函数，但更重要的是，我在`for`循环中犯了一个小错误和一个大错误。让我们仔细检查一下代码。
- en: First, notice how easy it is to look at a cell’s neighbors. Because an array
    is an ordered list of data, I can use the numbering of the indices to know which
    cells are next to which cells. I know that cell number 15, for example, has cell
    14 to its left and 16 to its right. More generally, I can say that for any cell
    `i`, its neighbors are `i - 1` and `i + 1`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意观察一个单元格的邻居是多么简单。因为数组是一个有序的数据列表，我可以通过索引的编号来知道哪些单元格是相邻的。例如，我知道单元格15的左边是单元格14，右边是单元格16。更一般地说，我可以说，对于任何单元格`i`，它的邻居是`i
    - 1`和`i + 1`。
- en: In fact, it’s not *quite* that easy. What have I done wrong? Think about how
    the code will execute. The first time through the loop, cell index `i` equals
    `0`. The code wants to look at cell 0’s neighbors. Left is `i - 1` or `-1`. Oops!
    An array by definition doesn’t have an element with an index of `-1`. It starts
    with index `0`!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，事情并没有那么简单。我错在哪里了？想想看代码是如何执行的。第一次进入循环时，单元格索引`i`等于`0`。代码希望查看单元格0的邻居。左边是`i
    - 1`，即`-1`。哎呀！数组的定义中没有索引为`-1`的元素。它从索引`0`开始！
- en: 'I alluded to this problem of edge cases earlier in the chapter and said I could
    worry about it later. Well, later is now. How should I handle the cell on the
    edge that doesn’t have a neighbor to both its left and its right? Here are three
    possible solutions to this problem:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章早些时候提到过边缘情况的问题，并说我可以稍后再处理。现在，稍后就是现在了。我应该如何处理那些没有左右邻居的边缘单元格呢？这里有三种可能的解决方案：
- en: '**Edges remain constant.** This is perhaps the simplest solution. Don’t bother
    to evaluate the edges, and always leave their state value constant (0 or 1).'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**边缘保持恒定。** 这或许是最简单的解决方案。不必评估边缘，始终保持它们的状态值不变（0或1）。'
- en: '**Edges wrap around.** Think of the CA as a strip of paper, and turn that strip
    of paper into a ring. The cell on the left edge is a neighbor of the cell on the
    right edge, and vice versa. This can create the appearance of an infinite grid
    and is probably the most commonly used solution.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**边缘环绕。** 把CA看作是一条纸带，然后将这条纸带变成一个环。左边缘的单元格是右边缘单元格的邻居，反之亦然。这样可以创建一个看起来像是无限网格的效果，并且这可能是最常用的解决方案。'
- en: '**Edges have different neighborhoods and rules.** If I wanted to, I could treat
    the edge cells differently and create rules for cells that have a neighborhood
    of two instead of three. You may want to do this in some circumstances, but in
    this case, it’s going to be a lot of extra lines of code for little benefit.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**边缘有不同的邻域和规则。** 如果需要，我可以将边缘单元格与其他单元格区分开，制定适用于只有两个邻居而不是三个邻居的规则。在某些情况下，你可能会这么做，但在本例中，这将增加很多额外的代码行，而收益却很小。'
- en: 'To make the code easiest to read and understand right now, I’ll go with option
    1 and skip the edge cases, leaving the values constant. This can be accomplished
    by starting the loop one cell later and ending it one cell earlier:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让代码现在更容易阅读和理解，我会选择第一种方法，跳过边缘情况，保持值恒定。可以通过让循环从下一个单元格开始，到前一个单元格结束来实现：
- en: '![Image](../images/pg411_Image_632.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg411_Image_632.jpg)'
- en: 'I need to fix one more problem before this is done, and identifying it is absolutely
    fundamental to the techniques behind programming CA simulations. The bug is subtle
    and won’t trigger an error; the CA just won’t perform correctly. It all lies in
    this line of code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成之前，我需要修复另一个问题，而识别这个问题对编程CA模拟背后的技术至关重要。这个bug非常隐蔽，不会触发错误；CA只是不能正确执行。问题全在这行代码中：
- en: '[PRE2]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This may seem perfectly innocent. After all, once I’ve computed a new state
    value, I want to assign the cell its new state. But think about the next iteration
    of the `for` loop. Let’s say the new state for cell 5 was just computed, and the
    loop is moving on to cell 6\. What happens next?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能完全无害。毕竟，一旦我计算出了一个新的状态值，我就想给单元格分配它的新状态。但想一想接下来`for`循环的下一次迭代。假设单元格5的新状态刚刚计算出来，循环开始处理单元格6。那么接下来会发生什么呢？
- en: Cell 6, generation 1 = a function of states for **cell 5**, cell 6, and cell
    7 at **generation 0**
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 单元格6，第1代 = **单元格5**、单元格6和单元格7在**第0代**的状态的函数
- en: 'A cell’s new state is a function of the previous neighbor states, so in this
    case, the value of cell 5 at generation 0 is needed in order to calculate cell
    6’s new state at generation 1\. Have I saved cell 5’s value at generation 0? No!
    Remember, this line of code was just executed for `i` equals `5`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单元格的新状态是前一个相邻单元格状态的函数，因此在这种情况下，需要第0代单元格5的值才能计算第1代单元格6的新状态。我是否保存了第0代单元格5的值？没有！记住，这行代码是刚刚对`i`等于`5`时执行的：
- en: '[PRE3]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once this happens, cell 5’s state at generation 0 is gone; `cells[5]` is now
    storing the value for generation 1\. I can’t overwrite the values in the array
    while I’m processing the array, because I need those values to calculate the new
    values!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发生这种情况，第0代单元格5的状态就消失了；`cells[5]`现在存储的是第1代的值。我不能在处理数组时覆盖数组中的值，因为我需要这些值来计算新的值！
- en: 'A solution to this problem is to have two arrays, one to store the current
    generation’s states and one for the next generation’s states. To save myself the
    step of reinitializing an array, I’ll use JavaScript’s `slice()` array method,
    which makes a copy of an array:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是使用两个数组，一个存储当前代的状态，另一个存储下一代的状态。为了省去重新初始化数组的步骤，我将使用JavaScript的`slice()`数组方法，它可以创建一个数组的副本：
- en: '![Image](../images/pg412_Image_633.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg412_Image_633.jpg)'
- en: 'Once the current generation’s array of values has been completely processed,
    the `cells` variable can be assigned the new array of states, effectively throwing
    away the previous generation’s values:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦当前代的值数组完全处理完毕，`cells`变量就可以被赋值为新的状态数组，从而有效地丢弃前一代的值：
- en: '![Image](../images/pg412_Image_634.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg412_Image_634.jpg)'
- en: 'I’m almost done, but I still need to define `rules()`, the function that computes
    the new state value based on the neighborhood (left, middle, and right cells).
    I know the function needs to return an integer (0 or 1), as well as receive three
    arguments (for the three neighbors):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我快完成了，但我仍然需要定义`rules()`，这个函数根据邻域（左边、中间和右边的单元格）计算新的状态值。我知道该函数需要返回一个整数（0或1），并且需要接收三个参数（代表三个邻居）：
- en: '![Image](../images/pg413_Image_635.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg413_Image_635.jpg)'
- en: I could write this function in many ways, but I’d like to start with a long-winded
    one that will hopefully provide a clear illustration of what’s happening. How
    shall I store the ruleset? Remember that a ruleset is a series of 8 bits (0 or
    1) that define the outcome for every possible neighborhood configuration. If you
    need a refresher, [Figure 7.20](ch07.xhtml#ch7fig20) shows the Wolfram notation
    for the Sierpiński triangle ruleset, along with the corresponding 0s and 1s listed
    in order. This should give you a hint as to the data structure I have in mind!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以用许多方法来编写这个函数，但我想从一个冗长的版本开始，这样或许可以清楚地说明发生了什么。我该如何存储这个规则集？记住，规则集是一系列8位（0或1），它们定义了每个可能邻域配置的结果。如果你需要复习一下，[图7.20](ch07.xhtml#ch7fig20)展示了Sierpiński三角形规则集的沃尔夫勒姆符号表示，以及按顺序列出的对应的0和1。这应该能给你一些关于我所设想的数据结构的提示！
- en: '![Image](../images/pg413_Image_636.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg413_Image_636.jpg)'
- en: 'Figure 7.20: A visual representation of a Wolfram ruleset with numeric encoding'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20：一个带有数字编码的沃尔夫勒姆规则集的可视化表示
- en: 'I can store this ruleset in an array:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以将这个规则集存储在一个数组中：
- en: '[PRE4]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And then I can say, for example, this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我可以说，例如，像这样：
- en: '[PRE5]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If left, middle, and right all have the state 1, that matches the configuration
    111, so the new state should be equal to the first value in the `ruleset` array.
    Duplicating this strategy for all eight possibilities looks like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左、中、右三个状态都是1，这与配置111匹配，因此新状态应该等于`ruleset`数组中的第一个值。对所有八种可能的情况重复这个策略如下所示：
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I like writing the `rules()` function this way because it describes line by
    line exactly what’s happening for each neighborhood configuration. However, it’s
    not a great solution. After all, what if a CA has four possible states (0 through
    3) instead of two? Suddenly there are 64 possible neighborhood configurations.
    And with 10 possible states, 1,000 configurations. And just imagine programming
    von Neumann’s 29 possible states. I’d be stuck typing out thousands upon thousands
    of `else...if` statements!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢以这种方式编写`rules()`函数，因为它逐行描述了每种邻域配置的发生情况。然而，这并不是一个很好的解决方案。毕竟，如果一个细胞自动机有四个可能的状态（从0到3）而不是两个呢？突然间，有64种可能的邻域配置。如果有10种可能的状态，那就是1000种配置。想象一下，如果要编程冯·诺依曼的29种可能状态，我将不得不输入成千上万的`else...if`语句！
- en: 'Another solution, though not quite as transparent, is to convert the neighborhood
    configuration (a 3-bit number) into a regular integer and use that value as the
    index into the ruleset array. This can be done as follows, using JavaScript’s
    built-in `parseInt()` function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案，尽管不那么透明，是将邻域配置（三位二进制数）转换为一个普通整数，并使用该值作为`ruleset`数组的索引。这可以通过以下方式实现，使用JavaScript内置的`parseInt()`函数：
- en: '![Image](../images/pg414_Image_637.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg414_Image_637.jpg)'
- en: 'This solution has one tiny problem, however. Consider rule 222:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个解决方案有一个小问题。考虑规则222：
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And say the neighborhood being tested is 111\. The resulting state should be
    equal to ruleset index 0, based on the way I first wrote the `rules()` function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 假设正在测试的邻域是111。根据我最初编写的`rules()`函数，结果状态应该等于规则集索引0：
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The binary number 111 converts to the decimal number 7\. But I don’t want `ruleset[7]`;
    I want `ruleset[0]`. For this to work, I need to invert the index before looking
    up the state in the `ruleset` array:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数111转换为十进制数7。但我不想要`ruleset[7]`，我想要`ruleset[0]`。为了使其有效，我需要在查找`ruleset`数组中的状态之前反转索引：
- en: '![Image](../images/pg414_Image_638.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg414_Image_638.jpg)'
- en: 'I now have everything needed to compute the generations for a Wolfram elementary
    CA. Here’s how the code looks all together:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在已经拥有计算沃尔夫勒姆基本细胞自动机世代所需的一切。以下是整个代码：
- en: '![Image](../images/pg415_Image_639.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg415_Image_639.jpg)'
- en: 'This is great, but one more piece is still missing: What good is a CA if you
    can’t see it?'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒，但还有一个部分缺失：如果你看不见细胞自动机，它又有什么用呢？
- en: '**Drawing an Elementary CA**'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**绘制基本细胞自动机**'
- en: The standard technique for drawing an elementary CA is to stack the generations
    one on top of the other, and to draw each cell as a square that’s black (for state
    1) or white (for state 0), as in [Figure 7.21](ch07.xhtml#ch7fig21). Before implementing
    this particular visualization, however, I’d like to point out two things.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制基本细胞自动机的标准技术是将世代一层层叠加起来，每个单元格绘制为一个方形，黑色表示状态1，白色表示状态0，如[图7.21](ch07.xhtml#ch7fig21)所示。然而，在实现这种特定的可视化之前，我想指出两点。
- en: '![Image](../images/pg416_Image_640.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg416_Image_640.jpg)'
- en: 'Figure 7.21: Rule 90 visualized as a stack of generations'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.21：规则90的世代堆叠可视化
- en: First, this visual interpretation of the data is completely literal. It’s useful
    for demonstrating the algorithms and results of Wolfram’s elementary CA, but it
    shouldn’t necessarily drive your own personal work. You’re not likely building
    a project that needs precisely this algorithm with this visual style. So, while
    learning to draw a CA in this way will help you understand and implement CA systems,
    this skill should exist only as a foundation.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这种数据的可视化解释完全是字面上的。它有助于展示沃尔夫勒姆的基本细胞自动机算法和结果，但它不一定应该驱动你个人的工作。你不太可能构建一个需要精确这个算法和这种可视化风格的项目。所以，虽然以这种方式学习绘制细胞自动机有助于你理解和实现细胞自动机系统，但这个技能应该仅仅作为一个基础存在。
- en: Second, the fact that a 1D CA is visualized with a 2D image can be misleading.
    It’s very important to remember that this is *not* a 2D CA. I’m simply choosing
    to show a history of all the generations stacked vertically. This technique creates
    a 2D image out of many instances of 1D data, but the system itself is 1D. Later,
    I’ll show you an actual 2D CA (the Game of Life), and I’ll cover how to visualize
    such a system.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点是，1D CA 用 2D 图像来可视化可能会误导人。非常重要的一点是要记住，这*不是*一个 2D CA。我只是选择将所有代数的历史记录垂直堆叠显示。这个技术通过将多次
    1D 数据的实例合成一个 2D 图像，但系统本身仍然是 1D 的。稍后，我会展示一个真正的 2D CA（生命游戏），并介绍如何可视化这样的系统。
- en: 'The good news is that drawing an elementary CA isn’t particularly difficult.
    I’ll begin by rendering a single generation. Let’s say each cell should be a 10×10
    square:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，绘制一个基本的 CA（元胞自动机）并不特别困难。我将从绘制单一的世代开始。假设每个单元格应为 10×10 的正方形：
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Assuming the canvas is 640 pixels wide, the CA will have 64 cells. Of course,
    I can calculate this value dynamically when I initialize the `cells` array in
    `setup()`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 假设画布宽度为 640 像素，那么 CA 将有 64 个单元格。当然，我可以在 `setup()` 中初始化 `cells` 数组时动态计算这个值：
- en: '![Image](../images/pg416_Image_641.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg416_Image_641.jpg)'
- en: 'Drawing the cells now involves iterating over the array and drawing a square
    based on the state of each cell:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，绘制单元格的过程涉及遍历数组并根据每个单元格的状态绘制一个正方形：
- en: '![Image](../images/pg416_Image_642.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg416_Image_642.jpg)'
- en: Two aspects of this code are off. First, when multiplying the state by 255,
    cells with a state of 1 will be white and those with 0 will be black, which is
    the opposite of what I originally intended! While this is of course okay since
    the color representation is arbitrary, I’ll correct this in the full example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有两个问题。首先，当将状态乘以 255 时，状态为 1 的单元格将变为白色，状态为 0 的单元格将变为黑色，这与我最初的意图相反！虽然这当然没问题，因为颜色表示是任意的，但我将在完整的示例中纠正这一点。
- en: The more pressing issue is that the y-position for each square is hardcoded
    to 0\. If I want the generations to be stacked on top of each other, with each
    row of cells marking a new generation, I’ll also need to calculate a y-position
    based on the generation number. I can accomplish this by adding a `generation`
    variable and incrementing it each time through `draw()`. With these additions,
    I can now look at the entire sketch.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 更紧迫的问题是每个正方形的 y 位置被硬编码为 0。如果我希望各代排列成堆叠的形式，每一行单元格表示一个新的世代，那么我还需要根据世代编号计算 y 位置。我可以通过添加一个
    `generation` 变量，并在 `draw()` 每次执行时将其递增来实现。通过这些改动，我现在可以查看整个草图。
- en: '![Image](../images/pg417_Image_644.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg417_Image_644.jpg)'
- en: 'You may have noticed an optimization I made in this example to simplify the
    drawing: I included a white background and rendered only the black squares, which
    saves the work of drawing many squares. This solution isn’t suitable for all cases—what
    if I want multicolored cells?—but it provides a performance boost in this simple
    case. (I’ll also note that if the size of each cell were 1 pixel, I wouldn’t want
    to use p5.js’s `square()` function, but rather access the pixel array directly.)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我在这个例子中所做的优化，以简化绘制过程：我加入了一个白色背景，并只绘制了黑色正方形，这节省了绘制许多正方形的工作。这个解决方案并不适用于所有情况——如果我想要多色单元格怎么办？——但是在这个简单的情况下，它提供了性能上的提升。（我还要指出，如果每个单元格的大小是
    1 像素，我不会使用 p5.js 的 `square()` 函数，而是直接访问像素数组。）
- en: 'Despite this optimization, another aspect of the drawing code is woefully inefficient:
    the sketch continues to draw generation after generation, extending beyond the
    bottom of the canvas. The code on the book’s website includes a simple stopping
    condition, but you might come up with other approaches to address this issue (some
    are mentioned in the following exercises).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管进行了优化，绘制代码的另一个方面依然非常低效：草图不断绘制一代又一代，延伸至画布底部之外。书中网站上的代码包括一个简单的停止条件，但你可能会想出其他方法来解决这个问题（一些方法在接下来的练习中提到）。
- en: '![Image](../images/pencil.jpg) **Exercise 7.1**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 7.1**'
- en: 'Expand [Example 7.1](ch07.xhtml#ch7ex1) to have the following feature: when
    the CA reaches the bottom of the canvas, the CA starts over with a new, random
    ruleset.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 [示例 7.1](ch07.xhtml#ch7ex1)，使其具有以下功能：当 CA 到达画布底部时，CA 重新开始并使用新的随机规则集。
- en: '![Image](../images/pencil.jpg) **Exercise 7.2**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 7.2**'
- en: Examine the patterns that occur if you initialize the cells in generation 0
    with random states.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 检查如果你用随机状态初始化第 0 代的单元格，出现的模式。
- en: '![Image](../images/pencil.jpg) **Exercise 7.3**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 7.3**'
- en: Visualize the CA in a nontraditional way. Break all the rules you can; don’t
    feel tied to using squares on a perfect grid with black and white.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以非传统的方式可视化细胞自动机（CA）。打破你能打破的所有规则；不要拘泥于使用完美网格上的黑白方块。
- en: '![Image](../images/pencil.jpg) **Exercise 7.4**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 7.4**'
- en: 'Create a visualization of the CA that scrolls upward as the generations increase
    so that you can view the generations to “infinity.” Hint: Instead of keeping track
    of one generation at a time, you’ll need to store a history of generations, always
    adding a new one and deleting the oldest one in each frame.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个细胞自动机的可视化，随着代数的增加而向上滚动，这样你就可以看到“无限”代数。提示：与其一次跟踪一代，你需要存储一代代的历史，每帧都添加一代并删除最旧的一代。
- en: '**Wolfram Classification**'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Wolfram 分类**'
- en: Now that you have a sketch for visualizing an elementary CA, you can supply
    it whatever ruleset you want and see the results. What kinds of outcomes can you
    expect? As I noted earlier, the vast majority of elementary CA rulesets produce
    visually uninspiring results, while some result in wondrously complex patterns
    like those found in nature. Wolfram has divided the range of outcomes into four
    classes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了可视化一个基本细胞自动机的草图，你可以为其提供任何规则集并查看结果。你可以期待哪些结果呢？正如我之前提到的，绝大多数基本细胞自动机规则集会产生视觉上乏味的结果，而一些则产生如同自然界中那样奇妙复杂的模式。Wolfram
    将结果范围分为四类。
- en: '**Class 1: Uniformity**'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类别 1：均匀性**'
- en: Class 1 CAs end up, after a certain number of generations, with every cell constant.
    This isn’t terribly exciting to watch. Rule 222 is a class 1 CA; if you run it
    for enough generations, every cell will eventually become and remain black (see
    [Figure 7.22](ch07.xhtml#ch7fig22)).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 类别 1 的细胞自动机在经过一定代数后，最终每个单元格的状态都会保持不变。看起来并不特别激动人心。规则 222 是一个类别 1 的细胞自动机；如果你运行它足够多的代数，最终每个单元格都会变为黑色并保持不变（见
    [图 7.22](ch07.xhtml#ch7fig22)）。
- en: '![Image](../images/pg419_Image_646.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg419_Image_646.jpg)'
- en: 'Figure 7.22: Rule 222'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.22：规则 222
- en: '**Class 2: Repetition**'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类别 2：重复**'
- en: Like class 1 CAs, class 2 CAs remain stable, but the cell states aren’t constant.
    Instead, they oscillate in a repeating pattern of 0s and 1s. In rule 190, each
    cell follows the sequence `11101110111011101110` ([Figure 7.23](ch07.xhtml#ch7fig23)).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 像类别 1 的细胞自动机一样，类别 2 的细胞自动机保持稳定，但单元格的状态并不是恒定的。相反，它们在 0 和 1 的重复模式中振荡。在规则 190 中，每个单元格遵循序列
    `11101110111011101110` （[图 7.23](ch07.xhtml#ch7fig23)）。
- en: '![Image](../images/pg420_Image_647.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg420_Image_647.jpg)'
- en: 'Figure 7.23: Rule 190'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.23：规则 190
- en: '**Class 3: Random**'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类别 3：随机**'
- en: Class 3 CAs appear random and have no easily discernible pattern. In fact, rule
    30 ([Figure 7.24](ch07.xhtml#ch7fig24)) is used as a random-number generator in
    Wolfram’s Mathematica software. Again, you can feel amazed that such a simple
    system with simple rules can descend into a chaotic and random pattern.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 类别 3 的细胞自动机看起来是随机的，并且没有明显的可辨认模式。实际上，规则 30 （[图 7.24](ch07.xhtml#ch7fig24)）被用作
    Wolfram Mathematica 软件中的随机数生成器。你可能会惊讶地发现，像这样的简单系统，遵循简单规则，却能发展成混乱和随机的模式。
- en: '![Image](../images/pg420_Image_648.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg420_Image_648.jpg)'
- en: 'Figure 7.24: Rule 30'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.24：规则 30
- en: '**Class 4: Complexity**'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类别 4：复杂性**'
- en: Class 4 CAs can be thought of as a mix between class 2 and class 3\. You can
    find repetitive, oscillating patterns inside the CA, but where and when these
    patterns appear is unpredictable and seemingly random. If a class 3 CA wowed you,
    then a class 4 like rule 110 ([Figure 7.25](ch07.xhtml#ch7fig25)) should really
    blow your mind!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 类别 4 的细胞自动机可以看作是类别 2 和类别 3 的混合体。你可以在细胞自动机中找到重复的、振荡的模式，但这些模式出现的时间和位置是不可预测的，似乎是随机的。如果类别
    3 的细胞自动机让你感到惊讶，那么像规则 110 （[图 7.25](ch07.xhtml#ch7fig25)）这样的类别 4 一定会让你大吃一惊！
- en: '![Image](../images/pg421_Image_649.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg421_Image_649.jpg)'
- en: 'Figure 7.25: Rule 110'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.25：规则 110
- en: In [Chapter 5](ch05.xhtml#ch05), I introduced the concept of a complex system
    and used flocking to demonstrate how simple rules can result in emergent behaviors.
    Class 4 CAs remarkably exhibit the characteristics of complex systems and are
    the key to simulating phenomena such as forest fires, traffic patterns, and the
    spread of diseases. Research and applications of CA consistently emphasize the
    importance of class 4 as the bridge between CA and nature.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第五章](ch05.xhtml#ch05) 中，我介绍了复杂系统的概念，并用群聚行为展示了简单规则如何导致涌现行为。类别 4 的细胞自动机显著地展示了复杂系统的特征，是模拟森林火灾、交通模式和疾病传播等现象的关键。细胞自动机的研究和应用始终强调类别
    4 作为细胞自动机与自然之间桥梁的重要性。
- en: '**The Game of Life**'
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**生命游戏**'
- en: 'The next step is to move from a 1D CA to a 2D one: the Game of Life. This will
    introduce additional complexity—each cell will have a bigger neighborhood—but
    with the complexity comes a wider range of possible applications. After all, most
    of what happens in computer graphics lives in two dimensions, and this chapter
    demonstrates how to apply CA thinking to a 2D p5.js canvas.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将一维元胞自动机（CA）扩展到二维：生命游戏。这将引入额外的复杂性——每个单元格将拥有更大的邻域——但随着复杂性的增加，可能的应用范围也变得更广。毕竟，大多数计算机图形学中的现象都发生在二维空间，而本章展示了如何将元胞自动机的思维方式应用于二维的
    p5.js 画布。
- en: 'In 1970, Martin Gardner wrote a *Scientific American* article that documented
    mathematician John Conway’s new Game of Life, describing it as *recreational mathematics*:
    “To play life you must have a fairly large checkerboard and a plentiful supply
    of flat counters of two colors. It is possible to work with pencil and graph paper
    but it is much easier, particularly for beginners, to use counters and a board.”'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 1970年，马丁·加德纳在《*科学美国人*》上撰写了一篇文章，记录了数学家约翰·康威的新生命游戏，并将其描述为*娱乐数学*：“要玩生命游戏，你必须有一个相当大的棋盘，并且需要大量两种颜色的平面棋子。虽然用铅笔和图纸也能操作，但特别是对于初学者来说，使用棋子和棋盘要容易得多。”
- en: The Game of Life has become something of a computational cliché, as myriad projects
    display the game on LEDs, screens, projection surfaces, and so on. But practicing
    building the system with code is still valuable for a few reasons.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 生命游戏已经变成了一种计算上的陈词滥调，许多项目展示了在LED、屏幕、投影面等上的游戏。然而，使用代码实践构建这个系统仍然非常有价值，原因有几个。
- en: 'For one, the Game of Life provides a good opportunity to practice skills with
    2D arrays, nested loops, and more. Perhaps more important, however, this CA’s
    core principles are tied directly to a core goal of this book: simulating the
    natural world with code. The Game of Life algorithm and technical implementation
    will provide you with the inspiration and foundation to build simulations that
    exhibit the characteristics and behaviors of biological systems of reproduction.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，生命游戏为练习二维数组、嵌套循环等技能提供了很好的机会。然而，更重要的是，这个元胞自动机的核心原理直接与本书的核心目标相联系：用代码模拟自然世界。生命游戏的算法和技术实现将为你提供灵感和基础，帮助你构建表现出生物系统繁殖特征和行为的模拟。
- en: Unlike von Neumann, who created an extraordinarily complex system of states
    and rules, Conway wanted to achieve a similar lifelike result with the simplest
    set of rules possible. Let’s look at how Gardner outlined Conway’s goals.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与冯·诺依曼不同，后者创建了一个极其复杂的状态和规则系统，康威希望用尽可能简单的规则集来实现类似的生命般的结果。让我们看看加德纳是如何概述康威的目标的。
- en: '*There should be no initial pattern for which there is a simple proof that
    the population can grow without limit.*'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*应该没有任何初始模式，它能够简单证明人口可以无限增长。*'
- en: '*There should be initial patterns that apparently do grow without limit.*'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*应该有一些初始模式，显然会无限增长。*'
- en: '*There should be simple initial patterns that grow and change for a considerable
    period of time before coming to an end in three possible ways: fading away completely
    (from overcrowding or becoming too sparse), settling into a stable configuration
    that remains unchanged thereafter, or entering an oscillating phase in which they
    repeat an endless cycle of two or more periods.*'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*应该有一些简单的初始模式，它们会持续增长并变化，经过相当长的时间后以三种方式之一结束：完全消失（由于过度拥挤或变得过于稀疏），稳定在一个配置中且之后保持不变，或进入振荡阶段，重复两种或更多周期的无尽循环。*'
- en: This might sound cryptic, but it essentially describes a Wolfram class 4 CA.
    The CA should be patterned but unpredictable over time, eventually settling into
    a uniform or oscillating state. In other words, though Conway didn’t use this
    terminology, the Game of Life should have all the properties of a *complex system*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能有些晦涩，但它本质上描述了沃尔夫拉姆第四类元胞自动机。该元胞自动机应该是有规律的，但随着时间推移变得不可预测，最终会趋于均匀或振荡状态。换句话说，尽管康威没有使用这个术语，生命游戏应该具备*复杂系统*的所有特性。
- en: '**The Rules of the Game**'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**游戏规则**'
- en: Let’s look at how the Game of Life works. It won’t take up too much time or
    space, since I can build on everything from Wolfram’s elementary CA. First, instead
    of a line of cells, I now have a 2D matrix of cells. As with the elementary CA,
    the possible states are 0 or 1\. In this case, however, since the system is all
    about life, 0 means “dead” and 1 means “alive.”
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看“生命游戏”是如何运作的。这不会占用太多时间或空间，因为我可以基于沃尔夫拉姆的基础元胞自动机进行构建。首先，代替一行细胞，我现在有一个二维的细胞矩阵。与基础元胞自动机一样，可能的状态是
    0 或 1。然而，在这个系统中，由于它是关于生命的，0 表示“死亡”，1 表示“存活”。
- en: Since the Game of Life is 2D, each cell’s neighborhood has now expanded. If
    a neighbor is an adjacent cell, a neighborhood is now nine cells instead of three,
    as shown in [Figure 7.26](ch07.xhtml#ch7fig26).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“生命游戏”是二维的，每个细胞的邻域现在已经扩展。如果一个邻居是相邻的细胞，那么邻域现在是九个细胞，而不是三个，正如在[图 7.26](ch07.xhtml#ch7fig26)中所示。
- en: '![Image](../images/pg422_Image_650.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg422_Image_650.jpg)'
- en: 'Figure 7.26: A 2D CA showing the neighborhood of nine cells'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.26：一个二维元胞自动机，显示九个细胞的邻域
- en: 'With three cells, a 3-bit number had eight possible configurations. With nine
    cells, there are 9 bits, or 512 possible neighborhoods. In most cases, defining
    an outcome for every single possibility would be impractical. The Game of Life
    gets around this problem by defining a set of rules according to general characteristics
    of the neighborhood: Is the neighborhood overpopulated with life, surrounded by
    death, or just right? Here are the rules of life:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于三个细胞，3 位数字有八种可能的配置。对于九个细胞，有 9 位，也就是 512 种可能的邻域。在大多数情况下，为每种可能性定义一个结果是不可行的。生命游戏通过根据邻域的总体特征来定义一套规则来解决这个问题：邻域是过度拥挤，还是被死亡包围，还是刚刚好？以下是生命规则：
- en: '**Death:** If a cell is alive (state = 1), it will die (state becomes 0) under
    the following circumstances:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**死亡：** 如果一个细胞存活（状态 = 1），在以下情况下它将死亡（状态变为 0）：'
- en: '**Overpopulation:** If the cell has four or more living neighbors, it dies.'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过度拥挤：** 如果该细胞有四个或更多的活邻居，它将死亡。'
- en: '**Loneliness:** If the cell has one or fewer living neighbors, it dies.'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**孤独：** 如果该细胞的活邻居少于或等于一个，它将死亡。'
- en: '**Birth:** If a cell is dead (state = 0), it will come to life (state becomes
    1) when it has exactly three living neighbors (no more, no less).'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**诞生：** 如果一个细胞死亡（状态 = 0），当它恰好有三个活邻居时，它将复生（状态变为 1）。'
- en: '**Stasis:** In all other cases, the cell’s state doesn’t change. Two scenarios
    are possible:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**静止：** 在所有其他情况下，细胞的状态不变。两种情况是可能的：'
- en: '**Staying alive:** If a cell is alive and has exactly two or three live neighbors,
    it stays alive.'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持存活：** 如果一个细胞存活并且有恰好两个或三个活邻居，它将保持存活。'
- en: '**Staying dead:** If a cell is dead and has anything other than three live
    neighbors, it stays dead.'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持死亡：** 如果一个细胞死亡并且有除了恰好三个活邻居之外的任何其他邻居，它将保持死亡。'
- en: '[Figure 7.27](ch07.xhtml#ch7fig27) shows a few examples of these rules. Focus
    on what happens to the center cell.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7.27](ch07.xhtml#ch7fig27)展示了这些规则的一些示例。重点关注中心细胞发生了什么。'
- en: '![Image](../images/pg423_Image_651.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg423_Image_651.jpg)'
- en: 'Figure 7.27: Example scenarios for death and birth in the Game of Life'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.27：生命游戏中的死亡和诞生示例场景
- en: With the elementary CA, I visualized many generations at once, stacked as rows
    in a 2D grid. With the Game of Life, however, the CA is in two dimensions. I could
    try to create an elaborate 3D visualization of the results and stack all the generations
    in a cube structure (and in fact, you might want to try this as an exercise),
    but a more typical way to visualize the Game of Life is to treat each generation
    as a single frame in an animation. This way, instead of viewing all the generations
    at once, you see them one at a time, and the result resembles rapidly developing
    bacteria in a petri dish.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在基础元胞自动机中，我一次可视化多个世代，按行堆叠在二维网格中。然而，在“生命游戏”中，元胞自动机是二维的。我可以尝试创建一个复杂的三维可视化结果，并将所有世代堆叠在一个立方体结构中（实际上，你可能想将此作为一个练习来尝试），但可视化生命游戏的更典型方法是将每一代视为动画中的一个单独画面。这样，你不是一次性查看所有世代，而是一次查看一个，结果看起来像是在培养皿中快速发展的细菌。
- en: One of the exciting aspects of the Game of Life is that some known initial patterns
    yield intriguing results. For example, the patterns shown in [Figure 7.28](ch07.xhtml#ch7fig28)
    remain static and never change.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 生命游戏的一个令人兴奋的方面是，一些已知的初始模式会产生有趣的结果。例如，[图 7.28](ch07.xhtml#ch7fig28)中显示的模式是静止的，永远不会改变。
- en: '![Image](../images/pg424_Image_652.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg424_Image_652.jpg)'
- en: 'Figure 7.28: Initial configurations of cells that remain stable'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.28：保持稳定的细胞初始配置
- en: The patterns in [Figure 7.29](ch07.xhtml#ch7fig29) oscillate back and forth
    between two states.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7.29](ch07.xhtml#ch7fig29)中的模式在两个状态之间来回振荡。'
- en: '![Image](../images/pg424_Image_653.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg424_Image_653.jpg)'
- en: 'Figure 7.29: Initial configurations of cells that oscillate between two states'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.29：在两个状态之间振荡的细胞初始配置
- en: And the patterns in [Figure 7.30](ch07.xhtml#ch7fig30) appear to move about
    the grid from generation to generation. The cells themselves don’t actually move,
    but you see the illusion of motion in the result of adjacent cells turning on
    and off.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7.30](ch07.xhtml#ch7fig30)中的模式看起来像是从一代到下一代在网格中移动。细胞本身并没有实际移动，但你可以看到由于相邻细胞的开关，产生了运动的错觉。'
- en: '![Image](../images/pg425_Image_654.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg425_Image_654.jpg)'
- en: 'Figure 7.30: Initial configurations of cells that appear to move'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.30：看似在移动的细胞初始配置
- en: 'If you’re interested in these patterns, several good out-of-the-box Game of
    Life online demonstrations allow you to configure the CA’s initial state and watch
    it run at varying speeds. Here are two examples:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些模式感兴趣，一些不错的“生命游戏”在线演示允许你配置CA的初始状态，并以不同速度观看它运行。以下是两个示例：
- en: Exploring Emergence by Mitchel Resnick and Brian Silverman, Lifelong Kindergarten
    Group, MIT Media Laboratory (*[https://www.playfulinvention.com/emergence](https://www.playfulinvention.com/emergence)*)
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《通过Mitchel Resnick和Brian Silverman，终身幼儿园小组，麻省理工学院媒体实验室探索涌现》（* [https://www.playfulinvention.com/emergence](https://www.playfulinvention.com/emergence)
    *）
- en: Conway’s Game of Life in p5.js by Steven Klise (*[https://sklise.github.io/conways-game-of-life](https://sklise.github.io/conways-game-of-life)*)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Steven Klise的p5.js版本的康威“生命游戏”（* [https://sklise.github.io/conways-game-of-life](https://sklise.github.io/conways-game-of-life)
    *）
- en: For the example I’ll build in the next section, I’ll focus on randomly initializing
    the states for each cell.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我将专注于随机初始化每个细胞的状态。
- en: '**The Implementation**'
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**实现**'
- en: 'I already have a lot of what I need to implement the Game of Life in p5.js:
    mostly, I just need to extend the code from the Wolfram CA sketch to two dimensions.
    I previously used a 1D array to store the list of cell states. Now I’ll use a
    2D array:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经拥有了在p5.js中实现生命游戏所需的大部分内容：主要是，我只需要将Wolfram CA草图的代码扩展到二维。我之前使用了一个一维数组来存储细胞状态列表。现在，我将使用一个二维数组：
- en: '[PRE10]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'I’ll begin by initializing each cell of the board with a random state, 0 or
    1:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从为每个细胞初始化一个随机状态（0或1）开始：
- en: '![Image](../images/pg425_Image_655.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg425_Image_655.jpg)'
- en: 'Just as before, I need an extra 2D array to receive the next generation’s states
    so I don’t overwrite the current generation’s 2D array as I’m processing it. Rather
    than write all the steps to create a 2D array in both `setup()` and `draw()`,
    however, it’s worth writing a function that returns a 2D array based on the number
    of columns and rows. I’ll also initialize each element of the array to `0` so
    that it isn’t filled with `undefined`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我需要一个额外的二维数组来接收下一代的状态，这样在处理当前代的二维数组时，就不会覆盖它。然而，与其在`setup()`和`draw()`中写出所有创建二维数组的步骤，不如编写一个根据列数和行数返回二维数组的函数。我还会将数组中的每个元素初始化为`0`，这样就不会填充`undefined`：
- en: '[PRE11]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now I can just call that function whenever a new 2D array is required:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当需要一个新的二维数组时，我只需调用这个函数：
- en: '![Image](../images/pg426_Image_657.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg426_Image_657.jpg)'
- en: 'Next, I need to sort out how to calculate each cell’s new state. For that,
    I need to determine how to reference the cell’s neighbors. In the case of a 1D
    CA, this was simple: if a cell index was `i`, its neighbors were `i-1` and `i+1`.
    Here, each cell doesn’t have a single index, but rather a column and row index:
    `i,j`. As shown in [Figure 7.31](ch07.xhtml#ch7fig31), the neighbors are `i-1,j-1`,
    `i,j-1`, `i+1,j-1`, `i-1,j`, `i+1,j`, `i-1,j+1`, `i,j+1`, and `i+1,j+1`.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我需要解决如何计算每个细胞的新状态。为此，我需要确定如何引用细胞的邻居。在一维CA的情况下，这很简单：如果一个细胞的索引是`i`，它的邻居就是`i-1`和`i+1`。在这里，每个细胞没有单一的索引，而是有一个列和行的索引：`i,j`。如[图
    7.31](ch07.xhtml#ch7fig31)所示，邻居是`i-1,j-1`、`i,j-1`、`i+1,j-1`、`i-1,j`、`i+1,j`、`i-1,j+1`、`i,j+1`和`i+1,j+1`。
- en: '![Image](../images/pg427_Image_658.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg427_Image_658.jpg)'
- en: 'Figure 7.31: The index values for the neighborhood of cells'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.31：细胞邻域的索引值
- en: 'The Game of Life rules operate by knowing how many neighbors are alive. If
    I create a variable `neighborSum` and increment it for each neighbor with a state
    of 1, I’ll have the total of live neighbors:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 生命游戏的规则是通过了解有多少个邻居处于“生存”状态来运作的。如果我创建一个变量`neighborSum`并对每个状态为1的邻居进行递增，我就能得到活着的邻居总数：
- en: '![Image](../images/pg427_Image_659.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg427_Image_659.jpg)'
- en: 'Just as with the Wolfram CA, I find myself writing out a bunch of `if` statements.
    This is another situation where, for teaching purposes, it’s useful and clear
    to write the code this way, explicitly stating every step (each time a neighbor
    has a state of 1, the counter increases). Nevertheless, it’s a bit silly to say,
    “If the cell state equals 1, add 1 to a counter” when I could instead just say,
    “Add every cell state to a counter.” After all, if the state can be only 0 or
    1, the sum of all the neighbors’ states will yield the total number of live cells.
    Since the neighbors are arranged in a mini 3×3 grid, I can introduce another nested
    loop to compute the sum more efficiently:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在沃尔夫勒姆CA中一样，我发现自己写了一堆`if`语句。这是另一个情况，对于教学目的，将代码写成这样逐步明确每个步骤（每当一个邻居的状态为1时，计数器增加）既有用又清晰。然而，说“如果单元格状态等于1，就将1加到计数器”其实有点傻，因为我可以直接说：“将每个单元格状态加到计数器。”毕竟，如果状态只能是0或1，那么所有邻居状态的总和将给出活跃单元格的总数。由于邻居排列成一个小的3×3网格，我可以引入另一个嵌套循环来更高效地计算总和：
- en: '![Image](../images/pg427_Image_660.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg427_Image_660.jpg)'
- en: 'Of course, I’ve made a significant mistake. In the Game of Life, the current
    cell doesn’t count as one of the neighbors. I could include a conditional to skip
    adding the state when both `k` and `l` equal `0`, but another option is to subtract
    the cell state after the loop is completed:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我犯了一个重大错误。在生命游戏中，当前单元格不算作邻居之一。我可以加入一个条件，跳过当`k`和`l`都等于`0`时的状态添加，但另一种选择是在循环完成后再减去单元格状态：
- en: '![Image](../images/pg428_Image_662.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg428_Image_662.jpg)'
- en: 'Finally, when I know the total number of live neighbors, I can decide what
    the cell’s new state should be according to the rules—birth, death, or stasis:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我知道了活跃邻居的总数，我可以根据规则决定单元格的新状态——出生、死亡或静止：
- en: '![Image](../images/pg428_Image_663.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg428_Image_663.jpg)'
- en: 'Putting this all together:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些内容组合起来：
- en: '![Image](../images/pg428_Image_664.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg428_Image_664.jpg)'
- en: 'Now I just need to draw the board. I’ll draw a square for each spot: white
    for off, black for on.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我只需要绘制棋盘了。我将为每个位置绘制一个方块：*关闭*时为白色，*开启*时为黑色。
- en: '![Image](../images/pg429_Image_666.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg429_Image_666.jpg)'
- en: 'In this example, I’m introducing yet another method for drawing the squares
    based on a cell’s state. Remember, multiplying the cell’s state by 255 gives a
    white fill color for *on* and black for *off*. To invert this, I start with 255
    and subtract the cell’s state multiplied by 255: black for *on* and white for
    *off*.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我介绍了另一种根据单元格状态绘制方块的方法。记住，将单元格状态乘以255会给出白色填充色表示*开启*，黑色表示*关闭*。为了反转这个过程，我从255开始，减去单元格状态乘以255：*开启*时为黑色，*关闭*时为白色。
- en: '![Image](../images/pencil.jpg) **Exercise 7.5**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 7.5**'
- en: Create a Game of Life simulation that allows you to manually configure the grid,
    either by hardcoding initial cell states or by drawing directly to the canvas.
    Use the simulation to explore some of the known Game of Life patterns.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个生命游戏模拟器，允许你手动配置网格，可以通过硬编码初始单元格状态或直接在画布上绘制来配置。利用这个模拟器探索一些已知的生命游戏模式。
- en: '![Image](../images/pencil.jpg) **Exercise 7.6**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 7.6**'
- en: Implement a wraparound feature for the Game of Life so that cells on the edges
    have neighbors on the opposite side of the grid.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为生命游戏实现一个环绕功能，使得位于边缘的单元格在网格的另一侧也能找到邻居。
- en: '![Image](../images/pencil.jpg) **Exercise 7.7**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 7.7**'
- en: The code in [Example 7.2](ch07.xhtml#ch7ex2) is convenient but not particularly
    memory efficient. It creates a new 2D array for every frame of animation! This
    matters very little for a p5.js application, but if you were implementing the
    Game of Life on a microcontroller or mobile device, you’d want to be more careful.
    One solution is to have only two arrays and constantly swap them, writing the
    next set of states into whichever one isn’t the current array. Implement this
    particular solution.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7.2](ch07.xhtml#ch7ex2)中的代码虽然很方便，但并不是特别节省内存。它为每一帧动画创建了一个新的二维数组！对于p5.js应用程序来说，这影响不大，但如果你在微控制器或移动设备上实现生命游戏，你可能需要更加小心。一个解决方案是只使用两个数组，并不断交换它们，将下一个状态集写入当前数组之外的那个数组。实现这个特定的解决方案。'
- en: '**Object-Oriented Cells**'
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**面向对象的单元格**'
- en: Over the course of this book, I’ve built examples of systems of *objects* that
    have properties and move about the canvas. In this chapter, although I’ve been
    talking about a cell as if it were an object, I haven’t used the principles of
    object orientation in the code. This has worked because a cell is such an enormously
    simple object; its only property is its state, a single 0 or 1\. However, I could
    further develop CA systems in plenty of ways beyond the simple models discussed
    here, and often these may involve keeping track of multiple properties for each
    cell. For example, what if a cell needs to remember its history of states? Or
    what if you want to apply motion and physics to a CA and have the cells move about
    the canvas, dynamically changing their neighbors from frame to frame?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的过程中，我建立了多个具有属性并在画布上移动的*对象*系统示例。在这一章中，尽管我一直在把单元格当作对象来讨论，但我并没有在代码中使用面向对象的原则。之所以能够这样工作，是因为单元格是一个非常简单的对象；它唯一的属性就是状态，0或1。但我可以在此基础上进一步开发元胞自动机系统，超越这里讨论的简单模型，通常这些开发可能涉及为每个单元格跟踪多个属性。例如，如果单元格需要记住其状态历史怎么办？或者如果你想对元胞自动机应用运动和物理学，并让单元格在画布上移动，动态地改变它们的邻居，从一帧到另一帧怎么办？
- en: 'To accomplish any of these ideas (and more), it would be helpful to see how
    to treat each cell as an object, rather than as a single 0 or 1 in an array. In
    a Game of Life simulation, for example, I’ll no longer want to initialize each
    cell like this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些想法（以及更多），了解如何将每个单元格视为对象，而不是数组中的单个0或1，将会非常有帮助。例如，在生命游戏模拟中，我将不再像这样初始化每个单元格：
- en: '[PRE12]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Instead, I want something like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我希望得到如下的效果：
- en: '[PRE13]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, `Cell` is a new class that I’ll write. What are the properties of a `Cell`
    object? In the Game of Life example, I might choose to create a cell that stores
    its position and size along with its state:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`Cell`是我将编写的新类。一个`Cell`对象的属性是什么？在生命游戏的例子中，我可能选择创建一个存储其位置和大小以及状态的单元格：
- en: '![Image](../images/pg430_Image_667.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg430_Image_667.jpg)'
- en: 'In the non-OOP version, I used separate 2D arrays to keep track of the states
    for the current and next generations. By making a cell an object, however, each
    cell could keep track of both states by introducing a variable for the previous
    state:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在非面向对象版本中，我使用了单独的二维数组来跟踪当前和下一代的状态。然而，通过将单元格作为对象，每个单元格可以通过引入一个“前一状态”变量来跟踪两个状态：
- en: '![Image](../images/pg431_Image_669.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg431_Image_669.jpg)'
- en: Suddenly, with these additional properties, the cell’s visualization can incorporate
    more information about the state. For example, what if each cell were colored
    based on whether its state has changed from one frame to another?
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 突然之间，借助这些额外的属性，单元格的可视化可以包含更多关于状态的信息。例如，如果每个单元格的颜色根据其状态是否从一个帧变化到另一个帧而变化，会怎么样？
- en: '![Image](../images/pg431_Image_670.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg431_Image_670.jpg)'
- en: Not much else about the code has to change (at least for my purposes here).
    The neighbors can still be counted the same way; the difference is that the neighbors’
    `previous` states are counted, and the cell’s new `state` property is updated.
    Encapsulating this logic into a `calculateState()` method that takes `board` as
    an argument might also be beneficial. I’ll leave that as an exercise for you.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其他部分不需要改变（至少对于我这里的目的来说）。邻居的计算方式仍然相同；不同之处在于，邻居的`previous`状态会被计数，单元格的新`state`属性会被更新。将这个逻辑封装到一个以`board`为参数的`calculateState()`方法中，可能也是有益的。我将这个留给你作为练习。
- en: 'The following is the Game of Life logic, adapted for cell objects but excluding
    the `calculateState()` enhancement:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是生命游戏的逻辑，已根据单元格对象进行了调整，但不包括`calculateState()`增强功能：
- en: '![Image](../images/pg432_Image_671.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg432_Image_671.jpg)'
- en: By transforming the cells into objects, numerous possibilities emerge for enhancing
    the cells’ properties and behaviors. For example, what if each cell had a `lifespan`
    property that increments with each cycle and influences its color or shape over
    time? Or imagine if a cell had a `terrain` property that could be `land`, `water`,
    `mountain`, or `forest`. How could a 2D CA integrate into a tile-based strategy
    game or other context?
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将单元格转换为对象，出现了许多增强单元格属性和行为的可能性。例如，假设每个单元格都有一个`lifespan`属性，该属性随着每个周期递增，并随着时间推移影响单元格的颜色或形状？或者，假设单元格有一个`terrain`属性，可能是`land`、`water`、`mountain`或`forest`。二维元胞自动机如何融入基于瓦片的战略游戏或其他场景中？
- en: '**Variations on Traditional CA**'
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**传统元胞自动机的变体**'
- en: Now that I’ve covered the basic concepts, algorithms, and programming strategies
    behind the most famous 1D and 2D CA, it’s time to think about how you might take
    this foundation of code and build on it, developing creative applications of CAs
    in your own work. In this section, I’ll talk through some ideas for expanding
    the features of a CA. Example answers to these exercises can be found on the book’s
    website.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经介绍了最著名的一维和二维元胞自动机的基本概念、算法和编程策略，是时候思考如何在这个代码基础上进行扩展，开发出自己工作中的创意应用。在本节中，我将讨论一些扩展元胞自动机功能的想法。有关这些习题的示范答案，请访问本书的官方网站。
- en: '**Nonrectangular Grids**'
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**非矩形网格**'
- en: There’s no particular reason to limit yourself to placing your cells in a rectangular
    grid. What happens if you design a CA with another type of shape?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要将单元格局限于放置在矩形网格中。如果你设计一个使用其他形状的元胞自动机会发生什么？
- en: '![Image](../images/pencil.jpg) **Exercise 7.8**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **习题 7.8**'
- en: Create a CA using a grid of hexagons (as shown here), each with six neighbors.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用六边形网格（如图所示）创建一个元胞自动机，每个六边形有六个邻居。
- en: '![Image](../images/pg433_Image_672.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg433_Image_672.jpg)'
- en: As a hint, you can use polar-to-Cartesian coordinate conversion to find the
    six vertices of a hexagon!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你可以使用极坐标到笛卡尔坐标的转换来找到六边形的六个顶点！
- en: '[PRE14]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Probabilistic**'
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**概率性**'
- en: The rules of a CA don’t necessarily have to define an exact outcome.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 元胞自动机的规则不一定需要定义一个确定的结果。
- en: '![Image](../images/pencil.jpg) **Exercise 7.9**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **习题 7.9**'
- en: 'Rewrite the Game of Life rules as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式重写生命游戏的规则：
- en: 'Overpopulation: If the cell has four or more living neighbors, it has an 80
    percent chance of dying.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过度拥挤：如果单元有四个或更多的生存邻居，它有80%的概率死亡。
- en: 'Loneliness: If the cell has one or fewer living neighbors, it has a 60 percent
    chance of dying.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 孤独：如果单元有一个或更少的生存邻居，它有60%的概率死亡。
- en: Or make up your own probabilistic rules!
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以自己编写概率规则！
- en: '**Continuous**'
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**连续性**'
- en: This chapter has focused on examples with a finite number of discrete cell states—either
    0 or 1\. What if the cell’s state could be any floating-point number from 0 to
    1?
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讨论了具有有限个离散单元状态的示例——状态为0或1。假如单元的状态可以是0到1之间的任何浮动数值，会怎么样呢？
- en: '![Image](../images/pencil.jpg) **Exercise 7.10**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **习题 7.10**'
- en: Adapt the Wolfram elementary CA to have a float state. You could define rules
    such as “If the state is greater than 0.5” or “. . . less than 0.2.”
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使沃尔夫拉姆的基本元胞自动机（CA）适应浮动状态。你可以定义诸如“如果状态大于0.5”或“如果状态小于0.2”这样的规则。
- en: '**Image Processing**'
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**图像处理**'
- en: I briefly touched on this earlier, but many image-processing algorithms operate
    on CA-like rules. For example, blurring an image requires creating a new pixel
    out of the average of a neighborhood of pixels. Simulations of ink dispersing
    on paper or water rippling over an image can also be achieved with CA rules.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前简要提到过这一点，但许多图像处理算法的工作原理类似于元胞自动机规则。例如，模糊图像需要根据像素邻域的平均值创建新的像素。墨水在纸上扩散或水面在图像上泛起涟漪的模拟也可以通过元胞自动机规则来实现。
- en: '![Image](../images/pencil.jpg) **Exercise 7.11**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **习题 7.11**'
- en: Create a CA in which each pixel is a cell and the pixel’s color is its state.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个元胞自动机，其中每个像素是一个单元，且像素的颜色即为其状态。
- en: '**Historical**'
  id: totrans-304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**历史性**'
- en: In the object-oriented Game of Life example, I used two variables to keep track
    of a cell’s current and previous states. What if you use an array to keep track
    of a cell’s state history over a longer period? This relates to the idea of a
    *complex adaptive system*, one that has the ability to change its rules over time
    by learning from its history. (Stay tuned for more on this concept in [Chapters
    9](ch09.xhtml#ch09) and [10](ch10.xhtml#ch10).)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的生命游戏示例中，我使用了两个变量来追踪单元当前和之前的状态。如果你使用数组来追踪单元在较长时间内的状态历史会怎么样？这与*复杂适应系统*的概念有关，即一个可以通过从历史中学习，随着时间的推移改变其规则的系统。（更多关于这个概念的内容，请参见[第9章](ch09.xhtml#ch09)和[第10章](ch10.xhtml#ch10)。）
- en: '![Image](../images/pencil.jpg) **Exercise 7.12**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **习题 7.12**'
- en: Visualize the Game of Life by coloring each cell according to the amount of
    time it has been alive or dead. Can you also use the cell’s history to inform
    the rules?
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 通过根据每个单元生存或死亡的时间长度为其上色来可视化生命游戏。你能否还利用单元的历史来更新规则？
- en: '**Moving Cells**'
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**移动单元**'
- en: In these basic examples, cells have a fixed position on a grid, but you could
    build a CA with cells that have no fixed position and instead move about the canvas.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些基本示例中，单元格在网格上的位置是固定的，但你也可以构建一个元胞自动机，单元没有固定位置，而是可以在画布上移动。
- en: '![Image](../images/pencil.jpg) **Exercise 7.13**'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **习题 7.13**'
- en: Use CA rules in a flocking system. What if each boid has a state (that perhaps
    informs its steering behaviors), and its neighborhood changes from frame to frame
    as it moves closer to or farther from other boids?
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在群体系统中使用元胞自动机（CA）规则。如果每个个体（boid）都有一个状态（可能影响其转向行为），并且随着它靠近或远离其他个体，邻域会从帧到帧发生变化，这会怎样呢？
- en: '**Nesting**'
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**嵌套**'
- en: As discussed in [Chapter 5](ch05.xhtml#ch05), a feature of complex systems is
    that they can be nested. A city is a complex system of people, a person is a complex
    system of organs, an organ is a complex system of cells, and so on. How could
    this be applied to a CA?
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第五章](ch05.xhtml#ch05)所讨论，复杂系统的一个特征是它们可以是嵌套的。城市是一个由人组成的复杂系统，一个人是由器官组成的复杂系统，一个器官是由细胞组成的复杂系统，依此类推。如何将这一点应用到元胞自动机（CA）中？
- en: '![Image](../images/pencil.jpg) **Exercise 7.14**'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **习题 7.14**'
- en: Design a CA in which each cell is a smaller CA.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个元胞自动机（CA），其中每个单元格都是一个较小的元胞自动机（CA）。
- en: '![Image](../images/bird.jpg) **The Ecosystem Project**'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/bird.jpg) **生态系统项目**'
- en: 'Incorporate CA into your ecosystem. Here are some possibilities:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 将元胞自动机（CA）融入到你的生态系统中。以下是一些可能性：
- en: Give each creature a state. How can that state drive its behavior? Taking inspiration
    from CA, how can that state change over time according to its neighbors’ states?
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给每个生物一个状态。这个状态如何驱动它的行为？从元胞自动机（CA）中获取灵感，如何让这个状态根据邻居的状态随时间变化？
- en: Consider the ecosystem’s world to be a CA. The creatures move from tile to tile,
    and each tile has a state. Is it land? Water? Food?
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将生态系统的世界视为一个元胞自动机（CA）。生物从一个方块移动到另一个方块，每个方块都有一个状态。是陆地？水域？食物？
- en: Use a CA to generate a pattern for the design of a creature in your ecosystem.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用元胞自动机（CA）来为你的生态系统中生物的设计生成一个模式。
- en: '![Image](../images/pg436_Image_673.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg436_Image_673.jpg)'
