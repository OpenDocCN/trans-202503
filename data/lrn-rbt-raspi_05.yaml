- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: AVOIDING OBSTACLES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 避免障碍物
- en: NOW YOU CAN CONTROL HOW YOUR ROBOT MOVES, AND THAT’S PRETTY COOL! BUT WOULDN’T
    IT BE COOLER STILL TO GET YOUR ROBOT TO CONTROL ITSELF?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以控制你的机器人如何移动，这已经很酷了！但如果让你的机器人自行控制自己，不是更酷吗？
- en: You may have noticed that your little two-wheeler is quite vulnerable to all
    kinds of hazards while it’s running around the floor. Crashing into walls and
    other objects can be very annoying and even dangerous to your hardware. In this
    chapter, I’ll show you how to enable your robot to autonomously detect and avoid
    obstacles. We’ll cover the theory behind obstacle detection and how to use the
    sensor you’ll need.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，你的小两轮在地板上跑时容易受到各种危害的影响。撞到墙壁和其他物体不仅令人烦恼，甚至可能对硬件造成危险。在本章中，我将向你展示如何让你的机器人能够自主地检测并避开障碍物。我们将讲解障碍物检测的原理以及如何使用你所需要的传感器。
- en: OBSTACLE DETECTION
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 障碍物检测
- en: 'In order for your robot to avoid obstacles, it will first need to be able to
    sense them. In electronics we use specialized sensors for this purpose. There’s
    a variety of ways to implement obstacle detection using sensors. At the hobbyist
    level, there are two main approaches: digital detection and analog detection.
    Digital detection is excellent at sensing obstacles within a certain range, but
    it can’t determine the distance to that obstacle. Analog detection, on the other
    hand, can do both, so that’s what we’ll use here to make our robot extra intelligent.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你的机器人能够避开障碍物，它首先需要能够感知这些障碍物。在电子学中，我们使用专门的传感器来完成这个任务。使用传感器实现障碍物检测有多种方法。在业余爱好者层面，有两种主要方法：数字检测和模拟检测。数字检测非常擅长在特定范围内感知障碍物，但无法确定与障碍物之间的距离。而模拟检测则能同时做到这两点，这也是我们在这里使用的方法，以使我们的机器人更加智能。
- en: Using Ultrasonic Sensors for Analog Object Detection
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用超声波传感器进行模拟物体检测
- en: The HC-SR04 ultrasonic sensor (seen in [Figure 5-1](ch05.xhtml#ch05fig1)) uses
    ultrasonic sound to determine the distance between the sensor and an object. The
    sensor works in much the same way that bat and dolphin sonar works in the natural
    world, and submarine sonar works in the not-so-natural world.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: HC-SR04 超声波传感器（如[图 5-1](ch05.xhtml#ch05fig1)所示）利用超声波来测量传感器与物体之间的距离。该传感器的工作原理与自然界中的蝙蝠和海豚声纳以及非自然界中的潜艇声纳相似。
- en: '![image](../images/f104-01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f104-01.jpg)'
- en: '**FIGURE 5-1** The HC-SR04 ultrasonic distance sensor'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5-1** HC-SR04 超声波距离传感器'
- en: Sound can be modeled as a wave with varying wavelength. Only a small range of
    the sound spectrum is audible to the human ear. Any sound waves with a frequency
    above this range (20 kHz+) are *ultrasound* waves. Ultrasonic distance sensors
    are designed to sense object proximity using ultrasound reflection. A sonar system
    like this sends out waves that bounce off obstacles. A receiver then detects the
    returning sound waves. Ultrasound is accurate within short distances (around a
    few meters) and is inaudible to humans.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 声音可以被建模为波动，具有不同的波长。人耳只能听到声音频谱中的一小部分范围。任何频率高于此范围（20 kHz+）的声音波都是*超声波*。超声波距离传感器的设计目的是通过超声波反射来感知物体的接近。这种声纳系统发出波，波遇到障碍物后反弹。接收器随后探测回来的声波。超声波在短距离内（大约几米）非常准确，并且人类无法听到。
- en: Understanding How the HC-SR04 Works
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解 HC-SR04 的工作原理
- en: A basic ultrasonic distance sensor like the HC-SR04 is made up of a transmitter,
    a receiver, and some circuitry. The transmitter and the receiver are the speaker-like
    protrusions resembling eyes in [Figure 5-1](ch05.xhtml#ch05fig1).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 像 HC-SR04 这样的基本超声波距离传感器由发射器、接收器和一些电路组成。发射器和接收器是像眼睛一样的扬声器状突起，见[图 5-1](ch05.xhtml#ch05fig1)。
- en: To determine a distance, the transmitter emits a high-frequency ultrasonic sound.
    This sound will bounce off any nearby solid objects and be reflected. The “bounce-back”
    is detected and picked up by the receiver on the HC-SR04.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定距离，发射器发出高频超声波声音。这种声音会反弹并反射到任何附近的固体物体上。反弹的信号会被 HC-SR04 上的接收器探测并接收。
- en: Sound travels through air at a constant speed. At room temperature (20º C/68
    ºF) a sound wave will travel at approximately 343 m/s (meters per second). While
    this is fast, it’s not instantaneous, which means there’s a small time difference
    between when the sound is emitted and when the bounce-back is received. Therefore,
    we can measure the distance by timing how long the signal takes to bounce back
    to the sensor.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 声音在空气中以恒定的速度传播。在室温下（20º C/68 ºF），声音波的传播速度大约为 343 米/秒（m/s）。虽然这个速度很快，但并非瞬时的，这意味着声音发出和反弹接收到之间存在一个小的时间差。因此，我们可以通过计时信号从传感器发出到返回所需的时间来测量距离。
- en: 'The relationship between speed, distance, and time can be summarized as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 速度、距离和时间之间的关系可以总结如下：
- en: '![Image](../images/eq105-01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/eq105-01.jpg)'
- en: 'The speed of an object in meters per second is equal to the distance that object
    has traveled in meters divided by the time it has taken to move that far in seconds.
    We’ll use this equation to figure out the distance. We know the speed of sound
    is constant at 343 m/s, and we can measure how long the sound wave takes to bounce
    off an object, which is the time. If you rearrange the equation to solve for distance,
    you get:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个物体的速度（以米/秒为单位）等于该物体在米中行进的距离除以它所花费的时间（以秒为单位）。我们将使用这个公式来计算距离。我们知道声音的传播速度是恒定的，为
    343 m/s，而且我们可以测量声音波反射回来的时间，也就是所用时间。如果你调整公式来解距离，你就会得到：
- en: '![Image](../images/eq105-02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/eq105-02.jpg)'
- en: This isn’t quite the full story, however. The ultrasonic pulse is emitted, bounces
    off an object, and is received by the HC-SR04, as shown in [Figure 5-2](ch05.xhtml#ch05fig2),
    meaning the sound wave is actually traveling *double* the distance from the sensor
    to the object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是全部。超声波脉冲被发出，碰到物体后反射回来，并被 HC-SR04 接收，如[图 5-2](ch05.xhtml#ch05fig2)所示，这意味着声音波实际上是从传感器到物体的距离*双倍*传播。
- en: '![image](../images/f106-01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f106-01.jpg)'
- en: '**FIGURE 5-2** The HC-SR04 distance-measuring process'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5-2** HC-SR04 距离测量过程'
- en: 'That means we need to divide the time recorded by the ultrasonic distance sensor
    in half, which results in the following equation:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要将超声波距离传感器记录的时间除以二，从而得到以下公式：
- en: '![image](../images/eq106-01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/eq106-01.jpg)'
- en: We have our method, so let’s try it out.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了方法，现在让我们来试试。
- en: MEASURING A SHORT DISTANCE
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测量短距离
- en: Now that you understand the mathematics and theory behind ultrasonic distance
    measurement, it’s time to put everything into practice and measure some distances!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了超声波距离测量背后的数学和原理，是时候将一切付诸实践，测量一些距离了！
- en: The Parts List
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配件清单
- en: 'In addition to the breadboard you already have on your Raspberry Pi robot,
    you’ll need the following components:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你在树莓派机器人上已经拥有的面包板，你还需要以下组件：
- en: An HC-SR04 ultrasonic sensor
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 HC-SR04 超声波传感器
- en: A 1 kΩ resistor
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 1 kΩ 电阻
- en: A 2 kΩ resistor
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 2 kΩ 电阻
- en: Jumper wires
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: Inexpensive HC-SR04 sensors are widely available through the usual online retailers.
    Just search “HC-SR04;” you shouldn’t have to spend more than a few dollars on
    one.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 价格便宜的 HC-SR04 传感器在常见的在线零售商处广泛销售。只需搜索“HC-SR04”，你应该不用花超过几美元就能买到一个。
- en: 'Any digital system has two logic states: low voltage (0) and high voltage (1).
    This was first introduced in [Chapter 4](ch04.xhtml) when explaining PWM. Usually,
    the low voltage is just ground, 0 V; however, the high voltage can change from
    system to system. This means that some systems require a 5 V signal to trigger
    a high voltage, while others may require only 3.3 V, for example. This just so
    happens to be the situation we are in! The HC-SR04 requires 5 V, whereas your
    Raspberry Pi operates on 3.3 V logic. Notice in [Figure 5-3](ch05.xhtml#ch05fig3)
    that there are four pins on the ultrasonic sensor: *Vcc* for power, *Trig* for
    the trigger pulse, *Echo* for the echo pulse, and finally *Gnd* for ground.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数字系统都有两种逻辑状态：低电压（0）和高电压（1）。这在[第4章](ch04.xhtml)解释 PWM 时首次引入。通常，低电压就是地线，0 V；然而，高电压可能会因系统而异。这意味着一些系统需要
    5 V 信号才能触发高电压，而其他系统可能只需要 3.3 V。例如，这正是我们所面临的情况！HC-SR04 需要 5 V，而你的树莓派使用 3.3 V 逻辑。请注意，在[图
    5-3](ch05.xhtml#ch05fig3)中，超声波传感器上有四个引脚：*Vcc* 为电源，*Trig* 为触发脉冲，*Echo* 为回声脉冲，最后是
    *Gnd* 为地。
- en: '![image](../images/f107-01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f107-01.jpg)'
- en: '**FIGURE 5-3** A close-up of the pins on an HC-SR04 module'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5-3** HC-SR04 模块引脚的特写'
- en: You’ll need to power the module using a 5 V source on the Vcc pin. When the
    HC-SR04 receives the bounce-back pulse, the Echo pin is set to a 5 V logic high,
    but if we were to connect this directly to the Raspberry Pi, the high voltage
    would cause serious damage. To avoid this, you’ll need to lower the sensor output
    voltage to something your Raspberry Pi can handle—that’s where the 1 kΩ and 2
    kΩ resistors come in handy. We’re going to use them to build a *voltage divider*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用5V电源为模块供电，接到Vcc引脚。当HC-SR04接收到反射回来的脉冲时，Echo引脚会设为5V高电平。但如果我们将这个直接连接到树莓派上，高电压会造成严重损坏。为避免这种情况，你需要将传感器的输出电压降低到树莓派能够承受的范围——这就是1
    kΩ和2 kΩ电阻派上用场的地方。我们将用它们来搭建一个*电压分压器*。
- en: Reducing Voltage with Voltage Dividers
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用电压分压器降低电压
- en: A *voltage divider* is a simple circuit that turns a larger voltage into a smaller
    one. The voltage divider takes an input voltage and uses two resistors in series
    to reduce and output that voltage. You use different values of resistors to make
    the output voltage a certain fraction of the input voltage.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*电压分压器* 是一种简单的电路，它将较大的电压转换为较小的电压。电压分压器接受输入电压，使用两个串联的电阻来降低并输出电压。你可以选择不同值的电阻，使输出电压成为输入电压的某一比例。'
- en: The voltage divider circuit is shown in [Figure 5-4](ch05.xhtml#ch05fig4). Notice
    that the output voltage is drawn from between the two resistors.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 电压分压电路如[图 5-4](ch05.xhtml#ch05fig4)所示。注意，输出电压是从两个电阻之间取出的。
- en: '![image](../images/f108-01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f108-01.jpg)'
- en: '**FIGURE 5-4** A voltage divider circuit'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5-4** 电压分压电路'
- en: 'As with most electronics, we use an equation to mathematically relate the two
    resistors (*R*[1] and *R*[2]) to the input and output voltages (*V*[in] and *V*[out]).
    Physicists don’t mince words, so the equation is simply called the *voltage divider
    equation*:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数电子设备一样，我们使用一个方程来将两个电阻（*R*[1] 和 *R*[2]）与输入和输出电压（*V*[in] 和 *V*[out]）数学关联起来。物理学家言简意赅，所以这个方程被直接称为
    *电压分压方程*：
- en: '![image](../images/eq108-01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/eq108-01.jpg)'
- en: Using this equation, you can work out the exact *R*[1] and *R*[2] resistor values
    you need to create the desired output voltage. The size of *R*[1] and *R*[2] is
    actually irrelevant; what matters instead is the *ratio* of *R*[1] and *R*[2].
    For example, if *R*[1] and *R*[2] are equal, then the output voltage will be half
    the input voltage.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个公式，你可以计算出所需的 *R*[1] 和 *R*[2] 电阻值，以产生所需的输出电压。*R*[1] 和 *R*[2] 的具体数值其实并不重要，重要的是它们之间的*比例*。例如，如果
    *R*[1] 和 *R*[2] 相等，那么输出电压将是输入电压的一半。
- en: WARNING
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '*No matter what resistor values you end up with, it’s always better to have
    an output voltage that is lower than the target, rather than higher. This is because
    a lower voltage will not harm your Raspberry Pi or other electronics, whereas
    a voltage that is too high, even by a small margin, may do so.*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*无论你最后得到什么电阻值，最好使输出电压低于目标电压，而不是高于目标电压。这是因为较低的电压不会损坏你的树莓派或其他电子设备，而稍微高一点的电压就可能会造成损坏。*'
- en: 'Let’s use this equation to work out what resistor values we need for the distance
    sensor on our robot. You know that the input voltage is 5 V, and the desired output
    voltage is 3.3 V, so we have two unknowns in the equation: *R*[1] and *R*[2].
    You can pick a common resistor value for one and that gives us just one unknown,
    which is much easier to work out. Let’s choose 1 kΩ for *R*[1]. By rearranging
    the equation to solve for *R*[2], you get:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用这个公式来计算我们机器人距离传感器所需的电阻值。已知输入电压为5V，所需的输出电压为3.3V，因此方程中有两个未知数：*R*[1] 和 *R*[2]。你可以选择一个常见的电阻值来确定其中一个，剩下的就只有一个未知数，这样就更容易计算了。我们选择1
    kΩ作为 *R*[1]。通过重新排列方程并解出 *R*[2]，你会得到：
- en: '![image](../images/eq108-02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/eq108-02.jpg)'
- en: 'If you plug in the numbers that you know, *R*[2] works out like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你代入已知的数值，*R*[2] 会按如下方式计算：
- en: '![image](../images/eq108-03.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/eq108-03.jpg)'
- en: Finding a resistor with the exact value 1941.176471 Ω is going to be very tricky!
    So instead we’ll just pick the nearest common resistor value. In our case, a 2
    kΩ or 2.2 kΩ resistor will suffice. If in doubt, try to find a resistor that’s
    nearest, but slightly *lower* than, the value you need. You can always put your
    two resistor values back into the equation to work out the output voltage with
    that pair if you want to double-check.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个精确值为 1941.176471 Ω 的电阻器将非常困难！所以我们将选择最接近的常见电阻值。在我们的情况下，2 kΩ 或 2.2 kΩ 电阻就足够了。如果有疑问，尝试找到一个接近但稍微*低于*所需值的电阻器。如果需要，你可以将这两个电阻值重新代入方程式，计算出该电阻组合的输出电压，以便进行二次检查。
- en: Wiring Up Your HC-SR04
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 接线你的 HC-SR04
- en: Now that you have all your necessary components, you can wire up your distance
    sensor. As always, ensure your Pi and robot’s power are disconnected before you
    start fiddling around with the wiring and connecting new things.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了所有必要的组件，可以开始接线你的距离传感器了。和往常一样，在开始操作接线和连接新组件之前，确保你的 Pi 和机器人电源已经断开。
- en: 'Rather than plug the HC-SR04 module directly into a breadboard, we’ll connect
    it using long jumper wires so you can position the distance sensor anywhere on
    your robot. Using your build from the previous chapter that has the motors wired
    up, follow these instructions, but don’t attach the sensor to the robot chassis
    just yet:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会直接将 HC-SR04 模块插入面包板，而是通过长跳线连接，这样你可以将距离传感器放置在机器人上的任何位置。使用上一章中已经接好电机的构建，按照这些说明进行操作，但暂时不要将传感器安装到机器人底盘上：
- en: Use a long jumper wire to connect the Vcc pin of your HC-SR04 to the Pi’s +5
    V power rail on your breadboard.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一根长跳线将 HC-SR04 的 Vcc 引脚连接到你的面包板上的 Pi +5 V 电源轨。
- en: Use another long jumper wire to connect the Gnd pin of your HC-SR04 to the ground
    rail on your breadboard. At this point your wiring should look like [Figure 5-5](ch05.xhtml#ch05fig5).
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用另一根长跳线将 HC-SR04 的 Gnd 引脚连接到面包板上的接地轨。此时你的接线应该像 [图 5-5](ch05.xhtml#ch05fig5)
    所示。
- en: '![image](../images/f109-01.jpg)'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f109-01.jpg)'
- en: '**FIGURE 5-5** HC-SR04 module connected to +5 V and ground. The motor controller
    chip and motors are omitted from the diagram, but you should keep them connected
    to your circuit. The orange stripes represent the area the L293D chip and its
    wiring takes up.'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 5-5** HC-SR04 模块连接到 +5 V 和接地。电机控制芯片和电机在图中省略，但你应该将它们保持连接到电路中。橙色条纹表示 L293D
    芯片及其接线所占的区域。'
- en: Next, use a wire to connect the Trig pin of your HC-SR04 directly to physical
    pin 16 on your Raspberry Pi. Pin 16 on the Pi is also called BCM 23.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用一根线将 HC-SR04 的 Trig 引脚直接连接到 Raspberry Pi 的物理引脚 16。Pi 的引脚 16 也被称为 BCM 23。
- en: Then attach a jumper wire from the Echo pin of your sensor to a new row on your
    breadboard. Connect a 1 kΩ resistor by putting one leg of the resistor into the
    same row as the Echo pin and the other leg of the resistor into a different, unused
    row of your breadboard. At this point your wiring should look like [Figure 5-6](ch05.xhtml#ch05fig6).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将跳线从传感器的 Echo 引脚连接到面包板上的新行。在同一行中插入一个 1 kΩ 电阻器，一端插入 Echo 引脚所在的行，另一端插入面包板上另一个未使用的行。此时你的接线应该像
    [图 5-6](ch05.xhtml#ch05fig6) 所示。
- en: '![image](../images/f110-01.jpg)'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f110-01.jpg)'
- en: '**FIGURE 5-6** The Trig pin of the HC-SR04 connected to BCM 23 and the Echo
    pin connected to a 1 kΩ resistor'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 5-6** HC-SR04 的 Trig 引脚连接到 BCM 23，Echo 引脚连接到 1 kΩ 电阻器'
- en: Wire up physical pin 18 (BCM 24) of your Raspberry Pi to the row with the other
    leg of the 1 kΩ resistor you just connected.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Raspberry Pi 的物理引脚 18（BCM 24）接到你刚刚连接的 1 kΩ 电阻器另一端的行。
- en: Finally, place one leg of your 2 kΩ/2.2 kΩ resistor in the row with the 1 kΩ
    resistor and jumper wire to your Pi’s BCM 24 pin, and place the other leg of this
    resistor in a ground rail. The complete circuit on your breadboard should look
    something like [Figure 5-7](ch05.xhtml#ch05fig7).
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将 2 kΩ/2.2 kΩ 电阻的一端插入与 1 kΩ 电阻和跳线相连的行，另一端连接到 Pi 的 BCM 24 引脚，并将此电阻的另一端接到接地轨。面包板上的完整电路应该像
    [图 5-7](ch05.xhtml#ch05fig7) 所示。
- en: '[Figure 5-8](ch05.xhtml#ch05fig8) shows a circuit diagram of the final outcome.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-8](ch05.xhtml#ch05fig8) 显示了最终结果的电路图。'
- en: '![image](../images/f111-01.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f111-01.jpg)'
- en: '**FIGURE 5-7** The completed breadboard diagram with the HC-SR04 and voltage
    divider in place'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5-7** 完整的面包板电路图，其中包含了 HC-SR04 和电压分压器'
- en: '![image](../images/f111-02.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f111-02.jpg)'
- en: '**FIGURE 5-8** A circuit diagram of the HC-SR04 connected to a Raspberry Pi'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5-8** HC-SR04 连接到 Raspberry Pi 的电路图'
- en: Programming Your Raspberry Pi to Read Distance
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编程你的树莓派读取距离
- en: 'With your ultrasonic distance sensor now wired up, it’s time to delve into
    some more Python code to use the sensor. Boot up your Raspberry Pi from a wall
    outlet, log in, and locate the *robot* folder you’re saving your programs in.
    Create a new program called *distance_test.py* with this command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的超声波距离传感器已经接好电路，是时候深入一些Python代码来使用这个传感器了。从墙壁插座启动你的树莓派，登录后，找到保存程序的*robot*文件夹。使用以下命令创建一个名为*distance_test.py*的新程序：
- en: pi@raspberrypi:~/robot $ nano distance_test.py
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ nano distance_test.py
- en: In this project, we’ll still use the GPIO Zero Python library, but we’ll move
    away from the built-in functions and objects. Instead, I’ll show you how to program
    and operate the HC-SR04 entirely from scratch!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们仍然使用GPIO Zero Python库，但我们将远离内置函数和对象。相反，我将向你展示如何从头开始编程和操作HC-SR04！
- en: The code in [Listing 5-1](ch05.xhtml#ch05list1) will send out a signal, also
    known as a *ping*, and then read and print out the distance of the first object
    the signal meets. Save this code into the *distance_test.py* you have already
    open. Try to use your programming skills to read through and decipher it before
    moving on to my explanation!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 5-1](ch05.xhtml#ch05list1)中的代码将发送出一个信号，也就是所谓的*ping*，然后读取并打印出信号遇到的第一个物体的距离。将这段代码保存到你已打开的*distance_test.py*文件中。尝试用你的编程技能阅读并解读它，然后再继续我的解释！'
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**LISTING 5-1** Program to measure a single distance'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**LISTING 5-1** 用于测量单一距离的程序'
- en: As usual, we begin by importing the `gpiozero` and `time` libraries for use
    throughout the code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们首先导入`gpiozero`和`time`库，以便在代码中使用。
- en: At ➊ and on the following line, we create two variables, `TRIG` and `ECHO`,
    which simply store the pin number that the Trig and Echo pins are connected to,
    respectively. We capitalize these variables to indicate that they are *constants*—variables
    whose values we want to keep the same for the duration of the program.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊和接下来的行中，我们创建了两个变量，`TRIG`和`ECHO`，它们分别存储连接到Trig和Echo引脚的引脚编号。我们将这些变量大写，以表示它们是*常量*——我们希望在程序运行期间保持不变的变量。
- en: Capitalizing constants is a programming convention that tells you, and anyone
    else reading the code, that these values are not changed throughout the execution
    of the program. It’s worth stressing that because this is a convention, it’s merely
    a practice that most programmers do, not one enforced by Python. The code would
    work equally well if these were lowercase, or even a mixture of cases.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 大写常量是编程约定，告诉你和任何阅读代码的人，这些值在程序执行过程中不会改变。值得强调的是，虽然这是一种约定，但它仅仅是大多数程序员的做法，而不是Python强制要求的。即使这些常量使用小写字母，或者大小写混合，代码仍然能正常工作。
- en: The following two lines ➋ set up the GPIO pins connected to the Trig and Echo
    pins of the HC-SR04\. We set up the `trigger` variable to be an output, since
    it’s sending out a ping, and `echo` as an input, since it’s receiving a ping.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两行 ➋ 设置了连接到HC-SR04的Trig和Echo引脚的GPIO引脚。我们将`trigger`变量设置为输出，因为它发送ping信号，而将`echo`设置为输入，因为它接收ping信号。
- en: 'To trigger the ping, the HC-SR04 sensor needs a quick 10 µs (1 µs is a millionth
    of a second: 0.000001 s) pulse that takes place in the next chunk of code ➌.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了触发ping信号，HC-SR04传感器需要一个快速的10 µs脉冲（1 µs是百万分之一秒：0.000001秒），这个脉冲将在接下来的代码段 ➌ 中执行。
- en: When the ping has been sent out by the transmitter, the program must wait for
    the ping to clear the receiver before it starts listening for the echo. This is
    because the transmitter and the receiver on the HC-SR04 are close together, so
    in the microseconds after transmission, the sensor can hear the outgoing pulse.
    We don’t want to record the outgoing pulse accidentally, so we tell the program
    to wait until it hears the echo *and not* the original ping. You can think of
    this as if you and a friend were standing next to each other in a large room and
    you wanted to listen for an echo. If you were to shout “Hello!” your friend would
    hear you *before* you heard the echo from the room. This sort of effect is what
    we must avoid when using the HC-SR04.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当发射器发送出ping信号时，程序必须等待ping信号清除接收器，然后才开始监听回声。这是因为HC-SR04的发射器和接收器非常接近，因此在发射后的一段微秒时间内，传感器可能会听到发出的脉冲。我们不希望不小心记录下发射脉冲，因此我们告诉程序，直到它听到回声，而不是原始的ping信号时，才开始接收。这就像是你和朋友站在一个大房间里，你们想听回声。如果你大声喊“你好！”，你的朋友会在你听到回声之前就听到你的声音。这种效应是我们在使用HC-SR04时必须避免的。
- en: The next section of the code is responsible for making sure we pick up the echo.
    The `while` loop ➍ with the condition `echo.is_active == False` repeats until
    the outgoing pulse is no longer heard by the sensor. The program then stores the
    exact time the pulse clears the receiver in a new variable called `pulse_start`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的下一部分负责确保我们能够接收到回声。`while` 循环➍，其条件是 `echo.is_active == False`，会一直重复，直到传出的脉冲不再被传感器接收到。程序随后将脉冲清除接收器的准确时间存储在一个名为
    `pulse_start` 的新变量中。
- en: With the outgoing pulse now out of the way, the `while` loop with the condition
    `echo.is_active == True` ➎ catches the echo when it returns to the sensor. A second
    variable called `pulse_end` is created and is used to record the exact time of
    the bounce-back pulse.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于传出的脉冲已经被移除，`while` 循环，条件是 `echo.is_active == True` ➎，会在回声返回到传感器时捕获它。此时创建了第二个变量
    `pulse_end`，用于记录回声脉冲的准确时间。
- en: Then we simply subtract the time the ping was sent out from the time it was
    received to work out how long it took to return. We store the result in a variable
    called `pulse_duration` ➏.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需从接收到信号的时间中减去发送信号的时间，就能计算出回声返回所花费的时间。我们将结果存储在名为 `pulse_duration` ➏ 的变量中。
- en: 'Arguably the most important part of this program is at ➐ where we work out
    the distance from the time it has taken for the ping to return. We apply the earlier
    equation to the values we’ve collected in the program:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，这个程序最重要的部分是 ➐，我们根据回声返回所花费的时间来计算距离。我们将之前的公式应用到程序中收集到的数值：
- en: '![image](../images/eq114-01.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/eq114-01.jpg)'
- en: Rather than use the 343 m/s figure that is the speed of sound, we multiply it
    by 100 to give us a distance value in centimeters, which is much more relevant
    to the sorts of distances your robot will be dealing with.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有使用343 m/s这个声速值，而是将其乘以100，以便得到一个以厘米为单位的距离值，这对于你的机器人处理的距离更为相关。
- en: Finally, in the last few lines of the program, we round the distance value to
    one decimal place and then output it to the terminal.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在程序的最后几行，我们将距离值四舍五入到小数点后一位，然后将其输出到终端。
- en: 'Running Your Program: Measure a Short Distance'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行你的程序：测量短距离
- en: Now that you have the code finished, it’s time to test out the ultrasonic distance
    sensor and its accuracy.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了代码，是时候测试超声波距离传感器及其准确性了。
- en: Place your HC-SR04 parallel to a surface, like a table. Then place a fairly
    small solid object in front of the sensor and measure the distance with a ruler.
    In [Figure 5-9](ch05.xhtml#ch05fig9), I’m using an upright box. My box is roughly
    20 cm away from my HC-SR04.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的 HC-SR04 平行放置在一个表面上，比如桌子。然后在传感器前面放置一个相对较小的固体物体，并用直尺测量距离。在 [图 5-9](ch05.xhtml#ch05fig9)
    中，我使用的是一个竖直的盒子。我的盒子大约距离 HC-SR04 20 厘米。
- en: '![image](../images/f114-01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f114-01.jpg)'
- en: '**FIGURE 5-9** My HC-SR04 test setup'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5-9** 我的 HC-SR04 测试设置'
- en: 'As ever, to run your program, enter:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，要运行你的程序，请输入：
- en: pi@raspberrypi:~/robot $ python3 distance_test.py
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ python3 distance_test.py
- en: 'After a short period, a single distance reading should print to your terminal
    and the program will end. For me this looks like the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间后，应该会在终端显示单个距离读数，程序将结束。对我来说，输出结果如下所示：
- en: pi@raspberrypi:~/robot $ python3 button.py
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ python3 button.py
- en: 'Distance: 20.1'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 距离：20.1
- en: Your HC-SR04 should have successfully measured the space between itself and
    the object! Mine was pretty accurate, but you shouldn’t expect 100 percent accuracy
    with these readings.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 HC-SR04 应该已经成功测量了它与物体之间的距离！我的测量结果相当准确，但你不应该期望这些读数的准确性达到百分之百。
- en: 'If your reading was off by a large margin, try running the program again to
    see if that output was just an outlier. If you’re still getting wrong readings,
    check the numbers and equations in your program: are the values correct and have
    you applied the math in the right way? If the program hangs (does nothing) and
    never finishes executing, check that your wiring is correct and refer to the instructions
    earlier in the chapter. Your program may also hang if it never receives an echo.
    This could be because the distance you’re trying to measure is out of range. However,
    for indoor use you shouldn’t have any problems.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的读数偏差较大，尝试重新运行程序，看看该输出是否只是一个异常值。如果你仍然得到错误的读数，检查程序中的数字和公式：数值是否正确，数学是否应用正确？如果程序停滞不前（无反应）且永远不会完成执行，检查你的电线是否连接正确，并参考章节前面的说明。如果程序没有接收到回声，它也可能会停滞不前。这可能是因为你试图测量的距离超出了范围。然而，室内使用时应该不会出现问题。
- en: Finally, if you’re still having issues, consult the code and make sure it’s
    exactly the same as the program in [Listing 5-1](ch05.xhtml#ch05list1). As usual,
    you can grab the exact code examples from [*https://nostarch.com/raspirobots/*](https://nostarch.com/raspirobots/).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你仍然遇到问题，可以查阅代码，确保它与你在[清单 5-1](ch05.xhtml#ch05list1)中的程序完全相同。像往常一样，你可以从[*https://nostarch.com/raspirobots/*](https://nostarch.com/raspirobots/)获取确切的代码示例。
- en: MAKE YOUR ROBOT AVOID OBSTACLES
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让你的机器人避开障碍物
- en: Now that you have mastered measuring individual distances with an ultrasonic
    distance sensor, you can mount the sensor onto your robot and write a new program
    that will use the HC-SR04 to avoid obstacles.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了使用超声波传感器测量单个距离的技巧，你可以将传感器安装到你的机器人上，并编写一个新程序，使用HC-SR04来避开障碍物。
- en: By the end of this project, you’ll have a fully autonomous obstacle-avoider!
    The aim here is to make sure your Raspberry Pi robot gets no closer than 15 cm
    to any object before it takes evasive action.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个项目结束时，你将拥有一个完全自主的避障机器人！目标是确保你的树莓派机器人在采取回避动作之前，离任何物体的距离不小于15厘米。
- en: Mounting Your HC-SR04 Ultrasonic Sensor
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装你的HC-SR04超声波传感器
- en: The best place to mount your distance sensor is on the front of the robot in
    a location that is as central as possible. I recommend using sticky tack or double-sided
    tape to affix it. The module can sense distance only in a direct straight line,
    so don’t mount it too high above the floor or your robot is likely to crash into
    low-lying obstacles.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 安装距离传感器的最佳位置是机器人前方，尽量选择一个尽可能居中的位置。我推荐使用粘性胶粘物或双面胶带固定传感器。该模块只能在直接的直线范围内感知距离，因此不要将其安装得离地面太高，否则你的机器人很可能会撞到低矮的障碍物。
- en: 'I have mounted my HC-SR04 on the front stabilizer, as shown in [Figure 5-10](ch05.xhtml#ch05fig10).
    The sensor is about a centimeter off the ground. Note that the orientation of
    your sensor also doesn’t matter: mine is upside down!'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我将我的HC-SR04安装在前方稳定器上，如[图 5-10](ch05.xhtml#ch05fig10)所示。传感器离地面大约一厘米。请注意，传感器的方向也无关紧要：我的安装方式是倒过来的！
- en: '![image](../images/f116-01.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f116-01.jpg)'
- en: '**FIGURE 5-10** My HC-SR04 mounted to the front of my robot'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5-10** 我将HC-SR04安装在我的机器人前方'
- en: Programming Your Robot to Avoid Obstacles
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写程序使你的机器人避开障碍物
- en: To create the obstacle avoidance program, we’ll borrow heavily from the prior
    section’s code but set the distance sensor to constantly scan for upcoming obstacles.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建避障程序，我们将大量借用前一节的代码，但将距离传感器设置为持续扫描即将到来的障碍物。
- en: In [Listing 5-1](ch05.xhtml#ch05list1), we worked out how to measure a single
    distance in 10 lines of code. In our next program, we’ll need to repeat the code
    continuously to get a constantly refreshing distance from your robot to any upcoming
    obstacles. We could write out the code every time we need to use it, but that
    sounds time-consuming and dull, and we don’t even know how many times we’d need
    to write it out. Instead, there is a way to package up code so you can use it
    whenever and wherever you need it. Packaging up code like this creates what is
    known as a *function*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 5-1](ch05.xhtml#ch05list1)中，我们编写了10行代码来测量单个距离。在接下来的程序中，我们需要持续重复这段代码，以便不断刷新机器人与任何即将到来的障碍物之间的距离。我们可以每次需要时都写出这段代码，但那样既费时又单调，而且我们也不知道需要写多少次。相反，有一种方法可以将代码打包，这样你就可以在任何需要时随时使用它。像这样打包代码创造了所谓的*函数*。
- en: 'A Python function is a block of organized, reusable code that performs an action.
    Let’s try it out: enter the code for the obstacle avoidance program in [Listing
    5-2](ch05.xhtml#ch05list2) and save it as *obstacle_avoider.py* on your Raspberry
    Pi.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Python函数是一个组织好的、可重用的代码块，它执行某个操作。让我们来试试：输入[清单 5-2](ch05.xhtml#ch05list2)中的避障程序代码，并将其保存为*obstacle_avoider.py*文件在你的树莓派上。
- en: '[PRE1]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**LISTING 5-2** Obstacle avoidance program'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 5-2** 避障程序'
- en: This program begins by importing the necessary libraries. Then, you identify
    ➊ and set up ➋ the Trig and Echo pins of the HC-SR04 like you did in [Listing
    5-1](ch05.xhtml#ch05list1). This also initializes the robot for use.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序首先导入必要的库。然后，你像在[清单 5-1](ch05.xhtml#ch05list1)中那样设置HC-SR04的Trig和Echo引脚，标记➊并设置➋。这也初始化了机器人以供使用。
- en: At ➌, you meet your first Python function, which is organized into a code block.
    To start a function block, you use the keyword `def`. This is short for *define*,
    as you are defining what the block of code should do.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在第➌步，你将遇到第一个Python函数，它以代码块的形式组织。要开始一个函数块，你使用关键词`def`。这是*define*的缩写，因为你在定义代码块应该执行的功能。
- en: After `def`, you enter the name of the function, which, like a variable, can
    be called anything (provided it doesn’t start with a number). It is best to keep
    your function names short and to the point. The purpose of this function is to
    trigger the sensor and return a distance measurement, so I’ve called this function
    `get_distance()`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`def`之后，输入函数的名称，像变量一样，它可以是任何名字（前提是不能以数字开头）。最好保持函数名称简短、直观。这个函数的目的是触发传感器并返回距离测量，因此我将这个函数命名为`get_distance()`。
- en: Parentheses follow a function name, and the contents of such parentheses are
    referred to as the function’s *parameters* or *arguments*. These parameters allow
    us to pass information into a function for later use. In our case, we pass the
    trigger and echo pin information we set up earlier, so that the function is able
    to activate and use the HC-SR04 distance sensor.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名称后面跟着括号，括号中的内容被称为函数的*参数*或*实参*。这些参数允许我们将信息传递给函数以供后续使用。在我们的例子中，我们传递了之前设置的触发器和回声引脚信息，这样函数就能够激活并使用HC-SR04距离传感器。
- en: As with `while` and `for` loops, you need to indent the code inside the function
    so Python knows what code belongs to the function. The indented code begins at
    ➍ and extends to ➎, and it is *exactly* the same as the code you used to get a
    distance reading in [Listing 5-1](ch05.xhtml#ch05list1).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与`while`和`for`循环一样，你需要对函数内部的代码进行缩进，这样Python就知道哪些代码属于该函数。缩进代码从➍开始，到➎结束，并且它与[清单5-1](ch05.xhtml#ch05list1)中用于获取距离读取的代码*完全*相同。
- en: 'At ➎ the code *returns* the final output of the function: the distance reading.
    Returning information just means that the output of that function is handed back
    to the program whenever the function is called. This output could then be printed
    to the terminal, set to a variable, or manipulated in any way you, as the coder,
    desire!'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在➎部分，代码*返回*函数的最终输出：距离读取。返回信息意味着每次调用该函数时，函数的输出都会传递回程序。然后这些输出可以打印到终端，赋值给变量，或以你作为编程者希望的任何方式进行处理！
- en: We then start an infinite `while` loop. First we call the `get_distance()` function
    and store its result in the variable `dist` ➏.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们启动一个无限`while`循环。首先我们调用`get_distance()`函数，并将结果存储在变量`dist`中➏。
- en: 'Next, we introduce the crucial obstacle-avoiding logic with a conditional `if`
    statement ➐. This line translates to: “if the distance between the sensor and
    an obstacle is less than 15 cm, do the following.” If the condition is true, the
    two lines inside the statement run and turn the robot slowly right for a quarter
    of a second.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过一个条件`if`语句➐引入了关键的避障逻辑。这行代码的意思是：“如果传感器与障碍物之间的距离小于15厘米，执行以下操作。”如果条件成立，语句中的两行代码会执行，使机器人慢慢向右转动，持续四分之一秒。
- en: Finally, the code at ➑ deals with any other scenario. If an obstacle is further
    than 15 cm away, the robot proceeds forward slowly for a tenth of a second. Obstacle-avoiding
    programs usually work better when the robot is moving at a slower speed, so we
    set the robot at 30 percent of its full speed with the `(0.3)` argument here.
    If you find this is too slow or too fast for your particular build, feel free
    to increase or decrease the values inside the parentheses of the motor commands.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码中的➑部分处理任何其他情况。如果障碍物距离传感器超过15厘米，机器人会继续慢慢前进，持续十分之一秒。避障程序通常在机器人以较慢速度行驶时效果更好，因此我们在此通过`(0.3)`参数将机器人的速度设为其最大速度的30%。如果你发现这个速度对你构建的机器人来说太慢或太快，可以随意增加或减少电机命令中的括号内的值。
- en: 'Running Your Program: Make Your Robot Avoid Obstacles'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行你的程序：让你的机器人避开障碍物
- en: Now that the final piece of code is finished, I recommend clearing a suitably
    large area and then strategically placing obstacles at the correct height for
    your ultrasonic distance sensor. Take a look at [Figure 5-11](ch05.xhtml#ch05fig11)
    for the course I quickly created for my robot.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在最后一段代码已经完成，建议你清理出一个足够大的区域，然后根据你的超声波距离传感器的正确高度有策略地放置障碍物。可以参考我为我的机器人快速创建的[图5-11](ch05.xhtml#ch05fig11)。
- en: '![image](../images/f119-01.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f119-01.jpg)'
- en: '**FIGURE 5-11** My robot facing down some looming upright folders'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5-11** 我的机器人正面对一些竖立的文件夹'
- en: 'Run your program with the command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行你的程序：
- en: pi@raspberrypi:~/robot $ python3 obstacle_avoider.py
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ python3 obstacle_avoider.py
- en: Your robot should spring to life and proceed forward until it reaches its first
    obstacle, at which point it should turn until the obstacle is clear and then continue
    on its path.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你的机器人应该会活跃起来，向前行驶，直到遇到第一个障碍物，这时它应该转动，直到障碍物被清除，然后继续前进。
- en: Another fun experiment would be to stand in front of your robot and watch it
    scuttle away from you, no matter how many times you move your feet to be in front
    of it!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的实验是站在机器人前面，看看它如何每次都能逃离你，不论你怎么移动双脚站在它前方！
- en: As ever, kill the robot with the command CTRL-C.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，使用 CTRL-C 命令停止机器人。
- en: 'Challenge Yourself: Improve the Obstacle Avoidance Program'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战自我：改进避障程序
- en: Our method of obstacle avoidance here leaves a lot of room for improvement!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的避障方法仍有很大的改进空间！
- en: As mentioned, the HC-SR04 is able to detect distance only in a single straight
    line, so your robot could miss obstacles that are directly in front of it but
    too low or too high for it to sense.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，HC-SR04只能沿单一直线检测距离，因此你的机器人可能会错过直接在它前方、但由于过低或过高而无法感知的障碍物。
- en: Having just one distance sensor is also a limitation. Your robot can detect
    only obstacles that are straight ahead, so it could easily turn right or left
    into another obstacle! The more distance sensors you use, the more information
    the robot has and therefore the more intelligent the running code can be.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个距离传感器也是一个局限。你的机器人只能检测到正前方的障碍物，因此它可能会轻易地向右或向左转，撞上另一个障碍物！你使用的距离传感器越多，机器人获得的信息就越多，因此运行的代码也能变得更智能。
- en: Try to tweak the program in [Listing 5-2](ch05.xhtml#ch05list2) to make your
    robot avoid obstacles as efficiently as possible with one sensor. You could edit
    the minimum distance before evasive maneuvers are taken (the default is 15 cm).
    Or, you could edit the amount of time the motors are on for each evasion or the
    direction you turn. Try out different values in these variables and figure out
    what works best.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整[清单 5-2](ch05.xhtml#ch05list2)中的程序，以使你的机器人尽可能高效地使用一个传感器避开障碍物。你可以编辑在采取回避动作之前的最小距离（默认是
    15 cm）。或者，你可以编辑每次回避时电机开启的时间，或者调整转向的方向。尝试不同的变量值，并找出最适合的配置。
- en: When you feel you’ve improved the program as much as you can, you could grab
    a second ultrasonic HC-SR04 module, wire it up to more of your Pi’s GPIO pins
    just as before, and customize your code to use this new source of data in addition
    to the first HC-SR04\. If you’re using two sensors, a good place to mount them
    is on the front corners of your robot, rather than just facing forward.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当你觉得自己已经尽可能地改进了程序后，你可以再拿一个超声波 HC-SR04 模块，像之前一样将它接到树莓派的更多 GPIO 引脚上，并自定义代码，利用这个新的数据源与第一个
    HC-SR04 配合使用。如果你使用两个传感器，一个不错的安装位置是把它们安装在机器人的前角，而不仅仅是正对前方。
- en: If you’re still feeling adventurous, you could try a third distance sensor to
    build an even better picture of the environment your robot is in!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你依然充满冒险精神，你可以尝试使用第三个距离传感器，以便更全面地感知你的机器人所处的环境！
- en: SUMMARY
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we’ve covered everything from the theory behind ultrasonic distance
    measurement to programming using functions. You’ve put all of this together to
    turn your robot into a fully autonomous obstacle-avoiding machine.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了从超声波距离测量的原理到使用函数编程的所有内容。你已经将这些知识整合在一起，成功地将你的机器人变成了一个完全自主的避障机器。
- en: In the next chapter, I’ll show you how to make your robot unique by adding programmable
    RGB LEDs and sound effects!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我将向你展示如何通过添加可编程 RGB LED 和音效使你的机器人更具特色！
