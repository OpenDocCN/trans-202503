- en: Chapter 1. Primitive and Reference Types
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1章 原始类型和引用类型
- en: 'Most developers learn object-oriented programming by working with class-based
    languages such as Java or C#. When these developers start learning JavaScript,
    they get disoriented because JavaScript has no formal support for classes. Instead
    of defining classes from the beginning, with JavaScript you can just write code
    and create data structures as you need them. Because it lacks classes, JavaScript
    also lacks class groupings such as packages. Whereas in languages like Java, package
    and class names define both the types of objects you use and the layout of files
    and folders in your project, programming in JavaScript is like starting with a
    blank slate: You can organize things any way you want. Some developers choose
    to mimic structures from other languages, while others take advantage of JavaScript’s
    flexibility to come up with something completely new. To the uninitiated, this
    freedom of choice can be overwhelming, but once you get used to it, you’ll find
    JavaScript to be an incredibly flexible language that can adapt to your preferences
    quite easily.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者通过使用基于类的语言（如 Java 或 C#）来学习面向对象编程。当这些开发者开始学习 JavaScript 时，由于 JavaScript
    并不正式支持类的概念，他们会感到迷茫。与其从一开始就定义类，在 JavaScript 中，你可以根据需要编写代码并创建数据结构。由于缺乏类，JavaScript
    也没有像包这样的类分组。与 Java 中的语言不同，在 Java 中，包和类名定义了你使用的对象类型以及项目中文件和文件夹的布局，而 JavaScript
    编程就像从一张白纸开始：你可以随意组织事物。有些开发者选择模仿其他语言的结构，而另一些开发者则利用 JavaScript 的灵活性创造出完全新的东西。对于不了解的人来说，这种自由选择可能会让人不知所措，但一旦适应了，你会发现
    JavaScript 是一种极其灵活的语言，能够轻松适应你的偏好。
- en: To ease the transition from traditional object-oriented languages, JavaScript
    makes objects the central part of the language. Almost all data in JavaScript
    is either an object or accessed through objects. In fact, even functions (which
    languages traditionally make you jump through hoops to get references to) are
    represented as objects in JavaScript, which makes them *first-class functions*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让开发者更容易从传统的面向对象语言过渡，JavaScript 将对象作为语言的核心部分。几乎所有的 JavaScript 数据要么是对象，要么通过对象访问。实际上，即使是函数（传统语言需要你费劲力气才能获得引用的东西）在
    JavaScript 中也是作为对象来表示的，这使得它们成为*一等函数*。
- en: Working with and understanding objects is key to understanding JavaScript as
    a whole. You can create objects at any time and add or remove properties from
    them whenever you want. In addition, JavaScript objects are extremely flexible
    and have capabilities that create unique and interesting patterns that are simply
    not possible in other languages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 理解和使用对象是理解 JavaScript 整体的关键。你可以随时创建对象，并根据需要添加或删除其属性。此外，JavaScript 对象具有极高的灵活性，拥有其他语言无法实现的独特功能和有趣的模式。
- en: 'This chapter focuses on how to identify and work with the two primary JavaScript
    data types: primitive types and reference types. Though both are accessed through
    objects, they behave in different ways that are important to understand.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是如何识别和处理两种主要的 JavaScript 数据类型：原始类型和引用类型。虽然它们都是通过对象访问的，但它们的行为方式不同，这一点很重要。
- en: What Are Types?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是类型？
- en: 'Although JavaScript has no concept of classes, it still uses two kinds of *types*:
    primitive and reference. *Primitive types* are stored as simple data types. *Reference
    types* are stored as objects, which are really just references to locations in
    memory.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 JavaScript 没有类的概念，但它仍然使用两种*类型*：原始类型和引用类型。*原始类型*作为简单的数据类型存储。*引用类型*则作为对象存储，实际上只是指向内存位置的引用。
- en: The tricky thing is that JavaScript lets you treat primitive types like reference
    types in order to make the language more consistent for the developer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 麻烦的是，JavaScript 允许你将原始类型当作引用类型来处理，以使语言对于开发者更加一致。
- en: 'While other programming languages distinguish between primitive and reference
    types by storing primitives on the stack and references in the heap, JavaScript
    does away with this concept completely: It tracks variables for a particular scope
    with a *variable object*. Primitive values are stored directly on the variable
    object, while reference values are placed as a pointer in the variable object,
    which serves as a reference to a location in memory where the object is stored.
    However, as you’ll see later in this chapter, primitive values and reference values
    behave quite differently although they may initially seem the same.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其他编程语言通过将原始类型存储在栈上，而引用类型存储在堆上来区分原始类型和引用类型，JavaScript 完全没有这个概念：它通过 *变量对象* 来追踪特定作用域的变量。原始值直接存储在变量对象中，而引用值作为指针存储在变量对象中，指向内存中存储对象的位置。然而，正如本章后面会讨论的，尽管原始值和引用值最初看起来相同，但它们的行为实际上是截然不同的。
- en: Of course, there are other differences between primitive and reference types.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，原始类型和引用类型之间还有其他区别。
- en: Primitive Types
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始类型
- en: 'Primitive types represent simple pieces of data that are stored as is, such
    as `true` and 25\. There are five primitive types in JavaScript:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型表示简单的数据片段，这些数据按原样存储，例如 `true` 和 25。JavaScript 中有五种原始类型：
- en: '| **Boolean** | `true` or `false` |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| **布尔值** | `true` 或 `false` |'
- en: '| **Number** | Any integer or floating-point numeric value |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **数字** | 任意整数或浮点数值 |'
- en: '| **String** | A character or sequence of characters delimited by either single
    or double quotes (JavaScript has no separate character type) |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **字符串** | 由单引号或双引号限定的字符或字符序列（JavaScript 没有单独的字符类型） |'
- en: '| **Null** | A primitive type that has only one value, `null` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **空值** | 只有一个值 `null` 的原始类型 |'
- en: '| **Undefined** | A primitive type that has only one value, `undefined (undefined`
    is the value assigned to a variable that is not initialized) |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **未定义** | 只有一个值 `undefined` 的原始类型（`undefined` 是赋给未初始化变量的值） |'
- en: 'The first three types (Boolean, number, and string) behave in similar ways,
    while the last two (null and undefined) work a bit differently, as will be discussed
    throughout this chapter. All primitive types have literal representations of their
    values. *Literals* represent values that aren’t stored in a variable, such as
    a hardcoded name or price. Here are some examples of each type using its literal
    form:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 前三种类型（布尔值、数字和字符串）表现类似，而最后两种（空值和未定义）则有所不同，本章将进一步讨论。所有原始类型都有其值的字面量表示。*字面量* 表示未存储在变量中的值，例如硬编码的名称或价格。以下是每种类型使用其字面量形式的示例：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In JavaScript, as in many other languages, a variable holding a primitive directly
    contains the primitive value (rather than a pointer to an object). When you assign
    a primitive value to a variable, the value is copied into that variable. This
    means that if you set one variable equal to another, each variable gets its own
    copy of the data. For example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，和许多其他语言一样，持有原始值的变量直接包含原始值（而不是指向对象的指针）。当你将一个原始值赋给变量时，值会被复制到该变量中。这意味着，如果你将一个变量赋值给另一个变量，每个变量都会得到该数据的副本。例如：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `color1` is assigned the value of `"red"`. The variable `color2` is then
    assigned the value `color1`, which stores `"red"` in `color2`. Even though `color1`
    and `color2` contain the same value, they are completely separate from each other,
    and you can change the value in `color1` without affecting `color2` and vice versa.
    That’s because there are two different storage locations, one for each variable.
    [Figure 1-1](ch01.html#variable_object "Figure 1-1. Variable object") illustrates
    the variable object for this snippet of code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`color1` 被赋值为 `"red"`。然后，`color2` 被赋值为 `color1`，即将 `"red"` 存储在 `color2`
    中。尽管 `color1` 和 `color2` 存储相同的值，它们却是完全独立的，你可以在不影响 `color2` 的情况下更改 `color1` 的值，反之亦然。这是因为每个变量有两个不同的存储位置。[图
    1-1](ch01.html#variable_object "图 1-1. 变量对象") 展示了这段代码的变量对象。
- en: '![Variable object](figs/web/oojs01_01.png.jpg)Figure 1-1. Variable object'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![变量对象](figs/web/oojs01_01.png.jpg)图 1-1. 变量对象'
- en: 'Because each variable containing a primitive value uses its own storage space,
    changes to one variable are not reflected on the other. For example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个包含原始值的变量都有自己的存储空间，所以一个变量的变化不会影响到另一个变量。例如：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code, `color1` is changed to `"blue"` and `color2` retains its original
    value of `"red"`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`color1` 被更改为 `"blue"`，而 `color2` 保留其原始值 `"red"`。
- en: Identifying Primitive Types
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别原始类型
- en: 'The best way to identify primitive types is with the `typeof` operator, which
    works on any variable and returns a string indicating the type of data. The `typeof`
    operator works well with strings, numbers, Booleans, and `undefined`. The following
    shows the output when using `typeof` on different primitive values:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 确定原始类型的最佳方法是使用 `typeof` 操作符，它可以作用于任何变量，并返回一个表示数据类型的字符串。`typeof` 操作符适用于字符串、数字、布尔值和
    `undefined`。以下展示了使用 `typeof` 对不同原始值进行操作时的输出：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you might expect, `typeof` returns `"string"` when the value is a string;
    `"number"` when the value is a number (regardless of integer or floating-point
    values); `"boolean"` when the value is a Boolean; and `"undefined"` when the value
    is undefined.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预期的，当值为字符串时，`typeof` 返回 `"string"`；当值为数字时，返回 `"number"`（无论是整数还是浮点数）；当值为布尔值时，返回
    `"boolean"`；当值为 `undefined` 时，返回 `"undefined"`。
- en: The tricky part involves `null`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 难点在于 `null`。
- en: 'You wouldn’t be the first developer to be confused by the result of this line
    of code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你并不是第一个被这行代码的结果弄困惑的开发者：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When you run `typeof null`, the result is `"object"`. But why an object when
    the type is `null`? (In fact, this has been acknowledged as an error by TC39,
    the committee that designs and maintains JavaScript. You could reason that `null`
    is an empty object pointer, making `"object"` a logical return value, but that’s
    still confusing.)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 `typeof null` 时，结果是 `"object"`。但为什么类型是 `null` 时返回的是对象呢？（事实上，这被 TC39（负责设计和维护
    JavaScript 的委员会）视为一个错误。你可以推测 `null` 是一个空对象指针，因此 `"object"` 是一个合乎逻辑的返回值，但这仍然令人困惑。）
- en: 'The best way to determine if a value is `null` is to compare it against `null`
    directly, like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 确定一个值是否为 `null` 的最佳方法是直接将其与 `null` 进行比较，如下所示：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Comparing Without Coercion
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 无强制转换的比较
- en: 'Notice that this code uses the triple equals operator (`===`) instead of the
    double equals operator. The reason is that triple equals does the comparison without
    coercing the variable to another type. To understand why this is important, consider
    the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这段代码使用了三等号操作符（`===`）而不是双等号操作符。原因是三等号在进行比较时不会强制转换变量类型。为了理解为什么这很重要，考虑以下几点：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you use the double equals, the string `"5"` and the number `5` are considered
    equal because the double equals converts the string into a number before it makes
    the comparison. The triple equals operator doesn’t consider these values equal
    because they are two different types. Likewise, when you compare `undefined` and
    `null`, the double equals says that they are equivalent, while the triple equals
    says they are not. When you’re trying to identify `null`, use triple equals so
    that you can correctly identify the type.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用双等号时，字符串 `"5"` 和数字 `5` 被认为是相等的，因为双等号在比较前会将字符串转换为数字。三等号操作符不会认为这两个值相等，因为它们是两种不同的类型。同样，当你比较
    `undefined` 和 `null` 时，双等号会认为它们是等价的，而三等号则认为它们不相等。当你试图识别 `null` 时，使用三等号以便能够正确识别类型。
- en: Primitive Methods
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始方法
- en: 'Despite the fact that they’re primitive types, strings, numbers, and Booleans
    actually have methods. (The `null` and `undefined` types have no methods.) Strings,
    in particular, have numerous methods to help you work with them. For example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们是原始类型，字符串、数字和布尔值实际上都有方法。（`null` 和 `undefined` 类型没有方法。）特别是字符串，拥有许多方法来帮助你处理它们。例如：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Despite the fact that they have methods, primitive values themselves are not
    objects. JavaScript makes them look like objects to provide a consistent experience
    in the language, as you’ll see later in this chapter.*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管原始值本身具有方法，但它们并不是对象。JavaScript 让它们看起来像对象，以提供一致的语言体验，正如你将在本章后面看到的那样。*'
- en: Reference Types
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用类型
- en: Reference types represent objects in JavaScript and are the closest things to
    classes that you will find in the language. Reference values are *instances* of
    reference types and are synonymous with objects (the rest of this chapter refers
    to reference values simply as *objects*). An object is an unordered list of *properties*
    consisting of a name (always a string) and a value. When the value of a property
    is a function, it is called a *method*. Functions themselves are actually reference
    values in JavaScript, so there’s little difference between a property that contains
    an array and one that contains a function except that a function can be executed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型表示JavaScript中的对象，是语言中最接近类的存在。引用值是引用类型的*实例*，并且与对象同义（本章后面将引用值简单地称为*对象*）。一个对象是一个无序的*属性*列表，属性由名称（始终是字符串）和值组成。当属性的值是函数时，它被称为*方法*。函数本身实际上是JavaScript中的引用值，因此包含数组的属性与包含函数的属性几乎没有区别，除了函数可以被执行。
- en: Of course, you must create objects before you can begin working with them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你必须在开始使用对象之前创建它们。
- en: Creating Objects
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建对象
- en: It sometimes helps to think of JavaScript objects as nothing more than hash
    tables, as shown in [Figure 1-2](ch01.html#structure_of_an_object "Figure 1-2. Structure
    of an object").
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，将JavaScript对象看作只是哈希表会有所帮助，如[图1-2](ch01.html#structure_of_an_object "图1-2.
    对象的结构")所示。
- en: '![Structure of an object](figs/web/oojs01_02.png.jpg)Figure 1-2. Structure
    of an object'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![对象的结构](figs/web/oojs01_02.png.jpg)图1-2. 对象的结构'
- en: 'There are a couple of ways to create, or *instantiate*, objects. The first
    is to use the `new` operator with a *constructor*. (A constructor is simply a
    function that uses `new` to create an object—any function can be a constructor.)
    By convention, constructors in JavaScript begin with a capital letter to distinguish
    them from nonconstructor functions. For example, this code instantiates a generic
    object and stores a reference to it in `object`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 创建或*实例化*对象有几种方式。第一种是使用`new`运算符与*构造函数*。 （构造函数就是使用`new`来创建对象的函数——任何函数都可以是构造函数。）按照约定，JavaScript中的构造函数以大写字母开头，以便与非构造函数区分开来。例如，这段代码实例化了一个通用对象并将引用存储在`object`中：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Reference types do not store the object directly into the variable to which
    it is assigned, so the `object` variable in this example doesn’t actually contain
    the object instance. Instead, it holds a pointer (or reference) to the location
    in memory where the object exists. This is the primary difference between objects
    and primitive values, as the primitive is stored directly in the variable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型并不会将对象直接存储到被赋值的变量中，因此在这个例子中，`object`变量实际上并不包含对象实例。相反，它保存的是一个指针（或引用），指向内存中对象所在的位置。这是对象与原始值之间的主要区别，因为原始值是直接存储在变量中的。
- en: 'When you assign an object to a variable, you’re actually assigning a pointer.
    That means if you assign one variable to another, each variable gets a copy of
    the pointer, and both still reference the same object in memory. For example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个对象赋值给一个变量时，实际上你是在赋值一个指针。这意味着如果你将一个变量赋值给另一个变量，每个变量都会得到指针的副本，且两者仍然引用内存中同一个对象。例如：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code first creates an object (with `new`) and stores a reference in `object1`.
    Next, `object2` is assigned the value of `object1`. There is still only the one
    instance of the object that was created on the first line, but both variables
    now point to that object, as illustrated in [Figure 1-3](ch01.html#two_variables_pointing_to_one_object
    "Figure 1-3. Two variables pointing to one object").
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先创建了一个对象（使用`new`）并将引用存储在`object1`中。接着，`object2`被赋值为`object1`的值。仍然只有在第一行创建的那一个对象实例，但现在两个变量都指向该对象，如[图1-3](ch01.html#two_variables_pointing_to_one_object
    "图1-3. 两个变量指向一个对象")所示。
- en: '![Two variables pointing to one object](figs/web/oojs01_03-new.png)Figure 1-3. Two
    variables pointing to one object'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![两个变量指向一个对象](figs/web/oojs01_03-new.png)图1-3. 两个变量指向一个对象'
- en: Dereferencing Objects
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解引用对象
- en: JavaScript is a garbage-collected language, so you don’t really need to worry
    about memory allocations when you use reference types. However, it’s best to *dereference*
    objects that you no longer need so that the garbage collector can free up that
    memory. The best way to do this is to set the object variable to `null`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一个垃圾回收语言，因此在使用引用类型时，你实际上不需要担心内存分配。然而，最好是*解除引用*不再需要的对象，这样垃圾回收器才能释放内存。实现这一点的最佳方式是将对象变量设置为`null`。
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, `object1` is created and used before finally being set to `null`. When
    there are no more references to an object in memory, the garbage collector can
    use that memory for something else. (Dereferencing objects is especially important
    in very large applications that use millions of objects.)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`object1`在使用前被创建，并最终被设为`null`。当内存中不再有对某个对象的引用时，垃圾回收器可以将这部分内存用于其他用途。（在使用数百万个对象的大型应用程序中，解除引用对象尤为重要。）
- en: Adding or Removing Properties
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加或删除属性
- en: 'Another interesting aspect of objects in JavaScript is that you can add and
    remove properties at any time. For example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中另一个有趣的方面是，你可以随时添加和删除属性。例如：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, `myCustomProperty` is added to `object1` with a value of `"Awesome!"`.
    That property is also accessible on `object2` because both `object1` and `object2`
    point to the same object.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`myCustomProperty`被添加到`object1`，其值为`"Awesome!"`。由于`object1`和`object2`指向同一个对象，所以该属性也可以通过`object2`访问。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*This example demonstrates one particularly unique aspect of JavaScript: You
    can modify objects whenever you want, even if you didn’t define them in the first
    place. And there are ways to prevent such modifications, as you’ll learn later
    in this book.*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个示例展示了JavaScript一个特别独特的方面：你可以随时修改对象，即使你一开始没有定义它们。而且，后面你将学习到一些方法可以防止这种修改。*'
- en: In addition to generic object reference types, JavaScript has several other
    built-in types that are at your disposal.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通用的对象引用类型，JavaScript 还提供了几种其他内建类型供你使用。
- en: Instantiating Built-in Types
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例化内建类型
- en: You’ve seen how to create and interact with generic objects created with `new
    Object()`. The `Object` type is just one of a handful of built-in reference types
    that JavaScript provides. The other built-in types are more specialized in their
    intended usage and can be instantiated at any time.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了如何创建并操作通过`new Object()`创建的通用对象。`Object`类型只是JavaScript提供的众多内建引用类型之一。其他内建类型在用途上更为专用，可以随时实例化。
- en: 'The built-in types are:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 内建类型包括：
- en: '| **`Array`** | An ordered list of numerically indexed values |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| **`Array`** | 一个按数字索引排序的值的列表 |'
- en: '| **`Date`** | A date and time |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **`Date`** | 一个日期和时间 |'
- en: '| **`Error`** | A runtime error (there are also several more specific error
    subtypes) |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **`Error`** | 一个运行时错误（还有几个更具体的错误子类型） |'
- en: '| **`Function`** | A function |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| **`Function`** | 一个函数 |'
- en: '| **`Object`** | A generic object |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **`Object`** | 一个通用对象 |'
- en: '| **`RegExp`** | A regular expression |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **`RegExp`** | 一个正则表达式 |'
- en: 'You can instantiate each built-in reference type using `new`, as shown here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`new`实例化每个内建的引用类型，如下所示：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Literal Forms
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字面量形式
- en: Several built-in reference types have literal forms. A *literal* is syntax that
    allows you to define a reference value without explicitly creating an object,
    using the `new` operator and the object’s constructor. (Earlier in this chapter,
    you saw examples of primitive literals including string literals, numeric literals,
    Boolean literals, the `null` literal, and the `undefined` literal.)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一些内建的引用类型具有字面量形式。*字面量*是一种语法，允许你定义一个引用值，而不需要显式地使用`new`运算符和对象的构造函数创建对象。（在本章前面，你已经看到了一些原始字面量的例子，包括字符串字面量、数字字面量、布尔字面量、`null`字面量和`undefined`字面量。）
- en: Object and Array Literals
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象和数组字面量
- en: 'To create an object with *object literal* syntax, you can define the properties
    of a new object inside braces. Properties are made up of an identifier or string,
    a colon, and a value, with multiple properties separated by commas. For example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用*对象字面量*语法创建对象，你可以在大括号内定义新对象的属性。属性由标识符或字符串、冒号和值组成，多个属性之间用逗号分隔。例如：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can also use string literals as property names, which is useful when you
    want a property name to have spaces or other special characters:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用字符串字面量作为属性名，这在你希望属性名包含空格或其他特殊字符时非常有用：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This example is equivalent to the previous one despite the syntactic differences.
    Both examples are also logically equivalent to the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管语法不同，但这个示例与前一个示例是等价的。两个示例在逻辑上也等价于以下内容：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The outcome of each of the previous three examples is the same: an object with
    two properties. The choice of pattern is up to you because the functionality is
    ultimately the same.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之前三个示例的结果是相同的：一个具有两个属性的对象。选择哪种模式由你决定，因为功能本质上是相同的。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Using an object literal doesn’t actually call new Object(). Instead, the JavaScript
    engine follows the same steps it does when using new Object() without actually
    calling the constructor. This is true for all reference literals.*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用对象字面量实际上并不会调用 new Object()。相反，JavaScript 引擎会按照使用 new Object() 时的步骤进行处理，但并不实际调用构造函数。这对所有引用类型字面量都适用。*'
- en: 'You can define an *array literal* in a similar way by enclosing any number
    of comma-separated values inside square brackets. For example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将任意数量的用逗号分隔的值包含在方括号中来定义一个*数组字面量*。例如：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code is equivalent to the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码等价于以下代码：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Function Literals
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数字面量
- en: You almost always define functions using their literal form. In fact, using
    the `Function` constructor is typically discouraged given the challenges of maintaining,
    reading, and debugging a string of code rather than actual code, so you’ll rarely
    see it in code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎总是使用字面量形式来定义函数。事实上，通常不推荐使用 `Function` 构造函数，因为与实际代码相比，维护、阅读和调试字符串代码会更具挑战性，因此你很少会在代码中看到它。
- en: 'Creating functions is much easier and less error prone when you use the literal
    form. For example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字面量形式创建函数更加简单且不容易出错。例如：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code defines the `reflect()` function, which returns any value passed
    to it. Even in the case of this simple function, the literal form is easier to
    write and understand than the constructor form. Further, there is no good way
    to debug functions that are created in the constructor form: These functions aren’t
    recognized by JavaScript debuggers and therefore act as a black box in your application.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了 `reflect()` 函数，该函数返回传入的任何值。即使是这样一个简单的函数，字面量形式也比构造函数形式更容易编写和理解。此外，没有好的方法来调试通过构造函数形式创建的函数：这些函数无法被
    JavaScript 调试器识别，因此在你的应用程序中表现为黑盒。
- en: Regular Expression Literals
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正则表达式字面量
- en: 'JavaScript also has *regular expression literals* that allow you to define
    regular expressions without using the `RegExp` constructor. Regular expression
    literals look very similar to regular expressions in Perl: The pattern is contained
    between two slashes, and any additional options are single characters following
    the second slash. For example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 还有*正则表达式字面量*，允许你在不使用 `RegExp` 构造函数的情况下定义正则表达式。正则表达式字面量看起来与 Perl 中的正则表达式非常相似：模式位于两个斜杠之间，任何附加选项都是紧跟第二个斜杠后的单个字符。例如：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The literal form of regular expressions in JavaScript is a bit easier to deal
    with than the constructor form because you don’t need to worry about escaping
    characters within strings. When using the `RegExp` constructor, you pass the pattern
    in as a string, so you have to escape any backslashes. (That’s why `\d` is used
    in the literal and `\\d` is used in the constructor.) Regular expression literals
    are preferred over the constructor form in JavaScript except when the regular
    expression is being constructed dynamically from one or more strings.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中正则表达式的字面量形式比构造函数形式更容易处理，因为你不需要担心字符串中的字符转义问题。使用 `RegExp` 构造函数时，你需要将模式作为字符串传入，因此必须转义反斜杠。（这也是为什么在字面量中使用
    `\d` 而在构造函数中使用 `\\d` 的原因。）除非正则表达式是从一个或多个字符串动态构造的，否则在 JavaScript 中更推荐使用正则表达式字面量，而非构造函数形式。
- en: That said, with the exception of `Function`, there really isn’t any right or
    wrong way to instantiate built-in types. Many developers prefer literals, while
    some prefer constructors. Choose whichever method you find more comfortable to
    use.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，除了 `Function` 之外，实际上没有任何一种方式是正确或错误的来实例化内置类型。许多开发者偏好字面量，而有些开发者则偏好构造函数。选择你觉得更舒适的方式。
- en: Property Access
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性访问
- en: Properties are name/value pairs that are stored on an object. Dot notation is
    the most common way to access properties in JavaScript (as in many object-oriented
    languages), but you can also access properties on JavaScript objects by using
    bracket notation with a string.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是存储在对象上的名称/值对。点符号表示法是 JavaScript 中访问属性的最常见方式（就像许多面向对象的语言一样），但你也可以通过使用方括号表示法并配合字符串来访问
    JavaScript 对象的属性。
- en: 'For example, you could write this code, which uses dot notation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以编写这段代码，使用点符号表示法：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With bracket notation, the name of the method is now included in a string enclosed
    by square brackets, as in this example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方括号表示法时，方法名现在包含在用方括号括起来的字符串中，如下例所示：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This syntax is very useful when you want to dynamically decide which property
    to access. For example, here bracket notation allows you to use a variable instead
    of the string literal to specify the property to access.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想动态决定访问哪个属性时，这种语法非常有用。例如，在这里，括号符号允许你使用变量而不是字符串字面量来指定要访问的属性。
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this listing, the variable `method` has a value of `"push"`, so `push()`
    is called on the array. This capability is quite useful, as you’ll see throughout
    this book. The point to remember is that, other than syntax, the only difference—performance
    or otherwise—between dot notation and bracket notation is that bracket notation
    allows you to use special characters in property names. Developers tend to find
    dot notation easier to read, so you’ll see it used more frequently than bracket
    notation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，变量 `method` 的值为 `"push"`，因此在数组上调用了 `push()` 方法。这种能力非常有用，正如你将在本书中看到的那样。需要记住的一点是，除了语法之外，点符号和括号符号的唯一区别——无论是性能还是其他方面——是括号符号允许你在属性名中使用特殊字符。开发者通常发现点符号更容易阅读，因此你会看到它比括号符号使用得更频繁。
- en: Identifying Reference Types
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别引用类型
- en: 'A function is the easiest reference type to identify because when you use the
    `typeof` operator on a function, the operator should return `"function"`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是最容易识别的引用类型，因为当你对一个函数使用 `typeof` 操作符时，操作符应该返回 `"function"`：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Other reference types are trickier to identify because, for all reference types
    other than functions, `typeof` returns `"object"`. That’s not very helpful when
    you’re dealing with a lot of different types. To identify reference types more
    easily, you can use JavaScript’s `instanceof` operator.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 其他引用类型更难识别，因为对于除函数之外的所有引用类型，`typeof` 返回 `"object"`。在处理许多不同类型时，这并不是很有帮助。为了更容易地识别引用类型，你可以使用
    JavaScript 的 `instanceof` 操作符。
- en: 'The `instanceof` operator takes an object and a constructor as parameters.
    When the value is an instance of the type that the constructor specifies, `instanceof`
    returns `true`; otherwise, it returns `false`, as you can see here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof` 操作符接受一个对象和一个构造函数作为参数。当该值是构造函数指定的类型的实例时，`instanceof` 返回 `true`；否则，返回
    `false`，如下面所示：'
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, several values are tested using `instanceof` and a constructor.
    Each reference type is correctly identified by using `instanceof` and the constructor
    that represents its true type (even though the constructor wasn’t used in creating
    the variable).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，使用 `instanceof` 和构造函数测试了多个值。通过使用 `instanceof` 和表示其真实类型的构造函数，每个引用类型都被正确识别（即使在创建变量时并未使用构造函数）。
- en: The `instanceof` operator can identify inherited types. That means every object
    is actually an instance of `Object` because every reference type inherits from
    `Object`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof` 操作符可以识别继承类型。这意味着每个对象实际上都是 `Object` 的一个实例，因为每个引用类型都继承自 `Object`。'
- en: 'To demonstrate, the following listing examines the three references previously
    created with `instanceof`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，以下代码列出了之前用 `instanceof` 创建的三个引用：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Each reference type is correctly identified as an instance of `Object`, from
    which all reference types inherit.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每个引用类型都被正确识别为 `Object` 的实例，而所有引用类型都继承自 `Object`。
- en: Identifying Arrays
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别数组
- en: 'Although `instanceof` can identify arrays, there is one exception that affects
    web developers: JavaScript values can be passed back and forth between frames
    in the same web page. This becomes a problem only when you try to identify the
    type of a reference value, because each web page has its own global context—its
    own version of `Object`, `Array`, and all other built-in types. As a result, when
    you pass an array from one frame to another, `instanceof` doesn’t work because
    the array is actually an instance of `Array` from a different frame.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `instanceof` 可以识别数组，但有一个例外影响到网页开发者：JavaScript 值可以在同一网页的不同框架之间来回传递。这个问题只在你尝试识别引用值的类型时出现，因为每个网页都有自己的全局上下文——自己的
    `Object`、`Array` 和所有其他内建类型的版本。因此，当你将数组从一个框架传递到另一个框架时，`instanceof` 无法工作，因为该数组实际上是来自另一个框架的
    `Array` 的实例。
- en: 'To solve this problem, ECMAScript 5 introduced `Array.isArray()`, which definitively
    identifies the value as an instance of `Array` regardless of the value’s origin.
    This method should return `true` when it receives a value that is a native array
    from any context. If your environment is ECMAScript 5 compliant, `Array.isArray()`
    is the best way to identify arrays:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，ECMAScript 5 引入了 `Array.isArray()`，它可以明确地将值识别为 `Array` 的实例，无论该值的来源是什么。当该方法接收到来自任何上下文的本地数组值时，应该返回
    `true`。如果你的环境支持 ECMAScript 5，`Array.isArray()` 是识别数组的最佳方式：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `Array.isArray()` method is supported in most environments, both in browsers
    and in Node.js. This method isn’t supported in Internet Explorer 8 and earlier.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.isArray()` 方法在大多数环境中都得到支持，包括浏览器和 Node.js。但在 Internet Explorer 8 及更早版本中不支持此方法。'
- en: Primitive Wrapper Types
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始包装类型
- en: Perhaps one of the most confusing parts of JavaScript is the concept of *primitive
    wrapper types*. There are three primitive wrapper types (`String`, `Number`, and
    `Boolean`). These special reference types exist to make working with primitive
    values as easy as working with objects. (It would be very confusing if you had
    to use a different syntax or switch to a procedural style just to get a substring
    of text.)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 也许 JavaScript 中最让人困惑的部分之一就是 *原始包装类型* 的概念。原始包装类型有三种（`String`、`Number` 和 `Boolean`）。这些特殊的引用类型存在的目的是让处理原始值像处理对象一样简单。（如果你需要使用不同的语法或切换到过程式编程风格才能提取文本子字符串，那将非常令人困惑。）
- en: The primitive wrapper types are reference types that are automatically created
    behind the scenes whenever strings, numbers, or Booleans are read. For example,
    in the first line of this listing, a primitive string value is assigned to `name`.
    The second line treats `name` like an object and calls `charAt(0)` using dot notation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 原始包装类型是引用类型，每当读取字符串、数字或布尔值时，都会自动在幕后创建。例如，在此列出的第一行中，原始字符串值被赋值给 `name`。第二行将 `name`
    当作对象处理，并使用点符号调用 `charAt(0)`。
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is what happens behind the scenes:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是幕后发生的事情：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Because the second line uses a string (a primitive) like an object, the JavaScript
    engine creates an instance of `String` so that `charAt(0)` will work. The `String`
    object exists only for one statement before it’s destroyed (a process called *autoboxing*).
    To test this out, try adding a property to a string as if it were a regular object:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第二行将一个字符串（原始类型）像对象一样使用，JavaScript 引擎会创建一个 `String` 实例，以便 `charAt(0)` 可以正常工作。`String`
    对象仅在一条语句中存在，然后就被销毁（这个过程叫做 *自动装箱*）。要测试这一点，试着像对待普通对象一样给字符串添加一个属性：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This code attempts to add the property `last` to the string `name`. The code
    itself is just fine except that the property disappears. What happened? When working
    with regular objects, you can add properties at any time and they stay until you
    manually remove them. With primitive wrapper types, properties seem to disappear
    because the object on which the property was assigned is destroyed immediately
    afterward.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码尝试将属性 `last` 添加到字符串 `name` 上。代码本身没有问题，问题在于该属性消失了。发生了什么？在处理常规对象时，你可以随时添加属性，并且它们会保留下来，直到你手动移除它们。而对于原始包装类型，属性似乎会消失，因为分配属性的对象会在稍后立即被销毁。
- en: 'Here’s what’s actually happening in the JavaScript engine:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 JavaScript 引擎实际发生的事情：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Instead of assigning a new property to a string, the code actually creates
    a new property on a temporary object that is then destroyed. When you try to access
    that property later, a different object is temporarily created and the new property
    doesn’t exist there. Although reference values are created automatically for primitive
    values, when `instanceof` checks for these types of values the result is `false`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 代码并没有将新属性分配给字符串，而是实际上在一个临时对象上创建了一个新属性，该对象随后被销毁。当你稍后尝试访问该属性时，会临时创建一个不同的对象，并且该新属性在其中不存在。尽管为原始值自动创建了引用值，但当使用
    `instanceof` 检查这些类型的值时，结果是 `false`：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `instanceof` operator returns `false` because a temporary object is created
    only when a value is read. Because `instanceof` doesn’t actually read anything,
    no temporary objects are created, and it tells us the values aren’t instances
    of primitive wrapper types. You can create primitive wrapper types manually, but
    there are certain side effects:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof` 操作符返回 `false`，因为只有在读取值时才会创建临时对象。由于 `instanceof` 实际上并没有读取任何内容，因此没有创建临时对象，它告诉我们这些值不是原始包装类型的实例。你可以手动创建原始包装类型，但会有某些副作用：'
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, creating an instance of the primitive wrapper type just creates
    another object, which means that `typeof` can’t identify the type of data you
    intend to store.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，创建一个原始包装类型的实例只是创建另一个对象，这意味着`typeof`无法识别你打算存储的数据类型。
- en: In addition, you can’t use `String`, `Number`, and `Boolean` objects as you
    would primitive values. For example, the following code uses a `Boolean` object.
    The `Boolean` object is `false`, yet `console.log("Found")` still executes because
    an object is always considered `true` inside a conditional statement. It doesn’t
    matter that the object represents `false`; it’s an object, so it evaluates to
    `true`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你不能像使用原始值那样使用`String`、`Number`和`Boolean`对象。例如，以下代码使用了一个`Boolean`对象。该`Boolean`对象的值是`false`，但`console.log("Found")`仍然执行，因为在条件语句中，任何对象总是被视为`true`。对象是否代表`false`并不重要；它是一个对象，因此它被评估为`true`。
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Manually instantiating primitive wrappers can also be confusing in other ways,
    so unless you find a special case where it makes sense to do so, you should avoid
    it. Most of the time, using primitive wrapper objects instead of primitives only
    leads to errors.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 手动实例化原始包装类型在其他方面也可能造成困惑，因此除非你遇到一个特殊情况，确实有意义这么做，否则你应该避免使用它。大多数时候，使用原始包装对象而不是原始类型只会导致错误。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: While JavaScript doesn’t have classes, it does have types. Each variable or
    piece of data is associated with a specific primitive or reference type. The five
    primitive types (strings, numbers, Booleans, `null`, and `undefined`) represent
    simple values stored directly in the variable object for a given context. You
    can use `typeof` to identify primitive types with the exception of `null`, which
    must be compared directly against the special value `null`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JavaScript没有类，但它有类型。每个变量或数据片段都与特定的原始类型或引用类型相关联。五种原始类型（字符串、数字、布尔值、`null`和`undefined`）表示存储在变量对象中的简单值。你可以使用`typeof`来识别原始类型，除了`null`，它必须直接与特殊值`null`进行比较。
- en: Reference types are the closest thing to classes in JavaScript, and objects
    are instances of reference types. You can create new objects using the `new` operator
    or a reference literal. You access properties and methods primarily using dot
    notation, but you can also use bracket notation. Functions are objects in JavaScript,
    and you can identify them with the `typeof` operator. You should use `instanceof`
    with a constructor to identify objects of any other reference type.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型是JavaScript中最接近类的东西，而对象是引用类型的实例。你可以使用`new`操作符或引用字面量来创建新对象。你主要通过点符号访问属性和方法，但也可以使用括号符号。函数在JavaScript中是对象，你可以用`typeof`操作符来识别它们。你应该使用`instanceof`与构造函数一起使用，来识别任何其他引用类型的对象。
- en: 'To make primitives seem more like references, JavaScript has three primitive
    wrapper types: `String`, `Number`, and `Boolean`. JavaScript creates these objects
    behind the scenes so that you can treat primitives like regular objects, but the
    temporary objects are destroyed as soon as the statement using them is complete.
    Although you can create your own instances of primitive wrappers, it’s best not
    to do that because it can be confusing.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让原始值看起来更像引用类型，JavaScript有三种原始包装类型：`String`、`Number`和`Boolean`。JavaScript在幕后创建这些对象，使你能够像处理常规对象一样处理原始值，但这些临时对象会在使用它们的语句完成后被销毁。尽管你可以创建自己的原始包装实例，但最好不要这么做，因为这会造成混淆。
