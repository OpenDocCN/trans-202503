- en: Chapter 8. Exploitation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章。漏洞利用
- en: 'After all that preparatory work we finally get to the fun stuff: exploitation.
    In the exploitation phase of the pentest, we run exploits against the vulnerabilities
    we have discovered to gain access to target systems. Some vulnerabilities, such
    as the use of default passwords, are so easy to exploit, it hardly feels like
    exploitation at all. Others are much more complicated.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些准备工作之后，我们终于可以开始有趣的部分了：漏洞利用。在渗透测试的漏洞利用阶段，我们对已发现的漏洞运行漏洞攻击，以获得对目标系统的访问。有些漏洞，比如默认密码的使用，利用起来非常简单，几乎感觉不到是在进行真正的漏洞利用。其他一些则复杂得多。
- en: In this chapter we’ll look at exploiting the vulnerabilities we identified in
    [Chapter 6](ch06.xhtml "Chapter 6. Finding Vulnerabilities") to gain a foothold
    in target machines. We’ll return to our friend MS08-067 from [Chapter 4](ch04.xhtml
    "Chapter 4. Using the Metasploit Framework"), now that we have more background
    about the vulnerability. We’ll also exploit an issue in the SLMail POP3 server
    with a Metasploit module. In addition, we’ll piggyback on a previous compromise
    and bypass login on the FTP server on our Linux target. We will exploit a vulnerability
    in the TikiWiki install on the Linux target and a couple of default password issues
    on an XAMPP install on the Windows target. We’ll also take advantage of a readable
    and writable NFS share to take control of the SSH keys and log in as a valid user
    without knowing the password. We will interact with a fragile web server on a
    nonstandard port to take advantage of a directory traversal issue and download
    system files. For a refresher on how we discovered each of the issues we’ll use
    for exploitation, refer back to [Chapter 6](ch06.xhtml "Chapter 6. Finding Vulnerabilities").
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何利用在[第6章](ch06.xhtml "第6章。发现漏洞")中识别的漏洞来在目标机器上获取立足点。既然我们对该漏洞有了更多的背景知识，我们将回到我们的老朋友MS08-067，那个在[第4章](ch04.xhtml
    "第4章。使用Metasploit框架")中提到的漏洞。我们还将利用Metasploit模块来攻击SLMail POP3服务器中的问题。此外，我们将借助之前的入侵，绕过Linux目标的FTP服务器登录。我们还将利用Linux目标上TikiWiki安装中的漏洞，以及Windows目标上XAMPP安装中的一些默认密码问题。我们还将利用一个可读写的NFS共享，获取SSH密钥并作为有效用户登录，而无需知道密码。我们将与一个脆弱的Web服务器交互，通过一个非标准端口来利用目录遍历漏洞，下载系统文件。有关如何发现我们将用于利用的每个问题的复习，请回顾[第6章](ch06.xhtml
    "第6章。发现漏洞")。
- en: Revisiting MS08-067
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视MS08-067
- en: We know from [Chapter 6](ch06.xhtml "Chapter 6. Finding Vulnerabilities") that
    the SMB server on our Windows XP target is missing the MS08-067 patch. The MS08-067
    vulnerability has a good reputation for successful exploits, and the corresponding
    Metasploit module is ranked as *great*. We used this vulnerability as an example
    in [Chapter 4](ch04.xhtml "Chapter 4. Using the Metasploit Framework"), but the
    knowledge we gained in the previous chapters gives us solid evidence that this
    exploit will result in a compromise.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第6章](ch06.xhtml "第6章。发现漏洞")中我们知道，Windows XP目标上的SMB服务器缺少MS08-067补丁。MS08-067漏洞因其成功的利用而享有良好的声誉，相关的Metasploit模块被评为*极佳*。我们在[第4章](ch04.xhtml
    "第4章。使用Metasploit框架")中以此漏洞作为示例，但通过前几章的知识，我们有了确凿的证据表明，该漏洞利用会导致入侵。
- en: When we viewed the options for the *windows/smb/ms08_067_netapi* module in [Chapter 4](ch04.xhtml
    "Chapter 4. Using the Metasploit Framework"), we saw the usual `RHOST` and `RPORT`
    as well as `SMBPIPE`, which allows us to set the pipe that our exploit will use.
    The default is the browser pipe, though we can also use `SRVSRC`. In [Chapter 4](ch04.xhtml
    "Chapter 4. Using the Metasploit Framework"), we ran the Metasploit module *scanner/smb/pipe_auditor*
    to enumerate the listening SMB pipes and found that only the browser pipe is available.
    Thus, we know that the default `SMBPIPE` option, `BROWSER`, is the only one that
    will work.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第4章](ch04.xhtml "第4章。使用Metasploit框架")查看*windows/smb/ms08_067_netapi*模块的选项时，我们看到了常见的`RHOST`和`RPORT`，以及`SMBPIPE`，该选项允许我们设置我们的漏洞利用所使用的管道。默认情况下是浏览器管道，但我们也可以使用`SRVSRC`。在[第4章](ch04.xhtml
    "第4章。使用Metasploit框架")中，我们运行了Metasploit模块*scanner/smb/pipe_auditor*来枚举监听的SMB管道，并发现只有浏览器管道可用。因此，我们知道默认的`SMBPIPE`选项`BROWSER`是唯一有效的选项。
- en: Metasploit Payloads
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Metasploit有效载荷
- en: 'As we discussed in [Chapter 4](ch04.xhtml "Chapter 4. Using the Metasploit
    Framework"), payloads allow us to tell an exploited system to do things on our
    behalf. Though many payloads are either *bind shells*, which listen on a local
    port on the target machine, or *reverse shells*, which call back to a listener
    on the attack system, other payloads perform specific functions. For example,
    if you run the payload *osx/armle/vibrate* on an iPhone, the phone will vibrate.
    There are also payloads to add a new user account: *linux/x86/adduser* for Linux
    systems and *windows/adduser* for Windows. We can download and execute a file
    with *windows/download_exec_https* or execute a command with *windows/exec*. We
    can even use the speech API to make the target say “Pwned” with *windows/speak_pwned*.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第4章](ch04.xhtml "第4章. 使用Metasploit框架")中讨论的，载荷允许我们告诉被利用的系统代我们执行任务。虽然许多载荷是*绑定Shell*（在目标机器的本地端口上监听）或*反向Shell*（回调到攻击系统上的监听器），但其他载荷执行特定功能。例如，如果你在iPhone上运行载荷*osx/armle/vibrate*，手机会振动。还有一些载荷用于添加新用户帐户：*linux/x86/adduser*适用于Linux系统，*windows/adduser*适用于Windows。我们可以使用*windows/download_exec_https*下载并执行文件，或使用*windows/exec*执行命令。我们甚至可以使用语音API，让目标说出“Pwned”，通过*windows/speak_pwned*。
- en: Recall that we can see all the payloads available in Metasploit by entering
    `show payloads` at the root of Msfconsole. Enter this command after you tell Metasploit
    to use the *windows/smb/ms08_067_netapi* module so you can see only payloads that
    are compatible with the MS08-067 exploit.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们可以通过在Msfconsole的根目录下输入`show payloads`来查看Metasploit中所有可用的载荷。在告诉Metasploit使用*windows/smb/ms08_067_netapi*模块后，输入此命令，以便只查看与MS08-067漏洞兼容的载荷。
- en: In [Chapter 4](ch04.xhtml "Chapter 4. Using the Metasploit Framework"), we used
    *windows/shell_reverse_tcp*, but looking through the list, we also see a payload
    called *windows/shell/reverse_tcp*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.xhtml "第4章. 使用Metasploit框架")中，我们使用了*windows/shell_reverse_tcp*，但在查看列表时，我们还看到了一个名为*windows/shell/reverse_tcp*的载荷。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Both payloads create Windows command shells using a reverse connection (discussed
    in [Chapter 4](ch04.xhtml "Chapter 4. Using the Metasploit Framework")). The exploited
    machine will connect back to our Kali machine at the IP address and port specified
    in the payload options. Any of the payloads listed for the *windows/smb/ms08_067_netapi*
    will work just fine, but in different pentesting scenarios, you may have to get
    creative.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种载荷使用反向连接创建Windows命令Shell（在[第4章](ch04.xhtml "第4章. 使用Metasploit框架")中讨论过）。被利用的机器将通过载荷选项中指定的IP地址和端口回连到我们的Kali机器。任何列出的适用于*windows/smb/ms08_067_netapi*的载荷都能正常工作，但在不同的渗透测试场景中，你可能需要发挥创造力。
- en: Staged Payloads
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分阶段载荷
- en: The *windows/shell/reverse_tcp* payload is *staged*. If we use it with the *windows/smb/ms08_067_netapi*
    exploit, the string sent to the SMB server to take control of the target machine
    does not contain all of the instructions to create the reverse shell. Instead,
    it contains a *stager payload* with just enough information to connect back to
    the attack machine and ask Metasploit for instructions on what to do next. When
    we launch the exploit, Metasploit sets up a handler for the *windows/shell/reverse_tcp*
    payload to catch the incoming reverse connection and serve up the rest of the
    payload—in this case a reverse shell—then the completed payload is executed, and
    Metasploit’s handler catches the reverse shell. The amount of memory space available
    for a payload may be limited, and some advanced Metasploit payloads can take up
    a lot of space. Staged payloads allow us to use complex payloads without requiring
    a lot of space in memory.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*windows/shell/reverse_tcp*载荷是*分阶段*的。如果我们将其与*windows/smb/ms08_067_netapi*漏洞一起使用，发送到SMB服务器的字符串并不包含所有创建反向Shell的指令。相反，它包含一个*阶段载荷*，其中只有足够的信息来回连攻击机器并请求Metasploit提供接下来的指令。当我们启动漏洞时，Metasploit会为*windows/shell/reverse_tcp*载荷设置一个处理程序，以捕捉传入的反向连接并提供剩余的载荷——在这种情况下是反向Shell——然后完成的载荷被执行，Metasploit的处理程序捕捉到反向Shell。载荷可用的内存空间可能有限，一些高级Metasploit载荷可能占用大量空间。分阶段载荷允许我们在不占用大量内存空间的情况下使用复杂的载荷。'
- en: Inline Payloads
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内联载荷
- en: The *windows/shell_reverse_tcp* payload is an *inline*, or *single*, payload.
    Its exploit string contains all the code necessary to push a reverse shell back
    to the attacker machine. Though inline payloads take up more space than staged
    payloads, they are more stable and consistent because all the instructions are
    included in the original exploit string. You can distinguish inline and staged
    payloads by the syntax of their module name. For example, *windows/shell/reverse_tcp*
    or *windows/meterpreter/bind_tcp* are staged, whereas *windows/shell_reverse_tcp*
    is inline.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*windows/shell_reverse_tcp*有效载荷是一种*内联*（inline）或*单一*（single）有效载荷。其攻击字符串包含了将反向Shell推送回攻击者机器所需的所有代码。虽然内联有效载荷比分阶段有效载荷占用更多空间，但它们更加稳定和一致，因为所有指令都包含在原始攻击字符串中。你可以通过模块名称的语法来区分内联有效载荷和分阶段有效载荷。例如，*windows/shell/reverse_tcp*或*windows/meterpreter/bind_tcp*是分阶段的，而*windows/shell_reverse_tcp*是内联的。'
- en: Meterpreter
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Meterpreter
- en: Meterpreter is a custom payload written for the Metasploit Project. It is loaded
    directly into the memory of an exploited process using a technique known as *reflective
    dll injection*. As such, Meterpreter resides entirely in memory and writes nothing
    to the disk. It runs inside the memory of the host process, so it doesn’t need
    to start a new process that might be noticed by an intrusion prevention or intrusion
    detection system (IPS/IDS). Meterpreter also uses Transport Layer Security (TLS)
    encryption for communication between it and Metasploit. You can think of Meterpreter
    as a kind of shell and then some. It has additional useful commands that we can
    use, such as `hashdump`, which allows us to gain access to local Windows password
    hashes. (We’ll look at many Meterpreter commands when we study post exploitation
    in [Chapter 13](ch13.xhtml "Chapter 13. Post Exploitation").)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Meterpreter是为Metasploit项目编写的自定义有效载荷。它通过一种叫做*反射式DLL注入*（reflective dll injection）技术，直接加载到被利用的进程的内存中。因此，Meterpreter完全驻留在内存中，不会写入磁盘。它运行在宿主进程的内存中，因此不需要启动新的进程，避免被入侵防御或入侵检测系统（IPS/IDS）注意到。Meterpreter还使用传输层安全性（TLS）加密与Metasploit之间的通信。你可以将Meterpreter看作是一种Shell，并且它还有一些附加的有用命令，比如`hashdump`，它允许我们获取本地Windows密码哈希。（我们将在[第13章](ch13.xhtml
    "第13章. 后期利用")研究后期利用时，详细了解更多Meterpreter命令。）
- en: We saw in [Chapter 4](ch04.xhtml "Chapter 4. Using the Metasploit Framework")
    that Metasploit’s default payload for the *windows/smb/ms08_067_netapi* is *windows/meterpreter/reverse_tcp*.
    Let’s use the *windows/meterpreter/reverse_tcp* payload with our MS08-067 exploit
    this time. Our payload options should be familiar from other reverse payloads
    we have used so far. Let’s set our payload and run the exploit, as shown in [Example 8-1](ch08.xhtml#exploiting_ms08-067_with_a_meterpreter_p
    "Example 8-1. Exploiting MS08-067 with a Meterpreter payload").
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](ch04.xhtml "第4章. 使用Metasploit框架")中看到，Metasploit的默认有效载荷是*windows/smb/ms08_067_netapi*，其默认的负载是*windows/meterpreter/reverse_tcp*。这次我们将使用*windows/meterpreter/reverse_tcp*有效载荷配合我们的MS08-067漏洞。我们的有效载荷选项应该和之前使用的其他反向载荷相似。让我们设置好有效载荷并运行漏洞攻击，如[示例8-1](ch08.xhtml#exploiting_ms08-067_with_a_meterpreter_p
    "示例8-1. 使用Meterpreter有效载荷利用MS08-067漏洞")所示。
- en: Example 8-1. Exploiting MS08-067 with a Meterpreter payload
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 示例8-1. 使用Meterpreter有效载荷利用MS08-067漏洞
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As the output shows, running this exploit should open a Meterpreter session
    that we’ll be able to use for post exploitation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，运行这个漏洞攻击应该会打开一个Meterpreter会话，我们将能够在后期利用中使用它。
- en: Exploiting WebDAV Default Credentials
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用WebDAV默认凭据
- en: 'In [Chapter 6](ch06.xhtml "Chapter 6. Finding Vulnerabilities"), we found that
    the XAMPP installation on our Windows XP target employs default login credentials
    for the WebDAV folder used to upload files to the web server. This issue allows
    us to upload our own pages to the server with Cadaver, a command line client for
    WebDAV, which we used to verify this vulnerability in [Chapter 6](ch06.xhtml "Chapter 6. Finding
    Vulnerabilities"). Let’s create a simple test file to upload:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.xhtml "第6章. 查找漏洞")中，我们发现目标Windows XP上的XAMPP安装使用WebDAV文件夹的默认登录凭据来上传文件到Web服务器。这个问题允许我们使用Cadaver（一款WebDAV命令行客户端）上传自己的页面到服务器，我们在[第6章](ch06.xhtml
    "第6章. 查找漏洞")中使用它来验证这个漏洞。让我们创建一个简单的测试文件来上传：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now use Cadaver with the credentials *wampp:xampp* to authenticate with WebDAV.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用凭据*wampp:xampp*通过WebDAV进行身份验证。
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, use WebDAV’s `put` command to upload our *test.txt* file to the web
    server.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用WebDAV的`put`命令将我们的*test.txt*文件上传到Web服务器。
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you browse to */webdav/test.txt*, you should see that we have successfully
    uploaded our text file to the website, as shown in [Figure 8-1](ch08.xhtml#file_uploaded_with_webdav
    "Figure 8-1. A file uploaded with WebDAV").
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你浏览到 */webdav/test.txt*，你应该能看到我们已经成功将文本文件上传到网站，如图 [8-1](ch08.xhtml#file_uploaded_with_webdav
    "图 8-1. 通过 WebDAV 上传的文件") 所示。
- en: '![A file uploaded with WebDAV](httpatomoreillycomsourcenostarchimages2030386.png.jpg)Figure 8-1. A
    file uploaded with WebDAV'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![通过 WebDAV 上传的文件](httpatomoreillycomsourcenostarchimages2030386.png.jpg)图
    8-1. 通过 WebDAV 上传的文件'
- en: Running a Script on the Target Web Server
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在目标 Web 服务器上运行脚本
- en: A text file is not very useful to us; it would be better if we could upload
    a script and execute it on the web server, allowing us to run commands on the
    underlying system’s Apache web server. If Apache is installed as a system service,
    it will have system-level privileges, which we could use to gain maximum control
    over our target. If not, Apache will run with privileges of the user who started
    it. Either way, you should end up with a good deal of control over the underlying
    system just by dropping a file on the web server.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 文本文件对我们并没有太大用处；如果我们能上传一个脚本并在 Web 服务器上执行它，那就更好了，这样我们就能在底层系统的 Apache Web 服务器上执行命令。如果
    Apache 作为系统服务安装，它将具有系统级的权限，我们可以利用这些权限来获得对目标的最大控制。如果没有，Apache 将以启动它的用户的权限运行。无论哪种情况，你最终都能通过简单地将文件丢到
    Web 服务器上，就获得对底层系统的相当控制。
- en: Let’s start by confirming that our WebDAV user is allowed to upload scripts
    to the server. Because we found phpMyAdmin software on this web server in [Chapter 6](ch06.xhtml
    "Chapter 6. Finding Vulnerabilities"), we know that the XAMPP software includes
    PHP. If we upload and execute a PHP file, we should be able to run commands on
    the system using PHP.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先确认我们的 WebDAV 用户是否被允许上传脚本到服务器。由于我们在 [第6章](ch06.xhtml "第6章. 查找漏洞") 中找到了 phpMyAdmin
    软件，说明这个 Web 服务器上安装了 XAMPP 软件，包括了 PHP。如果我们上传并执行一个 PHP 文件，我们应该能够通过 PHP 在系统上执行命令。
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some open WebDAV servers allow uploading text files but block script files like
    .asp or .php. Lucky for us, that isn’t the case here, and we successfully uploaded
    test.php.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开放的 WebDAV 服务器允许上传文本文件，但会阻止脚本文件如 .asp 或 .php。不过幸运的是，这里并非如此，我们成功上传了 test.php。
- en: Uploading a Msfvenom Payload
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上传 Msfvenom 有效载荷
- en: In addition to uploading any PHP scripts we’ve created to perform tasks on the
    target, we can also use Msfvenom to generate a stand-alone Metasploit payload
    to upload to the server. We used Msfvenom briefly in [Chapter 4](ch04.xhtml "Chapter 4. Using
    the Metasploit Framework"), but to brush up on syntax, you can enter `msfvenom
    -h` for help. When you’re ready, list all the available payloads with the `-l`
    option for PHP payloads, as shown in [Example 8-2](ch08.xhtml#metasploit_php_payloads
    "Example 8-2. Metasploit PHP payloads").
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上传我们创建的任何 PHP 脚本以在目标上执行任务外，我们还可以使用 Msfvenom 生成一个独立的 Metasploit 有效载荷上传到服务器。我们在
    [第4章](ch04.xhtml "第4章. 使用 Metasploit 框架") 中简要使用了 Msfvenom，但如果你需要复习语法，可以输入 `msfvenom
    -h` 获取帮助。当你准备好时，使用 `-l` 选项列出所有可用的 PHP 有效载荷，如 [示例 8-2](ch08.xhtml#metasploit_php_payloads
    "示例 8-2. Metasploit PHP 有效载荷") 所示。
- en: Example 8-2. Metasploit PHP payloads
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-2. Metasploit PHP 有效载荷
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Msfvenom gives us a few options: We can download and execute a file on the
    system ❷, create a shell ❶, or even use Meterpreter ❸. Any of these payloads will
    give us control of the system, but let’s use *php/meterpreter/reverse_tcp*. After
    we specify a payload, we can use `-o` to find out which options we need to use
    with it, as shown here.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Msfvenom 给我们提供了几种选择：我们可以下载并在系统上执行一个文件 ❷，创建一个 shell ❶，或者甚至使用 Meterpreter ❸。任何这些有效载荷都能让我们控制系统，但我们选择使用
    *php/meterpreter/reverse_tcp*。指定有效载荷后，我们可以使用 `-o` 来查看需要与之一起使用的选项，如下所示。
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see we need to set `LHOST` to tell the payload which IP address to
    connect back to, and we can also change the `LPORT` option. Because this payload
    is already in PHP format, we can output it in the raw format with the `-f` option
    after we set our options, and then pipe the raw PHP code into a file with the
    *.php* extension for posting to the server, as shown here.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们需要设置 `LHOST` 来告诉有效载荷要连接回的 IP 地址，此外我们还可以更改 `LPORT` 选项。因为这个有效载荷已经是 PHP
    格式，我们可以在设置好选项后使用 `-f` 选项将其以原始格式输出，然后将原始 PHP 代码通过管道输出到一个带 *.php* 扩展名的文件中，上传到服务器，如下所示。
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now we upload the file using WebDAV.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用 WebDAV 上传文件。
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As in [Chapter 4](ch04.xhtml "Chapter 4. Using the Metasploit Framework"), we
    need to set up a handler in Msfconsole to catch the payload before we execute
    the script (see [Example 8-3](ch08.xhtml#setting_up_the_payload_handler "Example 8-3. Setting
    up the payload handler")).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在[第 4 章](ch04.xhtml "第 4 章. 使用 Metasploit 框架")中所述，我们需要在 Msfconsole 中设置一个处理程序，以便在执行脚本之前捕获有效载荷（见[示例
    8-3](ch08.xhtml#setting_up_the_payload_handler "示例 8-3. 设置有效载荷处理程序")）。
- en: Example 8-3. Setting up the payload handler
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-3. 设置有效载荷处理程序
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Use *multi/handler* in Msfconsole, set the payload to *php/meterpreter/reverse_tcp*
    ❶, and set `LHOST` ❷ and `LPORT` ❸ appropriately to match the generated payload.
    If this process is unfamiliar to you, jump back to the [Creating Standalone Payloads
    with Msfvenom](ch04.xhtml#creating_standalone_payloads_with_msfven "Creating Standalone
    Payloads with Msfvenom").
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Msfconsole 中使用 *multi/handler*，将有效载荷设置为 *php/meterpreter/reverse_tcp* ❶，并适当设置
    `LHOST` ❷ 和 `LPORT` ❸ 以匹配生成的有效载荷。如果这个过程对你来说不熟悉，可以回顾一下[使用 Msfvenom 创建独立有效载荷](ch04.xhtml#creating_standalone_payloads_with_msfven)。
- en: Running the uploaded payload by opening it in a web browser should provide us
    with a Meterpreter session that we can see when we return to Msfconsole, as shown
    here.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 web 浏览器中打开上传的有效载荷来运行它，应该会为我们提供一个 Meterpreter 会话，当我们返回到 Msfconsole 时可以看到，如下所示。
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can use the Meterpreter command `getuid` to see what privileges our session
    has on the exploited target. Generally speaking, we get the privileges of the
    software we exploited.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Meterpreter 命令 `getuid` 来查看我们的会话在被利用的目标上具有什么权限。一般来说，我们获得的是我们利用的软件的权限。
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We now have system privileges, which will allow us to take complete control
    of the Windows system. (It’s generally a bad idea to allow web server software
    to have system privileges for just this reason. Because XAMPP’s Apache server
    is running as a system service, we have full access to the underlying system.)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有系统权限，这将使我们能够完全控制 Windows 系统。（出于这个原因，一般来说，允许 web 服务器软件拥有系统权限并不好。因为 XAMPP
    的 Apache 服务器作为系统服务运行，我们可以完全访问底层系统。）
- en: Now let’s look at another issue with our XAMPP install.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们 XAMPP 安装的另一个问题。
- en: Exploiting Open phpMyAdmin
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用开放的 phpMyAdmin
- en: The same target XAMPP platform exploited in the previous section also includes
    an open phpMyAdmin install, which we can exploit to run commands on the database
    server. Like Apache, our MySQL server will have either system privileges (if it
    is installed as a Windows service) or the privileges of the user that started
    the MySQL process. By accessing the MySQL database, we can perform an attack similar
    to our WebDAV attack and upload scripts to the web server using MySQL queries.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中利用的同一目标 XAMPP 平台也包括一个开放的 phpMyAdmin 安装，我们可以利用它在数据库服务器上运行命令。像 Apache 一样，我们的
    MySQL 服务器将具有系统权限（如果它作为 Windows 服务安装）或启动 MySQL 进程的用户权限。通过访问 MySQL 数据库，我们可以执行类似于
    WebDAV 攻击的攻击，并使用 MySQL 查询将脚本上传到 web 服务器。
- en: To explore this attack, first navigate to *[http://192.168.20.10/phpmyadmin](http://192.168.20.10/phpmyadmin)*,
    and click the SQL tab at the top. We’ll use MySQL to write a script to the web
    server that we’ll use to get a remote shell. We’ll use a SQL `SELECT` statement
    to output a PHP script to a file on the web server, which will allow us to remotely
    control the target system. We’ll use the script `<?php system($_GET['cmd']); ?>`
    to grab the `cmd` parameter from the URL and execute it using the `system()` command.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索这个攻击，首先导航到 *[http://192.168.20.10/phpmyadmin](http://192.168.20.10/phpmyadmin)*，然后点击顶部的
    SQL 标签。我们将使用 MySQL 编写一个脚本到 web 服务器上，利用它来获取远程 shell。我们将使用 SQL `SELECT` 语句将 PHP
    脚本输出到 web 服务器上的文件，从而允许我们远程控制目标系统。我们将使用脚本 `<?php system($_GET['cmd']); ?>` 从 URL
    中抓取 `cmd` 参数并通过 `system()` 命令执行它。
- en: 'The default install location for XAMPP’s Apache on Windows is *C:\xampp\htodcs\*.
    The syntax for our command is: `SELECT "`*`<script string>`*`"` `into outfile
    "`*`path_to_file_on_web_server`*`"`. Our completed command looks like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: XAMPP 在 Windows 上的 Apache 默认安装位置是 *C:\xampp\htodcs\*。我们的命令语法是：`SELECT "`*`<script
    string>`*`"` `into outfile "`*`path_to_file_on_web_server`*`"`. 完整的命令如下所示：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We use double backslashes to escape, so we don’t end up with the file C:xampphtdocsshell.php,
    which we will not be able to access from the web server.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用双反斜杠进行转义，这样就不会得到文件路径 C:xampphtdocsshell.php，否则我们将无法通过 web 服务器访问它。
- en: '[Figure 8-2](ch08.xhtml#executing_sql_commands "Figure 8-2. Executing SQL commands")
    shows the command entered into the SQL console in phpMyAdmin.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-2](ch08.xhtml#executing_sql_commands "图 8-2. 执行 SQL 命令") 显示了在 phpMyAdmin
    的 SQL 控制台中输入的命令。'
- en: '![Executing SQL commands](httpatomoreillycomsourcenostarchimages2030388.png.jpg)Figure 8-2. Executing
    SQL commands'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![执行 SQL 命令](httpatomoreillycomsourcenostarchimages2030388.png.jpg)图 8-2. 执行
    SQL 命令'
- en: 'Run the completed query in phpMyAdmin, and then browse to the newly created
    file, *[http://192.168.20.10/shell.php](http://192.168.20.10/shell.php)*. The
    script should throw the error *Warning: system() [function.system]: Cannot execute
    a blank command in C:\xampp\htdocs\shell.php on line 1*, because we did not supply
    an `cmd` parameter. (Recall from earlier that *shell.php* grabs the `cmd` parameter
    from the URL and runs it using the PHP `system()` command.) We need to supply
    a `cmd` parameter that tells the script the command we’d like to run on the target
    system. For example, we can ask the Windows XP target to tell us its networking
    information using `ipconfig` as the `cmd` parameter, like so:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '在 phpMyAdmin 中运行完成的查询，然后浏览到新创建的文件 *[http://192.168.20.10/shell.php](http://192.168.20.10/shell.php)*。该脚本应该会抛出错误
    *Warning: system() [function.system]: Cannot execute a blank command in C:\xampp\htdocs\shell.php
    on line 1*，因为我们没有提供 `cmd` 参数。（回想一下，*shell.php* 从 URL 获取 `cmd` 参数，并通过 PHP 的 `system()`
    命令执行它。）我们需要提供一个 `cmd` 参数，告诉脚本我们想在目标系统上运行的命令。例如，我们可以让 Windows XP 目标告诉我们它的网络信息，通过将
    `cmd` 参数设置为 `ipconfig`，像这样：'
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The result is shown in [Figure 8-3](ch08.xhtml#code_execution "Figure 8-3. Code
    execution").
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如 [图 8-3](ch08.xhtml#code_execution "图 8-3. 代码执行") 所示。
- en: '![Code execution](httpatomoreillycomsourcenostarchimages2030390.png.jpg)Figure 8-3. Code
    execution'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![代码执行](httpatomoreillycomsourcenostarchimages2030390.png.jpg)图 8-3. 代码执行'
- en: Downloading a File with TFTP
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 TFTP 下载文件
- en: The previous steps give us a shell with system privileges, which we “upgrade”
    by uploading a more complicated PHP script. But rather than creating a really
    long and complicated SQL `SELECT` query, we can host a file on our Kali machine
    and then use our PHP shell to pull it down to the web server. On Linux, we could
    use `wget` to download files from the command line. This functionality is painfully
    absent on Windows, but we can use TFTP on Windows XP. Let’s use it to upload *meterpreter.php*
    from the previous section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤为我们提供了一个具有系统权限的 shell，我们通过上传一个更复杂的 PHP 脚本来“升级”它。但我们不需要创建一个非常长且复杂的 SQL `SELECT`
    查询，我们可以在 Kali 机器上托管一个文件，然后使用我们的 PHP shell 将其拉取到 Web 服务器。在 Linux 系统中，我们可以使用 `wget`
    从命令行下载文件。这个功能在 Windows 中显得格外缺失，但在 Windows XP 上我们可以使用 TFTP。让我们用它来上传上一节的 *meterpreter.php*。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: TFTP is not the only way we can transfer files with noninteractive command line
    access. In fact, some newer Windows systems do not have TFTP enabled by default.
    You can also have FTP read settings from a file with the `-s` option or use a
    scripting language such as Visual Basic or Powershell on the latest Windows operating
    systems.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: TFTP 不是唯一可以在非交互命令行访问下传输文件的方式。事实上，一些较新的 Windows 系统默认没有启用 TFTP。你还可以通过 `-s` 选项让
    FTP 从文件中读取设置，或者在最新的 Windows 操作系统上使用脚本语言，如 Visual Basic 或 Powershell。
- en: We can use the Atftpd TFTP server to host files on our Kali system. Start Atftpd
    in daemon mode, serving files from the location of your *meterpreter.php* script.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Atftpd TFTP 服务器在我们的 Kali 系统上托管文件。以守护进程模式启动 Atftpd，从 *meterpreter.php*
    脚本所在的位置提供文件。
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Set the `cmd` parameter in the *shell.php* script as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *shell.php* 脚本中设置 `cmd` 参数，如下所示：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This command should pull down *meterpreter.php* to the target’s Apache directory
    using TFTP, as shown in [Figure 8-4](ch08.xhtml#transferring_files_with_tftp "Figure 8-4. Transferring
    files with TFTP").
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令应该会通过 TFTP 将 *meterpreter.php* 拉取到目标的 Apache 目录，如 [图 8-4](ch08.xhtml#transferring_files_with_tftp
    "图 8-4. 通过 TFTP 传输文件") 所示。
- en: '![Transferring files with TFTP](httpatomoreillycomsourcenostarchimages2030392.png)Figure 8-4. Transferring
    files with TFTP'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![通过 TFTP 传输文件](httpatomoreillycomsourcenostarchimages2030392.png)图 8-4. 通过
    TFTP 传输文件'
- en: 'Now we can browse to *[http://192.168.20.10/meterpreter.php](http://192.168.20.10/meterpreter.php)*
    to open a Meterpreter shell. (Be sure to restart the handler to catch the Meterpreter
    connection before executing the script.) And as you can see, though we used an
    attack different from uploading a file through WebDAV, we ended up in the same
    place: We have a Meterpreter shell from the web server using its access to the
    MySQL server to upload files.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以浏览到 *[http://192.168.20.10/meterpreter.php](http://192.168.20.10/meterpreter.php)*
    来打开一个 Meterpreter shell。（在执行脚本之前，确保重新启动处理程序以捕捉 Meterpreter 连接。）正如你所看到的，尽管我们使用了不同于通过
    WebDAV 上传文件的攻击方法，但最终我们到达了同一个地方：我们通过 Web 服务器利用其对 MySQL 服务器的访问权限上传文件，获得了一个 Meterpreter
    shell。
- en: Now let’s look at attacking the other web server on the Windows XP system.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何攻击 Windows XP 系统上的另一个 Web 服务器。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is not the only way we could exploit database access. For example, if you
    find a Microsoft MS SQL database instead, you may be able to use the `xp_cmdshell()`
    function, which acts as a built-in system command shell. For security reasons,
    it is disabled on newer versions of MS SQL, but a user with administrative privileges
    should be able to reenable it, giving you shell access without having to upload
    anything.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是我们利用数据库访问的唯一方式。例如，如果你发现了一个 Microsoft MS SQL 数据库，你可能能够使用 `xp_cmdshell()`
    函数，它充当内建的系统命令行。出于安全考虑，这个函数在新版 MS SQL 中是禁用的，但具有管理员权限的用户应该能够重新启用它，从而在不上传任何东西的情况下获得
    shell 访问权限。
- en: Downloading Sensitive Files
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载敏感文件
- en: 'Recall from [Chapter 6](ch06.xhtml "Chapter 6. Finding Vulnerabilities") that
    our Zervit server on port 3232 has a directory traversal issue that will allow
    us to download files from the remote system without authentication. We can download
    the Windows *boot.ini* configuration file (and other files, too) through the browser
    with the following URL:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请回顾 [第6章](ch06.xhtml "第6章. 寻找漏洞")，我们在端口 3232 上的 Zervit 服务器存在一个目录遍历问题，允许我们在没有身份验证的情况下从远程系统下载文件。我们可以通过浏览器使用以下
    URL 下载 Windows 的 *boot.ini* 配置文件（以及其他文件）：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’ll use this ability to pull files containing password hashes (encrypted passwords)
    for Windows, as well as installed services.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用这一能力提取包含密码哈希值（加密密码）的文件，这些文件可能与 Windows 以及已安装的服务有关。
- en: Downloading a Configuration File
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载配置文件
- en: The default install location for XAMPP is *C:\xampp*, so we can expect the directory
    for FileZilla FTP server to be at *C:\xampp\FileZillaFtp*. A little online research
    on FileZilla tells us that it stores MD5 hashes of passwords in the *FileZilla
    Server.xml* configuration file. Depending on the strength of the FTP passwords
    stored in this file, we may be able to use the MD5 hash value to recover users’
    plaintext FTP passwords.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: XAMPP 的默认安装位置是 *C:\xampp*，所以我们可以预计 FileZilla FTP 服务器的目录位于 *C:\xampp\FileZillaFtp*。通过对
    FileZilla 进行一些在线研究，我们得知它将密码的 MD5 哈希值存储在 *FileZilla Server.xml* 配置文件中。根据这个文件中存储的
    FTP 密码的强度，我们或许可以利用 MD5 哈希值恢复用户的明文 FTP 密码。
- en: We captured the password for user *georgia* in [Chapter 7](ch07.xhtml "Chapter 7. Capturing
    Traffic"), but our target may contain additional accounts. Let’s use the Zervit
    server to download the FileZilla configuration file from *[http://192.168.20.10:3232/index.html?../../../../../../xampp/FileZillaFtp/FileZilla%20Server.xml](http://192.168.20.10:3232/index.html?../../../../../../xampp/FileZillaFtp/FileZilla%20Server.xml)*.
    (Note that %20 is hex encoding for a space.) You can see some of the contents
    of the file in [Example 8-4](ch08.xhtml#filezilla_ftp_configuration_file "Example 8-4. FileZilla
    FTP configuration file").
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第7章](ch07.xhtml "第7章. 捕获流量") 中已经捕获了 *georgia* 用户的密码，但我们的目标可能包含更多账户。让我们使用
    Zervit 服务器从 *[http://192.168.20.10:3232/index.html?../../../../../../xampp/FileZillaFtp/FileZilla%20Server.xml](http://192.168.20.10:3232/index.html?../../../../../../xampp/FileZillaFtp/FileZilla%20Server.xml)*
    下载 FileZilla 配置文件。（注意，%20 是空格的十六进制编码。）你可以在 [示例 8-4](ch08.xhtml#filezilla_ftp_configuration_file
    "示例 8-4. FileZilla FTP 配置文件") 中看到文件的部分内容。
- en: Example 8-4. FileZilla FTP configuration file
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-4. FileZilla FTP 配置文件
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, the configuration file contains two user accounts (in the User
    Name fields): *georgia* and *newuser*. Now all we have to do is figure out their
    passwords based on the stored hashes.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，配置文件中包含了两个用户账户（在用户名字段中）：*georgia* 和 *newuser*。现在我们所要做的就是根据存储的哈希值来找出他们的密码。
- en: We’ll look at turning password hashes back into plaintext passwords (including
    MD5 hashes) in the next chapter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章讨论如何将密码哈希值还原为明文密码（包括 MD5 哈希）。
- en: Downloading the Windows SAM
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载 Windows SAM
- en: 'Speaking of passwords, in addition to the FTP user passwords, we can try pulling
    down the *Windows Security Accounts Manager (SAM)* file that stores Windows hashes.
    The SAM file is obfuscated because the Windows Syskey utility encrypts the password
    hashes inside the SAM file with 128-bit Rivest Cipher 4 (RC4) to provide additional
    security. Even if an attacker or pentester is able to gain access to the SAM file,
    there is a bit more work to do to recover the password hashes. We need a key to
    reverse the RC4 encryption on the hashes. The encryption key for the Syskey utility,
    called the *bootkey*, is stored inside of the Windows SYSTEM file. We need to
    download both the SAM and SYSTEM files to recover the hashes and attempt to reverse
    them into plaintext passwords. In Windows XP, these files are located at *C:\Windows\System32\config*,
    so let’s try downloading the SAM file from the following URL:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 说到密码，除了 FTP 用户密码外，我们还可以尝试下载存储 Windows 哈希值的*Windows 安全账户管理器（SAM）*文件。由于 Windows
    Syskey 工具会使用 128 位 Rivest Cipher 4（RC4）加密 SAM 文件中的密码哈希值以提供额外的安全性，SAM 文件是经过混淆的。即使攻击者或渗透测试人员能够访问
    SAM 文件，仍然需要一些额外的工作来恢复密码哈希值。我们需要一个密钥来解密哈希值中的 RC4 加密。Syskey 工具的加密密钥，称为*启动密钥*，存储在
    Windows SYSTEM 文件中。我们需要下载 SAM 文件和 SYSTEM 文件，以便恢复哈希值并尝试将其转换为明文密码。在 Windows XP 中，这些文件位于*C:\Windows\System32\config*，所以我们可以尝试从以下
    URL 下载 SAM 文件：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we try to use Zervit to download this file, we get a “file not found”
    error. It looks like our Zervit server doesn’t have access to this file. Luckily,
    Windows XP backs up both the SAM and SYSTEM files to the *C:\Windows\repair directory*,
    and if we try to pull down the files from there, Zervit is able to serve them.
    These URLs should do the trick:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试使用 Zervit 下载此文件时，出现了“文件未找到”错误。看起来我们的 Zervit 服务器无法访问这个文件。幸运的是，Windows XP
    会将 SAM 和 SYSTEM 文件备份到*C:\Windows\repair 目录*，如果我们尝试从那里下载文件，Zervit 就能够提供它们。这些 URL
    应该能解决问题：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Like our MD5 hashes, we’ll use the Windows SAM file in the next chapter when
    we cover password attacks in depth.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 像我们的 MD5 哈希值一样，我们将在下一章深入讨论密码攻击时使用 Windows SAM 文件。
- en: Exploiting a Buffer Overflow in Third-Party Software
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用第三方软件中的缓冲区溢出
- en: In [Chapter 6](ch06.xhtml "Chapter 6. Finding Vulnerabilities"), we never did
    find out for sure if the SLMail server on our Windows XP target is vulnerable
    to the POP3 issue CVE-2003-0264\. The version number reported by SLMail (5.5)
    appears to line up with the vulnerability, so let’s try exploiting it. The corresponding
    Metasploit module, *windows/pop3/seattlelab_pass*, has a rank of *great*. (A ranking
    that high is unlikely to crash the service if it fails.)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 6 章](ch06.xhtml "第 6 章。寻找漏洞")中，我们从未确切了解我们的 Windows XP 目标上的 SLMail 服务器是否容易受到
    POP3 问题 CVE-2003-0264 的影响。SLMail 报告的版本号（5.5）似乎与该漏洞一致，所以我们来尝试利用它。相应的 Metasploit
    模块，*windows/pop3/seattlelab_pass*，排名为*优秀*。（如此高的排名意味着如果失败，服务不太可能崩溃。）
- en: '*Windows/pop3/seattlelab_pass* attempts to exploit a buffer overflow in the
    POP3 server. Using it is similar to setting up the MS08-067 exploit, as shown
    in [Example 8-5](ch08.xhtml#exploiting_slmail_5dot5_pop3_with_metasp "Example 8-5. Exploiting
    SLMail 5.5 POP3 with Metasploit").'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*Windows/pop3/seattlelab_pass* 试图利用 POP3 服务器中的缓冲区溢出漏洞。使用它与设置 MS08-067 漏洞类似，如[示例
    8-5](ch08.xhtml#exploiting_slmail_5dot5_pop3_with_metasp "示例 8-5。利用 Metasploit
    攻击 SLMail 5.5 POP3")所示。'
- en: Example 8-5. Exploiting SLMail 5.5 POP3 with Metasploit
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-5。利用 Metasploit 攻击 SLMail 5.5 POP3
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Running this exploit should give us another Meterpreter session on the Windows
    XP target—yet another way to take control of the system. (In [Chapter 13](ch13.xhtml
    "Chapter 13. Post Exploitation"), which covers post exploitation, we’ll see what
    to do once we have a Meterpreter session on a target.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个漏洞利用应该能让我们在 Windows XP 目标上获得另一个 Meterpreter 会话——这是控制系统的另一种方式。（在[第 13 章](ch13.xhtml
    "第 13 章。后期利用")中，我们将看到在获得 Meterpreter 会话后该怎么做。）
- en: Exploiting Third-Party Web Applications
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用第三方 Web 应用程序
- en: In [Chapter 6](ch06.xhtml "Chapter 6. Finding Vulnerabilities"), we used the
    Nikto web scanner against our Linux target and discovered an installation of the
    TikiWiki CMS software version 1.9.8 with a code execution vulnerability in the
    script *graph_formula.php*. A search for *TikiWiki* in Metasploit returns several
    modules, as shown in [Example 8-6](ch08.xhtml#tikiwiki_exploit_information "Example 8-6. TikiWiki
    exploit information").
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 6 章](ch06.xhtml "第 6 章. 寻找漏洞")中，我们对 Linux 目标使用了 Nikto 网络扫描器，发现了一个 TikiWiki
    CMS 软件版本 1.9.8 的安装，其中 *graph_formula.php* 脚本存在代码执行漏洞。在 Metasploit 中搜索 *TikiWiki*
    返回了几个模块，正如在[示例 8-6](ch08.xhtml#tikiwiki_exploit_information "示例 8-6. TikiWiki
    漏洞信息")中所示。
- en: Example 8-6. TikiWiki exploit information
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-6. TikiWiki 漏洞信息
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Based on the module names, *unix/webapp/tikiwiki_graph_formula_exec* ❶ looks
    like the one we need because it has *graph_formula* in its name. Our assumption
    is confirmed when we run `info` on the module. The OSVDB number ❷ listed in the
    references for *unix/webapp/tikiwiki_graph_formula_exec* matches our Nikto output
    from [Chapter 6](ch06.xhtml "Chapter 6. Finding Vulnerabilities").
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 根据模块名称，*unix/webapp/tikiwiki_graph_formula_exec* ❶ 看起来就是我们需要的，因为它的名字中有 *graph_formula*。当我们在该模块上运行
    `info` 命令时，我们的假设得到了确认。*unix/webapp/tikiwiki_graph_formula_exec* 的参考资料中的 OSVDB
    编号❷与我们在[第 6 章](ch06.xhtml "第 6 章. 寻找漏洞")中从 Nikto 扫描获得的输出一致。
- en: The options for this module are different from our previous exploit examples,
    as shown in [Example 8-7](ch08.xhtml#using_the_tikiwiki_exploit "Example 8-7. Using
    the TikiWiki exploit").
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块的选项与我们之前的漏洞利用示例不同，正如在[示例 8-7](ch08.xhtml#using_the_tikiwiki_exploit "示例
    8-7. 使用 TikiWiki 漏洞")中所示。
- en: Example 8-7. Using the TikiWiki exploit
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-7. 使用 TikiWiki 漏洞
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We could set a proxy chain ❶ and/or a virtual host ❸ for the TikiWiki server,
    but we don’t need to here. We can leave the URI set to the default location */tikiwiki*
    ❷.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为 TikiWiki 服务器设置代理链❶和/或虚拟主机❸，但在这里我们不需要这么做。我们可以将 URI 保持在默认位置*/tikiwiki* ❷。
- en: This exploit involves PHP command execution, so naturally, our payloads are
    PHP based. Using the `show payloads` command ([Example 8-8](ch08.xhtml#exploiting_tikiwiki_with_metasploit
    "Example 8-8. Exploiting TikiWiki with Metasploit")) reveals that we can use PHP-based
    Meterpreter ❶ as we did in our XAMPP exploit. We will also need to set our `LHOST`
    option ❷ again.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞涉及 PHP 命令执行，因此我们的有效载荷自然是基于 PHP 的。使用 `show payloads` 命令（[示例 8-8](ch08.xhtml#exploiting_tikiwiki_with_metasploit
    "示例 8-8. 使用 Metasploit 攻击 TikiWiki")）可以看到，我们可以使用基于 PHP 的 Meterpreter❶，就像我们在 XAMPP
    漏洞利用中做的那样。我们还需要再次设置 `LHOST` 选项❷。
- en: Example 8-8. Exploiting TikiWiki with Metasploit
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-8. 使用 Metasploit 攻击 TikiWiki
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, while exploiting the TikiWiki installation, the Metasploit module
    discovered the credentials ❸ for the TikiWiki database. Unfortunately, the MySQL
    server is not listening on the network, so these credentials cannot be used for
    additional compromise. Still, we should note them because they might come in handy
    during post exploitation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在利用 TikiWiki 安装漏洞时，Metasploit 模块发现了 TikiWiki 数据库的凭据❸。不幸的是，MySQL 服务器没有在网络上监听，因此这些凭据无法用于进一步的攻破。不过，我们应该记录下来，因为它们可能在后期利用时派上用场。
- en: Exploiting a Compromised Service
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用已被攻破的服务
- en: 'We noted in [Chapter 6](ch06.xhtml "Chapter 6. Finding Vulnerabilities") that
    the FTP server on the Linux target serves a banner for Very Secure FTP 2.3.4,
    the version replaced with a binary containing a backdoor. Because the official
    code was eventually restored by the authors of Vsftpd, the only way to find out
    if the server on our Linux target has the backdoor code is to test it. (We don’t
    need to worry about potentially crashing the service if it’s not vulnerable: If
    this server doesn’t have the backdoor code, we’ll just get a login error when
    we use the smiley face.)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 6 章](ch06.xhtml "第 6 章. 寻找漏洞")中提到，Linux 目标上的 FTP 服务器提供了 Very Secure FTP
    2.3.4 的版本公告，这个版本被替换为包含后门的二进制文件。因为官方代码最终被 Vsftpd 的作者恢复，唯一能确认我们 Linux 目标上的服务器是否有后门代码的方法就是进行测试。（如果该服务器没有后门代码，我们只会在使用笑脸符号时收到登录错误，不需要担心可能导致服务崩溃。）
- en: Enter any username you like, and add a `:)` at the end (see [Example 8-9](ch08.xhtml#triggering_the_vsftpd_backdoor
    "Example 8-9. Triggering the Vsftpd backdoor")). Use anything for the password,
    as well. If the backdoor is present, it will trigger without valid credentials.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 输入你喜欢的任何用户名，并在末尾加上 `:)`（见[示例 8-9](ch08.xhtml#triggering_the_vsftpd_backdoor
    "示例 8-9. 触发 Vsftpd 后门")）。密码也可以随便填。如果后门存在，它将会在没有有效凭据的情况下触发。
- en: Example 8-9. Triggering the Vsftpd backdoor
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-9. 触发 Vsftpd 后门
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We notice that the login hangs after the password. This tells us that the FTP
    server is still processing our login attempt, and if we query the FTP port again,
    it will continue to respond. Let’s use Netcat to try connecting to port 6200,
    where the root shell should spawn if the backdoor is present.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到密码输入后登录被挂起。这告诉我们FTP服务器仍在处理我们的登录尝试，如果我们再次查询FTP端口，它将继续响应。让我们使用Netcat尝试连接到端口6200，如果后门存在的话，根shell应该会在该端口启动。
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Sure enough, we have a root shell. Root privileges give us total control of
    our target machine. For example, we can get the system password hashes with the
    command `cat /etc/shadow`. Save the password hash for the user *georgia* (*georgia:$1$CNp3mty6$|RWcT0/PVYpDKwyaWWkSg/:15640:0:99999:7:::*)to
    a file called *linuxpasswords.txt*. We will attempt to turn this hash into a plaintext
    password in [Chapter 9](ch09.xhtml "Chapter 9. Password Attacks").
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，我们获得了一个root shell。根权限让我们完全控制目标机器。例如，我们可以使用命令`cat /etc/shadow`获取系统密码哈希。将用户*georgia*的密码哈希(*georgia:$1$CNp3mty6$|RWcT0/PVYpDKwyaWWkSg/:15640:0:99999:7:::*)保存到一个名为*linuxpasswords.txt*的文件中。我们将在[第9章](ch09.xhtml
    "第9章. 密码攻击")尝试将这个哈希转换为明文密码。
- en: Exploiting Open NFS Shares
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用开放的NFS共享
- en: At this point we know that the Linux target has exported user *georgia*’s home
    folder using NFS and that that share is available to anyone without the need for
    credentials. But this might not carry much security risk if we cannot use the
    access to read or write sensitive files.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们知道Linux目标已经通过NFS导出了*georgia*的主文件夹，并且该共享对任何人开放，无需凭证即可访问。但如果我们无法使用访问权限读取或写入敏感文件，这可能不会带来太大的安全风险。
- en: Recall that when we scanned the NFS mount in [Chapter 6](ch06.xhtml "Chapter 6. Finding
    Vulnerabilities"), we saw the *.ssh* directory. This directory could contain the
    user’s private SSH keys as well as keys used for authenticating a user over SSH.
    Let’s see if we can exploit this share. Start by mounting the NFS share on your
    Kali system.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，当我们在[第6章](ch06.xhtml "第6章. 寻找漏洞")扫描NFS挂载时，我们看到了*.ssh*目录。这个目录可能包含用户的私有SSH密钥以及用于通过SSH验证用户的密钥。让我们看看能否利用这个共享。首先，在你的Kali系统上挂载NFS共享。
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This doesn’t look too promising at first glance because *georgia* has no documents,
    pictures, or videos—just some simple buffer overflow examples we will use in [Chapter 16](ch16.xhtml
    "Chapter 16. A Stack-Based Buffer Overflow in Linux"). There doesn’t appear to
    be any sensitive information here, but before we jump to conclusions, let’s see
    what’s in the *.ssh* directory.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始这看起来并不太有希望，因为*georgia*没有文档、图片或视频——只有一些我们将在[第16章](ch16.xhtml "第16章. 基于栈的缓冲区溢出")中使用的简单缓冲区溢出示例。这里似乎没有敏感信息，但在我们得出结论之前，让我们看看*.ssh*目录里有什么。
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We now have access to *georgia*’s SSH keys. The *id_rsa* file is her private
    key, and *id_rsa.pub* is her corresponding public key. We can read or even change
    these values, and we can write to the SSH file *authorized_keys*, which handles
    a list of SSH public keys that are authorized to log in as the user *georgia*.
    And because we have write privileges, we can add our own key here that will allow
    us to bypass password authentication when logging in to the Ubuntu target as *georgia*,
    as shown in [Example 8-10](ch08.xhtml#generating_a_new_ssh_key_pair "Example 8-10. Generating
    a new SSH key pair").
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以访问*georgia*的SSH密钥。*id_rsa*文件是她的私钥，*id_rsa.pub*是她的对应公钥。我们可以读取甚至更改这些值，并且我们可以写入SSH文件*authorized_keys*，它管理着一个授权登录为*georgia*用户的SSH公钥列表。由于我们拥有写权限，我们可以在这里添加自己的密钥，这将允许我们在以*georgia*身份登录Ubuntu目标时绕过密码认证，正如在[示例
    8-10](ch08.xhtml#generating_a_new_ssh_key_pair "示例 8-10. 生成新的SSH密钥对")中所示。
- en: Example 8-10. Generating a new SSH key pair
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-10. 生成新的SSH密钥对
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, we generate a key on our Kali machine using `ssh-keygen`. By default
    our new public key is written to */root/.ssh/id_rsa.pub*, and our private key
    is written to */root/.ssh/id_rsa*. We want to add our public key to the *authorized_keys*
    file for *georgia* on Ubuntu.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`ssh-keygen`在我们的Kali机器上生成一个密钥。默认情况下，我们的新公钥会写入*/root/.ssh/id_rsa.pub*，而私钥会写入*/root/.ssh/id_rsa*。我们要将我们的公钥添加到Ubuntu上*georgia*的*authorized_keys*文件中。
- en: Next, let’s append the newly generated public key to *georgia*’s *authorized_keys*
    file. `cat` out the contents of the */root/.ssh/id_rsa.pub* file, and append it
    to *georgia*’s *authorized_keys* file.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将新生成的公钥追加到*georgia*的*authorized_keys*文件中。使用`cat`命令将*/root/.ssh/id_rsa.pub*文件的内容输出，并将其追加到*georgia*的*authorized_keys*文件中。
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We should now be able to SSH into the Linux target as *georgia*. Let’s give
    it a try.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该能够以*georgia*身份通过SSH连接到Linux目标。让我们试试看。
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That worked nicely. We can now successfully authenticate with the Linux target
    using public key authentication.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法很有效。现在我们可以成功地通过公钥认证与Linux目标进行身份验证。
- en: We could also have gained access by copying *georgia*’s key to the Kali machine.
    To do so, we first delete the SSH identity we created.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过将*georgia*的密钥复制到Kali机器来获得访问权限。为此，我们首先删除我们创建的SSH身份。
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, we copy *georgia*’s private key (*id_rsa*) and public key (*id_rsa.pub*)
    to root’s *.ssh* directory on Kali, and use the `ssh-add` command to add the identity
    to the authentication agent before we try to SSH into the Linux target.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将*georgia*的私钥（*id_rsa*）和公钥（*id_rsa.pub*）复制到Kali上root的*.ssh*目录，并使用`ssh-add`命令将身份添加到认证代理中，然后再尝试通过SSH连接到Linux目标。
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Again, we are able to gain access to the target by manipulating the SSH keys.
    We started with the ability to read and write files in *georgia*’s home directory.
    Now we have a shell on the Linux system as user *georgia* without needing a password.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们通过操控SSH密钥成功访问目标。我们从能够读取和写入*georgia*的主目录文件开始。现在我们已经以*georgia*用户的身份获得了Linux系统的shell，而无需密码。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we were able to combine the information we gathered in [Chapter 5](ch05.xhtml
    "Chapter 5. Information Gathering") with the vulnerabilities discovered in [Chapter 6](ch06.xhtml
    "Chapter 6. Finding Vulnerabilities") to exploit multiple compromises on both
    the Windows XP and Linux targets. We used various techniques, including attacking
    misconfigured web servers, piggybacking on backdoored software, taking advantage
    of poor access control to sensitive files, exploiting vulnerabilities in the underlying
    system, and exploiting issues in third-party software.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们能够将[第5章](ch05.xhtml "第5章. 信息收集")中收集的信息与[第6章](ch06.xhtml "第6章. 寻找漏洞")中发现的漏洞结合起来，利用多个漏洞对Windows
    XP和Linux目标进行攻击。我们使用了多种技术，包括攻击配置错误的Web服务器、利用后门软件、利用对敏感文件的访问控制不当、利用底层系统的漏洞以及利用第三方软件中的问题。
- en: Now that we’ve managed to get a foothold in the systems, in the next chapter,
    let’s turn to cracking the passwords we found on the systems.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经成功获得了系统的立足点，在下一章中，我们将开始破解我们在系统上找到的密码。
