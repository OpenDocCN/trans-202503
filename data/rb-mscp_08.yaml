- en: Chapter 8. How Ruby Borrowed a Decades-Old Idea from Lisp
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。Ruby 如何借鉴 Lisp 中的一个几十年历史的想法
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Blocks are Ruby’s implementation of closures.*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*块是 Ruby 对闭包的实现。*'
- en: Blocks are one of the most commonly used and powerful features of Ruby because
    they allow you to pass a code snippet to `Enumerable` methods, such as `each`,
    `detect`, or `inject`. Using the `yield` keyword, you can also write your own
    custom iterators or functions that call blocks for other reasons. Ruby code containing
    blocks is often more succinct, elegant, and expressive than equivalent code in
    older languages, such as C.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 块是 Ruby 中最常用且强大的特性之一，因为它们允许你将代码片段传递给 `Enumerable` 方法，例如 `each`、`detect` 或 `inject`。通过使用
    `yield` 关键字，你还可以编写自定义迭代器或函数，以调用其他原因的块。包含块的 Ruby 代码通常比等效的老旧语言（如 C）代码更简洁、更优雅、更具表现力。
- en: But don’t jump to the conclusion that blocks are a new idea! In fact, blocks
    are not new to Ruby at all. The computer science concept behind blocks, called
    *closures*, was first invented by Peter J. Landin in 1964, a few years after the
    original version of Lisp was created by John McCarthy in 1958\. Closures were
    later adopted by Lisp, or—more precisely—a dialect of Lisp called *Scheme*, which
    was invented by Gerald Sussman and Guy Steele in 1975\. Sussman and Steele’s use
    of closures in Scheme brought the idea to many programmers for the first time.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要急于得出结论，认为块是一个新概念！事实上，块在 Ruby 中并不新鲜。块背后的计算机科学概念，称为*闭包*，最早由 Peter J. Landin
    在 1964 年发明，距离 Lisp 的原始版本由 John McCarthy 在 1958 年创建才几年。闭包后来被 Lisp 采用，或者更准确地说，被
    Lisp 的一个方言——*Scheme* 采用，Scheme 是由 Gerald Sussman 和 Guy Steele 在 1975 年发明的。Sussman
    和 Steele 在 Scheme 中使用闭包的做法首次将这一概念带给了许多程序员。
- en: But what does the word *closure* actually mean in this context? In other words,
    exactly what are Ruby blocks? Are they just the snippet of Ruby code that appears
    between the `do` and `end` keywords? In this chapter I’ll review how Ruby implements
    blocks internally and demonstrate how they meet the definition of *closure* used
    by Sussman and Steele back in 1975\. I’ll also show how blocks, lambdas, and procs
    are all different ways of looking at closures.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 那么在这个语境中，*闭包*一词到底是什么意思呢？换句话说，Ruby 块到底是什么？它们只是出现在 `do` 和 `end` 关键字之间的 Ruby 代码片段吗？在本章中，我将回顾
    Ruby 如何在内部实现块，并展示它们如何符合 Sussman 和 Steele 在 1975 年提出的*闭包*定义。我还将展示块、lambda 和 proc
    如何作为不同的方式来理解闭包。
- en: Roadmap
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 路线图
- en: '[Blocks: Closures in Ruby](ch08.html#blocks_closures_in_ruby "Blocks: Closures
    in Ruby")'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[块：Ruby 中的闭包](ch08.html#blocks_closures_in_ruby "块：Ruby 中的闭包")'
- en: '[Stepping Through How Ruby Calls a Block](ch08.html#stepping_through_how_ruby_calls_a_block
    "Stepping Through How Ruby Calls a Block")'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[逐步了解 Ruby 如何调用块](ch08.html#stepping_through_how_ruby_calls_a_block "逐步了解 Ruby
    如何调用块")'
- en: '[Borrowing an Idea from 1975](ch08.html#borrowing_an_idea_from_1975 "Borrowing
    an Idea from 1975")'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[借鉴 1975 年的一个想法](ch08.html#borrowing_an_idea_from_1975 "借鉴 1975 年的一个想法")'
- en: '[The rb_block_t and rb_control_frame_t Structures](ch08.html#rbunderscoreblockunderscoret_and_rbu
    "The rb_block_t and rb_control_frame_t Structures")'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[rb_block_t 和 rb_control_frame_t 结构](ch08.html#rbunderscoreblockunderscoret_and_rbu
    "rb_block_t 和 rb_control_frame_t 结构")'
- en: '[Experiment 8-1: Which Is Faster: A while Loop or Passing a Block to each?](ch08.html#experiment_8-1_which_is_faster_a_while_l
    "Experiment 8-1: Which Is Faster: A while Loop or Passing a Block to each?")'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实验 8-1：哪种更快：while 循环还是将块传递给 each？](ch08.html#experiment_8-1_which_is_faster_a_while_l
    "实验 8-1：哪种更快：while 循环还是将块传递给 each？")'
- en: '[Lambdas and Procs: Treating a Function as a First-Class Citizen](ch08.html#lambdas_and_procs_treating_a_function_as
    "Lambdas and Procs: Treating a Function as a First-Class Citizen")'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Lambdas 和 Procs：将函数视为一等公民](ch08.html#lambdas_and_procs_treating_a_function_as
    "Lambdas 和 Procs：将函数视为一等公民")'
- en: '[Stack vs. Heap Memory](ch08.html#stack_vsdot_heap_memory "Stack vs. Heap Memory")'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[栈与堆内存](ch08.html#stack_vsdot_heap_memory "栈与堆内存")'
- en: '[A Closer Look at How Ruby Saves a String Value](ch08.html#closer_look_at_how_ruby_saves_a_string
    "A Closer Look at How Ruby Saves a String Value")'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[深入了解 Ruby 如何保存字符串值](ch08.html#closer_look_at_how_ruby_saves_a_string "深入了解
    Ruby 如何保存字符串值")'
- en: '[How Ruby Creates a Lambda](ch08.html#how_ruby_creates_a_lambda "How Ruby Creates
    a Lambda")'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby 如何创建 Lambda](ch08.html#how_ruby_creates_a_lambda "Ruby 如何创建 Lambda")'
- en: '[How Ruby Calls a Lambda](ch08.html#how_ruby_calls_a_lambda "How Ruby Calls
    a Lambda")'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby 如何调用 Lambda](ch08.html#how_ruby_calls_a_lambda "Ruby 如何调用 Lambda")'
- en: '[The Proc Object](ch08.html#proc_object "The Proc Object")'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Proc 对象](ch08.html#proc_object "Proc 对象")'
- en: '[Experiment 8-2: Changing Local Variables After Calling lambda](ch08.html#experiment_8-2_changing_local_variables
    "Experiment 8-2: Changing Local Variables After Calling lambda")'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实验 8-2: 调用 lambda 后改变局部变量](ch08.html#experiment_8-2_changing_local_variables
    "实验 8-2: 调用 lambda 后改变局部变量")'
- en: '[Calling lambda More Than Once in the Same Scope](ch08.html#calling_lambda_more_than_once_in_the_sam
    "Calling lambda More Than Once in the Same Scope")'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在同一作用域内多次调用 lambda](ch08.html#calling_lambda_more_than_once_in_the_sam "在同一作用域内多次调用
    lambda")'
- en: '[Summary](ch08.html#summary-id00033 "Summary")'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](ch08.html#summary-id00033 "总结")'
- en: 'Blocks: Closures in Ruby'
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块：Ruby 中的闭包
- en: Internally, Ruby represents each block using a C structure called `rb_block_t`,
    shown in [Figure 8-1](ch08.html#whatapostrophes_inside_the_rbunderscoreb "Figure 8-1. What’s
    inside the rb_block_t C structure?"). By learning what Ruby stores in `rb_block_t`,
    we can find out exactly what a block is.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 内部地，Ruby 使用一个名为 `rb_block_t` 的 C 结构来表示每个块，参见[图 8-1](ch08.html#whatapostrophes_inside_the_rbunderscoreb
    "图 8-1. rb_block_t C 结构内部是什么？")。通过了解 Ruby 在 `rb_block_t` 中存储的内容，我们可以准确地弄清楚一个块是什么。
- en: '![What’s inside the rb_block_t C structure?](httpatomoreillycomsourcenostarchimages1854175.png.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![rb_block_t C 结构内部是什么？](httpatomoreillycomsourcenostarchimages1854175.png.jpg)'
- en: Figure 8-1. What’s inside the rb_block_t C structure?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-1. rb_block_t C 结构内部是什么？
- en: As we did in [Chapter 5](ch05.html "Chapter 5. Objects and Classes") with the
    `RClass` structure, let’s deduce the contents of the `rb_block_t` structure based
    on what we know blocks can do in Ruby. We’ll begin with the most obvious attribute
    of blocks. We know that each block must consist of a piece of Ruby code, or internally
    a set of compiled YARV bytecode instructions. For example, suppose we call a method
    and pass a block as a parameter, as shown in [Example 8-1](ch08.html#superficiallycomma_a_block_is_just_a_sni
    "Example 8-1. Superficially, a block is just a snippet of Ruby code.").
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第 5 章](ch05.html "第 5 章. 对象与类")中对 `RClass` 结构的分析一样，我们也可以基于块在 Ruby 中的功能推测
    `rb_block_t` 结构的内容。我们将从块的最明显特征开始。我们知道每个块必须包含一段 Ruby 代码，或者在内部是编译后的 YARV 字节码指令。例如，假设我们调用一个方法并传递一个块作为参数，见[示例
    8-1](ch08.html#superficiallycomma_a_block_is_just_a_sni "示例 8-1. 表面上，一个块只是 Ruby
    代码的一小段")。
- en: Example 8-1. Superficially, a block is just a snippet of Ruby code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-1. 表面上，一个块只是 Ruby 代码的一小段。
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When executing the `10.times` call, Ruby needs to know what code to iterate
    over. Therefore, the `rb_block_t` structure must contain a pointer to that code,
    as shown in [Figure 8-2](ch08.html#rbunderscoreblockunderscoret_structu "Figure 8-2. The
    rb_block_t structure contains a pointer to a snippet of YARV instructions.").
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行 `10.times` 调用时，Ruby 需要知道要迭代的代码是什么。因此，`rb_block_t` 结构必须包含指向该代码的指针，如[图 8-2](ch08.html#rbunderscoreblockunderscoret_structu
    "图 8-2. rb_block_t 结构包含指向 YARV 指令片段的指针")所示。
- en: '![The rb_block_t structure contains a pointer to a snippet of YARV instructions.](httpatomoreillycomsourcenostarchimages1854177.png.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![rb_block_t 结构包含指向 YARV 指令片段的指针。](httpatomoreillycomsourcenostarchimages1854177.png.jpg)'
- en: Figure 8-2. The `rb_block_t` structure contains a pointer to a snippet of YARV
    instructions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-2. `rb_block_t` 结构包含指向 YARV 指令片段的指针。
- en: The value `iseq` is a pointer to the YARV instructions for the Ruby code in
    the block.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 值 `iseq` 是指向块中 Ruby 代码的 YARV 指令的指针。
- en: Another obvious but often overlooked behavior of blocks is that they can access
    variables in the surrounding or parent Ruby scope, as shown in [Example 8-2](ch08.html#code_inside_the_block_accesses_the_v
    "Example 8-2. The code inside the block accesses the variable str from the surrounding
    code.").
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个显而易见但常被忽视的块行为是，块可以访问周围或父级 Ruby 作用域中的变量，正如在[示例 8-2](ch08.html#code_inside_the_block_accesses_the_v
    "示例 8-2. 块内的代码访问来自周围代码的变量 str") 中所示。
- en: Example 8-2. The code inside the block accesses the variable `str` from the
    surrounding code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-2. 块内的代码访问来自周围代码的 `str` 变量。
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here the `puts` function call at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)
    refers equally to the `str2` variable inside the block and the `str` variable
    defined in the surrounding code at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
    Obviously blocks can access values from the code surrounding them. This ability
    is one of the things that makes blocks useful.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`puts` 函数调用在 ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg) 中同时引用了块内的
    `str2` 变量以及在周围代码中定义的 `str` 变量，位置见 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)。显然，块可以访问它们周围代码中的值。这种能力正是块有用之处之一。
- en: 'Blocks have in some sense a dual personality. On the one hand, they behave
    like separate methods: You can call them and pass them arguments just as you would
    any method. On the other hand, they’re part of the surrounding function or method.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 块在某种程度上具有双重特性。一方面，它们表现得像独立的方法：你可以像调用任何方法一样调用它们并传递参数。另一方面，它们是周围函数或方法的一部分。
- en: Stepping Through How Ruby Calls a Block
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤解析 Ruby 如何调用块
- en: How does this work internally? Does Ruby implement blocks as separate methods
    or as part of the surrounding method? Let’s step through [Example 8-2](ch08.html#code_inside_the_block_accesses_the_v
    "Example 8-2. The code inside the block accesses the variable str from the surrounding
    code.") to see what happens inside Ruby when you call a block.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何在内部工作的？Ruby 是将块实现为独立的方法，还是作为周围方法的一部分？让我们通过 [示例 8-2](ch08.html#code_inside_the_block_accesses_the_v
    "示例 8-2. 块内的代码访问周围代码中的变量 str.") 步骤查看，当你调用块时，Ruby 内部发生了什么。
- en: When Ruby executes the first line of code from [Example 8-2](ch08.html#code_inside_the_block_accesses_the_v
    "Example 8-2. The code inside the block accesses the variable str from the surrounding
    code.") at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg), `str =
    "The quick brown fox"`, YARV stores the local variable `str` on its internal stack.
    YARV tracks the location of `str` using the `EP`, or environment pointer, located
    in the current `rb_control_frame_t` structure, as shown in [Figure 8-3](ch08.html#ruby_saves_the_local_variable_str_on_the
    "Figure 8-3. Ruby saves the local variable str on the stack.").^([[1](#ftn.ch08fn01)])
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Ruby 执行 [示例 8-2](ch08.html#code_inside_the_block_accesses_the_v "示例 8-2. 块内的代码访问周围代码中的变量
    str.") 中的第一行代码时，在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 处，`str
    = "The quick brown fox"`，YARV 将局部变量 `str` 存储在其内部栈上。YARV 使用 `EP`（环境指针）追踪 `str`
    的位置，`EP` 位于当前的 `rb_control_frame_t` 结构中，如 [图 8-3](ch08.html#ruby_saves_the_local_variable_str_on_the
    "图 8-3. Ruby 将局部变量 str 保存到栈上。") 所示。^([[1](#ftn.ch08fn01)])
- en: '![Ruby saves the local variable str on the stack.](httpatomoreillycomsourcenostarchimages1854179.png.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 将局部变量 str 保存到栈上。](httpatomoreillycomsourcenostarchimages1854179.png.jpg)'
- en: Figure 8-3. Ruby saves the local variable `str` on the stack.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-3. Ruby 将局部变量 `str` 保存到栈上。
- en: Next, Ruby reaches the `10.times do` call at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    in [Example 8-2](ch08.html#code_inside_the_block_accesses_the_v "Example 8-2. The
    code inside the block accesses the variable str from the surrounding code.").
    Before executing the actual iteration—that is, before calling the `times` method—Ruby
    creates and initializes a new `rb_block_t` structure to represent the block. Ruby
    needs to create the block structure now because the block is really just another
    argument to the `times` method. [Figure 8-4](ch08.html#ruby_creates_a_new_rbunderscoreblockunde
    "Figure 8-4. Ruby creates a new rb_block_t structure before calling the method
    and passing the block to it.") shows this new `rb_block_t` structure.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Ruby 在 [示例 8-2](ch08.html#code_inside_the_block_accesses_the_v "示例 8-2.
    块内的代码访问周围代码中的变量 str.") 中到达 `10.times do` 调用，在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    处。执行实际迭代之前——也就是在调用 `times` 方法之前——Ruby 创建并初始化一个新的 `rb_block_t` 结构来表示块。Ruby 现在需要创建这个块结构，因为块实际上只是
    `times` 方法的另一个参数。[图 8-4](ch08.html#ruby_creates_a_new_rbunderscoreblockunde "图
    8-4. Ruby 在调用方法并将块传递给它之前创建了一个新的 rb_block_t 结构。") 显示了这个新的 `rb_block_t` 结构。
- en: When creating the new block structure, Ruby copies the current value of the
    `EP` into the new block. In other words, Ruby saves the location of the current
    stack frame in the new block.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新的块结构时，Ruby 将 `EP` 的当前值复制到新的块中。换句话说，Ruby 将当前栈帧的位置保存在新的块中。
- en: '![Ruby creates a new rb_block_t structure before calling the method and passing
    the block to it.](httpatomoreillycomsourcenostarchimages1854181.png.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 在调用方法并将块传递给它之前创建了一个新的 rb_block_t 结构。](httpatomoreillycomsourcenostarchimages1854181.png.jpg)'
- en: Figure 8-4. Ruby creates a new `rb_block_t` structure before calling the method
    and passing the block to it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-4. Ruby 在调用方法并将块传递给它之前创建了一个新的 `rb_block_t` 结构。
- en: 'Next, Ruby calls the `times` method on the object `10`, an instance of the
    `Fixnum` class. While doing this, YARV creates a new frame on its internal stack.
    Now we have two stack frames: above, a new stack frame for the `Fixnum.times`
    method, and below, the original stack frame used by the top-level function (see
    [Figure 8-5](ch08.html#ruby_creates_a_new_stack_frame_when_it_e "Figure 8-5. Ruby
    creates a new stack frame when it executes the 10.times call.")).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Ruby 在 `10` 对象（`Fixnum` 类的一个实例）上调用 `times` 方法。在执行此操作时，YARV 在其内部堆栈上创建了一个新的帧。现在我们有两个堆栈帧：上方是
    `Fixnum.times` 方法的新堆栈帧，下面是用于顶层函数的原始堆栈帧（见 [图 8-5](ch08.html#ruby_creates_a_new_stack_frame_when_it_e
    "图 8-5. Ruby 在执行 10.times 调用时创建了一个新的堆栈帧。")）。
- en: '![Ruby creates a new stack frame when it executes the 10.times call.](httpatomoreillycomsourcenostarchimages1854183.png.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 在执行 10.times 调用时创建了一个新的堆栈帧。](httpatomoreillycomsourcenostarchimages1854183.png.jpg)'
- en: Figure 8-5. Ruby creates a new stack frame when it executes the `10.times` call.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-5. Ruby 在执行 `10.times` 调用时创建了一个新的堆栈帧。
- en: Ruby implements the `times` method internally using its own C code. Although
    this is a built-in method, Ruby implements it just as you probably would. Ruby
    starts to iterate over the numbers 0, 1, 2, and so on, up to 9, and then it calls
    `yield`, calling the block once for each of these integers. Finally, the code
    that implements `yield` internally calls the block each time it moves through
    the loop, pushing a third frame onto the top of the stack for the code inside
    the block to use. [Figure 8-6](ch08.html#ruby_creates_a_third_stack_frame_when_th
    "Figure 8-6. Ruby creates a third stack frame when the 10.times method yields
    to the block.") shows this third stack frame.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 使用自己的 C 代码在内部实现 `times` 方法。尽管这是一个内置方法，但 Ruby 的实现方式与你可能实现的方法类似。Ruby 开始迭代数字
    0、1、2 等，直到 9，然后它调用 `yield`，每次为这些整数调用一次块。最后，实现 `yield` 的代码在内部每次通过循环时都会调用块，为块中的代码在堆栈顶部推送第三个帧。
    [图 8-6](ch08.html#ruby_creates_a_third_stack_frame_when_th "图 8-6. Ruby 在 `10.times`
    方法调用块时创建了第三个堆栈帧。") 展示了这个第三个堆栈帧。
- en: '![Ruby creates a third stack frame when the 10.times method yields to the block.](httpatomoreillycomsourcenostarchimages1854185.png.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 在 `10.times` 方法调用块时创建了第三个堆栈帧。](httpatomoreillycomsourcenostarchimages1854185.png.jpg)'
- en: Figure 8-6. Ruby creates a third stack frame when the `10.times` method yields
    to the block.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-6. Ruby 在 `10.times` 方法调用块时创建了第三个堆栈帧。
- en: 'On the left side of the figure, we now have three stack frames:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图的左侧现在有三个堆栈帧：
- en: On the top is the new stack frame for the block, containing the `str2` variable
    defined at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg) in [Example 8-2](ch08.html#code_inside_the_block_accesses_the_v
    "Example 8-2. The code inside the block accesses the variable str from the surrounding
    code.").
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在顶部是为块创建的新堆栈帧，包含在[示例 8-2](ch08.html#code_inside_the_block_accesses_the_v "示例
    8-2. 块内的代码访问来自外部代码的变量 str。")中定义的 `str2` 变量，位于 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)。
- en: In the middle is the stack frame used by the internal C code that implements
    the `Fixnum#times` method.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间是用于实现 `Fixnum#times` 方法的内部 C 代码的堆栈帧。
- en: And at the bottom is the original function’s stack frame, containing the `str`
    variable defined at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    in [Example 8-2](ch08.html#code_inside_the_block_accesses_the_v "Example 8-2. The
    code inside the block accesses the variable str from the surrounding code.").
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最底部是原始函数的堆栈帧，包含在[示例 8-2](ch08.html#code_inside_the_block_accesses_the_v "示例
    8-2. 块内的代码访问来自外部代码的变量 str。")中定义的 `str` 变量，位于 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)。
- en: While creating the new stack frame, Ruby’s internal `yield` code copies the
    `EP` from the block into the new stack frame. Now the code inside the block can
    access both its local variables, directly via the `rb_control_frame_t` structure,
    and the variables from the parent scope, indirectly via the `EP` pointer using
    dynamic variable access. Specifically, this allows the `puts` statement at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)
    in [Example 8-2](ch08.html#code_inside_the_block_accesses_the_v "Example 8-2. The
    code inside the block accesses the variable str from the surrounding code.") to
    access the `str2` variable from the parent scope.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新的栈帧时，Ruby 内部的 `yield` 代码将 `EP` 从块中复制到新的栈帧中。现在，块内的代码可以通过 `rb_control_frame_t`
    结构直接访问它的局部变量，并通过 `EP` 指针间接访问父作用域中的变量，利用动态变量访问。具体来说，这使得 [示例 8-2](ch08.html#code_inside_the_block_accesses_the_v
    "示例 8-2. 代码内的块访问来自周围代码的变量 str.") 中的 `puts` 语句能够访问父作用域中的 `str2` 变量。
- en: Borrowing an Idea from 1975
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 借用 1975 年的一个想法
- en: 'So far we’ve seen that Ruby’s `rb_block_t` structure contains two important
    values:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到 Ruby 的 `rb_block_t` 结构包含两个重要的值：
- en: A pointer to a snippet of YARV code instructions—the `iseq` pointer
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向 YARV 代码指令片段的指针——`iseq` 指针
- en: A pointer to a location on YARV’s internal stack, the location that was at the
    top of the stack when the block was created—the `EP` pointer
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向 YARV 内部栈位置的指针，即在创建块时栈顶所在的位置——`EP` 指针
- en: '[Figure 8-7](ch08.html#so_far_weapostropheve_seen_that_ruby_blo "Figure 8-7. So
    far we’ve seen that Ruby blocks contain a pointer to a YARV instruction snippet
    and a location on the YARV stack.") shows these two values in the `rb_block_t`
    structure.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-7](ch08.html#so_far_weapostropheve_seen_that_ruby_blo "图 8-7。到目前为止，我们已经看到
    Ruby 块包含指向 YARV 指令片段的指针和 YARV 栈上的一个位置。") 显示了 `rb_block_t` 结构中的这两个值。'
- en: '![So far we’ve seen that Ruby blocks contain a pointer to a YARV instruction
    snippet and a location on the YARV stack.](httpatomoreillycomsourcenostarchimages1854187.png.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![到目前为止，我们已经看到 Ruby 块包含指向 YARV 指令片段的指针和 YARV 栈上的一个位置。](httpatomoreillycomsourcenostarchimages1854187.png.jpg)'
- en: Figure 8-7. So far we’ve seen that Ruby blocks contain a pointer to a YARV instruction
    snippet and a location on the YARV stack.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-7。到目前为止，我们已经看到 Ruby 块包含指向 YARV 指令片段的指针和 YARV 栈上的一个位置。
- en: We also saw that Ruby uses the `EP` when a block accesses values from the surrounding
    code. At first, this seems like a very technical, unimportant detail. This is
    obviously a behavior we expect Ruby blocks to exhibit, and the `EP` seems to be
    a minor, uninteresting part of Ruby’s internal implementation of blocks. Or is
    it?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到，当 Ruby 块访问周围代码中的值时，Ruby 使用 `EP`。一开始，这看起来像是一个非常技术性的、不重要的细节。这显然是我们期望 Ruby
    块表现出的行为，而 `EP` 似乎只是 Ruby 内部实现块的一个小细节，一个不那么引人注目的部分。或者说它不是吗？
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1854189.png.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages1854189.png.jpg)'
- en: '*The IBM 704, above, was the first computer to run Lisp, in the early 1960s.
    (Credit: NASA)*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*上图中的 IBM 704 是第一台在 1960 年代初运行 Lisp 的计算机。（来源：NASA）*'
- en: 'The `EP` is actually a profoundly important part of Ruby internals. It’s the
    basis for Ruby’s implementation of *closures*, the computer science concept introduced
    in Lisp long before Ruby was created in the 1990s. Here’s how Sussman and Steele
    defined the term *closure* in 1975:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`EP` 实际上是 Ruby 内部实现中一个非常重要的部分。它是 Ruby 实现 *闭包* 的基础，闭包是一个计算机科学概念，在 Ruby 创立之前的
    Lisp 中就已被引入。以下是 Sussman 和 Steele 在 1975 年对 *闭包* 一词的定义：'
- en: In order to solve this problem we introduce the notion of a closure [11, 14]
    which is a data structure containing a lambda expression, and an environment to
    be used when that lambda expression is applied to arguments.^([[2](#ftn.ch08fn02)])
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们引入了闭包（[11, 14]）的概念，它是一个数据结构，包含一个 lambda 表达式和一个在应用该 lambda 表达式时使用的环境。^([[2](#ftn.ch08fn02)])
- en: 'They define a closure to be the combination of the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 他们定义闭包为以下内容的组合：
- en: A “lambda expression”—that is, a function that takes a set of arguments
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个“lambda 表达式”——即一个接受一组参数的函数
- en: An environment to be used when calling that lambda or function
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用该 lambda 或函数时使用的环境
- en: Let’s take another look at the internal `rb_block_t` structure, repeated for
    convenience in [Figure 8-8](ch08.html#blocks_are_the_combination_of_a_function
    "Figure 8-8. Blocks are the combination of a function and the environment to use
    when calling that function.").
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一下内部的 `rb_block_t` 结构体，为了方便起见，重复在[图 8-8](ch08.html#blocks_are_the_combination_of_a_function
    "图 8-8. 块是一个函数与调用该函数时使用的环境的结合。")中展示。
- en: '![Blocks are the combination of a function and the environment to use when
    calling that function.](httpatomoreillycomsourcenostarchimages1854191.png.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![块是一个函数与调用该函数时使用的环境的结合。](httpatomoreillycomsourcenostarchimages1854191.png.jpg)'
- en: Figure 8-8. Blocks are the combination of a function and the environment to
    use when calling that function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-8. 块是一个函数与调用该函数时使用的环境的结合。
- en: 'This structure meets Sussman and Steele’s definition of a closure:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构体符合 Sussman 和 Steele 对闭包的定义：
- en: '`iseq` is a pointer to a lambda expression—a function or code snippet.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iseq` 是指向一个 lambda 表达式的指针——即一个函数或代码片段。'
- en: '`EP` is a pointer to the environment to be used when calling that lambda or
    function—that is, a pointer to the surrounding stack frame.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EP` 是指向调用该 lambda 或函数时使用的环境的指针——即指向周围堆栈帧的指针。'
- en: Following this train of thought, we can see that blocks are Ruby’s implementation
    of closures. Ironically, blocks—one of the features that makes Ruby so elegant
    and modern—are based on research and work done at least 20 years before the birth
    of Ruby!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个思路，我们可以看到块（blocks）是 Ruby 实现闭包的方式。具有讽刺意味的是，块——正是使 Ruby 既优雅又现代的特性之一——基于的是至少在
    Ruby 诞生前 20 年就已经完成的研究和工作！
- en: The rb_block_t and rb_control_frame_t Structures
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`rb_block_t` 和 `rb_control_frame_t` 结构体'
- en: In Ruby 1.9 and later, you’ll find the definition of the `rb_block_t` structure
    in the *vm_core.h* file, as shown in [Example 8-3](ch08.html#definition_of_rbunderscoreblockunder
    "Example 8-3. The definition of rb_block_t from vm_core.h").
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 1.9 及以后的版本中，你可以在 *vm_core.h* 文件中找到 `rb_block_t` 结构体的定义，如 [示例 8-3](ch08.html#definition_of_rbunderscoreblockunder
    "示例 8-3. rb_block_t 的定义，来自 vm_core.h") 所示。
- en: Example 8-3. The definition of `rb_block_t` from *vm_core.h*
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-3. `rb_block_t` 结构体定义，来自 *vm_core.h*
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can see the `iseq` ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)
    and `ep` ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg) values described
    above, along with a few other values:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到上面描述的 `iseq` ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)
    和 `ep` ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg) 值，以及一些其他值：
- en: '`self` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg): The value
    the `self` pointer had when the block was first referred to is also an important
    part of the closure’s environment. Ruby executes block code inside the same object
    context that the code had outside the block.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)：当块首次被引用时，`self`
    指针指向的值也是闭包环境的一个重要部分。Ruby 在与块外部相同的对象上下文中执行块代码。'
- en: '`klass` ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg): Along with
    `self`, Ruby also keeps track of the class of the current object using this pointer.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`klass` ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)：与 `self`
    一起，Ruby 还使用这个指针来追踪当前对象的类。'
- en: '`proc` ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg): Ruby uses
    this value when it creates a proc object from a block. As we’ll see in the next
    section, procs and blocks are closely related.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proc` ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg)：Ruby 在从块创建
    proc 对象时会使用这个值。正如我们将在下一节中看到的，procs 和块是密切相关的。'
- en: Right above the definition of `rb_block_t` in *vm_core.h*, we see the definition
    of the `rb_control_frame_t` structure, as shown in [Example 8-4](ch08.html#definition_of_rbunderscorecontrolund
    "Example 8-4. The definition of rb_control_frame_t from vm_core.h").
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *vm_core.h* 中 `rb_block_t` 的定义上方，我们可以看到 `rb_control_frame_t` 结构体的定义，如 [示例
    8-4](ch08.html#definition_of_rbunderscorecontrolund "示例 8-4. rb_control_frame_t
    的定义，来自 vm_core.h") 所示。
- en: Example 8-4. The definition of `rb_control_frame_t` from *vm_core.h*
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-4. `rb_control_frame_t` 结构体定义，来自 *vm_core.h*
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice that this C structure also contains the same values as the `rb_block_t`
    structure: everything from `self` at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    to `proc` at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg). The fact
    that these two structures share the same values is one of the interesting, but
    confusing, optimizations Ruby uses internally to speed things up. Whenever you
    first refer to a block by passing it into a method call, Ruby needs to create
    a new `rb_block_t` structure and copy values such as the `EP` from the current
    `rb_control_frame_t` structure into it. However, because these two structures
    contain the same values in the same order (`rb_block_t` is a subset of `rb_control_frame_t`),
    Ruby can avoid creating a new `rb_block_t` structure and instead set the new block
    pointer to the common portion of the `rb_control_frame_t` structure. In other
    words, instead of allocating new memory to hold the new `rb_block_t` structure,
    Ruby simply passes a pointer to the middle of the `rb_control_frame_t` structure.
    By doing so, Ruby avoids unnecessary calls to `malloc` and speeds up the process
    of creating blocks.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个 C 结构体也包含了与 `rb_block_t` 结构体相同的值：从`self`到`proc`，正如下图所示！[](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    和 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)。这两个结构体共享相同的值是 Ruby
    为加速内部操作而采用的一项有趣但令人困惑的优化措施。每当你第一次通过将代码块传递到方法调用中时，Ruby 需要创建一个新的 `rb_block_t` 结构体，并将当前
    `rb_control_frame_t` 结构体中的值（如 `EP`）复制到其中。然而，由于这两个结构体在相同的顺序中包含相同的值（`rb_block_t`
    是 `rb_control_frame_t` 的子集），Ruby 可以避免创建新的 `rb_block_t` 结构体，而是将新的代码块指针设置为 `rb_control_frame_t`
    结构体中的公共部分。换句话说，Ruby 不是分配新的内存来存放新的 `rb_block_t` 结构体，而是简单地传递指向 `rb_control_frame_t`
    结构体中间部分的指针。通过这种方式，Ruby 避免了不必要的 `malloc` 调用，加快了创建代码块的过程。
- en: 'Experiment 8-1: Which Is Faster: A while Loop or Passing a Block to each?'
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '实验 8-1: 哪个更快：`while` 循环还是将代码块传递给 each？'
- en: Ruby code containing blocks is often more elegant and succinct than the equivalent
    code in older languages, such as C. For example, in C we would write the simple
    `while` loop shown in [Example 8-5](ch08.html#adding_up_1_through_10_in_c_using_a_whil
    "Example 8-5. Adding up 1 through 10 in C using a while loop") to add up the numbers
    1 through 10.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 包含代码块的 Ruby 代码通常比较老语言（如 C）中的等效代码更优雅、简洁。例如，在 C 中，我们会写出 [示例 8-5](ch08.html#adding_up_1_through_10_in_c_using_a_whil
    "示例 8-5. 使用 `while` 循环在 C 中求 1 到 10 的和") 中展示的简单 `while` 循环来将数字 1 到 10 相加。
- en: Example 8-5. Adding up 1 through 10 in C using a `while` loop
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-5. 使用 `while` 循环在 C 中求 1 到 10 的和
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Example 8-6](ch08.html#adding_up_1_through_10_in_ruby_using_a_w "Example 8-6. Adding
    up 1 through 10 in Ruby using a while loop") shows the same `while` loop in Ruby.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-6](ch08.html#adding_up_1_through_10_in_ruby_using_a_w "示例 8-6. 使用 while
    循环在 Ruby 中求 1 到 10 的和") 展示了 Ruby 中相同的 `while` 循环。'
- en: Example 8-6. Adding up 1 through 10 in Ruby using a `while` loop
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-6. 使用 `while` 循环在 Ruby 中求 1 到 10 的和
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, most Rubyists would write this code using a range object with a block,
    as shown in [Example 8-7](ch08.html#adding_up_1_through_10_in_ruby_using_a_r "Example 8-7. Adding
    up 1 through 10 in Ruby using a range object and a block").
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数 Ruby 开发者会像在 [示例 8-7](ch08.html#adding_up_1_through_10_in_ruby_using_a_r
    "示例 8-7. 使用区间对象和代码块在 Ruby 中求 1 到 10 的和") 中所示的那样，使用带有代码块的区间对象来编写这段代码。
- en: Example 8-7. Adding up 1 through 10 in Ruby using a range object and a block
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-7. 使用区间对象和代码块在 Ruby 中求 1 到 10 的和
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Aesthetics aside, is there any performance penalty for using a block here? Does
    Ruby slow down significantly in order to create the new `rb_block_t` structure,
    copy the `EP` value, and create new stack frames?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 抛开美学问题，使用代码块会有什么性能惩罚吗？Ruby 是否会为了创建新的 `rb_block_t` 结构体、复制 `EP` 值并创建新的栈帧而显著变慢？
- en: Well, I won’t benchmark the C code because clearly it will be faster than either
    option using Ruby. Instead, let’s measure how long it takes Ruby, using a simple
    `while` loop, to add up the integers 1 through 10 to obtain 55, as shown in [Example 8-8](ch08.html#benchmarking_the_while_loop_left_parenth
    "Example 8-8. Benchmarking the while loop (while.rb)").
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我不会对 C 代码进行基准测试，因为显然它会比使用 Ruby 的任何选项都要快。相反，让我们测量一下 Ruby 使用简单的 `while` 循环来将整数
    1 到 10 加起来得到 55 所需的时间，正如 [示例 8-8](ch08.html#benchmarking_the_while_loop_left_parenth
    "示例 8-8. 基准测试 while 循环（while.rb）") 所示。
- en: Example 8-8. Benchmarking the `while` loop *(while.rb)*
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-8. 基准测试 `while` 循环 *(while.rb)*
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, I’m using the benchmark library to measure the time required to run the
    `while` loop one million times. Admittedly, I’m using a block to control the million
    iterations (`ITERATIONS.times do`), but I’ll use the same block in the next test
    as well. Using Ruby 2.0 on my laptop, I can run through this code in just under
    a half second:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用基准测试库来测量运行`while`循环一百万次所需的时间。诚然，我使用了一个块来控制这百万次迭代（`ITERATIONS.times do`），但在下一个测试中，我也会使用相同的块。使用Ruby
    2.0在我的笔记本电脑上，我能在不到半秒的时间内完成这段代码：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now let’s measure the time required to run the code shown in [Example 8-9](ch08.html#benchmarking_a_call_to_a_block_left_pare
    "Example 8-9. Benchmarking a call to a block (each.rb)"), which uses `each` with
    a block.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测量运行[示例 8-9](ch08.html#benchmarking_a_call_to_a_block_left_pare "示例 8-9.
    基准测试调用一个块（each.rb）")的代码所需的时间，该代码使用`each`和一个块。
- en: Example 8-9. Benchmarking a call to a block *(each.rb)*
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-9. 基准测试调用一个块 *(each.rb)*
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This time it takes somewhat longer to run through the loop a million times,
    about 0.75 seconds:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这次运行一百万次循环所需的时间略长，约为0.75秒：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Ruby requires about 71 percent more time to call the block 10 times, compared
    to iterating through the simple `while` loop 10 times (see [Figure 8-9](ch08.html#ruby_2dot0_uses_71_percent_more_time_cal
    "Figure 8-9. Ruby 2.0 uses 71 percent more time calling a block vs. a simple while
    loop. The graph shows the time for one million iterations (in seconds).")).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与简单的`while`循环迭代10次相比，Ruby调用块的时间多了约71%（参见[图 8-9](ch08.html#ruby_2dot0_uses_71_percent_more_time_cal
    "图 8-9. Ruby 2.0调用块的时间比简单的while循环多71%。图表显示了一百万次迭代所需的时间（以秒为单位）。")）。
- en: '![Ruby 2.0 uses 71 percent more time calling a block vs. a simple while loop.
    The graph shows the time for one million iterations (in seconds).](httpatomoreillycomsourcenostarchimages1854193.png.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 2.0调用块的时间比简单的while循环多71%。图表显示了一百万次迭代所需的时间（以秒为单位）。](httpatomoreillycomsourcenostarchimages1854193.png.jpg)'
- en: Figure 8-9. Ruby 2.0 uses 71 percent more time calling a block vs. a simple
    `while` loop. The graph shows the time for one million iterations (in seconds).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-9. Ruby 2.0调用块的时间比简单的`while`循环多71%。图表显示了一百万次迭代所需的时间（以秒为单位）。
- en: Using `each` is slower because internally the `Range#each` method has to call
    or yield to the block each time around the loop. This involves a fairly large
    amount of work. In order to yield to a block, Ruby first has to create a new `rb_block_t`
    structure for that block, setting the `EP` in the new block to the referencing
    environment and passing the block into the call to `each`. Then each time around
    the loop Ruby has to create a new stack frame on YARV’s internal stack, call the
    block’s code, and finally copy the `EP` from the block to the new stack frame.
    Running a simple `while` loop is faster because Ruby needs only to reset the `PC`,
    or program counter, each time around the loop. It never calls a method or creates
    a new stack frame or a new `rb_block_t` structure.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`each`会更慢，因为在内部，`Range#each`方法每次循环时都必须调用或传递控制给块。这涉及相当大量的工作。为了将控制传递给一个块，Ruby首先必须为该块创建一个新的`rb_block_t`结构，并将新的块的`EP`设置为引用的环境，然后将该块传递给`each`的调用。然后，在每次循环时，Ruby必须在YARV的内部栈上创建一个新的栈帧，调用块的代码，最后将块的`EP`从块复制到新的栈帧。运行一个简单的`while`循环更快，因为Ruby只需要在每次循环时重置`PC`（程序计数器）。它从不调用方法，也不会创建新的栈帧或新的`rb_block_t`结构。
- en: Seventy-one percent more time seems like a large performance penalty, and, depending
    on your work and the context of this `while` loop, it may or may not be important.
    If this loop were part of a time-sensitive, critical operation that your end users
    were waiting for, and if there weren’t other expensive operations inside the loop,
    it might be worth writing the iteration using an old-fashioned C-style `while`
    loop. However, the performance of most Ruby applications, and certainly Ruby on
    Rails websites, is usually limited by database queries, network connections, and
    other factors, not by Ruby execution speed. It’s rare that Ruby’s execution speed
    has an immediate, direct impact on your application’s overall performance. (Of
    course, if you’re using a large framework, such as Ruby on Rails, then your Ruby
    code is a very small piece of a very large system. I imagine that Rails uses blocks
    and iterators many, many times while processing a simple HTTP request, apart from
    the Ruby code you write yourself.)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 增加 71% 的时间看起来像是一个巨大的性能惩罚，根据你的工作和这个 `while` 循环的上下文，它可能重要也可能不重要。如果这个循环是一个时间敏感的关键操作，并且最终用户正在等待，如果循环内部没有其他昂贵的操作，那么使用传统的
    C 风格 `while` 循环来编写迭代可能是值得的。然而，大多数 Ruby 应用程序，尤其是 Ruby on Rails 网站的性能，通常受到数据库查询、网络连接和其他因素的限制，而不是
    Ruby 执行速度的限制。Ruby 的执行速度很少会对应用程序的整体性能产生直接的影响。（当然，如果你使用的是一个大型框架，比如 Ruby on Rails，那么你的
    Ruby 代码只是一个非常庞大系统中的一小部分。我想 Rails 在处理一个简单的 HTTP 请求时，会多次使用块和迭代器，除了你自己写的 Ruby 代码之外。）
- en: 'Lambdas and Procs: Treating a Function as a First-Class Citizen'
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambdas 和 Procs：将函数视为一等公民
- en: Now to look at a more convoluted way of printing the “quick brown fox” string
    to the console. [Example 8-10](ch08.html#using_lambda_in_ruby "Example 8-10. Using
    lambda in Ruby") shows an example of using `lambda`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看一种更复杂的方式，将“quick brown fox”字符串打印到控制台。[示例 8-10](ch08.html#using_lambda_in_ruby
    "示例 8-10. 使用 Ruby 中的 lambda") 展示了使用 `lambda` 的一个例子。
- en: Example 8-10. Using `lambda` in Ruby
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-10. 使用 Ruby 中的 `lambda`
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let’s step through this code carefully. First, at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    we define a method called `message_function`. Inside `message_function`, we create
    a local variable at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    called `str`. Next, at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    we call `lambda`, and pass it a block. Inside this block, at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg),
    we print the “quick brown fox” string again. However, `message_function` won’t
    immediately display the string because it doesn’t actually call the block at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg).
    Instead, `lambda` returns the block we give it as a data value, which in turn
    is returned by `message_function`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细地走过这段代码。首先，在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    我们定义了一个名为 `message_function` 的方法。在 `message_function` 内部，在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    我们创建了一个名为 `str` 的局部变量。接下来，在 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    我们调用了 `lambda`，并传递了一个代码块。在这个代码块内，在 ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)
    我们再次打印了“quick brown fox”字符串。然而，`message_function` 不会立即显示这个字符串，因为它并没有实际调用位于 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    的代码块。相反，`lambda` 返回我们传给它的代码块作为数据值，而这个数据值又会被 `message_function` 返回。
- en: This is an example of “treating a function as a first-class citizen,” to paraphrase
    a commonly used computer science expression. Once the block is returned from `message_function`,
    we save it in the local variable `function_value` at ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg)
    and then call it explicitly, using the `call` method at ![](httpatomoreillycomsourcenostarchimages1854045.png.jpg).
    With the `lambda` keyword—or the equivalent `proc` keyword—Ruby allows you to
    convert a block into a data value in this way.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个“将函数视为一等公民”的例子，用计算机科学中常用的表达方式来说。块从 `message_function` 返回后，我们将其保存在局部变量 `function_value`
    中，如 ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg)，然后显式地使用 `call`
    方法调用它，如 ![](httpatomoreillycomsourcenostarchimages1854045.png.jpg)。通过 `lambda`
    关键字—或者等效的 `proc` 关键字—Ruby 允许你以这种方式将一个块转换为数据值。
- en: '![Does Ruby use an rb_lambda_t C structure? And if so, what would it contain?](httpatomoreillycomsourcenostarchimages1854195.png.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 是否使用 rb_lambda_t C 结构？如果是，它会包含什么？](httpatomoreillycomsourcenostarchimages1854195.png.jpg)'
- en: Figure 8-10. Does Ruby use an *rb_lambda_t* C structure? And if so, what would
    it contain?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-10. Ruby 是否使用 *rb_lambda_t* C 结构？如果是，它会包含什么？
- en: I have lots of questions about [Example 8-10](ch08.html#using_lambda_in_ruby
    "Example 8-10. Using lambda in Ruby"). What happens when we call `lambda`? How
    does Ruby convert the block into a data value, and what does it mean to treat
    this block as a first-class citizen? Does `message_function` return an `rb_block_t`
    structure directly, or does it return an `rb_lambda_t` structure? And what information
    would `rb_lambda_t` contain (see [Figure 8-10](ch08.html#does_ruby_use_an_rbunderscorelambdaunder
    "Figure 8-10. Does Ruby use an rb_lambda_t C structure? And if so, what would
    it contain?"))?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我有很多关于 [示例 8-10](ch08.html#using_lambda_in_ruby "示例 8-10. 使用 lambda 在 Ruby 中")
    的问题。当我们调用 `lambda` 时会发生什么？Ruby 如何将块转换为数据值，将块视为一等公民意味着什么？`message_function` 是直接返回一个
    `rb_block_t` 结构，还是返回一个 `rb_lambda_t` 结构？那么 `rb_lambda_t` 会包含哪些信息呢？（参见 [图 8-10](ch08.html#does_ruby_use_an_rbunderscorelambdaunder
    "图 8-10. Ruby 是否使用 rb_lambda_t C 结构？如果使用，它包含什么信息？")）？
- en: Stack vs. Heap Memory
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈与堆内存
- en: 'Before we can answer these questions, we need to take a closer look at how
    Ruby saves your data. Internally, Ruby saves your data in two places: on the *stack*
    or in the *heap*.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够回答这些问题之前，我们需要更仔细地了解 Ruby 如何保存数据。在内部，Ruby 将数据保存在两个地方：*栈*上或*堆*中。
- en: We’ve seen the *stack* before. This is where Ruby saves local variables, return
    values, and arguments for each of the methods in your program. Values on the stack
    are valid only for as long as that method is running. When a method returns, YARV
    deletes its stack frame and all the values inside it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前见过 *栈*。这是 Ruby 保存局部变量、返回值和每个方法参数的地方。栈上的值仅在该方法运行时有效。当方法返回时，YARV 会删除其栈帧和其中的所有值。
- en: Ruby uses the *heap* to save information that you might need for a while, even
    after a particular method returns. Each value in the heap remains valid for as
    long as there is a reference to it. Once a value is no longer referred to by any
    variable or object in your program, Ruby’s garbage collection system deletes it,
    freeing its memory for other uses.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 使用 *堆* 来保存你可能需要较长时间的数据，甚至在某个方法返回后依然有效。堆中的每个值都会在有引用指向它时保持有效。一旦一个值不再被程序中的任何变量或对象引用，Ruby
    的垃圾回收系统会删除它，释放其内存供其他用途。
- en: This scheme is not unique to Ruby. In fact, it’s used by many other programming
    languages, including Lisp and C. And remember, Ruby itself is a C program. YARV’s
    stack design is based on the way C programs use the stack, and Ruby’s heap uses
    the underlying C heap implementation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方案并非 Ruby 独有。事实上，许多其他编程语言也使用这种方式，包括 Lisp 和 C。而且请记住，Ruby 本身就是一个 C 程序。YARV 的栈设计基于
    C 程序使用栈的方式，Ruby 的堆使用的是底层 C 堆的实现。
- en: The stack and heap differ in one other important aspect. Ruby saves only references
    to data on the stack—that is, the `VALUE` pointers. For simple integer values,
    symbols, and constants such as `nil`, `true`, or `false`, the reference is the
    actual value. However, for all other data types, the `VALUE` is a pointer to a
    C structure containing the actual data, such as `RObject`. If only the `VALUE`
    references go on the stack, where does Ruby save the structures? In the heap.
    Let’s look at an example to understand this better.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 栈和堆在另一个重要方面有所不同。Ruby 只在栈上保存数据的引用——即 `VALUE` 指针。对于简单的整数值、符号和常量（例如 `nil`、`true`
    或 `false`），引用就是实际的值。然而，对于所有其他数据类型，`VALUE` 是指向包含实际数据的 C 结构的指针，例如 `RObject`。如果栈上只保存
    `VALUE` 引用，那么 Ruby 将数据结构保存在什么地方？保存在堆中。让我们通过一个例子更好地理解这一点。
- en: A Closer Look at How Ruby Saves a String Value
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更深入地了解 Ruby 如何保存字符串值
- en: Let’s look in detail at how Ruby handles the string value `str` from [Example 8-10](ch08.html#using_lambda_in_ruby
    "Example 8-10. Using lambda in Ruby"). First, imagine YARV has a stack frame for
    the outer scope but has yet to call `message_function`. [Figure 8-11](ch08.html#to_execute_the_code_in_listing_8-11comma
    "Figure 8-11. To execute the code in Example 8-11, Ruby starts with an initial
    stack frame.") shows this initial stack frame.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看一下 Ruby 如何处理字符串值 `str`，来自 [示例 8-10](ch08.html#using_lambda_in_ruby "示例
    8-10. 使用 lambda 在 Ruby 中")。首先，假设 YARV 有一个外部作用域的栈帧，但尚未调用 `message_function`。[图
    8-11](ch08.html#to_execute_the_code_in_listing_8-11comma "图 8-11. 为了执行示例 8-11
    中的代码，Ruby 从初始栈帧开始") 显示了这个初始栈帧。
- en: '![To execute the code in , Ruby starts with an initial stack frame.](httpatomoreillycomsourcenostarchimages1854197.png.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![为了执行代码，Ruby 从初始栈帧开始。](httpatomoreillycomsourcenostarchimages1854197.png.jpg)'
- en: Figure 8-11. To execute the code in [Example 8-11](ch08.html#this_code_doesnapostrophet_call_lambdado
    "Example 8-11. This code doesn’t call lambda."), Ruby starts with an initial stack
    frame.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-11。为了执行[示例 8-11](ch08.html#this_code_doesnapostrophet_call_lambdado "示例
    8-11。此代码没有调用 lambda")中的代码，Ruby 从初始栈帧开始。
- en: In this figure you can see YARV’s internal stack on the left and the `rb_control_frame_t`
    structure on the right. Now suppose Ruby executes the `message_function` function
    call shown at ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg) in [Example 8-10](ch08.html#using_lambda_in_ruby
    "Example 8-10. Using lambda in Ruby"). [Figure 8-12](ch08.html#ruby_creates_a_second_stack_frame_when_c
    "Figure 8-12. Ruby creates a second stack frame when calling message_function.")
    shows what happens next.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这张图中，你可以看到左侧是 YARV 的内部栈，右侧是 `rb_control_frame_t` 结构。现在假设 Ruby 执行了在[示例 8-10](ch08.html#using_lambda_in_ruby
    "示例 8-10。Ruby 中的 lambda 使用")中显示的 `message_function` 函数调用。接下来的[图 8-12](ch08.html#ruby_creates_a_second_stack_frame_when_c
    "图 8-12。Ruby 在调用 message_function 时创建第二个栈帧")展示了接下来的情况。
- en: '![Ruby creates a second stack frame when calling message_function.](httpatomoreillycomsourcenostarchimages1854199.png.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 在调用 message_function 时创建了第二个栈帧。](httpatomoreillycomsourcenostarchimages1854199.png.jpg)'
- en: Figure 8-12. Ruby creates a second stack frame when calling `message_function`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-12。Ruby 在调用 `message_function` 时创建了第二个栈帧。
- en: Ruby saves the `str` local variable in the new stack frame used by `message_function`.
    Let’s take a closer look at that `str` variable and how Ruby stores the “quick
    brown fox” string into it. Ruby stores each of your objects in a C structure called
    `RObject`, each of your arrays in a structure called `RArray`, each of your strings
    in a structure called `RString`, and so on. [Figure 8-13](ch08.html#ruby_uses_the_rstring_c_structure_to_sav
    "Figure 8-13. Ruby uses the RString C structure to save string values.") shows
    the “quick brown fox” string saved with `RString`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 将 `str` 局部变量保存在 `message_function` 使用的新栈帧中。让我们仔细看看这个 `str` 变量，以及 Ruby 如何将“quick
    brown fox”字符串存储到其中。Ruby 将每个对象保存在一个叫做 `RObject` 的 C 结构中，将每个数组保存在一个叫做 `RArray` 的结构中，将每个字符串保存在一个叫做
    `RString` 的结构中，依此类推。[图 8-13](ch08.html#ruby_uses_the_rstring_c_structure_to_sav
    "图 8-13。Ruby 使用 RString C 结构来保存字符串值") 展示了将“quick brown fox”字符串保存在 `RString` 中的情况。
- en: '![Ruby uses the RString C structure to save string values.](httpatomoreillycomsourcenostarchimages1854201.png.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 使用 RString C 结构来保存字符串值。](httpatomoreillycomsourcenostarchimages1854201.png.jpg)'
- en: Figure 8-13. Ruby uses the `RString` C structure to save string values.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-13。Ruby 使用 `RString` C 结构来保存字符串值。
- en: The actual string structure is shown on the right side of the figure, and a
    reference, or pointer, to the string is shown on the left. When Ruby saves a string
    value (or any object) onto the YARV stack, it actually places only the reference
    to the string on the stack. The actual string structure is saved in the heap instead,
    as shown in [Figure 8-14](ch08.html#str_value_on_the_stack_is_a_referenc "Figure 8-14. The
    str value on the stack is a reference to the RString structure saved in the heap.")
    on the next page.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的字符串结构如图右侧所示，字符串的引用或指针如图左侧所示。当 Ruby 将字符串值（或任何对象）保存到 YARV 栈时，实际上只将字符串的引用放入栈中。实际的字符串结构则保存于堆中，如下一页中的[图
    8-14](ch08.html#str_value_on_the_stack_is_a_referenc "图 8-14。栈上的 str 值是保存于堆中的
    RString 结构的引用。")所示。
- en: Once there are no longer any pointers referencing a particular object or value
    in the heap, Ruby frees that object or value during the next run of the garbage
    collection system. To demonstrate, suppose that my example code didn’t call `lambda`
    at all but rather immediately returned `nil` after saving the `str` variable,
    as shown in [Example 8-11](ch08.html#this_code_doesnapostrophet_call_lambdado
    "Example 8-11. This code doesn’t call lambda.").
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦堆中不再有任何指针引用某个特定对象或值，Ruby 会在下一次垃圾回收系统运行时释放该对象或值。为了演示这一点，假设我的示例代码根本没有调用 `lambda`，而是在保存
    `str` 变量后立即返回 `nil`，如[示例 8-11](ch08.html#this_code_doesnapostrophet_call_lambdado
    "示例 8-11。此代码没有调用 lambda")所示。
- en: Example 8-11. This code doesn’t call `lambda`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-11。此代码没有调用 `lambda`。
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![The str value on the stack is a reference to the RString structure saved
    in the heap.](httpatomoreillycomsourcenostarchimages1854203.png.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![栈上的 str 值是保存于堆中的 RString 结构的引用。](httpatomoreillycomsourcenostarchimages1854203.png.jpg)'
- en: Figure 8-14. The `str` value on the stack is a reference to the `RString` structure
    saved in the heap.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-14。栈上的 `str` 值是保存于堆中的 `RString` 结构的引用。
- en: Once this call to `message_function` finishes, YARV simply pops the `str` value
    off the stack (as well as any other temporary values saved there) and returns
    to the original stack frame, as shown in [Figure 8-15](ch08.html#now_there_is_no_longer_a_reference_to_th
    "Figure 8-15. Now there is no longer a reference to the RString structure.").
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `message_function` 调用完成，YARV 会简单地将 `str` 值从栈中弹出（以及栈中保存的任何其他临时值），并返回到原始栈帧，如
    [图 8-15](ch08.html#now_there_is_no_longer_a_reference_to_th "Figure 8-15. Now
    there is no longer a reference to the RString structure.") 所示。
- en: '![Now there is no longer a reference to the RString structure.](httpatomoreillycomsourcenostarchimages1854205.png.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![现在不再引用 `RString` 结构体。](httpatomoreillycomsourcenostarchimages1854205.png.jpg)'
- en: Figure 8-15. Now there is no longer a reference to the `RString` structure.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-15。现在不再引用 `RString` 结构体。
- en: As you can see in the figure, there is no longer a reference to the `RString`
    structure containing the “quick brown fox” string. Ruby’s garbage collection system
    is designed to identify values in the heap that don’t have any references to them,
    like the “quick brown fox” string here. After it identifies them, the GC system
    will free those orphaned values, returning that memory to the heap.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，不再引用包含“快速棕色狐狸”字符串的 `RString` 结构体。Ruby 的垃圾回收系统旨在识别堆中没有任何引用的值，就像这里的“快速棕色狐狸”字符串。识别后，GC
    系统将释放这些孤立的值，将内存返回到堆中。
- en: How Ruby Creates a Lambda
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ruby 如何创建 Lambda
- en: Now that we understand a bit more about the heap and how Ruby uses it, we’re
    ready to learn more about lambdas. Earlier when I used the phrase “treating a
    function as a first-class citizen,” I meant that Ruby allows you to treat functions
    or code as a data value, saving them into variables, passing them as arguments,
    and so on. Ruby implements this idea using blocks.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对堆以及 Ruby 如何使用堆有了一些了解，准备进一步学习关于 lambdas 的知识。之前我提到过“将函数作为一等公民”的说法，这意味着 Ruby
    允许你将函数或代码当作数据值来处理，将它们保存在变量中，作为参数传递等等。Ruby 使用块来实现这个概念。
- en: The `lambda` (or `proc`) keyword converts a block into a data value. But remember,
    blocks are Ruby’s implementation of closures. This means the new data value must
    somehow contain both the block’s code and referencing environment.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda`（或 `proc`）关键字将块转换为数据值。但请记住，块是 Ruby 对闭包的实现。这意味着新的数据值必须以某种方式包含块的代码和引用的环境。'
- en: To see what I mean, let’s return to [Example 8-10](ch08.html#using_lambda_in_ruby
    "Example 8-10. Using lambda in Ruby"), repeated here in [Example 8-12](ch08.html#using_lambda_in_ruby_left_parenthesisrep
    "Example 8-12. Using lambda in Ruby (repeated from Example 8-10)") with an eye
    toward its use of `lambda`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我的意思，我们返回到 [示例 8-10](ch08.html#using_lambda_in_ruby "Example 8-10. Using
    lambda in Ruby")，并在 [示例 8-12](ch08.html#using_lambda_in_ruby_left_parenthesisrep
    "Example 8-12. Using lambda in Ruby (repeated from Example 8-10)") 中重复，重点看它如何使用
    `lambda`。
- en: Example 8-12. Using `lambda` in Ruby (repeated from [Example 8-10](ch08.html#using_lambda_in_ruby
    "Example 8-10. Using lambda in Ruby"))
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-12。使用 `lambda` 在 Ruby 中（从 [示例 8-10](ch08.html#using_lambda_in_ruby "Example 8-10. Using
    lambda in Ruby") 重复）
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg) that when
    we call the lambda (the block), the `puts` statement inside the block at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    can access the `str` string variable defined at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    inside `message_function`. How can this be? We’ve just seen how the `str` reference
    to the `RString` structure is popped off the stack when `message_function` returns!
    Obviously, after calling `lambda`, the value of `str` lives on so that the block
    can access it later.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg) 处，当我们调用 lambda（块）时，块内的
    `puts` 语句位于 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg) 处，可以访问在
    ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 处的 `message_function`
    内定义的 `str` 字符串变量。这是怎么回事呢？我们刚刚看到，当 `message_function` 返回时，`str` 对 `RString` 结构体的引用被从栈中弹出！显然，在调用
    `lambda` 后，`str` 的值仍然存在，以便块在稍后访问它。
- en: When you call `lambda`, Ruby copies the entire contents of the current YARV
    stack frame into the heap, where the `RString` structure is located. For example,
    [Figure 8-16](ch08.html#ruby_creates_a_second_stack_fram-id00030 "Figure 8-16. Ruby
    creates a second stack frame when calling message_function.") shows how the YARV
    stack looks just after the `message_function` starts at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    in [Example 8-12](ch08.html#using_lambda_in_ruby_left_parenthesisrep "Example 8-12. Using
    lambda in Ruby (repeated from Example 8-10)"). (To keep things simple, I’m not
    showing the `RString` structure, but remember that the `RString` structure will
    also be saved in the heap.)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `lambda` 时，Ruby 将当前 YARV 堆栈帧的全部内容复制到堆中，其中包含 `RString` 结构。例如，图 [8-16](ch08.html#ruby_creates_a_second_stack_fram-id00030
    "图 8-16. Ruby 在调用 message_function 时创建了第二个堆栈帧。") 显示了 `message_function` 开始时 YARV
    堆栈的状态，位于 [示例 8-12](ch08.html#using_lambda_in_ruby_left_parenthesisrep "示例 8-12.
    在 Ruby 中使用 lambda（重复示例 8-10）") 的 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    处。（为了简化起见，这里没有显示 `RString` 结构，但请记住，`RString` 结构也会被保存在堆中。）
- en: '![Ruby creates a second stack frame when calling message_function.](httpatomoreillycomsourcenostarchimages1854207.png.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 在调用 message_function 时创建了第二个堆栈帧。](httpatomoreillycomsourcenostarchimages1854207.png.jpg)'
- en: Figure 8-16. Ruby creates a second stack frame when calling `message_function`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-16. Ruby 在调用 `message_function` 时创建了第二个堆栈帧。
- en: Next, [Example 8-12](ch08.html#using_lambda_in_ruby_left_parenthesisrep "Example 8-12. Using
    lambda in Ruby (repeated from Example 8-10)") calls `lambda` at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
    [Figure 8-17](ch08.html#when_you_call_lambdacomma_ruby_copies_th "Figure 8-17. When
    you call lambda, Ruby copies the current stack frame to the heap.") shows what
    happens in Ruby when you call `lambda`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，[示例 8-12](ch08.html#using_lambda_in_ruby_left_parenthesisrep "示例 8-12. 在
    Ruby 中使用 lambda（重复示例 8-10）") 在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    处调用 `lambda`。图 [8-17](ch08.html#when_you_call_lambdacomma_ruby_copies_th "图 8-17.
    当你调用 lambda 时，Ruby 会将当前堆栈帧复制到堆中。") 显示了调用 `lambda` 时 Ruby 会发生什么。
- en: The horizontal stack icon below the dotted line shows that Ruby creates a new
    copy of the stack frame for `message_function` in the heap. Now there is a second
    reference to the `str RString` structure, which means that Ruby won’t free it
    when `message_function` returns.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 虚线下方的水平堆栈图标显示，Ruby 为 `message_function` 创建了堆栈帧的新副本并保存在堆中。现在，`str RString` 结构有了第二个引用，这意味着当
    `message_function` 返回时，Ruby 不会释放该结构。
- en: 'In fact, along with the copy of the stack frame, Ruby creates two other new
    objects in the heap:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，除了堆栈帧的副本外，Ruby 还在堆中创建了另外两个新对象：
- en: An internal environment object, represented by the `rb_env_t` C structure at
    the lower left of the figure. It’s essentially a wrapper for the heap copy of
    the stack. As we’ll see in [Chapter 9](ch09.html "Chapter 9. Metaprogramming"),
    you can access this environment object indirectly in your programs using the `Binding`
    class.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个内部环境对象，通过图中左下角的 `rb_env_t` C 结构表示。它本质上是堆中堆栈副本的封装器。正如我们在 [第 9 章](ch09.html
    "第 9 章. 元编程") 中看到的，你可以通过 `Binding` 类间接访问该环境对象。
- en: A Ruby proc object, represented by the `rb_proc_t` structure. This is the actual
    return value from the `lambda` keyword; it’s what the `message_function` function
    returns.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Ruby proc 对象，通过 `rb_proc_t` 结构表示。这是 `lambda` 关键字的实际返回值；它是 `message_function`
    函数的返回值。
- en: Note that the new proc object, the `rb_proc_t` structure, contains an `rb_block_t`
    structure, including the `iseq` and `EP` pointers. Think of a proc as a kind of
    Ruby object that wraps up a block. As with a normal block, these keep track of
    the block’s code and the referencing environment for its closure. Ruby sets the
    `EP` in this block to point to the new heap copy of the stack frame.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，新的 proc 对象，即 `rb_proc_t` 结构，包含一个 `rb_block_t` 结构，其中包括 `iseq` 和 `EP` 指针。可以将
    proc 看作是一个封装块的 Ruby 对象。与普通块类似，这些指针跟踪块的代码和其闭包的引用环境。Ruby 会设置块中的 `EP` 指针，指向堆中堆栈帧的副本。
- en: Also, notice that the proc object contains an internal value called `is_lambda`.
    This is set to `true` for this example because we used the `lambda` keyword to
    create the proc. If I had instead created the proc using the `proc` keyword, or
    simply by calling `Proc.new`, then `is_lambda` would have been set to `false`.
    Ruby uses this flag to produce the slight behavior differences between procs and
    lambdas, though it’s best to think of procs and lambdas as essentially the same.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意proc对象包含一个内部值`is_lambda`。对于这个例子，`is_lambda`被设置为`true`，因为我们使用`lambda`关键字创建了proc。如果我使用`proc`关键字或者仅仅通过调用`Proc.new`来创建proc，那么`is_lambda`会被设置为`false`。Ruby通过这个标志来区分proc和lambda之间的细微行为差异，但最好将proc和lambda视为本质相同。
- en: '![When you call lambda, Ruby copies the current stack frame to the heap.](httpatomoreillycomsourcenostarchimages1854209.png.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![当你调用lambda时，Ruby会将当前的堆栈帧复制到堆中。](httpatomoreillycomsourcenostarchimages1854209.png.jpg)'
- en: Figure 8-17. When you call `lambda`, Ruby copies the current stack frame to
    the heap.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-17。当你调用`lambda`时，Ruby会将当前的堆栈帧复制到堆中。
- en: How Ruby Calls a Lambda
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ruby如何调用lambda
- en: Let’s go back to our lambda example in [Example 8-13](ch08.html#using_lambda_in_ruby_left_parent-id00031
    "Example 8-13. Using lambda in Ruby (repeated again from Example 8-10)").
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到[示例8-13](ch08.html#using_lambda_in_ruby_left_parent-id00031 "示例8-13. 在Ruby中使用lambda（从示例8-10再次重复）")中的lambda示例。
- en: Example 8-13. Using `lambda` in Ruby (repeated again from [Example 8-10](ch08.html#using_lambda_in_ruby
    "Example 8-10. Using lambda in Ruby"))
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 示例8-13。在Ruby中使用`lambda`（从[示例8-10](ch08.html#using_lambda_in_ruby "示例8-10. 在Ruby中使用lambda")再次重复）
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What happens when `message_function` returns at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)?
    Because the lambda or proc object is its return value, a reference to the lambda
    is saved in the stack frame for the outer scope in the `function_value` local
    variable. This prevents Ruby from freeing the proc, the internal environment object,
    and the `str` variable, and there are now pointers referring to all of these values
    in the heap (see [Figure 8-18](ch08.html#once_messageunderscorefunction_returnsco
    "Figure 8-18. Once message_function returns, the surrounding code holds a reference
    to the proc object.")).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当`message_function`在![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)处返回时会发生什么？因为lambda或proc对象是其返回值，lambda的引用会保存在外部作用域的堆栈帧中的`function_value`局部变量中。这防止了Ruby释放proc、内部环境对象以及`str`变量，并且现在堆中有指针指向这些值（参见[图8-18](ch08.html#once_messageunderscorefunction_returnsco
    "图8-18. 一旦message_function返回，外围代码会持有proc对象的引用。")）。
- en: '![Once message_function returns, the surrounding code holds a reference to
    the proc object.](httpatomoreillycomsourcenostarchimages1854211.png.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![一旦message_function返回，外围代码会持有proc对象的引用。](httpatomoreillycomsourcenostarchimages1854211.png.jpg)'
- en: Figure 8-18. Once `message_function` returns, the surrounding code holds a reference
    to the proc object.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-18。一旦`message_function`返回，外围代码会持有proc对象的引用。
- en: When Ruby executes the `call` method on the proc object at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg),
    it executes its block as well. [Figure 8-19](ch08.html#calling_a_proc_object_creates_a_new_stac
    "Figure 8-19. Calling a proc object creates a new stack frame as usual and sets
    the EP to point to the heap’s referencing environment.") shows what happens in
    Ruby when you use the `call` method on a lambda or proc.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当Ruby在![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)处执行proc对象的`call`方法时，它也会执行其块。[图8-19](ch08.html#calling_a_proc_object_creates_a_new_stac
    "图8-19. 调用proc对象会像往常一样创建一个新的堆栈帧，并将EP指向堆中的引用环境。")展示了当你在lambda或proc上使用`call`方法时，Ruby会发生什么。
- en: As with any block, when Ruby calls the block inside a proc object it creates
    a new stack frame and sets the `EP` to the block’s referencing environment. However,
    that environment is a copy of a stack frame previously copied into the heap; the
    new stack frame contains an `EP` that points to the heap. This `EP` allows the
    block’s call to `puts` to access the `str` value defined in `message_function`.
    [Figure 8-19](ch08.html#calling_a_proc_object_creates_a_new_stac "Figure 8-19. Calling
    a proc object creates a new stack frame as usual and sets the EP to point to the
    heap’s referencing environment.") shows the argument to the proc, `animal`, saved
    in the new stack frame, like any other method or block argument.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 和任何块一样，当 Ruby 调用 proc 对象中的块时，它会创建一个新的栈帧，并将 `EP` 设置为块的引用环境。然而，这个环境是之前已经复制到堆中的栈帧的副本；新的栈帧包含一个指向堆的
    `EP`。这个 `EP` 使得块内对 `puts` 的调用可以访问在 `message_function` 中定义的 `str` 值。[图 8-19](ch08.html#calling_a_proc_object_creates_a_new_stac
    "图 8-19。调用 proc 对象像往常一样创建一个新的栈帧，并将 EP 设置为指向堆的引用环境。") 展示了作为 proc 参数的 `animal`，它像其他方法或块的参数一样，保存在新的栈帧中。
- en: '![Calling a proc object creates a new stack frame as usual and sets the EP
    to point to the heap’s referencing environment.](httpatomoreillycomsourcenostarchimages1854213.png.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![调用 proc 对象像往常一样创建一个新的栈帧，并将 EP 设置为指向堆的引用环境。](httpatomoreillycomsourcenostarchimages1854213.png.jpg)'
- en: Figure 8-19. Calling a proc object creates a new stack frame as usual and sets
    the `EP` to point to the heap’s referencing environment.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-19。调用 proc 对象像往常一样创建一个新的栈帧，并将 `EP` 设置为指向堆的引用环境。
- en: The Proc Object
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Proc 对象
- en: We’ve seen that Ruby really has no structure called `rb_lambda_t`. In other
    words, the structure shown in [Figure 8-20](ch08.html#ruby_doesnapostrophet_actually_use_a_str
    "Figure 8-20. Ruby doesn’t actually use a structure called rb_lambda_t.") doesn’t
    actually exist.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 Ruby 其实并没有一个叫做 `rb_lambda_t` 的结构。换句话说，[图 8-20](ch08.html#ruby_doesnapostrophet_actually_use_a_str
    "图 8-20。Ruby 实际上并没有使用一个叫做 rb_lambda_t 的结构。") 中展示的那个结构实际上并不存在。
- en: '![Ruby doesn’t actually use a structure called rb_lambda_t.](httpatomoreillycomsourcenostarchimages1854215.png.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 实际上并没有使用一个叫做 rb_lambda_t 的结构。](httpatomoreillycomsourcenostarchimages1854215.png.jpg)'
- en: Figure 8-20. Ruby doesn’t actually use a structure called `rb_lambda_t`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-20。Ruby 实际上并没有使用一个叫做 `rb_lambda_t` 的结构。
- en: Instead, in this example, Ruby’s `lambda` keyword created a proc object—really,
    a wrapper for the block we passed to the `lambda` or `proc` keyword. Ruby represents
    procs using an `rb_proc_t` C structure, as you can see in [Figure 8-21](ch08.html#ruby_procs_are_closuressemicolon_they_co
    "Figure 8-21. Ruby procs are closures; they contain pointers to a function and
    a referencing environment.").
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在这个例子中，Ruby 的 `lambda` 关键字创建了一个 proc 对象——实际上，这是我们传递给 `lambda` 或 `proc` 关键字的块的封装器。Ruby
    使用 `rb_proc_t` C 结构来表示 procs，正如你在[图 8-21](ch08.html#ruby_procs_are_closuressemicolon_they_co
    "图 8-21。Ruby 的 proc 是闭包；它们包含指向函数和引用环境的指针。")中看到的那样。
- en: '![Ruby procs are closures; they contain pointers to a function and a referencing
    environment.](httpatomoreillycomsourcenostarchimages1854217.png.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 的 proc 是闭包；它们包含指向函数和引用环境的指针。](httpatomoreillycomsourcenostarchimages1854217.png.jpg)'
- en: Figure 8-21. Ruby procs are closures; they contain pointers to a function and
    a referencing environment.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-21。Ruby 的 proc 是闭包；它们包含指向函数和引用环境的指针。
- en: 'This is a closure: It contains a function along with the environment that function
    was referred to or created in. The environment is a persistent copy of the stack
    frame saved in the heap.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个闭包：它包含一个函数以及该函数所引用或创建的环境。这个环境是保存在堆中的栈帧的持久副本。
- en: A proc is a Ruby object. It contains the same information as other objects,
    including the `RBasic` structure. To save its object-related information, Ruby
    uses a structure called `RTypedData`, along with `rb_proc_t`, to represent instances
    of the proc object. [Figure 8-22](ch08.html#ruby_saves_the_object-related_informatio
    "Figure 8-22. Ruby saves the object-related information about proc objects in
    the RTypedData structure.") shows how these structures work together.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 proc 是一个 Ruby 对象。它包含与其他对象相同的信息，包括 `RBasic` 结构。为了保存与对象相关的信息，Ruby 使用一个叫做 `RTypedData`
    的结构，配合 `rb_proc_t` 来表示 proc 对象的实例。[图 8-22](ch08.html#ruby_saves_the_object-related_informatio
    "图 8-22。Ruby 将 proc 对象的与对象相关的信息保存在 RTypedData 结构中。") 展示了这些结构如何协同工作。
- en: 'You might think of `RTypedData` as a kind of trick that Ruby’s C code uses
    to create a Ruby object wrapper around a C data structure. In this case, Ruby
    uses `RTypedData` to create an instance of the `Proc` Ruby class that represents
    a single copy of the `rb_proc_t` structure. The `RTypedData` structure contains
    the same `RBasic` information as all Ruby objects:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`RTypedData`看作是Ruby的C代码用来围绕C数据结构创建Ruby对象包装器的一种技巧。在这个案例中，Ruby使用`RTypedData`来创建`Proc`
    Ruby类的一个实例，该类表示`rb_proc_t`结构体的单个副本。`RTypedData`结构体包含与所有Ruby对象相同的`RBasic`信息：
- en: '****`flags`****. Certain internal technical information Ruby needs to track'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`flags`****。Ruby需要跟踪的某些内部技术信息'
- en: '****`klass`****. A pointer to the Ruby class that the object is an instance
    of; the `Proc` class in this example'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`klass`****。指向该对象所属的Ruby类的指针；在此示例中是`Proc`类'
- en: '![Ruby saves the object-related information about proc objects in the RTypedData
    structure.](httpatomoreillycomsourcenostarchimages1854219.png.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby将与proc对象相关的信息保存在RTypedData结构中。](httpatomoreillycomsourcenostarchimages1854219.png.jpg)'
- en: Figure 8-22. Ruby saves the object-related information about proc objects in
    the `RTypedData` structure.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-22。Ruby将与proc对象相关的信息保存在`RTypedData`结构中。
- en: '[Figure 8-23](ch08.html#comparing_a_ruby_string_with_a_proc "Figure 8-23. Comparing
    a Ruby string with a proc") takes another look at how Ruby represents a proc object.
    The proc object is on the right next to an `RString` structure.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-23](ch08.html#comparing_a_ruby_string_with_a_proc "图8-23. 比较Ruby字符串与proc")再次查看Ruby如何表示proc对象。proc对象位于右侧，紧邻一个`RString`结构体。'
- en: Notice that Ruby handles the string value and the proc similarly. As with strings,
    procs can be saved into variables or passed as arguments to a function call. Ruby
    uses the `VALUE` pointer to the proc whenever you refer to one or save one into
    a variable.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Ruby处理字符串值和proc的方式相似。与字符串一样，procs可以被保存在变量中或作为函数调用的参数传递。每当你引用一个proc或将其保存在变量中时，Ruby使用指向该proc的`VALUE`指针。
- en: '![Comparing a Ruby string with a proc](httpatomoreillycomsourcenostarchimages1854221.png.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![比较Ruby字符串与proc](httpatomoreillycomsourcenostarchimages1854221.png.jpg)'
- en: Figure 8-23. Comparing a Ruby string with a proc
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-23。比较Ruby字符串与proc
- en: 'Experiment 8-2: Changing Local Variables After Calling lambda'
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验8-2：调用lambda后更改局部变量
- en: '[Example 8-10](ch08.html#using_lambda_in_ruby "Example 8-10. Using lambda in
    Ruby") through [Example 8-13](ch08.html#using_lambda_in_ruby_left_parent-id00031
    "Example 8-13. Using lambda in Ruby (repeated again from Example 8-10)") show
    how calling `lambda` copies the current stack frame in the heap. Now for a slightly
    different example. [Example 8-14](ch08.html#which_version_of_str_will_lambda_copy_to
    "Example 8-14. Which version of str will lambda copy to the heap (modify_after_lambda.rb)?")
    is basically the same, except that the line at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    changes `str` after calling `lambda`.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例8-10](ch08.html#using_lambda_in_ruby "示例8-10. 在Ruby中使用lambda")到[示例8-13](ch08.html#using_lambda_in_ruby_left_parent-id00031
    "示例8-13. 在Ruby中使用lambda（从示例8-10中重复）")展示了如何调用`lambda`将当前的栈帧复制到堆上。现在来看一个略有不同的示例。[示例8-14](ch08.html#which_version_of_str_will_lambda_copy_to
    "示例8-14. `lambda`会将`str`的哪个版本复制到堆上？（modify_after_lambda.rb）")基本相同，唯一不同的是在![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)这一行，`lambda`调用后更改了`str`。'
- en: Example 8-14. Which version of `str` will `lambda` copy to the heap *(modify_after_lambda.rb)*?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 示例8-14。`lambda`会将`str`的哪个版本复制到堆上？*(modify_after_lambda.rb)*
- en: '[PRE15]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Because we call `lambda` at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    before changing `str` to `The sly brown fox` at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg),
    Ruby should have copied the stack frame to the heap, including the original value
    of `str`. That means that when we call the lambda at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg),
    we should see the original “quick brown fox” string. However, running the code,
    we get the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)调用`lambda`时，`str`的值尚未更改为`The
    sly brown fox`，所以Ruby应该已经将栈帧复制到了堆中，包括`str`的原始值。这意味着当我们在![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)调用lambda时，应该看到原始的“quick
    brown fox”字符串。然而，运行代码时，我们得到以下结果：
- en: '[PRE16]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What happened? Ruby somehow copied the new value of `str`, `The sly brown fox`,
    to the heap so we could access it when we called the lambda at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？Ruby以某种方式将`str`的新值`The sly brown fox`复制到了堆上，以便我们在调用lambda时能够访问它，调用时位于![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)。
- en: To find out how Ruby did this, let’s look more closely at what happens when
    you call `lambda`. [Figure 8-24](ch08.html#when_you_call_lambdacomma_ruby_c-id00032
    "Figure 8-24. When you call lambda, Ruby copies the stack frame to the heap.")
    shows how Ruby copies the stack frame to the heap, including the value `str` from
    [Example 8-14](ch08.html#which_version_of_str_will_lambda_copy_to "Example 8-14. Which
    version of str will lambda copy to the heap (modify_after_lambda.rb)?").
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了弄清楚Ruby是如何做到这一点的，让我们更仔细地看看当你调用`lambda`时发生了什么。[图8-24](ch08.html#when_you_call_lambdacomma_ruby_c-id00032
    "图8-24。当你调用lambda时，Ruby将栈帧复制到堆中。")展示了Ruby如何将栈帧复制到堆中，包括来自[示例8-14](ch08.html#which_version_of_str_will_lambda_copy_to
    "示例8-14. `lambda`会将哪个版本的str复制到堆中（modify_after_lambda.rb）")的`str`值。
- en: '![When you call lambda, Ruby copies the stack frame to the heap.](httpatomoreillycomsourcenostarchimages1854223.png.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![当你调用lambda时，Ruby将栈帧复制到堆中。](httpatomoreillycomsourcenostarchimages1854223.png.jpg)'
- en: Figure 8-24. When you call `lambda`, Ruby copies the stack frame to the heap.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-24。当你调用`lambda`时，Ruby将栈帧复制到堆中。
- en: 'Once this copy is made, the code at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    in [Example 8-14](ch08.html#which_version_of_str_will_lambda_copy_to "Example 8-14. Which
    version of str will lambda copy to the heap (modify_after_lambda.rb)?") changes
    `str` to the “sly fox” string:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了此副本，[示例8-14](ch08.html#which_version_of_str_will_lambda_copy_to "示例8-14.
    `lambda`会将哪个版本的str复制到堆中（modify_after_lambda.rb）")中的代码在![图示](httpatomoreillycomsourcenostarchimages1853845.png.jpg)将`str`更改为“sly
    fox”字符串：
- en: '[PRE17]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Because Ruby copied the stack frame when we called `lambda`, we should be modifying
    the original copy of `str`, not the new lambda copy (see [Figure 8-25](ch08.html#does_ruby_continue_to_use_the_original_s
    "Figure 8-25. Does Ruby continue to use the original stack frame after making
    a heap copy?")).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ruby在调用`lambda`时复制了栈帧，我们应该修改原始的`str`副本，而不是新的lambda副本（参见[图8-25](ch08.html#does_ruby_continue_to_use_the_original_s
    "图8-25。Ruby在创建堆副本后是否继续使用原始栈帧？")）。
- en: '![Does Ruby continue to use the original stack frame after making a heap copy?](httpatomoreillycomsourcenostarchimages1854225.png.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby在创建堆副本后是否继续使用原始栈帧？](httpatomoreillycomsourcenostarchimages1854225.png.jpg)'
- en: Figure 8-25. Does Ruby continue to use the original stack frame after making
    a heap copy?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-25。Ruby在创建堆副本后是否继续使用原始栈帧？
- en: The new heap copy of the string should have remained unmodified, and calling
    the lambda later should have given the original “quick fox” string, not the modified
    “sly fox” one. How does Ruby allow us to modify the new persistent copy of the
    stack once it’s been created by `lambda`?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的新堆副本应保持未修改，稍后调用lambda时应该返回原始的“quick fox”字符串，而不是修改后的“sly fox”字符串。Ruby是如何允许我们在`lambda`创建新持久副本后修改栈的呢？
- en: As it turns out, once Ruby creates the new heap copy of the stack (the new `rb_env_t`
    structure or internal environment object), it resets the `EP` in the `rb_control_frame_t`
    structure to point to the copy. [Figure 8-26](ch08.html#ruby_resets_the_ep_after_creating_a_pers
    "Figure 8-26. Ruby resets the EP after creating a persistent heap copy of a stack
    frame.") shows how Ruby resets the `EP` after creating a persistent heap copy
    of a stack frame.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，一旦Ruby创建了栈的新的堆副本（新的`rb_env_t`结构或内部环境对象），它会重置`rb_control_frame_t`结构中的`EP`，使其指向该副本。[图8-26](ch08.html#ruby_resets_the_ep_after_creating_a_pers
    "图8-26。Ruby在创建堆栈帧的持久副本后重置EP。")展示了Ruby在创建堆栈帧的持久副本后如何重置`EP`。
- en: '![Ruby resets the EP after creating a persistent heap copy of a stack frame.](httpatomoreillycomsourcenostarchimages1854227.png.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby在创建堆栈帧的持久副本后重置EP。](httpatomoreillycomsourcenostarchimages1854227.png.jpg)'
- en: Figure 8-26. Ruby resets the `EP` after creating a persistent heap copy of a
    stack frame.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-26。Ruby在创建堆中的栈帧持久副本后，重置了`EP`。
- en: The difference here is that the `EP` now points down to the heap. Now when we
    call `str = "The sly brown fox"` at in [Example 8-14](ch08.html#which_version_of_str_will_lambda_copy_to
    "Example 8-14. Which version of str will lambda copy to the heap (modify_after_lambda.rb)?"),
    Ruby will use the new `EP` and access the value in the heap, not the original
    value on the stack. Notice `The sly brown fox` appears in the heap at the bottom
    of [Figure 8-26](ch08.html#ruby_resets_the_ep_after_creating_a_pers "Figure 8-26. Ruby
    resets the EP after creating a persistent heap copy of a stack frame.").
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的区别在于 `EP` 现在指向堆。当我们在[示例 8-14](ch08.html#which_version_of_str_will_lambda_copy_to
    "示例 8-14。lambda 会将哪个版本的 str 复制到堆（modify_after_lambda.rb）？") 中调用 `str = "The sly
    brown fox"` 时，Ruby 将使用新的 `EP` 访问堆中的值，而不是栈上的原始值。请注意，“The sly brown fox” 出现在堆中的[图
    8-26](ch08.html#ruby_resets_the_ep_after_creating_a_pers "图 8-26。Ruby 在创建堆上持久化栈帧副本后重置
    EP") 底部。
- en: Calling lambda More Than Once in the Same Scope
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在同一作用域内多次调用 lambda。
- en: Another interesting behavior of the `lambda` keyword is that Ruby avoids making
    copies of the stack frame more than once, as you can see in [Example 8-15](ch08.html#calling_lambda_twice_in_the_same_scope
    "Example 8-15. Calling lambda twice in the same scope").
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda` 关键字的另一个有趣行为是，Ruby 避免多次复制栈帧，正如你在[示例 8-15](ch08.html#calling_lambda_twice_in_the_same_scope
    "示例 8-15。相同作用域内调用两次 lambda") 中看到的那样。'
- en: Example 8-15. Calling `lambda` twice in the same scope
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-15。在同一作用域内调用 `lambda` 两次
- en: '[PRE18]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code expects both lambda functions to operate on the local variable `i`
    in the main scope.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码期望两个 lambda 函数在主作用域中操作局部变量 `i`。
- en: But if Ruby made a separate copy of the stack frame for each call to `lambda`,
    each function would operate on a separate copy of `i`. Look at the following example
    in [Example 8-16](ch08.html#calling_the_lambdas_created_in_listing_8 "Example 8-16. Calling
    the lambdas created in Example 8-15").
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果 Ruby 为每次调用 `lambda` 创建了栈帧的单独副本，那么每个函数都会操作 `i` 的单独副本。请看以下[示例 8-16](ch08.html#calling_the_lambdas_created_in_listing_8
    "示例 8-16。调用在示例 8-15 中创建的 lambda") 中的例子。
- en: Example 8-16. Calling the lambdas created in [Example 8-15](ch08.html#calling_lambda_twice_in_the_same_scope
    "Example 8-15. Calling lambda twice in the same scope")
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-16。调用在[示例 8-15](ch08.html#calling_lambda_twice_in_the_same_scope "示例 8-15。相同作用域内调用两次
    lambda") 中创建的 lambda。
- en: '[PRE19]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If Ruby used a separate copy of `i` for each lambda function, the previous listing
    would generate the output shown in [Example 8-17](ch08.html#output_we_would_expect_if_each_call
    "Example 8-17. The output we would expect if each call to lambda created its own
    copy of the stack frame").
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Ruby 为每个 lambda 函数使用了 `i` 的单独副本，那么前面的示例会生成[示例 8-17](ch08.html#output_we_would_expect_if_each_call
    "示例 8-17。如果每次调用 lambda 创建了自己的栈帧副本，我们期望的输出") 中显示的输出。
- en: Example 8-17. The output we would expect if each call to `lambda` created its
    own copy of the stack frame
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-17。如果每次调用 `lambda` 创建了自己的栈帧副本，我们期望的输出
- en: '[PRE20]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: But we actually see the output shown in [Example 8-18](ch08.html#because_the_lambda_functions_share_the_s
    "Example 8-18. Because the lambda functions share the same heap copy of the stack,
    running Example 8-16 generates this output.").
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，我们看到的是在[示例 8-18](ch08.html#because_the_lambda_functions_share_the_s "示例
    8-18。由于 lambda 函数共享相同堆上的栈副本，运行示例 8-16 会生成以下输出。") 中显示的输出。
- en: Example 8-18. Because the lambda functions share the same heap copy of the stack,
    running [Example 8-16](ch08.html#calling_the_lambdas_created_in_listing_8 "Example 8-16. Calling
    the lambdas created in Example 8-15") generates this output.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-18。由于 lambda 函数共享相同堆上的栈副本，运行[示例 8-16](ch08.html#calling_the_lambdas_created_in_listing_8
    "示例 8-16。调用在示例 8-15 中创建的 lambda") 会生成以下输出。
- en: '[PRE21]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Usually this is what you expect: Each block you pass to the lambdas accesses
    the same variable in the parent scope. Ruby achieves this by checking whether
    the `EP` already points to the heap. If so, as with the second call to `lambda`
    in [Example 8-15](ch08.html#calling_lambda_twice_in_the_same_scope "Example 8-15. Calling
    lambda twice in the same scope"), Ruby won’t create a second copy; it will simply
    reuse the same `rb_env_t` structure in the second `rb_proc_t` structure. Ultimately,
    both lambdas use the same heap copy of the stack.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这正是你期望的：你传递给 lambda 的每个块都访问父作用域中的相同变量。Ruby 通过检查 `EP` 是否已经指向堆来实现这一点。如果是，就像在[示例
    8-15](ch08.html#calling_lambda_twice_in_the_same_scope "示例 8-15。相同作用域内调用两次 lambda")
    中第二次调用 `lambda` 时，Ruby 不会创建第二个副本；它只会在第二个 `rb_proc_t` 结构中重用相同的 `rb_env_t` 结构。最终，两个
    lambda 使用相同的堆副本栈。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In [Chapter 3](ch03.html "Chapter 3. How Ruby Executes Your Code") we saw how
    YARV creates a new stack frame whenever you call a block, just as it does when
    you call a method. At first glance, Ruby blocks appear to be a special kind of
    method that you can call and pass arguments to. However, as we’ve seen in this
    chapter, there’s more to blocks than meets the eye.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章. Ruby 如何执行你的代码")中，我们看到每次调用块时，YARV 都会创建一个新的栈帧，正如调用方法时的行为一样。乍一看，Ruby
    块似乎是一种特殊的可以调用并传递参数的方法。然而，正如我们在本章中所看到的，块的含义远不止于此。
- en: 'Looking closely at the `rb_block_t` structure, we saw how blocks implement
    the computer science concept of *closure* in Ruby. Blocks are the combination
    of a function and an environment to use when calling that function. We learned
    that blocks have a curious dual personality in Ruby: They are similar to methods,
    but they also become part of the method that you call them from. The simplicity
    with which Ruby’s syntax allows for this dual role is one of the language’s most
    beautiful and elegant features.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看 `rb_block_t` 结构体时，我们看到块是如何在 Ruby 中实现计算机科学中的*闭包*概念的。块是一个函数与调用该函数时所需的环境的结合体。我们了解到，块在
    Ruby 中具有一种奇特的双重身份：它们类似于方法，但又成为调用它们的方法的一部分。Ruby 语法允许这种双重角色的方式非常简洁，这是这门语言最美丽和优雅的特点之一。
- en: Later we saw how Ruby allows you to treat functions or code as first-class citizens
    using the `lambda` keyword, which converts a block into a data value that you
    can pass, save, and reuse. After reviewing the differences between stack and heap
    memory, we explored the way that Ruby implements lambdas and procs, and we saw
    that Ruby copies the stack frame to the heap when you call `lambda` or `proc`
    and reuses it when you call the lambda’s block. Finally, we saw how the proc object
    represents code as a data object in Ruby.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 后来我们看到，Ruby 允许你使用 `lambda` 关键字将函数或代码作为一等公民，这将一个块转化为可以传递、保存和重用的数据值。在回顾栈内存和堆内存的区别之后，我们探讨了
    Ruby 如何实现 lambdas 和 procs，并且发现当你调用 `lambda` 或 `proc` 时，Ruby 会将栈帧复制到堆上，并在调用 lambda
    的块时重用它。最后，我们看到 proc 对象如何将代码表示为 Ruby 中的数据对象。
- en: '* * *'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#ch08fn01)]) If the outer code was located inside a function or method,
    then the `EP` would point to the stack frame as shown. But if the outer code was
    located in the top-level scope of your Ruby program, then Ruby would use dynamic
    access to save the variable in the `TOPLEVEL_BINDING` environment instead. Regardless,
    the `EP` will always indicate the location of the `str` variable.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#ch08fn01)]) 如果外部代码位于函数或方法内部，则 `EP` 会指向栈帧，如图所示。但如果外部代码位于 Ruby 程序的顶层作用域中，那么
    Ruby 会使用动态访问将变量保存在 `TOPLEVEL_BINDING` 环境中。不管怎样，`EP` 始终指示 `str` 变量的位置。
- en: '^([[2](#ch08fn02)]) Gerald J. Sussman and Guy L. Steele, Jr., “Scheme: An Interpreter
    for Extended Lambda Calculus” (MIT Artificial Intelligence Laboratory, AI Memo
    No. 349, December 1975).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '^([[2](#ch08fn02)]) Gerald J. Sussman 和 Guy L. Steele, Jr.， “Scheme: An Interpreter
    for Extended Lambda Calculus” (MIT 人工智能实验室，AI 备忘录 No. 349，1975年12月)。'
