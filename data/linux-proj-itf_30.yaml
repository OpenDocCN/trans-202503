- en: 'Chapter 30. Threads: Thread Synchronization'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第30章。线程：线程同步
- en: 'In this chapter, we describe two tools that threads can use to synchronize
    their actions: mutexes and condition variables. Mutexes allow threads to synchronize
    their use of a shared resource, so that, for example, one thread doesn’t try to
    access a shared variable at the same time as another thread is modifying it. Condition
    variables perform a complementary task: they allow threads to inform each other
    that a shared variable (or other shared resource) has changed state.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍两个线程可以用来同步操作的工具：互斥锁和条件变量。互斥锁允许线程同步访问共享资源，举例来说，避免一个线程在另一个线程正在修改共享变量时同时尝试访问该变量。条件变量则执行一个互补任务：它们允许线程相互通知共享变量（或其他共享资源）已发生状态变化。
- en: 'Protecting Accesses to Shared Variables: Mutexes'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护共享变量访问：互斥锁
- en: 'One of the principal advantages of threads is that they can share information
    via global variables. However, this easy sharing comes at a cost: we must take
    care that multiple threads do not attempt to modify the same variable at the same
    time, or that one thread doesn’t try to read the value of a variable while another
    thread is modifying it. The term *critical section* is used to refer to a section
    of code that accesses a shared resource and whose execution should be *atomic*;
    that is, its execution should not be interrupted by another thread that simultaneously
    accesses the same shared resource.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的主要优点之一是它们可以通过全局变量共享信息。然而，这种简单的共享是有代价的：我们必须确保多个线程不会同时尝试修改同一个变量，或者一个线程在另一个线程正在修改该变量时不会尝试读取变量的值。术语*临界区*用于指代访问共享资源的代码段，并且该代码段的执行应该是*原子*的；也就是说，其执行不应被其他同时访问同一共享资源的线程中断。
- en: '[Example 30-1](ch30.html#incorrectly_incrementing_a_global_variab "Example 30-1. Incorrectly
    incrementing a global variable from two threads") provides a simple example of
    the kind of problems that can occur when shared resources are not accessed atomically.
    This program creates two threads, each of which executes the same function. The
    function executes a loop that repeatedly increments a global variable, *glob*,
    by copying *glob* into the local variable *loc*, incrementing *loc*, and copying
    *loc* back to *glob*. (Since *loc* is an automatic variable allocated on the per-thread
    stack, each thread has its own copy of this variable.) The number of iterations
    of the loop is determined by the command-line argument supplied to the program,
    or by a default value, if no argument is supplied.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 30-1](ch30.html#incorrectly_incrementing_a_global_variab "示例 30-1. 两个线程错误地递增全局变量")提供了一个简单的例子，说明当共享资源没有原子访问时可能会发生的问题。该程序创建了两个线程，每个线程执行相同的函数。该函数执行一个循环，不断地递增全局变量*glob*，通过将*glob*的值复制到局部变量*loc*，递增*loc*，再将*loc*的值复制回*glob*。（由于*loc*是一个自动变量，在每个线程的栈上分配，因此每个线程都有自己的该变量副本。）循环的迭代次数由传递给程序的命令行参数决定，或者如果没有提供参数，则使用默认值。'
- en: Example 30-1. Incorrectly incrementing a global variable from two threads
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 30-1. 两个线程错误地递增全局变量
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Two threads incrementing a global variable without synchronization](figs/web/30-1_THREADS-A2-incr-scale90.png.jpg)Figure 30-1. Two
    threads incrementing a global variable without synchronization'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![两个线程在没有同步的情况下递增全局变量](figs/web/30-1_THREADS-A2-incr-scale90.png.jpg)图 30-1.
    两个线程在没有同步的情况下递增全局变量'
- en: 'When we run the program in [Example 30-1](ch30.html#incorrectly_incrementing_a_global_variab
    "Example 30-1. Incorrectly incrementing a global variable from two threads") specifying
    that each thread should increment the variable 1000 times, all seems well:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行[示例 30-1](ch30.html#incorrectly_incrementing_a_global_variab "示例 30-1.
    两个线程错误地递增全局变量")，并指定每个线程应将变量递增1000次时，一切看起来都很正常：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, what has probably happened here is that the first thread completed
    all of its work and terminated before the second thread even started. When we
    ask both threads to do a lot more work, we see a rather different result:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能发生的情况是，第一个线程在第二个线程开始之前就已经完成了所有工作并终止了。当我们要求两个线程做更多的工作时，结果则大不相同：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At the end of this sequence, the value of *glob* should have been 20 million.
    The problem here results from execution sequences such as the following (see also
    [Figure 30-1](ch30.html#two_threads_incrementing_a_global_variab "Figure 30-1. Two
    threads incrementing a global variable without synchronization"), above):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一系列操作的末尾，*glob*的值应该是2000万。这里的问题来自于如下的执行顺序（见[图30-1](ch30.html#two_threads_incrementing_a_global_variab
    "图30-1. 两个线程在没有同步的情况下递增全局变量")，上面）：
- en: Thread 1 fetches the current value of *glob* into its local variable *loc*.
    Let’s assume that the current value of *glob* is 2000.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程1将*glob*的当前值获取到它的局部变量*loc*中。假设当前*glob*的值是2000。
- en: The scheduler time slice for thread 1 expires, and thread 2 commences execution.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程1的调度时间片用完，线程2开始执行。
- en: Thread 2 performs multiple loops in which it fetches the current value of *glob*
    into its local variable *loc*, increments *loc*, and assigns the result to *glob*.
    In the first of these loops, the value fetched from *glob* will be 2000\. Let’s
    suppose that by the time the time slice for thread 2 has expired, *glob* has been
    increased to 3000.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程2执行多个循环，在每个循环中，它将*glob*的当前值获取到它的局部变量*loc*中，增加*loc*的值，并将结果赋回*glob*。在第一个循环中，从*glob*获取到的值将是2000。假设当线程2的时间片用完时，*glob*的值已经增加到3000。
- en: Thread 1 receives another time slice and resumes execution where it left off.
    Having previously (step 1) copied the value of *glob* (2000) into its *loc*, it
    now increments *loc* and assigns the result (2001) to *glob*. At this point, the
    effect of the increment operations performed by thread 2 is lost.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程1接收另一个时间片并继续执行它之前的操作。它之前（步骤1）将*glob*的值（2000）复制到了*loc*，现在它增加*loc*并将结果（2001）赋回*glob*。此时，线程2所做的递增操作的效果就丢失了。
- en: 'If we run the program in [Example 30-1](ch30.html#incorrectly_incrementing_a_global_variab
    "Example 30-1. Incorrectly incrementing a global variable from two threads") multiple
    times with the same command-line argument, we see that the printed value of *glob*
    fluctuates wildly:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们多次运行[示例30-1](ch30.html#incorrectly_incrementing_a_global_variab "示例30-1.
    从两个线程错误地递增全局变量")，使用相同的命令行参数，我们会发现*glob*的打印值剧烈波动：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This nondeterministic behavior is a consequence of the vagaries of the kernel’s
    CPU scheduling decisions. In complex programs, this nondeterministic behavior
    means that such errors may occur only rarely, be hard to reproduce, and therefore
    be difficult to find.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种非确定性行为是内核CPU调度决策的变动性的结果。在复杂的程序中，这种非确定性行为意味着这些错误可能很少发生，难以重现，因此也很难发现。
- en: 'It might seem that we could eliminate the problem by replacing the three statements
    inside the `for` loop in the *threadFunc()* function in [Example 30-1](ch30.html#incorrectly_incrementing_a_global_variab
    "Example 30-1. Incorrectly incrementing a global variable from two threads") with
    a single statement:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎我们可以通过用一个单一语句替换[示例30-1](ch30.html#incorrectly_incrementing_a_global_variab
    "示例30-1. 从两个线程错误地递增全局变量")中`for`循环内部的三条语句来消除这个问题：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, on many hardware architectures (e.g., RISC architectures), the compiler
    would still need to convert this single statement into machine code whose steps
    are equivalent to the three statements inside the loop in *threadFunc()*. In other
    words, despite its simple appearance, even a C increment operator may not be atomic,
    and it might demonstrate the behavior that we described above.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多硬件架构中（例如RISC架构），编译器仍然需要将这个单一语句转换为机器码，其步骤相当于*threadFunc()*循环内部的三条语句。换句话说，尽管它看起来很简单，即使是C语言的自增操作符也可能不是原子的，它可能会表现出我们上面描述的行为。
- en: To avoid the problems that can occur when threads try to update a shared variable,
    we must use a *mutex* (short for *mutual exclusion*) to ensure that only one thread
    at a time can access the variable. More generally, mutexes can be used to ensure
    atomic access to any shared resource, but protecting shared variables is the most
    common use.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免线程尝试更新共享变量时可能出现的问题，我们必须使用*互斥锁*（*mutex*，即*mutual exclusion*的缩写）来确保一次只有一个线程能够访问该变量。更一般地说，互斥锁可以用于确保对任何共享资源的原子访问，但保护共享变量是最常见的用途。
- en: 'A mutex has two states: *locked* and *unlocked*. At any moment, at most one
    thread may hold the lock on a mutex. Attempting to lock a mutex that is already
    locked either blocks or fails with an error, depending on the method used to place
    the lock.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥量有两种状态：*锁定*和*解锁*。在任何时刻，最多只有一个线程可以持有互斥量的锁。尝试锁定已被锁定的互斥量，要么会阻塞，要么会因所用方法的不同而返回错误。
- en: When a thread locks a mutex, it becomes the owner of that mutex. Only the mutex
    owner can unlock the mutex. This property improves the structure of code that
    uses mutexes and also allows for some optimizations in the implementation of mutexes.
    Because of this ownership property, the terms *acquire* and *release* are sometimes
    used synonymously for lock and unlock.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程锁定互斥量时，它成为该互斥量的拥有者。只有互斥量的拥有者可以解锁该互斥量。这个属性改进了使用互斥量的代码结构，并且还允许对互斥量的实现进行一些优化。由于这个拥有权属性，*获取*和*释放*这两个术语有时与锁定和解锁互斥量同义使用。
- en: 'In general, we employ a different mutex for each shared resource (which may
    consist of multiple related variables), and each thread employs the following
    protocol for accessing a resource:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们为每个共享资源（可能由多个相关变量组成）使用不同的互斥量，且每个线程都遵循以下协议来访问资源：
- en: lock the mutex for the shared resource;
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定共享资源的互斥量；
- en: access the shared resource; and
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问共享资源；以及
- en: unlock the mutex.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解锁互斥量；
- en: If multiple threads try to execute this block of code (a *critical section*),
    the fact that only one thread can hold the mutex (the others remain blocked) means
    that only one thread at a time can enter the block, as illustrated in [Figure 30-2](ch30.html#using_a_mutex_to_protect_a_critical_sect
    "Figure 30-2. Using a mutex to protect a critical section").
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个线程尝试执行这段代码块（*临界区*），由于只有一个线程可以持有互斥量（其他线程被阻塞），意味着一次只能有一个线程进入该代码块，如[图30-2](ch30.html#using_a_mutex_to_protect_a_critical_sect
    "图30-2. 使用互斥量保护临界区")所示。
- en: '![Using a mutex to protect a critical section](figs/web/30-2_THREADS-A2-mutex-block-scale90.png.jpg)Figure 30-2. Using
    a mutex to protect a critical section'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用互斥量保护临界区](figs/web/30-2_THREADS-A2-mutex-block-scale90.png.jpg)图30-2. 使用互斥量保护临界区'
- en: Finally, note that mutex locking is advisory, rather than mandatory. By this,
    we mean that a thread is free to ignore the use of a mutex and simply access the
    corresponding shared variable(s). In order to safely handle shared variables,
    all threads must cooperate in their use of a mutex, abiding by the locking rules
    it enforces.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意互斥量的锁定是建议性的，而非强制性的。我们的意思是，线程可以自由忽略互斥量的使用，直接访问相应的共享变量。为了安全地处理共享变量，所有线程必须在使用互斥量时协同工作，遵守其强制的锁定规则。
- en: Statically Allocated Mutexes
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态分配的互斥量
- en: A mutex can either be allocated as a static variable or be created dynamically
    at run time (for example, in a block of memory allocated via *malloc()*). Dynamic
    mutex creation is somewhat more complex, and we delay discussion of it until [Dynamically
    Initializing a Mutex](ch30.html#dynamically_initializing_a_mutex "Dynamically
    Initializing a Mutex").
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥量可以作为静态变量分配，或在运行时动态创建（例如，在通过*malloc()*分配的内存块中）。动态互斥量的创建稍微复杂一些，我们将推迟讨论，直到[动态初始化互斥量](ch30.html#dynamically_initializing_a_mutex
    "动态初始化互斥量")。
- en: 'A mutex is a variable of the type *pthread_mutex_t*. Before it can be used,
    a mutex must always be initialized. For a statically allocated mutex, we can do
    this by assigning it the value `PTHREAD_MUTEX_INITIALIZER`, as in the following
    example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥量是类型为*pthread_mutex_t*的变量。在使用互斥量之前，必须始终初始化它。对于静态分配的互斥量，我们可以通过将其赋值为`PTHREAD_MUTEX_INITIALIZER`来实现初始化，如以下示例所示：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: According to SUSv3, applying the operations that we describe in the remainder
    of this section to a *copy* of a mutex yields results that are undefined. Mutex
    operations should always be performed only on the original mutex that has been
    statically initialized using `PTHREAD_MUTEX_INITIALIZER` or dynamically initialized
    using *pthread_mutex_init()* (described in [Dynamically Initializing a Mutex](ch30.html#dynamically_initializing_a_mutex
    "Dynamically Initializing a Mutex")).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 根据SUSv3的规定，将我们在本节其余部分描述的操作应用于互斥量的*副本*会导致未定义的结果。互斥量操作应始终仅在已静态初始化的原始互斥量上执行，该原始互斥量可以通过`PTHREAD_MUTEX_INITIALIZER`进行静态初始化，或通过*pthread_mutex_init()*进行动态初始化（详见[动态初始化互斥量](ch30.html#dynamically_initializing_a_mutex
    "动态初始化互斥量")）。
- en: Locking and Unlocking a Mutex
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锁定与解锁互斥量
- en: After initialization, a mutex is unlocked. To lock and unlock a mutex, we use
    the *pthread_mutex_lock()* and *pthread_mutex_unlock()* functions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化后，互斥锁是解锁的。要锁定和解锁互斥锁，我们使用*pthread_mutex_lock()*和*pthread_mutex_unlock()*函数。
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return 0 on success, or a positive error number on error
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 两者在成功时返回0，出错时返回正的错误号
- en: To lock a mutex, we specify the mutex in a call to *pthread_mutex_lock()*. If
    the mutex is currently unlocked, this call locks the mutex and returns immediately.
    If the mutex is currently locked by another thread, then *pthread_mutex_lock()*
    blocks until the mutex is unlocked, at which point it locks the mutex and returns.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要锁定一个互斥锁，我们通过调用*pthread_mutex_lock()*来指定该互斥锁。如果互斥锁当前未被锁定，该调用会立即锁定互斥锁并返回。如果互斥锁当前已被另一个线程锁定，那么*pthread_mutex_lock()*会阻塞直到互斥锁被解锁，届时它会锁定该互斥锁并返回。
- en: 'If the calling thread itself has already locked the mutex given to *pthread_mutex_lock()*,
    then, for the default type of mutex, one of two implementation-defined possibilities
    may result: the thread deadlocks, blocked trying to lock a mutex that it already
    owns, or the call fails, returning the error `EDEADLK`. On Linux, the thread deadlocks
    by default. (We describe some other possible behaviors when we look at mutex types
    in [Mutex Types](ch30.html#mutex_types "Mutex Types").)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用线程本身已经锁定了传递给*pthread_mutex_lock()*的互斥锁，那么对于默认类型的互斥锁，可能会出现两种实现定义的结果之一：线程死锁，尝试锁定它已经拥有的互斥锁时被阻塞，或者调用失败，返回错误`EDEADLK`。在Linux中，默认情况下线程会死锁。（当我们查看[互斥锁类型](ch30.html#mutex_types
    "互斥锁类型")时，我们会描述其他一些可能的行为。）
- en: The *pthread_mutex_unlock()* function unlocks a mutex previously locked by the
    calling thread. It is an error to unlock a mutex that is not currently locked,
    or to unlock a mutex that is locked by another thread.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_mutex_unlock()*函数解锁由调用线程之前锁定的互斥锁。解锁一个未被锁定的互斥锁，或者解锁一个被另一个线程锁定的互斥锁是错误的。'
- en: If more than one other thread is waiting to acquire the mutex unlocked by a
    call to *pthread_mutex_unlock()*, it is indeterminate which thread will succeed
    in acquiring it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个线程在等待获取由调用*pthread_mutex_unlock()*解锁的互斥锁，那么哪个线程会成功获取该锁是无法确定的。
- en: Example program
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 30-2](ch30.html#using_a_mutex_to_protect_access_to_a_glo "Example 30-2. Using
    a mutex to protect access to a global variable") is a modified version of the
    program in [Example 30-1](ch30.html#incorrectly_incrementing_a_global_variab "Example 30-1. Incorrectly
    incrementing a global variable from two threads"). It uses a mutex to protect
    access to the global variable *glob*. When we run this program with a similar
    command line to that used earlier, we see that *glob* is always reliably incremented:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 30-2](ch30.html#using_a_mutex_to_protect_access_to_a_glo "示例 30-2. 使用互斥锁保护对全局变量的访问")是[示例
    30-1](ch30.html#incorrectly_incrementing_a_global_variab "示例 30-1. 错误地从两个线程递增全局变量")程序的修改版。它使用互斥锁来保护对全局变量*glob*的访问。当我们使用类似之前的命令行运行此程序时，我们会看到*glob*始终被可靠地递增：'
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Example 30-2. Using a mutex to protect access to a global variable
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 30-2. 使用互斥锁保护对全局变量的访问
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*pthread_mutex_trylock()* and *pthread_mutex_timedlock()*'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*pthread_mutex_trylock()* 和 *pthread_mutex_timedlock()*'
- en: 'The Pthreads API provides two variants of the *pthread_mutex_lock()* function:
    *pthread_mutex_trylock()* and *pthread_mutex_timedlock()*. (See the manual pages
    for prototypes of these functions.)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Pthreads API提供了*pthread_mutex_lock()*函数的两个变体：*pthread_mutex_trylock()* 和 *pthread_mutex_timedlock()*。（有关这些函数的原型，请参见手册页。）
- en: The *pthread_mutex_trylock()* function is the same as *pthread_mutex_lock()*,
    except that if the mutex is currently locked, *pthread_mutex_trylock()* fails,
    returning the error `EBUSY`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_mutex_trylock()*函数与*pthread_mutex_lock()*相同，不同之处在于如果互斥锁当前被锁定，*pthread_mutex_trylock()*会失败，返回错误`EBUSY`。'
- en: The *pthread_mutex_timedlock()* function is the same as *pthread_mutex_lock()*,
    except that the caller can specify an additional argument, *abstime*, that places
    a limit on the time that the thread will sleep while waiting to acquire the mutex.
    If the time interval specified by its *abstime* argument expires without the caller
    becoming the owner of the mutex, *pthread_mutex_timedlock()* returns the error
    `ETIMEDOUT`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_mutex_timedlock()*函数与*pthread_mutex_lock()*相同，唯一的不同是调用者可以指定一个额外的参数*abstime*，该参数限定了线程在等待获取互斥锁时的最大等待时间。如果指定的*abstime*参数指定的时间间隔到期，且调用者未成为互斥锁的拥有者，那么*pthread_mutex_timedlock()*会返回错误`ETIMEDOUT`。'
- en: The *pthread_mutex_trylock()* and *pthread_mutex_timedlock()* functions are
    much less frequently used than *pthread_mutex_lock()*. In most well-designed applications,
    a thread should hold a mutex for only a short time, so that other threads are
    not prevented from executing in parallel. This guarantees that other threads that
    are blocked on the mutex will soon be granted a lock on the mutex. A thread that
    uses *pthread_mutex_trylock()* to periodically poll the mutex to see if it can
    be locked risks being starved of access to the mutex while other queued threads
    are successively granted access to the mutex via *pthread_mutex_lock()*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_mutex_trylock()* 和 *pthread_mutex_timedlock()* 函数的使用频率远低于 *pthread_mutex_lock()*。在大多数设计良好的应用中，一个线程应该只持有互斥锁短暂的时间，以便其他线程能够并行执行。这确保了被阻塞在互斥锁上的其他线程将很快获得互斥锁的锁定。使用
    *pthread_mutex_trylock()* 定期轮询互斥锁以查看它是否可以被锁定的线程，存在因其他排队线程通过 *pthread_mutex_lock()*
    依次获得互斥锁而无法访问互斥锁的风险。'
- en: Performance of Mutexes
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 互斥锁的性能
- en: 'What is the cost of using a mutex? We have shown two different versions of
    a program that increments a shared variable: one without mutexes ([Example 30-1](ch30.html#incorrectly_incrementing_a_global_variab
    "Example 30-1. Incorrectly incrementing a global variable from two threads"))
    and one with mutexes ([Example 30-2](ch30.html#using_a_mutex_to_protect_access_to_a_glo
    "Example 30-2. Using a mutex to protect access to a global variable")). When we
    run these two programs on an x86-32 system running Linux 2.6.31 (with NPTL), we
    find that the version without mutexes requires a total of 0.35 seconds to execute
    10 million loops in each thread (and produces the wrong result), while the version
    with mutexes requires 3.1 seconds.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用互斥锁的代价是多少？我们展示了两个不同版本的程序来递增一个共享变量：一个不使用互斥锁（[示例 30-1](ch30.html#incorrectly_incrementing_a_global_variab
    "示例 30-1. 从两个线程错误地递增全局变量")），一个使用互斥锁（[示例 30-2](ch30.html#using_a_mutex_to_protect_access_to_a_glo
    "示例 30-2. 使用互斥锁保护对全局变量的访问")）。当我们在运行 Linux 2.6.31（带有 NPTL）的 x86-32 系统上运行这两个程序时，我们发现没有互斥锁的版本需要
    0.35 秒来执行每个线程中的 1000 万次循环（并且产生错误的结果），而使用互斥锁的版本需要 3.1 秒。
- en: At first, this seems expensive. But, consider the main loop executed by the
    version that does not employ a mutex ([Example 30-1](ch30.html#incorrectly_incrementing_a_global_variab
    "Example 30-1. Incorrectly incrementing a global variable from two threads")).
    In that version, the *threadFunc()* function executes a `for` loop that increments
    a loop control variable, compares that variable against another variable, performs
    two assignments and another increment operation, and then branches back to the
    top of the loop. The version that uses a mutex ([Example 30-2](ch30.html#using_a_mutex_to_protect_access_to_a_glo
    "Example 30-2. Using a mutex to protect access to a global variable")) performs
    the same steps, and locks and unlocks the mutex each time around the loop. In
    other words, the cost of locking and unlocking a mutex is somewhat less than ten
    times the cost of the operations that we listed for the first program. This is
    relatively cheap. Furthermore, in the typical case, a thread would spend much
    more time doing other work, and perform relatively fewer mutex lock and unlock
    operations, so that the performance impact of using a mutex is not significant
    in most applications.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这似乎代价很高。但请考虑不使用互斥锁的版本执行的主循环（[示例 30-1](ch30.html#incorrectly_incrementing_a_global_variab
    "示例 30-1. 从两个线程错误地递增全局变量")）。在该版本中，*threadFunc()* 函数执行一个 `for` 循环，递增一个循环控制变量，将该变量与另一个变量进行比较，执行两个赋值操作和另一个递增操作，然后跳回循环顶部。使用互斥锁的版本（[示例
    30-2](ch30.html#using_a_mutex_to_protect_access_to_a_glo "示例 30-2. 使用互斥锁保护对全局变量的访问")）执行相同的步骤，并在每次循环时锁定和解锁互斥锁。换句话说，锁定和解锁互斥锁的成本大约是我们为第一个程序列出的操作成本的十倍不到。这相对较便宜。此外，在典型情况下，线程会花费更多时间做其他工作，并执行较少的互斥锁定和解锁操作，因此在大多数应用中，使用互斥锁的性能影响并不显著。
- en: To put this further in perspective, running some simple test programs on the
    same system showed that 20 million loops locking and unlocking a file region using
    *fcntl()* ([Record Locking with *fcntl()*](ch55.html#record_locking_with_fcntl_open_parenthes
    "Record Locking with fcntl()")) require 44 seconds, and 20 million loops incrementing
    and decrementing a System V semaphore ([Chapter 47](ch47.html "Chapter 47. System
    V Semaphores")) require 28 seconds. The problem with file locks and semaphores
    is that they always require a system call for the lock and unlock operations,
    and each system call has a small, but appreciable, cost ([System Calls](ch03.html#system_calls
    "System Calls")). By contrast, mutexes are implemented using atomic machine-language
    operations (performed on memory locations visible to all threads) and require
    system calls only in case of lock contention.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明这一点，在同一系统上运行一些简单的测试程序显示，使用 *fcntl()* 锁定和解锁文件区域的 2000 万次循环需要 44 秒，而使用
    System V 信号量进行递增和递减的 2000 万次循环需要 28 秒 ([第 47 章](ch47.html "第 47 章. System V 信号量"))。文件锁和信号量的问题在于，它们总是需要系统调用来执行锁定和解锁操作，每个系统调用都有一个小但显著的开销
    ([系统调用](ch03.html#system_calls "系统调用"))。相比之下，互斥锁是通过原子机器语言操作（在所有线程可见的内存位置上执行）来实现的，只有在锁竞争的情况下才需要系统调用。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux, mutexes are implemented using *futexes* (an acronym derived from *fast
    user space mutexes*), and lock contentions are dealt with using the *futex()*
    system call. We don’t describe futexes in this book (they are not intended for
    direct use in user-space applications), but details can be found in [Drepper,
    2004 (a)], which also describes how mutexes are implemented using futexes. [Franke
    et al., 2002] is a (now outdated) paper written by the developers of futexes,
    which describes the early futex implementation and looks at the performance gains
    derived from futexes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，互斥锁是通过 *futexes* 实现的（*futexes* 是 *fast user space mutexes* 的缩写），锁竞争通过
    *futex()* 系统调用来处理。我们在本书中没有描述 futexes（它们不打算直接用于用户空间应用程序），但可以在 [Drepper, 2004 (a)]
    中找到详细信息，该文献也描述了如何使用 futexes 实现互斥锁。[Franke 等人, 2002] 是一篇（现在已过时的）论文，由 futexes 的开发人员编写，描述了早期的
    futex 实现，并研究了 futexes 带来的性能提升。
- en: Mutex Deadlocks
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 互斥锁死锁
- en: Sometimes, a thread needs to simultaneously access two or more different shared
    resources, each of which is governed by a separate mutex. When more than one thread
    is locking the same set of mutexes, deadlock situations can arise. [Figure 30-3](ch30.html#a_deadlock_when_two_threads_lock_two_mut
    "Figure 30-3. A deadlock when two threads lock two mutexes") shows an example
    of a deadlock in which each thread successfully locks one mutex, and then tries
    to lock the mutex that the other thread has already locked. Both threads will
    remain blocked indefinitely.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个线程需要同时访问两个或多个不同的共享资源，每个资源都由一个独立的互斥锁来管理。当多个线程同时锁定相同的互斥锁集合时，可能会出现死锁情况。[图
    30-3](ch30.html#a_deadlock_when_two_threads_lock_two_mut "图 30-3. 两个线程锁定两个互斥锁时的死锁")展示了一个死锁的例子，其中每个线程成功锁定一个互斥锁，然后尝试锁定另一个线程已经锁定的互斥锁。这两个线程将一直被阻塞，无法解锁。
- en: '![A deadlock when two threads lock two mutexes](figs/web/30-3_THREADS-A2-mutex-deadlock-scale90.png.jpg)Figure 30-3. A
    deadlock when two threads lock two mutexes'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![两个线程锁定两个互斥锁时的死锁](figs/web/30-3_THREADS-A2-mutex-deadlock-scale90.png.jpg)图
    30-3. 两个线程锁定两个互斥锁时的死锁'
- en: The simplest way to avoid such deadlocks is to define a mutex hierarchy. When
    threads can lock the same set of mutexes, they should always lock them in the
    same order. For example, in the scenario in [Figure 30-3](ch30.html#a_deadlock_when_two_threads_lock_two_mut
    "Figure 30-3. A deadlock when two threads lock two mutexes"), the deadlock could
    be avoided if the two threads always lock the mutexes in the order *mutex1* followed
    by *mutex2*. Sometimes, there is a logically obvious hierarchy of mutexes. However,
    even if there isn’t, it may be possible to devise an arbitrary hierarchical order
    that all threads should follow.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种死锁的最简单方法是定义一个互斥锁层次结构。当线程可以锁定同一组互斥锁时，它们应该始终按相同的顺序来锁定它们。例如，在[图 30-3](ch30.html#a_deadlock_when_two_threads_lock_two_mut
    "图 30-3. 两个线程锁定两个互斥锁时的死锁")的场景中，如果两个线程始终按照 *mutex1* 然后是 *mutex2* 的顺序来锁定互斥锁，就能避免死锁的发生。有时，互斥锁之间有一个逻辑上显而易见的层次结构。然而，即使没有这样的结构，仍然可以设计出一个任意的层次顺序，供所有线程遵循。
- en: An alternative strategy that is less frequently used is “try, and then back
    off.” In this strategy, a thread locks the first mutex using *pthread_mutex_lock()*,
    and then locks the remaining mutexes using *pthread_mutex_trylock()*. If any of
    the *pthread_mutex_trylock()* calls fails (with `EBUSY`), then the thread releases
    all mutexes, and then tries again, perhaps after a delay interval. This approach
    is less efficient than a lock hierarchy, since multiple iterations may be required.
    On the other hand, it can be more flexible, since it doesn’t require a rigid mutex
    hierarchy. An example of this strategy is shown in [Butenhof, 1996].
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一种较少使用的替代策略是“尝试，然后退回”。在这种策略中，线程使用 *pthread_mutex_lock()* 锁住第一个互斥锁，然后使用 *pthread_mutex_trylock()*
    锁住其余的互斥锁。如果任何 *pthread_mutex_trylock()* 调用失败（返回 `EBUSY`），则线程释放所有互斥锁，然后再尝试，可能会在延迟一段时间后再次尝试。这种方法比锁层次结构效率低，因为可能需要多次迭代。另一方面，它更加灵活，因为它不需要严格的互斥锁层次结构。这个策略的示例在
    [Butenhof, 1996] 中有所展示。
- en: Dynamically Initializing a Mutex
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态初始化互斥锁
- en: The static initializer value `PTHREAD_MUTEX_INITIALIZER` can be used only for
    initializing a statically allocated mutex with default attributes. In all other
    cases, we must dynamically initialize the mutex using *pthread_mutex_init()*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 静态初始化值 `PTHREAD_MUTEX_INITIALIZER` 仅能用于初始化具有默认属性的静态分配互斥锁。在所有其他情况下，我们必须使用 *pthread_mutex_init()*
    动态初始化互斥锁。
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or a positive error number on error
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回一个正的错误号码
- en: The *mutex* argument identifies the mutex to be initialized. The *attr* argument
    is a pointer to a *pthread_mutexattr_t* object that has previously been initialized
    to define the attributes for the mutex. (We say some more about mutex attributes
    in the next section.) If *attr* is specified as `NULL`, then the mutex is assigned
    various default attributes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*mutex* 参数标识要初始化的互斥锁。*attr* 参数是指向一个已被初始化的 *pthread_mutexattr_t* 对象的指针，用来定义互斥锁的属性。（在下一节中，我们会详细讲解互斥锁属性。）如果
    *attr* 被指定为 `NULL`，则互斥锁会被赋予各种默认属性。'
- en: SUSv3 specifies that initializing an already initialized mutex results in undefined
    behavior; we should not do this.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 规定，初始化一个已经初始化过的互斥锁会导致未定义的行为；我们不应这么做。
- en: 'Among the cases where we must use *pthread_mutex_init()* rather than a static
    initializer are the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用 *pthread_mutex_init()* 而不是静态初始化器的情况包括以下几种：
- en: The mutex was dynamically allocated on the heap. For example, suppose that we
    create a dynamically allocated linked list of structures, and each structure in
    the list includes a *pthread_mutex_t* field that holds a mutex that is used to
    protect access to that structure.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互斥锁是在堆上动态分配的。例如，假设我们创建了一个动态分配的结构体链表，每个结构体中都有一个包含互斥锁的 *pthread_mutex_t* 字段，用来保护对该结构体的访问。
- en: The mutex is an automatic variable allocated on the stack.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互斥锁是一个分配在栈上的自动变量。
- en: We want to initialize a statically allocated mutex with attributes other than
    the defaults.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望初始化一个具有默认属性之外的属性的静态分配互斥锁。
- en: When an automatically or dynamically allocated mutex is no longer required,
    it should be destroyed using *pthread_mutex_destroy()*. (It is not necessary to
    call *pthread_mutex_destroy()* on a mutex that was statically initialized using
    `PTHREAD_MUTEX_INITIALIZER`.)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个自动或动态分配的互斥锁不再需要时，应该使用 *pthread_mutex_destroy()* 销毁它。（对于使用 `PTHREAD_MUTEX_INITIALIZER`
    静态初始化的互斥锁，不需要调用 *pthread_mutex_destroy()*。）
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or a positive error number on error
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回一个正的错误号码
- en: It is safe to destroy a mutex only when it is unlocked, and no thread will subsequently
    try to lock it. If the mutex resides in a region of dynamically allocated memory,
    then it should be destroyed before freeing that memory region. An automatically
    allocated mutex should be destroyed before its host function returns.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在互斥锁处于解锁状态并且没有线程会再尝试锁住它时，销毁互斥锁才是安全的。如果互斥锁位于动态分配的内存区域中，则应在释放该内存区域之前销毁它。自动分配的互斥锁应在其宿主函数返回之前销毁。
- en: A mutex that has been destroyed with *pthread_mutex_destroy()* can subsequently
    be reinitialized by *pthread_mutex_init()*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个已被 *pthread_mutex_destroy()* 销毁的互斥锁可以通过 *pthread_mutex_init()* 重新初始化。
- en: Mutex Attributes
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 互斥锁属性
- en: 'As noted earlier, the *pthread_mutex_init() attr* argument can be used to specify
    a *pthread_mutexattr_t* object that defines the attributes of a mutex. Various
    Pthreads functions can be used to initialize and retrieve the attributes in a
    *pthread_mutexattr_t* object. We won’t go into all of the details of mutex attributes
    or show the prototypes of the various functions that can be used to initialize
    the attributes in a *pthread_mutexattr_t* object. However, we’ll describe one
    of the attributes that can be set for a mutex: its type.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，*pthread_mutex_init() attr* 参数可用于指定一个 *pthread_mutexattr_t* 对象，该对象定义了互斥锁的属性。可以使用各种
    Pthreads 函数来初始化和获取 *pthread_mutexattr_t* 对象中的属性。我们不会深入讨论互斥锁属性的所有细节，也不会展示可以用来初始化
    *pthread_mutexattr_t* 对象属性的各种函数的原型。然而，我们将描述一个可以为互斥锁设置的属性：其类型。
- en: Mutex Types
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 互斥锁类型
- en: 'In the preceding pages, we made a number of statements about the behavior of
    mutexes:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的页面中，我们做了一些关于互斥锁行为的陈述：
- en: A single thread may not lock the same mutex twice.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个线程不能两次锁定相同的互斥锁。
- en: A thread may not unlock a mutex that it doesn’t currently own (i.e., that it
    did not lock).
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程不能解锁它当前不拥有的互斥锁（即它没有锁定的互斥锁）。
- en: A thread may not unlock a mutex that is not currently locked.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程不能解锁当前没有锁定的互斥锁。
- en: 'Precisely what happens in each of these cases depends on the *type* of the
    mutex. SUSv3 defines the following mutex types:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下发生的具体情况取决于互斥锁的*类型*。SUSv3 定义了以下互斥锁类型：
- en: '`PTHREAD_MUTEX_NORMAL`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`PTHREAD_MUTEX_NORMAL`'
- en: (Self-)deadlock detection is not provided for this type of mutex. If a thread
    tries to lock a mutex that it has already locked, then deadlock results. Unlocking
    a mutex that is not locked or that is locked by another thread produces undefined
    results. (On Linux, both of these operations succeed for this mutex type.)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的互斥锁不提供（自我）死锁检测。如果一个线程尝试锁定它已经锁定的互斥锁，就会发生死锁。解锁一个没有被锁定或被另一个线程锁定的互斥锁会产生未定义的结果。（在
    Linux 上，这两种操作对这种类型的互斥锁会成功。）
- en: '`PTHREAD_MUTEX_ERRORCHECK`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`PTHREAD_MUTEX_ERRORCHECK`'
- en: Error checking is performed on all operations. All three of the above scenarios
    cause the relevant Pthreads function to return an error. This type of mutex is
    typically slower than a normal mutex, but can be useful as a debugging tool to
    discover where an application is violating the rules about how a mutex should
    be used.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有操作都进行了错误检查。上述三个场景都会导致相关的 Pthreads 函数返回错误。这种类型的互斥锁通常比普通的互斥锁要慢，但可以作为调试工具，用于发现应用程序在哪里违反了有关互斥锁使用规则的规定。
- en: '`PTHREAD_MUTEX_RECURSIVE`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`PTHREAD_MUTEX_RECURSIVE`'
- en: A recursive mutex maintains the concept of a lock count. When a thread first
    acquires the mutex, the lock count is set to 1\. Each subsequent lock operation
    by the same thread increments the lock count, and each unlock operation decrements
    the count. The mutex is released (i.e., made available for other threads to acquire)
    only when the lock count falls to 0\. Unlocking an unlocked mutex fails, as does
    unlocking a mutex that is currently locked by another thread.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 递归互斥锁维护一个锁定计数的概念。当一个线程首次获取互斥锁时，锁定计数被设置为 1。该线程每次执行锁操作时，锁定计数都会增加，每次解锁操作时，计数会减少。只有当锁定计数降为
    0 时，互斥锁才会被释放（即允许其他线程获取）。解锁一个未锁定的互斥锁会失败，解锁一个当前被另一个线程锁定的互斥锁也会失败。
- en: The Linux threading implementation provides nonstandard static initializers
    for each of the above mutex types (e.g., `PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP`),
    so that the use of *pthread_mutex_init()* is not required to initialize these
    mutex types for statically allocated mutexes. However, portable applications should
    avoid the use of these initializers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 线程实现提供了每种互斥锁类型的非标准静态初始化器（例如，`PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP`），因此对于静态分配的互斥锁，不需要使用
    *pthread_mutex_init()* 来初始化这些互斥锁类型。然而，可移植的应用程序应避免使用这些初始化器。
- en: In addition to the above mutex types, SUSv3 defines the `PTHREAD_MUTEX_DEFAULT`
    type, which is the default type of mutex if we use `PTHREAD_MUTEX_INITIALIZER`
    or specify *attr* as `NULL` in a call to *pthread_mutex_init()*. The behavior
    of this mutex type is deliberately undefined in all three of the scenarios described
    at the start of this section, which allows maximum flexibility for efficient implementation
    of mutexes. On Linux, a `PTHREAD_MUTEX_DEFAULT` mutex behaves like a `PTHREAD_MUTEX_NORMAL`
    mutex.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上面的互斥锁类型，SUSv3 还定义了 `PTHREAD_MUTEX_DEFAULT` 类型，这是如果我们使用 `PTHREAD_MUTEX_INITIALIZER`
    或在调用 *pthread_mutex_init()* 时指定*attr*为 `NULL`，默认的互斥锁类型。此互斥锁类型的行为在本节开始时描述的所有三种情况中都是故意未定义的，这为互斥锁的高效实现提供了最大灵活性。在
    Linux 上，`PTHREAD_MUTEX_DEFAULT` 互斥锁的行为类似于 `PTHREAD_MUTEX_NORMAL` 互斥锁。
- en: The code shown in [Example 30-3](ch30.html#setting_the_mutex_type "Example 30-3. Setting
    the mutex type") demonstrates how to set the type of a mutex, in this case to
    create an *error-checking* mutex.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 30-3](ch30.html#setting_the_mutex_type "示例 30-3. 设置互斥锁类型")中展示的代码演示了如何设置互斥锁的类型，在本例中是创建一个*错误检查*互斥锁。'
- en: Example 30-3. Setting the mutex type
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 30-3. 设置互斥锁类型
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Signaling Changes of State: Condition Variables'
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态变化的信号：条件变量
- en: A mutex prevents multiple threads from accessing a shared variable at the same
    time. A condition variable allows one thread to inform other threads about changes
    in the state of a shared variable (or other shared resource) and allows the other
    threads to wait (block) for such notification.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁防止多个线程同时访问共享变量。条件变量允许一个线程通知其他线程共享变量（或其他共享资源）状态的变化，并允许其他线程等待（阻塞）此类通知。
- en: 'A simple example that doesn’t use condition variables serves to demonstrate
    why they are useful. Suppose that we have a number of threads that produce some
    “result units” that are consumed by the main thread, and that we use a mutex-protected
    variable, *avail*, to represent the number of produced units awaiting consumption:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不使用条件变量的简单示例能够说明它们为何有用。假设我们有多个线程生产一些“结果单元”，这些单元由主线程消费，我们使用一个受互斥锁保护的变量*avail*来表示等待消费的生产单元数量：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code segments shown in this section can be found in the file `threads/prod_no_condvar.c`
    in the source code distribution for this book.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中展示的代码段可以在本书源代码的 `threads/prod_no_condvar.c` 文件中找到。
- en: 'In the producer threads, we would have code such as the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产者线程中，我们会有如下代码：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And in the main (consumer) thread, we could employ the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在主（消费者）线程中，我们可以使用以下代码：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The above code works, but it wastes CPU time, because the main thread continually
    loops, checking the state of the variable *avail*. A *condition variable* remedies
    this problem. It allows a thread to sleep (wait) until another thread notifies
    (signals) it that it must do something (i.e., that some “condition” has arisen
    that the sleeper must now respond to).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码是有效的，但它浪费了 CPU 时间，因为主线程会不断循环，检查变量*avail*的状态。*条件变量*可以解决这个问题。它允许一个线程进入休眠（等待）状态，直到另一个线程通知（信号）它必须执行某些操作（即，某个“条件”已经发生，休眠线程现在必须响应）。
- en: 'A condition variable is always used in conjunction with a mutex. The mutex
    provides mutual exclusion for accessing the shared variable, while the condition
    variable is used to signal changes in the variable’s state. (The use of the term
    *signal* here has nothing to do with the signals described in [Chapter 20](ch20.html
    "Chapter 20. Signals: Fundamental Concepts") to [Chapter 22](ch22.html "Chapter 22. Signals:
    Advanced Features"); rather, it is used in the sense of *indicate*.)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 条件变量总是与互斥锁一起使用。互斥锁为访问共享变量提供互斥，而条件变量用于通知变量状态的变化。（此处使用的*信号*一词与[第 20 章](ch20.html
    "第 20 章。信号：基本概念")到[第 22 章](ch22.html "第 22 章。信号：高级特性")中描述的信号无关；它是指*指示*的意思。）
- en: Statically Allocated Condition Variables
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态分配条件变量
- en: As with mutexes, condition variables can be allocated statically or dynamically.
    We defer discussion of dynamically allocated condition variables until [Dynamically
    Allocated Condition Variables](ch30.html#dynamically_allocated_condition_variable
    "Dynamically Allocated Condition Variables"), and consider statically allocated
    condition variables here.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与互斥锁一样，条件变量可以静态或动态分配。我们将延后讨论动态分配条件变量，直到[Dynamically Allocated Condition Variables](ch30.html#dynamically_allocated_condition_variable
    "动态分配条件变量")章节，并在这里讨论静态分配的条件变量。
- en: 'A condition variable has the type *pthread_cond_t*. As with a mutex, a condition
    variable must be initialized before use. For a statically allocated condition
    variable, this is done by assigning it the value `PTHREAD_COND_INITIALIZER`, as
    in the following example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 条件变量的类型是 *pthread_cond_t*。与互斥锁类似，条件变量在使用前必须初始化。对于静态分配的条件变量，可以通过将其赋值为 `PTHREAD_COND_INITIALIZER`
    来初始化，如以下示例所示：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: According to SUSv3, applying the operations that we describe in the remainder
    of this section to a *copy* of a condition variable yields results that are undefined.
    Operations should always be performed only on the original condition variable
    that has been statically initialized using `PTHREAD_COND_INITIALIZER` or dynamically
    initialized using *pthread_cond_init()* (described in [Dynamically Allocated Condition
    Variables](ch30.html#dynamically_allocated_condition_variable "Dynamically Allocated
    Condition Variables")).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 SUSv3，将我们在本节余下部分中描述的操作应用于条件变量的 *副本* 会导致未定义的结果。操作应始终仅在使用 `PTHREAD_COND_INITIALIZER`
    静态初始化或使用 *pthread_cond_init()* 动态初始化的原始条件变量上执行（详见 [动态分配的条件变量](ch30.html#dynamically_allocated_condition_variable
    "Dynamically Allocated Condition Variables")）。
- en: Signaling and Waiting on Condition Variables
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件变量的信号和等待
- en: The principal condition variable operations are *signal* and *wait*. The signal
    operation is a notification to one or more waiting threads that a shared variable’s
    state has changed. The wait operation is the means of blocking until such a notification
    is received.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的条件变量操作是 *signal* 和 *wait*。信号操作是通知一个或多个等待线程共享变量的状态已经改变。等待操作是阻塞直到接收到这种通知的手段。
- en: The *pthread_cond_signal()* and *pthread_cond_broadcast()* functions both signal
    the condition variable specified by *cond*. The *pthread_cond_wait()* function
    blocks a thread until the condition variable *cond* is signaled.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_cond_signal()* 和 *pthread_cond_broadcast()* 函数都向指定的条件变量 *cond* 发送信号。*pthread_cond_wait()*
    函数阻塞一个线程，直到条件变量 *cond* 被信号唤醒。'
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All return 0 on success, or a positive error number on error
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回正的错误号。
- en: The difference between *pthread_cond_signal()* and *pthread_cond_broadcast()*
    lies in what happens if multiple threads are blocked in *pthread_cond_wait()*.
    With *pthread_cond_signal()*, we are simply guaranteed that at least one of the
    blocked threads is woken up; with *pthread_cond_broadcast()*, all blocked threads
    are woken up.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_cond_signal()* 和 *pthread_cond_broadcast()* 之间的区别在于，当多个线程在 *pthread_cond_wait()*
    中被阻塞时发生的情况。使用 *pthread_cond_signal()* 时，我们仅确保至少一个被阻塞的线程会被唤醒；而使用 *pthread_cond_broadcast()*
    时，所有被阻塞的线程都会被唤醒。'
- en: 'Using *pthread_cond_broadcast()* always yields correct results (since all threads
    should be programmed to handle redundant and spurious wake-ups), but *pthread_cond_signal()*
    can be more efficient. However, *pthread_cond_signal()* should be used only if
    just one of the waiting threads needs to be woken up to handle the change in state
    of the shared variable, and it doesn’t matter which one of the waiting threads
    is woken up. This scenario typically applies when all of the waiting threads are
    designed to perform the exactly same task. Given these assumptions, *pthread_cond_signal()*
    can be more efficient than *pthread_cond_broadcast()*, because it avoids the following
    possibility:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *pthread_cond_broadcast()* 总是能产生正确的结果（因为所有线程应该编写代码来处理冗余和虚假唤醒），但是 *pthread_cond_signal()*
    可能更高效。然而，*pthread_cond_signal()* 应仅在只需要唤醒一个等待线程来处理共享变量状态变化的情况使用，而且不在乎唤醒哪个等待线程。当所有等待线程都设计为执行完全相同的任务时，这种场景通常适用。在这些假设下，*pthread_cond_signal()*
    可以比 *pthread_cond_broadcast()* 更高效，因为它避免了以下可能性：
- en: All waiting threads are awoken.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有等待线程都被唤醒。
- en: One thread is scheduled first. This thread checks the state of the shared variable(s)
    (under protection of the associated mutex) and sees that there is work to be done.
    The thread performs the required work, changes the state of the shared variable(s)
    to indicate that the work has been done, and unlocks the associated mutex.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个线程首先被调度。该线程检查共享变量的状态（在关联互斥锁的保护下），并看到有工作需要完成。线程执行所需的工作，改变共享变量的状态以表明工作已完成，并解锁关联的互斥锁。
- en: Each of the remaining threads in turn locks the mutex and tests the state of
    the shared variable. However, because of the change made by the first thread,
    these threads see that there is no work to be done, and so unlock the mutex and
    go back to sleep (i.e., call *pthread_cond_wait()* once more).
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的每个线程依次锁定互斥量并检查共享变量的状态。然而，由于第一个线程所做的更改，这些线程发现没有工作可做，因此解锁互斥量并回到休眠状态（即再次调用 *pthread_cond_wait()*）。
- en: By contrast, *pthread_cond_broadcast()* handles the case where the waiting threads
    are designed to perform different tasks (in which case they probably have different
    predicates associated with the condition variable).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，*pthread_cond_broadcast()* 处理的是等待线程需要执行不同任务的情况（在这种情况下，它们可能会有不同的条件变量谓词）。
- en: A condition variable holds no state information. It is simply a mechanism for
    communicating information about the application’s state. If no thread is waiting
    on the condition variable at the time that it is signaled, then the signal is
    lost. A thread that later waits on the condition variable will unblock only when
    the variable is signaled once more.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 条件变量不保存任何状态信息。它只是一个用于传递应用程序状态信息的机制。如果在条件变量被信号唤醒时没有线程在等待它，那么信号就会丢失。稍后等待条件变量的线程，只有当变量再次被信号唤醒时才会解除阻塞。
- en: The *pthread_cond_timedwait()* function is the same as *pthread_cond_wait()*,
    except that the *abstime* argument specifies an upper limit on the time that the
    thread will sleep while waiting for the condition variable to be signaled.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_cond_timedwait()* 函数与 *pthread_cond_wait()* 相同，不同之处在于 *abstime* 参数指定了线程在等待条件变量被信号唤醒时的最大休眠时间。'
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Returns 0 on success, or a positive error number on error
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回一个正的错误号。
- en: 'The *abstime* argument is a *timespec* structure ([High-Resolution Sleeping:
    *nanosleep()*](ch23.html#high-resolution_sleeping_colon_nanosleep "High-Resolution
    Sleeping: nanosleep()")) specifying an absolute time expressed as seconds and
    nanoseconds since the Epoch ([Calendar Time](ch10.html#calendar_time "Calendar
    Time")). If the time interval specified by *abstime* expires without the condition
    variable being signaled, then *pthread_cond_timedwait()* returns the error `ETIMEDOUT`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*abstime* 参数是一个 *timespec* 结构体（[高分辨率睡眠：*nanosleep()*](ch23.html#high-resolution_sleeping_colon_nanosleep
    "High-Resolution Sleeping: nanosleep()")），指定了自纪元（[日历时间](ch10.html#calendar_time
    "Calendar Time")）以来的绝对时间，以秒和纳秒表示。如果 *abstime* 指定的时间间隔过期且条件变量没有被信号唤醒，则 *pthread_cond_timedwait()*
    返回错误 `ETIMEDOUT`。'
- en: Using a condition variable in the producer-consumer example
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在生产者-消费者示例中使用条件变量
- en: 'Let’s revise our previous example to use a condition variable. The declarations
    of our global variable and associated mutex and condition variable are as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改之前的示例以使用条件变量。我们全局变量以及关联的互斥量和条件变量的声明如下：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: The code segments shown in this section can be found in the file `threads/prod_condvar.c`
    in the source code distribution for this book.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中显示的代码段可以在本书的源代码分发文件 `threads/prod_condvar.c` 中找到。
- en: 'The code in the producer threads is the same as before, except that we add
    a call to *pthread_cond_signal()*:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者线程中的代码与之前相同，唯一不同的是我们添加了一个调用 *pthread_cond_signal()*：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Before considering the code of the consumer, we need to explain *pthread_cond_wait()*
    in greater detail. We noted earlier that a condition variable always has an associated
    mutex. Both of these objects are passed as arguments to *pthread_cond_wait()*,
    which performs the following steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑消费者代码之前，我们需要更详细地解释 *pthread_cond_wait()*。我们之前提到过，条件变量总是与一个互斥量关联。这两个对象作为参数传递给
    *pthread_cond_wait()*，它执行以下步骤：
- en: unlock the mutex specified by *mutex*;
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解锁由 *mutex* 指定的互斥量；
- en: block the calling thread until another thread signals the condition variable
    *cond*; and
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞调用线程，直到另一个线程发出条件变量 *cond* 的信号；并且
- en: relock *mutex*.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新锁定 *mutex*。
- en: 'The *pthread_cond_wait()* function is designed to perform these steps because,
    normally, we access a shared variable in the following manner:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_cond_wait()* 函数的设计目的是执行这些步骤，因为通常我们以以下方式访问共享变量：'
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: (We explain why the *pthread_cond_wait()* call is placed within a `while` loop
    rather than an `if` statement in the next section.)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: （我们将在下一节解释为何将 *pthread_cond_wait()* 放在 `while` 循环中，而不是 `if` 语句中。）
- en: 'In the above code, both accesses to the shared variable must be mutex-protected
    for the reasons that we explained earlier. In other words, there is a natural
    association of a mutex with a condition variable:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，两个访问共享变量的操作都必须进行互斥锁保护，原因我们之前已经解释过。换句话说，互斥锁和条件变量之间有一个自然的关联：
- en: The thread locks the mutex in preparation for checking the state of the shared
    variable.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程锁定互斥锁，为检查共享变量的状态做准备。
- en: The state of the shared variable is checked.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 共享变量的状态被检查。
- en: If the shared variable is not in the desired state, then the thread must unlock
    the mutex (so that other threads can access the shared variable) before it goes
    to sleep on the condition variable.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果共享变量不处于期望的状态，那么线程必须解锁互斥锁（以便其他线程可以访问共享变量），然后再在条件变量上入睡。
- en: When the thread is reawakened because the condition variable has been signaled,
    the mutex must once more be locked, since, typically, the thread then immediately
    accesses the shared variable.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当线程因为条件变量被发出信号而重新唤醒时，必须再次锁定互斥锁，因为通常情况下，线程此时会立即访问共享变量。
- en: The *pthread_cond_wait()* function automatically performs the mutex unlocking
    and locking required in the last two of these steps. In the third step, releasing
    the mutex and blocking on the condition variable are performed atomically. In
    other words, it is not possible for some other thread to acquire the mutex and
    signal the condition variable before the thread calling *pthread_cond_wait()*
    has blocked on the condition variable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_cond_wait()* 函数自动执行这两个步骤中的互斥锁解锁和锁定操作。在第三步中，释放互斥锁和在条件变量上阻塞是原子性执行的。换句话说，在调用
    *pthread_cond_wait()* 的线程阻塞在条件变量之前，不可能有其他线程获取互斥锁并发出条件变量的信号。'
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is a corollary to the observation that there is a natural relationship
    between a condition variable and a mutex: all threads that concurrently wait on
    a particular condition variable must specify the same mutex in their *pthread_cond_wait()*
    (or *pthread_cond_timedwait()*) calls. In effect, a *pthread_cond_wait()* call
    dynamically binds a condition variable to a unique mutex for the duration of the
    call. SUSv3 notes that the result of using more than one mutex for concurrent
    *pthread_cond_wait()* calls on the same condition variable is undefined.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 关于条件变量和互斥锁之间有自然关系的观察有一个推论：所有同时等待同一条件变量的线程在它们的 *pthread_cond_wait()*（或 *pthread_cond_timedwait()*）调用中必须指定相同的互斥锁。实际上，*pthread_cond_wait()*
    调用在调用期间将条件变量动态绑定到一个唯一的互斥锁。SUSv3 提到，使用多个互斥锁进行并发的 *pthread_cond_wait()* 调用同一个条件变量的结果是未定义的。
- en: 'Putting the above details together, we can now modify the main (consumer) thread
    to use *pthread_cond_wait()*, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述细节结合起来，我们可以修改主（消费者）线程来使用 *pthread_cond_wait()*，如下所示：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We conclude with one final observation about the use of *pthread_cond_signal()*
    (and *pthread_cond_broadcast()*). In the producer code shown earlier, we called
    *pthread_mutex_unlock()*, and then called *pthread_cond_signal()*; that is, we
    first unlocked the mutex associated with the shared variable, and then signaled
    the corresponding condition variable. We could have reversed these two steps;
    SUSv3 permits them to be done in either order.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后对使用 *pthread_cond_signal()*（和 *pthread_cond_broadcast()*）做一个总结观察。在之前的生产者代码中，我们首先调用了
    *pthread_mutex_unlock()*，然后调用了 *pthread_cond_signal()*；也就是说，我们先解锁了与共享变量相关的互斥锁，然后发出了相应的条件变量信号。我们也可以将这两个步骤的顺序反过来；SUSv3
    允许它们以任意顺序执行。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '[Butenhof, 1996] points out that, on some implementations, unlocking the mutex
    and then signaling the condition variable may yield better performance than performing
    these steps in the reverse sequence. If the mutex is unlocked only after the condition
    variable is signaled, the thread performing *pthread_cond_wait()* may wake up
    while the mutex is still locked, and then immediately go back to sleep again when
    it finds that the mutex is locked. This results in two superfluous context switches.
    Some implementations eliminate this problem by employing a technique called *wait
    morphing*, which moves the signaled thread from the condition variable wait queue
    to the mutex wait queue without performing a context switch if the mutex is locked.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[Butenhof, 1996]指出，在某些实现中，先解锁互斥锁再发出条件变量信号的性能可能优于逆序执行这些步骤。如果互斥锁只有在条件变量被信号后才解锁，那么执行*pthread_cond_wait()*的线程可能会在互斥锁仍然被锁住时被唤醒，然后在发现互斥锁被锁住时立即重新进入睡眠状态。这会导致两个多余的上下文切换。一些实现通过采用称为*等待变形*的技术来消除这个问题，该技术将信号线程从条件变量等待队列移动到互斥锁等待队列，而无需执行上下文切换，前提是互斥锁已被锁住。'
- en: Testing a Condition Variable’s Predicate
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试条件变量的谓词
- en: 'Each condition variable has an associated predicate involving one or more shared
    variables. For example, in the code segment in the preceding section, the predicate
    associated with *cond* is *(avail == 0)*. This code segment demonstrates a general
    design principle: a *pthread_cond_wait()* call must be governed by a `while` loop
    rather than an `if` statement. This is so because, on return from *pthread_cond_wait()*,
    there are no guarantees about the state of the predicate; therefore, we should
    immediately recheck the predicate and resume sleeping if it is not in the desired
    state.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 每个条件变量都有一个与之关联的谓词，该谓词涉及一个或多个共享变量。例如，在前面章节中的代码段中，与*cond*相关联的谓词是*(avail == 0)*。该代码段展示了一个通用设计原则：*pthread_cond_wait()*调用必须由`while`循环来控制，而不是`if`语句。这是因为，从*pthread_cond_wait()*返回后，谓词的状态无法保证；因此，我们应该立即重新检查谓词，并在其不处于期望状态时继续睡眠。
- en: 'We can’t make any assumptions about the state of the predicate upon return
    from *pthread_cond_wait()*, for the following reasons:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能对从*pthread_cond_wait()*返回后的谓词状态做出任何假设，原因如下：
- en: '*Other threads may be woken up first*. Perhaps several threads were waiting
    to acquire the mutex associated with the condition variable. Even if the thread
    that signaled the mutex set the predicate to the desired state, it is still possible
    that another thread might acquire the mutex first and change the state of the
    associated shared variable(s), and thus the state of the predicate.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*其他线程可能会先被唤醒*。可能有多个线程在等待获取与条件变量相关联的互斥锁。即使发出信号的线程已将谓词设置为期望状态，仍然可能是另一个线程先获取了互斥锁并改变了相关共享变量的状态，从而改变了谓词的状态。'
- en: '*Designing for “loose” predicates may be simpler*. Sometimes, it is easier
    to design applications based on condition variables that indicate *possibility*
    rather than *certainty*. In other words, signaling a condition variable would
    mean “there *may be* something” for the signaled thread to do, rather than “there
    *is* something” to do. Using this approach, the condition variable can be signaled
    based on approximations of the predicate’s state, and the signaled thread can
    ascertain if there really is something to do by rechecking the predicate.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设计“松散”谓词可能更简单*。有时，基于指示*可能性*而非*确定性*的条件变量设计应用程序会更容易。换句话说，信号条件变量意味着“可能有某些事情”需要信号线程去做，而不是“有某些事情”需要做。使用这种方法，条件变量可以基于谓词状态的近似值来发出信号，信号线程可以通过重新检查谓词来确认是否真的有事情要做。'
- en: '*Spurious wake-ups can occur*. On some implementations, a thread waiting on
    a condition variable may be woken up even though no other thread actually signaled
    the condition variable. Such spurious wake-ups are a (rare) consequence of the
    techniques required for efficient implementation on some multiprocessor systems,
    and are explicitly permitted by SUSv3.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*虚假唤醒可能会发生*。在某些实现中，一个线程在等待条件变量时，可能会被唤醒，尽管没有其他线程实际发出条件变量信号。这种虚假唤醒是某些多处理器系统中为了高效实现而需要的技术的（罕见）结果，并且在SUSv3中明确允许。'
- en: 'Example Program: Joining Any Terminated Thread'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例程序：加入任何已终止的线程
- en: We noted earlier that *pthread_join()* can be used to join with only a specific
    thread. It provides no mechanism for joining with *any* terminated thread. We
    now show how a condition variable can be used to circumvent this restriction.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，*pthread_join()*只能与特定线程连接。它没有提供与*任何*已终止线程连接的机制。现在，我们将展示如何使用条件变量来绕过这个限制。
- en: The program in [Example 30-4](ch30.html#a_main_thread_that_can_join_with_any_ter
    "Example 30-4. A main thread that can join with any terminated thread") creates
    one thread for each of its command-line arguments. Each thread sleeps for the
    number of seconds specified in the corresponding command-line argument and then
    terminates. The sleep interval is our means of simulating the idea of a thread
    that does work for a period of time.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在[示例 30-4](ch30.html#a_main_thread_that_can_join_with_any_ter "示例 30-4. 一个可以与任何已终止线程连接的主线程")中为每个命令行参数创建一个线程。每个线程休眠时间为对应命令行参数指定的秒数，然后终止。休眠时间是我们模拟线程执行任务的手段。
- en: 'The program maintains a set of global variables recording information about
    all of the threads that have been created. For each thread, an element in the
    global *thread* array records the ID of the thread (the *tid* field) and its current
    state (the *state* field). The *state* field has one of the following values:
    `TS_ALIVE`, meaning the thread is alive; `TS_TERMINATED`, meaning the thread has
    terminated but not yet been joined; or `TS_JOINED`, meaning the thread has terminated
    and been joined.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 程序维护一组全局变量，记录所有已创建线程的信息。对于每个线程，全球*thread*数组中的一个元素记录线程的ID（*tid*字段）和其当前状态（*state*字段）。*state*字段有以下几种值：`TS_ALIVE`，表示线程处于活动状态；`TS_TERMINATED`，表示线程已终止但尚未连接；或`TS_JOINED`，表示线程已终止并且已连接。
- en: As each thread terminates, it assigns the value `TS_TERMINATED` to the *state*
    field for its element in the *thread* array, increments a global counter of terminated
    but as yet unjoined threads (*numUnjoined*), and signals the condition variable
    *threadDied*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个线程终止时，它会将值`TS_TERMINATED`分配给*thread*数组中该线程元素的*state*字段，增加一个全局计数器，记录已终止但尚未连接的线程(*numUnjoined*)，并触发条件变量*threadDied*。
- en: The main thread employs a loop that continuously waits on the condition variable
    *threadDied*. Whenever *threadDied* is signaled and there are terminated threads
    that have not been joined, the main thread scans the *thread* array, looking for
    elements with *state* set to `TS_TERMINATED`. For each thread in this state, *pthread_join()*
    is called using the corresponding *tid* field from the *thread* array, and then
    the *state* is set to `TS_JOINED`. The main loop terminates when all of the threads
    created by the main thread have died—that is, when the global variable *numLive*
    is 0.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 主线程使用一个循环，持续等待条件变量*threadDied*。每当*threadDied*被触发且存在尚未连接的已终止线程时，主线程扫描*thread*数组，寻找*state*字段设置为`TS_TERMINATED`的元素。对于处于该状态的每个线程，调用*pthread_join()*，使用*thread*数组中相应的*tid*字段，然后将*state*设置为`TS_JOINED`。当所有由主线程创建的线程都已终止——即全局变量*numLive*为0时，主循环终止。
- en: 'The following shell session log demonstrates the use of the program in [Example 30-4](ch30.html#a_main_thread_that_can_join_with_any_ter
    "Example 30-4. A main thread that can join with any terminated thread"):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell会话日志演示了[示例 30-4](ch30.html#a_main_thread_that_can_join_with_any_ter "示例
    30-4. 一个可以与任何已终止线程连接的主线程")中程序的使用：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, note that although the threads in the example program are created as
    joinable and are immediately reaped on termination using *pthread_join()*, we
    don’t need to use this approach in order to find out about thread termination.
    We could have made the threads detached, removed the use of *pthread_join()*,
    and simply used the *thread* array (and associated global variables) as the means
    of recording the termination of each thread.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意尽管示例程序中的线程是以可连接的方式创建，并且在终止时通过*pthread_join()*立即回收，但我们不需要采用这种方法来了解线程的终止状态。我们本可以让线程为分离线程，移除使用*pthread_join()*，并仅使用*thread*数组（和相关的全局变量）来记录每个线程的终止情况。
- en: Example 30-4. A main thread that can join with any terminated thread
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 30-4. 一个可以与任何已终止线程连接的主线程
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Dynamically Allocated Condition Variables
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态分配的条件变量
- en: The *pthread_cond_init()* function is used to dynamically initialize a condition
    variable. The circumstances in which we need to use *pthread_cond_init()* are
    analogous to those where *pthread_mutex_init()* is needed to dynamically initialize
    a mutex ([Dynamically Initializing a Mutex](ch30.html#dynamically_initializing_a_mutex
    "Dynamically Initializing a Mutex")); that is, we must use *pthread_cond_init()*
    to initialize automatically and dynamically allocated condition variables, and
    to initialize a statically allocated condition variable with attributes other
    than the defaults.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_cond_init()*函数用于动态初始化条件变量。我们需要使用*pthread_cond_init()*的情境类似于使用*pthread_mutex_init()*动态初始化互斥锁的情境（参见[动态初始化互斥锁](ch30.html#dynamically_initializing_a_mutex
    "Dynamically Initializing a Mutex")）；也就是说，我们必须使用*pthread_cond_init()*来初始化自动和动态分配的条件变量，并初始化具有非默认属性的静态分配条件变量。'
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or a positive error number on error
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回正的错误号
- en: The *cond* argument identifies the condition variable to be initialized. As
    with mutexes, we can specify an *attr* argument that has been previously initialized
    to determine attributes for the condition variable. Various Pthreads functions
    can be used to initialize the attributes in the *pthread_condattr_t* object pointed
    to by *attr*. If *attr* is `NULL`, a default set of attributes is assigned to
    the condition variable.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*cond*参数标识要初始化的条件变量。与互斥锁一样，我们可以指定一个*attr*参数，该参数是之前初始化的，用于确定条件变量的属性。可以使用各种Pthreads函数来初始化*attr*指向的*pthread_condattr_t*对象中的属性。如果*attr*为`NULL`，则为条件变量分配一组默认属性。'
- en: SUSv3 specifies that initializing an already initialized condition variable
    results in undefined behavior; we should not do this.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3规定，初始化已经初始化过的条件变量会导致未定义行为；我们不应这样做。
- en: When an automatically or dynamically allocated condition variable is no longer
    required, then it should be destroyed using *pthread_cond_destroy()*. It is not
    necessary to call *pthread_cond_destroy()* on a condition variable that was statically
    initialized using `PTHREAD_COND_INITIALIZER`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当自动或动态分配的条件变量不再需要时，应使用*pthread_cond_destroy()*销毁它。对于通过`PTHREAD_COND_INITIALIZER`静态初始化的条件变量，无需调用*pthread_cond_destroy()*。
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or a positive error number on error
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回正的错误号
- en: It is safe to destroy a condition variable only when no threads are waiting
    on it. If the condition variable resides in a region of dynamically allocated
    memory, then it should be destroyed before freeing that memory region. An automatically
    allocated condition variable should be destroyed before its host function returns.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在没有线程等待条件变量时，销毁该条件变量才是安全的。如果条件变量位于动态分配的内存区域中，则应该在释放该内存区域之前销毁该条件变量。自动分配的条件变量应在其宿主函数返回之前销毁。
- en: A condition variable that has been destroyed with *pthread_cond_destroy()* can
    subsequently be reinitialized by *pthread_cond_init()*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 已通过*pthread_cond_destroy()*销毁的条件变量可以通过*pthread_cond_init()*重新初始化。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: The greater sharing provided by threads comes at a cost. Threaded applications
    must employ synchronization primitives such as mutexes and condition variables
    in order to coordinate access to shared variables. A mutex provides exclusive
    access to a shared variable. A condition variable allows one or more threads to
    wait for notification that some other thread has changed the state of a shared
    variable.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 线程提供的更大共享带来了代价。线程化应用程序必须使用同步原语，如互斥锁和条件变量，以协调对共享变量的访问。互斥锁提供对共享变量的独占访问。条件变量允许一个或多个线程等待通知，直到另一个线程改变共享变量的状态。
- en: Further information
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多信息
- en: Refer to the sources of further information listed in [Summary](ch29.html#summary-id28
    "Summary").
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考[总结](ch29.html#summary-id28 "Summary")中列出的更多信息来源。
- en: Exercises
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Modify the program in [Example 30-1](ch30.html#incorrectly_incrementing_a_global_variab
    "Example 30-1. Incorrectly incrementing a global variable from two threads") (`thread_incr.c`)
    so that each loop in the thread’s start function outputs the current value of
    *glob* and some identifier that uniquely identifies the thread. The unique identifier
    for the thread could be specified as an argument to the *pthread_create()* call
    used to create the thread. For this program, that would require changing the argument
    of the thread’s start function to be a pointer to a structure containing the unique
    identifier and a loop limit value. Run the program, redirecting output to a file,
    and then inspect the file to see what happens to *glob* as the kernel scheduler
    alternates execution between the two threads.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[示例30-1](ch30.html#incorrectly_incrementing_a_global_variab "示例30-1. 两个线程错误地递增全局变量")程序（`thread_incr.c`），使线程的启动函数中的每个循环输出*glob*的当前值以及一个唯一标识该线程的标识符。线程的唯一标识符可以作为参数传递给用于创建线程的*pthread_create()*调用。对于这个程序，这要求改变线程启动函数的参数，使其成为指向包含唯一标识符和循环限制值的结构的指针。运行该程序，将输出重定向到文件中，然后检查文件，查看当内核调度器在两个线程之间交替执行时，*glob*发生了什么变化。
- en: 'Implement a set of thread-safe functions that update and search an unbalanced
    binary tree. This library should include functions (with the obvious purposes)
    of the following form:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一组线程安全的函数，用于更新和搜索一个不平衡的二叉树。这个库应包括以下形式的函数（具有明显的功能）：
- en: '[PRE26]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the above prototypes, *tree* is a structure that points to the root of the
    tree (you will need to define a suitable structure for this purpose). Each element
    of the tree holds a key-value pair. You will also need to define the structure
    for each element to include a mutex that protects that element so that only one
    thread at a time can access it. The *initialize()*, *add()*, and *lookup()* functions
    are relatively simple to implement. The *delete()* operation requires a little
    more effort.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上述原型中，*树*是一种指向树根的结构（你需要为此目的定义一个合适的结构）。树的每个元素都包含一个键值对。你还需要为每个元素定义一个结构，包含一个互斥量来保护该元素，以确保每次只有一个线程能够访问它。*initialize()*、*add()*和*lookup()*函数相对容易实现。*delete()*操作则需要稍微更多的工作。
- en: Note
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Removing the need to maintain a balanced tree greatly simplifies the locking
    requirements of the implementation, but carries the risk that certain patterns
    of input would result in a tree that performs poorly. Maintaining a balanced tree
    necessitates moving nodes between subtrees during the *add()* and *delete()* operations,
    which requires much more complex locking strategies.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不再需要维护平衡树，极大简化了实现中的锁定要求，但也带来了某些输入模式可能导致树性能较差的风险。维护平衡树需要在*add()*和*delete()*操作期间在子树之间移动节点，这需要更复杂的锁定策略。
