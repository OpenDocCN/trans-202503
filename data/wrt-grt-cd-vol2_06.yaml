- en: '**6**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6**'
- en: '**CONSTANTS AND HIGH-LEVEL LANGUAGES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**常量与高级语言**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: 'Some programmers may not realize it, but many CPUs do not treat constant and
    variable data identically at the machine code level. Most CPUs provide a special
    *immediate addressing mode* that allows a language translator to embed a constant
    value directly into a machine instruction rather than storing it in a memory location
    and accessing it as a variable. However, the CPU’s ability to represent constant
    data efficiently varies by CPU and, in fact, by the type of the data. By understanding
    how a CPU treats constant data at the machine code level, you can choose appropriate
    ways to represent constants in your HLL source code to produce smaller and faster
    executable programs. To that end, this chapter discusses the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员可能没有意识到，但许多 CPU 在机器代码级别并不会将常量和变量数据视为相同。大多数 CPU 提供一种特殊的*立即寻址模式*，允许语言翻译器将常量值直接嵌入机器指令中，而不是将其存储在内存位置并作为变量进行访问。然而，CPU
    表示常量数据的能力在不同 CPU 之间有所不同，事实上，甚至不同类型的数据也有差异。通过了解 CPU 如何在机器代码级别处理常量数据，你可以选择合适的方式在高级语言（HLL）源代码中表示常量，从而生成更小、更快的可执行程序。为此，本章将讨论以下主题：
- en: How to use literal constants properly to improve the efficiency of your programs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何正确使用字面常量来提高程序的效率
- en: The difference between a literal constant and a manifest constant
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字面常量和显式常量之间的区别
- en: How compilers process compile-time constant expressions to reduce program size
    and avoid runtime calculations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器如何处理编译时常量表达式，以减少程序大小并避免运行时计算
- en: The difference between a compile-time constant and read-only data kept in memory
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译时常量与存储在内存中的只读数据之间的区别
- en: How compilers represent noninteger constants, such as enumerated data types,
    Boolean data types, floating-point constants, and string constants
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器如何表示非整数常量，如枚举数据类型、布尔数据类型、浮点常量和字符串常量
- en: How compilers represent composite data type constants, such as array constants
    and record/struct constants
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器如何表示复合数据类型常量，如数组常量和记录/结构常量
- en: By the time you finish this chapter, you should have a clear understanding of
    how various constants can affect the efficiency of the machine code your compiler
    produces.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当你读完本章时，你应该清楚了解各种常量如何影响编译器生成的机器代码的效率。
- en: '**NOTE**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’ve already read* WGC1, *you may just want to skim through this chapter,
    which for the sake of completeness repeats some of the information from [Chapters
    6](ch06.xhtml#ch06) and [7](ch07.xhtml#ch07) of that volume.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你已经读过* WGC1，*你可能只想浏览一下本章，完整性考虑它重复了一些[第 6 章](ch06.xhtml#ch06)和[第 7 章](ch07.xhtml#ch07)中的信息。*'
- en: '**6.1 Literal Constants and Program Efficiency**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.1 字面常量与程序效率**'
- en: 'High-level programming languages and most modern CPUs allow you to specify
    constant values just about anywhere you can legally read the value of a memory
    variable. Consider the following Visual Basic and HLA statements, which assign
    the constant `1000` to the variable `i`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 高级编程语言和大多数现代 CPU 允许你在几乎任何可以合法读取内存变量值的地方指定常量值。考虑以下 Visual Basic 和 HLA 语句，它们将常量
    `1000` 赋值给变量 `i`：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The 80x86, like most CPUs, actually encodes the constant representation for
    1,000 directly into the machine instruction. This provides a compact and efficient
    way to work with constants at the machine level. Therefore, statements that use
    literal constants in this manner are often more efficient that those that assign
    constant values to a variable and then reference that variable later in the code.
    Consider the following Visual Basic code sequence:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 与大多数 CPU 一样，实际上将常量值 1,000 直接编码到机器指令中。这提供了一种紧凑且高效的方式在机器级别处理常量。因此，以这种方式使用字面常量的语句通常比那些将常量值赋给变量再在代码中引用该变量的语句更高效。考虑以下
    Visual Basic 代码序列：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now consider the 80x86 assembly code you would probably write for these last
    two statements. For the first statement, we must use two instructions because
    we can’t add the value of one memory location directly to another:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑你可能为这两个语句编写的 80x86 汇编代码。对于第一个语句，我们必须使用两条指令，因为我们不能将一个内存位置的值直接加到另一个内存位置上：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But we can add a constant to a memory location, so the second Visual Basic
    statement translates to a single machine instruction:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以将常量添加到内存位置，因此第二条 Visual Basic 语句会转化为一个单独的机器指令：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, using a literal constant, rather than a variable, is more efficient.
    This is not to suggest, however, that every processor operates more efficiently
    using literal constants, or that every CPU operates more efficiently no matter
    the value of the constant. Some very old CPUs don’t provide the ability to embed
    literal constants within a machine instruction at all; and many RISC processors,
    such as the ARM, do so only for smaller 8-, 12-, or 16-bit constants.^([1](footnotes.xhtml#ch6fn1))
    Even those CPUs that allow you to load any integer constant may not support literal
    floating-point constants—the ubiquitous 80x86 processor being one example. Few
    CPUs provide the ability to encode large data structures (such as an array, record,
    or string) as part of a machine instruction. For example, consider the following
    C code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用字面常量而不是变量更为高效。然而，这并不是说每个处理器在使用字面常量时都更高效，或者每个CPU在无论常量值如何时都更高效。一些非常老旧的CPU根本不支持将字面常量嵌入到机器指令中；而许多RISC处理器，如ARM，只有在较小的8位、12位或16位常量的情况下才支持此操作。^([1](footnotes.xhtml#ch6fn1))
    即便是那些允许加载任何整数常量的CPU，也可能不支持字面浮点常量——例如广泛使用的80x86处理器就是一个例子。很少有CPU提供将大数据结构（如数组、记录或字符串）编码为机器指令一部分的能力。例如，考虑以下C代码：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Its compilation to PowerPC assembly by the GCC compiler looks like this (edited
    to remove the nonrelevant code):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过GCC编译器将其编译为PowerPC汇编代码的过程如下所示（已编辑以去除不相关的代码）：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The PowerPC CPU allows only 16-bit immediate constants in a single instruction.
    In order to load a larger value into a register, the program has to first use
    the `lis` instruction to load the higher-order (HO) 16 bits of a 32-bit register
    and then use the `ori` instruction to merge in the lower-order (LO) 16 bits. The
    exact operation of these instructions isn’t too important. What’s notable is that
    the compiler emits three instructions for large constants, and only two for smaller
    constants. Therefore, using 16-bit constant values on the PowerPC produces shorter
    and faster machine code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: PowerPC CPU在单个指令中仅允许16位立即数常量。为了将更大的值加载到寄存器中，程序必须首先使用`lis`指令将32位寄存器的高16位（HO）加载，然后使用`ori`指令将低16位（LO）合并进来。这些指令的具体操作并不太重要。值得注意的是，编译器对于大常量发出三条指令，而对于较小的常量只发出两条指令。因此，在PowerPC上使用16位常量值会生成更短且更快速的机器代码。
- en: 'The compilation of this C code to ARMv7 assembly by the GCC compiler looks
    like this (edited to remove the nonrelevant code):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过GCC编译器将此C代码编译为ARMv7汇编代码的过程如下所示（已编辑以去除不相关的代码）：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The ARM CPU allows only 16-bit immediate constants in a single instruction.
    In order to load a larger value into a register, the compiler places the constant
    into a memory location and loads the constant from memory.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ARM CPU在单个指令中仅允许16位立即数常量。为了将更大的值加载到寄存器中，编译器将常量放置到内存位置，并从内存中加载常量。
- en: 'Even though CISC processors like the 80x86 can usually encode any integer constant
    (up to 32 bits) in a single instruction, this doesn’t mean that the program’s
    efficiency is independent of the sizes of the constants you use in your programs.
    CISC processors often use different encodings for machine instructions that have
    large or small immediate operands, allowing the program to use less memory for
    smaller constants. For example, consider the following two 80x86/HLA machine instructions:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 即便像80x86这样的CISC处理器通常可以在单条指令中编码任何整数常量（最多32位），这并不意味着程序的效率与程序中使用的常量大小无关。CISC处理器通常对具有大或小立即操作数的机器指令使用不同的编码方式，从而使程序在处理较小常量时能使用更少的内存。例如，考虑以下两个80x86/HLA机器指令：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On the 80x86 an assembler can encode the first instruction in 3 bytes: 2 bytes
    for the opcode and addressing mode information, and 1 byte to hold the small immediate
    constant `5`. The second instruction, on the other hand, requires 6 bytes to encode:
    2 bytes for the opcode and addressing mode information, and 4 bytes to hold the
    constant `500_000`. Certainly the second instruction is larger, and in some cases
    it may even run a little slower.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在80x86上，汇编器可以用3个字节来编码第一条指令：2个字节用于操作码和寻址模式信息，1个字节用于保存小的立即常量`5`。另一方面，第二条指令需要6个字节来编码：2个字节用于操作码和寻址模式信息，4个字节用于保存常量`500_000`。显然，第二条指令更大，在某些情况下，它甚至可能运行得稍微慢一些。
- en: '**6.2 Binding Times**'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.2 绑定时间**'
- en: 'What exactly is a constant? Obviously, from an HLL perspective, a constant
    is some sort of entity whose value doesn’t change (that is, remains constant).
    However, there is more to the definition. For example, consider the following
    Pascal constant declaration:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 常量究竟是什么？显然，从高级语言（HLL）的角度来看，常量是某种值不变的实体（即保持恒定）。然而，定义中还有更多内容。例如，考虑以下 Pascal 常量声明：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the code following this declaration,^([2](footnotes.xhtml#ch6fn2)) you can
    use the name someConstant in place of the value `5`. But what about before this
    declaration? How about outside the scope to which this declaration belongs? Clearly
    the value of someConstant can change upon the compiler processing this declaration.
    So the notion that a constant’s “value doesn’t change” doesn’t exactly apply here.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在此声明后的代码中，^([2](footnotes.xhtml#ch6fn2)) 你可以用名字 someConstant 替代值 `5`。但在此声明之前呢？在这个声明所属的作用域之外呢？显然，someConstant
    的值会随着编译器处理这个声明而变化。所以，常量的“值不变”这一概念在这里并不完全适用。
- en: 'The real concern here isn’t *where* the program associates a value with someConstant
    but *when*. *Binding* is the technical name for creating associations between
    attributes (such as the name, value, and scope) of some object. For example, the
    earlier Pascal example binds the value `5` to the name someConstant. *Binding
    time*—when the binding (association) occurs—can happen at several different points:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里真正关注的不是程序将值与 someConstant 关联的*位置*，而是*时间*。*绑定* 是创建某个对象的属性（如名字、值和作用域）之间关联的技术术语。例如，之前的
    Pascal 示例将值 `5` 绑定到名字 someConstant。*绑定时间*——即绑定（关联）发生的时间——可以在多个不同的时刻发生：
- en: '*At language definition time.* This refers to when the language designer(s)
    define the language. The constants `true` and `false` in many languages are good
    examples.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在语言定义时。* 这指的是语言设计者定义语言的时间。许多语言中的常量 `true` 和 `false` 就是很好的例子。'
- en: '*During compilation.* The Pascal someConstant declaration in this section is
    a good example.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在编译期间。* 本节中的 Pascal someConstant 声明就是一个很好的例子。'
- en: '*During the linking phase.* An example of this might be a constant that specifies
    the size of the object code (machine instructions) in a program. The program cannot
    compute this size any earlier than during the link phase, when the linker pulls
    in all the object code modules and combines them together.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在链接阶段。* 一个示例可能是指定程序中对象代码（机器指令）大小的常量。程序不能在链接阶段之前计算这个大小，因为链接器会将所有对象代码模块提取并合并在一起。'
- en: '*During program loading (into memory).* A good example of load time binding
    would be associating the address of an object in memory (such as a variable or
    machine instruction) with some pointer constant. On many systems, the operating
    system relocates the code when it loads it into memory, so the program can only
    determine absolute memory addresses after loading.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*程序加载（到内存）时。* 一个好的加载时绑定示例是将内存中某个对象的地址（例如变量或机器指令）与某个指针常量关联起来。在许多系统中，操作系统在加载代码到内存时会进行重定位，因此程序只能在加载后确定绝对内存地址。'
- en: '*During program execution.* Some bindings can occur only while the program
    is running. For example, when you assign the value of some (computed) arithmetic
    expression to a variable, the binding of the value to the variable occurs during
    execution.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*程序执行期间。* 有些绑定只能在程序运行时发生。例如，当你将某个（计算出的）算术表达式的值赋给一个变量时，值与变量的绑定发生在执行期间。'
- en: '*Dynamic bindings* are those that occur during program execution. *Static bindings*
    are those that occur at any other time. [Chapter 7](ch07.xhtml#ch07) will take
    another look at binding (see “What Is a Variable?” on [page 180](ch07.xhtml#page_180)).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态绑定* 是指在程序执行期间发生的绑定。*静态绑定* 是指在其他任何时间发生的绑定。[第7章](ch07.xhtml#ch07)将再次讨论绑定（参见《什么是变量？》在[第180页](ch07.xhtml#page_180)）。'
- en: '**6.3 Literal Constants vs. Manifest Constants**'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.3 字面常量与显式常量**'
- en: A *manifest constant* is a constant value associated with—that is, bound to—a
    symbolic name. A language translator can directly substitute the value everywhere
    the name appears within the source code, producing easy-to-read and easily maintained
    programs. The proper use of manifest constants is a good indication of professionally
    written code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*显式常量* 是与符号名称相关联（即绑定到符号名称）的常量值。语言翻译器可以在源代码中每次出现该名称时直接替换该值，从而生成易于阅读和维护的程序。正确使用显式常量是专业编写代码的良好标志。'
- en: 'Declaring manifest constants is simple in many programming languages:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多编程语言中，声明显式常量非常简单：
- en: Pascal programmers use the `const` section.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pascal 程序员使用 `const` 区域。
- en: HLA programmers can use the `const` or the `val` declaration sections.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HLA 程序员可以使用 `const` 或 `val` 声明区块。
- en: C/C++ programmers can use the `#define` macro facility.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C/C++ 程序员可以使用 `#define` 宏功能。
- en: 'This Pascal code fragment demonstrates an appropriate use of manifest constants
    in a program:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Pascal 代码片段展示了在程序中正确使用显式常量的例子：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code is much easier to read and maintain than code that uses literal constants.
    By changing a single statement in this program (the `maxIndex` constant declaration)
    and recompiling the source file, you can easily set the number of elements and
    the program will continue to function properly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码比使用文字常量的代码更易读和维护。通过更改此程序中的单一语句（`maxIndex` 常量声明）并重新编译源文件，你可以轻松设置元素的数量，并且程序将继续正常运行。
- en: Because the compiler substitutes the literal numeric constant in place of the
    symbolic name for the manifest constant, there is no performance penalty for using
    manifest constants. Given that they improve the readability of your programs without
    any loss in efficiency, manifest constants are an important component of great
    code. Use them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译器将文字常量替换为显式常量的符号名称，因此使用显式常量不会带来性能损失。鉴于它们能够在不损失效率的情况下提高程序的可读性，显式常量是优秀代码的重要组成部分。请使用它们。
- en: '**6.4 Constant Expressions**'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.4 常量表达式**'
- en: Many compilers support the use of *constant expressions*, which are expressions
    that can be evaluated during compilation. The component values of a constant expression
    are all known at compile time, so the compiler can evaluate the expression and
    substitute its value during compilation rather than computing it at runtime. As
    with manifest constants, constant expressions enable you to write more easily
    readable and maintainable code, without any runtime efficiency loss.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编译器支持使用 *常量表达式*，即那些可以在编译时计算的表达式。常量表达式的组成值在编译时就已知，因此编译器可以在编译时计算表达式并替代其值，而不是在运行时计算它。像显式常量一样，常量表达式使你能够编写更易于阅读和维护的代码，而不会带来任何运行时效率损失。
- en: 'For example, consider the following C code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下 C 代码：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'These two array declarations expand to the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个数组声明扩展为以下内容：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The C preprocessor further expands this to:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: C 预处理器进一步将其扩展为：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Although the C language definition supports constant expressions, this feature
    is not available in every language, so you’ll need to check the language reference
    manual for your particular compiler. The Pascal language definition, for example,
    says nothing about constant expressions. Some Pascal implementations support them,
    but others do not.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 C 语言定义支持常量表达式，但并非所有语言都支持此特性，因此你需要查看特定编译器的语言参考手册。例如，Pascal 语言定义并未提及常量表达式。一些
    Pascal 实现支持它们，但其他一些则不支持。
- en: 'Modern optimizing compilers are capable of computing constant subexpressions
    within arithmetic expressions at compile time (known as *constant folding*; see
    “Common Compiler Optimizations” on [page 63](ch04.xhtml#page_63)), thereby saving
    the expense of computing fixed values at runtime. Consider the following Pascal
    code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现代优化编译器能够在编译时计算算术表达式中的常量子表达式（称为 *常量折叠*；详见 [第 63 页](ch04.xhtml#page_63)的“常见编译器优化”），从而节省了在运行时计算固定值的开销。考虑以下
    Pascal 代码：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Any decent Pascal implementation will recognize that the subexpression `5*2–3`
    is a constant expression, compute the value for this expression (`7`) during compilation,
    and substitute that value at compile time. In other words, a good Pascal compiler
    generally emits machine code that is equivalent to the following statement:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 任何一个合格的 Pascal 实现都能够识别子表达式 `5*2–3` 是一个常量表达式，在编译期间计算这个表达式的值（`7`），并在编译时用该值替代。换句话说，一个优秀的
    Pascal 编译器通常会生成等同于以下语句的机器代码：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If your particular compiler fully supports constant expressions, you can use
    this feature to write better source code. It may seem paradoxical, but writing
    out a full expression at some point in your program can sometimes make that particular
    piece of code easier to read and understand; someone reading your code can see
    exactly how you calculated a value, rather than having to figure out how you arrived
    at some “magic” number. For example, in the context of an invoicing or timesheet
    routine, the expression `5*2–3` might describe the computation “two persons working
    for five hours, minus three person-hours provided for the job” better than the
    literal constant `7`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的编译器完全支持常量表达式，你可以利用这个特性来编写更好的源代码。可能看起来有些矛盾，但在程序的某些地方写出完整的表达式，有时会使那部分代码更容易阅读和理解；阅读代码的人可以准确看到你如何计算一个值，而不必弄清楚你是如何得出某个“魔法”数字的。例如，在发票或工时单的计算中，表达式`5*2–3`可能比字面常量`7`更能描述“两个工人工作五小时，减去三小时工时”的计算过程。
- en: 'The following sample C code, and the PowerPC output produced by the GCC compiler,
    demonstrates constant expression optimization in action:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例C代码及GCC编译器生成的PowerPC输出展示了常量表达式优化的实际情况：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here’s the GCC output (PowerPC assembly language):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是GCC的输出（PowerPC汇编语言）：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, GCC has replaced the constant expression `2*5+1` with the constant
    `11`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，GCC将常量表达式`2*5+1`替换为了常量`11`。
- en: Making your code more readable is definitely a good thing to do and a major
    part of writing great code. Keep in mind, however, that some compilers may not
    support the use of constant expressions, instead emitting code to compute the
    constant value at runtime. Obviously, this will affect the size and execution
    speed of your resulting program. Knowing what your compiler can do will help you
    decide whether to use constant expressions or precompute expressions to increase
    efficiency at the cost of readability.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使你的代码更具可读性无疑是做得很好的事情，也是编写优秀代码的一个重要部分。然而，请记住，一些编译器可能不支持常量表达式的使用，而是会生成代码，在运行时计算常量值。显然，这会影响你程序的大小和执行速度。了解你的编译器能够做什么，将帮助你决定是否使用常量表达式，或者为了提高效率而以牺牲可读性为代价预计算表达式。
- en: '**6.5 Manifest Constants vs. Read-Only Memory Objects**'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.5 显式常量与只读内存对象**'
- en: C/C++ programmers may have noticed that the previous section did not discuss
    the use of the C/C++ `const` declaration. This is because symbolic names (hereafter
    *symbols*) you declare in a C/C++ `const` statement aren’t necessarily manifest
    constants. That is, C/C++ does not always substitute the value for a symbol wherever
    it appears in a source file. Instead, a C/C++ compiler might store that `const`
    value in memory and then reference the `const` object as it would a static (read-only)
    variable. The only difference, then, between that `const` object and a static
    variable is that the C/C++ compiler doesn’t allow you to assign a value to `const`
    at runtime.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++程序员可能注意到，上一节没有讨论C/C++ `const`声明的使用。这是因为你在C/C++ `const`语句中声明的符号名（以下简称*符号*）不一定是显式常量。也就是说，C/C++并不总是在源文件中每次出现符号时都替换它的值。相反，C/C++编译器可能将该`const`值存储在内存中，然后像引用静态（只读）变量一样引用该`const`对象。这样，`const`对象和静态变量之间唯一的区别是，C/C++编译器不允许你在运行时给`const`赋值。
- en: C/C++ sometimes treats constants you declare in `const` statements as static
    variables for a very good reason—it allows you to create within a function local
    constants whose value can change each time that function executes (although while
    the function is executing, the value remains fixed). This is why you can’t always
    use such a “constant” within a `const` in C/C++ and expect the C/C++ compiler
    to precompute its value.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++有时会将你在`const`语句中声明的常量当作静态变量处理，这是有充分理由的——它允许你在函数内创建局部常量，且这些常量的值可以在每次函数执行时变化（尽管在函数执行过程中，值保持不变）。这就是为什么你不能总是在C/C++的`const`中使用这样的“常量”，并期望C/C++编译器预计算它的值。
- en: 'Most C++ compilers will accept this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数C++编译器会接受这个：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'They will not, however, accept this sequence:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，他们不会接受这个序列：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`arraySize` and `arraySizes` are both constants. Yet the C++ compiler won’t
    allow you to use the `arraySizes` constant, or anything based on it, as an array
    bound. This is because `arraySizes[0]` is actually a runtime memory location and,
    therefore, `arraySize` must also be a runtime memory location. In theory, you’d
    think the compiler would be smart enough to figure out that `arraySize` is computable
    at compile time and just substitute that value (`128`). The C++ language, however,
    doesn’t allow this.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`arraySize` 和 `arraySizes` 都是常量。然而，C++ 编译器不允许你使用 `arraySizes` 常量，或者基于它的任何内容作为数组边界。这是因为
    `arraySizes[0]` 实际上是一个运行时内存位置，因此 `arraySize` 也必须是一个运行时内存位置。理论上，你可能认为编译器会足够智能，能够推断出
    `arraySize` 在编译时是可以计算的，并将其值（`128`）直接替代。然而，C++ 语言并不允许这么做。'
- en: '**6.6 Swift let Statements**'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.6 Swift let 语句**'
- en: 'In the Swift programming language, you can create constants using the `let`
    statement. For example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 编程语言中，你可以使用 `let` 语句来创建常量。例如：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: However, the value is bound to the constant’s name at runtime (that is, this
    is a dynamic binding). The expression on the right-hand side of the assignment
    operator (`=`) doesn’t have to be a constant expression; it can be an arbitrary
    expression involving variables and other nonconstant components. Every time the
    program executes this statement (such as in a loop), the program could bind a
    different value to someConstant.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，该值在运行时绑定到常量的名称（也就是说，这是一个动态绑定）。赋值运算符（`=`）右侧的表达式不一定是常量表达式；它可以是包含变量和其他非常量组件的任意表达式。每次程序执行此语句时（例如在循环中），程序可能会为
    `someConstant` 绑定一个不同的值。
- en: The Swift `let` statement doesn’t truly define constants in the traditional
    sense; rather, it lets you create “write-once” variables. In other words, within
    the scope of the symbol you define using the `let` statement, you can initialize
    the name with a value only once. Note that if you leave and re-enter the name’s
    scope, the value is destroyed (upon exiting the scope) and you can bind a new
    (possibly different) value to the name upon re-entering the scope. Unlike, say,
    the `const int` declaration in C++, `let` statements do not allow you to allocate
    storage for the object in read-only memory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 的 `let` 语句并不真正定义常量，至少不像传统意义上的常量那样；它允许你创建“只写”变量。换句话说，在你使用 `let` 语句定义的符号的作用域内，你只能初始化该名称一次。请注意，如果你离开并重新进入该名称的作用域，值会被销毁（在退出作用域时），并且你可以在重新进入作用域时为该名称绑定一个新的（可能不同的）值。与
    C++ 中的 `const int` 声明不同，`let` 语句不允许你在只读内存中为对象分配存储空间。
- en: '**6.7 Enumerated Types**'
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.7 枚举类型**'
- en: Well-written programs often use a set of names to represent real-world quantities
    that don’t have an explicit numeric representation. An example of such a set of
    names might be various display technologies, like `crt`, `lcd`, `led`, and `plasma`.
    Even though the real world doesn’t associate numeric values with these concepts,
    you must encode the values numerically if you’re going to efficiently represent
    them in a computer system. The internal representation for each symbol is generally
    arbitrary, as long as the value we assign is unique. Many computer languages provide
    an *enumerated data type* that automatically associates a unique value with each
    name in a list. By using enumerated data types in your programs, you can assign
    meaningful names to your data rather than using “magic” numbers such as 0, 1,
    2, and so on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 编写良好的程序通常使用一组名称来表示没有明确数值表示的现实世界量。例如，这样一组名称可能是各种显示技术，如 `crt`、`lcd`、`led` 和 `plasma`。尽管现实世界并未将数值与这些概念关联，但如果你希望在计算机系统中高效地表示它们，你必须将这些值编码为数字。每个符号的内部表示通常是任意的，只要我们分配的值是唯一的。许多计算机语言提供了
    *枚举数据类型*，它自动将唯一的值与列表中的每个名称关联起来。通过在程序中使用枚举数据类型，你可以为数据分配有意义的名称，而不是使用类似 0、1、2 等“魔法数字”。
- en: 'For example, in early versions of the C language, you would create a sequence
    of identifiers, each with a unique value, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 C 语言的早期版本中，你会按照以下方式创建一系列唯一值的标识符：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By assigning values that are consecutive, you ensure that each is unique. Another
    advantage to this approach is that it orders the values. That is, `crt` < `lcd`
    < `led` < `plasma`. Unfortunately, creating manifest constants this way is laborious
    and error-prone.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分配连续的值，你可以确保每个值都是唯一的。这个方法的另一个优点是它对值进行了排序。也就是说，`crt` < `lcd` < `led` < `plasma`。不幸的是，这种方式创建显式常量既繁琐又容易出错。
- en: Fortunately, in most languages enumerated constants can solve this problem.
    To “enumerate” means to number, and this is exactly what the compiler does—it
    numbers each constant, thereby handling the bookkeeping details of assigning values
    to enumerated constants.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，大多数语言的枚举常量可以解决这个问题。 “枚举”意味着编号，这正是编译器所做的——它为每个常量编号，从而处理分配值给枚举常量的记录细节。
- en: 'Most modern programming languages provide support for declaring enumerated
    types and constants. Here are some examples from C/C++, Pascal, Swift, and HLA:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代编程语言都提供了声明枚举类型和常量的支持。以下是来自 C/C++、Pascal、Swift 和 HLA 的一些示例：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These four examples internally associate 0 with `crt`, 1 with `lcd`, 2 with
    `led`, 3 with `plasma`, and 4 with `oled`. Again, the exact internal representation
    is irrelevant (as long as each value is unique) because the value’s only purpose
    is to differentiate the enumerated objects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个示例内部将 `0` 与 `crt` 关联，`1` 与 `lcd`，`2` 与 `led`，`3` 与 `plasma`，`4` 与 `oled`。同样，确切的内部表示无关紧要（只要每个值都是唯一的），因为该值的唯一目的是区分枚举对象。
- en: 'Most languages assign *monotonically increasing* values (that is, each successive
    value is greater than all previous values) to symbols in an enumerated list. Therefore,
    these examples have the following relationships:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言会为枚举列表中的符号分配*单调递增*的值（即每个后续值都大于所有前面的值）。因此，这些示例具有以下关系：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Don’t let this give you the impression that all enumerated constants appearing
    in a single program have a unique internal representation, though. Most compilers
    assign a value of `0` to the first item in an enumeration list you create, a value
    of `1` to the second, and so on. For example, consider the following Pascal type
    declarations:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让这个给你留下这样一种印象：单个程序中出现的所有枚举常量都有唯一的内部表示。大多数编译器会将枚举列表中的第一个项分配值 `0`，第二个项分配值 `1`，以此类推。例如，考虑以下
    Pascal 类型声明：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Most Pascal compilers would use the value `0` as the internal representation
    for both `red` and `bolt`; `1` for `green` and `nut`; and so on. In languages
    (like Pascal and Swift) that enforce type checking, you generally can’t use symbols
    of type `colors` and `fasteners` in the same expression. Therefore, the fact that
    these symbols share the same internal representation isn’t an issue because the
    compiler’s type-checking facilities preclude any possible confusion. Some languages,
    like C/C++ and assembly, do not provide strong type checking, however, and so
    this kind of confusion can occur. In those languages, it is the programmer’s responsibility
    to avoid mixing different types of enumeration constants.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Pascal 编译器会将 `0` 作为 `red` 和 `bolt` 的内部表示；将 `1` 用于 `green` 和 `nut`；以此类推。在一些强制进行类型检查的语言（如
    Pascal 和 Swift）中，通常不能在同一表达式中使用类型为 `colors` 和 `fasteners` 的符号。因此，这些符号共享相同的内部表示并不是问题，因为编译器的类型检查机制会防止任何可能的混淆。然而，一些语言（如
    C/C++ 和汇编语言）并不提供强类型检查，因此可能会发生这种混淆。在这些语言中，避免混用不同类型的枚举常量是程序员的责任。
- en: Most compilers allocate the smallest unit of memory the CPU can efficiently
    access in order to represent an enumerated type. Because most enumerated type
    declarations define fewer than 256 symbols, compilers on machines that can efficiently
    access byte data will usually allocate a byte for any variable with an enumerated
    data type. Compilers on many RISC machines can allocate a 32-bit word (or more)
    simply because it’s faster to access such blocks of data. The exact representation
    is language and compiler/implementation dependent, so check your compiler’s reference
    manual for the details.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编译器会分配 CPU 可以高效访问的最小内存单元来表示枚举类型。由于大多数枚举类型声明定义的符号少于 256 个，因此在能够高效访问字节数据的机器上，编译器通常会为任何具有枚举数据类型的变量分配一个字节。许多
    RISC 机器上的编译器可以分配一个 32 位字（或更多），因为访问这些数据块更快。确切的表示方法依赖于语言和编译器/实现，因此请查阅编译器的参考手册以获取详细信息。
- en: '**6.8 Boolean Constants**'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.8 布尔常量**'
- en: Many high-level programming languages provide *Boolean*, or *logical*, constants
    to represent the values `true` and `false`. Because there are only two possible
    Boolean values, their representation requires only a single bit. However, because
    most CPUs do not allow you to allocate a single bit of storage, most programming
    languages use a whole byte or even a larger object to represent a Boolean value.
    What happens to any leftover bits in a Boolean object? Unfortunately, the answer
    varies by language.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 许多高级编程语言提供*布尔*或*逻辑*常量来表示`true`和`false`的值。因为布尔值只有两个可能的值，所以它们的表示只需要一个位。然而，由于大多数CPU不允许你分配单个位的存储空间，大多数编程语言使用整个字节甚至更大的对象来表示布尔值。那么，布尔对象中剩余的位会怎样呢？不幸的是，答案因语言而异。
- en: 'Many languages treat the Boolean data type as an enumerated type. For example,
    in Pascal, the Boolean type is defined this way:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言将布尔数据类型视为枚举类型。例如，在Pascal中，布尔类型定义如下：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This declaration associates the internal value `0` with `false` and `1` with
    `true`. This association has a couple of desirable attributes:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种声明将内部值`0`与`false`关联，将`1`与`true`关联。这个关联具有一些理想的属性：
- en: Most of the Boolean functions and operators behave as expected—for example,
    (`true` and `true`) = `true`, (`true` and `false`) = `false`, and so on.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数布尔函数和运算符按预期工作——例如，(`true` 和 `true`) = `true`，(`true` 和 `false`) = `false`，等等。
- en: When you compare the two values, `false` is less than `true`—an intuitive result.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你比较这两个值时，`false`小于`true`——这是一个直观的结果。
- en: 'Unfortunately, associating `0` with `false` and `1` with `true` isn’t always
    the best solution. Here are some reasons why:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，将`0`与`false`，`1`与`true`关联并不总是最佳的解决方案。以下是一些原因：
- en: Certain Boolean operations, applied to a bit string, do not produce expected
    results. For example, you might expect (not `false`) to be equal to `true`. However,
    if you store a Boolean variable in an 8-bit object, then (not `false`) is equal
    to `$FF`, which is not equal to `true` (`1`).
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些布尔运算应用于位串时，不会产生预期的结果。例如，你可能期望（not `false`）等于`true`。然而，如果你将布尔变量存储在8位对象中，那么（not
    `false`）的结果是`$FF`，这不等于`true`（`1`）。
- en: Many CPUs provide instructions that easily test for `0` or nonzero after an
    operation; few CPUs provide an implicit test for `1`.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多CPU提供指令，可以在操作后轻松检测`0`或非零；很少有CPU提供隐式的`1`检测。
- en: 'Many languages, such as C, C++, C#, and Java, treat `0` as `false` and anything
    else as `true`. This has a couple of advantages:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言，如C、C++、C#和Java，将`0`视为`false`，其他任何值视为`true`。这样做有几个优点：
- en: CPUs that provide easy checks for `0` and nonzero can easily test a Boolean
    result.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供简便的`0`和非零检查的CPU可以轻松测试布尔结果。
- en: The `0`/nonzero representation is valid regardless of the size of the object
    holding a Boolean variable.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`/非零表示法无论布尔变量存储对象的大小如何，都有效。'
- en: 'Unfortunately, this scheme also has some drawbacks:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种方案也有一些缺点：
- en: Many bitwise logical operations produce incorrect results when applied to `0`
    and nonzero Boolean values. For example `$A5` (`true`/nonzero) AND `$5A` (`true`/nonzero)
    is equal to `0` (`false`). Logically ANDing `true` and `true` should not produce
    `false`. Similarly, (NOT `$A5`) produces `$5A`. Generally, you’d expect (NOT `true`)
    to produce `false` rather than `true` (`$5A`).
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多按位逻辑运算在应用于`0`和非零布尔值时会产生不正确的结果。例如，`$A5`（`true`/非零）与`$5A`（`true`/非零）进行与运算结果为`0`（`false`）。按逻辑与运算，`true`和`true`不应该产生`false`。类似地，（NOT
    `$A5`）结果是`$5A`。通常，你会期望（NOT `true`）应该产生`false`而不是`true`（`$5A`）。
- en: When a bit string is treated as a two’s-complement signed-integer value, it’s
    possible for certain values of `true` to be less than zero (for example, the 8-bit
    value `$FF` is equivalent to `-1`). So, in some cases, the intuitive result that
    `false` is less than `true` may not be correct.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当位串被当作二进制补码有符号整数值处理时，某些`true`的值可能小于零（例如，8位值`$FF`等于`-1`）。因此，在某些情况下，`false`小于`true`的直观结果可能不正确。
- en: Unless you are working in assembly language (where you get to define the values
    for `true` and `false`), you’ll have to live with whatever scheme your HLL uses
    to represent Boolean values, as explained in its language reference manual.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你在汇编语言中工作（在这种情况下，你可以定义`true`和`false`的值），否则你必须接受高级语言（HLL）中表示布尔值的方案，正如它在语言参考手册中所解释的那样。
- en: 'Knowing how your language represents `true` and `false` can help you write
    high-level source code that produces better machine code. For example, suppose
    you are writing C/C++ code. In these languages, `false` is `0` and `true` is anything
    else. Consider the following statement in C:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 了解你的编程语言如何表示`true`和`false`，可以帮助你编写出生成更好机器代码的高级源代码。例如，假设你正在编写C/C++代码。在这些语言中，`false`是`0`，`true`是其他任何值。考虑下面的C语言语句：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The machine code produced for this assignment statement by many compilers is
    absolutely horrid. It often looks like the following (Visual C++ output):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编译器为这个赋值语句生成的机器代码是非常糟糕的。它通常看起来像下面这样（Visual C++输出）：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, suppose that you always ensure that you use the values `0` for `false`
    and `1` for `true` (with no possibility of any other value). Under these conditions,
    you could write the previous statement this way:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你始终确保使用`0`表示`false`，使用`1`表示`true`（且不允许使用其他值）。在这种条件下，你可以将之前的语句写成这样：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here’s the code that Visual C++ generates for the preceding statement:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Visual C++为前述语句生成的代码：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, this code is significantly better. Provided that you always
    use `1` for `true` and `0` for `false`, you can get away with using the bitwise
    AND (`&`) and OR (`|`) operators in place of the logical operators.^([3](footnotes.xhtml#ch6fn3))
    As noted earlier, you can’t get consistent results using the bitwise NOT operator;
    you can, however, do the following to produce correct results for a logical NOT
    operation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这段代码显著更好。只要你始终使用`1`表示`true`，`0`表示`false`，你就可以使用按位与（`&`）和按位或（`|`）操作符代替逻辑运算符。^([3](footnotes.xhtml#ch6fn3))
    如前所述，使用按位取反操作符无法得到一致的结果；但是，你可以通过以下方式实现正确的逻辑非操作：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This short sequence inverts all the bits in `j` and then clears all bits except
    bit 0.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的代码片段会反转`j`中的所有位，然后清除除第0位以外的所有位。
- en: The bottom line is that you should be intimately aware of how your particular
    compiler represents Boolean constants. If you’re given a choice (such as any nonzero
    value), then you can pick appropriate values for `true` and `false` to help your
    compiler emit better code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，你应该非常清楚你的编译器如何表示布尔常量。如果你有选择权（例如任何非零值），那么你可以为`true`和`false`选择适当的值，以帮助你的编译器生成更好的代码。
- en: '**6.9 Floating-Point Constants**'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.9 浮点常量**'
- en: 'Floating-point constants are special cases on most computer architectures.
    Because floating-point representations can consume a large number of bits, few
    CPUs provide an immediate addressing mode to load an arbitrary constant into a
    floating-point register. This is true even for small (32-bit) floating-point constants.
    It is even true on many CISC processors such as the 80x86\. Therefore, compilers
    often have to place floating-point constants in memory and then have the program
    read them from memory, just as though they were variables. Consider, for example,
    the following C program:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点常量在大多数计算机架构中是特殊情况。因为浮点表示可能会消耗大量位数，很少有CPU提供立即寻址模式来将任意常量加载到浮点寄存器中。即使是小的（32位）浮点常量也是如此。即使是在许多CISC处理器上，如80x86，也是如此。因此，编译器通常需要将浮点常量放置在内存中，然后让程序从内存中读取它们，就像它们是变量一样。例如，考虑以下C程序：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now consider the PowerPC code that GCC generates for this program with the
    `-O2` option:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑GCC为这个程序使用`-O2`选项生成的PowerPC代码：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Because the PowerPC processor is a RISC CPU, the code that GCC generates for
    this simple sequence is rather convoluted. For comparison with a CISC equivalent,
    consider the following HLA code for the 80x86; it is a line-by-line translation
    of the C code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PowerPC处理器是一个RISC CPU，GCC为这个简单的代码序列生成的代码相当复杂。为了与CISC等效代码进行对比，请看下面的80x86的HLA代码；它是C代码逐行翻译的结果：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This code is much easier to follow than the PowerPC code (this is one advantage
    of CISC code over RISC code). Note that like the PowerPC, the 80x86 does not support
    an immediate addressing mode for most floating-point operands. Therefore, as on
    the PowerPC, you have to place a copy of the constant `1.0` in some memory location
    and access that memory location whenever you want to work with the value `1.0`.^([4](footnotes.xhtml#ch6fn4))
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码比PowerPC代码更容易理解（这是CISC代码优于RISC代码的一个优势）。注意，和PowerPC一样，80x86不支持大多数浮点操作数的立即寻址模式。因此，和PowerPC一样，你必须将常量`1.0`的副本放置在某个内存位置，并在需要使用`1.0`的值时访问该内存位置。^([4](footnotes.xhtml#ch6fn4))
- en: Because most modern CPUs do not support an immediate addressing mode for all
    floating-point constants, using such constants in your programs is equivalent
    to accessing variables initialized with those constants. Don’t forget that accessing
    memory can be very slow if the locations you’re referencing are not in the data
    cache. Accordingly, using floating-point constants can be very slow compared with
    accessing integer or other constant values that fit within a register.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因为大多数现代CPU不支持对所有浮点常量使用立即寻址模式，所以在程序中使用这些常量等同于访问用这些常量初始化的变量。别忘了，如果你访问的内存位置不在数据缓存中，访问内存可能会非常慢。因此，使用浮点常量可能比访问适合寄存器的整数或其他常量值慢得多。
- en: Note that some CPUs do allow you to encode certain floating-point immediate
    constants as part of the instruction’s opcode. The 80x86, for example, has a special
    “load zero” instruction that loads `0.0` onto the floating-point stack. The ARM
    processor also provides an instruction that allows you to load certain floating-point
    constants into a CPU floating-point register (see “The `vmov` Instructions” in
    Appendix C online).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一些CPU确实允许将某些浮点立即常量编码为指令的操作码的一部分。例如，80x86处理器有一个特殊的“加载零”指令，它将`0.0`加载到浮点栈中。ARM处理器也提供了一条指令，允许将某些浮点常量加载到CPU浮点寄存器中（请参阅附录C在线中的“`vmov`指令”）。
- en: 'On 32-bit processors, a CPU can often do simple 32-bit floating-point operations
    using integer registers and the immediate addressing mode. For example, you can
    easily assign a 32-bit single-precision floating-point value to a variable by
    loading a 32-bit integer register with the bit pattern for that number and then
    storing the integer register into the floating-point variable. Consider the following
    code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在32位处理器上，CPU通常可以使用整数寄存器和立即寻址模式执行简单的32位浮点运算。例如，你可以通过加载一个32位整数寄存器，将该数值的比特模式加载进去，然后将整数寄存器存储到浮点变量中，从而轻松地将一个32位单精度浮点值赋给变量。考虑以下代码：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here’s the PowerPC code that GCC generates for this sequence:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是GCC为此序列生成的PowerPC代码：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The 80x86, being a CISC processor, makes this task trivial in assembly language.
    Here’s the HLA code that does the same job:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 作为CISC处理器，80x86使得在汇编语言中执行此任务变得非常简单。下面是实现相同功能的HLA代码：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Simple assignments of single-precision floating-point constants to floating-point
    variables can often use a CPU’s immediate addressing mode, sparing the program
    the expense of accessing memory (whose data might not be in the cache). Unfortunately,
    compilers don’t always take advantage of this trick for assigning a floating-point
    constant to a double-precision variable. GCC on the PowerPC or ARM, for example,
    reverts to keeping a copy of the constant in memory and copying that memory location’s
    value when assigning the constant to a floating-point variable.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将单精度浮点常量简单地赋值给浮点变量通常可以利用CPU的立即寻址模式，从而节省访问内存的开销（因为内存中的数据可能不在缓存中）。不幸的是，编译器并不总是利用这种技巧将浮点常量赋值给双精度变量。例如，PowerPC或ARM上的GCC会退回到将常量保存在内存中，并在将常量赋值给浮点变量时复制该内存位置的值。
- en: Most optimizing compilers are smart enough to maintain a table of constants
    they’ve created in memory. Therefore, if you reference the constant `2.0` (or
    any other floating-point constant) multiple times in your source file, the compiler
    will allocate only one memory object for that constant. Keep in mind, however,
    that this optimization works only within the same source file. If you reference
    the same constant value but in different source files, the compiler will probably
    create multiple copies of that constant.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数优化编译器足够智能，能够在内存中维护它们创建的常量表。因此，如果你在源文件中多次引用常量`2.0`（或任何其他浮点常量），编译器只会为该常量分配一个内存对象。然而，请记住，这种优化仅在同一个源文件内有效。如果你在不同的源文件中引用相同的常量值，编译器可能会为该常量创建多个副本。
- en: It’s certainly true that having multiple copies of the data wastes storage,
    but given the amount of memory in most modern systems, that’s a minor concern.
    A bigger problem is that the program usually accesses these constants in a random
    fashion, so they’re rarely sitting in cache and, in fact, they often evict some
    other more frequently used data from cache.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，拥有多个数据副本会浪费存储空间，但考虑到大多数现代系统的内存容量，这只是一个小问题。更大的问题是，程序通常以随机方式访问这些常量，因此它们很少驻留在缓存中，实际上，它们往往会将其他更常用的数据从缓存中逐出。
- en: 'One solution to this problem is to manage the floating-point “constants” yourself.
    Because these constants are effectively variables as far as the program is concerned,
    you can take charge of this process and place the floating-point constants you’ll
    need in initialized static variables. For example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个方法是自己管理浮动点“常量”。因为就程序而言，这些常量实际上是变量，你可以负责这个过程，并将需要的浮动点常量放入已初始化的静态变量中。例如：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this example, of course you gain absolutely nothing by treating the floating-point
    constants as static variables. However, in more complex situations where you have
    several floating-point constants, you can analyze your program to determine which
    constants you access often and place the variables for those constants at adjacent
    memory locations. Because of the way most CPUs handle spatial locality of reference
    (see *WGC1*), when you access one of these constant objects, the cache line will
    be filled with the values of the adjacent objects as well. Therefore, when you
    access those other objects within a short period of time, it’s likely that their
    values will be in the cache. Another advantage to managing these constants yourself
    is that you can create a global set of constants that you can reference from different
    compilation units (source files), so the program accesses only a single memory
    object for a given constant rather the multiple memory objects (one for each compilation
    unit). Compilers generally aren’t smart enough to make decisions like this concerning
    your data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这个例子中，通过将浮动点常量处理为静态变量，你根本不会获得任何好处。然而，在更复杂的情况下，当你有多个浮动点常量时，你可以分析程序，确定哪些常量经常被访问，并将这些常量的变量放置在相邻的内存位置。由于大多数CPU处理引用的空间局部性的方式（参见*WGC1*），当你访问其中一个常量对象时，缓存行将被填充相邻对象的值。因此，当你在短时间内访问其他对象时，它们的值很可能已经在缓存中。自己管理这些常量的另一个优点是，你可以创建一个全局常量集合，可以在不同的编译单元（源文件）中引用，这样程序在访问某个常量时只会访问一个内存对象，而不是多个内存对象（每个编译单元一个）。编译器通常没有足够的智能来做出有关数据的这种决策。
- en: '**6.10 String Constants**'
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.10 字符串常量**'
- en: 'Like floating-point constants, string constants cannot be processed efficiently
    by most compilers (even if they are literal or manifest constants). Understanding
    when you should use manifest constants and when you should replace them with memory
    references can help you guide the compiler to produce better machine code. For
    example, most CPUs are not capable of encoding a string constant as part of an
    instruction. Using a manifest string constant may actually make your program less
    efficient. Consider the following C code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 像浮动点常量一样，字符串常量也无法被大多数编译器高效处理（即使它们是字面值常量或显式常量）。理解何时应该使用显式常量，何时应将其替换为内存引用，可以帮助你指导编译器生成更好的机器代码。例如，大多数CPU无法将字符串常量编码为指令的一部分。使用显式字符串常量实际上可能使程序的效率降低。考虑以下C代码：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The compiler (actually, the C preprocessor) expands the macro `strConst` to
    the string literal `"A string constant"` everywhere the identifier `strConst`
    appears in the source file, so this code is actually equivalent to:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器（实际上是C预处理器）将宏`strConst`展开为字符串字面值`"A string constant"`，每当标识符`strConst`出现在源文件中时，所以这段代码实际上等价于：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The problem with this code is that the same string constant appears at different
    places throughout the program. In C/C++, the compiler places the string constant
    in memory and substitutes a pointer to the string. A nonoptimizing compiler might
    wind up making three separate copies of the string in memory, which wastes space
    because the data is exactly the same in all three cases. (Remember that we’re
    talking about *constant* strings here.)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的问题在于相同的字符串常量在程序的不同位置出现。在C/C++中，编译器将字符串常量放入内存并替换为指向该字符串的指针。一个没有优化的编译器可能会在内存中创建三份相同的字符串副本，这会浪费空间，因为这三份数据是完全相同的。（记住，我们这里说的是*常量*字符串。）
- en: Compiler writers discovered this problem a few decades ago and modified their
    compilers to keep track of the strings in a given source file. If a program used
    the same string literal two or more times, the compiler wouldn’t allocate storage
    for a second copy of the string. Instead, it would simply use the address of the
    earlier string. This optimization (constant folding) could reduce the size of
    the code if the same string appeared throughout a source file.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器开发者几十年前发现了这个问题，并修改了编译器以跟踪给定源文件中的字符串。如果一个程序多次使用相同的字符串字面常量，编译器不会为第二个副本的字符串分配存储空间，而是直接使用第一个字符串的地址。这种优化（常量折叠）可以减少代码的大小，特别是当相同的字符串出现在源文件的多个地方时。
- en: 'Unfortunately, constant folding doesn’t always work properly. One problem is
    that many older C programs assign a string literal constant to a character pointer
    variable and then proceed to change the characters in that literal string. For
    example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，常量折叠并不总是正常工作。一个问题是，许多旧的 C 程序将字符串字面常量分配给字符指针变量，然后继续修改该字面字符串中的字符。例如：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Compilers that reuse the same string constant fail if the user stores data
    into the string object, as this code demonstrates. Although this is bad programming
    practice, it occurred frequently enough in older C programs that compiler vendors
    couldn’t use the same storage for multiple copies of the same string literal.
    Even if the compiler vendor were to place the string literal constant into write-protected
    memory to prevent this problem, there are other semantic issues that this optimization
    raises. Consider the following C/C++ code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 重用相同字符串常量的编译器会失败，如果用户将数据存储到字符串对象中，就像这段代码演示的那样。虽然这是不良的编程实践，但在旧的 C 程序中，这种情况足够频繁，以至于编译器供应商无法为多个副本的相同字符串字面量使用相同的存储空间。即使编译器供应商将字符串字面常量放入只读内存以防止这个问题，仍然会出现其他语义问题。这引出了如下的
    C/C++ 代码：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Will `s1EQs2` contain `true` (`1`) or `false` (`0`) after executing this instruction
    sequence? In programs written before C compilers had good optimizers available,
    this sequence of statements would leave `false` in `s1EQs2`. This was because
    the compiler created two different copies of the same string data and placed those
    strings at different addresses in memory (so the addresses the program assigns
    to `sptr1` and `sptr2` would be different). In a later compiler that kept only
    a single copy of the string data in memory, this code sequence would leave `true`
    sitting in `s1EQs2` because both `sptr1` and `sptr2` would be pointing at the
    same memory address. This difference exists regardless of whether or not the string
    data appears in write-protected memory.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完这段指令序列后，`s1EQs2` 会包含 `true`（`1`）还是 `false`（`0`）？在 C 编译器没有良好优化器的早期程序中，这段语句会让
    `s1EQs2` 为 `false`。这是因为编译器创建了两个不同的字符串副本，并将这些字符串放置在内存的不同地址（因此程序分配给 `sptr1` 和 `sptr2`
    的地址会不同）。在一个后来的编译器中，如果编译器仅保留字符串数据的单一副本，这段代码序列会使 `s1EQs2` 为 `true`，因为 `sptr1` 和
    `sptr2` 会指向相同的内存地址。无论字符串数据是否出现在受保护的内存中，这种差异都存在。
- en: To solve this dilemma, many compiler vendors provide a compiler option to enable
    programmers to determine whether the compiler should emit a single copy of each
    string or one copy for each occurrence of the string. If you don’t write data
    into string literal constants or compare their addresses, you can select this
    option to reduce the size of your programs. If you have old code that requires
    separate copies of the string data (hopefully, you won’t write new code that requires
    this), you can enable this option.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个难题，许多编译器供应商提供了一个编译器选项，允许程序员决定编译器是应生成每个字符串的单一副本，还是为每个字符串的出现生成单独的副本。如果你不向字符串字面常量写入数据或比较它们的地址，可以选择这个选项来减少程序的大小。如果你有旧代码需要单独的字符串数据副本（希望你不会再写需要这种方式的新代码），你可以启用此选项。
- en: Unfortunately, many programmers are completely unaware of this option, and the
    default condition on some compilers is generally to make multiple copies of the
    string data. If you’re using C/C++ or some other language that manipulates strings
    via pointers to the character data, investigate whether the compiler provides
    an option to merge identical strings and, if so, activate that feature in your
    compiler.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，许多程序员完全没有意识到这个选项，且一些编译器的默认条件通常是创建字符串数据的多个副本。如果你正在使用 C/C++ 或其他通过字符数据指针操作字符串的语言，检查编译器是否提供合并相同字符串的选项，如果有的话，启用该功能。
- en: 'If your C/C++ compiler does not offer this string-merging optimization, you
    can implement it manually. To do so, just create a `char` array variable in your
    program and initialize it with the address of the string. Then use the name of
    that array variable exactly as you would a manifest constant throughout your program.
    For example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 C/C++ 编译器没有提供这个字符串合并优化，你可以手动实现它。为此，只需在程序中创建一个`char`数组变量，并用字符串的地址进行初始化。然后，像使用常量一样在整个程序中使用该数组变量的名称。例如：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This code will maintain only a single copy of the string literal constant in
    memory, even if the compiler doesn’t directly support the optimization. Actually,
    even if your compiler does directly support this optimization, there are several
    good reasons why you should use this trick rather than relying on your compiler
    to do the work for you.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将只在内存中保持一个字符串字面量常量的副本，即使编译器并不直接支持该优化。事实上，即使你的编译器直接支持此优化，仍然有几个很好的理由让你使用这个技巧，而不是依赖编译器为你完成这个工作。
- en: In the future you might have to port your code to a different compiler that
    doesn’t support this optimization.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将来你可能需要将代码移植到一个不支持此优化的不同编译器。
- en: By handling the optimization manually, you don’t have to worry about it.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过手动处理优化，你就不必担心这个问题了。
- en: By using a pointer variable rather than a string literal constant, you have
    the option of easily changing the string whose address this pointer contains under
    program control.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用指针变量而非字符串字面量常量，你可以在程序控制下轻松更改该指针所指向的字符串。
- en: In the future you might want to modify the program to switch (natural) languages
    under program control.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将来你可能需要修改程序，以便在程序控制下切换（自然）语言。
- en: You can easily share the string between multiple files.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在多个文件之间轻松共享字符串。
- en: This string optimization discussion assumes that your programming language manipulates
    strings by reference (that is, by using a pointer to the actual string data).
    Although this is certainly true for C/C++ programs, it is not true of all languages.
    Pascal implementations that support strings (such as Free Pascal) typically manipulate
    them by value rather than by reference. Any time you assign a string value to
    a string variable, the compiler makes a copy of the string data and places that
    copy in the storage reserved for the string variable. This copying process can
    be expensive and is unnecessary if your program never changes the data in the
    string variable. Worse still, if the (Pascal) program assigns a string literal
    to a string variable, the program will have two copies of the string floating
    around (the string literal constant in memory and the copy that the program made
    for the string variable). If the program never again changes the string (which
    is not at all uncommon), it will waste memory by maintaining two copies of the
    string when one would suffice. These reasons (space and speed) are probably why
    Borland went to a much more sophisticated string format when they created Delphi
    4.0, abandoning the string format in earlier versions of Delphi.^([5](footnotes.xhtml#ch6fn5))
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符串优化讨论假设你的编程语言通过引用操作字符串（即，通过使用指向实际字符串数据的指针）。虽然对于 C/C++ 程序来说这确实是事实，但并非所有语言都如此。支持字符串的
    Pascal 实现（如 Free Pascal）通常是通过值而非通过引用来操作字符串。每当你将一个字符串值赋给一个字符串变量时，编译器会复制字符串数据，并将该副本放入为字符串变量保留的存储空间中。这个复制过程可能会很耗费资源，如果你的程序从不修改字符串变量中的数据，那么这种复制就是不必要的。更糟糕的是，如果（Pascal）程序将字符串字面量赋给字符串变量，程序将会有两个字符串副本在内存中（一个是字符串字面量常量，另一个是程序为字符串变量所做的副本）。如果程序以后再也不修改这个字符串（这并不罕见），它将浪费内存，通过保留两个字符串副本来维护一个本可以只保留一个副本的字符串。这些原因（空间和速度）可能就是
    Borland 在创建 Delphi 4.0 时采用了更复杂的字符串格式，而放弃了早期版本 Delphi 中的字符串格式的原因。^([5](footnotes.xhtml#ch6fn5))
- en: Swift also treats strings as value objects. This means that, in the worst case,
    it will make a copy of a string literal whenever you assign that string literal
    to a string variable. However, Swift implements an optimization known as *copy-on-write*.
    Whenever you assign one string object to another, Swift just copies a pointer.
    Therefore, if multiple strings have been assigned the same value, Swift will use
    the same string data in memory for all the copies. When you modify some portion
    of the string, Swift will make a copy of the string prior to the modification
    (hence the name “copy-on-write”) so that other string objects referencing the
    original string data are not affected by the change.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Swift也将字符串视为值对象。这意味着，在最坏的情况下，每当你将一个字符串字面量赋值给字符串变量时，Swift会复制该字符串字面量。然而，Swift实现了一种名为*按需复制*的优化。每当你将一个字符串对象赋给另一个，Swift只会复制一个指针。因此，如果多个字符串被赋值相同的值，Swift会为所有副本在内存中使用相同的字符串数据。当你修改字符串的某个部分时，Swift会在修改之前先复制字符串（因此称为“按需复制”），以确保引用原始字符串数据的其他字符串对象不会受到该修改的影响。
- en: '**6.11 Composite Data Type Constants**'
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.11 复合数据类型常量**'
- en: 'Many languages support other composite constant types (such as arrays, structures/records,
    and sets) in addition to strings. Usually, the languages use these constants to
    statically initialize variables prior to the program’s execution. For example,
    consider the following C/C++ code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言除了字符串外，还支持其他复合常量类型（如数组、结构体/记录和集合）。通常，这些语言使用这些常量在程序执行前静态初始化变量。例如，考虑以下C/C++代码：
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that `arrayOfInts` is not a constant. Rather, it is the initializer that
    constitutes the array constant—that is, `{1,2,3,4,5,6,7,8}`. In the executable
    file, most C compilers simply overlay the eight integers at the address associated
    with `arrayOfInts` with these eight numeric values.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`arrayOfInts` 不是一个常量。相反，它是构成数组常量的初始化器——即`{1,2,3,4,5,6,7,8}`。在可执行文件中，大多数C编译器只是在与`arrayOfInts`关联的地址上叠加这八个整数值。
- en: 'For example, here’s what GCC emits for this variable:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面是GCC为这个变量输出的内容：
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There is no extra space consumed to hold the constant data, assuming that `arrayOfInts`
    is a static object in C.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`arrayOfInts`是C中的静态对象，那么存储常量数据不会占用额外的空间。
- en: 'The rules change, however, if the variable you’re initializing is not a statically
    allocated object. Consider the following short C sequence:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你正在初始化的变量不是静态分配的对象，规则就会发生变化。考虑以下简短的C代码序列：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this example, `arrayOfInts` is an *automatic* variable, meaning that the
    program allocates storage on the stack for the variable each time the program
    calls function `f()`. For this reason, the compiler cannot simply initialize the
    array with the constant data when the program loads into memory. The `arrayOfInts`
    object could actually lie at a different address on each activation of the function.
    To obey the semantics of the C programming language, the compiler will have to
    make a copy of the array constant and then physically copy that constant data
    into the `arrayOfInts` variable whenever the program calls the function. Using
    an array constant this way consumes extra space (to hold a copy of the array constant)
    and extra time (to copy the data). Sometimes the semantics of your algorithm requires
    a fresh copy of the data upon each new activation of the function `f()`. However,
    you need to recognize when this is necessary (and when the extra space and time
    are warranted) rather than blowing memory and CPU cycles.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`arrayOfInts`是一个*自动*变量，这意味着每次程序调用函数`f()`时，程序都会在栈上为该变量分配存储空间。因此，编译器不能仅仅在程序加载到内存时使用常量数据来初始化数组。`arrayOfInts`对象实际上可能在每次激活函数时位于不同的地址。为了遵循C编程语言的语义，编译器必须复制数组常量，并在程序调用该函数时将该常量数据物理复制到`arrayOfInts`变量中。以这种方式使用数组常量会消耗额外的空间（用于存储数组常量的副本）和额外的时间（用于复制数据）。有时，算法的语义要求每次新激活函数`f()`时都要获取数据的新副本。然而，你需要认识到什么时候这是必要的（以及什么时候额外的空间和时间是值得的），而不是无谓地浪费内存和CPU周期。
- en: 'If your program doesn’t modify the array’s data, you can use a static object
    that the compiler can initialize once when it loads the program into memory:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序没有修改数组的数据，你可以使用一个静态对象，编译器可以在加载程序到内存时初始化该对象一次：
- en: '[PRE45]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The C/C++ languages also support struct constants. The same space and speed
    considerations we’ve seen for arrays when initializing automatic variables also
    apply to struct constants.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++语言也支持结构体常量。当初始化自动变量时，我们看到的数组的空间和速度问题，同样适用于结构体常量。
- en: 'Embarcadero’s Delphi programming language also supports structured constants,
    though the term “constant” is a bit misleading here. Embarcadero calls them *typed
    constants*, and you declare them in the Delphi `const` section like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Embarcadero 的 Delphi 编程语言也支持结构化常量，尽管这里的“常量”一词有些误导。Embarcadero 称它们为 *类型化常量*，你可以在
    Delphi 的 `const` 部分这样声明：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Although the declaration appears in a Delphi `const` section, Delphi actually
    treats it as a variable declaration. It’s an unfortunate design choice, but for
    a programmer who wants to create structured constants, this mechanism works fine.
    As with the C/C++ examples in this section, it’s important to remember that the
    constant in this example is actually the `(1,2,3,4,5,6,7,8)` object, not the `ary`
    variable.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管声明出现在 Delphi 的 `const` 部分，Delphi 实际上将其视为变量声明。这是一个不太理想的设计选择，但对于想要创建结构化常量的程序员来说，这种机制是可行的。与本节中的
    C/C++ 示例一样，重要的是要记住，示例中的常量实际上是 `(1,2,3,4,5,6,7,8)` 对象，而不是 `ary` 变量。
- en: Delphi (along with most modern Pascals, such as Free Pascal) supports several
    other composite constant types as well. Set constants are good examples. Whenever
    you create a set of objects, the Pascal compiler generally initializes some memory
    location with a powerset (bitmap) representation of the set’s data. Wherever you
    refer to that set constant in your program, the Pascal compiler generates a memory
    reference to the set’s constant data in memory.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Delphi（以及大多数现代 Pascal，如 Free Pascal）也支持其他几种复合常量类型。例如，集合常量就是一个很好的例子。每当你创建一个对象集合时，Pascal
    编译器通常会用集合数据的幂集（位图）表示来初始化某个内存位置。每当你在程序中引用该集合常量时，Pascal 编译器会生成一个指向集合常量数据的内存引用。
- en: 'Swift also supports composite data type constants for arrays, tuples, dictionaries,
    structs/classes, and other data types. For example, the following `let` statement
    creates an array constant with eight elements:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 也支持复合数据类型常量，如数组、元组、字典、结构体/类以及其他数据类型。例如，以下 `let` 语句创建了一个包含八个元素的数组常量：
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**6.12 Constants Don’t Change**'
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.12 常量不变**'
- en: In theory, values bound to a constant don’t change (Swift’s `let` statement
    being the obvious exception). In modern systems, compilers that place constants
    in memory often put them in write-protected memory regions to force an exception
    if an inadvertent write occurs. Of course, few programs can be written using only
    read-only (or write-once) objects. Most programs require the ability to change
    the values of objects (*variables*) they manipulate. That is the subject of the
    next chapter.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，绑定到常量的值是不会改变的（Swift 中的 `let` 语句是一个明显的例外）。在现代系统中，将常量放入内存的编译器通常会将它们放置在写保护内存区域中，以便在发生意外写入时强制引发异常。当然，很少有程序仅使用只读（或一次写入）对象来编写。大多数程序都需要能够改变它们操作的对象（*变量*）的值。这是下一章的内容。
- en: '**6.13 For More Information**'
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.13 更多信息**'
- en: 'Duntemann, Jeff. *Assembly Language Step-by-Step*. 3rd ed. Indianapolis: Wiley,
    2009.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Duntemann, Jeff. *逐步学习汇编语言*. 第3版. 印第安纳波利斯：Wiley，2009年。
- en: 'Hyde, Randall. *The Art of Assembly Language*. 2nd ed. San Francisco: No Starch
    Press, 2010.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Hyde, Randall. *汇编语言的艺术*. 第2版. 旧金山：No Starch Press，2010年。
- en: '———. *Write Great Code, Volume 1: Understanding the Machine*. 2nd ed. San Francisco:
    No Starch Press, 2020.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ——. *编写高质量代码，第1卷：理解机器*. 第2版. 旧金山：No Starch Press，2020年。
