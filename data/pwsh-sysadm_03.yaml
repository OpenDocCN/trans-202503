- en: '2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '2'
- en: BASIC POWERSHELL CONCEPTS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基本 PowerShell 概念
- en: '![Images](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: 'This chapter covers four basic concepts in PowerShell: variables, data types,
    objects, and data structures. These concepts are fundamental to just about every
    common programming language, but there’s something that makes PowerShell distinctive:
    everything in PowerShell is an object.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 PowerShell 中的四个基本概念：变量、数据类型、对象和数据结构。这些概念是几乎所有常见编程语言的基础，但 PowerShell 有一个独特之处：PowerShell
    中的每一样东西都是一个对象。
- en: This may not mean much to you now, but keep it in mind as you move through the
    rest of this chapter. By the end of the chapter, you should have an idea of just
    how significant this is.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能现在对你意义不大，但在你继续本章的学习时，请记住这一点。到本章结束时，你应该能明白这一点有多重要。
- en: Variables
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量
- en: 'A *variable* is a place to store *values*. You can think of a variable as a
    digital box. When you want to use a value multiple times, for example, you can
    put it in a box. Then, instead of typing the same number over and over in your
    code, you can put it in a variable and call that variable whenever you need the
    value. But as you might have guessed from the name, the real power of a variable
    is that it can change: you can add stuff to a box, swap what’s in the box with
    something else, or take out whatever’s in there and show it off for a bit before
    putting it back.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量* 是存储 *值* 的地方。你可以把变量想象成一个数字盒子。当你想多次使用一个值时，例如，可以把它放在一个盒子里。然后，代替在代码中反复输入相同的数字，你可以将其放入变量中，并在需要该值时调用该变量。但正如你从名称中可能猜到的那样，变量的真正强大之处在于它可以改变：你可以往盒子里加东西，把盒子里的内容换成别的东西，或者拿出里面的东西展示一下，然后再把它放回去。'
- en: As you’ll see later in the book, this variability lets you build code that can
    handle a general situation, as opposed to being tailored to one specific scenario.
    This section covers the basic ways to use a variable.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在本书后面看到的那样，这种可变性使你能够构建可以处理一般情况的代码，而不是针对某一个特定场景量身定制的代码。本节介绍了使用变量的基本方法。
- en: Displaying and Changing a Variable
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显示和更改变量
- en: All variables in PowerShell start with a dollar sign (`$`), which indicates
    to PowerShell that you are calling a variable and not a cmdlet, function, script
    file, or executable file. For example, if you want to display the value of the
    `MaximumHistoryCount` variable, you have to prepend it with a dollar sign and
    call it, as in [Listing 2-1](ch02.xhtml#ch2list1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 中的所有变量都以美元符号（`$`）开头，这表示你正在调用一个变量，而不是调用 cmdlet、函数、脚本文件或可执行文件。例如，如果你想显示
    `MaximumHistoryCount` 变量的值，你必须在变量名前加上美元符号并调用它，如[清单 2-1](ch02.xhtml#ch2list1)所示。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 2-1: Calling the `$MaximumHistoryCount` variable*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-1：调用 `$MaximumHistoryCount` 变量*'
- en: The `$MaximumHistoryCount` variable is a built-in variable that determines the
    maximum number of commands PowerShell saves in its command history; the default
    is 4096 commands.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`$MaximumHistoryCount` 变量是一个内建变量，用于确定 PowerShell 在命令历史记录中保存的最大命令数；默认值为 4096
    条命令。'
- en: You can change a variable’s value by entering the variable name—starting with
    a dollar sign—and then using an equal sign (`=`) and the new value, as in [Listing
    2-2](ch02.xhtml#ch2list2).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入变量名（以美元符号开始），然后使用等号（`=`）和新值来更改变量的值，如[清单 2-2](ch02.xhtml#ch2list2)所示。
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 2-2: Changing the `$MaximumHistoryCount` variable’s value*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-2：更改 `$MaximumHistoryCount` 变量的值*'
- en: Here you’ve changed the `$MaximumHistoryCount` variable’s value to `200`, meaning
    PowerShell will save only the previous 200 commands in its command history.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将 `$MaximumHistoryCount` 变量的值更改为 `200`，这意味着 PowerShell 只会保存最近的 200 条命令。
- en: '[Listings 2-1](ch02.xhtml#ch2list1) and [2-2](ch02.xhtml#ch2list2) use a variable
    that already exists. Variables in PowerShell come in two broad classes: *user-defined
    variables*, which are created by the user, and *automatic variables*, which already
    exist in PowerShell. Let’s look at user-defined variables first.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-1](ch02.xhtml#ch2list1) 和 [2-2](ch02.xhtml#ch2list2) 使用了已经存在的变量。PowerShell
    中的变量大致分为两类：*用户定义的变量*，由用户创建，以及 *自动变量*，这些变量在 PowerShell 中已经存在。我们先来看一下用户定义的变量。'
- en: User-Defined Variables
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用户定义的变量
- en: A variable needs to exist before you can use it. Try typing $color into your
    PowerShell console, as shown in [Listing 2-3](ch02.xhtml#ch2list3).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用变量之前，变量需要先存在。尝试在 PowerShell 控制台中输入 $color，如[清单 2-3](ch02.xhtml#ch2list3)所示。
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 2-3: Entering an undefined variable results in an error.*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-3：输入未定义变量会导致错误。*'
- en: TURNING ON STRICT MODE
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 开启严格模式
- en: 'If you didn’t get the error in [Listing 2-3](ch02.xhtml#ch2list3), and your
    console shows no output, try running the following command to turn on strict mode:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在[列表 2-3](ch02.xhtml#ch2list3)中没有遇到错误，且控制台没有显示任何输出，尝试运行以下命令以开启严格模式：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Turning on strict mode tells PowerShell to throw errors when you violate good
    coding practices. For example, strict mode forces PowerShell to return an error
    when you reference an object property that doesn’t exist or an undefined variable.
    It’s considered best practice to turn on this mode when writing scripts, as it
    forces you to write cleaner, more predictable code. When simply running interactive
    code from the PowerShell console, this setting is typically not used. For more
    information about strict mode, run `Get-Help Set-StrictMode -Examples`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 开启严格模式会告知 PowerShell，在你违反良好编码实践时抛出错误。例如，严格模式会强制 PowerShell 在你引用不存在的对象属性或未定义的变量时返回错误。在编写脚本时，开启此模式被认为是最佳实践，因为它强制你编写更简洁、更可预测的代码。而在
    PowerShell 控制台中运行交互式代码时，通常不使用此设置。有关严格模式的更多信息，请运行`Get-Help Set-StrictMode -Examples`。
- en: In [Listing 2-3](ch02.xhtml#ch2list3), you tried to refer to the `$color` variable
    before it even existed, which resulted in an error. To create a variable, you
    need to *declare* it—say that it exists—and then *assign* a value to it (or *initialize*
    it). You can do these at the same time, as in [Listing 2-4](ch02.xhtml#ch2list4),
    which creates a variable `$color` that contains the value `blue`. You can assign
    a value to a variable by using the same technique you used to change the value
    of `$MaximumHistoryCount`—by entering the variable name, followed by the equal
    sign, and then the value.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 2-3](ch02.xhtml#ch2list3)中，你尝试在`$color`变量尚不存在之前引用它，结果导致了一个错误。要创建一个变量，你需要*声明*它——即声明它存在——然后*赋值*给它（或*初始化*它）。你可以同时进行这两个操作，像[列表
    2-4](ch02.xhtml#ch2list4)所示，创建一个值为`blue`的变量`$color`。你可以使用与改变`$MaximumHistoryCount`值相同的技巧来为变量赋值——输入变量名，后跟等号，再加上值。
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 2-4: Creating a `color` variable with a value of `blue`*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-4：创建一个值为`blue`的`color`变量*'
- en: Once you’ve created the variable and assigned it a value, you can reference
    it by typing the variable name in the console ([Listing 2-5](ch02.xhtml#ch2list5)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了变量并为其赋值，你可以通过在控制台中键入变量名来引用它（如[列表 2-5](ch02.xhtml#ch2list5)所示）。
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 2-5: Checking the value of a variable*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-5：检查变量的值*'
- en: The value of a variable won’t change unless something, or someone, explicitly
    changes it. You can call the `$color` variable any number of times, and it will
    return the value `blue` each time until the variable is redefined.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的值不会改变，除非有某个操作或某人明确地改变它。你可以多次调用`$color`变量，它每次都会返回值`blue`，直到该变量被重新定义。
- en: When you use the equal sign to define a variable ([Listing 2-4](ch02.xhtml#ch2list4)),
    you’re doing the same thing you’d do with the `Set-Variable` command. Likewise,
    when you type a variable into the console, and it prints out the value, as in
    [Listing 2-5](ch02.xhtml#ch2list5), you’re doing the same thing you’d do with
    the `Get-Variable` command. [Listing 2-6](ch02.xhtml#ch2list6) recreates [Listings
    2-4](ch02.xhtml#ch2list4) and [2-5](ch02.xhtml#ch2list5) by using these commands.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用等号定义变量时（如[列表 2-4](ch02.xhtml#ch2list4)所示），你正在做的事情与使用`Set-Variable`命令是一样的。同样，当你在控制台中键入一个变量，它输出该值时，像[列表
    2-5](ch02.xhtml#ch2list5)所示，你也在做的事情与使用`Get-Variable`命令是一样的。[列表 2-6](ch02.xhtml#ch2list6)通过这些命令重新创建了[列表
    2-4](ch02.xhtml#ch2list4)和[2-5](ch02.xhtml#ch2list5)。
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 2-6: Creating a variable and displaying its value with the `Set-Variable`
    and `Get-Variable` commands*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-6：使用`Set-Variable`和`Get-Variable`命令创建变量并显示其值*'
- en: You can also use `Get-Variable` to return all available variables (as shown
    in [Listing 2-7](ch02.xhtml#ch2list7)).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`Get-Variable`返回所有可用的变量（如[列表 2-7](ch02.xhtml#ch2list7)所示）。
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 2-7: Using `Get-Variable` to return all the variables.*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-7：使用`Get-Variable`返回所有变量。*'
- en: This command will list all the variables currently in memory, but notice that
    there are some you haven’t defined. You’ll look at this type of variable in the
    next section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将列出当前内存中的所有变量，但请注意，有些变量是你尚未定义的。你将在下一节中查看这种类型的变量。
- en: Automatic Variables
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动变量
- en: Earlier I introduced automatic variables, the premade variables that PowerShell
    itself uses. Although PowerShell allows you to change some of these variables,
    as you did in [Listing 2-2](ch02.xhtml#ch2list2), I typically advise against it
    because unexpected consequences can arise. In general, you should treat automatic
    variables as *read-only*. (Now might be a good time to change `$MaximumHistoryCount`
    back to 4096!)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我介绍了自动变量，这些是PowerShell自己使用的预定义变量。虽然PowerShell允许你更改其中一些变量，就像你在[示例 2-2](ch02.xhtml#ch2list2)中所做的那样，但我通常不建议这样做，因为可能会引发意外后果。通常情况下，你应该将自动变量视为*只读*。
    （现在可能是时候将`$MaximumHistoryCount`恢复为4096了！）
- en: 'This section covers a few of the automatic variables that you’re likely to
    use: the `$null` variable, `$LASTEXITCODE`, and the preference variables.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了一些你可能会使用的自动变量：`$null`变量、`$LASTEXITCODE`和偏好设置变量。
- en: The $null Variable
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`$null`变量'
- en: 'The `$null` variable is a strange one: it represents nothing. Assigning `$null`
    to a variable allows you to create that variable but not assign a real value to
    it, as in [Listing 2-8](ch02.xhtml#ch2list8).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`$null`变量是一个奇怪的变量：它代表“无”。将`$null`赋值给一个变量，可以让你创建该变量，但不为其分配实际的值，就像在[示例 2-8](ch02.xhtml#ch2list8)中所示。'
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 2-8: Assigning variables to `$null`*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-8：将变量赋值为`$null`*'
- en: Here, you assign `$null` to the `$foo` variable. Then, when you call `$foo`,
    nothing is displayed, but no errors occur because PowerShell recognizes the variable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将`$null`赋值给`$foo`变量。然后，当你调用`$foo`时，不会显示任何内容，但不会出现错误，因为PowerShell能够识别该变量。
- en: You can see which variables PowerShell recognizes by passing parameters to the
    `Get-Variable` command. You can see in [Listing 2-9](ch02.xhtml#ch2list9) that
    PowerShell knows that the `$foo` variable exists but does not recognize the `$bar`
    variable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向`Get-Variable`命令传递参数来查看PowerShell识别的变量。在[示例 2-9](ch02.xhtml#ch2list9)中，你可以看到PowerShell知道`$foo`变量存在，但没有识别出`$bar`变量。
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 2-9: Using `Get-Variable` to find variables*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-9：使用`Get-Variable`查找变量*'
- en: You may be wondering why we bother defining anything as `$null`. But `$null`
    is surprisingly useful. For example, as you’ll see later in this chapter, you
    often give a variable a value as a response to something else, like the output
    of a certain function. If you check that variable, and see that its value is still
    `$null`, you’ll know that something went wrong in the function and can act accordingly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会好奇为什么我们需要将某些东西定义为`$null`。其实，`$null`是非常有用的。例如，正如你将在本章后面看到的，通常你会根据其他事情的结果为一个变量赋值，比如某个函数的输出。如果你检查该变量，发现其值仍然是`$null`，那就意味着函数出了问题，你可以据此采取相应的措施。
- en: The LASTEXITCODE Variable
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: LASTEXITCODE变量
- en: Another commonly used automatic variable is `$LASTEXITCODE`. PowerShell allows
    you to invoke external executable applications like the old-school *ping.exe*,
    which pings a website to get a response. When external applications finish running,
    they finish with an *exit code*, or *return code*, that indicates a message. Typically,
    a 0 indicates success, and anything else means either a failure or another anomaly.
    For *ping.exe*, a 0 indicates it was able to successfully ping a node, and a 1
    indicates it could not.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常用的自动变量是`$LASTEXITCODE`。PowerShell允许你调用外部可执行应用程序，比如老式的*ping.exe*，它ping一个网站并获取响应。当外部应用程序运行结束时，它会以一个*退出代码*或*返回代码*结束，该代码表示一个消息。通常，0表示成功，其他任何值都表示失败或其他异常。对于*ping.exe*，0表示能够成功ping到一个节点，1表示无法ping通。
- en: When *ping.exe* runs, as in [Listing 2-10](ch02.xhtml#ch2list10), you’ll see
    the expected output but not an exit code. That’s because the exit code is hidden
    inside `$LASTEXITCODE`. The value of `$LASTEXITCODE` is always the exit code of
    the last application that was executed. [Listing 2-10](ch02.xhtml#ch2list10) pings
    *[google.com](http://google.com)*, returns its exit code, and then pings a nonexistent
    domain and returns its exit code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当`*ping.exe*`运行时，正如在[示例 2-10](ch02.xhtml#ch2list10)中所示，你会看到预期的输出，但不会看到退出代码。这是因为退出代码被隐藏在`$LASTEXITCODE`中。`$LASTEXITCODE`的值始终是最后执行的应用程序的退出代码。[示例
    2-10](ch02.xhtml#ch2list10)会ping *[google.com](http://google.com)*，返回其退出代码，然后ping一个不存在的域名并返回其退出代码。
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 2-10: Using* ping.exe *to demonstrate the `$LASTEXITCODE` variable*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-10：使用*ping.exe*演示`$LASTEXITCODE`变量*'
- en: The `$LASTEXITCODE` is 0 when you ping *[google.com](http://google.com)* but
    has a value of 1 when you ping the bogus domain name *dfdfdfdfd.com*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你ping *[google.com](http://google.com)* 时，`$LASTEXITCODE`为0，而当你ping虚假的域名*dfdfdfdfd.com*时，`$LASTEXITCODE`的值为1。
- en: The Preference Variables
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 偏好设置变量
- en: 'PowerShell has a type of automatic variable referred to as *preference variables*.
    These variables control the default behavior of various output streams: `Error`,
    `Warning`, `Verbose`, `Debug`, and `Information`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 有一种称为*首选项变量*的自动变量类型。这些变量控制着各种输出流的默认行为：`Error`、`Warning`、`Verbose`、`Debug`
    和 `Information`。
- en: 'You can find a list of all of the preference variables by running `Get-Variable`
    and filtering for all variables ending in *Preference*, as shown here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行`Get-Variable`并过滤出所有以*Preference*结尾的变量来查找所有首选项变量，示例如下：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'These variables can be used to configure the various types of output PowerShell
    can return. For example, if you’ve ever made a mistake and seen that ugly red
    text, you’ve seen the `Error` output stream. Run the following command to generate
    an error message:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量可用于配置 PowerShell 可以返回的各种类型的输出。例如，如果你曾经犯过错误并看到过那些难看的红色文本，那么你就见识过`Error`输出流。运行以下命令以生成错误信息：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should have gotten a similar error message, as this is the default behavior
    for the `Error` stream. If for whatever reason you didn’t want to be bothered
    by this error text, and would rather nothing happen, you could redefine the `$ErrorActionPreference`
    variable to `SilentlyContinue` or `Ignore`, either of which will tell PowerShell
    not to output any error text:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似的错误信息，因为这是`Error`流的默认行为。如果出于某种原因你不想被这些错误文本打扰，并希望什么都不发生，你可以将`$ErrorActionPreference`变量重新定义为`SilentlyContinue`或`Ignore`，这两种方式都会告诉
    PowerShell 不输出任何错误文本：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, no error text is output. Ignoring error output is generally
    considered bad practice, so change the value of `$ErrorActionPreference` back
    to `Continue` before proceeding. For more information on preference variables,
    check out the `about_help` content by running Get-Help about_Preference_Variables.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，没有输出错误文本。忽略错误输出通常被认为是不好的做法，因此请在继续之前将`$ErrorActionPreference`的值改回`Continue`。有关首选项变量的更多信息，请通过运行
    `Get-Help about_Preference_Variables` 查看 `about_help` 内容。
- en: Data Types
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'PowerShell variables come in a variety of forms, or *types*. All the details
    of PowerShell’s data types are beyond the scope of this chapter. What you need
    to know is that PowerShell has several data types—including bools, strings, and
    integers—and you can change a variable’s data type without errors. The following
    code should run with no errors:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 变量有多种形式或*类型*。PowerShell 的数据类型的所有细节超出了本章的讨论范围。你需要知道的是，PowerShell 有几种数据类型——包括布尔值、字符串和整数——而且你可以在不产生错误的情况下更改变量的数据类型。以下代码应该能够顺利运行：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is because PowerShell can figure out data types based on the values you
    provide it. What’s happening under the hood is a little too complicated for this
    book, but it’s important you understand the basic types and how they interact.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 PowerShell 可以根据你提供的值来推断数据类型。背后发生的事情有点复杂，不适合本书的讨论，但理解基本类型以及它们如何交互是很重要的。
- en: Boolean Values
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 布尔值
- en: Just about every programming language uses *booleans*, which have a true or
    false value (1 or 0). Booleans are used to represent binary conditions, like a
    light switch being on or off. In PowerShell, booleans are called *bools*, and
    the two boolean values are represented by the automatic variables `$true` and
    `$false`. These automatic variables are hardcoded into PowerShell and can’t be
    changed. [Listing 2-11](ch02.xhtml#ch2list11) shows how to set a variable to be
    `$true` or `$false`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有编程语言都使用*布尔值*，它们有真或假的值（1 或 0）。布尔值用于表示二元条件，比如开关的开或关。在 PowerShell 中，布尔值被称为*bools*，这两个布尔值分别由自动变量`$true`和`$false`表示。这些自动变量是硬编码到
    PowerShell 中的，无法更改。[列表 2-11](ch02.xhtml#ch2list11)展示了如何将变量设置为`$true`或`$false`。
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 2-11: Creating a bool variable*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-11：创建一个布尔变量*'
- en: You’ll see a lot more of bools in [Chapter 4](ch04.xhtml#ch4).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[第 4 章](ch04.xhtml#ch4)中看到更多的布尔值。
- en: Integers and Floating Points
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 整数与浮点数
- en: 'You can represent numbers in PowerShell in two main ways: via integer or floating-point
    data types.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过整数或浮点数据类型在 PowerShell 中表示数字。
- en: Integer types
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 整数类型
- en: '*Integer* data types hold only whole numbers and will round any decimal input
    to the nearest integer. Integer data types come in *signed* and *unsigned* types.
    Signed data types can store both positive and negative numbers; unsigned data
    types store values with no sign.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*整数*数据类型仅保存整数，并会将任何小数输入四舍五入为最接近的整数。整数数据类型分为*有符号*和*无符号*类型。有符号数据类型可以存储正数和负数；无符号数据类型只存储没有符号的数值。'
- en: By default, PowerShell stores integers by using the 32-bit signed `Int32` type.
    The bit count determines how big (or small) a number the variable can hold; in
    this case, anything in the range –2,147,483,648 to 2,147,483,647\. For numbers
    outside that range, you can use the 64-bit signed `Int64` type, which has a range
    of –9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，PowerShell 使用 32 位有符号 `Int32` 类型来存储整数。位数决定了变量能够存储的数字的大小（或小），在这种情况下，范围是从
    -2,147,483,648 到 2,147,483,647。对于超出此范围的数字，你可以使用 64 位有符号 `Int64` 类型，范围为 -9,223,372,036,854,775,808
    到 9,223,372,036,854,775,807。
- en: '[Listing 2-12](ch02.xhtml#ch2list12) shows an example of how PowerShell handles
    `Int32` types.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-12](ch02.xhtml#ch2list12) 展示了 PowerShell 如何处理 `Int32` 类型的示例。'
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 2-12: Using an `Int` type to store different values*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-12：使用 `Int` 类型存储不同的值*'
- en: Let’s walk through each of these steps. Don’t worry about all the syntax; for
    now, focus on the output. First, you create a variable `$num` and give it the
    value of 1 ❶. Next, you check the type of `$num` ❷ and see that PowerShell interprets
    1 as an `Int32`. You then change `$num` to hold a decimal value ❸ and check the
    type again and see that PowerShell has changed the type to `Double`. This is because
    PowerShell will change a variable’s type depending on its value. But you can force
    PowerShell to treat a variable as a certain type by *casting* that variable, as
    you do at the end by using the `[Int32]` syntax in front of `$num` ❹. As you can
    see, when forced to treat 1.5 as an integer, PowerShell rounds it up to 2.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解每一个步骤。别担心所有的语法，现在关注输出。首先，你创建一个变量 `$num` 并赋值为 1 ❶。接下来，你检查 `$num` 的类型 ❷，发现
    PowerShell 将 1 解释为 `Int32`。然后，你将 `$num` 改为持有一个小数值 ❸，再次检查类型，发现 PowerShell 已经将类型改为
    `Double`。这是因为 PowerShell 会根据变量的值来更改其类型。但你可以通过*强制转换*该变量来让 PowerShell 将其视为某种特定类型，如你在最后通过在
    `$num` 前加上 `[Int32]` 语法所做的那样 ❹。如你所见，当强制将 1.5 视为整数时，PowerShell 会将其四舍五入为 2。
- en: Now let’s look at the `Double` type.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下 `Double` 类型。
- en: Floating-Point Types
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 浮动点类型
- en: The `Double` type belongs to the broader class of variables known as *floating-point*
    variables. Although they can be used to represent whole numbers, floating-point
    variables are most often used to represent decimals. The other main type of floating-point
    variable is `Float`. I won’t go into the internal representation of the `Float`
    and `Double` types. What you need to know is that although `Float` and `Double`
    are capable of representing decimal numbers, these types can be imprecise, as
    shown in [Listing 2-13](ch02.xhtml#ch2list13).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Double` 类型属于称为*浮动点*变量的更广泛类别。尽管它们可以用于表示整数，但浮动点变量最常用于表示小数。浮动点变量的另一个主要类型是 `Float`。我不会深入讨论
    `Float` 和 `Double` 类型的内部表示。你需要知道的是，虽然 `Float` 和 `Double` 能够表示小数，但这些类型可能会不精确，如
    [列表 2-13](ch02.xhtml#ch2list13) 所示。'
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 2-13: Precision errors with floating-point types*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-13：浮动点类型的精度错误*'
- en: As you can see, PowerShell uses the `Double` type by default. But notice what
    happens when you add `$num` to itself but cast both as a `Float`—you get a strange
    answer. Again, the reasons are beyond the scope of this book, but be aware that
    errors like this can happen when using `Float` and `Double`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，PowerShell 默认使用 `Double` 类型。但请注意，当你将 `$num` 与自身相加并强制将两者转换为 `Float` 类型时，结果会非常奇怪。原因超出了本书的范围，但要注意，使用
    `Float` 和 `Double` 时可能会发生类似的错误。
- en: Strings
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串
- en: 'You’ve already seen this type of variable. When you defined the `$color` variable
    in [Listing 2-4](ch02.xhtml#ch2list4), you didn’t just type `$color = blue`. Instead,
    you enclosed the value in single quotes, which indicates to PowerShell that the
    value is a series of letters, or a *string*. If you try to assign the `blue` value
    to `$color` without the quotes, PowerShell will return an error:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经见过这种类型的变量。当你在 [列表 2-4](ch02.xhtml#ch2list4) 中定义 `$color` 变量时，你并没有直接输入 `$color
    = blue`。相反，你将值括在单引号中，这表示 PowerShell 该值是一串字母，或称为*字符串*。如果你尝试在没有引号的情况下将 `blue` 值赋给
    `$color`，PowerShell 将返回一个错误：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Without quotes, PowerShell interprets `blue` as a command and tries to execute
    it. Because the command `blue` doesn’t exist, PowerShell returns an error message
    that says so. To correctly define a string, you need to use quotes around your
    value.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有引号，PowerShell 会将 `blue` 解释为一个命令并尝试执行它。因为命令 `blue` 不存在，所以 PowerShell 会返回一个错误信息。要正确定义字符串，你需要在值周围使用引号。
- en: Combining Strings and Variables
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 组合字符串和变量
- en: 'Strings aren’t restricted to words; they can be phrases and sentences as well.
    For instance, you can assign `$sentence` this string:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串不限于单词，它们也可以是短语和句子。例如，你可以给`$sentence`赋值如下字符串：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: But maybe you want to use this same sentence, but with the words *PowerShell*
    and *blue* as the values of variables. For instance, what if you have a variable
    called `$name`, another called `$language`, and another called `$color`? [Listing
    2-14](ch02.xhtml#ch2list14) defines these variables by using other variables.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但也许你想使用相同的句子，不过将*PowerShell*和*blue*作为变量的值。例如，假设你有一个叫做`$name`的变量，一个叫做`$language`的变量，和一个叫做`$color`的变量？[列表
    2-14](ch02.xhtml#ch2list14)通过使用其他变量来定义这些变量。
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 2-14: Inserting variables in strings*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-14：在字符串中插入变量*'
- en: 'Notice the use of double quotes. Enclosing your sentence in single quotes doesn’t
    achieve the intended result:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意双引号的使用。将句子用单引号括起来并不能达到预期的效果：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This isn’t just a weird bug. There’s an important difference between single
    and double quotes in PowerShell.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是一个奇怪的错误。在PowerShell中，单引号和双引号之间有一个重要的区别。
- en: Using Double vs. Single Quotes
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用双引号与单引号
- en: When you’re assigning a variable a simple string, you can use single or double
    quotes, as shown in [Listing 2-15](ch02.xhtml#ch2list15).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你给一个变量赋值一个简单的字符串时，可以使用单引号或双引号，如[列表 2-15](ch02.xhtml#ch2list15)所示。
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 2-15: Changing variable values by using single and double quotes*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-15：通过使用单引号和双引号来改变变量值*'
- en: 'As you can see, it doesn’t matter which quotes you use to define a simple string.
    So why did it matter when you had variables in your string? The answer has to
    do with *variable interpolation*, or *variable expansion*. Normally, when you
    enter `$color` by itself into the console and hit ENTER, PowerShell *interpolates*,
    or *expands*, that variable. These are fancy terms that mean PowerShell is reading
    the value inside a variable, or opening the box so you can see inside. When you
    use double quotes to call a variable, the same thing happens: the variable is
    expanded, as you can see in [Listing 2-16](ch02.xhtml#ch2list16).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，定义一个简单字符串时使用单引号或双引号都没有关系。那么，为什么当字符串中有变量时就变得重要了呢？答案与*变量插值*，或*变量扩展*有关。通常，当你单独输入`$color`并按下ENTER键时，PowerShell会*插值*，或*扩展*那个变量。这些都是
    fancy 的术语，意味着PowerShell正在读取变量中的值，或者说是打开箱子让你看里面的内容。当你使用双引号调用变量时，同样的事情会发生：变量会被扩展，正如你在[列表
    2-16](ch02.xhtml#ch2list16)中看到的那样。
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 2-16: Variable behavior inside a string*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-16：字符串中的变量行为*'
- en: 'But notice what happens when you use single quotes: the console outputs the
    variable itself, not its value. Single quotes tell PowerShell that you mean *exactly*
    what you’re typing, whether that’s a word like *blue* or what looks like a variable
    called `$color`. To PowerShell, it doesn’t matter. It won’t look past the value
    in single quotes. So when you use a variable inside single quotes, PowerShell
    doesn’t know to expand that variable’s value. This is why you need to use double
    quotes when inserting variables into your strings.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但是注意当你使用单引号时会发生什么：控制台输出的是变量本身，而不是它的值。单引号告诉PowerShell你输入的就是*确切的*内容，无论是像*blue*这样的单词，还是看起来像一个叫做`$color`的变量。对PowerShell来说，这并不重要。它不会超越单引号中的值。所以，当你在单引号中使用变量时，PowerShell不知道要扩展该变量的值。这就是为什么在将变量插入字符串时需要使用双引号的原因。
- en: 'There’s much more to say about bools, integers, and strings. But for now, let’s
    take a step back and look at something more general: objects.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 关于布尔值、整数和字符串还有很多内容要讲。但现在，让我们退后一步，看看一些更一般的内容：对象。
- en: Objects
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象
- en: In PowerShell, *everything* is an object. In technical terms, an *object* is
    an individual instance of a specific template, called a class. A *class* specifies
    the kinds of things an object will contain. An object’s class determines its *methods*,
    or actions that can be taken on that object. In other words, the methods are all
    the things an object can do. For example, a list object might have a `sort()`
    method that, when called, will sort the list. Likewise, an object’s class determines
    its *properties*, the object’s variables. You can think of the properties as all
    the data about the object. In the case of the list object, you might have a `length`
    property that stores the number of elements in the list. Sometimes, a class will
    provide default values for the object’s properties, but more often than not, these
    are values you will provide to the objects you work with.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，*一切*都是对象。从技术上讲，*对象*是特定模板（称为类）的单个实例。*类*指定了一个对象将包含的内容。对象的类决定了它的*方法*，即可以对该对象执行的操作。换句话说，方法就是对象能做的所有事情。例如，一个列表对象可能有一个`sort()`方法，当调用时，它将排序该列表。同样，对象的类决定了它的*属性*，即对象的变量。你可以把属性看作是关于对象的所有数据。以列表对象为例，你可能会有一个`length`属性，它存储列表中元素的数量。有时，一个类会为对象的属性提供默认值，但更多情况下，这些值是你在工作中为对象提供的。
- en: 'But that’s all very abstract. Let’s consider an example: a car. The car starts
    out as a plan in the design phase. This plan, or template, defines how the car
    should look, what kind of engine it should have, what kind of chassis it should
    have, and so on. The plan also lays out what the car will be able to do once it’s
    complete—move forward, move in reverse, and open and close the sunroof. You can
    think of this plan as the car’s class.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但这一切都是非常抽象的。让我们考虑一个例子：一辆车。车从设计阶段的一个计划开始。这个计划或模板定义了车应该是什么样子，应该有什么样的引擎，应该有什么样的底盘，等等。计划还规定了车完成后能够做什么——前进、倒退、开关天窗。你可以把这个计划看作是车的类。
- en: Each car is built from this class, and all of that particular car’s properties
    and methods are added to it. One car might be blue, while the same model car might
    be red, and another car may have a different transmission. These attributes are
    the properties of a specific car object. Likewise, each of the cars will drive
    forward, drive in reverse, and have the same method to open and close the sunroof.
    These actions are the car’s methods.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每辆车都是从这个类构建的，并且该车所有特定的属性和方法都被添加到它身上。一辆车可能是蓝色的，而同一型号的车可能是红色的，另外一辆车可能有不同的变速箱。这些属性是特定车对象的属性。同样，每辆车都会前进、倒退，并且有相同的方法来开关天窗。这些操作就是车的方式。
- en: Now with that general understanding of how objects work, let’s get our hands
    dirty and work with PowerShell.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过对对象如何工作的总体了解，让我们动手实践，使用 PowerShell。
- en: Inspecting Properties
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查属性
- en: First, let’s make a simple object so you can dissect it and uncover the various
    facets of a PowerShell object. [Listing 2-17](ch02.xhtml#ch2list17) creates a
    simple string object called `$color`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个简单的对象，这样你可以拆解它，揭示 PowerShell 对象的各个方面。[列表 2-17](ch02.xhtml#ch2list17)创建了一个名为`$color`的简单字符串对象。
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 2-17: Creating a string object*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-17：创建字符串对象*'
- en: Notice that when you call `$color`, you get only the variable’s value. But typically,
    because they’re objects, variables have more information than just their value.
    They also have properties.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当你调用`$color`时，你只会得到变量的值。但通常情况下，因为它们是对象，变量包含的信息不仅仅是它们的值。它们还有属性。
- en: To look at an object’s properties, you’ll use the `Select-Object` command and
    the `Property` parameter. You’ll pass the `Property` an asterisk argument, as
    in [Listing 2-18](ch02.xhtml#ch2list18), to tell PowerShell to return everything
    it finds.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看对象的属性，你将使用`Select-Object`命令和`Property`参数。你将向`Property`传递一个星号参数，如[列表 2-18](ch02.xhtml#ch2list18)所示，以告诉
    PowerShell 返回它找到的所有内容。
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 2-18: Investigating object properties*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-18：调查对象属性*'
- en: As you can see, the `$color` string has only a single property, called `Length`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`$color`字符串只有一个属性，叫做`Length`。
- en: 'You can directly reference the `Length` property by using *dot notation*: you
    use the name of the object, followed by a dot and the name of the property you
    want to access (see [Listing 2-19](ch02.xhtml#ch2list19)).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用*点表示法*直接引用`Length`属性：你使用对象的名称，后跟一个点，再加上你想要访问的属性名称（见[列表 2-19](ch02.xhtml#ch2list19)）。
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 2-19: Using dot notation to check an object’s property*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-19：使用点表示法检查对象的属性*'
- en: Referencing objects like this will become second nature over time.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样引用对象将随着时间的推移变得得心应手。
- en: Using the Get-Member cmdlet
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Get-Member cmdlet
- en: Using `Select-Object`, you discovered that the `$color` string has only a single
    property. But recall that objects sometimes have methods as well. To take a look
    at all the methods *and* properties that exist on this string object, you can
    use the `Get-Member` cmdlet ([Listing 2-20](ch02.xhtml#ch2list20)); this cmdlet
    will be your best friend for a long time. It’s an easy way to quickly list all
    of a particular object’s properties and methods, collectively referred to as an
    object’s *members*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Select-Object`，你发现 `$color` 字符串只有一个属性。但请记住，对象有时也包含方法。要查看此字符串对象上所有的 *方法*
    和 *属性*，你可以使用 `Get-Member` cmdlet（[清单 2-20](ch02.xhtml#ch2list20)）；这个 cmdlet 会是你很长一段时间里的好帮手。它是一个快速列出特定对象所有属性和方法的简便方法，统称为对象的
    *成员*。
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 2-20: Using `Get-Member` to investigate object properties and methods*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-20：使用 `Get-Member` 来调查对象的属性和方法*'
- en: Now we’re talking! It turns out that your simple string object has quite a few
    methods associated with it. There are lots more to explore, but not all are shown
    here. The number of methods and properties an object will have depends on its
    parent class.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始深入探讨！事实证明，你的简单字符串对象有很多相关的方法。还有许多其他方法值得探索，但并不是所有都在这里展示。一个对象的方法和属性数量取决于它的父类。
- en: Calling Methods
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调用方法
- en: You can reference methods with dot notation. However, unlike a property, a method
    will always end in a set of opening and closing parentheses and can take one or
    more parameters.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用点符号来引用方法。然而，与属性不同，方法总是以一对开闭圆括号结尾，并且可以接受一个或多个参数。
- en: For example, suppose you want to remove a character in your `$color` variable.
    You can remove characters from a string by using the `Remove()` method. Let’s
    isolate `$color`’s `Remove()` method with the code in [Listing 2-21](ch02.xhtml#ch2list21).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想删除 `$color` 变量中的一个字符。你可以使用 `Remove()` 方法从字符串中删除字符。让我们通过 [清单 2-21](ch02.xhtml#ch2list21)
    中的代码，来聚焦 `$color` 的 `Remove()` 方法。
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 2-21: Looking at a string’s `Remove()` method*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-21：查看字符串的 `Remove()` 方法*'
- en: 'As you can see, there are two definitions. This means you can use the method
    in two ways: either with `startIndex` and the `count` parameter, or with just
    `startIndex`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有两个定义。这意味着你可以通过两种方式使用该方法：一种是带有 `startIndex` 和 `count` 参数，另一种是仅使用 `startIndex`。
- en: So to remove the second character in `$color`, you specify the place of the
    character where you’d like to start removing, which we call the *index*. Indexes
    start from 0, so the first letter has a starting place of 0, the second an index
    of 1, and so on. Along with an index, you can provide the number of characters
    you’d like to remove by using a comma to separate the parameter arguments, as
    in [Listing 2-22](ch02.xhtml#ch2list22).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，要删除 `$color` 中的第二个字符，你需要指定你希望开始删除字符的位置，这个位置我们称之为 *索引*。索引从 0 开始，所以第一个字母的起始位置是
    0，第二个字母的索引是 1，依此类推。通过索引，你还可以指定希望删除的字符数，方法是使用逗号分隔参数，如 [清单 2-22](ch02.xhtml#ch2list22)
    所示。
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 2-22: Calling methods*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-22：调用方法*'
- en: Using an index of 1, you’ve told PowerShell that you want to remove characters
    starting with the string’s second character; the second argument tells PowerShell
    to remove just one character. So you get `Rd`. But notice that the `Remove()`
    method doesn’t permanently change the value of a string variable. If you’d like
    to keep this change, you’d need to assign the output of the `Remove()` method
    to a variable, as shown in [Listing 2-23](ch02.xhtml#ch2list23).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引 1，你告诉 PowerShell 从字符串的第二个字符开始删除；第二个参数告诉 PowerShell 只删除一个字符。所以你得到 `Rd`。但是请注意，`Remove()`
    方法并不会永久改变字符串变量的值。如果你想保留这个更改，需要将 `Remove()` 方法的输出赋值给一个变量，如 [清单 2-23](ch02.xhtml#ch2list23)
    所示。
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 2-23: Capturing output of the `Remove()` method on a string*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-23：捕获字符串上 `Remove()` 方法的输出*'
- en: '**NOTE**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you need to know whether a method returns an object (as Remove() does)
    or modifies an existing object, you can check its description. As you can see
    in [Listing 2-21](ch02.xhtml#ch2list21), Remove()’s definition has the word string
    in front of it; this means that the function returns a new string. Functions with
    the word void in front typically modify existing objects. [Chapter 6](ch06.xhtml#ch6)
    covers this topic in more depth.*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你需要知道某个方法是返回一个对象（如 Remove() 所做的）还是修改一个现有对象，你可以查看它的描述。如你所见，在[示例 2-21](ch02.xhtml#ch2list21)中，Remove()
    的定义前面有一个字符串；这意味着该函数返回一个新的字符串。前面有 void 的函数通常会修改现有对象。[第 6 章](ch06.xhtml#ch6)将更深入地讨论这个话题。*'
- en: In these examples, you’ve used one of the simplest types of object, the string.
    In the next section, you’ll take a look at some more complex objects.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，你使用了最简单的对象类型之一——字符串。在下一节中，你将了解一些更复杂的对象。
- en: Data Structures
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据结构
- en: 'A *data structure* is a way to organize multiple pieces of data. Like the data
    they organize, data structures in PowerShell are represented by objects stored
    in variables. They come in three main types: arrays, ArrayLists, and hashtables.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据结构*是组织多个数据项的一种方式。与它们所组织的数据类似，PowerShell 中的数据结构由存储在变量中的对象表示。它们主要有三种类型：数组、ArrayList
    和哈希表。'
- en: Arrays
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数组
- en: So far, I’ve described a variable as a box. But if a simple variable (such as
    a `Float` type) is a single box, then an *array* is whole bunch of boxes taped
    together—a list of items represented by a single variable.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我把变量描述为一个盒子。但如果一个简单的变量（例如`Float`类型）是一个单独的盒子，那么*数组*就是一大堆用胶带粘在一起的盒子——由单个变量表示的一系列项目。
- en: Often you’ll need several related variables—say, a standard set of colors. Rather
    than storing each color as a separate string, and then referencing each of those
    individual variables, it’s much more efficient to store all of those colors in
    a single data structure. This section will show you how to create, access, modify,
    and add to an array.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你需要几个相关的变量——比如一组标准颜色。与其将每个颜色存储为单独的字符串，然后引用这些单独的变量，不如将所有这些颜色存储在一个单一的数据结构中，这样效率更高。本节将向你展示如何创建、访问、修改和向数组中添加元素。
- en: Defining Arrays
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义数组
- en: First, let’s define a variable called `$colorPicker` and assign it an array
    that holds four colors as strings. To do this, you use the at sign (`@`) followed
    by the four strings (separated by commas) within parentheses, as in [Listing 2-24](ch02.xhtml#ch2list24).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个名为 `$colorPicker` 的变量，并将其赋值为一个包含四种颜色的字符串数组。为此，你使用 `@` 符号，后跟四个字符串（用逗号分隔）放在括号内，如[示例
    2-24](ch02.xhtml#ch2list24)所示。
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 2-24: Creating an array*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-24：创建数组*'
- en: The `@` sign followed by an opening parenthesis and zero or more elements separated
    by a comma signals to PowerShell that you’d like to create an array.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`@`符号后面跟着一个左括号和零个或多个由逗号分隔的元素，表示你想要在 PowerShell 中创建一个数组。'
- en: Notice that after calling `$colorPicker`, PowerShell displays each of the array’s
    elements on a new line. In the next section, you’ll learn how to access each element
    individually.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在调用 `$colorPicker` 后，PowerShell 会将数组的每个元素显示在新的一行中。在下一节中，你将学习如何单独访问每个元素。
- en: Reading Array Elements
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 读取数组元素
- en: To access an element in an array, you use the name of the array followed by
    a pair of square brackets (`[]`) that contain the index of the element you want
    to access. As with string characters, you start numbering arrays at 0, so the
    first element is at index 0, the second at index 1, and so on. In PowerShell,
    using –1 as the index will return the final element.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数组中的元素，你需要使用数组的名称，后跟一对方括号（`[]`），括号内包含你想访问的元素的索引。与字符串字符一样，数组的编号从 0 开始，所以第一个元素的索引是
    0，第二个是 1，以此类推。在 PowerShell 中，使用 -1 作为索引将返回最后一个元素。
- en: '[Listing 2-25](ch02.xhtml#ch2list25) accesses several elements in our `$colorPicker`
    array.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-25](ch02.xhtml#ch2list25) 访问我们 `$colorPicker` 数组中的多个元素。'
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 2-25: Reading array elements*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-25：读取数组元素*'
- en: As you can see, if you try to specify an index number that doesn’t exist in
    the array, PowerShell will return an error message.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果你试图指定一个在数组中不存在的索引号，PowerShell 会返回一个错误信息。
- en: 'To access multiple elements in an array at the same time, you can use the *range
    operator* (`..`) between two numbers. The range operator will make PowerShell
    return those two numbers and every number between them, like so:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要同时访问数组中的多个元素，你可以在两个数字之间使用*范围操作符*（`..`）。范围操作符会使 PowerShell 返回这两个数字以及它们之间的每一个数字，像这样：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To use the range operator to access multiple items in an array, you use a range
    for an index, as shown here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用范围操作符访问数组中的多个项目，你需要使用一个索引范围，如下所示：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now that you’ve seen how to access elements in an array, let’s look at how to
    change them.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何访问数组中的元素，让我们来看看如何更改它们。
- en: Modifying Elements in an Array
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 修改数组中的元素
- en: If you want to change an element in an array, you don’t have to redefine the
    entire array. Instead, you can reference an item with its index and use the equal
    sign to assign a new value, as in [Listing 2-26](ch02.xhtml#ch2list26).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更改数组中的元素，你不需要重新定义整个数组。你可以通过其索引引用某个元素，并使用等号为其赋予一个新值，如 [清单 2-26](ch02.xhtml#ch2list26)
    所示。
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 2-26: Modifying elements in an array*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-26：修改数组中的元素*'
- en: Make sure you double-check that the index number is correct by displaying the
    element to your console before you modify an element.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改元素之前，确保通过将元素显示到控制台来仔细检查索引号是否正确。
- en: Adding Elements to an Array
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向数组添加元素
- en: You can add items to an array with the addition operator (`+`), as in [Listing
    2-27](ch02.xhtml#ch2list27).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用加法操作符 (`+`) 向数组添加元素，如 [清单 2-27](ch02.xhtml#ch2list27) 所示。
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 2-27: Adding a single item to an array*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-27：向数组添加单个元素*'
- en: Notice that you enter `$colorPicker` on both sides of the equal sign. This is
    because you are asking PowerShell to interpolate the `$colorPicker` variable and
    then add a new element.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在等号两边你都输入了 `$colorPicker`。这是因为你要求 PowerShell 插值 `$colorPicker` 变量，然后添加一个新元素。
- en: The `+` method works, but there’s a quicker, more readable way. You can use
    the plus and equal signs together to form `+=` (see [Listing 2-28](ch02.xhtml#ch2list28)).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`+` 方法有效，但有一种更快捷、更易读的方法。你可以使用加号和等号一起形成 `+=`（见 [清单 2-28](ch02.xhtml#ch2list28)）。'
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 2-28: Using the `+=` shortcut to add an item to an array*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-28：使用 `+=` 快捷方式向数组添加元素*'
- en: The `+=` operator tells PowerShell to *add this item to the existing array*.
    This shortcut prevents you from having to type out the array name twice and is
    much more common than using the full syntax.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`+=` 操作符告诉 PowerShell *将该项添加到现有数组中*。这个快捷方式可以避免你两次输入数组名，使用它比输入完整的语法要常见得多。'
- en: You can also add arrays to other arrays. Say you’d like to add the colors pink
    and cyan to your `$colorPicker` example. [Listing 2-29](ch02.xhtml#ch2list29)
    defines another array with just those two colors and adds them just as you did
    in [Listing 2-28](ch02.xhtml#ch2list28).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将数组添加到其他数组中。假设你想把粉色和青色添加到你的 `$colorPicker` 示例中。[清单 2-29](ch02.xhtml#ch2list29)
    定义了另一个仅包含这两种颜色的数组，并像在 [清单 2-28](ch02.xhtml#ch2list28) 中一样将它们添加进来。
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 2-29: Adding multiple elements to an array at once*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-29：一次向数组添加多个元素*'
- en: Adding multiple items at once can save you a lot of time, especially if you’re
    creating an array with a large number of items. Note that PowerShell treats any
    comma-separated set of values as an array, and you don’t explicitly need the `@`
    or parentheses.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一次添加多个元素可以节省你很多时间，尤其是在你创建一个包含大量元素的数组时。请注意，PowerShell 会将任何以逗号分隔的值集视为数组，你无需显式使用
    `@` 或括号。
- en: Unfortunately, there is no equivalent of `+=` to remove an element from an array.
    Removing elements from an array is more complicated than you might think, and
    we won’t cover it here. To understand why, read on!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有类似于 `+=` 的操作符来从数组中删除元素。从数组中删除元素比你想象的更复杂，我们在这里不会详细介绍。要了解原因，请继续阅读！
- en: ArrayLists
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数组列表（ArrayLists）
- en: 'Something strange happens when you add to an array. Every time you add an element
    to an array, you’re actually creating a new array from your old (interpolated)
    array and the new element. The same thing happens when you remove an element from
    an array: PowerShell destroys your old array and makes a new one. This is because
    arrays in PowerShell have a fixed size. When you change them, you can’t modify
    the size, so you have to create a new array. For small arrays like the ones we’ve
    been working with, you won’t notice this happening. But when you begin to work
    with *huge* arrays, with tens or hundreds of thousands of elements, you’ll see
    a big performance hit.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向数组添加元素时，会发生一些奇怪的事情。每次你向数组添加元素时，实际上是在通过旧的（插值过的）数组和新元素创建一个新的数组。当你从数组中删除元素时也会发生同样的事情：PowerShell
    会销毁旧数组并创建一个新数组。这是因为 PowerShell 中的数组大小是固定的。当你改变它们时，无法修改大小，因此必须创建一个新数组。对于像我们之前使用的小数组，你可能不会注意到这种情况。但当你开始处理*庞大的*数组，包含数万或数十万个元素时，你会看到明显的性能下降。
- en: 'If you know you’ll have to remove or add many elements to an array, I suggest
    you use a different data structure called an *ArrayList*. ArrayLists behave nearly
    identically to the typical PowerShell array, but with one crucial difference:
    they don’t have a fixed size. They can dynamically adjust to added or removed
    elements, giving a much higher performance when working with large amounts of
    data.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道你必须从数组中添加或移除许多元素，我建议你使用另一种数据结构，叫做*ArrayList*。ArrayList的行为几乎与典型的PowerShell数组相同，但有一个关键的区别：它们没有固定大小。它们可以动态调整以适应添加或移除的元素，在处理大量数据时提供更高的性能。
- en: Defining an ArrayList is exactly like defining an array, except that you need
    to cast it as an ArrayList. [Listing 2-30](ch02.xhtml#ch2list30) re-creates the
    color picker array but casts it as a `System.Collections.ArrayList` type.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 定义ArrayList与定义数组完全相同，只不过你需要将其转换为ArrayList。[示例 2-30](ch02.xhtml#ch2list30)重新创建了颜色选择器数组，但将其转换为`System.Collections.ArrayList`类型。
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 2-30: Creating an ArrayList*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-30：创建ArrayList*'
- en: As with an array, when you call an ArrayList, each item is displayed on a separate
    line.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，当你调用一个ArrayList时，每个项都会显示在单独的一行上。
- en: Adding Elements to an ArrayList
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向ArrayList添加元素
- en: To add or remove an element from an ArrayList without destroying it, you can
    use its methods. You can use the `Add()` and `Remove()` methods to add or remove
    items from an ArrayList. [Listing 2-31](ch02.xhtml#ch2list31) uses the `Add()`
    method and enters the new element within the method’s parentheses.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要向ArrayList添加或移除元素而不销毁它，你可以使用其方法。你可以使用`Add()`和`Remove()`方法来向ArrayList添加或移除项。[示例
    2-31](ch02.xhtml#ch2list31)使用了`Add()`方法并将新元素放在方法的括号内。
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 2-31: Adding a single item to an ArrayList*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-31：向ArrayList添加单个项*'
- en: 'Notice the output: the number 4, which is the index of the new element you
    added. Typically, you won’t use this number, so you can send the `Add()` method
    output to the `$null` variable to prevent it from outputting anything, as shown
    in [Listing 2-32](ch02.xhtml#ch2list32).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意输出：数字4是你添加的新元素的索引。通常，你不会使用这个数字，所以可以将`Add()`方法的输出发送到`$null`变量，避免其输出任何内容，如[示例
    2-32](ch02.xhtml#ch2list32)所示。
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 2-32: Sending output to `$null`*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-32：将输出发送到`$null`*'
- en: There are a few ways to negate output from PowerShell commands, but assigning
    output to `$null` gives the best performance, as the `$null` variable cannot be
    reassigned.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以取消PowerShell命令的输出，但将输出分配给`$null`能提供最佳性能，因为`$null`变量无法重新赋值。
- en: Removing Elements from an ArrayList
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从ArrayList中移除元素
- en: You can remove elements in a similar way, using the `Remove()` method. For example,
    if you want to remove the value `gray` from the ArrayList, enter the value within
    the method’s parentheses, as in [Listing 2-33](ch02.xhtml#ch2list33).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以以类似的方式移除元素，使用`Remove()`方法。例如，如果你想从ArrayList中移除值`gray`，可以将值放在方法的括号内，如[示例
    2-33](ch02.xhtml#ch2list33)所示。
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 2-33: Removing an item from an ArrayList*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-33：从ArrayList中移除项*'
- en: Notice that to remove an item, you don’t have to know the index number. You
    can reference the element by its actual value—in this case, `gray`. If the array
    has multiple elements with the same value, PowerShell will remove the element
    closest to the start of the ArrayList.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，要移除一个项目，你不必知道索引号。你可以通过实际值引用元素——在这种情况下是`gray`。如果数组中有多个相同值的元素，PowerShell将移除离ArrayList开头最近的元素。
- en: It’s hard to see the performance difference with small examples like these.
    But ArrayLists perform much better on large datasets than arrays. As with most
    programming choices, you’ll need to analyze your specific situation to determine
    whether it makes more sense to use an array or an ArrayList. The rule of thumb
    is the larger the collection of items you’re working with, the better off you’ll
    be using an ArrayList. If you’re working with small arrays of fewer than 100 elements
    or so, you’ll notice little difference between an array and an ArrayList.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在像这样的简单示例中很难看到性能差异。但是，ArrayList在处理大数据集时比数组表现得更好。与大多数编程选择一样，你需要分析你的具体情况，来确定是使用数组还是ArrayList更合适。通常来说，你处理的项目集合越大，使用ArrayList越好。如果你处理的是少于100个元素的小数组，你几乎不会发现数组和ArrayList之间有什么区别。
- en: Hashtables
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 哈希表
- en: 'Arrays and ArrayLists are great when you need your data associated with only
    a position in a list. But sometimes you’ll want something more direct: a way to
    correlate two pieces of data. For example, you might have a list of usernames
    you want to match to real names. In that case, you could use a *hashtable* (or
    *dictionary*), a PowerShell data structure that contains a list of *key-value
    pairs*. Instead of using a numeric index, you give PowerShell an input, called
    a *key*, and it returns the *value* associated with that key. So, in our example,
    you would index into the hashtable by using the username, and it would return
    that user’s real name.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只需要根据列表中的位置关联数据时，数组和 ArrayList 很有用。但有时你需要更加直接的方式：一种关联两段数据的方式。例如，你可能有一个用户名列表，想要将其匹配到真实姓名。在这种情况下，你可以使用
    *哈希表*（或 *字典*），这是 PowerShell 中包含 *键值对* 列表的数据结构。你不使用数字索引，而是给 PowerShell 提供一个输入，称为
    *键*，它返回与该键关联的 *值*。因此，在我们的例子中，你可以使用用户名作为哈希表的索引，它将返回该用户的真实姓名。
- en: '[Listing 2-34](ch02.xhtml#ch2list34) defines a hashtable, called `$users`,
    that holds information about three users.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-34](ch02.xhtml#ch2list34) 定义了一个名为 `$users` 的哈希表，其中包含三名用户的信息。'
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Listing 2-34: Creating a hashtable*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-34：创建哈希表*'
- en: PowerShell will not let you define a hashtable with duplicate keys. Each key
    has to uniquely point to a single value, which can be an array or even another
    hashtable!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 不允许你定义具有重复键的哈希表。每个键必须唯一地指向一个值，而这个值可以是一个数组，甚至是另一个哈希表！
- en: Reading Elements from Hashtables
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从哈希表中读取元素
- en: To access a specific value in a hashtable, you use its key. There are two ways
    to do this. Say you want to find out the real name of the user `abertram`. You
    could use either of the two approaches shown in [Listing 2-35](ch02.xhtml#ch2list35).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问哈希表中的特定值，你可以使用它的键。你可以通过两种方式来实现这一点。假设你想查找用户 `abertram` 的真实姓名，你可以使用 [示例 2-35](ch02.xhtml#ch2list35)
    中展示的任意两种方法。
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 2-35: Accessing a hashtable’s value*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-35：访问哈希表的值*'
- en: The two options have subtle differences, but for now, you can choose whichever
    method you prefer.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种选项有细微的差别，但现在你可以选择任何你偏好的方法。
- en: 'The second command in [Listing 2-35](ch02.xhtml#ch2list35) uses a property:
    `$users.abertram`. PowerShell will add each key to the object’s properties. If
    you want to see all the keys and values a hashtable has, you can access the `Keys`
    and `Values` properties, as in [Listing 2-36](ch02.xhtml#ch2list36).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-35](ch02.xhtml#ch2list35) 中的第二条命令使用了一个属性：`$users.abertram`。PowerShell
    会将每个键添加到对象的属性中。如果你想查看哈希表中的所有键和值，可以访问 `Keys` 和 `Values` 属性，如 [示例 2-36](ch02.xhtml#ch2list36)
    所示。'
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Listing 2-36: Reading hashtable keys and values*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-36：读取哈希表的键和值*'
- en: 'If you want to see *all* the properties of a hashtable (or any object), you
    can run this command:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看哈希表（或任何对象）的 *所有* 属性，你可以运行以下命令：
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Adding and Modifying Hashtable Items
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加和修改哈希表项
- en: To add an element to a hashtable, you can use the `Add()` method or create a
    new index by using square brackets and an equal sign. Both ways are shown in [Listing
    2-37](ch02.xhtml#ch2list37).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要向哈希表中添加元素，你可以使用 `Add()` 方法，或者通过使用方括号和等号创建一个新索引。两种方法都在 [示例 2-37](ch02.xhtml#ch2list37)
    中展示。
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 2-37: Adding an item to a hashtable*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-37：向哈希表添加项*'
- en: Now your hashtable stores five users. But what happens if you need to change
    one of the values in your hashtable?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的哈希表存储了五个用户。如果你需要修改哈希表中的某个值，应该怎么办？
- en: When you’re modifying a hashtable, it’s always a good idea to check that the
    key-value pair you want exists. To check whether a key already exists in a hashtable,
    you can use the `ContainsKey()` method, part of every hashtable created in PowerShell.
    When the hashtable contains the key, it will return `True;` otherwise, it will
    return `False`, as shown in [Listing 2-38](ch02.xhtml#ch2list38).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当你修改哈希表时，最好检查你想要修改的键值对是否存在。要检查一个键是否已经存在于哈希表中，你可以使用 `ContainsKey()` 方法，这是 PowerShell
    中每个哈希表的组成部分。当哈希表中包含该键时，它将返回 `True`；否则，返回 `False`，如 [示例 2-38](ch02.xhtml#ch2list38)
    所示。
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Listing 2-38: Checking items in a hashtable*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-38：检查哈希表中的项*'
- en: Once you’ve confirmed the key is in the hashtable, you can modify its value
    by using a simple equal sign, as shown in [Listing 2-39](ch02.xhtml#ch2list39).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确认键存在于哈希表中，你可以通过使用一个简单的等号来修改其值，如 [示例 2-39](ch02.xhtml#ch2list39) 所示。
- en: '[PRE49]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '*Listing 2-39: Modifying a hashtable value*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-39：修改哈希表值*'
- en: As you’ve seen, you can add items to a hashtable in a couple of ways. As you’ll
    see in the next section, there’s only one way to remove an item from a hashtable.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以通过几种方式向哈希表中添加项目。正如你将在下一部分看到的，删除哈希表中的项只有一种方法。
- en: Removing Items from a Hashtable
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从哈希表中删除项
- en: Like ArrayLists, hashtables have a `Remove()` method. Simply call it and pass
    in the key value of the item you want to remove, as in [Listing 2-40](ch02.xhtml#ch2list40).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 与 ArrayList 一样，哈希表有一个 `Remove()` 方法。只需调用它并传入你想删除项的键值，如[清单 2-40](ch02.xhtml#ch2list40)所示。
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*Listing 2-40: Removing an item from a hashtable*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-40：从哈希表中删除一项*'
- en: One of your users should be gone, but you can call the hashtable to double-check.
    Remember that you can use the `Keys` property to remind yourself of any key name.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你的一个用户应该已经不在了，但你可以调用哈希表来进行双重检查。记住，你可以使用 `Keys` 属性来提醒自己任何键的名称。
- en: Creating Custom Objects
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建自定义对象
- en: So far in this chapter, you’ve been making and using types of objects built
    into PowerShell. Most of the time, you can stick with these types and save yourself
    the work of creating your own. But sometimes you’ll need to create a custom object
    with properties and methods that you define.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，你一直在创建和使用 PowerShell 内置的对象类型。大多数时候，你可以使用这些类型，避免自己创建对象。但有时候，你需要创建一个自定义对象，定义你自己的属性和方法。
- en: '[Listing 2-41](ch02.xhtml#ch2list41) uses the `New-Object` cmdlet to define
    a new object with a `PSCustomObject` type.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-41](ch02.xhtml#ch2list41) 使用 `New-Object` cmdlet 定义了一个 `PSCustomObject`
    类型的新对象。'
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '*Listing 2-41: Creating a custom object by using `New-Object`*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-41：使用 `New-Object` 创建自定义对象*'
- en: This example uses the `New-Object` command, but you could do the same thing
    by using an equal sign and a cast, as in [Listing 2-42](ch02.xhtml#ch2list42).
    You define a hashtable in which the keys are property names, and the values are
    property values, and then cast it as `PSCustomObject`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用了 `New-Object` 命令，但你也可以通过使用等号和强制转换来做同样的事情，如[清单 2-42](ch02.xhtml#ch2list42)所示。你定义一个哈希表，其中键是属性名称，值是属性值，然后将其强制转换为
    `PSCustomObject`。
- en: '[PRE52]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '*Listing 2-42: Creating a custom object by using the `PSCustomObject` type
    accelerator*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-42：使用 `PSCustomObject` 类型加速器创建自定义对象*'
- en: Notice that [Listing 2-42](ch02.xhtml#ch2list42) uses a semicolon (`;`) to separate
    the key and value definitions.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[清单 2-42](ch02.xhtml#ch2list42) 使用分号（`；`）来分隔键和值的定义。
- en: Once you have a custom object, you use it as you would any other object. [Listing
    2-43](ch02.xhtml#ch2list43) passes our custom object to the `Get_Member` cmdlet
    to check that it is a `PSCustomObject` type.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了自定义对象，你就可以像使用任何其他对象一样使用它。[清单 2-43](ch02.xhtml#ch2list43) 将我们的自定义对象传递给 `Get_Member`
    cmdlet 来检查它是否为 `PSCustomObject` 类型。
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '*Listing 2-43: Investigating properties and methods of a custom object*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-43：调查自定义对象的属性和方法*'
- en: As you can see, your object already has some preexisting methods (for example,
    one that returns the object’s type!), along with the properties you defined when
    you created the object in [Listing 2-42](ch02.xhtml#ch2list42).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你的对象已经有了一些预先存在的方法（例如，其中一个返回对象的类型！），以及你在[清单 2-42](ch02.xhtml#ch2list42)中创建对象时定义的属性。
- en: 'Let’s access those properties by using dot notation:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用点表示法来访问这些属性：
- en: '[PRE54]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Looks good! You’ll use `PSCustomObject` objects a lot throughout the rest of
    the book. They’re powerful tools that let you create much more flexible code.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！在本书的其余部分，你会经常使用 `PSCustomObject` 对象。它们是强大的工具，让你能够创建更加灵活的代码。
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: By now, you should have a general understanding of objects, variables, and data
    types. If you still don’t understand these concepts, please reread this chapter.
    This is some of the most foundational stuff we’ll be covering. A high-level understanding
    of these concepts will make the rest of this book much easier to understand.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该对对象、变量和数据类型有一个大致的了解。如果你仍然不理解这些概念，请重新阅读这一章。这是我们将要讨论的最基础的内容之一。对这些概念有一个高层次的理解将使得本书的其他部分更容易理解。
- en: 'The next chapter covers two ways to combine commands in PowerShell: the pipeline
    and scripts.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍两种在 PowerShell 中组合命令的方法：管道和脚本。
