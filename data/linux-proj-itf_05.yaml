- en: 'Chapter 5. File I/O: Further Details'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章 文件 I/O：进一步细节
- en: In this chapter, we extend the discussion of file I/O that we started in the
    previous chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续讨论在上一章中开始的文件 I/O。
- en: In continuing the discussion of the *open()* system call, we explain the concept
    of *atomicity*—the notion that the actions performed by a system call are executed
    as a single uninterruptible step. This is a necessary requirement for the correct
    operation of many system calls.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续讨论 *open()* 系统调用时，我们解释了 *原子性* 的概念——即系统调用执行的动作作为一个单一的不可中断的步骤完成。这是许多系统调用正确操作的必要要求。
- en: 'We introduce another file-related system call, the multipurpose *fcntl()*,
    and show one of its uses: fetching and setting open file status flags.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了另一个与文件相关的系统调用——多用途的 *fcntl()*，并展示了它的一个用法：获取和设置打开文件的状态标志。
- en: Next, we look at the kernel data structures used to represent file descriptors
    and open files. Understanding the relationship between these structures clarifies
    some of the subtleties of file I/O discussed in subsequent chapters. Building
    on this model, we then explain how to duplicate file descriptors.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨用于表示文件描述符和打开文件的内核数据结构。理解这些结构之间的关系，有助于我们理清后续章节中讨论的文件 I/O 的一些细微之处。在此基础上，我们将进一步解释如何复制文件描述符。
- en: We then consider some system calls that provide extended read and write functionality.
    These system calls allow us to perform I/O at a specific location in a file without
    changing the file offset, and to transfer data to and from multiple buffers in
    a program.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们考虑一些提供扩展读写功能的系统调用。这些系统调用允许我们在文件的特定位置进行 I/O，而不改变文件偏移量，并能够在程序中的多个缓冲区之间传输数据。
- en: We briefly introduce the concept of nonblocking I/O, and describe some extensions
    provided to support I/O on very large files.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要介绍了非阻塞 I/O 的概念，并描述了一些扩展功能，以支持非常大的文件的 I/O 操作。
- en: Since temporary files are used by many system programs, we’ll also look at some
    library functions that allow us to create and use temporary files with randomly
    generated unique names.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多系统程序使用临时文件，我们还将介绍一些库函数，它们允许我们创建并使用具有随机生成唯一名称的临时文件。
- en: Atomicity and Race Conditions
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子性与竞争条件
- en: Atomicity is a concept that we’ll encounter repeatedly when discussing the operation
    of system calls. All system calls are executed atomically. By this, we mean that
    the kernel guarantees that all of the steps in a system call are completed as
    a single operation, without being interrupted by another process or thread.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 原子性是我们在讨论系统调用操作时会反复遇到的一个概念。所有的系统调用都是原子性执行的。我们所说的原子性执行，意味着内核保证系统调用中的所有步骤作为一个单独的操作完成，不会被其他进程或线程中断。
- en: Atomicity is essential to the successful completion of some operations. In particular,
    it allows us to avoid *race conditions* (sometimes known as *race hazards*). A
    race condition is a situation where the result produced by two processes (or threads)
    operating on shared resources depends in an unexpected way on the relative order
    in which the processes gain access to the CPU(s).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 原子性对于某些操作的成功完成至关重要。特别是，它使我们能够避免 *竞争条件*（有时也称为 *竞争危害*）。竞争条件是指两个进程（或线程）在操作共享资源时，产生的结果以一种意外的方式依赖于进程获得
    CPU 访问权限的相对顺序。
- en: In the next few pages, we look at two situations involving file I/O where race
    conditions occur, and show how these conditions are eliminated through the use
    of *open()* flags that guarantee the atomicity of the relevant file operations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几页中，我们将讨论两种涉及文件 I/O 的情况，在这些情况下会发生竞争条件，并展示如何通过使用保证相关文件操作原子性的 *open()* 标志来消除这些条件。
- en: 'We revisit the topic of race conditions when we describe *sigsuspend()* in
    [Waiting for a Signal Using a Mask: *sigsuspend()*](ch22.html#waiting_for_a_signal_using_a_mask_colon
    "Waiting for a Signal Using a Mask: sigsuspend()") and *fork()* in Section 24.4.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述 *sigsuspend()*（参见[使用掩码等待信号：*sigsuspend()*](ch22.html#waiting_for_a_signal_using_a_mask_colon
    "使用掩码等待信号：sigsuspend()")）和 *fork()*（参见第24.4节）时，我们会重新讨论竞争条件的问题。
- en: Creating a file exclusively
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个独占文件
- en: In [File descriptor number returned by *open()*](ch04.html#file_descriptor_number_returned_by-id1
    "File descriptor number returned by open()"), we noted that specifying `O_EXCL`
    in conjunction with `O_CREAT` causes *open()* to return an error if the file already
    exists. This provides a way for a process to ensure that it is the creator of
    a file. The check on the prior existence of the file and the creation of the file
    are performed atomically. To see why this is important, consider the code shown
    in [Example 5-1](ch05.html#incorrect_code_to_exclusively_open_a_fil "Example 5-1. Incorrect
    code to exclusively open a file"), which we might resort to in the absence of
    the `O_EXCL` flag. (In this code, we display the process ID returned by the *getpid()*
    system call, which enables us to distinguish the output of two different runs
    of this program.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[由*open()*返回的文件描述符号](ch04.html#file_descriptor_number_returned_by-id1 "由 open()
    返回的文件描述符号")中，我们提到将`O_EXCL`与`O_CREAT`一起使用，会导致如果文件已经存在，*open()*返回错误。这为进程确保它是文件的创建者提供了一种方法。文件是否存在的检查与文件的创建是原子性执行的。为了理解这一点，请考虑[示例
    5-1](ch05.html#incorrect_code_to_exclusively_open_a_fil "示例 5-1. 错误的独占打开文件代码")中的代码，这是在没有`O_EXCL`标志的情况下我们可能会采用的代码。（在这段代码中，我们显示了*getpid()*系统调用返回的进程
    ID，这使我们能够区分两次运行该程序的输出。）
- en: Example 5-1. Incorrect code to exclusively open a file
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-1. 错误的独占打开文件代码
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Aside from the long-winded use of two calls to *open()*, the code in [Example 5-1](ch05.html#incorrect_code_to_exclusively_open_a_fil
    "Example 5-1. Incorrect code to exclusively open a file") also contains a bug.
    Suppose that when our process first called *open()*, the file did not exist, but
    by the time of the second *open()*, some other process had created the file. This
    could happen if the kernel scheduler decided that the process’s time slice had
    expired and gave control to another process, as shown in [Figure 5-1](ch05.html#failing_to_exclusively_create_a_file
    "Figure 5-1. Failing to exclusively create a file"), or if the two processes were
    running at the same time on a multiprocessor system. [Figure 5-1](ch05.html#failing_to_exclusively_create_a_file
    "Figure 5-1. Failing to exclusively create a file") portrays the case where two
    processes are both executing the code shown in [Example 5-1](ch05.html#incorrect_code_to_exclusively_open_a_fil
    "Example 5-1. Incorrect code to exclusively open a file"). In this scenario, process
    A would wrongly conclude that it had created the file, since the second *open()*
    succeeds whether or not the file exists.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了冗长地使用两次*open()*调用外，[示例 5-1](ch05.html#incorrect_code_to_exclusively_open_a_fil
    "示例 5-1. 错误的独占打开文件代码")中的代码还包含了一个 bug。假设在我们的进程第一次调用*open()*时，文件并不存在，但到第二次*open()*时，另一个进程已经创建了该文件。如果内核调度程序决定进程的时间片已经耗尽，并将控制权交给了另一个进程（如[图
    5-1](ch05.html#failing_to_exclusively_create_a_file "图 5-1. 未能独占创建文件")所示），或者两个进程在多处理器系统上同时运行，则可能会发生这种情况。[图
    5-1](ch05.html#failing_to_exclusively_create_a_file "图 5-1. 未能独占创建文件")展示了两个进程都在执行[示例
    5-1](ch05.html#incorrect_code_to_exclusively_open_a_fil "示例 5-1. 错误的独占打开文件代码")中所示代码的情况。在这种情况下，进程
    A 会错误地得出结论，认为它已经创建了文件，因为第二次*open()*无论文件是否存在都会成功。
- en: While the chance of the process wrongly believing it was the creator of the
    file is relatively small, the possibility that it may occur nevertheless renders
    this code unreliable. The fact that the outcome of these operations depends on
    the order of scheduling of the two processes means that this is a race condition.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然进程错误地认为它是文件创建者的概率相对较小，但这种可能性仍然使得该代码不可靠。这些操作的结果依赖于两个进程调度的顺序，意味着这是一个竞态条件。
- en: '![Failing to exclusively create a file](figs/web/05-1_FILEIO-B-non-atomic-open-scale90.png.jpg)Figure 5-1. Failing
    to exclusively create a file'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![未能独占创建文件](figs/web/05-1_FILEIO-B-non-atomic-open-scale90.png.jpg)图 5-1. 未能独占创建文件'
- en: 'To demonstrate that there is indeed a problem with this code, we could replace
    the commented line `WINDOW FOR FAILURE` in [Example 5-1](ch05.html#incorrect_code_to_exclusively_open_a_fil
    "Example 5-1. Incorrect code to exclusively open a file") with a piece of code
    that creates an artificially long delay between the check for file existence and
    the creation of the file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这段代码确实存在问题，我们可以将[示例 5-1](ch05.html#incorrect_code_to_exclusively_open_a_fil
    "示例 5-1. 错误的独占打开文件代码")中的注释行`WINDOW FOR FAILURE`替换为一段代码，在检查文件是否存在和文件创建之间制造一个人工的长延迟：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *sleep()* library function suspends the execution of a process for a specified
    number of seconds. We discuss this function in Section 23.4.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*sleep()* 库函数将暂停进程的执行，直到指定的秒数过去。我们将在第23.4节讨论这个函数。'
- en: 'If we run two simultaneous instances of the program in [Example 5-1](ch05.html#incorrect_code_to_exclusively_open_a_fil
    "Example 5-1. Incorrect code to exclusively open a file"), we see that they both
    claim to have exclusively created the file:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们同时运行两个程序实例，在[示例 5-1](ch05.html#incorrect_code_to_exclusively_open_a_fil
    "示例 5-1. 错误代码用于独占打开文件")中，我们会看到它们都声称已经独占创建了文件：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the penultimate line of the above output, we see the shell prompt mixed with
    output from the first instance of the test program.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出的倒数第二行中，我们看到 Shell 提示符与第一个测试程序实例的输出混合在一起。
- en: Both processes claim to have created the file because the code of the first
    process was interrupted between the existence check and the creation of the file.
    Using a single *open()* call that specifies the `O_CREAT` and `O_EXCL` flags prevents
    this possibility by guaranteeing that the check and creation steps are carried
    out as a single atomic (i.e., uninterruptible) operation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 两个进程声称已创建文件，因为第一个进程的代码在检查文件是否存在和创建文件之间被中断。使用一个同时指定 `O_CREAT` 和 `O_EXCL` 标志的
    *open()* 调用可以防止这种情况发生，它通过保证检查和创建操作作为一个单一的原子（即不可中断）操作来实现。
- en: Appending data to a file
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向文件追加数据
- en: 'A second example of the need for atomicity is when we have multiple processes
    appending data to the same file (e.g., a global log file). For this purpose, we
    might consider using a piece of code such as the following in each of our writers:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 原子性需求的第二个示例是当我们有多个进程向同一文件追加数据时（例如，向全局日志文件写入）。为此，我们可能会考虑在每个写入者中使用如下代码：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, this code suffers the same defect as the previous example. If the first
    process executing the code is interrupted between the *lseek()* and *write()*
    calls by a second process doing the same thing, then both processes will set their
    file offset to the same location before writing, and when the first process is
    rescheduled, it will overwrite the data already written by the second process.
    Again, this is a race condition because the results depend on the order of scheduling
    of the two processes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码与前一个示例存在相同的缺陷。如果第一个执行代码的进程在 *lseek()* 和 *write()* 调用之间被第二个进程中断，且第二个进程正在执行相同操作，那么两个进程会在写入之前将文件偏移量设置为相同的位置，当第一个进程被重新调度时，它将覆盖第二个进程已经写入的数据。这仍然是一个竞争条件，因为结果取决于两个进程的调度顺序。
- en: Avoiding this problem requires that the seek to the next byte past the end of
    the file and the write operation happen atomically. This is what opening a file
    with the `O_APPEND` flag guarantees.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这个问题需要保证文件的下一个字节的寻址和写操作是原子性的。这正是使用 `O_APPEND` 标志打开文件所保证的。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some file systems (e.g., NFS) don’t support `O_APPEND`. In this case, the kernel
    reverts to the nonatomic sequence of calls shown above, with the consequent possibility
    of file corruption as just described.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一些文件系统（例如 NFS）不支持 `O_APPEND`。在这种情况下，内核会回退到上面显示的非原子调用序列，因此可能会导致文件损坏，如前所述。
- en: 'File Control Operations: *fcntl()*'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件控制操作：*fcntl()*
- en: The *fcntl()* system call performs a range of control operations on an open
    file descriptor.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*fcntl()* 系统调用对打开的文件描述符执行一系列控制操作。'
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Return on success depends on *cmd*, or -1 on error
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回取决于 *cmd*，出错时返回 -1
- en: The *cmd* argument can specify a wide range of operations. We examine some of
    them in the following sections, and delay examination of others until later chapters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*cmd* 参数可以指定多种操作。我们将在接下来的章节中讨论其中的一些，并将其他操作的讨论推迟到后面的章节。'
- en: As indicated by the ellipsis, the third argument to *fcntl()* can be of different
    types, or it can be omitted. The kernel uses the value of the *cmd* argument to
    determine the data type (if any) to expect for this argument.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如省略号所示，*fcntl()* 的第三个参数可以是不同类型的，或者可以省略。内核使用 *cmd* 参数的值来确定此参数应期望的数据类型（如果有的话）。
- en: Open File Status Flags
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开文件状态标志
- en: 'One use of *fcntl()* is to retrieve or modify the access mode and open file
    status flags of an open file. (These are the values set by the *flags* argument
    specified in the call to *open()*.) To retrieve these settings, we specify *cmd*
    as `F_GETFL`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*fcntl()* 的一个用途是检索或修改已打开文件的访问模式和文件状态标志。（这些是由调用 *open()* 时指定的 *flags* 参数设置的值。）要检索这些设置，我们指定
    *cmd* 为 `F_GETFL`：'
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After the above piece of code, we could test if the file was opened for synchronized
    writes as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段之后，我们可以像下面这样测试文件是否以同步写入模式打开：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'SUSv3 requires that only status flags that were specified during an *open()*
    or a later *fcntl()* `F_SETFL` should be set on an open file. However, Linux deviates
    from this in one respect: if an application was compiled using one of the techniques
    described in [I/O on Large Files](ch05.html#i_solidus_o_on_large_files "I/O on
    Large Files") for opening large files, then `O_LARGEFILE` will always be set in
    the flags retrieved by `F_GETFL`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3要求只有在*open()*或后续的*fcntl()* `F_SETFL`中指定的状态标志才能在打开的文件上设置。然而，Linux在这一点上有所不同：如果应用程序是使用[I/O
    on Large Files](ch05.html#i_solidus_o_on_large_files "I/O on Large Files")中描述的某种技术编译的来打开大文件，那么在通过`F_GETFL`获取的标志中，`O_LARGEFILE`将始终被设置。
- en: 'Checking the access mode of the file is slightly more complex, since the `O_RDONLY`
    (0), `O_WRONLY` (1), and `O_RDWR` (2) constants don’t correspond to single bits
    in the open file status flags. Therefore, to make this check, we mask the *flags*
    value with the constant `O_ACCMODE`, and then test for equality with one of the
    constants:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 检查文件的访问模式稍微复杂一些，因为`O_RDONLY`（0）、`O_WRONLY`（1）和`O_RDWR`（2）常量并不对应打开文件状态标志中的单个比特。因此，为了进行此检查，我们将*flags*值与常量`O_ACCMODE`进行掩码操作，然后测试是否与某个常量相等：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can use the *fcntl()* `F_SETFL` command to modify some of the open file status
    flags. The flags that can be modified are `O_APPEND`, `O_NONBLOCK`, `O_NOATIME`,
    `O_ASYNC`, and `O_DIRECT`. Attempts to modify other flags are ignored. (Some other
    UNIX implementations allow *fcntl()* to modify other flags, such as `O_SYNC`.)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用*fcntl()*的`F_SETFL`命令来修改一些打开文件的状态标志。可以修改的标志有`O_APPEND`、`O_NONBLOCK`、`O_NOATIME`、`O_ASYNC`和`O_DIRECT`。修改其他标志的尝试会被忽略。（一些其他UNIX实现允许*fcntl()*修改其他标志，例如`O_SYNC`。）
- en: 'Using *fcntl()* to modify open file status flags is particularly useful in
    the following cases:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*fcntl()*修改打开文件状态标志在以下情况下特别有用：
- en: The file was not opened by the calling program, so that it had no control over
    the flags used in the *open()* call (e.g., the file may be one of the three standard
    descriptors that are opened before the program is started).
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件并不是由调用程序打开的，因此它无法控制在*open()*调用中使用的标志（例如，该文件可能是程序启动前已经打开的三个标准描述符之一）。
- en: The file descriptor was obtained from a system call other than *open()*. Examples
    of such system calls are *pipe()*, which creates a pipe and returns two file descriptors
    referring to either end of the pipe, and *socket()*, which creates a socket and
    returns a file descriptor referring to the socket.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件描述符是通过除*open()*以外的系统调用获得的。此类系统调用的例子有*pipe()*，它创建一个管道并返回两个文件描述符，分别指向管道的两端；还有*socket()*，它创建一个套接字并返回一个指向该套接字的文件描述符。
- en: 'To modify the open file status flags, we use *fcntl()* to retrieve a copy of
    the existing flags, then modify the bits we wish to change, and finally make a
    further call to *fcntl()* to update the flags. Thus, to enable the `O_APPEND`
    flag, we would write the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修改打开文件的状态标志，我们使用*fcntl()*来获取现有标志的副本，然后修改我们希望更改的位，最后再次调用*fcntl()*来更新标志。因此，要启用`O_APPEND`标志，我们可以这样写：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Relationship Between File Descriptors and Open Files
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件描述符与打开文件之间的关系
- en: Up until now, it may have appeared that there is a one-to-one correspondence
    between a file descriptor and an open file. However, this is not the case. It
    is possible—and useful—to have multiple descriptors referring to the same open
    file. These file descriptors may be open in the same process or in different processes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，可能看起来文件描述符和打开文件之间存在一一对应关系。然而，事实并非如此。实际上，可以有多个描述符指向同一个打开文件，这样做是可能的也是有用的。这些文件描述符可以在同一进程中打开，也可以在不同进程中打开。
- en: 'To understand what is going on, we need to examine three data structures maintained
    by the kernel:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解发生了什么，我们需要检查内核维护的三个数据结构：
- en: the per-process file descriptor table;
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个进程的文件描述符表；
- en: the system-wide table of open file descriptions; and
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统范围的打开文件描述符表；以及
- en: the file system i-node table.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统的i节点表。
- en: 'For each process, the kernel maintains a table of *open file descriptors*.
    Each entry in this table records information about a single file descriptor, including:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个进程，内核维护一个*打开文件描述符*表。该表中的每一项记录一个单独文件描述符的信息，包括：
- en: a set of flags controlling the operation of the file descriptor (there is just
    one such flag, the close-on-exec flag, which we describe in [File Descriptors
    and *exec()*](ch27.html#file_descriptors_and_exec_open_parenthes "File Descriptors
    and exec()")); and
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组控制文件描述符操作的标志（这里只有一个这样的标志，即关闭执行标志，我们在[文件描述符和 *exec()*](ch27.html#file_descriptors_and_exec_open_parenthes
    "File Descriptors and exec()")中描述了它）；以及
- en: a reference to the open file description.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用该打开文件描述符。
- en: 'The kernel maintains a system-wide table of all *open file descriptions*. (This
    table is sometimes referred to as the *open file table*, and its entries are sometimes
    called *open file handles*.) An open file description stores all information relating
    to an open file, including:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 内核维护一个系统范围内的所有 *打开文件描述符* 的表。（这个表有时被称为 *打开文件表*，其条目有时被称为 *打开文件句柄*。）一个打开文件描述符存储与打开文件相关的所有信息，包括：
- en: the current file offset (as updated by *read()* and *write()*, or explicitly
    modified using *lseek()*);
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前文件偏移量（由 *read()* 和 *write()* 更新，或通过 *lseek()* 显式修改）；
- en: status flags specified when opening the file (i.e., the *flags* argument to
    *open()*);
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开文件时指定的状态标志（即传递给 *open()* 的 *flags* 参数）；
- en: the file access mode (read-only, write-only, or read-write, as specified in
    *open()*);
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件访问模式（只读、只写或读写，具体由 *open()* 指定）；
- en: settings relating to signal-driven I/O ([Signal-Driven I/O](ch63.html#signal-driven_i_solidus_o
    "Signal-Driven I/O")); and
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与信号驱动 I/O 相关的设置（[信号驱动 I/O](ch63.html#signal-driven_i_solidus_o "Signal-Driven
    I/O")）；以及
- en: a reference to the *i-node* object for this file.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向该文件的 *i-node* 对象的引用。
- en: 'Each file system has a table of *i-nodes* for all files residing in the file
    system. The i-node structure, and file systems in general, are discussed in more
    detail in [Chapter 14](ch14.html "Chapter 14. File Systems"). For now, we note
    that the i-node for each file includes the following information:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件系统都有一个包含文件系统中所有文件的 *i-node* 的表。i-node 结构以及文件系统的一般概念将在[第 14 章](ch14.html
    "第 14 章. 文件系统")中详细讨论。现在，我们需要注意的是，每个文件的 i-node 包括以下信息：
- en: file type (e.g., regular file, socket, or FIFO) and permissions;
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件类型（例如，常规文件、套接字或 FIFO）和权限；
- en: a pointer to a list of locks held on this file; and
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向此文件上持有的锁列表的指针；以及
- en: various properties of the file, including its size and timestamps relating to
    different types of file operations.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的各种属性，包括文件大小和与不同类型文件操作相关的时间戳。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Here, we are overlooking the distinction between on-disk and in-memory representations
    of an i-node. The on-disk i-node records the persistent attributes of a file,
    such as its type, permissions, and timestamps. When a file is accessed, an in-memory
    copy of the i-node is created, and this version of the i-node records a count
    of the open file descriptions referring to the i-node and the major and minor
    IDs of the device from which the i-node was copied. The in-memory i-node also
    records various ephemeral attributes that are associated with a file while it
    is open, such as file locks.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们忽略了磁盘上和内存中 i-node 表示之间的区别。磁盘上的 i-node 记录文件的持久性属性，如文件类型、权限和时间戳。当文件被访问时，会创建该
    i-node 的内存副本，这个版本的 i-node 记录了引用该 i-node 的打开文件描述符的数量，以及从中复制该 i-node 的设备的主次 ID。内存中的
    i-node 还记录了与文件在打开时相关的各种临时属性，如文件锁。
- en: '[Figure 5-2](ch05.html#relationship_between_file_descriptors_co "Figure 5-2. Relationship
    between file descriptors, open file descriptions, and i-nodes") illustrates the
    relationship between file descriptors, open file descriptions, and i-nodes. In
    this diagram, two processes have a number of open file descriptors.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-2](ch05.html#relationship_between_file_descriptors_co "图 5-2. 文件描述符、打开文件描述符与
    i-node 之间的关系") 说明了文件描述符、打开文件描述符与 i-node 之间的关系。在此图中，两个进程都有多个打开的文件描述符。'
- en: '![Relationship between file descriptors, open file descriptions, and i-nodes](figs/web/05-2_FILEIO-B-open-files.png.jpg)Figure 5-2. Relationship
    between file descriptors, open file descriptions, and i-nodes'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![文件描述符、打开文件描述符与 i-node 之间的关系](figs/web/05-2_FILEIO-B-open-files.png.jpg)图
    5-2. 文件描述符、打开文件描述符与 i-node 之间的关系'
- en: In process A, descriptors 1 and 20 both refer to the same open file description
    (labeled 23). This situation may arise as a result of a call to *dup()*, *dup2()*,
    or *fcntl()* (see [Duplicating File Descriptors](ch05.html#duplicating_file_descriptors
    "Duplicating File Descriptors")).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在进程 A 中，描述符 1 和 20 都引用相同的打开文件描述（标记为 23）。这种情况可能是由对 *dup()*、*dup2()* 或 *fcntl()*
    的调用引起的（见[复制文件描述符](ch05.html#duplicating_file_descriptors "Duplicating File Descriptors")）。
- en: Descriptor 2 of process A and descriptor 2 of process B refer to a single open
    file description (73). This scenario could occur after a call to *fork()* (i.e.,
    process A is the parent of process B, or vice versa), or if one process passed
    an open descriptor to another process using a UNIX domain socket ([Passing File
    Descriptors](ch61.html#passing_file_descriptors "Passing File Descriptors")).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 进程 A 的描述符 2 和进程 B 的描述符 2 引用同一个打开的文件描述符 (73)。这种情况可能发生在调用 *fork()* 后（即，进程 A 是进程
    B 的父进程，反之亦然），或者如果一个进程通过 UNIX 域套接字将一个打开的描述符传递给另一个进程 ([传递文件描述符](ch61.html#passing_file_descriptors
    "Passing File Descriptors"))。
- en: Finally, we see that descriptor 0 of process A and descriptor 3 of process B
    refer to different open file descriptions, but that these descriptions refer to
    the same i-node table entry (1976)—in other words, to the same file. This occurs
    because each process independently called *open()* for the same file. A similar
    situation could occur if a single process opened the same file twice.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到进程 A 的描述符 0 和进程 B 的描述符 3 引用不同的打开文件描述符，但这些描述符引用的是同一个 i-node 表条目 (1976)——换句话说，指向同一个文件。这是因为每个进程独立地调用
    *open()* 打开了同一个文件。如果是一个进程两次打开同一个文件，也会发生类似的情况。
- en: 'We can draw a number of implications from the preceding discussion:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从前述讨论中得出若干结论：
- en: Two different file descriptors that refer to the same open file description
    share a file offset value. Therefore, if the file offset is changed via one file
    descriptor (as a consequence of calls to *read()*, *write()*, or *lseek()*), this
    change is visible through the other file descriptor. This applies both when the
    two file descriptors belong to the same process and when they belong to different
    processes.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个指向相同打开文件描述符的不同文件描述符共享一个文件偏移值。因此，如果通过一个文件描述符更改了文件偏移（作为调用 *read()*，*write()*
    或 *lseek()* 的结果），该更改在另一个文件描述符中是可见的。这适用于文件描述符属于同一进程或不同进程的情况。
- en: Similar scope rules apply when retrieving and changing the open file status
    flags (e.g., `O_APPEND`, `O_NONBLOCK`, and `O_ASYNC`) using the *fcntl()* `F_GETFL`
    and `F_SETFL` operations.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用 *fcntl()* 的 `F_GETFL` 和 `F_SETFL` 操作来检索和更改打开文件状态标志（例如，`O_APPEND`，`O_NONBLOCK`
    和 `O_ASYNC`）时，也适用类似的作用域规则。
- en: By contrast, the file descriptor flags (i.e., the close-on-exec flag) are private
    to the process and file descriptor. Modifying these flags does not affect other
    file descriptors in the same process or a different process.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相比之下，文件描述符标志（即 close-on-exec 标志）是进程和文件描述符的私有的。修改这些标志不会影响同一进程中其他的文件描述符，也不会影响不同进程中的文件描述符。
- en: Duplicating File Descriptors
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制文件描述符
- en: 'Using the (Bourne shell) I/O redirection syntax `2>&1` informs the shell that
    we wish to have standard error (file descriptor 2) redirected to the same place
    to which standard output (file descriptor 1) is being sent. Thus, the following
    command would (since the shell evaluates I/O directions from left to right) send
    both standard output and standard error to the file `results.log`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 (Bourne shell) 的 I/O 重定向语法 `2>&1` 告诉 shell 我们希望将标准错误（文件描述符 2）重定向到与标准输出（文件描述符
    1）相同的位置。因此，以下命令会（由于 shell 是从左到右评估 I/O 定向）将标准输出和标准错误都发送到文件 `results.log`：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The shell achieves the redirection of standard error by duplicating file descriptor
    2 so that it refers to the same open file description as file descriptor 1 (in
    the same way that descriptors 1 and 20 of process A refer to the same open file
    description in [Figure 5-2](ch05.html#relationship_between_file_descriptors_co
    "Figure 5-2. Relationship between file descriptors, open file descriptions, and
    i-nodes")). This effect can be achieved using the *dup()* and *dup2()* system
    calls.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 通过复制文件描述符 2 来实现标准错误的重定向，使其指向与文件描述符 1 相同的打开文件描述符（就像进程 A 的描述符 1 和描述符 20
    在 [图 5-2](ch05.html#relationship_between_file_descriptors_co "Figure 5-2. Relationship
    between file descriptors, open file descriptions, and i-nodes") 中指向同一个打开的文件描述符一样）。这种效果可以通过
    *dup()* 和 *dup2()* 系统调用来实现。
- en: 'Note that it is not sufficient for the shell simply to open the `results.log`
    file twice: once on descriptor 1 and once on descriptor 2\. One reason for this
    is that the two file descriptors would not share a file offset pointer, and hence
    could end up overwriting each other’s output. Another reason is that the file
    may not be a disk file. Consider the following command, which sends standard error
    down the same pipe as standard output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，仅仅让 shell 打开 `results.log` 文件两次是不够的：一次在描述符 1 上，另一次在描述符 2 上。原因之一是这两个文件描述符不会共享文件偏移指针，因此可能会互相覆盖对方的输出。另一个原因是该文件可能不是磁盘文件。考虑以下命令，它将标准错误输出发送到与标准输出相同的管道中：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The *dup()* call takes *oldfd*, an open file descriptor, and returns a new descriptor
    that refers to the same open file description. The new descriptor is guaranteed
    to be the lowest unused file descriptor.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*dup()* 调用接受 *oldfd*（一个已打开的文件描述符），并返回一个新的描述符，该描述符指向相同的已打开文件描述符。新描述符保证是最小的未使用文件描述符。'
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns (new) file descriptor on success, or -1 on error
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回（新）文件描述符，出错时返回 -1。
- en: 'Suppose we make the following call:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们进行如下调用：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Assuming the normal situation where the shell has opened file descriptors 0,
    1, and 2 on the program’s behalf, and no other descriptors are in use, *dup()*
    will create the duplicate of descriptor 1 using file 3.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在正常情况下，shell 已经为程序打开了文件描述符 0、1 和 2，并且没有其他描述符在使用中，*dup()* 将使用文件 3 创建描述符 1 的副本。
- en: 'If we wanted the duplicate to be descriptor 2, we could use the following technique:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望副本是描述符 2，可以使用以下技巧：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code works only if descriptor 0 was open. To make the above code simpler,
    and to ensure we always get the file descriptor we want, we can use *dup2()*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只有在描述符 0 已经打开时才有效。为了简化上述代码，并确保我们总是获得我们想要的文件描述符，我们可以使用 *dup2()*。
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns (new) file descriptor on success, or -1 on error
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回（新）文件描述符，出错时返回 -1。
- en: The *dup2()* system call makes a duplicate of the file descriptor given in *oldfd*
    using the descriptor number supplied in *newfd*. If the file descriptor specified
    in *newfd* is already open, *dup2()* closes it first. (Any error that occurs during
    this close is silently ignored; safer programming practice is to explicitly *close()
    newfd* if it is open before the call to *dup2()*.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*dup2()* 系统调用通过使用 *newfd* 中提供的描述符号来复制 *oldfd* 给定的文件描述符。如果 *newfd* 指定的文件描述符已经打开，*dup2()*
    会先关闭它。（在关闭过程中发生的任何错误都会被静默忽略；为了更安全的编程实践，建议在调用 *dup2()* 之前显式地 *close()* *newfd*，如果它已经打开。）'
- en: 'We could simplify the preceding calls to *close()* and *dup()* to the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将之前的 *close()* 和 *dup()* 调用简化为如下：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A successful *dup2()* call returns the number of the duplicate descriptor (i.e.,
    the value passed in *newfd*).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的 *dup2()* 调用会返回副本描述符的编号（即传入 *newfd* 的值）。
- en: If *oldfd* is not a valid file descriptor, then *dup2()* fails with the error
    `EBADF` and *newfd* is not closed. If *oldfd* is a valid file descriptor, and
    *oldfd* and *newfd* have the same value, then *dup2()* does nothing—*newfd* is
    not closed, and *dup2()* returns the *newfd* as its function result.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *oldfd* 不是有效的文件描述符，则 *dup2()* 会因错误 `EBADF` 而失败，并且 *newfd* 不会被关闭。如果 *oldfd*
    是有效的文件描述符，并且 *oldfd* 和 *newfd* 的值相同，则 *dup2()* 不做任何操作——*newfd* 不会被关闭，*dup2()*
    会返回 *newfd* 作为它的函数结果。
- en: 'A further interface that provides some extra flexibility for duplicating file
    descriptors is the *fcntl()* `F_DUPFD` operation:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 提供更多灵活性以便复制文件描述符的另一个接口是 *fcntl()* 的 `F_DUPFD` 操作：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This call makes a duplicate of *oldfd* by using the lowest unused file descriptor
    greater than or equal to *startfd*. This is useful if we want a guarantee that
    the new descriptor (*newfd*) falls in a certain range of values. Calls to *dup()*
    and *dup2()* can always be recoded as calls to *close()* and *fcntl()*, although
    the former calls are more concise. (Note also that some of the *errno* error codes
    returned by *dup2()* and *fcntl()* differ, as described in the manual pages.)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该调用通过使用大于或等于 *startfd* 的最小未使用文件描述符来复制 *oldfd*。如果我们希望确保新描述符（*newfd*）落在某个特定的值范围内，这非常有用。对
    *dup()* 和 *dup2()* 的调用总是可以重新编写为对 *close()* 和 *fcntl()* 的调用，尽管前者的调用更简洁。（还要注意，*dup2()*
    和 *fcntl()* 返回的一些 *errno* 错误代码不同，具体描述见手册页面。）
- en: From [Figure 5-2](ch05.html#relationship_between_file_descriptors_co "Figure 5-2. Relationship
    between file descriptors, open file descriptions, and i-nodes"), we can see that
    duplicate file descriptors share the same file offset value and status flags in
    their shared open file description. However, the new file descriptor has its own
    set of file descriptor flags, and its close-on-exec flag (`FD_CLOEXEC`) is always
    turned off. The interfaces that we describe next allow explicit control of the
    new file descriptor’s close-on-exec flag.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从[图 5-2](ch05.html#relationship_between_file_descriptors_co "图 5-2. 文件描述符、打开的文件描述和
    i-nodes 之间的关系")中，我们可以看到，复制的文件描述符共享同一文件偏移量值和状态标志，在它们共享的打开文件描述中。但是，新文件描述符有自己的文件描述符标志，并且其关闭时执行标志（`FD_CLOEXEC`）始终关闭。我们接下来描述的接口允许显式控制新文件描述符的关闭时执行标志。
- en: The *dup3()* system call performs the same task as *dup2()*, but adds an additional
    argument, *flags*, that is a bit mask that modifies the behavior of the system
    call.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*dup3()* 系统调用执行的任务与 *dup2()* 相同，但添加了一个额外的参数 *flags*，它是一个位掩码，用于修改系统调用的行为。'
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns (new) file descriptor on success, or -1 on error
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回（新）文件描述符，出错时返回 -1
- en: Currently, *dup3()* supports one flag, `O_CLOEXEC`, which causes the kernel
    to enable the close-on-exec flag (`FD_CLOEXEC`) for the new file descriptor. This
    flag is useful for the same reasons as the *open()* `O_CLOEXEC` flag described
    in [File descriptor number returned by *open()*](ch04.html#file_descriptor_number_returned_by-id1
    "File descriptor number returned by open()").
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，*dup3()* 支持一个标志，`O_CLOEXEC`，该标志使内核为新文件描述符启用关闭时执行标志（`FD_CLOEXEC`）。这个标志与在[文件描述符号由
    *open()* 返回](ch04.html#file_descriptor_number_returned_by-id1 "文件描述符号由 open()
    返回")中描述的 *open()* `O_CLOEXEC` 标志具有相同的用途。
- en: The *dup3()* system call is new in Linux 2.6.27, and is Linux-specific.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*dup3()* 系统调用是 Linux 2.6.27 中新增的，并且是 Linux 特有的。'
- en: 'Since Linux 2.6.24, Linux also supports an additional *fcntl()* operation for
    duplicating file descriptors: `F_DUPFD_CLOEXEC`. This flag does the same thing
    as `F_DUPFD`, but additionally sets the close-on-exec flag (`FD_CLOEXEC`) for
    the new file descriptor. Again, this operation is useful for the same reasons
    as the *open()* `O_CLOEXEC` flag. `F_DUPFD_CLOEXEC` is not specified in SUSv3,
    but is specified in SUSv4.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Linux 2.6.24 起，Linux 还支持一个额外的 *fcntl()* 操作，用于复制文件描述符：`F_DUPFD_CLOEXEC`。该标志与
    `F_DUPFD` 执行相同的操作，但额外为新文件描述符设置了关闭时执行标志（`FD_CLOEXEC`）。同样，这个操作对于与 *open()* 中的 `O_CLOEXEC`
    标志相同的原因是有用的。`F_DUPFD_CLOEXEC` 在 SUSv3 中没有指定，但在 SUSv4 中有指定。
- en: 'File I/O at a Specified Offset: *pread()* and *pwrite()*'
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在指定偏移量处进行文件 I/O：*pread()* 和 *pwrite()*
- en: The *pread()* and *pwrite()* system calls operate just like *read()* and *write()*,
    except that the file I/O is performed at the location specified by *offset*, rather
    than at the current file offset. The file offset is left unchanged by these calls.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*pread()* 和 *pwrite()* 系统调用的操作方式与 *read()* 和 *write()* 相似，唯一不同的是文件 I/O 是在由
    *offset* 指定的位置执行，而不是在当前文件偏移量处执行。这些调用不会改变文件偏移量。'
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of bytes read, 0 on EOF, or -1 on error
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 返回读取的字节数，遇到 EOF 时返回 0，出错时返回 -1
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of bytes written, or -1 on error
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 返回写入的字节数，或者在出错时返回 -1
- en: 'Calling *pread()* is equivalent to *atomically* performing the following calls:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 *pread()* 相当于 *原子地* 执行以下调用：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For both *pread()* and *pwrite()*, the file referred to by *fd* must be seekable
    (i.e., a file descriptor on which it is permissible to call *lseek()*).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *pread()* 和 *pwrite()*，*fd* 所指代的文件必须是可寻址的（即，文件描述符必须允许调用 *lseek()*）。
- en: 'These system calls can be particularly useful in multithreaded applications.
    As we’ll see in [Chapter 29](ch29.html "Chapter 29. Threads: Introduction"), all
    of the threads in a process share the same file descriptor table. This means that
    the file offset for each open file is global to all threads. Using *pread()* or
    *pwrite()*, multiple threads can simultaneously perform I/O on the same file descriptor
    without being affected by changes made to the file offset by other threads. If
    we attempted to use *lseek()* plus *read()* (or *write()*) instead, then we would
    create a race condition similar to the one that we described when discussing the
    `O_APPEND` flag in Section 5.1\. (The *pread()* and *pwrite()* system calls can
    similarly be useful for avoiding race conditions in applications where multiple
    processes have file descriptors referring to the same open file description.)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统调用在多线程应用中尤为有用。正如我们在[第29章](ch29.html "第29章：线程简介")中看到的，进程中的所有线程共享相同的文件描述符表。这意味着每个打开文件的文件偏移对于所有线程来说是全局的。通过使用*pread()*或*pwrite()*，多个线程可以同时对相同的文件描述符执行I/O，而不会受到其他线程修改文件偏移的影响。如果我们尝试使用*lseek*()加*read*()（或*write*()）来代替，那么我们会创建一个竞争条件，类似于我们在讨论第5.1节中的`O_APPEND`标志时描述的情况。（*pread()*和*pwrite()*系统调用同样可以用于避免多个进程对同一文件描述符进行I/O时出现的竞争条件。）
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If we are repeatedly performing *lseek()* calls followed by file I/O, then
    the *pread()* and *pwrite()* system calls can also offer a performance advantage
    in some cases. This is because the cost of a single *pread()* (or *pwrite()*)
    system call is less than the cost of two system calls: *lseek()* and *read()*
    (or *write()*). However, the cost of system calls is usually dwarfed by the time
    required to actually perform I/O.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们反复执行*lseek()*调用并随后进行文件I/O，那么在某些情况下，*pread()*和*pwrite()*系统调用也能提供性能优势。这是因为单个*pread*（或*pwrite*）系统调用的成本低于两个系统调用的成本：*lseek*()和*read*()（或*write*()）。然而，系统调用的成本通常相较于实际执行I/O所需的时间来说微不足道。
- en: 'Scatter-Gather I/O: *readv()* and *writev()*'
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分散-聚集 I/O：*readv()* 和 *writev()*
- en: The *readv()* and *writev()* system calls perform scatter-gather I/O.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*readv()*和*writev()*系统调用执行分散-聚集I/O。'
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of bytes read, 0 on EOF, or -1 on error
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 返回读取的字节数，EOF时返回0，出错时返回-1
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of bytes written, or -1 on error
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 返回写入的字节数，出错时返回-1
- en: 'Instead of accepting a single buffer of data to be read or written, these functions
    transfer multiple buffers of data in a single system call. The set of buffers
    to be transferred is defined by the array *iov*. The integer *iovcnt* specifies
    the number of elements in *iov*. Each element of *iov* is a structure of the following
    form:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数不是接受单个数据缓冲区进行读取或写入，而是在一次系统调用中传输多个数据缓冲区。要传输的缓冲区集合由数组*iov*定义。整数*iovcnt*指定*iov*中元素的数量。*iov*的每个元素都是如下结构：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 allows an implementation to place a limit on the number of elements in
    *iov*. An implementation can advertise its limit by defining `IOV_MAX` in `<limits.h>`
    or at run time via the return from the call *sysconf(_SC_IOV_MAX)*. (We describe
    *sysconf()* in Section 11.2.) SUSv3 requires that this limit be at least 16\.
    On Linux, `IOV_MAX` is defined as 1024, which corresponds to the kernel’s limit
    on the size of this vector (defined by the kernel constant `UIO_MAXIOV`).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3允许实现对*iov*中的元素数量设置限制。实现可以通过在`<limits.h>`中定义`IOV_MAX`或通过运行时调用*sysconf(_SC_IOV_MAX)*的返回值来宣传其限制。（我们在第11.2节中描述了*sysconf*()）。SUSv3要求此限制至少为16。在Linux中，`IOV_MAX`被定义为1024，这对应于内核对该向量大小的限制（由内核常量`UIO_MAXIOV`定义）。
- en: However, the *glibc* wrapper functions for *readv()* and *writev()* silently
    do some extra work. If the system call fails because *iovcnt* is too large, then
    the wrapper function temporarily allocates a single buffer large enough to hold
    all of the items described by *iov* and performs a *read()* or *write()* call
    (see the discussion below of how *writev()* could be implemented in terms of *write()*).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，*glibc*对*readv()*和*writev()*的封装函数会悄悄地做一些额外的工作。如果系统调用因*iovcnt*过大而失败，那么封装函数会临时分配一个足够大的单个缓冲区来容纳所有由*iov*描述的项，并执行*read*()或*write*()调用（见下文关于如何通过*write*()实现*writev*()的讨论）。
- en: '[Figure 5-3](ch05.html#example_of_an_iovec_array_and_associated "Figure 5-3. Example
    of an iovec array and associated buffers") shows an example of the relationship
    between the *iov* and *iovcnt* arguments, and the buffers to which they refer.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-3](ch05.html#example_of_an_iovec_array_and_associated "图 5-3. *iovec*
    数组及其相关缓冲区的示例") 显示了 *iov* 和 *iovcnt* 参数与它们所指缓冲区之间的关系示例。'
- en: '![Example of an iovec array and associated buffers](figs/web/05-3_FILEIO-B-iov-scale90.png.jpg)Figure 5-3. Example
    of an *iovec* array and associated buffers'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![iovec 数组及其相关缓冲区示例](figs/web/05-3_FILEIO-B-iov-scale90.png.jpg)图 5-3. *iovec*
    数组及其相关缓冲区示例'
- en: Scatter input
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分散输入
- en: 'The *readv()* system call performs *scatter input*: it reads a contiguous sequence
    of bytes from the file referred to by the file descriptor *fd* and places (“scatters”)
    these bytes into the buffers specified by *iov*. Each of the buffers, starting
    with the one defined by *iov[0]*, is completely filled before *readv()* proceeds
    to the next buffer.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*readv()* 系统调用执行 *分散输入*：它从 *fd* 所引用的文件中读取一系列连续的字节，并将这些字节（“分散”）放入由 *iov* 指定的缓冲区中。每个缓冲区，从
    *iov[0]* 定义的缓冲区开始，在 *readv()* 继续到下一个缓冲区之前都必须完全填满。'
- en: An important property of *readv()* is that it completes atomically; that is,
    from the point of view of the calling process, the kernel performs a single data
    transfer between the file referred to by *fd* and user memory. This means, for
    example, that when reading from a file, we can be sure that the range of bytes
    read is contiguous, even if another process (or thread) sharing the same file
    offset attempts to manipulate the offset at the same time as the *readv()* call.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*readv()* 的一个重要特性是它以原子操作完成；也就是说，从调用进程的角度来看，内核在 *fd* 所引用的文件和用户内存之间执行单次数据传输。这意味着，例如，当从文件中读取时，即使另一个进程（或线程）正在共享相同的文件偏移并尝试同时操作偏移，仍然可以确保读取的字节范围是连续的。'
- en: On successful completion, *readv()* returns the number of bytes read, or 0 if
    end-of-file was encountered. The caller must examine this count to verify whether
    all requested bytes were read. If insufficient data was available, then only some
    of the buffers may have been filled, and the last of these may be only partially
    filled.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功完成后，*readv()* 返回读取的字节数，如果遇到文件结束符则返回 0。调用者必须检查此计数，以验证是否读取了所有请求的字节。如果数据不足，则可能只有部分缓冲区被填充，且最后一个缓冲区可能只部分填充。
- en: '[Example 5-2](ch05.html#performing_scatter_input_with_readv_open "Example 5-2. Performing
    scatter input with readv()") demonstrates the use of *readv()*.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-2](ch05.html#performing_scatter_input_with_readv_open "示例 5-2. 使用 readv()
    执行分散输入") 演示了 *readv()* 的使用。'
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using the prefix `t_` followed by a function name as the name of an example
    program (e.g., `t_readv.c` in [Example 5-2](ch05.html#performing_scatter_input_with_readv_open
    "Example 5-2. Performing scatter input with readv()")) is our way of indicating
    that the program primarily demonstrates the use of a single system call or library
    function.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前缀 `t_` 后跟函数名作为示例程序的名称（例如，[示例 5-2](ch05.html#performing_scatter_input_with_readv_open
    "示例 5-2. 使用 readv() 执行分散输入") 中的 `t_readv.c`）是我们表示该程序主要演示单一系统调用或库函数使用的一种方式。
- en: Example 5-2. Performing scatter input with *readv()*
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-2. 使用 *readv()* 执行分散输入
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Gather output
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 聚集输出
- en: The *writev()* system call performs *gather output*. It concatenates (“gathers”)
    data from all of the buffers specified by *iov* and writes them as a sequence
    of contiguous bytes to the file referred to by the file descriptor *fd*. The buffers
    are gathered in array order, starting with the buffer defined by *iov[0]*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*writev()* 系统调用执行 *聚集输出*。它将所有由 *iov* 指定的缓冲区中的数据连接（“聚集”）起来，并作为一系列连续的字节写入到 *fd*
    所引用的文件中。这些缓冲区按照数组顺序收集，从 *iov[0]* 定义的缓冲区开始。'
- en: Like *readv()*, *writev()* completes atomically, with all data being transferred
    in a single operation from user memory to the file referred to by *fd*. Thus,
    when writing to a regular file, we can be sure that all of the requested data
    is written contiguously to the file, rather than being interspersed with writes
    by other processes (or threads).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *readv()* 类似，*writev()* 完成原子操作，所有数据都以单次操作从用户内存传输到 *fd* 所引用的文件中。因此，当写入常规文件时，我们可以确保所有请求的数据都连续地写入文件，而不是与其他进程（或线程）的写入交织在一起。
- en: As with *write()*, a partial write is possible. Therefore, we must check the
    return value from *writev()* to see if all requested bytes were written.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *write()* 一样，部分写入是可能的。因此，我们必须检查 *writev()* 的返回值，以查看是否写入了所有请求的字节。
- en: 'The primary advantages of *readv()* and *writev()* are convenience and speed.
    For example, we could replace a call to *writev()* by either:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*readv()* 和 *writev()* 的主要优点是便利性和速度。例如，我们可以通过以下方式替换对 *writev()* 的调用：'
- en: code that allocates a single large buffer, copies the data to be written from
    other locations in the process’s address space into that buffer, and then calls
    *write()* to output the buffer; or
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配一个大的单一缓冲区，将要写入的数据从进程地址空间中的其他位置复制到该缓冲区，然后调用 *write()* 输出缓冲区；或者
- en: a series of *write()* calls that output the buffers individually.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列单独输出缓冲区的 *write()* 调用。
- en: The first of these options, while semantically equivalent to using *writev()*,
    leaves us with the inconvenience (and inefficiency) of allocating buffers and
    copying data in user space.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项中的第一个，在语义上等同于使用 *writev()*，但我们面临着在用户空间分配缓冲区和复制数据的不便（以及低效）。
- en: The second option is not semantically equivalent to a single call to *writev()*,
    since the *write()* calls are not performed atomically. Furthermore, performing
    a single *writev()* system call is cheaper than performing multiple *write()*
    calls (refer to the discussion of system calls in [System Calls](ch03.html#system_calls
    "System Calls")).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项在语义上不等同于对 *writev()* 的单次调用，因为 *write()* 调用不是原子操作。此外，执行一次 *writev()* 系统调用比执行多个
    *write()* 调用更便宜（参见 [系统调用](ch03.html#system_calls "系统调用") 中的系统调用讨论）。
- en: Performing scatter-gather I/O at a specified offset
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在指定偏移量执行散列聚集I/O
- en: 'Linux 2.6.30 adds two new system calls that combine scatter-gather I/O functionality
    with the ability to perform the I/O at a specified offset: *preadv()* and *pwritev()*.
    These system calls are nonstandard, but are also available on the modern BSDs.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 2.6.30 添加了两个新系统调用，将散列聚集 I/O 功能与在指定偏移量执行 I/O 的能力结合起来：*preadv()* 和 *pwritev()*。这些系统调用是非标准的，但在现代
    BSD 系统中也可用。
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of bytes read, 0 on EOF, or -1 on error
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 返回读取的字节数，EOF 时返回 0，出错时返回 -1
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of bytes written, or -1 on error
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 返回写入的字节数，出错时返回-1
- en: The *preadv()* and *pwritev()* system calls perform the same task as *readv()*
    and *writev()*, but perform the I/O at the file location specified by *offset*
    (like *pread()* and *pwrite()*).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*preadv()* 和 *pwritev()* 系统调用执行与 *readv()* 和 *writev()* 相同的任务，但在由 *offset*
    指定的文件位置执行 I/O（类似于 *pread()* 和 *pwrite()*）。'
- en: These system calls are useful for applications (e.g., multithreaded applications)
    that want to combine the benefits of scatter-gather I/O with the ability to perform
    I/O at a location that is independent of the current file offset.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统调用对希望结合散列聚集 I/O 优势，并能够在与当前文件偏移量无关的位置执行 I/O 的应用程序（例如，多线程应用程序）非常有用。
- en: 'Truncating a File: *truncate()* and *ftruncate()*'
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 截断文件：*truncate()* 和 *ftruncate()*
- en: The *truncate()* and *ftruncate()* system calls set the size of a file to the
    value specified by *length*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*truncate()* 和 *ftruncate()* 系统调用将文件的大小设置为由 *length* 指定的值。'
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return 0 on success, or -1 on error
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时两者均返回 0，出错时返回 -1
- en: If the file is longer than *length*, the excess data is lost. If the file is
    currently shorter than *length*, it is extended by padding with a sequence of
    null bytes or a hole.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件长度大于 *length*，多余的数据将丢失。如果文件当前长度小于 *length*，它将通过填充一系列空字节或孔来扩展。
- en: The difference between the two system calls lies in how the file is specified.
    With *truncate()*, the file, which must be accessible and writable, is specified
    as a pathname string. If *pathname* is a symbolic link, it is dereferenced. The
    *ftruncate()* system call takes a descriptor for a file that has been opened for
    writing. It doesn’t change the file offset for the file.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个系统调用的区别在于文件的指定方式。使用 *truncate()* 时，文件必须是可访问且可写的，并通过路径名字符串指定。如果 *pathname*
    是符号链接，它将被解引用。*ftruncate()* 系统调用需要一个已打开且可写的文件描述符。它不会改变文件的偏移量。
- en: 'If the *length* argument to *ftruncate()* exceeds the current file size, SUSv3
    allows two possible behaviors: either the file is extended (as on Linux) or the
    system call returns an error. XSI-conformant systems must adopt the former behavior.
    SUSv3 requires that *truncate()* always extend the file if *length* is greater
    than the current file size.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *ftruncate()* 的 *length* 参数大于当前文件大小，SUSv3 允许两种可能的行为：文件被扩展（如同 Linux）或系统调用返回错误。符合
    XSI 标准的系统必须采用前者行为。SUSv3 要求如果 *length* 大于当前文件大小，*truncate()* 必须始终扩展文件。
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *truncate()* system call is unique in being the only system call that can
    change the contents of a file without first obtaining a descriptor for the file
    via *open()* (or by some other means).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*truncate()*系统调用的独特之处在于它是唯一可以在不通过*open()*（或其他方式）先获取文件描述符的情况下改变文件内容的系统调用。'
- en: Nonblocking I/O
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非阻塞I/O
- en: 'Specifying the `O_NONBLOCK` flag when opening a file serves two purposes:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开文件时指定`O_NONBLOCK`标志有两个目的：
- en: If the file can’t be opened immediately, then *open()* returns an error instead
    of blocking. One case where *open()* can block is with FIFOs ([FIFOs](ch44.html#fifos
    "FIFOs")).
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件不能立即打开，则*open()*返回一个错误，而不是阻塞。*open()*可能会阻塞的一种情况是使用FIFO（[FIFO](ch44.html#fifos
    "FIFO")）。
- en: After a successful *open()*, subsequent I/O operations are also nonblocking.
    If an I/O system call can’t complete immediately, then either a partial data transfer
    is performed or the system call fails with one of the errors `EAGAIN` or `EWOULDBLOCK`.
    Which error is returned depends on the system call. On Linux, as on many UNIX
    implementations, these two error constants are synonymous.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在成功调用*open()*之后，随后的I/O操作也是非阻塞的。如果一个I/O系统调用不能立即完成，则会执行部分数据传输，或者系统调用会以`EAGAIN`或`EWOULDBLOCK`错误之一失败。返回哪个错误取决于系统调用。在Linux上，与许多UNIX实现一样，这两个错误常量是同义的。
- en: Nonblocking mode can be used with devices (e.g., terminals and pseudoterminals),
    pipes, FIFOs, and sockets. (Because file descriptors for pipes and sockets are
    not obtained using *open()*, we must enable this flag using the *fcntl()* `F_SETFL`
    operation described in Section 5.3.)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞模式可以用于设备（例如终端和伪终端）、管道、FIFO和套接字。（由于管道和套接字的文件描述符不是通过*open()*获取的，我们必须使用*fcntl()*中的`F_SETFL`操作来启用此标志，如第5.3节所述。）
- en: '`O_NONBLOCK` is generally ignored for regular files, because the kernel buffer
    cache ensures that I/O on regular files does not block, as described in Section
    13.1\. However, `O_NONBLOCK` does have an effect for regular files when mandatory
    file locking is employed ([Mandatory Locking](ch55.html#mandatory_locking "Mandatory
    Locking")).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常规文件，`O_NONBLOCK`通常会被忽略，因为内核缓冲区缓存确保常规文件的I/O不会阻塞，如第13.1节所述。然而，当使用强制文件锁定时，`O_NONBLOCK`对常规文件是有效的（[强制锁定](ch55.html#mandatory_locking
    "强制锁定")）。
- en: We say more about nonblocking I/O in [Nonblocking I/O](ch44.html#nonblocking_i_solidus_o-id1
    "Nonblocking I/O") and in [Chapter 63](ch63.html "Chapter 63. Alternative I/O
    Models").
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[非阻塞I/O](ch44.html#nonblocking_i_solidus_o-id1 "非阻塞I/O")和[第63章](ch63.html
    "第63章. 其他I/O模型")中进一步讨论非阻塞I/O。
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Historically, System V-derived implementations provided the `O_NDELAY` flag,
    with similar semantics to `O_NONBLOCK`. The main difference was that a nonblocking
    *write()* on System V returned 0 if a *write()* could not be completed or if no
    input was available to satisfy a *read()*. This behavior was problematic for *read()*
    because it was indistinguishable from an end-of-file condition, and so the first
    POSIX.1 standard introduced `O_NONBLOCK`. Some UNIX implementations continue to
    provide the `O_NDELAY` flag with the old semantics. On Linux, the `O_NDELAY` constant
    is defined, but it is synonymous with `O_NONBLOCK`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，源自System V的实现提供了`O_NDELAY`标志，其语义类似于`O_NONBLOCK`。主要的区别是，System V上的非阻塞*write()*在*write()*无法完成或没有输入可以满足*read()*时返回0。这种行为对于*read()*来说是有问题的，因为它与文件结束条件无法区分，因此第一个POSIX.1标准引入了`O_NONBLOCK`。一些UNIX实现继续提供`O_NDELAY`标志及其旧语义。在Linux上，`O_NDELAY`常量已定义，但它与`O_NONBLOCK`同义。
- en: I/O on Large Files
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大文件的I/O
- en: The *off_t* data type used to hold a file offset is typically implemented as
    a signed long integer. (A signed data type is required because the value -1 is
    used for representing error conditions.) On 32-bit architectures (such as x86-32)
    this would limit the size of files to 2^(31)–1 bytes (i.e., 2 GB).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 用于存储文件偏移量的*off_t*数据类型通常实现为有符号长整型。（需要有符号数据类型，因为-1的值用于表示错误条件。）在32位架构（例如x86-32）上，这将限制文件大小为2^(31)-1字节（即2GB）。
- en: However, the capacity of disk drives long ago exceeded this limit, and thus
    the need arose for 32-bit UNIX implementations to handle files larger than this
    size. Since this is a problem common to many implementations, a consortium of
    UNIX vendors cooperated on the *Large File Summit* (LFS), to enhance the SUSv2
    specification with the extra functionality required to access large files. We
    outline the LFS enhancements in this section. (The complete LFS specification,
    finalized in 1996, can be found at [http://opengroup.org/platform/lfs.html](http://opengroup.org/platform/lfs.html).)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，磁盘驱动器的容量早已超过了这一限制，因此需要 32 位 UNIX 实现来处理比这个大小更大的文件。由于这是许多实现中普遍存在的问题，UNIX 厂商的联盟在
    *Large File Summit*（LFS）上进行了合作，增强了 SUSv2 规范，加入了访问大文件所需的额外功能。我们在本节中概述了 LFS 的增强功能。（完整的
    LFS 规范已于 1996 年定稿，可以在 [http://opengroup.org/platform/lfs.html](http://opengroup.org/platform/lfs.html)
    找到。）
- en: Linux has provided LFS support on 32-bit systems since kernel 2.4 (*glibc* 2.2
    or later is also required). In addition, the corresponding file system must also
    support large files. Most native Linux file systems provide this support, but
    some nonnative file systems do not (notable examples are Microsoft’s VFAT and
    NFSv2, both of which impose hard limits of 2 GB, regardless of whether the LFS
    extensions are employed).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 从 2.4 版本的内核开始就为 32 位系统提供了 LFS 支持（同时需要 *glibc* 2.2 或更高版本）。此外，相应的文件系统必须也支持大文件。大多数原生的
    Linux 文件系统提供了这一支持，但一些非原生文件系统并不支持（显著的例子包括微软的 VFAT 和 NFSv2，它们都强加了 2 GB 的硬性限制，无论是否使用了
    LFS 扩展）。
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because long integers use 64 bits on 64-bit architectures (e.g., Alpha, IA-64),
    these architectures generally don’t suffer the limitations that the LFS enhancements
    were designed to address. Nevertheless, the implementation details of some native
    Linux file systems mean that the theoretical maximum size of a file may be less
    than 2^(63)–1, even on 64-bit systems. In most cases, these limits are much higher
    than current disk sizes, so they don’t impose a practical limitation on file sizes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在 64 位架构上长整型使用 64 位（例如，Alpha、IA-64），这些架构通常不会遇到 LFS 增强功能所针对的限制。然而，一些原生 Linux
    文件系统的实现细节意味着，即使在 64 位系统上，文件的理论最大大小也可能小于 2^(63)–1。在大多数情况下，这些限制远高于当前磁盘的大小，因此它们对文件大小并不构成实际限制。
- en: 'We can write applications requiring LFS functionality in one of two ways:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式编写需要 LFS 功能的应用程序：
- en: Use an alternative API that supports large files. This API was designed by the
    LFS as a “transitional extension” to the Single UNIX Specification. Thus, this
    API is not required to be present on systems conforming to SUSv2 or SUSv3, but
    many conforming systems do provide it. This approach is now obsolete.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用支持大文件的替代 API。这个 API 是 LFS 作为“过渡扩展”设计的，用于单一 UNIX 规范。因此，这个 API 并不要求在符合 SUSv2
    或 SUSv3 的系统上必须存在，但许多符合规范的系统确实提供了它。这个方法现在已经过时。
- en: Define the `_FILE_OFFSET_BITS` macro with the value 64 when compiling our programs.
    This is the preferred approach, because it allows conforming applications to obtain
    LFS functionality without making any source code changes.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译我们的程序时，将`_FILE_OFFSET_BITS`宏定义为 64。这是推荐的做法，因为它允许符合规范的应用程序在不修改任何源代码的情况下获得
    LFS 功能。
- en: The transitional LFS API
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 过渡性的 LFS API
- en: To use the transitional LFS API, we must define the `_LARGEFILE64_SOURCE` feature
    test macro when compiling our program, either on the command line, or within the
    source file before including any header files. This API provides functions capable
    of handling 64-bit file sizes and offsets. These functions have the same names
    as their 32-bit counterparts, but have the suffix *64* appended to the function
    name. Among these functions are *fopen64()*, *open64()*, *lseek64()*, *truncate64()*,
    *stat64()*, *mmap64()*, and *setrlimit64()*. (We’ve already described some of
    the 32-bit counterparts of these functions; others are described in later chapters.)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用过渡性的 LFS API，我们必须在编译程序时定义`_LARGEFILE64_SOURCE`功能测试宏，可以在命令行中定义，或者在源文件中包含任何头文件之前定义。这个
    API 提供了能够处理 64 位文件大小和偏移量的函数。这些函数与其 32 位版本同名，但在函数名后加上了后缀 *64*。这些函数包括 *fopen64()*、*open64()*、*lseek64()*、*truncate64()*、*stat64()*、*mmap64()*
    和 *setrlimit64()*。（我们已经描述了其中一些 32 位函数的对应版本；其他版本将在后续章节中描述。）
- en: 'In order to access a large file, we simply use the 64-bit version of the function.
    For example, to open a large file, we could write the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问大文件，我们只需使用 64 位版本的函数。例如，要打开一个大文件，我们可以写如下代码：
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Calling *open64()* is equivalent to specifying the `O_LARGEFILE` flag when calling
    *open()*. Attempts to open a file larger than 2 GB by calling *open()* without
    this flag return an error.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 *open64()* 相当于在调用 *open()* 时指定 `O_LARGEFILE` 标志。如果在没有该标志的情况下调用 *open()* 来打开一个大于
    2 GB 的文件，则会返回错误。
- en: 'In addition to the aforementioned functions, the transitional LFS API adds
    some new data types, including:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前述函数外，过渡性的 LFS API 还增加了一些新的数据类型，包括：
- en: '*struct stat64*: an analog of the *stat* structure ([Retrieving File Information:
    *stat()*](ch15.html#retrieving_file_information_colon_stat_o "Retrieving File
    Information: stat()")) allowing for large file sizes.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*struct stat64*：*stat* 结构的类似物（[检索文件信息：*stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "检索文件信息：stat()")），允许处理大文件大小。'
- en: '*off64_t*: a 64-bit type for representing file offsets.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*off64_t*：一种用于表示文件偏移量的 64 位类型。'
- en: 'The *off64_t* data type is used with (among others) the *lseek64()* function,
    as shown in [Example 5-3](ch05.html#accessing_large_files "Example 5-3. Accessing
    large files"). This program takes two command-line arguments: the name of a file
    to be opened and an integer value specifying a file offset. The program opens
    the specified file, seeks to the given file offset, and then writes a string.
    The following shell session demonstrates the use of the program to seek to a very
    large offset in the file (greater than 10 GB) and then write some bytes:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*off64_t* 数据类型与 (*lseek64()*) 函数等一起使用，如 [示例 5-3](ch05.html#accessing_large_files
    "示例 5-3. 访问大文件") 中所示。此程序接受两个命令行参数：要打开的文件名和一个整数值，用于指定文件偏移量。程序打开指定的文件，跳转到给定的文件偏移量，然后写入一个字符串。以下的
    shell 会话演示了如何使用该程序跳转到文件中的一个非常大的偏移量（超过 10 GB），然后写入一些字节：'
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Example 5-3. Accessing large files
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-3. 访问大文件
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `_FILE_OFFSET_BITS` macro
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`_FILE_OFFSET_BITS` 宏'
- en: 'The recommended method of obtaining LFS functionality is to define the macro
    `_FILE_OFFSET_BITS` with the value 64 when compiling a program. One way to do
    this is via a command-line option to the C compiler:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 LFS 功能的推荐方法是，在编译程序时定义宏 `_FILE_OFFSET_BITS` 并将其值设置为 64。实现此目的的一种方式是通过 C 编译器的命令行选项：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Alternatively, we can define this macro in the C source before including any
    header files:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在包含任何头文件之前，在 C 源代码中定义此宏：
- en: '[PRE32]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This automatically converts all of the relevant 32-bit functions and data types
    into their 64-bit counterparts. Thus, for example, calls to *open()* are actually
    converted into calls to *open64()*, and the *off_t* data type is defined to be
    64 bits long. In other words, we can recompile an existing program to handle large
    files without needing to make any changes to the source code.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这会自动将所有相关的 32 位函数和数据类型转换为其 64 位对应物。例如，*open()* 的调用实际上会转换为对 *open64()* 的调用，而
    *off_t* 数据类型被定义为 64 位长。换句话说，我们可以重新编译现有程序来处理大文件，而无需更改源代码。
- en: Using `_FILE_OFFSET_BITS` is clearly simpler than using the transitional LFS
    API, but this approach relies on applications being cleanly written (e.g., correctly
    using *off_t* to declare variables holding file offsets, rather than using a native
    C integer type).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `_FILE_OFFSET_BITS` 显然比使用过渡性的 LFS API 更简便，但这种方法依赖于应用程序的清晰编写（例如，正确使用 *off_t*
    来声明保存文件偏移量的变量，而不是使用本地 C 整数类型）。
- en: The `_FILE_OFFSET_BITS` macro is not required by the LFS specification, which
    merely mentions this macro as an optional method of specifying the size of the
    *off_t* data type. Some UNIX implementations use a different feature test macro
    to obtain this functionality.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`_FILE_OFFSET_BITS` 宏不是 LFS 规范所要求的，LFS 规范仅提到此宏作为指定 *off_t* 数据类型大小的可选方法。一些 UNIX
    实现使用不同的功能测试宏来获得此功能。'
- en: Note
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If we attempt to access a large file using 32-bit functions (i.e., from a program
    compiled without setting `_FILE_OFFSET_BITS` to 64), then we may encounter the
    error `EOVERFLOW`. For example, this error can occur if we attempt to use the
    32-bit version of *stat()* ([Retrieving File Information: *stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "Retrieving File Information: stat()")) to retrieve information about a file whose
    size exceeds 2 GB.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用 32 位函数访问大文件（即，从未设置 `_FILE_OFFSET_BITS` 为 64 的程序编译），则可能会遇到错误 `EOVERFLOW`。例如，如果我们尝试使用
    32 位版本的 *stat()* （[检索文件信息：*stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "检索文件信息：stat()")）来检索一个大小超过 2 GB 的文件信息时，就可能发生此错误。
- en: Passing *off_t* values to *printf()*
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将 *off_t* 值传递给 *printf()*
- en: 'One problem that the LFS extensions don’t solve for us is how to pass *off_t*
    values to *printf()* calls. In [System Data Types](ch03.html#system_data_types
    "System Data Types"), we noted that the portable method of displaying values of
    one of the predefined system data types (e.g., *pid_t* or *uid_t*) was to cast
    that value to *long*, and use the `%ld` *printf()* specifier. However, if we are
    employing the LFS extensions, then this is often not sufficient for the *off_t*
    data type, because it may be defined as a type larger than *long*, typically *long
    long*. Therefore, to display a value of type *off_t*, we cast it to *long long*
    and use the `%lld` *printf()* specifier, as in the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: LFS 扩展没有为我们解决的一个问题是如何将*off_t*值传递给*printf()*调用。在[系统数据类型](ch03.html#system_data_types
    "System Data Types")中，我们提到，显示预定义系统数据类型之一（例如*pid_t*或*uid_t*）的值的便携式方法是将该值转换为*long*类型，并使用`%ld`
    *printf()* 格式说明符。然而，如果我们使用了 LFS 扩展，这通常不足以处理*off_t*数据类型，因为它可能被定义为比*long*更大的类型，通常是*long
    long*。因此，为了显示*off_t*类型的值，我们将其转换为*long long*类型，并使用`%lld` *printf()* 格式说明符，如下所示：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Similar remarks also apply for the related *blkcnt_t* data type, which is employed
    in the *stat* structure (described in [Retrieving File Information: *stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "Retrieving File Information: stat()")).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '类似的评论也适用于相关的*blkcnt_t*数据类型，它在*stat*结构中使用（详见[检索文件信息：*stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "Retrieving File Information: stat()")）。'
- en: Note
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we are passing function arguments of the types *off_t* or *stat* between
    separately compiled modules, then we need to ensure that both modules use the
    same sizes for these types (i.e., either both were compiled with `_FILE_OFFSET_BITS`
    set to 64 or both were compiled without this setting).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在不同编译的模块之间传递*off_t*或*stat*类型的函数参数，那么我们需要确保两个模块使用相同大小的这些类型（即，要么都使用`_FILE_OFFSET_BITS`设置为64编译，要么都没有这个设置）。
- en: The `/dev/fd` Directory
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`/dev/fd`目录'
- en: For each process, the kernel provides the special virtual directory `/dev/fd`.
    This directory contains filenames of the form `/dev/fd/`*n*, where *n* is a number
    corresponding to one of the open file descriptors for the process. Thus, for example,
    `/dev/fd/0` is standard input for the process. (The `/dev/fd` feature is not specified
    by SUSv3, but several other UNIX implementations provide this feature.)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个进程，内核提供了特殊的虚拟目录`/dev/fd`。该目录包含形式为`/dev/fd/`*n*的文件名，其中*n*是对应进程的一个打开文件描述符的数字。因此，例如，`/dev/fd/0`是进程的标准输入。（`/dev/fd`功能没有在SUSv3中指定，但其他一些UNIX实现提供了此功能。）
- en: 'Opening one of the files in the `/dev/fd` directory is equivalent to duplicating
    the corresponding file descriptor. Thus, the following statements are equivalent:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`/dev/fd`目录中的一个文件相当于复制相应的文件描述符。因此，以下语句是等效的：
- en: '[PRE34]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The *flags* argument of the *open()* call *is* interpreted, so that we should
    take care to specify the same access mode as was used by the original descriptor.
    Specifying other flags, such as `O_CREAT`, is meaningless (and ignored) in this
    context.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*open()*调用的*flags*参数是被解释的，因此我们应当小心地指定与原始描述符使用的相同访问模式。在此上下文中，指定其他标志，例如`O_CREAT`，是没有意义的（且会被忽略）。'
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`/dev/fd` is actually a symbolic link to the Linux-specific `/proc/self/fd`
    directory. The latter directory is a special case of the Linux-specific `/proc/`*PID*`/fd`
    directories, each of which contains symbolic links corresponding to all of the
    files held open by a process.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`/dev/fd`实际上是指向 Linux 特有的`/proc/self/fd`目录的符号链接。后者目录是 Linux 特有的`/proc/`*PID*`/fd`目录的特例，每个这样的目录包含与进程打开的所有文件相对应的符号链接。'
- en: 'The files in the `/dev/fd` directory are rarely used within programs. Their
    most common use is in the shell. Many user-level commands take filename arguments,
    and sometimes we would like to put them in a pipeline and have one of the arguments
    be standard input or output instead. For this purpose, some programs (e.g., *diff*,
    *ed*, *tar*, and *comm*) have evolved the hack of using an argument consisting
    of a single hyphen (`-`) to mean “use standard input or output (as appropriate)
    for this filename argument.” Thus, to compare a file list from *ls* against a
    previously built file list, we might write the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`/dev/fd`目录中的文件在程序中很少使用。它们最常见的用途是在shell中。许多用户级命令接受文件名作为参数，有时我们希望将它们放入管道中，并将其中一个参数作为标准输入或输出。因此，一些程序（例如*diff*、*ed*、*tar*和*comm*）已经发展出一个技巧，使用一个由单个连字符（`-`）组成的参数来表示“为此文件名参数使用标准输入或输出（根据情况）。”因此，为了将*ls*列出的文件列表与先前构建的文件列表进行比较，我们可能会写如下命令：'
- en: '[PRE35]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This approach has various problems. First, it requires specific interpretation
    of the hyphen character on the part of each program, and many programs don’t perform
    such interpretation; they are written to work only with filename arguments, and
    they have no means of specifying standard input or output as the files with which
    they are to work. Second, some programs instead interpret a single hyphen as a
    delimiter marking the end of command-line options.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法存在各种问题。首先，它要求每个程序对连字符字符进行特定的解释，然而许多程序并没有执行这种解释；它们是为仅处理文件名参数编写的，并且没有指定标准输入或输出作为要操作的文件的方式。其次，一些程序则将单个连字符解释为一个分隔符，标志着命令行选项的结束。
- en: 'Using `/dev/fd` eliminates these difficulties, allowing the specification of
    standard input, output, and error as filename arguments to any program requiring
    them. Thus, we can write the previous shell command as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `/dev/fd` 消除了这些问题，允许将标准输入、输出和错误作为文件名参数传递给任何需要它们的程序。因此，我们可以将之前的 shell 命令写成如下形式：
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As a convenience, the names `/dev/stdin`, `/dev/stdout`, and `/dev/stderr` are
    provided as symbolic links to, respectively, `/dev/fd/0`, `/dev/fd/1`, and `/dev/fd/2`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，提供了符号链接 `/dev/stdin`、`/dev/stdout` 和 `/dev/stderr`，分别指向 `/dev/fd/0`、`/dev/fd/1`
    和 `/dev/fd/2`。
- en: Creating Temporary Files
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建临时文件
- en: 'Some programs need to create temporary files that are used only while the program
    is running, and these files should be removed when the program terminates. For
    example, many compilers create temporary files during the compilation process.
    The GNU C library provides a range of library functions for this purpose. (The
    variety is, in part, a consequence of inheritance from various other UNIX implementations.)
    Here, we describe two of these functions: *mkstemp()* and *tmpfile()*.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序需要创建只在程序运行期间使用的临时文件，这些文件应在程序终止时被删除。例如，许多编译器在编译过程中会创建临时文件。GNU C 库为此提供了一系列库函数。（这些函数的多样性，部分是因为继承自其他
    UNIX 实现。）在这里，我们描述了其中的两个函数：*mkstemp()* 和 *tmpfile()*。
- en: The *mkstemp()* function generates a unique filename based on a template supplied
    by the caller and opens the file, returning a file descriptor that can be used
    with I/O system calls.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*mkstemp()* 函数根据调用者提供的模板生成一个唯一的文件名，并打开该文件，返回一个文件描述符，可以与 I/O 系统调用一起使用。'
- en: '[PRE37]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Returns file descriptor on success, or -1 on error
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回文件描述符，出错时返回 -1。
- en: The *template* argument takes the form of a pathname in which the last 6 characters
    must be `XXXXXX`. These 6 characters are replaced with a string that makes the
    filename unique, and this modified string is returned via the *template* argument.
    Because *template* is modified, it must be specified as a character array, rather
    than as a string constant.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*template* 参数的形式为一个路径名，其中最后 6 个字符必须是 `XXXXXX`。这 6 个字符将被一个字符串替换，从而使文件名唯一，修改后的字符串通过
    *template* 参数返回。由于 *template* 会被修改，因此它必须指定为字符数组，而不是字符串常量。'
- en: The *mkstemp()* function creates the file with read and write permissions for
    the file owner (and no permissions for other users), and opens it with the `O_EXCL`
    flag, guaranteeing that the caller has exclusive access to the file.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*mkstemp()* 函数使用读写权限为文件所有者（并且不给其他用户任何权限）创建文件，并以 `O_EXCL` 标志打开该文件，确保调用者对文件具有独占访问权限。'
- en: 'Typically, a temporary file is unlinked (deleted) soon after it is opened,
    using the *unlink()* system call ([Creating and Removing (Hard) Links: *link*()
    and *unlink*()](ch18.html#creating_and_removing_open_parenthesis_h "Creating and
    Removing (Hard) Links: link() and unlink()")). Thus, we could employ *mkstemp()*
    as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在打开临时文件后不久，使用 *unlink()* 系统调用将其取消链接（删除） ([创建和移除（硬）链接：*link*() 和 *unlink*()](ch18.html#creating_and_removing_open_parenthesis_h
    "创建和移除（硬）链接：link() 和 unlink()"))。因此，我们可以像这样使用 *mkstemp()*：
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: The *tmpnam()*, *tempnam()*, and *mktemp()* functions can also be used to generate
    unique filenames. However, these functions should be avoided because they can
    create security holes in an application. See the manual pages for further details
    on these functions.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*tmpnam()*、*tempnam()* 和 *mktemp()* 函数也可以用来生成唯一的文件名。然而，应避免使用这些函数，因为它们可能在应用程序中创建安全漏洞。有关这些函数的更多细节，请参阅手册页面。'
- en: The *tmpfile()* function creates a uniquely named temporary file that is opened
    for reading and writing. (The file is opened with the `O_EXCL` flag to guard against
    the unlikely possibility that another process has already created a file with
    the same name.)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*tmpfile()* 函数创建一个唯一命名的临时文件，并打开该文件进行读写。（该文件以 `O_EXCL` 标志打开，以防止另一个进程已经创建了具有相同名称的文件。）'
- en: '[PRE39]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns file pointer on success, or `NULL` on error
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回文件指针，出错时返回 `NULL`
- en: On success, *tmpfile()* returns a file stream that can be used with the *stdio*
    library functions. The temporary file is automatically deleted when it is closed.
    To do this, *tmpfile()* makes an internal call to *unlink()* to remove the filename
    immediately after opening the file.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时，*tmpfile()* 返回一个文件流，可与 *stdio* 库函数一起使用。临时文件在关闭时会自动删除。为此，*tmpfile()* 会在打开文件后立即调用
    *unlink()* 来删除文件名。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In the course of this chapter, we introduced the concept of atomicity, which
    is crucial to the correct operation of some system calls. In particular, the *open()*
    `O_EXCL` flag allows the caller to ensure that it is the creator of a file, and
    the *open()* `O_APPEND` flag ensures that multiple processes appending data to
    the same file don’t overwrite each other’s output.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了原子性这一概念，它对于某些系统调用的正确操作至关重要。特别是，*open()* 的 `O_EXCL` 标志允许调用者确保它是文件的创建者，*open()*
    的 `O_APPEND` 标志确保多个进程向同一文件追加数据时不会互相覆盖输出。
- en: The *fcntl()* system call performs a variety of file control operations, including
    changing open file status flags and duplicating file descriptors. Duplicating
    file descriptors is also possible using *dup()* and *dup2()*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*fcntl()* 系统调用执行各种文件控制操作，包括更改打开文件的状态标志和复制文件描述符。也可以使用 *dup()* 和 *dup2()* 来复制文件描述符。'
- en: We looked at the relationship between file descriptors, open file descriptions,
    and file i-nodes, and noted that different information is associated with each
    of these three objects. Duplicate file descriptors refer to the same open file
    description, and thus share open file status flags and the file offset.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了文件描述符、打开文件描述和文件 i-node 之间的关系，并指出这三个对象各自关联不同的信息。重复的文件描述符引用相同的打开文件描述，因此共享打开文件的状态标志和文件偏移量。
- en: We described a number of system calls that extend the functionality of the conventional
    *read()* and *write()* system calls. The *pread()* and *pwrite()* system calls
    perform I/O at a specified file location without changing the file offset. The
    *readv()* and *writev()* calls perform scatter-gather I/O. The *preadv()* and
    *pwritev()* calls combine scatter-gather I/O functionality with the ability to
    perform I/O at a specified file location.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了若干扩展传统 *read()* 和 *write()* 系统调用功能的系统调用。*pread()* 和 *pwrite()* 系统调用在指定的文件位置进行
    I/O，而不改变文件偏移量。*readv()* 和 *writev()* 调用执行分散-聚集 I/O。*preadv()* 和 *pwritev()* 调用结合了分散-聚集
    I/O 功能，并能够在指定的文件位置进行 I/O。
- en: The *truncate()* and *ftruncate()* system calls can be used to decrease the
    size of a file, discarding the excess bytes, or to increase the size, padding
    with a zero-filled file hole.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*truncate()* 和 *ftruncate()* 系统调用可用于减小文件大小，丢弃多余的字节，或增加文件大小，用零填充文件洞。'
- en: We briefly introduced the concept of nonblocking I/O, and we’ll return to it
    in later chapters.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要介绍了非阻塞 I/O 的概念，稍后将在后续章节中回到这一主题。
- en: The LFS specification defines a set of extensions that allow processes running
    on 32-bit systems to perform operations on files whose size is too large to be
    represented in 32 bits.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: LFS 规范定义了一组扩展，允许在 32 位系统上运行的进程对文件进行操作，这些文件的大小过大，无法在 32 位中表示。
- en: The numbered files in the `/dev/fd` virtual directory allow a process to access
    its own open files via file descriptor numbers, which can be particularly useful
    in shell commands.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`/dev/fd` 虚拟目录中的编号文件允许进程通过文件描述符号访问其自己的打开文件，这在 Shell 命令中特别有用。'
- en: The *mkstemp()* and *tmpfile()* functions allow an application to create temporary
    files.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*mkstemp()* 和 *tmpfile()* 函数允许应用程序创建临时文件。'
- en: Exercises
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Modify the program in [Example 5-3](ch05.html#accessing_large_files "Example 5-3. Accessing
    large files") to use standard file I/O system calls (*open()* and *lseek()*) and
    the *off_t* data type. Compile the program with the `_FILE_OFFSET_BITS` macro
    set to 64, and test it to show that a large file can be successfully created.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[示例 5-3](ch05.html#accessing_large_files "示例 5-3. 访问大文件")中的程序，使用标准文件I/O系统调用（*open()*和*lseek()*）以及*off_t*数据类型。使用`_FILE_OFFSET_BITS`宏将程序编译为64位，并测试它以证明可以成功创建大文件。
- en: Write a program that opens an existing file for writing with the `O_APPEND`
    flag, and then seeks to the beginning of the file before writing some data. Where
    does the data appear in the file? Why?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，使用`O_APPEND`标志打开现有文件进行写入，然后在写入一些数据之前将文件指针定位到文件的开头。数据会出现在文件的什么位置？为什么？
- en: 'This exercise is designed to demonstrate why the atomicity guaranteed by opening
    a file with the `O_APPEND` flag is necessary. Write a program that takes up to
    three command-line arguments:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个练习旨在演示通过使用`O_APPEND`标志打开文件所保证的原子性是如何必要的。编写一个程序，接受最多三个命令行参数：
- en: '[PRE40]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This program should open the specified filename (creating it if necessary)
    and append *num-bytes* bytes to the file by using *write()* to write a byte at
    a time. By default, the program should open the file with the `O_APPEND` flag,
    but if a third command-line argument (*x*) is supplied, then the `O_APPEND` flag
    should be omitted, and instead the program should perform an *lseek(fd, 0, SEEK_END)*
    call before each *write()*. Run two instances of this program at the same time
    without the *x* argument to write 1 million bytes to the same file:'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该程序应打开指定的文件名（如有必要，创建该文件），并通过使用*write()*一次写入一个字节的方式，将*num-bytes*字节附加到文件中。默认情况下，程序应使用`O_APPEND`标志打开文件，但如果提供了第三个命令行参数（*x*），则应省略`O_APPEND`标志，而是程序应该在每次*write()*之前执行*lseek(fd,
    0, SEEK_END)*调用。运行两个实例的程序，同时没有*x*参数，以将100万字节写入同一文件：
- en: '[PRE41]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Repeat the same steps, writing to a different file, but this time specifying
    the *x* argument:'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重复相同的步骤，写入到另一个文件，但这次指定*x*参数：
- en: '[PRE42]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: List the sizes of the files `f1` and `f2` using *ls -l* and explain the difference.
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用*ls -l*列出文件`f1`和`f2`的大小，并解释差异。
- en: Implement *dup()* and *dup2()* using *fcntl()* and, where necessary, *close()*.
    (You may ignore the fact that *dup2()* and *fcntl()* return different *errno*
    values for some error cases.) For *dup2()*, remember to handle the special case
    where *oldfd* equals *newfd*. In this case, you should check whether *oldfd* is
    valid, which can be done by, for example, checking if *fcntl(oldfd, F_GETFL)*
    succeeds. If *oldfd* is not valid, then the function should return -1 with *errno*
    set to `EBADF`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*fcntl()*实现*dup()*和*dup2()*，并在必要时使用*close()*。（你可以忽略*dup2()*和*fcntl()*在某些错误情况下返回不同*errno*值的事实。）对于*dup2()*，记得处理*oldfd*等于*newfd*的特殊情况。在这种情况下，你应该检查*oldfd*是否有效，可以通过例如检查*fcntl(oldfd,
    F_GETFL)*是否成功来实现。如果*oldfd*无效，则该函数应返回-1，并将*errno*设置为`EBADF`。
- en: Write a program to verify that duplicated file descriptors share a file offset
    value and open file status flags.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，验证复制的文件描述符共享相同的文件偏移量值和打开的文件状态标志。
- en: 'After each of the calls to *write()* in the following code, explain what the
    content of the output file would be, and why:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码的每次*write()*调用后，解释输出文件的内容是什么，并说明原因：
- en: '[PRE43]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Implement *readv()* and *writev()* using *read()*, *write()*, and suitable
    functions from the *malloc* package ([Allocating Memory on the Heap: *malloc()*
    and *free()*](ch07.html#allocating_memory_on_the_heap_colon_mall "Allocating Memory
    on the Heap: malloc() and free()")).'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*read()*、*write()*和*malloc*包中的适当函数（[在堆上分配内存：*malloc()*和*free()*](ch07.html#allocating_memory_on_the_heap_colon_mall
    "在堆上分配内存：malloc()和free()")）实现*readv()*和*writev()*。
