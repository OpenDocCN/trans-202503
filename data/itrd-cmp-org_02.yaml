- en: '**2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2'
- en: DATA STORAGE FORMATS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储格式**
- en: '![Image](../images/pg23_Image_2.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg23_Image_2.jpg)'
- en: 'You may be used to thinking of computers as hardware devices for storing collections
    of programs, files, and graphics. In this book, we’ll look at computers in a different
    way: as billions of two-state switches and one or more *control units*—devices
    that can both detect and change the states of the switches.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能习惯于将计算机视为用于存储程序、文件和图形的硬件设备。在本书中，我们将以不同的方式看待计算机：它们是由数十亿个双态开关和一个或多个*控制单元*——这些设备能够检测并改变开关的状态。
- en: In [Chapter 1](ch01.xhtml), we discussed communicating with the world outside
    the computer using input and output. In this chapter, we’ll begin exploring how
    computers encode data for storage in memory, and we’ll write some programs in
    C that explore these concepts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml)中，我们讨论了如何通过输入和输出与计算机外部的世界进行通信。在本章中，我们将开始探索计算机如何对数据进行编码以便存储在内存中，并且我们将编写一些C语言程序来探讨这些概念。
- en: '**Switches and Groups of Switches**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**开关与开关组**'
- en: Whatever you’re doing on your computer—streaming a video, posting on social
    media, writing a program—it’s done by combinations of two-state switches interacting
    with each other. Each combination of switches represents a possible state the
    computer can be in. If you wanted to describe what was happening on your computer,
    you could list a combination of switches. In plain English, this would be something
    like “The first switch is on, the second one is also on, but the third is off,
    while the fourth is on.” But describing the computer this way would be difficult,
    because modern computers use billions of switches. Instead, we use a more concise,
    numeric notation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你在计算机上做什么——播放视频、发布社交媒体动态、编写程序——都是通过双态开关之间的组合相互作用来完成的。每一种开关组合都表示计算机可能处于的一个状态。如果你想描述计算机上发生的事情，你可以列出一个开关组合。用简单的英语表达，这就像是“第一个开关打开，第二个开关也打开，但第三个开关关闭，而第四个开关打开。”但是以这种方式描述计算机是很困难的，因为现代计算机使用的是数十亿个开关。相反，我们使用一种更简洁的数字表示法。
- en: '***Representing Switches with Bits***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***用位表示开关***'
- en: You’re probably familiar with the *decimal system*, which uses the digits 0
    to 9 to write numbers. We want to represent switches numerically, but our switches
    have only 2 states, not 10\. Here, the *binary system*—a two-digit system that
    uses `0`s and `1`s—is useful.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉*十进制系统*，它使用数字0到9来书写数字。我们希望用数字表示开关，但我们的开关只有2种状态，而不是10种。在这里，*二进制系统*——一种使用`0`和`1`的二位系统——就显得非常有用了。
- en: 'We’ll use a *binary digit*, commonly shortened to *bit*, to represent the state
    of a switch. A bit can have two values: `0`, which represents that a switch is
    “off,” and `1`, which represents that a switch is “on.” If we wanted, we could
    assign the opposite values to these digits; all that matters is that we’re consistent.
    Let’s use bits to simplify our statement about switches: we have a computer in
    which the first, second, and fourth switches are on and the third is off. In binary,
    we would represent this as `1101`.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用*二进制数字*，通常简称为*位*，来表示开关的状态。一个位可以有两个值：`0`，表示开关是“关闭”的，和`1`，表示开关是“打开”的。如果我们愿意，也可以将这些数字的值反过来分配；重要的是我们要保持一致。让我们使用位来简化关于开关的描述：我们有一台计算机，其中第一个、第二个和第四个开关是打开的，第三个开关是关闭的。用二进制表示就是`1101`。
- en: '***Representing Groups of Bits***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***表示位组***'
- en: Even with binary, sometimes we have so many bits that the number is un-readable.
    In those cases, we use *hexadecimal digits* to specify bit patterns. The hexadecimal
    system has 16 digits, each of which can represent one group of 4 bits. [Table
    2-1](ch02.xhtml#ch2tab1) shows all 16 possible combinations of 4 bits and the
    corresponding hexadecimal digit for each combination. After using hexadecimal
    for a while, you will probably memorize this table, but if you forget it, an online
    search will quickly bring up a hexadecimal-to-binary converter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是二进制，有时我们也会有很多位，导致数字变得难以阅读。在这种情况下，我们使用*十六进制数字*来表示位模式。十六进制系统有16个数字，每个数字可以表示一组4个位。[表2-1](ch02.xhtml#ch2tab1)显示了4位的所有16种可能组合及其对应的十六进制数字。使用十六进制一段时间后，你可能会记住这个表格，但如果忘记了，网上搜索一个十六进制转二进制的转换器会很方便。
- en: '**Table 2-1:** The Hexadecimal Representation of 4 Bits'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 4位的十六进制表示'
- en: '| **One hexadecimal digit** | **Four binary digits (bits)** |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **一个十六进制数字** | **四个二进制数字（位）** |'
- en: '| --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `0` | `0000` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0000` |'
- en: '| `1` | `0001` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0001` |'
- en: '| `2` | `0010` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `0010` |'
- en: '| `3` | `0011` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `0011` |'
- en: '| `4` | `0100` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `4` | `0100` |'
- en: '| `5` | `0101` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `5` | `0101` |'
- en: '| `6` | `0110` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `6` | `0110` |'
- en: '| `7` | `0111` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `7` | `0111` |'
- en: '| `8` | `1000` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `8` | `1000` |'
- en: '| `9` | `1001` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `9` | `1001` |'
- en: '| `a` | `1010` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `a` | `1010` |'
- en: '| `b` | `1011` |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `b` | `1011` |'
- en: '| `c` | `1100` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `c` | `1100` |'
- en: '| `d` | `1101` |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `d` | `1101` |'
- en: '| `e` | `1110` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `e` | `1110` |'
- en: '| `f` | `1111` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `f` | `1111` |'
- en: 'Using hexadecimal, we can write `1101`, or “on, on, off, on,” with a single
    digit: `d`[16] = `1101`[2].'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用十六进制表示时，我们可以用一个数字表示`1101`，即“开，开，关，开”——`d`[16] = `1101`[2]。
- en: '**NOTE**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When it isn’t clear from the context, I will indicate the base of a number
    in this text with a subscript. For example, 100[10] is in decimal,* 100*[16] is
    in hexadecimal, and* 100*[2] is in binary.*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*当上下文不清晰时，我会在本文中使用下标来表示数字的进制。例如，100[10]表示十进制，100*[16]表示十六进制，100*[2]表示二进制。*'
- en: The *octal* system, based on the number 8, is less common, but you will encounter
    it occasionally. The eight octal digits span from `0` to `7`, and each digit represents
    a group of 3 bits. [Table 2-2](ch02.xhtml#ch2tab2) shows the correspondence between
    each possible group of 3 bits and its corresponding single octal digit.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*八进制*系统基于数字8，虽然不常见，但你偶尔会遇到它。八个八进制数字从`0`到`7`，每个数字代表一组三个比特。[表2-2](ch02.xhtml#ch2tab2)展示了每组三个比特与其对应的单个八进制数字之间的关系。'
- en: '**Table 2-2:** The Octal Representation of 3 Bits'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-2：** 3比特的八进制表示'
- en: '| **One octal digit** | **Three binary digits (bits)** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **一个八进制数字** | **三个二进制数字（比特）** |'
- en: '| --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `0` | `000` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `000` |'
- en: '| `1` | `001` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `001` |'
- en: '| `2` | `010` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `010` |'
- en: '| `3` | `011` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `011` |'
- en: '| `4` | `100` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `4` | `100` |'
- en: '| `5` | `101` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `5` | `101` |'
- en: '| `6` | `110` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `6` | `110` |'
- en: '| `7` | `111` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `7` | `111` |'
- en: For example, the 4-bit example we’re using, `1101`[2], would be written `15`[8]
    in octal.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们使用的4比特示例`1101`[2]，在八进制中表示为`15`[8]。
- en: '***Using Hexadecimal Digits***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用十六进制数字***'
- en: 'Hexadecimal digits are especially convenient when we need to specify the state
    of a group of, say, 16 or 32 switches. In place of each group of 4 bits, we can
    write one hexadecimal digit. For example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制数字在需要指定一组开关状态时特别方便，比如16个或32个开关。每四个比特位可以用一个十六进制数字来表示。例如：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A single bit is rarely useful for storing data. The smallest number of bits
    that can be accessed at a time in a computer is defined as a *byte*. In most modern
    computers, a byte consists of 8 bits, but there are exceptions to the 8-bit byte.
    For example, the CDC 6000 series of scientific mainframe computers used a 6-bit
    byte.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 单一比特位通常无法用于存储数据。计算机中一次可以访问的最小比特数被定义为*字节*。在大多数现代计算机中，一个字节由8个比特组成，但也有例外。例如，CDC
    6000系列科学主机计算机使用的是6位字节。
- en: 'In the C and C++ programming languages, prefixing a number with `0x`—that’s
    a zero and a lowercase *x*—specifies that the number is expressed in hexadecimal.
    Prefixing a number with only a `0` specifies octal representation. C++ allows
    us to specify a value in binary by prefixing the number with `0b`. Although the
    `0b` notation for specifying binary is not part of standard C, our compiler, `gcc`,
    allows it. Thus, when we write C or C++ code in this book, these all mean the
    same thing:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在C和C++编程语言中，数字前加`0x`——即零和小写字母*x*——表示该数字是以十六进制表示的。若数字前仅加`0`，则表示八进制表示。C++允许通过在数字前加`0b`来指定二进制值。虽然`0b`表示二进制的语法不是C标准的一部分，但我们的编译器`gcc`支持这一语法。因此，当我们在本书中编写C或C++代码时，这些都表示相同的含义：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you’re using a different C compiler, you may not be able to use the `0b`
    syntax to specify binary.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用不同的C编译器，可能无法使用`0b`语法来指定二进制。
- en: '**YOUR TURN**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的回合**'
- en: '2.1     Express the following bit patterns in hexadecimal:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 2.1     将以下比特模式转换为十六进制：
- en: (a)     `0100 0101 0110 0111`
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: (a)     `0100 0101 0110 0111`
- en: (b)     `1000 1001 1010 1011`
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: (b)     `1000 1001 1010 1011`
- en: (c)     `1111 1110 1101 1100`
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: (c)     `1111 1110 1101 1100`
- en: (d)     `0000 0010 0101 0010`
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: (d)     `0000 0010 0101 0010`
- en: '2.2     Express the following hexadecimal patterns in binary:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 2.2     将以下十六进制模式转换为二进制：
- en: (a)     `83af`
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: (a)     `83af`
- en: (b)     `9001`
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: (b)     `9001`
- en: (c)     `aaaa`
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: (c)     `aaaa`
- en: (d)     `5555`
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: (d)     `5555`
- en: 2.3     How many bits are represented by each of the following?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 2.3     以下每个表示多少比特？
- en: (a)     `ffffffff`
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: (a)     `ffffffff`
- en: (b)     `7fff58b7def0`
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: (b)     `7fff58b7def0`
- en: (c)     `1111`[2]
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: (c)     `1111`[2]
- en: (d)     `1111`[16]
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: (d)     `1111`[16]
- en: 2.4     How many hexadecimal digits are required to represent each of the following?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 2.4     以下每个需要多少个十六进制数字来表示？
- en: (a)     8 bits
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: (a)     8比特
- en: (b)     32 bits
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: (b)     32比特
- en: (c)     64 bits
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: (c)     64比特
- en: (d)     10 bits
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: (d)     10比特
- en: (e)     20 bits
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: (e)     20比特
- en: (f)     7 bits
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: (f)     7比特
- en: '**The Mathematical Equivalence of Binary and Decimal**'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**二进制与十进制的数学等价性**'
- en: In the previous section, you learned that binary digits are a natural way to
    show the states of switches within the computer. You also learned that we can
    use hexadecimal to show the state of four switches with a single character. In
    this section, I’ll show you some of the mathematical properties of the binary
    number system and how it translates to and from the more familiar decimal (base
    10) number system.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了二进制数字是如何自然地表示计算机内部开关状态的。你还学到了我们可以用十六进制表示四个开关的状态，通过一个字符。在这一节中，我将向你展示二进制数系统的一些数学性质，以及它如何与我们更为熟悉的十进制（基数10）数系统互相转换。
- en: '***Getting to Know Positional Notation***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***了解位置符号系统***'
- en: By convention, we use positional notation when writing numbers. *Positional
    notation* means that the value of a symbol depends on its position within a group
    of symbols. In the familiar decimal number system, we use the symbols 0, 1, .
    . . , 9 to represent numbers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 按照约定，当我们写数字时，使用位置符号系统。*位置符号系统*意味着符号的值取决于它在符号组中的位置。在我们熟悉的十进制数系统中，我们使用符号0、1、...、9来表示数字。
- en: In the number 50, the value of the symbol 5 is 50 because it’s in the *tens
    position*, and any number in that position is multiplied by 10\. In the number
    500, the value of the symbol 5 is 500 because it’s in the *hundreds position*.
    The symbol 5 is the same in any position, but its value depends on the position
    it occupies within the number.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字50中，符号5的值是50，因为它位于*十位*，任何在该位置的数字都会乘以10。在数字500中，符号5的值是500，因为它位于*百位*。符号5在任何位置的值都是一样的，但其值取决于它在数字中所处的位置。
- en: Taking this a step further, in the decimal number system, the integer 123 is
    taken to mean
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步地，在十进制数系统中，整数123意味着
- en: '![Image](../images/pg41_Image_5.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg41_Image_5.jpg)'
- en: 'or:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '![Image](../images/pg41_Image_6.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg41_Image_6.jpg)'
- en: In this example, the rightmost digit, 3, is the *least significant digit* because
    its value contributes the least to the number’s total value. The leftmost digit,
    1, is the *most significant digit* because it contributes the most value.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，最右边的数字3是*最低有效数字*，因为它对数字总值的贡献最小。最左边的数字1是*最高有效数字*，因为它对数字总值的贡献最大。
- en: '**ANOTHER NUMBER SYSTEM**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**另一种数字系统**'
- en: 'Before positional notations were invented, people used counting systems to
    keep track of numerical quantities. The *Roman numeral* system is a well-known
    example of a counting system. It uses the symbols I for 1, V for 5, X for 10,
    L for 50, and so on. To represent two things, you simply use two I’s: II. Similarly,
    XX represents 20 things.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在位置符号系统发明之前，人们使用计数系统来跟踪数量。*罗马数字*系统就是一种著名的计数系统示例。它使用符号I表示1，V表示5，X表示10，L表示50，等等。要表示两个物品，你只需用两个I：II。类似地，XX表示20个物品。
- en: The two main rules of the Roman numeral system are that symbols that represent
    larger values come first, and if a symbol representing a smaller value is placed
    before a larger one, then the value of the smaller one is subtracted from the
    immediately following larger one. For example, IV represents 4 because I (1) is
    less than V (5), so it is subtracted from the value represented by V.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 罗马数字系统的两个主要规则是，表示较大值的符号排在前面；如果一个表示较小值的符号出现在较大符号之前，则较小符号的值会从紧接其后的较大符号的值中被减去。例如，IV代表4，因为I（1）小于V（5），所以从V的值中减去I的值。
- en: 'There is no symbol for zero in the Roman numeral system because the symbol
    0 isn’t needed in counting systems. In a positional system, we need a symbol to
    mark the fact that there is no value in that position, but the position still
    counts toward the value being represented: the zeros in 500 tell us that there
    are no values in the tens position or the ones position. There is just a value
    of 5 in the hundreds position.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 罗马数字系统中没有零的符号，因为在计数系统中不需要符号0。在位置符号系统中，我们需要一个符号来标记该位置没有值，但该位置仍然对表示的值起作用：在500中的零告诉我们，十位和个位没有值。只有百位上有一个5的值。
- en: 'The invention of positional notations greatly simplified arithmetic and led
    to the mathematics we know today. If you need to convince yourself, divide 60
    (LX) by 3 (III) in the Roman numeral system. (Answer: XX.)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 位置符号的发明极大简化了算术运算，并导致了我们今天所知的数学。如果你需要说服自己，可以在罗马数字系统中试着将60（LX）除以3（III）。(答案：XX。)
- en: The *base*, or *radix*, of the decimal number system—that is, the number of
    unique digits—is 10\. This means there are 10 symbols to represent the digits
    0 through 9\. Moving a digit one place to the left increases its value by a factor
    of 10\. Moving it one place to the right decreases its value by a factor of 10\.
    The positional notation generalizes to any radix *r* as
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制数系统的*基数*或*进制*是 10。这意味着有 10 个符号来表示数字 0 到 9。将一个数字向左移动一位会使其值增加 10 倍。将其向右移动一位会使其值减少
    10 倍。位置记数法可以推广到任何基数 *r*，即
- en: '![Image](../images/pg41_Image_7.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg41_Image_7.jpg)'
- en: where there are *n* digits in the number and each *d[i]* is a single digit with
    0 *≤ d[i]* < *r*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 其中数字中有 *n* 位，每个 *d[i]* 是一个单独的数字，满足 0 *≤ d[i]* < *r*。
- en: This expression tells us how to determine the value of each digit in the number.
    We determine the position of each digit in the number by counting from the right,
    starting with zero. At each position, we raise the radix, *r*, to the power of
    its position and then multiply that number by the value of the digit. Adding all
    the results gives us the value represented by the number.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式告诉我们如何确定数字中每一位的值。我们通过从右边开始按顺序计数，从零开始来确定每一位的位置。在每个位置，我们将基数 *r* 提到该位置的幂次方，然后将其与该数字的值相乘。将所有结果相加，我们就得到了该数字所表示的值。
- en: The radix in the binary number system is 2, so there are only two symbols for
    representing the digits. This means that *d[i]* = `0`, `1`, and we can write this
    expression as
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数系统的进制是 2，因此只有两个符号来表示数字。这意味着 *d[i]* = `0`、`1`，我们可以将该表达式写为
- en: '![Image](../images/pg42_Image_8.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg42_Image_8.jpg)'
- en: where there are *n* digits in the number and each *d[i]* = `0` or `1`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 其中数字中有 *n* 位，每个 *d[i]* = `0` 或 `1`。
- en: In the next section, we’ll convert binary numbers to and from unsigned decimals.
    *Signed* numbers can be either positive or negative, but *unsigned* numbers have
    no sign. We’ll discuss signed numbers in [Chapter 3](ch03.xhtml).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将把二进制数转换为无符号十进制数并反向转换。*有符号*数字可以是正数或负数，但*无符号*数字没有符号。我们将在[第 3 章](ch03.xhtml)中讨论有符号数字。
- en: '***Converting Binary to Unsigned Decimal***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***二进制转换为无符号十进制***'
- en: 'You can easily convert from binary to decimal by computing the value of 2 raised
    to the power of the position it’s in and then multiplying that by the value of
    the bit in that position. For example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过计算 2 的位置次方，然后将其与该位置上的位值相乘，轻松地将二进制转换为十进制。例如：
- en: '![Image](../images/pg42_Image_9.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg42_Image_9.jpg)'
- en: 'Using pseudocode, the procedure for converting binary to decimal can be summarized
    as:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用伪代码，二进制转换为十进制的过程可以总结为：
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At each bit position, this algorithm computes 2*^i* and then multiplies by the
    respective bit value, either `0` or `1`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个位位置，算法计算 2*^i* 并将其与相应的位值（`0` 或 `1`）相乘。
- en: '**NOTE**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although we’re considering only integers at this point, this algorithm does
    generalize to fractional values. Simply continue the exponents of the radix,*
    r*, on to negative values—that is,* r^(n – *1*), r^(n – *2*)*, . . . ,* r*¹,*
    r*⁰,* r^(–*1*), r^(–*2*)*, . . . This will be covered in detail in [Chapter 19](ch19.xhtml).*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管我们此时只考虑整数，但该算法确实可以推广到小数值。只需将进制 *r* 的指数继续扩展到负值——即 *r^(n – *1*)*，*r^(n – *2*)*，...，*r¹*，*r⁰*，*r^(–*1*)*，*r^(–*2*)*，...
    这将在[第 19 章](ch19.xhtml)中详细讨论。*'
- en: '**YOUR TURN**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮到你了**'
- en: 2.5     Looking at the generalized equation in this section, what are the values
    of *r*, *n*, and each *d[i]* for the decimal number 29,458,254 and the hexadecimal
    number `29458254`?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 2.5     查看本节中的广义方程，十进制数 29,458,254 和十六进制数 `29458254` 的 *r*、*n* 和每个 *d[i]* 的值是什么？
- en: '2.6     Convert the following 8-bit binary numbers to decimal:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 2.6     将以下 8 位二进制数转换为十进制：
- en: (a)     `1010 1010`
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: (a)     `1010 1010`
- en: (b)     `0101 0101`
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: (b)     `0101 0101`
- en: (c)     `1111 0000`
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: (c)     `1111 0000`
- en: (d)     `0000 1111`
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: (d)     `0000 1111`
- en: (e)     `1000 0000`
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: (e)     `1000 0000`
- en: (f)     `0110 0011`
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: (f)     `0110 0011`
- en: (g)     `0111 1011`
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: (g)     `0111 1011`
- en: (h)     `1111 1111`
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: (h)     `1111 1111`
- en: '2.7     Convert the following 16-bit binary numbers to decimal:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 2.7     将以下 16 位二进制数转换为十进制：
- en: (a)     `1010 1011 1100 1101`
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: (a)     `1010 1011 1100 1101`
- en: (b)     `0001 0011 0011 0100`
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: (b)     `0001 0011 0011 0100`
- en: (c)     `1111 1110 1101 1100`
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: (c)     `1111 1110 1101 1100`
- en: (d)     `0000 0111 1101 1111`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: (d)     `0000 0111 1101 1111`
- en: (e)     `1000 0000 0000 0000`
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: (e)     `1000 0000 0000 0000`
- en: (f)     `0000 0100 0000 0000`
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: (f)     `0000 0100 0000 0000`
- en: (g)     `0111 1011 1010 1010`
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: (g)     `0111 1011 1010 1010`
- en: (h)     `0011 0000 0011 1001`
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: (h)     `0011 0000 0011 1001`
- en: '2.8     Develop an algorithm to convert hexadecimal to decimal and then convert
    the following 16-bit numbers to decimal:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 2.8     开发一个算法将十六进制转为十进制，并将以下 16 位数字转换为十进制：
- en: (a)     `a000`
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: (a)     `a000`
- en: (b)     `ffff`
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: (b)     `ffff`
- en: (c)     `0400`
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: (c)     `0400`
- en: (d)     `1111`
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: (d)     `1111`
- en: (e)     `8888`
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: (e)     `8888`
- en: (f)     `0190`
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: (f)     `0190`
- en: (g)     `abcd`
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: (g)     `abcd`
- en: (h)     `5555`
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: (h)     `5555`
- en: '***Converting Unsigned Decimal to Binary***'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***无符号十进制转二进制***'
- en: If we want to convert an unsigned decimal integer, *N*, to binary, we set it
    equal to the previous expression for binary numbers to give the equation
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将一个无符号十进制整数 *N* 转换为二进制，我们将其设置为与之前的二进制数表达式相等，得到方程
- en: '![Image](../images/pg43_Image_10.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg43_Image_10.jpg)'
- en: where each *d[i]* = `0` or `1`. We divide both sides of this equation by 2,
    and the exponent of each 2 term on the right side decreases by 1, giving
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 其中每个 *d[i]* = `0` 或 `1`。我们将这个方程两边都除以 2，右边每个 2 的指数减 1，得到
- en: '![Image](../images/pg43_Image_11.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg43_Image_11.jpg)'
- en: 'where *N*[1] is the integer part and the remainder, *r*[0], is `0` for even
    numbers and `1` for odd numbers. Doing a little rewriting, we have the equivalent
    equation:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *N*[1] 是整数部分，余数 *r*[0] 对于偶数为 `0`，对于奇数为 `1`。稍作改写，我们得到等效方程：
- en: '![Image](../images/pg43_Image_12.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg43_Image_12.jpg)'
- en: All the terms within the parentheses on the right side are integers. The integer
    part of both sides of an equation must be equal, and the fractional parts must
    also be equal. That is, we have
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧括号内的所有项都是整数。方程两边的整数部分必须相等，分数部分也必须相等。也就是说，我们得到
- en: '![Image](../images/pg43_Image_13.jpg) and:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg43_Image_13.jpg) 和：'
- en: '![Image](../images/pg44_Image_14.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg44_Image_14.jpg)'
- en: 'Thus, you can see that *d*[0] = *r*[0]. Subtracting *r*[0] /2 (which equals
    *d*[0]/2) from both sides of our expanded equation gives us:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以看到 *d*[0] = *r*[0]。将 *r*[0] /2（即 *d*[0]/2）从扩展方程的两边相减，得到：
- en: '![Image](../images/pg44_Image_15.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg44_Image_15.jpg)'
- en: 'Again, we divide both sides by 2:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将两边都除以 2：
- en: '![Image](../images/pg44_Image_16.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg44_Image_16.jpg)'
- en: 'Using the same reasoning as earlier, *d*[1] = *r*[1]. We can produce the binary
    representation of a number by working from right to left, repeatedly dividing
    by 2, and using the remainder as the value of the respective bit. This is summarized
    in the following algorithm, where the forward slash (`/`) is the integer division
    operator and the percent sign (`%`) is the modulo operator:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与之前相同的推理，*d*[1] = *r*[1]。我们可以通过从右到左反复除以 2，并使用余数作为相应位的值来得到一个数字的二进制表示。这个过程总结在以下算法中，其中斜杠（`/`）是整数除法运算符，百分号（`%`）是取模运算符：
- en: '[PRE3]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Some programming tasks require a specific bit pattern—for example, programming
    a hardware device. In these cases, specifying a bit pattern rather than a numerical
    value is more natural. We can think of the bits in groups of four and use hexadecimal
    to specify each group. For example, if our algorithm required the use of zeros
    alternating with ones—`0101 0101 0101 0101 0101 0101 0101 0101`—we could convert
    this to the decimal value 431,655,765, or we could express it in hexadecimal as
    `0x55555555` (shown here in C/C++ syntax). Once you’ve memorized [Table 2-1](ch02.xhtml#ch2tab1),
    you’ll find it much easier to work with hexadecimal for bit patterns.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程任务需要特定的位模式，例如，编程硬件设备。在这些情况下，指定位模式而不是数值更为自然。我们可以将位分成四组，并使用十六进制表示每一组。例如，如果我们的算法要求使用零和一交替出现的位——`0101
    0101 0101 0101 0101 0101 0101 0101`——我们可以将其转换为十进制值 431,655,765，或者我们也可以用十六进制表示为
    `0x55555555`（在 C/C++ 语法中）。一旦你记住了[表 2-1](ch02.xhtml#ch2tab1)，你会发现使用十六进制表示位模式更加轻松。
- en: The discussion in these two sections has dealt only with unsigned integers.
    The representation of signed integers depends upon some architectural features
    of the CPU that we’ll discuss in [Chapter 3](ch03.xhtml).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论的内容仅涉及无符号整数。带符号整数的表示依赖于 CPU 的一些架构特性，我们将在[第 3 章](ch03.xhtml)中讨论。
- en: '**YOUR TURN**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮到你了**'
- en: '2.9     Convert the following unsigned decimal integers to their 8-bit hexadecimal
    representation:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 2.9     将以下无符号十进制整数转换为其 8 位十六进制表示：
- en: (a)     100
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: (a)     100
- en: (b)     123
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: (b)     123
- en: (c)     10
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: (c)     10
- en: (d)     88
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: (d)     88
- en: (e)     255
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: (e)     255
- en: (f)     16
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: (f)     16
- en: (g)     32
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: (g)     32
- en: (h)     128
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: (h)     128
- en: '2.10     Convert the following unsigned decimal integers to their 16-bit hexadecimal
    representation:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 2.10     将以下无符号十进制整数转换为其 16 位十六进制表示：
- en: (a)     1,024
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: (a)     1,024
- en: (b)     1,000
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: (b)     1,000
- en: (c)     32,768
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: (c)     32,768
- en: (d)     32,767
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: (d)     32,767
- en: (e)     256
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: (e)     256
- en: (f)     65,535
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: (f)     65,535
- en: (g)     4,660
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: (g)     4,660
- en: (h)     43,981
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: (h)     43,981
- en: 2.11     Invent a code that would allow you to store letter grades with plus
    or minus (that is, the grades A, A–, B+, B, B–, . . . , D, D–, F). How many bits
    are required for your code?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 2.11     发明一种代码，允许你存储带有加号或减号的字母成绩（即成绩A、A–、B+、B、B–、. . . 、D、D–、F）。你的代码需要多少位？
- en: '**Storing Data in Memory**'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据存储在内存中**'
- en: 'We now have the language necessary to begin discussing how data is stored in
    computer memory. We’ll start with how memory is organized. There are two general
    kinds of memory used for storing program instructions and data in a computer:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了开始讨论数据如何存储在计算机内存中的语言。我们将从内存是如何组织的开始。计算机中用于存储程序指令和数据的内存一般有两种类型：
- en: '**Random-access memory (RAM)**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**随机存取内存 (RAM)**'
- en: Once a bit (switch) is set to either `0` or `1`, it stays in that state until
    the control unit actively changes it or the power is turned off. The control unit
    can both read and change the state of a bit.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个位（开关）被设置为`0`或`1`，它将保持该状态，直到控制单元主动改变它或电源被切断。控制单元既可以读取位的状态，也可以改变位的状态。
- en: The name *random-access memory* is misleading. Here, *random access* means that
    it takes the same amount of time to access any byte in the memory, not that any
    randomness is involved when reading the byte. We contrast RAM with *sequential
    access memory (SAM)*, where the amount of time it takes to access a byte depends
    on its position in some sequence. An example of SAM is magnetic tape, which is
    typically used for backups, where retrieval speed is less important. The length
    of time it takes to access a byte depends on the physical location of the byte
    stored on the tape with respect to the current position of the tape.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*随机存取内存*这个名称是误导性的。在这里，*随机存取*意味着访问内存中的任何字节所需的时间相同，而不是在读取字节时涉及任何随机性。我们将RAM与*顺序访问内存
    (SAM)*进行对比，后者访问字节所需的时间取决于其在某个序列中的位置。SAM的一个例子是磁带，通常用于备份，在那里检索速度并不那么重要。访问字节所需的时间取决于存储在磁带上的字节的物理位置与当前磁带位置的关系。'
- en: '**Read-only memory (ROM)**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**只读内存 (ROM)**'
- en: The control unit can read the state of each bit in ROM but can’t change it.
    You can reprogram some types of ROM with specialized hardware, but the bits remain
    in the new state when the power is turned off. ROM is also called *nonvolatile
    memory (NVM)*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 控制单元可以读取ROM中每个位的状态，但不能改变它。你可以通过专用硬件重新编程某些类型的ROM，但当电源关闭时，位将保持在新的状态。ROM也被称为*非易失性内存
    (NVM)*。
- en: '***Memory Addresses***'
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内存地址***'
- en: Each byte in memory has a location, or address, much like the room number in
    an office building. The address of a specific byte never changes. That is, the
    957th byte from the beginning of memory will always be the 957th byte. However,
    the state (content) of each of the bits—`0` or `1`—in any given byte can be changed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 内存中的每个字节都有一个位置或地址，类似于办公大楼中的房间号。特定字节的地址是固定不变的。也就是说，从内存开始的第957个字节将始终是第957个字节。然而，任何给定字节中每个位的状态（`0`
    或 `1`）是可以改变的。
- en: Computer scientists typically express the address of each byte in memory in
    hexadecimal, starting the numbering at zero. Thus, we would say that the 957th
    byte is at address `0x3bc` (= 956 in decimal).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家通常使用十六进制表示内存中每个字节的地址，编号从零开始。因此，我们可以说第957个字节的地址是`0x3bc`（即十进制的956）。
- en: The first 16 bytes in memory have the addresses `0`, `1`, `2`, `3`, `4`, `5`,
    `6`, `7`, `8`, `9`, `a`, `b`, `c`, `d`, `e`, and `f`. Using the notation
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 内存中的前16个字节的地址是`0`、`1`、`2`、`3`、`4`、`5`、`6`、`7`、`8`、`9`、`a`、`b`、`c`、`d`、`e`和`f`。使用这种表示法
- en: '[PRE4]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: we can show the contents of each of the first 16 bytes of memory, as in [Table
    2-3](ch02.xhtml#ch2tab3) (the contents here are arbitrary).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以展示内存中前16个字节的内容，如[表2-3](ch02.xhtml#ch2tab3)所示（这里的内容是任意的）。
- en: '**Table 2-3:** Example Contents of the First 16 Bytes of Memory'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-3：** 内存前16个字节的示例内容'
- en: '| **Address** | **Content** | **Address** | **Content** |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| **地址** | **内容** | **地址** | **内容** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `0x00000000` | `0x6a` | `0x00000008` | `0xf0` |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `0x00000000` | `0x6a` | `0x00000008` | `0xf0` |'
- en: '| `0x00000001` | `0xf0` | `0x00000009` | `0x02` |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `0x00000001` | `0xf0` | `0x00000009` | `0x02` |'
- en: '| `0x00000002` | `0x5e` | `0x0000000a` | `0x33` |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `0x00000002` | `0x5e` | `0x0000000a` | `0x33` |'
- en: '| `0x00000003` | `0x00` | `0x0000000b` | `0x3c` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `0x00000003` | `0x00` | `0x0000000b` | `0x3c` |'
- en: '| `0x00000004` | `0xff` | `0x0000000c` | `0xc3` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `0x00000004` | `0xff` | `0x0000000c` | `0xc3` |'
- en: '| `0x00000005` | `0x51` | `0x0000000d` | `0x3c` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `0x00000005` | `0x51` | `0x0000000d` | `0x3c` |'
- en: '| `0x00000006` | `0xcf` | `0x0000000e` | `0x55` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `0x00000006` | `0xcf` | `0x0000000e` | `0x55` |'
- en: '| `0x00000007` | `0x18` | `0x0000000f` | `0xaa` |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `0x00000007` | `0x18` | `0x0000000f` | `0xaa` |'
- en: The content of each byte is represented by two hexadecimal digits, which specify
    the exact state of the byte’s 8 bits.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字节的内容由两个十六进制数字表示，这些数字指定字节的 8 位的精确状态。
- en: 'But what can the state of the byte’s 8 bits tell us? There are two issues that
    a programmer needs to consider when storing data in memory:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，字节的 8 位状态能告诉我们什么呢？程序员在将数据存储到内存时，需要考虑两个问题：
- en: '**How many bits are needed to store the data?**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**存储数据需要多少位？**'
- en: To answer this question, we need to know how many different values are allowed
    for the particular data item. Look at the number of different values we can represent
    in [Table 2-1](ch02.xhtml#ch2tab1) (4 bits) and [Table 2-2](ch02.xhtml#ch2tab2)
    (3 bits). We can represent up to 2*^n* different values in *n* bits. Notice, too,
    that we might not use all the possible bit patterns we have within an allocated
    space.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，我们需要知道该数据项允许多少种不同的值。请查看[表 2-1](ch02.xhtml#ch2tab1)（4 位）和[表 2-2](ch02.xhtml#ch2tab2)（3
    位）中可以表示的不同值的数量。我们可以用 *n* 位表示最多 2*^n* 种不同的值。还要注意的是，我们可能并不会使用在分配空间内所有可能的位模式。
- en: '**What is the code for storing the data?**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**存储数据的代码是什么？**'
- en: Most of the data we deal with in everyday life is not expressed in terms of
    zeros and ones. To store it in computer memory, the programmer must decide how
    to encode the data in zeros and ones.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们日常生活中处理的大多数数据不是以零和一的形式表示的。为了将其存储在计算机内存中，程序员必须决定如何将数据编码成零和一。
- en: In the rest of this chapter, you’ll see how we can store characters and unsigned
    integers in memory using the state of the bits in one or more bytes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，你将看到我们如何利用一个或多个字节中位的状态将字符和无符号整数存储到内存中。
- en: '#### ***Characters***'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***字符***'
- en: 'When you’re programming, you will almost always be manipulating text strings,
    which are arrays of characters. The first program you ever wrote was probably
    a “Hello, World!” program. If you wrote it in C, you used a statement like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编程时，几乎总是在操作文本字符串，这些字符串是字符数组。你写的第一个程序可能是一个“Hello, World!”程序。如果你用 C 语言写的，可能会使用类似这样的语句：
- en: '[PRE5]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Or, in C++:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在 C++ 中：
- en: '[PRE6]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When translating either of these statements into machine code, the compiler
    must do two things:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当将这些语句翻译成机器代码时，编译器必须做两件事：
- en: Store each of the characters in a location in memory where the control unit
    can access them.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个字符存储在内存中的一个位置，以便控制单元可以访问它们。
- en: Generate the machine instructions to write the characters on the screen.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成机器指令将字符写到屏幕上。
- en: We’ll start by considering how a single character is stored in memory.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从考虑如何在内存中存储一个单独的字符开始。
- en: '**Encoding Characters**'
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**编码字符**'
- en: The most common standard for encoding characters for computer storage is *Unicode
    UTF-8*. It uses 1 to 4 bytes for storing a number called a *code point*, which
    represents a character. A Unicode code point is written as U+*h*, where *h* is
    four to six hexadecimal digits. The operating system and display hardware associate
    one or more code points with a *glyph*, which is what we see on the screen or
    on paper. For example, U+0041 is the code point for the Latin capital letter *A*,
    which has the glyph A in the font used for this book.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计算机存储字符编码的最常见标准是 *Unicode UTF-8*。它使用 1 到 4 个字节来存储一个称为 *代码点* 的数字，该数字表示一个字符。一个
    Unicode 代码点写作 U+*h*，其中 *h* 是四到六个十六进制数字。操作系统和显示硬件将一个或多个代码点与一个 *字形* 关联，字形就是我们在屏幕上或纸上看到的内容。例如，U+0041
    是拉丁大写字母 *A* 的代码点，而在本书使用的字体中，它对应的字形是 A。
- en: UTF-8 is backward compatible with an older standard, the *American Standard
    Code for Information Interchange*, or *ASCII* (pronounced “ask-ee”). ASCII uses
    7 bits to specify each code point in a 128-character set, which contains the English
    alphabet (uppercase and lowercase), numerals, special characters, and control
    characters. In all of our programming in this book, we will use only the characters
    from the ASCII subset of UTF-8, U+0000 to U+007F.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8 向后兼容一个较旧的标准，即 *美国信息交换标准代码*，或 *ASCII*（发音为“ask-ee”）。ASCII 使用 7 位来指定一个包含
    128 个字符的字符集中的每个代码点，该字符集包括英语字母（大写和小写）、数字、特殊字符和控制字符。在本书的所有编程中，我们只会使用 UTF-8 的 ASCII
    子集中的字符，U+0000 到 U+007F。
- en: '[Table 2-4](ch02.xhtml#ch2tab4) shows the Unicode code points for the characters
    used to represent hexadecimal numbers and the corresponding 8-bit patterns that
    are stored in memory in our programming environment. You will have a chance to
    put this table to use later in the book, when you learn how to convert from the
    character representation of an integer to its binary representation. For now,
    notice that while the numeric characters are organized in a contiguous bit pattern
    sequence, there is a gap between them and the alphabetic characters.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-4](ch02.xhtml#ch2tab4) 展示了用于表示十六进制数字的字符的 Unicode 代码点，以及在我们的编程环境中存储这些字符的对应
    8 位模式。稍后在本书中，你将有机会使用这个表格，当你学习如何从整数的字符表示转换为其二进制表示时。目前，注意到虽然数字字符是按照连续的位模式顺序组织的，但它们与字母字符之间有一个间隙。'
- en: '**Table 2-4:** Some UTF-8 Code Points for Hexadecimal Characters'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-4：** 一些十六进制字符的 UTF-8 代码点'
- en: '| **Code point** | **Character description** | **Character glyph** | **Bit
    pattern** |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| **代码点** | **字符描述** | **字符字形** | **位模式** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| U+0030 | Digit zero | `0` | `0x30` |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| U+0030 | 数字零 | `0` | `0x30` |'
- en: '| U+0031 | Digit one | `1` | `0x31` |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| U+0031 | 数字一 | `1` | `0x31` |'
- en: '| U+0032 | Digit two | `2` | `0x32` |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| U+0032 | 数字二 | `2` | `0x32` |'
- en: '| U+0033 | Digit three | `3` | `0x33` |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| U+0033 | 数字三 | `3` | `0x33` |'
- en: '| U+0034 | Digit four | `4` | `0x34` |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| U+0034 | 数字四 | `4` | `0x34` |'
- en: '| U+0035 | Digit five | `5` | `0x35` |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| U+0035 | 数字五 | `5` | `0x35` |'
- en: '| U+0036 | Digit six | `6` | `0x36` |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| U+0036 | 数字六 | `6` | `0x36` |'
- en: '| U+0037 | Digit seven | `7` | `0x37` |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| U+0037 | 数字七 | `7` | `0x37` |'
- en: '| U+0038 | Digit eight | `8` | `0x38` |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| U+0038 | 数字八 | `8` | `0x38` |'
- en: '| U+0039 | Digit nine | `9` | `0x39` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| U+0039 | 数字九 | `9` | `0x39` |'
- en: '| U+0061 | Latin small letter a | `a` | `0x61` |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| U+0061 | 拉丁小写字母 a | `a` | `0x61` |'
- en: '| U+0062 | Latin small letter b | `b` | `0x62` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| U+0062 | 拉丁小写字母 b | `b` | `0x62` |'
- en: '| U+0063 | Latin small letter c | `c` | `0x63` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| U+0063 | 拉丁小写字母 c | `c` | `0x63` |'
- en: '| U+0064 | Latin small letter d | `d` | `0x64` |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| U+0064 | 拉丁小写字母 d | `d` | `0x64` |'
- en: '| U+0065 | Latin small letter e | `e` | `0x65` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| U+0065 | 拉丁小写字母 e | `e` | `0x65` |'
- en: '| U+0066 | Latin small letter f | `f` | `0x66` |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| U+0066 | 拉丁小写字母 f | `f` | `0x66` |'
- en: Although the hexadecimal numerical portion is the same as the bit pattern for
    the code points U+0000 to U+007F, this does not necessarily hold true for other
    characters. For example, U+00B5 is the code point for the micro sign, which is
    stored in memory as the 16-bit pattern `0xc2b5` and has the glyph *µ* in the font
    used for this book.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管十六进制数值部分与代码点 U+0000 到 U+007F 的位模式相同，但这并不一定适用于其他字符。例如，U+00B5 是微符号的代码点，它在内存中以
    16 位模式 `0xc2b5` 存储，并且在本书中使用的字体显示为字形 *µ*。
- en: UTF-8 uses 1 byte per character to store code points U+0000 to U+007F. Bits
    6 and 5 in the byte (recall that bits are numbered from right to left, starting
    with 0) specify the four groups of characters, shown in [Table 2-5](ch02.xhtml#ch2tab5).
    The special characters are mostly punctuation. For example, the space character
    is U+0020 and the semicolon character (;) is U+003B.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8 使用每个字符 1 字节来存储代码点 U+0000 到 U+007F。字节中的位 6 和位 5（记住，位从右到左编号，从 0 开始）指定了四个字符组，如
    [表 2-5](ch02.xhtml#ch2tab5) 所示。特殊字符大多是标点符号。例如，空格字符是 U+0020，分号字符（;）是 U+003B。
- en: '**Table 2-5:** The Character Groups in Code Points U+0000 to U+007F'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-5：** 字符组在代码点 U+0000 到 U+007F 中的分布'
- en: '| **Bit 6** | **Bit 5** | **Type of character** |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| **位 6** | **位 5** | **字符类型** |'
- en: '| --- | --- | --- |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `0` | `0` | Control |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | 控制字符 |'
- en: '| `0` | `1` | Numeric and special |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | 数字字符和特殊字符 |'
- en: '| `1` | `0` | Uppercase alphabetic and special |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | 大写字母和特殊字符 |'
- en: '| `1` | `1` | Lowercase alphabetic and special |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | 小写字母和特殊字符 |'
- en: You can generate a table of the code points that coincide with ASCII characters
    by typing the command man ascii in a Linux terminal window. (You may need to install
    the `ascii` program on your computer.) It is quite large and not the sort of thing
    you would want to memorize, but it can be helpful to understand roughly how it’s
    organized.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 Linux 终端窗口中输入命令 `man ascii` 来生成与 ASCII 字符对应的代码点表。 (你可能需要在计算机上安装 `ascii`
    程序。) 这个表非常庞大，不适合记忆，但它有助于大致了解其组织结构。
- en: You can learn more about Unicode at *[https://www.unicode.org/releases/](https://www.unicode.org/releases/)*.
    For a more informal discussion of how Unicode came to be, I recommend Joel Spolsky’s
    “The Absolute Minimum Every Software Developer Absolutely, Positively Must Know
    About Unicode and Character Sets (No Excuses!)” at *[https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/)*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *[https://www.unicode.org/releases/](https://www.unicode.org/releases/)*
    了解更多关于 Unicode 的信息。若想了解更多关于 Unicode 的形成过程，我推荐 Joel Spolsky 的《每个软件开发者必须绝对了解的 Unicode
    和字符集最基本知识（没有借口！）》一文，链接在 *[https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/)*。
- en: '**YOUR TURN**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮到你了**'
- en: 2.12     Many people use uppercase for the alphabetic hexadecimal characters.
    Every programming language I know about accepts either case. Redo [Table 2-4](ch02.xhtml#ch2tab4)
    using the bit patterns for the uppercase hexadecimal characters.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 2.12     许多人使用大写字母表示字母的十六进制字符。我所知道的每种编程语言都接受这两种大小写。使用大写十六进制字符的位模式重新做 [表 2-4](ch02.xhtml#ch2tab4)。
- en: 2.13     Create an ASCII table for the lowercase alphabetic characters.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 2.13     为小写字母字符创建一个 ASCII 表。
- en: 2.14     Create an ASCII table for the uppercase alphabetic characters.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 2.14     为大写字母字符创建一个 ASCII 表。
- en: 2.15     Create an ASCII table for the punctuation marks.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 2.15     为标点符号创建一个 ASCII 表。
- en: '**Storing a Text String**'
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**存储文本字符串**'
- en: 'Getting back to `Hello, World!\n`, the compiler stores this text string as
    a constant array of characters. To specify the extent of this array, a C-style
    string uses the code point U+0000 (ASCII `NUL`) at the end of the string as a
    *sentinel* value, which is a unique value that indicates the end of a sequence
    of characters. Thus, the compiler must allocate 15 bytes for this string: 13 for
    `Hello, World!`, 1 for the newline `\n`, and 1 for the `NUL`. [Table 2-6](ch02.xhtml#ch2tab6)
    shows how this text string would be stored starting at location `0x4004a1` in
    memory.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `Hello, World!\n`，编译器将这个文本字符串作为一个常量字符数组存储。为了指定这个数组的范围，C 风格的字符串使用代码点 U+0000（ASCII
    `NUL`）作为字符串结尾的 *哨兵* 值，哨兵值是一个唯一值，用来标示字符序列的结束。因此，编译器必须为这个字符串分配 15 个字节：13 个字节用于 `Hello,
    World!`，1 个字节用于换行符 `\n`，1 个字节用于 `NUL`。 [表 2-6](ch02.xhtml#ch2tab6) 显示了这个文本字符串如何从内存位置
    `0x4004a1` 开始存储。
- en: '**Table 2-6:** `Hello, World!\n` Stored in Memory'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-6：** `Hello, World!\n` 存储在内存中'
- en: '| **Address** | **Content** | **Address** | **Content** |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| **地址** | **内容** | **地址** | **内容** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `0x4004a1` | `0x48` | `0x4004a9` | `0x6f` |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `0x4004a1` | `0x48` | `0x4004a9` | `0x6f` |'
- en: '| `0x4004a2` | `0x65` | `0x4004aa` | `0x72` |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `0x4004a2` | `0x65` | `0x4004aa` | `0x72` |'
- en: '| `0x4004a3` | `0x6c` | `0x4004ab` | `0x6c` |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `0x4004a3` | `0x6c` | `0x4004ab` | `0x6c` |'
- en: '| `0x4004a4` | `0x6c` | `0x4004ac` | `0x64` |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `0x4004a4` | `0x6c` | `0x4004ac` | `0x64` |'
- en: '| `0x4004a5` | `0x6f` | `0x4004ad` | `0x21` |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `0x4004a5` | `0x6f` | `0x4004ad` | `0x21` |'
- en: '| `0x4004a6` | `0x2c` | `0x4004ae` | `0x0a` |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `0x4004a6` | `0x2c` | `0x4004ae` | `0x0a` |'
- en: '| `0x4004a7` | `0x20` | `0x4004af` | `0x00` |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `0x4004a7` | `0x20` | `0x4004af` | `0x00` |'
- en: '| `0x4004a8` | `0x57` | — | — |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `0x4004a8` | `0x57` | — | — |'
- en: C uses U+000A (ASCII `LF`) as a newline character (at address `0x4004ae` in
    this example), even though the C syntax requires that the programmer write two
    characters, `\n`. The text string ends with the `NUL` character at `0x4004af`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: C 使用 U+000A（ASCII `LF`）作为换行符（在此示例中位于地址 `0x4004ae`），尽管 C 语法要求程序员写出两个字符 `\n`。文本字符串以
    `NUL` 字符（位于 `0x4004af`）结尾。
- en: In Pascal, another programming language, the length of a string is specified
    by the first byte in the string, which is taken to be an 8-bit unsigned integer.
    (This is the reason for the 256-character limit on text strings in Pascal.) The
    C++ string class has additional features, but the actual text string is stored
    as a C-style text string within the C++ string instance.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pascal 语言中，字符串的长度由字符串中的第一个字节指定，该字节被视为一个 8 位无符号整数。（这也是 Pascal 中文本字符串限制为 256
    个字符的原因。）C++ 的字符串类有更多功能，但实际的文本字符串仍然存储为 C 风格的文本字符串，嵌套在 C++ 字符串实例中。
- en: '***Unsigned Integers***'
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***无符号整数***'
- en: Since an unsigned integer can be expressed in any radix, probably the most obvious
    way to store it is to use the binary number system. If we number the bits in a
    byte from right to left, then the lowest-order bit would be stored in bit 0, the
    next in bit 1, and so forth. For example, the integer 123[10] = `7b`[16], so the
    state of the byte where it is stored would be `01111011`[2]. Using only a single
    byte restricts the range of unsigned integers to be from 0 to 255[10], since `ff`[16]
    = 255[10]. The default size for an unsigned integer in our programming environment
    is 4 bytes, which allows for a range of 0 to 4,294,967,295[10].
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无符号整数可以用任何进制表示，最明显的存储方式可能就是使用二进制数系统。如果我们从右到左给一个字节的位编号，那么最低位将存储在位0，接下来的位存储在位1，以此类推。例如，整数123[10]
    = `7b`[16]，因此它存储的字节状态将是`01111011`[2]。仅使用一个字节会将无符号整数的范围限制在0到255[10]之间，因为`ff`[16]
    = 255[10]。在我们的编程环境中，无符号整数的默认大小是4字节，允许的范围是0到4,294,967,295[10]。
- en: One limitation of using the binary number system is that you need to convert
    a decimal number from a character string to the binary number system before performing
    arithmetic operations on it. For example, the decimal number 123 would be stored
    in character string format as the four bytes `0x31`, `0x32`, `0x33`, and `0x00`,
    while in unsigned integer format, it would be stored as the 4-byte binary number
    `0x0000007b`. At the other end, binary numbers need to be converted to their decimal
    character representations for most real-world display purposes.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二进制数系统的一个限制是，在对十进制数进行算术操作之前，你需要将其从字符字符串转换为二进制数系统。例如，十进制数123将以字符字符串格式存储为四个字节`0x31`、`0x32`、`0x33`和`0x00`，而在无符号整数格式中，它将以4字节的二进制数`0x0000007b`存储。在另一端，为了大多数现实世界的显示用途，二进制数需要转换为它们的十进制字符表示。
- en: '*Binary coded decimal (BCD)* is another code for storing integers. It uses
    4 bits for each decimal digit, as shown in [Table 2-7](ch02.xhtml#ch2tab7).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*二进制编码十进制（BCD）*是另一种存储整数的编码方式。它为每个十进制数字使用4位，如[表2-7](ch02.xhtml#ch2tab7)所示。'
- en: '**Table 2-7:** Binary Coded Decimal'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-7：** 二进制编码十进制'
- en: '| **Decimal digit** | **BCD code** |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| **十进制数字** | **BCD码** |'
- en: '| --- | --- |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | `0000` |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 0 | `0000` |'
- en: '| 1 | `0001` |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `0001` |'
- en: '| 2 | `0010` |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `0010` |'
- en: '| 3 | `0011` |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 3 | `0011` |'
- en: '| 4 | `0100` |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 4 | `0100` |'
- en: '| 5 | `0101` |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 5 | `0101` |'
- en: '| 6 | `0110` |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 6 | `0110` |'
- en: '| 7 | `0111` |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 7 | `0111` |'
- en: '| 8 | `1000` |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 8 | `1000` |'
- en: '| 9 | `1001` |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 9 | `1001` |'
- en: For example, in a 16-bit storage location, the decimal number 1,234 would be
    stored in BCD as `0001 0010 0011 0100` (in the binary number system, it would
    be `0000 0100 1101 0010`).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个16位的存储位置中，十进制数1,234将以BCD格式存储为`0001 0010 0011 0100`（在二进制数系统中，它将是`0000 0100
    1101 0010`）。
- en: With only 10 of the possible 16 combinations being used, six bit patterns are
    wasted. This means that a 16-bit storage location has a range of 0 to 9,999 for
    values if we use BCD, compared to a range of 0 to 65,535 if we use binary. This
    is a less efficient use of memory. On the other hand, the conversions between
    a character format and an integer format are simpler with BCD, as you will learn
    in [Chapter 16](ch16.xhtml).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有可能的16种组合中的10种被使用，剩余的六种位模式被浪费了。这意味着，如果我们使用BCD，一个16位的存储位置可以存储0到9,999之间的值，而如果使用二进制，它的范围则是0到65,535。这是内存利用效率较低的一种方式。另一方面，BCD在字符格式和整数格式之间的转换更简单，正如你将在[第16章](ch16.xhtml)中学到的那样。
- en: BCD is important in specialized systems that deal primarily with numerical business
    data, because they tend to print numbers more often than they perform mathematical
    operations on them. COBOL, a programming language intended for business applications,
    supports a packed BCD format where two digits (in BCD code) are stored in each
    8-bit byte. Here, the *last* (4-bit) digit is used to store the sign of the number,
    as shown in [Table 2-8](ch02.xhtml#ch2tab8). The specific codes used depend upon
    the implementation.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: BCD在专门处理数字业务数据的系统中非常重要，因为这些系统通常比执行数学运算更频繁地打印数字。COBOL是一种面向业务应用的编程语言，支持打包BCD格式，其中每个8位字节存储两个BCD码数字。这里，*最后*（4位）的数字用于存储数字的符号，如[表2-8](ch02.xhtml#ch2tab8)所示。使用的具体代码取决于实现。
- en: '**Table 2-8:** Example Sign Codes for Packed BCD Format'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-8：** 打包BCD格式的示例符号代码'
- en: '| **Sign** | **Sign code** |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **符号代码** |'
- en: '| --- | --- |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| + | `1010` |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| + | `1010` |'
- en: '| – | `1011` |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| – | `1011` |'
- en: '| + | `1100` |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| + | `1100` |'
- en: '| – | `1101` |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| – | `1101` |'
- en: '| + | `1110` |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| + | `1110` |'
- en: '| Unsigned | `1111` |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| 无符号 | `1111` |'
- en: For example, `0001 0010 0011 1010` represents +123, `0001 0010 0011 1011` represents
    –123, and `0001 0010 0011 1111` represents 123.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`0001 0010 0011 1010` 表示 +123，`0001 0010 0011 1011` 表示 -123，`0001 0010 0011
    1111` 表示 123。
- en: Next, we’ll explore some of these concepts using the C programming language.
    If you’re new to C, this discussion will provide an introduction to the language.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 C 编程语言来探讨这些概念。如果你是 C 新手，这个讨论将为你提供语言的介绍。
- en: '**Exploring Data Formats with C**'
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 C 探索数据格式**'
- en: In this section, we’ll write our first programs with the C programming language.
    These particular programs illustrate the differences between how numbers are stored
    in memory and how we humans read them. C allows us to get close enough to the
    hardware to understand the core concepts, while taking care of many of the low-level
    details. You shouldn’t find the simple C programs in this book too difficult,
    especially if you already know how to program in another language.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将使用 C 编程语言编写我们的第一个程序。这些特定的程序展示了数字在内存中存储的方式与我们人类读取它们的方式之间的差异。C 语言使我们能够接近硬件，理解核心概念，同时处理许多底层的细节。你应该不会觉得本书中的简单
    C 程序太难，尤其是如果你已经会使用其他语言编程的话。
- en: If you learned how to program in a higher-level language, such as C++, Java,
    or Python, you probably learned object-oriented programming. C doesn’t support
    the object-oriented paradigm; it is a *procedural* programming language. C programs
    are divided into *functions*, where a function is a named group of programming
    statements. Other programming languages also use the terms *procedure* and *subprogram*,
    with some minor distinctions between them depending on the language.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经在更高级的语言中学习编程，如 C++、Java 或 Python，你可能学过面向对象编程。C 不支持面向对象的编程范式；它是一种*过程式*编程语言。C
    程序被分为*函数*，函数是一个命名的编程语句组。其他编程语言也使用*过程*和*子程序*这些术语，根据语言的不同，它们之间可能有一些细微的区别。
- en: '***Using C and C++ I/O Libraries***'
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 C 和 C++ I/O 库***'
- en: Most high-level programming languages include a standard library that can be
    thought of as part of the language. A *standard library* contains functions and
    data structures that can be used in the language for doing common things such
    as terminal I/O (writing to the screen and reading from the keyboard). C includes
    the *C standard library* and C++ includes the *C++ standard library*.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数高级编程语言都包含一个标准库，可以将其视为语言的一部分。一个*标准库*包含可以在语言中用于执行常见任务的函数和数据结构，如终端I/O（向屏幕写入和从键盘读取）。C
    包含 *C 标准库*，C++ 包含 *C++ 标准库*。
- en: 'C programmers use functions in the `stdio` library for terminal I/O, while
    C++ programmers use functions in the `iostream` library. For example, the C code
    sequence for reading an integer from the keyboard, adding 100 to it, and writing
    the result to the screen looks like this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: C 程序员使用 `stdio` 库中的函数进行终端 I/O，而 C++ 程序员则使用 `iostream` 库中的函数。例如，读取键盘输入的整数，给它加
    100，并将结果写入屏幕的 C 代码序列如下：
- en: '[PRE7]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The C++ code sequence looks something like this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的代码序列大致如下：
- en: '[PRE8]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In both examples, the code reads characters (each as a separate `char`) from
    the keyboard and converts the `char` sequence into the corresponding `int` format.
    Then, it adds 100 to the `int` before converting the result into a `char` sequence
    and displaying it on the screen. The C or C++ I/O library functions in the previous
    code snippets do the necessary conversions between `char` sequences and the `int`
    storage format.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个示例中，代码从键盘读取字符（每个字符作为一个独立的 `char`），并将 `char` 序列转换为相应的 `int` 格式。然后，它将 `int`
    加 100 后，再将结果转换回 `char` 序列并在屏幕上显示。前面的 C 或 C++ I/O 库函数完成了 `char` 序列和 `int` 存储格式之间的必要转换。
- en: '[Figure 2-1](ch02.xhtml#ch2fig1) shows the relationship between a C application
    program, the I/O libraries, and the operating system.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-1](ch02.xhtml#ch2fig1) 显示了 C 应用程序、I/O 库和操作系统之间的关系。'
- en: '![Image](../images/pg52_Image_17.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg52_Image_17.jpg)'
- en: '*Figure 2-1: The relationship of I/O libraries to the application and the operating
    system*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：I/O 库与应用程序和操作系统的关系*'
- en: When reading from the keyboard, the `scanf` library function first calls the
    `read` *system call* function, a function in the operating system, to read characters
    from the keyboard. The input on the keyboard is in the form of a string of characters,
    each of the `char` data type. The `scanf` library function performs the conversion
    of this string to the `int` data type for the application program. The `printf`
    library function converts from the `int` data type to the corresponding string
    of characters in the `char` data type and calls the `write` system call function
    to write each character to the screen.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当从键盘读取时，`scanf`库函数首先调用`read` *系统调用* 函数，这是操作系统中的一个函数，用于从键盘读取字符。键盘上的输入是一个字符串，每个字符都是`char`数据类型。`scanf`库函数将这个字符串转换为应用程序所需的`int`数据类型。`printf`库函数则将`int`数据类型转换为对应的字符串，并调用`write`系统调用函数将每个字符写入屏幕。
- en: In [Figure 2-1](ch02.xhtml#ch2fig1), an application program can call the `read`
    and `write` functions directly to transfer characters. We’ll explore this in [Chapter
    16](ch16.xhtml), where we’ll write our own conversion functions. Although the
    C/C++ library functions do a much better job of this than we will, the exercise
    of doing it yourself will give you a better understanding of how data is stored
    in memory and manipulated by software.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图2-1](ch02.xhtml#ch2fig1)中，一个应用程序可以直接调用`read`和`write`函数来传输字符。我们将在[第16章](ch16.xhtml)中深入探讨这一点，届时我们将编写自己的转换函数。尽管C/C++库函数在这方面做得比我们好得多，但亲自实现这个功能将帮助你更好地理解数据是如何存储在内存中并被软件操作的。
- en: '**NOTE**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Even if you’re familiar with the GNU* make *program, it’s worth learning how
    to use it to build your programs. It may seem like overkill at this point, but
    it’s much easier to learn with simple programs. The manual is available in several
    formats at* [https://www.gnu.org/software/make/manual/](https://www.gnu.org/software/make/manual/)*,
    and my comments about using it are available on my website at* [https://rgplantz.github.io](https://rgplantz.github.io).'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*即使你熟悉GNU* make *程序，学习如何使用它来构建你的程序也是值得的。此时可能看起来有点多余，但对于简单的程序来说，学习起来更容易。手册可以通过几种格式在*
    [https://www.gnu.org/software/make/manual/](https://www.gnu.org/software/make/manual/)
    *获取，我对使用它的评论可以在我的网站上找到，网址是* [https://rgplantz.github.io](https://rgplantz.github.io)。'
- en: '***Writing and Executing Your First C Program***'
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写和执行你的第一个C程序***'
- en: Most programming books start with a simple program that just prints “Hello,
    World!” to a computer screen, but we’ll start with a program that reads a hexadecimal
    value, both as an unsigned integer and as a text string ([Listing 2-1](ch02.xhtml#ch2list1)).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程书籍从一个简单的程序开始，这个程序仅仅是将“Hello, World!”打印到计算机屏幕上，但我们将从一个程序开始，它读取一个十六进制值，既作为无符号整数，也作为文本字符串（[示例2-1](ch02.xhtml#ch2list1)）。
- en: '*int_and_string.c*'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '*int_and_string.c*'
- en: '[PRE9]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 2-1: A program showing the difference between an integer and a text
    string*'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例2-1：显示整数和文本字符串之间差异的程序*'
- en: We start our code with some documentation that gives a brief description of
    what the program does ❶. When writing your own source files, you should also include
    your name and the date they were written as part of the documentation (I’ve omitted
    them in the example programs in this book to save space). All text following two
    slash characters, `//`, on a line is a comment. C also allows us to start a multiple-line
    comment using `/*` and end it using `*/`. Comments are for the human reader and
    have no effect on the program itself.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一些文档开始我们的代码，这些文档简要描述了程序的功能❶。当编写自己的源文件时，您也应当在文档中包括您的名字和编写日期（在本书的示例程序中为了节省空间，我省略了这些内容）。在一行中，紧跟两个斜杠字符`//`后的所有文本都是注释。C语言还允许我们使用`/*`开始一个多行注释，并用`*/`结束它。注释是给人类读者看的，对程序本身没有任何影响。
- en: The first operation that actually affects the program is the inclusion of a
    *header file*, *stdio.h* ❷, using the `#include` directive. As you will learn,
    the C compiler needs to know the type of each data item that is passed to or from
    a function. A header file is used to provide a *prototype statement* for each
    function, which specifies these data types. The *stdio.h* header file defines
    the interface to many of the functions in the C standard library, which tells
    the compiler what to do when calls to any of these functions are encountered in
    our source code. The *stdio.h* header file is already installed on your computer
    in a location the compiler knows.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 实际影响程序的第一个操作是使用 `#include` 指令包含*头文件*，即 *stdio.h* ❷。正如你将要学习的，C 编译器需要知道传递给或从函数返回的每个数据项的类型。头文件用于提供每个函数的*原型声明*，以指定这些数据类型。*stdio.h*
    头文件定义了 C 标准库中许多函数的接口，告诉编译器在我们的源代码中遇到这些函数的调用时该怎么做。*stdio.h* 头文件已经安装在你的计算机上，存放在编译器知道的位置。
- en: 'The remaining code in this listing is the definition of a C `main` function.
    All C programs are made up of functions, which have this general format:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 本清单中的其余代码是 C `main` 函数的定义。所有 C 程序都由函数组成，这些函数具有以下一般格式：
- en: '[PRE10]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When a C program is executed, the operating system first sets up either a *hosted
    environment* or a *freestanding environment*, which sets up the resources on your
    computer to run the program. The hosted environment includes access to the functions
    in the C standard library, while the freestanding environment does not. Most of
    the programs in this book run in the hosted environment. I’ll show you how to
    use the freestanding environment in “Supervisor Calls” on [page 474](ch21.xhtml#ch21lev1sec5)
    in [Chapter 21](ch21.xhtml).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 C 程序被执行时，操作系统首先设置一个*托管环境*或*独立环境*，这会为你的计算机配置资源以运行该程序。托管环境包括对 C 标准库中函数的访问，而独立环境则不包括。书中大部分程序运行在托管环境中。关于如何在[第21章](ch21.xhtml)的“管理调用”部分使用独立环境，我会在[第474页](ch21.xhtml#ch21lev1sec5)进行说明。
- en: In the C hosted environment, program execution starts with the `main` function,
    meaning that the program you write must include a function whose function name
    is `main`. The `main` function can call other functions, which in turn can call
    other functions. But program control normally ends up back in the `main` function,
    which then returns to the C hosted environment.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 托管环境中，程序的执行从 `main` 函数开始，这意味着你编写的程序必须包含一个名为 `main` 的函数。`main` 函数可以调用其他函数，而这些函数又可以调用其他函数。但是，程序控制通常会最终回到
    `main` 函数，然后返回到 C 托管环境。
- en: When a function is called in C, the calling function can include a list of *arguments*
    in the call as inputs to the called function. These inputs serve as *parameters*
    in the computation performed by the called function. For example, in [Listing
    2-1](ch02.xhtml#ch2list1), when the program first starts, the `main` function
    calls the `printf` function with one argument, a text string ❹. The `printf` function
    uses the text string to determine what to display on the screen. We’ll look closely
    at how arguments are passed to functions and how they’re used as parameters in
    the function in [Chapter 14](ch14.xhtml). The `main` function in [Listing 2-1](ch02.xhtml#ch2list1)
    does not need any data from the C hosted environment; we show this in its definition
    by using `void` for the parameter list.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 C 中调用一个函数时，调用函数可以在调用中包含一个*参数*列表，作为输入传递给被调用的函数。这些输入作为被调用函数中执行计算的*参数*。例如，在[清单
    2-1](ch02.xhtml#ch2list1)中，当程序首次启动时，`main` 函数调用了 `printf` 函数，并传递了一个参数，即文本字符串 ❹。`printf`
    函数使用这个文本字符串来确定屏幕上显示的内容。在[第14章](ch14.xhtml)中，我们将仔细查看参数如何传递给函数，以及它们如何作为参数在函数中使用。[清单
    2-1](ch02.xhtml#ch2list1)中的 `main` 函数不需要来自 C 托管环境的数据；我们通过在其定义中使用 `void` 作为参数列表来表示这一点。
- en: Upon completing execution, a function normally returns to the calling function.
    The called function can pass a data item to the calling function when returning.
    A `main` function should return a single integer to the C hosted environment,
    indicating whether the program detected any errors in its execution. Thus, the
    return-data-type for `main` is `int`. The `main` function in [Listing 2-1](ch02.xhtml#ch2list1)
    returns the integer 0 to the C hosted environment, which passes this value to
    the operating system.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完成后，函数通常会返回到调用函数。当返回时，被调用函数可以将一个数据项传递给调用函数。`main`函数应该返回一个整数值给C语言环境，表示程序在执行过程中是否检测到任何错误。因此，`main`的返回数据类型是`int`。[Listing
    2-1](ch02.xhtml#ch2list1)中的`main`函数将整数0返回给C语言环境，并将此值传递给操作系统。
- en: 'In [Listing 2-1](ch02.xhtml#ch2list1), we define two variables in the `main`
    function at the beginning of the function body: an unsigned integer named `an_int`
    and a text string named `a_string` ❸. Most modern programming languages allow
    us to introduce new variables anywhere in the code, but C requires that they be
    listed at the beginning of the function. (There are some exceptions to this rule,
    but they are beyond the scope of this book.) Think of it as listing the ingredients
    for a recipe before giving the instructions on how to use them. We *define* a
    variable by introducing its name and specifying its data type. The `[10]` notation
    tells the compiler to allocate an array of 10 `char`s for the `a_string` variable,
    which will allow us to store a C-style text string up to nine characters long.
    (The 10th `char` would be the terminating `NUL` character.) We’ll look at arrays
    in detail in [Chapter 17](ch17.xhtml).'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Listing 2-1](ch02.xhtml#ch2list1)中，我们在`main`函数的函数体开始部分定义了两个变量：一个无符号整数`an_int`和一个文本字符串`a_string`
    ❸。大多数现代编程语言允许我们在代码的任何地方引入新变量，但C语言要求它们必须在函数开始时列出。（这一规则有一些例外，但它们超出了本书的范围。）可以把它当作是在给出如何使用它们的指令之前，先列出食谱中的原料。我们通过引入变量名并指定其数据类型来*定义*一个变量。`[10]`符号告诉编译器为`a_string`变量分配一个长度为10的`char`数组，这样我们就可以存储一个最多9个字符的C风格文本字符串。（第10个`char`是终止的`NUL`字符。）我们将在[第17章](ch17.xhtml)详细讨论数组。
- en: The program uses the `printf` function from the C standard library to display
    text on the screen. The first argument in the call to `printf` is a *format string*,
    which is a text string made up of ordinary characters (except `%`) to display
    on the screen.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用C标准库中的`printf`函数在屏幕上显示文本。对`printf`的调用中的第一个参数是一个*格式字符串*，它是由普通字符（除了`%`）组成的文本字符串，用于在屏幕上显示。
- en: The simplest format string for `printf` is just the text you want printed, without
    any variables. If you want to print the values of variables, the format string
    acts as a template of the text you want printed. The place in the text string
    where you want the value of a variable to be printed is marked with a *conversion
    specifier*. Each conversion specifier begins with the `%` character, and the names
    of the variables are listed after the format string in the same order that their
    respective conversion specifiers appear in the template ❼.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf`的最简单格式字符串就是你想打印的文本，没有任何变量。如果你想打印变量的值，格式字符串就充当了你想打印的文本模板。在文本字符串中，你希望打印变量值的位置由一个*转换说明符*标记。每个转换说明符以`%`字符开头，变量名按照它们在模板中出现的顺序列出，位于格式字符串后面
    ❼。'
- en: The `%` character that begins a conversion specifier is immediately followed
    by one or more conversion code characters to tell `printf` how to display the
    value of the variable. [Table 2-9](ch02.xhtml#ch2tab9) shows some common conversion
    specifiers for `printf` and `scanf` format strings.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`%`字符是每个转换说明符的开头，后面紧跟一个或多个转换代码字符，用以告诉`printf`如何显示变量的值。[表2-9](ch02.xhtml#ch2tab9)展示了`printf`和`scanf`格式字符串的一些常见转换说明符。'
- en: '**Table 2-9:** Some Common Conversion Specifiers'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-9：** 一些常见的转换说明符'
- en: '| **Conversion specifier** | **Representation** |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| **转换说明符** | **表示方式** |'
- en: '| --- | --- |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `%u` | Unsigned decimal integer |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| `%u` | 无符号十进制整数 |'
- en: '| `%d` or `%i` | Signed decimal integer |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `%d` 或 `%i` | 有符号十进制整数 |'
- en: '| `%f` | Float |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `%f` | 浮点数 |'
- en: '| `%x` | Hexadecimal |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `%x` | 十六进制 |'
- en: '| `%s` | Text string |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `%s` | 文本字符串 |'
- en: The conversion specifiers can include other characters that specify properties,
    such as the field width of the display, whether the value is left-or right-justified
    within the field, and more. I won’t go into additional detail here; read man [page
    3](ch01.xhtml#page_3) for `printf` to learn more (enter the man 3 printf command
    to view the man page).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 转换说明符可以包含其他指定属性的字符，例如显示字段的宽度、值是否在字段内左对齐或右对齐等等。我这里不再详细讲解；要了解更多内容，请阅读`printf`的man
    [页面 3](ch01.xhtml#page_3)（输入man 3 printf命令查看man页面）。
- en: The first argument in the call to the C standard library function `scanf` is
    also a format string. We use the same conversion specifiers in the format string
    to tell the `scanf` function how to interpret the characters typed on the keyboard
    ❺. We tell `scanf` where to store the input integer by using the *address of*
    operator on the variable name, `&an_int`. When passing the name of an array to
    a function, C sends the address of the array, so we don’t use the `&` operator
    when calling `scanf` to read a text string from the keyboard ❻.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 调用C标准库函数`scanf`时，第一个参数也是格式字符串。我们在格式字符串中使用相同的转换说明符来告诉`scanf`函数如何解释键盘输入的字符 ❺。我们通过使用*地址运算符*（&）来告诉`scanf`将输入的整数存储在变量`&an_int`中。当将数组的名称传递给函数时，C会传递数组的地址，因此在调用`scanf`读取文本字符串时，我们不需要使用`&`运算符
    ❻。
- en: Any other character included in the format string for `scanf` besides these
    conversion specifiers must be matched exactly by the keyboard input. For example,
    the format string
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在`scanf`的格式字符串中，除了这些转换说明符外，格式字符串中的其他字符必须与键盘输入完全匹配。例如，格式字符串
- en: '[PRE11]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: requires an input like
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 需要类似下面的输入：
- en: '[PRE12]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: which would read the integers 123 and 456 from the keyboard. You can read man
    [page 3](ch01.xhtml#page_3) for `scanf` to learn more (enter the man 3 scanf command).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从键盘读取整数123和456。你可以阅读man [页面 3](ch01.xhtml#page_3)了解`scanf`的更多信息（输入man 3 scanf命令）。
- en: Finally, the `main` function returns 0 to the C hosted environment, which passes
    this value to the operating system. The value 0 tells the operating system that
    everything went smoothly ❽.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main`函数向C托管环境返回0，C托管环境将此值传递给操作系统。值0告诉操作系统一切顺利 ❽。
- en: 'Compiling and running the program in [Listing 2-1](ch02.xhtml#ch2list1) on
    my computer gave the following output:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的计算机上编译并运行[列表 2-1](ch02.xhtml#ch2list1)中的程序，得到了以下输出：
- en: '[PRE13]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The program in [Listing 2-1](ch02.xhtml#ch2list1) demonstrates an important
    concept: hexadecimal is used as a human convenience for stating bit patterns.
    A number is not inherently binary, decimal, or hexadecimal; it’s simply a value.
    And a specific value can be expressed equivalently in each of these three number
    bases. For that matter, it can be expressed equivalently in *any* number base
    (2, 16, 285, and so forth), but since a computer consists of binary switches,
    it makes sense to think of numerical values stored in a computer in terms of the
    binary number base.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-1](ch02.xhtml#ch2list1)中的程序演示了一个重要概念：十六进制是人类为了表示位模式而使用的便捷方式。一个数字本身并不是二进制、十进制或十六进制的；它仅仅是一个值。并且，可以在这三种数字进制中等价地表示一个特定的值。事实上，它还可以在*任何*数字进制（2、16、285等等）中等价表示，但由于计算机由二进制开关组成，因此从二进制数制的角度来看存储在计算机中的数值是有意义的。'
- en: '**YOUR TURN**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮到你了**'
- en: '2.16     Write a hexadecimal-to-decimal converter program in C. Your program
    will allow a user to enter a number in hexadecimal and will then print the decimal
    equivalent. The output should look like this: `0x7b = 123`.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 2.16     编写一个十六进制到十进制转换的C程序。程序将允许用户输入一个十六进制数，并打印出对应的十进制值。输出应该是这样的：`0x7b = 123`。
- en: '2.17     Write a decimal-to-hexadecimal converter program in C. Your program
    will allow a user to enter a number in decimal and will then print the hexadecimal
    equivalent. The output should look like this: `123 = 0x7b`.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 2.17     编写一个十进制到十六进制转换的C程序。程序将允许用户输入一个十进制数，然后打印出对应的十六进制值。输出应该是这样的：`123 = 0x7b`。
- en: 2.18     Change `%u` to `%i` in the last `printf` statement in the program in
    [Listing 2-1](ch02.xhtml#ch2list1). What does the program print if you enter `ffffffff`?
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 2.18     将程序[列表 2-1](ch02.xhtml#ch2list1)中最后一个`printf`语句的`%u`改为`%i`。如果输入`ffffffff`，程序会打印什么？
- en: '**Examining Memory with a Debugger**'
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用调试器检查内存**'
- en: Now that we’ve started writing programs, you’ll need to learn how to use the
    GNU debugger, `gdb`. A *debugger* is a program that allows you to run your program
    while you observe and control its behavior. When you use a debugger, it’s a little
    like you’re a puppeteer and your program is a carefully controlled puppet. Your
    main instrument of control is the *breakpoint*; when you set a breakpoint and
    your program reaches it while running, the program will pause and return control
    to the debugger. When control is with the debugger, you can look at the values
    stored in your program’s variables, which can help you figure out where any bugs
    are.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经开始编写程序，你需要学习如何使用GNU调试器`gdb`。一个*调试器*是一个允许你在观察和控制程序行为的同时运行程序的工具。当你使用调试器时，它就像你是一个木偶师，而你的程序是一个精心控制的木偶。你主要的控制工具是*断点*；当你设置一个断点并且程序在运行时遇到它时，程序会暂停并将控制权交还给调试器。控制权交给调试器后，你可以查看程序变量中存储的值，这可以帮助你找出程序中的错误。
- en: If all this seems premature—our programs so far are simple and don’t seem to
    require debugging—I promise that it’s much better to learn how to use a debugger
    on a simple example than on a complicated program that does not work. `gdb` is
    also a valuable tool for learning the material in this book, even when you write
    bug-free programs. In the following `gdb` session dialog, I’ll show you how to
    determine where a variable is stored in memory and how to see what is stored there,
    both in decimal and in hexadecimal. You will see how to use `gdb` on a live program
    to illustrate the concepts discussed on the previous pages.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得这一切显得有些过早——到目前为止我们的程序很简单，似乎不需要调试——我保证，学习如何在简单的例子中使用调试器，要比在一个复杂的且无法运行的程序上学习要好得多。即使你编写的是没有错误的程序，`gdb`也是学习本书内容的一个有价值的工具。在接下来的`gdb`会话中，我将展示如何确定一个变量在内存中的存储位置，并查看存储在那里的是十进制值还是十六进制值。你将看到如何在一个运行中的程序上使用`gdb`，以说明前面几页讨论的概念。
- en: 'You’ll see more in [Chapters 9](ch09.xhtml) and [10](ch10.xhtml), but the `gdb`
    commands listed here should be enough to get you started:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[第9章](ch09.xhtml)和[第10章](ch10.xhtml)中看到更多内容，但这里列出的`gdb`命令足以让你开始使用：
- en: b source_filename:line_number   Set a breakpoint at the specified line_number
    in the source file, source_filename. The code will stop running at the breakpoint,
    when line_number is encountered, and return control to `gdb`, allowing you to
    test various elements of the code.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: b source_filename:line_number   在指定的source_filename文件中的line_number行设置一个断点。代码在遇到该断点时会停止运行，并将控制权交回给`gdb`，让你测试代码中的各种元素。
- en: c   Continue program execution from the current location.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: c   从当前的位置继续程序执行。
- en: h command   Get help on how to use command.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: h command   获取如何使用命令的帮助。
- en: i r   Show the contents of the registers (*info registers*). (You’ll learn about
    CPU registers in [Chapter 9](ch09.xhtml).)
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: i r   显示寄存器的内容（*info registers*）。(你将在[第9章](ch09.xhtml)中学习CPU寄存器。)
- en: l line_number   List 10 lines of the source code, centered at the specified
    line_number.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: l line_number   列出以指定line_number为中心的10行源代码。
- en: print expression   Evaluate expression and print the value.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: print expression   评估表达式并打印其值。
- en: printf "format", var1, var2, ..., varn   Display the values of var1`,` var2`,
    ...,` varn in a given format. The `"`format `"` string follows the same rules
    as for `printf` in the C standard library.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: printf "format", var1, var2, ..., varn   以给定格式显示var1, var2, ..., varn的值。`"`format`"`字符串遵循与C标准库中`printf`相同的规则。
- en: r   Run a program that has been loaded under the control of `gdb`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: r   在`gdb`控制下运行已加载的程序。
- en: x/nfs memory_address   Display (examine) n values in memory in format f of size
    s starting at memory_address.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: x/nfs memory_address   以指定格式f和大小s，从memory_address开始显示（检查）内存中的n个值。
- en: '***Using Your Debugger***'
  id: totrans-370
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用你的调试器***'
- en: Let’s walk through the program in [Listing 2-1](ch02.xhtml#ch2list1) using `gdb`
    to explore some of the concepts covered thus far. Follow along on your computer
    as you read this; it’s much easier to understand `gdb` when you’re using it. Note
    that the addresses you see on your computer will probably be different than those
    in this example.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用`gdb`在[清单 2-1](ch02.xhtml#ch2list1)中逐步执行程序，探索到目前为止覆盖的一些概念。阅读时请在你的电脑上跟着操作；当你实际使用`gdb`时，理解它会更容易。请注意，你在电脑上看到的地址可能与你在这个示例中看到的不同。
- en: 'I’ll start by compiling the program using the `gcc` command:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过使用`gcc`命令来编译程序：
- en: '[PRE14]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `-g` option tells the compiler to include debugger information in the executable
    program. The `-Wall` option tells the compiler to issue warnings about things
    in your code that are correct C code but still might not be what you intended
    to write. For example, it will warn you about declaring a variable in your function
    that is never used, which could mean you’ve forgotten something.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`-g` 选项告诉编译器将调试信息包含在可执行程序中。`-Wall` 选项告诉编译器发出警告，提醒你代码中看似正确的 C 代码可能并非你想要写的内容。例如，它会警告你在函数中声明了一个从未使用过的变量，这可能意味着你忘记了什么。'
- en: The `-o` option specifies the name of the output file, which is the executable
    program.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`-o` 选项指定输出文件的名称，即可执行程序。'
- en: 'Having compiled the program, I can run it under the control of `gdb` using
    this command:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译程序后，我可以使用此命令在 `gdb` 的控制下运行程序：
- en: '[PRE15]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `gdb` startup message, which I’ve removed from the previous output to save
    space, contains information about your debugger and refers you to its usage documentation.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`gdb` 启动时的消息，我已从之前的输出中删除以节省空间，包含有关调试器的信息，并参考其使用文档。'
- en: The `l` command lists 10 lines of source code and then returns control to the
    `gdb` program, as shown by the `(gdb)` prompt. Press ENTER to repeat the previous
    command, and `l` displays the next (up to) 10 lines.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`l` 命令列出 10 行源代码，然后将控制权交回给 `gdb` 程序，显示 `(gdb)` 提示符。按回车键可以重复上一个命令，`l` 会显示接下来的（最多）10行。'
- en: 'A breakpoint is used to stop the program and return control to the debugger.
    I like to set breakpoints where a function is about to call another function so
    I can examine the values in the argument variables before they are passed to the
    called function. This `main` function calls `printf` on line 15, so I set a breakpoint
    there. Since I’m already looking at the source code where I want to set a breakpoint,
    I don’t need to specify the filename:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 断点用于停止程序并将控制权返回给调试器。我喜欢在函数即将调用另一个函数时设置断点，这样我可以检查传递给被调用函数的参数变量的值。此 `main` 函数在第
    15 行调用 `printf`，所以我在这里设置了断点。由于我已经在查看源代码并希望设置断点的位置，因此不需要指定文件名：
- en: '[PRE16]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If `gdb` ever gets to this statement while executing the program, it will pause
    *before the statement is executed* and return control to the debugger.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `gdb` 在执行程序时遇到此语句，它将在*执行语句之前*暂停，并将控制权交回给调试器。
- en: 'Having set my breakpoint, I run the program:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好断点后，我运行程序：
- en: '[PRE17]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `r` command starts executing the program from the beginning. When the program
    reaches the breakpoint, control returns to `gdb`, which displays the next program
    statement that is ready to be executed. Before continuing execution, I display
    the contents of the two variables that are being passed to the `printf` function:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`r` 命令从头开始执行程序。当程序到达断点时，控制权返回给 `gdb`，它将显示下一个准备执行的程序语句。在继续执行之前，我会显示传递给 `printf`
    函数的两个变量的内容：'
- en: '[PRE18]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can use the `print` command to display the value currently stored in a variable.
    `gdb` knows the data type of each variable from the source code. It displays `int`
    variables in decimal. When displaying `char` variables, `gdb` will do its best
    to display the character glyph corresponding to the code point value. When there
    is no corresponding character glyph, `gdb` shows the code point as a `\` followed
    by three *octal* digits (see [Table 2-2](ch02.xhtml#ch2tab2)). For example, there
    is no character glyph for `NUL`, so `gdb` shows `\000` at the end of the text
    string I entered.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `print` 命令来显示当前存储在变量中的值。`gdb` 从源代码中知道每个变量的数据类型。它会以十进制显示 `int` 类型的变量。当显示
    `char` 类型的变量时，`gdb` 会尽力显示与代码点值相对应的字符图形。如果没有相应的字符图形，`gdb` 会以 `\` 后跟三个*八进制*数字来显示代码点值（见
    [表 2-2](ch02.xhtml#ch2tab2)）。例如，`NUL` 没有对应的字符图形，所以 `gdb` 在我输入的文本字符串末尾显示 `\000`。
- en: 'The `printf` command can format the displayed values. The formatting string
    is the same as for the `printf` function in the C standard library:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf` 命令可以格式化显示的值。格式化字符串与 C 标准库中的 `printf` 函数相同：'
- en: '[PRE19]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`gdb` provides another command, `x`, for examining the content of memory (that
    is, the actual bit patterns) directly. Its help message is brief, but it tells
    you everything you need to know:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`gdb` 还提供了一个命令 `x`，用于直接检查内存内容（即实际的位模式）。它的帮助消息简洁明了，但提供了你所需的所有信息：'
- en: '[PRE20]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `x` command needs the address of the area of memory to show. We can use
    the `print` command to find the address of a variable:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`x` 命令需要提供一个内存区域的地址来显示内容。我们可以使用 `print` 命令来查找变量的地址：'
- en: '[PRE21]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can use the `x` command to display the content of `an_int` in three different
    ways—one decimal word (`1dw`), one hexadecimal word (`1xw`), and four hexadecimal
    bytes (`4xb`)—as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`x`命令以三种不同的方式显示`an_int`的内容——一个十进制字（`1dw`），一个十六进制字（`1xw`），以及四个十六进制字节（`4xb`）——如下所示：
- en: '[PRE22]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**NOTE**'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The size of a* word *depends upon the computer environment you are using.
    In our environment, it’s 4 bytes.*'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个* 单词 *的大小取决于你使用的计算机环境。在我们的环境中，它是4个字节。*'
- en: The display of these four bytes may look out of order to you. The first byte
    ❶ is located at the address shown on the left of the row. The next byte in the
    row is at the subsequent address, `0x7fffffef7d`. So, this row displays each of
    the bytes stored at the memory addresses `0x7fffffef7c`, `0x7fffffef7d`, `0x7fffffef7e`,
    and `0x7fffffef7f`, reading from left to right, that make up the variable `an_int`.
    When displaying these same four bytes separately, the least significant byte appears
    *first* in memory. This is called *little-endian* storage order; I’ll explain
    further after this tour of `gdb`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这些四个字节的显示可能看起来乱序了。第一个字节❶位于行左侧显示的地址。行中的下一个字节位于后续地址`0x7fffffef7d`。因此，该行显示了位于内存地址`0x7fffffef7c`、`0x7fffffef7d`、`0x7fffffef7e`和`0x7fffffef7f`处的字节，从左到右依次排列，组成了变量`an_int`。当单独显示这四个字节时，最不重要的字节*首先*出现在内存中。这就是所谓的*小端存储顺序*；我将在之后的`gdb`教程中进一步解释。
- en: 'We can also display the content of the `a_string` variable by first getting
    its address:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过首先获取`a_string`变量的地址来显示其内容：
- en: '[PRE23]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we’ll look at the content of `a_string` in two ways, as 10 characters
    (`10c`) and as 10 hexadecimal bytes (`10xb`):'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将以两种方式查看`a_string`的内容，分别是10个字符（`10c`）和10个十六进制字节（`10xb`）：
- en: '[PRE24]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The character display shows the code point in decimal and the character glyph
    for each character. The hexadecimal byte display shows only the code point in
    hexadecimal for each byte. Both displays show the `NUL` character that marks the
    end of the six-character string we entered. Since we asked for a 10-byte display,
    the remaining 3 bytes have random values not related to our text string, often
    called *garbage values*.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 字符显示会以十进制显示每个字符的代码点及其字符字形。十六进制字节显示仅以十六进制显示每个字节的代码点。两种显示都显示了标记我们输入的六个字符字符串结束的`NUL`字符。由于我们请求显示10个字节，剩余的3个字节包含与我们的文本字符串无关的随机值，通常称为*垃圾值*。
- en: 'Finally, I continue execution of the program and then quit `gdb`:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我继续执行程序并退出`gdb`：
- en: '[PRE25]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***Understanding Byte Storage Order in Memory***'
  id: totrans-406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***理解内存中的字节存储顺序***'
- en: The difference between the full 4-byte display and the 1-byte display of the
    integer value at `0x7fffffef7c` in memory illustrates a concept known as *endianness*,
    or byte storage order. We usually read numbers from left to right. The digits
    to the left have more significance (count for more) than the digits to the right.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的4字节显示和内存中`0x7fffffef7c`处整数值的1字节显示之间的差异，说明了一个名为*字节序*（endianess）或字节存储顺序的概念。我们通常从左到右读取数字，左侧的数字比右侧的数字更具意义（占用更多）。
- en: '##### **Little-Endian**'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '##### **小端存储**'
- en: Data is stored in memory with the *least* significant byte in a multiple-byte
    value in the lowest-numbered address. That is, the “littlest” byte (counts the
    least) comes first in memory.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 数据在内存中存储时，*最不* 重要的字节在多字节值中位于地址编号最小的地方。也就是说，内存中存储的是“最小”（计数最少）的字节。
- en: 'When we examine memory one byte at a time, each byte is displayed in numerically
    ascending addresses:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们逐字节检查内存时，每个字节都会显示在按地址升序排列的内存地址中：
- en: '[PRE26]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'At first glance, the value appears to be stored backward, because the least
    significant (“little end”) byte of the value is stored first in memory. When we
    command `gdb` to display the entire 4-byte value, it knows that ours is a little-endian
    environment, and it rearranges the display of the bytes in the proper order:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，值似乎是反向存储的，因为值的最不重要的（“小端”）字节首先存储在内存中。当我们命令`gdb`显示整个4字节值时，它知道我们是小端环境，并会重新排列字节的显示顺序，使其正确：
- en: '[PRE27]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Big-Endian**'
  id: totrans-414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**大端存储**'
- en: Data is stored in memory with the *most* significant byte in a multiple-byte
    value in the lowest-numbered address. That is, the “biggest” byte (counts the
    most) comes first in memory.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 数据在内存中存储时，*最* 重要的字节在多字节值中位于地址编号最小的地方。也就是说，内存中存储的是“最大”（计数最多）的字节。
- en: 'If we ran the previous program on a big-endian computer, such as one using
    the PowerPC architecture, we would see the following (assuming the variable is
    located at the same address):'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在一台大端计算机上运行之前的程序，比如使用 PowerPC 架构的计算机，我们将看到以下内容（假设变量位于相同的地址）：
- en: '[PRE28]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That is, the 4 bytes in a big-endian computer would be stored as:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 即，在大端计算机中，4个字节将以以下方式存储：
- en: '[PRE29]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Again, `gdb` would know that this is a big-endian computer and so would display
    the full 4-byte value in the proper order.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`gdb` 会知道这是一个大端计算机，因此会以正确的顺序显示完整的 4 字节值。
- en: In the vast majority of programming situations, endianness is not an issue.
    However, you need to know about it because it can be confusing when examining
    memory in the debugger. Endianness is also an issue when different computers communicate
    with each other. For example, *Transport Control Protocol/Internet Protocol (TCP/IP)*
    is defined to be big-endian, sometimes called *network byte order*. The instructions
    in the AArch64 architecture are stored in little-endian order. The data can be
    stored in either order, but the default in our environment is little-endian, and
    the operating system reorders the bytes for internet communication. You also need
    to know about byte order if you’re writing communications software for an operating
    system itself or for an embedded system that may not have an operating system.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在绝大多数编程场景中，字节序并不是一个问题。然而，你需要了解它，因为在调试器中检查内存时它可能会让人困惑。字节序也是不同计算机之间通信时的问题。例如，*传输控制协议/互联网协议（TCP/IP）*
    被定义为大端，有时也叫做 *网络字节顺序*。AArch64 架构中的指令以小端顺序存储。数据可以存储为任意顺序，但我们环境中的默认顺序是小端，操作系统会为互联网通信重新排序字节。如果你为操作系统本身或者可能没有操作系统的嵌入式系统编写通信软件，你也需要了解字节顺序。
- en: '**YOUR TURN**'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的回合**'
- en: 2.19     Enter the program in [Listing 2-1](ch02.xhtml#ch2list1). Follow through
    the program with `gdb`. Using the numbers you get, explain where the variables
    `an_int` and `a_string` are stored in memory and what is stored in each location.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 2.19     在 [列表 2-1](ch02.xhtml#ch2list1) 中输入程序。用 `gdb` 跟踪程序。使用你得到的数字，解释 `an_int`
    和 `a_string` 变量在内存中的存储位置以及每个位置存储的内容。
- en: '**What You’ve Learned**'
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: '**Bits**   A computer is a collection of on/off switches that we can represent
    with bits.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '**比特**   计算机是由开/关开关组成的，我们可以用比特表示它们。'
- en: '**Hexadecimal**   This is a number system based on 16\. Each hexadecimal digit,
    `0` to `f`, represents 4 bits.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**十六进制**   这是基于 16 的数字系统。每个十六进制数字，`0` 到 `f`，代表 4 位。'
- en: '**Byte**   This is a group of 8 bits. The bit pattern can be expressed as two
    hexadecimal digits.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '**字节**   这是 8 位的一个组。该比特模式可以用两个十六进制数字表示。'
- en: '**Converting between decimal and binary**   The two number systems are mathematically
    equivalent.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '**十进制与二进制转换**   这两种数字系统在数学上是等价的。'
- en: '**Memory addressing**   Bytes in memory are numbered (addressed) sequentially.
    The byte’s address is usually expressed in hexadecimal.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存寻址**   内存中的字节按顺序编号（寻址）。字节的地址通常以十六进制表示。'
- en: '**Endianness**   An integer that is more than 1 byte can be stored with the
    highest-order byte in the lowest byte address (big-endian) or with the lowest-order
    byte in the lowest byte address (little-endian). Our environment is little-endian.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '**字节序**   一个超过 1 字节的整数可以将最高位字节存储在最低字节地址（大端）或将最低位字节存储在最低字节地址（小端）。我们的环境是小端。'
- en: '**UTF-8 encoding**   This is a code for storing characters in memory.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '**UTF-8 编码**   这是用于将字符存储在内存中的编码。'
- en: '**String**   A C-style string is an array of characters terminated by the `NUL`
    character.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串**   C 风格的字符串是一个由字符组成的数组，以 `NUL` 字符结束。'
- en: printf   This C library function is used to write formatted data on the screen.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: printf   这个 C 库函数用于在屏幕上输出格式化的数据。
- en: scanf   This C library function is used to read formatted data from the keyboard.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: scanf   这个 C 库函数用于从键盘读取格式化数据。
- en: '**Debugging**   The `gdb` debugger can be used to see how the variables change
    at each step in the execution of a program.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试**   `gdb` 调试器可以用来查看变量在程序执行的每一步中如何变化。'
- en: In the next chapter, you’ll learn about addition and subtraction in the binary
    number system for both unsigned and signed integers. This will illuminate some
    of the potential errors inherent in using a fixed number of bits to represent
    numerical values.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何在二进制数字系统中进行加法和减法运算，适用于无符号和有符号整数。这将揭示使用固定数量的比特表示数值时可能出现的一些潜在错误。
