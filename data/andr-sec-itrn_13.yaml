- en: Chapter 13. System Updates and Root Access
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章 系统更新与 Root 权限
- en: In the preceding chapters, we introduced Android’s security model and discussed
    how integrating SELinux into Android has reinforced it. In this chapter, we take
    a bit of a right turn and introduce methods that can be used to circumvent Android’s
    security model.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了 Android 的安全模型，并讨论了将 SELinux 集成到 Android 中是如何加强这一安全模型的。在本章中，我们稍微转变方向，介绍了一些可以绕过
    Android 安全模型的方法。
- en: In order to perform a full OS update or to restore the device to its factory
    state, it’s necessary to escape the security sandbox and gain full access to a
    device, because even the most privileged Android components are not given complete
    access to all system partitions and storage devices. Additionally, while having
    full administrative (root) access at runtime is clearly against Android’s security
    design, executing with root privileges can be useful in order to implement functionality
    not offered by Android, such as the addition of custom firewall rules or full
    (including system partitions) device backup. Indeed, the wide availability of
    custom Android builds (often called *ROMs*) and apps that allow users to extend
    or replace OS functionality using root access (commonly known as *root apps*)
    has been one of the reasons for Android’s success.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行完整的操作系统更新或将设备恢复到出厂状态，必须突破安全沙盒并获得设备的完全访问权限，因为即使是最特权的 Android 组件也没有完全访问所有系统分区和存储设备的权限。此外，尽管在运行时拥有完整的管理员（root）权限显然违背了
    Android 的安全设计，但使用 root 权限执行操作对于实现 Android 不提供的功能是有用的，例如添加自定义防火墙规则或进行完整（包括系统分区）的设备备份。事实上，定制的
    Android 版本（通常被称为 *ROMs*）以及允许用户通过 root 权限扩展或替代操作系统功能的应用程序（通常被称为 *root 应用*）的广泛可用性，正是
    Android 成功的原因之一。
- en: In this chapter, we explore the design of Android’s bootloader and recovery
    OS, and show how they can be used to replace the system software of a device.
    We then show how root access is implemented on engineering builds and how Android
    production builds can be modified to allow executing code with superuser privileges
    by installing a “superuser” application. Finally, we discuss how custom Android
    distributions implement and control root access.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Android 引导加载程序和恢复操作系统的设计，并展示了它们如何用于替换设备的系统软件。接着，我们展示了如何在工程版构建中实现
    root 权限，以及如何修改 Android 生产版构建以允许通过安装 “superuser” 应用程序执行具有超级用户权限的代码。最后，我们讨论了定制的
    Android 发行版如何实现和控制 root 权限。
- en: Bootloader
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导加载程序
- en: A *bootloader* is a low-level program that is executed when a device is powered.
    Its main purpose is to initialize the hardware and find and start the main operating
    system.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*引导加载程序*是一个在设备通电时执行的低级程序。它的主要目的是初始化硬件并找到并启动主操作系统。'
- en: As briefly discussed in [Chapter 10](ch10.html "Chapter 10. Device Security"),
    Android bootloaders are usually locked and only allow booting or installing an
    operating system image that has been signed by the device manufacturer. This is
    an important step in establishing a verified boot path, because it ensures that
    only trusted and unmodified system software can be installed on a device. However,
    while most users are not interested in modifying the core OS of their devices,
    installing a third-party Android build is a valid user choice and may even be
    the only way to run a recent version of Android on devices that have stopped receiving
    OS updates from their manufacturer. That is why most recent devices provide a
    way to unlock the bootloader and install third-party Android builds.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第10章](ch10.html "第10章. 设备安全")中简要讨论的那样，Android 引导加载程序通常是锁定的，只允许启动或安装已由设备制造商签名的操作系统镜像。这是建立受验证启动路径的重要步骤，因为它确保设备上只能安装受信任的、未修改的系统软件。然而，尽管大多数用户并不关心修改设备的核心操作系统，安装第三方
    Android 版本仍然是一个有效的用户选择，并且可能是运行已停止接收操作系统更新的设备上最新版本 Android 的唯一方法。这就是为什么大多数新设备提供解锁引导加载程序并安装第三方
    Android 版本的方式。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*While Android bootloaders are typically closed source, the bootloaders of
    most ARM devices based on Qualcomm SoCs are derived from the Little Kernel (LK)
    bootloader,*^([[137](#ftn.ch13fn01)]) *which is open source.*^([[138](#ftn.ch13fn02)])'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然 Android 的引导加载程序通常是封闭源代码的，但大多数基于 Qualcomm SoC 的 ARM 设备的引导加载程序是源自 Little
    Kernel (LK) 引导加载程序，*^([[137](#ftn.ch13fn01)]) *该引导加载程序是开源的。*^([[138](#ftn.ch13fn02)])'
- en: In the following sections, we’ll look at how to interact with Android bootloaders
    and how the bootloader can be unlocked on Nexus devices. We then describe the
    fastboot protocol used to update devices via the bootloader.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨如何与 Android 引导加载程序进行交互，以及如何在 Nexus 设备上解锁引导加载程序。然后，我们会描述通过引导加载程序更新设备时使用的
    fastboot 协议。
- en: Unlocking the Bootloader
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解锁引导加载程序
- en: The bootloaders of Nexus devices are unlocked by issuing the `oem unlock` command
    when the device is in fastboot mode (discussed in the next section). Therefore,
    in order to unlock a device, it must first be started in fastboot mode, either
    by issuing the `adb reboot bootloader` command (if the device already allows ADB
    access), or by pressing a special key combination while the device is booting.
    For example, holding down the Volume down, Volume up, and Power buttons simultaneously
    on a powered-down Nexus 5 interrupts the normal boot process and brings up the
    fastboot screen shown in [Figure 13-1](ch13.html#nexus_5_bootloader_screen "Figure 13-1. Nexus
    5 bootloader screen").
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Nexus 设备的引导加载程序通过在设备处于 fastboot 模式时发出 `oem unlock` 命令来解锁（将在下一节讨论）。因此，为了解锁设备，必须首先通过发出
    `adb reboot bootloader` 命令（如果设备已允许 ADB 访问）或通过在设备启动时按下特定的按键组合进入 fastboot 模式。例如，在关闭电源的
    Nexus 5 上同时按住音量下、音量上和电源按钮，会中断正常的启动过程，并显示[图 13-1](ch13.html#nexus_5_bootloader_screen
    "图 13-1. Nexus 5 引导加载程序屏幕")中的 fastboot 屏幕。
- en: The bootloader has a simple UI that can be driven by the Volume up/down and
    Power buttons. It allows users to continue the boot process, restart the device
    in fastboot or recovery mode, and power down the device.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序具有一个简单的用户界面，可以通过音量上下和电源按钮进行操作。它允许用户继续启动过程、在 fastboot 或恢复模式下重新启动设备，并关闭设备电源。
- en: Connecting the device to a host machine via a USB cable allows additional commands
    to be sent to the device using the `fastboot` command-line tool (part of the Android
    SDK). Issuing the `fastboot oem unlock` command brings up the confirmation screen
    shown in [Figure 13-2](ch13.html#nexus_5_bootloader_unlock_screen "Figure 13-2. Nexus
    5 bootloader unlock screen").
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 USB 电缆将设备连接到主机计算机可以使用 `fastboot` 命令行工具（Android SDK 的一部分）向设备发送额外的命令。发出 `fastboot
    oem unlock` 命令会显示确认屏幕，如[图 13-2](ch13.html#nexus_5_bootloader_unlock_screen "图
    13-2. Nexus 5 引导加载程序解锁屏幕")所示。
- en: '![Nexus 5 bootloader screen](figs/web/13fig01.png.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![Nexus 5 引导加载程序屏幕](figs/web/13fig01.png.jpg)'
- en: Figure 13-1. Nexus 5 bootloader screen
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-1. Nexus 5 引导加载程序屏幕
- en: '![Nexus 5 bootloader unlock screen](figs/web/13fig02.png.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Nexus 5 引导加载程序解锁屏幕](figs/web/13fig02.png.jpg)'
- en: Figure 13-2. Nexus 5 bootloader unlock screen
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-2. Nexus 5 引导加载程序解锁屏幕
- en: The confirmation screen warns that unlocking the bootloader allows installation
    of untested third-party OS builds and clears all user data. Because a third-party
    OS build might not follow Android’s security model and might allow unrestricted
    access to data, clearing all user data is an important security measure; it ensures
    that existing user data cannot be extracted after the bootloader is unlocked.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 确认屏幕警告解锁引导加载程序将允许安装未经测试的第三方操作系统构建，并清除所有用户数据。由于第三方操作系统构建可能不遵循 Android 的安全模型，并可能允许对数据的无限制访问，因此清除所有用户数据是一个重要的安全措施；它确保在引导加载程序解锁后无法提取现有的用户数据。
- en: The bootloader can be locked again by issuing the `fastboot oem lock` command.
    Relocking the bootloader returns it to its original state, and loading or booting
    third-party OS images is no longer possible. However, besides a locked/unlocked
    flag, some bootloaders keep an additional, “tampered” flag that is set when the
    bootloader is first unlocked. This flag allows the bootloader to detect if it
    has ever been locked and disallow some operations or show a warning even if it
    is in a locked state.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过发出 `fastboot oem lock` 命令可以重新锁定引导加载程序。重新锁定引导加载程序将其恢复到原始状态，并且不再能够加载或启动第三方操作系统镜像。然而，除了锁定/解锁标志之外，一些引导加载程序还会保持一个额外的“篡改”标志，该标志会在引导加载程序首次解锁时被设置。这个标志可以让引导加载程序检测它是否曾经被锁定，并在它处于锁定状态时拒绝某些操作或显示警告。
- en: Fastboot Mode
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fastboot 模式
- en: While the `fastboot` command and protocol can be used to unlock the boot-loader,
    their original purpose was to make it easy to clear or overwrite device partitions
    by sending partition images to the bootloader, which are then written to the specified
    block device. This is particularly useful when porting Android to a new device
    (referred to as “device bring-up”) or restoring a device to factory state using
    partition images provided by the device manufacturer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `fastboot` 命令和协议可用于解锁引导加载程序，但它们的初衷是简化通过向引导加载程序发送分区镜像来清除或覆盖设备分区，之后这些镜像会写入指定的块设备。当将
    Android 移植到新设备（称为“设备启动”）或使用设备制造商提供的分区镜像将设备恢复到出厂状态时，这特别有用。
- en: Android Partition Layout
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android 分区布局
- en: Android devices typically have several partitions, which fastboot refers to
    by name (rather than by the corresponding Linux device file). A list of partitions
    and their names can be obtained by listing the files in the *by-name/* directory
    corresponding to the device’s SoC in */dev/block/platform/*. For example, because
    the Nexus 5 is based on Qualcomm SoC, which includes a Mobile Station Modem (MSM)
    baseband processor, the corresponding directory is called *msm_sdcc.1/* as shown
    in [Example 13-1](ch13.html#list_of_partitions_on_a_nexus_5 "Example 13-1. List
    of partitions on a Nexus 5") (timestamps omitted).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Android 设备通常有多个分区，fastboot 通过名称（而不是对应的 Linux 设备文件）来引用这些分区。可以通过列出 *by-name/*
    目录中的文件来获取分区及其名称，该目录对应设备的 SoC，位于 */dev/block/platform/* 下。例如，由于 Nexus 5 基于高通 SoC，其中包含移动台基带处理器（MSM），因此对应的目录名为
    *msm_sdcc.1/*，如 [示例 13-1](ch13.html#list_of_partitions_on_a_nexus_5 "示例 13-1.
    Nexus 5 的分区列表") 中所示（省略时间戳）。
- en: Example 13-1. List of partitions on a Nexus 5
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-1. Nexus 5 的分区列表
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, the Nexus 5 has 29 partitions, most of which store device-specific
    and proprietary data, such as the Android bootloader in *aboot* ➊, the baseband
    software in *modem* ➎, and the second stage bootloader in *sbl1* ➐. The Android
    OS is hosted in the *boot* ➋ partition, which stores the kernel and the *rootfs*
    RAM disk image, and the *system* partition ➑, which stores all other system files.
    User files are stored in the *userdata* partition ➒, and temporary files, such
    as downloaded OTA images and recovery OS commands and logs, are stored in the
    *cache* partition ➌. Finally, the recovery OS image resides in the *recovery*
    partition ➏.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Nexus 5 有 29 个分区，其中大多数存储设备特定的专有数据，如 *aboot* ➊ 中的 Android 引导加载程序，*modem*
    ➎ 中的基带软件，以及 *sbl1* ➐ 中的第二阶段引导加载程序。Android 操作系统托管在 *boot* ➋ 分区中，存储内核和 *rootfs*
    RAM 磁盘镜像，*system* 分区 ➑ 存储所有其他系统文件。用户文件存储在 *userdata* 分区 ➒ 中，临时文件，如下载的 OTA 镜像和恢复操作系统命令及日志，存储在
    *cache* 分区 ➌ 中。最后，恢复操作系统镜像存储在 *recovery* 分区 ➏ 中。
- en: The Fastboot Protocol
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Fastboot 协议
- en: The fastboot protocol works over USB and is driven by the host. That is, communication
    is initiated by the host, which uses USB bulk transfers to send text-based commands
    and data to the bootloader. The USB client (boot-loader) responds with a status
    string such as *OKAY* or *FAIL*; an information message starting with *INFO*;
    or *DATA*, which signifies that the bootloader is ready to accept data from the
    host. When all data is received, the boot-loader responds with one of the *OKAY*,
    *FAIL*, or *INFO* messages describing the final status of the command.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: fastboot 协议通过 USB 工作，并由主机驱动。也就是说，通信是由主机发起的，主机使用 USB 批量传输将基于文本的命令和数据发送到引导加载程序。USB
    客户端（引导加载程序）会响应一个状态字符串，如 *OKAY* 或 *FAIL*；一个以 *INFO* 开头的信息消息；或 *DATA*，表示引导加载程序准备好接收来自主机的数据。当所有数据接收完毕后，引导加载程序会通过
    *OKAY*、*FAIL* 或 *INFO* 消息响应，描述命令的最终状态。
- en: Fastboot Commands
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Fastboot 命令
- en: The `fastboot` command-line utility implements the fastboot protocol, and allows
    you to get a list of connected devices that support fastboot (using the `devices`
    command), obtain information about the bootloader (with the `getvar` command),
    reboot the device in various modes (with `continue`, `reboot`, `reboot-bootloader`),
    and `erase` or `format` a partition.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`fastboot` 命令行工具实现了 fastboot 协议，允许你获取支持 fastboot 的已连接设备列表（使用 `devices` 命令），获取引导加载程序的信息（使用
    `getvar` 命令），以各种模式重启设备（使用 `continue`、`reboot`、`reboot-bootloader`），并 `erase` 或
    `format` 分区。'
- en: The `fastboot` command supports various ways to write a disk image to a partition.
    A single named partition can be flashed using the `flash` *`partition image-filename`*
    command, and multiple partition images contained in a ZIP file can be flashed
    at once using the `update` *`ZIP-filename`* command.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`fastboot`命令支持多种将磁盘镜像写入分区的方式。使用`flash` *`partition image-filename`*命令可以闪存单个命名分区，而使用`update`
    *`ZIP-filename`*命令可以一次性闪存ZIP文件中的多个分区镜像。'
- en: The `flashall` command automatically flashes the contents of the *boot.img*,
    *system.img*, and *recovery.img* files in its working directory to the *boot*,
    *system*, and *recovery* partitions of the device, respectively. Finally, the
    `flash:raw boot` *`kernel ramdisk`* command automatically creates a boot image
    from the specified kernel and RAM disk and flashes it to the *boot* partition.
    In addition to flashing partition images, `fastboot` can also be used to boot
    an image without writing it to the device when invoked with the `boot` *`boot-image`*
    or `boot` *`kernel ramdisk`* commands.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`flashall`命令会自动将其工作目录中的*boot.img*、*system.img*和*recovery.img*文件的内容分别闪存到设备的*boot*、*system*和*recovery*分区。最后，`flash:raw
    boot` *`kernel ramdisk`*命令会根据指定的内核和RAM磁盘自动创建一个启动镜像并将其闪存到*boot*分区。除了闪存分区镜像外，`fastboot`还可以在使用`boot`
    *`boot-image`*或`boot` *`kernel ramdisk`*命令时，启动一个镜像而无需将其写入设备。'
- en: Commands that modify device partitions, such as the various `flash` variations,
    and commands that boot custom kernels, such as the `boot` command, are not allowed
    when the bootloader is locked.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 修改设备分区的命令，如各种`flash`变体命令，以及启动自定义内核的命令，如`boot`命令，在启动加载程序被锁定时是不允许的。
- en: '[Example 13-2](ch13.html#example_fastboot_session "Example 13-2. Example fastboot
    session") shows an example `fastboot` session.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-2](ch13.html#example_fastboot_session "示例 13-2. 示例 fastboot 会话") 显示了一个`fastboot`会话的示例。'
- en: Example 13-2. Example `fastboot` session
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-2. 示例 `fastboot` 会话
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the first command ➊ lists the serial numbers of devices connected to the
    host, which are currently in fastboot mode. The commands at ➋ and ➌ obtain the
    bootloader and baseband version strings, respectively. Finally, the command at
    ➍ tries to boot a custom recovery image but fails because the bootloader is currently
    locked.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个命令➊列出了连接到主机的设备的序列号，这些设备当前处于fastboot模式。命令➋和➌分别获取启动加载程序和基带版本字符串。最后，命令➍尝试启动一个自定义恢复镜像，但由于启动加载程序当前被锁定，操作失败。
- en: Recovery
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复
- en: The *recovery OS*—also called *recovery console* or simply, *recovery*—is a
    minimal OS that is used for tasks that cannot be executed directly from Android,
    such as factory reset (erasing the *userdata* partition) or applying OTA updates.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*恢复操作系统*—也称为*恢复控制台*或简单的*恢复*—是一个最小化操作系统，用于执行不能直接从Android执行的任务，如恢复出厂设置（擦除*userdata*分区）或应用OTA更新。'
- en: Like the bootloader’s fastboot mode, the recovery OS can be started either by
    pressing a specific key combination while the device boots, or via ADB by using
    the `adb reboot recovery` command. Some bootloaders also provide a menu interface
    (see [Figure 13-1](ch13.html#nexus_5_bootloader_screen "Figure 13-1. Nexus 5 bootloader
    screen")) that can be used to start the recovery. In the following sections, we
    take a look at the “stock” Android recovery that ships with Nexus devices and
    is included in AOSP, and then introduce custom recoveries, which offer much richer
    functionality but require an unlocked bootloader in order to be installed or booted.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与启动加载程序的fastboot模式类似，恢复操作系统可以通过在设备启动时按下特定的按键组合，或通过使用`adb reboot recovery`命令通过ADB启动。一些启动加载程序还提供一个菜单界面（见[图13-1](ch13.html#nexus_5_bootloader_screen
    "图13-1. Nexus 5 启动加载器界面")），可以用来启动恢复。在接下来的部分，我们将介绍Nexus设备随附的“原生”Android恢复以及包含在AOSP中的恢复系统，然后介绍自定义恢复，这些恢复提供了更丰富的功能，但需要解锁启动加载程序才能安装或启动。
- en: Stock Recovery
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储恢复
- en: Android’s stock recovery implements the minimal functionality needed to satisfy
    the “Updatable Software” section of the *Android Compatibility Definition Document
    (CDD)*, which requires that “device implementations MUST include a mechanism to
    replace the entirety of the system software...” and that “the update mechanism
    used MUST support updates without wiping user data.”^([[139](#ftn.ch13fn03)])
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Android的原生恢复实现了满足*Android兼容性定义文档（CDD）*中“可更新软件”部分所需的最小功能，该部分要求“设备实现必须包括一个机制来替换整个系统软件……”并且“所使用的更新机制必须支持在不擦除用户数据的情况下进行更新。”^([[139](#ftn.ch13fn03)])
- en: That said, the CDD doesn’t specify the concrete update mechanism that should
    be used, so different approaches to system updates are possible and the stock
    recovery implements both OTA updates and tethered updates. For OTA updates, the
    main OS downloads the update file and then instructs the recovery to apply it.
    In the case of tethered updates, users download the update package on their PC
    and push it to the recovery using the `adb sideload` *`otafile.zip`* command.
    The actual update process for both approaches is the same; only the method of
    obtaining the OTA package differs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，CDD（兼容性定义文档）并没有指定应使用哪种具体的更新机制，因此可能有不同的系统更新方法，而默认恢复模式实现了 OTA 更新和连接更新两种方式。对于
    OTA 更新，主操作系统下载更新文件，然后指示恢复模式应用该更新。对于连接更新，用户在 PC 上下载更新包，并使用`adb sideload` *`otafile.zip`*命令将其推送到恢复模式。两种方法的实际更新过程是相同的；只有获取
    OTA 包的方法不同。
- en: The stock recovery has a simple menu interface (shown in [Figure 13-3](ch13.html#stock_recovery_menu
    "Figure 13-3. Stock recovery menu")) that is operated using the device’s hardware
    buttons, usually the Power button and Volume up/down. However, the menu is hidden
    by default and needs to be activated by pressing a dedicated key combination.
    On Nexus devices, the recovery menu can usually be displayed by holding down the
    Power and Volume down buttons simultaneously for a few seconds.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 默认恢复模式具有简单的菜单界面（如[图13-3](ch13.html#stock_recovery_menu "图13-3. 默认恢复菜单")所示），通过设备的硬件按钮操作，通常是电源按钮和音量上下按钮。然而，菜单默认是隐藏的，需要通过按下特定的按键组合来激活。在
    Nexus 设备上，通常通过同时按住电源和音量下按钮几秒钟即可显示恢复菜单。
- en: 'The system recovery menu has four options: *reboot*, *apply update from ADB*,
    *factory reset*, and *wipe cache partition*. The ***apply update from ADB*** option
    starts the ADB server on the device and enables the tethered update (side-load)
    mode. However, as you can see, there is no option for applying an OTA update because
    once the user chooses to apply an OTA update from the main OS (see [Figure 13-4](ch13.html#applying_a_system_update_from_the_main_o
    "Figure 13-4. Applying a system update from the main OS")), it is applied automatically,
    without further user interaction. Android accomplishes this by sending control
    commands to the recovery, which are automatically executed when the recovery starts.
    (We discuss the mechanisms used to control the recovery in the next section.)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 系统恢复菜单有四个选项：*重启*、*通过 ADB 应用更新*、*恢复出厂设置*和*清除缓存分区*。***通过 ADB 应用更新***选项会在设备上启动
    ADB 服务器，并启用连接更新（侧加载）模式。然而，如你所见，并没有应用 OTA 更新的选项，因为一旦用户选择从主操作系统应用 OTA 更新（见[图13-4](ch13.html#applying_a_system_update_from_the_main_o
    "图13-4. 从主操作系统应用系统更新")），系统会自动应用更新，无需进一步的用户操作。Android 通过向恢复模式发送控制命令来实现这一点，这些命令会在恢复模式启动时自动执行。（我们将在下一节讨论用于控制恢复模式的机制。）
- en: '![Stock recovery menu](figs/web/13fig03.png.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![默认恢复菜单](figs/web/13fig03.png.jpg)'
- en: Figure 13-3. Stock recovery menu
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-3. 默认恢复菜单
- en: '![Applying a system update from the main OS](figs/web/13fig04.png.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![从主操作系统应用系统更新](figs/web/13fig04.png.jpg)'
- en: Figure 13-4. Applying a system update from the main OS
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-4. 从主操作系统应用系统更新
- en: Controlling the Recovery
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制恢复模式
- en: The main OS controls the recovery via the `android.os.RecoverySystem` API, which
    communicates with the recovery by writing option strings, each on a new line,
    to the */cache/recovery/command* file. The contents of the *command* file are
    read by the `recovery` binary (located at */sbin/recovery* in the recovery OS),
    which is automatically started from *init.rc* when the recovery boots. The options
    modify the behavior of the `recovery` binary and cause it to wipe the specified
    partition, apply an OTA update, or simply reboot. [Table 13-1](ch13.html#options_for_the_stock_recovery_binary
    "Table 13-1. Options for the Stock recovery Binary") shows the options supported
    by the stock `recovery` binary.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 主操作系统通过`android.os.RecoverySystem` API 控制恢复模式，该 API 通过将每个选项字符串写入*/cache/recovery/command*文件中的新行，与恢复模式通信。*command*文件的内容会被`recovery`二进制文件（位于恢复操作系统的*/sbin/recovery*）读取，该文件会在恢复模式启动时从*init.rc*自动启动。选项会修改`recovery`二进制文件的行为，导致其擦除指定分区、应用
    OTA 更新或仅仅重启。[表13-1](ch13.html#options_for_the_stock_recovery_binary "表13-1. 默认恢复二进制的选项")显示了默认`recovery`二进制文件支持的选项。
- en: Table 13-1. Options for the Stock recovery Binary
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 表13-1. 默认恢复二进制的选项
- en: '| recovery Option | Description |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 恢复选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `--send_intent=<string>` | Save and communicate the specified intent action
    back to the main OS when finished |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `--send_intent=<string>` | 完成后将指定的意图动作保存并传回主操作系统 |'
- en: '| `--update_package=<OTA package path>` | Verify and install the specified
    OTA package |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `--update_package=<OTA包路径>` | 验证并安装指定的OTA包 |'
- en: '| `--wipe_data` | Erase the *userdata* and *cache* partitions, then reboot
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `--wipe_data` | 擦除*用户数据*和*缓存*分区，然后重启 |'
- en: '| `--wipe_cache` | Erase the *cache* partition, then reboot |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `--wipe_cache` | 擦除*缓存*分区，然后重启 |'
- en: '| `--show_text` | Message to display |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `--show_text` | 显示的消息 |'
- en: '| `--just_exit` | Exit and reboot |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `--just_exit` | 退出并重启 |'
- en: '| `--locale` | Locale to use for recovery messages and UI |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `--locale` | 恢复消息和UI使用的语言环境 |'
- en: '| `--stages` | Set the current stage of the recovery process |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `--stages` | 设置恢复过程的当前阶段 |'
- en: In order to ensure that the specified command(s) are always completed, the `recovery`
    binary copies its arguments to the bootloader control block (BCB), which is hosted
    on the *misc* partition (➍ in [Example 13-1](ch13.html#list_of_partitions_on_a_nexus_5
    "Example 13-1. List of partitions on a Nexus 5")). The BCB is used to communicate
    the current state of the recovery process to the bootloader. The format of the
    BCB is specified in the `bootloader_message` structure, shown in [Example 13-3](ch13.html#bcb_format_structure_definition
    "Example 13-3. BCB format structure definition").
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保指定的命令始终完成，`recovery`二进制文件将其参数复制到引导加载程序控制块（BCB），该控制块位于*misc*分区（➍处在[示例 13-1](ch13.html#list_of_partitions_on_a_nexus_5
    "示例 13-1. Nexus 5上的分区列表")中）。BCB用于将恢复过程的当前状态传递给引导加载程序。BCB的格式在`bootloader_message`结构中定义，详见[示例
    13-3](ch13.html#bcb_format_structure_definition "示例 13-3. BCB格式结构定义")。
- en: Example 13-3. BCB format structure definition
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-3. BCB格式结构定义
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If a device is rebooted or powered down in the middle of the recovery process,
    the next time it is started the bootloader inspects the BCB and starts the recovery
    again if the BCB contains the *boot-recovery* command. If the recovery process
    completes successfully, the `recovery` binary clears the BCB before exiting (sets
    all bytes to zero), and on the next reboot the boot-loader starts the main Android
    OS.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备在恢复过程中重启或断电，下次启动时，引导加载程序会检查BCB，如果BCB包含*boot-recovery*命令，则会重新启动恢复过程。如果恢复过程成功完成，`recovery`二进制文件会在退出前清除BCB（将所有字节设置为零），并且在下次重启时，引导加载程序会启动主Android操作系统。
- en: In [Example 13-3](ch13.html#bcb_format_structure_definition "Example 13-3. BCB
    format structure definition"), the command at ➊ is the command to the bootloader
    (usually *boot-recovery*); ➋ is a status file written by the bootloader after
    performing a platform-specific action; ➌ contains the options for the `recovery`
    binary (`--update_package`, `--wipe-data`, and so on); and ➍ is a string describing
    the install stage of OTA packages that require multiple restarts, for example
    *2/3* if the installation requires three reboots. The last field ➎ is reserved
    and not used as of this writing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 13-3](ch13.html#bcb_format_structure_definition "示例 13-3. BCB格式结构定义")中，➊处的命令是发送给引导加载程序的命令（通常是*boot-recovery*）；➋是引导加载程序在执行平台特定操作后写入的状态文件；➌包含`recovery`二进制文件的选项（如`--update_package`、`--wipe-data`等）；➍是描述OTA包安装阶段的字符串，若安装需要多次重启，则例如*2/3*表示安装需要三次重启。最后的字段➎是保留字段，目前未使用。
- en: Sideloading an OTA Package
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装OTA包
- en: Besides being downloaded by the main OS, an OTA package can be directly passed
    to the recovery from a host PC. In order to enable this update mode, the user
    must choose the *apply update from ADB* option from the recovery menu first. This
    starts a trimmed down version of the standard ADB daemon, which supports only
    the `sideload` command. Executing `adb sideload` *`OTA-package-file`* on the host
    transfers the OTA file to */tmp/update.zip* on the device and installs it (see
    “[Applying the Update](ch13.html#applying_the_update "Applying the Update")”).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了由主操作系统下载外，OTA包还可以直接从主机PC传递给恢复模式。为了启用这种更新模式，用户必须首先从恢复菜单中选择*从ADB应用更新*选项。这将启动一个简化版本的标准ADB守护进程，仅支持`adb
    sideload`命令。在主机上执行`adb sideload` *`OTA-package-file`*将OTA文件传输到设备上的*/tmp/update.zip*并进行安装（参见“[应用更新](ch13.html#applying_the_update
    "应用更新")”）。
- en: OTA Signature Verification
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OTA签名验证
- en: As we learned in [Chapter 3](ch03.html "Chapter 3. Package Management"), OTA
    packages are code signed, with the signature applied over the whole file (unlike
    JAR and APK files, which include a separate signature for each file in the archive).
    When the OTA process is started from the main Android OS, the OTA package (ZIP
    file) is first verified using the `verifyPackage()` method of the `RecoverySystem`
    class. This method receives both the path to the OTA package and a ZIP file containing
    a list of X.509 certificates that are allowed to sign OTA updates as parameters.
    If the OTA package is signed with the private key corresponding to any of the
    certificates in the ZIP file, the OTA is considered valid and the system reboots
    into recovery in order to apply it. If no certificate ZIP file is specified, the
    system default, */system/etc/security/otacerts.zip*, is used.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [第 3 章](ch03.html "第 3 章. 包管理") 中所学，OTA 包是经过代码签名的，签名覆盖整个文件（与 JAR 和 APK
    文件不同，后者为归档中的每个文件都包含单独的签名）。当从主 Android 操作系统启动 OTA 过程时，首先使用 `RecoverySystem` 类的
    `verifyPackage()` 方法验证 OTA 包（ZIP 文件）。该方法接收 OTA 包的路径和一个包含允许签署 OTA 更新的 X.509 证书列表的
    ZIP 文件作为参数。如果 OTA 包是使用与 ZIP 文件中任何证书对应的私钥签署的，则该 OTA 被视为有效，并且系统会重启进入恢复模式以应用该更新。如果未指定证书
    ZIP 文件，则使用系统默认值 */system/etc/security/otacerts.zip*。
- en: The recovery verifies the OTA package that it is instructed to apply independently
    of the main OS in order to ensure that the OTA package has not been replaced before
    starting the recovery. The verification is performed with a set of public keys
    built into the recovery image. When building the recovery, these keys are extracted
    from the specified set of OTA signing certificates, converted to mincrypt format
    using the `DumpPublicKey` tool, and written to the */res/keys* file. When RSA
    is used as the signature algorithm, the keys are mincrypt’s `RSAPublicKey` structures,
    serialized as C literals (as they would appear in a C source file), optionally
    preceded by a version identifier that specifies the hash used when signing the
    OTA package and the RSA key public exponent of the key. The *keys* file may look
    like [Example 13-4](ch13.html#contents_of_the_solidusressoliduskeys_fi "Example 13-4. Contents
    of the /res/keys file in the recovery OS").
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复程序验证它将应用的 OTA 包，而无需依赖主操作系统，以确保在启动恢复之前 OTA 包没有被替换。验证通过一组内置在恢复映像中的公钥来执行。在构建恢复时，这些密钥从指定的
    OTA 签名证书集中提取，使用 `DumpPublicKey` 工具转换为 mincrypt 格式，并写入到 */res/keys* 文件中。当使用 RSA
    作为签名算法时，这些密钥是 mincrypt 的 `RSAPublicKey` 结构，序列化为 C 字面量（如同在 C 源文件中出现的形式），可选择性地前面加上版本标识符，该标识符指定在签署
    OTA 包时使用的哈希以及 RSA 密钥的公共指数。*keys* 文件可能如下所示：[示例 13-4](ch13.html#contents_of_the_solidusressoliduskeys_fi
    "示例 13-4. 恢复操作系统中 /res/keys 文件的内容")。
- en: Example 13-4. Contents of the /res/keys file in the recovery OS
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-4. 恢复操作系统中 /res/keys 文件的内容
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the first line ➊ is a serialized version 1 key (implicit if a version
    identifier is not specified), which has a public exponent *e=3* and can be used
    to verify signatures created using SHA-1; the second line ➋ contains a version
    2 key that has a public exponent *e=65537* and is also used with SHA-1 signatures.
    The currently supported signature algorithms are 2048-bit RSA with SHA-1 (key
    versions 1 and 2) or SHA-256 (key versions 3 and 4), and ECDSA with SHA-256 (key
    version 5, available in AOSP’s mater branch) and 256-bit EC keys using the NIST
    P-256 curve.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第一行 ➊ 是一个序列化的版本 1 密钥（如果未指定版本标识符，则隐式使用该版本），该密钥具有公共指数 *e=3*，可以用于验证使用 SHA-1
    创建的签名；第二行 ➋ 包含一个版本 2 密钥，具有公共指数 *e=65537*，也用于 SHA-1 签名。当前支持的签名算法有 2048 位 RSA 配合
    SHA-1（密钥版本 1 和 2）或 SHA-256（密钥版本 3 和 4），以及 ECDSA 配合 SHA-256（密钥版本 5，AOSP 的 master
    分支可用）和使用 NIST P-256 曲线的 256 位 EC 密钥。
- en: Starting the System Update Process
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动系统更新过程
- en: If the signature of the OTA package verifies, the recovery applies the system
    update by executing the update command included in the OTA file. The update command
    is saved in the *META-INF/com/google/android/* directory of the recovery image
    as `update-binary` ➊, as shown in [Example 13-5](ch13.html#contents_of_a_system_update_ota_package
    "Example 13-5. Contents of a system update OTA package").
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 OTA 包的签名验证通过，恢复程序通过执行 OTA 文件中包含的更新命令来应用系统更新。更新命令保存在恢复映像的 *META-INF/com/google/android/*
    目录下，文件名为 `update-binary` ➊，如 [示例 13-5](ch13.html#contents_of_a_system_update_ota_package
    "示例 13-5. 系统更新 OTA 包的内容") 中所示。
- en: Example 13-5. Contents of a system update OTA package
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-5. 系统更新 OTA 包的内容
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The recovery extracts `update-binary` from the OTA file to */tmp/update_binary*
    and starts it, passing it three parameters: the recovery API version (version
    3 as of this writing); the file descriptor of a pipe that `update-binary` uses
    to communicate progress and messages back to the recovery; and the path to the
    OTA package. The *update-binary* process in turn extracts the updater script,
    included as *META-INF/com/google/android/updater-script* ➋ in the OTA package,
    and evaluates it. The updater script is written in a dedicated scripting language
    called *edify* (since version 1.6; previous versions used an older variant called
    *amend*). The edify language supports simple control structures such as `if` and
    `else`, and is extensible via functions, which can also act as control structures
    (by deciding which of their arguments to evaluate). The updater script includes
    a sequence of function calls that trigger the operations necessary to apply the
    update.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复过程从OTA文件中提取`update-binary`到*/tmp/update_binary*并启动它，传递三个参数：恢复API版本（截至本文写作时为版本3）；`update-binary`用于与恢复进程通信的管道文件描述符；以及OTA包的路径。然后，*update-binary*进程提取更新脚本，该脚本作为*META-INF/com/google/android/updater-script*
    ➋包含在OTA包中，并执行它。更新脚本使用一种名为*edify*的专用脚本语言编写（自1.6版本起；以前的版本使用旧的变种，称为*amend*）。edify语言支持简单的控制结构，如`if`和`else`，并且可以通过函数扩展，这些函数也可以充当控制结构（通过决定评估哪些参数）。更新脚本包含一系列函数调用，触发应用更新所需的操作。
- en: Applying the Update
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用更新
- en: The edify implementation defines and registers various functions that are used
    for copying, deleting, and patching files; formatting and mounting volumes; setting
    file permissions and SELinux labels; and more. [Table 13-2](ch13.html#summary_of_important_edify_functions
    "Table 13-2. Summary of Important edify Functions") shows a summary of the most
    often used edify functions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: edify实现定义并注册了用于复制、删除和修补文件；格式化和挂载卷；设置文件权限和SELinux标签等操作的各种函数。[表13-2](ch13.html#summary_of_important_edify_functions
    "表13-2. 重要edify函数摘要")展示了最常用的edify函数的摘要。
- en: Table 13-2. Summary of Important edify Functions
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表13-2. 重要edify函数摘要
- en: '| Function Name | Description |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 函数名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `abort` | Aborts the install process with an error message. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `abort` | 以错误信息中止安装过程。 |'
- en: '| `apply_patch` | Safely applies a binary patch. Ensures that the patched file
    has the expected hash value, before replacing the original. Can also patch disk
    partitions. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `apply_patch` | 安全地应用二进制补丁。在替换原始文件之前，确保补丁文件具有预期的哈希值。也可以修补磁盘分区。 |'
- en: '| `apply_patch_check` | Checks if a file has the specified hash value. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `apply_patch_check` | 检查文件是否具有指定的哈希值。 |'
- en: '| `assert` | Checks if a condition is true. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `assert` | 检查条件是否为真。 |'
- en: '| `delete/delete_recursive` | Deletes a file/all files in a directory. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `delete/delete_recursive` | 删除文件/目录中的所有文件。 |'
- en: '| `file_getprop` | Gets a system property from the specified property file.
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `file_getprop` | 从指定的属性文件中获取系统属性。 |'
- en: '| `format` | Formats a volume with the specified filesystem. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `format` | 使用指定的文件系统格式化一个卷。 |'
- en: '| `getprop` | Gets a system property. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `getprop` | 获取系统属性。 |'
- en: '| `mount` | Mounts a volume at the specified path. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `mount` | 将一个卷挂载到指定路径。 |'
- en: '| `package_extract_dir` | Extracts the specified ZIP directory to a path on
    the filesystem. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `package_extract_dir` | 将指定的ZIP目录提取到文件系统的路径。 |'
- en: '| `package_extract_file` | Extracts the specified ZIP file to a path on the
    filesystem or returns it as a blob. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `package_extract_file` | 将指定的ZIP文件提取到文件系统的路径，或将其作为二进制数据返回。 |'
- en: '| `run_program` | Executes the specified program in a subprocess and waits
    for it to finish. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `run_program` | 在子进程中执行指定程序，并等待其完成。 |'
- en: '| `set_metadata/set_metadata_recursive` | Sets the owner, group, permission
    bits, file capabilities, and SELinux label on file/all files in a directory. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `set_metadata/set_metadata_recursive` | 设置文件/目录中所有文件的所有者、组、权限位、文件功能和SELinux标签。
    |'
- en: '| `show_progress` | Reports back progress to the parent process. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `show_progress` | 向父进程报告进度。 |'
- en: '| `symlink` | Creates a symbolic link(s) to a target, deleting existing symbolic
    link files first. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `symlink` | 创建指向目标的符号链接，首先删除现有的符号链接文件。 |'
- en: '| `ui_print` | Sends a message back to the parent process. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `ui_print` | 向父进程发送一条消息。 |'
- en: '| `umount` | Unmounts a mounted volume. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `umount` | 卸载一个已挂载的卷。 |'
- en: '| `write_raw_image` | Writes a raw image to the specified disk partition. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `write_raw_image` | 将原始镜像写入指定的磁盘分区。 |'
- en: '[Example 13-6](ch13.html#contents_of_updater-script_in_a_full_sys "Example 13-6. Contents
    of updater-script in a full system update OTA package") shows the (abbreviated)
    contents of a typical system update edify script.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-6](ch13.html#contents_of_updater-script_in_a_full_sys "示例 13-6。完整系统更新
    OTA 包中的 updater-script 内容") 展示了一个典型的系统更新 edify 脚本的（简略）内容。'
- en: Example 13-6. Contents of updater-script in a full system update OTA package
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-6。完整系统更新 OTA 包中的 updater-script 内容
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Copying and Patching Files
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制和修补文件
- en: The updater script first mounts the *system* partition, then checks to see if
    the device model and its current build are what it expects ➊. This check is required
    because trying to install a system update over an incompatible build can leave
    a device in an unusable state. (This is often called a “soft brick,” because it
    can usually be recovered by reflashing all partitions with a working build; a
    “hard brick” cannot be recovered.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: updater 脚本首先挂载 *system* 分区，然后检查设备型号及其当前构建是否符合预期 ➊。此检查是必需的，因为试图在不兼容的构建上安装系统更新可能会导致设备无法使用。（这通常被称为“软砖”，因为通常可以通过重新刷写所有分区并使用有效的构建恢复；而“硬砖”是无法恢复的。）
- en: Because an OTA update usually does not contain complete system files, only binary
    patches against the previous version of each changed file (produced using `bsdiff`),^([[140](#ftn.ch13fn04)])
    applying an update can succeed only if each file-to-be-patched is the same as
    the one used to produce the respective patch. To ensure this, the updater script
    checks that the hash value of each file-to-be-patched is one it expects using
    the `apply_patch_check` function ➋.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 OTA 更新通常不包含完整的系统文件，而只是对每个已更改文件的前一版本进行二进制补丁（使用 `bsdiff` 生成），^([[140](#ftn.ch13fn04)])
    所以只有在每个待修补的文件与生成相应补丁时所使用的文件一致的情况下，更新才能成功。为确保这一点，updater 脚本使用 `apply_patch_check`
    函数 ➋ 检查每个待修补文件的哈希值是否符合预期。
- en: In addition to system files, the update process also patches partitions that
    don’t contain a filesystem, such as the *boot* and *modem* partitions. To guarantee
    that patching such partitions will succeed, the updater script checks the contents
    of target partitions as well and aborts if they are not in the expected state
    ➌. When all system files and partitions have been verified, the updater script
    deletes unnecessary files, as well as files that will be replaced completely instead
    of being patched ➍. The script then goes on to patch all system files ➎ and partitions
    ➏. It then removes any previous recovery patches and unpacks the new recovery
    in */system/* ➐.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 除了系统文件外，更新过程还会修补不包含文件系统的分区，如 *boot* 和 *modem* 分区。为了确保修补这些分区能成功，updater 脚本还会检查目标分区的内容，如果它们不处于预期状态则会中止
    ➌。验证完所有系统文件和分区后，updater 脚本会删除不必要的文件，以及那些将完全替换而不是修补的文件 ➍。接着，脚本会修补所有系统文件 ➎ 和分区 ➏。然后，它会删除任何先前的恢复补丁，并将新的恢复环境解包到
    */system/* ➐。
- en: Setting File Ownership, Permissions, and Security Labels
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置文件所有权、权限和安全标签
- en: The next step is to set the user, owner, permissions, and file capabilities
    of all created or patched files and directories using the `set_metadata_recursive`
    function ➑. As of version 4.3, Android supports SELinux (see [Chapter 12](ch12.html
    "Chapter 12. Selinux")), so all files must be properly labeled in order for access
    rules to be effective. That is why the `set_metadata_recursive` function has been
    extended to set the SELinux security label (the last parameter, *u:object_r:system_file:s0*
    in ➑) of files and directories.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用 `set_metadata_recursive` 函数 ➑ 设置所有创建或修补的文件和目录的用户、所有者、权限以及文件能力。从版本 4.3
    开始，Android 支持 SELinux（见 [第 12 章](ch12.html "第 12 章。Selinux")），因此所有文件必须正确标记，以便访问规则生效。这就是为什么
    `set_metadata_recursive` 函数被扩展以设置文件和目录的 SELinux 安全标签（➑ 中的最后一个参数，*u:object_r:system_file:s0*）。
- en: Finishing the Update
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成更新
- en: Next, the updater script patches the device’s baseband software ➒, which is
    typically stored in the *modem* partition. The final step of the script is to
    unmount the system partition➓.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，updater 脚本修补设备的基带软件 ➒，基带软件通常存储在 *modem* 分区。脚本的最后一步是卸载系统分区 ➓。
- en: After the *update-binary* process exits, the recovery wipes the cache partition
    if it was started with the `–wipe_cache` option and copies the execution logs
    to */cache/recovery/* so that they are accessible from the main OS. Finally, if
    no errors are reported, the recovery clears the BCB and reboots into the main
    OS.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在*update-binary*进程退出后，如果使用了`–wipe_cache`选项启动恢复操作系统，恢复会擦除缓存分区，并将执行日志复制到*/cache/recovery/*，以便从主操作系统访问。最后，如果没有报告错误，恢复操作系统会清除BCB并重启到主操作系统。
- en: If the update process is aborted due to an error, the recovery reports this
    to the user, and prompts them to reboot the device in order to try again. Because
    the BCB has not been cleared, the device automatically reboots in recovery mode,
    and the update process is started from scratch.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更新过程由于错误中止，恢复操作系统会向用户报告此错误，并提示用户重启设备以重新尝试。由于BCB未被清除，设备会自动以恢复模式重启，并从头开始更新过程。
- en: Updating the Recovery
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新恢复操作系统
- en: If you examine the entire updater script in [Example 13-6](ch13.html#contents_of_updater-script_in_a_full_sys
    "Example 13-6. Contents of updater-script in a full system update OTA package")
    in detail, you’ll notice that while it patches the *boot* ➏ and *modem* ➒ partitions
    and unpacks a patch for the *recovery* partition ➐ (which hosts the recovery OS),
    it does not apply the unpacked patch. This is by design. Because an update can
    be interrupted at any moment, the update process needs to be restarted from the
    same state the next time the device is powered on. If, for example, power is interrupted
    while writing to the *recovery* partition, updating the recovery OS would change
    that initial state and might leave the system in an unusable condition. Therefore,
    the recovery OS is updated from the main OS only when the main OS update has completed
    and the main OS boots successfully.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你详细查看[示例 13-6](ch13.html#contents_of_updater-script_in_a_full_sys "示例 13-6.
    完整系统更新OTA包中的updater-script内容")中的整个更新脚本，你会注意到，尽管它会修补*boot* ➏和*modem* ➒分区，并为*recovery*分区
    ➐（用于恢复操作系统）解压补丁，但它并不会应用解压后的补丁。这是设计使然。因为更新过程可能随时被中断，因此更新过程需要在设备下次开机时从相同的状态重新开始。例如，如果在写入*recovery*分区时电源中断，更新恢复操作系统会改变初始状态，可能会导致系统处于不可用的状态。因此，恢复操作系统仅在主操作系统更新完成且主操作系统成功启动后才会进行更新。
- en: The update is triggered by the *flash_recovery* service in Android’s *init.rc*
    file, as shown in [Example 13-7](ch13.html#definition_of_the_flashunderscorerecover
    "Example 13-7. Definition of the flash_recovery service in init.rc").
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 更新由Android的*init.rc*文件中的*flash_recovery*服务触发，如[示例 13-7](ch13.html#definition_of_the_flashunderscorerecover
    "示例 13-7. init.rc中flash_recovery服务的定义")所示。
- en: Example 13-7. Definition of the flash_recovery *service in* init.rc
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-7. flash_recovery *服务在* init.rc中的定义
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, this service simply starts the */system/etc/install-recovery.sh*
    shell script ➊. The shell script, along with a patch file for the recovery partition,
    is copied by the OTA updater script (➐ in [Example 13-6](ch13.html#contents_of_updater-script_in_a_full_sys
    "Example 13-6. Contents of updater-script in a full system update OTA package"))
    if the recovery requires an update. The contents of *install-recovery.sh* might
    look like [Example 13-8](ch13.html#contents_of_install-recoverydotsh "Example 13-8. Contents
    of install-recovery.sh").
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个服务仅仅是启动*/system/etc/install-recovery.sh* shell脚本 ➊。如果恢复需要更新，OTA更新脚本会将这个shell脚本及恢复分区的补丁文件（见[示例 13-6](ch13.html#contents_of_updater-script_in_a_full_sys
    "示例 13-6. 完整系统更新OTA包中的updater-script内容")中的➐）复制到设备中。*install-recovery.sh*的内容可能如[示例 13-8](ch13.html#contents_of_install-recoverydotsh
    "示例 13-8. install-recovery.sh的内容")所示。
- en: Example 13-8. Contents of install-recovery.sh
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-8. install-recovery.sh的内容
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The script uses the `applypatch` command to check whether the recovery OS needs
    to be patched by checking the hash value of the *recovery* partition ➊. If the
    hash of the device’s *recovery* partition matches the hash of the version against
    which the patch was created, the script applies the patch ➋. If the recovery has
    already been updated or has an unknown hash, the script logs a message and exits
    ➌.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本使用`applypatch`命令通过检查*recovery*分区的哈希值来判断恢复操作系统是否需要打补丁 ➊。如果设备的*recovery*分区的哈希值与创建补丁时所用版本的哈希值匹配，脚本将应用补丁
    ➋。如果恢复分区已经更新或哈希值未知，脚本将记录一条消息并退出 ➌。
- en: Custom Recoveries
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义恢复
- en: A custom recovery is a recovery OS build created by a third party (not the device
    manufacturer). Because it is created by a third party, a custom recovery is not
    signed with the manufacturer’s keys, and therefore a device’s bootloader needs
    to be unlocked in order to boot or flash it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义恢复是由第三方（而非设备制造商）创建的恢复操作系统版本。由于它是由第三方创建的，因此自定义恢复没有使用制造商的密钥签名，因此设备的引导加载程序需要解锁才能启动或刷入它。
- en: A custom recovery can be booted without installing it on the device with the
    `fastboot boot` *`custom-recovery.img`* command, or it may be permanently flashed
    using the `fastboot flash recovery` *`custom-recovery.img`* command.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义恢复可以通过`fastboot boot` *`custom-recovery.img`* 命令在不安装到设备上的情况下启动，或者可以使用`fastboot
    flash recovery` *`custom-recovery.img`* 命令永久刷入设备。
- en: A custom recovery provides advanced functionality that is typically not available
    in stock recoveries, such as full partition backup and restore, a root shell with
    a full set of device management utilities, support for mounting external USB devices,
    and so on. A custom recovery can also disable OTA package signature checking,
    which allows for installing third-party OS builds or modification, such as framework
    or theme customizations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义恢复提供了通常在官方恢复中不可用的高级功能，如完整分区备份与恢复、具有完整设备管理工具集的根权限 shell、支持挂载外部 USB 设备等。自定义恢复还可以禁用
    OTA 包签名检查，这允许安装第三方操作系统或进行修改，如框架或主题定制。
- en: Various custom recoveries are available, but as of this writing, by far the
    most full-featured and actively maintained is the Team Win Recovery Project (TWRP).^([[141](#ftn.ch13fn05)])
    It is based on the AOSP stock recovery and is also an open source project.^([[142](#ftn.ch13fn06)])
    TWRP has a theme-able, touch screen interface that is very similar to the native
    Android UI. It supports encrypted partition backups, installing system updates
    from USB devices, and backup and restore to/from external devices, and it has
    an integrated file manager. The startup screen of TWRP version 2.7 is shown in
    [Figure 13-5](ch13.html#twrp_recovery_startup_screen "Figure 13-5. TWRP recovery
    startup screen").
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种自定义恢复可供选择，但截至目前，功能最全且维护最积极的是 Team Win Recovery Project (TWRP)。^([[141](#ftn.ch13fn05)])
    它基于 AOSP 官方恢复，且也是一个开源项目。^([[142](#ftn.ch13fn06)]) TWRP 拥有一个可定制的触摸屏界面，非常类似于原生 Android
    UI。它支持加密分区备份、从 USB 设备安装系统更新、从外部设备备份与恢复，并且内置文件管理器。TWRP 版本 2.7 的启动屏幕见于 [图 13-5](ch13.html#twrp_recovery_startup_screen
    "图 13-5. TWRP 恢复启动屏幕")。
- en: '![TWRP recovery startup screen](figs/web/13fig05.png.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![TWRP 恢复启动屏幕](figs/web/13fig05.png.jpg)'
- en: Figure 13-5. TWRP recovery startup screen
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-5. TWRP 恢复启动屏幕
- en: Like the stock AOSP recovery, custom recoveries can be controlled from the main
    OS. In addition to passing parameters via the */cache/recovery/ command* file,
    custom recoveries usually allow some (or all) of their extended features to be
    triggered from the main OS. For example, TWRP supports a minimal scripting language,
    which describes what recovery actions should be executed upon booting the recovery.
    This allows Android apps to queue recovery commands via a convenient GUI interface.
    For example, requesting a compressed backup of the *boot*, *userdata*, and *system*
    partitions generates the script shown in [Example 13-9](ch13.html#twrp_backup_script_example
    "Example 13-9. TWRP backup script example").
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与 AOSP 官方恢复类似，自定义恢复也可以从主操作系统中控制。除了通过 */cache/recovery/ 命令* 文件传递参数外，自定义恢复通常允许从主操作系统触发其某些（或所有）扩展功能。例如，TWRP
    支持一种简洁的脚本语言，用于描述在启动恢复时应执行的恢复操作。这允许 Android 应用通过便捷的 GUI 界面排队执行恢复命令。例如，请求压缩备份 *boot*、*userdata*
    和 *system* 分区时，会生成 [示例 13-9](ch13.html#twrp_backup_script_example "示例 13-9. TWRP
    备份脚本示例") 中所示的脚本。
- en: Example 13-9. TWRP backup script example
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-9. TWRP 备份脚本示例
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Warning
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: '*Permanently flashing a custom recovery that has an option to ignore OTA package
    signatures might allow the system software of your device to be replaced and back-doored
    given brief physical access to the devices. Therefore, it is not recommended to
    flash a custom recovery on a device you use daily and which stores personal or
    sensitive information.*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*永久刷入一个可以忽略 OTA 包签名的自定义恢复可能会导致在设备有短暂物理接触的情况下，设备的系统软件被替换并且被植入后门。因此，不建议在您日常使用的设备上刷入自定义恢复，特别是那些存储个人或敏感信息的设备。*'
- en: Root Access
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根权限访问
- en: Android’s security model applies the principle of least privilege and strives
    to isolate system and app processes from each other by running each process as
    a dedicated user. However, Android is also based on a Linux kernel, which implements
    a standard Unix-style DAC (unless SELinux is enabled; see [Chapter 12](ch12.html
    "Chapter 12. Selinux")).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Android 的安全模型应用了最小权限原则，并通过将每个进程作为一个独立的用户来努力将系统和应用进程彼此隔离。然而，Android 也基于 Linux
    内核，后者实现了标准的 Unix 风格的 DAC（除非启用了 SELinux；请参见 [第12章](ch12.html "第12章。Selinux")）。
- en: One of the greatest shortcomings of this DAC security model is that a certain
    system user, typically called *root* (UID=0), also known as the *superuser*, is
    given absolute power over the system. Root can read, write, and change the permission
    bits of any file or directory; kill any process; mount and unmount volumes; and
    so on. While such unconstrained permissions are necessary for managing a traditional
    Linux system, having superuser access on an Android device allows one to effectively
    bypass Android’s sandbox, and read or write the private files of any application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 DAC 安全模型的最大缺点之一是，某个系统用户，通常称为 *root*（UID=0），也被称为 *超级用户*，被授予对系统的绝对控制权限。Root
    可以读取、写入并更改任何文件或目录的权限位；杀死任何进程；挂载和卸载卷；等等。尽管这种不受限制的权限对于管理传统的 Linux 系统是必要的，但在 Android
    设备上拥有超级用户权限，意味着可以有效绕过 Android 的沙盒，并读取或写入任何应用程序的私密文件。
- en: Root access also allows changing the system configuration by modifying partitions
    that are designed to be read-only, starting or stopping system services at will,
    and removing or disabling core system applications. This can adversely affect
    the stability of a device, or even render it unusable, which is why root access
    is typically not allowed on production devices.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Root 权限还允许通过修改本应为只读的分区、更改系统配置、随意启动或停止系统服务、以及删除或禁用核心系统应用程序。这可能会对设备的稳定性产生不利影响，甚至导致设备无法使用，这也是为什么生产设备通常不允许
    root 权限的原因。
- en: Furthermore, Android tries to limit the number of system processes that execute
    as root, because a programming error in any such process can open the doors to
    privilege escalation attacks, which could result in third-party applications gaining
    root access. With the deployment of SELinux in enforcing mode, processes are limited
    by the global security policy, and therefore compromising a root process does
    not necessarily grant unrestricted access to a device but could still allow access
    to sensitive data or allow modifying system behavior. Additionally, even a process
    constrained by SELinux could exploit a kernel vulnerability in order to circumvent
    the security policy or otherwise obtain unrestricted root access.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Android 尝试限制以 root 权限执行的系统进程数量，因为任何此类进程中的编程错误都可能导致权限提升攻击，进而使第三方应用程序获得 root
    权限。通过在强制模式下部署 SELinux，进程受到全局安全策略的限制，因此，即使破解了 root 进程，也不一定能获得对设备的无限制访问权限，但仍可能访问敏感数据或修改系统行为。此外，即使进程受到
    SELinux 限制，也有可能通过利用内核漏洞绕过安全策略，或以其他方式获得无限制的 root 权限。
- en: With all that said, root access could be very convenient for debugging or reverse
    engineering applications on development devices. Additionally, while allowing
    root access to third-party applications does compromise Android’s security model,
    it also allows various system customizations that are typically not available
    on production devices to be performed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，root 权限对于在开发设备上调试或逆向工程应用程序来说是非常方便的。此外，虽然允许第三方应用程序获得 root 权限会破坏 Android
    的安全模型，但它也允许进行一些通常在生产设备上无法执行的系统定制。
- en: Because one of Android’s biggest selling points has always been its ease of
    customization, the demand for ever greater flexibility via modifying the core
    OS (also called *modding*), has always been high, especially during Android’s
    early years. Besides customizing the system, having root access on an Android
    device allows for the implementation of applications that are not possible without
    modifying the framework and adding system services, such as firewalls, full device
    backup, network sharing, and so on.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Android 的一个最大卖点一直是其易于定制性，用户对通过修改核心操作系统（也称为 *modding*）获得更大灵活性的需求一直很高，尤其是在
    Android 的早期。除了定制系统外，获得 Android 设备的 root 权限还可以实现一些在不修改框架和添加系统服务的情况下无法实现的应用程序，例如防火墙、完整设备备份、网络共享等。
- en: In the following sections, we describe how root access is implemented in development
    (engineering) Android builds and custom Android builds (ROMs), and how it can
    be added to production builds. We then show how apps that require superuser access
    (typically called *root apps*) can request and use root privileges in order to
    execute processes as root.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将描述在开发（工程版）Android构建和自定义Android构建（ROM）中如何实现root访问，以及如何将其添加到生产构建中。然后，我们展示需要超级用户访问（通常称为*root应用*）的应用如何请求并使用root权限，以便作为root用户执行进程。
- en: Root Access on Engineering Builds
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工程版构建中的Root访问
- en: Android’s build system can produce several build variants for a particular device
    that differ by the number of applications and utilities included, as well as by
    the values of several key system properties that modify system behavior. Some
    of these build variants allow root access from the Android shell, as we’ll show
    in the following sections.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Android的构建系统可以为特定设备生成多个构建变体，这些变体在包含的应用程序和工具的数量以及几个修改系统行为的关键系统属性值上有所不同。我们将在接下来的章节中展示，这些构建变体中的一些允许通过Android
    shell获得root访问权限。
- en: Starting ADB as Root
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以Root身份启动ADB
- en: Commercial devices use the *user* build variant (the current build variant is
    set as the value of the *ro.build.type* system property), which doesn’t include
    diagnostics and development tools, disables the ADB daemon by default, disallows
    debugging of applications that don’t explicitly set the `debuggable` attribute
    to `true` in their manifests, and disallows root access via the shell. The *userdebug*
    build variant is very close to *user*, but it also includes some additional modules
    (those with the *debug* module tag), allows debugging of all apps, and enables
    ADB by default.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 商业设备使用*用户*构建变体（当前构建变体的值设置为*ro.build.type*系统属性的值），该变体不包含诊断和开发工具，默认禁用ADB守护进程，禁止调试未在其清单中明确将`debuggable`属性设置为`true`的应用，并且不允许通过shell访问root。*userdebug*构建变体与*用户*变体非常相似，但它还包括一些额外的模块（带有*debug*模块标签的模块），允许调试所有应用，并默认启用ADB。
- en: Engineering, or *eng*, builds include most available modules, allow debugging,
    enable ADB by default, and set the *ro.secure* system property to 0, which changes
    the behavior of the ADB daemon running on a device. When set to 1 (secure mode),
    the *adbd* process, which initially runs as root, drops all capabilities from
    its capability bounding set with the exception of `CAP_SETUID` and `CAP_SETGID`
    (which are required to implement the `run-as` utility). It then adds several supplementary
    GIDs that are required to access network interfaces, external storage, and system
    logs, and finally changes its UID and GID to `AID_SHELL` (UID=2000). On the other
    hand, when *ro.secure* is set to 0 (the default for engineering builds), the *adbd*
    daemon continues to run as root and has the full capability bounding set. [Example 13-10](ch13.html#adbd_process_details_on_a_user_build
    "Example 13-10. adbd process details on a user build") shows the process IDs and
    capabilities for the *adbd* process on a *user* build.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 工程版（或*eng*版）构建包括大多数可用模块，默认允许调试，默认启用ADB，并将*ro.secure*系统属性设置为0，这会改变设备上运行的ADB守护进程的行为。当设置为1（安全模式）时，*adbd*进程最初作为root用户运行，除`CAP_SETUID`和`CAP_SETGID`（这些是实现`run-as`工具所必需的）外，丢弃其能力边界集中的所有权限。然后，它添加了几个附加的GID，用于访问网络接口、外部存储和系统日志，最后将其UID和GID更改为`AID_SHELL`（UID=2000）。另一方面，当*ro.secure*设置为0（工程版构建的默认值）时，*adbd*守护进程继续作为root用户运行，并拥有完整的能力边界集。[示例
    13-10](ch13.html#adbd_process_details_on_a_user_build "示例 13-10：用户构建中的adbd进程细节")展示了*用户*构建中*adbd*进程的进程ID和权限。
- en: Example 13-10. adbd process details on a user build
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-10：用户构建中的adbd进程细节
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the process’s UID ➊ and GID ➋ are both set to 2000 (`AID_SHELL`),
    and the *adbd* process has a number of supplementary GIDs added ➌. Finally, the
    process’s capability bounding set, which determines what capabilities child processes
    are allowed, is set to 0x0000000c0 (`CAP_SETUID|CAP_SETGID`) ➍. This capability
    setting guarantees that, on *user* builds, processes started from Android’s shell
    are limited to the `CAP_SETUID` and `CAP_SETGID` capabilities, even if the executed
    binary has the SUID bit set, or its file capabilities permit additional privileges.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，进程的UID ➊和GID ➋都被设置为2000（`AID_SHELL`），并且*adbd*进程添加了若干附加的GID ➌。最后，进程的能力边界集，决定了子进程可以使用哪些能力，被设置为0x0000000c0（`CAP_SETUID|CAP_SETGID`）
    ➍。此能力设置保证了，在*用户*构建中，从Android shell启动的进程仅限于`CAP_SETUID`和`CAP_SETGID`权限，即使执行的二进制文件设置了SUID位，或其文件权限允许额外的特权。
- en: In contrast, on an *eng* or *userdebug* build, the ADB daemon can execute as
    root, as shown in [Example 13-11](ch13.html#adbd_process_details_on_an_eng_build
    "Example 13-11. adbd process details on an eng build").
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在 *eng* 或 *userdebug* 构建中，ADB 守护进程可以作为 root 执行，如 [示例 13-11](ch13.html#adbd_process_details_on_an_eng_build
    "示例 13-11. 在 eng 版本构建中的 adbd 进程详情") 中所示。
- en: Example 13-11. adbd process details on an eng build
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-11. 在 eng 版本构建中的 adbd 进程详情
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, the *adbd* process runs with UID ➌ and GID ➍ 0 (root), has no supplementary
    groups ➎, and has the full set of Linux capabilities (➏, ➐, and ➑). However, as
    you can see at ➋, the *ro.secure* system property is set to 1, which suggests
    that *adbd* should not be running as root.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*adbd* 进程以 UID ➌ 和 GID ➍ 0（root）身份运行，没有附加的组 ➎，并且拥有完整的 Linux 能力集（➏、➐ 和 ➑）。然而，正如你在
    ➋ 中所看到的，*ro.secure* 系统属性被设置为 1，这表明 *adbd* 不应该以 root 身份运行。
- en: While the ADB daemon does drop its root privileges on *userdebug* builds (as
    in this example, ➊), it can be manually restarted in insecure mode by issuing
    the `adb root` command from a host, as shown in [Example 13-12](ch13.html#restarting_adbd_as_root_on_userdebug_bui
    "Example 13-12. Restarting adbd as root on userdebug builds").
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 *userdebug* 构建中 ADB 守护进程会丢失其 root 权限（如本示例 ➊ 所示），但它可以通过从主机发出 `adb root` 命令以不安全模式手动重启，如
    [示例 13-12](ch13.html#restarting_adbd_as_root_on_userdebug_bui "示例 13-12. 在用户调试版构建中以
    root 身份重启 adbd") 中所示。
- en: Example 13-12. Restarting adbd *as root on* userdebug *builds*
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-12. 在用户调试版构建中以 root 身份重启 adbd
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the *adbd* daemon is initially running as *shell* (UID=2000), and any
    shells started from the host also have UID=2000 and GID=2000 ➊. Issuing the `adb
    root` command ➋ (which internally sets the *service.adb.root* system property
    to 1) restarts the ADB daemon as root ➌, and any subsequently started shells have
    UID and GUID=0 ➍.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*adbd* 守护进程最初以 *shell*（UID=2000）身份运行，任何从主机启动的 shell 也具有 UID=2000 和 GID=2000
    ➊。执行 `adb root` 命令 ➋（该命令内部将 *service.adb.root* 系统属性设置为 1）会将 ADB 守护进程重启为 root ➌，之后启动的任何
    shell 的 UID 和 GID 都为 0 ➍。
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Because this particular device has SELinux enabled, even though the UID and
    GID of the shell change, its security context (security label) stays the same:*
    u:r:shell:s0 *in both* ➊ *and* ➍*. Therefore, even after obtaining a root shell
    via ADB, all processes started from the shell are still bound by the permissions
    granted to the* shell *domain (unless allowed to transition to another domain
    by the MAC policy; see [Chapter 12](ch12.html "Chapter 12. Selinux") for details).
    In practice, as of Android 4.4, the* shell *domain is unconfined, so when running
    as root, processes in this domain are allowed almost full control over the device.*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于此设备启用了 SELinux，即使 shell 的 UID 和 GID 改变，其安全上下文（安全标签）依然保持不变：* u:r:shell:s0
    *在* ➊ *和* ➍ *中都相同*。因此，即使通过 ADB 获取了 root shell，所有从 shell 启动的进程仍然受限于分配给 *shell*
    域的权限（除非通过 MAC 策略允许转换到其他域；有关详细信息，请参见 [第 12 章](ch12.html "第 12 章. Selinux")）。实际上，从
    Android 4.4 开始，*shell* 域是没有限制的，因此当以 root 身份运行时，属于该域的进程几乎可以完全控制设备。'
- en: Using the su Command
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 su 命令
- en: On *userdebug* builds, root access can also be obtained without restarting ADB
    as root. This can be accomplished using the `su` (short for *substitute user*,
    also referred to as *switch user* and *superuser*) command, which is installed
    with the SUID bit set, thus allowing calling processes to obtain a root shell
    or execute a command as the specified UID (including UID=0). The default `su`
    implementation is very basic and only allows the *root* and *shell* users to use
    it, as shown in [Example 13-13](ch13.html#default_su_implementation_for_userdebug
    "Example 13-13. Default su implementation for userdebug builds").
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *userdebug* 构建中，也可以在不将 ADB 以 root 身份重启的情况下获得 root 访问权限。可以通过使用 `su`（即 *substitute
    user* 的简称，也称为 *switch user* 和 *superuser*）命令来实现，该命令以 SUID 位设置安装，从而允许调用进程获取一个 root
    shell 或以指定的 UID（包括 UID=0）执行命令。默认的 `su` 实现非常基础，只允许 *root* 和 *shell* 用户使用，如 [示例
    13-13](ch13.html#default_su_implementation_for_userdebug "示例 13-13. 用户调试版构建中 `su`
    的默认实现") 中所示。
- en: Example 13-13. Default *`su` implementation for* userdebug *builds*
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-13. 用户调试版构建中 *`su` 的默认实现*
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The main function first checks whether the calling UID is `AID_ROOT` (0) or
    `AID_SHELL` (2000) ➊, and exits if called by a user with a different UID. It then
    sets the process UID and GID to 0 (➋ and ➌), and finally starts the Android shell
    ➍. Any commands executed from this shell inherit its privileges by default, thus
    allowing superuser access to the device.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 主要功能首先检查调用的 UID 是否为 `AID_ROOT` (0) 或 `AID_SHELL` (2000) ➊，如果是由其他 UID 的用户调用，则退出。接着，它将进程的
    UID 和 GID 设置为 0 (➋ 和 ➌)，最后启动 Android shell ➍。从这个 shell 执行的任何命令默认继承它的权限，从而允许对设备进行超级用户访问。
- en: Root Access on Production Builds
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产版本中的 Root 权限
- en: As we learned in “[Root Access on Engineering Builds](ch13.html#root_access_on_engineering_builds
    "Root Access on Engineering Builds")”, commercial Android devices are usually
    based on the *user* build variant. This means that the ADB daemon is running as
    the *shell* user, and no `su` command is installed on the device.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在“[工程版本中的 Root 权限](ch13.html#root_access_on_engineering_builds "Root Access
    on Engineering Builds")”中所学到的，商业 Android 设备通常基于 *用户* 构建变种。这意味着 ADB 守护进程以 *shell*
    用户身份运行，并且设备上没有安装 `su` 命令。
- en: This is a secure configuration, and most users should be able to achieve their
    device configuration and customization tasks with the tools provided by the platform,
    or with third-party applications such as custom launchers, keyboards, or VPN clients.
    However, operations that modify the look and feel or core configuration of Android
    are not possible, and neither is low-level access to the underlying Linux OS.
    Such operations can only be performed by running certain commands with root privileges,
    which is why many power users seek to enable root access on their devices.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个安全配置，大多数用户应能够使用平台提供的工具或第三方应用程序（如自定义启动器、键盘或 VPN 客户端）来实现设备配置和定制任务。然而，修改 Android
    的外观、感觉或核心配置是不可行的，底层 Linux 操作系统的低级访问也无法实现。只有通过运行某些具有 root 权限的命令，才能执行这些操作，这就是为什么许多高级用户寻求在设备上启用
    root 权限的原因。
- en: Obtaining root access on an Android device is commonly known as *rooting* and
    can be fairly simple on devices that have an unlockable bootloader or nearly impossible
    on devices that don’t allow bootloader unlocking and take additional measures
    to prevent system partition modifications. In the next sections, we describe the
    typical rooting process and introduce some of the most popular “superuser” apps
    that enable and manage root access.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在安卓设备上获得 root 权限通常被称为 *rooting*，对于那些拥有可解锁 bootloader 的设备来说，这个过程相对简单；而对于那些不允许解锁
    bootloader 并采取额外措施防止修改系统分区的设备，则几乎不可能。在接下来的章节中，我们将描述典型的 root 过程，并介绍一些最受欢迎的“超级用户”应用程序，这些应用程序可以启用和管理
    root 权限。
- en: Rooting by Changing the boot or system Image
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过更改启动或系统镜像进行 Root
- en: On some Android devices, given an unlocked bootloader, a *user* build can easily
    be turned into an engineering or *userdebug* build by simply flashing a new boot
    image (often called a *kernel*, or *custom kernel*), which changes the values
    of the *ro.secure* and *ro.debuggable* system properties. Changing these properties
    allows the ADB daemon to execute as root and enables root access via the Android
    shell, as described in“[Root Access on Engineering Builds](ch13.html#root_access_on_engineering_builds
    "Root Access on Engineering Builds")”. However, most current Android *user* builds
    disable this behavior at compile time (by not defining the `ALLOW_ADBD_ROOT` macro)
    and the values of the *ro.secure* and *ro.debuggable* system properties are ignored
    by the *adbd* daemon.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些 Android 设备上，给定一个解锁的 bootloader，通过简单地刷入新的启动镜像（通常称为 *kernel*，或 *custom kernel*），一个
    *用户* 构建可以轻松转变为工程版或 *userdebug* 构建，从而改变 *ro.secure* 和 *ro.debuggable* 系统属性的值。修改这些属性使得
    ADB 守护进程可以作为 root 执行，并通过 Android shell 启用 root 访问，正如在“[工程版本中的 Root 权限](ch13.html#root_access_on_engineering_builds
    "Root Access on Engineering Builds")”中所描述的那样。然而，大多数当前的 Android *用户* 构建在编译时禁用了这种行为（通过不定义
    `ALLOW_ADBD_ROOT` 宏），并且 *ro.secure* 和 *ro.debuggable* 系统属性的值会被 *adbd* 守护进程忽略。
- en: Another way to enable root access is to unpack the system image, add a SUID
    `su` binary or a similar utility, and overwrite the *system* partition with the
    new system image. This would typically allow root access not only from the shell,
    but from third-party applications as well. However, several security enhancements
    in Android 4.3^([[143](#ftn.ch13fn07)]) and later versions disallow apps from
    executing SUID programs by dropping all capabilities from the bounding set of
    Zygote-spawned processes, and mounting the *system* partition with the `nosetuid`
    flag.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 root 权限的另一种方法是解包系统镜像，添加一个 SUID `su` 二进制文件或类似的工具，并用新的系统镜像覆盖 *system* 分区。这通常不仅允许从
    shell 获取 root 权限，还允许第三方应用程序获取 root 权限。然而，Android 4.3^([[143](#ftn.ch13fn07)])
    及更高版本中的一些安全增强功能禁止应用程序执行 SUID 程序，通过从 Zygote 启动的进程的边界集合中删除所有能力，并将 *system* 分区挂载为
    `nosetuid` 标志。
- en: Additionally, on Android versions that set SELinux to enforcing mode, executing
    a process with root privileges does not typically change its security context,
    and such a process is still limited by the MAC policy. For these reasons, enabling
    root access on a recent Android version may not be as simple as changing a few
    system properties or copying a SUID binary to the device. Of course, replacing
    the *boot* or *system* image allows SELinux to be disabled and any security mitigation
    to be reverted, thus relaxing the device’s security level and enabling root access.
    However, such a radical approach is not unlike replacing the whole OS and may
    prevent the device from receiving system updates from the device manufacturer.
    This is undesirable in most cases, and several root methods that try to coexist
    with the stock OS of the device have been developed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在将 SELinux 设置为强制模式的 Android 版本上，执行具有 root 权限的进程通常不会改变其安全上下文，该进程仍然会受到 MAC
    策略的限制。因此，在最新的 Android 版本上启用 root 权限可能不像改变一些系统属性或将 SUID 二进制文件复制到设备那么简单。当然，替换 *boot*
    或 *system* 镜像可以禁用 SELinux 并恢复任何安全缓解措施，从而放宽设备的安全级别并启用 root 权限。然而，这种激进的方法不亚于替换整个操作系统，并且可能会阻止设备从设备制造商处接收系统更新。在大多数情况下，这是不可取的，因此已经开发了几种尝试与设备的原生操作系统共存的
    root 方法。
- en: Rooting by Flashing an OTA Package
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过闪存 OTA 包进行 Root
- en: An OTA package can add or modify system files, without replacing the whole OS
    image, and is therefore a good candidate for adding root access to a device. Most
    popular superuser apps are distributed as a combination of an OTA package, which
    needs to be installed once, and a companion manager application, which can be
    updated online.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: OTA 包可以添加或修改系统文件，而无需替换整个操作系统镜像，因此是向设备添加 root 权限的良好候选方法。大多数流行的超级用户应用程序以 OTA 包和配套的管理应用程序的组合形式分发，OTA
    包只需安装一次，管理应用程序可以在线更新。
- en: SuperSU
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SuperSU
- en: We’ll use the SuperSU OTA package ^([[144](#ftn.ch13fn08)]) and app ^([[145](#ftn.ch13fn09)])
    (developed by Jorrit “Chainfire” Jongma) to demonstrate how this approach works.
    SuperSU is currently the most popular superuser application and is actively maintained,
    keeping in step with the latest modifications to the Android platform. The SuperSU
    OTA package is similar in structure to a full system update package but contains
    only a small number of files, as shown in [Example 13-14](ch13.html#contents_of_the_supersu_ota_package
    "Example 13-14. Contents of the SuperSU OTA package").
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 SuperSU OTA 包 ^([[144](#ftn.ch13fn08)]) 和应用程序 ^([[145](#ftn.ch13fn09)])（由
    Jorrit “Chainfire” Jongma 开发）来演示这种方法是如何工作的。SuperSU 是目前最流行的超级用户应用程序，并且在积极维护中，与
    Android 平台的最新修改保持同步。SuperSU OTA 包的结构类似于完整的系统更新包，但只包含少量文件，如 [示例 13-14](ch13.html#contents_of_the_supersu_ota_package
    "示例 13-14。SuperSU OTA 包的内容") 所示。
- en: Example 13-14. Contents of the SuperSU OTA package
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-14。SuperSU OTA 包的内容
- en: '[PRE13]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The package contains a few native binaries compiled for the ARM ➊ and x86 ➐
    platforms, scripts for starting and installing the SuperSU daemon (➋ and ➌), the
    APK file of the management GUI application ➍, and two updater scripts (➎ and ➏)
    that apply the OTA package.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 该包包含一些为 ARM ➊ 和 x86 ➐ 平台编译的原生二进制文件，启动和安装 SuperSU 守护进程的脚本（➋ 和 ➌），管理 GUI 应用程序的
    APK 文件 ➍，以及两个更新脚本（➎ 和 ➏），用于应用 OTA 包。
- en: In order to understand how SuperSU enables root access, we need to first examine
    its install process. To do so, let’s analyze the contents of the `update-binary`
    script ➎, shown in [Example 13-15](ch13.html#supersu_ota_install_script "Example 13-15. SuperSU
    OTA install script"). (SuperSU uses a regular shell script instead of a native
    binary, so `updater-script` is simply a placeholder.)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 SuperSU 如何启用 root 权限，我们需要首先检查它的安装过程。为此，让我们分析 `update-binary` 脚本 ➎ 的内容，见
    [示例 13-15](ch13.html#supersu_ota_install_script "示例 13-15. SuperSU OTA 安装脚本")。（SuperSU
    使用常规的 shell 脚本而不是本地二进制文件，因此 `updater-script` 只是一个占位符。）
- en: Example 13-15. SuperSU OTA install script
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-15. SuperSU OTA 安装脚本
- en: '[PRE14]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The update script first mounts the *rootfs* filesystem and the *system* and
    *userdata* partitions in read-write mode ➊, and then it extracts ➋ and copies
    the included files to their intended locations on the filesystem. The `su` and
    `daemonsu` native binaries ➌ are copied to */system/xbin/*, which is the usual
    location of extra native binaries (binaries that are not necessary for running
    the Android OS). The root access management application is copied to */system/app/*
    ➍ and is automatically installed by the package manager when the device reboots.
    Next, the update script copies the *install-recovery.sh* script to */system/etc/*
    ➎.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 更新脚本首先以读写模式挂载 *rootfs* 文件系统以及 *system* 和 *userdata* 分区 ➊，然后它提取 ➋ 并将包含的文件复制到文件系统中的预定位置。`su`
    和 `daemonsu` 本地二进制文件 ➌ 被复制到 */system/xbin/*，这是额外本地二进制文件的常见位置（这些文件对于运行 Android
    操作系统不是必需的）。根访问管理应用被复制到 */system/app/* ➍ 并在设备重启时由包管理器自动安装。接下来，更新脚本将 *install-recovery.sh*
    脚本复制到 */system/etc/* ➎。
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*As discussed in “[Updating the Recovery](ch13.html#updating_the_recovery "Updating
    the Recovery")”, this script is typically used to update the recovery image from
    the main OS, so you might be wondering why the SuperSU install is trying to update
    the recovery of the device. SuperSU uses this script to start some of its components
    at boot time, which we’ll discuss shortly.*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*如在“[更新恢复模式](ch13.html#updating_the_recovery "更新恢复模式")”中讨论的那样，这个脚本通常用于从主操作系统更新恢复镜像，因此你可能会疑惑为什么
    SuperSU 安装脚本会尝试更新设备的恢复镜像。SuperSU 使用这个脚本在启动时启动其某些组件，我们稍后会讨论。*'
- en: The next step of the OTA package install process is to set the permissions ➏
    and SELinux security labels ➐ of the installed binaries (`ch_con` is a shell function
    that calls the `chcon` SELinux utility and sets the *u:object_r:system_file:s0*
    label). Finally, the script calls the `su` command with the `--install` option
    ➑ in order to perform some post-install initialization, and then unmounts */system*
    and */data* ➒. When the script exits successfully, the recovery reboots the device
    into the main Android OS.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: OTA 包安装过程的下一步是设置已安装二进制文件的权限 ➏ 和 SELinux 安全标签 ➐（`ch_con` 是一个调用 `chcon` SELinux
    工具并设置 *u:object_r:system_file:s0* 标签的 shell 函数）。最后，脚本调用 `su` 命令并使用 `--install`
    选项 ➑ 执行一些安装后的初始化，然后卸载 */system* 和 */data* ➒。当脚本成功退出时，恢复模式会重新启动设备并进入主 Android 操作系统。
- en: How SuperSU Is Initialized
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SuperSU 初始化方式
- en: To understand how SuperSU is initialized, let’s look at the contents of the
    *install-recovery.sh* script (see [Example 13-16](ch13.html#contents_of_supersuapostrophes_install-r
    "Example 13-16. Contents of SuperSU’s install-recovery.sh script"), with comments
    omitted), which is automatically executed by `init` on boot.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 SuperSU 是如何初始化的，让我们查看 *install-recovery.sh* 脚本的内容（见 [示例 13-16](ch13.html#contents_of_supersuapostrophes_install-r
    "示例 13-16. SuperSU 的 install-recovery.sh 脚本内容")，省略了注释），该脚本在启动时由 `init` 自动执行。
- en: Example 13-16. Contents of SuperSU’s install-recovery.sh *script*
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-16. SuperSU 的 install-recovery.sh *脚本* 内容
- en: '[PRE15]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The script first executes the `daemonsu` binary ➊, which starts a daemon process
    with root privileges. The next step executes the *install-recovery-2.sh* script
    ➋, which may be used to perform additional initialization, necessary for other
    root apps. Using a daemon in order to allow apps to execute code with root privileges
    is required in Android 4.3 and later, because all apps (which are forked from
    *zygote*) have their capability bounding set zeroed out, thus preventing them
    from executing privileged operations, even if they manage to start a process as
    root. Additionally, as of Android 4.4, SELinux is in enforcing mode, so any processes
    started by an application inherit its security context (typically *untrusted_app*),
    and therefore are subject to the same MAC restrictions as the app itself.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本首先执行`daemonsu`二进制文件➊，它启动一个具有root权限的守护进程。接下来的步骤执行*install-recovery-2.sh*脚本➋，该脚本可能用于执行其他初始化，以便其他root应用程序使用。为了允许应用程序以root权限执行代码，在Android
    4.3及更高版本中，必须使用守护进程，因为所有应用程序（从*zygote*派生）其能力边界被设置为零，这防止它们执行特权操作，即使它们设法以root身份启动进程。此外，从Android
    4.4开始，SELinux处于强制模式，因此任何由应用程序启动的进程都会继承其安全上下文（通常是*untrusted_app*），因此受到与应用程序本身相同的MAC限制。
- en: SuperSU gets around these security restrictions by having apps use the `su`
    binary to execute commands as root, which in turn pipes those commands via a Unix
    domain socket to the *daemonsu* daemon, which ultimately executes the received
    commands as root within the *u:r:init:s0* SELinux context. The processes in play
    are illustrated in [Example 13-17](ch13.html#processes_started_when_an_app_requests_r
    "Example 13-17. Processes started when an app requests root access via SuperSU").
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: SuperSU通过让应用程序使用`su`二进制文件以root身份执行命令来绕过这些安全限制，命令通过Unix域套接字传输给*daemonsu*守护进程，后者最终在*u:r:init:s0*
    SELinux上下文中以root身份执行接收到的命令。相关进程如[示例13-17](ch13.html#processes_started_when_an_app_requests_r
    "示例13-17. 当应用程序通过SuperSU请求root访问时启动的进程")所示。
- en: Example 13-17. Processes started when an app requests root access via SuperSU
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 示例13-17。当应用程序通过SuperSU请求root权限时启动的进程
- en: '[PRE16]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the `com.example.app` app ➏ (whose parent process is *zygote* ➋) requests
    root access by passing a command to the `su` binary using its `-c` option. As
    you can see, the `su` process ➑ executes as the same user (*u0_a292*, UID=10292)
    and in the same SELinux domain (*untrusted_app*) as the requesting app. However,
    the process ➒ of the command the app requested to be executed as root (`sleep`
    in this example) indeed executes as root in the *init* SELinux domain (security
    context *u:r:init:s0*). If we trace its parent PID (PPID, in the fourth column),
    we find that the *sleep* process is started by the *daemonsu:10292* process ➎,
    which is a *daemonsu* instance dedicated to our example app (with UID=10292).
    The *daemonsu:10292* process ➎ inherits its *init* SELinux domain from the *daemonsu:master*
    instance ➍, which is in turn started by the first *daemonsu* instance ➌. This
    is the instance started via the *install-recovery.sh* script (see [Example 13-16](ch13.html#contents_of_supersuapostrophes_install-r
    "Example 13-16. Contents of SuperSU’s install-recovery.sh script")), and it runs
    within the domain of its parent—the *init* process ➊ (PID=1).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`com.example.app`应用程序➏（其父进程是*zygote*➋）通过将命令传递给`su`二进制文件并使用其`-c`选项请求root权限。如你所见，`su`进程➑以与请求应用相同的用户（*u0_a292*，UID=10292）和相同的SELinux域（*untrusted_app*）执行。然而，应用请求以root身份执行的命令的进程➒（在此示例中为`sleep`）确实在*init*
    SELinux域中以root身份执行（安全上下文*u:r:init:s0*）。如果我们追踪其父PID（PPID，在第四列），会发现*sleep*进程是由*daemonsu:10292*进程➎启动的，这是专为我们的示例应用程序（UID=10292）创建的*daemonsu*实例。*daemonsu:10292*进程➎从*daemonsu:master*实例➍继承其*init*
    SELinux域，该实例又由第一个*daemonsu*实例➌启动。这个实例是通过*install-recovery.sh*脚本启动的（参见[示例13-16](ch13.html#contents_of_supersuapostrophes_install-r
    "示例13-16. SuperSU的install-recovery.sh脚本内容")），并且在其父进程*init*（PID=1）的域内运行。
- en: The *eu.chainfire.supersu* process ➐ belongs to the SuperSU management application,
    which shows the root access grant dialog shown in [Figure 13-6](ch13.html#supersu_root_access_request_grant_dialog
    "Figure 13-6. SuperSU root access request grant dialog").
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*eu.chainfire.supersu*进程➐属于SuperSU管理应用程序，该程序显示[图13-6](ch13.html#supersu_root_access_request_grant_dialog
    "图13-6. SuperSU root访问请求授权对话框")中显示的root访问授权对话框。'
- en: '![SuperSU root access request grant dialog](figs/web/13fig06.png.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![SuperSU root访问请求授权对话框](figs/web/13fig06.png.jpg)'
- en: Figure 13-6. SuperSU root access request grant dialog
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-6. SuperSU root访问请求授权对话框
- en: Superuser access can be granted one time only, for a certain period of time,
    or permanently. SuperSU keeps an internal whitelist of apps that have been granted
    root access and does not show the grant dialog if the requesting app is already
    in the whitelist.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 超级用户访问权限可以只授予一次、一定时间内，或永久授予。SuperSU 保留一个内部白名单，列出已获得 root 访问权限的应用程序，如果请求的应用程序已经在白名单中，则不会显示授权对话框。
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*SuperSU has a companion library,* libsuperuser,^([[146](#ftn.ch13fn10)]) *which
    makes it easier to write root apps by providing Java wrappers for the different
    patterns of calling the `su` binary. The author of SuperSU also provides a comprehensive
    guide to writing root apps called* How-To SU.^([[147](#ftn.ch13fn11)])'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*SuperSU 有一个配套库，* libsuperuser,^([[146](#ftn.ch13fn10)]) *它通过提供 Java 封装器来简化编写
    root 应用程序的过程，适配不同的调用 `su` 二进制文件的模式。SuperSU 的作者还提供了一个全面的编写 root 应用程序的指南，名为* How-To
    SU.^([[147](#ftn.ch13fn11)])'
- en: Root Access on Custom ROMs
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义 ROM 上的 root 访问
- en: Custom ROMs that provide root access don’t have to go through *install-recovery.sh*
    in order to start their superuser daemon (equivalent to SuperSU’s *daemonsu*)
    because they can customize the startup process at will. For example, the popular
    CyanogenMod open source Android distribution starts its *su* daemon from *init.superuser.rc*,
    as shown in [Example 13-18](ch13.html#startup_script_for_the_su_daemon_in_cyan
    "Example 13-18. Startup script for the su daemon in CyanogenMod").
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 提供 root 访问权限的自定义 ROM 不需要通过 *install-recovery.sh* 来启动其超级用户守护进程（相当于 SuperSU 的
    *daemonsu*），因为它们可以随意定制启动过程。例如，流行的 CyanogenMod 开源 Android 发行版从 *init.superuser.rc*
    启动其 *su* 守护进程，如[示例 13-18](ch13.html#startup_script_for_the_su_daemon_in_cyan "示例
    13-18. CyanogenMod 中 su 守护进程的启动脚本")所示。
- en: Example 13-18. Startup script for the su *daemon in CyanogenMod*
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-18. CyanogenMod 中 su *守护进程的启动脚本*
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This *init* script defines the *su_daemon* service ➊, which can be started or
    stopped by changing the value of the *persist.sys.root_access* persistent system
    property (➋ through ➎). The value of this property also determines whether root
    access should be granted only to apps, ADB shells, or both. Root access is disabled
    by default and can be configured via CyanogenMod’s Development options, as shown
    in [Figure 13-7](ch13.html#cyanogenmod_root_access_options "Figure 13-7. CyanogenMod
    root access options").
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 *init* 脚本定义了 *su_daemon* 服务 ➊，可以通过更改 *persist.sys.root_access* 持久系统属性的值来启动或停止（➋
    到 ➎）。该属性的值还决定了是否仅授予应用程序、ADB shell 或两者 root 访问权限。默认情况下，root 访问被禁用，可以通过 CyanogenMod
    的开发选项进行配置，如[图 13-7](ch13.html#cyanogenmod_root_access_options "图 13-7. CyanogenMod
    根访问选项")所示。
- en: Warning
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: '*While SuperSU and custom ROMs that allow root access take certain measures
    to regulate what apps are allowed to execute commands as root (usually by adding
    them to a whitelist), an implementation flaw could allow apps to bypass these
    measures and obtain root access without user confirmation. Therefore, root access
    should be disabled on everyday-use devices and used only when necessary for development
    or debugging.*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管 SuperSU 和允许 root 访问的自定义 ROM 采取一定措施来规范哪些应用程序可以作为 root 执行命令（通常通过将它们添加到白名单中），但是实现缺陷可能会允许应用程序绕过这些措施并在没有用户确认的情况下获得
    root 访问权限。因此，root 访问应在日常使用的设备上禁用，仅在开发或调试时需要时使用。*'
- en: '![CyanogenMod root access options](figs/web/13fig07.png.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![CyanogenMod 根访问选项](figs/web/13fig07.png.jpg)'
- en: Figure 13-7. CyanogenMod root access options
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-7. CyanogenMod 根访问选项
- en: Rooting via Exploits
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过漏洞获取 Root 访问
- en: On production devices that don’t have an unlockable bootloader, root access
    can be obtained by exploiting a privilege escalation vulnerability, which allows
    an app or shell process to start a root shell (also called *soft root*) and modify
    the system. The exploits are typically packaged into “one-click” apps or scripts,
    which try to persist root access by installing a `su` binary or modifying system
    configuration. For example, the so-called towelroot exploit (which is distributed
    as an Android app) takes advantage of a vulnerability in the Linux kernel (CVE-2014-3153)
    to obtain root access and installs SuperSU in order to persist it. (Root access
    can also be persisted by overwriting the *recovery* partition with a custom recovery,
    thus allowing the installation of arbitrary software, including superuser applications.
    However, some devices have additional protections that prevent modifications to
    the *boot*, *system*, and *recovery* partitions, so permanent root access might
    not be possible.)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在无法解锁引导程序的生产设备上，可以通过利用特权提升漏洞来获得 root 权限，该漏洞允许应用程序或 shell 进程启动一个 root shell（也称为
    *软 root*），并修改系统。这些漏洞通常打包成“单击式”应用程序或脚本，试图通过安装 `su` 二进制文件或修改系统配置来保持 root 权限。例如，所谓的
    towelroot 漏洞（它以 Android 应用程序的形式分发）利用 Linux 内核中的一个漏洞（CVE-2014-3153）获得 root 权限，并安装
    SuperSU 以保持 root 权限。（Root 权限也可以通过覆盖 *recovery* 分区并安装自定义恢复镜像来持久化，从而允许安装任意软件，包括超级用户应用程序。然而，一些设备有额外的保护机制，防止修改
    *boot*、*system* 和 *recovery* 分区，因此永久获得 root 权限可能不可行。）
- en: Note
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*See [Chapter 3](ch03.html "Chapter 3. Package Management") of the* Android
    Hacker’s Handbook *(Wiley, 2014) for a detailed description of the major privilege-escalation
    vulnerabilities that have been used to obtain root access in various Android versions.
    [Chapter 12](ch12.html "Chapter 12. Selinux") of the same book introduces the
    main exploit-mitigation techniques that have been implemented in Android in order
    to prevent privilege-escalation attacks and generally harden the system.*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*详见《Android 黑客手册》 (Wiley, 2014) 的[第 3 章](ch03.html "第 3 章. 包管理")，该章详细描述了用于在不同
    Android 版本中获取 root 权限的主要特权提升漏洞。[第 12 章](ch12.html "第 12 章. Selinux")介绍了 Android
    中为防止特权提升攻击而实施的主要漏洞缓解技术，并总体上增强了系统的安全性。*'
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In order to allow for updating the system software or returning a device to
    its factory state, Android devices allow unrestricted, low-level access to their
    storage via the bootloader. The bootloader typically implements a management protocol,
    usually fastboot, that allows for transferring and flashing partition images from
    a host machine. Bootloaders on production devices are usually locked and allow
    flashing only of signed images. However, most bootloaders can be unlocked, thus
    allowing flashing images from third parties.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够更新系统软件或将设备恢复到出厂状态，Android 设备通过引导程序（bootloader）允许对其存储进行不受限制的低级访问。引导程序通常实现一个管理协议，通常是
    fastboot，允许从主机传输和刷写分区映像。生产设备上的引导程序通常是锁定的，只允许刷写签名的映像。然而，大多数引导程序可以解锁，从而允许刷写第三方的映像。
- en: Android uses a dedicated partition to store a second, minimal OS, called a recovery,
    which is used to apply OTA update packages or clear all data on the device. Like
    bootloaders, recoveries on production devices typically allow applying only those
    OTA packages signed by the device manufacturer. If the bootloader is unlocked,
    a custom recovery, which allows installing updates signed by third parties or
    completely forgoes signature verification, can be booted or permanently installed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Android 使用一个专用分区来存储第二个最小化的操作系统，称为恢复模式（recovery），用于应用 OTA 更新包或清除设备上的所有数据。与引导程序类似，生产设备上的恢复模式通常只允许应用设备制造商签名的
    OTA 更新包。如果引导程序已解锁，则可以启动或永久安装自定义恢复模式，这种模式允许安装由第三方签名的更新，或完全放弃签名验证。
- en: Engineering or debug builds of Android allow root access via the Android shell,
    but root access is typically disabled on production devices. Root access on such
    devices can be enabled by installing a third-party OTA package that includes a
    “superuser” daemon and a companion application that allow controlled root access
    to applications. Third-party Android builds (ROMs) typically allow root access
    out of the box, although it can also be disabled via the system settings interface.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Android的工程或调试版允许通过Android shell获取root权限，但生产设备上通常会禁用root权限。在这些设备上，可以通过安装包含“superuser”守护进程和配套应用程序的第三方OTA包来启用root权限，从而控制对应用程序的root访问。第三方Android构建（ROM）通常开箱即用允许root权限，尽管也可以通过系统设置界面禁用。
- en: '* * *'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[137](#ch13fn01)]) Code Aurora Forum, “(L)ittle (K)ernel based Android bootloader,”
    *[https://www.codeaurora.org/blogs/little-kernel-based-android-bootloader/](https://www.codeaurora.org/blogs/little-kernel-based-android-bootloader/)*
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[137](#ch13fn01)]) Code Aurora Forum, “基于(L)ittle (K)ernel的Android引导加载程序，”
    *[https://www.codeaurora.org/blogs/little-kernel-based-android-bootloader/](https://www.codeaurora.org/blogs/little-kernel-based-android-bootloader/)*
- en: ^([[138](#ch13fn02)]) Code Aurora Forum, *[https://www.codeaurora.org/cgit/quic/la/kernel/lk/](https://www.codeaurora.org/cgit/quic/la/kernel/lk/)*
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[138](#ch13fn02)]) Code Aurora Forum, *[https://www.codeaurora.org/cgit/quic/la/kernel/lk/](https://www.codeaurora.org/cgit/quic/la/kernel/lk/)*
- en: ^([[139](#ch13fn03)]) Google, *Android Compatibility Definition*, *[https://static.googleusercontent.com/media/source.android.com/en//compatibility/android-cdd.pdf](https://static.googleusercontent.com/media/source.android.com/en//compatibility/android-cdd.pdf)*
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[139](#ch13fn03)]) Google, *Android兼容性定义*，* [https://static.googleusercontent.com/media/source.android.com/en//compatibility/android-cdd.pdf](https://static.googleusercontent.com/media/source.android.com/en//compatibility/android-cdd.pdf)*
- en: ^([[140](#ch13fn04)]) Colin Percival, “Binary diff/patch utility,” *[http://www.daemonology.net/bsdiff/](http://www.daemonology.net/bsdiff/)*
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[140](#ch13fn04)]) Colin Percival, “二进制差异/补丁工具，” *[http://www.daemonology.net/bsdiff/](http://www.daemonology.net/bsdiff/)*
- en: ^([[141](#ch13fn05)]) TeamWin, “TWRP 2.7,” *[http://teamw.in/project/twrp2/](http://teamw.in/project/twrp2/)*
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[141](#ch13fn05)]) TeamWin, “TWRP 2.7,” *[http://teamw.in/project/twrp2/](http://teamw.in/project/twrp2/)*
- en: ^([[142](#ch13fn06)]) TeamWin, “Team Win Recovery Project (TWRP),” *[https://github.com/TeamWin/Team-Win-Recovery-Project/](https://github.com/TeamWin/Team-Win-Recovery-Project/)*
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[142](#ch13fn06)]) TeamWin, “Team Win Recovery Project (TWRP),” *[https://github.com/TeamWin/Team-Win-Recovery-Project/](https://github.com/TeamWin/Team-Win-Recovery-Project/)*
- en: ^([[143](#ch13fn07)]) Google, “Security Enhancements in Android 4.3,” *[http://source.android.com/devices/tech/security/enhancements43.html](http://source.android.com/devices/tech/security/enhancements43.html)*
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[143](#ch13fn07)]) Google, “Android 4.3中的安全增强功能，” *[http://source.android.com/devices/tech/security/enhancements43.html](http://source.android.com/devices/tech/security/enhancements43.html)*
- en: ^([[144](#ch13fn08)]) Jorrit “Chainfire” Jongma, “CF-Root download page,” *[http://download.chainfire.eu/supersu/](http://download.chainfire.eu/supersu/)*
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[144](#ch13fn08)]) Jorrit “Chainfire” Jongma, “CF-Root下载页面，” *[http://download.chainfire.eu/supersu/](http://download.chainfire.eu/supersu/)*
- en: '^([[145](#ch13fn09)]) Jorrit “Chainfire” Jongma, “Google Play Apps: SuperSU,”
    *[https://play.google.com/store/apps/details?id=eu.chainfire.supersu&hl=en](https://play.google.com/store/apps/details?id=eu.chainfire.supersu&hl=en)*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[145](#ch13fn09)]) Jorrit “Chainfire” Jongma, “Google Play应用：SuperSU，” *[https://play.google.com/store/apps/details?id=eu.chainfire.supersu&hl=en](https://play.google.com/store/apps/details?id=eu.chainfire.supersu&hl=en)*
- en: ^([[146](#ch13fn10)]) Jorrit “Chainfire” Jongma, libsuperuser, *[https://github.com/Chainfire/libsuperuser/](https://github.com/Chainfire/libsuperuser/)*
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[146](#ch13fn10)]) Jorrit “Chainfire” Jongma, libsuperuser， *[https://github.com/Chainfire/libsuperuser/](https://github.com/Chainfire/libsuperuser/)*
- en: ^([[147](#ch13fn11)]) Jorrit “Chainfire” Jongma, “How-To SU Guidelines for problem-free
    su usage,” *[http://su.chainfire.eu/](http://su.chainfire.eu/)*
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[147](#ch13fn11)]) Jorrit “Chainfire” Jongma, “无问题的su使用指南，” *[http://su.chainfire.eu/](http://su.chainfire.eu/)*
