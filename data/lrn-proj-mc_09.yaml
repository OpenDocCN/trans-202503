- en: '**9**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9**'
- en: '**HITTING THINGS WITH LISTS AND DICTIONARIES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用列表和字典处理事物**'
- en: '![image](graphics/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common01.jpg)'
- en: 'We use lists, such as shopping lists or lists of instructions, to remember
    a group of items or to work through steps in a certain order. Lists in Python
    are very similar: they’re used to store a collection of data within a sequence.
    A *list* can store several types of data, including strings, numbers, Booleans,
    and even other lists.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用列表，例如购物清单或指令清单，来记住一组项目或按特定顺序执行步骤。在 Python 中，列表非常相似：它们用于在序列中存储数据集合。一个*列表*可以存储多种类型的数据，包括字符串、数字、布尔值，甚至其他列表。
- en: Normally, variables can hold only one value. Lists are useful because they allow
    you to store several values in a single variable, such as the numbers from 1 to
    100 or your friends’ first names. In other programming languages, lists are sometimes
    called *arrays*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，变量只能保存一个值。列表非常有用，因为它们允许你在一个变量中存储多个值，例如从 1 到 100 的数字，或者你朋友的名字。在其他编程语言中，列表有时被称为*数组*。
- en: You can use lists of block IDs, coordinates, or a variety of other things to
    gain lots of power over your Minecraft world. Because lists can store several
    kinds of values in a single variable, they give you flexibility that a regular
    variable can’t offer.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用块 ID、坐标或其他多种内容的列表，以便更好地控制你的 Minecraft 世界。因为列表可以在一个变量中存储多种类型的值，它们为你提供了常规变量无法提供的灵活性。
- en: In this chapter, you’ll learn how to use lists with the Minecraft Python API
    to create a mini-game for recording height, make a progress bar, and write a program
    that randomly slides the player around the game.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用 Minecraft Python API 和列表来创建一个迷你游戏，用于记录高度，制作进度条，并编写一个程序，让玩家在游戏中随机滑动。
- en: '**USING LISTS**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用列表**'
- en: Making a list with Python is straightforward. To define a list, use square brackets
    around any number of values—or no values at all, which is called an *empty* list.
    Each item in a list needs to be separated by a comma.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 创建列表非常简单。定义一个列表时，可以将任意数量的值放在方括号内——或者根本不放任何值，这就是所谓的*空*列表。列表中的每个项都需要用逗号分隔。
- en: 'For example, a list of ingredients for noodle soup might look like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一份面条汤的配料列表可能看起来像这样：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `noodleSoup` list contains several items and all of them are strings.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`noodleSoup` 列表包含多个项，它们都是字符串。'
- en: 'You can create an empty list like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样创建一个空列表：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Use an empty list when you want to add values later in your program.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你希望稍后在程序中添加值时，可以使用空列表。
- en: 'You can store any data type in your list and even mix different data types.
    For example, you could have a list that contains integers and strings:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在列表中存储任何数据类型，甚至可以混合不同的数据类型。例如，你可以有一个包含整数和字符串的列表：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Sometimes your lists will be very long, making them difficult for humans to
    read. But you can format long lists across several lines in Python so programmers
    can read them easily. Using several lines for items has no effect on how the Python
    code runs. For example, the following format for soup ingredients works the same
    as the earlier `noodleSoup` list:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你的列表可能非常长，使得人类难以阅读。但是你可以在 Python 中将长列表跨多行格式化，这样程序员可以更容易地阅读它们。将项分成多行不会影响 Python
    代码的运行。例如，以下的汤配料格式与之前的 `noodleSoup` 列表一样：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we’ll look at how you can access and change items in a list.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何访问和修改列表中的项。
- en: '**ACCESSING A LIST ITEM**'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问列表项**'
- en: 'To access a value in a list, reference the item’s position in the list, which
    is known as its *index*. Using the noodle soup example, you can access the first
    item in the list like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问列表中的值，需要引用项在列表中的位置，这个位置被称为*索引*。以面条汤为例，你可以像这样访问列表中的第一个项：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It’s important to note that the first index in a list is 0\. The second item
    is index 1, the third is index 2, and so on. The reason for this is that computers
    count from zero when using lists.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，列表中的第一个索引是 0。第二项是索引 1，第三项是索引 2，依此类推。之所以如此，是因为计算机在使用列表时是从零开始计数的。
- en: Counting from zero might seem silly, but there’s a good reason for it. Early
    computers were very slow and had a very little memory. It was faster and more
    efficient to start counting indexes from zero. Even though computers are much
    faster these days, they still count from zero.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从零开始计数可能看起来很傻，但其实有充分的理由。早期的计算机非常慢，内存也非常有限。从零开始计数更快，也更高效。即使现在的计算机已经非常快，它们仍然从零开始计数。
- en: 'It’s also important to note that if you try to access a list index that is
    greater than the number of items in the list, you’ll get an error message. The
    following line tries to print the item in index position 5:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，如果你尝试访问一个列表索引，它大于列表中的项数，你会得到一个错误信息。以下这行代码尝试打印索引位置 5 中的项：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here’s part of the error message:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是部分错误信息：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `IndexError` tells me that there is no data in the index I want to access.
    Index position 5 in the list has no data because it’s outside the length of the
    list. Python can’t return a value that doesn’t exist!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`IndexError` 提示我，我想访问的索引位置没有数据。列表中的索引位置 5 没有数据，因为它超出了列表的长度。Python 无法返回一个不存在的值！'
- en: '**CHANGING A LIST ITEM**'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**更改列表项**'
- en: Just like you can change the value of variables, you can change individual items
    in lists as well. This is because lists are *mutable*, which means they can be
    changed. To change an item in a list, you use the item’s index position and set
    its value the same way you would set the value of a variable (by using an equal
    sign).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以更改变量的值一样，你也可以更改列表中的单个项。这是因为列表是*可变的*，意味着它们是可以修改的。要更改列表中的一项，你可以使用该项的索引位置，并像设置变量的值一样设置它的值（通过等号）。
- en: 'Let’s change the beef item in the noodle soup to chicken. Beef is the fifth
    item in the list, so it has an index of 4 (remember, you count from zero in lists).
    We can easily change item 4 to chicken, like so:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把面条汤中的牛肉项改成鸡肉。牛肉是列表中的第五个项，所以它的索引是 4（记住，列表是从零开始计数的）。我们可以轻松地将索引 4 的项改为鸡肉，像这样：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now let’s do something cool with lists in Minecraft.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在 Minecraft 中做一些有趣的事情，利用列表。
- en: '**MISSION #47: HIGH AND LOW**'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #47：高与低**'
- en: When I’m exploring the Minecraft world, it’s interesting to look back over my
    journey. From the highest mountains to the lowest caves, exploration is one of
    my favorite activities in the game. Sometimes when I’m playing with friends, we
    race each other to see who can get to the highest or lowest point in the game
    the fastest. So no one cheats, I wrote a program that stores the lowest and highest
    y-coordinates the player reaches within 60 seconds.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在探索 Minecraft 世界时，回顾我的旅程是件很有趣的事。从最高的山峰到最深的洞穴，探索是我在游戏中最喜欢的活动之一。有时候和朋友们一起玩时，我们会比赛，看看谁能最快到达游戏中的最高或最低点。为了防止作弊，我写了一个程序，记录玩家在
    60 秒内到达的最低和最高 y 坐标。
- en: When I run the program, it tells me the highest and lowest places in the game
    that I traveled to during one minute. [Listing 9-1](ch09.html#ch9ex1) contains
    the code I’ve started for you. Copy it into a new file and save it as *highAndLow.py*
    in a new folder called *lists*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行程序时，它会告诉我我在游戏中旅行的一分钟内到达的最高和最低位置。[清单 9-1](ch09.html#ch9ex1) 包含了我为你开始编写的代码。将其复制到一个新文件中，并将其保存为
    *highAndLow.py*，放在一个名为 *lists* 的新文件夹中。
- en: '*highAndLow.py*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*highAndLow.py*'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 9-1: The start of the code to get the lowest and highest positions
    the player visits*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-1：获取玩家访问的最低和最高位置的代码开始部分*'
- en: The program will store the lowest and highest y-coordinates you’ve traveled
    to in a list called `heights` ➊. The first item in the list (index position 0)
    stores the lowest coordinate and the second (index position 1) stores the highest.
    We need to start with a high “lowest” value and a low “highest” value so that
    the first time we run the program, the player’s position will be the new lowest
    or highest value and will be displayed in the chat. Here I’ve used a default lowest
    value of 100 and a default highest value of 0.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会将你所到达的最低和最高 y 坐标保存在一个名为 `heights` 的列表中 ➊。列表中的第一个项（索引位置 0）存储最低坐标，第二个项（索引位置
    1）存储最高坐标。我们需要从一个较高的“最低”值和较低的“最高”值开始，这样第一次运行程序时，玩家的位置将成为新的最低或最高值，并会显示在聊天窗口中。这里我使用了默认的最低值
    100 和默认的最高值 0。
- en: The `while` loop runs once per second for 60 seconds to constantly update the
    values in `heights`. The `if` statement checks whether the player’s current height
    is lower than the lowest value stored in the list ➋. Then the `elif` statement
    checks whether the current height is greater than the highest position stored
    in the list ➌.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环每秒运行一次，持续 60 秒，以不断更新 `heights` 中的值。`if` 语句检查玩家当前的高度是否低于列表中存储的最低值
    ➋。然后，`elif` 语句检查当前高度是否大于列表中存储的最高位置 ➌。'
- en: 'To complete the code, you need to set the value of the lowest height, `height[0]`,
    to the value of `pos.y` at ➋. Remember that you set the values in lists like you
    would a variable, so the line of code should look like this: `height[0] = pos.y`.
    You also need to set the highest height, `height[1]`, to the value of `pos.y`
    ➌.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成代码，你需要将最低高度`height[0]`的值设置为➋处`pos.y`的值。记住，你可以像设置变量一样设置列表中的值，因此代码行应该如下所示：`height[0]
    = pos.y`。你还需要将最高高度`height[1]`的值设置为➌处`pos.y`的值。
- en: Finally, you need to output the value of the lowest ➍ and highest ➎ heights
    in the last two lines of the program. To do this, you’ll need to access the index
    positions for the lowest and highest heights from the `heights` list (again, index
    0 is the lowest height and index 1 is the highest height).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要在程序的最后两行输出最低➍和最高➎高度的值。为此，你需要从`heights`列表中访问最低和最高高度的索引位置（再次说明，索引0是最低高度，索引1是最高高度）。
- en: Run the program and start running around the game. See how high and how low
    you can get. After 60 seconds, the loop will stop, and the program will display
    your highest and lowest heights. Run the program several times and see if you
    can beat your record!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序并开始在游戏中跑动。看看你能跑得多高或多低。60秒后，循环将停止，程序会显示你的最高和最低高度。多次运行程序，看看你能否打破自己的记录！
- en: '[Figure 9-1](ch09.html#ch9fig1) shows one of my attempts.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-1](ch09.html#ch9fig1)展示了我尝试的一种方法。'
- en: '![image](graphics/f09-01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f09-01.jpg)'
- en: '*Figure 9-1: The lowest y-coordinate I visited was 15 and the highest was 102.*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：我访问过的最低y坐标是15，最高是102。*'
- en: '**BONUS OBJECTIVE: AN UNEXPECTED BUG**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**额外目标：一个意外的bug**'
- en: In *highAndLow.py*, the default values for the lowest and highest positions
    are set to 100 and 0\. This isn’t a problem as long as you go lower than 100 and
    higher than 0\. However, if you don’t go lower than 100 and higher than 0, the
    value won’t change, which can make the program inaccurate. Can you work out how
    to fix this?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在*highAndLow.py*中，最低和最高位置的默认值分别设置为100和0。这没问题，只要你走得比100低、比0高。但是，如果你没有走得比100低、比0高，值就不会改变，这会导致程序不准确。你能解决这个问题吗？
- en: '**MANIPULATING LISTS**'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**操作列表**'
- en: Lists have a set of built-in functions that let you manipulate them. These functions
    include common operations like adding an item to a list, inserting an item, or
    deleting an item.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表有一组内置函数，可以让你操作它们。这些函数包括常见操作，如向列表添加项目、插入项目或删除项目。
- en: '**ADDING AN ITEM**'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**添加项目**'
- en: 'You can add an item to the end of a list using the `append()` function: just
    include the value of the item you want to append as an argument.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`append()`函数向列表末尾添加项目：只需将你想添加的项目的值作为参数传递进去。
- en: 'The noodle soup would be better if we added some vegetables. To do this, use
    the `append()` function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们往面条汤里加点蔬菜，味道会更好。为此，使用`append()`函数：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now the `noodleSoup` list contains a `"vegetables"` string as the last item
    in the list.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`noodleSoup`列表的最后一项是一个`"vegetables"`字符串。
- en: 'Appending items is very useful when you start with an empty list. By using
    the `append()` function, you can add the first item to an empty list:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 向列表中添加项目在你从一个空列表开始时非常有用。通过使用`append()`函数，你可以将第一个项目添加到空列表中：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**INSERTING AN ITEM**'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**插入项目**'
- en: It’s also possible to insert an item into the middle of a list. The `insert()`
    function places an item between two existing items and changes the index positions
    for all the items after the newly inserted item.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将项目插入到列表的中间。`insert()`函数将项目放在两个现有项目之间，并改变所有插入项后面项目的索引位置。
- en: This function takes two arguments, the index position where you want to insert
    the item and the value that you want to insert.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有两个参数，一个是你想插入项目的索引位置，另一个是你想插入的值。
- en: 'For example, here’s our current `noodleSoup` list:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是我们当前的`noodleSoup`列表：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s add `"pepper"` to the list in the third index position:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把`"pepper"`添加到列表的第三个索引位置：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The updated list holds the following values after the insert:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 插入后，更新的列表包含以下值：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you try to insert an item at an index position that is greater than the length
    of the list, the item will be added after the last item. For example, if your
    list has seven items, but you try to insert at item position 10, the item will
    just be added to the end of the list.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在一个比列表长度更大的索引位置插入项目，项目将被添加到最后一个项目之后。例如，如果你的列表有七个项目，但你尝试插入第10个项目，项目将直接添加到列表的末尾。
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After running this code, the last item in the list will be `"salt"`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码后，列表中的最后一个项目将是`"salt"`：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that salt isn’t in index position 10; instead it is in index position
    7.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，盐并不在索引位置10，而是在索引位置7。
- en: '**DELETING AN ITEM**'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**删除一个项目**'
- en: Sometimes you’ll want to get rid of an item in a list. You use the `del` keyword
    for this. The keyword goes before the name of the list, with the index position
    of the item you want to delete in the square brackets.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能需要从列表中移除一个项目。你可以使用`del`关键字来做到这一点。该关键字放在列表名称之前，后面跟上你想删除的项目的索引位置，位置用方括号表示。
- en: 'For example, to delete the `"beef"` item, which is now in index position 5
    in the `noodleSoup` list, do this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要删除`noodleSoup`列表中现在位于索引位置5的“beef”项，可以这样做：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can also use the `del` keyword in combination with the `index()` function
    if you want to find the index position of a value and then delete it:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查找一个值的索引位置并将其删除，你也可以将`del`关键字与`index()`函数结合使用：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After deleting an item, the index positions in a list will change. This is
    what the list will look like after we delete `"beef"` at index position 5:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一个项目后，列表中的索引位置将会发生变化。这是我们删除位于索引位置5的“beef”后列表的样子：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `"vegetables"` index position changes from 6 to 5, and the `"salt"` index
    position changes from 7 to 6\. Note that only indexes after the deleted item will
    be affected; any indexes before the deleted item will be unchanged. Keep this
    in mind when deleting items from your lists.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`"vegetables"`的索引位置从6变为5，而`"salt"`的索引位置从7变为6。注意，只有在删除项之后的索引会受到影响；删除项之前的索引不会改变。删除列表中的项时，请记住这一点。'
- en: '**MISSION #48: PROGRESS BAR**'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #48：进度条**'
- en: Let’s use some of the list functions to create a progress bar in Minecraft.
    It will look like the one you see onscreen when you’re downloading a file from
    the Internet or when you’re keeping track of your next level up in a role-playing
    game.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一些列表函数来在Minecraft中创建一个进度条。它看起来像你在下载文件时看到的进度条，或者在角色扮演游戏中追踪你的下一级进度条。
- en: The program will use the progress bar to count to 10 seconds. When the program
    starts, the progress bar will be made of glass blocks. For every second that passes,
    the progress bar will replace a glass block with a lapis lazuli block. [Figure
    9-2](ch09.html#ch9fig2) shows the first five steps in the progress bar.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将使用进度条计时到10秒。当程序开始时，进度条将由玻璃块组成。每经过一秒，进度条将用青金石块替换一个玻璃块。[图 9-2](ch09.html#ch9fig2)显示了进度条的前五个步骤。
- en: '![image](graphics/f09-02.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f09-02.jpg)'
- en: '*Figure 9-2: The progress bar shows the progress at 50 percent (5 out of 10
    blocks are lapis lazuli).*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-2：进度条显示50%的进度（10个块中有5个是青金石）。*'
- en: Open IDLE and create a new file. Save it as *progressBar.py* in the *lists*
    folder. An incomplete version of the program is in [Listing 9-2](ch09.html#ch9ex2).
    Copy it into your text editor.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 打开IDLE并创建一个新文件。将其保存为*progressBar.py*，并放在*lists*文件夹中。[清单 9-2](ch09.html#ch9ex2)中的程序是未完成的。将其复制到你的文本编辑器中。
- en: '*progressBar.py*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*progressBar.py*'
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 9-2: Incomplete code to make a progress bar*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-2：制作进度条的未完成代码*'
- en: 'To complete the program in [Listing 9-2](ch09.html#ch9ex2), you’ll need to
    do the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成[清单 9-2](ch09.html#ch9ex2)中的程序，你需要执行以下操作：
- en: Add 10 glass blocks (ID 20) to the empty `blocks` list at ➊.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在➊位置将10个玻璃块（ID 20）添加到空的`blocks`列表中。
- en: Use the `setBlock()` function to set all 10 blocks ➋ from the list in the game
    world. The first three blocks have been set for you.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`setBlock()`函数将列表中的所有10个块➋设置到游戏世界中。前3个块已经为你设置好了。
- en: Write a statement that deletes the last block in the list (index position 9)
    ➌. Remember that you use the `del` keyword to delete an item from a list.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个语句删除列表中的最后一个块（索引位置9）➌。记住，你需要使用`del`关键字从列表中删除一个项目。
- en: Insert a new lapis lazuli block at the start of the list ➍. Use the `insert()`
    function with the `barBlock` variable to insert a new lapis lazuli block in index
    position 0.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表的开始位置插入一个新的青金石块➍。使用`insert()`函数和`barBlock`变量，将一个新的青金石块插入到索引位置0。
- en: Comments are included in the code to help you find where you need to do these
    tasks.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中包含注释，以帮助你找到需要执行这些任务的位置。
- en: '**BONUS OBJECTIVE: UP AND DOWN AGAIN**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加目标：再次上下**'
- en: At the moment, the progress bar in *progressBar.py* only counts upward and stops
    when it’s full. Can you work out how to make the progress bar count down in the
    opposite direction?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，*progressBar.py*中的进度条只会向上计数，并在满格时停止。你能弄明白如何让进度条向相反方向倒计时吗？
- en: '**TREATING STRINGS LIKE LISTS**'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**将字符串当作列表处理**'
- en: Strings can be treated like lists, because a string is also a *sequence* of
    data. You can access individual characters in a string using their index; however,
    you cannot change the characters in each index position using the `append` or
    `insert` functions because strings are *immutable*. That means that they cannot
    be changed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以像列表一样处理，因为字符串也是一个 *数据序列*。你可以通过索引访问字符串中的单个字符；然而，你不能使用 `append` 或 `insert`
    函数更改每个索引位置的字符，因为字符串是 *不可变的*。这意味着它们无法更改。
- en: 'The following code will print the second letter in the string `"Grape"`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将打印字符串 `"Grape"` 中的第二个字母：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This shows that you can access parts of a string like you would items in a
    list. For example, you could access the first letters of someone’s first and last
    names to print their initials:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明你可以像访问列表中的元素一样访问字符串的部分。例如，你可以访问某人的名字和姓氏的首字母来打印他们的首字母：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The new string `"L J"` that you get by accessing parts of a string using index
    positions is called a *substring*. Note that the index for a string also counts
    from zero!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用索引位置访问字符串的部分，你得到的新字符串 `"L J"` 被称为 *子字符串*。注意，字符串的索引也是从零开始的！
- en: '**TUPLES**'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**元组**'
- en: '*Tuples* are a type of list that is immutable. But like other lists, they’re
    a sequence of items of any variable type. Tuples use parentheses instead of square
    brackets, and they use commas to separate items.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*元组* 是一种不可变的列表类型。但和其他列表一样，它们是由任何变量类型的项组成的序列。元组使用圆括号而不是方括号，并且使用逗号分隔项。'
- en: 'For example, say a nation’s only Olympic athlete, from an underfunded training
    program, records a number of distances for their long jumps in meters:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一个国家唯一的奥林匹克运动员来自一个资金匮乏的训练项目，记录了他们在长跳中的多个跳跃距离（单位：米）：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If the athlete jumped only once, you could also create a tuple with a single
    value. To write a tuple with a single value, you still have to include a comma:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运动员只跳了一次，你也可以创建一个包含单一值的元组。要写一个包含单一值的元组，你仍然需要加上逗号：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When you’re defining a tuple, the parentheses are optional, so you can just
    define a tuple by placing commas between values, like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义元组时，圆括号是可选的，因此你可以通过在值之间放置逗号来定义元组，就像这样：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To access values of tuples, use the square bracket notation that you use with
    regular lists. Let’s assign the value in index 1 of the `distance` tuple to the
    variable `jump`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问元组的值，可以使用与普通列表相同的方括号表示法。让我们将 `distance` 元组中索引为 1 的值赋给变量 `jump`：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The main difference between lists and tuples is that tuples are immutable:
    you can’t change their contents. You can’t append items to the end of the tuple,
    insert items, delete items, or update any values. You use tuples instead of lists
    when your program doesn’t need to change the values of the items in the tuple.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和元组之间的主要区别在于元组是不可变的：你不能改变它们的内容。你不能向元组的末尾添加项目、插入项目、删除项目或更新任何值。当你的程序不需要改变元组中项目的值时，你会使用元组而不是列表。
- en: '**SETTING VARIABLES WITH TUPLES**'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用元组设置变量**'
- en: A useful feature of tuples is that you can use them to set more than one variable
    at the same time. This saves space and can keep related variables clustered together.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的一个有用特点是你可以同时为多个变量赋值。这节省了空间，并且可以将相关的变量聚集在一起。
- en: 'Normally, you would refer to a tuple like you would a list, by using a single
    variable name:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会像引用列表一样引用元组，使用一个变量名：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: However, let’s say we want to store the values in two variables instead of one.
    The syntax to do so isn’t complex. You separate the variable names with commas,
    then use an equal sign, and then write the tuples on the other side of the equal
    sign. Each tuple value will be assigned to the variable in the corresponding position.
    Let’s take a look.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设我们想要将值存储在两个变量中而不是一个。实现这一点的语法并不复杂。你只需要用逗号分隔变量名，然后使用等号，接着在等号的另一边写上元组。每个元组值将被分配给对应位置的变量。让我们看一下。
- en: 'In this example, two variables, `width` and `height`, are set to the values
    `6` and `30`, respectively:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，两个变量 `width` 和 `height` 分别被设置为值 `6` 和 `30`：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now we have two variables. One is called `width` and has a value of `6`, and
    the other is called `height` and has a value of `30`. And we did it by using just
    a single line of code!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个变量。一个叫做 `width`，其值为 `6`，另一个叫做 `height`，其值为 `30`。而且我们仅通过一行代码就完成了这件事！
- en: '**MISSION #49: SLIDING**'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #49: 滑动**'
- en: 'Setting variables with tuples is a quick and easy way to save space in your
    programs. It’s also useful for setting related variables together in one place
    in your program. For example, throughout the book you’ve used code like this for
    setting the values of the `x`, `y`, and `z` variables:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元组设置变量是节省程序空间的一种快速简便的方法。它对于将相关变量集中设置在程序中的一个地方也非常有用。例如，在本书中，你已经使用过类似这样的代码来设置`x`、`y`和`z`变量的值：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Instead, you can use a tuple to set all of these values in one line:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以使用元组在一行代码中设置所有这些值：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, you’ll put your new code-writing abilities to use! Your mission is to
    create a program that moves the player randomly around the game world in small
    steps, making it look like you’re skating on ice. I’ve started the program for
    you in [Listing 9-3](ch09.html#ch9ex3); some bits are missing and you need to
    complete them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将运用你新的代码编写能力！你的任务是创建一个程序，使玩家在游戏世界中随机移动，通过小步伐看起来像是在冰上滑行。我已经为你开始了程序代码，见[清单
    9-3](ch09.html#ch9ex3)；一些部分缺失，你需要完成它们。
- en: '*sliding.py*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*sliding.py*'
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 9-3: The start of the code to make the player slide around the map*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-3：让玩家在地图上滑行的代码开头*'
- en: Copy [Listing 9-3](ch09.html#ch9ex3) into a new file and save it as *sliding.py*
    in your *lists* folder. To finish the program, you need to get the player’s starting
    position ➊ and set the values of the `x`, `y`, and `z` variables ➋. Use a tuple
    to set these values. This program also uses the `uniform()` function ➌, which
    is like the `randint()` function (see “[Playing with Random Numbers](ch03.html#ch03lev2sec12)”
    on [page 62](ch03.html#page_62)) but returns a random float value instead of an
    integer value. Use the `uniform()` function to change the value of the `z` variable
    in the loop ➍. This has already been done for the `x` variable ➌.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将[清单 9-3](ch09.html#ch9ex3)复制到一个新文件中，并将其保存在你的*lists*文件夹中，命名为*sliding.py*。要完成程序，你需要获取玩家的起始位置
    ➊，并设置`x`、`y`和`z`变量的值 ➋。使用元组设置这些值。该程序还使用了`uniform()`函数 ➌，它类似于`randint()`函数（见“[玩转随机数](ch03.html#ch03lev2sec12)”在[第62页](ch03.html#page_62)），但返回一个随机的浮动值，而不是整数值。在循环中，使用`uniform()`函数来更改`z`变量的值
    ➍。`x`变量已经通过该函数进行了更改 ➌。
- en: '[Figure 9-3](ch09.html#ch9fig3) shows my player sliding slowly around my game.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-3](ch09.html#ch9fig3)展示了我的玩家在游戏中缓慢滑行。'
- en: '![image](graphics/f09-03.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f09-03.jpg)'
- en: '*Figure 9-3: Slowly sliding backwards around my garden*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-3：我在花园里慢慢滑行*'
- en: '**BONUS OBJECTIVE: SLIDING BLOCKS**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加目标：滑动方块**'
- en: The *sliding.py* program makes the player slide randomly around the game. Can
    you work out how to change the program so it makes a block slide around?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*sliding.py*程序使玩家在游戏中随机滑动。你能想出如何修改程序使方块滑动吗？'
- en: '**RETURNING A TUPLE**'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**返回元组**'
- en: 'Some of Python’s built-in functions return a tuple. When you define your own
    functions, they can return the result as a tuple as well. To do that, you put
    a tuple after the `return` keyword. For example, let’s create a function to convert
    a date into a tuple. We give the date as a string argument, and the function will
    return the year, the month, and the day in a tuple. Here’s the code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Python的内置函数返回一个元组。当你定义自己的函数时，它们也可以返回一个元组作为结果。为此，你只需要在`return`关键字后面放一个元组。例如，我们可以创建一个将日期转换为元组的函数。我们将日期作为字符串参数传递，函数会返回一个包含年份、月份和日期的元组。以下是代码：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When we call the function and give it a date as a string, it returns a tuple
    containing the year, month, and day in that order:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用函数并传入一个日期字符串时，它会返回一个元组，元组中的顺序为年份、月份和日期：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When we call the function, we can store the returned tuple however we want.
    This code stores each value in a separate variable:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用函数时，可以根据需要存储返回的元组。以下代码将每个值存储到一个单独的变量中：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now we can quickly convert date strings to individual variables. In my work
    as a software developer, I use code that’s very similar to this all the time.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以快速将日期字符串转换为单独的变量。在我作为软件开发人员的工作中，我经常使用与此非常相似的代码。
- en: '**OTHER USEFUL FEATURES OF LISTS**'
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**列表的其他有用特性**'
- en: You can do many other tasks with lists. This section explains how to find the
    length of a list, how to randomly choose an item from a list, and how to use an
    `if` statement to check whether a value is in a list.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用列表完成许多其他任务。本节解释了如何查找列表的长度、如何从列表中随机选择一个项目，以及如何使用`if`语句检查一个值是否在列表中。
- en: '**LIST LENGTH**'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**列表长度**'
- en: 'The `len()` function is a quick way to find the length of any list in Python.
    The function returns the number of items in a list when a list is used as an argument.
    Let’s see it in action:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`len()` 函数是一个快速查找 Python 中任何列表长度的方式。当列表作为参数时，函数返回列表中项目的数量。我们来看看它是如何工作的：'
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Although Python starts counting indexes at zero, it counts how many items are
    in a list in regular counting numbers. The highest index in this list is 5, but
    Python knows there are 6 total items!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Python 从零开始计算索引，但它以常规的计数方式计算列表中有多少个项目。这个列表中的最高索引是 5，但 Python 知道总共有 6 个项目！
- en: '**MISSION #50: BLOCK HITS**'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #50：块击打**'
- en: The Minecraft Python API has a handy function that returns a list of locations
    you’ve hit with your sword. You can use the items in the list to get the coordinates
    of blocks you’ve hit. You’ll see how useful this is in programs later in this
    chapter and later in the book.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Minecraft Python API 提供了一个方便的函数，返回你用剑击中的方块位置列表。你可以使用列表中的项目来获取你击中的方块的坐标。你将在本章后面的程序以及本书后续章节中看到它的有用之处。
- en: 'You can also make a short and fun game that counts the number of blocks you
    can hit in a minute. In this mission, you’ll do just that. It’s quite a fun game:
    play against a friend and try to beat each other’s scores! You can also expand
    it, for example, by keeping a high score.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以制作一个短小有趣的游戏，计算你在一分钟内能击打多少个方块。在这个任务中，你将实现这一目标。这是一个非常有趣的游戏：与朋友一起玩，试图打破彼此的记录！你还可以扩展它，例如通过记录最高分来增加趣味。
- en: '[Figure 9-4](ch09.html#ch9fig4) shows the program in action.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-4](ch09.html#ch9fig4) 展示了程序的运行效果。'
- en: '![image](graphics/f09-04.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f09-04.jpg)'
- en: '*Figure 9-4: In 60 seconds I hit 197 blocks.*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：在 60 秒内我击打了 197 个方块。*'
- en: 'Not much code is required to make this game. Here’s a summary of the code structure:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 制作这个游戏所需的代码并不多。以下是代码结构的概述：
- en: Connect to the Minecraft game.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到 Minecraft 游戏。
- en: Wait 60 seconds.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待 60 秒。
- en: Get the list of block hits.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取块击打列表。
- en: Display the length of the block hits list to chat.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示块击打列表的长度到聊天窗口。
- en: 'The following code shows the only part you haven’t seen so far, which is the
    code that gets the list of block hits from the game:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了你到目前为止尚未看到的部分，即从游戏中获取块击打列表的代码：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This code uses the `pollBlockHits()` function to return a list of block hits
    and stores that list in a variable named `blockHits`. The `blockHits` variable
    will act like any other kind of list, so you can access data from index positions
    and get the length of the list.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用 `pollBlockHits()` 函数返回一个块击打列表，并将该列表存储在名为 `blockHits` 的变量中。`blockHits`
    变量将像其他任何类型的列表一样工作，因此你可以通过索引位置访问数据，并获取列表的长度。
- en: 'When you play this game, you’ll have to right-click blocks to keep count of
    them. The reason is that the `pollBlockHits()` function records all the blocks
    you *right-click* with a sword. On the PC version of Minecraft, right-clicking
    with your sword looks more like you’re defending yourself than hitting something,
    but it still records which blocks you’ve clicked. [Figure 9-5](ch09.html#ch9fig5)
    shows what this looks like. Make sure you only right-click with your sword: left
    clicks with your sword won’t be recorded, and neither will right-clicking with
    something else in your hand! But you can use any type of sword, including iron,
    gold, and diamond.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当你玩这个游戏时，你需要右键点击方块来计算它们的数量。原因是 `pollBlockHits()` 函数会记录所有你用剑右键点击的方块。在 Minecraft
    的 PC 版本中，使用剑右键看起来更像是你在防御而不是击打某物，但它仍然会记录你点击了哪些方块。[图 9-5](ch09.html#ch9fig5) 展示了这是什么样子。确保你只用剑右键点击：用剑左键点击不会被记录，手里拿着别的东西右键点击也不会被记录！但你可以使用任何类型的剑，包括铁剑、金剑和钻石剑。
- en: '![image](graphics/f09-05.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f09-05.jpg)'
- en: '*Figure 9-5: When I right-click, the player holds the sword like this.*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-5：当我右键点击时，玩家像这样举着剑。*'
- en: 'When you print the output of the list, it should look similar to this, although
    the values will change each time depending on where you hit:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印列表的输出时，它应该看起来类似于这个，尽管每次值会根据你击打的位置不同而变化：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This list output stores the details of four block hits. Each item contains
    the hit’s coordinates. You’ll learn how to access these coordinates in [Mission
    #55](ch10.html#ch10lev2sec01) ([page 196](ch10.html#page_196)).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '这个列表输出存储了四个块击打的详细信息。每个项目包含击打的坐标。你将在 [任务 #55](ch10.html#ch10lev2sec01)（[第 196
    页](ch10.html#page_196)）中学会如何访问这些坐标。'
- en: To help you get started with the program, I’ve written the basic structure in
    [Listing 9-4](ch09.html#ch9ex4).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你开始这个程序，我已经在 [清单 9-4](ch09.html#ch9ex4) 中写了基本的结构。
- en: '*swordHits.py*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*swordHits.py*'
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 9-4: Beginnings of the sword hits game*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-4：剑击游戏的开端*'
- en: To complete this program, open IDLE, create a new file, and copy [Listing 9-4](ch09.html#ch9ex4)
    into it. Save this file as *swordHits.py* in the *lists* folder. Set the `blockHits`
    variable using the `pollBlockHits()` function ➊ and set the `blockHitsLength`
    variable by getting the length of the `blockHits` variable ➋.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个程序，打开IDLE，创建一个新文件，并将[清单 9-4](ch09.html#ch9ex4)的内容复制到文件中。将文件保存为*swordHits.py*，并放入*lists*文件夹中。使用`pollBlockHits()`函数➊设置`blockHits`变量，并通过获取`blockHits`变量的长度来设置`blockHitsLength`变量➋。
- en: '**RANDOMLY CHOOSING AN ITEM**'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**随机选择一个项**'
- en: By now you might have realized that I really like using randomly generated things
    in my programs. Randomness makes a program behave somewhat unpredictably every
    time you run it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里，你可能已经意识到，我真的很喜欢在我的程序中使用随机生成的元素。随机性使得程序在每次运行时表现得有些不可预测。
- en: When you’re using lists, you’ll want to access random items from the list from
    time to time. For example, you might want to choose a block at random from a list
    of blocks.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用列表时，你会时不时需要从列表中访问随机项。例如，你可能需要从一堆块中随机选择一个。
- en: The `choice()` function in the `random` module is the go-to function for choosing
    a list item at random. The function takes one argument, the list that you want
    to use, and returns a random item from within the list.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`random`模块中的`choice()`函数是选择列表项的首选函数。这个函数接受一个参数，即你想要使用的列表，并从中返回一个随机项。'
- en: 'In [Listing 9-5](ch09.html#ch9ex5), the `colors` list contains the names of
    several colors. It chooses one at random using the `choice()` function and then
    prints it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 9-5](ch09.html#ch9ex5)中，`colors`列表包含了几种颜色的名称。它使用`choice()`函数随机选择一个，并将其打印出来：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 9-5: Printing a random color from a list of colors*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-5：从颜色列表中打印一个随机颜色*'
- en: When you run the code, the program will output an item from the list at random.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行代码时，程序会随机输出列表中的一项。
- en: '**MISSION #51: RANDOM BLOCK**'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #51：随机块**'
- en: In Minecraft, selecting a random block ID from a range of numbers can cause
    problems in the program because some block IDs don’t have corresponding blocks.
    One solution is to use a list of valid blocks to select from at random. Lists
    allow you to create a limited number of items and then select one at random using
    the `choice()` function.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在Minecraft中，从一系列数字中随机选择一个块ID可能会导致程序出错，因为有些块ID没有对应的块。一个解决方法是使用一个有效块的列表，从中随机选择。列表允许你创建有限数量的项，然后使用`choice()`函数从中随机选择一个。
- en: Your mission is to create a list of block IDs, select a random block from that
    list, and then set the block to the player’s position. You can use [Listing 9-5](ch09.html#ch9ex5)
    as a starting point.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是创建一个块 ID 的列表，从中随机选择一个块，然后将该块设置到玩家的位置。你可以使用[清单 9-5](ch09.html#ch9ex5)作为起点。
- en: First, create a list of block IDs. Second, use the `random.choice()` function
    to select a block from the list. Third, use the `setBlock()` function to place
    the random block in the Minecraft game.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个块 ID 的列表。其次，使用`random.choice()`函数从列表中选择一个块。最后，使用`setBlock()`函数将随机块放置到Minecraft游戏中。
- en: Save the program as *randomBlock.py* in the *lists* folder.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序保存为*randomBlock.py*，并放入*lists*文件夹中。
- en: Include as many blocks as you want in your list. For my list I chose five blocks,
    including melon, diamond, and gold. You can see the result of running the program
    in [Figure 9-6](ch09.html#ch9fig6).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在列表中包含任意数量的块。对于我的列表，我选择了五种块，包括西瓜、钻石和金块。你可以在[图 9-6](ch09.html#ch9fig6)中看到运行程序的结果。
- en: '![image](graphics/f09-06.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f09-06.jpg)'
- en: '*Figure 9-6: The program randomly selected a gold block.*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-6：程序随机选择了一个金块。*'
- en: '**COPYING A LIST**'
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复制列表**'
- en: 'Copying lists is quite tricky in most programming languages. List variables
    do not actually contain values; instead, they contain a reference to an address
    in your computer’s memory that has further references to the values contained
    in the list. Although your computer takes care of this capability behind the scenes,
    it’s worthwhile to understand how it works because it will make you a smarter
    programmer! You can view the memory address of a list using the `id()` function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程语言中，复制列表是相当棘手的。列表变量实际上并不包含值；相反，它们包含一个指向你计算机内存中某个地址的引用，这个地址进一步引用了列表中包含的值。虽然你的计算机会在幕后处理这一功能，但了解它的工作原理是值得的，因为这会让你成为一个更聪明的程序员！你可以使用`id()`函数查看列表的内存地址：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: For example, the output of this code on my computer was `3067456428`. The value
    `3067456428` is the memory location where `cake` is stored. When you run this
    code on your computer, you’ll probably get a different number because it’s stored
    in a different place in your computer’s memory.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我的电脑上运行这段代码时，输出为 `3067456428`。值 `3067456428` 是 `cake` 存储的内存位置。当你在你的电脑上运行这段代码时，可能会得到一个不同的数字，因为它存储在电脑内存中的不同位置。
- en: You don’t need to understand this behavior fully, but you do need to know that
    it has consequences when you want to copy a list into another variable. Instead
    of the values in the list being copied as you would expect, the memory location
    of the list is copied into the new variable. This means that when you change a
    value in either list, it will affect the other.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要完全理解这个行为，但你需要知道，当你想把一个列表复制到另一个变量时，它会产生影响。与预期的不同，列表中的值并没有被复制，而是列表的内存位置被复制到了新变量中。这意味着，当你在任一列表中更改某个值时，它会影响另一个列表。
- en: 'For example, the following program creates a list called `cake` and then sets
    the value of `chocolateCake` to be the same as `cake`. An item, `"Chocolate"`,
    is then added to the `chocolateCake` list:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面的程序创建了一个名为 `cake` 的列表，然后将 `chocolateCake` 的值设置为与 `cake` 相同。接着，向 `chocolateCake`
    列表中添加了一个项，`"Chocolate"`：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Unfortunately, `"Chocolate"` is also added to the `cake` list, even though
    you didn’t want it to be. You can see this mistake when the lists are printed:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，尽管你不希望这样，`"Chocolate"` 也被添加到了 `cake` 列表中。你可以通过打印列表看到这个错误：
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This problem happens because the variables store the memory location of the
    list, not the items in the list.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题发生是因为变量存储的是列表的内存位置，而不是列表中的项。
- en: 'A simple way to overcome this problem is to use a *list slice*. When you slice
    food with a knife, you are cutting it into different parts. A list slice in Python
    is similar. When you slice a list, you take a piece of the list. You can use a
    list slice to take only certain items in a list, but in this case, you’ll be using
    a list slice to copy every item in a list. To copy the `cake` list into the `chocolateCake`
    variable, use this code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 克服这个问题的一种简单方法是使用 *列表切片*。当你用刀切割食物时，你是在把它分成不同的部分。在 Python 中，列表切片也类似。当你切割一个列表时，你实际上是从列表中取出一部分。你可以使用列表切片来获取列表中的某些项，但在这个例子中，你将使用列表切片来复制列表中的每一项。要将
    `cake` 列表复制到 `chocolateCake` 变量中，可以使用以下代码：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `chocolateCake` variable will now contain the values of the `cake` list
    but with a different memory address.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`chocolateCake` 变量将包含 `cake` 列表中的值，但内存地址不同。
- en: 'The code for the cake ingredients can be corrected using the list slice:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过列表切片来修正蛋糕配料的代码：
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can see that the items in `cake` have been copied to `chocolateCake` using
    `[:]` at ➊.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`cake` 中的项已经通过 `[:]` 被复制到了 `chocolateCake` 中，见 ➊。
- en: 'Here’s the output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice that the values in both lists are now different—only `chocolateCake`
    contains the `"Chocolate"` value.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在两个列表中的值已经不同——只有 `chocolateCake` 包含了 `"Chocolate"` 值。
- en: '**ITEMS AND IF STATEMENTS**'
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**项目和 if 语句**'
- en: To find out whether a value is in a list, you can use the `in` operator. The
    `in` operator goes between a value and the list you want to check. If the value
    is in the list, the expression will evaluate to `True`; if the value is not in
    the list, the expression will evaluate to `False`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查某个值是否在列表中，可以使用 `in` 运算符。`in` 运算符位于一个值和你想检查的列表之间。如果该值在列表中，表达式的结果为 `True`；如果该值不在列表中，表达式的结果为
    `False`。
- en: 'The following example checks whether the value `"Eggs"` is in the `cake` list:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例检查值 `"Eggs"` 是否在 `cake` 列表中：
- en: '[PRE45]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The value `True` will be printed, because `"Eggs"` is in the list.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 输出值为 `True`，因为 `"Eggs"` 在列表中。
- en: 'You can of course use the `in` operator as part of an `if` statement condition.
    The following code extends and adapts this example to use an `if` statement instead
    of printing the Boolean value. It checks whether `"Ham"` is in the `cake` list
    and prints different messages depending on whether it is or isn’t in the list:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以将 `in` 运算符用作 `if` 语句条件的一部分。以下代码扩展并改编了这个例子，使用 `if` 语句而不是直接打印布尔值。它检查 `"Ham"`
    是否在 `cake` 列表中，并根据是否在列表中打印不同的信息：
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can combine the `not` operator with the `in` operator to produce the opposite
    effect. Instead of returning `True` when an item is in a list, the code will return
    `False` and vice versa. Here’s how that looks (note that the bodies of the `if`
    and `else` statements have also been swapped):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`not`操作符与`in`操作符结合使用，产生相反的效果。代码将返回`False`而不是当一个项目在列表中时返回`True`，反之亦然。下面是示例（注意`if`和`else`语句的主体也已交换）：
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You can use either technique in your programs. Just choose the one that you
    think makes the most sense!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在程序中使用任一技术。只需选择你认为最合适的一种！
- en: '**MISSION #52: NIGHT VISION SWORD**'
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #52：夜视剑**'
- en: Do you forget to bring enough torches with you when you’re exploring caves in
    Minecraft? I do that all the time. Sometimes I forget to bring any torches, and
    I’m too far into the cave to go back. So I fumble around in the dark, not really
    sure if I’m finding anything useful. But with your Python knowledge, you can make
    a program to help you find diamonds with your sword.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你在探索Minecraft中的洞穴时是否会忘记带足够的火把？我经常这样做。有时我甚至忘记带火把，而且我已经走得太远，无法回头。所以我在黑暗中摸索，不确定自己是否发现了什么有用的东西。但是，凭借你的Python知识，你可以制作一个程序，帮助你用剑找到钻石。
- en: Let’s write a basic program that uses the `pollBlockHits()` function to check
    whether any of the blocks you’ve hit are diamond ore. This is useful for exploring
    caves with no light or playing a game of “find the diamond ore” in the dark. The
    code is in [Listing 9-6](ch09.html#ch9ex6). Copy it into a new file and save it
    as *nightVisionSword.py* in the *lists* folder.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个基本程序，使用`pollBlockHits()`函数检查你击中的方块是否是钻石矿石。这对于在没有光的洞穴中探险，或者玩“在黑暗中找钻石矿石”的游戏很有用。代码在[Listing
    9-6](ch09.html#ch9ex6)中。将其复制到新文件中，并保存为*nightVisionSword.py*，保存在*lists*文件夹中。
- en: '*nightVisionSword.py*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*nightVisionSword.py*'
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Listing 9-6: This program will help you find diamond ore in the dark.*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-6：这个程序将帮助你在黑暗中找到钻石矿石。*'
- en: Notice how `hit.pos.x`, `hit.pos.y`, and `hit.pos.z` are used ➊. Each hit stores
    the coordinates of the block that was clicked using a tuple. You can access these
    coordinates using dot notation. In this example, the variable name `hit` is used
    to name the list that contains each block hit, so I access the coordinates using
    `hit.pos.x`, `hit.pos.y`, and `hit.pos.z`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何使用`hit.pos.x`、`hit.pos.y`和`hit.pos.z` ➊。每次击中都会存储点击方块的坐标，这些坐标是通过元组存储的。你可以使用点符号访问这些坐标。在这个例子中，`hit`这个变量名被用来命名包含每个击中方块的列表，因此我通过`hit.pos.x`、`hit.pos.y`和`hit.pos.z`来访问这些坐标。
- en: The code is nearly complete. The only remaining task is to check whether you’ve
    found some diamond. Add an `if` statement ➋ to check whether diamond ore (block
    ID 56) is in the `blocks` list and post a message to chat saying `"You found some
    diamond ore!"` if it is. Add a `break` statement inside the `if` statement as
    well so the loop stops repeating when you find the ore.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 代码几乎完成了。唯一剩下的任务是检查你是否找到了钻石。添加一个`if`语句 ➋，检查`blocks`列表中是否有钻石矿石（方块ID 56），如果有，则向聊天窗口发送消息`"你找到了钻石矿石！"`。在`if`语句中添加一个`break`语句，使得当你找到矿石时，循环停止。
- en: '[Figure 9-7](ch09.html#ch9fig7) shows the program in action.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-7](ch09.html#ch9fig7)展示了程序的运行效果。'
- en: '![image](graphics/f09-07.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f09-07.jpg)'
- en: '*Figure 9-7: It’s dark, but I found some diamond ore. Yay!*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-7：很黑，但我找到了钻石矿石。耶！*'
- en: If you’re not as forgetful as I am and remember to bring torches with you into
    caves, you can still use this code—as a game. Make an underground room with no
    light and put a single diamond ore somewhere on the wall. Run the program and
    see how long it takes you to find the diamond ore in the dark. Remember to right-click
    with a sword! That’s the only way the `pollBlockHits()` function can record which
    blocks you’re hitting.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不像我那么健忘，记得带火把进入洞穴，你仍然可以将这段代码当作一个游戏来使用。制作一个没有光的地下室，并在墙上某个地方放一个钻石矿石。运行程序，看看你需要多少时间才能在黑暗中找到钻石矿石。记得用剑右键点击！这是`pollBlockHits()`函数记录你击中的方块的唯一方式。
- en: '**BONUS OBJECTIVE: DIAMOND CHALLENGE**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**额外目标：钻石挑战**'
- en: It would be cool to change the *nightVisionSword.py* program into a full mini-game.
    Can you automatically generate a room with a single diamond block placed at random,
    put the player in that room, and then time how long it takes them to find the
    block in the dark?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 将*nightVisionSword.py*程序改造成一个完整的小型游戏会很酷。你能自动生成一个房间，在其中随机放置一个钻石方块，把玩家放在这个房间里，然后计时玩家在黑暗中找到该方块所花费的时间吗？
- en: '**DICTIONARIES**'
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典**'
- en: Dictionaries are a type of list that uses a different approach. Instead of using
    an index to identify items, dictionaries identify items using a set of keys defined
    by the programmer.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是一种使用不同方法的列表。字典不使用索引来标识项，而是使用程序员定义的一组键来标识项。
- en: 'For example, this `raceTimes` dictionary stores the names of people who ran
    in a race and their race times:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个`raceTimes`字典存储了参加比赛的人的名字和他们的比赛时间：
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The key uniquely identifies each value in the dictionary. In this example, the
    key is the name of the person. The `'Katy'` key has an associated value of `26`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 键唯一地标识字典中的每个值。在这个示例中，键是人的名字。`'Katy'`键对应的值是`26`。
- en: Like lists, dictionaries are mutable; their content can be changed.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 和列表一样，字典是可变的；它们的内容可以更改。
- en: '**DEFINING A DICTIONARY**'
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**定义字典**'
- en: 'To define a dictionary, use a pair of curly brackets around a set of key-value
    pairs. For example, you can use a dictionary to describe a person. You can use
    keys like `''name''` and `''favoriteAnimal''` to store information about the person,
    like so:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个字典，可以使用一对花括号将一组键值对括起来。例如，你可以使用字典来描述一个人。你可以使用像`'name'`和`'favoriteAnimal'`这样的键来存储关于此人的信息，像这样：
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this example, every key is a string. Each key is paired with a value using
    a colon. For example, `'age'` is a key and `42` is its corresponding value. Items
    in the dictionary are then separated by commas.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，每个键都是一个字符串。每个键与一个值配对，使用冒号。例如，`'age'`是一个键，`42`是其对应的值。字典中的项然后用逗号分隔。
- en: You may have noticed that using dictionaries makes it easy for a programmer
    to understand what each item in the list represents; for example, it’s easy to
    understand that the `'name'` key stores a name, not a number or some other random
    information.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，使用字典可以让程序员轻松理解列表中的每一项表示什么；例如，很容易理解`'name'`键存储的是名字，而不是数字或其他随机信息。
- en: You can also use integers and floats as dictionary keys. Using floats or integers
    in dictionaries is very useful when the keys you want to match with values don’t
    follow a strict sequence.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用整数和浮动数作为字典的键。在字典中使用浮动数或整数非常有用，当你想要匹配的键与值之间不遵循严格的顺序时。
- en: 'The following example creates a dictionary of train times. The train time (which
    is a float) is stored as the key, and the destination of the train is stored as
    the value:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例创建了一个火车时间的字典。火车时间（浮动值）作为键存储，火车的目的地作为值存储：
- en: '[PRE51]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Because dictionaries can store two pieces of data that go together as a pair,
    they’re ideal for a situation like this. If I used a list of train destinations
    instead of a dictionary, I wouldn’t be able to match up the times to the destinations.
    I would only be able to use the list’s index positions, which would be 0, 1, 2,
    3, 4, and so on, instead of the times.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因为字典可以存储成对的数据，它们非常适合像这样的情况。如果我使用一个火车目的地的列表而不是字典，我就无法将时间与目的地匹配起来。我只能使用列表的索引位置，如0、1、2、3、4，等等，而不是时间。
- en: '**ACCESSING ITEMS IN DICTIONARIES**'
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问字典中的项**'
- en: To access the value of an item in a dictionary, you use square brackets and
    a key instead of an index. The key is usually a string or an integer. When you’re
    creating a dictionary that uses strings as keys, make sure you put them in quotation
    marks.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问字典中项的值，可以使用方括号和键，而不是使用索引。键通常是字符串或整数。当你创建一个使用字符串作为键的字典时，确保将它们放在引号中。
- en: 'For example, to access the value of the `''name''` key in the `person` dictionary
    created earlier, you would use this syntax:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要访问之前创建的`person`字典中`'name'`键的值，你可以使用以下语法：
- en: '[PRE52]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `agentName` variable will contain the value `''David''` because it accesses
    the value of the `''name''` key. In the same way, if you wanted to access the
    age of the agent, you would use the `''age''` key:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`agentName`变量将包含值`''David''`，因为它访问了`''name''`键的值。同样，如果你想访问代理的年龄，可以使用`''age''`键：'
- en: '[PRE53]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This would store the value `42` in the `agentAge` variable.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将值`42`存储在`agentAge`变量中。
- en: 'In the `trainTimes` example, you can access the values in the dictionary (the
    destinations) using their key values (the train times), which are floats:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在`trainTimes`示例中，你可以使用字典中的键值（火车时间）来访问字典中的值（目的地），这些键值是浮动的：
- en: '[PRE54]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Accessing the `3.15` key in the `trainTimes` dictionary sets the `myTrain` variable
    to `'Lake City'`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`trainTimes`字典中的`3.15`键会将`myTrain`变量设置为`'Lake City'`。
- en: '**MISSION #53: SIGHTSEEING GUIDE**'
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #53: 旅游指南**'
- en: 'When you’re using dictionaries, you can store any data type as the value, even
    lists and tuples. For example, you could store a tuple containing values for `x`,
    `y`, and `z`. Here’s an example of code that does just that:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用字典时，你可以将任何数据类型作为值存储，包括列表和元组。例如，你可以存储一个包含`x`、`y`和`z`值的元组。以下是一个实现该功能的代码示例：
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `places` dictionary stores two items. The dictionary key is the name of
    a location in my Minecraft game (such as my living room or bedroom), and the value
    is a tuple of the coordinates. If I wanted to access the coordinates of my living
    room, I would use the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`places`字典存储了两个项。字典的键是我在Minecraft游戏中某个地点的名称（例如我的客厅或卧室），而值是该地点坐标的元组。如果我想访问我客厅的坐标，我将使用以下代码：'
- en: '[PRE56]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Your mission is to create a program that uses a dictionary to store the locations
    of different places in your Minecraft game so you can teleport to them by name.
    Include as many locations in the dictionary as you want. To teleport to those
    locations, you need to access the tuple of coordinates stored in the dictionary
    and then set `x`, `y`, and `z` to the values stored in the tuple. Comments in
    the code show where to do this.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是创建一个程序，使用字典存储Minecraft游戏中不同地点的位置，以便你可以通过名称传送到这些地方。可以在字典中包含任意数量的位置。要传送到这些地点，你需要访问字典中存储的坐标元组，然后将`x`、`y`和`z`设置为元组中存储的值。代码中的注释标明了你需要进行这些操作的位置。
- en: Copy [Listing 9-7](ch09.html#ch9ex7) into the IDLE text editor and save it in
    the *lists* folder as *sightseeingGuide.py*.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 将[示例 9-7](ch09.html#ch9ex7)复制到IDLE文本编辑器中，并将其保存到*lists*文件夹下，命名为*sightseeingGuide.py*。
- en: '*sightseeingGuide.py*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*sightseeingGuide.py*'
- en: '[PRE57]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '*Listing 9-7: Some neat code to teleport to different locations*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-7：一些用于传送到不同位置的有趣代码*'
- en: I’ve included a statement that asks you to enter the name of the location you
    want to go to. This input is stored in the `choice` variable ➊. The program then
    uses an `if` statement to check whether the value of `choice` is in the dictionary
    ➋. The last line uses the `x`, `y`, and `z` variables to teleport the player to
    the position stored in the dictionary.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经包含了一条语句，提示你输入你想要前往的地点名称。这个输入被存储在`choice`变量中 ➊。程序随后使用`if`语句检查`choice`的值是否在字典中
    ➋。最后一行使用`x`、`y`和`z`变量将玩家传送到字典中存储的位置。
- en: When the program runs, enter the name of the location that you want to go to.
    [Figure 9-8](ch09.html#ch9fig8) shows my version of the program teleporting me
    to different places in my game.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，输入你想要前往的地点名称。[图 9-8](ch09.html#ch9fig8)展示了我在程序中传送到不同地点的版本。
- en: '![image](graphics/f09-08.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f09-08.jpg)'
- en: '*Figure 9-8: I teleported to my living room (top) and my bedroom (bottom).*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-8：我传送到了我的客厅（上）和卧室（下）。*'
- en: '**CHANGING OR ADDING AN ITEM IN A DICTIONARY**'
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**更改或添加字典中的项**'
- en: It doesn’t take much work to change the value of an item in a dictionary. You
    use square brackets with a key to access the item and set it as you would a normal
    variable (with an equal sign). You can also add a new item using this approach.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 更改字典中项的值并不需要太多工作。你只需使用方括号和键来访问该项，并像设置普通变量一样（使用等号）为其赋值。你也可以使用这种方法添加新项。
- en: 'Let’s change the value of the `age` item in the `person` dictionary from 42
    to 43:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`person`字典中`age`项的值从42更改为43：
- en: '[PRE58]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let’s also add a new item called `location` with the value `''USS Discovery''`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也添加一个名为`location`的新项，值为`'USS Discovery'`：
- en: '[PRE59]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: After running this code, the dictionary will have a new key called `location`
    that has the value of `'USS Discovery'`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码后，字典将包含一个名为`location`的新键，其值为`'USS Discovery'`。
- en: '**DELETING ITEMS IN DICTIONARIES**'
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**删除字典中的项**'
- en: 'Sometimes you’ll want to delete an item in a dictionary. As with a list, you
    use the `del` keyword to do this. For example, to delete the `favoriteAnimal`
    item in the `person` dictionary, you would do this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能想删除字典中的某个项。和列表一样，你可以使用`del`关键字来删除它。例如，要删除`person`字典中的`favoriteAnimal`项，你可以这样做：
- en: '[PRE60]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you can see, it works just like deleting items from a list.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这和从列表中删除项一样有效。
- en: '**MISSION #54: BLOCK HITS SCORE**'
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #54：击打方块得分**'
- en: 'In [Mission #50](ch09.html#ch09lev2sec12) ([page 180](ch09.html#page_180)),
    you wrote a program that counts the number of times the player hits a block with
    their sword in 60 seconds. As fun as the program is, it would be even cooler if
    you could record the scores of everyone who played.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '在[任务 #50](ch09.html#ch09lev2sec12)（[第180页](ch09.html#page_180)）中，你编写了一个程序，计算玩家在60秒内用剑击打方块的次数。虽然这个程序很有趣，但如果你能记录所有玩家的得分，那会更酷。'
- en: To add a scoreboard to the game, you’ll use a dictionary. The dictionary will
    store the player’s name and their score, which can then be displayed alongside
    everyone else’s scores.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要为游戏添加成绩榜，你将使用字典。字典将存储玩家的名字和分数，这些可以与其他玩家的分数一起显示出来。
- en: To get started, open *swordHits.py* and save it as *swordHitsScore.py* in the
    *lists* folder. Update the code to match [Listing 9-8](ch09.html#ch9ex8), where
    I’ve made some changes to the program so it repeats, asks the player for their
    name, and then prints all the scores. (I’ve also included the solutions to the
    missing code from *swordHits.py*.) The older sections are grayed out. (Remember
    to indent everything inside the loop.)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，打开*swordHits.py*并将其保存为*swordHitsScore.py*，放在*lists*文件夹中。更新代码以匹配[清单 9-8](ch09.html#ch9ex8)，在这里我对程序做了一些修改，使其能够重复运行，要求玩家输入他们的名字，然后打印所有的成绩。（我还包括了*swordHits.py*中缺失代码的解决方案。）旧部分已被灰色标记。（记得缩进循环内部的所有内容。）
- en: '*swordHitsScore.py*'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*swordHitsScore.py*'
- en: '[PRE61]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '*Listing 9-8: When the code is complete, it will add a scoreboard to the block
    hits game.*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-8：当代码完成时，它将为方块击打游戏添加一个成绩榜。*'
- en: To finish the program, you need to store the name and score of every player
    who plays the game. Do this by adding a new dictionary item using the pieces of
    data in the code at ➊. The dictionary is called `scoreboard`, and the name of
    the player is stored in the `name` variable.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成程序，你需要存储每个玩游戏的玩家的名字和分数。通过使用代码中➊部分的数据，向字典添加一个新的条目来实现这一点。字典叫做`scoreboard`，玩家的名字存储在`name`变量中。
- en: '[Figure 9-9](ch09.html#ch9fig9) shows the output of my scoreboard.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-9](ch09.html#ch9fig9)显示了我的成绩榜的输出。'
- en: '![image](graphics/f09-09.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f09-09.jpg)'
- en: '*Figure 9-9: My friends and I played a game, and Jim is the winner with 274
    block hits.*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-9：我和我的朋友们玩了一个游戏，Jim以274次方块击打获胜。*'
- en: '**NOTE**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You might have noticed that when the* `scoreboard` *dictionary is printed,
    it isn’t easy to read. You’ll learn how to fix this in [Mission #59](ch10.html#ch10lev2sec07)
    ([page 205](ch10.html#page_205)).*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能已经注意到，当打印`scoreboard`字典时，它不太容易阅读。在[任务 #59](ch10.html#ch10lev2sec07)中，你将学会如何解决这个问题（[第205页](ch10.html#page_205)）。*'
- en: '**BONUS OBJECTIVE: BEST SCORE**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加目标：最佳成绩**'
- en: 'At the moment, if someone plays the *swordHitsScore.py* game two or more times
    (and enters the same username), the program will only record their most recent
    score. Can you work out how to use an `if` statement to check whether the player
    has already entered a score and store the new score only if it is greater than
    the previous one? Here’s the beginning of the code to help you out. It checks
    whether someone’s name is already in the `scoreboard` dictionary:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果某人玩了*swordHitsScore.py*游戏两次或更多次（并且输入了相同的用户名），程序只会记录他们最近的分数。你能想出如何使用`if`语句来检查玩家是否已经输入过分数，并且仅在新分数大于之前的分数时存储新分数吗？以下是帮助你开始的代码。它检查某人的名字是否已经在`scoreboard`字典中：
- en: '[PRE62]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**WHAT YOU LEARNED**'
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: Excellent job! In this chapter you learned about lists, tuples, and dictionaries.
    You saw that they can store several data values in a single variable. They are
    a very useful way to structure and store data in your programs.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好！在本章中，你学到了列表、元组和字典。你看到它们可以在一个变量中存储多个数据值。它们是结构化和存储程序数据的非常有用的方式。
- en: In the missions, you created several fun programs that use lists, dictionaries,
    and tuples. With lists, you created a progress bar using lapis lazuli and glass.
    Using tuples, you learned a quicker way to set the `x`, `y`, and `z` variables.
    And dictionaries allowed you to store the coordinates of things you’ve built and
    then teleport to them by entering their names.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些任务中，你创建了几个有趣的程序，使用了列表、字典和元组。通过列表，你创建了一个使用青金石和玻璃的进度条。通过元组，你学到了设置`x`、`y`和`z`变量的更快捷方式。字典让你存储你建造的物体的坐标，然后通过输入它们的名字传送到这些物体。
- en: In [Chapter 10](ch10.html#ch10), you’ll further develop your knowledge of lists
    by learning about `for` loops. You’ll create some very cool programs, including
    one that you can use to duplicate items you’ve built.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](ch10.html#ch10)中，你将通过学习`for`循环，进一步发展你对列表的理解。你将创建一些非常酷的程序，包括一个可以用来复制你所建造的物品的程序。
