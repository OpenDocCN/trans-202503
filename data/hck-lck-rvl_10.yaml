- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">AN
    INTRODUCTION TO PYTHON</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">Python
    入门</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: The skills you’ve learned in the last few chapters are instrumental for investigating
    leaked datasets, but having basic programming knowledge is even more powerful.
    Using Python or other programming languages, you can give your computer precise
    instructions for performing tasks that existing tools or shell scripts don’t allow.
    For example, you could write a Python script that scours a million pieces of video
    metadata to determine where the videos were filmed. In my experience, Python is
    also simpler, easier to understand, and less error-prone than shell scripts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你在前几章中学到的技能对于调查泄漏的数据集非常有用，但拥有基本的编程知识更为强大。通过使用 Python 或其他编程语言，你可以给计算机下达精确的指令，执行现有工具或
    Shell 脚本无法完成的任务。例如，你可以编写一个 Python 脚本，搜索一百万条视频元数据，确定视频拍摄的地点。根据我的经验，Python 比 Shell
    脚本更简单、更易理解，且错误更少。
- en: This chapter provides a crash course on the fundamentals of Python programming.
    You’ll learn to write and execute Python scripts and use the interactive Python
    interpreter. You’ll also use Python to do math, define variables, work with strings
    and Boolean logic, loop through lists of items, and use functions. Future chapters
    rely on your understanding of these basic skills.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了 Python 编程基础的速成课程。你将学习编写和执行 Python 脚本，并使用交互式 Python 解释器。你还将使用 Python 做数学运算、定义变量、处理字符串和布尔逻辑、循环遍历列表中的项，并使用函数。未来的章节将依赖于你对这些基础技能的理解。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 7-1: Install Python</samp>'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 7-1：安装 Python</samp>
- en: Some operating systems, including most versions of Linux and macOS, come with
    Python preinstalled, and it’s common to have multiple versions of Python installed
    at once. This book uses Python 3\. After you follow the Python installation instructions
    for your operating system in this exercise, you should be able to run Python scripts
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">python3</samp> (for Linux
    and Mac) or <samp class="SANS_TheSansMonoCd_W5Regular_11">python</samp> (for Windows)
    command.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作系统，包括大多数版本的 Linux 和 macOS，预装了 Python，并且通常会安装多个版本的 Python。本书使用 Python 3。在本练习中，根据你的操作系统按照
    Python 安装说明进行操作后，你应该能够使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">python3</samp>（适用于
    Linux 和 Mac）或 <samp class="SANS_TheSansMonoCd_W5Regular_11">python</samp>（适用于
    Windows）命令运行 Python 脚本。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Windows</samp>
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Windows</samp>
- en: Download and install the latest version of Python 3 for Windows from [*https://<wbr>www<wbr>.python<wbr>.org*](https://www.python.org).
    During installation, check the box **Add Python 3.*****x*** **to PATH** (where
    **3.*****x*** is the latest Python 3 version), which allows you to run the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">python</samp> command in PowerShell without
    using the Python program’s absolute path.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [*https://<wbr>www<wbr>.python<wbr>.org*](https://www.python.org) 下载并安装最新版本的
    Python 3（适用于 Windows）。在安装过程中，勾选 **Add Python 3.*****x*** **to PATH**（其中 **3.*****x***
    是最新的 Python 3 版本），这将允许你在 PowerShell 中运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">python</samp>
    命令，而无需使用 Python 程序的绝对路径。
- en: Wherever this chapter instructs you to open a terminal, use PowerShell instead
    of an Ubuntu terminal. You can also learn to use Python in Ubuntu with WSL by
    following this chapter’s Linux instructions, but running Python directly in Windows
    makes reading and writing data on your Windows-formatted USB disk much faster.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要求你打开终端时，请使用 PowerShell 而不是 Ubuntu 终端。你也可以通过遵循本章中的 Linux 指南，在 Ubuntu 中使用 WSL
    学习 Python，但直接在 Windows 中运行 Python 可以更快地读取和写入 Windows 格式的 USB 磁盘数据。
- en: Windows users should replace all instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">python3</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">python</samp> when running
    the example code in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 用户在运行本章中的示例代码时，应将所有的 <samp class="SANS_TheSansMonoCd_W5Regular_11">python3</samp>
    替换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">python</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Linux</samp>
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Linux</samp>
- en: 'Open a terminal and make sure the <samp class="SANS_TheSansMonoCd_W5Regular_11">python3</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">python3-pip</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">python3-venv</samp>
    packages are installed, using this <samp class="SANS_TheSansMonoCd_W5Regular_11">apt</samp>
    command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并使用此 <samp class="SANS_TheSansMonoCd_W5Regular_11">apt</samp> 命令确保已安装 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">python3</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">python3-pip</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">python3-venv</samp> 软件包：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command either installs the latest version of Python 3 available in the
    Ubuntu repositories (as well as a few related packages you’ll need for this chapter)
    or does nothing if the packages are already installed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会安装 Ubuntu 软件库中可用的最新版本 Python 3（以及本章中需要的其他相关软件包），或者如果这些软件包已安装，则不会执行任何操作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">macOS</samp>
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">macOS</samp>
- en: 'Open a terminal and run the following Homebrew command to make sure <samp class="SANS_TheSansMonoCd_W5Regular_11">python3</samp>
    is installed:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并运行以下 Homebrew 命令以确保已安装 <samp class="SANS_TheSansMonoCd_W5Regular_11">python3</samp>：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command either installs the latest version of Python 3 available in Homebrew
    or does nothing if it’s already installed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会安装 Homebrew 中可用的最新版本 Python 3，或者如果已经安装，则不会执行任何操作。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 7-2: Write Your First Python
    Script</samp>'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 7-2：编写你的第一个 Python 脚本</samp>
- en: Now that you’ve downloaded Python, you’ll write and run a simple Python script
    that displays some text in your terminal.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经下载了 Python，接下来你将编写并运行一个简单的 Python 脚本，在终端中显示一些文本。
- en: In your text editor, create a new file called *exercise-7-2.py* (all Python
    scripts end in *.py*). The first time you open a Python script in VS Code, it
    asks if you want to install the Python extension. I recommend doing so in order
    to enable VS Code to make suggestions as you’re typing. The extension also has
    various features for highlighting syntax errors and helping you format your code
    nicely.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中，创建一个名为 *exercise-7-2.py* 的新文件（所有 Python 脚本以 *.py* 结尾）。第一次在 VS Code 中打开
    Python 脚本时，它会询问你是否要安装 Python 扩展。我建议安装该扩展，以便在输入时启用 VS Code 提供建议。该扩展还具有高亮语法错误和帮助你格式化代码等功能。
- en: 'Enter the following code (or copy and paste it from [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-7<wbr>/exercise<wbr>-7<wbr>-2<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-7/exercise-7-2.py)),
    then save the file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下代码（或从 [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-7<wbr>/exercise<wbr>-7<wbr>-2<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-7/exercise-7-2.py)
    复制并粘贴），然后保存文件：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As with shell scripts, Python scripts run instructions one line at a time, starting
    at the top. When you run this code, <samp class="SANS_TheSansMonoCd_W5Regular_11">print("hacks")</samp>
    calls a function called <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    and passes the string <samp class="SANS_TheSansMonoCd_W5Regular_11">hacks</samp>
    into it, displaying <samp class="SANS_TheSansMonoCd_W5Regular_11">hacks</samp>
    in your terminal window. The second line similarly displays <samp class="SANS_TheSansMonoCd_W5Regular_11">leaks</samp>.
    (I’ll explain strings in greater detail in the “Python Basics” section on page
    172, and functions in the “Functions” section on page 192.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与 shell 脚本一样，Python 脚本逐行执行指令，从顶部开始。当你运行这段代码时，<samp class="SANS_TheSansMonoCd_W5Regular_11">print("hacks")</samp>
    调用了一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> 的函数，并将字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">hacks</samp> 传递给它，在终端窗口中显示 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">hacks</samp>。第二行同样会显示 <samp class="SANS_TheSansMonoCd_W5Regular_11">leaks</samp>。（我将在第172页的《Python基础》一节中更详细地解释字符串，第192页的《函数》一节中解释函数。）
- en: 'Next, the script defines a variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">revelations</samp>
    and sets its value to the uppercase version of the string <samp class="SANS_TheSansMonoCd_W5Regular_11">revelations</samp>.
    To find the uppercase version of that string, the program calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">upper()</samp>
    method, which is a type of function. The final line then displays what’s stored
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">revelations</samp> variable:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">REVELATIONS</samp>.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，脚本定义了一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">revelations</samp>
    的变量，并将其值设置为字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">revelations</samp>
    的大写版本。为了获取该字符串的大写版本，程序调用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">upper()</samp>
    方法，这是一种函数类型。最后一行则显示了存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">revelations</samp>
    变量中的内容： <samp class="SANS_TheSansMonoCd_W5Regular_11">REVELATIONS</samp>。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*I have fond memories of retyping snippets of code from books. When I was a
    teenager, I taught myself web and video game development by reading programming
    books and typing the code samples I found into my own editor. I always found that
    actually retyping the code, rather than copying and pasting it, helped make the
    concepts stick, so I recommend doing that for the exercises in this book.*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*我对重新输入书中的代码片段有着美好的记忆。当我还是青少年时，我通过阅读编程书籍并将其中的代码示例输入到我自己的编辑器中，自己学习了网页和视频游戏开发。我发现，真正重新输入代码，而不是直接复制粘贴，能帮助我更好地理解概念，所以我建议你也这样做，完成本书中的练习。*'
- en: 'In a terminal, change to your *exercises* folder and run the script you just
    created with the following command (Windows users, remember to replace <samp class="SANS_TheSansMonoCd_W5Regular_11">python3</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">python</samp>):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，切换到你的 *exercises* 文件夹，并运行你刚刚创建的脚本，使用以下命令（Windows 用户记得将 <samp class="SANS_TheSansMonoCd_W5Regular_11">python3</samp>
    替换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">python</samp>）：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The argument in this command is the path to the script that you want to run,
    *exercise-7-2.py*. You should get the following output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令中的参数是你要运行的脚本的路径，*exercise-7-2.py*。你应该得到如下输出：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Try making the following changes to your script, running it after each change
    to see the results:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试对你的脚本进行以下更改，并在每次更改后运行脚本查看结果：
- en: Change the text in the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    functions.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改 <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> 函数中的文本。
- en: Add new <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> functions
    to display more text.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> 函数来显示更多文本。
- en: Use the string methods <samp class="SANS_TheSansMonoCd_W5Regular_11">lower()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">capitalize()</samp> instead
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">upper()</samp>.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字符串方法 <samp class="SANS_TheSansMonoCd_W5Regular_11">lower()</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">capitalize()</samp> 来代替 <samp class="SANS_TheSansMonoCd_W5Regular_11">upper()</samp>。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Python Basics</samp>
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Python 基础</samp>
- en: In this section, you’ll learn to write code in the interactive Python interpreter,
    comment your code, start doing simple math in Python, and use strings and lists.
    This gentle introduction to Python syntax will let you quickly try out some code
    on your own, before you dive into more advanced topics.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何在交互式 Python 解释器中编写代码，如何注释代码，如何在 Python 中做简单的数学运算，以及如何使用字符串和列表。这本书将通过对
    Python 语法的温和介绍，让你在深入学习更高级的内容之前，能迅速开始动手尝试代码。
- en: As you read, don’t be shy about searching online for answers to any Python questions
    you might have beyond what this book covers. I frequently find solutions to Python
    problems on websites like Stack Overflow, a forum where people can ask technical
    questions and others can answer them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读时，不要害羞，可以上网查找关于 Python 的问题，特别是那些本书没有覆盖的部分。我经常在像 Stack Overflow 这样的网站上找到解决
    Python 问题的方法，Stack Overflow 是一个论坛，大家可以在上面提问技术问题，其他人则可以回答。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Interactive Python
    Interpreter</samp>
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">交互式 Python 解释器</samp>
- en: 'The *Python interpreter* is a command line program that lets you run Python
    code in real time, without writing scripts first, allowing you to quickly test
    commands. To open the Python interpreter, you run the <samp class="SANS_TheSansMonoCd_W5Regular_11">python3</samp>
    command without any arguments, like so:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python 解释器* 是一个命令行程序，它允许你实时运行 Python 代码，无需先编写脚本，从而可以快速测试命令。要打开 Python 解释器，你只需运行
    <samp class="SANS_TheSansMonoCd_W5Regular_11">python3</samp> 命令，无需任何参数，如下所示：'
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The interpreter starts by telling you exactly which version of Python you’re
    using. Similar to a command line interface, it gives you the prompt <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp>
    and waits for you to enter a Python command.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器首先会告诉你正在使用哪个版本的 Python。类似于命令行界面，它会显示提示符 <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp>，并等待你输入
    Python 命令。
- en: 'Run the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Entering <samp class="SANS_TheSansMonoCd_W5Regular_11">print("Hello World!")</samp>
    and pressing ENTER should immediately run your code, displaying <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello
    World!</samp> on the next line. Exit the interpreter and return to the shell by
    running <samp class="SANS_TheSansMonoCd_W7Bold_B_11">exit()</samp> or pressing
    CTRL-D.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 <samp class="SANS_TheSansMonoCd_W5Regular_11">print("Hello World!")</samp>
    并按下 ENTER 键，应该会立即运行你的代码，并在下一行显示 <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello
    World!</samp>。通过运行 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">exit()</samp>
    或按下 CTRL-D 退出解释器并返回到 shell。
- en: In the remainder of this book, if my examples include the <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp>
    prompt, that means they’re running in the Python interpreter. Run the same code
    in your own interpreter as you follow along.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后续章节中，如果我的示例中包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp>
    提示符，表示它们正在 Python 解释器中运行。请在自己的解释器中运行相同的代码，并跟着一起学习。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Comments</samp>
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">注释</samp>
- en: 'Writing code can be confusing even to experienced programmers, so it’s always
    a good idea to *comment* your code: add inline notes to yourself or to others
    who might read your program. If you describe the purpose of a specific portion
    of code in plain English (or whatever language you speak), whoever looks at this
    code in the future can understand the gist of what it’s doing at a glance.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码对于即使是经验丰富的程序员来说也可能感到困惑，因此，*注释*代码总是个好主意：为自己或其他可能阅读你程序的人添加内联注释。如果你用简单的英语（或你所说的任何语言）描述代码特定部分的目的，那么将来查看这段代码的人就能一目了然地理解它的作用。
- en: 'If a line of code starts with a hash mark (<samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp>),
    the whole line is a comment. You can also add a hash mark after some code, followed
    by your comment. For example, run the following lines of code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一行代码以井号（<samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp>）开头，则整行都是注释。你也可以在某些代码之后添加井号，并写上注释。例如，运行以下几行代码：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is exactly the same as comments in shell scripting, which you learned about
    in [Chapter 3](chapter3.xhtml). Python ignores comments, since they’re intended
    for humans.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这与你在[第三章](chapter3.xhtml)中学习到的 shell 脚本中的注释完全相同。Python 会忽略注释，因为它们是给人看的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Math with Python</samp>
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">在 Python 中的数学运算</samp>
- en: 'Computers, which are technically complicated calculators, are great at doing
    math. It might not be immediately apparent, but investigating datasets means constantly
    dealing with basic math: calculating disk space, counting files, searching for
    keywords, and sorting lists. Here’s how a few basic mathematical operations work
    in Python:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机，作为技术上复杂的计算器，非常擅长进行数学运算。虽然这可能并不立刻显现出来，但研究数据集意味着不断进行基本的数学操作：计算磁盘空间、统计文件数量、搜索关键词以及排序列表。以下是几个基本数学运算在
    Python 中的实现方法：
- en: '**Operators**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: 'The arithmetic operators for addition (+), subtraction (−), multiplication
    (×), and division (/) are mostly the same in Python: <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>,
    with an asterisk <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> for multiplication.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 加法（+）、减法（−）、乘法（×）和除法（/）的算术运算符在 Python 中大致相同：<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>，乘法则使用星号
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>。
- en: '**Variables**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量**'
- en: In math, a variable is a placeholder, normally a letter like *x*. Variables
    in math often represent something unknown and it’s your job to solve for it, but
    Python variables are never unknown—they always have a value. Name your Python
    variables something descriptive like <samp class="SANS_TheSansMonoCd_W5Regular_11">price</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">number_of_retweets</samp> rather
    than single letters without clear meanings. Variables in Python can represent
    much more than just numbers, as you’ll see later in this chapter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，变量是占位符，通常是像 *x* 这样的字母。数学中的变量通常代表未知数，你的任务是解出它，但 Python 中的变量永远不是未知的——它们始终有一个值。给你的
    Python 变量起一个有描述性的名字，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">price</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">number_of_retweets</samp>，而不是没有明确意义的单个字母。正如你在本章后面看到的，Python
    中的变量不仅仅代表数字。
- en: '**Expressions**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式**'
- en: 'An expression is a bit like a sentence made up of numbers, variables, and operators.
    For example, here are a few expressions:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式有点像由数字、变量和运算符组成的句子。例如，以下是一些表达式：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Like sentences, expressions need to have the correct syntax. Just like “potato
    the inside” isn’t a valid sentence, 1 1 + isn’t a valid expression. Enter the
    following expressions in the Python interpreter to see how it evaluates them:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 像句子一样，表达式需要有正确的语法。就像“potato the inside”不是一个有效的句子，1 1 + 也不是一个有效的表达式。你可以在 Python
    解释器中输入以下表达式，看看它如何评估这些表达式：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Just like a calculator, Python respects the order of operations. It also supports
    using parentheses:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 就像计算器一样，Python 遵循运算顺序。它还支持使用括号：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As in the rest of math, Python won’t allow you to divide by zero:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他数学运算一样，Python 不允许你除以零：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You define a variable in Python by saving a value inside that variable with
    the equal sign (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>). Try defining
    <samp class="SANS_TheSansMonoCd_W5Regular_11">price</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">sales_tax</samp>
    variables and then using them in an expression:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你通过将一个值赋给变量来定义它，使用等号 (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>)。尝试定义
    <samp class="SANS_TheSansMonoCd_W5Regular_11">price</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">sales_tax</samp>
    变量，然后在表达式中使用它们：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can’t use variables that you haven’t yet defined. For example, if you use
    an undefined variable <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> in
    an expression, you’ll get an error:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能使用尚未定义的变量。例如，如果你在表达式中使用一个未定义的变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>，你会遇到错误：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Instead of just setting a variable equal to some value, you’ll often want to
    modify its existing value by a certain amount. For example, if you’re keeping
    track of the total price of items in a shopping cart in the <samp class="SANS_TheSansMonoCd_W5Regular_11">total</samp>
    variable and want to add 10 dollars to that total, you would define the variable
    like so:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅仅是将一个变量赋值为某个值，通常你会希望通过某个量来修改其现有值。例如，如果你在 <samp class="SANS_TheSansMonoCd_W5Regular_11">total</samp>
    变量中记录购物车中商品的总价格，并希望在总额上加 10 美元，你可以这样定义这个变量：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> operator performs
    the same operation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> 运算符执行相同的操作：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> operator adds the
    number on the right to the variable on the left. The Python operators <samp class="SANS_TheSansMonoCd_W5Regular_11">-=</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*=</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">/=</samp>
    work the same way. In your Python interpreter, define a variable, then try changing
    its value using these operators.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> 运算符将右侧的数字加到左侧的变量上。Python
    的运算符 <samp class="SANS_TheSansMonoCd_W5Regular_11">-=</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">*=</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">/=</samp> 以相同的方式工作。在你的 Python
    解释器中，定义一个变量，然后尝试使用这些运算符修改它的值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Strings</samp>
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">字符串</samp>
- en: 'A *string* is a sequence of characters. Any time you need to load, modify,
    or display text, you store it in a string. If you load the contents of a text
    file into a variable in Python (for example, a 5MB EML file that includes attachments),
    that’s a string. But strings are also often very short: in Exercise 7-2, you used
    the strings <samp class="SANS_TheSansMonoCd_W5Regular_11">"hacks"</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">"leaks"</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">"revelations"</samp>.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串* 是一系列字符。任何时候你需要加载、修改或显示文本时，都可以将其存储在字符串中。如果你将一个文本文件的内容加载到 Python 变量中（例如，包含附件的
    5MB EML 文件），那就是一个字符串。但字符串通常也很短：在练习 7-2 中，你使用了字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">"hacks"</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">"leaks"</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">"revelations"</samp>。'
- en: 'In Python, strings must be enclosed in either single quotes (<samp class="SANS_TheSansMonoCd_W5Regular_11">''</samp>)
    or double quotes (<samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp>). Run
    the following examples, which demonstrate how to use each type of quote. Here
    is a string with double quotes:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，字符串必须用单引号（<samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp>）或双引号（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">"</samp>）括起来。运行以下示例，演示如何使用每种类型的引号。这里是一个使用双引号的字符串：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is the same string with single quotes:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用单引号的相同字符串：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Use double quotes if you have single quotes within the string:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串中包含单引号，可以使用双引号：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Use single quotes if you have double quotes within the string:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串中包含双引号，可以使用单引号：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Some of the same techniques you learned in [Chapter 3](chapter3.xhtml) to work
    with strings in your shell also apply to strings in Python. If your string uses
    double quotes, you can escape them like so:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](chapter3.xhtml)中你学到的处理字符串的技巧，同样适用于 Python 中的字符串。如果你的字符串使用了双引号，可以像这样转义它们：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can similarly escape single quotes in a single-quote string:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在单引号字符串中使用转义单引号：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Like numbers, strings can be stored in variables. Run the following code to
    define <samp class="SANS_TheSansMonoCd_W5Regular_11">first_name</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">last_name</samp> variables, replacing
    my name with yours:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 和数字一样，字符串也可以存储在变量中。运行以下代码来定义 <samp class="SANS_TheSansMonoCd_W5Regular_11">first_name</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">last_name</samp> 变量，将我的名字替换为你的名字：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In Python, *f-strings* are strings that can contain variables. To use an f-string,
    put the letter <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> before the
    quotes, then put variable names in braces (<samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>and}).
    For example, run the following commands to display the values of the variables
    you just defined:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，*f-strings* 是包含变量的字符串。要使用 f-string，在引号前加上字母 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>，然后将变量名放在大括号中（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">{</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>）。例如，运行以下命令来显示你刚刚定义的变量的值：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Place expressions inside f-strings in order to evaluate them:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将表达式放入 f-strings 中进行求值：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Python will evaluate the expression for you, in this case <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>,
    and just print the result, which is <samp class="SANS_TheSansMonoCd_W5Regular_11">15</samp>.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Python 会为你计算表达式，在此情况下为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>，并直接打印结果，即
    <samp class="SANS_TheSansMonoCd_W5Regular_11">15</samp>。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 7-3: Write a Python Script
    with Variables, Math, and Strings</samp>'
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 7-3：编写一个包含变量、数学和字符串的 Python 脚本</samp>
- en: 'In this exercise, you’ll practice the concepts you’ve learned so far by writing
    a simple Python script that uses variables and a few basic math expressions and
    prints some strings. The script calculates how old a person is in months, days,
    hours, minutes, and seconds, given their name and an age (in years), and then
    displays this information. In your text editor, create a new file called *exercise-7-3.py*
    and define these two variables:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将通过编写一个简单的 Python 脚本来练习迄今为止学到的概念，该脚本使用变量和一些基本的数学表达式并打印一些字符串。该脚本根据姓名和年龄（以年为单位）计算一个人以月、日、小时、分钟和秒为单位的年龄，然后显示这些信息。在文本编辑器中，创建一个名为
    *exercise-7-3.py* 的新文件，并定义这两个变量：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Replace the values of <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">age_years</samp> with your own
    name and age.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将 <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">age_years</samp>
    的值替换为你自己的姓名和年龄。
- en: 'Next, define some more variables that represent age in different units: months,
    days, hours, minutes, and seconds. Start with months:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一些表示不同单位年龄的变量：月、日、小时、分钟和秒。先从月开始：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add a days variable:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个天数变量：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, define variables for hour, minutes, and seconds:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，定义小时、分钟和秒的变量：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that you’ve defined the variables, you can display them to the user. Since
    the numbers in this exercise are going to get big, you’ll include commas to make
    them easier to read. For example, run this code in the interpreter to display
    the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">number</samp> with
    commas using an f-string, adding <samp class="SANS_TheSansMonoCd_W5Regular_11">:,</samp>
    after the variable name within the braces:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了变量，可以将它们显示给用户。由于本练习中的数字会变得很大，你将包括逗号以使其更容易阅读。例如，在解释器中运行以下代码，以使用 f-string
    显示带有逗号的 <samp class="SANS_TheSansMonoCd_W5Regular_11">number</samp> 变量，方法是在变量名的花括号内添加
    <samp class="SANS_TheSansMonoCd_W5Regular_11">:,</samp>：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Back in the Python script, add code to display all of the values, like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 Python 脚本中，添加代码以显示所有这些值，像这样：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This code uses <samp class="SANS_TheSansMonoCd_W5Regular_11">{name}</samp> to
    display the value of the name variable. That variable is a string, so it doesn’t
    make sense to try to separate it with commas. The rest of the variables are numbers,
    though, so the code includes <samp class="SANS_TheSansMonoCd_W5Regular_11">:,</samp>
    inside the braces for all of them to include commas in the output. (The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">age_years</samp> values don’t need commas,
    unless you happen to be older than 1,000, but it doesn’t hurt to use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">:,</samp> syntax—it adds a comma only
    if one is needed.)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">{name}</samp> 来显示姓名变量的值。该变量是一个字符串，因此尝试用逗号分隔它是没有意义的。然而，其它变量是数字，所以代码在所有这些变量的花括号内包括了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">:,</samp>，以便在输出中加入逗号。（<samp class="SANS_TheSansMonoCd_W5Regular_11">age_years</samp>
    的值不需要逗号，除非你超过了1,000岁，但使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">:,</samp>
    语法也没有坏处——它只会在需要时添加逗号。）
- en: 'Save the file in your text editor. (A complete copy of the script is available
    at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-7<wbr>/exercise<wbr>-7<wbr>-3<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-7/exercise-7-3.py).)
    In a terminal, change to your *exercises* folder for this exercise and run the
    script. Here’s what happens when I do so:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中保存文件。（脚本的完整副本可在[*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-7<wbr>/exercise<wbr>-7<wbr>-3<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-7/exercise-7-3.py)找到。）在终端中，切换到此练习的*exercises*文件夹并运行脚本。以下是我运行时的结果：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When you run the script with your name and age, try changing the age and running
    it again to see how the numbers change.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行带有姓名和年龄的脚本时，尝试更改年龄并重新运行，看看数字是如何变化的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Lists and Loops</samp>
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">列表和循环</samp>
- en: You’ll often need to manage lists when investigating datasets. For example,
    you might work with lists of filenames or rows in a spreadsheet. In this section,
    you’ll learn how to store lists as variables and loop through those lists in order
    to run the same code for each list item. You did something similar in [Chapter
    4](chapter4.xhtml) with <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops in the shell, but this time you’ll be working in Python.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究数据集时，你经常需要管理列表。例如，你可能会处理文件名的列表或电子表格中的行。在这一节中，你将学习如何将列表存储为变量，并循环遍历这些列表，以便对每个列表项运行相同的代码。在[第4章](chapter4.xhtml)中，你已经在
    shell 中使用过<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环，今天你将使用 Python
    来处理。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining and Printing
    Lists</samp>
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">定义和打印列表</samp>
- en: 'In Python, lists are defined with brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">[</samp>and]),
    with each item in the list separated by commas (<samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>).
    You might have a list of numbers:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，列表是用括号（<samp class="SANS_TheSansMonoCd_W5Regular_11">[</samp>和]）定义的，列表中的每一项由逗号（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">,</samp>）分隔。你可能会有一个数字列表：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Or of strings:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 或者是字符串：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Or an empty list:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 或者是一个空列表：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Just as variables can contain numbers or strings, they can also contain lists.
    Use this line of code to store a list of letters in the Hebrew alphabet, spelled
    out using Latin characters, in the <samp class="SANS_TheSansMonoCd_W5Regular_11">hebrew_letters</samp>
    variable:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就像变量可以包含数字或字符串一样，它们也可以包含列表。使用以下代码行将希伯来字母表的字母列表（使用拉丁字母拼写）存储在<samp class="SANS_TheSansMonoCd_W5Regular_11">hebrew_letters</samp>变量中：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now use the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function
    to display the items in the <samp class="SANS_TheSansMonoCd_W5Regular_11">hebrew_letters</samp>
    variable:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用<samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>函数来显示<samp class="SANS_TheSansMonoCd_W5Regular_11">hebrew_letters</samp>变量中的项：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can make long lists easier to read by entering each item in the list on
    its own line, indented, like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将列表中的每一项单独输入一行并缩进，使长列表更易于阅读，如下所示：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Each item in a list has an *index*, a number that represents where in the list
    that item is located. The index of the first item is 0, the second is 1, the third
    is 2, and so on. To select a list item, you append brackets with the item’s index
    to the end of the list. For example, to select the first letter in the <samp class="SANS_TheSansMonoCd_W5Regular_11">hebrew_letters</samp>
    list, use <samp class="SANS_TheSansMonoCd_W5Regular_11">hebrew_letters[0]</samp>:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每一项都有一个*索引*，即表示该项在列表中位置的数字。第一个项的索引是 0，第二个是 1，第三个是 2，依此类推。要选择列表项，你需要将该项的索引放入括号中并附加到列表的末尾。例如，要选择<samp
    class="SANS_TheSansMonoCd_W5Regular_11">hebrew_letters</samp>列表中的第一个字母，可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">hebrew_letters[0]</samp>：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first line of code uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    function to display the item from the <samp class="SANS_TheSansMonoCd_W5Regular_11">hebrew_letters</samp>
    list at index 0 (<samp class="SANS_TheSansMonoCd_W5Regular_11">aleph</samp>),
    and the second line displays the item at index 1 (<samp class="SANS_TheSansMonoCd_W5Regular_11">bet</samp>).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代码使用<samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>函数显示<samp
    class="SANS_TheSansMonoCd_W5Regular_11">hebrew_letters</samp>列表中索引为 0 的项（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">aleph</samp>），第二行显示索引为 1 的项（<samp class="SANS_TheSansMonoCd_W5Regular_11">bet</samp>）。
- en: 'Now use negative numbers to select items starting from the end of the list,
    like so:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用负数来从列表的末尾开始选择项目，如下所示：
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp>
    function to count the number of items in a list. For example, run the following
    code to get the number of items in the <samp class="SANS_TheSansMonoCd_W5Regular_11">hebrew_letters</samp>
    list:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp>函数来计算列表中项的数量。例如，运行以下代码来获取<samp
    class="SANS_TheSansMonoCd_W5Regular_11">hebrew_letters</samp>列表中的项数：
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This code uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    function to display the output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp>
    function. You could get the same result by storing the output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp>
    function in a variable:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用<samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>函数显示<samp
    class="SANS_TheSansMonoCd_W5Regular_11">len()</samp>函数的输出。你也可以将<samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp>函数的输出存储到一个变量中，以得到相同的结果：
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first line of code runs <samp class="SANS_TheSansMonoCd_W5Regular_11">len(hebrew_letters)</samp>
    and stores the result in the <samp class="SANS_TheSansMonoCd_W5Regular_11">length_of_hebrew_alphabet</samp>
    variable. The second line uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    function to display that result.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代码运行<samp class="SANS_TheSansMonoCd_W5Regular_11">len(hebrew_letters)</samp>并将结果存储在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">length_of_hebrew_alphabet</samp>变量中。第二行使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>函数显示该结果。
- en: 'You don’t have to store a list in a variable to select items from it. For example,
    run this code to display the second item (at index 1) in the list <samp class="SANS_TheSansMonoCd_W5Regular_11">[1,2,3]</samp>:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必将列表存储在变量中就能从中选择项。例如，运行这段代码来显示列表<samp class="SANS_TheSansMonoCd_W5Regular_11">[1,2,3]</samp>中的第二项（索引为1）：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">append()</samp> method lets
    you add items to lists. For example, run the following code to add a new color
    to a list of favorites:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">append()</samp>方法允许你向列表中添加项目。例如，运行以下代码将一个新颜色添加到收藏列表中：
- en: '[PRE43]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This code defines the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">favorite_colors</samp>
    as a list of strings containing <samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">blue</samp>.
    It then adds another string, <samp class="SANS_TheSansMonoCd_W5Regular_11">black</samp>,
    to the list by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">append()</samp>
    method, before finally displaying the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">favorite_colors</samp>
    variable, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将变量<samp class="SANS_TheSansMonoCd_W5Regular_11">favorite_colors</samp>定义为一个包含<samp
    class="SANS_TheSansMonoCd_W5Regular_11">red</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">green</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">blue</samp>的字符串列表。然后，它通过使用<samp class="SANS_TheSansMonoCd_W5Regular_11">append()</samp>方法将另一个字符串<samp
    class="SANS_TheSansMonoCd_W5Regular_11">black</samp>添加到列表中，最后使用<samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>函数显示<samp
    class="SANS_TheSansMonoCd_W5Regular_11">favorite_colors</samp>变量的值。
- en: When writing code that analyzes datasets, you’ll often create an empty list
    and then append items to that list to make the data easier to work with. For example,
    you’ll learn in [Chapter 13](chapter13.xhtml) about the code I wrote while investigating
    America’s Frontline Doctors, an anti-vaccine group. To properly analyze a dataset
    of hundreds of thousands of files containing patient information, I wrote code
    that created an empty list, opened each file, and appended the pertinent patient
    data to that list.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写分析数据集的代码时，你通常会创建一个空列表，然后将项目添加到该列表中，以便更容易处理数据。例如，在[第13章](chapter13.xhtml)中，你将了解到我在调查美国前线医生（一家反疫苗组织）时编写的代码。为了正确分析包含患者信息的数十万个文件的数据集，我编写了代码来创建一个空列表，打开每个文件，并将相关的患者数据附加到该列表中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running for Loops</samp>
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">运行for循环</samp>
- en: 'In [Chapter 4](chapter4.xhtml), you used a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to unzip each BlueLeaks ZIP file. Python also has <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops, and they work the same way they do in shell scripting: by running a snippet
    of code, called a *block*, on each item in a list. A <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop has the following syntax:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](chapter4.xhtml)中，你使用了一个<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环来解压每个BlueLeaks
    ZIP文件。Python也有<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环，它们的工作方式与Shell脚本中的for循环相同：通过对列表中的每一项运行一个代码片段（称为*代码块*）。一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环有以下语法：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This syntax is followed by a block of indented code. Once you choose a new variable
    to define in <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">variable_name</samp>,
    you can use it in your code block.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法后面跟着一个缩进的代码块。一旦你选择了一个新的变量名<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">variable_name</samp>，你就可以在代码块中使用它。
- en: 'For example, run the following code to loop through the <samp class="SANS_TheSansMonoCd_W5Regular_11">hebrew_letters</samp>
    list, store each item in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">letter</samp>,
    and then display that item:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，运行以下代码循环遍历<samp class="SANS_TheSansMonoCd_W5Regular_11">hebrew_letters</samp>列表，将每个项存储在变量<samp
    class="SANS_TheSansMonoCd_W5Regular_11">letter</samp>中，然后显示该项：
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After you enter the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, which ends in a colon (<samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp>),
    the Python interpreter changes the prompt from <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">…</samp> and waits for you to
    enter the code block that will run for each item. Indent every line in your block
    with the same number of spaces, then end your block with a blank line. In this
    example, the code block that runs is just one line: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(letter)</samp>.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在你输入 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环后，它以冒号（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">:</samp>）结束，Python 解释器会将提示符从 <samp class="SANS_TheSansMonoCd_W5Regular_11">>>></samp>
    改为 <samp class="SANS_TheSansMonoCd_W5Regular_11">…</samp>，并等待你输入将在每个项上运行的代码块。你需要在代码块的每一行前缩进相同数量的空格，然后用一个空行结束你的代码块。在这个例子中，运行的代码块只有一行：
    <samp class="SANS_TheSansMonoCd_W5Regular_11">print(letter)</samp>。
- en: 'The code should return the following output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 代码应该返回以下输出：
- en: '[PRE46]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop runs 22 times, once for each item in the list, and stores the item in the
    variable <samp class="SANS_TheSansMonoCd_W5Regular_11">letter</samp>. The first
    time it loops, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">letter</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph</samp>. The second time,
    the value is <samp class="SANS_TheSansMonoCd_W5Regular_11">bet</samp>, and so
    on.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环执行了 22 次，每次遍历列表中的每个项，并将项存储在变量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">letter</samp> 中。第一次循环时，<samp class="SANS_TheSansMonoCd_W5Regular_11">letter</samp>
    的值是 <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph</samp>。第二次时，值是 <samp class="SANS_TheSansMonoCd_W5Regular_11">bet</samp>，依此类推。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Indentation tells Python which lines of code are part of your code blocks.
    If some lines are indented with four spaces, but others with two or three spaces,
    your Python code won’t work. To keep things simple, I recommend always indenting
    with four spaces. When writing scripts in VS Code, you can indent multiple lines
    of code by selecting them with your mouse and then pressing* *TAB* *(which indents
    four spaces for you) or unindent by selecting a line and pressing* *SHIFT-TAB**.*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*缩进告诉 Python 哪些代码行是代码块的一部分。如果某些行用四个空格缩进，但其他行用两个或三个空格，Python 代码就会无法运行。为了保持简单，我建议总是使用四个空格进行缩进。当在
    VS Code 中编写脚本时，你可以通过鼠标选择多行代码，然后按* *TAB* *（它会为你缩进四个空格），或者按 *SHIFT-TAB* *取消缩进*。*'
- en: 'The following, slightly more complicated, example uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp>
    function to count not the number of items in a list but characters in a string:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个稍微复杂一点的例子，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp>
    函数来计算字符串中的字符数量，而不是列表中的项目数：
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This code tells you how many characters are used to spell the word for each
    Hebrew letter in the Latin alphabet.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会告诉你每个希伯来字母在拉丁字母中拼写该单词时使用了多少个字符。
- en: 'You can use <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops
    to loop through strings as well, since a string is essentially a list of characters:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环来遍历字符串，因为字符串本质上是字符的列表：
- en: '[PRE48]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can run a single <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop as many times as you need for the dataset you’re working on. For example,
    in [Chapter 9](chapter9.xhtml), you’ll write code that can open each of the hundreds
    of spreadsheets in the BlueLeaks dataset and uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to run your block of code on each row.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要运行一个单独的 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环，针对你正在处理的数据集。例如，在[第9章](chapter9.xhtml)中，你将编写代码来打开BlueLeaks数据集中的每个数百个电子表格，并使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环在每一行上运行你的代码块。
- en: In the next section, you’ll learn to make your programs more dynamic and useful
    by determining which blocks of code should run under which circumstances.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将学会通过确定哪些代码块在什么情况下运行，使你的程序更加动态和有用。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Control Flow</samp>
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">控制流</samp>
- en: Python scripts start at the top and run one line of code at a time, but they
    don’t always run these lines consecutively. In <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops, for example, the same block of code might run over and over again before
    the loop completes and the program continues to the next line. The order in which
    your lines of code run is your program’s *control flow*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Python脚本从顶部开始，逐行执行代码，但它们并不总是按顺序执行这些代码行。例如，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环中，同一段代码可能会反复执行，直到循环完成，程序才继续到下一行。代码执行的顺序就是你程序的 *控制流程*。
- en: As you start writing code, you’ll often alter the control flow by telling your
    computer to do different things in different situations. If you write a program
    that loops through a list of files in a dataset, for instance, you may want to
    run different code when the program reaches a PDF document than when it encounters
    an MP4 video.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始编写代码时，你会经常通过告诉计算机在不同情况下做不同的事情来改变控制流程。例如，如果你编写一个程序来遍历数据集中的文件列表，你可能希望在程序处理PDF文档时运行不同的代码，而不是遇到MP4视频时。
- en: This section teaches you how to run certain blocks of code under certain conditions.
    To do this, you’ll learn how to compare values, use <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements based on these comparisons, and express arbitrarily complicated conditions
    using Boolean logic, all of which allow you to control the flow of your program.
    You’ll need this sort of logic whenever you write code that searches a dataset
    for something specific and then responds according to what it finds.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将教你如何在特定条件下运行某些代码块。为此，你将学习如何比较值，基于这些比较使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    语句，并使用布尔逻辑表达任意复杂的条件，这一切都可以让你控制程序的流程。当你编写搜索数据集中特定内容的代码并根据找到的内容做出响应时，你将需要这种逻辑。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Comparison Operators</samp>
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">比较运算符</samp>
- en: 'As mentioned earlier in this chapter, expressions that use the arithmetic operators
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    generally evaluate to numbers: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, for example.
    Expressions in Python also use the following *comparison operators* to compare
    terms:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，使用算术运算符 <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> 的表达式通常会评估为数字：例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> 会评估为 <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>。Python中的表达式还使用以下
    *比较运算符* 来比较项：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11"><</samp> Less than
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11"><</samp> 小于
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11"><=</samp> Less than or equal to
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11"><=</samp> 小于或等于
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">></samp> Greater than
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">></samp> 大于
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">>=</samp> Greater than or equal
    to
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">>=</samp> 大于或等于
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">==</samp> Equal to (not to be confused
    with a single equal sign (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>),
    which defines a variable)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">==</samp> 等于（与单个等号（<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>）定义变量不同）
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">!=</samp> Not equal to
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">!=</samp> 不等于
- en: 'A *Boolean* is a type of variable that is either <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. Expressions that
    use comparison operators evaluate to Booleans instead of numbers, as in the following
    examples:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值*是一种变量类型，它的值要么是 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    要么是 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。使用比较运算符的表达式会评估为布尔值，而不是数字，如以下示例所示：'
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can use these same operators to compare strings, too. In Python, saying
    that one string is less than another means that the former comes before the latter
    in alphabetical order, as in the following examples:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用这些相同的运算符来比较字符串。在 Python 中，说一个字符串小于另一个字符串意味着前者在字母顺序中排在后者之前，如以下示例所示：
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Strings are case sensitive. If you don’t care about capitalization and want
    to just see whether the strings are made up of the same words, make them both
    lowercase before you compare them:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是区分大小写的。如果你不在意大小写，只想看看字符串是否由相同的单词组成，可以在比较之前将它们都转换为小写：
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This technique allows you to determine whether the data you’re evaluating fulfills
    a given condition. For example, in [Chapter 11](chapter11.xhtml), you’ll write
    code to analyze the metadata of over a million videos uploaded to the far-right
    social network Parler. Using comparison operators, you’ll determine which videos
    were filmed on January 6, 2021, in Washington, DC, during the insurrection after
    Trump lost the 2020 election.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这项技术使你能够判断正在评估的数据是否满足给定条件。例如，在 [第11章](chapter11.xhtml) 中，你将编写代码分析上传到极右翼社交网络
    Parler 的超过百万个视频的元数据。通过使用比较运算符，你将判断哪些视频是在 2021 年 1 月 6 日，在特朗普失去 2020 年大选后，华盛顿特区暴动期间拍摄的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">if Statements</samp>
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">if 语句</samp>
- en: You use <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements to
    tell your code to do something under certain conditions but not others. The syntax
    for an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">:</samp> followed by an indented block
    of code. If the expression evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    then the code block runs. If the expression evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    the code doesn’t run, and the flow moves on to the next line.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句来告诉代码在某些条件下执行某些操作，而在其他条件下不执行。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句的语法是 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">表达式</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp>，然后跟着一个缩进的代码块。如果表达式的结果为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，那么代码块就会执行。如果表达式的结果为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，代码就不会执行，流程将转到下一行。
- en: 'For example, run the following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，运行以下代码：
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This code sets the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">password</samp>
    variable to <samp class="SANS_TheSansMonoCd_W5Regular_11">letmein</samp>. That
    means the expression in the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement (<samp class="SANS_TheSansMonoCd_W5Regular_11">password</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">"letmein"</samp>)
    evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> and the
    code block runs, so it displays <samp class="SANS_TheSansMonoCd_W5Regular_11">ACCESS
    GRANTED</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Welcome</samp>.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将 <samp class="SANS_TheSansMonoCd_W5Regular_11">password</samp> 变量的值设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">letmein</samp>。这意味着 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    语句中的表达式（<samp class="SANS_TheSansMonoCd_W5Regular_11">password</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"letmein"</samp>）的结果为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，于是代码块被执行，显示
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ACCESS GRANTED</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Welcome</samp>。
- en: 'Now try including the wrong password in your <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试在你的 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句中包含错误的密码：
- en: '[PRE53]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This time, because you set the password to <samp class="SANS_TheSansMonoCd_W5Regular_11">"yourefired"</samp>,
    the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">password</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">"letmein"</samp>
    evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>, and Python
    doesn’t run the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement’s
    code block.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，由于你将密码设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">"yourefired"</samp>，表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">password</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"letmein"</samp> 的结果为 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，因此
    Python 不会执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句中的代码块。
- en: 'An <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement can optionally
    incorporate an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> block
    so that if the condition is true, one code block runs, and if it’s false, another
    block runs:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句可以选择性地包含一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">else</samp> 语句块，这样如果条件为真，则运行一个代码块；如果条件为假，则运行另一个代码块：
- en: '[PRE54]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You can also incorporate <samp class="SANS_TheSansMonoCd_W5Regular_11">elif</samp>
    blocks, short for “else if.” These let you make another comparison if the first
    comparison is false, as shown in [Listing 7-1](#list7-1).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以加入 <samp class="SANS_TheSansMonoCd_W5Regular_11">elif</samp> 语句块，它是“else
    if”的缩写。这样可以在第一次比较为假时进行另一次比较，正如 [Listing 7-1](#list7-1) 所示。
- en: '[PRE55]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-1: Comparing</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">if, elif, and else</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp>'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-1: 比较</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">if, elif, 和 else</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">语句</samp>'
- en: In this code, the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    evaluates the <samp class="SANS_TheSansMonoCd_W5Regular_11">password</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">"letmein"</samp>
    expression. If it evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    the code block runs and displays the <samp class="SANS_TheSansMonoCd_W5Regular_11">ACCESS
    GRANTED</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Welcome</samp>
    messages. If the expression evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    the program moves on to the <samp class="SANS_TheSansMonoCd_W5Regular_11">elif</samp>
    block, which evaluates the <samp class="SANS_TheSansMonoCd_W5Regular_11">password</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">"open
    sesame"</samp> expression. If that evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    it runs the block of code that displays <samp class="SANS_TheSansMonoCd_W5Regular_11">SECRET
    AREA ACCESS GRANTED</samp>. If it evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    the program moves on to the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    code block, which displays <samp class="SANS_TheSansMonoCd_W5Regular_11">ACCESS
    DENIED</samp>.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句评估 <samp class="SANS_TheSansMonoCd_W5Regular_11">password</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">"letmein"</samp>
    表达式。如果它的值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，代码块运行并显示
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ACCESS GRANTED</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Welcome</samp>
    消息。如果表达式的值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，程序将跳转到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">elif</samp> 语句块，它评估 <samp class="SANS_TheSansMonoCd_W5Regular_11">password</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">"open
    sesame"</samp> 表达式。如果该表达式的值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，则运行显示
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SECRET AREA ACCESS GRANTED</samp>
    的代码块。如果表达式的值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，程序将跳转到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> 代码块，显示 <samp class="SANS_TheSansMonoCd_W5Regular_11">ACCESS
    DENIED</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nested Code Blocks</samp>
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">嵌套代码块</samp>
- en: 'You can also accomplish the results of [Listing 7-1](#list7-1) with multiple
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements and no <samp
    class="SANS_TheSansMonoCd_W5Regular_11">elif</samp>, using *nested* code blocks,
    or indented blocks of code inside other indented blocks of code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过多个 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句并且不使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">elif</samp> 来实现 [Listing 7-1](#list7-1)
    的结果，使用*嵌套*的代码块，或者在其他缩进的代码块内嵌套缩进的代码块：
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This code is functionally the same as [Listing 7-1](#list7-1).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的功能与 [Listing 7-1](#list7-1) 相同。
- en: The more complicated your code, the more nested code blocks may come in handy.
    You might include <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops
    inside your <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    code blocks, or <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements
    inside <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops, or even
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops inside <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 代码越复杂，嵌套代码块可能越有用。你可能会在 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    语句的代码块中包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环，或者在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环中包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    语句，甚至在 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环中再嵌套 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环。
- en: 'You might prefer <samp class="SANS_TheSansMonoCd_W5Regular_11">elif</samp>
    statements to nested <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements
    purely for readability purposes: it’s easier to read and write code with 100 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">elif</samp> statements than code that’s
    indented 100 times because it has 100 nested <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 出于可读性考虑，你可能会更倾向于使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">elif</samp>
    语句，而不是嵌套的 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句：使用 100 个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">elif</samp> 语句比因为有 100 个嵌套的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句而导致代码缩进 100 次要更易读和编写。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Searching Lists</samp>
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">搜索列表</samp>
- en: 'The Python <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> operator,
    which tells you whether an item appears in a list, is useful for working with
    lists. For example, to check whether the number 42 appears in a list of numbers,
    you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 运算符可以告诉你某个项是否出现在列表中，它在处理列表时非常有用。例如，要检查数字
    42 是否出现在数字列表中，你可以按如下方式使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>：
- en: '[PRE57]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: To the left of the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> operator
    is a potential item inside a list, and to the right is the list. If the item is
    in the list, then the expression evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
    If not, it evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 运算符的左侧是列表中的潜在项，右侧是列表。如果该项在列表中，则表达式的值为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。如果不在，则值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。
- en: 'You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">not in</samp>
    to check if an item *isn’t* in a list:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">not in</samp> 来检查某个项是否*不在*列表中：
- en: '[PRE58]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Additionally, you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    to search for smaller strings inside of larger strings:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 来搜索较小的字符串是否出现在较大的字符串中：
- en: '[PRE59]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This code defines the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">sentence</samp>,
    then checks to see if the string <samp class="SANS_TheSansMonoCd_W5Regular_11">putin</samp>
    is inside the lowercase version of that sentence.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">sentence</samp>，然后检查字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">putin</samp> 是否出现在该句子的所有小写字母版本中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Logical Operators</samp>
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">逻辑运算符</samp>
- en: It’s possible to describe any scenario, no matter how complicated, using the
    *logical operators* <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp>.
    Like comparison operators, logical operators also evaluate to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>, and they let you
    combine comparisons.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 无论情景多么复杂，都可以使用 *逻辑运算符* <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">or</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp>
    来描述。像比较运算符一样，逻辑运算符的值也为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，并且它们允许你组合多个比较。
- en: 'For example, say you like astronomy and want to know if it’s a good time for
    stargazing. Let’s set this up as a logical expression: if ((it’s dark out) **and**
    (it’s **not** raining) **and** (it’s **not** cloudy)) **or** (you have access
    to the James Webb Space Telescope), then yes. Otherwise, no. Logical operators
    let you define this sort of logic in your Python code.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你喜欢天文学，并且想知道现在是不是适合观星的好时机。我们可以将这个情况设置为一个逻辑表达式：如果（（天黑了）**并且**（没有下雨）**并且**（没有多云））**或**（你有詹姆斯·韦布太空望远镜的使用权限），那么是的。否则，否。逻辑运算符允许你在
    Python 代码中定义这种逻辑。
- en: 'Like other operators, the <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp> operators compare
    an expression on the left with an expression on the right. With <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>,
    if both sides are true, the whole expression is true. If either is false, the
    whole expression is false. For example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他运算符一样，<samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>
    运算符将左边的表达式与右边的表达式进行比较。使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>
    时，如果两边都为真，整个表达式为真。如果任一边为假，整个表达式为假。例如：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">and</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">and</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">and</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">and</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">and</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">and</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">and</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">and</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
- en: 'With <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>, if either expression
    is true, the whole expression is true. The whole expression is false only when
    both expressions are false. For example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp> 时，如果任一表达式为真，整个表达式为真。只有当两个表达式都为假时，整个表达式才为假。例如：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> expression differs
    from the others in that it doesn’t use an expression to the left, just to the
    right. It flips true to false, and false to true. For example:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> 表达式与其他表达式不同，它不使用左侧的表达式，而只使用右侧的表达式。它将真值转换为假，假值转换为真。例如：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">not</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">not</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">not</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">not</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
- en: 'In sum, use <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp> to determine
    whether two things are both true, use <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>
    to determine whether at least one of two things is true, and use <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp>
    to change a true to a false or vice versa. For example, consider this code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp> 来判断两个条件是否都为真，使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp> 来判断两个条件中至少有一个为真，使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">not</samp> 来将真值转换为假，反之亦然。例如，考虑下面的代码：
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The first <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    has an expression that compares two other expressions, <samp class="SANS_TheSansMonoCd_W5Regular_11">country</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">"US"</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">age</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">country</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">US</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">age</samp>
    is greater than or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp>,
    the expression simplifies to <samp class="SANS_TheSansMonoCd_W5Regular_11">True
    and True</samp>. Since both Booleans are true, this evaluates to simply <samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>, and the code block after
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement runs, printing
    <samp class="SANS_TheSansMonoCd_W5Regular_11">You can legally drink alcohol</samp>
    to the screen.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句包含一个表达式，比较两个其他表达式，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">country</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"US"</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">age</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp>。如果
    <samp class="SANS_TheSansMonoCd_W5Regular_11">country</samp> 是 <samp class="SANS_TheSansMonoCd_W5Regular_11">US</samp>
    并且 <samp class="SANS_TheSansMonoCd_W5Regular_11">age</samp> 大于或等于 <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp>，该表达式将简化为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True and True</samp>。由于两个布尔值都为真，这个表达式的值为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，因此 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    语句后的代码块将执行，屏幕上会打印出 <samp class="SANS_TheSansMonoCd_W5Regular_11">You can legally
    drink alcohol</samp>。
- en: The first <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> block determines
    what happens if that expression evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
    For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">country</samp> is
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Italy</samp>, but <samp class="SANS_TheSansMonoCd_W5Regular_11">age</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">30</samp>, the expression simplifies
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">False and True</samp>. Since
    at least one of the Booleans is false, this evaluates to simply <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    so the code block after <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    runs. Likewise, if <samp class="SANS_TheSansMonoCd_W5Regular_11">country</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">US</samp> but <samp class="SANS_TheSansMonoCd_W5Regular_11">age</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">18</samp>, then the expression
    simplifies to <samp class="SANS_TheSansMonoCd_W5Regular_11">True and False</samp>.
    This, too, evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    so the code block after <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    runs.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个<samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>代码块决定了当该表达式求值为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>时会发生什么。例如，如果<samp class="SANS_TheSansMonoCd_W5Regular_11">country</samp>是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Italy</samp>，但<samp class="SANS_TheSansMonoCd_W5Regular_11">age</samp>是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">30</samp>，则表达式简化为<samp class="SANS_TheSansMonoCd_W5Regular_11">False
    and True</samp>。由于至少有一个布尔值为假，因此结果为<samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，所以<samp
    class="SANS_TheSansMonoCd_W5Regular_11">else</samp>后面的代码块会运行。同样，如果<samp class="SANS_TheSansMonoCd_W5Regular_11">country</samp>是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">US</samp>，但<samp class="SANS_TheSansMonoCd_W5Regular_11">age</samp>是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">18</samp>，那么表达式简化为<samp class="SANS_TheSansMonoCd_W5Regular_11">True
    and False</samp>。这同样求值为<samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，因此<samp
    class="SANS_TheSansMonoCd_W5Regular_11">else</samp>后面的代码块会运行。
- en: 'Inside the second <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    block is a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    without Boolean logic: if <samp class="SANS_TheSansMonoCd_W5Regular_11">country</samp>
    isn’t <samp class="SANS_TheSansMonoCd_W5Regular_11">US</samp>, the screen displays
    <samp class="SANS_TheSansMonoCd_W5Regular_11">I don''t know about your country</samp>.
    Otherwise (meaning <samp class="SANS_TheSansMonoCd_W5Regular_11">country</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">US</samp>), it displays <samp
    class="SANS_TheSansMonoCd_W5Regular_11">You''re too young to legally drink alcohol</samp>.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个<samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>代码块中是一个简单的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句，没有布尔逻辑：如果<samp class="SANS_TheSansMonoCd_W5Regular_11">country</samp>不是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">US</samp>，则屏幕显示<samp class="SANS_TheSansMonoCd_W5Regular_11">I
    don't know about your country</samp>。否则（意味着<samp class="SANS_TheSansMonoCd_W5Regular_11">country</samp>是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">US</samp>），则显示<samp class="SANS_TheSansMonoCd_W5Regular_11">You're
    too young to legally drink alcohol</samp>。
- en: 'Just like with math, you can use parentheses in <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements to compare multiple expressions. For example, the drinking age in the
    US is 21 and the drinking age in Italy is 18\. Let’s add Italy to this program,
    this time incorporating an <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>
    operator:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数学中一样，您可以在<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句中使用括号来比较多个表达式。例如，美国的法定饮酒年龄是21岁，而意大利的法定饮酒年龄是18岁。让我们在这个程序中加入意大利，这次使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">or</samp>运算符：
- en: '[PRE61]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In plain English, the first <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement tells the program that if your country is the US and you’re at least
    21 *or* if your country is Italy and you’re at least 18, then you can legally
    drink. In either case, the whole expression in the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement is true, and the program prints <samp class="SANS_TheSansMonoCd_W5Regular_11">You
    can legally drink alcohol</samp>. If just one of those is true and not the other
    (for instance, if you’re a 19-year-old Italian), the whole statement is still
    true. That’s what <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp> means:
    if either of the things you’re comparing is true, then the whole expression is
    true.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的英语来说，第一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句告诉程序：如果你的国家是美国且你至少21岁，*或者*
    如果你的国家是意大利且你至少18岁，那么你可以合法饮酒。在这两种情况下，<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    语句中的整个表达式为真，程序将打印 <samp class="SANS_TheSansMonoCd_W5Regular_11">You can legally
    drink alcohol</samp>。如果其中只有一个条件为真，另一个条件为假（例如，如果你是一个19岁的意大利人），整个语句仍然为真。这就是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">or</samp> 的意思：如果你比较的两个条件中任意一个为真，那么整个表达式为真。
- en: 'Use the operator <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> to
    turn <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> values into <samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    values into <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. For example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用运算符 <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> 可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，或者将 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。例如：
- en: '[PRE62]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You could replace <samp class="SANS_TheSansMonoCd_W5Regular_11">not age</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">age</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp> for the same result.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">not age</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp> 替换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">age</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp>，效果相同。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exception Handling</samp>
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">异常处理</samp>
- en: Python programs may abruptly quit with an error called an *exception*. This
    is typically known as “throwing an exception.” *Exception handling* ensures that
    your Python code will run another code block when your code catches an exception,
    instead of quitting with an error.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Python 程序可能会因为一个错误而突然退出，这个错误被称为 *异常*。这通常被称为“抛出异常”。*异常处理* 确保你的 Python 代码在捕获异常时会运行另一个代码块，而不是因错误退出。
- en: 'You’ve seen a few examples of exceptions already in this chapter, like when
    you tried dividing by zero (something you can’t do in math) or using a variable
    that hasn’t been defined:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经看过几个异常的例子，比如尝试除以零（这是数学中不允许的）或者使用未定义的变量：
- en: '[PRE63]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In these cases, Python threw a <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroDivisionError</samp>
    exception and a <samp class="SANS_TheSansMonoCd_W5Regular_11">NameError</samp>
    exception, respectively.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，Python 分别抛出了 <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroDivisionError</samp>
    异常和 <samp class="SANS_TheSansMonoCd_W5Regular_11">NameError</samp> 异常。
- en: 'You can write code that catches exceptions when they’re thrown, allowing you
    to handle them gracefully. For example, let’s say you have a list of names called
    <samp class="SANS_TheSansMonoCd_W5Regular_11">names</samp>, and you want display
    the first name in the list:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写捕获异常的代码，当异常被抛出时允许你优雅地处理它们。例如，假设你有一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">names</samp>
    的名字列表，并且你想显示列表中的第一个名字：
- en: '[PRE64]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This code displays the value at <samp class="SANS_TheSansMonoCd_W5Regular_11">names[0]</samp>,
    or the first item in the <samp class="SANS_TheSansMonoCd_W5Regular_11">names</samp>
    list. This works as expected if there are a few names in the list. But what if
    <samp class="SANS_TheSansMonoCd_W5Regular_11">names</samp> is empty?
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码显示 <samp class="SANS_TheSansMonoCd_W5Regular_11">names[0]</samp> 的值，即 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">names</samp> 列表中的第一个项目。如果列表中有几个名字，这段代码按预期工作。但是，如果
    <samp class="SANS_TheSansMonoCd_W5Regular_11">names</samp> 为空呢？
- en: '[PRE65]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this case, since the index 0 doesn’t exist because the list is empty, Python
    throws an <samp class="SANS_TheSansMonoCd_W5Regular_11">IndexError</samp> exception.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于索引0不存在（因为列表为空），Python抛出了一个<samp class="SANS_TheSansMonoCd_W5Regular_11">IndexError</samp>异常。
- en: 'You can catch this exception using <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp> statements, like
    this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp>语句来捕获这个异常，像这样：
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This code first runs a <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp>
    statement, followed by a code block. It attempts to run the code in that block,
    and if it succeeds without hitting an exception, it moves on to the next line
    of code after the <samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp>
    block. However, if it hits an exception, then it runs the code in the <samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp>
    block before moving on.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先运行一个<samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp>语句，接着是一个代码块。它尝试运行代码块中的代码，如果没有遇到异常，它会继续执行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">except</samp>块之后的下一行代码。然而，如果遇到异常，它会先运行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">except</samp>块中的代码，然后再继续。
- en: 'Here’s what it looks like when there’s no exception:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有异常时，代码的表现如下：
- en: '[PRE67]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In this case, the code block after the <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp>
    statement ran successfully, so the control flow moved on past the <samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp>
    block.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，<samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp>语句后的代码块成功运行，因此控制流跳过了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">except</samp>块。
- en: 'Here’s what it looks like when the exception is thrown, but the code catches
    it and handles it gracefully:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当抛出异常，但代码捕获并优雅地处理它时，代码的表现如下：
- en: '[PRE68]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The code block after the <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp>
    statement ran, but Python threw an <samp class="SANS_TheSansMonoCd_W5Regular_11">IndexError</samp>
    exception when it evaluated <samp class="SANS_TheSansMonoCd_W5Regular_11">names[0]</samp>.
    Instead of crashing and displaying an error, this code caught the exception and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp> block ran. In
    this case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp> statement
    runs if any exception is thrown in the <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp>
    block, but you can get more granular than that by using different <samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp>
    statements for different types of exceptions. Consider the following example:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp>语句后的代码块运行了，但是当Python在评估<samp
    class="SANS_TheSansMonoCd_W5Regular_11">names[0]</samp>时抛出了<samp class="SANS_TheSansMonoCd_W5Regular_11">IndexError</samp>异常。该代码没有崩溃或显示错误，而是捕获了异常并执行了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">except</samp>块。在这种情况下，如果在<samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp>块中抛出任何异常，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">except</samp>语句都会执行，但你可以使用不同的<samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp>语句来处理不同类型的异常。请考虑以下示例：
- en: '[PRE69]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: By using <samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Exception</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">:</samp>, where you replace <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Exception</samp>
    with a specific exception you’re interested in catching, you can write different
    code to handle different types of exceptions. You’ll revisit exception handling
    in [Chapter 10](chapter10.xhtml), when you learn how to work with JSON data, and
    in the [Chapter 14](chapter14.xhtml) case study on neo-Nazi chat logs.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用<samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Exception</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">:</samp>，你可以将<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Exception</samp>替换为你感兴趣捕获的具体异常，编写不同的代码来处理不同类型的异常。在[第10章](chapter10.xhtml)中，你将学习如何处理JSON数据时重新回顾异常处理，而在[第14章](chapter14.xhtml)的案例研究中，你将学习如何处理新纳粹聊天日志。
- en: Now that you know how control flow works in Python, you’ll practice some basic
    Python syntax and make comparisons using <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements and Boolean logic in the next exercise.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了Python中的控制流如何工作，接下来你将练习一些基本的Python语法，并在下一个练习中使用<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句和布尔逻辑进行比较。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 7-4: Practice Loops and Control
    Flow</samp>'
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 7-4：练习循环和控制流</samp>
- en: 'In social media slang, a common form of mockery is to employ *alternating caps*,
    or switching from uppercase to lowercase and back to uppercase, when quoting people.
    For example, here’s the text of a viral tweet from the now-suspended Twitter account
    @BigWangTheoryy:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在社交媒体俚语中，一种常见的讽刺方式是使用 *交替大小写*，即在引用别人时从大写字母切换到小写字母，再切换回大写字母。例如，这是来自现在被暂停的 Twitter
    账户 @BigWangTheoryy 的一条病毒性推文的文本：
- en: '*failing classes*Me: “Can I get some extra credit?”Professor: “cAn i GEt SomE
    eXtRa creDiT?”'
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*不及格的课程*我：“我可以加个学分吗？”教授：“cAn i GEt SomE eXtRa creDiT？”'
- en: In this exercise, you’ll write a Python script that starts with some text and
    converts it into alternating caps style, using the control flow concepts you learned
    in the previous section.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将编写一个 Python 脚本，使用你在上一节中学到的控制流概念，从一些文本开始，并将其转换为交替大小写风格。
- en: 'In your text editor, create a new file called *exercise-7-4.py*, and start
    by defining the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>,
    like this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的文本编辑器中，创建一个名为 *exercise-7-4.py* 的新文件，并像这样定义变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>：
- en: '[PRE70]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The simplest way to write this script is to start with an empty string, called
    <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps_text</samp>, and
    then loop through the characters in <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>,
    adding characters to <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps_text</samp>
    one at a time and alternating their capitalization as you do so. Add a second
    line to your script defining that variable, like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这个脚本的最简单方法是从一个空字符串开始，叫做 <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps_text</samp>，然后循环遍历
    <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp> 中的字符，一次添加一个字符到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps_text</samp> 中，并在添加过程中交替改变它们的大小写。像这样在脚本中添加第二行来定义该变量：
- en: '[PRE71]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, you’ll define a Boolean variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">should_be_capital</samp>.
    Each time you loop through a character in <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>,
    you’ll use this Boolean to keep track of whether the current character should
    be capital or lowercase. For this example, start with a capital letter:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将定义一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">should_be_capital</samp>
    的布尔变量。每次循环遍历 <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp> 中的字符时，你将使用这个布尔变量来跟踪当前字符是否应该是大写或小写。对于这个例子，先从大写字母开始：
- en: '[PRE72]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Beneath that line, add the main part of the script:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在那行下面，添加脚本的主要部分：
- en: '[PRE73]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Using a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, this
    code loops through the characters in <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>,
    storing each character in the <samp class="SANS_TheSansMonoCd_W5Regular_11">character</samp>
    variable. It then adds these characters to <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps_text</samp>,
    switching between upper- and lowercase.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环，这段代码遍历 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">text</samp> 中的字符，将每个字符存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">character</samp>
    变量中。然后，它将这些字符添加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps_text</samp>
    中，并在大写和小写之间切换。
- en: During each iteration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, <samp class="SANS_TheSansMonoCd_W5Regular_11">character</samp> is another
    character in <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>, the variable
    containing the <samp class="SANS_TheSansMonoCd_W5Regular_11">"One does not simply
    walk into Mordor"</samp> string. The first time the code loops, <samp class="SANS_TheSansMonoCd_W5Regular_11">character</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">O</samp>. When the code reaches
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, <samp class="SANS_TheSansMonoCd_W5Regular_11">should_be_capital</samp>
    evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> for this
    character, so the code block runs. The <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp>
    operator adds <samp class="SANS_TheSansMonoCd_W5Regular_11">character.upper()</samp>
    (or the uppercase version of <samp class="SANS_TheSansMonoCd_W5Regular_11">character</samp>)
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps_text</samp>.
    Since the code began by adding a capital letter, you want it to add a lowercase
    letter next, so you set <samp class="SANS_TheSansMonoCd_W5Regular_11">should_be
    _capital</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
    The code block ends, and the code starts its second loop.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环时，<samp class="SANS_TheSansMonoCd_W5Regular_11">character</samp>
    是 <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp> 中的另一个字符，<samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>
    变量包含了字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">"One does not simply walk
    into Mordor"</samp>。代码第一次循环时，<samp class="SANS_TheSansMonoCd_W5Regular_11">character</samp>
    是 <samp class="SANS_TheSansMonoCd_W5Regular_11">O</samp>。当代码执行到 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    语句时，<samp class="SANS_TheSansMonoCd_W5Regular_11">should_be_capital</samp> 对于这个字符的值为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，因此执行代码块。<samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp>
    运算符将 <samp class="SANS_TheSansMonoCd_W5Regular_11">character.upper()</samp>（即
    <samp class="SANS_TheSansMonoCd_W5Regular_11">character</samp> 的大写版本）添加到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps_text</samp> 中。由于代码一开始是添加大写字母，因此接下来希望添加小写字母，因此将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">should_be_capital</samp> 设置为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。代码块结束后，代码开始进入第二次循环。
- en: During the second iteration, <samp class="SANS_TheSansMonoCd_W5Regular_11">character</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">should_be_capital</samp>
    evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. When
    the code reaches the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement,
    the expression evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    so the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> block runs. This
    is similar to the other block, except that it appends the lowercase version of
    character, <samp class="SANS_TheSansMonoCd_W5Regular_11">character.lower()</samp>,
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">alternative_caps_text</samp>
    and sets <samp class="SANS_TheSansMonoCd_W5Regular_11">should_be_capital</samp>
    back to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. So far, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps_text</samp> is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">On</samp>.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次迭代中，<samp class="SANS_TheSansMonoCd_W5Regular_11">character</samp> 为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">n</samp>，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">should_be_capital</samp>
    的值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。当代码执行到 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    语句时，表达式的值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>，因此执行 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">else</samp> 块。这个过程与另一个块类似，不同的是，它将字符的小写版本
    <samp class="SANS_TheSansMonoCd_W5Regular_11">character.lower()</samp> 附加到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">alternative_caps_text</samp> 中，并将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">should_be_capital</samp> 重新设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。到目前为止，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps_text</samp> 的值是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">On</samp>。
- en: During the third iteration, <samp class="SANS_TheSansMonoCd_W5Regular_11">character</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">should_be_capital</samp>
    evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. When the
    code reaches the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement,
    the expression evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    so that code block runs again, adding a capital <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating _caps_text</samp>
    and setting <samp class="SANS_TheSansMonoCd_W5Regular_11">should_be_capital</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> again. The code
    continues in this way for the rest of the characters in <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>.
    Note that the uppercase and lowercase versions of the space character, <samp class="SANS_TheSansMonoCd_W5Regular_11">"
    ".upper()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">" ".lower()</samp>,
    are identical. The <samp class="SANS_TheSansMonoCd_W5Regular_11">upper()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">lower()</samp> methods also
    don’t change punctuation characters like <samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>,
    and so on.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三次迭代时，<samp class="SANS_TheSansMonoCd_W5Regular_11">character</samp>是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">e</samp>，并且<samp class="SANS_TheSansMonoCd_W5Regular_11">should_be_capital</samp>的值为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。当代码进入<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句时，表达式的值为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，因此该代码块再次执行，将大写字母<samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>添加到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps_text</samp>中，并将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">should_be_capital</samp>重新设置为<samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。代码以这种方式继续处理<samp
    class="SANS_TheSansMonoCd_W5Regular_11">text</samp>中的其余字符。请注意，空格字符的大小写版本，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">" ".upper()</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">"
    ".lower()</samp>是相同的。<samp class="SANS_TheSansMonoCd_W5Regular_11">upper()</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">lower()</samp>方法也不会改变像<samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">.</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>等标点符号的字符。
- en: 'When this <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is
    finished, all you have left to do is display the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps_text</samp>
    by adding this line to your script:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环完成时，你只需要通过在脚本中添加这一行来显示<samp
    class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps_text</samp>的值：
- en: '[PRE74]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Your Python script is complete (you can also find a complete copy at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-7<wbr>/exercise<wbr>-7<wbr>-4<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-7/exercise-7-4.py)).
    Run your script. Here’s the output I get:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Python脚本已经完成（你也可以在[*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-7<wbr>/exercise<wbr>-7<wbr>-4<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-7/exercise-7-4.py)找到完整的副本）。运行你的脚本。以下是我得到的输出：
- en: '[PRE75]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now change the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>
    and run the script again. For example, I changed the value to <samp class="SANS_TheSansMonoCd_W5Regular_11">"There
    are very fine people on both sides"</samp>:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在改变<samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>的值并重新运行脚本。例如，我将值更改为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">"There are very fine people on both sides"</samp>：
- en: '[PRE76]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You’ve gained a beginner’s understanding of using lists and loops and controlling
    the flow of execution. I’ll conclude the chapter with one more fundamental programming
    skill: breaking your code down into simpler chunks using functions.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经掌握了使用列表、循环和控制执行流程的基础知识。本章将以另一项基本编程技能结束：使用函数将你的代码拆分成更简单的模块。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Functions</samp>
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">函数</samp>
- en: The more complicated your programs get, the more important it is to break the
    problems you’re trying to solve down into smaller chunks and work on them individually.
    This allows you to focus on the bigger picture, using those smaller chunks of
    code as building blocks. In this section, you’ll learn how to do this using functions.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 程序越复杂，你越需要将要解决的问题分解成更小的部分，并分别处理它们。这可以让你专注于更大的整体，通过使用这些小块代码作为构建块来实现。在本节中，你将学习如何通过函数来实现这一点。
- en: '*Functions*, fundamental building blocks of programming, are reusable chunks
    of code. They take *arguments*—the variables that you pass into a function—as
    input and can *return* a value after they finish running. You’ve already used
    a few functions that come with Python, like <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp>, but you can also
    define your own function and use it as many times as you want without having to
    rewrite that code. You’ll learn how to do that in this section.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*，作为编程的基本构建块，是可重复使用的代码块。它们接受*参数*—你传递给函数的变量—作为输入，并在运行完成后可以*返回*一个值。你已经使用过一些
    Python 提供的函数，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> 和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp>，但你也可以定义自己的函数，并且可以多次使用它，而不需要重新编写那段代码。在本节中，你将学习如何做到这一点。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The def Keyword</samp>
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">def 关键字</samp>
- en: 'You can define a new function using the <samp class="SANS_TheSansMonoCd_W5Regular_11">def</samp>
    keyword. For example, this code defines a function called <samp class="SANS_TheSansMonoCd_W5Regular_11">test()</samp>,
    which prints a string to your terminal:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">def</samp> 关键字来定义一个新函数。例如，下面的代码定义了一个名为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">test()</samp> 的函数，它会在终端打印一串字符串：
- en: '[PRE77]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Function definition lines end with a colon and are followed by an indented
    code block that defines exactly what the function does: in this case, it displays
    the string <samp class="SANS_TheSansMonoCd_W5Regular_11">this is a test function</samp>.
    This <samp class="SANS_TheSansMonoCd_W5Regular_11">test()</samp> function doesn’t
    include any arguments, which means every time you run it, it will do the exact
    same thing.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义行以冒号结束，后面跟着一个缩进的代码块，定义函数的具体行为：在这个例子中，它显示字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">this
    is a test function</samp>。这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">test()</samp>
    函数没有任何参数，这意味着每次你运行它时，它都会做完全相同的事情。
- en: '[Listing 7-2](#list7-2) defines a slightly more complicated function, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sum()</samp>, that adds two numbers together.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 7-2](#list7-2) 定义了一个稍微复杂一点的函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">sum()</samp>，它将两个数字相加。'
- en: '[PRE78]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: Defining an example
    function</samp>'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: 定义一个示例函数</samp>'
- en: This new function takes <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> as arguments and returns
    the sum of those two variables. For any function that takes more than one argument,
    like this one, you separate the arguments with commas (<samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新函数接受 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    作为参数，并返回这两个变量的和。对于任何接受多个参数的函数，如本例，你需要用逗号 (<samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>)
    分隔这些参数。
- en: Each variable has a *scope*, which describes which parts of your code can use
    that variable. The arguments of a function (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>), as well as any variables
    defined inside the function, have a scope that can be accessed only by code in
    that function’s code block. In other words, you can use these <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> variables only inside
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum()</samp> function, and they
    won’t be defined outside of that code block.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量都有一个*作用域*，它描述了代码中的哪些部分可以使用该变量。一个函数的参数（在这个例子中是 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>），以及在函数内部定义的任何变量，具有只能在该函数代码块内访问的作用域。换句话说，你只能在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sum()</samp> 函数内部使用这些 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 变量，它们不会在该代码块外部定义。
- en: 'You can think of defining a function as telling Python, “I’m making a new function
    with this name, and here’s what it does.” However, the function itself won’t run
    until you *call* it. Consider the following Python script:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把定义一个函数看作是告诉Python：“我正在创建一个新函数，命名为这个，并且这是它的功能。”然而，函数本身不会执行，直到你*调用*它。考虑以下Python脚本：
- en: '[PRE79]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: First, the code defines a function called <samp class="SANS_TheSansMonoCd_W5Regular_11">sum()</samp>
    to be a code block with just a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement. This function doesn’t run yet. The code then defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">red_apples</samp>
    variable, setting its value to <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>,
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">green_apples</samp> variable,
    setting its value to <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码定义了一个名为<samp class="SANS_TheSansMonoCd_W5Regular_11">sum()</samp>的函数，该函数只是一个包含<samp
    class="SANS_TheSansMonoCd_W5Regular_11">return</samp>语句的代码块。这个函数尚未执行。然后，代码定义了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">red_apples</samp>变量，并将其值设置为<samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>，还定义了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">green_apples</samp>变量，并将其值设置为<samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>。
- en: The next line starts with <samp class="SANS_TheSansMonoCd_W5Regular_11">total_apples</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>, but before Python can
    set the value of that variable, it needs to learn what that value should be. To
    do that, the code first calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum()</samp>
    function, passing in the arguments <samp class="SANS_TheSansMonoCd_W5Regular_11">red_apples</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">green_apples</samp> as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>.
    Now that the code is finally calling this function, <samp class="SANS_TheSansMonoCd_W5Regular_11">return
    a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    runs. In this function call, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">red_apples</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">green_apples</samp>. The function
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, which is <samp class="SANS_TheSansMonoCd_W5Regular_11">16</samp>.
    Now that the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum()</samp> function
    has returned, the code defines a variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">total_apples</samp>,
    setting its value to the return value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum()</samp>
    function, <samp class="SANS_TheSansMonoCd_W5Regular_11">16</samp>.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行以<samp class="SANS_TheSansMonoCd_W5Regular_11">total_apples</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp>开始，但在Python能够设置该变量的值之前，它需要知道该值应为多少。为此，代码首先调用了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sum()</samp>函数，传入<samp class="SANS_TheSansMonoCd_W5Regular_11">red_apples</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">green_apples</samp>作为<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>。现在代码终于调用了这个函数，<samp class="SANS_TheSansMonoCd_W5Regular_11">return
    a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>会运行。在这个函数调用中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>是<samp class="SANS_TheSansMonoCd_W5Regular_11">red_apples</samp>，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>是<samp class="SANS_TheSansMonoCd_W5Regular_11">green_apples</samp>。函数返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>，即<samp class="SANS_TheSansMonoCd_W5Regular_11">16</samp>。现在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sum()</samp>函数已经返回，代码定义了一个名为<samp class="SANS_TheSansMonoCd_W5Regular_11">total_apples</samp>的变量，并将其值设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sum()</samp>函数的返回值，即<samp class="SANS_TheSansMonoCd_W5Regular_11">16</samp>。
- en: Finally, the code calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    function, passing in an f-string as an argument, which displays the <samp class="SANS_TheSansMonoCd_W5Regular_11">total_apples</samp>
    variable. It will display the message <samp class="SANS_TheSansMonoCd_W5Regular_11">There
    are 16 apples</samp>.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码调用了<samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>函数，并传入一个f-string作为参数，显示<samp
    class="SANS_TheSansMonoCd_W5Regular_11">total_apples</samp>变量。它会显示消息<samp class="SANS_TheSansMonoCd_W5Regular_11">There
    are 16 apples</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Default Arguments</samp>
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">默认参数</samp>
- en: Function definitions can also have *default arguments*, which means defining
    their value is optional. If you haven’t passed in any values for them when the
    function is called, the default value is used instead.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义也可以有*默认参数*，这意味着定义它们的值是可选的。如果在调用函数时没有传入这些参数的值，那么默认值将会被使用。
- en: 'For example, consider this function, which, given a number and optionally a
    number of exclamation marks and question marks, prints a greeting using its arguments:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个函数，它接受一个数字，并可选地接受感叹号和问号的数量，使用这些参数打印一个问候语：
- en: '[PRE80]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The argument <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> is a
    *positional argument*, which means when you call this function, the first argument
    you pass in always has to be <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>.
    However, <samp class="SANS_TheSansMonoCd_W5Regular_11">num_exclamations</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">num_questions</samp> are default
    arguments, so passing values in for those is optional. The <samp class="SANS_TheSansMonoCd_W5Regular_11">greet()</samp>
    function defines the strings <samp class="SANS_TheSansMonoCd_W5Regular_11">exclamations</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">questions</samp> and sets them
    to a series of exclamation points and question marks. (In Python, when you multiply
    a string by a number, you get the original string repeated multiple times; for
    example, <samp class="SANS_TheSansMonoCd_W5Regular_11">"A" * 3</samp> evaluates
    to the string <samp class="SANS_TheSansMonoCd_W5Regular_11">AAA</samp>.) The code
    then displays <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello</samp>, followed
    by the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>, followed
    by the number of exclamation points and question marks passed into the function.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> 是*位置参数*，这意味着在调用函数时，你传入的第一个参数必须始终是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>。然而，<samp class="SANS_TheSansMonoCd_W5Regular_11">num_exclamations</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">num_questions</samp> 是默认参数，所以传入这些参数的值是可选的。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">greet()</samp> 函数定义了字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">exclamations</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">questions</samp>，并将它们设置为一系列感叹号和问号。（在
    Python 中，当你将一个字符串乘以一个数字时，结果是将原字符串重复多次；例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">"A"
    * 3</samp> 结果是字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">AAA</samp>。）然后代码会显示
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello</samp>，接着是 <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    的值，再后面是传入函数的感叹号和问号的数量。
- en: 'This function has one positional argument (<samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>)
    and two default arguments (<samp class="SANS_TheSansMonoCd_W5Regular_11">num_exclamations</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">num_questions</samp>). You can
    call it just passing in <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>,
    without passing values in for the default arguments, and they will automatically
    be set to 3 and 2, respectively:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有一个位置参数（<samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>）和两个默认参数（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">num_exclamations</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">num_questions</samp>）。你可以只传入
    <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>，而不传入默认参数的值，这样它们会自动设置为
    3 和 2，分别对应感叹号和问号的数量：
- en: '[PRE81]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You can also keep the default value for one of the default arguments, but choose
    a value for another. When you manually choose a value for a default argument,
    you’re using a *keyword argument*. For example:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以保留其中一个默认参数的默认值，但为另一个选择一个新的值。当你手动为默认参数选择值时，你就是在使用*关键字参数*。例如：
- en: '[PRE82]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The first function call uses keyword arguments for both <samp class="SANS_TheSansMonoCd_W5Regular_11">num_exclamation</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">num_questions</samp>; the second
    function call uses a keyword argument only for <samp class="SANS_TheSansMonoCd_W5Regular_11">num_questions</samp>
    and uses the default argument for <samp class="SANS_TheSansMonoCd_W5Regular_11">num_exclamations</samp>;
    and the third function call uses a keyword argument for <samp class="SANS_TheSansMonoCd_W5Regular_11">num_exclamations</samp>
    and uses the default argument for <samp class="SANS_TheSansMonoCd_W5Regular_11">num_questions</samp>.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数调用使用了关键字参数来传递 <samp class="SANS_TheSansMonoCd_W5Regular_11">num_exclamation</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">num_questions</samp>；第二个函数调用仅使用了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">num_questions</samp> 的关键字参数，并且对
    <samp class="SANS_TheSansMonoCd_W5Regular_11">num_exclamations</samp> 使用了默认参数；第三个函数调用则使用了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">num_exclamations</samp> 的关键字参数，而对
    <samp class="SANS_TheSansMonoCd_W5Regular_11">num_questions</samp> 使用了默认参数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Return Values</samp>
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">返回值</samp>
- en: Functions become a lot more useful when they take some input, do some computation,
    and then return a value, known as the *return value*. The <samp class="SANS_TheSansMonoCd_W5Regular_11">greet()</samp>
    function just described displays output, but it doesn’t return a value that I
    could save in a variable or pass into further functions. However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp>
    function you used earlier takes input (a list or a string), does some computation
    (calculates the length of the list or string), and returns a value (the length).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在接受输入、进行计算并返回一个值时变得更加有用，这个返回的值被称为 *返回值*。之前描述的 <samp class="SANS_TheSansMonoCd_W5Regular_11">greet()</samp>
    函数只是显示输出，但它不会返回一个我可以保存在变量中或传递给其他函数的值。然而，之前你使用的 <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp>
    函数接受输入（一个列表或字符串），进行计算（计算列表或字符串的长度），并返回一个值（该长度）。
- en: 'Here’s an example of a function that takes a string <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    as an argument and returns the number of vowels in the string:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例函数，它接受一个字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> 作为参数，并返回该字符串中元音字母的数量：
- en: '[PRE83]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This function brings together many of the concepts covered in this chapter
    so far: it defines the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">number_of_vowels</samp>
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, then defines the variable
    <samp class="SANS_TheSansMonoCd_W5Regular_11">vowels</samp> as a string containing
    lowercase and uppercase English vowels. Next, it uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to loop through each character in <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>,
    the string that’s passed into the function.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数综合了本章迄今为止讲解的许多概念：它将变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">number_of_vowels</samp>
    定义为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，然后将变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">vowels</samp>
    定义为包含大小写英语元音字母的字符串。接下来，它使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环遍历传入函数的字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> 中的每个字符。
- en: In each loop, the code uses an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement to check whether the character is a vowel (since <samp class="SANS_TheSansMonoCd_W5Regular_11">vowels</samp>
    contains both lowercase and uppercase letters, this code considers both <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    to be vowels). If the character is a vowel, the code increases the <samp class="SANS_TheSansMonoCd_W5Regular_11">number_of_vowels</samp>
    variable by one. Finally, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">number_of_vowels</samp>,
    which equals however many vowels it counted in <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次循环中，代码使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句检查字符是否为元音字母（由于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">vowels</samp> 包含大小写字母，因此此代码将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    都视为元音字母）。如果字符是元音字母，代码会将 <samp class="SANS_TheSansMonoCd_W5Regular_11">number_of_vowels</samp>
    变量加一。最后，它返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">number_of_vowels</samp>，其值等于在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> 中计算出的元音字母数量。
- en: 'Here are a few examples of calling this function and passing in different strings:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些调用此函数并传入不同字符串的示例：
- en: '[PRE84]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'When you define a variable, you can set its value to the return value of a
    function just by setting the variable equal to that function call:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个变量时，可以通过将该变量设置为函数调用的返回值来初始化它：
- en: '[PRE85]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This code defines the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">num_vowels_think</samp>
    and sets its value to the return value of <samp class="SANS_TheSansMonoCd_W5Regular_11">count_vowels("THINK")</samp>,
    or the number of vowels in the string <samp class="SANS_TheSansMonoCd_W5Regular_11">THINK</samp>.
    It also defines the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">num_vowels_lizard</samp>
    and sets its value to the return value of <samp class="SANS_TheSansMonoCd_W5Regular_11">count_vowels("lizard")</samp>.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">num_vowels_think</samp>，并将其值设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">count_vowels("THINK")</samp> 的返回值，或者说是字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">THINK</samp> 中的元音字母数量。它还定义了变量 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">num_vowels_lizard</samp>，并将其值设置为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">count_vowels("lizard")</samp> 的返回值。
- en: 'You can then use those variables to define new variables:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用这些变量来定义新变量：
- en: '[PRE86]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This code adds those two variables together, saving their sum in a new variable
    called <samp class="SANS_TheSansMonoCd_W5Regular_11">total_vowels</samp>. It then
    prints the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">total_vowels</samp>
    to the terminal.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将这两个变量相加，并将它们的和保存在一个名为<samp class="SANS_TheSansMonoCd_W5Regular_11">total_vowels</samp>的新变量中。然后，它会将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">total_vowels</samp>的值打印到终端。
- en: 'When a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement
    runs, the function immediately ends, so <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    is also useful if you want to stop a function early. For example, the following
    <samp class="SANS_TheSansMonoCd_W5Regular_11">is_exciting()</samp> function loops
    through all the characters in a string <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    to check whether the character is an exclamation point:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当<samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>语句执行时，函数会立即结束，因此<samp
    class="SANS_TheSansMonoCd_W5Regular_11">return</samp>在你想提前停止函数时也非常有用。例如，下面的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">is_exciting()</samp>函数会循环遍历字符串<samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>中的所有字符，以检查该字符是否为感叹号：
- en: '[PRE87]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: If the function finds an exclamation point, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    immediately stopping the function. If it checks each character and finds no exclamation
    points, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
    For example, if you call this function and pass in the string <samp class="SANS_TheSansMonoCd_W5Regular_11">!@#$</samp>,
    the function will return <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    during the first iteration of the loop and immediately end—it will never even
    get to the second iteration. If you pass in the string <samp class="SANS_TheSansMonoCd_W5Regular_11">hello!</samp>,
    it won’t return <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> until
    the last iteration of the loop, since it doesn’t find the <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>
    until the end of the string. And if you pass in the string <samp class="SANS_TheSansMonoCd_W5Regular_11">goodbye</samp>,
    it will loop through the entire string and not find an exclamation point, so it
    will return <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数找到感叹号，它会返回<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，并立即停止函数。如果检查每个字符时没有找到感叹号，它将返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。例如，如果你调用这个函数并传入字符串<samp class="SANS_TheSansMonoCd_W5Regular_11">!@#$</samp>，函数将在循环的第一次迭代中返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>并立即结束——它甚至不会进入第二次迭代。如果你传入字符串<samp
    class="SANS_TheSansMonoCd_W5Regular_11">hello!</samp>，它直到循环的最后一次迭代才返回<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>，因为它要到字符串的末尾才能找到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp>。如果你传入字符串<samp class="SANS_TheSansMonoCd_W5Regular_11">goodbye</samp>，它会循环遍历整个字符串，但找不到感叹号，所以会返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Docstrings</samp>
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">文档字符串</samp>
- en: In *self-documenting* code, documentation is defined as part of the code as
    docstrings rather than in a separate document. *Docstrings* are strings enclosed
    by three double quotes (<samp class="SANS_TheSansMonoCd_W5Regular_11">"""</samp>)
    or three single quotes (<samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">''</samp>) on either side, placed as the
    first line of code after a function definition. When you run the function, the
    program ignores the docstring, but Python can use it to pull up documentation
    about the function on request. Docstrings are optional, but they can help other
    people understand your code.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在*自文档化*代码中，文档作为文档字符串被定义为代码的一部分，而不是单独的文档。*文档字符串*是被三重双引号（<samp class="SANS_TheSansMonoCd_W5Regular_11">"""</samp>）或三重单引号（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">'</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">''</samp>）包围的字符串，位于函数定义后的第一行代码中。当你运行函数时，程序会忽略文档字符串，但Python可以在需要时使用它来提取有关函数的文档。文档字符串是可选的，但它们可以帮助其他人理解你的代码。
- en: 'For example, here’s how you’d define the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum()</samp>
    function with a docstring:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面是如何使用文档字符串定义<code class="SANS_TheSansMonoCd_W5Regular_11">sum()</code>函数的方式：
- en: '[PRE88]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This is exactly the same as the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum()</samp>
    function defined in [Listing 7-2](#list7-2), except it includes a docstring.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这与在[示例 7-2](#list7-2)中定义的<samp class="SANS_TheSansMonoCd_W5Regular_11">sum()</samp>函数完全相同，只不过它包含了一个文档字符串。
- en: 'If you run the <samp class="SANS_TheSansMonoCd_W5Regular_11">help()</samp>
    function, passing in the name of a function (without arguments) as the argument,
    the Python interpreter will display documentation for that function. For example,
    running <samp class="SANS_TheSansMonoCd_W5Regular_11">help(sum)</samp> gives you
    the following output:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行<samp class="SANS_TheSansMonoCd_W5Regular_11">help()</samp>函数，并将一个函数的名称（不带参数）作为参数传入，Python解释器将显示该函数的文档。例如，运行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">help(sum)</samp>将显示以下输出：
- en: '[PRE89]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">help()</samp> function works
    for any function, though it’s useful only if the programmer who wrote that function
    included a docstring. In this case, it tells you that it’s showing you help for
    the function called <samp class="SANS_TheSansMonoCd_W5Regular_11">sum()</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">__main__</samp> module. You’ll
    learn more about modules in [Chapter 8](chapter8.xhtml), but they’re essentially
    functions you write yourself. Try running <samp class="SANS_TheSansMonoCd_W7Bold_B_11">help(print)</samp>
    or <samp class="SANS_TheSansMonoCd_W7Bold_B_11">help(len)</samp> to view the docstrings
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">len()</samp> functions.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">help()</samp>函数适用于任何函数，但只有在编写该函数的程序员包含了文档字符串时才有用。在本例中，它告诉你，它正在显示名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sum()</samp>的函数的帮助文档，该函数位于<samp class="SANS_TheSansMonoCd_W5Regular_11">__main__</samp>模块中。你将在[第8章](chapter8.xhtml)中了解更多关于模块的内容，但它们本质上是你自己编写的函数。尝试运行<samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">help(print)</samp>或<samp class="SANS_TheSansMonoCd_W7Bold_B_11">help(len)</samp>，查看<samp
    class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp>函数的文档字符串。
- en: Press Q to get out of the help interface and back to the Python interpreter.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 按Q退出帮助界面，返回到Python解释器。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 7-5: Practice Writing Functions</samp>'
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 7-5：练习编写函数</samp>
- en: In this exercise, you’ll turn the script you wrote in Exercise 7-4 into a function.
    You can then call this function multiple times, passing text into it so that it
    returns an alternating caps version of that text each time.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，你将把在练习7-4中编写的脚本转换为一个函数。然后，你可以多次调用此函数，传入文本，以便它每次都返回该文本的交替大小写版本。
- en: 'In your text editor, create a new file called *exercise-7-5.py* and create
    a new function called <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps()</samp>,
    which takes in the argument <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>,
    like this:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的文本编辑器中，创建一个名为*exercise-7-5.py*的新文件，并创建一个名为<samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps()</samp>的新函数，该函数接收参数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">text</samp>，如下所示：
- en: '[PRE90]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Next, copy the code from Exercise 7-4 and paste it into this function, making
    sure to indent it so that it aligns with the docstring. Delete the line that defines
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp> value; instead,
    define <samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp> by passing it
    into the function as an argument. Also change the last line of the Exercise 7-4
    code from <samp class="SANS_TheSansMonoCd_W5Regular_11">print(alternating_caps_text)</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">return alternating_caps_text</samp>.
    This function shouldn’t display the alternating caps version of a string; it should
    create a variable containing this version of a string and return it.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，复制练习7-4中的代码并将其粘贴到此函数中，确保将其缩进，使其与文档字符串对齐。删除定义<samp class="SANS_TheSansMonoCd_W5Regular_11">text</samp>值的那一行；改为将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">text</samp>作为参数传递给函数来定义它。同时，将练习7-4代码中的最后一行从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">print(alternating_caps_text)</samp>更改为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">return alternating_caps_text</samp>。这个函数不应该显示字符串的交替大小写版本；它应该创建一个包含该版本的变量并返回它。
- en: 'Your complete function should look like this (you can also find a copy at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-7<wbr>/exercise<wbr>-7<wbr>-5<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-7/exercise-7-5.py)):'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你的完整函数应该如下所示（你也可以在[*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-7<wbr>/exercise<wbr>-7<wbr>-5<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-7/exercise-7-5.py)找到一个副本）：
- en: '[PRE91]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now that you have a function—a reusable chunk of code—you can use it as many
    times as you want. Call this function a few times, remembering to display its
    return value using the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    function, like this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个函数——一个可重用的代码块——你可以根据需要调用它多次。像这样调用这个函数几次，并记得使用<samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>函数显示它的返回值：
- en: '[PRE92]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: You can change the text that you pass in to the <samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps()</samp>
    function calls to whatever you want.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更改传递给<samp class="SANS_TheSansMonoCd_W5Regular_11">alternating_caps()</samp>函数调用的文本，修改成你想要的任何内容。
- en: 'Here’s what it looks like when I run this script:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我运行这个脚本时的效果：
- en: '[PRE93]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: While the output of this script is displayed in a mocking tone, I hope that
    the sentiment is true for you!
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个脚本的输出是以嘲讽的语气显示的，但我希望这个情感对你来说是真实的！
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: This chapter has covered several basic Python programming concepts you’ll rely
    upon in future investigations. You learned to write simple Python scripts that
    incorporate the major features of the language, including variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements, <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops, and
    functions. You’re ready to continue your Python programming journey in the next
    chapter, this time writing code to directly investigate datasets.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了你在未来研究中将依赖的几个基本的Python编程概念。你学会了编写包含语言主要特性的简单Python脚本，包括变量、<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环和函数。你已经准备好在下一章继续你的Python编程之旅，这次将编写代码直接调查数据集。
