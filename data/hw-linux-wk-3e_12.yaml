- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Network File Transfer and Sharing
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络文件传输和共享
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: This chapter surveys options for distributing and sharing files between machines
    on a network. We’ll start by looking at some ways to copy files other than the
    `scp` and `sftp` utilities that you’ve already seen. Then we’ll discuss true file
    sharing, where you attach a directory on one machine to another machine.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了在网络上分发和共享文件的选项。我们将首先看看除了你已经看到的`scp`和`sftp`工具外的其他文件复制方法。然后我们将讨论真正的文件共享，即将一台机器上的目录附加到另一台机器上。
- en: 'Because there are so many ways to distribute and share files, here’s a list
    of scenarios with corresponding solutions:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有许多方式可以分发和共享文件，以下是一些场景及其对应的解决方案：
- en: '| Make a file or directory from your Linux machine temporarily available to
    other machines. | Python SimpleHTTPServer (Section 12.1) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 将Linux机器上的文件或目录临时提供给其他机器。 | Python SimpleHTTPServer（第12.1节）|'
- en: '| Distribute (copy) files across machines, particularly on a regular basis.
    | rsync (Section 12.2) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| 在机器之间分发（复制）文件，特别是定期进行。 | rsync（第12.2节）|'
- en: '| Regularly share the files on your Linux machine to Windows machines. | Samba
    (Section 12.4) |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 定期将Linux机器上的文件共享到Windows机器上。 | Samba（第12.4节）|'
- en: '| Mount Windows shares on your Linux machine. | CIFS (Section 12.4) |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 在Linux机器上挂载Windows共享。 | CIFS（第12.4节）|'
- en: '| Implement small-scale sharing between Linux machines with minimal setup.
    | SSHFS (Section 12.5) |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 在Linux机器之间实现小规模共享，设置最小。 | SSHFS（第12.5节）|'
- en: '| Mount larger filesystems from an NAS or other server on your trusted local
    network. | NFS (Section 12.6) |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 从NAS或其他服务器挂载更大的文件系统到你的受信本地网络。 | NFS（第12.6节）|'
- en: '| Mount cloud storage to your Linux machine. | Various FUSE-based filesystems
    (Section 12.7) |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 将云存储挂载到Linux机器上。 | 各种基于FUSE的文件系统（第12.7节）|'
- en: Notice that there’s nothing here about large-scale sharing between multiple
    locations with many users. Though not impossible, such a solution generally requires
    a fair amount of work, and is not within the scope of this book. We’ll end the
    chapter by discussing why this is the case.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里没有涉及到多个地点之间、多个用户进行大规模共享的内容。虽然不是不可能，但这种解决方案通常需要大量的工作，并不在本书的范围内。我们将在本章结束时讨论为什么会这样。
- en: Unlike many other chapters in this book, the last part of this chapter is not
    advanced material. In fact, the sections that you might get the most value from
    are the most “theoretical” ones. Sections 12.3 and 12.8 will help you understand
    *why* there are so many options listed here in the first place.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的许多其他章节不同，本章的最后部分并非高级内容。事实上，你可能从中获得最大价值的是那些“理论性”的部分。第12.3节和第12.8节将帮助你理解*为什么*这里列出了这么多选项。
- en: 12.1 Quick Copy
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 快速复制
- en: 'Let’s say you want to copy a file (or files) from your Linux machine to another
    one on your personal network, and you don’t care about copying it back or anything
    fancy—you just want to get your files there quickly. There’s a convenient way
    to do this with Python. Just go to the directory containing the file(s) and run:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想将一个文件（或多个文件）从你的Linux机器复制到你个人网络中的另一台机器上，而且你不关心将它复制回来或其他复杂操作——你只希望快速将文件传输过去。可以通过Python实现这种方便的方式。只需进入包含文件的目录，并运行：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This starts a basic web server that makes the current directory available to
    any browser on the network. By default, it runs on port 8000, so if the machine
    you run this on is at address 10.1.2.4, point your browser on the destination
    system to *http://10.1.2.4:8000* and you’ll be able to grab what you need.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这会启动一个基本的Web服务器，使当前目录可以被网络上的任何浏览器访问。默认情况下，它运行在8000端口，因此如果你在地址为10.1.2.4的机器上运行此服务，访问目标系统的浏览器时，只需访问*http://10.1.2.4:8000*，你就能获取所需的文件。
- en: 12.2 rsync
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 rsync
- en: 'When you want to start copying more than just a file or two, you can turn to
    tools that require server support on the destination. For example, you can copy
    an entire directory structure to another place with `scp -r`, provided that the
    remote destination has SSH and SCP server support (this is available for Windows
    and macOS). We’ve already seen this option in Chapter 10:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要开始复制的不仅仅是一个或两个文件时，可以使用需要目标服务器支持的工具。例如，你可以使用`scp -r`将整个目录结构复制到另一个地方，前提是远程目标支持SSH和SCP服务器（Windows和macOS都可以支持）。我们在第10章已经看到过这种方法：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This method gets the job done but is not very flexible. In particular, after
    the transfer completes, the remote host may not have an exact copy of the directory.
    If `directory` already exists on the remote machine and contains some extraneous
    files, those files persist after the transfer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法能够完成任务，但并不非常灵活。特别是，在传输完成后，远程主机可能没有目录的精确副本。如果`directory`在远程机器上已经存在，并且包含一些多余的文件，那么这些文件会在传输后继续存在。
- en: If you expect to do this sort of thing regularly (and especially if you plan
    to automate the process), you should use a dedicated synchronizer system that
    can also perform analysis and verification. On Linux, `rsync` is the standard
    synchronizer, offering good performance and many useful ways to perform transfers.
    In this section we’ll cover some of the essential `rsync` operation modes and
    look at some of its peculiarities.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你预计要经常进行这种操作（特别是如果你计划自动化这个过程），你应该使用一个专门的同步系统，它还可以执行分析和验证。在Linux上，`rsync`是标准的同步工具，提供良好的性能和许多有用的传输方式。在本节中，我们将介绍一些`rsync`的基本操作模式，并探讨一些它的特殊性。
- en: 12.2.1  Getting Started with rsync
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.1  开始使用rsync
- en: To get `rsync` working between two hosts, you must install the `rsync` program
    on both the source and destination, and you’ll need a way to access one machine
    from the other. The easiest way to transfer files is to use a remote shell account,
    and let’s assume that you want to transfer files using SSH access. However, remember
    that `rsync` can be handy even for copying files and directories between locations
    on a single machine, such as from one filesystem to another.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要在两个主机之间使用`rsync`，你必须在源和目标主机上都安装`rsync`程序，并且你需要一种从一台机器访问另一台机器的方式。传输文件的最简单方法是使用远程
    shell 账户，假设你想通过SSH访问来传输文件。然而，请记住，`rsync`即使在单台机器上复制文件和目录之间的位置时也非常有用，例如从一个文件系统复制到另一个文件系统。
- en: 'On the surface, the `rsync` command is not much different from `scp`. In fact,
    you can run `rsync` with the same arguments. For example, to copy a group of files
    to your home directory on *host*, enter:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，`rsync`命令与`scp`没有太大区别。实际上，你可以使用相同的参数运行`rsync`。例如，要将一组文件复制到*host*上的主目录，输入：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On any contemporary system, `rsync` assumes that you’re using SSH to connect
    to the remote host.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何现代系统上，`rsync`假设你使用SSH连接到远程主机。
- en: 'Beware of this error message:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 小心这个错误信息：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This notice says that your remote shell can’t find `rsync` on its system. If
    `rsync` is on the remote system but isn’t in the command path for the user on
    that system, use `--rsync-path=``path` to manually specify its location.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提示表示你的远程 shell 无法在系统中找到`rsync`。如果`rsync`已安装在远程系统上，但不在该系统用户的命令路径中，请使用`--rsync-path=``path`手动指定其位置。
- en: 'If the username is different on the two hosts, add `user@` to the remote hostname
    in the command arguments, where `user` is your username on `host`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个主机上的用户名不同，请在命令参数中的远程主机名之前加上`user@`，其中`user`是你在`host`上的用户名：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Unless you supply extra options, `rsync` copies only files. In fact, if you
    specify just the options described so far and you supply a directory `dir` as
    an argument, you’ll see this message:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你提供额外选项，否则`rsync`仅复制文件。事实上，如果你只指定了到目前为止描述的选项，并且提供了一个目录`dir`作为参数，你将看到以下消息：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To transfer entire directory hierarchies—complete with symbolic links, permissions,
    modes, and devices—use the `-a` option. Furthermore, if you want to copy to a
    directory other than your home directory on the remote host, place its name after
    the remote host, like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要传输整个目录结构——包括符号链接、权限、模式和设备——使用`-a`选项。此外，如果你想复制到远程主机上不是你主目录的目录，可以将其名称放在远程主机名后面，如下所示：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Copying directories can be tricky, so if you’re not exactly sure what will
    happen when you transfer the files, use the `-nv` option combination. The `-n`
    option tells `rsync` to operate in “dry run” mode—that is, to run a trial without
    actually copying any files. The `-v` option is for verbose mode, which shows details
    about the transfer and the files involved:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 复制目录可能会比较棘手，所以如果你不完全确定在传输文件时会发生什么，使用`-nv`选项组合。`-n`选项告诉`rsync`以“干跑”模式运行——也就是说，运行一个试验而不实际复制任何文件。`-v`选项用于详细模式，它显示有关传输和文件的详细信息：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output looks like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 12.2.2  Making Exact Copies of a Directory Structure
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.2  精确复制目录结构
- en: By default, `rsync` copies files and directories without considering the previous
    contents of the destination directory. For example, if you transferred directory
    *d* containing the files *a* and *b* to a machine that already had a file named
    *d/c*, the destination would contain *d/a*, *d/b*, and *d/c* after the `rsync`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`rsync` 复制文件和目录时不会考虑目标目录中的先前内容。例如，如果你将包含文件 *a* 和 *b* 的目录 *d* 传输到已经有文件
    *d/c* 的机器上，那么在 `rsync` 执行后，目标目录将包含 *d/a*、*d/b* 和 *d/c*。
- en: 'To make an exact replica of the source directory, you must delete files in
    the destination directory that do not exist in the source directory, such as *d/c*
    in this example. Use the `--delete` option to do that:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了精确复制源目录，你必须删除目标目录中不存在于源目录中的文件，例如此示例中的 *d/c*。使用 `--delete` 选项来实现这一点：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 12.2.3  Using the Trailing Slash
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.3  使用尾部斜杠
- en: 'Be particularly careful when specifying a directory as the source in an `rsync`
    command line. Consider the basic command that we’ve been working with so far:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定目录作为 `rsync` 命令行中的源时，特别需要小心。考虑一下我们迄今为止一直在使用的基本命令：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Upon completion, you’ll have the directory `dir` inside `dest_dir` on `host`.
    [Figure 12-1](#figure12-1) shows an example of how `rsync` normally handles a
    directory with files named *a* and *b*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你将在 `host` 上的 `dest_dir` 内拥有一个名为 `dir` 的目录。[图 12-1](#figure12-1) 显示了 `rsync`
    如何处理一个包含名为 *a* 和 *b* 的文件的目录。
- en: '![f12001](image_fi/500402c12/f12001.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![f12001](image_fi/500402c12/f12001.png)'
- en: 'Figure 12-1: Normal `rsync` copy'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-1：正常的 `rsync` 复制
- en: 'However, adding a slash (`/`) to the source name significantly changes the
    behavior:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在源名称后添加一个斜杠（`/`）会显著改变其行为：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, `rsync` copies everything *inside* `dir` to `dest_dir` on `host` without
    actually creating `dir` on the destination host. Therefore, you can think of a
    transfer of `dir/` as an operation similar to `cp` `dir/* dest_dir` on the local
    filesystem.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`rsync` 会将 `dir` 内的所有内容复制到 `host` 上的 `dest_dir`，但不会在目标主机上实际创建 `dir`。因此，你可以将
    `dir/` 的传输视为类似于在本地文件系统上执行 `cp` `dir/* dest_dir` 的操作。
- en: 'For example, say you have a directory *dir* containing the files *a* and *b*
    (*dir/a* and *dir/b*). You run the trailing-slash version of the command to transfer
    them to the `dest_dir` directory on `host`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个包含文件 *a* 和 *b*（*dir/a* 和 *dir/b*）的目录 *dir*。你运行带有尾部斜杠的命令，将它们传输到 `host`
    上的 `dest_dir` 目录：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When the transfer completes, `dest_dir` contains copies of *a* and *b* but *not*
    *dir*. If, however, you had omitted the trailing `/` on *dir*, `dest_dir` would
    have gotten a copy of *dir* with *a* and *b* inside. Then, as a result of the
    transfer, you’d have files and directories named `dest_dir`*/dir/a* and `dest_dir`*/dir/b*
    on the remote host. [Figure 12-2](#figure12-2) illustrates how `rsync` handles
    the directory structure from [Figure 12-1](#figure12-1) when using a trailing
    slash.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当传输完成后，`dest_dir` 会包含 *a* 和 *b* 的副本，但不包含 *dir*。然而，如果你省略了 *dir* 后面的尾部斜杠，`dest_dir`
    会得到一个名为 *dir* 的副本，其中包含 *a* 和 *b*。然后，作为传输的结果，你将在远程主机上看到名为 `dest_dir`*/dir/a* 和
    `dest_dir`*/dir/b* 的文件和目录。[图 12-2](#figure12-2) 演示了在使用尾部斜杠时，`rsync` 如何处理来自 [图
    12-1](#figure12-1) 的目录结构。
- en: When transferring files and directories to a remote host, accidentally adding
    a `/` after a path would normally be nothing more than a nuisance; you could go
    to the remote host, add the *dir* directory, and put all of the transferred items
    back in *dir*. Unfortunately, there’s a greater potential for disaster when you
    combine the trailing `/` with the `--delete` option; be extremely careful because
    you can easily remove unrelated files this way.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当将文件和目录传输到远程主机时，不小心在路径后加一个 `/` 通常只是一个小麻烦；你可以去远程主机，添加 *dir* 目录，并将所有传输的项目放回 *dir*
    中。不幸的是，当你将尾部斜杠与 `--delete` 选项结合使用时，可能会发生更严重的灾难；务必小心，因为这样你很容易删除不相关的文件。
- en: '![f12002](image_fi/500402c12/f12002.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![f12002](image_fi/500402c12/f12002.png)'
- en: 'Figure 12-2: Effect of trailing slash in `rsync`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-2：尾部斜杠在 `rsync` 中的作用
- en: 12.2.4  Excluding Files and Directories
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.4  排除文件和目录
- en: 'One important feature of `rsync` is its ability to exclude files and directories
    from a transfer operation. For example, say you’d like to transfer a local directory
    called *src* to *host*, but you want to exclude anything named *.git*. You can
    do it like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`rsync` 的一个重要特性是它能够从传输操作中排除文件和目录。例如，假设你想将一个名为 *src* 的本地目录传输到 *host*，但你希望排除任何名为
    *.git* 的文件。你可以这样做：'
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that this command excludes *all* files and directories named *.git* because
    `--exclude` takes a pattern, not an absolute filename. To exclude one specific
    item, specify an absolute path that starts with */*, as shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这条命令排除了所有名为*.git*的文件和目录，因为`--exclude`接受的是模式，而不是绝对文件名。要排除特定项，请指定以`/*`开头的绝对路径，如下所示：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here are a few more tips on how to exclude patterns:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于如何排除模式的技巧：
- en: You can have as many `--exclude` parameters as you like.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以根据需要添加任意多的`--exclude`参数。
- en: If you use the same patterns repeatedly, place them in a plaintext file (one
    pattern per line) and use `--exclude-from=``file`.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你重复使用相同的模式，可以将它们放入一个纯文本文件（每行一个模式），并使用`--exclude-from=``file`。
- en: 'To exclude directories named *item* but include files with this name, use a
    trailing slash: `--exclude=``item``/`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要排除名为*item*的目录，但包括具有该名称的文件，可以使用尾部斜杠：`--exclude=``item``/`。
- en: The exclude pattern is based on a full file or directory name component and
    may contain simple globs (wildcards). For example, `t*s` matches *this*, but it
    does not match *ethers*.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排除模式基于完整的文件或目录名称组件，可以包含简单的通配符。例如，`t*s`匹配*this*，但不匹配*ethers*。
- en: If you exclude a directory or filename but find that your pattern is too restrictive,
    use `--include` to specifically include another file or directory.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你排除一个目录或文件名，但发现你的模式太严格，可以使用`--include`来专门包括另一个文件或目录。
- en: 12.2.5  Checking Transfers, Adding Safeguards, and Using Verbose Mode
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.5  检查传输、添加保障和使用详细模式
- en: To speed operation, `rsync` uses a quick check to determine whether any files
    on the transfer source are already on the destination. The check uses a combination
    of the file size and its last-modified date. The first time you transfer an entire
    directory hierarchy to a remote host, `rsync` sees that none of the files already
    exist at the destination, and it transfers everything. Testing your transfer with
    `rsync -n` verifies this for you.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加速操作，`rsync`使用快速检查来确定传输源中的文件是否已经存在于目标端。该检查结合了文件大小和最后修改日期。当你第一次将整个目录层级传输到远程主机时，`rsync`会发现目标端没有这些文件，因此会传输所有文件。使用`rsync
    -n`进行传输测试可以验证这一点。
- en: After running `rsync` once, run it again using `rsync -v`. This time you should
    see that no files show up in the transfer list because the file set exists on
    both ends, with the same modification dates.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一次`rsync`后，再次使用`rsync -v`运行它。这时你应该会看到传输列表中没有文件，因为文件集在两端都存在，且修改日期相同。
- en: 'When the files on the source side are not identical to the files on the destination
    side, `rsync` transfers the source files and overwrites any files that exist on
    the remote side. The default behavior may be inadequate, though, because you may
    need additional reassurance that files are indeed the same before skipping over
    them in transfers, or you might want to add some extra safeguards. Here are some
    options that come in handy:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当源端的文件与目标端的文件不一致时，`rsync`会传输源文件并覆盖远程端的任何文件。但默认行为可能不够充分，因为你可能需要额外的确认，以确保文件确实相同，或者你可能希望添加一些额外的保障。以下是一些有用的选项：
- en: '`--checksum`(abbreviation: `-c`) Computes checksums (mostly unique signatures)
    of the files to see if they’re the same. This option consumes a small amount of
    I/O and CPU resources during transfers, but if you’re dealing with sensitive data
    or files that often have uniform sizes, this is a must.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`--checksum`（缩写：`-c`）计算文件的校验和（通常是唯一的签名），以检查文件是否相同。此选项在传输过程中会消耗少量的I/O和CPU资源，但如果你处理的是敏感数据或经常具有相同大小的文件，这是必须的。'
- en: '`--ignore-existing` Doesn’t clobber files already on the target side.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`--ignore-existing` 不会覆盖目标端已存在的文件。'
- en: '`--backup`(abbreviation: `-b`) Doesn’t clobber files already on the target
    but rather renames these existing files by adding a `~` suffix to their names
    before transferring the new files.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`--backup`（缩写：`-b`）不会覆盖目标端已存在的文件，而是通过在文件名后添加`~`后缀来重命名这些已存在的文件，然后再传输新文件。'
- en: '`--suffix=s` Changes the suffix used with `--backup` from `~` to `s`.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`--suffix=s` 将`--backup`使用的后缀从`~`改为`s`。'
- en: '`--update`(abbreviation: `-u`) Doesn’t clobber any file on the target that
    has a later date than the corresponding file on the source.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`--update`（缩写：`-u`）不会覆盖目标中比源文件更新的文件。'
- en: With no special options, `rsync` operates quietly, producing output only when
    there’s a problem. However, you can use `rsync -v` for verbose mode or `rsync
    -vv` for even more details. (You can tack on as many `v` options as you like,
    but two is probably more than you need.) For a comprehensive summary after the
    transfer, use `rsync --stats`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有特别选项的情况下，`rsync` 默默运行，只有在出现问题时才会产生输出。然而，你可以使用 `rsync -v` 启用详细模式，或者使用 `rsync
    -vv` 获取更多的细节。（你可以根据需要添加任意多个 `v` 选项，但通常两个 `v` 就足够了。）要在传输完成后获得综合总结，可以使用 `rsync --stats`。
- en: 12.2.6  Compressing Data
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.6  压缩数据
- en: 'Many users like the `-z` option in conjunction with `-a` to compress the data
    before transmission:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 许多用户喜欢将 `-z` 选项与 `-a` 一起使用，在传输前压缩数据：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Compression can improve performance in certain situations, such as when you’re
    uploading a large amount of data across a slow connection (like a slow upstream
    link) or when the latency between the two hosts is high. However, across a fast
    local area network, the two endpoint machines can be constrained by the CPU time
    that it takes to compress and decompress data, so uncompressed transfer may be
    faster.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩可以在某些情况下提高性能，例如当你需要通过慢速连接（如慢速上行链路）上传大量数据，或当两个主机之间的延迟较高时。然而，在快速的局域网中，两个端点机器可能会受到压缩和解压数据所需的
    CPU 时间的限制，因此未压缩的传输可能更快。
- en: 12.2.7  Limiting Bandwidth
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.7  限制带宽
- en: It’s easy to clog the uplink of internet connections when you’re uploading a
    large amount of data to a remote host. Even though you won’t be using your (normally
    large) downlink capacity during such a transfer, your connection will still seem
    quite slow if you let `rsync` go as fast as it can, because outgoing TCP packets
    such as HTTP requests will have to compete with your transfers for bandwidth on
    your uplink.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向远程主机上传大量数据时，很容易堵塞互联网连接的上行链路。尽管在这样的传输过程中你不会使用（通常较大的）下行带宽，如果你让 `rsync` 以最快速度运行，连接仍然会变得相当缓慢，因为如
    HTTP 请求等传出的 TCP 数据包将与你的传输竞争上行带宽。
- en: 'To get around this, use `--bwlimit` to give your uplink a little breathing
    room. For example, to limit the bandwidth to 100,000Kbps, you might do something
    like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，使用 `--bwlimit` 给你的上行链路留一些喘息的空间。例如，要将带宽限制为 100,000Kbps，你可以像这样操作：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 12.2.8  Transferring Files to Your Computer
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.8  将文件传输到你的计算机
- en: 'The `rsync` command isn’t just for copying files from your local machine to
    a remote host. You can also transfer files from a remote machine to your local
    host by placing the remote host and remote source path as the first argument on
    the command line. For example, to transfer `src_dir` on the remote system to `dest_dir`
    on the local host, run this command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`rsync` 命令不仅仅用于将文件从本地机器复制到远程主机。你也可以通过将远程主机和远程源路径作为命令行的第一个参数，来将文件从远程机器传输到本地主机。例如，要将远程系统上的`src_dir`传输到本地主机上的`dest_dir`，请运行以下命令：'
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 12.2.9  Further rsync Topics
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.9  更多 rsync 主题
- en: Whenever you need to copy numerous files, `rsync` should be one of the first
    utilities that comes to mind. Running `rsync` in batch mode is particularly useful
    for copying the same set of files to multiple hosts, because it speeds up long
    transfers and makes it possible to resume when interrupted.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你需要复制大量文件时，`rsync` 应该是你首先想到的工具之一。在批处理模式下运行 `rsync` 对于将相同的文件集复制到多个主机特别有用，因为它能加速长时间的传输并且在中断时能够恢复。
- en: You’ll also find `rsync` useful for making backups. For example, you can attach
    internet storage, such as Amazon’s S3, to your Linux system and then use `rsync
    --delete` to periodically synchronize a filesystem with the network storage to
    implement a very effective backup system.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会发现 `rsync` 对于制作备份非常有用。例如，你可以将互联网存储（如 Amazon 的 S3）附加到你的 Linux 系统上，然后使用 `rsync
    --delete` 定期将文件系统与网络存储同步，从而实现一个非常有效的备份系统。
- en: There are many more command-line options than those described here. For a rough
    overview, run `rsync --help`. You’ll find more detailed information in the rsync(1)
    manual page as well as at the `rsync` home page ([https://rsync.samba.org/](https://rsync.samba.org/)).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的命令行选项只是其中的一部分。要获取大致的概览，请运行 `rsync --help`。你还可以在 `rsync` 的手册页和官网（[https://rsync.samba.org/](https://rsync.samba.org/)）找到更详细的信息。
- en: 12.3 Introduction to File Sharing
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 文件共享简介
- en: Your Linux machine probably doesn’t live alone on your network, and when you
    have multiple machines on a network, there’s nearly always a reason to share files
    among them. For the remainder of this chapter, we’ll first look at file sharing
    between Windows and macOS machines, and you’ll learn more about how Linux adapts
    to interacting with completely foreign environments. For the purpose of sharing
    files between Linux machines or accessing files from a Network Area Storage (NAS)
    device, we’ll wrap up by talking about using SSHFS and the Network File System
    (NFS) as a client.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Linux机器可能并不是在网络上独自存在，当你网络中有多台机器时，几乎总是有理由在它们之间共享文件。在本章的其余部分，我们将首先探讨Windows和macOS机器之间的文件共享，你将了解更多关于Linux如何与完全不同的环境进行交互的内容。为了共享Linux机器之间的文件或访问网络存储设备（NAS）上的文件，我们最后将讨论如何使用SSHFS和网络文件系统（NFS）作为客户端。
- en: 12.3.1  File Sharing Usage and Performance
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.1  文件共享使用和性能
- en: 'One thing you need to ask yourself when working with any kind of file sharing
    system is why you’re doing it in the first place. In traditional Unix-based networks,
    there were two major reasons: convenience and lack of local storage. One user
    could log in to one of several machines on a network, each with access to the
    user’s home directory. It was far more economical to concentrate storage on a
    small number of centralized servers than to buy and maintain a lot of local storage
    for every machine on the network.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用任何类型的文件共享系统时，你需要问自己一个问题，那就是你最初为什么要这么做。在传统的基于Unix的网络中，有两个主要原因：方便和缺乏本地存储。用户可以登录到网络中的一台机器，每台机器都可以访问用户的主目录。将存储集中在少数几个集中式服务器上，比为网络中的每台机器购买和维护大量本地存储要经济得多。
- en: 'This model’s advantages are overshadowed by one major disadvantage that has
    remained constant over the years: network storage performance is often poor compared
    to local storage. Some kinds of data access are okay; for example, contemporary
    hardware and networks have no problems streaming video and audio data from a server
    to a media player in part because the data access pattern is very predictable.
    A server sending the data from a large file or stream can pre-load and buffer
    the data efficiently, because it knows that the client will likely access data
    sequentially.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型的优点被一个长期存在的主要缺点所掩盖：与本地存储相比，网络存储性能通常较差。一些数据访问方式是可以接受的；例如，现代硬件和网络没有问题将视频和音频数据从服务器流式传输到媒体播放器，部分原因在于数据访问模式非常可预测。服务器在发送大文件或流数据时，可以有效地预加载并缓冲数据，因为它知道客户端很可能按顺序访问数据。
- en: However, if you’re doing more complex manipulation or accessing many different
    files at once, you’ll find your CPU waiting on the network more often than not.
    Latency is one of the primary culprits. This is the time it takes to receive data
    from any random (arbitrary) network file access. Before sending any data to the
    client, the server must accept and decipher the request, and then locate and load
    the data. The first steps are often the slowest, and are done for almost every
    new file access.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你进行更复杂的操作或同时访问许多不同的文件，你会发现你的CPU更常在等待网络响应。延迟是主要的罪魁祸首之一。这是接收任何随机（任意）网络文件访问数据所需的时间。在将数据发送到客户端之前，服务器必须接受并解读请求，然后定位并加载数据。前几个步骤通常是最慢的，几乎每次新的文件访问都要执行。
- en: The moral of the story is that when you start thinking about network file sharing,
    ask yourself why you’re doing it. If it’s for large amounts of data not requiring
    frequent random access, you likely won’t have a problem. But if, for example,
    you’re editing video or developing a software system of any substantial size,
    you’ll want to keep all of your files on local storage.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 故事的寓意是，当你开始考虑网络文件共享时，要问自己为什么要这么做。如果是为了存储大量不需要频繁随机访问的数据，你很可能不会遇到问题。但如果你在编辑视频或开发一个大型软件系统时，你会希望将所有文件保存在本地存储中。
- en: 12.3.2  File Sharing Security
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.2  文件共享安全
- en: Traditionally, security in file sharing protocols has not been treated as a
    high priority. This has consequences for how and where you want to implement file
    sharing. If you have any reason to doubt the security of the network(s) between
    the machines sharing files, you’ll want to consider both authorization/authentication
    and encryption in your configuration. Good authorization and authentication means
    that only parties with the correct credentials have access to files (and that
    the server is who it claims to be), and encryption ensures that no one will be
    able steal file data as it transits to its destination.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，文件共享协议中的安全性并未被视为高优先级。这会影响你如何以及在何处实施文件共享。如果你有任何理由怀疑共享文件的机器之间网络的安全性，你需要在配置中考虑授权/认证和加密。良好的授权和认证意味着只有拥有正确凭证的人员才能访问文件（并且服务器是它所声称的身份），而加密确保没有人能够在文件数据传输到目的地的过程中窃取它。
- en: The file sharing options that are the easiest to configure are typically the
    least secure, and unfortunately, there are no standardized ways to secure these
    types of access. However, if you’re willing to put in the work of connecting the
    correct pieces, tools such as stunnel, IPSec, and VPNs can secure the layers below
    basic file sharing protocols.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易配置的文件共享选项通常是最不安全的，不幸的是，目前没有标准化的方法来保障这些访问的安全性。然而，如果你愿意付出努力连接正确的组件，像 stunnel、IPSec
    和 VPN 等工具可以确保基本文件共享协议下方的安全层。
- en: 12.4 Sharing Files with Samba
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4 使用 Samba 共享文件
- en: If you have machines running Windows, you’ll probably want to permit access
    to your Linux system’s files and printers from those Windows machines using the
    standard Windows network protocol, *Server Message Block (SMB)*. macOS supports
    SMB file sharing too, but you can also use SSHFS, described in Section 12.5.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有运行 Windows 的机器，你可能希望通过标准的 Windows 网络协议 *Server Message Block (SMB)* 允许从这些
    Windows 机器访问你 Linux 系统上的文件和打印机。macOS 也支持 SMB 文件共享，但你也可以使用 SSHFS，详见第 12.5 节。
- en: 'The standard file sharing software suite for Unix is called *Samba*. Not only
    does Samba allow your network’s Windows computers to get to your Linux system,
    but it also works the other way around: you can print and access files on Windows
    servers from your Linux machine via its Samba client software.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 的标准文件共享软件套件称为 *Samba*。Samba 不仅允许你网络中的 Windows 计算机访问你的 Linux 系统，而且还可以反向操作：你可以通过其
    Samba 客户端软件，在 Linux 机器上打印并访问 Windows 服务器上的文件。
- en: 'To set up a Samba server, do the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Samba 服务器的步骤如下：
- en: Create an *smb.conf* file.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 *smb.conf* 文件。
- en: Add file sharing sections to *smb.conf*.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 *smb.conf* 中添加文件共享部分。
- en: Add printer sharing sections to *smb.conf*.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将打印机共享部分添加到 *smb.conf* 中。
- en: Start the Samba daemons `nmbd` and `smbd`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Samba 守护进程 `nmbd` 和 `smbd`。
- en: When you install Samba from a distribution package, your system should perform
    these steps using some reasonable defaults for the server. However, it probably
    won’t be able to determine which particular *shares* (resources) on your Linux
    machine you want to offer to clients.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从发行版包中安装 Samba 时，系统应该会执行这些步骤，并为服务器设置一些合理的默认值。然而，它可能无法确定你希望将 Linux 机器上的哪些 *共享*（资源）提供给客户端。
- en: 12.4.1  Server Configuration
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.1  服务器配置
- en: The central Samba configuration file is *smb.conf*, which most distributions
    place in an *etc* directory, such as */etc/samba*. However, you might have to
    hunt around to find this file, as it could also be in a *lib* directory, such
    as */usr/local/samba/lib*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 中央的 Samba 配置文件是 *smb.conf*，大多数发行版将其放置在 *etc* 目录下，例如 */etc/samba*。然而，你可能需要到处查找才能找到该文件，因为它也可能位于
    *lib* 目录下，例如 */usr/local/samba/lib*。
- en: 'The *smb.conf* file format is similar to the XDG style that you’ve seen elsewhere
    (such as the systemd configuration format) and breaks down into several sections
    denoted with square brackets such as `[global]` and `[printers]`. The `[global]`
    section in *smb.conf* contains general options that apply to the entire server
    and all shares. These options primarily pertain to network configuration and access
    control. This sample `[global]` section shows how to set the server name, description,
    and workgroup:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*smb.conf* 文件格式类似于你在其他地方见过的 XDG 风格（例如 systemd 配置格式），并分为几个用方括号表示的部分，如 `[global]`
    和 `[printers]`。*smb.conf* 中的 `[global]` 部分包含适用于整个服务器和所有共享的常规选项。这些选项主要涉及网络配置和访问控制。以下是一个示例
    `[global]` 部分，展示了如何设置服务器名称、描述和工作组：'
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'These parameters work as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数的作用如下：
- en: '`netbios name` The server name. If you omit this parameter, Samba uses the
    Unix hostname. NetBIOS is an API that SMB hosts often employ to talk to one another.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`netbios name` 服务器名称。如果省略此参数，Samba将使用Unix主机名。NetBIOS是一种API，SMB主机经常使用它进行相互通信。'
- en: '`server string` A short description of the server. The default is the Samba
    version number.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`server string` 服务器的简短描述。默认值是Samba版本号。'
- en: '`workgroup` The Windows workgroup name. If you’re on a Windows domain, set
    this parameter to the name of your domain.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`workgroup` Windows工作组名称。如果你在Windows域中，请将此参数设置为你的域名。'
- en: 12.4.2  Server Access Control
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.2  服务器访问控制
- en: 'You can add options to your *smb.conf* file to limit which machines and users
    can access your Samba server. Here are a few of the many options that you can
    set in your `[global]` section and in the sections that control individual shares
    (as described later in the chapter):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*smb.conf*文件中添加选项，以限制哪些机器和用户可以访问你的Samba服务器。以下是你可以在`[global]`部分和控制单独共享资源的部分中设置的一些选项（本章后面会详细描述）：
- en: '`interfaces` Set this to have Samba listen (accept connections) on the given
    networks or interfaces. For example:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`interfaces` 设置此项，使Samba在指定的网络或接口上监听（接受连接）。例如：'
- en: '[PRE19]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`bind interfaces only` Set this to `yes` when using the `interfaces` parameter
    in order to limit access to only the machines that you can directly reach on those
    interfaces.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bind interfaces only` 当使用`interfaces`参数时，将此设置为`yes`，以将访问限制为仅能直接通过这些接口访问的机器。'
- en: '`valid users` Set this to allow the given users access. For example:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`valid users` 设置此项以允许指定用户访问。例如：'
- en: '[PRE20]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`guest ok` Set this parameter to `true` to make a share available to anonymous
    users on the network. Do this only if you’re sure that the network is private.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`guest ok` 将此参数设置为`true`，以使共享资源对网络上的匿名用户可用。仅当你确定网络是私有的时，才这样做。'
- en: '`browseable` Set this to make shares viewable by network browsers. If you set
    this parameter to `no` for any shares, you’ll still be able to access the shares
    on the Samba server, but you’ll need to know their exact names in order to be
    able to access them.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`browseable` 将此设置为使共享资源可以被网络浏览器查看。如果你将此参数设置为`no`，你仍然可以访问Samba服务器上的共享资源，但你需要知道它们的确切名称才能访问。'
- en: 12.4.3  Passwords
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.3  密码
- en: In general, you should allow access to your Samba server only with password
    authentication. Unfortunately, the basic password system on Unix is different
    from that on Windows, so unless you specify cleartext network passwords or authenticate
    passwords with a Windows domain server, you must set up an alternative password
    system. This section shows you how to set up an alternative password system using
    Samba’s *Trivial Database (TDB)* backend, which is appropriate for small networks.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你应该仅允许使用密码认证访问你的Samba服务器。不幸的是，Unix上的基本密码系统与Windows上的不同，因此除非你指定明文网络密码或使用Windows域服务器进行密码验证，否则你必须设置一个替代的密码系统。本节将向你展示如何使用Samba的*简易数据库(TDB)*后端设置替代密码系统，这适用于小型网络。
- en: 'First, use these entries in your *smb.conf* `[global]` section to define the
    Samba password database characteristics:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在你的*smb.conf* `[global]`部分使用以下条目定义Samba密码数据库的特性：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These lines allow you to manipulate the Samba password database with the `smbpasswd`
    command. The `obey pam restrictions` parameter ensures that any user changing
    their password with the `smbpasswd` command must obey any rules that PAM (Pluggable
    Authentication Modules, covered in Chapter 7) enforces for normal password changes.
    For the `passdb backend` parameter, you can optionally specify a pathname for
    the TDB file after a colon—for example, `tdbsam:/etc/samba/private/passwd.tdb`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行允许你使用`smbpasswd`命令操作Samba密码数据库。`obey pam restrictions`参数确保任何通过`smbpasswd`命令更改密码的用户都必须遵守PAM（可插拔认证模块，第7章中介绍）对常规密码更改的限制。对于`passdb
    backend`参数，你可以选择性地在冒号后指定TDB文件的路径名，例如，`tdbsam:/etc/samba/private/passwd.tdb`。
- en: Adding and Deleting Users
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加和删除用户
- en: 'The first thing you need to do to give a Windows user access to your Samba
    server is to add the user to the password database with the `smbpasswd -a` command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让Windows用户访问你的Samba服务器的第一步是使用`smbpasswd -a`命令将用户添加到密码数据库中：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `username` parameter to the `smbpasswd` command must be a valid username
    on your Linux system.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`smbpasswd`命令中的`username`参数必须是你Linux系统上的有效用户名。'
- en: Like the regular system’s `passwd` program, `smbpasswd` asks you to enter the
    new SMB user’s password twice. After the password passes any necessary security
    checks, `smbpasswd` confirms that it has created the new user.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 像常规系统的`passwd`程序一样，`smbpasswd`会要求你输入新SMB用户的密码两次。密码通过必要的安全检查后，`smbpasswd`会确认已创建新用户。
- en: 'To remove a user, use the `-x` option to `smbpasswd`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除用户，请使用`smbpasswd`的`-x`选项：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To just temporarily deactivate the user, use the `-d` option; the `-e` option
    can be used later to reenable the user:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要暂时禁用用户，使用`-d`选项；稍后可以使用`-e`选项重新启用该用户：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Changing Passwords
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更改密码
- en: 'You can change a Samba password as the superuser by using `smbpasswd` with
    no options or keywords other than the username:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`smbpasswd`（除了用户名外不带任何选项或关键字）以超级用户身份更改Samba密码：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: However, if the Samba server is running, any user can change their own Samba
    password by entering `smbpasswd` by itself on the command line.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果Samba服务器正在运行，任何用户都可以通过在命令行中输入`smbpasswd`单独更改自己的Samba密码。
- en: 'Finally, here’s one place in your configuration to beware of. If you see a
    line like this in your *smb.conf* file, be careful:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是配置中的一个需要注意的地方。如果在你的*smb.conf*文件中看到如下行，请小心：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This line causes `smbpasswd` to change a user’s normal password *in addition*
    to the Samba password. The result can be very confusing, especially when a user
    changes their Samba password to something that’s not their Linux password and
    discovers that they can no longer log in to their Linux system. Some distributions
    set this parameter by default in their Samba server packages!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行导致`smbpasswd`在更改用户的普通密码*同时*更改Samba密码。这个结果可能会非常令人困惑，特别是当用户将Samba密码更改为与其Linux密码不同的内容时，他们会发现无法再登录到Linux系统。有些发行版在其Samba服务器包中默认设置此参数！
- en: 12.4.4  Manual Server Startup
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.4  手动启动服务器
- en: 'Typically, you shouldn’t need to worry about starting the server if you installed
    Samba from a distribution package. Check the list from `systemctl --type=service`
    to verify. However, if you installed it from source code, run `nmbd` and `smbd`
    with the following arguments, where `smb_config_file` is the full path of your
    *smb.conf* file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果你是从发行版包安装Samba，应该不需要担心启动服务器。可以通过`systemctl --type=service`查看列表进行验证。然而，如果你是从源代码安装的，运行`nmbd`和`smbd`并传入以下参数，其中`smb_config_file`是你的*smb.conf*文件的完整路径：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `nmbd` daemon is a NetBIOS name server, and `smbd` does the actual work
    of handling share requests. The `-D` option specifies daemon mode. If you alter
    the *smb.conf* file while `smbd` is running, you can notify the daemon of the
    changes with a HUP signal, though it’s almost always for the better if you let
    systemd supervise the server, in which case you can get `systemctl` to do the
    work for you.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`nmbd`守护进程是一个NetBIOS名称服务器，而`smbd`则负责处理共享请求。`-D`选项指定守护进程模式。如果在`smbd`运行时修改了*smb.conf*文件，可以通过HUP信号通知守护进程这些更改，尽管通常来说，如果让systemd管理服务器会更好，在这种情况下，你可以让`systemctl`为你处理这些工作。'
- en: 12.4.5  Diagnostics and Logfiles
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.5  诊断与日志文件
- en: If something goes wrong when a Samba server starts up, an error message appears
    on the command line. However, runtime diagnostic messages go to the *log.nmbd*
    and *log.smbd* logfiles, which are usually in a */var/log* directory, such as
    */var/log/samba*. You’ll also find other logfiles there, such as individual logs
    for each individual client.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Samba服务器启动时出现问题，命令行上会出现错误消息。然而，运行时诊断消息会被写入到*log.nmbd*和*log.smbd*日志文件中，通常位于*/var/log*目录下，例如*/var/log/samba*。你还会在那里找到其他日志文件，比如每个单独客户端的日志。
- en: 12.4.6  File Share Configuration
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.6  文件共享配置
- en: 'To export a directory to SMB clients (that is, to share a directory with a
    client), add a section like this to your *smb.conf* file, where `label` is what
    you would like to call the share (such as `mydocuments`) and `path` is the full
    directory path:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要将目录导出到SMB客户端（即与客户端共享目录），请将以下类似内容添加到你的*smb.conf*文件中，其中`label`是你希望为共享命名的名称（例如`mydocuments`），`path`是完整的目录路径：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'These parameters are useful in directory shares:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数在目录共享中非常有用：
- en: '`guest ok` A `yes` setting here allows guest access to the share. The `public`
    parameter is a synonym.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`guest ok` 在此设置为`yes`时，允许来宾访问共享。`public` 参数是其同义词。'
- en: '`writable` A `yes` or `true` setting here marks the share as read-write. Do
    not allow guest access to a read-write share.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`writable` 设置为`yes`或`true`时，表示共享为可读写。不要允许来宾访问可读写的共享。'
- en: '`printable` Obviously, on a directory share, this parameter must be set to
    `no` or `false`.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`printable` 显然，在目录共享上，必须将此参数设置为`no`或`false`。'
- en: '`veto files` This parameter prevents the export of any files that match the
    given patterns. You must enclose each pattern between forward slashes (so that
    it looks like `/pattern/`). This example bars object files, as well as any file
    or directory named *bin*:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`veto files` 该参数防止导出与给定模式匹配的任何文件。您必须将每个模式用斜杠括起来（使其看起来像`/pattern/`）。此示例禁止对象文件以及任何名为*bin*的文件或目录：'
- en: '[PRE29]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 12.4.7  Home Directories
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.7  主目录
- en: 'You can add a section called `[homes]` to your *smb.conf* file if you want
    to export home directories to users. The section should look like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望将用户的主目录导出，可以在您的*smb.conf*文件中添加一个名为`[homes]`的部分。该部分应如下所示：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'By default, Samba reads the logged-in user’s */etc/passwd* entry to determine
    their home directory for `[homes]`. However, if you don’t want Samba to follow
    this behavior (that is, you want to keep the Windows home directories in a different
    place than the regular Linux home directories), you can use the `%S` substitution
    in a `path` parameter. For example, here’s how you would switch a user’s `[homes]`
    directory to */u/user*:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Samba读取已登录用户的*/etc/passwd*条目，以确定其`[homes]`的主目录。然而，如果您不希望Samba遵循此行为（即，您希望将Windows主目录存放在与常规Linux主目录不同的位置），您可以在`path`参数中使用`%S`替代符。例如，您可以通过以下方式将用户的`[homes]`目录切换到*/u/user*：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Samba substitutes the current username for the `%S`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Samba将当前用户名替换为`%S`。
- en: 12.4.8  Printer Sharing
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.8  打印机共享
- en: 'You can export your printers to Windows clients by adding a `[printers]` section
    to your *smb.conf* file. Here’s how the section looks when you’re using CUPS,
    the standard Unix printing system:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在*smb.conf*文件中添加`[printers]`部分，将打印机导出到Windows客户端。当您使用CUPS（标准Unix打印系统）时，该部分如下所示：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To use the `printing = CUPS` parameter, your Samba installation must be configured
    and linked against the CUPS library.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`printing = CUPS`参数，您的Samba安装必须配置并链接到CUPS库。
- en: 12.4.9  The Samba Client
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.9  Samba客户端
- en: The Samba client program `smbclient` can print to and access remote Windows
    shares. This program comes in handy when you’re in an environment where you must
    interact with Windows servers that don’t offer a Unix-friendly means of communication.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Samba客户端程序`smbclient`可以打印和访问远程Windows共享。当您处于必须与不提供Unix友好通信方式的Windows服务器交互的环境中时，这个程序非常有用。
- en: 'To get started with `smbclient`, use the `-L` option to get a list of shares
    from a remote server named `SERVER`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用`smbclient`，请使用`-L`选项获取名为`SERVER`的远程服务器的共享列表：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You don’t need `-U` `username` if your Linux username is the same as your username
    on `SERVER`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的Linux用户名与`SERVER`上的用户名相同，则不需要`-U` `username`。
- en: 'After you run this command, `smbclient` asks for a password. To try to access
    a share as a guest, press enter; otherwise, enter your password on `SERVER`. Upon
    success, you should get a share list like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，`smbclient`会要求输入密码。要尝试以访客身份访问共享，请按回车；否则，在`SERVER`上输入您的密码。成功后，您应该会看到如下共享列表：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Use the `Type` field to help you make sense of each share, and pay attention
    only to the `Disk` and `Printer` shares (the `IPC` shares are for remote management).
    This list has two disk shares and two printer shares. Use the name in the `Sharename`
    column to access each share.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Type`字段帮助您理解每个共享的类型，并仅关注`Disk`和`Printer`共享（`IPC`共享用于远程管理）。此列表包含两个磁盘共享和两个打印机共享。使用`Sharename`列中的名称访问每个共享。
- en: Accessing Files as a Client
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 作为客户端访问文件
- en: 'If you need only casual access to files in a disk share, use the following
    command (again, you can omit the `-U` `username` if your Linux username matches
    your username on the server):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仅需要偶尔访问磁盘共享中的文件，可以使用以下命令（如果您的Linux用户名与服务器上的用户名相同，可以省略`-U` `username`）：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Upon success, you will get a prompt like this, indicating that you can now
    transfer files:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，您将看到类似于此的提示，表示现在可以传输文件：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this file transfer mode, `smbclient` is similar to the Unix `ftp`, and you
    can run these commands:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件传输模式下，`smbclient`类似于Unix的`ftp`，您可以运行以下命令：
- en: '`get` `file` Copies `file` from the remote server to the current local directory.'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get` `file` 将`file`从远程服务器复制到当前本地目录。'
- en: '`put` `file` Copies `file` from the local machine to the remote server.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`put` `file` 将`file`从本地计算机复制到远程服务器。'
- en: '`cd` `dir` Changes the directory on the remote server to `dir`.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cd` `dir` 将远程服务器上的目录更改为`dir`。'
- en: '`lcd` `localdir` Changes the current local directory to `localdir`.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lcd` `localdir` 将当前本地目录更改为`localdir`。'
- en: '`pwd` Prints the current directory on the remote server, including the server
    and share names.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pwd` 打印远程服务器上的当前目录，包括服务器和共享名称。'
- en: '`!``command` Runs `command` on the local host. Two particularly handy commands
    are `!pwd` and `!ls` to determine directory and file status on the local side.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`!``command` 在本地主机上运行`command`。两个特别实用的命令是`!pwd`和`!ls`，用于查看本地的目录和文件状态。'
- en: '`help` Shows a full list of commands.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`help` 显示完整的命令列表。'
- en: Using the CIFS Filesystem
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用CIFS文件系统
- en: 'If you’d like to have more convenient access to files on a Windows server,
    you can attach a share directly to your system with `mount`. The command syntax
    is as follows (notice the use of `SERVER``:``sharename` rather than the normal
    `\\``SERVER``\``sharename` format):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望更方便地访问Windows服务器上的文件，可以直接使用`mount`将共享连接到你的系统。命令语法如下（注意使用`SERVER``:``sharename`而不是正常的`\\``SERVER``\``sharename`格式）：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In order to use `mount` like this, you must have the Common Internet File System
    (CIFS) utilities installed on your system. Most distributions offer these as a
    separate package.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了像这样使用`mount`，你必须在系统上安装通用互联网文件系统（CIFS）工具。大多数发行版将其作为一个单独的包提供。
- en: 12.5 SSHFS
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.5 SSHFS
- en: With Windows file sharing systems out of the way, in this section we’ll discuss
    file sharing between Linux systems. For scenarios that aren’t particularly complicated,
    a convenient option to consider is SSHFS. This is nothing more than a user-space
    filesystem that opens an SSH connection and presents the files on the other side
    at a mount point on your machine. Most distributions don’t install it by default,
    so you might need to install your distribution’s SSHFS package.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决了Windows文件共享系统的问题后，本节将讨论Linux系统之间的文件共享。对于一些不特别复杂的场景，SSHFS是一个方便的选择。这不过是一个用户空间的文件系统，它打开一个SSH连接并在你的机器上以挂载点的形式呈现远程端的文件。大多数发行版默认不安装它，因此你可能需要安装对应发行版的SSHFS包。
- en: 'The syntax for using SSHFS on the command line looks superficially similar
    to SSH commands that you’ve seen before. Of course, you need to supply the shared
    directory (on the remote host) and the desired mount point:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中使用SSHFS的语法在表面上看起来与以前看到的SSH命令相似。当然，你需要提供共享目录（在远程主机上）和所需的挂载点：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Just like in SSH, you can drop the `username``@` if the username is the same
    on the remote host, and you can also omit `:``dir` if you just want to mount the
    home directory on the other side. This command asks for the password on the other
    side if necessary.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在SSH中一样，如果远程主机上的用户名相同，你可以省略`username``@`，如果你只想挂载远程主机的主目录，也可以省略`:``dir`。如果需要，命令会要求输入远程主机的密码。
- en: 'Because this is a user-space filesystem, you have to unmount it with `fusermount`
    if you’re running this as a regular user:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个用户空间的文件系统，如果以普通用户身份运行，你必须使用`fusermount`来卸载它：
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The superuser can also unmount these filesystems with `umount`. To ensure consistency
    of ownership and security, this type of filesystem is usually best mounted as
    a regular user.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 超级用户也可以使用`umount`卸载这些文件系统。为了确保所有权和安全性的一致性，通常最好以普通用户身份挂载此类文件系统。
- en: 'SSHFS has these advantages:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: SSHFS具有以下优点：
- en: It has minimal setup. The only requirement on the remote host is that SFTP is
    enabled, and most SSH servers enable it by default.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的设置非常简单。远程主机的唯一要求是启用SFTP，而大多数SSH服务器默认启用它。
- en: It’s not dependent on any kind of specific network configuration. If you can
    open an SSH connection, SSHFS will work, regardless if it’s on a secure local
    network or over an insecure remote network.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不依赖于任何特定的网络配置。如果你能够建立SSH连接，SSHFS就能工作，无论是在安全的本地网络还是不安全的远程网络上。
- en: 'The disadvantages of SSHFS are:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: SSHFS的缺点是：
- en: Performance suffers. There is a lot of overhead in encryption, translation,
    and transport (but it may not be as bad as you expect).
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能较差。加密、转换和传输存在大量开销（但可能没有你想象的那么糟糕）。
- en: Multiuser setups are limited.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多用户设置有限。
- en: It’s definitely worth trying SSHFS if you think it might work for you, because
    it’s so easy to set up.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为SSHFS可能对你有用，它绝对值得一试，因为它非常容易设置。
- en: 12.6 NFS
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.6 NFS
- en: One of the most commonly used traditional systems for file sharing among Unix
    systems is NFS, and there are many different versions of NFS for different scenarios.
    You can serve NFS over TCP and UDP, with a large number of authentication and
    encryption options (very few of which are enabled by default, unfortunately).
    Because there are so many options, NFS can be a big topic, so we’ll just stick
    to the bare minimum of coverage.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix系统中，NFS是最常用的传统文件共享系统之一，而且根据不同的场景，NFS有许多不同的版本。你可以通过TCP和UDP提供NFS，提供大量的认证和加密选项（但不幸的是，默认情况下很少启用）。由于选项繁多，NFS可能是一个庞大的话题，所以我们这里只讨论最基本的内容。
- en: 'To mount a remote directory on a server with NFS, use the same basic syntax
    as for mounting a CIFS directory:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要在服务器上挂载远程目录，使用与挂载CIFS目录相同的基本语法：
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Technically, you don’t need the `-t nfs` option because `mount` should figure
    this out for you, but you may want to investigate the options in the nfs(5) manual
    page. You’ll find several different options for security using the `sec` option.
    Many administrators on small, closed networks use host-based access control. More
    sophisticated methods, such as Kerberos-based authentication, require additional
    configuration on other parts of your system.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，你不需要`-t nfs`选项，因为`mount`应该能够自动识别，但你可能需要查看nfs(5)手册页中的选项。你会发现有几个不同的安全选项可以使用`sec`选项进行配置。许多小型封闭网络的管理员使用基于主机的访问控制。更复杂的方法，如基于Kerberos的认证，需要在系统的其他部分进行额外配置。
- en: When you find that you’re making greater use of filesystems over a network,
    set up the automounter so that your system will mount the filesystems only when
    you actually try to use them in order to prevent problems with dependencies on
    boot. The traditional automounting tool was called automount, and there’s a newer
    version called amd, but much of this functionality has now been supplanted by
    the automount unit type in systemd.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发现自己更多地依赖网络上的文件系统时，设置自动挂载器，这样你的系统只有在你实际尝试使用这些文件系统时才会挂载它们，从而避免启动时由于依赖关系问题导致的故障。传统的自动挂载工具叫做automount，新的版本叫做amd，但许多功能现在已经被systemd中的自动挂载单元类型所取代。
- en: 12.7 Cloud Storage
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.7 云存储
- en: 'Speaking of cloud backups, another network file storage option is cloud storage,
    such as AWS S3 or Google Cloud Storage. These systems don’t have the performance
    of storage on a local network, but they do offer two significant advantages: you
    never have to maintain them, and you shouldn’t have to worry about backups.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 说到云备份，另一种网络文件存储选项是云存储，例如AWS S3或Google Cloud Storage。这些系统的性能不及本地网络存储，但它们提供了两个重要的优势：你不必维护它们，而且你不必担心备份。
- en: Aside from the web (and programmatic) interfaces that all cloud storage providers
    offer, there are ways to mount most kinds of cloud storage on a Linux system.
    Unlike most of the filesystems that we’ve seen so far, these are nearly all implemented
    as FUSE (File System in User Space) interfaces. For some popular cloud storage
    providers such as S3, there are even multiple options. This makes sense, because
    a FUSE handler is nothing more than a user-space daemon that acts as an intermediary
    between the data source and the kernel.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有云存储提供商提供的网页（和程序接口）之外，还有方法可以在Linux系统上挂载大多数类型的云存储。与我们迄今为止看到的大多数文件系统不同，这些几乎都作为FUSE（用户空间文件系统）接口实现。对于一些流行的云存储提供商，如S3，甚至有多个选项可供选择。这是有道理的，因为FUSE处理程序只不过是一个用户空间的守护进程，充当数据源和内核之间的中介。
- en: This book doesn’t cover the specifics of setting up a cloud storage client,
    because every one is different.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不涉及设置云存储客户端的具体细节，因为每个客户端的设置方式都不同。
- en: 12.8 The State of Network File Sharing
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.8 网络文件共享的现状
- en: At this point, you might feel that this discussion of the NFS and file sharing
    in general seems somewhat incomplete—and it might be, but only as much as the
    file sharing systems themselves. We discussed performance and security concerns
    in Sections 12.3.1 and 12.3.2. In particular, the base security level of NFS is
    quite low, requiring significant extra work to improve. CIFS systems are somewhat
    better in this regard, as the necessary encryption layers are built into contemporary
    software. However, performance limitations aren’t easy to overcome, not to mention
    how badly a system can perform when it is temporarily unable to access its network
    storage.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可能会觉得关于NFS和文件共享的讨论似乎有些不完整——这也许是，因为文件共享系统本身就是如此。我们在第12.3.1节和12.3.2节讨论了性能和安全性问题。特别是，NFS的基本安全性较低，需要做大量额外工作来提升。CIFS系统在这方面稍微好一些，因为必要的加密层已经内置到当代软件中。然而，性能的限制很难克服，更不用说当系统暂时无法访问其网络存储时，它的性能会变得多么糟糕。
- en: There have been several attempts to deal with this issue. Perhaps the most extensive
    is the Andrew File System (AFS), first designed in the 1980s, which was built
    around solutions to these problems. So why doesn’t everyone use AFS or something
    like it?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有多次尝试来解决这个问题。也许最广泛的尝试是Andrew文件系统（AFS），它最早在1980年代设计，围绕这些问题的解决方案构建。那么，为什么不是每个人都使用AFS或类似的系统呢？
- en: There is no one answer to this question, but much of it comes down to a certain
    lack of flexibility in some parts of the design. For example, the security mechanism
    requires a Kerberos authentication system. Though universally available, it has
    never been standard on Unix systems, and requires a nontrivial amount of work
    to set up and maintain (you have to set up a server for it).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题没有唯一答案，但很大程度上归结于设计中的某些部分缺乏灵活性。例如，安全机制需要Kerberos身份验证系统。尽管它在全球范围内都有提供，但它从未在Unix系统上成为标准，而且需要进行不小的工作才能设置和维护（你必须为其设置一个服务器）。
- en: For a large institution, fulfilling requirements such as Kerberos isn’t a problem.
    This is exactly the setting in which AFS has thrived; universities and financial
    institutions are big AFS sites. But for the small user, it’s simply easier not
    to do it, preferring simpler options like NFS or CIFS shares. This sort of limitation
    even extends to Windows; starting with Windows 2000, Microsoft switched to Kerberos
    as the default authentication on its server product, but small networks don’t
    tend to be Windows domains with this kind of server.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型机构，满足像Kerberos这样的要求并不成问题。这正是AFS得以蓬勃发展的环境；大学和金融机构是大型AFS站点。但对于小型用户来说，简单的选择如NFS或CIFS共享更为便捷，因此他们更倾向于不使用这些复杂的选项。即便是Windows系统也存在这种限制；从Windows
    2000开始，微软将Kerberos作为其服务器产品的默认身份验证方式，但小型网络通常不会是具有这种服务器的Windows域。
- en: Aside from the authentication prerequisite, there’s a problem that stems from
    more technical reasons. Many network filesystem clients have traditionally been
    kernel code, NFS in particular. Unfortunately, the requirements of network filesystems
    are complex enough that problems start to occur. The authentication alone has
    no place in the kernel. A kernel client implementation also severely limits the
    potential developer base for a network filesystem, hampering the system as a whole.
    In some cases, client code was in user space, but there was always some sort of
    kernel customization underneath.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 除了身份验证的前提条件外，还有一个来自技术原因的问题。许多网络文件系统客户端传统上是内核代码，特别是NFS。不幸的是，网络文件系统的需求复杂到开始出现问题。仅身份验证就无法放置在内核中。内核客户端实现还严重限制了网络文件系统的潜在开发者基础，从而阻碍了整个系统的发展。在某些情况下，客户端代码位于用户空间，但底层总有一些内核定制。
- en: At the moment, we find ourselves without a truly standard means of network file
    sharing in the Linux/Unix world (at least if you’re not a large site or you aren’t
    willing to put in a fair amount of work). However, this won’t necessarily always
    be the case.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在Linux/Unix世界中，我们没有一种真正标准的网络文件共享方式（至少如果你不是大型站点或者不愿意投入大量精力的话）。然而，这种情况不一定会永远如此。
- en: When providers started to offer cloud storage, it was clear that the traditional
    forms of network file sharing wouldn’t be suitable. In the cloud, access methods
    are built on top of security mechanisms such as TLS that make it possible to access
    storage without setting up a large system such as Kerberos. As mentioned in the
    preceding section, there are many options available via FUSE to access cloud storage.
    We’re no longer dependent on the kernel for any part of the client; any kind of
    authentication, encryption, or handling can easily be done in user space.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供商开始提供云存储时，很明显传统的网络文件共享方式已经不再适用。在云中，访问方法建立在安全机制之上，例如TLS，使得无需设置像Kerberos这样的大型系统就能访问存储。正如前一部分提到的，通过FUSE有许多选项可以访问云存储。我们不再依赖内核来处理客户端的任何部分；任何形式的身份验证、加密或处理都可以轻松地在用户空间完成。
- en: All of this means that the future could very well see some file-sharing designs
    incorporating more flexibility in security and other areas such as filename translation.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些意味着，未来可能会看到一些文件共享设计在安全性和其他领域（如文件名转换）方面融入更多灵活性。
