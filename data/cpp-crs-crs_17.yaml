- en: '**14'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**14'
- en: ITERATORS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器**
- en: '*Say “friend” and enter.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*说“朋友”然后进入。'
- en: —J.R.R. Tolkein*, The Lord of the Rings
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —J.R.R. 托尔金*, 《魔戒》
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Iterators are the STL component that provides the interface between containers
    and algorithms to manipulate them. An iterator is an interface to a type that
    knows how to traverse a particular sequence and exposes simple, pointer-like operations
    to elements.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是 STL 组件，用于提供容器和算法之间的接口以操作它们。迭代器是一个接口，指向知道如何遍历特定序列的类型，并暴露类似指针的简单操作来访问元素。
- en: 'Every iterator supports at least the following operations:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 每个迭代器至少支持以下操作：
- en: Access the current element (`operator*`) for reading and/or writing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问当前元素（`operator*`）进行读取和/或写入
- en: Go to the next element (`operator++`)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转到下一个元素（`operator++`）
- en: Copy construct
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拷贝构造
- en: Iterators are categorized based on which additional operations they support.
    These categories determine which algorithms are available and what you can do
    with an iterator in your generic code. In this chapter, you’ll learn about these
    iterator categories, convenience functions, and adapters.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器根据支持的额外操作进行分类。这些类别决定了哪些算法可用，以及你可以在通用代码中对迭代器做什么。在本章中，你将学习这些迭代器类别、便利函数和适配器。
- en: '**Iterator Categories**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**迭代器类别**'
- en: An iterator’s category determines the operations it supports. These operations
    include reading and writing elements, iterating forward and backward, reading
    multiple times, and accessing random elements.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器的类别决定了它支持的操作。这些操作包括读取和写入元素、前向和后向遍历、重复读取和访问随机元素。
- en: Because code that accepts an iterator is usually generic, the iterator’s type
    is typically a template parameter that you can encode with concepts, which you
    learned about in “Concepts” on [page 163](ch06.xhtml#page_163). Although you probably
    won't have to interact with iterators directly (unless you’re writing a library),
    you’ll still need to know the iterator categories so you don’t try to apply an
    algorithm to inappropriate iterators. If you do, you’re likely to get cryptic
    compiler errors. Recall from “Type Checking in Templates” on [page 161](ch06.xhtml#page_161)
    that because of how templates instantiate, error messages generated from inappropriate
    type arguments are usually inscrutable.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接受迭代器的代码通常是通用的，因此迭代器的类型通常是一个模板参数，你可以通过概念来编码它，正如你在“概念”一章中学习的那样，见[第163页](ch06.xhtml#page_163)。尽管你可能不需要直接与迭代器交互（除非你在编写库），但你仍然需要了解迭代器的类别，以免将算法应用于不合适的迭代器。如果你这么做了，可能会遇到难以理解的编译器错误。回想一下在“模板中的类型检查”一章中提到的内容，见[第161页](ch06.xhtml#page_161)，由于模板实例化的方式，从不适当类型参数生成的错误消息通常是难以理解的。
- en: '***Output Iterators***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***输出迭代器***'
- en: You can use an *output iterator* to write into and increment but nothing else.
    Think of an output iterator as a bottomless pit that you throw data into.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 *输出迭代器* 来写入并递增，但不能做其他操作。可以将输出迭代器视为一个无底洞，你将数据丢入其中。
- en: When using an output iterator, you write, then increment, then write, then increment,
    ad nauseam. Once you’ve written to an output iterator, you cannot write again
    until you’ve incremented at least once. Likewise, once you’ve incremented an output
    iterator, you cannot increment again before writing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用输出迭代器时，你先写入，再递增，再写入，再递增，一直如此。一旦你向输出迭代器写入内容，在至少递增一次之前不能再写入。同样，向输出迭代器递增之后，在写入之前不能再递增。
- en: To write to an output iterator, dereference the iterator using the dereference
    operator (`*`) and assign a value to the resulting reference. To increment an
    output iterator, use `operator++` or `operator++(int)`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要向输出迭代器写入内容，使用解引用操作符（`*`）解引用迭代器，并将值赋给结果引用。要递增输出迭代器，使用 `operator++` 或 `operator++(int)`。
- en: Again, unless you’re writing a C++ library, it’s unlikely that you’ll have to
    *implement* your own output iterator types; however, you’ll *use* them quite a
    lot.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，除非你在编写 C++ 库，否则不太可能需要*实现*自己的输出迭代器类型；然而，你会*频繁使用*它们。
- en: One prominent usage is writing into containers as if they were output iterators.
    For this, you use insert iterators.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的用法是像使用输出迭代器一样写入容器。为此，你可以使用插入迭代器。
- en: '**Insert Iterators**'
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**插入迭代器**'
- en: 'An *insert iterator* (or *inserter*) is an output iterator that wraps a container
    and transforms writes (assignments) into insertions. Three insert iterators exist
    in the STL’s `<iterator>` header as class templates:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*插入迭代器*（或 *插入器*）是一个输出迭代器，它包装一个容器，并将写操作（赋值）转化为插入操作。STL 的 `<iterator>` 头文件中有三个插入迭代器，作为类模板存在：'
- en: '`std::back_insert_iterator`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::back_insert_iterator`'
- en: '`std::front_insert_iterator`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::front_insert_iterator`'
- en: '`std::insert_iterator`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::insert_iterator`'
- en: 'The STL also offers three convenience functions for building these iterators:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: STL 还提供了三个便利函数，用于构建这些迭代器：
- en: '`std::back_inserter`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::back_inserter`'
- en: '`std::front_inserter`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::front_inserter`'
- en: '`std::inserter`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::inserter`'
- en: The `back_insert_iterator` transforms iterator writes into calls to the container’s
    `push_back`, whereas `front_insert_iterator` calls to `push_front`. Both of these
    insert iterators expose a single constructor that accepts a container reference,
    and their corresponding convenience functions take a single argument. Obviously,
    the wrapped container must implement the appropriate method. For example, a `vector`
    won’t work with a `front_insert_iterator`, and a `set` won’t work with either
    of them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`back_insert_iterator` 将迭代器写入操作转换为对容器 `push_back` 的调用，而 `front_insert_iterator`
    则是调用 `push_front`。这两种插入迭代器都公开了一个接受容器引用的构造函数，而它们对应的便利函数只接受一个参数。显然，被包装的容器必须实现相应的方法。例如，`vector`
    不适用于 `front_insert_iterator`，而 `set` 也不适用于这两者。'
- en: 'The `insert_iterator` takes two constructor arguments: a container to wrap
    and an iterator pointing into a position in that container. The `insert_iterator`
    then transforms writes into calls to the container’s `insert` method, and it will
    pass the position you provided on construction as the first argument. For example,
    you use the `insert_iterator` to insert into the middle of a sequential container
    or to add elements into a `set` with a hint.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert_iterator` 接受两个构造函数参数：一个容器用于包装，另一个是指向该容器中某个位置的迭代器。然后，`insert_iterator`
    将写入操作转换为对容器 `insert` 方法的调用，并将你在构造时提供的位置作为第一个参数。例如，你可以使用 `insert_iterator` 将元素插入到顺序容器的中间，或者在
    `set` 中带提示地添加元素。'
- en: '**NOTE**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Internally, all the insert iterators completely ignore `operator++`, `operator++(int)`,
    and `operator*`. Containers don’t need this intermediate step between insertions,
    but it’s generally a requirement for output iterators.*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*在内部，所有的插入迭代器完全忽略 `operator++`、`operator++(int)` 和 `operator*`。容器不需要在插入之间执行这个中间步骤，但这通常是输出迭代器的一个要求。*'
- en: '[Listing 14-1](ch14.xhtml#ch14ex01) illustrates the basic usages of the three
    insert iterators by adding elements to a `deque`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码示例 14-1](ch14.xhtml#ch14ex01) 通过向 `deque` 添加元素，展示了三种插入迭代器的基本用法。'
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 14-1: Insert iterators convert writes into container insertions.*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码示例 14-1：插入迭代器将写入操作转换为容器插入。*'
- en: First, you build a `back_insert_iterator` with `back_inserter` to wrap a `deque`
    called `dq` ➊. When you write into the `back_insert_iterator`, it translates the
    write into a `push_back`, so the `deque` contains a single element, `2` ➋. Because
    output iterators require incrementing before you can write again, you follow with
    an increment ➌. When you write `4` to the `back_insert_iterator`, it again translates
    the write into a `push_back` so the `deque` contains the elements `2 4` ➍.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你使用 `back_inserter` 构建一个 `back_insert_iterator` 来包装一个名为 `dq` 的 `deque` ➊。当你向
    `back_insert_iterator` 写入时，它会将写入操作转换为 `push_back`，因此 `deque` 只包含一个元素 `2` ➋。因为输出迭代器在再次写入之前需要进行递增操作，所以你接着进行一次递增
    ➌。当你向 `back_insert_iterator` 写入 `4` 时，它会再次将写入操作转换为 `push_back`，使得 `deque` 包含元素
    `2 4` ➍。
- en: Next, you build a `front_insert_iterator` with `front_inserter` to wrap `dq`
    ➎. Writing `1` into this newly constructed inserter results in a call to `push_front`,
    so the deque contains the elements `1 2 4` ➏.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以使用 `front_inserter` 构建一个 `front_insert_iterator` 来包装 `dq` ➎。将 `1` 写入这个新构造的插入器时，它会调用
    `push_front`，因此双端队列包含元素 `1 2 4` ➏。
- en: Finally, you build an `insert_iterator` with `inserter` by passing `dq` and
    an iterator pointing to its third element (`4`). When you write 3 into this inserter
    ➑, it inserts just before the element pointed to by the iterator you passed at
    construction ➐. This results in `dq` containing the elements `1 2 3 4` ➒.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以通过传递 `dq` 和一个指向其第三个元素（`4`）的迭代器，使用 `inserter` 构建一个 `insert_iterator`。当你向这个插入器写入
    `3` ➑ 时，它会将元素插入到由构造时传入的迭代器所指向元素之前 ➐。最终，`dq` 包含元素 `1 2 3 4` ➒。
- en: '[Table 14-1](ch14.xhtml#ch14tab01) summarizes the insert iterators.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 14-1](ch14.xhtml#ch14tab01) 总结了插入迭代器。'
- en: '**Table 14-1:** Summary of Insert Iterators'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 14-1：** 插入迭代器汇总'
- en: '| **Class** | **Convenience function** | **Delegated function** | **Example
    containers** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **类** | **便利函数** | **委托函数** | **示例容器** |'
- en: '| `back_insert_iterator` | `back_inserter` | `push_back` | vectors, deques,
    lists |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `back_insert_iterator` | `back_inserter` | `push_back` | 向量、双端队列、列表 |'
- en: '| `front_insert_iterator` | `front_inserter` | `push_front` | deques, lists
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `front_insert_iterator` | `front_inserter` | `push_front` | 双端队列、列表 |'
- en: '| `insert_iterator` | `inserter` | `insert` | vectors, deques, lists, sets
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `insert_iterator` | `inserter` | `insert` | 向量，双端队列，列表，集合 |'
- en: '**List of Supported Output Iterator Operations**'
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**支持的输出迭代器操作列表**'
- en: '[Table 14-2](ch14.xhtml#ch14tab02) summarizes the output iterator’s supported
    operations.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 14-2](ch14.xhtml#ch14tab02)总结了输出迭代器支持的操作。'
- en: '**Table 14-2:** Output Iterator’s Supported Operations'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 14-2：** 输出迭代器支持的操作'
- en: '| **Operation** | **Notes** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| `*`itr`=`t | Writes into the output iterator. After operation, iterator is
    incrementable but not necessarily dereferencable. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `*`itr`=`t | 写入输出迭代器。操作后，迭代器可以递增，但不一定可以解引用。 |'
- en: '| `++`itritr`++` | Increments the iterator. After operation, iterator is either
    dereferencable or exhausted (past the end) but is not necessarily incrementable.
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `++`itr`++` | 递增迭代器。操作后，迭代器要么可以解引用，要么已耗尽（超出末尾），但不一定可以递增。 |'
- en: '| iterator-type`{` itr `}` | Copy-constructs an iterator from itr. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 迭代器类型`{` itr `}` | 从`itr`拷贝构造一个迭代器。 |'
- en: '***Input Iterators***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***输入迭代器***'
- en: You can use an *input iterator* to *read from*, *increment*, and check for equality.
    It’s the foil to the output iterator. You can only iterate through an input iterator
    once.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用*输入迭代器*来*读取*、*递增*并检查相等性。它是输出迭代器的对立面。你只能通过输入迭代器遍历一次。
- en: The usual pattern when reading from an input iterator is to obtain a half-open
    range with a *begin* and an *end* iterator. To read through the range, you read
    the `begin` iterator using `operator*` followed by an increment with `operator++`.
    Next, you evaluate whether the iterator equals `end`. If it does, you’ve exhausted
    the range. If it doesn’t, you can continue reading/incrementing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从输入迭代器读取时的常见模式是获取一个半开范围，包含*begin*和*end*迭代器。要遍历这个范围，你使用`operator*`读取`begin`迭代器，然后通过`operator++`递增。接下来，你判断迭代器是否等于`end`。如果是，你已经耗尽了范围。如果不是，你可以继续读取/递增。
- en: '**NOTE**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Input iterators are the magic that makes the range expressions discussed in
    “Range-Based `for` Loops” on [page 234](ch08.xhtml#page_234) work.*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*输入迭代器是使“基于范围的`for`循环”在[第234页](ch08.xhtml#page_234)中讨论的范围表达式工作的魔法。*'
- en: A canonical usage of an input iterator is to wrap a program’s standard input
    (usually the keyboard). Once you’ve read a value from standard input, it’s gone.
    You cannot go back to the beginning and replay. This behavior matches an input
    iterator’s supported operations really well.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 输入迭代器的一个典型用法是包装程序的标准输入（通常是键盘）。一旦从标准输入读取一个值，它就消失了。你不能返回开始并重播。这种行为与输入迭代器支持的操作非常契合。
- en: In “A Crash Course in Iterators” on [page 412](ch13.xhtml#page_412), you learned
    that every container exposes iterators with `begin`/`cbegin`/`end`/`cend` methods.
    All of these methods are *at least* input iterators (and they might support additional
    functionality). For example, [Listing 14-2](ch14.xhtml#ch14ex02) illustrates how
    to extract a range from a `forward_list` and manipulate the iterators manually
    for reading.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在“迭代器速成课程”中，你学习到每个容器都暴露了具有`begin`/`cbegin`/`end`/`cend`方法的迭代器。所有这些方法*至少*是输入迭代器（并且可能支持额外的功能）。例如，[清单
    14-2](ch14.xhtml#ch14ex02)演示了如何从`forward_list`中提取范围并手动操作迭代器以进行读取。
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 14-2: Interacting with input iterators from a `forward_list`*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-2：与来自`forward_list`的输入迭代器交互*'
- en: You create a `forward_list` containing three elements ➊. The container’s constness
    means the elements are immutable, so the iterators support only read operations.
    You extract an iterator with the `begin` method of `forward_list` ➋. Using `operator*`,
    you extract the element pointed to by `itr` ➌ and follow up with the obligatory
    incrementation ➍. Once you’ve exhausted the range by reading/incrementing, `itr`
    equals the `end` of the `forward_list` ➎.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建一个包含三个元素的`forward_list` ➊。容器的常量性意味着元素是不可变的，因此迭代器仅支持读取操作。你通过`forward_list`的`begin`方法提取一个迭代器
    ➋。使用`operator*`，你提取由`itr`指向的元素 ➌，并随后执行必要的递增操作 ➍。一旦通过读取/递增耗尽了范围，`itr`等于`forward_list`的`end`
    ➎。
- en: '[Table 14-3](ch14.xhtml#ch14tab03) summarizes the input iterator’s supported
    operations.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 14-3](ch14.xhtml#ch14tab03)总结了输入迭代器支持的操作。'
- en: '**Table 14-3:** Input Iterator’s Supported Operations'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 14-3：** 输入迭代器支持的操作'
- en: '| **Operation** | **Notes** |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| `*`itr | Dereferences the pointed-to member. Might or might not be read-only.
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `*`itr | 解引用指向的成员。可能是只读的，也可能不是。 |'
- en: '| itr`->`mbr | Dereferences the member mbr of the object pointed-to by itr.
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| itr`->`mbr | 解引用迭代器指向的对象的成员mbr。 |'
- en: '| `++`itritr`++` | Increments the iterator. After operation, iterator is either
    dereferencable or exhausted (past the end). |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `++`itr itr`++` | 递增迭代器。操作后，迭代器要么可解引用，要么已被耗尽（超出末尾）。|'
- en: '| itr1 `==` itr2itr1 `!=` itr2 | Compares whether the iterators are equal (pointing
    to the same element). |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| itr1 `==` itr2itr1 `!=` itr2 | 比较迭代器是否相等（是否指向相同元素）。|'
- en: '| iterator-type`{` itr `}` | Copy-constructs an iterator from itr. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| iterator-type`{` itr `}` | 通过迭代器itr复制构造一个新的迭代器。|'
- en: '***Forward Iterators***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***前向迭代器***'
- en: 'A *forward iterator* is an input iterator with additional features: a forward
    iterator can also traverse multiple times, default construct, and copy assign.
    You can use a forward iterator in place of an input iterator in all cases.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*前向迭代器*是一种具备额外功能的输入迭代器：前向迭代器还可以进行多次遍历、默认构造和复制赋值。在所有情况下，你都可以使用前向迭代器代替输入迭代器。'
- en: All STL containers provide forward iterators. Accordingly, the `forward_list`
    used in [Listing 14-2](ch14.xhtml#ch14ex02) actually provides a forward iterator
    (which is also an input iterator).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所有STL容器都提供前向迭代器。因此，在[示例14-2](ch14.xhtml#ch14ex02)中使用的`forward_list`实际上提供了一个前向迭代器（它也是一个输入迭代器）。
- en: '[Listing 14-3](ch14.xhtml#ch14ex03) updates [Listing 14-2](ch14.xhtml#ch14ex02)
    to iterate over the `forward_list` multiple times.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例14-3](ch14.xhtml#ch14ex03)更新了[示例14-2](ch14.xhtml#ch14ex02)，使其能够多次遍历`forward_list`。'
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 14-3: Traversing a forward iterator twice*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例14-3：双向遍历前向迭代器两次*'
- en: Again you create a `forward_list` containing three elements ➊. You extract an
    iterator called `itr1` with the `begin` method of `forward_list` ➋, then create
    a copy called `itr2` ➌. You exhaust `itr1` ➍ and `itr2` ➎, iterating over the
    range twice while summing both times. The resulting `double_sum` equals 12 ➏.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你创建了一个包含三个元素的`forward_list` ➊。你通过`forward_list`的`begin`方法提取出一个名为`itr1`的迭代器
    ➋，然后创建一个名为`itr2`的副本 ➌。你遍历`itr1` ➍ 和`itr2` ➎，在两次遍历过程中求和。最终的`double_sum`等于12 ➏。
- en: '[Table 14-4](ch14.xhtml#ch14tab04) summarizes the forward iterator’s supported
    operations.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[表14-4](ch14.xhtml#ch14tab04)总结了前向迭代器支持的操作。'
- en: '**Table 14-4:** Forward Iterator’s Supported Operations'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**表14-4：** 前向迭代器支持的操作'
- en: '| **Operation** | **Notes** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **说明** |'
- en: '| `*`itr | Dereferences the pointed-to member. Might or might not be read-only.
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `*`itr | 解引用所指向的成员。可能是只读的，也可能不是。|'
- en: '| itr`->`mbr | Dereferences the member mbr of the object pointed-to by itr.
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| itr`->`mbr | 解引用迭代器itr所指向对象的成员mbr。|'
- en: '| `++`itritr`++` | Increments the iterator so it points to the next element.
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `++`itr itr`++` | 递增迭代器，使其指向下一个元素。|'
- en: '| itr1 `==` itr2itr1 `!=` itr2 | Compares whether the iterators are equal (pointing
    to the same element). |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| itr1 `==` itr2itr1 `!=` itr2 | 比较迭代器是否相等（是否指向相同元素）。|'
- en: '| iterator-type`{}` | Default constructs an iterator. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| iterator-type`{}` | 默认构造一个迭代器。|'
- en: '| iterator-type`{` itr `}` | Copy-constructs an iterator from itr. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| iterator-type`{` itr `}` | 通过迭代器itr复制构造一个新的迭代器。|'
- en: '| itr1 `=` itr2 | Assigns an iterator itr1 from itr2. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| itr1 `=` itr2 | 将迭代器itr2赋值给itr1。|'
- en: '***Bidirectional Iterators***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***双向迭代器***'
- en: A *bidirectional iterator* is a forward iterator that can also iterate backward.
    You can use a bidirectional iterator in place of a forward or input iterator in
    all cases.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*双向迭代器*是一种前向迭代器，它也可以向后迭代。你可以在所有情况下使用双向迭代器代替前向或输入迭代器。'
- en: Bidirectional iterators permit backward iteration with `operator--` and `operator—(int)`.
    The STL containers that provide bidirectional iterators are `array, list`, `deque,
    vector`, and all of the ordered associative containers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 双向迭代器允许使用`operator--`和`operator—(int)`进行反向迭代。提供双向迭代器的STL容器包括`array, list`, `deque,
    vector`，以及所有有序关联容器。
- en: '[Listing 14-4](ch14.xhtml#ch14ex04) illustrates how to iterate in both directions
    using the bidirectional iterator of `list`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例14-4](ch14.xhtml#ch14ex04)展示了如何使用`list`的双向迭代器进行双向遍历。'
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 14-4: The `std::list` methods `begin` and `end` provide bidirectional
    iterators.*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例14-4：`std::list`的方法`begin`和`end`提供双向迭代器。*'
- en: Here, you create a `list` containing three elements ➊. You extract an iterator
    called `itr` with the `begin` method of `list` ➋. As with the input and forward
    iterators, you can dereference ➌ and increment ➍ the iterator. Additionally, you
    can decrement the iterator ➎ so you can go back to elements you’ve already iterated
    over ➏.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你创建了一个包含三个元素的`list` ➊。你通过`list`的`begin`方法提取出一个迭代器，命名为`itr` ➋。像输入迭代器和前向迭代器一样，你可以解引用
    ➌ 并递增 ➍ 该迭代器。此外，你还可以递减迭代器 ➎，以便回到已经遍历过的元素 ➏。
- en: '[Table 14-5](ch14.xhtml#ch14tab05) summarizes a bidirectional iterator’s supported
    operations.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[表14-5](ch14.xhtml#ch14tab05)总结了双向迭代器支持的操作。'
- en: '**Table 14-5:** Bidirectional Iterator’s Supported Operations'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**表14-5：** 双向迭代器支持的操作'
- en: '| **Operation** | **Notes** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **说明** |'
- en: '| `*`itr | Dereferences the pointed-to member. Might or might not be read-only.
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `*`itr | 解引用指向的成员，可能是只读的，也可能不是。 |'
- en: '| itr`->`mbr | Dereferences the member mbr of the object pointed to by itr.
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| itr`->`mbr | 解引用迭代器指向对象的成员mbr。 |'
- en: '| `++`itritr`++` | Increments the iterator so it points to the next element.
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `++`itritr`++` | 递增迭代器，使其指向下一个元素。 |'
- en: '| `--`itritr`--` | Decrements the iterator so it points to the previous element.
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `--`itritr`--` | 递减迭代器，使其指向前一个元素。 |'
- en: '| itr1 `==` itr2itr1 `!=` itr2 | Compares whether the iterators are equal (pointing
    to the same element). |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| itr1 `==` itr2itr1 `!=` itr2 | 比较两个迭代器是否相等（指向相同元素）。 |'
- en: '| iterator-type`{}` | Default constructs an iterator. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| iterator-type`{}` | 默认构造一个迭代器。 |'
- en: '| iterator-type`{` itr `}` | Copy-constructs an iterator from itr. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| iterator-type`{` itr `}` | 从itr复制构造一个迭代器。 |'
- en: '| itr1 `=` itr2 | Assigns an iterator itr1 from itr2. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| itr1 `=` itr2 | 将迭代器itr1赋值为itr2。 |'
- en: '***Random-Access Iterators***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***随机访问迭代器***'
- en: A *random-access iterator* is a bidirectional iterator that supports random
    element access. You can use a random-access iterator in place of bidirectional,
    forward, and input iterators in all cases.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*随机访问迭代器*是一个支持随机元素访问的双向迭代器。你可以在所有情况下使用随机访问迭代器替代双向、前向和输入迭代器。
- en: Random-access iterators permit random access with `operator[]` and also iterator
    arithmetic, such as adding or subtracting integer values and subtracting other
    iterators to find distances. The STL containers that provide random-access iterators
    are `array``, vector`, and `deque`. [Listing 14-5](ch14.xhtml#ch14ex05) illustrates
    how to access arbitrary elements using a random-access iterator from a `vector`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 随机访问迭代器允许使用`operator[]`进行随机访问，还支持迭代器算术运算，比如加法或减法整数值，以及通过减法计算其他迭代器之间的距离。提供随机访问迭代器的STL容器有`array`、`vector`和`deque`。[列表14-5](ch14.xhtml#ch14ex05)展示了如何通过随机访问迭代器从`vector`访问任意元素。
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 14-5: Interacting with a random-access iterator*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表14-5：与随机访问迭代器的交互*'
- en: You create a `vector` containing three elements ➊. You extract an iterator called
    `itr` with the `begin` method of `vector` ➋. Because this is a random-access iterator,
    you can use `operator[]` to dereference arbitrary elements ➌. Of course, you can
    still increment the iterator using `operator++` ➍. You can also add to or subtract
    from an iterator to access elements at a given offset ➎➏.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个包含三个元素的`vector` ➊。你通过`vector`的`begin`方法提取出一个叫`itr`的迭代器 ➋。由于这是一个随机访问迭代器，你可以使用`operator[]`来解引用任意元素
    ➌。当然，你仍然可以使用`operator++`来递增迭代器 ➍。你还可以通过加法或减法来操作迭代器，以访问给定偏移量的元素 ➎➏。
- en: '**List of Supported Random-Access Iterator Operations**'
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**支持的随机访问迭代器操作列表**'
- en: '[Table 14-6](ch14.xhtml#ch14tab06) summarizes the random-access iterator’s
    supported operations.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[表14-6](ch14.xhtml#ch14tab06)总结了随机访问迭代器支持的操作。'
- en: '**Table 14-6:** Random-Access Iterator’s Supported Operations'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**表14-6：** 随机访问迭代器支持的操作'
- en: '| **Operation** | **Notes** |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **说明** |'
- en: '| itr`[`n`]` | Dereferences the element with index n. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| itr`[`n`]` | 解引用索引为n的元素。 |'
- en: '| itr`+`nitr`-`n | Returns the iterator at offset n from itr. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| itr`+`nitr`-`n | 返回位于itr偏移量n处的迭代器。 |'
- en: '| itr2`-`itr1 | Computes the distance between itr1 and itr2. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| itr2`-`itr1 | 计算itr1和itr2之间的距离。 |'
- en: '| `*`itr | Dereferences the pointed-to member. Might or might not be read-only.
    |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `*`itr | 解引用指向的成员，可能是只读的，也可能不是。 |'
- en: '| itr`->`mbr | Dereferences the member mbr of the object pointed to by itr.
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| itr`->`mbr | 解引用迭代器指向对象的成员mbr。 |'
- en: '| `++`itritr`++` | Increments the iterator so it points to the next element.
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `++`itritr`++` | 递增迭代器，使其指向下一个元素。 |'
- en: '| `--`itritr`--` | Decrements the iterator so it points to the previous element.
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `--`itritr`--` | 递减迭代器，使其指向前一个元素。 |'
- en: '| itr1 `==` itr2itr1 `!=` itr2 | Compares whether the iterators are equal (pointing
    to the same element). |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| itr1 `==` itr2itr1 `!=` itr2 | 比较两个迭代器是否相等（指向相同元素）。 |'
- en: '| iterator-type`{}` | Default constructs an iterator. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| iterator-type`{}` | 默认构造一个迭代器。 |'
- en: '| iterator-type`{` itr `}` | Copy-constructs an iterator from itr. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| iterator-type`{` itr `}` | 从itr复制构造一个迭代器。 |'
- en: '| itr1 `<` itr2itr1 `>` itr2itr1 `<=` itr2itr1 `>=` itr2 | Performs the corresponding
    comparison to the iterators’ positions. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| itr1 `<` itr2itr1 `>` itr2itr1 `<=` itr2itr1 `>=` itr2 | 执行对应的迭代器位置比较。 |'
- en: '***Contiguous Iterators***'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***连续迭代器***'
- en: 'A *contiguous iterator* is a random-access iterator with elements adjacent
    in memory. For a contiguous iterator `itr`, all elements `itr[n]` and `itr[n+1]`
    satisfy the following relation for all valid selections of indices `n` and offsets
    `i`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*连续迭代器* 是一种随机访问迭代器，其元素在内存中是相邻的。对于一个连续迭代器 `itr`，所有元素 `itr[n]` 和 `itr[n+1]` 对于所有有效的索引
    `n` 和偏移量 `i`，都满足以下关系：'
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `vector` and `array` containers provide contiguous iterators, but `list`
    and `deque` don’t.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector` 和 `array` 容器提供连续的迭代器，但 `list` 和 `deque` 不提供。'
- en: '***Mutable Iterators***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***可变迭代器***'
- en: All forward iterators, bidirectional iterators, random-access iterators, and
    contiguous iterators can support read-only or read-and-write modes. If an iterator
    supports read and write, you can assign values to the references returned by dereferencing
    an iterator. Such iterators are called *mutable iterators*. For example, a bidirectional
    iterator that supports reading and writing is called a mutable bidirectional iterator.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前向迭代器、双向迭代器、随机访问迭代器和连续迭代器都可以支持只读模式或读写模式。如果一个迭代器支持读写，你可以将值赋给通过解引用迭代器返回的引用。这种迭代器被称为
    *可变迭代器*。例如，一个支持读取和写入的双向迭代器被称为可变双向迭代器。
- en: In each of the examples so far, the containers used to underpin the iterators
    have been `const`. This produces iterators to `const` objects, which are of course
    not writable. [Listing 14-6](ch14.xhtml#ch14ex06) extracts a mutable, random-access
    iterator from a (non-`const`) `deque`, allowing you to write into arbitrary elements
    of the container.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在每个例子中，用于支撑迭代器的容器都是 `const`。这会产生指向 `const` 对象的迭代器，这当然是不可写的。[清单 14-6](ch14.xhtml#ch14ex06)
    从一个（非 `const`）`deque` 中提取出一个可变的随机访问迭代器，允许你对容器的任意元素进行写操作。
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 14-6: A mutable random-access iterator permits writing.*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-6：一个可变的随机访问迭代器允许写操作。*'
- en: You construct a `deque` containing three elements ➊ and then obtain an iterator
    pointing to the first element ➋. Next, you write the value 2 to the second element
    ➌. Then, you increment the iterator so it points to the element you just modified
    ➍. When you dereference the pointed-to element, you get back the value you wrote
    in ➎.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造一个包含三个元素的 `deque` ➊，然后获取一个指向第一个元素的迭代器 ➋。接下来，你将值 2 写入第二个元素 ➌。然后，你增加迭代器，使其指向刚刚修改的元素
    ➍。当你解引用该元素时，你将得到你写入的值 ➎。
- en: '[Figure 14-1](ch14.xhtml#ch14fig01) illustrates the relationship between the
    input iterator and all its more featureful descendants.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-1](ch14.xhtml#ch14fig01) 说明了输入迭代器与其所有功能更强的后代之间的关系。'
- en: '![image](../images/fig14_1.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig14_1.jpg)'
- en: '*Figure 14-1: Input iterator categories and their nested relationships*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-1：输入迭代器类别及其嵌套关系*'
- en: To summarize, the input iterator supports only read and increment. Forward iterators
    are also input iterators, so they also support read and increment but additionally
    allow you to iterate over their range multiple times (“multi-pass”). Bidirectional
    iterators are also forward iterators, but they additionally permit decrement operations.
    Random access iterators are also bidirectional iterators, but you can access arbitrary
    elements in the sequence directly. Finally, contiguous iterators are random-access
    iterators that guarantee their elements are contiguous in memory.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，输入迭代器仅支持读取和递增。前向迭代器也是输入迭代器，因此它们也支持读取和递增，但还允许你多次迭代它们的范围（“多次遍历”）。双向迭代器也是前向迭代器，但它们额外允许进行递减操作。随机访问迭代器也是双向迭代器，但你可以直接访问序列中的任意元素。最后，连续迭代器是随机访问迭代器，它保证其元素在内存中是连续的。
- en: '**Auxiliary Iterator Functions**'
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**辅助迭代器函数**'
- en: If you write generic code dealing with iterators, you should use *auxiliary
    iter**ator functions* from the `<iterator>` header to manipulate iterators rather
    than using the supported operations directly. These iterator functions perform
    common tasks of traversing, swapping, and computing distances between iterators.
    The major advantage of using the auxiliary functions instead of direct iterator
    manipulation is that the auxiliary functions will inspect an iterator’s type traits
    and determine the most efficient method for performing the desired operation.
    Additionally, auxiliary iterator functions make generic code even more generic
    because it will work with the widest range of iterators.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写处理迭代器的通用代码，应该使用来自 `<iterator>` 头文件的 *辅助迭代器函数* 来操作迭代器，而不是直接使用支持的操作。这些迭代器函数执行常见的任务，如遍历、交换和计算迭代器之间的距离。使用辅助函数而不是直接操作迭代器的主要优势在于，辅助函数会检查迭代器的类型特征，并确定执行所需操作的最有效方法。此外，辅助迭代器函数使通用代码更加通用，因为它可以适用于更广泛的迭代器。
- en: '***std::advance***'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***std::advance***'
- en: 'The `std::advance` auxiliary iterator function allows you to increment or decrement
    by the desired amount. This function template accepts an iterator reference and
    an integer value corresponding to the distance you want to move the iterator:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::advance` 辅助迭代器函数允许你按所需的数量递增或递减。此函数模板接受一个迭代器引用和一个整数值，该值对应你希望移动迭代器的距离：'
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `InputIterator` template parameter must be at least an input iterator ➊,
    and the `Distance` template parameter is usually an integer ➋.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputIterator` 模板参数必须至少是输入迭代器 ➊，而 `Distance` 模板参数通常是一个整数 ➋。'
- en: The `advance` function doesn’t perform bounds checking, so you must ensure that
    you’ve not exceeded the valid range for the iterator’s position.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`advance` 函数不执行边界检查，因此必须确保没有超出迭代器位置的有效范围。'
- en: 'Depending on the iterator’s category, `advance` will perform the most efficient
    operation that achieves the desired effect:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 根据迭代器的类别，`advance` 将执行最有效的操作来实现所需的效果：
- en: '**Input iterator** The `advance` function will invoke `itr++` the correct number
    of times; `dist` cannot be negative.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入迭代器** `advance` 函数将调用 `itr++` 正确次数；`dist` 不能为负数。'
- en: '**Bidirectional iterator** The function will invoke `itr++` or `itr--` the
    correct number of times.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**双向迭代器** 该函数将调用 `itr++` 或 `itr--` 正确次数。'
- en: '**Random access iterator** It will invoke `itr+=dist`; `dist` can be negative.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**随机访问迭代器** 它将调用 `itr+=dist`；`dist` 可以是负数。'
- en: '**NOTE**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Random-access iterators will be more efficient than lesser iterators with
    `advance`, so you might want to use `operator+=` instead of `advance` if you want
    to forbid the worst-case (linear-time) performance.*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*随机访问迭代器在使用 `advance` 时会比其他类型的迭代器更高效，因此如果你想避免最坏情况（线性时间）的性能，可以考虑使用 `operator+=`
    而不是 `advance`。*'
- en: '[Listing 14-7](ch14.xhtml#ch14ex07) illustrates how to use `advance` to manipulate
    a random-access iterator.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14-7](ch14.xhtml#ch14ex07) 展示了如何使用 `advance` 操作随机访问迭代器。'
- en: '[PRE8]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 14-7: Using `advance` to manipulate a contiguous iterator*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 14-7：使用 `advance` 操作连续迭代器*'
- en: Here, you initialize a `vector` called `mission` with 16 `unsigned char` objects
    ➊. Next, you extract an iterator called `itr` using the `begin` method of `mission`
    ➋ and invoke `advance` on `itr` to advance four elements so it points at the fourth
    element (with value 0x49) ➌. You advance again four elements to the eighth element
    (with value 0x74) ➍. Finally, you invoke advance with −8 to retreat eight values,
    so the iterator again points to the first element (with value 0x9e) ➎.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你初始化了一个名为 `mission` 的 `vector`，包含 16 个 `unsigned char` 对象 ➊。接着，你通过 `mission`
    的 `begin` 方法提取一个名为 `itr` 的迭代器 ➋，并在 `itr` 上调用 `advance` 将其前进四个元素，使其指向第四个元素（值为 0x49）
    ➌。再前进四个元素，指向第八个元素（值为 0x74） ➍。最后，你调用 `advance` 将迭代器后退 8 个值，使其再次指向第一个元素（值为 0x9e）
    ➎。
- en: '***std::next and std::prev***'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***std::next 和 std::prev***'
- en: 'The `std::next` and `std::prev` auxiliary iterator functions are function templates
    that compute offsets from a given iterator. They return a new iterator pointing
    to the desired element without modifying the original iterator, as demonstrated
    here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::next` 和 `std::prev` 辅助迭代器函数是函数模板，用于计算相对于给定迭代器的偏移量。它们返回一个指向所需元素的新迭代器，而不会修改原始迭代器，如下所示：'
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The function `next` accepts at least a forward iterator ➊ and optionally a
    distance ➋, and it returns an iterator pointing to the corresponding offset. This
    offset can be negative if `itr` is bidirectional. The `prev` function template
    works like `next` in reverse: it accepts at least a bidirectional iterator ➌ and
    optionally a distance ➍ (which can be negative).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`next` 函数接受至少一个前向迭代器 ➊，并且可选地接受一个距离 ➋，它返回一个指向相应偏移量的迭代器。如果 `itr` 是双向迭代器，这个偏移量可以是负数。`prev`
    函数模板与 `next` 在反向操作时类似：它至少接受一个双向迭代器 ➌，并且可选地接受一个距离 ➍（这个距离可以是负数）。'
- en: Neither `next` nor `prev` performs bounds checking. This means you must be absolutely
    sure that your math is correct and that you’re staying within the sequence; otherwise,
    you’ll get undefined behavior.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`next` 和 `prev` 都不执行边界检查。这意味着你必须确保自己的数学计算是正确的，并且在序列范围内，否则你会遇到未定义的行为。'
- en: '**NOTE**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For both `next` and `prev`, `itr` remains unchanged unless it’s an rvalue,
    in which case `advance` is used for efficiency.*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于 `next` 和 `prev`，除非是右值，否则 `itr` 保持不变，在这种情况下会使用 `advance` 来提高效率。*'
- en: '[Listing 14-8](ch14.xhtml#ch14ex08) illustrates how to use `next` to obtain
    a new iterator pointing to the element at a given offset.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14-8](ch14.xhtml#ch14ex08) 演示了如何使用 `next` 获取一个新的迭代器，指向给定偏移量处的元素。'
- en: '[PRE10]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 14-8: Using `next` to obtain offsets from an iterator*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 14-8：使用 `next` 获取迭代器的偏移量*'
- en: As in [Listing 14-7](ch14.xhtml#ch14ex07), you initialize a vector containing
    16 `unsigned char`s and extract an iterator `itr1` pointing to the first element
    ➊. You use `advance` to increment the iterator four elements ➋ so it points to
    the element with the value 0x49 ➌. The first use of `next` omits a distance argument,
    which defaults to 1 ➍. This produces a new iterator, `itr2`, which is one past
    `itr1` ➎.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如同 [示例 14-7](ch14.xhtml#ch14ex07) 中所示，你初始化一个包含 16 个 `unsigned char` 的 vector，并提取一个指向第一个元素的迭代器
    `itr1` ➊。你使用 `advance` 将迭代器递增四个元素 ➋，使其指向值为 0x49 的元素 ➌。第一次使用 `next` 时省略了距离参数，默认为
    1 ➍。这会生成一个新的迭代器 `itr2`，它指向 `itr1` 后一个元素 ➎。
- en: You invoke `next` a second time with a distance argument of 4 ➏. This produces
    another new iterator, `itr3`, which points to four past the element of `itr1`
    ➐. Neither of these invocations affects the original iterator `itr1` ➑.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你第二次调用 `next`，并传递一个距离参数 4 ➏。这会产生另一个新的迭代器 `itr3`，它指向 `itr1` 后四个元素 ➐。这些调用都不会影响原始的迭代器
    `itr1` ➑。
- en: '***std::distance***'
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***std::distance***'
- en: 'The `std::distance` auxiliary iterator function enables you to compute the
    distance between two input iterators `itr1` and `itr2`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::distance` 辅助迭代器函数允许你计算两个输入迭代器 `itr1` 和 `itr2` 之间的距离：'
- en: '[PRE11]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the iterators are not random access, `itr2` must refer to an element after
    `itr1`. It’s a good idea to ensure that `itr2` comes after `itr1`, because you’ll
    get undefined behavior if you accidentally violate this requirement and the iterators
    are not random access.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迭代器不是随机访问的，`itr2` 必须指向 `itr1` 后面的元素。确保 `itr2` 在 `itr1` 之后是个好习惯，因为如果你不小心违反了这一要求并且迭代器不是随机访问的，你将遇到未定义的行为。
- en: '[Listing 14-9](ch14.xhtml#ch14ex09) illustrates how to compute the distance
    between two random access iterators.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14-9](ch14.xhtml#ch14ex09) 演示了如何计算两个随机访问迭代器之间的距离。'
- en: '[PRE12]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 14-9: Using `distance` to obtain the distance between iterators*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 14-9：使用 `distance` 获取迭代器之间的距离*'
- en: After initializing your `vector` ➊, you create an iterator pointing to the `eighth`
    element using `std::next` ➋. You use `std::prev` on `eighth` to obtain an iterator
    to the `fifth` element by passing 3 as the second argument ➌. When you pass `fifth`
    and `eighth` as the arguments to distance, you get 3 ➍.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化 `vector` ➊ 后，你使用 `std::next` ➋ 创建一个指向 `第八` 个元素的迭代器。你在 `第八` 个元素上使用 `std::prev`，通过传递
    3 作为第二个参数 ➌ 来获得指向 `第五` 个元素的迭代器。当你将 `第五` 个元素和 `第八` 个元素作为参数传递给 `distance` 时，你会得到
    3 ➍。
- en: '***std::iter_swap***'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***std::iter_swap***'
- en: 'The `std::iter_swap` auxiliary iterator function allows you to swap the values
    pointed to by two forward iterators `itr1` and `itr2`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::iter_swap` 辅助迭代器函数允许你交换两个前向迭代器 `itr1` 和 `itr2` 指向的值：'
- en: '[PRE13]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The iterators don’t need to have the same type, as long as their pointed-to
    types are assignable to one another. [Listing 14-10](ch14.xhtml#ch14ex10) illustrates
    how to use `iter_swap` to exchange two `vector` elements.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器不需要具有相同的类型，只要它们指向的类型可以相互赋值。[示例 14-10](ch14.xhtml#ch14ex10) 演示了如何使用 `iter_swap`
    交换两个 `vector` 元素。
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 14-10: Using `iter_swap` to exchange pointed-to elements*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 14-10：使用 `iter_swap` 交换指向的元素*'
- en: After you construct a `vector` with the elements `3 2 1` ➊, you invoke `iter_swap`
    on the first element ➋ and the last element ➌. After the exchange, the `vector`
    contains the elements `1 2 3` ➍.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造一个元素为`3 2 1`的`vector`之后 ➊，你对第一个元素 ➋ 和最后一个元素 ➌ 调用`iter_swap`。交换后，`vector`包含元素`1
    2 3` ➍。
- en: '**Additional Iterator Adapters**'
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**其他迭代器适配器**'
- en: In addition to insert iterators, the STL provides move iterator adapters and
    reverse iterator adapters to modify iterator behavior.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除了插入迭代器，STL还提供了移动迭代器适配器和逆向迭代器适配器来修改迭代器行为。
- en: '**NOTE**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The STL also provides stream iterator adapters, which you’ll learn about in
    [Chapter 16](ch16.xhtml#ch16) alongside streams.*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*STL还提供了流迭代器适配器，你将在[第16章](ch16.xhtml#ch16)中学习它们，内容涉及流。*'
- en: '***Move Iterator Adapters***'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***移动迭代器适配器***'
- en: A *move iterator adapter* is a class template that converts all iterator accesses
    into move operations. The convenience function template `std::make_move_iterator`
    in the `<iterator>` header accepts a single iterator argument and returns a move
    iterator adapter.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*移动迭代器适配器*是一个类模板，它将所有迭代器访问转换为移动操作。头文件`<iterator>`中的便利函数模板`std::make_move_iterator`接受一个迭代器参数并返回一个移动迭代器适配器。'
- en: The canonical use of a move iterator adapter is to move a range of objects into
    a new container. Consider the toy class `Movable` in [Listing 14-11](ch14.xhtml#ch14ex11),
    which stores an `int` value called `id`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 移动迭代器适配器的经典用法是将一系列对象移动到一个新的容器中。考虑[清单 14-11](ch14.xhtml#ch14ex11)中的玩具类`Movable`，它存储一个名为`id`的`int`值。
- en: '[PRE15]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 14-11: The `Movable` class stores an `int`.*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-11：`Movable`类存储一个`int`。*'
- en: The `Movable` constructor takes an `int` and stores it into its `id` field ➊.
    Movable is also move constructible; it will steal the `id` from its move-constructor
    argument ➋, replacing it with −1 ➌.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Movable`的构造函数接受一个`int`并将其存储到`id`字段中 ➊。`Movable`也是可移动构造的；它将从其移动构造函数参数中偷取`id`
    ➋，并将其替换为−1 ➌。'
- en: '[Listing 14-12](ch14.xhtml#ch14ex12) constructs a `vector` of `Movable` objects
    called `donor` and moves them into a `vector` called `recipient`.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 14-12](ch14.xhtml#ch14ex12)构造了一个`Movable`对象的`vector`，名为`donor`，并将它们移动到一个名为`recipient`的`vector`中。'
- en: '[PRE16]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 14-12: Using the move iterator adapter to convert iterator operations
    into move operations*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-12：使用移动迭代器适配器将迭代器操作转换为移动操作*'
- en: Here, you default construct a `vector` called `donor` ➊, which you use to `emplace_back`
    three `Movable` objects with `id` fields 1, 2, and 3 ➋. You then use the range
    constructor of `vector` with the `begin` and `end` iterators of `donor`, which
    you pass to `make_move_iterator` ➌. This converts all iterator operations into
    move operations, so the move constructor of `Movable` gets called. As a result,
    all the elements of `donor` are in a moved-from state ➍, and all the elements
    of `recipient` match the previous elements of `donor` ➎.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你默认构造一个名为`donor`的`vector` ➊，并用`id`字段为1、2和3的三个`Movable`对象调用`emplace_back`
    ➋。然后，你使用`vector`的范围构造函数，传入`donor`的`begin`和`end`迭代器，并将它们传递给`make_move_iterator`
    ➌。这将所有迭代器操作转换为移动操作，因此会调用`Movable`的移动构造函数。结果，`donor`的所有元素都处于已移动状态 ➍，而`recipient`的所有元素与`donor`之前的元素相匹配
    ➎。
- en: '***Reverse Iterator Adapters***'
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***逆向迭代器适配器***'
- en: A *reverse iterator adapter* is a class template that swaps an iterator’s increment
    and decrement operators. The net effect is that you can reverse the input to an
    algorithm by applying a reverse iterator adapter. One common scenario where you
    might want to use a reverse iterator is when searching backward from the end of
    a container. For example, perhaps you’ve been pushing logs onto the end of a `deque`
    and want to find the latest entry that meets some criterion.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*逆向迭代器适配器*是一个类模板，它交换迭代器的增量和递减操作符。其效果是通过应用逆向迭代器适配器，你可以反转算法的输入。一个常见的使用逆向迭代器的场景是从容器的末尾向后搜索。例如，假设你将日志推送到一个`deque`的末尾，并希望查找满足某些条件的最新条目。'
- en: Almost all containers in [Chapter 13](ch13.xhtml#ch13) expose reverse iterators
    with `rbegin`/`rend`/`crbegin`/`crend` methods. For example, you can create a
    container with the reverse sequence of another container, as shown in [Listing
    14-13](ch14.xhtml#ch14ex13).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有容器都在[第13章](ch13.xhtml#ch13)中暴露了逆向迭代器，提供`rbegin`/`rend`/`crbegin`/`crend`方法。例如，你可以创建一个容器，它包含另一个容器的逆序，如[清单
    14-13](ch14.xhtml#ch14ex13)所示。
- en: '[PRE17]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 14-13: Creating a container with the reverse of another container’s
    elements*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-13：创建一个包含另一个容器元素逆序的容器*'
- en: Here, you create a `list` containing the elements `3 2 1` ➊. Next, you construct
    a `vector` with the reverse of the sequence by using the `crbegin` and `crend`
    methods ➋. The `vector` contains `1 2 3`, the reverse of the list elements ➌.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你创建了一个包含元素`3 2 1`的`list` ➊。接着，你使用`crbegin`和`crend`方法构建了一个反向顺序的`vector` ➋。这个`vector`包含`1
    2 3`，是`list`元素的反向顺序 ➌。
- en: Although containers usually expose reverse iterators directly, you can also
    convert a normal iterator into a reverse iterator manually. The convenience function
    template `std::make_reverse_iterator` in the `<iterator>` header accepts a single
    iterator argument and returns a reverse iterator adapter.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管容器通常直接暴露反向迭代器，但你也可以手动将正常的迭代器转换为反向迭代器。`<iterator>`头文件中的便利函数模板`std::make_reverse_iterator`接受一个单一的迭代器参数，并返回一个反向迭代器适配器。
- en: Reverse iterators are designed to work with half-open ranges that are exactly
    opposite of normal half-open ranges. Internally, a *reverse half-open range* has
    an `rbegin` iterator that refers to 1 past a half-open range’s `end` and an `rend`
    iterator that refers to the half-open range’s `begin`, as shown in [Figure 14-2](ch14.xhtml#ch14fig02).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 反向迭代器设计用于与半开区间配合使用，这些半开区间与正常的半开区间正好相反。在内部，*反向半开区间*有一个`rbegin`迭代器，指向半开区间的`end`后一个位置，并且有一个`rend`迭代器，指向半开区间的`begin`，如[图
    14-2](ch14.xhtml#ch14fig02)所示。
- en: '![image](../images/fig14_2.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig14_2.jpg)'
- en: '*Figure 14-2: A reverse half-open range*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：一个反向半开区间*'
- en: However, these implementation details are all transparent to the user. The iterators
    dereference as you would expect. As long as the range isn’t empty, you can dereference
    the reverse-begin iterator, and it will return the first element. But you *cannot*
    dereference the reverse-end iterator.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些实现细节对用户是透明的。迭代器会按预期进行解引用。只要区间不为空，你就可以解引用反向开始迭代器，它将返回第一个元素。但你*不能*解引用反向结束迭代器。
- en: Why introduce this representational complication? With this design, you can
    easily swap the begin and end iterators of a half-open range to produce a reverse
    half-open range. For example, [Listing 14-14](ch14.xhtml#ch14ex14) uses `std::make_reverse_iterator`
    to convert normal iterators to reverse iterators, accomplishing the same task
    as [Listing 14-13](ch14.xhtml#ch14ex13).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要引入这种表示上的复杂性？通过这种设计，你可以轻松地交换半开区间的开始和结束迭代器，以生成一个反向半开区间。例如，[列表 14-14](ch14.xhtml#ch14ex14)使用`std::make_reverse_iterator`将普通迭代器转换为反向迭代器，实现了与[列表
    14-13](ch14.xhtml#ch14ex13)相同的任务。
- en: '[PRE18]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 14-14: The `make_reverse_iterator` function converts a normal iterator
    to a reverse iterator*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 14-14：`make_reverse_iterator`函数将普通迭代器转换为反向迭代器*'
- en: Pay special attention to the iterators you’re extracting from `original`. To
    create the `begin` iterator, you extract an `end` iterator from `original` and
    pass it to `make_reverse_iterator` ➊. The reverse iterator adapter will swap increment
    and decrement operators, but it needs to start in the right place. Likewise, you
    need to terminate at the original’s beginning, so you pass the result of `cbegin`
    to `make_reverse_iterator` to produce the correct end ➋. Passing these to the
    range constructor of `easy_as` ➌ produces identical results to [Listing 14-13](ch14.xhtml#ch14ex13).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意你从`original`中提取的迭代器。要创建`begin`迭代器，你需要从`original`中提取一个`end`迭代器，并将其传递给`make_reverse_iterator`
    ➊。反向迭代器适配器会交换递增和递减操作符，但它需要从正确的位置开始。同样，你需要在原始序列的开始处终止，因此你将`cbegin`的结果传递给`make_reverse_iterator`，以生成正确的结束迭代器
    ➋。将这些传递给`easy_as`的范围构造器 ➌，会产生与[列表 14-13](ch14.xhtml#ch14ex13)相同的结果。
- en: '**NOTE**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All reverse iterators expose a `base` method, which will convert the reverse
    iterator back into a normal iterator.*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有反向迭代器都暴露一个`base`方法，该方法将反向迭代器转换回普通迭代器。*'
- en: '**Summary**'
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'In this short chapter, you learned all the iterator categories: output, input,
    forward, bidirectional, random-access, and contiguous. Knowing the basic properties
    of each category provides you with a framework for understanding how containers
    connect with algorithms. The chapter also surveyed iterator adapters, which enable
    you to customize iterator behavior, and the auxiliary iterator functions, which
    help you write generic code with iterators.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一短小的章节中，你学习了所有的迭代器类别：输出迭代器、输入迭代器、前向迭代器、双向迭代器、随机访问迭代器和连续迭代器。了解每种类别的基本特性为你提供了一个框架，用于理解容器如何与算法连接。该章节还介绍了迭代器适配器，使你能够自定义迭代器行为，以及辅助迭代器函数，帮助你用迭代器编写通用代码。
- en: '**EXERCISES**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '**14-1.** Create a corollary to [Listing 14-8](ch14.xhtml#ch14ex08) using `std::prev`
    rather than `std::next`.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**14-1.** 使用`std::prev`而不是`std::next`，创建一个与[清单14-8](ch14.xhtml#ch14ex08)相应的推论。'
- en: '**14-2.** Write a function template called `sum` that accepts a half-open range
    of `int` objects and returns the sum of the sequence.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**14-2.** 编写一个名为`sum`的函数模板，该模板接受一个半开区间的`int`对象并返回该序列的和。'
- en: '**14-3.** Write a program that uses the `Stopwatch` class in [Listing 12-25](ch12.xhtml#ch12ex25)
    to determine the runtime performance of `std::advance` when given a forward iterator
    from a large `std::forward_list` and a large `std::vector`. How does the runtime
    change with the number of elements in the container? (Try hundreds of thousands
    or millions of elements.)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**14-3.** 编写一个程序，使用[清单12-25](ch12.xhtml#ch12ex25)中的`Stopwatch`类来确定在给定来自大`std::forward_list`和大`std::vector`的正向迭代器时，`std::advance`的运行时性能。随着容器中元素数量的增加，运行时性能如何变化？（尝试数十万或数百万个元素。）'
- en: '**FURTHER READING**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*The C++ Standard Library: A Tutorial and Reference*, 2nd Edition, by Nicolai
    M. Josuttis (Addison-Wesley Professional, 2012)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++标准库：教程与参考*，第2版，作者Nicolai M. Josuttis（Addison-Wesley Professional，2012年）'
- en: '*C++ Templates: The Complete Guide*, 2nd Edition, by David Vandevoorde et al.
    (Addison-Wesley, 2017)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++模板：完全指南*，第2版，作者David Vandevoorde等人（Addison-Wesley，2017年）'
