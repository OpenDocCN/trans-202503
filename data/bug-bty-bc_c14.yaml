- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Insecure Deserialization
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 不安全的反序列化
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: '*Insecure deserialization* vulnerabilities happen when applications deserialize
    program objects without proper precaution. An attacker can then manipulate serialized
    objects to change the program’s behavior.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*不安全的反序列化*漏洞发生在应用程序在没有适当预防措施的情况下反序列化程序对象时。攻击者可以操控序列化对象，从而改变程序的行为。'
- en: Insecure deserialization bugs have always fascinated me. They’re hard to find
    and exploit, because they tend to look different depending on the programming
    language and libraries used to build the application. These bugs also require
    deep technical understanding and ingenuity to exploit. Although they can be a
    challenge to find, they are worth the effort. Countless write-ups describe how
    researchers used these bugs to achieve RCE on critical assets from companies such
    as Google and Facebook.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 不安全的反序列化漏洞一直让我着迷。它们很难发现和利用，因为它们的表现形式取决于所使用的编程语言和库，因而看起来各不相同。这些漏洞还需要深厚的技术理解和创造力才能加以利用。尽管它们可能很难被发现，但值得付出努力。无数的研究报告描述了研究人员如何利用这些漏洞实现RCE（远程代码执行），并攻破Google、Facebook等公司的关键资产。
- en: In this chapter, I’ll talk about what insecure deserialization is, how insecure
    deserialization bugs happen in PHP and Java applications, and how you can exploit
    them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将讲解什么是不安全的反序列化，PHP和Java应用程序中如何出现不安全的反序列化漏洞，以及如何利用这些漏洞。
- en: Mechanisms
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机制
- en: '*Serialization* is the process by which some bit of data in a programming language
    gets converted into a format that allows it to be saved in a database or transferred
    over a network. *Deserialization* refers to the opposite process, whereby the
    program reads the serialized object from a file or the network and converts it
    back into an object.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*序列化*是将编程语言中的某些数据转换为一种格式的过程，以便将其保存到数据库或通过网络传输。*反序列化*指的是相反的过程，即程序从文件或网络读取序列化的对象，并将其转换回对象。'
- en: This is useful because some objects in programming languages are difficult to
    transfer through a network or to store in a database without corruption. Serialization
    and deserialization allow programming languages to reconstruct identical program
    objects in different computing environments. Many programming languages support
    the serialization and deserialization of objects, including Java, PHP, Python,
    and Ruby.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有用，因为在编程语言中，一些对象在通过网络传输或存储到数据库时很容易发生损坏。序列化和反序列化允许编程语言在不同的计算环境中重建相同的程序对象。许多编程语言都支持对象的序列化和反序列化，包括Java、PHP、Python和Ruby。
- en: Developers often trust user-supplied serialized data because it is difficult
    to read or unreadable to users. This trust assumption is what attackers can abuse.
    *Insecure deserialization* is a type of vulnerability that arises when an attacker
    can manipulate the serialized object to cause unintended consequences in the program.
    This can lead to authentication bypasses or even RCE. For example, if an application
    takes a serialized object from the user and uses the data contained in it to determine
    who is logged in, a malicious user might be able to tamper with that object and
    authenticate as someone else. If the application uses an unsafe deserialization
    operation, the malicious user might even be able to embed code snippets in the
    object and get it executed during deserialization.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员常常信任用户提供的序列化数据，因为这些数据对用户来说难以读取或根本无法读取。这种信任假设正是攻击者可以利用的漏洞。*不安全的反序列化*是一种漏洞类型，发生在攻击者能够操控序列化对象，从而导致程序出现意外后果时。这可能导致身份验证绕过，甚至是RCE。例如，如果一个应用程序从用户那里获取一个序列化的对象，并利用其中的数据来确定谁已经登录，恶意用户可能会篡改该对象，从而冒充其他人登录。如果应用程序使用了不安全的反序列化操作，恶意用户甚至可能将代码片段嵌入对象中，并在反序列化过程中执行这些代码。
- en: The best way to understand insecure deserialization is to learn how different
    programming languages implement serialization and deserialization. Since these
    processes look different in every language, we’ll explore how this vulnerability
    presents itself in PHP and Java. Before we continue, you’ll need to install PHP
    and Java if you want to test out the example code in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 理解不安全的反序列化的最佳方法是学习不同编程语言如何实现序列化和反序列化。由于这些过程在每种语言中都有不同的表现，我们将探讨这种漏洞在PHP和Java中的表现形式。在继续之前，如果你想测试本章中的示例代码，你需要安装PHP和Java。
- en: You can install PHP by following the instructions for your system on the PHP
    manual page ([https://www.php.net/manual/en/install.php](https://www.php.net/manual/en/install.php)).
    You can then run PHP scripts by running `php` `YOUR_PHP_SCRIPT.php` using the
    command line. Alternatively, you can use an online PHP tester like ExtendsClass
    ([https://extendsclass.com/php.html](https://extendsclass.com/php.html)) to test
    the example scripts. Search *online PHP tester* for more options. Note that not
    all online PHP testers support serialization and deserialization, so make sure
    to choose one that does.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照 PHP 手册页面上的说明来安装 PHP（[https://www.php.net/manual/en/install.php](https://www.php.net/manual/en/install.php)）。然后，你可以通过命令行运行
    `php` `YOUR_PHP_SCRIPT.php` 来运行 PHP 脚本。或者，你可以使用像 ExtendsClass 这样的在线 PHP 测试工具（[https://extendsclass.com/php.html](https://extendsclass.com/php.html)）来测试示例脚本。搜索
    *online PHP tester* 以获取更多选项。请注意，并非所有在线 PHP 测试工具都支持序列化和反序列化，因此请确保选择一个支持这些功能的工具。
- en: Most computers should already have Java installed. If you run `java -version`
    at the command line and see a Java version number returned, you don’t have to
    install Java again. Otherwise, you can find the instructions to install Java at
    [https://java.com/en/download/help/download_options.html](https://java.com/en/download/help/download_options.html).
    You can also use an online Java compiler to test your code; Tutorials Point has
    one at [https://www.tutorialspoint.com/compile_java_online.php](https://www.tutorialspoint.com/compile_java_online.php).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算机应该已经安装了 Java。如果你在命令行中运行 `java -version` 并看到返回的 Java 版本号，则无需再次安装 Java。否则，你可以在
    [https://java.com/en/download/help/download_options.html](https://java.com/en/download/help/download_options.html)
    查找安装 Java 的说明。你还可以使用在线 Java 编译器来测试代码；Tutorials Point 提供了一个在线编译器，地址为 [https://www.tutorialspoint.com/compile_java_online.php](https://www.tutorialspoint.com/compile_java_online.php)。
- en: PHP
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP
- en: Although most deserialization bugs in the wild are caused by insecure deserialization
    in Java, I’ve also found PHP deserialization vulnerabilities to be extremely common.
    In my research project that studied publicly disclosed deserialization vulnerabilities
    on HackerOne, I discovered that half of all disclosed deserialization vulnerabilities
    were caused by insecure deserialization in PHP. I also found that most deserialization
    vulnerabilities are resolved as high-impact or critical-impact vulnerabilities;
    incredibly, most can be used to cause the execution of arbitrary code on the target
    server.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在现实中大多数反序列化漏洞是由 Java 中的不安全反序列化引起的，但我发现 PHP 的反序列化漏洞也非常常见。在我的一个研究项目中，我研究了 HackerOne
    上公开披露的反序列化漏洞，发现所有公开披露的反序列化漏洞中，有一半是由 PHP 中的不安全反序列化引起的。我还发现，大多数反序列化漏洞被归类为高影响或严重影响漏洞；令人难以置信的是，大多数漏洞可以用来在目标服务器上执行任意代码。
- en: When insecure deserialization vulnerabilities occur in PHP, we sometimes call
    them *PHP object injection vulnerabilities*. To understand PHP object injections,
    you first need to understand how PHP serializes and deserializes objects.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当 PHP 中发生不安全的反序列化漏洞时，我们有时称之为 *PHP 对象注入漏洞*。要理解 PHP 对象注入漏洞，首先需要了解 PHP 如何序列化和反序列化对象。
- en: When an application needs to store a PHP object or transfer it over the network,
    it calls the PHP function `serialize()` to pack it up. When the application needs
    to use that data, it calls `unserialize()` to unpack and get the underlying object.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序需要存储一个 PHP 对象或通过网络传输它时，它会调用 PHP 函数 `serialize()` 来打包该对象。当应用程序需要使用这些数据时，它会调用
    `unserialize()` 来解包并获取底层对象。
- en: 'For example, this code snippet will serialize the object called `user`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这段代码片段将会序列化名为 `user` 的对象：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This piece of PHP code declares a class called `User`. Each `User` object will
    contain a `$username` and a `$status` attribute 1. It then creates a new `User`
    object called `$user` 2. It sets the `$username` attribute of `$user` to `'vickie'`
    3 and its `$status` attribute to `'not admin'` 4. Then, it serializes the `$user`
    object and prints out the string representing the serialized object 5.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 PHP 代码声明了一个名为 `User` 的类。每个 `User` 对象将包含一个 `$username` 和一个 `$status` 属性 1。然后，它创建了一个名为
    `$user` 的新 `User` 对象 2。接着，它将 `$user` 的 `$username` 属性设置为 `'vickie'` 3，并将其 `$status`
    属性设置为 `'not admin'` 4。然后，它序列化 `$user` 对象，并打印出表示序列化对象的字符串 5。
- en: 'Store this code snippet as a file named *serialize_test.php* and run it using
    the command `php serialize_test.php`. You should get the serialized string that
    represents the `user` object:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段代码保存为名为 *serialize_test.php* 的文件，并使用命令 `php serialize_test.php` 运行它。你应该能够得到表示
    `user` 对象的序列化字符串：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s break down this serialized string. The basic structure of a PHP serialized
    string is `data type``:``data`. In terms of data types, `b` represents a Boolean,
    `i` represents an integer, `d` represents a float, `s` represents a string, `a`
    represents an array, and `O` represents an object instance of a particular class.
    Some of these types get followed by additional information about the data, as
    described here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下这个序列化字符串。PHP 序列化字符串的基本结构是 `数据类型``:``数据`。关于数据类型，`b`表示布尔值，`i`表示整数，`d`表示浮动数，`s`表示字符串，`a`表示数组，`O`表示某个类的对象实例。其中一些类型后面跟着关于数据的附加信息，如下所述：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using this reference as a guide, we can see that our serialized string represents
    an object of the class `User`. It has two properties. The first property has the
    name `username` and the value `vickie`. The second property has the name `status`
    and the value `not admin`. The names and values are all strings.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以这个参考为指南，我们可以看到我们的序列化字符串表示一个 `User` 类的对象。它有两个属性。第一个属性名为 `username`，值为 `vickie`。第二个属性名为
    `status`，值为 `not admin`。这些名字和值都是字符串。
- en: 'When you’re ready to operate on the object again, you can deserialize the string
    with `unserialize()`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备再次操作对象时，可以使用 `unserialize()` 来反序列化字符串：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first few lines of this code snippet create a user object, serialize it,
    and store the serialized string into a variable called `$serialized_string` 1.
    Then, it unserializes the string and stores the restored object into the variable
    `$unserialized_data` 2. The `var_dump()` PHP function displays the value of a
    variable. The last two lines display the value of the unserialized object `$unserialized_data`
    and its status property 3.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的前几行创建了一个用户对象，将其序列化，并将序列化字符串存储到一个名为 `$serialized_string` 1 的变量中。然后，它反序列化该字符串并将恢复的对象存储到变量
    `$unserialized_data` 2 中。`var_dump()` PHP 函数显示变量的值。最后两行显示了反序列化后的对象 `$unserialized_data`
    及其状态属性 3。
- en: Most object-oriented programming languages have similar interfaces for serializing
    and deserializing program objects, but the format of their serialized objects
    are different. Some programming languages also allow developers to serialize into
    other standardized formats, such as JSON and YAML.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数面向对象的编程语言都有类似的接口来序列化和反序列化程序对象，但它们的序列化对象格式不同。一些编程语言还允许开发人员序列化成其他标准格式，如 JSON
    和 YAML。
- en: Controlling Variable Values
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制变量值
- en: You might have already noticed something fishy here. If the serialized object
    isn’t encrypted or signed, can anyone create a `User` object? The answer is yes!
    This is a common way insecure deserialization endangers applications.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到这里有些不对劲。如果序列化的对象没有加密或签名，任何人都可以创建一个`User`对象吗？答案是可以！这是一个常见的、不安全的反序列化危害应用程序的方式。
- en: 'One possible way of exploiting a PHP object injection vulnerability is by manipulating
    variables in the object. Some applications simply pass in a serialized object
    as a method of authentication without encrypting or signing it, thinking the serialization
    alone will stop users from tampering with the values. If that’s the case, you
    can mess with the values encoded in the serialized string:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 PHP 对象注入漏洞的一种可能方式是通过操作对象中的变量。一些应用程序只是传递一个序列化对象作为认证方法，而没有对其进行加密或签名，认为仅凭序列化就能阻止用户篡改值。如果是这种情况，你可以修改序列化字符串中编码的值：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example of the `User` object we created earlier, you change the `status`
    to `admin` by modifying your PHP script 1. Then you can intercept the outgoing
    request in your proxy and insert the new object in place of the old one to see
    if the application grants you admin privileges.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前创建的`User`对象的这个示例中，你可以通过修改你的 PHP 脚本 1，将 `status` 改为 `admin`。然后，你可以在代理中拦截传出的请求，并将新的对象替换掉旧的对象，看看应用程序是否授予你管理员权限。
- en: 'You can also change your serialized string directly:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以直接修改你的序列化字符串：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you’re tampering with the serialized string directly, remember to change
    the string’s length marker as well, since the length of your `status` string has
    changed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你直接篡改序列化字符串，记得也要更改字符串的长度标记，因为你的 `status` 字符串的长度已经发生变化：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: unserialize() Under the Hood
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: unserialize() 内部机制
- en: To understand how `unserialize()` canlead to RCEs, let’s take a look at how
    PHP creates and destroys objects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 `unserialize()` 如何导致 RCE（远程代码执行），让我们来看看 PHP 是如何创建和销毁对象的。
- en: '*PHP magic methods* are method names in PHP that have special properties. If
    the serialized object’s class implements any method with a magic name, these methods
    will have magic properties, such as being automatically run during certain points
    of execution, or when certain conditions are met. Two of these magic methods are
    `__wakeup()` and `__destruct()`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*PHP 魔术方法*是具有特殊属性的 PHP 方法名称。如果序列化对象的类实现了任何具有魔术名称的方法，这些方法将具有魔术属性，例如在执行的某些时刻自动运行，或者在满足某些条件时执行。这些魔术方法中有两个是`__wakeup()`和`__destruct()`。'
- en: The `__wakeup()` method is used during instantiation when the program creates
    an instance of a class in memory, which is what `unserialize()` does; it takes
    the serialized string, which specifies the class and the properties of that object,
    and uses that data to create a copy of the originally serialized object. It then
    searches for the `__wakeup()` method and executes code in it. The `__wakeup()`
    method is usually used to reconstruct any resources that the object may have,
    reestablish any database connections that were lost during serialization, and
    perform other reinitialization tasks. It’s often useful during a PHP object injection
    attack because it provides a convenient entry point to the server’s database or
    other functions in the program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`__wakeup()`方法在实例化时使用，当程序在内存中创建类的实例时，这就是`unserialize()`的作用；它接受序列化字符串，指定该对象的类和属性，并使用这些数据创建原始序列化对象的副本。然后，它会搜索`__wakeup()`方法并执行其中的代码。`__wakeup()`方法通常用于重建对象可能具有的任何资源，重新建立序列化过程中丢失的数据库连接，并执行其他重新初始化任务。在
    PHP 对象注入攻击中，它通常很有用，因为它提供了一个方便的入口点，进入服务器的数据库或程序中的其他功能。'
- en: The program then operates on the object and uses it to perform other actions.
    When no references to the deserialized object exist, the program calls the `__destruct()`
    function to clean up the object. This method often contains useful code in terms
    of exploitation. For example, if a `__destruct()` method contains code that deletes
    and cleans up files associated with the object, the attacker might be able to
    mess with the integrity of the filesystem by controlling the input passed into
    those functions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后程序在对象上进行操作，并使用它执行其他操作。当没有对反序列化对象的引用时，程序会调用`__destruct()`函数来清理该对象。这个方法通常包含在利用中的有用代码。例如，如果`__destruct()`方法包含删除并清理与对象相关的文件的代码，攻击者可能通过控制传入这些函数的输入，破坏文件系统的完整性。
- en: Achieving RCE
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现 RCE
- en: When you control a serialized object passed into `unserialize()`, you control
    the properties of the created object. You might also be able to control the values
    passed into automatically executed methods like `__wakeup()` or `__destruct()`.
    If you can do that, you can potentially achieve RCE.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你控制一个传入`unserialize()`的序列化对象时，你就能控制创建对象的属性。你也可能能够控制传入自动执行的方法（如`__wakeup()`或`__destruct()`）的值。如果你能做到这一点，就有可能实现
    RCE。
- en: 'For example, consider this vulnerable code example, taken from[https://www.owasp.org/index.php/PHP_Object_Injection](https://www.owasp.org/index.php/PHP_Object_Injection):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下漏洞代码示例，来自[https://www.owasp.org/index.php/PHP_Object_Injection](https://www.owasp.org/index.php/PHP_Object_Injection)：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code declares a class called `Example2`. It has a `$hook` attribute and
    two methods: `__construct()` and `__wakeup()` 1. The `__wakeup()` function executes
    the string stored in `$hook` as PHP code if `$hook` is not empty 2. The PHP `eval()`
    function takes in a string and runs the content of the string as PHP code. Then,
    the program runs `unserialize()` on a user-supplied cookie named `data` 3.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了一个名为`Example2`的类。它有一个`$hook`属性和两个方法：`__construct()`和`__wakeup()`。1. 如果`$hook`不为空，`__wakeup()`函数会将存储在`$hook`中的字符串作为
    PHP 代码执行。2. PHP `eval()`函数接受一个字符串并将其内容作为 PHP 代码运行。然后，程序在用户提供的名为`data`的 cookie
    上运行`unserialize()`。
- en: Here, you can achieve RCE because the code passes a user-provided object into
    `unserialize()`, and there is an object class, `Example2`, with a magic method
    that automatically runs `eval()` on user-provided input when the object is instantiated.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以实现 RCE，因为代码将用户提供的对象传递给`unserialize()`，并且有一个对象类`Example2`，它具有一个魔术方法，该方法在实例化对象时会自动对用户提供的输入运行`eval()`。
- en: 'To exploit this RCE, you’d set your `data` cookie to a serialized `Example2`
    object, and the `hook` property to whatever PHP code you want to execute. You
    can generate the serialized object by using the following code snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用这个 RCE，你需要将你的`data` cookie设置为一个序列化的`Example2`对象，并将`hook`属性设置为你想执行的任何 PHP
    代码。你可以通过以下代码片段生成序列化对象：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Before we print the object, we need to URL-encode it 1, since we’ll be injecting
    the object via a cookie. Passing the string generated by this code into the `data`
    cookie will cause the server to execute the PHP code `phpinfo();`, which outputs
    information about PHP’s configuration on the server. The phpinfo() function is
    often used as a proof-of-concept function to run in bug reports to proof successful
    PHP command injection. The following is what happens in detail on the target server
    during this attack:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印对象之前，我们需要对其进行URL编码1，因为我们将通过cookie注入该对象。将该代码生成的字符串传递给`data` cookie会导致服务器执行PHP代码`phpinfo();`，该代码输出服务器上PHP配置的信息。phpinfo()函数通常用作概念验证函数，在漏洞报告中运行，以证明PHP命令注入成功。以下是此攻击在目标服务器上发生的详细过程：
- en: The serialized `Example2` object is passed into the program as the `data` cookie.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 序列化后的`Example2`对象作为`data` cookie传递到程序中。
- en: The program calls `unserialize()` on the `data` cookie.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序对`data` cookie调用`unserialize()`方法。
- en: Because the `data` cookie is a serialized `Example2` object, `unserialize()`
    instantiates a new `Example2` object.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为`data` cookie是一个序列化的`Example2`对象，`unserialize()`会实例化一个新的`Example2`对象。
- en: The `unserialize()` function sees that the `Example2` class has `__wakeup()`
    implemented, so `__wakeup()` is called.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`unserialize()`函数看到`Example2`类中实现了`__wakeup()`，于是调用了`__wakeup()`方法。'
- en: The `__wakeup()` function looks for the object’s `$hook` property, and if it
    is not `NULL`, it runs `eval($hook)`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`__wakeup()`函数查找对象的`$hook`属性，如果它不是`NULL`，则执行`eval($hook)`。'
- en: The `$hook` property is not `NULL`, because it is set to `phpinfo();`, and so
    `eval("phpinfo();")` is run.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$hook`属性不是`NULL`，因为它被设置为`phpinfo();`，因此`eval("phpinfo();")`会被执行。'
- en: You’ve achieved RCE by executing the arbitrary PHP code you’ve placed in the
    `data` cookie.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你通过执行放置在`data` cookie中的任意PHP代码，成功实现了远程代码执行（RCE）。
- en: Using Other Magic Methods
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用其他魔术方法
- en: 'So far, we’ve mentioned the magic methods `__wakeup()` and `__destruct()`.
    There are actually four magic methods you’ll find particularly useful when trying
    to exploit an `unserialize()` vulnerability: `__wakeup()`, `__destruct()`, `__toString()`,
    and `__call()`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们提到了魔术方法`__wakeup()`和`__destruct()`。实际上，当试图利用`unserialize()`漏洞时，有四个魔术方法特别有用：`__wakeup()`、`__destruct()`、`__toString()`和`__call()`。
- en: Unlike `__wakeup()` and `__destruct()`, which always get executed if the object
    is created, the `__toString()` method is invoked only when the object is treated
    as a string. It allows a class to decide how it will react when one of its objects
    is treated as a string. For example, it can decide what to display if the object
    is passed into an `echo()` or `print()` function. You’ll see an example of using
    this method in a deserialization attack in “Using POP Chains” on page 238.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与`__wakeup()`和`__destruct()`不同，这两个方法只要对象被创建就会执行，而`__toString()`方法仅在对象被当作字符串处理时才会被调用。它允许类决定当其中一个对象被当作字符串时该如何反应。例如，它可以决定在对象传递给`echo()`或`print()`函数时显示什么内容。你将在“使用POP链”一节（第238页）看到如何在反序列化攻击中使用此方法的例子。
- en: A program invokes the `__call()` method when an undefined method is called.
    For example, a call to `$object->undefined($args)` will turn into `$object->__call('undefined',
    $args)`. Again, the exploitability of this magic method varies wildly, depending
    on how it was implemented. Sometimes attackers can exploit this magic method when
    the application’s code contains a mistake or when users are allowed to define
    a method name to call themselves.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用一个未定义的方法时，程序会调用`__call()`方法。例如，调用`$object->undefined($args)`将变成`$object->__call('undefined',
    $args)`。同样，这个魔术方法的可利用性差异很大，取决于它是如何实现的。有时，攻击者可以在应用程序代码中存在错误或允许用户定义要调用的方法名时利用该魔术方法。
- en: You’ll typically find these four magic methods the most useful for exploitation,
    but many other methods exist. If the ones mentioned here aren’t exploitable, it
    might be worth checking out the class’s implementation of the other magic methods
    to see whether you can start an exploit from there. Read more about PHP’s magic
    methods at [https://www.php.net/manual/en/language.oop5.magic.php](https://www.php.net/manual/en/language.oop5.magic.php).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会发现这四个魔术方法在利用中最为有用，但还有许多其他方法存在。如果这里提到的方法不可利用，可能值得查看该类中其他魔术方法的实现，看看是否能从那里发起攻击。阅读更多关于PHP魔术方法的信息，参考[https://www.php.net/manual/en/language.oop5.magic.php](https://www.php.net/manual/en/language.oop5.magic.php)。
- en: Using POP Chains
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用POP链
- en: So far, you know that when attackers control a serialized object passed into
    `unserialize()`, they can control the properties of the created object. This gives
    them the opportunity to hijack the flow of the application by choosing the values
    passed into magic methods like `__wakeup()`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经知道，当攻击者控制传递给 `unserialize()` 的序列化对象时，他们可以控制创建的对象的属性。这使他们有机会通过选择传递给魔术方法（如
    `__wakeup()`）的值来劫持应用程序的流程。
- en: 'This exploit works . . . sometimes. But this approach has a problem: what if
    the declared magic methods of the class don’t contain any useful code in terms
    of exploitation? For example, sometimes the available classes for object injections
    contain only a few methods, and none of them contain code injection opportunities.
    Then the unsafe deserialization is useless, and the exploit is a bust, right?'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞有时能工作。但这个方法有个问题：如果类声明的魔术方法在利用时没有任何有用的代码怎么办？例如，有时用于对象注入的类只有几个方法，而且这些方法中没有任何代码注入的机会。那么不安全的反序列化就变得没用了，漏洞就失效了，对吧？
- en: 'We have another way of achieving RCE even in this scenario: POP chains. A *property-oriented
    programming (POP) chain* is a type of exploit whose name comes from the fact that
    the attacker controls all of the deserialized object’s properties. POP chains
    work by stringing bits of code together, called *gadgets*, to achieve the attacker’s
    ultimate goal. These gadgets are code snippets borrowed from the codebase. POP
    chains use magic methods as their initial gadget. Attackers can then use these
    methods to call other gadgets.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这种情况下，我们还有另一种实现 RCE（远程代码执行）的方法：POP 链。*面向属性编程（POP）链* 是一种漏洞类型，其名称来源于攻击者控制反序列化对象的所有属性这一事实。POP
    链通过将多个代码片段（称为 *gadgets*）串联起来，来实现攻击者的最终目标。这些 *gadgets* 是从代码库中借用的代码片段。POP 链将魔术方法作为其初始
    *gadget*，攻击者可以利用这些方法来调用其他 *gadgets*。
- en: 'If this seems abstract, consider the following example application code, taken
    from [https://owasp.org/www-community/vulnerabilities/PHP_Object_Injection](https://owasp.org/www-community/vulnerabilities/PHP_Object_Injection):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来很抽象，请参考以下示例应用程序代码，摘自 [https://owasp.org/www-community/vulnerabilities/PHP_Object_Injection](https://owasp.org/www-community/vulnerabilities/PHP_Object_Injection)：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this application, the code defines two classes: `Example` and `CodeSnippet`.
    `Example` has a property named `obj` 1, and when an `Example` object is deserialized,
    its `__wakeup()` function is called, which calls `obj`’s `evaluate()` method 2.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，代码定义了两个类：`Example` 和 `CodeSnippet`。`Example` 类有一个名为 `obj` 的属性 1，当一个
    `Example` 对象被反序列化时，它的 `__wakeup()` 函数会被调用，而该函数会调用 `obj` 的 `evaluate()` 方法 2。
- en: The `CodeSnippet` class has a property named `code` that contains the code string
    to be executed 3 and an `evaluate()` method 4, which calls `eval()` on the `code`
    string.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`CodeSnippet` 类有一个名为 `code` 的属性，包含要执行的代码字符串 3，并且有一个 `evaluate()` 方法 4，该方法在
    `code` 字符串上调用 `eval()`。'
- en: In another part of the code, the program accepts the POST parameter `data` from
    the user and calls `unserialize()` on it 5.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的另一部分，程序接受来自用户的 POST 参数 `data` 并对其调用 `unserialize()` 5。
- en: 'Since that last line contains an insecure deserialization vulnerability, an
    attacker can use the following code to generate a serialized object:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于最后一行包含一个不安全的反序列化漏洞，攻击者可以使用以下代码生成一个序列化对象：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code snippet defines a class named `CodeSnippet` and set its `code` property
    to `phpinfo();`. Then it defines a class named `Example`, and sets its `obj` property
    to a new `CodeSnippet` instance on instantiation. Finally, it creates an `Example`
    instance, serializes it, and URL-encodes the serialized string. The attacker can
    then feed the generated string into the POST parameter `data`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段定义了一个名为 `CodeSnippet` 的类，并将它的 `code` 属性设置为 `phpinfo();`。然后定义了一个名为 `Example`
    的类，并在实例化时将其 `obj` 属性设置为一个新的 `CodeSnippet` 实例。最后，创建一个 `Example` 实例，进行序列化，并对序列化字符串进行
    URL 编码。攻击者可以将生成的字符串传递给 POST 参数 `data`。
- en: Notice that the attacker’s serialized object uses class and property names found
    elsewhere in the application’s source code. As a result, the program will do the
    following when it receives the crafted `data` string.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，攻击者的序列化对象使用了应用程序源代码中其他地方找到的类和属性名称。因此，当程序接收到伪造的 `data` 字符串时，它将执行以下操作。
- en: First, it will unserialize the object and create an `Example` instance. Then,
    since `Example` implements `__wakeup()`, the program will call `__wakeup()` and
    see that the `obj` property is set to a `CodeSnippet` instance. Finally, it will
    call the `evaluate()` method of the `obj`, which runs `eval("phpinfo();")`, since
    the attacker set the `code` property to `phpinfo()`. The attacker is able to execute
    any PHP code of their choosing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它会反序列化对象并创建一个`Example`实例。然后，由于`Example`实现了`__wakeup()`方法，程序会调用`__wakeup()`并看到`obj`属性被设置为一个`CodeSnippet`实例。最后，它会调用`obj`的`evaluate()`方法，该方法执行`eval("phpinfo();")`，因为攻击者将`code`属性设置为`phpinfo()`。攻击者能够执行他们选择的任何PHP代码。
- en: POP chains achieve RCE by chaining and reusing code found in the application’s
    codebase. Let’s look at another example of how to use POP chains to achieve SQL
    injection. This example is also taken from [https://owasp.org/www-community/vulnerabilities/PHP_Object_Injection](https://owasp.org/www-community/vulnerabilities/PHP_Object_Injection).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: POP链通过将应用程序代码库中找到的代码链接和重用来实现RCE。让我们来看一个如何使用POP链来实现SQL注入的例子。这个例子也来自[https://owasp.org/www-community/vulnerabilities/PHP_Object_Injection](https://owasp.org/www-community/vulnerabilities/PHP_Object_Injection)。
- en: 'Say an application defines a class called `Example3` somewhere in the code
    and deserializes unsanitized user input from the POST parameter `data`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设应用程序在代码的某个地方定义了一个名为`Example3`的类，并从POST参数`data`中反序列化未经清理的用户输入：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that `Example3` implements the `__toString()` magic method 1. In this
    case, when an `Example3` instance is treated as a string, it will return the result
    of the `getValue()` method run on its `$obj` property.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Example3`实现了`__toString()`魔术方法1。在这种情况下，当`Example3`实例被当作字符串处理时，它将返回在其`$obj`属性上运行的`getValue()`方法的结果。
- en: 'Let’s also say that, somewhere in the application, the code defines the class
    `SQL_Row_Value`. It has a method named `getValue()`, which executes a SQL query.
    The SQL query takes input from the `$_table` property of the `SQL_Row_Value` instance:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在应用程序的某个地方，代码定义了一个名为`SQL_Row_Value`的类。它有一个名为`getValue()`的方法，该方法执行SQL查询。SQL查询从`SQL_Row_Value`实例的`$_table`属性中获取输入：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'An attacker can achieve SQL injection by controlling the `$obj` in `Example3`.
    The following code will create an `Example3` instance with `$obj` set to a `SQL_Row_Value`
    instance, and with `$_table` set to the string `"SQL Injection"`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以通过控制`Example3`中的`$obj`来实现SQL注入。以下代码将创建一个`Example3`实例，将`$obj`设置为一个`SQL_Row_Value`实例，并将`$_table`设置为字符串`"SQL
    Injection"`：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As a result, whenever the attacker’s `Example3` instance is treated as a string,
    its `$obj`’s `get_Value()` method will be executed. This means the `SQL_Row_Value`’s
    `get_Value()` method will be executed with the `$_table` string set to `"SQL Injection"`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当攻击者的`Example3`实例被当作字符串处理时，它的`$obj`的`get_Value()`方法就会被执行。这意味着`SQL_Row_Value`的`get_Value()`方法将会执行，并且`$_table`字符串被设置为`"SQL
    Injection"`。
- en: The attacker has achieved a limited SQL injection, since they can control the
    string passed into the SQL query `SELECT * FROM {$this->_table} WHERE id = " .
    (int)$id;`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者已经实现了有限的SQL注入，因为他们可以控制传递到SQL查询中的字符串`SELECT * FROM {$this->_table} WHERE id
    = " . (int)$id;`。
- en: POP chains are similar to *return-oriented programming (**ROP)* attacks, an
    interesting technique used in binary exploitation. You can read more about it
    on Wikipedia, at [https://en.wikipedia.org/wiki/Return-oriented_programming](https://en.wikipedia.org/wiki/Return-oriented_programming)*.*
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: POP链类似于*基于返回的编程（**ROP)**攻击，这是一种在二进制利用中使用的有趣技术。你可以在维基百科上阅读更多相关内容，链接：[https://en.wikipedia.org/wiki/Return-oriented_programming](https://en.wikipedia.org/wiki/Return-oriented_programming)*。
- en: Java
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java
- en: 'Now that you understand how insecure deserialization in PHP works, let’s explore
    another programming language prone to these vulnerabilities: Java. Java applications
    are prone to insecure deserialization vulnerabilities because many of them handle
    serialized objects. To understand how to exploit deserialization vulnerabilities
    in Java, let’s look at how serialization and deserialization work in Java.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了PHP中不安全反序列化的工作原理，让我们来探索另一种易受此类漏洞影响的编程语言：Java。Java应用程序容易受到不安全反序列化漏洞的影响，因为许多Java应用程序处理序列化的对象。为了了解如何利用Java中的反序列化漏洞，我们来看看Java中序列化和反序列化是如何工作的。
- en: 'For Java objects to be serializable, their classes must implement the `java.io.Serializable`
    interface. These classes also implement special methods, `writeObject()` and `readObject()`,
    to handle the serialization and deserialization, respectively, of objects of that
    class. Let’s look at an example. Store this code in a file named *SerializeTest.java*:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要使Java对象可序列化，它们的类必须实现`java.io.Serializable`接口。这些类还实现了特殊方法`writeObject()`和`readObject()`，分别处理该类对象的序列化和反序列化。让我们看一个例子。将以下代码存储在名为*SerializeTest.java*的文件中：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, in the directory where you stored the file, run these commands. They
    will compile the program and run the code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在存储文件的目录中，运行以下命令。这些命令将编译程序并执行代码：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You should see the string `vickie` printed as the output. Let’s break down the
    program a bit. First, we define a class named `User` that implements `Serializable`
    1. Only classes that implement `Serializable` can be serialized and deserialized.
    The `User` class has a `username` attribute that is used to store the user’s username
    2.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到字符串`vickie`作为输出打印出来。我们来详细分析一下这个程序。首先，我们定义一个名为`User`的类，它实现了`Serializable`接口1。只有实现了`Serializable`接口的类才能被序列化和反序列化。`User`类有一个`username`属性，用于存储用户的用户名2。
- en: Then, we create a new `User` object 3 and set its username to the string `"vickie"`
    4. We write the serialized version of `newUser` and store it into the file *object.ser*
    5. Finally, we read the object from the file, deserialize it, and print out the
    user’s username 6.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个新的`User`对象3，并将其用户名设置为字符串`"vickie"` 4。我们将`newUser`的序列化版本写入并存储到文件*object.ser*
    5中。最后，我们从文件中读取对象，反序列化它，并打印出用户的用户名6。
- en: To exploit Java applications via an insecure deserialization bug, we first have
    to find an entry point through which to insert the malicious serialized object.
    In Java applications, serializable objects are often used to transport data in
    HTTP headers, parameters, or cookies.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用Java应用程序中的不安全反序列化漏洞，我们首先必须找到一个入口点，通过该入口点插入恶意的序列化对象。在Java应用程序中，序列化对象通常用于在HTTP头、参数或Cookies中传输数据。
- en: 'Java serialized objects are not human readable like PHP serialized strings.
    They often contain non-printable characters as well. But they do have a couple
    signatures that can help you recognize them and find potential entry points for
    your exploits:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Java序列化对象不像PHP序列化字符串那样易于阅读。它们通常包含不可打印的字符。但它们确实有几个标识符，可以帮助你识别它们并找到潜在的攻击入口：
- en: Starts with `AC ED 00 05` in hex or `rO0` in base64\. (You might see these within
    HTTP requests as cookies or parameters.)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在十六进制中以`AC ED 00 05`开头，或在Base64中以`rO0`开头。 (你可能会在HTTP请求中看到这些，作为Cookies或参数。)
- en: The `Content-Type` header of an HTTP message is set to `application/x-java-serialized-object`.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP消息的`Content-Type`头被设置为`application/x-java-serialized-object`。
- en: Since Java serialized objects contain a lot of special characters, it’s common
    to encode them before transmission, so look out for differently encoded versions
    of these signatures as well.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Java序列化对象包含很多特殊字符，因此在传输之前常常会对其进行编码，因此还需要注意这些标识符的不同编码版本。
- en: After you discover a user-supplied serialized object, the first thing you can
    try is to manipulate program logic by tampering with the information stored within
    the objects. For example, if the Java object is used as a cookie for access control,
    you can try changing the usernames, role names, and other identity markers that
    are present in the object, re-serialize it, and relay it back to the application.
    You can also try tampering with any sort of value in the object that is a filepath,
    file specifier, or control flow value to see if you can alter the program’s flow.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在发现一个用户提供的序列化对象后，你可以尝试的第一件事是通过篡改对象中存储的信息来操控程序逻辑。例如，如果Java对象作为访问控制的Cookie使用，你可以尝试更改其中的用户名、角色名和其他身份标识符，将其重新序列化后再返回给应用程序。你还可以尝试篡改对象中任何类型的值，例如文件路径、文件说明符或控制流值，看看是否能够改变程序的执行流程。
- en: Sometimes when the code doesn’t restrict which classes the application is allowed
    to deserialize, it can deserialize any serializable classes to which it has access.
    This means attackers can create their own objects of any class. A potential attacker
    can achieve RCE by constructing objects of the right classes that can lead to
    arbitrary commands.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当代码没有限制应用程序允许反序列化的类时，它可以反序列化任何它可以访问的序列化类。这意味着攻击者可以创建任何类的对象。潜在攻击者可以通过构造合适的类对象，导致任意命令的执行，从而实现远程代码执行（RCE）。
- en: Achieving RCE
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现RCE
- en: The path from a Java deserialization bug to RCE can be convoluted. To gain code
    execution, you often need to use a series of gadgets to reach the desired method
    for code execution. This works similarly to exploiting deserialization bugs using
    POP chains in PHP, so we won’t rehash the whole process here. In Java applications,
    you’ll find gadgets in the libraries loaded by the application. Using gadgets
    that are in the application’s scope, create a chain of method invocations that
    eventually leads to RCE.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Java 反序列化漏洞到远程代码执行（RCE）的路径可能会非常复杂。为了获得代码执行权限，你通常需要使用一系列工具链来达成最终的代码执行方法。这与使用
    PHP 中的 POP 链利用反序列化漏洞的方式类似，因此我们在这里不会重新描述整个过程。在 Java 应用程序中，你会在应用程序加载的库中找到这些工具链。通过使用应用程序范围内的工具链，创建方法调用链，最终实现远程代码执行。
- en: Finding and chaining gadgets to formulate an exploit can be time-consuming.
    You’re also limited to the classes available to the application, which can restrict
    what your exploits can do. To save time, try creating exploit chains by using
    gadgets in popular libraries, such as the Apache Commons-Collections, the Spring
    Framework, Apache Groovy, and Apache Commons FileUpload. You’ll find many of these
    published online.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 查找并串联工具链以构建利用载荷可能需要消耗大量时间。你还受限于应用程序中可用的类，这可能限制你的利用方式。为了节省时间，尝试通过使用流行库中的工具链来创建利用链，例如
    Apache Commons-Collections、Spring 框架、Apache Groovy 和 Apache Commons FileUpload。你会在网上找到很多此类资源。
- en: Automating the Exploitation by Using Ysoserial
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Ysoserial 自动化利用
- en: Ysoserial ([https://github.com/frohoff/ysoserial/](https://github.com/frohoff/ysoserial/))
    is a tool that you can use to generate payloads that exploit Java insecure deserialization
    bugs, saving you tons of time by keeping you from having to develop gadget chains
    yourself.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Ysoserial ([https://github.com/frohoff/ysoserial/](https://github.com/frohoff/ysoserial/))
    是一个工具，可以用来生成利用 Java 不安全反序列化漏洞的有效载荷，节省大量时间，避免你自己开发工具链。
- en: 'Ysoserial uses a collection of gadget chains discovered in common Java libraries
    to formulate exploit objects. With Ysoserial, you can create malicious Java serialized
    objects that use gadget chains from specified libraries with a single command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Ysoserial 使用在常见 Java 库中发现的工具链来构造利用对象。使用 Ysoserial，你可以通过一个命令创建使用指定库中的工具链的恶意 Java
    序列化对象：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For example, to create a payload that uses a gadget chain in the Commons-Collections
    library to open a calculator on the target host, execute this command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要创建一个利用 Commons-Collections 库中的工具链在目标主机上打开计算器的有效载荷，可以执行此命令：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The gadget chains generated by Ysoserial all grant you the power to execute
    commands on the system. The program takes the command you specified and generates
    a serialized object that executes that command.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Ysoserial 生成的工具链都能让你在系统上执行命令。该程序接受你指定的命令，并生成一个序列化对象来执行该命令。
- en: Sometimes the library to use for your gadget chain will seem obvious, but often
    it’s a matter of trial and error, as you’ll have to discover which vulnerable
    libraries your target application implements. This is where good reconnaissance
    will help you.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，使用哪个库来构建你的工具链似乎很明显，但通常这是一个试错过程，因为你必须发现目标应用程序实现了哪些易受攻击的库。这时，良好的侦察工作将会帮助你。
- en: You can find more resources about exploiting Java deserialization on GitHub
    at [https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet/](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet/).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到更多关于利用 Java 反序列化的资源，链接为 [https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet/](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet/)。
- en: Prevention
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防御措施
- en: Defending against deserialization vulnerabilities is difficult. The best way
    to protect an application against these vulnerabilities varies greatly based on
    the programming language, libraries, and serialization format used. No one-size-fits-all
    solution exists.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 防御反序列化漏洞是非常困难的。保护应用程序免受这些漏洞攻击的最佳方法根据所使用的编程语言、库和序列化格式的不同而有很大差异。没有一种通用的解决方案。
- en: You should make sure not to deserialize any data tainted by user input without
    proper checks. If deserialization is necessary, use an allowlist to restrict deserialization
    to a small number of allowed classes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该确保不会反序列化任何未经适当检查的用户输入污染的数据。如果必须反序列化，使用允许列表来限制反序列化仅限于少数允许的类。
- en: You can also use simple data types, like strings and arrays, instead of objects
    that need to be serialized when being transported. And, to prevent the tampering
    of serialized cookies, you can keep track of the session state on the server instead
    of relying on user input for session information. Finally, you should keep an
    eye out for patches and make sure your dependencies are up-to-date to avoid introducing
    deserialization vulnerabilities via third-party code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用简单的数据类型，如字符串和数组，而不是在传输时需要被序列化的对象。此外，为了防止序列化的 Cookie 被篡改，你可以在服务器上跟踪会话状态，而不是依赖用户输入的会话信息。最后，你应当关注补丁更新，确保你的依赖项是最新的，以避免通过第三方代码引入反序列化漏洞。
- en: 'Some developers try to mitigate deserialization vulnerabilities by identifying
    the commonly vulnerable classes and removing them from the application. This effectively
    restricts available gadgets attackers can use in gadget chains. However, this
    isn’t a reliable form of protection. Limiting gadgets can be a great layer of
    defense, but hackers are creative and can always find more gadgets in other libraries,
    coming up with creative ways to achieve the same results. It’s important to address
    the root cause of this vulnerability: the fact that the application deserializes
    user data insecurely.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发人员尝试通过识别常见的易受攻击的类并将其从应用程序中移除来缓解反序列化漏洞。这确实限制了攻击者在“工具链”中可以使用的有效工具。然而，这并不是一种可靠的防护方式。限制工具可以是一个很好的防御层，但黑客是富有创意的，他们总能在其他库中找到更多的工具，并通过创新的方式实现相同的结果。重要的是要解决这个漏洞的根本原因：应用程序不安全地反序列化用户数据。
- en: 'The OWASP Deserialization Cheat Sheet is an excellent resource for learning
    how to prevent deserialization flaws for your specific technology: [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP 反序列化备忘单是一个学习如何防止特定技术中的反序列化缺陷的优秀资源：[https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)。
- en: Hunting for Insecure Deserialization
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找不安全的反序列化
- en: Conducting a source code review is the most reliable way to detect deserialization
    vulnerabilities. From the examples in this chapter, you can see that the fastest
    way to find insecure deserialization vulnerabilities is by searching for deserialization
    functions in source code and checking if user input is being passed into it recklessly.
    For example, in a PHP application, look for `unserialize()`, and in a Java application,
    look for `readObject()`. In Python and Ruby applications, look for the functions
    `pickle.loads()` and `Marshall.load()`, respectively.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 进行源代码审查是检测反序列化漏洞最可靠的方法。从本章的示例中可以看到，寻找不安全的反序列化漏洞的最快方法是通过在源代码中搜索反序列化函数，并检查是否有用户输入被不加限制地传递到这些函数中。例如，在
    PHP 应用程序中，查找 `unserialize()`，在 Java 应用程序中，查找 `readObject()`。在 Python 和 Ruby 应用程序中，分别查找
    `pickle.loads()` 和 `Marshall.load()` 函数。
- en: But many bug bounty hunters have been able to find deserialization vulnerabilities
    without examining any code. Here are some strategies that you can use to find
    insecure deserialization without access to source code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 但许多漏洞奖励猎人已经能够在没有检查任何代码的情况下发现反序列化漏洞。以下是一些可以在没有源代码访问权限的情况下用来寻找不安全反序列化的策略。
- en: Begin by paying close attention to the large blobs of data passed into an application.
    For example, the base64 string `Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6InZpY2tpZSI7czo2OiJzdGF0dXMiO3M6OToibm90IGFkbWluIjt9`
    is the base64-encoded version of the PHP serialized string `O:4:"User":2:{s:8:"username";s:6:"vickie";s:6:"status";s:9:"not
    admin";}`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，密切关注传递到应用程序中的大块数据。例如，base64 字符串 `Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6InZpY2tpZSI7czo2OiJzdGF0dXMiO3M6OToibm90IGFkbWluIjt9`
    是 PHP 序列化字符串 `O:4:"User":2:{s:8:"username";s:6:"vickie";s:6:"status";s:9:"not
    admin";}` 的 base64 编码版本。
- en: 'And this is the base64 representation of a serialized Python object of class
    `Person` with a name attribute of `vickie`: `gASVLgAAAAAAAACMCF9fbWFpbl9flIwGUGVyc29ulJOUKYGUfZSMBG5hbWWUjAZWaWNraWWUc2Iu`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个序列化的 Python 对象的 base64 表示形式，类名为 `Person`，其中 `name` 属性的值为 `vickie`：`gASVLgAAAAAAAACMCF9fbWFpbl9flIwGUGVyc29ulJOUKYGUfZSMBG5hbWWUjAZWaWNraWWUc2Iu`。
- en: These large data blobs could be serialized objects that represent object injection
    opportunities. If the data is encoded, try to decode it. Most encoded data passed
    into web applications is encoded with base64\. For example, as mentioned earlier,
    Java serialized objects often start with the hex characters `AC ED 00 05` or the
    characters `rO0` in base64\. Pay attention to the `Content-Type` header of an
    HTTP request or response as well. For example, a `Content-Type` set to `application/x-java-serialized-object`
    indicates that the application is passing information via Java serialized objects.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些大数据块可能是表示对象注入机会的序列化对象。如果数据被编码了，尝试解码它。大多数传入Web应用程序的编码数据是用base64编码的。例如，如前所述，Java序列化对象通常以十六进制字符`AC
    ED 00 05`或base64编码的`rO0`开头。还要注意HTTP请求或响应的`Content-Type`头。例如，设置为`application/x-java-serialized-object`的`Content-Type`表示应用程序通过Java序列化对象传递信息。
- en: Alternatively, you can start by seeking out features that are prone to deserialization
    flaws. Look for features that might have to deserialize objects supplied by the
    user, such as database inputs, authentication tokens, and HTML form parameters.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以通过寻找容易受到反序列化缺陷影响的特性开始。查找可能需要反序列化用户提供的对象的功能，比如数据库输入、身份验证令牌和HTML表单参数。
- en: Once you’ve found a user-supplied serialized object, you need to determine the
    type of serialized object it is. Is it a PHP object, a Python object, a Ruby object,
    or a Java object? Read each programming language’s documentation to familiarize
    yourself with the structure of its serialized objects.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你找到了用户提供的序列化对象，你需要确定它是哪种类型的序列化对象。它是PHP对象、Python对象、Ruby对象还是Java对象？阅读每种编程语言的文档，熟悉其序列化对象的结构。
- en: Finally, try tampering with the object by using one of the techniques I’ve mentioned.
    If the application uses the serialized object as an authentication mechanism,
    try to tamper with the fields to see if you can log in as someone else. You can
    also try to achieve RCE or SQL injection via a gadget chain.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尝试使用我提到的技术篡改对象。如果应用程序将序列化对象用作身份验证机制，尝试篡改字段，看是否能够以其他用户身份登录。你还可以尝试通过小工具链实现远程代码执行或SQL注入。
- en: Escalating the Attack
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级攻击
- en: This chapter has already described how insecure deserialization bugs often result
    in remote code execution, granting the attacker a wide range of capabilities with
    which to impact the application. For that reason, deserialization bugs are valuable
    and impactful vulnerabilities. Even when RCE isn’t possible, you might be able
    to achieve an authentication bypass or otherwise meddle with the logic flow of
    the application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已经描述了不安全的反序列化漏洞如何通常导致远程代码执行，进而赋予攻击者广泛的能力来影响应用程序。因此，反序列化漏洞是宝贵且具有影响力的漏洞。即使无法实现远程代码执行（RCE），你也许可以绕过身份验证，或以其他方式干扰应用程序的逻辑流程。
- en: However, the impact of insecure deserialization can be limited when the vulnerability
    relies on an obscure point of entry, or requires a certain level of application
    privilege to exploit, or if the vulnerable function isn’t available to unauthenticated
    users.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当不安全的反序列化依赖于一个晦涩的入口点，或者需要一定级别的应用权限才能利用，或者如果该漏洞函数对未认证用户不可用时，不安全的反序列化影响可能会受到限制。
- en: When escalating deserialization flaws, take the scope and rules of the bounty
    program into account. Deserialization vulnerabilities can be dangerous, so make
    sure you don’t cause damage to the target application when trying to manipulate
    program logic or execute arbitrary code. Read Chapter 18 for tips on how to create
    safe PoCs for an RCE.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在提升反序列化缺陷时，要考虑赏金计划的范围和规则。反序列化漏洞可能是危险的，因此在尝试操作程序逻辑或执行任意代码时，确保不要对目标应用程序造成损害。阅读第18章，获取有关如何为远程代码执行（RCE）创建安全PoC的建议。
- en: Finding Your First Insecure Deserialization!
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到你的第一个不安全的反序列化漏洞！
- en: 'Now it’s time to dive in and find your first insecure deserialization vulnerability.
    Follow the steps we covered to find one:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候深入并找到你的第一个不安全的反序列化漏洞了。按照我们讲解的步骤去寻找：
- en: If you can get access to an application’s source code, search for deserialization
    functions in source code that accept user input.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你能够访问应用程序的源代码，搜索源代码中接受用户输入的反序列化函数。
- en: If you cannot get access to source code, look for large blobs of data passed
    into an application. These could indicate serialized objects that are encoded.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你无法访问源代码，可以查找传入应用程序的大块数据。这些数据可能表示被编码的序列化对象。
- en: Alternatively, look for features that might have to deserialize objects supplied
    by the user, such as database inputs, authentication tokens, and HTML form parameters.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，寻找可能需要反序列化由用户提供的对象的功能，例如数据库输入、身份验证令牌和HTML表单参数。
- en: If the serialized object contains information about the identity of the user,
    try tampering with the serialized object found and see if you can achieve authentication
    bypass.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果序列化的对象包含有关用户身份的信息，尝试篡改找到的序列化对象，看看能否实现身份验证绕过。
- en: See if you can escalate the flaw into a SQL injection or remote code execution.
    Be extra careful not to cause damage to your target application or server.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看是否可以将该漏洞升级为SQL注入或远程代码执行。务必小心，不要对目标应用程序或服务器造成损害。
- en: Draft your first insecure deserialization report!
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 撰写你的第一个不安全反序列化报告！
