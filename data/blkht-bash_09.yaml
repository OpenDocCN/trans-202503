- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 9 PRIVILEGE ESCALATION
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 权限提升
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In this chapter, you’ll learn about the various ways that unintentional system
    misconfigurations and a lack of hardening could help you elevate your privileges
    on a compromised host. We’ll explore how the Linux operating system grants permissions,
    examine a system’s sudo and PATH configurations, automate the search for sensitive
    files, manipulate vulnerable cron jobs, attack system accounts, discover kernel
    exploits, and more.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解各种意外的系统配置错误和缺乏强化措施如何帮助你在被攻陷的主机上提升权限。我们将探讨 Linux 操作系统如何授予权限，检查系统的 sudo
    和 PATH 配置，自动化搜索敏感文件，操控易受攻击的 cron 作业，攻击系统账户，发现内核漏洞等内容。
- en: What Is Privilege Escalation?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是权限提升？
- en: '*Privilege escalation* occurs when a low-privileged user is able to perform
    privileged operations that are outside the scope of the current user’s identity
    permissions by abusing misconfigurations, taking over other accounts, or exploiting
    other vulnerabilities. It’s an important stage in the compromise chain, because
    low-privileged accounts limit the actions you can take on a system. The following
    are examples of actions that an attacker might take but that are usually forbidden
    for nonroot users:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*权限提升* 发生在低权限用户通过滥用配置错误、接管其他账户或利用其他漏洞，能够执行超出当前用户身份权限范围的特权操作时。这是攻击链中的一个重要阶段，因为低权限账户限制了你在系统上可以执行的操作。以下是攻击者可能采取的操作示例，但这些操作通常是非
    root 用户所禁止的：'
- en: Reading system files that may contain sensitive information
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读可能包含敏感信息的系统文件
- en: Creating files and folders in privileged system locations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特权系统位置创建文件和文件夹
- en: Creating additional system users or modifying existing ones
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建额外的系统用户或修改现有用户
- en: Modifying or deleting sensitive files, such as logs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改或删除敏感文件，如日志文件
- en: Installing system-wide software packages
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装系统范围的软件包
- en: Modifying the configuration of services
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改服务的配置
- en: Enabling, disabling, or restarting services
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用、禁用或重启服务
- en: Of course, if misconfigurations exist on a system, we might be able to perform
    these actions from low-privileged accounts. For example, we might be able to write
    to a directory if it has the wrong permissions set, or read a sensitive file if
    it were copied to a path that is accessible by all system users and happened to
    inherit the permissions of its new location.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果系统存在配置错误，我们可能能够从低权限账户执行这些操作。例如，如果目录的权限设置错误，我们可能能够写入该目录；或者如果敏感文件被复制到所有系统用户都能访问的路径，并且继承了新位置的权限，我们可能能够读取该文件。
- en: 'Numerous conditions can enable privilege escalation: configuration mistakes,
    a lack of system hardening, poor software design, assumptions about the environment,
    and so on. Here are technical and theoretical examples that could lead to privilege
    escalation conditions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多条件可以导致权限提升：配置错误、缺乏系统强化、糟糕的软件设计、对环境的假设等等。以下是可能导致权限提升的技术和理论示例：
- en: Using vulnerable software packages or kernel versions
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用易受攻击的软件包或内核版本
- en: Granting overly lax permissions on dangerous utilities or processes
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在危险的实用程序或进程上授予过于宽松的权限
- en: Running applications by using privileged context, such as root
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特权上下文运行应用程序，例如 root 用户
- en: Assuming that all users are to be trusted
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设所有用户都可以被信任
- en: Storing reused credentials in files accessible to all users
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将重复使用的凭据存储在所有用户都可以访问的文件中
- en: Linux File and Directory Permissions
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux 文件和目录权限
- en: Every file and directory has a configuration made up of read (r), write (w),
    and execute (x) permissions. In addition, every file and directory is owned by
    a user and a group. As you learned in the previous chapter, Linux defines users
    in */etc/passwd* and groups in */etc/group*. Administrators grant permissions
    to a particular user, a particular group, and anyone else (also called *others*).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件和目录都有由读取（r）、写入（w）和执行（x）权限组成的配置。此外，每个文件和目录都有一个用户和一个组作为所有者。如你在前一章所学，Linux
    在 */etc/passwd* 中定义用户，在 */etc/group* 中定义组。管理员为特定用户、特定组和其他任何人（也叫做 *others*）授予权限。
- en: File and directory permissions and ownership can be changed accidentally or
    *made loose* because of a misconfiguration, meaning these resources have the potential
    to be exposed to unauthorized users. It is important to spot these misconfigurations
    when performing penetration tests.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 文件和目录的权限和所有权可能会因配置错误而不小心被更改或*变得松散*，这意味着这些资源有可能暴露给未经授权的用户。因此，在进行渗透测试时，发现这些配置错误非常重要。
- en: Viewing Permissions
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看权限
- en: 'Let’s examine the permission and ownership assignments of the */etc/passwd*
    file as an example. We’ll walk through the bolded part of the output, from left
    to right:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以*/etc/passwd*文件的权限和所有权分配为例。我们将从左到右查看输出的加粗部分：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first character represents the type of resource. A hyphen (-) indicates
    a file, while the d character would represent a directory.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字符表示资源的类型。连字符（-）表示文件，而字母d则表示目录。
- en: Next, rw- represents the file’s owner permissions. In this case, the permissions
    are set to read (r) and write (w). The last hyphen is a placeholder for the execute
    (x) permission, which isn’t set here.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，rw-表示文件所有者的权限。在这种情况下，权限设置为读取（r）和写入（w）。最后一个连字符是执行（x）权限的占位符，此处未设置该权限。
- en: 'The next set of permissions (r--) belongs to the group and indicates read access
    only. Other users also have only read access. The two instances of root represent
    the identity of the file’s owner and group: the *root* user and the root group.
    [Figure 9-1](chapter9.xhtml#fig9-1) illustrates this permission breakdown in a
    digestible way.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下一组权限（r--）属于组，仅表示读取权限。其他用户也仅具有读取权限。两次出现的root表示文件所有者和组的身份：*root*用户和root组。[图9-1](chapter9.xhtml#fig9-1)以简明的方式展示了这一权限分解。
- en: '![](../images/pg203.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg203.jpg)'
- en: 'Figure 9-1: Basic file permissions'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-1：基本文件权限
- en: In practice, these permissions mean that all local accounts can read the file
    but that only the *root* user can modify it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些权限意味着所有本地帐户都可以读取文件，但只有*root*用户可以修改它。
- en: Setting Permissions
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置权限
- en: 'We set Linux file and directory permissions by using the chmod command, and
    set file and directory ownership by using the chown command. To see these commands
    in action, create an empty file named *my_new_file.txt* on your Kali machine:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用chmod命令设置Linux文件和目录权限，使用chown命令设置文件和目录的所有权。为了演示这些命令的使用，您可以在Kali机器上创建一个名为*my_new_file.txt*的空文件：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, set this file’s user and group to *kali*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将该文件的用户和组设置为*kali*：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now set read, write, and execute permissions for the user (u+rwx), read permissions
    for the group (g+r), and read permissions for everyone else (o+r):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为用户设置读取、写入和执行权限（u+rwx），为组设置读取权限（g+r），为其他人设置读取权限（o+r）：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also represent file and directory permissions (but not ownership) by
    using *octal representation*, which uses the digits 0 through 7\. We set one digit
    for the user, one for the group, and one for others, producing a value such as
    777, 700, or 440. The permissions correspond to the following octal values:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用*八进制表示法*来表示文件和目录的权限（但不包括所有权），该表示法使用数字0到7。我们为用户、组和其他人分别设置一个数字，生成类似777、700或440的值。权限对应以下八进制值：
- en: The read (r) permission is 4.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取（r）权限是4。
- en: The write (w) permission is 2.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入（w）权限是2。
- en: The execute (x) permission is 1.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行（x）权限是1。
- en: The no permission value is 0.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无权限的值为0。
- en: To grant read, write, and execute permissions to everyone (that is, the user
    owner, the group, and anyone else), we’d add the three permission numbers. Read
    (4), write (2), and execute (1) added together equal 7. This means that if you
    set the permission 777, everyone would get read, write, and execute permissions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想授予所有人（即用户所有者、组和其他人）读取、写入和执行权限，我们需要将三个权限数字相加。读取（4）、写入（2）和执行（1）相加等于7。这意味着，如果设置权限为777，所有人都会获得读取、写入和执行权限。
- en: 'What if we want to grant only the user read access but deny access to the group
    and everyone else? Here is an example of how to do this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想授予用户读取权限，但拒绝组和其他人的访问权限，应该怎么做呢？以下是实现这一点的示例：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We use the octal value of 400, as 4 grants read access to the user and the two
    0 values set zero permissions for the group and everyone else.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用八进制值400，因为4授予用户读取权限，两个0值为组和其他人设置了零权限。
- en: Creating File Access Control Lists
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建文件访问控制列表
- en: We’ve covered the fundamentals of file and directory permissions and ownership,
    but a few other security mechanisms could also grant or prevent user access.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了文件和目录权限以及所有权的基础知识，但还有一些其他安全机制也可以授予或阻止用户访问。
- en: '*File access control lists (ACLs)* allow you to set additional permissions
    on files and directories at a more granular level. For example, say we have a
    group called *sysadmins* with a few members, such as Alice, Bob, and Eve, and
    we need to grant access to Alice and Bob, but not Eve. Setting the sysadmins group
    on a file or directory would instead grant all members access. ACLs allow us to
    grant or deny access to specific users on top of the existing permission scheme.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件访问控制列表（ACLs）*允许你在文件和目录上设置更细粒度的额外权限。例如，假设我们有一个名为*sysadmins*的组，其中包含几个成员，如Alice、Bob和Eve，我们需要授予Alice和Bob访问权限，但不授予Eve。将sysadmins组设置在文件或目录上将使所有成员都可以访问。ACL允许我们在现有权限方案的基础上授予或拒绝特定用户的访问权限。'
- en: 'The next example assumes you have a group named *sysadmins* and system users
    named Alice, Bob, and Eve. You can use the following commands to create these
    resources:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例假设你有一个名为*sysadmins*的组和名为Alice、Bob和Eve的系统用户。你可以使用以下命令来创建这些资源：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, let’s create a new empty file and observe its default ACLs. We use the
    getfacl command to achieve this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个新的空文件并观察其默认ACL。我们使用getfacl命令来实现这一点：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we’ll grant read access to the *sysadmins* group to ensure that Alice and
    Bob, who are members, can access it:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将授予*sysadmins*组读取权限，以确保Alice和Bob，作为组成员，可以访问它：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We pass the modify (-m) flag to setfacl so it modifies permissions, followed
    by the group name, the desired permissions (g:sysadmins:r--), and the target file
    or directory.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递modify（-m）标志给setfacl，以便它修改权限，接着是组名、所需权限（g:sysadmins:r--）以及目标文件或目录。
- en: 'At this point, all members of the group can read the file. How do we now exclude
    a particular user? Run the following command to remove all permissions for Eve:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，所有组成员都可以读取该文件。我们现在如何排除特定用户呢？运行以下命令以删除Eve的所有权限：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing the ACL permissions again should show that Eve has no access to the
    file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 再次列出ACL权限，应该会显示Eve无法访问该文件：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When a file or directory has ACLs set, Linux will show a plus sign (+) when
    you view the file’s permissions:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件或目录设置了ACL时，Linux在查看文件权限时会显示一个加号（+）：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It’s important to be aware that this security control is available.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这种安全控制是可用的。
- en: Viewing SetUID and SetGID
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看SetUID和SetGID
- en: '*Set User ID (SetUID)* is a special permission that can be set on executable
    files. It allows the executable to run with the permission of the user who owns
    the executable. For example, imagine that a script allows users on the system
    to delete logfiles from the */var/log* path. To do this without granting root
    privileges to users, a sysadmin can set the SetUID bit on the executable file.
    Likewise, the *Set Group ID (SetGID)* permission allows users to run executable
    files with the permissions of the owning group.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*Set用户ID（SetUID）*是一种特殊权限，可以在可执行文件上设置。它允许可执行文件以拥有该可执行文件的用户权限运行。例如，假设一个脚本允许系统上的用户删除*/var/log*路径中的日志文件。为了在不授予root权限的情况下允许用户这样做，系统管理员可以在可执行文件上设置SetUID位。同样，*Set组ID（SetGID）*权限允许用户以拥有组的权限运行可执行文件。'
- en: 'When an executable file has SetUID or SetGID set, you’ll see s instead of x
    in the file’s permissions. One file that uses both SetUID and SetGID is the At
    scheduler binary */usr/bin/at*, which we used in [Chapter 8](chapter8.xhtml) for
    task scheduling when we used the at command. Run the following command to see
    SetUID and SetGID:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当可执行文件设置了SetUID或SetGID时，你会看到文件权限中会出现s而不是x。一个同时使用SetUID和SetGID的文件是At调度器二进制文件*/usr/bin/at*，我们在[第8章](chapter8.xhtml)中使用at命令进行任务调度时使用了它。运行以下命令以查看SetUID和SetGID：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, you can see that SetUID is set, as indicated by the first s in the permissions,
    followed by SetGID, as indicated by the second s. Thus, when users run the at
    command, they run it with the permissions of the *daemon* user and group.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到SetUID已经设置，这可以从权限中的第一个s看到，接着是SetGID，可以从第二个s看到。因此，当用户运行at命令时，他们以*daemon*用户和组的权限运行。
- en: Another example of a command that uses the SetUID set to its executable is passwd,
    which changes account passwords. Executables set with SetUID and SetGID can be
    a security risk and are a prime target for privilege escalation. We will demonstrate
    an exploitation example in “Exploiting a SetUID Misconfiguration” on [page 208](#pg_208).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用SetUID设置其可执行文件的命令示例是passwd，它用于更改账户密码。设置了SetUID和SetGID的可执行文件可能存在安全风险，是特权提升的主要目标。我们将在“利用SetUID配置错误”中展示一个攻击示例，见[第208页](#pg_208)。
- en: Setting the Sticky Bit
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置粘滞位
- en: 'When the *sticky bit* is set on a directory, files under that directory can’t
    be deleted by users or groups who don’t own the files, even if the file’s permissions
    would otherwise allow the deletion. A good example of a directory with the sticky
    bit set is */tmp*. Run the following command to see it:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当在目录上设置*粘滞位*时，即使文件的权限允许删除，其他用户或用户组也无法删除该目录下的文件，除非他们拥有该文件。设置了粘滞位的目录的一个典型例子是*/tmp*。运行以下命令查看它：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The t means the sticky bit is set on this directory. To set a sticky bit on
    a directory, run the following commands:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: t表示该目录上设置了粘滞位。要在目录上设置粘滞位，请运行以下命令：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can also set the SetUID, SetGID, or sticky bit via the octal representation
    by prepending an additional digit before the permission: the sticky bit is 1,
    SetGID is 2, and SetUID is 4. To demonstrate this, let’s copy a binary from the
    system and change its permissions. Copy the *ping* binary into the */tmp* directory
    and name it *ping.backup*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过八进制表示法设置SetUID、SetGID或粘滞位，在权限前添加一个额外的数字：粘滞位为1，SetGID为2，SetUID为4。为了演示这一点，让我们从系统中复制一个二进制文件并更改其权限。将*ping*二进制文件复制到*/tmp*目录，并命名为*ping.backup*：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, set the file with the octal permission notation of 4700:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将文件的八进制权限标注设置为4700：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This sets SetUID (4), followed by read, write, and execute permissions for the
    user-owner only (700).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了SetUID（4），接着为用户所有者设置读、写和执行权限（700）。
- en: Finding Files Based on Permissions
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于权限查找文件
- en: '[Chapter 8](chapter8.xhtml) covered the FHS, which aims to standardize the
    locations of certain files and directories on Linux systems. But files, whether
    they’re configurations or the source code of an application, could live pretty
    much anywhere, so it’s important to figure out what is accessible to our current
    privilege context.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](chapter8.xhtml)介绍了FHS，它旨在标准化Linux系统中某些文件和目录的位置。但是，文件无论是配置文件还是应用程序的源代码，都可以存放在几乎任何地方，因此理解哪些文件在当前权限上下文中是可以访问的非常重要。'
- en: Luckily, searching for readable, writable, and executable files and directories
    is quite easy. Tools such as find can even locate files based on permissions.
    Let’s explore how to do this.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，查找可读、可写和可执行的文件和目录相当简单。像find这样的工具甚至可以根据权限定位文件。让我们来探索如何做到这一点。
- en: 'To search for files and directories that are readable by everyone on a system
    (meaning *others*), beginning from the root directory and searching recursively,
    use the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找系统上每个人都可以读取的文件和目录（即*其他*），从根目录开始递归搜索，请使用以下命令：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To search for files only, pass the -type f flag, and to search directories
    only, pass the -type d flag:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要只查找文件，请传递-type f标志；只查找目录，请传递-type d标志：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To suppress any access-denied errors while searching, pipe the standard error
    stream to */dev/null*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索时，要抑制任何访问拒绝错误，可以将标准错误流传递到*/dev/null*：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To search for files and directories that anyone can write to, use the following
    command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找任何人都可以写入的文件和目录，请使用以下命令：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A search for executable files and directories follows the same pattern. To
    search for files and directories that are executable by everyone, use the following
    command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 查找可执行文件和目录的方式遵循相同的模式。要搜索每个人都可以执行的文件和目录，请使用以下命令：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The term *executable directories* may sound confusing, but essentially, setting
    an executable permission (x) on a folder allows users to navigate into the directory
    (for example, with cd).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*可执行目录*这个术语可能会让人困惑，但本质上，在文件夹上设置可执行权限（x）允许用户进入该目录（例如，通过cd命令）。'
- en: 'You can combine these commands into one, such as the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些命令组合成一个，例如如下所示：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This command finds all globally readable, writable, and executable files.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令查找所有全局可读、可写和可执行的文件。
- en: 'The find command also allows us to search for particular permissions by using
    the -perm flag. We could use this to search for files set with either SetUID or
    SetGID. The following searches for SetGID files:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: find 命令还允许我们通过使用 -perm 标志来搜索特定的权限。我们可以利用这一点来搜索设置了 SetUID 或 SetGID 的文件。以下命令搜索
    SetGID 文件：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Similarly, this command searches for SetUID files:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，这个命令搜索 SetUID 文件：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can also locate directories set with the sticky bit flag:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以找到设置了粘滞位标志的目录：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Searching for these special permissions will likely yield results on most Linux
    systems, as some files have these permissions set by default. It’s important to
    become familiar with these files so you can easily distinguish between default
    system files and ones that were modified by the system owner.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数 Linux 系统中，搜索这些特殊权限可能会得到结果，因为某些文件默认就设置了这些权限。了解这些文件非常重要，这样你就可以轻松区分默认的系统文件和被系统所有者修改过的文件。
- en: Exploiting a SetUID Misconfiguration
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用 SetUID 配置错误
- en: Let’s exploit a program with the SetUID bit set. On the compromised machines,
    run a system-wide search for SetUID and SetGID files, then perform an internet
    search to figure out which of these files are meant to have these flags set and
    which are misconfigured.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用一个设置了 SetUID 位的程序。在被攻破的机器上，进行系统范围的 SetUID 和 SetGID 文件搜索，然后进行互联网搜索，找出哪些文件应当设置这些标志，哪些文件配置错误。
- en: Your search should identify *ELinks*, a web browser that allows users to surf
    websites directly from the command line by displaying results as simple text output.
    [Figure 9-2](chapter9.xhtml#fig9-2) shows what browsing Google looks like when
    using ELinks.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你的搜索应该能找到*ELinks*，它是一个让用户直接从命令行浏览网站并以简单文本输出显示结果的网页浏览器。[图 9-2](chapter9.xhtml#fig9-2)展示了使用
    ELinks 浏览 Google 的样子。
- en: '![](../images/pg209.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg209.jpg)'
- en: 'Figure 9-2: Browsing Google with the ELinks command line web browser'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2：使用 ELinks 命令行网页浏览器浏览 Google
- en: 'On the backup user account of *p-jumpbox-01* (172.16.10.13), you should find
    the ELinks binary located at */usr/bin/elinks.* To verify that the SetUID is set,
    use the ls or the stat command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在*p-jumpbox-01*（172.16.10.13）的备份用户帐户上，你应该能找到位于*/usr/bin/elinks*的 ELinks 二进制文件。要验证是否设置了
    SetUID，可以使用 ls 或 stat 命令：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'ELinks will execute in the *root* context when we run it, so if we’re able
    to get it to do something interesting, like read a local file, we should be able
    to access sensitive files available only to *root*. Explore the ELinks options
    by passing the --help flag to the command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 ELinks 时，它将在*root*上下文中执行，因此如果我们能让它做一些有趣的事，比如读取本地文件，我们应该能够访问仅限*root*用户访问的敏感文件。通过传递
    --help 标志来探索 ELinks 的选项：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, use the -dump 1 flag to read a website address and print it to the standard
    output stream:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 -dump 1 标志来读取网站地址并将其打印到标准输出流：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ELinks should parse data from the website, such as a collection of links, and
    print it to the terminal.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ELinks 应该从网站解析数据，例如链接集合，并将其打印到终端。
- en: 'How might we exploit this behavior? Well, just as the *http://* or *https://*
    schemes allow us to read data from websites, the *file:///* scheme allows web
    browsers to read files on the local system. Since we’re running as root, we can
    read sensitive paths such as */etc/shadow*, which stores password hashes:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何利用这种行为呢？就像*http://*或*https://*协议允许我们从网站读取数据一样，*file:/// *协议允许网页浏览器读取本地系统上的文件。由于我们是以
    root 用户身份运行，我们可以读取敏感路径，例如*/etc/shadow*，该文件存储密码的哈希值：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It’s important to note that while we abused ELinks, we didn’t exploit a vulnerability
    in ELinks itself; rather, we used a well-known browser feature for malicious purposes
    with the help of the SetUID bit.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，尽管我们滥用了 ELinks，但并没有利用 ELinks 本身的漏洞；相反，我们利用了一个众所周知的浏览器功能，配合 SetUID 位进行恶意操作。
- en: Scavenging for Credentials
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找凭证
- en: In this section, we cover places on the system where you might find sensitive
    files containing credentials. Even encrypted credentials could be weak and brute-forceable,
    and you might find them used across multiple servers. Privilege escalation doesn’t
    always involve a highly sophisticated exploit; if you discover credentials lying
    around on disk, you might be able to simply log in to a more powerful account.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本节我们将讨论系统中可能包含凭证的敏感文件位置。即使是加密的凭证也可能很弱并且容易暴力破解，而且你可能会发现它们在多个服务器上使用。权限提升并不总是涉及高度复杂的漏洞利用；如果你发现凭证散落在磁盘上，你可能只需要登录到一个更强大的帐户。
- en: Passwords and Secrets
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密码和秘密
- en: 'Passwords and secrets, such as API keys, can live in many places on a system.
    Administrators might run commands that contain their usernames and passwords,
    applications may log credentials in logfiles, and configuration files may contain
    credentials as part of a connection string. Search for credentials in places such
    as the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 密码和秘密，如 API 密钥，可能会存储在系统的多个位置。管理员可能会运行包含其用户名和密码的命令，应用程序可能会将凭据记录在日志文件中，配置文件可能包含作为连接字符串一部分的凭据。搜索凭据的地方包括：
- en: Configuration files under the */etc* directory
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/etc* 目录下的配置文件'
- en: Environment variables
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量
- en: Logfiles
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志文件
- en: History files of users
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的历史文件
- en: Scheduled tasks, such as cron jobs
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时任务，如 cron 作业
- en: Script files written in languages such as bash or Python
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 bash 或 Python 等语言编写的脚本文件
- en: Memory
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存
- en: Boot configuration files
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动配置文件
- en: Keyrings
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密钥环
- en: System files such as */etc/shadow*
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统文件，如 */etc/shadow*
- en: There are multiple approaches to uncovering such secrets. We could use bash
    to recursively search for password patterns, craft searches for specific files
    and extensions of interest, or manually inspect sensitive filesystem areas.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以揭示这些秘密。我们可以使用 bash 递归地搜索密码模式，针对特定的文件和感兴趣的扩展名构建搜索，或手动检查敏感的文件系统区域。
- en: 'Let’s modify the search techniques introduced in “Finding Files Based on Permissions”
    on [page 207](#pg_207) to look for specific filenames of interest. For example,
    search for readable files with the word *password* in them by using a case-insensitive
    grep filter:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改在“基于权限查找文件”一节中介绍的搜索技巧，查看感兴趣的特定文件名。例如，通过使用不区分大小写的 grep 过滤器，搜索包含 *password*
    关键字的可读文件：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then search for readable files that contain words such as *api_key*, *token*,
    and *key*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后搜索包含诸如 *api_key*、*token* 和 *key* 之类的词汇的可读文件：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You might also search for readable files with specific extensions like *.hashes*,
    *.env*, and *.credentials*:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以搜索具有特定扩展名的可读文件，如 *.hashes*、*.env* 和 *.credentials*：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Searching for hardcoded credentials without running into false positives is
    an art, but you could use data gleaned from the reconnaissance phase or external
    resources to build more fine-tuned search patterns.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索硬编码的凭据而不产生误报是一门艺术，但你可以使用侦查阶段获得的数据或外部资源来构建更精细化的搜索模式。
- en: 'One such resource is Nuclei’s inventory of templates for finding interesting
    data (such as passwords, API tokens, and cloud account IDs) in local files: *[https://github.com/projectdiscovery/nuclei-templates/tree/main/file/keys](https://github.com/projectdiscovery/nuclei-templates/tree/main/file/keys)*.
    For instance, the *github-oauth-token.yaml* template searches for the GitHub Open
    Authentication (OAuth) tokens used to log in to GitHub accounts:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个资源是 Nuclei 提供的模板库存，用于在本地文件中查找有趣的数据（如密码、API 令牌和云账户 ID）：*[https://github.com/projectdiscovery/nuclei-templates/tree/main/file/keys](https://github.com/projectdiscovery/nuclei-templates/tree/main/file/keys)*。例如，*github-oauth-token.yaml*
    模板搜索用于登录 GitHub 帐户的 GitHub 开放认证 (OAuth) 令牌：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This template looks for strings that start with the character sequence gho_
    and are followed by a string of 32 characters. If you don’t want to use Nuclei,
    you could input this regular expression into a grep search:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板查找以字符序列 gho_ 开头，后跟 32 个字符的字符串。如果你不想使用 Nuclei，可以将这个正则表达式输入到 grep 搜索中：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We use grep -E to specify a regular-expression-based filter. Alternatively,
    you could use egrep, a wrapper to the grep command that passes the -E flag under
    the hood, for convenience:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 grep -E 来指定基于正则表达式的过滤器。或者，你也可以使用 egrep，这是 grep 命令的包装器，底层会自动传递 -E 标志，方便使用：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You could also pass the -R flag to perform a recursive search:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以传递 -R 标志来执行递归搜索：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is useful for searching a directory that has many files, such as a web
    application’s source code directory.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于搜索具有大量文件的目录非常有用，例如 Web 应用的源代码目录。
- en: Private Keys
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 私钥
- en: Private keys are a huge asset to penetration testers. We can use them to connect
    to servers, decrypt files, perform man-in-the-middle attacks, and more. You might
    find private keys in restricted folders, such as */root*, or in an individual
    user’s home directory, depending on its type and owner.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥对渗透测试人员来说是一个巨大的资产。我们可以用它们连接到服务器，解密文件，执行中间人攻击等等。你可能会在受限文件夹中找到私钥，如 */root*，或在某个用户的家目录中，具体取决于其类型和所有者。
- en: SSH Keys
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SSH 密钥
- en: Unless modified, SSH private keys are usually named *id_rsa*, after the RSA
    cryptosystem, or *id_dsa*, after the Digital Signature Algorithm (DSA) cryptosystem,
    without an extension. Their corresponding public key is usually either *id_rsa.pub*
    or *id_dsa.pub*. You’ll typically find SSH keys under the hidden directory *.ssh*
    for each user account. For example, the user Eve’s SSH keys would be stored at
    */home/eve/.ssh/id_rsa* and */home/eve/.ssh/id_rsa.pub* if generated using RSA.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除非修改过，SSH 私钥通常命名为*id_rsa*，以 RSA 加密系统命名，或*id_dsa*，以数字签名算法（DSA）加密系统命名，没有扩展名。它们对应的公钥通常为*id_rsa.pub*或*id_dsa.pub*。通常，你会在每个用户账户的隐藏目录*.ssh*下找到
    SSH 密钥。例如，如果使用 RSA 生成，用户 Eve 的 SSH 密钥将存储在*/home/eve/.ssh/id_rsa*和*/home/eve/.ssh/id_rsa.pub*。
- en: 'SSH private keys have a well-defined file structure, shown here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 私钥具有明确定义的文件结构，如下所示：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The keys use *Privacy-Enhanced Mail (PEM)*, a common format to store and transfer
    cryptographic keys. PEM starts with a header (BEGIN), followed by the key data
    and a footer (END). Here are common headers you may see in the wild:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些密钥使用*隐私增强邮件 (PEM)*格式，这是一种用于存储和传输加密密钥的常见格式。PEM 以一个头部（BEGIN）开始，接着是密钥数据，最后是尾部（END）。以下是你可能在实际应用中看到的常见头部：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Recursively searching for these strings in files is fairly easy. For example,
    take a look at this grep command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中递归搜索这些字符串是相当容易的。例如，看看这个 grep 命令：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The -R option searches recursively, and the double dash (--) prior to the search
    pattern "-----BEGIN" signifies the end of the arguments. This allows us to easily
    search for strings that contain dashes, such as the ones in PEM headers.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: -R 选项会递归搜索，而在搜索模式 "-----BEGIN" 前的双短横线（--）表示参数的结束。这使我们能够轻松地搜索包含短横线的字符串，例如 PEM
    头部中的字符串。
- en: 'You could also try to search for keys of the following types: ecdsa, ecdsa-sk,
    ed25519, and ed25519-sk. Changing the key type will change the names of the generated
    keys. For rcdsa, the keys are named *id_ecdsa* and *id_ecdsa.pub*, whereas for
    ed25519, they’re named *id_ed25519* and *id_ed25519.pub*.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以尝试搜索以下类型的密钥：ecdsa、ecdsa-sk、ed25519 和 ed25519-sk。更改密钥类型会改变生成的密钥的名称。对于 rcdsa，密钥的名称是*id_ecdsa*和*id_ecdsa.pub*，而对于
    ed25519，密钥的名称是*id_ed25519*和*id_ed25519.pub*。
- en: Also look for *SSH host keys*, the cryptographic keys that validate a server’s
    identity. When an SSH client connects to an SSH server, the client checks the
    server’s identity by using the public host key, which is stored in the client’s
    *known_hosts* file. If this public key has changed, the SSH client generates an
    alert saying it can’t verify the host.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要查找*SSH 主机密钥*，即验证服务器身份的加密密钥。当 SSH 客户端连接到 SSH 服务器时，客户端会通过使用存储在客户端*known_hosts*文件中的公钥来验证服务器的身份。如果该公钥发生变化，SSH
    客户端会生成一个警告，表示无法验证主机。
- en: Public and private SSH host keys are usually stored under the */etc/ssh* directory
    and may have names such as *ssh_host_ecdsa_key*, *ssh_host_rsa_key*, *ssh_host_ed25519_key*,
    *ssh_host_ecdsa_key.pub*, *ssh_host_rsa_key.pub*, or *ssh_host_ed25519_key.pub*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 公共和私有 SSH 主机密钥通常存储在*/etc/ssh*目录下，并可能具有如下名称：*ssh_host_ecdsa_key*、*ssh_host_rsa_key*、*ssh_host_ed25519_key*、*ssh_host_ecdsa_key.pub*、*ssh_host_rsa_key.pub*或*ssh_host_ed25519_key.pub*。
- en: These keys are usually generated automatically when the server is provisioned,
    though it’s also possible to manually generate them. Compromising SSH host keys
    could allow you to impersonate a server on a network.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些密钥通常在服务器配置时自动生成，但也可以手动生成。泄露 SSH 主机密钥可能会使你能够在网络上冒充一个服务器。
- en: PGP Keys
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PGP 密钥
- en: '*Pretty Good Privacy (PGP)* is an encryption scheme used to encrypt files,
    emails, and more. Like SSH keys, PGP private keys use the PEM format. They look
    something like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*Pretty Good Privacy (PGP)* 是一种用于加密文件、电子邮件等的加密方案。像 SSH 密钥一样，PGP 私钥使用 PEM 格式。它们看起来像这样：'
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*GNU Privacy Guard (GnuPG)* is an implementation of OpenPGP (defined in RFC
    4880) that provides command line utilities for managing PGP keys. It lets you
    generate keys, import and export keys, verify signatures, and more.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*GNU Privacy Guard (GnuPG)* 是 OpenPGP（在 RFC 4880 中定义）的一个实现，它提供了用于管理 PGP 密钥的命令行工具。它可以让你生成密钥、导入和导出密钥、验证签名等。'
- en: You can generate a GnuPG key by using the gpg tool and running the gpg --generate-key
    command. When a user generates keys with GnuPG, it stores the keys in a keyring
    that is usually located in a hidden dot directory named *.gnupg* under the user’s
    home directory. (Users can change the keyring’s location by setting the environment
    variable GNUPGHOME to a different directory location.)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用gpg工具通过运行gpg --generate-key命令来生成一个GnuPG密钥。当用户使用GnuPG生成密钥时，它会将密钥存储在通常位于用户主目录下的名为*.gnupg*的隐藏目录中的密钥环中。（用户可以通过设置环境变量GNUPGHOME，将密钥环的位置更改为其他目录位置。）
- en: Within this directory, the*~/.gnupg/private-keys-v1.d/* folder contains private
    keys, the *~/.gnupg/trustdb.gpg* file contains the GnuPG trust database, and the
    *~/.gnupg/pubring.kbx* file contains metadata. Therefore, you first need to have
    access to an account before being able to list the account’s keys.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在此目录中，*~/.gnupg/private-keys-v1.d/*文件夹包含私钥，*~/.gnupg/trustdb.gpg*文件包含GnuPG信任数据库，*~/.gnupg/pubring.kbx*文件包含元数据。因此，你首先需要访问一个账户，才能列出该账户的密钥。
- en: 'Let’s export PGP keys from one of the lab’s machines. On *p-web-01* (172.16.10.10),
    run the following command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实验室的一台机器上导出PGP密钥。在*p-web-01*（172.16.10.10）上，运行以下命令：
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This should output any PGP keys accessible to the user, including keys that
    appear to belong to a server account, *arodriguez@acme-infinity-servers.com*:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出任何用户可访问的PGP密钥，包括看起来属于服务器账户的密钥，*arodriguez@acme-infinity-servers.com*：
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we wanted to steal this private key, we could export it to a file in the
    following way:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想窃取这个私钥，可以按照以下方式将其导出到文件：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The --output private.pgp argument writes the content to a file, --armor outputs
    the key in ASCII format, and --export-secret-key arodriguez@acme-infinity-servers.com
    specifies the key to export based on an email address.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: --output private.pgp参数将内容写入文件，--armor将密钥以ASCII格式输出，--export-secret-key arodriguez@acme-infinity-servers.com指定基于电子邮件地址导出的密钥。
- en: In certain cases, however, this export may fail. This is because GnuPG keys
    can be protected if the creator used a passphrase during the key generation, and
    you’ll need to supply the passphrase to perform the export. In Exercise 16, we’ll
    cover a way to bypass this protection by using bash.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，这种导出可能会失败。原因是如果创建者在生成密钥时使用了密码短语，GnuPG密钥可能会受到保护，此时你需要提供密码短语才能执行导出操作。在练习16中，我们将介绍通过使用bash绕过这种保护的方法。
- en: Certificates
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 证书
- en: In the post-compromise stage of a penetration test, you may sometimes encounter
    a server that transmits data over encrypted channels. For example, a web server
    might send HTTP data over SSL to clients.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试的后渗透阶段，你有时可能会遇到通过加密通道传输数据的服务器。例如，Web服务器可能通过SSL将HTTP数据发送给客户端。
- en: Popular web servers such as Apache or nginx commonly store certificates in */etc/ssl/certs*
    and private keys in */etc/ssl/private*. Certificates usually have the *.crt* extension,
    while private keys have the *.key* or *.pem* extensions. Those PEM files could
    contain just the public key, or they could store the entire certificate chain
    (including the private key, the public key, and root certificates).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 像Apache或nginx这样的流行Web服务器通常将证书存储在*/etc/ssl/certs*中，将私钥存储在*/etc/ssl/private*中。证书通常以*.crt*为扩展名，而私钥以*.key*或*.pem*为扩展名。这些PEM文件可能仅包含公钥，或者它们可能存储整个证书链（包括私钥、公钥和根证书）。
- en: 'If you have access to an Apache or nginx configuration file, the configuration
    keys listed therein usually point to the location of the certificate and its private
    key. We’ve bolded these keys in the following nginx configuration file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有访问Apache或nginx配置文件的权限，配置文件中列出的配置密钥通常会指向证书及其私钥的位置。我们在以下nginx配置文件中将这些密钥加粗显示：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'These keys look like the following in the Apache configuration for an HTTPS-enabled
    website:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用了HTTPS的Apache网站配置中，这些密钥通常如下所示：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You could perform a system-wide search for nginx or Apache configuration files,
    then cross-examine the location of the keys to see whether they’re accessible
    to you.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以进行全系统搜索，查找nginx或Apache的配置文件，然后交叉检查密钥的位置，看看它们是否对你可访问。
- en: 'Proxies can also be configured to use SSL. Here is an example configuration
    file for HAProxy, with the location of the PEM file shown in bold:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 代理也可以配置为使用SSL。以下是HAProxy的示例配置文件，其中PEM文件的位置以粗体显示：
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'HAProxy, which performs load balancing, may define a few backend servers, each
    with its own certificate files:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 执行负载均衡的HAProxy可能会定义几个后端服务器，每个服务器都有自己的证书文件：
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can identify these files based on the *ca-file* parameter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据*ca-file*参数识别这些文件。
- en: 'Exercise 16: Brute-Forcing GnuPG Key Passphrases'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 16：暴力破解 GnuPG 密钥密码短语
- en: When passphrase protection exists on a GnuPG key, you won’t be able to export
    the key without providing the passphrase. No sweat, though; there is a bash-y
    way to brute-force the passphrase.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当 GnuPG 密钥启用了密码短语保护时，您无法在未提供密码短语的情况下导出密钥。不过，别担心；有一种 bash 风格的方法可以暴力破解密码短语。
- en: '[Listing 9-1](chapter9.xhtml#Lis9-1) operates on a file named *passphrases.txt*
    containing a bunch of possible passphrases. It assumes the GnuPG key’s ID is the
    email *identity@blackhatbash.com*.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-1](chapter9.xhtml#Lis9-1) 操作的是一个名为 *passphrases.txt* 的文件，该文件包含了一些可能的密码短语。它假设
    GnuPG 密钥的 ID 为电子邮件 *identity@blackhatbash.com*。'
- en: gnupg_passphrase_bf.sh
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: gnupg_passphrase_bf.sh
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Listing 9-1: Brute-forcing protected GnuPG private keys'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-1：暴力破解受保护的 GnuPG 私钥
- en: In this script, we define a variable named KEY_ID to specify the key ID we want
    to brute-force ❶. At ❷, we list the keys available and grep for the key ID we’ll
    be brute-forcing to ensure it exists. Then we iterate over the *passphrase.txt*
    file line by line by using a while loop, echo the passphrase ❸, and pass it as
    input to the gpg command.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本中，我们定义了一个名为 `KEY_ID` 的变量，用于指定我们要暴力破解的密钥 ID ❶。在 ❷，我们列出了所有可用的密钥，并使用 `grep`
    查找要暴力破解的密钥 ID，以确保该密钥存在。然后，我们通过 while 循环逐行遍历 *passphrase.txt* 文件，回显密码短语 ❸，并将其作为输入传递给
    gpg 命令。
- en: This command takes a bunch of important parameters that allow us to brute-force
    the passphrase in an automated fashion. The --batch --yes flag allows the pgp
    command to execute while unattended, --pinentry-mode loopback allows us to fake
    a pin entry, --passphrase-fd 0 makes pgp read the passphrase from file descriptor
    zero (the standard input stream), --output writes the output to a file of our
    choice, --armor formats the exported key by using ASCII, and --export-secret-key
    is the key identifier to export.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令包含一系列重要参数，使我们能够以自动化的方式暴力破解密码短语。`--batch --yes` 标志允许 pgp 命令在无人值守的情况下执行，`--pinentry-mode
    loopback` 允许我们伪造密码输入，`--passphrase-fd 0` 使 pgp 从文件描述符零（标准输入流）读取密码短语，`--output`
    将输出写入我们选择的文件，`--armor` 使用 ASCII 格式化导出的密钥，`--export-secret-key` 是用于导出密钥的标识符。
- en: If the pgp command returns an exit code of zero, either the passphrase worked
    or no passphrase was set to begin with, at which point we exit.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 pgp 命令返回的退出代码为零，表示密码短语有效，或者根本没有设置密码短语，此时我们退出。
- en: NOTE
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*You can find this chapter’s scripts at* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch09](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch09).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*您可以在此章节的脚本位于* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch09](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch09)。'
- en: To take this exploitation further and practice your bash scripting, improve
    the script so it can iterate through all available key identities and brute-force
    them one by one.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步利用这一漏洞并练习您的 bash 脚本编写，改进脚本以便它能够遍历所有可用的密钥身份，并逐一进行暴力破解。
- en: Examining the sudo Configuration
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查 sudo 配置
- en: The sudo Linux command elevates a user’s permissions to root without granting
    that user direct access to the root account. Imagine that you’re the administrator
    of a server and want to give another user the ability to add new firewall rules.
    While you could just hand them the root account password, doing so could lead
    to a compromise. With sudo, you could grant permissions to run, say, the iptables
    command or a tool like tcpdump without revealing the root account’s password.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo` Linux 命令将用户权限提升为 root，而不授予该用户直接访问 root 账户的权限。假设您是服务器的管理员，并希望授予其他用户添加新防火墙规则的能力。虽然您可以直接将
    root 账户密码交给他们，但这样做可能会导致安全问题。使用 `sudo`，您可以授予该用户运行某些命令的权限，比如 `iptables` 命令或类似 `tcpdump`
    的工具，而不暴露 root 账户的密码。'
- en: 'From an attacker’s perspective, the sudo configuration is worth exploring,
    as a misconfiguration could grant you access to sensitive resources. On your Kali
    machine, the built-in *kali* user has sudo access by default. You can test it
    by running the following command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从攻击者的角度来看，sudo 配置值得探索，因为配置错误可能会让您访问敏感资源。在 Kali 机器上，内置的 *kali* 用户默认具有 sudo 权限。您可以通过运行以下命令来测试：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The command should then prompt you to enter your login password:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，命令会提示您输入登录密码：
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The -l flag lists the current user’s sudo privileges. As you can see, the user
    has (ALL : ALL) ALL, which basically means unlimited privileged access.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`-l` 标志列出当前用户的 sudo 权限。如您所见，用户具有 (ALL : ALL) ALL，这基本上意味着无限制的特权访问。'
- en: 'The sudo command can grant granular permissions thanks to its configuration
    file */etc/sudoers*. Here are a few permission grants you could achieve with advanced
    sudo configurations:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: sudo命令通过其配置文件*/etc/sudoers*可以授予精细化权限。以下是一些通过高级sudo配置可以实现的权限授予：
- en: Granting sudo permissions to a particular user or group
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为特定用户或组授予sudo权限
- en: Granting sudo permissions to a particular user or group for a particular system
    command only
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅为特定用户或组授予特定系统命令的sudo权限
- en: Granting sudo permissions to a particular user or group for a particular script
    only
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅为特定用户或组授予特定脚本的sudo权限
- en: Granting sudo permission to run a command without requiring the user to enter
    their password
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授予sudo权限，以便运行命令时无需用户输入密码
- en: 'To supplement */etc/sudoers*, the */etc/sudoers.d* directory can store independent
    sudo configuration files. The main */etc/sudoers* file can import files from this
    directory by using the @includedir instruction:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了补充*/etc/sudoers*，*/etc/sudoers.d*目录可以存储独立的sudo配置文件。主*/etc/sudoers*文件可以通过使用@includedir指令从此目录导入文件：
- en: '[PRE50]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Keep in mind that */etc/sudoers* can be modified only by privileged users and
    is readable only by the *root* user and root group:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，*/etc/sudoers*只能由特权用户修改，并且只有*root*用户和root组可以读取：
- en: '[PRE51]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If you’re able to write to this file or into the directory */etc/sudoers.d*,
    you should be able to grant yourself root access; by default, however, you aren’t
    able to do this.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够写入此文件或目录*/etc/sudoers.d*，你应该能够为自己授予root权限；然而，默认情况下，你无法执行此操作。
- en: 'In Kali, any member of the *kali-trusted* group is granted sudo access without
    requiring a password, as defined in the */etc/sudoers.d/kali-grant-root* file:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kali中，*kali-trusted*组的任何成员都可以在不需要密码的情况下获得sudo访问权限，这在*/etc/sudoers.d/kali-grant-root*文件中定义：
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Since the *kali* user is not part of the *kali-trusted* group, this user has
    sudo privileges but is required to supply a password whenever it’s used.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*kali*用户不属于*kali-trusted*组，因此该用户具有sudo权限，但每次使用时都需要提供密码。
- en: 'However, the *kali* user is part of the *sudo* group, referenced in */etc/sudoers*.
    Users who are members of this group are automatically granted unlimited sudo access,
    as defined by this configuration line:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，*kali*用户属于*/etc/sudoers*中提到的*sudo*组。此组的成员将自动获得无限制的sudo访问权限，如下配置行所定义：
- en: '[PRE53]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To see the list of groups the *kali* user is a member of, run the groups command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看*kali*用户所属的组列表，可以运行groups命令：
- en: '[PRE54]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here are a few examples of sudo configurations that could lead to privilege
    escalation scenarios:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些可能导致权限提升场景的sudo配置示例：
- en: The system could grant you sudo permissions on dangerous commands, including
    shell commands that could land you in a root shell.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统可能会授予你在危险命令上的sudo权限，包括可能将你带入root shell的shell命令。
- en: The system could configure sudo on a script that is writable by all users on
    a system, allowing unauthorized users to add malicious commands that would get
    executed with the root context.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统可能会在一个所有用户都可写的脚本上配置sudo，允许未经授权的用户添加恶意命令，这些命令将以root权限执行。
- en: Groups containing a large number of users could be granted sudo, expanding the
    attack surface and adding more ways to gain sudo access (as you could attempt
    to exploit each of the sudo group members).
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 含有大量用户的组可能被授予sudo权限，这会扩大攻击面并增加获得sudo访问权限的途径（因为你可以尝试利用每个sudo组成员）。
- en: The next section should help you understand the dangers of granting sudo access.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将帮助你理解授予sudo访问权限的危险。
- en: Abusing Text Editor Tricks
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滥用文本编辑器技巧
- en: 'Let’s walk through an attack that relies on sudo access. As the backup user
    on *p-jumpbox-01* (176.16.10.13), run the sudo -l command and provide the password
    (*backup*) when prompted. Then view the sudo configuration for this user:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们演示一个依赖于sudo访问权限的攻击。作为*p-jumpbox-01*（176.16.10.13）上的备份用户，运行sudo -l命令，并在提示时输入密码（*backup*）。然后查看该用户的sudo配置：
- en: '[PRE55]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It looks like we’ve been granted sudo access on vi, a text editor. Granting
    sudo permissions on a text editor may seem innocent, but it’s not.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们已获得了vi（一个文本编辑器）的sudo访问权限。为文本编辑器授予sudo权限看似无害，但实际上并非如此。
- en: For instance, we could pass a file to the vi command to tell it to write to
    that file. When granted sudo access, we can write to any file we’d like or create
    new files in system locations that are accessible or writable to the *root* user
    only.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将一个文件传递给vi命令，指示它写入该文件。当获得sudo访问权限时，我们可以写入任何文件，或者在系统仅对*root*用户可访问或可写的系统位置创建新文件。
- en: 'Let’s write a file to a system location that regular users aren’t allowed to
    access under normal circumstances. Enter the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将一个文件写入一个普通用户通常无法访问的系统位置。请输入以下内容：
- en: '[PRE56]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: A text editor prompt should appear. Press the I key on the keyboard, then enter
    anything you like. When done, press ESC, followed by SHIFT-:. Enter wq! and press
    ENTER to save the file and quit. You’ll notice that we are able to write the file
    to the */etc* directory, which is writable by privileged users only. Similarly,
    we could edit any file on the system, such as */etc/passwd* and */etc/shadow*,
    or even insert a backdoor to an application directly.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 应该会出现一个文本编辑器提示。按键盘上的 I 键，然后输入你喜欢的内容。完成后，按 ESC，再按 SHIFT-:。输入 wq! 并按 ENTER 保存文件并退出。你会注意到我们能够将文件写入
    */etc* 目录，而该目录只有特权用户才能写入。同样地，我们可以编辑系统上的任何文件，例如 */etc/passwd* 和 */etc/shadow*，甚至直接插入应用程序后门。
- en: To take advantage of this access, try dropping yourself into a root shell. vi
    allows the execution of bash commands from within the text editor’s window. This
    feature is convenient when you’re programming and need to execute shell commands
    to see the output or to view files outside the script.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这种访问权限，尝试将自己切换到 root shell。vi 允许在文本编辑器窗口内执行 bash 命令。当你在编程时需要执行 shell 命令以查看输出或查看脚本外的文件时，这个功能非常方便。
- en: 'Enter sudo vi in the terminal, then press SHIFT-: and enter !bash. You should
    now be in a root shell! Enter the whoami command to confirm you’re the root user.
    At this point, you should set the root account’s password by using the passwd
    command (without any additional parameters) so that you can easily log in to it
    at any point.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '在终端中输入 sudo vi，然后按 SHIFT-: 并输入 !bash。你现在应该已经进入 root shell！输入 whoami 命令确认你是
    root 用户。此时，你应该使用 passwd 命令（不带任何额外参数）设置 root 账户的密码，以便随时能够轻松登录。'
- en: Downloading Malicious sudoers Files
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载恶意的 sudoers 文件。
- en: In the previous section, you may have noticed that we also have sudo access
    to curl, used to read resources from web servers. You may be asking yourself,
    What could we possibly do with sudo access to a command line–based HTTP client?
    Well, quite a bit!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一部分中，你可能已经注意到我们还拥有对 curl 的 sudo 访问权限，用于从 Web 服务器读取资源。你可能会问，拥有对基于命令行的 HTTP
    客户端的 sudo 访问权限，我们能做什么呢？嗯，很多事情！
- en: If you look at the curl manual page, you’ll see it provides an -o (output) flag
    for writing content into files or directories. This means you can download files
    with curl by making a GET request to a website and redirect the output to a file
    by using the -o flag.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 curl 手册页面，你会看到它提供了 -o（输出）标志，用于将内容写入文件或目录。这意味着你可以通过向网站发出 GET 请求并使用 -o 标志将输出重定向到文件来下载文件。
- en: 'To exploit this behavior, we could set up a remote web server that serves a
    configuration file; if we can download this file in a way that overwrites an existing
    file, we could elevate our permissions or gain new access. Let’s exploit *p-jumpbox-01*
    (176.16.10.13) once again to elevate from the backup user to the *root* user.
    Here are a few directions we could take:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这种行为，我们可以设置一个远程 Web 服务器，提供一个配置文件；如果我们能以某种方式下载这个文件并覆盖现有文件，就可以提升我们的权限或获得新的访问权限。让我们再次利用
    *p-jumpbox-01*（176.16.10.13）从备份用户提升到 *root* 用户。以下是我们可以采取的几个方向：
- en: Serving modified versions of */etc/passwd* and */etc/shadow* files that would
    change the password of the *root* user
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供修改过的 */etc/passwd* 和 */etc/shadow* 文件，这些文件会改变 *root* 用户的密码。
- en: Serving a modified version of */etc/sudoers* so it grants sudo permissions to
    the backup user
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供修改过的 */etc/sudoers* 文件，使其授予备份用户 sudo 权限。
- en: Inserting a new sudo configuration into the */etc/sudoers.d* directory
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 */etc/sudoers.d* 目录中插入新的 sudo 配置。
- en: Serving a cron-job shell script that runs in the context of the system (as root)
    and is tasked with taking privileged actions on our behalf
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个 cron-job shell 脚本，它以系统（root）身份运行，并负责代表我们执行特权操作。
- en: 'We’ll take the third option: serving a custom *sudoers* file from the Kali
    machine and inserting it into the target’s */etc/sudoers.d* directory.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择第三个选项：从 Kali 机器提供一个自定义的 *sudoers* 文件，并将其插入到目标的 */etc/sudoers.d* 目录。
- en: 'First, grab the new sudo configuration file, *add-sudo-to-user*, from the book’s
    GitHub repository and place it somewhere on your filesystem, such as the Kali
    home directory. Next, open a terminal and navigate to the directory where the
    downloaded file is located. Then run the following command to start a web server
    on port 8080:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从本书的GitHub仓库获取新的sudo配置文件*add-sudo-to-user*，并将其放置在文件系统中的某个位置，例如Kali的主目录。接下来，打开终端并导航到下载文件所在的目录。然后运行以下命令，在8080端口启动一个Web服务器：
- en: '[PRE57]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Next, as the *p-jumpbox-01* backup user, run the following command to download
    the file from Kali. Kali’s lab IP address should be 172.16.10.1:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，作为*p-jumpbox-01*备份用户，运行以下命令从Kali下载文件。Kali的实验室IP地址应该是172.16.10.1：
- en: '[PRE58]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This curl command uses the -s flag (silent) to suppress output such as the download
    progress bar. We then make a GET request to the Kali machine to grab *add-sudo-to-user*.
    The -o (output) flag points to a filesystem destination where the output of the
    GET request will be saved. In this case, we use the */etc/sudoers.d* directory.
    Confirm that the file was successfully pulled by using ls to list the files in
    */etc/sudoers.d*. Then run the sudo -l command to see that you now have full sudo
    access.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个curl命令使用-s标志（静默模式）来抑制输出，比如下载进度条。然后我们向Kali机器发起GET请求来获取*add-sudo-to-user*。-o（输出）标志指向一个文件系统目标位置，GET请求的输出将被保存到该位置。在这种情况下，我们使用*/etc/sudoers.d*目录。使用ls命令列出*/etc/sudoers.d*中的文件来确认文件是否已成功下载。然后运行sudo
    -l命令，查看你现在是否拥有完整的sudo权限。
- en: Keep in mind that manually modifying the *sudoers* file is quite dangerous.
    Any errors you make could impact your ability to regain sudo access in the future,
    so we highly recommend using a dedicated sudo modification tool like visudo to
    modify sudo configurations. This tool catches syntax errors early so you don’t
    get locked out.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，手动修改*sudoers*文件是非常危险的。任何错误可能会影响你将来重新获得sudo访问权限的能力，因此我们强烈建议使用像visudo这样的专用sudo修改工具来修改sudo配置。该工具可以及早捕捉语法错误，避免你被锁定。
- en: After successfully compromising the root account, we recommend setting the account’s
    password to *passwd* so you can easily switch to the account later.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功攻陷root账户后，我们建议将账户密码设置为*passwd*，以便稍后能够轻松切换到该账户。
- en: Hijacking Executables via PATH Misconfigurations
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过PATH配置错误劫持可执行文件
- en: The PATH environment variable is a colon-separated list of directories in which
    the shell searches for executables by default. For example, when you enter the
    touch command to create a file, the shell searches the PATH to locate the binary.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: PATH环境变量是一个以冒号分隔的目录列表，shell默认在这些目录中搜索可执行文件。例如，当你输入touch命令创建一个文件时，shell会在PATH中搜索以定位二进制文件。
- en: 'Run the following command on any compromised machine to see its current PATH
    value:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何被攻陷的机器上运行以下命令查看其当前PATH值：
- en: '[PRE59]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To attempt privilege escalation, we could modify the PATH variable to include
    additional paths. For example, say a system has a dedicated custom script directory
    at */data/scripts*. Modifying the PATH directory to include this script directory
    is quite easy:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试提升权限，我们可以修改PATH变量以包含额外的路径。例如，假设系统有一个专门的自定义脚本目录*/data/scripts*。修改PATH目录以包含这个脚本目录非常简单：
- en: '[PRE60]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can append paths to PATH, as in the previous example, but also prepend them.
    In the following example, we prepend the current working directory (.) to the
    path:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像之前的示例一样将路径追加到PATH中，也可以将它们提前。以下示例中，我们将当前工作目录（.）添加到路径前面：
- en: '[PRE61]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now, if an executable runs as root and calls an external command as part of
    its logic, it might execute the attacker-controlled file instead of the intended
    executable.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果一个可执行文件以root身份运行并调用外部命令作为其逻辑的一部分，它可能会执行攻击者控制的文件，而不是预期的可执行文件。
- en: 'As an example, let’s use PATH hijacking to run a custom executable. We’ll target
    the following program written in C, which calls the whoami command. Let’s see
    if we can make it run a different binary of our choosing:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个示例，让我们使用PATH劫持来运行一个自定义可执行文件。我们将以以下用C语言编写的程序为目标，该程序调用了whoami命令。让我们看看是否能够让它运行我们选择的不同二进制文件：
- en: '[PRE62]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: At ❶, the code uses the command system("whoami") to call the whoami command,
    and at ❷, it calls the *whoami* binary directly by using its absolute path, */usr/bin/whoami*.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在❶处，代码使用命令system("whoami")调用whoami命令，在❷处，它通过使用其绝对路径*/usr/bin/whoami*直接调用*whoami*二进制文件。
- en: 'Copy this code into a new file named *getuser.c* on any of the compromised
    machines. You can also download the file directly from the book’s GitHub repository.
    Next, compile this program and make it executable by using the GNU Compiler Collection
    (GCC):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码复制到任何被攻陷的机器上，保存为名为*getuser.c*的新文件。你也可以直接从书籍的GitHub仓库下载此文件。接下来，使用GNU编译器集合（GCC）编译该程序并使其可执行：
- en: '[PRE63]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This should create a new binary named *getuser*. Let’s set the executable permissions
    on it:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会创建一个名为*getuser*的新二进制文件。让我们设置其可执行权限：
- en: '[PRE64]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, set the PATH such that the current directory is prepended to it:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，设置PATH，使当前目录被添加到它的前面：
- en: '[PRE65]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this output, you can see that the */tmp* directory was prepended to the PATH.
    This is because we were in the */tmp* directory when we executed this command;
    your value might look different if you navigated to a different directory. Make
    sure that the *getuser* binary is located in whatever directory you prepended
    to the PATH.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输出中，你可以看到*/tmp*目录被添加到PATH前面。这是因为我们在执行此命令时位于*/tmp*目录；如果你导航到其他目录，你的值可能会有所不同。确保*getuser*二进制文件位于你添加到PATH前面的目录中。
- en: Since we control one of the directories in the PATH, we can create a fake *whoami*
    script in that path ([Listing 9-2](chapter9.xhtml#Lis9-2)).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们控制了PATH中的一个目录，我们可以在该路径中创建一个伪造的*whoami*脚本（[清单9-2](chapter9.xhtml#Lis9-2)）。
- en: '[PRE66]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Listing 9-2: Forging a whoami executable'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 清单9-2：伪造whoami可执行文件
- en: 'The *getuser* program will look for the whoami command in the PATH, and since
    */tmp* will be read first, it should pick up the fake program. Run *getuser* to
    see the result:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*getuser*程序将在PATH中查找whoami命令，既然*/tmp*会最先被读取，它应该会选择伪造的程序。运行*getuser*查看结果：'
- en: '[PRE67]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see, the program executed the fake *whoami* script. Note, however,
    that the program’s second call to whoami executed the correct command because
    it specified the file’s full path.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，程序执行了伪造的*whoami*脚本。然而需要注意的是，程序第二次调用whoami时执行了正确的命令，因为它指定了文件的完整路径。
- en: 'Exercise 17: Maliciously Modifying a Cron Job'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 练习17：恶意修改Cron任务
- en: '[Chapter 8](chapter8.xhtml) covered scheduled tasks, including where they typically
    reside on a filesystem and how to execute them. Scheduled tasks generally run
    a custom script designed to perform a desired action, and this script might reference
    other local files for information. Also, the script might run with elevated privileges.
    So, they’re an interesting avenue to explore when looking for privilege escalation
    vulnerabilities.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](chapter8.xhtml)介绍了计划任务，包括它们通常在文件系统中的位置以及如何执行它们。计划任务通常运行一个自定义脚本，旨在执行特定操作，该脚本可能会引用其他本地文件来获取信息。此外，脚本可能会以提升的权限运行。因此，在寻找权限提升漏洞时，它们是一个有趣的探索方向。'
- en: 'On *p-jumpbox-01* (172.16.10.13), take a look at the contents of the */etc/
    crontab* file:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在*p-jumpbox-01*（172.16.10.13）上，查看*/etc/crontab*文件的内容：
- en: '[PRE68]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'As you can see, the command bash /scripts/backup_data.sh runs every five minutes,
    using the *root* user. Let’s check whether this script is accessible to us:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，命令bash /scripts/backup_data.sh每五分钟运行一次，并使用*root*用户。让我们检查一下这个脚本是否对我们可访问：
- en: '[PRE69]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It is, so let’s take a look at the script’s contents, shown in [Listing 9-3](chapter9.xhtml#Lis9-3).
    Does anything stand out to you?
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 的确如此，让我们来看看脚本的内容，如[清单9-3](chapter9.xhtml#Lis9-3)所示。你有什么发现吗？
- en: '[PRE70]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Listing 9-3: A data backup script'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 清单9-3：数据备份脚本
- en: The script first sets the CURRENT_DATE variable with today’s date ❶. Then a
    for loop iterates over the */tmp* and */data* directories ❷ and tests whether
    the file *extra_cmds.sh* exists in each directory ❸. If the script finds the file,
    the source command copies the *extra_cmds.sh* script ❹ into the currently executing
    script, which runs all its instructions in the same shell. Next, a tar command
    compresses the contents of */data/backup* into a single *tar.gz* file under */data*
    ❺. The script then removes any contents left in */data/backup*.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本首先通过当前日期设置`CURRENT_DATE`变量 ❶。然后，for循环遍历*/tmp*和*/data*目录 ❷，并测试每个目录中是否存在文件*extra_cmds.sh*
    ❸。如果脚本找到了该文件，source命令将*extra_cmds.sh*脚本 ❹ 复制到当前执行的脚本中，这样它会在同一shell中运行所有指令。接下来，tar命令将*/data/backup*目录中的内容压缩成一个单独的*tar.gz*文件，并存放在*/data*目录下
    ❺。脚本随后删除*/data/backup*中剩余的任何内容。
- en: This script contains a vulnerability; it doesn’t take into consideration that
    */tmp* is a world-accessible directory. If the *extra_cmds.sh* file doesn’t exist,
    someone could potentially create one, then introduce additional instructions for
    the cron job to execute. In addition, the */data* directory is also world-writable
    because of what seems to be a misconfiguration. Run the stat (or ls) command on
    */data* to see the permissions set.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本包含一个漏洞；它没有考虑到 */tmp* 是一个全世界可访问的目录。如果 *extra_cmds.sh* 文件不存在，某人可能会创建一个，然后为
    cron 作业引入额外的指令。此外，*/data* 目录也是可写的，这似乎是一个配置错误。运行 stat（或 ls）命令查看 */data* 上设置的权限。
- en: To test this vulnerability, write content to the *extra_cmd.sh* file. [Listing
    9-4](chapter9.xhtml#Lis9-4) provides a simple proof of concept.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试此漏洞，可以将内容写入 *extra_cmd.sh* 文件。[列表 9-4](chapter9.xhtml#Lis9-4) 提供了一个简单的概念验证示例。
- en: '[PRE71]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Listing 9-4: A proof-of-concept script to exploit the vulnerable cron job'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-4：利用易受攻击的 cron 作业的概念验证脚本
- en: 'An execution of this script by Cron will result in a new file named *proof-of-concept*
    under */tmp* with the content The running user is: followed by the output of the
    whoami command, which in this case should be root.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '通过 Cron 执行这个脚本会导致在 */tmp* 下生成一个名为 *proof-of-concept* 的新文件，文件内容为：The running
    user is: 后跟 whoami 命令的输出，在这个案例中应该是 root。'
- en: 'Save this file and use chmod to set the executable permissions on it, then
    wait five minutes to see the result:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此文件并使用 chmod 设置可执行权限，然后等待五分钟查看结果：
- en: '[PRE72]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Vulnerabilities in shell scripts aren’t rare, because they’re often written
    with the assumption that the operating environment does not have malicious users
    potentially looking for ways to exploit it. Tools called *linters*, such as ShellCheck
    (*[https://www.shellcheck.net](https://www.shellcheck.net)*), help enforce best
    practices when writing shell scripts. ShellCheck also highlights potential code
    areas that may cause security risks due to code errors.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: shell 脚本中的漏洞并不罕见，因为它们通常在假设操作环境没有恶意用户可能寻找利用漏洞的情况下编写。名为 *linters* 的工具，如 ShellCheck
    (*[https://www.shellcheck.net](https://www.shellcheck.net)*)，帮助在编写 shell 脚本时执行最佳实践。ShellCheck
    还会突出显示可能由于代码错误导致安全风险的潜在代码区域。
- en: 'To further exploit this flaw, consider writing a new *extra_cmd.sh* that takes
    any of the following actions:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步利用这个漏洞，考虑编写一个新的 *extra_cmd.sh*，执行以下任一操作：
- en: Modify a sudo configuration to grant a user of your choice permission.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 sudo 配置，以授予你选择的用户权限。
- en: Change the permissions to a directory of interest, such as a log directory,
    so that your low-privileged user has access to it.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改感兴趣目录的权限，例如日志目录，以便你的低权限用户可以访问它。
- en: Copy files from other users’ home directories to a directory readable to your
    user.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其他用户的主目录复制文件到你的用户可以读取的目录。
- en: Finding Kernel Exploits
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找内核漏洞
- en: When discovered, high-profile kernel-level vulnerabilities tend to get the security
    industry excited and panicked at the same time. While they’re often disclosed
    responsibly through security disclosure channels, we sometimes learn about them
    only when threat actors attempt to gain privileged access by using a zero day.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当高危内核级漏洞被发现时，通常会让安全行业既兴奋又恐慌。虽然它们通常通过安全披露渠道负责任地公开，但我们有时只能在威胁行为者试图通过使用零日漏洞获得特权访问时才得知这些漏洞。
- en: WARNING
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 警告
- en: '*These exploits could crash the kernel, so unless you have explicit permission
    from a client, you’ll want to avoid using them during penetration tests.*'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*这些漏洞可能会使内核崩溃，因此除非你获得了客户的明确许可，否则你应该避免在渗透测试中使用它们。*'
- en: 'Kernel exploits target specific kernel versions, CPU architectures (such as
    x86_64 or ARM), or operating systems, so to use one, you’ll first need to analyze
    the system to determine the kernel version that’s running. On your Kali machine,
    run the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 内核漏洞通常针对特定的内核版本、CPU 架构（如 x86_64 或 ARM）或操作系统，因此在使用其中之一之前，你需要先分析系统，以确定正在运行的内核版本。在你的
    Kali 机器上运行以下命令：
- en: '[PRE73]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You can find kernel exploits in databases such as *[https://exploit-db.com](https://exploit-db.com)*
    by searching for the specific kernel version of interest. While this can be a
    manual process, automated tools aim to make this search faster and more accurate
    by matching the kernel’s version to a list of CVEs.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过搜索感兴趣的特定内核版本，在像 *[https://exploit-db.com](https://exploit-db.com)* 这样的数据库中找到内核漏洞。虽然这可能是一个手动过程，但自动化工具旨在通过将内核版本与
    CVE 列表匹配，使搜索过程更快、更准确。
- en: SearchSploit
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SearchSploit
- en: '*SearchsSploit* is a command line utility built into Kali that interfaces with
    Exploit-DB, allowing you to perform searches from the terminal.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*SearchsSploit* 是 Kali 中内置的一个命令行工具，它与 Exploit-DB 接口连接，允许你从终端执行搜索。'
- en: 'The following command performs a search for Linux kernel exploits for the *Dirty
    COW vulnerability* (CVE-2016-5195), a race condition vulnerability that impacted
    kernel versions before 4.8.3:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令会搜索针对 *Dirty COW 漏洞*（CVE-2016-5195）的 Linux 内核漏洞，这是一个竞态条件漏洞，影响了 4.8.3 之前的内核版本：
- en: '[PRE74]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Other tools aim to automate the kernel exploit search by locally analyzing a
    system and matching the kernel version with a database of vulnerable kernels and
    exploits. One such tool is Linux Exploit Suggester 2.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 其他工具旨在通过本地分析系统并将内核版本与易受攻击的内核和漏洞数据库进行匹配，来自动化内核漏洞搜索。其中一个工具是 Linux Exploit Suggester
    2。
- en: Linux Exploit Suggester 2
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux Exploit Suggester 2
- en: '*Linux Exploit Suggester 2* is a Perl script that runs locally on a system.
    It attempts to find exploits that match the currently running kernel version.
    To give it a try, run the following command against your Kali machine:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*Linux Exploit Suggester 2* 是一个在系统上本地运行的 Perl 脚本。它尝试查找与当前运行的内核版本匹配的漏洞。为了尝试它，可以在你的
    Kali 机器上运行以下命令：'
- en: '[PRE75]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Under the hood, the exploit suggester script contains a database of more than
    70 kernel exploits as of this writing. Some examples include a vulnerability in
    OverlayFS (CVE-2015-8660) and a vulnerability in eBPF (CVE-2017-16695).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，漏洞建议脚本包含一个数据库，截至目前已有超过 70 个内核漏洞。一些例子包括 OverlayFS 漏洞（CVE-2015-8660）和 eBPF
    漏洞（CVE-2017-16695）。
- en: Attacking Adjacent Accounts
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 攻击相邻账户
- en: When you land on a compromised host as a nonroot user, you may want to try to
    escalate your privileges by attacking other system accounts. You may even be able
    to gain root access by compromising a nonroot account that happens to have certain
    privileges, such as unrestricted sudo privileges or a certain file in the home
    directory containing credentials.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当你作为非 root 用户登陆到一个被攻破的主机时，你可能会想通过攻击其他系统账户来提升权限。你甚至可能通过攻破一个非 root 账户来获取 root
    访问权限，前提是该账户拥有某些特权，比如无限制的 sudo 权限或家目录下的某个文件包含凭证。
- en: 'We can attempt to brute-force system accounts by using bash. First, let’s identify
    accounts that have an active shell by performing a grep search for */bin/bash*
    (though remember that there could be other shells as well). Execute the following
    command against *p-jumpbox-01* (172.16.10.13):'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试使用 bash 来暴力破解系统账户。首先，让我们通过执行 grep 搜索 */bin/bash* 来识别具有活动 shell 的账户（不过请记住，也可能有其他的
    shell）。在 *p-jumpbox-01*（172.16.10.13）上执行以下命令：
- en: '[PRE76]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: For the purpose of this example, we’ll attack the account *jmartinez*. [Listing
    9-5](chapter9.xhtml#Lis9-5) attempts to brute-force the password for that account.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，我们将攻击账户 *jmartinez*。[列表 9-5](chapter9.xhtml#Lis9-5) 尝试暴力破解该账户的密码。
- en: local_account _bf.sh
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: local_account _bf.sh
- en: '[PRE77]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Listing 9-5: Brute-forcing adjacent accounts'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-5：暴力破解相邻账户
- en: 'In this script, we set two variables: USER, with the account name to attack
    ❶, and PASSWORD_FILE, a file that will contain a passwords list ❷.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们设置了两个变量：USER，表示要攻击的账户名 ❶，以及 PASSWORD_FILE，一个包含密码列表的文件 ❷。
- en: Next, we read the content of PASSWORD_FILE by using a while loop ❸, iterating
    through each password that exists. We echo each password to the standard output
    stream and pipe it to the su command. Then we use su - ${USER} -c 'whoami' to
    attempt to switch to the user and execute the whoami command upon success.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用一个 while 循环 ❸ 来读取 PASSWORD_FILE 的内容，遍历每一个存在的密码。我们将每个密码输出到标准输出流，并将其通过管道传输给
    su 命令。然后，我们使用 su - ${USER} -c 'whoami' 来尝试切换到该用户并在成功后执行 whoami 命令。
- en: If the whoami command returns the username we’re brute-forcing in the output
    (*jmartinez* in this case), it means we were able to successfully guess the password
    and execute a command as the user. We check that it returned this string by using
    grep -q "${USER}".
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 whoami 命令在输出中返回我们正在暴力破解的用户名（在这个例子中是 *jmartinez*），那么就表示我们成功地猜测出了密码并以该用户身份执行了命令。我们可以使用
    grep -q "${USER}" 来验证是否返回了这个字符串。
- en: Let’s test it. Download and save the script on the *p-jumpbox-01* machine by
    using the methods you’ve learned so far.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行测试。通过你目前学到的方法，将脚本下载并保存到 *p-jumpbox-01* 机器上。
- en: 'Next, write a few passwords to the *passwords.txt* file. Make sure this file
    exists in the same directory as the *local_account_bf.sh* script:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向 *passwords.txt* 文件中写入一些密码。确保该文件与 *local_account_bf.sh* 脚本位于同一目录下：
- en: '[PRE78]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now run the script and observe its output:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行脚本并观察其输出：
- en: '[PRE79]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The password was found to be *password123*! Try switching to the user and providing
    the password:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 密码被发现是*password123*！尝试切换到用户并提供密码：
- en: '[PRE80]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Next, you should be able to see that this user has sudo access everywhere by
    running sudo -l:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你应该能够看到该用户在任何地方都有sudo权限，运行`sudo -l`来验证：
- en: '[PRE81]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This should give us access to the root account. To confirm we are able to switch
    to the root user, type the following:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该能让我们访问root账户。为了确认我们能够切换到root用户，请键入以下命令：
- en: '[PRE82]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Congratulations! You successfully compromised this machine.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你成功攻破了这台机器。
- en: Privilege Escalation with GTFOBins
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用GTFOBins进行特权提升
- en: We can use commonly available utilities on Linux-based machines for a variety
    of nefarious purposes. The GTFOBins project (*[https://gtfobins.github.io](https://gtfobins.github.io)*)
    highlights many of these utilities, and in particular, what an attacker can do
    with them if they have permissions such as SetUID or sudo set. As you can see
    in [Figure 9-3](chapter9.xhtml#fig9-3), some utilities allow arbitrary file reads
    and writes, file downloads and uploads, reverse shells, and more.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在基于Linux的机器上使用常见的工具执行各种恶意操作。GTFOBins项目（*[https://gtfobins.github.io](https://gtfobins.github.io)*)突出了许多这样的工具，特别是如果攻击者具有SetUID或sudo权限，他们可以利用这些工具做什么。如[图9-3](chapter9.xhtml#fig9-3)所示，一些工具允许任意文件读取和写入、文件下载和上传、反向Shell等。
- en: '![](../images/pg228.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg228.jpg)'
- en: 'Figure 9-3: The GTFOBins home page'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-3：GTFOBins首页
- en: When you inspect the filesystem for sudo access or SetUID permissions set on
    particular utilities or binaries, we highly recommend that you search the GTFOBins
    database to learn about possible attack opportunities.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查文件系统中的sudo访问权限或某些工具或二进制文件上的SetUID权限时，我们强烈建议你搜索GTFOBins数据库，以了解可能的攻击机会。
- en: 'Exercise 18: Mapping GTFOBins Exploits to Local Binaries'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 练习18：将GTFOBins漏洞映射到本地二进制文件
- en: 'Can you automate your search of the GTFOBins repository? In this exercise,
    you’ll use bash to map the list of available utilities on a target system to those
    in the GTFOBins database. The GTFOBins project is hosted on GitHub, where each
    binary has its own Markdown documentation file (with the *.md* extension), so
    you’ll need your script to do the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 你能自动化搜索GTFOBins仓库吗？在这个练习中，你将使用bash将目标系统上可用的工具列表映射到GTFOBins数据库中的工具。GTFOBins项目托管在GitHub上，每个二进制文件都有自己的Markdown文档文件（扩展名为*.md*），因此你需要让你的脚本执行以下操作：
- en: 1.  Perform a search for system and user binaries (in directories such as */bin*,
    */usr/bin*, and */usr/sbin*). For the purpose of this exercise, the search should
    look for SetUID files.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  搜索系统和用户二进制文件（在诸如*/bin*、*/usr/bin*和*/usr/sbin*等目录中）。为了这个练习，搜索应关注SetUID文件。
- en: 2.  Use filtering commands to extract only the filenames, without their paths.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  使用过滤命令提取仅包含文件名的结果，而不包含路径。
- en: 3.  Perform an HTTP GET request against the GTFOBins database to search for
    the correct documentation file, using the filename.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  对GTFOBins数据库执行HTTP GET请求，使用文件名搜索正确的文档文件。
- en: 4.  Print the results to the console or to a file.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  将结果打印到控制台或文件中。
- en: 'Your script should be able to output all exploitation methods for the binaries
    it found on the system with matches in the database. You can view an example GTFOBins
    page for the wget binary here: *[https://raw.githubusercontent.com/GTFOBins/GTFOBins.github.io/master/_gtfobins/wget.md](https://raw.githubusercontent.com/GTFOBins/GTFOBins.github.io/master/_gtfobins/wget.md)*.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 你的脚本应该能够输出它在系统上找到的所有二进制文件的利用方法，这些二进制文件在数据库中有匹配项。你可以在这里查看wget二进制文件的GTFOBins页面示例：
    *[https://raw.githubusercontent.com/GTFOBins/GTFOBins.github.io/master/_gtfobins/wget.md](https://raw.githubusercontent.com/GTFOBins/GTFOBins.github.io/master/_gtfobins/wget.md)*。
- en: If you get stuck, take a look at the example solution, *gtfobins_search.sh*,
    in the book’s GitHub repository.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到困难，可以查看书本GitHub仓库中的示例解决方案，*gtfobins_search.sh*。
- en: Automating Privilege Escalation
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化特权提升
- en: As you may have noticed, privilege escalation requires both time and craft.
    Luckily, there are scripts that aim to automate the tedious task of sifting through
    system directories to find misconfigurations or unhardened components.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，特权提升既需要时间也需要技巧。幸运的是，有一些脚本旨在自动化这一繁琐的任务，即通过系统目录筛选，寻找配置错误或未加固的组件。
- en: LinEnum
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LinEnum
- en: We ran LinEnum for information gathering in [Chapter 8](chapter8.xhtml). If
    you use the -t (thorough) flag to run a check, it should return details that could
    help you escalate your privileges, such as files that belong to the current user,
    hidden (dot) files, private keys, and Git credential files.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第8章](chapter8.xhtml)中使用过 LinEnum 来收集信息。如果使用 -t（彻底）标志运行检查，它应返回一些可能帮助你提升权限的详细信息，例如属于当前用户的文件、隐藏文件、私钥以及
    Git 凭据文件。
- en: 'But the script’s output can be verbose, because it prints every finding. The
    -k (keyword) option performs a system-wide search for a keyword of your choice:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 但该脚本的输出可能会很冗长，因为它会打印每一个发现。-k（关键字）选项会在系统范围内搜索你选择的关键字：
- en: '[PRE83]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This command searches for the string P@ssw0rd in files accessible to the current
    user.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会在当前用户可访问的文件中搜索字符串 P@ssw0rd。
- en: unix-privesc-check
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: unix-privesc-check
- en: 'Albeit a little older, *unix-privesc-check* is another self-contained shell
    script that can search a system for local misconfigurations. Copy the *unix-privesc
    -check* script from your Kali machine (the file should be under */home/kali/tools/unix-privesc-check*
    or */usr/bin/unix-privesc-check*) to any of the compromised hosts, then run a
    scan using the standard option:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管稍显陈旧，*unix-privesc-check* 仍然是一个独立的 Shell 脚本，可以在系统中搜索本地配置错误。从你的 Kali 机器（文件应位于
    */home/kali/tools/unix-privesc-check* 或 */usr/bin/unix-privesc-check*）复制 *unix-privesc-check*
    脚本到任何被攻破的主机上，然后使用标准选项运行扫描：
- en: '[PRE84]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The standard option is optimized for speed and will quickly enumerate misconfigurations
    on the system, but it provides less comprehensive enumeration coverage. The detailed
    option is more likely to catch misconfigurations in third-party software found
    on a host:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 标准选项经过优化，速度较快，会迅速枚举系统中的配置错误，但提供的枚举覆盖较少。详细选项则更有可能捕捉到主机上第三方软件中的配置错误：
- en: '[PRE85]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'You should see output similar to that of LinEnum:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似 LinEnum 输出的内容：
- en: '[PRE86]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: There are a few other privilege escalation automation tools you should be familiar
    with.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他你应该熟悉的权限提升自动化工具。
- en: MimiPenguin
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MimiPenguin
- en: MimiPenguin (*[https://github.com/huntergregal/mimipenguin](https://github.com/huntergregal/mimipenguin)*)
    is a scanner for finding the credentials of logged-in users who are connected
    to Linux systems running desktop environments such as the GNOME desktop environment
    and display managers such as LightDM or the GNOME Display Manager. If you come
    from a Windows penetration-testing background, you may be familiar with Mimikatz,
    a popular tool to extract credentials stored in memory. MimiPenguin was created
    to perform equivalent tasks in the Linux world.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: MimiPenguin (*[https://github.com/huntergregal/mimipenguin](https://github.com/huntergregal/mimipenguin)*)
    是一个扫描工具，用于查找已登录用户的凭证，这些用户连接到运行桌面环境（如 GNOME 桌面环境）和显示管理器（如 LightDM 或 GNOME Display
    Manager）的 Linux 系统。如果你有 Windows 渗透测试的背景，可能对 Mimikatz 熟悉，它是一个流行的工具，用于提取存储在内存中的凭证。MimiPenguin
    是为在 Linux 世界中执行等效任务而创建的。
- en: Linuxprivchecker
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linuxprivchecker
- en: The Python-based utility Linuxprivchecker (*[https://github.com/sleventyeleven/linuxprivchecker/tree/master](https://github.com/sleventyeleven/linuxprivchecker/tree/master)*),
    developed by Mike Czumak (T_v3rn1x), performs local cleartext password searches,
    finds shell escape opportunities in utilities such as text editors, provides kernel
    exploit recommendations based on the running kernel version, searches for file
    and directory permission misconfigurations, and more.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Mike Czumak (T_v3rn1x) 开发的基于 Python 的工具 Linuxprivchecker (*[https://github.com/sleventyeleven/linuxprivchecker/tree/master](https://github.com/sleventyeleven/linuxprivchecker/tree/master)*)，执行本地明文密码搜索，寻找文本编辑器等实用工具中的
    Shell 逃逸机会，基于正在运行的内核版本提供内核漏洞建议，搜索文件和目录权限配置错误等。
- en: Bashark
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bashark
- en: Bashark (*[https://github.com/redcode-labs/Bashark/tree/master](https://github.com/redcode-labs/Bashark/tree/master)*)
    is a shell script developed by wintrmvte. It provides a terminal user interface
    with helper functions for a variety of offensive security tasks, such as the enumeration
    of users, port scanning, reverse shell generation, and host enumeration. Its purpose
    is to facilitate executing common tasks without needing to write scripts and while
    primarily using tools that are commonly available on Linux systems.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Bashark (*[https://github.com/redcode-labs/Bashark/tree/master](https://github.com/redcode-labs/Bashark/tree/master)*)
    是一个由 wintrmvte 开发的 Shell 脚本。它提供一个终端用户界面，带有帮助函数，适用于各种攻击性安全任务，如用户枚举、端口扫描、反向 Shell
    生成和主机枚举。其目的是在无需编写脚本的情况下，主要使用 Linux 系统中常见的工具，简化常见任务的执行。
- en: Summary
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned the fundamentals of privilege escalation, explored
    the basic and advanced file permission features in Linux systems, then scoured
    the local system for misconfigurations in files and directories. You also sifted
    through system locations where credentials are often found and inspected the configurations
    of mechanisms that could lead to privilege escalation vulnerabilities, such as
    sudo, PATH, and cron jobs. Finally, you performed local brute-force attacks against
    other system accounts.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了权限提升的基本知识，探讨了 Linux 系统中基本和高级的文件权限特性，然后检查了本地系统中的文件和目录配置错误。你还浏览了系统中常见的存储凭证的位置，并检查了可能导致权限提升漏洞的机制配置，如
    sudo、PATH 和 cron 作业。最后，你对其他系统账户进行了本地暴力破解攻击。
