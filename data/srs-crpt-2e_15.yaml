- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">DIFFIE–HELLMAN</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">迪菲–赫尔曼</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In November 1976, Stanford researchers Whitfield Diffie and Martin Hellman published
    a research paper titled “New Directions in Cryptography” that revolutionized cryptography
    forever. Their paper introduced the notion of public-key encryption and signatures,
    though they didn’t actually have any of those schemes; they simply had what they
    termed a *public-key cryptosystem*, a protocol that allows two parties to establish
    a shared secret by exchanging information visible to an eavesdropper. This is
    now known as the *Diffie–Hellman (DH) protocol*. Prior to Diffie–Hellman, establishing
    a shared secret required tedious procedures such as manually exchanging sealed
    envelopes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 1976年11月，斯坦福大学的研究人员**惠特菲尔德·迪菲**和**马丁·赫尔曼**发表了一篇名为《密码学的新方向》的研究论文，彻底改变了密码学的面貌。他们的论文提出了公钥加密和签名的概念，尽管他们实际上并没有这些方案；他们仅提出了一个他们称之为*公钥密码系统*的协议，这种协议允许双方通过交换对窃听者可见的信息来建立共享的秘密。这就是现在所称的*迪菲–赫尔曼（DH）协议*。在迪菲–赫尔曼之前，建立共享秘密需要繁琐的程序，例如手动交换密封的信封。
- en: Once communicating parties establish a shared secret value with the DH protocol,
    they can use that secret to establish a *secure channel* by turning the secret
    into one or more symmetric keys that they then use to encrypt and authenticate
    subsequent communication. The DH protocol and its variants are therefore called
    *key agreement* protocols.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通信双方通过DH协议建立了共享的秘密值，他们就可以利用该秘密值建立一个*安全通道*，通过将秘密转化为一个或多个对称密钥，然后用这些密钥加密和验证随后的通信。因此，DH协议及其变种被称为*密钥协商*协议。
- en: In the first part of this chapter, you’ll read about the mathematical foundations
    of the Diffie–Hellman protocol, including the computational problems that DH relies
    on to perform its magic. Then you’ll learn about different versions of the Diffie–Hellman
    protocol you can use to create secure channels. Finally, because Diffie–Hellman
    schemes are secure only when their parameters are well chosen, you’ll see scenarios
    where Diffie–Hellman can fail.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，你将了解迪菲–赫尔曼协议的数学基础，包括DH依赖的计算问题，这些问题使得它的魔力得以实现。接下来，你将学习可以用来创建安全通道的不同版本的迪菲–赫尔曼协议。最后，由于迪菲–赫尔曼方案只有在其参数选择得当时才是安全的，你将看到一些迪菲–赫尔曼可能失败的场景。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Diffie and Hellman received the prestigious Turing Award in 2015 for their
    invention of public-key cryptography and digital signatures, but others deserve
    credit as well. In 1974, while a computer science undergraduate, Ralph Merkle
    introduced the idea of public-key cryptography with* Merkle’s puzzles*. Around
    that same time, researchers at the British Government Communications Headquarters
    (GCHQ), the British equivalent of the NSA, discovered the principles behind Rivest–Shamir–Adleman
    (RSA) and Diffie–Hellman key agreement, though that fact was declassified only
    decades later.*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**迪菲**和**赫尔曼**因发明了公钥密码学和数字签名，于2015年荣获了声望极高的图灵奖，但其他人也应当获得认可。1974年，当时还是计算机科学本科生的**拉尔夫·梅尔克**提出了公钥密码学的概念，并引入了**梅尔克谜题**。大约在同一时期，英国政府通信总部（GCHQ），即英国版的美国国家安全局（NSA）的研究人员发现了**里维斯特–沙米尔–阿德尔曼（RSA）**和**迪菲–赫尔曼**密钥协商的原理，尽管这一事实直到几十年后才被解密。'
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Diffie–Hellman Function</samp>
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">迪菲–赫尔曼函数</samp>
- en: To understand DH key agreement protocols, you must understand their core operation,
    the *DH function*. Diffie and Hellman originally defined the DH function to work
    with groups denoted **Z**p^*, which consist of nonzero integer numbers modulo
    a prime number, which is usually denoted *p* (see [Chapter 9](chapter9.xhtml)).
    Another public parameter is the base number, or *generator*, *g*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解DH密钥协商协议，你必须理解其核心操作，即*DH函数*。迪菲和赫尔曼最初定义了DH函数，要求其与**Z**p^*群一起工作，该群由模素数p的非零整数构成（通常用*p*表示，见[第9章](chapter9.xhtml)）。另一个公共参数是基数或*生成元*，即*g*。
- en: The DH function involves two private values chosen randomly by the two communicating
    parties from the group **Z**p^*, which we’ll write *a* and *b*. A private value
    *a* is associated with the public value *A* = *g**^a* mod *p*, or *g* raised to
    the power *a* modulo *p*. This *A* is sent to the other party through a message
    visible to eavesdroppers. The public value associated with *b* is *B* = *g**^b*
    mod *p*, which is sent to the owner of *a*. An attacker can thus learn *A* and
    *B*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: DH 函数涉及两个私有值，由两方从群体 **Z**p^* 中随机选择，我们将其写作 *a* 和 *b*。私有值 *a* 与公有值 *A* = *g**^a*
    mod *p* 相关，或者说 *g* 的 *a* 次方对 *p* 取模。这个 *A* 会通过一个对窃听者可见的消息发送给另一方。与 *b* 相关的公有值是
    *B* = *g**^b* mod *p*，它会发送给 *a* 的拥有者。因此，攻击者可以得知 *A* 和 *B*。
- en: 'DH works by combining either public value with the other private value, such
    that the result is the same in both cases: *A**^b* = (*g**^a*)*^b* = *g**^(ab)*
    and *B* *^a* = (*g**^b*)*^a* = *g**^(ba)* = *g**^(ab)*. The resulting value, *g**^(ab)*,
    is the *shared secret*; you then pass it to a *key derivation function (KDF)*
    to generate one or more shared symmetric keys. A KDF is a kind of hash function
    that returns a random-looking string the size of the desired key length.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: DH 的工作原理是将一个公有值与另一个私有值结合，使得两者的结果相同：*A**^b* = (*g**^a*)*^b* = *g**^(ab)* 和 *B*
    *^a* = (*g**^b*)*^a* = *g**^(ba)* = *g**^(ab)*。得到的值 *g**^(ab)* 是 *共享密钥*；然后，你将其传递给
    *密钥派生函数 (KDF)* 以生成一个或多个共享的对称密钥。KDF 是一种哈希函数，它返回一个看起来随机的字符串，其长度等于所需的密钥长度。
- en: And that’s it. Like many great scientific discoveries (gravity, relativity,
    quantum computing, or RSA), the Diffie–Hellman trick is relatively simple in hindsight.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。像许多伟大的科学发现（重力、相对论、量子计算或 RSA）一样，Diffie–Hellman 方法事后看相对简单。
- en: Diffie–Hellman’s simplicity can be deceiving, however. For one, it won’t work
    with just any prime *p* or base number *g*. Some values of *g* restrict the shared
    secrets *g**^(ab)* to a small subset of possible values, whereas you’d expect
    to have about as many possible values as elements in **Z**p^* and therefore as
    many possible values for the shared secret. To ensure the highest security, safe
    DH parameters should work with a prime *p* such that (*p* – 1)/2 is also prime.
    Such a *safe prime* guarantees that the group doesn’t have small subgroups that
    would make DH easier to break. With a safe prime, DH can work with any element
    in **Z**p^*, excepting 1 and *p* – 1; notably, *g* = 2 makes computations slightly
    faster. But generating a safe prime *p* takes more time than generating a totally
    random one.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Diffie–Hellman 的简单性可能会令人误解。首先，它并不是任何素数 *p* 或基数 *g* 都能奏效。一些 *g* 的值会将共享密钥 *g**^(ab)*
    限制在一个较小的子集范围内，而你可能期望共享密钥的值范围与 **Z**p^* 中的元素数量相当，因此应该有尽可能多的共享密钥值。为了确保最高的安全性，安全的
    DH 参数应与一个素数 *p* 一起工作，使得 (*p* – 1)/2 也是素数。这样的 *安全素数* 可以确保群体中没有小的子群，这些子群可能使 DH 更容易被破解。使用安全素数时，DH
    可以与 **Z**p^* 中的任何元素一起工作，除了 1 和 *p* – 1；特别地，*g* = 2 会使计算稍微加快。不过，生成一个安全素数 *p* 比生成一个完全随机的素数需要更多时间。
- en: For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">dhparam</samp>
    command of the OpenSSL toolkit generates only safe DH parameters, but the extra
    checks built into the algorithm result increase the execution time considerably,
    as [Listing 11-1](chapter11.xhtml#Lis11-1) shows.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，OpenSSL 工具包中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">dhparam</samp>
    命令仅生成安全的 DH 参数，但算法内置的额外检查会显著增加执行时间，如[示例 11-1](chapter11.xhtml#Lis11-1)所示。
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-1: Measuring the
    execution time of generating 2,048-bit Diffie–Hellman parameters with the OpenSSL
    toolkit</samp>'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 11-1：测量生成 2,048 位 Diffie–Hellman
    参数的执行时间（使用 OpenSSL 工具包）</samp>
- en: It took around eight seconds to generate the DH parameters using the OpenSSL
    toolkit (it’s common to observe generation times in the order of 30 seconds or
    even more than 1 minute).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenSSL 工具包生成 DH 参数大约需要 8 秒（常见的生成时间为 30 秒，甚至超过 1 分钟）。
- en: For the sake of comparison, [Listing 11-2](chapter11.xhtml#Lis11-2) shows how
    long it takes on the same system to generate RSA parameters of the same size (that
    is, two prime numbers, *p* and *q*, each half the size of the *p* used for DH).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行比较，[示例 11-2](chapter11.xhtml#Lis11-2) 显示了在相同系统上生成相同大小的 RSA 参数（即两个素数，*p*
    和 *q*，每个素数的大小是 DH 所用 *p* 的一半）所需的时间。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-2: Generating 2,048-bit
    RSA parameters while measuring the execution time</samp>'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 11-2：生成 2,048 位 RSA 参数并测量执行时间</samp>
- en: 'Generating DH parameters took about 50 times longer than generating RSA parameters
    of the same security level, mainly due to the extra constraint imposed on the
    prime generated to create DH parameters.  ### <samp class="SANS_Futura_Std_Bold_B_11">The
    Diffie–Hellman Problems</samp>'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 生成 DH 参数的时间大约是生成相同安全级别的 RSA 参数的 50 倍，主要是由于在生成 DH 参数时对素数施加了额外的约束。### <samp class="SANS_Futura_Std_Bold_B_11">Diffie–Hellman
    问题</samp>
- en: The security of DH protocols relies on the hardness of computational problems,
    especially on that of the discrete logarithm problem (DLP) from [Chapter 9](chapter9.xhtml).
    You can break DH by recovering the private value *a* from its public value *g**^a*,
    which boils down to solving a DLP instance. But we don’t care about just the discrete
    logarithm problem when using DH to compute shared secrets. We also care about
    two DH-specific problems.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: DH 协议的安全性依赖于计算问题的难度，尤其是离散对数问题（DLP）的难度，详见[第 9 章](chapter9.xhtml)。你可以通过从公有值 *g**^a*
    中恢复私有值 *a* 来破解 DH，这实际上是解决一个 DLP 实例。但当我们使用 DH 来计算共享秘密时，我们不仅关心离散对数问题。我们还关心两个 DH
    特有的问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Computational
    Problem</samp>
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">计算问题</samp>
- en: The *computational Diffie–Hellman (CDH)* problem is that of computing the shared
    secret *g* *^(ab)* given only the public values *g* *^a* and *g* *^b*, without
    knowing the secret values *a* and *b*. The motivation is to ensure that even if
    an eavesdropper captures *g* *^a* and *g* *^b*, they shouldn’t be able to determine
    the shared secret *g* *^(ab)*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算 Diffie–Hellman (CDH)* 问题是给定公有值 *g* *^a* 和 *g* *^b*，在不知道私有值 *a* 和 *b* 的情况下，计算共享秘密
    *g* *^(ab)*。其动机是确保即使窃听者捕获了 *g* *^a* 和 *g* *^b*，他们也无法确定共享秘密 *g* *^(ab)*。'
- en: If you can solve DLP, then you can also solve CDH; that is, if you determine
    *a* and *b* given *g* *^a* and *g* *^b*, then you’ll be able to compute *g* *^(ab)*.
    In other words, DLP is *at least* as hard as CDH. But you don’t know for sure
    whether CDH is at least as hard as DLP, which would make the problems equally
    hard. In other words, DLP is to CDH what the factoring problem is to the RSA problem.
    (Recall that factoring allows you to solve the RSA problem but not necessarily
    the converse.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够解决 DLP，那么你也可以解决 CDH；也就是说，如果给定 *g* *^a* 和 *g* *^b* 能确定 *a* 和 *b*，那么你就能计算出
    *g* *^(ab)*。换句话说，DLP 至少和 CDH 一样难。但你不能确定 CDH 是否至少和 DLP 一样难，这会使得这两个问题同样困难。换句话说，DLP
    对 CDH 就像因式分解问题对 RSA 问题一样。（回想一下，因式分解可以解决 RSA 问题，但不一定能反过来解决。）
- en: Diffie–Hellman shares another similarity with RSA in that DH delivers a similar
    security level as RSA for a given modulus size. For example, the DH protocol with
    a 2,048-bit prime *p* offers roughly 90-bit security, as RSA with a 2,048-bit
    modulus. Indeed, the fastest way to break CDH is to solve DLP using the *number
    field sieve* algorithm, a method similar but not identical to the general number
    field sieve (GNFS), which breaks RSA by factoring its modulus.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Diffie–Hellman 与 RSA 还有另一个相似之处，即 DH 在给定模数大小时提供与 RSA 相似的安全级别。例如，具有 2,048 位素数
    *p* 的 DH 协议提供大约与 2,048 位模数的 RSA 相当的 90 位安全性。实际上，破解 CDH 的最快方法是使用 *数域筛法* 算法来解决离散对数问题（DLP），这种方法与通用数域筛法（GNFS）相似，但不完全相同，GNFS
    是通过对 RSA 的模数进行因式分解来破解 RSA 的方法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Decisional Problem</samp>
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">可判定问题</samp>
- en: When you need a seemingly stronger assumption than CDH’s hardness, enter the
    *decisional Diffie–Hellman (DDH)* problem. Given *g* *^a*, *g* *^b*, and a value
    that’s either *g* *^(ab)* or *g* *^c* for some random *c* (each of the two with
    a chance of 1/2), the DDH problem consists of determining whether *g* *^(ab)*
    (the shared secret corresponding to *g* *^a* and *g* *^b*) was chosen.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要比 CDH 的难度更强的假设时，就需要引入 *可判定 Diffie–Hellman (DDH)* 问题。给定 *g* *^a*、*g* *^b*，以及一个值，它要么是
    *g* *^(ab)*，要么是 *g* *^c*（其中 *c* 是某个随机数，每个值的概率为 1/2），DDH 问题的目标是判断 *g* *^(ab)*（对应于
    *g* *^a* 和 *g* *^b* 的共享秘密）是否被选择。
- en: 'Relying on DDH rather than CDH is relevant in the following case: imagine that
    an attacker can compute only the first 32 bits of *g* *^(ab)* given the 2,048-bit
    values of *g* *^a* and *g* *^b*. Although CDH remains unbroken because 32 bits
    may not be enough to completely recover *g* *^(ab)*, the attacker would’ve learned
    something about the shared secret, which might allow them to compromise an application’s
    security.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，依赖 DDH 而非 CDH 是有意义的：假设攻击者仅能计算给定 *g* *^a* 和 *g* *^b* 的 2,048 位值中的前 32
    位 *g* *^(ab)*。虽然 CDH 仍然没有被攻破，因为 32 位可能不足以完全恢复 *g* *^(ab)*，但攻击者已经从中学到了一些关于共享密钥的信息，这可能允许他们破坏应用程序的安全性。
- en: To ensure that an attacker can’t learn anything about the shared secret *g*
    *^(ab)*, this value needs to be *indistinguishable* from a random group element,
    just as an encryption scheme is secure when ciphertexts are indistinguishable
    from random strings. That is, an attacker shouldn’t be able to determine whether
    a given number is *g* *^(ab)* or *g**^c* for some random *c*, given *g**^a*, *g**^b*.
    The *decisional Diffie–Hellman assumption* assumes that no attacker can solve
    DDH efficiently.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保攻击者无法得知共享密钥 *g* *^(ab)* 的任何信息，该值需要与一个随机群元素 *不可区分*，就像加密方案在密文与随机字符串不可区分时是安全的。这就是说，攻击者不应该能够确定给定的数字是
    *g* *^(ab)* 还是 *g**^c*（其中 *c* 是某个随机值），给定 *g**^a* 和 *g**^b*。*判定性 Diffie–Hellman
    假设* 假设没有攻击者可以有效地解决 DDH 问题。
- en: 'If DDH is hard, then so is CDH, and you can’t learn anything about *g* *^(ab)*.
    So if you can solve CDH, you can also solve DDH: given a triplet (*g* *^a*, *g*
    *^b*, *x*), you’d be able to derive *g* *^(ab)* from *g**^a* and *g* *^b* and
    check whether the result is equal to the given *x*.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 DDH 很困难，那么 CDH 也是如此，你无法得知 *g* *^(ab)* 的任何信息。所以，如果你能解决 CDH，那么你也能解决 DDH：给定一个三元组
    (*g* *^a*, *g* *^b*, *x*)，你将能够从 *g**^a* 和 *g* *^b* 中推导出 *g* *^(ab)* 并检查结果是否等于给定的
    *x*。
- en: The bottom line is that DDH is fundamentally less hard than CDH (notably, DDH
    is not hard over **Z**p^*, contrarily to CDH), yet DDH hardness is a prime assumption
    in cryptography and one of the most studied.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，DDH 从根本上比 CDH 更简单（值得注意的是，DDH 在 **Z**p^* 上并不困难，与 CDH 相反），然而，DDH 难度是密码学中的一个重要假设，并且是最研究的假设之一。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Variants of Diffie–Hellman</samp>
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Diffie–Hellman 的变体</samp>
- en: Sometimes cryptographers devise new schemes and prove that they’re at least
    as hard to break as it is to solve some hard problem. But such hard problems are
    not always CDH or DDH but instead can be variants of them. We’d like to be able
    to demonstrate that breaking a cryptosystem is as hard as solving CDH or DDH,
    but this isn’t always possible with advanced cryptographic mechanisms, typically
    because such schemes involve more complex operations than basic Diffie–Hellman
    protocols.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，密码学家设计新的方案，并证明它们至少像解决某些困难问题一样困难。但这些困难问题并不总是 CDH 或 DDH，可能是它们的变体。我们希望能够证明，破解一个密码系统的难度和解决
    CDH 或 DDH 的难度一样大，但对于一些先进的密码学机制，这并不总是可能的，通常是因为这些方案涉及比基本的 Diffie–Hellman 协议更复杂的操作。
- en: For example, in one DH-like problem, given *g**^a*, an attacker attempts to
    compute *g*^(1/)*^a*, where 1/*a* is the inverse of *a* in the group (typically
    **Z**p^* for some prime *p*). In another, an attacker might distinguish the pairs
    (*g**^a*, *g**^b*) from the pairs (*g**^a*, *g*^(1/)*^a*) for random *a* and *b*.
    Finally, in the *twin Diffie–Hellman problem*, given *g**^a*, *g**^b*, and *g**^c*,
    an attacker attempts to compute the two values *g**^(ab)* and *g**^(ac)*. Sometimes
    such DH variants turn out to be as hard as CDH or DDH, and sometimes they’re fundamentally
    easier—and therefore provide lower security guarantees. As an exercise, try to
    find connections between the hardness of these problems and that of CDH and DDH.
    (Twin Diffie–Hellman is actually *as hard* as CDH, but that isn’t easy to prove!)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个类似 DH 的问题中，给定 *g**^a*，攻击者试图计算 *g*^(1/)*^a*，其中 1/*a* 是群中 *a* 的逆元（通常是 **Z**p^*，其中
    *p* 是某个质数）。在另一个问题中，攻击者可能通过随机的 *a* 和 *b* 区分对 (*g**^a*, *g**^b*) 和对 (*g**^a*, *g*^(1/)*^a*)。最后，在
    *双重 Diffie–Hellman 问题* 中，给定 *g**^a*、*g**^b* 和 *g**^c*，攻击者试图计算两个值 *g**^(ab)* 和
    *g**^(ac)*。有时这些 DH 变体的难度与 CDH 或 DDH 一样困难，有时它们则更容易——因此提供的安全保证较低。作为练习，试着找出这些问题的难度与
    CDH 和 DDH 难度之间的联系。（双重 Diffie–Hellman 实际上与 CDH *同样困难*，但这并不容易证明！）
- en: <samp class="SANS_Futura_Std_Bold_B_11">Key Agreement Protocols</samp>
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">密钥协议</samp>
- en: The Diffie–Hellman problem is designed to build secure key agreement protocols,
    which secure communication between two or more parties communicating over a network
    with the aid of a shared secret. The parties turn this secret into one or more
    *session keys*—symmetric keys that encrypt and authenticate the information exchanged
    for the duration of the session.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Diffie–Hellman 问题旨在构建安全的密钥协商协议，确保两个或多个在网络上通信的各方通过共享秘密来加密通信。这些各方将这个秘密转化为一个或多个
    *会话密钥*—对称密钥，在会话期间加密和认证交换的信息。
- en: Before studying actual DH protocols, you should know what makes a key agreement
    protocol secure and how simpler protocols work. We’ll begin our discussion with
    a prevalent key agreement protocol that doesn’t rely on DH.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究实际的 DH 协议之前，你应该了解一个密钥协商协议安全的因素，以及更简单的协议是如何工作的。我们将从一个常见的密钥协商协议开始，这个协议不依赖于
    DH。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Non-DH Key Agreement</samp>
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">非 DH 密钥协商</samp>
- en: 'To provide a sense of how a key agreement protocol works and what it means
    for it to be secure, let’s look at the protocol the 4G and 5G telecommunications
    standards use to establish communication between a SIM card and a telecom operator:
    *authenticated key agreement (AKA)*. It doesn’t use the Diffie–Hellman function
    but instead uses only symmetric-key operations. [Figure 11-1](chapter11.xhtml#fig11-1)
    details how the protocol works.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让大家了解一个密钥协商协议是如何工作的，以及它如何确保安全，我们来看看 4G 和 5G 电信标准中用于在 SIM 卡和电信运营商之间建立通信的协议：*认证密钥协商
    (AKA)*。它不使用 Diffie–Hellman 函数，而是仅使用对称密钥操作。[图 11-1](chapter11.xhtml#fig11-1) 详细描述了该协议是如何工作的。
- en: '![](../images/fig11-1.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig11-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-1: The AKA protocol
    in 4G and 5G telecommunication</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-1：4G 和 5G 电信中的 AKA 协议</samp>
- en: In this description of the protocol, the SIM card has a secret key, *K*, that
    the operator knows. The operator begins the session by selecting a random value,
    *R*, and then computes two values, *SK* and *V*[1], based on two pseudorandom
    functions, **PRF**0 and **PRF**1\. Next, the operator sends a message to the SIM
    card containing the values *R* and *V*[1], which are visible to attackers. Once
    the SIM card has *R*, it has what it needs to compute *SK* with **PRF**0, and
    it does. The two parties in this session end up with a shared key, *SK*, that
    attackers are unable to determine by simply looking at the messages exchanged
    between the parties, or even by modifying them or injecting new ones. The SIM
    card verifies that it’s talking to the operator by recomputing *V*[1] with **PRF**1,
    *K*, and *R*, and then checking to make sure that the calculated *V*[1] matches
    the *V*[1] sent by the operator. The SIM card then computes a verification value,
    *V*[2], with a new function, **PRF**2, with *K* and *R* as input, and sends *V*[2]
    to the operator. The operator verifies that the SIM card knows *K* by computing
    *V*[2] and checking that the computed value matches the received *V*[2].
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在此协议描述中，SIM 卡有一个秘密密钥 *K*，该密钥由运营商知晓。运营商通过选择一个随机值 *R* 开始会话，然后基于两个伪随机函数 **PRF**0
    和 **PRF**1 计算出两个值 *SK* 和 *V*[1]。接下来，运营商向 SIM 卡发送包含 *R* 和 *V*[1] 的消息，这些值对攻击者是可见的。一旦
    SIM 卡获取到 *R*，它便可以使用 **PRF**0 来计算 *SK*，并且确实计算出了这个值。会话中的两方最终得到一个共享密钥 *SK*，攻击者无法仅通过查看双方交换的消息，甚至通过修改它们或注入新的消息来确定该密钥。SIM
    卡通过重新计算 *V*[1]，使用 **PRF**1、*K* 和 *R*，并检查计算出的 *V*[1] 是否与运营商发送的 *V*[1] 匹配，从而验证它正在与运营商通信。然后，SIM
    卡使用新的函数 **PRF**2 和 *K*、*R* 作为输入计算一个验证值 *V*[2]，并将 *V*[2] 发送给运营商。运营商通过计算 *V*[2]
    并检查计算出的值是否与接收到的 *V*[2] 匹配来验证 SIM 卡是否知道 *K*。
- en: In the protocol as I described it, there’s a way to fool the SIM card with a
    replay attack. Essentially, if an attacker captures a pair (*R*, *V*[1]), they
    may send it to the SIM card and trick the SIM into believing that the pair came
    from a legitimate operator that knows *K*. To prevent this attack, the protocol
    includes additional checks to ensure the same *R* isn’t reused.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我描述的协议中，有一种方法可以通过重放攻击欺骗 SIM 卡。本质上，如果攻击者捕获了一对 (*R*, *V*[1])，他们可以将其发送到 SIM 卡，并欺骗
    SIM 卡相信该对数据来自一个合法的运营商，该运营商知道 *K*。为了防止这种攻击，协议包含了额外的检查，以确保同一 *R* 不会被重用。
- en: Problems arise if *K* is compromised. For example, an attacker who compromises
    *K* can perform a man-in-the-middle attack and listen to all cleartext communication.
    Such an attacker could send messages between the two parties while pretending
    to be both the legitimate SIM card operator and the SIM card. Even if *K* isn’t
    compromised at the time of a given communication, an attacker can record communications
    and any messages exchanged during the key agreement and later decrypt those communications
    by using the captured *R* values if they find *K*. An attacker could then determine
    the past session keys and use them to decrypt the recorded traffic—in that case,
    the protocol doesn’t offer *forward secrecy*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*K*被泄露，就会出现问题。例如，一个泄露了*K*的攻击者可以进行中间人攻击，监听所有明文通信。这样的攻击者可能在两个方之间发送消息，同时冒充合法的SIM卡运营商和SIM卡。即使*K*在某次通信时并没有被泄露，攻击者也可以记录通信和密钥协议期间交换的任何消息，并在找到*K*时使用捕获的*R*值解密这些通信。攻击者可以通过此方式确定过去的会话密钥，并用它们解密已录制的流量——在这种情况下，协议没有提供*前向保密性*。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Attack Models for
    Key Agreement Protocols</samp>
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">密钥协议的攻击模型</samp>
- en: There is no single definition of security for key agreement protocols, and a
    key protocol is never completely secure without context and without considering
    the attack model and the security goals. You can, for example, argue that the
    previous 4G/5G protocol is secure because a passive attacker won’t find the session
    keys, but it’s also insecure because once the key *K* leaks, this compromises
    all previous and future communications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥协议没有单一的安全定义，且没有考虑攻击模型和安全目标的上下文情况下，任何密钥协议都不可能完全安全。例如，你可以认为之前的4G/5G协议是安全的，因为被动攻击者无法找到会话密钥，但它也不安全，因为一旦密钥*K*泄露，这会危及所有之前和之后的通信。
- en: 'There are different notions of security in key agreement protocols as well
    as three main attack models that depend on the information the protocol leaks.
    From weakest to strongest, these are the *network attacker*, the *data leak*,
    and the *breach*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥协议中有不同的安全概念，以及三个主要的攻击模型，这些模型取决于协议泄露的信息。从最弱到最强，这些模型是*网络攻击者*、*数据泄漏*和*突破*：
- en: '**The network attacker **This attacker observes the messages exchanged between
    the two legitimate parties running a key agreement protocol and can record, modify,
    drop, or inject messages. To protect against such an attacker, a key agreement
    protocol must not leak any information on the established shared secret.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络攻击者** 该攻击者观察两个合法方之间交换的消息，并且可以记录、修改、丢弃或注入消息。为了防范此类攻击者，密钥协议必须确保不会泄漏任何关于已建立共享秘密的信息。'
- en: '**The data leak **In this model, the attacker acquires the session key and
    all *temporary* secrets (such as *SK* in the telecom protocol example) from one
    or more executions of the protocol, but not the long-term secrets (like *K* in
    that same protocol).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据泄漏** 在这个模型中，攻击者通过一次或多次协议执行获得会话密钥和所有*临时*秘密（例如电信协议示例中的*SK*），但不会获得长期秘密（如该协议中的*K*）。'
- en: '**The breach (or corruption) **In this model, the attacker learns the long-term
    key of one or more of the parties. Once a breach occurs, security is no longer
    attainable because the attacker can impersonate one or both parties in subsequent
    sessions of the protocol, as it’s the only piece of information that identifies
    a party (at least in theory, since in practice mechanisms such as IP whitelisting
    can reduce the risk of impersonation). Nonetheless, the attacker shouldn’t be
    able to recover secrets from sessions executed before gathering the key.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**突破（或篡改）** 在这个模型中，攻击者获知一个或多个方的长期密钥。一旦发生突破，安全性就无法再保证，因为攻击者可以在后续的协议会话中冒充其中一个或两个方，因为这是唯一可以标识一个方的信息（至少在理论上如此，因为在实践中像IP白名单这样的机制可以降低冒充的风险）。尽管如此，攻击者不应该能够从发生在获取密钥之前的会话中恢复秘密。'
- en: 'Now that we’ve looked at the attack models and seen what an attacker can do,
    let’s explore the security goals—that is, the security guarantees that the protocol
    should offer. You can design a key agreement protocol to satisfy several security
    goals. The four most relevant ones are described here, from simplest to most sophisticated:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了攻击模型并看到了攻击者可能采取的行动，让我们来探讨一下安全目标——即协议应该提供的安全保障。你可以设计一个密钥协议来满足多个安全目标。这里描述了四个最相关的目标，按从简单到复杂的顺序排列：
- en: '**Authentication **The protocol should allow for *mutual authentication*, wherein
    each party can authenticate the other party. AKA occurs when a protocol authenticates
    both parties.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证** 协议应该允许*互相认证*，即每一方都能认证另一方。AKA是指协议认证双方。'
- en: '**Key control **Neither party should be able to choose the final shared secret
    or coerce it to be in a specific subset. The previously discussed 4G/5G key agreement
    protocol lacks this property because the operator chooses the value for *R* that
    entirely determines the final shared key.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥控制** 任何一方都不应能够选择最终的共享密钥或强迫其属于特定子集。前面讨论过的4G/5G密钥协商协议缺乏这一特性，因为运营商选择了完全决定最终共享密钥的*R*值。'
- en: '**Forward secrecy  **Even if all long-term secrets are exposed, an attacker
    should be unable to compute shared secrets from previous executions of the protocol,
    even if they record all previous executions or can inject or modify messages from
    previous executions. A *forward-secret*, or *forward-secure*, protocol guarantees
    that even if you have to deliver your devices and their secrets to some authority,
    they won’t be able to decrypt your prior encrypted communications. (The 4G/5G
    key agreement protocol doesn’t provide forward secrecy.)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**前向保密性** 即使所有长期密钥都被泄露，攻击者也应该无法从协议的先前执行中计算出共享密钥，即使他们记录了所有先前的执行或能够注入或修改先前执行中的消息。*前向保密*，或称为*前向安全*协议，保证即使你必须将设备及其密钥交给某个机构，他们也无法解密你之前加密的通讯。（4G/5G密钥协商协议不提供前向保密性。）'
- en: '**Resistance to key-compromise impersonation (KCI) **KCI occurs when an attacker
    compromises a party’s long-term key and can use it to impersonate another party.
    For example, the 4G/5G key agreement protocol allows trivial key-compromise impersonation
    because both parties share the same key *K*. A key agreement protocol ideally
    prevents this kind of attack.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**抵抗密钥泄露冒充（KCI）** KCI发生在攻击者泄露某一方的长期密钥，并利用该密钥冒充另一方。例如，4G/5G密钥协商协议允许轻易的密钥泄露冒充，因为双方共享相同的密钥*K*。理想的密钥协商协议应该防止这种攻击。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Performance</samp>
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">性能</samp>
- en: To be useful, a key agreement protocol should be efficient as well as secure.
    You should take several factors into account when considering a key agreement
    protocol’s efficiency, including the number of messages exchanged, their length,
    the computational effort to implement the protocol, and whether precomputations
    can be made to save time. A protocol is generally more efficient when exchanging
    fewer, shorter messages, and it’s best if interactivity is kept minimal so that
    neither party has to wait to receive a message before sending the next one. You
    can typically measure a protocol’s efficiency through its duration in terms of
    *round trips*, or the time it takes to send a message and receive a response.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有用，密钥协商协议应该既高效又安全。在考虑一个密钥协商协议的效率时，你应该考虑多个因素，包括交换的消息数量、消息的长度、实现协议的计算工作量以及是否可以进行预计算以节省时间。协议通常在交换较少、较短的消息时更高效，如果能够最小化交互性，使得双方无需等待收到消息再发送下一个消息，那是最理想的。你通常可以通过协议的持续时间来衡量其效率，以*往返时间*为标准，即发送消息并接收响应所需的时间。
- en: Round-trip time is usually the main cause of latency in protocols, but the amount
    of computation to be carried out by the parties also counts; the fewer required
    computations, and the more precomputations that can be done in advance, the better.
    For example, the 4G/5G key agreement protocol exchanges two messages of a few
    hundred bits each, which must be sent in a certain order. You can use precomputation
    with this protocol to save time since the operator can pick many values of *R*
    in advance; precompute the matching values of *SK*, *V*[1], and *V*[2]; and store
    them all in a database. In this case, precomputation has the advantage of reducing
    the exposure of the long-term key.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 往返时间通常是协议延迟的主要原因，但双方需要执行的计算量也很重要；所需计算越少，能进行的预计算越多，效果越好。例如，4G/5G密钥协商协议交换两条每条几百比特的消息，且必须按照特定顺序发送。你可以使用预计算来节省时间，因为运营商可以提前选择多个*R*值；预计算与*SK*、*V*[1]、*V*[2]的匹配值，并将它们都存储在数据库中。在这种情况下，预计算的优点是减少了长期密钥的暴露。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Diffie–Hellman Protocols</samp>'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">Diffie–Hellman 协议</samp>'
- en: The Diffie–Hellman function is the core of most of the deployed public-key agreement
    protocols—for example, in TLS and SSH. However, there is no single Diffie–Hellman
    protocol but rather a variety of ways to use the DH function to establish a shared
    secret. We’ll review three protocols in the sections that follow. In each discussion,
    I’ll stick to the usual crypto placeholder names and call the two parties Alice
    and Bob, and the attacker Eve. I’ll write *g* as the generator of the group used
    for arithmetic operations, a value fixed and known in advance to Alice, Bob, and
    Eve.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Diffie–Hellman 函数是大多数已部署的公钥协商协议的核心——例如 TLS 和 SSH。但并没有单一的 Diffie–Hellman 协议，而是有多种方法可以使用
    DH 函数来建立共享密钥。我们将在接下来的章节中回顾三种协议。在每个讨论中，我将坚持使用常见的加密占位符名称，称两方为 Alice 和 Bob，攻击者为 Eve。我将写
    *g* 作为用于算术运算的群生成元，这是一个在 Alice、Bob 和 Eve 之间预先固定并已知的值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Anonymous Diffie–Hellman</samp>
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">匿名 Diffie–Hellman</samp>
- en: '*Anonymous Diffie–Hellman* is the simplest Diffie–Hellman protocol. It’s anonymous
    because it’s not authenticated; the participants have no cryptographic identity
    that either party can verify, and neither party holds a long-term key. Alice can’t
    prove to Bob that she’s Alice, and vice versa.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*匿名 Diffie–Hellman* 是最简单的 Diffie–Hellman 协议。它之所以匿名，是因为没有认证机制；参与者没有任何加密身份，双方都无法验证对方的身份，也没有持有长期密钥。Alice
    无法证明自己是 Alice，Bob 也是如此。'
- en: In anonymous Diffie–Hellman, each party picks a random value (*a* for Alice
    and *b* for Bob) to use as a private key and sends the corresponding public key
    to the other peer. [Figure 11-2](chapter11.xhtml#fig11-2) shows the process in
    more detail.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在匿名 Diffie–Hellman 中，每一方选择一个随机值（*a* 代表 Alice，*b* 代表 Bob）作为私钥，并将对应的公钥发送给对方。[图
    11-2](chapter11.xhtml#fig11-2) 详细展示了这一过程。
- en: '![](../images/fig11-2.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig11-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-2: The anonymous
    Diffie–Hellman protocol</samp>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-2：匿名 Diffie–Hellman 协议</samp>
- en: Alice uses her exponent *a* and the group basis *g* to compute *A* = *g**^a*,
    which she sends to Bob. Bob receives *A* and computes *A**^b*, which is equal
    to (*g**^a*)*^b*. Bob now obtains the value *g**^(ab)* and computes *B* from his
    random exponent *b* and the value *g*. He then sends *B* to Alice, which she uses
    to compute *g**^(ab)*. Alice and Bob end up with the same value, *g**^(ab)*, after
    performing similar operations that involve raising both *g* and the value received
    to their private exponent’s power. A simple protocol, secure against only the
    laziest of attackers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Alice 使用她的指数 *a* 和群基 *g* 计算 *A* = *g**^a*，并将其发送给 Bob。Bob 收到 *A* 后计算 *A**^b*，这等同于
    (*g**^a*)*^b*。Bob 现在获得值 *g**^(ab)*，并根据他的随机指数 *b* 和值 *g* 计算 *B*。然后他将 *B* 发送给 Alice，Alice
    使用该值计算 *g**^(ab)*。Alice 和 Bob 在进行相似的操作后，最终得到相同的值 *g**^(ab)*，这些操作涉及将 *g* 和接收到的值分别提升到各自私有指数的幂。一个简单的协议，只能抵抗最懒的攻击者。
- en: Attackers can take down anonymous DH with a man-in-the-middle attack. A network
    attacker simply needs to intercept messages and pretend to be Bob (to Alice) and
    pretend to be Alice (to Bob), as [Figure 11-3](chapter11.xhtml#fig11-3) depicts.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以通过中间人攻击摧毁匿名 Diffie–Hellman 协议。网络攻击者只需要拦截消息，并假装是 Bob（对 Alice），又假装是 Alice（对
    Bob），如[图 11-3](chapter11.xhtml#fig11-3)所示。
- en: '![](../images/fig11-3.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig11-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-3: A man-in-the-middle
    attack on the anonymous Diffie–Hellman protocol</samp>'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-3：中间人攻击匿名 Diffie–Hellman
    协议</samp>
- en: As in the previous exchange, Alice and Bob pick random exponents, *a* and *b*.
    Alice now computes and sends *A*, but Eve intercepts and drops the message. Eve
    then picks a random exponent, *c*, and computes *C* = *g**^c* to send to Bob.
    Because this protocol has no authentication, Bob believes he is receiving *C*
    from Alice and goes on to compute *g**^(bc)*. Bob then computes *B* and sends
    that value to Alice, but Eve intercepts and drops the message again. Eve now computes
    *g**^(bc)*; picks a new exponent, *d*; computes *g**^(ad)*; computes *D* from
    *g**^d*; and sends *D* to Alice. Alice then computes *g**^(ad)* as well.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如同之前的交换过程，Alice 和 Bob 各自选择随机指数，*a* 和 *b*。Alice 现在计算并发送 *A*，但 Eve 拦截并丢弃了该消息。然后，Eve
    选择一个随机指数 *c*，计算 *C* = *g**^c* 并发送给 Bob。由于该协议没有认证机制，Bob 以为他收到了来自 Alice 的 *C*，并继续计算
    *g**^(bc)*。接着，Bob 计算 *B* 并将该值发送给 Alice，但 Eve 再次拦截并丢弃了消息。Eve 现在计算 *g**^(bc)*，选择一个新的指数
    *d*，计算 *g**^(ad)*，从 *g**^d* 计算出 *D*，并将 *D* 发送给 Alice。然后，Alice 也计算 *g**^(ad)*。
- en: As a result of this attack, the attacker Eve shares a secret with Alice (*g**^(ad)*)
    and another secret with Bob (*g**^(bc)*), while Alice and Bob believe that they’re
    sharing a single secret with each other. After completing the protocol execution,
    Alice derives symmetric keys from *g**^(ad)* to encrypt data sent to Bob, but
    Eve intercepts the encrypted messages, decrypts them, and reencrypts them to Bob
    using another set of keys derived from *g**^(bc)*—after potentially modifying
    the cleartext. All of this happens with Alice and Bob unaware; they’re doomed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种攻击，攻击者 Eve 与 Alice 共享一个秘密 (*g**^(ad)*)，并与 Bob 共享另一个秘密 (*g**^(bc)*)，而 Alice
    和 Bob 认为他们共享的是一个彼此之间的秘密。在协议执行完成后，Alice 从 *g**^(ad)* 推导出对称密钥来加密发送给 Bob 的数据，但 Eve
    拦截了加密消息，解密后使用另一个由 *g**^(bc)* 推导出的密钥重新加密并发送给 Bob——可能还会修改明文。所有这些操作都是在 Alice 和 Bob
    不知情的情况下进行的；他们注定会失败。
- en: To foil this attack, you need a way to authenticate the parties so Alice can
    prove she’s the real Alice and Bob can prove he’s the real Bob. Fortunately, there’s
    a way to do so.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种攻击，你需要一种认证双方身份的方法，这样 Alice 就可以证明她是真正的 Alice，Bob 也能证明他是真正的 Bob。幸运的是，确实有办法做到这一点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authenticated Diffie–Hellman</samp>
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">认证的 Diffie–Hellman</samp>
- en: '*Authenticated Diffie–Hellman* addresses the man-in-the-middle attacks that
    can affect anonymous DH. Authenticated DH equips the two parties with both a private
    key and a public key, thereby allowing Alice and Bob to sign their messages to
    stop Eve from sending messages on their behalf. Here, the signatures aren’t computed
    with a DH function but with a public-key signature scheme such as RSA-PSS. As
    a result, to successfully send messages on behalf of Alice, an attacker needs
    to forge a valid signature, which is impossible with a secure signature scheme.
    [Figure 11-4](chapter11.xhtml#fig11-4) shows how authenticated DH works.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*认证的 Diffie–Hellman* 解决了可能影响匿名 DH 的中间人攻击问题。认证的 DH 为双方提供了私钥和公钥，从而使得 Alice 和
    Bob 可以对他们的消息进行签名，以防止 Eve 代表他们发送消息。在这里，签名不是通过 DH 函数计算的，而是通过公钥签名方案（如 RSA-PSS）计算的。因此，要成功地代表
    Alice 发送消息，攻击者需要伪造一个有效的签名，而在安全的签名方案下，这是不可能的。[图 11-4](chapter11.xhtml#fig11-4)
    展示了认证 DH 的工作原理。'
- en: '![](../images/fig11-4.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig11-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-4: The authenticated
    Diffie–Hellman protocol</samp>'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-4：认证的 Diffie–Hellman 协议</samp>
- en: The label **Alice** (*priv*A, *pub*B) on the first line means that Alice holds
    her own private key, *priv*A, as well as Bob’s public key, *pub*B. This *priv*/*pub*
    key pair is called a *long-term key* because it’s fixed in advance and remains
    constant through consecutive runs of the protocol. Alice can use her key pair
    *priv*A/*pub*A with parties other than Bob, as long as they know *pub*A (*how*
    they know it is another question and one of the hardest operational problems in
    cryptography). These long-term private keys should be kept secret, while the public
    keys are considered to be known to an attacker.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行中的标签 **Alice** (*priv*A, *pub*B) 表示 Alice 持有她自己的私钥 *priv*A，以及 Bob 的公钥 *pub*B。这个
    *priv*/*pub* 密钥对被称为 *长期密钥*，因为它是预先固定的，并且在协议的连续执行中保持不变。Alice 可以使用她的密钥对 *priv*A/*pub*A
    与除 Bob 以外的其他方进行通信，只要他们知道 *pub*A（*他们怎么知道这个*是另一个问题，也是密码学中最难解决的操作问题之一）。这些长期私钥应该保密，而公钥则被认为是攻击者已知的。
- en: Alice and Bob begin by picking random exponents, *a* and *b*, as in anonymous
    DH. Alice then calculates *A* and a signature *sig*A based on a combination of
    her signing function **sign**, her private key *priv*A, and *A*. Now Alice sends
    *A* and *sig*A to Bob, who verifies *sig*A with her public key *pub*A. If the
    signature is invalid, Bob knows that the message didn’t come from Alice, and he
    discards *A*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Alice 和 Bob 首先选择随机指数 *a* 和 *b*，就像在匿名 DH 中一样。然后，Alice 基于她的签名函数 **sign**、她的私钥
    *priv*A 和 *A* 计算 *A* 和一个签名 *sig*A。现在，Alice 将 *A* 和 *sig*A 发送给 Bob，后者使用 Alice 的公钥
    *pub*A 来验证 *sig*A。如果签名无效，Bob 知道该消息不是来自 Alice，并会丢弃 *A*。
- en: If the signature is correct, Bob computes *g**^(ab)* from *A* and his random
    exponent *b*. He then computes *B* and his own signature from a combination of
    the **sign** function, his private key *priv*B, and *B*. He sends *B* and *sig*B
    to Alice, who attempts to verify *sig*B with Bob’s public key *pub*B. Alice computes
    *g**^(ab)* only if Bob’s signature is successfully verified.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果签名是正确的，Bob 会根据 *A* 和他自己的随机指数 *b* 计算 *g**^(ab)*。然后，他通过 **sign** 函数、自己的私钥 *priv*B
    和 *B* 的组合计算 *B* 和他的签名 *sig*B。接着，他将 *B* 和 *sig*B 发送给 Alice，后者尝试用 Bob 的公钥 *pub*B
    来验证 *sig*B。如果 Bob 的签名成功验证，Alice 才会计算 *g**^(ab)*。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security Against Network Attackers</samp>
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">防止网络攻击者的安全性</samp>
- en: 'Authenticated DH is secure against network attackers because they can’t learn
    any bit of information on the shared secret *g**^(ab)* since they ignore the DH
    exponents. Authenticated DH also provides forward secrecy: even if an attacker
    corrupts any of the parties at some point, as in the *breach* attack model discussed
    earlier, they’d learn the private signing keys but not any of the ephemeral DH
    exponents; hence, they’d be unable to learn the value of any previously shared
    secrets.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 认证 DH 对网络攻击者是安全的，因为他们无法从共享秘密 *g**^(ab)* 中获取任何信息，因为他们忽略了 DH 指数。认证 DH 还提供前向保密性：即使攻击者在某个时刻破坏了任何一方，正如之前讨论的
    *泄漏* 攻击模型那样，他们将获得私有签名密钥，但无法获得任何临时 DH 指数；因此，他们无法得知任何先前共享秘密的值。
- en: The authenticated variant of DH offers only partial protection against *key
    control*. Alice can’t craft special values of *a* to restrict the choice of shared
    secret *g**^(ab)*, because she doesn’t yet know *g**^b*, which influences the
    result as much as *a*. (One exception would be if Alice chose *a* = 0, in which
    case you’d have *g**^(ab)* = 1 for any *b*. The protocol should thus reject 0,
    though implementations may not do so in practice.) However, Bob can try several
    values of *b* until he finds one “that suits him”; for example, for which *g**^(ab)*
    has certain properties, such as its first 16 bits being 1.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: DH 的认证变体只提供了对 *密钥控制* 的部分保护。Alice 不能构造特殊的 *a* 值来限制共享秘密 *g**^(ab)* 的选择，因为她还不知道
    *g**^b*，而 *g**^b* 对结果的影响与 *a* 一样大。（一个例外是如果 Alice 选择 *a* = 0，在这种情况下无论 *b* 取什么值，*g**^(ab)*
    都会等于 1。协议因此应该拒绝 0，尽管实际实现可能不会这么做。）然而，Bob 可以尝试多个 *b* 值，直到找到一个“适合他的”值；例如，对于某些值，使得
    *g**^(ab)* 具有某些属性，如其前 16 位为 1。
- en: You can eliminate Bob’s power over the value of the secret by sending **Hash**(*g**^b*)
    from Bob to Alice as the first message, before Alice sends her *g**^a*. I’ll leave
    you to analyze this modification and understand why it works (the newly sent message
    is a *commitment* of Bob’s public key).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 Alice 发送她的 *g**^a* 之前，先从 Bob 发送 **Hash**(*g**^b*) 到 Alice 作为第一个消息，来消除
    Bob 对秘密值的控制。我将留给你分析这个修改并理解为什么它有效（新发送的消息是 Bob 公钥的*承诺*）。
- en: Authenticated DH has other limitations. For one, Eve can pretend to be Alice
    by recording previous values of *A* and *sig*A and replaying them to Bob. Bob
    mistakenly believes he’s sharing a secret with Alice, even though Eve isn’t able
    to learn that secret because she doesn’t know Alice’s secret *a*. She thus wouldn’t
    be able to compute *B**^a* from the *B* sent by Bob.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 认证 DH 还有其他局限性。例如，Eve 可以通过记录之前的 *A* 和 *sig*A 值并将其重放给 Bob 来伪装成 Alice。Bob 错误地认为他正在与
    Alice 共享秘密，尽管 Eve 无法得知该秘密，因为她不知道 Alice 的秘密 *a*。因此，她无法从 Bob 发送的 *B* 计算出 *B**^a*。
- en: You can eliminate this risk by adding a *key confirmation* procedure, wherein
    Alice and Bob prove to each other that they own the shared secret. For example,
    Alice and Bob may perform key confirmation by sending **Hash**(*pub*A || *pub*B
    || *g**^(ab)*) and **Hash**(*pub*B || *pub*A || *g**^(ab)*), respectively, for
    some hash function **Hash**. Both parties can verify the correctness of these
    hash values by recomputing its result. The different order of public keys *pub*A
    || *pub*B and *pub*B || *pub*A ensures that Alice and Bob will send different
    values and that an attacker can’t pretend to be Alice by copying Bob’s hash value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加 *密钥确认* 程序来消除这个风险，其中 Alice 和 Bob 互相证明他们拥有共享秘密。例如，Alice 和 Bob 可以通过分别发送
    **Hash**(*pub*A || *pub*B || *g**^(ab)*) 和 **Hash**(*pub*B || *pub*A || *g**^(ab)*)
    来执行密钥确认，其中 **Hash** 是某个哈希函数。双方可以通过重新计算结果来验证这些哈希值的正确性。公钥 *pub*A || *pub*B 和 *pub*B
    || *pub*A 的不同顺序确保了 Alice 和 Bob 发送不同的值，且攻击者不能通过复制 Bob 的哈希值来伪装成 Alice。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security Against Data Leaks</samp>
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">防止数据泄露的安全性</samp>
- en: Authenticated DH’s vulnerability to data leak attackers is of greater concern.
    In this type of attack, the attacker learns the value of ephemeral, short-term
    secrets (namely, the exponents *a* and *b*) and uses that information to impersonate
    one of the communicating parties. If Eve learns the value of an exponent *a* along
    with the value of *sig*A sent to Bob, she could initiate a new execution of the
    protocol and impersonate Alice, as [Figure 11-5](chapter11.xhtml#fig11-5) illustrates.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 经过身份验证的 DH 在面对数据泄露攻击者时的脆弱性更为令人关注。在此类攻击中，攻击者获取了临时、短期秘密（即指数 *a* 和 *b*）的值，并利用这些信息冒充其中一方通信者。如果
    Eve 获取了指数 *a* 的值以及发送给 Bob 的 *sig*A 的值，她就可以发起协议的新执行并冒充 Alice，正如[图 11-5](chapter11.xhtml#fig11-5)所示。
- en: '![](../images/fig11-5.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig11-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-5: An impersonation
    attack on the authenticated Diffie–Hellman protocol</samp>'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-5：对经过身份验证的 Diffie–Hellman
    协议的冒充攻击</samp>
- en: In this attack scenario, Eve learns the value of an *a* and replays the corresponding
    *A* and its signature *sig*A, pretending to be Alice. Bob verifies the signature
    and computes *g**^(ab)* from *A* and sends *B* and *sig*B, which Eve then uses
    to compute *g**^(ab)*, using the stolen *a*. This results in the two having a
    shared secret. Bob now believes he’s talking to Alice.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种攻击场景中，Eve 获取了 *a* 的值，并重放了相应的 *A* 及其签名 *sig*A，假装自己是 Alice。Bob 验证签名并根据 *A*
    计算 *g**^(ab)*，然后发送 *B* 和 *sig*B，Eve 接着利用窃取的 *a* 来计算 *g**^(ab)*，从而两者达成了共享秘密。此时，Bob
    认为他在与 Alice 进行通信。
- en: You can protect authenticated DH against the leak of ephemeral secrets by integrating
    the long-term keys into the shared secret computation so that you can’t determine
    the shared secret without knowing the long-term secret.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将长期密钥整合到共享秘密计算中，来保护经过身份验证的 DH 免受临时秘密泄露的风险，这样就无法在不知道长期秘密的情况下确定共享秘密。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Menezes–Qu–Vanstone</samp>
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Menezes–Qu–Vanstone</samp>
- en: The *Menezes–Qu–Vanstone (MQV)* protocol is a milestone in the history of DH-based
    protocols. Designed in 1998, MQV was approved to protect most critical assets
    when the NSA included it in its Suite B, a portfolio of algorithms designed to
    protect classified information. (NSA eventually dropped MQV, allegedly because
    it wasn’t used. I’ll discuss the reasons why shortly.)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*Menezes–Qu–Vanstone (MQV)* 协议是 DH 基础协议历史上的一个里程碑。MQV 于 1998 年设计，获得批准用于保护大多数关键资产，当时
    NSA 将其纳入其 Suite B，后者是为了保护机密信息而设计的一组算法。（NSA 最终放弃了 MQV，原因据说是其未被广泛使用。稍后我会讨论原因。）'
- en: MQV is Diffie–Hellman on steroids. It’s more secure than authenticated DH, and
    it improves on authenticated DH’s performance properties. In particular, MQV allows
    users to send only two messages, independently of each other, in arbitrary order.
    Users can also send shorter messages than with authenticated DH, and they don’t
    need to send explicit signature or verification messages. In other words, you
    don’t need to use a signature scheme in addition to the Diffie–Hellman function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: MQV 是经过加强的 Diffie–Hellman。它比经过身份验证的 DH 更安全，并且改善了经过身份验证的 DH 的性能特性。特别是，MQV 允许用户发送仅有的两条消息，彼此独立，顺序任意。用户还可以发送比经过身份验证的
    DH 更短的消息，而且不需要发送显式的签名或验证消息。换句话说，你不需要在 Diffie–Hellman 函数之外使用签名方案。
- en: 'As with authenticated DH, in MQV Alice and Bob each hold a long-term private
    key as well as the long-term public key of the other party. The difference is
    that the MQV keys aren’t signing keys: they consist of a private exponent, *x*,
    and a public value, *g**^x*. [Figure 11-6](chapter11.xhtml#fig11-6) shows the
    operation of the MQV protocol.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与经过身份验证的 DH 相同，在 MQV 中，Alice 和 Bob 各自持有一个长期私钥以及对方的长期公钥。不同之处在于，MQV 密钥不是签名密钥：它们由一个私有指数
    *x* 和一个公有值 *g**^x* 组成。[图 11-6](chapter11.xhtml#fig11-6) 展示了 MQV 协议的操作。
- en: '![](../images/fig11-6.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig11-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-6: The MQV protocol</samp>'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-6：MQV 协议</samp>
- en: 'The *x* and *y* are Alice and Bob’s respective long-term private keys, and
    *X* and *Y* are their public keys. Bob and Alice start with their own private
    keys and each other’s public keys, which are *g* to the power of a private key.
    Each chooses a random exponent, and then Alice calculates *A* and sends it to
    Bob, who then calculates *B* and sends it to Alice. Once Alice gets Bob’s ephemeral
    public key *B*, she combines it with her long-term private key *x*, her ephemeral
    private key *a*, and Bob’s long-term public key *Y* by calculating the result
    of (*B* × *Y**^B*)*^a* ^+ *^(xA)*, as in [Figure 11-6](chapter11.xhtml#fig11-6).
    Developing this expression, you obtain the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*和*y*分别是Alice和Bob的长期私钥，*X*和*Y*是他们的公钥。Bob和Alice从各自的私钥和对方的公钥开始，公钥是*g*的私钥幂。每人选择一个随机的指数，然后Alice计算*A*并将其发送给Bob，接着Bob计算*B*并将其发送给Alice。一旦Alice得到Bob的短期公钥*B*，她将其与自己的长期私钥*x*、短期私钥*a*以及Bob的长期公钥*Y*结合，计算出结果（*B*
    × *Y**^B*）*^a* ^+ *^(xA)*，如[图11-6](chapter11.xhtml#fig11-6)所示。展开这个表达式，你可以得到以下结果：'
- en: '![](../images/pg228-1.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg228-1.jpg)'
- en: 'Meanwhile, Bob calculates the result of (*A* × *X**^A*)*^b* ^+ *^(yB)*, and
    you can verify that it’s equal to the value Alice calculated:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，Bob计算（*A* × *X**^A*）*^b* ^+ *^(yB)*的结果，你可以验证它等于Alice计算出的值：
- en: '![](../images/pg228-2.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg228-2.jpg)'
- en: You get the same value for both Alice and Bob, *g*^(*^b* ^+ *^(yB)*^()()*^a*
    ^+ *^(xA)*^), which tells you that Alice and Bob share the same secret.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Alice和Bob都得到相同的值，*g*^(*^b* ^+ *^(yB)*^()()*^a* ^+ *^(xA)*^)，这表明Alice和Bob共享相同的密钥。
- en: Unlike authenticated DH, you can’t break MQV by a mere leak of the ephemeral
    secrets. Knowledge of *a* or *b* won’t let an attacker determine the final shared
    secret because they need the long-term private keys to compute it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与认证DH不同，通过单纯泄露短期密钥并不能破解MQV。知道*a*或*b*并不能让攻击者确定最终的共享密钥，因为他们需要长期私钥才能计算出来。
- en: What happens in the strongest attack model, the breach model, when a long-term
    key is compromised? If Eve compromises Alice’s long-term private key *x*, the
    previously established shared secrets are safe because their computation also
    involved Alice’s ephemeral private keys.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在最强的攻击模型——破坏模型中，如果长期密钥被破坏，会发生什么？如果Eve破坏了Alice的长期私钥*x*，那么先前建立的共享密钥仍然是安全的，因为它们的计算过程也涉及了Alice的短期私钥。
- en: However, MQV doesn’t provide *perfect* forward secrecy because of the following
    attack. Say, for example, that Eve intercepts Alice’s *A* message and replaces
    it with her *A* = *g**^a* for some *a* that Eve chose. In the meantime, Bob sends
    *B* to Alice (and Eve records *B*’s value) and computes the shared key. If Eve
    later compromises Alice’s long-term private key *x*, she can determine the key
    that Bob computed during this session. This breaks forward secrecy since Eve has
    now recovered the shared secret of a previous execution of the protocol. In practice,
    however, you can eliminate the risk with a key-confirmation step in which Alice
    and Bob would realize that they don’t share the same key, and they’d abort the
    protocol before deriving any session keys.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，MQV并不能提供*完美*的前向保密性，原因是存在以下攻击。例如，假设Eve拦截了Alice的*A*消息，并将其替换为她自己选择的*a*值，使得*A*
    = *g**^a*。与此同时，Bob向Alice发送*B*（Eve记录了*B*的值），并计算共享密钥。如果Eve后来获取了Alice的长期私钥*x*，她就能确定Bob在此会话中计算出的密钥。这破坏了前向保密性，因为Eve已经恢复了先前执行协议时的共享密钥。然而，在实践中，你可以通过一个密钥确认步骤来消除这一风险，Alice和Bob可以意识到他们没有共享相同的密钥，并且在派生任何会话密钥之前终止协议。
- en: Despite its elegance and security, MQV is rarely used in practice for a couple
    of reasons. It used to be encumbered by patents, which hampered its widespread
    adoption. It’s also harder than it looks to get MQV right. In fact, when weighed
    against its increased complexity, MQV’s security benefits are often perceived
    as low in comparison to the simpler authenticated DH.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管MQV具有优雅性和安全性，但在实践中却很少使用，原因有几个。它曾经受到专利的限制，阻碍了其广泛采用。与此同时，正确实现MQV比看起来要困难得多。事实上，考虑到它增加的复杂性，MQV的安全性优势通常被认为相较于简单的认证DH较低。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">事情如何出错</samp>
- en: Diffie–Hellman protocols can fail spectacularly in a variety of ways. The following
    sections highlight some cases often observed in practice.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Diffie–Hellman协议可能以各种方式失败，下面的章节将突出显示一些实践中常见的情况。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Not Hashing the Shared
    Secret</samp>
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">没有对共享密钥进行哈希处理</samp>
- en: I’ve alluded to the fact that the shared secret that concludes a DH session
    exchange (*g**^(ab)* in our examples) is taken as input to derive session keys
    but is not a key itself. And it shouldn’t be. A symmetric key should look random,
    and each bit should either be 0 or 1 with the same probability. But *g**^(ab)*
    is not a random string; it’s a random element within some mathematical group whose
    bits may be biased toward 0 or 1\. A random group element is different from a
    random string of bits.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾提到过，结束DH会话交换的共享密钥（我们示例中的 *g**^(ab)*）被作为输入用于派生会话密钥，但它本身并不是密钥。而它不应该是密钥。对称密钥应该看起来是随机的，每一位应该有相同的概率是0或1。但是
    *g**^(ab)* 并不是一个随机字符串；它是某个数学群中的随机元素，其位可能会偏向0或1。一个随机的群元素与一个随机的位字符串是不同的。
- en: 'Imagine, for example, that you’re working within the multiplicative group **Z**[13]^*
    = {1, 2, 3, . . . , 12} using *g* = 2 as a generator of the group, meaning that
    *g**^i* spans all values of **Z**[13]^* for *i* in 1, 2, . . . 12: *g*¹ = 2, *g*²
    = 4, *g*³ = 8, *g*⁴ = 3, and so on. If *g*’s exponent is random, you’ll get a
    random element of **Z**[13]^*, but the encoding of a **Z**[13]^* element as a
    4-bit string won’t be uniformly random: not all bits will have the same probability
    of being a 0 or a 1\. In **Z**[13]^*, seven values have 0 as their most significant
    bit (the numbers from 1 to 7 in the group), but only five have 1 as their most
    significant bit (from 8 to 12). That is, this bit is 0 with probability 7/12 ≈
    0.58, whereas a random bit should ideally be 0 with probability 0.5\. Moreover,
    the 4-bit sequences 1101, 1110, and 1111 will never appear.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，假设你在使用乘法群**Z**[13]^* = {1, 2, 3, . . . , 12}，并且使用 *g* = 2作为该群的生成元，这意味着 *g**^i*遍历所有**Z**[13]^*中的值，i取1,
    2, . . . 12：*g*¹ = 2，*g*² = 4，*g*³ = 8，*g*⁴ = 3，依此类推。如果 *g*的指数是随机的，你将得到**Z**[13]^*中的一个随机元素，但将**Z**[13]^*元素编码为4位字符串时，不会是均匀随机的：并非所有位都有相同的概率是0或1。在**Z**[13]^*中，七个值的最高有效位是0（群中从1到7的数字），但只有五个值的最高有效位是1（从8到12）。也就是说，这个位是0的概率是7/12
    ≈ 0.58，而随机位理想情况下应该是0的概率为0.5。此外，4位序列1101、1110和1111永远不会出现。
- en: To avoid such biases in the session keys derived from a DH shared secret, use
    a cryptographic hash function such as BLAKE3 or SHA-3—or, better yet, a key derivation
    function (KDF). An example of KDF construction is HKDF, or HMAC-based KDF (as
    specified in RFC 5869), but today BLAKE2 and SHA-3 feature dedicated modes to
    behave as KDFs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免从DH共享密钥派生的会话密钥存在这种偏差，可以使用加密哈希函数，如BLAKE3或SHA-3，或者更好的是，使用密钥派生函数（KDF）。KDF构造的一个例子是HKDF，或基于HMAC的KDF（如RFC
    5869中所规定），但如今BLAKE2和SHA-3都有专门的模式来充当KDF。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Anonymous Diffie–Hellman
    from TLS 1.0</samp>
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">TLS 1.0中的匿名Diffie–Hellman</samp>
- en: The TLS protocol is the security behind HTTPS secure websites as well as many
    other protocols, such as email transfer with the Simple Mail Transfer Protocol
    (SMTP). TLS takes several parameters, including the type of Diffie–Hellman protocol
    it will use. For backward compatibility reasons, TLS supports anonymous DH since
    version 1.0 up to version 1.2 (that is, without any server authentication), though
    not in version 1.3\. As DH is secure against only passive attackers, it can give
    a false impression of security.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: TLS协议是HTTPS安全网站以及其他许多协议背后的安全机制，比如使用简单邮件传输协议（SMTP）的电子邮件传输。TLS采用多个参数，包括它将使用的Diffie–Hellman协议的类型。出于向后兼容的原因，TLS从1.0版本到1.2版本支持匿名DH（即没有任何服务器认证），但在1.3版本中不再支持。由于DH仅对被动攻击者具有安全性，它可能会给人一种错误的安全感。
- en: 'The original documentation of TLS describes the risks of this protocol (*[https://<wbr>www<wbr>.rfc<wbr>-editor<wbr>.org<wbr>/rfc<wbr>/rfc2246](https://www.rfc-editor.org/rfc/rfc2246)*):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 'TLS的原始文档描述了该协议的风险 (*[https://<wbr>www<wbr>.rfc<wbr>-editor<wbr>.org<wbr>/rfc<wbr>/rfc2246](https://www.rfc-editor.org/rfc/rfc2246)*):'
- en: Completely anonymous connections only provide protection against passive eavesdropping.
    Unless an independent tamper-proof channel is used to verify that the finished
    messages were not replaced by an attacker, server authentication is required in
    environments where active man-in-the-middle attacks are a concern.
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 完全匿名的连接仅能防止被动窃听。除非使用独立的防篡改通道来验证完成的消息未被攻击者替换，否则在存在主动中间人攻击风险的环境中，需要服务器认证。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unsafe Group Parameters</samp>
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">不安全的组参数</samp>
- en: In January 2016, the maintainers of the OpenSSL toolkit fixed a high-severity
    vulnerability (CVE-2016-0701) that allowed an attacker to exploit unsafe Diffie–Hellman
    parameters. The root cause of the vulnerability was that OpenSSL allowed users
    to work with unsafe DH group parameters (namely, an unsafe prime *p*) instead
    of throwing an error and aborting the protocol altogether before performing any
    arithmetic operation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在2016年1月，OpenSSL工具包的维护者修复了一个高严重性的漏洞（CVE-2016-0701），该漏洞允许攻击者利用不安全的Diffie-Hellman参数。漏洞的根本原因是OpenSSL允许用户使用不安全的DH组参数（即不安全的素数*p*），而不是在执行任何算术操作之前抛出错误并完全中止协议。
- en: Essentially, OpenSSL accepted a prime number *p* whose multiplicative group
    **Z**p^* (where all DH operations happen) contained small subgroups. As you learned
    at the beginning of this chapter, the existence of small subgroups within a larger
    group in a cryptographic protocol is bad because it confines shared secrets to
    a much smaller set of possible values than if it were to use the whole group **Z**p^*.
    Worse still, an attacker can craft a DH exponent *x* that, when combined with
    the victim’s public key *g**^y*, reveals information on the private key *y* and
    eventually its entirety.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，OpenSSL接受了一个素数*p*，其乘法群**Z**p^*（所有DH操作发生的地方）包含小子群。正如你在本章开头所学到的，密码学协议中较大群体内的小子群的存在是非常不利的，因为它将共享的密钥限制在一个比使用整个群**Z**p^*更小的值集上。更糟糕的是，攻击者可以构造一个DH指数*x*，当它与受害者的公钥*g**^y*结合时，泄露私钥*y*的部分信息，最终揭示其完整内容。
- en: 'Although the actual vulnerability is from 2016, the principle the attack used
    dates back to the 1997 paper “A Key Recovery Attack on Discrete Log-based Schemes
    Using a Prime Order Subgroup” by Chae Hoon Lim and Pil Joong Lee. The fix for
    the vulnerability is simple: when accepting a prime *p* as group modulus, the
    protocol must check that *p* is a safe prime by verifying that (*p* – 1) / 2 is
    prime as well to ensure that the group **Z**p^* won’t have small subgroups and
    that an attack on this vulnerability will fail.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管实际漏洞源自2016年，但该攻击所采用的原理可以追溯到1997年Chae Hoon Lim和Pil Joong Lee的论文《使用素数阶子群的离散对数方案的密钥恢复攻击》。修复此漏洞的方法很简单：当接受素数*p*作为群模数时，协议必须通过验证(*p*
    – 1) / 2是否为素数来检查*p*是否为安全素数，从而确保群**Z**p^*没有小子群，攻击者无法利用此漏洞进行攻击。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">进一步阅读</samp>
- en: You can dig deeper into the DH key agreement protocols by reading a number of
    standards and official publications, including ANSI X9.42, RFC 2631 and RFC 5114,
    IEEE 1363, and NIST SP 800-56A. These serve as references to ensure interoperability
    and to provide recommendations for group parameters.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过阅读多个标准和官方出版物，深入了解DH密钥协商协议，包括ANSI X9.42、RFC 2631和RFC 5114、IEEE 1363和NIST
    SP 800-56A。这些文献作为参考，确保互操作性并为群参数提供建议。
- en: 'To learn more about advanced DH protocols (such as MQV and its cousins HMQV
    and OAKE, among others) and their security notions (including unknown-key share
    attacks and group representation attacks), read the 2005 article “HMQV: A High-Performance
    Secure Diffie–Hellman Protocol” by Hugo Krawczyk (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2005<wbr>/176](https://eprint.iacr.org/2005/176)*)
    and the 2011 article “A New Family of Implicitly Authenticated Diffie–Hellman
    Protocols” by Andrew C. Yao and Yunlei Zhao (*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2011<wbr>/035](https://eprint.iacr.org/2011/035)*).
    These articles express Diffie–Hellman operations differently than in this chapter.
    For example, they represent the shared secret as *xP* instead of *g**^x*. Generally,
    you’ll find multiplication replaced with addition and exponentiation replaced
    with multiplication, because those protocols are usually not defined over groups
    of integers but over elliptic curves, as you’ll learn in [Chapter 12](chapter12.xhtml).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于高级DH协议（如MQV及其相关协议HMQV和OAKE等）及其安全性概念（包括未知密钥共享攻击和群表示攻击），请阅读Hugo Krawczyk的2005年文章《HMQV：一种高效的安全Diffie-Hellman协议》（*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2005<wbr>/176](https://eprint.iacr.org/2005/176)*)和Andrew
    C. Yao与Yunlei Zhao的2011年文章《一种新的隐式认证Diffie-Hellman协议家族》（*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2011<wbr>/035](https://eprint.iacr.org/2011/035)*）。这些文章以不同于本章的方式表达Diffie-Hellman操作。例如，它们将共享密钥表示为*xP*而不是*g**^x*。通常，你会发现乘法被加法取代，指数运算被乘法取代，因为这些协议通常不是定义在整数群上，而是定义在椭圆曲线上，正如你在[第12章](chapter12.xhtml)中将学到的。
