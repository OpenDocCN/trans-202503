- en: '# 5'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '# 5'
- en: Analyzing Network Protocols
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分析网络协议
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Analyzing protocols is important for tasks such as fingerprinting, obtaining
    information, and even exploitation. But in the IoT world, you’ll frequently have
    to work with proprietary, custom, or new network protocols. These protocols can
    be challenging, because even if you can capture network traffic, packet analyzers
    like Wireshark often can’t identify what you’ve found. Sometimes, you’ll need
    to write new tools to communicate with the IoT device.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 协议分析对于任务如指纹识别、信息获取甚至漏洞利用都至关重要。但在物联网领域，你经常需要处理专有的、定制的或新的网络协议。这些协议可能会很具挑战性，因为即使你能够捕获到网络流量，像Wireshark这样的数据包分析工具往往无法识别你所发现的内容。有时，你可能需要编写新工具来与物联网设备进行通信。
- en: In this chapter, we explain the process of analyzing network communications,
    focusing specifically on the challenges you’ll face when working with unusual
    protocols. We start by walking through a methodology for performing security assessments
    of unfamiliar network protocols and implementing custom tools to analyze them.
    Next, we extend the most popular traffic analyzer, Wireshark, by writing our own
    protocol dissector. Then we write custom modules for Nmap to fingerprint and even
    attack any new network protocol that dares to cross your path.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们解释了分析网络通信的过程，特别关注处理不常见协议时你将面临的挑战。我们首先介绍了一种执行陌生网络协议安全评估和实现自定义工具进行分析的方法。接下来，我们通过编写自己的协议解析器扩展了最流行的流量分析器Wireshark。然后，我们为Nmap编写了自定义模块，以指纹识别甚至攻击任何敢于与你的道路相交的新网络协议。
- en: The examples in this chapter target the DICOM protocol, one of the most common
    protocols in medical devices and clinical systems, rather than an unusual protocol.
    Even so, almost no security tools support DICOM, so this chapter should help you
    work with any unusual network protocol you might encounter in the future.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例以DICOM协议为目标，这是医疗设备和临床系统中最常见的协议之一，而不是一种不常见的协议。尽管如此，几乎没有安全工具支持DICOM协议，因此本章将帮助你处理将来可能遇到的任何不常见网络协议。
- en: Inspecting Network Protocols
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查网络协议
- en: When you’re working with unusual protocols, it’s best to analyze them according
    to a methodology. Follow the process we describe in this section when assessing
    a network protocol’s security. We attempt to cover the most important tasks, including
    information gathering, analysis, prototyping, and security auditing.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理不常见的协议时，最好根据一种方法论来分析它们。按照本节中描述的过程评估网络协议的安全性。我们尝试涵盖最重要的任务，包括信息收集、分析、原型制作和安全审计。
- en: Information Gathering
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信息收集
- en: In the information-gathering phase, you’ll try to find all relevant resources
    available to you. But first, figure out whether the protocol is well documented
    by searching for the protocol’s official and unofficial documentation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在信息收集阶段，你将尽力找到所有可用的相关资源。但首先，查明该协议是否有良好的文档记录，方法是搜索该协议的官方和非官方文档。
- en: Enumerating and Installing Clients
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 枚举和安装客户端
- en: Once you have access to the documentation, find all the clients that can communicate
    with the protocol and install them. You can use these to replicate and generate
    traffic at will. Different clients might implement the protocol with small variations,
    so note these differences! Also, check whether programmers have written implementations
    in different programming languages. The more clients and implementations you find,
    the higher your chances are of finding better documentation and replicating network
    messages.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了文档，找到所有能够与该协议通信的客户端并安装它们。你可以使用这些客户端随意复制和生成流量。不同的客户端可能会对协议进行一些小的变动，因此请注意这些差异！此外，检查是否有程序员用不同的编程语言编写了实现。你找到的客户端和实现越多，找到更好文档和复制网络消息的机会就越大。
- en: Discovering Dependent Protocols
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 发现依赖的协议
- en: 'Next, figure out whether the protocol depends on other protocols. For example,
    the Server Message Block (SMB) protocol generally works with NetBios over TCP/IP
    (NBT). If you’re writing new tools, you need to know any protocol dependencies
    to read and understand messages and to create and send new messages. Be sure to
    figure out which transport protocol your protocol is using. Is it TCP or UDP?
    Or is it something else: SCTP, maybe?'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，弄清楚该协议是否依赖于其他协议。例如，服务器消息块（SMB）协议通常与TCP/IP上的NetBios（NBT）一起工作。如果你正在编写新工具，你需要了解协议的依赖关系，以便读取和理解消息，以及创建和发送新消息。确保弄清楚你的协议使用的是哪种传输协议。是TCP还是UDP？还是其他协议：也许是SCTP？
- en: Figuring Out the Protocol’s Port
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 确定协议的端口
- en: Figure out the protocol’s default port number and whether the protocol ever
    runs on alternate ports. Identifying the default port and whether that number
    can change is helpful information that you’ll use when writing scanners or information-gathering
    tools. For example, Nmap reconnaissance scripts might not run if we write an inaccurate
    execution rule, and Wireshark might not use the correct dissector. Although there
    are workarounds for these issues, it’s best to have robust execution rules from
    the start.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 找出协议的默认端口号以及协议是否会在其他端口上运行。识别默认端口及其是否可以更改是编写扫描器或信息收集工具时的有用信息。例如，如果我们编写了不准确的执行规则，Nmap
    侦察脚本可能无法运行，而 Wireshark 可能无法使用正确的解码器。虽然这些问题有解决方法，但最好从一开始就拥有健全的执行规则。
- en: Finding Additional Documentation
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找额外的文档
- en: Check Wireshark’s website for additional documentation or capture samples. The
    Wireshark project often includes packet captures and is an overall great source
    of information. The project uses a wiki ([https://gitlab.com/wireshark/wireshark/-/wikis/home/](https://gitlab.com/wireshark/wireshark/-/wikis/home/))
    to allow contributors to add new information to every page.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请访问 Wireshark 网站查找额外的文档或捕获样本。Wireshark 项目通常包括数据包捕获，是一个极好的信息来源。该项目使用维基（[https://gitlab.com/wireshark/wireshark/-/wikis/home/](https://gitlab.com/wireshark/wireshark/-/wikis/home/)）允许贡献者向每个页面添加新信息。
- en: Also, notice which areas lack documentation. Can you identify functions that
    aren’t well described? A lack of documentation can point you toward interesting
    findings.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，注意哪些区域缺乏文档。您能否识别出描述不充分的功能？文档缺失可能会指向有趣的发现。
- en: Testing Wireshark Dissectors
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试 Wireshark 解码器
- en: Test whether all the Wireshark dissectors work properly against the protocol
    in use. Can Wireshark interpret and read all fields correctly in the protocol
    messages?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 测试所有 Wireshark 解码器是否能正确地处理所使用的协议。Wireshark 能否正确地解析并读取协议消息中的所有字段？
- en: To do this, first check whether Wireshark has a dissector for the protocol and
    if it’s enabled. You can do that by clicking **Analyze**▶**Enabled Protocols**,
    as shown in [Figure 5-1](#figure5-1).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，首先检查 Wireshark 是否有该协议的解码器，并且是否已启用。您可以通过点击**分析**▶**启用协议**来检查，如[图 5-1](#figure5-1)所示。
- en: '![f05001](Images/f05001.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![f05001](Images/f05001.png)'
- en: 'Figure 5-1: The Enabled Protocols window in Wireshark'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-1：Wireshark 中的启用协议窗口
- en: If the protocol specifications are public, check that all fields are identified
    correctly. Especially with complex protocols, dissectors often have errors. If
    you spot any, pay close attention to them. To get more ideas, review the list
    of Common Vulnerabilities and Exposures (CVEs) assigned to Wireshark dissectors.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果协议规范是公开的，检查所有字段是否正确定义。尤其是对于复杂的协议，解码器常常会有错误。如果发现任何错误，请特别留意它们。为了获得更多想法，可以查看分配给
    Wireshark 解码器的常见漏洞与暴露（CVE）列表。
- en: Analysis
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析
- en: In the analysis phase, generate and replay traffic to understand how the protocol
    works. The objective is to get a clear idea of the overall structure of the protocol,
    including its transport layer, messages, and available operations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析阶段，生成并重放流量，以了解协议的工作原理。目标是清楚地了解协议的整体结构，包括其传输层、消息和可用操作。
- en: Obtaining a Copy of the Network Traffic
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取网络流量副本
- en: Depending on the type of device, there are different ways of obtaining the network
    traffic you need to analyze. Some might support proxy configurations out of the
    box! Determine whether you need to perform active or passive network traffic sniffing.
    (You can find several examples of how to do this in James Forshaw’s *Attacking
    Network Protocols* [No Starch Press, 2018].) Try to generate traffic for every
    use case available, and generate as much traffic as possible. Having different
    clients helps you understand the differences and quirks in existing implementations.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据设备类型，有不同的方法来获取您需要分析的网络流量。有些设备可能直接支持代理配置！确定您是否需要进行主动或被动的网络流量嗅探。（您可以在 James
    Forshaw 的《攻击网络协议》[No Starch Press, 2018]中找到几个关于如何做的示例。）尽量为每个可用的使用场景生成流量，并尽可能多地生成流量。拥有不同的客户端有助于您了解现有实现中的差异和独特之处。
- en: One of the first steps in the analysis phase should be looking at the traffic
    capture and examining the packets sent and received. Some obvious issues might
    pop up, so it’s useful to do this before moving on with active analysis. The website
    [https://gitlab.com/wireshark/wireshark/-/wikis/SampleCaptures/](https://gitlab.com/wireshark/wireshark/-/wikis/SampleCaptures/)
    is an excellent resource for finding public captures.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 分析阶段的第一步应该是查看流量捕获并检查发送和接收的数据包。可能会出现一些显而易见的问题，因此在进行主动分析之前，进行此步骤是非常有用的。网站 [https://gitlab.com/wireshark/wireshark/-/wikis/SampleCaptures/](https://gitlab.com/wireshark/wireshark/-/wikis/SampleCaptures/)
    是寻找公共捕获的一个优秀资源。
- en: Analyzing Network Traffic with Wireshark
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Wireshark 分析网络流量
- en: If Wireshark has a dissector that can parse the traffic you generated, enable
    it by clicking the checkbox by its name in the Enabled Protocols window, as shown
    in [Figure 5-2](#figure5-2).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Wireshark 有一个可以解析你生成的流量的解析器，通过在“已启用协议”窗口中勾选其名称旁的复选框来启用它，如[图 5-2](#figure5-2)所示。
- en: '![f05002](Images/f05002.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![f05002](Images/f05002.png)'
- en: 'Figure 5-2: Disabled protocol dissector in Enabled Protocols window in Wireshark'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-2：Wireshark 中“已启用协议”窗口中的禁用协议解析器
- en: 'Now try looking for the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试查找以下内容：
- en: '**The first bytes in the message.** Sometimes the first bytes in the initial
    connection handshake or messages are magic bytes that provide a way to quickly
    identify the service.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**消息中的前几个字节。** 有时，初始连接握手或消息中的前几个字节是魔术字节，可以快速识别服务。'
- en: '**The initial connection handshake.** This is an important function of any
    protocol. It’s usually during this step that you learn about the protocol’s version
    and supported features, including security features like encryption. Replicating
    this step will also help you develop scanners to easily find these devices and
    services on networks.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始连接握手。** 这是任何协议的一个重要功能。通常在这一步，你可以了解协议的版本和支持的特性，包括加密等安全特性。复制此步骤还将帮助你开发扫描器，轻松地在网络上找到这些设备和服务。'
- en: '**Any TCP/UDP streams and common data structures used in the protocol.** Sometimes,
    you’ll identify strings in plaintext, or common data structures, such as packets
    with the length appended to the beginning of the message.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**协议中使用的任何 TCP/UDP 流和常见数据结构。** 有时，你会识别出明文字符串，或常见的数据结构，比如将长度附加到消息开头的数据包。'
- en: '**The endianness of the protocol.** Some protocols use mixed endianness, which
    can cause problems if not identified early. Endianness varies a lot from protocol
    to protocol, but it’s necessary for creating correct packets.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**协议的字节序。** 一些协议使用混合字节序，如果没有提前识别，可能会导致问题。字节序在不同协议中差异很大，但它对于创建正确的数据包是必需的。'
- en: '**The structure of the messages.** Identify different headers and message structures
    and how to initialize and close the connection.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**消息的结构。** 确定不同的头部和消息结构，以及如何初始化和关闭连接。'
- en: Prototyping and Tool Development
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原型设计与工具开发
- en: Once you’ve analyzed the protocol, you can start *prototyping*, or transforming
    the notes you gathered from your analysis into actual software that you can use
    to communicate with a service using the protocol. The prototype will confirm that
    you correctly understood the packet structure of each message type. In this phase,
    it’s important to choose a programming language that allows you to work very quickly.
    For that reason, we prefer dynamically typed scripting languages, such as Lua
    or Python. Check whether any libraries and frameworks are available that you could
    leverage to speed up development.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析完协议后，你可以开始 *原型设计*，或者将你从分析中收集到的笔记转化为实际的软件，以便用该协议与服务进行通信。原型将确认你是否正确理解了每种消息类型的数据包结构。在这个阶段，选择一种能够快速开发的编程语言非常重要。因此，我们倾向于使用动态类型脚本语言，如
    Lua 或 Python。检查是否有可用的库和框架可以帮助加速开发。
- en: If Wireshark doesn’t support the protocol, develop a dissector to help you with
    the analysis. We’ll discuss this process in the “Developing a Lua Wireshark Dissector
    for the DICOM Protocol” section later in this chapter. We’ll also use Lua for
    prototyping an Nmap Scripting Engine module to communicate with the service.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Wireshark 不支持该协议，可以开发一个解析器来帮助分析。我们将在本章稍后的“为 DICOM 协议开发 Lua Wireshark 解析器”一节中讨论这一过程。我们还将使用
    Lua 来原型化 Nmap 脚本引擎模块，以与该服务进行通信。
- en: Conducting a Security Assessment
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行安全评估
- en: 'Once you’ve concluded the analysis, confirmed your conjectures about the protocol,
    and created a working prototype to communicate with the DICOM service, you need
    to assess the protocol’s security. In addition to the general security assessment
    process described in Chapter 3, check for the following key points:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了分析，确认了关于协议的假设，并创建了一个与 DICOM 服务通信的工作原型，你需要评估协议的安全性。除了第 3 章中描述的一般安全评估过程外，还要检查以下关键点：
- en: '**Test server and client impersonation attacks.** Ideally, the client and server
    should authenticate each other, a process known as mutual authentication. If they
    don’t, it might be possible to impersonate either the client or the server. This
    behavior can have serious consequences; for example, we once performed a client-impersonation
    attack to spoof a drug library component and feed a drug infusion pump with rogue
    drug libraries. Although the two endpoints communicated over Transport Layer Security
    (TLS), this couldn’t prevent the attack, because no mutual authentication took
    place.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试服务器和客户端伪装攻击。** 理想情况下，客户端和服务器应该相互验证，这是一个称为互相认证的过程。如果没有认证，可能会伪装成客户端或服务器。这种行为可能会产生严重后果；例如，我们曾经进行过一次客户端伪装攻击，伪装成一个药品库组件，并向药品输注泵注入恶意药品库。尽管两个端点通过传输层安全（TLS）通信，但这无法防止攻击，因为没有进行互认证。'
- en: '**Fuzz the protocol and check for flooding attacks.** Also, attempt to replicate
    crashes and identify bugs. Fuzzing is the process of automatically supplying malformed
    input to a system with the end goal of finding implementation bugs. Most of the
    time, this will cause the system to crash. The more complex the protocol, the
    higher the chances of finding memory corruption flaws. DICOM (analyzed later in
    this chapter) is a perfect example. Given its complexity, it’s possible to find
    buffer overflows and other security problems in different implementations. In
    flooding attacks, attackers send the system a large number of requests to exhaust
    the system’s resources, causing the system to become unresponsive. A typical example
    of this is the TCP SYN flood attack, which you can mitigate using SYN cookies.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模糊测试协议并检查洪水攻击。** 同时，尝试复制崩溃并识别漏洞。模糊测试是自动向系统提供格式错误的输入，最终目标是发现实现中的缺陷。大多数情况下，这会导致系统崩溃。协议越复杂，发现内存损坏漏洞的可能性越大。DICOM（本章稍后分析）就是一个完美的例子。由于其复杂性，有可能在不同的实现中发现缓冲区溢出和其他安全问题。在洪水攻击中，攻击者向系统发送大量请求，以耗尽系统资源，导致系统无法响应。典型的例子是
    TCP SYN 洪水攻击，你可以通过 SYN cookies 来缓解该攻击。'
- en: '**Check for encryption and signing.** Is the data confidential? Can we assure
    the data integrity? How strong are the cryptographic algorithms used? We’ve seen
    cases where vendors implemented their own custom cryptographic algorithms, and
    it was always a disaster. In addition, many network protocols don’t require any
    digital signing, which provides message authentication, data integrity, and nonrepudiation.
    For example, DICOM doesn’t employ digital signing unless it’s used over a secure
    protocol like Transport Layer Security (TLS), which is susceptible to man-in-the-middle
    attacks.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查加密和签名。** 数据是否保密？我们能否保证数据完整性？所使用的加密算法有多强大？我们曾见过一些供应商实现了自定义的加密算法，结果总是灾难性的。此外，许多网络协议并不要求任何数字签名，而数字签名可以提供消息认证、数据完整性和不可否认性。例如，DICOM
    除非在安全协议（如传输层安全性 TLS）上使用，否则不会使用数字签名，而这也容易受到中间人攻击。'
- en: '**Test for downgrade attacks.** These are cryptographic attacks on the protocol
    that force the system to use a lower-quality, more insecure mode of operation
    (for example, one that sends cleartext data). Examples include the Padding Oracle
    on Downgraded Legacy Encryption (POODLE) attack on Transport Layer Security/Secure
    Sockets Layer (TLS/SSL). In this attack, a man-in-the-middle attacker forces clients
    to fall back on SSL 3.0 and exploits a design flaw to steal cookies or passwords.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试降级攻击。** 这些是针对协议的加密攻击，迫使系统使用质量较低、更不安全的操作模式（例如，发送明文数据）。例如，传输层安全协议/安全套接层（TLS/SSL）上的填充
    Oracle 降级遗留加密（POODLE）攻击。在这种攻击中，中间人攻击者强迫客户端回退到 SSL 3.0，并利用设计缺陷窃取 cookies 或密码。'
- en: '**Test for amplification attacks.** These attacks are caused when the protocol
    has functions whose response is considerably larger than the request, because
    attackers can abuse these functions to cause a denial of service. An example of
    this is the mDNS reflection DDoS attack, where some mDNS implementations responded
    to unicast queries that originated from sources outside the local-link network.
    We’ll explore mDNS in Chapter 6\.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试放大攻击。** 当协议具有响应比请求大得多的功能时，就会发生这种攻击，因为攻击者可以滥用这些功能造成服务拒绝攻击。一个例子是 mDNS 反射
    DDoS 攻击，在这种攻击中，一些 mDNS 实现响应来自本地链路网络外部源的单播查询。我们将在第六章探讨 mDNS。'
- en: Developing a Lua Wireshark Dissector for the DICOM Protocol
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 DICOM 协议开发 Lua Wireshark 解码器
- en: This section shows you how to write a dissector that you can use with Wireshark.
    When auditing network protocols used by IoT devices, it’s crucial we understand
    how the communication is happening, how the messages are formed, and what functions,
    operations, and security mechanisms are involved. Then we can start altering data
    flows to find vulnerabilities. To write our dissector, we’ll use Lua; it allows
    us to quickly analyze captured network communications with a small amount code.
    We’ll go from seeing blobs of information to readable messages by contributing
    just a few lines of code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本节向你展示如何编写一个可以与 Wireshark 一起使用的解码器。在审计物联网设备使用的网络协议时，理解通信方式、消息的构成以及涉及的功能、操作和安全机制至关重要。然后，我们可以开始修改数据流以寻找漏洞。为了编写解码器，我们将使用
    Lua；它允许我们通过少量代码快速分析捕获的网络通信。通过贡献几行代码，我们将从查看信息块到查看可读的消息。
- en: For this exercise, we’ll only focus on the subset of functions needed to process
    DICOM A-type messages (discussed in the next section). Another detail to note
    when writing Wireshark dissectors for TCP in Lua is that packets can be fragmented.
    Also, depending on factors like packet retransmissions, out of order errors, or
    Wireshark configurations limiting the packet size captures (the default capture
    packet size limit is 262,144 bytes), we might have less or more than one message
    in a TCP segment. Let’s ignore this for now and focus on the A-ASSOCIATE requests,
    which will be enough to identify DICOM services when we write a scanner. If you
    want to learn more about how to deal with TCP fragmentation, see the full resulting
    example file *orthanc.lua* distributed with this book’s materials or go to [https://nostarch.com/practical-iot-hacking/](https://nostarch.com/practical-iot-hacking/).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将只关注处理 DICOM A 类型消息所需的函数子集（将在下一节讨论）。另一个需要注意的细节是，当使用 Lua 编写 Wireshark
    解码器处理 TCP 时，数据包可能会被分段。此外，考虑到数据包重传、乱序错误或 Wireshark 配置限制了数据包大小（默认捕获数据包大小限制为 262,144
    字节），我们可能会在一个 TCP 段中得到比一个消息更多或更少的数据。现在我们暂时忽略这个问题，专注于 A-ASSOCIATE 请求，当我们编写扫描器时，这足以识别
    DICOM 服务。如果你想了解如何处理 TCP 分段，请查看本书材料中分发的完整示例文件 *orthanc.lua*，或者访问 [https://nostarch.com/practical-iot-hacking/](https://nostarch.com/practical-iot-hacking/)。
- en: Working with Lua
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Lua
- en: Lua is a scripting language for creating expandable or scriptable modules in
    many important security projects, such as Nmap, Wireshark, and even commercial
    security products like NetMon from LogRhythm. Some of the products you use daily
    are likely running Lua. Many IoT devices also use Lua because of its small binary
    size and well-documented API, which makes it easy to use to extend projects in
    other languages like C, C++, Erlang, and even Java. This makes Lua perfect for
    embedding into applications. You’ll learn how to represent and work with data
    in Lua, and how popular software such as Wireshark and Nmap use Lua to extend
    their capabilities for traffic analysis, network discovery, and exploitation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 是一种脚本语言，用于在许多重要的安全项目中创建可扩展或可脚本化的模块，例如 Nmap、Wireshark 以及像 LogRhythm 的 NetMon
    这样的商业安全产品。你每天使用的一些产品可能就在运行 Lua。许多物联网设备也使用 Lua，因为它具有小巧的二进制文件和良好的 API 文档，使其易于与 C、C++、Erlang，甚至
    Java 等其他语言一起使用，扩展项目。这使得 Lua 非常适合嵌入到应用程序中。你将学习如何在 Lua 中表示和处理数据，以及 Wireshark 和 Nmap
    等流行软件如何使用 Lua 扩展其流量分析、网络发现和利用功能。
- en: Understanding the DICOM Protocol
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 DICOM 协议
- en: 'DICOM is a nonproprietary protocol developed by the American College of Radiology
    and National Electrical Manufacturers Association. It has become the international
    standard for transferring, storing, and processing medical imaging information.
    Although DICOM isn’t proprietary, it’s a good example of a network protocol implemented
    in many medical devices, and traditional network security tools don’t support
    it very well. DICOM over TCP/IP communications are two-way: a client requests
    an action and the server performs it, but they can switch their roles, if necessary.
    In DICOM terminology, the client is called Service Call User (SCU) and the server
    is called the Service Call Provider (SCP).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: DICOM是由美国放射学会和国家电气制造商协会开发的非专有协议。它已成为传输、存储和处理医学影像信息的国际标准。尽管DICOM不是专有的，但它是许多医疗设备中实现的网络协议的一个典型例子，而传统的网络安全工具对其支持并不好。DICOM通过TCP/IP进行的通信是双向的：客户端请求一个操作，服务器执行它，但如果需要，它们可以交换角色。在DICOM术语中，客户端称为服务调用用户（SCU），服务器称为服务调用提供者（SCP）。
- en: Before writing any code, let’s examine some important DICOM messages and the
    protocol structure.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何代码之前，让我们先检查一些重要的DICOM消息和协议结构。
- en: C-ECHO Messages
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C-ECHO消息
- en: '*DICOM C-ECHO* messages exchange information about the calling and called applications,
    entities, versions, UIDs, names, and roles, among other details. We commonly call
    them DICOM *pings*, because they’re used to determine whether a DICOM service
    provider is online. A C-ECHO message uses several *A-type messages*, so we’ll
    be looking for these in this section. The first packet a C-ECHO operation sends
    is an *A-ASSOCIATE request message*, which is sufficient to identify a DICOM service
    provider. From the A-ASSOCIATE response, you can obtain information about the
    service.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*DICOM C-ECHO*消息交换关于调用和被调用应用程序、实体、版本、UID、名称和角色等信息。我们通常称它们为DICOM *ping*，因为它们用于确定DICOM服务提供者是否在线。C-ECHO消息使用多个*A类型消息*，所以我们将在本节中寻找这些消息。C-ECHO操作发送的第一个包是*A-ASSOCIATE请求消息*，它足以识别一个DICOM服务提供者。从A-ASSOCIATE响应中，你可以获得关于该服务的信息。'
- en: A-Type Protocol Data Units (PDUs)
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A类型协议数据单元（PDU）
- en: 'There are seven kinds of A-type messages used in C-ECHO messages:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在C-ECHO消息中使用了七种A类型消息：
- en: '**A-ASSOCIATE request (A-ASSOCIATE-RQ):** Requests sent by the client to establish
    a DICOM connection'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A-ASSOCIATE请求（A-ASSOCIATE-RQ）：** 客户端发送的请求，用于建立DICOM连接'
- en: '**A-ASSOCIATE accept (A-ASSOCIATE-AC):** Responses sent by the server to accept
    a DICOM A-ASSOCIATE request'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A-ASSOCIATE接受（A-ASSOCIATE-AC）：** 服务器发送的响应，用于接受DICOM A-ASSOCIATE请求'
- en: '**A-ASSOCIATE reject (A-ASSOCIATE-RJ):** Responses sent by the server to reject
    a DICOM A-ASSOCIATE request'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A-ASSOCIATE拒绝（A-ASSOCIATE-RJ）：** 服务器发送的响应，用于拒绝DICOM A-ASSOCIATE请求'
- en: '**(P-DATA-TF):** Data packets sent by server and client'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(P-DATA-TF)：** 服务器和客户端发送的数据包'
- en: '**A-RELEASE request (A-RELEASE-RQ):** Requests sent by the client to close
    a DICOM connection'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A-RELEASE请求（A-RELEASE-RQ）：** 客户端发送的请求，用于关闭DICOM连接'
- en: '**A-RELEASE response (A-RELEASE-RP PDU):** Responses sent by the server to
    acknowledge the A-RELEASE request'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A-RELEASE响应（A-RELEASE-RP PDU）：** 服务器发送的响应，用于确认A-RELEASE请求'
- en: '**A-ASSOCIATE abort (A-ABORT PDU):** Responses sent by the server to cancel
    the A-ASSOCIATE operation'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A-ASSOCIATE中止（A-ABORT PDU）：** 服务器发送的响应，用于取消A-ASSOCIATE操作'
- en: These PDUs all start with a similar packet structure. The first part is a one-byte
    unsigned integer in Big Endian that indicates the PDU type. The second part is
    a one-byte reserved section set to 0x0\. The third part is the PDU length information,
    a four-byte unsigned integer in Little Endian. The fourth part is a variable-length
    data field. [Figure 5-3](#figure5-3) shows this structure.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些PDU都以类似的包结构开始。第一部分是一个字节的无符号整数（Big Endian），表示PDU类型。第二部分是一个字节的保留区域，设置为0x0。第三部分是PDU长度信息，一个四字节的无符号整数（Little
    Endian）。第四部分是一个可变长度的数据字段。[图5-3](#figure5-3)展示了这个结构。
- en: '![f05003](Images/f05003.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![f05003](Images/f05003.png)'
- en: 'Figure 5-3: The structure of a DICOM PDU'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-3：DICOM PDU的结构
- en: Once we know the message structure, we can start reading and parsing DICOM messages.
    Using the size of each field, we can calculate offsets when defining fields in
    our prototypes to analyze and communicate with DICOM services.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了消息结构，就可以开始读取和解析DICOM消息。通过每个字段的大小，我们可以计算偏移量，在定义原型字段时用于分析和与DICOM服务进行通信。
- en: Generating DICOM Traffic
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成DICOM流量
- en: 'To follow along with this exercise, you need to set up a DICOM server and client.
    *Orthanc* is a robust, open source DICOM server that runs on Windows, Linux, and
    macOS. Install it on your system, make sure the configuration file has the `DicomServerEnabled`
    flag enabled, and run the Orthanc binary. If everything goes smoothly, you should
    then have a DICOM server running on TCP port 4242 (the default port). Enter the
    `orthanc` command to see the following logs describing configuration options:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随这个练习，你需要设置一个 DICOM 服务器和客户端。*Orthanc* 是一个强大且开源的 DICOM 服务器，支持 Windows、Linux
    和 macOS。将其安装到你的系统上，确保配置文件中启用了 `DicomServerEnabled` 标志，并运行 Orthanc 可执行文件。如果一切顺利，你应该会在
    TCP 端口 4242（默认端口）上启动 DICOM 服务器。输入 `orthanc` 命令，可以看到以下描述配置选项的日志：
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you don’t want to install Orthanc to follow along, you can find sample packet
    captures in the online resources for this book or at the Wireshark Packet Sample
    Page for DICOM.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想安装 Orthanc 来进行本教程，你可以在本书的在线资源或 Wireshark DICOM 数据包示例页面中找到示例数据包捕获文件。
- en: Enabling Lua in Wireshark
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Wireshark 中启用 Lua
- en: Before jumping into the code, make sure you’ve installed Lua and enabled it
    in your Wireshark installation. You can check whether it’s available in the “About
    Wireshark” window, as shown in [Figure 5-4](#figure5-4).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写代码之前，确保你已经安装了 Lua 并在 Wireshark 安装中启用了它。你可以在“关于 Wireshark”窗口中检查它是否可用，如[图
    5-4](#figure5-4)所示。
- en: '![f05004](Images/f05004.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![f05004](Images/f05004.png)'
- en: 'Figure 5-4: The About Wireshark window shows that Lua is supported'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-4：关于 Wireshark 窗口显示 Lua 已被支持
- en: 'The Lua engine is disabled by default. To enable it, set the boolean variable
    `disable_lua` to `false` in the *init.lua* file in your Wireshark installation
    directory:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 引擎默认是禁用的。要启用它，需要在 Wireshark 安装目录下的 *init.lua* 文件中将布尔变量 `disable_lua` 设置为
    `false`：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After checking whether it’s available and enabling Lua, double-check that Lua
    support is working correctly by writing a test script and then running it as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查并启用 Lua 后，再次通过编写测试脚本并运行它来确认 Lua 支持是否正常工作，运行方式如下：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we include a simple print statement (like the line `print "Hello from Lua")`
    in the test file, we should see the output before the capture begins.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在测试文件中包括一个简单的打印语句（例如 `print "Hello from Lua"`），我们应该会在捕获开始前看到输出。
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: On Windows, you might not see output if you use a regular print statement. But
    the `report_failure()` function will open a window containing your message, so
    it’s a good alternative.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，如果使用常规的打印语句，可能不会看到输出。但 `report_failure()` 函数会打开一个窗口，显示你的消息，因此这是一个不错的替代方案。
- en: Defining the Dissector
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义解码器
- en: 'Let’s define our new protocol dissector using the `Proto(name, description)`
    function. As mentioned earlier, this dissector will specifically identify DICOM
    A-type messages (one of the seven messages listed earlier):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `Proto(name, description)` 函数定义新的协议解码器。如前所述，这个解码器将专门识别 DICOM A 型消息（前面列出的七种消息之一）：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we define the header fields in Wireshark to match the DICOM PDU structure
    discussed previously with the help of the `ProtoField` class:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义 Wireshark 中的头字段，以匹配前面讨论的 DICOM PDU 结构，借助 `ProtoField` 类：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We use these ProtoFields to add items to the dissection tree. For our dissector,
    we’ll call `ProtoField` twice: once to create the one-byte unsigned integer to
    store the PDU type 1 and a second time for two bytes to store the message length
    2. Note how we assigned a table of values for PDU types. Wireshark will automatically
    display this information. Then we set our protocol dissector fields 3 to a Lua
    table containing our ProtoFields.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这些 ProtoFields 将项目添加到解码树中。对于我们的解码器，我们会调用两次 `ProtoField`：第一次创建一个用于存储 PDU
    类型 1 的单字节无符号整数，第二次创建一个用于存储消息长度 2 的两字节数据。注意我们为 PDU 类型分配了一个值表。Wireshark 将自动显示这些信息。然后，我们将协议解码器字段
    3 设置为包含我们 ProtoFields 的 Lua 表。
- en: Defining the Main Protocol Dissector Function
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义主协议解码器函数
- en: 'Next, we declare our main protocol dissector function, `dissector()`, which
    has three arguments: a buffer for Wireshark to dissect, packet information, and
    a tree that displays protocol information.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明主协议解码器函数`dissector()`，它有三个参数：Wireshark 用来解码的缓冲区、数据包信息和显示协议信息的树形结构。
- en: In this `dissector()` function, we’ll dissect our protocol and add the ProtoFields
    we defined earlier to the tree containing our protocol information.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `dissector()` 函数中，我们将解码我们的协议，并将之前定义的 ProtoFields 添加到包含协议信息的树形结构中。
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We set the `protocol` field to the protocol name we defined in `dicom_protocol.name`
    1. For each item we want to add, we use either `add_le()` for Big-Endian data
    or `add()` for Little Endian, along with a `ProtoField` and the buffer range to
    dissect.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `protocol` 字段设置为我们在 `dicom_protocol.name` 中定义的协议名称 1。对于我们要添加的每一项，我们使用 `add_le()`
    来处理大端数据，或者使用 `add()` 来处理小端数据，并配合 `ProtoField` 和要解码的缓冲区范围。
- en: Completing the Dissector
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完善解码器
- en: The `DissectorTable` holds a table of subdissectors for the protocol, shown
    through the Decode dialog in Wireshark.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`DissectorTable` 保存协议的子解码器表，通过 Wireshark 的 Decode 对话框显示。'
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To complete the dissector, we simply add our dissector to the `DissectorTable`
    for TCP ports at port 4242\.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成解码器，我们只需要将我们的解码器添加到 TCP 端口的 `DissectorTable` 中，端口号为 4242\。
- en: '[Listing 5-1](#listing5-1) shows the dissector in its entirety.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-1](#listing5-1) 显示了解码器的完整代码。'
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 5-1: The completed DICOM A-type message dissector'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-1：完成的 DICOM A 类型消息解码器
- en: We enable this dissector by putting the *.lua* file inside Wireshark’s plug-in
    directory and then reloading Wireshark. Then, when we analyze a DICOM capture,
    we should see the `pduType` byte and message length displayed under the DICOM
    PDU column we defined in our `tree:add()` call. [Figure 5-5](#figure5-5) shows
    this in Wireshark. You can use the `dicom-a.message_length` and `dicom-a.pdu_type`
    filters we defined 1 to filter traffic, too.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将 *.lua* 文件放入 Wireshark 的插件目录中并重新加载 Wireshark 来启用这个解码器。然后，当我们分析 DICOM 捕获时，我们应该看到在我们定义的
    `tree:add()` 调用下，DICOM PDU 列中显示 `pduType` 字节和消息长度。[图 5-5](#figure5-5) 展示了在 Wireshark
    中的显示。你也可以使用我们定义的 `dicom-a.message_length` 和 `dicom-a.pdu_type` 过滤器 1 来过滤流量。
- en: '![f05005](Images/f05005.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![f05005](Images/f05005.png)'
- en: 'Figure 5-5: The DICOM dissector in Lua for A-type messages in Wireshark'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-5：Wireshark 中 Lua 编写的 DICOM A 类型消息解码器
- en: Now we can clearly identify the PDU type and message length in DICOM packets.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以清楚地识别 DICOM 包中的 PDU 类型和消息长度。
- en: Building a C-ECHO Requests Dissector
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 C-ECHO 请求解码器
- en: When we analyze a C-ECHO request with our new dissector, we should see that
    it’s composed of different A-type messages, like those shown in [Figure 5-5](#figure5-5).
    The next step is to analyze the data contained in these DICOM packets.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用新的解码器分析 C-ECHO 请求时，我们应该看到它由不同的 A 类型消息组成，如 [图 5-5](#figure5-5) 所示。下一步是分析这些
    DICOM 包中包含的数据。
- en: To show how we can handle strings in our Lua dissector, let’s add some code
    to our dissector to parse an A-ASSOCIATE message. [Figure 5-6](#figure5-6) shows
    the structure of an A-ASSOCIATE request.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示我们如何在 Lua 解码器中处理字符串，让我们添加一些代码到解码器中，以解析 A-ASSOCIATE 消息。[图 5-6](#figure5-6)
    显示了 A-ASSOCIATE 请求的结构。
- en: '![f05006](Images/f05006.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![f05006](Images/f05006.png)'
- en: 'Figure 5-6: The structure of an A-ASSOCIATE request'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-6：A-ASSOCIATE 请求的结构
- en: Notice the 16-byte-long called and calling application entity titles. An *application
    entity title* is a label that identifies a service provider. The message also
    includes a 32-byte-long reserved section that should be set to 0x0 and variable-length
    items, including an Application Context item, Presentation Context items, and
    a User Info item.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到被叫和叫叫应用实体标题的 16 字节长度。*应用实体标题* 是标识服务提供者的标签。该消息还包括一个 32 字节长的保留部分，应该设置为 0x0，并且包含可变长度的项目，包括一个应用上下文项目、展示上下文项目和用户信息项目。
- en: Extracting the String Values of the Application Entity Titles
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取应用实体标题的字符串值
- en: 'Let’s start by extracting the message’s fixed-length fields, including the
    string values of the calling and called application entity titles. This is useful
    information; often, services lack authentication, so if you have the correct application
    entity title, you can connect and start issuing DICOM commands. We can define
    new ProtoField objects for our A-ASSOCIATE request message with the following
    code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从提取消息的固定长度字段开始，包括叫叫和被叫应用实体标题的字符串值。这是有用的信息；通常，服务缺乏身份验证，因此，如果你有正确的应用实体标题，就可以连接并开始发出
    DICOM 命令。我们可以通过以下代码为我们的 A-ASSOCIATE 请求消息定义新的 ProtoField 对象：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To extract the string values of called and calling application entity titles,
    we use the ProtoField `ProtoField.string` function.``We pass it a name to use
    in the filters 1, an optional name to display in the tree 2, the display format
    (either `base.ASCII` or `base.UNICODE`), and an optional description field.``
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取被叫和叫叫应用实体标题的字符串值，我们使用 ProtoField 的 `ProtoField.string` 函数。``我们传递给它一个用于过滤器
    1 的名称、一个可选的名称用于在树形结构中显示 2、显示格式（`base.ASCII` 或 `base.UNICODE`），以及一个可选的描述字段.``
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
