- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Complex Data Types
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂数据类型
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In this chapter, we’ll move beyond arrays and simple types to create more complex
    data types. We’ll start with a simple `enum` that defines a named list of items.
    Then we’ll look at structures and unions, which hold values of different types,
    accessed by name (unlike arrays, which contain values of a single type accessed
    by number or index). To make a custom data type, we’ll combine enums, structures,
    and unions. In addition, we’ll explore how structures are used in embedded programming.
    Finally, we’ll take a look at `typedef`, which allows us to define our own data
    type from existing types.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将超越数组和简单类型，创建更复杂的数据类型。我们将从一个简单的`enum`开始，它定义了一个命名的项列表。然后我们将研究结构体和联合体，它们包含不同类型的值，并通过名称访问（不同于数组，它包含一个类型的值，并通过数字或索引访问）。为了创建一个自定义数据类型，我们将组合使用枚举、结构体和联合体。此外，我们还将探讨结构体在嵌入式编程中的应用。最后，我们将介绍`typedef`，它允许我们从现有类型定义自己的数据类型。
- en: Enums
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: 'An *enumerated type*, or `enum`, is a data type that allows us to define a
    named list of items. For example, if we want to store a limited set of colors
    in a variable, we could enter the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*枚举类型*，或称`enum`，是一种数据类型，允许我们定义一个命名项的列表。例如，如果我们想在变量中存储一个有限的颜色集合，可以这样写：'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Although this will work, we would still need to keep track of the various colors.
    Fortunately, C will do that for us if we use an `enum`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这会有效，但我们仍然需要跟踪各种颜色。幸运的是，如果我们使用`enum`，C语言会为我们完成这项工作：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With `enum`, C does the bookkeeping for us. If we have only three colors, that’s
    not much of a problem. However, the X Window System has more than 750 named colors.
    Keeping track of all those numbers is a nontrivial process.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`enum`，C语言为我们做了记录工作。如果我们只有三种颜色，那问题不大。然而，X Window系统有超过750种命名颜色。追踪这些数字是一个不小的任务。
- en: 'C tends to be a bit loose when it comes to types. Internally, C assigns `COLOR_RED`,
    `COLOR_BLUE`, and `COLOR_GREEN` the integer values of 0, 1, and 2, respectively.
    We normally don’t care about that, but sometimes this assignment surfaces. For
    example, this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: C语言在类型方面比较宽松。内部，C会分别将`COLOR_RED`、`COLOR_BLUE`和`COLOR_GREEN`赋值为整数0、1和2。我们通常不在意这一点，但有时这种赋值会浮现出来。例如，以下代码：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'will print the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 将打印出以下内容：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Also, C does not type-check `enum` assignments. For example, the following
    statement will not generate an error or warning:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，C语言不会对`enum`赋值进行类型检查。例如，以下语句不会生成错误或警告：
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our `enum` defines three colors, so the legal numbers for colors are 0, 1, and
    2—not 33\. This can be a problem.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`enum`定义了三种颜色，所以合法的颜色数字是0、1和2——而不是33。这可能会成为一个问题。
- en: Suppose we write a function to print the color stored in `colorIWant`. What
    will users think when they see the following output?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们写一个函数来打印存储在`colorIWant`中的颜色。当用户看到以下输出时，他们会怎么想？
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Printing an incorrect answer like this gives the user a good indication that
    your program is broken. You can give a better one if you use the `enum` value
    to index an array. Here’s an example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样打印一个错误的答案会让用户很好地意识到你的程序出了问题。如果你使用`enum`值来索引一个数组，就可以给出更好的结果。以下是一个例子：
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now if `colorIWant` is 33, the program will print:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果`colorIWant`是33，程序将打印：
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Your results may vary, depending on what data there is in element 33 of a three-element
    array.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果可能会有所不同，这取决于三元素数组中的元素33的内容。
- en: Preprocessor Tricks and Enums
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预处理器技巧与枚举
- en: In this section, you’ll learn how to use some advanced preprocessor directives
    to make dealing with enums a little easier. First, I want to say that 999 times
    out of 1,000, using a clever trick will cause more trouble than it’s worth. Simple
    and clear is almost always better than complex and clever. This situation is one
    of the few exceptions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用一些高级预处理器指令，使得处理枚举变得更容易。首先，我想说的是，千百次中，使用巧妙的技巧带来的麻烦通常多于它的好处。简单明了几乎总比复杂巧妙要好。这种情况是少数几个例外之一。
- en: Let’s take a look at some code that defines colors and the names of colors.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一段代码，它定义了颜色和颜色名称。
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This example has two items that depend on each other: `colorType` and `colorNames`.
    The programmer who wrote it was nice enough to put in a comment indicating that
    those two items are linked, and the two items are actually defined next to each
    other. (Sometimes two items that depend on each other can be in different files
    without comments indicating the linkage.)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例有两个相互依赖的项：`colorType`和`colorNames`。编写这段代码的程序员很贴心地加了注释，指明这两个项是相关的，而且它们实际上是紧挨着定义的。（有时候，两个相互依赖的项可能在不同的文件中，而没有任何指示它们关联的注释。）
- en: 'As programmers, we want our code to be as simple as possible. Having two different
    items that must be updated simultaneously is not ideal. We can solve this problem
    through the clever use of the preprocessor:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们希望代码尽可能简单。需要同时更新的两个不同项并不理想。我们可以通过巧妙使用预处理器来解决这个问题：
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s start with the first definition:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从第一个定义开始：
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The backslash (`\`) tells the C preprocessor that the line is continued. We’ve
    put them all in the same column, so it’s obvious if we accidentally omit one.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠（`\`）告诉C预处理器该行是继续的。我们将它们放在同一列中，这样如果我们不小心漏掉一个就很容易发现。
- en: 'Now everywhere we use `COLOR_LIST`, the C preprocessor will turn it into the
    following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当我们使用`COLOR_LIST`时，C预处理器会将其转换为以下内容：
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When we define the `enum`, we need our list to be the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义`enum`时，我们需要我们的列表如下：
- en: '[PRE12]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We get this by defining `DEFINE_ITEM` to output only the item name:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义`DEFINE_ITEM`只输出项名称，我们得到这个：
- en: '[PRE13]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This means that the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着下面的代码：
- en: '[PRE14]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'gets turned into this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 变成了这个：
- en: '[PRE15]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we erase the definition of `DEFINE_ITEM` since we don’t need it anymore
    for the `enum` definition:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们删除`DEFINE_ITEM`的定义，因为我们不再需要它来进行`enum`定义：
- en: '[PRE16]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we define the `colorNames` list by redefining the `DEFINE_ITEM` macro:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过重新定义`DEFINE_ITEM`宏来定义`colorNames`列表：
- en: '[PRE17]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The hash mark (`#`) tells the preprocessor to change the token that follows
    into a string, so now `COLOR_LIST` will expand into the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 井号（`#`）告诉预处理器将后续的标记转换为字符串，因此现在`COLOR_LIST`将展开为以下内容：
- en: '[PRE18]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the full definition for `colorNames`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`colorNames`的完整定义：
- en: '[PRE19]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The comments are a vital part of this definition. Any time you use a cute trick
    like this, document it well so that the poor person maintaining this code has
    some idea of what you did.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是这个定义的重要部分。每当你使用这样的巧妙技巧时，要做好文档，以便维护此代码的可怜的人能知道你做了什么。
- en: Structures
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体
- en: 'The C *structure* (`struct`) allows us to group together multiple items of
    different types. The items, called *fields*, are identified by name. It’s different
    from an array that defines a data structure containing items of the same type,
    and the items, called *elements*, are indexed by number. For example, consider
    this structure that groups together information describing a house:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: C语言的*结构体*（`struct`）允许我们将多种不同类型的项组合在一起。这些项被称为*字段*，并通过名称进行标识。它与定义包含相同类型项的数据结构的数组不同，数组中的项称为*元素*，并通过数字索引。例如，考虑以下将描述房屋信息的结构体：
- en: '[PRE20]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To access an element of a structure, use the format `variable.field`, with
    a dot in the middle. For example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问结构体的元素，可以使用`变量.字段`的格式，中间用点号分隔。例如：
- en: '[PRE21]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following program shows how to put this all together:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序展示了如何将这一切结合在一起：
- en: '**struct.c**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**struct.c**'
- en: '[PRE22]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let’s debug this program in the STM32 Workbench (see [Figure 8-1](#figure8-1)).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在STM32工作台中调试这个程序（参见[图 8-1](#figure8-1)）。
- en: '![f08001](image_fi/501621c08/f08001.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![f08001](image_fi/501621c08/f08001.png)'
- en: 'Figure 8-1: The `struct` variable display'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-1：`struct`变量显示
- en: Stopping on line 20, we can now see the structure in the variable list. Clicking
    the + icon expands the structure to show what’s in it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在第20行停止，我们现在可以在变量列表中看到结构体。点击 + 图标可以展开结构体，显示其内容。
- en: Structures in Memory
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存中的结构体
- en: Let’s take a look at how the C compiler will lay out this structure in memory.
    The compiler needs to allocate 1 byte for `stories` (`uint8_t`), 1 byte for `bedrooms`
    (`uint8_t`), and 4 bytes for `squareFeet` (`uint32_t`). Logically, the layout
    should look like [Table 8-1](#table8-1).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看C编译器将如何在内存中布局这个结构体。编译器需要为`stories`（`uint8_t`）分配1个字节，为`bedrooms`（`uint8_t`）分配1个字节，为`squareFeet`（`uint32_t`）分配4个字节。逻辑上，布局应该像[表
    8-1](#table8-1)所示。
- en: 'Table 8-1: Structure Layout'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-1：结构体布局
- en: '| **Offset** | **Type** | **Field** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **偏移量** | **类型** | **字段** |'
- en: '| --- | --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | `uint8_t` | `stories` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 0 | `uint8_t` | `stories` |'
- en: '| 1 | `uint8_t` | `bedrooms` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `uint8_t` | `bedrooms` |'
- en: '| 2 | `uint32_t` | `squareFeet` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `uint32_t` | `squareFeet` |'
- en: '| 3 |  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 3 |  |'
- en: '| 4 |  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 4 |  |'
- en: '| 5 |  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 5 |  |'
- en: 'From [Table 8-1](#table8-1), we see that the structure takes up 6 bytes. However,
    when we run the program, we see the following output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [表 8-1](#table8-1) 中，我们可以看到该结构占用了 6 字节。然而，当我们运行程序时，看到以下输出：
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Where did the other 2 bytes come from?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另外 2 个字节来自哪里？
- en: 'The problem is memory design. On the ARM chip (and many others), memory is
    organized as a series of 32-bit integers aligned on a 4-byte boundary, like so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在内存设计上。在 ARM 芯片（以及许多其他芯片）中，内存是按一系列 32 位整数进行组织的，并且这些整数是对齐在 4 字节边界上的，像这样：
- en: '| `0x10000` | 32 bits |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `0x10000` | 32 位 |'
- en: '| `0x10004` | 32 bits |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `0x10004` | 32 位 |'
- en: '| `0x10008` | 32 bits |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `0x10008` | 32 位 |'
- en: '| `. . .` |  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `. . .` |  |'
- en: Let’s say we want an 8-bit byte at `0x10001`. The machine fetches 32 bits from
    `0x10000` and then throws away 24 bits, which is wasteful because extra data is
    fetched, although there is no performance hit.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要一个 8 位字节，位于 `0x10001`。计算机从 `0x10000` 获取 32 位数据，然后丢弃 24 位数据，这样做很浪费，因为额外的数据被读取了，尽管没有性能损失。
- en: 'Now let’s say we need a 32-bit integer starting at `0x10002`. Attempting to
    fetch this data directly results in an alignment exception that will abort our
    program. The computer has to do the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要一个从 `0x10002` 开始的 32 位整数。直接获取这些数据会导致对齐异常，进而中止程序。计算机必须执行以下操作：
- en: Fetch 16 bits from `0x10000`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `0x10000` 读取 16 位数据。
- en: Fetch 16 bits from `0x10004`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `0x10004` 读取 16 位数据。
- en: Combine them.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们组合起来。
- en: The internal ARM circuitry does *not* complete these steps. Instead, the compiler
    must generate multiple instructions to do the work, which isn’t good for performance.
    (We go into this in more detail later in the chapter.)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 内部 ARM 电路*并不*完成这些步骤。相反，编译器必须生成多条指令来完成这项工作，这对于性能来说并不好。（我们将在本章稍后部分详细讨论这个问题。）
- en: It would be much nicer if `squareFeet` aligned on a 4-byte boundary instead
    of a 2-byte boundary, so the compiler optimizes the layout of the structure by
    adding 2 bytes of padding. This makes the structure larger but much easier to
    deal with. [Table 8-2](#table8-2) shows the structure’s actual adjusted layout.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `squareFeet` 能够对齐到 4 字节边界，而不是 2 字节边界，那就好了，这样编译器可以通过添加 2 字节的填充来优化结构布局。这使得结构变大了，但处理起来要容易得多。[表
    8-2](#table8-2) 显示了结构的实际调整后的布局。
- en: 'Table 8-2: Padded Structure Layout'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-2：填充结构布局
- en: '| **Offset** | **Type** | **Field** |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **偏移量** | **类型** | **字段** |'
- en: '| --- | --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | `uint8_t` | `stories` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 0 | `uint8_t` | `stories` |'
- en: '| 1 | `uint8_t` | `bedrooms` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `uint8_t` | `bedrooms` |'
- en: '| 2 | `uint8_t` | (padding) |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `uint8_t` | （填充） |'
- en: '| 3 | `uint8_t` | (padding) |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 3 | `uint8_t` | （填充） |'
- en: '| 4 | `uint32_t` | `squareFeet` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 4 | `uint32_t` | `squareFeet` |'
- en: '| 5 |  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 5 |  |'
- en: '| 6 |  |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 6 |  |'
- en: '| 7 |  |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 7 |  |'
- en: This extra padding is sometimes a problem. For example, if you have a lot of
    houses and very limited memory, the padding in each house structure adds up to
    a lot of wasted space.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种额外的填充有时会成为一个问题。例如，如果你有很多房屋而且内存非常有限，那么每个房屋结构中的填充就会累积成大量浪费的空间。
- en: 'Another example is in embedded programming. I had an old, pre-iPod music device
    called the Rio that didn’t come with Linux tools to load the music onto the device,
    so I wrote some tools myself. Every data block had a header that looked something
    like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是在嵌入式编程中。我有一款旧的、iPod 发布之前的音乐设备，叫做 Rio，它没有配备 Linux 工具来将音乐加载到设备上，所以我自己写了一些工具。每个数据块都有一个像这样的头部：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When I first loaded songs on my Rio, they would play fine. But when I pressed
    Rewind to back up a few seconds, the device would go crazy and start the song
    all over again. The problem was that GCC was adding padding to the structure:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次在 Rio 上加载歌曲时，它们播放得很好。但当我按下倒带按钮倒回几秒钟时，设备就会疯掉并重新开始播放歌曲。问题在于 GCC 在结构中添加了填充：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As a result, what the Rio thought was the previous block was instead some padding
    and half the value of the previous block. No wonder the device became confused.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，Rio 认为前一个块是之前的一个块，实际上那只是一些填充和前一个块的一半值。难怪设备会变得混乱。
- en: 'The solution was to tell the compiler not to add padding with the `packed`
    attribute:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是告诉编译器不要通过 `packed` 属性添加填充：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, `__attribute__((packed))` is a GNU extension to the C language,
    and it may not work on other compilers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`__attribute__((packed))` 是 C 语言的一个 GNU 扩展，它可能在其他编译器上无法使用。
- en: Accessing Unaligned Data
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问未对齐的数据
- en: By default, the compiler will “adjust” the alignment of elements of a structure
    for efficient memory access. As we’ve seen, hardware designers sometimes have
    different ideas, and in order to get the structure to match the hardware, we have
    to include the `__attribute__((packed))` directive.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，编译器会“调整”结构体元素的对齐方式，以便高效的内存访问。正如我们所见，硬件设计师有时会有不同的想法，为了让结构体与硬件匹配，我们必须包含`__attribute__((packed))`指令。
- en: To see why the compiler makes such adjustments, let’s write a program that does
    both aligned and unaligned 32-bit accesses. The packed structure is more compact,
    but it requires more code to access the 32-bit value. The unpacked structure is
    efficient to access, but it takes up more memory.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解编译器为什么做出这样的调整，让我们编写一个程序，它同时执行对齐和未对齐的32位访问。打包结构体更加紧凑，但需要更多的代码来访问32位值。未打包结构体访问更高效，但占用更多内存。
- en: 'The following program shows how both the packed and unpacked structures are
    accessed:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序展示了如何访问打包和未打包结构体：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'First, let’s look at the code generated to fetch an aligned `uint32_t`  1 (comments
    added):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看一下获取对齐的`uint32_t` 1时生成的代码（已添加注释）：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It uses one instruction to get the address of the structure and one to get the
    value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用一条指令获取结构体的地址，并用一条指令获取值。
- en: 'Now let’s look at the unaligned fetch 2:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下未对齐的取值 2：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The unaligned fetch requires four instructions instead of the one required
    by an aligned fetch. The program must use two load instructions to get the two
    halves of the number: one shift to get the top half to the top of the register,
    and a logical OR to combine the two numbers.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 未对齐的取值需要四条指令，而对齐的取值只需要一条指令。程序必须使用两条加载指令来获取数字的两个部分：一条移位指令将高半部分移到寄存器的顶部，另一条逻辑或指令将这两个数合并。
- en: Code like this must be used every time an unaligned `uint32_t` is loaded or
    stored. You can see why the compiler might want to avoid doing that and adds padding.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每次加载或存储未对齐的`uint32_t`时，必须使用像这样的代码。你可以理解为什么编译器可能会避免这样做，并且添加填充。
- en: Structure Initialization
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构体初始化
- en: 'We can initialize structures by putting the initializer list inside curly brackets
    (`{}`). For example, the following statement declares and initializes `myHouse`
    with one statement:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将初始化列表放在花括号（`{}`）中来初始化结构体。例如，下面的语句通过一个语句声明并初始化`myHouse`：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In early versions of the language, that was the only way to initialize structures.
    Later, when C99 (the C specification finalized in 1999) came along, a new feature
    called *designated initializers* was added to let you initialize fields by name.
    Here’s an example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在语言的早期版本中，这是初始化结构体的唯一方法。后来，当C99（1999年最终确定的C语言规范）发布时，增加了一种名为*指定初始化器*的新特性，允许通过字段名称初始化。这里有一个例子：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The fields must be in the same order as they are declared in the structure.
    The GCC compiler has an extension that lets you use designated initializers using
    a different method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 字段必须按照声明时的顺序排列。GCC编译器有一个扩展，允许你使用指定初始化器，采用不同的方式：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this case, the order does not have to match the order in which the fields
    were declared.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，字段的顺序不需要与声明时的顺序匹配。
- en: Structure Assignment
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构体赋值
- en: 'C does not allow you to assign one array to another, but it does allow you
    to assign one structure to another. Here’s an example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: C语言不允许将一个数组赋值给另一个数组，但它允许将一个结构体赋值给另一个结构体。这里有一个例子：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If these were arrays, assignment would be illegal, but since they are structures,
    it works.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些是数组，赋值将是非法的，但由于它们是结构体，因此可以正常工作。
- en: Structure Pointers
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构体指针
- en: 'C’s parameter-passing mechanism uses *call by value*, meaning that if we pass
    a parameter to a procedure, it copies the value of the parameter onto the stack.
    This practice is not a problem when we have something small like a 2-byte integer,
    but most structures are not very small and actually can be quite large. When a
    structure is passed as a parameter, *the entire structure is copied onto the stack*,
    making it an expensive operation. Here’s an example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: C语言的参数传递机制使用*按值传递*，意味着如果我们将参数传递给一个过程，它会将参数的值复制到栈上。当我们传递的是像2字节整数这样的小型数据时，这种做法没有问题，但大多数结构体并不小，实际上可能非常大。当一个结构体作为参数传递时，*整个结构体都会被复制到栈上*，这使得操作变得昂贵。这里有一个例子：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: What’s going on here is that in order to perform the “call by value” parameter
    passing, the compiler must generate code to copy `aRectangle` in its entirety
    onto the stack. For larger structures, that can use a lot of stack space and take
    up a lot of time copying the data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情是，为了执行“按值传递”参数传递，编译器必须生成代码，将整个`aRectangle`复制到栈上。对于较大的结构体，这可能会占用大量栈空间，并且复制数据时耗时较长。
- en: 'It’s more efficient to pass a structure as a pointer:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指针传递结构体更高效：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this case, only the pointer (a small item) is passed as a parameter. In
    the case of the ARM compiler, this is done by putting it in a register: quick,
    easy, and no stack space used.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只有指针（一个小项）作为参数传递。以 ARM 编译器为例，它是通过将其放入寄存器来实现的：快速、简便且不占用栈空间。
- en: One of the advantages of call by value is any changes to the parameter are not
    passed back to the caller. But we didn’t make any changes, so that’s not an issue.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 按值传递的一个优点是，参数的任何更改都不会传回给调用者。但我们并没有做任何更改，所以这不是问题。
- en: When we passed parameters as pointers, we used `const` to indicate that no changes
    to the parameters were allowed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按指针传递参数时，我们使用`const`来表明不允许修改参数。
- en: 'It’s a little awkward to access a member of a structure pointer using the `(*rectangle).height`
    syntax. Because of this, C has added some syntactic sugar that allows us to use
    a shortcut—the `->` operator:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`(*rectangle).height`语法来访问结构体指针的成员有点别扭。为此，C 添加了一些语法糖，使我们可以使用简便方式——`->`操作符：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: C feels free to treat an array as a pointer and a pointer as an array. When
    an array is passed in as a parameter, the array is automatically turned into a
    pointer. When an array is specified as a procedure parameter, it is automatically
    turned into a pointer behind your back.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: C 在处理数组时可以自由地把它当作指针来使用，而指针也可以当作数组来使用。当数组作为参数传递时，数组会自动转换为指针。当数组被指定为过程参数时，它会在你不知情的情况下自动转换为指针。
- en: Saying C is “call by value” is not strictly true. It’s more precise to say,
    “C is called by value, except for arrays, which are called by pointer value.”
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 说 C 是“按值传递”并不完全正确。更精确的说法是，“C 按值传递，除了数组是按指针值传递。”
- en: Structure Naming
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构体命名
- en: 'Like many things in C, the naming of structures is not all that simple. That’s
    because in a single C structure declaration, we can define a structure name (or
    not) and a variable (or not). Here’s the general syntax for a structure definition:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 像 C 中的许多事物一样，结构体的命名并不简单。这是因为在一个 C 结构体声明中，我们可以定义结构体名称（也可以不定义）和变量（也可以不定义）。下面是结构体定义的一般语法：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let’s consider the example when we don’t have a structure name:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下没有结构体名称的例子：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This defines the `aBox` variable, but what type is `aBox`? It is a structure
    with no name, or an *anonymous structure*. Anonymous structures can be used to
    define a variable only when the structure is defined. They do not specify a structure
    name that can be used in later declarations.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了`aBox`变量，但`aBox`是什么类型呢？它是一个没有名称的结构体，或者是一个*匿名结构体*。匿名结构体只能在结构体定义时用于定义变量。它们不指定结构体名称，因此在后续声明中无法使用。
- en: 'Now let’s consider the case where we leave off the variable name:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑省略变量名的情况：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This defines a structure type but no variables. It can be used later to define
    a variable:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个结构类型，但没有定义变量。它可以在后续用来定义一个变量：
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can put in both a structure name and a variable name in the same declaration:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在同一个声明中同时定义结构体名称和变量名称：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This defines both a `box` structure and a variable `aBox`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个`box`结构和一个变量`aBox`。
- en: 'C has one more trick up its sleeve—we can have a structure definition with
    no structure name and no variable name:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: C 还有一个技巧——我们可以定义没有结构体名称和变量名称的结构体：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Because there is no structure name, we can use this only to access the variable
    defined here. But no variable is defined here, so we can’t access anything, which
    means that although it’s perfectly legal, it’s also perfectly useless.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因为没有结构体名称，我们只能用它来访问这里定义的变量。但这里并没有定义任何变量，所以我们无法访问任何内容，这意味着虽然它完全合法，但也是完全没用的。
- en: Unions
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联合体
- en: 'A `union` is like a `struct` except that instead of each field being assigned
    a different location, all the fields are stored in the same location. Here’s an
    example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`union`类似于`struct`，不同之处在于每个字段不分配不同的位置，而是所有字段都存储在同一个位置。以下是一个示例：'
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The compiler allocates 4 bytes for the `uint32_t` and *the same 4 bytes* for
    the `float`. Let’s take a look at this in action:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器为`uint32_t`分配4字节，并且*同样分配4字节*给`float`。让我们看一下它的实际表现：
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The second assignment actually changes `anInteger` to 1065353216 (0x3f800000).
    It’s a very strange integer, but as a floating point, it’s 1.0.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个赋值实际上将 `anInteger` 更改为 1065353216 (0x3f800000)。这是一个非常奇怪的整数，但作为浮点数，它是 1.0。
- en: 'Good programming practice is to use the same field name for storing and retrieving
    a value from an union. For example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的编程实践是使用相同的字段名称来存储和取出联合体中的值。例如：
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When you use different fields, the results will be different on different machines.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用不同的字段时，结果会在不同的机器上有所不同。
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this case the value of `someInt` will depend on the size of an integer, the
    size of a float, the floating-point format, and the byte order, all of which are
    processor-dependent.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`someInt` 的值将取决于整数的大小、浮点数的大小、浮点格式和字节顺序，而这些都依赖于处理器。
- en: 'Now let’s talk about the byte order problem. Let’s say you have four cards
    in your hand, numbered 1, 2, 3, and 4\. You want to put them into a row of four
    boxes in front of you. So, you take the top card and put it in the leftmost box,
    you put the next card in the box to the right of that, and so on. Your boxes now
    contain the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论字节顺序问题。假设你手上有四张卡片，编号为 1、2、3 和 4。你想把它们放进你面前的四个盒子里。所以，你把最上面的卡片放进最左边的盒子，把下一张卡片放进右边的盒子，以此类推。现在你的盒子里包含以下内容：
- en: '| 1 | 2 | 3 | 4 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 3 | 4 |'
- en: When you pick up the cards, you start at the right and put each card on top
    of the pile. The result is that you get 1, 2, 3, and 4 in order back in your hand.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拿起卡片时，你从右边开始，并将每张卡片放在堆叠的最上面。结果是，你会按顺序拿到 1、2、3 和 4。
- en: 'Now another person comes along and puts the cards in the boxes starting on
    the right side and going left. Their boxes look like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在另一个人过来了，把卡片从右边开始放入盒子，再向左放。他们的盒子看起来是这样的：
- en: '| 4 | 3 | 2 | 1 |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 3 | 2 | 1 |'
- en: They pick up the cards starting at the left and work right. Again, this person
    will wind up with 1, 2, 3, and 4 in their hand, in exactly that order.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 他们从左边开始拿起卡片，依次向右移动。同样，这个人最终会拿到 1、2、3 和 4，顺序完全一致。
- en: What I’ve just described is how two different CPU architectures will store numbers
    in memory. In some cases it will be 1, 2, 3, and 4 and in others 4, 3, 2, and
    1\. As long as you are storing and retrieving the same size number, byte order
    makes no difference.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚才描述的是两种不同的 CPU 架构如何在内存中存储数字。在某些情况下，它会是 1、2、3 和 4，而在其他情况下，它会是 4、3、2 和 1。只要存储和读取的是相同大小的数字，字节顺序就无关紧要。
- en: 'Now let’s say you want to store four cards in the boxes but retrieve only two,
    which means your boxes look like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你想把四张卡片存入盒子里，但只取出两张，这意味着你的盒子看起来是这样的：
- en: '| 1 | 2 | 3 | 4 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 3 | 4 |'
- en: When you pick up your cards, you get only 1 and 2.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拿起你的卡片时，你只会得到 1 和 2。
- en: 'However, the other person’s storage looks like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，另一个人的存储方式是这样的：
- en: '| 4 | 3 | 2 | 1 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 3 | 2 | 1 |'
- en: The leftmost *n* boxes are always used when retrieving cards, so this person
    will start at the left and grab 3 and 4, meaning they’ll get a different result.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最左边的 *n* 个盒子在取卡片时总是被使用，所以这个人将从左边开始，拿到 3 和 4，这意味着他们会得到不同的结果。
- en: This difference is caused by the two of you using a different order when storing
    and retrieving cards. The same thing happens in computers. Different computers
    store things in different orders. As a result, you are going to get different
    answers on different machines if you try and store one type of data and retrieve
    another.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个差异是因为你们两个人在存储和取出卡片时使用了不同的顺序。计算机中也发生了同样的事情。不同的计算机以不同的顺序存储数据。因此，如果你尝试存储一种数据类型并取出另一种数据类型，你将在不同的机器上得到不同的结果。
- en: Therefore, if you put something in `theValue.anInteger`, the only way you’re
    guaranteed to get consistent results is to take it out using only the `theValue.anInteger`
    field.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你将某个值放入 `theValue.anInteger`，唯一能保证获得一致结果的方式就是仅通过 `theValue.anInteger` 字段取出它。
- en: Creating a Custom Type
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义类型
- en: We’re now going to take all three of our new data types—`struct`, `union`, and
    `enum`—and combine them into one large data type in order to draw a shape on the
    screen. The shape can be a square, rectangle, circle, or triangle. Each of those
    shapes can be described differently.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将结合我们新创建的三种数据类型——`struct`、`union` 和 `enum`——将它们合并成一个大数据类型，用来在屏幕上绘制形状。这个形状可以是正方形、矩形、圆形或三角形。每种形状的描述方式不同。
- en: 'All we need to describe a square is a single side:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要描述一个正方形的单个边长：
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To describe a rectangle, we need a width and height:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要描述一个矩形，我们需要宽度和高度：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can draw a circle with only its radius:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以仅用半径画一个圆：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, to draw a triangle, we describe the base and height:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要绘制一个三角形，我们需要描述它的底边和高度：
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A generic shape type should hold any one of these, which indicates that we
    need a `union`. But in order to draw a shape, we need to know not only its description
    but also what type of shape it is. The `enum` data type was designed for a limited
    list of simple values:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通用的形状类型应该包含这些中的任何一个，这意味着我们需要一个`union`。但是，为了绘制一个形状，我们不仅需要知道它的描述，还需要知道它是什么类型的形状。`enum`数据类型是为有限的简单值列表而设计的：
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we get to define our data structure:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义我们的数据结构了：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first field is `type`, which contains the type of shape contained in the
    structure. The second field contains the `dimensions` of the shape. It’s a `union`
    because different shapes have different dimensions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字段是`type`，它包含结构体中所包含的形状类型。第二个字段包含形状的`dimensions`。它是一个`union`，因为不同的形状有不同的维度。
- en: 'The code to draw the shapes looks something like the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制形状的代码看起来像如下所示：
- en: '[PRE53]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This design pattern is fairly common in C programming: a `union` that can hold
    many different types of data and an `enum` that tells which type we actually have.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式在C编程中相当常见：一个可以容纳多种不同类型数据的`union`和一个指示我们实际拥有哪种类型的`enum`。
- en: Structures and Embedded Programming
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体与嵌入式编程
- en: In this section, we take a hardware specification and turn it into a C structure,
    using what we’ve learned so far about structures and alignment.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将硬件规范转换为C结构体，运用到我们目前所学的结构体和对齐的知识。
- en: The small computer system interface (SCSI) was designed to provide a standard
    way of transferring data to and from devices. It started in 1986 and since has
    been expanded and enhanced a great deal. It works by sending a structure called
    a command block to the device and getting back data and status messages in return.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 小型计算机系统接口（SCSI）旨在提供一种标准的方式，用于在设备之间传输数据。它始于1986年，后来经过了许多扩展和增强。它通过向设备发送一个称为命令块的结构体，并返回数据和状态信息的方式来工作。
- en: When first written, the SCSI standard defined the `READ (6)` command, which
    limited the block address to 16 bits, allowing for a disk of up to 16MB, which
    was large for the time. Of course, disk makers quickly created bigger disks, so
    the SCSI people had to create a new command to allow for a bigger drive. This
    was the `READ (10)` command, which was followed by the `READ (12)`, `READ (16)`,
    and `READ (32)` commands. The `READ (32)` command uses a 64-bit block address.
    Hopefully, it will take the disk manufacturers a little time to catch up and create
    an 8-zebibyte disk.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初，SCSI标准定义了`READ (6)`命令，该命令将块地址限制为16位，允许的最大磁盘大小为16MB，这是当时相对较大的磁盘。当然，磁盘制造商很快就生产出了更大的磁盘，因此SCSI团队不得不创建一个新命令，以支持更大的驱动器。这就是`READ
    (10)`命令，之后是`READ (12)`、`READ (16)`和`READ (32)`命令。`READ (32)`命令使用64位块地址。希望磁盘制造商能花点时间赶上，生产出8泽比字节的磁盘。
- en: '[Figure 8-2](#figure8-2) shows the command block for the `READ (10)` command.
    If we want to read data from the disk, we’ll need a C structure to contain this
    information and send it to the device.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-2](#figure8-2)显示了`READ (10)`命令的命令块。如果我们想从磁盘读取数据，我们需要一个C结构体来包含这些信息并将其发送到设备。'
- en: '![f08002](image_fi/501621c08/f08002.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![f08002](image_fi/501621c08/f08002.png)'
- en: 'Figure 8-2: The `READ (10)` command block'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-2：`READ (10)`命令块
- en: 'At first, it seems like a simple translation:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，它看起来像是一个简单的翻译：
- en: '[PRE54]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, because we’re paranoid and careful, the first thing we did in the program
    was to put in an `assert` statement to make sure our definition matches the hardware.
    An `assert` statement aborts the program if the condition is not true. If we expect
    the `read10` control block to contain 10 bytes and it doesn’t, our program has
    a big problem. And we do too, because the `assert` fails.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们比较谨慎，程序中做的第一件事就是插入一个`assert`语句，确保我们的定义与硬件匹配。如果`assert`语句的条件不为真，它将终止程序。如果我们期望`read10`控制块包含10个字节，但它并没有，那么我们的程序就会有大问题。我们也有问题，因为`assert`会失败。
- en: 'So what happened? Inspecting the structure, we see that the `lba` field (a
    `uint32`) is aligned on a 2-byte boundary. The compiler wants to put it on a 4-byte
    boundary, so it added 2 bytes of padding. We need to pack the structure:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 那么发生了什么呢？检查结构体后，我们看到`lba`字段（一个`uint32`）被对齐到了2字节边界。编译器希望将其对齐到4字节边界，因此它添加了2字节的填充。我们需要打包这个结构体：
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `packed` attribute tells GCC to not add any padding. As a result, our structure
    is inefficient, but it matches the hardware. Also, our `assert` doesn’t fail,
    so we’ve done it right.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`packed` 属性告诉 GCC 不要添加任何填充。因此，我们的结构不够高效，但它与硬件匹配。此外，我们的 `assert` 也没有失败，因此我们做得对。'
- en: typedef
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`typedef`'
- en: 'We can define our own types using the `typedef` statement. For example, the
    following statement defines a new `dimension` type:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `typedef` 语句定义我们自己的类型。例如，以下语句定义了一个新的 `dimension` 类型：
- en: '[PRE56]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This type is equivalent to an `unsigned int` and can be used like any other
    type:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 该类型等同于 `unsigned int`，可以像其他类型一样使用：
- en: '[PRE57]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The syntax of a `typedef` is similar to that of a variable declaration. It
    contains the `typedef` keyword and the name of the initial type, as well as the
    name of the defined type:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`typedef` 的语法类似于变量声明。它包含 `typedef` 关键字和初始类型的名称，以及定义类型的名称：'
- en: '[PRE58]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'One example of `typedef` can be found in the *stdint.h* file, which is included
    in many of our programs:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`typedef` 的一个例子可以在 *stdint.h* 文件中找到，该文件在许多程序中都被包含：'
- en: '[PRE59]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the early days of C, an `int` could be 16 or 32 bits, depending on the processor.
    In the early days of programming, if users wanted to use a 16-bit integer (which
    the old C standard didn’t support), they had to put something like this in their
    code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言的早期，`int` 可能是 16 位或 32 位，这取决于处理器。在编程的早期，如果用户想使用 16 位整数（旧的 C 标准不支持），他们必须在代码中写出类似以下的内容：
- en: '[PRE60]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: After years of having to define our own precise data types, the C standards
    committee created the *stdint.h* header file and made it a part of the language.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，由于需要自己定义精确的数据类型，C 标准委员会创建了 *stdint.h* 头文件，并将其纳入语言的一部分。
- en: Function Pointers and typedef
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数指针与 `typedef`
- en: 'C allows pointers to functions, which are useful when doing callbacks. For
    example, we might tell a graphics system to call a given function when a button
    is pressed. The code for that might look like the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言允许使用函数指针，这在进行回调时非常有用。例如，我们可能会告诉图形系统在按下按钮时调用给定的函数。实现这功能的代码可能如下所示：
- en: '[PRE61]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `functionToHandleButtonPress` parameter is a pointer to a function that
    returns an integer and takes a constant event pointer as its single argument.
    That sentence is a mess, and it doesn’t get any easier when we translate it to
    C:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`functionToHandleButtonPress` 参数是一个指向返回整数并接受常量事件指针作为唯一参数的函数的指针。这个句子很复杂，翻译成
    C 代码后也没有变得更容易：'
- en: '[PRE62]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The first set of parentheses is required because without it we define a function
    that returns an integer pointer:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个括号是必需的，因为如果没有它，我们定义的是一个返回整数指针的函数：
- en: '[PRE63]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Rather than remember these convoluted syntax rules, let’s simplify the syntax
    using `typedef`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与其记住这些复杂的语法规则，不如使用 `typedef` 来简化语法：
- en: '[PRE64]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This changes the definition of `registerButtonPressHandler` from:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `registerButtonPressHandler` 的定义更改为：
- en: '[PRE65]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'to this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里：
- en: '[PRE66]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `typedef` provides a way of organizing types to simplify our code, as well
    as make things clearer.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`typedef` 提供了一种组织类型的方式，以简化代码并使其更清晰。'
- en: typedef and struct
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`typedef` 和 `struct`'
- en: We’ve already seen how we can use `struct` to define a structured data type.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用 `struct` 来定义结构化数据类型。
- en: '[PRE67]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To use this structure, we must use the `struct` keyword:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此结构时，我们必须使用 `struct` 关键字：
- en: '[PRE68]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `typedef` statement allows us to avoid using the `struct` keyword:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`typedef` 语句使我们能够避免使用 `struct` 关键字：'
- en: '[PRE69]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `typedef` in this case tells C that we want to define a new `rectangle`
    type.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`typedef` 告诉 C 我们想要定义一个新的 `rectangle` 类型。
- en: Some people believe that using `typedef` to define a new structure type makes
    the code simpler and cleaner. Others prefer to use `struct` because it makes it
    obvious that a variable is a `struct`. The syntax is optional, so use whatever
    works best for you.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人认为使用 `typedef` 来定义一个新的结构类型可以使代码更简洁、更清晰。也有人喜欢使用 `struct`，因为它能明确指出一个变量是 `struct`
    类型。语法是可选的，因此可以根据自己的需求选择最适合的方式。
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter is all about organizing data. The `enum` type allows you to organize
    simple name lists without having to worry about which field gets what value. Structures
    provide a powerful tool for organizing data of different types. For embedded programmers,
    they are also useful for communicating with actual hardware devices. However,
    keep in mind that a hardware designer’s idea of how a structure is laid out can
    be different from what C thinks it should be.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要讲述如何组织数据。`enum`类型允许你组织简单的名称列表，而不必担心哪个字段对应什么值。结构体为组织不同类型的数据提供了强大的工具。对于嵌入式程序员来说，它们还在与实际硬件设备通信时非常有用。然而，请记住，硬件设计师对于结构体布局的理解可能与C语言对其的理解有所不同。
- en: While structures can hold only a fixed set of data, unions can hold multiple
    sets (just not at the same time). Between the two of them, we have a great deal
    of control over how we store data.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然结构体只能存储一组固定的数据，但联合体可以存储多个数据集（只不过不能同时存储）。通过它们，我们可以很好地控制数据存储方式。
- en: Another tool for organizing data is the `typedef` directive, which allows us
    to define our own types. It lets us represent data using familiar types instead
    of being forced to use the basic C types.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个组织数据的工具是`typedef`指令，它允许我们定义自己的数据类型。它让我们可以使用熟悉的类型来表示数据，而不必使用基本的C语言类型。
- en: Many complex data types exist, and C provides a good set of tools for managing
    them.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多复杂的数据类型，C语言提供了一整套很好的工具来管理这些类型。
- en: Programming Problems
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程问题
- en: Create a structure to hold a fraction. Then create procedures that add, subtract,
    multiply, and divide fractions. The fractions should be stored in normalized form.
    In other words, 2/4 should be stored as 1/2.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个结构体来存储分数。然后创建程序来执行加法、减法、乘法和除法操作。分数应存储为标准化形式。换句话说，2/4应该存储为1/2。
- en: Create a structure called `car` that holds attributes common to both electric
    and gas-powered cars. Add to it a union with two fields, `electric` and `gas`,
    that are structures that hold attributes specific to that type of car. For example,
    `numberOfPassengers` is common to all cars. The field `chargingTime` would be
    electric-only.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`car`的结构体，包含电动和燃油汽车共有的属性。为其添加一个包含两个字段`electric`和`gas`的联合体，这两个字段是分别存储电动和燃油汽车特有属性的结构体。例如，`numberOfPassengers`是所有汽车共有的字段，而`chargingTime`仅适用于电动汽车。
- en: Write a structure to describe a student (single class). The data should contain
    not only the student’s name and ID number but also an array containing the student’s
    grades.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个结构体来描述一个学生（单一班级）。数据应包含学生的姓名和学号，以及一个包含学生成绩的数组。
- en: Write a structure to handle the data shown in [Figure 8-3](#figure8-3).![f08003](image_fi/501621c08/f08003.png)
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个结构体来处理[图8-3](#figure8-3)中显示的数据。![f08003](image_fi/501621c08/f08003.png)
- en: 'Figure 8-3: IPv4 header format'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8-3：IPv4头格式
- en: 'The Southern California Railroad has the only Acme Traffic Signal (the one
    with arms and lights) actually at an intersection. To change the signal from STOP
    to GO, the controller must do the following:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 南加州铁路是唯一一个在交叉口设置了Acme交通信号灯（带有臂和灯）的地方。要将信号从STOP更改为GO，控制器必须执行以下操作：
- en: Turn off the STOP light.
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭STOP灯。
- en: Turn on the GO light.
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开GO灯。
- en: Turn on the DIRECTION relay.
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开DIRECTION继电器。
- en: Energize the ARM relay.
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动ARM继电器。
- en: Wait 3 seconds.
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待3秒钟。
- en: Turn off the ARM relay.
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭ARM继电器。
- en: Turn off the DIRECTION relay.
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭DIRECTION继电器。
- en: 'We have the following commands available: (1) change state of light *x* to
    *y*, where *x* is STOP or GO, and *y* is ON or OFF; (2) set DIRECTION relay power
    to *x*, where *x* is ON or OFF; and (3) sleep for *n* seconds. Write a structure
    for each command. Then write a union that holds an `enum` to identify the command
    and the structure for the given command.'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们有以下可用命令：（1）将灯光*x*的状态更改为*y*，其中*x*为STOP或GO，*y*为ON或OFF；（2）将DIRECTION继电器电源设置为*x*，其中*x*为ON或OFF；（3）休眠*n*秒。为每个命令编写一个结构体。然后编写一个联合体，包含一个`enum`来标识命令和相应命令的结构体。
