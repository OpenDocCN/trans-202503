- en: Chapter 2. Permissions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 权限
- en: In the previous chapter, we gave an overview of Android’s security model and
    briefly introduced permissions. In this chapter we’ll provide more details about
    permissions, focusing on their implementation and enforcement. We will then discuss
    how to define custom permissions and apply them to each of Android’s components.
    Finally, we’ll say a few words about *pending intents*, which are tokens that
    allow an application to start an intent with the identity and privileges of another
    application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们概述了Android的安全模型，并简要介绍了权限。在本章中，我们将提供有关权限的更多细节，重点讲解它们的实现和执行。接下来，我们将讨论如何定义自定义权限并将其应用于每个Android组件。最后，我们将简要介绍*待处理的意图*，它是一个令牌，允许应用程序以另一个应用程序的身份和权限启动意图。
- en: The Nature of Permissions
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权限的性质
- en: As we learned in [Chapter 1](ch01.html "Chapter 1. Android’s Security Model"),
    Android applications are sandboxed and by default can access only their own files
    and a very limited set of system services. In order to interact with the system
    and other applications, Android applications can request a set of additional permissions
    that are granted at install time and cannot be changed (with some exceptions,
    as we’ll discuss later in this chapter).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](ch01.html "第1章. Android的安全模型")中所学到的，Android应用程序是沙箱式的，默认情况下只能访问它们自己的文件和一小部分系统服务。为了与系统和其他应用程序进行交互，Android应用程序可以请求一组附加权限，这些权限在安装时授予，且在安装后不能更改（但有一些例外，我们将在本章后面讨论）。
- en: In Android, a *permission* is simply a string denoting the ability to perform
    a particular operation. The target operation can be anything from accessing a
    physical resource (such as the device’s SD card) or shared data (such as the list
    of registered contacts) to the ability to start or access a component in a third-party
    application. Android comes with a built-in set of predefined permissions. New
    permissions that correspond to new features are added in each version.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，*权限*只是一个字符串，表示执行特定操作的能力。目标操作可以是访问物理资源（如设备的SD卡）或共享数据（如已注册联系人列表），也可以是启动或访问第三方应用程序中的组件的能力。Android提供了一组内建的预定义权限，每个版本都会添加与新功能相关的新权限。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*New built-in permissions, which lock down functionality that previously didn’t
    require a permission, are applied conditionally, depending on the* targetSdkVersion
    *specified in an app’s manifest: applications targeting Android versions that
    were released before the new permission was introduced cannot be expected to know
    about it, and therefore the permission is usually granted implicitly (without
    being requested). However, implicitly granted permissions are still shown in the
    list of permissions on the app installer screen so that users can be aware of
    them. Apps targeting later versions need to explicitly request the new permission.*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*新的内建权限，限制了以前不需要权限的功能，依赖于* targetSdkVersion *在应用程序清单中指定的版本进行条件应用：针对引入新权限之前发布的Android版本的应用程序无法知道这些权限，因此这些权限通常会被隐式授予（无需请求）。不过，隐式授予的权限仍会在应用安装器屏幕的权限列表中显示，以便用户了解它们。针对较新版本的应用程序需要明确请求这些新权限。*'
- en: Built-in permissions are documented in the platform API reference.^([[11](#ftn.ch02fn01)])
    Additional permissions, called *custom permissions*, can be defined by both system
    and user-installed applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 内建权限在平台API参考文档中有记录。^([[11](#ftn.ch02fn01)]) 另外，还可以定义由系统和用户安装的应用程序使用的*自定义权限*。
- en: To view a list of the permissions currently known to the system, use the `pm
    list permissions` command (see [Example 2-1](ch02.html#getting_a_list_of_all_permissions
    "Example 2-1. Getting a list of all permissions")). To display additional information
    about permissions, including the defining package, label, description, and protection
    level, add the `-f` parameter to the command.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看系统当前已知的权限列表，可以使用`pm list permissions`命令（参见[示例2-1](ch02.html#getting_a_list_of_all_permissions
    "示例2-1. 获取所有权限的列表")）。要显示关于权限的更多信息，包括定义的包、标签、描述和保护级别，可以在命令中添加`-f`参数。
- en: Example 2-1. Getting a list of all permissions
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-1. 获取所有权限的列表
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Permission names are typically prefixed with their defining package concatenated
    with the string *.permission*. Because built-in permissions are defined in the
    `android` package, their names start with *android.permission*. For example, in
    [Example 2-1](ch02.html#getting_a_list_of_all_permissions "Example 2-1. Getting
    a list of all permissions"), the `REBOOT` ➊ and `BIND_VPN_SERVICE` ➋ are built-in
    permissions, while `GALLERY_PROVIDER` ➌ is defined by the Gallery application
    (package `com.google.android.gallery3d`) and `RECEIVE_LAUNCH_BROADCASTS` ➍ is
    defined by the default launcher application (package `com.android.launcher3`).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 权限名称通常以其定义的包名和字符串*.permission*为前缀。由于内建权限在`android`包中定义，它们的名称以*android.permission*开头。例如，在[示例
    2-1](ch02.html#getting_a_list_of_all_permissions "示例 2-1. 获取所有权限列表")中，`REBOOT`
    ➊和`BIND_VPN_SERVICE` ➋是内建权限，而`GALLERY_PROVIDER` ➌是由图库应用（包名为`com.google.android.gallery3d`）定义的，`RECEIVE_LAUNCH_BROADCASTS`
    ➍则由默认启动器应用（包名为`com.android.launcher3`）定义。
- en: Requesting Permissions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求权限
- en: Applications request permissions by adding one or more `<uses-permission>` tags
    to their *AndroidManifest.xml* file and can define new permissions with the `<permission>`
    tag. [Example 2-2](ch02.html#requesting_permissions_using_the_applica "Example 2-2. Requesting
    permissions using the application manifest file") shows an example manifest file
    that requests the `INTERNET` and `WRITE_EXTERNAL_STORAGE` permissions. (We show
    how to define custom permission in “[Custom Permissions](ch02.html#custom_permissions
    "Custom Permissions")”.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 应用通过向其*AndroidManifest.xml*文件添加一个或多个`<uses-permission>`标签来请求权限，并可以通过`<permission>`标签定义新的权限。[示例
    2-2](ch02.html#requesting_permissions_using_the_applica "示例 2-2. 使用应用清单文件请求权限")展示了一个请求`INTERNET`和`WRITE_EXTERNAL_STORAGE`权限的清单文件示例。（我们将在“[自定义权限](ch02.html#custom_permissions
    "自定义权限")”中展示如何定义自定义权限。）
- en: Example 2-2. Requesting permissions using the application manifest file
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-2. 使用应用清单文件请求权限
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Permission Management
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权限管理
- en: Permissions are assigned to each application (as identified by a unique *package
    name*) at install time by the system *package manager* service. The package manager
    maintains a central database of installed packages, both preinstalled and user-installed,
    with information about the install path, version, signing certificate, and assigned
    permissions of each package, as well as a list of all permissions defined on a
    device. (The `pm list permissions` command introduced in the previous section
    obtains this list by querying the package manager.) This package database is stored
    in the XML file */data/system/packages.xml*, which is updated each time an application
    is installed, updated, or uninstalled. [Example 2-3](ch02.html#application_entry_in_packagesdotxml
    "Example 2-3. Application entry in packages.xml") shows a typical application
    entry from *packages.xml*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 权限在应用安装时由系统的*包管理器*服务分配给每个应用（通过唯一的*包名*进行标识）。包管理器维护一个包含已安装包的中央数据库，包括预安装和用户安装的包，其中记录了每个包的安装路径、版本、签名证书和分配的权限信息，以及设备上定义的所有权限列表。（前一节介绍的`pm
    list permissions`命令通过查询包管理器来获取此列表。）这个包数据库存储在XML文件*/data/system/packages.xml*中，每次应用被安装、更新或卸载时，都会更新该文件。[示例
    2-3](ch02.html#application_entry_in_packagesdotxml "示例 2-3. packages.xml中的应用条目")展示了*packages.xml*中的典型应用条目。
- en: Example 2-3. Application entry in packages.xml
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-3. packages.xml中的应用条目
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We discuss the meaning of most tags and attributes in [Chapter 3](ch03.html
    "Chapter 3. Package Management"), but for now let’s focus on the ones that are
    related to permissions. Each package is represented by a `<package>` element,
    which contains information about the assigned UID (in the `userId` attribute ➊),
    signing certificate (in the `<cert>` tag ➋), and assigned permissions (listed
    as children of the `<perms>` tag ➌). To get information about an installed package
    programmatically, use the `getPackageInfo()` method of the `android.content.pm.PackageManager`
    class, which returns a `PackageInfo` instance that encapsulates the information
    contained in the `<package>` tag.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](ch03.html "第3章. 包管理")中讨论大多数标签和属性的含义，但现在让我们重点关注与权限相关的内容。每个包通过`<package>`元素表示，该元素包含有关分配的UID（在`userId`属性
    ➊中）、签名证书（在`<cert>`标签 ➋中）以及分配的权限（作为`<perms>`标签的子项列出 ➌）的信息。要以编程方式获取已安装包的信息，可以使用`android.content.pm.PackageManager`类的`getPackageInfo()`方法，该方法返回一个`PackageInfo`实例，封装了`<package>`标签中包含的信息。
- en: If all permissions are assigned at install time and cannot be changed or revoked
    without uninstalling the application, how does the package manager decide whether
    it should grant the requested permissions? To understand this, we need to discuss
    permission protection levels.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有权限都在安装时分配，并且在不卸载应用的情况下无法更改或撤销，包管理器如何决定是否授予请求的权限？为了理解这一点，我们需要讨论权限的保护级别。
- en: Permission Protection Levels
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权限保护级别
- en: According to the official documentation,^([[12](#ftn.ch02fn02)]) a permission’s
    *protection level* “characterizes the potential risk implied in the permission
    and indicates the procedure that the system should follow when determining whether
    or not to grant the permission.” In practice, this means that whether a permission
    is granted or not depends on its protection level. The following sections discuss
    the four protection levels defined in Android and how the system handles each.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方文档，^([[12](#ftn.ch02fn02)]) 权限的*保护级别*“描述了该权限所包含的潜在风险，并指示系统在决定是否授予权限时应遵循的程序。”实际上，这意味着权限是否被授予取决于其保护级别。接下来的章节讨论了
    Android 中定义的四种保护级别，以及系统如何处理每种级别。
- en: normal
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 普通
- en: This is the default value. It defines a permission with low risk to the system
    or other applications. Permissions with protection level *normal* are automatically
    granted without requiring user confirmation. Examples are `ACCESS_NETWORK_STATE`
    (allows applications to access information about networks) and `GET_ACCOUNTS`
    (allows access to the list of accounts in the Accounts Service).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认值。它定义了一种对系统或其他应用程序风险较低的权限。具有*普通*保护级别的权限会在不需要用户确认的情况下自动授予。例如 `ACCESS_NETWORK_STATE`（允许应用访问网络信息）和
    `GET_ACCOUNTS`（允许访问帐户服务中的帐户列表）。
- en: dangerous
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 危险
- en: Permissions with the *dangerous* protection level give access to user data or
    some form of control over the device. Examples are `READ_SMS` (allows an application
    to read SMS messages) and `CAMERA` (gives applications access to the camera device).
    Before granting dangerous permissions, Android shows a confirmation dialog that
    displays information about the requested permissions. Because Android requires
    that all requested permission be granted at install time, the user can either
    agree to install the app, thus granting the requested *dangerous* permission(s),
    or cancel the application install. For example, for the application shown in [Example 2-3](ch02.html#application_entry_in_packagesdotxml
    "Example 2-3. Application entry in packages.xml") (Google Translate), the system
    confirmation dialog will look like the one shown in [Figure 2-1](ch02.html#default_android_application_install_conf
    "Figure 2-1. Default Android application install confirmation dialog").
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 具有*危险*保护级别的权限会访问用户数据或对设备进行某种形式的控制。例如 `READ_SMS`（允许应用读取短信消息）和 `CAMERA`（允许应用访问相机设备）。在授予危险权限之前，Android
    会显示一个确认对话框，显示请求权限的信息。由于 Android 要求在安装时授予所有请求的权限，用户可以同意安装应用，从而授予请求的*危险*权限，或者取消应用安装。例如，对于[示例
    2-3](ch02.html#application_entry_in_packagesdotxml "示例 2-3. packages.xml 中的应用条目")（Google
    Translate）中显示的应用，系统确认对话框将类似于[图 2-1](ch02.html#default_android_application_install_conf
    "图 2-1. 默认的 Android 应用安装确认对话框")中所示。
- en: Google Play and other application market clients display their own dialog, which
    is typically styled differently. For the same application, the Google Play Store
    client displays the dialog shown in [Figure 2-2](ch02.html#google_play_store_client_application_ins
    "Figure 2-2. Google Play Store client application install confirmation dialog").
    Here, all *dangerous* permissions are organized by permission group (see “[System
    Permissions](ch02.html#system_permissions "System Permissions")”) and normal permissions
    are not displayed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Google Play 和其他应用市场客户端会显示自己的对话框，样式通常不同。对于相同的应用，Google Play 商店客户端会显示[图 2-2](ch02.html#google_play_store_client_application_ins
    "图 2-2. Google Play 商店客户端应用安装确认对话框")中显示的对话框。在这里，所有*危险*权限按权限组进行组织（参见“[系统权限](ch02.html#system_permissions
    "系统权限")”），普通权限则不会显示。
- en: '![Default Android application install confirmation dialog](figs/web/02fig01.png.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![默认的 Android 应用安装确认对话框](figs/web/02fig01.png.jpg)'
- en: Figure 2-1. Default Android application install confirmation dialog
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-1. 默认的 Android 应用安装确认对话框
- en: '![Google Play Store client application install confirmation dialog](figs/web/02fig02.png.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Google Play 商店客户端应用安装确认对话框](figs/web/02fig02.png.jpg)'
- en: Figure 2-2. Google Play Store client application install confirmation dialog
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-2. Google Play 商店客户端应用安装确认对话框
- en: signature
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 签名
- en: A *signature* permission is only granted to applications that are signed with
    the same key as the application that declared the permission. This is the “strongest”
    permission level because it requires the possession of a cryptographic key, which
    only the app (or platform) owner controls. Thus, applications using *signature*
    permissions are typically controlled by the same author. Built-in signature permissions
    are typically used by system applications that perform device management tasks.
    Examples are `NET_ADMIN` (configure network interfaces, IPSec, and so on) and
    `ACCESS_ALL_EXTERNAL_STORAGE` (access all multi-user external storage). We’ll
    discuss *signature* permissions in more detail in “[Signature Permissions](ch02.html#signature_permissions
    "Signature Permissions")”.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*签名*权限仅授予与声明该权限的应用使用相同密钥签名的应用。这是“最强”的权限级别，因为它要求拥有一个只有应用（或平台）所有者控制的加密密钥。因此，使用*签名*权限的应用通常由同一个作者控制。内置的签名权限通常由执行设备管理任务的系统应用使用。示例包括`NET_ADMIN`（配置网络接口、IPSec
    等）和`ACCESS_ALL_EXTERNAL_STORAGE`（访问所有多用户外部存储）。我们将在“[签名权限](ch02.html#signature_permissions
    "签名权限")”中更详细地讨论*签名*权限。'
- en: signatureOrSystem
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: signatureOrSystem
- en: 'Permissions with this protection level are somewhat of a compromise: they are
    granted to applications that are either part of the system image, or that are
    signed with the same key as the app that declared the permission. This allows
    vendors that have their applications preinstalled on an Android device to share
    specific features that require a permission without having to share signing keys.
    Until Android 4.3, any application installed on the *system* partition was granted
    *signatureOrSystem* permissions automatically. Since Android 4.4, applications
    need to be installed in the */system/priv-app/* directory in order to be granted
    permissions with this protection level.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 具有此保护级别的权限可以说是一种折衷：它们授予那些属于系统镜像的一部分，或与声明此权限的应用使用相同密钥签名的应用。这允许那些在 Android 设备上预安装应用的厂商在不共享签名密钥的情况下，分享需要权限的特定功能。直到
    Android 4.3，安装在*system*分区上的任何应用都会自动获得*signatureOrSystem*权限。自 Android 4.4 起，应用需要安装在*/system/priv-app/*目录下，才能获得具有此保护级别的权限。
- en: Permission Assignment
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权限分配
- en: Permissions are enforced at various layers in Android. Higher-level components
    such as applications and system services query the package manager to determine
    which permissions have been assigned to an application and decide whether to grant
    access. Lower-level components like native daemons typically do not have access
    to the package manager and rely on the UID, GID, and supplementary GIDs assigned
    to a process in order to determine which privileges to grant it. Access to system
    resources like device files, Unix domain sockets (local sockets), and network
    sockets is regulated by the kernel based on the owner and access mode of the target
    resource and the UID and GIDs of the accessing process.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 权限在 Android 中的各个层面进行强制执行。较高层次的组件，例如应用程序和系统服务，会查询包管理器以确定哪些权限已分配给某个应用，并决定是否授予访问权限。较低层次的组件，如本地守护进程，通常无法访问包管理器，而是依赖于分配给进程的
    UID、GID 和附加 GID 来决定授予哪些特权。对系统资源的访问，如设备文件、Unix 域套接字（本地套接字）和网络套接字，由内核基于目标资源的所有者、访问模式以及访问进程的
    UID 和 GID 来进行管理。
- en: We’ll look into framework-level permission enforcement in “[Permission Enforcement](ch02.html#permission_enforcement
    "Permission Enforcement")”. Let’s first discuss how permissions are mapped to
    OS-level constructs such as UID and GIDs and how these process IDs are used for
    permission enforcement.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在“[权限强制执行](ch02.html#permission_enforcement "权限强制执行")”中深入探讨框架级别的权限强制执行。首先，我们将讨论权限如何映射到操作系统级别的构造（如
    UID 和 GID），以及这些进程 ID 如何用于权限强制执行。
- en: Permissions and Process Attributes
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 权限与进程属性
- en: As in any Linux system, Android processes have a number of associated process
    attributes, most importantly real and effective UID and GID, and a set of supplementary
    GIDs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何 Linux 系统一样，Android 进程都有一组关联的进程属性，最重要的是实际和有效的 UID 和 GID，以及一组附加的 GID。
- en: As discussed in [Chapter 1](ch01.html "Chapter 1. Android’s Security Model"),
    each Android application is assigned a unique UID at install time and executes
    in a dedicated process. When the application is started, the process’s UID and
    GID are set to the application UID assigned by the installer (the package manager
    service). If additional permissions have been assigned to the application, they
    are mapped to GIDs and assigned as supplementary GIDs to the process. Permission
    to GID mappings for built-in permissions are defined in the */etc/permission/
    platform.xml* file. [Example 2-4](ch02.html#permission_to_gid_mapping_in_platformdot
    "Example 2-4. Permission to GID mapping in platform.xml") shows an excerpt from
    the *platform.xml* file found on an Android 4.4 device.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第 1 章](ch01.html "第 1 章. Android 的安全模型")所述，每个 Android 应用在安装时都会被分配一个唯一的 UID，并在专用进程中执行。当应用启动时，进程的
    UID 和 GID 会被设置为安装程序（包管理服务）分配的应用 UID。如果应用被分配了额外的权限，这些权限会映射到 GID，并作为补充 GID 分配给进程。内建权限的权限到
    GID 映射定义在 */etc/permission/ platform.xml* 文件中。[示例 2-4](ch02.html#permission_to_gid_mapping_in_platformdot
    "示例 2-4. 在 platform.xml 中的权限到 GID 映射") 显示了在 Android 4.4 设备上找到的 *platform.xml*
    文件的摘录。
- en: Example 2-4. Permission to GID mapping in platform.xml
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-4. 在 platform.xml 中的权限到 GID 映射
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the `INTERNET` permission is associated with the *inet* GID ➊, and the
    `WRITE_EXTERNAL_STORAGE` permission is associated with the *sdcard_r* and *sdcard_rw*
    GIDs ➋. Thus any process for an app that has been granted the `INTERNET` permission
    is associated with the supplementary GID corresponding to the *inet* group, and
    processes with the `WRITE_EXTERNAL_STORAGE` permission have the GIDs of *sdcard_r*
    and *sdcard_rw* added to the list of associated supplementary GIDs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`INTERNET` 权限与 *inet* GID ➊ 相关联，`WRITE_EXTERNAL_STORAGE` 权限与 *sdcard_r*
    和 *sdcard_rw* GIDs ➋ 相关联。因此，任何已被授予 `INTERNET` 权限的应用进程，都与对应的 *inet* 组的补充 GID 相关联，而授予
    `WRITE_EXTERNAL_STORAGE` 权限的进程，则将 *sdcard_r* 和 *sdcard_rw* 的 GID 添加到相关补充 GID 列表中。
- en: 'The `<assign-permission>` tag serves the opposite purpose: it is used to assign
    higher-level permissions to system processes running under a specific UID that
    do not have a corresponding package. [Example 2-4](ch02.html#permission_to_gid_mapping_in_platformdot
    "Example 2-4. Permission to GID mapping in platform.xml") shows that processes
    running with the *media* UID (in practice, this is the *mediaserver* daemon) are
    assigned the `MODIFY_AUDIO_SETTINGS` ➌ and `ACCESS_SURFACE_FLINGER` ➍ permissions.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`<assign-permission>` 标签的作用恰恰相反：它用于将更高级别的权限分配给在特定 UID 下运行的系统进程，这些进程没有对应的包。[示例
    2-4](ch02.html#permission_to_gid_mapping_in_platformdot "示例 2-4. 在 platform.xml
    中的权限到 GID 映射") 显示了与 *media* UID（实际上是 *mediaserver* 守护进程）一起运行的进程被分配了 `MODIFY_AUDIO_SETTINGS`
    ➌ 和 `ACCESS_SURFACE_FLINGER` ➍ 权限。'
- en: Android does not have an */etc/group* file, so the mapping from group names
    to GIDs is static and defined in the *android_filesystem_config.h* header file.
    [Example 2-5](ch02.html#static_user_and_group_name_to_uidsolidus "Example 2-5. Static
    user and group name to UID/GID mapping in android_filesystem_config.h") shows
    an excerpt containing the *sdcard_rw* ➊, *sdcard_r* ➋, and *inet* ➌ groups.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Android 没有*/etc/group* 文件，因此从组名到 GID 的映射是静态的，并在 *android_filesystem_config.h*
    头文件中定义。[示例 2-5](ch02.html#static_user_and_group_name_to_uidsolidus "示例 2-5. 在
    android_filesystem_config.h 中的静态用户和组名到 UID/GID 映射") 显示了一个包含 *sdcard_rw* ➊、*sdcard_r*
    ➋ 和 *inet* ➌ 组的摘录。
- en: Example 2-5. Static user and group name to UID/GID mapping in android_filesystem_config.h
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-5. 在 android_filesystem_config.h 中的静态用户和组名到 UID/GID 映射
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The *android_filesystem_config.h* file also defines the owner, access mode,
    and associated capabilities (for executables) of core Android system directories
    and files.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*android_filesystem_config.h* 文件还定义了 Android 核心系统目录和文件的所有者、访问模式以及关联的能力（对于可执行文件）。'
- en: The package manager reads *platform.xml* at startup and maintains a list of
    permissions and associated GIDs. When it grants permissions to a package during
    installation, the package manager checks whether each permission has an associated
    GID(s). If so, the GID(s) is added to the list of supplementary GIDs associated
    with the application. The supplementary GID list is written as the last field
    of the *packages.list* file (see [Example 1-6](ch01.html#uid_corresponding_to_each_application_is
    "Example 1-6. The UID corresponding to each application is stored in /data/system/packages.list")).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器在启动时读取 *platform.xml* 并维护权限及其关联的 GID 列表。当它在安装过程中授予权限时，包管理器会检查每个权限是否有关联的
    GID(s)。如果有，GID(s) 会被添加到与应用相关联的附加 GID 列表中。附加 GID 列表作为 *packages.list* 文件的最后一项字段写入（参见
    [示例 1-6](ch01.html#uid_corresponding_to_each_application_is "示例 1-6. 每个应用对应的 UID
    存储在 /data/system/packages.list 中")）。
- en: Process Attribute Assignment
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进程属性分配
- en: Before we see how the kernel and lower-level system services check and enforce
    permissions, we need to examine how Android application processes are started
    and assigned process attributes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解内核和低级系统服务如何检查并强制执行权限之前，我们需要先了解 Android 应用进程是如何启动和分配进程属性的。
- en: As discussed in [Chapter 1](ch01.html "Chapter 1. Android’s Security Model"),
    Android applications are implemented in Java and are executed by the Dalvik VM.
    Thus each application process is in fact a Dalvik VM process executing the application’s
    bytecode. In order to reduce the application memory footprint and improve startup
    time, Android does not start a new Dalvik VM process for each application. Instead,
    it uses a partially initialized process called *zygote* and forks it (using the
    `fork()` system call^([[13](#ftn.ch02fn03)])) when it needs to start a new application.
    However, instead of calling one of the `exec()` functions like it does when starting
    a native process, it merely executes the `main()` function of the specified Java
    class. This process is called *specialization*, because the generic *zygote* process
    is turned into a specific application process, much like cells originating from
    the zygote cell specialize into cells that perform different functions. Thus the
    forked process inherits the memory image of the *zygote* process, which has preloaded
    most core and application framework Java classes. Because those classes never
    change and Linux uses a copy-on-write mechanism when forking processes, all child
    processes of *zygote* (that is, all Android applications) share the same copy
    of framework Java classes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 1 章](ch01.html "第 1 章. Android 的安全模型")中所讨论，Android 应用是用 Java 实现的，并由 Dalvik
    虚拟机执行。因此，每个应用进程实际上是一个执行应用字节码的 Dalvik 虚拟机进程。为了减少应用内存占用并提高启动速度，Android 并不会为每个应用启动一个新的
    Dalvik 虚拟机进程。相反，它使用一个部分初始化的进程，称为 *zygote*，当需要启动新应用时，它会分叉该进程（使用 `fork()` 系统调用^([[13](#ftn.ch02fn03)]))。然而，它并不会像启动本地进程时那样调用
    `exec()` 函数，而是仅执行指定 Java 类的 `main()` 函数。这个过程被称为 *专门化*，因为通用的 *zygote* 进程被转化为一个特定的应用进程，就像来自合子细胞的细胞会专门化成执行不同功能的细胞一样。因此，分叉出的进程继承了
    *zygote* 进程的内存映像，而 *zygote* 进程已经预加载了大多数核心和应用框架 Java 类。由于这些类从不改变，而且 Linux 在分叉进程时使用写时复制机制，所有
    *zygote* 的子进程（即所有 Android 应用）共享相同的框架 Java 类副本。
- en: The *zygote* process is started by the *init.rc* initialization script and receives
    commands on a Unix-domain socket, also named *zygote*. When *zygote* receives
    a request to start a new application process, it forks itself, and the child process
    executes roughly the following code (abbreviated from `forkAndSpecializeCommon()`
    in *dalvik_system_Zygote.cpp*) in order to specialize itself as shown in [Example 2-6](ch02.html#application_process_specialization_in_zy
    "Example 2-6. Application process specialization in zygote").
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*zygote* 进程由 *init.rc* 初始化脚本启动，并通过一个名为 *zygote* 的 Unix 域套接字接收命令。当 *zygote*
    接收到启动新应用进程的请求时，它会自我分叉，子进程大致执行以下代码（简化自 *dalvik_system_Zygote.cpp* 中的 `forkAndSpecializeCommon()`），以便按
    [示例 2-6](ch02.html#application_process_specialization_in_zy "示例 2-6. 在 zygote
    中的应用进程专门化") 所示进行自我专门化。'
- en: Example 2-6. Application process specialization in zygote
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-6. 在 zygote 中的应用进程专门化
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As shown here, the child process first sets its supplementary GIDs (corresponding
    to permissions) using `setgroups()`, called by `setgroupsIntarray()` at ➊. Next,
    it sets resource limits using `setrlimit()`, called by `setrlimitsFromArray()`
    at ➋, then sets the real, effective, and saved user and group IDs using `setresgid()`
    ➌ and `setresuid()` ➍.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，子进程首先使用 `setgroups()` 设置其附加 GID（对应权限），该函数由 `setgroupsIntarray()` 在 ➊ 调用。接着，它使用
    `setrlimit()` 设置资源限制，该函数由 `setrlimitsFromArray()` 在 ➋ 调用，然后使用 `setresgid()` ➌
    和 `setresuid()` ➍ 设置实际、有效和保存的用户 ID 和组 ID。
- en: The child process is able to change its resource limits and all process attributes
    because it initially executes as root, just like its parent process, *zygote*.
    After the new process attributes are set, the child process executes with the
    assigned UIDs and GIDs and cannot go back to executing as root because the saved
    user ID is not 0.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程能够改变其资源限制和所有进程属性，因为它最初以 root 身份执行，就像它的父进程*zygote*一样。在设置完新的进程属性后，子进程将以分配的
    UID 和 GID 执行，并且无法再以 root 身份执行，因为保存的用户 ID 不是 0。
- en: After setting the UIDs and GIDs, the process sets its capabilities^([[14](#ftn.ch02fn04)])
    using `capset()`, called from `setCapabilities()` ➎. Then, it sets its scheduling
    policy by adding itself to one of the predefined control groups ➏.^([[15](#ftn.ch02fn05)])
    At ➐, the process sets its nice name (displayed in the process list, typically
    the application’s package name) and *seinfo* tag (used by SELinux, which we discuss
    in [Chapter 12](ch12.html "Chapter 12. Selinux")). Finally, it enables debugging
    if requested ➑.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完 UID 和 GID 后，进程使用 `capset()` 设置其能力^([[14](#ftn.ch02fn04)])，该函数由 `setCapabilities()`
    在 ➎ 调用。然后，它通过将自己添加到预定义的控制组之一来设置调度策略 ➏.^([[15](#ftn.ch02fn05)]) 在 ➐ 处，进程设置其优先级名称（在进程列表中显示，通常是应用程序的包名）和
    *seinfo* 标签（由 SELinux 使用，我们将在[第12章](ch12.html "第12章. Selinux")中讨论）。最后，如果请求，进程会启用调试
    ➑。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Android 4.4 introduces a new, experimental runtime called Android RunTime
    (ART), which is expected to replace Dalvik in a future version. While ART brings
    many changes to the current execution environment, most importantly ahead-of-time
    (AOT) compilation, it uses the same zygote-based app process execution model as
    Dalvik.*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*Android 4.4 引入了一个新的实验性运行时，称为 Android 运行时（ART），预计将在未来的版本中替代 Dalvik。虽然 ART 带来了许多对当前执行环境的改变，最重要的是提前编译（AOT），但它使用与
    Dalvik 相同的基于 zygote 的应用进程执行模型。*'
- en: The process relationship between *zygote* and application process is evident
    in the process list obtained with the `ps` command, as shown in [Example 2-7](ch02.html#zygote_and_application_process_relations
    "Example 2-7. zygote and application process relationship").
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `ps` 命令获取的进程列表中可以明显看到*zygote*和应用进程之间的关系，如[示例 2-7](ch02.html#zygote_and_application_process_relations
    "示例 2-7. zygote 和应用进程的关系")所示。
- en: Example 2-7. zygote and application process relationship
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-7. zygote 和应用进程的关系
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, the PID column denotes the process ID, the PPID column denotes the parent
    process ID, and the NAME column denotes the process name. As you can see, *zygote*
    (PID 181 ➋) is started by the *init* process (PID 1 ➊) and all application processes
    have *zygote* as their parent (PPID 181). Each process executes under a dedicated
    user, either built-in (*radio*, *nfc*), or automatically assigned (*u0_a7*) at
    install time. The process names are set to the package name of each application
    (`com.android.phone`, `com.android.nfc`, and `com.google.android.gms`).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，PID 列表示进程 ID，PPID 列表示父进程 ID，NAME 列表示进程名称。如你所见，*zygote*（PID 181 ➋）是由*init*进程（PID
    1 ➊）启动的，所有应用进程的父进程都是*zygote*（PPID 181）。每个进程都在一个专用用户下执行，可能是内置的（*radio*，*nfc*），或者在安装时自动分配的（*u0_a7*）。进程名称被设置为每个应用的包名（`com.android.phone`，`com.android.nfc`，和
    `com.google.android.gms`）。
- en: Permission Enforcement
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权限强制执行
- en: As discussed in the previous section, each application process is assigned a
    UID, GID, and supplementary GIDs when it is forked from *zygote*. The kernel and
    system daemons use these process identifiers to decide whether to grant access
    to a particular system resource or function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，每个应用进程在从*zygote*分叉时都会分配一个 UID、GID 和附加的 GID。内核和系统守护进程使用这些进程标识符来决定是否授予访问某个系统资源或功能的权限。
- en: Kernel-Level Enforcement
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核级强制执行
- en: Access to regular files, device nodes, and local sockets is regulated just as
    it is in any Linux system. One Android-specific addition is requiring processes
    that want to create network sockets to belong to the group *inet*. This Android
    kernel addition is known as “paranoid network security” and is implemented as
    an additional check in the Android kernel, as shown in [Example 2-8](ch02.html#paranoid_network_security_implementation
    "Example 2-8. Paranoid network security implementation in the Android kernel").
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对常规文件、设备节点和本地套接字的访问与任何 Linux 系统一样受到管理。Android 特有的一个添加项是要求希望创建网络套接字的进程属于 *inet*
    组。这个 Android 内核的添加项被称为“偏执的网络安全”，并作为 Android 内核中的一个附加检查实现，如 [示例 2-8](ch02.html#paranoid_network_security_implementation
    "示例 2-8. Android 内核中的偏执网络安全实现") 所示。
- en: Example 2-8. Paranoid network security implementation in the Android kernel
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-8. Android 内核中的偏执网络安全实现
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Caller processes that do not belong to the `AID_INET` (GID 3003, name *inet*)
    group and do not have the `CAP_NET_RAW` capability (allowing the use of RAW and
    PACKET sockets) receive an access denied error (➊ and ➌). NonAndroid kernels do
    not define `CONFIG_ANDROID_PARANOID_NETWORK` and thus no special group membership
    is required to create a socket ➋. In order for the *inet* group to be assigned
    to an application process, it needs to be granted the `INTERNET` permission. As
    a result, only applications with the `INTERNET` per-mission can create network
    sockets. In addition to checking process credentials when creating sockets, Android
    kernels also grant certain capabilities to processes executing with specific GIDs:
    processes that execute with the `AID_NET_RAW` (GID 3004) are given the `CAP_NET_RAW`
    capability, and those executing with `AID_NET_ADMIN` (GID 3005) are given the
    `CAP_NET_ADMIN` capability.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 不属于 `AID_INET`（GID 3003，名称为 *inet*）组且没有 `CAP_NET_RAW` 能力（允许使用 RAW 和 PACKET 套接字）的调用进程会收到访问拒绝错误（➊
    和 ➌）。非 Android 内核未定义 `CONFIG_ANDROID_PARANOID_NETWORK`，因此创建套接字时不需要特别的组成员身份 ➋。为了将
    *inet* 组分配给应用进程，必须授予其 `INTERNET` 权限。因此，只有具有 `INTERNET` 权限的应用程序才能创建网络套接字。除了在创建套接字时检查进程凭据外，Android
    内核还会授予具有特定 GID 的进程某些能力：以 `AID_NET_RAW`（GID 3004）身份执行的进程会获得 `CAP_NET_RAW` 能力，而以
    `AID_NET_ADMIN`（GID 3005）身份执行的进程会获得 `CAP_NET_ADMIN` 能力。
- en: Paranoid network security is also used to control access to Bluetooth sockets
    and the kernel tunneling driver (used for VPN). A full list of Android GIDs that
    the kernel treats in a special way can be found in the *include/linux/android_aid.h*
    file in the kernel source tree.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 偏执的网络安全还用于控制对蓝牙套接字和内核隧道驱动程序（用于 VPN）的访问。内核以特殊方式处理的 Android GID 的完整列表可以在内核源代码树中的
    *include/linux/android_aid.h* 文件中找到。
- en: Native Daemon-Level Enforcement
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地守护进程级别的强制执行
- en: While Binder is the preferred IPC mechanism in Android, lower-level native daemons
    often use Unix domain sockets (local sockets) for IPC. Because Unix domain sockets
    are represented as nodes on the filesystem, standard filesystem permission can
    be used to control access.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Binder 是 Android 中首选的进程间通信（IPC）机制，但较低级别的本地守护进程通常使用 Unix 域套接字（本地套接字）进行 IPC。由于
    Unix 域套接字在文件系统中以节点的形式表示，因此可以使用标准的文件系统权限来控制访问。
- en: 'As most sockets are created with an access mode that only allows access to
    their owner and group, clients running under a different UID and GID cannot connect
    to the socket. Local sockets for system daemons are defined in *init.rc* and created
    by *init* on startup with the specified access mode. For example, [Example 2-9](ch02.html#vold_daemon_entry_in_initdotrc
    "Example 2-9. vold daemon entry in init.rc") shows how the volume management daemon
    (*vold*) is defined in *init.rc*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数套接字是以仅允许其所有者和组访问的访问模式创建的，运行在不同 UID 和 GID 下的客户端无法连接到该套接字。系统守护进程的本地套接字在 *init.rc*
    中定义，并由 *init* 在启动时以指定的访问模式创建。例如，[示例 2-9](ch02.html#vold_daemon_entry_in_initdotrc
    "示例 2-9. init.rc 中的 vold 守护进程条目") 显示了如何在 *init.rc* 中定义卷管理守护进程 (*vold*)：
- en: Example 2-9. vold daemon entry in init.rc
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-9. init.rc 中的 vold 守护进程条目
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*vold* declares a socket called *vold* with the 0660 access mode, owned by
    *root* and with group set to *mount* ➊. The *vold* daemon needs to run as root
    in order to mount or unmount volumes, but members of the *mount* group (`AID_MOUNT`,
    GID 1009) can send it commands via the local socket without needing to run as
    the superuser. Local sockets for Android daemons are created in the */dev/socket/*
    directory. [Example 2-10](ch02.html#local_sockets_for_core_system_daemons_in "Example 2-10. Local
    sockets for core system daemons in /dev/socket/") shows that the *vold* socket
    ➊ has the owner and permission specified in *init.rc*.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*vold*声明了一个名为*vold*的套接字，访问模式为0660，所有者为*root*，并且组设置为*mount* ➊。*vold*守护进程需要以root身份运行才能挂载或卸载卷，但*mount*组的成员（`AID_MOUNT`，GID
    1009）可以通过本地套接字向其发送命令，而无需以超级用户身份运行。Android守护进程的本地套接字创建在*/dev/socket/*目录中。[示例 2-10](ch02.html#local_sockets_for_core_system_daemons_in
    "示例 2-10. /dev/socket/中的核心系统守护进程的本地套接字")显示了*vold*套接字➊的所有者和权限设置，这些设置在*init.rc*中指定。'
- en: Example 2-10. Local sockets for core system daemons in /dev/socket/
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-10. /dev/socket/中的核心系统守护进程的本地套接字
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Unix domain sockets allow the passing and querying of client credentials using
    the `SCM_CREDENTIALS` control message and the `SO_PEERCRED` socket option. Like
    the effective UID and effective GUID that are part of a Binder transaction, the
    peer credentials associated with a local socket are checked by the kernel and
    cannot be forged by user-level processes. This allows native daemons to implement
    additional, fine-grained control over the operations that they allow for a particular
    client, as shown in [Example 2-11](ch02.html#fine-grained_access_control_based_on_soc
    "Example 2-11. Fine-grained access control based on socket client credentials
    in vold") using the *vold* daemon as an example.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Unix域套接字允许通过`SCM_CREDENTIALS`控制消息和`SO_PEERCRED`套接字选项传递和查询客户端凭证。与Binder事务中包含的有效UID和有效GUID类似，与本地套接字关联的对等凭证由内核检查，并且不能被用户级进程伪造。这允许本地守护进程实现对其允许的特定客户端操作的额外精细化控制，如[示例
    2-11](ch02.html#fine-grained_access_control_based_on_soc "示例 2-11. 基于套接字客户端凭证的精细化访问控制在vold中的应用")所示，使用*vold*守护进程作为示例。
- en: Example 2-11. Fine-grained access control based on socket client credentials
    in vold
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-11. 基于套接字客户端凭证的精细化访问控制在vold中的应用
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The *vold* daemon only allows encrypted container management commands to clients
    running as the *root* (UID 0) or *system* (`AID_SYSTEM`, UID 1000) users. Here,
    the UID returned by `SocketClient->getUid()` ➊ is initialized with the client
    UID obtained using `getsockopt(SO_PEERCRED)` as shown in [Example 2-12](ch02.html#obtaining_local_socket_client_credential
    "Example 2-12. Obtaining local socket client credentials using getsockopt()")
    at ➊.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*vold*守护进程仅允许以*root*（UID 0）或*system*（`AID_SYSTEM`，UID 1000）用户身份运行的客户端发送加密容器管理命令。在这里，`SocketClient->getUid()`返回的UID➊是通过`getsockopt(SO_PEERCRED)`获取的客户端UID，如[示例
    2-12](ch02.html#obtaining_local_socket_client_credential "示例 2-12. 使用getsockopt()获取本地套接字客户端凭证")中所示。'
- en: Example 2-12. Obtaining local socket client credentials using `getsockopt()`
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-12. 使用`getsockopt()`获取本地套接字客户端凭证
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Local socket connection functionality is encapsulated in the `android.net.LocalSocket`
    class and is available to Java applications as well, allowing higher-level system
    services to communicate with native daemons without using JNI code. For example,
    the `MountService` framework class uses `LocalSocket` to send commands to the
    *vold* daemon.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本地套接字连接功能封装在`android.net.LocalSocket`类中，Java应用程序也可以使用该功能，使得更高层次的系统服务能够与本地守护进程进行通信，而无需使用JNI代码。例如，`MountService`框架类使用`LocalSocket`向*vold*守护进程发送命令。
- en: Framework-Level Enforcement
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架级强制执行
- en: As discussed in the introduction to Android permissions, access to Android components
    can be controlled using permissions by declaring the required permissions in the
    manifest of the enclosing application. The system keeps track of the permissions
    associated with each component and checks to see whether callers have been granted
    the required permissions before allowing access. Because components cannot change
    the permissions they require at runtime, enforcement by the system is *static*.
    Static permissions are an example of declarative security. When using declarative
    security, security attributes such as roles and permissions are placed in the
    metadata of a component (the *AndroidManifest.xml* file in Android), rather than
    in the component itself, and are enforced by the container or runtime environment.
    This has the advantage of isolating security decisions from business logic but
    can be less flexible than implementing securing checks within the component.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在Android权限介绍中所讨论的那样，访问Android组件可以通过声明所需权限在封闭应用程序的清单中来控制。系统会跟踪与每个组件关联的权限，并在允许访问之前检查调用者是否已被授予所需权限。由于组件不能在运行时更改其所需的权限，因此系统的强制执行是*静态的*。静态权限是声明性安全性的一个例子。使用声明性安全性时，角色和权限等安全属性被放置在组件的元数据中（在Android中是*AndroidManifest.xml*文件），而不是在组件本身，并由容器或运行时环境强制执行。这有一个优点，即将安全决策与业务逻辑隔离开，但相比在组件内部实现安全检查，它可能不够灵活。
- en: Android components can also check to see whether a calling process has been
    granted a certain permission without declaring the permissions in the manifest.
    This *dynamic permission enforcement* requires more work but allows for more fine-grained
    access control. Dynamic permission enforcement is an example of imperative security,
    because security decisions are made by each component rather than being enforced
    by the runtime environment.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Android组件还可以检查调用进程是否已被授予某个权限，而无需在清单中声明权限。这种*动态权限强制执行*需要更多的工作，但允许更细粒度的访问控制。动态权限强制执行是命令式安全性的一个例子，因为安全决策由每个组件做出，而不是由运行时环境强制执行。
- en: Let’s look at how dynamic and static permission enforcement are implemented
    in more detail.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解动态和静态权限强制执行的实现方式。
- en: Dynamic Enforcement
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态强制执行
- en: As discussed in [Chapter 1](ch01.html "Chapter 1. Android’s Security Model"),
    the core of Android is implemented as a set of cooperating system services that
    can be called from other processes using the Binder IPC mechanism. Core services
    register with the service manager and any application that knows their registration
    name can obtain a Binder reference. Because Binder does not have a built-in access
    control mechanism, when clients have a reference they can call any method of the
    underlying system service by passing the appropriate parameters to `Binder.transact()`.
    Therefore, access control needs to be implemented by each system service.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第1章](ch01.html "第1章. Android的安全模型")中讨论的那样，Android的核心是由一组合作的系统服务实现的，这些服务可以通过Binder
    IPC机制从其他进程调用。核心服务注册到服务管理器，任何知道它们注册名称的应用程序都可以获取Binder引用。由于Binder没有内置的访问控制机制，因此当客户端拥有引用时，它们可以通过将适当的参数传递给`Binder.transact()`来调用底层系统服务的任何方法。因此，访问控制需要由每个系统服务实现。
- en: In [Chapter 1](ch01.html "Chapter 1. Android’s Security Model"), we showed that
    system services can regulate access to exported operations by directly checking
    the UID of the caller obtained from `Binder.getCallingUid()` (see [Example 1-8](ch01.html#checking_that_the_caller_is_running_with
    "Example 1-8. Checking that the caller is running with the system UID")). However,
    this method requires that the service knows the list of allowed UIDs in advance,
    which only works for well-known fixed UIDs such as those of *root* (UID 0) and
    *system* (UID 1000). Also, most services do not care about the actual UID of the
    caller; they simply want to check if it has been granted a certain permission.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. Android的安全模型")中，我们展示了系统服务如何通过直接检查从`Binder.getCallingUid()`获取的调用者UID来调节对导出操作的访问（参见[示例1-8](ch01.html#checking_that_the_caller_is_running_with
    "示例1-8. 检查调用者是否以系统UID运行")）。然而，这种方法要求服务提前知道允许的UID列表，这仅适用于一些已知的固定UID，如*root*（UID
    0）和*system*（UID 1000）。此外，大多数服务并不关心调用者的实际UID；它们只关心是否已授予某个权限。
- en: Because each application UID in Android is associated with a unique package
    (unless it is part of a shared user ID), and the package manager keeps track of
    the permissions granted to each package, this is made possible by querying the
    package manager service. Checking to see whether the caller has a certain permission
    is a very common operation, and Android provides a number of helper methods in
    the `android.content.Context` class that can perform this check.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个Android应用的UID都与一个唯一的包关联（除非它是共享用户ID的一部分），并且包管理器跟踪每个包授予的权限，所以可以通过查询包管理服务来实现这一点。检查调用者是否具有某个权限是一个非常常见的操作，Android在`android.content.Context`类中提供了多个辅助方法来执行此检查。
- en: Let’s first examine how the `int Context.checkPermission(String permission,
    int pid, int uid)` method works. This method returns `PERMISSION_GRANTED` if the
    passed UID has the permission, and returns `PERMISSION_DENIED` otherwise. If the
    caller is *root* or *system*, the permission is automatically granted. As a performance
    optimization, if the requested permission has been declared by the calling app,
    it is granted without examining the actual permission. If that is not the case,
    the method checks to see whether the target component is public (exported) or
    private, and denies access to all private components. (We’ll discuss component
    export in “[Public and Private Components](ch02.html#public_and_private_components
    "Public and Private Components")”.) Finally, the code queries the package manager
    service to see if the caller has been granted the requested permission. The relevant
    code from the `PackageManagerService` class is shown in [Example 2-13](ch02.html#uid-based_permission_check_in_packageman
    "Example 2-13. UID-based permission check in PackageManagerService").
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看看`int Context.checkPermission(String permission, int pid, int uid)`方法的工作原理。此方法如果传入的UID具有该权限，则返回`PERMISSION_GRANTED`，否则返回`PERMISSION_DENIED`。如果调用者是*root*或*system*，则权限会自动授予。作为性能优化，如果请求的权限已经被调用的应用声明，则直接授予权限，而无需检查实际权限。如果不是这种情况，方法会检查目标组件是公开（导出）还是私有，并拒绝访问所有私有组件。（我们将在“[公共与私有组件](ch02.html#public_and_private_components
    "公共与私有组件")”中讨论组件的导出）。最后，代码会查询包管理服务，以查看调用者是否已获得请求的权限。来自`PackageManagerService`类的相关代码可参见[示例2-13](ch02.html#uid-based_permission_check_in_packageman
    "示例2-13 基于UID的权限检查")。
- en: Example 2-13. UID-based permission check in `PackageManagerService`
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-13. `PackageManagerService`中的基于UID的权限检查
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here the `PackageManagerService` first determines the *app ID* of the application
    based on the passed UID ➊ (the same application can be assigned multiple UIDs
    when installed for different users, which we discuss in detail in [Chapter 4](ch04.html
    "Chapter 4. User Management")) and then obtains the set of granted permissions.
    If the `GrantedPermission` class (which holds the actual `java.util.Set<String>`
    of permission names) contains the target permission, the method returns `PERMISSION_GRANTED`
    ➋. If not, it checks whether the target permission should be automatically assigned
    to the passed-in UID ➌ (based on the `<assign-permission>` tags in `platform.xml`,
    as shown in [Example 2-4](ch02.html#permission_to_gid_mapping_in_platformdot "Example 2-4. Permission
    to GID mapping in platform.xml")). If this check fails as well, it finally returns
    `PERMISSION_DENIED`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`PackageManagerService`首先根据传入的UID ➊确定应用程序的*应用ID*（同一个应用程序在为不同用户安装时可以分配多个UID，详细讨论请参见[第4章](ch04.html
    "第4章 用户管理")），然后获取授予的权限集合。如果`GrantedPermission`类（其中包含实际的`java.util.Set<String>`类型的权限名称）包含目标权限，则该方法返回`PERMISSION_GRANTED`
    ➋。否则，它将检查目标权限是否应自动分配给传入的UID ➌（依据`platform.xml`中的`<assign-permission>`标签，如[示例2-4](ch02.html#permission_to_gid_mapping_in_platformdot
    "示例2-4 platform.xml中的权限到GID的映射")所示）。如果该检查也失败，最终返回`PERMISSION_DENIED`。
- en: The other permission-check helper methods in the `Context` class follow the
    same procedure. The `int checkCallingOrSelfPermission(String permission)` method
    calls `Binder.getCallingUid()` and `Binder.getCallingPid()` for us, and then calls
    `checkPermission(String permission, int pid, int uid)` using the obtained values.
    The `enforcePermission(String permission, int pid, int uid, String message)` method
    does not return a result but instead throws a `SecurityException` with the specified
    message if the permission is not granted. For example, the `BatterStatsService`
    class guarantees that only apps that have the `BATTERY_STATS` permission can obtain
    battery statistics by calling `enforceCallingPermission()` before executing any
    other code, as shown in [Example 2-14](ch02.html#dynamic_permission_check_in_batterystats
    "Example 2-14. Dynamic permission check in BatteryStatsService"). Callers that
    have not been granted the permission receive a `SecurityException`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context` 类中的其他权限检查辅助方法遵循相同的流程。`int checkCallingOrSelfPermission(String permission)`
    方法会调用 `Binder.getCallingUid()` 和 `Binder.getCallingPid()`，然后使用获取到的值调用 `checkPermission(String
    permission, int pid, int uid)`。`enforcePermission(String permission, int pid,
    int uid, String message)` 方法不会返回结果，而是在没有权限时抛出带有指定消息的 `SecurityException`。例如，`BatteryStatsService`
    类通过在执行其他代码之前调用 `enforceCallingPermission()` 来确保只有拥有 `BATTERY_STATS` 权限的应用程序能够获取电池统计信息，如
    [示例 2-14](ch02.html#dynamic_permission_check_in_batterystats "示例 2-14. 在 BatteryStatsService
    中进行动态权限检查") 所示。未被授予权限的调用者会收到 `SecurityException`。'
- en: Example 2-14. Dynamic permission check in `BatteryStatsService`
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-14. `BatteryStatsService` 中的动态权限检查
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Static Enforcement
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态强制执行
- en: Static permission enforcement comes into play when an application tries to interact
    with a component declared by another application. The enforcement process takes
    into account the permissions declared for each target component (if any) and allows
    the interaction if the caller process has been granted the required permission.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 静态权限强制执行在应用程序尝试与另一个应用程序声明的组件进行交互时起作用。强制执行过程会考虑每个目标组件声明的权限（如果有），并在调用者进程被授予所需权限时允许交互。
- en: Android uses intents to describe an operation it needs to perform, and intents
    that fully specify the target component (by package and class name) are called
    *explicit*. On the other hand, *implicit* intents contain some data (often only
    an abstract action such as `ACTION_SEND`) that allows the system to find a matching
    component, but they do not fully specify a target component.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Android 使用意图来描述需要执行的操作，完全指定目标组件（通过包名和类名）的意图称为 *显式* 意图。另一方面，*隐式* 意图包含一些数据（通常只是一个抽象动作，例如
    `ACTION_SEND`），允许系统找到匹配的组件，但并未完全指定目标组件。
- en: When the system receives an implicit intent, it first resolves it by searching
    for matching components. If more than one matching component is found, the user
    is presented with a selection dialog. When a target component has been selected,
    Android checks to see whether it has any associated permissions, and if it does,
    checks whether they have been granted to the caller.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统接收到一个隐式意图时，它首先通过搜索匹配的组件来解析该意图。如果找到多个匹配的组件，用户将看到一个选择对话框。当选择了目标组件后，Android
    会检查该组件是否有相关的权限，如果有，再检查这些权限是否已经授予给调用者。
- en: 'The general process is similar to dynamic enforcement: the UID and PID of the
    caller are obtained using `Binder.getCallingUid()` and `Binder.getCallingPid()`,
    the caller UID is mapped to a package name, and the associated permissions are
    retrieved. If the set of caller permissions contains the ones required by the
    target component, the component is started; otherwise, a `SecurityException` is
    thrown.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一般流程类似于动态权限强制：通过 `Binder.getCallingUid()` 和 `Binder.getCallingPid()` 获取调用者的
    UID 和 PID，调用者的 UID 会被映射到一个包名，并且检索相关的权限。如果调用者权限集包含目标组件所需的权限，组件将被启动；否则，将抛出 `SecurityException`。
- en: Permission checks are performed by the `ActivityManagerService`, which resolves
    the specified intent and checks to see whether the target component has an associated
    permission attribute. If so, it delegates the permission check to the package
    manager. The timing and concrete sequence of permission checks is slightly different
    depending on the target component. (Next, we’ll examine how checks are performed
    for each component.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 权限检查由 `ActivityManagerService` 执行，该服务解析指定的意图并检查目标组件是否有相关的权限属性。如果有，它将权限检查委托给包管理器。具体的权限检查时机和顺序会根据目标组件有所不同。（接下来，我们将检查每个组件如何进行检查。）
- en: Activity and Service Permission Enforcement
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动和服务权限强制执行
- en: Permission checks for activities are performed if the intent passed to `Context.startActivity()`
    or `startActivityForResult()` resolves to an activity that declares a permission.
    A `SecurityException` is thrown if the caller does not have the required permission.
    Because Android services can be started, stopped, and bound to, calls to `Context.startService()`,
    `stopService()`, and `bindService()` are all subject to permission checks if the
    target service declares a permission.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递给`Context.startActivity()`或`startActivityForResult()`的意图指向一个声明了权限的活动，则会进行活动的权限检查。如果调用者没有所需的权限，将抛出`SecurityException`。因为
    Android 服务可以启动、停止和绑定，因此调用`Context.startService()`、`stopService()`和`bindService()`时，如果目标服务声明了权限，也会受到权限检查。
- en: Content Provider Permission Enforcement
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内容提供者权限强制执行
- en: Content provider permissions can either protect the whole component or a particular
    exported URI, and different permissions can be specified for reading and writing.
    (You’ll learn more about permission declaration in “[Content Provider Permissions](ch02.html#content_provider_permissions
    "Content Provider Permissions")”.) If different permissions for reading and writing
    have been specified, the read permission controls who can call `ContentResolver.query()`
    on the target provider or URI, and the write permission controls who can call
    `ContentResolver.insert()`, `ContentResolver.update()`, and `ContentResolver.delete()`
    on the provider or one of its exported URIs. The checks are performed synchronously
    when one of these methods is called.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 内容提供者权限可以保护整个组件或特定的导出 URI，并且可以为读取和写入指定不同的权限。（你将在《[内容提供者权限](ch02.html#content_provider_permissions
    "Content Provider Permissions")》一章中了解更多关于权限声明的内容。）如果为读取和写入指定了不同的权限，则读取权限控制谁可以在目标提供者或
    URI 上调用`ContentResolver.query()`，而写入权限控制谁可以在提供者或其导出的 URI 上调用`ContentResolver.insert()`、`ContentResolver.update()`和`ContentResolver.delete()`。当调用这些方法时，权限检查会同步执行。
- en: Broadcast Permission Enforcement
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 广播权限强制执行
- en: When sending a broadcast, applications can require that receivers hold a particular
    permission by using the `Context.sendBroadcast (Intent intent, String receiverPermission)`
    method. Because broadcasts are asynchronous, no permission check is performed
    when calling this method. The check is performed when delivering the intent to
    registered receivers. If a target receiver does not hold the required permission,
    it is skipped and does not receive the broadcast, but no exception is thrown.
    In turn, broadcast receivers can require that broadcasters hold a specific permission
    in order to be able to target them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送广播时，应用程序可以要求接收者持有特定的权限，方法是使用`Context.sendBroadcast(Intent intent, String
    receiverPermission)`方法。由于广播是异步的，调用此方法时不会执行权限检查。权限检查是在将意图传递给已注册的接收者时进行的。如果目标接收者没有持有所需的权限，它将被跳过，并且不会接收到广播，但不会抛出异常。反过来，广播接收者也可以要求广播发送者持有特定的权限，才能将广播发送给它们。
- en: 'The required permission is specified in the manifest or when registering a
    broadcast dynamically. This permission check is also performed when delivering
    the broadcast and does not result in a `SecurityException`. Thus delivering a
    broadcast might require two permission checks: one for the broadcast sender (if
    the receiver specified a permission) and one for the broadcast receiver (if the
    sender specified a permission).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的权限可以在清单文件中指定，也可以在动态注册广播时指定。这个权限检查也会在传递广播时执行，并且不会导致`SecurityException`。因此，发送广播可能需要进行两次权限检查：一次是广播发送者的权限检查（如果接收者指定了权限），另一次是广播接收者的权限检查（如果发送者指定了权限）。
- en: Protected and Sticky Broadcasts
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 受保护和粘性广播
- en: Some system broadcasts are declared as *protected* (for example, `BOOT_COMPLETED`
    and `PACKAGE_INSTALLED`) and can only be sent by a system process running as one
    of `SYSTEM_UID`, `PHONE_UID`, `SHELL_UID`, `BLUETOOTH_UID`, or *root*. If a process
    running under a different UID tries to send a protected broadcast, it receives
    a `SecurityException` when calling one of the `sendBroadcast()` methods. Sending
    “sticky” broadcasts (if marked as sticky, the system preserves the sent `Intent`
    object after the broadcast is complete) requires that the sender holds `BROADCAST_STICKY`
    permission; otherwise, a `SecurityException` is thrown and the broadcast is not
    sent.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一些系统广播被声明为 *protected*（例如，`BOOT_COMPLETED` 和 `PACKAGE_INSTALLED`），只能由以 `SYSTEM_UID`、`PHONE_UID`、`SHELL_UID`、`BLUETOOTH_UID`
    或 *root* 身份运行的系统进程发送。如果一个以其他 UID 运行的进程试图发送受保护的广播，在调用 `sendBroadcast()` 方法时会收到
    `SecurityException`。发送“粘性”广播（如果标记为粘性，系统会在广播完成后保留发送的 `Intent` 对象）要求发送者持有 `BROADCAST_STICKY`
    权限；否则，会抛出 `SecurityException` 并且广播不会发送。
- en: System Permissions
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统权限
- en: Android’s built-in permissions are defined in the `android` package, sometimes
    also referred to as “the framework” or “the platform.” As we learned in [Chapter 1](ch01.html
    "Chapter 1. Android’s Security Model"), the core Android framework is the set
    of classes shared by system services, with some exposed via the public SDK as
    well. Framework classes are packaged in JAR files found in */system/framework/*
    (about 40 in latest releases).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Android 的内置权限在 `android` 包中定义，有时也称为“框架”或“平台”。正如我们在[第 1 章](ch01.html "第 1 章.
    Android 的安全模型")中所学到的，核心 Android 框架是由系统服务共享的一组类，其中一些通过公共 SDK 进行公开。框架类打包在 JAR 文件中，这些文件位于
    */system/framework/*（最新版本中大约 40 个）。
- en: Besides JAR libraries, the framework contains a single APK file, *framework-res.apk*.
    As the name implies, it packages framework resources (animation, drawables, layouts,
    and so on), but no actual code. Most importantly, it defines the `android` package
    and system permissions. As *framework-res.apk* is an APK file, it contains an
    *AndroidManifest.xml* file where permission groups and permissions are declared
    (see [Example 2-15](ch02.html#system_permission_definitions_in_the_man "Example 2-15. System
    permission definitions in the manifest of framework-res.apk")).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 JAR 库，框架还包含一个 APK 文件，*framework-res.apk*。顾名思义，它打包了框架资源（动画、图形、布局等），但没有实际代码。最重要的是，它定义了
    `android` 包和系统权限。由于 *framework-res.apk* 是一个 APK 文件，它包含一个 *AndroidManifest.xml*
    文件，在该文件中声明了权限组和权限（参见[示例 2-15](ch02.html#system_permission_definitions_in_the_man
    "示例 2-15. framework-res.apk 中清单的系统权限定义")）。
- en: Example 2-15. System permission definitions in the manifest of framework-res.apk
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-15. framework-res.apk 中清单的系统权限定义
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As shown in this listing, the *AndroidManifest.xml* file also declares the system’s
    protected broadcasts ➊. A *permission group* ➋ specifies a name for a set of related
    permissions. Individual permission can be added to a group by specifying the group
    name in their `permissionGroup` attribute ➌.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如本列表所示，*AndroidManifest.xml* 文件还声明了系统的受保护广播 ➊。一个 *权限组* ➋ 为一组相关权限指定了一个名称。个别权限可以通过在它们的
    `permissionGroup` 属性中指定组名来加入该组 ➌。
- en: Permission groups are used to display related permissions in the system UI,
    but each permission still needs to be requested individually. That is, applications
    cannot request that they be granted all the permissions in a group.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 权限组用于在系统 UI 中显示相关的权限，但每个权限仍然需要单独请求。也就是说，应用程序不能请求授予它们整个权限组中的所有权限。
- en: Recall that each permission has an associated protection level declared using
    the `protectionLevel` attribute, as shown at ➍.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，每个权限都有一个相关的保护级别，通过 `protectionLevel` 属性声明，如 ➍ 所示。
- en: Protection levels can be combined with *protection flags* to further constrain
    how permissions are granted. The currently defined flags are `system` (0x10) and
    `development` (0x20). The `system` flag requires that applications be part of
    the system image (that is, installed on the read-only *system* partition) in order
    to be granted a permission. For example, the `MANAGE_USB` permission, which allows
    applications to manage preferences and permissions for USB devices, is only granted
    to applications that are both signed with the platform signing key and installed
    on the *system* partition ➎. The `development` flag marks development permissions
    ➏, which we’ll discuss after presenting signature permissions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 保护级别可以与 *保护标志* 结合使用，进一步限制权限的授予方式。目前定义的标志有 `system`（0x10）和 `development`（0x20）。`system`
    标志要求应用程序必须是系统镜像的一部分（即安装在只读的 *system* 分区上），才能获得权限。例如，`MANAGE_USB` 权限，允许应用程序管理 USB
    设备的偏好设置和权限，只会授予那些同时使用平台签名密钥签名并安装在 *system* 分区上的应用程序 ➎。`development` 标志标记了开发权限
    ➏，我们将在介绍完签名权限后进行讨论。
- en: Signature Permissions
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 签名权限
- en: As discussed in [Chapter 1](ch01.html "Chapter 1. Android’s Security Model"),
    all Android applications are required to be code signed with a signature key controlled
    by the developer. This applies to system applications and the framework resource
    package as well. We discuss package signing in detail in [Chapter 3](ch03.html
    "Chapter 3. Package Management"), but for now let’s say a few words about how
    system applications are signed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第 1 章](ch01.html "第 1 章. Android 的安全模型")中讨论的那样，所有 Android 应用程序都需要使用开发者控制的签名密钥进行代码签名。这同样适用于系统应用程序和框架资源包。我们在[第
    3 章](ch03.html "第 3 章. 包管理")中会详细讨论包签名的问题，但现在我们先简单说几句关于系统应用签名的情况。
- en: 'System applications are signed by a *platform key*. By default, there are four
    different keys in the current Android source tree: *platform*, *shared*, *media*,
    and *testkey* (*releasekey* for release builds). All packages considered part
    of the core platform (System UI, Settings, Phone, Bluetooth, and so on) are signed
    with the *platform* key; the search- and contacts-related packages with the *shared*
    key; the gallery app and media related providers with the *media* key; and everything
    else (including packages that don’t explicitly specify the signing key in their
    makefile) with the *testkey* (or *releasekey*). The *framework-res.apk* APK that
    defines system permissions is signed with the *platform* key. Thus any app trying
    to request a system permission with *signature* protection level needs to be signed
    with the same key as the framework resource package.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 系统应用程序是由 *平台密钥* 签名的。默认情况下，当前 Android 源代码树中有四种不同的密钥：*平台*、*共享*、*媒体* 和 *testkey*（发布版本使用
    *releasekey*）。所有被视为核心平台的一部分的包（如系统 UI、设置、电话、蓝牙等）都由 *平台* 密钥签名；与搜索和联系人相关的包由 *共享*
    密钥签名；图库应用和与媒体相关的提供者由 *媒体* 密钥签名；其他所有包（包括那些在其 makefile 中未明确指定签名密钥的包）都由 *testkey*（或
    *releasekey*）签名。定义系统权限的 *framework-res.apk* APK 文件是由 *平台* 密钥签名的。因此，任何试图请求具有 *签名*
    保护级别的系统权限的应用程序，都需要使用与框架资源包相同的密钥签名。
- en: For example, the `NET_ADMIN` permission shown in [Example 2-15](ch02.html#system_permission_definitions_in_the_man
    "Example 2-15. System permission definitions in the manifest of framework-res.apk")
    (which allows a granted application to control network interfaces), is declared
    with the *signature* protection level ➍ and can only be granted to applications
    signed with the *platform* key.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[示例 2-15](ch02.html#system_permission_definitions_in_the_man "示例 2-15. 系统权限定义在
    framework-res.apk 的清单中") 中显示的 `NET_ADMIN` 权限（允许被授权的应用程序控制网络接口）是使用 *签名* 保护级别 ➍
    声明的，并且只能授予使用 *平台* 密钥签名的应用程序。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The Android open source repository (AOSP) includes pregenerated test keys
    that are used by default when signing compiled packages. They should never be
    used for production builds because they are public and available to anyone who
    downloads Android source code. Release builds should be signed with newly generated
    private keys that belong only to the build owner. Keys can be generated using
    the* make_key *script, which is included in the* development/tools/ *AOSP directory.
    See the* build/target/product/security/README *file for details on platform key
    generation.*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*Android 开源仓库（AOSP）包括预生成的测试密钥，这些密钥在默认情况下用于签署已编译的包。它们不应在生产版本中使用，因为它们是公开的，任何下载
    Android 源代码的人都可以获取。发布版应该使用仅属于构建所有者的新生成的私钥进行签名。密钥可以通过* make_key *脚本生成，该脚本包含在* development/tools/
    *AOSP 目录中。有关平台密钥生成的详细信息，请参阅* build/target/product/security/README *文件。*'
- en: Development Permissions
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发权限
- en: Traditionally, the Android permission model does not allow for dynamically granting
    and revoking permissions, and the set of granted permission for an application
    is fixed at install time. However, since Android 4.2, this rule has been relaxed
    a little by adding a number of *development permissions* (such as `READ_LOGS`
    and `WRITE_SECURE_SETTINGS`). Development permission can be granted or revoked
    on demand using the *pm grant* and *pm revoke* commands on the Android shell.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，Android 的权限模型不允许动态授予和撤销权限，应用的已授予权限集在安装时就已固定。然而，自 Android 4.2 起，通过添加一系列*开发权限*（如
    `READ_LOGS` 和 `WRITE_SECURE_SETTINGS`），此规则有所放宽。开发权限可以通过 Android shell 上的*pm grant*
    和 *pm revoke* 命令按需授予或撤销。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Of course, this operation is not available to everyone and is protected by
    the `GRANT_REVOKE_PERMISSIONS` signature permission. It is granted to the* android.uid.shell
    *shared user ID (UID 2000), and to all processes started from the Android shell
    (which also runs as UID 2000).*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*当然，这一操作并非对所有人开放，且受`GRANT_REVOKE_PERMISSIONS`签名权限的保护。该权限授予* android.uid.shell
    *共享用户 ID（UID 2000），并授予所有从 Android shell 启动的进程（它们也以 UID 2000 运行）。*'
- en: Shared User ID
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享用户 ID
- en: Android applications signed with the same key can request the ability to run
    as the same UID, and optionally in the same process. This feature is referred
    to as *shared user ID* and is extensively used by core framework services and
    system applications. Because it can have subtle effects on process accounting
    and application management, the Android team does not recommend that third-party
    applications use it, but it is available to user-installed applications as well.
    Additionally, switching an existing applications that does not use a shared user
    ID to a shared user ID is not supported, so cooperating applications that need
    to use shared user ID should be designed and released as such from the start.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同密钥签名的 Android 应用可以请求以相同的 UID 运行，并可选择在同一进程中运行。此功能称为*共享用户 ID*，被核心框架服务和系统应用广泛使用。由于它可能对进程计数和应用管理产生微妙的影响，Android
    团队不推荐第三方应用使用此功能，但它同样对用户安装的应用可用。此外，切换一个未使用共享用户 ID 的现有应用到共享用户 ID 是不支持的，因此需要使用共享用户
    ID 的合作应用应该从一开始就设计并发布为此方式。
- en: Shared user ID is enabled by adding the `sharedUserId` attribute to *AndroidManifest.xml*’s
    root element. The user ID specified in the manifest needs to be in Java package
    format (containing at least one dot [`.`]) and is used as an identifier, much
    like package names for applications. If the specified shared UID does not exist,
    it is created. If another package with the same shared UID is already installed,
    the signing certificate is compared to that of the existing package, and if they
    do not match, an `INSTALL_FAILED_SHARED_USER_INCOMPATIBLE` error is returned and
    installation fails.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 共享用户 ID 通过在 *AndroidManifest.xml* 的根元素中添加 `sharedUserId` 属性来启用。清单中指定的用户 ID 需要采用
    Java 包格式（至少包含一个点 [`.`]），并作为标识符使用，类似于应用程序的包名。如果指定的共享 UID 不存在，则会创建它。如果已经安装了另一个具有相同共享
    UID 的包，则会将签名证书与现有包的证书进行比较，如果不匹配，则返回 `INSTALL_FAILED_SHARED_USER_INCOMPATIBLE`
    错误，安装失败。
- en: Adding the `sharedUserId` attribute to a new version of an installed app will
    cause it to change its UID, which would result in losing access to its own files
    (that was the case in some early Android versions). Therefore, this is disallowed
    by the system, which will reject the update with the `INSTALL_FAILED_UID_CHANGED`
    error. In short, if you plan to use shared UID for your apps, you have to design
    for it from the start, and must have used it since the very first release.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将`sharedUserId`属性添加到已安装应用程序的新版本时，会导致它更改其UID，这将导致无法访问自己的文件（这是某些早期Android版本中的情况）。因此，系统不允许这样做，会拒绝更新并返回`INSTALL_FAILED_UID_CHANGED`错误。简而言之，如果你打算为应用使用共享UID，必须从一开始就为此进行设计，并且必须从第一次发布开始就使用它。
- en: 'The shared UID itself is a first class object in the system’s package database
    and is treated much like applications: it has an associated signing certificate(s)
    and permissions. Android has five built-in shared UIDs, which are automatically
    added when the system is bootstrapped:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 共享UID本身是系统包数据库中的一个一类对象，类似于应用程序，它具有关联的签名证书和权限。Android有五个内置的共享UID，这些UID在系统引导时会自动添加：
- en: '*android.uid.system* (SYSTEM_UID, 1000)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*android.uid.system*（SYSTEM_UID，1000）'
- en: '*android.uid.phone* (PHONE_UID, 1001)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*android.uid.phone*（PHONE_UID，1001）'
- en: '*android.uid.bluetooth* (BLUETOOH_UID, 1002)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*android.uid.bluetooth*（BLUETOOH_UID，1002）'
- en: '*android.uid.log* (LOG_UID, 1007)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*android.uid.log*（LOG_UID，1007）'
- en: '*android.uid.nfc* (NFC_UID, 1027)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*android.uid.nfc*（NFC_UID，1027）'
- en: '[Example 2-16](ch02.html#definition_of_the_androiddotuiddotsystem "Example 2-16. Definition
    of the android.uid.system shared user") shows how the *android.uid.system* shared
    user is defined:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例2-16](ch02.html#definition_of_the_androiddotuiddotsystem "示例2-16. android.uid.system共享用户的定义")展示了如何定义*android.uid.system*共享用户：'
- en: Example 2-16. Definition of the android.uid.system shared user
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-16. android.uid.system共享用户的定义
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, apart from having a bunch of scary permissions (about 66 on
    a 4.4 device), the definition is very similar to the package declarations shown
    earlier. Conversely, packages that are part of a shared user do not have an associated
    granted permission list. Instead, they inherit the permissions of the shared user,
    which are a union of the permissions requested by all currently installed packages
    with the same shared user ID. One side effect of this is that if a package is
    part of a shared user, it can access APIs that it hasn’t explicitly requested
    permissions for, as long as some package with the same shared user ID has already
    requested them. Permissions are dynamically removed from the `<shared-user>` definition
    as packages are installed or uninstalled though, so the set of available permissions
    is neither guaranteed nor constant.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，除了拥有一堆令人担忧的权限（在4.4设备上约66个），其定义与前面展示的包声明非常相似。相反，作为共享用户一部分的包没有关联的已授予权限列表。它们继承了共享用户的权限，这些权限是所有当前安装的具有相同共享用户ID的包请求的权限的并集。一个副作用是，如果一个包是共享用户的一部分，它可以访问那些它没有显式请求权限的API，只要某个具有相同共享用户ID的包已经请求了这些权限。然而，权限会在安装或卸载包时动态地从`<shared-user>`定义中移除，因此可用的权限集合既不保证也不是固定的。
- en: '[Example 2-17](ch02.html#package_declaration_of_an_application_th "Example 2-17. Package
    declaration of an application that runs under a shared user ID") shows how the
    declaration of the `KeyChain` system app that runs under a shared user ID looks
    like. As you can see, it references the shared user with the `sharedUserId` attribute
    and lacks explicit permission declarations:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例2-17](ch02.html#package_declaration_of_an_application_th "示例2-17. 在共享用户ID下运行的应用程序的包声明")展示了如何声明在共享用户ID下运行的`KeyChain`系统应用程序。如你所见，它通过`sharedUserId`属性引用了共享用户，并且没有显式的权限声明：'
- en: Example 2-17. Package declaration of an application that runs under a shared
    user ID
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-17. 在共享用户ID下运行的应用程序的包声明
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The shared UID is not just a package management construct; it actually maps
    to a shared Linux UID at runtime as well. [Example 2-18](ch02.html#applications_running_under_a_shared_uid
    "Example 2-18. Applications running under a shared UID (system)") shows an example
    of two system apps running as the *system* user (UID 1000):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 共享UID不仅仅是一个包管理构造；它实际上在运行时也映射到一个共享的Linux UID。[示例2-18](ch02.html#applications_running_under_a_shared_uid
    "示例2-18. 运行在共享UID下的应用程序（系统）")展示了两个作为*system*用户（UID 1000）运行的系统应用程序的示例：
- en: Example 2-18. Applications running under a shared UID (system)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-18. 运行在共享UID下的应用程序（系统）
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Applications that are part of a shared user can run in the same process, and
    because they already have the same Linux UID and can access the same system resources,
    this typically does not require any additional modifications. A common process
    can be requested by specifying the same process name in the `process` attribute
    of the `<application>` tag in the manifests of all apps that need to run in one
    process. While the obvious result of this is that the apps can share memory and
    communicate directly instead of using IPC, some system services allow special
    access to components running in the same process (for example, direct access to
    cached passwords or getting authentication tokens without showing UI prompts).
    Google applications (such as Play Services and the Google location service) take
    advantage of this by requesting to run in the same process as the Google login
    service in order to be able to sync data in the background without user interaction.
    Naturally, they are signed with the same certificate and are part of the *com.google.uid.shared*
    shared user.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 属于共享用户的一部分的应用可以在同一进程中运行，由于它们已经具有相同的Linux UID并能够访问相同的系统资源，通常不需要任何额外的修改。可以通过在所有需要在同一进程中运行的应用的`<application>`标签的`process`属性中指定相同的进程名称来请求一个公共进程。显而易见，这样做的结果是这些应用可以共享内存并直接通信，而不是使用IPC，某些系统服务允许对同一进程中运行的组件进行特殊访问（例如，直接访问缓存的密码或在不显示UI提示的情况下获取认证令牌）。Google应用（如Play服务和Google位置服务）通过请求与Google登录服务在同一进程中运行来利用这一点，以便能够在后台同步数据而无需用户交互。自然，它们使用相同的证书签名，并且是*com.google.uid.shared*共享用户的一部分。
- en: Custom Permissions
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义权限
- en: '*Custom permissions* are simply permissions declared by third-party applications.
    When declared, they can be added to application components for static enforcement
    by the system, or the application can dynamically check to see if callers have
    been granted the permission using the `checkPermission()` or `enforcePermission()`
    methods of the `Context` class. As with built-in permissions, applications can
    define permission groups that their custom permissions are added to. For example,
    [Example 2-19](ch02.html#custom_permission_treecomma_permission_g "Example 2-19. Custom
    permission tree, permission group, and permission declaration") shows the declaration
    of a permission group ➋ and the permission belonging to that group ➌.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*自定义权限*只是第三方应用声明的权限。当声明后，它们可以被添加到应用组件中，以便由系统进行静态强制执行，或者应用可以动态检查调用者是否已通过`checkPermission()`或`enforcePermission()`方法被授予该权限，这些方法属于`Context`类。与内建权限一样，应用可以定义权限组，并将自定义权限添加到这些组中。例如，[示例2-19](ch02.html#custom_permission_treecomma_permission_g
    "示例2-19. 自定义权限树、权限组和权限声明")展示了一个权限组的声明➋及属于该组的权限➌。'
- en: Example 2-19. Custom permission tree, permission group, and permission declaration
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-19. 自定义权限树、权限组和权限声明
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As with system permissions, if the protection level is *normal* or *dangerous*,
    custom permission will be granted automatically when the user okays the confirmation
    dialog. In order to be able to control which applications are granted a custom
    permission, you need to declare it with the *signature* protection level to guarantee
    that it will only be granted to applications signed with the same key.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与系统权限类似，如果保护级别为*正常*或*危险*，当用户确认对话框时，自定义权限将自动授予。为了能够控制哪些应用被授予自定义权限，你需要声明其*签名*保护级别，以保证该权限只会授予使用相同密钥签名的应用。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The system can only grant a permission that it knows about, which means that
    applications that define custom permissions need to be installed before the applications
    that make use of those permissions are installed. If an application requests a
    permission unknown to the system, it is ignored and not granted.*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统只能授予它已知的权限，这意味着定义自定义权限的应用必须在使用这些权限的应用之前安装。如果应用请求系统未知的权限，该权限将被忽略并不会被授予。*'
- en: Applications can also add new permissions dynamically using the `android.content.pm.PackageManager.addPermission()`
    API and remove them with the matching `removePermision()` API. Such dynamically
    added permissions must belong to a *permission tree* defined by the application.
    Applications can only add or remove permissions from a permission tree in their
    own package or another package running as the same shared user ID.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序还可以通过`android.content.pm.PackageManager.addPermission()`API动态添加新权限，并使用匹配的`removePermission()`API将其删除。这些动态添加的权限必须属于应用定义的*权限树*。应用只能从自己的包或与其共享用户ID的另一个包中添加或删除权限。
- en: Permission tree names are in reverse domain notation and a permission is considered
    to be in a permission tree if its name is prefixed with the permission tree name
    plus a dot (`.`). For example, the `com.example.app.permission.PERMISSION2` permission
    is a member of the `com.example.app.permission` tree defined in [Example 2-19](ch02.html#custom_permission_treecomma_permission_g
    "Example 2-19. Custom permission tree, permission group, and permission declaration")
    at ➊. [Example 2-20](ch02.html#adding_a_dynamic_permission_programmatic "Example 2-20. Adding
    a dynamic permission programmatically") shows how to add a dynamic permission
    programmatically.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 权限树名称采用反向域名表示法，如果一个权限的名称以权限树名称加上点号（`.`）作为前缀，则该权限被视为属于该权限树。例如，`com.example.app.permission.PERMISSION2`权限是`com.example.app.permission`树的成员，定义在[示例
    2-19](ch02.html#custom_permission_treecomma_permission_g "示例 2-19. 自定义权限树、权限组和权限声明")中的➊位置。[示例
    2-20](ch02.html#adding_a_dynamic_permission_programmatic "示例 2-20. 通过编程方式添加动态权限")展示了如何通过编程方式添加动态权限。
- en: Example 2-20. Adding a dynamic permission programmatically
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-20. 通过编程方式添加动态权限
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Dynamically added permissions are added to the package database (*/data/system/packages.xml*).
    They persist across reboots, just like permissions defined in the manifest, but
    they have an additional `type` attribute set to *dynamic*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 动态添加的权限会被添加到包数据库（*/data/system/packages.xml*）中。它们会在重启后持续存在，就像在清单中定义的权限一样，但它们有一个额外的`type`属性，值为*dynamic*。
- en: Public and Private Components
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共和私有组件
- en: Components defined in the *AndroidManifest.xml* file can be public or private.
    Private components can be called only by the declaring application, while public
    ones are available to other applications as well.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在*AndroidManifest.xml*文件中定义的组件可以是公开的或私有的。私有组件只能被声明的应用调用，而公开组件则对其他应用也可用。
- en: With the exception of content providers, all components are private by default.
    Because the purpose of content providers is to share data with other applications,
    content providers were initially public by default, but this behavior changed
    in Android 4.2 (API Level 17). Applications that target API Level 17 or later
    now get private content providers by default, but they are kept public for backward
    compatibility when targeting a lower API level.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除内容提供者外，所有组件默认都是私有的。因为内容提供者的目的是与其他应用共享数据，内容提供者最初默认是公开的，但在Android 4.2（API级别17）中，这一行为发生了变化。现在，目标API级别为17或更高的应用默认获得私有内容提供者，但为了向后兼容，目标较低API级别的应用仍然保持公开。
- en: Components can be made public by explicitly setting the `exported` attribute
    to `true`, or implicitly by declaring an intent filter. Components that have an
    intent filter but that do not need to be public can be made private by setting
    the `exported` attribute to `false`. If a component is not exported, calls from
    external applications are blocked by the activity manager, regardless of the permissions
    the calling process has been granted (unless it is running as *root* or *system*).
    [Example 2-21](ch02.html#keeping_a_component_private_by_setting "Example 2-21. Keeping
    a component private by setting exported="false"") shows how to keep a component
    private by setting the `exported` attribute to `false`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以通过显式设置`exported`属性为`true`，或者通过声明意图过滤器隐式设置为公开。具有意图过滤器但不需要公开的组件，可以通过设置`exported`属性为`false`来使其私有。如果一个组件未被导出，来自外部应用的调用将被活动管理器阻止，无论调用进程是否拥有相应权限（除非它以*root*或*system*身份运行）。[示例
    2-21](ch02.html#keeping_a_component_private_by_setting "示例 2-21. 通过设置exported=\"false\"保持组件私有")展示了如何通过将`exported`属性设置为`false`来保持组件私有。
- en: Example 2-21. Keeping a component private by setting `exported="false"`
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-21. 通过设置`exported="false"`保持组件私有
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Unless explicitly intended for public consumption, all public components should
    be protected by a custom permission.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 除非明确用于公开，否则所有公共组件都应该通过自定义权限进行保护。
- en: Activity and Service Permissions
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动和服务权限
- en: Activities and services can each be protected by a single permission set with
    the `permission` attribute of the target component. The activity permission is
    checked when other applications call `Context.startActivity()` or `Con text.startActivityForResult()`
    with an intent that resolves to that activity. For services, the permission is
    checked when other applications call one of `Context.startService()`, `stopService()`,
    or `bindService()` with an intent that resolves to the service.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 活动和服务可以通过目标组件的`permission`属性来分别由单一权限保护。当其他应用程序使用解析到该活动的意图调用`Context.startActivity()`或`Context.startActivityForResult()`时，将检查活动权限。对于服务，当其他应用程序使用解析到该服务的意图调用`Context.startService()`、`stopService()`或`bindService()`时，将检查服务权限。
- en: For example, [Example 2-22](ch02.html#protecting_activities_and_services_with
    "Example 2-22. Protecting activities and services with custom permissions") shows
    two custom permissions, `START_MY_ACTIVITY` and `USE_MY_SERVICE`, set to an activity
    ➊ and service ➋, respectively. Applications that want to use these components
    need to request the respective permissions using the `<uses-permission>` tag in
    their manifest.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[示例 2-22](ch02.html#protecting_activities_and_services_with "示例 2-22. 使用自定义权限保护活动和服务")展示了两个自定义权限，`START_MY_ACTIVITY`和`USE_MY_SERVICE`，分别与活动
    ➊ 和服务 ➋ 关联。希望使用这些组件的应用程序需要在其清单中使用`<uses-permission>`标签请求相应的权限。
- en: Example 2-22. Protecting activities and services with custom permissions
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-22. 使用自定义权限保护活动和服务
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Broadcast Permissions
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广播权限
- en: Unlike activities and services, permissions for broadcast receivers can be specified
    both by the receiver itself and by the application sending the broadcast. When
    sending a broadcast, applications can either use the `Context.sendBroadcast(Intent
    intent)` method to send a broadcast to be delivered to all registered receives,
    or limit the scope of components that receive the broadcast by using the `Context.sendBroadcast(Intent
    intent, String receiverPermission)`. The `receiverPermission` parameter specifies
    the permission that interested receivers need to hold in order to receive the
    broadcast. Alternatively, starting with Android 4.0, senders can use the `Intent.setPackage(String
    packageName)` to limit the scope of receivers to those defined in the specified
    package. On multi-user devices, system applications that hold the `INTERACT_ACROSS_USERS`
    permission can send a broadcast that is delivered only to a specific user by the
    using the `sendBroadcastAsUser(Intent intent, UserHandle user)` and `sendBroadcastAsUser(Intent
    intent, UserHandle user, String receiverPermission)` methods.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与活动和服务不同，广播接收器的权限既可以由接收器本身指定，也可以由发送广播的应用程序指定。在发送广播时，应用程序可以使用`Context.sendBroadcast(Intent
    intent)`方法发送广播，该广播将被传递给所有注册的接收器，或者通过使用`Context.sendBroadcast(Intent intent, String
    receiverPermission)`限制接收广播的组件范围。`receiverPermission`参数指定了感兴趣的接收器需要持有的权限才能接收广播。或者，从
    Android 4.0 开始，发送方可以使用`Intent.setPackage(String packageName)`来限制接收广播的接收器范围，仅限于指定包中定义的接收器。在多用户设备上，持有`INTERACT_ACROSS_USERS`权限的系统应用程序可以通过使用`sendBroadcastAsUser(Intent
    intent, UserHandle user)`和`sendBroadcastAsUser(Intent intent, UserHandle user,
    String receiverPermission)`方法，将广播仅发送给特定用户。
- en: Receivers can limit who can send them broadcasts by specifying a permission
    using the `permission` attribute of the `<receiver>` tag in the manifest for statically
    registered receivers, or by passing the required permission to the `Context.registerReceiver(BroadcastReceiver
    receiver, IntentFilter filter, String broadcastPermission, Handler scheduler)`
    method for dynamically registered receivers.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接收器可以通过在清单中的`<receiver>`标签的`permission`属性中指定权限来限制谁可以向它们发送广播，对于静态注册的接收器，或者通过将所需权限传递给`Context.registerReceiver(BroadcastReceiver
    receiver, IntentFilter filter, String broadcastPermission, Handler scheduler)`方法来限制动态注册的接收器。
- en: Only broadcasters that have been granted the required permission will be able
    to send a broadcast to that receiver. For example, device administration applications
    that enforce systemwide security policies (we discuss device administration in
    [Chapter 9](ch09.html "Chapter 9. Enterprise Security")) require the `BIND_DEVICE_ADMIN`
    permission in order to receive the `DEVICE_ADMIN_ENABLED` broadcast. Because this
    is a system permission with protection level *signature*, requiring the permission
    guarantees that only the system can activate device administration applications.
    For example, [Example 2-23](ch02.html#specifying_a_permission_for_a_statically
    "Example 2-23. Specifying a permission for a statically registered broadcast receiver")
    shows how the default Android Email application specifies the `BIND_DEVICE_ADMIN`
    ➊ permission for its `PolicyAdmin` receiver.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 只有被授予所需权限的广播发送者才能向该接收器发送广播。例如，执行系统安全策略的设备管理应用程序（我们在[第9章](ch09.html "第9章. 企业安全")讨论设备管理）需要`BIND_DEVICE_ADMIN`权限才能接收`DEVICE_ADMIN_ENABLED`广播。因为这是一个具有*签名*保护级别的系统权限，要求此权限可以确保只有系统才能激活设备管理应用程序。例如，[示例
    2-23](ch02.html#specifying_a_permission_for_a_statically "示例 2-23. 为静态注册的广播接收器指定权限")展示了默认的Android邮件应用程序如何为其`PolicyAdmin`接收器指定`BIND_DEVICE_ADMIN`
    ➊权限。
- en: Example 2-23. Specifying a permission for a statically registered broadcast
    receiver
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-23. 为静态注册的广播接收器指定权限
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As with other components, private broadcast receivers can only receive broadcasts
    originating from the same application.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他组件一样，私有广播接收器只能接收来自同一应用程序的广播。
- en: Content Provider Permissions
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容提供者权限
- en: As mentioned in “[The Nature of Permissions](ch02.html#nature_of_permissions
    "The Nature of Permissions")”, content providers have a more complex permission
    model than other components, as we’ll describe in detail in this section.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如在“[权限的本质](ch02.html#nature_of_permissions "权限的本质")”一节中提到的，内容提供者具有比其他组件更复杂的权限模型，我们将在本节中详细描述。
- en: Static Provider Permissions
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态提供者权限
- en: While a single permissions that controls access to the whole provider can be
    specified using the `permission` attribute, most providers employ different permission
    for reading and writing, and can also specify per-URI permissions. One example
    of a provider that uses different permissions for reading and writing is the built-in
    `ContactsProvider`. [Example 2-24](ch02.html#contactsprovider_permission_declarations
    "Example 2-24. ContactsProvider permission declarations") shows the declaration
    of its `ContactsProvider2` class.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用`permission`属性指定控制整个提供者访问的单一权限，但大多数提供者会为读取和写入操作使用不同的权限，并且还可以为每个URI指定权限。一个使用不同权限来进行读取和写入的提供者的例子是内置的`ContactsProvider`。[示例
    2-24](ch02.html#contactsprovider_permission_declarations "示例 2-24. ContactsProvider
    权限声明")展示了其`ContactsProvider2`类的声明。
- en: Example 2-24. `ContactsProvider` permission declarations
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-24. `ContactsProvider` 权限声明
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The provider uses the `readPermission` attribute to specify one permission for
    reading data (`READ_CONTACTS` ➊), and a separate permission for writing data using
    the `writePermission` attribute (`WRITE_CONTACTS` ➋). Thus, applications that
    only hold the `READ_CONTACTS` permission can only call the `query()` method of
    the provider, and calls to `insert()`, `update()`, or `delete()` require the caller
    to hold the `WRITE_CONTACTS` permission. Applications that need to both read and
    write to the contacts provider need to hold both permissions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 该提供者使用`readPermission`属性指定用于读取数据的权限（`READ_CONTACTS` ➊），并使用`writePermission`属性指定用于写入数据的单独权限（`WRITE_CONTACTS`
    ➋）。因此，只有持有`READ_CONTACTS`权限的应用程序才能调用提供者的`query()`方法，而对`insert()`、`update()`或`delete()`方法的调用则要求调用者持有`WRITE_CONTACTS`权限。需要同时读取和写入联系人提供者的应用程序必须同时持有这两种权限。
- en: When the global read and write permission are not sufficiently flexible, providers
    can specify per-URI permissions to protect a certain subset of their data. Per-URI
    permissions have higher priority than the component-level permission (or read
    and write permissions, if specified separately). Thus if an application wants
    to access a content provider URI that has an associated permission, it needs to
    hold only the target URI’s permission, and not the component-level permission.
    In [Example 2-24](ch02.html#contactsprovider_permission_declarations "Example 2-24. ContactsProvider
    permission declarations"), the `ContactsProvider2` uses the `<path-permission>`
    tag to require that applications trying to read photos of contacts hold the `GLOBAL_SEARCH`
    permission ➌. As per-URI permissions override the global read permission, interested
    applications do not need to hold the `READ_CONTACTS` permission. In practice,
    the `GLOBAL_SEARCH` permission is used to grant read-only access to some of the
    system providers’ data to Android’s search system, which cannot be expected to
    hold read permissions to all providers.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当全局的读写权限不够灵活时，提供者可以指定每个URI的权限，以保护其数据的某个子集。每个URI权限的优先级高于组件级权限（或者，如果指定了的话，也高于读写权限）。因此，如果应用程序想访问一个具有相关权限的内容提供者URI，它只需要持有目标URI的权限，而不需要持有组件级权限。在[示例
    2-24](ch02.html#contactsprovider_permission_declarations "示例 2-24. ContactsProvider权限声明")中，`ContactsProvider2`使用`<path-permission>`标签要求试图读取联系人照片的应用持有`GLOBAL_SEARCH`权限➌。由于每个URI的权限会覆盖全局读权限，因此感兴趣的应用不需要持有`READ_CONTACTS`权限。在实际应用中，`GLOBAL_SEARCH`权限用于授权Android的搜索系统只读访问某些系统提供者的数据，而无需期望它持有所有提供者的读权限。
- en: Dynamic Provider Permissions
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态提供者权限
- en: While statically defined per-URI permissions can be quite powerful, applications
    sometimes need to grant temporary access to a particular piece of data (referred
    to by its URI) to other apps, without requiring that they hold a particular permission.
    For example, an email or messaging application may need to cooperate with an image
    viewer app in order to display an attachment. Because the app cannot know the
    URIs of attachments in advance, if it used static per-URI permissions, it would
    need to grant read access to all attachments to the image viewer app, which is
    undesirable.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然静态定义的每个URI权限功能强大，但有时应用程序需要向其他应用授予对特定数据（通过其URI引用）的临时访问权限，而不要求它们持有特定的权限。例如，电子邮件或消息应用可能需要与图像查看器应用配合，以显示附件。由于该应用无法提前知道附件的URI，如果它使用静态的每个URI权限，它将需要为图像查看器应用授予对所有附件的读取权限，这是不理想的。
- en: To avoid this situation and potential security concern, applications can dynamically
    grant temporary per-URI access using the `Context.grantUriPermission(String toPackage,
    Uri uri, int modeFlags)` method and revoke access using the matching `revokeUriPermission(Uri
    uri, int modeFlags)` method. Temporary per-URI access is enabled by setting the
    global `grantUriPermissions` attribute to `true` or by adding a `<grant-uri-permission>`
    tag in order to enable it for a specific URI. For example, [Example 2-25](ch02.html#attachmentprovider_declaration_from_the
    "Example 2-25. AttachmentProvider declaration from the Email app") shows how the
    Email application uses the `grantUriPermissions` attribute ➊ to allow temporary
    access to attachments without requiring the `READ_ATTACHMENT` permission.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况和潜在的安全问题，应用程序可以使用`Context.grantUriPermission(String toPackage, Uri uri,
    int modeFlags)`方法动态授予临时的每个URI访问权限，并通过匹配的`revokeUriPermission(Uri uri, int modeFlags)`方法撤销访问权限。通过将全局`grantUriPermissions`属性设置为`true`，或通过添加`<grant-uri-permission>`标签来为特定的URI启用临时每个URI访问权限。例如，[示例
    2-25](ch02.html#attachmentprovider_declaration_from_the "示例 2-25. 邮件应用中的AttachmentProvider声明")展示了邮件应用如何使用`grantUriPermissions`属性➊来允许临时访问附件，而不需要`READ_ATTACHMENT`权限。
- en: Example 2-25. `AttachmentProvider` declaration from the Email app
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-25. 邮件应用中的`AttachmentProvider`声明
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In practice, applications rarely use the `Context.grantPermission()` and `revokePermission()`
    methods directly to allow per-URI access. Instead, they set the `FLAG_GRANT_READ_URI_PERMISSION`
    or `FLAG_GRANT_WRITE_URI_PERMISSION` flags to the intent used to start the cooperating
    application (image viewer in our example). When those flags are set, the recipient
    of the intent is granted permission to perform read or write operations on the
    URI in the intent’s data.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，应用程序很少直接使用 `Context.grantPermission()` 和 `revokePermission()` 方法来允许按 URI
    访问权限。相反，它们将 `FLAG_GRANT_READ_URI_PERMISSION` 或 `FLAG_GRANT_WRITE_URI_PERMISSION`
    标志设置到用于启动协作应用程序（在我们的示例中是图像查看器）的意图中。当这些标志被设置时，接收意图的应用程序将被授予对意图数据中 URI 进行读取或写入操作的权限。
- en: Beginning with Android 4.4 (API Level 19), per-URI access grants can be persisted
    across device reboots with the `ContentResolver.takePersistableUriPermission()`
    method, if the received intent has the `FLAG_GRANT_PERSISTABLE_URI_PERMISSION`
    flag set. Grants are persisted to the */data/system/urigrants.xml* file and can
    be revoked by calling the `releasePersistableUriPermission()` method. Both transient
    and persistent per-URI access grants are managed by the system `ActivityManagerService`,
    which APIs related to per-URI access call internally.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Android 4.4（API 级别 19）开始，按 URI 的访问权限可以通过 `ContentResolver.takePersistableUriPermission()`
    方法在设备重启后保持，如果接收到的意图设置了 `FLAG_GRANT_PERSISTABLE_URI_PERMISSION` 标志。权限被持久化到 */data/system/urigrants.xml*
    文件中，可以通过调用 `releasePersistableUriPermission()` 方法撤销。系统的 `ActivityManagerService`
    会管理所有的短期和持久性按 URI 访问权限的授予，相关的 API 内部调用处理这些权限。
- en: Beginning with Android 4.1 (API level 16), applications can use the `ClipData`
    facility^([[16](#ftn.ch02fn06)]) of intents to add more than one content URI to
    temporarily be granted access to.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Android 4.1（API 级别 16）开始，应用程序可以使用意图的 `ClipData` 功能^([[16](#ftn.ch02fn06)])，将多个内容
    URI 临时授予访问权限。
- en: Per-URI access is granted using one of the `FLAG_GRANT_*` intent flags, and
    automatically revoked when the task of the called application finishes, so there
    is no need to call `revokePermission()`. [Example 2-26](ch02.html#using_the_flagunderscoregrantunderscorer
    "Example 2-26. Using the FLAG_GRANT_READ_URI_PERMISSION flag to start a viewer
    application") shows how the Email application creates an intent that launches
    an attachment viewer application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 URI 的访问权限是通过 `FLAG_GRANT_*` 意图标志之一授予的，并且在被调用的应用程序的任务完成时自动撤销，因此无需调用 `revokePermission()`。
    [示例 2-26](ch02.html#using_the_flagunderscoregrantunderscorer "示例 2-26. 使用 FLAG_GRANT_READ_URI_PERMISSION
    标志启动查看器应用程序") 展示了电子邮件应用程序如何创建一个启动附件查看器应用程序的意图。
- en: Example 2-26. Using the `FLAG_GRANT_READ_URI_PERMISSION` flag to start a viewer
    application
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-26. 使用 `FLAG_GRANT_READ_URI_PERMISSION` 标志启动查看器应用程序
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Pending Intents
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 待处理意图
- en: Pending intents are neither an Android component nor a permission, but because
    they allow an application to grant its own permissions to another application,
    we discuss them here.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 待处理意图既不是 Android 组件也不是权限，但因为它们允许一个应用程序向另一个应用程序授予自己的权限，所以我们在这里讨论它们。
- en: Pending intents encapsulate an intent and a target action to perform with it
    (start an activity, send a broadcast, and so on). The main difference from “regular”
    intents is that pending intents also include the identity of the applications
    that created them. This allows pending intents to be handed to other applications,
    which can use them to perform the specified action using the identity and permissions
    of the original application. The identity stored in pending intents is guaranteed
    by the system `ActivityManagerService`, which keeps track of the currently active
    pending intents.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 待处理意图封装了一个意图和一个要执行的目标操作（启动活动、发送广播等）。与“常规”意图的主要区别是，待处理意图还包括创建它们的应用程序的身份。这使得待处理意图可以被传递给其他应用程序，后者可以使用原始应用程序的身份和权限执行指定的操作。待处理意图中存储的身份由系统的
    `ActivityManagerService` 保证，后者跟踪当前活动的待处理意图。
- en: Pending intents are used to implement alarms and notifications in Android. Alarms
    and notifications allow any application to specify an action that needs to be
    performed on its behalf, either at a specified time for alarms, or when the user
    interacts with a system notification. Alarms and notifications can be triggered
    when the application that created them is no longer running, and the system uses
    the information in the pending intent to start it and perform the intent action
    on its behalf. [Example 2-27](ch02.html#using_a_pending_intent_to_schedule_an_al
    "Example 2-27. Using a pending intent to schedule an alarm") shows how the Email
    application uses a pending intent created with the `PendingIntent.getBroadcast()`
    ➊ to schedule broadcasts that trigger email synchronization.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 待处理意图用于在 Android 中实现警报和通知。警报和通知允许任何应用程序指定一个需要代表其执行的操作，无论是对警报的指定时间，还是用户与系统通知交互时。即使创建它们的应用程序不再运行，警报和通知仍可以被触发，系统利用待处理意图中的信息来启动该应用程序并代表其执行意图操作。[示例
    2-27](ch02.html#using_a_pending_intent_to_schedule_an_al "示例 2-27. 使用待处理意图调度警报")展示了电子邮件应用程序如何使用通过`PendingIntent.getBroadcast()`➊创建的待处理意图来调度触发电子邮件同步的广播。
- en: Example 2-27. Using a pending intent to schedule an alarm
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-27. 使用待处理意图调度警报
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Pending intents can be handed to non-system applications as well. The same
    rules apply: applications that receive a `PendingIntent` instance can perform
    the specified operation with the same permissions and identity as creator applications.
    Therefore, care should be taken when building the base intent, and base intents
    should generally be as specific as possible (with component name explicitly specified)
    to ensure that the intent is received by the intended components.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 待处理的意图也可以交给非系统应用程序处理。相同的规则适用：接收`PendingIntent`实例的应用程序可以使用与创建应用程序相同的权限和身份来执行指定的操作。因此，在构建基础意图时应小心，基础意图通常应该尽可能具体（明确指定组件名称），以确保意图被预期的组件接收。
- en: The implementation of pending intents is rather complex, but it is based on
    the same IPC and sandboxing principles that other Android components are built
    upon. When an application creates a pending intent, the system retrieves its UID
    and PID using `Binder.getCallingUid()` and `Binder.getCallingPid()`. Based on
    those, the system retrieves the package name and user ID (on multi-user devices)
    of the creator and stores them in a `PendingIntentRecord` along with the base
    intent and any additional meta-data. The activity manager keeps a list of active
    pending intents by storing the corresponding `PendingIntentRecord`s, and when
    triggered, retrieves the necessary record. It then uses the information in the
    record to assume the identity of the pending intent creator and execute the specified
    action. From there, the process is the same as when starting any Android component
    and the same permission checks are performed.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 待处理意图的实现相当复杂，但它基于与其他 Android 组件相同的 IPC 和沙箱原则。当一个应用程序创建待处理意图时，系统通过`Binder.getCallingUid()`和`Binder.getCallingPid()`获取其
    UID 和 PID。根据这些信息，系统检索创建者的包名和用户 ID（在多用户设备上），并将它们与基础意图和任何附加元数据一起存储在`PendingIntentRecord`中。活动管理器通过存储相应的`PendingIntentRecord`来保持活跃的待处理意图列表，并在触发时检索必要的记录。然后，它使用记录中的信息来假设待处理意图创建者的身份并执行指定的操作。从那里开始，过程与启动任何
    Android 组件相同，并执行相同的权限检查。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Android runs each application in a restricted sandbox and requires that applications
    request specific permissions in order to interact with other apps or the system.
    Permissions are strings that denote the ability to perform a particular action.
    They are granted at application install time and (with the exception of development
    permissions) remain fixed during an application’s lifetime. Permissions can be
    mapped to Linux supplementary group IDs, which the kernel checks before granting
    access to system resources.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Android 在受限的沙箱中运行每个应用程序，并要求应用程序请求特定权限才能与其他应用或系统交互。权限是表示执行特定操作能力的字符串。它们在应用程序安装时授予，并且（开发权限除外）在应用程序的生命周期内保持不变。权限可以映射到
    Linux 补充组 ID，内核在授予访问系统资源之前会检查这些 ID。
- en: Higher-level system services enforce permissions by obtaining the UID of the
    calling application using Binder and looking up the permissions it holds in the
    package manager database. Permissions associated with a component declared in
    an application’s manifest file are automatically enforced by the system, but applications
    can also choose to perform additional permission checks dynamically. In addition
    to using built-in permissions, applications can also define custom permissions
    and associate them with their components in order to control access.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 高级系统服务通过使用Binder获取调用应用程序的UID，并在包管理器数据库中查找其持有的权限，从而强制执行权限。与应用程序清单文件中声明的组件相关的权限由系统自动强制执行，但应用程序也可以选择动态执行额外的权限检查。除了使用内置权限外，应用程序还可以定义自定义权限，并将其与组件关联，以控制访问。
- en: Each Android component can require a permission, and content providers can additionally
    specify read and write permissions on a per-URI basis. Pending intents encapsulate
    the identity of the application that created them as well as an intent and an
    action to perform, which allows the system or third-party applications to perform
    actions on behalf of the original applications with the same identity and permissions.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Android组件都可以要求权限，内容提供者还可以在每个URI基础上指定读写权限。挂起的Intent封装了创建它们的应用程序的身份，以及要执行的Intent和Action，这使得系统或第三方应用程序能够代表原始应用程序以相同的身份和权限执行操作。
- en: '* * *'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[11](#ch02fn01)]) Google, *Android API Reference*, “Manifest.permission class,”
    *[http://developer.android.com/reference/android/Manifest.permission.html](http://developer.android.com/reference/android/Manifest.permission.html)*
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[11](#ch02fn01)]) Google，*Android API参考*，“Manifest.permission类”，*[http://developer.android.com/reference/android/Manifest.permission.html](http://developer.android.com/reference/android/Manifest.permission.html)*
- en: '^([[12](#ch02fn02)]) Google, *Android API Guides,* “App Manifest: <permission>
    tag,” *[http://developer.android.com/guide/topics/manifest/permission-element.html#plevel](http://developer.android.com/guide/topics/manifest/permission-element.html#plevel)*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[12](#ch02fn02)]) Google，*Android API指南*，“应用清单：<permission>标签”，*[http://developer.android.com/guide/topics/manifest/permission-element.html#plevel](http://developer.android.com/guide/topics/manifest/permission-element.html#plevel)*
- en: ^([[13](#ch02fn03)]) For detailed information about process management functions
    like `fork()`, `setuid()`, and so on, see the respective man pages or a Unix programming
    text, such as W. Richard Stevens and Stephen A. Rago’s *Advanced Programming in
    the UNIX Environment (3rd edition)*, Addison-Wesley Professional, 2013.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[13](#ch02fn03)]) 关于进程管理函数，如`fork()`、`setuid()`等的详细信息，请参阅相关的手册页或Unix编程书籍，例如W.
    Richard Stevens和Stephen A. Rago的*《UNIX环境高级编程（第3版）》*，Addison-Wesley Professional，2013年。
- en: '^([[14](#ch02fn04)]) For a discussion of Linux capabilities, see Chapter 39
    of Michael Kerrisk’s *The Linux Programming Interface: A Linux and UNIX System
    Programming Handbook*, No Starch Press, 2010.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[14](#ch02fn04)]) 关于Linux能力的讨论，请参阅Michael Kerrisk的*《Linux编程接口：Linux和UNIX系统编程手册》*第39章，No
    Starch Press，2010年。
- en: ^([[15](#ch02fn05)]) Linux Kernel Archives, *CGROUPS*, *[https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt](https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt)*
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[15](#ch02fn05)]) Linux内核档案，*CGROUPS*，*[https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt](https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt)*
- en: ^([[16](#ch02fn06)]) Google, *Android API Reference*, “ClipData,” *[http://developer.android.com/reference/android/content/ClipData.html](http://developer.android.com/reference/android/content/ClipData.html)*
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[16](#ch02fn06)]) Google，*Android API参考*，“ClipData”，*[http://developer.android.com/reference/android/content/ClipData.html](http://developer.android.com/reference/android/content/ClipData.html)*
