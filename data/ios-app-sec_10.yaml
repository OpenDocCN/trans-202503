- en: '**7**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7**'
- en: '**IOS NETWORKING**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**iOS 网络**'
- en: Almost all applications use one or more of three iOS network APIs. In order
    of abstraction, these are the URL loading system, the Foundation `NSStream` API,
    and the Core Foundation `CFStream` API. The URL loading system is used for fetching
    and manipulating data, such as network resources or files, via URLs. The `NSStream`
    and `CFStream` classes are slightly lower-level methods to deal with network connections,
    without going quite so low as the socket level. These classes are used for non-HTTP-based
    communications, or where you need more direct control over network behavior.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有应用都会使用三种 iOS 网络 API 中的一个或多个。按照抽象层级的顺序，它们分别是 URL 加载系统、Foundation `NSStream`
    API 和 Core Foundation `CFStream` API。URL 加载系统用于通过 URL 获取和操作数据，比如网络资源或文件。`NSStream`
    和 `CFStream` 类则是稍低级的方法，用于处理网络连接，但它们并不直接到达套接字层级。这些类用于非 HTTP 基础的通信，或当你需要更直接控制网络行为时。
- en: In this chapter, I’ll discuss iOS networking in detail, starting from the high-level
    APIs. For most purposes, apps can stick with the higher-level APIs, but there
    are some cases where you can’t quite bend those APIs to your will. With lower-level
    APIs, however, there are more pitfalls to consider.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将详细讨论 iOS 网络，从高层次的 API 开始。对于大多数用途，应用可以使用高层次的 API，但也有一些情况是这些 API 不能完全满足需求的。然而，使用低层次的
    API 时，需要考虑更多的陷阱。
- en: '**Using the iOS URL Loading System**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 iOS URL 加载系统**'
- en: The URL loading system can handle most network tasks an app will need to perform.
    The primary method of interacting with the URL API is by constructing an `NSURLRequest`
    object and using it to instantiate an `NSURLConnection` object, along with a delegate
    that will receive the connection’s response. When the response is fully received,
    the delegate will be sent a `connection:didReceiveResponse` message, with an `NSURLResponse`
    object as the supplied parameter.^([1](footnote.html#fn62))
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: URL 加载系统能够处理应用程序需要执行的大多数网络任务。与 URL API 交互的主要方式是构造一个 `NSURLRequest` 对象，并利用它实例化一个
    `NSURLConnection` 对象，以及一个接收连接响应的代理。当响应完全接收后，代理会收到一个 `connection:didReceiveResponse`
    消息，参数是一个 `NSURLResponse` 对象。^([1](footnote.html#fn62))
- en: But not everyone uses the powers of the URL loading system properly, so in this
    section, I’ll first show you how to spot an app that bypasses Transport Layer
    Security. Then, you’ll learn how to authenticate endpoints through certificates,
    avoid the dangers of open redirects, and implement certificate pinning to limit
    how many certificates your app trusts.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但并非每个人都能正确使用 URL 加载系统的功能，因此在本节中，我将首先展示如何发现一个绕过传输层安全性的应用。接着，你将学到如何通过证书验证端点，避免开放重定向的危险，并实现证书固定，限制你的应用信任的证书数量。
- en: '***Using Transport Layer Security Correctly***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***正确使用传输层安全性***'
- en: '*Transport Layer Security (TLS)*, the modern specification supplanting SSL,
    is crucial to the security of almost any networked application. When used correctly,
    TLS both keeps the data transmitted over a connection confidential and authenticates
    the remote endpoint, ensuring that the certificate presented is signed by a trusted
    certificate authority. By default, iOS does the Right Thing™ and refuses to connect
    to any endpoint with an untrusted or invalid certificate. But all too frequently,
    in applications of all kinds, mobile and otherwise, developers explicitly disable
    TLS/SSL endpoint validation, allowing the application’s traffic to be intercepted
    by network attackers.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*传输层安全性 (TLS)*，现代的替代 SSL 的规范，对于几乎所有网络应用的安全至关重要。正确使用 TLS 时，它不仅能确保通过连接传输的数据机密性，还能验证远程端点，确保呈现的证书是由受信任的证书颁发机构签名的。默认情况下，iOS
    会做正确的事情™，拒绝连接任何拥有不受信任或无效证书的端点。但在各种应用中，无论是移动端还是其他类型，开发者经常明确禁用 TLS/SSL 端点验证，从而让应用的流量容易被网络攻击者拦截。'
- en: In iOS, TLS can be disabled a number of ways. In the past, developers would
    often use the undocumented `setAllowsAnyHTTPSCertificate` private class method
    of `NSURLRequest` to easily disable verification. Apple fairly quickly started
    rejecting applications that used this method, as it tends to do with apps that
    use private APIs. There are, however, still obfuscation methods that may allow
    the use of this API to slip past the approval process, so check codebases to ensure
    that the method isn’t just called by another name.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 中，TLS 可以通过多种方式禁用。过去，开发者通常会使用 `NSURLRequest` 的未记录的私有类方法 `setAllowsAnyHTTPSCertificate`
    来轻松禁用验证。苹果公司很快开始拒绝使用此方法的应用，就像它对使用私有 API 的应用所做的那样。然而，仍然存在一些混淆方法，可能会让这个 API 在审核过程中悄悄通过，因此需要检查代码库，确保该方法没有被其他名字调用。
- en: There’s an even more disastrous way to bypass TLS validation. It will also (probably)
    get your app rejected in this day and age, but it illustrates an important point
    about categories. I once had a client that licensed what should have been a fairly
    simple piece of third-party code and included it in their product. Despite handling
    TLS correctly everywhere else in the project, their updated version of the third-party
    code did not validate any TLS connections. Apparently, the third-party vendor
    had implemented a category of `NSURLRequest`, using the `allowsAnyHTTPSCertificateForHost`
    method to avoid validation. The category contained only the directive `return
    YES;`, causing all `NSURLRequests` to silently ignore bad certificates. The moral?
    Test things, and don’t make assumptions! Also, you have to audit third-party code
    along with the rest of your codebase. Mistakes might not be your fault, but nobody
    is likely to care about that.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种更具灾难性的绕过 TLS 验证的方法。这也很可能会导致你的应用被拒绝，但它说明了类别的重要性。我曾经有一个客户，他们授权了一个本应相当简单的第三方代码，并将其包含在产品中。尽管该项目的其他地方都正确处理了
    TLS，但他们更新后的第三方代码没有验证任何 TLS 连接。显然，第三方供应商实现了 `NSURLRequest` 的一个类别，使用 `allowsAnyHTTPSCertificateForHost`
    方法来避免验证。该类别仅包含指令 `return YES;`，导致所有 `NSURLRequest` 安静地忽略错误的证书。这个教训是什么？测试代码，别做假设！另外，你必须审计第三方代码，就像审计你自己代码库中的其他代码一样。错误可能不是你的错，但没人会关心这个。
- en: '**NOTE**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Thankfully, it’s much more difficult to make accidental TLS-disabling mistakes
    in iOS 9, as it by default does not allow applications to make non-TLS connections.
    Instead, developers are required to put a specific exception in the app’s* Info.plist
    *for URLs to be accessed over plaintext HTTP. However, this won’t solve cases
    of willful disabling of TLS protections.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*幸运的是，在 iOS 9 中，意外禁用 TLS 的错误变得更加困难，因为默认情况下，iOS 不允许应用进行非 TLS 连接。相反，开发者需要在应用的*
    Info.plist *中为通过明文 HTTP 访问的 URL 放置一个特定的例外。然而，这并不能解决故意禁用 TLS 保护的情况。*'
- en: Now, there is actually an official API to bypass TLS verification. You can use
    a delegate of `NSURLConnection` with the `NSURLConnectionDelegate` protocol.^([2](footnote.html#fn63))
    The delegate must implement the `willSendRequestForAuthenticationChallenge` method,
    which can then call the `continueWithoutCredentialForAuthenticationChallenge`
    method. This is the current, up-to-date method; you may also see older code that
    uses `connection:canAuthenticateAgainstProtectionSpace:` or `connection:didReceiveAuthenticationChallenge:`.
    [Listing 7-1](ch07.html#ch7ex1) shows an example of how you might see this done
    in the wild.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，实际上有一个官方的 API 可以绕过 TLS 验证。你可以使用 `NSURLConnection` 的委托并实现 `NSURLConnectionDelegate`
    协议。^([2](footnote.html#fn63)) 委托必须实现 `willSendRequestForAuthenticationChallenge`
    方法，然后可以调用 `continueWithoutCredentialForAuthenticationChallenge` 方法。这是当前的最新方法；你也可能会看到使用
    `connection:canAuthenticateAgainstProtectionSpace:` 或 `connection:didReceiveAuthenticationChallenge:`
    的旧代码。[示例 7-1](ch07.html#ch7ex1) 显示了如何在实际中看到这样的做法。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 7-1: Sending a dummy* `NSURLCredential` *in response to the challenge*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-1：响应挑战时发送虚拟的* `NSURLCredential` *对象*'
- en: This code looks rather benign, especially since it uses the words *protection*,
    *credential*, *authentication*, and *trust* all over the place. What it actually
    does is bypass verification of the TLS endpoint, leaving the connection susceptible
    to interception.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来相当无害，特别是因为它在各处都使用了 *protection*、*credential*、*authentication* 和 *trust*
    等词汇。实际上，它所做的是绕过 TLS 端点的验证，使连接容易受到拦截。
- en: Of course, I’m not encouraging you to actually *do* anything to bypass TLS verification
    in your app. You shouldn’t, and you’re a bad person if you do. These examples
    just show the pattern that you may see in code that you have to examine. These
    patterns can be difficult to spot and understand, but if you see code that bypasses
    TLS verification, be sure to change it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我并不是鼓励你在应用程序中实际*做*任何绕过TLS验证的事情。你不应该这样做，如果你这么做，你就是个坏人。这些示例只是展示了你在检查代码时可能会看到的模式。这些模式可能很难发现和理解，但如果你看到绕过TLS验证的代码，务必进行修改。
- en: '***Basic Authentication with NSURLConnection***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用NSURLConnection的基本认证***'
- en: HTTP basic authentication isn’t a particularly robust authentication mechanism.
    It doesn’t support session management or password management, and therefore, the
    user can’t log out or change their password without using a separate application.
    But for some tasks, such as authenticating to APIs, these issues are less important,
    and you still might run across this mechanism in an app’s codebase—or be required
    to implement it yourself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP基本认证并不是一种特别强大的认证机制。它不支持会话管理或密码管理，因此用户不能在不使用单独应用程序的情况下注销或更改密码。但对于某些任务，例如对API的认证，这些问题并不那么重要，你仍然可能会在应用程序的代码库中遇到这种机制，或者被要求自己实现它。
- en: You can implement HTTP basic authentication using either `NSURLSession` or `NSURLConnection`,
    but there are a couple of pitfalls that you’ll want to be aware of, whether you’re
    writing an app or examining someone else’s code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`NSURLSession`或`NSURLConnection`来实现HTTP基本认证，但无论是编写应用程序还是检查他人的代码，你都需要注意几个陷阱。
- en: 'The simplest implementation uses the `willSendRequestForAuthenticationChallenge`
    delegate method of `NSURLConnection`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的实现使用`NSURLConnection`的`willSendRequestForAuthenticationChallenge`委托方法：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The delegate is first passed an `NSURLAuthenticationChallenge` object. It then
    creates a credential with a username and password, which can be either provided
    by the user or pulled from the Keychain. Finally, the sender of the challenge
    is passed the credential and challenge in return.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 委托对象首先会传递一个`NSURLAuthenticationChallenge`对象。接着，它创建一个包含用户名和密码的凭证，用户名和密码可以由用户提供，或从钥匙串中获取。最后，挑战的发送者会将凭证和挑战一起返回。
- en: There are two potential problems to pay attention to when implementing HTTP
    basic authentication in this way. First, avoid storing the username and password
    within either the source code or the shared preferences. You can use the `NSURLCredentialStorage`
    API to store user-supplied credentials in the Keychain automatically, using `sharedCredentialStorage`,
    as shown in [Listing 7-2](ch07.html#ch7ex2).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实现HTTP基本认证时需要注意两个潜在问题。首先，避免将用户名和密码存储在源代码或共享偏好设置中。你可以使用`NSURLCredentialStorage`
    API自动将用户提供的凭证存储在钥匙串中，使用`sharedCredentialStorage`，如[示例 7-2](ch07.html#ch7ex2)所示。
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 7-2: Setting the default credentials of a protection space*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-2：设置保护空间的默认凭证*'
- en: This simply creates a protection space ➊, which includes the host, the port,
    the protocol, and optionally the HTTP authentication realm (if using HTTP basic
    authentication) and the authentication method (for example, using NTLM or another
    mechanism). At ➋, the example creates a credential with the username and password
    that it most likely received from user input. It then sets that to the default
    credential for this protection space at ➌, and the credential should be automatically
    stored in the Keychain. In the future, the app this code belongs to can read credentials
    with the same API, using the `defaultCredentialForProtectionSpace` method, as
    shown in [Listing 7-3](ch07.html#ch7ex3).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个保护空间➊，其中包括主机、端口、协议，以及可选的HTTP认证领域（如果使用HTTP基本认证）和认证方法（例如，使用NTLM或其他机制）。在➋，示例创建一个凭证，凭证包含最有可能从用户输入中接收到的用户名和密码。然后，在➌，它将凭证设置为该保护空间的默认凭证，并且凭证应该会自动存储在钥匙串中。未来，属于该代码的应用程序可以使用相同的API通过`defaultCredentialForProtectionSpace`方法读取凭证，如[示例
    7-3](ch07.html#ch7ex3)所示。
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 7-3: Using the default credential for a protection space*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-3：使用保护空间的默认凭证*'
- en: Note, however, that credentials stored in `sharedCredentialStorage` are marked
    with the Keychain attribute `kSecAttrAccessibleWhenUnlocked`. If you need stricter
    protections, you’ll need to manage Keychain storage yourself. I talk more about
    managing the Keychain in [Chapter 13](ch13.html#ch13).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，存储在 `sharedCredentialStorage` 中的凭证会被标记为钥匙串属性 `kSecAttrAccessibleWhenUnlocked`。如果你需要更严格的保护，你需要自行管理钥匙串存储。我在[第
    13 章](ch13.html#ch13)中讲解了如何管理钥匙串。
- en: Also, be sure to pay attention to how you specify the value of the `persistence`
    argument when creating the credential. If you’re storing in the Keychain using
    `NSURLCredentialStorage`, you can use either the `NSURLCredentialPersistencePermanent`
    or `NSURLCredentialPersistenceSynchronizable` types when creating your credentials.
    If you’re using the authentication for something more transient, the `NSURLCredentialPersistenceNone`
    or `NSURLCredentialPersistenceForSession` types are more appropriate. You can
    find details on what each of these persistence types mean in [Table 7-1](ch07.html#ch7tab1).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请确保在创建凭证时，注意如何指定 `persistence` 参数的值。如果你使用 `NSURLCredentialStorage` 存储在钥匙串中，可以在创建凭证时使用
    `NSURLCredentialPersistencePermanent` 或 `NSURLCredentialPersistenceSynchronizable`
    类型。如果你是用认证做一些更临时的操作，`NSURLCredentialPersistenceNone` 或 `NSURLCredentialPersistenceForSession`
    类型更为合适。你可以在[表 7-1](ch07.html#ch7tab1)中找到每种持久性类型的详细含义。
- en: '**Table 7-1:** Credential Persistence Types'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-1：** 凭证持久性类型'
- en: '| **Persistence type** | **Meaning** |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **持久性类型** | **含义** |'
- en: '| --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `NSURLCredentialPersistenceNone` | Don’t store the credential at all. Use
    this only when you need to make a single request to a protected resource. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `NSURLCredentialPersistenceNone` | 完全不存储凭证。仅在你需要对受保护资源进行一次请求时使用此项。 |'
- en: '| `NSURLCredentialPersistenceForSession` | Persist the credential for the lifetime
    of your application. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `NSURLCredentialPersistenceForSession` | 将凭证存储在应用程序的生命周期内。 |'
- en: '| `NSURLCredentialPersistencePermanent` | Store the credential in the Keychain.
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `NSURLCredentialPersistencePermanent` | 将凭证存储在钥匙串中。 |'
- en: '| `NSURLCredentialPersistenceForSession` | Persist the credential for the lifetime
    of your application. Use this is if you need a credential just for the time your
    app remains running. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `NSURLCredentialPersistenceForSession` | 将凭证存储在应用程序的生命周期内。若你只在应用运行时需要凭证，可以使用此项。
    |'
- en: '| `NSURLCredentialPersistencePermanent` | Store the credential in the Keychain.
    Use this when you’ll want this credential on a consistent basis as long as the
    user has the app installed. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `NSURLCredentialPersistencePermanent` | 将凭证存储在钥匙串中。当你希望在用户安装应用程序时，凭证能够持续存在时使用此项。
    |'
- en: '| `NSURLCredentialPersistenceSynchronizable` | Store the credential in the
    Keychain, and allow it to be synchronized to other devices and iCloud. Use this
    when you want to have people transfer the credential between devices and don’t
    have concerns about sending the credential to a third party like iCloud. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `NSURLCredentialPersistenceSynchronizable` | 将凭证存储在钥匙串中，并允许其同步到其他设备和 iCloud。当你希望用户在设备之间传输凭证并且不担心将凭证发送到像
    iCloud 这样的第三方时使用此项。 |'
- en: '***Implementing TLS Mutual Authentication with NSURLConnection***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 NSURLConnection 实现 TLS 双向认证***'
- en: 'One of the best methods of performing client authentication is to use a client
    certificate and private key; however, this is somewhat convoluted on iOS. The
    basic concept is relatively simple: implement a delegate for `willSendRequestForAuthenticationChallenge`
    (formerly `didReceiveAuthenticationChallenge`), check whether the authentication
    method is `NSURLAuthenticationMethodClientCertificate`, retrieve and load a certificate
    and private key, build a credential, and use the credential for the challenge.
    Unfortunately, there aren’t built-in Cocoa APIs for managing certificates, so
    you’ll need to muck about with Core Foundation a fair bit, like in this basic
    framework:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 执行客户端认证的最佳方法之一是使用客户端证书和私钥；然而，这在 iOS 上有些复杂。基本概念相对简单：实现 `willSendRequestForAuthenticationChallenge`（以前为
    `didReceiveAuthenticationChallenge`）的代理，检查认证方法是否为 `NSURLAuthenticationMethodClientCertificate`，检索并加载证书和私钥，构建凭证，并使用凭证进行挑战。不幸的是，Cocoa
    没有内置的 API 用于管理证书，因此你需要在 Core Foundation 中进行一些操作，像下面这个基本框架一样：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This example creates a `SecIdentityRef` and `SecTrustRef` so that it has destinations
    to pass to the `extractIdentityAndTrust` function at ➊. This function will extract
    the identity and trust information from a blob of PKCS #12 data (file extension
    *.p12*). These archive files just store a bunch of cryptography objects in one
    place.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '这个示例创建了一个 `SecIdentityRef` 和 `SecTrustRef`，以便可以将它们传递给 ➊ 处的 `extractIdentityAndTrust`
    函数。这个函数会从一个 PKCS #12 数据块（文件扩展名为 *.p12*）中提取身份和信任信息。这些归档文件只是将一组加密对象集中存储在一个地方。'
- en: The code then makes a `SecCertificateRef` into which it extracts the certificate
    from the identity ➋. Next, it builds an array containing the one certificate at
    ➌ and creates a `CFArrayRef` to hold that certificate at ➍. Finally, the code
    creates an `NSURLCredential`, passing in its identity and its array of certificates
    with only one element ➎, and presents this credential as the answer to its challenge
    ➏.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将创建一个 `SecCertificateRef`，并从身份中提取证书 ➋。接着，它构建一个数组，包含在 ➌ 处的唯一证书，并创建一个 `CFArrayRef`
    来存放该证书 ➍。最后，代码创建一个 `NSURLCredential`，将其身份和仅包含一个元素的证书数组传入 ➎，并将此凭据作为挑战的答案呈现 ➏。
- en: 'You’ll notice some handwaving around ➊. This is because obtaining the actual
    certificate p12 data can happen a few different ways. You can perform a one-time
    bootstrap and fetch a newly generated certificate over a secure channel, generate
    a certificate locally, read one from the filesystem, or fetch one from the Keychain.
    One way to get the certificate information used in `somep12Data` is by retrieving
    it from the filesystem, like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在 ➊ 处有一些不明确的描述。这是因为获取实际证书 p12 数据有几种不同的方法。你可以执行一次性引导，通过安全通道获取新生成的证书，或者在本地生成证书，或者从文件系统读取证书，或者从钥匙串中获取证书。获取
    `somep12Data` 中使用的证书信息的一种方式是从文件系统中检索，方法如下：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The best place to store certificates of course is the Keychain; I’ll cover that
    further in [Chapter 13](ch13.html#ch13).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 存储证书的最佳位置当然是钥匙串；我会在 [第13章](ch13.html#ch13)进一步讲解。
- en: '***Modifying Redirect Behavior***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***修改重定向行为***'
- en: By default, `NSURLConnection` will follow HTTP redirects when it encounters
    them. However, its behavior when this happens is, well, unusual. When the redirect
    is encountered, `NSURLConnection` will send a request, containing the HTTP headers
    as they were used in the original `NSURLHttpRequest`, to the new location. Unfortunately,
    this also means that the current value of your cookies for the original domain
    is passed to the new location. As a result, if an attacker can get your application
    to visit a page on your site that accepts an arbitrary URL as a place to redirect
    to, that attacker can steal your users’ cookies, as well as any other sensitive
    data that your application might store in its HTTP headers. This type of flaw
    is called an *open redirect*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`NSURLConnection` 会在遇到 HTTP 重定向时跟随它。然而，当发生重定向时，它的行为是比较特殊的。当重定向被触发时，`NSURLConnection`
    会将请求发送到新位置，并携带原始 `NSURLHttpRequest` 中的 HTTP 头信息。不幸的是，这也意味着你当前的原始域名的 Cookie 会被传递到新位置。因此，如果攻击者能够让你的应用访问一个接受任意
    URL 作为重定向目标的页面，那么该攻击者就能窃取你的用户 Cookie，以及你应用可能存储在 HTTP 头中的任何其他敏感数据。这种漏洞被称为 *开放重定向*。
- en: 'You can modify this behavior by implementing `connect:willSendRequest: redirectResponse`^([3](footnote.html#fn64))
    on your `NSURLConnectionDelegate` in iOS 4.3 and older, or on your `NSURLConnectionDataDelegate`
    in iOS 5.0 and newer.^([4](footnote.html#fn65))'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以通过在 iOS 4.3 及更早版本的 `NSURLConnectionDelegate` 上实现 `connect:willSendRequest:
    redirectResponse`^([3](footnote.html#fn64))，或者在 iOS 5.0 及更高版本的 `NSURLConnectionDataDelegate`
    上实现此方法来修改这一行为。^([4](footnote.html#fn65))'
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At ➊, this code checks whether the domain you’re redirecting to is different
    from the name of your site. If it’s the same, it carries on as normal. If it’s
    different, it modifies the request to be `nil` ➋.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，这段代码会检查你要重定向的域名是否与网站的名称相同。如果相同，它会继续正常执行。如果不同，它会将请求修改为 `nil` ➋。
- en: '***TLS Certificate Pinning***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***TLS 证书固定***'
- en: In the past several years, there have been a number of troubling developments
    regarding certificate authorities (CAs), the entities that vouch for the TLS certificates
    that we encounter on a daily basis. Aside from the massive number of signing authorities
    trusted by your average client application, CAs have had several prominent security
    breaches where signing keys were compromised or where overly permissive certificates
    were issued. These breaches allow anyone in possession of the signing key to impersonate
    any TLS server, meaning they can successfully and transparently read or modify
    requests to the server and their responses.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，关于证书颁发机构（CAs，负责担保我们日常遇到的 TLS 证书的实体）出现了一些令人担忧的发展。除了客户端应用程序信任的签名机构数量庞大外，CAs
    还发生了几次显著的安全漏洞事件，包括签名密钥被泄露或颁发过于宽松的证书。这些漏洞使得任何拥有签名密钥的人都可以冒充任何 TLS 服务器，意味着他们可以成功且透明地读取或修改请求及其响应。
- en: To help mitigate these attacks, client applications of many types have implemented
    *certificate pinning*. This term can refer to a number of different techniques,
    but the core idea is to programmatically restrict the number of certificates that
    your application will trust. You could limit trust to a single CA (that is, the
    one that your company uses to sign its server certificates), to an internal root
    CA that you use to create your own certificates (the top of the chain of trust),
    or simply to a leaf certificate (a single specific certificate at the bottom of
    the chain of trust).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助缓解这些攻击，许多类型的客户端应用程序实现了 *证书固定*。这个术语可以指代多种不同的技术，但核心思想是通过编程限制应用程序信任的证书数量。您可以将信任限制为单一
    CA（即您的公司用于签署服务器证书的 CA），限制为您用来创建自己证书的内部根 CA（即信任链的顶部），或者仅限于一个叶证书（信任链底部的一个特定证书）。
- en: 'As part of the SSL Conservatory project, my colleague Alban Diquet has developed
    some convenient wrappers that allow you to implement certificate pinning in your
    application. (Learn more at *[https://github.com/iSECPartners/ssl-conservatory](https://github.com/iSECPartners/ssl-conservatory)*.)
    You could write your own wrapper or use an existing one; either way, a good wrapper
    can make pinning rather simple. For example, here’s a look at how easy it would
    be to implement certificate pinning with Alban’s wrapper:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 SSL Conservatory 项目的一部分，我的同事 Alban Diquet 开发了一些方便的封装器，使您能够在应用程序中实现证书固定。（了解更多内容，请访问
    *[https://github.com/iSECPartners/ssl-conservatory](https://github.com/iSECPartners/ssl-conservatory)*。）您可以编写自己的封装器，也可以使用现有的封装器；无论哪种方式，一个好的封装器可以使证书固定变得相当简单。例如，下面是如何通过
    Alban 的封装器轻松实现证书固定：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At ➊, this code simply defines a method to load a certificate from a DER-formatted
    file into an `NSData` object and calls this method at ➋. If this is successful,
    the code puts `myCertData` into an `NSMutableDictionary` ➌ and calls the `loadSSLPinsFromDERCertificates`
    method of the main `SSLCertificatePinning` class ➍. With these pins loaded, an
    app would also need to implement an `NSURLConnection` delegate, as shown in [Listing
    7-4](ch07.html#ch7ex4).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，这段代码简单地定义了一个方法，从 DER 格式的文件中加载证书到 `NSData` 对象，并在 ➋ 处调用此方法。如果加载成功，代码会将 `myCertData`
    放入 `NSMutableDictionary` ➌ 中，并调用主 `SSLCertificatePinning` 类的 `loadSSLPinsFromDERCertificates`
    方法 ➍。加载这些固定证书后，应用程序还需要实现一个 `NSURLConnection` 委托，如 [列表 7-4](ch07.html#ch7ex4) 所示。
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 7-4: An* `NSURLConnection` *delegate to handle certificate pinning
    logic*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-4：一个* `NSURLConnection` *委托，用于处理证书固定逻辑*'
- en: This simply evaluates the certificate chain presented by a remote server and
    compares it to the pinned certificates included with your application. If a pinned
    certificate is found, the connection continues; if it isn’t, the authentication
    challenge process is canceled.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码简单地评估远程服务器提供的证书链，并将其与应用程序中包含的固定证书进行比较。如果找到固定证书，则连接继续；如果没有找到，则取消认证挑战过程。
- en: With your delegate implemented as shown, all your uses of `NSURLConnection`
    should check to ensure that they are pinned to a domain and certificate pair in
    your predefined list. If you’re curious, you can find the rest of the code to
    implement your own certificate pinning at *[https://github.com/iSECPartners/ssl-conservatory/tree/master/ios](https://github.com/iSECPartners/ssl-conservatory/tree/master/ios)*.
    There’s a fair bit of other logic involved, so I can’t show all the code here.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 按照所示实现您的代理后，所有`NSURLConnection`的使用应该检查确保它们绑定到您预定义列表中的域名和证书对。如果您感兴趣，可以在*[https://github.com/iSECPartners/ssl-conservatory/tree/master/ios](https://github.com/iSECPartners/ssl-conservatory/tree/master/ios)*找到其余的代码来实现您自己的证书钉扎。涉及的其他逻辑相当复杂，所以我无法在这里展示所有代码。
- en: '**NOTE**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re in a hurry, a delegate that you can just subclass is included in
    the SSL Conservatory sample code.*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您很急，可以使用SSL Conservatory示例代码中的代理类进行子类化。*'
- en: Up to now, I’ve shown network security issues and solutions that revolve around
    `NSURLConnection`. But as of iOS 7, `NSURLSession` is preferred over the traditional
    `NSURLConnection` class. Let’s take a closer look at this API.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我展示了围绕`NSURLConnection`的网络安全问题和解决方案。但从iOS 7开始，`NSURLSession`比传统的`NSURLConnection`类更为推荐。让我们更详细地看看这个API。
- en: '**Using NSURLSession**'
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用NSURLSession**'
- en: The `NSURLSession` class is generally favored by developers because it focuses
    on the use of network *sessions*, as opposed to `NSURLConnection`’s focus on individual
    requests. While broadening the scope of `NSURLConnection` somewhat, `NSURLSession`
    also gives additional flexibility by allowing configurations to be set on individual
    sessions rather than globally throughout the application. Once sessions are instantiated,
    they are handed individual tasks to perform, using the `NSURLSessionDataTask`,
    `NSURLSessionUploadTask`, and `NSURLSessionDownloadTask` classes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSURLSession`类通常更受开发者青睐，因为它专注于使用网络*会话*，而不是`NSURLConnection`专注于单个请求。虽然`NSURLSession`在某种程度上扩大了`NSURLConnection`的范围，但它还通过允许在单个会话上设置配置，而不是在应用程序中全局设置配置，提供了更多的灵活性。一旦会话被实例化，它们将被分配个别任务来执行，使用`NSURLSessionDataTask`、`NSURLSessionUploadTask`和`NSURLSessionDownloadTask`类。'
- en: In this section, you’ll explore some ways to use `NSURLSession`, some potential
    security pitfalls, and some security mechanisms not provided by the older `NSURLConnection`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将探索一些使用`NSURLSession`的方法，一些潜在的安全陷阱，以及一些`NSURLConnection`未提供的安全机制。
- en: '***NSURLSession Configuration***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***NSURLSession 配置***'
- en: The `NSURLSessionConfiguration` class encapsulates options passed to `NSURLSession`
    objects so that you can have separate configurations for separate types of requests.
    For example, you can apply different caching and cookie policies to requests fetching
    data of varying sensitivity levels, rather than having these policies be app-wide.
    To use the system policies for `NSURLSession` configuration, you can use the default
    policy of `[NSURLSessionConfigurationdefaultConfiguration]`, or you can simply
    neglect to specify a configuration policy and instantiate your request object
    with `[NSURLSessionsharedSession]`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSURLSessionConfiguration`类封装了传递给`NSURLSession`对象的选项，以便您可以为不同类型的请求提供独立的配置。例如，您可以对获取不同敏感级别数据的请求应用不同的缓存和cookie策略，而不是让这些策略在整个应用程序中全局应用。要使用`NSURLSession`的系统策略，您可以使用默认策略`[NSURLSessionConfigurationdefaultConfiguration]`，或者您可以简单地不指定配置策略，直接使用`[NSURLSessionsharedSession]`来实例化请求对象。'
- en: For security-sensitive requests that should leave no remnants on local storage,
    the configuration method `ephemeralSessionConfiguration` should be used instead.
    A third method, `backgroundSessionConfiguration`, is available specifically for
    long-running upload or download tasks. This type of session will be handed off
    to a system service to manage completion, even if your application is killed or
    crashes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不应在本地存储留下任何痕迹的安全敏感请求，应使用配置方法`ephemeralSessionConfiguration`。另一种方法`backgroundSessionConfiguration`专门用于长时间运行的上传或下载任务。这种类型的会话将交给系统服务来管理完成，即使您的应用被终止或崩溃。
- en: Also, for the first time, you can specify that a connection use only TLS version
    1.2, which helps defend against attacks such as BEAST^([5](footnote.html#fn66))
    and CRIME,^([6](footnote.html#fn67)) both of which can allow network attackers
    to read or tamper with your TLS connections.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以首次指定连接仅使用TLS版本1.2，这有助于防御BEAST^([5](footnote.html#fn66))和CRIME^([6](footnote.html#fn67))等攻击，这些攻击可能允许网络攻击者读取或篡改您的TLS连接。
- en: '**NOTE**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Session configurations are read-only after an* `*NSURLSession*` *is instantiated;
    policies and configurations cannot be changed mid-session, and you cannot swap
    out for a separate configuration.*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*会话配置在实例化* `*NSURLSession*` *后是只读的；会话期间无法更改策略和配置，且无法更换为不同的配置。*'
- en: '***Performing NSURLSession Tasks***'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***执行NSURLSession任务***'
- en: Let’s walk through the typical flow of creating an `NSURLSessionConfiguration`
    and assigning it a simple task, as shown in [Listing 7-5](ch07.html#ch7ex5).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起看看创建`NSURLSessionConfiguration`并为其分配简单任务的典型流程，如[示例 7-5](ch07.html#ch7ex5)所示。
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 7-5: Creating an ephemeral* `NSURLConfiguration` *requiring TLSv1.2*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-5：创建一个要求TLSv1.2的临时* `NSURLConfiguration`'
- en: The `NSURLSessionConfiguration` object is instantiated at ➊, with the specification
    that the connection should be ephemeral. This should prevent cached data from
    being written to local storage. Then, at ➋, the configuration also requires TLS
    version 1.2 since the developer controls the endpoint and knows that it supports
    that version. Next, just as with `NSURLConnection`, an `NSURL` object and an `NSURLRequest`
    object with that URL ➌ are created. With the configuration and request created,
    the app can then instantiate the session ➍ and assign a task to that session ➎.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处实例化了`NSURLSessionConfiguration`对象，指定连接应为临时的。这应该能防止缓存数据写入本地存储。然后，在➋处，配置要求使用TLS
    1.2版本，因为开发者控制着端点并且知道该端点支持该版本。接下来，就像`NSURLConnection`一样，创建了一个`NSURL`对象和一个带有该URL的`NSURLRequest`对象
    ➌。创建配置和请求后，应用程序可以实例化会话 ➍并为该会话分配任务 ➎。
- en: '`NSURLSessionDataTask` and its siblings take a completion handler block as
    an argument ➏. This block asynchronously handles the server response and data
    you receive as a result of the task. Alternatively (or in addition), you can specify
    a custom delegate conforming to the `NSURLSessionTaskDelegate` protocol. One reason
    you may want to use both a `completionHandler` and a delegate is to have the completion
    handler take care of the results of the request, while the delegate manages authentication
    and caching decisions on a session basis instead of a task basis (I’ll talk about
    this in the next section).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSURLSessionDataTask`及其相关对象将一个完成处理器块作为参数 ➏。这个块异步处理服务器响应和你因任务收到的数据。或者（或额外），你可以指定一个符合`NSURLSessionTaskDelegate`协议的自定义代理。你可能希望同时使用`completionHandler`和代理的原因之一是，完成处理器处理请求结果，而代理则在会话级别而非任务级别管理认证和缓存决策（我将在下一节讨论这个问题）。'
- en: Finally, at ➐, this code sets the task running with a call to its `resume` method
    because all tasks are suspended upon creation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在➐处，这段代码通过调用`resume`方法启动任务，因为所有任务在创建时都会被暂停。
- en: '***Spotting NSURLSession TLS Bypasses***'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***发现NSURLSession TLS绕过***'
- en: '`NSURLSession` has a way to avoid TLS checks as well. Apps can just use the
    `didReceiveChallenge` delegate and pass the `proposedCredential` of the challenge
    received back as a credential for the session, as in [Listing 7-6](ch07.html#ch7ex6).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSURLSession` 也有一种方法可以避免TLS检查。应用程序可以使用`didReceiveChallenge`代理，并将接收到的挑战的`proposedCredential`作为凭证传回给会话，
    如[示例 7-6](ch07.html#ch7ex6)所示。'
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 7-6: Bypassing server verification with* `NSURLSession`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-6：使用* `NSURLSession` *绕过服务器验证*'
- en: This is another bypass that can be tricky to spot. Look for code like that at
    ➊, where there’s a `completionHandler` followed by `proposedCredential`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个可能很难发现的绕过方法。查看像➊处那样的代码，其中有一个`completionHandler`，后面跟着`proposedCredential`。
- en: '***Basic Authentication with NSURLSession***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用NSURLSession的基本认证***'
- en: HTTP authentication with `NSURLSession` is handled by the session and is passed
    to the `didReceiveChallenge` delegate, as shown in [Listing 7-7](ch07.html#ch7ex7).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`NSURLSession`进行HTTP认证由会话处理，并传递给`didReceiveChallenge`代理，如[示例 7-7](ch07.html#ch7ex7)所示。
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 7-7: A sample* `didReceiveChallenge` *delegate*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-7：一个示例的* `didReceiveChallenge` *代理*'
- en: This approach defines a delegate and a completion handler at ➊, creates an `NSURLCredential`
    at ➋, and passes that credential to the completion handler at ➌. Note that for
    either the `NSURLConnection` or `NSURLSession` approach, some developers forget
    to ensure that they’re talking to the correct host or sending credentials securely.
    This would result in credentials getting sent to *every* URL your app loads, instead
    of just yours; [Listing 7-8](ch07.html#ch7ex8) shows an example of what that mistake
    might look like.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在 ➊ 处定义了一个代理和一个完成处理程序，在 ➋ 处创建了一个 `NSURLCredential`，并将该凭据传递给 ➌ 处的完成处理程序。请注意，无论是
    `NSURLConnection` 还是 `NSURLSession` 方法，一些开发者会忘记确保他们与正确的主机通信或以安全的方式发送凭据。这将导致凭据发送到你应用加载的
    *每个* URL，而不仅仅是你自己的；[清单 7-8](ch07.html#ch7ex8)展示了这个错误可能是什么样子的。
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 7-8: The wrong way to do HTTP auth*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-8：错误的 HTTP 认证方式*'
- en: If you want to use persistent credentials for a dedicated endpoint, you can
    store them in `sharedCredentialStorage` as you did with `NSURLConnection`. When
    constructing your session, you can provide these credentials beforehand without
    having to worry about a delegate method, as shown in [Listing 7-9](ch07.html#ch7ex9).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为某个专用端点使用持久化凭据，可以像使用 `NSURLConnection` 一样将凭据存储在 `sharedCredentialStorage`
    中。在构建会话时，你可以提前提供这些凭据，而无需担心代理方法，正如在[清单 7-9](ch07.html#ch7ex9)中所示。
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 7-9: Using an* `NSURLSessionConfiguration` *to reference stored credentials*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-9：使用* `NSURLSessionConfiguration` *引用存储的凭据*'
- en: This just creates an `NSURLSessionConfiguration` and specifies that it should
    use the shared credential storage. When you connect to a resource that has credentials
    stored in the Keychain, those will be used by the session.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是创建一个 `NSURLSessionConfiguration`，并指定它应使用共享凭据存储。当你连接到一个在钥匙串中存储了凭据的资源时，这些凭据将被会话使用。
- en: '***Managing Stored URL Credentials***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***管理存储的 URL 凭据***'
- en: You’ve seen how to store and read credentials using `sharedCredentialStorage`,
    but the `NSURLCredentialStorage` API also lets you remove credentials using the
    `removeCredential:forProtectionSpace` method. For example, you may want to do
    this when a user explicitly decides to log out of an application or remove an
    account. [Listing 7-10](ch07.html#ch7ex10) shows a typical use case.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看过如何使用 `sharedCredentialStorage` 存储和读取凭据，但 `NSURLCredentialStorage` API 也允许你使用
    `removeCredential:forProtectionSpace` 方法移除凭据。例如，当用户明确决定从应用中退出或删除帐户时，你可能想要这样做。[清单
    7-10](ch07.html#ch7ex10)展示了一个典型的使用场景。
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 7-10: Removing default credentials*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-10：移除默认凭据*'
- en: This will delete the credentials from your local Keychain. However, if a credential
    has a persistence of `NSURLCredentialPersistenceSynchronizable`, the credential
    may have been synchronized to other devices via iCloud. To remove the credentials
    from all devices, use the `NSURLCredentialStorageRemoveSynchronizableCredentials`
    option, as shown in [Listing 7-11](ch07.html#ch7ex11).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从你的本地钥匙串中删除凭据。然而，如果凭据的持久化类型为 `NSURLCredentialPersistenceSynchronizable`，凭据可能已通过
    iCloud 同步到其他设备。要从所有设备中删除凭据，请使用 `NSURLCredentialStorageRemoveSynchronizableCredentials`
    选项，正如在[清单 7-11](ch07.html#ch7ex11)中所示。
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 7-11: Removing credentials from the local Keychain and from iCloud*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-11：从本地钥匙串和 iCloud 中移除凭据*'
- en: At this point, you should have an understanding of the `NSURLConnection` and
    `NSURLSession` APIs and their basic usage. There are other network frameworks
    that you may encounter, which have their own behaviors and require slightly different
    security configuration. I’ll cover a few of these now.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你应该已经理解了 `NSURLConnection` 和 `NSURLSession` API 及其基本用法。你可能还会遇到其他网络框架，它们有自己的行为，并需要稍微不同的安全配置。我现在将介绍其中的一些。
- en: '**Risks of Third-Party Networking APIs**'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**第三方网络 API 的风险**'
- en: There are a few popular third-party networking APIs used in iOS applications,
    largely for simplifying various networking tasks such as multipart uploads and
    certificate pinning. The most commonly used one is AFNetworking,^([7](footnote.html#fn68))
    followed by the now-obsolete ASIHTTPRequest.^([8](footnote.html#fn69)) In this
    section, I’ll introduce you to both.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 应用中，有一些流行的第三方网络 API，主要用于简化各种网络任务，如多部分上传和证书固定。最常用的一个是 AFNetworking，^([7](footnote.html#fn68))
    其次是现已过时的 ASIHTTPRequest。^([8](footnote.html#fn69)) 在本节中，我将向你介绍这两个。
- en: '***Bad and Good Uses of AFNetworking***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***AFNetworking 的不当与正确使用***'
- en: AFNetworking is a popular library built on top of `NSOperation` and `NSHTTPRequest`.
    It provides several convenience methods to interact with different types of web
    APIs and perform common HTTP networking tasks.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: AFNetworking是一个流行的库，构建于`NSOperation`和`NSHTTPRequest`之上。它提供了多种便捷方法来与不同类型的Web
    API交互并执行常见的HTTP网络任务。
- en: As with other networking frameworks, one crucial task is to ensure that TLS
    safety mechanisms have not been disabled. In AFNetworking, TLS certificate validation
    can be disabled in a few ways. One is via the `_AFNETWORKING_ALLOW_INVALID_SSL_CERTIFICATES`
    flag, typically set in the *Prefix.pch* file. Another way is to set a property
    of `AFHTTPClient`, as in [Listing 7-12](ch07.html#ch7ex12).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他网络框架一样，一个关键任务是确保TLS安全机制没有被禁用。在AFNetworking中，TLS证书验证可以通过几种方式禁用。其一是通过`_AFNETWORKING_ALLOW_INVALID_SSL_CERTIFICATES`标志，通常在*Prefix.pch*文件中设置。另一种方式是设置`AFHTTPClient`的一个属性，如[示例7-12](ch07.html#ch7ex12)所示。
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 7-12: Disabling TLS validation with* `setAllowsInvalidSSLCertificate`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例7-12：通过* `setAllowsInvalidSSLCertificate`禁用TLS验证'
- en: The last way you might see TLS validation being disabled is by changing the
    security policy of `AFHTTPRequestOperationManager` with `setAllowsInvalidSSLCertificate`,
    as shown in [Listing 7-13](ch07.html#ch7ex13).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能看到的最后一种禁用TLS验证的方式是通过使用`setAllowsInvalidSSLCertificate`更改`AFHTTPRequestOperationManager`的安全策略，如[示例7-13](ch07.html#ch7ex13)所示。
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 7-13: Disabling TLS validation using* `securityPolicy`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例7-13：使用* `securityPolicy`禁用TLS验证'
- en: You’ll also want to verify that the code you’re examining doesn’t use the `AFHTTPRequestOperationLogger`
    class in production versions. This logger uses `NSLog` on the backend to write
    requested URLs to the Apple System Log, allowing them to be seen by other applications
    on some iOS versions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要确保你正在检查的代码在生产版本中没有使用`AFHTTPRequestOperationLogger`类。这个日志记录器在后台使用`NSLog`将请求的URL写入Apple系统日志，这使得其他应用程序在某些iOS版本中可以看到它们。
- en: 'One particularly useful feature that AFNetworking provides is the ability to
    easily perform certificate pinning. You can just set the `_AFNETWORKING_PIN_SSL_CERTIFICATES_`
    #define in your project’s *.pch* file, and set the pinning mode (`defaultSSLPinningMode`)
    property of your `AFHTTPClient` instance appropriately; the available modes are
    described in [Table 7-2](ch07.html#ch7tab2). You then put the certificates that
    you want to pin to in the bundle root, as files with a *.cer* extension.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'AFNetworking 提供的一个特别有用的功能是能够轻松地执行证书固定（certificate pinning）。你只需在项目的*.pch*文件中设置`_AFNETWORKING_PIN_SSL_CERTIFICATES_`
    #define，并适当设置`AFHTTPClient`实例的固定模式（`defaultSSLPinningMode`）属性；可用的模式在[表7-2](ch07.html#ch7tab2)中描述。然后将你希望固定的证书放入捆绑包根目录，作为*.cer*扩展名的文件。'
- en: '**Table 7-2:** AFNetworking SSL Pinning Modes'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-2：** AFNetworking SSL固定模式'
- en: '| **Mode** | **Meaning** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | **含义** |'
- en: '| --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `AFSSLPinningModeNone` | Perform no certificate pinning, even if pinning
    is enabled. Use for debug mode if necessary. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `AFSSLPinningModeNone` | 不执行证书固定，即使固定已启用。如果需要，可以在调试模式中使用。 |'
- en: '| `AFSSLPinningModePublicKey` | Pin to the certificate’s public key. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `AFSSLPinningModePublicKey` | 固定到证书的公钥。 |'
- en: '| `AFSSLPinningModeCertificate` | Pin to the exact certificate (or certificates)
    supplied. This will require an application update if a certificate is reissued.
    |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `AFSSLPinningModeCertificate` | 固定到提供的确切证书（或证书）。如果证书被重新签发，则需要更新应用程序。 |'
- en: As shown in sample code included with AFNetworking, you can examine URLs to
    determine whether they should be pinned. Just evaluate the scheme and domain name
    to see whether those domains belong to you. [Listing 7-14](ch07.html#ch7ex14)
    shows an example.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如AFNetworking随附的示例代码所示，你可以检查URL来确定它们是否应该被固定。只需评估协议和域名，查看这些域名是否属于你。[示例7-14](ch07.html#ch7ex14)展示了一个例子。
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 7-14: Determining whether a URL should be pinned*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例7-14：确定一个URL是否应该被固定*'
- en: The `else` statement is not strictly necessary because not pinning is the default,
    but it does provide some clarity.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`else`语句并不是绝对必要的，因为不进行固定是默认设置，但它确实提供了某种清晰度。'
- en: Keep in mind that AFNetworking pins to all certificates provided in the bundle,
    but it doesn’t check that the certificate common name and the hostname of the
    network endpoint match. This is mostly an issue if your application pins to multiple
    sites with different security standards. In other words, if your application pins
    to both *[https://funnyimages.com](https://funnyimages.com)* and *[https://www.bank.com](https://www.bank.com)*,
    an attacker in possession of the *funnyimages.com* private key would be able to
    intercept communications from your application to *bank.com*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，AFNetworking 会固定捆绑包中提供的所有证书，但它不会检查证书的常用名称与网络端点的主机名是否匹配。如果你的应用程序同时绑定到多个具有不同安全标准的网站，这通常会成为一个问题。换句话说，如果你的应用程序同时绑定到
    *[https://funnyimages.com](https://funnyimages.com)* 和 *[https://www.bank.com](https://www.bank.com)*，那么持有
    *funnyimages.com* 私钥的攻击者就能够拦截你应用程序与 *bank.com* 之间的通信。
- en: Now that you’ve had a glimpse at how you can use and abuse the AFNetworking
    library, let’s move on to ASIHTTPRequest.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对如何使用和滥用 AFNetworking 库有了一个初步了解，让我们继续讨论 ASIHTTPRequest。
- en: '***Unsafe Uses of ASIHTTPRequest***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***不安全的 ASIHTTPRequest 使用***'
- en: ASIHTTPRequest is a deprecated library similar to AFNetworking, but it’s a bit
    less complete and is based on the CFNetwork API. It should not be used for new
    projects, but you may find it in existing codebases where migration has been considered
    too expensive. When examining these codebases, the standard SSL validation bypass
    to look for is `setValidatesSecureCertificate:NO`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ASIHTTPRequest 是一个已弃用的库，类似于 AFNetworking，但功能稍微不那么完整，并且基于 CFNetwork API。它不应在新项目中使用，但你可能会在现有的代码库中找到它，尤其是在迁移成本过高的情况下。当检查这些代码库时，标准的
    SSL 验证绕过方法是 `setValidatesSecureCertificate:NO`。
- en: You’ll also want to examine *ASIHTTPRequestConfig.h* in your project to ensure
    that overly verbose logging is not enabled (see [Listing 7-15](ch07.html#ch7ex15)).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要检查项目中的 *ASIHTTPRequestConfig.h*，以确保没有启用过于冗长的日志记录（见 [Listing 7-15](ch07.html#ch7ex15)）。
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 7-15: Logging defines in* ASIHTTPRequestConfig.h'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 7-15：* ASIHTTPRequestConfig.h 中的日志定义'
- en: 'If you do want to use these logging facilities, you may want to wrap them in
    `#ifdef DEBUG` conditionals, like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实希望使用这些日志功能，可能需要将它们包装在 `#ifdef DEBUG` 条件语句中，如下所示：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This *ASIHTTPRequestConfig.h* file wraps the logging facilities inside conditionals
    to keep this information from leaking in production builds.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 *ASIHTTPRequestConfig.h* 文件将日志功能包装在条件语句中，以防止在生产版本中泄露这些信息。
- en: '**Multipeer Connectivity**'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Multipeer Connectivity**'
- en: iOS 7 introduced Multipeer Connectivity,^([9](footnote.html#fn70)) which allows
    nearby devices to communicate with each other with a minimal network configuration.
    Multipeer Connectivity communication can take place over Wi-Fi (either peer-to-peer
    or multipeer networks) or Bluetooth personal area networks (PANs). Bonjour is
    the default mechanism for browsing and advertising available services.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 7 引入了 Multipeer Connectivity^([9](footnote.html#fn70))，它允许附近的设备在最小网络配置下进行通信。Multipeer
    Connectivity 的通信可以通过 Wi-Fi（点对点或多点网络）或蓝牙个人区域网络（PANs）进行。Bonjour 是浏览和广告可用服务的默认机制。
- en: Developers can use Multipeer Connectivity to perform peer-to-peer file transfers
    or stream content between devices. As with any type of peer communication, the
    validation of incoming data from untrusted peers is crucial; however, there are
    also transport security mechanisms in place to ensure that the data is safe from
    eavesdropping.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以使用 Multipeer Connectivity 来执行点对点文件传输或在设备之间流式传输内容。与任何类型的对等通信一样，验证来自不信任对等方的传入数据至关重要；然而，也有传输安全机制确保数据不被窃听。
- en: Multipeer Connectivity sessions are created with either the `initWithPeer` or
    `initWithPeer:securityIdentity:encryptionPreference:` class method of the `MCSession`
    class. The latter method allows you to require encryption, as well as include
    a certificate chain to verify your device.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Multipeer Connectivity 会话是通过 `MCSession` 类的 `initWithPeer` 或 `initWithPeer:securityIdentity:encryptionPreference:`
    类方法创建的。后者方法允许你要求加密，并可以包含证书链来验证设备。
- en: When specifying a value for `encryptionPreference`, your options are `MCEncryptionNone`,
    `MCEncryptionRequired`, and `MCEncryptionOptional`. Note that these are interchangeable
    with values of `0`, `1`, or `2`, respectively. So while values of `0` and `1`
    behave how you would expect if this value were a Boolean, a value of `2` is functionally
    equivalent to not having encryption at all.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当为`encryptionPreference`指定值时，可选择的选项有`MCEncryptionNone`、`MCEncryptionRequired`和`MCEncryptionOptional`。请注意，这些选项与`0`、`1`或`2`的值可以互换。因此，尽管`0`和`1`的值表现得像布尔值一样，但`2`的值在功能上等同于完全没有加密。
- en: It’s a good idea to require encryption unconditionally because `MCEncryptionOptional`
    is subject to downgrade attacks. (You can find more detail in Alban Diquet’s Black
    Hat talk on reversing the Multipeer Connectivity protocol.^([10](footnote.html#fn71)))
    [Listing 7-16](ch07.html#ch7ex16) shows a typical invocation, creating a session
    and requiring encryption.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议无条件要求加密，因为`MCEncryptionOptional`容易受到降级攻击。（你可以在Alban Diquet的Black Hat演讲中找到关于反向工程Multipeer
    Connectivity协议的更多细节^([10](footnote.html#fn71)))。 [列表 7-16](ch07.html#ch7ex16)展示了一个典型的调用，创建一个会话并要求加密。
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 7-16: Creating an* `MCSession`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-16：创建一个* `MCSession`'
- en: When connecting to a remote device, the delegate method `session:didReceiveCertificate:fromPeer:certificateHandler:`
    is called, passing in the peer’s certificate and allowing you to specify a handler
    method to take specific action based on whether the certificate was verified successfully.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接到远程设备时，会调用委托方法`session:didReceiveCertificate:fromPeer:certificateHandler:`，传入对等方的证书，并允许你指定一个处理方法，根据证书是否成功验证来采取特定行动。
- en: '**NOTE**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you fail to create the* `*didReceiveCertificate*` *delegate method or don’t
    implement a* `*certificateHandler*` *in this delegate method, no verification
    of the remote endpoint will occur, making the connection susceptible to interception
    by a third party.*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你未能创建* `*didReceiveCertificate*` *委托方法或没有在该委托方法中实现* `*certificateHandler*`
    *，则远程端点不会进行验证，这使得连接容易被第三方拦截。*'
- en: 'When examining codebases using the Multipeer Connectivity API, ensure that
    all instantiations of `MCSession` provide an identity and require transport encryption.
    Sessions with any type of sensitive information should never be instantiated simply
    with `initWithPeer`. Also ensure that the delegate method for `didReceiveCertificate`
    exists and is implemented correctly and that the `certificateHandler` behaves
    properly when a peer fails certificate validation. You specifically *don’t* want
    to see something like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查使用Multipeer Connectivity API的代码库时，确保所有`MCSession`实例化时都提供身份并要求传输加密。任何包含敏感信息的会话绝不能仅仅使用`initWithPeer`实例化。还要确保`didReceiveCertificate`的委托方法存在并正确实现，并确保当对等方证书验证失败时，`certificateHandler`能够正确处理。你*不*希望看到像这样的代码：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This code blindly passes a `YES` boolean to the handler, which you should never,
    ever do.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码盲目地将`YES`布尔值传递给处理器，这是你绝对不应该做的。
- en: It’s up to you to decide how you’d like to implement validation. Systems for
    validation tend to be somewhat customized, but you have a couple of basic options.
    You can have clients generate certificates themselves and then *trust on first
    use (TOFU)*, which just verifies that the certificate being presented is the same
    as the one shown the first time you paired with a peer. You can also implement
    a server that will return the public certificates of users when queried to centralize
    the management of identities. Choose a solution that makes sense for your business
    model and threat model.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自行决定如何实现验证。验证系统往往是定制化的，但你有几种基本选项。你可以让客户端自行生成证书，然后使用*首次信任（TOFU）*，这只会验证所呈现的证书是否与第一次配对时展示的证书相同。你也可以实现一个服务器，当查询时返回用户的公钥证书，从而集中管理身份。选择一个适合你的业务模型和威胁模型的解决方案。
- en: '**Lower-Level Networking with NSStream**'
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用NSStream进行低级网络编程**'
- en: '`NSStream` is suitable for making non-HTTP network connections, but it can
    also be used for HTTP communications with fairly little effort. For some unfathomable
    reason, in the transition between OS X Cocoa and iOS Cocoa Touch, Apple removed
    the method that allows an `NSStream` to establish a network connection to a remote
    host, `getStreamsToHost`. So if you want to sit around streaming things to yourself,
    then awesome. Otherwise, in Technical Q&A QA1652,^([11](footnote.html#fn72)) Apple
    describes a category that you can use to define a roughly equivalent `getStreamsToHostNamed`
    method of `NSStream`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSStream` 适用于建立非 HTTP 网络连接，但它也可以通过相对较少的工作用于 HTTP 通信。由于某些无法理解的原因，在 OS X Cocoa
    和 iOS Cocoa Touch 之间的过渡中，Apple 删除了允许 `NSStream` 建立与远程主机网络连接的方法 `getStreamsToHost`。所以如果你想自己进行流式传输，那太棒了。否则，在技术问答
    QA1652 中，^([11](footnote.html#fn72)) Apple 描述了一个类别，你可以用它定义一个大致等同于 `NSStream` 的
    `getStreamsToHostNamed` 方法。'
- en: The alternative is to use the lower-level Core Foundation `CFStreamCreatePairWithSocketToHost`
    function and cast the input and output `CFStream`s to `NSStream`s, as shown in
    [Listing 7-17](ch07.html#ch7ex17).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用较低级别的 Core Foundation `CFStreamCreatePairWithSocketToHost` 函数，并将输入和输出的
    `CFStream` 强制转换为 `NSStream`，如 [列表 7-17](ch07.html#ch7ex17) 所示。
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 7-17: Casting* `CFStreams` *to* `NSStreams`'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-17：将* `CFStreams` *转换为* `NSStreams`'
- en: '`NSStream`s allow users only minor control of the characteristics of the connection,
    such as TCP port and TLS settings (see [Listing 7-18](ch07.html#ch7ex18)).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSStream` 只允许用户对连接的特性进行少量控制，如 TCP 端口和 TLS 设置（参见 [列表 7-18](ch07.html#ch7ex18)）。'
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 7-18: Opening a basic TLS connection with* `NSStream`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-18：使用* `NSStream` *打开基本的 TLS 连接*'
- en: 'This is the typical use of an `NSStream`: setting a host, port, and input and
    output streams. Since you don’t have a ton of control over TLS settings, the only
    setting that might be screwed up is ➊, the `NSStreamSocketSecurityLevel`. You
    should set it to `NSStreamSocketSecurityLevelTLSv1` to ensure that you don’t end
    up using an older, broken SSL/TLS protocol.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `NSStream` 的典型用法：设置主机、端口和输入输出流。由于你对 TLS 设置没有太多控制，唯一可能出错的设置是 ➊，`NSStreamSocketSecurityLevel`。你应该将其设置为
    `NSStreamSocketSecurityLevelTLSv1`，以确保你不会使用过时的、已损坏的 SSL/TLS 协议。
- en: '**Even Lower-level Networking with CFStream**'
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 CFStream 进行更低级别的网络编程**'
- en: With `CFStream`s, the developer is given an unfortunate amount of control in
    TLS session negotiation.^([12](footnote.html#fn73)) See [Table 7-3](ch07.html#ch7tab3)
    for a number of `CFStream` properties that you should look for. These controls
    allow developers to override or disable verification of the peer’s canonical name
    (CN), ignore expiration dates, allow untrusted root certificates, and totally
    neglect to verify the certificate chain at all.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `CFStream` 时，开发者在 TLS 会话协商中有不幸过多的控制权。^([12](footnote.html#fn73)) 参见 [表 7-3](ch07.html#ch7tab3)，了解你应该查找的多个
    `CFStream` 属性。这些控制允许开发者覆盖或禁用验证对等方的规范名称（CN）、忽略过期日期、允许不受信任的根证书，并完全忽略验证证书链。
- en: '**Table 7-3:** Horrible `CFStream` TLS Security Constants'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-3：** 恶心的 `CFStream` TLS 安全常量'
- en: '| **Constant** | **Meaning** | **Default** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **常量** | **含义** | **默认值** |'
- en: '| --- | --- | --- |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `kCFStreamSSLLevel` | The protocol to be used for encrypting the connection.
    | negotiated*^a* |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `kCFStreamSSLLevel` | 用于加密连接的协议。 | negotiated*^a* |'
- en: '| `kCFStreamSSLAllowsExpiredCertificates` | Accept expired TLS certificates.
    | false |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `kCFStreamSSLAllowsExpiredCertificates` | 接受过期的 TLS 证书。 | false |'
- en: '| `kCFStreamSSLAllowsExpiredRoots` | Accept certificates that have expired
    root certificates in their certificate chain. | false |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `kCFStreamSSLAllowsExpiredRoots` | 接受证书链中包含已过期根证书的证书。 | false |'
- en: '| `kCFStreamSSLAllowsAnyRoot` | Whether a root certificate can be used as a
    TLS endpoint’s certificate (in other words, a self-signed or unsigned certificate).
    | false |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `kCFStreamSSLAllowsAnyRoot` | 是否可以使用根证书作为 TLS 端点的证书（换句话说，自签名或未签名证书）。 | false
    |'
- en: '| `kCFStreamSSLValidatesCertificateChain` | Whether the certificate chain is
    validated. | true |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `kCFStreamSSLValidatesCertificateChain` | 是否验证证书链。 | true |'
- en: '| `kCFStreamSSLPeerName` | Overrides the hostname compared to that of the certificate’s
    CN. If set to `kCFNull`, no validation is performed. | hostname |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `kCFStreamSSLPeerName` | 覆盖与证书的 CN 比较的主机名。如果设置为 `kCFNull`，则不执行验证。 | hostname
    |'
- en: '| `kCFStreamSSLIsServer` | Whether this stream will act as a server. | false
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `kCFStreamSSLIsServer` | 此流是否作为服务器使用。 | false |'
- en: '| `kCFStreamSSLCertificates` | An array of certificates that will be used if
    `kCFStreamSSLIsServer` is true. | none |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `kCFStreamSSLCertificates` | 如果`kCFStreamSSLIsServer`为真，将使用的证书数组。 | 无 |'
- en: '*a*. The default constant is `kCFStreamSocketSecurityLevelNegotiatedSSL`, which
    negotiates the strongest method available from the server.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*. 默认常量是`kCFStreamSocketSecurityLevelNegotiatedSSL`，它会与服务器协商使用最强的可用方法。'
- en: 'You probably shouldn’t be using these security constants at all, but if you
    must use TLS `CFStream`s, just do it the right way. It’s simple! Provided that
    you’re not creating a network server within the app itself (which is a pretty
    rare usage of `CFStream` in an iOS app), there are two steps you should follow:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能根本不应该使用这些安全常量，但如果你必须使用TLS `CFStream`，就按照正确的方法操作。这很简单！前提是你没有在应用内创建网络服务器（这是`CFStream`在iOS应用中相当罕见的用法），你需要遵循两个步骤：
- en: Set `kCFStreamSSLLevel` to `kCFStreamSocketSecurityLevelTLSv1`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`kCFStreamSSLLevel`设置为`kCFStreamSocketSecurityLevelTLSv1`。
- en: Don’t mess with anything else.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要搞乱其他任何东西。
- en: '**Closing Thoughts**'
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结束语**'
- en: You’ve looked at quite a number of ways for apps to communicate with the outside
    world and the incorrect ways those things can be implemented. Let’s now turn our
    attention to communication with other applications and some of the pitfalls that
    can happen when shuffling data around via IPC.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了许多应用与外界通信的方式，以及这些方式可能会被错误实现的情况。现在让我们把注意力转向与其他应用的通信，以及通过IPC传输数据时可能遇到的一些陷阱。
