- en: '![](../images/pg160.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg160.jpg)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-17.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-17.xhtml)</samp>
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">FUNCTIONS</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">函数</samp>
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: '*Functions*—chunks of code that can be defined in one place and invoked somewhere
    else—are a fundamental concept in every mainstream programming language. They’re
    so fundamental, in fact, that there are dedicated processor instructions just
    for making function calls. In this chapter, you’ll implement function calls and
    definitions according to the standard *calling convention* for Unix-like systems,
    which defines exactly how function calls should work at the assembly level. Calling
    conventions make it possible for binaries that were compiled separately (and might
    even have been written in different source languages) to interoperate. By following
    your system’s calling convention, you’ll be able to compile programs that call
    functions in external libraries, including the standard library. The programs
    you compile will finally be able to perform I/O operations! Programs built by
    other compilers will also be able to use libraries built by your compiler.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*——可以在一个地方定义并在其他地方调用的代码块——是每种主流编程语言中的基本概念。实际上，它们如此基础，以至于有专门的处理器指令来进行函数调用。在本章中，你将根据类Unix系统的标准*调用约定*实现函数调用和定义，调用约定精确定义了函数调用在汇编级别的工作方式。调用约定使得分别编译的二进制文件（即使它们可能是用不同的源语言编写的）能够相互操作。通过遵循你系统的调用约定，你将能够编译调用外部库函数的程序，包括标准库。你编译的程序最终将能够执行I/O操作！由其他编译器构建的程序也将能够使用你编译器构建的库。'
- en: We’ll spend most of this chapter on semantic analysis and assembly code generation.
    In the semantic analysis stage, we’ll add a new *type checking* pass, which is
    bolded in the diagram at the start of this chapter. This pass is pretty bare-bones
    for now, but we’ll build on it as we add new types throughout [Part II](part2.xhtml).
    In the assembly generation stage, we’ll dig into our system’s calling convention,
    which tells us how to set up stack frames, pass arguments and return values, and
    transfer control from one function to another.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容将集中在语义分析和汇编代码生成上。在语义分析阶段，我们将添加一个新的*类型检查*过程，在本章开始时的图示中已被加粗显示。这个过程目前非常简化，但随着我们在[第二部分](part2.xhtml)中添加新类型，它会不断发展。在汇编生成阶段，我们将深入探讨系统的调用约定，它告诉我们如何设置堆栈帧、传递参数和返回值，以及如何从一个函数转移控制到另一个函数。
- en: To get started, let’s define exactly what features we’re about to implement.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来明确我们将要实现的功能。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Declaring, Defining, and Calling Functions</samp>
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">声明、定义和调用函数</samp>
- en: In this chapter, you’ll implement function calls, function declarations, and
    function definitions. A function *declaration* tells you a function’s name and
    type. The declaration brings the function name into scope so it can be called
    later. A function *definition* is a declaration that includes a function body.
    (All function definitions are declarations, but not all declarations are definitions.)
    Your compiler already has some support for function definitions, since it can
    compile <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>. Now you’ll
    generalize it to compile other functions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将实现函数调用、函数声明和函数定义。一个函数*声明*告诉你函数的名称和类型。声明将函数名引入作用域，以便后续调用。一个函数*定义*是一个包含函数体的声明。（所有函数定义都是声明，但并非所有声明都是定义。）你的编译器已经支持某些函数定义，因为它可以编译<samp
    class="SANS_TheSansMonoCd_W5Regular_11">main</samp>。现在，你将将其通用化，以编译其他函数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declarations and
    Definitions</samp>
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">声明和定义</samp>
- en: A function declaration, like the one in [Listing 9-1](chapter9.xhtml#list9-1),
    must include the function’s return type, its name, and a type and name for each
    parameter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数声明，像[清单 9-1](chapter9.xhtml#list9-1)中的函数声明，必须包括函数的返回类型、函数名，以及每个参数的类型和名称。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-1: A function declaration</samp>'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 9-1：一个函数声明</samp>
- en: 'For now, a function’s return type and parameter types all have to be <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. As we’ve already seen, if
    a function has no parameters, its parameter list is just the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    keyword:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，函数的返回类型和参数类型都必须是 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。正如我们之前看到的，如果函数没有参数，它的参数列表只是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 关键字：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A function definition looks just like the function declaration from [Listing
    9-1](chapter9.xhtml#list9-1), plus a body. [Listing 9-2](chapter9.xhtml#list9-2)
    shows an example of a function definition.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义看起来就像 [清单 9-1](chapter9.xhtml#list9-1) 中的函数声明，外加一个函数体。[清单 9-2](chapter9.xhtml#list9-2)
    显示了一个函数定义的例子。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-2: A function definition</samp>'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 9-2：一个函数定义</samp>
- en: 'You can declare the same function as many times as you like, but all the declarations
    must be compatible: the return type, parameter types, and number of parameters
    must be the same. The parameter names can vary between declarations, because only
    the parameter names in the function definition are used. [Listing 9-3](chapter9.xhtml#list9-3),
    for example, is perfectly valid.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以多次声明相同的函数，但所有声明必须兼容：返回类型、参数类型和参数个数必须相同。参数名称可以在声明之间有所不同，因为只有函数定义中的参数名称会被使用。例如，[清单
    9-3](chapter9.xhtml#list9-3) 就是完全有效的。
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-3: Declaring a function
    multiple times with different parameter names</samp>'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 9-3：用不同的参数名称多次声明一个函数</samp>
- en: While it’s legal to declare a function multiple times, you cannot define a function
    more than once; if you did, when the function was called, there would be no way
    to tell which definition to execute.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然声明一个函数多次是合法的，但你不能定义一个函数多次；如果你这么做，当调用该函数时，就无法判断执行哪个定义。
- en: 'You can declare functions in two places: at the top level and inside the body
    of other functions. [Listing 9-4](chapter9.xhtml#list9-4) includes both kinds
    of declarations.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在两个地方声明函数：在顶层或在其他函数的主体内。[清单 9-4](chapter9.xhtml#list9-4) 包含了这两种声明方式。
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-4: Nested and top-level
    function declarations</samp>'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 9-4：嵌套和顶级函数声明</samp>
- en: You can’t define a function in the body of another function, however. The C
    standard supports function definitions only at the top level, so it doesn’t allow
    programs like [Listing 9-5](chapter9.xhtml#list9-5).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你不能在另一个函数的主体内定义函数。C标准只支持在顶层定义函数，因此它不允许像 [清单 9-5](chapter9.xhtml#list9-5)
    这样的程序。
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-5: A nested function
    definition (not supported)</samp>'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 9-5：嵌套函数定义（不支持）</samp>
- en: Some compilers support nested function definitions as a language extension and
    will compile [Listing 9-5](chapter9.xhtml#list9-5) just fine. We won’t implement
    this language extension; we’re sticking with features that are in the C standard.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编译器作为语言扩展支持嵌套函数定义，并能够成功编译 [清单 9-5](chapter9.xhtml#list9-5)。我们不会实现这个语言扩展；我们只坚持使用C标准中的功能。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Function Calls</samp>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">函数调用</samp>'
- en: 'A function call consists of a function name followed by a sequence of comma-separated
    arguments, wrapped in parentheses:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用由一个函数名，后跟一系列用逗号分隔的参数，这些参数被括在圆括号中：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While the identifiers in a function declaration are called function *parameters*,
    the expressions passed into a function call are called function *arguments*. For
    example, in [Listing 9-6](chapter9.xhtml#list9-6), <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    are parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>, while
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">2
    * c</samp> are arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '在函数声明中的标识符被称为函数*参数*，传递给函数调用的表达式则被称为函数*实参*。例如，在[清单 9-6](chapter9.xhtml#list9-6)中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">c</samp>是< samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>的参数，而<a
    href="#">a</a> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">2 * c</samp>是传递给< samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>的实参。 '
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-6: Function parameters
    and arguments</samp>'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 9-6：函数参数与实参</samp>
- en: As [Listing 9-7](chapter9.xhtml#list9-7) illustrates, a function must be declared,
    but not necessarily defined, before it can be called.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如[清单 9-7](chapter9.xhtml#list9-7)所示，函数必须在调用之前声明，但不一定要定义。
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-7: Declaring and
    then calling a function</samp>'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 9-7：声明函数并调用它</samp>
- en: The definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> may
    appear later in the same file, or it may appear in a separate library. It’s up
    to the linker, not your compiler, to find the definition of every function your
    program calls. If it can’t find the definition, linking will fail.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>的定义可能会出现在同一个文件的后面，或者可能出现在单独的库中。寻找程序调用的每个函数的定义是链接器的任务，而不是编译器。如果链接器无法找到定义，链接将失败。
- en: It’s illegal to call a function before it’s declared, so [Listing 9-8](chapter9.xhtml#list9-8)
    is invalid.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数声明之前调用函数是非法的，因此[清单 9-8](chapter9.xhtml#list9-8)是无效的。
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-8: Calling a function
    before it’s declared</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 9-8：调用一个未声明的函数</samp>
- en: In practice, many compilers warn about programs that call undeclared functions,
    but don’t reject them. Our implementation is stricter and rejects programs like
    [Listing 9-8](chapter9.xhtml#list9-8) during semantic analysis.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，许多编译器会警告调用未声明函数的程序，但不会拒绝它们。我们的实现更为严格，在语义分析期间会拒绝像[清单 9-8](chapter9.xhtml#list9-8)这样的程序。
- en: 'It’s also illegal to call a function with the wrong number of arguments, or
    to call a variable as a function. (Function pointers would be an exception to
    this second point if we were implementing them.)  #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Identifier
    Linkage</samp>'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数时使用错误数量的实参，或者将变量当作函数来调用也是非法的。（如果我们在实现函数指针时，这一点会有例外。）#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">标识符链接</samp>
- en: Function and variable names are both identifiers. They exist in the same namespace
    and follow the same scoping rules. Function names, like variable names, can be
    shadowed by other declarations in inner scopes. Consider [Listing 9-9](chapter9.xhtml#list9-9),
    where the variable name <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    shadows the function name <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名和变量名都是标识符。它们存在于相同的命名空间中，并遵循相同的作用域规则。像变量名一样，函数名也可以被内层作用域中的其他声明所遮蔽。请看[清单 9-9](chapter9.xhtml#list9-9)，其中变量名<samp
    class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>遮蔽了函数名<samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>。
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-9: A variable name
    shadowing a function name</samp>'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 9-9：变量名遮蔽函数名</samp>
- en: This program compiles without error and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>.
    Function names can also shadow variable names, as [Listing 9-10](chapter9.xhtml#list9-10)
    demonstrates.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序可以正常编译并返回<samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>。如[清单 9-10](chapter9.xhtml#list9-10)所示，函数名也可以遮蔽变量名。
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-10: A function name
    shadowing a variable name</samp>'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 9-10：一个函数名覆盖一个变量名</samp>
- en: Here, the function name <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    shadows the variable name <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>;
    this program compiles without error too, as long as the function <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    is defined somewhere else.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，函数名 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 覆盖了变量名 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>；只要函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    在其他地方定义，这个程序也可以编译通过。
- en: In other ways, however, function declarations are resolved very differently
    from the local variable declarations we’ve seen so far. Every local variable declaration
    refers to a different variable, even if some of those variables have the same
    name (we make this explicit when we give a unique name to each variable in the
    variable resolution pass). But multiple function declarations with the same name
    all refer to the same function. Consider [Listing 9-11](chapter9.xhtml#list9-11),
    which includes three function declarations that use the name <samp class="SANS_TheSansMonoCd_W5Regular_11">incr</samp>.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在其他方面，函数声明的解析与我们之前看到的局部变量声明非常不同。每个局部变量声明都引用不同的变量，即使其中一些变量具有相同的名称（当我们在变量解析过程中为每个变量提供唯一的名称时，我们会明确指出这一点）。但是，多个同名的函数声明都引用同一个函数。考虑[列表
    9-11](chapter9.xhtml#list9-11)，其中包括三个使用名称 <samp class="SANS_TheSansMonoCd_W5Regular_11">incr</samp>
    的函数声明。
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-11: Multiple function
    declarations that refer to a single definition</samp>'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 9-11：多个函数声明引用单个定义</samp>
- en: Each of these declarations ultimately refers to the same function definition.
    This listing doesn’t contain declarations of three different functions called
    <samp class="SANS_TheSansMonoCd_W5Regular_11">incr</samp>; it contains three declarations
    of the same function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些声明中的每一个最终都引用相同的函数定义。这个列表不包含三个不同的函数声明，名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">incr</samp>；它包含三个相同函数的声明。
- en: In the C standard, a declaration’s *linkage* determines how it relates to other
    declarations of the same identifier. There are a few different kinds of linkage.
    According to section 6.2.2, paragraph 2, of the C standard, “each declaration
    of a particular identifier with *external linkage* denotes the same object or
    function.” In [Listing 9-11](chapter9.xhtml#list9-11), every declaration of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">incr</samp> has external linkage, so these
    declarations all refer to the same function definition. Declarations with external
    linkage can refer to the same object or function even if they appear in different
    translation units. (A *translation unit* is just a preprocessed source file.)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 标准中，一个声明的 *链接性* 决定了它如何与同一标识符的其他声明相关联。链接性有几种不同的类型。根据 C 标准第 6.2.2 节第 2 段，“每个具有
    *外部链接性* 的特定标识符的声明表示相同的对象或函数。”在[列表 9-11](chapter9.xhtml#list9-11)中，每个 <samp class="SANS_TheSansMonoCd_W5Regular_11">incr</samp>
    的声明都有外部链接性，因此这些声明都引用相同的函数定义。具有外部链接性的声明即使出现在不同的翻译单元中，也可以引用相同的对象或函数。（*翻译单元* 就是一个经过预处理的源文件。）
- en: Consider a program made up of two different files. In one file, shown in [Listing
    9-12](chapter9.xhtml#list9-12), we define a function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个由两个不同文件组成的程序。在一个文件中，如[列表 9-12](chapter9.xhtml#list9-12)所示，我们定义一个函数。
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-12: Defining a library
    function in one file</samp>'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 9-12：在一个文件中定义一个库函数</samp>
- en: In the other file, which is shown in [Listing 9-13](chapter9.xhtml#list9-13),
    we declare and use that function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个文件中，如[列表 9-13](chapter9.xhtml#list9-13)所示，我们声明并使用该函数。
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-13: Declaring and
    calling the library function in a different file</samp>'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 9-13：在不同文件中声明并调用库函数</samp>
- en: 'Even though <samp class="SANS_TheSansMonoCd_W5Regular_11">library_fun</samp>
    is declared in two different files, the linker will recognize that both of these
    declarations refer to the same thing: the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">library_fun</samp>
    in [Listing 9-12](chapter9.xhtml#list9-12). It will then update every use of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">library_fun</samp> in the binary code
    for [Listing 9-13](chapter9.xhtml#list9-13) to point to the definition in [Listing
    9-12](chapter9.xhtml#list9-12).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管<samp class="SANS_TheSansMonoCd_W5Regular_11">library_fun</samp>在两个不同的文件中声明，链接器会识别这两个声明指向同一个内容：在[列出9-12](chapter9.xhtml#list9-12)中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">library_fun</samp>的定义。然后，它会更新在[列出9-13](chapter9.xhtml#list9-13)中的每个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">library_fun</samp>的使用，指向[列出9-12](chapter9.xhtml#list9-12)中的定义。
- en: In this chapter, all function identifiers have external linkage. Local variables,
    on the other hand, have no linkage*.* Section 6.2.2, paragraph 2, of the C standard
    says that “each declaration of an identifier with *no linkage* denotes a unique
    entity.” A local variable can’t refer to the same object as another local variable,
    and it can’t refer to the same thing as an identifier with external linkage, like
    a function name.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，所有函数标识符都有外部链接。另一方面，局部变量没有链接*。* C标准第6.2.2节第2段指出，“每个没有链接的标识符的声明都表示一个唯一的实体。”局部变量不能与另一个局部变量引用相同的对象，也不能与具有外部链接的标识符（如函数名）引用相同的内容。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*It may look like an identifier’s linkage depends only on whether it’s a function
    or a variable, but in the next chapter you’ll see that this isn’t the case. We’ll
    implement global variable declarations with external linkage, and we’ll implement
    function and variable declarations with a third kind of linkage,* internal linkage*.
    Declarations with internal linkage can be linked to other declarations in the
    same translation unit, but not in other translation units.*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*看起来标识符的链接性仅取决于它是函数还是变量，但在下一章中你将看到，情况并非如此。我们将实现具有外部链接的全局变量声明，并实现具有第三种链接性——*内部链接*——的函数和变量声明。具有内部链接的声明可以与同一翻译单元中的其他声明链接，但不能与其他翻译单元中的声明链接。*'
- en: Since all declarations of a given function name must refer to the same function
    definition, they must be compatible even if they appear in different scopes. [Listing
    9-14](chapter9.xhtml#list9-14) contains two incompatible function declarations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同一个函数名的所有声明必须指向同一个函数定义，即使它们出现在不同的作用域中，它们也必须兼容。[列出9-14](chapter9.xhtml#list9-14)包含了两个不兼容的函数声明。
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-14: Conflicting function
    declarations</samp>'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列出9-14：冲突的函数声明</samp>
- en: The two declarations of <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    should refer to the same function, since they both have external linkage. But
    no function definition could satisfy both declarations, since the numbers of parameters
    differ. Because the two declarations conflict, this code won’t compile.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 两个<samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>的声明应当指向同一个函数，因为它们都具有外部链接。然而没有任何一个函数定义能够同时满足这两个声明，因为它们的参数数量不同。由于这两个声明冲突，这段代码无法编译。
- en: Now that we’ve covered some background information on functions, we can get
    to work on the compiler. But we won’t start with the lexer right away. First,
    we need to update the compiler driver.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讲解了一些关于函数的背景知识，接下来可以开始编写编译器。但我们不会立即从词法分析器开始。首先，我们需要更新编译器驱动程序。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Compiling Libraries</samp>
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">编译库</samp>
- en: 'In previous chapters, we could compile only stand-alone executables. Every
    source file we compiled defined a <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function, which was the program’s entry point. Now that we can handle other functions,
    we should also be able to compile libraries, which don’t have an entry point.
    When your compiler translates source code into assembly, it doesn’t care whether
    it’s processing a library or an executable. Your compiler driver, however, does
    care, because the linker expects a complete program to include <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>.
    If you try to compile a source file with no <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function using your current compiler driver, you’ll get a linker error, which
    might look something like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们只能编译独立的可执行文件。每个我们编译的源文件都定义了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    函数，它是程序的入口点。现在我们能够处理其他函数时，我们也应该能够编译没有入口点的库。当你的编译器将源代码转换为汇编时，它并不关心是处理一个库还是可执行文件。然而，你的编译器驱动程序是关心的，因为链接器期望一个完整的程序包含
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>。如果你尝试用当前的编译器驱动程序编译一个没有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 函数的源文件，你会得到一个链接器错误，错误信息可能类似于以下内容：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This error means the linker is trying and failing to link your code against
    <samp class="SANS_TheSansMonoCd_W5Regular_11">crt0</samp>, the wrapper code that
    invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误意味着链接器正在尝试但未能将你的代码链接到 <samp class="SANS_TheSansMonoCd_W5Regular_11">crt0</samp>，即调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 的包装代码。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp> command accepts
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp> command line flag that
    tells it not to invoke the linker; when this flag is present, it generates an
    object file instead of an executable. To work with the test suite, your compiler
    driver should recognize the <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp>
    flag as well. When it’s passed this flag, the compiler driver should first convert
    the source program to assembly as usual, then run the following command to convert
    the assembly program into an object file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp> 命令接受一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp>
    命令行标志，告诉它不要调用链接器；当这个标志存在时，它会生成一个目标文件，而不是可执行文件。为了与测试套件一起工作，你的编译器驱动程序也应该识别 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-c</samp> 标志。当它收到这个标志时，编译器驱动程序应该像往常一样先将源程序转换为汇编文件，然后运行以下命令将汇编程序转换为目标文件：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The output filename should be the original filename with a *.o* suffix. In other
    words, <samp class="SANS_TheSansMonoCd_W5Regular_11">./YOUR_COMPILER -c /path/to/program.c</samp>
    should produce an object file at */path/to/program.o*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的文件名应该是原始文件名加上 *.o* 后缀。换句话说，<samp class="SANS_TheSansMonoCd_W5Regular_11">./YOUR_COMPILER
    -c /path/to/program.c</samp> 应该生成一个位于 */path/to/program.o* 的目标文件。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*If you wanted to compile and distribute a real library, you wouldn’t just
    produce an object file; you’d create a shared library (a* .so *file on Linux or
    a* .dylib *file on macOS). If you like, you can add another option to your compiler
    driver to produce shared libraries; your driver can convert an assembly program
    into a shared library instead of an object file by invoking GCC or Clang with
    the appropriate flags. But there’s a major limitation on your compiler’s ability
    to produce shared libraries, particularly on Linux; we’ll talk more about this
    in [Chapter 10](chapter10.xhtml).*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想要编译并分发一个真正的库，你不仅仅是生成一个目标文件；你应该创建一个共享库（在 Linux 上是一个 *.so* 文件，在 macOS 上是一个
    *.dylib* 文件）。如果你愿意，可以向你的编译器驱动程序添加另一个选项来生成共享库；你的驱动程序可以通过使用适当的标志调用 GCC 或 Clang，将汇编程序转换为共享库，而不是目标文件。但是，编译器生成共享库的能力有一个重大限制，特别是在
    Linux 上；我们将在[第 10 章](chapter10.xhtml)中详细讨论这个问题。*'
- en: At this point, you might also want to extend your compiler driver to accept
    multiple input source files. The test suite doesn’t require this feature, but
    you’ll need it if you want to compile multifile programs. To handle multiple source
    files, your compiler driver should convert each one to assembly separately, then
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp> command to assemble
    them and link them together.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可能还想扩展你的编译器驱动程序，以接受多个输入源文件。测试套件不要求这个功能，但如果你想编译多文件程序，你将需要它。为了处理多个源文件，你的编译器驱动程序应该分别将每个源文件转换为汇编文件，然后使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp> 命令将它们汇编并链接在一起。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">词法分析器</samp>
- en: 'You’ll add one token in this chapter:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你将添加一个新的标记：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> A comma
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> 逗号
- en: Lists of function parameters or arguments are comma-separated.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数或参数列表由逗号分隔。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">解析器</samp>
- en: 'We need to extend the AST in a couple of spots to support function calls, declarations,
    and definitions. Let’s start with function calls, which are a kind of expression:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在几个位置扩展 AST，以支持函数调用、声明和定义。让我们从函数调用开始，它是一种表达式：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The AST node for a function call includes the function name and a list of arguments.
    Each argument is an expression.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用的 AST 节点包含函数名和一组参数。每个参数都是一个表达式。
- en: 'Next, we’ll refactor the <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp>
    node so that it can represent either function or variable declarations:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重构<samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp>节点，使其既能表示函数声明，也能表示变量声明：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We’ve renamed the <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp>
    node to <samp class="SANS_TheSansMonoCd_W5Regular_11">function_declaration</samp>.
    (We’ll walk through the other changes to this node in a moment.) The <samp class="SANS_TheSansMonoCd_W5Regular_11">variable_declaration</samp>
    node includes the same information that <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp>
    did in earlier chapters: a variable name and an optional initializer. But it looks
    a little different from the other AST nodes we’ve seen so far; it doesn’t include
    a named constructor like <samp class="SANS_TheSansMonoCd_W5Regular_11">FunDecl</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">VarDecl</samp>. When a node in
    ASDL has multiple constructors—like the <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp>
    node and most of the other AST nodes do—each constructor needs a distinct name
    so we can tell them apart. But since the <samp class="SANS_TheSansMonoCd_W5Regular_11">variable_declaration</samp>
    node has only one constructor, we aren’t required to name that constructor. In
    ASDL jargon, a node definition with exactly one unnamed constructor is a *product
    type*. The other nodes we’ve used up until now are *sum types*, because they all
    have named constructors. Product types are just a syntactic convenience so that
    we aren’t forced to use clunky, redundant constructor names.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将<samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp>节点重命名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">function_declaration</samp>。（稍后我们会详细讲解此节点的其他更改。）<samp
    class="SANS_TheSansMonoCd_W5Regular_11">variable_declaration</samp>节点包含与之前章节中<samp
    class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp>相同的信息：变量名和可选的初始化值。但它与我们迄今为止看到的其他
    AST 节点有所不同；它不像<samp class="SANS_TheSansMonoCd_W5Regular_11">FunDecl</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">VarDecl</samp>那样包含一个命名构造函数。当 ASDL 中的一个节点有多个构造函数时——比如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp>节点和大多数其他 AST 节点——每个构造函数需要一个独特的名称，以便我们区分它们。但由于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">variable_declaration</samp>节点只有一个构造函数，因此不要求为该构造函数命名。在
    ASDL 术语中，具有一个未命名构造函数的节点定义被称为*产品类型*。我们迄今为止使用的其他节点都是*和类型*，因为它们都有命名的构造函数。产品类型只是语法上的一种便捷方式，这样我们就不需要使用笨重、冗余的构造函数名称。
- en: 'Now let’s update <samp class="SANS_TheSansMonoCd_W5Regular_11">function_declaration</samp>.
    Here’s the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">function _definition</samp>
    node:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新<samp class="SANS_TheSansMonoCd_W5Regular_11">function_declaration</samp>。以下是现有的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">function _definition</samp>节点：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We need to make a few changes here. First, as I already noted, we’ll rename
    it to the more accurate <samp class="SANS_TheSansMonoCd_W5Regular_11">function_declaration</samp>.
    We’ll also add function parameters, and we’ll make the function body optional
    so this node can represent both function declarations and function definitions.
    Lastly, for consistency with <samp class="SANS_TheSansMonoCd_W5Regular_11">variable_declaration</samp>,
    we’ll remove the <samp class="SANS_TheSansMonoCd_W5Regular_11">Function</samp>
    constructor name to turn this into a product type. Our revised AST node for representing
    function declarations and definitions is:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在这里进行一些更改。首先，正如我之前所提到的，我们将其重命名为更准确的<samp class="SANS_TheSansMonoCd_W5Regular_11">function_declaration</samp>。我们还将添加函数参数，并将函数体设为可选，这样该节点既可以表示函数声明，也可以表示函数定义。最后，为了与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">variable_declaration</samp>保持一致，我们将移除<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Function</samp>构造函数名称，从而将其转变为产品类型。我们修改后的
    AST 节点用于表示函数声明和定义如下：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we need to change the top-level definition of a program. Now, instead
    of a single <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function,
    a program is a list of function definitions and declarations:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要改变程序的顶层定义。现在，程序不再是一个单独的<samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>函数，而是一个包含函数定义和声明的列表：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[Listing 9-15](chapter9.xhtml#list9-15) shows the complete updated AST.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9-15节](chapter9.xhtml#list9-15)展示了完整的更新后的抽象语法树。'
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-15: The abstract
    syntax tree with function calls, declarations, and definitions</samp>'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">第9-15节：带有函数调用、声明和定义的抽象语法树</samp>
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp> can appear
    as a block item, but only a <samp class="SANS_TheSansMonoCd_W5Regular_11">variable_declaration</samp>
    can appear in a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    header. Note that this AST can represent nested function definitions, like the
    one in [Listing 9-5](chapter9.xhtml#list9-5), even though we don’t support them.
    We’ll check for nested function definitions during the semantic analysis stage
    and throw an error if we encounter any.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个<samp class="SANS_TheSansMonoCd_W5Regular_11">声明</samp>可以作为一个块项出现，但是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">变量声明</samp>只能出现在<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环头部。请注意，这个抽象语法树可以表示嵌套的函数定义，比如[第9-5节](chapter9.xhtml#list9-5)中的函数，尽管我们目前不支持它们。我们将在语义分析阶段检查嵌套的函数定义，并在遇到任何情况时抛出错误。
- en: '[Listing 9-16](chapter9.xhtml#list9-16) shows the updated grammar.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9-16节](chapter9.xhtml#list9-16)展示了更新后的语法。'
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-16: The grammar with
    function calls, declarations, and definitions</samp>'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">第9-16节：带有函数调用、声明和定义的语法</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11"><param-list></samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><argument-list></samp> symbols in [Listing
    9-16](chapter9.xhtml#list9-16) don’t have equivalent nodes in the AST. I’ve factored
    them out of the production rules for function declarations and function calls,
    respectively, to make those rules a bit more readable. A <samp class="SANS_TheSansMonoCd_W5Regular_11"><param-list></samp>
    consists of just the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    keyword if a function has no parameters; otherwise, it consists of a comma-separated
    list of parameters, each with a type and name. An <samp class="SANS_TheSansMonoCd_W5Regular_11"><argument-list></samp>
    consists of a comma-separated list of expressions. Note that <samp class="SANS_TheSansMonoCd_W5Regular_11"><param-list></samp>
    is required in a function declaration, but <samp class="SANS_TheSansMonoCd_W5Regular_11"><argument-list></samp>
    is optional in a function call. Parsing a comma-separated list of arguments or
    parameters is similar to parsing a list of block items; just consume the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">,</samp> tokens between list elements,
    and stop when you see a) token.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9-16节](chapter9.xhtml#list9-16)中的<samp class="SANS_TheSansMonoCd_W5Regular_11"><param-list></samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><argument-list></samp>符号在抽象语法树中没有等价的节点。我已经从函数声明和函数调用的产生规则中分离出它们，以使这些规则更易读。一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><param-list></samp>如果一个函数没有参数，只包含<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>关键字；否则，它包含一个逗号分隔的参数列表，每个参数都有类型和名称。一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><argument-list></samp>包含一个逗号分隔的表达式列表。请注意，函数声明中需要一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><param-list></samp>，但在函数调用中<samp class="SANS_TheSansMonoCd_W5Regular_11"><argument-list></samp>是可选的。解析逗号分隔的参数或参数类似于解析块项列表；只需在列表元素之间消耗<samp
    class="SANS_TheSansMonoCd_W5Regular_11">,</samp>标记，并在看到a）标记时停止。'
- en: Function calls have higher precedence than any binary or ternary operator, so
    you should handle them when parsing the <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>
    symbol. If a <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp> starts
    with an identifier, look ahead one token to figure out whether the expression
    is a variable or a function call. If the next token is <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp>,
    you can assume it’s a function call. Similarly, you’ll need to check for a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(</samp>token to distinguish between function
    and variable declarations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用的优先级高于任何二元或三元运算符，因此在解析<samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>符号时，应首先处理它们。如果一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>以标识符开始，请查看下一个符号以确定表达式是变量还是函数调用。如果下一个符号是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">(</samp>，可以假设这是一个函数调用。同样，你需要检查<samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp>符号，以区分函数和变量声明。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Semantic Analysis</samp>'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">语义分析</samp>'
- en: During the variable resolution pass, we give every local variable a new, unique
    name. However, we shouldn’t rename entities with external linkage. Two declarations
    of local variables named <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    refer to distinct memory addresses, so we assign them distinct names. But two
    declarations of a function named <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>
    refer to the same code, so those declarations should keep the same name throughout
    compilation. Furthermore, an object with external linkage must retain the name
    from the original source code because the linker will rely on that name during
    symbol resolution. The linker won’t be able to link an object file that calls
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> to the object file that
    defines <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> unless the name
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> was preserved when each
    of those object files was compiled.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量解析阶段，我们为每个局部变量赋予一个新的、独特的名称。然而，我们不应重命名具有外部链接的实体。两个名为<samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>的局部变量声明指向不同的内存地址，因此我们为它们分配不同的名称。但两个名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>的函数声明指向相同的代码，因此这些声明在编译过程中应保持相同的名称。此外，具有外部链接的对象必须保留来自原始源代码的名称，因为链接器将在符号解析时依赖该名称。除非在每个目标文件编译时都保留了名称<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>，否则链接器将无法将调用<samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>的目标文件与定义<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>的目标文件链接起来。
- en: We’ll therefore need to update the variable resolution pass to rename identifiers
    with no linkage but leave identifiers with external linkage unchanged. (Since
    this pass will handle functions as well as variables, I’ll call it *identifier
    resolution* instead of variable resolution from now on.) We’ll check for all the
    usual error conditions, like duplicate declarations and undeclared identifiers;
    we’ll also validate that there are no nested function definitions. The logic to
    catch duplicate declarations will change slightly, since it’s legal to declare
    a name with external linkage more than once in the same scope. For instance, [Listing
    9-17](chapter9.xhtml#list9-17) is perfectly valid.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要更新变量解析阶段，以重命名没有链接的标识符，但保留具有外部链接的标识符不变。（由于这个阶段将处理函数和变量，因此从现在开始我将其称为*标识符解析*，而非变量解析。）我们将检查所有常见的错误条件，比如重复声明和未声明的标识符；我们还将验证没有嵌套的函数定义。由于在同一作用域中多次声明具有外部链接的名称是合法的，捕获重复声明的逻辑会稍作修改。例如，[示例
    9-17](chapter9.xhtml#list9-17)是完全合法的。
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-17: Multiple function
    declarations in the same scope</samp>'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 9-17：同一作用域内的多个函数声明</samp>
- en: Because both declarations of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    have external linkage, they refer to the same function, so they don’t conflict.
    Duplicate declarations of an identifier conflict only when they refer to different
    entities; when you use that identifier later in the same scope, there’s no way
    to tell which entity it should refer to.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两个<samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>的声明都有外部链接，它们指向相同的函数，因此没有冲突。标识符的重复声明只有在它们指向不同的实体时才会冲突；当你在同一作用域中稍后使用该标识符时，无法判断它应该指向哪个实体。
- en: We also have a few other error cases to check for. We must validate that every
    declaration of a function has the same number of parameters and that no function
    is defined more than once. Also, we must validate that variables aren’t used as
    functions and that functions are called with the right number of arguments. These
    errors aren’t that similar to the error cases we already check for, because they’re
    not really about what identifiers are in scope. They’re *type errors*, which occur
    when different declarations of an object have conflicting types or when an object
    is used in a way its type doesn’t support.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些其他的错误情况需要检查。我们必须验证每个函数声明的参数数量是否一致，并确保没有函数被定义多次。同时，我们还要验证变量是否被当作函数使用，以及函数是否传入了正确数量的参数。这些错误和我们之前检查的错误情况不太相似，因为它们并不直接涉及标识符的作用域。它们是*类型错误*，当一个对象的不同声明具有冲突的类型，或者对象以其类型不支持的方式使用时，就会发生类型错误。
- en: We’ll define a separate type checking pass to catch these errors. This pass
    will also build up a symbol table to store the type of every identifier in the
    program, along with a few other properties of identifiers that we need to track.
    We’ll refer back to the symbol table in later compiler stages. (This is different
    from the symbol table in an object file, which the linker uses during symbol resolution.
    The symbol table we build in the type checker is internal to the compiler.)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个独立的类型检查阶段来捕捉这些错误。此阶段还将构建一个符号表，用来存储程序中每个标识符的类型以及我们需要跟踪的其他一些标识符属性。在编译器的后续阶段，我们将回头参考这个符号表。（这不同于目标文件中的符号表，链接器在符号解析期间使用它。我们在类型检查器中构建的符号表是编译器内部的。）
- en: 'At the end of this chapter, the semantic analysis stage will consist of three
    passes: identifier resolution, type checking, and loop labeling. The loop labeling
    pass can happen at any point relative to the other two passes.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，语义分析阶段将包括三个阶段：标识符解析、类型检查和循环标记。循环标记阶段可以在其他两个阶段的任意时刻进行。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extending Identifier
    Resolution</samp>
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">扩展标识符解析</samp>
- en: 'Let’s update the identifier resolution pass to handle function calls, function
    declarations, and function definitions. We’ll need to track one new piece of information
    for each entry in the identifier map: whether it has external linkage. As you
    build up your identifier map, don’t assume that functions always have external
    linkage and variables never do. That assumption holds right now, but it won’t
    in the next chapter.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新标识符解析阶段，以处理函数调用、函数声明和函数定义。我们需要为标识符映射中的每个条目跟踪一项新的信息：它是否具有外部链接性。在构建标识符映射时，不要假设函数总是具有外部链接性，而变量永远没有。这个假设目前成立，但在下一章中它将不再成立。
- en: 'We’ll also update a couple of names in our pseudocode: we’ll change <samp class="SANS_TheSansMonoCd_W5Regular_11">variable_map</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier_map</samp>, and we’ll
    rename the <samp class="SANS_TheSansMonoCd_W5Regular_11">from_current_block</samp>
    field in the identifier map to <samp class="SANS_TheSansMonoCd_W5Regular_11">from_current_scope</samp>,
    since function declarations can appear outside of blocks, at the top level.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将更新伪代码中的一些名称：将<samp class="SANS_TheSansMonoCd_W5Regular_11">variable_map</samp>改为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">identifier_map</samp>，并将标识符映射中的<samp class="SANS_TheSansMonoCd_W5Regular_11">from_current_block</samp>字段重命名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">from_current_scope</samp>，因为函数声明可以出现在块之外，即在顶层。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Function Calls</samp>
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">函数调用</samp>
- en: A function name, like a variable name, needs to be present in the identifier
    map before you can use it. [Listing 9-18](chapter9.xhtml#list9-18) demonstrates
    how <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp> should handle
    function calls.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名，像变量名一样，必须在标识符映射中存在才能使用。[列表 9-18](chapter9.xhtml#list9-18)展示了如何由<samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>处理函数调用。
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-18: Resolving function
    calls</samp>'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 9-18：解析函数调用</samp>
- en: First, we look up the function name in the identifier map to confirm that it’s
    in scope at this point in the program. Then, we replace this name with the new
    name from the identifier map. In a valid program, this new name will be the same
    as the original name, since we don’t rename identifiers with external linkage.
    But we also need to consider invalid programs. Maybe <samp class="SANS_TheSansMonoCd_W5Regular_11">fun_name</samp>
    is actually the name of a local variable instead of a function; in that case,
    trying to call it like a function is a type error. Resolving <samp class="SANS_TheSansMonoCd_W5Regular_11">fun
    _name</samp> here will allow us to catch this type error during type checking.
    We’ll also wait until the type checking pass to make sure this function call has
    the right number of arguments.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在标识符映射中查找函数名称，以确认它在程序的当前阶段是否在作用域中。然后，我们用标识符映射中的新名称替换这个名称。在一个有效的程序中，这个新名称将与原始名称相同，因为我们不会重命名具有外部链接的标识符。但我们也需要考虑无效程序的情况。也许<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fun_name</samp>实际上是一个局部变量的名称，而不是函数；在这种情况下，尝试像调用函数一样调用它就是一个类型错误。解析<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fun_name</samp>将使我们在类型检查时捕捉到这个类型错误。我们还会等到类型检查通过后再确认该函数调用是否有正确数量的参数。
- en: After we replace the function’s name, we recursively call <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>
    on each function argument, just like we recursively resolve each subexpression
    in unary, binary, and ternary expressions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们替换函数名称后，我们会递归地对每个函数参数调用<samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>，就像我们递归地解析一元、二元和三元表达式中的每个子表达式一样。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Function Declarations</samp>
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">函数声明</samp>
- en: Now let’s consider function declarations. We can handle a function declaration
    in almost exactly the same way whether it appears in a block or at the top level.
    First, we add the function name to the current scope. Then, we process its parameters,
    adding them to a new inner scope. Finally, if there’s a function body, we process
    that too. [Listing 9-19](chapter9.xhtml#list9-19) illustrates how to resolve function
    declarations.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑函数声明。无论函数声明出现在代码块中还是顶层，我们几乎都可以以完全相同的方式处理它。首先，我们将函数名称添加到当前作用域。然后，我们处理它的参数，将它们添加到一个新的内部作用域。最后，如果有函数体，我们也处理它。[清单
    9-19](chapter9.xhtml#list9-19)展示了如何解析函数声明。
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-19: Resolving function
    declarations</samp>'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 9-19: 解析函数声明</samp>'
- en: Before we update the identifier map, we need to make sure that we’re not illegally
    redeclaring an identifier ❶. If the identifier isn’t already in scope, there’s
    no conflict. If the identifier was declared in an outer scope, that’s also fine;
    the new declaration shadows the existing one. So far, this is exactly the same
    as how we handle variable declarations. However, we also need to consider linkage.
    Multiple declarations of an identifier with external linkage can appear in the
    same scope. We already know the new declaration has external linkage because it’s
    a function declaration, so it’s legal as long as the old declaration has external
    linkage too. But if the old declaration has no linkage (because it declares a
    local variable), we’ll throw an error. The <samp class="SANS_TheSansMonoCd_W5Regular_11">has_linkage</samp>
    attribute in the identifier map tells us whether an identifier has external linkage.
    (In the next chapter, it will track whether the identifier has any linkage at
    all, either internal or external.)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更新标识符映射之前，需要确保我们没有非法地重新声明一个标识符❶。如果标识符当前不在作用域中，那么就没有冲突。如果标识符在外部作用域中已经声明，那也是没问题的；新的声明会覆盖旧的声明。到目前为止，这和我们处理变量声明的方式完全相同。不过，我们还需要考虑链接性。具有外部链接的标识符的多个声明可以出现在同一作用域中。我们已经知道新的声明具有外部链接，因为它是一个函数声明，所以只要旧的声明也具有外部链接，这样做是合法的。但是，如果旧的声明没有链接（因为它声明了一个局部变量），我们将抛出错误。标识符映射中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">has_linkage</samp>属性告诉我们一个标识符是否具有外部链接。（在下一章中，它将跟踪标识符是否具有任何链接性，无论是内部还是外部。）
- en: If there’s no conflicting declaration, we add this name to <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier_map</samp>
    ❷. We don’t generate new names for functions; the <samp class="SANS_TheSansMonoCd_W5Regular_11">new_name</samp>
    attribute for this map entry should just be the original name. Because this declaration
    has external linkage, the <samp class="SANS_TheSansMonoCd_W5Regular_11">has_linkage</samp>
    attribute should be <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有冲突的声明，我们将此名称添加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier_map</samp>
    ❷。我们不会为函数生成新名称；该映射条目的 <samp class="SANS_TheSansMonoCd_W5Regular_11">new_name</samp>
    属性应为原始名称。因为该声明具有外部链接性，<samp class="SANS_TheSansMonoCd_W5Regular_11">has_linkage</samp>
    属性应为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。
- en: 'Next, we resolve the parameter names. The list of function parameters in a
    declaration starts a new scope, so we make a copy of the identifier map to keep
    track of them ❸. Parameter names can shadow names from the outer scope, but two
    parameters in the same function declaration can’t share a name. So, this is legal:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们解析参数名称。声明中的函数参数列表开启了一个新作用域，因此我们需要复制标识符映射以跟踪它们 ❸。参数名称可以覆盖外部作用域中的名称，但同一个函数声明中的两个参数不能共享名称。所以，这是合法的：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'But this is not:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这不是：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'I’ve left out the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_param</samp>,
    but it should be the same as your existing code to resolve variable declarations:
    it should make sure the parameter name isn’t already declared in the current scope,
    generate a unique name for it, add it to the identifier map, and return the new
    name. You may want to write one helper function to resolve both parameters and
    local variable declarations, since the logic is the same in both cases.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我省略了 <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_param</samp> 的伪代码，但它应该与你现有的代码相同，用于解决变量声明：它应确保参数名称在当前作用域中尚未声明，生成一个唯一的名称，为其添加到标识符映射中，并返回新的名称。你可能想写一个辅助函数来解决参数和局部变量声明，因为在这两种情况下逻辑是相同的。
- en: We resolve the function’s parameters for two reasons. First, we need to validate
    that there are no duplicate parameter names. Second, we need to make sure the
    parameters are in scope when we process the function body. When we process a function
    declaration with no body, the second point doesn’t matter; we could get away with
    checking for duplicate parameters without renaming them or updating the inner
    scope. However, I think it’s easiest to process function declarations in a uniform
    way whether they have a body or not.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解析函数的参数有两个原因。首先，我们需要验证没有重复的参数名称。其次，我们需要确保在处理函数体时，参数处于作用域中。当我们处理没有函数体的函数声明时，第二点就不重要了；我们可以通过检查重复的参数而不重命名它们或更新内部作用域来完成。然而，我认为最简单的做法是无论函数是否有体，都以统一的方式处理函数声明。
- en: The last step in [Listing 9-19](chapter9.xhtml#list9-19) is processing the function
    body, if there is one. We handle this with <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_block</samp>,
    as usual; we just need to make sure to pass in <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_map</samp>
    so the function parameters will be in scope. The function name itself is also
    in scope because we added it to the outer map before making a copy; we’ll therefore
    be able to handle functions that call themselves recursively.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 9-19](chapter9.xhtml#list9-19) 的最后一步是处理函数体（如果有的话）。我们像往常一样使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">resolve_block</samp> 来处理；我们只需要确保传入 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">inner_map</samp>，这样函数参数就会在作用域内。函数名本身也在作用域内，因为我们在复制之前已经将其添加到外部映射中；因此，我们能够处理递归调用自身的函数。'
- en: 'The function parameters and function body are in the same scope, so you should
    pass in <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_map</samp>, and not
    a copy of it, when you process the function body. This, for example, is illegal:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数和函数体处于同一作用域中，因此在处理函数体时，应该传入 <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_map</samp>，而不是它的副本。例如，这就是非法的：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The variable declaration <samp class="SANS_TheSansMonoCd_W5Regular_11">int a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">3;</samp>
    is an illegal duplicate declaration because it’s in the same scope as parameter
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明 <samp class="SANS_TheSansMonoCd_W5Regular_11">int a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">3;</samp> 是一个非法的重复声明，因为它与参数 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 在同一个作用域中。
- en: At this point, we can return the updated <samp class="SANS_TheSansMonoCd_W5Regular_11">function_declaration</samp>
    node. While the function name itself hasn’t changed, the list of parameters and
    any variables declared in the function body have been renamed in this new node.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们可以返回更新后的<samp class="SANS_TheSansMonoCd_W5Regular_11">function_declaration</samp>节点。尽管函数名本身没有改变，但函数体内声明的参数列表和任何变量都已在此新节点中被重命名。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Local Declarations</samp>
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">局部声明</samp>
- en: You can process local variable declarations exactly the same way as in previous
    chapters; just be sure to record in the identifier map that these declarations
    do not have linkage. To process a local function declaration, first check if it
    has a body. If it does, throw an error; otherwise, call <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve
    _function_declaration</samp>, which we defined in [Listing 9-19](chapter9.xhtml#list9-19).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像前几章一样处理局部变量声明；只需确保在标识符映射中记录这些声明没有链接性。要处理局部函数声明，首先检查它是否有函数体。如果有，抛出一个错误；否则，调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">resolve _function_declaration</samp>，这是我们在[示例
    9-19](chapter9.xhtml#list9-19)中定义的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Top-Level Processing</samp>
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">顶层处理</samp>
- en: Finally, we need to put all this together to process a list of function declarations.
    Just process them in order, building up the identifier map as you go. Each function
    name you add will remain in scope as you process later function declarations.
    The parameter names and local variables in a function won’t be visible in later
    functions, because they were added to an inner scope.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将所有这些内容整合在一起，以处理函数声明的列表。按顺序处理它们，同时在过程中构建标识符映射。你添加的每个函数名将在后续处理的函数声明中保持作用域。函数中的参数名和局部变量在后续函数中不可见，因为它们被添加到内层作用域。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Type
    Checker</samp>
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">编写类型检查器</samp>
- en: Our remaining validation is all type checking. Every identifier, whether it’s
    a function or a variable, has a type. Variables can have types like <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    but at this point in our project the type of every variable is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    A function’s type depends on its return type and the types of its parameters.
    For example, a function can have a type like “function that takes three <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> parameters and returns an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.” Right now, we support only
    functions that take <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> parameters
    and return <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> results, so
    only the number of parameters varies.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们剩下的验证全部是类型检查。每个标识符，无论是函数还是变量，都有一个类型。变量可以有像<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>这样的类型，但在我们项目的这个阶段，每个变量的类型都是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。一个函数的类型取决于其返回类型和参数的类型。例如，一个函数可以有这样的类型：“接收三个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>参数并返回一个<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。”现在，我们只支持接受<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>类型参数并返回<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>类型结果的函数，因此只有参数的数量会有所不同。
- en: 'The type checking pass validates that all declarations and uses of an identifier
    have compatible types. For example, if you declare that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is a variable, you can’t call it like a function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查阶段验证所有标识符的声明和使用是否具有兼容的类型。例如，如果你声明<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>是一个变量，你不能像调用函数一样使用它：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can’t declare a function in multiple places with different types:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在多个地方声明具有不同类型的函数：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can’t call a function with the wrong number of parameters:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能调用具有错误参数数量的函数：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And you can’t define the same function more than once:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你也不能多次定义相同的函数：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This last error isn’t a type error per se, but it’s easiest to check here.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误本身并不是类型错误，但最容易在这里检查。
- en: To type check the program, we’ll record the type of every identifier in the
    symbol table. We’ll also record whether each function we encounter is defined
    or just declared; that is, whether it has a body. The symbol table will be our
    central source of information about every identifier in the program. In this chapter,
    we’ll primarily use the symbol table to catch type errors. We’ll add more information
    to this table, and find more uses for it, in future chapters.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行类型检查，我们将记录符号表中每个标识符的类型。我们还将记录每个遇到的函数是已定义还是仅仅声明；也就是说，它是否有函数体。符号表将成为我们获取程序中每个标识符信息的核心来源。在本章中，我们将主要使用符号表来捕获类型错误。在未来的章节中，我们将向该表中添加更多信息，并找到更多使用它的方式。
- en: 'To build a symbol table, we need a way to represent types in the compiler,
    just like we need a way to represent ASTs. Right now, your type definition should
    look something like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建符号表，我们需要一种方法在编译器中表示类型，就像我们需要一种方法表示抽象语法树（AST）一样。目前，你的类型定义应该是这样的：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Every variable has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    and the only information we need about a function’s type is how many parameters
    it has. We’ll add more types in [Part II](part2.xhtml).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量的类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，我们只需要了解函数类型的一个信息，那就是它有多少个参数。在[第二部分](part2.xhtml)中，我们将添加更多的类型。
- en: We’ll build the symbol table by traversing the program in the usual fashion.
    When we encounter a function or variable declaration, we’ll record its type in
    the symbol table. The type checker doesn’t transform the AST like the identifier
    resolution pass does, so the individual type checking methods won’t return transformed
    AST nodes; they’ll just add symbol table entries and report errors. (The type
    checker *will* transform the AST in [Part II](part2.xhtml).)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过按常规方式遍历程序来构建符号表。当我们遇到函数或变量声明时，我们会在符号表中记录它的类型。类型检查器不像标识符解析阶段那样转换抽象语法树，因此各个类型检查方法不会返回转换后的
    AST 节点；它们只会添加符号表条目并报告错误。（类型检查器会在[第二部分](part2.xhtml)中转换抽象语法树。）
- en: '[Listing 9-20](chapter9.xhtml#list9-20) shows how to type check a variable
    declaration.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-20](chapter9.xhtml#list9-20) 展示了如何进行变量声明的类型检查。'
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-20: Type checking
    variable declarations</samp>'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 9-20：类型检查变量声明</samp>
- en: Every variable has a unique name by this point, so we know that this declaration
    won’t conflict with any existing entry in the symbol table. We just add it to
    the symbol table and then type check its initializer, if it has one. Functions
    are a little trickier. Because you can declare a function more than once, it might
    already have an entry in the symbol table. So, before adding a function to the
    symbol table, you need to validate it against what’s already there. [Listing 9-21](chapter9.xhtml#list9-21)
    gives the pseudocode to type check a function declaration.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量到此时都有了唯一的名称，因此我们知道这个声明不会与符号表中的任何现有条目冲突。我们只需将其添加到符号表中，然后检查其初始化器的类型（如果有的话）。函数稍微复杂一些。因为你可以声明一个函数多次，它可能已经在符号表中有条目。因此，在将函数添加到符号表之前，你需要验证它是否与已有条目冲突。[示例
    9-21](chapter9.xhtml#list9-21) 给出了类型检查函数声明的伪代码。
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-21: Type checking
    function declarations</samp>'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 9-21：类型检查函数声明</samp>
- en: We first check that the function hasn’t already been declared with a different
    type ❶. Then, we make sure we’re not redefining a function that was already defined
    ❷. The <samp class="SANS_TheSansMonoCd_W5Regular_11">defined</samp> attribute
    in a function’s symbol table entry tracks whether we’ve already type checked a
    definition of that function. (The symbol table entries for variables don’t need
    this attribute.)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查函数是否已经用不同的类型声明过 ❶。然后，确保我们没有重新定义一个已经定义过的函数 ❷。函数符号表条目中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">defined</samp>
    属性跟踪我们是否已经对该函数的定义进行了类型检查。（变量的符号表条目不需要这个属性。）
- en: After validation, we add the function to the symbol table ❸. This will overwrite
    the existing symbol table entry, if there is one. That’s okay, because the type
    won’t change. We just need to take the old entry into account when setting the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">defined</samp> attribute. If the
    function was already defined, or if the current declaration has a body, we’ll
    set <samp class="SANS_TheSansMonoCd_W5Regular_11">defined</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
    Finally, if the current declaration has a body ❹, we’ll add each of the function’s
    parameters to the symbol table, then type check the function body.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证后，我们将函数添加到符号表 ❸ 中。如果存在相应的条目，它会覆盖现有的符号表条目。这样是可以的，因为类型不会改变。我们只需要在设置 <samp class="SANS_TheSansMonoCd_W5Regular_11">defined</samp>
    属性时考虑旧的条目。如果该函数已经定义，或者当前声明具有函数体，我们会将 <samp class="SANS_TheSansMonoCd_W5Regular_11">defined</samp>
    设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。最后，如果当前声明有函数体 ❹，我们会将每个函数的参数添加到符号表中，然后对函数体进行类型检查。
- en: 'Keep in mind that the symbol table includes every declaration we’ve type checked
    so far, even if it’s not in scope. Consider this example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，符号表包括我们迄今为止已进行类型检查的每一个声明，即使它不在当前作用域内。考虑这个例子：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The nested function declaration ❶ is not in scope when the function is declared
    again ❷. Nonetheless, declaration ❶ will be in the symbol table when we type check
    declaration ❷. So, we’ll detect that these two declarations conflict and throw
    an error.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的函数声明 ❶ 在函数重新声明 ❷ 时不在作用域内。然而，当我们进行声明 ❷ 的类型检查时，声明 ❶ 会出现在符号表中。因此，我们会检测到这两个声明冲突并抛出错误。
- en: We’ll validate uses of identifiers as well as declarations. An identifier can
    be used as a variable in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>
    AST node or as a function name in a <samp class="SANS_TheSansMonoCd_W5Regular_11">FunctionCall</samp>
    AST node. In both cases, you should validate that the identifier has the expected
    type. [Listing 9-22](chapter9.xhtml#list9-22) demonstrates how to type check both
    kinds of expressions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将验证标识符的使用和声明。标识符可以在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>
    AST 节点中作为变量使用，或者在 <samp class="SANS_TheSansMonoCd_W5Regular_11">FunctionCall</samp>
    AST 节点中作为函数名使用。在这两种情况下，您都应该验证该标识符是否具有预期的类型。[列表 9-22](chapter9.xhtml#list9-22)
    演示了如何类型检查这两种类型的表达式。
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-22: Type checking
    expressions</samp>'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 9-22：类型检查表达式</samp>
- en: When an identifier is called as a function, you need to validate that it was
    declared as a function, not an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    ❶. You also need to validate that it’s called with the correct number of arguments
    ❷, then recursively type check each of its arguments ❸. When an identifier is
    used as a variable, you need to validate that it was declared as a variable and
    not a function ❹.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当标识符作为函数被调用时，您需要验证它是否被声明为函数，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    ❶。您还需要验证它是否使用了正确数量的参数 ❷，然后递归地对每个参数进行类型检查 ❸。当标识符作为变量使用时，您需要验证它是否被声明为变量，而不是函数 ❹。
- en: Remember that your symbol table will need to be accessible in later compiler
    passes. I recommend making the symbol table a global variable (or a singleton,
    depending on your implementation language) so that it’s easy to access from anywhere
    in the compiler. In our type checking pseudocode, the symbol table is an explicit
    argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_*</samp>
    functions instead of a global variable, for the sake of clarity. But in a real
    implementation, I’ve found that using a global variable is less cumbersome.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，您的符号表需要在后续的编译器过程中可访问。我建议将符号表设置为全局变量（或者根据您使用的实现语言，可以使用单例模式），这样可以方便从编译器的任何位置访问它。在我们的类型检查伪代码中，符号表是作为一个显式参数传递给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_*</samp> 函数，而不是全局变量，以便更清晰地表达。但在实际实现中，我发现使用全局变量会更简单些。
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">TACKY 生成</samp>
- en: Now that we’re sure the input program is valid, let’s convert it to TACKY. We’ll
    need to make a few changes to the TACKY IR. First, we need a new TACKY instruction
    to represent function calls. Second, we need to include parameters in TACKY function
    definitions. Finally, we’ll define a whole TACKY program as a list of functions
    instead of a single function. [Listing 9-23](chapter9.xhtml#list9-23) shows the
    updated definition of the TACKY IR.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确认输入程序有效，让我们将其转换为TACKY。我们需要对TACKY IR进行一些修改。首先，我们需要一个新的TACKY指令来表示函数调用。其次，我们需要在TACKY函数定义中包含参数。最后，我们将整个TACKY程序定义为一个函数列表，而不是单个函数。[清单
    9-23](chapter9.xhtml#list9-23)展示了更新后的TACKY IR定义。
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-23: Adding function
    calls to TACKY</samp>'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 9-23：将函数调用添加到TACKY</samp>
- en: These changes correspond closely to the changes to the AST in [Listing 9-15](chapter9.xhtml#list9-15).
    The TACKY IR requires fewer changes than the AST, however, because we don’t represent
    function declarations in TACKY. Like variable declarations without initializers,
    function declarations without bodies are discarded during IR generation. Only
    function definitions are converted to TACKY.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改与 [清单 9-15](chapter9.xhtml#list9-15) 中AST的更改非常相似。然而，TACKY IR所需的更改比AST少，因为我们在TACKY中不表示函数声明。就像没有初始值的变量声明一样，TACKY
    IR生成时会丢弃没有函数体的声明。只有函数定义会被转换为TACKY。
- en: The new <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> instruction
    requires a function name, a list of arguments, and a destination for the return
    value. Just like the operands of other TACKY instructions, function arguments
    must be constants or variables, not expressions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> 指令需要一个函数名、一组参数列表和一个返回值的目标位置。与其他TACKY指令的操作数一样，函数参数必须是常量或变量，而不是表达式。
- en: To convert an entire program to TACKY, process the top-level function declarations
    one at a time, converting each function definition to a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp>
    and discarding any declaration without a body. To convert a function call to TACKY,
    generate the instructions to evaluate each argument and construct a list of the
    resulting TACKY values. The TACKY for the function call <samp class="SANS_TheSansMonoCd_W5Regular_11">fun(e1,
    e2, …)</samp> will look like [Listing 9-24](chapter9.xhtml#list9-24).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要将整个程序转换为TACKY，逐个处理顶层函数声明，将每个函数定义转换为TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp>
    并丢弃没有函数体的声明。要将函数调用转换为TACKY，生成指令以评估每个参数，并构建由这些TACKY值组成的列表。函数调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">fun(e1,
    e2, …)</samp> 对应的TACKY将如下所示 [清单 9-24](chapter9.xhtml#list9-24)。
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-24: Converting a
    function call to TACKY</samp>'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 9-24：将函数调用转换为TACKY</samp>
- en: This is the same approach we use to handle other expressions with nested subexpressions,
    like unary and binary operations. Now we’re just generalizing it to an arbitrary
    number of nested expressions, since a function can have an arbitrary number of
    arguments.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们处理其他包含嵌套子表达式的表达式的方法相同，比如一元和二元运算。现在我们只是将其推广到任意数量的嵌套表达式，因为一个函数可以有任意数量的参数。
- en: 'Remember to add a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(0)</samp>
    instruction to the end of every function body, to make sure it returns to the
    caller even if some execution paths are missing a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement. Next, we’ll tackle the trickiest part of this chapter: implementing
    function calls in assembly.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在每个函数体的末尾添加 <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(0)</samp>
    指令，以确保即使某些执行路径缺少 <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句，也能正确返回调用者。接下来，我们将处理本章中最棘手的部分：在汇编中实现函数调用。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">汇编生成</samp>
- en: 'We’re going to make two big changes to the TACKY-to-assembly conversion pass
    in this chapter: putting function parameters on the stack so they can be accessed
    in the function body and converting the new <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    instruction to assembly. We’ll also make a couple of smaller changes to the pseudoregister
    replacement and instruction fix-up passes. But before we make these changes, we
    need to understand the calling convention we’re going to use.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将对TACKY到汇编的转换过程做出两个重大修改：将函数参数放到栈上，以便它们可以在函数体内访问，以及将新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    指令转换为汇编代码。我们还将对伪寄存器替换和指令修正过程做一些小的修改。但在做这些修改之前，我们需要了解我们将使用的调用约定。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding
    Calling Conventions</samp>'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">理解调用约定</samp>'
- en: 'A *calling convention* is a contract between the caller and callee about how
    a function will be called. It answers questions like:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用约定*是调用者和被调用者之间关于如何调用函数的协议。它回答了诸如以下问题：'
- en: How are arguments passed to the callee? Are they passed in registers or on the
    stack?
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数是如何传递给被调用者的？它们是通过寄存器传递还是通过栈传递？
- en: How is a function’s return value passed back to the caller?
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的返回值是如何传回给调用者的？
- en: Is the callee or caller responsible for removing arguments from the stack at
    the end of a function?
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数结束时，是否由被调用者还是调用者负责从栈中移除参数？
- en: Which registers is the callee allowed to overwrite, and which does it need to
    preserve?
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被调用者允许覆盖哪些寄存器，哪些寄存器需要保留？
- en: A shared calling convention allows the caller and callee to work together. The
    caller knows where to put arguments, and the callee knows where to look for them.
    The callee knows where to store a return value, and the caller knows where to
    find it after the callee returns. The callee and caller both know which registers
    they need to save to ensure that the callee won’t clobber any values the caller
    will use after the function call. This ensures that both functions can access
    the information they need.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 共享调用约定允许调用者和被调用者协作。调用者知道将参数放在哪里，而被调用者知道从哪里查找它们。被调用者知道将返回值存储在哪里，调用者知道在被调用者返回后从哪里找到它。调用者和被调用者都知道需要保存哪些寄存器，以确保被调用者不会覆盖调用者在函数调用后将使用的任何值。这确保了两个函数可以访问它们所需的信息。
- en: A calling convention is part of a larger specification, called the *application
    binary interface (ABI)*, that makes it possible to link object files that were
    built by different compilers. As long as the object files all share the same ABI,
    they’ll be able to interoperate. In addition to calling conventions, the ABI specifies
    how different C types are represented in memory, which will be important in [Part
    II](part2.xhtml). Most of the other details that make up the ABI—like executable
    file formats—are handled by the assembler, linker, and operating system, so we
    don’t need to worry about them.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 调用约定是更大规范的一部分，称为*应用二进制接口（ABI）*，它使得由不同编译器构建的目标文件可以链接在一起。只要目标文件共享相同的ABI，它们就能互操作。除了调用约定，ABI还指定了不同C类型在内存中的表示方式，这在[第二部分](part2.xhtml)中非常重要。构成ABI的大多数其他细节——例如可执行文件格式——由汇编器、链接器和操作系统处理，因此我们不需要担心它们。
- en: If your compiler adheres to the calling conventions on your platform, you can
    compile programs that depend on the standard library and any other libraries you
    might want to use. You’ll be able to compile programs that make system calls and
    perform I/O operations. You still can’t compile the standard library itself—it
    relies on all sorts of language features that we haven’t implemented—but since
    it’s already compiled and lives on your system, you can link to it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的编译器遵循你平台上的调用约定，你就可以编译依赖于标准库以及你可能想要使用的任何其他库的程序。你将能够编译进行系统调用和执行I/O操作的程序。你仍然无法编译标准库本身——它依赖于我们尚未实现的各种语言特性——但由于它已经被编译并且存在于你的系统中，你可以链接到它。
- en: 'Every Unix-like system uses the standard calling convention defined in the
    *System V ABI*. (This ABI takes its name from Unix System V, an early commercial
    version of Unix.) Since we’re targeting macOS and Linux, we’ll use the System
    V calling convention. There are different versions of the System V ABI for different
    processor architectures; we’ll use the version for x64 processors. Windows has
    its own ABI, which we won’t worry about. If you’re doing this project on Windows
    Subsystem for Linux, you’ll still be able to use the System V calling convention.
    Next, we’ll look at how this calling convention works.  #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Calling
    Functions with the System V ABI</samp>'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '每个类 Unix 系统都使用 *System V ABI* 中定义的标准调用约定。（该 ABI 以 Unix System V 命名，这是 Unix
    的早期商业版本。）由于我们正在针对 macOS 和 Linux，因此我们将使用 System V 调用约定。System V ABI 对不同处理器架构有不同版本；我们将使用针对
    x64 处理器的版本。Windows 有其自己的 ABI，我们不需要担心。如果你在 Windows Subsystem for Linux 上进行这个项目，你仍然可以使用
    System V 调用约定。接下来，我们将了解这种调用约定是如何工作的。  #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用
    System V ABI 调用函数</samp>'
- en: 'In the previous section, I listed a few questions that a calling convention
    must answer. Let’s see how the System V calling convention answers these questions,
    and the other requirements it imposes:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我列出了一些调用约定必须回答的问题。让我们看看 System V 调用约定如何回答这些问题，以及它所施加的其他要求：
- en: '**Argument passing**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数传递**'
- en: 'The first six integer arguments to a function are passed in the EDI, ESI, EDX,
    ECX, R8D, and R9D registers, in that order (64-bit integers are passed using these
    registers’ 64-bit names instead: RDI, RSI, RDX, RCX, R8, and R9). Any remaining
    arguments are pushed onto the stack *in reverse order.* For example, to implement
    the function call <samp class="SANS_TheSansMonoCd_W5Regular_11">foo(a, b, c, d,
    e, f, g, h)</samp>, you first copy variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    into EDI, then copy <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> into
    ESI, and so on, up to <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>.
    Then, you push <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>, the last
    argument, onto the stack. Finally, you push <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>
    onto the stack.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的前六个整数参数按照顺序通过 EDI、ESI、EDX、ECX、R8D 和 R9D 寄存器传递（64 位整数使用这些寄存器的 64 位名称传递：RDI、RSI、RDX、RCX、R8
    和 R9）。其余的参数则以*相反顺序*推入栈中。例如，为了实现函数调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">foo(a,
    b, c, d, e, f, g, h)</samp>，首先将变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    复制到 EDI 中，然后将 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> 复制到 ESI 中，依此类推，直到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>。然后，将最后一个参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>
    推入栈中，最后将 <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> 推入栈中。
- en: '**Return values**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: As we know, a function’s return value is passed in EAX (or RAX if you’re returning
    a 64-bit integer). The return value must be in EAX when the <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    instruction is executed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，函数的返回值通过 EAX（或者如果是返回 64 位整数，则通过 RAX）传递。在执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    指令时，返回值必须位于 EAX 中。
- en: '**Argument cleanup**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数清理**'
- en: After the callee returns, the caller removes any arguments from the stack. The
    callee does not clean up arguments.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用者返回后，调用者会从栈中移除所有参数。被调用者不会清理参数。
- en: '**Caller-saved and callee-saved registers**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**调用者保存和被调用者保存的寄存器**'
- en: If a register is *caller-saved*, the callee is allowed to overwrite it. The
    caller must therefore save the register’s value to the stack before issuing the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction if it will
    need it later. It can then pop that value off the stack after the function returns.
    (If the value in a register won’t be used after the function call, the caller
    doesn’t need to save it.) If a register is *callee-saved*, it must have the same
    contents when a function returns as it did at the start of the function. If the
    callee needs to use the register, it typically pushes the register’s value onto
    the stack during the function prologue, then pops it back off the stack during
    the function epilogue. Registers RAX, R10, R11, and all the parameter passing
    registers are caller-saved; the remaining registers are callee-saved.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果寄存器是 *caller-saved*，被调用者可以覆盖它。因此，调用者在发出 <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    指令之前，必须将寄存器的值保存在栈中，以便稍后使用。然后，在函数返回后，调用者可以从栈中弹出该值。（如果寄存器中的值在函数调用后不再使用，调用者则无需保存它。）如果寄存器是
    *callee-saved*，那么它在函数返回时必须与函数开始时的内容相同。如果被调用者需要使用该寄存器，通常会在函数前言中将寄存器的值推入栈中，然后在函数尾部将其弹出。寄存器
    RAX、R10、R11 以及所有参数传递寄存器是 caller-saved；其余寄存器是 callee-saved。
- en: '**Stack alignment**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**栈对齐**'
- en: The System V ABI requires the stack to be 16-byte aligned. In other words, the
    address stored in RSP, the stack pointer, must be divisible by 16 when we issue
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction. The ABI
    imposes this requirement because some instructions require 16-byte-aligned operands.
    It’s easier to maintain the correct alignment of these operands if the stack is
    16-byte aligned to begin with.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: System V ABI 要求栈必须是 16 字节对齐的。换句话说，当我们发出 <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    指令时，存储在 RSP（栈指针）中的地址必须能够被 16 整除。ABI 强制要求这一点，因为某些指令需要 16 字节对齐的操作数。如果栈一开始就是 16 字节对齐的，那么更容易保持这些操作数的正确对齐。
- en: You can find the full System V x64 ABI at *[https://<wbr>gitlab<wbr>.com<wbr>/x86<wbr>-psABIs<wbr>/x86<wbr>-64<wbr>-ABI](https://gitlab.com/x86-psABIs/x86-64-ABI)*.
    However, looking at an example might be more useful than reading the spec. Consider
    [Listing 9-25](chapter9.xhtml#list9-25).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *[https://<wbr>gitlab<wbr>.com<wbr>/x86<wbr>-psABIs<wbr>/x86<wbr>-64<wbr>-ABI](https://gitlab.com/x86-psABIs/x86-64-ABI)*
    上找到完整的 System V x64 ABI。然而，查看一个示例可能比阅读规范更有帮助。请参考 [列表 9-25](chapter9.xhtml#list9-25)。
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-25: A C program that
    includes a function call</samp>'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 9-25：一个包含函数调用的 C 程序</samp>
- en: '[Listing 9-26](chapter9.xhtml#list9-26) gives the assembly code for <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>.
    It’s more optimized than what your compiler will produce, in order to illustrate
    the System V calling convention more clearly.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-26](chapter9.xhtml#list9-26) 给出了 <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>
    的汇编代码。它比编译器生成的代码更为优化，以便更清楚地说明 System V 调用约定。'
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-26: The assembly
    code for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">fun</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">in [Listing 9-25](chapter9.xhtml#list9-25)</samp>'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 9-26：用于</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">fun</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">的汇编代码，见 [列表 9-25](chapter9.xhtml#list9-25)</samp>
- en: '[Listing 9-27](chapter9.xhtml#list9-27) gives the assembly code to call <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11">caller</samp>.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-27](chapter9.xhtml#list9-27) 给出了从 <samp class="SANS_TheSansMonoCd_W5Regular_11">caller</samp>
    调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> 的汇编代码。'
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-27: The assembly
    code to call</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">fun</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">in [Listing 9-25](chapter9.xhtml#list9-25)</samp>'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 9-27：调用</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">fun</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">的汇编代码，见 [列表 9-25](chapter9.xhtml#list9-25)</samp>
- en: Let’s walk through this function call and see how the program state changes
    at each step. In the following diagrams, the left column shows the contents of
    the stack and general-purpose registers, and the right column shows the contents
    of RIP, which always holds the address of the next instruction to execute. (Note
    that the instruction addresses in these diagrams aren’t realistic. These addresses
    suggest that every instruction is 1 byte long, but instruction length varies,
    and it’s usually more than a single byte!)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步地跟踪这个函数调用，看看程序状态如何在每一步发生变化。在接下来的图示中，左侧列显示了堆栈和通用寄存器的内容，右侧列显示了 RIP 的内容，RIP
    始终保存着下一条要执行的指令的地址。（请注意，这些图中的指令地址并不真实。这些地址表明每条指令只有 1 字节长，但指令长度是变化的，通常超过一个字节！）
- en: '[Figure 9-1](#fig9-1) shows the initial state of the program before the call
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-1](#fig9-1) 显示了在调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>
    之前程序的初始状态。'
- en: '![](../images/fig9-1.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig9-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: The initial state
    of the program in [Listing 9-25](chapter9.xhtml#list9-25) [Description](description-18.xhtml)</samp>'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-1: [Listing 9-25](chapter9.xhtml#list9-25)
    中程序的初始状态 [描述](description-18.xhtml)</samp>'
- en: In [Figure 9-1](#fig9-1), RSP and RBP point to the same address. There are no
    local variables in <samp class="SANS_TheSansMonoCd_W5Regular_11">caller</samp>,
    so we don’t need to allocate any stack space. The registers in this diagram all
    hold 64-bit values, but we’ll usually use 32-bit register names, like EDI, ESI,
    and EDX, because all our function arguments and return values are 32-bit integers.
    However, we’ll use 64-bit register names when saving to and restoring from the
    stack, because <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> require 64-bit operands.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 9-1](#fig9-1) 中，RSP 和 RBP 指向相同的地址。<samp class="SANS_TheSansMonoCd_W5Regular_11">caller</samp>
    中没有局部变量，因此我们不需要分配任何堆栈空间。图中的寄存器都保存着 64 位的值，但我们通常会使用 32 位寄存器名称，如 EDI、ESI 和 EDX，因为我们所有的函数参数和返回值都是
    32 位整数。然而，在保存到堆栈和从堆栈恢复时，我们将使用 64 位寄存器名称，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> 需要 64 位操作数。
- en: 'The one argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">caller</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>, is passed in RDI. Let’s
    say the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">15</samp>. To call <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>,
    we need to pass all eight arguments according to the System V calling convention.
    The first six arguments will be passed in registers, and the last two will be
    passed on the stack. But copying the first argument into RDI will clobber <samp
    class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>, which we’ll need again after
    the function call. So, the very first step, before passing any arguments, is to
    save <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> onto the stack:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">caller</samp> 的唯一参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>
    是通过 RDI 传递的。假设 <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> 的值是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">15</samp>。为了调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>，我们需要根据
    System V 调用约定传递所有八个参数。前六个参数将通过寄存器传递，最后两个参数将通过堆栈传递。但是，将第一个参数复制到 RDI 会覆盖掉 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>，而我们在函数调用后还需要它。因此，第一步，在传递任何参数之前，就是将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> 保存到堆栈中：
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Next, we adjust RSP so it will be 16-byte aligned when we issue the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instruction. We need to work backward from the number of arguments and saved registers
    we put on the stack. Before the start of the function call, we can assume that
    the stack pointer is a multiple of 16\. (To guarantee this, we’ll allocate stack
    space in multiples of 16 bytes in the function prologue.) We’ll then push some
    registers and function arguments onto the stack; each of these will be 8 bytes.
    If the total number of registers and arguments pushed onto the stack is even,
    the stack will be 16-byte aligned after we’ve added all of them. If the number
    of registers and arguments on the stack is odd, we need to subtract 8 bytes from
    the stack pointer to get the right alignment.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调整RSP，使其在执行<samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>指令时保持16字节对齐。我们需要从栈上放置的参数和保存的寄存器的数量开始倒推。在函数调用开始之前，我们可以假设栈指针是16的倍数。（为了保证这一点，我们将在函数前言中分配16字节的栈空间。）然后，我们将把一些寄存器和函数参数压入栈中；每个将占用8字节。如果压入栈的寄存器和参数总数是偶数，那么在添加所有这些内容后栈将保持16字节对齐。如果栈上的寄存器和参数数目是奇数，我们需要从栈指针中减去8字节，以获得正确的对齐方式。
- en: 'In this example, we push one register, RDI. We’ll also need to push two arguments
    onto the stack, <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">h</samp>. In total, we’ll push three values,
    totaling 24 bytes, onto the stack before issuing the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instruction. Therefore, we need to adjust the stack by another 8 bytes after saving
    RDI:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将一个寄存器RDI压入栈中。我们还需要将两个参数压入栈中，分别是<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">h</samp>。在执行<samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>指令之前，我们总共会将三个值压入栈中，总计24字节。因此，在保存RDI后，我们需要再调整栈8字节：
- en: '[PRE46]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now we’re ready to set up the arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>.
    We start with the first six arguments, which will be passed in registers. Because
    the arguments are all 32-bit integers, we’ll use 32-bit register names here:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好设置<samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>的参数了。我们从前六个参数开始，它们将通过寄存器传递。因为这些参数都是32位整数，所以我们将在这里使用32位寄存器名称：
- en: '[PRE47]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, we push the remaining two arguments onto the stack, in reverse order:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将剩余的两个参数按逆序压入栈中：
- en: '[PRE48]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Each of these instructions will push a 64-bit constant onto the stack, because
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instruction can
    push only 64-bit values. [Figure 9-2](#fig9-2) shows the state of the program
    after we save RDI, adjust the stack, and set up the function arguments.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 每条指令都会将一个64位常量压入栈中，因为<samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>指令只能压入64位值。[图9-2](#fig9-2)显示了在我们保存RDI、调整栈并设置函数参数后程序的状态。
- en: '![](../images/fig9-2.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig9-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-2: The state of the
    program just before the call instruction [Description](description-19.xhtml)</samp>'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图9-2：调用指令之前程序的状态 [描述](description-19.xhtml)</samp>
- en: 'You can tell that the stack is indeed 16-byte aligned because the stack pointer
    is divisible by 16 (or <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>
    in hexadecimal). Once our arguments are set up, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> assembly instruction:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看出，栈确实是16字节对齐的，因为栈指针可以被16整除（或者是16进制的<samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp>）。一旦我们的参数设置好，我们就可以通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">call</samp>汇编指令调用<sup class="SANS_TheSansMonoCd_W5Regular_11">fun</sup>：
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction does
    two things. First, it pushes the address of the instruction that immediately follows
    it, the return address, onto the stack. Then, it transfers control to the instruction
    labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> by copying that
    instruction’s address into RIP. [Figure 9-3](#fig9-3) shows the state of the program
    just after the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>指令做了两件事。首先，它将紧随其后的指令地址，即返回地址，压入栈中。然后，它通过将该指令的地址复制到RIP中，将控制权转移到标记为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>的指令。[图9-3](#fig9-3)显示了在执行<sup
    class="SANS_TheSansMonoCd_W5Regular_11">call</sup>指令后，程序的状态。
- en: '![](../images/fig9-3.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig9-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-3: The state of the
    program just after the call</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">instruction
    [Description](description-20.xhtml)</samp>'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-3：调用指令执行后的程序状态</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-20.xhtml)</samp>
- en: The function prologue, which we’re already familiar with, sets up the stack
    frame for <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>, which puts
    the program in the state shown in [Figure 9-4](#fig9-4).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉的函数序言为 <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> 设置了栈帧，这使得程序进入了
    [图 9-4](#fig9-4) 所示的状态。
- en: '![](../images/fig9-4.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig9-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-4: The state of the
    program after the function prologue for fun [Description](description-21.xhtml)</samp>'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-4：函数序言执行后 fun 的程序状态</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-21.xhtml)</samp>
- en: 'In this diagram, the portion of the stack with a white background is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>’s stack frame. The portion
    with a light gray background is <samp class="SANS_TheSansMonoCd_W5Regular_11">caller</samp>’s
    stack frame. In <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>, we need
    to calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>. This requires us to access
    one parameter that was passed in a register (<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>)
    and one that was passed on the stack (<samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>).
    The next instruction in <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>
    copies the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> into
    EAX:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，带有白色背景的部分是 <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> 的栈帧。带有浅灰色背景的部分是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">caller</samp> 的栈帧。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>
    中，我们需要计算 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>。这要求我们访问通过寄存器传入的一个参数（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>）和通过栈传入的另一个参数（<samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>）。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> 中的下一条指令将 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    的值复制到 EAX 寄存器：
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, we want to add <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>,
    which was passed on the stack, to the value in EAX. Stack arguments, just like
    local variables, can be addressed relative to RBP. We know that RBP points to
    the stack slot that contains the base address of the caller’s stack frame. The
    stack slot just below that, at <samp class="SANS_TheSansMonoCd_W5Regular_11">8(%rbp)</samp>,
    contains the return address in the caller. The value below that, at <samp class="SANS_TheSansMonoCd_W5Regular_11">16(%rbp)</samp>,
    will be the first stack argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>.
    (Remember that we pushed stack arguments in reverse order. That means <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>,
    the first stack argument, was pushed onto the stack last and is now closest to
    the current stack frame.) The next argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>,
    will be 8 bytes below that, at <samp class="SANS_TheSansMonoCd_W5Regular_11">24(%rbp)</samp>,
    and we can access it accordingly:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望将通过栈传入的 <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp> 加到 EAX
    寄存器中的值上。栈参数，就像局部变量一样，可以相对于 RBP 来访问。我们知道 RBP 指向包含调用者栈帧基地址的栈槽。就在它下面的栈槽，即 <samp class="SANS_TheSansMonoCd_W5Regular_11">8(%rbp)</samp>，包含了调用者的返回地址。紧接着下面的值，即
    <samp class="SANS_TheSansMonoCd_W5Regular_11">16(%rbp)</samp>，将是第一个栈参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>。（记住，我们是按逆序推入栈的。这意味着第一个栈参数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> 最后推入栈，因此它现在离当前栈帧最近。）下一个参数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp> 将位于它下面 8 字节的位置，即 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">24(%rbp)</samp>，我们可以相应地访问它：
- en: '[PRE51]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We pushed a 64-bit constant, <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>,
    onto the stack, but <samp class="SANS_TheSansMonoCd_W5Regular_11">addl</samp>
    needs a 32-bit operand. It will therefore interpret the 4 bytes starting at <samp
    class="SANS_TheSansMonoCd_W5Regular_11">24(%rbp)</samp> as a 32-bit integer, effectively
    dropping the upper 32 bits. Since those bits are just leading zeros, the resulting
    value will still be <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>. That
    is, even though each argument pushed onto the stack must be 64 bits, we can still
    interpret them as 32-bit integers in the callee.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个64位常量`<samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>`压入栈中，但`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">addl</samp>`需要一个32位操作数。因此，它将从`<samp class="SANS_TheSansMonoCd_W5Regular_11">24(%rbp)</samp>`开始的4个字节解释为一个32位整数，从而有效地丢弃了高32位。由于这些高32位只是前导零，结果值仍然是`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">8</samp>`。也就是说，尽管每个压入栈的参数必须是64位，但我们仍然可以在被调用者中将它们解释为32位整数。
- en: 'At this point, we have the correct return value in EAX. We’re ready for the
    function epilogue:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，EAX中存储着正确的返回值。我们已经准备好进行函数尾处理：
- en: '[PRE52]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">movq</samp> instruction
    is unnecessary in this particular program. Usually, this instruction deallocates
    the current stack frame, putting the old value of RBP back at the top of the stack.
    But we didn’t allocate any stack space for <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>,
    so RSP and RBP already have the same value.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`<samp class="SANS_TheSansMonoCd_W5Regular_11">movq</samp>`指令在这个特定的程序中并不必要。通常，这条指令会释放当前的栈帧，将RBP的旧值放回栈顶。但我们没有为`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>`分配任何栈空间，因此RSP和RBP已经有相同的值。
- en: The epilogue puts the stack back the way it was before the prologue. [Figure
    9-5](#fig9-5) shows how things will look at this point.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 函数尾处理将栈恢复到与函数开始之前相同的状态。[图 9-5](#fig9-5)显示了此时的程序状态。
- en: '![](../images/fig9-5.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig9-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-5: The state of the
    program just before returning to the caller [Description](description-22.xhtml)</samp>'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-5：返回给调用者之前的程序状态 [描述](description-22.xhtml)</samp>
- en: We return to the caller with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    instruction, which pops the return address off the stack and transfers control
    to that address. [Figure 9-6](#fig9-6) shows the state of the program after we
    return to the caller.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`<samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>`指令返回给调用者，该指令从栈中弹出返回地址，并将控制权转移到该地址。[图
    9-6](#fig9-6)显示了我们返回给调用者后程序的状态。
- en: '![](../images/fig9-6.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig9-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-6: The state of the
    program just after returning to the caller [Description](description-23.xhtml)</samp>'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-6：返回给调用者之后的程序状态 [描述](description-23.xhtml)</samp>
- en: 'At this point, the stack is in exactly the same state as it was just before
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction. The
    last step is to clean up the padding and stack arguments and restore <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>
    to RDI:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，栈的状态与`<samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>`指令之前完全相同。最后一步是清理填充和栈参数，并将`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>`恢复到RDI：
- en: '[PRE53]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now the stack is back the way it was before the function call, and RDI has been
    restored to its original state. The RAX register contains the return value, which
    we can use later in the function body. Because the other registers were uninitialized
    before the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>, we
    don’t need to clean them up now. [Figure 9-7](#fig9-7) shows the state of the
    program once we’ve finished cleaning up after the function call.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，栈恢复到函数调用之前的状态，RDI也已恢复到原始状态。RAX寄存器包含返回值，我们可以在函数体中稍后使用。由于其他寄存器在调用`<samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>`之前没有被初始化，因此我们现在不需要清理它们。[图
    9-7](#fig9-7)显示了我们在清理完函数调用后程序的状态。
- en: '![](../images/fig9-7.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig9-7.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-7: The state of the
    program after the function call has been completed [Description](description-24.xhtml)</samp>'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 9-7：函数调用完成后的程序状态 [描述](description-24.xhtml)</samp>
- en: At this point, you should have a clear understanding of how to call functions
    and access function parameters in assembly. We’re ready to update the assembly
    generation stage.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你应该清楚地理解了如何在汇编中调用函数并访问函数参数。现在我们准备更新汇编生成阶段。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Function
    Calls and Definitions to Assembly</samp>
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将函数调用和定义转换为汇编</samp>
- en: We’re going to extend our assembly AST now, for the first time since [Chapter
    4](chapter4.xhtml). [Listing 9-28](chapter9.xhtml#list9-28) defines the new AST,
    with changes bolded.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将第一次扩展我们的汇编 AST，距离[第4章](chapter4.xhtml)已经有一段时间了。[清单 9-28](chapter9.xhtml#list9-28)定义了新的
    AST，并且有变化的部分已加粗。
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-28: The assembly
    AST with support for function calls</samp>'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 9-28：支持函数调用的汇编 AST</samp>
- en: 'First, we change the top-level definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">Program</samp>
    to support multiple function definitions. We also introduce three new instructions.
    To adjust the stack alignment before a function call, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp>
    instruction we already have, which will eventually be emitted as a <samp class="SANS_TheSansMonoCd_W5Regular_11">subq</samp>
    instruction. To remove arguments and padding after a function call, we add a corresponding
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DeallocateStack</samp> instruction,
    which will be emitted as <samp class="SANS_TheSansMonoCd_W5Regular_11">addq</samp>.
    We also need the <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp> instruction
    to push arguments onto the stack. We’ve already used <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    in the function prologue, but in such a limited way that we could add it mechanically
    during code emission. Now that we’re going to be using it more extensively, we
    need to add it to the assembly AST. And, of course, we need the <samp class="SANS_TheSansMonoCd_W5Regular_11">Call</samp>
    instruction to actually call functions. Lastly, we need a few new registers for
    argument passing: <samp class="SANS_TheSansMonoCd_W5Regular_11">CX</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DI</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">SI</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">R8</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">R9</samp>.
    Arguments are also passed in the <samp class="SANS_TheSansMonoCd_W5Regular_11">DX</samp>
    register, which is already in our AST. Like in previous chapters, the AST doesn’t
    distinguish between the different aliases for each register: <samp class="SANS_TheSansMonoCd_W5Regular_11">DI</samp>,
    for example, will be emitted as <samp class="SANS_TheSansMonoCd_W5Regular_11">%rdi</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">%edi</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">%dil</samp>,
    depending on whether we want to use the whole register, its lower 4 bytes, or
    its lowest byte.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将顶层定义的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Program</samp> 修改为支持多个函数定义。我们还引入了三条新指令。为了在函数调用之前调整栈对齐，我们可以使用已经存在的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> 指令，它最终会转换为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">subq</samp> 指令。为了在函数调用后移除参数和填充内容，我们添加了一个相应的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DeallocateStack</samp> 指令，它会被转换为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">addq</samp>。我们还需要 <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp>
    指令来将参数压入栈中。我们已经在函数序言中使用过 <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>，但那时它的使用非常有限，可以在代码生成时机械地添加它。现在我们将更加广泛地使用它，因此需要将其添加到汇编
    AST 中。当然，我们还需要 <samp class="SANS_TheSansMonoCd_W5Regular_11">Call</samp> 指令来实际调用函数。最后，我们需要一些新的寄存器来传递参数：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CX</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">DI</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SI</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">R8</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">R9</samp>。参数还可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">DX</samp>
    寄存器传递，这在我们的 AST 中已经存在。像前几章一样，AST 不区分每个寄存器的不同别名：例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">DI</samp>
    会被转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">%rdi</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">%edi</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">%dil</samp>，具体取决于我们是想使用整个寄存器、其低
    4 个字节，还是最低的一个字节。
- en: 'With these additions to the assembly AST in place, we can update the TACKY-to-assembly
    conversion. Remember that we made three changes to the TACKY IR: we defined a
    program as a list of functions instead of a single function, added parameters
    to each function definition, and added a <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    instruction. Accounting for the first change is straightforward: we convert a
    list of functions in TACKY to a list of functions in assembly. Next, we’ll make
    function parameters accessible in assembly. Then, we’ll see how to convert the
    new <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> instruction to
    assembly.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些对汇编抽象语法树（AST）的修改完成后，我们可以更新 TACKY 到汇编的转换。记住，我们对 TACKY IR 做了三处更改：我们将程序定义为一个函数列表，而不是一个单一的函数，向每个函数定义中添加了参数，并且添加了一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> 指令。处理第一个更改是直接的：我们将
    TACKY 中的函数列表转换为汇编中的函数列表。接下来，我们将使函数参数在汇编中可访问。然后，我们将看到如何将新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    指令转换为汇编代码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Accessing Function Parameters
    in Assembly</samp>
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">汇编中访问函数参数</samp>
- en: At the start of a function, each parameter is stored in the register or stack
    location dictated by our calling convention. We could access function parameters
    in assembly code by referring directly to those locations. The assembly code for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> in [Listing 9-26](chapter9.xhtml#list9-26)
    took this approach; when we needed to add parameters <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>, we referred to their
    calling convention–defined locations, <samp class="SANS_TheSansMonoCd_W5Regular_11">%edi</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">24(%rbp)</samp>. This works,
    but it has a few disadvantages. It requires us to push parameter passing registers
    onto the stack just before function calls and pop them off again afterward, like
    we had to push and pop RDI before and after the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>
    in [Listing 9-27](chapter9.xhtml#list9-27). It also leads to conflicts with other
    instructions that use parameter passing registers. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    writes to the EDX register, potentially clobbering the function parameter stored
    there. Finally, it makes the pseudoregister allocation phase more complex, because
    parameters must be handled differently from local variables.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数开始时，每个参数都会存储在由我们的调用约定所指定的寄存器或栈位置中。我们可以通过直接引用这些位置来在汇编代码中访问函数参数。[列表 9-26](chapter9.xhtml#list9-26)
    中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> 的汇编代码采取了这种方法；当我们需要添加参数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>
    时，我们直接引用它们的调用约定所定义的位置，<samp class="SANS_TheSansMonoCd_W5Regular_11">%edi</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">24(%rbp)</samp>。这种方式有效，但有一些缺点。它要求我们在函数调用之前将参数传递寄存器压入栈中，之后再将其弹出，就像我们在
    [列表 9-27](chapter9.xhtml#list9-27) 中对 <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>
    调用前后必须压入和弹出 RDI 一样。它还可能导致与使用参数传递寄存器的其他指令发生冲突。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    指令会写入 EDX 寄存器，可能会破坏存储在该寄存器中的函数参数。最后，它使得伪寄存器分配阶段变得更加复杂，因为参数必须与局部变量区别开来处理。
- en: 'We’ll take a different approach that bypasses these problems: at the start
    of each function body, we’ll copy each parameter from its calling convention–defined
    register or memory address into a slot in the current function’s stack frame.
    Let’s look at a simple example. [Listing 9-29](chapter9.xhtml#list9-29) defines
    a function with one parameter.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用一种不同的方法，绕过这些问题：在每个函数体的开始，我们会将每个参数从调用约定所定义的寄存器或内存地址复制到当前函数栈帧中的一个位置。我们来看一个简单的例子。[列表
    9-29](chapter9.xhtml#list9-29) 定义了一个有一个参数的函数。
- en: '[PRE55]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-29: A function with
    a single parameter</samp>'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 9-29：一个带有单一参数的函数</samp>
- en: 'When we generate the assembly for this function, we’ll include an extra <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction at the start of
    the function body:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为这个函数生成汇编代码时，我们将在函数体的开始包含一个额外的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    指令：
- en: '[PRE56]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This instruction copies the function’s first parameter into the <samp class="SANS_TheSansMonoCd_W5Regular_11">param</samp>
    pseudoregister. Keep in mind that any uses of <samp class="SANS_TheSansMonoCd_W5Regular_11">Var("param")</samp>
    in TACKY will be translated to uses of <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo("param")</samp>
    in assembly.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令将函数的第一个参数复制到<samp class="SANS_TheSansMonoCd_W5Regular_11">param</samp>伪寄存器中。请记住，在TACKY中，任何对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Var("param")</samp>的使用都会被转换为对汇编中<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Pseudo("param")</samp>的使用。
- en: 'The generated assembly for the whole function will look like this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 整个函数生成的汇编代码看起来像这样：
- en: '[PRE57]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: (Really, <samp class="SANS_TheSansMonoCd_W5Regular_11">param</samp> would be
    renamed during identifier resolution, and we would emit an extra <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(0)</samp>
    instruction during TACKY generation, but neither of these details matter for this
    example.)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: （事实上，<samp class="SANS_TheSansMonoCd_W5Regular_11">param</samp>会在标识符解析期间被重命名，而且在TACKY生成过程中我们会发出额外的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return(0)</samp>指令，但这两个细节对于本示例来说并不重要。）
- en: We’ll replace pseudoregisters with stack locations in the usual fashion. Since
    <samp class="SANS_TheSansMonoCd_W5Regular_11">param</samp> is our only pseudoregister,
    we’ll assign it to <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(-4)</samp>.
    We’ll ultimately emit the assembly program shown in [Listing 9-30](chapter9.xhtml#list9-30).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照通常的方式将伪寄存器替换为栈位置。由于<samp class="SANS_TheSansMonoCd_W5Regular_11">param</samp>是我们唯一的伪寄存器，我们将其分配给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Stack(-4)</samp>。最终我们将发出在[Listing 9-30](chapter9.xhtml#list9-30)中显示的汇编程序。
- en: '[PRE58]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-30: The assembly
    program for [Listing 9-29](chapter9.xhtml#list9-29)</samp>'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-30: [Listing 9-29](chapter9.xhtml#list9-29)的汇编程序</samp>'
- en: Copying parameters onto the stack keeps code generation simple. We won’t need
    to save caller-saved registers before function calls or restore them afterward,
    because we use these registers only in very transient ways. When we pass function
    parameters in registers, we save them to the stack immediately, instead of leaving
    them in those registers long term. Aside from function parameters, the only values
    we store in caller-saved registers are return values, the results of <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    instructions, and values that are temporarily copied into R10D or R11D during
    the instruction rewriting stage. Just like parameters, these values are either
    used or copied to the stack right away. The upshot is that the values in caller-saved
    registers will never need to persist across function calls; that’s why we don’t
    need to save or restore them. (Meanwhile, the callee doesn’t need to save or restore
    most callee-saved registers because we don’t use them at all. The sole exceptions
    are the RBP and RSP registers, which we save and restore in the function prologue
    and epilogue.)
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数复制到栈上使得代码生成保持简单。我们不需要在函数调用之前保存调用者保存的寄存器，或者在调用后恢复它们，因为我们只在非常短暂的时间内使用这些寄存器。当我们通过寄存器传递函数参数时，我们会立即将它们保存到栈上，而不是长时间将它们保存在寄存器中。除了函数参数外，我们仅在调用者保存的寄存器中存储返回值、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>指令的结果以及在指令重写阶段临时复制到R10D或R11D中的值。就像参数一样，这些值要么会立即使用，要么会复制到栈中。结果是，调用者保存的寄存器中的值不需要在函数调用之间保持持久化；这就是为什么我们不需要保存或恢复它们的原因。（同时，callee不需要保存或恢复大多数callee保存的寄存器，因为我们根本不使用它们。唯一的例外是RBP和RSP寄存器，我们会在函数前言和尾声中保存和恢复它们。）
- en: 'Along the same lines, we don’t have to worry about the <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    instruction clobbering the parameter in EDX. We don’t need any extra logic to
    handle function parameters during pseudoregister allocation, either: we can assign
    them to stack locations just like local variables.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们不需要担心<code class="SANS_TheSansMonoCd_W5Regular_11">idiv</code>指令会破坏EDX中的参数。我们也不需要任何额外的逻辑来处理伪寄存器分配过程中的函数参数：我们可以像处理局部变量一样将它们分配到栈位置。
- en: On the other hand, copying parameters to the stack is inefficient. First of
    all, we’re generating extra <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instructions. Second, we’re forcing the program to access memory, which is usually
    slower than registers, every time it reads or writes a parameter. Luckily, we’ll
    be able to get rid of most of these extra instructions and memory accesses when
    we implement register allocation in [Part III](part3.xhtml).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，将参数复制到堆栈上效率低下。首先，我们生成了额外的<samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>指令。其次，我们强迫程序每次读写参数时访问内存，而访问内存通常比寄存器要慢。幸运的是，当我们在[第三部分](part3.xhtml)实现寄存器分配时，能够消除大部分这些额外的指令和内存访问。
- en: When you generate these parameter-copying instructions, start by moving the
    first parameter from <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(DI)</samp>
    into a pseudoregister, the second from <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(SI)</samp>,
    and so on, up to the sixth parameter (or until you run out of parameters, if the
    function has fewer than six). Then, copy the seventh parameter from <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(16)</samp>,
    the eighth from <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(24)</samp>,
    and so on until you’ve handled every parameter. As we saw earlier, the top of
    the caller’s stack frame, <samp class="SANS_TheSansMonoCd_W5Regular_11">8(%rbp)</samp>,
    is the return address, and the seventh parameter—the first parameter passed on
    the stack—is always just below it, at <samp class="SANS_TheSansMonoCd_W5Regular_11">16(%rbp)</samp>.
    From there, the offset increases by 8 bytes for each additional parameter, because
    the caller pushes them onto the stack as 8-byte values (even though the callee
    interprets them as 4-byte values).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当你生成这些参数复制指令时，从将第一个参数从<samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(DI)</samp>移到伪寄存器开始，第二个参数从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Reg(SI)</samp>移到伪寄存器，以此类推，直到第六个参数（或者如果函数参数少于六个，则按实际参数个数）。然后，从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Stack(16)</samp>复制第七个参数，从<samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(24)</samp>复制第八个参数，以此类推，直到处理完所有参数。正如我们之前看到的，调用者堆栈框架的顶部<samp
    class="SANS_TheSansMonoCd_W5Regular_11">8(%rbp)</samp>是返回地址，第七个参数——第一个通过堆栈传递的参数——总是在其下方，位于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">16(%rbp)</samp>。从那里开始，每个额外参数的偏移量增加 8 字节，因为调用者将它们作为
    8 字节的值推送到堆栈上（尽管被调用者将它们解释为 4 字节的值）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing FunCall</samp>
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">实现 FunCall</samp>
- en: Earlier, we stepped through the assembly code for a function call. Now let’s
    look at how to generate this assembly code. [Listing 9-31](chapter9.xhtml#list9-31)
    gives the pseudocode to convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    TACKY instruction to assembly.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们走过了函数调用的汇编代码。现在让我们看看如何生成这些汇编代码。[列表 9-31](chapter9.xhtml#list9-31)给出了将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> TACKY 指令转换为汇编的伪代码。
- en: '[PRE59]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-31: Emitting assembly
    for a function call</samp>'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 9-31：为函数调用生成汇编代码</samp>
- en: The first step is to make sure the stack is properly aligned. We must do this
    before passing arguments on the stack; if we add extra padding between the arguments
    and the callee’s stack frame, the callee won’t be able to find them. When we walked
    through the function call in [Listing 9-27](chapter9.xhtml#list9-27), we saw that
    if we pushed an even number of arguments and caller-saved registers to the stack,
    it would still be 16-byte aligned afterward—no padding required. If we pushed
    an odd number, we’d need to subtract another 8 bytes from the stack pointer to
    maintain the correct alignment. Now, thanks to the parameter-copying trick from
    the previous section, we need to consider only arguments that are pushed onto
    the stack, not caller-saved registers. So, we just check how many arguments we’ll
    push onto the stack, then emit an <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp>
    instruction if that number is odd.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是确保堆栈正确对齐。我们必须在将参数传递到堆栈之前做这件事；如果在参数和被调用者的堆栈框架之间添加额外的填充，调用者将无法找到它们。当我们在[列表
    9-27](chapter9.xhtml#list9-27)中走过函数调用时，我们看到如果将偶数个参数和调用者保存的寄存器推送到堆栈，之后堆栈仍然是 16
    字节对齐的——不需要填充。如果推送的是奇数个，我们需要从堆栈指针中减去额外的 8 字节以保持正确的对齐。现在，感谢上一节中的参数复制技巧，我们只需考虑推送到堆栈上的参数，而不需要考虑调用者保存的寄存器。因此，我们只需检查将要推送到堆栈上的参数数量，如果是奇数，则生成一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp>指令。
- en: Next, we pass the function arguments. As we process each argument, we convert
    it from a TACKY value to an assembly operand with the <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_val</samp>
    helper function. (I’ve omitted the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_val</samp>,
    since you already know how to perform this conversion.) The first six arguments
    are copied into the appropriate registers. A function may, of course, have fewer
    than six arguments; in that case, we copy every argument into a register.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们传递函数参数。在处理每个参数时，我们通过 `<samp class="SANS_TheSansMonoCd_W5Regular_11">convert_val</samp>`
    辅助函数将其从 TACKY 值转换为汇编操作数。（我省略了 `<samp class="SANS_TheSansMonoCd_W5Regular_11">convert_val</samp>`
    的伪代码，因为你已经知道如何执行此转换。）前六个参数被复制到适当的寄存器中。当然，一个函数可能有少于六个参数；在这种情况下，我们将每个参数复制到一个寄存器中。
- en: If the function has more than six arguments, the remainder must be passed on
    the stack. We push the last argument, then the second-to-last, and so on, up through
    the seventh argument. Keep in mind that our arguments are 4-byte integers, but
    we need to push 8 bytes onto the stack for each of them (because the ABI requires
    it, and because <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp> takes
    only 8-byte operands). However, the callee will use only the lower 4 bytes of
    each argument. If an argument is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm</samp> operand, we pass it
    with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp> instruction
    ❶. If it’s in memory, we first copy the argument into <samp class="SANS_TheSansMonoCd_W5Regular_11">AX</samp>,
    then push that ❷. Using an immediate value in an instruction like <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq
    $7</samp> pushes the 8-byte representation of that value. Pushing a <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg</samp>
    operand pushes the entire 8-byte register, whose lower 4 bytes we can access with
    the corresponding 4-byte alias. (The code emission pass will use 4-byte register
    aliases like <samp class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp> in most
    instructions, including <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>,
    and 8-byte aliases like <samp class="SANS_TheSansMonoCd_W5Regular_11">%rax</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp> instructions.)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数有超过六个参数，剩余的参数必须通过栈传递。我们先推送最后一个参数，再推送倒数第二个，依此类推，直到第七个参数。请记住，我们的参数是 4 字节整数，但我们需要为每个参数推送
    8 字节到栈上（因为 ABI 要求这样做，而且因为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp>`
    只接受 8 字节操作数）。然而，被调用函数只会使用每个参数的低 4 字节。如果某个参数是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm</samp> 操作数，我们通过单条 <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp>
    指令传递它❶。如果它在内存中，我们先将参数复制到 <samp class="SANS_TheSansMonoCd_W5Regular_11">AX</samp>
    寄存器中，然后再将其推送❷。使用像 `<samp class="SANS_TheSansMonoCd_W5Regular_11">pushq $7</samp>`
    这样的立即数指令会将该值的 8 字节表示推送到栈中。推送一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg</samp>
    操作数会推送整个 8 字节寄存器，我们可以使用相应的 4 字节别名来访问其低 4 字节。（代码生成阶段将使用像 <samp class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp>
    这样的 4 字节寄存器别名在大多数指令中，包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>，以及像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">%rax</samp> 这样的 8 字节别名在 <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp>
    指令中。)
- en: If we used a 4-byte memory operand directly in an instruction like <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq
    -4(%rbp)</samp>, we’d push the 4 bytes of our operand followed by 4 bytes of whatever
    happened to follow it in memory. This would usually be fine, if a bit kludgy.
    But if the 4 bytes that followed our operand weren’t readable memory, trying to
    access those bytes would trigger a segmentation fault and crash the program. This
    issue won’t come up when we push an operand from the stack; the bytes right after
    it will hold either some other temporary value from the current function or the
    saved base address of the caller’s stack frame. But it could come up when we push
    static variables, which we’ll implement in [Chapter 10](chapter10.xhtml). A static
    variable might appear at the very end of a valid memory region; in this case,
    the memory addresses just past that variable could be invalid. (You can read more
    about this edge case in Randall Hyde’s *The Art of 64-Bit Assembly, Volume 1*
    [No Starch Press, 2021]; see section 5.5.3.3, “Passing Parameters on the Stack.”)
    Copying the operand from memory into a register before we push it avoids this
    problem. Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">AX</samp> is
    the only register we can use to help push memory operands onto the stack, because
    we have to preserve the callee-saved registers, we’ve already put arguments in
    the parameter passing registers, and we’ve reserved R10 and R11 for the instruction
    fix-up phase.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在指令中直接使用一个 4 字节的内存操作数，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq
    -4(%rbp)</samp>，我们会先将 4 字节的操作数压入栈中，然后再跟着压入 4 字节的内存后续内容。这通常没问题，虽然有点笨拙。但如果操作数后面的
    4 字节不是可读的内存，尝试访问这些字节会触发段错误，从而导致程序崩溃。这个问题在我们从栈中压入操作数时不会发生；其后的字节要么保存当前函数的临时值，要么是调用者栈帧的基址。但是，当我们压入静态变量时，这个问题可能会出现，我们将在[第
    10 章](chapter10.xhtml)中实现这一部分。静态变量可能出现在有效内存区域的末尾；在这种情况下，变量后面的内存地址可能是无效的。（你可以在
    Randall Hyde 的 *The Art of 64-Bit Assembly, Volume 1* [No Starch Press, 2021]
    中了解更多这个边缘情况；参见 5.5.3.3 节，“栈上传递参数”）。通过在将操作数压入栈之前将其从内存复制到寄存器，我们可以避免这个问题。请注意，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AX</samp> 是唯一可以帮助我们将内存操作数压入栈的寄存器，因为我们必须保留被调用者保存的寄存器，参数已经存放在传递参数的寄存器中，并且我们已将
    R10 和 R11 保留用于指令修复阶段。
- en: Once every argument is in place, we issue the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instruction to transfer control to the callee. After the call returns, we no longer
    need the arguments that were passed on the stack, and we certainly don’t need
    the padding. We add the total size of those arguments and the padding to the stack
    pointer with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeallocateStack</samp>
    instruction. After deallocating this space, the stack pointer will be back where
    it was before we started preparing for the function call.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦每个参数都准备好，我们就发出 <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> 指令，将控制权转交给被调用者。调用返回后，我们不再需要栈上传递的参数，也当然不需要填充。我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DeallocateStack</samp> 指令，将这些参数和填充的总大小加到栈指针上。释放这些空间后，栈指针会恢复到准备函数调用之前的位置。
- en: Finally, we retrieve the function’s return value. This value will be in EAX,
    and we copy it to its destination with a <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检索函数的返回值。这个值将保存在 EAX 中，我们通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    指令将其复制到目标位置。
- en: '[Tables 9-1](chapter9.xhtml#tab9-1) and [9-2](chapter9.xhtml#tab9-2) summarize
    this chapter’s changes to the conversion from TACKY to assembly. New constructs
    and changes to existing constructs are bolded.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-1](chapter9.xhtml#tab9-1) 和 [9-2](chapter9.xhtml#tab9-2) 总结了本章将 TACKY
    转换为汇编的变化。新构造和现有构造的修改已加粗显示。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-1:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Top-Level TACKY Constructs to Assembly</samp>
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 9-1:</samp> <samp class="SANS_Futura_Std_Book_11">将顶层
    TACKY 构造转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 顶层构造</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编顶层构造</samp>
    |'
- en: '| --- | --- |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">function_definitions</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">function_definitions</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
    |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">function_definitions</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">function_definitions</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name,</samp> <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">params</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,
    instructions)</samp> |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name,</samp> <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">params</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,
    instructions)</samp> |'
- en: '[PRE60]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '|'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-2:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表9-2：</samp> <samp class="SANS_Futura_Std_Book_11">将TACKY指令转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编指令</samp>
    |'
- en: '| --- | --- |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FunCall(fun_name, args, dst)</samp>
    |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FunCall(fun_name, args, dst)</samp>
    |'
- en: '[PRE61]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '|'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The assembly for a function call is too complex to fully specify in a table,
    so the conversion for <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    in [Table 9-2](chapter9.xhtml#tab9-2) is more of a rough outline.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用的汇编太复杂，无法完全在表格中指定，因此[表9-2](chapter9.xhtml#tab9-2)中关于<st1 class="SANS_TheSansMonoCd_W5Regular_11">FunCall</st1>的转换更像是一个粗略的概述。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudoregisters</samp>
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">替换伪寄存器</samp>
- en: 'Next, we’ll update the pseudoregister replacement pass. Most of the logic here
    won’t change: we’ll replace pseudoregisters in each function definition exactly
    the same way as in past chapters. As we saw earlier, pseudoregisters that represent
    function parameters don’t require any special handling. They’ll get assigned locations
    on the stack, just like local variables.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新伪寄存器替换过程。这里的大部分逻辑不会改变：我们将以与过去章节相同的方式，在每个函数定义中替换伪寄存器。正如我们之前所看到的，代表函数参数的伪寄存器不需要任何特殊处理。它们将像局部变量一样分配栈上的位置。
- en: However, we do need to make a couple of updates. First, we’ll extend this pass
    to replace pseudoregisters in the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp>
    instruction. (We don’t directly push pseudoregisters now, but we will in [Part
    II](part2.xhtml).) Second, we’ll change how we track the stack space needed by
    each function. Previously, this whole pass returned a single number because the
    program contained a single function. Now we need to return a stack size for each
    function we process. You could record each function’s stack size in the symbol
    table, or annotate each function with its stack size in the assembly AST.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要进行几个更新。首先，我们将扩展此过程以替换新<st1 class="SANS_TheSansMonoCd_W5Regular_11">Push</st1>指令中的伪寄存器。（我们现在不直接推送伪寄存器，但我们会在[第二部分](part2.xhtml)中这么做。）其次，我们将更改如何跟踪每个函数所需的栈空间。之前，这个过程返回一个单一的数字，因为程序只包含一个函数。现在我们需要为每个处理的函数返回一个栈大小。你可以将每个函数的栈大小记录在符号表中，或者在汇编AST中注释每个函数的栈大小。
- en: Note that parameters count toward a function’s stack size, whether they were
    passed on the stack or in registers, since we copy them into the function’s stack
    frame.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，参数会计入函数的栈大小，无论它们是通过栈传递还是通过寄存器传递，因为我们将它们复制到函数的栈帧中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Allocating Stack
    Space During Instruction Fix-Up</samp>
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">在指令修复过程中分配栈空间</samp>
- en: 'We need to make one small adjustment to the instruction fix-up pass: we’ll
    change how we add <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp>
    to each function definition. First, we’ll look up the stack space needed by each
    function wherever we recorded it during pseudoregister replacement. Next, we’ll
    round that stack size up to the next multiple of 16\. Rounding up the size of
    the stack frame makes it easier to maintain the correct stack alignment during
    function calls.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对指令修正阶段做一个小调整：我们将更改添加 <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp>
    到每个函数定义的方式。首先，我们将查找每个函数所需的堆栈空间，查找的位置是我们在伪寄存器替换过程中记录的位置。接下来，我们将把堆栈大小四舍五入到下一个16的倍数。将堆栈帧的大小四舍五入，使得在函数调用期间更容易保持正确的堆栈对齐。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">代码输出</samp>
- en: Now we need to make sure the code emission stage can handle all our new instructions
    and operands. Most of this is pretty straightforward, but there are a few platform-specific
    details to consider. As we’ve already seen, function names are prefixed with an
    underscore on macOS, but not on Linux. This applies in <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instructions too, so on macOS you’ll emit
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要确保代码输出阶段能够处理我们所有的新指令和操作数。大部分内容都很简单直接，但也有一些特定平台的细节需要考虑。正如我们已经看到的，macOS
    上的函数名会以下划线作为前缀，而 Linux 上则不会。这一点在 <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    指令中也适用，因此在 macOS 上你将输出：
- en: '[PRE62]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'and on Linux you’ll emit:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，你将输出：
- en: '[PRE63]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'On Linux, you’ll also call functions in external libraries differently from
    functions defined in the same file. If <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    isn’t defined in the current translation unit, you’ll emit:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，你还会以不同的方式调用外部库中的函数，和调用同一文件中定义的函数不同。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    没有在当前翻译单元中定义，你将输出：
- en: '[PRE64]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: PLT stands for *procedure linkage table*, a section in ELF executables. (*ELF*,
    short *for Executable and Linkable Format*, is the standard file format for object
    files and executables on Linux and most other Unix-like systems; macOS uses a
    different file format called *Mach-O*.) Programs use the PLT to call functions
    in shared libraries. We’ve already learned that the linker combines object files
    and resolves symbols to concrete locations in memory in order to produce an executable.
    On modern systems, these locations are typically encoded as offsets from the current
    instruction rather than absolute memory addresses. When we define and use a symbol
    in the same executable, the linker can figure out the symbol’s relative offset
    from the instruction that uses it and resolve the reference.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: PLT 代表*过程链接表*，这是 ELF 可执行文件中的一个部分。(*ELF*，全称 *Executable and Linkable Format*，是
    Linux 和大多数类 Unix 系统中对象文件和可执行文件的标准格式；macOS 使用一种名为 *Mach-O* 的不同文件格式。) 程序使用 PLT 来调用共享库中的函数。我们已经学习过，链接器将对象文件合并并解析符号，定位到内存中的具体位置，从而生成可执行文件。在现代系统中，这些位置通常编码为相对于当前指令的偏移量，而不是绝对的内存地址。当我们在同一个可执行文件中定义并使用符号时，链接器可以根据使用该符号的指令计算出符号的相对偏移量，并解决该引用。
- en: Shared libraries are a different story. When a program uses a shared library,
    the linker doesn’t copy the whole library into the executable. Instead, the library
    is loaded into memory separately at runtime. The linker doesn’t know exactly where
    this library will live in memory, so it can’t resolve the names of shared library
    functions. Another piece of software, called the *dynamic linker*, must resolve
    these names at runtime. The dynamic linker can resolve symbols in a few different
    ways, but the most common approach is *lazy binding*. Using lazy binding, we don’t
    figure out a function’s address until the program tries to call that function.
    That’s where the PLT comes in. The operand <samp class="SANS_TheSansMonoCd_W5Regular_11">foo@PLT</samp>
    doesn’t refer to the function <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>.
    It refers to a tiny bit of code in the PLT that determines the address of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> if we don’t already know it,
    and then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>. The linker
    is responsible for generating this code, which is called a *PLT entry*.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库是另一个故事。当程序使用共享库时，链接器不会将整个库复制到可执行文件中。相反，库会在运行时被单独加载到内存中。链接器并不知道这个库在内存中的确切位置，因此它无法解析共享库函数的名称。另一个软件部分，叫做*动态链接器*，必须在运行时解析这些名称。动态链接器可以通过几种不同的方式来解析符号，但最常见的方法是*懒惰绑定*。使用懒惰绑定时，直到程序尝试调用某个函数时，我们才会确定该函数的地址。这时，PLT（过程链接表）就派上用场了。操作数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">foo@PLT</samp>并不指代函数<samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>。它指向PLT中的一小段代码，这段代码会在我们还不知道时确定<samp
    class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>的地址，然后调用<samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>。链接器负责生成这段代码，这段代码称为*PLT条目*。
- en: 'If <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> isn’t defined in
    the current translation unit, it might be defined in a shared library or in another
    object file that the linker will include in the final executable. In the latter
    case, we don’t need the PLT: the linker will be able to figure out the address
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> (or, more precisely,
    its offset from the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    instruction that refers to it). The code emission pass can’t tell these two cases
    apart, so it should include the <samp class="SANS_TheSansMonoCd_W5Regular_11">@PLT</samp>
    suffix either way; there’s no harm in including this suffix when we don’t need
    it.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果<samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>在当前翻译单元中未定义，它可能在共享库中定义，或者在链接器会包含到最终可执行文件中的另一个目标文件中。在后一种情况下，我们不需要PLT：链接器能够确定<samp
    class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>的地址（或者，更准确地说，它的偏移量相对于引用它的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">call</samp>指令）。代码生成阶段无法区分这两种情况，因此它应该无论如何都包括<samp
    class="SANS_TheSansMonoCd_W5Regular_11">@PLT</samp>后缀；即使我们不需要它，包含这个后缀也不会有害。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*For a more in-depth explanation of how the PLT works and why we need it, see
    the two blog posts on position-independent code listed in [Chapter 1](chapter1.xhtml)’s
    “Additional Resources” on [page 21](chapter1.xhtml#pg_21).*'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*关于PLT如何工作以及为什么需要它的更深入解释，请参阅[第1章](chapter1.xhtml)“附加资源”中的两个关于位置无关代码的博客文章，位于[第21页](chapter1.xhtml#pg_21)。*'
- en: On Linux, to check whether a function was defined in the current translation
    unit—and therefore whether it requires the <samp class="SANS_TheSansMonoCd_W5Regular_11">@PLT</samp>
    modifier—you’ll need to look it up in the symbol table. On macOS, which handles
    lazy binding slightly differently, you don’t need the <samp class="SANS_TheSansMonoCd_W5Regular_11">@PLT</samp>
    modifier at all.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，要检查一个函数是否在当前翻译单元中定义——因此它是否需要<samp class="SANS_TheSansMonoCd_W5Regular_11">@PLT</samp>修饰符——你需要在符号表中查找它。在macOS上，由于懒惰绑定的处理方式略有不同，你根本不需要<samp
    class="SANS_TheSansMonoCd_W5Regular_11">@PLT</samp>修饰符。
- en: '[Tables 9-3](chapter9.xhtml#tab9-3) through [9-5](chapter9.xhtml#tab9-5) show
    the changes to the code emission pass for this chapter, with new constructs and
    updates to existing constructs bolded.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '[表9-3](chapter9.xhtml#tab9-3)至[9-5](chapter9.xhtml#tab9-5)展示了本章中代码生成阶段的更改，新增的构造和更新的现有构造已用粗体标出。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-3:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Top-Level Assembly Constructs</samp>
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表9-3：</samp> <samp class="SANS_Futura_Std_Book_11">格式化顶级汇编构造</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编顶层结构</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">function_definitions</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">程序(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">函数定义</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> |'
- en: '[PRE65]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '|'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-4:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Instructions</samp>
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 9-4:</samp> <samp class="SANS_Futura_Std_Book_11">格式化汇编指令</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DeallocateStack(int)</samp>
    |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">释放栈空间(int)</samp> |'
- en: '[PRE66]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '|'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Push(operand)</samp> |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">推送(操作数)</samp> |'
- en: '[PRE67]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '|'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Call(label)</samp> |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">调用(label)</samp> |'
- en: '[PRE68]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '|'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-5:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 9-5:</samp> <samp class="SANS_Futura_Std_Book_11">格式化汇编操作数</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编操作数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(AX)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rax</samp> |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">寄存器(AX)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8字节</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rax</samp> |'
- en: '|  | <samp class="SANS_Futura_Std_Book_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp>
    |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Book_11">4字节</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp>
    |'
- en: '|  | <samp class="SANS_Futura_Std_Book_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%al</samp>
    |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Book_11">1字节</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%al</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(DX)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rdx</samp> |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">寄存器(DX)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8字节</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rdx</samp> |'
- en: '|  | <samp class="SANS_Futura_Std_Book_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%edx</samp>
    |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Book_11">4字节</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%edx</samp>
    |'
- en: '|  | <samp class="SANS_Futura_Std_Book_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%dl</samp>
    |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Book_11">1字节</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%dl</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(CX)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rcx</samp> |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">寄存器(CX)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8字节</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rcx</samp> |'
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%ecx</samp>
    |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">4字节</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%ecx</samp>
    |'
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%cl</samp>
    |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1字节</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%cl</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(DI)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rdi</samp> |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">寄存器(DI)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8字节</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rdi</samp> |'
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%edi</samp>
    |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">4字节</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%edi</samp>
    |'
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%dil</samp>
    |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1字节</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%dil</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(SI)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rsi</samp> |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">寄存器(SI)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8字节</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rsi</samp> |'
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%esi</samp>
    |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">4字节</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%esi</samp>
    |'
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%sil</samp>
    |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1字节</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%sil</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(R8)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r8</samp> |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(R8)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8字节</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r8</samp> |'
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r8d</samp>
    |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">4字节</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r8d</samp>
    |'
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r8b</samp>
    |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1字节</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r8b</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(R9)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r9</samp> |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(R9)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8字节</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r9</samp> |'
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r9d</samp>
    |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">4字节</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r9d</samp>
    |'
- en: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r9b</samp>
    |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Heavy_B_11">1字节</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r9b</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R10)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r10</samp> |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R10)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8字节</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r10</samp> |'
- en: '|  | <samp class="SANS_Futura_Std_Book_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r10d</samp>
    |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Book_11">4字节</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r10d</samp>
    |'
- en: '|  | <samp class="SANS_Futura_Std_Book_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r10b</samp>
    |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Book_11">1字节</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r10b</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R11)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r11</samp> |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R11)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">8字节</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r11</samp> |'
- en: '|  | <samp class="SANS_Futura_Std_Book_11">4-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r11d</samp>
    |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Book_11">4字节</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r11d</samp>
    |'
- en: '|  | <samp class="SANS_Futura_Std_Book_11">1-byte</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r11b</samp>
    |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Book_11">1字节</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r11b</samp>
    |'
- en: We now have 8-byte, 4-byte, and 1-byte names for every register. We’ll use 8-byte
    register names in <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instructions,
    1-byte names in conditional set instructions, and 4-byte names everywhere else.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们为每个寄存器都有了8字节、4字节和1字节的名称。在`push`指令中，我们将使用8字节寄存器名称，在条件设置指令中使用1字节名称，其它地方使用4字节名称。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Calling Library Functions</samp>
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">调用库函数</samp>
- en: Once you’ve updated the backend of your compiler, you’ll be able to compile
    programs that call standard library functions. You won’t be able to use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> directives, because any
    standard library header file will use language features your compiler doesn’t
    support. Instead, you’ll need to explicitly declare any library functions you
    want to use.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你更新了编译器的后端，你将能够编译调用标准库函数的程序。你将无法使用<samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>指令，因为任何标准库头文件都会使用编译器不支持的语言特性。相反，你需要显式声明任何你想要使用的库函数。
- en: There aren’t many library functions we can call at this point. Because the only
    type we’ve implemented is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    we can’t call functions that use any non-<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    type as either a return type or a parameter type. But we can call <samp class="SANS_TheSansMonoCd_W5Regular_11">putchar</samp>,
    which takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> argument
    and prints the corresponding ASCII character to stdout. This is enough for us
    to compile [Listing 9-32](chapter9.xhtml#list9-32), which is a slightly unorthodox
    implementation of “Hello, World!”
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以调用的库函数不多。因为我们实现的唯一类型是<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，所以我们不能调用任何使用非<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>类型作为返回类型或参数类型的函数。但我们可以调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">putchar</samp>，它接受一个<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>参数，并将对应的ASCII字符打印到标准输出。这足够让我们编译[清单9-32](chapter9.xhtml#list9-32)，这是一个稍微不正统的“Hello,
    World!”实现。
- en: '[PRE69]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-32: Hello, World!</samp>'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单9-32：Hello, World!</samp>
- en: 'Try compiling [Listing 9-32](chapter9.xhtml#list9-32) with your compiler and
    running it. If you’ve implemented everything correctly, it will write to stdout:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用你的编译器编译[清单9-32](chapter9.xhtml#list9-32)并运行它。如果你正确实现了所有内容，它将写入标准输出：
- en: '[PRE70]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This is a big milestone! Take a moment to bask in your sense of accomplishment
    before running the remaining test cases.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重大里程碑！在运行剩余的测试用例之前，先花点时间享受一下你的成就感。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: 'Function calls are the most powerful, and most complicated, feature we’ve seen
    so far. To implement them, you expanded the semantic analysis stage to understand
    different kinds of identifiers and learned the ins and outs of the System V calling
    convention. All that work paid off: you can finally compile programs that interact
    with the outside world!'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用是我们迄今为止见过的最强大、最复杂的特性。为了实现它们，你扩展了语义分析阶段，以理解不同种类的标识符，并学会了System V调用约定的细节。所有这些工作都得到了回报：你终于可以编译与外部世界交互的程序了！
- en: You’ve also laid the groundwork for other language features. You’ll expand on
    the idea of identifier linkage and build on the latest changes to the identifier
    resolution pass when you implement file scope variables and storage-class specifiers
    in the next chapter (the last chapter of [Part I](part1.xhtml)!). And you’ll continue
    to extend the type checker as you add more types throughout [Part II](part2.xhtml).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 你还为其他语言特性奠定了基础。当你在下一章（[第一部分](part1.xhtml)的最后一章）实现文件作用域变量和存储类说明符时，你将扩展标识符链接的概念，并基于标识符解析阶段的最新变化。随着[第二部分](part2.xhtml)中更多类型的加入，你还将继续扩展类型检查器。
