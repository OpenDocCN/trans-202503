- en: '**12'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**12'
- en: INSTRUCTION DETAILS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 指令详情**
- en: '![Image](../images/pg255_Image_259.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg255_Image_259.jpg)'
- en: In [Chapters 2](ch02.xhtml) and [3](ch03.xhtml), you learned how bit patterns
    can be used to represent data. Then, in [Chapters 4](ch04.xhtml) to [8](ch08.xhtml),
    you learned how bits can be implemented in hardware and used to perform computations.
    In this chapter, I’ll explain some of the details of how instructions are encoded
    in bit patterns that specify the operations and the locations of the data they
    operate on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.xhtml)和[第3章](ch03.xhtml)中，你学习了如何使用位模式表示数据。然后，在[第4章](ch04.xhtml)到[第8章](ch08.xhtml)中，你学习了如何在硬件中实现位，并利用它们执行计算。在本章中，我将解释一些关于指令如何通过位模式编码的细节，这些位模式指定了操作和它们操作的数据的位置。
- en: The primary goal of this chapter is to give you an overall view of how computer
    instructions know where the data they operate on is located. The details of the
    machine code for each instruction are not the sort of thing that people memorize—you’ll
    need to consult the manual for those—but being able to interpret them has helped
    me to better understand and debug many of my programs during my career.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目标是让你对计算机指令如何知道它们操作的数据的位置有一个整体了解。每个指令的机器码细节并不是人们会记住的内容——你需要查阅手册来获得这些细节——但能够理解这些内容帮助我在职业生涯中更好地理解和调试许多程序。
- en: The *Arm Architecture Reference Manual for A-Profile Architecture*, available
    at *[https://developer.arm.com/documentation/ddi0487/latest](https://developer.arm.com/documentation/ddi0487/latest)*,
    gives an in-depth description of how each bit in a given instruction affects what
    the instruction does, which can be a little daunting to read. To help you learn
    how to read the details in the manual, I’ll cover several instructions here, adding
    my own explanations to the manual’s descriptions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*《Arm架构参考手册 A-Profile架构》*，可以在*[https://developer.arm.com/documentation/ddi0487/latest](https://developer.arm.com/documentation/ddi0487/latest)*找到，详细描述了给定指令中每一位是如何影响该指令执行的，读起来可能有些吓人。为了帮助你学会如何阅读手册中的细节，我将涵盖几个指令，并在手册的描述上添加我自己的解释。'
- en: 'As mentioned in [Chapter 10](ch10.xhtml), A64 instructions fall into three
    general categories:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第10章](ch10.xhtml)中所提到的，A64指令分为三大类：
- en: '**Load and store** These instructions are used to transfer data between memory
    and general-purpose registers.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**加载与存储** 这些指令用于在内存和通用寄存器之间传输数据。'
- en: '**Data processing** These instructions operate on data items in registers and
    constants that are encoded as part of the instruction.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据处理** 这些指令在寄存器中的数据项和作为指令一部分编码的常量上进行操作。'
- en: '**Program flow control** These instructions are used to change the order of
    instruction execution from the order they are loaded into memory.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序流程控制** 这些指令用于改变指令执行的顺序，而不是它们加载到内存中的顺序。'
- en: We’ll look at a few examples of each type of instruction in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看几个每种类型指令的例子。
- en: '**Looking at Machine Code**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**查看机器码**'
- en: An *assembly listing* is a specific type of file generated by the assembler
    from assembly language source code that shows the machine code corresponding to
    each assembly language instruction. I’ll use the program in [Listing 12-1](ch12.xhtml#ch12list1)
    to show the machine language for several instructions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*汇编列表*是汇编器从汇编语言源代码生成的特定类型文件，显示了每条汇编语言指令对应的机器码。我将使用[清单12-1](ch12.xhtml#ch12list1)中的程序来展示几条指令的机器语言。'
- en: '*add_consts.s*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_consts.s*'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 12-1: A program to add some constants*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单12-1：一个用于加法常量的程序*'
- en: Of course, this is a silly program—all the data is constant—but it does allow
    me to illustrate a few points. For example, I’ve used two different instructions,
    `mov` ❶ and `orr` ❷, to copy the value in `w20` into `w2`. This will allow us
    to compare the machine code for two ways of accomplishing the same effect.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个傻乎乎的程序——所有的数据都是常量——但它确实让我能够说明一些要点。例如，我使用了两条不同的指令，`mov` ❶ 和 `orr` ❷，将`w20`中的值复制到`w2`中。这将使我们能够比较两种完成相同效果的机器码。
- en: We can produce an assembly listing by passing the `-al` option to the assembler.
    This causes the assembly listing to be written to standard output, which defaults
    to the screen. We can capture this with the redirection operator, `>`. For example,
    I used the command
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`-al`选项传递给汇编器来生成汇编列表。这会将汇编列表写入标准输出，默认是屏幕。我们可以使用重定向操作符`>`捕获它。例如，我使用了命令
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: to produce the assembly listing file shown in [Listing 12-2](ch12.xhtml#ch12list2).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 生成[清单12-2](ch12.xhtml#ch12list2)中显示的汇编列表文件。
- en: '*add_consts.lst*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_consts.lst*'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 12-2: The assembly listing file for the program in [Listing 12-1](ch12.xhtml#ch12list1)*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-2：程序的汇编清单文件，参见[清单 12-1](ch12.xhtml#ch12list1)*'
- en: The first column in the assembly listing file shows the corresponding line number
    in the source file. The next column shows the 16-bit relative address from the
    beginning of each section, in hexadecimal.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编清单文件中的第一列显示源文件中的相应行号。下一列显示从每个节的开始到该行的16位相对地址，采用十六进制表示。
- en: The third column gives the machine code for the instruction or data, also in
    hexadecimal. All A64 instructions are 32 bits wide. The assembly listing shows
    the 4 bytes in each instruction in the order that they’ll be stored in memory.
    Since ours is a little-endian environment, the 4 bytes appear backward in the
    assembly listing. For example, the first instruction in this program ❶ is the
    32-bit word `0xa9827bfd`. (We’ll look at the other instructions that I’ve called
    out in this listing a bit later, in “Moving Data from Register to Register” on
    [page 232](ch12.xhtml#ch12lev2sec1).)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第三列给出了指令或数据的机器码，也以十六进制表示。所有A64指令都是32位宽的。汇编清单显示了每条指令中的4个字节，它们将按顺序存储在内存中。由于我们处于小端环境，汇编清单中的4个字节会按相反顺序显示。例如，本程序中的第一条指令❶是32位字`0xa9827bfd`。（我们稍后将在“从寄存器到寄存器的数据移动”部分，位于[第232页](ch12.xhtml#ch12lev2sec1)中，查看我在此清单中标出的其他指令。）
- en: 'In some cases, the names for the bit fields in my descriptions are different
    from those in the manual. Note that some of the names I use might have a different
    meaning in other places in the manual. Here are the names I’m using:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我描述中的比特字段名称与手册中的不同。请注意，我使用的一些名称在手册中的其他地方可能有不同的含义。以下是我使用的名称：
- en: sf The size flag. The operands are 32-bit values when it’s `0` or 64-bit when
    it’s `1`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: sf 大小标志。当为`0`时，操作数为32位值；当为`1`时，操作数为64位值。
- en: imm A constant integer used by the instruction.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: imm 指令使用的常数整数。
- en: hw The number of halfwords (16 bits) to shift a 16-bit `imm` value left before
    loading it into a register.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: hw 在将16位`imm`值加载到寄存器之前，左移的半字（16位）的数量。
- en: b_offset The number of bytes from the current instruction to an address.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: b_offset 当前指令到某个地址的字节数。
- en: b_offset:hi The high-order part of a `b_offset`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: b_offset:hi `b_offset`的高位部分。
- en: b:lo The low-order part of a `b_offset`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: b:lo `b_offset`的低位部分。
- en: w_offset The number of 32-bit words from the current instruction to an address.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: w_offset 当前指令到某个地址的32位字的数量。
- en: rb The number of a register holding a 64-bit base address for this instruction.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: rb 持有64位基地址的寄存器的编号，该地址用于此指令。
- en: rd The number of the destination register, which will hold the result of the
    instruction’s operation. Where there are two destination registers, I use `rd1`
    and `rd2`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: rd 目标寄存器的编号，用于存储指令操作的结果。如果有两个目标寄存器，我使用`rd1`和`rd2`。
- en: rs The number of a source register, which holds a value used in the instruction’s
    operation. Where there are two source registers, I use `rs1` and `rs2`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: rs 源寄存器的编号，用于存储在指令操作中使用的值。如果有两个源寄存器，我使用`rs1`和`rs2`。
- en: 'pi Tells the instruction how to treat the base register: `01` for post-index,
    `11` for pre-index, or `10` for don’t change.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: pi 指示指令如何处理基寄存器：`01`表示后索引，`11`表示前索引，或`10`表示不改变。
- en: 'sh Tells the instruction whether to shift an operand before using it in the
    operation: yes if it’s `1`, and no if it’s `0`. For a 2-bit `sh` field, `00` is
    `lsl`, `01` is `lsr`, `10` is `asr`, and `11` is `ror`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: sh 告诉指令是否在操作前对操作数进行移位：如果为`1`，则为移位；如果为`0`，则不移位。对于2位的`sh`字段，`00`表示`lsl`，`01`表示`lsr`，`10`表示`asr`，`11`表示`ror`。
- en: shft_amnt The number of bits to shift an operand.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: shft_amnt 操作数要左移的位数。
- en: 'Bits 28 to 25 show which group the instruction is in: load and store (`0x4,
    0x6, 0xc, 0xe`), data processing (`0x5, 0x7, 0x8, 0x9, 0xd, 0xf`), or program
    flow control (`0xa, 0xb`). Many instructions have variants. The assembler will
    pick the variant appropriate for the operands we use. I’ll start by showing you
    the load and store instructions in [Listing 12-1](ch12.xhtml#ch12list1).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 位28到25显示指令所在的组：加载和存储组（`0x4, 0x6, 0xc, 0xe`）、数据处理组（`0x5, 0x7, 0x8, 0x9, 0xd,
    0xf`），或者程序流控制组（`0xa, 0xb`）。许多指令有变体。汇编器将选择适合我们使用的操作数的变体。我将首先向你展示[清单 12-1](ch12.xhtml#ch12list1)中的加载和存储指令。
- en: '**Encoding Load and Store Instructions**'
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**加载和存储指令的编码**'
- en: '[Figure 12-1](ch12.xhtml#ch12fig1) shows the basic load instruction.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-1](ch12.xhtml#ch12fig1) 显示了基本的加载指令。'
- en: '![Image](../images/pg259_Image_260.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg259_Image_260.jpg)'
- en: '*Figure 12-1: A basic load instruction: `Idr w3, [sp, z]`*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-1：基本的加载指令：`Idr w3, [sp, z]`*'
- en: '[Figure 12-2](ch12.xhtml#ch12fig2) shows the basic store instruction.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-2](ch12.xhtml#ch12fig2)显示了基本的存储指令。'
- en: '![Image](../images/pg259_Image_261.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg259_Image_261.jpg)'
- en: '*Figure 12-2: A basic store instruction:* str w22, [sp, z]'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-2：基本的存储指令：* str w22, [sp, z]'
- en: In both instructions, bit 24 is `1`, which shows us that the assembler has used
    the immediate, unsigned offset variant. Other variants have `0` in bit 24\. Both
    instructions use `sp` as the base address register, giving `11111` in the `rb`
    field, and in both instructions the offset from the base register is the number
    of 32-bit words. The offset in [Listing 12-1](ch12.xhtml#ch12list1) is `z`, which
    equates to 28\. We use the number of bytes in assembly language, but the assembler
    divides this value by 4 to encode the number of words in the machine code for
    the instruction, giving 7 in the `w_offset` field.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两条指令中，第 24 位是 `1`，这表示汇编器使用了立即数、无符号偏移量变体。其他变体的第 24 位是 `0`。这两条指令都使用 `sp` 作为基地址寄存器，`rb`
    字段中的值为 `11111`，而在这两条指令中，从基寄存器的偏移量是 32 位字的数量。[代码清单 12-1](ch12.xhtml#ch12list1)中的偏移量是
    `z`，即 28。我们在汇编语言中使用字节数，但汇编器将这个值除以 4，以便在指令的机器码中编码字的数量，这样 `w_offset` 字段中的值就是 7。
- en: In [Figure 12-1](ch12.xhtml#ch12fig1), the `0` in the `sf` field together with
    `00011` in the `rd` field tells the CPU to use `w3` for the destination register,
    and the `0` in the `sf` field together with `10110` in the `rs` field in [Figure
    12-2](ch12.xhtml#ch12fig2) tells the CPU to use `w22` for the source register.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 12-1](ch12.xhtml#ch12fig1)中，`sf` 字段中的 `0` 和 `rd` 字段中的 `00011` 告诉 CPU 使用
    `w3` 作为目标寄存器，在[图 12-2](ch12.xhtml#ch12fig2)中，`sf` 字段中的 `0` 和 `rs` 字段中的 `10110`
    告诉 CPU 使用 `w22` 作为源寄存器。
- en: The stack frame is created with the `stp` instruction, shown in [Figure 12-3](ch12.xhtml#ch12fig3).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈框架是通过 `stp` 指令创建的，如[图 12-3](ch12.xhtml#ch12fig3)所示。
- en: '![Image](../images/pg260_Image_262.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg260_Image_262.jpg)'
- en: '*Figure 12-3: The instruction to push* fp *and* sp *onto the stack:* stp fp,
    lr, [sp, FRAME]!'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-3：将* fp *和* sp *推送到堆栈的指令：* stp fp, lr, [sp, FRAME]!'
- en: It is deleted with the `ldp` instruction, shown in [Figure 12-4](ch12.xhtml#ch12fig4).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过 `ldp` 指令删除，如[图 12-4](ch12.xhtml#ch12fig4)所示。
- en: '![Image](../images/pg260_Image_263.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg260_Image_263.jpg)'
- en: '*Figure 12-4: The instruction to pop* fp *and* sp *from the stack:* ldp fp,
    lr, [sp], FRAME'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-4：从堆栈中弹出* fp *和* sp *的指令：* ldp fp, lr, [sp], FRAME'
- en: Both of these instructions use `sp` for their base register. In [Figure 12-3](ch12.xhtml#ch12fig3),
    the `11` in the `pi` field tells the CPU to subtract the `w_offset`, 4 words (32
    bytes), from `sp` before (pre-index) storing the contents of registers `x29` and
    `x30` at that address. The CPU stores the entire 64 bits of each register because
    `sf` is `1`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个指令都使用 `sp` 作为基址寄存器。在[图 12-3](ch12.xhtml#ch12fig3)中，`pi` 字段中的 `11` 告诉 CPU
    在存储寄存器 `x29` 和 `x30` 的内容到该地址之前（前索引）从 `sp` 中减去 `w_offset`，即 4 个字（32 字节）。因为 `sf`
    为 `1`，CPU 会存储每个寄存器的整个 64 位数据。
- en: The `pi` field is `01` in [Figure 12-4](ch12.xhtml#ch12fig4), so 32 is added
    to `sp` after (post-index) the two 64-bit values are loaded into registers `x29`
    and `x30`. The CPU loads 64 bits from memory into each register because `sf` is
    `1`. Next, I’ll explain the data processing instructions in [Listing 12-2](ch12.xhtml#ch12list2).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`pi` 字段在[图 12-4](ch12.xhtml#ch12fig4)中是 `01`，因此在将两个 64 位的值加载到寄存器 `x29` 和 `x30`
    后，`sp` 会加上 32（后索引）。CPU 从内存加载 64 位数据到每个寄存器，因为 `sf` 为 `1`。接下来，我将解释[代码清单 12-2](ch12.xhtml#ch12list2)中的数据处理指令。'
- en: '**Encoding Data Processing Instructions**'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编码数据处理指令**'
- en: Data processing instructions operate on values that are already in the CPU,
    either in registers or as part of the instruction itself. They are used to move
    data or perform arithmetic and logic operations on data. In some cases, these
    operations overlap.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 数据处理指令作用于已经在 CPU 中的值，这些值可能存储在寄存器中，也可能是指令本身的一部分。它们用于移动数据或对数据进行算术和逻辑运算。在某些情况下，这些操作会重叠。
- en: '***Moving Data from Register to Register***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***从寄存器到寄存器的数据移动***'
- en: We’ll start by looking at the instruction that moves the value from the `sp`
    register to the `fp` register, shown in [Figure 12-5](ch12.xhtml#ch12fig5).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看将值从 `sp` 寄存器移动到 `fp` 寄存器的指令，如[图 12-5](ch12.xhtml#ch12fig5)所示。
- en: '![Image](../images/pg260_Image_264.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg260_Image_264.jpg)'
- en: '*Figure 12-5: A basic register-to-register move instruction:* mov fp, sp'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-5：基本的寄存器到寄存器的移动指令：* mov fp, sp'
- en: Next, we’ll look at an instruction that uses a logical operation to effectively
    move a value from one register to another, shown in [Figure 12-6](ch12.xhtml#ch12fig6).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看一种使用逻辑运算符将值从一个寄存器有效地移动到另一个寄存器的指令，见[图12-6](ch12.xhtml#ch12fig6)。
- en: '![Image](../images/pg261_Image_265.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg261_Image_265.jpg)'
- en: '*Figure 12-6: A logical operation to move data:* orr w2, wzr, w20'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-6：通过逻辑运算移动数据的指令：* orr w2, wzr, w20'
- en: Notice that the `rs` field in [Figure 12-5](ch12.xhtml#ch12fig5) is the same
    as the `rs1` field in [Figure 12-6](ch12.xhtml#ch12fig6), but in the first case
    it’s the code for the stack pointer and in the second it’s the zero register.
    This shows that the way register 31 is treated, as a stack pointer or zero register,
    depends on the instruction.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[图12-5](ch12.xhtml#ch12fig5)中的`rs`字段与[图12-6](ch12.xhtml#ch12fig6)中的`rs1`字段相同，但在第一个情况下，它是堆栈指针的代码，而在第二个情况下，它是零寄存器。这表明，寄存器31的处理方式，作为堆栈指针或零寄存器，取决于指令。
- en: You’re probably wondering why I’m showing an `orr` instruction instead of a
    `mov` instruction in [Figure 12-6](ch12.xhtml#ch12fig6). As you might guess from
    the name, the `orr` instruction performs a bitwise OR operation between the values
    in the two source registers, `rs1` and `rs2`, and stores the result in the destination
    register, `rd`. Since `rs1` is the zero register in our instruction, this operation
    simply moves the value in `rs2` to `rd`, which is equivalent to `mov w2, w20`
    here. I’ll describe the `orr` instruction in more detail when we look at logic
    operators in [Chapter 16](ch16.xhtml).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么在[图12-6](ch12.xhtml#ch12fig6)中我展示的是`orr`指令，而不是`mov`指令。正如你从名称中可能猜到的那样，`orr`指令对两个源寄存器`rs1`和`rs2`中的值执行按位或（bitwise
    OR）操作，并将结果存储到目标寄存器`rd`中。由于我们的指令中`rs1`是零寄存器，因此这个操作实际上只是将`rs2`中的值移动到`rd`，这相当于`mov
    w2, w20`。当我们在[第16章](ch16.xhtml)讨论逻辑运算符时，我会更详细地描述`orr`指令。
- en: The `mov w2, w20` ❷ and `orr w2, wzr, w20` ❸ instructions in [Listing 12-2](ch12.xhtml#ch12list2)
    (on [page 229](ch12.xhtml#page_229)) use exactly the same machine code. The two
    names for the same instruction are said to be *aliases*. For the instructions
    that have aliases, you should use the name that better expresses your intent in
    the algorithm. In our example program, `mov w2, w20` is a better choice.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单12-2](ch12.xhtml#ch12list2)（见[第229页](ch12.xhtml#page_229)）中的`mov w2, w20`
    ❷和`orr w2, wzr, w20` ❸指令使用的是完全相同的机器码。这两种指令的不同名称被称为*别名*。对于具有别名的指令，你应当使用能更好表达算法意图的名称。在我们的示例程序中，`mov
    w2, w20`是一个更好的选择。
- en: '***Moving a Constant to a Register***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将常量移入寄存器***'
- en: '[Figure 12-7](ch12.xhtml#ch12fig7) shows the instruction for moving a positive
    or unsigned constant into a register.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-7](ch12.xhtml#ch12fig7)展示了将正数或无符号常量移入寄存器的指令。'
- en: '![Image](../images/pg261_Image_266.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg261_Image_266.jpg)'
- en: '*Figure 12-7: The instruction for moving a positive constant:* mov w19, 123'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-7：将正常量移入寄存器的指令：* mov w19, 123'
- en: '[Figure 12-8](ch12.xhtml#ch12fig8) shows the instruction for moving a negative
    constant into a register.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-8](ch12.xhtml#ch12fig8)展示了将负常量移动到寄存器中的指令。'
- en: '![Image](../images/pg261_Image_267.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg261_Image_267.jpg)'
- en: '*Figure 12-8: The instruction for moving a negative constant:* mov w20, -123'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-8：将负常量移入寄存器的指令：* mov w20, -123'
- en: Although both instructions use the `mov` mnemonic, in [Figure 12-7](ch12.xhtml#ch12fig7)
    bit 30 is `1`, and in [Figure 12-8](ch12.xhtml#ch12fig8) it’s `0`. The difference
    is that the first instruction is moving a positive number and the second a negative
    number. When the constant in a `mov` instruction is negative, the assembler uses
    the `movn` (move with NOT) instruction from [Chapter 10](ch10.xhtml).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两条指令都使用`mov`助记符，但在[图12-7](ch12.xhtml#ch12fig7)中，位30为`1`，而在[图12-8](ch12.xhtml#ch12fig8)中，它为`0`。其区别在于，第一条指令是在移动一个正数，而第二条指令则是在移动一个负数。当`mov`指令中的常量为负数时，汇编器会使用[第10章](ch10.xhtml)中的`movn`（移位并取反）指令。
- en: In [Figure 12-7](ch12.xhtml#ch12fig7), the constant +123 is encoded as `0x007b`,
    as we would expect, but in [Figure 12-8](ch12.xhtml#ch12fig8) we see that –123
    is encoded as `0x007a`, which is +122 in decimal.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图12-7](ch12.xhtml#ch12fig7)中，常量+123被编码为`0x007b`，这符合我们的预期，但在[图12-8](ch12.xhtml#ch12fig8)中，我们看到–123被编码为`0x007a`，在十进制中是+122。
- en: 'You learned in [Chapter 3](ch03.xhtml) that in the two’s complement notation,
    the negative of a number can be computed by taking the complement of the number
    and adding 1\. In other words, –123 is the complement of +122 in two’s complement
    notation. The `mov` instruction in [Figure 12-8](ch12.xhtml#ch12fig8) computes
    the NOT of the value in the `imm` field and sign-extends it to the size of the
    destination register before storing the result there. So, this instruction uses
    the `0x007a` to store `0xffffff85` in the `w20` register, as shown in the debugger:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第3章](ch03.xhtml)中学到，在二补码表示法中，负数可以通过取数字的补码再加1来计算。换句话说，-123在二补码表示法中是+122的补码。[图
    12-8](ch12.xhtml#ch12fig8)中的`mov`指令计算`imm`字段值的NOT值，并将其符号扩展到目标寄存器的大小后存储到该寄存器中。所以，这条指令使用`0x007a`将`0xffffff85`存储到`w20`寄存器中，如调试器所示：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In both instructions, the constant has to fit within the 16-bit immediate value.
    The range for positive numbers is 0 to +65,535, and for negative numbers it’s
    –1 to –65,536.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两条指令中，常数必须适应16位立即数值。正数的范围是0到+65,535，负数的范围是-1到-65,536。
- en: '***Performing Arithmetic***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***执行算术运算***'
- en: Let’s look at the instruction for adding a constant to a value in a register,
    shown in [Figure 12-9](ch12.xhtml#ch12fig9).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一下在[图 12-9](ch12.xhtml#ch12fig9)中显示的将常数加到寄存器值中的指令。
- en: '![Image](../images/pg262_Image_268.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg262_Image_268.jpg)'
- en: '*Figure 12-9: The instruction for adding a constant to a value:* add w22, w21,
    456'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-9：将常数添加到值的指令：* add w22, w21, 456'
- en: This instruction adds the 12-bit `imm` value to the value in `rs` and stores
    the result in the `rd` register. When the shift bit, `sh`, is `1`, the `imm` value
    is shifted left 12 bits before performing the addition. The shift option allows
    us to add a 24-bit constant in two `add` operations. The first will add the low-order
    12 bits and the second the high-order 12 bits.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令将12位的`imm`值加到`rs`中的值，并将结果存储在`rd`寄存器中。当移位位`sh`为`1`时，`imm`值会先左移12位再进行加法。这个移位选项允许我们在两次`add`操作中添加一个24位的常数。第一次将添加低12位，第二次将添加高12位。
- en: Comparing [Figure 12-9](ch12.xhtml#ch12fig9) with [Figure 12-5](ch12.xhtml#ch12fig5),
    you can see another example of an alias. If `imm` is 0 and one of `rd` or `rs`
    is 31, this `add` instruction is the same as a `mov` to or from the `sp` register.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将[图 12-9](ch12.xhtml#ch12fig9)与[图 12-5](ch12.xhtml#ch12fig5)进行比较，你会看到另一个别名的例子。如果`imm`为0且`rd`或`rs`中的一个为31，那么这条`add`指令与`mov`指令（用于`sp`寄存器）是相同的。
- en: '***Computing Addresses***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计算地址***'
- en: Now, let’s look at the instruction that loads the address of the `printf` format
    string into the `x0` register, as shown in [Figure 12-10](ch12.xhtml#ch12fig10).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下加载`printf`格式字符串地址到`x0`寄存器中的指令，如[图 12-10](ch12.xhtml#ch12fig10)所示。
- en: '![Image](../images/pg263_Image_269.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg263_Image_269.jpg)'
- en: '*Figure 12-10: The instruction to load an address:* adr x0, format'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-10：加载地址的指令：* adr x0, format'
- en: You learned in [Chapter 11](ch11.xhtml) that this instruction computes the address
    of `format` by adding the offset from this instruction to `format` and the value
    in `pc`, then loads the result into `x0`. The `b_offset` field in this instruction
    shows that all 21 bits are `0` (don’t forget to include the two low-order bits
    in the `b:lo` field). This seems to indicate that the `format` text string is
    located at the same place as this instruction, which is clearly not possible.
    This text string is in the `.rodata` section. The linker will decide where to
    locate that section and fill in the `b_offset:hi` and `b:lo` fields during the
    linking process.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第11章](ch11.xhtml)中学到，这条指令通过将这条指令的偏移量加到`format`和`pc`中的值来计算`format`的地址，然后将结果加载到`x0`寄存器中。这条指令中的`b_offset`字段显示所有21位都是`0`（别忘了包括`b:lo`字段中的两个低位）。这似乎表明`format`文本字符串位于与这条指令相同的位置，显然这是不可能的。该文本字符串位于`.rodata`段中。链接器将在链接过程中决定该段的存放位置，并填充`b_offset:hi`和`b:lo`字段。
- en: '***Looking at the Details of an Executable File***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查看可执行文件的详细信息***'
- en: 'You can use a program called `objdump` to look at the code in an executable
    program file. For example, to dump the contents of the *add_consts* file, you
    can use the following command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一个名为`objdump`的程序查看可执行程序文件中的代码。例如，要转储*add_consts*文件的内容，可以使用以下命令：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `-D` option dumps all the sections in the file, assumes that they all contain
    instructions, and disassembles them as such. I’m showing only the two sections
    that interest us here.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`-D`选项转储文件中的所有段，假设它们都包含指令，并将它们反汇编。我这里只显示了我们关心的两个段。'
- en: The first column shows the relative address where each instruction will be loaded
    into memory. The operating system will decide the base loading address when loading
    the program.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列显示每条指令加载到内存时的相对地址。操作系统将在加载程序时决定基加载地址。
- en: The second column shows the machine code of the instruction at that address.
    Note that `objdump` displays the machine code in 32-bit instruction order, not
    in the little-endian byte order we see in assembly listing files.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第二列显示该地址处指令的机器码。请注意，`objdump`显示的机器码是32位指令顺序，而不是我们在汇编清单文件中看到的小端字节顺序。
- en: The linker has filled in the offset to the `format` text string in the `adr`
    instruction ❶. Per [Figure 12-10](ch12.xhtml#ch12fig10), the offset is `000000000000010110100`.
    Adding this to the relative address of the instruction gives `0x7a4` + `0x0b4`
    = `0x858`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器已填充`adr`指令中的`format`文本字符串的偏移量❶。根据[图12-10](ch12.xhtml#ch12fig10)，该偏移量为`000000000000010110100`。将其加到指令的相对地址上，得到`0x7a4`
    + `0x0b4` = `0x858`。
- en: 'The machine code at relative address `0x858` begins with the bytes `0x25`,
    `0x69`, `0x20`, `0x2b`, which are the code points for the first four characters
    in the format text string: `%`, `i`, space, and `+`. The assembly listing file,
    shown in [Listing 12-2](ch12.xhtml#ch12list2), displays the bytes in the proper
    order. Next, I’ll show you the two instructions in this program that cause program
    flow to go someplace other than the next instruction in memory.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 相对地址`0x858`处的机器码以字节`0x25`、`0x69`、`0x20`、`0x2b`开始，这些是格式文本字符串中前四个字符的代码点：`%`、`i`、空格和`+`。汇编清单文件（见[清单12-2](ch12.xhtml#ch12list2)）按正确顺序显示这些字节。接下来，我将向你展示此程序中的两个指令，它们使程序流程转移到内存中下一个指令之外的位置。
- en: '**Encoding Program Flow Control Instructions**'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编码程序流程控制指令**'
- en: I’ll start with the instruction used to call the `printf` function, shown in
    [Figure 12-11](ch12.xhtml#ch12fig11).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从用于调用`printf`函数的指令开始，见[图12-11](ch12.xhtml#ch12fig11)。
- en: '![Image](../images/pg264_Image_270.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg264_Image_270.jpg)'
- en: '*Figure 12-11: The function call instruction:* bl printf'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-11：函数调用指令：* bl printf'
- en: The `bl` instruction copies the address in `pc`, plus 4, to the link register,
    `x30`. It then shifts `w_offset` 2 bits to the left to give a byte offset, sign-extends
    it to 64 bits, and adds the result to `pc`. The result is to save the address
    of the instruction immediately after the `bl` instruction in memory to the link
    register and then transfer program flow to `w_offset` words from the address of
    the `bl` instruction. Since `w_offset` is 26 bits wide, the offset in bytes is
    limited to 28 bits, giving a transfer limit of ±128MB away in memory.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`bl`指令将`pc`中的地址加上4后的值复制到链接寄存器`x30`。然后，它将`w_offset`向左移2位，得到字节偏移量，扩展为64位，并将结果加到`pc`。结果是将`bl`指令后面的指令地址保存到链接寄存器中，然后将程序流程转移到距离`bl`指令地址`w_offset`字的地方。由于`w_offset`是26位宽，因此字节偏移量被限制为28位，导致在内存中最多可以转移±128MB。'
- en: The last instruction we’ll look at is `ret`, shown in [Figure 12-12](ch12.xhtml#ch12fig12).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看的最后一条指令是`ret`，见[图12-12](ch12.xhtml#ch12fig12)。
- en: '![Image](../images/pg264_Image_271.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg264_Image_271.jpg)'
- en: '*Figure 12-12: The return from function instruction:* ret'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-12：函数返回指令：* ret'
- en: The `ret` instruction moves the address from the register specified in the `rs`
    field to `pc`. Although I didn’t specify a register in [Listing 12-2](ch12.xhtml#ch12list2),
    the assembler uses `x30` by default. We could use another register, but that would
    be inconsistent with the published standards and likely lead to program bugs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`ret`指令将指定寄存器中地址的值移动到`pc`。尽管在[清单12-2](ch12.xhtml#ch12list2)中我没有指定寄存器，但汇编器默认使用`x30`。我们可以使用另一个寄存器，但这将与已发布的标准不一致，并可能导致程序出现错误。'
- en: '**YOUR TURN**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**你来试试**'
- en: 12.1     Enter the program in [Listing 12-1](ch12.xhtml#ch12list1) and use the
    debugger to determine when the `adr` instruction knows the address of the format
    text string.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 12.1 在[清单12-1](ch12.xhtml#ch12list1)中输入程序，并使用调试器确定`adr`指令何时知道格式文本字符串的地址。
- en: 12.2     Experiment with the constants in the program in [Listing 12-1](ch12.xhtml#ch12list1)
    to find the magnitude limits of the constants.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 12.2 尝试修改[清单12-1](ch12.xhtml#ch12list1)中的常量，找出常量的大小限制。
- en: 12.3     Modify the program in [Listing 12-1](ch12.xhtml#ch12list1) to use 64-bit
    integers (`long int` in C). Does this allow you to use larger constants?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 12.3 修改[清单12-1](ch12.xhtml#ch12list1)中的程序，使用64位整数（C语言中的`long int`）。这是否允许你使用更大的常量？
- en: 12.4     Write a program in C that does the same thing as our assembly language
    program in [Listing 12-1](ch12.xhtml#ch12list1). Does your C program allow you
    to use larger constants? If so, why?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 12.4    编写一个C程序，完成与我们在[清单 12-1](ch12.xhtml#ch12list1)中汇编语言程序相同的功能。你的C程序是否允许你使用更大的常量？如果可以，为什么？
- en: Now that you know what machine code looks like, we’ll look at how an assembler
    program translates assembly language into machine code. The general algorithm
    is similar for linking functions together; I’ll cover that too.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了机器代码是什么样子，我们来看一下汇编器程序是如何将汇编语言翻译成机器代码的。链接功能的通用算法类似；我也会讲解这一部分。
- en: '**Translating Assembly into Machine Code**'
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**将汇编语言翻译成机器代码**'
- en: The presentation in this section is meant to be an overview, so it ignores most
    of the details. My intention is to give you only a rough idea of how an assembler
    translates the source code into machine language and how a linker connects the
    different modules that make up an entire program.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的介绍是概述性内容，因此忽略了大多数细节。我的目的是仅向你大致展示汇编器如何将源代码翻译成机器语言，以及链接器如何将构成整个程序的不同模块连接起来。
- en: '***The Assembler***'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***汇编器***'
- en: The simplest approach for an assembler to translate assembly language into machine
    code would be to go through the source one line at a time, translating each one
    in turn. This would work fine, except for situations where an instruction refers
    to a label on a line after the current line.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编器将汇编语言翻译成机器代码的最简单方法是逐行处理源代码，一次翻译一行。这种方法在大多数情况下是有效的，除了指令引用当前行之后的标签的位置时。
- en: To see how the assembler deals with these forward references, I’ll make a forward
    reference to [Listing 13-11](ch13.xhtml#ch13list11) in [Chapter 13](ch13.xhtml),
    where we’ll be making use of them. [Listing 12-3](ch12.xhtml#ch12list3) shows
    a portion of the assembly listing file from that program.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解汇编器如何处理这些前向引用，我将在[第 13 章](ch13.xhtml)中的[清单 13-11](ch13.xhtml#ch13list11)中做一个前向引用，我们将在其中使用这些引用。[清单
    12-3](ch12.xhtml#ch12list3)显示了该程序的汇编清单文件的一部分。
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 12-3: Part of the listing file for the program in [Listing 13-11](ch13.xhtml#ch13list11)
    from [Chapter 13](ch13.xhtml)*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-3：来自[第 13 章](ch13.xhtml)的[清单 13-11](ch13.xhtml#ch13list11)程序的一部分*'
- en: I’ll cover the details in [Chapter 13](ch13.xhtml), but this section of code
    compares the values in registers `w0` and `w1`. If the value in `w1` is higher,
    the `b.hi` instruction causes the program flow to branch to the address labeled
    `tails`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在[第 13 章](ch13.xhtml)中详细讲解，但这一段代码比较了`w0`和`w1`寄存器中的值。如果`w1`中的值较高，`b.hi`指令会导致程序流程跳转到标记为`tails`的地址。
- en: '[Figure 12-13](ch12.xhtml#ch12fig13) shows the machine code that the assembler
    produced for the `b.hi` instruction.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-13](ch12.xhtml#ch12fig13)展示了汇编器为`b.hi`指令生成的机器代码。'
- en: '![Image](../images/pg266_Image_272.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg266_Image_272.jpg)'
- en: '*Figure 12-13: A conditional branch:* b.hi tails'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-13：条件分支：* b.hi tails'
- en: The `tails` label is at relative location `0x38`, which is `0x10` bytes beyond
    the `b.hi` instruction at `0x28`. In [Figure 12-13](ch12.xhtml#ch12fig13), the
    `w_offset` is `0x00004`, or `0x10` bytes. The question is how the assembler knew
    the location of the forward reference to the `tails` label.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`tails`标签位于相对位置`0x38`，比`0x28`处的`b.hi`指令高`0x10`字节。在[图 12-13](ch12.xhtml#ch12fig13)中，`w_offset`是`0x00004`，即`0x10`字节。问题是汇编器是如何知道`tails`标签的前向引用位置的。'
- en: A common way to deal with forward references is to use a *two-pass assembler*,
    which scans the program twice. During the first pass, the assembler creates a
    *local symbol table*, associating each symbol with a numerical value. Those symbols
    defined with a `.equ` directive are entered directly in the table.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 处理前向引用的常用方法是使用*两遍汇编器*，它会扫描程序两遍。在第一次遍历期间，汇编器创建一个*本地符号表*，将每个符号与一个数字值关联起来。通过`.equ`指令定义的符号会直接输入到表中。
- en: For the labeled locations in the code, the assembler needs to determine the
    location of each label relative to the beginning of the module being assembled
    and then enter that value and the label in the table. A separate local symbol
    table is created for each `.text` and `.data` segment in the file.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代码中带标签的位置，汇编器需要确定每个标签相对于正在汇编的模块起始位置的距离，并将该值和标签输入表中。每个`.text`和`.data`段在文件中都会创建一个独立的本地符号表。
- en: 'Here’s the general algorithm for the first pass of a two-pass assembler, which
    generates a local symbol table:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个两遍汇编器第一次遍历的通用算法，它生成一个本地符号表：
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once the local symbol table is created, the assembler does a second pass through
    the source code file. It uses a built-in *opcode table* to determine the machine
    code, and when a symbol is used in an instruction, it looks up the value of the
    symbol in the local symbol table. If it does not find the symbol in the local
    symbol table, it leaves space in the instruction for a number and records the
    symbol and its location in the object file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦本地符号表创建完成，汇编器会对源代码文件进行第二遍扫描。它使用内建的*操作码表*来确定机器代码，当指令中使用符号时，它会在本地符号表中查找符号的值。如果在本地符号表中没有找到该符号，它会在指令中留出空位来填入数字，并将符号及其位置记录在目标文件中。
- en: 'The general algorithm looks like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一般算法如下：
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As an alternative, we could create a *one-pass assembler*. It would need to
    maintain a list of the locations of each forward reference and, when the label
    is found, use the table to go back and fill in the appropriate value.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，我们可以创建一个*单遍汇编器*。它需要维护一个前向引用位置的列表，当找到标签时，使用该表回去填写适当的值。
- en: 'Again, this is a highly simplified overview of the assembly process that is
    intended only to show you the general idea of how an assembler works. [Chapter
    7](ch07.xhtml) in Andrew S. Tanenbaum and Todd Austin’s *Structured Computer Organization*,
    6th edition (Pearson, 2012), has a section that provides more details about the
    assembly process. There is a thorough discussion of the design of assembler programs
    in [Chapter 2](ch02.xhtml) of Leland Beck’s *System Software: An Introduction
    to Systems Programming*, 3rd edition (Pearson, 1997).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是对汇编过程的高度简化概述，旨在展示汇编器工作的大致思路。Andrew S. Tanenbaum和Todd Austin的《*结构化计算机组织*》第6版（Pearson，2012）中的[第7章](ch07.xhtml)提供了有关汇编过程的更多细节。Leland
    Beck的《*系统软件：系统编程导论*》第3版（Pearson，1997）中的[第2章](ch02.xhtml)详细讨论了汇编程序的设计。
- en: Most functions will have function calls, which are references to labels in `.text`
    segments defined in other files that cannot be resolved by the assembler. The
    same is true of any labels in `.data` segments, even if they’re defined in the
    same source code file. I’ll show you the program that resolves these references
    in the next section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数函数会有函数调用，即对其他文件中定义的`.text`段标签的引用，这些引用无法由汇编器解决。`.data`段中的任何标签也是如此，即使它们定义在同一个源代码文件中。接下来的部分将展示一个解决这些引用的程序。
- en: '***The Linker***'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***链接器***'
- en: The job of the linker is to figure out the relative locations of the labels
    in a program so it can enter the offset to each label wherever there is a reference
    to the label. A linker works in much the same way as an assembler, except the
    basic unit is a block of machine code instead of a line of assembly language.
    A typical program comprises many object files, each of which often has more than
    one `.text` segment and may have `.data` segments, all of which must be linked
    together. As with an assembler, two passes can be used to resolve forward references.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器的工作是确定程序中标签的相对位置，以便在引用标签的地方插入该标签的偏移量。链接器的工作方式与汇编器类似，只不过基本单元是机器代码块，而不是一行汇编语言。一个典型的程序由多个目标文件组成，每个文件通常有不止一个`.text`段，并可能有`.data`段，这些段必须被链接在一起。与汇编器一样，可以通过两遍扫描来解决前向引用问题。
- en: An object file created by the assembler includes the size of each segment in
    the file, together with a list of all the global symbols and where they are used
    in the segment. During the first pass, the linker reads each object file and creates
    a *global symbol table* that contains the relative location of each global symbol
    from the beginning of the program. In the second pass, the linker creates an executable
    file that includes all the machine code from the object files with the relative
    location values from the global symbol table plugged into the locations where
    they are referenced.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编器生成的目标文件包含文件中每个段的大小，以及所有全局符号的列表和它们在段中的使用位置。在第一遍扫描中，链接器读取每个目标文件，并创建一个*全局符号表*，该表包含每个全局符号相对于程序起始位置的相对位置。在第二遍扫描中，链接器创建一个可执行文件，该文件包括所有来自目标文件的机器代码，并将全局符号表中的相对位置值插入到引用它们的位置。
- en: This process resolves all the references to names defined in the modules that
    comprise the program, but it will leave unresolved all references to externally
    defined names, such as function or variable names that are defined in the C standard
    library. The linker enters these unresolved references into the *global offset
    table (GOT)*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程解决了所有引用程序中各模块定义的名称的引用，但它会将所有对外部定义名称的引用（如在C标准库中定义的函数或变量名）保持未解决。链接器将这些未解决的引用输入到*全局偏移表（GOT）*中。
- en: 'If the external reference is a function call, the linker also enters this information
    into the *procedure linkage table (PLT)*, along with the location in the machine
    code where the reference is made. You can see how the linker has done this by
    looking at how we wrote a call to a C standard library function in [Listing 12-1](ch12.xhtml#ch12list1):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果外部引用是函数调用，链接器还会将此信息输入到*过程链接表（PLT）*中，并记录引用所在的机器码位置。你可以通过查看我们在[列表12-1](ch12.xhtml#ch12list1)中如何编写调用C标准库函数的代码，来看到链接器是如何做到这一点的：
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using the `objdump` program to look at the contents of the executable file
    for this program, we see what the linker has added:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`objdump`程序查看该程序的可执行文件内容，我们可以看到链接器所做的添加：
- en: '[PRE9]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From the encoding of the `bl` instruction in [Figure 12-11](ch12.xhtml#ch12fig11),
    we see that the `w_offset` is the 26-bit value `0x3ffffab`. There are 4 bytes
    in a word, so this is equal to the 28-bit byte offset of `0xffffeac`. Adding the
    byte offset to the relative address of the instruction gives `0x00007a4` + `0xffffeac`
    = `0x0000650`. (Don’t forget that these are signed integers, so the carry from
    this addition is irrelevant.) This is the offset from this `bl` instruction to
    where the link to `printf` is located in the PLT.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从[图12-11](ch12.xhtml#ch12fig11)中`bl`指令的编码中，我们看到`w_offset`是26位值`0x3ffffab`。一个字有4个字节，所以这等于28位字节偏移`0xffffeac`。将字节偏移加到指令的相对地址上，得到`0x00007a4`
    + `0xffffeac` = `0x0000650`。（别忘了这些是有符号整数，所以这个加法的进位是无关紧要的。）这就是从这个`bl`指令到PLT中`printf`链接位置的偏移。
- en: When the program runs, the operating system also loads the GOT and the PLT for
    the program. During execution, if the program accesses an external variable, the
    operating system loads the library module where the variable is defined and enters
    its relative address in the GOT. When the program calls one of the functions in
    the PLT, if the function has not already been loaded, the operating system loads
    it, inserts its address into the program’s GOT, and adjusts the corresponding
    entry in the PLT accordingly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，操作系统还会加载程序的GOT和PLT。在执行过程中，如果程序访问一个外部变量，操作系统会加载包含该变量定义的库模块，并将其相对地址输入到GOT中。当程序调用PLT中的某个函数时，如果该函数尚未加载，操作系统会加载它，将其地址插入程序的GOT，并相应地调整PLT中的对应条目。
- en: I want to reemphasize that, as with the previous discussion of assemblers, this
    is only a rough overview of how linkers work. If you would like to learn more
    about linkers, I recommend John R. Levine’s *Linkers & Loaders* (Morgan Kaufmann,
    1999).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我想再次强调，正如之前关于汇编程序的讨论一样，这只是链接器工作原理的粗略概述。如果你想深入了解链接器，我推荐John R. Levine的*Linkers
    & Loaders*（摩根·考夫曼出版社，1999年）。
- en: '**What You’ve Learned**'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: '**Machine code** The instruction bit patterns that control the CPU.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**机器码** 控制CPU的指令位模式。'
- en: '**Assembly listing** The machine code corresponding to each instruction in
    a program, optionally generated by the assembler.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**汇编列表** 程序中每条指令对应的机器码，可以由汇编程序生成（可选）。'
- en: '**Registers** The number of the register is encoded in 5 bits.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**寄存器** 寄存器的编号在5个比特位中编码。'
- en: '**Register size** A single bit encodes whether the full 64 bits or the low-order
    32 bits is used.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**寄存器大小** 一个比特编码指示使用的是完整的64位寄存器还是低32位寄存器。'
- en: '**Immediate data** A constant encoded within the instruction.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**立即数** 指令中编码的常量。'
- en: '**Address offset** The distance from the referencing instruction to a memory
    address, which can be encoded within the referencing instruction.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址偏移** 从引用指令到内存地址的距离，可以在引用指令中编码。'
- en: '**Aliases** The assembler can have more than one name for some instructions,
    to better show the intent of using the instruction.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**别名** 汇编程序可能为某些指令提供多个名称，以更好地表达使用该指令的意图。'
- en: '**Assembler** A program that translates assembly language to machine code and
    creates a global symbol table.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**汇编器** 将汇编语言翻译为机器码并创建全局符号表的程序。'
- en: '**Linker** A program that resolves cross-references between the segments in
    the program and creates a procedure linkage table that is used by the operating
    system.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**链接器** 一个程序，用于解决程序中各个段落之间的交叉引用，并创建一个由操作系统使用的过程链接表。'
- en: 'So far, all our programs have used sequential program flow and called subfunctions.
    In the next chapter, we’ll return to programming and you’ll learn about the other
    two necessary program flow constructs: repetition and two-way branching.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的所有程序都使用了顺序程序流并调用了子函数。在下一章，我们将回到编程，你将学习其他两个必要的程序流程结构：重复和双向分支。
