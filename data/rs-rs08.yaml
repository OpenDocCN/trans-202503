- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Asynchronous Programming
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: 'Asynchronous programming is, as the name implies, programming that is not synchronous.
    At a high level, an asynchronous operation is one that executes in the background—the
    program won’t wait for the asynchronous operation to complete but will instead
    continue to the next line of code immediately. If you’re not already familiar
    with asynchronous programming, that definition may feel insufficient as it doesn’t
    actually explain what asynchronous programming *is*. To really understand the
    asynchronous programming model and how it works in Rust, we have to first dig
    into what the alternative is. That is, we need to understand the *synchronous*
    programming model before we can understand the *asynchronous* one. This is important
    in both clarifying the concepts and demonstrating the trade-offs of using asynchronous
    programming: an asynchronous solution is not always the right one! We’ll start
    this chapter by taking a quick journey through what motivates asynchronous programming
    as a concept in the first place; then we’ll dig into how asynchrony in Rust actually
    works under the hood.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程，顾名思义，就是不按同步方式执行的编程。高层次地说，异步操作是在后台执行的——程序不会等待异步操作完成，而是会立即继续执行下一行代码。如果你还不熟悉异步编程，可能会觉得这个定义不够充分，因为它并没有真正解释异步编程*是什么*。为了真正理解异步编程模型以及它在
    Rust 中是如何工作的，我们首先必须了解它的替代模型。也就是说，我们需要理解*同步*编程模型，才能更好地理解*异步*编程模型。这一点很重要，不仅能帮助我们理清概念，还能展示使用异步编程的权衡：异步方案并不总是正确的选择！我们将在本章开始时，快速回顾一下为什么异步编程作为一个概念会被提出；然后，我们将深入探讨
    Rust 中异步操作的实现原理。
- en: What’s the Deal with Asynchrony?
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步操作到底是怎么回事？
- en: Before we get to the details of the synchronous and asynchronous programming
    models, we first need to take a quick look at what your computer is actually doing
    when it runs your programs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解同步和异步编程模型的细节之前，我们首先需要快速了解一下计算机在运行程序时究竟在做什么。
- en: Computers are fast. Really fast. So fast, in fact, that they spend most of their
    time waiting for things to happen. Unless you’re decompressing files, encoding
    audio, or crunching numbers, chances are that your CPU mostly sits idle, waiting
    for operations to complete. It’s waiting for a network packet to arrive, for the
    mouse to move, for the disk to finish writing some bytes, or maybe even just for
    a read from main memory to complete. From the CPU’s perspective, eons go by between
    most such events. When one does occur, the CPU runs a few more instructions, then
    goes back to waiting again. Take a look at your CPU utilization—it’s probably
    somewhere in the low single digits, and that’s likely where it hovers the majority
    of the time.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机很快。真的很快。事实上，它们的速度快到大部分时间都在等待事情发生。除非你在解压文件、编码音频或进行复杂的计算，否则你的 CPU 很可能大部分时间都是空闲的，在等待操作完成。它在等待网络数据包的到达，等待鼠标的移动，等待磁盘写入某些字节，甚至可能只是在等待从主内存中读取的数据完成。从
    CPU 的角度来看，大多数此类事件之间仿佛过了很长时间。当某个事件发生时，CPU 执行一些指令，然后又回到等待状态。看看你的 CPU 使用率——它可能一直徘徊在个位数的低值，这也是大多数时间它的工作状态。
- en: Synchronous Interfaces
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同步接口
- en: 'Synchronous interfaces allow your program (or rather, a single thread in your
    program) to execute only a single operation at a time; each operation has to wait
    for the previous synchronous operation to finish before it gets to run. Most interfaces
    you see in the wild are synchronous: you call them, they go do some stuff, and
    eventually they return when the operation has completed and your program can continue
    from there. The reason for this, as we’ll see later in this chapter, is that making
    an operation asynchronous takes a fair bit of extra machinery. Unless you need
    the benefits of asynchrony, sticking to the synchronous model requires much less
    pomp and circumstance.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 同步接口允许你的程序（或者更准确地说，程序中的单个线程）一次只能执行一个操作；每个操作必须等待前一个同步操作完成后才能运行。大多数你在实际开发中遇到的接口都是同步的：你调用它们，它们做一些事情，最终在操作完成后返回，程序才能继续运行。我们稍后在本章中将看到，这背后的原因是：使操作变为异步需要一些额外的机制。除非你需要异步的好处，否则坚持同步模型会少一些繁琐的步骤和复杂的情况。
- en: Synchronous interfaces hide all this waiting; the application calls a function
    that says “write these bytes to this file,” and some time later, that function
    completes and the next line of code executes. Behind the scenes, what really happens
    is that the operating system queues up a write operation to the disk and then
    puts the application to sleep until the disk reports that it has finished the
    write. The application experiences this as the function taking a long time to
    execute, but in reality it isn’t really executing at all, just waiting.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 同步接口隐藏了所有这些等待；应用程序调用一个函数，要求“将这些字节写入这个文件”，过一段时间后，那个函数完成，下一行代码执行。在幕后，实际上发生的是，操作系统将写操作排队到磁盘，并将应用程序挂起，直到磁盘报告写入完成。应用程序体验到的是该函数执行时间很长，但实际上并没有执行，只是处于等待状态。
- en: 'An interface that performs operations sequentially in this way is also often
    referred to as *blocking*, since the operation in the interface that has to wait
    for some external event to happen in order for it to make progress *blocks* further
    execution until that event happens. Whether you refer to an interface as synchronous
    or blocking, the basic idea is the same: the application does not move on until
    the current operation finishes. While the operation is waiting, so is the application.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式按顺序执行操作的接口通常也被称为*阻塞*，因为接口中的操作必须等待某个外部事件发生，才能继续执行，而这个事件的发生*阻塞*了后续的执行。无论你是称接口为同步还是阻塞，基本的概念是相同的：应用程序不会继续进行，直到当前操作完成。在等待操作时，应用程序也在等待。
- en: Synchronous interfaces are usually considered to be easy to work with and simple
    to reason about, since your code executes just one line at a time. But they also
    allow the application to do only one thing at a time. That means if you want your
    program to wait for either user input or a network packet, you’re out of luck
    unless your operating system provides an operation specifically for that. Similarly,
    even if your application could do some other useful work while the disk is writing
    a file, it doesn’t have that option as the file write operation blocks the execution!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 同步接口通常被认为易于使用且容易推理，因为你的代码一次只执行一行。但它们也只能让应用程序一次执行一项任务。这意味着，如果你希望程序等待用户输入或网络数据包，你就没戏了，除非操作系统提供了专门的操作来处理这种情况。同样，即使你的应用程序在磁盘写文件时可以做一些其他有用的工作，它也没有这个选择，因为文件写操作会阻塞执行！
- en: Multithreading
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多线程
- en: By far the most common solution to allowing concurrent execution is to use *multithreading*.
    In a multithreaded program, each thread is responsible for executing a particular
    independent sequence of blocking operations, and the operating system multiplexes
    among the threads so that if any thread can make progress, progress is made. If
    one thread blocks, some other thread may still be runnable, and so the application
    can continue to do useful work.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，允许并发执行的最常见解决方案是使用*多线程*。在一个多线程程序中，每个线程负责执行一系列独立的阻塞操作，操作系统在各个线程之间进行多路复用，以便如果有线程可以继续执行，就会继续执行。如果某个线程被阻塞，其他线程可能仍然可以运行，因此应用程序可以继续进行有用的工作。
- en: Usually, these threads communicate with each other using a synchronization primitive
    like a lock or a channel so that the application can still coordinate their efforts.
    For example, you might have one thread that waits for user input, one thread that
    waits for network packets, and another thread that waits for either of those threads
    to send a message on a channel shared between all three threads.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些线程通过使用像锁或通道这样的同步原语相互通信，从而使应用程序仍然能够协调它们的工作。例如，你可能会有一个线程等待用户输入，一个线程等待网络数据包，另一个线程等待这两个线程中的任何一个在线程之间共享的通道上发送消息。
- en: Multithreading gives you *concurrency*—the ability to have multiple independent
    operations that can be executed at any one time. It’s up to the system running
    the application (in this case, the operating system) to choose among the threads
    that aren’t blocked and decide which to execute next. If one thread is blocked,
    it can choose to run another one that can make progress instead.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程为你提供了*并发*——能够在任何时刻执行多个独立操作的能力。由运行该应用程序的系统（在本例中是操作系统）决定在没有被阻塞的线程中选择哪个线程执行，并决定接下来执行哪个线程。如果某个线程被阻塞，系统可以选择运行另一个可以继续执行的线程。
- en: Multithreading combined with blocking interfaces gets you quite far, and large
    swaths of production-ready software are built in this way. But this approach is
    not without its shortcomings. First, keeping track of all these threads quickly
    gets cumbersome; if you have to spin up a thread for every concurrent task, including
    simple ones like waiting for keyboard input, the threads add up fast, and so does
    the additional complexity needed to keep track of how all those threads interact,
    communicate, and coordinate.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程结合阻塞接口能够让你走得很远，许多生产级软件都是以这种方式构建的。但是这种方法也有它的缺点。首先，快速跟踪所有这些线程会变得繁琐；如果你必须为每一个并发任务创建一个线程，包括像等待键盘输入这样简单的任务，线程会迅速增加，管理这些线程之间的交互、通信和协调的复杂性也随之增加。
- en: 'Second, switching between threads gets costly the more of them there are. Every
    time one thread stops running and another one starts back up in its place, you
    need to do a round-trip to the operating system scheduler, and that’s not free.
    On some platforms, spawning new threads is also a fairly heavyweight process.
    Applications with high performance needs often mitigate this cost by reusing threads
    and using operating system calls that allow you to block on many related operations,
    but ultimately you are left with the same problem: blocking interfaces require
    that you have as many threads as the number of blocking calls you want to make.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，线程之间的切换成本随着线程数量的增加而增加。每当一个线程停止运行，另一个线程接替运行时，你需要向操作系统调度器做一次回调，而这不是免费的。在某些平台上，创建新线程也是一个相对重量级的过程。高性能需求的应用程序通常通过重用线程和使用允许你在多个相关操作上进行阻塞的操作系统调用来减轻这一成本，但最终你还是会面临同样的问题：阻塞接口要求你有与要进行的阻塞调用数量相同的线程。
- en: 'Finally, threads introduce *parallelism* into your program. The distinction
    between concurrency and parallelism is subtle, but important: concurrency means
    that the execution of your tasks is interleaved, whereas parallelism means that
    multiple tasks are executing at the same time. If you have two tasks, their execution
    expressed in ASCII might look like `_-_-_` (concurrency) versus `=====` (parallelism).
    Multithreading does not necessarily imply parallelism—even though you have many
    threads, you might have only a single core, so only one thread is executing at
    a given time—but the two usually go hand in hand. You can make two threads mutually
    exclusive in their execution by using a `Mutex` or other synchronization primitive,
    but that introduces additional complexity—threads want to run in parallel. And
    while parallelism is often a good thing—who doesn’t want their program to run
    faster on more cores—it also means that your program must handle truly simultaneous
    access to shared data structures. This means moving from `Rc`, `Cell`, and `RefCell`
    to the more powerful but also slower `Arc` and `Mutex`. While you *may* want to
    use the latter types in your concurrent program to enable parallelism, threading
    *forces* you to use them. We’ll look at multithreading in much greater detail
    in Chapter 10.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，线程为你的程序引入了*并行性*。并发性和并行性的区别微妙但重要：并发性意味着你的任务执行是交替进行的，而并行性意味着多个任务同时执行。如果你有两个任务，它们的执行用
    ASCII 表示可能像 `_-_-_`（并发性）与 `=====`（并行性）这样。多线程并不一定意味着并行性——即使你有许多线程，可能只有一个核心，这样只有一个线程在某一时刻执行——但两者通常是密切相关的。你可以通过使用
    `Mutex` 或其他同步原语来使两个线程的执行互斥，但这会引入额外的复杂性——线程希望并行运行。并行性通常是一个好事——谁不希望他们的程序在更多核心上运行得更快呢——但这也意味着你的程序必须处理对共享数据结构的真正并发访问。这意味着从
    `Rc`、`Cell` 和 `RefCell` 转向更强大但也更慢的 `Arc` 和 `Mutex`。虽然你*可能*想在并发程序中使用后者类型来启用并行性，但线程*迫使*你使用它们。我们将在第
    10 章详细探讨多线程。
- en: Asynchronous Interfaces
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步接口
- en: 'Now that we’ve explored synchronous interfaces, we can look at the alternative:
    asynchronous or *nonblocking* interfaces. An asynchronous interface is one that
    may not yield a result straightaway, and may instead indicate that the result
    will be available at some later time. This gives the caller the opportunity to
    do something else in the meantime rather than having to go to sleep until that
    particular operation completes. In Rust parlance, an asynchronous interface is
    a method that returns a `Poll`, as defined in [Listing 8-1](#listing8-1).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了同步接口，接下来可以看看它的替代方案：异步或*非阻塞*接口。异步接口是指可能不会立刻返回结果，而是可能表示结果会在稍后的某个时间可用。这让调用者有机会在此期间做其他事情，而不必等到特定操作完成才“睡眠”。在
    Rust 的术语中，异步接口是返回`Poll`的方法，如[示例 8-1](#listing8-1)所定义。
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 8-1: The core of asynchrony: the “here you are or come back later”
    type'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-1：异步的核心：“你现在就可以得到，或者稍后再来”的类型
- en: '`Poll` usually shows up in the return type of functions whose names start with
    `poll`—these are methods that signal they can attempt an operation without blocking.
    We’ll get into how exactly they do that later in this chapter, but in general
    they attempt to perform as much as they can of the operation before they would
    normally block, and then return. And crucially, they remember where they left
    off so that they can resume execution later when additional progress can again
    be made.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Poll` 通常出现在以 `poll` 开头的函数的返回类型中——这些方法表示它们可以在不阻塞的情况下尝试某个操作。我们将在本章后面详细讨论它们是如何做到这一点的，但一般来说，它们会在通常会阻塞之前尽可能多地执行操作，然后返回。而且关键是，它们会记住它们暂停的位置，以便当有进一步进展时，可以恢复执行。'
- en: These nonblocking functions allow us to easily perform multiple tasks concurrently.
    For example, if you want to read from either the network or the user’s keyboard,
    whichever has an event available first, all you have to do is poll both in a loop
    until one of them returns `Poll::Ready`. No need for any additional threads or
    synchronization!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些非阻塞函数使我们能够轻松地并发执行多个任务。例如，如果你想从网络或用户的键盘中读取数据，哪个先有事件可用，你只需要在循环中轮询两个，直到其中一个返回
    `Poll::Ready`。不需要任何额外的线程或同步！
- en: The word *loop* here should make you a little nervous. You don’t want your program
    to burn through a loop three billion times a second when it may be minutes until
    the next input occurs. In the world of blocking interfaces, this wasn’t a problem
    since the operating system simply put the thread to sleep and then took care of
    waking it up when a relevant event occurred, but how do we avoid burning cycles
    while waiting in this brave new nonblocking world? That’s what much of the remainder
    of this chapter will be about.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的*循环*这个词应该让你有点紧张。你可不希望你的程序每秒执行三十亿次循环，而可能还要等几分钟才有下一个输入发生。在阻塞接口的世界里，这不是问题，因为操作系统会简单地让线程进入休眠，然后在发生相关事件时唤醒它，但在这个全新的非阻塞世界里，我们该如何避免在等待时浪费
    CPU 周期呢？这正是本章其余部分要讲解的内容。
- en: Standardized Polling
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准化轮询
- en: To get to a world where every library can be used in a nonblocking fashion,
    we could have every library author cook up their own `poll` methods, all with
    slightly different names, signatures, and return types—but that would quickly
    get unwieldy. Instead, in Rust, polling is standardized through the `Future` trait.
    A simplified version of `Future` is shown in [Listing 8-2](#listing8-2) (we’ll
    get back to the real one later in this chapter).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现一个可以以非阻塞方式使用每个库的世界，我们可以让每个库的作者编写他们自己的 `poll` 方法，虽然这些方法的名字、签名和返回类型可能略有不同，但那样很快就会变得难以管理。相反，在
    Rust 中，轮询通过 `Future` 特征来标准化。`Future` 的简化版本如[示例 8-2](#listing8-2)所示（我们将在本章后面介绍真正的版本）。
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 8-2: A simplified view of the `Future` trait'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-2：`Future` 特征的简化视图
- en: Types that implement the `Future` trait are known as *futures* and represent
    values that may not be available yet. A future could represent the next time a
    network packet comes in, the next time the mouse cursor moves, or just the point
    at which some amount of time has elapsed. You can read `Future<Output = Foo>`
    as “a type that will produce a `Foo` in the future.” Types like this are often
    referred to in other languages as *promises*—they promise that they will eventually
    yield the indicated type. When a future eventually returns `Poll::Ready(T)`, we
    say that the future *resolves* into a `T`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了 `Future` 特征的类型被称为 *futures*，代表那些可能还不可用的值。一个 future 可能代表下次网络数据包的到来、下次鼠标光标的移动，或者只是某段时间过去的时刻。你可以将
    `Future<Output = Foo>` 理解为“一个将来会生成 `Foo` 类型的类型”。这种类型在其他语言中通常被称为 *promises*——它们承诺最终会返回指定的类型。当一个
    future 最终返回 `Poll::Ready(T)` 时，我们说这个 future *解析* 为 `T`。
- en: With this trait in place, we can generalize the pattern of providing `poll`
    methods. Instead of having methods like `poll_recv` and `poll_keypress`, we can
    have methods like `recv` and `keypress` that both return `impl Future` with an
    appropriate `Output` type. This doesn’t change the fact that you have to poll
    them—we’ll deal with that later—but it does mean that at least there is a standardized
    interface to these kinds of pending values, and we don’t need to use the `poll_`
    prefix everywhere.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个特征，我们可以将提供 `poll` 方法的模式泛化。我们不需要像 `poll_recv` 和 `poll_keypress` 这样的特定方法，而可以使用像
    `recv` 和 `keypress` 这样的方法，它们都会返回 `impl Future` 和适当的 `Output` 类型。这并不改变你必须轮询它们的事实——我们稍后会处理这个问题——但它至少意味着这些挂起值有了标准化的接口，我们不需要到处使用
    `poll_` 前缀。
- en: Ergonomic Futures
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人体工程学未来
- en: Writing a type that implements `Future` in the way I’ve described so far is
    quite a pain. To see why, first take a look at the fairly straightforward asynchronous
    code block in [Listing 8-3](#listing8-3) that simply tries to forward messages
    from the input channel `rx` to the output channel `tx`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以我所描述的方式编写一个实现 `Future` 的类型相当麻烦。为了理解为什么，首先来看一下 [列表 8-3](#listing8-3) 中那个相当简单的异步代码块，它只是尝试将输入通道
    `rx` 中的消息转发到输出通道 `tx`。
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 8-3: Implementing a channel-forwarding future using `async` and `await`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-3：使用 `async` 和 `await` 实现一个通道转发的未来
- en: This code, written using `async` and await syntax, looks very similar to its
    equivalent synchronous code and is easy to read. We simply send each message we
    receive in a loop until there are no more messages, and each `await` point corresponds
    to a place where a synchronous variant might block. Now think about if you instead
    had to express this code by manually implementing the `Future` trait. Since each
    call to `poll` starts at the top of the function, you’d need to package the necessary
    state to continue from the last place the code yielded. The result is fairly grotesque,
    as [Listing 8-4](#listing8-4) demonstrates.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用 `async` 和 await 语法编写，看起来与其同步代码非常相似，且易于阅读。我们只是简单地在一个循环中发送每条接收到的消息，直到没有更多消息，每个
    `await` 点对应一个同步变体可能会阻塞的地方。现在想象一下，如果你必须手动实现 `Future` 特征来表达这段代码会怎样。由于每次调用 `poll`
    都从函数顶部开始，你需要打包必要的状态，以便从上次代码暂停的地方继续执行。结果相当难看，正如 [列表 8-4](#listing8-4) 所展示的那样。
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 8-4: Manually implementing a channel-forwarding future'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-4：手动实现一个通道转发的未来
- en: 'You’ll rarely have to write code like this in Rust anymore, but it gives important
    insight into how things work under the hood, so let’s walk through it. First,
    we define our future type as an `enum` 1, which we’ll use to keep track of what
    we’re currently waiting on. This is a consequence of the fact that when we return
    `Poll::Pending`, the next call to `poll` will start at the top of the function
    again. We need some way to know what we were in the middle of so that we know
    which operation to continue on. Furthermore, we need to keep track of different
    information depending on what we’re doing: if we’re waiting for a `receive` to
    finish, we need to keep that `ReceiveFuture` (the definition of which is not shown
    in this example) so that we can poll it the next time we are polled ourselves,
    and the same goes for `SendFuture`. The `Option`s here might strike you as weird
    too; we’ll get back to those shortly.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你在Rust中很少需要再写这样的代码了，但它提供了关于底层工作原理的重要洞察，所以让我们一起了解一下。首先，我们将未来类型定义为一个`enum`，用来追踪我们当前在等待什么。这是因为当我们返回`Poll::Pending`时，下一次调用`poll`会从函数的顶部重新开始。我们需要某种方式来知道我们当时停在哪里，这样我们才能知道继续进行哪个操作。此外，根据我们正在做的事情，我们还需要跟踪不同的信息：如果我们在等待`receive`完成，我们需要保留那个`ReceiveFuture`（这个定义在本示例中没有显示），这样我们下次被轮询时就能轮询它，`SendFuture`也是一样。这里的`Option`可能也会让你觉得奇怪；我们很快就会解释它们。
- en: When we implement `Future` for `Forward`, we declare its output type as `()`
    2 because this future doesn’t actually return anything. Instead, the future resolves
    (with no result) when it has finished forwarding everything from the input channel
    to the output channel. In a more complete example, the `Output` of our forwarding
    type might be a `Result` so that it could communicate errors from `receive()`
    and `send()` back up the stack to the function that’s polling for the completion
    of the forwarding. But this code is complicated enough already, so we’ll leave
    that for another day.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为`Forward`实现`Future`时，我们将其输出类型声明为`()`，因为这个未来实际上并不返回任何东西。相反，当它完成从输入通道到输出通道的所有转发时，未来就会解析（没有结果）。在一个更完整的示例中，我们的转发类型的`Output`可能是一个`Result`，这样它就可以将来自`receive()`和`send()`的错误信息传递回堆栈中的函数，以便轮询转发的完成。但这段代码已经足够复杂了，我们暂时将这个问题留到以后再说。
- en: When `Forward` is polled, it needs to resume wherever it last left off, which
    we find out by matching on the enum variant currently held in `self` 3. For whichever
    branch we go into, the first step is to poll the future that blocks progress for
    the current operation; if we’re trying to receive, we poll the `ReceiveFuture`,
    and if we’re trying to send, we poll the `SendFuture`. If that call to `poll`
    returns `Poll::Pending`, then we can make no progress, and we return `Poll::Pending`
    ourselves. But if the current future resolves, we have work to do!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Forward`被轮询时，它需要从上次停下的地方恢复，我们通过匹配当前在`self`中持有的枚举变体来找出这一点。无论进入哪个分支，第一步是轮询当前操作阻塞进度的未来；如果我们试图接收，我们就轮询`ReceiveFuture`，如果我们试图发送，我们就轮询`SendFuture`。如果对`poll`的调用返回`Poll::Pending`，那么我们无法取得进展，我们也会返回`Poll::Pending`。但如果当前的未来被解析，我们就有事情要做！
- en: When one of the inner futures resolves, we need to update what the current operation
    is by switching which enum variant is stored in `self`. In order to do so, we
    have to move out of `self` to call `Receiver::receive` or `Sender::send`—but we
    can’t do that because all we have is `&mut self`. So, we store the state we have
    to move in an `Option`, which we move out of with `Option::take` 4. This is silly
    since we’re about to overwrite `self` anyway 5, and hence the `Option`s will always
    be `Some`, but sometimes tricks are needed to make the borrow checker happy.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当其中一个内部的未来解析时，我们需要通过切换`self`中存储的枚举变体来更新当前的操作。为了做到这一点，我们必须从`self`中移出，以调用`Receiver::receive`或`Sender::send`——但是我们不能这样做，因为我们只有`&mut
    self`。因此，我们将必须移出的状态存储在一个`Option`中，我们通过`Option::take`移出它。这看起来有些傻，因为我们即将覆盖`self`，因此这些`Option`总是`Some`，但有时一些技巧是必须的，才能让借用检查器满意。
- en: Finally, if we do make progress, we then poll `self` again 6 so that if we can
    immediately make progress on the pending send or receive, we do so. This is actually
    necessary for correctness when implementing the real `Future` trait, which we’ll
    get back to later, but for now think of this as an optimization.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们确实取得了进展，我们会再次轮询`self`，这样如果我们能立即处理待发送或待接收的操作，就会继续进行。这实际上是实现真实`Future`特质时的必要步骤，稍后我们会回到这个话题，但现在可以把它当作一种优化来理解。
- en: 'We just hand-wrote a *state machine*: a type that has a number of possible
    states and moves between them in response to particular events. This was a fairly
    simple state machine, at that. Imagine having to write code like this for more
    complicated use cases where you have additional intermediate steps!'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚手写了一个 *状态机*：一种具有多个可能状态并根据特定事件在状态之间移动的类型。实际上，这只是一个相当简单的状态机。试想一下，如果你需要为更复杂的用例编写这样的代码，其中还包含额外的中间步骤，会是怎样的一种情况！
- en: Beyond writing the unwieldy state machine, we have to know the types of the
    futures that `Sender::send` and `Receiver::receive` return so that we can store
    them in our type. If those methods instead returned `impl Future`, we’d have no
    way to write out the types for our variants. The `send` and `receive` methods
    also have to take ownership of the sender and the receiver; if they did not, the
    lifetimes of the futures they returned would be tied to the borrow of `self`,
    which would end when we return from `poll`. But that would not work, since we’re
    trying to store those futures *in* `self`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编写笨重的状态机外，我们还必须知道`Sender::send`和`Receiver::receive`返回的 futures 类型，以便我们能够将它们存储在我们的类型中。如果这些方法返回的是`impl
    Future`，我们将无法为我们的变体写出类型。`send`和`receive`方法还必须获取发送者和接收者的所有权；如果没有获取所有权，它们返回的 futures
    的生命周期将与`self`的借用相关联，而当我们从`poll`返回时，生命周期就会结束。但那样是不行的，因为我们要尝试将这些 futures *存储在* `self`中。
- en: Ultimately, this code is hard to write, hard to read, and hard to change. If
    we wanted to add error handling, for example, the code complexity would increase
    significantly. Luckily, there’s a better way!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这段代码既难以编写，也难以阅读，还难以修改。例如，如果我们想添加错误处理，代码的复杂度将显著增加。幸运的是，有一种更好的方法！
- en: async/await
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: async/await
- en: Rust 1.39 gave us the `async` keyword and the closely related `await` postfix
    operator, which we used in the original example in [Listing 8-3](#listing8-3).
    Together, they provide a much more convenient mechanism for writing asynchronous
    state machines like the one in [Listing 8-5](#listing8-5). Specifically, they
    let you write the code in such a way that it doesn’t even look like a state machine!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 1.39为我们引入了`async`关键字和紧密相关的`await`后缀操作符，我们在[清单 8-3](#listing8-3)中的原始示例中使用了它们。它们一起提供了一种更方便的机制，用于编写像[清单
    8-5](#listing8-5)中那样的异步状态机。具体来说，它们让你可以以一种方式编写代码，看起来根本不像是状态机！
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 8-5: Implementing a channel-forwarding future using `async` and `await`,
    repeated from [Listing 8-3](#listing8-3)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-5：使用`async`和`await`实现一个频道转发的 future，重复自[清单 8-3](#listing8-3)
- en: If you don’t have much experience with `async` and `await`, the difference between
    [Listing 8-4](#listing8-4) and [Listing 8-5](#listing8-5) might give you an idea
    of why the Rust community was so excited to see them land. But since this is an
    intermediate book, let’s dive a little deeper to understand just how this short
    segment of code can replace the much longer manual implementation. To do that,
    we first need to talk about *generators*—the mechanism by which `async` and `await`
    are implemented.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对`async`和`await`没有太多经验，[清单 8-4](#listing8-4)和[清单 8-5](#listing8-5)之间的区别可能会让你大致明白为什么Rust社区对它们的出现如此兴奋。但由于这是一本中级书籍，让我们更深入地探讨一下，理解这一小段代码是如何替代更长的手动实现的。为此，我们首先需要谈论一下
    *生成器*——`async`和`await`的实现机制。
- en: Generators
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成器
- en: Briefly described, a generator is a chunk of code with some extra compiler-generated
    bits that enables it to stop, or *yield*, its execution midway through and then
    resume from where it last yielded later on. Take the `forward` function in [Listing
    8-3](#listing8-3), for example. Imagine that it gets to the call to `send`, but
    the channel is currently full. The function can’t make any more progress, but
    it also cannot block (this is nonblocking code, after all), so it needs to return.
    Now suppose the channel eventually clears and we want to proceed with the send.
    If we call `forward` again from the top, it’ll call `next` again and the item
    we previously tried to send will be lost, so that’s no good. Instead, we turn
    `forward` into a generator.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，生成器是一段代码，带有一些额外的由编译器生成的部分，使得它能够在执行过程中暂停，或 *yield*，然后在稍后从上次暂停的地方恢复。以[清单
    8-3](#listing8-3)中的`forward`函数为例。假设它执行到调用`send`时，频道当前已满。函数无法继续执行，但它也不能阻塞（毕竟这是非阻塞代码），因此它需要返回。现在假设频道最终清空，我们希望继续发送。如果我们从头再次调用`forward`，它会再次调用`next`，而我们之前尝试发送的项目会丢失，这样就不好了。相反，我们将`forward`变成一个生成器。
- en: Whenever the `forward` generator cannot make progress anymore, it needs to store
    its current state somewhere so that when its execution eventually resumes, it
    resumes in the right place with the right state. It saves the state through an
    associated data structure that’s generated by the compiler, which contains all
    the state of the generator at a given point in time. A method on that data structure
    (also generated) then allows the generator to resume from its current state, stored
    in `&mut self`, and updates the state again when the generator again cannot make
    progress.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`forward`生成器无法再继续执行时，它需要将当前状态存储在某个地方，以便在执行恢复时，能够在正确的位置和正确的状态下恢复。它通过编译器生成的一个关联数据结构保存状态，该结构包含生成器在某一时刻的所有状态。该数据结构上的一个方法（也是编译器生成的）允许生成器从当前状态（存储在`&mut
    self`中）恢复，并在生成器再次无法继续执行时更新状态。
- en: This “return but allow me to resume later” operation is called *yielding*, which
    effectively means it returns while keeping some extra state on the side. When
    we later want to resume a call to `forward`, we invoke the known entry point into
    the generator (the *resume method*, which is `poll` for `async` generators), and
    the generator inspects the previously stored state in `self` to decide what to
    do next. This is exactly the same thing we did manually in [Listing 8-4](#listing8-4)!
    In other words, the code in [Listing 8-5](#listing8-5) loosely desugars to the
    hypothetical code shown in [Listing 8-6](#listing8-6).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“返回但允许我稍后恢复”的操作称为*yielding*，其有效含义是它在返回的同时保持一些额外的状态。稍后当我们想恢复对`forward`的调用时，我们会调用生成器的已知入口点（即*恢复方法*，对于`async`生成器来说是`poll`），生成器检查之前存储在`self`中的状态来决定下一步做什么。这与我们在[列表8-4](#listing8-4)中手动完成的操作完全相同！换句话说，[列表8-5](#listing8-5)中的代码松散地等价于[列表8-6](#listing8-6)中所示的假设代码。
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 8-6: Desugaring `async`/`await` into a generator'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8-6：将`async`/`await`转化为生成器
- en: At the time of writing, generators are not actually usable in Rust—they are
    only used internally by the compiler to implement `async`/`await`—but that may
    change in the future. Generators come in handy in a number of cases, such as to
    implement iterators without having to carry around a `struct` or to implement
    an `impl Iterator` that figures out how to yield items one at a time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，生成器在Rust中实际上是不可用的——它们仅在编译器内部用于实现`async`/`await`——但这在未来可能会改变。生成器在许多情况下非常有用，例如在不需要携带`struct`的情况下实现迭代器，或者实现一个`impl
    Iterator`，它能够逐个处理生成项。
- en: If you look closely at Listings 8-5 and 8-6, they may seem a little magical
    once you know that every `await` or `yield` is really a return from the function.
    After all, there are several local variables in the function, and it’s not clear
    how they’re restored when we resume later on. This is where the compiler-generated
    part of generators comes into play. The compiler transparently injects code to
    persist those variables into and read them from the generator’s associated data
    structure, rather than the stack, at the time of execution. So if you declare,
    write to, or read from some local variable `a`, you are really operating on something
    akin to `self.a`. Problem solved! It’s all really quite marvelous.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察列表8-5和8-6，你可能会发现一旦知道每个`await`或`yield`实际上是函数的一个返回，你就会觉得它们有些神奇。毕竟，函数中有几个局部变量，且不清楚它们在我们稍后恢复时是如何恢复的。这正是编译器生成的生成器部分发挥作用的地方。编译器透明地注入代码，在执行时将这些变量持久化到生成器的关联数据结构中，而不是栈中。因此，如果你声明、写入或读取某个局部变量`a`，你实际上是在操作类似于`self.a`的东西。问题解决！这一切实际上都非常神奇。
- en: One subtle but important difference between the manual `forward` implementation
    and the `async`/`await` version is that the latter can hold references across
    yield points. This enables functions like `Receiver::next` and `Sender::send`
    in [Listing 8-5](#listing8-5) to take `&mut self` rather than the `self` they
    took in [Listing 8-4](#listing8-4). If we tried to use a `&mut self` receiver
    for these methods in the manual state machine implementation, the borrow checker
    would have no way to enforce that the `Receiver` stored inside `Forward` cannot
    be referenced between when `Receiver::next` is called and when the future it returns
    resolves, and so it would reject the code. Only by moving the `Receiver` into
    the future can we convince the compiler that the `Receiver` is not otherwise accessible.
    Meanwhile, with `async`/`await`, the borrow checker can inspect the code before
    the compiler turns it into a state machine and verify that `rx` is indeed not
    accessed again until after the future is dropped, when the `await` on it returns.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 手动实现的 `forward` 和 `async`/`await` 版本之间有一个微妙但重要的区别，即后者可以跨 `yield` 点持有引用。这使得像[清单
    8-5](#listing8-5)中的 `Receiver::next` 和 `Sender::send` 这样的函数可以使用 `&mut self`，而不是像[清单
    8-4](#listing8-4)中那样使用 `self`。如果我们在手动状态机实现中尝试使用 `&mut self` 的接收器，借用检查器将无法确保 `Receiver`
    存储在 `Forward` 中的实例在 `Receiver::next` 被调用和它返回的 future 解析之间不会被引用，因此它会拒绝这段代码。只有将
    `Receiver` 移动到 future 中，我们才能说服编译器相信 `Receiver` 不会被其他方式访问。与此同时，使用 `async`/`await`
    时，借用检查器可以在编译器将代码转换成状态机之前检查代码，并验证 `rx` 在 future 被丢弃之前确实没有再次被访问，直到 `await` 返回。
- en: Pin and Unpin
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pin 和 Unpin
- en: We’re not quite done. While generators are neat, a challenge arises from the
    technique as I’ve described it so far. In particular, it’s not clear what happens
    if the code in the generator (or, equivalently, the `async` block) takes a reference
    to a local variable. In the code from [Listing 8-5](#listing8-5), the future that
    `rx.next()` returns must necessarily hold a reference to `rx` if a next message
    is not immediately available so that it knows where to try again when the generator
    next resumes. When the generator yields, the future and the reference the future
    contains get stashed away inside the generator. But what now happens if the generator
    is moved? Specifically, look at the code in [Listing 8-7](#listing8-7), which
    calls `forward`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完全完成。虽然生成器很有趣，但从目前为止我描述的技术中会出现一个挑战。特别是，如果生成器中的代码（或者等价地，`async` 块）引用了局部变量，那么到底会发生什么并不明确。在[清单
    8-5](#listing8-5)中的代码中，如果下一个消息不可立即获取，则`rx.next()`返回的 future 必须持有 `rx` 的引用，以便它知道生成器下一次恢复时该从哪里重新开始。当生成器
    `yield` 时，future 和它所包含的引用会被存储在生成器内部。但是如果生成器被移动了，现在会发生什么呢？特别地，看看[清单 8-7](#listing8-7)中的代码，它调用了
    `forward`。
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 8-7: Moving a future after polling it'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-7：轮询之后移动一个 future
- en: The `try_forward` function polls `forward` only once, to forward as many messages
    as possible without blocking. If the receiver may still produce more messages
    (that is, if it returned `Poll::Pending` instead of `Poll::Ready(None)`), those
    messages are deferred to be forwarded at some later time by returning the forwarding
    future to the caller, which may choose to poll again at a time when it sees fit.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`try_forward` 函数只轮询一次 `forward`，以便尽可能多地转发消息而不阻塞。如果接收方可能仍会生成更多消息（即，如果它返回的是 `Poll::Pending`
    而不是 `Poll::Ready(None)`），这些消息会被推迟到稍后转发，通过将转发的 future 返回给调用者，调用者可以选择在合适的时机再次轮询。'
- en: Let’s work through what happens here with what we know about `async` and `await`
    so far. When we poll the `forward` generator, it goes through the `while` loop
    some unknown number of times and eventually returns either `Poll::Ready(())` if
    the receiver ended, or `Poll::Pending` otherwise. If it returns `Poll::Pending`,
    the generator contains a future returned from either `rx.next()` or `tx.send(t)`.
    Those futures both contain a reference to one of the arguments initially provided
    to `forward` (`rx` and `tx`, respectively), which must also be stored in the generator.
    But when `try_forward` returns the entire generator, the fields of the generator
    also move. Thus, `rx` and `tx` no longer reside at the same locations in memory,
    and the references stored in the stashed-away future are no longer pointing to
    the right data!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们结合目前对`async`和`await`的理解，逐步分析这里发生了什么。当我们轮询`forward`生成器时，它会进入`while`循环若干次，最终返回`Poll::Ready(())`，如果接收方已结束，或者返回`Poll::Pending`，否则。如果返回`Poll::Pending`，则生成器包含一个由`rx.next()`或`tx.send(t)`返回的`future`。这两个`future`都包含对最初传递给`forward`的某个参数的引用（分别是`rx`和`tx`），这些引用也必须存储在生成器中。但是，当`try_forward`返回整个生成器时，生成器的字段也会移动。因此，`rx`和`tx`不再位于内存中的相同位置，存储在临时`future`中的引用不再指向正确的数据！
- en: 'What we’ve run into here is a case of a *self-referential* data structure:
    one that holds both data and references to that data. With generators, these self-referential
    structures are very easy to construct, and being unable to support them would
    be a significant blow to ergonomics because it would mean you wouldn’t be able
    to hold references across any yield point. The (ingenious) solution for supporting
    self-referential data structures in Rust comes in the form of the `Pin` type and
    the `Unpin` trait. Very briefly, `Pin` is a wrapper type that prevents the wrapped
    type from being (safely) moved, and `Unpin` is a marker trait that says the implementing
    type *can* be removed safely from a `Pin`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里遇到的是一个*自指*数据结构的案例：一种同时包含数据和对该数据的引用的结构。使用生成器，这些自指结构非常容易构造，不能支持它们将对易用性产生重大打击，因为这意味着你将无法在任何`yield`点之间保持引用。Rust支持自指数据结构的（巧妙的）解决方案是`Pin`类型和`Unpin`特征。简而言之，`Pin`是一个包装类型，它阻止被包装类型（安全地）移动，而`Unpin`是一个标记特征，表示实现该特征的类型*可以*从`Pin`中安全地移除。
- en: Pin
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pin
- en: There’s a lot of nuance to cover here, so let’s start with a concrete use of
    the `Pin` wrapper. [Listing 8-2](#listing8-2) gave you a simplified version of
    the `Future` trait, but we’re now ready to peel back one part of the simplification.
    [Listing 8-8](#listing8-8) shows the `Future` trait somewhat closer to its final
    form.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多细节需要探讨，让我们从`Pin`包装器的一个具体用法开始。[Listing 8-2](#listing8-2)给出了`Future`特征的简化版本，但现在我们准备好揭示简化的部分内容。[Listing
    8-8](#listing8-8)展示了更接近最终形式的`Future`特征。
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 8-8: A less simplified view of the `Future` trait with `Pin`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-8: 带有`Pin`的`Future`特征的较简化视图'
- en: In particular, this definition requires that you call `poll` on `Pin<&mut Self>`.
    Once you have a value behind a `Pin`, that constitutes a contract that that value
    will never move again. This means that you can construct self-references internally
    to your heart’s delight, exactly as you want for generators.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，这个定义要求你在`Pin<&mut Self>`上调用`poll`。一旦你得到了一个`Pin`包装的值，就意味着你与这个值之间的契约：这个值永远不会再移动。这意味着你可以根据需要在内部构造自引用，正如你为生成器所期望的那样。
- en: But how do you get a `Pin` to call `poll`? And how can `Pin` ensure that the
    contained value won’t move? To see how this magic works, let’s look at the definition
    of `std::pin::Pin` and some of its key methods, shown in [Listing 8-9](#listing8-9).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如何让`Pin`调用`poll`呢？`Pin`如何确保包含的值不会移动？要了解这个魔法是如何运作的，我们来看看`std::pin::Pin`的定义和一些关键方法，如[Listing
    8-9](#listing8-9)所示。
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 8-9: `std::pin::Pin` and its key methods'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-9: `std::pin::Pin`及其关键方法'
- en: There’s a lot to unpack here, and we’re going to have to go over the definition
    in [Listing 8-9](#listing8-9) a few times before all the bits make sense, so please
    bear with me.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多内容需要理解，我们需要多次查看[Listing 8-9](#listing8-9)的定义，直到所有细节都能理顺，所以请耐心一点。
- en: First, you’ll notice that `Pin` holds a *pointer type*. That is, rather than
    hold some `T` directly, it holds a type `P` that dereferences through `Deref`
    into `T`. This means that rather than have a `Pin<MyType>`, you’ll have a `Pin<Box<MyType>>`
    or `Pin<Rc<MyType>>` or `Pin<&mut MyType>`. The reason for this design is simple—`Pin`’s
    primary goal is to make sure that once you place a `T` behind a `Pin`, that `T`
    won’t move, as doing so might invalidate self-references stored in the `T`. If
    the `Pin` just held a `T` directly, then simply moving the `Pin` would be enough
    to invalidate that invariant! In the remainder of this section, I’ll refer to
    `P` as the *pointer* type and `T` as the *target* type.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你会注意到`Pin`持有的是*指针类型*。也就是说，它并不是直接持有某个`T`，而是持有一个通过`Deref`解引用到`T`的类型`P`。这意味着，你不会直接拥有一个`Pin<MyType>`，而是会拥有`Pin<Box<MyType>>`、`Pin<Rc<MyType>>`或`Pin<&mut
    MyType>`。这样设计的原因很简单——`Pin`的主要目的是确保一旦你把`T`放在`Pin`后面，`T`就不会移动，因为这样做可能会使存储在`T`中的自引用失效。如果`Pin`直接持有`T`，那么仅仅移动`Pin`就足以使这个不变式失效！在本节的其余部分，我将`P`称为*指针*类型，将`T`称为*目标*类型。
- en: Next, notice that `Pin`’s constructor, `new_unchecked`, is unsafe. This is because
    the compiler has no way to actually check that the pointer type indeed promises
    that the pointed-to (target) type won’t move again. Consider, for example, a variable
    `foo` on the stack. If `Pin`’s constructor were safe, we could do `Pin::new(&mut
    foo)`, call a method that requires `Pin<&mut Self>` (and thus assumes that `Self`
    won’t move again), and then drop the `Pin`. At this point, we could modify `foo`
    as much as we liked, since it is no longer borrowed—including moving it! We could
    then pin it again and call the same method, which would be none the wiser that
    any self-referential pointers it may have constructed the first time around would
    now be invalid.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，注意到`Pin`的构造函数`new_unchecked`是一个不安全的函数。这是因为编译器无法实际检查指针类型是否真的承诺被指向的（目标）类型不会再移动。例如，考虑一个栈上的变量`foo`。如果`Pin`的构造函数是安全的，我们可以执行`Pin::new(&mut
    foo)`，然后调用一个需要`Pin<&mut Self>`的方法（因此假设`Self`不会再移动），接着丢弃`Pin`。此时，我们可以任意修改`foo`，因为它不再被借用——包括移动它！然后我们可以再次将它固定，并调用相同的方法，但该方法并不会察觉任何它可能在第一次调用时构造的自引用指针现在已经无效了。
- en: We then get to the `get_unchecked_mut` method, which gives you a mutable reference
    to the `T` behind the `Pin`’s pointer type. This method is also unsafe, because
    once we give out a `&mut T`, the caller has to promise it won’t use that `&mut
    T` to move the `T` or otherwise invalidate its memory, lest any self-references
    be invalidated. If this method weren’t unsafe, a caller could call a method that
    takes `Pin<&mut Self>` and then call the safe variant of `get_unchecked_mut` on
    two `Pin<&mut _>`s, then use `mem::swap` to swap the values behind the `Pin`.
    If we were to then call a method that takes `Pin<&mut Self>` again on either `Pin`,
    its assumption that the `Self` hasn’t moved would be violated, and any internal
    references it stored would be invalid!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接着是`get_unchecked_mut`方法，它返回一个对`Pin`的指针类型后面的`T`的可变引用。这个方法也是不安全的，因为一旦我们给出了一个`&mut
    T`，调用者必须保证不会使用这个`&mut T`来移动`T`或以其他方式使其内存无效，否则任何自引用都会失效。如果这个方法不是不安全的，调用者可以调用一个接受`Pin<&mut
    Self>`的方法，然后在两个`Pin<&mut _>`上调用`get_unchecked_mut`的安全版本，再使用`mem::swap`交换`Pin`后面的值。如果我们随后再次在任一`Pin`上调用一个接受`Pin<&mut
    Self>`的方法，它会假设`Self`没有移动，但这种假设会被破坏，任何它存储的内部引用都会无效！
- en: Perhaps surprisingly, `Pin<P>` always implements `Deref<Target = T>`, and that
    is entirely safe. The reason for this is that a `&T` does not let you move `T`
    without writing other unsafe code (`UnsafeCell`, for example, as we’ll discuss
    in Chapter 9). This is a good example of why the scope of an unsafe block extends
    beyond just the code it contains. If you wrote some code in one part of the application
    that (unsafely) replaced a `T` behind an `&` using `UnsafeCell`, then it *could*
    be that that `&T` initially came from a `Pin<&mut T>`, and that you have now violated
    the invariant that the `T` behind the `Pin` may never move, even though the place
    where you unsafely replaced the `&T` did not even mention `Pin`!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 或许令人惊讶的是，`Pin<P>`总是实现了`Deref<Target = T>`，而且这是完全安全的。原因在于，`&T`不会让你在没有写其他不安全代码（例如`UnsafeCell`，我们将在第9章讨论）的情况下移动`T`。这是一个很好的例子，说明了为什么不安全代码块的作用范围不仅限于它所包含的代码。如果你在应用程序的某个地方（不安全地）用`UnsafeCell`替换了一个`&`后面的`T`，那么*可能*这个`&T`最初来自一个`Pin<&mut
    T>`，而你现在破坏了`Pin`后面`T`永远不能移动的这个不变式，即使你在不安全地替换`&T`的地方根本没有提到`Pin`！
- en: 'Unpin: The Key to Safe Pinning'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 'Unpin: 安全固定的关键'
- en: 'At this point you might ask: given that getting a mutable reference is unsafe
    anyway, why not have `Pin` hold a `T` directly? That is, rather than require an
    indirection through a pointer type, you could instead make the contract for `get_unchecked_mut`
    that it is only safe to call if you haven’t moved the `Pin`. The answer to that
    question lies in a neat safe use of `Pin` that the pointer design enables. Recall
    that the whole reason we want `Pin` in the first place is so we can have target
    types that may contain references to themselves (like a generator) and give their
    methods a guarantee that the target type hasn’t moved and thus that internal self-references
    remain valid. `Pin` lets us use the type system to enforce that guarantee, which
    is great. But unfortunately, with the design so far, `Pin` is very unwieldy to
    work with. This is because it always requires unsafe code, even if you are working
    with a target type that doesn’t contain any self-references, and so doesn’t care
    whether it’s been moved or not.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，你可能会问：既然获取可变引用本身就不安全，为什么不让`Pin`直接持有`T`呢？也就是说，为什么不通过指针类型间接访问，而是将`get_unchecked_mut`的契约设为：只有在你没有移动`Pin`时调用它才是安全的。这个问题的答案就在于，`Pin`的指针设计允许我们进行一种巧妙的安全使用。回想一下，我们最初需要`Pin`的原因是希望能够使用可能包含自身引用的目标类型（比如生成器），并为其方法提供一个保证，即目标类型未发生移动，从而确保内部的自引用仍然有效。`Pin`使我们能够使用类型系统来强制执行这个保证，这是很棒的。但不幸的是，按目前的设计，`Pin`使用起来非常笨拙。这是因为它总是需要不安全的代码，即使你正在处理一个不包含任何自引用的目标类型，也不关心它是否已被移动。
- en: This is where the marker trait `Unpin` comes into play. An implementation of
    `Unpin` for a type simply asserts that the type is safe to move out of a `Pin`
    when used as a target type. That is, the type promises that it will never use
    any of `Pin`’s guarantees about the referent not moving again when used as a target
    type, and thus those guarantees may be broken. `Unpin` is an auto-trait, like
    `Send` and `Sync`, and so is auto-implemented by the compiler for any type that
    contains only `Unpin` members. Only types that explicitly opt out of `Unpin` (like
    generators) and types that contain those types are `!Unpin`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这时标记特征`Unpin`就发挥作用了。为某个类型实现`Unpin`，简单地声明该类型在作为目标类型时，能够安全地从`Pin`中移出。也就是说，该类型保证在作为目标类型使用时，永远不会使用`Pin`所提供的关于引用对象不再移动的任何保证，因此这些保证可以被打破。`Unpin`是一个自动特征，就像`Send`和`Sync`一样，因此编译器会为任何只包含`Unpin`成员的类型自动实现`Unpin`。只有那些明确选择不实现`Unpin`的类型（比如生成器）以及包含这些类型的类型才是`!Unpin`。
- en: For target types that are `Unpin`, we can provide a much simpler safe interface
    to `Pin`, as shown in [Listing 8-10](#listing8-10).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Unpin`类型的目标，我们可以提供一个更简单的安全接口给`Pin`，正如在[清单 8-10](#listing8-10)中所示。
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 8-10: The safe API to `Pin` for `Unpin` target types'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-10：用于`Unpin`目标类型的安全 API `Pin`
- en: 'To make sense of the safe API in [Listing 8-10](#listing8-10), think about
    the safety requirements of the unsafe methods from [Listing 8-9](#listing8-9):
    the function `Pin::new_unchecked` is unsafe because the caller must promise that
    the referent cannot be moved outside of the `Pin`, and that the implementations
    of `Deref`, `DerefMut`, and `Drop` for the pointer type do not move the referent
    through the reference they receive. Those requirements are there to ensure that
    once we give out a `Pin` to a `T`, we never move that `T` again. But if the `T`
    is `Unpin`, it has declared that it does not care if it is moved even if it was
    previously pinned, so it’s fine if the caller does not satisfy any of those requirements!'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解[清单 8-10](#listing8-10)中的安全 API，可以思考[清单 8-9](#listing8-9)中的不安全方法的安全要求：`Pin::new_unchecked`函数是不安全的，因为调用者必须保证引用对象不能被移出`Pin`，并且指针类型的`Deref`、`DerefMut`和`Drop`的实现不会通过它们接收到的引用移动引用对象。这些要求是为了确保一旦我们将`Pin`交给某个`T`，就不再移动该`T`。但是，如果`T`是`Unpin`，它已经声明自己不关心是否被移动，即使之前它是被固定的，因此如果调用者没有满足这些要求也没问题！
- en: 'Similarly, `get_unchecked_mut` is unsafe because the caller must guarantee
    that it doesn’t move the `T` out of the `&mut T`—but with `T: Unpin`, `T` has
    declared that it’s fine being moved even after being pinned, so that safety requirement
    is no longer important. This means that for `Pin<P> where P::Target: Unpin`, we
    can simply provide safe variants of both those methods (`DerefMut` being the safe
    version of `get_unchecked_mut`). In fact, we can even provide a `Pin::into_inner`
    that simply gives back the owned `P` if the target type is `Unpin`, since the
    `Pin` is essentially irrelevant!'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '类似地，`get_unchecked_mut`是`unsafe`的，因为调用者必须保证它不会将`T`从`&mut T`中移出——但对于`T: Unpin`，`T`已经声明它在被固定后仍然可以被移动，因此这个安全要求不再重要。这意味着对于`Pin<P>
    where P::Target: Unpin`，我们可以简单地提供这两个方法的安全版本（`DerefMut`是`get_unchecked_mut`的安全版本）。事实上，我们甚至可以提供一个`Pin::into_inner`，它会在目标类型是`Unpin`时简单地返回拥有的`P`，因为`Pin`在这种情况下基本上没有意义！'
- en: Ways of Obtaining a Pin
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取 Pin 的方式
- en: 'With our new understanding of `Pin` and `Unpin`, we can now make progress toward
    using the new `Future` definition from [Listing 8-8](#listing8-8) that requires
    `Pin<&mut Self>`. The first step is to construct the required type. If the future
    type is `Unpin`, that step is easy—we just use `Pin::new(&mut future)`. If it
    is not `Unpin`, we can pin the future in one of two main ways: by pinning to the
    heap or pinning to the stack.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们对`Pin`和`Unpin`的新理解，我们现在可以朝着使用需要`Pin<&mut Self>`的新`Future`定义的方向前进，这个定义来自于[列表
    8-8](#listing8-8)。第一步是构造所需的类型。如果未来类型是`Unpin`，那一步很简单——我们只需要使用`Pin::new(&mut future)`。如果它不是`Unpin`，我们可以通过两种主要方式之一将未来固定：通过将它固定到堆上或固定到栈上。
- en: Let’s start with pinning to the heap. The primary contract of `Pin` is that
    once something has been pinned, it cannot move. The pinning API takes care of
    honoring that contract for all methods and traits on `Pin`, so the main role of
    any function that constructs a `Pin` is to ensure that if the `Pin` *itself* moves,
    the referent value does not move too. The easiest way to ensure that is to place
    the referent on the heap, and then place just a pointer to the referent in the
    `Pin`. You can then move the `Pin` to your heart’s delight, but the target will
    remain where it was. This is the rationale behind the (safe) method `Box::pin`,
    which takes a `T` and returns a `Pin<Box<T>>`. There’s no magic to it; it simply
    asserts that `Box` follows the `Pin` constructor, `Deref`, and `Drop` contracts.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将值固定到堆上开始。`Pin`的主要合同是，一旦某个对象被固定，它就不能再移动。固定 API 会确保所有方法和特性都遵守这一合同，因此构造`Pin`的任何函数的主要作用是确保如果`Pin`
    *本身*移动，引用的值也不会移动。确保这一点最简单的方法是将引用的值放在堆上，然后在`Pin`中放置对引用值的指针。你可以随心所欲地移动`Pin`，但是目标值会保持原样。这就是（安全）方法`Box::pin`的逻辑，它接受一个`T`并返回一个`Pin<Box<T>>`。这并没有什么神奇之处；它只是确保`Box`遵循`Pin`构造函数、`Deref`和`Drop`合同。
- en: The other option, pinning to the stack, is a little more involved, and at the
    time of writing requires a smidgen of unsafe code. We have to ensure that the
    pinned value cannot be accessed after the `Pin` with a `&mut` to it has been dropped.
    We accomplish that by shadowing the value as shown in the macro in [Listing 8-11](#listing8-11)
    or by using one of the crates that provide exactly this macro. One day it may
    even make it into the standard library!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是将值固定到栈上，这有点复杂，在撰写时需要一些不安全的代码。我们必须确保在`Pin`与`&mut`引用已被丢弃后，固定的值无法再被访问。我们通过像[列表
    8-11](#listing8-11)中宏所示的那样对值进行遮蔽，或使用提供此类宏的其中一个库来实现这一点。也许有一天它甚至会进入标准库！
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 8-11: Macro for pinning to the stack'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-11：用于将值固定到栈上的宏
- en: 'By taking the name of the variable to pin to the stack, the macro ensures that
    the caller has the value it wants to pin somewhere on the stack already. The shadowing
    of `$var` ensures that the caller cannot drop the `Pin` and continue to use the
    unpinned value (which would breach the `Pin` contract for any target type that’s
    `!Unpin`). By moving the value stored in `$var`, the macro also ensures that the
    caller cannot drop the `$var` binding the macro declarations without also dropping
    the original variable. Specifically, without that line, the caller could write
    (note the extra scope):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过获取要固定到栈上的变量名，宏确保调用者已经在栈上的某个地方有了它想要固定的值。对`$var`的遮蔽确保了调用者无法丢弃`Pin`并继续使用未固定的值（这会违反对任何`!Unpin`目标类型的`Pin`合同）。通过移动存储在`$var`中的值，宏还确保调用者不能在不丢弃原始变量的情况下丢弃绑定宏声明的`$var`。具体来说，如果没有那行代码，调用者可能会写出（请注意额外的作用域）：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we give a pinned instance of `foo` to `poll`, but then we later use a
    `&mut` to `foo` without a `Pin`, which violates the `Pin` contract. With the extra
    reassignment, on the other hand, that code would also move `foo` into the new
    scope, rendering it unusable after the scope ends.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将一个`foo`的固定实例传递给`poll`，但是之后我们又使用了一个`&mut`来传递`foo`，而没有使用`Pin`，这违反了`Pin`契约。另一方面，通过额外的重新赋值，这段代码会将`foo`移动到新的作用域中，使得它在作用域结束后变得不可用。
- en: Pinning on the stack therefore requires unsafe code, unlike `Box::pin`, but
    avoids the extra allocation that `Box` introduces and also works in `no_std` environments.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，栈上的固定操作需要不安全的代码，这与`Box::pin`不同，但避免了`Box`引入的额外分配，并且在`no_std`环境中也能正常工作。
- en: Back to the Future
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 回到未来
- en: We now have our pinned future, and we know what that means. But you may have
    noticed that none of this important pinning stuff shows up in most asynchronous
    code you write with `async` and `await`. And that’s because the compiler hides
    it from you.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了固定的future，并且我们知道这意味着什么。但你可能已经注意到，尽管这些重要的固定操作在大多数你写的异步代码中并没有显现出来——比如使用`async`和`await`，而且这是因为编译器将它们隐藏了。
- en: 'Think back to when we discussed [Listing 8-5](#listing8-5), when I told you
    that `<expr>.await` desugars into something like:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们讨论过的[列表8-5](#listing8-5)，当时我告诉你，`<expr>.await`去糖化成类似于以下内容：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That was an ever-so-slight simplification because, as we’ve seen, you can call
    `Future::poll` only if you have a `Pin<&mut Self>` for the future. The desugaring
    is actually a bit more sophisticated, as shown in [Listing 8-12](#listing8-12).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 那只是一个非常轻微的简化，因为正如我们所看到的，只有当你拥有一个`Pin<&mut Self>`类型的future时，才能调用`Future::poll`。去糖化实际上要复杂一些，如[列表8-12](#listing8-12)所示。
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 8-12: A more accurate desugaring of `<expr>.await`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8-12：`<expr>.await`的更准确的去糖化
- en: The match 1 is a neat shorthand to not only ensure that the expansion remains
    a valid expression, but also move the expression result into a variable that we
    can then pin on the stack. Beyond that, the main new addition is the call to `Pin::new_unchecked`
    2. That call is safe because for the containing async block to be polled, it must
    already be pinned due to the signature of `Future::poll`. And the async block
    was polled for us to reach the call to `Pin::new_unchecked`, so the generator
    state is pinned. Since `pinned` is stored in the generator that corresponds to
    the async block (it must be so that `yield` will resume correctly), we know that
    `pinned` will not move again. Furthermore, `pinned` is not accessible except through
    a `Pin` once we’re in the loop, so no code is able to move out of the value in
    `pinned`. Thus, we meet all the safety requirements of `Pin::new_unchecked`, and
    the code is safe.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配1是一种巧妙的简写，不仅确保扩展保持有效表达式，还将表达式的结果移动到一个变量中，我们可以在栈上对其进行固定。除此之外，主要的新内容是调用了`Pin::new_unchecked`
    2。该调用是安全的，因为为了能够对包含的异步块进行轮询，它必须已经被固定，因为`Future::poll`的签名要求如此。而异步块已经被轮询过，因此我们达到了调用`Pin::new_unchecked`的步骤，所以生成器状态已经被固定。由于`pinned`存储在与异步块对应的生成器中（它必须如此，以确保`yield`能正确恢复），我们知道`pinned`不会再移动。而且，一旦进入循环，`pinned`无法被访问，除非通过`Pin`，所以没有代码能够将值从`pinned`中移出。因此，我们满足了`Pin::new_unchecked`的所有安全要求，代码是安全的。
- en: Going to Sleep
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 睡觉中
- en: We went pretty deep into the weeds with `Pin`, but now that we’re out the other
    side, there is another issue around futures that may have been making your brain
    itch. If a call to `Future::poll` returns `Poll::Pending`, you need something
    to call `poll` again at a later time to check whether you can make progress yet.
    That something is usually called the *executor*. Your executor could be a simple
    loop that polls all the futures you are waiting on until they’ve all returned
    `Poll::Ready`, but that would burn a lot of CPU cycles you could probably have
    used for other, more useful things, like running your web browser. Instead, we
    want the executor to do whatever useful work it can do, and then go to sleep.
    It should stay asleep until one of the futures can make progress, and only then
    wake up to do another pass, before going to sleep again.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经深入探讨了`Pin`，但现在我们已经走出那一段，关于future还有另一个可能让你大脑痒痒的问题。如果`Future::poll`调用返回`Poll::Pending`，你需要某种机制在稍后的时间再次调用`poll`来检查是否可以继续推进。这个机制通常被称为*执行器*。你的执行器可以是一个简单的循环，轮询你等待的所有future，直到它们都返回`Poll::Ready`，但这样会浪费很多CPU周期，而你本可以将它们用于其他更有用的事情，比如运行你的网页浏览器。相反，我们希望执行器做它能做的任何有用工作，然后进入睡眠状态。它应该保持睡眠，直到某个future能够继续推进，只有到那个时候，才会醒来做下一次轮询，再次进入睡眠。
- en: Waking Up
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 醒来
- en: The condition that determines when to check back with a given future varies
    widely. It might be “when a network packet arrives on this port,” “when the mouse
    cursor moves,” “when someone sends on this channel,” “when the CPU receives a
    particular interrupt,” or even “after this much time has passed.” On top of that,
    developers can write their own futures that wrap multiple other futures, and thus,
    they may have several wake-up conditions. Some futures may even introduce their
    own entirely custom wake events.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 决定何时检查给定 future 的条件差异很大。它可能是“当网络包到达此端口时”，“当鼠标光标移动时”，“当有人在此通道上发送时”，“当 CPU 收到特定中断时”，甚至是“经过了这么多时间之后”。此外，开发人员还可以编写自己的
    futures，它们可能会包装多个其他 futures，因此可能有多个唤醒条件。一些 futures 甚至可能引入完全自定义的唤醒事件。
- en: 'To accommodate these many use cases, Rust introduces the notion of a `Waker`:
    a way to wake the executor to signal that progress can be made. The `Waker` is
    what makes the whole machinery around futures work. The executor constructs a
    `Waker` that integrates with the mechanism the executor uses to go to sleep, and
    passes the `Waker` in to any `Future` it polls. How? With the additional parameter
    to `Future::poll` that I’ve hidden from you so far. Sorry about that. [Listing
    8-13](#listing8-13) gives the final and true definition for `Future`—no more lies!'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应这些不同的使用场景，Rust 引入了 `Waker` 的概念：一种唤醒执行器以信号推进的方式。`Waker` 是整个未来（futures）机制能够工作的关键。执行器构造一个与其睡眠机制整合的
    `Waker`，并将该 `Waker` 传递给它轮询的每一个 `Future`。怎么做的？就是通过我之前一直隐藏的 `Future::poll` 的额外参数。抱歉之前没告诉你。[Listing
    8-13](#listing8-13) 给出了 `Future` 的最终和真实定义——没有更多的谎言！
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 8-13: The actual `Future` trait with `Context`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-13：实际的 `Future` trait 和 `Context`
- en: The `&mut Context` contains the `Waker`. The argument is a `Context`, not a
    `Waker` directly, so that we can augment the asynchronous ecosystem with additional
    context for futures should that be deemed necessary.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`&mut Context` 包含了 `Waker`。该参数是一个 `Context`，而不是直接传递一个 `Waker`，这样我们可以在需要时为 futures
    提供额外的上下文，从而扩展异步生态系统。'
- en: The primary method on `Waker` is `wake` (and the by-reference variant `wake_by_ref`),
    which should be called when the future can again make progress. The `wake` method
    takes no arguments, and its effects are entirely defined by the executor that
    constructed the `Waker`. You see, `Waker` is secretly generic over the executor.
    Or, more precisely, whatever constructed the `Waker` gets to dictate what happens
    when `Waker::wake` is called, when a `Waker` is cloned, and when a `Waker` is
    dropped. This all happens through a manually implemented vtable, which functions
    similarly to the dynamic dispatch we discussed way back in Chapter 2.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Waker` 的主要方法是 `wake`（以及按引用变体 `wake_by_ref`），当 future 可以继续推进时应该调用该方法。`wake`
    方法不接受任何参数，其效果完全由构造 `Waker` 的执行器定义。你看，`Waker` 在幕后是对执行器进行泛型化的。或者更准确地说，构造 `Waker`
    的对象决定了当调用 `Waker::wake`、克隆 `Waker` 以及丢弃 `Waker` 时会发生什么。这一切都是通过手动实现的 vtable 来实现的，类似于我们在第二章讨论的动态派发。'
- en: It’s a somewhat involved process to construct a `Waker`, and the mechanics of
    it aren’t all that important for using one, but you can see the building blocks
    in the `RawWakerVTable` type in the standard library. It has a constructor that
    takes the function pointers for `wake` and `wake_by_ref` as well as `Clone` and
    `Drop`. The `RawWakerVTable`, which is usually shared among all of an executor’s
    wakers, is bundled up with a raw pointer intended to hold data specific to each
    `Waker` instance (like which future it’s for) and is turned into a `RawWaker`.
    That is in turn passed to `Waker::from_raw` to produce a safe `Waker` that can
    be passed to `Future::poll`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个 `Waker` 是一个相对复杂的过程，其机制对于使用它并不是特别重要，但你可以在标准库中的 `RawWakerVTable` 类型中看到构建块。它有一个构造函数，接受
    `wake` 和 `wake_by_ref` 的函数指针，以及 `Clone` 和 `Drop`。`RawWakerVTable` 通常在所有执行器的 waker
    之间共享，它与一个原始指针捆绑在一起，该指针用于存储特定于每个 `Waker` 实例的数据（比如它是针对哪个 future），然后转换为一个 `RawWaker`。接着，它被传递到
    `Waker::from_raw` 以生成一个安全的 `Waker`，可以传递给 `Future::poll`。
- en: Fulfilling the Poll Contract
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 履行 Poll 合约
- en: 'So far we’ve skirted around what a future actually does with a `Waker`. The
    idea is fairly simple: if `Future::poll` returns `Poll::Pending`, it is the future’s
    responsibility to ensure that *something* calls `wake` on the provided `Waker`
    when the future is next able to make progress. Most futures uphold this property
    by returning `Poll::Pending` only if some other future also returned `Poll::Pending`;
    in this way, it trivially fulfills the contract of `poll` since the inner future
    must follow that same contract. But there can’t be turtles all the way down. At
    some point, you reach a future that does not poll other futures but instead does
    something like write to a network socket or attempt to receive on a channel. These
    are commonly referred to as *leaf futures* since they have no children. A leaf
    future has no inner future but instead directly represents some resource that
    may not yet be ready to return a result.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经回避了 future 如何使用 `Waker` 的问题。这个概念相当简单：如果 `Future::poll` 返回 `Poll::Pending`，那么
    future 的责任是确保当 future 下次能够进展时，*某些东西* 会调用提供的 `Waker` 的 `wake` 方法。大多数 future 通过仅在其他
    future 也返回 `Poll::Pending` 时才返回 `Poll::Pending` 来遵守这一规则；通过这种方式，它轻松履行了 `poll` 的合同，因为内部的
    future 必须遵循相同的合同。但事情不可能永远这么简单。最终，你会遇到一个不对其他 future 进行轮询的 future，而是做一些像写入网络套接字或尝试从通道接收的操作。这些通常被称为
    *叶子 future*，因为它们没有子 future。叶子 future 没有内部 future，而是直接表示某个可能还未准备好返回结果的资源。
- en: 'Leaf futures typically come in one of two shapes: those that wait for events
    that originate within the same process (like a channel receiver), and those that
    wait for events external to the process (like a TCP packet read). Those that wait
    for internal events all tend to follow the same pattern: store the `Waker` where
    the code that will wake you up can find it, and have that code call `wake` on
    the `Waker` when it generates the relevant event. For example, consider a leaf
    future that has to wait for a message on an in-memory channel. It stores its `Waker`
    inside the part of the channel that is shared between the sender and the receiver
    and then returns `Poll::Pending`. When a sender later comes along and injects
    a message into the channel, it notices the `Waker` left there by the waiting receiver
    and calls `wake` on the `Waker` before returning from `send`. Now the receiver
    is awoken, and the poll contract is upheld.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 叶子 future 通常有两种形态：一种是等待来自同一进程内的事件（比如通道接收器），另一种是等待来自进程外部的事件（比如 TCP 数据包读取）。那些等待内部事件的叶子
    future 都倾向于遵循相同的模式：将 `Waker` 存储在代码中，确保唤醒代码可以找到它，并在生成相关事件时调用 `Waker` 的 `wake` 方法。例如，考虑一个必须等待内存通道中消息的叶子
    future。它将其 `Waker` 存储在通道的发送者和接收者共享的部分，然后返回 `Poll::Pending`。当发送者稍后往通道中注入一条消息时，它会注意到接收者留下的
    `Waker`，并在从 `send` 返回之前调用 `wake` 方法。现在接收者被唤醒，轮询合同得到了遵守。
- en: Leaf futures that deal with external events are more involved, as the code that
    generates the event they’re waiting for knows nothing of futures or wakers. Most
    often the generating code is the operating system kernel, which knows when a disk
    is ready or a timer expires, but it could also be a C library that invokes a callback
    into Rust when an operation completes or some other such external entity. A leaf
    future wrapping an external resource like this could spin up a thread that executes
    a blocking system call (or waits for the C callback) and then use the internal
    waking mechanism, but that would be wasteful; you would spin up a thread every
    time an operation had to wait and be left with lots of single-use threads sitting
    around waiting for things.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 处理外部事件的叶子 future 更为复杂，因为生成它们所等待事件的代码并不了解 future 或 waker。最常见的生成代码是操作系统内核，它知道何时磁盘准备就绪或定时器到期，但它也可能是一个
    C 库，在操作完成时调用回调进入 Rust 或其他类似的外部实体。这样一个包装了外部资源的叶子 future 可能会启动一个执行阻塞系统调用（或等待 C 回调）的线程，然后使用内部唤醒机制，但那样会浪费资源；每次操作需要等待时都会启动一个线程，结果就会有很多只使用一次的线程闲置在那里等待事件。
- en: Instead, executors tend to provide implementations of leaf futures that communicate
    behind the scenes with the executor to arrange for the appropriate interaction
    with the operating system. How exactly this is orchestrated depends on the executor
    and the operating system, but roughly speaking the executor keeps track of all
    the event sources that it should listen for the next time it goes to sleep. When
    a leaf future realizes it must wait for an external event, it updates that executor’s
    state (which it knows about since it’s provided by the executor crate) to include
    that external event source alongside its `Waker`. When the executor can no longer
    make progress, it gathers all of the event sources the various pending leaf futures
    are waiting for and does a big blocking call to the operating system, telling
    it to return when *any* of the resources the leaf futures are waiting on have
    a new event. On Linux, this is usually achieved with the `epoll` system call;
    Windows, the BSDs, macOS, and pretty much every other operating system provide
    similar mechanisms. When that call returns, the executor calls `wake` on all the
    wakers associated with event sources that the operating system reported events
    for, and thus the poll contract is fulfilled.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，执行器通常提供叶子 future 的实现，这些实现与执行器在幕后通信，以安排与操作系统的适当交互。具体如何协调取决于执行器和操作系统，但大致来说，执行器会跟踪所有它应该监听的事件源，以便下次进入休眠时使用。当叶子
    future 意识到必须等待外部事件时，它会更新该执行器的状态（它知道这个状态，因为它由执行器 crate 提供），将外部事件源与其 `Waker` 一起包括在内。当执行器无法继续执行时，它会收集所有正在等待的叶子
    future 的事件源，并进行一次大的阻塞调用，告诉操作系统，当*任何*叶子 future 正在等待的资源有新事件时返回。在 Linux 上，通常通过 `epoll`
    系统调用实现；Windows、BSD、macOS 以及几乎所有其他操作系统也提供类似的机制。当该调用返回时，执行器会对所有与操作系统报告事件的事件源相关联的
    waker 调用 `wake`，从而完成轮询契约。
- en: A knock-on effect of the tight integration between leaf futures and the executor
    is that leaf futures from one executor crate often cannot be used with a different
    executor. Or at least, they cannot be used unless the leaf future’s executor is
    *also* running. When the leaf future goes to store its `Waker` and register the
    event source it’s waiting for, the executor it was built against needs to have
    that state set up and needs to be running so that the event source will actually
    be monitored and `wake` eventually called. There are ways around this, such as
    having leaf futures spawn an executor if one is not already running, but this
    is not always advisable as it means that an application can transparently end
    up with multiple executors running at the same time, which can reduce performance
    and mean you must inspect the state of multiple executors when debugging.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 叶子 future 与执行器之间紧密集成的一个连锁反应是，来自一个执行器 crate 的叶子 future 通常不能与另一个执行器一起使用。或者至少，除非叶子
    future 的执行器*也*在运行，否则无法使用。当叶子 future 要存储其 `Waker` 并注册它正在等待的事件源时，它所构建的执行器需要设置该状态，并且需要运行，以便事件源实际上会被监视，并最终调用
    `wake`。有一些方法可以绕过这个问题，例如在没有执行器运行的情况下让叶子 future 生成一个执行器，但这并不总是可取的，因为这意味着应用程序可能会透明地在同一时间运行多个执行器，这会降低性能，并且在调试时必须检查多个执行器的状态。
- en: 'Library crates that wish to support multiple executors have to be generic over
    their leaf resources. For example, instead of using a particular executor’s ``TcpStream
    or `File` future type, a library can store a generic `T: AsyncRead + AsyncWrite`.
    However, the ecosystem has yet to settle on exactly what these traits should look
    like and which traits are needed, so for the moment it’s fairly difficult to make
    code truly generic over the executor. For example, while `AsyncRead` and `AsyncWrite`
    are somewhat common across the ecosystem (or can be easily adapted if necessary),
    no traits currently exist for running a future in the background (*spawning*,
    which we’ll discuss later) or for representing a timer.``'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '希望支持多个执行器的库 crate 必须在其叶子资源上使用泛型。例如，库可以存储一个泛型的 `T: AsyncRead + AsyncWrite`，而不是使用特定执行器的``TcpStream
    或 `File` future 类型。然而，生态系统尚未确定这些 trait 应该是什么样子以及需要哪些 trait，因此目前很难使代码在执行器上真正具有泛型性。例如，虽然
    `AsyncRead` 和 `AsyncWrite` 在生态系统中有些常见（或者如果需要，可以很容易地进行适配），但目前还没有为在后台运行 future（*生成*，我们稍后将讨论）或表示定时器的
    trait。'
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
