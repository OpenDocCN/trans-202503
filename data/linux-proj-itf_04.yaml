- en: 'Chapter 4. File I/O: The Universal I/O Model'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章 文件I/O：通用I/O模型
- en: We now start to look in earnest at the system call API. Files are a good place
    to start, since they are central to the UNIX philosophy. The focus of this chapter
    is the system calls used for performing file input and output.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在开始认真研究系统调用API。文件是一个很好的起点，因为它们是UNIX哲学的核心。本章的重点是用于执行文件输入和输出的系统调用。
- en: We introduce the concept of a file descriptor, and then look at the system calls
    that constitute the so-called universal I/O model. These are the system calls
    that open and close a file, and read and write data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了文件描述符的概念，接着探讨了构成所谓通用I/O模型的系统调用。这些是打开和关闭文件、读取和写入数据的系统调用。
- en: We focus on I/O on disk files. However, much of the material covered here is
    relevant for later chapters, since the same system calls are used for performing
    I/O on all types of files, such as pipes and terminals.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重点讨论磁盘文件的I/O。然而，这里讨论的许多内容对后续章节也很重要，因为相同的系统调用被用于执行各种类型文件的I/O操作，例如管道和终端。
- en: '[Chapter 5](ch05.html "Chapter 5. File I/O: Further Details") extends the discussion
    in this chapter with further details on file I/O. One other aspect of file I/O,
    buffering, is complex enough to deserve its own chapter. [Chapter 13](ch13.html
    "Chapter 13. File I/O Buffering") covers I/O buffering in the kernel and in the
    *stdio* library.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](ch05.html "第5章. 文件I/O：进一步的细节")扩展了本章的讨论，提供了有关文件I/O的更多细节。文件I/O的另一个方面——缓冲——足够复杂，值得单独成章。[第13章](ch13.html
    "第13章. 文件I/O 缓冲")讨论了内核和*stdio*库中的I/O缓冲。'
- en: Overview
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: All system calls for performing I/O refer to open files using a *file descriptor*,
    a (usually small) nonnegative integer. File descriptors are used to refer to all
    types of open files, including pipes, FIFOs, sockets, terminals, devices, and
    regular files. Each process has its own set of file descriptors.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所有执行I/O的系统调用都是通过*文件描述符*来引用已打开的文件的，文件描述符是一个（通常较小的）非负整数。文件描述符用于引用所有类型的已打开文件，包括管道、FIFO、套接字、终端、设备和常规文件。每个进程都有自己的一组文件描述符。
- en: By convention, most programs expect to be able to use the three standard file
    descriptors listed in [Table 4-1](ch04.html#standard_file_descriptors "Table 4-1. Standard
    file descriptors"). These three descriptors are opened on the program’s behalf
    by the shell, before the program is started. Or, more precisely, the program inherits
    copies of the shell’s file descriptors, and the shell normally operates with these
    three file descriptors always open. (In an interactive shell, these three file
    descriptors normally refer to the terminal under which the shell is running.)
    If I/O redirections are specified on a command line, then the shell ensures that
    the file descriptors are suitably modified before starting the program.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 按惯例，大多数程序期望能够使用[表4-1](ch04.html#standard_file_descriptors "表4-1. 标准文件描述符")中列出的三个标准文件描述符。这三个描述符由shell在程序启动之前代表程序打开。或者，更准确地说，程序继承了shell的文件描述符副本，并且shell通常总是保持这三个文件描述符处于打开状态。（在交互式shell中，这三个文件描述符通常指向shell正在运行的终端。）如果命令行中指定了I/O重定向，则shell确保在启动程序之前，文件描述符被适当修改。
- en: Table 4-1. Standard file descriptors
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-1. 标准文件描述符
- en: '| File descriptor | Purpose | POSIX name | *stdio* stream |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 文件描述符 | 目的 | POSIX名称 | *stdio*流 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | standard input | `STDIN_FILENO` | *stdin* |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 标准输入 | `STDIN_FILENO` | *stdin* |'
- en: '| 1 | standard output | `STDOUT_FILENO` | *stdout* |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 标准输出 | `STDOUT_FILENO` | *stdout* |'
- en: '| 2 | standard error | `STDERR_FILENO` | *stderr* |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 标准错误 | `STDERR_FILENO` | *stderr* |'
- en: When referring to these file descriptors in a program, we can use either the
    numbers (0, 1, or 2) or, preferably, the POSIX standard names defined in `<unistd.h>`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中引用这些文件描述符时，我们可以使用数字（0、1或2），或者最好使用在`<unistd.h>`中定义的POSIX标准名称。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although the variables *stdin*, *stdout*, and *stderr* initially refer to the
    process’s standard input, output, and error, they can be changed to refer to any
    file by using the *freopen()* library function. As part of its operation, *freopen()*
    may change the file descriptor underlying the reopened stream. In other words,
    after an *freopen()* on *stdout*, for example, it is no longer safe to assume
    that the underlying file descriptor is still 1.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管变量*stdin*、*stdout*和*stderr*最初指的是进程的标准输入、输出和错误，但可以通过使用*freopen()*库函数将它们更改为指向任何文件。作为操作的一部分，*freopen()*可能会改变重新打开的流所依赖的文件描述符。换句话说，在对*stdout*进行*freopen()*之后，例如，就不能再安全地假设底层文件描述符仍然是1。
- en: 'The following are the four key system calls for performing file I/O (programming
    languages and software packages typically employ these calls only indirectly,
    via I/O libraries):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是执行文件 I/O 的四个关键系统调用（编程语言和软件包通常仅间接通过 I/O 库使用这些调用）：
- en: '*fd = open (pathname, flags, mode)* opens the file identified by *pathname*,
    returning a file descriptor used to refer to the open file in subsequent calls.
    If the file doesn’t exist, *open()* may create it, depending on the settings of
    the *flags* bit-mask argument. The *flags* argument also specifies whether the
    file is to be opened for reading, writing, or both. The *mode* argument specifies
    the permissions to be placed on the file if it is created by this call. If the
    *open()* call is not being used to create a file, this argument is ignored and
    can be omitted.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*fd = open (pathname, flags, mode)* 打开由 *pathname* 标识的文件，并返回一个文件描述符，用于在后续调用中引用该打开的文件。如果文件不存在，*open()*
    可能会根据 *flags* 参数的设置创建文件。*flags* 参数还指定文件是用于读取、写入还是两者兼有。*mode* 参数指定如果通过此调用创建文件时所赋予的权限。如果
    *open()* 调用不是用于创建文件，则此参数会被忽略，可以省略。'
- en: '*numread = read (fd, buffer, count)* reads at most *count* bytes from the open
    file referred to by *fd* and stores them in *buffer*. The *read()* call returns
    the number of bytes actually read. If no further bytes could be read (i.e., end-of-file
    was encountered), *read()* returns 0.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*numread = read (fd, buffer, count)* 从由 *fd* 引用的打开文件中读取最多 *count* 字节，并将其存储在
    *buffer* 中。*read()* 调用返回实际读取的字节数。如果无法读取更多字节（即遇到文件结束），*read()* 返回 0。'
- en: '*numwritten = write (fd, buffer, count)* writes up to *count* bytes from *buffer*
    to the open file referred to by *fd*. The *write()* call returns the number of
    bytes actually written, which may be less than *count*.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*numwritten = write (fd, buffer, count)* 从 *buffer* 中写入最多 *count* 字节到由 *fd*
    引用的打开文件。*write()* 调用返回实际写入的字节数，这个数可能小于 *count*。'
- en: '*status = close (fd)* is called after all I/O has been completed, in order
    to release the file descriptor *fd* and its associated kernel resources.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*status = close (fd)* 在所有 I/O 操作完成后被调用，用于释放文件描述符 *fd* 及其相关的内核资源。'
- en: Before we launch into the details of these system calls, we provide a short
    demonstration of their use in [Example 4-1](ch04.html#using_i_solidus_o_system_calls
    "Example 4-1. Using I/O system calls"). This program is a simple version of the
    *cp(1)* command. It copies the contents of the existing file named in its first
    command-line argument to the new file named in its second command-line argument.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨这些系统调用的细节之前，我们先提供一个简短的演示，展示它们在 [示例 4-1](ch04.html#using_i_solidus_o_system_calls
    "示例 4-1. 使用 I/O 系统调用") 中的用法。该程序是 *cp(1)* 命令的简化版。它将第一个命令行参数中指定的现有文件的内容复制到第二个命令行参数中指定的新文件中。
- en: 'We can use the program in [Example 4-1](ch04.html#using_i_solidus_o_system_calls
    "Example 4-1. Using I/O system calls") as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下使用 [示例 4-1](ch04.html#using_i_solidus_o_system_calls "示例 4-1. 使用 I/O 系统调用")
    中的程序：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Example 4-1. Using I/O system calls
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-1. 使用 I/O 系统调用
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Universality of I/O
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I/O 的普遍性
- en: 'One of the distinguishing features of the UNIX I/O model is the concept of
    *universality of I/O*. This means that the same four system calls—*open()*, *read()*,
    *write()*, and *close()*—are used to perform I/O on all types of files, including
    devices such as terminals. Consequently, if we write a program using only these
    system calls, that program will work on any type of file. For example, the following
    are all valid uses of the program in [Example 4-1](ch04.html#using_i_solidus_o_system_calls
    "Example 4-1. Using I/O system calls"):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX I/O 模型的一个显著特征是 *I/O 的普遍性* 概念。这意味着相同的四个系统调用——*open()*, *read()*, *write()*,
    和 *close()*——用于对所有类型的文件进行 I/O 操作，包括终端等设备。因此，如果我们仅使用这些系统调用编写程序，那么该程序将能在任何类型的文件上运行。例如，以下是程序在
    [示例 4-1](ch04.html#using_i_solidus_o_system_calls "示例 4-1. 使用 I/O 系统调用") 中的有效用法：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Universality of I/O is achieved by ensuring that each file system and device
    driver implements the same set of I/O system calls. Because details specific to
    the file system or device are handled within the kernel, we can generally ignore
    device-specific factors when writing application programs. When access to specific
    features of a file system or device is required, a program can use the catchall
    *ioctl()* system call ([Operations Outside the Universal I/O Model: *ioctl()*](ch04.html#operations_outside_the_universal_i_solid
    "Operations Outside the Universal I/O Model: ioctl()")), which provides an interface
    to features that fall outside the universal I/O model.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 'I/O 的通用性通过确保每个文件系统和设备驱动程序实现相同的 I/O 系统调用来实现。由于与文件系统或设备相关的细节在内核中处理，我们在编写应用程序时通常可以忽略设备特定的因素。当需要访问文件系统或设备的特定功能时，程序可以使用
    *ioctl()* 系统调用 ([超出通用 I/O 模型的操作: *ioctl()*](ch04.html#operations_outside_the_universal_i_solid
    "超出通用 I/O 模型的操作: ioctl()"))，它提供了对不属于通用 I/O 模型的功能的接口。'
- en: 'Opening a File: *open()*'
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开文件：*open()*
- en: The *open()* system call either opens an existing file or creates and opens
    a new file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*open()* 系统调用可以打开一个已存在的文件，也可以创建并打开一个新文件。'
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns file descriptor on success, or -1 on error
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回文件描述符，出错时返回 -1
- en: The file to be opened is identified by the *pathname* argument. If *pathname*
    is a symbolic link, it is dereferenced. On success, *open()* returns a file descriptor
    that is used to refer to the file in subsequent system calls. If an error occurs,
    *open()* returns -1 and *errno* is set accordingly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开的文件由 *pathname* 参数指定。如果 *pathname* 是符号链接，它将被解除引用。成功时，*open()* 返回一个文件描述符，用于在后续的系统调用中引用该文件。如果发生错误，*open()*
    返回 -1，并相应地设置 *errno*。
- en: The *flags* argument is a bit mask that specifies the *access mode* for the
    file, using one of the constants shown in [Table 4-2](ch04.html#file_access_modes
    "Table 4-2. File access modes").
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*flags* 参数是一个位掩码，指定文件的 *访问模式*，使用 [表 4-2](ch04.html#file_access_modes "表 4-2.
    文件访问模式") 中显示的常量之一。'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Early UNIX implementations used the numbers 0, 1, and 2 instead of the names
    shown in [Table 4-2](ch04.html#file_access_modes "Table 4-2. File access modes").
    Most modern UNIX implementations define these constants to have those values.
    Thus, we can see that `O_RDWR` is not equivalent to `O_RDONLY | O_WRONLY`; the
    latter combination is a logical error.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的 UNIX 实现使用数字 0、1 和 2 来代替 [表 4-2](ch04.html#file_access_modes "表 4-2. 文件访问模式")
    中显示的名称。大多数现代 UNIX 实现定义这些常量，使其具有这些值。因此，我们可以看到，`O_RDWR` 并不等同于 `O_RDONLY | O_WRONLY`；后一种组合是逻辑错误。
- en: When *open()* is used to create a new file, the *mode* bit-mask argument specifies
    the permissions to be placed on the file. (The *mode_t* data type used to type
    *mode* is an integer type specified in SUSv3.) If the *open()* call doesn’t specify
    `O_CREAT`, *mode* can be omitted.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *open()* 用于创建新文件时，*mode* 位掩码参数指定文件的权限。（用于指定 *mode* 的 *mode_t* 数据类型是 SUSv3
    中指定的整数类型。）如果 *open()* 调用没有指定 `O_CREAT`，则 *mode* 可以省略。
- en: Table 4-2. File access modes
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-2. 文件访问模式
- en: '| Access mode | Description |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 访问模式 | 描述 |'
- en: '| --- | --- |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `O_RDONLY` | Open the file for reading only |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `O_RDONLY` | 仅打开文件以供读取 |'
- en: '| `O_WRONLY` | Open the file for writing only |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `O_WRONLY` | 仅打开文件以供写入 |'
- en: '| `O_RDWR` | Open the file for both reading and writing |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `O_RDWR` | 打开文件以进行读写操作 |'
- en: 'We describe file permissions in detail in Section 15.4\. Later, we’ll see that
    the permissions actually placed on a new file depend not just on the *mode* argument,
    but also on the process umask ([The Process File Mode Creation Mask: *umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "The Process File Mode Creation Mask: umask()")) and the (optionally present)
    default access control list ([Default ACLs and File Creation](ch17.html#default_acls_and_file_creation
    "Default ACLs and File Creation")) of the parent directory. In the meantime, we’ll
    just note that the *mode* argument can be specified as a number (typically in
    octal) or, preferably, by ORing (`|`) together zero or more of the bit-mask constants
    listed in [Table 15-4](ch15.html#constants_for_file_permission_bits "Table 15-4. Constants
    for file permission bits"), in [File Permissions](ch15.html#file_permissions "File
    Permissions").'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 15.4 节中详细描述了文件权限。稍后我们将看到，实际设置的新文件权限不仅取决于 *mode* 参数，还取决于进程的 umask（[进程文件模式创建掩码：*umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "进程文件模式创建掩码：umask()")）和（可选存在的）父目录的默认访问控制列表（[默认 ACL 和文件创建](ch17.html#default_acls_and_file_creation
    "默认 ACL 和文件创建")）。在此之前，我们仅需注意，*mode* 参数可以指定为数字（通常是八进制）或更优地，通过将一个或多个位掩码常量按位 OR (`|`)
    来指定，这些常量列在[表 15-4](ch15.html#constants_for_file_permission_bits "表 15-4. 文件权限位的常量")中，见[文件权限](ch15.html#file_permissions
    "文件权限")。
- en: '[Example 4-2](ch04.html#examples_of_the_use_of_open_open_parenth "Example 4-2. Examples
    of the use of open()") shows examples of the use of *open()*, some of which employ
    additional *flags* bits that we describe shortly.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-2](ch04.html#examples_of_the_use_of_open_open_parenth "示例 4-2. *open()*
    使用示例") 展示了 *open()* 的使用示例，其中一些使用了我们稍后会介绍的附加 *flags* 位。'
- en: Example 4-2. Examples of the use of *open()*
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-2. *open()* 使用示例
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: File descriptor number returned by *open()*
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*open()* 返回的文件描述符号'
- en: SUSv3 specifies that if *open()* succeeds, it is guaranteed to use the lowest-numbered
    unused file descriptor for the process. We can use this feature to ensure that
    a file is opened using a particular file descriptor. For example, the following
    sequence ensures that a file is opened using standard input (file descriptor 0).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 规范规定，如果 *open()* 成功，它会保证使用进程中最小的未使用文件描述符。我们可以利用这一特性确保文件通过特定的文件描述符打开。例如，下面的序列确保文件使用标准输入（文件描述符
    0）打开。
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since file descriptor 0 is unused, *open()* is guaranteed to open the file using
    that descriptor. In [Duplicating File Descriptors](ch05.html#duplicating_file_descriptors
    "Duplicating File Descriptors"), we look at the use of *dup2()* and *fcntl()*
    to achieve a similar result, but with more flexible control over the file descriptor
    used. In that section, we also show an example of why it can be useful to control
    the file descriptor on which a file is opened.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件描述符 0 未使用，*open()* 保证使用该描述符打开文件。在[复制文件描述符](ch05.html#duplicating_file_descriptors
    "复制文件描述符")一节中，我们讨论了如何使用 *dup2()* 和 *fcntl()* 来实现类似的结果，但它们提供了对使用的文件描述符的更灵活控制。在这一节中，我们还展示了一个示例，说明为何控制文件打开时所用的文件描述符会是有用的。
- en: The *open() flags* Argument
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*open() flags* 参数'
- en: In some of the example *open()* calls shown in [Example 4-2](ch04.html#examples_of_the_use_of_open_open_parenth
    "Example 4-2. Examples of the use of open()"), we included other bits (`O_CREAT`,
    `O_TRUNC`, and `O_APPEND`) in *flags* in addition to the file access mode. We
    now consider the *flags* argument in more detail. [Table 4-3](ch04.html#values_for_the_flags_argument_of_open_op
    "Table 4-3. Values for the flags argument of open()") summarizes the full set
    of constants that can be bit-wise ORed (`|`) in *flags*. The final column indicates
    which of these constants are standardized in SUSv3 or SUSv4.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 4-2](ch04.html#examples_of_the_use_of_open_open_parenth "示例 4-2. *open()*
    使用示例")中展示的某些 *open()* 调用中，我们在 *flags* 中除了文件访问模式外，还包括了其他位（`O_CREAT`、`O_TRUNC` 和
    `O_APPEND`）。现在我们更详细地考虑 *flags* 参数。[表 4-3](ch04.html#values_for_the_flags_argument_of_open_op
    "表 4-3. *open()* 的 *flags* 参数值") 总结了可以按位 OR (`|`) 在 *flags* 中的所有常量。最后一列指示了哪些常量在
    SUSv3 或 SUSv4 中被标准化。
- en: Table 4-3. Values for the *flags* argument of *open()*
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-3. *open()* 的 *flags* 参数值
- en: '| Flag | Purpose | SUS? |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 目的 | SUS? |'
- en: '| --- | --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `O_RDONLY` | Open for reading only | v3 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `O_RDONLY` | 仅打开进行读取 | v3 |'
- en: '| `O_WRONLY` | Open for writing only | v3 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `O_WRONLY` | 仅打开进行写入 | v3 |'
- en: '| `O_RDWR` | Open for reading and writing | v3 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `O_RDWR` | 允许读写 | v3 |'
- en: '| `O_CLOEXEC` | Set the close-on-exec flag (since Linux 2.6.23) | v4 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `O_CLOEXEC` | 设置执行时关闭标志（自 Linux 2.6.23 起） | v4 |'
- en: '| `O_CREAT` | Create file if it doesn’t already exist | v3 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `O_CREAT` | 如果文件不存在则创建文件 | v3 |'
- en: '| `O_DIRECT` | File I/O bypasses buffer cache |   |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `O_DIRECT` | 文件I/O绕过缓冲区缓存 |   |'
- en: '| `O_DIRECTORY` | Fail if *pathname* is not a directory | v4 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `O_DIRECTORY` | 如果*pathname*不是目录，则失败 | v4 |'
- en: '| `O_EXCL` | With *O_CREAT*: create file exclusively | v3 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `O_EXCL` | 与*O_CREAT*一起使用：排他性创建文件 | v3 |'
- en: '| `O_LARGEFILE` | Used on 32-bit systems to open large files |   |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `O_LARGEFILE` | 用于32位系统打开大文件 |   |'
- en: '| `O_NOATIME` | Don’t update file last access time on *read()* (since Linux
    2.6.8) |   |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `O_NOATIME` | 不更新*read()*的文件最后访问时间（自Linux 2.6.8起） |   |'
- en: '| `O_NOCTTY` | Don’t let *pathname* become the controlling terminal | v3 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `O_NOCTTY` | 不允许*pathname*成为控制终端 | v3 |'
- en: '| `O_NOFOLLOW` | Don’t dereference symbolic links | v4 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `O_NOFOLLOW` | 不跟踪符号链接 | v4 |'
- en: '| `O_TRUNC` | Truncate existing file to zero length | v3 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `O_TRUNC` | 将现有文件截断为零长度 | v3 |'
- en: '| `O_APPEND` | Writes are always appended to end of file | v3 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `O_APPEND` | 写入总是附加到文件末尾 | v3 |'
- en: '| `O_ASYNC` | Generate a signal when I/O is possible |   |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `O_ASYNC` | 当I/O操作可用时生成信号 |   |'
- en: '| `O_DSYNC` | Provide synchronized I/O data integrity (since Linux 2.6.33)
    | v3 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `O_DSYNC` | 提供同步I/O数据完整性（自Linux 2.6.33起） | v3 |'
- en: '| `O_NONBLOCK` | Open in nonblocking mode | v3 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `O_NONBLOCK` | 以非阻塞模式打开 | v3 |'
- en: '| `O_SYNC` | Make file writes synchronous | v3 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `O_SYNC` | 使文件写入同步 | v3 |'
- en: 'The constants in [Table 4-3](ch04.html#values_for_the_flags_argument_of_open_op
    "Table 4-3. Values for the flags argument of open()") are divided into the following
    groups:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格4-3](ch04.html#values_for_the_flags_argument_of_open_op "Table 4-3. Values
    for the flags argument of open()")中的常量分为以下几组：'
- en: '*File access mode flags*: These are the `O_RDONLY`, `O_WRONLY`, and `O_RDWR`
    flags described earlier. Only one of these values should be specified in *flags*.
    The access mode can be retrieved using the *fcntl()* `F_GETFL` operation ([Open
    File Status Flags](ch05.html#open_file_status_flags "Open File Status Flags")).'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件访问模式标志*：这些是之前描述的`O_RDONLY`、`O_WRONLY`和`O_RDWR`标志。在*flags*中只能指定其中一个值。访问模式可以使用*fcntl()*的`F_GETFL`操作来获取（[打开文件状态标志](ch05.html#open_file_status_flags
    "Open File Status Flags")）。'
- en: '*File creation flags*: These are the flags shown in the second part of [Table 4-3](ch04.html#values_for_the_flags_argument_of_open_op
    "Table 4-3. Values for the flags argument of open()"). They control various aspects
    of the behavior of the *open()* call, as well as options for subsequent I/O operations.
    These flags can’t be retrieved or changed.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件创建标志*：这些是[表格4-3](ch04.html#values_for_the_flags_argument_of_open_op "Table
    4-3. Values for the flags argument of open()")中第二部分所示的标志。它们控制*open()*调用的各种行为，以及后续I/O操作的选项。这些标志不能被检索或更改。'
- en: '*Open file status flags*: These are the remaining flags in [Table 4-3](ch04.html#values_for_the_flags_argument_of_open_op
    "Table 4-3. Values for the flags argument of open()"). They can be retrieved and
    modified using the *fcntl()* `F_GETFL` and `F_SETFL` operations ([Open File Status
    Flags](ch05.html#open_file_status_flags "Open File Status Flags")). These flags
    are sometimes simply called the *file status flags*.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*打开文件状态标志*：这些是[表格4-3](ch04.html#values_for_the_flags_argument_of_open_op "Table
    4-3. Values for the flags argument of open()")中其余的标志。可以使用*fcntl()*的`F_GETFL`和`F_SETFL`操作来获取和修改它们（[打开文件状态标志](ch05.html#open_file_status_flags
    "Open File Status Flags")）。这些标志有时也称为*文件状态标志*。'
- en: Note
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Since kernel 2.6.22, the Linux-specific files in the directory `/proc/`*PID*`/fdinfo`
    can be read to obtain information about the file descriptors of any process on
    the system. There is one file in this directory for each of the process’s open
    file descriptors, with a name that matches the number of the descriptor. The *pos*
    field in this file shows the current file offset ([Changing the File Offset: *lseek()*](ch04.html#changing_the_file_offset_colon_lseek_ope
    "Changing the File Offset: lseek()")). The *flags* field is an octal number that
    shows the file access mode flags and open file status flags. (To decode this number,
    we need to look at the numeric values of these flags in the C library header files.)'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '自内核版本2.6.22起，可以通过读取目录`/proc/`*PID*`/fdinfo`中的Linux特定文件来获取系统上任何进程的文件描述符信息。该目录中每个文件都代表进程的一个打开的文件描述符，文件名与描述符的编号相匹配。该文件中的*pos*字段显示当前文件偏移量（[更改文件偏移量：*lseek()*](ch04.html#changing_the_file_offset_colon_lseek_ope
    "Changing the File Offset: lseek()")）。*flags*字段是一个八进制数字，显示文件访问模式标志和打开文件状态标志。（要解码此数字，我们需要查看C库头文件中这些标志的数值。）'
- en: 'Details for the *flags* constants are as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是*flags*常量的详细信息：
- en: '`O_APPEND`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`O_APPEND`'
- en: Writes are always appended to the end of the file. We discuss the significance
    of this flag in Section 5.1.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 写入操作始终附加到文件末尾。我们将在第5.1节讨论这个标志的意义。
- en: '`O_ASYNC`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`O_ASYNC`'
- en: Generate a signal when I/O becomes possible on the file descriptor returned
    by *open()*. This feature, termed *signal-driven I/O*, is available only for certain
    file types, such as terminals, FIFOs, and sockets. (The `O_ASYNC` flag is not
    specified in SUSv3; however, it, or the older synonym, `FASYNC`, is found on most
    UNIX implementations.) On Linux, specifying the `O_ASYNC` flag when calling *open()*
    has no effect. To enable signal-driven I/O, we must instead set this flag using
    the *fcntl()* `F_SETFL` operation ([Open File Status Flags](ch05.html#open_file_status_flags
    "Open File Status Flags")). (Several other UNIX implementations behave similarly.)
    Refer to [Signal-Driven I/O](ch63.html#signal-driven_i_solidus_o "Signal-Driven
    I/O") for more information about the `O_ASYNC` flag.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件描述符上变得可进行 I/O 操作时，生成信号。这种被称为*信号驱动 I/O*的功能仅适用于某些文件类型，例如终端、FIFO 和套接字。（`O_ASYNC`标志在SUSv3中未被指定；然而，它或其较老的同义词`FASYNC`在大多数
    UNIX 实现中都有。）在 Linux 上，当调用*open()*时指定`O_ASYNC`标志没有效果。要启用信号驱动 I/O，我们必须改为使用*fcntl()*的`F_SETFL`操作设置此标志（[打开文件状态标志](ch05.html#open_file_status_flags
    "打开文件状态标志")）。 （其他几个 UNIX 实现的行为也类似。）有关`O_ASYNC`标志的更多信息，请参见[信号驱动 I/O](ch63.html#signal-driven_i_solidus_o
    "信号驱动I/O")。
- en: '`O_CLOEXEC` (since Linux 2.6.23)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`O_CLOEXEC`（自 Linux 2.6.23 起）'
- en: Enable the close-on-exec flag (`FD_CLOEXEC`) for the new file descriptor. We
    describe the `FD_CLOEXEC` flag in Section 27.4\. Using the `O_CLOEXEC` flag allows
    a program to avoid additional *fcntl()* `F_GETFD` and `F_SETFD` operations to
    set the close-on-exec flag. It is also necessary in multithreaded programs to
    avoid the race conditions that could occur using the latter technique. These races
    can occur when one thread opens a file descriptor and then tries to mark it close-on-exec
    at the same time as another thread does a *fork()* and then an *exec()* of an
    arbitrary program. (Suppose that the second thread manages to both *fork()* and
    *exec()* between the time the first thread opens the file descriptor and uses
    *fcntl()* to set the close-on-exec flag.) Such races could result in open file
    descriptors being unintentionally passed to unsafe programs. (We say more about
    race conditions in Section 5.1.)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为新的文件描述符启用关闭执行标志（`FD_CLOEXEC`）。我们在第27.4节描述了`FD_CLOEXEC`标志。使用`O_CLOEXEC`标志可以使程序避免执行额外的*fcntl()*
    `F_GETFD`和`F_SETFD`操作来设置关闭执行标志。在多线程程序中，这也是必需的，以避免使用后者技术时可能发生的竞争条件。这些竞争可能发生在一个线程打开文件描述符后，试图同时标记它为关闭执行，而另一个线程执行*fork()*并随后执行任意程序的*exec()*。
    （假设第二个线程在第一个线程打开文件描述符并使用*fcntl()*设置关闭执行标志的时间之间成功执行了*fork()*和*exec()*。）这种竞争可能导致打开的文件描述符被意外传递给不安全的程序。（我们在第5.1节中将更多地讨论竞争条件。）
- en: '`O_CREAT`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`O_CREAT`'
- en: If the file doesn’t already exist, it is created as a new, empty file. This
    flag is effective even if the file is being opened only for reading. If we specify
    `O_CREAT`, then we must supply a *mode* argument in the *open()* call; otherwise,
    the permissions of the new file will be set to some random value from the stack.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件尚不存在，则会创建一个新的空文件。即使该文件仅用于读取，此标志也有效。如果我们指定`O_CREAT`，则必须在*open()*调用中提供*mode*参数；否则，新文件的权限将被设置为栈中的某个随机值。
- en: '`O_DIRECT`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`O_DIRECT`'
- en: Allow file I/O to bypass the buffer cache. This feature is described in Section
    13.6\. The `_GNU_SOURCE` feature test macro must be defined in order to make this
    constant definition available from `<fcntl.h>`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 允许文件 I/O 绕过缓冲区缓存。此功能在第13.6节中描述。必须定义`_GNU_SOURCE`特性测试宏，以使此常量定义在`<fcntl.h>`中可用。
- en: '`O_DIRECTORY`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`O_DIRECTORY`'
- en: 'Return an error (*errno* equals `ENOTDIR`) if *pathname* is not a directory.
    This flag is an extension designed specifically for implementing *opendir()* ([Reading
    Directories: *opendir()* and *readdir()*](ch18.html#reading_directories_colon_opendir_open_p
    "Reading Directories: opendir() and readdir()")). The `_GNU_SOURCE` feature test
    macro must be defined in order to make this constant definition available from
    `<fcntl.h>`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*pathname*不是目录，则返回错误（*errno* 等于 `ENOTDIR`）。此标志是专门为实现*opendir()*（[读取目录：*opendir()*和*readdir()*](ch18.html#reading_directories_colon_opendir_open_p
    "读取目录：opendir()和readdir()")）而设计的扩展。必须定义`_GNU_SOURCE`特性测试宏，以使此常量定义在`<fcntl.h>`中可用。
- en: '`O_DSYNC` (since Linux 2.6.33)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`O_DSYNC`（自 Linux 2.6.33 起）'
- en: Perform file writes according to the requirements of synchronized I/O data integrity
    completion. See the discussion of kernel I/O buffering in Section 13.3.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 根据同步 I/O 数据完整性完成的要求执行文件写入。有关内核 I/O 缓冲的讨论，请参见第 13.3 节。
- en: '`O_EXCL`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`O_EXCL`'
- en: This flag is used in conjunction with `O_CREAT` to indicate that if the file
    already exists, it should not be opened; instead, *open()* should fail, with *errno*
    set to `EEXIST`. In other words, this flag allows the caller to ensure that it
    is the process creating the file. The check for existence and the creation of
    the file are performed *atomically*. We discuss the concept of atomicity in Section
    5.1\. When both `O_CREAT` and `O_EXCL` are specified in *flags*, *open()* fails
    (with the error `EEXIST`) if *pathname* is a symbolic link. SUSv3 requires this
    behavior so that a privileged application can create a file in a known location
    without there being a possibility that a symbolic link would cause the file to
    be created in a different location (e.g., a system directory), which would have
    security implications.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该标志与 `O_CREAT` 一起使用，表示如果文件已存在，则不应打开文件；相反，*open()* 应该失败，并将 *errno* 设置为 `EEXIST`。换句话说，该标志允许调用者确保它是创建文件的进程。检查文件是否存在和创建文件的操作是
    *原子性* 执行的。我们在第 5.1 节中讨论了原子性的概念。当同时指定 `O_CREAT` 和 `O_EXCL` 时，如果 *pathname* 是符号链接，*open()*
    会失败（错误为 `EEXIST`）。SUSv3 要求这种行为，以便特权应用程序可以在已知位置创建文件，而不会因为符号链接导致文件在不同位置（例如系统目录）创建，这可能带来安全隐患。
- en: '`O_LARGEFILE`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`O_LARGEFILE`'
- en: Open the file with large file support. This flag is used on 32-bit systems in
    order to work with large files. Although it is not specified in SUSv3, the `O_LARGEFILE`
    flag is found on several other UNIX implementations. On 64-bit Linux implementations
    such as Alpha and IA-64, this flag has no effect. See [I/O on Large Files](ch05.html#i_solidus_o_on_large_files
    "I/O on Large Files") for more information.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 打开支持大文件的文件。该标志用于 32 位系统，以便处理大文件。尽管在 SUSv3 中没有规定，但在其他几个 UNIX 实现中可以找到 `O_LARGEFILE`
    标志。在 Alpha 和 IA-64 等 64 位 Linux 实现中，该标志没有任何作用。有关更多信息，请参见[大文件 I/O](ch05.html#i_solidus_o_on_large_files
    "大文件 I/O")。
- en: '`O_NOATIME` (since Linux 2.6.8)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`O_NOATIME`（自 Linux 2.6.8 起）'
- en: 'Don’t update the file last access time (the *st_atime* field described in [Retrieving
    File Information: *stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "Retrieving File Information: stat()")) when reading from this file. To use this
    flag, the effective user ID of the calling process must match the owner of the
    file, or the process must be privileged (`CAP_FOWNER`); otherwise, *open()* fails
    with the error `EPERM`. (In reality, for an unprivileged process, it is the process’s
    file-system user ID, rather than its effective user ID, that must match the user
    ID of the file when opening a file with the `O_NOATIME` flag, as described in
    Section 9.5.) This flag is a nonstandard Linux extension. To expose its definition
    from `<fcntl.h>`, we must define the `_GNU_SOURCE` feature test macro. The `O_NOATIME`
    flag is intended for use by indexing and backup programs. Its use can significantly
    reduce the amount of disk activity, because repeated disk seeks back and forth
    across the disk are not required to read the contents of a file and to update
    the last access time in the file’s i-node ([I-nodes](ch14.html#i-nodes "I-nodes")).
    Functionality similar to `O_NOATIME` is available using the `MS_NOATIME` *mount()*
    flag ([Mounting a File System: *mount()*](ch14.html#mounting_a_file_system_colon_mount_open
    "Mounting a File System: mount()")) and the `FS_NOATIME_FL` flag ([I-node Flags
    (*ext2* Extended File Attributes)](ch15.html#i-node_flags_open_parenthesis_ext2_exten
    "I-node Flags (ext2 Extended File Attributes)")).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 读取该文件时，不更新文件的最后访问时间（在[检索文件信息：*stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "检索文件信息：stat()")中描述的 *st_atime* 字段）。要使用此标志，调用进程的有效用户 ID 必须与文件的所有者匹配，或者进程必须具有特权（`CAP_FOWNER`）；否则，*open()*
    会因错误 `EPERM` 而失败。（实际上，对于非特权进程，当使用 `O_NOATIME` 标志打开文件时，必须匹配文件的用户 ID，而不是有效用户 ID，如第
    9.5 节所述）。该标志是非标准的 Linux 扩展。为了从 `<fcntl.h>` 中暴露其定义，必须定义 `_GNU_SOURCE` 特性测试宏。`O_NOATIME`
    标志旨在由索引和备份程序使用。使用该标志可以显著减少磁盘活动，因为读取文件内容并更新文件的 i-node 中的最后访问时间时，不需要反复在磁盘上进行寻道操作（即不需要来回读取磁盘）。
- en: '`O_NOCTTY`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`O_NOCTTY`'
- en: If the file being opened is a terminal device, prevent it from becoming the
    controlling terminal. Controlling terminals are discussed in Section 34.4\. If
    the file being opened is not a terminal, this flag has no effect.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在打开的文件是一个终端设备，防止它成为控制终端。控制终端在第 34.4 节中讨论。如果打开的文件不是终端，这个标志没有效果。
- en: '`O_NOFOLLOW`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`O_NOFOLLOW`'
- en: Normally, *open()* dereferences *pathname* if it is a symbolic link. However,
    if the `O_NOFOLLOW` flag is specified, then *open()* fails (with *errno* set to
    `ELOOP`) if *pathname* is a symbolic link. This flag is useful, especially in
    privileged programs, for ensuring that *open()* doesn’t dereference a symbolic
    link. To expose the definition of this flag from `<fcntl.h>`, we must define the
    `_GNU_SOURCE` feature test macro.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，*open()* 会取消引用 *pathname*，如果它是符号链接。然而，如果指定了 `O_NOFOLLOW` 标志，则如果 *pathname*
    是符号链接，*open()* 将失败（并将 *errno* 设置为 `ELOOP`）。这个标志特别在特权程序中非常有用，确保 *open()* 不会取消引用符号链接。为了暴露这个标志的定义，必须定义
    `_GNU_SOURCE` 特性测试宏。
- en: '`O_NONBLOCK`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`O_NONBLOCK`'
- en: Open the file in nonblocking mode. See Section 5.9.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以非阻塞模式打开文件。请参见第 5.9 节。
- en: '`O_SYNC`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`O_SYNC`'
- en: Open the file for synchronous I/O. See the discussion of kernel I/O buffering
    in Section 13.3.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以同步 I/O 模式打开文件。请参见第 13.3 节关于内核 I/O 缓冲的讨论。
- en: '`O_TRUNC`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`O_TRUNC`'
- en: If the file already exists and is a regular file, then truncate it to zero length,
    destroying any existing data. On Linux, truncation occurs whether the file is
    being opened for reading or writing (in both cases, we must have write permission
    on the file). SUSv3 leaves the combination of `O_RDONLY` and `O_TRUNC` unspecified,
    but most other UNIX implementations behave in the same way as Linux.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件已经存在并且是一个常规文件，则将其截断为零长度，销毁任何现有数据。在 Linux 上，无论文件是以读取还是写入模式打开，都会发生截断（在两种情况下，我们必须对文件具有写权限）。SUSv3
    未指定 `O_RDONLY` 和 `O_TRUNC` 的组合，但大多数其他 UNIX 实现与 Linux 行为相同。
- en: Errors from *open()*
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*open()* 函数的错误'
- en: 'If an error occurs while trying to open the file, *open()* returns -1, and
    *errno* identifies the cause of the error. The following are some possible errors
    that can occur (in addition to those already noted when describing the *flags*
    argument above):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试打开文件时发生错误，*open()* 将返回 -1，*errno* 标识错误的原因。以下是一些可能发生的错误（除了上述描述 *flags* 参数时已提到的错误）：
- en: '`EACCES`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`EACCES`'
- en: The file permissions don’t allow the calling process to open the file in the
    mode specified by *flags*. Alternatively, because of directory permissions, the
    file could not be accessed, or the file did not exist and could not be created.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 文件权限不允许调用进程以由 *flags* 指定的模式打开该文件。或者，由于目录权限，文件无法访问，或文件不存在且无法创建。
- en: '`EISDIR`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`EISDIR`'
- en: The specified file is a directory, and the caller attempted to open it for writing.
    This isn’t allowed. (On the other hand, there are occasions when it can be useful
    to open a directory for reading. We consider an example in [Operating Relative
    to a Directory File Descriptor](ch18.html#operating_relative_to_a_directory_file_d
    "Operating Relative to a Directory File Descriptor").)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 指定的文件是一个目录，且调用者尝试以写入模式打开它。这是不允许的。（另一方面，有时打开目录进行读取是有用的。我们在[相对于目录文件描述符的操作](ch18.html#operating_relative_to_a_directory_file_d
    "相对于目录文件描述符的操作")中讨论了一个例子。）
- en: '`EMFILE`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`EMFILE`'
- en: The process resource limit on the number of open file descriptors has been reached
    (`RLIMIT_NOFILE`, described in [Details of Specific Resource Limits](ch36.html#details_of_specific_resource_limits
    "Details of Specific Resource Limits")).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 已达到打开文件描述符的进程资源限制（`RLIMIT_NOFILE`，详见[特定资源限制的详细信息](ch36.html#details_of_specific_resource_limits
    "特定资源限制的详细信息")）。
- en: '`ENFILE`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENFILE`'
- en: The system-wide limit on the number of open files has been reached.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 系统范围内的打开文件数限制已达到。
- en: '`ENOENT`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENOENT`'
- en: The specified file doesn’t exist, and `O_CREAT` was not specified, or `O_CREAT`
    was specified, and one of the directories in *pathname* doesn’t exist or is a
    symbolic link pointing to a nonexistent pathname (a dangling link).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 指定的文件不存在，并且未指定 `O_CREAT`，或者指定了 `O_CREAT`，但 *pathname* 中的某个目录不存在，或是指向不存在路径的符号链接（悬空链接）。
- en: '`EROFS`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`EROFS`'
- en: The specified file is on a read-only file system and the caller tried to open
    it for writing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 指定的文件位于只读文件系统上，调用者尝试以写入模式打开它。
- en: '`ETXTBSY`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`ETXTBSY`'
- en: The specified file is an executable file (a program) that is currently executing.
    It is not permitted to modify (i.e., open for writing) the executable file associated
    with a running program. (We must first terminate the program in order to be able
    to modify the executable file.)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 指定的文件是一个可执行文件（程序），且该程序当前正在执行。不能修改（即，不能以写入方式打开）与正在运行的程序相关联的可执行文件。（我们必须首先终止程序，才能修改可执行文件。）
- en: 'When we later describe other system calls or library functions, we generally
    won’t list the range of possible errors that may occur in the above fashion. (Such
    a list can be found in the corresponding manual page for each system call or library
    function.) We do so here for two reasons. One of these is that *open()* is the
    first system call that we describe in detail, and the above list illustrates that
    a system call or library function may fail for any of a number of reasons. Second,
    the specific reasons why *open()* may fail make an interesting list in themselves,
    illustrating a number of factors and checks that come into play when a file is
    accessed. (The above list is incomplete: see the *open(2)* manual page for more
    reasons why *open()* may fail.)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们后续描述其他系统调用或库函数时，一般不会以上述方式列出可能出现的错误范围。（可以在每个系统调用或库函数的相应手册页中找到这样的列表。）我们在这里这么做有两个原因。其中之一是
    *open()* 是我们详细描述的第一个系统调用，以上列表说明了一个系统调用或库函数可能因多种原因失败。第二，*open()* 失败的具体原因本身就形成了一个有趣的列表，展示了在访问文件时涉及的多个因素和检查。（上述列表不完整：有关
    *open()* 失败的更多原因，请参阅 *open(2)* 手册页。）
- en: The *creat()* System Call
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*creat()* 系统调用'
- en: In early UNIX implementations, *open()* had only two arguments and could not
    be used to create a new file. Instead, the *creat()* system call was used to create
    and open a new file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的 UNIX 实现中，*open()* 只有两个参数，且不能用于创建新文件。相反，*creat()* 系统调用用于创建并打开新文件。
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns file descriptor, or -1 on error
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 返回文件描述符，出错时返回 -1
- en: 'The *creat()* system call creates and opens a new file with the given *pathname*,
    or if the file already exists, opens the file and truncates it to zero length.
    As its function result, *creat()* returns a file descriptor that can be used in
    subsequent system calls. Calling *creat()* is equivalent to the following *open()*
    call:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*creat()* 系统调用创建并打开一个具有给定 *pathname* 的新文件，或者如果该文件已经存在，则打开文件并将其截断为零长度。作为其功能结果，*creat()*
    返回一个文件描述符，可以在后续的系统调用中使用。调用 *creat()* 相当于以下的 *open()* 调用：'
- en: '[PRE7]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Because the *open() flags* argument provides greater control over how the file
    is opened (e.g., we can specify `O_RDWR` instead of `O_WRONLY`), *creat()* is
    now obsolete, although it may still be seen in older programs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 *open() flags* 参数提供了对文件打开方式的更大控制（例如，我们可以指定 `O_RDWR` 而不是 `O_WRONLY`），*creat()*
    已经过时，尽管在较旧的程序中仍然可能看到它。
- en: 'Reading from a File: *read()*'
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从文件读取：*read()*
- en: The *read()* system call reads data from the open file referred to by the descriptor
    *fd*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*read()* 系统调用从由描述符 *fd* 引用的打开文件中读取数据。'
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of bytes read, 0 on EOF, or -1 on error
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 返回读取的字节数，遇到文件结尾（EOF）时返回 0，出错时返回 -1
- en: The *count* argument specifies the maximum number of bytes to read. (The *size_t*
    data type is an unsigned integer type.) The *buffer* argument supplies the address
    of the memory buffer into which the input data is to be placed. This buffer must
    be at least *count* bytes long.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*count* 参数指定要读取的最大字节数。（*size_t* 数据类型是一个无符号整数类型。）*buffer* 参数提供内存缓冲区的地址，用于存放输入数据。该缓冲区必须至少有
    *count* 字节长。'
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: System calls don’t allocate memory for buffers that are used to return information
    to the caller. Instead, we must pass a pointer to a previously allocated memory
    buffer of the correct size. This contrasts with several library functions that
    *do* allocate memory buffers in order to return information to the caller.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用不会为用于返回信息的缓冲区分配内存。相反，我们必须传递一个指向先前分配的正确大小的内存缓冲区的指针。这与一些库函数不同，库函数会分配内存缓冲区以便返回信息给调用者。
- en: A successful call to *read()* returns the number of bytes actually read, or
    0 if end-of-file is encountered. On error, the usual -1 is returned. The *ssize_t*
    data type is a signed integer type used to hold a byte count or a -1 error indication.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 成功调用 *read()* 时，返回实际读取的字节数，或者遇到文件结尾时返回 0。发生错误时，通常返回 -1。*ssize_t* 数据类型是一个带符号整数类型，用于存储字节数或
    -1 错误指示。
- en: A call to *read()* may read less than the requested number of bytes. For a regular
    file, the probable reason for this is that we were close to the end of the file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 调用*read()*时，读取的字节数可能少于请求的字节数。对于常规文件，通常的原因是文件接近末尾。
- en: When *read()* is applied to other types of files—such as pipes, FIFOs, sockets,
    or terminals—there are also various circumstances where it may read fewer bytes
    than requested. For example, by default, a *read()* from a terminal reads characters
    only up to the next newline (`\n`) character. We consider these cases when we
    cover other file types in subsequent chapters.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当*read()*应用于其他类型的文件时——例如管道、FIFO、套接字或终端——也有可能读取的字节数少于请求的字节数。例如，默认情况下，从终端的*read()*只会读取到下一个换行符（`\n`）为止。在接下来的章节中，我们将讨论其他文件类型时会涉及到这些情况。
- en: 'Using *read()* to input a series of characters from, say, a terminal, we might
    expect the following code to work:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*read()*从终端等设备输入一系列字符时，我们可能期望以下代码能够正常工作：
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output from this piece of code is likely to be strange, since it will probably
    include characters in addition to the string actually entered. This is because
    *read()* doesn’t place a terminating null byte at the end of the string that *printf()*
    is being asked to print. A moment’s reflection leads us to realize that this must
    be so, since *read()* can be used to read any sequence of bytes from a file. In
    some cases, this input might be text, but in other cases, the input might be binary
    integers or C structures in binary form. There is no way for *read()* to tell
    the difference, and so it can’t attend to the C convention of null terminating
    character strings. If a terminating null byte is required at the end of the input
    buffer, we must put it there explicitly:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出可能会显得奇怪，因为它很可能包含除了实际输入的字符串之外的其他字符。这是因为*read()*并没有在字符串末尾放置一个终止的空字节，而*printf()*被要求打印这个字符串。经过短暂的思考后我们可以理解这一点，因为*read()*可以读取文件中的任何字节序列。在某些情况下，这些输入可能是文本，但在其他情况下，输入可能是二进制整数或二进制形式的C结构。*read()*无法区分这些情况，因此它不能遵循C语言中字符串以空字节终止的约定。如果输入缓冲区的末尾需要一个终止的空字节，我们必须显式地将其放在那里：
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Because the terminating null byte requires a byte of memory, the size of *buffer*
    must be at least one greater than the largest string we expect to read.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因为终止空字节需要一个字节的内存，所以*buffer*的大小必须至少比我们预计要读取的最大字符串大1个字节。
- en: 'Writing to a File: *write()*'
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入文件：*write()*
- en: The *write()* system call writes data to an open file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*write()*系统调用将数据写入一个打开的文件。'
- en: '[PRE11]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of bytes written, or -1 on error
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 返回写入的字节数，出错时返回-1
- en: 'The arguments to *write()* are similar to those for *read()*: *buffer* is the
    address of the data to be written; *count* is the number of bytes to write from
    *buffer*; and *fd* is a file descriptor referring to the file to which data is
    to be written.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*write()*的参数与*read()*类似：*buffer*是要写入的数据的地址；*count*是从*buffer*写入的字节数；*fd*是一个文件描述符，指向要写入数据的文件。'
- en: On success, *write()* returns the number of bytes actually written; this may
    be less than *count*. For a disk file, possible reasons for such a *partial write*
    are that the disk was filled or that the process resource limit on file sizes
    was reached. (The relevant limit is `RLIMIT_FSIZE`, described in Section 36.3.)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时，*write()*返回实际写入的字节数；这可能少于*count*。对于磁盘文件，可能导致*部分写入*的原因是磁盘已满，或进程的文件大小资源限制已达到。（相关限制在第36.3节中描述）
- en: When performing I/O on a disk file, a successful return from *write()* doesn’t
    guarantee that the data has been transferred to disk, because the kernel performs
    buffering of disk I/O in order to reduce disk activity and expedite *write()*
    calls. We consider the details in [Chapter 13](ch13.html "Chapter 13. File I/O
    Buffering").
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在对磁盘文件进行I/O操作时，*write()*成功返回并不保证数据已被写入磁盘，因为内核会对磁盘I/O进行缓冲，以减少磁盘活动并加速*write()*调用。我们将在[第13章](ch13.html
    "第13章. 文件I/O缓冲")中讨论这些细节。
- en: 'Closing a File: *close()*'
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭文件：*close()*
- en: The *close()* system call closes an open file descriptor, freeing it for subsequent
    reuse by the process. When a process terminates, all of its open file descriptors
    are automatically closed.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*close()*系统调用关闭一个打开的文件描述符，使其可以被进程重新使用。当进程终止时，它的所有打开文件描述符会自动关闭。'
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: It is usually good practice to close unneeded file descriptors explicitly, since
    this makes our code more readable and reliable in the face of subsequent modifications.
    Furthermore, file descriptors are a consumable resource, so failure to close a
    file descriptor could result in a process running out of descriptors. This is
    a particularly important issue when writing long-lived programs that deal with
    multiple files, such as shells or network servers.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，显式地关闭不需要的文件描述符是一个良好的实践，因为这样可以使我们的代码在后续修改中更具可读性和可靠性。此外，文件描述符是可消耗的资源，因此如果未能关闭文件描述符，可能会导致进程耗尽描述符。这在编写处理多个文件的长生命周期程序时尤为重要，例如
    shell 或网络服务器。
- en: 'Just like every other system call, a call to *close()* should be bracketed
    with error-checking code, such as the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他系统调用一样，*close()* 调用应当配备错误检查代码，如下所示：
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This catches errors such as attempting to close an unopened file descriptor
    or close the same file descriptor twice, and catches error conditions that a specific
    file system may diagnose during a close operation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以捕捉到诸如尝试关闭未打开的文件描述符或重复关闭相同文件描述符等错误，并捕捉到某些文件系统在关闭操作中可能诊断出的错误条件。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: NFS (Network File System) provides an example of an error that is specific to
    a file system. If an NFS commit failure occurs, meaning that the data did not
    reach the remote disk, then this error is propagated to the application as a failure
    in the *close()* call.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: NFS（网络文件系统）提供了一个特定于文件系统的错误示例。如果发生 NFS 提交失败，意味着数据未能到达远程磁盘，那么该错误将作为 *close()*
    调用中的失败被传递到应用程序。
- en: 'Changing the File Offset: *lseek()*'
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改文件偏移量：*lseek()*
- en: For each open file, the kernel records a *file offset*, sometimes also called
    the *read-write offset* or *pointer*. This is the location in the file at which
    the next *read()* or *write()* will commence. The file offset is expressed as
    an ordinal byte position relative to the start of the file. The first byte of
    the file is at offset 0.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个打开的文件，内核记录一个 *文件偏移量*，有时也称为 *读写偏移量* 或 *指针*。这是文件中下一次 *read()* 或 *write()*
    操作开始的位置。文件偏移量是相对于文件开始的字节位置表示的。文件的第一个字节位于偏移量 0 处。
- en: The file offset is set to point to the start of the file when the file is opened
    and is automatically adjusted by each subsequent call to *read()* or *write()*
    so that it points to the next byte of the file after the byte(s) just read or
    written. Thus, successive *read()* and *write()* calls progress sequentially through
    a file.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 文件偏移量在文件打开时设置为指向文件的开始，并会在每次随后的 *read()* 或 *write()* 调用时自动调整，使其指向刚刚读取或写入的字节之后的下一个字节。因此，连续的
    *read()* 和 *write()* 调用会顺序地通过文件进行。
- en: The *lseek()* system call adjusts the file offset of the open file referred
    to by the file descriptor *fd*, according to the values specified in *offset*
    and *whence*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*lseek()* 系统调用会根据 *offset* 和 *whence* 指定的值，调整由文件描述符 *fd* 引用的打开文件的文件偏移量。'
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns new file offset if successful, or -1 on error
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，返回新的文件偏移量；如果发生错误，则返回 -1。
- en: 'The *offset* argument specifies a value in bytes. (The *off_t* data type is
    a signed integer type specified by SUSv3.) The *whence* argument indicates the
    base point from which *offset* is to be interpreted, and is one of the following
    values:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*offset* 参数指定一个字节数值（*off_t* 数据类型是一个有符号整数类型，依据 SUSv3 规范）。*whence* 参数指示 *offset*
    解释的基准点，且其值必须是以下之一：'
- en: '`SEEK_SET`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`SEEK_SET`'
- en: The file offset is set *offset* bytes from the beginning of the file.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 文件偏移量从文件开头起设置为 *offset* 字节。
- en: '`SEEK_CUR`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`SEEK_CUR`'
- en: The file offset is adjusted by *offset* bytes relative to the current file offset.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 文件偏移量相对于当前的文件偏移量调整 *offset* 字节。
- en: '`SEEK_END`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`SEEK_END`'
- en: The file offset is set to the size of the file plus *offset*. In other words,
    *offset* is interpreted with respect to the next byte after the last byte of the
    file.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 文件偏移量设置为文件大小加上 *offset*。换句话说，*offset* 是相对于文件最后一个字节之后的下一个字节进行解释的。
- en: '[Figure 4-1](ch04.html#interpreting_the_whence_argument_of_lsee "Figure 4-1. Interpreting
    the whence argument of lseek()") shows how the *whence* argument is interpreted.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-1](ch04.html#interpreting_the_whence_argument_of_lsee "图 4-1. 解释 lseek()
    的 whence 参数") 显示了 *whence* 参数的解释方式。'
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In earlier UNIX implementations, the integers 0, 1, and 2 were used, rather
    than the `SEEK_*` constants shown in the main text. Older versions of BSD used
    different names for these values: `L_SET`, `L_INCR`, and `L_XTND`.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的 UNIX 实现中，使用的是整数 0、1 和 2，而不是主文中所示的 `SEEK_*` 常量。旧版本的 BSD 使用了不同的名称来表示这些值：`L_SET`、`L_INCR`
    和 `L_XTND`。
- en: '![Interpreting the whence argument of lseek()](figs/web/04-1_FILEIO-A-lseek-scale90.png.jpg)Figure 4-1. Interpreting
    the *whence* argument of *lseek()*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![解释 *lseek()* 的 whence 参数](figs/web/04-1_FILEIO-A-lseek-scale90.png.jpg)图
    4-1. 解释 *lseek()* 的 *whence* 参数'
- en: If *whence* is `SEEK_CUR` or `SEEK_END`, *offset* may be negative or positive;
    for `SEEK_SET`, *offset* must be nonnegative.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *whence* 是 `SEEK_CUR` 或 `SEEK_END`，*offset* 可以是负值或正值；对于 `SEEK_SET`，*offset*
    必须是非负值。
- en: 'The return value from a successful *lseek()* is the new file offset. The following
    call retrieves the current location of the file offset without changing it:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的 *lseek()* 调用的返回值是新的文件偏移量。以下调用会在不改变文件偏移量的情况下，检索当前文件偏移量的位置：
- en: '[PRE15]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some UNIX implementations (but not Linux) have the nonstandard *tell(fd)* function,
    which serves the same purpose as the above *lseek()* call.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 UNIX 实现（但不是 Linux）提供了非标准的 *tell(fd)* 函数，它与上述 *lseek()* 调用的作用相同。
- en: 'Here are some other examples of *lseek()* calls, along with comments indicating
    where the file offset is moved to:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些其他的 *lseek()* 调用示例，并附有注释，指示文件偏移量移动到的位置：
- en: '[PRE16]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Calling *lseek()* simply adjusts the kernel’s record of the file offset associated
    with a file descriptor. It does not cause any physical device access.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 *lseek()* 仅仅调整内核记录的与文件描述符相关联的文件偏移量。它不会导致任何物理设备访问。
- en: We describe some further details of the relationship between file offsets, file
    descriptors, and open files in Section 5.4.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 5.4 节中描述文件偏移量、文件描述符和打开文件之间关系的更多细节。
- en: We can’t apply *lseek()* to all types of files. Applying *lseek()* to a pipe,
    FIFO, socket, or terminal is not permitted; *lseek()* fails, with *errno* set
    to `ESPIPE`. On the other hand, it is possible to apply *lseek()* to devices where
    it is sensible to do so. For example, it is possible to seek to a specified location
    on a disk or tape device.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能将 *lseek()* 应用于所有类型的文件。将 *lseek()* 应用于管道、FIFO、套接字或终端是不允许的；此时 *lseek()* 会失败，且
    *errno* 被设置为 `ESPIPE`。另一方面，对于某些设备，应用 *lseek()* 是合理的。例如，能够在磁盘或磁带设备上定位到指定的位置。
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *l* in the name *lseek()* derives from the fact that the *offset* argument
    and the return value were both originally typed as *long*. Early UNIX implementations
    provided a *seek()* system call, which typed these values as *int*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*lseek()* 名称中的 *l* 源自于 *offset* 参数和返回值最初都被定义为 *long* 类型。早期的 UNIX 实现提供了一个 *seek()*
    系统调用，该系统调用将这些值定义为 *int* 类型。'
- en: File holes
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件孔
- en: What happens if a program seeks past the end of a file, and then performs I/O?
    A call to *read()* will return 0, indicating end-of-file. Somewhat surprisingly,
    it is possible to write bytes at an arbitrary point past the end of the file.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序尝试在文件末尾之后寻址，然后执行 I/O 操作，会发生什么？调用 *read()* 将返回 0，表示文件结束。令人有些惊讶的是，实际上可以在文件末尾之后的任意位置写入字节。
- en: The space in between the previous end of the file and the newly written bytes
    is referred to as a *file hole*. From a programming point of view, the bytes in
    a hole exist, and reading from the hole returns a buffer of bytes containing 0
    (null bytes).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件末尾和新写入的字节之间的空间被称为 *文件孔*。从编程的角度来看，孔中的字节是存在的，从孔中读取将返回包含 0（空字节）的字节缓冲区。
- en: File holes don’t, however, take up any disk space. The file system doesn’t allocate
    any disk blocks for a hole until, at some later point, data is written into it.
    The main advantage of file holes is that a sparsely populated file consumes less
    disk space than would otherwise be required if the null bytes actually needed
    to be allocated in disk blocks. Core dump files ([Core Dump Files](ch22.html#core_dump_files
    "Core Dump Files")) are common examples of files that contain large holes.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，文件孔不会占用任何磁盘空间。文件系统不会为一个孔分配磁盘块，直到在某个以后时刻，数据被写入其中。文件孔的主要优势是，稀疏填充的文件比需要实际分配磁盘块的零字节文件消耗的磁盘空间要少。核心转储文件（[Core
    Dump Files](ch22.html#core_dump_files "Core Dump Files")）是包含大孔的文件的常见示例。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The statement that file holes don’t consume disk space needs to be qualified
    slightly. On most file systems, file space is allocated in units of blocks ([File
    Systems](ch14.html#file_systems-id1 "File Systems")). The size of a block depends
    on the file system, but is typically something like 1024, 2048, or 4096 bytes.
    If the edge of a hole falls within a block, rather than on a block boundary, then
    a complete block is allocated to store the data in the other part of the block,
    and the part corresponding to the hole is filled with null bytes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 文件空洞不占用磁盘空间的说法需要稍作说明。在大多数文件系统中，文件空间是按块的单位分配的（[文件系统](ch14.html#file_systems-id1
    "File Systems")）。块的大小取决于文件系统，但通常是1024、2048或4096字节。如果空洞的边缘位于块内，而不是在块的边界上，则会分配一个完整的块来存储块的另一部分数据，空洞对应的部分则会填充为零字节。
- en: Most native UNIX file systems support the concept of file holes, but many nonnative
    file systems (e.g., Microsoft’s VFAT) do not. On a file system that doesn’t support
    holes, explicit null bytes are written to the file.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数本地UNIX文件系统支持文件空洞的概念，但许多非本地文件系统（例如，微软的VFAT）不支持。在不支持空洞的文件系统上，会显式地向文件写入空字节。
- en: The existence of holes means that a file’s nominal size may be larger than the
    amount of disk storage it utilizes (in some cases, considerably larger). Writing
    bytes into the middle of the file hole will decrease the amount of free disk space
    as the kernel allocates blocks to fill the hole, even though the file’s size doesn’t
    change. Such a scenario is uncommon, but nevertheless one to be aware of.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 存在空洞意味着文件的名义大小可能大于其实际使用的磁盘存储空间（在某些情况下，可能大得多）。将字节写入文件的空洞中会减少空闲磁盘空间，因为内核会分配块来填补空洞，即使文件的大小没有变化。这样的情况虽然不常见，但仍然需要注意。
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 specifies a function, *posix_fallocate(fd, offset, len)*, that ensures
    that space is allocated on disk for the byte range specified by *offset* and *len*
    for the disk file referred to by the descriptor *fd*. This allows an application
    to be sure that a later *write()* to the file won’t fail because disk space is
    exhausted (which could otherwise occur if a hole in the file was filled in, or
    some other application consumed space on the disk). Historically, the *glibc*
    implementation of this function achieved the desired result by writing a 0 byte
    into each block in the specified range. Since version 2.6.23, Linux provides an
    *fallocate()* system call, which provides a more efficient way of ensuring that
    the necessary space is allocated, and the *glibc posix_fallocate()* implementation
    makes use of this system call when it is available.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3指定了一个函数，*posix_fallocate(fd, offset, len)*，它确保为由描述符*fd*引用的磁盘文件中由*offset*和*len*指定的字节范围分配磁盘空间。这使得应用程序可以确保稍后的*write()*不会因为磁盘空间耗尽而失败（否则如果文件中的空洞被填充，或者其他应用程序占用了磁盘空间，可能会发生这种情况）。历史上，*glibc*实现此函数的方式是通过向指定范围的每个块写入一个0字节来达到预期效果。自2.6.23版本起，Linux提供了*fallocate()*系统调用，这为确保分配必要空间提供了一种更高效的方法，并且当该系统调用可用时，*glibc
    posix_fallocate()*实现会利用它。
- en: '[I-nodes](ch14.html#i-nodes "I-nodes") describes how holes are represented
    in a file, and [Retrieving File Information: *stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "Retrieving File Information: stat()") describes the *stat()* system call, which
    can tell us the current size of a file, as well as the number of blocks actually
    allocated to the file.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[I节点](ch14.html#i-nodes "I-nodes")描述了文件中空洞是如何表示的，[检索文件信息：*stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "Retrieving File Information: stat()")描述了*stat()*系统调用，它可以告诉我们文件的当前大小，以及实际分配给文件的块数。'
- en: Example program
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 4-3](ch04.html#demonstration_of_read_open_parenthesis_c "Example 4-3. Demonstration
    of read(), write(), and lseek()") demonstrates the use of *lseek()* in conjunction
    with *read()* and *write()*. The first command-line argument to this program is
    the name of a file to be opened. The remaining arguments specify I/O operations
    to be performed on the file. Each of these operations consists of a letter followed
    by an associated value (with no separating space):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例4-3](ch04.html#demonstration_of_read_open_parenthesis_c "Example 4-3. Demonstration
    of read(), write(), and lseek()")演示了*read()*、*write()*和*lseek()*的结合使用。此程序的第一个命令行参数是要打开的文件名，其余参数指定对该文件执行的I/O操作。每个操作由一个字母后跟一个相关的值（没有空格分隔）组成：'
- en: '`s`*offset*: Seek to byte *offset* from the start of the file.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`*偏移量*：从文件开始位置寻址到字节*偏移量*。'
- en: '`r`*length*: Read *length* bytes from the file, starting at the current file
    offset, and display them in text form.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`*length*: 从文件的当前文件偏移量开始，读取 *length* 字节，并以文本形式显示。'
- en: '`R`*length*: Read *length* bytes from the file, starting at the current file
    offset, and display them in hexadecimal.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R`*length*: 从文件的当前文件偏移量开始，读取 *length* 字节，并以十六进制形式显示。'
- en: '`w`*str*: Write the string of characters specified in *str* at the current
    file offset.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`*str*: 在当前文件偏移量处写入 *str* 中指定的字符字符串。'
- en: Example 4-3. Demonstration of *read()*, *write()*, and *lseek()*
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-3. 演示 *read()*, *write()* 和 *lseek()*
- en: '[PRE17]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following shell session log demonstrates the use of the program in [Example 4-3](ch04.html#demonstration_of_read_open_parenthesis_c
    "Example 4-3. Demonstration of read(), write(), and lseek()"), showing what happens
    when we attempt to read bytes from a file hole:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 shell 会话日志演示了 [示例 4-3](ch04.html#demonstration_of_read_open_parenthesis_c
    "Example 4-3. Demonstration of read(), write(), and lseek()") 中程序的使用，显示了我们尝试从文件孔中读取字节时发生的情况：
- en: '[PRE18]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Operations Outside the Universal I/O Model: *ioctl()*'
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用 I/O 模型之外的操作：*ioctl()*
- en: The *ioctl()* system call is a general-purpose mechanism for performing file
    and device operations that fall outside the universal I/O model described earlier
    in this chapter.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*ioctl()* 系统调用是一个通用机制，用于执行不符合本章前面描述的通用 I/O 模型的文件和设备操作。'
- en: '[PRE19]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Value returned on success depends on *request*, or -1 on error
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回的值取决于 *request*，或在出错时返回 -1。
- en: The *fd* argument is an open file descriptor for the device or file upon which
    the control operation specified by *request* is to be performed. Device-specific
    header files define constants that can be passed in the *request* argument.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*fd* 参数是一个打开的文件描述符，表示将要执行 *request* 指定的控制操作的设备或文件。特定设备的头文件定义了可以在 *request*
    参数中传递的常量。'
- en: As indicated by the standard C ellipsis (`...`) notation, the third argument
    to *ioctl()*, which we label *argp*, can be of any type. The value of the *request*
    argument enables *ioctl()* to determine what type of value to expect in *argp*.
    Typically, *argp* is a pointer to either an integer or a structure; in some cases,
    it is unused.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如标准 C 中的省略号（`...`）表示法所示，*ioctl()* 的第三个参数，我们标记为 *argp*，可以是任何类型。*request* 参数的值使
    *ioctl()* 能够确定在 *argp* 中预期的值类型。通常，*argp* 是指向整数或结构的指针；在某些情况下，它未使用。
- en: We’ll see a number of uses for *ioctl()* in later chapters (see, for example,
    [I-node Flags (*ext2* Extended File Attributes)](ch15.html#i-node_flags_open_parenthesis_ext2_exten
    "I-node Flags (ext2 Extended File Attributes)")).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中看到 *ioctl()* 的多个使用案例（例如，参见 [I-node 标志 (*ext2* 扩展文件属性)](ch15.html#i-node_flags_open_parenthesis_ext2_exten
    "I-node Flags (ext2 Extended File Attributes)"))。
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The only specification that SUSv3 makes for *ioctl()* is for operations to control
    STREAMS devices. (The STREAMS facility is a System V feature that is not supported
    by the mainline Linux kernel, although a few add-on implementations have been
    developed.) None of the other *ioctl()* operations described in this book is specified
    in SUSv3\. However, the *ioctl()* call has been part of the UNIX system since
    early versions, and consequently several of the *ioctl()* operations that we describe
    are provided on many other UNIX implementations. As we describe each *ioctl()*
    operation, we note portability issues.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 对 *ioctl()* 的唯一规定是控制 STREAMS 设备的操作。（STREAMS 是一个 System V 特性，主流 Linux 内核不支持该特性，尽管已经开发出一些附加实现。）本书中描述的其他
    *ioctl()* 操作在 SUSv3 中没有具体规定。然而，*ioctl()* 调用自 UNIX 系统早期版本以来就已存在，因此我们描述的几个 *ioctl()*
    操作在许多其他 UNIX 实现中都有提供。在描述每个 *ioctl()* 操作时，我们会指出可移植性问题。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In order to perform I/O on a regular file, we must first obtain a file descriptor
    using *open()*. I/O is then performed using *read()* and *write()*. After performing
    all I/O, we should free the file descriptor and its associated resources using
    *close()*. These system calls can be used to perform I/O on all types of files.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对常规文件进行 I/O 操作，我们必须首先使用 *open()* 获取文件描述符。然后，使用 *read()* 和 *write()* 进行 I/O
    操作。完成所有 I/O 操作后，我们应该使用 *close()* 释放文件描述符及其相关资源。这些系统调用可以用于对所有类型的文件进行 I/O 操作。
- en: The fact that all file types and device drivers implement the same I/O interface
    allows for universality of I/O, meaning that a program can typically be used with
    any type of file without requiring code that is specific to the file type.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 所有文件类型和设备驱动程序实现相同的 I/O 接口，这使得 I/O 具有通用性，这意味着一个程序通常可以与任何类型的文件一起使用，而无需编写特定于文件类型的代码。
- en: For each open file, the kernel maintains a file offset, which determines the
    location at which the next read or write will occur. The file offset is implicitly
    updated by reads and writes. Using *lseek()*, we can explicitly reposition the
    file offset to any location within the file or past the end of the file. Writing
    data at a position beyond the previous end of the file creates a hole in the file.
    Reads from a file hole return bytes containing zeros.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个打开的文件，内核维护一个文件偏移量，确定下一个读取或写入将发生的位置。文件偏移量会在读取和写入时隐式更新。通过使用 *lseek()*，我们可以显式地将文件偏移量重新定位到文件中的任何位置，甚至超过文件末尾。在文件的末尾写入数据会在文件中创建一个空洞。从文件空洞中读取数据会返回包含零的字节。
- en: The *ioctl()* system call is a catchall for device and file operations that
    don’t fit into the standard file I/O model.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*ioctl()* 系统调用是一个涵盖设备和文件操作的通用方法，适用于那些不符合标准文件 I/O 模型的操作。'
- en: Exercises
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: The *tee* command reads its standard input until end-of-file, writing a copy
    of the input to standard output and to the file named in its command-line argument.
    (We show an example of the use of this command when we discuss FIFOs in Section
    44.7.) Implement *tee* using I/O system calls. By default, *tee* overwrites any
    existing file with the given name. Implement the -*a* command-line option (*tee
    -a file*), which causes *tee* to append text to the end of a file if it already
    exists. (Refer to [Appendix B](apb.html "Appendix B. Parsing Command-Line Options")
    for a description of the *getopt()* function, which can be used to parse command-line
    options.)
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*tee* 命令读取标准输入直到文件结尾，并将输入的副本写入标准输出和命令行参数中指定的文件。（我们在第 44.7 节讨论 FIFO 时会展示此命令的使用示例。）使用
    I/O 系统调用实现 *tee*。默认情况下，*tee* 会覆盖任何已存在的文件。实现 -*a* 命令行选项（*tee -a file*），该选项会使 *tee*
    在文件已存在的情况下将文本追加到文件末尾。（参见 [附录 B](apb.html "附录 B. 解析命令行选项")，其中描述了 *getopt()* 函数，能够解析命令行选项。）'
- en: Write a program like *cp* that, when used to copy a regular file that contains
    holes (sequences of null bytes), also creates corresponding holes in the target
    file.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个类似 *cp* 的程序，当用于复制包含空洞（空字节序列）的常规文件时，也会在目标文件中创建相应的空洞。
