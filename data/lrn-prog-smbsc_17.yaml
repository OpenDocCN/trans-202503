- en: '**17**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**17**'
- en: '**EXPANDING TO HIGHER-DIMENSION ARRAYS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展到高维数组**'
- en: '![image](graphics/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common01.jpg)'
- en: In the previous two chapters, you learned how to use one-dimensional arrays
    to store collections of items. In this chapter, we’ll expand this concept to two
    dimensions and higher. Working in more than one dimension is also called working
    in *higher* dimensions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，你学习了如何使用一维数组来存储项目集合。本章将这一概念扩展到二维及更高维度。处理多维数组也叫做处理*高维*数组。
- en: In a *two-dimensional (2D)* array, you can store values in a table or a grid.
    For example, think about the scoreboard at a baseball game (see [Figure 17-1](ch17.html#ch17fig1)).
    The left column lists the team names, and the right columns list the innings and
    other statistics.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在*二维（2D）*数组中，你可以在表格或网格中存储值。例如，想象一下棒球比赛中的记分牌（见 [Figure 17-1](ch17.html#ch17fig1)）。左侧列列出了队名，右侧列列出了局数和其他统计数据。
- en: '![image](graphics/f17-01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f17-01.jpg)'
- en: '*Figure 17-1: Baseball scoreboard*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 17-1：棒球记分牌*'
- en: The arrays you’ll make in this chapter are similar to a scoreboard. They let
    you organize your data in rows and columns.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你将创建的数组类似于记分牌。它们允许你将数据按行和列组织起来。
- en: When you complete this chapter, you’ll understand 2D and other higher-dimensional
    arrays and you’ll be able to use them to build new types of applications, including
    a treasure-hunting game!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将理解二维及其他高维数组，并能够使用它们来构建新类型的应用程序，包括寻宝游戏！
- en: '**Two-Dimensional Arrays**'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**二维数组**'
- en: 'A 2D array has two dimensions: rows and columns. You can think of a 2D array
    as a table. For example, [Figure 17-2](ch17.html#ch17fig2) shows a 2D array named
    `score` that stores a student’s test scores in three subjects.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个二维数组有两个维度：行和列。你可以将二维数组视为一个表格。例如，[Figure 17-2](ch17.html#ch17fig2) 显示了一个名为`score`的二维数组，用来存储学生在三门科目中的考试成绩。
- en: '![image](graphics/f17-02.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f17-02.jpg)'
- en: '*Figure 17-2: A pictorial view of a 2D array*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 17-2：二维数组的图示视图*'
- en: The first row contains math test scores, the second row records the science
    test scores, and the next row stores English scores. This 2D arrangement of elements
    is also referred to as a *matrix* (the plural is *matrices*). But this matrix
    won’t teach you slow-motion kung fu!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行包含数学考试成绩，第二行记录了科学考试成绩，接下来的行存储了英语成绩。这种元素的二维排列也称为*矩阵*（复数为*矩阵*）。但这个矩阵不会教你慢动作功夫！
- en: 'To access the individual elements of a matrix, you need two indices: one for
    the rows and the other for the columns. Here are some examples:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问矩阵中的单个元素，你需要两个索引：一个表示行，另一个表示列。以下是一些示例：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The variable `score` is a *double-scripted variable* because it requires two
    indices to access its elements. The first index is the row number, and the second
    index is the column number.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`score`是一个*双重脚本变量*，因为它需要两个索引来访问其元素。第一个索引是行号，第二个索引是列号。
- en: As with one-dimensional arrays, the index of each dimension can be a number
    or a string. Also, the values stored in the matrix can be numbers, strings, or
    other identifiers returned by objects in the Small Basic library. Let’s look at
    some simple examples of 2D arrays next.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与一维数组一样，每个维度的索引可以是数字或字符串。此外，矩阵中存储的值可以是数字、字符串或Small Basic库中对象返回的其他标识符。接下来我们来看一些二维数组的简单示例。
- en: '***A Random Matrix***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***随机矩阵***'
- en: A client named MI6 wants your help to generate passwords for security locks.
    The program shown in [Listing 17-1](ch17.html#ch17ex1) creates a matrix named
    `mat` consisting of random numbers. The matrix contains three rows and four columns,
    which is a 3×4 (read *3 by 4*) matrix, or a 3×4 array.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为MI6的客户需要你的帮助来为安全锁生成密码。程序 [Listing 17-1](ch17.html#ch17ex1) 创建了一个名为`mat`的矩阵，其中包含随机数。该矩阵包含三行四列，是一个3×4（读作*3乘4*）矩阵，或者是一个3×4数组。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 17-1: Filling a 3×4 array with random numbers*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 17-1：用随机数填充一个3×4数组*'
- en: The program uses a nested `For` loop to fill the matrix with random numbers
    (lines 2–6). Nested `For` loops are extremely helpful when you’re working with
    2D arrays, because you can use one to loop through rows and the other to loop
    through columns. In this example, the outer loop uses a control variable `r` (for
    *rows*) and runs from 1 to 3 (line 2); the inner loop uses a control variable
    `c` (for *columns*) and runs from 1 to 4 (line 3).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用嵌套的`For`循环填充矩阵的随机数（第2–6行）。嵌套的`For`循环在处理二维数组时非常有用，因为你可以使用一个循环遍历行，另一个循环遍历列。在这个例子中，外层循环使用控制变量`r`（表示*行*），从1运行到3（第2行）；内层循环使用控制变量`c`（表示*列*），从1运行到4（第3行）。
- en: The first pass of the outer loop (`r = 1`) causes four passes inside the inner
    loop (`c = 1`, `2`, `3`, and `4`), which fills `mat[1][1]`, `mat[1][2]`, `mat[1][3]`,
    and `mat[1][4]`. The second pass of the outer loop (`r = 2`) causes another four
    iterations of the inner loop (`c = 1`, `2`, `3`, and `4`) and fills `mat[2][1]`,
    `mat[2][2]`, `mat[2][3]`, and `mat[2][4]`. Likewise, the third pass of the outer
    loop (`r = 3`) fills the third row of the matrix. [Figure 17-3](ch17.html#ch17fig3)
    illustrates this process.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 外层循环的第一次执行（`r = 1`）会导致内层循环执行四次（`c = 1`、`2`、`3`、`4`），填充`mat[1][1]`、`mat[1][2]`、`mat[1][3]`、`mat[1][4]`。外层循环的第二次执行（`r
    = 2`）会导致内层循环再执行四次（`c = 1`、`2`、`3`、`4`），填充`mat[2][1]`、`mat[2][2]`、`mat[2][3]`、`mat[2][4]`。同样，外层循环的第三次执行（`r
    = 3`）会填充矩阵的第三行。[图 17-3](ch17.html#ch17fig3)展示了这一过程。
- en: '![image](graphics/f17-03.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f17-03.jpg)'
- en: '*Figure 17-3: Using a nested* `For` *loop to access the elements of a matrix*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-3：使用嵌套的* `For` *循环访问矩阵元素*'
- en: Following along with this figure, when `r = 1`, the program takes the top `c`
    branch and fills in all four sets of the 2D array elements. When `r = 2`, it iterates
    through the middle branch four times. When `r = 3`, it iterates through the bottom
    branch.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这张图，当`r = 1`时，程序执行顶部的`c`分支，填充二维数组的四组元素。当`r = 2`时，它会遍历中间的分支四次。当`r = 3`时，它会遍历底部的分支。
- en: After filling the matrix with random numbers, the program uses another nested
    loop to display its contents (lines 9–14) using a similar process. The outer loop
    runs from 1 to 3 to index the three rows (line 9), and the inner loop runs from
    1 to 4 to index the four columns (line 10). Line 11 displays the element at index
    `mat[r][c]` (column `c` in row `r`), followed by a space. When the inner loop
    ends, it means an entire row has been displayed, and the cursor moves to the next
    line to prepare to display the next row (line 13).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在用随机数填充矩阵之后，程序使用另一个嵌套循环以类似的方式显示其内容（第9–14行）。外层循环从1到3运行，用于索引三行（第9行），内层循环从1到4运行，用于索引四列（第10行）。第11行显示索引为`mat[r][c]`（第r行第c列）的元素，并跟着一个空格。当内层循环结束时，意味着一整行已经显示完毕，光标将移动到下一行，准备显示下一行（第13行）。
- en: 'It’s time to turn your program over to your MI6 client. Here’s a sample output
    of this program, but your output will most likely be different:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将你的程序交给MI6客户了。下面是该程序的一个示例输出，但你的输出很可能会有所不同：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can make matrices even more useful by programming them to accept user input.
    We’ll look at how to do that next.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编程使矩阵能够接受用户输入，你可以使矩阵变得更加有用。接下来，我们将看看如何做到这一点。
- en: '**TRY IT OUT 17-1**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试一下 17-1**'
- en: In [Listing 17-1](ch17.html#ch17ex1), the numbers in the matrix are stored by
    rows. First, row 1 is filled, then row 2, and finally row 3\. The reason is that
    we made the `r` loop (which represents rows) the outer loop and the `c` loop (which
    represents columns) the inner loop. Change the program so it fills the matrix
    by columns first instead of rows.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 17-1](ch17.html#ch17ex1)中，矩阵中的数字按行存储。首先填充第1行，然后是第2行，最后是第3行。原因是我们将代表行的`r`循环设置为外层循环，将代表列的`c`循环设置为内层循环。修改程序，让它先按列填充矩阵，而不是按行填充。
- en: '***A Matrix with User Input***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***带有用户输入的矩阵***'
- en: 'Your MI6 client loves the program you built, but now they want to be able to
    enter certain numbers into the password matrix. You can easily change [Listing
    17-1](ch17.html#ch17ex1) to take input from the user instead of using random numbers.
    Just replace line 4 with the following two lines:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你的MI6客户喜欢你编写的程序，但现在他们希望能够将某些数字输入到密码矩阵中。你可以轻松修改[清单 17-1](ch17.html#ch17ex1)，让它从用户处获取输入，而不是使用随机数。只需将第4行替换为以下两行：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first statement prompts the user to enter an element in the matrix, and
    the second line reads and stores the user’s entry. Make this change, and try it
    out to see how it works.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条语句提示用户输入矩阵中的一个元素，第二条语句读取并存储用户的输入。进行此更改，并尝试运行程序，看看它是如何工作的。
- en: But matrices aren’t only about numbers. You can use them to make some fun, colorful
    applications too. In the next example, you’ll create a colorful grid and animate
    it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但矩阵不仅仅是数字。你也可以使用它们来制作一些有趣的彩色应用程序。在接下来的示例中，你将创建一个彩色网格并使其动画化。
- en: '***Animated Squares***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***动画方块***'
- en: Let’s write a program that creates a 4×8 grid of randomly colored squares and
    then animates these squares to fly to the upper-left corner of the graphics window,
    as shown in [Figure 17-4](ch17.html#ch17fig4).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来编写一个程序，创建一个4×8的随机颜色方块网格，并将这些方块动画化，飞向图形窗口的左上角，如[图17-4](ch17.html#ch17fig4)所示。
- en: '![image](graphics/f17-04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f17-04.jpg)'
- en: '*Figure 17-4: Illustrating the output of* AnimatedSquares.sb'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-4：展示* AnimatedSquares.sb 输出的效果'
- en: The complete application is shown in [Listing 17-2](ch17.html#ch17ex2).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序在[清单17-2](ch17.html#ch17ex2)中展示。
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 17-2: Using a matrix to store shape IDs*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单17-2：使用矩阵存储形状ID*'
- en: The program uses a nested `For` loop to create the squares (lines 3–10). The
    outer loop (which creates the rows) runs four times, and the inner loop (which
    creates the columns) runs eight times (lines 3–4), for a total of 32 iterations
    (4×8). In each pass of the inner loop, the square’s color is set by changing the
    `BrushColor` property (lines 5–6), and a square is created by calling `AddRectangle()`.
    We save its identifier in `box[r][c]` (line 7) and then move the created square
    to its position on the square grid (see [Figure 17-4](ch17.html#ch17fig4)). Let’s
    take a closer look at lines 7–8.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用嵌套的`For`循环来创建方块（第3–10行）。外部循环（创建行）运行四次，内部循环（创建列）运行八次（第3–4行），共进行32次迭代（4×8）。在每次内部循环中，方块的颜色通过更改`BrushColor`属性来设置（第5–6行），然后通过调用`AddRectangle()`创建一个方块。我们将其标识符保存在`box[r][c]`中（第7行），然后将创建的方块移动到它在方块网格中的位置（见[图17-4](ch17.html#ch17fig4)）。让我们仔细看一下第7–8行。
- en: At line 7, the `AddRectangle()` method takes the width and the height of the
    desired rectangle and returns an identifier of the created shape. In this example,
    we pass 20 for both arguments to create a square, and we save the returned identifier
    in `box[r][c]`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7行，`AddRectangle()`方法接受期望的矩形的宽度和高度，并返回创建的形状的标识符。在这个例子中，我们传递20作为两个参数来创建一个方块，并将返回的标识符保存在`box[r][c]`中。
- en: 'To move the square, we call the `Move()` method of the `Shapes` object (line
    8). This method takes three arguments: the identifier of the shape we want to
    move and the x- and y-coordinates of the position we’re moving it to. The squares
    in each row have their x positions (left edge) at 1 × 20 = 20, 2 × 20 = 40, 3
    × 20 = 60, and so on. The squares in each column have their y positions (top edge)
    at 1 × 20 = 20, 2 × 20 = 40, 3 × 20 = 60, and so on. This is why we use `c * 20`
    and `r * 20` in the call to `Move()`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要移动方块，我们调用`Shapes`对象的`Move()`方法（第8行）。该方法接受三个参数：我们要移动的形状标识符，以及我们要将其移动到的位置的x和y坐标。每一行中的方块的x位置（左边缘）分别是1
    × 20 = 20, 2 × 20 = 40, 3 × 20 = 60，依此类推。每一列中的方块的y位置（上边缘）分别是1 × 20 = 20, 2 × 20
    = 40, 3 × 20 = 60，依此类推。这就是为什么我们在调用`Move()`时使用`c * 20`和`r * 20`的原因。
- en: At the end of this `For` loop, the `box` matrix contains 32 unique identifiers
    for the 32 squares created by the `Shapes` object.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`For`循环的末尾，`box`矩阵包含了由`Shapes`对象创建的32个方块的32个唯一标识符。
- en: 'The program then animates the squares (lines 13–18), using a nested `For` loop
    to access the rows and the columns of `box`. During each iteration, we ask the
    `Shapes` object to animate one square (line 15) and then pause for a short time
    (line 16). The `Animate()` method takes four arguments: the identifier of the
    shape we want to animate, the x- and y-coordinates of the destination, and the
    animation duration in milliseconds. We ask the `Shapes` object to move each square
    to point (0, 0) in 1 second (1000 milliseconds).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 程序随后通过动画化方块（第13–18行），使用嵌套的`For`循环来访问`box`的行和列。在每次迭代中，我们请求`Shapes`对象动画化一个方块（第15行），然后暂停一段时间（第16行）。`Animate()`方法接受四个参数：我们要动画化的形状的标识符、目标的x和y坐标，以及动画持续时间（毫秒）。我们要求`Shapes`对象将每个方块在1秒（1000毫秒）内移动到点(0,
    0)。
- en: '**TRY IT OUT 17-2**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试一下 17-2**'
- en: Change the program in [Listing 17-2](ch17.html#ch17ex2) to animate the squares
    by columns instead of by rows. If you’re feeling artistic, try moving the squares
    to create a pattern in the graphics window.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 修改[清单17-2](ch17.html#ch17ex2)中的程序，通过列而不是行来动画化方块。如果你有艺术感觉，可以尝试移动方块，创建图形窗口中的一个图案。
- en: '***Using String Indices***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用字符串索引***'
- en: The previous examples used integer indices to access the elements of a matrix.
    Our next example teaches you how use strings for indices. You’ll examine an application
    that keeps track of students’ scores in different subjects.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例使用整数索引来访问矩阵的元素。我们的下一个示例将教你如何使用字符串作为索引。你将查看一个应用程序，它用于跟踪学生在不同科目中的成绩。
- en: 'Welcome to Professor Xavier’s School for Gifted Youngsters! The class has only
    three students right now: Scott, Jean, and Logan (the others are on an important
    mission). The school teaches only three subjects: math, science, and combat. Let’s
    write a program that prompts the user to enter a student’s name and then displays
    the student’s average score. The complete program is shown in [Listing 17-3](ch17.html#ch17ex3).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到教授Xavier的天才少年学校！目前班上只有三名学生：Scott、Jean和Logan（其他人正在执行一个重要任务）。学校只教授三门课程：数学、科学和战斗。让我们编写一个程序，提示用户输入学生的姓名，然后显示该学生的平均成绩。完整程序见[示例
    17-3](ch17.html#ch17ex3)。
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 17-3: Using strings for indices*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 17-3：使用字符串作为索引*'
- en: The program starts by initializing the `score` matrix with the scores of the
    three students (lines 2–10). Rows are indexed by the students’ names, and columns
    are indexed by the subjects. [Figure 17-5](ch17.html#ch17fig5) shows a visual
    representation of the `score` matrix.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 程序首先通过初始化`score`矩阵来设置三名学生的成绩（第2–10行）。行由学生的名字索引，列由科目索引。[图 17-5](ch17.html#ch17fig5)展示了`score`矩阵的可视化表示。
- en: '![image](graphics/f17-05.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f17-05.jpg)'
- en: '*Figure 17-5: The score matrix in [Listing 17-3](ch17.html#ch17ex3)*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-5：在[示例 17-3](ch17.html#ch17ex3)中的成绩矩阵*'
- en: The program prompts the user to enter a student’s name (line 12) and assigns
    the input to the `name` variable (line 13). It then pulls that student’s math
    score into the `sum` variable (line 14), adds the student’s science score to `sum`
    (line 15), and adds the student’s combat score (line 16). Finally, the program
    computes the average score (line 17) and displays it (line 18).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 程序提示用户输入学生的姓名（第12行），并将输入的值赋给`name`变量（第13行）。然后，程序将该学生的数学成绩存入`sum`变量（第14行），将该学生的科学成绩加到`sum`中（第15行），并加上学生的战斗成绩（第16行）。最后，程序计算平均成绩（第17行）并显示出来（第18行）。
- en: 'Here’s the output from a sample run:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例运行的输出：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The string index is case insensitive, which is why the program worked when we
    entered *scott* with a lowercase *s*. What do you think the output will be if
    you enter an invalid student name? Run the program to check your answer.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串索引不区分大小写，这就是为什么当我们输入小写的*scott*时程序仍然能正常工作。你觉得如果输入无效的学生姓名，程序会怎样输出？运行程序来验证你的答案。
- en: '**TRY IT OUT 17-3**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**动手实践 17-3**'
- en: Update the program in [Listing 17-3](ch17.html#ch17ex3) to display the score
    of a student in a given subject. Have the user enter the name of the student and
    the subject.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 更新[示例 17-3](ch17.html#ch17ex3)中的程序，以显示某学生在给定科目的成绩。让用户输入学生的姓名和科目。
- en: '***Going Interactive***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***互动环节***'
- en: 'Let’s explore how to get the students’ scores from the user rather than hardcoding
    them within the program like we did in [Listing 17-3](ch17.html#ch17ex3). We’ll
    use two loops to iterate over the students’ names and subjects, as shown in the
    following pseudocode (you’ll learn how to translate this pseudocode into real
    code in a moment):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一下如何从用户那里获取学生成绩，而不是像在[示例 17-3](ch17.html#ch17ex3)中那样将它们硬编码在程序中。我们将使用两个循环来遍历学生的姓名和科目，如下所示的伪代码（稍后你将学习如何将这个伪代码转化为真实的代码）：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can save the names of the students in a one-dimensional array, save the
    names of the subjects in another one-dimensional array, and then use nested `For`
    loops with integer indices to access the individual elements of these two arrays.
    Then you can use the strings (student name and subject) as indices for a `score`
    matrix. Check out [Listing 17-4](ch17.html#ch17ex4) to see the code in action.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将学生的名字保存在一个一维数组中，将科目的名字保存在另一个一维数组中，然后使用嵌套的`For`循环和整数索引来访问这两个数组的个别元素。接着，你可以使用字符串（学生名字和科目）作为`score`矩阵的索引。查看[示例
    17-4](ch17.html#ch17ex4)了解代码如何运作。
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 17-4: Reading scores from the user*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 17-4：从用户输入成绩*'
- en: The program starts by creating the name and subject arrays (lines 2–3). Then
    a nested loop starts to fill the `score` matrix. The outer loop iterates over
    the students, and the inner loop iterates over the subjects.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 程序首先创建学生姓名和科目数组（第2–3行）。然后，开始一个嵌套循环来填充`score`矩阵。外层循环遍历学生，内层循环遍历科目。
- en: The outer loop starts with `I = 1`. Here `name` gets assigned to `nameList[1]`,
    which is `"Scott"` (line 6). Then the inner loop runs three times, the first time
    with `J = 1`, and `subject` gets assigned to `subjList[1]`, which is `"Math"`
    (line 8). Line 9 displays `Scott's Math score:`, and line 10 waits for the user’s
    input. The number entered by the user is saved in `score["Scott"]["Math"]`, and
    the inner loop repeats for `J = 2`. Now `subject` gets assigned to `subjList[2]`,
    which is `"Science"`. The program displays `Scott's Science score:`, waits for
    the user’s input, stores the entered number in `score["Scott"]["Science"]`, and
    repeats the inner loop with `J = 3`. Now `subject` gets assigned to `subjList[3]`,
    which is `"Combat"`. The program displays `Scott's Combat score:`, waits for the
    user’s input, and stores the entered number in `score["Scott"]["Combat"]`. This
    ends the inner loop.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 外部循环从 `I = 1` 开始。在这里，`name` 被赋值为 `nameList[1]`，即 `"Scott"`（第6行）。然后，内部循环执行三次，第一次
    `J = 1`，`subject` 被赋值为 `subjList[1]`，即 `"Math"`（第8行）。第9行显示 `Scott's Math score:`，第10行等待用户输入。用户输入的数字被保存到
    `score["Scott"]["Math"]`，然后内部循环在 `J = 2` 时重复。现在 `subject` 被赋值为 `subjList[2]`，即
    `"Science"`。程序显示 `Scott's Science score:`，等待用户输入，将输入的数字存储在 `score["Scott"]["Science"]`，并在
    `J = 3` 时继续重复内部循环。现在 `subject` 被赋值为 `subjList[3]`，即 `"Combat"`。程序显示 `Scott's Combat
    score:`，等待用户输入，并将输入的数字存储在 `score["Scott"]["Combat"]` 中。这结束了内部循环。
- en: The outer loop repeats with `I = 2`. This sets `name` to `nameList[2]`, which
    is `"Jean"` and the inner loop works again to fill `score["Jean"]["Math"]`, `score["Jean"]["Science"]`,
    and `score["Jean"]["Combat"]`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 外部循环在 `I = 2` 时重复。这将 `name` 设置为 `nameList[2]`，即 `"Jean"`，然后内部循环再次运行，以填写 `score["Jean"]["Math"]`、`score["Jean"]["Science"]`
    和 `score["Jean"]["Combat"]`。
- en: The outer loop repeats with `I = 3`. This sets `name` to `nameList[3]`, which
    is `"Logan"`, and the inner loop works again to fill `score["Logan"]["Math"]`,
    `score["Logan"]["Science"]`, and `score["Logan"]["Combat"]`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 外部循环在 `I = 3` 时重复。这将 `name` 设置为 `nameList[3]`，即 `"Logan"`，然后内部循环再次运行，以填写 `score["Logan"]["Math"]`、`score["Logan"]["Science"]`
    和 `score["Logan"]["Combat"]`。
- en: Trace through this second version of the program to understand how it works.
    Thinking through what happens at each step is a great way to learn how matrices
    work!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪这个程序的第二个版本，理解它是如何工作的。思考每一步发生了什么是学习矩阵工作原理的好方法！
- en: '**TRY IT OUT 17-4**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试一下 17-4**'
- en: 'Replace the statements that find the `sum` (lines 15–17) in [Listing 17-4](ch17.html#ch17ex4)
    with a `For` loop, as shown in the following code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 将[清单17-4](ch17.html#ch17ex4)中用于计算 `sum` 的语句（第15-17行）替换为一个 `For` 循环，如下所示的代码片段：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Common Operations on Numerical 2D Arrays**'
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数字二维数组的常见操作**'
- en: 'In this section, we’ll develop a useful set of subroutines that can perform
    common operations on a 2D array made up of numbers. We’ll use the sales of a fake
    company, Duckberg Industries, whose December sales report is shown in [Figure
    17-6](ch17.html#ch17fig6). The company has four stores (Beddy Buyz, UBroke I.T.
    Emporium, LAN Lord’s Cyber Store, and Mother Bored Electronics) and sells five
    types of products: Exploding Shoes (eShoes), the iShirt Computer (iShirt), Shampoop,
    Dehydrated Water (dWater), and the Invisible Hat (iHat). The numbers are the sales
    of each product in thousands.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一套有用的子程序，能够对由数字组成的二维数组执行常见操作。我们将使用一个虚构公司 Duckberg Industries 的销售数据，该公司12月的销售报告如[图17-6](ch17.html#ch17fig6)所示。该公司有四家门店（Beddy
    Buyz、UBroke I.T. Emporium、LAN Lord’s Cyber Store 和 Mother Bored Electronics），销售五种类型的产品：爆炸鞋（eShoes）、iShirt
    计算机（iShirt）、Shampoop、脱水水（dWater）和隐形帽子（iHat）。这些数字代表每种产品的销售额（单位：千元）。
- en: '![image](graphics/f17-06.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f17-06.jpg)'
- en: '*Figure 17-6: Duckberg Industries’ December sales report*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-6：Duckberg Industries 12月销售报告*'
- en: 'Open the file *Duckberg_Incomplete.sb* from this chapter’s folder. The file
    contains the data in [Figure 17-6](ch17.html#ch17fig6) in a sequence of statements
    that looks like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 打开本章文件夹中的 *Duckberg_Incomplete.sb* 文件。该文件包含[图17-6](ch17.html#ch17fig6)中的数据，形式如下：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The program also defines the following variables:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 程序还定义了以下变量：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Follow the instructions in the next two sections to complete the program.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 按照接下来的两节中的指示完成程序。
- en: '***Step 1: Add All Elements***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤1：添加所有元素***'
- en: Donald, the company’s sales manager, wants to know the total sales of the company.
    You need to add all the numbers in the `sales` matrix. The `TotalSales()` subroutine
    in [Listing 17-5](ch17.html#ch17ex5) shows you how to do that.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 销售经理 Donald 想知道公司总销售额。你需要将 `sales` 矩阵中的所有数字相加。[清单17-5](ch17.html#ch17ex5)中的
    `TotalSales()` 子程序展示了如何完成此操作。
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 17-5: Adding all numbers in a matrix*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-5：对矩阵中的所有数字求和*'
- en: You start by initializing the `sum` variable (which holds the running sum) to
    0 (line 2). You then use a nested loop to iterate over all the rows and columns
    (lines 3–4). For each iteration, you add the number stored in `sales[r][c]` to
    `sum` (line 5). When the outer loop ends, you display the result followed by `K`
    for thousands (line 8).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先将 `sum` 变量（用于保存运行总和）初始化为 0（第 2 行）。然后你使用嵌套循环遍历所有行和列（第 3–4 行）。对于每次迭代，你将 `sales[r][c]`
    中存储的数字加到 `sum` 上（第 5 行）。当外部循环结束时，你显示结果，并在后面加上 `K` 表示千位（第 8 行）。
- en: 'Add this subroutine to the program, and then add a statement to call it. Here’s
    what you should see when you call the `TotalSales()` subroutine:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将此子程序添加到程序中，然后添加语句以调用它。以下是当你调用 `TotalSales()` 子程序时应该看到的结果：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***Step 2: Find the Sum of Each Column***'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 2：计算每列的总和***'
- en: Donald also wants to see the total sales for each Duckberg Industries product.
    He needs to compare these numbers with those from his competitors to assess his
    company’s market share.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Donald 还想查看每个 Duckberg Industries 产品的总销售额。他需要将这些数字与竞争对手的销售额进行对比，以评估他公司在市场中的份额。
- en: To give Donald this information, you’ll use the `ColumnSum()` subroutine in
    [Listing 17-6](ch17.html#ch17ex6) to compute the sum of each column in the `sales`
    matrix.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给 Donald 提供这些信息，你将使用[清单 17-6](ch17.html#ch17ex6)中的 `ColumnSum()` 子程序来计算 `sales`
    矩阵中每一列的总和。
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 17-6: The* `ColumnSum()` *subroutine*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-6：`ColumnSum()` 子程序*'
- en: 'You start the outer loop to iterate over the five columns (line 2). For each
    column (each value of `c`), you initialize the column’s `sum` to 0 (line 3) and
    then start a `For` loop to add the numbers from all the rows in that column to
    `sum` (lines 4–6). When the inner loop completes, you get the name of the current
    product (from `product[c]`), append `"Sales: $"` to it, and save the resulting
    string in `colName` (line 7). In line 8, you display that string followed by the
    sum you just computed. The outer loop then restarts to find and display the sum
    for the next column.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '你开始外部循环，遍历五列（第 2 行）。对于每一列（每个 `c` 的值），你将该列的 `sum` 初始化为 0（第 3 行），然后启动一个 `For`
    循环，将该列所有行的数字累加到 `sum`（第 4–6 行）。当内部循环结束时，你获取当前产品的名称（从 `product[c]` 中），在它后面附加 `"Sales:
    $"`，并将结果字符串保存在 `colName` 中（第 7 行）。在第 8 行，你显示该字符串，并显示你刚刚计算的总和。外部循环然后重新开始，计算并显示下一列的总和。'
- en: 'Add this subroutine to the program, and then add a statement to call it. Here’s
    what you should see when you call the `ColumnSum()` subroutine:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将此子程序添加到程序中，然后添加语句以调用它。以下是当你调用 `ColumnSum()` 子程序时应该看到的结果：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**TRY IT OUT 17-5**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**动手试一试 17-5**'
- en: Donald wants to review the performance of his four stores by comparing the total
    sales of each store. Write a subroutine, `RowSum()`, that calculates and displays
    the sum for each row of the `sales` matrix.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Donald 想通过比较每个商店的总销售额来回顾他四家店的业绩。编写一个子程序 `RowSum()`，计算并显示 `sales` 矩阵中每一行的总和。
- en: '**Arrays of Three or More Dimensions**'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**三维或更高维度的数组**'
- en: You’ve learned that using 2D arrays is a convenient way to represent a table
    or a matrix. Small Basic also supports arrays with more than two dimensions. You
    can extend the syntax for creating 2D arrays to create arrays with even higher
    dimensions. Next we’ll explore how to create *three-dimensional (3D)* arrays in
    Small Basic.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解到，使用 2D 数组是一种表示表格或矩阵的方便方式。Small Basic 还支持多于两维的数组。你可以扩展创建 2D 数组的语法，来创建更高维度的数组。接下来我们将探讨如何在
    Small Basic 中创建*三维 (3D)* 数组。
- en: Let’s work with a shelf that has five racks. Each rack has three rows and four
    columns, and each position on the shelf has a box that contains screws of a certain
    size. Look at [Figure 17-7](ch17.html#ch17fig7) and imagine boxes of different
    screw sizes in each column and row (that’s 12 boxes). Then imagine that same number
    of boxes on all five racks. That’s 60 boxes in total!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来操作一个有五个架子的货架。每个架子有三行四列，每个位置上都有一个盒子，盒子中包含不同大小的螺丝。看看[图 17-7](ch17.html#ch17fig7)，并想象每一列和每一行中都有不同大小的螺丝盒子（总共是
    12 个盒子）。接着想象所有五个架子上都有同样数量的盒子。这样总共有 60 个盒子！
- en: '![image](graphics/f17-07.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f17-07.jpg)'
- en: '*Figure 17-7: Visualizing a 3D array*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-7：可视化 3D 数组*'
- en: We’ll examine a program that fills each box with a random number that indicates
    the size of the screws in that box. The program is shown in [Listing 17-7](ch17.html#ch17ex7).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一个程序，该程序为每个盒子填充一个随机数，表示该盒子中螺丝的大小。程序展示在[清单 17-7](ch17.html#ch17ex7)中。
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 17-7: Demonstrating the syntax for 3D arrays*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-7：演示 3D 数组的语法*'
- en: 'This program creates a 3D array named `box`. Its elements are indexed with
    three subscripts: `rack` runs from 1 to 5 (line 2), `row` runs from 1 to 3 (line
    3), and `col` runs from 1 to 4 (line 4). This array has 60 elements (5×4×3), just
    like the shelf in the example. Line 5 uses the syntax `box[rack] [row][col]` to
    access the box in rack number `rack`, row number `row`, and column number `col`,
    and it puts a random number in that box.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序创建了一个名为`box`的三维数组。它的元素使用三个下标来索引：`rack`的范围是1到5（第2行），`row`的范围是1到3（第3行），`col`的范围是1到4（第4行）。这个数组有60个元素（5×4×3），就像示例中的架子一样。第5行使用语法`box[rack]
    [row][col]`来访问编号为`rack`的架子、编号为`row`的行和编号为`col`的列中的盒子，并在该盒子中放入一个随机数。
- en: Notice that another nested `For` loop is used, but in this example, we nested
    three `For` loops instead of just two (lines 2–4). Generally, you’ll need to use
    one `For` loop per dimension in your higher-dimension array; as a result, you’ll
    be able to access every element in your array!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用了另一个嵌套的`For`循环，不过在这个例子中，我们嵌套了三个`For`循环，而不仅仅是两个（第2–4行）。通常，你需要为高维数组的每个维度使用一个`For`循环；这样，你就能够访问数组中的每一个元素！
- en: In the next section, you’ll use what you’ve learned so far to create an exciting
    treasure game. Get ready for another adventure!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，你将运用迄今为止学到的知识，创建一个激动人心的寻宝游戏。准备好迎接又一次冒险吧！
- en: '**TRY IT OUT 17-6**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**试试 17-6**'
- en: 'Write a program that displays the output of the `box` array in [Listing 17-7](ch17.html#ch17ex7).
    Your output should have the following format:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，显示[清单 17-7](ch17.html#ch17ex7)中`box`数组的输出。你的输出应该具有以下格式：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Create a Treasure Map Game**'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建一个寻宝游戏**'
- en: You woke up one morning and found you were alone on an island. A treasure map
    and an old compass were lying next to you. You could hardly hold back your excitement!
    You decided to look for the treasure. [Figure 17-8](ch17.html#ch17fig8) shows
    a sample map of the island.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你某天早晨醒来，发现自己孤身一人在一个岛屿上。旁边有一张藏宝图和一只旧指南针。你几乎抑制不住兴奋的心情！你决定去寻找宝藏。[图17-8](ch17.html#ch17fig8)展示了岛屿的示例地图。
- en: '![image](graphics/f17-08.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f17-08.jpg)'
- en: '*Figure 17-8: The user interface for the Treasure Map game*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-8：寻宝游戏的用户界面*'
- en: You can move north, east, south, or west, one block at a time. But because the
    compass is old, it might lead you in the wrong direction. For example, if you
    go north or south, there’s a 20 percent chance that you’ll also move one block
    to the left or to the right. And if you go east or west, there’s a 20 percent
    chance that you’ll also move one block up or down. Each time you move, you’ll
    receive information about your current location. The game ends if you find the
    treasure or if you fall in the water where the hungry sharks are waiting! Don’t
    think of *Jaws* while you’re playing this game! (Sorry, that probably didn’t help.)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以每次移动一格，向北、东、南或西。但由于指南针很旧，它可能会把你指向错误的方向。例如，如果你向北或向南走，有20%的概率你还会向左或向右移动一格。如果你向东或向西走，也有20%的概率你会向上或向下移动一格。每次移动时，你会收到关于当前位置的信息。如果你找到了宝藏，或者不小心掉进了有饥饿鲨鱼等待的水域，游戏就结束了！在玩这个游戏时不要想起*大白鲨*！（抱歉，这可能没什么帮助。）
- en: Because you have the treasure map in your hands, you should be able to guess
    your location. For example, let’s say you’re in a forest, and when you click the
    S button to go south, the game tells you you’re now next to a volcano. Looking
    at the map, you can figure out that the treasure is just two blocks west.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你手中有藏宝图，你应该能够猜出自己的位置。例如，假设你在一片森林中，当你点击 S 按钮向南走时，游戏告诉你你现在站在一个火山旁边。看着地图，你可以推测出宝藏就在西边两格远的地方。
- en: The following sections will guide you step-by-step to show you how to put this
    game together. Adventure awaits!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将一步步指导你如何将这个游戏拼凑起来。冒险在等待着你！
- en: '***Step 1: Open the Startup File***'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 1：打开启动文件***'
- en: Open the *TreasureMap_Incomplete.sb* file from this chapter’s folder. This file
    contains some comments and placeholders for the required subroutines. You’ll add
    all the code one step at a time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 打开本章文件夹中的*TreasureMap_Incomplete.sb*文件。该文件包含一些注释和占位符，供你填写所需的子程序。你将一步步添加所有的代码。
- en: This folder also contains the eight images you’ll use. *Background.png* is a
    580×450 image of the game’s background, and the seven 32×32 icons are the different
    objects on the treasure map.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹还包含了你将使用的八张图片。*Background.png*是游戏背景的580×450像素图像，另外七个32×32像素的图标代表藏宝图上的不同物体。
- en: '**NOTE**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you run into any problems, check out the finished program* TreasureMap.sb,
    *which is also included in this chapter’s folder.*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你遇到问题，可以查看完成的程序* TreasureMap.sb，*它也包含在本章的文件夹中。*'
- en: '***Step 2: Create the GUI Elements***'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 2：创建 GUI 元素***'
- en: Add the code in [Listing 17-8](ch17.html#ch17ex8) to initialize the `GraphicsWindow`
    and create the controls (buttons and text shapes) for the game.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 [清单 17-8](ch17.html#ch17ex8) 中的代码来初始化 `GraphicsWindow` 并创建游戏的控件（按钮和文本形状）。
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 17-8: Initializing* `GraphicsWindow`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-8：初始化* `GraphicsWindow`'
- en: Lines 1–6 set the properties of `GraphicsWindow`. Lines 9–11 create and position
    the text that tells the player their current position on the island, and lines
    14–19 create the five buttons (see [Figure 17-8](ch17.html#ch17fig8)). Line 21
    registers a handler to process the buttons, and line 23 calls `NewGame()` to start
    a new game.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第 1 行到第 6 行设置 `GraphicsWindow` 的属性，第 9 行到第 11 行创建并定位显示玩家当前在岛上位置的文本，第 14 行到第
    19 行创建五个按钮（见 [图 17-8](ch17.html#ch17fig8)）。第 21 行注册一个处理程序来处理按钮，第 23 行调用 `NewGame()`
    来开始新游戏。
- en: '***Step 3: Start a New Game***'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 3：开始新游戏***'
- en: Now you’ll add the `NewGame()` subroutine. This subroutine (shown in [Listing
    17-9](ch17.html#ch17ex9)) is called when the player clicks the New Game button.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将添加 `NewGame()` 子程序。该子程序（见 [清单 17-9](ch17.html#ch17ex9)）在玩家点击“新游戏”按钮时被调用。
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 17-9: The* `NewGame()` *subroutine*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-9：* `NewGame()` *子程序*'
- en: You set the `gameOver` flag to 0 because the game isn’t over yet (line 2). You
    also set `moveNumber` to 0 because the player hasn’t made any moves yet (line
    3). You then find the program’s path and assign it to the `path` variable. You’ll
    use this variable when you draw the different icons on the treasure map. In line
    6, you draw a new copy of the background image to erase the previous map. You
    then call `CreateNewMap()` to create and draw a new treasure map (line 7) and
    call `ShowLocation()` to give feedback to the player about their current location
    on the island (line 8). `ShowLocation()` updates the text message to describe
    the player’s new location after they move. You’ll add these subroutines next.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你将 `gameOver` 标志设置为 0，因为游戏还没有结束（第 2 行）。你还将 `moveNumber` 设置为 0，因为玩家还没有进行任何移动（第
    3 行）。接下来，你会找到程序的路径并将其赋值给 `path` 变量。你将使用这个变量在藏宝图上绘制不同的图标。在第 6 行，你会绘制一个新的背景图像来擦除之前的地图。然后，你会调用
    `CreateNewMap()` 来创建并绘制新的藏宝图（第 7 行），并调用 `ShowLocation()` 来反馈玩家在岛上的当前位置（第 8 行）。`ShowLocation()`
    更新文本信息，以描述玩家移动后的新位置。你接下来将添加这些子程序。
- en: '***Step 4: Create a New Treasure Map***'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 4：创建新的藏宝图***'
- en: The `CreateNewMap()` subroutine builds a 10×10 array to represent the treasure
    map. Each element in the array stores a number between 0 and 7\. The number 0
    means clear, 1 means grass, 2 means forest, 3 means volcano, 4 means cave, 5 means
    rain, 6 means flowers, and 7 means treasure. The `CreateNewMap()` subroutine is
    shown in [Listing 17-10](ch17.html#ch17ex10).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateNewMap()` 子程序构建了一个 10×10 的数组来表示藏宝图。数组中的每个元素存储一个 0 到 7 之间的数字。数字 0 表示空地，1
    表示草地，2 表示森林，3 表示火山，4 表示洞穴，5 表示雨，6 表示花朵，7 表示宝藏。`CreateNewMap()` 子程序的代码见 [清单 17-10](ch17.html#ch17ex10)。'
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 17-10: The* `CreateNewMap()` *subroutine*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-10：* `CreateNewMap()` *子程序*'
- en: First, you set all the elements of the map to 0 (lines 2–6). In line 8, you
    define an array, `objId`, that holds the identifiers of the objects you’ll add
    to the map. This array asks for eight grass fields, eight forests, two volcanoes,
    two caves, two rainy spots, two flower fields, and one treasure spot. The last
    element in the array is intentionally set to 0 so that the `While` loop on line
    10 finds an empty starting place for the player. When you’re feeling more adventurous,
    you can change the `objId` array to make the treasure map contain more or fewer
    objects.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将地图的所有元素设置为 0（第 2 行到第 6 行）。在第 8 行，你定义了一个数组 `objId`，该数组保存你将添加到地图中的对象标识符。这个数组要求八个草地、八个森林、两个火山、两个洞穴、两个雨区、两个花地和一个宝藏点。数组中的最后一个元素被故意设置为
    0，以便第 10 行的 `While` 循环能够找到玩家的空白起始位置。当你想要更具冒险精神时，可以修改 `objId` 数组，使藏宝图包含更多或更少的对象。
- en: Next, you start a `While` loop to add the objects to the treasure map. First,
    you select a random cell on the map (lines 11–12). If that cell is clear (line
    13), you mark it with a number that’s not zero to reserve it for the next object
    from `objId` (line 14), call `DrawObject()` to draw the added object on the treasure
    map (line 15), and increment the `count` variable to point to the next element
    in `objId` (line 16). When the loop finishes, you set the player’s current row,
    `rowP`, and column, `colP`, to the empty cell found by the `While` loop in its
    last iteration (lines 20–21). This ensures the player starts on a clear cell on
    the map.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你开始一个`While`循环，将物体添加到藏宝图中。首先，你选择地图上的一个随机单元格（第11-12行）。如果该单元格为空（第13行），你用非零的数字标记它，以便为下一个来自`objId`的物体保留该位置（第14行），然后调用`DrawObject()`在藏宝图上绘制该物体（第15行），并递增`count`变量，指向`objId`中的下一个元素（第16行）。当循环完成时，你将玩家的当前行`rowP`和列`colP`设置为`While`循环最后一次迭代中找到的空单元格（第20-21行）。这样可以确保玩家从地图上的空单元格开始。
- en: '***Step 5: Draw Objects on the Map***'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤5：在地图上绘制物体***'
- en: Before you add the `ShowLocation()` subroutine, you need to add the `DrawObject()`
    subroutine in [Listing 17-11](ch17.html#ch17ex11). You call this subroutine to
    draw an object at `map[row][col]`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在你添加`ShowLocation()`子例程之前，需要先在[清单17-11](ch17.html#ch17ex11)中添加`DrawObject()`子例程。你调用这个子例程来在`map[row][col]`的位置绘制物体。
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 17-11: The* `DrawObject()` *subroutine*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单17-11：* `DrawObject()` *子例程*'
- en: You define the `imgName` array that holds the name of the image file for the
    seven objects in the game (line 2). In line 4, you get the number stored in the
    map at row number `row` and column number `col`, and then you assign this value
    to `imgID`. If this number is between 1 and 7 (line 5), you construct the full
    path for the image that corresponds to this number (line 6) and then draw that
    image at its position on the map (lines 8–10). The numbers you see in lines 8–9
    (52, 38, and 25) come from the background image. These numbers ensure that the
    objects are drawn in the centers of the cells in [Figure 17-8](ch17.html#ch17fig8).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义了`imgName`数组，用于存储游戏中七个物体的图像文件名（第2行）。在第4行，你获取存储在地图上行号为`row`、列号为`col`的单元格中的数字，然后将该值赋给`imgID`。如果该数字介于1和7之间（第5行），你会构建对应数字的图像完整路径（第6行），并将该图像绘制在地图上的相应位置（第8-10行）。你在第8-9行看到的数字（52、38和25）来自背景图像。这些数字确保物体被绘制在[图17-8](ch17.html#ch17fig8)中单元格的中心。
- en: '***Step 6: Show the Player’s Location***'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤6：显示玩家位置***'
- en: Now you can add the `ShowLocation()` subroutine in [Listing 17-12](ch17.html#ch17ex12),
    which tells the player their current location on the island.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在[清单17-12](ch17.html#ch17ex12)中添加`ShowLocation()`子例程，它会告诉玩家他们在岛上的当前位置。
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 17-12: The* `ShowLocation()` *subroutine*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单17-12：* `ShowLocation()` *子例程*'
- en: The subroutine uses an `If/ElseIf` ladder to create a message, `msg`, based
    on the player’s current location, which is identified by `rowP` and `colP` (lines
    1–20). The subroutine then calls `SetText()` to show this message using the text
    shape identified by `txtID`. Note how the player’s move number, `moveNumber`,
    is included in the message so they know how many times they’ve moved.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 该子例程使用`If/ElseIf`结构根据玩家当前的位置创建一条信息`msg`，该位置由`rowP`和`colP`标识（第1-20行）。然后，子例程调用`SetText()`通过由`txtID`标识的文本形状显示这条信息。注意信息中包含了玩家的移动次数`moveNumber`，这样玩家就能知道他们移动了多少次。
- en: '***Step 7: Handle Button Clicks***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤7：处理按钮点击事件***'
- en: This is the final step to finish the game! You just need to process the button
    clicks. Add the `OnButtonClicked()` subroutine shown in [Listing 17-13](ch17.html#ch17ex13).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完成游戏的最后一步！你只需要处理按钮点击事件。添加在[清单17-13](ch17.html#ch17ex13)中显示的`OnButtonClicked()`子例程。
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 17-13: The* `OnButtonClicked()` *subroutine*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单17-13：* `OnButtonClicked()` *子例程*'
- en: Because you’re using five buttons, you start by finding the identifier of the
    clicked button (line 2). If it’s the New Game button (line 4), you call `NewGame()`
    to start all over (line 5). Otherwise, the player has clicked one of the four
    movement buttons. You need to process the player’s request only if the game isn’t
    over yet. If the game is still in progress (line 6), you increment `moveNumber`
    (line 7), call `MovePlayer()` to set the player’s new location (line 9), and then
    check the status after this move (lines 11–16). If the player falls into the shark-infested
    water (line 11), you set `gameOver` to 1 (line 12) and inform the player of their
    bad luck (line 13). Otherwise, if the player is still on the island, you call
    `ShowLocation()` to give them information about their new location (line 15).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你使用了五个按钮，首先你需要找到被点击按钮的标识符（第2行）。如果是“新游戏”按钮（第4行），你调用`NewGame()`来重新开始（第5行）。否则，玩家点击了四个移动按钮中的一个。只有在游戏尚未结束时，你才需要处理玩家的请求。如果游戏仍在进行中（第6行），你增加`moveNumber`（第7行），调用`MovePlayer()`来设置玩家的新位置（第9行），然后检查此移动后的状态（第11行至第16行）。如果玩家掉入了鲨鱼出没的水域（第11行），你将`gameOver`设为1（第12行），并通知玩家他们的运气不好（第13行）。否则，如果玩家仍然在岛上，你调用`ShowLocation()`来提供他们新位置的信息（第15行）。
- en: The last subroutine you need to add in this game is in [Listing 17-14](ch17.html#ch17ex14).
    The `MovePlayer()` subroutine sets the player’s next position based on which button
    (N, E, S, or W) they clicked.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在这个游戏中添加的最后一个子程序位于[示例 17-14](ch17.html#ch17ex14)。`MovePlayer()`子程序根据玩家点击的按钮（N、E、S或W）设置玩家的下一个位置。
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 17-14: The* `MovePlayer()` *subroutine*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 17-14：* `MovePlayer()` *子程序*'
- en: We mentioned that the old compass has a 20 percent chance of being wrong. To
    simulate this, you create the variable `shift` to alter the player’s direction.
    First, you get a random number between 1 and 10 (line 3). If this number is 1,
    you set `shift` to 1\. If this number is 2, you set `shift` to –1 (lines 4–8).
    Otherwise, you keep `shift` at 0, which means that you won’t alter the player’s
    move in any way (line 2).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过旧指南针有20%的可能性会出错。为了模拟这一点，你创建了变量`shift`来改变玩家的方向。首先，你生成一个介于1到10之间的随机数（第3行）。如果这个数字是1，你将`shift`设为1。如果这个数字是2，你将`shift`设为–1（第4行至第8行）。否则，你将保持`shift`为0，这意味着你不会改变玩家的移动（第2行）。
- en: You start an `If/ElseIf` ladder to process the clicked button (lines 10–22).
    If the player clicked the north button N (line 10), you move them up one row (line
    11) and change their current column by using the `shift` variable (line 12). If
    `shift` is 0, the player’s current column won’t change, and they’ll move north.
    The rest of the ladder works the same way.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你开始使用`If/ElseIf`阶梯来处理被点击的按钮（第10行至第22行）。如果玩家点击了北方按钮N（第10行），你将他们向上移动一行（第11行），并使用`shift`变量改变他们当前的列（第12行）。如果`shift`为0，玩家的当前列不会改变，他们将向北移动。阶梯的其余部分以相同方式工作。
- en: Now that the game is complete, you can enjoy it. See how long it takes you to
    find the treasure without getting eaten by the sharks!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏完成了，你可以尽情享受。看看你需要多长时间才能找到宝藏而不被鲨鱼吃掉！
- en: '**TRY IT OUT 17-7**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试一下 17-7**'
- en: The Treasure Map game has a lot of room for improvement. For example, you can
    give the player another chance if they fall victim to the sharks. You can also
    give the player more clues about their current location. Come up with some ideas
    to improve the game, and try to implement them. Make an adventure worthy of Captain
    Jack Sparrow!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 《寻宝图》游戏还有很多可以改进的地方。例如，如果玩家掉进鲨鱼的陷阱，你可以给他们另一次机会。你还可以提供更多关于玩家当前位置的线索。想出一些点子来改进游戏，并尝试实施它们。打造一场值得杰克·斯派罗船长参与的冒险！
- en: '**Programming Challenges**'
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程挑战**'
- en: If you get stuck, check out *[http://nostarch.com/smallbasic/](http://nostarch.com/smallbasic/)*
    for the solutions and for more resources and review questions for teachers and
    students.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到困难，可以查看 *[http://nostarch.com/smallbasic/](http://nostarch.com/smallbasic/)*，了解解决方案以及更多资源和针对教师与学生的复习问题。
- en: 'Okla is a fearless warrior known for his courage and wisdom. He’s now on a
    noble mission in a haunted castle looking for the four keys needed to free the
    puppies that are trapped inside! But there’s a problem: the haunted castle is
    guarded by evil monsters who throw bombs all over the castle. Each time one of
    these bombs hits Okla, he loses 10 units of energy. You need to help Okla navigate
    his way through the castle to find the four keys before he loses all his energy.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Okla 是一位无畏的战士，以勇气和智慧著称。他现在正在一个闹鬼的城堡中执行一项高尚的任务，寻找四把钥匙，以解救被困在里面的小狗！但问题来了：这个闹鬼的城堡被邪恶的怪物守卫着，怪物会到处扔炸弹。每当这些炸弹击中
    Okla 时，他会失去 10 点能量。你需要帮助 Okla 穿越城堡，在他失去所有能量之前找到四把钥匙。
- en: '![image](graphics/f0260-01.jpg)'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](graphics/f0260-01.jpg)'
- en: Open the file *Okla.sb* from this chapter’s folder, and run it to play the game.
    After you play the game and understand how it works, come up with some ideas to
    improve it, and try to implement them.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开本章文件夹中的 *Okla.sb* 文件，并运行它来玩游戏。在玩完游戏并理解其运行方式后，想出一些改进的想法，并尝试实现它们。
- en: Open the file *TicTacToe_Incomplete.sb* from this chapter’s folder. This game
    lets you play tic-tac-toe against the computer. The game’s board is represented
    by a 3×3 matrix named `board`. When the player clicks a square, the game draws
    an X in the clicked cell and fills the number 1 in its `board` element. The computer
    then takes its turn and picks an empty cell at random (the computer isn’t that
    smart). The game draws an O in the cell the computer selected and fills in the
    number 5 in that `board` element. The following figure illustrates how the game
    works.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开本章文件夹中的 *TicTacToe_Incomplete.sb* 文件。这个游戏让你与计算机进行井字游戏对战。游戏的棋盘由一个名为 `board`
    的 3×3 矩阵表示。当玩家点击一个方格时，游戏会在该格子中绘制一个 X，并在其 `board` 元素中填入数字 1。接着，计算机会轮到自己并随机选择一个空格（计算机并不是那么聪明）。游戏会在计算机选定的格子中绘制一个
    O，并在该 `board` 元素中填入数字 5。下图展示了游戏的运行方式。
- en: '![image](graphics/f0261-01.jpg)'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](graphics/f0261-01.jpg)'
- en: Your task is to complete the `CheckWinner()` subroutine, which is called after
    each move. You need to check the sum of each row, each column, and the two diagonals.
    A sum of 3 means the player won the game. A sum of 15 means the computer won the
    game. If there’s no winner and nine moves have been made (the board is filled
    completely with the Xs and Os), the game is a tie.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的任务是完成 `CheckWinner()` 子程序，该子程序会在每次移动后被调用。你需要检查每一行、每一列和两个对角线的和。和为 3 表示玩家赢得了游戏。和为
    15 表示计算机赢得了游戏。如果没有赢家并且已经进行了九次移动（棋盘已完全填满 X 和 O），则游戏为平局。
