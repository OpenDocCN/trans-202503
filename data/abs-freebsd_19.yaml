- en: '**19'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**19'
- en: ADVANCED SECURITY FEATURES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级安全特性**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: FreeBSD includes a variety of tools for securing network traffic and users.
    Some of these tools are invisible to sysadmins but work behind the scenes to increase
    security, such as the sandboxing API capsicum(4). Packet filtering lets you control
    who can access your system. You can also use blacklisting to block network addresses
    that keep poking at your host. In addition, FreeBSD has a whole bunch of optional
    security features you can enable either in the installation process or later.
    In this chapter, we’ll examine these tools and techniques, look at monitoring
    your system’s security, and discuss how to react if you suffer an intrusion.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 提供了多种工具来保护网络流量和用户。一些工具对系统管理员是不可见的，但它们在后台工作以增加安全性，例如沙箱 API capsicum(4)。数据包过滤使你可以控制谁可以访问你的系统。你还可以使用黑名单来阻止那些不断攻击你主机的网络地址。此外，FreeBSD
    还拥有一整套可选的安全特性，你可以在安装过程中或稍后启用。在本章中，我们将研究这些工具和技术，了解如何监控系统的安全性，并讨论如果遭遇入侵该如何应对。
- en: 'Let’s start with a core security topic: unprivileged users.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个核心安全话题开始：非特权用户。
- en: '**Unprivileged Users**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**非特权用户**'
- en: An *unprivileged user* is a specific user for a specific task. He has only the
    rights necessary to perform that limited task. Many programs run as unprivileged
    users or use unprivileged users to perform specific duties.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*非特权用户*是为特定任务创建的特定用户。他只有执行该有限任务所需的权限。许多程序作为非特权用户运行，或使用非特权用户执行特定职责。'
- en: “Only the rights needed to perform its duties” sounds like every user account,
    doesn’t it? That’s true, but the account used by the least privileged human being
    still has more rights than many programs need. Anyone with shell access has a
    home directory. The normal user may create files in their home directory, run
    text editors, or process email. Your average shell user needs these minimal privileges,
    but programs do not. By having a program, particularly a network daemon, run as
    a very restricted user, you control the amount of damage an intruder can do to
    either the program or the user.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: “只有执行职责所需的权限”听起来像是每个用户账户的要求，不是吗？确实如此，但即便是最低权限的人类用户所使用的账户，仍然比许多程序所需的权限要多。任何拥有
    shell 访问权限的用户都有一个家目录。普通用户可以在其家目录中创建文件、运行文本编辑器或处理电子邮件。普通 shell 用户需要这些最小权限，但程序不需要。通过让程序，特别是网络守护进程，以一个非常受限的用户身份运行，你可以控制入侵者对程序或用户造成的损害。
- en: FreeBSD includes several unprivileged users. Take a look at */etc/passwd* and
    you’ll see accounts like *audit*, *bind*, *uucp*, and *www*. These are all unprivileged
    accounts for use by specific server daemons. See what they have in common.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 包括几个非特权用户。查看 */etc/passwd*，你会看到像 *audit*、*bind*、*uucp* 和 *www* 这样的账户。这些都是为特定服务器守护进程使用的非特权账户。看看它们有什么共同点。
- en: Unprivileged users don’t have normal home directories. Many have a home directory
    of */nonexistent*, while others, such as *sshd*, have a special home directory
    such as */var/empty*. Having a home directory where you may not write or read
    files makes the account less flexible but good enough for a server daemon. These
    users do own files on the system, but they usually can’t write to those files.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 非特权用户没有正常的家目录。许多用户的家目录是 */nonexistent*，而其他一些用户，如 *sshd*，则有一个特殊的家目录，如 */var/empty*。拥有一个无法写入或读取文件的家目录虽然使账户的灵活性降低，但对于服务器守护进程来说已经足够。虽然这些用户确实拥有系统上的文件，但通常无法修改这些文件。
- en: Similarly, nobody should ever log into these accounts. If the account *bind*
    is reserved for the DNS system, nobody should actually log into the system as
    that user! Such an account must have a user shell that specifically denies logging
    in, like */usr/sbin/nologin*. How does all this enhance system security? Let’s
    look at an example.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，任何人都不应该登录这些账户。如果账户*bind*是为DNS系统保留的，那么实际上也不应该以该用户身份登录系统！这样的账户必须具有专门拒绝登录的用户
    shell，例如 */usr/sbin/nologin*。这一切是如何增强系统安全性的呢？让我们看一个例子。
- en: Whatever web server you’re using, it generally runs under the unprivileged account
    *www*. Suppose that an intruder discovered a security flaw in the version of the
    web server program you’re using and can make the web server execute arbitrary
    code. This is among the worst types of security problems, where an intruder can
    make the server program do absolutely anything within its power. What *is* within
    this program’s power?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用的是哪个 Web 服务器，它通常都会在未授权账户 *www* 下运行。假设入侵者发现了你正在使用的 Web 服务器程序版本中的安全漏洞，并且能够让
    Web 服务器执行任意代码。这是最糟糕的安全问题之一，因为入侵者可以让服务器程序做它有能力做的任何事。那么，这个程序的能力究竟是什么呢？
- en: The intruder probably wants a command prompt on the system. A command prompt
    on a Unix-like system is the door to so much more access, after all. The unprivileged
    user has an assigned shell that specifically disallows logins. This really annoys
    intruders and requires them to work much harder to reach that command prompt.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 入侵者可能想要在系统上获得一个命令提示符。毕竟，在类 Unix 系统上，命令提示符是进入更多访问权限的门槛。未授权用户拥有一个专门不允许登录的 shell。这会让入侵者非常恼火，迫使他们付出更多努力才能达到命令提示符。
- en: If she’s really clever, though, the nologin shell won’t stop the intruder. Let’s
    assume that through clever trickery she makes the web server execute a simple
    shell, such as */bin/sh*, and offer her the prompt. She’s in and can wreak untold
    damage . . . or can she?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，如果她真的足够聪明，nologin shell 并不会阻止入侵者。假设通过巧妙的手段，她让 Web 服务器执行一个简单的 shell，比如 */bin/sh*，并向她提供命令提示符。她进来了，可以造成无法估量的破坏……或者她能做到吗？
- en: She has no home directory and doesn’t have permissions to create one. That means
    that any files she wants to store must go in a globally accessible directory,
    such as */tmp* or */var/tmp*, increasing her visibility. The Apache configuration
    file is owned by root or by your web server administration group, and the *www*
    user isn’t part of that group. The intruder might have a path into the web server,
    but she can’t reconfigure it. She can’t change the website files, as the *www*
    user doesn’t own them. The *www* user doesn’t have access to anything on the system
    except the web server itself. A sufficiently skilled intruder can make the web
    server serve up different pages or redirect to another site, at least until a
    reboot. Penetrating the application running on the server, or the host itself,
    requires another whole set of security breaches.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 她没有主目录，也没有权限创建一个。这意味着她想存储的任何文件都必须放在一个全局可访问的目录中，比如 */tmp* 或 */var/tmp*，这增加了她的可见性。Apache
    配置文件由 root 或您的 Web 服务器管理组拥有，而 *www* 用户不属于该组。入侵者可能有途径进入 Web 服务器，但她无法重新配置它。她无法更改网站文件，因为
    *www* 用户并不拥有它们。*www* 用户对系统上的任何内容都没有访问权限，除了 Web 服务器本身。一个足够有技能的入侵者可以让 Web 服务器展示不同的页面或重定向到另一个站点，至少在重启之前是这样。突破服务器上运行的应用程序或主机本身，则需要一整套额外的安全漏洞。
- en: An unprivileged user doesn’t solve all security problems, mind you. Our compromised
    *www* user can view web application source files. If your application is badly
    written or has database passwords hardcoded into hidden files, you’re still in
    a lot of trouble. Still, if you’ve kept your system updated and all your packages
    up-to-date, an intruder will have a very hard time penetrating FreeBSD itself.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，未授权用户并不能解决所有的安全问题。我们已经被攻破的 *www* 用户可以查看 Web 应用的源代码文件。如果你的应用编写不当，或者将数据库密码硬编码在隐藏的文件中，你仍然会陷入很大的麻烦。不过，如果你已经保持系统更新并且所有软件包都保持最新，入侵者将很难渗透到
    FreeBSD 系统中。
- en: '***The nobody Account***'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***nobody 账户***'
- en: For years, system administrators used the account *nobody* as a generic unprivileged
    user. They’d run web servers, proxy servers, and whatever else as *nobody*. This
    was better than running those programs as root, but not as good as having separate
    users for each daemon. If an intruder successfully penetrated one of these programs,
    he had access to them all. Our hypothetical web server intruder would abruptly
    have access not only to the web server but also to whatever other programs run
    as that same user! If you’re using NFS, remember that NFS defaults to mapping
    remote root accounts to *nobody*. The whole point of using unprivileged users
    is to minimize the possible damage from a successful intrusion.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，系统管理员将账户*nobody*作为通用的非特权用户。他们会以*nobody*身份运行网页服务器、代理服务器以及其他程序。这样做比以root身份运行这些程序更安全，但还不如为每个守护进程创建独立的用户。如果入侵者成功渗透了这些程序中的一个，他将可以访问所有这些程序。我们的假设性网页服务器入侵者不仅能访问网页服务器，还能访问以相同用户身份运行的其他程序！如果您正在使用NFS，请记住，NFS默认将远程root账户映射为*nobody*。使用非特权用户的整个目的是最小化成功入侵后可能造成的损害。
- en: While you might test with the *nobody* account, never deploy production services
    with it. Use separate unprivileged accounts liberally.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可能会使用*nobody*账户进行测试，但绝不要使用它来部署生产服务。要广泛使用独立的非特权账户。
- en: '***A Sample Unprivileged User***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个示例非特权用户***'
- en: 'Here are parameters useful for a generic unprivileged user:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是适用于通用非特权用户的参数：
- en: '**Username** Assign a username related to the user’s function. For example,
    the default user for web servers is *www*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户名** 为用户的功能分配一个相关的用户名。例如，网页服务器的默认用户是*www*。'
- en: '**Home directory** Unprivileged users should deliberately not have a home directory,
    so use */nonexistent*. Do not create a */nonexistent* directory either; the whole
    point is that it doesn’t exist!'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**主目录** 非特权用户应该故意没有主目录，因此使用*/nonexistent*。也不要创建*/nonexistent*目录；重点是它根本不存在！'
- en: '**Shell** Unpriviliged users must not have a shell that can execute commands,
    so use */usr/sbin/nologin*.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shell** 非特权用户必须没有可以执行命令的shell，因此使用*/usr/sbin/nologin*。'
- en: '**UID/GID** Choose a special range of user and group IDs for unprivileged users.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**UID/GID** 为非特权用户选择一个特殊范围的用户和组ID。'
- en: '**Full name** Assign a name describing the user’s function.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**全名** 为用户的功能分配一个描述性的名称。'
- en: '**Password** Use chpass(1) to assign the user a single asterisk as their encrypted
    password. This disables the account password. (Note that chpass(1) stands for
    *change password file*, not *change password*!)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**密码** 使用chpass(1)将用户的加密密码设置为一个星号，这将禁用账户密码。（请注意，chpass(1)代表*更改密码文件*，而不是*更改密码*！）'
- en: These settings make your unprivileged user very unprivileged indeed. You can
    set all of this easily with adduser(8), giving the account no password, the correct
    home directory, and an appropriate shell.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置使得您的非特权用户确实变得非常不特权。您可以使用adduser(8)轻松设置这些，给账户设置无密码、正确的主目录和适当的shell。
- en: Many ports and packages have assigned unprivileged users and groups, listed
    in */usr/ports/UIDs* and */usr/ports/GIDs*. Don’t be afraid to add more. Use UIDs
    above 1,000, so as not to conflict with those assigned by packages and FreeBSD’s
    core.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 许多端口和包已经分配了非特权用户和组，列在*/usr/ports/UIDs*和*/usr/ports/GIDs*中。不要害怕添加更多。使用1000以上的UID，以避免与包和FreeBSD核心分配的UID冲突。
- en: '**Network Traffic Control**'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网络流量控制**'
- en: Sysadminis must have the ability to control traffic to and from their systems.
    Unwanted visitors must be stopped while legitimate users get access. FreeBSD provides
    a variety of tools that allow you to control outside access to your systems, including
    TCP wrappers, packet filtering, and blacklisting.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员必须具备控制进出其系统的流量的能力。必须阻止不受欢迎的访问者，同时允许合法用户访问。FreeBSD提供了多种工具，允许您控制外部访问您的系统，包括TCP包装器、数据包过滤和黑名单功能。
- en: The TCP wrappers, or simply *wrappers*, control access to network daemons. While
    the program must be written to support TCP wrappers, most modern software has
    supported wrappers for many years. Wrappers are fairly simple to configure and
    don’t require much networking knowledge. As access controls go, however, wrappers
    are fairly limited. Wrappers do let you do interesting things with connections
    and with daemons offering connections, though, which is why we’ll discuss it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: TCP包装器，或简称*包装器*，控制网络守护进程的访问权限。虽然程序必须支持TCP包装器，但大多数现代软件多年来已经支持包装器。包装器配置相对简单，不需要太多网络知识。然而，作为访问控制手段，包装器的功能是有限的。尽管如此，包装器允许您对连接和提供连接的守护进程执行一些有趣的操作，这就是为什么我们要讨论它的原因。
- en: '*Packet filtering* controls which traffic the system allows to pass through
    it and which traffic it rejects. Most firewalls are packet filters with a pretty
    GUI on top, but you can use FreeBSD packet filtering and proxy software to build
    a solid firewall in and of itself. A rejected connection request never reaches
    any userland program; it’s blocked in the network stack. Packet filtering can
    control access to any program, service, or network port but does require more
    networking knowledge.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据包过滤* 控制系统允许哪些流量通过，以及哪些流量被拒绝。大多数防火墙实际上是数据包过滤器，只是上面加了一个漂亮的图形用户界面，但你也可以使用 FreeBSD
    的数据包过滤和代理软件来构建一个坚固的防火墙。被拒绝的连接请求永远不会到达任何用户空间程序；它会在网络栈中被阻止。数据包过滤可以控制对任何程序、服务或网络端口的访问，但需要更多的网络知识。'
- en: '*Blacklisting* is useful when you want a program to be able to decide to stop
    listening to a remote host. The most common tool for blacklisting is fail2ban
    (*[https://www.fail2ban.org/](https://www.fail2ban.org/)*), which is flexible
    but requires much special configuration. FreeBSD includes blacklistd, an easier-to-configure
    blacklisting tool that requires integration with programs that use it.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*黑名单* 在你希望程序能够决定停止监听远程主机时非常有用。最常见的黑名单工具是 fail2ban (*[https://www.fail2ban.org/](https://www.fail2ban.org/)*)，它非常灵活，但需要大量的特殊配置。FreeBSD
    包含 blacklistd，一个更易配置的黑名单工具，但需要与使用它的程序集成。'
- en: Which should you use? For basic TCP/IP access control, I recommend always using
    a packet filter. Only use TCP wrappers if you need their specific features. I
    discuss blocking and allowing connections with TCP wrappers only as a prerequisite
    to those advanced features. If you want a service to block clients after a certain
    number of failed connection attempts, consider blacklistd.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用哪种策略？对于基本的 TCP/IP 访问控制，我建议始终使用数据包过滤器。只有在需要 TCP 包装器的特定功能时，才使用它们。我仅将 TCP
    包装器的连接阻止与允许作为实现这些高级功能的前提进行讨论。如果你希望服务在多次连接失败后阻止客户端，可以考虑使用 blacklistd。
- en: With wrappers or packet filtering, you must decide whether you want a default
    accept or default deny traffic control policy.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包装器或数据包过滤时，你必须决定是选择默认接受还是默认拒绝的流量控制策略。
- en: '**Default Accept vs. Default Deny**'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**默认接受与默认拒绝**'
- en: One of the essential decisions in any security policy is between default accept
    and default deny. A *default accept* security stance means that you allow any
    type of connection except what you specifically disallow. A *default deny* stance
    means that you allow connections only from specified parts of the internet and/or
    to specified services and that you refuse all other connections. The default is
    used unless you make a specific rule dictating otherwise. Once you’ve chosen your
    default security stance, you create exceptions one way or another to either provide
    or block services as necessary. The choice is really between whether you offer
    services to the world (default accept) or only to a select few (default deny).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何安全策略中，一个重要的决策就是选择默认接受还是默认拒绝。*默认接受* 安全策略意味着你允许任何类型的连接，除了你明确禁止的连接。*默认拒绝* 策略意味着你只允许来自特定部分互联网和/或特定服务的连接，拒绝所有其他连接。除非你制定了特定规则，否则默认设置会被使用。一旦选择了默认安全策略，你就可以以某种方式创建例外，以提供或阻止服务。选择的关键实际上是在于你是否愿意向全世界提供服务（默认接受），还是只向少数人提供服务（默认拒绝）。
- en: For example, company policy might dictate that the intranet web server must
    be accessible only from within the company. If so, adopt a default deny stance
    and explicitly list who may access the server. Alternatively, if you have a public
    website but want to block certain parts of the internet from accessing it for
    whatever reason, adopt a default accept stance.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，公司的政策可能要求公司内部网服务器只能从公司内部访问。如果是这样，可以采用默认拒绝策略，并明确列出可以访问该服务器的人员。或者，如果你有一个公共网站，但希望阻止某些互联网部分出于某种原因访问它，则可以采用默认接受策略。
- en: I always recommend a default deny stance. If you don’t make a choice, however,
    you’ve chosen default accept.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是推荐默认拒绝策略。然而，如果你没有做出选择，那么你就选择了默认接受。
- en: Choosing a default doesn’t mean that the default must be implemented without
    exceptions. My public web servers have a default deny security stance, but I specifically
    allow the world to access the websites. The machine rejects attempts to connect
    to other programs unless they come from one of a few specified IP addresses. This
    is a perfectly acceptable default deny stance.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个默认策略并不意味着这个默认策略必须毫无例外地执行。我的公共 web 服务器采取默认拒绝安全策略，但我特意允许全球访问这些网站。除非连接请求来自几个指定的
    IP 地址之一，否则机器会拒绝连接其他程序的尝试。这是一个完全可以接受的默认拒绝策略。
- en: Different security tools implement these stances in different ways. For example,
    with TCP wrappers, the *first* matching rule is applied. If your last rule denies
    everything, you’ve established a policy that says, “Unless I’ve specifically created
    a rule earlier to permit this traffic, block it.” On the other hand, with the
    PF packet filter, the *last* matching rule applies. If your first rule says, “Block
    all traffic,” you’ve implemented a policy that says, “Unless I specifically create
    a later rule to permit this traffic, block it.”
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的安全工具以不同的方式实现这些策略。例如，使用 TCP 包装器时，应用的是*第一个*匹配规则。如果你的最后一条规则拒绝所有内容，那么你就建立了一个策略，表示：“除非我在之前的规则中明确允许此流量，否则阻止它。”另一方面，使用
    PF 包过滤器时，应用的是*最后一个*匹配规则。如果你的第一条规则说：“阻止所有流量”，那么你就实施了一个策略，表示：“除非我在后面的规则中特别允许此流量，否则阻止它。”
- en: Both default accept and default deny annoy the sysadmin. If you have a default
    accept policy, you’ll spend your time continually plugging holes. If you choose
    a default deny policy, you’ll spend your time opening access for people. You’ll
    repeatedly apologize for either choice. With default deny, you’ll say things like,
    “I’ve just activated service for you. I apologize for the inconvenience.” With
    default accept, you’ll say things like, “. . . and that’s why the intruders were
    able to access our internal accounting database and why we lost millions of dollars.”
    In the latter case, “I apologize for the inconvenience” *really* doesn’t suffice.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 默认接受和默认拒绝都会让系统管理员感到烦恼。如果你采取默认接受策略，你将不断花时间修补漏洞。如果选择默认拒绝策略，你将花时间为别人打开访问权限。你会对任何选择不断道歉。如果选择默认拒绝，你可能会说：“我刚刚为你激活了服务，非常抱歉给你带来不便。”如果选择默认接受，你可能会说：“……这就是入侵者能够访问我们的内部财务数据库并导致我们损失数百万美元的原因。”在后一种情况下，“我为不便向你道歉”*真的是*不够的。
- en: '**TCP Wrappers**'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**TCP 包装器**'
- en: Remember from [Chapter 7](ch07.xhtml#ch07) that network connections are made
    to various programs that listen for connection requests. When a program is built
    with TCP wrappers support, the program checks the incoming request against the
    wrappers configuration. If the wrappers configuration says to reject the connection,
    the program immediately drops the request. Despite the name, TCP wrappers work
    with both TCP and UDP connections. Wrappers are a long-running Unix standard that
    have been incorporated into FreeBSD. Individual programs might or might not work
    with wrappers; while just about everything in the base FreeBSD system does, some
    third-party software doesn’t.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在[第7章](ch07.xhtml#ch07)中我们提到过，网络连接会建立到各种监听连接请求的程序上。当一个程序内置 TCP 包装器支持时，程序会根据包装器配置检查传入的请求。如果包装器配置指示拒绝连接，程序会立即丢弃该请求。尽管名称中有
    TCP，TCP 包装器也可以与 UDP 连接一起使用。包装器是一个长期存在的 Unix 标准，已经被纳入 FreeBSD。个别程序可能支持包装器，也可能不支持；虽然
    FreeBSD 基础系统中的几乎所有程序都支持，某些第三方软件则不支持。
- en: TCP wrappers are implemented as a shared library, called *libwrap*. As seen
    in [Chapter 17](ch17.xhtml#ch17), shared libraries are small chunks of code that
    can be shared between programs. Any program that links with libwrap may use the
    TCP wrappers functions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 包装器实现为一个共享库，称为*libwrap*。正如在[第17章](ch17.xhtml#ch17)中所看到的，共享库是可以在程序之间共享的小块代码。任何与
    libwrap 链接的程序都可以使用 TCP 包装器功能。
- en: Wrappers most commonly protect inetd(8), the super server that handles network
    requests for smaller programs. We’ll discuss inetd in [Chapter 20](ch20.xhtml#ch20).
    While our examples cover inetd(8), you can protect any other program that supports
    wrappers in exactly the same way. While wrappers help protect inetd(8), make sure
    inetd(8) doesn’t offer any unnecessary services, just as you do for the main system.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器最常见的保护对象是 inetd(8)，它是一个超级服务器，处理较小程序的网络请求。我们将在[第20章](ch20.xhtml#ch20)中讨论 inetd。虽然我们的示例涉及
    inetd(8)，但你可以用完全相同的方式保护任何其他支持包装器的程序。虽然包装器有助于保护 inetd(8)，但要确保 inetd(8) 不提供任何不必要的服务，正如你对待主系统一样。
- en: '***Configuring Wrappers***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置包装器***'
- en: 'Wrappers check each incoming connection request against the rules in */etc/hosts.allow*,
    in order. The first matching rule is applied, and processing stops immediately.
    This makes rule order very important. Each rule is on a separate line and is made
    up of three parts separated by colons: a daemon name, a client list, and a list
    of options. Here’s a sample rule:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 封装器按顺序检查每个传入连接请求与*/etc/hosts.allow*中的规则进行匹配。第一个匹配的规则会被应用，并且立即停止处理。这使得规则的顺序变得非常重要。每条规则都在单独的一行上，由三部分组成，三部分通过冒号分隔：守护进程名称、客户端列表和选项列表。下面是一个示例规则：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The daemon name is `ftpd`; the client list is `all`, meaning all hosts; and
    the option is `deny`, telling wrappers to reject all connections. Nobody can connect
    to the FTP server on this host unless an earlier rule explicitly grants access.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程名称是`ftpd`；客户端列表是`all`，意味着所有主机；选项是`deny`，指示封装器拒绝所有连接。除非先前的规则明确授权访问，否则没有人能够连接到该主机上的FTP服务器。
- en: 'In the early examples, I refer to only two options: `accept` and `deny`. They
    allow and reject connections, respectively. We’ll discuss the additional options
    later.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的示例中，我只提到两个选项：`accept`和`deny`。它们分别允许和拒绝连接。稍后我们将讨论其他选项。
- en: '**Daemon Name**'
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**守护进程名称**'
- en: The daemon name is the program’s name as it appears on the command line. For
    example, inetd(8) starts the ftpd(8) program when it receives an incoming FTP
    request. The Apache web server starts a program called *httpd*, so if your version
    of Apache supports wrappers, give the daemon name as `httpd`. (Note that Apache
    doesn’t run out of inetd, but it can support wrappers anyway.) One special daemon
    name, `ALL`, matches all daemons that support wrappers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程名称是程序在命令行中出现的名称。例如，inetd(8)在接收到FTP请求时启动ftpd(8)程序。Apache web服务器启动一个名为*httpd*的程序，所以如果你的Apache版本支持封装器，请将守护进程名称指定为`httpd`。（注意，Apache并不是从inetd启动的，但它仍然可以支持封装器。）一个特殊的守护进程名称`ALL`匹配所有支持封装器的守护进程。
- en: 'If your system has multiple IP addresses, you can specify, as part of the daemon
    name, different wrapper rules for each IP address that a daemon listens on:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的系统有多个IP地址，你可以在守护进程名称中指定每个守护进程监听的IP地址的不同封装器规则：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we have two daemon names, `ftpd@203.0.113.1` and `ftpd@203.0.113.2`.
    Each has a separate TCP wrapper rule.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们有两个守护进程名称，`ftpd@203.0.113.1`和`ftpd@203.0.113.2`。每个都有一个单独的TCP封装器规则。
- en: '**The Client List**'
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**客户端列表**'
- en: 'The client list is a list of specific IP addresses, network address blocks,
    hostnames, domain names, and keywords, separated by spaces. Hostnames and IP addresses
    are simple: just list them.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端列表是一个由特定IP地址、网络地址块、主机名、域名和关键字组成的列表，用空格分隔。主机名和IP地址很简单：只需要列出它们。
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this rule at the top of */etc/hosts.allow*, wrappers allow my netmanager
    machine and any host with an IP address of 203.0.113.5 to connect to any service
    on this host. (I could block this access by other means, mind you.)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此规则放在*/etc/hosts.allow*文件顶部，封装器允许我的网络管理机和任何IP地址为203.0.113.5的主机连接到该主机上的任何服务。（请注意，我可以通过其他方式阻止此访问。）
- en: 'Specify network numbers in the client list with a slash between the IP address
    and the netmask, as discussed in [Chapter 7](ch07.xhtml#ch07). For example, if
    script kiddies attack your server from a bunch of addresses that begin with 192.0.2,
    you could block them like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端列表中指定网络号时，IP地址和子网掩码之间用斜杠分隔，如[第7章](ch07.xhtml#ch07)中所述。例如，如果脚本小子从一堆以192.0.2开头的地址攻击你的服务器，你可以通过以下方式来阻止它们：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can also use domain names in client lists by prefacing them with a dot.
    This works through reverse DNS, which means that anyone who controls the DNS server
    for a block of addresses can evade this restriction.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在客户端列表中使用域名，并在前面加一个点来实现。通过反向DNS实现此功能，这意味着任何控制一个地址块的DNS服务器的人都可以绕过此限制。
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you have a long list of clients, you can even list them in a file and put
    the full path to the file in the client space in */etc/hosts.allow*. I’ve been
    on networks with large numbers of widely scattered hosts, such as an ISP or corporate
    network environment with network management workstations scattered across the
    world. Each workstation shared the same wrapper rules as every other workstation
    and appeared on half a dozen lines in *hosts.allow*. By maintaining a single file
    with a workstation list, I could centralize all changes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个长的客户端列表，你甚至可以将它们列在一个文件中，并将文件的完整路径放入*/etc/hosts.allow*文件中的客户端空间。我曾经在一个拥有大量分布广泛主机的网络上工作，比如一个ISP或公司网络环境，在全球各地有网络管理工作站。每个工作站共享与其他工作站相同的封装器规则，并在*hosts.allow*中出现多行。通过维护一个包含工作站列表的文件，我可以集中管理所有的变更。
- en: In addition to specifically listing client addresses and names, wrappers provide
    several special client keywords to add groups of clients to your list. [Table
    19-1](ch19.xhtml#ch19tab1) shows the keywords and their usage.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了专门列出客户端地址和名称外，包装器还提供了几个特殊的客户端关键字，用于将一组客户端添加到你的列表中。[表 19-1](ch19.xhtml#ch19tab1)
    显示了这些关键字及其用法。
- en: Most of the client keywords listed in [Table 19-1](ch19.xhtml#ch19tab1) require
    a working DNS server. If you use these keywords, you must have a very reliable
    DNS service, and you must remember the vital link between DNS and the rest of
    your programs. If your DNS server fails, daemons that use wrappers and those keywords
    can’t identify any hosts. This means that everything matches your `UNKNOWN` rule,
    which probably denies the connection. Also, broken DNS on the client end can deny
    remote users access to your servers, as your DNS servers won’t be able to get
    proper information from the client’s servers. Finally, if you use DNS-based wrapping
    extensively, an intruder needs only to overload your nameserver or otherwise interrupt
    your nameserver to create a very effective denial-of-service attack against your
    network.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 19-1](ch19.xhtml#ch19tab1)中列出的多数客户端关键字需要一个正常工作的 DNS 服务器。如果你使用这些关键字，你必须拥有一个非常可靠的
    DNS 服务，并且必须记住 DNS 和其他程序之间的重要联系。如果你的 DNS 服务器失败，使用包装器和这些关键字的守护进程将无法识别任何主机。这意味着所有的连接都会匹配
    `UNKNOWN` 规则，通常会拒绝连接。此外，客户端端的 DNS 故障可能会拒绝远程用户访问你的服务器，因为你的 DNS 服务器无法从客户端的服务器获取正确的信息。最后，如果你广泛使用基于
    DNS 的包装，入侵者只需要过载你的名称服务器或以其他方式干扰你的名称服务器，就能对你的网络发起非常有效的拒绝服务攻击。'
- en: '**Table 19-1:** TCP Wrapper Keywords'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 19-1：** TCP 包装器关键字'
- en: '| **Keyword** | **Usage** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **关键字** | **用法** |'
- en: '| --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ALL` | This matches every possible host. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `ALL` | 该规则匹配所有可能的主机。 |'
- en: '| `LOCAL` | This matches every machine whose hostname does not include a dot.
    Generally, this means machines in the local domain. Machines on the other side
    of the world who happen to share your domain name are considered “local” under
    this rule. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `LOCAL` | 该规则匹配每个主机名中不包含点的机器。通常，这意味着局域网内的机器。位于世界另一端、恰好共享你域名的机器也会被视为“本地”主机。
    |'
- en: '| `UNKNOWN` | This matches machines with unidentifiable hostnames or usernames.
    As a general rule, any host making an IP connection has a known IP address. Tracing
    hostnames, however, requires DNS, and tracking usernames requires identd(8). Be
    very careful using this option because transitory DNS issues can make even local
    hostnames unresolvable and most hosts don’t run identd(8) by default. You don’t
    want a service to become unusable just because your nameserver was misconfigured—especially
    if that machine *is* your nameserver! |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `UNKNOWN` | 该规则匹配无法识别主机名或用户名的机器。一般来说，任何建立 IP 连接的主机都有已知的 IP 地址。然而，追踪主机名需要
    DNS，追踪用户名需要 identd(8)。使用此选项时要非常小心，因为临时的 DNS 问题可能导致即使是本地主机名也无法解析，而且大多数主机默认不运行 identd(8)。你不希望因为你的名称服务器配置错误而导致服务无法使用——尤其是当那台机器*就是*你的名称服务器时！
    |'
- en: '| `KNOWN` | This matches any host with a determinable hostname and IP address.
    Be very careful using this, as DNS outages can interrupt service. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `KNOWN` | 该规则匹配任何具有可确定主机名和 IP 地址的主机。使用此规则时要非常小心，因为 DNS 中断可能会影响服务。 |'
- en: '| `PARANOID` | This matches any host whose name does not match its IP address.
    You might receive a connection from a host with an IP address of 192.168.84.3
    that claims to be called *mail.michaelwlucas.com*. Wrappers turn around and check
    the IP address of *mail.michaelwlucas.com*. If wrappers get a different IP address,
    the host matches this rule. Sysadmins who do not have time to maintain their DNS
    are the most likely to have unpatched, insecure systems. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `PARANOID` | 该规则匹配任何主机，其名称与其 IP 地址不匹配。你可能会收到来自 IP 地址为 192.168.84.3 的主机的连接请求，该主机声称自己叫做*mail.michaelwlucas.com*。包装器会反过来检查*mail.michaelwlucas.com*的
    IP 地址。如果包装器得到不同的 IP 地址，该主机就符合此规则。没有时间维护 DNS 的系统管理员最有可能拥有未修补的、不安全的系统。 |'
- en: TCP wrappers provide additional keywords, but they’re not as useful or secure
    as these. For example, it’s possible to allow connections based on the username
    on the remote machine. You don’t want to rely on a client username on a remote
    machine, however. For example, if I set up wrappers to allow only someone with
    a username of *mwlucas* to connect to my home system, someone could easily add
    an account of that name to his FreeBSD system and get right in. Also, this relies
    on the same rarely used identd(1) protocol that was mentioned earlier. You can
    find a few other obscure keywords of similar usefulness in hosts_access(5).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: TCP包装器提供了其他一些关键字，但它们没有这些关键字那么有用或安全。例如，可以基于远程机器上的用户名来允许连接。然而，你不应该依赖远程机器上的客户端用户名。例如，如果我设置包装器，只允许用户名为*mwlucas*的人连接到我的本地系统，某人可以轻松地在他们的FreeBSD系统中添加一个该名字的帐户，并直接访问。此外，这还依赖于之前提到的罕用的identd(1)协议。你可以在hosts_access(5)中找到一些其他类似有用的模糊关键字。
- en: '**The ALL and ALL EXCEPT Keywords**'
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**ALL 和 ALL EXCEPT 关键字**'
- en: 'Both daemon names and client lists can use the `ALL` and `ALL EXCEPT` keywords.
    The `ALL` keyword matches absolutely everything. For example, the default *hosts.allow*
    starts with a rule that permits all connections, from all locations, to any daemon:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程名称和客户端列表都可以使用`ALL`和`ALL EXCEPT`关键字。`ALL`关键字匹配所有内容。例如，默认的*hosts.allow*文件以一条允许所有连接的规则开始，这条规则允许从任何位置到任何守护进程的连接：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This matches all programs and all clients. You can limit this by giving a specific
    name to either the client list or the daemon list.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于所有程序和所有客户端。你可以通过为客户端列表或守护进程列表指定特定名称来限制这一点。
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we reject all connections from the host 203.0.113.87.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们拒绝来自主机203.0.113.87的所有连接。
- en: 'Categorically blocking access to all hosts isn’t that great an idea, but remember
    that TCP wrappers follow rules in order and quit when they reach the first matching
    rule. The `ALL` keyword lets you set a default stance quite easily. Consider the
    following ruleset:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 完全阻止对所有主机的访问并不是一个好主意，但请记住，TCP包装器会按顺序执行规则，并在找到第一个匹配规则时停止检查。`ALL`关键字使你可以轻松设置一个默认立场。考虑以下规则集：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our workstations 192.168.8.3 and 192.168.8.4 (probably the sysadmin’s workstations)
    may access anything they want. Anyone in the world may access the FTP server.
    Finally, we drop all other connections. This is a useful default deny stance.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作站192.168.8.3和192.168.8.4（可能是系统管理员的工作站）可以访问任何他们想访问的内容。世界上的任何人都可以访问FTP服务器。最后，我们拒绝所有其他连接。这是一个有用的默认拒绝立场。
- en: 'Use the `ALL EXCEPT` keyword to compress rules. `ALL EXCEPT` allows you to
    list hosts by exclusion; what isn’t listed matches. Here, we write the same rules
    with `ALL EXCEPT`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ALL EXCEPT`关键字来压缩规则。`ALL EXCEPT`允许你通过排除的方式列出主机；没有列出的主机将匹配。在这里，我们用`ALL EXCEPT`写出相同的规则：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Of course, this rule relies on having a default accept policy that permits the
    FTP connection later.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这条规则依赖于拥有一个默认的接受策略，该策略允许之后的FTP连接。
- en: Some people find rules more clear when written with `ALL`, others prefer `ALL
    EXCEPT`. The important thing to remember is that the first matching rule ends
    the check, so be careful slinging `ALL` around.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人认为用`ALL`编写规则更清晰，而另一些人则更喜欢`ALL EXCEPT`。需要记住的重要一点是，第一次匹配的规则会结束检查，因此在使用`ALL`时要小心。
- en: 'It’s a good idea to allow any connections from the local host; you’re likely
    to discover a number of programs that break when they can’t talk to the local
    machine. Put a rule like this early in your *hosts.allow*:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 允许来自本地主机的任何连接是一个好主意；你可能会发现有些程序在无法与本机通信时会出错。在你的*hosts.allow*文件中尽早放入这样的规则：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Options**'
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**选项**'
- en: 'We’ve already seen two options: `allow` and `deny`. While `allow` permits the
    connection, `deny` blocks it. The first rule in the default *hosts.allow* applies
    to all daemons and clients, and it matches and allows all possible connections.
    This rule can’t be first in your *hosts.allow* if you want to wrap your services,
    but it’s a good final rule in a default accept security stance. Similarly, an
    `ALL`:`ALL`:`deny` rule is a good final rule in a default deny security stance.
    TCP wrappers support other options besides the simple `allow` and `deny`, however,
    giving you a great deal of flexibility.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了两种选项：`allow`和`deny`。`allow`允许连接，而`deny`则阻止连接。默认的*hosts.allow*文件中的第一条规则适用于所有守护进程和客户端，它匹配并允许所有可能的连接。如果你想保护你的服务，这条规则不能排在*hosts.allow*中的第一位，但它是默认接受安全立场下的一个好最终规则。类似地，`ALL`:`ALL`:`deny`规则是在默认拒绝安全立场下的一个好最终规则。然而，TCP包装器除了简单的`allow`和`deny`之外，还支持其他选项，给你提供了很大的灵活性。
- en: '**LONG RULES**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**长规则**'
- en: If you’re using a lot of options, wrapper rules can get very long. To help keep
    rules readable, the *hosts.allow* file can use the backslash (`\`) followed by
    a return as a line-continuation character.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用了很多选项，包装规则可能会变得非常长。为了帮助保持规则的可读性，*hosts.allow* 文件可以使用反斜杠 (`\`) 后跟回车符作为行续字符。
- en: '**Logging**'
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**记录**'
- en: Once you’ve decided to accept or reject the connection attempt, you can also
    log the connection. Suppose you want to permit but specifically log all incoming
    requests from a competitor. Similarly, you might want to know how many connections
    your server rejects because of DNS problems when using the `PARANOID` client keyword.
    Logging is good. More logging is better. Disk space is cheaper than your time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你决定接受或拒绝连接尝试，你还可以记录该连接。假设你想允许但特别记录来自竞争对手的所有传入请求。同样，你可能想知道因为 DNS 问题而被拒绝的服务器连接数量，当使用
    `PARANOID` 客户端关键字时。记录很有用，更多的记录更好。磁盘空间比你的时间便宜。
- en: The `severity` option sends a message to the system log, syslogd(8). You can
    configure syslogd to direct these messages to an arbitrary file based on the syslogd
    facility and level you choose (see [Chapter 21](ch21.xhtml#ch21)).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`severity` 选项将消息发送到系统日志，即 syslogd(8)。你可以配置 syslogd 将这些消息定向到一个任意文件，具体取决于你选择的
    syslogd 设施和级别（见 [第21章](ch21.xhtml#ch21)）。'
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This example permits all SSH connections but also logs them using the local0
    facility.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例允许所有 SSH 连接，但也通过 local0 设施记录它们。
- en: '**Twisting**'
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**扭转**'
- en: The `twist` option allows you to run arbitrary shell commands and scripts when
    someone attempts to connect to a wrapped TCP daemon and returns the output to
    the remote user. The `twist` option works properly only with TCP connections.
    (Remember, UDP is connectionless; there’s no connection to return the response
    over, so you must jump through very sophisticated and annoying hoops to make `twist`
    work with UDP. Also, protocols that transmit over UDP frequently don’t expect
    such a response and aren’t usually equipped to receive or interpret it. Using
    `twist` with UDP isn’t worth the trouble.) The `twist` option takes a shell command
    as an argument and acts as a deny-plus-do-this rule. You must know basic shell
    scripting to use `twist`; very complicated uses of `twist` are possible, but we’ll
    stick with the simple ones.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`twist` 选项允许你在有人尝试连接到包装的 TCP 守护进程时执行任意的 shell 命令和脚本，并将输出返回给远程用户。`twist` 选项仅适用于
    TCP 连接。（记住，UDP 是无连接的；没有连接可以返回响应，因此你必须通过非常复杂和麻烦的步骤才能使 `twist` 在 UDP 上工作。此外，许多通过
    UDP 传输的协议通常不期望这样的响应，也不具备接收或解释它的能力。在 UDP 上使用 `twist` 并不值得麻烦。）`twist` 选项将 shell
    命令作为参数，并充当拒绝加执行此操作的规则。你必须了解基本的 shell 脚本才能使用 `twist`；`twist` 的复杂用法是可能的，但我们将坚持使用简单的用法。'
- en: 'The `twist` option is useful for a final rule in a default deny stance. Use
    `twist` to return an answer to the person attempting to connect as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`twist` 选项对于默认拒绝策略中的最后一条规则很有用。使用 `twist` 向尝试连接的人返回如下答案：'
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you want to deny just a particular service to a particular host, you can
    use more specific daemon and client lists with `twist`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想拒绝某个特定主机的特定服务，可以使用更具体的守护进程和客户端列表与 `twist` 配合使用：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This isn’t effective against spam, but it might make you feel better. Legit
    customers that encounter rude messages might trigger meetings, however.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这对抗垃圾邮件并不有效，但可能会让你感觉更好。不过，遇到粗鲁信息的合法客户可能会引发会议。
- en: 'If you’re feeling friendly, you can tell people why you’re rejecting their
    connection. The following `twist` rejects all connections from people whose hostname
    doesn’t match their IP address and tells them why:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感觉友好，可以告诉人们你拒绝他们连接的原因。以下 `twist` 会拒绝所有主机名与其 IP 地址不匹配的连接，并告诉他们原因：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using `twist` holds the network connection open until the shell command finishes.
    If your command takes a long time to finish, you could find that you’re holding
    open more connections than you like. This can impact system performance. A script
    kiddie can use `twist` to overload your system, creating a very simple DoS attack.
    Make `twist` simple and quick-finishing.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `twist` 会保持网络连接开启，直到 shell 命令完成。如果你的命令执行时间较长，你可能会发现你保持了比预期更多的连接，这可能会影响系统性能。脚本小白可以利用
    `twist` 使你的系统过载，进行一个非常简单的拒绝服务攻击。确保 `twist` 简单且能快速完成。
- en: '**Spawning**'
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**生成**'
- en: 'Like `twist`, the `spawn` option denies the connection and runs a specified
    shell command. Unlike `twist`, `spawn` doesn’t return the results to the client.
    Use `spawn` when you want your FreeBSD system to take an action upon a connection
    request but you don’t want the client to know about it. Spawned commands run in
    the background. The following example allows the connection but logs the client’s
    IP address to a file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `twist` 类似，`spawn` 选项会拒绝连接并运行指定的 shell 命令。与 `twist` 不同，`spawn` 不会将结果返回给客户端。当您希望
    FreeBSD 系统在连接请求时采取某种行动，但又不希望客户端知道时，使用 `spawn`。生成的命令在后台运行。以下示例允许连接，但将客户端的 IP 地址记录到文件中：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Wait a minute—where did the `%a` come from? TCP wrappers support several variables
    for use in `twist` and `spawn` commands, so you can easily customize your responses.
    This particular variable, `%a`, stands for *client address*. It expands into the
    client’s IP address in the shell command before the command is run. [Table 19-2](ch19.xhtml#ch19tab2)
    lists other variables.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下——`%a` 是从哪里来的？TCP wrapper 支持多个变量，用于 `twist` 和 `spawn` 命令中，因此您可以轻松自定义响应。这个特定的变量
    `%a` 代表 *客户端地址*。在命令运行之前，它会展开为客户端的 IP 地址，出现在 shell 命令中。[表 19-2](ch19.xhtml#ch19tab2)
    列出了其他变量。
- en: '**Table 19-2:** Variables for `twist` and `spawn` Scripts'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 19-2：** `twist` 和 `spawn` 脚本的变量'
- en: '| **Variable** | **Description** |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **变量** | **描述** |'
- en: '| --- | --- |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `%a` | Client address. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `%a` | 客户端地址。 |'
- en: '| `%A` | Server IP address. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `%A` | 服务器的 IP 地址。 |'
- en: '| `%c` | All available client information. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `%c` | 所有可用的客户端信息。 |'
- en: '| `%d` | Name of the daemon connected to. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `%d` | 连接的守护进程名称。 |'
- en: '| `%h` | Client hostname, or IP address if hostname not available. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `%h` | 客户端的主机名，如果没有主机名，则是 IP 地址。 |'
- en: '| `%H` | Server hostname, or IP address if hostname not available. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `%H` | 服务器主机名，如果没有主机名，则为 IP 地址。 |'
- en: '| `%n` | Client hostname, or `UNKNOWN` if no hostname is found. If the hostname
    and the IP address don’t match, this returns `PARANOID`. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `%n` | 客户端的主机名，如果找不到主机名，则返回 `UNKNOWN`。如果主机名和 IP 地址不匹配，则返回 `PARANOID`。 |'
- en: '| `%N` | Server hostname, but if no hostname is found, this returns either
    `UNKNOWN` or `PARANOID`. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `%N` | 服务器的主机名，如果找不到主机名，则返回 `UNKNOWN` 或 `PARANOID`。 |'
- en: '| `%p` | Daemon’s process ID. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `%p` | 守护进程的进程 ID。 |'
- en: '| `%s` | All available server information. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `%s` | 所有可用的服务器信息。 |'
- en: '| `%u` | Client’s username. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `%u` | 客户端的用户名。 |'
- en: '| `%%` | A single `%` character. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `%%` | 单个 `%` 字符。 |'
- en: 'Use these variables anywhere you’d use the information they represent in a
    shell script. For example, to log all available client information to a file whenever
    anyone connects to a wrapped program, you could use this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 shell 脚本中，您可以在任何需要表示它们所代表信息的地方使用这些变量。例如，当有人连接到包装程序时，您可以使用以下命令将所有可用的客户端信息记录到文件中：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Spaces and backslashes are illegal characters in shell commands and might cause
    problems. While neither appears in hostnames under normal circumstances, the internet
    is almost by definition not normal. TCP wrappers replace any character that might
    confuse the command shell with an underscore (`_`). Check for underscores in your
    logs; they might indicate possible intrusion attempts or just someone who doesn’t
    know what they’re doing.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 空格和反斜杠是 shell 命令中的非法字符，可能会导致问题。虽然在正常情况下，主机名中不会出现这两个字符，但互联网几乎可以说是与常规不同的。TCP wrapper
    会将任何可能干扰命令 shell 的字符替换为下划线 (`_`)。请检查您的日志中的下划线；它们可能表示潜在的入侵尝试，或者只是某些不懂的人在操作。
- en: '***Wrapping Up Wrappers***'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***包装封装器总结***'
- en: Let’s take all the examples given so far in this section and build a complete
    */etc/hosts.allow* to protect a hypothetical network system. We must first inventory
    the network resources this system offers, the IP addresses we have on the network,
    and the remote systems we wish to allow to connect.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将本节中给出的所有示例结合起来，构建一个完整的 */etc/hosts.allow* 文件来保护一个假设的网络系统。我们首先必须盘点这个系统提供的网络资源、我们网络中的
    IP 地址，以及我们希望允许连接的远程系统。
- en: 'While these requirements are fairly complicated, they boil down to a very simple
    ruleset:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些要求相当复杂，但它们归结为一个非常简单的规则集：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can find many more commented-out examples in */etc/hosts.allow* or in hosts_allow(5)
    and hosts_access(5).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 */etc/hosts.allow* 或 hosts_allow(5) 和 hosts_access(5) 中找到更多注释掉的示例。
- en: '**Packet Filtering**'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据包过滤**'
- en: To control access to networked programs that don’t support TCP wrappers, or
    whenever your needs exceed what wrappers provide, use one of FreeBSD’s kernel-level
    packet filtering tools. If you need a packet filter, it’s best to entirely replace
    your TCP wrappers implementation with packet filtering. Using both tools at once
    on the same machine will simply confuse you.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要控制不支持 TCP 包装器的网络程序的访问，或者当你的需求超出了包装器所能提供的功能时，可以使用 FreeBSD 的内核级包过滤工具。如果你需要包过滤器，最好完全用包过滤替代
    TCP 包装器的实现。在同一台机器上同时使用这两种工具只会让你更加困惑。
- en: A packet filter compares every network packet that enters the system to a list
    of rules. When a rule matches the packet, the kernel acts based upon that rule.
    Rules can tell the system to allow, drop, or alter the packet. You can’t use the
    nifty options provided by TCP wrappers, however; instead of spitting a comparatively
    friendly rejection message back at the client, the connection is severed at the
    network level before the client even reaches the application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 包过滤器会将每个进入系统的网络包与规则列表进行比较。当某个规则与包匹配时，内核会根据该规则进行操作。规则可以指示系统允许、丢弃或修改包。然而，你不能使用
    TCP 包装器提供的那些巧妙选项；连接会在网络层被切断，客户端甚至没有机会到达应用层，就被拒绝了，而不是返回一个相对友好的拒绝信息。
- en: While the idea of packet filtering is straightforward enough, your first implementation
    will be a complete nightmare—er, I mean, a “valuable learning experience.” Be
    prepared to spend hours experimenting and don’t be discouraged by failures. In
    my experience, it’s ignorance of basic TCP/IP that causes grief with packet filtering,
    rather than the packet filter itself. Trying to filter network traffic without
    understanding the network is frustrating and pointless. The only way to really
    understand TCP/IP is to do real work with it, however. Go study [Chapter 7](ch07.xhtml#ch07)
    again. If that doesn’t suffice, dig into the books recommended there.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管包过滤的概念足够简单，但你第一次实现时将面临一场彻底的噩梦——呃，我是说，一场“宝贵的学习经验”。准备好花几个小时进行实验，并且不要因为失败而灰心丧气。根据我的经验，困扰包过滤的往往是对基本
    TCP/IP 知识的无知，而不是包过滤器本身。试图在不了解网络的情况下进行网络流量过滤是令人沮丧且毫无意义的。要真正理解 TCP/IP，唯一的方法是进行实际的工作。再去学习[第七章](ch07.xhtml#ch07)。如果那还不够，就深入阅读那里的推荐书籍。
- en: 'FreeBSD suffers from a wealth of packet filters: IPFW, IP Filter, and PF.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 面临着大量的包过滤器：IPFW、IP Filter 和 PF。
- en: IPFW is the primordial FreeBSD packet filtering software. It’s tightly integrated
    with FreeBSD; in fact, the generically named files */etc/rc.firewall* and */etc/rc.firewall6*
    are purely for IPFW. While quite powerful and very popular with more experienced
    FreeBSD administrators, it’s a little difficult for a beginner.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: IPFW 是 FreeBSD 最早的包过滤软件。它与 FreeBSD 紧密集成；事实上，名为 */etc/rc.firewall* 和 */etc/rc.firewall6*
    的文件完全是为 IPFW 准备的。虽然非常强大，并且在经验丰富的 FreeBSD 管理员中非常流行，但对于初学者来说，它有点难度。
- en: The second packet filter, IP Filter, is not a FreeBSD-specific firewall program
    but is supported on several Unix-like operating systems. It’s primarily the work
    of one individual, Darren Reed, who has by heroic effort developed the overwhelming
    majority of the code and ported it to all those operating systems. IP Filter is
    most useful if you want to share one firewall configuration among multiple operating
    systems.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个包过滤器，IP Filter，并不是 FreeBSD 特有的防火墙程序，而是在多个类 Unix 操作系统上都有支持。它主要是由一个人——达伦·里德（Darren
    Reed）——的巨大努力完成的，他开发了绝大部分代码并将其移植到所有这些操作系统上。如果你希望在多个操作系统之间共享一个防火墙配置，IP Filter 最为有用。
- en: We’ll focus on the imaginatively named *PF*, or *packet filter*. PF originated
    in OpenBSD and was designed to be featureful, flexible, and easy to use. The average
    FreeBSD administrator can use PF to achieve almost any effect possible with the
    other two packet filters.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点讨论富有创意命名的*PF*，即*包过滤器*。PF 起源于 OpenBSD，旨在提供丰富的功能、灵活性并且易于使用。普通的 FreeBSD 管理员可以使用
    PF 实现几乎所有使用其他两个包过滤器可以达到的效果。
- en: '**NOTE**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For in-depth discussion of PF, you might check out Peter N. M. Hansteen’s*
    The Book of PF *(No Starch Press, 2014) or my book* Absolute OpenBSD *(No Starch
    Press, 2013), which contains several chapters about PF. You might also look at
    the online PF FAQ, but that has fewer haiku.*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想深入讨论 PF，可以参考彼得·N·M·汉斯廷（Peter N. M. Hansteen）的《PF 之书》（The Book of PF）（No
    Starch Press, 2014），或者我自己的书《绝对 OpenBSD》（Absolute OpenBSD）（No Starch Press, 2013），其中有几章专门讲解
    PF。你还可以查看在线的 PF FAQ，但那里的俳句要少一些。*'
- en: '***Enabling PF***'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启用 PF***'
- en: 'PF includes the packet filtering kernel module, *pf.ko*, and the userland program
    pfctl(8). Before using PF, you must load the kernel module. The simplest way is
    to enable PF in *rc.conf*:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: PF 包括数据包过滤内核模块 *pf.ko* 和用户空间程序 pfctl(8)。在使用 PF 之前，你必须加载内核模块。最简单的方法是通过 *rc.conf*
    启用 PF：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: PF defaults to the accept all stance, which means that you won’t lock yourself
    out of your server merely by enabling the firewall.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: PF 默认采用接受所有策略，这意味着仅仅启用防火墙并不会让你把自己锁定在服务器之外。
- en: '***Default Accept and Default Deny in Packet Filtering***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***默认接受和默认拒绝在数据包过滤中的应用***'
- en: The security stances (default accept and default deny) are critical in packet
    filtering. If you use the default accept stance and want to protect your system
    or network, you need numerous rules to block every possible attack. If you use
    the default deny stance, you must explicitly open holes for every little service
    you offer. In almost all cases, default deny is preferable; while it can be more
    difficult to manage, its increased security more than makes up for that difficulty.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 安全策略（默认接受和默认拒绝）在数据包过滤中至关重要。如果你使用默认接受策略并希望保护你的系统或网络，你需要许多规则来阻止每一种可能的攻击。如果你使用默认拒绝策略，你必须为你提供的每个小服务显式地开放端口。在几乎所有情况下，默认拒绝是更可取的；虽然它可能更难管理，但它带来的更高安全性完全弥补了这种困难。
- en: When using a default deny stance, it’s very easy to lock yourself out of remotely
    accessing your machine. When you have an SSH connection to a remote machine and
    accidentally break the rule that allows SSH access, you’re in trouble. Everybody
    does this at least once, so don’t be too embarrassed when it happens to you. The
    point is, it’s best not to learn about packet filtering on a remote machine; start
    with a machine that you can console into so you can recover easily. I’ve cut my
    own access many times, generally because I’m not thinking straight when solving
    an unrelated packet filtering problem. Without a remote console or IPMI, the only
    fix is to kick myself as I climb into the car, drive to the remote location, and
    apologize profusely to the people I’ve inconvenienced as I fix the problem. Fortunately,
    as I grow older, this happens less and less.^([1](footnote.xhtml#ch19fn1))
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认拒绝策略时，很容易将自己锁定在无法远程访问计算机的状态。当你通过 SSH 连接到远程计算机并不小心打破允许 SSH 访问的规则时，你就会遇到麻烦。每个人至少都会发生一次这种情况，所以当它发生在你身上时，不要太尴尬。关键是，最好不要在远程计算机上学习数据包过滤；从你可以控制台访问的计算机开始，这样你可以轻松恢复。我自己多次切断了自己的访问，通常是因为在解决与数据包过滤无关的问题时没有理清思路。如果没有远程控制台或
    IPMI，唯一的解决办法就是在我爬上车、开车去远程地点时踢自己一脚，并在修复问题时向我给他人带来不便的人道歉。幸运的是，随着我年龄的增长，这种情况越来越少发生。^([1](footnote.xhtml#ch19fn1))
- en: Still, in almost all circumstances, a default deny stance is correct. As a new
    administrator, the only way you can reasonably learn packet filtering is if you
    have convenient access to the system console. If you’re not entirely confident
    in your configuration, don’t set up a packet filtering system across the country
    unless you have remote console and power access, a competent local administrator,
    or a serial console.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在几乎所有情况下，默认拒绝策略是正确的。作为一个新管理员，你唯一合理的学习数据包过滤的方式是确保你可以方便地访问系统控制台。如果你对自己的配置不完全有信心，除非你有远程控制台和电源访问、一个合格的本地管理员或者一个串行控制台，否则不要在全国范围内设置数据包过滤系统。
- en: '***Basic Packet Filtering and Stateful Inspection***'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础数据包过滤与有状态检查***'
- en: Recall from [Chapter 7](ch07.xhtml#ch07) that a TCP connection can be in a variety
    of states, such as opening, open, closing, and so on. For example, every connection
    opens when the client sends a SYN packet to the server to request connection synchronization.
    If the server is listening on the requested port, it responds with a SYN-ACK,
    meaning, “I’ve received your request, and here’s basic information for our connection.”
    The client acknowledges receipt of the information with an ACK packet, meaning,
    “I acknowledge receipt of the connection information.” Each part of this three-way
    handshake must complete for a connection to occur. Your packet filtering ruleset
    must permit all parts of the handshake, as well as the actual data transmission,
    to occur. Allowing your server to receive incoming connection requests is useless
    if your packet filter rules don’t permit transmitting that SYN-ACK.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第7章](ch07.xhtml#ch07)，TCP连接可以处于多种状态，如打开、开启、关闭等。例如，每个连接在客户端发送SYN数据包请求连接同步时都会开启。如果服务器在请求的端口上监听，它会回复SYN-ACK，表示：“我已收到你的请求，这是我们的连接的基本信息。”客户端用ACK数据包确认收到信息，表示：“我已确认收到连接信息。”三次握手的每个部分都必须完成，才能建立连接。你的数据包过滤规则集必须允许三次握手的所有部分，以及实际的数据传输。如果你的数据包过滤器规则不允许传输SYN-ACK，允许服务器接收传入连接请求就毫无意义。
- en: In the early 1990s, packet filters checked each packet individually. If a packet
    matched a rule, it was allowed to pass. The system didn’t record what it had previously
    passed and had no idea whether a packet was part of a legitimate transaction or
    not. For example, if a packet arrived marked SYN-ACK with a destination address
    inside the packet filter, the packet filter generally decided that the packet
    had to be the response to a packet it had previously approved. Such a packet *had*
    to be approved to complete the three-way handshake. As a result, intruders forged
    SYN-ACK packets and used them to circumvent seemingly secure devices. Since the
    packet filter didn’t know who had previously sent a SYN packet, it couldn’t reject
    illegitimate SYN-ACK packets. Once an intruder gets packets inside a network,
    he can usually trigger a response from a random device and start to worm his way
    in.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在1990年代初，数据包过滤器会单独检查每个数据包。如果数据包匹配规则，它将被允许通过。系统不会记录之前已经通过的内容，也不知道某个数据包是否属于合法的事务。例如，如果一个标记为SYN-ACK的数据包到达并且其目标地址在数据包过滤器内，数据包过滤器通常会认为该数据包必须是对之前已批准的数据包的响应。这样的数据包*必须*被批准，以完成三次握手。因此，入侵者伪造SYN-ACK数据包并利用它们绕过看似安全的设备。由于数据包过滤器不知道谁曾发送过SYN数据包，它无法拒绝不合法的SYN-ACK数据包。一旦入侵者将数据包带入网络，他通常可以从一个随机设备触发响应，开始渗透。
- en: Modern packet filters use stateful inspection to counteract this problem. *Stateful
    inspection* means keeping track of every connection and its current condition.
    If an incoming SYN-ACK packet appears to be part of an ongoing connection, but
    nobody sent a corresponding SYN request, the packet is rejected. While this complicates
    the kernel, writing stateful inspection packet filter rules is easier than writing
    old-fashioned rules. The packet filter must track many, many possible states,
    so this is harder to program than it might seem—especially when you add in problems
    such as packet fragmentation, antispoofing, and so on.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现代数据包过滤器使用有状态检查来应对这个问题。*有状态检查*意味着跟踪每个连接及其当前状态。如果一个传入的SYN-ACK数据包似乎是正在进行的连接的一部分，但没有人发送相应的SYN请求，则该数据包会被拒绝。虽然这使内核变得更加复杂，但编写有状态检查数据包过滤规则比编写传统的规则要容易。数据包过滤器必须跟踪许多可能的状态，因此这比看起来要难编程，尤其是当你考虑到数据包碎片、反欺骗等问题时。
- en: PF performs stateful inspection by default. You don’t need to specify it in
    a rule.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: PF默认执行有状态检查。你无需在规则中指定它。
- en: 'If you’ve started to think, “Hey, packet filtering sounds like a firewall,”
    you’re right, to a point. The word *firewall* is applied to a variety of network
    protection devices. Some of these devices are very sophisticated; some lose intelligence
    contests to cinderblocks. These days, the term *firewall* is nothing more than
    a marketing buzzword with very little concrete meeting. The word *firewall* is
    like the word *car*: do you mean a rusty 1972 Gremlin with a 6-horsepower engine
    and an exhaust system that emits enough fumes to breach the Kyoto Accords, or
    a shiny Tesla Roadster with a 500-horsepower engine, a fancy tricolor paintjob,
    and the Stereo System of The Apocalypse? Both have their uses, but one is obviously
    designed for performance. While the Gremlins of firewalls might have their place,
    it’s preferable to get the best you can afford.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经开始想，“嘿，数据包过滤听起来像是防火墙”，您是对的，有一定道理。*防火墙*这个词被应用于各种网络保护设备。 其中一些设备非常复杂；一些设备甚至在智力竞赛中败给了水泥块。如今，*防火墙*这个词不过是一个营销术语，几乎没有实际意义。*防火墙*这个词就像*汽车*这个词：你是指一辆生锈的1972年款Gremlin，配有6马力的发动机，排气系统的废气足以突破《京都议定书》，还是一辆闪亮的特斯拉Roadster，配有500马力的发动机、华丽的三色涂装以及“末日音响系统”？两者各有其用途，但显然其中一款是为性能而设计的。虽然“Gremlin”式的防火墙可能也有其用武之地，但最好还是选择您能负担得起的最好的设备。
- en: Having said that, FreeBSD can be made as solid a firewall as you desire. Packet
    filtering is only the beginning. The packages collection contains a variety of
    application proxies that can let your FreeBSD system go up against Checkpoint
    or a PIX and come out on top—for tens of thousands of dollars less.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，FreeBSD可以打造一个坚固的防火墙，完全满足您的需求。数据包过滤只是开始。软件包集合包含各种应用代理，可以让您的FreeBSD系统与Checkpoint或PIX抗衡，并在顶尖表现中脱颖而出——且费用远低于数万美元。
- en: '***Configuring PF***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置PF***'
- en: Configure PF in */etc/pf.conf*. This file contains statements and rules whose
    formats vary with the features they configure. Not only is the rule order extremely
    important but also the order in which features are configured. If you try to do
    stateful inspection before you reassemble fragmented packets, for example, connections
    won’t work properly.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 配置PF在*/etc/pf.conf*文件中。这个文件包含了不同格式的声明和规则，具体格式取决于它们配置的功能。不仅规则的顺序至关重要，功能配置的顺序也同样关键。例如，如果您在重新组装分片数据包之前尝试进行状态检查，连接将无法正常工作。
- en: 'The default */etc/pf.conf* has the sample rules in the proper order, but if
    you’re in the slightest danger of becoming confused, I suggest that you put large
    comment markers between the sections, in capital letters if necessary. (Use hash
    marks to comment *pf.conf*.) The features must be entered in this exact order:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的*/etc/pf.conf*包含了正确顺序的示例规则，但如果您有任何混淆的危险，建议您在各个部分之间加上大号注释标记，必要时使用大写字母。 （使用井号来注释*pf.conf*。）功能必须按此准确顺序输入：
- en: Macros
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 宏
- en: Tables
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表格
- en: Options
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选项
- en: Packet normalization
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据包规范化
- en: Bandwidth management
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带宽管理
- en: Translation
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 翻译
- en: Redirection
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重定向
- en: Packet filtering
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据包过滤
- en: Yes, PF does more than just filter packets. It’s a general-purpose TCP/IP manipulation
    tool. We won’t cover all of its features here; go read Peter’s book.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，PF不仅仅是用来过滤数据包。它是一个通用的TCP/IP处理工具。我们不会在这里介绍它的所有功能；去阅读Peter的书吧。
- en: '**Macros**'
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**宏**'
- en: 'A macro lets you define variables to make writing and reading rules easier.
    For example, here are macros to define your network interface and your IP address:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 宏允许您定义变量，以便更轻松地编写和阅读规则。例如，下面是定义您的网络接口和IP地址的宏：
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Later in your rules, you may describe your network interface as `$interface`
    and your server’s IP address as `$serveraddr`. This means that if you renumber
    your server or change your network card, making one change in your *pf.conf* fully
    updates your rules.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的规则中，您可能会将网络接口描述为`$interface`，将服务器的IP地址描述为`$serveraddr`。这意味着，如果您重新编号服务器或更换网络卡，只需在*pf.conf*中进行一次更改，您的规则就会完全更新。
- en: Sometimes you’ll want a rule to refer to “all IP addresses currently on this
    interface.” You don’t care which address the traffic arrives at, you just want
    either to accept or reject traffic to that interface. PF provides shorthand for
    this. Enclose the interface name in parentheses, as we’ll see later. (You can
    use the interface name without parentheses, but then PF won’t notice any IP changes
    since the last reload or restart.)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您希望某个规则引用“当前在此接口上的所有IP地址”。您不关心流量到达的是哪个地址，只希望接受或拒绝到该接口的流量。PF为此提供了简写方式。将接口名称括在括号中，稍后我们将看到。
    （您也可以不使用括号直接使用接口名称，但这样PF就无法察觉到自上次重新加载或重启以来IP的变化。）
- en: '**Tables and Options**'
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**表格和选项**'
- en: PF can store long lists of addresses through tables. That’s a more sophisticated
    use of PF than we’re going to use, but you should know the capability exists.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: PF 可以通过表格存储大量地址。这比我们将要使用的 PF 更加复杂，但你应该知道这一功能的存在。
- en: Similarly, PF has a variety of options that control network connection timing,
    table sizes, and other internal settings. The default settings are generally adequate
    for normal (and most abnormal) use.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，PF 有多种选项来控制网络连接的时间、表格大小和其他内部设置。默认设置通常足够满足正常（以及大多数不正常）使用。
- en: '**Packet Normalization**'
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**数据包规范化**'
- en: 'TCP/IP packets can be broken up in transit, and processing these shards of
    data increases system load and the amount of work your server must do both to
    serve the request and filter the packets. A system must reassemble these fragments
    before handing them on to your client software, while deciding what to do with
    any other random crud that arrives. PF refers to this reassembly as *scrubbing*.
    For example, to reassemble all fragments coming in your network interface, drop
    all fragments too small to possibly be legitimate, and otherwise sensibly sanitize
    your incoming data stream, use the following rule:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP 数据包在传输过程中可能被拆分，处理这些数据碎片会增加系统负载，以及服务器必须做的工作量，无论是为了服务请求，还是过滤数据包。系统必须在将数据包交给客户端软件之前重新组装这些碎片，同时决定如何处理任何其他随机的垃圾数据。PF
    将这种重新组装称为 *清理*。例如，要重新组装所有通过网络接口进入的碎片，丢弃所有可能不合法的过小碎片，并合理地清理传入的数据流，使用以下规则：
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This affects all packets entering the computer.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这会影响进入计算机的所有数据包。
- en: While scrubbing seems like a “nice to have,” it’s actually quite important since
    PF filters are based on whole packets. Fragments are much more difficult to filter
    and require special handling unless reassembled. Not scrubbing your traffic causes
    connectivity problems.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然清理看起来像是“锦上添花”，但它实际上相当重要，因为 PF 的过滤是基于整个数据包的。碎片要过滤起来要复杂得多，并且需要特殊处理，除非它们被重新组装。没有清理流量会导致连接问题。
- en: '**Bandwidth, Translation, and Redirection**'
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**带宽、转换和重定向**'
- en: PF includes other features vital for firewalls and performs other functions
    normally associated with network devices. Through queueing, PF can control how
    much traffic the host transmits on a per-IP or even per-port basis. PF includes
    a whole bunch of features to support Network Address Translation (NAT) and port
    redirection, two critical firewall features. The support exceeds that found in
    many commercial offerings.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: PF 包括其他对于防火墙至关重要的功能，并执行通常与网络设备相关的其他功能。通过排队，PF 可以控制主机在每个 IP 或甚至每个端口的基础上传输的流量。PF
    包含一大堆功能来支持网络地址转换（NAT）和端口重定向，这两个是防火墙的关键功能。它的支持超出了许多商业产品的范畴。
- en: All of this would fill another book. Literally. Peter Hansteen wrote *The Book
    of PF*. Go read that and build a firewall. Every sysadmin should build a firewall
    out of a raw operating system at least once in her life. Even if you revert to
    using a commercial offering, a little embedded device, or a product like pfSense
    or OPNsense, you’ll learn a whole bunch.^([2](footnote.xhtml#ch19fn2))
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些内容足以填满另一本书。字面意思。Peter Hansteen 写了 *PF 手册*。去读一下，然后搭建一个防火墙。每个系统管理员至少应该用裸操作系统搭建一次防火墙。即使最终选择使用商业产品、嵌入式设备，或像
    pfSense 或 OPNsense 这样的产品，你也会学到很多东西。^([2](footnote.xhtml#ch19fn2))
- en: '***Small-Server PF Rule Sample***'
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***小型服务器 PF 规则示例***'
- en: Here’s a sample set of PF rules for protecting a small internet server. Start
    from here and edit this to match your server’s requirements.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一组用于保护小型互联网服务器的 PF 规则样本。从这里开始，编辑它以匹配你服务器的需求。
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We start by defining a macro for our interface name ➊ so that if we change network
    cards, we won’t need to rewrite all our rules.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个宏来指定我们的接口名称 ➊，这样如果更换网络卡时，我们就不需要重写所有规则。
- en: The second line instructs PF not to filter on the lo0 interface ➋. The loopback
    interface is local to the machine. The only host that can communicate over it
    is the local machine.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行指示 PF 不对 lo0 接口 ➋ 进行过滤。回环接口是本地机器的，只有本地机器能够通过它进行通信。
- en: Then, we scrub incoming traffic ➌, reassembling packets into a coherent whole
    and throwing away what can’t be reassembled.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们清理传入流量 ➌，将数据包重新组装成一个连贯的整体，并丢弃那些无法重新组装的数据包。
- en: Now that we have a sensible stream of incoming data, we can filter it. This
    policy starts by blocking all incoming traffic ➍, setting a default deny policy.
    Everything not explicitly permitted is forbidden.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个合理的传入数据流，我们可以对其进行过滤。此策略首先通过阻止所有传入流量 ➍，设置默认拒绝策略。没有明确允许的任何东西都被禁止。
- en: Outbound traffic gets a default allow policy ➎.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 出站流量有默认允许策略 ➎。
- en: The final three rules in this policy address TCP, UDP, and ICMP. They have a
    similar format, which we’ll dissect shortly.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本策略中的最后三条规则处理TCP、UDP和ICMP。它们有类似的格式，我们稍后会详细分析。
- en: First, we permit TCP traffic to ports 22, 53, 80, and 443 ➏.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们允许TCP流量访问端口22、53、80和443 ➏。
- en: Next, we permit UDP traffic to port 53 ➐. If this host offered more services
    than DNS, we’d have a longer list of ports.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们允许UDP流量访问端口53 ➐。如果该主机提供的服务多于DNS，那么我们会有更长的端口列表。
- en: The final rule allows vital ICMP traffic to our host and permits the host to
    respond ➑.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条规则允许至关重要的ICMP流量访问我们的主机，并允许该主机响应 ➑。
- en: Let’s take a closer look at the TCP rule.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看TCP规则。
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This host has a default deny policy on inbound traffic, so with the `pass in`
    statement ➊, we’re carving out an exception to that policy.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 该主机对入站流量有默认拒绝策略，因此通过`pass in`语句 ➊，我们对该策略做出了一个例外。
- en: The next chunk of the rule specifies which interface this rule applies to ➋.
    This rule applies to the interface defined by the macro `$ext_if`, or em1.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 规则的下一部分指定了该规则适用的接口 ➋。该规则适用于由宏`$ext_if`定义的接口，或者是em1。
- en: Then, we specify a protocol ➌. This rule applies to TCP connections.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们指定一个协议 ➌。这个规则适用于TCP连接。
- en: You can write PF rules that apply only to specific source or destination addresses.
    This rule applies to traffic from any host ➍. You can drop this part of the rule
    if you’re permitting any source address.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写仅适用于特定源或目标地址的PF规则。这个规则适用于来自任何主机的流量 ➍。如果你允许任何源地址，可以省略规则中的这一部分。
- en: We then specify a destination address ➎. The destination is the interface name
    in parentheses, which means “any IP address on this interface.”
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们指定一个目标地址 ➎。目标是括号中的接口名称，这意味着“该接口上的任何IP地址”。
- en: Lastly, define the ports this rule applies to ➏. The braces allow you to group
    several entities together. The filter permits connections to port 22 (ssh), 53
    (DNS), 80 (HTTP), and 443 (HTTPS). You could specify a port by its name (from
    */etc/services*), but I find numbers to be more reliable. Editing */etc/services*
    shouldn’t break your firewall! Deploying a new TCP service on this host requires
    only adding a port to the list and reloading the firewall rules.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，定义该规则适用的端口 ➏。大括号允许你将多个实体组合在一起。该过滤器允许连接到端口22（ssh）、53（DNS）、80（HTTP）和443（HTTPS）。你也可以通过端口名指定端口（来自*/etc/services*），但我发现数字更可靠。编辑*/etc/services*不应该破坏你的防火墙！在该主机上部署新的TCP服务只需要将端口添加到列表中并重新加载防火墙规则。
- en: The UDP rule is very slightly different.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: UDP规则略有不同。
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The most obvious change is defining UDP protocol instead of TCP ➊. One less
    obvious change is that this rule drops the source address. It applies to packets
    from any address. This packet filter allows only one port, 53 ➋. Rules with a
    single port don’t need braces.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的变化是定义UDP协议而不是TCP ➊。一个不那么明显的变化是该规则省略了源地址。它适用于来自任何地址的数据包。这个数据包过滤器只允许一个端口，53
    ➋。带有单一端口的规则不需要大括号。
- en: The ICMP rule looks a little tricky, but it’s really just the same.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP规则看起来有点复杂，但其实它和其他规则是一样的。
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Specifying that this rule applies to ICMP is straightforward ➊. And this rule
    also doesn’t list a source address, so it applies to traffic from anywhere.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 指定此规则适用于ICMP是直接的 ➊。这个规则也没有列出源地址，因此适用于来自任何地方的流量。
- en: Where the TCP and UDP rules specify a destination port, this ICMP rule lists
    an `icmp-type` ➋. ICMP doesn’t have ports, but it does have different types of
    traffic. For our purposes, though, ICMP types are much like ports. Types have
    numerical codes, but the names are easier.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在TCP和UDP规则中指定目标端口的地方，ICMP规则列出了`icmp-type` ➋。ICMP没有端口，但它有不同类型的流量。对于我们的目的，ICMP类型类似于端口。类型有数字代码，但名称更容易记。
- en: This rule specifies four different types of ICMP traffic ➌.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则指定了四种不同类型的ICMP流量 ➌。
- en: Taken as a whole, this rule permits ICMP traffic that’s generally necessary
    for proper internet functioning. Your environment might need other ICMP types.
    Your organization’s security policy might specify what ICMP you can and cannot
    pass. But these four are a reasonable combination for an internet-facing server.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这条规则允许通常对互联网正常运行至关重要的ICMP流量。你的环境可能需要其他类型的ICMP。你组织的安全政策可能会指定可以和不能传递哪些ICMP。但是这四种类型对于面对互联网的服务器来说是一个合理的组合。
- en: This simple policy defines basic rules for communicating with our server. While
    it’s not perfect, it can raise barriers for intruders. That jerk who broke into
    your web server and started a command prompt on port 10000? If your firewall rules
    don’t allow incoming connections on that port, all their hard work will be wasted.
    Such a tragedy.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的策略定义了与我们服务器通信的基本规则。虽然它并不完美，但它可以为入侵者设置障碍。那个闯入你的网站服务器并在10000端口启动命令提示符的家伙？如果你的防火墙规则不允许该端口的传入连接，那么他们所有的努力都会白费。真是个悲剧。
- en: '***Managing PF***'
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***管理PF***'
- en: Manage PF with pfctl(8). If your rules have no errors, pfctl(8) runs silently;
    it produces output only when you have errors. You’ll want to test, activate, view,
    and remove rules.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pfctl(8)管理PF。如果你的规则没有错误，pfctl(8)将静默运行；只有在出现错误时才会输出结果。你需要测试、启用、查看和删除规则。
- en: '**Testing Rules**'
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**测试规则**'
- en: As a firewall error can cause you much grief, it’s best to check your rules
    before activating them. While a rule check only parses the file, checking for
    grammatical errors in the rules themselves, activating rules with grammatical
    errors either leaves your system unprotected, locks you out, or both. Use the
    `-n` flag to check a file for problems and `-f` to specify the PF rules file.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于防火墙错误可能会给你带来很大麻烦，最好在启用规则之前先检查它们。虽然规则检查只会解析文件，检查规则本身的语法错误，但如果启用包含语法错误的规则，可能会导致系统无法保护、锁定或两者兼而有之。使用`-n`标志检查文件中的问题，使用`-f`指定PF规则文件。
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you get errors, fix them and try again.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现错误，请修复它们并重新尝试。
- en: '**Activating Rules**'
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**启用规则**'
- en: Once your syntax check runs silently, activate the new rules by removing the
    `-n` flag.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦语法检查静默运行，移除`-n`标志以启用新规则。
- en: '[PRE25]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Changing PF configuration is very quick. This means you can have several PF
    configurations for different times or situations. Perhaps you want to allow access
    only to certain services at certain parts of the day; you could schedule a pfctl(8)
    run to install appropriate rules for those times. Or maybe you have separate rules
    for disaster situations and want to install a special ruleset when you lose your
    internet connection. Using pfctl(8) makes all these configurations simple.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 更改PF配置非常迅速。这意味着你可以为不同的时间或情况准备多个PF配置。也许你只想在一天中的某些时段允许访问特定服务；你可以安排一个pfctl(8)运行，在这些时段安装适当的规则。或者，也许你有针对灾难情况的独立规则，并希望在失去互联网连接时安装特殊的规则集。使用pfctl(8)可以使所有这些配置变得简单。
- en: '**View Rules**'
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**查看规则**'
- en: If you want to see the rules currently running on your firewall, use `pfctl
    -sr`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看当前正在防火墙上运行的规则，请使用`pfctl -sr`。
- en: '[PRE26]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can write PF rules in exactly the format shown here.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照这里展示的格式编写PF规则。
- en: Note that while we specified multiple TCP ports in the configuration file, in
    the packet filter each TCP and UDP port gets its own rule. Likewise, each ICMP
    type gets its own rule.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然我们在配置文件中指定了多个TCP端口，但在数据包过滤器中，每个TCP和UDP端口都有自己的规则。同样，每种ICMP类型也有自己的规则。
- en: '**Removing Rules**'
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**删除规则**'
- en: Finally, remove all rules from your running configuration with the `-Fa` (flush
    all) flags. (You could use flags other than `a` to remove parts of your firewall
    config, but that can leave your system in an inconsistent state.)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`-Fa`（刷新所有）标志从运行配置中删除所有规则。（你可以使用除`a`以外的其他标志来删除防火墙配置的部分内容，但这样可能会使系统处于不一致的状态。）
- en: '[PRE27]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You’ll see PF systematically erase all rules, NAT configurations, and anything
    else in your configuration. Do not manually clear the configuration before loading
    a new configuration; just load the new rules file to erase the old rules.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到PF系统地删除所有规则、NAT配置以及配置中的其他内容。在加载新配置之前，不要手动清除配置；只需加载新规则文件即可删除旧规则。
- en: PF is terribly powerful, very flexible, and can abuse TCP/IP in almost any way
    you like (and some ways you won’t like). We’ve barely scratched the surface. Check
    out some of the resources listed at the start of “[Packet Filtering](ch19.xhtml#lev829)”
    on [page 462](ch19.xhtml#page_462) to explore PF in depth.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: PF非常强大，灵活性很高，可以几乎以任何你喜欢的方式（甚至一些你不喜欢的方式）滥用TCP/IP。我们才刚刚触及表面。查看在[第462页](ch19.xhtml#page_462)中提到的“[数据包过滤](ch19.xhtml#lev829)”中的一些资源，以深入探索PF。
- en: '**Blacklistd(8)**'
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Blacklistd(8)**'
- en: Sometimes you want more thoughtful packet filtering than a simple allow or deny
    permits. I often have SSH servers open to the public internet so that I can log
    in from anywhere. I do rather resent botnets thinking that I’d be sufficiently
    daft to permit logins without a password, though. That’s where blacklistd(8) comes
    in.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能需要比简单的允许或拒绝更深思熟虑的数据包过滤。我经常将SSH服务器开放给公网，这样我就可以从任何地方登录。不过，我确实有点不满那些认为我会允许没有密码登录的僵尸网络。这个时候，Blacklistd(8)就派上用场了。
- en: Blacklistd lets a daemon report, “Hey, this IP address is bugging me.” Once
    blacklistd receives a sufficient number of complaints about an address, it tells
    the firewall to block that address. Those bots eternally poking at your SSH server?
    They’re history.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Blacklistd允许一个守护进程报告：“嘿，这个IP地址在骚扰我。”一旦Blacklistd收到足够多关于某个地址的投诉，它就会通知防火墙阻止该地址。那些不断攻击你SSH服务器的机器人？它们已经历史。
- en: This sort of blacklisting is only marginally useful against distributed botnets
    like the Hail Mary Cloud, but even then, you might be able to configure sensitivity
    to block out the most annoying clients. It all depends on just how intrusive each
    botnet member is.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这种黑名单策略对于像Hail Mary Cloud这样的分布式僵尸网络只有有限的作用，但即便如此，你仍然可以配置敏感度，屏蔽掉最烦人的客户端。一切取决于每个僵尸网络成员的侵扰程度。
- en: To use blacklistd, you must set up the packet filter to accept input from blacklistd,
    set tolerance levels for each service, and configure the service to use blacklistd.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Blacklistd，你必须设置数据包过滤器以接受来自Blacklistd的输入，设置每个服务的容忍级别，并配置服务以使用Blacklistd。
- en: '***PF and Blacklistd***'
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***PF与Blacklistd***'
- en: 'PF handles dynamic rules through anchors. You can use pfctl(8) to edit an active
    anchor, letting you insert rules at a specific point in the policy. Add the blacklistd
    anchor to your rules right before your first `block` and `pass` statements. Using
    the policy from the previous section, your rules would look like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: PF通过锚点处理动态规则。你可以使用pfctl(8)编辑活动锚点，让你在策略中的特定位置插入规则。在你的`block`和`pass`语句之前添加Blacklistd锚点。按照上一节的策略，你的规则将如下所示：
- en: '[PRE28]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You must include the quotes around the anchor name, and you must specify the
    interface.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在锚点名称周围包含引号，并且必须指定接口。
- en: The packet filter is now ready for dynamic blacklisting.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包过滤器现在已经准备好进行动态黑名单处理。
- en: '***Configuring Blacklistd***'
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置Blacklistd***'
- en: Blacklistd gets its configuration from */etc/blacklistd.conf*. While most of
    its configuration goes in this file, you can also modify the service’s behavior
    with command line options.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Blacklistd从*/etc/blacklistd.conf*获取其配置。虽然它的大部分配置都放在这个文件中，但你也可以通过命令行选项修改服务的行为。
- en: Start by enabling blacklistd in */etc/rc.conf*.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 从启用*/etc/rc.conf*中的Blacklistd开始。
- en: '[PRE29]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The daemon won’t start until you either reboot or start it manually, so you
    can configure it now.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程不会启动，直到你重新启动或手动启动它，所以你现在可以进行配置。
- en: '**/etc/blacklistd.conf**'
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**/etc/blacklistd.conf**'
- en: Blacklistd rules each support a single service, port, or group of addresses.
    Put your rules into */etc/blacklistd.conf*, one rule per line. Blacklistd rules
    come in two groups, local and remote.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Blacklistd规则每个只支持单个服务、端口或地址组。将你的规则放入*/etc/blacklistd.conf*，每行一个规则。Blacklistd规则分为两组，分别是本地和远程。
- en: '*Local* blacklistd rules apply to items local to the machine running blacklistd.
    This is where you set rules for the local SSH service, or port 99, or anything
    else local. The section of local rules is prefaced with `[local]`.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*本地*的Blacklistd规则适用于运行Blacklistd的机器上的项目。这里是设置本地SSH服务、端口99或任何本地内容的地方。本地规则部分以`[local]`开头。'
- en: '*Remote* blacklistd rules apply to items not local to the machine. Here, you
    might define rules like “this block gets reduced tolerance” or “disable these
    addresses for shorter times” or “never block these addresses.” The section of
    remote rules gets prefaced with `[remote]`. We’ll talk about local rules first
    and then the additions supported by remote rules.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*远程*的Blacklistd规则适用于不在本地机器上的项目。这里，你可以定义规则，比如“这个块减少容忍度”或“禁用这些地址较短时间”或“永远不阻止这些地址”。远程规则部分以`[remote]`开头。我们将首先讨论本地规则，然后再讨论远程规则支持的附加内容。'
- en: 'Here’s a sample *blacklistd.conf* entry:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个*blacklistd.conf*条目的示例：
- en: '[PRE30]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first line is a `[local]` statement. Every rule that appears after this
    applies to the local machine, until we hit a `[remote]` entry.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是一个`[local]`语句。此后出现的每个规则都适用于本地机器，直到遇到`[remote]`条目为止。
- en: Each rule has seven fields. The first four fields identify traffic to be blacklisted,
    while the last three fields define the blacklist behavior. An asterisk (`*`) is
    a wildcard, saying anything matches this field.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 每个规则有七个字段。前四个字段识别要列入黑名单的流量，而后三个字段定义黑名单行为。星号（`*`）是通配符，表示任何内容都匹配这个字段。
- en: The first field is the *location*. For local rules, this gives the network port
    that this rule applies to. Entries like `ssh` and `ftp` are slightly deceiving.
    They don’t apply to the programs named `sshd` and `ftpd`, but rather to the network
    ports listed in */etc/services*. While you can list a specific IP address and
    port in local rules, blacklistd ignores the address. Only the port applies. The
    sample rule blocks on `ssh`, or port 22.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字段是*位置*。对于本地规则，它提供了适用的网络端口。像`ssh`和`ftp`这样的条目可能会让人产生误解。它们并不适用于名为`sshd`和`ftpd`的程序，而是适用于*/etc/services*中列出的网络端口。虽然在本地规则中你可以列出特定的IP地址和端口，但blacklistd会忽略该地址。只有端口才会生效。示例规则阻止了`ssh`，即端口22。
- en: The second field gives the socket type. TCP sockets use type `stream`, while
    UDP sockets need `dgram`. At this time, all services that support blacklistd use
    TCP. You can safely use an asterisk here to say “any socket type.” Our sample
    rule uses stream, so it’s for TCP connections.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个字段提供了套接字类型。TCP套接字使用`stream`类型，而UDP套接字需要`dgram`。目前，所有支持blacklistd的服务都使用TCP。你可以放心地在这里使用星号，表示“任何套接字类型”。我们的示例规则使用的是stream，因此它适用于TCP连接。
- en: The third field defines the *protocol*. Supported options include `tcp`, `udp`,
    `tcp6`, `udp6`, or `numeric`, or you can just use a wildcard and say “any protocol.”
    The only reason not to use a wildcard here is if you want to specifically match
    only one version of IP, such as using a different blacklist setting for TCP over
    IPv4 than for TCP over IPv6.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个字段定义了*协议*。支持的选项包括`tcp`、`udp`、`tcp6`、`udp6`或`numeric`，或者你可以使用通配符表示“任何协议”。不使用通配符的唯一原因是，如果你只想匹配某一版本的IP，例如为TCP
    over IPv4与TCP over IPv6使用不同的黑名单设置。
- en: The fourth field gives the *owner* of the daemon complaining about the traffic.
    This can be a wildcard, a username, or a UID. Again, wildcards are the most common
    entry here. For blacklisting purposes, I don’t care which user runs the server
    running on port 22; I care that it gets protected from random poking.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个字段给出了抱怨流量的守护进程的*所有者*。这可以是一个通配符、一个用户名或一个UID。这里通配符是最常见的条目。对于黑名单目的来说，我不关心哪个用户运行在端口22上运行的服务器；我关心的是它能被保护不受随机访问。
- en: The fifth field, the *packet filter rule name*, is the first entry that determines
    how the block works. Blacklistd defaults to putting all blocks under an anchor
    called *blacklistd*, which we put into *pf.conf* in the previous section. If you
    want separate blacklists to use different anchors, you can define an anchor name
    in this field; otherwise, just use the wildcard for the default.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 第五个字段，*数据包过滤规则名称*，是决定如何阻止的第一个条目。Blacklistd的默认行为是将所有阻止操作放在名为*blacklistd*的锚点下，这个锚点我们在上一节的*pf.conf*中添加过。如果你希望不同的黑名单使用不同的锚点，可以在这个字段中定义锚点名称；否则，使用通配符作为默认值。
- en: If you start a name with a hyphen (`-`), it means “use an anchor with the default
    name prepended.”
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在名称前加上一个连字符（`-`），意味着“使用默认名称前缀的锚点”。
- en: '[PRE31]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This entry adds any new blacklist rules to an anchor called *blacklistd-ssh*.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 该条目将任何新的黑名单规则添加到名为*blacklistd-ssh*的锚点。
- en: Using a slash (`/`) in the name field and the length of the netmask tells blacklistd
    to block entire subnets using prefix notation.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在名称字段中使用斜杠（`/`）和网络掩码的长度告诉blacklistd使用前缀表示法来阻止整个子网。
- en: '[PRE32]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When one host in a network misbehaves, we block everything in the adjoining
    /24\. A /24 means very different things in IPv4 versus IPv6\. Be sure to specify
    which protocol this rule applies to!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当网络中的一台主机行为异常时，我们会阻止邻接的整个/24子网。/24在IPv4和IPv6中有非常不同的含义。务必指定该规则适用的协议！
- en: The sixth column, *nfail*, sets the number of login failures needed to blacklist
    the remote IP. Here, a wildcard means never. Our example rule sets a limit of
    3, which is how many chances OpenSSH gives you to log in on one connection.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 第六列，*nfail*，设置需要多少次登录失败才能将远程IP列入黑名单。这里，通配符表示从不。我们的示例规则设置为3，这是OpenSSH在一次连接中给你的登录尝试次数。
- en: The last column, *disable*, says how long to blacklist the host for. The default
    unit is seconds, but you can use `m`, `h`, and `d` for minutes, hours, and days,
    respectively. Our example rule is set to 24 hours.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一列，*禁用*，表示要将主机列入黑名单多长时间。默认单位是秒，但你也可以使用`m`、`h`和`d`分别表示分钟、小时和天。我们的示例规则设置为24小时。
- en: So, with this rule in place, failing to authenticate to SSH three times will
    result in the client being blocked for 24 hours.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，设置了这条规则后，SSH 认证失败三次将导致客户端被封锁 24 小时。
- en: Once you have local rules set up, you can configure remote rules.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了本地规则，就可以配置远程规则。
- en: '**blacklistd.conf Remote Rules**'
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**blacklistd.conf 远程规则**'
- en: 'Use remote rules to specify how blacklistd varies its behavior depending on
    the remote host. Each of the fields in a remote rule is the same as that in the
    local rules, but how blacklistd uses them changes. Here’s a sample remote rule:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用远程规则来指定 blacklistd 如何根据远程主机改变其行为。远程规则中的每个字段与本地规则相同，但 blacklistd 使用它们的方式会有所不同。这里是一个示例远程规则：
- en: '[PRE33]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The *address* column is an IP (either IPv4 or IPv6) address, a port, or both.
    This lets you set special rules for a specific remote address range. Our sample
    rule applies to the address range 203.0.113.128/25.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*地址* 列是一个 IP 地址（IPv4 或 IPv6），一个端口，或者两者。这允许你为特定的远程地址范围设置特殊规则。我们的示例规则适用于地址范围
    203.0.113.128/25。'
- en: The *type*, *protocol*, and *owner* columns are interpreted identical to the
    local rules.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型*、*协议*和*所有者*列的解释与本地规则相同。'
- en: The *name* column gets interesting. The equal sign in a remote rule means “use
    the value from the local rule you’re matching.” This rule says to take the firewall
    rule name entry and add the network prefix /25 (a 255.255.255.128 netmask) to
    it. If a connection from this address range gets blacklisted, it will affect the
    entire subnet. If you put a PF anchor name here, the blacklistd adds rules for
    this address block to the named anchor. A wildcard reverts to the default table.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*名称* 列非常有趣。在远程规则中的等号意味着“使用你匹配的本地规则中的值”。这条规则表示从防火墙规则中获取规则名称条目，并在其后添加网络前缀 /25（一个
    255.255.255.128 的子网掩码）。如果来自这个地址范围的连接被列入黑名单，将会影响整个子网。如果你在此处放入一个 PF 锚点名称，blacklistd
    会将该地址块的规则添加到命名锚点中。通配符将恢复为默认表。'
- en: The *nfail* column lets you set a custom number of failures for this address.
    Maybe you want to offer that one customer that just can’t figure out how to type
    their password the first 30 times extra attempts to fail. Setting this column
    to an asterisk disables blocking.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*nfail* 列让你为这个地址设置自定义的失败次数。也许你想给那个总是输入错误密码的客户提供额外的尝试机会，允许他失败前 30 次。将此列设置为星号将禁用阻止功能。'
- en: The *disable* column lets you set a custom block time for this address block.
    Using a wildcard here disables blocking.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*禁用* 列允许你为这个地址块设置自定义的封锁时间。使用通配符将禁用封锁功能。'
- en: Remote rules let you enforce stricter limits on people you don’t like, while
    telling blacklistd(8) never to blacklist your office.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 远程规则让你对你不喜欢的人施加更严格的限制，同时告诉 blacklistd(8) 永远不要黑名单你的办公室。
- en: You can now start blacklistd. It won’t do anything, though, because programs
    don’t know they should complain to it. But once you configure them, it’ll be ready.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以启动 blacklistd 了。但它不会做任何事情，因为程序不知道它应该向 blacklistd 报告错误。不过，一旦你配置了它们，它就准备好了。
- en: '***Configuring Blacklistd Clients***'
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置 Blacklistd 客户端***'
- en: FreeBSD includes a few blacklistd-aware clients. The two you’re most likely
    to use are ftpd(8) and sshd(8).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 包含了一些支持 blacklistd 的客户端。你最可能使用的两个是 ftpd(8) 和 sshd(8)。
- en: To enable blacklistd in your SSH server, add the following line to */etc/ssh/sshd_config*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的 SSH 服务器中启用 blacklistd，请将以下行添加到 */etc/ssh/sshd_config* 中。
- en: '[PRE34]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Restart sshd.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 重启 sshd。
- en: Enable blacklisting in ftpd(8) with the `-B` command line option, either in
    */etc/inetd.conf* or in the standalone process’s */etc/rc.conf* flags.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ftpd(8) 中启用黑名单功能，可以使用 `-B` 命令行选项，配置在 */etc/inetd.conf* 中或独立进程的 */etc/rc.conf*
    标志中。
- en: '[PRE35]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: These programs will now whinge to blacklistd(8) any time someone fails to log
    in.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些程序会在有人登录失败时向 blacklistd(8) 报告。
- en: '***Managing Blacklistd***'
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***管理 Blacklistd***'
- en: Blacklisting annoying clients that have no right to poke at your services cuts
    down on the amount of log analysis you need to do, but you’ll probably want to
    see exactly what the blacklist is blocking. You want blacklistctl(8).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 将那些没有权限访问你服务的烦人客户端加入黑名单，能够减少你需要进行的日志分析量，但你可能会想看到 blacklistd 正在阻止的具体内容。你需要使用
    blacklistctl(8)。
- en: 'The blacklistctl(8) program has only one function: to display addresses and
    networks blocked by blacklistd. You always want the `blacklistctl dump` command.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: blacklistctl(8) 程序只有一个功能：显示 blacklistd 阻止的地址和网络。你总是需要使用 `blacklistctl dump`
    命令。
- en: By default, `blacklistctl dump` shows hosts that are in the list of candidates
    to be blocked but are not yet blocked. Add the `-b` flag to see all blocked hosts.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`blacklistctl dump` 显示的是在黑名单候选列表中的主机，但尚未被封锁。添加 `-b` 标志可以查看所有已封锁的主机。
- en: '[PRE36]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we see that the address range 203.0.113.128/25 attempted 6 out of 3 permitted
    login attempts. How did it achieve this? SSH lets a client try multiple logins
    on a single TCP/IP connection. Blacklisting doesn’t stop a live connection. The
    last time the guilty host attempted to access this service was at the date shown
    in `last access`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到地址范围203.0.113.128/25尝试了3次登录，但允许的登录尝试次数为6次。它是如何做到的？SSH允许客户端在一个TCP/IP连接上尝试多次登录。黑名单不会阻止一个活动连接。上次有问题的主机尝试访问此服务是在`last
    access`显示的日期。
- en: You might find the time remaining more useful than the time of last access.
    Add the `-r` flag.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现剩余时间比最后访问时间更有用。加上`-r`标志。
- en: '[PRE37]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Too soon, this subnet will be free to harass and harry my innocent SSH server.
    Maybe I need to increase the blacklist duration.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，这个子网将被释放，可以继续骚扰和困扰我的无辜SSH服务器。也许我需要增加黑名单的时效。
- en: '***De-Blacklisting***'
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***去黑名单***'
- en: 'Despite your best efforts, one day you’ll need to pull an address from the
    blacklist before it expires naturally. The blacklistctl(8) program offers no way
    to do this: you must manually delete the address from the PF table. Doing so requires
    understanding how blacklistd manages addresses inside PF.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你尽了最大努力，总有一天你需要在地址自然过期之前从黑名单中移除一个地址。blacklistctl(8)程序并不提供这样的功能：你必须手动从PF表中删除该地址。这样做需要理解blacklistd如何在PF中管理地址。
- en: Each blocked port has a child anchor inside the blacklistd anchor. This anchor
    is named after the port. The child anchor that blocks port 22 would be called
    *blacklistd/22*. Inside that child anchor, you’ll find a table containing the
    blocked addresses. The table is named *port*, followed by the port number. Hosts
    that can no longer connect to port 22 appear in a table called *port22*.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 每个被阻止的端口都有一个子锚点，在blacklistd锚点内。这个锚点是以端口命名的。阻止端口22的子锚点将被命名为*blacklistd/22*。在那个子锚点内，你会找到一个包含被阻止地址的表格。该表格的名称是*port*，后面跟着端口号。无法再连接到端口22的主机将出现在一个名为*port22*的表格中。
- en: Here, I use the packet filter control program pfctl(8) to examine the contents
    of the port22 table inside child anchor blacklistd/22\. I’m not going to explain
    all of this; just substitute your table and child anchor names. (Read Hansteen’s
    *The Book of PF* to let anchors drag you under. Far, far under.)
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用包过滤控制程序pfctl(8)来检查子锚点blacklistd/22\中的port22表的内容。我不会解释所有内容；只需替换你的表和子锚点名称。（阅读Hansteen的*《PF之书》*，让锚点将你拖得更深。非常深，非常深。）
- en: '[PRE38]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Yes, our problem address is in there. Removing it requires a fairly arcane pfctl(8)
    command.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们的问题地址就在其中。移除它需要一个相当深奥的pfctl(8)命令。
- en: '[PRE39]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The blacklist is maintained in a database outside of PF, though, so the blacklisted
    address will still show up in blacklistctl(8). That database entry will eventually
    expire harmlessly. If the host misbehaves again, it will get blocked again.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，黑名单是保存在PF之外的一个数据库中，因此被黑名单中的地址仍会出现在blacklistctl(8)中。该数据库条目最终会无害地过期。如果主机再次不当行为，它将再次被阻止。
- en: '**Public-Key Encryption**'
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**公钥加密**'
- en: Many server daemons rely upon public-key encryption to ensure confidentiality,
    integrity, and authenticity of communications. Many different internet services
    also use public-key encryption. You need a basic grasp of public-key encryption
    to run services like secure websites (https) and secure POP3 mail (pop3ssl). If
    you’re already familiar with public-key encryption, you can probably skip this
    section. If not, gird your loins for a highly compressed introduction to the topic.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 许多服务器守护进程依赖公钥加密来确保通信的机密性、完整性和真实性。许多不同的互联网服务也使用公钥加密。你需要对公钥加密有基本的了解，才能运行像安全网站（https）和安全POP3邮件（pop3ssl）这样的服务。如果你已经熟悉公钥加密，你大概可以跳过这一部分。如果不熟悉，请为一个高度压缩的入门介绍做好准备。
- en: Encryption systems use a key to transform messages between readable (cleartext)
    and encoded (ciphertext) versions. Although the words *cleartext* and *ciphertext*
    include the word *text*, they aren’t restricted to text; they can also include
    graphics files, binaries, and any other data you might want to send.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 加密系统使用密钥将消息在可读（明文）和编码（密文）版本之间转换。尽管*明文*和*密文*这两个词包含了*文本*一词，但它们并不限于文本；它们还可以包括图形文件、二进制文件以及你可能想要发送的任何其他数据。
- en: 'All cryptosystems have three main purposes: integrity, confidentiality, and
    nonrepudiation. *Integrity* means that the message hasn’t been tampered with.
    *Confidentiality* means that the message can be read only by the intended audience.
    And *nonrepudiation* means that the author can’t later claim that he or she didn’t
    write that message.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 所有加密系统有三个主要目的：完整性、保密性和不可否认性。*完整性*意味着消息没有被篡改。*保密性*意味着只有预定的受众能够读取消息。*不可否认性*意味着作者不能在事后声称自己没有写过这条消息。
- en: Older ciphers relied on a single key, and anyone with the key could both encrypt
    and decrypt messages. You might have had to do a lot of work to transform the
    message, as with the Enigma engine that drove the Allies nuts during World War
    II, but the key made the transformation possible. A typical example is any code
    that requires a key or password. The one-time message pads popular in spy novels
    are the ultimate single-key ciphers, impossible to break unless you have that
    exact key.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的密码系统依赖于单一密钥，任何拥有密钥的人都可以加密和解密消息。你可能需要做大量工作来转换消息，比如二战期间让盟军头痛的恩尼格玛机，但密钥使得这种转换成为可能。一个典型的例子就是需要密钥或密码的任何代码。流行于间谍小说中的一次性信息密码本就是最终的单密钥密码系统，除非你拥有那把准确的密钥，否则是无法破解的。
- en: 'Unlike single-key ciphers, public-key (or asymmetric) encryption systems use
    two keys: a private key and a public key. Messages are encrypted with one key
    and decrypted with the other, and digital signatures ensure the message isn’t
    tampered with en route. The math to explain this is really quite horrendous, but
    it does work—just accept that really, really large numbers behave really, really
    oddly. Generally, the key owner keeps the private key secret but hands the public
    key out to the world at large, for anyone’s use. The key owner uses the private
    key, while everyone else uses the public key. The key owner can encrypt messages
    that anyone can read, while anyone in the public can send a message that only
    the key owner can read.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 与单密钥密码系统不同，公钥（或非对称）加密系统使用两把密钥：一把私钥和一把公钥。消息使用其中一把密钥加密，使用另一把密钥解密，数字签名确保消息在传输过程中未被篡改。解释这一点的数学确实相当复杂，但它确实有效——只需要接受这样一个事实：非常非常大的数字表现得非常非常奇怪。通常，密钥拥有者会将私钥保密，但将公钥发给全世界供任何人使用。密钥拥有者使用私钥，而其他人则使用公钥。密钥拥有者可以加密任何人都能阅读的消息，而世界上任何人都可以发送只有密钥拥有者能够读取的消息。
- en: Public-key cryptography fills our need for integrity, confidentiality, and nonrepudiation.
    If an author wants anyone to be able to read his message, while ensuring that
    it isn’t tampered with, he can encrypt the message with his private key. Anyone
    with the public key (that is, the world) can read the message, but tampering with
    the message renders it illegible. (Depending on the use, he might choose to sign
    the message digitally instead.)
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密技术满足了我们对完整性、保密性和不可否认性的需求。如果作者希望任何人都能够读取他的消息，并确保消息未被篡改，他可以用自己的私钥加密消息。任何拥有公钥的人（也就是全世界的人）都可以读取这条消息，但一旦篡改，消息将变得无法辨认。（根据实际用途，他可能选择代替签署数字签名来签署消息。）
- en: Encrypting messages this way also ensures that the author of the message has
    the private key. If someone wants to send a message that can be read only by a
    particular person, he can encrypt the message with the desired audience’s public
    key. Only the person with the matching private key can read the message.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式加密消息还确保了消息的作者拥有私钥。如果某人想发送一条只有特定人员才能读取的消息，他可以用该特定受众的公钥来加密消息。只有拥有匹配私钥的人才能读取这条消息。
- en: This works well so long as the private key is kept private. Once the private
    key is stolen, lost, or made public, the security is lost. A careless person who
    has his private key stolen could even find others signing documents for him. Be
    careful with your keys, unless you want to learn that someone used your private
    key to order half a million dollars’ worth of high-end graphics workstations and
    have them overnighted to an abandoned-house maildrop in inner-city Detroit.^([3](footnote.xhtml#ch19fn3))
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 只要私钥保持私密，这种方法是有效的。一旦私钥被盗、丢失或公开，安全性就会丧失。一个粗心的人如果丢失了自己的私钥，甚至可能会发现别人代替他签署文件。如果你不想发现有人用你的私钥订购了价值五十万美元的高端图形工作站并将其通过快递送到底特律市中心一个废弃房屋的邮件投递点，就要小心保管好你的密钥。^([3](footnote.xhtml#ch19fn3))
- en: The standard toolkit for all of these operations is OpenSSL.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作的标准工具包是OpenSSL。
- en: '**WHY OPENSSL?**'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么选择OpenSSL？**'
- en: For many years, OpenSSL was the only choice for an encryption library. Today’s
    newer alternatives, although probably more reliable, don’t meet FreeBSD’s long-term
    support model. The most obvious replacement, LibreSSL, supports each release for
    only one year. Until an encryption toolkit is both reliable and can be upgraded
    throughout the course of a FreeBSD release’s lifespan, OpenSSL won’t be replaced.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，OpenSSL 一直是唯一的加密库选择。今天的更新替代方案，尽管可能更加可靠，但并不符合 FreeBSD 的长期支持模型。最明显的替代品，LibreSSL，只对每个版本提供一年的支持。在加密工具包既可靠又能在
    FreeBSD 发布周期内持续升级之前，OpenSSL 将不会被替代。
- en: '***OpenSSL***'
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***OpenSSL***'
- en: FreeBSD includes the OpenSSL toolkit for handling public-key cryptography. OpenSSL
    lets you perform a full range of encryption operations. While many programs use
    OpenSSL functionality, the sysadmin doesn’t need OpenSSL directly very often.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 包含了用于处理公钥加密的 OpenSSL 工具包。OpenSSL 让你能够执行全方位的加密操作。尽管许多程序使用 OpenSSL 的功能，系统管理员通常不需要直接使用
    OpenSSL。
- en: 'While OpenSSL works fine out of the box, I find it worthwhile to set a few
    defaults to make my life easier down the road. Configure OpenSSL with the file
    */etc/ssl/openssl.cnf*. Almost all of the settings in this file are correct as
    they are, and you shouldn’t change them unless you’re a cryptographer. The few
    things useful to change are the defaults for generating cryptographic signatures.
    Each default value is marked by the string `_default`. You’d be most interested
    in the following settings for common OpenSSL operations, which I’ve adjusted to
    fit my needs:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 OpenSSL 开箱即用，但我发现设置一些默认值可以让我的工作更轻松。使用文件 */etc/ssl/openssl.cnf* 配置 OpenSSL。该文件中的几乎所有设置默认是正确的，除非你是密码学家，否则不应该更改这些设置。可以更改的少数有用的设置是生成加密签名的默认值。每个默认值都以字符串
    `_default` 标记。你最可能关心的是以下设置，我已经根据自己的需求进行了调整：
- en: '[PRE40]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `countryName_default` ➊ is the two-letter code for your nation—in my case,
    `US`. The `stateOrProvinceName_default` ➋ is the name of your local state and
    can be of any length. I would set this to `Michigan`. The `0.organization``Name_default`
    field ➌ is your company name. If I’m buying a signed certificate, I’d put the
    same thing here that I want to appear on the certificate. If I’m just testing
    how programs work with SSL and don’t have a real company name, I might use the
    name of the company I work for or something that I make up.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`countryName_default` ➊ 是你所在国家的两字母代码——在我这里是 `US`。`stateOrProvinceName_default`
    ➋ 是你所在州的名称，可以是任何长度。我会设置为 `Michigan`。`0.organizationName_default` 字段 ➌ 是你的公司名称。如果我要购买签名证书，我会在这里填入希望出现在证书上的内容。如果只是测试程序如何与
    SSL 一起工作，并且没有真正的公司名称，我可能会使用我工作的公司名称或我自己编造的名称。'
- en: The following values don’t show up in *openssl.cnf*, but if you set them, they
    appear as defaults in the OpenSSL command prompts. I find these useful, even though
    they change more frequently than the previous defaults—they remind me of the correct
    format of these answers, if nothing else.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 以下值不会出现在 *openssl.cnf* 中，但如果你设置了它们，它们会作为默认值出现在 OpenSSL 命令提示符中。我发现这些很有用，尽管它们比之前的默认值更新得更频繁——它们至少能提醒我正确的答案格式。
- en: '[PRE41]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `localityName_default` ➊ is the name of your city. The `organizationalUnitName_default`
    ➋ is the part of your company this certificate is for. One of the most commonly
    misunderstood values in OpenSSL, `commonName_default` ➌, is the hostname of the
    machine this certificate is for, as it appears in reverse DNS. Remember, reverse
    DNS isn’t necessarily the same as the hostname! Your web server might have a nice
    friendly name, but the hosting company might assign it a totally different name
    in reverse DNS. Finally, `emailAddress_default` ➍ is the email address of the
    site administrator.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`localityName_default` ➊ 是你所在城市的名称。`organizationalUnitName_default` ➋ 是你公司中该证书所适用的部门。OpenSSL
    中最常被误解的值之一是 `commonName_default` ➌，它是该证书所属机器的主机名，如同反向 DNS 中所显示的那样。记住，反向 DNS 不一定与主机名相同！你的
    Web 服务器可能有一个友好的名称，但托管公司可能会在反向 DNS 中为它分配一个完全不同的名称。最后，`emailAddress_default` ➍ 是站点管理员的电子邮件地址。'
- en: These values all show up in prompts in the OpenSSL command as default choices.
    Setting them in the configuration file will save you annoyance later.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值会作为默认选择出现在 OpenSSL 命令提示符中。将它们设置在配置文件中可以省去后续的麻烦。
- en: '***Certificates***'
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***证书***'
- en: One interesting thing about public-key encryption is that the author and the
    audience don’t have to be people. They can be programs. Secure Shell (SSH) and
    the Secure Sockets Layer (SSL) are two different ways programs can communicate
    without fear of intruders listening in. Public-key cryptography is a major component
    of the *digital certificates* used by secure websites and secure mail services.
    When you open Firefox to buy something online, you might not realize that the
    browser is frantically encrypting and decrypting web pages. This is why your computer
    might complain about “invalid certificates;” someone’s public key has either expired
    or the certificate is self-signed. Today’s protocols encrypt and decrypt with
    *Transport Layer Security (TLS)* and use *TLS certificates*.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 关于公钥加密，有一个有趣的地方是，作者和受众不必是人类。他们可以是程序。安全外壳（SSH）和安全套接字层（SSL）是程序可以在不担心入侵者窃听的情况下通信的两种不同方式。公钥密码学是*数字证书*的一个重要组成部分，这些数字证书用于安全网站和安全邮件服务。当你打开Firefox购买东西时，可能没意识到浏览器正在疯狂地加密和解密网页。这就是为什么你的计算机会抱怨“无效证书”的原因；某人的公钥可能已经过期，或者证书是自签的。今天的协议使用*传输层安全（TLS）*进行加密和解密，并使用*TLS证书*。
- en: '**SSL VS. TLS**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**SSL 与 TLS**'
- en: You hear about SSL all the time, but it’s most often incorrect. Today, Transport
    Layer Security (TLS) has mostly replaced SSL. Most uses of the term *SSL* are
    lingering remnants. Generally speaking, internet-facing sites should use TLS version
    1.1 or better. TLS version 1.0 is only weakly protected. Traffic secured by any
    version of the SSL protocol isn’t secured.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你常常听到关于SSL的说法，但它通常是不正确的。今天，传输层安全（TLS）大多取代了SSL。大多数关于*SSL*的使用是遗留下来的残余。一般来说，面向互联网的网站应该使用TLS
    1.1或更高版本。TLS 1.0的保护仅仅是弱保护。任何版本的SSL协议所加密的流量都不安全。
- en: Many companies, such as VeriSign, provide a public-key signing service. These
    companies are called *Certificate Authorities (CAs)*, as they provide *TLS certificates*.
    Other companies that need a certificate signed provide proof of their identity,
    such as corporate papers and business records, and those public-key signing companies
    sign the applicant’s certificate with their CA certificate. By signing the certificate,
    the CA says, “I have inspected this person’s credentials and he, she, or it has
    proven their identity to my satisfaction.” They’re not guaranteeing anything else,
    however. A TLS certificate owner can use the certificate to run a website that
    sells fraudulent or dangerous products or use it to encrypt a ransom note. Signed
    TLS certificates guarantee certain types of technical security, not personal integrity
    or even unilateral technical security. Certificates don’t magically apply security
    patches for you.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 许多公司，如VeriSign，提供公钥签名服务。这些公司被称为*证书颁发机构（CAs）*，因为它们提供*TLS证书*。其他需要签署证书的公司提供他们的身份验证证明，如公司文件和商业记录，然后这些公钥签名公司用它们的CA证书签署申请人的证书。通过签署证书，CA表示：“我已检查过此人的证件，他/她/它已证明自己的身份，且我对此表示满意。”然而，它们并不保证其他任何事情。TLS证书的拥有者可以使用证书运行一个销售欺诈或危险产品的网站，或者用它来加密勒索信。签名的TLS证书保证的是某些类型的技术安全，而非个人诚信，甚至也不保证单方面的技术安全。证书并不会神奇地为你应用安全补丁。
- en: Web browsers and other certificate-using software include certificates for the
    major CAs. When the browser receives a certificate signed by a CA, it recognizes
    the certificate as legitimate. Essentially, the web browser says, “I trust the
    Certificate Authority, and the Certificate Authority trusts this company, so I
    will trust the company.” So long as you trust the CA, everything works.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器和其他使用证书的软件包含主要CA的证书。当浏览器收到一个由CA签署的证书时，它会将该证书视为合法。基本上，网络浏览器会说：“我信任这个证书颁发机构，而证书颁发机构信任这家公司，因此我也会信任这家公司。”只要你信任该CA，一切都能正常工作。
- en: The package `ca_root_nss` contains the CA certificates recognized by the Mozilla
    Project. If a piece of software fails attempting to validate certificates, make
    sure you installed this package.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`ca_root_nss`包包含Mozilla项目认可的CA证书。如果某个软件在验证证书时失败，请确保你已安装该包。'
- en: Most CAs are big commercial companies. No matter the size of your organization,
    though, I encourage you to investigate Let’s Encrypt (*[https://www.letsencrypt.org/](https://www.letsencrypt.org/)*).
    Let’s Encrypt is a CA that provides free, globally valid TLS certificates.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数CA都是大型商业公司。不过，无论你的组织规模如何，我建议你调查Let’s Encrypt（*[https://www.letsencrypt.org/](https://www.letsencrypt.org/)*）。Let’s
    Encrypt是一个提供免费、全球有效的TLS证书的CA。
- en: Using a certificate that’s not signed by any CA is perfectly fine for testing.
    It might also suffice for applications within a company, where you can install
    the certificate in the client web browser or tell your users to trust the certificate.
    We’ll look at both ways.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用未被任何 CA 签名的证书在测试中是完全可以的。它也可能适用于公司内部的应用程序，你可以将证书安装到客户端的网页浏览器中，或者告诉用户信任该证书。我们将讨论这两种方法。
- en: Both uses of the certificate require a host key.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种证书使用都需要一个主机密钥。
- en: '**TLS Host Key**'
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**TLS 主机密钥**'
- en: 'Both signed and self-signed certificates require a private key for the host.
    The host key is just a carefully crafted random number. The following command
    creates a 2,048-bit host key and places it in the file *host.key*:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是签名证书还是自签名证书，都需要主机的私钥。主机密钥只是一个精心生成的随机数。以下命令创建一个 2,048 位的主机密钥并将其放置在 *host.key*
    文件中：
- en: '[PRE42]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You’ll see a statement that OpenSSL is creating a host key and dots crossing
    the screen as key generation proceeds. In only a few seconds, you’ll have a file
    containing a key. The key is a plaintext file that contains the words `BEGIN RSA
    PRIVATE KEY` and a bunch of random characters.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一条声明，表示 OpenSSL 正在创建主机密钥，并且屏幕上会出现点点移动，表示密钥生成过程正在进行。只需几秒钟，你就会得到一个包含密钥的文件。该文件是一个纯文本文件，包含
    `BEGIN RSA PRIVATE KEY` 和一堆随机字符。
- en: Protect your host key! Make it owned by root and readable only by root. Once
    you place your certificate in production, anyone who has that key can use it to
    eavesdrop on your private communications.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 保护你的主机密钥！确保它由 root 拥有并且仅 root 可读。一旦将证书投入生产环境，任何拥有该密钥的人都可以用它来窃听你的私人通信。
- en: '[PRE43]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Place this host key in a directory with the same permissions that we placed
    on the key file itself.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个主机密钥放置在与我们为密钥文件本身设置的权限相同的目录中。
- en: '**Create a Certificate Request**'
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建证书请求**'
- en: 'You need a certificate request for either a signed or self-signed certificate.
    We don’t do much with OpenSSL, so we won’t dissect this command. Go to the directory
    with your host key and enter this verbatim:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个证书请求，无论是签名证书还是自签名证书。我们不常使用 OpenSSL，所以我们不会深入分析这个命令。进入包含主机密钥的目录，并按原样输入以下命令：
- en: '[PRE44]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In response, you’ll see instructions and then a series of questions. By hitting
    ENTER, you’ll take the default answers. If you’ve configured OpenSSL, the default
    answers are correct.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应中，你将看到一些说明，然后是一系列问题。按下 ENTER 键，你将接受默认答案。如果你已配置 OpenSSL，则默认答案是正确的。
- en: '[PRE45]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The two-letter code for the country ➊ is defined in the ISO 3166 standard, so
    a quick web search will find this for you. If you don’t know the state ➋ and city
    ➌ you live in, ask someone who occasionally leaves the server room. The organization
    name ➍ is probably your company, and you list the department or division name
    ➎ as well. If you don’t have a company, list your family name or some other way
    to uniquely identify yourself, and for a self-signed certificate, you can list
    anything you want. Different CAs have different standards for noncorporate entities,
    so check the CA’s instructions.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 国家代码 ➊ 是根据 ISO 3166 标准定义的，你可以通过快速的网页搜索找到它。如果你不知道你所在的州 ➋ 和城市 ➌，可以问问偶尔离开服务器房间的人。组织名称
    ➍ 很可能是你的公司，并且你也需要列出部门或分部名称 ➎。如果你没有公司，可以列出你的姓氏或其他任何能唯一标识你的方式，对于自签名证书，你可以列出任何你想要的内容。不同的
    CA 对非公司实体有不同的标准，所以请检查 CA 的说明。
- en: The common name ➏ is frequently misunderstood. It’s not your name; it’s the
    name of the server as shown in reverse DNS. You must have a server name here,
    or the request will be useless.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 公共名称 ➏ 经常被误解。它不是你的名字，而是反向 DNS 中显示的服务器名称。你必须在这里填写服务器名称，否则请求将毫无用处。
- en: I suggest using a generic email address ➐ rather than an individual’s email
    address. In this case, I *am* [michaelwlucas.com](http://michaelwlucas.com), so
    I might as well use my address. You don’t want your organization’s certificates
    tied to an individual who might leave the company for whatever reason.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用一个通用的电子邮件地址 ➐，而不是个人的电子邮件地址。在这种情况下，我 *是* [michaelwlucas.com](http://michaelwlucas.com)，所以我可以使用我的地址。你不希望你的组织的证书与一个可能因任何原因离开公司的个人挂钩。
- en: '[PRE46]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The challenge password ➊ is also known as a *passphrase*. Again, keep this secret
    because anyone with the passphrase can use your certificate. Use of a certificate
    passphrase is optional, however. If you use one, you must type it when your server
    starts. That means that if your web server crashes, the website won’t work until
    someone enters the passphrase. While passphrase use is highly desirable, this
    might be unacceptable. Hit ENTER to use a blank passphrase.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战密码➊也被称为*密码短语*。再次提醒，保密这个密码短语，因为任何知道它的人都可以使用你的证书。然而，使用证书密码短语是可选的。如果使用密码短语，服务器启动时必须输入它。这意味着，如果你的Web服务器崩溃，网站将无法正常工作，直到有人输入密码短语。虽然使用密码短语非常有价值，但这可能是不可接受的。按ENTER键以使用空密码短语。
- en: You’ve already entered quite a few company names, so a third ➋ is probably unnecessary.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经输入了不少公司名称，所以第三个➋可能没有必要了。
- en: Once you return to a command prompt, you’ll see the file *csr.pem* in the current
    directory. It looks much like your host key, except that the top line says `BEGIN
    CERTIFICATE REQUEST` instead of `BEGIN RSA PRIVATE KEY`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你返回命令提示符，你会看到当前目录下有一个名为*csr.pem*的文件。它看起来与您的主机密钥非常相似，不同之处在于顶行显示的是`BEGIN CERTIFICATE
    REQUEST`，而不是`BEGIN RSA PRIVATE KEY`。
- en: Submit *csr.pem* to your Certificate Authority, who will return the actual certificate.
    I recommend saving the certificate in a file named after the host, such as *www.mwl.io.crt*.
    This signed certificate is good for any TLS service, including web pages, pop3ssl,
    or any other TLS-capable daemon.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 将*csr.pem*提交给你的证书授权中心，证书授权中心将返回实际的证书。我建议将证书保存在一个以主机命名的文件中，比如*www.mwl.io.crt*。这个签名证书适用于任何TLS服务，包括网页、pop3ssl或任何其他支持TLS的守护进程。
- en: Some CAs require you use an intermediate certificate with your cert. While most
    daemons have a configuration option to specify an intermediate certificate, if
    yours doesn’t, you can append the signed certificate to the end of the intermediate
    cert.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 一些CA要求你使用中间证书与您的证书一起使用。虽然大多数守护进程有配置选项来指定中间证书，但如果没有，你可以将签名证书附加到中间证书的末尾。
- en: '**Sign a Certificate Yourself**'
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**自行签署证书**'
- en: 'A self-signed certificate is technically identical to a signed certificate,
    but it’s not submitted to a Certificate Authority. Instead, you provide the signature
    yourself. Most customers won’t accept a self-signed certificate on a production
    service, but it’s perfectly suitable for testing. To sign your own CSR, run the
    following:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 自签名证书在技术上与签名证书相同，但它没有提交给证书授权中心。相反，你自己提供签名。大多数客户不会在生产服务中接受自签名证书，但它非常适合用于测试。要签署你自己的CSR，请运行以下命令：
- en: '[PRE47]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: That’s it! You now have a self-signed certificate good for 365 days ➊ in the
    file *selfsigned.crt* ➋. You can use this key exactly like a signed certificate,
    so long as you’re willing to ignore the warnings your application displays.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你现在拥有一个有效期为365天➊的自签名证书，保存在文件*selfsigned.crt*➋中。你可以像使用签名证书一样使用这个密钥，只要你愿意忽略应用程序显示的警告。
- en: If you sign your own certificates, client software generates warnings that the
    “certificate signer is unknown.” This is expected—after all, people outside my
    office have no idea who Michael W. Lucas is or why he’s signing web certificates.
    For some reason, people trust Symantec and other big-company CAs. I’m trusted
    by the people who know me,^([4](footnote.xhtml#ch19fn4)) but not trusted by the
    world at large. For this reason, don’t use self-signed certificates anywhere the
    public will see them because the warnings will confuse, annoy, or even scare them
    away.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你自行签署证书，客户端软件会生成“证书签名者未知”的警告。这是正常的——毕竟，除了我的办公室的人，没有人知道Michael W. Lucas是谁，或者他为什么要签署网站证书。出于某种原因，人们信任Symantec和其他大型公司的CA。我被认识我的人信任^([4](footnote.xhtml#ch19fn4))，但在全球范围内并不被信任。因此，不要在公众能够看到的地方使用自签名证书，因为警告会让他们困惑、恼火，甚至把他们吓跑。
- en: But before you go drop any amount of money on a CA certificate, definitely check
    out Let’s Encrypt. It really will change your system administration practice.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在你花钱购买CA证书之前，务必先查看Let’s Encrypt。它真的会改变你的系统管理实践。
- en: '***TLS Trick: Connecting to TLS-Protected Ports***'
  id: totrans-372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***TLS技巧：连接到TLS保护的端口***'
- en: I said we wouldn’t do much with OpenSSL, and that’s correct. There’s one facility
    the software offers that’s too useful to pass up, however, and once you know it,
    you’ll use this one trick at least once a month and be glad you have it.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我说过我们不会做太多OpenSSL的操作，没错。但这款软件提供了一个太有用的功能，不能错过，一旦你学会了，你每月至少会使用这个技巧一次，并且很高兴你掌握了它。
- en: 'Throughout this book, we test network services by using telnet(1) to connect
    to the daemon running on that port and issuing commands. This works well for plaintext
    services such as SMTP, POP3, and HTTP. It doesn’t work for encrypted services
    such as HTTPS. You need a program to manage the encryption for you when you connect
    to these services. OpenSSL includes the `openssl s_client` command, which is intended
    for exactly this sort of client debugging. While you’ll see a lot of cryptographic
    information, you’ll also get the ability to issue plaintext commands to the daemon
    and view its responses. Use the command `openssl s_client -connect` with a hostname
    and port number, separated by a colon. Here, we connect to the secure web server
    at *[www.absolutefreebsd.com](http://www.absolutefreebsd.com)*:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们通过使用telnet(1)连接到运行在该端口上的守护进程并发出命令来测试网络服务。这对于SMTP、POP3和HTTP等明文服务效果很好，但对加密服务如HTTPS则不起作用。当你连接到这些服务时，你需要一个程序来为你管理加密。OpenSSL包含`openssl
    s_client`命令，专门用于这种类型的客户端调试。虽然你会看到很多加密信息，但你还可以发出明文命令给守护进程，并查看它的响应。使用命令`openssl
    s_client -connect`，并提供主机名和端口号，中间用冒号隔开。这里，我们连接到安全网页服务器 *[www.absolutefreebsd.com](http://www.absolutefreebsd.com)*：
- en: '[PRE48]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You’ll see lots of stuff about chains of trust and limitations of liability,
    as well as lines and lines of the random-looking digital certificates. After all
    that, however, you’ll see a blank line with no command prompt. You’re speaking
    directly to the server daemon. As this is a web server, let’s try an HTTP command:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到许多关于信任链和责任限制的内容，以及看起来随机的数字证书。然而，在所有这些之后，你会看到一个空白行，没有命令提示符。你正在直接与服务器守护进程对话。由于这是一个网页服务器，让我们尝试一个HTTP命令：
- en: '[PRE49]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The system responds with:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 系统响应如下：
- en: '[PRE50]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The HTTP protocol has changed since the last time I tried this, I guess. But
    I’m definitely connected to the web server. The network works.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议自上次我尝试这个以来发生了变化，我猜是这样。但我肯定已经连接到网页服务器了。网络工作正常。
- en: Some of you are probably wondering why we encrypt the service if it’s so easy
    to talk to the encrypted service. The encryption doesn’t protect the daemon; it
    protects the data stream between the client and the server. TLS encryption prevents
    someone from eavesdropping your network conversation in transit—it doesn’t protect
    either the server or the client. TLS can’t save you if someone breaks into your
    desktop.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你们中的一些人可能会想，如果与加密服务的通信如此简单，为什么还要加密这个服务呢？加密并不是保护守护进程，而是保护客户端和服务器之间的数据流。TLS加密可以防止有人在传输过程中窃听你的网络对话——它并不保护服务器或客户端。如果有人闯入了你的桌面，TLS也无法拯救你。
- en: From this point on, I’ll assume that you understand this OpenSSL command and
    what happens when we use it.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 从此时起，我假设你已经理解了这个OpenSSL命令以及我们使用它时发生的事情。
- en: '**HARDWARE CRYPTOGRAPHIC SUPPORT**'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**硬件加密支持**'
- en: Most modern hardware has built-in encryption acceleration. Unfortunately, FreeBSD
    doesn’t include it in the default configuration. Hardware crypto acceleration
    reduces load on the CPU and probably accelerates encryption. The aesni(4) kernel
    module activates access to Intel’s hardware cryptographic accelerator. A driver
    for the new AMD accelerator is in development. In-kernel drivers affect only encryption
    that happens in the kernel, such as for encrypted disks and IPSec.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代硬件都内置了加密加速功能。不幸的是，FreeBSD默认配置中没有包含这一功能。硬件加密加速可以减少CPU的负载，并且可能加速加密过程。aesni(4)内核模块激活了对Intel硬件加密加速器的访问。新的AMD加速器驱动正在开发中。内核驱动仅影响内核中发生的加密过程，例如加密磁盘和IPSec。
- en: '**Global Security Settings**'
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**全局安全设置**'
- en: FreeBSD supports many optional security settings. These settings change basic
    FreeBSD behavior, making it differ from the common Unix experience. Some other
    operating systems provide these settings by default, however, so they’re not unique
    to FreeBSD.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD支持许多可选的安全设置。这些设置改变了基本的FreeBSD行为，使其与常见的Unix体验不同。然而，一些其他操作系统默认提供这些设置，因此它们并不唯一于FreeBSD。
- en: Should you turn all these features on in the name of improved security? There’s
    no universally correct answer here. If restricting access to part of the system
    to the root account means that you’ll need to give more people root access, maybe
    you shouldn’t impose that restriction. A couple of these should be activated on
    all systems, though.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否应该为了提高安全性而开启所有这些功能？这里没有一个普遍正确的答案。如果限制某部分系统的访问权限到root账户意味着你需要给予更多的人root权限，也许你不应该强制施加这种限制。不过，其中有几项应该在所有系统上启用。
- en: '***Install-Time Options***'
  id: totrans-388
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安装时选项***'
- en: The FreeBSD installer provides an option for enabling each of these settings
    on first boot. You can enable and disable them later with the given sysctl setting.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 安装程序提供了一个选项，可以在首次启动时启用这些设置。你可以稍后使用给定的 sysctl 设置启用或禁用它们。
- en: Many of these features are especially useful on servers that don’t have many
    users. If your application server doesn’t have unprivileged users other than those
    used by applications, you should probably enable features that restrict unprivileged
    users. If you have unprivileged users, though, consider the situation more closely.
    Most of my unprivileged users^([5](footnote.xhtml#ch19fn5)) shouldn’t be looking
    at server processes or other users, so I lock them down.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能在用户不多的服务器上特别有用。如果你的应用服务器除了应用程序使用的用户外没有其他非特权用户，那么你应该启用限制非特权用户的功能。不过，如果有非特权用户，请更仔细地考虑这种情况。我的大多数非特权用户^([5](footnote.xhtml#ch19fn5))不应该查看服务器进程或其他用户，因此我会对他们进行限制。
- en: '**Hiding Other UIDs’ Processes**'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐藏其他 UID 的进程**'
- en: Normally, commands like `ps -ax` display all processes running on the system.
    When you set the sysctl `security.bsd.see_other_uids` to 0, users can see only
    their own processes. Root can see all processes, no matter how you set this.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，像 `ps -ax` 这样的命令会显示系统上所有正在运行的进程。当你将 sysctl `security.bsd.see_other_uids`
    设置为 0 时，用户只能看到自己的进程。无论如何设置，root 用户可以看到所有进程。
- en: '**Hiding Other GIDs’ Processes**'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐藏其他 GID 的进程**'
- en: Similarly, users can normally see processes owned by other groups. Disable that
    ability by setting the sysctl `security.bsd.see_other_gids` to 0\. Again, root
    can see every process, no matter how this is set.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，用户通常可以看到其他组拥有的进程。通过将 sysctl `security.bsd.see_other_gids` 设置为 0，可以禁用该功能。同样，root
    用户可以看到所有进程，无论该设置如何。
- en: '**Hiding Jailed Processes**'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐藏监禁进程**'
- en: Users on a host can usually see all processes running in jails. By setting `security.bsd.see_jail_proc`
    to 0, unprivileged nonjailed users can’t see jailed processes. This feature appeared
    in FreeBSD 12.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 主机上的用户通常可以看到所有在 jail 中运行的进程。通过将 `security.bsd.see_jail_proc` 设置为 0，非特权的非监禁用户将无法看到监禁进程。这个功能出现在
    FreeBSD 12 中。
- en: '**Hide Message Buffer**'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐藏消息缓冲区**'
- en: Unprivileged users can normally see the system message buffer, available through
    dmesg(8). Disable that access by setting the sysctl `security``.bsd.unprivileged_read_msgbuf`
    to 0.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 非特权用户通常可以看到系统消息缓冲区，该缓冲区可以通过 dmesg(8) 访问。通过将 sysctl `security.bsd.unprivileged_read_msgbuf`
    设置为 0，可以禁用该访问。
- en: '**Disable Process Debugging**'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**禁用进程调试**'
- en: A debugger can tell users a whole bunch of useful information. Setting `security.bsd.unprivileged_proc_debug`
    to 0 disallows unprivileged users from using the debugger on processes.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器可以告诉用户大量有用的信息。将 `security.bsd.unprivileged_proc_debug` 设置为 0，禁止非特权用户使用调试器调试进程。
- en: '**Randomize Process IDs**'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**随机化进程 ID**'
- en: Traditional Unix systems create process IDs in sequential order, allowing attackers
    a chance at guessing what the next PID will be. Randomize process IDs by setting
    the sysctl `kern.randompid` to a random large integer. If you set it to 1, the
    kernel picks a fresh random number between 100 and 1,123 at each boot.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 Unix 系统按顺序创建进程 ID，这让攻击者有机会猜测下一个 PID 会是什么。通过将 sysctl `kern.randompid` 设置为一个随机的大整数，可以随机化进程
    ID。如果你将其设置为 1，内核在每次启动时会从 100 到 1,123 之间选择一个新的随机数。
- en: '**Clean /tmp**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**清理 /tmp**'
- en: All sensible Unix-like systems clean */tmp* at boot to dispose of temporary
    files. Somewhere in the last few years, FreeBSD turned this behavior off by default.
    You might use tmpfs(5) for */tmp*, which gets destroyed at every power-down. If
    your */tmp* is on disk, though, well . . . as you’re all sensible and wholesome
    sysadmins, always set `clear_tmp_enable` to `YES` in */etc/rc.conf*.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 所有合理的类 Unix 系统在启动时会清理 */tmp* 以清除临时文件。在过去的几年里，FreeBSD 默认关闭了这个行为。你可以使用 tmpfs(5)
    来处理 */tmp*，它会在每次关机时销毁。如果你的 */tmp* 存储在磁盘上，那么……作为一个理性和合格的系统管理员，请始终在 */etc/rc.conf*
    中将 `clear_tmp_enable` 设置为 `YES`。
- en: '**Disable Syslogd Networking**'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**禁用 Syslogd 网络功能**'
- en: By default, syslogd(8) creates a half-open socket on UDP port 514\. Nobody can
    connect to this socket; it’s used only as a placeholder so nothing else binds
    to that port. Some people consider this half-open socket problematic. I’d say
    it’s a feature; you don’t want something else binding to port 514, claiming to
    be syslogd, and sending either worrisome or falsely soothing messages to your
    logging host. But to disable that half-open socket, set `syslogd_flags` to `-ss`
    in */etc/rc.conf*.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，syslogd(8) 会在 UDP 端口 514 上创建一个半开放的套接字。没有人可以连接到这个套接字；它仅作为占位符使用，以防止其他东西绑定到该端口。一些人认为这个半开放的套接字是一个问题。但我认为这是一个特性；你不希望其他东西绑定到端口
    514，声称自己是 syslogd，并向你的日志主机发送令人担忧或虚假安抚的消息。要禁用这个半开放的套接字，请在 */etc/rc.conf* 文件中将 `syslogd_flags`
    设置为 `-ss`。
- en: '**Disable Sendmail**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**禁用 Sendmail**'
- en: A default FreeBSD install doesn’t accept email from the network, but it does
    run a sendmail(8) daemon to sent outgoing messages. To completely disable sending
    mail from this host, set `sendmail_enable` to `NONE` in */etc/rc.conf*.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 FreeBSD 安装不会接受来自网络的电子邮件，但它会运行一个 sendmail(8) 守护进程来发送外发邮件。要完全禁用从此主机发送邮件，请在
    */etc/rc.conf* 文件中将 `sendmail_enable` 设置为 `NONE`。
- en: Disabling outbound mail won’t prevent the daily, weekly, and monthly maintenance
    tasks from running. It’ll prevent you from receiving the output of those messages
    unless you log directly onto the host, however. For people with multiple hosts,
    disabling outbound mail is unwise. Disabling Sendmail makes sense if you use an
    alternative mail agent, such as dma(8) (see [Chapter 20](ch20.xhtml#ch20)).
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用外发邮件不会阻止每日、每周和每月的维护任务运行。然而，除非你直接登录到主机，否则它会阻止你接收这些消息的输出。对于有多个主机的人来说，禁用外发邮件是不明智的。如果你使用其他邮件代理，例如
    dma(8)（请参见 [第 20 章](ch20.xhtml#ch20)），禁用 Sendmail 是合理的。
- en: '***Secure Console***'
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安全控制台***'
- en: Most Unix systems consider the physical console secure. Anyone who has access
    to the physical machine can do anything to the host that they want, including
    changing the root password. By changing all of the */etc/ttys* entries that say
    `secure` to `insecure`, you tell FreeBSD to demand the root password even in single-user
    mode.^([6](footnote.xhtml#ch19fn6)) This won’t prevent someone from physical access
    gaining access to your operating system, but it’ll mean that they’ll have to do
    slightly more work to subvert your machine. *Very* slightly more work.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Unix 系统认为物理控制台是安全的。任何拥有物理机器访问权限的人都可以对主机做任何事情，包括更改 root 密码。通过将所有 */etc/ttys*
    文件中标记为 `secure` 的条目更改为 `insecure`，你告诉 FreeBSD 即使在单用户模式下也要求输入 root 密码。^([6](footnote.xhtml#ch19fn6))
    这不会阻止某人通过物理访问来入侵你的操作系统，但意味着他们需要做更多的工作来破坏你的机器。*非常*稍微多一点的工作。
- en: '***Nonexecutable Stack and Stack Guard***'
  id: totrans-412
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***不可执行堆栈与堆栈保护***'
- en: One basic exploit mitigation technique is the nonexecutable stack. Once a program
    is loaded into memory, each page of memory allocated to that program should be
    either writable or executable, but not both.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 一种基本的漏洞缓解技术是不可执行堆栈。程序加载到内存后，分配给该程序的每个内存页面应该是可写的或可执行的，但不能两者兼具。
- en: A common exploit technique is to trick a program into writing information to
    memory and then executing that memory. An attacker might convince a program to
    write to a chunk of memory, but with the nonexecutable stack, the kernel won’t
    execute it.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的漏洞利用技术是欺骗程序将信息写入内存，然后执行该内存。攻击者可能会说服程序写入一块内存，但在不可执行堆栈的情况下，内核不会执行它。
- en: The stack defaults to nonexecutable on modern versions of FreeBSD. The only
    reason to disable this is if you have a badly written program that relies on executing
    and writing the same chunk of memory. Most such defective software has been rightfully
    purged from the open source ecosystem in the last 15 years. If you’re very unlucky
    and can’t avoid running a program that can’t handle a nonexecutable stack, you
    can disable this by setting the sysctls `kern.elf32.nxstack` (for 32-bit programs)
    or `kern.elf64.nxstack` (for 64-bit programs) to 0.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代版本的 FreeBSD 中，堆栈默认是不可执行的。禁用此功能的唯一理由是，如果你有一个编写不当的程序，依赖于执行和写入同一块内存。大多数此类有缺陷的软件在过去
    15 年中已被正当地清除出开源生态系统。如果你非常不幸且无法避免运行无法处理不可执行堆栈的程序，你可以通过将 `kern.elf32.nxstack`（对于
    32 位程序）或 `kern.elf64.nxstack`（对于 64 位程序）设置为 0 来禁用此功能。
- en: Related to the nonexecutable stack, a stack guard page adds a random-sized shred
    of extra memory between parts of a program’s memory allocation. This makes it
    harder for an attacker to guess memory addresses. FreeBSD allocates a stack guard
    page by default, but you can turn it off by setting the sysctl `security.bsd.stack_guard_page`
    to 0.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 与不可执行堆栈相关，堆栈保护页在程序内存分配的各部分之间添加了一个大小随机的额外内存片段。这使得攻击者更难猜测内存地址。FreeBSD 默认分配堆栈保护页，但你可以通过将
    sysctl `security.bsd.stack_guard_page` 设置为 0 来关闭它。
- en: '***Other Security Settings***'
  id: totrans-417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***其他安全设置***'
- en: Most of FreeBSD’s other kernel-level security settings are available in the
    `security.bsd` sysctl tree. More get added every few months. Run `sysctl -d security.bsd`
    to display your hosts’ available options. I’ve described many of these earlier
    in this section, but you might find some of the others useful. Options include
    disabling the root account’s privileges (`security.bsd.suser_enabled`), allowing
    nonroot users to set an idle priority (`security.bsd.unprivileged_idprio`), and
    blocking unprivileged users from using mlock(2) (`security.bsd.unprivileged_mlock`).
    Take a look at the current options and see what might be useful.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 其他大多数内核级安全设置可以在 `security.bsd` sysctl 树中找到。每隔几个月会增加一些新的设置。运行 `sysctl
    -d security.bsd` 来显示主机可用的选项。我在本节中已经描述了其中的许多内容，但你可能会发现其他一些设置也有用。选项包括禁用 root 账户的特权（`security.bsd.suser_enabled`）、允许非
    root 用户设置空闲优先级（`security.bsd.unprivileged_idprio`）以及阻止非特权用户使用 mlock(2)（`security.bsd.unprivileged_mlock`）。看看当前的选项，看看哪些可能有用。
- en: '**Preparing for Intrusions with mtree(1)**'
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 mtree(1) 为入侵做准备**'
- en: One of the worst things to happen to a sysadmin is something that makes him
    think that his system could’ve been penetrated. If you find mysterious files in
    */tmp* or extra commands in */usr/local/sbin*, or if things “just don’t feel right,”
    you’ll be left wondering whether someone has compromised your system. The worst
    thing about this feeling is that there’s no way to prove it hasn’t happened. A
    skilled attacker can replace system binaries with her own customized versions,
    so that her actions are never logged and your attempts to find her will fail.
    Having Sherlock Holmes examine your server with a magnifying glass is useless
    when the magnifying glass has been provided by the criminal and includes the special
    criminal-cloaking feature! People have even hijacked the system compiler so that
    freshly built binaries include the hijacker’s backdoor.^([7](footnote.xhtml#ch19fn7))
    What makes matters worse is that computers do weird things all the time. Operating
    systems are terribly complicated, and applications are worse. Maybe that weird
    file in */tmp* is something your text editor barfed up when you hit the keys too
    fast, or perhaps it’s a leftover from a sloppy intruder.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 对系统管理员来说，最糟糕的事情之一就是让他觉得系统可能被攻破了。如果你在 */tmp* 中发现神秘文件，或在 */usr/local/sbin* 中发现多余的命令，或者感觉“总有些不对劲”，你就会怀疑是否有人入侵了你的系统。最糟糕的是，这种感觉无法得到证实。一个熟练的攻击者可以用她自己定制的版本替换系统二进制文件，这样她的行为就永远不会被记录，你对她的追踪也会失败。当犯罪分子提供了放大镜并包含了特殊的犯罪遮掩功能时，给你的服务器做检查就像是让福尔摩斯用放大镜来检查你的服务器一样毫无意义！有人甚至劫持了系统编译器，以便新构建的二进制文件包含劫持者的后门。^([7](footnote.xhtml#ch19fn7))
    更糟糕的是，计算机经常做出奇怪的事情。操作系统极其复杂，应用程序更糟。也许 */tmp* 中那个奇怪的文件是你的文本编辑器在你敲键盘太快时吐出的，或者它是某个粗心入侵者留下的遗物。
- en: The *only* way to recover a compromised system is to reinstall it from scratch,
    restore the data from backup, and hope that the security hole that led to the
    compromise is fixed. That’s a thin hope, and doubt is so easy to acquire that
    many sysadmins eventually stop caring or lie to themselves rather than live with
    the constant worry.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复被入侵系统的*唯一*方法是从头重新安装系统，从备份中恢复数据，并希望导致入侵的安全漏洞已经被修复。这是一个微弱的希望，怀疑感是如此容易产生，以至于许多系统管理员最终停止在乎，或者欺骗自己，而不是忍受不断的担忧。
- en: Most intruders change files that already exist on the system. FreeBSD’s mtree(1)
    can record the permissions, size, dates, and cryptographic checksums of files
    on your system. (While freebsd-update(8) includes similar features, and you don’t
    have to gather data beforehand, it covers only the base system.) If you record
    these characteristics when your system is freshly installed, you have a record
    of what those files look like intact. When an intruder changes those files, a
    comparison will highlight the differences. When you have even the vaguest feeling
    you’ve been hacked, you can check that same information on the existing files
    to see whether any have changed.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数入侵者会修改系统上已经存在的文件。FreeBSD 的 mtree(1) 可以记录系统上文件的权限、大小、日期和加密校验和。（虽然 freebsd-update(8)
    也包含类似的功能，并且你无需提前收集数据，但它仅涵盖基础系统。）如果你在系统刚安装时记录这些特征，你就有了文件完整无损的记录。当入侵者更改这些文件时，比较将突出显示差异。当你感觉自己可能被黑客攻击时，你可以检查现有文件上的相同信息，看看是否有文件发生变化。
- en: '***Running mtree(1)***'
  id: totrans-423
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行 mtree(1)***'
- en: 'The following command runs mtree(1) across your root partition and stores SHA512
    and SHA256 cryptographic checksums, placing them in a file for later analysis:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令会在你的根分区上运行 mtree(1)，并存储 SHA512 和 SHA256 加密校验和，将它们放入一个文件中以供后续分析：
- en: '[PRE51]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: While you can use mtree(1) across the entire server, most people use `-x` ➊
    to run it once per partition. You don’t want to record checksums on frequently
    changing files, such as the database partition on your database server. Collecting
    checksums on NFS mounts has the twin features of running really slowly and increasing
    network congestion. The `-ic` flag ➋ tells mtree to print its results to the screen,
    with each subsequent layer in the filesystem indented. This format matches the
    system mtree files in */etc/mtree*. The `-K` flag accepts several optional keywords;
    in this case, we want to generate SHA512 checksums ➌ and SHA256 checksums ➍. The
    `-p` flag ➎ tells mtree which partition to check. Almost every partition has files
    or directories that change on a regular basis and that you therefore don’t want
    to record checksums for. Use `-X` ➏ to specify an *exclusion file*, a file containing
    a list of paths not to match. Finally, redirect the output of this command to
    the file */tmp/mtree.out* ➐.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在整个服务器上使用 mtree(1)，大多数人使用 `-x` ➊ 每次对每个分区运行它。你不希望在频繁更改的文件上记录校验和，例如数据库服务器上的数据库分区。在
    NFS 挂载点上收集校验和具有双重特性：非常慢并且增加网络拥塞。`-ic` 标志 ➋ 告诉 mtree 将其结果打印到屏幕上，每个后续的文件系统层级都会缩进。这个格式与系统中的
    mtree 文件（位于 */etc/mtree*）匹配。`-K` 标志接受几个可选的关键字；在这个例子中，我们希望生成 SHA512 校验和 ➌ 和 SHA256
    校验和 ➍。`-p` 标志 ➎ 告诉 mtree 要检查哪个分区。几乎每个分区都有定期更改的文件或目录，因此你不希望为这些文件记录校验和。使用 `-X` ➏
    指定一个 *排除文件*，该文件包含不匹配的路径列表。最后，将此命令的输出重定向到文件 */tmp/mtree.out* ➐。
- en: '***mtree(1) Output: The Spec File***'
  id: totrans-427
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***mtree(1) 输出：规范文件***'
- en: mtree(1)’s output is known as a specification, or *spec*. While this specification
    was originally intended for use in installing software, we’re using it to verify
    a software install. Your spec starts with comments showing the user who ran the
    command, the machine the command ran on, the filesystem analyzed, and the date.
    The first real entry in the spec sets the defaults for this host and begins with
    `/set`.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: mtree(1) 的输出被称为规范（spec），或 *规范文件*。虽然这个规范最初是为了安装软件时使用，但我们现在用它来验证软件安装。你的规范从注释开始，显示了运行该命令的用户、命令运行的机器、分析的文件系统以及日期。规范中的第一个真实条目设置了该主机的默认值，并以
    `/set` 开头。
- en: '[PRE52]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The mtree(1) program picked these settings as defaults based on its analysis
    of the files in the partition. The default filesystem object is a file, owned
    by UID 0 and GID 0, with permissions of 0755, with one hard link and the user
    archive flag. After that, every file and directory on the system has a separate
    entry. Here’s the entry for the root directory:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: mtree(1) 程序根据对分区中文件的分析选择了这些默认设置。默认的文件系统对象是一个文件，属于 UID 0 和 GID 0，权限为 0755，具有一个硬链接和用户归档标志。之后，系统上的每个文件和目录都有一个单独的条目。以下是根目录的条目：
- en: '[PRE53]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This file is the dot (`.`) ➊, or *the directory we’re in right now*. It’s a
    directory ➋, and it has 19 hard links ➌ to it. This directory was modified 1,504,101,311.033742000
    seconds into Unix epochal time ➍. The Unix epoch began January 1, 1970.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件是点（`.`） ➊，或 *我们现在所在的目录*。它是一个目录 ➋，并且它有 19 个硬链接 ➌。这个目录在 Unix 纪元时间 1,504,101,311.033742000
    秒时被修改 ➍。Unix 纪元始于 1970 年 1 月 1 日。
- en: '**EPOCHAL SECONDS AND REAL DATES**'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '**纪元秒与真实日期**'
- en: Don’t feel like counting seconds since the epoch began? To convert epochal seconds
    into normal dates, run `date -r` seconds. Cut off the fraction at the end of mtree’s
    time, however; date(1) likes only whole seconds.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 不想计算自纪元开始以来的秒数吗？要将纪元秒转换为普通日期，可以运行`date -r`秒数。不过，需要去掉mtree时间末尾的小数部分；因为date(1)只接受整数秒。
- en: 'In some ways, the entry for the directory is rather boring. An intruder can’t
    realistically replace the directory itself, after all! Here’s an entry for an
    actual file in the root directory:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 从某些方面来说，目录的条目相当无聊。毕竟，入侵者无法实际替换目录本身！以下是根目录中一个实际文件的条目：
- en: '[PRE54]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We see the filename and the same mode, link, and time information as in the
    root directory, but also get the file size ➊. Additionally, there’s the SHA256
    ➋ and SHA512 ➌ cryptographic hashes computed from the files.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到文件名和与根目录相同的模式、链接和时间信息，但还可以看到文件大小➊。此外，还有从文件计算得出的SHA256➋和SHA512➌加密哈希值。
- en: While it’s theoretically possible for an intruder to craft a file that matches
    a particular cryptographic hash, and while cryptographers are constantly trying
    to find practical ways to create files that match arbitrary SHA256 and SHA512
    checksums, it’s extremely unlikely that an intruder can create a fake file that
    matches both checksums, contains his backdoor, and still functions well enough
    that the system owner won’t immediately notice a problem. By the time this happens,
    we will have additional checksum algorithms resistant to those methods and will
    switch to them.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然理论上入侵者可以制作一个与特定加密哈希值匹配的文件，且尽管密码学家们不断尝试找到实际方法来制作匹配任意SHA256和SHA512校验和的文件，但入侵者能够制作一个匹配这两个校验和、包含其后门且仍能正常运行的伪造文件的可能性极低。如果真的发生这种情况，我们将会有其他抗此类方法的校验和算法，并会切换到这些算法。
- en: '***The Exclusion File***'
  id: totrans-439
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***排除文件***'
- en: The exclusion file (given with `-X`) lists filesystems you don’t want mtree(1)
    to analyze. Lots of filesystems will change without malicious intervention. Log
    files and user home directories should change. Directories like */tmp* and */var/db/entropy
    better* change on a functional system. List each directory you don’t want checked
    on its own line in the exclusion file, with a leading dot.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 排除文件（通过`-X`提供）列出了你不希望mtree(1)分析的文件系统。许多文件系统会在没有恶意干扰的情况下发生变化。日志文件和用户主目录应该会发生变化。像*/tmp*和*/var/db/entropy*这样的目录在功能系统中最好也会发生变化。在排除文件中每一行列出你不想检查的目录，前面加上一个点。
- en: '[PRE55]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Wait a day or so, and then run mtree(1) again to generate a new spec file. Differences
    between the two mtree files will let you improve your exclusion file. You’ll do
    the exact same thing when you suspect a system intrusion.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 等待一天左右，然后再次运行mtree(1)生成新的规格文件。两个mtree文件之间的差异将帮助你改进排除文件。当你怀疑系统被入侵时，你也可以做完全相同的操作。
- en: '***Saving the Spec File***'
  id: totrans-443
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***保存规格文件***'
- en: The spec file contains the information needed to verify the integrity of your
    system after a suspected intrusion. Leaving the spec file on the server you want
    to verify means that an intruder can edit the file and conceal his wrongdoing.
    You must not save the file on the system itself! Now and then someone will suggest
    that you checksum the mtree spec file but keep it on the server. That’s not useful;
    if someone tampers with the mtree file and the checksum, how would you know? Or
    worse—if someone tampered with the spec file and you caught it, you couldn’t tell
    what change had been made! Copy your spec file to a safe location, preferably
    on an offline media, such as a flash drive or an optical disk.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 规格文件包含了在怀疑发生入侵后验证系统完整性所需的信息。如果你将规格文件保存在你想要验证的服务器上，入侵者就可以编辑该文件并掩盖其恶行。你绝对不能将文件保存在系统本身上！时不时会有人建议你对mtree规格文件进行校验和，但将其保留在服务器上。这样没有用；如果有人篡改了mtree文件和校验和，你怎么知道呢？更糟的是——如果有人篡改了规格文件，而你发现了，你也无法知道更改了什么！请将规格文件复制到一个安全的位置，最好是离线介质，如闪存驱动器或光盘。
- en: '***Finding System Differences***'
  id: totrans-445
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查找系统差异***'
- en: When something raises your suspicions and you begin to think that you might
    have suffered an intrusion, create a new mtree spec file and compare it with the
    “known good” spec file you stored offline. Use mtree(1) to check for differences
    between spec files.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 当一些事情引起你的怀疑，并开始认为你可能遭遇入侵时，创建一个新的mtree规格文件，并与你离线存储的“已知良好”规格文件进行比较。使用mtree(1)检查规格文件之间的差异。
- en: '[PRE56]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Every entry in the file is something that has changed. My exclusion file is
    finely tuned, eliminating files I expect to have changed. This particular run
    generates two lines of output.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的每一项条目都代表一个已发生更改的内容。我的排除文件经过精细调校，去除了我预期会发生更改的文件。这次运行生成了两行输出。
- en: '[PRE57]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The file */bin/sh* ➊ has changed size ➍ between mtree runs. This isn’t good.
    Also, note the two different SHA256 hashes ➋ ➎ and the two different SHA512 hashes
    ➌ ➏. Don’t hit the panic button yet, but start asking your fellow sysadmins pointed,
    hard questions. If you can’t get a good answer as to why this binary changed,
    you might look for your installation media.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*/bin/sh* ➊的大小在mtree运行之间发生了变化➍。这不好。同时，注意到两个不同的SHA256哈希值➋ ➎和两个不同的SHA512哈希值➌
    ➏。现在不要慌张，但开始向你的同事们提出尖锐、直接的问题。如果你不能得到一个合理的答案，解释为什么这个二进制文件发生了变化，可能需要查看你的安装介质。
- en: Or, perhaps you need to update your exclusion file. But if */bin/sh* changed,
    probably not.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也许你需要更新你的排除文件。但如果*/bin/sh*发生了变化，可能就不是了。
- en: '**Monitoring System Security**'
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**监控系统安全**'
- en: So, you think your server is secure. Maybe it is . . . for now.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你认为你的服务器是安全的。也许它是……暂时是。
- en: 'Unfortunately, there’s a class of intruders with nothing better to do than
    to keep up on the latest security holes and try them out on systems they think
    might be vulnerable. Even if you read *FreeBSD-security* religiously and apply
    every single patch, you still might get hacked one day. While there’s no way to
    be absolutely sure you haven’t been hacked, the following hints will help you
    find out when something does happen:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，存在一类入侵者，他们无事可做，只能跟进最新的安全漏洞，并尝试在他们认为可能脆弱的系统上进行攻击。即使你虔诚地阅读*FreeBSD-security*并应用每一个补丁，你仍然有可能在某一天被黑客入侵。虽然没有办法绝对确认你没有被黑客入侵，但以下线索将帮助你在发生异常时发现问题：
- en: Be familiar with your servers. Run `ps -axx` on them regularly, and learn what
    processes normally run on them. If you see a process you don’t recognize, investigate.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉你的服务器。定期运行`ps -axx`，并了解它们通常运行的进程。如果看到不认识的进程，进行调查。
- en: Examine your open network ports with `netstat -na` and `sockstat`. What TCP
    and UDP ports should your server be listening on? If you don’t recognize an open
    port, investigate. Perhaps it’s innocent, but it might be an intruder’s backdoor.
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`netstat -na`和`sockstat`检查你的开放网络端口。你的服务器应该监听哪些TCP和UDP端口？如果你不认识某个开放端口，进行调查。也许它是无害的，但它也可能是入侵者的后门。
- en: Unexplained system problems are hints. Many intruders are ham-fisted klutzes
    with poor sysadmin skills, who use click-and-drool attacks. They’ll crash your
    system and think that they’re the cyber incarnation of Samuel L. Jackson.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法解释的系统问题是线索。许多入侵者都是笨手笨脚、缺乏系统管理员技能的傻瓜，他们使用点击和拖拽攻击。他们会让你的系统崩溃，并以为自己是塞缪尔·L·杰克逊的网络化身。
- en: Truly skilled intruders not only clean up after themselves but also ensure that
    the system has no problems that might alert you. Therefore, systems that are unusually
    stable are also suspicious.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真正熟练的入侵者不仅会在事后清理现场，还会确保系统没有任何可能引起你警觉的问题。因此，系统异常稳定的情况下也应当保持警惕。
- en: Unexplained reboots might indicate someone illicitly installing a new kernel.
    They might also be a sign of failing hardware or bad configuration, so investigate
    them anyway.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法解释的重启可能表明有人非法安装了新的内核。它们也可能是硬件故障或配置不当的迹象，因此无论如何都应该进行调查。
- en: FreeBSD sends you emails every day giving basic system status information. Read
    them. Save them. If something looks suspicious, investigate. Look at old messages
    to see when something has changed.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeBSD每天会通过邮件发送基本的系统状态信息。阅读它们。保存它们。如果发现任何可疑之处，进行调查。查看旧的消息，了解什么时候发生了变化。
- en: I particularly recommend the `lsof` package to increase your familiarity with
    your system. The `lsof` program lists all open files on your system. Reading lsof(8)
    output is an education in and of itself; you probably had no idea that your web
    server opened so much crud. Seeing strange files open indicates either that you’re
    not sufficiently familiar with your system or that someone’s doing something improper.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 我特别推荐使用`lsof`软件包来增加你对系统的熟悉度。`lsof`程序列出系统上所有打开的文件。阅读lsof(8)的输出本身就是一种教育；你可能从未意识到你的Web服务器会打开这么多无用的文件。看到陌生的文件被打开，意味着你可能对你的系统不够熟悉，或者某人在做不当的事情。
- en: '**Package Security**'
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**软件包安全**'
- en: The FreeBSD Project provides a database of security vulnerabilities in the ports
    and packages system. This database is made available in *Vulnerability and eXposure
    Markup Language (VuXML)*. When someone volunteers to maintain a port, they’re
    also volunteering to watch out for security problems with that port.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 项目提供了一个包含端口和软件包系统安全漏洞的数据库。这个数据库以*漏洞与曝光标记语言（VuXML）*的形式提供。当有人自愿维护一个端口时，他们也自愿关注该端口的安全问题。
- en: An internet-connected FreeBSD host with pkg(8) installed downloads the latest
    VuXML file during the periodic(8) run (see [Chapter 21](ch21.xhtml#ch21)) and
    stores it in */var/db/pkg/vuln.xml*. It then compares the installed packages with
    that database. If one of your packages has a vulnerability, you’ll be notified
    in the daily status email. (You are reading your daily status emails, right?)
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 一台连接互联网并安装了 pkg(8) 的 FreeBSD 主机会在 periodic(8) 运行时下载最新的 VuXML 文件（参见 [第 21 章](ch21.xhtml#ch21)），并将其存储在
    */var/db/pkg/vuln.xml* 中。然后，它会将已安装的软件包与该数据库进行比较。如果你的某个软件包存在漏洞，你将会在每日状态邮件中收到通知。（你有在阅读每日状态邮件吧？）
- en: If your packages are insecure, upgrade them as per [Chapter 15](ch15.xhtml#ch15).
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的软件包不安全，按照 [第 15 章](ch15.xhtml#ch15) 的方法升级它们。
- en: If need be, you can set a different location to fetch the *vuln.xml* file with
    the `VULNXML_SITE` option in *pkg.conf*. You might do this if you maintain your
    own package repository and vulnerability databases.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你可以通过在 *pkg.conf* 中使用 `VULNXML_SITE` 选项来设置一个不同的地址来获取 *vuln.xml* 文件。如果你维护自己的软件包仓库和漏洞数据库，你可能会这么做。
- en: '**If You’re Hacked**'
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如果你被黑了**'
- en: After all this, what do you do if your system is hacked? There’s no easy answer.
    Huge books are written on the subject. Here are a few general suggestions, however.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一切之后，如果你的系统被黑了，你该怎么办？没有简单的答案。关于这个主题已经写了大量书籍。不过，这里有一些常规的建议。
- en: 'First and foremost: A hacked system can’t be trusted. If someone has gained
    root access on your internet server, he could have replaced any program on the
    system. Even if you close the hole he broke in through, he could have installed
    a hacked version of login(8) that sends your username and password to an IRC channel
    somewhere every time you log in. Do not trust this system. An upgrade can’t cleanse
    it, as even freebsd-update(8) and the compiler are suspect.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 首先也是最重要的：一个被黑客入侵的系统是无法信任的。如果有人获得了你互联网服务器的 root 权限，他可能已经替换了系统上的任何程序。即使你修补了他入侵的漏洞，他也可能已经安装了一个篡改过的
    login(8) 程序，每次你登录时都会将你的用户名和密码发送到某个 IRC 频道。不要信任这个系统。升级无法清除它，因为即使是 freebsd-update(8)
    和编译器也有可能受到怀疑。
- en: 'While rootkit-hunting software might help you verify the presence of intruders,
    nothing can verify that the intruder *isn’t* there. Feel free to write *[FreeBSD-security@FreeBSD.org](mailto:FreeBSD-security@FreeBSD.org)*
    for advice. Describe what you’re seeing and why you think you’re hacked. Be prepared
    for the ugly answer, though: completely reinstall your computer from known secure
    media, and restore your data from backup. You did read [Chapter 5](ch05.xhtml#ch05),
    right?'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 rootkit 检测软件可能帮助你验证是否存在入侵者，但没有任何工具可以验证入侵者是否“已不在”系统中。你可以随时写信给 *[FreeBSD-security@FreeBSD.org](mailto:FreeBSD-security@FreeBSD.org)*
    请求建议。描述你所看到的情况以及你认为自己被黑的原因。不过，准备好面对一个不太愉快的答案：彻底从已知安全的介质重新安装你的计算机，并从备份中恢复数据。你看过
    [第 5 章](ch05.xhtml#ch05)了吗？
- en: Good security practices reduce your chances of being hacked, just as safe driving
    reduces your chances of being in a car wreck. Eventually you’ll total your wheels
    anyway and wonder why you bothered. Good luck!
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的安全实践能减少被黑客攻击的几率，就像安全驾驶能减少发生车祸的几率一样。最终你无论如何都会撞坏你的车，然后会想为什么要费这个劲。祝你好运！
