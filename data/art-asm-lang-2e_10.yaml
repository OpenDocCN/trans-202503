- en: Chapter 11. THE STRING INSTRUCTIONS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 字符串指令
- en: '![THE STRING INSTRUCTIONS](tagoreillycom20100401nostarchimages577853.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![字符串指令](tagoreillycom20100401nostarchimages577853.png.jpg)'
- en: A *string* is a collection of values stored in contiguous memory locations.
    Strings are usually arrays of bytes, words, or (on 80386 and later processors)
    double words. The 80x86 microprocessor family supports several instructions specifically
    designed to cope with strings. This chapter explores some of the uses of these
    string instructions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串*是存储在连续内存位置中的一组值。字符串通常是字节、字或（在80386及更高处理器上）双字的数组。80x86 微处理器家族支持几种专门设计用来处理字符串的指令。本章将探讨这些字符串指令的一些用途。'
- en: 'The 80x86 CPUs can process three types of strings: byte strings, word strings,
    and double-word strings. They can move strings, compare strings, search for a
    specific value within a string, initialize a string to a fixed value, and do other
    primitive operations on strings. The 80x86''s string instructions are also useful
    for manipulating arrays, tables, and records. You can easily assign or compare
    such data structures using the string instructions. Using string instructions
    may speed up your array-manipulation code considerably.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 CPU 可以处理三种类型的字符串：字节字符串、字字符串和双字字符串。它们可以移动字符串、比较字符串、在字符串中查找特定值、将字符串初始化为固定值，并执行其他字符串基础操作。80x86
    的字符串指令对于操作数组、表格和记录也非常有用。你可以使用字符串指令轻松地分配或比较这些数据结构。使用字符串指令可以显著加速数组操作代码。
- en: 11.1 The 80x86 String Instructions
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.1 80x86 字符串指令
- en: 'All members of the 80x86 family support five different string instructions:
    `movs`*`x`*, `cmps`*`x`*, `scas`*`x`*, `lods`*`x`*, and `stosx`.^([[128](#ftn.CHP-11-FN-1)])
    (*`x`* = `b`, `w`, or `d` for byte, word, or double word, respectively; this text
    will generally drop the *`x`* suffix when talking about these string instructions
    in a general sense.) They are the string primitives on which you can build most
    other string operations. How you use these five instructions is the topic of the
    sections that follow.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86系列的所有成员都支持五种不同的字符串指令：`movs`*`x`*、`cmps`*`x`*、`scas`*`x`*、`lods`*`x`* 和
    `stosx`。^([[128](#ftn.CHP-11-FN-1)])（*`x`* = `b`、`w` 或 `d`，分别表示字节、字或双字；在一般讨论这些字符串指令时，通常会省略
    *`x`* 后缀。）这些是构建其他大多数字符串操作的基础指令。如何使用这五条指令是接下来各节的主题。
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 11.1.1 How the String Instructions Operate
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1.1 字符串指令的操作方式
- en: 'The string instructions operate on blocks (contiguous linear arrays) of memory.
    For example, the `movs` instruction moves a sequence of bytes from one memory
    location to another. The `cmps` instruction compares two blocks of memory. The
    `scas` instruction scans a block of memory for a particular value. These string
    instructions often require three operands: a destination block address, a source
    block address, and (optionally) an element count. For example, when using the
    `movs` instruction to copy a string, you need a source address, a destination
    address, and a count (the number of string elements to move).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串指令作用于内存的块（连续线性数组）。例如，`movs` 指令将一串字节从一个内存位置移动到另一个位置。`cmps` 指令比较两个内存块。`scas`
    指令扫描内存块以查找特定值。这些字符串指令通常需要三个操作数：目标块地址、源块地址和（可选的）元素计数。例如，在使用 `movs` 指令复制字符串时，你需要源地址、目标地址和计数（要移动的字符串元素数量）。
- en: 'Unlike other instructions, which operate on memory, the string instructions
    don''t have any explicit operands. The operands for the string instructions are
    as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他操作内存的指令不同，字符串指令没有显式操作数。字符串指令的操作数如下：
- en: ESI (source index) register
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ESI（源索引）寄存器
- en: EDI (destination index) register
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EDI（目标索引）寄存器
- en: ECX (count) register
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECX（计数）寄存器
- en: AL/AX/EAX register
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AL/AX/EAX 寄存器
- en: The direction flag in the FLAGS register
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FLAGS 寄存器中的方向标志
- en: For example, one variant of the `movs` (move string) instruction copies ECX
    elements from the source address specified by ESI to the destination address specified
    by EDI. Likewise, the `cmps` instruction compares the string pointed at by ESI,
    of length ECX, to the string pointed at by EDI.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`movs`（移动字符串）指令的一个变体将 ECX 个元素从由 ESI 指定的源地址复制到由 EDI 指定的目标地址。同样，`cmps` 指令将
    ESI 指向的字符串（长度为 ECX）与 EDI 指向的字符串进行比较。
- en: Not all string instructions have source and destination memory operands (only
    `movs` and `cmps` support them). For example, the `scas` instruction (scan a string)
    compares the value in the accumulator (AL, AX, or EAX) to values in memory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '并不是所有的字符串指令都有源操作数和目的操作数（只有 `movs` 和 `cmps` 支持）。例如，`scas` 指令（扫描字符串）会将累加器中的值（AL、AX
    或 EAX）与内存中的值进行比较。  '
- en: 11.1.2 The rep/repe/repz and repnz/repne Prefixes
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '11.1.2 `rep`/`repe`/`repz` 和 `repnz`/`repne` 前缀  '
- en: 'The string instructions, by themselves, do not operate on strings of data.
    The `movs` instruction, for example, will only copy a single byte, word, or double
    word. When the `movs` instruction executes, it ignores the value in the ECX register.
    The repeat prefixes tell the 80x86 to do a multibyte string operation. The syntax
    for the repeat prefix is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '字符串指令本身并不会对数据字符串进行操作。例如，`movs` 指令只会复制一个字节、字或双字。当执行 `movs` 指令时，它会忽略 ECX 寄存器中的值。重复前缀告诉
    80x86 执行多字节的字符串操作。重复前缀的语法如下：  '
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You don't normally use the repeat prefixes with the `lods` instruction.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '通常情况下，你不会将重复前缀与 `lods` 指令一起使用。  '
- en: When specifying the repeat prefix before a string instruction, the string instruction
    repeats its operation ECX times.^([[129](#ftn.CHP-11-FN-2)]) Without the repeat
    prefix, the instruction operates only on a single element (byte, word, or double
    word).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '当在字符串指令前加上重复前缀时，字符串指令会重复执行 ECX 次操作。^([[129](#ftn.CHP-11-FN-2)]) 没有重复前缀时，指令仅作用于单一元素（字节、字或双字）。  '
- en: You can use repeat prefixes to process entire strings with a single instruction.
    You can use the string instructions, without the repeat prefix, as string primitive
    operations to synthesize more powerful string operations.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以使用重复前缀通过单一指令处理整个字符串。你也可以在没有重复前缀的情况下使用字符串指令作为字符串的基本操作，进而合成更强大的字符串操作。  '
- en: 11.1.3 The Direction Flag
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '11.1.3 方向标志  '
- en: In addition to the ESI, EDI, ECX, and AL/AX/EAX registers, one other register
    controls the operation of the 80x86's string instructions—the EFLAGs register.
    Specifically, the *direction flag* in the flags register controls how the CPU
    processes strings.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '除了 ESI、EDI、ECX 和 AL/AX/EAX 寄存器之外，还有一个寄存器控制 80x86 字符串指令的操作——EFLAG 寄存器。具体来说，标志寄存器中的
    *方向标志* 控制 CPU 如何处理字符串。  '
- en: If the direction flag is clear, the CPU increments ESI and EDI after operating
    on each string element. For example, executing `movs` will move the byte, word,
    or double word at ESI to EDI and will then increment ESI and EDI by 1, 2, or 4\.
    When specifying the `rep` prefix before this instruction, the CPU increments ESI
    and EDI for each element in the string (the count in ECX specifies the number
    of elements). At completion, the ESI and EDI registers will be pointing at the
    first item beyond the strings.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '如果方向标志被清除，CPU 在操作每个字符串元素后会递增 ESI 和 EDI。例如，执行 `movs` 会将 ESI 处的字节、字或双字移动到 EDI，然后将
    ESI 和 EDI 分别递增 1、2 或 4。当在此指令前加上 `rep` 前缀时，CPU 会根据 ECX 中指定的元素数量递增 ESI 和 EDI。执行完后，ESI
    和 EDI 寄存器会指向字符串之外的第一个元素。  '
- en: If the direction flag is set, the 80x86 decrements ESI and EDI after it processes
    each string element (again, ECX specifies the number of string elements). After
    a repeated string operation, the ESI and EDI registers will be pointing at the
    first byte, word, or double word before the strings if the direction flag was
    set.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '如果方向标志被设置，80x86 在处理每个字符串元素后会递减 ESI 和 EDI（同样，ECX 指定字符串元素的数量）。在重复的字符串操作后，如果方向标志被设置，ESI
    和 EDI 寄存器将指向字符串之前的第一个字节、字或双字。  '
- en: You can change the direction flag's value using the `cld` (clear direction flag)
    and `std` (set direction flag) instructions. When using these instructions inside
    a procedure, keep in mind that they modify the machine state. Therefore, you may
    need to save the direction flag during the execution of that procedure. The following
    example exhibits the kinds of problems you might encounter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `cld`（清除方向标志）和 `std`（设置方向标志）指令来更改方向标志的值。当在过程内使用这些指令时，请记住它们会修改机器状态。因此，你可能需要在执行该过程时保存方向标志。以下示例展示了你可能遇到的问题。
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code will not work properly. The calling code assumes that the direction
    flag is clear after `Str2` returns. However, this isn't true. Therefore, the string
    operations executed after the call to `Str2` will not function properly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '这段代码不会正常工作。调用代码假设 `Str2` 返回后方向标志已经清除，但实际上并非如此。因此，在调用 `Str2` 后执行的字符串操作将无法正常工作。  '
- en: There are a couple of ways to handle this problem. The first, and probably the
    most obvious, is always to insert the `cld` or `std` instructions immediately
    before executing a sequence of one or more string instructions. This ensures that
    the direction flag is always set properly for your code. The other alternative
    is to save and restore the direction flag using the `pushfd` and `popfd` instructions.
    Using these two techniques, the code above would look like the following examples.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题有几种方法。第一个，也是最明显的方法，是在执行一个或多个字符串指令的序列之前，总是插入`cld`或`std`指令。这确保了你的代码中的方向标志始终被正确设置。另一种选择是使用`pushfd`和`popfd`指令来保存和恢复方向标志。使用这两种技巧，以上代码可以变成以下示例。
- en: 'Always issuing `cld` or `std` before a string instruction:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串指令之前始终发出`cld`或`std`指令：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Saving and restoring the flags register:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 保存和恢复标志寄存器：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you use the `pushfd` and `popfd` instructions to save and restore the flags
    register, keep in mind that you're saving and restoring all the flags. This makes
    it somewhat difficult to return information in other flag bits. For example, it's
    a bit of work to return an error condition in the carry flag if you use `pushfd`
    and `popfd` to preserve the direction flag in the procedure.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`pushfd`和`popfd`指令来保存和恢复标志寄存器，请记住，你是在保存和恢复所有的标志。这会让返回其他标志位的信息变得有些困难。例如，如果你使用`pushfd`和`popfd`来保留方向标志，那么在程序中返回进位标志的错误条件就需要一些额外的工作。
- en: A third solution is to always ensure that the direction flag is clear except
    for the execution of a particular sequence that requires it to be set. For example,
    many library calls and some operating systems always assume that the direction
    flag is clear when you call them. Most standard C library functions work this
    way, for example. You can follow this convention by always assuming that the direction
    flag is clear, and then make sure you clear it immediately after a sequence that
    requires the use of `std`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种解决方案是始终确保方向标志在特定需要设置它的指令序列之外是清除的。例如，许多库函数和一些操作系统总是假设在调用它们时，方向标志是清除的。例如，大多数标准C库函数就是这样工作的。你可以遵循这一约定，始终假设方向标志已被清除，并在需要使用`std`的序列后立即确保将其清除。
- en: 11.1.4 The movs Instruction
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1.4 `movs`指令
- en: 'The `movs` instruction uses the following syntax:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`movs`指令使用以下语法：'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `movsb` (move string, bytes) instruction fetches the byte at address ESI,
    stores it at address EDI, and then increments or decrements the ESI and EDI registers
    by 1\. If the `rep` prefix is present, the CPU checks ECX to see if it contains
    0\. If not, then it moves the byte from ESI to EDI and decrements the ECX register.
    This process repeats until ECX becomes 0\. If ECX contains 0 upon initial execution,
    the `movs` instruction will not copy any data bytes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`movsb`（移动字符串，字节）指令从地址ESI取出一个字节并存储到地址EDI，然后将ESI和EDI寄存器递增或递减1。如果存在`rep`前缀，CPU会检查ECX，看看它是否为0。如果不是，CPU就会将字节从ESI移动到EDI，并将ECX寄存器递减。这个过程会重复，直到ECX变为0。如果ECX在初次执行时就为0，`movs`指令将不会复制任何数据字节。'
- en: The `movsw` (move string, words) instruction fetches the word at address ESI,
    stores it at address EDI, and then increments or decrements ESI and EDI by 2\.
    If there is a `rep` prefix, then the CPU repeats this procedure ECX times.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`movsw`（移动字符串，字）指令从地址ESI取出一个字并存储到地址EDI，然后将ESI和EDI分别递增或递减2。如果存在`rep`前缀，则CPU会重复这个过程ECX次。'
- en: The `movsd` instruction operates in a similar fashion on double words. It increments
    or decrements ESI and EDI by 4 after each data movement.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`movsd`指令在双字数据上以类似方式工作。每次数据移动后，它会将ESI和EDI递增或递减4。'
- en: 'When you use the `rep` prefix, the `movsb` instruction moves the number of
    bytes you specify in the ECX register. The following code segment copies 384 bytes
    from `CharArray1` to `CharArray2`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`rep`前缀时，`movsb`指令会移动你在ECX寄存器中指定的字节数。以下代码段将384个字节从`CharArray1`复制到`CharArray2`：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you substitute `movsw` for `movsb`, then the preceding code will move 384
    words (768 bytes) rather than 384 bytes:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`movsw`替换为`movsb`，那么前面的代码将移动384个字（768字节），而不是384个字节：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Remember, the ECX register contains the element count, not the byte count. When
    using the `movsw` instruction, the CPU moves the number of words specified in
    the ECX register. Similarly, `movsd` moves the number of double words you specify
    in the ECX register, not the number of bytes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，ECX寄存器包含的是元素计数，而不是字节计数。使用`movsw`指令时，CPU会移动ECX寄存器指定数量的字。同样，`movsd`指令移动的是ECX寄存器指定的双字数，而不是字节数。
- en: 'If you''ve set the direction flag before executing a `movsb/movsw/movsd` instruction,
    the CPU decrements the ESI and EDI registers after moving each string element.
    This means that the ESI and EDI registers must point at the last element of their
    respective strings before executing a `movsb`, `movsw`, or `movsd` instruction.
    For example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在执行 `movsb/movsw/movsd` 指令之前设置了方向标志，CPU 会在移动每个字符串元素后递减 ESI 和 EDI 寄存器。这意味着，在执行
    `movsb`、`movsw` 或 `movsd` 指令之前，ESI 和 EDI 寄存器必须指向它们各自字符串的最后一个元素。例如：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Although there are times when processing a string from tail to head is useful
    (see the `cmps` description in [11.1.5 The cmps Instruction](ch11.html#the_cmps_instruction
    "11.1.5 The cmps Instruction")), generally you''ll process strings in the forward
    direction because that''s more straightforward. There is one class of string operations
    where being able to process strings in both directions is absolutely mandatory:
    moving strings when the source and destination blocks overlap. Consider what happens
    in the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在某些情况下，从尾到头处理字符串是有用的（参见 [11.1.5 cmps 指令](ch11.html#the_cmps_instruction "11.1.5
    cmps 指令") 中的描述），但通常你会按正向方向处理字符串，因为这样更直接。有一类字符串操作，必须能够支持双向处理：当源和目标块重叠时，移动字符串。考虑以下代码中会发生什么：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This sequence of instructions treats `CharArray1` and `CharArray2` as a pair
    of 384-byte strings. However, the last 383 bytes in the `CharArray1` array overlap
    the first 383 bytes in the `CharArray2` array. Let's trace the operation of this
    code byte by byte.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这一指令序列将 `CharArray1` 和 `CharArray2` 视为一对 384 字节的字符串。然而，`CharArray1` 数组中的最后 383
    个字节与 `CharArray2` 数组中的前 383 个字节重叠。我们来逐字节跟踪这段代码的操作。
- en: When the CPU executes the `movsb` instruction, it copies the byte at ESI (`CharArray1`)
    to the byte pointed at by EDI (`CharArray2`). Then it increments ESI and EDI,
    decrements ECX by 1, and repeats this process. Now the ESI register points at
    `CharArray1+1` (which is the address of `CharArray2`), and the EDI register points
    at `CharArray2+1`. The `movsb` instruction copies the byte pointed at by ESI to
    the byte pointed at by EDI. However, this is the byte originally copied from location
    `CharArray1`. So the `movsb` instruction copies the value originally in location
    `CharArray1` to both locations `CharArray2` and `CharArray2+1`. Again, the CPU
    increments ESI and EDI, decrements ECX, and repeats this operation. Now the `movsb`
    instruction copies the byte from location `CharArray1+2` (`CharArray2+1`) to location
    `CharArray2+2`. But once again, this is the value that originally appeared in
    location `CharArray1`. Each repetition of the loop copies the next element in
    `CharArray1[0]` to the next available location in the `CharArray2` array. Pictorially,
    it looks something like [Figure 11-1](ch11.html#copying_data_between_two_overlapping_arr
    "Figure 11-1. Copying data between two overlapping arrays (forward direction)").
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当 CPU 执行 `movsb` 指令时，它会将 ESI 指向的字节（`CharArray1`）复制到 EDI 指向的字节（`CharArray2`）。然后，ESI
    和 EDI 会递增，ECX 会减少 1，并重复这个过程。此时，ESI 寄存器指向 `CharArray1+1`（即 `CharArray2` 的地址），而
    EDI 寄存器指向 `CharArray2+1`。`movsb` 指令将 ESI 指向的字节复制到 EDI 指向的字节。然而，这个字节原本是从 `CharArray1`
    位置复制过来的。因此，`movsb` 指令将原本位于 `CharArray1` 位置的值同时复制到 `CharArray2` 和 `CharArray2+1`。再次，CPU
    递增 ESI 和 EDI，递减 ECX，并重复这个操作。此时，`movsb` 指令将来自 `CharArray1+2`（即 `CharArray2+1`）的位置的字节复制到
    `CharArray2+2` 的位置。但这依然是原本出现在 `CharArray1` 位置的值。每次循环的重复都会将 `CharArray1[0]` 中的下一个元素复制到
    `CharArray2` 数组中下一个可用的位置。从图示来看，大致如下所示：[图 11-1](ch11.html#copying_data_between_two_overlapping_arr
    "图 11-1. 在两个重叠数组之间复制数据（正向方向）")。
- en: The end result is that the `movsb` instruction replicates `X` throughout the
    string. The `movsb` instruction copies the source operand into the memory location,
    which will become the source operand for the very next move operation, which causes
    the replication.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是，`movsb` 指令会在整个字符串中复制 `X`。`movsb` 指令将源操作数复制到内存位置，这个内存位置将成为下一次移动操作的源操作数，从而导致复制的发生。
- en: '![Copying data between two overlapping arrays (forward direction)](tagoreillycom20100401nostarchimages578075.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![在两个重叠数组之间复制数据（正向方向）](tagoreillycom20100401nostarchimages578075.png)'
- en: Figure 11-1. Copying data between two overlapping arrays (forward direction)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-1. 在两个重叠数组之间复制数据（正向方向）
- en: If you really want to move one array into another when they overlap like this,
    you should move each element of the source string to the destination string starting
    at the end of the two strings, as shown in [Figure 11-2](ch11.html#using_a_backward_copy_to_copy_data_in_ov
    "Figure 11-2. Using a backward copy to copy data in overlapping arrays").
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实想在两个数组重叠的情况下将一个数组移动到另一个数组中，你应该从两个字符串的末尾开始，将源字符串的每个元素移动到目标字符串中，正如[图 11-2](ch11.html#using_a_backward_copy_to_copy_data_in_ov
    "图 11-2. 使用向后复制复制重叠数组中的数据")所示。
- en: Setting the direction flag and pointing ESI and EDI at the end of the strings
    will allow you to (correctly) move one string to another when the two strings
    overlap and the source string begins at a lower address than the destination string.
    If the two strings overlap and the source string begins at a higher address than
    the destination string, then clear the direction flag and point ESI and EDI at
    the beginning of the two strings.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 设置方向标志，并将ESI和EDI指向字符串的末尾，将允许你在两个字符串重叠且源字符串位于目标字符串较低地址处时（正确地）将一个字符串移动到另一个字符串。如果两个字符串重叠，且源字符串位于目标字符串的较高地址处，那么清除方向标志并将ESI和EDI指向两个字符串的开始处。
- en: If the two strings do not overlap, then you can use either technique to move
    the strings around in memory. Generally, operating with the direction flag clear
    is the easiest, so that makes the most sense.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个字符串没有重叠，那么你可以使用任一技术将字符串移动到内存中。通常，清除方向标志进行操作是最简单的，因此最有意义。
- en: '![Using a backward copy to copy data in overlapping arrays](tagoreillycom20100401nostarchimages578077.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![使用向后复制复制重叠数组中的数据](tagoreillycom20100401nostarchimages578077.png)'
- en: Figure 11-2. Using a backward copy to copy data in overlapping arrays
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-2. 使用向后复制复制重叠数组中的数据
- en: You shouldn't use the `movs`*`x`* instruction to fill an array with a single
    byte, word, or double-word value. Another string instruction, `stos`, is much
    better for this purpose. However, for arrays whose elements are 1, 2, or 4 bytes,
    you can use the `movs` instruction to initialize the entire array to the content
    of the first element.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该使用`movs`*`x`*指令来用单一字节、字或双字值填充数组。另一个字符串指令，`stos`，在这方面要更合适。然而，对于元素为1、2或4字节的数组，你可以使用`movs`指令将整个数组初始化为第一个元素的内容。
- en: The `movs` instruction is sometimes more efficient when copying double words
    than it is copying bytes or words. On some systems, it typically takes the same
    amount of time to copy a byte using `movsb` as it does to copy a double word using
    `movsd`. Therefore, if you are moving a large number of bytes from one array to
    another, the copy operation will be faster if you can use the movsd instruction
    rather than the `movsb` instruction. If the number of bytes you wish to move is
    an even multiple of 4, this is a trivial change; just divide the number of bytes
    to copy by 4, load this value into ECX, and then use the `movsb` instruction.
    If the number of bytes is not evenly divisible by 4, then you can use the `movsd`
    instruction to copy all but the last 1, 2, or 3 bytes of the array (that is, the
    remainder after you divide the byte count by 4). For example, if you want to efficiently
    move 4,099 bytes, you can do so with the following instruction sequence.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`movs`指令在复制双字时有时比复制字节或字更高效。在某些系统中，使用`movsb`复制一个字节所需的时间通常与使用`movsd`复制一个双字所需的时间相同。因此，如果你要将大量字节从一个数组移动到另一个数组，如果你能使用`movsd`指令而不是`movsb`指令，复制操作会更快。如果你要移动的字节数是4的偶数倍，这就是一个微不足道的变化；只需将要复制的字节数除以4，将此值加载到ECX中，然后使用`movsb`指令。如果字节数不能被4整除，则可以使用`movsd`指令复制数组中除了最后1、2或3字节之外的所有字节（即，将字节计数除以4后的余数）。例如，如果你想高效地移动4,099个字节，你可以通过以下指令序列来完成。'
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using this technique to copy data never requires more than three `movs`*`x`*
    instructions because you can copy 1, 2, or 3 bytes with no more than two `movsb`
    and `movsw` instructions. The scheme above is most efficient if the two arrays
    are aligned on double-word boundaries. If not, you might want to move the `movsb`
    or `movsw` instruction (or both) before the `movsd` so that the `movsd` instruction
    works with double-word-aligned data.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此技术复制数据时，从不需要超过三个`movs`*`x`*指令，因为你可以通过不超过两个`movsb`和`movsw`指令复制1、2或3字节。如果两个数组在双字边界上对齐，上述方案效率最高。如果没有对齐，你可能需要将`movsb`或`movsw`指令（或两者）移到`movsd`之前，这样`movsd`指令就可以与双字对齐的数据一起工作。
- en: 'If you do not know the size of the block you are copying until the program
    executes, you can still use code like the following to improve the performance
    of a block move of bytes:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在程序执行之前无法知道你正在复制的块的大小，你仍然可以使用类似以下代码来提高字节块移动的性能：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On many computer systems, the `movsd` instruction provides about the fastest
    way to copy bulk data from one location to another. While there are, arguably,
    faster ways to copy the data on certain CPUs, ultimately the memory bus performance
    is the limiting factor, and the CPUs are generally much faster than the memory
    bus. Therefore, unless you have a special system, writing fancy code to improve
    memory-to-memory transfers is probably a waste of time. Also note that Intel has
    improved the performance of the `movs`*`x`* instructions on later processors so
    that `movsb` operates almost as efficiently as `movsw` and `movsd` when copying
    the same number of bytes. Therefore, when working on a later 80x86 processor,
    it may be more efficient to simply use `movsb` to copy the specified number of
    bytes rather than go through all the complexity outlined above. The bottom line
    is this: If the speed of a block move matters to you, try it several different
    ways and pick the fastest (or the simplest, if they all run the same speed, which
    is likely).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多计算机系统中，`movsd` 指令提供了一种复制大量数据从一个位置到另一个位置的最快方法。虽然在某些 CPU 上，可能有更快的方式来复制数据，但最终内存总线的性能才是限制因素，而
    CPU 通常比内存总线要快得多。因此，除非你有一个特殊的系统，否则编写复杂的代码来优化内存到内存的传输可能是浪费时间。另外请注意，英特尔在后续处理器上改善了
    `movs`*`x`* 指令的性能，使得 `movsb` 在复制相同字节数时几乎和 `movsw` 及 `movsd` 一样高效。因此，在后期的 80x86
    处理器上，直接使用 `movsb` 复制指定字节数可能比执行上述所有复杂的操作更高效。最重要的一点是：如果你对块移动的速度有要求，尝试几种不同的方式，并选择最快的方法（或者，如果它们的速度相同，选择最简单的方法，这种情况可能性很大）。
- en: 11.1.5 The cmps Instruction
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1.5 cmps 指令
- en: 'The `cmps` instruction compares two strings. The CPU compares the string referenced
    by EDI to the string pointed at by ESI. ECX contains the length of the two strings
    (when using the `repe` or `repne` prefix). Like the `movs` instruction, HLA allows
    several different forms of this instruction:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmps` 指令用于比较两个字符串。CPU 将 EDI 引用的字符串与 ESI 指向的字符串进行比较。ECX 包含两个字符串的长度（当使用 `repe`
    或 `repne` 前缀时）。与 `movs` 指令类似，HLA 允许此指令的几种不同形式：'
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As for the `movs` instruction, you specify the actual operand addresses in the
    ESI and EDI registers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `movs` 指令类似，你在 ESI 和 EDI 寄存器中指定实际的操作数地址。
- en: Without a repeat prefix, the `cmps` instruction subtracts the value at location
    EDI from the value at ESI and updates the flags. Other than updating the flags,
    the CPU doesn't use the difference produced by this subtraction. After comparing
    the two locations, `cmps` increments or decrements the ESI and EDI registers by
    1, 2, or 4 (for `cmpsb/cmpsw/cmpsd`, respectively). `cmps` increments the ESI
    and EDI registers if the direction flag is clear and decrements them otherwise.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有重复前缀，`cmps` 指令会将 EDI 位置的值与 ESI 位置的值进行相减，并更新标志位。除了更新标志位之外，CPU 不会使用这次相减得到的差值。比较两个位置后，`cmps`
    会根据需要将 ESI 和 EDI 寄存器分别加 1、2 或 4（分别对应 `cmpsb/cmpsw/cmpsd`）。如果方向标志清除，`cmps` 会增加
    ESI 和 EDI 寄存器的值，否则会减少它们。
- en: Of course, you will not tap the real power of the `cmps` instruction using it
    to compare single bytes, words, or double words in memory. This instruction shines
    when you use it to compare whole strings. With `cmps`, you can compare consecutive
    elements in a string until you find a match or until consecutive elements do not
    match.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用 `cmps` 指令来比较内存中的单个字节、字或双字时，你不会真正发挥它的强大功能。当你用它来比较整个字符串时，这条指令才会发挥真正的优势。使用
    `cmps`，你可以比较字符串中的连续元素，直到找到匹配项或直到连续元素不匹配。
- en: 'To compare two strings to see if they are equal or not equal, you must compare
    corresponding elements in a string until they don''t match. Consider the following
    strings:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较两个字符串是否相等或不相等，你必须比较字符串中的对应元素，直到它们不匹配。考虑以下字符串：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The only way to determine that these two strings are equal is to compare each
    character in the first string to the corresponding character in the second. After
    all, the second string could have been `String2`, which definitely is not equal
    to `String1`. Once you encounter a character in the destination string that does
    not equal the corresponding character in the source string, the comparison can
    stop. You needn't compare any other characters in the two strings.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 确定这两个字符串是否相等的唯一方法是将第一个字符串中的每个字符与第二个字符串中对应的字符进行比较。毕竟，第二个字符串可能是`String2`，而这显然与`String1`不相等。一旦你遇到目标字符串中的一个字符，它与源字符串中的对应字符不相等，比较就可以停止。你不需要再比较两个字符串中的其他字符。
- en: 'The `repe` prefix accomplishes this operation. It will compare successive elements
    in a string as long as they are equal and ECX is greater than 0\. We could compare
    the two strings above using the following 80x86 assembly language code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`repe`前缀完成了此操作。它将比较字符串中的连续元素，只要它们相等且ECX大于0。我们可以使用以下80x86汇编语言代码来比较上述两个字符串：'
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After the execution of the `cmpsb` instruction, you can test the flags using
    the standard (unsigned) conditional jump instructions. This lets you check for
    equality, inequality, less than, greater than, and so on.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`cmpsb`指令之后，你可以使用标准的（无符号）条件跳转指令来测试标志位。这样，你可以检查相等、不相等、小于、大于等情况。
- en: Character strings are usually compared using *lexicographical ordering*. In
    lexicographical ordering, the least significant element of a string carries the
    most weight. This is in direct contrast to standard integer comparisons, where
    the most significant portion of the number carries the most weight. Furthermore,
    the length of a string affects the comparison only if the two strings are identical
    up to the length of the shorter string. For example, `Zebra` is less than `Zebras`
    because it is the shorter of the two strings; however, `Zebra` is greater than
    `AAAAAAAAAAH!` even though `Zebra` is shorter. Lexicographical comparisons compare
    corresponding elements until encountering a character that doesn't match or until
    encountering the end of the shorter string. If a pair of corresponding characters
    do not match, then this algorithm compares the two strings based on that single
    character. If the two strings match up to the length of the shorter string, we
    must compare their length. The two strings are equal if and only if their lengths
    are equal and each corresponding pair of characters in the two strings are identical.
    Lexicographical ordering is the standard alphabetical ordering you've grown up
    with.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 字符字符串通常使用*字典顺序*进行比较。在字典顺序中，字符串的最低有效元素权重最大。这与标准整数比较直接对立，在整数比较中，数字的最高有效部分权重最大。此外，只有当两个字符串在短字符串的长度范围内完全相同时，字符串的长度才会影响比较。例如，`Zebra`小于`Zebras`，因为它是两个字符串中较短的一个；然而，尽管`Zebra`较短，它仍然大于`AAAAAAAAAAH!`。字典顺序比较会逐个比较对应的字符，直到遇到不匹配的字符或到达较短字符串的末尾。如果一对对应的字符不匹配，则此算法根据该单个字符比较两个字符串。如果两个字符串在较短字符串的长度范围内匹配，我们必须比较它们的长度。只有当两个字符串的长度相等，并且两个字符串中的每一对对应字符都相同时，两个字符串才相等。字典顺序就是你从小到大习惯的标准字母排序。
- en: 'For character strings, use the `cmps` instruction in the following manner:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符字符串，请按以下方式使用`cmps`指令：
- en: The direction flag must be cleared before comparing the strings.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在比较字符串之前，必须清除方向标志。
- en: Use the `cmpsb` instruction to compare the strings on a byte-by-byte basis.
    Even if the strings contain an even number of characters, you cannot use the `cmpsw`
    or `cmpsd` instructions. They do not compare strings in lexicographical order.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`cmpsb`指令按字节逐个比较字符串。即使字符串包含偶数个字符，也不能使用`cmpsw`或`cmpsd`指令。它们不会按照字典顺序比较字符串。
- en: You must load the ECX register with the length of the smaller string.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须将ECX寄存器加载为较短字符串的长度。
- en: Use the `repe` prefix.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`repe`前缀。
- en: The ESI and EDI registers must point at the very first character in the two
    strings you want to compare.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ESI和EDI寄存器必须指向你想要比较的两个字符串中的第一个字符。
- en: 'After the execution of the `cmps` instruction, if the two strings were equal,
    their lengths must be compared in order to finish the comparison. The following
    code compares a couple of character strings:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`cmps`指令之后，如果两个字符串相等，它们的长度必须进行比较，以完成比较。以下代码比较了一对字符字符串：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you're using bytes to hold the string lengths, you should adjust this code
    appropriately (that is, use a `movzx` instruction to load the lengths into ECX).
    HLA strings use a double word to hold the current length value, so this isn't
    an issue when using HLA strings.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用字节来存储字符串的长度，你应该适当地调整这段代码（即，使用`movzx`指令将长度加载到ECX寄存器）。HLA字符串使用双字来存储当前的长度值，因此在使用HLA字符串时并不会遇到这个问题。
- en: 'You can also use the `cmps` instruction to compare multiword integer values
    (that is, extended-precision integer values). Because of the amount of setup required
    for a string comparison, this isn''t practical for integer values less than six
    or eight double words in length, but for large integer values, it''s an excellent
    way to compare such values. Unlike for character strings, we cannot compare integer
    strings using lexicographical ordering. When comparing strings, we compare the
    characters from the least significant byte to the most significant byte. When
    comparing integers, we must compare the values from the most significant byte
    (or word/double word) down to the least significant byte, word, or double word.
    So, to compare two 32-byte (256-bit) integer values, use the following code on
    the 80x86:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`cmps`指令来比较多字整型值（即扩展精度的整型值）。由于字符串比较需要大量的准备工作，因此对于长度小于六或八个双字的整型值，使用这种方法并不实际，但对于大整型值，它是一个极好的比较方式。与字符字符串不同，我们不能使用字典序比较整数字符串。在比较字符串时，我们从最不重要的字节开始比较到最重要的字节。而在比较整数时，我们必须从最重要的字节（或字/双字）开始比较，直到最不重要的字节、字或双字。因此，要比较两个32字节（256位）的整型值，可以在80x86上使用以下代码：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code compares the integers from their most significant dword down to the
    least significant dword. The `cmpsd` instruction finishes when the two values
    are unequal or upon decrementing ECX to 0 (implying that the two values are equal).
    Once again, the flags provide the result of the comparison.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从整型值的最重要的双字开始比较，直到最不重要的双字。`cmpsd`指令在两个值不相等或ECX递减为0时结束（表示两个值相等）。再次强调，标志提供了比较的结果。
- en: The `repne` prefix will instruct the `cmps` instruction to compare successive
    string elements as long as they do not match. The 80x86 flags are of little use
    after the execution of this instruction. Either the ECX register is 0 (in which
    case the two strings are totally different), or it contains the number of elements
    compared in the two strings until a match is found. While this form of the `cmps`
    instruction isn't particularly useful for comparing strings, it is useful for
    locating the first pair of matching items in a couple of byte, word, or double-word
    arrays. In general, though, you'll rarely use the `repne` prefix with `cmps`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`repne`前缀将指示`cmps`指令比较连续的字符串元素，只要它们不匹配。执行此指令后，80x86标志几乎没有用。要么ECX寄存器为0（表示两个字符串完全不同），要么它包含在两个字符串中比较的元素数量，直到找到匹配项为止。虽然这种形式的`cmps`指令在比较字符串时不太有用，但它对于在字节、字或双字数组中定位第一对匹配项很有用。一般来说，你很少会在`cmps`中使用`repne`前缀。'
- en: 'One last thing to keep in mind with using the `cmps` instruction: The value
    in the ECX register determines the number of elements to process, not the number
    of bytes. Therefore, when using `cmpsw`, ECX specifies the number of words to
    compare. Likewise, for `cmpsd`, ECX contains the number of double words to process.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cmps`指令时需要记住的一件事是：ECX寄存器中的值决定了要处理的元素数量，而不是字节数。因此，当使用`cmpsw`时，ECX指定要比较的字数。同样，对于`cmpsd`，ECX包含要处理的双字数。
- en: 11.1.6 The scas Instruction
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1.6 `scas`指令
- en: The `cmps` instruction compares two strings against each other. You do not use
    it to search for a particular element within a string. For example, you could
    not use the `cmps` instruction to quickly scan for a 0 throughout some other string.
    You can use the `scas` (scan string) instruction for this task.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmps`指令用于比较两个字符串。你不能使用它来查找字符串中的特定元素。例如，你不能使用`cmps`指令快速扫描另一个字符串中的0。你可以使用`scas`（扫描字符串）指令来完成这个任务。'
- en: Unlike the `movs` and `cmps` instructions, the `scas` instruction requires only
    a destination string (pointed at by EDI) rather than both a source and destination
    string. The source operand is the value in the AL (scasb), AX (`scasw`), or EAX
    (`scasd`) register. The `scas` instruction compares the value in the accumulator
    (AL, AX, or EAX) against the value pointed at by EDI and then increments (or decrements)
    EDI by 1, 2, or 4\. The CPU sets the flags according to the result of the comparison.
    While this might be useful on occasion, `scas` is a lot more useful when using
    the `repe` and `repne` prefixes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与`movs`和`cmps`指令不同，`scas`指令只需要一个目标字符串（由EDI指向），而不是源字符串和目标字符串。源操作数是AL寄存器中的值（`scasb`）、AX寄存器中的值（`scasw`）或EAX寄存器中的值（`scasd`）。`scas`指令将累加器中的值（AL、AX或EAX）与EDI指向的值进行比较，然后根据比较结果将EDI增加或减少1、2或4。CPU根据比较结果设置标志。虽然这种操作偶尔会有用，但当使用`repe`和`repne`前缀时，`scas`指令要更加有用。
- en: With the `repe` prefix (repeat while equal), `scas` scans the string searching
    for an element that does not match the value in the accumulator. When using the
    `repne` prefix (repeat while not equal), `scas` scans the string, searching for
    the first string element that is equal to the value in the accumulator.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`repe`前缀（等值时重复），`scas`扫描字符串，寻找第一个不匹配累加器中值的元素。使用`repne`前缀（不等时重复），`scas`扫描字符串，寻找第一个与累加器中值匹配的字符串元素。
- en: 'You''re probably wondering, "Why do these prefixes do exactly the opposite
    of what they ought to do?" The preceding paragraphs haven''t quite phrased the
    operation of the `scas` instruction properly. When using the `repe` prefix with
    `scas`, the 80x86 scans through the string while the value in the accumulator
    is equal to the string operand. This is equivalent to searching through the string
    for the first element that does not match the value in the accumulator. The `scas`
    instruction with `repne` scans through the string while the accumulator is not
    equal to the string operand. Of course, this form searches for the first value
    in the string that matches the value in the accumulator register. The `scas` instructions
    take the following forms:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“为什么这些前缀做的完全是它们应该做的反方向？”前面的段落并没有完全正确地描述`scas`指令的操作。使用`repe`前缀与`scas`指令时，80x86会在累加器中的值等于字符串操作数时扫描字符串。这相当于在字符串中搜索第一个不匹配累加器中值的元素。使用`scas`指令与`repne`前缀时，CPU会在累加器中的值不等于字符串操作数时扫描字符串。显然，这种方式是在寻找字符串中第一个与累加器寄存器中的值匹配的值。`scas`指令有以下几种形式：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Like the `cmps` and `movs` instructions, the value in the ECX register specifies
    the number of elements, not bytes, to process when using a repeat prefix.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 像`cmps`和`movs`指令一样，ECX寄存器中的值指定了要处理的元素数，而不是字节数，特别是在使用重复前缀时。
- en: 11.1.7 The stos Instruction
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1.7 `stos`指令
- en: 'The `stos` instruction stores the value in the accumulator at the location
    specified by EDI. After storing the value, the CPU increments or decrements EDI
    depending on the state of the direction flag. Although the `stos` instruction
    has many uses, its primary use is to initialize arrays and strings to a constant
    value. For example, if you have a 256-byte array you want to clear out with zeros,
    use the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`stos`指令将累加器中的值存储到由EDI指定的位置。存储完值后，CPU根据方向标志的状态增加或减少EDI。尽管`stos`指令有许多用途，但它的主要用途是将数组和字符串初始化为常量值。例如，如果你有一个256字节的数组并且想用零清空它，可以使用以下代码：'
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code writes 64 double words rather than 256 bytes because a single `stosd`
    operation is faster than four `stosb` operations.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码写入的是64个双字，而不是256个字节，因为单次`stosd`操作比四次`stosb`操作更快。
- en: 'The `stos` instructions take six forms. They are:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`stos`指令有六种形式，它们是：'
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `stosb` instruction stores the value in the AL register into the specified
    memory location(s), the `stosw` instruction stores the AX register into the specified
    memory location(s), and the `stosd` instruction stores EAX into the specified
    location(s).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`stosb`指令将AL寄存器中的值存储到指定的内存位置，`stosw`指令将AX寄存器中的值存储到指定的内存位置，`stosd`指令将EAX寄存器中的值存储到指定的内存位置。'
- en: Keep in mind that the `stos` instruction is useful only for initializing a byte,
    word, or double-word array to a constant value. If you need to initialize an array
    with elements that have different values, you cannot use the `stos` instruction.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`stos`指令仅用于将字节、字或双字数组初始化为常量值。如果你需要初始化一个包含不同值的数组，不能使用`stos`指令。
- en: 11.1.8 The lods Instruction
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1.8 `lods`指令
- en: The `lods` instruction is unique among the string instructions. You will probably
    never use a repeat prefix with this instruction. The `lods` instruction copies
    the byte, word, or double word pointed at by ESI into the AL, AX, or EAX register,
    after which it increments or decrements the ESI register by 1, 2, or 4\. Repeating
    this instruction via the repeat prefix would serve almost no purpose whatsoever
    because the accumulator register will be overwritten each time the `lods` instruction
    repeats. At the end of the repeat operation, the accumulator will contain the
    last value read from memory.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`lods`指令在所有字符串指令中是独特的。你可能永远不会在此指令中使用重复前缀。`lods`指令将ESI指针指向的字节、字或双字复制到AL、AX或EAX寄存器中，然后将ESI寄存器递增或递减1、2或4。通过重复前缀来重复此指令几乎没有任何意义，因为每次`lods`指令重复时，累加器寄存器都会被覆盖。在重复操作结束时，累加器将包含最后一个从内存读取的值。'
- en: Instead, use the `lods` instruction to fetch bytes (`lodsb`), words (`lodsw`),
    or double words (`lodsd`) from memory for further processing. By using the `lods`
    and `stos` instructions, you can synthesize powerful string operations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 代替重复使用`rep`前缀，使用`lods`指令从内存中提取字节（`lodsb`）、字（`lodsw`）或双字（`lodsd`）进行进一步处理。通过使用`lods`和`stos`指令，你可以合成强大的字符串操作。
- en: 'Like the `stos` instruction, the `lods` instructions take six forms:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 和`stos`指令一样，`lods`指令有六种形式：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As mentioned earlier, you'll rarely, if ever, use the `rep` prefixes with these
    instructions.^([[130](#ftn.CHP-11-FN-3)]) The 80x86 increments or decrements ESI
    by 1, 2, or 4 depending on the direction flag and whether you're using the `lodsb`,
    `lodsw`, or `lodsd` instruction.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你几乎不会使用`rep`前缀与这些指令一起使用。^([[130](#ftn.CHP-11-FN-3)]) 80x86会根据方向标志以及你使用`lodsb`、`lodsw`或`lodsd`指令的不同，分别以1、2或4的步长递增或递减ESI寄存器。
- en: 11.1.9 Building Complex String Functions from lods and stos
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1.9 基于lods和stos构建复杂字符串函数
- en: 'The 80x86 supports only five different string instructions: `movs`, `cmps`,
    `scas`, `lods`, and `stos`.^([[131](#ftn.CHP-11-FN-4)]) These certainly aren''t
    the only string operations you''ll ever want to use. However, you can use the
    `lods` and `stos` instructions to easily generate any particular string operation
    you like. For example, suppose you wanted a string operation that converts all
    the uppercase characters in a string to lowercase. You could use the following
    code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86只支持五条不同的字符串指令：`movs`、`cmps`、`scas`、`lods`和`stos`。^([[131](#ftn.CHP-11-FN-4)])
    这些当然不是你永远会使用的唯一字符串操作。然而，你可以利用`lods`和`stos`指令轻松生成任何你想要的特定字符串操作。例如，假设你想要一个字符串操作，将字符串中的所有大写字母转换为小写字母。你可以使用以下代码：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Because the `lods` and `stos` instructions use the accumulator as an intermediary
    location, you can use any accumulator operation to quickly manipulate string elements.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`lods`和`stos`指令使用累加器作为中介位置，你可以利用任何累加器操作来快速操作字符串元素。
- en: '* * *'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[128](#CHP-11-FN-1)]) The 80x86 processor support two additional string instructions,
    `ins` and `outs`, which input strings of data from an input port or output strings
    of data to an output port. We will not consider these instructions because they
    are privileged instructions, and you cannot execute them in a standard 32-bit
    OS application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[128](#CHP-11-FN-1)]) 80x86处理器支持两条额外的字符串指令，`ins`和`outs`，它们分别从输入端口输入字符串数据或将字符串数据输出到输出端口。我们不会考虑这些指令，因为它们是特权指令，你不能在标准32位操作系统应用程序中执行它们。
- en: ^([[129](#CHP-11-FN-2)]) Except for the `cmps` instruction, which repeats *at
    most* the number of times specified in the ECX register.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[129](#CHP-11-FN-2)]) 除了`cmps`指令，它最多重复ECX寄存器中指定的次数。
- en: ^([[130](#CHP-11-FN-3)]) They appear here simply because they are allowed. They're
    not very useful, but they are allowed. About the only use for this form of the
    instruction is to "touch" items in the cache so they are preloaded into the cache.
    However, there are better ways to accomplish this.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[130](#CHP-11-FN-3)]) 它们之所以出现在这里，仅仅是因为它们是允许的。它们并不是很有用，但确实被允许。此类指令的唯一用途大概是“触碰”缓存中的项，以便它们被预加载到缓存中。然而，还有更好的方法可以实现这一点。
- en: ^([[131](#CHP-11-FN-4)]) Not counting `ins` and `outs`, which we're ignoring
    here.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[131](#CHP-11-FN-4)]) 不包括`ins`和`outs`，我们在这里忽略它们。
- en: 11.2 Performance of the 80x86 String Instructions
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.2 80x86字符串指令的性能
- en: In the early 80x86 processors, the string instructions provided the most efficient
    way to manipulate strings and blocks of data. However, these instructions are
    not part of Intel's RISC Core instruction set, and as such, they can be slower
    than doing the same operations using discrete instructions. Intel has optimized
    the `movs` instruction on later processors so that it operates about as rapidly
    as possible, but the other string instructions can be fairly slow. As always,
    it's a good idea to implement performance-critical algorithms using different
    algorithms (with and without the string instructions) and compare their performance
    to determine which solution to use.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的 80x86 处理器中，字符串指令提供了操作字符串和数据块的最有效方式。然而，这些指令并不是 Intel 的 RISC Core 指令集的一部分，因此，它们可能比使用离散指令执行相同操作要慢。Intel
    在后来的处理器上优化了 `movs` 指令，使其尽可能快速运行，但其他字符串指令可能会相对较慢。像往常一样，建议使用不同的算法（包括和不包括字符串指令的版本）来实现性能关键的算法，并比较它们的性能，以确定使用哪种解决方案。
- en: Keep in mind that the string instructions run at different speeds relative to
    other instructions depending on which processor you're using. Therefore, it's
    a good idea to try your experiments on the processors where you expect your code
    to run. Note that on most processors, the `movs` instruction is faster than the
    corresponding discrete instructions. Intel has worked hard to keep `movs` optimized
    because so much performance-critical code uses it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，字符串指令的执行速度相对于其他指令会根据所使用的处理器而有所不同。因此，最好在你期望代码运行的处理器上进行实验。请注意，在大多数处理器上，`movs`
    指令比对应的离散指令要快。Intel 努力优化 `movs`，因为许多对性能敏感的代码都在使用它。
- en: Although the string instructions can be slower than discrete instructions, there
    is no question that the string instructions are generally more compact than the
    discrete code that achieves the same result.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管字符串指令可能比离散指令更慢，但毫无疑问，字符串指令通常比实现相同结果的离散代码更加紧凑。
- en: 11.3 For More Information
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.3 更多信息
- en: The HLA Standard Library contains hundreds of string and pattern-matching functions
    you may find useful. All of this appears in source form at [http://www.artofasm.com/](http://www.artofasm.com/)
    or [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/); you should check
    out some of that source code if you want to see some examples of string instructions
    in action. Note also that some of the HLA Standard Library routines use discrete
    instructions to implement certain high-performance algorithms. You may want to
    look at that code as an example of such code. The 16-bit edition of this book
    (which appears on the website) discusses the implementation of several character-string
    functions using the 80x86 string instructions. Check out that edition for additional
    examples (those examples do not appear here because of the performance problems
    with the string instructions). Finally, for general information about string functions,
    check out the HLA Standard Library reference manual. It explains the operation
    of the string and pattern-matching functions found in the HLA Standard Library.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 标准库包含数百个你可能会觉得有用的字符串和模式匹配函数。所有这些都以源代码形式出现在 [http://www.artofasm.com/](http://www.artofasm.com/)
    或 [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) 上；如果你想查看一些字符串指令的实际例子，应该查阅一些源代码。还要注意，HLA
    标准库中的某些例程使用离散指令来实现某些高性能算法。你可能会想查看这些代码作为此类代码的例子。本书的 16 位版本（出现在网站上）讨论了使用 80x86 字符串指令实现多个字符字符串函数的问题。查阅该版本以获得更多示例（这些示例由于字符串指令的性能问题未出现在这里）。最后，关于字符串函数的更多一般信息，请查阅
    HLA 标准库参考手册，它解释了 HLA 标准库中字符串和模式匹配函数的操作。
