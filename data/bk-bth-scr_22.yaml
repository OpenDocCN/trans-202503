- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 20 ADVANCED FOR TECHNIQUES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20个高级`for`技巧
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: The previous three chapters have shown the power of the for command, but they’ve
    also demonstrated how tricky it can be to use and even exposed some limitations.
    In this chapter, I’ll explore some advanced topics, including techniques for working
    around some of those limitations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 过去的三章展示了`for`命令的强大功能，但也演示了它使用起来的复杂性，甚至揭示了一些限制。在本章中，我将探讨一些高级主题，包括如何绕过这些限制的技巧。
- en: 'In this chapter, I’ll explain how to perform the following tasks:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将解释如何执行以下任务：
- en: Make the interpreter honor null values between consecutive delimiter characters
    in the data interrogated by the for /F command
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让解释器在`for /F`命令查询的数据中，尊重连续分隔符字符之间的空值。
- en: Force a string to uppercase (or lowercase) with traditional Batch or by embedding
    either a PowerShell or Python command into the Batch code, a technique you can
    extend to other commands, languages, and applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用传统的Batch，或者通过将PowerShell或Python命令嵌入Batch代码中，强制将字符串转换为大写（或小写），这是一种可以扩展到其他命令、语言和应用程序的技巧。
- en: Implement two levels of delayed expansion inside the code block of a for command
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`for`命令的代码块中实现两个级别的延迟扩展
- en: Handle escaping in a for command, particularly using the double quote in the
    delims clause
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`for`命令中处理转义，尤其是使用`delims`子句中的双引号。
- en: These techniques will allow you to process more types of data and more complex
    variables. If you code bat files long enough, at least a couple of these topics
    will become relevant to you. More important, they should demonstrate a means of
    problem solving that will spark your imagination when other yet unknown problems
    arise.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技巧将使你能够处理更多类型的数据和更复杂的变量。如果你编写批处理文件的时间足够长，至少其中的几个话题对你来说会变得相关。更重要的是，它们应该展示了一种解决问题的方法，这将激发你在遇到其他未知问题时的想象力。
- en: Honoring Nulls
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尊重空值
- en: 'In [Chapter 19](chapter19.xhtml), I alluded to the fact that when using the
    delims clause to divvy a string up into individual tokens, the interpreter doesn’t
    honor nulls. Consider the contents of a file named *staff.csv* that contains five
    items in each employee’s record: first, middle, and last names followed by job
    title and government ID:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第19章](chapter19.xhtml)中，我提到过，当使用`delims`子句将字符串分割为独立标记时，解释器不会尊重空值。考虑一个名为`staff.csv`的文件，其中包含每个员工记录的五个项目：名字、中间名、姓氏，后跟职位和政府ID：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The data is well organized, but not very readable. However, the following code
    displays a rudimentary report to the console with data from the first four tokens,
    while not displaying the sensitive data at the end of the record—or at least that’s
    the intention:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数据组织得很好，但可读性不强。然而，以下代码会将来自前四个标记的数据以基础报告的形式显示到控制台，同时不显示记录末尾的敏感数据——或者至少是这样的意图：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first two records generate the following, but notice that there’s a major
    problem:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 前两条记录生成如下内容，但请注意，这里存在一个重大问题：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Colin doesn’t have a middle name as you can see in the data Colin,,Clark, but
    the for /F command just skips over the null between the two commas, skewing the
    later data and exposing Colin’s government ID. In many situations, such as when
    delimiting on any number of spaces, this behavior is exactly what you might want
    as a coder, but not here. When presented with data like this, you need a means
    of forcing Batch to honor the null.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在数据`Colin,,Clark`中看到的，Colin没有中间名，但`for /F`命令会跳过两个逗号之间的空值，导致后续数据出现偏差，并暴露了Colin的政府ID。在许多情况下，比如在按多个空格分隔时，作为程序员，你可能希望这种行为，但在这里就不行。当遇到这样的数据时，你需要一种方法来强制Batch尊重空值。
- en: 'This solution inserts a space between consecutive comma delimiters with the
    use of nested for /F commands:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案通过使用嵌套的`for /F`命令，在连续的逗号分隔符之间插入一个空格：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At the beginning of the outer for /F command ❶, I store the entire record in
    the inRec variable and then use it as text input of the inner for /F command ❷,
    but take a close look at that input: !inRec:,,=, ,!. First, I resolve inRec with
    exclamation marks because I’ve assigned it in the code block. More important,
    this syntax replaces double commas with two commas separated by a space, which
    in effect inserts a space. The inner for /F command ❷ passes four comma-delimited
    tokens into its code block, and when processing Colin’s data, that inserted space
    becomes the second token, %%b, and I write it to the console as the middle name
    ❸ with the rest of the information.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在外层for /F命令❶的开始，我将整个记录存储在inRec变量中，然后将它作为内层for /F命令❷的文本输入，但请仔细查看这个输入：!inRec:,,=,
    ,!。首先，我通过感叹号解析inRec，因为我已经在代码块中为它赋值。更重要的是，这个语法将双逗号替换为由空格分隔的两个逗号，实际上插入了一个空格。内层for
    /F命令❷将四个以逗号分隔的标记传递到它的代码块中，当处理科林的数据时，插入的空格变成了第二个标记%%b，并将其作为中间名❸与其他信息一起写入控制台。
- en: 'The report for Amy is unchanged, and Colin’s entry looks much better:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 艾米的报告没有变化，科林的条目看起来好多了：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: His middle name correctly displays as nothing, and his government ID is hidden
    from sight.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 他的中间名正确地显示为空，而他的政府身份证明被隐藏起来。
- en: While these nested commands work for this particular data, the logic is far
    from bulletproof. It doesn’t work when a null is the very first token in a record
    because such a null doesn’t present as double commas; the null first token manifests
    as just a comma leading the record, followed by the second token. It also doesn’t
    catch two consecutive nulls, or triple commas, inserting a space before the second
    comma, but not after it. Finally, these nested for commands change the null to
    a space, so it is altered. Depending on how you plan to use the data, that often
    won’t be an issue, but at times you’ll want to maintain data integrity.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些嵌套命令对于该特定数据有效，但逻辑远非万无一失。当记录中的第一个标记是空值时，它就无法正常工作，因为这样的空值不会表现为双逗号；空值作为第一个标记时，只表现为一个逗号引领记录，后面跟着第二个标记。它也无法捕捉到两个连续的空值，或是连续三个逗号，在第二个逗号前插入一个空格，但在它后面却没有插入空格。最后，这些嵌套的for命令将空值更改为空格，因此它被改变了。根据你如何使用数据，这通常不是问题，但有时你会希望保持数据的完整性。
- en: All of these stipulations might seem to disqualify this approach, but if you
    know your data, it may be perfectly acceptable. For instance, in this example
    data, if you’re confident that the middle name is the only token that might be
    missing and you’re fine writing an extra space after the tag for the middle name,
    this syntax works just fine. But there’s always room for improvement.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些规定可能看起来会使这种方法不适用，但如果你了解你的数据，它可能是完全可以接受的。例如，在这个示例数据中，如果你确信中间名是唯一可能缺失的标记，并且你可以接受在中间名标签后写入一个额外的空格，那么这个语法就完全没问题。但总是有改进的空间。
- en: 'With a few tweaks to the prior solution, the following code corrects for all
    of the limitations just discussed:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对之前解决方案做一些调整，下面的代码修正了刚才讨论的所有局限性：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The outer for /F command ❶ is the same. The inner for /F command ❷ is still
    passing four comma-delimited tokens, but its input (_!inRec:,=,_!) prepends every
    token with an underscore. This leading underscore prepends the entire record,
    which in effect prepends just the first token with an underscore. Then the replacement
    syntax changes every comma to a comma followed by an underscore, which inserts
    an underscore after every comma, effectively prepending each of the remaining
    tokens with an underscore. The null token is now an underscore (,_,), so the interpreter
    honors it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 外层for /F命令❶保持不变。内层for /F命令❷仍然传递四个以逗号分隔的标记，但它的输入(_!inRec:,=,_!)在每个标记前加上了一个下划线。这个前置的下划线实际上是对整个记录进行前置操作，只是将第一个标记前加了一个下划线。然后，替换语法将每个逗号改为一个逗号后跟下划线，这会在每个逗号后插入下划线，从而有效地使每个剩余的标记前加上下划线。空值标记现在是一个下划线(,_)，所以解释器会尊重它。
- en: While this solves one problem, it causes another; we must strip the newly minted
    leading underscore off each data item or token before using it. I don’t often
    merge multiple commands on a single line of code, but I’ve done so with four set
    commands because they’re short, simple, and redundant ❸. The first command, set
    a=%%a, assigns the token %%a to the variable a, allowing me to substring off the
    first character later in the code block, !a:~1! ❹, leaving only the data after
    the leading underscore, which is the original content. I then use the same technique
    for the other three tokens because I’m confident that every token has a leading
    underscore.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这解决了一个问题，但也引发了另一个问题；我们必须在使用数据项或令牌之前，去除每个数据项或令牌前面新添加的下划线。我不常在单行代码中合并多个命令，但在这里我使用了四个
    set 命令，因为它们简短、简单且重复❸。第一个命令，set a=%%a，将令牌 %%a 赋值给变量 a，之后我可以在代码块中通过 !a:~1! ❹ 截取第一个字符，留下只有去除前导下划线后的数据，即原始内容。接着，我对其他三个令牌使用相同的技巧，因为我确信每个令牌前都有下划线。
- en: This technique that prepends every token with a character and then strips it
    off is far more universal.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在每个令牌前添加一个字符然后去除它的技巧要更加通用。
- en: Forcing a String to Uppercase
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制将字符串转换为大写
- en: If you haven’t picked up on this yet, I love Batch coding, but there are times
    when another coding language offers a different solution, maybe even a better
    solution, from what I can devise in Batch. For instance, forcing text to uppercase
    is a trivial exercise in modern languages that have some sort of callable method,
    such as .toUpper() found in PowerShell or Python’s .upper(). Unfortunately, Batch
    doesn’t have a command, or any built-in mechanism, that converts text to uppercase,
    but I’ll show some different means of completing this task.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有意识到，我非常喜欢 Batch 编程，但有时其他编程语言能提供与我在 Batch 中构思的不同，甚至更好的解决方案。例如，强制将文本转换为大写在现代语言中是一个微不足道的操作，这些语言有某种可调用的方法，比如
    PowerShell 中的 .toUpper() 或 Python 中的 .upper()。不幸的是，Batch 并没有类似的命令或任何内建机制来将文本转换为大写，但我会展示一些不同的方法来完成这个任务。
- en: 'By now you’ve seen a few instances of where we’ve built something from scratch,
    and for this solution we’ll use the case-insensitivity endemic to Batch to create
    a routine that actually alters the case of text. The following routine accepts
    a variable name of a string as input and returns the same variable with its contents
    forced to uppercase:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经看到我们如何从头开始构建一些东西，而在这个解决方案中，我们将利用 Batch 中固有的不区分大小写的特性，创建一个实际改变文本大小写的例程。以下例程接受一个字符串变量名作为输入，并返回该变量，其中内容被强制转换为大写：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This optionless for command executes the set command to update the variable
    with delayed expansion 26 times, once for each character of the alphabet, where
    each pass resolves %%u to an uppercase character. (Maybe I should’ve broken with
    my convention and used %%U here.)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个不带选项的 for 命令执行 set 命令，以延迟扩展的方式更新变量 26 次，每次处理字母表中的一个字符，每次传递都将 %%u 解析为一个大写字符。（也许我应该打破惯例，在这里使用
    %%U。）
- en: The first pass changes A to A, which looks redundant until you remember that
    the Batch text replacement syntax is case-insensitive, meaning that this technique
    changes A and a both to A. Next, we change B to B, C to C, and so on until we
    exhaust the entire alphabet.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次传递将 A 改为 A，这看起来有些多余，直到你记得批处理文本替换语法是不区分大小写的，这意味着这个技巧同时将 A 和 a 都改为 A。接下来，我们将
    B 改为 B，C 改为 C，依此类推，直到整个字母表都被替换完。
- en: When the for loop completes, it has changed all lowercase letters to their uppercase
    counterparts without affecting the existing uppercase letters and nonalphabetical
    characters. The variable passed into this logic as the lone parameter now contains
    the uppercase text.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当 for 循环完成时，它将所有小写字母转换为大写字母，而不会影响现有的大写字母和非字母字符。传递给这个逻辑的变量作为唯一参数，现在包含的是转换为大写的文本。
- en: You can create a similar routine to force a string to lowercase by changing
    the input list of values to the set of all lowercase characters. The only other
    change might be to the label, which you might update to something like :ToLower.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个类似的例程，将字符串强制转换为小写，只需将输入的值列表更改为所有小写字符的集合。唯一可能需要更改的是标签，你可能需要将其更新为类似 :ToLower
    的名称。
- en: Embedding a PowerShell Command
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 嵌入 PowerShell 命令
- en: An alternative solution is to use that PowerShell command mentioned earlier
    as input to a Batch for /F command. Yes, you read that correctly; you can embed
    logic from another coding language into Batch code. But before seeing the PowerShell
    command as part of the for /F command, let’s see it run at the command prompt.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是将前面提到的 PowerShell 命令作为输入传递给 Batch 的 for /F 命令。没错，你没看错；你可以将其他编程语言的逻辑嵌入到
    Batch 代码中。但是在将 PowerShell 命令作为 for /F 命令的一部分之前，我们先来看一下它在命令提示符下的运行情况。
- en: If your Windows computer is loaded with PowerShell, you can execute PowerShell
    commands at the command prompt, and unless you purchased your computer before
    the first iPhone was released, it’s on there, packaged with every Windows operating
    system since XP SP2 (circa 2006).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 Windows 电脑中预装了 PowerShell，你可以在命令提示符下执行 PowerShell 命令，除非你在第一代 iPhone 发布之前购买了电脑，否则自
    XP SP2（大约 2006 年）以来，每个 Windows 操作系统都会自带 PowerShell。
- en: 'Enter this at the command prompt:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令提示符下输入此命令：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The interpreter writes the text between the single quotes to the console, with
    every alpha character capitalized.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器将单引号内的文本输出到控制台，所有字母字符都会被转为大写。
- en: At a glance, this looks like a Batch command named powershell, but there’s no
    such command. Instead, this is the program, *powershell.exe*, and the interpreter
    should find it as part of the path hierarchy (*C:\Windows\System32\WindowsPowerShell\v1.0\*
    on most computers). The argument to the program is the PowerShell command that
    converts text to uppercase, which happens to use dot notation, the antithesis
    of traditional Batch. The text being forced to uppercase is inside the single
    quotes, followed by the dot and the appropriate PowerShell method for the task
    with its parentheses escaped.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一眼看去，这看起来像是一个名为 powershell 的 Batch 命令，但并没有这样的命令。实际上，这是程序 *powershell.exe*，解释器应该能够在路径层级中找到它（大多数电脑上的路径为
    *C:\Windows\System32\WindowsPowerShell\v1.0\*）。该程序的参数是 PowerShell 命令，用于将文本转换为大写，这个命令恰好使用了点表示法，正好与传统
    Batch 命令相反。被强制转换为大写的文本位于单引号内，后面跟着点和适当的 PowerShell 方法，其括号已转义。
- en: 'You can also put this command into a bat file, and it works great if you’re
    happy seeing SET THIS TO UPPER-CASE written to stdout, but you want this text
    assigned to a variable. That’s where the for /F command comes into play:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将此命令放入 bat 文件中，它在你希望看到“SET THIS TO UPPER-CASE”写入标准输出时表现良好，但如果你希望将此文本赋值给一个变量，那么就需要使用
    for /F 命令：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As in the first solution, this routine has one parameter that functions as input
    and output—that is, the name of the variable containing the text.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一个解决方案一样，这个例程有一个参数，作为输入和输出使用——也就是包含文本的变量的名称。
- en: 'The back quotes encasing the input of the for /F command tell the interpreter
    that a command is the input, in this case an embedded PowerShell command. Notice
    that this command looks very much like the command that we earlier entered at
    the command prompt. The only difference is that !%~1! now replaces the hardcoded
    text. The %~1 parameter resolves to the input variable name; then the exclamation
    marks and delayed expansion resolve the variable to its value. The output of the
    PowerShell command is the uppercase version of this text, and the interpreter
    sends that text into the code block as the variable %%u where we finally reassign
    it to the same input parameter: %~1.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 包围在反引号中的 for /F 命令的输入告诉解释器这是一个命令输入，在本例中是嵌入的 PowerShell 命令。请注意，这个命令看起来非常像我们之前在命令提示符下输入的命令。唯一的区别是现在
    !%~1! 替代了硬编码的文本。%~1 参数解析为输入变量名；然后，感叹号和延迟扩展会将变量解析为其值。PowerShell 命令的输出是该文本的大写版本，解释器将其作为变量
    %%u 发送到代码块中，最终将其重新赋值给相同的输入参数：%~1。
- en: Embedding a Python Command
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 嵌入 Python 命令
- en: There’s no need to stop with a PowerShell command. Anything that you can enter
    at the command prompt can be valid input to a for /F command, including the invocation
    of any program, not just Batch commands. For this demonstration, I’ll invoke the
    Python runtime, but you can use the runtime for any language as long as you can
    execute it at the command prompt. You can even execute a program that you’ve written
    and compiled in another language and treat its output as input to a for /F command.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必止步于 PowerShell 命令。任何你可以在命令提示符下输入的内容，都可以作为 for /F 命令的有效输入，包括调用任何程序，而不仅仅是 Batch
    命令。在这个示例中，我将调用 Python 运行时，但只要你能够在命令提示符下执行它，你就可以使用任何语言的运行时。你甚至可以执行用其他语言编写并编译的程序，将它的输出作为
    for /F 命令的输入。
- en: 'Unlike PowerShell, your Windows computer probably didn’t come with the Python
    runtime installed, but you can download it from *[https://<wbr>www<wbr>.python<wbr>.org<wbr>/downloads<wbr>/](https://www.python.org/downloads/)*.
    This isn’t a Python book (although No Starch Press does have some great offerings),
    so I won’t delve into the syntax in detail, but with Python installed on your
    computer, the following routine is functionally equivalent to the previous two
    that share the same label:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与 PowerShell 不同，你的 Windows 计算机可能没有预装 Python 运行时，但你可以从 *[https://<wbr>www<wbr>.python<wbr>.org<wbr>/downloads<wbr>/](https://www.python.org/downloads/)*
    下载。这里不是一本关于 Python 的书（虽然 No Starch Press 的确有一些很棒的书籍），所以我不会详细探讨语法，但只要你的计算机上安装了
    Python，下面的例程在功能上等同于前两个具有相同标签的例程：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I promised not to delve, but very briefly, python is the extensionless executable,
    or runtime, and -c tells the runtime that a single Python command comes next.
    The print() function writes the output generated from what’s inside its parentheses,
    which is the resolved input variable encased in single quotes, a dot, and the
    Python method that converts a string to uppercase. The Python command is much
    easier to read when you remove the six escape characters: "print(''!%~1!''.upper())".'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我答应不深入探讨，但简而言之，python 是没有扩展名的可执行文件或运行时，-c 告诉运行时接下来是一个 Python 命令。`print()` 函数输出的是括号内内容的结果，该内容是解析后的输入变量，包含单引号、一个点和将字符串转换为大写的
    Python 方法。去掉六个转义字符后，Python 命令更容易阅读：`print('!%~1!'.upper())`。
- en: The set command in the code block once again assigns the output from the embedded
    command to its lone parameter. But also notice that I’m setting a variable to
    text containing both the usebackq keyword and the tokens clause, and then I resolve
    that text as part of the for /F command. There are two reasons for this. The first
    and most immediate is that the command wouldn’t have fit on the page otherwise
    (although it would’ve been perfectly valid). Second, this is another opportunity
    for me to remind you how we can piece together commands in an uncompiled scripting
    language.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块中的 set 命令再次将嵌入命令的输出赋值给它的唯一参数。但还要注意，我设置了一个包含 usebackq 关键字和 tokens 子句的文本变量，然后将该文本作为
    for /F 命令的一部分进行解析。这样做有两个原因。第一个也是最直接的原因是，否则命令就放不下在页面上（尽管它是完全有效的）。第二，这是另一个机会，让我提醒你，我们如何在一个未编译的脚本语言中将命令拼接在一起。
- en: The actual PowerShell and Python commands themselves are certainly simple, but
    the Batch machinations needed to use them do add some complexity. It’s usually
    not the first technique that comes to mind to solve a problem, but when you can
    really make use of a command from another language, the for /F command offers
    you an effective means of assigning its output.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的 PowerShell 和 Python 命令本身当然很简单，但使用它们所需的 Batch 机制确实增加了一些复杂性。这通常不是解决问题时首先想到的技巧，但当你能够真正利用其他语言的命令时，for
    /F 命令为你提供了一种有效的方式来分配其输出。
- en: NOTE
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*In [Chapter 19](chapter19.xhtml), for the sake of consistency, I recommended
    getting into the habit of using usebackq when a command is the input to a for
    /F command. Part of my rationale was that while neither the back quote nor the
    single quote is typically found in such commands, the single quote is the more
    likely of the two. For these last two examples, the keyword and encasing back
    quotes aren’t just good practice; they’re required because the embedded PowerShell
    and Python commands both contain single quotes.*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*在[第19章](chapter19.xhtml)中，为了保持一致性，我建议养成在命令作为 for /F 命令输入时使用 usebackq 的习惯。我推荐的部分原因是，虽然在这样的命令中通常找不到反引号或单引号，但单引号是两者中更可能出现的。对于这最后两个例子，关键字和包含反引号不仅是好的实践；它们是必须的，因为嵌入的
    PowerShell 和 Python 命令都包含单引号。*'
- en: Two Levels of Delayed Expansion
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 延迟扩展的两个层次
- en: Delayed expansion is one great feature of Batch that’s not available in most
    other languages. As you gain experience and start building a more interesting
    and complex codebase, you’ll come upon the fairly common issue of handling two
    levels of delayed expansion inside a for command’s code block.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟扩展是 Batch 的一大特点，其他大多数语言中都没有。当你积累经验并开始构建一个更有趣且复杂的代码库时，你会遇到一个相当常见的问题，即如何在 for
    命令的代码块中处理两个层次的延迟扩展。
- en: 'In [Chapter 3](chapter3.xhtml), I demonstrated delayed expansion by defining
    variables containing the culinary delights of five cities. Here are two:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](chapter3.xhtml)中，我通过定义包含五个城市美食的变量来演示了延迟扩展。这里有两个例子：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Using the same abbreviations, I also set up variables for the full name of
    each city:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的缩写，我还设置了每个城市完整名称的变量：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Ultimately, the following echo command contains two examples of delayed expansion
    that resolve these variables, assuming that city is assigned a valid city abbreviation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，以下的 echo 命令包含了两个延迟扩展的示例，这些示例解析了这些变量，前提是 city 变量被分配了有效的城市缩写：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now let’s build on this example to make a list of all 50 states in the United
    States and assign a culinary capital to each. For instance, while Jefferson City
    is the capital of Missouri, St. Louis with its frozen custard is considered by
    many its culinary capital. In the state where I grew up, Connecticut, a long-standing
    debate still brews between the thin crust pizza unique to New Haven and Middletown’s
    steamed cheeseburger. I’ve no desire to get into the middle of that rhubarb, but
    for the sake of this exercise, some authoritative body (me) has been given the
    power to define the culinary capital of each state, along with that city’s, and
    therefore that state’s, dish. Given a list of state postal abbreviation codes,
    I can define the culinary capital of each like so:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们基于这个例子，列出美国所有50个州，并为每个州指定一个烹饪之都。例如，虽然杰斐逊市是密苏里州的首府，但圣路易斯以其冷冻卡士达闻名，许多人认为它是该州的烹饪之都。在我成长的州——康涅狄格州，纽黑文独特的薄脆比萨和米德尔顿的蒸奶酪汉堡之间长期以来一直存在争论。我并不想卷入其中，但为了本练习的需要，我（某个权威机构）被赋予了定义每个州烹饪之都的权力，并且明确了每个城市，进而确定该州的代表性菜肴。给定一个州的邮政缩写代码列表，我可以这样定义每个州的烹饪之都：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For instance, the culinary capital of TN (Tennessee), culCapTN, is Nash (Nashville).
    Now we can use the two-digit state codes as input to a for command where delayed
    expansion resolves the culinary capital variable into city abbreviations. Then
    a second level of delayed expansion resolves those abbreviations into foods and
    full city names.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，TN（田纳西州）的烹饪之都 culCapTN 是 Nash（纳什维尔）。现在，我们可以使用两位数的州代码作为输入，进行 for 命令，其中延迟扩展将烹饪之都变量解析为城市缩写。然后，第二级的延迟扩展将这些缩写解析为食物和完整的城市名称。
- en: 'These state codes could be coming from data in a file, but to keep this exercise
    as simple as possible, I’m using a hardcoded list of state codes as the input
    to an optionless for command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些州的代码可能来自文件中的数据，但为了让这个练习尽可能简单，我使用了硬编码的州代码列表作为没有选项的 for 命令的输入：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The %%s variable resolves to the state code in each of the five passes. In the
    first pass of the data, !culCap%%s! resolves to !culCapTN!, which then resolves
    to Nash, which we assign to the city variable. Then the echo command, lifted verbatim
    from [Chapter 3](chapter3.xhtml), resolves the two examples of delayed expansion
    just as it did in the prior chapter, right?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '%%s 变量会在五次迭代中解决到州的代码。在数据的第一次迭代中，!culCap%%s! 会解决为 !culCapTN!，然后它会解决为 Nash（纳什维尔），并且我们将其分配给
    city 变量。然后，echo 命令从[第3章](chapter3.xhtml)中按字面意思提取，解决了两个延迟扩展的示例，就像在上一章中那样，对吧？'
- en: 'Wrong! If such a scenario had worked, I wouldn’t label it an “advanced technique.”
    While the interpreter successfully assigns a city abbreviation to city, when inside
    a code block such as this one, a variable has two different values: exclamation
    mark delimiters resolve it to the value it has taken on in the code block, and
    percent sign delimiters resolve it to its value before the block was ever executed.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 错了！如果这种情况有效，我就不会称其为“高级技巧”了。虽然解释器成功地为 city 变量分配了城市缩写，但当代码处于像这样的代码块内时，变量会有两个不同的值：感叹号定界符将其解决为代码块中已取得的值，而百分号定界符则将其解决为代码块执行之前的值。
- en: Hence, %city% resolves to nothing (or whatever it was set to in prior code),
    and then !food%city%! resolves to !food!, which in turn most likely resolves to
    nothing as well. The code doesn’t hang or throw an abort—even worse, it just displays
    an incomplete sentence.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，%city% 解决为无（或它在先前代码中设置的任何值），然后 !food%city%! 解决为 !food!，而 !food! 很可能也解决为无。代码不会挂起或抛出中止错误——更糟糕的是，它只会显示一个不完整的句子。
- en: We’re in a quandary. Since city was set inside the code block, the only way
    of resolving it to its current value involves exclamation marks, but delayed expansion
    demands that we resolve the inner variable with percent signs. (When first faced
    with this dilemma, most every coder, if not every coder, tries interchanging the
    delimiters. Try if you must, but it just doesn’t work.) In some way, shape, or
    form, you must make city resolvable via percent signs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们陷入了困境。由于 city 是在代码块内部设置的，解决它当前值的唯一方法涉及感叹号，但延迟展开要求我们用百分号来解析内部变量。（当首次遇到这个困境时，大多数程序员，如果不是所有程序员，都会尝试交换定界符。你可以试试，但它就是不行。）以某种方式，你必须通过百分号让
    city 可解析。
- en: 'One solution involves a hidden routine. This technique doesn’t assign the results
    of the first delayed expansion resolution to a variable such as city; instead,
    it passes the value to a routine:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案涉及一个隐藏的例程。这个技巧并不会将第一次延迟展开的结果赋值给像 city 这样的变量；相反，它将值传递给一个例程：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code in the routine then resolves the city as a simple parameter with the
    %~1 syntax. Since the routine is performing the resolution outside of the for
    command’s code block, the variable !food%~1! resolves nicely to !foodTN!, which
    resolves again to Hot Chicken.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例程中的代码随后使用 %~1 语法将城市解析为一个简单的参数。由于例程在 for 命令的代码块外部执行解析，变量 !food%~1! 会很好地解析为 !foodTN!，再次解析为热鸡肉。
- en: This technique isn’t without issues, however. It’s not the type of involved
    routine that would normally lend itself to being placed at the end of a bat file,
    and it definitely would not appear in its own bat file. It’s really a single command
    (plus the label and terminating goto :eof command), so it’s best kept close to
    the call command. But if I had placed the label immediately after this for command,
    the interpreter would execute the routine once for each state and then again one
    more time when the for command completes and control falls to the next command.
    To correct for this, I use a clunky conditional clause that can never be true,
    0 equ 1, in an if command that acts as the routine’s gatekeeper.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种技巧也不是没有问题的。它不是那种通常适合放在 bat 文件末尾的复杂例程，而且绝对不会单独出现在一个 bat 文件中。它其实只是一个单一的命令（加上标签和终止的
    goto :eof 命令），所以最好将其靠近 call 命令。但如果我将标签紧接在这个 for 命令后面，解释器会对每个州执行一次例程，然后在 for 命令完成并控制流转到下一个命令时，再执行一次。为了解决这个问题，我使用了一个永远不会为真的笨拙条件语句
    0 equ 1，它作为例程的门卫。
- en: This technique can easily confuse anyone reading the code, but it successfully
    conceals a hidden routine placed near a call command that is the only means of
    accessing it. It works, and I’ve used it often, but it’s not the kind of logic
    you’ll want to hang up on the fridge next to your kid’s artwork.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技巧很容易让任何阅读代码的人感到困惑，但它成功地隐藏了一个放在 call 命令附近的隐藏例程，而这是访问它的唯一方法。它有效，我经常使用它，但这不是你会想挂在冰箱上和孩子的艺术作品一起展示的那种逻辑。
- en: 'The far more elegant solution is to nest a second for command inside the first:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 更为优雅的解决方案是将第二个 for 命令嵌套在第一个命令中：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, the %%s resolves to the state code; then !culCap%%s!, which resolves
    to the corresponding city abbreviation, is the string input to the inner for command,
    where we assign it to %%c. Hence, the inner for command is nothing more than a
    means of assigning the city to a variable that we can resolve with percent signs.
    Notice that I’ve replaced what was being resolved to null in the problem statement,
    %city%, with the %%c variable. Again, taking Tennessee as the example, %%c resolves
    to Nash, and then !food%%c! becomes !foodNash!, which in turn resolves to delicious
    Hot Chicken. Similarly, !%%cFull! resolves to !NashFull!, which resolves to Nashville.
    Now, that’s some fridge-worthy code!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，%%s 解析为州代码；然后 !culCap%%s!，解析为相应的城市缩写，是传入内部 for 命令的字符串，我们将其赋值给 %%c。因此，内部的
    for 命令只不过是将 city 赋值给一个变量，我们可以通过百分号来解析它。注意，我已经将问题陈述中解析为 null 的 %city% 替换为 %%c 变量。同样，以田纳西州为例，%%c
    解析为 Nash，然后 !food%%c! 变为 !foodNash!，进一步解析为美味的热鸡肉。类似地，!%%cFull! 解析为 !NashFull!，并解析为
    Nashville。现在，这可是值得贴在冰箱上的代码！
- en: I use the /F option with the inner for command along with double quotes encasing
    the text input. Setting the tokens keyword to an asterisk ensures that %%c resolves
    to the entire text string, even if it has embedded spaces, meaning that the code
    block executes exactly once. (A much simpler optionless for command would have
    worked as the inner for command for this particular data, but the for /F command
    is a more universal solution because it handles inputs both with and without embedded
    spaces.)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`/F`选项与内部`for`命令配合，并用双引号将文本输入括起来。将tokens关键字设置为星号确保`%%c`解析为整个文本字符串，即使它包含空格，这意味着代码块只会执行一次。（一个更简单的不带选项的`for`命令对于这个特定数据也能作为内部`for`命令使用，但`for
    /F`命令是一个更通用的解决方案，因为它可以处理包含空格和不包含空格的输入。）
- en: 'Both solutions detailed in this section write the following output to the console:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中详细介绍的两种解决方案会将以下输出写入控制台：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The problem statement that I’ve provided may seem a bit contrived, but the
    need for this technique presents itself often. More realistic examples usually
    involve a far more complex situation involving files, arrays, hash tables, and
    more topics I haven’t delved into yet. For instance, to retrieve a target path
    for a robocopy command, you might read the destination city from a file and then
    look up the city in a hash table to get that path. But every one of those situations
    boils down to the same issue: you need to use delayed expansion on a variable
    previously set in a code block. Be on the lookout for similar situations.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我提供的这个问题陈述看起来可能有些牵强，但这种技术的需求常常出现。更现实的例子通常涉及更复杂的情况，涉及文件、数组、哈希表等更多我尚未深入探讨的主题。例如，若要为`robocopy`命令获取目标路径，你可能需要从文件中读取目标城市，然后在哈希表中查找该城市以获得路径。但这些情况归根结底都是同一个问题：你需要在代码块中使用延迟扩展来处理之前设置的变量。要时刻留意类似的情况。
- en: Escaping with the for Command
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`for`命令进行转义
- en: 'Escaping special characters in a for command is a challenge that can manifest
    itself in many different ways, and one such example is in the suboptions clause.
    Input data is often completely outside of our hands as coders. It would be great
    if all data files were comma- or pipe-delimited, but many times you are forced
    to use a more complex set of delimiters. The worst possible situation is text
    delimited by the double quote. If you’re trying to extract six tokens, you might
    consider this suboptions clause, but it’s invalid:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`命令中转义特殊字符是一个挑战，可能以多种不同方式表现出来，其中一个例子就是在子选项子句中。输入数据通常完全不在我们程序员的掌控之中。如果所有数据文件都是以逗号或管道符分隔的那该多好，但很多时候你不得不使用更复杂的分隔符。最糟糕的情况是文本以双引号分隔。如果你试图提取六个标记，你可能会考虑这个子选项子句，但它是无效的：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'While the interpreter sees the first double quote correctly as the start of
    the clause, the second terminates the clause, and the third is out of context.
    But this cryptic-looking clause performs the task:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然解释器正确地将第一个双引号识别为子句的开始，但第二个双引号终止了子句，第三个双引号则处于上下文之外。但这个看起来晦涩的子句完成了任务：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There’s no double quote opening the clause, and the double quote at the end
    doesn’t close the clause—it’s the sole entry in the set of delimiters. The double
    quotes encasing the clause are no more. This allows you to include the double
    quote in the delims clause, as long as you escape it with a preceding caret. But
    the lack of double quotes encasing the options clause causes other issues. Equal
    signs and even spaces are no longer protected by the encasing double quotes and
    are now also in need of escaping.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 没有双引号开启子句，且结尾的双引号并没有关闭子句——它是分隔符集中的唯一项。包围子句的双引号不再存在。这允许你在`delims`子句中包含双引号，只要你用前导插入符号进行转义。但是，缺少包围选项子句的双引号会引发其他问题。等号甚至空格不再受到包围双引号的保护，现在也需要转义。
- en: I’ve placed a caret before both equal signs. The space in between the two keyword
    clauses would terminate the larger suboptions clause, so that also needs escaping.
    That particular caret appears to trail the 6, but it really leads the space. In
    a less-than-well-documented feature of Batch, you can drop the encasing double
    quotes as long as you escape special characters and spaces.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我在两个等号前面都加了插入符号（^）。这两个关键字子句之间的空格会终止较大的子选项子句，因此这个空格也需要转义。这个插入符号看起来似乎跟在6后面，但实际上它是引导空格的。在批处理的一个不太文档化的特性中，只要你转义了特殊字符和空格，你就可以省略包围的双引号。
- en: 'Now let’s put this all together and test it. Consider the very small file,
    *UglyData.txt*, with just this one line of data with five double quotes delimiting
    the six words:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将这一切结合起来并进行测试。考虑这个非常小的文件，*UglyData.txt*，其中仅有一行数据，用五个双引号分隔六个单词：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This for /F command contains the options clause discussed earlier:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 for /F 命令包含了前面讨论过的选项子句：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here’s the output to the console:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出到控制台的内容：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In [Chapter 19](chapter19.xhtml), I mentioned that I usually use usebackq when
    reading a file. I didn’t here because the suboptions are already getting messy,
    but if you put double quotes around the input file, you would need to add usebackq^
    and a space before the tokens clause. (You’ll see something similar to this shortly.)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第19章](chapter19.xhtml) 中，我提到过我通常在读取文件时使用 usebackq。这里没有使用，因为子选项已经变得很混乱，但如果你把双引号放在输入文件周围，你需要在
    tokens 子句前添加 usebackq^ 和一个空格。（你稍后会看到类似的内容。）
- en: 'The same principle works when there are multiple delimiters. Let’s make *UglyData.txt*
    even uglier by adding caret, pipe, percent sign, and ampersand delimiters:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在多个分隔符时，相同的原理也适用。让我们通过添加插入符号、管道符、百分号和与符号分隔符，使*UglyData.txt*变得更加混乱：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now the following suboptions clause makes this work:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以下的子选项子句使得这个操作得以实现：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A caret escapes all of these special characters (even the caret delimiter) except
    for one; we can only escape the percent sign with another percent sign.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个插入符号转义所有这些特殊字符（甚至是插入符号分隔符），除了一个；我们只能通过另一个百分号来转义百分号。
- en: The need for a double quote in the set of delimiters might not come up often,
    but this technique is indispensable when it does.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在分隔符集里可能很少会出现双引号的需求，但一旦需要，这项技术就显得不可或缺。
- en: We aren’t done escaping just yet. In this next example, I’ll use the same data
    and write the same output to the console, but the source of the data will be different.
    I’ll pull the ugly data out of a file and set it to a variable, which will require
    changes to both the data and the for /F command.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完全完成转义。在接下来的示例中，我将使用相同的数据并将相同的输出写入控制台，但数据的来源会不同。我将从一个文件中提取混乱数据，并将其设置为一个变量，这将要求对数据和
    for /F 命令进行更改。
- en: 'I’ll start with the data. In [Chapter 14](chapter14.xhtml), you learned that
    when setting a variable, you must escape all special characters, but even this
    leaves you with a variable containing special characters that can’t be resolved
    later without exposing them. The solution is two levels of escaping:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从数据开始。在 [第14章](chapter14.xhtml) 中，你学到了设置变量时必须转义所有特殊字符，但即便如此，你得到的变量仍然包含无法稍后解析的特殊字符，除非将它们暴露出来。解决方法是进行两层转义：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With this set command, all of the double carets resolve to single carets. The
    interpreter discards all of the other carets because they are escaping other characters;
    the double percent signs resolve to one, resulting in four becoming two. Finally,
    the interpreter sets uglyData to the This^^is^|some%%messed^"up^&data text. The
    next time we resolve this variable, the existing escape characters will be dropped.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个 set 命令，所有的双插入符号都会被解析为单插入符号。解释器会丢弃所有其他插入符号，因为它们是在转义其他字符；双百分号会解析为一个，从而使得四个变成两个。最后，解释器将
    uglyData 设置为 This^^is^|some%%messed^"up^&data 文本。下一次我们解析这个变量时，现有的转义字符将被丢弃。
- en: 'There are changes to the for /F command as well:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对 for /F 命令也做了更改：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The command contains the more complex delims clause with the set of five delimiters,
    all of which are escaped. The %uglyData% text input to the for command resolves
    to This^is|some%messed"up&data, encased in single quotes, and the usebackq keyword
    is in place with its trailing escape character.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令包含了更复杂的 delims 子句，包含五个已转义的分隔符。输入到 for 命令中的 %uglyData% 文本会解析为 This^is|some%messed"up&data，且被单引号包围，并且
    usebackq 关键字也已就位，并带有其后缀转义字符。
- en: Since a double quote is part of the input, this for /F command must use single
    quotes around the input string, which necessitates the usebackq keyword. (It’s
    one of those blue moon situations mentioned in [Chapter 19](chapter19.xhtml).)
    Notice that Batch more easily handled the double quote when it was inside a file
    being read; parsing strings is usually more complex than parsing file data. Finally,
    we see This data is no longer messed up. written to the console.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于双引号是输入的一部分，因此此 for /F 命令必须在输入字符串周围使用单引号，这就需要使用 usebackq 关键字。（这正是 [第19章](chapter19.xhtml)
    中提到的那种罕见情况。）注意，当双引号位于正在读取的文件中时，Batch 更容易处理它；通常，解析字符串比解析文件数据要复杂。最后，我们看到 This data
    is no longer messed up. 被写入控制台。
- en: The biggest takeaway from this discussion is that you should always figure out
    how many levels of escaping to expect and make sure that the code can support
    all expected special characters in the input.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从这次讨论中，最大的收获是你应该始终弄清楚需要预期多少级别的转义，并确保代码能够支持输入中所有预期的特殊字符。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, I presented some advanced techniques that I’ve come across
    in my career as a Batch coder. It’s not an exhaustive list of interesting for
    command conundrums, but it’s representative of many. To tap into the full power
    of Batch, you must understand the for command, and that requires experimentation
    and exploration. Don’t be intimidated. If you code in Batch long enough, you’ll
    encounter something not covered here, but if you follow the thought process that
    went into these examples, you should be able to experiment your way to a solution.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我介绍了一些我在作为批处理编码员的职业生涯中遇到的高级技巧。这并不是关于`for`命令的所有有趣难题的详尽列表，但它代表了许多典型情况。要充分发挥批处理的能力，你必须理解`for`命令，而这需要实验和探索。不要害怕。如果你在批处理中编程足够长时间，你会遇到一些这里没有涉及的内容，但如果你遵循这些示例中的思考过程，你应该能够通过实验找到解决方案。
- en: This rounds out [Part II](part2.xhtml), but it’s by no means the last you’ll
    see of the for command in the pages ahead. Many more applications of this command
    are yet to come, but in the next chapter, I’ll step back and explore some important
    pseudo-environment variables.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容结束了[第二部分](part2.xhtml)，但这绝不是你在接下来的章节中最后一次见到`for`命令。这个命令的更多应用还在后面，但在下一章，我会稍微退一步，探索一些重要的伪环境变量。
