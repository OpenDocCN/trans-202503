- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">AUTHENTICATED
    ENCRYPTION</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">认证加密</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: This chapter is about a type of algorithm that protects not only a message’s
    confidentiality but also its authenticity. Recall from [Chapter 7](chapter7.xhtml)
    that message authentication codes (MACs) protect a message’s authenticity by creating
    a tag, which is a kind of signature. Like MACs, the authenticated encryption (AE)
    algorithms in this chapter produce an authentication tag, but they also encrypt
    the message. In other words, a single AE algorithm offers the features of both
    a normal cipher and a MAC.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讲解的是一种算法，它不仅保护消息的机密性，还保护其真实性。回想一下[第7章](chapter7.xhtml)，消息认证码（MAC）通过创建一个标签（类似于签名）来保护消息的真实性。像MAC一样，本章中的认证加密（AE）算法不仅生成认证标签，还会加密消息。换句话说，单一的AE算法提供了常规密码和MAC的功能。
- en: 'Combining a cipher and a MAC can achieve varying levels of authenticated encryption,
    as you’ll learn throughout this chapter. We’ll review several ways to combine
    MACs with ciphers, discuss which methods are the most secure, and explore ciphers
    that produce both a ciphertext and an authentication tag. We’ll then look at four
    important authenticated ciphers: three block cipher–based constructions, with
    a focus on the popular Advanced Encryption Standard in Galois Counter Mode (AES-GCM),
    and a cipher that uses only a permutation algorithm.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 结合密码学和消息认证码（MAC）可以实现不同级别的认证加密，正如你在本章中将学到的那样。我们将回顾几种将MAC与密码学结合的方式，讨论哪些方法是最安全的，并探索既生成密文又生成认证标签的密码算法。然后，我们将介绍四种重要的认证加密算法：三种基于分组密码的构造，重点讨论广泛使用的高级加密标准（AES-GCM）模式，以及一种仅使用置换算法的密码。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Authenticated Encryption Using MACs</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用MAC的认证加密</samp>
- en: '[Figure 8-1](chapter8.xhtml#fig8-1) shows three ways that MACs and ciphers
    can be combined to both encrypt and authenticate a plaintext: encrypt-and-MAC,
    MAC-then-encrypt, and encrypt-then-MAC.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-1](chapter8.xhtml#fig8-1)展示了三种将MAC和密码结合来同时加密和认证明文的方法：加密与MAC、MAC-再加密和加密-再MAC。'
- en: '![](../images/fig8-1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig8-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: Cipher and MAC
    combinations</samp>'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图8-1：密码与MAC的组合</samp>
- en: These combinations differ in the order in which you apply encryption and generate
    the authentication tag. The choice of a specific MAC or cipher algorithm is unimportant
    as long as each is secure in its own right and the MAC and cipher use distinct
    keys.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组合方法的区别在于应用加密和生成认证标签的顺序。选择特定的MAC或密码算法并不重要，只要每种算法本身是安全的，并且MAC和密码算法使用不同的密钥。
- en: In the encrypt-and-MAC composition, the plaintext is encrypted and an authentication
    tag is generated directly from the plaintext, such that the two operations (encryption
    and authentication) are independent of each other and you can therefore compute
    them in parallel. In the MAC-then-encrypt scheme, you generate the tag from the
    plaintext first and then encrypt the plaintext and MAC together. In the encrypt-then-MAC
    method, you encrypt the plaintext first and then generate the tag from the ciphertext.
    Let’s see which method is likely to be the most secure.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密与MAC组合中，明文被加密并且认证标签直接从明文生成，因此这两步操作（加密和认证）是独立的，你可以并行计算它们。在MAC-再加密方案中，你首先从明文生成标签，然后将明文和MAC一起加密。在加密-再MAC方法中，你首先加密明文，然后从密文中生成标签。让我们看看哪种方法可能是最安全的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Encrypt-and-MAC Approach</samp>
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">加密与MAC方法</samp>
- en: The *encrypt-and-MAC* approach computes a ciphertext and a MAC tag separately.
    Given a plaintext *P*, the sender computes a ciphertext *C* = **E**(*K*[1], *P*),
    where **E** is an encryption algorithm and *C* is the resulting ciphertext. You
    calculate the authentication tag *T* from the plaintext as *T* = **MAC**(*K*[2],
    *P*). The two operations are independent and can therefore be computed in parallel.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*加密与MAC*方法分别计算密文和MAC标签。给定明文*P*，发送方计算密文*C* = **E**(*K*[1], *P*)，其中**E**是加密算法，*C*是得到的密文。你从明文计算认证标签*T*，即*T*
    = **MAC**(*K*[2], *P*)。这两步操作是独立的，因此可以并行计算。'
- en: Once you’ve generated the ciphertext and authentication tag, the sender transmits
    both to the intended recipient. When the recipient receives *C* and *T*, they
    decrypt *C* to obtain the plaintext *P* by computing *P* = **D**(*K*[1], *C*).
    Next, they compute **MAC**(*K*[2], *P*) using the decrypted plaintext and compare
    the result to the *T* received. This verification fails if either *C* or *T* was
    corrupted, and the message is deemed invalid.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你生成了密文和认证标签，发送方将两者传输给预期的接收方。当接收方收到 *C* 和 *T* 时，他们通过计算 *P* = **D**(*K*[1],
    *C*) 解密 *C* 以获得明文 *P*。接下来，他们使用解密后的明文计算 **MAC**(*K*[2], *P*)，并将结果与接收到的 *T* 进行比较。如果
    *C* 或 *T* 被损坏，验证将失败，消息将被视为无效。
- en: In theory, encrypt-and-MAC is the least secure MAC and cipher composition because
    even a secure MAC could leak information on *P*, making *P* easier to recover.
    Because the goal of using MACs is simply to make tags unforgeable and because
    tags aren’t necessarily random looking, the authentication tag (*T*) of a plaintext
    (*P*) could still leak information even though the MAC is considered secure! (If
    the MAC is a pseudorandom function, the tag won’t leak anything on *P*.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，加密并附加 MAC 是最不安全的 MAC 和密码组合，因为即使是一个安全的 MAC 也可能泄露 *P* 的信息，使得 *P* 更容易被恢复。因为使用
    MAC 的目的是为了使标签不可伪造，并且标签不一定是随机的，明文 (*P*) 的认证标签 (*T*) 即使在 MAC 被认为是安全的情况下，也可能泄露信息！（如果
    MAC 是伪随机函数，标签就不会泄露任何关于 *P* 的信息。）
- en: Still, despite its relative weakness, many systems continue supporting encrypt-and-MAC,
    including the secure transport layer protocol SSH, wherein each encrypted packet
    *C* is followed by the tag *T* = **MAC**(*K*, *N* || *P*), where *N* is a 32-bit
    sequence number that increments for each packet. In practice, encrypt-and-MAC
    has proven good enough for use with SSH, thanks to the use of strong MAC algorithms
    like HMAC-SHA-256 that don’t leak information on *P*. Enter the following command
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管相对较弱，许多系统仍然继续支持加密并附加 MAC，包括安全传输层协议 SSH，其中每个加密数据包 *C* 后面跟随标签 *T* = **MAC**(*K*,
    *N* || *P*)，其中 *N* 是一个 32 位的序列号，每个数据包递增。在实践中，由于使用了像 HMAC-SHA-256 这样的强大 MAC 算法，它们不会泄露
    *P* 的信息，因而加密并附加 MAC 在 SSH 中被证明足够安全。输入以下命令
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: to see the list of MACs supported by the OpenSSH software.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 OpenSSH 软件支持的 MAC 列表。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">MAC-Then-Encrypt
    Composition</samp>
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">MAC-然后加密组合</samp>
- en: The *MAC-then-encrypt* composition protects a message, *P*, by first computing
    the authentication tag *T* = **MAC**(*K*[2], *P*). Next, it creates the ciphertext
    by encrypting the plaintext and tag together, according to *C* = **E**(*K*[1],
    *P* || *T*).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*MAC-然后加密* 组合通过首先计算认证标签 *T* = **MAC**(*K*[2], *P*) 来保护消息 *P*。接下来，根据 *C* = **E**(*K*[1],
    *P* || *T*)，它将明文和标签一起加密生成密文。'
- en: Once these steps are complete, the sender transmits only *C*, which contains
    both the encrypted plaintext and tag. Upon receipt, the recipient decrypts *C*
    by computing *P* || *T* = **D**(*K*[1], *C*) to obtain the plaintext and tag *T*.
    Next, the recipient verifies the received tag *T* by computing a tag directly
    from the plaintext according to **MAC**(*K*[2], *P*) to confirm that the computed
    tag is equal to the tag *T*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些步骤完成，发送方只传输 *C*，它包含了加密的明文和标签。接收方收到后，通过计算 *P* || *T* = **D**(*K*[1], *C*)
    解密 *C* 以获得明文和标签 *T*。接下来，接收方通过根据 **MAC**(*K*[2], *P*) 直接从明文计算标签来验证接收到的标签 *T*，以确认计算出的标签与标签
    *T* 相等。
- en: As with encrypt-and-MAC, when using MAC-then-encrypt, the recipient must decrypt
    *C* before determining whether they’re receiving corrupted packets—a process that
    exposes potentially corrupted plaintexts to the receiver. Nevertheless, MAC-then-encrypt
    is more secure than encrypt-and-MAC because it hides the plaintext’s authentication
    tag, thus preventing the tag from leaking information on the plaintext.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与加密并附加 MAC 类似，在使用 MAC-然后加密时，接收方必须在确定是否接收到损坏的数据包之前先解密 *C* —— 这个过程可能会让接收方看到潜在损坏的明文。尽管如此，MAC-然后加密比加密并附加
    MAC 更安全，因为它隐藏了明文的认证标签，从而防止标签泄露明文的信息。
- en: The TLS protocol has used MAC-then-encrypt for years, but TLS 1.3 replaced MAC-then-encrypt
    with authenticated ciphers (see [Chapter 13](chapter13.xhtml) for more on TLS
    1.3).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 协议已使用 MAC-然后加密多年，但 TLS 1.3 将 MAC-然后加密替换为经过认证的密码（有关 TLS 1.3 的更多信息，请参见[第13章](chapter13.xhtml)）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Encrypt-Then-MAC
    Composition</samp>
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">加密-然后 MAC 组合</samp>
- en: 'The encrypt-then-MAC composition sends two values to the recipient: the ciphertext
    produced by *C* = **E**(*K*[1], *P*) and a tag based on the ciphertext, *T* =
    **MAC**(*K*[2], *C*). The receiver computes the tag using **MAC**(*K*[2], *C*)
    and verifies that it equals the *T* received. If the values are equal, the plaintext
    is computed as *P* = **D**(*K*[1], *C*); if they are not equal, the ciphertext
    is discarded.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: encrypt-then-MAC 组合将两个值发送给接收方：由 *C* = **E**(*K*[1], *P*) 产生的密文和基于密文的标签 *T* =
    **MAC**(*K*[2], *C*)。接收方使用 **MAC**(*K*[2], *C*) 计算标签，并验证它是否等于接收到的 *T*。如果值相等，则计算明文为
    *P* = **D**(*K*[1], *C*)；如果不相等，则丢弃密文。
- en: One advantage of this method is that the receiver needs to compute a MAC only
    to detect corrupt messages, meaning that there’s no need to decrypt a corrupt
    ciphertext. Also, attackers can’t send pairs of *C* and *T* to the receiver to
    decrypt unless they’ve broken the MAC, which makes it harder for attackers to
    transmit malicious data to the recipient.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个优点是接收方只需要计算 MAC 来检测消息是否损坏，这意味着不需要解密损坏的密文。此外，攻击者不能发送 *C* 和 *T* 的对给接收方解密，除非他们已经破解了
    MAC，这使得攻击者更难将恶意数据传输给接收方。
- en: This combination of features makes encrypt-then-MAC stronger than the encrypt-and-MAC
    and MAC-then-encrypt approaches. This is one reason why the widely used IPsec
    secure communications protocol suite uses it to protect packets (for example,
    within VPN tunnels).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特性组合使得 encrypt-then-MAC 比 encrypt-and-MAC 和 MAC-then-encrypt 方法更强大。这也是广泛使用的
    IPsec 安全通信协议套件采用这种方法来保护数据包（例如，在 VPN 隧道内）的原因之一。
- en: Note that SSH and TLS don’t use encrypt-then-MAC because other approaches appeared
    adequate when SSH and TLS were created—not because theoretical weaknesses didn’t
    exist but because undesirable properties don’t necessarily become actual vulnerabilities.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，SSH 和 TLS 并没有使用 encrypt-then-MAC，因为在创建 SSH 和 TLS 时，其他方法已经足够有效——这并不是因为理论上的弱点不存在，而是因为不良特性不一定会变成实际的漏洞。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Authenticated Ciphers</samp>
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">认证密码算法</samp>
- en: '*Authenticated ciphers* are an alternative to the cipher and MAC combinations.
    They’re like normal ciphers except that they return an authentication tag together
    with the ciphertext.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*认证密码算法* 是密码和 MAC 组合的替代方案。它们像普通的密码算法，只不过它们会在返回密文的同时还返回一个认证标签。'
- en: You represent the authenticated cipher encryption as **AE**(*K*, *P*) = (*C*,
    *T*). The term **AE** stands for *authenticated encryption*, which is based on
    a key (*K*) and a plaintext (*P*) and returns a ciphertext (*C*) and a generated
    authentication tag (*T*). In other words, a single authenticated cipher algorithm
    does the same job as a cipher and MAC combination, making it simpler, faster,
    and often more secure.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将认证密码加密表示为 **AE**(*K*, *P*) = (*C*, *T*)。术语 **AE** 代表 *认证加密*，它基于密钥 (*K*)
    和明文 (*P*)，返回密文 (*C*) 和生成的认证标签 (*T*)。换句话说，单一的认证密码算法完成了密码和 MAC 组合的工作，使得它更简洁、更快速，并且通常更安全。
- en: You represent authenticated cipher decryption by **AD**(*K*, *C*, *T*) = *P*.
    Here, **AD** stands for *authenticated decryption*, which returns a plaintext
    (*P*) given a ciphertext (*C*), tag (*T*), and key (*K*). If the tag validation
    fails, **AD** returns an error to prevent the recipient from processing a plaintext
    that may have been forged. By the same token, if **AD** returns a plaintext, it’s
    been encrypted by someone or something that knows the secret key.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将认证密码解密表示为 **AD**(*K*, *C*, *T*) = *P*。这里，**AD** 代表 *认证解密*，它根据密文 (*C*)、标签
    (*T*) 和密钥 (*K*) 返回明文 (*P*)。如果标签验证失败，**AD** 会返回错误，防止接收方处理可能被伪造的明文。同样，如果 **AD**
    返回明文，说明它是由知道秘密密钥的某人或某物加密的。
- en: 'The basic security requirements of an authenticated cipher are simple: its
    authentication should be as strong as a MAC’s, meaning it should be impossible
    to forge a ciphertext and tag pair (*C*, *T*) that the decryption function **AD**
    will accept and decrypt.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 认证密码的基本安全要求很简单：其认证强度应该与 MAC 的强度一样，这意味着应该不可能伪造一个密文和标签对 (*C*, *T*)，使得解密函数 **AD**
    接受并解密它。
- en: As far as confidentiality is concerned, an authenticated cipher is fundamentally
    stronger than a basic cipher because systems holding the secret key will decrypt
    a ciphertext only if the authentication tag is valid. If the tag is invalid, the
    plaintext is discarded. This characteristic prevents attackers from performing
    chosen-ciphertext queries, an attack where they create ciphertexts and ask for
    the corresponding plaintext.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就保密性而言，一个认证密码比一个基础密码从根本上更强大，因为持有秘密密钥的系统只有在认证标签有效时才会解密密文。如果标签无效，明文会被丢弃。这一特性防止了攻击者进行选择密文查询攻击，即他们创建密文并请求相应的明文。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authenticated Encryption
    with Associated Data</samp>
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">带关联数据的认证加密</samp>
- en: Cryptographers define *associated data* as any data processed by an authenticated
    cipher such that the data is authenticated (thanks to the authentication tag)
    but not encrypted. By default, all plaintext data fed to an authenticated cipher
    is encrypted *and* authenticated.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学家将*关联数据*定义为通过认证密码处理的任何数据，使得这些数据经过认证（通过认证标签）但不被加密。默认情况下，所有输入到认证密码的数据都是被加密*和*认证的。
- en: Say you want to authenticate a message, including its unencrypted parts, but
    not encrypt the entire message—that is, you want to authenticate and transmit
    data in addition to an encrypted message. For example, if a cipher processes a
    network packet composed of a header followed by a payload, you might choose to
    encrypt the payload to hide the actual data transmitted, but not encrypt the header
    since it contains information required to deliver the packet to its final recipient.
    At the same time, you might still like to authenticate the header’s data to make
    sure that it’s received from the expected sender.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要验证一条消息，包括它的未加密部分，但不加密整个消息——也就是说，你想验证和传输数据，除了加密的消息之外。例如，如果一个密码算法处理一个由头部和有效负载组成的网络数据包，你可能会选择加密有效负载来隐藏实际传输的数据，但不加密头部，因为头部包含将数据包传递给最终接收者所需的信息。与此同时，你可能仍然希望验证头部数据，以确保它是从预期的发送者收到的。
- en: To accomplish these goals, cryptographers created the notion of *authenticated
    encryption with associated data (AEAD)*. An AEAD algorithm allows you to attach
    cleartext data to a ciphertext in such a way that if the cleartext data is corrupted,
    the authentication tag won’t validate, and the ciphertext won’t decrypt. Such
    cleartext data must be encoded and serialized in a secure way to prevent ambiguous
    interpretation of its content.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些目标，密码学家创造了*带关联数据的认证加密（AEAD）*的概念。AEAD算法允许你将明文数据附加到密文中，以一种方式使得如果明文数据被篡改，认证标签将无法通过验证，密文也无法解密。这些明文数据必须以安全的方式进行编码和序列化，以防止对其内容的歧义解释。
- en: You can write an AEAD operation as **AEAD**(*K*, *P*, *A*) = (*C*, *A*, *T*).
    Given a key (*K*), plaintext (*P*), and associated data (*A*), AEAD returns the
    ciphertext, the unencrypted associated data *A*, and an authentication tag. AEAD
    leaves the unencrypted associated data unchanged, and the ciphertext is the encryption
    of plaintext. The authentication tag depends on both *P* and *A* and will be verified
    as valid only if neither *C* nor *A* has been modified.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将AEAD操作写成**AEAD**(*K*, *P*, *A*) = (*C*, *A*, *T*)。给定一个密钥(*K*)、明文(*P*)和关联数据(*A*)，AEAD返回密文、未加密的关联数据*A*和认证标签。AEAD保持未加密的关联数据不变，密文是明文的加密。认证标签依赖于*P*和*A*，并且只有当*C*和*A*都没有被修改时，认证标签才会被验证为有效。
- en: Because the authenticated tag depends on *A*, you compute decryption with associated
    data by **ADAD**(*K*, *C*, *A*, *T*) = (*P*, *A*). Decryption requires the key,
    ciphertext, associated data, and tag in order to compute the plaintext and associated
    data, and it fails if either *C* or *A* has been corrupted.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于认证标签依赖于*A*，你可以通过**ADAD**(*K*, *C*, *A*, *T*) = (*P*, *A*)来计算带关联数据的解密。解密需要密钥、密文、关联数据和标签，以便计算明文和关联数据，如果*C*或*A*被破坏，解密将失败。
- en: When using AEAD, you can leave *A* or *P* empty. If the associated data *A*
    is empty, AEAD becomes a normal authenticated cipher; if *P* is empty, it’s just
    a MAC.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AEAD时，你可以将*A*或*P*留空。如果关联数据*A*为空，AEAD就变成了一个普通的认证密码；如果*P*为空，那它就只是一个MAC。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*As of this writing, AEAD is the current norm for authenticated encryption.
    Because nearly all authenticated ciphers in use today support associated data,
    when referring to authenticated ciphers throughout this book, I’m referring to
    AEAD unless stated otherwise. When discussing AEAD operations of encryption and
    decryption, I’ll refer to them as* ***AE*** *and* ***AD****, respectively.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*截至本文写作时，AEAD是当前认证加密的标准。由于几乎所有当前使用的认证密码都支持关联数据，在本书中提到的认证密码，除非特别说明，都是指AEAD。当讨论AEAD的加密和解密操作时，我将分别称之为*
    ***AE*** *和* ***AD***。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Predictability and
    Nonces</samp>
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">可预测性和随机数</samp>
- en: 'Recall from [Chapter 1](chapter1.xhtml) that to be secure, encryption schemes
    must be unpredictable and return different ciphertexts when called repeatedly
    to encrypt the same plaintext—otherwise, an attacker can determine whether the
    same plaintext was encrypted twice. To be unpredictable, block ciphers and stream
    ciphers feed the cipher an extra parameter: the initial value (IV) or *nonce*—a
    number that can be used only once. Authenticated ciphers use the same trick. Thus,
    you express authenticated encryption as **AE**(*K*, *P*, *A*, *N*), where *N*
    is a nonce. It’s up to the encryption operation to pick a nonce that has never
    been used before with the same key.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第1章](chapter1.xhtml)中提到的，为了保证安全，加密方案必须是不可预测的，并且在重复加密相同明文时返回不同的密文——否则，攻击者就能确定是否加密了相同的明文。为了不可预测性，分组密码和流密码会给密码算法提供一个额外的参数：初始值（IV）或*随机数*——这是一个只能使用一次的数字。认证密码也使用了同样的技巧。因此，你可以将认证加密表示为**AE**(*K*,
    *P*, *A*, *N*)，其中*N*是随机数。加密操作需要选择一个从未与相同密钥一起使用过的随机数。
- en: As with block and stream ciphers, decryption with an authenticated cipher requires
    the nonce used for encryption to perform correctly. You can thus express decryption
    as **AD**(*K*, *C*, *A*, *T*, *N*) = (*P*, *A*), where *N* is the nonce used to
    create *C* and *T*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与分组密码和流密码一样，使用认证密码进行解密时需要使用加密时所用的随机数，以确保解密操作正确。因此，你可以将解密表示为**AD**(*K*, *C*,
    *A*, *T*, *N*) = (*P*, *A*)，其中*N*是用于生成*C*和*T*的随机数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Criteria for a Good
    Authenticated Cipher</samp>
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">良好认证密码的标准</samp>
- en: 'Researchers have been struggling since the early 2000s to define what makes
    a good authenticated cipher, and the answer is still elusive. Because of AEAD’s
    many inputs that play different roles, it’s harder to define a notion of security
    than it is for basic ciphers that only encrypt a message. For example, the research
    article “Nonces Are Noticed: AEAD Revisited,” available at *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2019<wbr>/624](https://eprint.iacr.org/2019/624)*,
    proposed a theoretical framework for nonce-based encryption. Nevertheless, in
    this section, I’ll summarize the most important criteria to consider when evaluating
    the security, performance, and functionality of an authenticated cipher.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 自2000年代初以来，研究人员一直在努力定义什么才是一个好的认证密码，但答案仍然难以捉摸。由于AEAD有许多不同角色的输入，其安全性比仅加密消息的基本密码更难定义。例如，研究文章《随机数被注意到：AEAD再探》，可在*[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2019<wbr>/624](https://eprint.iacr.org/2019/624)*查看，提出了一个基于随机数加密的理论框架。尽管如此，在本节中，我将总结评估认证密码的安全性、性能和功能时需要考虑的最重要标准。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security</samp>
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">安全性</samp>
- en: 'The most important criteria to measure the strength of an authenticated cipher
    are its ability to protect the confidentiality of data (that is, the secrecy of
    the plaintext) and the authenticity and integrity of the communication (as with
    the MAC’s ability to detect corrupted messages). An authenticated cipher must
    compete in both leagues: its confidentiality must be as strong as that of the
    strongest cipher, and its authenticity as strong as that of the best MAC. In other
    words, if you remove the authentication part in an AEAD, you should get a secure
    cipher, and if you remove the encryption part, you should get a strong MAC.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 衡量认证密码强度的最重要标准是其保护数据机密性的能力（即明文的保密性），以及通信的真实性和完整性（例如，MAC检测损坏消息的能力）。认证密码必须在这两个领域都具备竞争力：其机密性必须与最强密码相当，而其真实性必须与最好的MAC相当。换句话说，如果你去掉AEAD中的认证部分，你应该得到一个安全的密码，而如果去掉加密部分，你应该得到一个强大的MAC。
- en: Another measure of the strength of an authenticated cipher’s security is based
    on its fragility when faced with repeated nonces. For example, if a nonce is reused,
    can an attacker decrypt ciphertexts or learn the difference between plaintexts?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 认证密码强度的另一个衡量标准是它在面对重复的随机数时的脆弱性。例如，如果随机数被重复使用，攻击者是否能够解密密文或识别明文之间的差异？
- en: Researchers call this notion of robustness *misuse resistance* and have designed
    misuse-resistant authenticated ciphers to weigh the impact of a repeated nonce
    and attempt to determine whether confidentiality, authenticity, or both would
    be compromised in the face of such an attack, as well as what information about
    the encrypted data would likely leak.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员称这种强度的概念为*滥用抗性*，并设计了滥用抗性的认证密码，来评估重复使用随机数的影响，并尝试确定在这种攻击面前，机密性、真实性或两者是否会受到破坏，以及加密数据可能泄露哪些信息。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Performance</samp>
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">性能</samp>
- en: As with every cryptographic algorithm, you measure the throughput of an authenticated
    cipher in bits processed per second. This speed depends on the number of operations
    performed by the cipher’s algorithm and on the extra cost of the authentication
    functionality. The extra security features of authenticated ciphers come with
    a performance hit. However, the measure of a cipher’s performance isn’t just about
    pure speed. It’s also about parallelizability, structure, and whether the cipher
    is streamable. Let’s examine these notions more closely.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 和每种加密算法一样，认证密码的吞吐量是通过每秒处理的比特数来衡量的。这一速度取决于密码算法执行的操作数量以及认证功能的额外开销。认证密码的额外安全特性会带来性能损失。然而，密码性能的衡量标准不仅仅是纯粹的速度，还包括并行性、结构以及密码是否支持流式处理。我们来更深入地了解这些概念。
- en: A cipher’s *parallelizability* is a measure of its ability to process multiple
    data blocks simultaneously without waiting for the previous block’s processing
    to complete. Block cipher–based designs can be easily parallelizable when each
    block can be processed independently of the other blocks. For example, the CTR
    block cipher mode from [Chapter 4](chapter4.xhtml) is parallelizable, whereas
    the CBC encryption mode is not, because blocks are chained.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 密码的*并行性*是衡量其在不等待前一个数据块处理完成的情况下同时处理多个数据块的能力。基于块密码的设计可以轻松实现并行化，当每个数据块可以独立于其他数据块进行处理时。例如，[第4章](chapter4.xhtml)中的CTR块密码模式是可并行的，而CBC加密模式则不可并行，因为块是相互链式的。
- en: 'The internal structure of an authenticated cipher is another important performance
    criteria. There are two main types of structure: one-layer and two-layer. In a
    two-layer structure (for example, in the widely used AES-GCM), one algorithm processes
    the plaintext, and then a second algorithm processes the result. Typically, the
    first layer is the encryption layer, and the second is the authentication layer.
    But as you might expect, a two-layer structure complicates implementation and
    tends to slow down computations.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 认证密码的内部结构是另一个重要的性能标准。主要有两种结构类型：单层和双层。在双层结构中（例如广泛使用的AES-GCM），一个算法处理明文，然后第二个算法处理结果。通常，第一个层是加密层，第二个层是认证层。但正如你可能预料到的那样，双层结构使得实现更加复杂，并且通常会导致计算速度变慢。
- en: 'An authenticated cipher is *streamable* (also called an *online* cipher) when
    it can process a message block by block and discard any already-processed blocks.
    In contrast, nonstreamable ciphers must store the entire message, typically because
    they need to make two consecutive passes over the data: one from the start to
    the end and the other from the end to the start of the data obtained from the
    first pass.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当认证密码能够逐块处理消息并丢弃已处理的块时，它就是*可流式处理*（也称为*在线*密码）。相反，不能流式处理的密码必须存储整个消息，通常是因为它们需要对数据进行两次连续的处理：一次从头到尾，另一次从尾到头，利用第一次处理得到的数据。
- en: Because of potentially high memory requirements, some applications won’t work
    with nonstreamable ciphers. For example, a router could receive an encrypted block
    of data, decrypt it, and then return the plaintext block before moving on to decrypt
    the subsequent block of the message, though the recipient of the decrypted message
    would still have to verify the authentication tag sent at the end of the decrypted
    data stream.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可能的高内存需求，某些应用程序无法使用不可流式处理的密码。例如，一台路由器可以接收加密的数据块，解密它，然后返回明文数据块，然后再继续解密后续的消息块，尽管接收解密消息的接收者仍需验证解密数据流末尾发送的认证标签。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Other Features</samp>
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">其他特性</samp>
- en: 'Functional criteria are the features of a cipher or its implementation that
    don’t directly relate to either security or performance. For example, some authenticated
    ciphers allow only associated data to precede the data to be encrypted (because
    they need access to it to start encryption). Others require associated data to
    follow the data to be encrypted or support the inclusion of associated data anywhere—even
    between chunks of plaintext. This last case is the best, because it enables users
    to protect their data in any possible situation, but it’s also the hardest to
    design securely: more features often bring more complexity and potential vulnerabilities.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 功能标准是指密码或其实现的特性，这些特性与安全性或性能无直接关系。例如，一些认证密码只允许关联数据位于待加密数据之前（因为它们需要访问关联数据以开始加密）。其他的则要求关联数据位于待加密数据之后，或者支持在任何位置（即使是明文块之间）插入关联数据。最后这种情况是最理想的，因为它允许用户在任何可能的情况下保护数据，但这也是最难以安全设计的：更多的功能往往带来更多的复杂性和潜在漏洞。
- en: Another piece of functional criteria to consider relates to whether you can
    use the same core algorithm for both encryption and decryption. For example, many
    authenticated ciphers are based on the AES block cipher, which specifies the use
    of two similar algorithms for encrypting and decrypting a block. As discussed
    in [Chapter 4](chapter4.xhtml), the CBC block cipher mode requires both algorithms,
    but the CTR mode requires only the encryption algorithm. Likewise, authenticated
    ciphers may not need both algorithms. Although the extra cost of implementing
    both encryption and decryption algorithms won’t impact most software, it’s often
    noticeable on low-cost dedicated hardware, where you measure implementation cost
    in terms of logic gates, or the silicon area occupied by the cryptography.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的功能标准是，你是否可以使用相同的核心算法进行加密和解密。例如，许多认证密码基于 AES 区块密码，它规定使用两种相似的算法来加密和解密数据块。如[第4章](chapter4.xhtml)中所述，CBC
    区块密码模式需要两种算法，而 CTR 模式只需要加密算法。同样，认证密码可能不需要两种算法。虽然实现加密和解密算法的额外成本不会影响大多数软件，但在低成本专用硬件上，往往会有所体现，在这种硬件上，实施成本通常以逻辑门或加密占用的硅面积来衡量。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">The AES-GCM Authenticated Cipher
    Standard</samp>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">AES-GCM 认证密码标准</samp>'
- en: AES-GCM is the most widely used authenticated cipher. AES-GCM is based on the
    AES algorithm, and the Galois counter mode (GCM) of operation is essentially a
    tweak of the CTR mode that incorporates a small and efficient component to compute
    an authentication tag. As I write this, AES-GCM is a NIST standard (SP 800-38D),
    is part of NSA’s Suite B, and is recognized by the IETF for the secure network
    protocols IPsec, SSH, and TLS 1.2 and 1.3.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: AES-GCM 是最广泛使用的认证密码。AES-GCM 基于 AES 算法，而 Galois 计数器模式（GCM）的工作方式本质上是对 CTR 模式的一种调整，加入了一个小巧高效的组件来计算认证标签。在我写这篇文章时，AES-GCM
    已成为 NIST 标准（SP 800-38D），是 NSA Suite B 的一部分，并且被 IETF 认可，用于安全网络协议 IPsec、SSH 以及 TLS
    1.2 和 1.3。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Although GCM works with any block cipher, you’ll probably see it used only
    with AES.*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管 GCM 可以与任何区块密码一起使用，但你可能只会看到它与 AES 一起使用。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GCM Internals</samp>
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GCM 内部机制</samp>
- en: '[Figure 8-2](chapter8.xhtml#fig8-2) shows how AES-GCM works: AES instances
    parameterized by a secret key (*K*) transform a block composed of the nonce (*N*)
    concatenated with a counter (starting here at 1, then incremented to 2, 3, and
    so on) and then XOR the result with a plaintext block to obtain a ciphertext block.
    So far, that’s nothing new when compared to the CTR mode.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-2](chapter8.xhtml#fig8-2) 展示了 AES-GCM 的工作原理：由一个秘密密钥 (*K*) 参数化的 AES 实例将一个由随机数
    (*N*) 与计数器（从 1 开始，接着递增为 2、3 等）连接起来组成的块进行转换，然后将结果与明文块进行异或操作，得到密文块。到目前为止，与 CTR 模式相比，这没有什么新意。'
- en: '![](../images/fig8-2.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig8-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-2: The AES-GCM mode,
    applied to one associated data block,</samp> <samp class="SANS_Futura_Std_Book_11">A</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUB_11">1</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,
    and two plaintext blocks,</samp> <samp class="SANS_Futura_Std_Book_11">P</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUB_11">1</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp>
    <samp class="SANS_Futura_Std_Book_11">P</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">2</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">. The circled multiplication sign represents
    polynomial multipli- cation by</samp> <samp class="SANS_Futura_Std_Book_11">H</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">, the authentication key derived from</samp>
    <samp class="SANS_Futura_Std_Book_11">K</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">.</samp>'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 8-2：AES-GCM 模式，应用于一个关联数据块，</samp>
    <samp class="SANS_Futura_Std_Book_11">A</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">1</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">，以及两个明文块，</samp> <samp class="SANS_Futura_Std_Book_11">P</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUB_11">1</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">和</samp>
    <samp class="SANS_Futura_Std_Book_11">P</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">2</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">。圆圈中的乘号表示由</samp> <samp class="SANS_Futura_Std_Book_11">H</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">，从</samp> <samp class="SANS_Futura_Std_Book_11">K</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">派生出的认证密钥进行多项式乘法。</samp>
- en: The ciphertext blocks are then mixed using a combination of XORs and multiplications
    (as you’ll see next). You can see AES-GCM as doing (1) an encryption in CTR mode
    and (2) a MAC over the ciphertext blocks. Therefore, AES-GCM is essentially an
    encrypt-then-MAC construction, where AES-CTR encrypts using a 128-bit key (*K*)
    and a 96-bit nonce (*N*).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 密文块随后通过异或和乘法的组合进行混合（正如你接下来会看到的）。你可以把 AES-GCM 看作是做了 (1) 在 CTR 模式下的加密和 (2) 对密文块进行
    MAC 操作。因此，AES-GCM 本质上是一种加密-再进行 MAC 构造，其中 AES-CTR 使用 128 位密钥 (*K*) 和 96 位随机数 (*N*)
    进行加密。
- en: To authenticate the ciphertext, GCM uses a Wegman–Carter MAC (see [Chapter 7](chapter7.xhtml)),
    which XORs the value **AES**(*K*, *N* || 0) with the output of the universal hash
    function *GHASH*. In [Figure 8-2](chapter8.xhtml#fig8-2), GHASH corresponds to
    the series of operations “⊗[H]” followed by the XOR with len(*A*) || len(*C*),
    or the bit length of *A* (the associated data) followed by the bit length of *C*
    (the ciphertext).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证密文的真实性，GCM 使用了 Wegman–Carter MAC（见 [第 7 章](chapter7.xhtml)），它将值 **AES**(*K*,
    *N* || 0) 与通用哈希函数 *GHASH* 的输出进行异或。在 [图 8-2](chapter8.xhtml#fig8-2) 中，GHASH 对应于操作序列
    “⊗[H]”，然后与 len(*A*) || len(*C*) 进行异或，或与 *A*（关联数据）的比特长度以及 *C*（密文）的比特长度进行异或。
- en: You can thus express the authentication tag’s value as *T* = **GHASH** (*H*,
    *A*, *C*) ⊕ **AES**(*K*, *N* || 0), where *H* is the *hash key*, or *authentication
    key*. This key is determined as *H* = **AES**(*K*, 0), which is the encryption
    of the block equal to a sequence of null bytes (I didn’t include this step in
    [Figure 8-2](chapter8.xhtml#fig8-2) for clarity).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以将认证标签的值表示为 *T* = **GHASH** (*H*, *A*, *C*) ⊕ **AES**(*K*, *N* || 0)，其中
    *H* 是 *哈希密钥*，或 *认证密钥*。这个密钥被确定为 *H* = **AES**(*K*, 0)，即等于由一系列空字节组成的块的加密（为了清晰起见，我没有在
    [图 8-2](chapter8.xhtml#fig8-2) 中包含这一步）。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*In GCM, GHASH doesn’t use* K *directly in order to ensure that if GHASH’s
    key is compromised, the master key* K *remains secret. Given* K*, you can get*
    H *by computing* ***AES****(*K*, 0), but you can’t recover* K *from that value,
    since* K *acts here as AES’s key.*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 GCM 中，GHASH 并不直接使用* K *，以确保如果 GHASH 的密钥被泄露，主密钥* K *仍然保持秘密。给定* K*，你可以通过计算
    ***AES****(*K*, 0) 来得到* H*，但你无法从这个值恢复* K*，因为* K* 在这里作为 AES 的密钥。*'
- en: GHASH uses *polynomial notation* to multiply each ciphertext block with the
    authentication key *H*. This use of polynomial multiplication makes GHASH fast
    in hardware and software, thanks, to a special polynomial multiplication instruction
    available in many common microprocessors (<samp class="SANS_TheSansMonoCd_W5Regular_11">CLMUL</samp>,
    for carry-less multiplication).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: GHASH 使用 *多项式表示法* 将每个密文块与认证密钥 *H* 相乘。这种多项式乘法的使用使得 GHASH 在硬件和软件中都非常快，因为许多常见微处理器都提供了一个特殊的多项式乘法指令（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CLMUL</samp>，用于无进位乘法）。
- en: Alas, GHASH is far from ideal. For one thing, its speed is suboptimal. Even
    when using the <samp class="SANS_TheSansMonoCd_W5Regular_11">CLMUL</samp> instruction,
    the AES-CTR layer that encrypts the plaintext remains faster than the GHASH MAC.
    Second, GHASH is painful to implement correctly. In fact, even the experienced
    developers of the OpenSSL project, by far the most-used cryptographic piece of
    software in the world, got AES-GCM’s GHASH wrong. One commit had a bug in a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">gcm_ghash_clmul</samp> function that allowed
    attackers to forge valid MACs for the AES-GCM. (Fortunately, Intel engineers spotted
    the error before the bug entered the next OpenSSL release.)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，GHASH 远非理想。首先，它的速度并不理想。即使使用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">CLMUL</samp>
    指令，加密明文的 AES-CTR 层仍然比 GHASH MAC 更快。其次，正确实现 GHASH 非常麻烦。事实上，即便是 OpenSSL 项目中经验丰富的开发人员——世界上最广泛使用的加密软件——也曾在实现
    AES-GCM 的 GHASH 时犯错。有一个提交在 <samp class="SANS_TheSansMonoCd_W5Regular_11">gcm_ghash_clmul</samp>
    函数中存在一个 bug，允许攻击者伪造 AES-GCM 的有效 MAC。 （幸运的是，英特尔工程师在 bug 进入下一版 OpenSSL 发布之前发现了这个错误。）
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GCM Security</samp>
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GCM 安全性</samp>
- en: AES-GCM’s biggest weakness is its fragility in the face of nonce repetition.
    If you use the same nonce *N* twice to encrypt two distinct messages, then an
    attacker observing the two ciphertexts can determine the value of the XOR between
    their respective plaintexts. They can also retrieve the authentication key *H*
    and use it to forge tags for any ciphertext, associated data, or combination thereof.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: AES-GCM 的最大弱点是它在面对随机数重复时的脆弱性。如果你使用相同的随机数 *N* 加密两个不同的消息，那么观察这两个密文的攻击者可以确定它们各自明文的异或值。攻击者还可以恢复出认证密钥
    *H*，并用它伪造任何密文、关联数据或它们的组合的标签。
- en: A look at the basic algebra behind AES-GCM’s computations (see [Figure 8-2](chapter8.xhtml#fig8-2))
    helps clarify this fragility. You compute a tag (*T*) as *T* = **GHASH** (*H*,
    *A*, *C*) ⊕ **AES**(*K*, *N* || 0), where GHASH is a universal hash function with
    linearly related inputs and outputs.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 AES-GCM 计算背后的基本代数（见 [图 8-2](chapter8.xhtml#fig8-2)）有助于澄清这种脆弱性。你可以将标签 (*T*)
    计算为 *T* = **GHASH** (*H*, *A*, *C*) ⊕ **AES**(*K*, *N* || 0)，其中 GHASH 是一个具有线性相关输入输出的通用哈希函数。
- en: 'If you compute two tags, *T*[1] and *T*[2], with the same nonce *N*, the AES
    part will vanish. If you have two tags, *T*[1] = **GHASH**(*H*, *A*[1], *C*[1])
    ⊕ **AES**(*K*, *N* || 0) and *T*[2] = **GHASH**(*H*, *A*[2], *C*[2]) ⊕ **AES**(*K*,
    *N* || 0), XORing them together results in the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用相同的随机数 *N* 计算两个标签 *T*[1] 和 *T*[2]，那么 AES 部分将会消失。如果你有两个标签，*T*[1] = **GHASH**(*H*,
    *A*[1], *C*[1]) ⊕ **AES**(*K*, *N* || 0) 和 *T*[2] = **GHASH**(*H*, *A*[2], *C*[2])
    ⊕ **AES**(*K*, *N* || 0)，将它们进行异或操作，结果如下：
- en: '![](../images/pg166-1.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg166-1.jpg)'
- en: If you use the same nonce twice, an attacker can thus recover the value **GHASH**(*H*,
    *A*[1], *C*[1]) ⊕ **GHASH**(*H*, *A*[2], *C*[2]) for some known *A*[1], *C*[1],
    *A*[2], and *C*[2]. The linearity of GHASH then allows an attacker to recover
    *H*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你两次使用相同的随机数，那么攻击者可以恢复出 **GHASH**(*H*, *A*[1], *C*[1]) ⊕ **GHASH**(*H*, *A*[2],
    *C*[2])，其中 *A*[1]、*C*[1]、*A*[2] 和 *C*[2] 是已知的。GHASH 的线性特性允许攻击者恢复出 *H*。
- en: In 2016, researchers scanned the internet for instances of AES-GCM exposed through
    HTTPS servers, in search of systems with repeating nonces (see the research article
    *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2016<wbr>/475](https://eprint.iacr.org/2016/475)*).
    They found 184 servers with repeating nonces, including 23 that always used the
    all-zero string as a nonce.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 2016 年，研究人员扫描了互联网，查找通过 HTTPS 服务器暴露的 AES-GCM 实例，试图寻找存在重复随机数的系统（参见研究文章 *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2016<wbr>/475](https://eprint.iacr.org/2016/475)*）。他们发现了
    184 台存在重复随机数的服务器，其中 23 台总是使用全零字符串作为随机数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GCM Efficiency</samp>
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GCM 效率</samp>
- en: An advantage of GCM mode is that GCM encryption and decryption process blocks
    independently, allowing you to parallelize their computation. However, the GMAC
    computation isn’t parallelizable, because it must be computed from the beginning
    to the end of the ciphertext once GHASH has processed any associated data. This
    lack of parallelizability means that any system that receives the plaintext first
    and then the associated data has to wait until all associated data is read and
    hashed before hashing the first ciphertext block.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: GCM 模式的一个优点是 GCM 加密和解密过程中的每个块可以独立处理，从而可以将它们的计算并行化。然而，GMAC 计算是无法并行化的，因为它必须从密文的开始到结束计算，一旦
    GHASH 处理完任何关联数据后才可以计算。这种无法并行化的特性意味着，任何先接收明文然后接收关联数据的系统都必须等待所有关联数据被读取并哈希处理之后，才能对第一个密文块进行哈希处理。
- en: 'However, GCM is streamable: since the computations in its two layers can be
    pipelined, there’s no need to store all ciphertext blocks before computing GHASH
    because GHASH processes each block as it’s encrypted. In other words, *P*[1] encrypts
    to *C*[1], then GHASH processes *C*[1] while *P*[2] encrypts to *C*[2], then *P*[1]
    and *C*[1] are no longer needed, and so on.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，GCM 是可流式处理的：由于其两层计算可以流水线处理，因此无需在计算 GHASH 之前存储所有密文块，因为 GHASH 会在每个块被加密时处理它。换句话说，*P*[1]
    会加密为 *C*[1]，然后 GHASH 在 *P*[2] 加密为 *C*[2] 的同时处理 *C*[1]，之后 *P*[1] 和 *C*[1] 就不再需要，以此类推。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The OCB Authenticated Cipher Mode</samp>
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">OCB 认证加密模式</samp>
- en: First developed in 2001, *offset codebook (OCB)* predates GCM, and like GCM
    it produces an authenticated cipher from a block cipher, though it does so faster
    and more simply. OCB has yet to see wider adoption because until 2021, the use
    of OCB was patented and required a license from its inventor. OCB is now free
    for anyone to use in any application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*偏移代码本（OCB）*首次开发于 2001 年，早于 GCM，并且像 GCM 一样，它从块加密算法生成一个认证的密码文本，尽管它做得更快、更简单。由于在
    2021 年之前，OCB 的使用受专利保护，并且需要从发明者那里获得许可，因此它尚未广泛采用。现在，OCB 对任何人免费开放，任何应用程序都可以使用。'
- en: Unlike GCM, OCB blends encryption and authentication into one processing layer
    that uses a single key. There’s no separate authentication layer, so OCB provides
    authentication mostly for free and performs nearly as many block cipher calls
    as a nonauthenticated cipher would—OCB is almost as simple as the ECB mode (see
    [Chapter 4](chapter4.xhtml)), except that it’s more secure.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与 GCM 不同，OCB 将加密和认证融合为一个处理层，并使用一个密钥。没有单独的认证层，因此 OCB 提供的认证几乎是免费的，并且执行的块加密调用几乎与非认证加密模式一样多——OCB
    几乎与 ECB 模式一样简单（参见 [第 4 章](chapter4.xhtml)），只不过它更安全。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">OCB Internals</samp>
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">OCB 内部结构</samp>
- en: '[Figure 8-3](chapter8.xhtml#fig8-3) shows how OCB works: it encrypts each plaintext
    block *P* to a ciphertext block *C* = **E**(*K*, *P* ⊕ *O*) ⊕ *O*, where **E**
    is a block cipher encryption function. Here, *O* (the *offset*) is a value that
    depends on the key and the nonce incremented for each new block processed.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-3](chapter8.xhtml#fig8-3) 显示了 OCB 的工作原理：它将每个明文块 *P* 加密为一个密文块 *C* = **E**(*K*,
    *P* ⊕ *O*) ⊕ *O*，其中 **E** 是一个块加密函数。在这里，*O*（*偏移量*）是一个值，它依赖于密钥和每处理一个新块时递增的随机数。'
- en: '![](../images/fig8-3.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig8-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-3: The OCB encryption
    process when run on two plaintext blocks, with no associated data</samp>'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 8-3：OCB 在处理两个明文块且没有关联数据时的加密过程</samp>
- en: To produce the authentication tag, OCB first XORs the plaintext blocks together
    to compute *S* = *P*[1] ⊕ *P*[2] ⊕ *P*[3] ⊕ . . . The tag is then *T* = **E**(*K*,
    *S* ⊕ *O*^*), where *O*^* is an offset value computed from the offset of the last
    plaintext block processed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成认证标签，OCB 首先对明文块进行异或运算，计算 *S* = *P*[1] ⊕ *P*[2] ⊕ *P*[3] ⊕ . . . 然后，标签为 *T*
    = **E**(*K*, *S* ⊕ *O*^*)，其中 *O*^* 是通过处理最后一个明文块时的偏移量计算出的偏移值。
- en: Like AES-GCM, OCB also supports associated data as a series of blocks, *A*[1],
    *A*[2], and so on. When an OCB encrypted message contains associated data, calculate
    the authentication tag according to the formula
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 像 AES-GCM 一样，OCB 也支持将关联数据作为一系列块，即 *A*[1]、*A*[2] 等。当 OCB 加密的消息包含关联数据时，按照公式计算认证标签。
- en: '![](../images/pg168-1.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg168-1.jpg)'
- en: where OCB defines different offsets from those used to encrypt *P*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，OCB 定义了与用于加密 *P* 的偏移量不同的偏移量。
- en: Unlike GCM and encrypt-then-MAC, which combine ciphertext blocks to form the
    tag, OCB calculates the authentication tag by combining plaintext data. There’s
    nothing wrong with this approach, and OCB is backed by solid security proofs.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与 GCM 和加密后再 MAC 不同，后者通过将密文块组合形成标签，OCB 通过组合明文数据来计算认证标签。这种方法没有问题，且 OCB 得到了坚实的安全证明。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*For more on how to implement OCB, see either RFC 7253 or the 2011 paper “The
    Software Performance of Authenticated-Encryption Modes” by Ted Krovetz and Phillip
    Rogaway, which covers the latest and best version of OCB, OCB3\. For further details
    on OCB, see the FAQ at* [http://<wbr>web<wbr>.cs<wbr>.ucdavis<wbr>.edu<wbr>/rogaway<wbr>/ocb<wbr>/ocb<wbr>-faq<wbr>.htm](http://web.cs.ucdavis.edu/rogaway/ocb/ocb-faq.htm).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关如何实现 OCB 的更多信息，请参见 RFC 7253 或 2011 年 Ted Krovetz 和 Phillip Rogaway 撰写的论文《认证加密模式的软件性能》，该文介绍了最新和最好的
    OCB 版本，即 OCB3。有关 OCB 的更多细节，请参见 FAQ：* [http://<wbr>web<wbr>.cs<wbr>.ucdavis<wbr>.edu<wbr>/rogaway<wbr>/ocb<wbr>/ocb<wbr>-faq<wbr>.htm](http://web.cs.ucdavis.edu/rogaway/ocb/ocb-faq.htm)。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">OCB Security</samp>
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">OCB 安全性</samp>
- en: OCB is a bit less fragile than GCM against repeated nonces. If you use a nonce
    twice, an attacker that sees the two ciphertexts could notice that, say, the third
    plaintext block of the first message is identical to the third plaintext block
    of the second message. With GCM, attackers can find not only duplicates but also
    the XOR differences between blocks at the same position. The impact of repeated
    nonces is therefore worse with GCM than with OCB.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: OCB 对重复的 nonce（随机数）比 GCM 稍微不那么脆弱。如果你使用同一个 nonce 两次，攻击者可以看到两个密文后，发现例如第一个消息的第三个明文块与第二个消息的第三个明文块相同。使用
    GCM 时，攻击者不仅能发现重复项，还能找出相同位置块之间的异或差异。因此，重复 nonce 对 GCM 的影响比 OCB 更严重。
- en: As with GCM, repeated nonces jeopardize the authenticity of OCB, though less
    potently. For example, an attacker could combine blocks from two messages authenticated
    with OCB to create another encrypted message with the same checksum and tag as
    one of the original two messages, but the attacker wouldn’t be able to recover
    a secret key as with GCM.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与 GCM 一样，重复的 nonce 会危及 OCB 的真实性，尽管影响较小。例如，攻击者可以将用 OCB 认证的两条消息中的块组合起来，生成一个与原始两条消息之一相同的加密消息，并且具有相同的校验和和标签，但攻击者无法像在
    GCM 中那样恢复秘密密钥。
- en: In 2023, cryptographers discovered that using OCB3 with very short nonces (6
    bits) causes its security to significantly reduce; see the article at *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2023<wbr>/326](https://eprint.iacr.org/2023/326)*.
    Note that the version OCB2 was broken, as described in the article at *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2019<wbr>/311<wbr>.pdf](https://eprint.iacr.org/2019/311.pdf)*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 2023 年，密码学家发现，使用非常短的 nonce（6 位）的 OCB3 会显著降低其安全性；请参阅这篇文章：* [https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2023<wbr>/326](https://eprint.iacr.org/2023/326)*。请注意，OCB2
    版本已被破解，详情请参见这篇文章：* [https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2019<wbr>/311<wbr>.pdf](https://eprint.iacr.org/2019/311.pdf)*。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">OCB Efficiency</samp>
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">OCB 效率</samp>
- en: OCB and GCM are about equally efficient. Like GCM, OCB is parallelizable and
    streamable. In terms of raw efficiency, GCM and OCB make about as many calls to
    the underlying block cipher (usually AES), but OCB is slightly faster than GCM
    because it simply XORs the plaintext rather than performing something like the
    relatively expensive GHASH computation. (In earlier generations of Intel microprocessors,
    AES-GCM used to be more than three times slower than AES-OCB because AES and GHASH
    instructions had to compete for CPU resources and couldn’t be run in parallel.)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: OCB 和 GCM 的效率大致相同。像 GCM 一样，OCB 也是可以并行处理和流式传输的。在原始效率方面，GCM 和 OCB 对底层块加密算法（通常是
    AES）调用次数差不多，但 OCB 比 GCM 略快，因为它只需要对明文进行异或运算，而不是像相对昂贵的 GHASH 计算那样执行额外的操作。（在早期的英特尔微处理器中，AES-GCM
    的速度曾比 AES-OCB 慢三倍以上，因为 AES 和 GHASH 指令必须争夺 CPU 资源，无法并行执行。）
- en: An important difference between OCB and GCM implementations is that OCB needs
    both the block cipher’s encryption and decryption functions to encrypt and decrypt,
    increasing the cost of hardware implementations when only limited silicon is available
    for crypto components. In contrast, GCM uses only the encryption function for
    both encryption and decryption.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: OCB 和 GCM 实现之间的一个重要区别是，OCB 需要块密码的加密和解密函数来进行加密和解密，这增加了硬件实现的成本，尤其是在加密组件的硅片资源有限的情况下。相比之下，GCM
    只使用加密函数来进行加密和解密。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The SIV Authenticated Cipher Mode</samp>
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">SIV 认证密码模式</samp>
- en: '*Synthetic IV (SIV)* is an authenticated cipher mode typically used with AES.
    Unlike GCM and OCB, SIV is secure even if you use the same nonce twice: an attacker
    that gets two ciphertexts encrypted using the same nonce would only be able to
    learn whether the same plaintext was encrypted twice. Unlike with GCM or OCB,
    the attacker would be unable to tell whether the first block of the two messages
    is the same, because the nonce used to encrypt is first computed as a combination
    of the given nonce and the plaintext.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*合成初始化向量（SIV）* 是一种通常与 AES 一起使用的认证密码模式。与 GCM 和 OCB 不同，即使使用相同的随机数两次，SIV 依然是安全的：攻击者如果获取到使用相同随机数加密的两个密文，最多只能知道是否对相同的明文进行过两次加密。与
    GCM 或 OCB 不同，攻击者无法判断两个消息的第一个块是否相同，因为用于加密的随机数是通过给定的随机数和明文的组合来计算的。'
- en: 'The SIV construction specification is more general than that of GCM. Instead
    of specifying detailed internals as with GCM’s GHASH, SIV simply tells you how
    to combine a cipher (**E**) and a pseudorandom function (**PRF**) to get an authenticated
    cipher: you first compute the tag *T* = **PRF**(*K*[1], *N* || *P*) and then the
    ciphertext *C* = **E**(*K*[2], *T*, *P*), where *T* acts as the nonce of **E**.
    Thus, SIV needs two keys (*K*[1] and *K*[2]) and a nonce (*N*).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: SIV 构造的规范比 GCM 更为通用。与 GCM 的 GHASH 详细内部实现不同，SIV 只告诉你如何将一个密码 (**E**) 和一个伪随机函数
    (**PRF**) 结合起来得到一个认证密码：首先计算标签 *T* = **PRF**(*K*[1], *N* || *P*)，然后计算密文 *C* = **E**(*K*[2],
    *T*, *P*)，其中 *T* 作为 **E** 的随机数。因此，SIV 需要两个密钥 (*K*[1] 和 *K*[2]) 以及一个随机数 (*N*)。
- en: 'The major limitation of SIV is that it’s not streamable: after computing *T*,
    it must keep the entire plaintext *P* in memory. In other words, to encrypt a
    100GB plaintext with SIV, you must first store the 100GB so that SIV encryption
    can read it.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: SIV 的主要限制是它不可流式处理：在计算 *T* 后，它必须将整个明文 *P* 保存在内存中。换句话说，要用 SIV 加密一个 100GB 的明文，你必须先存储这
    100GB，以便 SIV 加密可以读取它。
- en: The document RFC 5297, based on the 2006 paper “Deterministic Authenticated-Encryption”
    by Phillip Rogaway and Thomas Shrimpton, specifies SIV as using CMAC-AES (a MAC
    construction using AES) as a PRF and AES-CTR as a cipher. In 2015, a more efficient
    version of SIV was proposed, GCM-SIV, which combines GCM’s fast GHASH function
    and SIV’s mode and is nearly as fast as GCM. Like the original SIV, however, GCM-SIV
    isn’t streamable. (For more information, see *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2015<wbr>/102](https://eprint.iacr.org/2015/102)*.)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 文档 RFC 5297 基于 2006 年 Phillip Rogaway 和 Thomas Shrimpton 发表的论文《确定性认证加密》，指定 SIV
    使用 CMAC-AES（一个基于 AES 的 MAC 构造）作为伪随机函数（PRF），并使用 AES-CTR 作为密码算法。2015 年，提出了一种更高效的
    SIV 版本——GCM-SIV，它结合了 GCM 的快速 GHASH 函数和 SIV 模式，并且几乎与 GCM 一样快。然而，与原始的 SIV 一样，GCM-SIV
    也不可流式处理。（更多信息请参见 *[https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2015<wbr>/102](https://eprint.iacr.org/2015/102)*。）
- en: <samp class="SANS_Futura_Std_Bold_B_11">Permutation-Based AEAD</samp>
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">基于置换的 AEAD</samp>
- en: 'Now for a totally different approach to building an authenticated cipher: instead
    of building a mode of operation around a block cipher like AES, we’ll look at
    a cipher that builds a mode around a permutation. A permutation simply transforms
    an input to an output of the same size, reversibly, without using a key, that’s
    the simplest component imaginable. Better still, the resulting AEAD is fast, provably
    secure, and more resistant to nonce reuse than GCM and OCB.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在介绍一种完全不同的认证密码构建方法：我们将不围绕像 AES 这样的块密码构建操作模式，而是看一种围绕置换构建模式的密码。置换简单地将输入转换为大小相同的输出，可逆且不使用密钥，这是最简单的组件。更好的是，最终得到的
    AEAD 不仅快速、可证明安全，而且比 GCM 和 OCB 更能抵抗重用随机数攻击。
- en: '[Figure 8-4](chapter8.xhtml#fig8-4) shows how a permutation-based AEAD works:
    from a fixed initial state *H*[0], you XOR the key *K* followed by the nonce *N*
    to the internal state, to obtain a new value of the internal state that’s the
    same size as the original. You then transform the new state with a permutation
    **P** and get a new value of the state. Now you XOR the first plaintext block
    *P*[1] to the state and take the resulting value as the first ciphertext block
    *C*[1], where *P*[1] and *C*[1] are equal in size but shorter than the state.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-4](chapter8.xhtml#fig8-4)展示了基于置换的AEAD是如何工作的：从一个固定的初始状态 *H*[0] 开始，你将密钥
    *K* 和随机数 *N* 依次与内部状态进行异或操作，以获得一个与原始状态相同大小的新内部状态。然后，你通过置换 **P** 转换新的状态，并获得状态的新值。接下来，你将第一个明文块
    *P*[1] 与状态进行异或操作，并将得到的结果作为第一个密文块 *C*[1]，其中 *P*[1] 和 *C*[1] 大小相同，但都比状态短。'
- en: '![](../images/fig8-4.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig8-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-4: A permutation-based
    authenticated cipher</samp>'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 8-4：基于置换的认证加密算法</samp>
- en: To encrypt a second block, transform the state with **P**, XOR the next plaintext
    block *P*[2] to the current state, and take the resulting value as *C*[2]. Then
    iterate over all plaintext blocks and, following the last call to **P**, take
    bits from the internal state as the authentication tag *T*, as in the right side
    of [Figure 8-4](chapter8.xhtml#fig8-4).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要加密第二个块，通过**P**转换状态，将下一个明文块 *P*[2] 与当前状态进行异或操作，并将结果作为 *C*[2]。然后对所有明文块进行迭代，并在最后一次调用
    **P** 后，从内部状态中提取位作为认证标签 *T*，如[图 8-4](chapter8.xhtml#fig8-4)右侧所示。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*You can adapt the mode in [Figure 8-4](chapter8.xhtml#fig8-4) to support associated
    data, but the process is a bit more complicated, so I’ll skip its description.*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以根据[图 8-4](chapter8.xhtml#fig8-4)中的模式来支持关联数据，但过程稍微复杂一些，因此我将跳过其描述。*'
- en: 'Designing *secure* permutation-based authenticated ciphers has certain requirements.
    First, only XOR input values to a part of the state: the larger this part, the
    more control a successful attacker has on the internal state and thus the lower
    the cipher’s security. Indeed, all security relies on the secrecy of the internal
    state.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 设计*安全*的基于置换的认证加密算法有一定要求。首先，只能对状态的一部分进行异或操作：这一部分越大，成功攻击者对内部状态的控制越多，密码的安全性就越低。实际上，所有的安全性都依赖于内部状态的保密性。
- en: Also, you must properly pad blocks with extra bits in a way that ensures that
    any two different messages yield different results. As a counterexample, if the
    last plaintext block is shorter than a complete block, it shouldn’t just be padded
    with 0s; otherwise, a plaintext block of, say, 2 bytes (0000) would result in
    a complete plaintext block (0000 . . . 0000), as would a block of 3 bytes (000000).
    As a result, you’d get the same tag for both messages, although they differ in
    size.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你必须正确地填充块并添加额外的位，以确保任何两个不同的消息会产生不同的结果。举个反例，如果最后一个明文块小于完整块，它不应该仅仅填充0；否则，一个例如2字节的明文块（0000）会变成一个完整的明文块（0000
    . . . 0000），同样，3字节的块（000000）也会变成完整的明文块。结果，你会得到两个消息相同的标签，尽管它们的大小不同。
- en: If you reuse a nonce in such a permutation-based cipher, the impact isn’t as
    bad as with GCM or OCB—the strength of the authentication tag won’t be compromised.
    If you repeat a nonce, an attacker would only learn whether the two encrypted
    messages begin with the same value, as well as the length of this common value,
    or prefix. For example, although encrypting the two six-block messages *ABCXYZ*
    and *ABCDYZ* (each letter symbolizing a block here) with the same nonce might
    yield the two ciphertexts *JKLTUV* and *JKLMNO*, which have identical prefixes,
    attackers wouldn’t be able to learn that the two plaintexts shared the same final
    two blocks (*YZ*).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在这样的基于置换的加密算法中重用随机数，则影响不像在GCM或OCB中那么严重——认证标签的强度不会受到影响。如果重复使用随机数，攻击者只能知道两个加密消息是否以相同的值开始，并且了解这个公共值或前缀的长度。例如，尽管使用相同的随机数加密两个六块消息
    *ABCXYZ* 和 *ABCDYZ*（这里每个字母表示一个块）可能会产生两个密文 *JKLTUV* 和 *JKLMNO*，它们有相同的前缀，攻击者也无法得知这两个明文共享相同的最后两个块（*YZ*）。
- en: In terms of performance, permutation-based ciphers offer the benefits of a single
    layer of operations, streamable processing, and the use of a single-core algorithm
    for encryption and decryption. However, they aren’t parallelizable like GCM or
    OCB because new calls to **P** need to wait for the previous call to complete.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能角度来看，基于置换的密码提供了单层操作、流式处理和使用单核算法进行加密和解密的优势。然而，它们不像GCM或OCB那样可以并行化，因为对**P**的新调用需要等待先前的调用完成。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*If you’re tempted to pick your favorite permutation and make up your own authenticated
    cipher, please don’t. You’re likely to get the details wrong and end up with an
    insecure cipher. Read the specifications written by experienced cryptographers
    for algorithms such as Keyak (an algorithm derived from Keccak), the Duplex construction,
    and deck functions on* [https://<wbr>keccak<wbr>.team](https://keccak.team)*.
    You’ll see that permutation-based ciphers are more complex than they first appear.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你有冲动选择自己喜欢的置换并制作自己的认证密码，请不要这样做。你可能会犯错，最终得到一个不安全的密码。阅读经验丰富的密码学家为诸如Keyak（源自Keccak的算法）、Duplex构造和deck函数等算法编写的规范，访问*
    [https://<wbr>keccak<wbr>.team](https://keccak.team)*。你会发现，基于置换的密码比它们最初看起来的要复杂得多。*'
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">如何出错</samp>
- en: Authenticated ciphers have a larger attack surface than hash functions or block
    ciphers because they aim to achieve both confidentiality *and* authenticity. They
    take several different input values and must remain secure regardless of whether
    the input contains only associated data and no encrypted data, extremely large
    plaintexts, or different key sizes. They must also be secure for all nonce values
    against attackers who collect numerous message/tag pairs and, to some extent,
    against accidental repetition of nonces.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 认证密码的攻击面比哈希函数或分组密码大，因为它们不仅要实现保密性*和*真实性。它们需要多个不同的输入值，并且必须在输入仅包含关联数据且没有加密数据、极大明文或不同密钥大小的情况下保持安全。它们还必须对所有随机数值在攻击者收集大量消息/标签对时保持安全，并且在一定程度上能够抵御随机数重复的意外情况。
- en: That’s a lot to ask, and even AES-GCM has several imperfections.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这要求很高，即使是AES-GCM也有几个不完美之处。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES-GCM and Weak
    Hash Keys</samp>
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES-GCM 和弱哈希密钥</samp>
- en: 'One of AES-GCM’s weaknesses is in its authentication algorithm GHASH: certain
    values of the hash key *H* greatly simplify attacks against GCM’s authentication
    mechanism. Specifically, if the value *H* belongs to some specific, mathematically
    defined subgroups of all 128-bit strings, attackers might be able to guess a valid
    authentication tag for some message simply by shuffling the blocks of a previous
    message.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: AES-GCM的一个弱点在于其认证算法GHASH：某些哈希密钥 *H* 的值极大地简化了针对GCM认证机制的攻击。具体而言，如果 *H* 的值属于所有128位字符串的某些特定数学定义的子群，攻击者可能通过重新排列之前消息的块来猜测某些消息的有效认证标签。
- en: To understand this weakness, let’s look at how GHASH works.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个弱点，我们来看一下GHASH是如何工作的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">GHASH Internals</samp>
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">GHASH 内部结构</samp>
- en: As you saw in [Figure 8-2](chapter8.xhtml#fig8-2), GHASH starts with a 128-bit
    value, *H*, initially set to **AES**(*K*, 0), and then repeatedly computes
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图8-2](chapter8.xhtml#fig8-2)中看到的，GHASH从一个128位的值 *H* 开始，初始值设置为 **AES**(*K*,
    0)，然后反复计算：
- en: '![](../images/pg171-1.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg171-1.jpg)'
- en: starting from *X*[0] = 0 and processing ciphertext blocks *C*[1], *C*[2], and
    so on. GHASH returns the final *X*i to compute the final tag.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *X*[0] = 0 开始，处理密文块 *C*[1]、*C*[2] 等。GHASH 返回最终的 *X*i，用于计算最终标签。
- en: 'Say for the sake of simplicity that all *C*i values are equal to 1 so that
    for any *I* you have this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设为了简便，所有 *C*i 值都等于 1，那么对于任何 *I*，你都会得到以下结果：
- en: '![](../images/pg171-2.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg171-2.jpg)'
- en: Next, computing X[1] from our first equation yields
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从我们的第一个方程计算出 X[1]，结果为：
- en: '![](../images/pg172-1.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg172-1.jpg)'
- en: 'substituting *X*[0] with 0 and *C*[1] with 1, to yield the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *X*[0] 替换为 0，*C*[1] 替换为 1，得到如下结果：
- en: '![](../images/pg172-2.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg172-2.jpg)'
- en: Thanks to the distributive property of ⊗ over ⊕, we substitute *X*[1] with *H*
    and *C*[2] with 1 and then compute the next value, *X*[2], as
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于⊗在⊕上的分配律，我们将 *X*[1] 替换为 *H*，将 *C*[2] 替换为 1，然后计算下一个值 *X*[2]，结果为：
- en: '![](../images/pg172-3.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg172-3.jpg)'
- en: where *H* ² is *H* squared, or *H* ⊗ *H*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *H* ² 是 *H* 的平方，或 *H* ⊗ *H*。
- en: 'Now you derive *X*[3] by substituting *X*[2] for its derivation, and obtain
    the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过将 *X*[2] 用于其推导，你得出 *X*[3]，并得到以下结果：
- en: '![](../images/pg172-4.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg172-4.jpg)'
- en: 'Next, you derive *X*[4] to be *X*[4] = *H* ⁴ ⊕ *H* ³ ⊕ *H* ² ⊕ *H*, and so
    on, and eventually the last *X*i is this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你推导出 *X*[4] 为 *X*[4] = *H* ⁴ ⊕ *H* ³ ⊕ *H* ² ⊕ *H*，以此类推，最终得到最后的 *X*i 为：
- en: '![](../images/pg172-5.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg172-5.jpg)'
- en: 'Remember that you set all blocks *C*i equal to 1\. If these values are arbitrary
    instead, you end up with the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你将所有块 *C*i 设置为 1。如果这些值是任意的，你将得到以下结果：
- en: '![](../images/pg172-6.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg172-6.jpg)'
- en: GHASH then XORs the message’s length to this last *X*n, multiplies the result
    by *H*, and XORs this value with **AES**(*K*, *N* || 0) to create the final authentication
    tag, *T*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: GHASH 然后将消息的长度与最后的 *X*n 异或，将结果乘以 *H*，并将此值与 **AES**(*K*, *N* || 0) 异或以创建最终的认证标签
    *T*。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Where Things Break</samp>
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">问题出现的地方</samp>
- en: 'What can go wrong from here? Let’s look first at the simplest cases:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始可能会出什么问题？我们首先来看最简单的情况：
- en: If *H* = 0, then *X*n = 0 regardless of the *C*i values and thus regardless
    of the message. That is, all messages will have the same authentication tag if
    *H* is 0.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *H* = 0，则无论 *C*i 的值如何，*X*n 都为 0，因此与消息无关。也就是说，如果 *H* 为 0，则所有消息的认证标签将相同。
- en: If *H* = 1, then the tag is just an XOR of the ciphertext blocks, and reordering
    the ciphertext blocks will give the same authentication tag.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *H* = 1，则标签仅仅是密文块的异或，重新排列密文块将得到相同的认证标签。
- en: Since 0 and 1 are only two of 2^(128) possible values of *H*, there’s only a
    2/2^(128) = 1/2^(127) chance of these occurring. But there are other weak values
    as well—namely, all values of *H* that belong to a *short cycle* when raised to
    *i*th powers. For example, the value of *H* <samp class="SANS_TheSansMonoCd_W5Regular_11">10d04d25f93556e69f58ce2f8d035a4</samp>
    belongs to a cycle of length 5, as it satisfies *H*⁵ = *H*, and therefore *H*
    *^e* = *H* for any *e* that is a multiple of 5 (the very definition of cycle with
    respect to fifth powers). Consequently, in the preceding expression of the final
    GHASH value *X*n, swapping the blocks *C*n (multiplied to *H*) and the block *C*n
    – [4] (multiplied to *H*⁵) leaves the authentication tag unchanged, which amounts
    to a forgery. An attacker may exploit this property to construct a new message
    and its valid tag without knowing the key, which should be impossible for a secure
    authenticated cipher.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 0 和 1 只是 *H* 的 2^(128) 种可能值中的两种，因此它们出现的概率仅为 2/2^(128) = 1/2^(127)。但也有其他弱值—即所有当
    *H* 被提升到 *i* 次方时，属于*短周期*的 *H* 的所有值。例如，*H* 的值 <samp class="SANS_TheSansMonoCd_W5Regular_11">10d04d25f93556e69f58ce2f8d035a4</samp>
    属于长度为 5 的周期，因为它满足 *H*⁵ = *H*，因此任何 *e* 为 5 的倍数时，*H* *^e* = *H*（即第五次方周期的定义）。因此，在前面的最终
    GHASH 值 *X*n 表达式中，交换块 *C*n（与 *H* 相乘）和块 *C*n – [4]（与 *H*⁵ 相乘）不会改变认证标签，这就等于伪造攻击。攻击者可能利用这一特性构造一个新的消息及其有效标签，而无需知道密钥，这应该是不可能的，对于一个安全的认证密码。
- en: The preceding example is based on a cycle of length 5, but there are many cycles
    of greater length and therefore many values of *H* that are weaker than they should
    be. The upshot is that, in the unlikely case that *H* belongs to a short cycle
    of values and attackers can forge as many authentication tags as they want, unless
    they know *H* or *K*, they can’t determine *H*’s cycle length. While attackers
    can’t exploit this vulnerability, you can avoid it by carefully choosing the polynomial
    used for modulo reductions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例基于长度为 5 的周期，但存在许多更长的周期，因此有许多 *H* 的值比应有的更弱。结果是，在极不可能的情况下，如果 *H* 属于一个短周期的值，并且攻击者可以伪造任意数量的认证标签，除非他们知道
    *H* 或 *K*，否则他们无法确定 *H* 的周期长度。虽然攻击者无法利用这个漏洞，但你可以通过仔细选择用于模减的多项式来避免此问题。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*For further details on this attack, read “Cycling Attacks on GCM, GHASH and
    Other Polynomial MACs and Hashes” by Markku-Juhani O. Saarinen, available at*
    [https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2011<wbr>/202](https://eprint.iacr.org/2011/202).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关此攻击的更多细节，请阅读 Markku-Juhani O. Saarinen 的《GCM、GHASH 和其他多项式 MAC 和哈希的循环攻击》，可以在*
    [https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2011<wbr>/202](https://eprint.iacr.org/2011/202)
    上查阅。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES-GCM and Small
    Tags</samp>
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES-GCM 和小标签</samp>
- en: In practice, AES-GCM usually returns 128-bit tags, but it can produce tags of
    any length. Unfortunately, when using shorter tags, the probability of forgery
    increases significantly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，AES-GCM通常返回128位标签，但它可以生成任意长度的标签。不幸的是，当使用较短的标签时，伪造的概率显著增加。
- en: When using a 128-bit tag, an attacker who attempts a forgery should succeed
    with a probability of 1/2^(128) because there are 2^(128) possible 128-bit tags.
    (Generally, with an *n*-bit tag, the probability of success should be 1/2*^n*,
    where 2*^n* is the number of possible values of an *n*-bit tag.) But when using
    shorter tags, the probability of forgery is much higher than 1/2*^n* due to weaknesses
    in the structure of GCM that are beyond the scope of this discussion. For example,
    a 32-bit tag allows an attacker who knows the authentication tag of some 2MB message
    to succeed with a chance of 1/2^(16) instead of 1/2^(32).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用128位标签时，攻击者试图伪造标签的成功概率应为1/2^(128)，因为有2^(128)种可能的128位标签。（通常，对于一个*n*位标签，成功的概率应为1/2^n，其中2^n是*n*位标签的可能值的数量。）但是，当使用较短的标签时，由于GCM结构中的弱点，伪造的概率远高于1/2^n，这些弱点超出了本讨论的范围。例如，32位标签允许一个攻击者在知道某个2MB消息的认证标签后，以1/2^(16)的几率成功，而不是1/2^(32)。
- en: Generally, with *n*-bit tags, the probability of forgery isn’t 1/2*^n* but rather
    2*^m*/2*^n*, where 2*^m* is the number of blocks of the longest message for which
    a successful attacker observed the tag. For example, if you use 48-bit tags and
    process messages of 4GB (or 2^(28) blocks of 16 bytes each), the probability of
    a forgery is 2^(28)/2^(48) = 1/2^(20), or about one chance in a million. That’s
    a relatively high chance as far as cryptography is concerned. (For more information
    on this attack, see the 2005 paper “Authentication Weaknesses in GCM” by Niels
    Ferguson.)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于*n*位标签，伪造的概率不是1/2^n，而是2^m/2^n，其中2^m是成功的攻击者观察到标签的最长消息的块数。例如，如果你使用48位标签并处理4GB的消息（或2^(28)个每个16字节的块），那么伪造的概率是2^(28)/2^(48)
    = 1/2^(20)，大约相当于百万分之一的几率。这在密码学中算是一个相对较高的几率。（有关此攻击的更多信息，请参见Niels Ferguson在2005年发表的论文《GCM中的认证弱点》）
- en: <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">进一步阅读</samp>
- en: 'To learn more about authenticated ciphers, visit the home page of CAESAR, the
    Competition for Authenticated Encryption: Security, Applicability, and Robustness
    (*[http://<wbr>competitions<wbr>.cr<wbr>.yp<wbr>.to<wbr>/caesar<wbr>.html](http://competitions.cr.yp.to/caesar.html)*).
    Started in 2012, CAESAR was a crypto competition in the style of the AES and SHA-3
    competitions, though it isn’t organized by NIST.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于认证密码的信息，请访问CAESAR主页，认证加密竞赛：安全性、适用性和鲁棒性：[http://competitions.cr.yp.to/caesar.html](http://competitions.cr.yp.to/caesar.html)。CAESAR于2012年开始，是一场类似于AES和SHA-3竞赛的加密竞赛，尽管它并不是由NIST组织的。
- en: 'The CAESAR competition attracted an impressive number of innovative designs:
    from OCB-like modes to permutation-based modes (such as NORX and Keyak), as well
    as totally original algorithms (such as AEZ or AEGIS). In 2019, CAESAR concluded
    with the selection of a portfolio of seven algorithms divided into three categories,
    which you can find on its official page at *[https://<wbr>competitions<wbr>.cr<wbr>.yp<wbr>.to<wbr>/caesar<wbr>-submissions<wbr>.html](https://competitions.cr.yp.to/caesar-submissions.html)*.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: CAESAR竞赛吸引了大量创新设计：从类似OCB的模式到基于置换的模式（如NORX和Keyak），以及完全原创的算法（如AEZ或AEGIS）。2019年，CAESAR竞赛结束，选出了七个算法组成的组合，分为三类，你可以在其官方网站上找到：[https://competitions.cr.yp.to/caesar-submissions.html](https://competitions.cr.yp.to/caesar-submissions.html)。
- en: Another competition where you can find authenticated encryption algorithms was
    NIST’s Lightweight Cryptography project. Running from 2017 to 2023, it aimed at
    standardizing algorithms optimized for resource-constrained environments (memory,
    processor size, and so on) such as embedded platforms. The winner of the competition
    was Ascon, a family of permutation-based algorithms, presented in detail on its
    official site at *[https://<wbr>ascon<wbr>.iaik<wbr>.tugraz<wbr>.at](https://ascon.iaik.tugraz.at)*.
    To discover the other candidate algorithms and the work presented at the project
    workshops, visit *[https://<wbr>csrc<wbr>.nist<wbr>.gov<wbr>/Projects<wbr>/lightweight<wbr>-cryptography](https://csrc.nist.gov/Projects/lightweight-cryptography)*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以找到认证加密算法的竞争项目是NIST的轻量级密码学项目。该项目从2017年到2023年，旨在标准化优化资源受限环境（如嵌入式平台的内存、处理器大小等）使用的算法。该竞争的获胜者是Ascon，这是一类基于置换的算法，详细信息可在其官方网站上查看，网址是*[https://<wbr>ascon<wbr>.iaik<wbr>.tugraz<wbr>.at](https://ascon.iaik.tugraz.at)*。要了解其他候选算法以及在项目研讨会上展示的工作，请访问*[https://<wbr>csrc<wbr>.nist<wbr>.gov<wbr>/Projects<wbr>/lightweight<wbr>-cryptography](https://csrc.nist.gov/Projects/lightweight-cryptography)*。
- en: In this chapter, we focused on GCM, but a handful of other modes are used in
    real applications as well. Specifically, the counter with CBC-MAC (CCM) and EAX
    modes competed with GCM for standardization in the early 2000s, and although GCM
    was selected, its competitors are used in a few applications. For example, CCM
    is used in the WPA2 Wi-Fi encryption protocol. Consider reading these ciphers’
    specifications and reviewing their relative security and performance merits.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们重点讨论了GCM，但在实际应用中，其他几种模式也被使用。具体来说，带CBC-MAC的计数器模式（CCM）和EAX模式在2000年代初与GCM竞争标准化，尽管最终选用了GCM，但其竞争者也在一些应用中被使用。例如，CCM被用于WPA2
    Wi-Fi加密协议。考虑阅读这些密码的规格，并审视它们相对的安全性和性能优势。
- en: This concludes our discussion of symmetric-key cryptography! You’ve seen block
    ciphers, stream ciphers, (keyed) hash functions, and now authenticated ciphers—all
    the main cryptography components that work with a symmetric key, or no key at
    all. Before we move to *asymmetric* cryptography, [Chapter 9](chapter9.xhtml)
    focuses on computer science and math, to provide background for asymmetric schemes
    such as RSA ([Chapter 10](chapter10.xhtml)) and Diffie–Hellman ([Chapter 11](chapter11.xhtml)).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们关于对称密钥密码学的讨论的总结！你已经了解了分组密码、流密码、（带密钥的）哈希函数，以及现在的认证密码——所有与对称密钥或根本不使用密钥的主要密码学组件。在我们转向*非对称*密码学之前，[第九章](chapter9.xhtml)将重点介绍计算机科学和数学，为非对称方案（如RSA（[第十章](chapter10.xhtml)）和Diffie–Hellman（[第十一章](chapter11.xhtml)））提供背景。
