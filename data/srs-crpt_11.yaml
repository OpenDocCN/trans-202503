- en: '10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '10'
- en: RSA
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: RSA
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: 'The Rivest–Shamir–Adleman (RSA) cryptosystem revolutionized cryptography when
    it emerged in 1977 as the first public-key encryption scheme; whereas classical,
    symmetric-key encryption schemes use the same secret key to encrypt and decrypt
    messages, public-key encryption (also called *asymmetric* encryption) uses two
    keys: one is your public key, which can be used by anyone who wants to encrypt
    messages for you, and the other is your private key, which is required in order
    to decrypt messages encrypted using the public key. This magic is the reason why
    RSA came as a real breakthrough, and 40 years later, it’s still the paragon of
    public-key encryption and a workhorse of internet security. (One year prior to
    RSA, Diffie and Hellman had introduced the concept of public-key cryptography,
    but their scheme was unable to perform public-key encryption.)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Rivest–Shamir–Adleman (RSA) 加密系统在1977年问世时，作为第一个公钥加密方案，彻底改变了密码学；而经典的对称密钥加密方案使用相同的秘密密钥来加密和解密信息，公钥加密（也叫做*非对称*加密）则使用两个密钥：一个是你的公钥，任何想要为你加密信息的人都可以使用它，另一个是你的私钥，只有使用这个私钥才能解密用公钥加密的信息。这种“魔法”是RSA成为真正突破性技术的原因，40年后，它仍然是公钥加密的典范，是互联网安全的核心工具。（在RSA发布的前一年，Diffie和Hellman提出了公钥密码学的概念，但他们的方案无法进行公钥加密。）
- en: RSA is above all an arithmetic trick. It works by creating a mathematical object
    called a *trapdoor permutation*, a function that transforms a number *x* to a
    number *y* in the same range, such that computing *y* from *x* is easy using the
    public key, but computing *x* from *y* is practically impossible unless you know
    the private key—the *trapdoor*. (Think of *x* as a plaintext and *y* as a ciphertext.)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: RSA本质上是一种算术技巧。它通过创建一个叫做*陷门置换*的数学对象来工作，这是一种将数字*x*转换为范围内的数字*y*的函数，使得通过公钥从*x*计算出*y*很容易，但除非你知道私钥——*陷门*，否则几乎不可能从*y*计算出*x*。（可以把*x*看作明文，把*y*看作密文。）
- en: In addition to encryption, RSA is also used to build digital signatures, wherein
    the owner of the private key is the only one able to sign a message, and the public
    key enables anyone to verify the signature’s validity.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 除了加密，RSA还用于构建数字签名，其中私钥的拥有者是唯一能够签署信息的人，而公钥则使任何人都能验证签名的有效性。
- en: In this chapter, I explain how the RSA trapdoor permutation works, discuss RSA’s
    security relative to the factoring problem (discussed in [Chapter 9](ch09.xhtml#ch9)),
    and then explain why the RSA trapdoor permutation alone isn’t enough to build
    *secure* encryption and signatures. I also discuss ways to implement RSA and demonstrate
    how to attack it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将解释RSA的陷门置换是如何工作的，讨论RSA相对于因数分解问题的安全性（在[第9章](ch09.xhtml#ch9)中讨论），并进一步解释为什么单靠RSA的陷门置换不足以构建*安全*的加密和签名。我还将讨论如何实现RSA，并演示如何攻击RSA。
- en: We begin with an explanation of the basic mathematical notions behind RSA.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从解释RSA背后的基本数学概念开始。
- en: The Math Behind RSA
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RSA背后的数学
- en: When encrypting a message, RSA sees the message as a big number, and encryption
    consists essentially of multiplications of big numbers. Therefore, in order to
    understand how RSA works, we need to know what kind of big numbers it manipulates
    and how multiplication works on those numbers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密一条信息时，RSA将该信息视为一个大数字，加密本质上是对大数字进行乘法运算。因此，为了理解RSA如何工作，我们需要知道它处理的是什么类型的大数字，以及如何在这些数字上进行乘法运算。
- en: RSA sees the plaintext that it’s encrypting as a positive integer between 1
    and *n* – 1, where *n* is a large number called the *modulus*. More precisely,
    RSA works on the numbers less than *n* that are co-prime with *n* and therefore
    that have no common prime factor with *n*. Such numbers, when multiplied together,
    yield another number that satisfies these criteria. We say that these numbers
    form a group, denoted **Z**[*N*]^*, and call the multiplicative group of integers
    modulo *n*. (See the mathematical definition of a group in [“What Is a Group?”](ch09.xhtml#lev2sec121)
    on page 174.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: RSA将其加密的明文视为介于1和*n* – 1之间的正整数，其中*n*是一个称为*模数*的大数字。更准确地说，RSA处理的是小于*n*且与*n*互质的数字，这些数字与*n*没有共同的素因子。当这些数字相乘时，会得到另一个满足这些标准的数字。我们称这些数字组成一个群，记作**Z**[*N*]^*，并称之为整数模*n*的乘法群。（请参见[“什么是群？”](ch09.xhtml#lev2sec121)中第174页的群的数学定义。）
- en: For example, consider the group **Z**[4]^* of integers modulo 4\. Recall from
    [Chapter 9](ch09.xhtml#ch9) that a group must include an identity element (that
    is, 1) and that each number *x* in the group must have an inverse, a number *y*
    such that *x* × *y* = 1\. How do we determine that set that makes up **Z**[4]^*?
    Based on our definitions, we know that 0 is not in the group **Z**[4]^* because
    multiplying any number by 0 can never give 1, so 0 has no inverse. By the same
    token, the number 1 belongs to **Z**[4]^* because 1 × 1 = 1, so 1 is its own inverse.
    However, the number 2 does not belong in this group because we can’t obtain 1
    by multiplying 2 with another element of **Z**[4]^* (the reason is that 2 isn’t
    co-prime with 4, because 4 and 2 share the factor of 2.) The number 3 belongs
    in the group **Z**[4]^* because it is its own inverse within **Z**[4]^*. Thus,
    we have **Z**[4]^* = {1, 3}.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，考虑模 4 的整数群 **Z**[4]^*。回想一下 [第 9 章](ch09.xhtml#ch9)，一个群必须包含一个单位元（即 1），并且群中的每个数字
    *x* 必须有一个逆元，即存在一个数字 *y*，使得 *x* × *y* = 1。那么我们如何确定组成 **Z**[4]^* 的集合呢？根据我们的定义，我们知道
    0 不在 **Z**[4]^* 中，因为任何数字与 0 相乘都不能得到 1，因此 0 没有逆元。同样地，数字 1 属于 **Z**[4]^*，因为 1 ×
    1 = 1，所以 1 是它自己的逆元。然而，数字 2 不属于这个群，因为我们无法通过将 2 与 **Z**[4]^* 中的其他元素相乘来得到 1（原因是 2
    与 4 不互质，因为 4 和 2 共享因子 2）。数字 3 属于 **Z**[4]^*，因为它在 **Z**[4]^* 中是它自己的逆元。因此，**Z**[4]^*
    = {1, 3}。
- en: 'Now consider **Z**[5]^*, the multiplicative group of integers modulo 5\. What
    numbers does this set contain? The number 5 is prime, and 1, 2, 3, and 4 are all
    co-prime with 5, so the set of **Z**[5]^* is {1, 2, 3, 4}. Let’s verify this:
    2 × 3 mod 5 = 1, therefore, 2 is 3’s inverse, and 3 is 2’s inverse; note that
    4 is its own inverse because 4 × 4 mod 5 = 1; finally, 1 is again its own inverse
    in the group.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑 **Z**[5]^*，这是模 5 的整数乘法群。这个集合包含哪些数字呢？数字 5 是质数，且 1、2、3 和 4 都与 5 互质，因此 **Z**[5]^*
    的集合是 {1, 2, 3, 4}。我们来验证一下：2 × 3 mod 5 = 1，因此，2 是 3 的逆元，3 是 2 的逆元；注意，4 是它自己的逆元，因为
    4 × 4 mod 5 = 1；最后，1 在这个群中也是它自己的逆元。
- en: 'In order to find the number of elements in a group **Z**[*n*]^* when *n* isn’t
    prime, we use *Euler’s totient function,* which is written as φ(*n*), with φ representing
    the Greek letter phi. This function gives the number of elements co-prime with
    *n*, which is the number of elements in **Z**[*n*]^*. As a rule, if *n* is a product
    of prime numbers *n* = *p*[1] × *p*[2] × … × *p*[*m*], the number of elements
    in the group **Z**[*n*]^* is the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算当 *n* 不是质数时群 **Z**[*n*]^* 中的元素个数，我们使用 *欧拉函数*，用符号 φ(*n*) 表示，其中 φ 代表希腊字母 phi。这个函数给出了与
    *n* 互质的元素个数，也就是 **Z**[*n*]^* 中的元素个数。通常来说，如果 *n* 是质数的乘积 *n* = *p*[1] × *p*[2] ×
    … × *p*[*m*]，那么群 **Z**[*n*]^* 中的元素个数为：
- en: φ(*n*) = (*p*[1] − 1) × (*p*[2] − 1) × … × (*p[m]* − 1)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: φ(*n*) = (*p*[1] − 1) × (*p*[2] − 1) × … × (*p[m]* − 1)
- en: RSA only deals with numbers *n* that are the product of two large primes, usually
    noted as *n* = *pq*. The associated group **Z**[*N*]^* will then contain φ(*n*)
    = (*p* – 1)(*q* – 1) elements. By expanding this expression, we get the equivalent
    definition φ(*n*) = *n* – *p* – *q* + 1, or φ(*n*) = (*n* + 1) – (*p* + *q*),
    which expresses more intuitively the value of φ(*n*) relative to *n*. In other
    words, all but (*p* + *q*) numbers between 1 and *n* – 1 belong to **Z**[*N*]^*
    and are “valid numbers” in RSA operations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: RSA 只处理 *n* 是两个大质数的乘积的数字，通常表示为 *n* = *pq*。相关的群 **Z**[*N*]^* 将包含 φ(*n*) = (*p*
    – 1)(*q* – 1) 个元素。通过展开这个表达式，我们得到等价的定义 φ(*n*) = *n* – *p* – *q* + 1，或者 φ(*n*) =
    (*n* + 1) – (*p* + *q*)，这更加直观地表达了 φ(*n*) 相对于 *n* 的值。换句话说，除了 (*p* + *q*) 之外，所有
    1 和 *n* – 1 之间的数字都属于 **Z**[*N*]^* 并且在 RSA 操作中是“有效的数字”。
- en: The RSA Trapdoor Permutation
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RSA 陷门置换
- en: The RSA trapdoor permutation is the core algorithm behind RSA-based encryption
    and signatures. Given a modulus *n* and number *e*, called the *public exponent*,
    the RSA trapdoor permutation transforms a number *x* from the set **Z**[*n*]^*
    into a number *y* = *x*^(*e*) mod *n*. In other words, it calculates the value
    that’s equal to *x* multiplied by itself *e* times modulo *n* and then returns
    the result. When we use the RSA trapdoor permutation to encrypt, the modulus *n*
    and the exponent *e* make up the RSA public key.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: RSA 陷门置换是 RSA 加密和签名背后的核心算法。给定模数 *n* 和数字 *e*，称为 *公钥指数*，RSA 陷门置换将集合 **Z**[*n*]^*
    中的数字 *x* 转换为数字 *y* = *x*^(*e*) mod *n*。换句话说，它计算出与 *x* 自乘 *e* 次模 *n* 相等的值，并返回结果。当我们使用
    RSA 陷门置换进行加密时，模数 *n* 和指数 *e* 组成 RSA 公钥。
- en: 'In order to get *x* back from *y*, we use another number, denoted *d*, to compute
    the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 *y* 中恢复出 *x*，我们使用另一个数字，记作 *d*，计算如下：
- en: '*y^d* mod *n* = (*x^e*)^(*d*) mod *n* = *x^(ed)* mod *n* = *x*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*y^d* mod *n* = (*x^e*)^(*d*) mod *n* = *x^(ed)* mod *n* = *x*'
- en: Because *d* is the trapdoor that allows us to decrypt, it is part of the private
    key in an RSA key pair, and, unlike the public key, it should always be kept secret.
    The number *d* is also called the *secret exponent*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 *d* 是让我们能够解密的“陷门”，它是 RSA 密钥对中的一部分，和公钥不同，应该始终保密。数字 *d* 也称为 *秘密指数*。
- en: Obviously, *d* isn’t just any number; it’s the number such that *e* multiplied
    by *d* is equivalent to 1, and therefore such that *x*^(*ed*) mod *n* = *x* for
    any *x*. More precisely, we must have *ed* = 1 mod φ(*n*) in order to get *x*^(*ed*)
    = *x*¹ = *x* and to decrypt the message correctly. Note that we compute modulo
    φ(*n*) and not modulo *n* here because exponents behave like the indexes of elements
    of **Z**[*n*]^* rather than as the elements themselves. Because **Z**[*n*]^* has
    φ(*n*) elements, the index must be less than φ(*n*).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，*d* 不是随便的数字；它是满足 *e* 与 *d* 相乘等于 1 的数字，因此满足 *x*^(*ed*) mod *n* = *x* 对任何 *x*
    都成立。更准确地说，我们必须有 *ed* = 1 mod φ(*n*)，才能确保 *x*^(*ed*) = *x*¹ = *x* 并正确解密消息。请注意，我们这里计算的是模
    φ(*n*) 而不是模 *n*，因为指数行为类似于 **Z**[*n*]^* 的元素索引，而不是元素本身。由于 **Z**[*n*]^* 中有 φ(*n*)
    个元素，索引必须小于 φ(*n*)。
- en: The number φ(*n*) is crucial to RSA’s security. In fact, finding φ(*n*) for
    an RSA modulus *n* is equivalent to breaking RSA, because the secret exponent
    *d* can easily be derived from φ(*n*) and *e*, by computing *e*’s inverse. Hence
    *p* and *q* should also be secret, since knowing *p* or *q* gives φ(*n*) by computing
    (*p* – 1)(*q* – 1) = φ(*n*).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数字 φ(*n*) 对 RSA 的安全性至关重要。事实上，求解 RSA 模数 *n* 的 φ(*n*) 等同于破解 RSA，因为秘密指数 *d* 可以通过计算
    *e* 的逆元，轻松从 φ(*n*) 和 *e* 推导出来。因此，*p* 和 *q* 也应当保密，因为知道 *p* 或 *q* 就可以通过计算 (*p* –
    1)(*q* – 1) = φ(*n*) 来得到 φ(*n*)。
- en: '**NOTE**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: φ(n) *is also called the* order *of the group* **Z**[n]^*; *the order is an
    important characteristic of a group, which is also essential to other public-key
    systems such as Diffie–Hellman and elliptic curve cryptography.*
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: φ(n) *也称为* 群的顺序 **Z**[n]^*；*顺序是群的重要特征，这对于其他公钥系统（如 Diffie–Hellman 和椭圆曲线密码学）也至关重要。*
- en: RSA Key Generation and Security
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RSA 密钥生成与安全性
- en: '*Key generation* is the process by which an RSA key pair is created, namely
    a public key (modulus *n* and public exponent *e*) and its private key (secret
    exponent *d*). The numbers *p* and *q* (such that *n* = *pq*) and the order φ(*n*)
    should also be secret, so they’re often seen as part of the private key.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*密钥生成* 是创建 RSA 密钥对的过程，即生成公钥（模数 *n* 和公钥指数 *e*）和对应的私钥（秘密指数 *d*）。数字 *p* 和 *q*（使得
    *n* = *pq*）以及顺序 φ(*n*) 也应当保密，因此它们通常被视为私钥的一部分。'
- en: In order to generate an RSA key pair, we first pick two random prime numbers,
    *p* and *q*, and then compute φ(*n*) from these, and we compute *d* as the inverse
    of *e*. To show how this works, [Listing 10-1](ch10.xhtml#ch10list1) uses SageMath
    (*[http://www.sagemath.org/](http://www.sagemath.org/)*), an open-source Python-like
    environment that includes many mathematical packages.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成 RSA 密钥对，我们首先选择两个随机的素数 *p* 和 *q*，然后根据这两个数计算 φ(*n*)，接着计算 *d* 作为 *e* 的逆元。为了演示这一过程，[清单
    10-1](ch10.xhtml#ch10list1) 使用了 SageMath (*[http://www.sagemath.org/](http://www.sagemath.org/)*)，这是一个开源的类
    Python 环境，包含了许多数学包。
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 10-1: Generating RSA parameters using SageMath*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-1：使用 SageMath 生成 RSA 参数*'
- en: '**NOTE**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In order to avoid multiple pages of output, I’ve used a 64-bit modulus* n
    *in [Listing 10-1](ch10.xhtml#ch10list1), but in practice an RSA modulus should
    be at least 2048 bits.*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了避免输出多页内容，我在 [清单 10-1](ch10.xhtml#ch10list1) 中使用了一个 64 位的模数* n *，但实际上，RSA
    模数应至少为 2048 位。*'
- en: We use the `random_prime()` function to pick random primes `p` ❶ and `q` ❷,
    which are lower than a given argument. Next, we multiply `p` and `q` to get the
    modulus `n` ❸ and φ(*n*), which is the variable `phi` ❹. We then generate a random
    public exponent, `e` ❺, by picking a random prime less than `phi` in order to
    ensure that `e` will have an inverse modulo `phi`. We then generate the associated
    private exponent *d* by using the `xgcd()` function from Sage ❻. This function
    computes the numbers *s* and *t* given two numbers, *a* and *b*, with the extended
    Euclidean algorithm such that *as* + *bt* = **GCD**(*a*, *b*). Finally, we check
    that *ed* mod φ(*n*) = 1 ❼, to ensure that *d* will work correctly to invert the
    RSA permutation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`random_prime()`函数来选择小于给定参数的随机质数`p` ❶ 和 `q` ❷，然后将`p`和`q`相乘得到模数`n` ❸ 和φ(*n*)，即变量`phi`
    ❹。接下来，我们生成一个随机的公有指数`e` ❺，通过选择一个小于`phi`的随机质数，确保`e`具有模`phi`的逆元。然后，我们通过使用Sage中的`xgcd()`函数来生成关联的私有指数*d*
    ❻。该函数通过扩展欧几里得算法计算出两个数*a*和*b*的数值*s*和*t*，使得*as* + *bt* = **GCD**(*a*, *b*)。最后，我们检查*ed*
    mod φ(*n*) = 1 ❼，以确保*d*可以正确地反转RSA置换。
- en: Now we can apply the trapdoor permutation, as shown in [Listing 10-2](ch10.xhtml#ch10list2).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以应用陷门置换，如在[Listing 10-2](ch10.xhtml#ch10list2)中所示。
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 10-2: Computing the RSA trapdoor permutation back and forth*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-2: 计算RSA陷门置换的前后过程*'
- en: We assign the integer 1234567 to *x* ❶ and then use the function `power_mod(x,
    e, n)`, the exponentiation modulo *n*, or *x*^(*e*) mod *n* in equation form,
    to calculate *y* ❷. Having computed *y* = *x*^(*e*) mod *n*, we compute *y*^(*d*)
    mod *n* ❸ with the trapdoor *d* to return the original *x*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将整数1234567赋值给*x* ❶，然后使用`power_mod(x, e, n)`函数进行模*n*的幂运算，或者按方程形式计算*x*^(*e*)
    mod *n*，得到*y* ❷。计算得出*y* = *x*^(*e*) mod *n*后，我们再用陷门*d*计算*y*^(*d*) mod *n* ❸，以返回原始的*x*。
- en: But how hard is it to find *x* without the trapdoor *d*? An attacker who can
    factor big numbers can break RSA by recovering *p* and *q* and then φ(*n*) in
    order to compute *d* from *e*. But that’s not the only risk. Another risk to RSA
    lies in an attacker’s ability to compute *x* from *x*^(*e*) mod *n*, or *e* th
    roots modulo *n*, without necessarily factoring *n*. Both risks seem closely connected,
    though we don’t know for sure whether they are equivalent.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在没有陷门*d*的情况下，找到*x*有多困难呢？一个能够因式分解大数的攻击者可以通过恢复*p*和*q*，再通过计算φ(*n*)来从*e*中计算出*d*，从而破解RSA。但这并非唯一的风险。RSA的另一个风险在于攻击者能够从*x*^(*e*)
    mod *n*中计算出*x*，即计算*e*次方根模*n*，而不必因式分解*n*。这两种风险看起来紧密相关，尽管我们无法确定它们是否等价。
- en: 'Assuming that factoring is indeed hard and that finding *e* th roots is about
    as hard, RSA’s security level depends on three factors: the size of *n*, the choice
    of *p* and *q*, and how the trapdoor permutation is used. If *n* is too small,
    it could be factored in a realistic amount of time, revealing the private key.
    To be safe, *n* should at least be 2048 bits long (a security level of about 90
    bits, requiring a computational effort of about 2^(90) operations), but preferably
    4096 bits long (a security level of approximately 128 bits). The values *p* and
    *q* should be unrelated random prime numbers of similar size. If they are too
    small, or too close together, it becomes easier to determine their value from
    *n*. Finally, the RSA trapdoor permutation should not be used directly for encryption
    or signing, as I’ll discuss shortly.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设因式分解确实困难，而求解*e*次方根也同样困难，RSA的安全性取决于三个因素：*n*的大小，*p*和*q*的选择，以及陷门置换的使用方式。如果*n*太小，可能会在实际时间内被因式分解，进而暴露私钥。为了安全起见，*n*至少应为2048位（约90位的安全级别，需要大约2^(90)次操作的计算量），但最好是4096位（约128位的安全级别）。*p*和*q*的值应该是无关的随机质数，且大小相近。如果它们太小或过于接近，从*n*中确定它们的值就变得更容易。最后，RSA的陷门置换不应直接用于加密或签名，正如我稍后将讨论的那样。
- en: Encrypting with RSA
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用RSA加密
- en: Typically, RSA is used in combination with a symmetric encryption scheme, where
    RSA is used to encrypt a symmetric key that is then used to encrypt a message
    with a cipher such as the Advanced Encryption Standard (AES). But encrypting a
    message or symmetric key with RSA is more complicated than simply converting the
    target to a number *x* and computing *x*^(*e*) mod *n*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，RSA与对称加密方案结合使用，其中RSA用于加密对称密钥，然后使用该密钥通过诸如高级加密标准（AES）等加密算法加密消息。但使用RSA加密消息或对称密钥比简单地将目标转换为数字*x*并计算*x*^(*e*)
    mod *n*更为复杂。
- en: In the following subsections, I explain why a naive application of the RSA trapdoor
    permutation is insecure, and how strong RSA-based encryption works.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的各个小节中，我将解释为什么简单应用 RSA 陷门置换是不安全的，以及强 RSA 加密是如何工作的。
- en: '*Breaking Textbook RSA Encryption’s Malleability*'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*打破教科书式 RSA 加密的易变性*'
- en: '*Textbook RSA encryption* is the phrase used to describe the simplistic RSA
    encryption scheme wherein the plaintext contains only the message you want to
    encrypt. For example, to encrypt the string *RSA*, we would first convert it to
    a number by concatenating the ASCII encodings of each of the three letters as
    a byte: *R* (byte 52), *S* (byte 53), and *A* (byte 41). The resulting byte string
    `525341` is equal to 5395265 when converted to decimal, which we might then encrypt
    by computing 5395265^(*e*) mod *n*. Without knowing the secret key, there would
    be no way to decrypt the message.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*教科书式 RSA 加密*是用来描述一种简化的 RSA 加密方案，其中明文仅包含你想要加密的消息。例如，要加密字符串 *RSA*，我们首先通过连接每个字母的
    ASCII 编码（作为字节）来将其转换为数字：*R*（字节 52）、*S*（字节 53）和 *A*（字节 41）。得到的字节串 `525341` 转换为十进制后是
    5395265，我们可以通过计算 5395265^(*e*) mod *n* 来加密它。如果不知道私钥，就无法解密该消息。'
- en: 'However, textbook RSA encryption is deterministic: if you encrypt the same
    plaintext twice, you’ll get the same ciphertext twice. That’s one problem, but
    there’s a bigger problem—given two textbook RSA ciphertexts *y*[1] = *x*[1]^(*e*)
    mod *n* and *y*[2] = *x*[2]^(*e*) mod *n*, you can derive the ciphertext of *x*[1]
    × *x*[2] by multiplying these two ciphertexts together, like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，教科书式 RSA 加密是确定性的：如果你两次加密相同的明文，你会得到相同的密文。这是一个问题，但更大的问题是——给定两个教科书式 RSA 密文 *y*[1]
    = *x*[1]^(*e*) mod *n* 和 *y*[2] = *x*[2]^(*e*) mod *n*，你可以通过将这两个密文相乘，推导出 *x*[1]
    × *x*[2] 的密文，就像这样：
- en: '*y*[1] × *y*[2] mod *n* = *x*[1]^(*e*) × *x*[2]^(*e*) mod *n* = (*x*[1] × *x*[2])^(*e*)
    mod *n*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[1] × *y*[2] mod *n* = *x*[1]^(*e*) × *x*[2]^(*e*) mod *n* = (*x*[1] × *x*[2])^(*e*)
    mod *n*'
- en: The result is (*x*[1] × *x*[2])^(*e*) mod *n*, the ciphertext of the message
    *x*[1] × *x*[2] mod *n*. Thus an attacker could create a new valid ciphertext
    from two RSA ciphertexts, allowing them to compromise the security of your encryption
    by letting them deduce information about the original message. We say that this
    weakness makes textbook RSA encryption *malleable*. (Of course, if you know *x*[1]
    and *x*[2], you can compute (*x*[1] × *x*[2])^(*e*) mod *n*, too, but if you only
    know *y*[1] and *y*[2], you should not be able to multiply ciphertexts and get
    a ciphertext of the multiplied plaintexts.)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 (*x*[1] × *x*[2])^(*e*) mod *n*，即消息 *x*[1] × *x*[2] mod *n* 的密文。因此，攻击者可以通过将两个
    RSA 密文结合，创建一个新的有效密文，从而通过让他们推导出原始消息的信息，来破坏你的加密安全性。我们说，这种弱点使得教科书式的 RSA 加密变得*易变*。（当然，如果你知道
    *x*[1] 和 *x*[2]，你也可以计算 (*x*[1] × *x*[2])^(*e*) mod *n*，但如果你只知道 *y*[1] 和 *y*[2]，你不应该能够通过相乘密文得到相乘后的明文密文。）
- en: '*Strong RSA Encryption: OAEP*'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*强 RSA 加密：OAEP*'
- en: In order to make RSA ciphertexts nonmalleable, the ciphertext should consist
    of the message data and some additional data called *padding*, as shown in [Figure
    10-1](ch10.xhtml#ch10fig1). The standard way to encrypt with RSA in this fashion
    is to use Optimal Asymmetric Encryption Padding (OAEP), commonly referred to as
    RSA-OAEP. This scheme involves creating a bit string as large as the modulus by
    padding the message with extra data and randomness before applying the RSA function.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 RSA 密文不易变，密文应包括消息数据和一些附加数据，这些附加数据被称为 *填充*，如[图 10-1](ch10.xhtml#ch10fig1)所示。以这种方式加密
    RSA 的标准方法是使用最优非对称加密填充（OAEP），通常称为 RSA-OAEP。该方案通过在应用 RSA 函数之前，用额外的数据和随机数填充消息，创建一个与模数相同大小的位串。
- en: '![image](../images/f10-01.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f10-01.jpg)'
- en: '*Figure 10-1: Encrypting a symmetric key,* K, *with RSA using* (n, e) *as a
    public key*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-1：使用 RSA 加密对称密钥* K，*以* (n, e) *作为公钥*'
- en: '**NOTE**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*OAEP is referred to as RSAES-OAEP in official documents such as the PKCS#1
    standard by the RSA company and NIST’s Special Publication 800-56B. OAEP improves
    on the earlier method now called PKCS#1 v1.5, which is one of the first in a series
    of Public-Key Cryptography Standards (PKCS) created by RSA. It is markedly less
    secure than OAEP, yet is still used in many systems.*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*OAEP 在官方文档中被称为 RSAES-OAEP，如 RSA 公司和 NIST 的特殊出版物 800-56B 中的 PKCS#1 标准。OAEP
    改进了现在被称为 PKCS#1 v1.5 的早期方法，这是一系列由 RSA 创建的公钥密码学标准（PKCS）中的第一个。它明显不如 OAEP 安全，但仍然在许多系统中使用。*'
- en: OAEP’s Security
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: OAEP 的安全性
- en: OAEP uses a pseudorandom number generator (PRNG) to ensure the indistinguishability
    and nonmalleability of ciphertexts by making the encryption probabilistic. It
    has been proven secure as long as the RSA function and the PRNG are secure and,
    to a lesser extent, as long as the hash functions aren’t too weak. You should
    use OAEP whenever you need to encrypt with RSA.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: OAEP 使用伪随机数生成器（PRNG）来确保密文的不可区分性和不可篡改性，使得加密具有概率性。只要 RSA 函数和 PRNG 是安全的，且哈希函数不太弱，它就被证明是安全的。每当你需要使用
    RSA 加密时，都应使用 OAEP。
- en: How OAEP Encryption Works
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: OAEP 加密工作原理
- en: In order to encrypt with RSA in OAEP mode, you need a message (typically a symmetric
    key, *K*), a PRNG, and two hash functions. To create the ciphertext, you use a
    given modulus *n* long of *m* bytes (that is, 8*m* bits, and therefore an *n*
    lower than 2⁸^(*m*)). To encrypt *K*, the *encoded message* is formed as *M* =
    *H* || 00 … 00 || 01 || *K*, where *H* is an *h*-byte constant defined by the
    OAEP scheme, followed by as many 00 bytes as needed and a 01 byte. This encoded
    message, *M*, is then processed as described next and as depicted in [Figure 10-2](ch10.xhtml#ch10fig2).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以 RSA-OAEP 模式加密，你需要一个消息（通常是一个对称密钥，*K*）、一个伪随机数生成器（PRNG）和两个哈希函数。为了生成密文，你使用一个给定的模数
    *n*，它有 *m* 字节长（即 8*m* 位，因此 *n* 小于 2⁸^(*m*)）。为了加密 *K*，*编码消息* 形成 *M* = *H* || 00
    … 00 || 01 || *K*，其中 *H* 是由 OAEP 方案定义的 *h* 字节常量，后面跟着所需数量的 00 字节和一个 01 字节。然后，按照下文所述的方式处理这个编码后的消息
    *M*，并如 [图 10-2](ch10.xhtml#ch10fig2) 所示。
- en: '![image](../images/f10-02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f10-02.jpg)'
- en: '*Figure 10-2: Encrypting a symmetric key*, K, *with RSA-OAEP, where* H *is
    a fixed parameter and* R *is random bits*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-2：使用 RSA-OAEP 加密对称密钥* K，*其中* H *是固定参数，* R *是随机位*'
- en: Next, you generate an *h*-byte random string *R* and set *M* = *M* ⊕ **Hash1**(*R*),
    where **Hash1**(*R*) is as long as *M*. You then set *R* = *R* ⊕ **Hash2**(*M*),
    where **Hash2**(*M*) is as long as *R*. Now you use these new values of *M* and
    *R* to form an *m*-byte string *P* = 00 || *M* || *R*, which is as long as the
    modulus *n* and which can be converted to an integer number less than *n*. The
    result of this conversion is the number *x*, which is then used to compute the
    RSA function *x*^(*e*) mod *n* to get the ciphertext.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，生成一个 *h* 字节的随机字符串 *R* 并设置 *M* = *M* ⊕ **Hash1**(*R*)，其中 **Hash1**(*R*) 的长度与
    *M* 相同。然后设置 *R* = *R* ⊕ **Hash2**(*M*)，其中 **Hash2**(*M*) 的长度与 *R* 相同。现在，使用这些新的
    *M* 和 *R* 值来形成一个 *m* 字节的字符串 *P* = 00 || *M* || *R*，它的长度与模数 *n* 相同，并且可以转换为一个小于
    *n* 的整数。此转换的结果是数字 *x*，然后使用 RSA 函数 *x*^(*e*) mod *n* 来计算密文。
- en: To decrypt a ciphertext *y*, you would first compute *x* = *y*^(*d*) mod *n*
    and, from this, recover the final values of *M* and *R*. Next, you would retrieve
    *M*’s initial value by computing *M* ⊕ **Hash1**(*R* ⊕ **Hash2**(*M*)). Finally,
    you would verify that *M* is of the form *H* || 00 … 00 || 01 || *K*, with an
    *h*-byte *H* and 00 bytes followed by a 01 byte.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 解密密文 *y* 时，你首先计算 *x* = *y*^(*d*) mod *n*，并从中恢复 *M* 和 *R* 的最终值。接下来，你通过计算 *M*
    ⊕ **Hash1**(*R* ⊕ **Hash2**(*M*)) 来恢复 *M* 的初始值。最后，你验证 *M* 的格式是否为 *H* || 00 … 00
    || 01 || *K*，其中 *H* 是 *h* 字节长，后面跟着 00 字节和一个 01 字节。
- en: In practice, the parameters *m* and *h* (the length of the modulus and the length
    of **Hash2**’s output, respectively) are typically *m* = 256 bytes (for 2048-bit
    RSA) and *h* = 32 (using SHA-256 as **Hash2**). This leaves *m* – *h* – 1 = 223
    bytes for *M*, of which up to *m* – 2*h* – 2 = 190 bytes are available for *K*
    (the “– 2” is due to the separator 01 byte in *M*). The **Hash1** hash value is
    then composed of *m* – *h* – 1 = 223 bytes, which is longer than the hash value
    of any common hash function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，参数 *m* 和 *h*（分别是模数的长度和**Hash2**输出的长度）通常为 *m* = 256 字节（对于 2048 位 RSA）和
    *h* = 32（使用 SHA-256 作为 **Hash2**）。这使得 *m* – *h* – 1 = 223 字节可用于 *M*，其中最多有 *m*
    – 2*h* – 2 = 190 字节可用于 *K*（“– 2”是由于 *M* 中的分隔符 01 字节）。然后，**Hash1** 哈希值由 *m* – *h*
    – 1 = 223 字节组成，这比任何常见哈希函数的哈希值都要长。
- en: '**NOTE**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In order to build a hash with such an unusual output length, the RSA standard
    documents specify the use of the* mask generating function *technique to create
    hash functions that return arbitrarily large hash values from any hash function.*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了构建具有如此不寻常输出长度的哈希，RSA 标准文档指定使用* mask generating function *技术来创建能够从任何哈希函数返回任意大哈希值的哈希函数。*'
- en: Signing with RSA
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 RSA 签名
- en: Digital signatures can prove that the holder of the private key tied to a particular
    digital signature signed some message and that the signature is authentic. Because
    no one other than the private key holder knows the private exponent *d*, no one
    can compute a signature *y* = *x*^(*d*) mod *n* from some value *x*, but everyone
    can verify *y*^(*e*) mod *n* = *x* given the public exponent *e*. That verified
    signature can be used in a court of law to demonstrate that the private-key holder
    did sign some particular message—a property of undeniability called *nonrepudiation*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名可以证明与特定数字签名相关联的私钥持有者签署了某条消息，并且该签名是合法的。因为除了私钥持有者之外，没有人知道私有指数*d*，所以没有人能够从某个值*x*计算出签名*y*
    = *x*^(*d*) mod *n*，但是任何人都可以通过公共指数*e*验证*y*^(*e*) mod *n* = *x*。该验证过的签名可以在法庭上用来证明私钥持有者确实签署了某条特定消息——这一不可否认的特性被称为*不可否认性*。
- en: It’s tempting to see RSA signatures as the converse of encryption, but they
    are not. Signing with RSA is not the same as encrypting with the private key.
    Encryption provides confidentiality whereas a digital signature is used to prevent
    forgeries. The most salient example of this difference is that it’s okay for a
    signature scheme to leak information on the message signed, because the message
    is not secret. For example, a scheme that reveals parts of the messages could
    be a secure signature scheme but not a secure encryption scheme.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 人们可能会误以为RSA签名是加密的反向操作，但实际上并非如此。用RSA签名与用私钥加密是不同的。加密提供保密性，而数字签名用于防止伪造。这个差异最明显的例子是，签名方案可以泄露签名消息的部分信息，因为消息本身并不保密。例如，某个透露消息部分内容的方案可以是一个安全的签名方案，但却不是一个安全的加密方案。
- en: Due to the processing overhead required, public-key encryption can only process
    short messages, which are usually secret keys rather than actual messages. A signature
    scheme, however, can process messages of arbitrary sizes by using their hash values
    **Hash**(*M*) as a proxy, and it can be deterministic yet secure. Like RSA-OAEP,
    RSA-based signature schemes can use a padding scheme, but they can also use the
    maximal message space allowed by the RSA modulus.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于公钥加密需要较高的处理开销，它只能处理短消息，这些消息通常是秘密密钥而不是实际的消息。然而，签名方案可以通过使用消息的哈希值**Hash**(*M*)作为代理，处理任意大小的消息，并且可以是确定性且安全的。像RSA-OAEP一样，基于RSA的签名方案可以使用填充方案，但它们也可以使用RSA模数所允许的最大消息空间。
- en: '*Breaking Textbook RSA Signatures*'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*破解教科书式RSA签名*'
- en: 'What we call a *textbook RSA signature* is the method that signs a message,
    *x*, by directly computing *y* = *x*^(*d*) mod *n*, where *x* can be any number
    between 0 and *n* – 1\. Like textbook encryption, textbook RSA signing is simple
    to specify and implement but also insecure in the face of several attacks. One
    such attack involves a trivial forgery: upon noticing that 0^(*d*) mod *n* = 0,
    1^(*d*) mod *n* = 1, and (*n* – 1)^(*d*) mod *n* = *n* – 1, regardless of the
    value of the private key *d*, an attacker can forge signatures of 0, 1, or *n*
    – 1 without knowing *d*.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的*教科书式RSA签名*是通过直接计算*y* = *x*^(*d*) mod *n*来签署消息*x*的方法，其中*x*可以是介于0和*n* –
    1之间的任意数值。像教科书加密一样，教科书式RSA签名简单易于指定和实现，但在面对多种攻击时也容易受到攻击。一种攻击方式是伪造签名：当攻击者注意到0^(*d*)
    mod *n* = 0，1^(*d*) mod *n* = 1，以及(*n* – 1)^(*d*) mod *n* = *n* – 1时，不论私钥*d*的值如何，攻击者都可以伪造0、1或*n*
    – 1的签名，而无需知道*d*。
- en: More worrying is the *blinding* *attack*. For example, say you want to get a
    third party’s signature on some incriminating message, *M*, that you know they
    would never knowingly sign. To launch this attack, you could first find some value,
    *R*, such that *R*^(*e*)*M* mod *n* is a message that your victim would knowingly
    sign. Next, you would convince them to sign that message and to show you their
    signature, which is equal to *S* = (*R*^(*e*)*M*)^(*d*) mod *n*, or the message
    raised to the power *d*. Now, given that signature, you can derive the signature
    of *M*, namely *M*^(*d*), with the aid of some straightforward computations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 更让人担忧的是*盲签名攻击*。举个例子，假设你想让第三方在某条有罪的消息*M*上签名，而你知道他们绝对不会主动签署此消息。要发起这种攻击，你可以先找到一个值*R*，使得*R*^(*e*)*M*
    mod *n*是受害者会愿意签署的消息。接下来，你会说服他们签署该消息并展示他们的签名，这个签名等于*S* = (*R*^(*e*)*M*)^(*d*) mod
    *n*，即消息的*d*次方。现在，凭借这个签名，你可以通过一些简单的计算推导出*M*的签名，即*M*^(*d*)。
- en: 'Here’s how this works: because *S* can be written as (*R*^(*e*)*M*)^(*d*) =
    *R*^(*ed*)*M*^(*d*), and because *R*^(*ed*) = *R* is equal to *R*^(*ed*) = *R*
    (by definition), we have S = (*R*^(*e*)*M*)^(*d*) = *RM*^(*d*). To obtain *M*^(*d*),
    we simply divide *S* by *R*, as follows, to obtain the signature:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这如何工作：因为 *S* 可以写作 (*R*^(*e*)*M*)^(*d*) = *R*^(*ed*)*M*^(*d*)，并且因为 *R*^(*ed*)
    = *R* 等于 *R*^(*ed*) = *R*（按定义），我们有 S = (*R*^(*e*)*M*)^(*d*) = *RM*^(*d*)。为了获得
    *M*^(*d*)，我们只需通过 *R* 将 *S* 除以，从而获得签名：
- en: '*S*/*R* = *RM^d*/*R* = *M^d*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*S*/*R* = *RM^d*/*R* = *M^d*'
- en: As you can see, this is a practical and powerful attack.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一个实际且强大的攻击方式。
- en: '*The PSS Signature Standard*'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*PSS签名标准*'
- en: The RSA *Probabilistic Signature Scheme (PSS)* is to RSA signatures what OAEP
    is to RSA encryption. It was designed to make message signing more secure, thanks
    to the addition of padding data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: RSA *概率签名方案 (PSS)* 就像 OAEP 对 RSA 加密的作用一样，是对 RSA 签名的扩展。它旨在通过增加填充数据来提高消息签名的安全性。
- en: As shown in [Figure 10-3](ch10.xhtml#ch10fig3), PSS combines a message narrower
    than the modulus with some random and fixed bits before RSAing the results of
    this padding process.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 10-3](ch10.xhtml#ch10fig3) 所示，PSS 将比模数更窄的消息与一些随机和固定的位结合，然后对这些填充后的结果进行 RSA
    运算。
- en: '![image](../images/f10-03.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f10-03.jpg)'
- en: '*Figure 10-3: Signing a message*, M, *with RSA and with the PSS standard, where*
    (n, d) *is the private key*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-3：使用 RSA 和 PSS 标准签名消息* M，*其中* (n, d) *是私钥*'
- en: Like all public-key signature schemes, PSS works on a message’s hash rather
    than on the message itself. Signing **Hash**(*M*) is secure as long as the hash
    function is collision resistant. One particular benefit of PSS is that you can
    use it to sign messages of any length, because after hashing a message, you’ll
    obtain a hash value of the same length regardless of the message’s original length.
    The hash’s length is typically 256 bits, with the hash function SHA-256.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有公钥签名方案一样，PSS 基于消息的哈希值而非消息本身进行工作。只要哈希函数是抗碰撞的，签名 **Hash**(*M*) 就是安全的。PSS 的一个特别好处是，你可以用它来签名任何长度的消息，因为对消息进行哈希后，不管原始消息的长度如何，你都会得到一个相同长度的哈希值。哈希的长度通常是
    256 位，使用的哈希函数是 SHA-256。
- en: Why not sign by just running OAEP on **Hash**(*M*)? Unfortunately, you can’t.
    Although similar to PSS, OAEP has only been proven secure for encryption, not
    for signature.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接通过对 **Hash**(*M*) 运行 OAEP 来签名？不幸的是，你不能。虽然与 PSS 相似，但 OAEP 只被证明在加密中是安全的，而不是在签名中。
- en: Like OAEP, PSS also requires a PRNG and two hash functions. One, **Hash1**,
    is a typical hash with *h*-byte hash values such as SHA-256\. The other, **Hash2**,
    is a wide-output hash like OAEP’s **Hash2**.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与 OAEP 类似，PSS 也需要一个 PRNG 和两个哈希函数。其中一个，**Hash1**，是一个典型的哈希函数，具有 *h* 字节的哈希值，如 SHA-256。另一个，**Hash2**，是一个宽输出哈希函数，类似于
    OAEP 的 **Hash2**。
- en: 'The PSS signing procedure for message *M* works as follows (where *h* is **Hash1**’s
    output length):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于消息 *M*，PSS 签名过程如下（其中 *h* 是 **Hash1** 的输出长度）：
- en: Pick an *r*-byte random string *R* using the PRNG.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 PRNG 选择一个 *r* 字节的随机字符串 *R*。
- en: Form an encoded message *M**′* = 0000000000000000 || **Hash1**(*M*) || *R*,
    long of *h* + *r* + 8 bytes (with eight zero bytes at the beginning).
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造编码消息 *M**′* = 0000000000000000 || **Hash1**(*M*) || *R*，长度为 *h* + *r* + 8
    字节（前面加上八个零字节）。
- en: Compute the *h*-byte string *H* = **Hash1**(*M**′*).
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 *h* 字节字符串 *H* = **Hash1**(*M**′*)。
- en: Set *L* = 00 … 00 || 01 || *R*, or a sequence of 00 bytes followed by a 01 byte
    and then *R*, with a number of 00 bytes such that *L* is long of *m* – *h* – 1
    bytes (the byte width *m* of the modulus minus the hash length *h* minus 1).
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 *L* = 00 … 00 || 01 || *R*，或者一串 00 字节，后跟一个 01 字节，然后是 *R*，使得 *L* 的长度为 *m*
    – *h* – 1 字节（模数的字节宽度 *m* 减去哈希长度 *h* 再减去 1）。
- en: Set *L* = *L* ⊕ **Hash2**(*H*), thus replacing the previous value of *L* with
    a new value.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 *L* = *L* ⊕ **Hash2**(*H*)，从而用新值替换 *L* 的旧值。
- en: Convert the *m*-byte string *P* = *L* || *H* || BC to a number, *x*, lower than
    *n*. Here, the byte BC is a fixed value appended after *H*.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *m* 字节的字符串 *P* = *L* || *H* || BC 转换为一个小于 *n* 的数字 *x*。这里，字节 BC 是在 *H* 后附加的固定值。
- en: Given the value of *x* just obtained, compute the RSA function *x*^(*d*) mod
    *n* to obtain the signature.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定刚获得的 *x* 值，计算 RSA 函数 *x*^(*d*) mod *n* 以获得签名。
- en: To verify a signature given a message, *M*, you compute **Hash1**(*M*) and use
    the public exponent *e* to retrieve *L* and *H* and then *M′* from the signature,
    checking the padding’s correctness at each step.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证给定消息 *M* 的签名，你需要计算 **Hash1**(*M*)，然后使用公钥指数 *e* 来恢复 *L* 和 *H*，再从签名中恢复 *M′*，并在每一步检查填充的正确性。
- en: In practice, the random string *R* (called a *sal**t* in the RSA-PSS standard)
    is usually as long as the hash value. For example, if you use *n* = 2048 bits
    and SHA-256 as the hash, the value *L* is long of *m* – *h* – 1 = 256 – 32 – 1
    = 223 bytes, and the random string *R* would typically be 32 bytes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，随机字符串 *R*（在 RSA-PSS 标准中称为 *salt*）通常与哈希值的长度相同。例如，如果你使用 *n* = 2048 位并选择 SHA-256
    作为哈希算法，值 *L* 的长度为 *m* – *h* – 1 = 256 – 32 – 1 = 223 字节，而随机字符串 *R* 通常为 32 字节。
- en: Like OAEP, PSS is provably secure, standardized, and widely deployed. Also like
    OAEP, it looks needlessly complex and is prone to implementation errors and mishandled
    corner cases. But unlike RSA encryption, there’s a way to get around this extra
    complexity with a signature scheme that doesn’t even need a PRNG, thus reducing
    the risk of insecure RSA signatures caused by an insecure PRNG, as discussed next.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与 OAEP 相似，PSS 是经过证明的安全、标准化且广泛部署的。和 OAEP 一样，它看起来过于复杂，容易发生实现错误和角落情况的处理不当。但与 RSA
    加密不同，有一种方法可以绕过这种额外的复杂性，采用一种甚至不需要伪随机数生成器（PRNG）的签名方案，从而减少由不安全的 PRNG 引起的不安全 RSA 签名的风险，下面将讨论这一点。
- en: '*Full Domain Hash Signatures*'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*全域哈希签名*'
- en: '*Full Domain Hash (FDH)* is the simplest signature scheme you can imagine.
    To implement it, you simply convert the byte string **Hash**(*M*) to a number,
    *x*, and create the signature *y* = *x*^(*d*) mod *n*, as shown in [Figure 10-4](ch10.xhtml#ch10fig4).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*全域哈希（FDH）* 是你能想象的最简单的签名方案。要实现它，你只需将字节串 **Hash**(*M*) 转换为一个数字 *x*，然后创建签名 *y*
    = *x*^(*d*) mod *n*，如 [图 10-4](ch10.xhtml#ch10fig4) 所示。'
- en: '![image](../images/f10-04.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f10-04.jpg)'
- en: '*Figure 10-4: Signing a message with RSA using the Full Domain Hash technique*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-4：使用全域哈希技术签名消息*'
- en: Signature verification is straightforward, too. Given a signature that is a
    number *y*, you compute *x* = *y*^(*e*) mod *n* and compare the result with **Hash**(*M*).
    It’s boringly simple, deterministic, yet secure. So why bother with the complexity
    of PSS?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 签名验证也很简单。给定一个数字签名 *y*，你计算 *x* = *y*^(*e*) mod *n*，然后将结果与 **Hash**(*M*) 进行比较。它简单、确定性且安全。那么，为什么还要使用复杂的
    PSS 呢？
- en: The main reason is that PSS was released *after* FDH, in 1996, and it has a
    security proof that inspires more confidence than FDH. Specifically, its proof
    offers slightly higher security guarantees than the proof of FDH, and its use
    of randomness helped strengthen that proof.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 主要原因是，PSS 是在 1996 年发布的，晚于 FDH，并且它有一个比 FDH 更能令人信服的安全性证明。具体来说，它的证明提供了略高于 FDH 证明的安全保证，且其使用的随机性有助于增强这一证明。
- en: These stronger theoretical guarantees are the main reason cryptographers prefer
    PSS over FDH, but most applications using PSS today could switch to FDH with no
    meaningful security loss. In some contexts, however, a viable reason to use PSS
    instead of FDH is that PSS’s randomness protects it from some attacks on its implementation,
    such as the fault attacks we’ll discuss in [“How Things Can Go Wrong”](ch10.xhtml#lev1sec72)
    on page 196.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更强的理论保证是密码学家偏好 PSS 而不是 FDH 的主要原因，但今天使用 PSS 的大多数应用可以在没有显著安全损失的情况下切换到 FDH。然而，在某些情况下，使用
    PSS 而不是 FDH 的一个合理理由是，PSS 的随机性保护它免受一些针对其实现的攻击，比如我们将在 [“事物如何出错”](ch10.xhtml#lev1sec72)（第
    196 页）中讨论的故障攻击。
- en: RSA Implementations
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RSA 实现
- en: I sincerely hope you’ll never have to implement RSA from scratch. If you’re
    asked to, run as fast as you can and question the sanity of the person who asked
    you to do so. It took decades for cryptographers and engineers to develop RSA
    implementations that are fast, sufficiently secure, and hopefully free of debilitating
    bugs, so you really don’t want to reinvent RSA. Even with all the documentation
    available, it would take months to complete this daunting task.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我真诚地希望你永远不必从零实现 RSA。如果有人要求你这么做，尽量跑得越快越好，并质疑要求你这么做的人的理智。密码学家和工程师花了几十年才开发出快速、足够安全且希望没有致命漏洞的
    RSA 实现，因此你真的不想重新发明 RSA。即使有所有文档可用，完成这个艰巨任务也需要几个月的时间。
- en: 'Typically, when implementing RSA, you’ll use a library or API that provides
    the necessary functions to carry out RSA operations. For example, the Go language
    has the following function in its `crypto` package (from *[https://www.golang.org/src/crypto/rsa/rsa.go](https://www.golang.org/src/crypto/rsa/rsa.go)*):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在实现 RSA 时，你会使用一个提供执行 RSA 操作所需函数的库或 API。例如，Go 语言的 `crypto` 包中有以下函数（来自 *[https://www.golang.org/src/crypto/rsa/rsa.go](https://www.golang.org/src/crypto/rsa/rsa.go)*）：
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The function `EncryptOAEP()` takes a hash value, a PRNG, a public key, a message,
    and a label (an optional parameter of OAEP), and returns a signature and an error
    code. When you call `EncryptOAEP()`, it calls `encrypt()` to compute the RSA function
    given the padded data, as shown in [Listing 10-3](ch10.xhtml#ch10list3).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`EncryptOAEP()`接受一个哈希值、一个伪随机数生成器（PRNG）、一个公钥、一个消息和一个标签（OAEP的可选参数），并返回一个签名和一个错误码。当你调用`EncryptOAEP()`时，它会调用`encrypt()`来计算给定填充数据的RSA函数，如[清单
    10-3](ch10.xhtml#ch10list3)所示。
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 10-3: Implementing the core RSA encryption function from the Go language
    cryptography library*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-3：从Go语言加密库实现核心RSA加密函数*'
- en: The main operation shown in [Listing 10-3](ch10.xhtml#ch10list3) is `c.Exp(m,
    e, pub.N)`, which raises a message, `m`, to the power `e` modulo `pub.N`, and
    assigns the result to the variable `c`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-3](ch10.xhtml#ch10list3)中显示的主要操作是`c.Exp(m, e, pub.N)`，它将消息`m`提升到指数`e`并对`pub.N`取模，然后将结果赋值给变量`c`。'
- en: If you choose to implement RSA instead of using a readily available library
    function, be sure to rely on an existing *big-number* library, which is a set
    of functions and types that allow you to define and compute arithmetic operations
    on large numbers thousands of bits long. For example, you might use the GNU Multiple
    Precision (GMP) arithmetic library in C, or Go’s `big` package. (Believe me, you
    don’t want to implement big-number arithmetic yourself.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择实现RSA，而不是使用现成的库函数，务必依赖一个现有的*大数*库，它是一组函数和类型，允许你定义和计算对数千位长的大数的算术运算。例如，你可以在C语言中使用GNU多精度（GMP）算术库，或者在Go语言中使用`big`包。（相信我，你不想自己实现大数算术。）
- en: Even if you just use a library function when implementing RSA, be sure that
    you understand how the internals work in order to measure the risks.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在实现RSA时仅使用库函数，也务必了解其内部工作原理，以便衡量风险。
- en: '*Fast Exponentiation Algorithm: Square-and-Multiply*'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*快速指数运算算法：平方并乘法*'
- en: The operation of raising *x* to the power *e*, when computing *x*^(*e*) mod
    *n*, is called *exponentiation*. When we’re working with big numbers, as with
    RSA, this operation can be extremely slow if naively implemented. But how do we
    do this efficiently?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 *x* 的 *e* 次幂时的操作，称为*指数运算*。当我们处理大数时，如RSA，如果简单实现，这一操作可能非常缓慢。但我们如何高效地完成这个操作呢？
- en: The naive way to compute *x*^(*e*) mod *n* takes *e* – 1 multiplications, as
    shown in the pseudocode algorithm in [Listing 10-4](ch10.xhtml#ch10list4).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 *x*^(*e*) mod *n* 的简单方法需要 *e* – 1 次乘法，如[清单 10-4](ch10.xhtml#ch10list4)中的伪代码算法所示。
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 10-4: A naive exponentiation algorithm in pseudocode*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-4：伪代码中的一个简单指数运算算法*'
- en: This algorithm is simple but highly inefficient. One way to get the same result
    exponentially faster is to square rather than multiply exponents until the correct
    value is reached. This family of methods is called *square-and-**multiply*, or
    *exponentiation by squaring* or *binary exponentiation*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法简单但效率极低。一种获得相同结果并显著加速的方法是，通过平方而不是乘法指数，直到达到正确的值。这类方法被称为*平方并乘*，或者*通过平方的指数运算*，或者*二进制指数运算*。
- en: 'For example, say that we want to compute 3^(65537) mod 36567232109354321\.
    (The number 65537 is the public exponent used in most RSA implementations.) We
    could multiply the number 3 by itself 65536 times, or we could approach this problem
    with the understanding that 65537 can be written as 2^(16) + 1 and use a series
    of squaring operations. Essentially, we do the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们要计算 3^(65537) mod 36567232109354321（65537是大多数RSA实现中使用的公共指数）。我们可以将数字3自己乘以65536次，或者我们可以通过理解65537可以写成
    2^(16) + 1，来使用一系列平方运算来解决这个问题。基本上，我们做以下操作：
- en: 'Initialize a variable, *y* = 3, and then compute the following squaring (*y*²)
    operations:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一个变量 *y* = 3，然后计算以下平方（*y*²）操作：
- en: Set *y* = *y*² mod *n* (now *y* = 3² mod *n*).
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 *y* = *y*² mod *n*（现在 *y* = 3² mod *n*）。
- en: Set *y* = *y*² mod *n* (now *y* = (3²)² mod *n* = 3⁴ mod *n*).
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 *y* = *y*² mod *n*（现在 *y* = (3²)² mod *n* = 3⁴ mod *n*）。
- en: Set *y* = *y*² mod *n* (now *y* = (3⁴)² = 3⁸ mod *n*).
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 *y* = *y*² mod *n*（现在 *y* = (3⁴)² = 3⁸ mod *n*）。
- en: Set *y* = *y*² mod *n* (now *y* = (3⁸)² = 3^(16) mod *n*).
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 *y* = *y*² mod *n*（现在 *y* = (3⁸)² = 3^(16) mod *n*）。
- en: Set *y* = *y*² mod *n* (now *y* = (3^(16))²= 3^(32) mod *n*).
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 *y* = *y*² mod *n*（现在 *y* = (3^(16))²= 3^(32) mod *n*）。
- en: And so on until *y* = 3^(65536), by performing 16 squarings.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以此类推，直到 *y* = 3^(65536)，通过执行16次平方运算。
- en: To get the final result, we return 3 × *y* mod *n* = 3^(65537) mod *n* = 26652909283612267\.
    In other words, we compute the result with only 17 multiplications rather than
    65536 with the naive method.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到最终结果，我们返回3 × *y* mod *n* = 3^(65537) mod *n* = 26652909283612267。换句话说，我们只需要通过17次乘法来计算结果，而不是使用朴素方法的65536次乘法。
- en: More generally, a square-and-multiply method works by scanning the exponent’s
    bits one by one, from left to right, computing the square for each exponent’s
    bit to double the exponent’s value, and multiplying by the original number for
    each bit with a value of 1 encountered. In the preceding example, the exponent
    65537 is 10000000000000001 in binary, and we squared *y* for each new bit and
    multiplied by the original number 3 only for the very first and last bits.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般来说，平方并乘法方法通过从左到右逐一扫描指数的每一位，计算每一位的平方以加倍指数的值，并对每个位为1时与原始数字相乘。在前面的例子中，指数65537在二进制中是10000000000000001，我们为每个新位平方*y*，并且仅在第一个和最后一个位时才与原始数字3相乘。
- en: '[Listing 10-5](ch10.xhtml#ch10list5) shows how this would work as a general
    algorithm in pseudocode to compute *x*^(*e*) mod *n* when the exponent *e* consists
    of bits *e*[*m*] [–] [1]*e*[*m*] [–] [2] … *e*[1]*e*[0], where *e*[0] is the least
    significant bit.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 10-5](ch10.xhtml#ch10list5)展示了如何作为一个通用算法在伪代码中计算 *x*^(*e*) mod *n*，其中指数
    *e* 包含位 *e*[*m*] [–] [1]*e*[*m*] [–] [2] … *e*[1]*e*[0]，其中 *e*[0] 是最低有效位。'
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 10-5: A fast exponentiation algorithm in pseudocode*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-5: 快速指数运算算法的伪代码*'
- en: The `expMod()` algorithm shown in [Listing 10-5](ch10.xhtml#ch10list5) runs
    in time *O*(*m*), whereas the naive algorithm runs in time *O*(2^(*m*)), where
    *m* is the bit length of the exponent. Here, *O*() is the asymptotic complexity
    notation introduced in [Chapter 9](ch09.xhtml#ch9).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 10-5](ch10.xhtml#ch10list5)中显示的`expMod()`算法的运行时间为*O*(*m*)，而朴素算法的运行时间为*O*(2^(*m*)),
    其中 *m* 是指数的位长。这里的*O*()是[第9章](ch09.xhtml#ch9)中引入的渐近复杂度符号。'
- en: Real systems often implement variants of this simplest square-and-multiply method.
    One such variant is the *sliding window* method, which considers blocks of bits
    rather than individual bits to perform a given multiplication operation. For example,
    see the function `expNN()` of the Go language, whose source code is available
    at *[https://golang.org/src/math/big/nat.go](https://golang.org/src/math/big/nat.go)*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 真实系统通常实现这种最简单的平方并乘法方法的变种。其中一种变种是*滑动窗口*方法，它考虑一块块的位而非单个的位来执行给定的乘法操作。例如，参见Go语言中的`expNN()`函数，其源代码可以在*
    [https://golang.org/src/math/big/nat.go](https://golang.org/src/math/big/nat.go)*找到。
- en: How secure are these square-and-multiply exponentiation algorithms? Unfortunately,
    the tricks to speed the process up often result in increased vulnerability against
    some attacks. Let’s see what can go wrong.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些平方并乘法指数算法有多安全？不幸的是，虽然加速过程的技巧通常能提高速度，但往往会增加对某些攻击的脆弱性。让我们看看会出现什么问题。
- en: The weakness in these algorithms is due to the fact that the exponentiation
    operations are heavily dependent on the exponent’s value. The `if` operation shown
    in [Listing 10-5](ch10.xhtml#ch10list5) takes a different branch based on whether
    an exponent’s bit is 0 or 1\. If a bit is 1, an iteration of the `for` loop will
    be slower than it will be for 0, and attackers who monitor the execution time
    of the RSA operation can exploit this time difference to recover a private exponent.
    This is called a timing attack. Attacks on hardware can distinguish 1 bit from
    0 bits by monitoring the device’s power consumption and observing which iterations
    perform an extra multiplication to reveal which bits of the private exponent are
    1.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法的弱点在于指数运算对指数值的依赖性很强。[Listing 10-5](ch10.xhtml#ch10list5)中显示的`if`操作根据指数的某一位是0还是1来选择不同的分支。如果某一位是1，那么`for`循环的迭代将比0时慢，攻击者通过监控RSA操作的执行时间可以利用这个时间差来恢复私有指数。这就是所谓的定时攻击。硬件攻击者可以通过监控设备的功耗来区分1位和0位，并观察哪些迭代执行了额外的乘法，从而揭示私有指数中哪些位为1。
- en: Only a minority of cryptographic libraries implement effective defenses against
    timing attacks, let alone against such power-analysis attacks.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 只有少数加密库实现了有效的防御机制，能够抵御定时攻击，更不用说应对像功率分析攻击这样的攻击了。
- en: '*Small Exponents for Faster Public-Key Operations*'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*使用小指数以加速公钥操作*'
- en: Because an RSA computation is essentially the computation of an exponentiation,
    its performance depends on the value of the exponents used. Smaller exponents
    require fewer multiplications and therefore can make the exponentiation computation
    much faster.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 RSA 计算本质上是指数运算，因此其性能取决于所用指数的值。较小的指数需要较少的乘法，因此可以使指数计算更快。
- en: The public exponent *e* can in principle be any value between 3 and φ(*n*) –
    1, as long as *e* and φ(*n*) are co-prime. But in practice you’ll only find small
    values of *e*, and most of the time *e* = 65537 due to concerns with encryption
    and signature verification speed. For example, the Microsoft Windows CryptoAPI
    only supports public exponents that fit in a 32-bit integer. The larger the *e*,
    the slower it is to compute *x*^(*e*) mod *n.*
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 公共指数 *e* 理论上可以是介于 3 和 φ(*n*) - 1 之间的任何值，只要 *e* 和 φ(*n*) 互质。但实际上，您只会发现小的 *e*
    值，而且大多数情况下 *e* = 65537，这是由于加密和签名验证速度的考虑。例如，Microsoft Windows CryptoAPI 只支持适合 32
    位整数的公共指数。*e* 越大，计算 *x*^(*e*) mod *n* 的速度就越慢。
- en: Unlike the size of the public exponent, the private exponent *d* will be about
    as large as *n*, making decryption much slower than encryption, and signing much
    slower than verification. Indeed, because *d* is secret, it must be unpredictable
    and therefore can’t be restricted to a small value. For example, if *e* is fixed
    to 65537, the corresponding *d* will usually be of the same order of magnitude
    as the modulus *n*, which would be close to 2^(2048) if *n* is 2048 bits long.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与公共指数的大小不同，私有指数 *d* 将与 *n* 大小相当，这使得解密比加密慢得多，签名也比验证慢得多。实际上，由于 *d* 是保密的，它必须是不可预测的，因此不能限制为一个小值。例如，如果
    *e* 固定为 65537，那么相应的 *d* 通常与模数 *n* 的数量级相同，如果 *n* 是 2048 位长，那么它将接近 2^(2048)。
- en: 'As discussed in [“Fast Exponentiation Algorithm: Square-and-Multiply”](ch10.xhtml#lev2sec130)
    on page 192, raising a number to the power 65537 will only take 17 multiplications,
    whereas raising a number to the power of some 2048-bit number will take on the
    order of 3000 multiplications.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在 [“快速指数算法：平方乘法”](ch10.xhtml#lev2sec130) 第 192 页中讨论的那样，将一个数字提高到 65537 次方只需要
    17 次乘法，而将一个数字提高到某个 2048 位数字的次方则需要大约 3000 次乘法。
- en: One way to determine the actual speed of RSA is to use the OpenSSL toolkit.
    For example, [Listing 10-6](ch10.xhtml#ch10list6) shows the results of 512-, 1024-,
    2048-, and 4096-bit RSA operations on my MacBook, which is equipped with an Intel
    Core i5-5257U clocked at 2.7 GHz.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 确定 RSA 实际速度的一种方法是使用 OpenSSL 工具包。例如，[列表 10-6](ch10.xhtml#ch10list6) 显示了在我的 MacBook
    上进行 512 位、1024 位、2048 位和 4096 位 RSA 操作的结果，该 MacBook 配备了 2.7 GHz 时钟频率的 Intel Core
    i5-5257U 处理器。
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 10-6: Benchmarks of RSA operations using the OpenSSL toolkit*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-6：使用 OpenSSL 工具包的 RSA 操作基准测试*'
- en: How much slower is verification compared to signature generation? To get an
    idea, we can compute the ratio of the verification time over signature time. The
    benchmarks in [Listing 10-6](ch10.xhtml#ch10list6) show that I’ve got verification-over-signature
    speed ratios of approximately 11.51, 14.75, 21.96, and 57.42 for 512-, 1024-,
    2048-, and 4096-bit moduli sizes, respectively. The gap grows with the modulus
    size because the number of multiplications for *e* operations will remain constant
    with respect to the modulus size (for example, 17 when *e* = 65537), while private-key
    operations will always need more multiplications for a greater modulus because
    *d* will grow accordingly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 验证与签名生成相比慢多少？为了获得一个概念，我们可以计算验证时间与签名时间的比率。[列表 10-6](ch10.xhtml#ch10list6) 中的基准测试显示，对于
    512 位、1024 位、2048 位和 4096 位模数大小，我得到的验证与签名速度比率分别约为 11.51、14.75、21.96 和 57.42。这个差距随着模数大小的增加而增大，因为
    *e* 操作所需的乘法次数将与模数大小保持恒定（例如，当 *e* = 65537 时是 17），而私钥操作由于 *d* 随着模数增大而增加，始终需要更多的乘法。
- en: 'But if small exponents are so nice, why use 65537 and not something like 3?
    It would actually be fine (and faster) to use 3 as an exponent when implementing
    RSA with a secure scheme such as OAEP, PSS, or FDH. Cryptographers avoid doing
    so, however, because when *e* = 3, less secure schemes make certain types of mathematical
    attacks possible. The number 65537 is large enough to avoid such *low-exponent
    attacks*, and it has just one instance in which a bit is 1, thanks to its low
    Hamming weight, which decreases the computational time. 65537 is also special
    for mathematicians: it’s the fourth Fermat number, or a number of the form'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果小指数这么好用，为什么不用 65537 而用 3 呢？实际上，在实现带有安全方案的 RSA（如 OAEP、PSS 或 FDH）时，使用 3 作为指数也是可以的，而且会更快。然而，加密专家避免这样做，因为当
    *e* = 3 时，较不安全的方案会使某些数学攻击成为可能。数字 65537 足够大，可以避免这种*低指数攻击*，并且由于其低哈明重量，它只有一个位是 1，从而减少了计算时间。65537
    对数学家也有特别意义：它是第四个费马数，或一种形式为
- en: 2^((2^(*n*))) + 1
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 2^((2^(*n*))) + 1
- en: because it’s equal to 2^(16) + 1, where 16 = 2⁴, but that’s just a curiosity
    mostly irrelevant for cryptographic engineers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它等于 2^(16) + 1，其中 16 = 2⁴，但这仅仅是一个好奇心，通常对加密工程师来说并不重要。
- en: '*The Chinese Remainder Theorem*'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*中国剩余定理*'
- en: The most common trick to speed up decryption and signature verification (that
    is, the computation of *y*^(*d*) mod *n*) is the *Chinese remainder theorem (CRT)*.
    It makes RSA about four times faster.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 加速解密和签名验证（即计算 *y*^(*d*) mod *n*）的最常见技巧是*中国剩余定理（CRT）*。它使得 RSA 约四倍更快。
- en: The Chinese remainder theorem allows for faster decryption by computing two
    exponentiations, modulo *p* and modulo *q*, rather than simply modulo *n*. Because
    *p* and *q* are much smaller than *n*, it’s faster to perform two “small” exponentiations
    than a single “big” one.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 中国剩余定理通过计算两个指数，模 *p* 和模 *q*，而不是直接模 *n*，可以加快解密速度。因为 *p* 和 *q* 比 *n* 小得多，所以执行两个“较小”的指数运算比执行一个“较大”的要快。
- en: The Chinese remainder theorem isn’t specific to RSA. It’s a general arithmetic
    result that, in its simplest form, states that if *n* = *n*[1]*n*[2]*n*[3] … ,
    where the *n*[*i*]s are pairwise co-prime (that is, **GCD**(*n*[*i*], *n*[*j*])
    = 1 for any distinct *i* and *j*), then the value *x* mod *n* can be computed
    from the values *x* mod *n*[1], *x* mod *n*[2], *x* mod *n*[3], … . For example,
    say we have *n* = 1155, which we write as the product of prime factors 3 × 5 ×
    7 × 11\. We want to determine the number *x* that satisfies *x* mod 3 = 2, *x*
    mod 5 = 1, *x* mod 7 = 6, and *x* mod 11 = 8\. (I’ve chosen 2, 1, 6, and 8 arbitrarily.)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 中国剩余定理并不仅限于 RSA。它是一个一般的算术结果，最简单的形式指出，如果 *n* = *n*[1]*n*[2]*n*[3] …，其中 *n*[*i*]s
    是两两互质的（即 **GCD**(*n*[*i*], *n*[*j*]) = 1 对于任何不同的 *i* 和 *j*），那么值 *x* mod *n* 可以从
    *x* mod *n*[1]、*x* mod *n*[2]、*x* mod *n*[3] 等值计算出来。例如，假设我们有 *n* = 1155，我们将其写成素因数的乘积
    3 × 5 × 7 × 11。我们想要确定满足 *x* mod 3 = 2、*x* mod 5 = 1、*x* mod 7 = 6 和 *x* mod 11
    = 8 的数字 *x*。（我任意选择了 2、1、6 和 8。）
- en: 'To find *x* using the Chinese remainder theorem, we can compute the sum *P*(*n*[1])
    + *P*(*n*[2]) + … , where *P*(*n*[*i*]) is defined as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用中国剩余定理找到 *x*，我们可以计算 *P*(*n*[1]) + *P*(*n*[2]) + …，其中 *P*(*n*[*i*]) 定义如下：
- en: '*P*(*n[i]*) = (*x* mod *n[i]*) × *n* / *n[i]* × (1 / (*n* / *n[i]*) mod *n[i]*)
    mod *n*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*(*n[i]*) = (*x* mod *n[i]*) × *n* / *n[i]* × (1 / (*n* / *n[i]*) mod *n[i]*)
    mod *n*'
- en: Note that the second term, *n*/*n*[*i*], is equal to the product of all other
    factors than this *n*[*i*].
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第二项 *n*/*n*[*i*] 等于除了这个 *n*[*i*] 之外所有其他因子的乘积。
- en: 'To apply this formula to our example and recover our *x* mod 1155, we take
    the arbitrary values 2, 1, 6, and 8; we compute *P*(3), *P*(5), *P*(7), and *P*(8);
    and then we add them together to get the following expression:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个公式应用到我们的例子中并恢复 *x* mod 1155，我们取任意值 2、1、6 和 8；我们计算 *P*(3)、*P*(5)、*P*(7)
    和 *P*(8)；然后将它们加在一起，得到以下表达式：
- en: '![image](../images/f0196-01.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0196-01.jpg)'
- en: Here, I’ve just applied the preceding definition of *P*(*n*[*i*]). (The math
    behind the way each number was found is straightforward, but I won’t detail it
    here.) This expression can then be reduced to [770 + 231 + 1980 + 1680] mod *n*
    = 41, and indeed 41 is the number I had picked for this example, so we’ve got
    the correct result.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我刚刚应用了前面定义的 *P*(*n*[*i*])。（每个数字如何找到的数学原理是直接的，但我不会在这里详细说明。）然后可以将这个表达式简化为
    [770 + 231 + 1980 + 1680] mod *n* = 41，实际上 41 正是我为这个例子选择的数字，所以我们得到了正确的结果。
- en: 'Applying the CRT to RSA is simpler than the previous example, because there
    are only two factors for each *n* (namely *p* and *q*). Given a ciphertext *y*
    to decrypt, instead of computing *y*^(*d*) mod *n*, you use the CRT to compute
    *x*[*p*] = *y*^(*s*) mod *p*, where *s* = *d* mod (*p* – 1) and *x*[q] = *y*^(*t*)
    mod *q*, where *t* = *d* mod (*q* – 1). You now combine these two expressions
    and compute *x* to be the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 将 CRT 应用于 RSA 比之前的例子更简单，因为每个 *n* 只有两个因子（即 *p* 和 *q*）。给定一个密文 *y* 需要解密时，与你计算 *y*^(*d*)
    mod *n* 的方式不同，你使用 CRT 来计算 *x*[*p*] = *y*^(*s*) mod *p*，其中 *s* = *d* mod (*p* –
    1)，并且 *x*[*q*] = *y*^(*t*) mod *q*，其中 *t* = *d* mod (*q* – 1)。然后，你将这两个表达式结合起来，计算
    *x* 得到如下结果：
- en: '*x* = *x[p]* × *q* × (1/*q* mod *p*) + *x[q]* × *p* × (1/*p* mod *q*) mod *n*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* = *x[p]* × *q* × (1/*q* mod *p*) + *x[q]* × *p* × (1/*p* mod *q*) mod *n*'
- en: And that’s it. This is faster than square-and-multiply because the multiplication-heavy
    operations are carried out on modulo *p* and *q*, numbers that are twice as small
    as *n*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。它比平方乘法更快，因为乘法密集的操作是在模 *p* 和 *q* 上进行的，而这两个数的大小仅为 *n* 的一半。
- en: '**NOTE**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the final operation, the two numbers* q × (1/q *mod* p) *and* p × (1/p
    *mod* q) *can be computed in advance, which means only two multiplications and
    an addition of modulo* n *need to be computed to find* x.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*在最后的操作中，两个数* q × (1/q *mod* p) *和* p × (1/p *mod* q) *可以提前计算，这意味着只需要计算两次乘法和一次模
    *n* 的加法来找到* x。'
- en: Unfortunately, there’s a security caveat attached to these techniques, as I’ll
    discuss next.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这些技术附带有一个安全隐患，接下来我将讨论这一点。
- en: How Things Can Go Wrong
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误如何发生
- en: Even more beautiful than the RSA scheme itself is the range of attacks that
    work either because the implementation leaks (or can be made to leak) information
    on its internals or because RSA is used insecurely. I discuss two classic examples
    of these types of attacks in the sections that follow.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 比 RSA 方案本身更美妙的是，一系列攻击的方式，它们之所以有效，要么是因为实现泄漏了（或可以被诱导泄漏）算法内部信息，要么是因为 RSA 被不安全地使用。我将在接下来的章节中讨论两个经典的攻击示例。
- en: '*The Bellcore Attack on RSA-CRT*'
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*Bellcore 攻击 RSA-CRT*'
- en: The Bellcore attack on RSA is one of the most important attacks in the history
    of RSA. When first discovered in 1996, it stood out because it exploited RSA’s
    vulnerability to *fault injections*—attacks that force a part of the algorithm
    to misbehave and thus yield incorrect results. For example, hardware circuits
    or embedded systems can be temporarily perturbed by suddenly altering their voltage
    supply or by beaming a laser pulse to a carefully chosen part of a chip. Attackers
    can then exploit the resulting faults in an algorithm’s internal operation by
    observing the impact on the final result. For example, comparing the correct result
    with a faulty one can provide information on the algorithm’s internal values,
    including secret values.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Bellcore 攻击是 RSA 历史上最重要的攻击之一。1996 年首次发现时，它引起了广泛关注，因为它利用了 RSA 对 *故障注入* 的漏洞——故障注入攻击通过迫使算法的一部分出错，从而得到不正确的结果。例如，硬件电路或嵌入式系统可以通过突然改变电压供应或向芯片上精确选定的部分照射激光脉冲来临时扰动。攻击者可以通过观察最终结果的影响，利用算法内部操作的故障。例如，比较正确结果和错误结果，可以提供关于算法内部值（包括密钥）的信息。
- en: The Bellcore attack is such a fault attack. It works on RSA signature schemes
    that use the Chinese remainder theorem and that are deterministic—meaning that
    it works on FDH, but not on PSS, which is probabilistic.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Bellcore 攻击就是这样一种故障攻击。它作用于使用中国剩余定理的 RSA 签名方案，并且是确定性的——这意味着它作用于 FDH，但不作用于 PSS，因为
    PSS 是概率性的。
- en: 'To understand how the Bellcore attack works, recall from the previous section
    that with CRT, the result that is equal to *x*^(*d*) mod *n* is obtained by computing
    the following, where *x*[*p*] = *y*^(*s*) mod *p* and *x*[*q*] = *y*^(*t*) mod
    *q*:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 Bellcore 攻击如何工作，请回想上一节内容，使用 CRT 时，等于 *x*^(*d*) mod *n* 的结果是通过以下计算获得的，其中
    *x*[*p*] = *y*^(*s*) mod *p* 和 *x*[*q*] = *y*^(*t*) mod *q*：
- en: '*x* = *x[p]* × *q* × (1/*q* mod *p*) + *x[q]* × *p* × (1/*p* mod *q*) mod *n*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* = *x[p]* × *q* × (1/*q* mod *p*) + *x[q]* × *p* × (1/*p* mod *q*) mod *n*'
- en: 'Now assume that an attacker induces a fault in the computation of *x*[*q*]
    so that you end up with some incorrect value, which differs from the actual *x*[*q*].
    Let’s call this incorrect value *x*[*q*]′ and call the final result obtained *x*′.
    The attacker can then subtract the incorrect signature *x*′ from the correct signature
    *x* to factor *n*, which results in the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设攻击者在 *x*[*q*] 的计算中引入了一个故障，使得你得到了一个错误的值，与实际的 *x*[*q*] 不同。我们将这个错误的值称为 *x*[*q*]′，并称最终得到的结果为
    *x*′。攻击者可以通过将错误的签名 *x*′ 与正确的签名 *x* 相减，进而分解 *n*，得到如下结果：
- en: '*x* − *x*′ = (*x[q]* − *x*[*q*]′) × *p* × (1/*p* mod *q*) mod *n*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* − *x*′ = (*x[q]* − *x*[*q*]′) × *p* × (1/*p* mod *q*) mod *n*'
- en: The value *x* – *x*′ is therefore a multiple of *p*, so *p* is a divisor of
    *x* – *x*′. Because *p* is also a divisor of *n*, the greatest common divisor
    of *n* and *x* – *x*′ yields *p*, **GCD**(*x* – *x*′, *n*) = *p*. We can then
    compute *q* = *n*/*p* and *d*, resulting in a total break of RSA signatures.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*x* – *x*′ 是 *p* 的倍数，所以 *p* 是 *x* – *x*′ 的一个约数。由于 *p* 也是 *n* 的约数，*n* 和 *x*
    – *x*′ 的最大公约数为 *p*，**GCD**(*x* – *x*′, *n*) = *p*。然后我们可以计算 *q* = *n*/*p* 和 *d*，从而导致
    RSA 签名的完全破解。
- en: A variant of this attack works when you don’t know the correct signature but
    only know the message is signed. There’s also a similar fault attack on the modulus
    value, rather than on the CRT values computation, but I won’t go into detail on
    that here.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击的一个变种发生在你不知道正确签名的情况下，但只知道消息已被签名。也有类似的故障攻击，针对的是模数值，而不是针对 CRT 值的计算，但我在这里不详细讨论这个。
- en: '*Sharing Private Exponents or Moduli*'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*共享私有指数或模数*'
- en: Now I’ll show you why your public key shouldn’t have the same modulus *n* as
    that of someone else.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将向你展示为什么你的公钥不应该与其他人的模数 *n* 相同。
- en: Different private keys belonging to different systems or persons should obviously
    have different private exponents, *d*, even if the keys use different moduli,
    or you could try your own value of *d* to decrypt messages encrypted for other
    entities, until you hit one that shares the same *d*. By the same token, different
    key pairs should have different *n* values, even if they have different *d*s,
    because *p* and *q* are usually part of the private key. Hence, if we share the
    same *n* and thus the same *p* and *q*, I can compute your private key from your
    public key *e* using *p* and *q*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不同系统或人员的不同私钥显然应该有不同的私有指数 *d*，即使它们使用不同的模数，或者你可能会尝试你自己的 *d* 值来解密为其他实体加密的消息，直到你碰到一个与自己共享相同
    *d* 的密钥。以同样的道理，不同的密钥对应该有不同的 *n* 值，即使它们有不同的 *d*，因为 *p* 和 *q* 通常是私钥的一部分。因此，如果我们共享相同的
    *n*，从而共享相同的 *p* 和 *q*，我可以通过你的公钥 *e* 结合 *p* 和 *q* 计算出你的私钥。
- en: What if my private key is simply the pair (*n*, *d*[1]), and your private key
    is (*n*, *d*[2]) and your public key is (*n*, *e*[2])? Say that I know *n* but
    not *p* and *q*, so I can’t directly compute your private exponent *d*[2] from
    your public exponent *e*[2]. How would you compute *p* and *q* from a private
    exponent *d* only? The solution is a bit technical, but elegant.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我的私钥只是一个对 (*n*, *d*[1])，而你的私钥是 (*n*, *d*[2])，你的公钥是 (*n*, *e*[2])，假设我知道 *n*
    但不知道 *p* 和 *q*，那么我不能直接从你的公钥指数 *e*[2] 计算出你的私有指数 *d*[2]。那么，你如何仅凭私有指数 *d* 计算出 *p*
    和 *q* 呢？这个解决方案有点技术性，但非常优雅。
- en: Remember that *d* and *e* satisfy *ed* = *k*φ(*n*) + 1, where φ(*n*) is secret
    and could give us *p* and *q* directly. We don’t know *k* or φ(*n*), but we can
    compute *k*φ(*n*) = *ed* – 1.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，*d* 和 *e* 满足 *ed* = *k*φ(*n*) + 1，其中 φ(*n*) 是秘密的，可能直接给我们 *p* 和 *q*。我们不知道
    *k* 或 φ(*n*)，但是我们可以计算出 *k*φ(*n*) = *ed* – 1。
- en: 'What can we do with this value *k*φ(*n*)? A first observation is that, according
    to *Euler’s theorem*, we know that for any number *a* co-prime with *n*, *a*^(φ(*n*))
    = 1 mod *n*. Therefore, modulo *n* we have the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能用这个值 *k*φ(*n*) 做什么？第一个观察是，根据 *欧拉定理*，我们知道对于任何与 *n* 互质的数 *a*，*a*^(φ(*n*)) =
    1 mod *n*。因此，模 *n* 下我们有如下关系：
- en: '*a*^(*kφ*(*n*)) = (*a*^(φ(*n*)))^(*k*) = 1^(*k*) = 1'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*^(*kφ*(*n*)) = (*a*^(φ(*n*)))^(*k*) = 1^(*k*) = 1'
- en: A second observation is that, because *k*φ(*n*) is an even number, we can write
    it as 2^(*s*)*t* for some numbers *s* and *t*. That is, we’ll be able to write
    *a*^(*k*φ(*n*)) = 1 mod *n* under the form *x*² = 1 mod *n* for some *x* easily
    computed from *k*φ(*n*). Such an *x* is called a *root of unity*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个观察是，由于 *k*φ(*n*) 是偶数，我们可以将其写成 2^(*s*)*t* 的形式，其中 *s* 和 *t* 是某些数值。也就是说，我们能够将
    *a*^(*k*φ(*n*)) = 1 mod *n* 写成 *x*² = 1 mod *n*，其中 *x* 可以通过 *k*φ(*n*) 轻松计算得到。这样的
    *x* 称为 *单位根*。
- en: The key observation is that *x*² = 1 mod *n* is equivalent to saying that the
    value *x*² – 1 = (*x* – 1)(*x* + 1) divides *n*. In other words, *x* – 1 or *x*
    + 1 must have a common factor with *n*, which can give us the factorization of
    *n*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 关键观察是，*x*² = 1 mod *n* 等价于说 *x*² – 1 = (*x* – 1)(*x* + 1) 能被 *n* 整除。换句话说，*x*
    – 1 或 *x* + 1 必须与 *n* 有共同因子，这可以帮助我们找到 *n* 的因式分解。
- en: '[Listing 10-7](ch10.xhtml#ch10list7) shows a Python implementation of this
    method where, in order to find the factors *p* and *q* from *n* and *d*, we use
    small, 64-bit numbers for the sake of simplicity.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表10-7](ch10.xhtml#ch10list7) 显示了此方法的Python实现，其中，为了简化，我们使用小的64位数字来从 *n* 和
    *d* 中找到因子 *p* 和 *q*。'
- en: '[PRE7]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 10-7: A python program that computes the prime factors* p *and* q
    *from the private exponent* d'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-7：一个计算私有指数* d *的质因子* p *和* q *的Python程序*'
- en: 'This program determines *k*φ(*n*) from *e* and *d* ❶ by finding the number
    *t* such that *k*φ(*n*) = 2^(*s*)*t*, for some *s* ❷. Then it looks for *a* and
    *k* such that (*a*^(*k*))² = 1 mod *n* ❸, using *t* as a starting point for *k*
    ❹. When this condition is satisfied ❺, we’ve found a solution. It then determines
    the factor *p* ❻ and verifies ❼ that the value of *pq* equals the value of *n.*
    It then prints the resulting values of *p* and *q*:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序通过找到数字 *t*，使得 *k*φ(*n*) = 2^(*s*)*t*，来确定 *k*φ(*n*)，其中 *s* ❷ 是某个值。然后它寻找 *a*
    和 *k*，使得 (*a*^(*k*))² = 1 mod *n* ❸，使用 *t* 作为 *k* 的起始点 ❹。当此条件得到满足 ❺ 时，我们就找到了一个解。接着，程序确定因子
    *p* ❻ 并验证 ❼ *pq* 的值是否等于 *n* 的值。最后，程序打印出结果 *p* 和 *q* 的值：
- en: '[PRE8]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The program correctly returns the two factors.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序正确返回两个因子。
- en: Further Reading
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: RSA deserves a book by itself. I had to omit many important and interesting
    topics, such as Bleichenbacher’s padding oracle attack on OAEP’s predecessor (the
    standard PKCS#1 v1.5), an attack similar in spirit to the padding oracle attack
    on block ciphers seen in [Chapter 4](ch04.xhtml#ch4). There’s also Wiener’s attack
    on RSA with low private exponents, and attacks using Coppersmith’s method on RSA
    with small exponents that potentially also have insecure padding.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: RSA 本身值得一本书的篇幅。许多重要且有趣的话题我不得不省略，比如Bleichenbacher对OAEP前身（标准PKCS#1 v1.5）进行的填充oracle攻击，这与[第4章](ch04.xhtml#ch4)中对分组密码的填充oracle攻击在精神上相似。此外，还有Wiener对低私有指数RSA的攻击，以及使用Coppersmith方法对具有小指数的RSA进行的攻击，这些攻击可能也存在不安全的填充。
- en: To see research results related to side-channel attacks and defenses, view the
    CHES workshop proceedings that have run since 1999 at *[http://www.chesworkshop.org/](http://www.chesworkshop.org/)*.
    One of the most useful references while writing this chapter was Boneh’s “Twenty
    Years of Attacks on the RSA Cryptosystem,” a survey that reviews and explains
    the most important attacks on RSA. For reference specifically on timing attacks,
    the paper “Remote Timing Attacks Are Practical” by Brumley and Boneh, is a must-read,
    both for its analytical and experimental contributions. To learn more about fault
    attacks, read the full version of the Bellcore attack paper “On the Importance
    of Eliminating Errors in Cryptographic Computations” by Boneh, DeMillo, and Lipton.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看与侧信道攻击和防御相关的研究结果，请查看自1999年以来举办的CHES研讨会论文集，访问 *[http://www.chesworkshop.org/](http://www.chesworkshop.org/)*。在编写本章时，最有用的参考文献之一是Boneh的“二十年RSA加密系统攻击”——一篇回顾并解释RSA最重要攻击的综述性文章。关于定时攻击的参考文献，Brumley和Boneh的论文《远程定时攻击是可行的》是必读的，因其在分析和实验方面的贡献。要了解更多关于故障攻击的内容，请阅读Boneh、DeMillo和Lipton的Bellcore攻击论文《在密码学计算中消除错误的重要性》的完整版。
- en: The best way to learn how RSA implementations work, though sometimes painful
    and frustrating, is to review the source code of widely used implementations.
    For example, see RSA and its underlying big-number arithmetic implementations
    in OpenSSL, in NSS (the library used by the Mozilla Firefox browser), in Crypto++,
    or in other popular software, and examine their implementations of arithmetic
    operations as well as their defenses against timing and fault attacks.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 学习RSA实现如何工作，尽管有时痛苦且令人沮丧，但最好的方法是查看广泛使用的实现的源代码。例如，可以查看OpenSSL中的RSA及其底层大数运算实现，查看NSS（Mozilla
    Firefox浏览器使用的库）、Crypto++或其他流行软件中的实现，检查它们的运算操作以及它们对定时攻击和故障攻击的防御措施。
