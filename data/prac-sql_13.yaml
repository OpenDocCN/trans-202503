- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Advanced Query Techniques
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 高级查询技巧
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Sometimes data analysis requires advanced SQL techniques that go beyond a table
    join or basic `SELECT` query. In this chapter, we’ll cover techniques that include
    writing a query that uses the results of other queries as inputs and reclassifying
    numerical values into categories before counting them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，数据分析需要一些超越表连接或基础 `SELECT` 查询的高级 SQL 技巧。在本章中，我们将介绍一些技巧，包括编写查询，利用其他查询的结果作为输入，并在计数之前将数值重新分类为不同的类别。
- en: For the exercises, I’ll introduce a dataset of temperatures recorded in select
    US cities, and we’ll revisit datasets you’ve created in previous chapters. The
    code for the exercises is available, along with all the book’s resources, at [https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/).
    You’ll continue to use the `analysis` database you’ve already built. Let’s get
    started.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些练习中，我将介绍一个包含美国部分城市温度数据集，并回顾你在前几章中创建的数据集。本书的练习代码及所有资源可通过 [https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/)
    获得。你将继续使用你已经建立的 `analysis` 数据库。让我们开始吧。
- en: Using Subqueries
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用子查询
- en: 'A *subquery* is a query nested inside another query. Typically, it performs
    a calculation or a logical test or generates rows to be passed into the main outer
    query. Subqueries are part of standard ANSI SQL, and the syntax is not unusual:
    we just enclose a query in parentheses. For example, we can write a subquery that
    returns multiple rows and treat those results as a table in the `FROM` clause
    of the main outer query. Or we can create a *scalar subquery* that returns a single
    value and use it as part of an *expression* to filter rows via `WHERE`, `IN`,
    and `HAVING` clauses. A *correlated subquery* is one that depends on a value or
    table name from the outer query to execute. Conversely, an *uncorrelated subquery*
    has no reference to objects in the main query.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*子查询* 是嵌套在另一个查询内部的查询。通常，它执行计算或逻辑测试，或生成行以传递给外部的主查询。子查询是标准 ANSI SQL 的一部分，语法并不特别：我们只是将查询括在括号内。例如，我们可以编写一个返回多行的子查询，并将这些结果当作
    `FROM` 子句中的表来使用。或者，我们可以创建一个 *标量子查询*，它返回一个单一值，并将其作为 *表达式* 的一部分，用于通过 `WHERE`、`IN`
    和 `HAVING` 子句过滤行。*相关子查询* 是指依赖外部查询中的某个值或表名来执行的子查询。相反，*非相关子查询* 则不引用主查询中的任何对象。'
- en: It’s easier to understand these concepts by working with data, so let’s revisit
    several datasets from earlier chapters, including the census county-level population
    estimates table `us_counties_pop_est_2019` and the business patterns table `cbp_naics_72_establishments`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过操作数据来理解这些概念会更容易，因此让我们回顾一些早期章节中的数据集，包括 `us_counties_pop_est_2019` 人口普查县级估算表和
    `cbp_naics_72_establishments` 商业模式表。
- en: Filtering with Subqueries in a WHERE Clause
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 `WHERE` 子句中过滤使用子查询
- en: 'A `WHERE` clause lets you filter query results based on criteria you provide,
    using an expression such as `WHERE quantity > 1000`. But this requires that you
    already know the value to use for comparison. What if you don’t? That’s one way
    a subquery comes in handy: it lets you write a query that generates one or more
    values to use as part of an expression in a `WHERE` clause.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE` 子句允许你根据提供的标准过滤查询结果，使用像 `WHERE quantity > 1000` 这样的表达式。但这要求你已经知道要用来比较的值。如果你不知道该怎么做呢？这时子查询就派上用场了：它让你编写一个查询，生成一个或多个值，用作
    `WHERE` 子句中的表达式的一部分。'
- en: Generating Values for a Query Expression
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为查询表达式生成值
- en: Say you wanted to write a query to show which US counties are at or above the
    90th percentile, or top 10 percent, for population. Rather than writing two separate
    queries—one to calculate the 90th percentile and another to find counties with
    populations at or higher—you can do both at once using a subquery as part of a
    `WHERE` clause, as shown in [Listing 13-1](#listing13-1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想编写一个查询，显示哪些美国县的人口位于或超过第90百分位数，或者是前10%的县。你不必编写两个独立的查询——一个计算90百分位数，另一个查找人口位于或高于这个数值的县——你可以一次性完成这两个任务，使用子查询作为
    `WHERE` 子句的一部分，如[列表 13-1](#listing13-1)所示。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 13-1: Using a subquery in a `WHERE` clause'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13-1：在 `WHERE` 子句中使用子查询
- en: 'The `WHERE` clause 1, which filters by the total population column `pop_est_2019`,
    doesn’t include a value as it normally would. Instead, after the `>=` comparison
    operators, we provide a subquery in parentheses. This subquery uses the `percentile_cont()`
    function to generate one value: the 90th percentile cutoff point in the `pop_est_2019`
    column.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE`子句1通过总人口列`pop_est_2019`进行筛选，但没有像通常那样指定一个值。相反，在`>=`比较操作符之后，我们提供了一个括号中的子查询。这个子查询使用`percentile_cont()`函数生成一个值：`pop_est_2019`列中的第90百分位数临界点。'
- en: This is an example of an uncorrelated subquery. It does not depend on any values
    in the outer query, and it will be executed just once to generate the requested
    value. If you run the subquery portion only, by highlighting it in pgAdmin, it
    will execute, and you should see a result of `213707.3`. But you won’t see that
    number when you run the entire query in [Listing 13-1](#listing13-1), because
    the subquery result is passed directly to the outer query’s `WHERE` clause.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个无关子查询的示例。它不依赖于外部查询中的任何值，并且只会执行一次以生成所请求的值。如果你只运行子查询部分，通过在pgAdmin中高亮它，它将执行，你应该会看到`213707.3`的结果。但在运行整个查询[示例
    13-1](#listing13-1)时，你看不到这个数字，因为子查询的结果会直接传递到外部查询的`WHERE`子句中。
- en: The entire query should return 315 rows, or about 10 percent of the 3,142 rows
    in `us_counties_pop_est_2019`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 整个查询应该返回315行，约占`us_counties_pop_est_2019`表中3,142行的10%。
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The result includes all counties with a population greater than or equal to
    `213707.3`, the value the subquery generated.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 结果包括所有人口大于或等于`213707.3`的县，这是子查询生成的值。
- en: Using a Subquery to Identify Rows to Delete
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用子查询来识别要删除的行
- en: We can use the same subquery in a `DELETE` statement to specify what to remove
    from a table. In [Listing 13-2](#listing13-2), we make a copy of the census table
    using the method you learned in Chapter 10 and then delete everything from that
    backup except the 315 counties in the top 10 percent of population.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`DELETE`语句中使用相同的子查询来指定从表中删除的内容。在[示例 13-2](#listing13-2)中，我们使用你在第10章学到的方法创建了一个人口普查表的副本，然后从该备份中删除除前10%人口的315个县以外的所有数据。
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 13-2: Using a subquery in a `WHERE` clause with `DELETE`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-2：在`WHERE`子句中使用子查询与`DELETE`
- en: Run the code in [Listing 13-2](#listing13-2), and then execute `SELECT count(*)
    FROM us_counties_2019_top10;` to count the remaining rows. The result should be
    315 rows, which is the original 3,142 minus the 2,827 below the value identified
    by the subquery.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 执行[示例 13-2](#listing13-2)中的代码，然后执行`SELECT count(*) FROM us_counties_2019_top10;`来计算剩余的行数。结果应该是315行，即原始的3,142行减去子查询所识别的2,827行。
- en: Creating Derived Tables with Subqueries
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用子查询创建派生表
- en: If your subquery returns rows and columns, you can place it in a `FROM` clause
    to create a new table known as a *derived table* that you can query or join with
    other tables, just as you would a regular table. It’s another example of an uncorrelated
    subquery.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的子查询返回行和列，你可以将其放入`FROM`子句中，创建一个新的表，称为*派生表*，你可以像查询常规表一样查询或与其他表进行连接。这是另一个无关子查询的示例。
- en: Let’s look at a simple example. In Chapter 6, you learned the difference between
    average and median. A median often better indicates a dataset’s central value
    because a few very large or small values (or outliers) can skew an average. For
    that reason, I often compare the two. If they’re close, the data more likely falls
    in a *normal distribution* (the familiar bell curve), and the average is a good
    representation of the central value. If the average and median are far apart,
    some outliers might be having an effect or the distribution is skewed, not normal.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子。在第6章中，你学习了平均数和中位数的区别。中位数通常更能准确表示数据集的中心值，因为少数几个极大或极小的值（或异常值）会偏移平均值。因此，我常常比较二者。如果它们接近，数据更可能符合*正态分布*（熟悉的钟形曲线），此时平均值可以很好地代表中心值。如果平均值和中位数差距很大，则可能存在异常值的影响，或者数据分布是偏斜的，非正态的。
- en: Finding the average and median population of US counties as well as the difference
    between them is a two-step process. We need to calculate the average and the median
    and then subtract the two. We can do both operations in one fell swoop with a
    subquery in the `FROM` clause, as shown in [Listing 13-3](#listing13-3).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 查找美国县的平均人口和中位数人口以及二者之间的差异是一个两步过程。我们需要计算平均值和中位数，然后将二者相减。我们可以通过在`FROM`子句中使用子查询一次性完成这两个操作，如[示例
    13-3](#listing13-3)所示。
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 13-3: Subquery as a derived table in a `FROM` clause'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-3：作为派生表的子查询用于`FROM`子句
- en: The subquery 1 that produces a derived table is straightforward. We use the
    `avg()` and `percentile_cont()` functions to find the average and median of the
    census table’s `pop_est_2019` column and name each column with an alias. Then
    we name the derived table `calcs` 2 so we can reference it in the main query.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 产生派生表的子查询1很直接。我们使用`avg()`和`percentile_cont()`函数来计算人口普查表中`pop_est_2019`列的平均值和中位数，并为每一列命名一个别名。然后，我们将派生表命名为`calcs`
    2，这样我们就可以在主查询中引用它。
- en: 'In the main query, we subtract the `median` from the `average`, both of which
    are returned by the subquery. The result is rounded and labeled with the alias
    `median_average_diff`. Run the query, and the result should be the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在主查询中，我们将子查询返回的`median`与`average`相减。结果会被四舍五入并标记为别名`median_average_diff`。执行查询后，结果应该如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The difference between the median and average, 78,742, is nearly three times
    the size of the median. That indicates we have some high-population counties inflating
    the average.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 中位数和平均数之间的差异78,742几乎是中位数的三倍。这表明我们有一些高人口的县城拉高了平均数。
- en: Joining Derived Tables
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接派生表
- en: Joining multiple derived tables lets you perform several preprocessing steps
    before final calculations in a main query. For example, in Chapter 11, we calculated
    the rate of tourism-related businesses per 1,000 population in each county. Let’s
    say we want to do the same at the state level. Before we can calculate that rate,
    we need to know the number of tourism businesses in each state and the population
    of each state. [Listing 13-4](#listing13-4) shows how to write subqueries for
    both tasks and join them to calculate the overall rate.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 连接多个派生表可以让你在主查询的最终计算之前执行多个预处理步骤。例如，在第11章中，我们计算了每千人中与旅游相关的企业数量。假设我们想在州一级进行相同的计算。在我们计算这个比率之前，我们需要知道每个州的旅游企业数量和每个州的人口。
    [示例 13-4](#listing13-4)展示了如何为这两个任务编写子查询，并将它们连接起来计算整体比率。
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 13-4: Joining two derived tables'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-4：连接两个派生表
- en: You learned how to calculate rates in Chapter 11, so the math and syntax in
    the outer query for finding `estabs_per_thousand` 1 should be familiar. We divide
    the number of establishments by the population and then multiply that quotient
    by a thousand. For the inputs, we use the values generated from two derived tables.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第11章中学过如何计算比率，所以外部查询中寻找`estabs_per_thousand` 1的数学运算和语法应该是熟悉的。我们将企业数量除以人口，然后将商数乘以千。对于输入，我们使用从两个派生表生成的值。
- en: The first 2 finds the number of establishments in each state using the `sum()`
    aggregate function. We give this derived table the alias `est` for reference in
    the main part of the query. The second 3 finds the 2018 estimated population by
    state by using `sum()` on the `pop_est_2018` column. We alias this derived table
    as `census`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个2使用`sum()`聚合函数找出每个州的企业数量。我们将这个派生表命名为`est`，以便在查询的主部分引用。第二个3使用`sum()`计算每个州的2018年估算人口，基于`pop_est_2018`列。我们将这个派生表命名为`census`。
- en: 'Next, we join the derived tables 4 by linking the `st` column in `est` to the
    `state_name` column in `census`. We then list the results in descending order
    based on the rate. Here’s a sample of the 51 rows showing the highest and lowest
    rates:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过将`est`中的`st`列与`census`中的`state_name`列连接起来，连接这两个派生表4。然后，我们根据比率按降序列出结果。以下是51行中的一个样本，展示了最高和最低的比率：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At the top is Washington, DC, unsurprising given the tourist activity generated
    by the museums, monuments, and other attractions in the nation’s capital. Montana
    may seem like a surprise in second place, but it’s a low-population state with
    major tourist destinations including Glacier and Yellowstone national parks. Mississippi
    and Kentucky are among those states with the fewest tourism-related businesses
    per 1,000 population.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 排在第一位的是华盛顿特区，这并不令人意外，因为国会大厦、博物馆、纪念碑以及其他旅游景点产生了大量游客活动。蒙大拿州排第二似乎令人惊讶，但它是一个人口较少的州，拥有主要的旅游目的地，包括冰川国家公园和黄石国家公园。密西西比州和肯塔基州是每千人中旅游相关企业最少的州。
- en: Generating Columns with Subqueries
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用子查询生成列
- en: You can also place a subquery in the column list after `SELECT` to generate
    a value for that column in the query result. The subquery must generate only a
    single row. For example, the query in [Listing 13-5](#listing13-5) selects the
    geography and population information from `us_counties_pop_est_2019` and then
    adds an uncorrelated subquery to add the median of all counties to each row in
    the new column `us_median`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在`SELECT`后面的列列表中放置子查询，以生成查询结果中该列的值。子查询必须只生成一行数据。例如，[清单13-5](#listing13-5)中的查询从`us_counties_pop_est_2019`中选择地理和人口信息，然后添加一个无关的子查询，将所有县的中位数添加到新列`us_median`的每一行中。
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 13-5: Adding a subquery to a column list'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 清单13-5：向列列表中添加子查询
- en: 'The first rows of the result set should look like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 结果集的前几行应该如下所示：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: On its own, that repeating `us_median` value isn’t very helpful. It would be
    more interesting and useful to generate values that indicate how much each county’s
    population deviates from the median value. Let’s look at how we can use the same
    subquery technique to do that. [Listing 13-6](#listing13-6) builds on [Listing
    13-5](#listing13-5) by substituting a subquery after `SELECT` that calculates
    the difference between the population and the median for each county.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，重复的`us_median`值并不是特别有用。更有趣和实用的是生成一些值，表示每个县的人口与中位数值的偏差。让我们看看如何使用相同的子查询技巧来实现这一点。[清单13-6](#listing13-6)在[清单13-5](#listing13-5)的基础上，替换了一个子查询，计算每个县人口与中位数之间的差异。
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 13-6: Using a subquery in a calculation'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 清单13-6：在计算中使用子查询
- en: The subquery 1 is now part of a calculation that subtracts the subquery’s result
    from `pop_est_2019`, the total population, giving the column an alias of `diff_from_median`.
    To make this query even more useful, we can filter results to show counties whose
    population is close to the median. To do this, we repeat the calculation with
    the subquery in the `WHERE` clause 2 and filter results using the `BETWEEN -1000
    AND 1000` expression.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询1现在成为一个计算的一部分，该计算将子查询的结果从`pop_est_2019`（总人口）中减去，为列指定了别名`diff_from_median`。为了使这个查询更加有用，我们可以过滤结果，显示人口接近中位数的县。为此，我们在`WHERE`子句2中重复子查询计算，并使用`BETWEEN
    -1000 AND 1000`表达式过滤结果。
- en: 'The outcome should reveal 78 counties. Here are the first five rows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该会显示78个县。以下是前五行：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Bear in mind that subqueries can add to overall query execution time. In [Listing
    13-6](#listing13-6), I removed the subquery from [Listing 13-5](#listing13-5)
    that displays the column `us_median` to avoid repeating the subquery a third time.
    With our data set, the impact is minimal; if we were working with millions of
    rows, winnowing some unneeded subqueries might provide a significant speed boost.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，子查询可能会增加整体查询执行时间。在[清单13-6](#listing13-6)中，我从[清单13-5](#listing13-5)中移除了显示列`us_median`的子查询，以避免第三次重复子查询。对于我们的数据集，影响是最小的；如果我们处理的是数百万行数据，剔除一些不必要的子查询可能会显著提高速度。
- en: Understanding Subquery Expressions
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解子查询表达式
- en: You can also use subqueries to filter rows by evaluating whether a condition
    evaluates as `true` or `false`. For this, we can use *subquery expressions*, which
    are a combination of a keyword with a subquery and are generally used in `WHERE`
    clauses to filter rows based on the existence of values in another table.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用子查询通过评估条件是否为`true`或`false`来过滤行。为此，我们可以使用*子查询表达式*，这是一种将关键字与子查询结合的表达式，通常用于`WHERE`子句中，根据另一个表中是否存在某些值来过滤行。
- en: 'The PostgreSQL documentation at [https://www.postgresql.org/docs/current/functions-subquery.html](https://www.postgresql.org/docs/current/functions-subquery.html)
    lists available subquery expressions, but here we’ll examine the syntax for two
    that tend to be used most often: `IN` and `EXISTS`. To prep, run the code in [Listing
    13-7](#listing13-7) to create a small table called `retirees` that we’ll query
    along with the `employees` table you built in Chapter 7. We’ll imagine that we’ve
    received this data from a vendor listing people who’ve applied for retirement
    benefits.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL文档在[https://www.postgresql.org/docs/current/functions-subquery.html](https://www.postgresql.org/docs/current/functions-subquery.html)中列出了可用的子查询表达式，但在这里我们将检查两种最常用的子查询语法：`IN`和`EXISTS`。在此之前，运行[清单13-7](#listing13-7)中的代码，创建一个名为`retirees`的小表，我们将与第7章中构建的`employees`表一起查询。我们假设已经从供应商处收到数据，列出了申请退休福利的人。
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 13-7: Creating and filling a `retirees` table'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 清单13-7：创建并填充`retirees`表
- en: Now let’s use this table in some subquery expressions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在一些子查询表达式中使用这个表。
- en: Generating Values for the IN Operator
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为 `IN` 运算符生成值
- en: The subquery expression `IN (``subquery``)` works like the `IN` operator example
    in Chapter 3 except we employ a subquery to provide the list of values to check
    against rather than manually entering one. In [Listing 13-8](#listing13-8), we
    use an uncorrelated subquery, which will be executed one time, to generate `id`
    values from the `retirees` table. The values it returns become the list for the
    `IN` operator in the `WHERE` clause. This lets us find employees who are also
    present in the table of retirees.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询表达式 `IN (``subquery``)` 的工作方式与第 3 章中 `IN` 运算符的例子类似，只不过我们使用一个子查询来提供检查的值列表，而不是手动输入一个。在[清单
    13-8](#listing13-8)中，我们使用一个不相关的子查询，它将执行一次，生成来自 `retirees` 表的 `id` 值。它返回的值成为 `WHERE`
    子句中 `IN` 运算符的列表。这使我们能够找到也出现在退休人员表中的员工。
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 13-8: Generating values for the `IN` operator'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 13-8：生成 `IN` 运算符的值
- en: 'Run the query, and the output shows the two people in `employees` whose `emp_id`
    have a matching `id` in the `retirees` table:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 运行查询时，输出将显示 `employees` 中的两个人，他们的 `emp_id` 在 `retirees` 表中有匹配的 `id`：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Checking Whether Values Exist
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查值是否存在
- en: The subquery expression `EXISTS (``subquery``)` returns a value of `true` if
    the subquery in parentheses returns at least one row. If it returns no rows, `EXISTS`
    evaluates to `false`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询表达式 `EXISTS (``subquery``)` 如果括号中的子查询返回至少一行，则返回 `true`，如果没有返回任何行，则 `EXISTS`
    评估为 `false`。
- en: The `EXISTS` subquery expression in [Listing 13-9](#listing13-9) shows an example
    of a correlated subquery—it includes an expression in its `WHERE` clause that
    requires data from the outer query. Also, because the subquery is correlated,
    it will execute once for each row returned by the outer query, each time checking
    whether there’s an `id` in `retirees` that matches `emp_id` in `employees`. If
    there is a match, the `EXISTS` expression returns `true`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 13-9](#listing13-9)中的 `EXISTS` 子查询表达式展示了一个关联子查询的例子——它在 `WHERE` 子句中包含一个需要外部查询数据的表达式。此外，由于子查询是关联的，它会对外部查询返回的每一行执行一次，每次检查
    `retirees` 中是否有一个与 `employees` 中的 `emp_id` 匹配的 `id`。如果有匹配，`EXISTS` 表达式返回 `true`。
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 13-9: Using a correlated subquery with `WHERE EXISTS`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 13-9：使用 `WHERE EXISTS` 的关联子查询
- en: When you run the code, it should return the same result as it did in [Listing
    13-8](#listing13-8). Using this approach is particularly helpful if you need to
    join on more than one column, which you can’t do with the `IN` expression. You
    also can add the `NOT` keyword with `EXISTS` to perform the opposite function
    and find rows in the employees table with no corresponding record in `retirees`,
    as in [Listing 13-10](#listing13-10).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行代码时，它应该返回与[清单 13-8](#listing13-8)中相同的结果。使用这种方法特别有帮助，特别是当你需要连接多个列时，这是 `IN`
    表达式无法做到的。你还可以在 `EXISTS` 中添加 `NOT` 关键字来执行相反的操作，查找员工表中没有与 `retirees` 表中的记录相对应的行，如[清单
    13-10](#listing13-10)所示。
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 13-10: Using a correlated subquery with `WHERE NOT EXISTS`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 13-10：使用 `WHERE NOT EXISTS` 的关联子查询
- en: 'That should produce these results:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生以下结果：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The technique of using `NOT` with `EXISTS` is helpful for finding missing values
    or assessing whether a dataset is complete.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `NOT` 和 `EXISTS` 的技巧对于查找缺失值或评估数据集是否完整非常有用。
- en: Using Subqueries with LATERAL
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `LATERAL` 的子查询
- en: Placing the keyword `LATERAL` before subqueries in a `FROM` clause adds several
    bits of functionality that help simplify otherwise complicated queries.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `FROM` 子句中放置 `LATERAL` 关键字在子查询之前，增加了几个功能，这有助于简化本来复杂的查询。
- en: LATERAL with FROM
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 `LATERAL` 与 `FROM`
- en: First, a subquery preceded by `LATERAL` can reference tables and other subqueries
    that appear before it in the `FROM` clause, which can reduce redundant code by
    making it easy to reuse calculations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，前面加上 `LATERAL` 的子查询可以引用在 `FROM` 子句中出现在它之前的表和其他子查询，这可以通过使计算易于重用来减少冗余代码。
- en: '[Listing 13-11](#listing13-11) calculates the change in county population from
    2018 to 2019 two ways: raw change in numbers and percent change.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-11](#listing13-11)通过两种方式计算从 2018 年到 2019 年县人口的变化：原始变化数和百分比变化。'
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 13-11: Using `LATERAL` subqueries in the `FROM` clause'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 13-11：在 `FROM` 子句中使用 `LATERAL` 子查询
- en: In the `FROM` clause, after naming the `us_counties_pop_est_2019` table, we
    add the first `LATERAL` subquery 1. In parentheses, we place a query that subtracts
    the 2018 population estimate from the 2019 estimate and alias the result as `raw_chg`.
    Because a `LATERAL` subquery can reference a table listed before it in the `FROM`
    clause without needing to specify its name, we can omit the `us_counties_pop_est_2019`
    table from the subquery. Subqueries in `FROM` must have an alias, so we label
    this one `rc`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FROM`子句中，在指定`us_counties_pop_est_2019`表后，我们添加了第一个`LATERAL`子查询1。在括号内，我们编写一个查询，计算2018年人口估算与2019年估算的差值，并将结果别名为`raw_chg`。由于`LATERAL`子查询可以引用`FROM`子句中之前列出的表，而无需指定其名称，因此我们可以省略`us_counties_pop_est_2019`表在子查询中的引用。`FROM`中的子查询必须有别名，因此我们将其标记为`rc`。
- en: The second `LATERAL` subquery 2 calculates the percent change in population
    from 2018 to 2019\. To find percent change, we must know the raw change. Rather
    than re-calculate it, we can reference the `raw_chg` value from the previous subquery.
    That helps make our code shorter and easier to read.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`LATERAL`子查询2计算2018年到2019年人口的百分比变化。为了找到百分比变化，我们必须知道原始变化量。我们可以通过引用前一个子查询中的`raw_chg`值来避免重新计算它。这有助于使我们的代码更简洁、更易读。
- en: 'The query results should look like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 查询结果应如下所示：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: LATERAL with JOIN
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`LATERAL`与`JOIN`'
- en: 'Combining `LATERAL` with `JOIN` creates functionality similar to a *for loop*
    in a programming language: for each row generated by the query in front of the
    `LATERAL` join, a subquery or function after the `LATERAL` join will be evaluated
    once.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将`LATERAL`与`JOIN`结合使用，创建了类似于编程语言中*for循环*的功能：对于`LATERAL`连接前由查询生成的每一行，在`LATERAL`连接之后的子查询或函数将被评估一次。
- en: We’ll reuse the `teachers` table from Chapter 2 and create a new table to record
    each time a teacher swipes a badge to unlock a lab door. Our task is to find the
    two most recent times a teacher accessed a lab. [Listing 13-12](#listing13-12)
    shows the code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新使用第2章中的`teachers`表，并创建一个新表记录每次教师刷卡解锁实验室门的时间。我们的任务是找到教师访问实验室的两个最近时间。[Listing
    13-12](#listing13-12)展示了代码。
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 13-12: Using a subquery with a `LATERAL` join'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 13-12: 使用子查询与`LATERAL`连接'
- en: First, we add a primary key 1 to the `teachers` table using `ALTER TABLE` (we
    didn’t place a constraint on this table in Chapter 2 because we were just covering
    the basics about creating tables). Next, we make a simple `teachers_lab_access`
    table 2 with columns to record the lab name and access timestamp. The table has
    a surrogate primary key `access_id` and a foreign key `teacher_id` that references
    `id` in `teachers`. Finally, we add six rows to the table using an `INSERT` 3
    statement.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`ALTER TABLE`为`teachers`表添加主键1（在第2章中我们没有在此表上设置约束，因为我们只是介绍了创建表的基础知识）。接下来，我们创建一个简单的`teachers_lab_access`表2，包含记录实验室名称和访问时间戳的列。该表有一个替代主键`access_id`，并且外键`teacher_id`引用了`teachers`表中的`id`。最后，我们使用`INSERT`3语句向表中添加了六行数据。
- en: Now we’re ready to query the data. In our `SELECT` statement, we join `teachers`
    to a subquery using `LEFT JOIN`. We add the `LATERAL` 4 keyword, which means for
    each row returned from `teachers`, the subquery will execute, returning the two
    most recent labs accessed by that particular teacher and the times they were accessed.
    Using `LEFT JOIN` will return all rows from `teachers` regardless of whether the
    subquery finds a matching teacher in `teachers_lab_access`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备查询数据。在我们的`SELECT`语句中，我们通过`LEFT JOIN`将`teachers`连接到一个子查询。我们添加了`LATERAL`4关键字，这意味着对于从`teachers`返回的每一行，子查询将执行，返回该教师访问的两个最近的实验室及其访问时间。使用`LEFT
    JOIN`将返回所有来自`teachers`的行，无论子查询是否找到匹配的教师在`teachers_lab_access`中。
- en: In the `WHERE` 5 clause, the subquery references the outer query using the foreign
    key of `teacher_lab_access`. This `LATERAL` join syntax requires that the subquery
    have an alias 6, which here is `a`, and the value `true` in the `ON` portion 7
    of the `JOIN` clause. In this case, `true` lets us create the join without naming
    specific columns to join upon.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WHERE`子句中，子查询通过外键`teacher_lab_access`引用外部查询。此`LATERAL`连接语法要求子查询具有别名6，这里为`a`，并且在`JOIN`子句的`ON`部分需要设置`true`的值7。在这种情况下，`true`使我们能够创建连接，而不需要指定连接的特定列。
- en: 'Run the query, and the results should look like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 执行查询后，结果应如下所示：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The two teachers with IDs in the access table have their two most recent lab
    access times shown. Teachers who didn’t access a lab display `NULL` values; if
    we want to remove those from the results, we could substitute `INNER JOIN` (or
    just `JOIN`) for `LEFT JOIN`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 访问表中两个教师的 ID 显示了他们最近的两次实验室访问时间。没有访问实验室的教师显示 `NULL` 值；如果我们希望从结果中删除这些教师，可以用 `INNER
    JOIN`（或直接使用 `JOIN`）代替 `LEFT JOIN`。
- en: Next, let’s explore another syntax for working with subqueries.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索另一种处理子查询的语法。
- en: Using Common Table Expressions
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用公用表表达式
- en: The *common table expression* *(CTE)*, a relatively recent addition to standard
    SQL, allows you to use one or more `SELECT` queries to predefine temporary tables
    that you can reference as often as needed in your main query. CTEs are informally
    called `WITH` queries because you define them using a `WITH ... AS` statement.
    The following examples show some advantages of using them, including cleaner code
    and less redundancy.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*公用表表达式*（*CTE*）是标准 SQL 中的一个相对较新的功能，它允许你使用一个或多个 `SELECT` 查询预定义临时表，并在主查询中根据需要反复引用这些临时表。CTE
    非正式地称为 `WITH` 查询，因为它们是通过 `WITH ... AS` 语句定义的。以下示例展示了使用 CTE 的一些优势，包括代码更简洁、冗余更少。'
- en: '[Listing 13-13](#listing13-13) shows a simple CTE based on our census estimates
    data. The code determines how many counties in each state have 100,000 people
    or more. Let’s walk through the example.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13-13](#listing13-13) 显示了一个基于我们普查估算数据的简单公用表表达式（CTE）。该代码确定了每个州中有多少县的人口达到
    100,000 或以上。我们来逐步分析这个例子。'
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 13-13: Using a simple CTE to count large counties'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13-13：使用简单的 CTE 计算大县
- en: The `WITH ... AS` statement 1 defines the temporary table `large_counties`.
    After `WITH`, we name the table and list its column names in parentheses. Unlike
    column definitions in a `CREATE TABLE` statement, we don’t need to provide data
    types, because the temporary table inherits those from the subquery 2, which is
    enclosed in parentheses after `AS`. The subquery must return the same number of
    columns as defined in the temporary table, but the column names don’t need to
    match. The column list is optional if you’re not renaming columns; I’ve included
    it here so you can see the syntax.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`WITH ... AS` 语句 1 定义了临时表 `large_counties`。在 `WITH` 后，我们命名表并在括号中列出其列名。与 `CREATE
    TABLE` 语句中的列定义不同，我们不需要提供数据类型，因为临时表继承了来自子查询 2 的数据类型，子查询用括号括起来并位于 `AS` 后面。子查询必须返回与临时表中定义的列数相同的列，但列名不需要匹配。如果不重新命名列，则列列表是可选的；这里我列出了它以便你看到语法。'
- en: 'The main query 3 counts and groups the rows in `large_counties` by `state_name`
    and then orders by the count in descending order. The top six rows of the results
    should look like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 主查询 3 按 `state_name` 对 `large_counties` 中的行进行计数和分组，然后按降序排列计数。结果的前六行应该是这样的：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Texas, Florida, and California are among the states that had the most counties
    with a 2019 population of 100,000 or more.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 德克萨斯州、佛罗里达州和加利福尼亚州是人口在 100,000 以上的县最多的州之一。
- en: '[Listing 13-14](#listing13-14) uses a CTE to rewrite the join of derived tables
    in [Listing 13-4](#listing13-4) (finding the rate of tourism-related businesses
    per 1,000 population in each state) into a more readable format.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13-14](#listing13-14) 使用 CTE 将 [列表 13-4](#listing13-4) 中派生表的连接（查找每个州每千人中的旅游相关企业比率）改写成更易读的格式。'
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 13-14: Using CTEs in a table join'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13-14：在表连接中使用 CTE
- en: Following the `WITH` keyword, we define two tables using subqueries. The first
    subquery, `counties` 1, returns the 2018 population of each state. The second,
    `establishments` 2, returns the number of tourism-related businesses per state.
    With those tables defined, we join them 3 on the `st` column in each table and
    calculate the rate per thousand. The results are identical to the joined derived
    tables in [Listing 13-4](#listing13-4), but [Listing 13-14](#listing13-14) is
    easier to comprehend.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `WITH` 关键字之后，我们使用子查询定义了两个表。第一个子查询 `counties` 1 返回每个州的 2018 年人口。第二个子查询 `establishments`
    2 返回每个州的旅游相关企业数量。定义了这些表之后，我们通过每个表中的 `st` 列将它们连接 3，并计算每千人的比率。结果与 [列表 13-4](#listing13-4)
    中连接的派生表相同，但 [列表 13-14](#listing13-14) 更容易理解。
- en: As another example, you can use a CTE to simplify queries that have redundant
    code. For example, in [Listing 13-6](#listing13-6), we used a subquery with the
    `percentile_cont()` function in two locations to find median county population.
    In [Listing 13-15](#listing13-15), we can write that subquery just once as a CTE.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，你可以使用CTE简化那些包含冗余代码的查询。例如，在[示例 13-6](#listing13-6)中，我们在两个位置使用了带有`percentile_cont()`函数的子查询来查找中位数县人口。在[示例
    13-15](#listing13-15)中，我们可以将这个子查询作为CTE只写一次。
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 13-15: Using CTEs to minimize redundant code'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-15：使用CTE来减少冗余代码
- en: After the `WITH` keyword, we define `us_median` 1 as the result of the same
    subquery used in [Listing 13-6](#listing13-6), which finds the median population
    using `percentile_cont()`. Then we reference the `us_median_pop` column on its
    own 2, as part of a calculated column 3, and in a `WHERE` clause 5. To make the
    value available to every row in the `us_counties_pop_est_2019` table during `SELECT`,
    we use the `CROSS JOIN` 4 you learned in Chapter 7.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WITH`关键字之后，我们定义了`us_median` 1，作为[示例 13-6](#listing13-6)中相同子查询的结果，该子查询使用`percentile_cont()`查找中位数人口。然后，我们单独引用`us_median_pop`列
    2，作为计算列 3 的一部分，并在`WHERE`子句 5 中使用它。为了在`SELECT`过程中将该值提供给`us_counties_pop_est_2019`表中的每一行，我们使用了第7章中学到的`CROSS
    JOIN` 4。
- en: This query provides identical results to those in [Listing 13-6](#listing13-6),
    but we had to write the subquery that finds the median only once. Another bonus
    is that you can more easily revise the query. For example, to find counties whose
    population is close to the 90th percentile, you need to substitute `.9` for `.5`
    as input to `percentile_cont()` in only one place.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询返回的结果与[示例 13-6](#listing13-6)中的结果相同，但我们只需要写一次查找中位数的子查询。另一个优点是，你可以更容易地修改查询。例如，要查找人口接近90百分位的县，只需要在`percentile_cont()`的输入中将`.5`替换为`.9`，并且只需在一个地方进行修改。
- en: Readable code, less redundancy, and easier modifications are often-cited reasons
    for using CTEs. Another, beyond the scope of this book, is the ability to add
    a `RECURSIVE` keyword that lets a CTE loop through query results within the CTE
    itself—a task useful when dealing with data organized in a hierarchy. An example
    is a company’s personnel listing, where you might want to find all the people
    who report to a particular executive. The recursive CTE will start with the executive
    and then loop down through rows finding her direct reports and then the people
    who report to those people. You can learn more about recursive query syntax via
    the PostgreSQL documentation at [https://www.postgresql.org/docs/current/queries-with.html](https://www.postgresql.org/docs/current/queries-with.html).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性强的代码、更少的冗余和更容易的修改通常是使用CTE的理由。另一个超出本书范围的理由是能够添加`RECURSIVE`关键字，使CTE可以在CTE内部循环查询结果——当处理按层次组织的数据时，这个功能特别有用。一个例子是公司的人员列表，可能你想找出所有向某位高管汇报的人员。递归CTE会从该高管开始，然后向下循环遍历各行，找到她的直接下属，再找到这些下属的下属。你可以通过PostgreSQL文档了解更多关于递归查询语法的信息，网址是[https://www.postgresql.org/docs/current/queries-with.html](https://www.postgresql.org/docs/current/queries-with.html)。
- en: Performing Cross Tabulations
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行交叉表
- en: '*Cross tabulations* provide a simple way to summarize and compare variables
    by displaying them in a table layout, or matrix. Rows in the matrix represent
    one variable, columns represent another variable, and each cell where a row and
    column intersect holds a value, such as a count or percentage.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*交叉表*提供了一种简单的方法，通过将变量以表格布局或矩阵的形式展示，从而总结和比较它们。矩阵中的行代表一个变量，列代表另一个变量，而每个行列交点处的单元格则包含一个值，例如计数或百分比。'
- en: 'You’ll often see cross tabulations, also called *pivot tables* or *crosstabs*,
    used to report summaries of survey results or to compare pairs of variables. A
    frequent example happens during elections when candidates’ votes are tallied by
    geography:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会看到交叉表格，也叫做*透视表*或*交叉表*，它们用于报告调查结果的汇总或比较成对的变量。一个常见的例子发生在选举期间，当候选人的选票按照地理位置进行统计时：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this case, the candidates’ names are one variable, the wards (or city districts)
    are another variable, and the cells at the intersection of the two hold the vote
    totals for that candidate in that ward. Let’s look at how to generate cross tabulations.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，候选人的名字是一个变量，选区（或城市区）是另一个变量，而交点处的单元格则保存该候选人在该选区的得票总数。让我们看看如何生成交叉表格。
- en: Installing the crosstab() Function
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装crosstab()函数
- en: Standard ANSI SQL doesn’t have a crosstab function, but PostgreSQL does as part
    of a *module* you can install easily. Modules are PostgreSQL extras that aren’t
    part of the core application; they include functions related to security, text
    search, and more. You can find a list of PostgreSQL modules at [https://www.postgresql.org/docs/current/contrib.html](https://www.postgresql.org/docs/current/contrib.html).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 标准 ANSI SQL 没有交叉表函数，但 PostgreSQL 作为一个你可以轻松安装的 *模块* 提供了此功能。模块是 PostgreSQL 的附加功能，不是核心应用程序的一部分；它们包括与安全性、文本搜索等相关的函数。你可以在
    [https://www.postgresql.org/docs/current/contrib.html](https://www.postgresql.org/docs/current/contrib.html)
    查找 PostgreSQL 模块的列表。
- en: 'PostgreSQL’s `crosstab()` function is part of the `tablefunc` module. To install
    `tablefunc`, execute this command in pgAdmin:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 的 `crosstab()` 函数是 `tablefunc` 模块的一部分。要安装 `tablefunc`，请在 pgAdmin
    中执行以下命令：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: PostgreSQL should return the message `CREATE EXTENSION`. (If you’re working
    with another database management system, check its documentation for a similar
    functionality. For example, Microsoft SQL Server has the `PIVOT` command.)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 应该返回消息 `CREATE EXTENSION`。（如果你使用的是其他数据库管理系统，请查阅其文档以获取类似功能。例如，Microsoft
    SQL Server 有 `PIVOT` 命令。）
- en: Next, we’ll create a basic crosstab so you can learn the syntax, and then we’ll
    handle a more complex case.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个基本的交叉表，以便你可以学习语法，然后我们将处理一个更复杂的情况。
- en: Tabulating Survey Results
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 汇总调查结果
- en: Let’s say your company needs a fun employee activity so you coordinate an ice
    cream social at each of your three offices. The trouble is that people are particular
    about ice cream flavors. To choose flavors people will like in each office, you
    decide to conduct a survey.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的公司需要一个有趣的员工活动，因此你协调了在三个办公室举办的冰淇淋聚会。问题是，人们对冰淇淋口味很挑剔。为了选择每个办公室人们喜欢的口味，你决定进行一项调查。
- en: The CSV file *ice_cream_survey.csv* contains 200 responses to your survey. You
    can download this file, along with all the book’s resources, at [https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/).
    Each row includes a `response_id`, `office`, and `flavor`. You’ll need to count
    how many people chose each flavor at each office and share the results in a readable
    way.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: CSV 文件 *ice_cream_survey.csv* 包含了对你调查的 200 个回应。你可以在 [https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/)
    下载此文件以及本书的所有资源。每一行包括一个 `response_id`、`office` 和 `flavor`。你需要计算每个办公室每种口味的选择人数，并以可读的方式共享结果。
- en: In your `analysis` database, use the code in [Listing 13-16](#listing13-16)
    to create a table and load the data. Make sure you change the file path to the
    location on your computer where you saved the CSV file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `analysis` 数据库中，使用 [示例 13-16](#listing13-16) 中的代码创建表并加载数据。确保更改文件路径为你在计算机上保存
    CSV 文件的位置。
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 13-16: Creating and filling the `ice_cream_survey` table'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-16：创建并填充 `ice_cream_survey` 表
- en: 'If you want to inspect the data, run the following to view the first five rows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想检查数据，运行以下命令查看前五行：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The data should look like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 数据应该像这样：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It looks like chocolate is in the lead! But let’s confirm this choice by using
    the code in [Listing 13-17](#listing13-17) to generate a crosstab.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来巧克力口味领先！但让我们通过使用 [示例 13-17](#listing13-17) 中的代码生成交叉表来确认这一选择。
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 13-17: Generating the ice cream survey crosstab'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-17：生成冰淇淋调查交叉表
- en: The query begins with a `SELECT *` statement that selects everything from the
    contents of the `crosstab()` function 1. We supply two queries as parameters to
    the `crosstab()` function; note that because these queries are parameters, we
    place them inside single quotes. The first query generates the data for the crosstab
    and has three required columns. The first column, `office` 2, supplies the row
    names for the crosstab. The second column, `flavor` 3, supplies the category (or
    column) name to be associated with the value provided in the third column. Those
    values will display in each cell where a row and a column intersect in the table.
    In this case, we want the intersecting cells to show a `count()` 4 of each flavor
    selected at each office. This first query on its own creates a simple aggregated
    list.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 查询以 `SELECT *` 语句开始，该语句从 `crosstab()` 函数的内容中选择所有内容。我们将两个查询作为参数传递给 `crosstab()`
    函数；请注意，由于这些查询是参数，我们将它们放在单引号内。第一个查询生成交叉表的数据，并包含三个必需的列。第一列，`office`，提供交叉表的行名称。第二列，`flavor`，提供与第三列中提供的值相关联的类别（或列）名称。这些值将显示在表中行与列交叉的每个单元格中。在这种情况下，我们希望交叉的单元格显示每个办公室选择的每种口味的
    `count()`。这个第一个查询本身创建了一个简单的聚合列表。
- en: The second query parameter 5 produces the category names for the columns. The
    `crosstab()` function requires that the second subquery returns only one column,
    so we use `SELECT` to retrieve `flavor` and `GROUP BY` to return that column’s
    unique values.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个查询参数 5 生成列的类别名称。`crosstab()` 函数要求第二个子查询只返回一列，因此我们使用 `SELECT` 来检索 `flavor`，并使用
    `GROUP BY` 来返回该列的唯一值。
- en: Then we specify the names and data types of the crosstab’s output columns following
    the `AS` keyword 6. The list must match the row and column names in the order
    the queries generate them. For example, because the second query that supplies
    the category columns orders the flavors alphabetically, the output column list
    must as well.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在 `AS` 关键字后指定交叉表输出列的名称和数据类型 6。该列表必须与查询生成的行和列的名称顺序一致。例如，由于提供类别列的第二个查询按字母顺序排列口味，输出列列表也必须如此。
- en: 'When we run the code, our data displays in a clean, readable crosstab:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码时，数据将以干净、易读的交叉表形式显示：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It’s easy to see at a glance that the Midtown office favors chocolate but has
    no interest in strawberry, which is represented by a `NULL` value showing that
    strawberry received no votes. But strawberry is the top choice Downtown, and the
    Uptown office is more evenly split among the three flavors.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一目了然，Midtown 办公室偏爱巧克力，但对草莓毫无兴趣，草莓的得票数为 `NULL`，表示草莓没有收到任何投票。而草莓是 Downtown 的首选，Uptown
    办公室则在三种口味之间较为均衡。
- en: Tabulating City Temperature Readings
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 城市温度读数汇总
- en: 'Let’s create another crosstab, but this time we’ll use real data. The *temperature_readings.csv*
    file, also available with all the book’s resources at [https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/),
    contains a year’s worth of daily temperature readings from three observation stations
    around the United States: Chicago, Seattle, and Waikiki, a neighborhood on the
    south shore of the city of Honolulu. The data come from the US National Oceanic
    and Atmospheric Administration (NOAA) at [https://www.ncdc.noaa.gov/cdo-web/datatools/findstation/](https://www.ncdc.noaa.gov/cdo-web/datatools/findstation/).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个交叉表，这次我们将使用真实数据。*temperature_readings.csv* 文件也可以在本书的所有资源中找到，网址为 [https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/)，其中包含来自美国三个观测站点（芝加哥、西雅图和威基基——位于檀香山市区南岸的一个社区）的为期一年的每日温度读数。数据来自美国国家海洋和大气管理局（NOAA），网址为
    [https://www.ncdc.noaa.gov/cdo-web/datatools/findstation/](https://www.ncdc.noaa.gov/cdo-web/datatools/findstation/)。
- en: 'Each row in the CSV file contains four values: the station name, the date,
    and the day’s maximum and minimum temperatures. All temperatures are in Fahrenheit.
    For each month in each city, we want to compare climates using the median high
    temperature. [Listing 13-18](#listing13-18) has the code to create the `temperature_readings`
    table and import the CSV file.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: CSV 文件中的每一行包含四个值：站点名称、日期以及当天的最高和最低温度。所有温度均为华氏度。对于每个城市的每个月，我们希望使用中位数最高温度来比较气候。[Listing
    13-18](#listing13-18) 中的代码用于创建 `temperature_readings` 表并导入 CSV 文件。
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 13-18: Creating and filling a `temperature_readings` table'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 13-18：创建并填充 `temperature_readings` 表
- en: The table contains the four columns from the CSV file; we add a natural primary
    key using the station name and observation date. A quick count should return 1,077
    rows. Now, let’s see what cross tabulating the data does using [Listing 13-19](#listing13-19).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 表格包含来自 CSV 文件的四列；我们使用站点名称和观测日期添加了一个自然主键。快速计数应返回 1,077 行数据。现在，让我们看看使用 [Listing
    13-19](#listing13-19) 交叉汇总数据会产生什么效果。
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 13-19: Generating the temperature readings crosstab'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 13-19：生成温度读数交叉表
- en: The crosstab structure is the same as in [Listing 13-18](#listing13-18). The
    first subquery inside `crosstab()` generates the data for the crosstab, finding
    the median maximum temperature for each month. It supplies three required columns.
    The first, `station_name` 1, names the rows. The second column uses the `date_part()`
    function 2 from Chapter 12 to extract the month from `observation_date`, which
    provides the crosstab columns. Then we use `percentile_cont(.5)` 3 to find the
    50th percentile, or the median, of the `max_temp`. We group by station name and
    month so we have a median `max_temp` for each month at each station.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉表的结构与 [清单 13-18](#listing13-18) 中相同。`crosstab()` 内部的第一个子查询生成交叉表的数据，查找每个月的中位数最高温度。它提供了三个必需的列。第一个列
    `station_name` 1 命名了行。第二列使用了第 12 章中的 `date_part()` 函数 2，从 `observation_date` 中提取月份，作为交叉表的列。然后我们使用
    `percentile_cont(.5)` 3 来查找 `max_temp` 的第 50 个百分位数，即中位数。我们按照站点名称和月份进行分组，以便获得每个站点每个月的中位数
    `max_temp`。
- en: As in [Listing 13-18](#listing13-18), the second subquery produces the set of
    category names for the columns. I’m using a function called `generate_series()`
    4 in a manner noted in the official PostgreSQL documentation to create a list
    of numbers from 1 to 12 that match the month numbers `date_part()` extracts from
    `observation_date`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [清单 13-18](#listing13-18) 中所示，第二个子查询生成列的类别名称集合。我使用一个叫做 `generate_series()`
    的函数，按照官方 PostgreSQL 文档中的方式创建从 1 到 12 的数字列表，这些数字与 `date_part()` 从 `observation_date`
    提取的月份数字相匹配。
- en: 'Following `AS`, we provide the names and data types for the crosstab’s output
    columns. Each is a `numeric` type, matching the output of the percentile function.
    The following output is practically poetry:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AS` 后，我们提供了交叉表输出列的名称和数据类型。每列都是 `numeric` 类型，匹配分位数函数的输出。以下输出几乎如同诗篇：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We’ve transformed a raw set of daily readings into a compact table showing the
    median maximum temperature each month for each station. At a glance, we can see
    that the temperature in Waikiki is consistently balmy, whereas Chicago’s median
    high temperatures vary from just above freezing to downright pleasant. Seattle
    falls between the two.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一组原始的每日读数转化为一个简洁的表格，展示每个站点每月的中位数最高温度。一眼看去，我们可以发现怀基基的温度始终如春，而芝加哥的中位数最高温度则从接近冰点到相当宜人不等。西雅图的温度介于两者之间。
- en: Crosstabs do take time to set up, but viewing datasets in a matrix often makes
    comparisons easier than viewing the same data in a vertical list. Keep in mind
    that the `crosstab()` function is resource-intensive, so tread carefully when
    querying sets that have millions or billions of rows.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 设置交叉表确实需要时间，但将数据集以矩阵的形式展示，往往比以垂直列表的形式查看相同数据更容易进行比较。请记住，`crosstab()` 函数是资源密集型的，因此在查询包含百万或十亿行的集合时要小心。
- en: Reclassifying Values with CASE
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `CASE` 重新分类值
- en: The ANSI Standard SQL `CASE` statement is a *conditional expression*, meaning
    it lets you add some “if this, then . . .” logic to a query. You can use `CASE`
    in multiple ways, but for data analysis, it’s handy for reclassifying values into
    categories. You can create categories based on ranges in your data and classify
    values according to those categories.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ANSI 标准 SQL 的 `CASE` 语句是一个 *条件表达式*，意味着它允许你在查询中添加“如果这样，则……”的逻辑。你可以以多种方式使用 `CASE`，但对于数据分析而言，它非常方便，用于将值重新分类为不同类别。你可以根据数据中的范围创建类别，并根据这些类别对值进行分类。
- en: 'The `CASE` syntax follows this pattern:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`CASE` 语法遵循以下模式：'
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We give the `CASE` keyword 1 and then provide at least one `WHEN` `condition`
    `THEN` `result` clause, where `condition` is any expression the database can evaluate
    as `true` or `false`, such as `county = 'Dutchess County'` or `date > '1995-08-09'`.
    If the condition is `true`, the `CASE` statement returns the `result` and stops
    checking any further conditions. The result can be any valid data type. If the
    condition is `false`, the database moves on to evaluate the next condition.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给 `CASE` 关键字一个值 1，然后提供至少一个 `WHEN` `condition` `THEN` `result` 子句，其中 `condition`
    是任何数据库可以评估为 `true` 或 `false` 的表达式，例如 `county = 'Dutchess County'` 或 `date > '1995-08-09'`。如果条件为
    `true`，则 `CASE` 语句返回 `result` 并停止检查任何进一步的条件。结果可以是任何有效的数据类型。如果条件为 `false`，则数据库继续评估下一个条件。
- en: To evaluate more conditions, we can add optional `WHEN ... THEN` clauses 2.
    We can also provide an optional `ELSE` clause 3 to return a result in case no
    condition evaluates as `true`. Without an `ELSE` clause, the statement would return
    a `NULL` when no conditions are `true`. The statement finishes with an `END` keyword
    4.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估更多条件，我们可以添加可选的 `WHEN ... THEN` 子句 2。我们还可以提供一个可选的 `ELSE` 子句 3，以在没有条件为 `true`
    时返回一个结果。如果没有 `ELSE` 子句，当没有条件为 `true` 时，语句将返回 `NULL`。语句以 `END` 关键字 4 结束。
- en: '[Listing 13-20](#listing13-20) shows how to use the `CASE` statement to reclassify
    the temperature readings into descriptive groups (named according to my own bias
    against cold weather).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-20](#listing13-20) 显示了如何使用 `CASE` 语句将温度读数重新分类为描述性分组（这些分组根据我自己对寒冷天气的偏见来命名）。'
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 13-20: Reclassifying temperature data with `CASE`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 13-20：使用 `CASE` 重新分类温度数据
- en: We create six ranges for the `max_temp` column in `temperature_readings`, which
    we define using comparison operators. The `CASE` statement evaluates each value
    to find whether any of the six expressions are `true`. If so, the statement outputs
    the appropriate text. Note that the ranges account for all possible values in
    the column, leaving no gaps. If none of the statements is `true`, then the `ELSE`
    clause assigns the value to the category `No reading`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 `temperature_readings` 中的 `max_temp` 列创建了六个范围，通过比较运算符来定义。`CASE` 语句会评估每个值，检查六个表达式中是否有任何一个为
    `true`。如果是，语句会输出相应的文本。请注意，这些范围涵盖了列中的所有可能值，没有任何遗漏。如果没有任何条件为 `true`，则 `ELSE` 子句将值分配到
    `No reading` 类别。
- en: 'Run the code; the first five rows of output should look like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码；输出的前五行应该如下所示：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now that we’ve collapsed the dataset into six categories, let’s use those categories
    to compare climate among the three cities in the table.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将数据集压缩成六个类别，让我们用这些类别来比较表中三个城市的气候。
- en: Using CASE in a Common Table Expression
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在公用表表达式中使用 `CASE`
- en: The operation we performed with `CASE` on the temperature data in the previous
    section is a good example of a preprocessing step you could use in a CTE. Now
    that we’ve grouped the temperatures in categories, let’s count the groups by city
    in a CTE to see how many days of the year fall into each temperature category.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中使用 `CASE` 对温度数据进行的操作是一个很好的示例，展示了你可以在 CTE 中使用的预处理步骤。现在我们已经将温度分组，接下来让我们在
    CTE 中按城市统计这些分组，看看每个温度类别包含了多少天。
- en: '[Listing 13-21](#listing13-21) shows the code for reclassifying the daily maximum
    temperatures recast to generate a `temps_collapsed` CTE and then use it for an
    analysis.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13-21](#listing13-21) 显示了重新分类日最高温度的代码，重新生成 `temps_collapsed` CTE 并将其用于分析。'
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 13-21: Using `CASE` in a CTE'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 13-21：在 CTE 中使用 `CASE`
- en: 'This code reclassifies the temperatures and then counts and groups by station
    name to find general climate classifications of each city. The `WITH` keyword
    defines the CTE of `temps_collapsed` 1, which has two columns: `station_name`
    and `max_temperature_group`. We then run a `SELECT` query on the CTE 2, performing
    straightforward `count(*)` and `GROUP BY` operations on both columns. The results
    should look like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码重新分类了温度，然后按站点名称进行计数和分组，以找到每个城市的一般气候分类。`WITH` 关键字定义了 `temps_collapsed` CTE
    1，它有两列：`station_name` 和 `max_temperature_group`。然后我们在 CTE 2 上运行 `SELECT` 查询，执行简单的
    `count(*)` 和 `GROUP BY` 操作。结果应该如下所示：
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Using this classification scheme, the amazingly consistent Waikiki weather,
    with `Warm` maximum temperatures 361 days of the year, confirms its appeal as
    a vacation destination. From a temperature standpoint, Seattle looks good too,
    with nearly 300 days of `Pleasant` or `Warm` high temps (although this belies
    Seattle’s legendary rainfall). Chicago, with 30 days of `Frigid` max temps and
    8 days `Inhumane`, probably isn’t for me.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这一分类方案，令人惊讶的一致的威基基天气，361天的 `Warm` 最高气温，证明了它作为度假胜地的吸引力。从温度角度来看，西雅图也不错，几乎有300天的
    `Pleasant` 或 `Warm` 高温（尽管这与西雅图传奇般的降雨量相矛盾）。芝加哥有30天的 `Frigid` 最高气温和8天的 `Inhumane`
    最高气温，可能不适合我。
- en: Wrapping Up
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned to make queries work harder for you. You can now
    add subqueries in multiple locations to provide finer control over filtering or
    preprocessing data before analyzing it in a main query. You also can visualize
    data in a matrix using cross tabulations and reclassify data into groups; both
    techniques give you more ways to find and tell stories using your data. Great
    work!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何让查询更好地为你服务。你现在可以在多个位置添加子查询，从而在分析主查询之前对数据进行更精细的过滤或预处理。你还可以使用交叉制表法将数据可视化为矩阵，并将数据重新分类为不同的组；这两种技术都为你提供了更多使用数据来发现和讲述故事的方法。干得不错！
- en: Throughout the next chapters, we’ll dive into SQL techniques that are more specific
    to PostgreSQL. We’ll begin by working with and searching text and strings.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨更多专门针对 PostgreSQL 的 SQL 技巧。我们将从处理和搜索文本以及字符串开始。
