- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 14 STRING OPERATIONS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14 字符串操作
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: A *string* is a collection of values stored in contiguous memory locations.
    Strings are usually arrays of bytes, half words, words, dwords, or quad words.
    Some CISC CPUs, such as the Intel x86-64, support instructions that operate directly
    on strings of data. However, the ARM does not provide instructions for this purpose,
    as string operations tend to be complex and violate RISC design guidelines. Nevertheless,
    it is possible to operate on string data structures by using discrete ARM instructions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串*是存储在连续内存位置上的一组值。字符串通常是字节、半字、字、双字或四字的数组。一些CISC CPU，如Intel x86-64，支持直接操作字符串数据的指令。然而，ARM没有提供这类指令，因为字符串操作往往很复杂，并且违反了RISC设计准则。不过，使用离散的ARM指令仍然可以操作字符串数据结构。'
- en: Although the ARM CPU does not support string-specific instructions, string operations
    are still an important function that CPUs must perform. This chapter discusses
    how to work with strings when using ARM assembly language. First off, this chapter
    describes how to call functions in the C stdlib to implement string operations.
    These functions are well written (typically in assembly language) and provide
    a high-performance implementation, as long as you are using zero-terminated strings.
    As noted throughout this book, however, zero-terminated strings are not the most
    suitable string data structure for high-performance string operations. Therefore,
    this chapter describes a better string format that allows you to write faster
    string functions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管ARM CPU不支持字符串特定的指令，但字符串操作仍然是CPU必须执行的重要功能。本章讨论了在使用ARM汇编语言时如何处理字符串。首先，本章介绍了如何调用C标准库中的函数来实现字符串操作。这些函数编写得很好（通常是用汇编语言编写），并提供了高性能的实现，只要你使用的是零终止字符串。然而，如本书中所述，零终止字符串并不是高性能字符串操作最适合的字符串数据结构。因此，本章描述了一种更好的字符串格式，使你能够编写更快速的字符串函数。
- en: Of course, the problem with a new string implementation is that the C stdlib
    functions don’t support it, so this chapter also describes how to implement various
    string functions that support the new string format. Finally, this chapter concludes
    by discussing Unicode strings and string functions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，采用新的字符串实现问题在于C标准库函数不支持它，因此本章还描述了如何实现支持新字符串格式的各种字符串函数。最后，本章通过讨论Unicode字符串和字符串函数来作总结。
- en: 14.1 Zero-Terminated Strings and Functions
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1 零终止字符串与函数
- en: '[Chapter 4](chapter4.xhtml) briefly introduced the string data type, discussing
    zero-terminated strings (commonly used in C/C++ and languages derived from them),
    length-prefixed strings, string descriptors, and other string forms. As noted
    there, the zero-terminated string is the most common string form in use today.
    In particular, Linux (Pi OS) and macOS generally use zero-terminated strings for
    API functions to which you pass or receive string data. Therefore, you’ll often
    use zero-terminated strings in your ARM assembly language programs running under
    these OSes. This section describes the issues with zero-terminated strings and
    how to call functions in the C stdlib that support zero-terminated strings.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](chapter4.xhtml)简要介绍了字符串数据类型，讨论了零终止字符串（常用于C/C++及其衍生语言）、长度前缀字符串、字符串描述符和其他字符串形式。如前所述，零终止字符串是当前最常用的字符串形式。特别是，Linux（Pi
    OS）和macOS通常在API函数中使用零终止字符串来传递或接收字符串数据。因此，在这些操作系统下运行的ARM汇编语言程序中，你将经常使用零终止字符串。本节描述了零终止字符串的问题以及如何调用支持零终止字符串的C标准库函数。'
- en: 'The main problem with zero-terminated strings is performance. Such strings
    often require scanning over every character in the string to perform simple operations
    such as computing the string length. For example, the following code computes
    the length of a string named longZString:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 零终止字符串的主要问题是性能。这些字符串通常需要扫描每个字符才能执行简单的操作，比如计算字符串的长度。例如，以下代码计算名为longZString的字符串的长度：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If longZString is indeed very long, this code sequence can take a long time
    to execute.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果longZString确实非常长，那么这段代码序列可能需要很长时间才能执行。
- en: Length-prefixed strings (see section 4.6.2, “Length-Prefixed Strings,” on [page
    188](chapter4.xhtml#pg_188)) solve this problem by including the string’s current
    length along with the data. Any string function that uses the string’s length
    will operate much more efficiently because it doesn’t have to first scan the entire
    string to determine its length. If you get to choose the string format to use
    in your assembly language code, choosing a data type that includes the length
    as part of the string’s data can dramatically improve string-processing performance.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 长度前缀字符串（参见第 4.6.2 节，“长度前缀字符串”，在 [第 188 页](chapter4.xhtml#pg_188)）通过将字符串的当前长度与数据一起包含来解决这个问题。任何使用字符串长度的字符串函数将更高效地操作，因为它不必首先扫描整个字符串来确定其长度。如果你能够选择在汇编语言代码中使用的字符串格式，选择一个将长度作为字符串数据一部分的数据类型，可以显著提高字符串处理性能。
- en: Unfortunately, you don’t always get to choose the string format to use in your
    code. Sometimes external datasets, applications, or OSes force the zero-terminated
    string format on you (for example, OS API calls generally require zero-terminated
    strings).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，你并不总是能选择代码中使用的字符串格式。有时，外部数据集、应用程序或操作系统会强制你使用以零结尾的字符串格式（例如，操作系统的 API 调用通常要求使用以零结尾的字符串）。
- en: It is possible to improve the performance of naive string functions such as
    the string-length code given earlier. In particular, the code at whileLp processes
    a single byte per iteration of the loop. Because the ARM64 CPU is capable of processing
    8 bytes at a time in general-purpose registers (and 16 bytes at a time in vector
    registers), you might wonder whether it’s possible to do better than one character
    per loop iteration. After all, if you can process 16 bytes per loop iteration
    (rather than 1), the function should run 16 times faster, right?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能提高像之前给出的字符串长度代码这样的简单字符串函数的性能。特别是，whileLp 中的代码每次循环迭代时处理一个字节。由于 ARM64 CPU 通常能够在通用寄存器中一次处理
    8 个字节（在向量寄存器中一次处理 16 个字节），你可能会想，是否可以比每次循环迭代处理一个字符做得更好。毕竟，如果你每次循环迭代处理 16 个字节（而不是
    1 个字节），函数应该运行快 16 倍，对吧？
- en: The answer is a qualified yes. The first caveat is that processing 16 bytes
    per iteration is more complex and will require more than three instructions in
    the loop body. Expecting a 16-times improvement is therefore overly optimistic;
    4 to 8 times faster is probably a more reasonable expectation but still worth
    achieving.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是有条件的肯定。第一个警告是每次迭代处理 16 字节更复杂，需要循环体中超过三条指令。因此，期望提升 16 倍是过于乐观的；4 到 8 倍的提升可能是更合理的期望，但仍然值得追求。
- en: The second caveat is that processing 16 characters at a time requires loading
    16 bytes from memory on each iteration, meaning that for many strings you’ll have
    to read data from memory beyond the end of the string. Thus, it’s possible to
    read beyond the end of an MMU page in memory containing the string, which could
    lead to a memory protection fault (see section 3.1.7, “Memory Access and MMU Pages,”
    on [page 127](chapter3.xhtml#pg_127)). While such a situation is rare, it nevertheless
    represents a defect in your code that could crash your application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个警告是每次处理 16 个字符需要在每次迭代时从内存加载 16 个字节，这意味着对于许多字符串，你将不得不从字符串的末尾之后的内存中读取数据。因此，可能会读取超过包含字符串的
    MMU 页的末尾，这可能导致内存保护错误（参见第 3.1.7 节，“内存访问和 MMU 页”，在 [第 127 页](chapter3.xhtml#pg_127)）。虽然这种情况很少发生，但它仍然代表了代码中的一个缺陷，可能会导致你的应用程序崩溃。
- en: One last issue, while not as lethal as an illegal memory access, is that loading
    16 bytes of data from memory into a vector register works best if the data is
    aligned on a 16-byte boundary. Unfortunately, a zero-terminated string is not
    guaranteed to begin on such a boundary in memory.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题，尽管它不像非法内存访问那样致命，但从内存加载 16 个字节的数据到向量寄存器中时，如果数据按照 16 字节边界对齐，则效果最佳。不幸的是，以零结尾的字符串在内存中并不能保证从这样的边界开始。
- en: If you have complete control of string placement in memory, you can arrange
    for strings to always begin on a 16-byte boundary. Likewise, you can always include
    padding at the end of the strings so you’re guaranteed to be able to read at least
    15 bytes beyond the end of the string’s data, thereby avoiding the MMU page-boundary
    problem. Unfortunately, few programs have such tight control over their strings
    that they can guarantee this arrangement in memory. For example, if an OS returns
    a pointer to a string, it may violate alignment and padding requirements.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完全控制字符串在内存中的位置，你可以确保字符串总是从16字节边界开始。同样，你也可以在字符串末尾始终添加填充，以确保至少能读取字符串数据末尾之后的15个字节，从而避免MMU页面边界的问题。不幸的是，很少有程序能够对其字符串有如此严格的控制，以确保内存中的这种安排。例如，如果操作系统返回指向字符串的指针，它可能会违反对齐和填充要求。
- en: 'As a general rule, I recommend calling C stdlib functions if you’re going to
    manipulate zero-terminated (C) strings. In the past, C stdlib functions were written
    in C, and even with the best optimizing compilers it was easy enough for a good
    assembly language programmer to write faster code than the compiler produced.
    However, modern C stdlib string code is typically written in assembly language
    (by an *expert* programmer) and is often much better than any code you would write
    yourself. The GNU C stdlib for AARCH64, for example, has the following functions
    written in handcoded assembly language (see section 14.6, “For More Information,”
    on [page 859](chapter14.xhtml#pg_859) for more on these):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果你要操作以零结尾的（C）字符串，我建议调用C标准库函数。在过去，C标准库函数是用C编写的，即使使用最好的优化编译器，也足够简单，好的汇编语言程序员能够编写比编译器生成的代码更快的代码。然而，现代C标准库的字符串代码通常是用汇编语言编写的（由*专家*程序员编写），通常比你自己写的任何代码都要好。例如，GNU
    C标准库的AARCH64版本中，以下函数是用手写汇编语言编写的（有关更多信息，请参见[第859页](chapter14.xhtml#pg_859)，在“更多信息”一节中）：
- en: strcpy
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: strcpy
- en: strchr
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: strchr
- en: strchrnul
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: strchrnul
- en: strcmp
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: strcmp
- en: strcpy
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: strcpy
- en: strlen
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: strlen
- en: strncmp
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: strncmp
- en: strnlen
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: strnlen
- en: strrchr
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: strrchr
- en: 'The following is the GNU C stdlib *strlen.S* source file (slightly modified
    for formatting and comments):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是GNU C标准库的*strlen.S*源文件（稍作修改以便格式化和注释）：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The defines ❶ give the registers meaningful names within the function. Personally,
    I prefer to see the register names with comments describing their contents rather
    than redefined registers, to make it easier to avoid reusing registers, but this
    is certainly an acceptable style, especially for C library code that uses the
    ARM ABI.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏定义❶为函数中的寄存器赋予了有意义的名称。就个人而言，我更倾向于看到带有描述寄存器内容的注释的寄存器名称，而不是重新定义的寄存器，这样可以更容易避免重复使用寄存器，但这无疑是一种可接受的风格，特别是在使用ARM
    ABI的C库代码中。
- en: 'As noted earlier, code that operates on 16 bytes at a time (as this version
    of strlen() does) has to deal with two issues: aligning data on a 16-byte boundary
    and preventing data access beyond the end of the MMU page containing the string.
    This code achieves both of those requirements by using the bic instruction ❷ to
    set the LO 4 bits of the string pointer to 0\. Setting the LO 4 bits to 0 will
    align the pointer on the 16-byte boundary on or before the beginning of the string.
    Note that src (X1) might now point at up to 15 characters before the actual start
    of the string (which might contain some 0 bytes; this function will deal with
    that issue later). Because MMU pages always begin on a 4,096-byte boundary (which
    are also 16-byte boundaries), adjusting the pointer to the beginning of the 16-byte
    boundary will never produce a memory access outside the MMU page containing the
    start of the string.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，处理一次16字节数据的代码（如该版本的strlen()所做的）必须解决两个问题：将数据对齐到16字节边界，并防止数据访问超出包含字符串的MMU页的末尾。此代码通过使用bic指令❷将字符串指针的低4位设置为0来实现这两个要求。将低4位设置为0会将指针对齐到字符串起始位置之前或与16字节边界对齐。请注意，src（X1）现在可能会指向实际字符串开始之前最多15个字符（这些字符可能包含一些0字节；该函数稍后会处理这个问题）。因为MMU页总是从4,096字节边界开始（这些边界也是16字节边界），所以调整指针到16字节边界的起始位置永远不会产生超出包含字符串起始位置的MMU页的内存访问。
- en: Another advantage to aligning the pointer on a 16-byte boundary is that you
    don’t have to worry about accidental illegal memory accesses at the end of the
    MMU page. Because 4,096 is divisible by 16, loading 16 bytes at a time on 16-byte
    boundaries will never produce a memory access that crosses a page boundary. If
    the zero-terminating byte is anywhere within those 16 bytes, reading data to the
    end of the 16-byte block is safe. Clearing the LO 4 bits of the pointer thus allows
    safe memory accesses within an MMU page.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将指针对齐到 16 字节边界的另一个优点是，你不必担心在 MMU 页末尾发生意外的非法内存访问。由于 4096 可被 16 整除，在 16 字节边界上一次加载
    16 字节永远不会导致跨越页面边界的内存访问。如果终止 0 字节位于这 16 字节中的任何位置，从 16 字节块的末尾读取数据是安全的。因此，通过清除指针的
    LO 4 位，允许在 MMU 页内进行安全的内存访问。
- en: The problem with aligning the src pointer to a 16-byte boundary is that doing
    so may change the pointer to point at memory *before* the start of the string.
    While this won’t create MMU page fault problems, it might cause the code to incorrectly
    compute the string’s length. At the very least, you don’t want to count any extra
    bytes before the start of the string, nor do you want to terminate the string-length
    calculation, because 0s appear in those earlier bytes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对 src 指针进行 16 字节对齐的问题在于，进行对齐可能会导致指针指向字符串开始 *之前* 的内存。虽然这不会引起 MMU 页故障问题，但它可能导致代码错误地计算字符串的长度。至少，你不想计算字符串开始之前的任何额外字节，也不想在这些字节中出现
    0 时终止字符串长度的计算。
- en: Fortunately, the code handles this in a clever way ❷. First, the ld1 instruction
    starts the process by loading 16 bytes from the aligned address in src. The cmeq
    instruction then locates every 0 byte in those 16, then stores 0xFF in the corresponding
    bytes of V1 (vhas_null) and 0s everywhere else.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，代码以巧妙的方式处理了这个问题❷。首先，ld1 指令通过从对齐的地址加载 src 中的 16 字节来启动该过程。然后，cmeq 指令在这 16
    字节中定位每个 0 字节，并将 0xFF 存储到 V1（vhas_null）的相应字节中，其它地方填充 0。
- en: The shrn instruction shifts the compare mask bits to the right 4 bit positions.
    The even bytes now contain two comparison masks in the LO and HO nibbles, and
    the “narrowing” component of the instruction extracts those even bytes and packs
    them into the LO 8 bytes of V2 (for a total of 16 nibbles), which the fmov instruction
    copies into X2.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: shrn 指令将比较掩码位右移 4 位。偶数字节现在包含两个比较掩码，分别位于 LO 和 HO 的 nibbles 中，指令的“缩小”部分提取这些偶数字节，并将它们打包到
    V2 的 LO 8 字节中（总共 16 个 nibbles），然后 fmov 指令将其复制到 X2 中。
- en: The lsl instruction (which I skipped discussing in the previous paragraph) is
    part of the code that deals with extra bytes appearing in the 16-byte block prior
    to the string. This multiplies the original address by 4; this will be an index
    into the nibbles held in X2, where the string will actually start (using only
    the LO 6 bits of the shifted value). The lsr instruction shifts the nibble mask
    to the right by the number of bits held in the LO 6 bits of X4 (shift). This removes
    the cmeq nibble masks from X2 for the bytes that appear before the start of the
    string. These lsl and lsr instructions allow the algorithm to ignore the (possible)
    extra bytes in the 16-byte block before the string.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: lsl 指令（在上一段中我跳过了讨论）是处理在字符串之前的 16 字节块中出现的额外字节的代码的一部分。它将原始地址乘以 4；这将是 X2 中 nibbles
    的索引，实际的字符串将从那里开始（只使用移位值的 LO 6 位）。lsr 指令将 nibble 掩码右移，移动的位数是 X4（shift）的 LO 6 位中的值。这会将
    X2 中位于字符串开始之前的字节的 cmeq nibble 掩码移除。这些 lsl 和 lsr 指令允许算法忽略字符串之前 16 字节块中的（可能存在的）额外字节。
- en: The resulting value in X2 will contain 0b1111 nibbles everywhere a 0 byte appears
    in the portion of the string held in V0 (vdata), and 0b0000 in all the other nibbles.
    In particular, X2 will contain 0 if there were no 0 bytes in the string in V0\.
    If X2 contains 0 (meaning no 0 bytes), the string’s terminating 0 byte must appear
    later in the string; in that case, the cbz instruction transfers control to label
    zloop.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最终在 X2 中的值将包含 0b1111 每当 V0（vdata）中字符串的部分出现 0 字节时，所有的其他字节则是 0b0000。特别地，如果 V0
    中的字符串没有 0 字节，X2 将包含 0。如果 X2 中包含 0（意味着没有 0 字节），则字符串的终止 0 字节必须出现在字符串的后面；在这种情况下，cbz
    指令将控制转移到标签 zloop。
- en: If X2 does not contain 0, a 0b1111 nibble indicates the position of a 0 byte
    in the string. The rbit (reverse bits) instruction ❸ reverses all the bits in
    X2, and the clz instruction counts the number of leading 0s. Because each byte
    in the string is marked by 4 bits in X2, the count in X0 (result) is four times
    the length of the string. The lsr instruction shifts this count right by 2, which
    divides the bit count by 4, producing the string length.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 X2 不包含 0，则 0b1111 nibble 表示字符串中 0 字节的位置。rbit（反转位）指令❸会反转 X2 中的所有位，而 clz 指令会统计前导
    0 的数量。由于字符串中的每个字节在 X2 中由 4 位标记，X0（结果）中的计数值是字符串长度的四倍。lsr 指令将该计数值右移 2 位，相当于将位计数除以
    4，从而得到字符串的长度。
- en: The function then returns this length to the caller in X0\. This code handles
    the case where the string appears in the first block of bytes loaded into V0 (vdata).
    If the string is sufficiently long that the code must fetch another block of 16
    bytes from memory, the function transfers control to the code ❹. The code at zloop
    is responsible for processing blocks of 16 characters, where the first byte read
    from memory is part of the string (unlike the previous code, where the first 1–15
    bytes might not be part of the string). This loop rapidly scans through blocks
    of 16 bytes, looking for the first one that contains a 0\. As this loop takes
    five instructions to process 16 bytes (versus three instructions to process a
    single byte in the original string-length example), you would expect it to run
    approximately eight times faster than the single-byte-at-a-time code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，函数将该长度返回给调用者，保存在 X0 中。此代码处理字符串出现在加载到 V0（vdata）的第一块字节中的情况。如果字符串足够长，以至于代码必须从内存中获取另一块
    16 字节的数据，函数会将控制转移到代码❹。zloop 中的代码负责处理包含 16 个字符的块，其中从内存中读取的第一个字节是字符串的一部分（与之前的代码不同，后者的前
    1–15 字节可能不是字符串的一部分）。这个循环快速扫描 16 字节的块，寻找第一个包含 0 的块。由于这个循环处理 16 字节需要五条指令（而原始的逐字节字符串长度计算例子只需要三条指令），你可以预期它会比单字节处理的代码快大约八倍。
- en: Once the loop finds a 0 byte somewhere in a block of 16 bytes ❺, it determines
    the position of the 0 byte (using the same technique as earlier ❷ ❸), adds the
    distance from the start of the string to the current 16-byte block, then adds
    the number of nonzero bytes in the current 16-byte block.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦循环在 16 字节块中找到一个 0 字节❺，它就会确定该 0 字节的位置（使用与之前相同的技术❷❸），然后将从字符串起始位置到当前 16 字节块的距离加上当前
    16 字节块中的非零字节数。
- en: Although this code is tricky and complex, computing the length of a zero-terminated
    string is a common operation, so it’s worth the optimization work. You would be
    hard-pressed to improve on this algorithm when writing your own code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这段代码复杂且难度较高，但计算零终止字符串的长度是一个常见的操作，因此优化是值得的。当你编写自己的代码时，几乎无法比这个算法更好。
- en: Again, because the *glibc* (GNU Library for C) authors have spent considerable
    time optimizing their ARM string functions, I highly recommend calling the C stdlib
    functions if they are appropriate for your application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，由于*glibc*（GNU C 库）的作者花费了大量时间优化他们的 ARM 字符串函数，我强烈推荐在合适的情况下调用 C 标准库函数。
- en: 14.2 A String Format for Assembly Language Programmers
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2 面向汇编语言程序员的字符串格式
- en: As mentioned many times in this book, the zero-terminated string is not the
    best string data type to use if you want to write the highest-performing code.
    Choosing a string format that incorporates the length, and possibly other information,
    as well as providing data alignment for the string data, can improve performance
    in many cases. This section introduces a sample format that provides these improvements.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书中多次提到的，如果你想编写最高效的代码，零终止字符串并不是最佳的字符串数据类型。选择一个包含长度信息的字符串格式，可能还包括其他信息，并且提供数据对齐，通常能在许多情况下提升性能。本节介绍了一种提供这些改进的示例格式。
- en: The string format discussed in this section is based on the HLA string format
    (see section 4.6.2, “Length-Prefixed Strings,” on [page 188](chapter4.xhtml#pg_188)).
    HLA strings consist of two 32-bit length values followed by the character data
    and a zero-terminating byte. A string “variable” is just a pointer object that
    points to the first character of the string (or to a zero-terminating byte, if
    the string is empty).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论的字符串格式基于 HLA 字符串格式（请参见第 4.6.2 节“长度前缀字符串”，见[第 188 页](chapter4.xhtml#pg_188)）。HLA
    字符串由两个 32 位的长度值组成，后跟字符数据和一个零终止字节。一个字符串“变量”只是一个指向字符串第一个字符（或者如果字符串为空，指向零终止字节）的指针对象。
- en: The current length of the string (character count, not including the zero-terminating
    byte) appears at address ptr-4, and a maximum allocated space (for characters)
    value appears at address ptr-8 (where ptr is the pointer to the character data).
    Both length values are unsigned 32-bit values, supporting strings up to 4GB in
    length. For HLA, string objects are always aligned on a 4-byte boundary and the
    storage allocated for the string (and 0 byte) is always a multiple of 4 bytes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的当前长度（字符计数，不包括零终止字节）位于地址 ptr-4，最大分配空间（字符数）值位于地址 ptr-8（其中 ptr 是指向字符数据的指针）。这两个长度值都是无符号
    32 位值，支持最大长度为 4GB 的字符串。对于 HLA，字符串对象总是以 4 字节边界对齐，并且为字符串（和 0 字节）分配的存储空间总是 4 字节的倍数。
- en: 'For strings on a 64-bit CPU, a few changes are appropriate. First, the 4-byte
    maximum length and current length fields can remain. You probably don’t need strings
    that can hold more than four billion characters. The alignment should be on a
    16-byte boundary, allowing the use of Neon vector registers to efficiently process
    16 bytes at a time from memory. Finally, storage allocated for strings should
    always be a multiple of 16 bytes (to prevent problems when reading bytes beyond
    the end of the string). Here’s a first pass at a structure that defines this string
    type:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 64 位 CPU 上的字符串，需要做一些调整。首先，4 字节的最大长度和当前长度字段可以保留。你可能不需要能够容纳超过四十亿个字符的字符串。对齐应该在
    16 字节边界上，以便使用 Neon 向量寄存器高效地一次处理 16 字节数据。最后，为字符串分配的存储空间应该始终是 16 字节的倍数（以防止读取超出字符串末尾的字节时出现问题）。以下是定义该字符串类型的结构的第一次尝试：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With this struct declaration and a pointer to a string object in X0, you can
    access the fields of the string as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此结构声明并且指向字符串对象的指针位于 X0，你可以按如下方式访问字符串的字段：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that X0 points directly at the first character of the string (if it isn’t
    empty), so you can reference the character data by using [x0] directly (you don’t
    need to use the string.chars field name, which turns out to be 0, anyway).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，X0 直接指向字符串的第一个字符（如果它不是空的），因此你可以通过直接使用[x0]来引用字符数据（你不需要使用 string.chars 字段名，反正它的值为
    0）。
- en: 'If you would actually like to allocate storage for string data, or initialize
    some string storage with character data, the following two macros are useful (as
    a first approximation, with a minor modification to appear in the next section):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你实际想为字符串数据分配存储空间，或使用字符数据初始化一些字符串存储，以下两个宏非常有用（作为初步的近似，稍后会在下一节进行小的修改）：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The str.buf macro will allocate storage for a string that can hold a maximum
    of maxSize characters (plus a zero-terminating byte). The .align directive ensures
    that the object begins on a 16-byte boundary (2⁴). It initializes the first word
    of the structure (string.maxlen) with maxSize passed as the argument. It creates
    an empty string by initializing the second 4 bytes (the string.len field) with
    0\. Finally, it allocates sufficient storage for maxSize + 1 characters (for the
    string data and a zero-terminating byte, initializing them to zeros) and additional
    storage to ensure that the whole data structure (including the string.maxlen and
    string.len fields) consumes a multiple of 16 bytes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: str.buf 宏将为一个字符串分配存储空间，该字符串最多可以容纳 maxSize 个字符（加一个零终止字节）。.align 指令确保对象从 16 字节边界开始（2⁴）。它将结构的第一个字（string.maxlen）初始化为传递的
    maxSize 参数。它通过将结构的第二个 4 字节（string.len 字段）初始化为 0 来创建一个空字符串。最后，它为 maxSize + 1 个字符（包括字符串数据和一个零终止字节，且初始化为零）分配足够的存储空间，并额外分配存储空间以确保整个数据结构（包括
    string.maxlen 和 string.len 字段）占用 16 字节的倍数。
- en: 'Here’s an example use of the str.buf macro:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 str.buf 宏的一个示例：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The str.literal macro also creates string buffers, but instead of initializing
    it with the empty string, you can specify a string literal in the macro:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: str.literal 宏也会创建字符串缓冲区，但它会初始化为空字符串，而你可以在宏中指定一个字符串字面值：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that str.literal will initialize both the string.maxlen and string.len
    fields with the actual size of the string literal you supply.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，str.literal 会使用你提供的字符串字面值的实际大小初始化 string.maxlen 和 string.len 字段。
- en: This string data type has one small issue. Although the entire structure is
    aligned on a 16-byte boundary—and the whole structure is a multiple of 16 bytes
    long, at least when you create the buffers with the str.buf and str.literal macros—the
    first character of string data is actually at an address that is not a multiple
    of 16 (though it is a multiple of 8). To process string data 16 bytes at a time,
    you must either make a special case of the first 8 bytes or add another 8 bytes
    to the beginning of the structure (some additional fields or just 8 padding bytes).
    In the next section, you’ll see a modification of these two macros that adds an
    extra field for this purpose.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符串数据类型有一个小问题。虽然整个结构在16字节边界上对齐——并且整个结构长度是16字节的倍数，至少当你通过str.buf和str.literal宏创建缓冲区时——但是字符串数据的第一个字符实际上位于一个不是16的倍数的地址（尽管它是8的倍数）。为了每次处理16字节的字符串数据，你必须特别处理前8个字节，或者在结构的开头再添加8个字节（一些附加字段或只是8个填充字节）。在下一节中，你将看到这两个宏的修改，增加了一个额外的字段来解决这个问题。
- en: 14.2.1 Dynamic String Allocation
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.1 动态字符串分配
- en: As long as you use only the str.buf and str.literal macros to allocate storage
    for string variables, you don’t have to worry about alignment and MMU page issues;
    your string data structures will always be allocated on a 16-byte boundary (because
    of the .align 4 statement) and will always be a multiple of 16 bytes long. However,
    if you want to dynamically allocate storage for your strings (using the C stdlib
    malloc() function, for example), you must deal with data alignment and padding
    issues yourself.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你仅使用str.buf和str.literal宏为字符串变量分配存储，你就不需要担心对齐和MMU页面问题；你的字符串数据结构将始终在16字节边界上分配（因为.align
    4语句）并且始终是16字节的倍数长度。然而，如果你想为字符串动态分配存储（例如使用C标准库的malloc()函数），你必须自己处理数据对齐和填充问题。
- en: The C stdlib malloc() function makes no promises about the storage it allocates,
    other than it will return a pointer to *at least* the amount of storage you’ve
    requested if the function succeeds. In particular, the C stdlib doesn’t make any
    guarantees about the alignment of the storage you’ve requested. Also, malloc()
    may allocate a few bytes more than you’ve requested, but you can never count on
    this. If you want your storage to be allocated on a certain byte boundary (such
    as a 16-byte boundary), you’ll have to handle this yourself.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: C标准库的malloc()函数对于它分配的存储没有做任何承诺，除了如果函数成功，它将返回一个指向*至少*你请求的存储量的指针。特别地，C标准库并不保证你请求的存储会有特定的对齐方式。此外，malloc()可能会分配比你请求的多一些字节，但你不能依赖这一点。如果你希望存储按某个字节边界（例如16字节边界）进行分配，你必须自己处理。
- en: 'If you can’t guarantee that malloc() returns a properly aligned block, you
    can create a str.alloc function that does this for you:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法保证malloc()返回一个正确对齐的内存块，你可以创建一个str.alloc函数来为你处理：
- en: 1.  On entry, add 16 to the requested storage size to make room for any needed
    padding bytes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在入口处，将请求的存储大小加16，以便为任何需要的填充字节留出空间。
- en: 2.  Call the malloc() function with the new allocation size.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 调用malloc()函数并传递新的分配大小。
- en: 3.  Save the pointer that malloc() returns (you will need it to free the storage
    later).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 保存malloc()返回的指针（你稍后将需要它来释放存储）。
- en: 4.  Add 15 to the pointer and clear the LO 4 bits of the sum; then add 16 so
    the pointer contains the address of the first character position in the string.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将指针加15，并清除和总和的低4位；然后加16，使指针包含字符串中第一个字符位置的地址。
- en: 5.  Set the maxlen field as appropriate.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要设置maxlen字段。
- en: 6.  Initialize the len field to 0.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将len字段初始化为0。
- en: 7.  Store a zero-terminating byte at the first character position (to create
    an empty string).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个字符位置存储一个零终止字节（以创建一个空字符串）。
- en: 8.  Return the pointer to the first character position as the str.malloc result.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向第一个字符位置的指针作为str.malloc的结果。
- en: 'A function that deallocates the string storage is much simpler: all you need
    to do is fetch the allocated pointer (saved during the str.alloc call), then call
    the C stdlib free() function to free the storage. From where do you retrieve the
    allocated pointer value? The best place to keep it is within the string object
    data structure itself, as accomplished in the following modification of the string
    structure:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个释放字符串存储的函数要简单得多：你需要做的就是获取分配的指针（在str.alloc调用期间保存），然后调用C标准库的free()函数来释放存储。你从哪里获取已分配的指针值？最好将其保存在字符串对象的数据结构中，以下是字符串结构的修改方式：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The header fields now consume 16 bytes, so the string.chars field will start
    on a 16-byte aligned boundary (assuming the whole structure is on a 16-byte boundary).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，头字段占用了16个字节，因此string.chars字段将开始于16字节对齐的边界上（假设整个结构体都在16字节对齐的边界上）。
- en: 'Before providing the code to implement str.alloc and str.free, I’ll introduce
    one other useful string constructor function that str.alloc will use: str.bufInit.
    Its purpose is similar to the str.buf macro insofar as it initializes a memory
    buffer to hold a string object, but while you use str.buf to declare a static
    object in memory during assembly, str.bufInit allows you to initialize a block
    of memory at runtime. The str.bufInit function does the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供实现str.alloc和str.free的代码之前，我将介绍另一个str.alloc将使用的有用字符串构造函数：str.bufInit。它的目的类似于str.buf宏，都是用于初始化一个内存缓冲区来保存字符串对象，但当你在汇编期间使用str.buf来声明一个静态对象时，str.bufInit允许你在运行时初始化一块内存。str.bufInit函数的作用如下：
- en: Adjusts the pointer passed to it so that the address held in the pointer is
    16-byte aligned (adding 0 to 15 to the pointer’s value if it is not already 16-byte
    aligned).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整传入的指针，以确保指针中存储的地址是16字节对齐的（如果指针的值没有16字节对齐，则向指针的值添加0到15）。
- en: Initializes the string.allocPtr field to 0 (NULL) to differentiate the buffer
    from one created by str.alloc.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将string.allocPtr字段初始化为0（NULL），以区分由str.alloc创建的缓冲区。
- en: Computes the string.maxlen field value based on the buffer size passed to the
    function, subtracting any padding bytes needed to achieve 16-byte alignment, as
    well as the 16 bytes required by the header field and any additional bytes needed
    to ensure that the whole structure is a multiple of 16 bytes long.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据传入函数的缓冲区大小计算string.maxlen字段的值，减去为了实现16字节对齐所需的填充字节，以及头字段所需的16字节和确保整个结构体长度为16字节倍数所需的额外字节。
- en: Initializes the string.len field to 0 and stores a zero-terminating byte at
    the beginning of the character buffer area.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将string.len字段初始化为0，并在字符缓冲区区域的开始处存储一个零终止字节。
- en: 'Before presenting the implementation of these string functions, a quick sidetrack
    is necessary to present the volatile_save structure the code will use to preserve
    registers. This structure appears in the *aoaa.inc* header file and takes the
    following form:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示这些字符串函数的实现之前，需要稍作旁白，介绍代码将使用的volatile_save结构体，以便保存寄存器。这个结构体出现在*aoaa.inc*头文件中，形式如下：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Listing 14-1 contains the str.alloc and str.free functions, as well as updates
    to the str.buf and str.literal macros (to handle the string.allocPtr field). The
    listing uses the string structure (I gave earlier in this section) that includes
    the string.allocPtr field. For strings whose storage is allocated dynamically,
    this field will contain the allocation pointer that str.free will use when deallocating
    the string’s storage. For string objects that were not created on the heap, this
    field will contain NULL (0). This structure is the first major piece of code appearing
    in the listing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-1包含了str.alloc和str.free函数，以及对str.buf和str.literal宏的更新（用于处理string.allocPtr字段）。该列表使用了我在本节前面给出的字符串结构，其中包括string.allocPtr字段。对于动态分配存储的字符串，此字段将包含分配指针，str.free将在释放字符串存储时使用该指针。对于未在堆上创建的字符串对象，此字段将包含NULL（0）。这个结构体是列表中第一个出现的重要代码部分。
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The str.buf and str.literal macros contain minor modifications (to the macros
    with the same name given earlier in this chapter) that include storage for the
    allocPtr field:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: str.buf和str.literal宏包含一些小的修改（与本章前面给出的同名宏），这些修改包括为allocPtr字段分配存储空间：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that both of these macros will initialize this field to NULL (0).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两个宏都会将此字段初始化为NULL（0）。
- en: 'The next section of the listing is the code section, beginning with the usual
    getTitle function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的下一部分是代码部分，从常见的getTitle函数开始：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, the str.bufInit function initializes a memory buffer for use as a string
    variable:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，str.bufInit函数初始化一个内存缓冲区，用作字符串变量：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function expects a pointer to the buffer in X0 along with the buffer length
    in W1\. It initializes the fields of the string object and returns a pointer to
    the string object in X0\. The code begins by clearing the HO 32 bits of X1, so
    the code can work with 64-bit values ❶. It then adjusts the pointer passed in
    X0 to make it 16-byte aligned, by adding 16 and clearing the LO 4 bits of the
    sum ❷. This adjusts X0 to point at the next higher 16-byte aligned address if
    it wasn’t already so aligned.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数期望X0中传入一个指向缓冲区的指针，以及W1中的缓冲区长度。它初始化字符串对象的字段，并返回指向字符串对象的指针在X0中。代码首先清除X1的高32位，以便代码可以处理64位值❶。然后，它调整X0中传入的指针，使其对齐到16字节，通过加上16并清除和的低4位❷。如果该指针尚未对齐到16字节地址，这将使X0指向下一个较高的16字节对齐地址。
- en: Next, the code adjusts the pointer to contain the address of the first byte
    of character data in the string (so that the other fields have negative offsets
    from the pointer) ❸. It then computes the new maxlen value by subtracting out
    the padding bytes (for 16-byte alignment) and the size of the fields preceding
    the character data ❹. The function returns an error if this difference is a negative
    value.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码调整指针，使其包含字符串中第一个字节字符数据的地址（这样其他字段相对于该指针的偏移量为负）❸。然后，代码通过减去填充字节（用于16字节对齐）和字符数据之前字段的大小来计算新的maxlen值❹。如果这个差值为负数，函数会返回错误。
- en: The code ensures that the length of the character data is a multiple of 16 bytes
    (possibly further reducing the maxlen size) by clearing the LO 4 bits of the length
    value ❺. The function returns an error if the maxlen value turns out to be 0.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过清除长度值的低4位❺，确保字符数据的长度是16字节的倍数（可能会进一步减小maxlen的大小）。如果maxlen值为0，函数将返回错误。
- en: Finally, the code initializes the fields of the string object (producing an
    empty string) ❻. Note that
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码初始化字符串对象的字段（生成一个空字符串）❻。请注意
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: clears the carry flag (successful return) because adding 0 to anything never
    produces an unsigned overflow (carry). Also note that
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 清除进位标志（成功返回），因为将0加到任何值上永远不会产生无符号溢出（进位）。还要注意
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: always sets the carry flag because the carry will be set after a comparison
    if the left value is greater than or equal to (higher than or the same as) the
    right value. Of course, for unsigned values, any value will always be greater
    than or equal to 0.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 总是设置进位标志，因为在比较之后如果左值大于或等于（大于或相等于）右值，进位标志将被设置。当然，对于无符号值，任何值总是大于或等于0。
- en: Two functions in Listing 14-1, str.alloc and str.free, will call the C stdlib
    malloc() and free() functions. The str.alloc and str.free functions preserve all
    registers they modify that don’t contain explicit return values. However, because
    the malloc() and free() functions follow the ARM ABI, they are allowed to overwrite
    values in the volatile register set. To preserve the register values, the str.alloc
    and str.free functions must preserve the volatile registers by using the volatile_save
    structure.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例14-1中的两个函数，str.alloc和str.free，将调用C标准库中的malloc()和free()函数。str.alloc和str.free函数保存它们修改的所有寄存器（这些寄存器不包含显式的返回值）。然而，由于malloc()和free()函数遵循ARM
    ABI，它们被允许覆盖volatile寄存器集中的值。为了保存寄存器值，str.alloc和str.free函数必须通过使用volatile_save结构来保存volatile寄存器。
- en: 'Up next is the str.alloc function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是str.alloc函数：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The local variable declaration str_alloc.vsave (type volatile_save ❶) will
    hold the preserved values of the volatile registers. Unfortunately, this structure
    is so large that you cannot directly access fields by using the [FP, #offset]
    addressing mode. Therefore, the code computes the address of the volatile_save.x0x1
    field into X1 and stores successive registers into the block pointed at by X1
    ❷. This code must initialize X1 prior to storing anything in str_alloc.vsave,
    so it first preserves X1 in a different local variable. Because the function returns
    the result in X0 and has to save X1 in a different location, this code doesn’t
    actually use the volatile_save.x0x1 field of str_alloc.vsave.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '本地变量声明str_alloc.vsave（类型为volatile_save ❶）将保存volatile寄存器的值。不幸的是，这个结构非常大，无法直接使用[FP,
    #offset]寻址模式访问字段。因此，代码将volatile_save.x0x1字段的地址计算到X1中，并将连续的寄存器存储到X1指向的块中❷。这段代码必须在将任何内容存储到str_alloc.vsave之前先初始化X1，因此它首先在另一个本地变量中保存X1。由于函数返回结果在X0中并且必须将X1保存在不同的位置，因此这段代码实际上并没有使用str_alloc.vsave的volatile_save.x0x1字段。'
- en: The code saves all the volatile registers except X0 and X1 ❸. It uses the pre-increment
    addressing mode, so it skips over the volatile_save.x0x1 field when writing the
    X2 and X3 registers to the structure.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 代码保存了除 X0 和 X1 ❸ 之外的所有易变寄存器。它使用预增寻址模式，因此在将 X2 和 X3 寄存器写入结构时，会跳过 volatile_save.x0x1
    字段。
- en: Next, the code computes a string allocation size by adding 16 to maxlen (to
    cover the extra fields in the string data structure) ❹; it also adjusts the allocation
    size to be a multiple of 16 (greater than or equal to the requested size plus
    16). This ensures that the character data area is a multiple of 16 bytes long,
    so string-handling code can manipulate 16 bytes at a time without worrying about
    accessing data beyond the allocated storage.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码通过将 16 加到 maxlen 来计算字符串分配的大小（以覆盖字符串数据结构中的额外字段）❹；它还调整分配的大小，使其成为 16 的倍数（大于或等于请求的大小加
    16）。这确保字符数据区域的长度是 16 字节的倍数，因此字符串处理代码可以一次操作 16 字节，而不必担心访问超出分配存储的区域。
- en: The call to malloc() ❺ allocates the storage for the string object. This code
    checks for a NULL (0) return result and returns an error if malloc() fails. On
    success, the code initializes the fields of the string object and then returns
    a pointer to the object in X0 (with the carry clear on a successful call) ❻. Finally,
    the code restores all the volatile registers (except X0, which contains the function
    result) ❼.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对 malloc() ❺ 的调用为字符串对象分配存储空间。该代码检查返回结果是否为 NULL（0），如果 malloc() 失败，则返回错误。成功时，代码初始化字符串对象的字段，然后返回指向该对象的指针到
    X0（在成功调用时，进位标志清除）❻。最后，代码恢复所有易变寄存器（X0 除外，因为它包含了函数结果）❼。
- en: 'Next, the code includes the str.free function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码包括了 str.free 函数：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The str.free function also calls a C stdlib function and therefore must preserve
    all the volatile registers. In fact, the preservation code ❶ ❺ makes up the bulk
    of the statements in this function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: str.free 函数还调用了 C 标准库函数，因此必须保留所有易变寄存器。实际上，保留寄存器的代码 ❶ ❺ 占据了该函数的大部分语句。
- en: The caller passes the address of an assembly string object in the X0 register
    to this function. However, this is not the address that the code passes to the
    C stdlib free() function; instead, this code fetches the address found in the
    string.allocPtr field to pass on to free() ❷.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者将汇编字符串对象的地址传递到 X0 寄存器中传递给此函数。然而，这不是代码传递给 C 标准库 free() 函数的地址；相反，代码获取的是在 string.allocPtr
    字段中找到的地址，并将其传递给 free() ❷。
- en: Before actually calling free(), the code first checks whether this pointer value
    is NULL ❸. A NULL string.allocPtr value means that the string wasn’t originally
    allocated with a call to str.alloc. If that’s the case, str.free simply returns
    (without registering an error), allowing code to call this function on dynamically
    and statically allocated objects. This is sometimes convenient when an arbitrary
    string pointer has been passed to a function that frees the storage without knowing
    how the storage was originally created.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际调用 free() 之前，代码首先检查该指针值是否为 NULL ❸。一个 NULL 的 string.allocPtr 值意味着字符串最初并没有通过调用
    str.alloc 分配内存。如果是这种情况，str.free 直接返回（不注册错误），允许代码在动态和静态分配的对象上调用此函数。当一个任意的字符串指针被传递到一个不知道原始存储方式的函数时，这有时很方便。
- en: Finally, the str.free function calls the free() function ❹ to return the storage
    to the heap.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，str.free 函数调用 free() 函数 ❹ 来将存储空间归还给堆。
- en: 'Here’s a main program example (along with some data) that tests the functions
    appearing in Listing 14-1:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个主程序示例（以及一些数据），用来测试清单 14-1 中出现的函数：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The asmMain function provides a few simple examples of calls to the str.alloc,
    str.free, and str.bufInit functions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: asmMain 函数提供了几个简单的示例，演示了如何调用 str.alloc、str.free 和 str.bufInit 函数。
- en: 'Here’s the build command for Listing 14-1 and the sample program output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是清单 14-1 的构建命令和示例程序输出：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, this code properly copied the static string to the dynamically
    allocated string.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这段代码正确地将静态字符串复制到了动态分配的字符串中。
- en: 14.2.2 String Copy Function
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.2 字符串复制函数
- en: 'Listing 14-1 demonstrates the lack of perhaps the most important string function
    of all: one that copies character data from one string to another. This section
    presents str.cpy, the second-most-used string function (after string length, in
    my experience), which makes a copy of the data in one string variable and stores
    that data in a second string variable.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 14-1 演示了可能最重要的字符串函数的缺失：一个将字符数据从一个字符串复制到另一个字符串的函数。本节介绍了 str.cpy，这是第二常用的字符串函数（在我看来，仅次于字符串长度函数），它将一个字符串变量中的数据复制并存储到另一个字符串变量中。
- en: 'The str.cpy function must do the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: str.cpy函数必须执行以下操作：
- en: Compare the length of the source string against the maximum length of the destination
    string and return an error if the source string will not fit in the destination
    string variable.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较源字符串的长度与目标字符串的最大长度，如果源字符串无法容纳到目标字符串变量中，则返回错误。
- en: Copy the len field from the source string to the destination string.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将len字段从源字符串复制到目标字符串。
- en: Copy len + 1 characters from the source string to the destination string, which
    will also copy the zero-terminating byte.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从源字符串复制len + 1个字符到目标字符串，这也会复制零终止字节。
- en: Listing 14-2 provides the implementation of this function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-2提供了该函数的实现。
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The str.cpy function is straightforward and efficient, almost entirely because
    of the design of the string data type (in particular, the alignment and padding
    requirements of the string). The code first checks to ensure that the current
    length of the source string is less than or equal to the maximum length allowed
    for the destination string ❶. If the source string’s length is too large, control
    transfers to the end of the function and it returns. The comparison will set the
    carry flag if the source length is “higher or same” as the destination maximum
    length. Therefore, this comparison automatically sets the carry flag to indicate
    a *string overflow* error if it branches because the string.len field is higher
    than the string.maxlen field. Because the new destination string will be a copy
    of the source string, the code then sets the destination string.len field to the
    source string’s length ❷.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: str.cpy函数直截了当且高效，几乎完全得益于字符串数据类型的设计（特别是字符串的对齐和填充要求）。代码首先检查以确保源字符串的当前长度小于或等于目标字符串允许的最大长度❶。如果源字符串的长度过大，控制权将转移到函数的末尾，并返回。该比较会在源长度“大于或等于”目标最大长度时设置进位标志。因此，如果字符串.len字段大于字符串.maxlen字段，比较自动设置进位标志以指示*字符串溢出*错误。这是因为新的目标字符串将是源字符串的副本，因此代码接着将目标字符串.len字段设置为源字符串的长度❷。
- en: The code is responsible for copying the character data from the source string
    to the destination string ❸. This is a repeat...until loop, so it always copies
    16 bytes, even if the string length is 0\. That’s okay because the string data
    type always ensures that the character storage area is a multiple of 16 bytes
    long (including space for a zero-terminating byte). This loop may end up copying
    just the zero-terminating byte and 15 bytes of garbage data, but it will not access
    memory beyond the end of the string object’s storage.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 代码负责将字符数据从源字符串复制到目标字符串❸。这是一个重复...直到循环，因此它总是复制16个字节，即使字符串长度为0也是如此。没关系，因为字符串数据类型始终确保字符存储区是16字节的倍数（包括零终止字节的空间）。这个循环可能最终只会复制零终止字节和15个垃圾数据字节，但它不会访问超出字符串对象存储区域之外的内存。
- en: For each of the 16 bytes the loop copies ❸, the code decrements the length counter
    (W4) by 16\. The subs instruction sets the flags exactly as a cmp instruction
    would, so the bhi instruction repeats the loop as long as the value in W4 is greater
    than 16 (prior to the subs instruction). If the string’s length is a multiple
    of 16 bytes long, this loop will terminate after copying the last 16 bytes of
    the string (when W4 decrements to 0). In this situation, the beq instruction ❹
    transfers control to the code that will append the zero-terminating byte.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每16个字节，循环会复制❸，代码会将长度计数器（W4）减少16。subs指令的作用与cmp指令完全相同，因此bhi指令会在W4中的值大于16时重复执行循环（在subs指令之前）。如果字符串的长度是16字节的倍数，这个循环会在复制完最后16个字节后终止（当W4递减到0时）。在这种情况下，beq指令❹会将控制权转移到代码中，以附加零终止字节。
- en: If the string’s length is not an integral multiple of 16, subtracting 16 will
    produce a result greater than 0 but less than 16 (meaning some characters remain
    left to copy from the source to the destination). Therefore, the code will fall
    through to the ldr/str instructions and copy the remaining bytes of the string
    (plus some garbage bytes).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串的长度不是16的整数倍，减去16后会得到一个大于0但小于16的结果（意味着还有一些字符需要从源字符串复制到目标字符串）。因此，代码会继续执行到ldr/str指令，并复制字符串中剩余的字节（加上一些垃圾字节）。
- en: Finally, the code will store a zero-terminating byte to the end of the string
    ❺ in the event the previous ldr/str instructions didn’t copy that byte along with
    the character data.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码将把零终止字节存储到字符串的末尾❺，以防前面的ldr/str指令没有将该字节与字符数据一起复制过来。
- en: NOTE
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Technically, the* beq *instruction in Listing 14-2 is unnecessary. If the
    string’s length is an exact multiple of 16 bytes long, at least 1 additional byte
    must be copied: the zero-terminating byte. Therefore, the data structure is guaranteed
    to contain at least 16 additional bytes, so falling through to the next pair of
    load and store instructions won’t create a problem. As an interesting experiment,
    you might determine whether removing the* beq *instruction improves or hurts the
    algorithm’s performance.*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*从技术上讲，* beq *指令在清单14-2中是多余的。如果字符串的长度恰好是16字节的倍数，至少必须复制1个额外的字节：零终止字节。因此，数据结构保证包含至少16个附加字节，因此跳过到下一个加载和存储指令对程序不会造成问题。作为一个有趣的实验，你可以确定移除*
    beq *指令是否会改善或损害算法的性能。*'
- en: 'Here’s the build command and sample program output for the code in Listing
    14-2:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是清单14-2中代码的构建命令和示例程序输出：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Although this string is shorter than 16 characters long and doesn’t fully test
    str.cpy, I’ve run this program with different source strings to verify that it
    works for larger strings.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个字符串短于16个字符，并没有完全测试str.cpy，但我已经用不同的源字符串运行了这个程序，以验证它是否适用于更长的字符串。
- en: '#### 14.2.3 String Comparison Function'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 14.2.3 字符串比较函数'
- en: 'After copying strings, comparing strings is the string function you’ll likely
    use most often. To compare two character strings, use the following steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在复制字符串之后，比较字符串是你可能最常用的字符串函数。要比较两个字符字符串，请使用以下步骤：
- en: 1.  Extract a character at corresponding indices from both strings.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  从两个字符串的对应索引提取一个字符。
- en: 2.  Compare the two characters. If they are not equal, the comparison is complete
    and the result of the string comparison is the result of this character comparison
    (not equal, less than, or greater than). If they are equal and not zero, repeat
    step 1.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  比较这两个字符。如果它们不相等，比较完成，字符串比较的结果就是该字符比较的结果（不相等、小于或大于）。如果它们相等且不为零，重复步骤1。
- en: 3.  If the two characters are both 0 bytes, the comparison is finished, and
    the two strings are equal.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  如果两个字符都是0字节，比较结束，两个字符串相等。
- en: This algorithm works for zero-terminated strings (and, because they are also
    zero-terminated, for the assembly language string format given in this chapter).
    Note that the comparison algorithm does not use the string-length value.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法适用于零终止字符串（并且由于它们也是零终止的，它适用于本章中给出的汇编语言字符串格式）。请注意，比较算法不使用字符串长度值。
- en: 'Here’s a naive version of this string comparison in ARM64 assembly language
    that assumes X0 and X1 point at the string data to compare:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单版本的字符串比较，使用ARM64汇编语言，假设X0和X1指向要比较的字符串数据：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you saw with the strlen() function, processing multiple bytes at once using
    64- or 128-bit registers is usually much faster. Can you improve performance by
    using vector registers? The big problem with this is that vector comparisons check
    for a specific comparison (lt, le, eq, ne, gt, or ge). They don’t set the condition
    code flags, so you can use the conditional branches, which is what most programmers
    would prefer. That being the case, comparing eight characters at a time using
    64-bit general-purpose registers is probably the best solution.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在strlen()函数中看到的，使用64位或128位寄存器一次处理多个字节通常要快得多。你能通过使用向量寄存器来提高性能吗？这样做的一个大问题是，向量比较会检查特定的比较条件（lt,
    le, eq, ne, gt或ge）。它们不会设置条件码标志，因此你可以使用条件分支，这也是大多数程序员更倾向使用的方式。既然如此，使用64位通用寄存器一次比较八个字符可能是最好的解决方案。
- en: Given the efficiency of the glibc strlen() function, you might wonder whether
    its strcmp() function is also good. Listing 14-3 presents this function, with
    its operation explained in the comments.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到glibc的strlen()函数的效率，你可能会想知道它的strcmp()函数是否也同样高效。清单14-3展示了这个函数，并在注释中解释了它的操作。
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The majority of the complexity is due to the code being written to handle string
    data that is not aligned to an 8-byte boundary. This string-comparison code could
    be written more simply if it could assume that the source and destination strings
    were always aligned on an 8-byte boundary. Because the assembly language string
    object is, by definition, always aligned on a 16-byte boundary, it is possible
    to write a more efficient comparison function for those strings. Listing 14-4
    provides such a str.cmp function.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数复杂性源于代码是为处理未对齐到8字节边界的字符串数据而编写的。如果可以假设源字符串和目标字符串始终对齐到8字节边界，这段字符串比较代码可以编写得更简单。由于汇编语言中的字符串对象在定义上始终对齐到16字节边界，因此可以为这些字符串编写更高效的比较函数。列表14-4提供了这样的str.cmp函数。
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The str.cmp function does not modify the X0 or X1 registers, but it will modify
    X2 through X7, so this code begins by preserving these register values ❶. It then
    copies the values in X0 and X1 into X2 and X3 (respectively), which it will use
    in the code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: str.cmp函数不会修改X0或X1寄存器，但它会修改X2到X7寄存器，因此这段代码首先通过保存这些寄存器的值来保护这些寄存器 ❶。接着，它将X0和X1中的值分别复制到X2和X3中，后续的代码会使用这些值。
- en: When comparing the strings, str.cmp will compare only to the length of the shorter
    string. The code computes the minimum length of the two strings ❷, leaving the
    result in W6\. If the two strings are equal to the length of the shorter string,
    the shorter string is considered less than the longer string.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较字符串时，str.cmp只会比较到较短字符串的长度。代码会计算两个字符串的最小长度 ❷，并将结果保存在W6中。如果两个字符串的长度等于较短字符串的长度，则较短的字符串被认为小于较长的字符串。
- en: The cmp8 loop compares the characters in the string 8 bytes at a time ❸. Strings
    are intrinsically a *big-endian* data structure, meaning the lower-order bytes
    in the string have the most-significant values. Therefore, you cannot simply load
    8 successive bytes into a pair of 64-bit registers and compare those registers;
    that would produce a little-endian comparison result. To resolve this issue, the
    code executes two rev instructions to swap the bytes in the two 64-bit registers
    prior to comparing them, resulting in a big-endian comparison.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: cmp8循环每次比较8字节的字符 ❸。字符串本质上是*大端*数据结构，意味着字符串中的低位字节具有最高的值。因此，你不能简单地将8个连续的字节加载到一对64位寄存器中并直接比较这些寄存器；那样会产生小端比较结果。为了解决这个问题，代码在比较之前执行两条rev指令，将两个64位寄存器中的字节交换，从而实现大端比较。
- en: After comparing the two dwords, the code branches to the return code if those
    dwords are not equal. At that point, the ARM condition codes will hold the result
    of the comparison. If the two dwords are equal, the cmp8 loop must repeat until
    it has exhausted all the characters or finds a pair of dwords that are not equal.
    The code subtracts 8 from W6 and repeats if the value prior to the subtraction
    was greater than or equal to 8 (remember, subs and cmp set the flags the same
    way) ❹.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较完两个双字后，如果这两个双字不相等，代码会跳转到返回代码的位置。此时，ARM条件码将保存比较结果。如果两个双字相等，cmp8循环必须重复，直到所有字符都比较完或者找到一对不相等的双字。代码从W6中减去8并重复执行，如果减法前的值大于或等于8（记住，subs和cmp会以相同方式设置标志）
    ❹。
- en: Because this code subtracts 8 from W6 before comparing the corresponding characters,
    if W6 winds up with 0, eight characters still remain to compare. That’s why this
    code repeats even when subtracting 8 produces a 0 result.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这段代码在比较相应字符之前会从W6中减去8，所以即使W6的值为0，仍然会剩下八个字符进行比较。这就是为什么即使减去8后结果为0，这段代码仍然会重复执行的原因。
- en: If the code falls down to ❺, the W6 contains a negative result. The code adds
    8 to this value to determine the number of characters it must still process. If
    the result is 0, the strings are the same length and all characters in the string
    are equal; in that case, the code exits (with the flags already containing appropriate
    values). If the result is nonzero, the code processes the remaining characters
    in the two strings one character at a time ❻. (Four instructions per character,
    for an average of four characters per string, assuming random string lengths,
    is usually faster than attempting to zero out the excess bytes and compare 8 bytes
    at a time.)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码进入到 ❺，则W6包含一个负数结果。代码将8加到这个值上，以确定它仍然需要处理的字符数。如果结果为0，说明两个字符串长度相同，并且所有字符都相等；此时，代码退出（并且标志已经包含适当的值）。如果结果不为0，代码会逐个字符处理这两个字符串中的剩余字符
    ❻。（假设字符串长度随机，每个字符处理四条指令，对于平均每个字符串四个字符的情况，这通常比尝试清除多余字节并一次比较8字节要更快。）
- en: If the code transfers or drops through to cmpLens ❼, the strings were equal
    to the length of the shorter string. At this point, the code determines the result
    of the comparison by comparing the strings’ lengths.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码跳转到或通过cmpLens❼，则表示两个字符串在较短字符串的长度处相等。在此时，代码通过比较两个字符串的长度来确定比较结果。
- en: The main program compares several strings to test the str.cmp function. The
    prtResult function ❽ is a short utility function that prints the result of the
    comparisons.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序比较几个字符串来测试str.cmp函数。prtResult函数❽是一个简短的实用函数，用于打印比较结果。
- en: NOTE
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*This code would be slightly more efficient if it preserved X0 and X1 rather
    than X2 and X3, then used X0 and X1 rather than X2 and X3\. However, I left X0
    and X1 alone because during development I used* printf() *to print some debugging
    messages. Feel free to change this code to use X0/X1 rather than X2/X3 if the
    two extra instructions (those that move X0 and X1 into X2 and X3) bother you.*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果保留X0和X1而不是X2和X3，代码会稍微高效一点，然后使用X0和X1而不是X2和X3。然而，我保留了X0和X1，因为在开发过程中我使用了* printf()
    *来打印一些调试信息。如果两个额外的指令（那些将X0和X1移动到X2和X3的指令）让你不舒服，随时可以修改这段代码，使用X0/X1而不是X2/X3。*'
- en: 'As was the case for the glibc strcmp() function, the str.cmp function expects
    pointers to the two strings to compare in X0 and X1\. The *left* string is X0,
    and the *right* string is X1\. Left and right have to do with their position in
    a comparison expression. The following example demonstrates the positions of the
    two strings in an if statement:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 和glibc的strcmp()函数一样，str.cmp函数期望在X0和X1中传入指向要比较的两个字符串的指针。*左侧*字符串是X0，*右侧*字符串是X1。左侧和右侧与它们在比较表达式中的位置相关。下面的示例演示了两个字符串在if语句中的位置：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The strcmp() function returns a result in X0 indicating the result of the comparison:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: strcmp()函数返回一个结果到X0，表示比较结果：
- en: If X0 is negative, the left string (X0) is less than the right string (X1).
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果X0为负，则左侧字符串（X0）小于右侧字符串（X1）。
- en: If X0 is 0, the two strings are equal.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果X0为0，则两个字符串相等。
- en: If X0 is positive, the left string is greater than the right string.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果X0为正，则左侧字符串大于右侧字符串。
- en: The str.cmp function, on the other hand, returns the comparison result in the
    condition code flags, so you can use the conditional branch instructions upon
    return to test the result.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，str.cmp函数会将比较结果返回到条件代码标志中，因此你可以在返回后使用条件分支指令来测试结果。
- en: 'Here’s the build command and sample output for Listing 14-4:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是清单14-4的构建命令和示例输出：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, str.cmp returned the proper results for the test strings.  ####
    14.2.4 Substring Function'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '如你所见，str.cmp返回了正确的测试字符串结果。 #### 14.2.4 子字符串函数'
- en: 'The last ASCII example I’ll provide in this chapter is the substring function
    str.substr. A typical substring function extracts a portion of the characters
    from a string, creating a new string from the substring. It typically has four
    parameters: a pointer to a source string, an index into the substring where the
    extraction is to begin, a length specifying the number of characters to copy from
    the source, and a pointer to a destination string.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我提供的最后一个ASCII示例是子字符串函数str.substr。一个典型的子字符串函数从字符串中提取一部分字符，创建一个由子字符串组成的新字符串。它通常有四个参数：指向源字符串的指针、子字符串提取起始位置的索引、指定从源字符串中复制字符的长度以及指向目标字符串的指针。
- en: 'The substring operation has several issues:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 子字符串操作有几个问题：
- en: You can’t assume that the source characters are aligned on a 16-byte boundary.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能假设源字符是按16字节边界对齐的。
- en: The specified starting index might be beyond the length of the source string.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定的起始索引可能超出源字符串的长度。
- en: The specified substring length might extend beyond the end of the source string.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定的子字符串长度可能超出源字符串的末尾。
- en: The length of the substring might exceed the maximum length of the destination
    string.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子字符串的长度可能超过目标字符串的最大长度。
- en: The first issue is often impossible to deal with. Most of the time, either the
    source characters or the destination characters will have an unaligned address.
    The str.substr code in this section will choose to keep the destination address
    aligned on a 16-byte boundary (which it gets by default). The function must carefully
    check the length while copying data to ensure that it doesn’t read any data beyond
    the end of the source-string data structure.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题通常是无法处理的。大多数情况下，源字符或目标字符的地址将是不对齐的。本节中的 `str.substr` 代码将选择保持目标地址在 16 字节边界上对齐（默认情况下会得到这个对齐）。在复制数据时，函数必须仔细检查长度，以确保它不会读取超过源字符串数据结构末尾的数据。
- en: 'You can handle the second issue in two ways: either return an error code without
    copying any data or simply store an empty string into the destination. This latter
    solution is often the most convenient, and I rely on it in this section’s code.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式处理第二个问题：要么返回一个错误代码而不复制任何数据，要么简单地将空字符串存储到目标中。后者通常是最方便的解决方案，我在本节的代码中依赖于它。
- en: 'Likewise, there are two ways to handle the third issue: either return an error
    code without copying any data or copy all the characters from the starting index
    to the end of the source string into the destination string. Once again, the latter
    solution is often the most convenient, and the str.substr code relies on it.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，处理第三个问题有两种方法：要么返回错误代码而不复制任何数据，要么将从起始索引到源字符串末尾的所有字符复制到目标字符串中。同样，后者通常是最方便的解决方案，`str.substr`
    代码依赖于它。
- en: The fourth issue is a bit more problematic. The str.substr code could truncate
    the string it copies, but this situation usually indicates a serious error on
    the part of the application (string overflow). Therefore, str.substr will return
    a flag in the carry to indicate success or failure.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个问题稍微复杂一些。`str.substr`代码可能会截断它复制的字符串，但这种情况通常表示应用程序发生了严重错误（字符串溢出）。因此，`str.substr`将在进位标志中返回一个标志，表示成功或失败。
- en: NOTE
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you prefer to return an error status for the second and third issues listed
    here, you can easily modify* str.substr *to accomplish this.*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你更倾向于返回第二和第三个问题的错误状态，可以很容易地修改* `str.substr` *来实现这一点。*'
- en: Listing 14-5 provides the str.substr function and a sample main program that
    tests it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 14-5 提供了 `str.substr` 函数和一个测试该函数的示例主程序。
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The str.substr function begins by finding any special cases it must handle.
    It first checks whether the starting index value is beyond the end of the source
    string; if so, the function returns the empty string as the result ❶. Next, the
    code checks whether the starting index plus the substring length would extend
    beyond the end of the source string; if so, it adjusts the length to reach to
    the end of the source string (and no farther) ❷. Finally, if the substring length
    is greater than the maximum length of the destination string, str.substr immediately
    returns with the carry flag set to indicate an error condition ❸.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.substr`函数首先通过查找必须处理的特殊情况开始。它首先检查起始索引值是否超出了源字符串的末尾；如果是，函数将返回空字符串作为结果 ❶。接下来，代码检查起始索引加上子字符串长度是否会超出源字符串的末尾；如果是，函数会将长度调整为不超过源字符串的末尾（而不会更远）
    ❷。最后，如果子字符串的长度大于目标字符串的最大长度，`str.substr`会立即返回，并将进位标志设置为表示错误条件 ❸。'
- en: If none of the special cases exist, the code can successfully copy a substring
    into the destination string. str.substr begins this process by setting the length
    of the destination string to the length of the substring ❹. The code then copies
    the substring data starting at the index position, beginning by adding the value
    of the index to the string pointer ❺.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有特殊情况，代码就可以成功地将子字符串复制到目标字符串中。`str.substr`开始此过程时，会将目标字符串的长度设置为子字符串的长度 ❹。然后，代码从索引位置开始复制子字符串数据，首先通过将索引值加到字符串指针上来开始
    ❺。
- en: The loop copies 16 bytes at a time using the V0 vector register (Q0) ❻, as long
    as there are 16 or more bytes left to copy. When fewer than 16 bytes are left
    to copy, the code drops down to ❼ and adds 16 to the remaining length value (because
    the loop subtracted 16 one too many times).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 循环每次复制 16 字节，使用 V0 向量寄存器（Q0） ❻，只要剩余的字节数是 16 字节或更多。剩余字节数少于 16 字节时，代码会跳到 ❼，并将剩余长度值加
    16（因为循环多减了一次 16）。
- en: After adding 16, W6 will contain a value in the range 0 to 15, the number of
    bytes left to copy. The code could have executed a simple loop to copy the remaining
    bytes one at a time to the destination, but that would be somewhat slow. Instead,
    I chose to execute a (simulated) switch statement to transfer control to one of
    16 labels ❽ where the code exists to carry out a straight-line, brute-force copy
    of the necessary bytes. (To reduce code size, I’ve interleaved these sections
    as much as possible, sharing various code sequences.)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在加上16后，W6将包含一个0到15之间的值，即剩余需要复制的字节数。代码本可以执行一个简单的循环，将剩余字节一个一个复制到目标位置，但那样会比较慢。相反，我选择执行一个（模拟的）`switch`语句，将控制权转移到16个标签之一❽，在这些标签的代码中执行直接的、暴力的字节复制。（为了减少代码大小，我尽可能地交错这些部分，重用各种代码序列。）
- en: Once they copy the necessary number of bytes, all these code sequences converge
    ❾ (also the location where the switch code transfers if 0 bytes are left to copy).
    This code appends a zero-terminating byte to the end of the string, clears the
    carry flag, and returns to the caller.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它们复制了所需的字节数，所有这些代码序列会汇聚到❾（这也是如果剩余字节为0时，切换代码转移的位置）。这段代码将一个零终止字节附加到字符串的末尾，清除进位标志，并返回给调用者。
- en: The code handles the special case in which str.substr returns an empty string
    because the index value was greater than the length of the source string ❿. This
    code sets the length of the destination string to 0, then transfers to ❾ to zero-terminate
    the string and return success. The asmMain function calls a special helper function
    (testSubstr) to perform various tests and print the results.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码处理了`str.substr`返回空字符串的特殊情况，因为索引值大于源字符串的长度❿。这段代码将目标字符串的长度设置为0，然后转移到❾以零终止字符串并返回成功。`asmMain`函数调用了一个特殊的辅助函数（`testSubstr`）来执行各种测试并打印结果。
- en: It is very unlikely that the start of the substring will lie on a 16-byte boundary.
    Therefore, when the function in Listing 14-5 fetches 16 bytes at a time from the
    source string, it will probably be an unaligned memory access (which is slower).
    Without writing a lot of code, you can’t do much about this other than accept
    that execution will be slightly slower. Because the accesses may not be aligned
    on a 16-byte boundary, it is important that this code copies only the specified
    number of bytes (never reading beyond the end of the source string) to ensure
    it doesn’t access an inappropriate memory page.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 子字符串的起始位置极不可能位于16字节边界上。因此，当清单14-5中的函数每次从源字符串中提取16个字节时，它很可能会发生未对齐的内存访问（这会更慢）。在不写大量代码的情况下，你对此几乎无能为力，只能接受执行会略微变慢这一事实。因为访问可能不对齐16字节边界，所以这段代码只能复制指定数量的字节（绝不读取超出源字符串结尾的内容），以确保不会访问到不合适的内存页面。
- en: 'Here is the build command and sample output for the program in Listing 14-5:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是清单14-5中程序的构建命令和示例输出：
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: While this isn’t an exhaustive test by any means, this output is sufficient
    to show the basic operation of str.substr.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这不是一个详尽无遗的测试，但这份输出足以展示`str.substr`的基本操作。
- en: 14.2.5 More String Functions
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.5 更多字符串函数
- en: 'Of course, any decent string library has many additional string functions.
    A str.len function is the most obvious function missing thus far. The implementation
    of this function should be fairly obvious: just fetch the string.len field from
    the string data structure. Even ignoring this oversight, however, there are dozens
    of other string functions you might want to use (the HLA standard library, for
    example, provides over 200 string functions).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，任何优秀的字符串库都有许多额外的字符串函数。`str.len`函数是迄今为止最明显缺失的函数。这个函数的实现应该非常直观：只需从字符串数据结构中获取`string.len`字段。即使忽略这个疏漏，仍然有几十个你可能希望使用的其他字符串函数（例如，HLA标准库提供了超过200个字符串函数）。
- en: Unfortunately, this book doesn’t have room to describe a complete set of string
    library functions. After reading this chapter, you should possess the skills needed
    to implement any string functions you need on your own. See section 14.6, “For
    More Information,” on [page 859](chapter14.xhtml#pg_859) for further resources
    to help you do so.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，本书没有空间描述完整的字符串库函数。在阅读完本章后，你应该具备自己实现任何所需字符串函数的技能。有关更多资源，可以参见第14.6节“更多信息”，位于[第859页](chapter14.xhtml#pg_859)。
- en: 14.3 The Unicode Character Set
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3 Unicode字符集
- en: All code examples up to this point in this book have assumed that strings in
    assembly language consist of sequences of ASCII characters, largely because Gas
    doesn’t directly support Unicode. However, Linux and macOS systems generally work
    with Unicode (though ASCII is a subset of Unicode). Now that you’ve seen how to
    implement string functions for ASCII characters, it’s time to expand on [Chapter
    2](chapter2.xhtml)’s cursory introduction to Unicode and discuss string functions
    for Unicode strings.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本书到目前为止的所有代码示例都假设汇编语言中的字符串是由 ASCII 字符组成的，主要是因为 Gas 并不直接支持 Unicode。然而，Linux 和
    macOS 系统通常使用 Unicode（尽管 ASCII 是 Unicode 的一个子集）。现在你已经了解了如何为 ASCII 字符实现字符串函数，是时候扩展
    [第 2 章](chapter2.xhtml) 对 Unicode 的简要介绍，并讨论 Unicode 字符串的字符串函数了。
- en: 14.3.1 Unicode History
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.1 Unicode 历史
- en: A few decades back, engineers at Aldus Corporation, NeXT, Sun Microsystems,
    Apple Computer, IBM, Microsoft, the Research Libraries Group, and Xerox realized
    that their new computer systems with bitmaps and user-selectable fonts could display
    far more than 256 characters at one time. At the time, *double-byte character
    sets (DBCSs)* were the most common solution.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年前，Aldus 公司、NeXT、Sun Microsystems、Apple Computer、IBM、Microsoft、研究图书馆小组和 Xerox
    的工程师们意识到，他们的新计算机系统配备了位图和用户可选择的字体，可以一次显示远超过 256 个字符。当时，*双字节字符集（DBCSs）* 是最常见的解决方案。
- en: DBCSs had a couple of issues, however. First, as they were typically variable-length
    encodings, they required special library code; common character or string algorithms
    that depended on fixed-length character encodings would not work properly with
    them. Second, no consistent standard existed; different DBCSs used the same encoding
    for different characters.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，DBCSs 有一些问题。首先，通常它们是变长编码，需要特殊的库代码；依赖于固定长度字符编码的常见字符或字符串算法无法与它们正常工作。其次，没有统一的标准；不同的
    DBCSs 对不同的字符使用相同的编码。
- en: To avoid these compatibility problems, the engineers sought a different solution.
    They came up with the Unicode character set, which originally used a 2-byte character
    size. Like DBCSs, this approach still required special library code (existing
    single-byte string functions would not always work with 2-byte characters). Other
    than changing the size of a character, however, most existing string algorithms
    would still work with 2-byte characters. The Unicode definition included all the
    (known or living) character sets at the time, giving each character a unique encoding,
    to avoid the consistency problems that plagued differing DBCSs.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些兼容性问题，工程师们寻求了不同的解决方案。他们提出了 Unicode 字符集，最初使用 2 字节字符大小。像 DBCSs 一样，这种方法仍然需要特殊的库代码（现有的单字节字符串函数不总是能与
    2 字节字符兼容）。然而，除了改变字符的大小之外，大多数现有的字符串算法仍然可以与 2 字节字符一起使用。Unicode 的定义包括了当时所有（已知或现存的）字符集，为每个字符分配了唯一的编码，以避免不同
    DBCSs 所困扰的一致性问题。
- en: The original Unicode standard used a 16-bit word to represent each character.
    Therefore, Unicode supported up to 65,536 character codes—a huge advance over
    the 256 possible codes representable with an 8-bit byte. Furthermore, Unicode
    is upward compatible from ASCII. If the HO 9 bits of a Unicode character’s binary
    representation contain 0, the LO 7 bits use the standard ASCII code. (ASCII is
    a 7-bit code, so if the HO 9 bits of a 16-bit Unicode value are all 0, the remaining
    7 bits are an ASCII encoding for a character.) If the HO 9 bits contain a nonzero
    value, the 16 bits form an extended character code, above and beyond the ASCII
    character set.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 Unicode 标准使用 16 位字来表示每个字符。因此，Unicode 支持最多 65,536 个字符编码——相比之下，8 位字节所能表示的
    256 个编码是一个巨大的进步。此外，Unicode 向下兼容 ASCII。如果 Unicode 字符的二进制表示中的高 9 位为 0，则低 7 位使用标准的
    ASCII 码。（ASCII 是 7 位码，因此如果 16 位 Unicode 值的高 9 位全为 0，剩余的 7 位就是字符的 ASCII 编码。）如果高
    9 位包含非零值，则 16 位形成扩展字符编码，超出了 ASCII 字符集的范围。
- en: You may be wondering why so many character codes are necessary. When Unicode
    was first being developed, certain Asian character sets contained 4,096 characters.
    The Unicode character set even provided codes you could use to create an application-defined
    character set. Approximately half of the 65,536 possible character codes have
    been defined, and the remaining character encodings are reserved for future expansion.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么需要这么多字符编码。在 Unicode 最初开发时，某些亚洲字符集包含了 4,096 个字符。Unicode 字符集甚至提供了可以用来创建应用程序定义的字符集的编码。大约一半的
    65,536 个可能的字符编码已经被定义，剩余的字符编码则保留用于未来的扩展。
- en: Today, Unicode is a universal character set, long replacing ASCII and older
    DBCSs. All modern OSes (including macOS, Windows, Linux, Pi OS, Android, and Unix),
    all web browsers, and most modern applications provide Unicode support. The Unicode
    Consortium, a nonprofit corporation, maintains the Unicode standard. By maintaining
    the standard, the consortium helps guarantee that a character you write on one
    system will display as you expect on a different system or application.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，Unicode 已经成为一个通用字符集，长期以来取代了 ASCII 和较旧的 DBCS。所有现代操作系统（包括 macOS、Windows、Linux、Pi
    OS、Android 和 Unix）、所有网页浏览器以及大多数现代应用程序都提供对 Unicode 的支持。Unicode 联盟是一个非营利性机构，负责维护
    Unicode 标准。通过维护这一标准，联盟帮助保证你在一个系统上输入的字符能够在另一个系统或应用程序中按预期显示。
- en: 14.3.2 Code Points and Code Planes
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.2 码点和码平面
- en: Alas, as well-thought-out as the original Unicode standard was, its creators
    couldn’t have anticipated the subsequent explosion in characters. Emojis, astrological
    symbols, arrows, pointers, and a wide variety of symbols introduced for the internet,
    mobile devices, and web browsers—along with a desire to support historic, obsolete,
    and rare scripts—have greatly expanded the Unicode symbol repertoire.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜的是，尽管最初的 Unicode 标准设计得非常周全，其创建者不可能预见到随后字符数量的爆炸性增长。表情符号、占星符号、箭头、指示符以及为互联网、移动设备和网页浏览器引入的各种符号——加上支持历史性、过时和稀有文字的需求——大大扩展了
    Unicode 符号库。
- en: In 1996, systems engineers discovered that 65,536 symbols were insufficient.
    Rather than require 3 or 4 bytes for each Unicode character, those in charge of
    the Unicode definition gave up on trying to create a fixed-size representation
    of characters and allowed for opaque (and multiple) encodings of Unicode characters.
    Today, Unicode defines 1,112,064 code points, far exceeding the 2-byte capacity
    originally set aside for Unicode characters.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1996 年，系统工程师发现 65,536 个符号已不足够。为了避免每个 Unicode 字符需要 3 或 4 字节的存储空间，负责 Unicode
    定义的人放弃了创建固定大小字符表示法的想法，允许 Unicode 字符使用不透明的（且可变的）编码方式。如今，Unicode 定义了 1,112,064 个码点，远超最初为
    Unicode 字符保留的 2 字节容量。
- en: A Unicode *code point* is simply an integer value associated with a particular
    character symbol; you can think of it as the Unicode equivalent of the ASCII code
    for a character. The convention for Unicode code points is to specify the value
    in hexadecimal with a U+ prefix. For example, U+0041 is the Unicode code point
    for the letter A.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 的*码点*只是与特定字符符号关联的一个整数值；你可以把它看作是字符的 Unicode 等效的 ASCII 码。Unicode 码点的约定是以十六进制值表示，并加上
    U+ 前缀。例如，U+0041 是字母 A 的 Unicode 码点。
- en: Blocks of 65,536 characters are known as a *multilingual plane* in Unicode.
    The first multilingual plane, U+000000 to U+00FFFF, roughly corresponds to the
    original 16-bit Unicode definition; the Unicode standard calls this the *Basic
    Multilingual Plane (BMP)*. Planes 1 (U+010000 to U+01FFFF), 2 (U+020000 to U+02FFFF),
    and 14 (U+0E0000 to U+0EFFFF) are supplementary planes. Plane 3 (U+030000 to U+03FFFF)
    is the *Tertiary Ideographic Plane* (see *[https://<wbr>unicode<wbr>.org<wbr>/roadmaps<wbr>/tip<wbr>/](https://unicode.org/roadmaps/tip/)*).
    Unicode reserves planes 4 through 13 for future expansion and planes 15 and 16
    for user-defined character sets.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 65,536 个字符块在 Unicode 中被称为*多语言平面*。第一个多语言平面 U+000000 到 U+00FFFF 大致对应于最初的 16 位
    Unicode 定义；Unicode 标准将其称为*基本多语言平面（BMP）*。平面 1（U+010000 到 U+01FFFF）、平面 2（U+020000
    到 U+02FFFF）和平面 14（U+0E0000 到 U+0EFFFF）是补充平面。平面 3（U+030000 到 U+03FFFF）是*第三象形文字平面*（参见
    *[https://<wbr>unicode<wbr>.org<wbr>/roadmaps<wbr>/tip<wbr>/](https://unicode.org/roadmaps/tip/)*）。Unicode
    保留平面 4 到 13 用于未来扩展，平面 15 和 16 则用于用户定义字符集。
- en: The Unicode standard defines code points in the range U+000000 to U+10FFFF.
    Note that 0x10ffff is 1,114,111, which is where most of the 1,112,064 characters
    in the Unicode character set come from; the remaining 2,048 values form the *surrogate
    code points*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 标准定义了从 U+000000 到 U+10FFFF 范围内的码点。请注意，0x10FFFF 是 1,114,111，这就是大多数 1,112,064
    个 Unicode 字符来自的地方；剩余的 2,048 个值则构成了*代理码点*。
- en: 14.3.3 Surrogate Code Points
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.3 代理码点
- en: As noted earlier, Unicode began life as a 16-bit (2-byte) character set encoding.
    When it became apparent that 16 bits were insufficient to handle all the possible
    characters that existed at the time, an expansion was necessary. As of Unicode
    v2.0, the Unicode Consortium extended the definition of Unicode to include multiword
    characters. Now Unicode uses surrogate code points (U+D800 through U+DFFF) to
    encode values larger than U+FFFF, as shown in [Figure 14-1](chapter14.xhtml#fig14-1).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Unicode 起初是作为一个 16 位（2 字节）字符集编码的。当人们意识到 16 位不足以处理当时所有可能存在的字符时，扩展变得必要。从
    Unicode v2.0 开始，Unicode 联盟扩展了 Unicode 的定义，加入了多字字符。现在，Unicode 使用代理代码点（U+D800 到
    U+DFFF）来编码比 U+FFFF 更大的值，如[图 14-1](chapter14.xhtml#fig14-1)所示。
- en: '![](../images/Figure14-1.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure14-1.jpg)'
- en: 'Figure 14-1: Surrogate code-point encoding for Unicode planes 1–16'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-1：Unicode 平面 1-16 的代理代码点编码
- en: The two words, unit 1 (high surrogate) and unit 2 (low surrogate), always appear
    together. The unit 1 value with HO bits 0b110110 specifies the upper 10 bits (b10
    through b19) of the Unicode scalar, and the unit 2 value with HO bits 0b110111
    specifies the lower 10 bits (b0 through b9) of the Unicode scalar. Therefore,
    the value of bits b16 to b19 plus 1 specifies Unicode planes 1 through 16\. Bits
    b0 through b15 specify the Unicode scalar value within the plane.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个词，单元 1（高代理）和单元 2（低代理），总是一起出现。单元 1 值的高位 0b110110 指定 Unicode 标量的上 10 位（b10
    到 b19），而单元 2 值的高位 0b110111 指定 Unicode 标量的下 10 位（b0 到 b9）。因此，b16 到 b19 位加 1 的值指定了
    Unicode 平面 1 到 16。b0 到 b15 位指定该平面内的 Unicode 标量值。
- en: Note that surrogate codes appear only in the BMP. None of the other multilingual
    planes contain surrogate codes. Bits b0 through b19 extracted from the unit 1
    and 2 values always specify a Unicode scalar value (even if the values fall in
    the range U+D800 through U+DFFF).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代理代码仅出现在基本多语言平面（BMP）中。其他的多语言平面不包含代理代码。从单元 1 和单元 2 值提取的 b0 到 b19 位总是指定一个
    Unicode 标量值（即使这些值落在 U+D800 到 U+DFFF 范围内）。
- en: 14.3.4 Glyphs, Characters, and Grapheme Clusters
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.4 字形、字符和字素簇
- en: Each Unicode code point has a unique name. For example, U+0045 has the name
    LATIN CAPITAL LETTER A. The symbol A is *not* the name of the character. A is
    a *glyph*, a series of strokes (one horizontal and two slanted strokes) that a
    device draws in order to represent the character.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Unicode 代码点都有一个唯一的名称。例如，U+0045 的名称是拉丁大写字母 A。符号 A *不是* 字符的名称。A 是一个*字形*，它是设备为表示该字符所绘制的一系列笔画（一个水平笔画和两个斜笔画）。
- en: Many glyphs exist for the single Unicode character LATIN CAPITAL LETTER A. For
    example, a Times Roman A and a Times Roman Italic A have different glyphs, but
    Unicode doesn’t differentiate between them (or between the A character in any
    two different fonts). The character LATIN CAPITAL LETTER A remains U+0045 regardless
    of the font or style you use to draw it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单一的 Unicode 字符拉丁大写字母 A，存在许多字形。例如，Times Roman A 和 Times Roman Italic A 有不同的字形，但
    Unicode 并不区分它们（也不区分任意两种字体中的 A 字符）。无论你使用什么字体或样式来绘制，字符拉丁大写字母 A 的 Unicode 始终是 U+0045。
- en: 'The term *character* has a simple meaning when working with ASCII. The character
    code 0x41 corresponds to the LATIN CAPITAL LETTER A, which has a consistent representation
    when it appears on a display screen; in particular, a one-to-one correspondence
    exists between ASCII character codes and the symbol a user expects to see on the
    display. The situation is dramatically more complex when working with Unicode.
    There’s a difference between what you’d normally call a character and the definition
    of a Unicode character (*scalar* in Unicode terminology). For example, consider
    the following Swift code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 ASCII 时，*字符* 这个术语有一个简单的含义。字符代码 0x41 对应于拉丁大写字母 A，当它出现在显示屏上时有一个一致的表现；特别是，ASCII
    字符代码与用户期望在屏幕上看到的符号之间存在一一对应关系。而当使用 Unicode 时，情况复杂得多。在这里，通常所说的字符和 Unicode 字符的定义（在
    Unicode 术语中是*标量*）之间是有区别的。例如，考虑以下的 Swift 代码：
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This section uses the Swift programming language for examples because it is
    one of the first programming languages that attempts to do Unicode right (though
    a huge performance hit results from it). Assembly, on the other hand, requires
    the programmer to handle everything manually and isn’t the best tool for many
    Unicode examples. I explain how to translate this to assembly code in section
    14.4, “Unicode in Assembly Language,” on [page 853](chapter14.xhtml#pg_853).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 本节使用 Swift 编程语言作为示例，因为它是第一个尝试正确处理 Unicode 的编程语言之一（尽管这样做会导致巨大的性能损失）。另一方面，汇编语言要求程序员手动处理所有内容，并且对于许多
    Unicode 示例来说并不是最佳工具。我将在第 14.4 节“汇编语言中的 Unicode”中解释如何将其转换为汇编代码，[请参见第 853 页](chapter14.xhtml#pg_853)。
- en: The Swift syntax for specifying a Unicode scalar value within a string is "\u{hex}",
    where hex is a hexadecimal value, as in "\u{301}". In this example, 301 is the
    hexadecimal code for the *combining acute accent* character. The first print()
    statement prints the character, producing é on the output, as you expect. The
    second print() statement prints the number of characters Swift determines are
    present in the string—in this case, 1. The third print() statement prints the
    number of elements (UTF-16 elements, discussed further later in this section)
    in the string. In this case, that number is 2, because the string holds 2 words
    of UTF-16 data.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串中指定 Unicode 标量值的 Swift 语法是“\u{hex}”，其中 hex 是一个十六进制值，例如“\u{301}”。在这个示例中，301
    是*组合尖音符*字符的十六进制代码。第一个 print() 语句打印字符，输出 é，正如你所期望的那样。第二个 print() 语句打印 Swift 确定字符串中存在的字符数——在这种情况下是
    1。第三个 print() 语句打印字符串中的元素数量（UTF-16 元素，本节后面会进一步讨论）。在这种情况下，该数字是 2，因为该字符串包含 2 个 UTF-16
    数据单元。
- en: In this example, is é one character or two? Internally (assuming UTF-16 encoding),
    the computer sets aside 4 bytes of memory for this single character (two 16-bit
    Unicode scalar values). On the screen, however, the output takes only one character
    position and looks like a single character to the user. When this character appears
    within a text editor and the cursor is immediately to the right of the character,
    the user expects that pressing BACKSPACE will delete it. From the user’s perspective,
    then, this is a single character (as Swift reports when you print the count attribute
    of the string).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，é 是一个字符还是两个？在内部（假设使用 UTF-16 编码），计算机为这个单一字符分配了 4 字节的内存（两个 16 位的 Unicode
    标量值）。然而，在屏幕上，输出只占一个字符位置，并且对用户来说看起来像一个字符。当这个字符出现在文本编辑器中，并且光标紧挨着该字符时，用户会期望按下 BACKSPACE
    删除它。因此，从用户的角度来看，这就是一个字符（正如 Swift 在你打印字符串的 count 属性时所报告的那样）。
- en: In Unicode, however, a *character* is largely equivalent to a code point. In
    Unicode terminology, when you talk about symbols that an application displays
    to an end user, you refer to them not as characters but as *grapheme clusters*.
    These are sequences of one or more Unicode code points that combine to form a
    single language element (that is, something that appears as a single character
    to the user on the display, such as é).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Unicode 中，*字符*在很大程度上等同于代码点。在 Unicode 术语中，当你谈论应用程序向最终用户显示的符号时，你将其称为*字形簇*，而不是字符。这些是一个或多个
    Unicode 代码点的序列，它们组合在一起形成一个单一的语言元素（即，在显示器上以单个字符的形式呈现给用户的内容，例如 é）。
- en: 14.3.5 Normal Forms and Canonical Equivalence
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.5 规范形式与规范等价性
- en: 'The Unicode character é actually existed on personal computers long before
    Unicode came along: it’s part of the original IBM PC character set and of the
    Latin-1 character set (used, for example, on old DEC terminals). Unicode uses
    the Latin-1 character set for the code points in the range U+00A0 to U+00FF, and
    U+00E9 just happens to correspond to the é character. Therefore, you can modify
    the earlier program as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Unicode 字符 é 在 Unicode 出现之前就已经存在于个人计算机中：它是原始 IBM PC 字符集和 Latin-1 字符集的一部分（例如，在旧的
    DEC 终端上使用）。Unicode 使用 Latin-1 字符集来表示 U+00A0 到 U+00FF 范围内的代码点，而 U+00E9 恰好对应于 é
    字符。因此，你可以如下修改之前的程序：
- en: '[PRE29]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The outputs from this program are as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出如下：
- en: '[PRE30]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Ouch! You now have a couple of strings that all produce é but contain a different
    number of code points. Imagine how this complicates programming strings containing
    Unicode characters. For example, if you try to compare the following three strings
    (Swift syntax), what will the result be?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 哎哟！你现在有几个字符串，它们都生成 é，但包含的代码点数量不同。想象一下，这会如何使得包含 Unicode 字符的字符串编程变得复杂。例如，如果你尝试比较以下三个字符串（Swift
    语法），结果会是什么呢？
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To the user, both strings look the same on the screen. However, they clearly
    contain different values. If you compare them to see whether they are equal, will
    the result be true or false?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户而言，这两个字符串在屏幕上看起来是一样的。然而，它们显然包含不同的值。如果你比较它们以判断它们是否相等，结果是true还是false？
- en: Ultimately, that depends on which string libraries you’re using. Most current
    string libraries would return false if you compared these strings for equality.
    Many languages’ string libraries simply report that both strings are unequal.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这取决于你使用的是哪种字符串库。大多数当前的字符串库在比较这些字符串是否相等时会返回false。许多语言的字符串库简单地报告这两个字符串不相等。
- en: The two Unicode/Swift strings "\{E9}" and "e\{301}" should produce the same
    output on the display. Therefore, they are canonically equivalent according to
    the Unicode standard. Some string libraries won’t report any of these strings
    as being equivalent. Some, like the one accompanying Swift, will handle small
    canonical equivalences (such as "\{E9}" == "e\{301}") but not arbitrary sequences
    that should be equivalent. (This is probably a good balance of correctness versus
    efficiency; it can be computationally expensive to handle all the weird cases
    that won’t normally happen, such as "e\{301}\{301}".)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 Unicode/Swift 字符串 "\{E9}" 和 "e\{301}" 应该在显示器上输出相同的内容。因此，根据 Unicode 标准，它们是规范等效的。一些字符串库不会报告这些字符串是等效的。有些库，比如与
    Swift 一起使用的库，会处理小的规范等价（如 "\{E9}" == "e\{301}"），但不会处理应当等价的任意序列。（这可能是正确性与效率之间的良好平衡；处理所有不常发生的奇怪情况，如
    "e\{301}\{301}"，在计算上是很昂贵的。）
- en: Unicode defines *normal forms* for Unicode strings. One aspect of normal form
    is to replace canonically equivalent sequences with an equivalent sequence—for
    example, replace "e\u{309}" with "\u{E9}" or vice versa (the shorter form is usually
    preferable). Some Unicode sequences allow multiple combining characters. Often,
    the order of the combining characters is irrelevant to producing the desired grapheme
    cluster. However, comparing two such characters is easier if the combining characters
    are in a specified order. Normalizing Unicode strings may also produce results
    whose combining characters always appear in a fixed order, thereby improving the
    efficiency of string comparisons.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 为 Unicode 字符串定义了*规范形式*。规范形式的一个方面是将规范等效的序列替换为等效序列——例如，将 "e\u{309}" 替换为
    "\u{E9}"，反之亦然（通常更短的形式更为优选）。某些 Unicode 序列允许多个组合字符。通常，组合字符的顺序对生成所需的字形簇无关紧要。然而，如果组合字符按照指定的顺序排列，比较两个这样的字符会更容易。规范化
    Unicode 字符串也可能产生其组合字符始终以固定顺序出现的结果，从而提高字符串比较的效率。
- en: 14.3.6 Encodings
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.6 编码
- en: 'As of Unicode 2.0, the standard supports a 21-bit character space capable of
    handling over a million characters (though most of the code points remain reserved
    for future use). Rather than use a fixed-size 3-byte (or worse, 4-byte) encoding
    to allow the larger character set, the Unicode Consortium allows different encodings:
    UTF-32, UTF-16, and UTF-8 (*UTF* stands for *Unicode Transformation Format*).
    Each of these three encodings comes with advantages and disadvantages.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Unicode 2.0 开始，标准支持一个 21 位字符空间，能够处理超过一百万个字符（尽管大多数代码点仍然保留供未来使用）。Unicode 联盟并没有使用固定大小的
    3 字节（或更糟，4 字节）编码来支持更大的字符集，而是允许使用不同的编码：UTF-32、UTF-16 和 UTF-8（*UTF* 代表 *Unicode
    转换格式*）。这三种编码各有优缺点。
- en: '*UTF-32* uses 32-bit integers to hold Unicode scalars. The advantage to this
    scheme is that a 32-bit integer can represent every Unicode scalar value in only
    21 bits. Programs that require random access to characters in strings—without
    having to search for surrogate pairs—and other constant-time operations are usually
    possible when using UTF-32\. The obvious drawback to UTF-32 is that each Unicode
    scalar value requires 4 bytes of storage—twice that of the original Unicode definition
    and four times that of ASCII characters.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*UTF-32* 使用 32 位整数来表示 Unicode 标量值。这种方案的优点是，32 位整数可以用 21 位表示每个 Unicode 标量值。需要对字符串中的字符进行随机访问的程序——无需查找代理对——以及其他常数时间操作，在使用
    UTF-32 时通常是可能的。UTF-32 的显著缺点是每个 Unicode 标量值需要 4 字节的存储空间——是原始 Unicode 定义的两倍，也是 ASCII
    字符的四倍。'
- en: It may seem that using two or four times as much storage (over ASCII and the
    original Unicode) is a small price to pay. After all, modern machines have several
    orders of magnitude more storage than they did when Unicode first appeared. However,
    that extra storage has a huge impact on performance, because those additional
    bytes quickly consume cache storage. Furthermore, modern string-processing libraries
    often operate on character strings 8 bytes at a time (on 64-bit machines). With
    ASCII characters, that means a given string function can process up to eight characters
    concurrently; with UTF-32, that same string function can operate on only two characters
    concurrently. As a result, the UTF-32 version will run four times slower than
    the ASCII version. Ultimately, even Unicode scalar values are insufficient to
    represent all Unicode characters (that is, many Unicode characters require a sequence
    of Unicode scalars), so using UTF-32 doesn’t solve the problem.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用比 ASCII 和原始 Unicode 多两到四倍的存储空间（即使用 UTF-32）似乎是一个小代价。毕竟，现代计算机的存储空间远比 Unicode
    最初出现时大几个数量级。然而，这额外的存储空间对性能有巨大影响，因为这些额外的字节会迅速消耗缓存存储。此外，现代字符串处理库通常每次操作 8 字节（在 64
    位计算机上）。对于 ASCII 字符，这意味着一个给定的字符串函数可以同时处理最多八个字符；而对于 UTF-32，相同的字符串函数只能同时处理两个字符。因此，UTF-32
    版本的速度将是 ASCII 版本的四倍慢。最终，即便是 Unicode 标量值也不足以表示所有 Unicode 字符（即许多 Unicode 字符需要一系列
    Unicode 标量值），因此使用 UTF-32 并不能解决问题。
- en: As the name suggests, the second encoding format that Unicode supports, *UTF-16*,
    uses 16-bit (unsigned) integers to represent Unicode values. To handle scalar
    values greater than 0xFFFF, UTF-16 uses the surrogate-pair scheme to represent
    values in the range 0x010000 to 0x10FFFF. Because the vast majority of useful
    characters fit into 16 bits, most UTF-16 characters require only 2 bytes. For
    those rare cases where surrogates are necessary, UTF-16 requires two words (32
    bits) to represent the character.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，Unicode 支持的第二种编码格式，*UTF-16*，使用 16 位（无符号）整数表示 Unicode 值。为了处理大于 0xFFFF
    的标量值，UTF-16 使用代理对方案表示 0x010000 到 0x10FFFF 范围内的值。因为绝大多数有用的字符适合于 16 位表示，所以大多数 UTF-16
    字符仅需要 2 字节。对于那些需要代理的少数情况，UTF-16 需要两个字（32 位）来表示字符。
- en: The last encoding, and unquestionably the most popular, is *UTF-8*. The UTF-8
    encoding is forward-compatible from the ASCII character set. In particular, all
    ASCII characters have a single-byte representation (their original ASCII code,
    where the HO bit of the byte containing the character contains a 0 bit). If the
    UTF-8 HO bit is 1, UTF-8 requires 1 to 3 additional bytes to represent the Unicode
    code point.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的编码格式，也是无疑最流行的，是 *UTF-8*。UTF-8 编码向后兼容 ASCII 字符集。特别是，所有的 ASCII 字符都有单字节表示（它们的原始
    ASCII 代码，其中包含该字符的字节的高位（HO）为 0）。如果 UTF-8 的高位（HO）为 1，则 UTF-8 需要 1 到 3 个附加字节来表示 Unicode
    代码点。
- en: '[Table 14-1](chapter14.xhtml#tab14-1) provides the UTF-8 encoding schema, where
    the *x* bits are the Unicode point bits.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 14-1](chapter14.xhtml#tab14-1)提供了 UTF-8 编码方案，其中的 *x* 位是 Unicode 点位的位。'
- en: 'Table 14-1: UTF-8 Encoding'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14-1：UTF-8 编码
- en: '| Bytes | Bits for code point | First code point | Last code point | Byte 1
    | Byte 2 | Byte 3 | Byte 4 |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 字节数 | 代码点的位数 | 第一个代码点 | 最后一个代码点 | 字节 1 | 字节 2 | 字节 3 | 字节 4 |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| 1 | 7 | U+00 | U+7F | 0xxxxxxx |  |  |  |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 7 | U+00 | U+7F | 0xxxxxxx |  |  |  |'
- en: '| 2 | 11 | U+80 | U+7FF | 110xxxxx | 10xxxxxx |  |  |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 11 | U+80 | U+7FF | 110xxxxx | 10xxxxxx |  |  |'
- en: '| 3 | 16 | U+800 | U+FFFF | 1110xxxx | 10xxxxxx | 10xxxxxx |  |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 16 | U+800 | U+FFFF | 1110xxxx | 10xxxxxx | 10xxxxxx |  |'
- en: '| 4 | 21 | U+10000 | U+10FFFF | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 21 | U+10000 | U+10FFFF | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |'
- en: For multibyte sequences, byte 1 contains the HO bits, byte 2 contains the next
    HO bits (LO bits compared to byte 1), and so on. For example, the 2-byte sequence
    (0b11011111, 0b10000001) corresponds to the Unicode scalar 0b0000_0111_1100_0001
    (U+07C1).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多字节序列，字节 1 包含高位（HO）位，字节 2 包含接下来的高位（与字节 1 的低位（LO）比较），依此类推。例如，2 字节序列（0b11011111,
    0b10000001）对应的 Unicode 标量值是 0b0000_0111_1100_0001（U+07C1）。
- en: UTF-8 encoding is probably the most common encoding in use, since most web pages
    use it. Most C stdlib string functions will operate on UTF-8 text without modification
    (although some can produce malformed UTF-8 strings if the programmer isn’t careful).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8 编码可能是最常用的编码格式，因为大多数网页都使用它。大多数 C 标准库的字符串函数会在 UTF-8 文本上无修改地运行（尽管如果程序员不小心，某些函数可能会产生格式错误的
    UTF-8 字符串）。
- en: Different languages and OSes default to using different encodings. For example,
    macOS and Windows tend to use UTF-16 encoding, whereas most Unix systems use UTF-8\.
    Some variants of Python use UTF-32 as their native character format. By and large,
    though, most programming languages use UTF-8 because they can continue to use
    older ASCII-based character-processing libraries to process UTF-8 characters.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的语言和操作系统默认使用不同的编码。例如，macOS和Windows倾向于使用UTF-16编码，而大多数Unix系统使用UTF-8。某些Python变种使用UTF-32作为它们的本地字符格式。总的来说，大多数编程语言使用UTF-8，因为它们可以继续使用基于ASCII的旧字符处理库来处理UTF-8字符。
- en: 14.3.7 Combining Characters
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.7 组合字符
- en: Although UTF-8 and UTF-16 encodings are much more compact than UTF-32, the CPU
    overhead and algorithmic complexities of dealing with multibyte (or multiword)
    character sets complicates their use, introducing bugs and performance issues.
    Despite the issues of wasting memory, especially in the cache, why not simply
    define characters as 32-bit entities and be done with it? This seems like it would
    simplify string-processing algorithms, improving performance and reducing the
    likelihood of defects in the code.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管UTF-8和UTF-16编码比UTF-32更加紧凑，但处理多字节（或多字）的字符集所需的CPU开销和算法复杂性使得它们的使用变得更加复杂，容易引入bug和性能问题。尽管存在浪费内存，特别是在缓存中，为什么不干脆将字符定义为32位实体并解决问题呢？这似乎能简化字符串处理算法，提高性能，并减少代码缺陷的可能性。
- en: 'The problem with this theory is that you cannot represent all possible grapheme
    clusters with only 21 bits (or even 32 bits) of storage. Many grapheme clusters
    consist of several concatenated Unicode code points. Here’s an example from Chris
    Eidhof and Ole Begemann’s *Advanced Swift*, version 3.0 (CreateSpace, 2017):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个理论的问题在于，你不能仅凭21位（甚至32位）存储来表示所有可能的字形簇。许多字形簇由多个连接的Unicode代码点组成。以下是来自Chris Eidhof和Ole
    Begemann的《*高级Swift*》，版本3.0（CreateSpace，2017）中的一个示例：
- en: '[PRE32]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Each of these Unicode grapheme clusters produces the same output: Ò., (a character
    from the Yoruba character set). The character sequence (U+1ECD, U+300) is an o.
    followed by a combining acute. The character sequence (U+F2, U+323) is an ò followed
    by a combining dot. The character sequence (U+6F, U+323, U+300) is an o followed
    by a combining dot, followed by a combining acute.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些Unicode字形簇都会产生相同的输出：Ò.（来自约鲁巴字符集的一个字符）。字符序列（U+1ECD，U+300）是一个o，后跟一个组合的尖音符。字符序列（U+F2，U+323）是一个ò，后跟一个组合的点。字符序列（U+6F，U+323，U+300）是一个o，后跟一个组合的点，再后跟一个组合的尖音符。
- en: 'The Swift string comparisons treat all four strings as equal:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Swift字符串比较将这四个字符串视为相等：
- en: '[PRE33]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: No single Unicode scalar value will produce this character. You must combine
    at least two Unicode scalars (or as many as three) to produce this grapheme cluster
    on the output device. Even UTF-32 encoding would still require two (32-bit) scalars
    to produce this particular output.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 没有单一的Unicode标量值能够产生这个字符。你必须至少组合两个Unicode标量（或最多三个）来在输出设备上产生这个字形簇。即使是UTF-32编码，也仍然需要两个（32位）标量来产生这个特定的输出。
- en: Emojis present another challenge that can’t be solved using UTF-32\. Consider
    the Unicode scalar U+1F471\. This prints an emoji of a person with blond hair.
    If you add a skin-color modifier, you obtain (U+1F471, U+1F3FF), which produces
    a person with a dark skin tone and blond hair. In both cases, a single character
    displays on the screen. The first example uses a single Unicode scalar value,
    but the second example requires two. There is no way to encode this with a single
    UTF-32 value.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 表情符号带来了另一个挑战，无法通过UTF-32解决。考虑Unicode标量U+1F471。它显示一个金发人的表情符号。如果你添加一个肤色修饰符，你会得到（U+1F471，U+1F3FF），这会产生一个肤色较深的金发人。在这两种情况下，屏幕上显示的是一个字符。第一个例子使用单一的Unicode标量值，但第二个例子需要两个。没有办法用单一的UTF-32值来编码这个。
- en: 'The bottom line is that certain Unicode grapheme clusters require multiple
    scalars, no matter how many bits you assign to the scalar (it’s possible to combine
    30 or 40 scalars into a single grapheme cluster, for example). That means you’re
    stuck dealing with multiword sequences to represent a single “character,” regardless
    of how hard you try to avoid it. This is why UTF-32 has never really taken off:
    it doesn’t solve the problem of random access into a string of Unicode characters.
    When normalizing and combining Unicode scalars, using UTF-8 or UTF-16 encodings
    is more efficient.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结论是，某些 Unicode 字形簇需要多个标量，不管你为标量分配多少位（例如，可能会将 30 或 40 个标量合并成一个字形簇）。这意味着你不得不处理多个词序列来表示一个“字符”，无论你多么努力地避免这种情况。这也是为什么
    UTF-32 从未真正流行起来的原因：它并没有解决对 Unicode 字符串进行随机访问的问题。在规范化和组合 Unicode 标量时，使用 UTF-8 或
    UTF-16 编码会更高效。
- en: Again, most languages and OSes today support Unicode in one form or another
    (typically using UTF-8 or UTF-16 encoding). Despite the obvious problems with
    dealing with multibyte character sets, modern programs need to deal with Unicode
    strings rather than simple ASCII strings.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，今天大多数语言和操作系统都以某种形式支持 Unicode（通常使用 UTF-8 或 UTF-16 编码）。尽管处理多字节字符集存在显而易见的问题，现代程序需要处理
    Unicode 字符串，而不是简单的 ASCII 字符串。
- en: 14.4 Unicode in Assembly Language
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4 汇编语言中的 Unicode
- en: As noted in section 2.17, “Gas Support for the Unicode Character Set,” on [page
    102](chapter2.xhtml#pg_102)), Gas doesn’t provide especially good support for
    Unicode strings. If you have a text editor that allows you to enter Unicode text
    into a source file, you might be able to type non-ASCII UTF-8 characters into
    a string constant and have Gas accept them. In general, though, the safest way
    to insert non-ASCII Unicode characters into an assembly language source file is
    to use hexadecimal constants. This section describes how to output Unicode characters
    from a console application and provides a brief introduction to Unicode string
    functions.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 2.17 节“Gas 对 Unicode 字符集的支持”中所述，参见 [第 102 页](chapter2.xhtml#pg_102)，Gas 对
    Unicode 字符串的支持并不特别好。如果你有一个支持输入 Unicode 文本的文本编辑器，你可能能够在字符串常量中输入非 ASCII 的 UTF-8
    字符，并且 Gas 能够接受它们。然而，通常来说，将非 ASCII Unicode 字符插入到汇编语言源文件中最安全的方式是使用十六进制常量。本节介绍如何从控制台应用程序输出
    Unicode 字符，并简要介绍 Unicode 字符串函数。
- en: 14.4.1 Writing Console Applications with UTF-8 Characters
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.4.1 编写支持 UTF-8 字符的控制台应用程序
- en: 'To be able to print strings containing UTF-8 characters, you must ensure that
    your OS is able to accept them. This is generally accomplished by using the C
    stdlib setlocale() function. Unfortunately, the parameter list varies by locale,
    so I can’t provide a universal example that works everywhere. For US English,
    I typically use the following function call:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够打印包含 UTF-8 字符的字符串，你必须确保你的操作系统能够接受它们。通常通过使用 C 标准库中的 setlocale() 函数来实现。不幸的是，参数列表根据区域设置有所不同，因此我无法提供一个适用于所有环境的通用示例。对于美国英语，我通常使用以下函数调用：
- en: '[PRE34]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The exact string for the second parameter will vary based on the country and
    language. You can search online for a description of the setlocale() function
    for more details about calling this function (or see section 14.6, “For More Information,”
    on [page 859](chapter14.xhtml#pg_859)). The following Linux/macOS command will
    list the available locale strings for your system:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数的具体字符串会根据国家和语言的不同而有所变化。你可以在线搜索 setlocale() 函数的描述，了解更多有关调用该函数的详细信息（或者参见第
    14.6 节“更多信息”，见 [第 859 页](chapter14.xhtml#pg_859)）。以下是列出你系统可用区域设置字符串的 Linux/macOS
    命令：
- en: '[PRE35]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here are some of the strings produced by this command under macOS (on a Mac
    mini M1):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此命令在 macOS 上（在 Mac mini M1 上）生成的一些字符串：
- en: '[PRE36]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: See “For More Information” for an explanation of the locale string format.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 有关区域设置字符串格式的解释，请参见“更多信息”部分。
- en: 'You could call setlocale() from your assembly language code, but I’ve found
    it more convenient to modify the *c.cpp* program that the *build* script uses.
    The following shows this modification:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你的汇编语言代码中调用 setlocale()，但我发现修改 *c.cpp* 程序更为方便，这个程序是 *build* 脚本使用的。以下展示了这个修改：
- en: '[PRE37]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Listing 14-6 presents a trivial program that demonstrates example text output
    containing UTF-8, to be compiled and linked with *c-utf8.cpp*. This example prints
    the UTF-8 sequence U+65 (lowercase e) followed by U+301 (combining acute accent
    character).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 14-6 展示了一个简单的程序，演示了包含 UTF-8 的示例文本输出，需与 *c-utf8.cpp* 编译和链接。此示例打印出 UTF-8 序列
    U+65（小写字母 e）后跟 U+301（组合急性重音符号）。
- en: '[PRE38]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that the UTF-8 encoding for U+301 requires 2 bytes
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，U+301的UTF-8编码需要2个字节
- en: '[PRE39]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: where B[11] down to B[0] is 0x301 or 0b011_0000_0001\. Therefore, the two UTF-8
    bytes are 0b1100_1100 (0xCC) and 0b10000001 (0x81).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 其中B[11]到B[0]是0x301或0b011_0000_0001。因此，两个UTF-8字节是0b1100_1100（0xCC）和0b10000001（0x81）。
- en: 'Here’s the build command and sample output for Listing 14-6 (assuming that
    *c-utf8.cpp* has been renamed to *c.cpp*):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第14-6节的构建命令和示例输出（假设*c-utf8.cpp*已重命名为*c.cpp*）：
- en: '[PRE40]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, the character sequence e, 0xcc, 0x89 produces the accented é
    character.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，字符序列e, 0xcc, 0x89产生了带重音符号的é字符。
- en: 14.4.2 Using Unicode String Functions
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.4.2 使用Unicode字符串函数
- en: 'As long as you stick with UTF-8 encoding, character string functions that operate
    on ASCII strings will *mostly* work with Unicode strings. You should be aware
    of a few issues, though:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你坚持使用UTF-8编码，操作ASCII字符串的字符字符串函数*大多数*能与Unicode字符串一起工作。不过，你应该意识到一些问题：
- en: Unless you keep strings in a canonical form, some string comparisons may report
    that two strings are not equal when, in fact, they would appear equal to the reader.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非你将字符串保持在规范形式，否则某些字符串比较可能会报告两个字符串不相等，而实际上，它们对读者来说是相等的。
- en: String comparison for *less than* and *greater than* will likely produce nonintuitive
    results because ASCII comparisons don’t work well in the face of Unicode scalars
    whose values consume 2 or more bytes.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于*小于*和*大于*的字符串比较，可能会产生非直观的结果，因为ASCII比较在面对那些值占用2个或更多字节的Unicode标量时表现不佳。
- en: A string-length calculation (when using zero-terminated or the assembly language
    string data type) will report the number of *bytes* in the string, not the number
    of characters (scalars or glyphs). Unless the string contains only ASCII characters,
    the length calculation will be wrong. The only reasonable way to count characters
    in a Unicode string is to process each glyph one at a time and count the glyphs.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串长度计算（当使用零终止或汇编语言字符串数据类型时）将报告字符串中的*字节*数，而不是字符（标量或字形）数。除非字符串仅包含ASCII字符，否则长度计算会是错误的。计算Unicode字符串中字符的唯一合理方法是一次处理一个字形并计算字形数。
- en: Functions that accept indices into a string generally require glyph indices,
    not byte indices. For example, the str.substr function given earlier could extract
    a substring containing a portion of a glyph at the beginning of the string, or
    chop a glyph in half at the end of the string, if the index and length parameters
    aren’t carefully chosen. Functions that insert glyphs into a string or delete
    characters from a string will suffer from this same problem.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受字符串索引的函数通常需要字形索引，而不是字节索引。例如，前面给出的str.substr函数，如果索引和长度参数选择不当，可能会提取包含字形部分的子字符串，或者在字符串的末尾切割一个字形。
- en: Because of these issues (and more), it’s dangerous to use ASCII-based string
    functions on Unicode and UTF-8 strings. It goes without saying that ASCII-based
    functions will not work on UTF-16 or UTF-32 encodings of Unicode characters.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些问题（以及其他问题），在Unicode和UTF-8字符串上使用基于ASCII的字符串函数是危险的。不言而喻，基于ASCII的函数在UTF-16或UTF-32编码的Unicode字符上是无法工作的。
- en: 'Section 14.6, “For More Information,” on the next page provides links to several
    string libraries (mostly written on C/C++) that process Unicode strings. The International
    Components for Unicode (UCI) library is important to consider, since it’s the
    library provided by the Unicode Consortium. At the time of writing, this library
    (ICU74.2) claims the following support:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 下一页的第14.6节，“更多信息”，提供了几个处理Unicode字符串的字符串库的链接（大多是用C/C++编写的）。国际Unicode组件（UCI）库是值得考虑的重要库，因为它是由Unicode联盟提供的。写作时，这个库（ICU74.2）宣称支持以下内容：
- en: The latest version of the Unicode standard
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最新版本的Unicode标准
- en: Character set conversions with support for over 220 code pages
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持超过220个代码页的字符集转换
- en: Locale data for more than 300 locales
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超过300种区域设置的区域数据
- en: Language-sensitive text collation (sorting) and searching based on the Unicode
    Collation Algorithm (ISO 14651)
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Unicode排序算法（ISO 14651）的语言敏感文本排序和搜索
- en: Regular expression matching and Unicode sets
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式匹配和Unicode集合
- en: Transformations for normalization, upper- and lowercase, script transliterations
    (50+ pairs)
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于标准化、大写和小写转换、脚本转写（50+对）
- en: Resource bundles for storing and accessing localized information
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储和访问本地化信息的资源包
- en: Date/number/message formatting and parsing of culture-specific input/output
    formats
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文化特定输入/输出格式的日期/数字/消息格式化和解析
- en: Calendar-specific date and time manipulation
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日历特定的日期和时间操作
- en: Text boundary analysis for finding character, word, and sentence boundaries
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本边界分析，用于查找字符、单词和句子的边界
- en: Although this isn’t a complete set of string functions you’d expect in a typical
    programming language, it does provide all the basic operations needed to correctly
    implement a full set of functions. Also keep in mind that Unicode string functions
    aren’t particularly fast. Unfortunately, because of the design of the Unicode
    character set (and multibyte character sets in general), you have to process each
    and every character in a string to accomplish mundane tasks. Only a few functions,
    like str.cpy, can work without scanning over every character in the string.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这不是典型编程语言中期望的完整字符串函数集合，但它提供了实现完整功能所需的所有基本操作。还请记住，Unicode字符串函数并不是特别快速。不幸的是，由于Unicode字符集（以及一般的多字节字符集）的设计，必须处理字符串中的每个字符才能完成日常任务。只有少数函数，如str.cpy，可以在不扫描每个字符的情况下工作。
- en: 14.5 Moving On
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.5 继续前进
- en: This chapter covered string data structures (zero-terminated and special assembly
    language strings), calling C stdlib string functions from assembly, writing assembly
    language–based string functions, and using the Unicode character set (and Unicode
    string functions).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了字符串数据结构（零终止和特殊汇编语言字符串）、从汇编语言调用C标准库字符串函数、编写基于汇编语言的字符串函数，以及使用Unicode字符集（和Unicode字符串函数）。
- en: The next chapter discusses managing large projects in assembly language, particularly
    how to create library modules, which will prove useful for combining several string
    functions into a single library module.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论如何在汇编语言中管理大型项目，特别是如何创建库模块，这对于将多个字符串函数组合成一个库模块非常有用。
- en: '### 14.6 For More Information'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '### 14.6 更多信息'
- en: 'The official Unicode website is the main source for information about all things
    concerning the Unicode standard. This is the closest thing to an official Unicode
    library: *[https://<wbr>icu<wbr>.unicode<wbr>.org<wbr>/home](https://icu.unicode.org/home)*.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方Unicode网站是关于Unicode标准所有相关信息的主要来源。这是最接近官方Unicode库的地方： *[https://icu.unicode.org/home](https://icu.unicode.org/home)*。
- en: GNU offers a Unicode string library at *[https://<wbr>www<wbr>.gnu<wbr>.org<wbr>/software<wbr>/libunistring<wbr>/manual<wbr>/libunistring<wbr>.html](https://www.gnu.org/software/libunistring/manual/libunistring.html)*.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU提供了一个Unicode字符串库，网址为 *[https://www.gnu.org/software/libunistring/manual/libunistring.html](https://www.gnu.org/software/libunistring/manual/libunistring.html)*。
- en: You can find the source code for the functions from the GNU C stdlib for AARCH64
    discussed in this chapter at *[https://<wbr>github<wbr>.com<wbr>/bminor<wbr>/glibc<wbr>/tree<wbr>/master<wbr>/sysdeps<wbr>/aarch64](https://github.com/bminor/glibc/tree/master/sysdeps/aarch64)*.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 *[https://github.com/bminor/glibc/tree/master/sysdeps/aarch64](https://github.com/bminor/glibc/tree/master/sysdeps/aarch64)*
    找到本章讨论的GNU C标准库中AARCH64相关函数的源代码。
- en: For the GitHub repository containing the source code for the glibc string functions
    written in ARM assembly, see *[https://<wbr>github<wbr>.com<wbr>/ARM<wbr>-software<wbr>/optimized<wbr>-routines<wbr>/tree<wbr>/master<wbr>/string<wbr>/aarch64](https://github.com/ARM-software/optimized-routines/tree/master/string/aarch64)*.
    You can study this code to learn advanced string-handling tricks in assembly language.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关包含用ARM汇编语言编写的glibc字符串函数源代码的GitHub仓库，请参见 *[https://github.com/ARM-software/optimized-routines/tree/master/string/aarch64](https://github.com/ARM-software/optimized-routines/tree/master/string/aarch64)*。你可以研究这些代码，学习汇编语言中的高级字符串处理技巧。
- en: For help writing ARM string-handling functions in assembly language, you can
    post questions to a forum I’ve set up at *[https://<wbr>forums<wbr>.randallhyde<wbr>.com](https://forums.randallhyde.com)*.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若需要帮助编写ARM字符串处理函数的汇编代码，可以在我设置的论坛上提问，网址为 *[https://forums.randallhyde.com](https://forums.randallhyde.com)*。
- en: For a list of various Unicode string libraries, see *[https://<wbr>unicodebook<wbr>.readthedocs<wbr>.io<wbr>/libraries<wbr>.html#libunistring](https://unicodebook.readthedocs.io/libraries.html#libunistring)*.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关各种Unicode字符串库的列表，请参见 *[https://unicodebook.readthedocs.io/libraries.html#libunistring](https://unicodebook.readthedocs.io/libraries.html#libunistring)*。
- en: Wikipedia offers more detail on Unicode code points at *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Unicode#General<wbr>_Category<wbr>_property](https://en.wikipedia.org/wiki/Unicode#General_Category_property)*.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科提供了关于 Unicode 代码点的更多详细信息：*[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Unicode#General<wbr>_Category<wbr>_property](https://en.wikipedia.org/wiki/Unicode#General_Category_property)*。
- en: 'My website links to information on the HLA string library (x86): *[https://<wbr>www<wbr>.randallhyde<wbr>.com<wbr>/AssemblyLanguage<wbr>/HighLevelAsm<wbr>/HLADoc<wbr>/index<wbr>.html](https://www.randallhyde.com/AssemblyLanguage/HighLevelAsm/HLADoc/index.html)*.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的网页链接到有关 HLA 字符串库（x86）的信息：*[https://<wbr>www<wbr>.randallhyde<wbr>.com<wbr>/AssemblyLanguage<wbr>/HighLevelAsm<wbr>/HLADoc<wbr>/index<wbr>.html](https://www.randallhyde.com/AssemblyLanguage/HighLevelAsm/HLADoc/index.html)*。
- en: ARM Developer assembly language string library source code can be found at *[https://<wbr>developer<wbr>.arm<wbr>.com<wbr>/documentation<wbr>/102620<wbr>/0100<wbr>/Optimized<wbr>-string<wbr>-routines<wbr>-<wbr>-<wbr>-libastring](https://developer.arm.com/documentation/102620/0100/Optimized-string-routines---libastring)*.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARM 开发者汇编语言字符串库源代码可以在 *[https://<wbr>developer<wbr>.arm<wbr>.com<wbr>/documentation<wbr>/102620<wbr>/0100<wbr>/Optimized<wbr>-string<wbr>-routines<wbr>-<wbr>libastring](https://developer.arm.com/documentation/102620/0100/Optimized-string-routines---libastring)*
    找到。
- en: For more on the setlocale() function, see *[https://<wbr>man7<wbr>.org<wbr>/linux<wbr>/man<wbr>-pages<wbr>/man3<wbr>/setlocale<wbr>.3<wbr>.html](https://man7.org/linux/man-pages/man3/setlocale.3.html)*.
    For an explanation of the locale string format, see *[https://<wbr>docs<wbr>.oracle<wbr>.com<wbr>/javase<wbr>/8<wbr>/docs<wbr>/api<wbr>/java<wbr>/util<wbr>/Locale<wbr>.html](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html)*
    (or search for **locale function**).
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 setlocale() 函数的更多信息，请参见 *[https://<wbr>man7<wbr>.org<wbr>/linux<wbr>/man<wbr>-pages<wbr>/man3<wbr>/setlocale<wbr>.3<wbr>.html](https://man7.org/linux/man-pages/man3/setlocale.3.html)*。有关区域设置字符串格式的解释，请参见
    *[https://<wbr>docs<wbr>.oracle<wbr>.com<wbr>/javase<wbr>/8<wbr>/docs<wbr>/api<wbr>/java<wbr>/util<wbr>/Locale<wbr>.html](https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html)*（或搜索
    **locale function**）。
