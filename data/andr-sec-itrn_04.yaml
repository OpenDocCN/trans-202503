- en: Chapter 4. User Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 用户管理
- en: Android originally targeted personal devices such as smartphones and assumed
    that each device had only one user. With the increase in popularity of tablets
    and other shared devices, multi-user support was added in version 4.2 and extended
    in later versions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Android 最初是面向个人设备（如智能手机）的，假设每个设备只有一个用户。随着平板电脑和其他共享设备的普及，Android 在 4.2 版本中增加了多用户支持，并在后续版本中进行了扩展。
- en: In this chapter, we’ll discuss how Android manages users who share devices and
    data. We begin with a look at the types of users Android supports and how it stores
    user metadata. We then discuss how Android shares installed applications between
    users while isolating application data and keeping it private to each user. Finally,
    we cover how Android implements isolated external storage.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论 Android 如何管理共享设备和数据的用户。我们首先介绍 Android 支持的用户类型及其如何存储用户元数据。接着，我们讨论 Android
    如何在用户之间共享已安装的应用程序，同时隔离应用程序数据并确保每个用户的数据隐私。最后，我们讲解 Android 如何实现隔离的外部存储。
- en: Multi-User Support Overview
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多用户支持概述
- en: Android’s multi-user support allows multiple users to share a single device
    by providing each user with an isolated, personal environment. Each user can have
    their own home screen, widgets, apps, online accounts, and files that are not
    accessible to other users.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Android 的多用户支持允许多个用户共享同一设备，通过为每个用户提供一个独立的、个人化的环境。每个用户可以拥有自己的主屏幕、小部件、应用程序、在线账户和文件，这些内容对其他用户不可访问。
- en: 'Users are identified by a unique *user ID* (not to be confused with Linux UIDs)
    and only the system can switch between users. User switching is normally triggered
    by selecting a user from the Android lockscreen and (optionally) authenticating
    using a pattern, PIN, password, and so on (see [Chapter 10](ch10.html "Chapter 10. Device
    Security")). Applications can get information about the current user via the `UserManager`
    API, but typically code modification is not required in order to support a multi-user
    environment. Applications that need to modify their behavior when used by a restricted
    profile are an exception: these applications require additional code that checks
    what restrictions (if any) are imposed on the current user (see “[Restricted Profiles](ch04.html#restricted_profiles
    "Restricted Profiles")” for details).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过一个独特的*用户ID*（不要与Linux的UID混淆）进行标识，只有系统可以在用户之间切换。用户切换通常通过从 Android 锁屏界面选择一个用户来触发，并（可选地）通过图案、PIN、密码等方式进行身份验证（详见[第10章](ch10.html
    "第10章 设备安全")）。应用程序可以通过 `UserManager` API 获取当前用户的信息，但通常不需要修改代码即可支持多用户环境。需要在受限配置文件下修改行为的应用程序是一个例外：这些应用程序需要额外的代码来检查当前用户所施加的任何限制（详见“[受限配置文件](ch04.html#restricted_profiles
    "受限配置文件")”了解详情）。
- en: Multi-user support is built into the core Android platform and is thus available
    on all devices that run Android 4.2 or later. However, the default platform configuration
    only allows for a single user, which effectively disables multi-user support.
    In order to enable support for multiple users, the *config_multiuserMaximumUsers*
    system resource must be set to a value greater than one, typically by adding a
    device-specific overlay configuration file. For example, on the Nexus 7 (2013),
    the overlay is placed in the *device/ asus/flo/overlay/frameworks/base/core/res/res/values/config.xml*
    file and the *config_multiuserMaximumUsers* setting is defined as shown in [Example 4-1](ch04.html#enabling_multi-user_support_with_a_resou
    "Example 4-1. Enabling multi-user support with a resource overlay file"), to allow
    a maximum of eight users.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 多用户支持内建于 Android 核心平台，因此在所有运行 Android 4.2 或更高版本的设备上均可使用。然而，默认的平台配置只允许单个用户，这实际上禁用了多用户支持。为了启用多用户支持，*config_multiuserMaximumUsers*
    系统资源必须设置为大于 1 的值，通常通过添加设备特定的覆盖配置文件来实现。例如，在 Nexus 7（2013）上，覆盖文件放置在 *device/ asus/flo/overlay/frameworks/base/core/res/res/values/config.xml*
    文件中，*config_multiuserMaximumUsers* 设置如下所示，在[示例 4-1](ch04.html#enabling_multi-user_support_with_a_resou
    "示例 4-1. 使用资源覆盖文件启用多用户支持")中定义，允许最多支持 8 个用户。
- en: Example 4-1. Enabling multi-user support with a resource overlay file
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-1. 使用资源覆盖文件启用多用户支持
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The Android Compatibility Definition requires that devices that support telephony
    (such as mobile phones) must not enable multi-user support because “the behavior
    of the telephony APIs on devices with multiple users is currently undefined.”*^([[29](#ftn.ch04fn01)])
    *Therefore, in current production builds, all handsets are configured as single-user
    devices.*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*Android 兼容性定义要求支持电话功能的设备（如手机）不得启用多用户支持，因为“目前多用户设备上的电话 API 行为未定义。”*^([[29](#ftn.ch04fn01)])
    *因此，在当前的生产版本中，所有手机都被配置为单用户设备。*'
- en: When multi-user support is enabled, the system Settings application displays
    a Users entry that allows the device owner (the first user created, as discussed
    in the next section) to create and manage users. The user management screen is
    shown in [Figure 4-1](ch04.html#user_management_screen "Figure 4-1. User management
    screen").
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用多用户支持时，系统设置应用会显示一个“用户”条目，允许设备所有者（下一节中讨论的第一个创建的用户）创建和管理其他用户。[图 4-1](ch04.html#user_management_screen
    "图 4-1. 用户管理屏幕") 显示了用户管理屏幕。
- en: '![User management screen](figs/web/04fig01.png.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![用户管理屏幕](figs/web/04fig01.png.jpg)'
- en: Figure 4-1. User management screen
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-1. 用户管理屏幕
- en: As soon as more than one user has been created, the lockscreen shows a user
    widget that displays the current users and allows switching to a different user.
    [Figure 4-2](ch04.html#lockscreen_with_user_switcher_widget "Figure 4-2. Lockscreen
    with user switcher widget") shows how the lockscreen might look on a device with
    eight users.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了多个用户，锁屏上会显示一个用户小部件，显示当前用户并允许切换到其他用户。[图 4-2](ch04.html#lockscreen_with_user_switcher_widget
    "图 4-2. 带有用户切换小部件的锁屏") 展示了一个包含八个用户的设备上的锁屏界面。
- en: '![Lockscreen with user switcher widget](figs/web/04fig02.png.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![带有用户切换小部件的锁屏](figs/web/04fig02.png.jpg)'
- en: Figure 4-2. Lockscreen with user switcher widget
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-2. 带有用户切换小部件的锁屏
- en: Types of Users
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户类型
- en: Even though Android lacks the full user management features of most multi-user
    operating systems, which typically allow users to add multiple administrators
    and define user groups, it does support configuring user types with different
    privileges. Each user type and its privileges will be described in the following
    sections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Android 缺乏大多数多用户操作系统的完整用户管理功能，这些操作系统通常允许用户添加多个管理员并定义用户组，但它确实支持配置具有不同权限的用户类型。每种用户类型及其权限将在接下来的章节中详细描述。
- en: The Primary User (Owner)
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要用户（所有者）
- en: 'The *primary user*, also known as the device *owner*, is the first user created
    on a multi-user device, or the sole user on single-user devices. The owner is
    created by default and is always present. The primary user is assigned user ID
    0\. On single-user devices where the primary user is the only user, Android behaves
    much like previous versions that lacked multi-user support: directories and UIDs
    assigned to installed applications maintain the same format and permissions as
    in previous versions (see “[User Management](ch04.html#user_management-id00008
    "User Management")” and “[Application Sharing](ch04.html#application_sharing "Application
    Sharing")” for details).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*主要用户*，也称为设备的*所有者*，是多用户设备上创建的第一个用户，或者是单用户设备上的唯一用户。所有者默认创建并始终存在。主要用户被分配用户 ID
    0。在单用户设备上，主要用户是唯一用户，Android 的行为类似于没有多用户支持的早期版本：已安装应用程序分配的目录和 UID 保持与早期版本相同的格式和权限（详细内容请参见“[用户管理](ch04.html#user_management-id00008
    "用户管理")”和“[应用程序共享](ch04.html#application_sharing "应用程序共享")”）。'
- en: The primary user is assigned all privileges and can create and delete other
    users, as well as change system settings that affect all users, including settings
    related to device security, network connectivity, and application management.
    Device and user management privileges are granted to the primary user by showing
    the respective settings screens in system settings and hiding them from other
    users. Additionally, the underlying system services check the identity of the
    calling user before performing operations that can affect all users, and only
    allow execution when called by the device owner.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 主要用户被分配所有权限，可以创建和删除其他用户，并更改影响所有用户的系统设置，包括与设备安全性、网络连接性和应用程序管理相关的设置。设备和用户管理权限通过在系统设置中显示相关设置界面并将其隐藏于其他用户之外来授予主要用户。此外，底层系统服务在执行可能影响所有用户的操作之前，会检查调用用户的身份，仅当由设备所有者调用时才允许执行。
- en: 'As of Android version 4.4, the following screens in the Wireless and Networks
    section of system settings are displayed to only the primary user:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Android 版本 4.4 开始，系统设置中“无线和网络”部分的以下页面仅对主用户显示：
- en: Cell broadcasts
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蜂窝广播
- en: Manage mobile plan
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理移动计划
- en: Mobile network
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动网络
- en: Tethering and portable hotspot
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享与便携式热点
- en: VPN
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VPN
- en: WiMAX (shown if supported by the device)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WiMAX（如果设备支持，则显示）
- en: 'The following screens in the Security section are also reserved for the primary
    user:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 安全部分的以下页面也仅限主用户使用：
- en: Device encryption
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备加密
- en: SIM card lock
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SIM 卡锁
- en: Unknown sources (controls app sideloading; see [Chapter 3](ch03.html "Chapter 3. Package
    Management"))
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未知来源（控制应用程序侧载；见[第 3 章](ch03.html "第 3 章. 软件包管理")）
- en: Verify apps (controls package verification; see [Chapter 3](ch03.html "Chapter 3. Package
    Management"))
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证应用程序（控制软件包验证；见[第 3 章](ch03.html "第 3 章. 软件包管理")）
- en: Secondary Users
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 次要用户
- en: With the exception of restricted profiles (discussed in the next section), all
    added users are *secondary users*. Each gets a dedicated user directory (see “[User
    Management](ch04.html#user_management-id00008 "User Management")”), their own
    list of installed apps, and private data directories for each installed app.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除限制配置文件（将在下一节中讨论）外，所有添加的用户都是 *次要用户*。每个次要用户都有一个专用的用户目录（见“[用户管理](ch04.html#user_management-id00008
    "用户管理")”），他们自己的已安装应用程序列表，以及每个已安装应用程序的私人数据目录。
- en: Secondary users cannot add or manage users; they can only set their own username
    via the Users screen (see [Figure 4-1](ch04.html#user_management_screen "Figure 4-1. User
    management screen")). Additionally, they cannot perform any privileged operation
    reserved for the primary user as listed in the previous sections. Otherwise, secondary
    users can perform all the operations that a primary user can, including installing
    and using applications, and changing the system appearance and settings.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 次要用户不能添加或管理用户；他们只能通过用户屏幕设置自己的用户名（见[图 4-1](ch04.html#user_management_screen "图
    4-1. 用户管理界面")）。此外，他们不能执行任何主用户专有的特权操作，如前面部分所列。否则，次要用户可以执行主用户可以执行的所有操作，包括安装和使用应用程序，以及更改系统外观和设置。
- en: Although secondary users are restricted, their actions can still affect device
    behavior and other users. For example, they can add and connect to a new Wi-Fi
    network. Because Wi-Fi connectivity state is shared across the system, switching
    to a different user does not reset the wireless connection, and that user will
    be connected to the wireless network selected by the previous user. Secondary
    users can also toggle airplane mode and NFC, and change the global sound and display
    settings. Most importantly, as application packages are shared across all users
    (as discussed in “[Application Sharing](ch04.html#application_sharing "Application
    Sharing")”), if a secondary user updates an application that adds new permissions,
    permissions are granted to the application without requiring the consent of other
    users, and other users are not notified of permission changes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管次要用户受到限制，他们的行为仍然可能影响设备行为和其他用户。例如，他们可以添加并连接到新的 Wi-Fi 网络。由于 Wi-Fi 连接状态是系统共享的，切换到不同用户并不会重置无线连接，该用户将连接到上一个用户选择的无线网络。次要用户还可以切换飞行模式和
    NFC，并更改全局声音和显示设置。最重要的是，由于应用程序包在所有用户之间共享（如“[应用程序共享](ch04.html#application_sharing
    "应用程序共享")”中讨论的），如果次要用户更新了一个添加了新权限的应用程序，权限将直接授予该应用程序，无需其他用户同意，且其他用户不会收到权限更改的通知。
- en: Restricted Profiles
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制配置文件
- en: Unlike secondary users, restricted profiles (added in Android 4.3) are based
    on the primary user and share its applications, data, and accounts, with certain
    restrictions. As such, the primary user must set up a lockscreen password in order
    to protect their data. If no lockscreen password is in place when the primary
    user creates a restricted profile, Android prompts them to set up one.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与次要用户不同，限制配置文件（在 Android 4.3 中新增）是基于主用户的，并共享其应用程序、数据和帐户，但有一些限制。因此，主用户必须设置锁屏密码以保护其数据。如果主用户在创建限制配置文件时未设置锁屏密码，Android
    会提示他们设置一个密码。
- en: User Restrictions
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户限制
- en: Android defines the following default restrictions in order to control what
    users are allowed to do. All restrictions are `false` by default. The list below
    shows their value for restricted users in parentheses.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Android 定义了以下默认限制，以控制用户可以做的事情。所有限制默认值为 `false`。下面的列表显示了受限用户的相应值（括号内为限制用户的值）。
- en: '****`DISALLOW_CONFIG_BLUETOOTH`****. Specifies whether a user is prevented
    from configuring Bluetooth. (default: `false`)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`DISALLOW_CONFIG_BLUETOOTH`****。指定是否禁止用户配置蓝牙。（默认值：`false`）'
- en: '****`DISALLOW_CONFIG_CREDENTIALS`****. Specifies whether a user is prevented
    from configuring user credentials. When this restriction is set to `true`, restricted
    profiles cannot add trusted CA certificates or import private keys into the system
    credential store; see [Chapter 6](ch06.html "Chapter 6. Network Security and PKI")
    and [Chapter 7](ch07.html "Chapter 7. Credential Storage") for details. (default:
    `false`)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`DISALLOW_CONFIG_CREDENTIALS`****。指定是否禁止用户配置用户凭证。当该限制设置为 `true` 时，受限配置文件无法向系统凭证存储中添加受信任的
    CA 证书或导入私钥；有关详细信息，请参见 [第 6 章](ch06.html "第 6 章：网络安全和 PKI") 和 [第 7 章](ch07.html
    "第 7 章：凭证存储")。（默认值：`false`）'
- en: '****`DISALLOW_CONFIG_WIFI`****. Specifies whether a user is prevented from
    changing Wi-Fi access points. (default: `false`)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`DISALLOW_CONFIG_WIFI`****。指定是否禁止用户更改 Wi-Fi 接入点。（默认值：`false`）'
- en: '****`DISALLOW_INSTALL_APPS`****. Specifies whether a user is prevented from
    installing applications. (default: `false`)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`DISALLOW_INSTALL_APPS`****。指定是否禁止用户安装应用程序。（默认值：`false`）'
- en: '****`DISALLOW_INSTALL_UNKNOWN_SOURCES`****. Specifies whether a user is prevented
    from enabling the Unknown sources setting (see [Chapter 3](ch03.html "Chapter 3. Package
    Management")). (default: `false`)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`DISALLOW_INSTALL_UNKNOWN_SOURCES`****。指定是否禁止用户启用未知来源设置（见 [第 3 章](ch03.html
    "第 3 章：包管理")）。（默认值：`false`）'
- en: '****`DISALLOW_MODIFY_ACCOUNTS`****. Specifies whether a user is prevented from
    adding and removing accounts. (default: `true`)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`DISALLOW_MODIFY_ACCOUNTS`****。指定是否禁止用户添加和删除账户。（默认值：`true`）'
- en: '****`DISALLOW_REMOVE_USER`****. Specifies whether a user is prevented from
    removing users. (default: `false`)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`DISALLOW_REMOVE_USER`****。指定是否禁止用户删除其他用户。（默认值：`false`）'
- en: '****`DISALLOW_SHARE_LOCATION`****. Specifies whether a user is prevented from
    toggling location sharing. (default: `true`)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`DISALLOW_SHARE_LOCATION`****。指定是否禁止用户切换位置共享。（默认值：`true`）'
- en: '****`DISALLOW_UNINSTALL_APPS`****. Specifies whether a user is prevented from
    uninstalling applications. (default: `false`)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`DISALLOW_UNINSTALL_APPS`****。指定是否禁止用户卸载应用程序。（默认值：`false`）'
- en: '****`DISALLOW_USB_FILE_TRANSFER`****. Specifies whether a user is prevented
    from transferring files over USB. (default: `false`)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`DISALLOW_USB_FILE_TRANSFER`****。指定是否禁止用户通过 USB 转移文件。（默认值：`false`）'
- en: Applying Restrictions
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用限制
- en: 'At runtime, applications can use the `UserManager.getUserRestrictions()` method
    to get a `Bundle` (a universal container class that maps string keys to various
    value types) containing the restrictions imposed on a user. Restrictions are defined
    as key-value pairs, where the key is the restriction name and the Boolean value
    specifies whether it is in effect. Applications can use that value in order to
    disable certain functionality when running within a restricted profile. For example,
    the system Settings app checks the value of the `DISALLOW_SHARE_LOCATION` restriction
    when displaying location preferences. If the value is `true`, it disables the
    location mode setting. Another example is the `PackageManagerService`: it checks
    the `DISALLOW_INSTALL_APPS` and `DISALLOW_UNINSTALL_APPS` restrictions before
    installing or uninstalling apps and returns the `INSTALL_FAILED_USER_RESTRICTED`
    error code if any of those restrictions are set to `true` for the calling user.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，应用程序可以使用 `UserManager.getUserRestrictions()` 方法获取一个包含用户限制的 `Bundle`（一个将字符串键映射到各种值类型的通用容器类）。限制被定义为键值对，其中键是限制名称，布尔值指定该限制是否生效。应用程序可以使用该值来禁用在受限配置文件下运行时的某些功能。例如，系统设置应用会在显示位置偏好时检查
    `DISALLOW_SHARE_LOCATION` 限制的值。如果值为 `true`，则禁用位置模式设置。另一个例子是 `PackageManagerService`：它会在安装或卸载应用之前检查
    `DISALLOW_INSTALL_APPS` 和 `DISALLOW_UNINSTALL_APPS` 限制，并在这些限制中的任何一个被设置为 `true`
    时返回 `INSTALL_FAILED_USER_RESTRICTED` 错误代码。
- en: The primary user can select which applications will be available to a restricted
    profile. When a restricted profile is created, all installed applications are
    initially disabled, and the owner must explicitly enable the ones that they want
    to make available to the restricted profile (see [Figure 4-3](ch04.html#restricted_profile_management_screen
    "Figure 4-3. Restricted profile management screen")).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 主要用户可以选择哪些应用程序对受限配置文件可用。当创建受限配置文件时，所有已安装的应用程序默认会被禁用，所有者必须明确启用他们希望让受限配置文件使用的应用程序（见
    [图 4-3](ch04.html#restricted_profile_management_screen "图 4-3：受限配置文件管理屏幕")）。
- en: '![Restricted profile management screen](figs/web/04fig03.png.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![受限个人资料管理界面](figs/web/04fig03.png.jpg)'
- en: Figure 4-3. Restricted profile management screen
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-3. 受限个人资料管理界面
- en: In addition to the built-in restrictions defined by the OS, applications can
    define custom restrictions by creating a `BroadcastReceiver` that receives the
    `ACTION_GET_RESTRICTION_ENTRIES` intent. Android invokes this intent to query
    all apps for available restrictions and automatically builds a UI that allows
    device owners to toggle the app’s custom restrictions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了操作系统定义的内置限制外，应用程序还可以通过创建一个接收`ACTION_GET_RESTRICTION_ENTRIES`意图的`BroadcastReceiver`来定义自定义限制。Android会调用此意图查询所有应用程序的可用限制，并自动构建一个用户界面，允许设备所有者切换应用程序的自定义限制。
- en: At runtime, applications can use the `UserManager.getApplicationRestrictions()`
    method to obtain a `Bundle` that contains saved restrictions as key-value pairs.
    The application can then disable or modify certain features based on the applied
    restrictions. The device owner can toggle system and custom restrictions on the
    same settings screen used to manage applications available to a restricted profile.
    For example, in [Figure 4-3](ch04.html#restricted_profile_management_screen "Figure 4-3. Restricted
    profile management screen"), the single application restriction supported by the
    Settings app (whether to let apps use location information) is shown below the
    main application toggle.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，应用程序可以使用`UserManager.getApplicationRestrictions()`方法获取一个包含保存的限制条件的`Bundle`，这些限制以键值对的形式存储。然后，应用程序可以根据所应用的限制禁用或修改某些功能。设备所有者可以在同一个设置界面上切换系统和自定义限制，这个界面用于管理可供受限个人资料使用的应用程序。例如，在[图4-3](ch04.html#restricted_profile_management_screen
    "图4-3. 受限个人资料管理界面")中，设置应用程序支持的单一应用程序限制（是否允许应用程序使用位置信息）显示在主应用程序切换按钮下方。
- en: Access to Online Accounts
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问在线帐户
- en: Restricted profiles can also access the online accounts of the primary user
    via the `AccountManager` API (see [Chapter 8](ch08.html "Chapter 8. Online Account
    Management")), but this access is disabled by default. Applications that need
    access to accounts when running within a restricted profile must explicitly declare
    the account types they require using the `restrictedAccountType` attribute of
    the `<application>` tag, as shown in [Example 4-2](ch04.html#allowing_access_to_the_ownerapostrophes
    "Example 4-2. Allowing access to the owner’s accounts from a restricted profile").
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 受限个人资料也可以通过`AccountManager` API访问主用户的在线帐户（参见[第8章](ch08.html "第8章. 在线帐户管理")），但默认情况下该访问是禁用的。需要访问帐户的应用程序在受限个人资料下运行时，必须明确声明它们所需的帐户类型，使用`<application>`标签的`restrictedAccountType`属性，如[示例4-2](ch04.html#allowing_access_to_the_ownerapostrophes
    "示例4-2. 允许受限个人资料访问所有者的帐户")所示。
- en: Example 4-2. Allowing access to the owner’s accounts from a restricted profile
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4-2. 允许受限个人资料访问所有者的帐户
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On the other hand, applications that do not want to expose account information
    to restricted profiles can declare this by specifying the account type (an asterisk
    can be used to match all account types) as the value of the `requiredAccountType`
    attribute of the `<application>` tag. If the `requiredAccountType` attribute is
    specified, Android will automatically disable such applications for restricted
    profiles. For example, because the Android Calendar application declares `android:requiredAccountType="*"`
    in its manifest, it cannot be made available to restricted profiles and is disabled
    in the restrictions settings screen (see [Figure 4-3](ch04.html#restricted_profile_management_screen
    "Figure 4-3. Restricted profile management screen")).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，不希望向受限个人资料公开帐户信息的应用程序可以通过指定帐户类型（可以使用星号来匹配所有帐户类型）作为`<application>`标签的`requiredAccountType`属性的值来声明这一点。如果指定了`requiredAccountType`属性，Android将自动禁用这些应用程序的受限个人资料。例如，由于Android日历应用程序在其清单文件中声明了`android:requiredAccountType="*"`，因此无法向受限个人资料提供该应用程序，并且在限制设置界面中被禁用（参见[图4-3](ch04.html#restricted_profile_management_screen
    "图4-3. 受限个人资料管理界面")）。
- en: Guest User
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端用户
- en: Android supports a single guest user, but this functionality is disabled by
    default. While the guest user can be enabled by calling the `UserManager.setGuestEnabled()`
    method, the guest user does not appear to be referenced anywhere other than by
    the `UserManager` and related classes in current Android versions. Code comments
    indicate that the guest user might be transient, but as of this writing its exact
    purpose is not clear. It appears to be a remnant of a proposed feature that was
    rejected or never fully implemented.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Android 支持单个访客用户，但该功能默认情况下是禁用的。虽然可以通过调用 `UserManager.setGuestEnabled()` 方法启用访客用户，但在当前
    Android 版本中，访客用户似乎只在 `UserManager` 和相关类中被引用。代码注释表明访客用户可能是临时的，但截至目前，其确切用途尚不明确。它似乎是一个被拒绝或从未完全实现的拟议功能的遗留物。
- en: User Management
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户管理
- en: Android users are managed by the `UserManagerService`, which is responsible
    for reading and persisting user information and maintaining the list of active
    users. Because user management is closely related to package management, the `PackageManagerService`
    calls the `UserManagerService` to query or modify users when packages are installed
    or removed. The `android.os.UserManager` class provides a facade to the `UserManagerService`
    and exposes a subset of its functionality to third-party applications. Applications
    can get the number of users on a system, a user’s serial number, the name and
    list of restrictions for the current user, as well as the list of restrictions
    for a package without the need for any special permissions. All other user operations,
    including querying, adding, removing, or modifying users, require the `MANAGE_USERS`
    system signature permission.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Android 用户由 `UserManagerService` 管理，后者负责读取和持久化用户信息，并维护活跃用户的列表。由于用户管理与包管理密切相关，`PackageManagerService`
    在安装或移除包时会调用 `UserManagerService` 查询或修改用户。`android.os.UserManager` 类为 `UserManagerService`
    提供了一个外观，并将其部分功能暴露给第三方应用程序。应用程序可以获取系统中的用户数量、用户的序列号、当前用户的名称和限制列表，以及某个包的限制列表，而无需任何特殊权限。所有其他用户操作，包括查询、添加、删除或修改用户，都需要
    `MANAGE_USERS` 系统签名权限。
- en: Command-Line Tools
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令行工具
- en: User management operations can also be performed on the Android shell with the
    `pm` command. These commands can be run via the shell without root permissions,
    because the *shell* user (UID 2000) is granted the `MANAGE_USERS` permission.
    You can use the `pm create-user` command to create a new user, and the `pm remove-user`
    to remove it. The command `pm get-max-users` returns the maximum number of users
    supported by the OS, and `pm list users` lists all users. The output of the `pm
    list users` command might look like [Example 4-3](ch04.html#listing_users_using_the_pm_list_command
    "Example 4-3. Listing users using the pm list command") on a device with five
    users. The numbers in curly braces are the user ID, name, and flags, in that order.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 用户管理操作也可以通过 Android shell 使用 `pm` 命令来执行。这些命令可以通过 shell 运行，无需 root 权限，因为 *shell*
    用户（UID 2000）被授予了 `MANAGE_USERS` 权限。你可以使用 `pm create-user` 命令创建新用户，使用 `pm remove-user`
    删除用户。命令 `pm get-max-users` 返回操作系统支持的最大用户数，而 `pm list users` 列出所有用户。`pm list users`
    命令的输出可能像 [示例 4-3](ch04.html#listing_users_using_the_pm_list_command "示例 4-3. 使用
    pm list 命令列出用户") 中的输出那样，显示设备上有五个用户。大括号中的数字依次表示用户 ID、姓名和标志。
- en: Example 4-3. Listing users using the `pm list` command
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-3. 使用 `pm list` 命令列出用户
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: User States and Related Broadcasts
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户状态和相关广播
- en: The `UserManagerService` sends several broadcasts to notify other components
    of user-related events. When a user is added, it sends the `USER_ADDED` broadcast,
    and when a user is removed, it sends `USER_REMOVED`. If the user-name or their
    profile icon is changed, the `UserManagerService` sends the `USER_INFO_CHANGED`
    broadcast. Switching users triggers the `USER_BACKGROUND`, `USER_FOREGROUND`,
    and `USER_SWITCHED` broadcasts, all of which contain the relevant user ID as an
    extra.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserManagerService` 会发送多个广播来通知其他组件有关用户的事件。当添加用户时，它会发送 `USER_ADDED` 广播；当移除用户时，它会发送
    `USER_REMOVED` 广播。如果用户名称或头像被更改，`UserManagerService` 会发送 `USER_INFO_CHANGED` 广播。切换用户时，会触发
    `USER_BACKGROUND`、`USER_FOREGROUND` 和 `USER_SWITCHED` 广播，所有这些广播都会包含相关的用户 ID 作为附加信息。'
- en: While Android supports a maximum of eight users, only three users can be running
    at a time. A user is started when it is first switched to via the lockscreen user
    switcher. Android stops inactive users based on a least recently used (LRU) cache
    algorithm to ensure that no more than three users are active.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Android最多支持八个用户，但一次只能有三个用户处于活动状态。当通过锁屏用户切换器首次切换到某个用户时，该用户会被启动。Android根据最少最近使用（LRU）缓存算法停止不活跃的用户，以确保最多只有三个用户处于活动状态。
- en: When a user is stopped, its processes are killed and it no longer receives any
    broadcasts. When users are started or stopped, the system sends the `USER_STARTING`,
    `USER_STARTED`, `USER_STOPPING`, and `USER_STOPPED` broadcasts. The primary user
    is started automatically when the system boots and is never stopped.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户被停止时，其进程会被终止，且不再接收任何广播。启动或停止用户时，系统会发送`USER_STARTING`、`USER_STARTED`、`USER_STOPPING`和`USER_STOPPED`广播。主用户在系统启动时自动启动，并且永远不会停止。
- en: Starting, stopping, and switching users, as well as targeting a specific user
    with a broadcast, requires the `INTERACT_ACROSS_USERS` permission. This is a system
    permission with signature protection, but it also has the `development` flag set
    (see [Chapter 2](ch02.html "Chapter 2. Permissions")) so it can be dynamically
    granted to non-system applications that declare it (using the `pm grant` command).
    The `INTERACT_ACROSS_USERS_FULL` signature permission allows sending broadcasts
    to all users, changing the device administrator, as well as other privileged operations
    that affect all users.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 启动、停止、切换用户，以及通过广播定位特定用户，需要`INTERACT_ACROSS_USERS`权限。这是一个具有签名保护的系统权限，但它也设置了`development`标志（见[第2章](ch02.html
    "第2章. 权限")），因此可以动态授予声明该权限的非系统应用（使用`pm grant`命令）。`INTERACT_ACROSS_USERS_FULL`签名权限允许向所有用户发送广播、更改设备管理员以及执行其他影响所有用户的特权操作。
- en: User Metadata
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户元数据
- en: Android stores user data in the */data/system/users/* directory that hosts metadata
    about users in XML format, as well as user directories. On a device with five
    users, its contents may look like [Example 4-4](ch04.html#contents_of_solidusdatasolidussystemsoli
    "Example 4-4. Contents of /data/system/users/") (timestamps have been omitted).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Android将用户数据存储在*/data/system/users/*目录中，该目录包含以XML格式存储的用户元数据以及用户目录。在一个有五个用户的设备上，其内容可能类似于[示例
    4-4](ch04.html#contents_of_solidusdatasolidussystemsoli "示例 4-4. /data/system/users/目录内容")（时间戳已省略）。
- en: Example 4-4. Contents of /data/system/users/
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-4. /data/system/users/目录内容
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The User List File
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户列表文件
- en: As shown in [Example 4-4](ch04.html#contents_of_solidusdatasolidussystemsoli
    "Example 4-4. Contents of /data/system/users/"), each user has a dedicated directory
    called the *user system directory* with a name that matches the assigned user
    ID (➊ for the primary user) and an XML file that stores metadata about the user,
    again with a filename based on the user ID (➋ for the primary user). The *userlists.xml*
    file ➌ holds data about all users created on a system and may look like [Example 4-5](ch04.html#contents_of_userlistdotxml
    "Example 4-5. Contents of userlist.xml") on a system with five users.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如[示例 4-4](ch04.html#contents_of_solidusdatasolidussystemsoli "示例 4-4. /data/system/users/目录内容")所示，每个用户都有一个名为*用户系统目录*的专用目录，目录名与分配的用户ID匹配（➊为主用户），并且有一个存储用户元数据的XML文件，文件名同样基于用户ID（➋为主用户）。*userlists.xml*文件➌保存了关于系统上所有用户的数据，系统上有五个用户时，它可能类似于[示例
    4-5](ch04.html#contents_of_userlistdotxml "示例 4-5. userlist.xml文件内容")。
- en: Example 4-5. Contents of userlist.xml
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-5. userlist.xml文件内容
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The file format is basically a list of `<user>` tags holding the ID assigned
    to each user. The root `<users>` element has a `version` attribute specifying
    the current file version and a `nextSerialNumber` attribute holding the serial
    number to be assigned to the next user. The primary user is always assigned user
    ID 0.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 文件格式基本上是一个包含每个用户ID的`<user>`标签列表。根元素`<users>`具有一个`version`属性，指定当前文件版本，还有一个`nextSerialNumber`属性，表示下一个用户将分配的序列号。主用户的ID总是分配为0。
- en: The fact that UIDs assigned to applications are based on the user ID of the
    owning user ensures that on single-user devices, UIDs assigned to applications
    are the same as they were before multi-user support was introduced. (For more
    on application UIDs, see “[Application Data Directories](ch04.html#application_data_directories
    "Application Data Directories")”.) Secondary users and restricted profiles are
    assigned IDs beginning with the number 10.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 用户分配给应用程序的 UID 是基于拥有用户的用户 ID，这确保在单用户设备上，分配给应用程序的 UID 与引入多用户支持之前相同。（有关应用程序 UID
    的更多信息，请参见 “[应用程序数据目录](ch04.html#application_data_directories "应用程序数据目录")”。）次要用户和限制型配置文件的
    ID 从数字 10 开始。
- en: User Metadata Files
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户元数据文件
- en: The attributes of each user are stored in a dedicated XML file. [Example 4-6](ch04.html#user_metadata_file_contents
    "Example 4-6. User metadata file contents") shows an example for a restricted
    profile.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户的属性都存储在专用的 XML 文件中。[示例 4-6](ch04.html#user_metadata_file_contents "示例 4-6.
    用户元数据文件内容") 展示了一个限制型配置文件的示例。
- en: Example 4-6. User metadata file contents
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-6. 用户元数据文件内容
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, the `<name>` tag ➋ holds the user’s name and the `<restrictions>` tag
    ➌ has attributes for each enabled restriction. (See “[Restricted Profiles](ch04.html#restricted_profiles
    "Restricted Profiles")” for a list of built-in restrictions.) [Table 4-1](ch04.html#less_thanusergreater_than_element_attrib
    "Table 4-1. <user> Element Attributes") summarizes the attributes of the root
    `<user>` element shown at ➊ in [Example 4-6](ch04.html#user_metadata_file_contents
    "Example 4-6. User metadata file contents").
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<name>` 标签 ➋ 保存用户的名称，`<restrictions>` 标签 ➌ 含有每个启用的限制条件的属性。（有关内置限制的列表，请参见
    “[限制型配置文件](ch04.html#restricted_profiles "限制型配置文件")”。）[表 4-1](ch04.html#less_thanusergreater_than_element_attrib
    "表 4-1. `<user>` 元素属性") 总结了在 [示例 4-6](ch04.html#user_metadata_file_contents "示例
    4-6. 用户元数据文件内容") 中显示的根 `<user>` 元素的属性，见 ➊。
- en: Table 4-1. <user> Element Attributes
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1. `<user>` 元素属性
- en: '| Name | Format | Description |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 格式 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `id` | integer | User ID |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `id` | 整数 | 用户 ID |'
- en: '| `serialNumber` | integer | User serial number |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `serialNumber` | 整数 | 用户序列号 |'
- en: '| `flags` | integer | Flags that indicate the type of user |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `flags` | 整数 | 表示用户类型的标志 |'
- en: '| `created` | milliseconds since the Unix epoch, as per `System.currentTimeMillis()`
    | User creation time |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `created` | 自 Unix 纪元以来的毫秒数，参照 `System.currentTimeMillis()` | 用户创建时间 |'
- en: '| `lastLoggedIn` | milliseconds since the Unix epoch, as per `System.currentTimeMillis()`
    | Last login time |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `lastLoggedIn` | 自 Unix 纪元以来的毫秒数，参照 `System.currentTimeMillis()` | 上次登录时间
    |'
- en: '| `icon` | string | Full path to the user icon file |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `icon` | 字符串 | 用户图标文件的完整路径 |'
- en: '| `partial` | Boolean | Indicates that the user is partially initialized. Partial
    users may not have all of their files and directories created yet. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `partial` | 布尔值 | 表示用户为部分初始化。部分用户可能还没有创建所有文件和目录。 |'
- en: '| `pinHash` | hexadecimal string | The salted SHA1+MD5 PIN hash for PIN-protected
    restrictions |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `pinHash` | 十六进制字符串 | 用于 PIN 保护限制条件的盐值 SHA1+MD5 PIN 哈希 |'
- en: '| `salt` | long integer | The PIN salt for PIN-protected restrictions |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `salt` | 长整型 | 用于 PIN 保护限制条件的 PIN 盐值 |'
- en: '| `failedAttempts` | integer | The number of failed PIN entry attempts for
    PIN-protected restrictions |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `failedAttempts` | 整数 | PIN 保护的限制条件下失败的 PIN 输入尝试次数 |'
- en: '| `lastAttemptMs` | milliseconds since the Unix epoch, as per `System.currentTimeMillis()`
    | The time of the last PIN entry attempt for PIN-protected restrictions (in milliseconds
    since the Unix epoch, per `System.currentTimeMillis()`) |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `lastAttemptMs` | 自 Unix 纪元以来的毫秒数，参照 `System.currentTimeMillis()` | 上次尝试输入
    PIN 的时间（单位为自 Unix 纪元以来的毫秒数，参照 `System.currentTimeMillis()`） |'
- en: 'The `flags` attribute is one of the most important as it determines the user
    type. As of this writing, six bits of the flag value are used for the user type
    and the rest are reserved with the following flags currently defined:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`flags` 属性是最重要的属性之一，因为它决定了用户的类型。截止目前，标志值的六个位被用于表示用户类型，其余部分是保留的，目前已定义以下标志：'
- en: '**`FLAG_PRIMARY` (0x00000001)** Marks the primary user.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`FLAG_PRIMARY` (0x00000001)** 标记主用户。'
- en: '**`FLAG_ADMIN` (0x00000002)** Marks administrator users. Administrator can
    create and delete users.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`FLAG_ADMIN` (0x00000002)** 标记管理员用户。管理员可以创建和删除用户。'
- en: '**`FLAG_GUEST` (0x00000004)** Marks the guest user.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`FLAG_GUEST` (0x00000004)** 标记访客用户。'
- en: '**`FLAG_RESTRICTED` (0x00000008)** Marks restricted users.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`FLAG_RESTRICTED` (0x00000008)** 标记为受限用户。'
- en: '**`FLAG_INITIALIZED` (0x00000010)** Marks a user as fully initialized.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`FLAG_INITIALIZED` (0x00000010)** 标记用户为完全初始化。'
- en: While different flag combinations are possible, most combinations don’t represent
    a valid user type or state, and in practice the attributes for the primary owner
    are set to 19 (0x13 or `FLAG_INITIALIZED|FLAG_ADMIN|FLAG_PRIMARY`), secondary
    users have flags 16 (0x10 or `FLAG_INITIALIZED`), and restricted profiles have
    flags 24 (0x18 or `FLAG_INITIALIZED|FLAG_RESTRICTED`).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不同的标志组合是可能的，但大多数组合并不表示有效的用户类型或状态，实际中主拥有者的属性设置为19（0x13或`FLAG_INITIALIZED|FLAG_ADMIN|FLAG_PRIMARY`），辅助用户的标志为16（0x10或`FLAG_INITIALIZED`），限制配置文件的标志为24（0x18或`FLAG_INITIALIZED|FLAG_RESTRICTED`）。
- en: User System Directory
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户系统目录
- en: Each user system directory contains user-specific system settings and data but
    no application data. As we’ll see in the next section, each application that a
    user installs gets a dedicated data directory under */data*, much like on single-user
    devices. (See [Chapter 3](ch03.html "Chapter 3. Package Management") for more
    on application data directories.) For example, in the case of a secondary user
    with user ID 12, the user system directory would be named */data/system/users/12/*
    and might contain the files and directories listed in [Example 4-7](ch04.html#contents_of_a_user_directory
    "Example 4-7. Contents of a user directory").
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户系统目录包含特定用户的系统设置和数据，但不包含应用数据。如我们在下一节中所看到的，每个用户安装的应用都会在*/data*目录下获得一个专用的数据目录，类似于单用户设备上的情况。（有关应用数据目录的更多信息，请参见[第3章](ch03.html
    "Chapter 3. Package Management")）。例如，对于用户ID为12的辅助用户，用户系统目录将命名为*/data/system/users/12/*，并可能包含[示例4-7](ch04.html#contents_of_a_user_directory
    "Example 4-7. Contents of a user directory")中列出的文件和目录。
- en: Example 4-7. Contents of a user directory
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4-7. 用户目录的内容
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The file *accounts.db* ➊ is an SQLite database that holds online account details.
    (We discuss online account management in [Chapter 8](ch08.html "Chapter 8. Online
    Account Management").) The file *appwidgets.xml* ➋ holds information about widgets
    that the user has added to their home screen. The *device_policies.xml* ➌ file
    describes the current device policy (see [Chapter 9](ch09.html "Chapter 9. Enterprise
    Security") for details), and *gesture.key* ➍ and *password.key* ➐ contain the
    hash of the currently selected lockscreen pattern or PIN/password, respectively
    (see [Chapter 10](ch10.html "Chapter 10. Device Security") for format details).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*accounts.db* ➊是一个SQLite数据库，存储在线账户的详细信息。（我们在[第8章](ch08.html "Chapter 8. Online
    Account Management")中讨论在线账户管理。）文件*appwidgets.xml* ➋存储有关用户已添加到主屏幕的小部件的信息。*device_policies.xml*
    ➌文件描述了当前设备策略（有关详细信息，请参见[第9章](ch09.html "Chapter 9. Enterprise Security")），而*gesture.key*
    ➍和*password.key* ➐分别包含当前选定的锁屏图案或PIN码/密码的哈希值（有关格式的详细信息，请参见[第10章](ch10.html "Chapter
    10. Device Security")）。
- en: The *inputmethod* directory ➎ contains information about input methods. The
    *photo.png* file ➑ stores the user’s profile image or picture. The file *settings.db*
    ➒ holds system settings specific to that user, and *wallpaper* ➓ is the currently
    selected wallpaper image. The *package-restrictions.xml* file ➏ defines what applications
    the user has installed and stores their state. (We discuss application sharing
    and per-user application data in the next section.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*inputmethod*目录 ➎包含有关输入法的信息。*photo.png*文件 ➑存储用户的个人资料图片或照片。*settings.db*文件 ➒保存特定于该用户的系统设置，而*wallpaper*
    ➓是当前选定的壁纸图片。*package-restrictions.xml*文件 ➏定义了用户安装了哪些应用，并存储它们的状态。（我们将在下一节中讨论应用共享和每用户应用数据。）'
- en: Per-User Application Management
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每用户应用管理
- en: As mentioned in “[Multi-User Support Overview](ch04.html#multi-user_support_overview
    "Multi-User Support Overview")”, besides dedicated accounts and settings, each
    user gets their own copy of application data that cannot be accessed by other
    users. Android achieves this by assigning a new, per-user effective UID for each
    application and creating a dedicated application data directory owned by that
    UID. We’ll discuss the details of this implementation in the following sections.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如在“[多用户支持概述](ch04.html#multi-user_support_overview "Multi-User Support Overview")”中提到的，除了专用账户和设置外，每个用户都会获得自己的一份应用数据副本，其他用户无法访问。Android通过为每个应用分配一个新的、按用户划分的有效UID，并为该UID创建一个专用的应用数据目录来实现这一点。我们将在接下来的章节中讨论这一实现的细节。
- en: Application Data Directories
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用数据目录
- en: As we covered in [Chapter 3](ch03.html "Chapter 3. Package Management"), Android
    installs APK packages by copying them to the */data/app/* directory, and creates
    a dedicated data directory for each application under */data/data/*. When multi-user
    support is enabled, this layout is not changed but extended to support additional
    users. Application data for the primary user is still stored in */data/data/*
    for backward compatibility.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第 3 章](ch03.html "第 3 章. 包管理")中讲到的，Android 通过将 APK 包复制到*/data/app/*目录来安装应用程序，并在*/data/data/*下为每个应用程序创建一个专用的数据目录。当启用多用户支持时，这一布局不会改变，而是扩展以支持额外的用户。主用户的应用数据仍然存储在*/data/data/*中，以便向后兼容。
- en: If other users exist on the system when a new application is being installed,
    the `PackageManagerService` creates application data directories for each user.
    As with the data directory for the primary user, those directories are created
    with the help of the *installd* daemon (using the `mkuserdata` command) because
    the *system* user does not have enough privileges to change directory ownership.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在安装新应用程序时系统上存在其他用户，`PackageManagerService` 会为每个用户创建应用数据目录。与主用户的数据目录一样，这些目录是通过
    *installd* 守护进程（使用`mkuserdata`命令）创建的，因为 *system* 用户没有足够的权限来更改目录所有权。
- en: User data directories are stored in */data/user/* and named after the user’s
    ID. The device owner directory (*0/*) is a symbolic link to */data/data/*, as
    shown in [Example 4-8](ch04.html#contents_of_solidusdatasolidususersolidu "Example 4-8. Contents
    of /data/user/ on a multi-user device").
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 用户数据目录存储在*/data/user/*中，并以用户的 ID 命名。设备所有者目录 (*0/*) 是一个符号链接，指向*/data/data/*，如[示例
    4-8](ch04.html#contents_of_solidusdatasolidususersolidu "示例 4-8. 多用户设备上 /data/user/
    的内容")所示。
- en: Example 4-8. Contents of /data/user/ on a multi-user device
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-8. 多用户设备上 /data/user/ 的内容
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The contents of each application data directory are the same as */data/ data/*,
    but application directories for each user’s instance of the same application are
    owned by a different Linux user, as shown in [Example 4-9](ch04.html#contents_of_application_data_directories
    "Example 4-9. Contents of application data directories for the primary user and
    one secondary user").
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用数据目录的内容与*/data/data/*相同，但每个用户实例的相同应用的目录由不同的 Linux 用户拥有，如[示例 4-9](ch04.html#contents_of_application_data_directories
    "示例 4-9. 主用户和一个次要用户的应用数据目录内容")所示。
- en: Example 4-9. Contents of application data directories for the primary user and
    one secondary user
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-9. 主用户和一个次要用户的应用数据目录内容
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This listing shows the contents of the app data directories for the primary
    user ➊ and the secondary user with user ID 13 ➌. As you can see, even though both
    users have data directories for the same apps, such as the browser app (➋ for
    the owner and ➍ for the secondary user), those directories are owned by different
    Linux users: *u0_a16* in the case of the owner and *u13_a16* in the case of the
    secondary user. If we check the UID for those users using the `su` and `id` commands,
    we find that *u0_a16* has UID=10016, and *u13_a16* has UID=1310016.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表显示了主用户➊和用户 ID 为 13 的次要用户➌的应用数据目录的内容。如你所见，尽管两个用户都拥有相同应用的应用数据目录，例如浏览器应用（主用户为➋，次要用户为➍），这些目录分别属于不同的
    Linux 用户：主用户为*u0_a16*，次要用户为*u13_a16*。如果我们使用`su`和`id`命令检查这些用户的 UID，会发现*u0_a16*的
    UID 为 10016，而*u13_a16*的 UID 为 1310016。
- en: 'The fact that both UIDs contain the number 10016 is no coincidence. The repeating
    part is called the *app ID* and is the same as the UID assigned to the app when
    first installed on a single-user device. On multiuser devices, the app UID is
    derived from the user ID and the app ID using the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 UID 都包含数字 10016 这一事实并非巧合。重复的部分称为 *应用程序 ID*，它与应用程序在单用户设备上首次安装时分配的 UID 相同。在多用户设备上，应用程序的
    UID 是通过以下代码从用户 ID 和应用程序 ID 派生出来的：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because the owner’s user ID is always 0, the UIDs for the device owner’s apps
    are always the same as their app IDs. When the same application is executed in
    the context of different users, it executes under the respective UIDs assigned
    to each user’s application instance. For example, if the browser application is
    executed simultaneously by the device owner and a secondary user with user ID
    13, two separate processes running as the *u0_a16* and *u13_a16* Linux users will
    be created (UID 10016, for the owner ➊ and UID 1310016, for the secondary user
    ➋) as shown in [Example 4-10](ch04.html#process_information_for_the_browser_appl
    "Example 4-10. Process information for the browser application when executed by
    different device users").
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因为拥有者的用户 ID 总是 0，所以设备拥有者的应用的 UID 总是与其应用 ID 相同。当同一个应用在不同用户的上下文中执行时，它会在分配给每个用户应用实例的相应
    UID 下执行。例如，如果浏览器应用同时由设备拥有者和用户 ID 为 13 的次级用户执行，将会创建两个分别作为 *u0_a16* 和 *u13_a16*
    的 Linux 用户进程（设备拥有者的 UID 为 10016 ➊，次级用户的 UID 为 1310016 ➋），如 [示例 4-10](ch04.html#process_information_for_the_browser_appl
    "示例 4-10. 不同设备用户执行浏览器应用时的进程信息") 所示。
- en: Example 4-10. Process information for the browser application when executed
    by different device users
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-10. 不同设备用户执行浏览器应用时的进程信息
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Application Sharing
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用共享
- en: While installed applications have a dedicated data directory for each user,
    the APK files are shared among all users. The APK files are copied to */data/app/*
    and are readable by all users; shared libraries used by apps are copied to */data/app-lib/<package
    name>/* and are symlinked to */data/ user/<user ID>/<package name>/lib/*; and
    the optimized DEX files for each app are stored in */data/dalvik-cache/* and are
    also shared by all users. Thus once an application is installed, it is accessible
    to all device users, and an app data directory is automatically created for each
    user.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然已安装的应用程序为每个用户提供了专用的数据目录，但 APK 文件在所有用户之间共享。APK 文件被复制到 */data/app/* 并且对所有用户可读；应用程序使用的共享库被复制到
    */data/app-lib/<package name>/* 并通过符号链接链接到 */data/user/<user ID>/<package name>/lib/*；每个应用的优化
    DEX 文件存储在 */data/dalvik-cache/* 中，并且也由所有用户共享。因此，一旦应用程序被安装，它对于所有设备用户都是可访问的，并且会自动为每个用户创建一个应用数据目录。
- en: Android makes it possible for users to have different applications by creating
    a *package-restrictions.xml* file (➏ in [Example 4-7](ch04.html#contents_of_a_user_directory
    "Example 4-7. Contents of a user directory")) in the system directory of each
    user, which it uses to track whether an app is enabled for a user or not. Besides
    the install state of packages, this file contains information about the disabled
    components of each application, as well as a list of preferred applications to
    start when processing intents that can be handled by more than one application
    (such as opening a text file, for example). The contents of *package-restrictions.xml*
    might look like [Example 4-11](ch04.html#contents_of_the_package-restrictionsdotx
    "Example 4-11. Contents of the package-restrictions.xml file") for a secondary
    user.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Android 通过在每个用户的系统目录中创建一个 *package-restrictions.xml* 文件（见 [示例 4-7](ch04.html#contents_of_a_user_directory
    "示例 4-7. 用户目录的内容") ➏），使得用户可以拥有不同的应用程序，Android 使用该文件跟踪某个应用是否启用。除了包的安装状态外，该文件还包含有关每个应用禁用的组件的信息，以及在处理可以由多个应用处理的意图时，启动的首选应用列表（例如打开文本文件）。*package-restrictions.xml*
    文件的内容可能如下所示 [示例 4-11](ch04.html#contents_of_the_package-restrictionsdotx "示例 4-11.
    package-restrictions.xml 文件的内容")，针对次级用户的情况。
- en: Example 4-11. Contents of the package-restrictions.xml file
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-11. package-restrictions.xml 文件的内容
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the `com.example.app` package is available on the system but is not installed
    for that secondary user, as expressed by adding a `<pkg>` for the app and setting
    the `inst` attribute to `false` ➊. Based on this information, the `PackageManagerService`
    marks the `com.example.app` package as not installed for that user and the package
    doesn’t show up in the launcher or the list of apps in Settings.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`com.example.app` 包在系统上可用，但没有为该次用户安装，如通过添加 `<pkg>` 来表示该应用并将 `inst` 属性设置为
    `false` ➊。根据此信息，`PackageManagerService` 将 `com.example.app` 包标记为该用户未安装，因此该包不会出现在启动器或设置中的应用列表中。
- en: Applications can be installed but still marked as stopped, as shown at ➋. Here,
    the `com.example.app2` package is installed but marked as stopped by setting the
    `stopped` attribute to `true`. Android has a special state for applications that
    have never been launched; a state that is persisted with the `nl` attribute of
    the `<pkg>` tag. The device owner can block a package for a certain user, in which
    case the `blocked` attribute is set to `true`, though this is not shown in [Figure 4-4](ch04.html#warning_shown_when_the_device_owner_trie
    "Figure 4-4. Warning shown when the device owner tries to uninstall an app for
    all users").
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以被安装，但仍然标记为停止，如➋所示。在这里，`com.example.app2`包被安装，但通过将`stopped`属性设置为`true`，该应用被标记为停止。Android有一个特别的状态，针对那些从未启动过的应用；该状态通过`<pkg>`标签中的`nl`属性来保存。设备所有者可以阻止某个用户使用某个包，在这种情况下，`blocked`属性会被设置为`true`，但这不会在[图4-4](ch04.html#warning_shown_when_the_device_owner_trie
    "图4-4. 设备所有者尝试为所有用户卸载应用时显示的警告")中显示。
- en: When a device user installs an application, a `<pkg>` tag with `inst="false"`
    is added to the *package-restrictions.xml* files for all users. When another user
    installs the same application, the `inst` attribute is removed and the application
    is considered installed for that user. (Depending on how the second user started
    the install process, the APK file in */data/app/* may be replaced, as it is in
    an application update.)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备用户安装应用时，`inst="false"`标签会被添加到所有用户的*package-restrictions.xml*文件中。当其他用户安装相同的应用时，`inst`属性会被移除，应用被视为已为该用户安装。（根据第二个用户启动安装过程的方式，*/data/app/*中的APK文件可能会被替换，类似于应用更新的情况。）
- en: 'Restricted users cannot install applications, but the same procedure is applied
    when the device owner enables an app for a restricted user: the application is
    installed by calling the `PackageManagerService.installExistingPackageAsUser()`
    method, which sets the installed flag for the package and updates *package-restrictions.xml*
    accordingly.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 受限用户无法安装应用，但当设备所有者为受限用户启用应用时，仍然会按照相同的程序进行：应用通过调用`PackageManagerService.installExistingPackageAsUser()`方法安装，该方法为包设置安装标志，并相应地更新*package-restrictions.xml*文件。
- en: '![Warning shown when the device owner tries to uninstall an app for all users](figs/web/04fig04.png.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![设备所有者尝试为所有用户卸载应用时显示的警告](figs/web/04fig04.png.jpg)'
- en: Figure 4-4. Warning shown when the device owner tries to uninstall an app for
    all users
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-4. 设备所有者尝试为所有用户卸载应用时显示的警告
- en: When a user uninstalls a package, their app data is deleted and the internal
    per-user package installed flag is set to `false`. This state is then persisted
    by setting `inst="false"` to the removed package’s tag in the user’s *package-restrictions.xml*
    file. The APK file and native library directory are only removed when the last
    user that has the app installed uninstalls it. However, the owner can see all
    apps installed on the system in the All tab of the Apps Settings screen, including
    ones they haven’t installed, and they can uninstall those apps for all users.
    The **`Uninstall for all users`** action is hidden in the overflow menu so that
    it isn’t selected accidentally. It produces the warning shown in [Figure 4-4](ch04.html#warning_shown_when_the_device_owner_trie
    "Figure 4-4. Warning shown when the device owner tries to uninstall an app for
    all users"). If the owner selects OK in this warning dialog, app directories for
    all users are removed and the APK file is deleted from the device.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户卸载一个应用包时，他们的应用数据会被删除，且每个用户的包安装标志会被设置为`false`。这个状态会通过在用户的*package-restrictions.xml*文件中为已移除包的标签设置`inst="false"`来保存。APK文件和本地库目录仅在最后一个安装了该应用的用户卸载应用时才会被移除。然而，设备所有者可以在“应用设置”界面的“所有”标签页中查看系统上安装的所有应用，包括他们没有安装的应用，他们可以为所有用户卸载这些应用。**`为所有用户卸载`**操作会隐藏在溢出菜单中，以避免被意外选中。该操作会弹出警告，警告内容见[图4-4](ch04.html#warning_shown_when_the_device_owner_trie
    "图4-4. 设备所有者尝试为所有用户卸载应用时显示的警告")。如果设备所有者在警告对话框中点击确定，所有用户的应用目录将被删除，APK文件也将从设备中删除。
- en: 'The app-sharing scheme implemented on multi-user Android devices is backward-compatible
    with previous versions and saves device space by not copying APK files for all
    users. However, it has one major disadvantage: any user can update an application,
    even if it was originally installed by another user.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在多用户Android设备上实现的应用共享方案向后兼容以前的版本，并通过不为所有用户复制APK文件来节省设备空间。然而，它也有一个主要的缺点：任何用户都可以更新应用，即使它最初是由另一个用户安装的。
- en: This scheme is usually not a problem, because every user’s app instance has
    a separate data directory, except when the update adds new permissions. Because
    Android grants permissions at install time, if a user updates an app and accepts
    a new permission that affects user privacy (for example, `READ_CONTACTS`), that
    permission will apply to all users who use the app. Other users are not notified
    that the app has been granted a new permission and may never notice the change,
    unless they manually inspect the app’s details in system Settings. Android does
    show a warning that notifies users about this fact when they first enable multi-user
    support, but does not send subsequent notifications about specific apps.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方案通常没有问题，因为每个用户的应用实例都有一个单独的数据目录，除非更新添加了新的权限。由于 Android 在安装时授予权限，如果用户更新了一个应用并接受了一个影响用户隐私的新权限（例如，`READ_CONTACTS`），那么这个权限将适用于所有使用该应用的用户。其他用户不会被通知该应用已经被授予新权限，并且可能永远不会注意到这一变化，除非他们手动检查系统设置中的应用详细信息。Android
    确实会在首次启用多用户支持时显示警告，提醒用户这一事实，但不会针对特定应用发送后续通知。
- en: External Storage
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部存储
- en: Android has included support for external storage since the first public versions.
    Because the first few generations of Android devices implemented external storage
    by simply mounting a FAT-formatted removable SD card, external storage is often
    referred to as “the SD card.” However, the definition of external storage is broader
    and simply requires that external storage be a “case-insensitive filesystem with
    immutable POSIX permission classes and modes.”^([[30](#ftn.ch04fn02)]) The underlying
    implementation may be anything that satisfies this definition.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Android 从最早的公开版本开始就支持外部存储。因为最初几代 Android 设备通过简单地挂载一个 FAT 格式的可移动 SD 卡来实现外部存储，所以外部存储常常被称为“SD
    卡”。然而，外部存储的定义更为广泛，只要求外部存储是一个“区分大小写的文件系统，具有不可变的 POSIX 权限类和模式。”^([[30](#ftn.ch04fn02)])
    底层实现可以是任何满足这个定义的东西。
- en: External Storage Implementations
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部存储实现
- en: Newer devices tend to implement external storage by emulation, and some don’t
    have an SD card slot at all. For example, the last Google Nexus device that had
    an SD card slot was the Nexus One, released in January 2010, and all Nexus devices
    released after the Nexus S (which uses a dedicated partition for external storage)
    implement external storage by emulation. On devices that lack an SD card, external
    storage is implemented either by directly mounting a FAT-formatted partition,
    which resides on the same block device as primary storage, or by using a helper
    daemon to emulate it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的设备倾向于通过仿真来实现外部存储，有些设备甚至根本没有 SD 卡槽。例如，最后一款带有 SD 卡槽的 Google Nexus 设备是 2010
    年 1 月发布的 Nexus One，而所有 Nexus 设备（包括在 Nexus S 后发布的设备，这些设备使用专用分区来处理外部存储）都通过仿真来实现外部存储。在没有
    SD 卡槽的设备上，外部存储通常是通过直接挂载一个 FAT 格式的分区，该分区与主存储设备位于同一个块设备上，或者使用一个辅助守护进程来进行仿真。
- en: Beginning with Android version 4.4, apps have been able to manage their package-specific
    directories (*Android/data/com.example.app/* for an app with the `com.example.app`
    package) on external storage without requiring the `WRITE_EXTERNAL_STORAGE` permission,
    which grants access to all data on external storage, including camera pictures,
    videos, and other media. This feature is called *synthesized permissions* and
    its AOSP implementation is based on a FUSE daemon that wraps the raw device storage
    and manages file access and permission based on a specified permission emulation
    mode.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Android 4.4 版本开始，应用程序可以管理其特定于包的目录（例如，`com.example.app` 包的应用程序位于 *Android/data/com.example.app/*）在外部存储上，而不需要
    `WRITE_EXTERNAL_STORAGE` 权限，该权限允许访问外部存储上的所有数据，包括相机照片、视频和其他媒体。这个功能叫做 *合成权限*，其 AOSP
    实现基于一个 FUSE 守护进程，它将原始设备存储封装起来，并根据指定的权限仿真模式管理文件访问和权限。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Filesystem in Userspace*, or* FUSE,^([[31](#ftn.ch04fn03)]) *is a Linux feature
    that allows the implementation of a fully functional filesystem in a userspace
    program. This is achieved by using a generic FUSE kernel module that routes all
    Virtual Filesystem (VFS) system calls for the target filesystem to its userspace
    implementation. The kernel module and the user-space implementation communicate
    via a special file descriptor obtained by opening* /dev/fuse.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间文件系统*，或称 FUSE，^([[31](#ftn.ch04fn03)]) *是 Linux 的一项功能，允许在用户空间程序中实现一个完全功能的文件系统。这是通过使用一个通用的
    FUSE 内核模块来实现的，该模块将所有针对目标文件系统的虚拟文件系统（VFS）系统调用路由到其用户空间实现。内核模块和用户空间实现通过打开 * /dev/fuse
    获取的特殊文件描述符进行通信。
- en: As of Android version 4.4, multiple external storage devices can be accessed
    by applications, but the applications are only allowed to write arbitrary files
    on *primary external storage* (if they hold the `WRITE_EXTERNAL_STORAGE` permission),
    and they have only limited access to other external storage devices, referred
    to as *secondary external storage*. Our discussion will focus on primary external
    storage as it’s most closely related to multi-user support.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Android 版本 4.4 开始，应用程序可以访问多个外部存储设备，但仅允许它们在 *主要外部存储* 上写入任意文件（前提是它们持有 `WRITE_EXTERNAL_STORAGE`
    权限），并且只能有限地访问其他外部存储设备，这些设备被称为 *次要外部存储*。我们的讨论将重点关注主要外部存储，因为它与多用户支持关系最为密切。
- en: Multi-User External Storage
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多用户外部存储
- en: In order to uphold the Android security model in a multi-user environment, the
    Android Compatibility Definition Document (CDD) places numerous requirements on
    external storage. The most important of these is that “Each user instance on an
    Android device MUST have separate and isolated external storage directories.”
    ^([[32](#ftn.ch04fn04)])
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在多用户环境中维护 Android 的安全模型，Android 兼容性定义文档（CDD）对外部存储提出了诸多要求。其中最重要的一条是：“每个 Android
    设备上的用户实例必须拥有独立且隔离的外部存储目录。”^([[32](#ftn.ch04fn04)])
- en: 'Unfortunately, implementing this requirement poses a problem because external
    storage has traditionally been world-readable and implemented using the FAT filesystem,
    which does not support permissions. Google’s implementation of multi-user external
    storage leverages three Linux kernel features in order to provide backward-compatible,
    per-user external storage: mount namespaces, bind mounts, and shared subtrees.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，实现这一要求存在问题，因为外部存储传统上是全局可读的，并且使用 FAT 文件系统实现，而 FAT 文件系统不支持权限。Google 对多用户外部存储的实现利用了三个
    Linux 内核特性，以提供向后兼容的、按用户划分的外部存储：挂载命名空间、绑定挂载和共享子树。
- en: Advanced Linux Mount Features
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级 Linux 挂载功能
- en: As in other Unix systems, Linux manages all files from all storage devices as
    part of a single directory tree. Each filesystem is linked to a specific subtree
    by mounting it at a specified directory, called the *mount point*. Traditionally,
    the directory tree has been shared by all processes, and each process sees the
    same directory hierarchy.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如同其他 Unix 系统一样，Linux 将来自所有存储设备的所有文件作为单一目录树的一部分进行管理。每个文件系统通过在指定目录（称为 *挂载点*）处挂载来链接到特定的子树。传统上，目录树是所有进程共享的，每个进程看到的是相同的目录层次结构。
- en: Linux 2.4.19 and later versions added support for per-process mount namespaces,
    which allows each process to have its own set of mount points and thus use a directory
    hierarchy different from that of other processes.^([[33](#ftn.ch04fn05)]) The
    current list of mounts for each process can be read from the */proc/PID/ mounts*
    virtual file, where *PID* is the process ID. A forked Linux process can request
    a separate mount namespace by specifying the `CLONE_NEWNS` flag to the Linux-specific
    `clone()`^([[34](#ftn.ch04fn06)]) and `unshare()`^([[35](#ftn.ch04fn07)]) system
    calls. In this case, the namespace of the parent process is referred to as the
    *parent namespace*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 2.4.19 及更高版本添加了对每个进程挂载命名空间的支持，这使得每个进程可以拥有自己的一组挂载点，从而使用与其他进程不同的目录层次结构。^([[33](#ftn.ch04fn05)])
    当前每个进程的挂载列表可以从 */proc/PID/mounts* 虚拟文件中读取，其中 *PID* 是进程ID。一个被 fork 的 Linux 进程可以通过在
    Linux 特有的 `clone()`^([[34](#ftn.ch04fn06)]) 和 `unshare()`^([[35](#ftn.ch04fn07)])
    系统调用中指定 `CLONE_NEWNS` 标志来请求一个单独的挂载命名空间。在这种情况下，父进程的命名空间被称为 *父命名空间*。
- en: A *bind mount* allows a directory or file to be mounted at another path in the
    directory tree, making the same file or directory visible at multiple locations.
    A bind mount is created by specifying the `MS_BIND` flag to the `mount()` system
    call, or by passing the `--bind` parameter to the `mount` command.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*绑定挂载* 允许一个目录或文件在目录树中的另一路径上挂载，从而使同一个文件或目录在多个位置可见。绑定挂载通过在 `mount()` 系统调用中指定
    `MS_BIND` 标志，或者通过向 `mount` 命令传递 `--bind` 参数来创建。'
- en: 'Finally, *shared subtrees*,^([[36](#ftn.ch04fn08)]) which were first introduced
    in Linux 2.6.15, provide a way to control how filesystem mounts are propagated
    across mount namespaces. Shared subtrees make it possible for a process to have
    its own namespace but still access filesystems that are mounted after it starts.
    Shared subtrees provide four different mount types, of which Android uses the
    shared and slave mount. A *shared mount* created in a parent namespace propagates
    to all child namespaces and is thus visible to all processes that have cloned
    off a namespace. A *slave mount* has a master mount that is a shared mount, and
    also propagates new mounts. However, the propagation is one-way only: mounts at
    the master propagate to the slave, but mounts at the slave do not propagate to
    the master. This scheme allows a process to keep its mounts invisible to any other
    process, while still being able to see shared system mounts. Shared mounts are
    created by passing the `MS_SHARED` flag to the `mount()` system call, while creating
    slave mounts requires passing the `MS_SLAVE` flag.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*共享子树*，^([[36](#ftn.ch04fn08)])首次在 Linux 2.6.15 中引入，提供了一种控制文件系统挂载在挂载命名空间中传播的方式。共享子树使得进程能够拥有自己的命名空间，但仍能访问在启动后挂载的文件系统。共享子树提供了四种不同的挂载类型，其中
    Android 使用了共享挂载和从属挂载。*共享挂载* 在父命名空间中创建后会传播到所有子命名空间，因此对所有已克隆命名空间的进程都是可见的。*从属挂载*
    有一个共享挂载作为主挂载，并且也会传播新的挂载。然而，传播是单向的：主挂载的挂载会传播到从属挂载，但从属挂载的挂载不会传播到主挂载。此方案允许进程将其挂载保持对其他任何进程不可见，同时仍然能够看到共享的系统挂载。通过向
    `mount()` 系统调用传递 `MS_SHARED` 标志来创建共享挂载，而创建从属挂载则需要传递 `MS_SLAVE` 标志。
- en: Android Implementation
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android 实现
- en: Since Android 4.4, mounting external storage directly is no longer supported
    but is emulated using the FUSE *sdcard* daemon, even when the underlying device
    is a physical SD card. We’ll base our discussion on a configuration that is backed
    by a directory on internal storage, which is typical for devices without a physical
    SD card. (The official documentation^([[37](#ftn.ch04fn09)]) contains more details
    on other possible configurations.)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Android 4.4 起，直接挂载外部存储不再被支持，而是通过 FUSE *sdcard* 守护进程进行模拟，即使底层设备是物理 SD 卡。我们将基于一个由内部存储目录支持的配置进行讨论，这对于没有物理
    SD 卡的设备是典型配置。（官方文档^([[37](#ftn.ch04fn09)])包含了有关其他可能配置的更多细节。）
- en: On a device where primary external storage is backed by internal storage, the
    *sdcard* FUSE daemon uses the */data/media/* directory as a source and creates
    an emulated filesystem at */mnt/shell/emulated*. [Example 4-12](ch04.html#sdcard_service_declaration_for_emulated
    "Example 4-12. sdcard service declaration for emulated external storage") shows
    how the *sdcard* service is declared in the device-specific *init.rc* file in
    this case ➐.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个主外部存储由内部存储支持的设备上，*sdcard* FUSE 守护进程使用 */data/media/* 目录作为源，并在 */mnt/shell/emulated*
    创建一个模拟文件系统。[示例 4-12](ch04.html#sdcard_service_declaration_for_emulated "示例 4-12.
    为模拟外部存储声明 sdcard 服务") 显示了在这种情况下，如何在设备特定的 *init.rc* 文件中声明 *sdcard* 服务 ➐。
- en: Example 4-12. sdcard service declaration for emulated external storage
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-12. 为模拟外部存储声明 sdcard 服务
- en: '[PRE12]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, the `-u` and `-g` options specify the user and group the daemon should
    run as, and `-l` specifies the layout used for emulated storage (discussed later
    in this section). As you can see at ➊, the */mnt/shell/emulated/* directory (available
    via the `EMULATED_STORAGE_SOURCE` environment variable ➍) is owned and only accessible
    by the *shell* user. Its contents might look like [Example 4-13](ch04.html#contents_of_solidusmntsolidusshellsolidu
    "Example 4-13. Contents of /mnt/shell/emulated/") on a device with five users.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`-u` 和 `-g` 选项指定了守护进程应该以哪个用户和组身份运行，`-l` 指定了用于模拟存储的布局（将在本节稍后讨论）。如 ➊ 所示，*/mnt/shell/emulated/*
    目录（通过 `EMULATED_STORAGE_SOURCE` 环境变量 ➍ 可用）由 *shell* 用户拥有并且仅该用户可访问。其内容在拥有五个用户的设备上可能类似于
    [示例 4-13](ch04.html#contents_of_solidusmntsolidusshellsolidu "示例 4-13. /mnt/shell/emulated/
    的内容")。
- en: Example 4-13. Contents of /mnt/shell/emulated/
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-13. /mnt/shell/emulated/ 的内容
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As with app data directories, each user gets a dedicated external storage data
    directory named after their user ID. Android uses a combination of mount namespaces
    and bind mounts in order to make each user’s external storage data directory available
    only to the applications that the user starts, without showing them other users’
    data directories. Because all applications are forked off the *zygote* process
    (discussed in [Chapter 2](ch02.html "Chapter 2. Permissions")), external storage
    setup is implemented in two steps: the first one is common to all processes, and
    the second is specific to each process. First, mount points that are shared by
    all forked app processes are set up in the unique *zygote* process. Then dedicated
    mount points, which are visible only to that process, are set up as part of each
    app’s process specialization.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 与应用数据目录一样，每个用户都有一个专用的外部存储数据目录，该目录以用户的 ID 命名。Android 使用挂载命名空间和绑定挂载的组合，使每个用户的外部存储数据目录仅对用户启动的应用程序可用，而不会显示其他用户的数据目录。由于所有应用程序都是从
    *zygote* 进程分叉出来的（详见 [第 2 章](ch02.html "第 2 章. 权限")），外部存储设置分为两步：第一步是所有进程共有的，第二步是每个进程特有的。首先，在唯一的
    *zygote* 进程中设置所有分叉的应用进程共享的挂载点。然后，设置每个应用进程专用的挂载点，这些挂载点仅对该进程可见。
- en: Let’s first look at the shared part in the *zygote* process. [Example 4-14](ch04.html#mount_point_setup_in_zygote
    "Example 4-14. Mount point setup in zygote") shows an excerpt of the `initZygote()`
    function (found in *dalvik/vm/Init.cpp*) that highlights mount point setup.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们看看 *zygote* 进程中的共享部分。[示例 4-14](ch04.html#mount_point_setup_in_zygote "示例
    4-14. zygote 中的挂载点设置") 显示了 `initZygote()` 函数的摘录（该函数位于 *dalvik/vm/Init.cpp* 中），重点展示了挂载点设置。
- en: Example 4-14. Mount point setup in zygote
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-14. zygote 中的挂载点设置
- en: '[PRE14]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, *zygote* passes the `CLONE_NEWNS` flag to the `unshare()` system call
    ➊ in order to create a new, private mount namespace that will be shared by all
    its children (app processes). It then marks the root filesystem (mounted at /)
    as a slave by passing the `MS_SLAVE` flag to the `mount()` system call ➋. This
    ensures that changes from the default mount namespace, such as mounting encrypted
    containers or removable storage, only propagate to its children, while at the
    same time making sure that any mounts created by children do not propagate into
    the default namespace. Finally, *zygote* creates the memory-backed `EMULATED_STORAGE_TARGET`
    (usually */storage/emulated/*) mount point by creating a *tmpfs* filesystem ➌,
    which children use to bind mount external storage into their private namespaces.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*zygote* 将 `CLONE_NEWNS` 标志传递给 `unshare()` 系统调用 ➊，以创建一个新的私有挂载命名空间，并由其所有子进程（应用进程）共享。接着，它通过将
    `MS_SLAVE` 标志传递给 `mount()` 系统调用 ➋ 将根文件系统（挂载在 / 下）标记为从属。这确保了来自默认挂载命名空间的更改（如挂载加密容器或可移动存储）仅传播到其子进程，同时确保任何子进程创建的挂载不会传播到默认命名空间。最后，*zygote*
    通过创建一个 *tmpfs* 文件系统 ➌ 创建了一个基于内存的 `EMULATED_STORAGE_TARGET`（通常是 */storage/emulated/*）挂载点，子进程使用该挂载点将外部存储绑定挂载到它们的私有命名空间中。
- en: '[Example 4-15](ch04.html#external_storage_setup_for_app_processes "Example 4-15. External
    storage setup for app processes") shows the process-specific mount point setup
    found in *dalvik/vm/native/dalvik_system_Zygote.cpp* that is executed when forking
    each app process off *zygote*. (Error handling, logging, and some variable declarations
    have been omitted.)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-15](ch04.html#external_storage_setup_for_app_processes "示例 4-15. 应用进程的外部存储设置")
    显示了在 *dalvik/vm/native/dalvik_system_Zygote.cpp* 中找到的特定进程挂载点设置，该设置在从 *zygote*
    分叉每个应用进程时执行。（错误处理、日志记录和某些变量声明已被省略。）'
- en: Example 4-15. External storage setup for app processes
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-15. 应用进程的外部存储设置
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, the `mountEmulatedStorage()` function first obtains the current user ID
    from the process UID ➊, then uses the `unshare()` system call to create a new
    mount namespace for the process by passing the `CLONE_NEWNS` flag ➋. The function
    then obtains the values of the `EMULATED_STORAGE_SOURCE` ➌, `EMULATED_STORAGE_TARGET`
    ➍, and `EXTERNAL_STORAGE` ➎ environment variables, which are all initialized in
    the device-specific *init.rc* file (see ➌, ➍, and ➎ in [Example 4-12](ch04.html#sdcard_service_declaration_for_emulated
    "Example 4-12. sdcard service declaration for emulated external storage")). It
    then prepares the mount source ➏ and target ➐ directory paths based on the values
    of `EMULATED_STORAGE_SOURCE`, `EMULATED_STORAGE_TARGET`, and the current user
    ID.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`mountEmulatedStorage()` 函数首先通过进程 UID 获取当前用户 ID ➊，然后使用 `unshare()` 系统调用通过传递
    `CLONE_NEWNS` 标志为进程创建一个新的挂载命名空间 ➋。然后该函数获取环境变量 `EMULATED_STORAGE_SOURCE` ➌、`EMULATED_STORAGE_TARGET`
    ➍ 和 `EXTERNAL_STORAGE` ➎ 的值，这些环境变量都在设备特定的 *init.rc* 文件中初始化（请参见 [示例 4-12](ch04.html#sdcard_service_declaration_for_emulated
    "示例 4-12. 模拟外部存储的 sdcard 服务声明") 中的 ➌、➍ 和 ➎）。接下来，它根据 `EMULATED_STORAGE_SOURCE`、`EMULATED_STORAGE_TARGET`
    和当前用户 ID 的值准备挂载源 ➏ 和目标 ➐ 目录路径。
- en: The directories are created if they don’t exist, and then the method bind mounts
    the source directory (such as */mnt/shell/emulated/0* for the owner user) at the
    target path (for example, */storage/emulated/0* for the owner user) ➑. This ensures
    that external storage is accessible from the Android shell (started with the *adb
    shell* command), which is used extensively for application development and debugging.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目录不存在，它们会被创建，然后该方法会将源目录（例如 */mnt/shell/emulated/0* 为拥有者用户）绑定挂载到目标路径（例如 */storage/emulated/0*
    为拥有者用户）➑。这样可以确保外部存储能够通过 Android shell（通过 *adb shell* 命令启动）访问，该功能在应用开发和调试中广泛使用。
- en: The final step is to recursively bind mount the target directory at the fixed
    legacy directory (*/storage/emulated/legacy/*) ➒. The legacy directory is symlinked
    to */sdcard/* in the device-specific *init.rc* file (➏ in [Example 4-12](ch04.html#sdcard_service_declaration_for_emulated
    "Example 4-12. sdcard service declaration for emulated external storage")) for
    backward compatibility with apps that hardcode this path (normally obtained using
    the `android.os.Environment.getExternalStorageDirectory()` API).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将目标目录递归地绑定挂载到固定的遗留目录（*/storage/emulated/legacy/*）➒。遗留目录在设备特定的 *init.rc*
    文件中通过符号链接指向 */sdcard/*（➏ 在 [示例 4-12](ch04.html#sdcard_service_declaration_for_emulated
    "示例 4-12. 模拟外部存储的 sdcard 服务声明")），以便与硬编码此路径的应用保持向后兼容（通常通过 `android.os.Environment.getExternalStorageDirectory()`
    API 获取此路径）。
- en: After all steps have been executed, the newly created app process is guaranteed
    to see only the external storage allotted to the user that started it. We can
    verify this by looking at the list of mounts for two app process executed by different
    users as shown in [Example 4-16](ch04.html#list_of_mount_points_for_process_started
    "Example 4-16. List of mount points for process started by different users").
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完所有步骤后，新创建的应用进程只会看到分配给启动它的用户的外部存储。我们可以通过查看由不同用户启动的两个应用进程的挂载列表来验证这一点，具体内容如
    [示例 4-16](ch04.html#list_of_mount_points_for_process_started "示例 4-16. 不同用户启动的进程的挂载点列表")
    所示。
- en: Example 4-16. List of mount points for process started by different users
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-16. 不同用户启动的进程的挂载点列表
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the process started by the owner user with PID 7382 has a */storage/ emulated/0*
    mount point ➋, which is a bind mount of */mnt/shell/emulated/0/*, and process
    7538 (started by a secondary user) has a */storage/emulated/10* mount point ➎,
    which is a bind mount of */mnt/shell/emulated/10/*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，由拥有者用户启动的进程（PID 为 7382）有一个 */storage/emulated/0* 挂载点 ➋，这是 */mnt/shell/emulated/0/*
    的绑定挂载，而由次要用户启动的进程（PID 为 7538）有一个 */storage/emulated/10* 挂载点 ➎，这是 */mnt/shell/emulated/10/*
    的绑定挂载。
- en: Because neither process has a mount point for the other process’s external storage
    directory, each process can only see and modify its own files. Both processes
    have a */storage/emulated/legacy* mount point (➌ and ➏), but because it is bound
    to different directories (*/storage/emulated/0/* and */mnt/ shell/emulated/10/*,
    respectively), each process sees different contents. Both process can see */mnt/shell/emulated/*
    (➊ and ➍), but because this directory is only accessible to the *shell* user (permissions
    0700), app processes cannot see its contents.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两个进程没有对方外部存储目录的挂载点，每个进程只能看到并修改自己的文件。两个进程都有一个*/storage/emulated/legacy*挂载点（➌和➏），但由于它们绑定到不同的目录（分别是*/storage/emulated/0/*
    和 */mnt/shell/emulated/10/*），每个进程看到的内容不同。两个进程都可以看到*/mnt/shell/emulated/*（➊和➍），但因为该目录仅对*shell*用户可访问（权限0700），应用程序进程无法看到其内容。
- en: External Storage Permissions
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部存储权限
- en: In order to emulate the FAT filesystem that was originally used for external
    storage, the *sdcard* FUSE daemon assigns fixed owner, group, and access permissions
    to each file or directory on external storage. Additionally, permissions are not
    changeable, and symlinks and hardlinks are not supported. The assigned owner and
    permission are determined by the permission derivation mode that the *sdcard*
    daemon uses.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟最初用于外部存储的 FAT 文件系统，*sdcard* FUSE 守护进程为外部存储上的每个文件或目录分配固定的所有者、组和访问权限。此外，权限不可更改，且不支持符号链接和硬链接。分配的所有者和权限由*sdcard*守护进程使用的权限推导模式决定。
- en: In legacy mode (specified with the `-l` option), which is backward-compatible
    with previous Android versions and which is still the default in Android 4.4,
    most files and directories are owned by the root user and their group is set to
    *sdcard_r*. Applications that are granted the `READ_EXTERNAL_STORAGE` permission
    have *sdcard_r* as one of their supplementary groups, and thus can read most files
    on external storage even if they were originally created by a different application.
    [Example 4-17](ch04.html#owner_and_permissions_of_files_on_extern "Example 4-17. Owner
    and permissions of files on external storage") shows the owner and permission
    of files and directories in the root of external storage.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在遗留模式下（通过`-l`选项指定），该模式向后兼容先前的 Android 版本，并且仍然是 Android 4.4 中的默认模式，大多数文件和目录的所有者是
    root 用户，并且它们的组被设置为*sdcard_r*。授予 `READ_EXTERNAL_STORAGE` 权限的应用程序具有*sdcard_r*作为其附加组，因此即使文件最初由其他应用程序创建，它们也可以读取外部存储上的大多数文件。[示例
    4-17](ch04.html#owner_and_permissions_of_files_on_extern "示例 4-17. 外部存储中文件的所有者和权限")显示了外部存储根目录中文件和目录的所有者和权限。
- en: Example 4-17. Owner and permissions of files on external storage
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-17. 外部存储中文件的所有者和权限
- en: '[PRE17]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In previous versions of Android, all files and directories on external storage
    were assigned the same owner and permissions, but Android 4.4 treats the application-specific
    external files directory (*Android/data/<package-name>/*, the exact path is returned
    by the `Context.getExternalFilesDir()` method) differently. Applications don’t
    have to hold the `WRITE_EXTERNAL_STORAGE` permission in order to read and write
    files in this directory because it is owned by the creating application.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 的早期版本中，外部存储上的所有文件和目录都分配了相同的所有者和权限，但 Android 4.4 对应用程序特定的外部文件目录（*Android/data/<package-name>/*，确切路径由`Context.getExternalFilesDir()`方法返回）进行了不同的处理。应用程序不必持有
    `WRITE_EXTERNAL_STORAGE` 权限，就可以在该目录中读写文件，因为该目录的所有者是创建该文件的应用程序。
- en: That said, even in Android 4.4, the application’s external files directory is
    accessible by any application that holds the `READ_EXTERNAL_STORAGE` or `WRITE_EXTERNAL_STORAGE`
    permissions because the group of the directory is set to *sdcard_r*, as shown
    in [Example 4-18](ch04.html#owner_and_permissions_of_an_appapostroph "Example 4-18. Owner
    and permissions of an app’s external files directory").
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，即使在 Android 4.4 中，任何持有 `READ_EXTERNAL_STORAGE` 或 `WRITE_EXTERNAL_STORAGE`
    权限的应用程序仍可以访问应用程序的外部文件目录，因为该目录的组设置为*sdcard_r*，如[示例 4-18](ch04.html#owner_and_permissions_of_an_appapostroph
    "示例 4-18. 应用程序外部文件目录的所有者和权限")所示。
- en: Example 4-18. Owner and permissions of an app’s external files directory
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-18. 应用程序外部文件目录的所有者和权限
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Android 4.4 supports a more flexible permission derivation mode that is based
    on directory structure, and which is specified by passing the `-d` option to the
    *sdcard* daemon. This derivation mode sets dedicated groups to the directories
    *Pictures/* and *Music/* (*sdcard_pics* ➊ and *sdcard_av* ➋, as shown in [Example 4-19](ch04.html#directory_owners_and_permission_in_the_n
    "Example 4-19. Directory owners and permission in the new permission derivation
    mode")), which allows for fine-grained control over which files applications can
    access. As of this writing, Android doesn’t support such fine-grained access control,
    but it can easily be implemented by defining additional permissions that map to
    the *sdcard_pics* and *sdcard_av* groups. In the directory-structure-based permission
    mode, user directories are hosted under *Android/user/* ➌.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Android 4.4 支持一种更灵活的权限派生模式，该模式基于目录结构，并通过传递 `-d` 选项给 *sdcard* 守护进程来指定。此派生模式将专用组分配给
    *Pictures/* 和 *Music/* 目录（如[示例 4-19](ch04.html#directory_owners_and_permission_in_the_n
    "示例 4-19. 新权限派生模式下的目录所有者和权限")中所示，分别为 *sdcard_pics* ➊ 和 *sdcard_av* ➋），从而实现对应用程序可以访问的文件的精细控制。根据本文撰写时的情况，Android
    尚不支持这种精细的访问控制，但可以通过定义额外的权限来实现，这些权限映射到 *sdcard_pics* 和 *sdcard_av* 组。在基于目录结构的权限模式中，用户目录托管在
    *Android/user/* ➌ 下。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*While this new permission derivation mode is supported in Android 4.4, as
    of this writing, Nexus devices still use the legacy permission mode.*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管 Android 4.4 支持这种新的权限派生模式，但在撰写本文时，Nexus 设备仍使用传统的权限模式。*'
- en: Example 4-19. Directory owners and permission in the new permission derivation
    mode
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-19. 新权限派生模式下的目录所有者和权限
- en: '[PRE19]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Other Multi-User Features
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他多用户功能
- en: Besides dedicated app directories, external storage and settings, other Android
    features also support a multi-user device configuration. For example, as of version
    4.4, Android’s credential storage (which allows for secure management of cryptographic
    keys) lets each user have their own key storage. (We discuss credential storage
    in more detail in [Chapter 7](ch07.html "Chapter 7. Credential Storage").)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 除了专用的应用目录、外部存储和设置，其他 Android 功能也支持多用户设备配置。例如，从 4.4 版本开始，Android 的凭证存储（用于安全管理加密密钥）允许每个用户拥有自己的密钥存储。（我们在[第
    7 章](ch07.html "第 7 章. 凭证存储")中将详细讨论凭证存储。）
- en: In addition, Android’s online account database, accessible via the `AccountManager`
    API, has been extended to allow secondary users to have their own accounts, as
    well as to allow restricted profiles to share some of the primary user’s accounts
    (if the app that needs account access supports it). We discuss online account
    support and the `AccountManager` API in [Chapter 8](ch08.html "Chapter 8. Online
    Account Management").
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Android 的在线账户数据库可以通过 `AccountManager` API 访问，现已扩展，允许次要用户拥有自己的账户，并且允许限制性配置文件共享部分主用户的账户（如果需要账户访问的应用支持该功能）。我们在[第
    8 章](ch08.html "第 8 章. 在线账户管理")中讨论了在线账户支持和 `AccountManager` API。
- en: And finally, Android allows setting different device administration policies
    for each user. As of version 4.4, it also supports setting up per-user VPNs that
    only route a single user’s traffic and which are not accessible by other users.
    (We discuss device administration, VPNs, and other enterprise features in [Chapter 9](ch09.html
    "Chapter 9. Enterprise Security").)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Android 允许为每个用户设置不同的设备管理策略。从 4.4 版本开始，它还支持为每个用户设置 VPN，仅路由单个用户的流量，并且其他用户无法访问这些
    VPN。（我们在[第 9 章](ch09.html "第 9 章. 企业安全")中讨论了设备管理、VPN 和其他企业功能。）
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Android allows multiple users to share a device by providing dedicated internal
    and external storage to each user. Multi-user support follows the established
    security model and each user’s applications are assigned a unique UID and run
    in dedicated processes that cannot access other user’s data. User isolation is
    achieved by combining a UID assignment scheme that takes into account the user
    ID and storage mounting rules that allow each user to only see their own storage.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Android 允许多个用户共享设备，通过为每个用户提供专用的内部和外部存储。多用户支持遵循既定的安全模型，每个用户的应用程序被分配一个唯一的 UID，并在专用进程中运行，不能访问其他用户的数据。用户隔离是通过结合考虑用户
    ID 的 UID 分配方案和允许每个用户只查看自己存储的存储挂载规则来实现的。
- en: As of this writing, multi-user support is only available on devices without
    telephony support (usually tablets), as the behavior of telephony in a multi-user
    environment is currently undefined. Most Android features, including account database
    management, credential storage, device policies, and VPN support are multi-user-aware
    and allow each user to have their own configuration.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本文写作时，多用户支持仅在不支持电话功能的设备（通常是平板电脑）上可用，因为在多用户环境中，电话功能的行为目前尚未定义。大多数 Android 功能，包括账户数据库管理、凭证存储、设备策略和
    VPN 支持，都具有多用户意识，允许每个用户拥有自己的配置。
- en: '* * *'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[29](#ch04fn01)]) Google, *Android 4.4 Compatibility Definition,* “9.5\.
    Multi-User Support,” *[http://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf](http://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf)*
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[29](#ch04fn01)]) Google, *Android 4.4 兼容性定义,* “9.5\. 多用户支持，” *[http://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf](http://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf)*
- en: ^([[30](#ch04fn02)]) Google, “External Storage Technical Information,” *[http://source.android.com/devices/tech/storage/index.html](http://source.android.com/devices/tech/storage/index.html)*
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[30](#ch04fn02)]) Google, “外部存储技术信息，” *[http://source.android.com/devices/tech/storage/index.html](http://source.android.com/devices/tech/storage/index.html)*
- en: ^([[31](#ch04fn03)]) “Filesystem in Userspace,” *[http://fuse.sourceforge.net/](http://fuse.sourceforge.net/)*
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[31](#ch04fn03)]) “用户空间中的文件系统，” *[http://fuse.sourceforge.net/](http://fuse.sourceforge.net/)*
- en: ^([[32](#ch04fn04)]) Google, *Android 4.4 Compatibility Definition,* “9.5\.
    Multi-User Support,” *[http://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf](http://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf)*
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[32](#ch04fn04)]) Google, *Android 4.4 兼容性定义,* “9.5\. 多用户支持，” *[http://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf](http://static.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf)*
- en: '^([[33](#ch04fn05)]) Michael Kerrisk, *The Linux Programming Interface: A Linux
    and UNIX System Programming Handbook*, No Starch Press, 2010, pp. 261'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[33](#ch04fn05)]) Michael Kerrisk, *《Linux 编程接口：Linux 和 UNIX 系统编程手册》*, No
    Starch Press, 2010, 第 261 页
- en: ^([[34](#ch04fn06)]) Ibid., 598
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[34](#ch04fn06)]) 同上，第 598 页
- en: ^([[35](#ch04fn07)]) Ibid., 603
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[35](#ch04fn07)]) 同上，第 603 页
- en: ^([[36](#ch04fn08)]) Linux Kernel, *Shared Subtrees*, *[https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt](https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt)*
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[36](#ch04fn08)]) Linux 内核, *共享子树*, *[https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt](https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt)*
- en: '^([[37](#ch04fn09)]) Google, “External Storage: Typical Configuration Examples,”
    *[http://source.android.com/devices/tech/storage/config-example.html](http://source.android.com/devices/tech/storage/config-example.html)*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[37](#ch04fn09)]) Google, “外部存储：典型配置示例，” *[http://source.android.com/devices/tech/storage/config-example.html](http://source.android.com/devices/tech/storage/config-example.html)*
