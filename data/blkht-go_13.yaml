- en: '13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '13'
- en: HIDING DATA WITH STEGANOGRAPHY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用隐写术隐藏数据
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common.jpg)'
- en: The word *steganography* is a combination of the Greek words *steganos*, which
    means to cover, conceal, or protect, and *graphien*, which means to write. In
    security, *steganography* refers to techniques and procedures used to obfuscate
    (or hide) data by implanting it within other data, such as an image, so it can
    be extracted at a future point in time. As part of the security community, you’ll
    explore this practice on a routine basis by hiding payloads that you’ll recover
    after they are delivered to the target.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*隐写术*这个词由希腊词*steganos*（意味着覆盖、隐藏或保护）和*graphien*（意味着写）组成。在安全领域，*隐写术*指的是通过将数据植入到其他数据中（如图像）来模糊（或隐藏）数据的技术和程序，以便在未来某个时间点提取。作为安全社区的一部分，你将定期进行这种实践，通过隐藏有效载荷并在其传递给目标后恢复它们。'
- en: In this chapter, you’ll implant data within a Portable Network Graphics (PNG)
    image. You’ll first explore the PNG format and learn how to read PNG data. You’ll
    then implant your own data into the existing image. Finally, you’ll explore XOR,
    a method for encrypting and decrypting your implanted data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将把数据植入到便携式网络图形（PNG）图像中。你将首先探索PNG格式并学习如何读取PNG数据。然后，你将把自己的数据植入现有图像中。最后，你将探索XOR，这是一种加密和解密植入数据的方法。
- en: Exploring the PNG Format
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索PNG格式
- en: Let’s start by reviewing the PNG specification, which will help you understand
    the PNG image format and how to implant data into a file. You can find its technical
    specification at [*http://www.libpng.org/pub/png/spec/1.2/PNG-Structure.html*](http://www.libpng.org/pub/png/spec/1.2/PNG-Structure.html).
    It provides details about the byte format of a binary PNG image file, which is
    made up of repetitive byte chunks.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从回顾PNG规范开始，它将帮助你理解PNG图像格式以及如何将数据植入文件中。你可以在[*http://www.libpng.org/pub/png/spec/1.2/PNG-Structure.html*](http://www.libpng.org/pub/png/spec/1.2/PNG-Structure.html)找到其技术规范。它提供了关于二进制PNG图像文件字节格式的详细信息，这些文件由重复的字节块组成。
- en: Open a PNG file within a hex editor and navigate through each of the relevant
    byte chunk components to see what each does. We’re using the native hexdump hex
    editor on Linux, but any hex editor should work. You can find the sample image
    that we’ll open at [*https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/images/battlecat.png*](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/images/battlecat.png);
    however, all valid PNG images will follow the same format.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在十六进制编辑器中打开一个PNG文件，浏览每个相关的字节块组件，查看每个组件的作用。我们在Linux上使用的是原生的hexdump十六进制编辑器，但任何十六进制编辑器都可以工作。你可以在[*https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/images/battlecat.png*](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/images/battlecat.png)找到我们将要打开的示例图像；不过，所有有效的PNG图像都会遵循相同的格式。
- en: The Header
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 头部
- en: The first 8 bytes of the image file, `89 50 4e 47 0d 0a 1a 0a`, highlighted
    in [Figure 13-1](ch13.xhtml#ch13fig1), are called the *header*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图像文件的前8个字节，`89 50 4e 47 0d 0a 1a 0a`，在[图13-1](ch13.xhtml#ch13fig1)中高亮显示，被称为*头部*。
- en: '![Image](Images/13fig01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/13fig01.jpg)'
- en: '*Figure 13-1: The PNG file’s header*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-1：PNG文件的头部*'
- en: The second, third, and fourth hex values literally read `PNG` when converted
    to ASCII. The arbitrary trailing bytes consist of both DOS and Unix Carriage-Return
    Line Feed (CRLF). This specific header sequence, referred to as a file’s *magic
    bytes*, will be identical in every valid PNG file. The variations in content occur
    in the remaining chunks, as you’ll soon see.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第二、三、四个十六进制值转换为ASCII时会字面读取为`PNG`。任意的尾随字节包括DOS和Unix的回车换行符（CRLF）。这个特定的头部序列，被称为文件的*魔术字节*，在每个有效的PNG文件中都会是相同的。内容的变化发生在其余的字节块中，正如你很快会看到的那样。
- en: As we work through this spec, let’s start to build a representation of the PNG
    format in Go. It’ll help us expedite our end goal of embedding payloads. Since
    the header is 8 bytes long, it can be packed into a `uint64` data type, so let’s
    go ahead and build a struct called `Header` that will hold the value ([Listing
    13-1](ch13.xhtml#ch13list1)). (All the code listings at the root location of /
    exist under the provided github repo *[https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)*.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们研究这个规范时，让我们开始用Go构建一个PNG格式的表示。它将帮助我们加快嵌入有效载荷的最终目标。由于头部长度为8个字节，它可以打包到一个`uint64`数据类型中，所以我们可以构建一个名为`Header`的结构体来保存该值（[清单13-1](ch13.xhtml#ch13list1)）。(所有位于根目录的代码清单都在提供的GitHub仓库[*https://github.com/blackhat-go/bhg/*](https://github.com/blackhat-go/bhg/)下。)
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 13-1: Header struct definition (*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-1：Header结构体定义（*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
- en: The Chunk Sequence
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 块序列
- en: 'The remainder of the PNG file, shown in [Figure 13-2](ch13.xhtml#ch13fig2),
    is composed of repeating byte chunks that follow this pattern: `SIZE` (4 bytes),
    `TYPE` (4 bytes), `DATA` (any number of bytes), and `CRC` (4 bytes).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: PNG文件的其余部分，如[图13-2](ch13.xhtml#ch13fig2)所示，由重复的字节块组成，遵循以下模式：`SIZE`（4字节）、`TYPE`（4字节）、`DATA`（任意字节数）和`CRC`（4字节）。
- en: '![Image](Images/13fig02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/13fig02.jpg)'
- en: '*Figure 13-2: The pattern of the chunks used for the remainder of the image
    data*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-2：其余图像数据的块模式*'
- en: Reviewing the hex dump in further detail, you can see that the first chunk—the
    `SIZE` chunk—consists of bytes `0x00 0x00 0x00 0x0d`. This chunk defines the length
    of the `DATA` chunk that’ll follow. The hexadecimal conversion to ASCII is 13—so
    this chunk dictates that the `DATA` chunk will consist of 13 bytes. The `TYPE`
    chunk’s bytes, `0x49 0x48 0x44 0x52`, convert to an ASCII value of `IHDR` in this
    case. The PNG spec defines various valid types. Some of these types, such as `IHDR`,
    are used to define image metadata or signal the end of an image data stream. Other
    types, specifically the `IDAT` type, contain the actual image bytes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步查看十六进制转储，你可以看到第一个块——`SIZE`块——由字节`0x00 0x00 0x00 0x0d`组成。这个块定义了接下来的`DATA`块的长度。其十六进制转换为ASCII值为13——所以这个块规定`DATA`块将由13个字节组成。`TYPE`块的字节`0x49
    0x48 0x44 0x52`转换为ASCII值`IHDR`。PNG规范定义了各种有效的类型。其中一些类型，如`IHDR`，用于定义图像元数据或指示图像数据流的结束。其他类型，特别是`IDAT`类型，包含实际的图像字节。
- en: Next is the `DATA` chunk, whose length is defined by the `SIZE` chunk. Finally,
    the `CRC` chunk concludes the overall chunk segment. It consists of a CRC-32 checksum
    of the combined `TYPE` and `DATA` bytes. This particular `CRC` chunk’s bytes are
    `0x9a 0x76 0x82 0x70`. This format repeats itself throughout the entire image
    file until you reach an End of File (EOF) state, indicated by the chunk of type
    `IEND`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`DATA`块，其长度由`SIZE`块定义。最后，`CRC`块结束整个块段。它由`TYPE`和`DATA`字节的CRC-32校验和组成。这个特定的`CRC`块的字节为`0x9a
    0x76 0x82 0x70`。该格式在整个图像文件中重复，直到遇到文件结束（EOF）状态，表示为`IEND`类型的块。
- en: Just as you did with the `Header` struct in [Listing 13-1](ch13.xhtml#ch13list1),
    build a struct to hold the values of a single chunk, as defined in [Listing 13-2](ch13.xhtml#ch13list2).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在[列表13-1](ch13.xhtml#ch13list1)中对`Header`结构体所做的那样，构建一个结构体来保存单个块的值，如[列表13-2](ch13.xhtml#ch13list2)所定义。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 13-2: Chunk struct definition (*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-2：块结构定义（*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
- en: Reading Image Byte Data
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取图像字节数据
- en: The Go language handles binary data reads and writes with relative ease, thanks
    in part to the `binary` package (which you may remember from [Chapter 6](ch06.xhtml#ch6)),
    but before you can parse PNG data, you’ll need to open a file for reading. Let’s
    create a `PreProcessImage()` function that will consume a file handle of type
    `*os.File` and return a type of `*bytes.Reader` ([Listing 13-3](ch13.xhtml#ch13list3)).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言通过`binary`包相对轻松地处理二进制数据的读写（你可能还记得[第6章](ch06.xhtml#ch6)中提到过它），但在解析PNG数据之前，你需要打开一个文件进行读取。我们来创建一个`PreProcessImage()`函数，它将消耗一个类型为`*os.File`的文件句柄，并返回一个类型为`*bytes.Reader`的值（[列表13-3](ch13.xhtml#ch13list3)）。
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 13-3: The* PreProcessImage() *function definition (*[/ch-13/imgInject/utils/reader.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/utils/reader.go)*)*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-3：* PreProcessImage() *函数定义（*[/ch-13/imgInject/utils/reader.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/utils/reader.go)*)*'
- en: The function opens a file object in order to obtain a `FileInfo` structure ❶
    used to grab size information ❷. Immediately following are a couple of lines of
    code used to instantiate a `Reader` instance via `bufio.NewReader()` and then
    a `*bytes.Reader` instance via a call to `bytes.NewReader()` ❸. The function returns
    a `*bytes.Reader`, which positions you to start using the `binary` package to
    read byte data. You’ll first read the header data and then read the chunk sequence.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数打开一个文件对象以获取`FileInfo`结构体❶，用于获取文件大小信息❷。接下来是几行代码，用于通过`bufio.NewReader()`实例化一个`Reader`实例，然后通过调用`bytes.NewReader()`实例化一个`*bytes.Reader`实例❸。该函数返回一个`*bytes.Reader`，使你能够开始使用`binary`包来读取字节数据。你将首先读取头部数据，然后读取块序列。
- en: Reading the Header Data
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读取头部数据
- en: To validate that the file is actually a PNG file, use the first 8 bytes, which
    define a PNG file, to build the `validate()` method ([Listing 13-4](ch13.xhtml#ch13list4)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证文件是否确实为PNG文件，使用前8个字节来定义PNG文件，并构建`validate()`方法（[示例 13-4](ch13.xhtml#ch13list4)）。
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 13-4: Validating that the file is a PNG file (*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-4：验证文件是否为PNG文件 (*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
- en: Although this method may not seem overly complex, it introduces a couple of
    new items. The first, and the most obvious one, is the `binary.Read()` function
    ❶ that copies the first 8 bytes from the `bytes.Reader` into the `Header` struct
    value. Recall that you declared the `Header` struct field as type `uint64` ([Listing
    13-1](ch13.xhtml#ch13list1)), which is equivalent to 8 bytes. It’s also noteworthy
    that the `binary` package provides methods to read `Most Significant Bit` and
    `Least Significant Bit` formats via `binary.BigEndian` and `binary.LittleEndian`,
    respectively ❷. These functions can also be quite helpful when you’re performing
    binary writes; for example, you could select `BigEndian` to place bytes on the
    wire dictating the use of network byte ordering.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个方法看起来并不复杂，但它引入了一些新的内容。首先，也是最显而易见的一点，是`binary.Read()`函数❶，它将`bytes.Reader`中的前8个字节复制到`Header`结构体的值中。回想一下，你将`Header`结构体字段声明为`uint64`类型（[示例
    13-1](ch13.xhtml#ch13list1)），这相当于8个字节。值得注意的是，`binary`包提供了通过`binary.BigEndian`和`binary.LittleEndian`分别读取`最重要位`和`最不重要位`格式的方法❷。这些函数在执行二进制写入时也非常有用；例如，你可以选择`BigEndian`将字节按网络字节顺序传输到网络上。
- en: The binary endianness function also contains the methods that facilitate the
    marshaling of data types to a literal data type (such as `uint64`). Here, you’re
    creating a byte array of length 8 and performing a binary read necessary to copy
    the data into a `unit64` data type. You can then convert the bytes to their string
    representations and use slicing and a simple string comparison to validate that
    bytes 1 through 4 produce PNG, indicating that you have a valid image file format
    ❸.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制字节序函数还包含了便于将数据类型转化为字面数据类型（如`uint64`）的方法。在这里，你创建了一个长度为8的字节数组，并执行了必要的二进制读取，将数据复制到`unit64`数据类型中。接着，你可以将字节转换为其字符串表示形式，并使用切片和简单的字符串比较来验证字节1到字节4是否生成了PNG，表明你有一个有效的图像文件格式❸。
- en: To improve the process of checking that a file is a PNG file, we encourage you
    to look at the Go `bytes` package, as it contains convenience functions that you
    could use as a shortcut to compare a file header with the PNG magic byte sequence
    we mentioned earlier. We’ll let you explore this on your own.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进检查文件是否为PNG文件的过程，我们鼓励你查看Go语言的`bytes`包，因为它包含一些方便的函数，可以作为捷径，将文件头与我们之前提到的PNG魔术字节序列进行比较。我们会让你自己探索这一部分。
- en: Reading the Chunk Sequence
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读取块序列
- en: Once you validated that your file is a PNG image, you can write the code that
    reads the chunk sequence. The header will occur only once in a PNG file, whereas
    the chunk sequence will repeat the `SIZE`, `TYPE`, `DATA`, and `CRC` chunks until
    it reaches the EOF. Therefore, you need to be able to accommodate this repetition,
    which you can do most conveniently by using a Go conditional loop. With this in
    mind, let’s build out a `ProcessImage()` method, which iteratively processes all
    the data chunks up to the end of file ([Listing 13-5](ch13.xhtml#ch13list5)).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦验证了文件是PNG图像，您就可以编写读取数据块序列的代码。PNG文件中的头信息只会出现一次，而数据块序列会重复`SIZE`、`TYPE`、`DATA`和`CRC`数据块，直到达到文件结尾（EOF）。因此，您需要能够容纳这种重复，最方便的方式是使用Go的条件循环。考虑到这一点，让我们构建一个`ProcessImage()`方法，它会迭代地处理所有数据块，直到文件结尾（[示例13-5](ch13.xhtml#ch13list5)）。
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 13-5: The* ProcessImage() *method (*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例13-5：* ProcessImage() *方法 (*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
- en: You first pass a reference to a `bytes.Reader` memory address pointer (`*bytes.Reader`)
    as an argument to `ProcessImage()` ❶. The `validate()` method ([Listing 13-4](ch13.xhtml#ch13list4))
    you just created also took a reference to a `bytes.Reader` pointer. As convention
    dictates, multiple references to the same memory address pointer location will
    inherently allow mutable access to the referenced data. This essentially means
    that as you pass your `bytes.Reader` reference as an argument to `ProcessImage()`,
    the reader will have already advanced 8 bytes as a result of the size of the `Header`
    because you’re accessing the same instance of `bytes.Reader`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将一个`bytes.Reader`内存地址指针（`*bytes.Reader`）作为参数传递给`ProcessImage()` ❶。您刚刚创建的`validate()`方法（[示例13-4](ch13.xhtml#ch13list4)）也接受一个`bytes.Reader`指针的引用。按照惯例，对同一内存地址指针位置的多个引用会自然地允许对引用数据进行可变访问。这本质上意味着，当您将`bytes.Reader`引用作为参数传递给`ProcessImage()`时，由于您正在访问相同的`bytes.Reader`实例，读取器会在`Header`的大小影响下提前移动8个字节。
- en: Alternatively, had you not passed a pointer, the `bytes.Reader` would have either
    been a copy of the same PNG image data or separate unique instance data. That’s
    because advancing the pointer when you read the header would not have advanced
    the reader appropriately elsewhere. You want to avoid taking this approach. For
    one, passing around multiple copies of data when unnecessary is simply bad convention.
    More importantly, each time a copy is passed, it is positioned at the start of
    the file, forcing you to programmatically define and manage its position in the
    file prior to reading a chunk sequence.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您没有传递指针，`bytes.Reader`将是相同PNG图像数据的副本，或者是一个独立的唯一实例数据。这是因为，在读取头信息时，如果没有推进指针，它不会在其他地方适当地推进读取器。您应该避免采用这种方法。一方面，不必要地传递多个数据副本是一个不好的习惯。更重要的是，每次传递副本时，它都将从文件的开头开始，这迫使您在读取数据块序列之前，编程定义并管理其在文件中的位置。
- en: As you progress through the block of code, you define a `count` variable to
    track how many chunk segments the image file contains. The `chunkType` ❷ and `endChunkType`
    ❸ are used as part of the comparative logic, which evaluates the current `chunkType`
    to `endChunkType`’s `IEND` value designating an EOF condition ❹.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码块的进一步处理中，您定义了一个`count`变量来跟踪图像文件包含多少个数据块段。`chunkType` ❷ 和 `endChunkType` ❸
    用作比较逻辑的一部分，用于评估当前的`chunkType`与`endChunkType`的`IEND`值，该值表示文件结尾（EOF）条件 ❹。
- en: It would be nice to know where each chunk segment starts—or rather, each chunk’s
    absolute position within the file byte construct, a value known as the *offset*.
    If you know the offset value, it will be much easier to implant a payload into
    the file. For example, you can give a collection of offset locations to a *decoder*—a
    separate function that collects the bytes at each known offset—that then unwinds
    them into your intended payload. To get the offsets of each chunk, you’ll call
    the `mc.getOffset(b)` method ([Listing 13-6](ch13.xhtml#ch13list6)).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 知道每个数据块段的起始位置会很有帮助——或者更确切地说，每个数据块在文件字节构造中的绝对位置，这个值称为*偏移量*。如果您知道偏移量值，那么将有效载荷插入文件就会变得容易得多。例如，您可以将一系列偏移位置提供给*解码器*——一个收集每个已知偏移位置字节的单独函数——然后将它们解码为您预期的有效载荷。要获取每个数据块的偏移量，您可以调用`mc.getOffset(b)`方法（[示例13-6](ch13.xhtml#ch13list6)）。
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 13-6: The* getOffset() *method (*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-6：getOffset()方法 (*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
- en: The `bytes.Reader` contains a `Seek()` method that makes deriving the current
    position quite simple. The `Seek()` method moves the current read or write offset
    and then returns the new offset relative to the start of the file. Its first argument
    is the number of bytes by which you want to move the offset and its second argument
    defines the position from which the move will occur. The second argument’s optional
    values are `0` (Start of File), `1` (Current Position), and `2` (End of File).
    For example, if you wanted to shift 8 bytes to the left from your current position,
    you would use `b.Seek(-8,1)`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytes.Reader`包含一个`Seek()`方法，可以轻松地确定当前的位置。`Seek()`方法移动当前的读写偏移量，并返回相对于文件开头的新偏移量。它的第一个参数是你希望移动的字节数，第二个参数定义了从哪个位置开始移动。第二个参数的可选值为`0`（文件开头）、`1`（当前位置）和`2`（文件末尾）。例如，如果你想从当前位置向左移动8个字节，你可以使用`b.Seek(-8,1)`。'
- en: 'Here, `b.Seek(0,1)` ❶ states that you want to move your offset 0 bytes from
    the current position, so it simply returns the current offset: essentially retrieving
    the offset without moving it.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`b.Seek(0,1)` ❶ 表示你希望将偏移量从当前位置移动0个字节，因此它只是返回当前的偏移量：本质上是获取偏移量而不移动它。
- en: The next methods we detail define how you read the actual chunk segment bytes.
    To make things a bit more legible, let’s create a `readChunk()` method and then
    create separate methods for reading each chunk subfield ([Listing 13-7](ch13.xhtml#ch13list7)).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的方法将详细介绍如何读取实际的块段字节。为了使内容更加易读，我们将创建一个`readChunk()`方法，然后为每个块子字段创建单独的方法（[列表13-7](ch13.xhtml#ch13list7)）。
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 13-7: Chunk-reading methods (*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-7：块读取方法 (*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
- en: The methods `readChunkSize()`, `readChunkType()`, and `readChunkCRC()` are all
    similar. Each reads a `uint32` value into the respective field of the `Chunk`
    struct. However, `readChunkBytes()` is a bit of an anomaly. Because the image
    data is of variable length, we’ll need to supply this length to the `readChunkBytes()`
    function so that it knows how many bytes to read ❶. Recall that the data length
    is maintained in the `SIZE` subfield of the chunk. You identify the `SIZE` value
    ❷ and pass it as an argument to `readChunkBytes()` to define a slice of proper
    size ❸. Only then can the byte data be read into the struct’s `Data` field. That’s
    about it for reading the data, so let’s press on and explore writing byte data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`readChunkSize()`、`readChunkType()`和`readChunkCRC()`方法都是类似的。每个方法都将一个`uint32`值读取到`Chunk`结构体的相应字段中。然而，`readChunkBytes()`有些不同。由于图像数据的长度是可变的，我们需要将这个长度提供给`readChunkBytes()`函数，以便它知道读取多少字节
    ❶。回想一下，数据长度保存在块的`SIZE`子字段中。你需要识别`SIZE`值 ❷，并将其作为参数传递给`readChunkBytes()`，以定义一个合适大小的切片
    ❸。只有这样，字节数据才能被读取到结构体的`Data`字段中。读取数据的过程就到这里为止，接下来我们继续探索如何写入字节数据。'
- en: Writing Image Byte Data to Implant a Payload
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将图像字节数据写入以植入有效载荷
- en: Although you can choose from many complex steganography techniques to implant
    payloads, in this section we’ll focus on a method of writing to a certain byte
    offset. The PNG file format defines *critical* and *ancillary* chunk segments
    within the specification. The critical chunks are necessary for the image decoder
    to process the image. The ancillary chunks are optional and provide various pieces
    of metadata that are not critical to encoding or decoding, such as timestamps
    and text.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以选择许多复杂的隐写术技术来植入有效载荷，但在这一部分中，我们将重点介绍一种写入特定字节偏移量的方法。PNG文件格式在规范中定义了*关键*和*辅助*块段。关键块是图像解码器处理图像所必需的。辅助块是可选的，提供了各种元数据，这些元数据对编码或解码并不关键，例如时间戳和文本。
- en: Therefore, the ancillary chunk type provides an ideal location to either overwrite
    an existing chunk or insert a new chunk. Here, we’ll show you how to insert new
    byte slices into an ancillary chunk segment.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，辅助块类型提供了一个理想的位置，用于覆盖现有块或插入新块。在这里，我们将展示如何将新的字节切片插入到辅助块段中。
- en: Locating a Chunk Offset
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定位块偏移
- en: First, you need to identify an adequate offset somewhere in the ancillary data.
    You can spot ancillary chunks because they always start with lowercase letters.
    Let’s use the hex editor once again and open up the original PNG file while advancing
    to the end of the hex dump.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在附加数据中找到一个合适的偏移量。你可以通过附加块的首字母是小写字母来识别它们。让我们再次使用十六进制编辑器，打开原始 PNG 文件，并继续向十六进制转储的末尾前进。
- en: Every valid PNG image will have an `IEND` chunk type indicating the final chunk
    of the file (the `EOF` chunk). Moving to the 4 bytes that come before the final
    `SIZE` chunk will position you at the starting offset of the `IEND` chunk and
    the last of the arbitrary (critical or ancillary) chunks contained within the
    overall PNG file. Recall that ancillary chunks are optional, so it’s possible
    that the file you’re inspecting as you follow along won’t have the same ancillary
    chunks, or any for that matter. In our example, the offset to the `IEND` chunk
    begins at byte offset `0x85258` ([Figure 13-3](ch13.xhtml#ch13fig3)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每个有效的 PNG 图像都会有一个 `IEND` 块类型，指示文件的最后一个块（`EOF` 块）。移动到紧接在最后的 `SIZE` 块前的 4 个字节，会将你定位到
    `IEND` 块的起始偏移量，以及 PNG 文件中包含的最后一个任意（关键或附加）块。请记住，附加块是可选的，因此在你跟随示例检查文件时，文件中可能没有相同的附加块，甚至没有任何附加块。在我们的示例中，`IEND`
    块的偏移量从字节偏移 `0x85258` 开始（[图 13-3](ch13.xhtml#ch13fig3)）。
- en: '![Image](Images/13fig03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/13fig03.jpg)'
- en: '*Figure 13-3: Identifying a chunk offset relative to the IEND position*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-3：相对于 IEND 位置识别块的偏移量*'
- en: Writing Bytes with the ProcessImage() Method
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 ProcessImage() 方法写入字节
- en: A standard approach to writing ordered bytes into a byte stream is to use a
    Go struct. Let’s revisit another section of the `ProcessImage()` method we started
    building in [Listing 13-5](ch13.xhtml#ch13list5) and walk through the details.
    The code in [Listing 13-8](ch13.xhtml#ch13list8) calls individual functions that
    you’ll build out as you progress through this section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将有序字节写入字节流的标准方法是使用 Go 结构体。让我们回顾一下我们在 [清单 13-5](ch13.xhtml#ch13list5) 中开始构建的
    `ProcessImage()` 方法的另一个部分，并逐步分析其细节。[清单 13-8](ch13.xhtml#ch13list8) 中的代码调用了你将在本节中逐步构建的各个函数。
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 13-8: Writing bytes with the* `ProcessImage()` *method (*[/ch-13/imgInject/pnglib
    /commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-8：使用* `ProcessImage()` *方法写入字节（*[/ch-13/imgInject/pnglib /commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
- en: This method takes a `byte.Reader` and another struct, `models.CmdLineOpts`,
    as arguments ❶. The `CmdLineOpts` struct, shown in [Listing 13-9](ch13.xhtml#ch13list9),
    contains flag values passed in via the command line. We’ll use these flags to
    determine what payload to use and where to insert it in the image data. Since
    the bytes you’ll write follow the same structured format as those read from preexisting
    chunk segments, you can just create a new `MetaChunk` struct instance ❷ that will
    accept your new chunk segment values.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个 `byte.Reader` 和另一个结构体 `models.CmdLineOpts` 作为参数 ❶。`CmdLineOpts` 结构体，如
    [清单 13-9](ch13.xhtml#ch13list9) 所示，包含通过命令行传递的标志值。我们将使用这些标志来确定使用什么有效负载，并确定将其插入图像数据的位置。由于你将写入的字节遵循与从现有块段中读取的字节相同的结构化格式，你可以创建一个新的
    `MetaChunk` 结构体实例 ❷，它将接受新的块段值。
- en: The next step is to read the payload into a byte slice ❸. However, you’ll need
    additional functionality to coerce the literal flag values into a usable byte
    array. Let’s dive into the details of the `strToInt()` ❹, `createChunkSize()`
    ❺, `createChunkCRC()` ❻, `MarshalData()` ❼, and `WriteData()` ❽ methods.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将有效负载读取到字节切片中 ❸。然而，你需要额外的功能来强制将文字标志值转换为可用的字节数组。让我们深入了解 `strToInt()` ❹、`createChunkSize()`
    ❺、`createChunkCRC()` ❻、`MarshalData()` ❼ 和 `WriteData()` ❽ 方法的细节。
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 13-9: The* CmdLineOpts *struct (*[/ch-13/imgInject/models/opts.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/models/opts.go)*)*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-9：* CmdLineOpts *结构体（*[/ch-13/imgInject/models/opts.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/models/opts.go)*)*'
- en: The strToInt() Method
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: strToInt() 方法
- en: We’ll start with the `strToInt()` method ([Listing 13-10](ch13.xhtml#ch13list10)).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `strToInt()` 方法开始（[清单 13-10](ch13.xhtml#ch13list10)）。
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 13-10: The* strToInt() *method (*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-10：* strToInt() *方法（*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
- en: The `strToInt()` method is a helper that consumes a `string` ❶ as an argument
    and returns `uint32` ❷, which is the necessary data type for your `Chunk` struct
    `TYPE` value.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`strToInt()`方法是一个辅助函数，它接受一个`string` ❶作为参数，并返回`uint32` ❷，这是你`Chunk`结构体`TYPE`值所需的数据类型。'
- en: The createChunkSize() Method
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: createChunkSize() 方法
- en: Next, you use the `createChunkSize()` method to assign the `Chunk` struct `SIZE`
    value ([Listing 13-11](ch13.xhtml#ch13list11)).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你使用`createChunkSize()`方法为`Chunk`结构体的`SIZE`值分配空间（[Listing 13-11](ch13.xhtml#ch13list11)）。
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 13-11: The* createChunkSize() *method (*/[ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-11: The* createChunkSize() *method (*/[ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
- en: This method will obtain the length of the `chk.DATA` byte array ❷ and type-convert
    it to a `uint32` value ❶.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将获取`chk.DATA`字节数组的长度 ❷，并将其类型转换为`uint32`值 ❶。
- en: The createChunkCRC() Method
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: createChunkCRC() 方法
- en: Recall that the CRC checksum for each chunk segment comprises both the `TYPE`
    and `DATA` bytes. You’ll use the `createChunkCRC()` method to calculate this checksum.
    The method leverages Go’s `hash/crc32` package ([Listing 13-12](ch13.xhtml#ch13list12)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，每个块段的CRC校验和包含了`TYPE`和`DATA`字节。你将使用`createChunkCRC()`方法来计算这个校验和。该方法利用Go的`hash/crc32`包（[Listing
    13-12](ch13.xhtml#ch13list12)）。
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 13-12: The* createChunkCRC() *method (*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-12: The* createChunkCRC() *method (*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
- en: Prior to arriving at the `return` statement, you declare a `bytes.Buffer` ❶
    and write both the `TYPE` ❷ and `DATA` ❸ bytes into it. The byte slice from the
    buffer is then passed as an argument to the `ChecksumIEEE`, and the CRC-32 checksum
    value is returned as a `uint32` data type. The `return` statement ❹ is doing all
    the heavy lifting here, actually calculating the checksum on the necessary bytes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在到达`return`语句之前，你声明了一个`bytes.Buffer` ❶，并将`TYPE` ❷和`DATA` ❸字节写入其中。然后，缓冲区中的字节切片作为参数传递给`ChecksumIEEE`，并返回CRC-32校验值，数据类型为`uint32`。`return`语句
    ❹ 在这里起到了重要作用，实际上它在必要的字节上计算了校验和。
- en: The marshalData() Method
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: marshalData() 方法
- en: All necessary pieces of a chunk are assigned to their respective struct fields,
    which can now be marshaled into a `bytes.Buffer`. This buffer will provide the
    raw bytes of the custom chunk that are to be inserted into the new image file.
    [Listing 13-13](ch13.xhtml#ch13list13) shows what the `marshalData()` method looks
    like.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 块的所有必要部分都被分配到各自的结构体字段中，现在可以将它们序列化成一个`bytes.Buffer`。该缓冲区将提供要插入新图像文件中的自定义块的原始字节。[Listing
    13-13](ch13.xhtml#ch13list13)显示了`marshalData()`方法的样子。
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 13-13: The* marshalData() *method (*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-13: The* marshalData() *method (*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
- en: The `marshalData()` method declares a `bytes.Buffer` ❶ and writes the chunk
    information to it, including the size ❷, type ❸, data ❹, and checksum ❺. The method
    returns all the chunk segment data into a single consolidated `bytes.Buffer`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`marshalData()`方法声明了一个`bytes.Buffer` ❶，并将块信息写入其中，包括大小 ❷、类型 ❸、数据 ❹和校验和 ❺。该方法将所有块段数据返回到一个合并后的`bytes.Buffer`中。'
- en: The WriteData() Function
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: WriteData() 函数
- en: Now all you have left to do is to write your new chunk segment bytes into the
    offset of the original PNG image file. Let’s have a peek at the `WriteData()`
    function, which exists in a package we created named `utils` ([Listing 13-14](ch13.xhtml#ch13list14)).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你要做的就是将新的块段字节写入原始PNG图像文件的偏移位置。让我们看一眼`WriteData()`函数，它存在于我们创建的一个名为`utils`的包中（[Listing
    13-14](ch13.xhtml#ch13list14)）。
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 13-14: The* WriteData() *function (*[/ch-13/imgInject/utils/writer.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/utils/writer.go)*)*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-14: The* WriteData() *function (*[/ch-13/imgInject/utils/writer.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/utils/writer.go)*)*'
- en: The `WriteData()` function consumes a `bytes.Reader` ❶ containing the original
    image file byte data, a `models.CmdLineOpts` ❷ struct inclusive of the command
    line argument values, and a `byte` slice ❸ holding the new chunk byte segment.
    The code block starts with a `string`-to-`int64` conversion ❹ in order to obtain
    the offset value from the `models.CmdLineOpts` struct; this will help you write
    your new chunk segment to a specific location without corrupting other chunks.
    You then create a file handle ❺ so that the newly modified PNG image can be written
    to disk.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteData()` 函数接受一个包含原始图像文件字节数据的 `bytes.Reader` ❶、一个包含命令行参数值的 `models.CmdLineOpts`
    ❷ 结构体，以及一个保存新块字节段的 `byte` 切片 ❸。代码块从一个 `string` 到 `int64` 的转换 ❹ 开始，以便从 `models.CmdLineOpts`
    结构体中获取偏移值；这将帮助你将新的块段写入到指定的位置，而不会破坏其他块。接着，你创建一个文件句柄 ❺，以便将修改后的 PNG 图像写入磁盘。'
- en: You use the `r.Seek(0,0)` function call ❻ to rewind to the absolute beginning
    of the `bytes.Reader`. Recall that the first 8 bytes are reserved for the PNG
    header, so it’s important that the new output PNG image include these header bytes
    as well. You include them by instantiating a byte slice with a length determined
    by the `offset` value ❼. You then read that number of bytes from the original
    image and write those same bytes to your new image file ❽. You now have identical
    headers in both the original and new images.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 `r.Seek(0,0)` 函数调用 ❻ 将指针重置到 `bytes.Reader` 的绝对开始位置。回想一下，前 8 个字节保留给 PNG 头部，因此新生成的
    PNG 图像也必须包含这些头部字节。你通过实例化一个字节切片来包含这些字节，长度由 `offset` 值 ❼ 确定。然后，你从原始图像中读取这些字节，并将它们写入到新的图像文件
    ❽ 中。现在，你在原始图像和新图像中都有了相同的头部。
- en: You then write the new chunk segment bytes ❾ into the new image file. Finally,
    you append the remainder of the `bytes.Reader` bytes ❿ (that is, the chunk segment
    bytes from your original image) to the new image file. Recall that `bytes.Reader`
    has advanced to the offset location, because of the earlier read into a byte slice,
    which contains bytes from the offset to the EOF. You’re left with a new image
    file. Your new file has identical leading and trailing chunks as the original
    image, but it also contains your payload, injected as a new ancillary chunk.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将新的块段字节 ❾ 写入新的图像文件中。最后，你将 `bytes.Reader` 中剩余的字节 ❿（即来自原始图像的块段字节）追加到新图像文件中。回想一下，`bytes.Reader`
    已经前移到偏移位置，因为之前已经将其读取到一个字节切片中，切片包含从偏移位置到文件末尾的字节。你现在得到了一个新的图像文件。你的新文件与原始图像在前后块上完全相同，但它还包含你注入的负载，作为一个新的附加块。
- en: To help visualize a working representation of what you built so far, reference
    the overall working project code at *[https://github.com/blackhat-go/bhg/tree/master/ch-13/imgInject/](https://github.com/blackhat-go/bhg/tree/master/ch-13/imgInject)*.
    The `imgInject` program consumes command line arguments containing values for
    the original PNG image file, an offset location, an arbitrary data payload, the
    self-declared arbitrary chunk type, and the output filename for your modified
    PNG image file, as shown in [Listing 13-15](ch13.xhtml#ch13list15).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助可视化你目前构建的工作表示，可以参考整个工作项目的代码 *[https://github.com/blackhat-go/bhg/tree/master/ch-13/imgInject/](https://github.com/blackhat-go/bhg/tree/master/ch-13/imgInject/)*。`imgInject`
    程序接受包含原始 PNG 图像文件、偏移位置、任意数据负载、自声明的任意块类型以及修改后的 PNG 图像文件输出文件名等命令行参数，如 [Listing 13-15](ch13.xhtml#ch13list15)
    所示。
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 13-15: Running the* imgInject *command line program*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-15: 运行 imgInject 命令行程序*'
- en: If everything went as planned, `offset 0x85258` should now contain a new `rNDm`
    chunk segment, as shown in [Figure 13-4](ch13.xhtml#ch13fig4).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，`offset 0x85258` 现在应该包含一个新的 `rNDm` 块段，如 [Figure 13-4](ch13.xhtml#ch13fig4)
    所示。
- en: '![Image](Images/13fig04.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/13fig04.jpg)'
- en: '*Figure 13-4: A payload injected as an ancillary chunk (such as rNDm)*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 13-4: 作为附加块（如 rNDm）注入的负载*'
- en: Congratulations—you’ve just written your first steganography program!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你——你刚刚编写了第一个隐写术程序！
- en: Encoding and Decoding Image Byte Data by Using XOR
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 XOR 编码和解码图像字节数据
- en: Just as there are many types of steganography, so are there many techniques
    used to obfuscate data within a binary file. Let’s continue to build the sample
    program from the previous section. This time, you’ll include obfuscation to hide
    the true intent of your payload.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如存在许多类型的隐写术一样，也有许多技术用于在二进制文件中混淆数据。让我们继续构建上一节的示例程序。这次，你将加入混淆技术，以隐藏你负载的真实意图。
- en: Obfuscation can help conceal your payload from network-monitoring devices and
    endpoint security solutions. If, for example, you’re embedding raw shellcode used
    for spawning a new Meterpreter shell or Cobalt Strike beacon, you want to make
    sure it avoids detection. For this, you’ll use Exclusive OR bitwise operations
    to encrypt and decrypt the data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆可以帮助隐藏你的有效载荷，避免被网络监控设备和终端安全解决方案检测到。例如，如果你嵌入的是用于生成新的 Meterpreter shell 或 Cobalt
    Strike beacon 的原始 shellcode，你需要确保它能够避开检测。为此，你将使用异或按位操作来加密和解密数据。
- en: An *Exclusive OR* *(XOR)* is a conditional comparison between two binary values
    that produces a Boolean true value if and only if the two values are not the same,
    and a Boolean false value otherwise. In other words, the statement is true if
    either *x* or *y* are true—but not if both are true. You can see this represented
    in [Table 13-1](ch13.xhtml#ch13tab1), given that *x* and *y* are both binary input
    values.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*异或*（*XOR*）是一种条件比较，比较两个二进制值，如果且仅当两个值不同时，返回布尔真值，否则返回布尔假值。换句话说，若 *x* 或 *y* 中有一个为真，则该语句为真——但如果两者都为真，则为假。如[表
    13-1](ch13.xhtml#ch13tab1)所示，*x* 和 *y* 都是二进制输入值。'
- en: '**Table 13-1:** XOR Truth Table'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-1：** 异或真值表'
- en: '| **x** | **y** | **x ^ y output** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **x** | **y** | **x ^ y 输出** |'
- en: '| 0 | 1 | True or 1 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 真或 1 |'
- en: '| 1 | 0 | True or 1 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 真或 1 |'
- en: '| 0 | 0 | False or 0 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 假或 0 |'
- en: '| 1 | 1 | False or 0 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 假或 0 |'
- en: You can use this logic to obfuscate data by comparing the bits in the data to
    the bits of a secret key. When two values match, you change the bit in the payload
    to 0, and when they differ, you change it to 1\. Let’s expand the code you created
    in the previous section to include an `encodeDecode()` function, along with `XorEncode()`
    and `XorDecode()` functions. We’ll insert these functions into the `utils` package
    ([Listing 13-16](ch13.xhtml#ch13list16)).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将数据中的比特与密钥的比特进行比较来使用此逻辑进行数据混淆。当两个值匹配时，你将有效载荷中的比特改为 0，当它们不同时，你将其改为 1。让我们扩展你在上一节中创建的代码，加入一个
    `encodeDecode()` 函数，以及 `XorEncode()` 和 `XorDecode()` 函数。我们将把这些函数插入到 `utils` 包中（[列表
    13-16](ch13.xhtml#ch13list16)）。
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 13-16: The* encodeDecode() *function (*[/ch-13/imgInject/utils/encoders.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/utils/encoders.go)*)*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-16：* encodeDecode() *函数（*[/ch-13/imgInject/utils/encoders.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/utils/encoders.go)）*'
- en: The `encodeDecode()` function consumes a byte slice containing the payload ❶
    and a secret key value ❷ as arguments. A new byte slice, `bArr` ❸, is created
    within the function’s inner scope and initialized to the input byte length value
    (the length of the payload). Next, the function uses a conditional loop to iterate
    over each index position of input byte array.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`encodeDecode()` 函数接收一个包含有效载荷 ❶ 和一个密钥值 ❷ 的字节切片作为参数。在函数的内部作用域中创建一个新的字节切片 `bArr`
    ❸，并将其初始化为输入字节长度值（有效载荷的长度）。接下来，函数使用条件循环遍历输入字节数组的每个索引位置。'
- en: Within the inner conditional loop, each iteration XORs the current index’s binary
    value with a binary value derived from the modulo of the current index value and
    length of the secret key ❹. This allows you to use a key that is shorter than
    your payload. When the end of the key is reached, the modulo will force the next
    iteration to use the first byte of the key. Each XOR operation result is written
    to the new `bArr` byte slice, and the function returns the resulting slice.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部条件循环中，每次迭代都将当前索引的二进制值与从当前索引值和密钥长度的模值 ❹ 派生出的二进制值进行异或操作。这允许你使用比有效载荷更短的密钥。当密钥的末尾被处理时，模运算将强制下一次迭代使用密钥的第一个字节。每次异或操作的结果被写入新的
    `bArr` 字节切片，函数返回结果切片。
- en: The functions in [Listing 13-17](ch13.xhtml#ch13list17) wrap the `encodeDecode()`
    function to facilitate the encoding and decoding process.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13-17](ch13.xhtml#ch13list17) 中的函数包装了 `encodeDecode()` 函数，以便简化编码和解码过程。'
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 13-17: The* XorEncode() *and* XorDecode() *functions (*[/ch-13/imgInject/utils/encoders.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/utils/encoders.go)*)*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-17：* XorEncode() *和* XorDecode() *函数（*[/ch-13/imgInject/utils/encoders.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/utils/encoders.go)）*'
- en: You define two functions, `XorEncode()` and `XorDecode()`, which take the same
    literal arguments ❶ and return the same values ❷. That’s because you decode XOR-encoded
    data by using the same process used to encode the data. However, you define these
    functions separately, to provide clarity within the program code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义了两个函数，`XorEncode()`和`XorDecode()`，它们接受相同的字面参数❶并返回相同的值❷。这是因为你通过使用与编码数据时相同的过程来解码XOR编码的数据。然而，你将这些函数分开定义，以便在程序代码中提供清晰性。
- en: To use these XOR functions in your existing program, you’ll have to modify the
    `ProcessImage()` logic you created in [Listing 13-8](ch13.xhtml#ch13list8). These
    updates will leverage the `XorEncode()` function to encrypt the payload. The modifications,
    shown in [Listing 13-18](ch13.xhtml#ch13list18), assume you’re using command line
    arguments to pass values to conditional encode and decode logic.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要在现有程序中使用这些 XOR 函数，你需要修改在[清单 13-8](ch13.xhtml#ch13list8)中创建的`ProcessImage()`逻辑。这些更新将利用`XorEncode()`函数来加密有效载荷。修改内容如[清单
    13-18](ch13.xhtml#ch13list18)所示，假设你正在使用命令行参数将值传递给条件编码和解码逻辑。
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 13-18: Updating* ProcessImage() *to include XOR encoding (*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-18：更新`ProcessImage()`以包括XOR编码 (*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
- en: The function call to `XorEncode()` ❶ passes a `byte` slice containing the payload
    and secret key, XORs the two values, and returns a byte slice, which is assigned
    to `chk.Data`. The remaining functionality remains unchanged and marshals the
    new chunk segment to eventually be written to an image file.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对`XorEncode()`❶的函数调用传入一个包含有效载荷和密钥的`byte`切片，对这两个值进行XOR运算，并返回一个`byte`切片，该切片被赋值给`chk.Data`。其余功能保持不变，并将新的块段序列化以最终写入图像文件。
- en: The command line run of your program should produce a result similar to the
    one in [Listing 13-19](ch13.xhtml#ch13list19).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你程序的命令行运行应该产生类似于[清单 13-19](ch13.xhtml#ch13list19)中的结果。
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 13-19: Running the* imgInject *program to XOR encode a data chunk
    block*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-19：运行`imgInject`程序对数据块进行XOR编码*'
- en: The `payload` is written to a byte representation and displayed to stdout as
    `Payload Original` ❶. The `payload` is then XORed with a `key` value of `gophers`
    and displayed to stdout as `Payload Encode` ❷.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload`被写入字节表示并显示到标准输出为`Payload Original`❶。然后，`payload`与`gophers`的`key`值进行XOR运算，并显示为`Payload
    Encode`❷。'
- en: To decrypt your payload bytes, you use the decode function, as in [Listing 13-20](ch13.xhtml#ch13list20).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解密你的有效载荷字节，你需要使用解码函数，如[清单 13-20](ch13.xhtml#ch13list20)所示。
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 13-20: Decoding the image file and payload (*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-20：解码图像文件和有效载荷 (*[/ch-13/imgInject/pnglib/commands.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/pnglib/commands.go)*)*'
- en: The block requires the offset position of the chunk segment that contains the
    payload ❶. You use the offset to `Seek()` ❷ the file position, along with a subsequent
    call to `readChunk()` ❸ that’s necessary to derive the `SIZE`, `TYPE`, `DATA`,
    and `CRC` values. A call to `XorDecode()` ❹ takes the `chk.Data` payload value
    and the same secret key used to encode the data, and then assigns the decoded
    payload value back to `chk.Data`. (Remember that this is symmetric encryption,
    so you use the same key to both encrypt and decrypt the data.) The code block
    continues by calling `marshalData()` ❺, which converts your `Chunk` struct to
    a `byte` slice. Finally, you write the new chunk segment containing the decoded
    payload to a file by using the `WriteData()` function ❻.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码块要求包含有效载荷的块段的偏移位置❶。你使用偏移量来`Seek()`❷文件位置，并随后的`readChunk()`❸调用是必要的，用于推导`SIZE`、`TYPE`、`DATA`和`CRC`值。调用`XorDecode()`❹时，将`chk.Data`有效载荷值和用于编码数据的相同密钥传入，然后将解码后的有效载荷值重新分配回`chk.Data`。（请记住，这是对称加密，所以你使用相同的密钥进行加密和解密。）代码块继续通过调用`marshalData()`❺，将你的`Chunk`结构转换为`byte`切片。最后，你通过使用`WriteData()`函数❻将包含解码有效载荷的新块段写入文件。
- en: A command line run of your program, this time with a decode argument, should
    produce the result in [Listing 13-21](ch13.xhtml#ch13list21).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你程序的命令行运行，这次带有解码参数，应该产生[清单 13-21](ch13.xhtml#ch13list21)中的结果。
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 13-21: Running the* imgInject *program to XOR decode a data chunk
    block*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-21：运行`imgInject`程序对数据块进行XOR解码*'
- en: The `Payload Original` value ❶ is the encoded payload data read from the original
    PNG file, while the `Payload Decode` value ❷ is the decrypted payload. If you
    compare your sample command line run from before and the output here, you’ll notice
    that your decoded payload matches the original, cleartext value you supplied originally.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Payload Original`值❶是从原始PNG文件中读取的编码负载数据，而`Payload Decode`值❷是解密后的负载数据。如果你比较之前的示例命令行运行和此处的输出，你会注意到解码后的负载与你最初提供的原始明文值匹配。'
- en: There is a problem with the code, though. Recall that the program code injects
    your new decoded chunk at an offset position of your specification. If you have
    a file that already contains the encoded chunk segment and then attempt to write
    a new file with a decoded chunk segment, you’ll end up with both chunks in the
    new output file. You can see this in [Figure 13-5](ch13.xhtml#ch13fig5).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，代码中存在一个问题。回想一下，程序代码将新的解码块插入到你指定的偏移位置。如果你有一个已经包含编码块段的文件，然后尝试写入一个带有解码块段的新文件，你最终会在新输出文件中看到两个块段。你可以在[图13-5](ch13.xhtml#ch13fig5)中看到这一点。
- en: '![Image](Images/13fig05.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/13fig05.jpg)'
- en: '*Figure 13-5: The output file contains both the decoded chunk segment and encoded
    chunk segment.*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-5：输出文件包含解码块段和编码块段。*'
- en: To understand why this happens, recall that the encoded PNG file has the encoded
    chunk segment at offset `0x85258`, as shown in [Figure 13-6](ch13.xhtml#ch13fig6).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么会发生这种情况，请回顾一下，编码后的PNG文件在偏移位置`0x85258`处包含编码块段，如[图13-6](ch13.xhtml#ch13fig6)所示。
- en: '![Image](Images/13fig06.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/13fig06.jpg)'
- en: '*Figure 13-6: The output file containing the encoded chunk segment*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-6：包含编码块段的输出文件*'
- en: The problem presents itself when the decoded data is written to offset `0x85258`.
    When the decoded data gets written to the same location as the encoded data, our
    implementation doesn’t delete the encoded data; it merely shifts the remainder
    of the file bytes to the right, including the encoded chunk segment, as illustrated
    previously in [Figure 13-5](ch13.xhtml#ch13fig5). This can complicate payload
    extraction or produce unintended consequences, such as revealing the cleartext
    payload to network devices or security software.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出现在解码数据被写入偏移位置`0x85258`时。当解码数据被写入与编码数据相同的位置时，我们的实现并没有删除编码数据；它只是将文件的其余字节右移，包括编码块段，如之前在[图13-5](ch13.xhtml#ch13fig5)中所示。这可能会使负载提取变得复杂，或产生意外后果，例如将明文负载暴露给网络设备或安全软件。
- en: Fortunately, this issue is quite easy to resolve. Let’s take a look at our previous
    `WriteData()` function. This time, you can modify it to address the problem ([Listing
    13-22](ch13.xhtml#ch13list22)).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个问题很容易解决。我们来看看之前的`WriteData()`函数。这次，你可以修改它来解决这个问题（[代码清单13-22](ch13.xhtml#ch13list22)）。
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 13-22: Updating* WriteData() *to prevent duplicate ancillary chunk
    types (*[/ch-13/imgInject/utils/writer.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/utils/writer.go)*)*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单13-22：更新* WriteData() *以防止重复的辅助块类型*（[/ch-13/imgInject/utils/writer.go](https://github.com/blackhat-go/bhg/blob/master/ch-13/imgInject/utils/writer.go)）'
- en: You introduce the fix with the `c.Decode` conditional logic ❶. The XOR operation
    produces a byte-for-byte transaction. Therefore, the encoded and decoded chunk
    segments are identical in length. Furthermore, the `bytes.Reader` will contain
    the remainder of the original encoded image file at the moment the decoded chunk
    segment is written. So, you can perform a right byte shift comprising the length
    of the decoded chunk segment on the `bytes.Reader` ❷, advancing the `bytes.Reader`
    past the encoded chunk segment and writing the remainder of bytes to your new
    image file ❸.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过`c.Decode`的条件逻辑❶引入了修复。XOR操作按字节进行转换。因此，编码和解码的块段在长度上是相同的。此外，当解码块段被写入时，`bytes.Reader`将包含原始编码图像文件的剩余部分。因此，你可以对`bytes.Reader`执行一个右字节移位，移位的长度为解码块段的长度❷，将`bytes.Reader`推进到编码块段之后，并将剩余的字节写入新的图像文件❸。
- en: Voila! As you can see in [Figure 13-7](ch13.xhtml#ch13fig7), the hex editor
    confirms that you resolved the problem. No more duplicate ancillary chunk types.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！如[图13-7](ch13.xhtml#ch13fig7)所示，十六进制编辑器确认你已解决问题。不再有重复的辅助块类型。
- en: '![Image](Images/13fig07.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/13fig07.jpg)'
- en: '*Figure 13-7: The output file without duplicate ancillary data*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-7：没有重复辅助数据的输出文件*'
- en: The encoded data no longer exists. Additionally, running ls -la against the
    files should produce identical file lengths, even though file bytes have changed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 编码数据不再存在。此外，运行 `ls -la` 命令查看文件时，应该会显示相同的文件长度，尽管文件字节已经发生变化。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to describe the PNG image file format as a
    series of repetitive byte chunk segments, each with its respective purpose and
    applicability. Next, you learned methods of reading and navigating the binary
    file. Then you created byte data and wrote it to an image file. Finally, you used
    XOR encoding to obfuscate your payload.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何将 PNG 图像文件格式描述为一系列重复的字节块段，每个块段都有其相应的目的和适用性。接着，您学习了读取和浏览二进制文件的方法。然后，您创建了字节数据并将其写入图像文件。最后，您使用
    XOR 编码来混淆有效负载。
- en: This chapter focused on image files and only scratched the surface of what you
    can accomplish by using steganography techniques. But you should be able to apply
    what you learned here to explore other binary file types.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讲解了图像文件，并仅仅触及了使用隐写术技术可以实现的部分内容。但您应该能够将所学的知识应用到其他二进制文件类型的探索中。
- en: Additional Exercises
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加练习
- en: 'Like many of the other chapters in this book, this chapter will provide the
    most value if you actually code and experiment along the way. Therefore, we want
    to conclude with a few challenges to expand on the ideas already covered:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本书中的许多其他章节一样，本章如果您在实际编写代码和实验的过程中学习，将会提供最大的价值。因此，我们希望通过以下几个挑战来总结本章内容，扩展已经涵盖的思想：
- en: While reading the XOR section, you may have noticed that the `XorDecode()` function
    produces a decoded chunk segment, but never updates the CRC checksum. See if you
    can correct this issue.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在阅读 XOR 部分时，您可能已经注意到，`XorDecode()` 函数生成了解码后的数据块段，但从未更新 CRC 校验和。看看您能否修正这个问题。
- en: The `WriteData()` function facilitates the ability to inject arbitrary chunk
    segments. What code changes would you have to make if you wanted to overwrite
    existing ancillary chunk segments? If you need help, our explanation about byte
    shifting and the `Seek()` function may be useful in solving this problem.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WriteData()` 函数支持注入任意块段。假如您想要覆盖现有的附加块段，您需要做哪些代码修改？如果您需要帮助，我们关于字节移位和 `Seek()`
    函数的解释可能会对解决这个问题有所帮助。'
- en: 'Here’s a more challenging problem: try to inject a payload—the PNG `DATA` byte
    chunk—by distributing it throughout various ancillary chunk segments. You could
    do this one byte at a time, or with multiple groupings of bytes, so get creative.
    As an added bonus, create a decoder that reads exact payload byte offset locations,
    making it easier to extract the payload.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个更具挑战性的问题：尝试通过将有效负载——PNG `DATA` 字节块——分散到各个附加块段中来注入有效负载。您可以一次注入一个字节，或者使用多个字节分组，因此可以发挥创造力。作为额外奖励，创建一个解码器来读取确切的有效负载字节偏移位置，这样可以更轻松地提取有效负载。
- en: The chapter explained how to use XOR as a confidentiality technique—a method
    to obfuscate the implanted payload. Try to implement a different technique, such
    as AES encryption. Go core packages provide a number of possibilities (see [Chapter
    11](ch11.xhtml#ch11) if you need a refresher). Observe how the solution affects
    the new image. Does it cause the overall size to increase, and if so, by how much?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章解释了如何使用 XOR 作为一种保密技术——一种混淆植入有效负载的方法。尝试实现另一种技术，例如 AES 加密。Go 核心包提供了多种可能性（如果您需要复习，请参考[第
    11 章](ch11.xhtml#ch11)）。观察这个解决方案如何影响新图像。它是否导致整体大小增加，如果增加了，增加了多少？
- en: Use the code ideas within this chapter to expand support for other image file
    formats. Other image specifications may not be as organized as PNG. Want proof?
    Give the PDF specification a read, as it can be rather intimidating. How would
    you solve the challenges of reading and writing data to this new image format?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本章中的代码思路，扩展对其他图像文件格式的支持。其他图像规范可能不像 PNG 那样结构化。想要证明吗？阅读 PDF 规范，它可能会让人感到相当有压力。您如何解决读取和写入此新图像格式数据的挑战？
